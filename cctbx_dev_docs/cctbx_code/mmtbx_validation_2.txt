

 *******************************************************************************
mmtbx/validation/molprobity/probescore_ligand.py
from __future__ import absolute_import, division, print_function
from cctbx.array_family import flex
from libtbx import easy_run
from libtbx.utils import Sorry
import sys

class probescore_result():
  def __init__(self, model_piece, probe_sel, id_str, nuclear):
    self.id_str = id_str
    self.probe_lines = None
    self.probe_lines = self.run_probescore(model_piece, probe_sel, nuclear)
    self.result = self.parse_probescore_lines(self.probe_lines)

  def run_probescore(self, pdb_string, sel_str, nuclear):
    #run probescore on a subset of the model
    if nuclear:
      nuclear_flag = "-nuclear"
    else:
      nuclear_flag = ""
    probe_command = 'phenix.probe -c -both %s "%s" "not (%s)" -' % (nuclear_flag,sel_str,sel_str)
    probe_out = easy_run.fully_buffered(probe_command, stdin_lines=pdb_string)
    if (probe_out.return_code != 0):
      raise RuntimeError("Probe crashed - dumping stderr:\n%s" %
        "\n".join(probe_out.stderr_lines))
    probe_unformatted = probe_out.stdout_lines
    probe_lines = probe_out.stdout_lines
    return probe_lines

  def print_as_raw(self, out=sys.stdout):
    #print complete raw probe output
    print("\n----------------------------------------")
    print("Selection: %s" % self.id_str)
    for line in self.probe_lines:
      print(line, file=out)
    print("Selection: %s" % self.id_str)
    print("----------------------------------------")

  def print_as_digest(self, out=sys.stdout):
    #print a human-readable digest of the results
    ligand = self.result["ligand"]
    nonligand = self.result["nonligand"]
    if int(ligand["max_dots"]) == 0:
      ligand_dots_percent = 0
    else:
      ligand_dots_percent = float(ligand["contact_dots"])/float(ligand["max_dots"])*100
    if float(ligand["max_area"]) == 0:
      ligand_area_percent = 0
    else:
      ligand_area_percent = float(ligand["contact_area"])/float(ligand["max_area"])*100
    total_probescore = float(ligand["total_score"])+float(nonligand["total_score"])
    print("\nSelection: %s" % self.id_str)
    print("Selection dots: %s / %s = %.2f%%" % (ligand["contact_dots"],ligand["max_dots"],ligand_dots_percent), file=out)
    print("Selection contact area: %s / %s A^2 = %.2f%%" % (ligand["contact_area"],ligand["max_area"],ligand_area_percent), file=out)
    print("                     score  normalized", file=out)
    print("selection Hbond:  %8s %11s" % (ligand["hb_score"],ligand["hb_score_norm"]), file=out)
    print("selection Overlap:%8s %11s" % (ligand["overlap_score"],ligand["overlap_score_norm"]), file=out)
    print("selection Vdw:    %8s %11s" % (ligand["vdw_score"],ligand["vdw_score_norm"]), file=out)
    print("sum of contacts:  %8s %11s" % (ligand["total_score"],ligand["total_score_norm"]), file=out)
    print("\nprobescore:  %13s" % (total_probescore), file=out)
    print("\n")

  def print_as_oneline(self, filename="", out=sys.stdout):
    #print digest content as a single machine-readable line
    ligand = self.result["ligand"]
    nonligand = self.result["nonligand"]
    if int(ligand["max_dots"]) == 0:
      ligand_dots_percent = 0
    else:
      ligand_dots_percent = float(ligand["contact_dots"])/float(ligand["max_dots"])*100
    if float(ligand["max_area"]) == 0:
      ligand_area_percent = 0
    else:
      ligand_area_percent = float(ligand["contact_area"])/float(ligand["max_area"])*100
    total_probescore = float(ligand["total_score"])+float(nonligand["total_score"])
    print(":".join([filename,
                    self.id_str,
                    ligand["atoms"],
                    ligand["contact_dots"],
                    ligand["max_dots"],
                    "%.2f" % ligand_dots_percent,
                    ligand["contact_area"],
                    ligand["max_area"],
                    "%.2f" % ligand_area_percent,
                    ligand["hb_score"],
                    ligand["hb_score_norm"],
                    ligand["overlap_score"],
                    ligand["overlap_score_norm"],
                    ligand["vdw_score"],
                    ligand["vdw_score_norm"],
                    ligand["total_score"],
                    ligand["total_score_norm"],
                    "%.2f" % total_probescore]))

  def parse_probescore_lines(self, probescore_lines):
    ligand_section = False
    other_section = False
    for line in probescore_lines:
      #output has a 1->2 section for contacts from the ligand
      # and a 2->1 section for contacts from the rest of the structure.
      if line.startswith("subgroup: 1->2"):
        ligand_section = True
        other_section = False
      elif line.startswith("subgroup: 2->1"):
        ligand_section = False
        other_section = True
      #-----
      if ligand_section:
        if line.startswith("atoms"):
          ligand_atoms_selected = line.split()[2]
        elif line.startswith("potential dots"):
          ligand_potential_dots = line.split()[2]
        elif line.startswith("potential area"):
          ligand_potential_area = line.split()[2]
        #-----
        elif line.startswith("     tot contact"):
          ligand_vdw_score = line.split()[4]
          ligand_vdw_score_normalized  = line.split()[5]
        elif line.startswith("     tot overlap"):
          ligand_o_score = line.split()[4]
          ligand_o_score_normalized  = line.split()[5]
        elif line.startswith("     tot  H-bond"):
          ligand_hb_score = line.split()[4]
          ligand_hb_score_normalized  = line.split()[5]
        elif line.startswith("       grand tot"):
          ligand_total_dots = line.split()[2]
          ligand_total_score = line.split()[4]
          ligand_total_score_normalized  = line.split()[5]
        elif line.startswith("contact"):
          ligand_contact_area = line.split()[3]
      if other_section:
        #contacts from protein/na/other to the ligand
        #atom selection  is variable, based on "within",
        #  so normalization and area aren't very meaningful
        if line.startswith("atoms"):
          other_atoms_selected = line.split()[2]
        elif line.startswith("potential dots"):
          other_potential_dots = line.split()[2]
        elif line.startswith("potential area"):
          other_potential_area = line.split()[2]
        #-----
        elif line.startswith("     tot contact"):
          other_vdw_score = line.split()[4]
          #other_vdw_score_normalized  = line.split()[5]
        elif line.startswith("     tot overlap"):
          other_o_score = line.split()[4]
          #other_o_score_normalized  = line.split()[5]
        elif line.startswith("     tot  H-bond"):
          other_hb_score = line.split()[4]
          #other_hb_score_normalized  = line.split()[5]
        elif line.startswith("       grand tot"):
          other_total_dots = line.split()[2]
          other_total_score = line.split()[4]
          #other_total_score_normalized  = line.split()[5]
        elif line.startswith("contact"):
          other_contact_area = line.split()[3]

    ligand = {"atoms":ligand_atoms_selected,
              "max_dots":ligand_potential_dots,
              "contact_dots":ligand_total_dots,
              "max_area":ligand_potential_area,
              "contact_area":ligand_contact_area,
              "vdw_score":ligand_vdw_score,
              "vdw_score_norm":ligand_vdw_score_normalized,
              "hb_score":ligand_hb_score,
              "hb_score_norm":ligand_hb_score_normalized,
              "overlap_score":ligand_o_score,
              "overlap_score_norm":ligand_o_score_normalized,
              "total_score":ligand_total_score,
              "total_score_norm":ligand_total_score_normalized
              }
    nonligand = {"atoms":other_atoms_selected,
              "max_dots":other_potential_dots,
              "contact_dots":other_total_dots,
              "max_area":other_potential_area,
              "contact_area":other_contact_area,
              "vdw_score":other_vdw_score,
              #"vdw_score_norm":other_vdw_score_normalized,
              "hb_score":other_hb_score,
              #"hb_score_norm":other_hb_score_normalized,
              "overlap_score":other_o_score,
              #"overlap_score_norm":other_o_score_normalized,
              "total_score":other_total_score,
              #"total_score_norm":other_total_score_normalized
              }
    return {"ligand":ligand, "nonligand":nonligand}

class probescore():
  def __init__(self, model, selection_string_list, has_h, nuclear=False, out=sys.stdout):
    self.atoms = model.get_atoms()
    self.all_bsel = flex.bool(self.atoms.size(), False)
    self.results = []
    if not has_h:
      model_piece = self.add_hydrogens(model, nuclear=nuclear)
      ###TODO: read the Reduce'd version back in and do the model_piece thing on it
      ###This will be good for kinemage printing, if I get there
    for sel_str in selection_string_list:
      probe_sel, id_str = self.convert_to_probe_sel(model, sel_str)
      #probe_sel is the selection string rendered into probe syntax "chainA  100|chainA  350"
      #id_str is human readable for printing "A ASP 100,A SPD 350"
      if has_h:
        model_piece = self.get_model_piece(model, sel_str)
      self.results.append(probescore_result(model_piece, probe_sel, id_str, nuclear))

  def print_as_raw(self, out=sys.stdout):
    #print complete raw probe output
    for result in self.results:
      result.print_as_raw(out=out)

  def print_as_digest(self, out=sys.stdout):
    #print a human-readable digest of the results
    for result in self.results:
      result.print_as_digest(out=out)

  def print_as_oneline(self, filename=None, out=sys.stdout):
    #print digest content as a single machinereadable line
    header = ["input_file",
              "selection",
              "atoms",
              "contact_dots",
              "max_dots",
              "dots_percent",
              "contact_area",
              "max_area",
              "area_percent",
              "hb_score",
              "hb_score_norm",
              "overlap_score",
              "overlap_score_norm",
              "vdw_score",
              "vdw_score_norm",
              "total_score",
              "total_score_norm",
              "probescore"]
    print(":".join(header),file=out)
    for result in self.results:
      result.print_as_oneline(filename=filename, out=out)

  def convert_to_probe_sel(self, model, sel_str):
    #convert a Phenix selection string to a probe one
    #make the selection in Phenix,
    #then make a probe string enumerating every atom in the selection
    #instead, find the involved residues
    #this is gross, but is guarantees the same selection
    isel = model.iselection(string=sel_str)
    self.all_bsel.set_selected(isel, True)
    probe_residues = []
    id_strs = []
    for atom in self.atoms.select(isel):
      atomname = atom.name
      atomname = atomname.replace(" ","_") #probe uses _ chars for spaces in atom names for clarity
      resid = atom.parent().id_str()
      #ag.id_str() format: " TYR A  30 "
      altloc = resid[0:1]
      resname = resid[1:4]
      chain = resid[4:6].strip()
      resseq = resid[6:10]
      icode = resid[10:11].strip()
      probe_res_str = "chain%s %s%s" % (chain,resseq,icode)
      id_str = "%s %s%s%s" % (chain,resname,resseq,icode)
      probe_residues.append(probe_res_str)
      id_strs.append(id_str)
    unique_residues = set(probe_residues)
    unique_id_strs = set(id_strs)
    probe_sel = "|".join(unique_residues)
    id_str = ",".join(unique_id_strs)
    return probe_sel, id_str

  def add_hydrogens(self,model,nuclear=False):
    from mmtbx.validation.clashscore import check_and_add_hydrogen
    hierarchy = model.get_hierarchy()
    reduce_str, check = check_and_add_hydrogen(
      pdb_hierarchy=hierarchy,
      file_name=None,
      nuclear=nuclear,
      keep_hydrogens=True,
      verbose=False,
      model_number=0,
      n_hydrogen_cut_off=0,
      time_limit=120,
      allow_multiple_models=True,
      crystal_symmetry=None,
      do_flips=False,
      log=None)
    #There should be a check here for whether Reduce completed
    return reduce_str

  def get_model_piece(self, model, sel_str):
    #use "within" to get the relevant atoms from the model
    #convert those atoms to PDB string for into to probe
    #using subset of atoms should make probe faster for big models
    wide_selection = "within(%i, %s)" % (5, sel_str)
    isel = model.iselection(string=wide_selection)
    self.all_bsel.set_selected(isel, True)
    atom_list = []
    for atom in self.atoms.select(isel):
      atom_list.append(atom.format_atom_record())
    if not atom_list:
      raise Sorry('no atoms selected for "%s", please check selection' % sel_str)
    pdb_string = "\n".join(atom_list)
    return pdb_string

  def run_probescore(self, pdb_string, sel_str):
    #run probescore on a subset of the model
    probe_command = 'phenix.probe -c -both "%s" "not (%s)" -' % (sel_str,sel_str)
    probe_out = easy_run.fully_buffered(probe_command, stdin_lines=pdb_string)
    if (probe_out.return_code != 0):
      raise RuntimeError("Probe crashed - dumping stderr:\n%s" %
        "\n".join(probe_out.stderr_lines))
    probe_unformatted = probe_out.stdout_lines
    result = probe_out.stdout_lines
    return result



 *******************************************************************************


 *******************************************************************************
mmtbx/validation/molprobity/table_from_json.py
from __future__ import division
import os, sys
import json

red = '#ff9999'
yellow = '#ffff99'
green = '#99ff99'

def make_reskey(model_id, chain_id, resseq, icode):
  #create a unique string residue key with mmCIF-like placeholders for blank fields
  #The residue key is space-delimited
  return ' '.join([model_id.strip() or '.', chain_id.strip() or '.', resseq.strip(), icode.strip() or '?'])

class merged_validations():
  def __init__(self, hierarchy):
    self.data = {}
    self.indices = [] #reskeys in the same order as hierarchy
    self.validation_types = []
    self.summaries = {}
    self.model_ids = []
    for model in hierarchy.models():
      model_id = model.id.strip()
      self.model_ids.append(model_id)
      for chain in model.chains():
        chain_id = chain.id.strip()
        for rg in chain.residue_groups():
          #alts with different resnames?
          resseq = rg.resseq.strip()
          icode = rg.icode.strip()
          reskey = make_reskey(model_id, chain_id, resseq, icode)
          self.indices.append(reskey)
          self.data[reskey] = residue(rg, model_id, chain_id, resseq, icode)

  def add_summaries(self, json_list):
    for val_json in json_list:
      self.add_summary(val_json)

  def add_summary(self, val_json):
    val_type = val_json["validation_type"]
    self.summaries[val_type] = val_json["summary_results"]

  def add_validations(self, json_list):
    for val_json in json_list:
      val_type = val_json["validation_type"]
      #some validations especially those with multiple results per residue require special loading
      #these are clashscore, bond lengths, bond angles, chirals
      self.validation_types.append(val_type)
      if val_type == "clashscore":
        self.add_clashscore(val_json)
      elif val_type in ["mp_bonds", "mp_angles"]:
        self.add_geometry(val_json)
      else:
        self.add_validation(val_json)
    for reskey in self.data:
      #print(reskey)
      self.data[reskey].get_alternates()

  def add_validation(self, val_json):
    val_type = val_json["validation_type"]
    for result in val_json["flat_results"]:
      reskey = make_reskey(result["model_id"], result["chain_id"], result["resseq"].strip(), result["icode"])
      if not self.data[reskey].validations.get(val_type):
        self.data[reskey].validations[val_type] = {}
      self.data[reskey].validations[val_type][result["altloc"].strip()] = result
      if result["outlier"]:
        self.data[reskey].has_outlier = True

  def add_clashscore(self, val_json):
    assert val_json["validation_type"] == "clashscore"
    #each contact only gets one clash entry, so it needs to be stired twice for the residue table
    #  once for the source and once for the target
    #Usage of clash info should check whether reskey == srcreskey
    #  if not, then treat the target as the source
    for result in val_json["flat_results"]:
      srcreskey = make_reskey(result["model_id"], result["chain_id"], result["resseq"], result["icode"])
      if not self.data[srcreskey].validations.get("clashscore"):
        self.data[srcreskey].validations["clashscore"] = {}
      if not self.data[srcreskey].validations["clashscore"].get(result["altloc"].strip()):
        self.data[srcreskey].validations["clashscore"][result["altloc"].strip()] = []
      self.data[srcreskey].validations["clashscore"][result["altloc"].strip()].append(result)
      self.data[srcreskey].has_outlier = True

      trgreskey = make_reskey(result["model_id"], result["target_chain_id"], result["target_resseq"], result["target_icode"])
      if not self.data[trgreskey].validations.get("clashscore"):
        self.data[trgreskey].validations["clashscore"] = {}
      if not self.data[trgreskey].validations["clashscore"].get(result["target_altloc"].strip()):
        self.data[trgreskey].validations["clashscore"][result["target_altloc"].strip()] = []
      self.data[trgreskey].validations["clashscore"][result["target_altloc"].strip()].append(result)
      self.data[trgreskey].has_outlier = True
    #once all results are loaded, sort from worst to mildest clash
    for reskey in self.data:
      if not self.data[reskey].validations.get("clashscore"):
        continue
      for altloc in self.data[reskey].validations["clashscore"]:
        #clash overlaps are stored as negative values (vdw gaps would be positive)
        #so default ascending sort should put worst clash first
        self.data[reskey].validations["clashscore"][altloc].sort(key=lambda x: x["overlap"])

  def add_geometry(self, val_json):
    val_type = val_json["validation_type"]
    assert val_type in ["mp_bonds", "mp_angles"]
    for result in val_json["flat_results"]:
      #for both bonds and angles, the measure is assigned to the residue of the second atom (index 1) in the list
      #this only really matters at residue-residue joins
      reskey = make_reskey(result["atoms_model_id"][1], result["atoms_chain_id"][1], result["atoms_resseq"][1], result["atoms_icode"][1])

      #a bond or angle should be a mix of '' and possible a single alternate id
      #if multiple alternate ids are involved in a single bond, this will return the "highest" alternate
      #That's a weird case, and whether it shows up is based on how the hierarchy processes complex alternates.
      altloc = sorted(result["atoms_altloc"], reverse=True)[0].strip()

      if not self.data[reskey].validations.get(val_type):
        self.data[reskey].validations[val_type] = {}
      if not self.data[reskey].validations[val_type].get(altloc):
        self.data[reskey].validations[val_type][altloc] = []
      self.data[reskey].validations[val_type][altloc].append(result)
      self.data[reskey].has_outlier = True #needs to be outliers_only input
    #once all results are loaded, sort from worst to mildest
    #deviations can be too large or too small, so abs() is necessary
    for reskey in self.data:
      if not self.data[reskey].validations.get(val_type):
        continue
      for altloc in self.data[reskey].validations[val_type]:
        self.data[reskey].validations[val_type][altloc].sort(key=lambda x: abs(x["score"]), reverse=True)

  def get_table_order(self):
    #jsons may be received in any order
    master_order = ["clashscore",
                     "ramalyze",
                     "rotalyze",
                     "cbetadev",
                     "cablam",
                     "rna_puckers",
                     "rna_suites",
                     "mp_bonds",
                     "mp_angles",
                     "omegalyze"]
    table_order = []
    for x in master_order:
      if x in self.validation_types:
        table_order.append(x)
    return table_order

  def make_summary_table(self, model, red = '#ff9999', yellow = '#ffff99', green = '#99ff99'):
  # TODO: add a cleverness to do the first model if model==None
    #red = '#ff9999'
    #yellow = '#ffff99'
    #green = '#99ff99'
    lines = []
    table_order = self.get_table_order()
    if model.strip():
      lines.append("<br><b>Summary statistics: Model {model}</b>".format(model))
    else:
      lines.append("<br><b>Summary statistics</b>")
    lines.append("<table width='100%' cellspacing='1' border='2'>")
    lines += self.summary_table_clashscore(model, red, yellow, green)
    lines += self.summary_table_proteins(model, red, yellow, green)
    if "omegalyze" in table_order:
      lines = lines + self.summary_table_peptide_omegas(model, show_all=True)
    lines = lines + self.summary_table_nucleic_acids(model)
    lines = lines + self.summary_table_low_res(model)
    lines = lines + self.summary_table_additional(model)
    lines.append("</table>")
    lines.append(self.under_table_text(table_order))
    print("\n".join(lines))

  def under_table_text(self, table_order):
    notes = []
    notes.append("<small>In the two column results, the left column gives the raw count, right column gives the percentage.</small>")
    notes.append("<br><small>Some validations count different numbers of residues. E.g. Ramachandran's &phi; or &psi; is incomplete at chain ends, and Gly residues have no sidechains for rotamers.</small>")
    if "clashscore" in table_order:
      notes.append("<br><small>100<sup>th</sup> percentile is the best among structures of comparable resolution; 0<sup>th</sup> percentile is the worst.  For clashscore the comparative set of structures was selected in 2004, for MolProbity score in 2006.</small>")
      if "ramalyze" in table_order and "rotalyze" in table_order:
        notes.append("<br><small>MolProbity score combines the clashscore, rotamer, and Ramachandran evaluations into a single score, normalized to be on the same scale as X-ray resolution.</small>")
    if "rna_suites" in table_order:
      notes.append("<br><small>RNA backbone sugar-to-sugar suites are rotameric.  Outliers are RNA suites that don't fall into recognized rotamers.</small>")
    return "\n".join(notes)

  def summary_table_clashscore(self, model, red, yellow, green, resolution=None):
    resolution=2.0
    lines = []
    if "clashscore" in self.summaries:
      from mmtbx.validation.molprobity import percentile_clashscore
      data = self.summaries["clashscore"][model]
      pct_stats = percentile_clashscore.get_percentile_for_clashscore(data["clashscore"], resolution=resolution)
      #pct_stats = {"minres":minres, "maxres":maxres, "count":nSamples, "percentile":pctRank}
      if pct_stats["percentile"] >= 66: color=green
      elif pct_stats["percentile"] < 33: color=red
      else: color=yellow
      #ordinal = lambda n: "%d%s" % (n,"tsnrhtdd"[(n//10%10!=1)*(n%10<4)*n%10::4])
      if not resolution:
        range_text = "(N={count}, all resolutions)".format(count=pct_stats["count"])
      else:
        range_text = "(N={count}, {minres}&Aring; - {maxres}&Aring;)".format(count=pct_stats["count"], minres=pct_stats["minres"], maxres=pct_stats["maxres"])
      lines.append("""  <tr>
    <td align='center'>All-Atom Contacts</td>
    <td>Clashscore, all atoms</td>
    <td colspan='2' bgcolor='{color}'>&nbsp;{clashscore:.2f}</td>
    <td>{percentile}<sup>th</sup> percentile {range_text}</td>
  </tr>""".format(color=color, clashscore=data["clashscore"], percentile=pct_stats["percentile"], range_text=range_text))
    return lines

  def summary_table_proteins(self, model, red, yellow, green, resolution=None):
    protein_lines = []
    rows = 0
    if "rotalyze" in self.summaries:
      rows +=2
      data = self.summaries["rotalyze"][model]
      if data["outlier_percentage"] <= 0.3: color=green
      elif data["outlier_percentage"] > 1.5: color=red
      else: color=yellow
      protein_lines.append("  <tr>")
      protein_lines.append("""    <td>Poor rotamers</td>
    <td bgcolor='{color}'>&nbsp;{num_outliers} / {num_residues}</td>
    <td bgcolor='{color}'>&nbsp;{outlier_percentage:.2f}%</td>
    <td>Goal: &lt;0.3%</td>
  </tr>""".format(color= color, num_outliers=data["num_outliers"], num_residues=data["num_residues"], outlier_percentage=data["outlier_percentage"]))

      if data["num_residues"] == 0:
        color=green #none would be more accurate; does 'transparent' work?
        favored_pct = 0
      else:
        favored_pct = data["num_favored"]/data["num_residues"]*100.0
        if favored_pct >= 98: color=green
        elif favored_pct < 95: color=red
        else: color=yellow
      protein_lines.append("""  <tr>
    <td>Favored rotamers</td>
    <td bgcolor='{color}'>&nbsp;{num_favored} / {num_residues}</td>
    <td bgcolor='{color}'>&nbsp;{favored_pct:.2f}%</td>
    <td>Goal: &gt;98%</td>
  </tr>""".format(color=color, num_favored=data["num_favored"], num_residues=data["num_residues"], favored_pct=favored_pct))

    if "ramalyze" in self.summaries:
      rows += 2
      data = self.summaries["ramalyze"][model]
      if data["outlier_percentage"] <= 0.05: color=green
      elif data["outlier_percentage"] > 0.5 and data["num_outliers"] >= 2: color=red
      else: color=yellow
      protein_lines.append("  <tr>")
      protein_lines.append("""    <td>Ramachandran outliers</td>
    <td bgcolor='{color}'>&nbsp;{num_outliers} / {num_residues}</td>
    <td bgcolor='{color}'>&nbsp;{outlier_percentage:.2f}%</td>
    <td>Goal: &lt;0.05%</td>
  </tr>""".format(color=color, num_outliers=data["num_outliers"], num_residues=data["num_residues"], outlier_percentage=data["outlier_percentage"]))

      if data["favored_percentage"] >= 98: color=green
      elif data["favored_percentage"] < 95: color=red
      else: color=yellow
      protein_lines.append("""  <tr>
    <td>Ramachandran favored</td>
    <td bgcolor='{color}'>&nbsp;{num_favored} / {num_residues}</td>
    <td bgcolor='{color}'>&nbsp;{favored_percentage:.2f}%</td>
    <td>Goal: &gt;98%</td>
  </tr>""".format(color=color, num_favored=data["num_favored"], num_residues=data["num_residues"], favored_percentage=data["favored_percentage"]))

    if "rama_z" in self.summaries:
      #not yet available in json
      #work w/Oleg to get compatible output
      pass

    #MolProbity Score
    if "clashscore" in self.summaries and "ramalyze" in self.summaries and "rotalyze" in self.summaries:
      rows += 1
      from mmtbx.validation.utils import molprobity_score
      from mmtbx.validation.molprobity import percentile_mpscore
      mpscore = molprobity_score(self.summaries["clashscore"][model]["clashscore"],
                                 self.summaries["rotalyze"][model]["outlier_percentage"],
                                 self.summaries["ramalyze"][model]["favored_percentage"])
      pct_stats = percentile_mpscore.get_percentile_for_mpscore(mpscore, resolution=resolution)
      #pct_stats = {"minres":minres, "maxres":maxres, "count":nSamples, "percentile":pctRank}
      if pct_stats["percentile"] >= 66: color=green
      elif pct_stats["percentile"] < 33: color=red
      else: color=yellow
      range_text = "(N={count}, {minres}&Aring; - {maxres}&Aring;)".format(count=pct_stats["count"], minres=pct_stats["minres"], maxres=pct_stats["maxres"])
      protein_lines.append("""  <tr>
    <td>MolProbity score</td>
    <td colspan='2' bgcolor='{color}'>&nbsp;{mpscore:.2f}</td>
    <td>{percentile}<sup>th</sup> percentile {range_text}</td>
  </tr>""".format(color=color, mpscore=mpscore, percentile=pct_stats["percentile"], range_text=range_text))

    if "cbetadev" in self.summaries:
      rows += 1
      data = self.summaries["cbetadev"][model]
      if data["num_outliers"] == 0: color=green
      elif data["outlier_percentage"] >= 5: color=red
      else: color=yellow
      protein_lines.append("  <tr>")
      protein_lines.append("""    <td>C&beta; deviations &gt;0.25&Aring;</td>
    <td bgcolor='{color}'>&nbsp;{num_outliers} / {num_cbeta_residues}</td>
    <td bgcolor='{color}'>&nbsp;{outlier_percentage:.2f}%</td>
    <td>Goal: 0</td>
  </tr>""".format(color=color, num_outliers=data["num_outliers"], num_cbeta_residues=data["num_cbeta_residues"], outlier_percentage=data["outlier_percentage"]))

    if "mp_bonds" in self.summaries and self.summaries["mp_bonds"][model]["num_total_protein"] > 0:
      rows += 1
      data = self.summaries["mp_bonds"][model]
      if data["num_total_protein"] == 0:
        pct_outliers = 0.0
      else:
        pct_outliers = data["num_outliers_protein"]/data["num_total_protein"]*100.0
      if pct_outliers < 0.01: color=green
      elif pct_outliers >= 0.2: color=red
      else: color=yellow
      protein_lines.append("  <tr>")
      protein_lines.append("""    <td>Bad bonds</td>
    <td bgcolor='{color}'>&nbsp;{num_outliers_protein} / {num_total_protein}</td>
    <td bgcolor='{color}'>&nbsp;{pct_outliers:.2f}%</td>
    <td>Goal: 0%</td>
  </tr>""".format(color=color, num_outliers_protein=data["num_outliers_protein"], num_total_protein=data["num_total_protein"], pct_outliers=pct_outliers))

    if "mp_angles" in self.summaries and self.summaries["mp_angles"][model]["num_total_protein"] > 0:
      rows += 1
      data = self.summaries["mp_angles"][model]
      if data["num_total_protein"] == 0:
        pct_outliers = 0.0
      else:
        pct_outliers = data["num_outliers_protein"]/data["num_total_protein"]*100.0
      if pct_outliers < 0.1: color=green
      elif pct_outliers >= 0.5: color=red
      else: color=yellow
      protein_lines.append("  <tr>")
      protein_lines.append("""    <td>Bad angles</td>
    <td bgcolor='{color}'>&nbsp;{num_outliers_protein} / {num_total_protein}</td>
    <td bgcolor='{color}'>&nbsp;{pct_outliers:.2f}%</td>
    <td>Goal: 0.1%</td>
  </tr>""".format(color=color, num_outliers_protein=data["num_outliers_protein"], num_total_protein=data["num_total_protein"], pct_outliers=pct_outliers))

    if rows == 0:
      return []
    #Overwrite the first <tr> with the Protein Geometry section cell
    protein_lines[0] = """  <tr>
    <td align='center' rowspan='{rows}'>Protein Geometry</td>""".format(rows=rows)
    return protein_lines

  def summary_table_peptide_omegas(self, model, show_all=False):
    data = self.summaries["omegalyze"][model]
    lines = []
    rows = 1
    if data["num_proline"] == 0:
      pct_cis_pro = 0.0
    else:
      pct_cis_pro = data["num_cis_proline"]/data["num_proline"]*100.0
    lines.append("""    <td>Cis Prolines</td>
    <td>&nbsp;{num_cis_proline} / {num_proline}</td>
    <td>&nbsp;{pct_cis_pro:.2f}</td>
    <td>Expected: &le;1 per chain, or &le;5%</td>
  </tr>""".format(num_cis_proline=data["num_cis_proline"], num_proline=data["num_proline"], pct_cis_pro=pct_cis_pro))

    if show_all or data["num_cis_general"] != 0:
      rows += 1
      if data["num_general"] == 0:
        pct_cis_general = 0.0
      else:
        pct_cis_general = data["num_cis_general"]/data["num_general"]*100.0
      if pct_cis_general <= 0.05: color=green
      elif pct_cis_general > 0.1: color=red
      else: color=yellow
      lines.append("""  <tr>
    <td>Cis nonProlines</td>
    <td bgcolor='{color}'>&nbsp;{num_cis_general} / {num_general}</td>
    <td bgcolor='{color}'>&nbsp;{pct_cis_general}%</td>
    <td>Goal: &lt;0.05%</td>
  </tr>""".format(color=color, num_cis_general=data["num_cis_general"], num_general=data["num_general"], pct_cis_general=pct_cis_general))

    num_twisted = data["num_twisted_proline"] + data["num_twisted_general"]
    if show_all or num_twisted != 0:
      rows += 1
      num_res = data["num_general"]+data["num_proline"]
      if num_res == 0:
        pct_twisted = 0.0
      else:
        pct_twisted = num_twisted/num_res*100.0
      if num_twisted == 0: color=green
      elif pct_twisted > 0.1: color=red
      else: color=yellow
      lines.append("""  <tr>
    <td>Twisted peptides</td>
    <td bgcolor='{color}'>&nbsp;{num_twisted} / {num_res}</td>
    <td bgcolor='{color}'>&nbsp;{pct_twisted}%</td>
    <td>Goal: 0</td>
  </tr>""".format(color=color, num_twisted=num_twisted, num_res=num_res, pct_twisted=pct_twisted))
    omega_lines = ["  <tr>","    <td align='center' rowspan='{rows}'>Peptide Omegas</td>".format(rows=len(lines))] + lines
    return omega_lines

  def summary_table_nucleic_acids(self, model):
    lines=[]
    rows = 0
    if "rna_puckers" in self.summaries:
      rows += 1
      data = self.summaries["rna_puckers"][model]
      if data["num_residues"] == 0:
        pct_outliers = 0.0
      else:
        pct_outliers = data["num_outliers"]/data["num_residues"]*100.0
      if data["num_outliers"] == 0: color=green
      elif pct_outliers > 5: color=red
      else: color=yellow
      lines.append("  <tr>")
      lines.append("""    <td>Probably wrong sugar puckers</td>
    <td bgcolor='{color}'>&nbsp;{num_outliers} / {num_residues}</td>
    <td bgcolor='{color}'>&nbsp;{pct_outliers:.2f}%</td>
    <td>Goal: 0</td>
  </tr>""".format(color=color, num_outliers=data["num_outliers"], num_residues=data["num_residues"], pct_outliers=pct_outliers))

    if "rna_suites" in self.summaries:
      rows += 1
      data = self.summaries["rna_suites"][model]
      if data["num_suites"] == 0:
        pct_outliers = 0.0
      else:
        pct_outliers = data["num_outliers"]/data["num_suites"]*100.0
      if pct_outliers <= 5: color=green
      elif pct_outliers > 15: color=red
      else: color=yellow
      lines.append("  <tr>")
      lines.append("""    <td>Bad backbone conformations</td>
    <td bgcolor='{color}'>&nbsp;{num_outliers} / {num_suites}</td>
    <td bgcolor='{color}'>&nbsp;{pct_outliers:.2f}%</td>
    <td>Goal: &le; 5%</td>
  </tr>""".format(color=color, num_outliers=data["num_outliers"], num_suites=data["num_suites"], pct_outliers=pct_outliers))

    #if "rna_bonds" in self.summaries:
    if "mp_bonds" in self.summaries and self.summaries["mp_bonds"][model]["num_total_na"] > 0:
      rows += 1
      data = self.summaries["mp_bonds"][model]
      if data["num_total_na"] == 0:
        pct_outliers = 0.0
      else:
        pct_outliers = data["num_outliers_na"]/data["num_total_na"]*100.0
      if pct_outliers < 0.01: color=green
      elif pct_outliers >= 0.2: color=red
      else: color=yellow
      lines.append("  <tr>")
      lines.append("""    <td>Bad bonds</td>
    <td bgcolor='{color}'>&nbsp;{num_outliers_na} / {num_total_na}</td>
    <td bgcolor='{color}'>&nbsp;{pct_outliers:.2f}%</td>
    <td>Goal: 0%</td>
  </tr>""".format(color=color, num_outliers_na=data["num_outliers_na"], num_total_na=data["num_total_na"], pct_outliers=pct_outliers))

    if "mp_angles" in self.summaries and self.summaries["mp_angles"][model]["num_total_na"] > 0:
      rows += 1
      data = self.summaries["mp_angles"][model]
      if data["num_total_na"] == 0:
        pct_outliers = 0.0
      else:
        pct_outliers = data["num_outliers_na"]/data["num_total_na"]*100.0
      if pct_outliers < 0.1: color=green
      elif pct_outliers >= 0.5: color=red
      else: color=yellow
      lines.append("  <tr>")
      lines.append("""    <td>Bad bonds</td>
    <td bgcolor='{color}'>&nbsp;{num_outliers_na} / {num_total_na}</td>
    <td bgcolor='{color}'>&nbsp;{pct_outliers:.2f}%</td>
    <td>Goal: &lt;0.1%</td>
  </tr>""".format(color=color, num_outliers_na=data["num_outliers_na"], num_total_na=data["num_total_na"], pct_outliers=pct_outliers))

    if rows == 0:
      return []
    lines[0] = """  <tr>
    <td align='center' rowspan={rows}>Nucleic Acid<br>Geometry</td>""".format(rows=rows)
    return lines

  def summary_table_low_res(self, model): #Right now, this just means 2 rows of CaBLAM
    if "cablam" not in self.summaries:
      return []
    lines = []
    lines.append("""  <tr>
    <td align='center' rowspan='2'>Low-resolution Criteria</td>""")
    data = self.summaries["cablam"][model]
    if data["cablam_outliers_percentage"] <=1: color=green
    elif data["cablam_outliers_percentage"] > 5: color=red
    else: color=yellow
    lines.append("""    <td>CaBLAM outliers</td>
    <td bgcolor='{color}'>&nbsp;{num_cablam_outliers} / {num_residues}</td>
    <td bgcolor='{color}'>&nbsp;{cablam_outliers_percentage:.1f}%</td>
    <td>Goal: &lt;1.0%</td></tr>""".format(
    color=color, num_cablam_outliers=data["num_cablam_outliers"], num_residues=data["num_residues"], cablam_outliers_percentage=data["cablam_outliers_percentage"]))

    if data["ca_geom_outliers_percentage"] <=0.5: color=green
    elif data["ca_geom_outliers_percentage"] > 1: color=red
    else: color=yellow
    lines.append("""  <tr>
    <td>CA Geometry outliers</td>
    <td bgcolor='{color}'>&nbsp;{num_ca_geom_outliers} / {num_residues}</td>
    <td bgcolor='{color}'>&nbsp;{ca_geom_outliers_percentage:.1f}%</td>
    <td>Goal: &lt;1.0%</td></tr>""".format(
    color=color, num_ca_geom_outliers=data["num_ca_geom_outliers"], num_residues=data["num_residues"], ca_geom_outliers_percentage=data["ca_geom_outliers_percentage"]))

    return lines

  def summary_table_additional(self, model):
    first_row=True
    lines = []
    rows=0
    if "chirals" in self.summaries:
      rows+=1
      #nothing to load yet, add later
      lines.append("  <tr>")
      lines.append()
    if "undowser" in self.summaries:
      rows+=1
      data = self.summaries["undowser"][model]
      if data["num_waters"] == 0:
        pct_outliers = 0.0
      else:
        pct_outliers = data["num_outliers"]/data["num_waters"]*100.0
      lines.append("  <tr>")
      lines.append("""    <td>Waters with clashes</td>
    <td>&nbsp;{num_outliers} / {num_waters}</td>
    <td>&nbsp;{pct_outliers:.2f}%</td>
    <td>See UnDowser table for details</td>
  </tr>""".format(
       num_outliers=data["num_outliers"], num_waters=data["num_waters"], pct_outliers=pct_outliers))
    if rows == 0:
      return []
    lines[0] = """  <tr>
    <td align='center' rowspan='{rows}'>Additional validations</td>""".format(rows=rows)
    return lines

  def clash_header(self, model):
    return "    <th>Clash &gt; 0.4&Aring;<br><small>Clashscore: {clashscore:.2f}</small></th>".format(
      clashscore=self.summaries["clashscore"][model]["clashscore"])

  def rama_header(self, model):
    return "    <th>Ramachandran<br><small>Outliers: {num_outliers} out of {num_residues}</small></th>".format(
      num_outliers=self.summaries["ramalyze"][model]["num_outliers"], num_residues=self.summaries["ramalyze"][model]["num_residues"])

  def rota_header(self, model):
    return "    <th>Rotamer<br><small>Poor rotamers: {num_outliers} out of {num_residues}</small></th>".format(
      num_outliers=self.summaries["rotalyze"][model]["num_outliers"], num_residues=self.summaries["rotalyze"][model]["num_residues"])

  def cbdev_header(self, model):
    return "   <th>C&beta; deviation<br><small>Outliers: {num_outliers} out of {num_cbeta_residues}</small></th>".format(
      num_outliers=self.summaries["cbetadev"][model]["num_outliers"], num_cbeta_residues=self.summaries["cbetadev"][model]["num_cbeta_residues"])

  def cablam_header(self, model):
    return "    <th>CaBLAM<br><small>Outliers: {num_cablam_outliers} out of {num_residues}</small></th>".format(
      num_cablam_outliers=self.summaries["cablam"][model]["num_cablam_outliers"], num_residues=self.summaries["cablam"][model]["num_residues"])

  def pperp_header(self, model):
    return "    <th>Base-P perp dist.<br><small>Outliers: {num_outliers} out of {num_residues}</small></th>".format(
      num_outliers=self.summaries["rna_puckers"][model]["num_outliers"], num_residues=self.summaries["rna_puckers"][model]["num_residues"])

  def suite_header(self, model):
    return "    <th>RNA suite conf.<br><small>Outliers: {num_outliers} out of {num_suites}</small></th>".format(
      num_outliers=self.summaries["rna_suites"][model]["num_outliers"], num_suites=self.summaries["rna_suites"][model]["num_suites"])

  def bonds_header(self, model):
    return "    <th>Bond lengths<br><small>Outliers: {num_outliers} out of {num_total}</small></small></th>".format(
      num_outliers=self.summaries["mp_bonds"][model]["num_outliers"], num_total=self.summaries["mp_bonds"][model]["num_total"])

  def angles_header(self, model):
    return "    <th>Bond angles<br><small>Outliers: {num_outliers} out of {num_total}</small></th>".format(
      num_outliers=self.summaries["mp_angles"][model]["num_outliers"], num_total=self.summaries["mp_angles"][model]["num_total"])

  def omegalyze_header(self, model):
    total_res = self.summaries["omegalyze"][model]["num_proline"] + self.summaries["omegalyze"][model]["num_general"]
    total_nontrans = self.summaries["omegalyze"][model]["num_cis_proline"] + self.summaries["omegalyze"][model]["num_twisted_proline"] + self.summaries["omegalyze"][model]["num_cis_general"] + self.summaries["omegalyze"][model]["num_twisted_general"]
    return "    <th>Cis Peptides<br><small>Non-Trans: {total_nontrans} out of {total_res}</small></th>".format(
      total_nontrans=total_nontrans, total_res=total_res)

  def make_multicrit_table(self, model, outliers_only=False):
    lines = []
    #lines.append(self.html_header())
    if model.strip():
      lines.append("<br><b>Multi-criterion table: Model {model}</b>".format(model))
    else:
      lines.append("<br><b>Multi-criterion table</b>")
    lines.append("<table width='100%' cellspacing='1' border='1'>")
    lines.append("  <tr align='center' bgcolor='#9999cc'>")
    #lines.append("    <th><small>Model</small></th>")
    lines.append("    <th>Chain</th>")
    lines.append("    <th>#</th>")
    lines.append("    <th>ins</th>")
    lines.append("    <th>Res</th>")
    lines.append("    <th>alt</th>")
    #for val_type in self.validation_types:
    table_order = self.get_table_order()
    for val_type in table_order:
      #lines.append("    <td>%s</td>" % val_type) #this needs more details
      #lines.append("    <th style='position:sticky; top:10px; background-color:#9999cc'>%s</th>" % val_type) #this needs more details
      if val_type == "clashscore":
        lines.append(self.clash_header(model))
      elif val_type == "ramalyze":
        lines.append(self.rama_header(model))
      elif val_type == "rotalyze":
        lines.append(self.rota_header(model))
      elif val_type == "cbetadev":
        lines.append(self.cbdev_header(model))
      elif val_type == "cablam":
        lines.append(self.cablam_header(model))
      elif val_type == "rna_puckers":
        lines.append(self.pperp_header(model))
      elif val_type == "rna_suites":
        lines.append(self.suite_header(model))
      elif val_type == "mp_bonds":
        lines.append(self.bonds_header(model))
      elif val_type == "mp_angles":
        lines.append(self.angles_header(model))
      elif val_type == "omegalyze":
        lines.append(self.omegalyze_header(model))
      else:
        lines.append("    <th>%s</th>" % val_type) #this needs more details
    lines.append("  </tr>")

    line_colors = ['#ffffff','#f0f0f0']
    count = 0
    for reskey in self.indices:
      if outliers_only and not self.data[reskey].has_outlier:
        continue
      color = line_colors[count % 2]
      lines.append(self.data[reskey].residue_cells(color))
      for alt in self.data[reskey].alternates:
        if alt != self.data[reskey].alternates[0]:
          lines.append("  <tr align='center' bgcolor='{color}'>".format(color=color))
        lines.append("    <td>{resname}</td>".format(resname=self.data[reskey].find_resname(alt=alt)))
        if alt in self.data[reskey].modeled_alternates:
          lines.append("    <td>{alt}</td>".format(alt=alt))
        else:
          lines.append("    <td>({alt})</td>".format(alt=alt))
        ##for val_type in self.validation_types:
        for val_type in table_order:
          if val_type == "clashscore":
            lines.append(self.data[reskey].clash_cell(alt, reskey))
          elif val_type == "ramalyze":
            lines.append(self.data[reskey].ramalyze_cell(alt))
          elif val_type == "rotalyze":
            lines.append(self.data[reskey].rotalyze_cell(alt))
          elif val_type == "cbetadev":
            lines.append(self.data[reskey].cbetadev_cell(alt))
          elif val_type == "cablam":
            lines.append(self.data[reskey].cablam_cell(alt))
          elif val_type == "rna_puckers":
            lines.append(self.data[reskey].base_p_perp_cell(alt))
          elif val_type == "rna_suites":
            lines.append(self.data[reskey].suitename_cell(alt))
          elif val_type == "mp_bonds":
            lines.append(self.data[reskey].bond_length_cell(alt))
          elif val_type == "mp_angles":
            lines.append(self.data[reskey].bond_angle_cell(alt))
          elif val_type == "omegalyze":
            lines.append(self.data[reskey].omegalyze_cell(alt))

        lines.append("  </tr>")
      count+=1
    lines.append("</table>")
    print("\n".join(lines))


  def html_header(self):
    return """<!DOCTYPE html>
 <html lang="en">

  <head>
  <title>MolProbity Table Test</title>
  <style>
  th {position:sticky; top:0px; background-color:#9999cc}
  </style>
  </head>
  <body>
"""

  def html_header_d(self):
    return """<!DOCTYPE html>

<html lang="en">

  <head>

    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

    <title>MolProbity Table Test</title>


    <!-- CSS
    –––––––––––––––––––––––––––––––––––––––––––––––––– -->
    <!-- Bootstrap CSS -->
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
    <!-- Custom CSS -->
    <link rel="stylesheet" href="/static/css/mystyle.css" type="text/css">

    <!-- JAVASCRIPT
    –––––––––––––––––––––––––––––––––––––––––––––––––– -->

    <!-- jQuery library -->
    <script
      src="https://code.jquery.com/jquery-3.4.1.min.js"
      integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo="
      crossorigin="anonymous">
    </script>
    <!-- Popper.JS -->
    <script
      src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js"
      integrity="sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49"
      crossorigin="anonymous">
    </script>

    <!-- Bootstrap JS -->
    <script
      src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js"
      integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM"
      crossorigin="anonymous">
    </script>

    <!-- Maphighlight -->
    <script type="text/javascript" src="/static/js/jquery.maphilight.min.js"></script>
    <!-- Custom javascript -->
    <script
        type="text/javascript"
        src="/static/django_tables2_column_shifter/js/django_tables2_column_shifter.min.js">
    </script>
    <script type="text/javascript" src="/static/js/myjavascript.js"></script>

  </head>
  """

class residue():
  def __init__(self, rg, model_id, chain_id, resseq, icode):
    self.reskey = make_reskey(model_id, chain_id, resseq, icode)
    self.model_id = model_id
    self.chain_id = chain_id
    self.resseq = resseq
    self.icode = icode
    self.resnames = self.get_resnames_from_hierarchy(rg)
    self.resname = self.resnames[sorted(self.resnames.keys())[0]] #returns resname of first altloc alphabetically
    self.has_outlier = False
    self.validations = {}
    self.alternates = ['']
    self.modeled_alternates = self.get_alts_from_hierarchy(rg)
    self.colors = {"severe":"#ee4d4d",
                   "outlier":"#ff76a9",
                   "mild":"#ffb3cc"}

  def get_alternates(self):
    allalts = []+self.modeled_alternates
    for validation in self.validations:
      allalts += self.validations[validation]
    if not allalts:
      allalts.append('')
    self.alternates = sorted(set(allalts))
    #print(self.reskey, self.alternates)

  def get_resnames_from_hierarchy(self, rg):
    #Intended to handle the rare case where a residue has alternates with different residue names
    #May eventually need work to tie residue names to altlocs
    #This is assumed rare enough to be low priority
    resnames = {}
    for ag in rg.atom_groups():
      resnames[ag.altloc] = ag.resname
    return resnames

  def get_alts_from_hierarchy(self, rg):
    #Help track whether an alt came from the model or from calculations
    modeled_alternates = []
    for ag in rg.atom_groups():
      modeled_alternates.append(ag.altloc.strip())
    return modeled_alternates

  def find_resname(self, alt=''):
    res = self.resnames.get(alt)
    if res:
      return res
    else:
      #return self.resname+"*" #this version marks the guess/default
      return self.resname #default based on first alphabetical altloc

  def residue_cells(self,color):
    #residue identifiers, plus row management for alternates
    lines = []
    lines.append("  <tr align=center bgcolor='{color}'>".format(color=color))
    #lines.append("    <td rowspan={rows}>{resid}</td>".format(rows=len(self.alternates), resid=self.model_id))
    lines.append("    <td rowspan={rows}>{resid}</td>".format(rows=len(self.alternates), resid=self.chain_id))
    lines.append("    <td rowspan={rows}>{resid}</td>".format(rows=len(self.alternates), resid=self.resseq))
    lines.append("    <td rowspan={rows}>{resid}</td>".format(rows=len(self.alternates), resid=self.icode))

    return("\n".join(lines))

  def clash_cell(self, alt, reskey):
    clash_data_res = self.validations.get("clashscore")
    if clash_data_res is None:
      return "    <td>-</td>"
    clash_data = clash_data_res.get(alt)
    if clash_data is None:
      return "    <td>-</td>"
    clash_size = abs(clash_data[0]["overlap"])
    if clash_size < 0.5: color = self.colors["mild"] #implicitely clash_size>=0.4
    elif clash_size > 0.9: color = self.colors["severe"]
    else: color = self.colors["outlier"]
    line1 = "<td bgcolor={color}>{clash_size:.2f}&Aring;".format(color=color, clash_size=clash_size)
    if reskey == make_reskey(clash_data[0]["model_id"], clash_data[0]["chain_id"], clash_data[0]["resseq"], clash_data[0]["icode"]):
      line2 = "<br><small>{src_atom} with {trg_chain} {trg_resseq}{trg_icode} {trg_resname} {trg_atom} {trg_altloc}</small>".format(src_atom=clash_data[0]["name"],
                                                                                                                 trg_chain=clash_data[0]["target_chain_id"],
                                                                                                                 trg_resseq=clash_data[0]["target_resseq"],
                                                                                                                 trg_icode=clash_data[0]["target_icode"],
                                                                                                                 trg_resname=clash_data[0]["target_resname"],
                                                                                                                 trg_atom=clash_data[0]["target_name"],
                                                                                                                 trg_altloc=clash_data[0]["target_altloc"])
    else: #swap source and target in the cell
      line2 = "<br><small>{src_atom} with {trg_chain} {trg_resseq}{trg_icode} {trg_resname} {trg_atom} {trg_altloc}</small>".format(src_atom=clash_data[0]["target_name"],
                                                                                                                 trg_chain=clash_data[0]["chain_id"],
                                                                                                                 trg_resseq=clash_data[0]["resseq"],
                                                                                                                 trg_icode=clash_data[0]["icode"],
                                                                                                                 trg_resname=clash_data[0]["resname"],
                                                                                                                 trg_atom=clash_data[0]["name"],
                                                                                                                 trg_altloc=clash_data[0]["altloc"])
    return line1+line2+"</td>"

  def bond_length_cell(self, alt):
    geom_data_res = self.validations.get("mp_bonds")
    if geom_data_res is None:
      return "    <td>-</td>"
    geom_data = geom_data_res.get(alt)
    if geom_data is None:
      return "    <td>-</td>"
    geom_score = abs(geom_data[0]["score"])
    if geom_score >= 10: color = self.colors["severe"]
    else: color = self.colors["outlier"] #implicitly score>=4
    line1 = "<td bgcolor={color}>{outlier_count} OUTLIERS(S)".format(color=color, outlier_count=len(geom_data))
    line2 = "<br><small>worst is {atom1}--{atom2}: {geom_score:.1f} &sigma;</small>".format(
      atom1=geom_data[0]["atoms_name"][0].strip(), atom2=geom_data[0]["atoms_name"][1].strip(), geom_score=geom_score)
    return line1+line2+"</td>"

  def bond_angle_cell(self, alt):
    geom_data_res = self.validations.get("mp_angles")
    if geom_data_res is None:
      return "    <td>-</td>"
    geom_data = geom_data_res.get(alt)
    if geom_data is None:
      return "    <td>-</td>"
    geom_score = abs(geom_data[0]["score"])
    if geom_score >= 10: color = self.colors["severe"]
    else: color = self.colors["outlier"] #implicitly score>=4
    line1 = "<td bgcolor={color}>{outlier_count} OUTLIERS(S)".format(color=color, outlier_count=len(geom_data))
    line2 = "<br><small>worst is {atom1}-{atom2}-{atom3}: {geom_score:.1f} &sigma;</small>".format(
      atom1=geom_data[0]["atoms_name"][0].strip(), atom2=geom_data[0]["atoms_name"][1].strip(), atom3=geom_data[0]["atoms_name"][2].strip(), geom_score=geom_score)
    return line1+line2+"</td>"

  def ramalyze_cell(self, alt):
  #<td bgcolor='#ffb3cc'>Allowed (0.36%)<br><small>General / -156.1,27.4</small></td>
    rama_data_res = self.validations.get("ramalyze")
    if rama_data_res is None:
      return "    <td>-</td>"
    rama_data = rama_data_res.get(alt)
    if rama_data is None:
      return "    <td>-</td>"
    #linestart = "    <td "
    #print("\n".join(rama_data.keys()))
    if rama_data["rama_type"] == "Allowed":
      linestart = "    <td bgcolor='#ffb3cc'>"
    elif rama_data["rama_type"] == "Outlier":
       linestart = "    <td bgcolor='#ff76a9'>"
    else:
      linestart = "<td>"
    line1 = "{rama_type} ({score:.2f}%)".format(rama_type=rama_data["rama_type"], score=rama_data["score"])
    line2 = "<br><small>{res_type}/ {phi:.1f},{psi:.1f}</small>".format(res_type=rama_data["res_type_label"], phi=rama_data["phi"], psi=rama_data["psi"])
    return linestart+line1+line2+"</td>"

  def rotalyze_cell(self, alt):
    #<td bgcolor='#ffb3cc'>Allowed (0.4%) <i>p0</i><br><small>chi angles: 41.2,280.7</small></td>
    rota_data_res = self.validations.get("rotalyze")
    if rota_data_res is None:
      return "    <td>-</td>"
    rota_data = rota_data_res.get(alt)
    if rota_data is None:
      return "    <td>-</td>"

    if rota_data["evaluation"] == "Allowed":
      linestart = "    <td bgcolor='#ffb3cc'>"
    elif rota_data["evaluation"] == "Outlier":
       linestart = "    <td bgcolor='#ff76a9'>"
    else:
      linestart = "    <td>"

    if rota_data["outlier"]:
      line1 = "{rota_eval} ({score:.2f}%)".format(rota_eval=rota_data["evaluation"], score=rota_data["score"])
    else:
      line1 = "{rota_eval} ({score:.2f}%) <i>{rotamer}</i> ".format(rota_eval=rota_data["evaluation"], score=rota_data["score"], rotamer=rota_data["rotamer_name"])

    chi_angle_list = []
    for chi in rota_data["chi_angles"]:
      if chi is not None:
        chi_angle_list.append("%.1f" % chi)
    line2 = "<br><small>chi angles: {chi_angles}</small>".format(chi_angles=",".join(chi_angle_list))
    return linestart+line1+line2+"</td>"

  def cbetadev_cell(self, alt):
    #<td bgcolor='#ff76a9'>0.26&Aring;</td>
    cbdev_data_res = self.validations.get("cbetadev")
    if cbdev_data_res is None:
      return "    <td>-</td>"
    cbdev_data = cbdev_data_res.get(alt)
    if cbdev_data is None:
      return "    <td>-</td>"
    if cbdev_data["outlier"]:
      line = "    <td bgcolor='#ff76a9'>{dev_dist:.2f}&Aring;</td>".format(dev_dist=cbdev_data["deviation"])
    else:
      line = "    <td>{dev_dist:.2f}&Aring;</td>".format(dev_dist=cbdev_data["deviation"])
    return line

  def cablam_cell(self, alt):
    #<td bgcolor='#ffb3cc'> CaBLAM Disfavored   (1.671%)<br><small>                 </small></td>
    cablam_data_res = self.validations.get("cablam")
    if cablam_data_res is None:
      return "    <td>-</td>"
    cablam_data = cablam_data_res.get(alt)
    if cablam_data is None:
      return "    <td>-</td>"

    score = cablam_data["scores"]["cablam"]
    if cablam_data['outlier_type'] == "CA Geom Outlier":
      line1 = "    <td bgcolor={color}>CA Geom Outlier ({score:.3f}%)".format(color=self.colors["severe"], score=score)
    elif cablam_data['outlier_type'] == "CaBLAM Outlier":
      line1 = "    <td bgcolor={color}>CaBLAM Outlier ({score:.3f}%)".format(color=self.colors["outlier"], score=score)
    elif cablam_data['outlier_type'] == "CaBLAM Disfavored":
      line1 = "    <td bgcolor={color}>CaBLAM Disfavored ({score:.3f}%)".format(color=self.colors["mild"], score=score)
    else:
      line1 = "    <td>Favored ({score:.3f}%)".format(score=score)

    if cablam_data["feedback"] == "try alpha helix":
      line2 = "<br><small>alpha helix</small>"
    elif cablam_data["feedback"] == "try beta sheet":
      line2 = "<br><small>beta sheet</small>"
    elif cablam_data["feedback"] == "try three-ten":
      line2 = "<br><small>three-ten</small>"
    else:
      line2 = ""
    return line1+line2+"</td>"

  def omegalyze_cell(self, alt):
    omega_data_res = self.validations.get("omegalyze")
    if omega_data_res is None:
      return "    <td>-</td>"
    omega_data = omega_data_res.get(alt)
    if omega_data is None:
      return "    <td>-</td>"

    #Cis Pro gets text, but no color
    #Cis nonPro gets outlier pink
    #Twisted Anything gets severe red
    if omega_data["omega_type"] == "Twisted":
      linestart = "    <td bgcolor={color}>".format(color=self.colors["severe"])
    elif omega_data["omega_type"] == "Cis":
      if omega_data["resname"] == "PRO":
        linestart = "    <td>"
      else:
        linestart = "    <td bgcolor={color}>".format(color=self.colors["outlier"])
    else:
      return "    <td>-</td>"

    if omega_data["resname"] == "PRO":
      line1 = "{omega_type} PRO".format(omega_type = omega_data["omega_type"])
    else:
      line1 = "{omega_type} nonPRO".format(omega_type = omega_data["omega_type"])

    line2 = "<br><small>omega= {omega:.2f}</small>".format(omega=omega_data["omega"])
    return linestart+line1+line2+"</td>"

  def suitename_cell(self, alt):
    suite_data_res = self.validations.get("rna_suites")
    if suite_data_res is None:
      return "    <td>-</td>"
    suite_data = suite_data_res.get(alt)
    if suite_data is None:
      return "    <td>-</td>"

    if suite_data["outlier"]:
      line1 = "    <td bgcolor={color}>OUTLIER".format(color=self.colors["outlier"])
      line2 = ""
    else:
      line1 = "    <td>conformer: {suitename}".format(suitename=suite_data["cluster"])
      line2 = ""

    if suite_data["bin"] == "trig": #i.e. triaged
      line2 = "<br><small>(triaged {reason})</small>".format(reason = suite_data["reason"])
    elif suite_data["bin"] == "inc": #i.e. incomplete
      line2 = "<br><small>(incomplete)</small>"
    else: #suite_data["bin"] is something like "33 t" or "23 p", representing the two puckers and the m/p/t-staggered gamma dihedral
      ddg = suite_data["bin"][0] + "'," + suite_data["bin"][1] + "'," + suite_data["bin"][3]
      if suite_data["outlier"]:
        line2 = "<br><small>&delta;-1,&delta;,&gamma;={suite_bin}</small>".format(suite_bin=ddg)
      else:
        line2 = "<br><small>&delta;-1,&delta;,&gamma;={suite_bin} ; suiteness={suiteness:.2f}</small>".format(suite_bin=ddg, suiteness=suite_data["suiteness"])
    return line1+line2+"</td>"

  def base_p_perp_cell(self, alt):
    pperp_data_res = self.validations.get("rna_puckers")
    if pperp_data_res is None:
      return "    <td>-</td>"
    pperp_data = pperp_data_res.get(alt)
    if pperp_data is None:
      return "    <td>-</td>"

    outlier_types = []
    if pperp_data["is_delta_outlier"]:
      outlier_types.append("&delta;")
    if pperp_data["is_epsilon_outlier"]:
      outlier_types.append("&epsilon;")
    outlier_type = " & ".join(outlier_types)

    #diagnosis should not be calculated here! Put it in the validation itself!
    diagnosis="unknown"
    #if pperp_data["is_delta_outlier"]
    #if($perpdist < 2.9) //2.9A is dist cutoff for C2' vs C3' endo pucker
    #          $probpucker = "C2'-endo";
    #        else
    #          $probpucker = "C3'-endo";

    line1 = "    <td bgcolor={color}>suspect sugar pucker - {outlier_type} outlier".format(color=self.colors["outlier"], outlier_type=outlier_type)
    line2 = "<br><small>(P-perp distance implies {diagnosis})</small>".format(diagnosis=diagnosis)
    return line1+line2+"</td>"

def loadModel(filename):  # from suitename/suites.py
  from iotbx.data_manager import DataManager
  dm = DataManager()  # Initialize the DataManager and call it dm
  dm.set_overwrite(True)  # tell the DataManager to overwrite files with the same name
  model = dm.get_model(filename)
  return model
#model.get_hierarchy()

def read_jsons_from_files(file_list):
  #accepts list of file paths
  #returns dictionary of jsons
  validations = {}
  for file_path in file_list:
    if not os.path.isfile(file_path):
      continue
    valfile = open(file_path)
    validation = json.load(valfile)
    if validation.get("mp_bonds"):
      validations["mp_bonds"] = validation["mp_bonds"]
      validations["mp_angles"] = validation["mp_angles"]
    else:
      validations[validation["validation_type"]] = validation
    valfile.close()
  return validations

pdbfilepath = sys.argv[1]
model = loadModel(pdbfilepath)
h = model.get_hierarchy()
#merged = make_storage_structure_from_hierarchy(h)
merged = merged_validations(h)

file_list = sys.argv[2:]
validations = read_jsons_from_files(file_list)

merged.add_validations(validations.values())
merged.add_summaries(validations.values())

print(merged.html_header())
merged.make_summary_table("")
merged.make_multicrit_table("", outliers_only=True)



 *******************************************************************************


 *******************************************************************************
mmtbx/validation/mp_validate_bonds.py
# TODO reduce to one outlier per residue
# CDL on by default?

from __future__ import absolute_import, division, print_function
from mmtbx.monomer_library import pdb_interpretation
from mmtbx.validation import utils
from mmtbx import monomer_library
from mmtbx.validation import validation
from mmtbx.validation import residue
from mmtbx.validation import atoms
from mmtbx.validation import get_atoms_info
from scitbx.array_family import flex
from cctbx import geometry_restraints
from libtbx.str_utils import make_sub_header
from libtbx import slots_getstate_setstate
from math import sqrt
import sys
import json

# individual validation results
class mp_bond(atoms):
  __slots__ = atoms.__slots__ + ["sigma", "delta", "target", "distance_value", "macromolecule_type"]

  @staticmethod
  def header():
    return "%-20s  %6s  %6s  %6s" % ("residue", "atom 1", "atom 2", "sigmas")

  def id_str(self, spacer=" "):
    return "%s%s%s" % (self.atoms_info[0].id_str(), spacer,
      self.atoms_info[1].id_str())

  def format_values(self):
    return "%-20s  %6s  %6s  %6.2f" % (self.id_str(), self.atoms_info[0].name,
      self.atoms_info[1].name, self.score)

  def as_string(self, prefix=""):
    return prefix + self.format_values()

  def as_JSON(self):
    atoms_dict = {}
    for s in self.atoms_info[0].__slots__:
      atoms_dict["atoms_"+s] = [getattr(self.atoms_info[0], s), getattr(self.atoms_info[1], s)]
    serializable_slots = [s for s in self.__slots__ if s != 'atoms_info' and hasattr(self, s)]
    slots_as_dict = ({s: getattr(self, s) for s in serializable_slots})
    return json.dumps(self.merge_two_dicts(slots_as_dict, atoms_dict), indent=2)

  def as_hierarchical_JSON(self):
    hierarchical_dict = {}
    hierarchy_nest_list = ['model_id', 'chain_id', 'resid', 'altloc']
    return json.dumps(self.nest_dict(hierarchy_nest_list, hierarchical_dict), indent=2)

  def as_table_row_phenix(self):
    return [ self.id_str(), self.atoms_info[0].name, self.atoms_info[1].name,
             self.score ]

class mp_angle(atoms):
  __slots__ = atoms.__slots__ + ["sigma", "delta", "target", "angle_value", "macromolecule_type"]

  @staticmethod
  def header():
    return "%-20s  %6s  %6s  %6s  %6s" % ("residue", "atom 1", "atom 2",
      "atom 3", "sigmas")

  def id_str(self, spacer=" "):
    return "%s%s%s%s%s" % (self.atoms_info[0].id_str(), spacer,
      self.atoms_info[1].id_str(), spacer,
      self.atoms_info[2].id_str())

  def format_values(self):
    return "%-20s  %6s  %6s  %6s  %6.2f" % (self.id_str(),
      self.atoms_info[0].name, self.atoms_info[1].name,
      self.atoms_info[2].name, self.score)

  def as_string(self, prefix=""):
    return prefix + self.format_values()

  def as_JSON(self):
    atoms_dict = {}
    for s in self.atoms_info[0].__slots__:
      atoms_dict["atoms_"+s] = [getattr(self.atoms_info[0], s), getattr(self.atoms_info[1], s), getattr(self.atoms_info[2], s)]
    serializable_slots = [s for s in self.__slots__ if s != 'atoms_info' and hasattr(self, s)]
    slots_as_dict = ({s: getattr(self, s) for s in serializable_slots})
    return json.dumps(self.merge_two_dicts(slots_as_dict, atoms_dict), indent=2)

  def as_hierarchical_JSON(self):
    hierarchical_dict = {}
    hierarchy_nest_list = ['model_id', 'chain_id', 'resid', 'altloc']
    return json.dumps(self.nest_dict(hierarchy_nest_list, hierarchical_dict), indent=2)

  def as_table_row_phenix(self):
    return [ self.id_str(), self.atoms_info[0].name, self.atoms_info[1].name,
             self.atoms_info[2].name, self.score ]

# analysis objects
class mp_bonds(validation):
  output_header = "#residue:atom_1:atom_2:num_sigmas"
  label = "Bond lengths"
  gui_list_headers = ["Residue", "Atom 1", "Atom 2", "Sigmas"]
  gui_formats = ["%s", "%s", "%s", "%.2f"]
  wx_column_widths = [160] * 4
  def __init__(self, pdb_hierarchy, pdb_atoms, geometry_restraints_manager,
                outliers_only=True):
    validation.__init__(self)
    self.n_outliers_large_by_model = {}
    self.n_outliers_small_by_model = {}
    self.n_outliers_protein_by_model = {}
    self.n_outliers_na_by_model = {}
    self.n_outliers_other_by_model = {}
    self.n_total_protein_by_model = {}
    self.n_total_na_by_model = {}
    self.n_total_other_by_model = {}
    for m in pdb_hierarchy.models():
      self.n_total_by_model[m.id] = 0
      self.n_outliers_by_model[m.id] = 0
      self.n_outliers_small_by_model[m.id] = 0
      self.n_outliers_large_by_model[m.id] = 0
      self.n_total_protein_by_model[m.id] = 0
      self.n_outliers_protein_by_model[m.id] = 0
      self.n_total_na_by_model[m.id] = 0
      self.n_outliers_na_by_model[m.id] = 0
      self.n_total_other_by_model[m.id] = 0
      self.n_outliers_other_by_model[m.id] = 0
    cutoff = 4
    sites_cart = pdb_atoms.extract_xyz()
    flags = geometry_restraints.flags.flags(default=True)
    pair_proxies = geometry_restraints_manager.pair_proxies(
      flags=flags,
      sites_cart=sites_cart)
    bond_proxies = pair_proxies.bond_proxies
    for proxy in bond_proxies.simple:
      restraint = geometry_restraints.bond(
        sites_cart=sites_cart,
        proxy=proxy)
      atom1 = pdb_atoms[proxy.i_seqs[0]].name
      atom2 = pdb_atoms[proxy.i_seqs[1]].name
      labels = pdb_atoms[proxy.i_seqs[0]].fetch_labels()
      model_id = labels.model_id
      self.n_total += 1
      #iotbx.pdb.common_residue_names_get_class
      self.n_total_by_model[model_id] += 1
      mm_type = utils.get_mmtype_from_resname(pdb_atoms[proxy.i_seqs[0]].parent().resname)
      if mm_type=="PROTEIN":
        self.n_total_protein_by_model[model_id] += 1
      elif mm_type=="NA":
        self.n_total_na_by_model[model_id] += 1
      else:
        self.n_total_other_by_model[model_id] += 1
      sigma = sqrt(1 / restraint.weight)
      num_sigmas = - restraint.delta / sigma
      is_outlier = (abs(num_sigmas) >= cutoff)
      if is_outlier:
        self.n_outliers += 1
        self.n_outliers_by_model[model_id] += 1
        if mm_type == "PROTEIN":
          self.n_outliers_protein_by_model[model_id] += 1
        elif mm_type == "NA":
          self.n_outliers_na_by_model[model_id] += 1
        else:
          self.n_outliers_other_by_model[model_id] += 1
        if num_sigmas < 0:
          self.n_outliers_small_by_model[model_id] += 1
        else:
          self.n_outliers_large_by_model[model_id] += 1
      if (is_outlier or not outliers_only):
        self.results.append(mp_bond(
          atoms_info=get_atoms_info(pdb_atoms, proxy.i_seqs),
          target=restraint.distance_ideal,
          distance_value=restraint.distance_model,
          sigma=sigma,
          score=num_sigmas,
          delta=restraint.delta,
          xyz=flex.vec3_double([pdb_atoms[proxy.i_seqs[0]].xyz, pdb_atoms[proxy.i_seqs[1]].xyz]).mean(),
          outlier=is_outlier,
          macromolecule_type=mm_type))

  def get_result_class(self) : return mp_bond

  def as_JSON(self, addon_json={}):
    if not addon_json:
      addon_json = {}
    addon_json["validation_type"] = "mp_bonds"
    data = addon_json
    flat_results = []
    hierarchical_results = {}
    summary_results = {}
    for result in self.results:
      flat_results.append(json.loads(result.as_JSON()))
      hier_result = json.loads(result.as_hierarchical_JSON())
      hierarchical_results = self.merge_dict(hierarchical_results, hier_result)

    data['flat_results'] = flat_results
    data['hierarchical_results'] = hierarchical_results
    for mod_id in self.n_total_by_model.keys():
      summary_results[mod_id] = {"num_outliers": self.n_outliers_by_model[mod_id],
                                 "num_total": self.n_total_by_model[mod_id],
                                 "num_outliers_too_small": self.n_outliers_small_by_model[mod_id],
                                 "num_outliers_too_large": self.n_outliers_large_by_model[mod_id],
                                 "num_total_protein": self.n_total_protein_by_model[mod_id],
                                 "num_outliers_protein": self.n_outliers_protein_by_model[mod_id],
                                 "num_total_na": self.n_total_na_by_model[mod_id],
                                 "num_outliers_na": self.n_outliers_na_by_model[mod_id],
                                 "num_total_other": self.n_total_other_by_model[mod_id],
                                 "num_outliers_other": self.n_outliers_other_by_model[mod_id]}
    data['summary_results'] = summary_results
    return json.dumps(data, indent=2)

  def show_summary(self, out=sys.stdout, prefix=""):
    if (self.n_total == 0):
      print(prefix + "No bond lengths found.", file=out)
    elif (self.n_outliers == 0):
      print(prefix + "All bonds within 4.0 sigma of ideal values.", file=out)
    else :
      print(prefix + "%d/%d bond outliers present" % (self.n_outliers,
        self.n_total), file=out)

class mp_angles(validation):
  output_header = "#residue:atom_1:atom_2:atom_3:num_sigmas"
  label = "Bond angles"
  gui_list_headers = ["Residue", "Atom 1", "Atom 2", "Atom 3", "Sigmas"]
  gui_formats = ["%s", "%s", "%s", "%s", "%.2f"]
  wx_column_widths = [160] * 5
  def __init__(self, pdb_hierarchy, pdb_atoms, geometry_restraints_manager,
                outliers_only=True):
    validation.__init__(self)
    self.n_outliers_large_by_model = {}
    self.n_outliers_small_by_model = {}
    self.n_outliers_protein_by_model = {}
    self.n_outliers_na_by_model = {}
    self.n_outliers_other_by_model = {}
    self.n_total_protein_by_model = {}
    self.n_total_na_by_model = {}
    self.n_total_other_by_model = {}
    for m in pdb_hierarchy.models():
      self.n_total_by_model[m.id] = 0
      self.n_outliers_by_model[m.id] = 0
      self.n_outliers_small_by_model[m.id] = 0
      self.n_outliers_large_by_model[m.id] = 0
      self.n_total_protein_by_model[m.id] = 0
      self.n_outliers_protein_by_model[m.id] = 0
      self.n_total_na_by_model[m.id] = 0
      self.n_outliers_na_by_model[m.id] = 0
      self.n_total_other_by_model[m.id] = 0
      self.n_outliers_other_by_model[m.id] = 0
    cutoff = 4
    sites_cart = pdb_atoms.extract_xyz()
    flags = geometry_restraints.flags.flags(default=True)
    i_seq_name_hash = utils.build_name_hash(pdb_hierarchy=pdb_hierarchy)
    for proxy in geometry_restraints_manager.angle_proxies:
      restraint = geometry_restraints.angle(
        sites_cart=sites_cart,
        proxy=proxy)
      atom1 = pdb_atoms[proxy.i_seqs[0]].name
      atom2 = pdb_atoms[proxy.i_seqs[1]].name
      atom3 = pdb_atoms[proxy.i_seqs[2]].name
      labels = pdb_atoms[proxy.i_seqs[0]].fetch_labels()
      model_id = labels.model_id
      self.n_total += 1
      self.n_total_by_model[model_id] += 1
      mm_type = utils.get_mmtype_from_resname(pdb_atoms[proxy.i_seqs[0]].parent().resname)
      if mm_type=="PROTEIN":
        self.n_total_protein_by_model[model_id] += 1
      elif mm_type=="NA":
        self.n_total_na_by_model[model_id] += 1
      else:
        self.n_total_other_by_model[model_id] += 1
      sigma = sqrt(1 / restraint.weight)
      num_sigmas = - restraint.delta / sigma
      is_outlier = (abs(num_sigmas) >= cutoff)
      if is_outlier:
        self.n_outliers += 1
        self.n_outliers_by_model[model_id] += 1
        if mm_type == "PROTEIN":
          self.n_outliers_protein_by_model[model_id] += 1
        elif mm_type == "NA":
          self.n_outliers_na_by_model[model_id] += 1
        else:
          self.n_outliers_other_by_model[model_id] += 1
        if num_sigmas < 0:
          self.n_outliers_small_by_model[model_id] += 1
        else:
          self.n_outliers_large_by_model[model_id] += 1

      if (is_outlier or not outliers_only):
        self.results.append(mp_angle(
          atoms_info=get_atoms_info(pdb_atoms, proxy.i_seqs),
          target=restraint.angle_ideal,
          angle_value=restraint.angle_model,
          sigma=sigma,
          score=num_sigmas,
          delta=restraint.delta,
          xyz=pdb_atoms[proxy.i_seqs[1]].xyz,
          outlier=is_outlier,
          macromolecule_type=mm_type))

  def get_result_class(self) : return mp_angle

  def as_JSON(self, addon_json={}):
    if not addon_json:
      addon_json = {}
    addon_json["validation_type"] = "mp_angles"
    data = addon_json
    flat_results = []
    hierarchical_results = {}
    summary_results = {}
    for result in self.results:
      flat_results.append(json.loads(result.as_JSON()))
      hier_result = json.loads(result.as_hierarchical_JSON())
      hierarchical_results = self.merge_dict(hierarchical_results, hier_result)

    data['flat_results'] = flat_results
    data['hierarchical_results'] = hierarchical_results
    for mod_id in self.n_total_by_model.keys():
      summary_results[mod_id] = {"num_outliers": self.n_outliers_by_model[mod_id],
                                 "num_total": self.n_total_by_model[mod_id],
                                 "num_outliers_too_small": self.n_outliers_small_by_model[mod_id],
                                 "num_outliers_too_large": self.n_outliers_large_by_model[mod_id],
                                 "num_total_protein": self.n_total_protein_by_model[mod_id],
                                 "num_outliers_protein": self.n_outliers_protein_by_model[mod_id],
                                 "num_total_na": self.n_total_na_by_model[mod_id],
                                 "num_outliers_na": self.n_outliers_na_by_model[mod_id],
                                 "num_total_other": self.n_total_other_by_model[mod_id],
                                 "num_outliers_other": self.n_outliers_other_by_model[mod_id]}
    data['summary_results'] = summary_results
    return json.dumps(data, indent=2)

  def show_summary(self, out=sys.stdout, prefix=""):
    if (self.n_total == 0):
      print(prefix + "No bond angles found.", file=out)
    elif (self.n_outliers == 0):
      print(prefix + "All angles within 4.0 sigma of ideal values.", file=out)
    else :
      print(prefix + "%d/%d angle outliers present" % (self.n_outliers,
        self.n_total), file=out)

class mp_validate_bonds(slots_getstate_setstate):
  __slots__ = ["bonds", "angles"]

  def __init__(self,
      pdb_hierarchy,
      geometry_restraints_manager=None,
      params=None,
      outliers_only=True):
    if (geometry_restraints_manager is None):
      mon_lib_srv = monomer_library.server.server()
      ener_lib = monomer_library.server.ener_lib()
      processed_pdb_file = pdb_interpretation.process(
        mon_lib_srv=mon_lib_srv,
        ener_lib=ener_lib,
        pdb_hierarchy=pdb_hierarchy,
        substitute_non_crystallographic_unit_cell_if_necessary=True)
      geometry_restraints_manager = \
        processed_pdb_file.geometry_restraints_manager()
      pdb_hierarchy = \
        processed_pdb_file.all_chain_proxies.pdb_hierarchy
    pdb_atoms = pdb_hierarchy.atoms()
    self.bonds = mp_bonds(
      pdb_hierarchy=pdb_hierarchy,
      pdb_atoms=pdb_atoms,
      geometry_restraints_manager=geometry_restraints_manager,
      outliers_only=outliers_only)
    self.angles = mp_angles(
      pdb_hierarchy=pdb_hierarchy,
      pdb_atoms=pdb_atoms,
      geometry_restraints_manager=geometry_restraints_manager,
      outliers_only=outliers_only)

  def show_summary(self, out=sys.stdout, prefix=""):
    pass

  def show(self, out=sys.stdout, prefix="", outliers_only=None,
      verbose=True):
    for geo_type in self.__slots__ :
      rv = getattr(self, geo_type)
      if (rv.n_outliers > 0) or (not outliers_only):
        make_sub_header(rv.label, out=out)
        rv.show(out=out)

  def as_JSON(self, addon_json={}):
    if not addon_json:
      addon_json = {}
    mp_json = addon_json
    for slot in self.__slots__:
      slot_json = json.loads(getattr(self, slot).as_JSON())
      mp_json["mp_"+slot] = slot_json
    return json.dumps(mp_json, indent=2)


 *******************************************************************************


 *******************************************************************************
mmtbx/validation/omegalyze.py
from __future__ import absolute_import, division, print_function
from mmtbx.validation import residue, validation, atom
import os.path
from libtbx import slots_getstate_setstate
import numpy
import os, sys
import collections
import json
from iotbx.pdb.hybrid_36 import hy36decode

from mmtbx.conformation_dependent_library import generate_protein_fragments

################################################################################
# omegalyze.py
# This is a class to assess the omega (peptide bond) dihedral in protein
# backbone.  It originated following concerns that cis-peptides, especially
# non-proline cis-peptides were not being flagged by MolProbity, and so
# structures with an improbable over-abundance of cis-peptides were passing
# validation.
#
# This code reuses existing ramalyze code, structure, and naming conventions
# where possible.  Interfacing with this code should be either the same as or
# parallel to interfacing with ramalyze code.
#
################################################################################

#{{{ XXX Use these constants internally, not the strings
OMEGA_GENERAL = 0
OMEGA_PRO = 1

OMEGALYZE_TRANS   =0
OMEGALYZE_CIS     =1
OMEGALYZE_TWISTED =2

res_types = ["non-proline", "proline"] #used in GUI table
res_type_labels = ["non-Pro", "Pro    "] #used in text output for MolProbity
res_type_kin = ["nonPro", "Pro"]
omega_types = ["Trans", "Cis", "Twisted"]
#}}}

class kin_atom(slots_getstate_setstate):
  """Container class used in generation of kinemages."""
  __slots__ = ['id_str','xyz']
  def __init__(self, id_str, xyz):
    self.id_str = id_str
    self.xyz = xyz

def dist(p1,p2):
  return ((p1[0]-p2[0])**2 + (p1[1]-p2[1])**2 + (p1[2]-p2[2])**2)**0.5

def single_offset(p1,p2,offset):
  d = dist(p1,p2)
  return (p1[0]-(p1[0]-p2[0])/d*offset, p1[1]-(p1[1]-p2[1])/d*offset, p1[2]-(p1[2]-p2[2])/d*offset)

class omega_result(residue):
  """
  Result class for protein backbone omega angle analysis (molprobity.omegalyze).
  """
  __omega_attr__ = [
    "res_type",
    "omega_type",
    "omega",
    "is_nontrans",
    "markup_atoms",
    "highest_mc_b",
    "prev_resseq",
    "prev_icode",
    "prev_resname",
    "prev_altloc",
    "model_id"
  ]
  __slots__ = residue.__slots__ + __omega_attr__

  @staticmethod
  def header():
    return "%-31s %-12s %6s %-13s %6s" % ("Residues", "Type", "Omega","Conformation","MC_high_b")

  def residue_type(self):
    return res_type_labels[self.res_type]

  def omegalyze_type(self):
    return omega_types[self.omega_type]

  def residue_type_kin(self):
    return res_type_kin[self.res_type]

  def prev_id_str(self):
    return "%2s%4s%1s%1s%3s" % (
      self.chain_id, self.prev_resseq, self.prev_icode, self.prev_altloc,
      self.prev_resname)

  def as_string(self):
    return "%-12s to %-15s %-12s %6.2f %-13s %6.2f" % (
      self.prev_id_str(),self.id_str(),self.residue_type(),self.omega, self.omegalyze_type(),self.highest_mc_b)

  #For backwards compatibility
  def id_str_old(self):
    return "%s%4s%1s %1s%s" % (self.chain_id, self.resseq, self.icode,
      self.altloc, self.resname)

  def format_old(self):
    return "%s to %s: %s :%s:%s:%s" % (self.prev_id_str(),self.id_str(), self.residue_type(),
      ('%.2f'%self.omega).rjust(7), self.omegalyze_type().ljust(8),self.highest_mc_b)

  def as_JSON(self):
    serializable_slots = [s for s in self.__slots__ if s != 'markup_atoms' and hasattr(self, s)]
    slots_as_dict = ({s: getattr(self, s) for s in serializable_slots})
    slots_as_dict["omega_type"] = omega_types[slots_as_dict["omega_type"]]
    return json.dumps(slots_as_dict, indent=2)

#{'': {'A': {'  41 ': {'': {'altloc': '',
#                           'atom_selection': None,
#                           'chain_id': 'A',
#                           'highest_mc_b': 28.76,
#                           'icode': ' ',
#                           'is_nontrans': True,
#                           'model_id': '',
#                           'occupancy': None,
#                           'omega': -14.27418253081719,
#                           'omega_type': 'Cis',
#                           'outlier': True,
#                           'prev_altloc': '',
#                           'prev_icode': ' ',
#                           'prev_resname': 'PHE',
#                           'prev_resseq': '  40',
#                           'res_type': 1,
#                           'resname': 'PRO',
#                           'resseq': '  41',
#                           'score': None,
#                           'segid': None,
#                           'xyz': [-9.124,
#                                   3.291,
#                                   40.391]}},

  def as_hierarchical_JSON(self):
    hierarchical_dict = {}
    hierarchy_nest_list = ['model_id', 'chain_id', 'resid', 'altloc']
    return json.dumps(self.nest_dict(hierarchy_nest_list, hierarchical_dict), indent=2)

  def as_kinemage(self, triangles=False, vectors=False):
    ca1,c,n,ca2  = self.markup_atoms[0].xyz, self.markup_atoms[1].xyz, self.markup_atoms[2].xyz, self.markup_atoms[3].xyz
    o = 0.1

    d1 = dist(ca1,ca2)
    d2 = dist(n,c)
    d3 = dist(ca1,c)
    d4 = dist(n,ca2)
    d_diag = dist(ca1,n)
    c_n_vec = (n[0]-c[0], n[1]-c[1], n[2]-c[2])
    c_ca1_vec = (ca1[0]-c[0], ca1[1]-c[1], ca1[2]-c[2])
    ca2_ca1_vec =  (ca1[0]-ca2[0], ca1[1]-ca2[1], ca1[2]-ca2[2])
    ca2_n_vec = (n[0]-ca2[0], n[1]-ca2[1], n[2]-ca2[2])
    diag_vec = (n[0]-ca1[0], n[1]-ca1[1], n[2]-ca1[2])

    theta = numpy.arccos(numpy.dot(c_ca1_vec,diag_vec)/d_diag/d3)
    ca1_offset_len = o/numpy.sin(theta)
    ca1_offset = single_offset(ca1,n,ca1_offset_len)

    theta = numpy.arccos(numpy.dot(ca2_n_vec,diag_vec)/d_diag/d4)
    n_offset_len = o/numpy.sin(theta)
    n_offset = single_offset(n,ca1,n_offset_len)

    theta_ca2 = numpy.arccos(numpy.dot(ca2_n_vec,ca2_ca1_vec)/d4/d1)
    ca2_to_ca1_offset_len = o/numpy.sin(theta_ca2)
    ca2_to_ca1_offset = single_offset(ca2,ca1,ca2_to_ca1_offset_len)
    vec_from_offset = (ca2_to_ca1_offset[0]+n[0]-ca2[0], ca2_to_ca1_offset[1]+n[1]-ca2[1], ca2_to_ca1_offset[2]+n[2]-ca2[2])
    theta = -numpy.arccos(numpy.dot(diag_vec,ca2_ca1_vec)/d_diag/d1)
    v1 = -dist(ca1,ca1_offset)*numpy.sin(theta)
    x = v1/numpy.sin(theta_ca2)
    ca2_offset = single_offset(ca2_to_ca1_offset,vec_from_offset, x)

    theta_n = numpy.arccos(numpy.dot(diag_vec,c_n_vec)/d_diag/d2)
    n_to_c_offset_len = o/numpy.sin(theta_n)
    n_to_c_offset = single_offset(c,n,n_to_c_offset_len)

    v2 = dist(n,n_offset)*numpy.sin(theta_n)
    theta_c = numpy.arccos(numpy.dot(c_ca1_vec,c_n_vec)/d2/d3)
    c_to_n_offset_len = o/numpy.sin(theta_c)
    c_to_n_offset = single_offset(c,n,c_to_n_offset_len)
    x2 = v2/numpy.sin(theta_c)
    vec_from_offset = (c_to_n_offset[0]+ca1[0]-c[0], c_to_n_offset[1]+ca1[1]-c[1], c_to_n_offset[2]+ca1[2]-c[2])

    c_offset = single_offset(c_to_n_offset,vec_from_offset,x2)

    #This commented block was the first pass at offseting the triangles
    #  it was abandoned due to moving the drawn ca1-n diagonal off of the actual diagonal
    #o = 0.1 #this is the offset from the backbone in angstrom
    #d1 = ((ca1[0]-ca2[0])**2 + (ca1[1]-ca2[1])**2 + (ca1[2]-ca2[2])**2)**0.5
    #d2 = ((n[0]-c[0])**2 + (n[1]-c[1])**2 + (n[2]-c[2])**2)**0.5
    #d3 = ((ca1[0]-c[0])**2 + (ca1[1]-c[1])**2 + (ca1[2]-c[2])**2)**0.5
    #d4 = ((n[0]-ca2[0])**2 + (n[1]-ca2[1])**2 + (n[2]-ca2[2])**2)**0.5
    #ca1_offset = (ca1[0]+(ca2[0]-ca1[0])/d1*o - (ca1[0]-c[0])/d3*o, ca1[1]+(ca2[1]-ca1[1])/d1*o - (ca1[1]-c[1])/d3*o, ca1[2]+(ca2[2]-ca1[2])/d1*o - (ca1[2]-c[2])/d3*o)
    #ca2_offset = (ca2[0]-(ca2[0]-ca1[0])/d1*o - (ca2[0]-n[0])/d4*o, ca2[1]-(ca2[1]-ca1[1])/d1*o - (ca2[1]-n[1])/d4*o, ca2[2]-(ca2[2]-ca1[2])/d1*o - (ca2[2]-n[2])/d4*o)
    #c_offset = (c[0]+(n[0]-c[0])/d2*o+(ca1[0]-c[0])/d3*o, c[1]+(n[1]-c[1])/d2*o+(ca1[1]-c[1])/d3*o, c[2]+(n[2]-c[2])/d2*o+(ca1[2]-c[2])/d3*o)
    #n_offset = (n[0]-(n[0]-c[0])/d2*o+(ca2[0]-n[0])/d4*o, n[1]-(n[1]-c[1])/d2*o+(ca2[1]-n[1])/d4*o, n[2]-(n[2]-c[2])/d2*o+(ca2[2]-n[2])/d4*o)
    if triangles:
      triangle1_line1 = "{%s CA  (%s %s, omega= %.2f)} P X %s\n" % (
        self.markup_atoms[0].id_str, self.omegalyze_type(),
        self.residue_type_kin(), self.omega,
        "%.3f %.3f %.3f" % ca1_offset)
      triangle1_line2 =      "{%s C  (%s %s, omega= %.2f)} %s\n" % (
        self.markup_atoms[1].id_str, self.omegalyze_type(),
        self.residue_type_kin(), self.omega,
        "%.3f %.3f %.3f" % c_offset)
      triangle1_line3 =      "{%s N  (%s %s, omega= %.2f)} %s\n" % (
        self.markup_atoms[2].id_str, self.omegalyze_type(),
        self.residue_type_kin(), self.omega,
        "%.3f %.3f %.3f" % n_offset)
      triangle2_line1 = "{%s CA  (%s %s, omega= %.2f)} P X %s\n" % (
        self.markup_atoms[0].id_str, self.omegalyze_type(),
        self.residue_type_kin(), self.omega,
        "%.3f %.3f %.3f" % ca1_offset)
      triangle2_line2 =      "{%s N  (%s %s, omega= %.2f)} %s\n" % (
        self.markup_atoms[2].id_str, self.omegalyze_type(),
        self.residue_type_kin(), self.omega,
        "%.3f %.3f %.3f" % n_offset)
      triangle2_line3 =     "{%s CA  (%s %s, omega= %.2f)} %s\n" % (
        self.markup_atoms[3].id_str, self.omegalyze_type(),
        self.residue_type_kin(), self.omega,
        "%.3f %.3f %.3f" % ca2_offset)
      out_this = triangle1_line1 + triangle1_line2 + triangle1_line3 + triangle2_line1 + triangle2_line2 + triangle2_line3
    elif vectors:
      vector_line1 = "{%s CA  (%s %s, omega= %.2f)} P %s\n" % (
        self.markup_atoms[0].id_str, self.omegalyze_type(),
        self.residue_type_kin(), self.omega,
        "%.3f %.3f %.3f" % ca1_offset)
      if self.omega_type == OMEGALYZE_CIS:
        vector_line2 = "{%s CA  (%s %s, omega= %.2f)} %s\n" % (
          self.markup_atoms[3].id_str, self.omegalyze_type(),
          self.residue_type_kin(), self.omega,
          "%.3f %.3f %.3f" % ca2_offset)
      elif self.omega_type == OMEGALYZE_TWISTED:
        vector_line2 = "{%s N  (%s %s, omega= %.2f)} %s\n" % (
          self.markup_atoms[2].id_str, self.omegalyze_type(),
          self.residue_type_kin(), self.omega,
          "%.3f %.3f %.3f" % n_offset)
      else:
        return ""
      out_this = vector_line1 + vector_line2
    return out_this

  #def as_table_row_phenix(self):
  #  return [ self.chain_id, "%s %s" % (self.resname, self.resid),
  #           res_types[self.res_type], self.omega, omega_types[self.omega_type] ]

  def as_table_row_phenix(self):
    #'%4s%1s' string formatting for previous residue matched string formatting within self.resid
    return [ self.chain_id, "%1s%s %4s%1s to %1s%s %s" % (self.prev_altloc, self.prev_resname, self.prev_resseq, self.prev_icode, self.altloc, self.resname, self.resid),
             res_types[self.res_type], self.omega, omega_types[self.omega_type] ]

#the ramachandran_ensemble class is only called in mmtbx/validation/ensembles
# and does not seem to provide functionality useful to omega analysis
#So it is omitted for the moment

class omegalyze(validation):
  """
  Frontend for calculating omega angle statistics for a model.
  """
  __slots__ = validation.__slots__ + [
    "residue_count_by_model",
    "omega_count_by_model",
    "residue_count",
    "omega_count",
    "_outlier_i_seqs"
    ]

  program_description = "Analyze protein backbone peptide dihedrals (omega)"
  output_header = "residues:type:omega:conformation:mc_bmax"

  gui_list_headers = ["Chain","Residues","Residue type","omega","conformation"]
  gui_formats = ["%s", "%s", "%s", "%.2f", "%s"]
  wx_column_widths = [75,200,125,125,125]

  def get_result_class(self): return omega_result

  def __init__(self,
      pdb_hierarchy,
      nontrans_only=False,
      out=sys.stdout,
      quiet=True):
    validation.__init__(self)
    self.residue_count = [0, 0]
    #[OMEGA_GENERAL, OMEGA_PRO]
    self.omega_count = [[0,0,0], [0,0,0]]
    #[OMEGA_GENERAL, OMEGA_PRO], then
    #[OMEGALYZE_TRANS, OMEGALYZE_CIS, OMEGALYZE_TWISTED]
    self.residue_count_by_model = {}
    self.omega_count_by_model = {}

    from mmtbx.validation import utils
    from scitbx.array_family import flex
    self._outlier_i_seqs = flex.size_t()
    pdb_atoms = pdb_hierarchy.atoms()
    all_i_seqs = pdb_atoms.extract_i_seq()
    if all_i_seqs.all_eq(0):
      pdb_atoms.reset_i_seq()
    use_segids = utils.use_segids_in_place_of_chainids(
      hierarchy=pdb_hierarchy)

    first_conf_altloc = None
    prev_chain_id = None
    for twores in generate_protein_fragments(
        pdb_hierarchy,
        length=2,
        geometry=None,
        include_non_standard_peptides=True,
        include_d_amino_acids=True):
      main_residue = twores[1] #this is the relevant residue for id-ing cis-Pro
      conf_altloc = get_conformer_altloc(twores)
      omega_atoms = get_omega_atoms(twores)
      # omega_atoms is the list [CA1 C1 N2 CA2], with None for missing atoms
      if None in omega_atoms:
        continue
      twores_altloc = local_altloc_from_atoms(omega_atoms)

      model_id = twores[0].parent().parent().parent().id
      if model_id not in self.residue_count_by_model:
        self.residue_count_by_model[model_id] = [0,0]
        self.omega_count_by_model[model_id] = [[0,0,0],[0,0,0]]
      chain = main_residue.parent().parent()
      if use_segids:
        chain_id = utils.get_segid_as_chainid(chain=chain)
      else:
        chain_id = chain.id

      if chain_id != prev_chain_id: #if we've moved to a new chain...
        first_conf_altloc = conf_altloc #...reset reference altloc
        prev_chain_id = chain_id
      if (conf_altloc != first_conf_altloc) and twores_altloc == '':
        #skip non-alternate residues unless this is the first time thru a chain
        continue

      omega = get_omega(omega_atoms)
      if omega is None: continue
      omega_type = find_omega_type(omega)
      if omega_type == OMEGALYZE_TRANS:
        is_nontrans = False
      else:
        is_nontrans = True
        self.n_outliers += 1
      if main_residue.resname == "PRO": res_type = OMEGA_PRO
      else:                             res_type = OMEGA_GENERAL
      self.residue_count[res_type] += 1
      self.residue_count_by_model[model_id][res_type] += 1
      self.omega_count[res_type][omega_type] += 1
      self.omega_count_by_model[model_id][res_type][omega_type] += 1
      highest_mc_b = get_highest_mc_b(twores[0].atoms(),twores[1].atoms())
      coords = get_center(main_residue)
      markup_atoms = []
      for omega_atom in omega_atoms:
        markup_atoms.append(kin_atom(omega_atom.parent().id_str(), omega_atom.xyz))

      result = omega_result(
                model_id=model_id,
                chain_id=chain_id,
                resseq=main_residue.resseq,
                icode=main_residue.icode,
                resname=main_residue.resname,
                altloc=local_altloc_from_atoms(omega_atoms[2:]),
                prev_resseq=twores[0].resseq,
                prev_icode=twores[0].icode,
                prev_resname=twores[0].resname,
                prev_altloc=local_altloc_from_atoms(omega_atoms[0:2]),
                segid=None,
                omega=omega,
                omega_type=omega_type,
                res_type=res_type,
                is_nontrans=is_nontrans,
                outlier=is_nontrans,
                highest_mc_b=highest_mc_b,
                xyz=coords,
                markup_atoms=markup_atoms)

      if is_nontrans or not nontrans_only: #(not nontrans_only or is_nontrans)
        self.results.append(result)
      if is_nontrans:
        i_seqs = main_residue.atoms().extract_i_seq()
        assert (not i_seqs.all_eq(0)) #This assert copied from ramalyze
        self._outlier_i_seqs.extend(i_seqs)
    self.results.sort(key=lambda r: (r.model_id, r.chain_id, int(hy36decode(len(r.resseq), r.resseq)), r.icode, r.altloc))

  def _get_count_and_fraction(self, res_type, omega_type):
    total = self.residue_count[res_type]
    if total == 0:
      return 0, 0.0
    else:
      count = self.omega_count[res_type][omega_type]
      fraction = float(count) / total
      return count, fraction

  def as_kinemage(self):
    outlist = []
    cisprolist = []
    cisnonprolist = []
    cisprovectorlist = []
    cisnonprovectorlist = []
    twistlist = []
    twistvectorlist = []
    cisprohead = ["@subgroup {Cis proline} dominant master= {Cis proline} off\n",
      "@trianglelist {cis pro omega triangles} color= sea\n"]
    cisnonprohead = [
      "@subgroup {Cis peptides} dominant master= {Cis non-proline}\n",
      "@trianglelist {cis nonpro omega triangles} color= lime\n"]
    twisthead = [
      "@subgroup {Twisted peptides} dominant master= {Twisted peptides}\n",
      "@trianglelist {twisted omega triangles} color= yellow\n"]
    cisprovectorhead = ["@vectorlist {cis pro omega vectors} color= sea width=3\n"]
    cisnonprovectorhead = ["@vectorlist {cis nonpro omega vectors} color= lime width=3\n"]
    twistvectorhead=[
    "@vectorlist {twisted omega vectors} color= yellow width=3\n"]
    for result in self.results:
      if result.omega_type == OMEGALYZE_CIS:
        if result.res_type == OMEGA_PRO:
          cisprolist.append(result.as_kinemage(triangles=True))
          cisprovectorlist.append(result.as_kinemage(vectors=True))
        else:
          cisnonprolist.append(result.as_kinemage(triangles=True))
          cisnonprovectorlist.append(result.as_kinemage(vectors=True))
      elif result.omega_type == OMEGALYZE_TWISTED:
        twistlist.append(result.as_kinemage(triangles=True))
        twistvectorlist.append(result.as_kinemage(vectors=True))
    if cisprolist:
      outlist = outlist + cisprohead + cisprolist + cisprovectorhead + cisprovectorlist
    if cisnonprolist:
      outlist = outlist + cisnonprohead + cisnonprolist + cisnonprovectorhead + cisnonprovectorlist
    if twistlist:
      outlist = outlist + twisthead + twistlist + twistvectorhead + twistvectorlist
    return "".join(outlist)
    #it's my understanding that .join(list) is more efficient than string concat

  def as_coot_data(self):
    data = []
    for result in self.results:
      if result.is_nontrans:
        data.append((result.chain_id, result.resid, result.resname, result.score, result.xyz))
    return data

  def as_JSON(self, addon_json={}):
    # self.chain_id, "%1s%s %4s%1s to %1s%s %s" % (self.prev_altloc, self.prev_resname, self.prev_resseq, self.prev_icode, self.altloc, self.resname, self.resid),
    #         res_types[self.res_type], self.omega, omega_types[self.omega_type] ]
    # keep names roughly the same
    #check name in program template
    # {model: {1: {chain: {A: {residue_group: {1A: results}}}}}}
    if not addon_json:
      addon_json = {}
    addon_json["validation_type"] = "omegalyze"
    data = addon_json
    flat_results = []
    hierarchical_results = {}
    summary_results = {}
    #hierarchical_results_dict = collections.defaultdict(dict)
    #hierarchical_results_dict['model_id']['chain_id']['resseq+icode']['resname'] = 'result'
    #print(hierarchical_results_dict)
    for result in self.results:
      flat_results.append(json.loads(result.as_JSON()))
      hier_result = json.loads(result.as_hierarchical_JSON())
      hierarchical_results = self.merge_dict(hierarchical_results, hier_result)

    data['flat_results'] = flat_results
    data['hierarchical_results'] = hierarchical_results
    for model_id in self.residue_count_by_model.keys():
      summary_results[model_id] = {
        "num_cis_proline" : self.n_cis_proline_by_model(model_id),
        "num_twisted_proline" : self.n_twisted_proline_by_model(model_id),
        "num_proline" : self.n_proline_by_model(model_id),
        "num_cis_general" : self.n_cis_general_by_model(model_id),
        "num_twisted_general" : self.n_twisted_general_by_model(model_id),
        "num_general" : self.n_general_by_model(model_id),
      }
    data['summary_results'] = summary_results

    return json.dumps(data, indent=2)

  def show_summary(self, out=sys.stdout, prefix=""):
    print(prefix + 'SUMMARY: %i cis prolines out of %i PRO' % (
      self.n_cis_proline(),
      self.n_proline()), file=out)
    print(prefix + 'SUMMARY: %i twisted prolines out of %i PRO' % (
      self.n_twisted_proline(),
      self.n_proline()), file=out)
    print(prefix + 'SUMMARY: %i other cis residues out of %i nonPRO' % (
      self.n_cis_general(),
      self.n_general()), file=out)
    print(prefix + 'SUMMARY: %i other twisted residues out of %i nonPRO' % (
      self.n_twisted_general(),
      self.n_general()), file=out)

  def summary_only(self, out=sys.stdout, pdbid="pdbid"):
    out.write(os.path.basename(pdbid) + ":")
    if self.n_cis_proline() == 0:
      out.write("0:")
    else:
      out.write('%.3f' % (self.n_cis_proline()/self.n_proline()*100)+":")
    if self.n_twisted_proline() == 0:
      out.write("0:")
    else:
      out.write('%.3f' % (self.n_twisted_proline()/self.n_proline()*100)+":")
    out.write("%i" % self.n_proline() + ":")
    if self.n_cis_general() == 0:
      out.write("0:")
    else:
      out.write('%.3f' % (self.n_cis_general()/self.n_general()*100)+":")
    if self.n_twisted_general() == 0:
      out.write("0:")
    else:
      out.write('%.3f' % (self.n_twisted_general()/self.n_general()*100)+":")
    out.write("%i" % self.n_general() + "\n")

  def gui_summary(self):
    output = []
    if self.n_cis_proline() or self.n_proline():
      output.append('%i cis prolines out of %i PRO' % (self.n_cis_proline(),self.n_proline()))
    if self.n_twisted_proline():
      output.append('%i twisted prolines out of %i PRO' % (self.n_twisted_proline(),self.n_proline()))
    if self.n_cis_general():
      output.append('%i cis residues out of %i nonPRO' % (self.n_cis_general(),self.n_general()))
    if self.n_twisted_general():
      output.append('%i twisted residues out of %i nonPRO' % (self.n_twisted_general(),self.n_general()))
    return "\n".join(output)

  def n_proline(self):
    return self.residue_count[OMEGA_PRO]
  def n_trans_proline(self):
    return self.omega_count[OMEGA_PRO][OMEGALYZE_TRANS]
  def n_cis_proline(self):
    return self.omega_count[OMEGA_PRO][OMEGALYZE_CIS]
  def n_twisted_proline(self):
    return self.omega_count[OMEGA_PRO][OMEGALYZE_TWISTED]

  def n_general(self):
    return self.residue_count[OMEGA_GENERAL]
  def n_trans_general(self):
    return self.omega_count[OMEGA_GENERAL][OMEGALYZE_TRANS]
  def n_cis_general(self):
    return self.omega_count[OMEGA_GENERAL][OMEGALYZE_CIS]
  def n_twisted_general(self):
    return self.omega_count[OMEGA_GENERAL][OMEGALYZE_TWISTED]

  def n_proline_by_model(self, model_id):
    return self.residue_count_by_model[model_id][OMEGA_PRO]
  def n_trans_proline_by_model(self, model_id):
    return self.omega_count_by_model[model_id][OMEGA_PRO][OMEGALYZE_TRANS]
  def n_cis_proline_by_model(self, model_id):
    return self.omega_count_by_model[model_id][OMEGA_PRO][OMEGALYZE_CIS]
  def n_twisted_proline_by_model(self, model_id):
    return self.omega_count_by_model[model_id][OMEGA_PRO][OMEGALYZE_TWISTED]

  def n_general_by_model(self, model_id):
    return self.residue_count_by_model[model_id][OMEGA_GENERAL]
  def n_trans_general_by_model(self, model_id):
    return self.omega_count_by_model[model_id][OMEGA_GENERAL][OMEGALYZE_TRANS]
  def n_cis_general_by_model(self, model_id):
    return self.omega_count_by_model[model_id][OMEGA_GENERAL][OMEGALYZE_CIS]
  def n_twisted_general_by_model(self, model_id):
    return self.omega_count_by_model[model_id][OMEGA_GENERAL][OMEGALYZE_TWISTED]

def write_header(writeto=sys.stdout):
  writeto.write("residue:omega:evaluation\n")

def find_omega_type(omega):
  if (omega > -30) and (omega < 30): omega_type = OMEGALYZE_CIS
  elif (omega < -150) or (omega > 150): omega_type = OMEGALYZE_TRANS
  else: omega_type = OMEGALYZE_TWISTED
  return omega_type

def get_omega(omega_atoms):
  #omega_atoms = [CA1 C1 N2 CA2]
  if None in omega_atoms:
    return None
  import mmtbx.rotamer
  return mmtbx.rotamer.omega_from_atoms(omega_atoms[0], omega_atoms[1], omega_atoms[2], omega_atoms[3])

def get_highest_mc_b(prev_atoms, atoms):
  highest_mc_b = 0
  if (prev_atoms is not None):
    for atom in prev_atoms:
      if atom is not None and atom.name in [" CA "," C  "," N  "," O  ","CB"]:
        if atom.b > highest_mc_b:
          highest_mc_b = atom.b
  if (atoms is not None):
    for atom in atoms:
      if atom is not None and atom.name in [" CA "," C  "," N  "," O  ","CB"]:
        if atom.b > highest_mc_b:
          highest_mc_b = atom.b
  return highest_mc_b

def get_center(ag):
  for atom in ag.atoms():
    if (atom.name == " N  "):
      return atom.xyz
  return ag.atoms().extract_xyz().mean()

def get_conformer_altloc(twores):
  return twores[0].parent().altloc #go to conformer level

def local_altloc_from_atoms(atom_list):
  for atom in atom_list:
    if atom is not None:
      altloc = atom.parent().altloc #go to atom_group level
      if altloc != '':
        return altloc
  return ''

def get_omega_atoms(twores):
  atomlist = [twores[0].find_atom_by(name=" CA "),
              twores[0].find_atom_by(name=" C  "),
              twores[1].find_atom_by(name=" N  "),
              twores[1].find_atom_by(name=" CA ")]
  return atomlist


 *******************************************************************************


 *******************************************************************************
mmtbx/validation/phi_psi_2_data.py
from __future__ import absolute_import, division, print_function
import time
from mmtbx.conformation_dependent_library.cdl_utils import round_to_int
from collections import OrderedDict

# validation_types
validation_types = OrderedDict([
  ('MOTIF05'  , 'Motif (05)'),
  ('MOTIF'    , 'Motif (10)'),
  ('MOTIF20'  , 'Motif (20)'),
  ('MOTIF...' , 'Motif (->)'),
  ('GENERAL'  , 'General'),
  ('CIS'      , 'cis-peptide'),
  ('OUTLIER'  , 'Outlier'),
  ('ERROR'    , 'Error'),
])

phi_psi_2_peaks = {
  (-63, -42, -63, -42) : ['AA.1', 12120], #1
  (-64, -23, -87, -2) : ['AD.1', 499],
  (-115, 128, -118, 126) : ['BB.1', 223],
  (-68, 159, -57, -40) : ['PA.1', 216],
  (-55, 133, 87, -7) : ['Pd.1', 149],
  (-67, 148, -62, 140) : ['PP.1', 136],
  (-90, -3, -67, 139) : ['DP.1', 102],
  (-140, 158, -66, 146) : ['BP.1', 78],
  (-86, -2, 75, 22) : ['Dd.1', 74],
  (-118, 125, -66, 133) : ['BP.2', 72], #10
  (-92, -2, -58, -43) : ['DA.1', 67],
  (-63, 145, -136, 155) : ['PB.1', 67],
  (-79, 135, -133, 160) : ['PB.2', 64],
  (-66, 144, -118, 128) : ['PB.3', 63],
  (53, 37, 81, 2) : ['dd.1', 60],
  (-147, 159, -147, 156) : ['BB.2', 55],
  (-103, 14, -59, -34) : ['DA.2', 53],
  (-90, 123, -67, 138) : ['BP.3', 51],
  (-136, 161, -57, -41) : ['BA.1', 49],
  (91, -9, -70, 145) : ['dP.1', 48], # 20
  (-95, 107, -68, -20) : ['BA.2', 40],
  (-129, 124, 51, 41) : ['Bd.1', 36],
  (-133, 72, -65, -21) : ['ZA.1', 35],
  (54, -131, -70, -10) : ['pD.1', 34],
  (-80, -22, -159, 165) : ['DB.1', 34],
  (-68, 133, -117, -14) : ['PD.1', 34],
  (59, -132, -93, 8) : ['pD.2', 33],
  (-160, 166, -62, -37) : ['BA.3', 33],
  (-115, 101, -59, -36) : ['BA.4', 32],
  (-89, -29, -147, 151) : ['DB.2', 30], #30
  (-70, -39, -129, 80) : ['AZ.1', 28],
  (-115, -16, -155, 147) : ['DB.3', 28],
  (80, 4, -114, 140) : ['dB.1', 26],
  (-77, -43, -161, 158) : ['DB.4', 26],
  (-75, 124, -94, -35) : ['PD.2', 26],
  (77, 8, -120, 154) : ['dB.2', 25],
  (53, 57, -66, 153) : ['dP.2', 23],
  (58, 26, 57, 37) : ['dd.2', 22],
  (-124, 84, -66, 148) : ['ZP.1', 22],
  (61, 33, -61, -34) : ['dA.1', 21], #40
  (72, 22, -105, 151) : ['dB.3', 21],
  (-61, 138, -105, 6) : ['PD.3', 20],
  (-67, 159, 61, 35) : ['Pd.2', 19],
  (-92, -2, -132, 161) : ['DB.5', 19],
  (-90, 7, -116, 147) : ['DB.6', 19],
  (62, 35, -118, 162) : ['dB.4', 18],
  (48, 59, -66, -23) : ['dA.2', 18],
  (-77, -16, -130, 69) : ['AZ.2', 18],
  (85, -3, -64, -36) : ['dA.3', 17],
  (-89, 80, -76, -15) : ['gD.1', 16], #50
  (-83, -8, -131, 54) : ['AZ.3', 16],
  (-141, 100, -62, -28) : ['BA.5', 16],
  (-63, 134, -84, 81) : ['Pg.1', 15],
  (-132, 61, -65, 146) : ['ZP.2', 15],
  (-154, 153, -112, 10) : ['BD.1', 14],
  (-64, -40, -78, 125) : ['DP.2', 14],
  (-140, 131, -68, -17) : ['BA.6', 14],
  (80, 15, -94, -9) : ['dD.1', 13],
  (-89, -5, -123, 28) : ['DD.1', 13],
  (-78, -7, -120, 78) : ['AZ.4', 13], #60
  (-130, 5, 73, 15) : ['Dd.2', 12],
  (54, 42, -91, -3) : ['dD.2', 12],
  (-85, 71, -66, 144) : ['gP.1', 12],
  (-71, 118, -113, 16) : ['PD.4', 12],
  (-65, -41, -78, 153) : ['DP.3', 12],
  (-64, -32, 54, 57) : ['Dd.3', 12],
  (-62, -42, -115, 131) : ['DB.7', 12],
  (-126, 133, -106, 6) : ['BD.2', 12],
  (-134, 113, 59, -127) : ['Bp.1', 11],
  (-127, 99, 59, -124) : ['Bp.2', 11], #70
  (-101, 3, -129, 38) : ['DD.2', 11],
  (62, 25, -84, -8) : ['dD.3', 11],
  (-114, 13, -81, -16) : ['DD.3', 11],
  (61, 37, -104, 2) : ['dD.4', 10],
  (-86, 143, 50, 55) : ['Pd.3', 10],
  (-71, -15, -79, 78) : ['Dg.1', 10],
  (-153, 173, 55, 48) : ['Bd.2', 10],
  (-127, 2, -133, 128) : ['DB.8', 10],
  (-122, 128, -85, 80) : ['Bg.1', 10],
  (87, 175, -74, -16) : ['ED.1', 9], #80
  (97, -12, -77, -12) : ['dD.5', 9],
  (75, -173, -63, 143) : ['pP.1', 9],
  (-83, -12, -124, 105) : ['DB.9', 9],
  (-71, -14, 89, 175) : ['DE.1', 9],
  (-62, 137, -140, 16) : ['PD.5', 9],
  (-154, 168, -97, 1) : ['BD.3', 9],
  (87, 8, -149, 162) : ['dB.5', 8],
  (64, 31, -126, 24) : ['dD.6', 8],
  (168, -152, -135, 151) : ['EB.1', 8],
  (-99, 7, -80, 84) : ['Dg.2', 8], #90
  (-84, 69, -163, 150) : ['gB.1', 8],
  (-83, 68, -84, 173) : ['gP.2', 8],
  (-69, -35, 64, -153) : ['Ap.1', 8],
  (-64, 144, -138, 93) : ['PB.4', 8],
  (-129, 159, -103, -7) : ['BD.4', 8],
  (-121, -9, -65, -18) : ['DA.3', 8],
  (-114, 20, -116, 155) : ['DB.10', 8],
  (-103, 136, 60, 36) : ['Bd.3', 8],
  (-102, 8, -107, -178) : ['DP.4', 8],
  (-102, 114, -84, 78) : ['Bg.2', 8], #100
  (-102, -24, -116, -59) : ['DD.4', 8],
  }

class phi_psi_2_mask_class(dict):
  def __init__(self):
    self.data = {
      180  : "BBBBBBBBBBBBBBBPPPPPPPPPP                      pppppppppppEEEEEEEEEEBBBBB",
      175  : "BBBBBBBBBBBBBBBPPPPPPPPPPP                     pppppppppppEEEEEEEEEEEBBBB",
      170  : "BBBBBBBBBBBBBBBPPPPPPPPPPPP                      pppppppppEEEEEEEEEEEEBBB",
      165  : "BBBBBBBBBBBBBBBBPPPPPPPPPPP                      pppppppppEEEEEEEEEEEEEBB",
      160  : "BBBBBBBBBBBBBBBBBPPPPPPPPPPP                     EEEEEEEEEEEEEEEEEEEEEEBB",
      155  : "BBBBBBBBBBBBBBBBBPPPPPPPPPPP                    EEEEEEEEEEEEEEEEEEEEEEE B",
      150  : "BBBBBBBBBBBBBBBBBPPPPPPPPPPP                    EEEEEEEEEEEEEEEEEEEEEEEEB",
      145  : "BBBBBBBBBBBBBBBBBPPPPPPPPPPPP                     EEEEEEEEEEEE EEEEEEEEEB",
      140  : "BBBBBBBBBBBBBBBBBBPPPPPPPPPPPPP                  EEEEEEEEEEEEEEEEEE  EE B",
      135  : "BBBBBBBBBBBBBBBBBBBPPPPPPPPPPPP                  EEEEEEEEEEEEEEEE     EEB",
      130  : " BBBBBBBBBBBBBBBBBBPPPPPPPPPPPP                    EEEEEEEEEE EE  EEE EE ",
      125  : " BBBBBBBBBBBBBBBBBBPPPPPPPPPPPP                      EEEEEEE  EE  EEE    ",
      120  : " BBBBBBBBBBBBBBBBBBBPPPPPPPPPPP                      EEEEEEE  EE EE      ",
      115  : " BBBBBBBBBBBBBBBBBBBPPPPPPPPPP                   EE    EEEEEEE EEEE      ",
      110  : " BBBBBBBBBBBBBBBBBBBPPPPPPPPPP                   EEEEEEEEE EEE EE        ",
      105  : "BBBBBBBBBBBBBBBBBBBBPPPPP                          EEEEE   EEE          B",
      100  : "BBBBBBBBBBBBBBBBBBBBPPPP                   UU         EE    EEEE        B",
      95   : " BBBBBBBBBBZBBBBBBBBPPPP                   UU    dd   EE    EEEE         ",
      90   : " ZZZZZZZZZZZZZBBBBBBggg                         dddddddd UU EE UU     UU ",
      85   : "  ZZZZZZZZZZZZBBBgggggg                        dddddddd  UU    UU     UU ",
      80   : "  ZZZZZZZZZZZZggggggggg                     ddddddd                      ",
      75   : "  ZZZZZZZZZZZZggggggggg                     dddddddddd dd UU             ",
      70   : "  ZZZZZZZZZZZZggggggggg                   dddddddddddd dd UU             ",
      65   : "  ZZZZZZZZZZZZgggggggg                    ddddddddddd ddd                ",
      60   : "    ZZZZZZZZZZgggggggg                    ddddddddddd dd                 ",
      55   : "   ZZZZZZZZZZZgggggggggg                   dddddddddd    dd              ",
      50   : "  ZZZZZZZZZZZZgggggggggg                   ddddddddddd   dd dd           ",
      45   : "  DDDDDDDDZZZZgggggggg                     dddddddddddddd dddd           ",
      40   : "    DDDDDDDDDDDDDDgggg                     dddddddddddddd ddddd          ",
      35   : "    DDDDDDDDDDDDDDDDDg                      ddddddddddddddddddd          ",
      30   : "   DDDDDDDDDDDDDDDDDDD                      dddddddddddddddddd           ",
      25   : "   DDDDDDDDDDDDDDDDDD                        dddddddddddddddddd          ",
      20   : "    DDDDDDDDDDDDDDDDDD                        ddddddddddddddddd  UU      ",
      15   : "   DDDDDDDDDDDDDDDDDDDDD                      dddddddddddddddd   UU      ",
      10   : "  UUUUDDDDDDDDDDDDDDDDDD                       ddddddddddddddddd         ",
      5    : "  UU  DDDDDDDDDDDDDDDDDDD                       dddddddddddddddd         ",
      0    : "      DDDDDDDDDDDDDDDDDDD                        dddddddddddddddd        ",
      -5   : "      DDDDDDDDDDDDDDDDDDD                        dddddddddddddddd        ",
      -10  : "     DDDDDDDDDDDDDDDDDDDDD                      dddddddddddddddddd       ",
      -15  : "     DDDDDDDDDDDDDDDDDAADDD                     ddddddddddddddddddd      ",
      -20  : "      DDDDDDDDDDDDDDDAAAAAA                      dddddddddddddddddd      ",
      -25  : "   DDDDDDDDDDDDDDDDDAAAAAAAA                     dd ddddddddddddd        ",
      -30  : "  DDDDDDDDDDDDDDDDDDAAAAAAAA                      dddddddddddd ddddd     ",
      -35  : "  DD DDDDDDDDDDDDDDDAAAAAAAAA                    GGG ddddddddd ddddd     ",
      -40  : "    DD DDDDDDDDDDDDDAAAAAAAAA                    GGGGGG dddd    dddd     ",
      -45  : "    DD DDDDDDDDDDDDDAAAAAAAAAA                   GGGGGG   dd     dd      ",
      -50  : "    DDDDDDDDDDDDDDDDAAAAAAAAAAD                  GGGGGG   dd             ",
      -55  : "  DDDDDDDDDDDDDDDDDDAAAAAAAAAAD                  GGGGGG       UU         ",
      -60  : "  DDDDDDDDDDDDDDDDDDAAAAAAAAAADD                 GGGGGG   GG  UUU        ",
      -65  : "   DDDDDDDDDDDDDDDDDAAAAAAAAA DD                 GGGGGGG  GG   UU        ",
      -70  : "  DDDDDDDDDDDDDDDDDDDDDD DDDD                    GGGGGGG                 ",
      -75  : "  DDDDDDDDDDDDDDDDDDDDD  DDDD                     GG GGGG     UU         ",
      -80  : "    DDD DDDDDDDDDDDDD                               GGGGG     UU         ",
      -85  : "    DD     DDDDDDDDDD              UU               GGG   GG             ",
      -90  : "        UU  DDDDDD DD              UU           pp   GGGGGGG             ",
      -95  : "     UU UUUUUUUUUU                              pp pp  GGGG              ",
      -100 : "     UU UUUUUUUUUU                                ppp   GG               ",
      -105 : "      EEEEEEEEEEE            UU                pppppppp GG     UUUU      ",
      -110 : "UUU  EEEEEEEEEEEEE           UU            pp pppppppppp       UUUU    UU",
      -115 : "UUU  EEEEEEEEEEEEEE                        ppppppppp ppppp             UU",
      -120 : " UU  EEEEEEEEEEEEEEE                      pppppppppppppppp  EE     EE    ",
      -125 : "       EEEEEEEEEEEEE                      ppppppppppppppp  EEEEE   EEE   ",
      -130 : "      EEEEEEEEEEEEEE                       pppppppppppppp  EEEEE   EEEEE ",
      -135 : "EEEE EEEEEEEEEEEEEE                         ppppppppppppppEEEEE   EEEEEEE",
      -140 : "EEEE EEEEEEEEEEEEEEEE                        pppppppppppppEEEEEEE EEEEEEE",
      -145 : "EEEEEEEEEEEEEEEEEEEEE                         pppppppppppppEEEEEEEEEEEEEE",
      -150 : "EEEEEEEEEEEEEEEEEEEEE                         pppppppppppppEEEEEEEEEEEEEE",
      -155 : "EEEEEEEEEEEEEEEEEEEEEEE                       pppppppppppppEEEEEEEEEEEEEE",
      -160 : "EEEEEEEEEEEEEEEEEEEEEEE                     UU pppppppppppppEEEEEEEEEEEEE",
      -165 : "BBBBBBBBEEEEEEEEPPPPPPPP                    UU pppppppppppppEEEEEEEEEEEBB",
      -170 : "BBBBBBBBBBEEEEEEPPPPPPPP                       pppppppppppppEEEEEEEEEEEBB",
      -175 : "BBBBBBBBBBBBEEEEPPPPPPPPP                      pppppppppppEEEEEEEEEEEEBBB",
      -180 : "BBBBBBBBBBBBBBBBPPPPPPPPP                      pppppppppppEEEEEEEEEEBBBBB",
    #         0123456789012345678901234567890123456789012345678901234567890123456789012
    #                   1         2         3         4         5         6         7
    }

  def __getitem__(self, key):
    if key[1] in self.data:
      ptr = (key[0]+180)//5
      return self.data[key[1]][ptr:ptr+1]
    else:
      assert 0, 'key %(key)s not found' % locals()

  def get(self, key, default):
    if key[1] in self.data.keys():
      return self.__getitem__(key)
    else:
      return default

  def get_closest(self, key):
    new = (round_to_int(key[0], 5), round_to_int(key[1], 5))
    return self.get(new, None)

phi_psi_2_mask = phi_psi_2_mask_class()

class probability_class(dict):
  def __repr__(self):
    outl = ''
    for region, item in self.items():
      outl += '%s\n' % region#, sum(item.values())
      total = 0
      for pp2, p in item.items():
        total+=p
        outl += "  %s : %5.1f %5.1f\n" % (pp2,p,total)
    return outl

  def get_relative_probability(self, motif_key):
    key = motif_key.split()[0]
    prob = self.get(key[0], None)
    if prob is None:
      return None
    return prob.get(key, None)

class probability_distribution(dict):
  def __repr__(self):
    outl = ''
    keys = self.get_ordered_keys()
    for motif in keys:
      outl += '  %-5s : %5.2f\n' % (motif, self[motif]*100)
    return outl

  def get_ordered_keys(self):
    sort_orders = sorted(self.items(), key=lambda x: x[1], reverse=True)
    tmp = []
    for item in sort_orders: tmp.append(item[0])
    return tmp

def relative_probabilities(ignore_alpha_beta=False,
                           reverse_relationships=False,
                           ):
  data = probability_class()
  for key, item in phi_psi_2_peaks.items():
    if ignore_alpha_beta and (item[0].find('AA')>-1 or item[0].find('BB')>-1):
      continue
    if reverse_relationships:
      data.setdefault(item[0][1], {})
      data[item[0][1]][item[0]] = item[1]
    else:
      data.setdefault(item[0][0], {})
      data[item[0][0]][item[0]] = item[1]
  for region, item in data.items():
    total = sum(item.values())
    for pp2, n in item.items():
      item[pp2] = n/total*100
  if reverse_relationships: return data
  tmp = {}
  for region, item in data.items():
    for pp2, n in item.items():
      key = pp2.split('.')[0]
      tmp.setdefault(key, 0)
      tmp[key]+=n
  for key, n in tmp.items():
    data[key[0]][key]=n
  return data

def total_non_secondary_structure_probabilities(starting_selection='D'):
  data = probability_distribution()
  for key, item in phi_psi_2_peaks.items():
    motif, n = item
    if motif.find('AA')>-1 or motif.find('BB')>-1: continue
    if starting_selection and motif.find(starting_selection)!=0: continue
    key = motif.split('.')[0]
    data.setdefault(key, 0)
    data[key]+=n
  total = sum(data.values())
  for motif in data:
    data[motif] /= total
  return data

def get_closest_peak_two_D_space(xyz, general=None):
  #
  # need to cater to angle wrap
  #
  smallest_d2 = [1e9, 1e9]
  closest_peak = None
  for k, key in enumerate(phi_psi_2_peaks):
    if general and phi_psi_2_peaks[key][0].find(general)!=0: continue
    smallest_d2_local = [1e9, 1e9]
    for j in range(2):
      d2 = 0
      for i in range(2):
        d2 += (xyz[j*2+i]-key[j*2+i])**2
      if d2<smallest_d2_local[j]:
        smallest_d2_local[j]=d2
    # print '2D',k,general,key,smallest_d2,closest_peak,smallest_d2_local
    if max(smallest_d2_local)<max(smallest_d2):
      smallest_d2 = smallest_d2_local
      closest_peak = key
  # print 'returning',closest_peak,smallest_d2
  return closest_peak,smallest_d2

def get_two_D_space_peaks(xyz, closest_peak):
  rc = []
  for ptr in range(2):
    d2 = 0
    for i in range(2):
      d2 += (xyz[ptr*2+i]-closest_peak[ptr*2+i])**2
    rc.append(d2)
  return None, rc

def get_closest_peak(xyz, general=None):
  #
  # uses four dimensional space
  # need to cater to angle wrap
  #
  smallest_d2 = 1e9
  closest_peak = None
  for k, key in enumerate(phi_psi_2_peaks):
    if general and phi_psi_2_peaks[key][0].find(general)!=0: continue
    d2 = 0
    for i in range(4):
      d2 += (xyz[i]-key[i])**2
      if d2 > smallest_d2: break
    if d2<smallest_d2:
      smallest_d2=d2
      closest_peak=key
  return closest_peak,smallest_d2

def get_phi_psi_2_general(phi1, psi1, phi2, psi2,
                          informative=True,
                          verbose=False):
  key = (phi1, psi1, phi2, psi2)
  general = ''
  for i in range(0, 3, 2):
    phi_psi = [round_to_int(key[i], 5), round_to_int(key[i+1], 5)]
    lookup = phi_psi_2_mask.get(tuple(phi_psi), None)
    if lookup:
      general += lookup
    else:
      if informative:
        general += '!'
      else:
        return None
  if informative: general = general.replace(' ','!')
  return general

def get_phi_psi_2_vector(phi1,
                         psi1,
                         phi2,
                         psi2,
                         ):
  general = get_phi_psi_2_general(phi1, psi1, phi2, psi2, verbose=verbose)
  print(general)
  assert 0

def get_phi_psi_2_motif(phi1,
                        psi1,
                        phi2,
                        psi2,
                        return_type=False,
                        include_five_ring=True,
                        details=False,
                        verbose=False):
  if details: assert return_type
  key = (phi1, psi1, phi2, psi2)
  general = get_phi_psi_2_general(phi1, psi1, phi2, psi2, verbose=verbose)
  assert general.find(' ')==-1, '%s "%s"' % (key, general)
  if general is None or general.find('!')>-1:
    smallest_d2=1e9
    rc = '%-5s ' % general
    if return_type:
      rc = [rc, 'OUTLIER'] #'Improbable'
    if details:
      rc.append([general, '!'])
    return rc
  else:
    closest_peak, smallest_d2 = get_closest_peak(key, general=general)
    # print key, closest_peak, phi_psi_2_peaks[closest_peak], smallest_d2
    closest_peak_pair, smallest_d2_pair = get_closest_peak_two_D_space(
      key,
      general=general)
    if closest_peak:
      closest_peak_peak, smallest_d2_peak = get_two_D_space_peaks(key,
                                                                  closest_peak)
      if max(smallest_d2_pair)<400 and max(smallest_d2_peak)<400 and verbose:
        if smallest_d2_pair!=smallest_d2_peak:
          print('  DEBUG %s != %s' % (smallest_d2_pair, smallest_d2_peak))
          if (max(smallest_d2_pair)<100) != (max(smallest_d2_peak)<100):
            print('  one is closer than the other')
      addtional_args = [smallest_d2] + smallest_d2_peak
      addtional_args += [closest_peak, closest_peak_peak]
    else:
      addtional_args = [smallest_d2] + smallest_d2_pair
      addtional_args += [closest_peak, closest_peak_pair]
  def _verbose_output(args):
    return '%-5s%2s %6.1f %6.1f %6.1f %s %s' % tuple(args)
  def _output(args):
    return '%-5s%1s' % tuple(args)
  def _return_return(args, label, addtional_args, verbose, return_type, details):
    if verbose: outl = _verbose_output(args+addtional_args)
    else: outl = _output(args)
    rc = outl
    if return_type:
      rc = [outl, label]
    if details:
      rc.append(args+addtional_args)
    return rc
  if include_five_ring and max(smallest_d2_pair)<=25:
    return _return_return([phi_psi_2_peaks[closest_peak][0], '.'],
                          'MOTIF05',
                          addtional_args,
                          verbose,
                          return_type,
                          details)
  elif max(smallest_d2_pair)<=100:
    return _return_return([phi_psi_2_peaks[closest_peak][0], ''],
                          'MOTIF',
                          addtional_args,
                          verbose,
                          return_type,
                          details)
  elif max(smallest_d2_pair)<=400:
    return _return_return([phi_psi_2_peaks[closest_peak][0], '*'],
                          'MOTIF20',
                          addtional_args,
                          verbose,
                          return_type,
                          details)
  elif min(smallest_d2_pair)>1e8:
    return _return_return([general, '?'],
                          'GENERAL',
                          addtional_args,
                          verbose,
                          return_type,
                          details)
  else:
    return _return_return([general, ''],
                          'MOTIF...',
                          addtional_args,
                          verbose,
                          return_type,
                          details)
  print(key, closest_peak, smallest_d2)
  assert 0
  return None

def guess_next_phi_psi(four, pp2):
  pp_key = pp2[:4]
  pp_key = pp_key.split('.')[0].strip()
  phi_psi = None
  if pp_key[0]!='!' and pp_key[1]=='!':
    rp = relative_probabilities(ignore_alpha_beta=True)
    current = rp.get(pp_key[0], None)
    if current is None: return None
    for key in sorted(current, key=current.__getitem__, reverse=True):
      item = current[key]
      if key.find('.')>-1: break
    for phi_psi_2, info in phi_psi_2_peaks.items():
      if info[0]==key: break
    phi_psi = phi_psi_2[2:]
  return phi_psi

def get_phi_psi_2_dihedrals_from_basins(basin):
  for phi_psi_2, info in phi_psi_2_peaks.items():
    if info[0].find(basin)==0:
      return phi_psi_2

def get_phi_psi_2_key(pp2_key,
                      highest_probability=False,
                      closest=False,
                      reverse_relationships=False,
                      ):
  def _d2(xy1, xy2):
    d2 = 0
    for i in range(2):
      d2 += (xy1[i]-xy2[i])**2
    return d2
  def d2(xy1, xy2):
    rc = 1e9
    for phi in range(-360,361,360):
      for psi in range(-360,361,360):
        rc = min(rc, _d2([xy1[0]+phi, xy1[1]+psi], xy2))
    return rc
  #
  rc = relative_probabilities(ignore_alpha_beta=False,
                              reverse_relationships=reverse_relationships,
                              )
  full_key = None
  for key, item in rc.items():
    if reverse_relationships:
      if pp2_key[1]!=key: continue
    else:
      if pp2_key[0]!=key: continue
    if closest:
      min_dist = 1e9
      min_key = None
      for full_key, prob in item.items():
        dih = get_phi_psi_2_dihedrals_from_basins(full_key)
        if reverse_relationships:
          td2 = d2(dih[:2], closest)
        else:
          td2 = d2(dih[2:], closest)
        if td2<min_dist:
          min_dist=td2
          min_key=full_key
      full_key=min_key
    elif highest_probability:
      mv = max(item.values())
      for full_key, prob in item.items():
        if prob==mv: break
  # if pp2_key.find('!')==-1 and pp2_key.find('?')==-1:
  #   if pp2_key.find(full_key.split('.')[0])==-1:
  #     print('%s != %s' % (pp2_key, full_key))
  return full_key

def get_phi_psi_2_next_value(pp2_key,
                             highest_probability=False,
                             closest=False,
                             ):
  key = get_phi_psi_2_key(pp2_key,
                          highest_probability=highest_probability,
                          closest=closest,
                          )
  for pp2, data in phi_psi_2_peaks.items():
    if data[0].find(i)>-1:
      break

def print_lookup_table(data):
  ij = 0
  rr = [i for i in range(-179,180,2)]
  outl = ''
  for i in rr:
    line=[]
    for j in rr:
      line.append(str(data[ij]))
      ij+=1
    outl += '%s\n' % (','.join(line))
  f=file('test.csv', 'wb')
  f.write(outl)
  del f

def load_phi_psi_2_rama_restraints_tables():
  t0=time.time()
  from scitbx.array_family import flex
  from mmtbx_ramachandran_restraints_ext import lookup_table
  tables = {}
  tmp = OrderedDict()
  rr = [i for i in range(-179,180,2)]
  for i in rr:
    for j in rr:
      tmp[(i,j)]=0
  for pp2, info in phi_psi_2_peaks.items():
    for i in range(2):
      a=pp2[i*2]
      b=pp2[(i*2)+1]
      data = flex.double()
      for k, v in zip(tmp.keys(), tmp.values()):
        val = 1e9
        for phi in range(-360,361,360):
          for psi in range(-360,361,360):
            val = min(val, ((k[0]+phi)-a)**2 + ((k[1]+psi)-b)**2)
        data.append(val/1000)
      # print_lookup_table(data)
      t = lookup_table(data, 180)
      key = '%s|%s' % (info[0], ['leading', 'following'][i])
      tables[key] = t
  print('time to load tables: %0.1fs' % (time.time()-t0))
  return tables

def get_rama_table(proxy,
                   phi_psi_2_tables,
                   ):
  key, strategy = proxy.residue_type.split('...')
  reverse_relationships=False
  if proxy.residue_type[0]=='!':
    reverse_relationships=True
  closest=False
  if strategy.find('closest')>-1:
    tmp,phi,psi = strategy.split('_')
    closest=(float(phi),float(psi))
  pp2_key = get_phi_psi_2_key(
    key,
    highest_probability=(strategy=='highest_probability'),
    closest=closest,
    reverse_relationships=reverse_relationships,
    )
  if pp2_key is None: return None
  if pp2_key.find('.')==-1: pp2_key += '.1'
  if pp2_key.find('|')==-1: pp2_key += '|%s' % key.split('|')[1]
  rama_table = phi_psi_2_tables[pp2_key]
  return rama_table

def get_phi_psi_key_for_rama_proxy(phi_psi_2_motifs, three, strategy='closest'):
  pp2_key_1 = phi_psi_2_motifs.get(three[1].resseq_as_int(), '')
  pp2_key_2 = phi_psi_2_motifs.get(three[2].resseq_as_int(), '')
  pp2_t1 = '  '
  pp2_t2 = '  '
  if pp2_key_1.strip():
    pp2_t1 = pp2_key_1.split()[0]
  if pp2_key_2.strip():
    pp2_t2 = pp2_key_2.split()[0]
  # MISMATCH
  # if pp2_t1[1]!=pp2_t2[0]: return None
  # TOO FAR FROM MOTIF
  # if pp2_t1.find('.')==-1 and pp2_t1.find('.')==-1: return None
  # LEADING IS QUESTIONABLE
  if pp2_key_1.find('?')>-1: return None
  # OUTLIERS
  if(pp2_key_1.strip()=='!!' and pp2_key_2.strip()=='!!'):
    return None
  elif (pp2_key_1 and pp2_key_1[0]!='!' and pp2_key_1[1]=='!'):
    # following outlier
    pp2_key = '%s|%s' % (pp2_key_1.strip(), 'following')
  elif (pp2_key_2 and pp2_key_2[0]=='!' and pp2_key_2[1]!='!'):
    # leading outlier
    pp2_key = '%s|%s' % (pp2_key_2.strip(), 'leading')
  elif not pp2_key_1.strip():
    pp2_key = '%s|%s' % (pp2_key_2.strip(), 'leading')
  else:
    pp2_key = '%s|%s' % (pp2_key_1.strip(), 'following')
  pp2_key+='...%s' % strategy
  return pp2_key

if __name__=='__main__':

  print(relative_probabilities(ignore_alpha_beta=False))
  print(relative_probabilities(ignore_alpha_beta=True))
  print(relative_probabilities(ignore_alpha_beta=False,
                               reverse_relationships=True))
  # print(total_non_secondary_structure_probabilities())

  print(phi_psi_2_peaks[ (168, -152, -135, 151) ])

  for i in range(2):
    print(('-%s' % (i))*39)
    for phi_psi_2 in [(0,0,0,0),
                      ( -65, -40, -61, -44),
                      ]:
      print(phi_psi_2, get_phi_psi_2_motif(*tuple(phi_psi_2), verbose=i))

  print('(%s,%s) -> "%s"' % (1,1,phi_psi_2_mask.get_closest((1,1))))
  assert 0

  j=0
  phi_psi_2 = (-63, -42, -63, -42)
  for i in range(4):
    for x in range(-10,11):
      j+=1
      tmp = list(phi_psi_2)
      tmp[i] += x
      rc = get_phi_psi_2_motif(*tuple(tmp))
      assert rc.find('*')==-1, '%sth test of %s was %s' % (j, tmp, rc)

  print('OK')


 *******************************************************************************


 *******************************************************************************
mmtbx/validation/rama_z.py
from __future__ import absolute_import, division, print_function

from libtbx.utils import null_out
from libtbx import easy_pickle
import libtbx.load_env
import iotbx.phil
import iotbx.pdb
from mmtbx.secondary_structure import manager as ss_manager
from mmtbx.secondary_structure import sec_str_master_phil_str
from mmtbx.conformation_dependent_library import generate_protein_threes
from libtbx.str_utils import format_value
from scitbx.array_family import flex
from libtbx import adopt_init_args
from libtbx import group_args
from scitbx.math import linear_interpolation_2d
import numpy as np
import math
import json
import os
import sys

master_phil_str = """
rama_z {

}
"""

class result(object):
  def __init__(self, whole, helix, sheet, loop):
    adopt_init_args(self, locals())

  def as_string(self, prefix=''):
    f = format_value
    p = prefix
    w, h, s, l = self.whole, self.helix, self.sheet, self.loop
    d = "%5.2f"
    i = "%d"
    strs = [
      "\n%sRama-Z (Ramachandran plot Z-score):"%p,
      "%sInterpretation: bad |Rama-Z| > 3; suspicious 2 < |Rama-Z| < 3; good |Rama-Z| < 2." % p,
      "%sScores for whole/helix/sheet/loop are scaled independently;" % p,
      "%stherefore, the values are not related in a simple manner." % p,
      "%s  whole: %s (%s), residues: %s"%(p, f(d,w.value),f(d,w.std).strip(),f(i,w.n)),
      "%s  helix: %s (%s), residues: %s"%(p, f(d,h.value),f(d,h.std).strip(),f(i,h.n)),
      "%s  sheet: %s (%s), residues: %s"%(p, f(d,s.value),f(d,s.std).strip(),f(i,s.n)),
      "%s  loop : %s (%s), residues: %s"%(p, f(d,l.value),f(d,l.std).strip(),f(i,l.n))
    ]
    return "\n".join(strs)

  def as_json(self):
    data = {}
    for name, obj in [('whole', self.whole), ('helix', self.helix),
                      ('sheet', self.sheet), ('loop', self.loop)]:
      data[name] = {'value':obj.value,
                    'std':obj.std,
                    'n_residues':obj.n}
    return json.dumps(data, indent=2)

class rama_z(object):
  def __init__(self, models, log):
    db_path = libtbx.env.find_in_repositories(
        relative_path="chem_data/rama_z/top8000_rama_z_dict.pkl",
        test=os.path.isfile)
    self.log = log
    # this takes ~0.15 seconds, so I don't see a need to cache it somehow.
    self.db = easy_pickle.load(db_path)

    # Python 3 pickle fix
    # =========================================================================
    if sys.version_info.major == 3:
      self.db = easy_pickle.fix_py2_pickle(self.db)
    # =========================================================================

    self.calibration_values = {
        'H': (-0.045355950779513175, 0.1951165524439217),
        'S': (-0.0425581278436754, 0.20068584887814633),
        'L': (-0.018457764754231075, 0.15788374669456848),
        'W': (-0.016806654295023003, 0.12044960331869274)}
    self.residue_counts = {"H": 0, "S": 0, "L":0}
    self.z_score = {"H": None, "S": None, "L":None, 'W': None}
    self.means = {"H": {}, "S": {}, "L": {}}
    self.stds = {"H": {}, "S": {}, "L": {}}

    self.phi_step = 4
    self.psi_step = 4
    self.n_phi_half = 45
    self.n_psi_half = 45

    # this is needed to disable e.g. selection functionality when
    # multiple models are present
    self.n_models = len(models)
    self.res_info = []
    for model in models:
      if model.get_hierarchy().models_size() > 1:
        hierarchy = iotbx.pdb.hierarchy.root()
        m = model.get_hierarchy().models()[0].detached_copy()
        hierarchy.append_model(m)
        asc = hierarchy.atom_selection_cache()
      else:
        hierarchy = model.get_hierarchy()
        asc = model.get_atom_selection_cache()
      sec_str_master_phil = iotbx.phil.parse(sec_str_master_phil_str)
      ss_params = sec_str_master_phil.fetch().extract()
      ss_params.secondary_structure.protein.search_method = "from_ca"
      ss_params.secondary_structure.from_ca_conservative = True

      ssm = ss_manager(hierarchy,
          atom_selection_cache=asc,
          geometry_restraints_manager=None,
          sec_str_from_pdb_file=None,
          # params=None,
          params = ss_params.secondary_structure,
          was_initialized=False,
          mon_lib_srv=None,
          verbose=-1,
          log=null_out(),
          # log=sys.stdout,
          )

      filtered_ann = ssm.actual_sec_str.deep_copy()
      filtered_ann.remove_short_annotations(
          helix_min_len=4, sheet_min_len=4, keep_one_stranded_sheets=True)
      self.helix_sel = asc.selection(filtered_ann.overall_helices_selection())
      self.sheet_sel = asc.selection(filtered_ann.overall_sheets_selection())

      used_atoms = set()
      for three in generate_protein_threes(hierarchy=hierarchy, geometry=None):
        main_residue = three[1]
        phi_psi_atoms = three.get_phi_psi_atoms()
        if phi_psi_atoms is None:
          continue
        phi_atoms, psi_atoms = phi_psi_atoms
        key = [x.i_seq for x in phi_atoms]+[psi_atoms[-1].i_seq]
        key = "%s" % key
        if key not in used_atoms:
          phi, psi = three.get_phi_psi_angles()
          if None in (phi, psi):
            continue
          rkey = three.get_ramalyze_key()
          resname = main_residue.resname
          ss_type = self._figure_out_ss(three)
          self.res_info.append( ["", rkey, resname, ss_type, phi, psi] )
          self.residue_counts[ss_type] += 1
          used_atoms.add(key)
    self.residue_counts["W"] = self.residue_counts["H"] + self.residue_counts["S"] + self.residue_counts["L"]

  def get_residue_counts(self):
    return self.residue_counts

  def get_result(self):
    r  = self.z_score
    if(r["W"] is None): self.get_z_scores() # XXX Odd. This should not be necessary!
    rc = self.get_residue_counts()
    def nov(x,i):
      if(x is None): return None
      else:          return x[i]
    return result(
      whole = group_args(value=nov(r["W"],0), std=nov(r["W"],1), n=rc["W"]),
      helix = group_args(value=nov(r["H"],0), std=nov(r["H"],1), n=rc["H"]),
      sheet = group_args(value=nov(r["S"],0), std=nov(r["S"],1), n=rc["S"]),
      loop  = group_args(value=nov(r["L"],0), std=nov(r["L"],1), n=rc["L"]))

  def get_z_scores(self):
    for k in ['H', 'S', 'L', 'W']:
      if k != 'W':
        element_points = [p for p in self.res_info if p[3] == k]
      else:
        element_points = self.res_info
      c = None
      try:
        c = self._get_z_score_points(element_points)
      except ZeroDivisionError:
        c = None
      if c is not None:
        zs = (c - self.calibration_values[k][0]) / self.calibration_values[k][1]
        zs_std = None
        if len(element_points) > 1:
          zs_std = self._get_z_score_accuracy(element_points, k)
        self.z_score[k] = (zs, zs_std)
    return self.z_score

  def get_detailed_values(self):
    return self.res_info

  def _get_z_score_accuracy(self, points, part):
    scores = []
    values = [x[-1] for x in points]
    sum_values = np.sum(values)
    for v in values:
      s = (sum_values - v)/(len(values)-1)
      scores.append( ( s-self.calibration_values[part][0]) / self.calibration_values[part][1] )
    return np.std(scores) * ((len(points)-1) ** 0.5)

  def get_ss_selections(self):
    if self.n_models > 1:
      raise NotImplementedError
    self.loop_sel = flex.bool([True]*self.helix_sel.size())
    self.loop_sel &= ~self.helix_sel
    self.loop_sel &= ~self.sheet_sel
    return self.helix_sel, self.sheet_sel, self.loop_sel

  def _figure_out_ss(self, three):
    iseq = three.get_phi_psi_atoms()[0][-1].i_seq
    if self.helix_sel[iseq]: return "H"
    elif self.sheet_sel[iseq]: return "S"
    else: return "L"

  def _get_z_score_points(self, points):
    score = 0
    for entry in points:
      if len(entry) == 6:
        sc = self._get_z_score_point(entry)
        entry.append(sc)
      score += entry[-1]
    return score/len(points)

  def _get_z_score_point(self, entry):
    fname, rama_type, resname, ss_type, phi, psi = entry
    phi = round(phi, 10)
    psi = round(psi, 10)
    resname = self._get_resname(rama_type, resname)
    if resname == 'cisPRO':
      ss_type = 'L'
    table = self.db[ss_type][resname]
    vmin = -178
    step = 4
    if phi < -178:
      i = -1
      x1 = -182
      x2 = -178
    elif phi > 178:
      i = -1
      x1 = 178
      x2 = 182
    else:
      i = int(abs(-178 - phi) // 4)
      nsteps = abs(vmin - phi) // step
      x1 = vmin + nsteps * step
      x2 = x1 + 4

    if psi < -178:
      j = -1
      y1 = -182
      y2 = -178
    elif psi > 178:
      j = -1
      y1 = 178
      y2 = 182
    else:
      j = int(abs(-178 - psi) // 4)
      nsteps = abs(vmin - psi) // step
      y1 = vmin + nsteps * step
      y2 = y1 + 4

    xx = phi
    yy = psi
    v1 = table[i][j]
    v2 = table[i+1][j+1]
    v3 = table[i][j+1]
    v4 = table[i+1][j]

    int_sc = linear_interpolation_2d(x1,y1,x2,y2,v1,v2,v3,v4,xx,yy)
    if self.means[ss_type].get(resname, None) is None:
      self.means[ss_type][resname] = self._get_mean(ss_type, resname)
    if self.stds[ss_type].get(resname, None) is None:
      self.stds[ss_type][resname] = self._get_std(ss_type, resname, self.means[ss_type][resname])
    return (int_sc - self.means[ss_type][resname]) / self.stds[ss_type][resname]

  def _get_mean(self, ss_type, resname):
    # Origianl paper calc:
    reg_sum = 0
    sq_sum = 0
    for i in self.db[ss_type][resname]:
      for j in i:
        reg_sum += j
        sq_sum += j*j
    if reg_sum > 0:
      mean = sq_sum / reg_sum
    else:
      mean = 0
    return mean

  def _get_std(self, ss_type, resname, mean):
    # Origianl paper calc:
    ch = 0
    zn = 0
    for i in self.db[ss_type][resname]:
      for j in i:
        ch += j * (j-mean)**2
        zn += j
    zn -= 1
    if zn == 0:
      return 0
    std = math.sqrt(ch/zn)
    return std

  def _get_resname(self, rama_type, resname):
    rn = resname
    if resname == "MSE":
      rn = "MET"
    if rama_type == 2:
      rn = 'cisPRO'
    if rama_type == 3:
      rn = 'transPRO'
    if rama_type == 4:
      rn = 'prePRO'
    return rn


 *******************************************************************************


 *******************************************************************************
mmtbx/validation/ramachandran/__init__.py


 *******************************************************************************


 *******************************************************************************
mmtbx/validation/ramachandran/convert_from_text.py
from __future__ import absolute_import, division, print_function
import libtbx.load_env
import os

import six
from six.moves import range


output_fname = "rama8000_tables.h"
path_to_files = libtbx.env.find_in_repositories(
    os.path.join("chem_data", "rotarama_data"))
file_names = {
  'general':  "rama8000-general-noGPIVpreP.data",
  'glycine':  "rama8000-gly-sym.data",
  'cis_pro':  "rama8000-cispro.data",
  'trans_pro':"rama8000-transpro.data",
  'pre_pro':  "rama8000-prepro-noGP.data",
  'ile_val':  "rama8000-ileval-nopreP.data",
}

template = """
/*
This file contains tables for Ramachandran evaluation.
This file is generated by the following procedure, don't edit it manually
and keep consistent with the template there:
mmtbx/validation/ramachandran/convert_from_test.py
*/
#include <vector>
#include <scitbx/array_family/shared.h>
#include <scitbx/array_family/versa.h>
#include <scitbx/array_family/accessors/c_grid.h>


namespace mmtbx {{ namespace validation {{ namespace ramachandran {{

#define RAMA_GENERAL  0
#define RAMA_GLYCINE  1
#define RAMA_CISPRO   2
#define RAMA_TRANSPRO 3
#define RAMA_PREPRO   4
#define RAMA_ILE_VAL  5

#define RAMALYZE_OUTLIER  0
#define RAMALYZE_ALLOWED  1
#define RAMALYZE_FAVORED  2
#define RAMALYZE_ANY      3
#define RAMALYZE_NOT_FAVORED 4

  const std::string res_types[] = {{"general", "glycine", "cis-proline",
    "trans-proline", "pre-proline", "isoleucine or valine"}};

  const double linear_table_general[] = {{{general}}};
  const double linear_table_glycine[] = {{{glycine}}};
  const double linear_table_cis_pro[] = {{{cis_pro}}};
  const double linear_table_trans_pro[] = {{{trans_pro}}};
  const double linear_table_pre_pro[] = {{{pre_pro}}};
  const double linear_table_ile_val[] = {{{ile_val}}};

  scitbx::af::const_ref<double, scitbx::af::c_grid<2> > table_general(linear_table_general,    180,180);
  scitbx::af::const_ref<double, scitbx::af::c_grid<2> > table_glycine(linear_table_glycine,    180,180);
  scitbx::af::const_ref<double, scitbx::af::c_grid<2> > table_cis_pro(linear_table_cis_pro,    180,180);
  scitbx::af::const_ref<double, scitbx::af::c_grid<2> > table_trans_pro(linear_table_trans_pro,180,180);
  scitbx::af::const_ref<double, scitbx::af::c_grid<2> > table_pre_pro(linear_table_pre_pro,    180,180);
  scitbx::af::const_ref<double, scitbx::af::c_grid<2> > table_ile_val(linear_table_ile_val,    180,180);


}}}}}} // namespace mmtbx::validation::ramachandran
"""


def array_2d_to_string(arr):
  result = ""
  cur_str_len = 0
  for row in arr:
    for num in row:
      str_num = "{:.6g},".format(num)
      result += str_num
      cur_str_len += len(str_num)
      if cur_str_len > 100:
        result += "\n"
        cur_str_len = 0
  return result

def read_file_and_fill_arr(file_descr, arr):
  for line in file_descr.readlines():
    if line.startswith('#'): continue
    phi_str, psi_str, value_str = line.split()
    phi = int(float(phi_str))
    psi = int(float(psi_str))
    value = float(value_str)
    arr[(phi+179)//2][(psi+179)//2] = value

def run():
  dict_with_all_values = {}
  for key in file_names.keys():
    dict_with_all_values[key] = [[0 for x in range(180)] for y in range(180)]

  # reading. Not much error-handling, because if we have a error, we should fix
  # it here and not produce corrupted .h file

  for key, fname in six.iteritems(file_names):
    print("converting file", os.path.join(path_to_files, fname))
    inp_f = open(os.path.join(path_to_files, fname), 'r')
    read_file_and_fill_arr(inp_f, dict_with_all_values[key])
    inp_f.close()

  out_f = open(output_fname, 'w')
  out_f.write(template.format(
      general=array_2d_to_string(dict_with_all_values['general']),
      glycine=array_2d_to_string(dict_with_all_values['glycine']),
      cis_pro=array_2d_to_string(dict_with_all_values['cis_pro']),
      trans_pro=array_2d_to_string(dict_with_all_values['trans_pro']),
      pre_pro=array_2d_to_string(dict_with_all_values['pre_pro']),
      ile_val=array_2d_to_string(dict_with_all_values['ile_val']))
  )
  out_f.close()

if __name__ == '__main__':
  run()


 *******************************************************************************


 *******************************************************************************
mmtbx/validation/ramalyze.py

from __future__ import absolute_import, division, print_function
from mmtbx.validation import residue, validation, atom
from mmtbx.validation import graphics
from iotbx import data_plots
from libtbx import slots_getstate_setstate
from mmtbx.conformation_dependent_library import generate_protein_threes
from mmtbx.conformation_dependent_library.cdl_utils import get_c_ca_n
import sys
from scitbx.array_family import flex
from mmtbx.validation import utils
from mmtbx.validation.rotalyze import get_center
import mmtbx.rotamer
from mmtbx.rotamer import ramachandran_eval
from mmtbx.validation.fav_lists import fav_tables
from six.moves import range
import json

# XXX Use these constants internally, never strings!
RAMA_GENERAL = 0
RAMA_GLYCINE = 1
RAMA_CISPRO = 2
RAMA_TRANSPRO = 3
RAMA_PREPRO = 4
RAMA_ILE_VAL = 5

RAMALYZE_OUTLIER = 0
RAMALYZE_ALLOWED = 1
RAMALYZE_FAVORED = 2
RAMALYZE_ANY = 3
RAMALYZE_NOT_FAVORED = 4

# Values are rama_keys, from 0 to 5
res_types_dict = {"general": 0, "glycine":1, "cis-proline":2, "trans-proline":3,
             "pre-proline":4, "isoleucine or valine":5}

res_types = ["general", "glycine", "cis-proline", "trans-proline",
             "pre-proline", "isoleucine or valine"]
res_type_labels = ["General", "Gly", "cis-Pro", "trans-Pro", "pre-Pro",
                   "Ile/Val"]
res_type_plot_labels = ["all non-Pro/Gly residues", "Glycine", "cis-Proline",
  "trans-Proline", "pre-Proline residues", "Ile or Val"]
rama_types = ["OUTLIER", "Allowed", "Favored", "Any", "Allowed/Outlier"]
rama_type_labels = ["Outlier", "Allowed", "Favored", "Any", "Allowed/Outlier"]

class c_alpha(slots_getstate_setstate):
  """Container class used in the generation of kinemages."""
  __slots__ = ['id_str', 'xyz']
  def __init__(self, id_str, xyz):
    self.id_str = id_str
    self.xyz = xyz

class ramachandran(residue):
  """
  Result class for protein backbone Ramachandran analysis (phenix.ramalyze).
  """
  __rama_attr__ = [
    "res_type",
    "rama_type",
    "score",
    "phi",
    "psi",
    #"c_alphas",
    "markup",
    "model_id",
  ]
  __slots__ = residue.__slots__ + __rama_attr__

  @staticmethod
  def header():
    return "%-20s %-12s %10s %6s %-20s" % ("Residue", "Type", "Region", "Score",
      "Phi/Psi")

  def residue_type(self):
    return res_type_labels[self.res_type]

  def ramalyze_type(self):
    return rama_types[self.rama_type]

  def as_string(self):
    return "%-20s %-12s %10s %6.2f %10s" % (self.id_str(), self.residue_type(),
      self.ramalyze_type(), self.score,
      ",".join([ "%.1f" % x for x in [self.phi, self.psi] ]))

  def as_csv(self):
    rc = [self.chain_id.strip(), self.resseq.strip(),
      # self.icode, self.altloc,
      self.resname.strip()]
    rc += [self.residue_type(), self.ramalyze_type(), '%0.1f' % (self.score)]
    rc += [ "%.1f" % x for x in [self.phi, self.psi]]
    return ','.join(rc)

  # Backwards compatibility
  def id_str_old(self):
    return "%s%4s%1s %1s%s" % (self.chain_id, self.resseq, self.icode,
      self.altloc, self.resname)

  def format_old(self):
    return "%s:%.2f:%.2f:%.2f:%s:%s" % (self.id_str(), self.score,
      self.phi, self.psi, self.ramalyze_type(),
      res_types[self.res_type].capitalize())

  def as_kinemage(self):
    assert self.is_outlier()
#    ram_out = "{%s CA}P %s\n" % (self.c_alphas[0].id_str, "%.3f %.3f %.3f" %
#      self.c_alphas[0].xyz)
#    ram_out += "{%s CA} %s\n" % (self.c_alphas[1].id_str, "%.3f %.3f %.3f" %
#      self.c_alphas[1].xyz)
#    ram_out += "{%s CA} %s\n" % (self.c_alphas[2].id_str, "%.3f %.3f %.3f" %
#      self.c_alphas[2].xyz)
#    return ram_out
    return self.markup

  def as_JSON(self):
    serializable_slots = [s for s in self.__slots__ if s != 'markup' and hasattr(self, s)]
    slots_as_dict = ({s: getattr(self, s) for s in serializable_slots})
    slots_as_dict["rama_type"] = rama_types[slots_as_dict["rama_type"]]
    res_type_index = slots_as_dict['res_type']
    slots_as_dict['res_type'] = res_types[res_type_index]
    slots_as_dict['res_type_label'] = res_type_labels[res_type_index]
    return json.dumps(slots_as_dict, indent=2)

  def as_hierarchical_JSON(self):
    hierarchical_dict = {}
    hierarchy_nest_list = ['model_id', 'chain_id', 'resid', 'altloc']
    return json.dumps(self.nest_dict(hierarchy_nest_list, hierarchical_dict), indent=2)

  # GUI output
  def as_table_row_phenix(self):
    return [ self.chain_id, "%1s%s %s" % (self.altloc,self.resname,self.resid),
             self.residue_type(), self.score, self.phi, self.psi ]

class ramachandran_ensemble(residue):
  """Container for results for an ensemble of residues"""
  __slots__ = ramachandran.__slots__
  def __init__(self, all_results):
    self._copy_constructor(all_results[0])
    self.res_type = all_results[0].res_type
    self.rama_type = [ r.rama_type for r in all_results ]
    self.phi = flex.double([ r.phi for r in all_results ])
    self.psi = flex.double([ r.psi for r in all_results ])
    self.score = flex.double([ r.score for r in all_results ])

  def phi_min_max_mean(self):
    return self.phi.min_max_mean()

  def psi_min_max_mean(self):
    return self.psi.min_max_mean()

  def score_statistics(self):
    return self.score.min_max_mean()

  def phi_range(self):
    pass

class ramalyze(validation):
  """
  Frontend for calculating Ramachandran statistics for a model.  Can directly
  generate the corresponding plots.
  """
  __slots__ = validation.__slots__ + ["out_percent", "fav_percent",
    "n_allowed", "n_favored", "n_allowed_by_model", "n_favored_by_model", "n_type", "_outlier_i_seqs" ]
  program_description = "Analyze protein backbone ramachandran"
  output_header = "residue:score%:phi:psi:evaluation:type"
  gui_list_headers = ["Chain","Residue","Residue type","Score","Phi","Psi"]
  gui_formats = ["%s", "%s", "%s", "%.2f", "%.1f", "%.1f"]
  wx_column_widths = [75, 125, 125, 100, 125, 125]

  def get_result_class(self) : return ramachandran

  def __init__(self,
      pdb_hierarchy,
      outliers_only=False,
      show_errors=False,
      out=sys.stdout,
      quiet=False):
    # Optimization hint: make it possible to pass
    # ramachandran_eval.RamachandranEval() from outside.
    # Better - convert this to using mmtbx.model.manager where
    # RamachandranEval is already available.
    validation.__init__(self)
    self.n_allowed = 0
    self.n_favored = 0
    self.n_allowed_by_model = {}
    self.n_favored_by_model = {}
    self.n_type = [ 0 ] * 6
    self._outlier_i_seqs = flex.size_t()
    pdb_atoms = pdb_hierarchy.atoms()
    all_i_seqs = pdb_atoms.extract_i_seq()
    if (all_i_seqs.all_eq(0)):
      pdb_atoms.reset_i_seq()
    use_segids = utils.use_segids_in_place_of_chainids(
      hierarchy=pdb_hierarchy)
    analysis = ""
    output_list = []
    count_keys = []
    uniqueness_keys = []
    r = ramachandran_eval.RamachandranEval()
    ##if use_segids:
    ##      chain_id = utils.get_segid_as_chainid(chain=chain)
    ##    else:
    ##      chain_id = chain.id
    for three in generate_protein_threes(hierarchy=pdb_hierarchy, geometry=None):
      main_residue = three[1]
      phi_psi_atoms = three.get_phi_psi_atoms()
      if phi_psi_atoms is None:
        continue
      phi_atoms, psi_atoms = phi_psi_atoms
      phi = get_dihedral(phi_atoms)
      psi = get_dihedral(psi_atoms)
      coords = get_center(main_residue) #should find the CA of the center residue

      if (phi is not None and psi is not None):
        model_id = main_residue.parent().parent().parent().id
        if model_id not in self.n_total_by_model:
          self.n_total_by_model[model_id] = 0
          self.n_outliers_by_model[model_id] = 0
          self.n_allowed_by_model[model_id] = 0
          self.n_favored_by_model[model_id] = 0
        res_type = RAMA_GENERAL
        #self.n_total += 1
        if (main_residue.resname[0:3] == "GLY"):
          res_type = RAMA_GLYCINE
        elif (main_residue.resname[0:3] == "PRO"):
          is_cis = is_cislike_peptide(three)
          if is_cis:
            res_type = RAMA_CISPRO
          else:
            res_type = RAMA_TRANSPRO
        elif (three[2].resname == "PRO"):
          res_type = RAMA_PREPRO
        elif (main_residue.resname[0:3] == "ILE" or \
              main_residue.resname[0:3] == "VAL"):
          res_type = RAMA_ILE_VAL
        #self.n_type[res_type] += 1
        value = r.evaluate(res_types[res_type], [phi, psi])
        ramaType = self.evaluateScore(res_type, value)
        is_outlier = ramaType == RAMALYZE_OUTLIER

        c_alphas = None
        # XXX only save kinemage data for outliers
        if is_outlier :
          c_alphas = get_cas_from_three(three)
          assert (len(c_alphas) == 3)
          markup = self.as_markup_for_kinemage(c_alphas)
        else:
          markup = None
        result = ramachandran(
          model_id=main_residue.parent().parent().parent().id,
          chain_id=main_residue.parent().parent().id,
          resseq=main_residue.resseq,
          icode=main_residue.icode,
          resname=main_residue.resname,
          #altloc=main_residue.parent().altloc,
          altloc=get_altloc_from_three(three),
          segid=None, # XXX ???
          phi=phi,
          psi=psi,
          rama_type=ramaType,
          res_type=res_type,
          score=value*100,
          outlier=is_outlier,
          xyz=coords,
          markup=markup)
        #if result.chain_id+result.resseq+result.icode not in count_keys:
        result_key = result.model_id+result.chain_id+result.resseq+result.icode
        if result.altloc in ['','A'] and result_key not in count_keys:
          self.n_total += 1
          self.n_type[res_type] += 1
          self.n_total_by_model[model_id] += 1
          self.add_to_validation_counts(ramaType, model_id)
          count_keys.append(result_key)
        if (not outliers_only or is_outlier):
          if (result.altloc != '' or
            result_key not in uniqueness_keys):
            #the threes/conformers method results in some redundant result
            #  calculations in structures with alternates. Using the
            #  uniqueness_keys list prevents redundant results being added to
            #  the final list
            self.results.append(result)
            uniqueness_keys.append(result_key)
        if is_outlier :
          i_seqs = main_residue.atoms().extract_i_seq()
          assert (not i_seqs.all_eq(0))
          self._outlier_i_seqs.extend(i_seqs)
    #self.results.sort(key=lambda r: (r.model_id,r. chain_id, r.resseq_as_int(), r.icode, r.altloc))
    self.results.sort(key=lambda r: (r.model_id,r. chain_id, r.resseq_as_int(), r.icode, r.altloc))
    out_count, out_percent = self.get_outliers_count_and_fraction()
    fav_count, fav_percent = self.get_favored_count_and_fraction()
    self.out_percent = out_percent * 100.0
    self.fav_percent = fav_percent * 100.0

  def __add__(self, other):
    self.results += other.results
    return self

  def get_plots(self, show_labels=True, point_style='bo',
      markersize=10,markeredgecolor="black", dpi=100,markerfacecolor="white",
      show_filling=True, show_contours=True):
    """
    Create a dictionary of six PNG images representing the plots for each residue type.
    :param out: log filehandle
    """
    result = {}
    for pos in range(6):
      stats = utils.get_rotarama_data(
        pos_type=res_types[pos],
        convert_to_numpy_array=True)
      points, coords = self.get_plot_data(position_type=pos)
      result[pos] = draw_ramachandran_plot(
        points=points,
        rotarama_data=stats,
        position_type=pos,
        title=format_ramachandran_plot_title(pos, '*'),
        show_labels=show_labels,
        markeredgecolor=markeredgecolor,
        markerfacecolor=markerfacecolor,
        show_filling=show_filling,
        show_contours=show_contours,
        point_style=point_style,
        markersize=markersize)
    return result

  def write_plots(self, plot_file_base, out, show_labels=True, point_style='bo',
    markersize=10,markeredgecolor="black", show_filling=True, show_contours=True,
    dpi=100,markerfacecolor="white"):
    """
    Write a set of six PNG images representing the plots for each residue type.

    :param plot_file_base: file name prefix
    :param out: log filehandle
    """
    print("", file=out)
    print("Creating images of plots...", file=out)
    plots = self.get_plots(
        show_labels=show_labels,
        point_style=point_style,
        markersize=markersize,
        markeredgecolor=markeredgecolor,
        show_filling=show_filling,
        show_contours=show_contours,
        dpi=dpi,
        markerfacecolor=markerfacecolor)
    for pos in range(6):
      file_label = res_type_labels[pos].replace("/", "_")
      plot_file_name = plot_file_base + "_rama_%s.png" % file_label
      plots[pos].save_image(plot_file_name, dpi=dpi)
      print("  wrote %s" % plot_file_name, file=out)

  def display_wx_plots(self, parent=None,
      title="MolProbity - Ramachandran plots"):
    import wxtbx.plots.molprobity     # causes GUI error when moved to top?
    frame = wxtbx.plots.molprobity.ramalyze_frame(
      parent=parent, title=title, validation=self)
    frame.Show()
    return frame

  def show_summary(self, out=sys.stdout, prefix=""):
    print(prefix + 'SUMMARY: %i Favored, %i Allowed, %i Outlier out of %i residues (altloc A where applicable)' % (self.n_favored, self.n_allowed, self.n_outliers, self.n_total), file=out)
    print(prefix + 'SUMMARY: %.2f%% outliers (Goal: %s)' % \
      (self.out_percent, self.get_outliers_goal()), file=out)
    print(prefix + 'SUMMARY: %.2f%% favored (Goal: %s)' % \
      (self.fav_percent, self.get_favored_goal()), file=out)

  def get_plot_data(self, position_type=RAMA_GENERAL, residue_name="*",
      point_type=RAMALYZE_ANY):
    assert isinstance(position_type, int) and (0 <= position_type <= 5), \
      position_type
    points, coords = [], []
    for i, residue in enumerate(self.results):
      if ((residue.res_type == position_type) and
          ((residue_name == '*') or (residue_name == residue.resname))):
        if ((point_type == RAMALYZE_ANY) or
            (point_type == residue.rama_type) or
            ((residue.rama_type in [RAMALYZE_ALLOWED,RAMALYZE_OUTLIER]) and
             (point_type == RAMALYZE_NOT_FAVORED))):
          points.append((residue.phi, residue.psi, residue.simple_id(),
            residue.is_outlier()))
          coords.append(residue.xyz)
    return (points, coords)

  @staticmethod
  def evalScore(resType, value):
    if (value >= 0.02):
      return RAMALYZE_FAVORED
    if (resType == RAMA_GENERAL):
      if (value >= 0.0005):
        return RAMALYZE_ALLOWED
      else:
        return RAMALYZE_OUTLIER
    elif (resType == RAMA_CISPRO):
      if (value >=0.0020):
        return RAMALYZE_ALLOWED
      else:
        return RAMALYZE_OUTLIER
    else:
      if (value >= 0.0010):
        return RAMALYZE_ALLOWED
      else:
        return RAMALYZE_OUTLIER

  def evaluateScore(self, resType, value):
    ev = ramalyze.evalScore(resType, value)
    assert ev in [RAMALYZE_FAVORED, RAMALYZE_ALLOWED, RAMALYZE_OUTLIER]
    #if ev == RAMALYZE_FAVORED:
    #  self.n_favored += 1
    #elif ev == RAMALYZE_ALLOWED:
    #  self.n_allowed += 1
    #elif ev == RAMALYZE_OUTLIER:
    #  self.n_outliers += 1
    return ev

  def add_to_validation_counts(self, ev, model_id=""):
    if ev == RAMALYZE_FAVORED:
      self.n_favored += 1
      if model_id in self.n_favored_by_model:
        self.n_favored_by_model[model_id] += 1
      else:
        raise Sorry("Model ID not found in ramalyze favored count dictionary, make sure you are calling this function with the correct model ID")
    elif ev == RAMALYZE_ALLOWED:
      self.n_allowed += 1
      if model_id in self.n_allowed_by_model:
        self.n_allowed_by_model[model_id] += 1
      else:
        raise Sorry("Model ID not found in ramalyze allowed count dictionary, make sure you are calling this function with the correct model ID")
    elif ev == RAMALYZE_OUTLIER:
      self.n_outliers += 1
      if model_id in self.n_outliers_by_model:
        self.n_outliers_by_model[model_id] += 1
      else:
        raise Sorry("Model ID not found in ramalyze outliers count dictionary, make sure you are calling this function with the correct model ID")

  def get_outliers_goal(self):
    return "< 0.2%"

  def _get_count_and_fraction(self, res_type):
    if (self.n_total != 0):
      count = self.n_type[res_type]
      fraction = float(count) / self.n_total
      return count, fraction
    return 0, 0.

  @property
  def percent_favored(self):
    n_favored, frac_favored = self.get_favored_count_and_fraction()
    return frac_favored * 100.

  @property
  def percent_allowed(self):
    n_allowed, frac_allowed = self.get_allowed_count_and_fraction()
    return frac_allowed * 100.

  def get_allowed_count_and_fraction(self):
    if (self.n_total != 0):
      fraction = self.n_allowed / self.n_total
      return self.n_allowed, fraction
    return 0, 0.

  def get_allowed_goal(self):
    return "> 99.8%"

  def get_favored_count_and_fraction(self):
    if (self.n_total != 0):
      fraction = self.n_favored / self.n_total
      return self.n_favored, fraction
    return 0, 0.

  def get_favored_goal(self):
    return "> 98%"

  def get_general_count_and_fraction(self):
    return self._get_count_and_fraction(RAMA_GENERAL)

  def get_gly_count_and_fraction(self):
    return self._get_count_and_fraction(RAMA_GLYCINE)

  def get_cis_pro_count_and_fraction(self):
    return self._get_count_and_fraction(RAMA_CISPRO)

  def get_trans_pro_count_and_fraction(self):
    return self._get_count_and_fraction(RAMA_TRANSPRO)

  def get_prepro_count_and_fraction(self):
    return self._get_count_and_fraction(RAMA_PREPRO)

  def get_ileval_count_and_fraction(self):
    return self._get_count_and_fraction(RAMA_ILE_VAL)

  def get_phi_psi_residues_count(self):
    return self.n_total

  def as_markup_for_kinemage(self,c_alphas):
    #atom.id_str() returns 'pdb=" CA  LYS    16 "'
    #The [9:-1] slice gives ' LYS    16 '
    if None in c_alphas: return ''
    ram_out = "{%s CA}P %s\n" % (c_alphas[0].id_str()[9:-1], "%.3f %.3f %.3f" %
      c_alphas[0].xyz)
    ram_out += "{%s CA} %s\n" % (c_alphas[1].id_str()[9:-1], "%.3f %.3f %.3f" %
      c_alphas[1].xyz)
    ram_out += "{%s CA} %s\n" % (c_alphas[2].id_str()[9:-1], "%.3f %.3f %.3f" %
      c_alphas[2].xyz)
    return ram_out

  def as_kinemage(self):
    ram_out = "@subgroup {Rama outliers} master= {Rama outliers}\n"
    ram_out += "@vectorlist {bad Rama Ca} width= 4 color= green\n"
    for rama in self.results :
      if rama.is_outlier():
        ram_out += rama.as_kinemage()
    return ram_out

  def as_coot_data(self):
    data = []
    for result in self.results :
      if result.is_outlier():
        data.append((result.chain_id, result.resid, result.resname,
          result.score, result.xyz))
    return data

  def as_JSON(self, addon_json={}):
    if not addon_json:
      addon_json = {}
    addon_json["validation_type"] = "ramalyze"
    data = addon_json
    flat_results = []
    hierarchical_results = {}
    summary_results = {}
    for result in self.results:
      flat_results.append(json.loads(result.as_JSON()))
      hier_result = json.loads(result.as_hierarchical_JSON())
      hierarchical_results = self.merge_dict(hierarchical_results, hier_result)

    data['flat_results'] = flat_results
    data['hierarchical_results'] = hierarchical_results
    data['summary_results'] = summary_results
    for model_id in self.n_total_by_model.keys():
      summary_results[model_id] = {"num_favored" : self.n_favored_by_model[model_id],
        "num_allowed" : self.n_allowed_by_model[model_id],
        "num_outliers" : self.n_outliers_by_model[model_id],
        "num_residues" : self.n_total_by_model[model_id],
        "outlier_percentage" : self.n_outliers_by_model[model_id]/self.n_total_by_model[model_id]*100,
        "outlier_goal" : self.get_outliers_goal(),
        "favored_percentage" : self.n_favored_by_model[model_id]/self.n_total_by_model[model_id]*100,
        "favored_goal" : self.get_favored_goal()
      }
    data['summary_results'] = summary_results
    #{summary: {"summary_text": "74 Favored, 0 Allowed, 0 Outlier out of 74 residues (altloc A where applicable)"}
    #           "info": {"res_count": 74,
    #                    "favored": 74,}
                #}
    #filebase = os.path.basename(self.data_manager.get_model_names()[0])
    return json.dumps(data, indent=2)

def get_matching_atom_group(residue_group, altloc):
  match = None
  if (residue_group != None):
    for ag in residue_group.atom_groups():
      if (ag.altloc == "" and match == None): match = ag
      if (ag.altloc == altloc): match = ag
  return match

def get_dihedral(four_atom_list):
  from cctbx import geometry_restraints
  if None in four_atom_list:
    return None
  return geometry_restraints.dihedral(
    sites=[atom.xyz for atom in four_atom_list],
    angle_ideal=-40,
    weight=1).angle_model

def get_phi(prev_atoms, atoms):
  import mmtbx.rotamer
  prevC, resN, resCA, resC = None, None, None, None;
  if (prev_atoms is not None):
    for atom in prev_atoms:
      if (atom.name == " C  "): prevC = atom
  if (atoms is not None):
    for atom in atoms:
      if (atom.name == " N  "): resN = atom
      if (atom.name == " CA "): resCA = atom
      if (atom.name == " C  "): resC = atom
  if (prevC is not None and resN is not None and resCA is not None and resC is not None):
    return mmtbx.rotamer.phi_from_atoms(prevC, resN, resCA, resC)

def get_psi(atoms, next_atoms):
  import mmtbx.rotamer
  resN, resCA, resC, nextN = None, None, None, None
  if (next_atoms is not None):
    for atom in next_atoms:
      if (atom.name == " N  "): nextN = atom
  if (atoms is not None):
    for atom in atoms:
      if (atom.name == " N  "): resN = atom
      if (atom.name == " CA "): resCA = atom
      if (atom.name == " C  "): resC = atom
  if (nextN is not None and resN is not None and resCA is not None and resC is not None):
    return mmtbx.rotamer.psi_from_atoms(resN, resCA, resC, nextN)

def get_omega_atoms(three):
  ccn1, outl1 = get_c_ca_n(three[0])
  ccn2, outl2 = get_c_ca_n(three[1])
  if ccn1: ca1, c = ccn1[1], ccn1[0]
  else: ca1, c = None, None
  if ccn2: n, ca2 = ccn2[2], ccn2[1]
  else: n, ca2 = None, None
  #ca1, c, n, ca2 = ccn1[1], ccn1[0], ccn2[2], ccn2[1]
  omega_atoms = [ca1, c, n, ca2]
  return omega_atoms

def is_cis_peptide(three): #Depricated in favor of is_cislike_peptide below
  omega_atoms = get_omega_atoms(three)
  omega = get_dihedral(omega_atoms)
  if omega is None:
    return False
  if(omega > -30 and omega < 30):
    return True
  else:
    return False

def is_cislike_peptide(three):
  omega_atoms = get_omega_atoms(three)
  omega = get_dihedral(omega_atoms)
  if omega is None:
    return False
  if(omega > -90 and omega < 90):
    return True
    #Splitting omega at 90 accounts for twisted peptides and placed them in the cis/trans
    #  category closest to their modeled angle
    #This split is currently only relevant for twisted Proline, since cis nonPro is extremely rare
    #  and we do not define a separate Rama category for it
    #Users are advised to inspect every twisted Proline manually, since twisted peptides are higly
    #  unusual and should not be assumed to be close to correct. But they have to go somewhere on
    #  the Ramachandran plot
  else:
    return False

def get_cas_from_three(three):
  cas = []
  for residue in three:
    for atom in residue.atoms():
      if atom.name == " CA ":
        cas.append(atom)
        break
    else:
      cas.append(None)
  return cas
  ##  c_ca_n = get_c_ca_n(residue)
  ##  if c_ca_n[0] is None:
  ##    cas.append(None)
  ##  else:
  ##    cas.append(c_ca_n[0][1])
  ##return cas

def get_altloc_from_three(three):
  #look at all atoms in the main residues, plus the atoms used in calculations
  #  from adjacent residues to find if any have altlocs
  ##mc_atoms = (" N  ", " CA ", " C  ", " O  ")
  for atom in three[1].atoms():
    altchar = atom.parent().altloc
    if altchar != '':
      return altchar
  for atom in three[0].atoms():
    if atom.name != ' C  ':
      continue
    altchar = atom.parent().altloc
    if altchar != '':
      return altchar
  for atom in three[2].atoms():
    if atom.name != ' N  ':
      continue
    altchar = atom.parent().altloc
    if altchar != '':
      return altchar
  return ''

def construct_complete_residues(res_group):
  if (res_group is not None):
    complete_dict = {}
    nit, ca, co, oxy = None, None, None, None
    atom_groups = res_group.atom_groups()
    reordered = []
    # XXX always process blank-altloc atom group first
    for ag in atom_groups :
      if (ag.altloc == ''):
        reordered.insert(0, ag)
      else :
        reordered.append(ag)
    for ag in reordered :
      changed = False
      for atom in ag.atoms():
        if (atom.name == " N  "): nit = atom
        if (atom.name == " CA "): ca = atom
        if (atom.name == " C  "): co = atom
        if (atom.name == " O  "): oxy = atom
        if (atom.name in [" N  ", " CA ", " C  ", " O  "]):
          changed = True
      if (not None in [nit, ca, co, oxy]) and (changed):
        # complete residue backbone found
        complete_dict[ag.altloc] = [nit, ca, co, oxy]
    if len(complete_dict) > 0:
      return complete_dict
  return None

def isPrePro(residues, i):
  if (i < 0 or i >= len(residues) - 1): return False
  else:
    next = residues[i+1]
    for ag in next.atom_groups():
      if (ag.resname[0:3] == "PRO"): return True
  return False

def get_favored_regions(rama_key):
  """
  Returns list of tuples (phi, psi) inside separate favorable regions on
  particula Ramachandran plot.
  It is not the best idea to use strings, but it is not clear how
  conviniently use constants defined in the beginning of the file.
  """
  assert rama_key in range(6)

  if rama_key == RAMA_GENERAL:
    return [(-99, 119), (-63, -43), (53, 43), (60,-120)]
  if rama_key == RAMA_GLYCINE:
    return [(63, 41), (-63, -41), (79, -173), (-79, 173)]
  if rama_key == RAMA_CISPRO:
    return [(-75, 155), (-89, 5)]
  if rama_key == RAMA_TRANSPRO:
    # return [(-56, -55), (-55, 135)]
    return [(-57, -37), (-59, 143), (-81, 65)]
  if rama_key == RAMA_PREPRO:
    return [(-57, -45), (-100, 120), (49, 57)]
  if rama_key == RAMA_ILE_VAL:
    return [(-63, -45), (-119, 127)]
  return None

def get_favored_peaks(rama_key):
  """
  returns exact favored peaks with their score value
  """
  assert rama_key in range(6)

  if rama_key == RAMA_GENERAL:
    return [((-115.0, 131.0), 0.57068),
            ((-63.0, -43.0), 1.0),
            ((53.0, 43.0), 0.323004),
            ((53.0, -127.0), 0.0246619)]
  if rama_key == RAMA_GLYCINE:
    return [((63.0, 41.0), 1.0),
            ((-63.0, -41.0), 1.0),
            ((79.0, -173.0), 0.553852),
            # ((-79.0, 173.0), 0.553852),
            ]
  if rama_key == RAMA_CISPRO:
    return [((-75.0, 155.0), 1.0),
            ((-89.0, 5.0), 0.701149)]
  if rama_key == RAMA_TRANSPRO:
    return [((-57.0, -37.0), 0.99566),
            ((-59.0, 143.0), 1.0),
            ((-81.0, 65.0), 0.0896269)]
  if rama_key == RAMA_PREPRO:
    return [((-57.0, -45.0), 1.0),
            ((-67.0, 147.0), 0.992025),
            ((49.0, 57.0), 0.185259)]
  if rama_key == RAMA_ILE_VAL:
    return [((-63.0, -45.0), 1.0),
            ((-121.0, 129.0), 0.76163)]
  return None

def find_region_max_value(rama_key, phi, psi, allow_outside=False):
  def normalize(angle):
    a = int(angle)
    while a >= 180:
      a -= 360
    while a <= -180:
      a += 360
    return a
  from mmtbx.rotamer import ramachandran_eval
  from collections import Counter
  r = ramachandran_eval.RamachandranEval()
  value = r.evaluate(rama_key, [phi, psi])
  ev = ramalyze.evalScore(rama_key, value)
  if ev != RAMALYZE_FAVORED and not allow_outside:
    return None
  ph = int(phi)
  ps = int(psi)
  peaks = get_favored_peaks(rama_key)
  v = fav_tables[rama_key][normalize(ph)+180][normalize(ps)+180]
  values = []
  if v == 0:
    # look around, rounding problems
    for i in [-1,0,1]:
      for j in [-1,0,1]:
        values.append(fav_tables[rama_key][normalize(ph+i)+180][normalize(ps+j)+180])
    for e in Counter(values).elements():
      if e != 0:
        return peaks[e-1]
  if allow_outside:
    # do more comprehensive search, basically looking for the nearest
    # favorite region
    c = 1
    flag = True
    while flag:
      for i in range(-c,c):
        for j in range(-c,c):
          reg_number = fav_tables[rama_key][normalize(ph+i)+180][normalize(ps+j)+180]
          if reg_number != 0:
            flag = False
            return peaks[reg_number-1]
      c += 2
    return peaks[reg_number-1]
  if v == 0:
    return None
  else:
    return peaks[v-1]

#-----------------------------------------------------------------------
# GRAPHICS OUTPUT
def format_ramachandran_plot_title(position_type, residue_type):
  if (residue_type == '*'):
    title = "Ramachandran plot for " + res_type_plot_labels[position_type]
  else :
    title = "Ramachandran plot for " + residue_type
  return title

class ramachandran_plot_mixin(graphics.rotarama_plot_mixin):
  extent = [-180,180,-180,180]

  def set_labels(self, y_marks=()):
    self.plot.set_xlabel("Phi")
    self.plot.set_xticks([-120,-60,0,60,120])
    # self.plot.set_xticks([-160, -140, -120, -100, -80, -60, -40, -20, 0, 20, 40, 60, 80, 100, 120, 140, 160])
    self.plot.set_ylabel("Psi")
    self.plot.set_yticks([-120,-60,0,60,120])
    # self.plot.set_yticks([-160, -140, -120, -100, -80, -60, -40, -20, 0, 20, 40, 60, 80, 100, 120, 140, 160])
    self.plot.set_ylim((-182,182))
    self.plot.set_xlim((-182,182))
    # self.plot.grid(which='both', color='lime', linestyle='-', linewidth=2)

class ramachandran_plot(data_plots.simple_matplotlib_plot,
                         ramachandran_plot_mixin):
  def __init__(self, *args, **kwds):
    data_plots.simple_matplotlib_plot.__init__(self, *args, **kwds)
    ramachandran_plot_mixin.__init__(self, *args, **kwds)

def get_contours(position_type):
  '''
  Function for determining the contours in a Ramachandran plot

  Parameters
  ----------
  position_type: int, defined in beginning of file (e.g. RAMA_GENERAL)

  Returns
  -------
  list containing contours (2 numbers)

  data for plotting is being "scaled" in
  mmtbx/validation/utils.py: export_ramachandran_distribution():
    return npz ** scale_factor, # scale_factor = 0.25
  Therefore to calculate contours we need to look at
  mmtbx/validation/ramalyze.py: evalScore() for the logic and
  put the cutoff numbers to the power of 0.25
  '''
  general_contours = [0.1495, 0.376] # [0.0005**0.25, 0.02**0.25]
  cispro_contours = [0.21147, 0.376] # [0.002**0.25, 0.02**0.25]
  default_contours = [0.1778, 0.376] # [0.001**0.25, 0.02**0.25]

  contours = default_contours
  if position_type == RAMA_GENERAL :
    contours = general_contours
  elif position_type == RAMA_CISPRO :
    contours = cispro_contours
  return contours

def draw_ramachandran_plot(points,
                            rotarama_data,
                            position_type,
                            title,
                            show_labels=True,
                            markerfacecolor="white",
                            markeredgecolor="black",
                            show_filling=True,
                            show_contours=True,
                            markersize=10,
                            point_style='bo'):
  p = ramachandran_plot()
  contours = None
  if show_contours:
    contours = get_contours(position_type)
  p.draw_plot(
    stats=rotarama_data,
    title=title,
    points=points,
    show_labels=show_labels,
    colormap="Blues",
    contours=contours,
    markerfacecolor=markerfacecolor,
    markeredgecolor=markeredgecolor,
    show_filling=show_filling,
    markersize=markersize,
    point_style=point_style)
  return p


 *******************************************************************************


 *******************************************************************************
mmtbx/validation/regression/__init__.py


 *******************************************************************************


 *******************************************************************************
mmtbx/validation/regression/run_restraints.py

from __future__ import absolute_import, division, print_function
from mmtbx.monomer_library import pdb_interpretation
from mmtbx.validation import restraints
import sys

def run(args, log=sys.stdout):
  processed_pdb_file = pdb_interpretation.run(
    args=args,
    substitute_non_crystallographic_unit_cell_if_necessary=True,
    log=log)
  xray_structure = processed_pdb_file.xray_structure()
  if xray_structure is None :
    raise Sorry("Could not calculate X-ray structure from this PDB file. "+
      "This is probably due to missing symmetry information (CRYST1 record.")
  geometry = processed_pdb_file.geometry_restraints_manager(
    show_energies=False)
  chain_proxies = processed_pdb_file.all_chain_proxies
  pdb_hierarchy = chain_proxies.pdb_hierarchy
  result = restraints.combined(
    pdb_hierarchy=chain_proxies.pdb_hierarchy,
    xray_structure=xray_structure,
    geometry_restraints_manager=geometry,
    ignore_hd=True)
  result.show(out=log, prefix="  ")

if (__name__ == "__main__"):
  run(sys.argv[1:])


 *******************************************************************************


 *******************************************************************************
mmtbx/validation/regression/tst_cablam.py
from __future__ import absolute_import, division, print_function
from mmtbx.validation import cablam
from libtbx.test_utils import show_diff
from iotbx.data_manager import DataManager
from libtbx.test_utils import convert_string_to_cif_long

from iotbx import pdb
import libtbx.load_env
import os
import time
import json
from mmtbx.validation import test_utils

ref_cablam_text = """residue : outlier_type : contour_level : ca_contour_level : sec struc recommendation : alpha score : beta score : three-ten score
     3  ILE:                    :0.52764:0.49162:                 :0.06929:0.00000:0.00000
     4  PHE:                    :0.83948:0.80426: try alpha helix :0.34122:0.00000:0.00936
     5  GLU:                    :0.81271:0.79155: try alpha helix :0.31550:0.00000:0.00445
     6  MET:                    :0.77295:0.73578: try alpha helix :0.20871:0.00000:0.01115
     7  LEU:                    :0.70530:0.69504: try alpha helix :0.12026:0.00000:0.00484
     8  ARG:                    :0.71859:0.72353: try alpha helix :0.18161:0.00000:0.08888
     9  ILE:                    :0.84025:0.82510: try alpha helix :0.43515:0.00000:0.00548
    10  ASP:                    :0.65772:0.66407: try alpha helix :0.11727:0.00000:0.00000
    11  GLU:                    :0.17045:0.15375:                 :0.01055:0.00000:0.00000
    12  GLY:                    :0.35640:0.49471:                 :0.00000:0.00000:0.00000
    13  LEU:                    :0.07149:0.09040:                 :0.00000:0.00102:0.00000
    14  ARG:                    :0.41594:0.41432: try beta sheet  :0.00000:0.15626:0.00000
    15  LEU:                    :0.37150:0.44845: try beta sheet  :0.01142:0.00202:0.00000
    16  LYS:                    :0.14341:0.12064: try beta sheet  :0.00034:0.00045:0.00000
    17  ILE: CaBLAM Outlier     :0.00777:0.25439: try beta sheet  :0.00000:0.00123:0.00000
    18  TYR:                    :0.38403:0.26228: try beta sheet  :0.00000:0.00048:0.00000
    19  LYS:                    :0.23229:0.31769:                 :0.00000:0.00601:0.00000
    20  ASP:                    :0.24246:0.15915:                 :0.00000:0.00000:0.00000
    21  THR:                    :0.07474:0.10616:                 :0.00639:0.00000:0.00000
    22  GLU:                    :0.11848:0.17442:                 :0.00163:0.00000:0.00000
    23  GLY:                    :0.87986:0.86098:                 :0.00000:0.00000:0.00000
    24  TYR:                    :0.26671:0.25287:                 :0.00000:0.00975:0.00000
    25  TYR:                    :0.17809:0.17537: try beta sheet  :0.00000:0.00060:0.00000
    26  THR:                    :0.26444:0.16084:                 :0.00000:0.04956:0.00000
    27  ILE:                    :0.13051:0.05851:                 :0.00003:0.00000:0.00000
    28  GLY:                    :0.57593:0.34210:                 :0.00218:0.00000:0.00000
    29  ILE: CaBLAM Outlier     :0.00287:0.02229:                 :0.00006:0.00000:0.00000
    30  GLY:                    :0.27781:0.21754:                 :0.00000:0.00000:0.00000
    31  HIS:                    :0.38269:0.14269:                 :0.00000:0.05822:0.00000
    32  LEU:                    :0.34286:0.57402:                 :0.00000:0.07717:0.00000
    40C ASP:                    :0.94906:0.96373:                 :0.76901:0.00000:0.01862
    41  ALA:                    :0.92911:0.76129: try alpha helix :0.63484:0.00000:0.00712
    42  ALA:                    :0.96131:0.96875: try alpha helix :0.77091:0.00000:0.01214
    43  LYS:                    :0.97552:0.87406: try alpha helix :0.83796:0.00000:0.03254
    44  SER:                    :0.78399:0.86899: try alpha helix :0.79994:0.00000:0.01036
    45  GLU:                    :0.87884:0.86969: try alpha helix :0.73818:0.00000:0.01058
    46  LEU:                    :0.91916:0.88671: try alpha helix :0.74961:0.00000:0.03756
    47  ASP:                    :0.97483:0.96910: try alpha helix :0.90420:0.00000:0.01721
    48  LYS:                    :0.91878:0.96392: try alpha helix :0.80659:0.00000:0.01638
    49  ALA:                    :0.72801:0.71401: try alpha helix :0.14364:0.00000:0.00469
    50  ILE:                    :0.37448:0.38935:                 :0.04203:0.00000:0.00000
    51  GLY:                    :0.53355:0.56969:                 :0.00000:0.00000:0.00000
    52  ARG:                    :0.11630:0.07344:                 :0.00000:0.00736:0.00000
    53  ASN:                    :0.11365:0.08824: try beta sheet  :0.00000:0.00088:0.00000
    54  THR:                    :0.05756:0.15570:                 :0.00000:0.07997:0.00000
    55  ASN: CaBLAM Disfavored  :0.02086:0.00975:                 :0.00010:0.00000:0.00000
    56  GLY:                    :0.64275:0.61690:                 :0.00000:0.00000:0.00000
    57  VAL:                    :0.26151:0.15786:                 :0.00000:0.00000:0.00000
    58  ILE:                    :0.44409:0.45268:                 :0.00000:0.00268:0.00000
    59  THR:                    :0.49656:0.40961:                 :0.00000:0.00063:0.00000
    60  LYS:                    :0.57162:0.65356:                 :0.12322:0.00000:0.00000
    61  ASP:                    :0.87174:0.84785: try alpha helix :0.45478:0.00000:0.04867
    62  GLU:                    :0.94925:0.94200: try alpha helix :0.91876:0.00000:0.01601
    63  ALA:                    :0.78514:0.94158: try alpha helix :0.89034:0.00000:0.02358
    64  GLU:                    :0.84156:0.78750: try alpha helix :0.35344:0.00000:0.04013
    65  LYS:                    :0.80299:0.80830: try alpha helix :0.36710:0.00000:0.03984
    66  LEU:                    :0.86889:0.86756: try alpha helix :0.48381:0.00000:0.00890
    67  PHE:                    :0.90189:0.88748: try alpha helix :0.54551:0.00000:0.04663
    68  ASN:                    :0.98865:0.95803: try alpha helix :0.87462:0.00000:0.01623
    69  GLN:                    :0.97655:0.97438: try alpha helix :0.88753:0.00000:0.01169
    70  ASP:                    :0.78162:0.77513: try alpha helix :0.96064:0.00000:0.01640
    71  VAL:                    :0.75300:0.94269: try alpha helix :0.96236:0.00000:0.01399
    72  ASP:                    :0.96009:0.96323: try alpha helix :0.89004:0.00000:0.01905
    73  ALA:                    :0.89729:0.86971: try alpha helix :0.74118:0.00000:0.02781
    74  ALA:                    :0.96049:0.91354: try alpha helix :0.79346:0.00000:0.02381
    75  VAL:                    :0.90762:0.90773: try alpha helix :0.63817:0.00000:0.00743
    76  ARG:                    :0.85886:0.91395: try alpha helix :0.72908:0.00000:0.01009
    77  GLY:                    :0.96700:0.98047: try alpha helix :0.73374:0.00000:0.03867
    78  ILE:                    :0.98019:0.98238: try alpha helix :0.87047:0.00000:0.01631
    79  LEU:                    :0.58012:0.90368: try alpha helix :0.72839:0.00000:0.00859
    80  ARG:                    :0.44662:0.55775:                 :0.01191:0.00000:0.00000
    81  ASN:                    :0.34785:0.31423:                 :0.00000:0.00031:0.00000
    82  ALA:                    :0.29269:0.38361:                 :0.02096:0.00000:0.00000
    83  LYS:                    :0.58211:0.71041: try alpha helix :0.14248:0.00000:0.00001
    84  LEU:                    :0.41959:0.32368: try alpha helix :0.05148:0.00000:0.00626
    85  LYS:                    :0.66986:0.51927: try alpha helix :0.09610:0.00000:0.21238
    86  PRO:                    :0.98883:0.99594: try alpha helix :0.86833:0.00000:0.01204
    87  VAL:                    :0.75880:0.95367: try alpha helix :0.78186:0.00000:0.00912
    88  TYR:                    :0.91356:0.90539: try alpha helix :0.58192:0.00000:0.02264
    89  ASP:                    :0.73904:0.80679: try alpha helix :0.35668:0.00000:0.05555
    90  SER:                    :0.55972:0.60595:                 :0.00733:0.00000:0.01601
    91  LEU:                    :0.27769:0.22558:                 :0.00000:0.00107:0.00000
    92  ASP:                    :0.42270:0.36276:                 :0.00000:0.00000:0.00000
    93  ALA:                    :0.45818:0.40113:                 :0.07442:0.00000:0.00000
    94  VAL:                    :0.77606:0.76480: try alpha helix :0.51294:0.00000:0.00679
    95  ARG:                    :0.73578:0.72447: try alpha helix :0.16465:0.00000:0.02319
    96  ARG:                    :0.73291:0.70074: try alpha helix :0.14308:0.00000:0.15348
    97  ALA:                    :0.83719:0.80947: try alpha helix :0.32626:0.00000:0.05371
    98  ALA:                    :0.86385:0.88142: try alpha helix :0.53840:0.00000:0.04449
    99  LEU:                    :0.97900:0.93347: try alpha helix :0.84827:0.00000:0.01657
   100  ILE:                    :0.83575:0.81549: try alpha helix :0.35748:0.00000:0.04442
   101  ASN:                    :0.87477:0.84323: try alpha helix :0.45214:0.00000:0.04502
   102  MET:                    :0.96302:0.94884: try alpha helix :0.86991:0.00000:0.01048
   103  VAL:                    :0.96613:0.92822: try alpha helix :0.78662:0.00000:0.01923
   104  PHE:                    :0.77634:0.74271: try alpha helix :0.21660:0.00000:0.00765
   105  GLN:                    :0.56557:0.55357: try alpha helix :0.09128:0.00000:0.00000
   106  MET:                    :0.17345:0.14246:                 :0.01504:0.00000:0.00000
   107  GLY:                    :0.45772:0.54732:                 :0.00000:0.00000:0.00000
   108  GLU:                    :0.46203:0.46061:                 :0.05310:0.00000:0.00000
   109  THR:                    :0.92592:0.77315: try alpha helix :0.79332:0.00000:0.03679
   110  GLY:                    :0.94492:0.92742: try alpha helix :0.34326:0.00000:0.00675
   111  VAL:                    :0.65875:0.68327: try alpha helix :0.11230:0.00000:0.01439
   112  ALA:                    :0.68953:0.69294: try three-ten   :0.05884:0.00000:0.37750
   113  GLY:                    :0.35710:0.61555:                 :0.00122:0.00000:0.06679
   114  PHE: CaBLAM Disfavored  :0.02716:0.02012:                 :0.00000:0.00000:0.00000
   115  THR:                    :0.21716:0.25651:                 :0.02337:0.00038:0.00000
   116  ASN:                    :0.93064:0.87429: try alpha helix :0.62433:0.00000:0.00578
   117  SER:                    :0.84801:0.85414: try alpha helix :0.42589:0.00000:0.02916
   118  LEU:                    :0.82109:0.80540: try alpha helix :0.39810:0.00000:0.05275
   119  ARG:                    :0.97488:0.91843: try alpha helix :0.84079:0.00000:0.02236
   120  MET:                    :0.97381:0.94393: try alpha helix :0.85304:0.00000:0.02222
   121  LEU:                    :0.96664:0.96247: try alpha helix :0.76570:0.00000:0.01682
   122  GLN:                    :0.81647:0.96855: try alpha helix :0.78504:0.00000:0.03365
   123  GLN:                    :0.38558:0.54762:                 :0.01131:0.00000:0.00000
   124  LYS:                    :0.27195:0.31297:                 :0.00000:0.00063:0.00000
   125  ARG:                    :0.15025:0.03510: try beta sheet  :0.00000:0.01617:0.00000
   126  TRP:                    :0.36307:0.24379:                 :0.01956:0.00059:0.00000
   127  ASP:                    :0.90607:0.87620: try alpha helix :0.66236:0.00000:0.00567
   128  GLU:                    :0.94643:0.72509: try alpha helix :0.87977:0.00000:0.01864
   129  ALA:                    :0.78394:0.78865: try alpha helix :0.29204:0.00000:0.04696
   130  ALA:                    :0.83281:0.80403: try alpha helix :0.35091:0.00000:0.04734
   131  VAL:                    :0.89150:0.84481: try alpha helix :0.42877:0.00000:0.00505
   132  ASN:                    :0.84250:0.79163: try alpha helix :0.36966:0.00000:0.01480
   133  LEU:                    :0.72732:0.71627: try three-ten   :0.12666:0.00000:0.12935
   134  ALA:                    :0.58761:0.61900: try three-ten   :0.00324:0.00000:0.37544
   135  LYS: CaBLAM Disfavored  :0.04655:0.16709:                 :0.00000:0.00000:0.02864
   136  SER:                    :0.21418:0.10964:                 :0.00000:0.00275:0.00000
   137  ARG:                    :0.44964:0.57604:                 :0.05596:0.00000:0.00000
   138  TRP:                    :0.72494:0.72727: try alpha helix :0.15493:0.00000:0.07705
   139  TYR:                    :0.84309:0.82430: try alpha helix :0.39345:0.00000:0.00260
   140  ASN:                    :0.72053:0.79855: try alpha helix :0.36505:0.00000:0.00554
   141  GLN:                    :0.53741:0.51793:                 :0.07728:0.00000:0.00000
   142  THR:                    :0.19896:0.17954:                 :0.00051:0.00000:0.00000
   143  PRO:                    :0.66687:0.52699:                 :0.04263:0.00083:0.00000
   144  ASN:                    :0.77072:0.77580: try alpha helix :0.27392:0.00000:0.00914
   145  ARG:                    :0.74389:0.76664: try alpha helix :0.24488:0.00000:0.00073
   146  ALA:                    :0.91235:0.91083: try alpha helix :0.60613:0.00000:0.03068
   147  LYS:                    :0.75173:0.81694: try alpha helix :0.35878:0.00000:0.05334
   148  ARG:                    :0.79680:0.75473: try alpha helix :0.31349:0.00000:0.01607
   149  VAL:                    :0.82542:0.80165: try alpha helix :0.33416:0.00000:0.00323
   150  ILE:                    :0.90417:0.91613: try alpha helix :0.63958:0.00000:0.03949
   151  THR:                    :0.81490:0.82636: try alpha helix :0.48350:0.00000:0.03861
   152  THR:                    :0.86653:0.84523: try alpha helix :0.45410:0.00000:0.02507
   153  PHE:                    :0.88416:0.85966: try alpha helix :0.48595:0.00000:0.00357
   154  ARG:                    :0.58641:0.58326: try alpha helix :0.07799:0.00000:0.00000
   155  THR:                    :0.24379:0.24630:                 :0.02083:0.00000:0.00000
   156  GLY:                    :0.59583:0.57219:                 :0.00000:0.00063:0.00000
   157  THR:                    :0.32804:0.23017:                 :0.00000:0.00482:0.00000
   158  TRP:                    :0.08355:0.28156:                 :0.00000:0.00000:0.00000
   159  ASP:                    :0.40617:0.36789:                 :0.01844:0.00000:0.00000
   160  ALA:                    :0.66012:0.75135:                 :0.20693:0.00000:0.06554
SUMMARY: Note: Regardless of number of alternates, each residue is counted as having at most one outlier.
SUMMARY: CaBLAM found 151 full protein residues and 0 CA-only residues
SUMMARY: 5 residues (3.3%) have disfavored conformations. (<=5% expected).
SUMMARY: 2 residues (1.3%) have outlier conformations. (<=1% expected)
SUMMARY: 0 residues (0.00%) have severe CA geometry outliers. (<=0.5% expected)
SUMMARY: 87 residues (57.62%) are helix-like, 8 residues (5.30%) are beta-like
SUMMARY: 0 residues (0.00%) are correctable to helix, 1 residues (0.66%) are correctable to beta
"""

ref_cablam_oneline = """pdbid:151:1.3:3.3:0.00
"""

class cablam_test_string():
  #I wrote the regression test to use a class with a custom .write() method as a
  #  proof of principle for learning OOP and to see if I could. Possible because
  #  all my print functions accept an optional writeto= variable.
  def write(self,string):
    self.output += str(string)
  def __init__(self):
    self.output = ""

def exercise_cablam():
  regression_pdb = libtbx.env.find_in_repositories(
    relative_path="phenix_regression/pdb/pdb103l.ent",
    test=os.path.isfile) #This is the same file used for tst_kinemage.py
  if (regression_pdb is None):
    print("Skipping exercise_cablam(): input pdb (pdb103l.ent) not available")
    return
  #-----
  pdb_io = pdb.input(regression_pdb)
  pdbid = os.path.basename(regression_pdb)
  hierarchy = pdb_io.construct_hierarchy()

  output_holder = cablam_test_string()

  cablamalyze = cablam.cablamalyze(
    pdb_hierarchy = hierarchy,
    outliers_only=False,
    out=output_holder,
    quiet=False)

  cablamalyze.as_oneline()
  assert not show_diff(output_holder.output , ref_cablam_oneline)

  output_holder.output = ""

  cablamalyze.as_text()
  assert not show_diff(output_holder.output , ref_cablam_text)

cablam_json_multimodel_pdb = """MODEL        1
ATOM    120  N   LEU A  15      47.483  17.606  20.296  1.00 24.69           N
ATOM    121  CA  LEU A  15      47.208  17.724  21.716  1.00 28.08           C
ATOM    122  C   LEU A  15      46.866  19.132  22.189  1.00 47.52           C
ATOM    123  O   LEU A  15      46.551  19.411  23.375  1.00 42.41           O
ATOM    124  CB  LEU A  15      48.364  17.085  22.505  1.00 31.96           C
ATOM    125  CG  LEU A  15      48.460  15.567  22.290  1.00 33.79           C
ATOM    126  CD1 LEU A  15      49.627  14.978  23.088  1.00 56.11           C
ATOM    127  CD2 LEU A  15      47.145  14.911  22.717  1.00 70.78           C
ATOM    128  N   LYS A  16      46.925  20.028  21.225  1.00 27.45           N
ATOM    129  CA  LYS A  16      46.714  21.414  21.506  1.00 50.37           C
ATOM    130  C   LYS A  16      45.623  21.941  20.637  1.00 31.00           C
ATOM    131  O   LYS A  16      45.582  21.634  19.451  1.00 60.11           O
ATOM    132  CB  LYS A  16      48.019  22.163  21.214  1.00 55.51           C
ATOM    133  CG  LYS A  16      48.021  23.610  21.660  1.00 83.77           C
ATOM    134  CD  LYS A  16      48.087  23.790  23.175  1.00100.00           C
ATOM    135  CE  LYS A  16      46.895  24.555  23.771  1.00100.00           C
ATOM    136  NZ  LYS A  16      46.850  26.013  23.485  1.00100.00           N
ATOM    137  N   ILE A  17      44.688  22.708  21.196  1.00 56.16           N
ATOM    138  CA  ILE A  17      43.629  23.210  20.321  1.00 19.13           C
ATOM    139  C   ILE A  17      44.193  23.624  18.967  1.00 40.60           C
ATOM    140  O   ILE A  17      45.370  23.978  18.830  1.00 68.25           O
ATOM    141  CB  ILE A  17      42.830  24.404  20.896  1.00 47.36           C
ATOM    142  CG1 ILE A  17      42.267  24.102  22.265  1.00 43.38           C
ATOM    143  CG2 ILE A  17      41.684  24.855  19.952  1.00 16.95           C
ATOM    144  CD1 ILE A  17      40.965  24.845  22.441  1.00 27.07           C
ATOM    145  N   TYR A  18      43.324  23.628  17.965  1.00 20.84           N
ATOM    146  CA  TYR A  18      43.767  24.010  16.657  1.00 17.35           C
ATOM    147  C   TYR A  18      42.604  24.316  15.754  1.00 20.49           C
ATOM    148  O   TYR A  18      41.441  24.001  16.010  1.00 36.50           O
ATOM    149  CB  TYR A  18      44.788  23.023  16.018  1.00 42.02           C
ATOM    150  CG  TYR A  18      44.181  21.700  15.576  1.00 53.94           C
ATOM    151  CD1 TYR A  18      44.040  20.596  16.425  1.00 30.37           C
ATOM    152  CD2 TYR A  18      43.736  21.576  14.262  1.00 27.24           C
ATOM    153  CE1 TYR A  18      43.447  19.409  15.988  1.00 71.37           C
ATOM    154  CE2 TYR A  18      43.188  20.385  13.783  1.00 25.76           C
ATOM    155  CZ  TYR A  18      43.014  19.319  14.661  1.00 38.01           C
ATOM    156  OH  TYR A  18      42.461  18.164  14.150  1.00 42.56           O
ATOM    157  N   LYS A  19      42.908  24.929  14.651  1.00 27.49           N
ATOM    158  CA  LYS A  19      41.887  25.242  13.695  1.00 22.06           C
ATOM    159  C   LYS A  19      41.905  24.288  12.552  1.00 73.84           C
ATOM    160  O   LYS A  19      42.947  23.965  11.971  1.00 50.03           O
ATOM    161  CB  LYS A  19      41.983  26.625  13.131  1.00 32.98           C
ATOM    162  CG  LYS A  19      41.434  27.679  14.049  1.00 94.12           C
ATOM    163  CD  LYS A  19      41.484  29.058  13.414  1.00100.00           C
ATOM    164  CE  LYS A  19      42.332  30.073  14.190  1.00 71.32           C
ATOM    165  NZ  LYS A  19      42.244  31.445  13.655  1.00100.00           N
ENDMDL
MODEL        2
ATOM   1014  N   LEU A 133      30.536  10.928  -6.190  1.00 16.93           N
ATOM   1015  CA  LEU A 133      31.011  11.480  -4.927  1.00 19.63           C
ATOM   1016  C   LEU A 133      31.992  12.625  -5.134  1.00 26.72           C
ATOM   1017  O   LEU A 133      32.125  13.484  -4.270  1.00 23.28           O
ATOM   1018  CB  LEU A 133      31.707  10.402  -4.052  1.00 14.35           C
ATOM   1019  CG  LEU A 133      30.760   9.425  -3.342  1.00 31.49           C
ATOM   1020  CD1 LEU A 133      31.551   8.266  -2.745  1.00 37.78           C
ATOM   1021  CD2 LEU A 133      30.076  10.146  -2.198  1.00 14.00           C
ATOM   1022  N   ALA A 134      32.750  12.572  -6.245  1.00 21.52           N
ATOM   1023  CA  ALA A 134      33.801  13.544  -6.549  1.00 21.07           C
ATOM   1024  C   ALA A 134      33.292  14.934  -6.866  1.00 21.47           C
ATOM   1025  O   ALA A 134      34.032  15.932  -6.804  1.00 19.33           O
ATOM   1026  CB  ALA A 134      34.720  13.025  -7.662  1.00 17.54           C
ATOM   1027  N   LYS A 135      32.011  14.996  -7.224  1.00 21.06           N
ATOM   1028  CA  LYS A 135      31.347  16.250  -7.554  1.00 25.54           C
ATOM   1029  C   LYS A 135      30.774  16.866  -6.309  1.00 19.56           C
ATOM   1030  O   LYS A 135      29.550  16.919  -6.156  1.00 24.91           O
ATOM   1031  CB  LYS A 135      30.214  16.106  -8.570  1.00 12.97           C
ATOM   1032  CG  LYS A 135      30.558  15.217  -9.733  1.00 22.54           C
ATOM   1033  CD  LYS A 135      29.544  15.351 -10.840  1.00 46.13           C
ATOM   1034  CE  LYS A 135      30.178  15.191 -12.206  1.00 71.90           C
ATOM   1035  NZ  LYS A 135      29.730  13.985 -12.903  1.00 97.93           N
ATOM   1036  N   SER A 136      31.642  17.287  -5.410  1.00 13.65           N
ATOM   1037  CA  SER A 136      31.181  17.859  -4.158  1.00 14.56           C
ATOM   1038  C   SER A 136      32.180  18.868  -3.601  1.00 27.10           C
ATOM   1039  O   SER A 136      33.388  18.832  -3.911  1.00 22.82           O
ATOM   1040  CB  SER A 136      31.008  16.717  -3.136  1.00 17.51           C
ATOM   1041  OG  SER A 136      32.237  15.971  -3.070  1.00 15.66           O
ATOM   1042  N   ARG A 137      31.700  19.738  -2.728  1.00 19.66           N
ATOM   1043  CA  ARG A 137      32.576  20.679  -2.052  1.00 18.34           C
ATOM   1044  C   ARG A 137      33.630  19.903  -1.265  1.00 15.29           C
ATOM   1045  O   ARG A 137      34.808  20.230  -1.267  1.00 20.30           O
ATOM   1046  CB  ARG A 137      31.754  21.450  -1.038  1.00 22.08           C
ATOM   1047  CG  ARG A 137      32.616  22.258  -0.087  1.00 29.17           C
ATOM   1048  CD  ARG A 137      31.813  23.256   0.761  1.00 24.81           C
ATOM   1049  NE  ARG A 137      32.564  24.474   1.087  1.00100.00           N
ATOM   1050  CZ  ARG A 137      33.415  24.547   2.121  1.00100.00           C
ATOM   1051  NH1 ARG A 137      33.629  23.496   2.928  1.00100.00           N
ATOM   1052  NH2 ARG A 137      34.073  25.698   2.345  1.00100.00           N
ENDMDL
END
"""

def exercise_cablam_json2(test_mmcif=False):
  dm = DataManager()
  #print(help(dm))
  if test_mmcif:
    pdb_test_string = convert_string_to_cif_long(cablam_json_multimodel_pdb, hetatm_name_addition = "", chain_addition="LONGCHAIN")
  else:
    pdb_test_string = cablam_json_multimodel_pdb
  dm.process_model_str("1",pdb_test_string)
  m = dm.get_model("1")
  output_holder = cablam_test_string()

  cablamalyze = cablam.cablamalyze(
    pdb_hierarchy = m.get_hierarchy(),
    outliers_only=False,
    out=output_holder,
    quiet=False)

  cablam_json = cablamalyze.as_JSON()
  cablam_dict = json.loads(cablam_json)
  #import pprint
  #pprint.pprint(cablam_dict)
  summary_results_dict = cablam_dict['summary_results']
  if "   1" in summary_results_dict:
    summary_results_1_dict = summary_results_dict["   1"]
    summary_results_2_dict = summary_results_dict["   2"]
  else:
    summary_results_1_dict = summary_results_dict["1"]
    summary_results_2_dict = summary_results_dict["2"]
  assert summary_results_2_dict["num_cablam_disfavored"]==1, "tst_cablam summary json model 2 num_disfavored value changed, now: "+str(cablam_dict['summary_results']["   2"]["num_cablam_disfavored"])
  assert summary_results_1_dict["num_cablam_outliers"]==1, "tst_cablam summary json model 1 num_outliers value changed, now: "+str(cablam_dict['summary_results']["   1"]["num_cablam_outliers"])
  return cablam_dict

def exercise_cablam_json(test_mmcif=False):
  regression_pdb = libtbx.env.find_in_repositories(
    relative_path="phenix_regression/pdb/pdb103l.ent",
    test=os.path.isfile) #This is the same file used for tst_kinemage.py
  if (regression_pdb is None):
    print("Skipping exercise_cablam(): input pdb (pdb103l.ent) not available")
    return
  #-----
  dm = DataManager()
  if test_mmcif:
    with open(regression_pdb) as f:
      pdb_103l_str = f.read()
    pdb_103l_str = convert_string_to_cif_long(pdb_103l_str, hetatm_name_addition = "", chain_addition="LONGCHAIN")
    dm.process_model_str("1", pdb_103l_str)
    m = dm.get_model("1")
  else:
    m = dm.get_model(regression_pdb)
  output_holder = cablam_test_string()

  pdb_hierarchy_tst = m.get_hierarchy()

  cablamalyze = cablam.cablamalyze(
    pdb_hierarchy = m.get_hierarchy(),
    outliers_only=False,
    out=output_holder,
    quiet=False)

  cablam_json = cablamalyze.as_JSON()
  cablam_dict = json.loads(cablam_json)
  assert len(cablam_dict['flat_results'])==151, "tst_cablam json output not returning correct number of outliers, now: "+str(len(cablam_dict['flat_results']))
  assert cablam_dict['flat_results'][14]['outlier'], "tst_cablam json output first outlier changed"
  assert cablam_dict['flat_results'][14]['outlier_type']=='CaBLAM Outlier', "tst_cablam json output first outlier_type changed, now: "+cablam_dict['flat_results'][14]['outlier_type']
  assert test_utils.count_dict_values(cablam_dict['hierarchical_results'], "CaBLAM Outlier")==2, "tst_cablam hierarchical json total CaBLAM Outliers changed, now: "+str(test_utils.count_dict_values(cablam_dict['hierarchical_results'], "CaBLAM Outlier"))
  assert test_utils.count_dict_values(cablam_dict['hierarchical_results'], "CaBLAM Disfavored")==3, "tst_cablam hierarchical json total CaBLAM Disfavored changed, now: "+str(test_utils.count_dict_values(cablam_dict['hierarchical_results'], "CaBLAM Disfavored"))
  assert cablam_dict['summary_results'][""]["num_cablam_disfavored"]==5, "tst_cablam summary json num_disfavored value changed, now: "+str(cablam_dict['summary_results'][""]["num_cablam_disfavored"])
  assert cablam_dict['summary_results'][""]["num_cablam_outliers"]==2, "tst_cablam summary json num_outliers value changed, now: "+str(cablam_dict['summary_results'][""]["num_cablam_outliers"])
  assert cablam_dict['summary_results'][""]["num_ca_geom_outliers"]==0, "tst_cablam summary json num_ca_geom_outliers value changed, now: "+str(cablam_dict['summary_results'][""]["num_ca_geom_outliers"])
  assert cablam_dict['summary_results'][""]["num_residues"]==151, "tst_cablam summary json num_residues value changed, now: "+str(cablam_dict['summary_results'][""]["num_residues"])

def run():
  t0 = time.time()
  exercise_cablam()
  print("Cablam Text test OK")
  exercise_cablam_json()
  exercise_cablam_json(test_mmcif=True)
  print("Cablam JSON 1 OK")
  cablam_dict2 = exercise_cablam_json2()
  cablam_dict2cif = exercise_cablam_json2(test_mmcif=True)
  assert cablam_dict2['summary_results']['   1'] == cablam_dict2cif['summary_results']['1']
  assert cablam_dict2['summary_results']['   2'] == cablam_dict2cif['summary_results']['2']
  print("Cablam JSON 2 OK")
  print("OK. Time: %8.3f"%(time.time()-t0))

if (__name__ == "__main__"):
  run()


 *******************************************************************************


 *******************************************************************************
mmtbx/validation/regression/tst_cablam_2.py
from __future__ import absolute_import, division, print_function
from libtbx import easy_run
from iotbx.pdb.fetch import fetch_and_write
from time import time
import libtbx.load_env

def exercise_01():
  fetch_and_write(id='5o61', entity='model_cif')
  fb = easy_run.fully_buffered("phenix.cablam 5o61.cif")
  assert fb.return_code == 0, fb.return_code

if (__name__ == "__main__"):
  t0 = time()
  if (not libtbx.env.has_module(name="phenix")):
    print("Skipping: probe not configured")
  else:
    exercise_01()
  print("Time: %.2f" % (time() - t0))
  print("OK")


 *******************************************************************************


 *******************************************************************************
mmtbx/validation/regression/tst_cbetadev.py

from __future__ import absolute_import, division, print_function
from libtbx.test_utils import approx_equal, show_diff
import libtbx.load_env
from libtbx.easy_pickle import loads, dumps
from six.moves import cStringIO as StringIO
import iotbx.pdb
from iotbx.data_manager import DataManager
from libtbx.test_utils import convert_string_to_cif_long
import os.path
import json
import time

def exercise_cbetadev():
  regression_pdb = libtbx.env.find_in_repositories(
    relative_path="phenix_regression/pdb/pdb1jxt.ent",
    test=os.path.isfile)
  if (regression_pdb is None):
    print("Skipping exercise_cbetadev(): input pdb (pdb1jxt.ent) not available")
    return
  from mmtbx.validation import cbetadev
  pdb_in = iotbx.pdb.input(file_name=regression_pdb)
  hierarchy = pdb_in.construct_hierarchy()
  validation = cbetadev.cbetadev(
    pdb_hierarchy=hierarchy,
    outliers_only=True)
  assert approx_equal(validation.get_weighted_outlier_percent(), 4.40420846587)
  for unpickle in [False, True] :
    if unpickle :
      validation = loads(dumps(validation))
    assert (validation.n_outliers == len(validation.results) == 6)
    assert ([ cb.id_str() for cb in validation.results ] ==
      [' A   7 AILE', ' A   8 BVAL', ' A   8 CVAL', ' A  30 BTHR',
       ' A  39 BTHR', ' A  43 BASP'])
    assert approx_equal([ cb.deviation for cb in validation.results ],
      [0.25977096732623106, 0.2577218834868609, 0.6405578498280606,
       0.81238828498566, 0.9239566035292618, 0.5001892640352836])
    out = StringIO()
    validation.show_old_output(out=out, verbose=True)
    assert not show_diff(out.getvalue(),
"""\
pdb:alt:res:chainID:resnum:dev:dihedralNABB:Occ:ALT:
pdb :A:ile: A:   7 :  0.260: -46.47:   0.45:A:
pdb :B:val: A:   8 :  0.258:  80.92:   0.30:B:
pdb :C:val: A:   8 :  0.641: -53.98:   0.20:C:
pdb :B:thr: A:  30 :  0.812: -76.98:   0.30:B:
pdb :B:thr: A:  39 :  0.924:  56.41:   0.30:B:
pdb :B:asp: A:  43 :  0.500:   7.56:   0.25:B:
SUMMARY: 6 C-beta deviations >= 0.25 Angstrom (Goal: 0)
""")

  # Now with all residues
  validation = cbetadev.cbetadev(
    pdb_hierarchy=hierarchy,
    outliers_only=False)
  for unpickle in [False, True] :
    if unpickle :
      validation = loads(dumps(validation))
    for outlier in validation.results :
      assert (len(outlier.xyz) == 3)
    assert (validation.n_outliers == 6)
    assert (len(validation.results) == 51)
    assert validation.percent_outliers > 0.
    #assert validation.percent_outliers==10.
    out = StringIO()
    validation.show_old_output(out=out, verbose=True)
    assert not show_diff(out.getvalue(), """\
pdb:alt:res:chainID:resnum:dev:dihedralNABB:Occ:ALT:
pdb : :thr: A:   1 :  0.102:  11.27:   1.00: :
pdb :A:thr: A:   2 :  0.022: -49.31:   0.67:A:
pdb : :cys: A:   3 :  0.038: 103.68:   1.00: :
pdb : :cys: A:   4 :  0.047:-120.73:   1.00: :
pdb : :pro: A:   5 :  0.069:-121.41:   1.00: :
pdb : :ser: A:   6 :  0.052: 112.87:   1.00: :
pdb :A:ile: A:   7 :  0.260: -46.47:   0.45:A:
pdb :B:ile: A:   7 :  0.153: 122.97:   0.55:B:
pdb :A:val: A:   8 :  0.184:-155.36:   0.50:A:
pdb :B:val: A:   8 :  0.258:  80.92:   0.30:B:
pdb :C:val: A:   8 :  0.641: -53.98:   0.20:C:
pdb : :ala: A:   9 :  0.061: -82.84:   1.00: :
pdb :A:arg: A:  10 :  0.023: 172.25:   1.00:A:
pdb : :ser: A:  11 :  0.028:-129.11:   1.00: :
pdb :A:asn: A:  12 :  0.021: -80.80:   0.50:A:
pdb :B:asn: A:  12 :  0.199:  50.01:   0.50:B:
pdb :A:phe: A:  13 :  0.067: -37.32:   0.65:A:
pdb :B:phe: A:  13 :  0.138:  19.24:   0.35:B:
pdb : :asn: A:  14 :  0.065: -96.35:   1.00: :
pdb : :val: A:  15 :  0.138: -96.63:   1.00: :
pdb : :cys: A:  16 :  0.102: -28.64:   1.00: :
pdb : :arg: A:  17 :  0.053:-106.79:   1.00: :
pdb : :leu: A:  18 :  0.053:-141.51:   1.00: :
pdb : :pro: A:  19 :  0.065:-146.95:   1.00: :
pdb : :thr: A:  21 :  0.086:  53.80:   1.00: :
pdb :A:pro: A:  22 :  0.092: -83.39:   0.55:A:
pdb :A:glu: A:  23 :  0.014:-179.53:   0.50:A:
pdb :B:glu: A:  23 :  0.050:-179.78:   0.50:B:
pdb : :ala: A:  24 :  0.056: -88.96:   1.00: :
pdb : :leu: A:  25 :  0.084:-106.42:   1.00: :
pdb : :cys: A:  26 :  0.074: -94.70:   1.00: :
pdb : :ala: A:  27 :  0.056: -62.15:   1.00: :
pdb : :thr: A:  28 :  0.056:-114.82:   1.00: :
pdb :A:tyr: A:  29 :  0.068:   0.22:   0.65:A:
pdb :A:thr: A:  30 :  0.180: 103.27:   0.70:A:
pdb :B:thr: A:  30 :  0.812: -76.98:   0.30:B:
pdb : :cys: A:  32 :  0.029: -84.07:   1.00: :
pdb : :ile: A:  33 :  0.048:-119.17:   1.00: :
pdb : :ile: A:  34 :  0.045:  99.02:   1.00: :
pdb : :ile: A:  35 :  0.052:-128.24:   1.00: :
pdb : :pro: A:  36 :  0.084:-142.29:   1.00: :
pdb : :ala: A:  38 :  0.039:  50.01:   1.00: :
pdb :A:thr: A:  39 :  0.093: -96.63:   0.70:A:
pdb :B:thr: A:  39 :  0.924:  56.41:   0.30:B:
pdb : :cys: A:  40 :  0.013:-144.11:   1.00: :
pdb : :pro: A:  41 :  0.039: -97.09:   1.00: :
pdb :A:asp: A:  43 :  0.130:-146.91:   0.75:A:
pdb :B:asp: A:  43 :  0.500:   7.56:   0.25:B:
pdb : :tyr: A:  44 :  0.085:-143.63:   1.00: :
pdb : :ala: A:  45 :  0.055:  33.32:   1.00: :
pdb : :asn: A:  46 :  0.066: -50.46:   1.00: :
SUMMARY: 6 C-beta deviations >= 0.25 Angstrom (Goal: 0)
""")

  # Auxilary function: extract_atoms_from_residue_group
  from mmtbx.validation.cbetadev import extract_atoms_from_residue_group
  from iotbx import pdb
  pdb_1 = pdb.input(source_info=None, lines="""\
ATOM   1185  N  ASER A 146      24.734  37.097  16.303  0.50 16.64           N
ATOM   1186  N  BSER A 146      24.758  37.100  16.337  0.50 16.79           N
ATOM   1187  CA ASER A 146      24.173  37.500  17.591  0.50 16.63           C
ATOM   1188  CA BSER A 146      24.237  37.427  17.662  0.50 16.87           C
ATOM   1189  C  ASER A 146      22.765  36.938  17.768  0.50 15.77           C
ATOM   1190  C  BSER A 146      22.792  36.945  17.783  0.50 15.94           C
ATOM   1191  O  ASER A 146      22.052  36.688  16.781  0.50 14.91           O
ATOM   1192  O  BSER A 146      22.091  36.741  16.779  0.50 15.17           O
ATOM   1193  CB ASER A 146      24.118  39.035  17.649  0.50 16.93           C
ATOM   1194  CB BSER A 146      24.321  38.940  17.904  0.50 17.48           C
ATOM   1195  OG ASER A 146      23.183  39.485  18.611  0.50 17.56           O
ATOM   1196  OG BSER A 146      23.468  39.645  17.028  0.50 18.32           O  """).construct_hierarchy()
  pdb_2 = pdb.input(source_info=None, lines="""\
ATOM   1185  N   SER A 146      24.734  37.097  16.303  0.50 16.64           N
ATOM   1187  CA  SER A 146      24.173  37.500  17.591  0.50 16.63           C
ATOM   1189  C   SER A 146      22.765  36.938  17.768  0.50 15.77           C
ATOM   1191  O   SER A 146      22.052  36.688  16.781  0.50 14.91           O
ATOM   1193  CB ASER A 146      24.118  39.035  17.649  0.50 16.93           C
ATOM   1194  CB BSER A 146      24.321  38.940  17.904  0.50 17.48           C
ATOM   1195  OG ASER A 146      23.183  39.485  18.611  0.50 17.56           O
ATOM   1196  OG BSER A 146      23.468  39.645  17.028  0.50 18.32           O  """).construct_hierarchy()
  pdb_3 = pdb.input(source_info=None, lines="""\
ATOM   1185  N   SER A 146      24.734  37.097  16.303  0.50 16.64           N
ATOM   1187  CA  SER A 146      24.173  37.500  17.591  0.50 16.63           C
ATOM   1189  C   SER A 146      22.765  36.938  17.768  0.50 15.77           C
ATOM   1191  O   SER A 146      22.052  36.688  16.781  0.50 14.91           O
ATOM   1193  CB  SER A 146      24.118  39.035  17.649  0.50 16.93           C
ATOM   1195  OG ASER A 146      23.183  39.485  18.611  0.50 17.56           O
ATOM   1196  OG BSER A 146      23.468  39.645  17.028  0.50 18.32           O  """).construct_hierarchy()
  rg1 = pdb_1.only_model().only_chain().only_residue_group()
  rg2 = pdb_2.only_model().only_chain().only_residue_group()
  rg3 = pdb_3.only_model().only_chain().only_residue_group()
  all_relevant_atoms_1 = extract_atoms_from_residue_group(rg1)
  all_relevant_atoms_2 = extract_atoms_from_residue_group(rg2)
  all_relevant_atoms_3 = extract_atoms_from_residue_group(rg3)
  keys_1 = [ sorted([ k for k in a.keys() ]) for a in all_relevant_atoms_1 ]
  keys_2 = [ sorted([ k for k in a.keys() ]) for a in all_relevant_atoms_2 ]
  keys_3 = [ sorted([ k for k in a.keys() ]) for a in all_relevant_atoms_3 ]
  assert keys_1 == [[' C  ',' CA ',' CB ',' N  '],[' C  ',' CA ',' CB ',' N  ']]
  assert keys_2 == [[' C  ',' CA ',' CB ',' N  '],[' C  ',' CA ',' CB ',' N  ']]
  assert keys_3 == [[' C  ', ' CA ', ' CB ', ' N  ']]
  print("OK")

def exercise_cbetadev_d_peptide():
  from iotbx import pdb
  from mmtbx.validation import cbetadev
  hierarchy = pdb.input(source_info=None, lines='''
HETATM  566  N   DAL A  11      17.834  32.465  30.842  1.00  5.31           N
HETATM  567  CA  DAL A  11      16.839  31.829  29.896  1.00  4.19           C
HETATM  568  CB  DAL A  11      16.047  30.735  30.590  1.00  5.94           C
HETATM  569  C   DAL A  11      17.623  31.302  28.726  1.00  3.99           C
HETATM  570  O   DAL A  11      18.770  30.854  28.916  1.00  5.73           O''').construct_hierarchy()
  validation = cbetadev.cbetadev(
    pdb_hierarchy=hierarchy,
    outliers_only=False)
  # assert approx_equal(validation.get_weighted_outlier_percent(), 4.40420846587)
  for unpickle in [False, True] :
    if unpickle :
      validation = loads(dumps(validation))
    assert (len(validation.results) == 1)
    assert (validation.n_outliers == 0)
    assert ([ cb.id_str() for cb in validation.results ] ==
      [' A  11  DAL'])
    assert approx_equal([ cb.deviation for cb in validation.results ],
      [0.02848041692354018])
    print(validation.percent_outliers)
    assert validation.percent_outliers == 0.
    out = StringIO()
    validation.show_old_output(out=out, verbose=True)
    print(out.getvalue())
    for cb in validation.results:
      print(cb.id_str(), cb.deviation)
      assert cb.deviation<1.
  print('OK')

def exercise_cbetadev_misnamed_peptides():
  #testing that residues with wrong chirality show up as outliers
  #I have swapped the names of an otherwise real THR and DTH from 7ooj.pdb
  #they should both be outliers
  from iotbx import pdb
  from mmtbx.validation import cbetadev
  hierarchy = pdb.input(source_info=None, lines='''
HETATM  411  N   THR A  53      22.401  17.450 -18.803  1.00 66.31           N
HETATM  412  CA  THR A  53      23.810  17.544 -18.580  1.00 66.58           C
HETATM  413  CB  THR A  53      24.424  18.930 -18.527  1.00 67.06           C
HETATM  414  CG2 THR A  53      23.940  19.663 -17.276  1.00 68.25           C
HETATM  415  OG1 THR A  53      24.132  19.634 -19.725  1.00 69.19           O
HETATM  416  C   THR A  53      24.317  16.671 -19.722  1.00 67.57           C
HETATM  417  O   THR A  53      25.217  15.882 -19.525  1.00 76.32           O
ATOM    519  N   DTH A  66      14.250  13.187 -35.224  1.00 56.90           N
ATOM    520  CA  DTH A  66      12.879  13.360 -34.677  1.00 58.61           C
ATOM    521  C   DTH A  66      12.864  13.014 -33.188  1.00 57.65           C
ATOM    522  O   DTH A  66      13.234  11.876 -32.846  1.00 58.82           O
ATOM    523  CB  DTH A  66      11.870  12.499 -35.441  1.00 60.31           C
ATOM    524  OG1 DTH A  66      11.977  12.858 -36.818  1.00 66.15           O
ATOM    525  CG2 DTH A  66      10.452  12.683 -34.948  1.00 62.67           C''').construct_hierarchy()
  validation = cbetadev.cbetadev(
    pdb_hierarchy=hierarchy,
    outliers_only=True)
  # assert approx_equal(validation.get_weighted_outlier_percent(), 4.40420846587)
  for unpickle in [False, True] :
    if unpickle :
      validation = loads(dumps(validation))
    assert (validation.n_outliers == len(validation.results) == 2)
    assert ([ cb.id_str() for cb in validation.results ] ==
      [' A  53  THR',' A  66  DTH'])
    print([ cb.deviation for cb in validation.results ])
    assert approx_equal([ cb.deviation for cb in validation.results ],
      [2.3247665655338596, 2.4166600592687995])
    print(validation.percent_outliers)
    assert validation.percent_outliers>0.
    out = StringIO()
    validation.show_old_output(out=out, verbose=True)
    print(out.getvalue())
    for cb in validation.results:
      print(cb.id_str(), cb.deviation)
      assert cb.deviation>2.
  print('OK')

def exercise_cbetadev_nonstandard_peptide():
  #testing that a nonstandard animo acid defaults to the general case
  #LYZ is hydroxylysine
  from iotbx import pdb
  from mmtbx.validation import cbetadev
  hierarchy = pdb.input(source_info=None, lines='''
HETATM 3181  N   LYZ D   3      -1.842  -5.028  54.291  1.00 35.06           N
HETATM 3182  CA  LYZ D   3      -3.207  -4.726  53.880  1.00 36.27           C
HETATM 3183  C   LYZ D   3      -3.841  -3.660  54.771  1.00 41.71           C
HETATM 3184  O   LYZ D   3      -4.669  -2.842  54.381  1.00 52.20           O
HETATM 3185  CB  LYZ D   3      -4.176  -5.939  53.836  1.00 34.68           C''').construct_hierarchy()
  validation = cbetadev.cbetadev(
    pdb_hierarchy=hierarchy,
    outliers_only=False)
  # assert approx_equal(validation.get_weighted_outlier_percent(), 4.40420846587)
  for unpickle in [False, True] :
    if unpickle :
      validation = loads(dumps(validation))
    assert (len(validation.results) == 1)
    assert (validation.n_outliers == 0)
    assert ([ cb.id_str() for cb in validation.results ] ==
      [' D   3  LYZ'])
    assert approx_equal([ cb.deviation for cb in validation.results ],
      [0.14107909562037108])
    print(validation.percent_outliers)
    assert validation.percent_outliers == 0.
    out = StringIO()
    validation.show_old_output(out=out, verbose=True)
    print(out.getvalue())
    for cb in validation.results:
      print(cb.id_str(), cb.deviation)
      assert cb.deviation<1.
  print('OK')

def exercise_cbetadev_unknown_peptide():
  #testing that a nonstandard animo acid defaults to the general case
  #LYZ is hydroxylysine
  from iotbx import pdb
  from mmtbx.validation import cbetadev
  hierarchy = pdb.input(source_info=None, lines='''
HETATM 3181  N   LY? D   3      -1.842  -5.028  54.291  1.00 35.06           N
HETATM 3182  CA  LY? D   3      -3.207  -4.726  53.880  1.00 36.27           C
HETATM 3183  C   LY? D   3      -3.841  -3.660  54.771  1.00 41.71           C
HETATM 3184  O   LY? D   3      -4.669  -2.842  54.381  1.00 52.20           O
HETATM 3185  CB  LY? D   3      -4.176  -5.939  53.836  1.00 34.68           C''').construct_hierarchy()
  validation = cbetadev.cbetadev(
    pdb_hierarchy=hierarchy,
    outliers_only=False)
  # assert approx_equal(validation.get_weighted_outlier_percent(), 4.40420846587)
  for unpickle in [False, True] :
    if unpickle :
      validation = loads(dumps(validation))
    assert (len(validation.results) == 1)
    assert (validation.n_outliers == 0)
    for cb in validation.results: print(cb.id_str())
    assert ([ cb.id_str() for cb in validation.results ] ==
      [' D   3  LY?'])
    assert approx_equal([ cb.deviation for cb in validation.results ],
      [0.14107909562037108])
    print(validation.percent_outliers)
    assert validation.percent_outliers == 0.
    out = StringIO()
    validation.show_old_output(out=out, verbose=True)
    print(out.getvalue())
    for cb in validation.results:
      print(cb.id_str(), cb.deviation)
      assert cb.deviation<1.
  print('OK')

def exercise_cbetadev_json(test_mmcif=False):
  regression_pdb = libtbx.env.find_in_repositories(
    relative_path="phenix_regression/pdb/pdb1jxt.ent",
    test=os.path.isfile)
  if (regression_pdb is None):
    print("Skipping exercise_cbetadev(): input pdb (pdb1jxt.ent) not available")
    return
  from mmtbx.validation import cbetadev
  dm = DataManager()
  if test_mmcif:
    with open(regression_pdb) as f:
      pdb_1jxt_str = f.read()
    pdb_1jxt_str = convert_string_to_cif_long(pdb_1jxt_str, hetatm_name_addition = "", chain_addition="LONGCHAIN")
    dm.process_model_str("1", pdb_1jxt_str)
    m = dm.get_model("1")
    chainA = "ALONGCHAIN"
  else:
    m = dm.get_model(regression_pdb)
    chainA = "A"
  cbeta_json = cbetadev.cbetadev(pdb_hierarchy=m.get_hierarchy(), outliers_only=True).as_JSON()
  cbeta_dict = json.loads(cbeta_json)
  assert len(cbeta_dict['flat_results'])==6, "tst_cbetadev json output not returning correct number of outliers, now: "+str(len(cbeta_dict['flat_results']))
  assert approx_equal(cbeta_dict['flat_results'][0]['deviation'], 0.25977096732623106), "tst_cbetadev json output first deviation not approx_equal, now: "+str(cbeta_dict['flat_results'][0]['deviation'])
  assert approx_equal(cbeta_dict['flat_results'][-1]['deviation'], 0.5001892640352836), "tst_cbetadev json output last deviation not approx_equal, now: "+str(cbeta_dict['flat_results'][-1]['deviation'])
  assert approx_equal(cbeta_dict['hierarchical_results'][''][chainA]["   8 "]['B']["dihedral_NABB"], 80.92016704402938), "tst_cbetadev json output hierarchical result changed dihedral_NABB result, now: "+str(cbeta_dict['hierarchical_results'][''][chainA]["   8 "]['B']["dihedral_NABB"])
  assert cbeta_dict['summary_results'][""]['num_outliers']==6, "tst_cbetadev json output summary results num_outliers changed, now: "+str(cbeta_dict['summary_results'][""]['num_outliers'])
  assert cbeta_dict['summary_results'][""]['num_cbeta_residues']==51, "tst_cbetadev json output summary results num_cbeta_residues changed, now: "+str(cbeta_dict['summary_results'][""]['num_cbeta_residues'])
  return cbeta_dict

if (__name__ == "__main__"):
  t0 = time.time()
  exercise_cbetadev()
  exercise_cbetadev_d_peptide()
  exercise_cbetadev_misnamed_peptides()
  exercise_cbetadev_nonstandard_peptide()
  exercise_cbetadev_unknown_peptide()
  cb_dict = exercise_cbetadev_json()
  cb_dict_cif = exercise_cbetadev_json(test_mmcif=True)
  assert cb_dict['summary_results'] == cb_dict_cif['summary_results'], "tst_cbetadev summary results changed between pdb and cif version"
  print("OK. Time: %8.3f"%(time.time()-t0))


 *******************************************************************************


 *******************************************************************************
mmtbx/validation/regression/tst_cbetadev_02.py

from __future__ import absolute_import, division, print_function
from libtbx.test_utils import approx_equal
import libtbx.load_env
import iotbx.pdb
from mmtbx.validation import cbetadev
import os

def tst_01():
  """
  Exercise with model where coordinates are rounded to whole angstroms.
  """
  regression_pdb = libtbx.env.find_in_repositories(
    relative_path="cctbx_project/mmtbx/regression/pdbs/1ucs_cutted_xyz_rounded.pdb",
    test=os.path.isfile)

  pdb_in = iotbx.pdb.input(regression_pdb)
  hierarchy = pdb_in.construct_hierarchy()
  validation = cbetadev.cbetadev(
    pdb_hierarchy=hierarchy,
    outliers_only=True)
  # print (validation.get_weighted_outlier_percent())
  assert approx_equal(validation.get_weighted_outlier_percent(), 96.7741935483871)

if (__name__ == "__main__"):
  tst_01()
  print("OK")


 *******************************************************************************


 *******************************************************************************
mmtbx/validation/regression/tst_chiral_validation.py
from __future__ import absolute_import, division, print_function
from mmtbx.validation.restraints import chiralities
from libtbx.utils import null_out
from libtbx.easy_pickle import loads
from iotbx.data_manager import DataManager
from mmtbx.model import manager
from libtbx.test_utils import convert_pdb_to_cif_for_pdb_str
import time
import json
import difflib
import io

pdb_2v2k_str = """MODEL        1
ATOM    115  N   DAL A  15      23.144  19.154  24.719  1.00 23.07           N
ATOM    116  CA  DAL A  15      24.113  19.525  23.694  1.00 22.93           C
ATOM    117  C   DAL A  15      23.806  18.844  22.351  1.00 22.65           C
ATOM    118  O   DAL A  15      24.011  19.423  21.279  1.00 22.00           O
ATOM    119  CB  DAL A  15      25.505  19.141  24.158  1.00 22.70           C
HETATM 1607 FE1  F3S A 107      20.751  10.219  14.297  1.00 14.17          FE
HETATM 1608 FE3  F3S A 107      22.460  11.642  15.904  1.00 13.82          FE
HETATM 1609 FE4  F3S A 107      20.669  12.898  14.321  1.00 15.68          FE
HETATM 1610  S1  F3S A 107      22.965   9.822  14.630  1.00 16.10           S
HETATM 1611  S2  F3S A 107      20.493  11.571  12.455  1.00 15.59           S
HETATM 1612  S4  F3S A 107      22.860  13.566  14.695  1.00 16.02           S
HETATM 1613  S3  F3S A 107      20.168  11.468  16.107  1.00 14.13           S
HETATM 1614 FE1  F3S A 108      21.826  14.818  24.986  1.00 15.67          FE
HETATM 1615 FE3  F3S A 108      21.220  13.567  27.239  1.00 15.93          FE
HETATM 1616 FE4  F3S A 108      23.758  13.892  26.554  1.00 16.45          FE
HETATM 1617  S1  F3S A 108      20.202  15.285  26.498  1.00 17.82           S
HETATM 1618  S2  F3S A 108      23.825  15.811  25.405  1.00 16.95           S
HETATM 1619  S3  F3S A 108      22.148  12.719  25.509  1.00 16.89           S
HETATM 1620  S4  F3S A 108      22.801  13.937  28.648  1.00 19.61           S
ENDMDL
MODEL        2
ATOM    115  N   DAL A  15      23.144  19.154  24.719  1.00 23.07           N
ATOM    116  CA  DAL A  15      24.113  19.525  23.694  1.00 22.93           C
ATOM    117  C   DAL A  15      23.806  18.844  22.351  1.00 22.65           C
ATOM    118  O   DAL A  15      24.011  19.423  21.279  1.00 22.00           O
ATOM    119  CB  DAL A  15      25.505  19.141  24.158  1.00 22.70           C
HETATM 1607 FE1  F3S A 107      20.751  10.219  14.297  1.00 14.17          FE
HETATM 1608 FE3  F3S A 107      22.460  11.642  15.904  1.00 13.82          FE
HETATM 1609 FE4  F3S A 107      20.669  12.898  14.321  1.00 15.68          FE
HETATM 1610  S1  F3S A 107      22.965   9.822  14.630  1.00 16.10           S
HETATM 1611  S2  F3S A 107      20.493  11.571  12.455  1.00 15.59           S
HETATM 1612  S4  F3S A 107      22.860  13.566  14.695  1.00 16.02           S
HETATM 1613  S3  F3S A 107      20.168  11.468  16.107  1.00 14.13           S
HETATM 1614 FE1  F3S A 108      21.826  14.818  24.986  1.00 15.67          FE
HETATM 1615 FE3  F3S A 108      21.220  13.567  27.239  1.00 15.93          FE
HETATM 1616 FE4  F3S A 108      23.758  13.892  26.554  1.00 16.45          FE
HETATM 1617  S1  F3S A 108      20.202  15.285  26.498  1.00 17.82           S
HETATM 1618  S2  F3S A 108      23.825  15.811  25.405  1.00 16.95           S
HETATM 1619  S3  F3S A 108      22.148  12.719  25.509  1.00 16.89           S
HETATM 1620  S4  F3S A 108      22.801  13.937  28.648  1.00 19.61           S
ENDMDL
END
"""

expected_chiral = """  atoms                   ideal    model    delta   sigma  residual   deviation
   A 107  F3S  S2
   A 107  F3S FE1
   A 107  F3S FE3
   A 107  F3S FE4         10.77     7.78     2.99  2.00e-01  2.23e+02  14.9*sigma
   A 107  F3S  S2
   A 107  F3S FE1
   A 107  F3S FE3
   A 107  F3S FE4         10.77     7.78     2.99  2.00e-01  2.23e+02  14.9*sigma
   A  15  DAL  CA
   A  15  DAL  N
   A  15  DAL  C
   A  15  DAL  CB         -2.48     2.54    -5.02  2.00e-01  6.31e+02  25.1*sigma
   A  15  DAL  CA
   A  15  DAL  N
   A  15  DAL  C
   A  15  DAL  CB         -2.48     2.54    -5.02  2.00e-01  6.31e+02  25.1*sigma
   A 108  F3S  S2
   A 108  F3S FE1
   A 108  F3S FE3
   A 108  F3S FE4         10.77    -6.76    17.53  2.00e-01  7.68e+03  87.7*sigma
   A 108  F3S  S2
   A 108  F3S FE1
   A 108  F3S FE3
   A 108  F3S FE4         10.77    -6.76    17.53  2.00e-01  7.68e+03  87.7*sigma

  Min. delta:    2.988
  Max. delta:   17.532
  Mean delta:   10.670
"""

def calculate_results():
  dm = DataManager()
  #print(help(dm))
  dm.process_model_str("1",pdb_2v2k_str)
  model = dm.get_model("1")
  model.set_stop_for_unknowns(False)
  p = manager.get_default_pdb_interpretation_params()
  ##print(dir(p.pdb_interpretation))
  p.pdb_interpretation.allow_polymer_cross_special_position=True
  p.pdb_interpretation.flip_symmetric_amino_acids=False
  p.pdb_interpretation.clash_guard.nonbonded_distance_threshold = None
  model.set_log(log = null_out())
  model.process(make_restraints=True, pdb_interpretation_params=p)
  geometry_restraints_manager = model.get_restraints_manager().geometry
  pdb_hierarchy = model.get_hierarchy()
  pdb_hierarchy.atoms().reset_i_seq()
  xray_structure = model.get_xray_structure()
  from mmtbx import restraints
  restraints_manager = restraints.manager(
    geometry=geometry_restraints_manager)
  sites_cart = xray_structure.sites_cart()
  hd_selection = xray_structure.hd_selection()
  pdb_atoms = pdb_hierarchy.atoms()
  energies_sites = restraints_manager.energies_sites(
    sites_cart=sites_cart,
    compute_gradients=False).geometry
  restraint_proxies = getattr(restraints_manager.geometry, "chirality_proxies")
  chiral_list = chiralities(
      pdb_atoms=pdb_atoms,
      sites_cart=sites_cart,
      energies_sites=energies_sites,
      restraint_proxies=restraint_proxies,
      unit_cell=xray_structure.unit_cell(),
      ignore_hd=True,
      sigma_cutoff=4.0,
      outliers_only=True,
      use_segids_in_place_of_chainids=False)
  return chiral_list

def exercise_chiral_validation(chiral_list):

  chiral_io = io.StringIO()
  chiral_list.show(out=chiral_io, verbose=True)
  chiral_results = chiral_io.getvalue()
  chiral_io.close()
  diff = difflib.unified_diff(chiral_results.splitlines(), expected_chiral.splitlines(), fromfile="testvalue", tofile="expectedvalue")
  changed_lines = ""
  for line in diff:
    if line.startswith("-") or line.startswith("+"):
      changed_lines = changed_lines+"\n"+line
  assert changed_lines == "", "chiral validation text output changed, at the following lines: "+changed_lines

def exercise_chiral_json(chiral_list):
  ch_dict = json.loads(chiral_list.as_JSON())
  #import pprint
  #pprint.pprint(ch_dict)
  assert len(ch_dict['flat_results']) == 6, "tst_chiral_validation json output not returning correct number of water clashes, now: "+str(len(ch_dict['flat_results']))
  assert ch_dict['flat_results'][0]["outlier_type"] == "Tetrahedral geometry outlier", "tst_chiral_validation json output first outlier_type value changed, now: "+ch_dict['flat_results'][0]["outlier_type"]
  from mmtbx.validation import test_utils
  assert test_utils.count_dict_values(ch_dict['hierarchical_results'], "Tetrahedral geometry outlier")==2, "tst_chiral_validation json hierarchical output total number of Tetrahedral geometry outlier changed, now: "+str(test_utils.count_dict_values(ch_dict['hierarchical_results'], "Tetrahedral geometry outlier"))
  assert test_utils.count_dict_values(ch_dict['hierarchical_results'], "Pseudochiral naming error")==2, "tst_chiral_validation json hierarchical output total number of Pseudochiral naming error changed, now: "+str(test_utils.count_dict_values(ch_dict['hierarchical_results'], "Pseudochiral naming error"))
  assert test_utils.count_dict_values(ch_dict['hierarchical_results'], "Chiral handedness swap")==2, "tst_chiral_validation json hierarchical output total number of Chiral handedness swap changed, now: "+str(test_utils.count_dict_values(ch_dict['hierarchical_results'], "Chiral handedness swap"))
  summary_results_dict = ch_dict['summary_results']
  if "   1" in summary_results_dict:
    summary_results_1_dict = summary_results_dict["   1"]
    summary_results_2_dict = summary_results_dict["   2"]
  else:
    summary_results_1_dict = summary_results_dict["1"]
    summary_results_2_dict = summary_results_dict["2"]
  assert summary_results_1_dict["num_outliers"] == 3, "tst_chiral_validation json summary output total number of outliers changed, now: "+str(ch_dict['summary_results']["   1"]["num_outliers"])
  assert summary_results_1_dict["num_chiral_centers"] == 1, "tst_chiral_validation json summary output total number of true chiral centers changed, now: "+str(ch_dict['summary_results']["   1"]["num_chiral_centers"])
  assert summary_results_1_dict["num_total"] == 3, "tst_chiral_validation json summary output total number of tetrahedral changed, now: "+str(ch_dict['summary_results']["   1"]["num_total"])
  assert summary_results_2_dict["num_outliers"] == 3, "tst_chiral_validation json summary output model 2 total number of outliers changed, now: "+str(ch_dict['summary_results']["   1"]["num_outliers"])
  return ch_dict

if (__name__ == "__main__"):
  t0 = time.time()
  chiral_list = calculate_results()
  exercise_chiral_validation(chiral_list)
  ch_dict = exercise_chiral_json(chiral_list)
  convert_pdb_to_cif_for_pdb_str(locals(), chain_addition="LONGCHAIN", hetatm_name_addition = "", key_str="pdb_", print_new_string = False)
  chiral_list = calculate_results()
  ch_dict_cif = exercise_chiral_json(chiral_list)
  assert ch_dict['summary_results']['   1'] == ch_dict_cif['summary_results']['1'], "tst_chiral_validation summary results changed between pdb and cif version"
  assert ch_dict['summary_results']['   2'] == ch_dict_cif['summary_results']['2'], "tst_chiral_validation summary results changed between pdb and cif version"
  print("OK. Time: %8.3f"%(time.time()-t0))


 *******************************************************************************


 *******************************************************************************
mmtbx/validation/regression/tst_clashscore.py
from __future__ import absolute_import, division, print_function
from mmtbx.validation import clashscore
from iotbx import pdb
from libtbx.test_utils import approx_equal
from libtbx.utils import null_out
from libtbx.easy_pickle import loads, dumps
from iotbx.data_manager import DataManager
import libtbx.load_env
import time
import json

#protein
pdb_str_1 = """
MODEL        1
ATOM    556  N   LEU A  71      32.763  35.831  23.090  1.00 12.71           N
ATOM    557  CA  LEU A  71      34.145  35.472  23.481  1.00 16.06           C
ATOM    558  C   LEU A  71      34.239  35.353  24.979  1.00 18.09           C
ATOM    559  O   LEU A  71      33.707  36.197  25.728  1.00 19.26           O
ATOM    560  CB  LEU A  71      35.114  36.564  22.907  1.00 17.10           C
ATOM    561  CG  LEU A  71      35.926  35.979  21.737  1.00 19.37           C
ATOM    562  CD1 LEU A  71      35.003  35.084  20.920  1.00 17.51           C
ATOM    563  CD2 LEU A  71      36.533  37.087  20.917  1.00 19.57           C
ATOM    564  N   ARG A  72      34.930  34.384  25.451  1.00 21.47           N
ATOM    565  CA  ARG A  72      35.161  34.174  26.896  1.00 25.83           C
ATOM    566  C   ARG A  72      36.671  34.296  27.089  1.00 27.74           C
ATOM    567  O   ARG A  72      37.305  33.233  26.795  1.00 30.65           O
ATOM    568  CB  ARG A  72      34.717  32.760  27.286  1.00 28.49           C
ATOM    569  CG  ARG A  72      35.752  32.054  28.160  1.00 31.79           C
ATOM    570  CD  ARG A  72      35.612  30.577  28.044  1.00 34.05           C
ATOM    571  NE  ARG A  72      35.040  30.252  26.730  1.00 35.08           N
ATOM    572  CZ  ARG A  72      34.338  29.103  26.650  1.00 34.67           C
ATOM    573  NH1 ARG A  72      34.110  28.437  27.768  1.00 35.02           N
ATOM    574  NH2 ARG A  72      34.014  28.657  25.457  1.00 34.97           N
ATOM    575  N   LEU A  73      37.197  35.397  27.513  0.45 28.93           N
ATOM    576  CA  LEU A  73      38.668  35.502  27.680  0.45 30.76           C
ATOM    577  C   LEU A  73      39.076  34.931  29.031  0.45 32.18           C
ATOM    578  O   LEU A  73      38.297  34.946  29.996  0.45 32.31           O
ATOM    579  CB  LEU A  73      39.080  36.941  27.406  0.45 30.53           C
ATOM    580  CG  LEU A  73      39.502  37.340  26.002  0.45 30.16           C
ATOM    581  CD1 LEU A  73      38.684  36.647  24.923  0.45 29.57           C
ATOM    582  CD2 LEU A  73      39.337  38.854  25.862  0.45 29.11           C
ATOM    583  N   ARG A  74      40.294  34.412  29.045  0.45 33.82           N
ATOM    584  CA  ARG A  74      40.873  33.802  30.253  0.45 35.33           C
ATOM    585  C   ARG A  74      41.765  34.829  30.944  0.45 36.22           C
ATOM    586  O   ARG A  74      42.945  34.994  30.583  0.45 36.70           O
ATOM    587  CB  ARG A  74      41.651  32.529  29.923  0.45 36.91           C
ATOM    588  CG  ARG A  74      41.608  31.444  30.989  0.45 38.62           C
ATOM    589  CD  ARG A  74      41.896  30.080  30.456  0.45 39.75           C
ATOM    590  NE  ARG A  74      43.311  29.735  30.563  0.45 41.13           N
ATOM    591  CZ  ARG A  74      44.174  29.905  29.554  0.45 41.91           C
ATOM    592  NH1 ARG A  74      43.754  30.312  28.356  0.45 42.75           N
ATOM    593  NH2 ARG A  74      45.477  29.726  29.763  0.45 41.93           N
ENDMDL
END
"""

def exercise_clashscore():
  for cp in [True, False]:
    pdb_io = pdb.input(source_info=None, lines=pdb_str_1)
    pdb_hierarchy = pdb_io.construct_hierarchy()
    cs = clashscore.clashscore(
        pdb_hierarchy=pdb_hierarchy,
        fast = False,
        condensed_probe=cp,
        out=null_out())
    for unpickle in [False, True] :
      if (unpickle):
        cs = loads(dumps(cs))
      c_score = cs.get_clashscore()
      assert approx_equal(c_score, 35.29, eps=0.01)
      bad_clashes_list = cs.results
      assert ([ c.format_old() for c in bad_clashes_list ] ==
        [' A  72  ARG  HG2  A  72  ARG  O   :1.038',
        ' A  72  ARG  CG   A  72  ARG  O   :0.465',
        ' A  71  LEU  HA   A  71  LEU HD12 :0.446']), [ c.format_old() for c in bad_clashes_list ]

    #test nuclear distances
    cs = clashscore.clashscore(
        pdb_hierarchy=pdb_hierarchy,
        fast = False,
        condensed_probe=cp,
        nuclear=True)
    for unpickle in [False, True] :
      if (unpickle):
        cs = loads(dumps(cs))
      c_score = cs.get_clashscore()
      assert approx_equal(c_score, 58.82, eps=0.01)
      bad_clashes_list = cs.results
      assert ([ c.format_old() for c in bad_clashes_list ] ==
        [ ' A  72  ARG  HG2  A  72  ARG  O   :1.082',
          ' A  72  ARG  CG   A  72  ARG  O   :0.622',
          ' A  71  LEU  HA   A  71  LEU HD12 :0.535',
          ' A  72  ARG  HB3  A  72  ARG  HE  :0.475',
          ' A  72  ARG  HD3  A  72  ARG HH11 :0.451'])

    #test B factor cutoff
    cs = clashscore.clashscore(
        pdb_hierarchy=pdb_hierarchy,
        fast = False,
        condensed_probe=cp,
        b_factor_cutoff=40)
    for unpickle in [False, True] :
      if (unpickle):
        cs = loads(dumps(cs))
      c_score = cs.get_clashscore()
      assert approx_equal(c_score, 35.29, eps=0.01)
      c_score_b_cutoff = cs.get_clashscore_b_cutoff()
      assert approx_equal(c_score_b_cutoff, 39.47, eps=0.01)
      bad_clashes_list = cs.results
      assert ([ c.format_old() for c in bad_clashes_list ] ==
        [' A  72  ARG  HG2  A  72  ARG  O   :1.038',
        ' A  72  ARG  CG   A  72  ARG  O   :0.465',
        ' A  71  LEU  HA   A  71  LEU HD12 :0.446'])

def exercise_fast_clashscore():
  for fast_clash in [True, False]:
    pdb_io = pdb.input(source_info=None, lines=pdb_str_1)
    pdb_hierarchy = pdb_io.construct_hierarchy()
    cs = clashscore.clashscore(
        pdb_hierarchy=pdb_hierarchy,
        fast = fast_clash,
        condensed_probe=True,
        out=null_out())
    for unpickle in [False, True] :
      if (unpickle):
        cs = loads(dumps(cs))
      c_score = cs.get_clashscore()
      assert approx_equal(c_score, 35.29, eps=0.01)

    #test nuclear distances
    cs = clashscore.clashscore(
        pdb_hierarchy=pdb_hierarchy,
        fast = fast_clash,
        condensed_probe=True,
        nuclear=True)
    for unpickle in [False, True] :
      if (unpickle):
        cs = loads(dumps(cs))
      c_score = cs.get_clashscore()
      assert approx_equal(c_score, 58.82, eps=0.01)

def exercise_clashscore_json():
  dm = DataManager()
  #print(help(dm))
  dm.process_model_str("1",pdb_str_1)
  m = dm.get_model("1")
  cs = clashscore.clashscore(pdb_hierarchy=m.get_hierarchy())
  csjson_dict = json.loads(cs.as_JSON())
  #import pprint
  #pprint.pprint(csjson_dict)
  assert len(csjson_dict['flat_results']) == 3, "tst_clashscore json output not returning correct number of clashes"
  assert approx_equal(csjson_dict['flat_results'][0]["overlap"], -1.038), "tst_clashscore json output first overlap value changed"
  from mmtbx.validation import test_utils
  assert test_utils.count_dict_values(csjson_dict['hierarchical_results'], "bo")==3, "tst_clashscore json hierarchical output total number of clashes changed"
  assert csjson_dict['summary_results']["   1"]["num_clashes"] == 3, "tst_clashscore json summary output total number of clashes changed"
  assert approx_equal(csjson_dict['summary_results']["   1"]["clashscore"], 35.294117647058826), "tst_clashscore json summary output total number of clashes changed"

if (__name__ == "__main__"):
  if (not libtbx.env.has_module(name="probe")):
    print("Skipping exercise_clashscore(): probe not configured")
    print("OK")
  else:
    t0 = time.time()
    exercise_clashscore()
    exercise_fast_clashscore()
    exercise_clashscore_json()
    print("OK. Time: %8.3f"%(time.time()-t0))


 *******************************************************************************


 *******************************************************************************
mmtbx/validation/regression/tst_clashscore_2.py
from __future__ import absolute_import, division, print_function

import time
import libtbx.load_env

from mmtbx.command_line.molprobity import run as mp_run
from libtbx.utils import multi_out
from iotbx.cli_parser import CCTBXParser
from mmtbx.programs import clashscore

pdb_str_1 = """
ATOM      1  N   ASN A   1      12.388  -5.203  29.298  1.00 13.23           N
ATOM      2  CA  ASN A   1      12.398  -3.931  28.500  1.00  6.85           C
ATOM      3  CB  ASN A   1      13.493  -3.033  29.043  1.00  7.32           C
ATOM      4  CG  ASN A   1      13.414  -1.559  28.658  1.00  7.93           C
ATOM      5  OD1 ASN A   1      14.388  -0.782  28.842  1.00 10.99           O
ATOM      6  ND2 ASN A   1      12.315  -1.201  28.134  1.00 11.12           N
ATOM      7  C  AASN A   1      12.384  -4.463  27.091  0.45  6.81           C
ATOM      8  O  AASN A   1      12.645  -5.635  26.750  0.45  8.28           O
ATOM      9  C  BASN A   1      12.891  -4.205  27.064  0.55  9.54           C
ATOM     10  O  BASN A   1      14.004  -4.638  26.750  0.55 12.04           O
ATOM    180  N   GLU A  25      17.119   0.317  19.886  1.00  4.46           N
ATOM    181  CA  GLU A  25      17.951   0.073  21.066  1.00  4.05           C
ATOM    182  C   GLU A  25      17.083  -0.029  22.303  1.00  3.92           C
ATOM    183  O   GLU A  25      16.053   0.642  22.379  1.00  4.03           O
ATOM    184  CB  GLU A  25      18.993   1.197  21.334  1.00  5.58           C
ATOM    185  CG  GLU A  25      20.050   1.356  20.259  1.00  6.70           C
ATOM    186  CD AGLU A  25      21.014   2.440  20.770  0.47  7.87           C
ATOM    187  OE1AGLU A  25      22.134   2.188  21.301  0.47  9.47           O
ATOM    188  OE2AGLU A  25      20.526   3.611  20.664  0.47  7.81           O
ATOM    189  CD BGLU A  25      20.877   2.608  20.405  0.53  8.00           C
ATOM    190  OE1BGLU A  25      21.950   2.605  19.769  0.53  8.34           O
ATOM    191  OE2BGLU A  25      20.372   3.528  21.137  0.53  7.48           O
ATOM    192  N   VAL A  26      17.559  -0.774  23.291  1.00  4.51           N
ATOM    193  CA  VAL A  26      16.931  -0.812  24.603  1.00  4.35           C
ATOM    194  C   VAL A  26      17.394   0.427  25.384  1.00  4.53           C
ATOM    195  O   VAL A  26      18.565   0.603  25.717  1.00  6.63           O
ATOM    196  CB  VAL A  26      17.285  -2.120  25.322  1.00  6.28           C
ATOM    197  CG1 VAL A  26      16.710  -2.090  26.737  1.00  8.38           C
ATOM    198  CG2 VAL A  26      16.793  -3.328  24.541  1.00  7.99           C
ATOM    199  N   VAL A  27      16.430   1.306  25.641  1.00  4.09           N
ATOM    200  CA  VAL A  27      16.630   2.593  26.282  1.00  4.04           C
ATOM    201  C   VAL A  27      15.546   2.821  27.325  1.00  3.81           C
ATOM    202  O   VAL A  27      14.515   2.145  27.331  1.00  4.70           O
ATOM    203  CB  VAL A  27      16.645   3.734  25.238  1.00  4.32           C
ATOM    204  CG1 VAL A  27      17.867   3.681  24.325  1.00  5.54           C
ATOM    205  CG2 VAL A  27      15.361   3.732  24.400  1.00  4.82           C
ATOM    206  N   THR A  28      15.797   3.825  28.171  1.00  3.67           N
ATOM    207  CA  THR A  28      14.793   4.268  29.126  1.00  3.78           C
ATOM    208  C   THR A  28      14.774   5.796  29.120  1.00  3.63           C
ATOM    209  O   THR A  28      15.846   6.424  29.117  1.00  4.10           O
ATOM    210  CB  THR A  28      15.041   3.745  30.540  1.00  4.19           C
ATOM    211  OG1 THR A  28      16.342   4.127  31.000  1.00  4.27           O
ATOM    212  CG2 THR A  28      14.895   2.227  30.627  1.00  5.21           C
ATOM    213  N   PRO A  29      13.578   6.399  29.122  1.00  3.53           N
ATOM    214  CA  PRO A  29      12.262   5.767  29.064  1.00  3.65           C
ATOM    215  C   PRO A  29      11.992   5.133  27.695  1.00  3.56           C
ATOM    216  O   PRO A  29      12.719   5.286  26.720  1.00  5.32           O
ATOM    217  CB  PRO A  29      11.293   6.907  29.372  1.00  4.74           C
ATOM    218  CG  PRO A  29      12.017   8.133  28.814  1.00  4.83           C
ATOM    219  CD  PRO A  29      13.477   7.862  29.201  1.00  4.02           C
ATOM    220  N   MET A  30      10.875   4.415  27.628  1.00  4.82           N
ATOM    221  CA  MET A  30      10.472   3.706  26.429  1.00  3.92           C
ATOM    222  C   MET A  30       9.962   4.670  25.386  1.00  3.81           C
ATOM    223  O   MET A  30       9.205   5.595  25.690  1.00  4.84           O
ATOM    224  CB  MET A  30       9.331   2.734  26.807  1.00  4.57           C
ATOM    225  CG  MET A  30       8.873   1.861  25.654  1.00  4.88           C
ATOM    226  SD  MET A  30      10.130   0.613  25.308  1.00  5.54           S
ATOM    227  CE AMET A  30       9.590   0.158  23.659  0.80  5.92           C
ATOM    228  CE BMET A  30       9.842  -0.500  26.625  0.20 14.35           C
ATOM    229  N   GLY A  31      10.375   4.449  24.142  1.00  3.74           N
ATOM    230  CA  GLY A  31       9.846   5.184  23.024  1.00  4.22           C
ATOM    231  C   GLY A  31       8.887   4.357  22.184  1.00  3.46           C
ATOM    232  O   GLY A  31       8.350   3.328  22.642  1.00  3.89           O
ATOM    233  N   ILE A  32       8.655   4.794  20.950  1.00  3.51           N
ATOM    234  CA  ILE A  32       7.877   3.976  20.038  1.00  3.38           C
ATOM    235  C   ILE A  32       8.559   2.602  19.944  1.00  3.44           C
ATOM    236  O   ILE A  32       9.782   2.531  19.754  1.00  3.63           O
ATOM    237  CB  ILE A  32       7.807   4.651  18.658  1.00  3.57           C
ATOM    238  CG1 ILE A  32       7.052   5.977  18.750  1.00  4.18           C
ATOM    239  CG2 ILE A  32       7.139   3.697  17.669  1.00  4.59           C
ATOM    240  CD1 ILE A  32       7.076   6.794  17.464  1.00  4.77           C
ATOM    241  N   PRO A  33       7.817   1.492  20.034  1.00  3.75           N
ATOM    242  CA  PRO A  33       8.459   0.197  19.927  1.00  4.43           C
ATOM    243  C   PRO A  33       9.162   0.012  18.587  1.00  3.94           C
ATOM    244  O   PRO A  33       8.668   0.406  17.535  1.00  4.50           O
ATOM    245  CB  PRO A  33       7.289  -0.810  20.093  1.00  6.13           C
ATOM    246  CG  PRO A  33       6.309  -0.027  20.992  1.00  6.43           C
ATOM    247  CD  PRO A  33       6.394   1.383  20.414  1.00  4.84           C
ATOM    248  N   ALA A  34      10.310  -0.693  18.648  1.00  4.36           N
ATOM    249  CA  ALA A  34      11.123  -0.882  17.448  1.00  4.68           C
ATOM    250  C   ALA A  34      10.374  -1.543  16.299  1.00  4.72           C
ATOM    251  O   ALA A  34      10.729  -1.285  15.141  1.00  5.19           O
ATOM    252  CB  ALA A  34      12.370  -1.700  17.814  1.00  7.22           C
TER
HETATM  156  O   HOH A 173       9.659  -2.091  27.019  0.29  6.50           O
HETATM  191  O   HOH A 208      24.121   2.918  18.439  0.20  7.03           O
HETATM  217  O   HOH A 234      10.755   0.622  29.147  0.23  8.84           O
HETATM  230  O   HOH A 247      23.962   1.544  18.100  0.26  4.79           O
END
"""

def exercise_clashscore_molprob():
  """
  Make sure clashscore reported by mmtbx.clashscore and mmtbx.molprobity are the same
  This makes sure that occupancy modifications/cutoffs are the same if
  present. By default all q<0.3 are filtered out.
  """
  fname  = 'validation_tst_clashscore_2.pdb'
  with open(fname, 'w') as f:
    f.write(pdb_str_1)
  mp_result = mp_run(args=[fname])
  mp_cs = mp_result.validation.clashscore()

  logger = multi_out()
  parser = CCTBXParser(
    program_class=clashscore.Program,
    logger=logger)
  parser.parse_args([fname])
  task = clashscore.Program(
    parser.data_manager, parser.working_phil.extract(), logger=logger)
  task.validate()
  task.run()
  cs_cs = task.get_results().get_clashscore()

  assert mp_cs == cs_cs, "%f, %f" % (mp_cs, cs_cs)



if (__name__ == "__main__"):
  if (libtbx.env.has_module("reduce")
      and libtbx.env.has_module("probe")):
    t0 = time.time()
    exercise_clashscore_molprob()
    print("OK. Time: %8.3f"%(time.time()-t0))
  else:
    print("Skipping tst_clashscore_2(): probe or reduce not configured")



 *******************************************************************************


 *******************************************************************************
mmtbx/validation/regression/tst_do_flips_clashscore.py
from __future__ import absolute_import, division, print_function
from mmtbx.validation.clashscore import clashscore
import libtbx.load_env
import iotbx.pdb
import unittest
import os
from six.moves import map

__author__ = 'Youval'

test_pdb_str = '''\
CRYST1   77.977   77.977   66.800  90.00  90.00 120.00 P 31 2 1      6
SCALE1      0.012824  0.007404  0.000000        0.00000
SCALE2      0.000000  0.014808  0.000000        0.00000
SCALE3      0.000000  0.000000  0.014970        0.00000
ATOM    489  N   TRP A  96      27.616 -26.119   6.863  1.00 11.38           N
ATOM    490  CA  TRP A  96      28.969 -26.184   6.322  1.00 10.73           C
ATOM    491  C   TRP A  96      29.155 -25.427   5.023  1.00 10.54           C
ATOM    492  O   TRP A  96      28.250 -25.321   4.198  1.00 10.74           O
ATOM    493  CB  TRP A  96      29.451 -27.607   6.139  1.00 10.00           C
ATOM    494  CG  TRP A  96      29.781 -28.324   7.405  1.00  9.99           C
ATOM    495  CD1 TRP A  96      29.155 -28.212   8.613  1.00 11.22           C
ATOM    496  CD2 TRP A  96      30.773 -29.342   7.558  1.00 10.57           C
ATOM    497  NE1 TRP A  96      29.720 -29.094   9.512  1.00 11.57           N
ATOM    498  CE2 TRP A  96      30.713 -29.795   8.890  1.00 10.98           C
ATOM    499  CE3 TRP A  96      31.720 -29.904   6.696  1.00 10.60           C
ATOM    500  CZ2 TRP A  96      31.547 -30.793   9.373  1.00 12.52           C
ATOM    501  CZ3 TRP A  96      32.560 -30.881   7.186  1.00 12.06           C
ATOM    502  CH2 TRP A  96      32.479 -31.313   8.512  1.00 11.72           C
ATOM    503  N   THR A  97      30.383 -24.936   4.864  1.00 10.88           N
ATOM    504  CA  THR A  97      30.827 -24.204   3.693  1.00 10.65           C
ATOM    505  C   THR A  97      31.766 -25.066   2.858  1.00 10.84           C
ATOM    506  O   THR A  97      32.223 -26.130   3.296  1.00 10.69           O
ATOM    507  CB  THR A  97      31.602 -22.960   4.143  1.00 11.07           C
ATOM    508  OG1 THR A  97      32.717 -23.404   4.923  1.00 12.40           O
ATOM    509  CG2 THR A  97      30.701 -22.026   4.977  1.00 12.69           C
ATOM    510  N   ILE A  98      32.069 -24.587   1.655  1.00 10.75           N
ATOM    511  CA  ILE A  98      33.014 -25.241   0.774  1.00 10.93           C
ATOM    512  C   ILE A  98      34.349 -25.612   1.442  1.00 11.69           C
ATOM    513  O   ILE A  98      34.775 -26.756   1.341  1.00 11.92           O
ATOM    514  CB  ILE A  98      33.229 -24.393  -0.515  1.00 10.59           C
ATOM    515  CG1 ILE A  98      31.994 -24.515  -1.415  1.00 10.44           C
ATOM    516  CG2 ILE A  98      34.467 -24.832  -1.258  1.00 11.99           C
ATOM    517  CD1 ILE A  98      31.865 -23.451  -2.472  1.00 11.19           C
ATOM    518  N   PRO A  99      35.028 -24.654   2.103  1.00 12.86           N
ATOM    519  CA  PRO A  99      36.312 -25.036   2.697  1.00 12.90           C
ATOM    520  C   PRO A  99      36.208 -26.072   3.817  1.00 12.70           C
ATOM    521  O   PRO A  99      37.131 -26.870   4.015  1.00 13.09           O
ATOM    522  CB  PRO A  99      36.890 -23.697   3.193  1.00 13.38           C
ATOM    523  CG  PRO A  99      35.777 -22.758   3.263  1.00 13.70           C
ATOM    524  CD  PRO A  99      34.770 -23.207   2.227  1.00 13.18           C
ATOM    525  N   GLN A 100      35.081 -26.100   4.520  1.00 12.56           N
ATOM    526  CA  GLN A 100      34.892 -27.115   5.545  1.00 12.83           C
ATOM    527  C   GLN A 100      34.722 -28.505   4.925  1.00 12.30           C
ATOM    528  O   GLN A 100      35.279 -29.478   5.404  1.00 12.28           O
ATOM    529  CB  GLN A 100      33.705 -26.765   6.421  1.00 13.53           C
ATOM    530  CG  GLN A 100      33.883 -25.509   7.218  1.00 16.43           C
ATOM    531  CD  GLN A 100      32.648 -25.287   8.021  1.00 19.16           C
ATOM    532  NE2 GLN A 100      31.646 -24.831   7.508  1.00 17.90           O
ATOM    533  OE1 GLN A 100      32.675 -25.714   9.280  1.00 24.40           N
'''


class MyTestCase(unittest.TestCase):

  def setUp(self):
    self.file_to_delete = []
    # import files used in tests
    self.file_name = 'test_do_flips_clashscore.pdb'
    with open(self.file_name,'w') as f:
      f.write(test_pdb_str)
    self.file_to_delete.append(self.file_name)

  def test_identifying_and_addition_of_hydrogen(self):
    """ test identifying and addition of hydrogen """
    has_reduce = libtbx.env.has_module(name="reduce")
    if has_reduce:
      pdb_inp = iotbx.pdb.input(file_name=self.file_name)
      pdb_hierarchy = pdb_inp.construct_hierarchy()

      # don't do flip
      result = clashscore(
        pdb_hierarchy=pdb_hierarchy,
        keep_hydrogens=False)#verbose=True)

      self.assertAlmostEqual(result.clashscore,22.9885057471,places=4)

      # do flip
      result = clashscore(
        pdb_hierarchy=pdb_hierarchy,
        keep_hydrogens=False,#verbose=True)
        do_flips=True)

      self.assertEqual(result.clashscore,0)
    else:
      # Skip test if reduce is not present
      pass

  def tearDown(self):
    """ delete files created in during testing"""
    if self.file_to_delete:
      for fn in self.file_to_delete:
        if os.path.isfile(fn): os.remove(fn)

def run_selected_tests():
  """  Run selected tests

  1) List in "tests" the names of the particular test you want to run
  2) Comment out unittest.main()
  3) Un-comment unittest.TextTestRunner().run(run_selected_tests())
  """
  tests = ['test_something']
  suite = unittest.TestSuite(list(map(MyTestCase, tests)))
  return suite


if __name__ == '__main__':
  # use for individual tests
  # unittest.TextTestRunner().run(run_selected_tests())

  # Use to run all tests
  unittest.main(verbosity=0)


 *******************************************************************************


 *******************************************************************************
mmtbx/validation/regression/tst_experimental.py

# TODO more tests

from __future__ import absolute_import, division, print_function
from iotbx.pdb import hierarchy
from mmtbx.command_line import molprobity
import iotbx.pdb
from scitbx.array_family import flex
from libtbx.utils import null_out
import libtbx.load_env
import random

# Deuterium as ligand - formerly crashed real-space correlation
def exercise_01():
  pdb_raw = """\
CRYST1   10.000   15.000   10.000  90.00  90.00  90.00 P 1
ATOM   6407  N   GLY A 388      -0.783   9.368 -16.436  1.00 51.96           N
ATOM   6408  CA  GLY A 388      -0.227   9.888 -15.197  1.00 54.04           C
ATOM   6409  C   GLY A 388      -0.637  11.320 -14.897  1.00 55.86           C
ATOM   6410  O   GLY A 388      -1.728  11.738 -15.347  1.00 56.70           O
ATOM   6411  OXT GLY A 388       0.129  12.024 -14.203  1.00 56.98           O
ATOM   6412  D   GLY A 388      -0.460   9.727 -17.309  1.00 51.44           D
ATOM   6413  HA2 GLY A 388      -0.561   9.258 -14.385  1.00 54.07           H
ATOM   6414  HA3 GLY A 388       0.843   9.835 -15.243  1.00 54.13           H
TER    6415      GLY A 388
HETATM 6416  D   D8U A 401       2.236   5.695 -12.992  1.00 15.23           D
HETATM 6417  O   DOD A1001      -4.151   4.107 -16.592  1.00 13.40           O
HETATM 6418  D1  DOD A1001      -4.760   3.026 -11.326  1.00 15.45           D
HETATM 6419  D2  DOD A1001      -4.625   2.741 -13.845  1.00 14.81           D
"""
  random.seed(12345)
  flex.set_random_seed(12345)
  pdb_in = iotbx.pdb.input(source_info=None, lines=pdb_raw)
  xrs = pdb_in.xray_structure_simple()
  hierarchy = pdb_in.construct_hierarchy()
  hierarchy.atoms().reset_i_seq()
  open("tst_validate_experimental.pdb", "w").write(
    hierarchy.as_pdb_string(crystal_symmetry=xrs))
  f_calc =abs( xrs.structure_factors(d_min=2.0).f_calc())
  f_calc.set_observation_type_xray_amplitude()
  flags = f_calc.generate_r_free_flags()
  mtz = f_calc.as_mtz_dataset(column_root_label="F")
  mtz.add_miller_array(flags, column_root_label="FreeR_flag")
  mtz.mtz_object().write("tst_validate_experimental.mtz")
  args = [
    "tst_validate_experimental.pdb",
    "tst_validate_experimental.mtz",
  ]
  args.append("flags.clashscore=%s" % libtbx.env.has_module("probe"))
  result = molprobity.run(args=args,
    ignore_missing_modules=True,
    out=null_out()).validation
  assert result.real_space is not None
  ds = result.data_stats
  assert (ds.n_free > 0)

if (__name__ == "__main__"):
  exercise_01()
  print("OK")


 *******************************************************************************


 *******************************************************************************
mmtbx/validation/regression/tst_find_region_max_value.py
from __future__ import absolute_import, division, print_function

from mmtbx.validation.ramalyze import find_region_max_value
from mmtbx.validation.ramalyze import RAMA_GENERAL, RAMA_GLYCINE, RAMA_CISPRO, \
    RAMA_TRANSPRO, RAMA_PREPRO, RAMA_ILE_VAL

def exercise_1():
  # ((-63.0, -43.0), 1.0)
  print(find_region_max_value(RAMA_GENERAL, -100,0))
  assert find_region_max_value(RAMA_GENERAL, -100,0) == ((-63.0, -43.0), 1.0)
  assert find_region_max_value(RAMA_GENERAL, -120, 40) == ((-63.0, -43.0), 1.0)
  assert find_region_max_value(RAMA_GENERAL, -45, -55) == ((-63.0, -43.0), 1.0)
  assert find_region_max_value(RAMA_GENERAL, 0, 0) == None

  # ((-115.0, 131.0), 0.57068)
  assert find_region_max_value(RAMA_GENERAL, -80, 100) == ((-115.0, 131.0), 0.57068)
  assert find_region_max_value(RAMA_GENERAL, -160, 179) == ((-115.0, 131.0), 0.57068)
  assert find_region_max_value(RAMA_GENERAL, -80, 60) == ((-115.0, 131.0), 0.57068)
  assert find_region_max_value(RAMA_GENERAL, -120, -179) == ((-115.0, 131.0), 0.57068)

  # ((53.0, 43.0), 0.323004)
  assert find_region_max_value(RAMA_GENERAL, 60, 40) == ((53.0, 43.0), 0.323004)
  assert find_region_max_value(RAMA_GENERAL, 75, 0) == ((53.0, 43.0), 0.323004)
  assert find_region_max_value(RAMA_GENERAL, 60, 60) == ((53.0, 43.0), 0.323004)

  # ((53.0, -127.0), 0.0246619)
  assert find_region_max_value(RAMA_GENERAL, 53, -127) == ((53.0, -127.0), 0.0246619)
  assert find_region_max_value(RAMA_GENERAL, 54, -128) == ((53.0, -127.0), 0.0246619)
  assert find_region_max_value(RAMA_GENERAL, 53, -130) == ((53.0, -127.0), 0.0246619)

  print("==================================================")
  # ((-63.0, -41.0), 1.0)
  assert find_region_max_value(RAMA_GLYCINE, -80, -20) == ((-63.0, -41.0), 1.0)
  assert find_region_max_value(RAMA_GLYCINE, -80, 60) == ((-63.0, -41.0), 1.0)
  assert find_region_max_value(RAMA_GLYCINE, -80, 65) == ((-63.0, -41.0), 1.0)
  # ((63.0, 41.0), 1.0)
  assert find_region_max_value(RAMA_GLYCINE, 80, 0) == ((63.0, 41.0), 1.0)
  assert find_region_max_value(RAMA_GLYCINE, 80, -60) == ((63.0, 41.0), 1.0)
  # ((79.0, -173.0), 0.553852)
  assert find_region_max_value(RAMA_GLYCINE, 100, -160) == ((79.0, -173.0), 0.553852)
  assert find_region_max_value(RAMA_GLYCINE, 120, 160) == ((79.0, -173.0), 0.553852)
  assert find_region_max_value(RAMA_GLYCINE, -100, 140) == ((79.0, -173.0), 0.553852)
  assert find_region_max_value(RAMA_GLYCINE, -100, -160) == ((79.0, -173.0), 0.553852)

  print("==================================================")
  # ((-89.0, 5.0), 0.701149)
  assert find_region_max_value(RAMA_CISPRO, -80, 0) == ((-89.0, 5.0), 0.701149)
  assert find_region_max_value(RAMA_CISPRO, -60, -20) == ((-89.0, 5.0), 0.701149)
  assert find_region_max_value(RAMA_CISPRO, -100, 40) == ((-89.0, 5.0), 0.701149)
  # ((-75.0, 155.0), 1.0)
  assert find_region_max_value(RAMA_CISPRO, -80, 140) == ((-75.0, 155.0), 1.0)
  assert find_region_max_value(RAMA_CISPRO, -80, -178) == ((-75.0, 155.0), 1.0)

  print("==================================================")
  # ((-57.0, -37.0), 0.99566)
  assert find_region_max_value(RAMA_TRANSPRO, -60, -20) == ((-57.0, -37.0), 0.99566)
  assert find_region_max_value(RAMA_TRANSPRO, -80, 0) == ((-57.0, -37.0), 0.99566)
  assert find_region_max_value(RAMA_TRANSPRO, -40, -40) == ((-57.0, -37.0), 0.99566)
  # ((-81.0, 65.0), 0.0896269)
  assert find_region_max_value(RAMA_TRANSPRO, -80, 60) == ((-81.0, 65.0), 0.0896269)
  # ((-59.0, 143.0), 1.0)
  assert find_region_max_value(RAMA_TRANSPRO, -60, 140) == ((-59.0, 143.0), 1.0)
  assert find_region_max_value(RAMA_TRANSPRO, -80, -179) == ((-59.0, 143.0), 1.0)

  print("==================================================")
  # ((-70.1, 149.0), 0.9619998)
  assert find_region_max_value(RAMA_PREPRO, -120, 140) == ((-67.0, 147.0), 0.992025)
  assert find_region_max_value(RAMA_PREPRO, -120, 60) == ((-67.0, 147.0), 0.992025)
  assert find_region_max_value(RAMA_PREPRO, -160, 80) == ((-67.0, 147.0), 0.992025)
  assert find_region_max_value(RAMA_PREPRO, -160, 160) == ((-67.0, 147.0), 0.992025)
  # ((-57.0, -45.0), 1.0)
  assert find_region_max_value(RAMA_PREPRO, -60, -40) == ((-57.0, -45.0), 1.0)
  assert find_region_max_value(RAMA_PREPRO, -45, -55) == ((-57.0, -45.0), 1.0)
  # ((49.0, 57.0), 0.185259)
  assert find_region_max_value(RAMA_PREPRO, 49, 57) == ((49.0, 57.0), 0.185259)
  assert find_region_max_value(RAMA_PREPRO, 60, 60) == ((49.0, 57.0), 0.185259)
  assert find_region_max_value(RAMA_PREPRO, 55, 55) == ((49.0, 57.0), 0.185259)

  print("==================================================")
  # ((-63.0, -45.0), 1.0)
  assert find_region_max_value(RAMA_ILE_VAL, -60, -40) == ((-63.0, -45.0), 1.0)
  assert find_region_max_value(RAMA_ILE_VAL, -120, -60) == ((-63.0, -45.0), 1.0)
  assert find_region_max_value(RAMA_ILE_VAL, -120, 20) == ((-63.0, -45.0), 1.0)
  assert find_region_max_value(RAMA_ILE_VAL, -80, 0) == ((-63.0, -45.0), 1.0)
  # ((-121.0, 129.0), 0.76163)
  assert find_region_max_value(RAMA_ILE_VAL, -100, 140) == ((-121.0, 129.0), 0.76163)
  assert find_region_max_value(RAMA_ILE_VAL, -160, 140) == ((-121.0, 129.0), 0.76163)
  assert find_region_max_value(RAMA_ILE_VAL, -60, 140) == ((-121.0, 129.0), 0.76163)
  assert find_region_max_value(RAMA_ILE_VAL, -130, -179) == ((-121.0, 129.0), 0.76163)



if __name__ == '__main__':
  exercise_1()


 *******************************************************************************


 *******************************************************************************
mmtbx/validation/regression/tst_hydrogen_addition_clashscore.py
from __future__ import absolute_import, division, print_function
from mmtbx.validation.clashscore import check_and_add_hydrogen
import libtbx.load_env
import iotbx.pdb
import unittest
import os
from six.moves import map

__author__ = 'Youval'

test_pdb_str = '''\
CRYST1   80.020   97.150   49.850  90.00  90.00  90.00 C 2 2 21      8
SCALE1      0.012497  0.000000  0.000000        0.00000
SCALE2      0.000000  0.010293  0.000000        0.00000
SCALE3      0.000000  0.000000  0.020060        0.00000
ATOM      1  N   CYS A   1      41.272   7.927 -56.483  1.00 44.87           N
ATOM      2  CA  CYS A   1      40.571   9.126 -55.942  1.00 41.71           C
ATOM      3  C   CYS A   1      41.440  10.386 -55.943  1.00 38.08           C
ATOM      4  O   CYS A   1      41.256  11.281 -55.115  1.00 36.43           O
ATOM      5  CB  CYS A   1      40.055   8.833 -54.532  1.00 39.06           C
ATOM      6  SG  CYS A   1      41.291   8.128 -53.442  1.00 42.77           S
ATOM      7  N   ASP A   2      42.366  10.465 -56.895  1.00 41.37           N
ATOM      8  CA  ASP A   2      43.253  11.617 -57.014  1.00 43.37           C
ATOM      9  C   ASP A   2      42.583  12.834 -57.635  1.00 35.58           C
ATOM     10  O   ASP A   2      43.159  13.921 -57.670  1.00 38.51           O
ATOM     11  CB  ASP A   2      44.501  11.254 -57.812  1.00 55.07           C
ATOM     12  CG  ASP A   2      45.724  11.138 -56.938  1.00 64.10           C
ATOM     13  OD1 ASP A   2      45.964  10.034 -56.402  1.00 71.17           O
ATOM     14  OD2 ASP A   2      46.428  12.159 -56.767  1.00 62.17           O
ATOM     15  N   ALA A   3      41.370  12.640 -58.137  1.00 28.02           N
ATOM     16  CA  ALA A   3      40.609  13.720 -58.744  1.00 28.01           C
ATOM     17  C   ALA A   3      39.995  14.617 -57.670  1.00 29.12           C
ATOM     18  O   ALA A   3      39.612  15.753 -57.949  1.00 39.41           O
ATOM     19  CB  ALA A   3      39.515  13.146 -59.633  1.00 23.29           C
ATOM     20  N   PHE A   4      39.918  14.106 -56.444  1.00 23.62           N
ATOM     21  CA  PHE A   4      39.331  14.849 -55.336  1.00 12.37           C
ATOM     22  C   PHE A   4      40.343  15.632 -54.507  1.00 18.90           C
ATOM     23  O   PHE A   4      39.977  16.574 -53.802  1.00 20.87           O
ATOM     24  CB  PHE A   4      38.534  13.900 -54.442  1.00 10.74           C
ATOM     25  CG  PHE A   4      37.432  13.185 -55.164  1.00 10.86           C
ATOM     26  CD1 PHE A   4      36.180  13.772 -55.303  1.00 10.18           C
ATOM     27  CD2 PHE A   4      37.655  11.939 -55.736  1.00 14.14           C
ATOM     28  CE1 PHE A   4      35.166  13.131 -56.003  1.00 13.99           C
ATOM     29  CE2 PHE A   4      36.646  11.286 -56.441  1.00  9.42           C
ATOM     30  CZ  PHE A   4      35.401  11.882 -56.576  1.00 10.19           C
ATOM     31  N   VAL A   5      41.616  15.267 -54.629  1.00 15.08           N
ATOM     32  CA  VAL A   5      42.691  15.918 -53.884  1.00 18.34           C
ATOM     33  C   VAL A   5      42.775  17.426 -54.125  1.00 20.84           C
ATOM     34  O   VAL A   5      42.713  17.886 -55.265  1.00 38.92           O
ATOM     35  CB  VAL A   5      44.055  15.258 -54.208  1.00 21.65           C
ATOM     36  CG1 VAL A   5      45.191  15.981 -53.494  1.00 17.83           C
ATOM     37  CG2 VAL A   5      44.029  13.787 -53.800  1.00 25.16           C
ATOM     38  N   GLY A   6      42.891  18.187 -53.038  1.00 26.12           N
ATOM     39  CA  GLY A   6      42.993  19.635 -53.139  1.00 29.95           C
ATOM     40  C   GLY A   6      42.216  20.401 -52.082  1.00 26.34           C
ATOM     41  O   GLY A   6      41.670  19.815 -51.150  1.00 34.19           O
ATOM     42  N   THR A   7      42.194  21.723 -52.220  1.00 28.07           N
ATOM     43  CA  THR A   7      41.473  22.601 -51.301  1.00 22.77           C
ATOM     44  C   THR A   7      40.276  23.144 -52.072  1.00 21.63           C
ATOM     45  O   THR A   7      40.424  23.581 -53.213  1.00 30.40           O
ATOM     46  CB  THR A   7      42.360  23.765 -50.841  1.00 21.18           C
ATOM     47  OG1 THR A   7      43.614  23.245 -50.383  1.00 28.49           O
ATOM     48  CG2 THR A   7      41.698  24.521 -49.703  1.00 19.00           C
ATOM     49  N   TRP A   8      39.093  23.105 -51.459  1.00 19.58           N
ATOM     50  CA  TRP A   8      37.871  23.559 -52.125  1.00 22.39           C
ATOM     51  C   TRP A   8      37.059  24.548 -51.297  1.00 28.33           C
ATOM     52  O   TRP A   8      36.944  24.404 -50.082  1.00 36.01           O
ATOM     53  CB  TRP A   8      36.977  22.356 -52.476  1.00 25.27           C
ATOM     54  CG  TRP A   8      37.714  21.209 -53.124  1.00 28.71           C
ATOM     55  CD1 TRP A   8      38.477  20.265 -52.493  1.00 28.57           C
ATOM     56  CD2 TRP A   8      37.807  20.925 -54.526  1.00 25.39           C
ATOM     57  NE1 TRP A   8      39.050  19.422 -53.415  1.00 28.39           N
ATOM     58  CE2 TRP A   8      38.656  19.803 -54.670  1.00 23.95           C
ATOM     59  CE3 TRP A   8      37.263  21.510 -55.675  1.00 27.66           C
ATOM     60  CZ2 TRP A   8      38.973  19.258 -55.915  1.00 25.82           C
ATOM     61  CZ3 TRP A   8      37.578  20.965 -56.917  1.00 24.97           C
ATOM     62  CH2 TRP A   8      38.426  19.851 -57.023  1.00 25.28           C
ATOM     63  N   LYS A   9      36.490  25.543 -51.975  1.00 30.17           N
ATOM     64  CA  LYS A   9      35.653  26.559 -51.338  1.00 32.58           C
ATOM     65  C   LYS A   9      34.199  26.310 -51.718  1.00 28.46           C
ATOM     66  O   LYS A   9      33.906  25.943 -52.854  1.00 28.06           O
ATOM     67  CB  LYS A   9      36.023  27.969 -51.820  1.00 40.47           C
ATOM     68  CG  LYS A   9      37.324  28.552 -51.298  1.00 52.85           C
ATOM     69  CD  LYS A   9      37.391  30.038 -51.647  1.00 62.78           C
ATOM     70  CE  LYS A   9      38.673  30.705 -51.157  1.00 72.08           C
ATOM     71  NZ  LYS A   9      39.851  30.410 -52.023  1.00 74.54           N
ATOM     72  N   LEU A  10      33.290  26.516 -50.770  1.00 29.40           N
ATOM     73  CA  LEU A  10      31.866  26.349 -51.036  1.00 26.79           C
ATOM     74  C   LEU A  10      31.452  27.507 -51.944  1.00 35.56           C
ATOM     75  O   LEU A  10      31.912  28.637 -51.765  1.00 38.53           O
ATOM     76  CB  LEU A  10      31.073  26.419 -49.732  1.00 25.83           C
ATOM     77  CG  LEU A  10      29.558  26.286 -49.880  1.00 23.54           C
ATOM     78  CD1 LEU A  10      29.194  24.832 -50.107  1.00 22.85           C
ATOM     79  CD2 LEU A  10      28.870  26.812 -48.635  1.00 32.69           C
HETATM  901  N   NPH A 117      23.870  15.268 -50.490  1.00 25.06           N
HETATM  902  CA  NPH A 117      23.515  14.664 -49.210  1.00 22.94           C
HETATM  903  CB  NPH A 117      23.658  15.702 -48.113  1.00 21.44           C
HETATM  904  SG  NPH A 117      25.281  16.410 -47.839  1.00 31.29           S
HETATM  905  CD  NPH A 117      25.498  16.310 -46.059  0.50 33.70           C
HETATM  906  CE  NPH A 117      26.971  16.492 -45.820  0.50 39.92           C
HETATM  907  OZ  NPH A 117      27.815  15.348 -45.806  0.50 43.26           O
HETATM  908  NZ  NPH A 117      27.411  17.709 -45.649  0.50 43.87           N
HETATM  909  C6  NPH A 117      28.830  18.015 -45.436  0.50 51.14           C
HETATM  910  C5  NPH A 117      29.800  17.009 -45.411  0.50 51.26           C
HETATM  911  C6A NPH A 117      29.195  19.344 -45.262  0.50 52.54           C
HETATM  912  C4A NPH A 117      31.137  17.332 -45.219  0.50 52.42           C
HETATM  913  C10 NPH A 117      30.543  19.684 -45.064  0.50 54.23           C
HETATM  914  C7  NPH A 117      28.201  20.331 -45.288  0.50 53.28           C
HETATM  915  C4  NPH A 117      32.087  16.314 -45.202  0.50 53.40           C
HETATM  916  C1A NPH A 117      31.522  18.669 -45.046  0.50 55.19           C
HETATM  917  N10 NPH A 117      30.892  21.027 -44.889  0.50 53.87           N
HETATM  918  C8  NPH A 117      28.549  21.670 -45.111  0.50 54.83           C
HETATM  919  C3  NPH A 117      33.439  16.599 -45.020  0.50 53.96           C
HETATM  920  N1  NPH A 117      32.879  18.963 -44.861  0.50 57.78           N
HETATM  921  C9  NPH A 117      29.889  22.011 -44.911  0.50 55.29           C
HETATM  922  C2  NPH A 117      33.832  17.924 -44.852  0.50 55.79           C
HETATM  923  C   NPH A 117      22.061  14.206 -49.245  1.00 23.82           C
HETATM  924  O   NPH A 117      21.158  15.023 -49.423  1.00 24.62           O
ATOM    925  N   VAL A 118      21.831  12.913 -49.037  1.00 28.67           N
ATOM    926  CA  VAL A 118      20.474  12.371 -49.062  1.00 33.96           C
ATOM    927  C   VAL A 118      20.069  11.729 -47.737  1.00 36.17           C
ATOM    928  O   VAL A 118      20.854  11.018 -47.109  1.00 40.12           O
ATOM    929  CB  VAL A 118      20.297  11.336 -50.209  1.00 39.91           C
ATOM    930  CG1 VAL A 118      18.831  10.915 -50.336  1.00 38.68           C
ATOM    931  CG2 VAL A 118      20.791  11.918 -51.524  1.00 43.67           C
ATOM    932  N   MET A 119      18.829  11.986 -47.328  1.00 39.11           N
ATOM    933  CA  MET A 119      18.273  11.449 -46.092  1.00 39.84           C
ATOM    934  C   MET A 119      16.761  11.361 -46.256  1.00 45.51           C
ATOM    935  O   MET A 119      16.066  12.375 -46.173  1.00 45.08           O
ATOM    936  CB  MET A 119      18.616  12.370 -44.916  1.00 46.77           C
ATOM    937  CG  MET A 119      19.314  11.688 -43.740  1.00 45.80           C
ATOM    938  SD  MET A 119      18.225  10.980 -42.492  1.00 41.41           S
ATOM    939  CE  MET A 119      17.987   9.359 -43.118  1.00 44.09           C
ATOM    940  N   LYS A 120      16.265  10.152 -46.521  1.00 52.01           N
ATOM    941  CA  LYS A 120      14.834   9.908 -46.706  1.00 55.50           C
ATOM    942  C   LYS A 120      14.220  10.827 -47.764  1.00 61.07           C
ATOM    943  O   LYS A 120      13.324  11.621 -47.467  1.00 63.20           O
ATOM    944  CB  LYS A 120      14.079  10.073 -45.381  1.00 57.57           C
ATOM    945  CG  LYS A 120      14.393   9.026 -44.324  1.00 62.80           C
ATOM    946  CD  LYS A 120      13.804   9.426 -42.977  1.00 66.61           C
ATOM    947  CE  LYS A 120      14.422  10.730 -42.479  1.00 72.33           C
ATOM    948  NZ  LYS A 120      13.835  11.219 -41.198  1.00 69.78           N
TER    1036      ALA A 131
HETATM 1037  O   HOH A1001       8.647  20.222 -39.056  1.00 45.16           O
HETATM 1038  O   HOH A1002      16.907   6.512 -42.744  1.00 33.42           O
HETATM 1039  O   HOH A1003      28.827   2.276 -52.623  1.00 38.38           O
HETATM 1040  O   HOH A1004      30.966  10.844 -61.160  1.00 40.82           O
HETATM 1041  O   HOH A1005      30.838  16.415 -40.165  1.00 29.15           O
HETATM 1042  O   HOH A1006      31.573   1.965 -31.583  1.00 39.89           O
HETATM 1043  O   HOH A1007      37.321   3.217 -36.538  1.00 30.75           O
HETATM 1044  O   HOH A1008      38.663   3.050 -42.546  1.00 40.80           O
HETATM 1045  O   HOH A1009      38.830   9.609 -38.415  1.00 40.22           O
HETATM 1046  O   HOH A1010      14.636  22.139 -33.478  1.00 37.49           O
HETATM 1047  O   HOH A1011      16.639  25.103 -47.161  1.00 43.03           O
HETATM 1048  O   HOH A1012      17.561  26.508 -50.212  1.00 36.05           O
HETATM 1049  O   HOH A1013      20.199  26.017 -48.000  1.00 30.09           O
HETATM 1050  O   HOH A1014      19.269  19.390 -54.054  1.00 32.98           O
HETATM 1051  O   HOH A1015      24.341   3.887 -33.555  1.00 48.69           O
HETATM 1052  O   HOH A1016      24.806  10.616 -58.584  1.00 53.76           O
HETATM 1053  O   HOH A1017      29.937   3.471 -49.079  1.00 11.83           O
HETATM 1054  O   HOH A1018      31.421  10.991 -50.126  1.00 18.05           O
HETATM 1055  O   HOH A1019      35.725   3.882 -45.468  1.00  5.17           O
HETATM 1056  O   HOH A1020      35.293  11.651 -35.895  1.00 12.46           O
HETATM 1057  O   HOH A1021      36.784  16.657 -63.380  1.00 28.91           O
HETATM 1058  O   HOH A1022      38.577  25.715 -64.560  1.00 46.10           O
HETATM 1059  O   HOH A1023      39.943  20.367 -62.416  1.00 29.86           O
HETATM 1060  O   HOH A1024      42.053   3.459 -49.050  1.00 24.27           O
HETATM 1061  O   HOH A1026      43.187  22.656 -54.818  1.00 33.44           O
HETATM 1062  O   HOH A1027      47.201  12.336 -45.984  1.00 35.11           O
HETATM 1063  O   HOH A1028      53.460   7.293 -47.113  1.00 59.68           O
HETATM 1064  O   HOH A2001      21.683  15.390 -34.744  1.00 34.84           O
HETATM 1065  O   HOH A2002      33.838  15.714 -65.621  1.00 51.47           O
HETATM 1066  O   HOH A2003      36.315  13.744 -63.033  1.00 50.47           O
HETATM 1067  O   HOH A2004      47.315  14.827 -51.041  1.00 38.84           O
HETATM 1068  O   HOH A3001      18.141  28.190 -41.798  1.00 76.07           O
HETATM 1069  O   HOH A3002      26.887  17.479 -42.522  1.00 65.69           O
HETATM 1070  O   HOH A3003      27.587  21.810 -41.976  1.00 83.31           O
HETATM 1071  O   HOH A3004      29.928  13.873 -41.695  1.00 54.90           O
HETATM 1072  O   HOH A3005      32.870  14.371 -39.386  1.00 43.83           O
HETATM 1073  O   HOH A3006      33.981  15.263 -42.437  1.00 51.87           O
HETATM 1074  O   HOH A3007      49.639  13.800 -48.775  1.00 78.70           O
'''


class MyTestCase(unittest.TestCase):

  def setUp(self):
    self.file_to_delete = []
    # import files used in tests
    self.file_name = 'test_pdb_file.pdb'
    open(self.file_name,'w').write(test_pdb_str)
    self.file_to_delete.append(self.file_name)

  def test_identifying_and_addition_of_hydrogen(self):
    """ test identifying and addition of hydrogen """
    has_reduce = libtbx.env.has_module(name="reduce")
    if has_reduce:
      pdb_inp = iotbx.pdb.input(file_name=self.file_name)
      pdb_hierarchy = pdb_inp.construct_hierarchy()
      elements = pdb_hierarchy.atoms().extract_element()
      h_count_0 = elements.count(' H') + elements.count(' D')
      new_pdb_str,_ = check_and_add_hydrogen(
        file_name=self.file_name,
        verbose=False)

      pdb_inp = iotbx.pdb.input(source_info=None, lines=new_pdb_str)
      pdb_hierarchy = pdb_inp.construct_hierarchy()
      elements = pdb_hierarchy.atoms().extract_element()
      h_count_1 = elements.count(' H') + elements.count(' D')

      self.assertEqual(h_count_0,0)
      self.assertTrue(h_count_1>0)
    else:
      # Skip test if reduce is not present
      pass

  def tearDown(self):
    """ delete files created in during testing"""
    if self.file_to_delete:
      for fn in self.file_to_delete:
        if os.path.isfile(fn): os.remove(fn)

def run_selected_tests():
  """  Run selected tests

  1) List in "tests" the names of the particular test you want to run
  2) Comment out unittest.main()
  3) Un-comment unittest.TextTestRunner().run(run_selected_tests())
  """
  tests = ['test_something']
  suite = unittest.TestSuite(list(map(MyTestCase, tests)))
  return suite


if __name__ == '__main__':
  # use for individual tests
  # unittest.TextTestRunner().run(run_selected_tests())

  # Use to run all tests
  unittest.main(verbosity=0)


 *******************************************************************************
