

 *******************************************************************************
crys3d/regression/tst_websocket.py
from __future__ import absolute_import, division, print_function
from crys3d.hklviewer import jsview_3d
from crys3d.regression import tests_HKLviewer
import asyncio, os.path, websockets, socket, subprocess, time, threading


global socket_connected
socket_connected = False

def find_free_port():
  import socket
  s = socket.socket()
  s.bind(('', 0))      # Bind to a free port provided by the host.
  port = s.getsockname()[1]
  s.close()
  return port


async def handler(websocket, path):
# WS server example
  while True:
    name = await websocket.recv()
    print(f"{name}")
    greeting = f"Server got: {name}!"
    await websocket.send(greeting)
    print(greeting)
    if name=="Goodbye":
      global socket_connected
      await websocket.close()
      socket_connected = True
      return
    await asyncio.sleep(0.2)



websock_htmlstr = """
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head><meta charset="utf-8" /></head>
<body>

<div id='mytext'></div>
<div id='myservertext'></div>

<script>
document.getElementById('mytext').innerHTML = "Hoping to connect to localhost via websocket..."
var portnumber = %s;
//const mysocket = new WebSocket('ws://localhost:424242'); // testing connection failure
const mysocket = new WebSocket('ws://localhost:' + String(portnumber) + '/');
mysocket.addEventListener('open', function (event) {
  mysocket.send('Connection Established');
  mysocket.send('Goodbye');
  document.getElementById('mytext').innerHTML = "Websocket connection established to localhost:" + String(portnumber)
});
mysocket.onmessage = function(e) {
  document.getElementById('myservertext').innerHTML = e.data;
};
mysocket.onopen = function(e) { console.log(e)  };

</script>
</body>
</html>

"""

def write_and_run_websocktest_html(port):
  with open("websocket_test.html","w") as f:
    f.write(websock_htmlstr %port)
  myurl = "file:///" + os.path.abspath( "websocket_test.html" )
  myurl = myurl.replace("\\", "/")
  browserpath, webctrl = jsview_3d.get_browser_ctrl(tests_HKLviewer.browser)
  #assert webctrl.open(myurl)
  #os.system('"' + browserpath + '" ' + myurl + ' &')
  # ensure websockets server starts before the webbrowser loads page with javascript websocket client
  time.sleep(5)
  subprocess.run('"' + browserpath + '" ' + myurl + ' &', shell=True,
                 capture_output=False, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)


async def closing_time():
  dt = 0.2; t=0; maxtime = 60
  while t < maxtime:
    await asyncio.sleep(dt)
    t += dt
    global socket_connected
    if socket_connected:
      asyncio.get_event_loop().call_soon(asyncio.get_event_loop().stop)
      return
  print('Timed out trying to connect to webbrowser. Waited for %s seconds' %maxtime)
  asyncio.get_event_loop().call_soon(asyncio.get_event_loop().stop)


async def startserver(port):
  async with websockets.legacy.server.serve(handler, "localhost", port):
    print("in startserver")
    #await asyncio.Future()
    #await asyncio.sleep(10)

if __name__ == '__main__':
  port = find_free_port()
  thrd = threading.Thread(target = write_and_run_websocktest_html, args=(port,) )
  thrd.daemon = True
  thrd.start()
  print("Websockets server on localhost port %s waiting for browser connection." %port)
  tasks = asyncio.gather(
    #startserver(port),
    websockets.legacy.server.serve(handler, "localhost", port),
    closing_time()
  )
  evl = asyncio.get_event_loop()
  evl.run_until_complete(tasks)
  evl.run_forever()
  assert socket_connected
  print("OK")


 *******************************************************************************


 *******************************************************************************
crys3d/reverse_selection.py
from __future__ import absolute_import, division, print_function
# XXX: internal data for mouse selections in wx_selection_editor.py

from libtbx.utils import Sorry
from libtbx import adopt_init_args
import re
import six
from six.moves import range

single_quote = re.compile(r"'")

class chain_selection_info (object) :
  def __init__ (self, chain_id) :
    adopt_init_args(self, locals())
    self.resseqs = set()
    self.resseqs_by_altloc = {}
    self.remove_resseqs = set()
    self.remove_resseqs_by_altloc = {}

  def add_range (self, start, end, altloc=None) :
    resseqs = set([ x for x in range(start, end+1)])
    if altloc is None :
      if len(self.remove_resseqs) != 0 :
        self.remove_resseqs -= resseqs
      else :
        self.resseqs |= resseqs
    else :
      remove_resseqs = self.remove_resseqs_by_altloc.get(altloc, set())
      if len(remove_resseqs) != 0 :
        remove_resseqs -= resseqs
        if len(remove_resseqs) == 0 :
          self.remove_resseqs_by_altloc.pop(altloc)
        else :
          self.remove_resseqs_by_altloc[altloc] = remove_resseqs
      else :
        old_resseqs = self.resseqs_by_altloc.get(altloc, set())
        old_resseqs |= resseqs
        self.resseqs_by_altloc[altloc] = old_resseqs

  def remove_range (self, start, end, altloc=None) :
    resseqs = set([ x for x in range(start, end+1)])
    if altloc is None :
      if len(self.resseqs) != 0 :
        self.resseqs -= resseqs
      else :
        self.remove_resseqs |= resseqs
    else :
      selected_resseqs = self.resseqs_by_altloc.get(altloc, set())
      if len(selected_resseqs) > 0 :
        selected_resseqs -= resseqs
        if len(selected_resseqs) == 0 :
          self.resseqs_by_altloc.pop(altloc)
        else :
          self.resseqs_by_altloc[altloc] = selected_resseqs
      else :
        old_resseqs = self.remove_resseqs_by_altloc.get(altloc, set())
        old_resseqs |= resseqs
        self.remove_resseqs_by_altloc[altloc] = old_resseqs
    if (len(self.resseqs) == 0 and len(self.remove_resseqs) == 0 and
        len(self.resseqs_by_altloc) == 0 and
        len(self.remove_resseqs_by_altloc) == 0) :
      return True
    return False

  def __str__ (self) :
    sele_str = "chain '%s'" % self.chain_id
    clauses = []
    if len(self.resseqs) > 0 :
      ranges = get_set_ranges(self.resseqs)
      clauses.extend(assemble_resseq_ranges(ranges))
    if len(self.resseqs_by_altloc) > 0 :
      for altloc in self.resseqs_by_altloc :
        ranges = get_set_ranges(self.resseqs_by_altloc[altloc])
        clauses.extend(assemble_resseq_ranges_with_altloc(ranges, altloc))
    if len(clauses) > 0 :
      sele_str += " and ((" + ") or (".join(clauses) + "))"
    clauses = []
    if len(self.remove_resseqs) > 0 :
      ranges = get_set_ranges(self.remove_resseqs)
      clauses.extend(assemble_resseq_ranges(ranges))
    if len(self.remove_resseqs_by_altloc) > 0 :
      for altloc in self.remove_resseqs_by_altloc :
        ranges = get_set_ranges(self.remove_resseqs_by_altloc[altloc])
        clauses.extend(assemble_resseq_ranges_with_altloc(ranges, altloc))
    if len(clauses) > 0 :
      sele_str += " and not ((" + ") or (".join(clauses) + "))"
    return sele_str

class residue_selection_info (object) :
  def __init__ (self, chain_id, resid, altloc=None) :
    adopt_init_args(self, locals())

  def __str__ (self) :
    if self.altloc is None :
      return "chain '%s' and resid '%s'" % (self.chain_id, self.resid)
    else :
      return "chain '%s' and resid '%s' and altloc '%s'" % (self.chain_id,
        self.resid, self.altloc)

class atom_selection_info (object) :
  def __init__ (self, i_seq, atom) : #chain_id, resid, atom_name, altloc) :
    adopt_init_args(self, locals())

  def __str__ (self) :
    atom = self.atom
    altloc = atom.altloc
    if altloc == "" :
      altloc = " "
    return ("chain '%s' and resid '%s' and name '%s' and altloc '%s'" %
      (atom.chain_id, atom.resid(), single_quote.sub("\\\'",atom.name),
       altloc))

#-----------------------------------------------------------------------
class mouse_selection_manager (object) :
  def __init__ (self) :
    self.saved_selection = "none"
    self.selection_string = "none"
    self.flag_overwrite_mode = False
    self._selection_callback = None
    self.start_i_seq = None
    self.end_i_seq = None

  def set_overwrite_mode (self, overwrite=True) :
    self.flag_overwrite_mode = overwrite

  def selection_callback (self, selection_string, atom_selection) :
    if self._selection_callback is not None :
      self._selection_callback(selection_string, atom_selection)

  def set_selection_callback (self, callback) :
    assert hasattr(callback, "__call__") or callback is None
    self._selection_callback = callback

  def set_mmtbx_selection_function (self, mmtbx_selection_function) :
    self.mmtbx_selection_function = mmtbx_selection_function

  def update_selection_handlers (self, pdb_hierarchy,
      mmtbx_selection_function, special_position_settings=None) :
    from scitbx.array_family import flex
    self.mmtbx_selection_function = mmtbx_selection_function
    self.selection_cache = pdb_hierarchy.atom_selection_cache(
      special_position_settings=special_position_settings)
    self.atom_selection = flex.bool()
    #--- XXX: for testing only
    if not hasattr(self, "atom_index") :
      self.atom_index = []
      for atom in pdb_hierarchy.atoms_with_labels() :
        self.atom_index.append(atom)
    if not hasattr(self, "pdb_hierarchy") :
      self.pdb_hierarchy = pdb_hierarchy
    #---
    self.clear_selection()

  def clear_selection (self, apply_empty=True) :
    self.selected_chains = {}
    self.deselected_chains = {}
    self.selected_atoms = []
    self.deselected_atoms = []
    self.selected_residues = []
    self.deselected_residues = []
    self.selected_pair = []
    if apply_empty :
      self.apply_selection("none") #self.saved_selection)

  def selection_size (self) :
    return self.selection_i_seqs.size()

  def apply_selection (self, selection_string) :
    if selection_string is None or selection_string == "" :
      selection_string = "none"
    atom_selection = self.get_atom_selection(selection_string)
    error = False
    if atom_selection is None :
      error = True
      self.selection_string = "none"
      atom_selection = self.selection_cache.selection("none")
    else :
      # reduce selection string to most grouped format
      if (hasattr(self, 'pdb_hierarchy')):
        from iotbx.pdb.atom_selection import selection_string_from_selection
        # reducing selection string will fail if the selection has alternate
        # conformations, so just keep fully expanded form.
        try:
          selection_string = selection_string_from_selection(
            self.pdb_hierarchy, atom_selection)
        except Sorry:
          pass
      self.selection_string = selection_string
    self.atom_selection = atom_selection
    self.selection_i_seqs = atom_selection.iselection()
    if self.selection_callback is not None :
      self.selection_callback(self.selection_string, self.atom_selection)
    if error : # wait until the end to do this
      raise Sorry("Invalid selection '%s'."%selection_string)

  def get_atom_selection (self, selection_string) :
    try :
      if self.mmtbx_selection_function is not None :
        atom_selection = self.mmtbx_selection_function(
          string=selection_string,
          cache=self.selection_cache)
      else :
        atom_selection = self.selection_cache.selection(selection_string)
    except KeyboardInterrupt :
      raise
    except Exception as e :
      raise
      atom_selection =None
    return atom_selection

  def revert_selection (self) :
    self.apply_selection(self.saved_selection)

  def set_initial_selection (self, selection_string) :
    self.saved_selection = selection_string
    self.apply_selection(selection_string)

  def reset_range_selection (self) :
    self.start_i_seq = None

  def start_range_selection (self, i_seq) :
    if self.flag_overwrite_mode :
      self.clear_selection(apply_empty=False)
    self.start_i_seq = i_seq

  def end_range_selection (self, i_seq, deselect, ignore_altloc) :
    success = False
    if self.start_i_seq is not None :
      start_atom = self.atom_index[self.start_i_seq]
      end_atom = self.atom_index[i_seq]
      if (start_atom.chain_id == end_atom.chain_id and
          (ignore_altloc or start_atom.altloc == end_atom.altloc)) :
        chain_id = start_atom.chain_id
        if self.flag_overwrite_mode and not deselect :
          if chain_id in self.selected_chains :
            del self.selected_chains[chain_id]
        altloc = None
        if not ignore_altloc :
          altloc = start_atom.altloc
        start_range = start_atom.resseq_as_int()
        end_range = end_atom.resseq_as_int()
        if start_range > end_range :
          start_range = end_atom.resseq_as_int()
          end_range = start_atom.resseq_as_int()
        chain_info = self.selected_chains.get(chain_id)
        if deselect :
          deselect_str = "chain '%s' and resseq %d:%d" % (chain_id,
            start_range, end_range)
          if altloc is not None :
            deselect_str += " and altloc '%s'" % altloc
          if chain_info is not None :
            remove_chain = chain_info.remove_range(start_range, end_range,
              altloc)
            if remove_chain :
              self.selected_chains.pop(chain_id)
            success = True
          deselection = self.get_atom_selection(deselect_str)
          self.remove_redundant_residues(deselection, self.selected_residues)
          self.remove_redundant_atoms(deselection, self.selected_atoms)
          self.remove_redundant_residues(deselection.__invert__(),
            self.deselected_residues)
          self.remove_redundant_atoms(deselection.__invert__(),
            self.deselected_atoms)
        else :
          if chain_info is None :
            chain_info = chain_selection_info(chain_id)
          chain_info.add_range(start_range, end_range, altloc)
          self.selected_chains[chain_id] = chain_info
          chain_sel = self.selection_cache.selection(str(chain_info))
          self.remove_redundant_residues(chain_sel, self.selected_residues)
          self.remove_redundant_atoms(chain_sel, self.selected_atoms)
          success = True
        self.construct_selection()
    self.reset_range_selection()
    return success

  def toggle_chain_selection (self, i_seq) :
    atom = self.atom_index[i_seq]
    chain_id = atom.chain_id
    if chain_id in self.selected_chains :
      chain_info = self.selected_chains.pop(chain_id)
      chain_sel = self.selection_cache.selection(str(chain_info))
      self.remove_redundant_residues(chain_sel, self.deselected_residues)
      self.remove_redundant_atoms(chain_sel, self.deselected_atoms)
    else :
      chain_info = chain_selection_info(chain_id)
      self.selected_chains[chain_id] = chain_info
      chain_sel = self.selection_cache.selection(str(chain_info))
      self.remove_redundant_residues(chain_sel, self.selected_residues)
      self.remove_redundant_atoms(chain_sel, self.selected_atoms)
    self.construct_selection()

  def remove_redundant_residues (self, main_selection, residue_list) :
    i = 0
    while i < len(residue_list) :
      residue_info = residue_list[i]
      resi_sel = self.selection_cache.selection(str(residue_info))
      if main_selection.is_super_set(resi_sel) :
        residue_list.pop(i)
      else :
        i += 1

  def remove_redundant_atoms (self, main_selection, atom_list) :
    i = 0
    while i < len(atom_list) :
      i_seq = atom_list[i]
      if main_selection[i_seq] :
        atom_list.pop(i)
      else :
        i += 1

  def toggle_residue_selection (self, i_seq, ignore_altloc=True) :
    atom = self.atom_index[i_seq]
    if ignore_altloc :
      resi_info = residue_selection_info(atom.chain_id, atom.resid())
    else :
      resi_info = residue_selection_info(atom.chain_id, atom.resid(),
        atom.altloc)
    resi_sel = self.selection_cache.selection(str(resi_info))
    if self.flag_overwrite_mode :
      self.clear_selection(apply_empty=False)
      if not self.atom_selection.all_eq(resi_sel) :
        self.selected_residues.append(resi_info)
    else :
      if self.atom_selection.is_super_set(resi_sel) :
        self.deselected_residues.append(resi_info)
        self.remove_redundant_residues(resi_sel, self.selected_residues)
      else :
        self.selected_residues.append(resi_info)
        self.remove_redundant_residues(resi_sel, self.deselected_residues)
    self.remove_redundant_atoms(resi_sel, self.selected_atoms)
    self.remove_redundant_atoms(resi_sel, self.deselected_atoms)
    self.construct_selection()

  def select_pair (self, i_seq, selection_type="residue",
      allow_duplicate=False) :
    if len(self.selected_pair) == 2 :
      self.selected_pair = []
    atom = self.atom_index[i_seq]
    if selection_type == "residue" :
      selected_object = residue_selection_info(atom.chain_id, atom.resid())
    else :
      selected_object = atom_selection_info(i_seq, atom)
    n_selected = len(self.selected_pair)
    if n_selected == 1 and not allow_duplicate :
      # force items to be unique (no self-pairing)
      if str(selected_object) == str(self.selected_pair[0]) :
        print("skipping")
        return
    self.selected_pair.append(selected_object)
    self.construct_selection()

  def get_pair_selections (self) :
    pass

  def toggle_atom_selection (self, i_seq) :
    atom = self.atom_index[i_seq]
    if self.atom_selection[i_seq] : #and not i_seq in self.deselected_atoms :
      self.deselected_atoms.append(i_seq)
      if i_seq in self.selected_atoms :
        self.selected_atoms.remove(i_seq)
    elif not i_seq in self.selected_atoms :
      self.selected_atoms.append(i_seq)
      if i_seq in self.deselected_atoms :
        self.deselected_atoms.remove(i_seq)
    self.construct_selection()

  def select_single_residue (self, i_seq) :
    atom = self.atom_index[i_seq]
    resi_info = residue_selection_info(atom.chain_id, atom.resid())
    resi_sel = self.selection_cache.selection(str(resi_info))
    is_current_selection = ((resi_sel==self.atom_selection).count(False) == 0)
    self.clear_selection()
    if is_current_selection :
      return False
    self.toggle_residue_selection(i_seq)

  def select_single_atom (self, i_seq) :
    atom = self.atom_index[i_seq]
    self.clear_selection()
    self.toggle_atom_selection(i_seq)

  def construct_selection (self) :
    final_selection = ""
    # Part 1: stuff we want
    clauses = []
    for chain_id, chain_info in six.iteritems(self.selected_chains) :
      clauses.append(str(chain_info))
    chains_selection_str = assemble_selection_clauses(clauses)
    selection1 = self.get_atom_selection(chains_selection_str)
    deselection1 = selection1.__invert__()
    self.remove_redundant_residues(selection1, self.selected_residues)
    self.remove_redundant_residues(deselection1, self.deselected_residues)
    for residue_info in self.selected_residues :
      residue_selection_str = str(residue_info)
      clauses.append(residue_selection_str)
    chains_and_resi_sel_str = assemble_selection_clauses(clauses)
    selection2 = self.get_atom_selection(chains_and_resi_sel_str)
    deselection2 = selection2.__invert__()
    self.remove_redundant_atoms(selection2, self.selected_atoms)
    self.remove_redundant_atoms(deselection2, self.deselected_atoms)
    for other_info in self.selected_pair :
      clauses.append(str(other_info))
    for i_seq in self.selected_atoms :
      atom_info = atom_selection_info(i_seq, self.atom_index[i_seq])
      clauses.append(str(atom_info))
    positive_selection = assemble_selection_clauses(clauses)
    # Part 2: stuff we don't want
    clauses = []
    for residue_info in self.deselected_residues :
      residue_selection_str = str(residue_info)
      clauses.append(residue_selection_str)
    for i_seq in self.deselected_atoms :
      atom_info = atom_selection_info(i_seq, self.atom_index[i_seq])
      clauses.append(str(atom_info))
    negative_selection = assemble_selection_clauses(clauses)
    # assemble final selection
    if positive_selection != "" :
      if negative_selection != "" :
        final_selection = "(%s) and not (%s)" % (positive_selection,
                                                 negative_selection)
      else :
        final_selection = positive_selection
    else :
      final_selection = "none"
    self.apply_selection(final_selection)

def assemble_selection_clauses (clauses) :
  if len(clauses) == 0 :
    return ""
  elif len(clauses) == 1 : # not necessary, but looks nicer
    return clauses[0]
  else :
    return "(" + ") or (".join(clauses) + ")"

def get_set_ranges (residue_set) :
  resseqs = sorted(residue_set)
  previous_resseq = resseqs[0]
  ranges = []
  current_start = resseqs[0]
  for resseq in resseqs[1:-1] :
    if resseq > (previous_resseq + 1) :
      ranges.append((current_start, previous_resseq))
      current_start = resseq
    previous_resseq = resseq
  ranges.append((current_start, resseqs[-1]))
  return ranges

def assemble_resseq_ranges (ranges) :
  clauses = []
  for (start, end) in ranges :
    if start == end :
      clauses.append("resseq %d" % start)
    else :
      clauses.append("resseq %d:%d" % (start, end))
  return clauses

def assemble_resseq_ranges_with_altloc (ranges, altloc) :
  clauses = []
  for (start, end) in ranges :
    if start == end :
      clauses.append("resseq %d and altloc '%s'" % (start, altloc))
    else :
      clauses.append("resseq %d:%d and altloc '%s'" % (start,end,altloc))
  return clauses

########################################################################
def exercise () :
  from mmtbx.monomer_library import pdb_interpretation
  import cStringIO
  open("tmp.pdb", "w").write("""\
CRYST1   50.800   50.800  155.300  90.00  90.00  90.00 P 43 21 2     8
ATOM      4  N   SER A   1       8.753  29.755  61.685  1.00 49.13
ATOM      5  CA  SER A   1       9.242  30.200  62.974  1.00 46.62
ANISOU    5  CA  SER A   1    343    490   2719    -45   -169    617
ATOM      6  C   SER A   1      10.453  29.500  63.579  1.00 41.99
ATOM      7  O   SER A   1      10.593  29.607  64.814  1.00 43.24
ANISOU    7  O   SER A   1    343    490   2719    -45   -169    617
ATOM      8  CB  SER A   1       8.052  30.189  63.974  1.00 53.00
ATOM      9  OG  SER A   1       7.294  31.409  63.930  1.00 57.79
ATOM     10  N   ARG A   2      11.360  28.819  62.827  1.00 36.48
ATOM     11  CA  ARG A   2      12.548  28.316  63.532  1.00 30.20
ATOM     12  C   ARG A   2      13.502  29.501  63.500  1.00 25.54
ATOM     13  O   ARG A   2      13.730  30.037  62.407  1.00 23.86
ATOM     14  CB  ARG A   2      13.241  27.119  62.861  1.00 27.44
ATOM     15  CG  ARG A   2      12.412  25.849  62.964  1.00 23.66
ATOM     16  CD  ARG A   2      13.267  24.651  63.266  1.00 23.98
ATOM     17  NE  ARG A   2      13.948  24.115  62.135  1.00 22.71
ATOM     18  CZ  ARG A   2      15.114  23.487  62.201  1.00 21.38
ATOM     19  NH1 ARG A   2      15.845  23.331  63.301  1.00 19.34
ATOM     20  NH2 ARG A   2      15.575  23.030  61.051  1.00 26.66
ATOM     21  N   PRO A   3J     13.947  29.997  64.680  1.00 22.94
ATOM     22  CA  PRO A   3J     14.902  31.100  64.827  1.00 20.19
ATOM     23  C   PRO A   3J     16.195  30.718  64.086  1.00 18.44
ATOM     24  O   PRO A   3J     16.545  29.521  64.086  1.00 19.76
ATOM     25  CB  PRO A   3J     15.133  31.218  66.313  1.00 19.17
ATOM     26  CG  PRO A   3J     14.065  30.364  66.951  1.00 15.12
ATOM     27  CD  PRO A   3J     13.816  29.289  65.966  1.00 19.56
ATOM     28  N  AILE A   4      16.953  31.648  63.512  1.00 15.29
ATOM     29  CA AILE A   4      18.243  31.372  62.859  1.00 14.32
ATOM     30  C  AILE A   4      19.233  32.112  63.743  1.00 13.54
ATOM     31  O  AILE A   4      19.105  33.315  64.009  1.00 11.84
ATOM     32  CB AILE A   4      18.298  31.951  61.406  1.00 13.62
ATOM     33  CG1AILE A   4      17.157  31.300  60.620  1.00 18.39
ATOM     34  CG2AILE A   4      19.661  31.747  60.743  1.00 13.64
ATOM     35  CD1AILE A   4      16.879  32.102  59.355  1.00 16.69
ATOM     28  N  BILE A   4      16.953  31.648  63.512  1.00 15.29
ATOM     29  CA BILE A   4      18.243  31.372  62.859  1.00 14.32
ATOM     30  C  BILE A   4      19.233  32.112  63.743  1.00 13.54
ATOM     31  O  BILE A   4      19.105  33.315  64.009  1.00 11.84
ATOM     32  CB BILE A   4      18.298  31.951  61.406  1.00 13.62
ATOM     33  CG1BILE A   4      17.157  31.300  60.620  1.00 18.39
ATOM     34  CG2BILE A   4      19.661  31.747  60.743  1.00 13.64
ATOM1200035  CD1BILE A   4      16.879  32.102  59.355  1.00 16.69
HETATM 1475  S   SO4 S 188      31.424  42.923  60.396  1.00 55.69           S4+
HETATM 1476  O1  SO4 S 188      31.631  41.513  60.336  1.00 59.84           O1-
HETATM 1477  O2  SO4 S 188      32.533  43.699  59.932  1.00 49.98           O1-
HETATM 1478  O3  SO4 S 188      31.128  43.217  61.738  1.00 59.44           O1-
HETATM 1479  O4  SO4 S 188      30.353  43.201  59.539  1.00 60.54           O1-
HETATM 1480  O   HOH W 200      29.478  23.354  61.364  1.00  8.67      WATE
END""")
  out = cStringIO.StringIO()
  processed_pdb_file = pdb_interpretation.run(args=["tmp.pdb"], log=out)
  m = mouse_selection_manager()
  pdb_hierarchy = processed_pdb_file.all_chain_proxies.pdb_hierarchy
  pdb_hierarchy.atoms().reset_i_seq()
  m.update_selection_handlers(
    pdb_hierarchy=pdb_hierarchy,
    mmtbx_selection_function=processed_pdb_file.all_chain_proxies.selection)
  assert m.selection_size() == 0
  m.apply_selection("chain A")
  assert m.selection_size() == 40
  m.clear_selection()
  m.toggle_chain_selection(5)
  assert m.selection_size() == 40
  m.toggle_residue_selection(10)
  assert m.selection_size() == 29
  m.toggle_atom_selection(10) # XXX: doesn't work!
  assert m.selection_size() == 29
  m.toggle_atom_selection(20)
  assert m.selection_size() == 28

  from iotbx import pdb
  from scitbx.array_family import flex
  pdb_hierarchy = pdb.input(source_info=None, lines=flex.split_lines("""\
HETATM 4049  O   HOH W   1       2.954  13.042  11.632  1.00 37.53           O
HETATM 4050  O   HOH W   2       5.539  14.595  10.951  1.00 31.25           O
HETATM 4051  O   HOH W   3      -2.971  14.661  14.669  1.00 38.68           O
HETATM 4052  O   HOH W   4       6.281  34.000   7.684  1.00 39.58           O
HETATM 4053  O   HOH W   5      16.004   9.039  10.335  1.00 37.31           O
HETATM 4054  O   HOH W   6       2.144   5.718  20.447  1.00 49.77           O
HETATM 4055  O   HOH W   7      -1.180  10.517  14.630  1.00 32.95           O
HETATM 4056  O  AHOH W   8       9.227   8.636  12.535  1.00 32.52           O
HETATM 4056  O  BHOH W   8       9.227   8.636  12.535  1.00 32.52           O
HETATM 4057  O  AHOH W   9      11.070  -0.570  15.047  1.00 30.24           O
HETATM 4057  O  BHOH W   9      11.070  -0.570  15.047  1.00 30.24           O
HETATM 4058  O  AHOH W  10      15.630  -6.169  12.853  1.00 31.08           O
HETATM 4058  O  BHOH W  10      15.630  -6.169  12.853  1.00 31.08           O
HETATM 4059  O   HOH W  11      14.854  -8.299  16.887  1.00 32.65           O
HETATM 4060  O   HOH W  12      27.586   0.391  24.184  1.00 31.29           O
HETATM 4061  O   HOH W  13       3.240   7.801  38.401  1.00 32.09           O
END""")).construct_hierarchy()
  m = mouse_selection_manager()
  pdb_hierarchy.atoms().reset_i_seq()
  m.update_selection_handlers(pdb_hierarchy=pdb_hierarchy,
    mmtbx_selection_function=None)
  assert m.selection_size() == 0
  m.apply_selection("chain W")
  assert m.selection_size() == 16
  m.start_range_selection(5)
  m.end_range_selection(15, deselect=False, ignore_altloc=True)
  assert m.selection_size() == 11
  m.start_range_selection(6)
  m.end_range_selection(10, deselect=False, ignore_altloc=True)
  assert m.selection_size() == 11 # no change because of deselect=False
  m.start_range_selection(6)
  m.end_range_selection(9, deselect=True, ignore_altloc=True)
  assert m.selection_size() == 6
  m.start_range_selection(10)
  m.end_range_selection(12, deselect=True, ignore_altloc=False)
  assert m.selection_size() == 5
  print("OK")

if __name__ == "__main__" :
  exercise()

#---end


 *******************************************************************************


 *******************************************************************************
crys3d/ribbon.py

from __future__ import absolute_import, division, print_function
from gltbx.gl import *
import scitbx.math
from scitbx.array_family import flex
import scitbx.matrix
import time
import sys
from six.moves import range

class cartoon (object) :
  def __init__ (self, pdb_hierarchy, sec_str, selection_cache=None) :
    self._segments = []
    if selection_cache is None :
      selection_cache = pdb_hierarchy.atom_selection_cache()
    last_atom     = None
    ca_sele = selection_cache.selection("name ' CA '")
    c_sele = selection_cache.selection("name ' C  '")
    o_sele = selection_cache.selection("name ' O  '")
    last_i_seq = None
    last_labels = None
    last_site = None
    last_ss = None
    last_resseq = - sys.maxsize
    current_segment = None
    t1 = time.time()
    for model in pdb_hierarchy.models() :
      for chain in pdb_hierarchy.chains() :
        main_conf = chain.conformers()[0]
        for residue in main_conf.residues() :
          resseq = residue.resseq_as_int()
          for atom in residue.atoms() :
            i_seq = atom.i_seq
            site_cart = atom.xyz
            if ca_sele[i_seq] :
              ss_type = sec_str[i_seq]
              if (resseq > (last_resseq + 1)) :
                current_segment = self.new_segment(site_cart=site_cart,
                  i_seq=i_seq,
                  ss_type=ss_type)
              elif (ss_type != last_ss) :
                if (current_segment is not None) :
                  current_segment.set_next_site(site_cart)
                current_segment = self.new_segment(site_cart=site_cart,
                  i_seq=i_seq,
                  ss_type=ss_type,
                  prev_site=last_site)
              else :
                current_segment.add_residue(site_cart, i_seq)
              last_ss = ss_type
              last_resseq = resseq
              last_site = site_cart
              break
    print("%d segments" % len(self._segments))
    t2 = time.time()
    print("Extract backbone: %.3fms" % ((t2-t1) * 1000))

  def new_segment (self, site_cart, i_seq, ss_type, prev_site=None) :
    new_seg = None
    if (ss_type == 0) :
      new_seg = loop(site_cart, i_seq, prev_site)
    elif (ss_type == 1) :
      new_seg = helix(site_cart, i_seq, prev_site)
    elif (ss_type == 2) :
      new_seg = strand(site_cart, i_seq, prev_site)
    assert (new_seg is not None)
    self._segments.append(new_seg)
    return new_seg

  def construct_geometry (self, smoothness=5) :
    t1 = time.time()
    for segment in self._segments :
      segment.construct_geometry(smoothness)
    t2 = time.time()
    print("Construct geometry: %.3fms" % ((t2-t1) * 1000))

  def draw_ribbon (self, atom_colors, atoms_visible) :
    for segment in self._segments :
      segment.draw_ribbon(atom_colors, atoms_visible)

  def get_points_and_lines (self) :
    points = flex.vec3_double()
    line_i_seqs = []
    k = 0
    for segment in self._segments :
      vertices = segment.get_vertices()
      points.extend(vertices)
      for i in range(k, k + vertices.size() - 1) :
        line_i_seqs.append((i, i+1))
      k += vertices.size()
    return (points, line_i_seqs)

class segment (object) :
  def __init__ (self, site_cart, i_seq, prev_site=None) :
    self._prev_site = prev_site
    self._next_site = None
    self._n_sites = 1
    self._anchors = flex.vec3_double()
    self._anchors.append(site_cart)
    self._indices = flex.size_t()
    self._indices.append(i_seq)
    self._vertices = None
    self._vertex_i_seqs = None

  def add_residue (self, site_cart, i_seq) :
    self._anchors.append(site_cart)
    self._indices.append(i_seq)

  def set_next_site (self, next_site) :
    self._next_site = next_site

  def get_vertices (self) :
    if (self._vertices is None) :
      self.construct_geometry()
    return self._vertices

  def construct_geometry (self, smoothness=5) :
    n_sites = len(self._anchors)
    anchors = self._anchors
    indices = self._indices
    if (self._prev_site is not None) :
      anchors.insert(0, self._prev_site)
      indices.insert(0, indices[0])
    else :
      v01 = vec3(anchors[0]) - vec3(anchors[1])
      v00 = vec3(anchors[0]) + v01
      anchors.insert(0, v00.elems)
      indices.insert(0, indices[0])
    if (self._next_site is not None) :
      anchors.append(self._next_site)
      indices.append(indices[-1])
    else :
      vlast = vec3(anchors[-2]) - vec3(anchors[-1])
      vXX = vec3(anchors[-1]) - vlast
      anchors.append(vXX.elems)
      indices.append(indices[-1])
    vertices = flex.vec3_double()
    vertex_i_seqs = flex.size_t()
    for i in range(1, n_sites) :
      v0 = vec3(anchors[i-1])
      v1 = vec3(anchors[i])
      v2 = vec3(anchors[i+1])
      v3 = vec3(anchors[i+2])
      v10 = (v1 - v0).normalize()
      v23 = (v2 - v3).normalize()
      v05 = (v0 + v1) / 2.0
      _v15 = (v1 + v2) / 2.0
      v25 = (v2 + v3) / 2.0
      v15 = _v15 + ((v10 + v23) / 2.0)
      if (i == 1) :
        vertices.append(v05.elems)
        vertex_i_seqs.append(indices[0])
        new_vertices_0 = crspline_interp(v0.elems, v05.elems, v1.elems, v15.elems, smoothness)
        vertices.extend(new_vertices_0)
        for k in range(new_vertices_0.size()) :
          vertex_i_seqs.append(indices[i])
      vertices.append(anchors[i])
      vertex_i_seqs.append(indices[i])
      new_vertices_1 = crspline_interp(v05.elems, v1.elems, v15.elems, v2.elems,        smoothness)
      vertices.extend(new_vertices_1)
      for k in range(new_vertices_1.size()) :
        vertex_i_seqs.append(indices[i])
      vertices.append(v15.elems)
      vertex_i_seqs.append(indices[i])
      new_vertices_2 = crspline_interp(v1.elems, v15.elems, v2.elems, v25.elems,
        smoothness)
      vertices.extend(new_vertices_2)
      for k in range(new_vertices_2.size()) :
        vertex_i_seqs.append(indices[i+1])
      if (i == (n_sites - 1)) :
        new_vertices_3 = crspline_interp(v15.elems, v2.elems, v25.elems, v3.elems, smoothness)
        vertices.extend(new_vertices_3)
        for k in range(new_vertices_3.size()) :
          vertex_i_seqs.append(indices[n_sites])
    assert (vertices.size() == vertex_i_seqs.size())
    self._vertices = vertices
    self._vertex_i_seqs = vertex_i_seqs

  def draw_ribbon (self, atom_colors, atoms_visible) :
    vertices = self._vertices
    indices = self._vertex_i_seqs
    in_line_loop = False
    glLineWidth(2.0)
    for k, point in enumerate(vertices) :
      i_seq = indices[k]
      if atoms_visible[i_seq] :
        if (not in_line_loop) :
          glBegin(GL_LINE_STRIP)
          in_line_loop = True
        glColor3f(*atom_colors[i_seq])
        glVertex3f(*point)
      elif in_line_loop :
        glEnd()
        in_line_loop = False
    if in_line_loop :
      glEnd()

class loop (segment) :
  pass

class helix (segment) :
  pass

class strand (segment) :
  pass

def vec3 (xyz) :
  return scitbx.matrix.rec(xyz, (1,3))

def crspline_interp (*args) :
  return scitbx.math.interpolate_catmull_rom_spline(*args)


 *******************************************************************************


 *******************************************************************************
crys3d/run_tests.py
from __future__ import absolute_import, division, print_function
import sys
from libtbx import test_utils
import libtbx.load_env


tst_list = [ "$D/regression/tst_hklinfo.py" ]
tst_list_expected_unstable = [
   # fails sometimes due to websocket connection problem to webbrowser
   "$D/regression/tst_websocket.py",
   "$D/regression/tst_HKLviewerOSbrowserSliceK-9.py",
   "$D/regression/tst_HKLviewerOSbrowserBinFSigF.py",
]
other_tests = [
  "$D/regression/tst_HKLviewerQtGuiSliceK-9.py",
  "$D/regression/tst_HKLviewerQtGuiBinFSigF.py",
]
try:
  import PySide2  # special import
  pyside2_available = True
except ImportError:
  pyside2_available = False
if (sys.platform == "darwin" or sys.platform == "win32") and pyside2_available:
  tst_list.extend(other_tests)
else: # no DISPLAY environment on Azure VMs running linux so tests fail by default
  tst_list_expected_unstable.extend(other_tests)

# expected failure for Python 2
if sys.version_info < (3, 0):
  tst_list_expected_failures = tst_list
  tst_list_expected_unstable = []
  tst_list = []


def run():
  build_dir = libtbx.env.under_build("crys3d")
  dist_dir = libtbx.env.dist_path("crys3d")

  test_utils.run_tests(build_dir, dist_dir, tst_list)

if (__name__ == "__main__"):
  run()


 *******************************************************************************


 *******************************************************************************
crys3d/wx_combined_viewer.py
from __future__ import absolute_import, division, print_function

from crys3d import wx_tools
from crys3d.wx_selection_editor import selection_editor_mixin
import iotbx.phil
#from gltbx.wx_viewer_leapmotion import wxGLWindowLeapEnabled as wxGLWindow
from gltbx.wx_viewer import wxGLWindow
import gltbx.util
from gltbx.gl import *
from gltbx.glu import *
from scitbx.math import minimum_covering_sphere
from scitbx.array_family import flex
from scitbx import iso_surface
from libtbx import adopt_init_args
import wx
import os
import sys
import six
from six.moves import zip

viewer_phil = iotbx.phil.parse("""
  include scope crys3d.wx_selection_editor.viewer_phil
""", process_includes=True)

class map_data (object) :
  def __init__ (self, map, is_difference_map=False, radius=10.0) :
    adopt_init_args(self, locals())
    self.unit_cell = map.unit_cell()
    o = self.unit_cell.orthogonalization_matrix()
    self.orthogonaliser = (  o[0:3] + (0,)
                           + o[3:6] + (0,)
                           + o[6:9] + (0,)
                           + (0,0,0,1) )
    p = self.unit_cell.orthogonalize((0,0,0))
    q = self.unit_cell.orthogonalize((1,1,1))
    r = self.unit_cell.orthogonalize((1, 0, 0))
    s = self.unit_cell.orthogonalize((0, 1, 1))
    self.iso_levels = [1]
    self.colors = [(1,1,1)]

  def set_iso_levels (self, levels) :
    self.iso_levels = levels
    if len(self.colors) != len(levels) :
      self.colors = [ (1.0,1.0,1.0) for x in levels ]

  def increment_iso_levels (self, inc) :
    for i, cutoff in enumerate(self.iso_levels) :
      if self.is_difference_map :
        if cutoff < 0 :
          self.iso_levels[i] -= inc
        elif cutoff > 0 :
          self.iso_levels[i] += inc
      else :
        self.iso_levels[i] += inc

  def set_colors (self, colors) :
    assert len(self.iso_levels) == len(colors)
    self.colors = colors

  def update_map_data (self, map) :
    self.map = map

  def get_scene_data (self, rotation_center) :
    triangles = []
    r = self.radius
    c = rotation_center
    min = [ c[x] - float(r) for x in [0, 1, 2] ]
    max = [ c[x] + float(r) for x in [0, 1, 2] ]
    map_boundaries_cart = flex.vec3_double([min,max])
    bounds = self.unit_cell.fractionalize(sites_cart=map_boundaries_cart)
    rho = self.map.real_map()
    for iso_level in self.iso_levels :
      triangulation = iso_surface.triangulation(rho,
                                iso_level,
                                map_extent=(1,1,1),
                                from_here=bounds[0],
                                to_there=bounds[1],
                                periodic=True,
                                ascending_normal_direction=False
                              )
      triangles.append(triangulation)
    return map_scene(triangles, self.orthogonaliser, self.colors)

class map_scene (object) :
  def __init__ (self, triangles, orthogonaliser, colors) :
    assert len(triangles) == len(colors)
    adopt_init_args(self, locals())
    self.flag_use_materials = False
    self.clear_lists()

  def clear_lists (self) :
    self.mesh_display_list = None

  def draw_mesh (self) :
    if self.mesh_display_list is None :
      self.mesh_display_list = gltbx.gl_managed.display_list()
      self.mesh_display_list.compile()
      glMatrixMode(GL_MODELVIEW)
      gltbx.util.handle_error()
      glPushMatrix()
      try :
        glMultTransposeMatrixd(self.orthogonaliser)
        for i, triangulation in enumerate(self.triangles) :
          if self.flag_use_materials :
            pass
          #  self.materials[i].execute(specular=False)
          else :
            glColor3f(*self.colors[i])
          gltbx.util.IsoMesh(triangulation.vertices, triangulation.triangles)
      finally :
        glPopMatrix()
      self.mesh_display_list.end()
    self.mesh_display_list.call()

#-----------------------------------------------------------------------
class map_viewer_mixin (wxGLWindow) :
  initialize_map_viewer_super = True
  def __init__ (self, *args, **kwds) :
    if self.initialize_map_viewer_super :
      wxGLWindow.__init__(self, *args, **kwds)
    # various data objects
    self.map_ids     = []
    self.map_objects = []
    self.map_scenes  = {}
    self.show_object = {}
    self.map_panel = None
    # user settings
    self.mesh_line_width = 0.25 # very buggy on OS X + NVidia (and ???)
    self.selected_map_id = None
    self.update_maps = False
    self.flag_show_maps = True
    self.flag_smooth_lines = True
    self.flag_use_materials = False
    self.flag_show_rotation_center = True
    self.minimum_covering_sphere = minimum_covering_sphere(
      flex.vec3_double([[0,0,0],[100,100,100],[100,0,0],[0,100,100]]))

  def InitGL (self) :
    glClearColor(self.r_back, self.g_back, self.b_back, 0.0)
    gltbx.util.rescale_normals(fallback_to_normalize=True).enable()
    glEnable(GL_DEPTH_TEST)
    glShadeModel(GL_SMOOTH)
    glEnableClientState(GL_VERTEX_ARRAY)
    glEnableClientState(GL_NORMAL_ARRAY)
    self.initialize_modelview()

  def OnRedrawGL (self, event=None) :
    self.check_and_update_map_scenes()
    wxGLWindow.OnRedrawGL(self, event)

  def check_and_update_map_scenes (self) :
    if self.update_maps :
      self.update_map_scenes()
      self.update_maps = False

  def DrawGL (self) :
    if len(self.map_scenes) == 0 :
      return
    if self.flag_show_maps :
      self.draw_maps()
    if self.flag_show_rotation_center :
      self.draw_rotation_center()

  def OnTranslate (self, event) :
    wxGLWindow.OnTranslate(self, event)
    self.update_map_scenes()

  def draw_rotation_center(self):
    font = gltbx.fonts.ucs_bitmap_10x20
    font.setup_call_lists()
    glColor3f(0, 1.0, 0)
    glRasterPos3f(*self.rotation_center)
    font.render_string("+")

  def process_key_stroke (self, key) :
    pass

  def add_map (self, map_id, map, is_difference_map=False) :
    if map_id in self.map_ids :
      self.delete_map(map_id)
    map_object = map_data(map,
      is_difference_map=is_difference_map,
      radius=self.settings.opengl.map_radius)
    self.map_ids.append(map_id)
    self.map_objects.append(map_object)
    self.show_object[map_id] = True
    self.update_maps = True

  def delete_map (self, map_id) :
    if map_id in self.map_ids :
      i = self.map_ids.index(map_id)
      self.map_ids.pop(i)
      self.map_objects.pop(i)
      self.show_object.pop(map_id)
      if map_id in self.map_scenes :
        self.map_scenes.pop(map_id)
    self.update_maps = True

  def update_map (self, map_id, map) :
    if not map_id in self.map_ids :
      self.add_map(map_id, map)
    else :
      map_object = self.get_map(map_id)
      map_object.update_map_data(map)
      self.update_maps = True

  def show_map_ctrls (self) :
    if (self.map_panel is None) :
      if (self.model_panel is not None) :
        frame_rect = self.model_panel.GetRect()
        pos = (frame_rect[0], frame_rect[1] + frame_rect[3])
      else :
        frame_rect = self.GetParent().GetRect()
        display_rect = wx.GetClientDisplayRect()
        x_start = frame_rect[0] + frame_rect[2]
        if (x_start > (display_rect[2] - 400)) :
          x_start = display_rect[2] - 400
        y_start = frame_rect[1] + 200
        if (y_start > (display_rect[3] - 200)) :
          y_start = display_rect[3] - 200
        pos = (x_start, y_start)
      self.map_panel = wx_tools.MapControlPanel(
        parent=self,
        id=-1,
        title="Map controls",
        style=wx.CLOSE_BOX|wx.CAPTION|wx.SYSTEM_MENU,
        pos=pos)
      self.map_panel.Show()

  def update_map_from_miller_array (self, map_id, map_coeffs,
      resolution_factor=0.33) :
    assert map_coeffs.is_complex_array()
    fft_map = map_coeffs.fft_map(resolution_factor=resolution_factor)
    fft_map.apply_sigma_scaling()
    self.update_map(map_id, fft_map)

  def hide_maps (self, object_id=None) :
    for map_id in self.map_ids :
      if object_id is None or map_id == object_id :
        self.show_object[map_id] = False

  def iter_maps (self) :
    for (map_id, map_object) in zip(self.map_ids, self.map_objects) :
      yield (map_id, map_object)

  def get_map (self, map_id) :
    for (object_id, map_object) in self.iter_maps() :
      if object_id == map_id :
        return map_object

  def set_map_levels_and_colors (self, map_id, levels, colors) :
    map = self.get_map(map_id)
    map.set_iso_levels(levels)
    map.set_colors(colors)
    self.update_maps = True

  def set_selected_map (self, map_id) :
    if map_id is None :
      self.selected_map_id = None
    else :
      self.selected_map_id = map_id

  def get_selected_map (self) :
    return self.get_map(self.selected_map_id)

  def increment_map_iso_levels (self, inc) :
    if self.get_selected_map() is not None :
      self.get_selected_map().increment_iso_levels(inc)
      if (self.map_panel is not None) :
        self.map_panel.refresh_iso_levels()
      self.update_maps = True

  def update_map_scenes (self) :
    for object_id, map in self.iter_maps() :
      map.radius = self.settings.opengl.map_radius
      scene = map.get_scene_data(self.rotation_center)
      self.map_scenes[object_id] = scene

  def draw_maps (self) :
    gltbx.util.handle_error()
    if self.flag_use_materials :
      glLightfv(GL_LIGHT0, GL_AMBIENT, [0., 0., 0., 1.])
    glDisable(GL_LIGHT0)
    glDisable(GL_LIGHTING)
    glDisable(GL_BLEND)
    vendor = glGetString(GL_VENDOR)
    if (sys.platform == "darwin") : #and vendor.startswith("NVIDIA") :
      glDisable(GL_LINE_SMOOTH) # XXX what about Linux?
    line_width = 0.1
    w_range = [0.0,0.0]
    glGetFloatv(GL_LINE_WIDTH_RANGE, w_range)
    if (w_range[0] > 0.1) :
      line_width = w_range[0]
    glLineWidth(line_width)
    glPolygonMode(GL_FRONT_AND_BACK, GL_LINE)
    glHint(GL_LINE_SMOOTH_HINT, GL_NICEST)
    glHint(GL_POLYGON_SMOOTH_HINT, GL_NICEST)
    for map_id, scene in six.iteritems(self.map_scenes) :
      if self.show_object[map_id] :
        scene.draw_mesh()

#-----------------------------------------------------------------------
class model_and_map_viewer (selection_editor_mixin, map_viewer_mixin) :
  initialize_map_viewer_super = False
  def __init__ (self, *args, **kwds) :
    selection_editor_mixin.__init__(self, *args, **kwds)
    map_viewer_mixin.__init__(self, *args, **kwds)
    self.buffer_factor = 1
    self._debug_mode = ("GLTBX_DEBUG_MODE" in os.environ)

  def OnMouseWheel (self, event) :
    scale = event.GetWheelRotation()
    if self.selected_map_id is not None and not event.AltDown() :
      self.increment_map_iso_levels(scale * 0.1)
    elif False : #event.ShiftDown() :
      # FIXME what was this supposed to do?
      self.fog_end_offset -= scale
    else :
      self.slab_scale += 0.01 * scale
      if self.slab_scale > 1.0 :
        self.slab_scale = 1.0
      elif self.slab_scale < 0.01 :
        self.slab_scale = 0.01
    self.OnRedrawGL()

  def InitGL (self) :
    selection_editor_mixin.InitGL(self)
    gltbx.util.rescale_normals(fallback_to_normalize=True).enable()
    vendor = glGetString(GL_VENDOR)
    #if sys.platform == "darwin" and vendor.startswith("NVIDIA") :
    #  print vendor
    if (wx.VERSION >= (2,9)) and ("GL_MULTISAMPLE" in globals().keys()) :
      #print "glEnable(GL_MULTISAMPLE)"
      glEnable(GL_MULTISAMPLE) # FIXME doesn't actually work???
    glEnable(GL_POLYGON_SMOOTH)
    n = [0]
    glGetIntegerv(GL_SAMPLE_BUFFERS, n)

  def OnRedrawGL (self, event=None) :
    if self._debug_mode :
      self.show_stack_sizes()
    self.check_and_update_map_scenes()
    selection_editor_mixin.OnRedrawGL(self, event)

  def DrawGL (self) :
    selection_editor_mixin.DrawGL(self)
    map_viewer_mixin.DrawGL(self)

  def process_key_stroke (self, key) :
    selection_editor_mixin.process_key_stroke(self, key)
    map_viewer_mixin.process_key_stroke(self, key)
    self.OnRedrawGL()

  def update_mcs (self, *args, **kwds) :
    self.update_maps = True
    selection_editor_mixin.update_mcs(self, *args, **kwds)

  def recenter_on_atom (self, *args, **kwds) :
    self.update_maps = True
    selection_editor_mixin.recenter_on_atom(self, *args, **kwds)

  def hide_all (self, *args, **kwds) :
    self.hide_models(*args, **kwds)
    self.hide_maps(*args, **kwds)

  def hide_others (self, object_id=None) :
    if object_id is None :
      self.hide_models()
      self.hide_maps()
    else :
      for current_object_id in self.model_ids+self.map_ids :
        if current_object_id != object_id :
          self.show_object[current_object_id] = False

  def toggle_visibility (self, show_object, object_id=None) :
    for current_object_id in self.model_ids+self.map_ids :
      if current_object_id == object_id :
        self.show_object[current_object_id] = show_object

  def update_all_settings (self, params, redraw=False) :
    selection_editor_mixin.update_settings(self, params, redraw)
    self.update_maps = True

  def leap_translate (self) :
    wxGLWindow.leap_translate(self)
    self.update_map_scenes()
    self.OnRedraw()

#---end


 *******************************************************************************


 *******************************************************************************
crys3d/wx_extra.py
from __future__ import absolute_import, division, print_function
import wx

import libtbx.object_oriented_patterns as oop
from six.moves import range
from six.moves import zip

class copy_init_args(object):
  def __init__(self, args, exclude=()):
    if ("self" in args): del args["self"]
    else:                del args["O"]
    del args["self"]
    for param in exclude:
      del args[param]
    self.__dict__.update(args)

class _extended_wxDC(oop.injector, wx.DC):

  def FillWith3DGradient(self, rect, colour, direction, step=1):
    """ Based on Horst Puschmann's ImageTools.gradient_bgr in Olex """
    x,y,w,h = rect
    if direction == wx.SOUTH:
      d = h
      draw_line = lambda i: self.DrawLine(x, y+i, x+w, y+i)
    elif direction == wx.EAST:
      d = w
      draw_line = lambda i: self.DrawLine(x+i, y, x+i, y+h)
    elif direction == wx.NORTH:
      d = h
      draw_line = lambda i: self.DrawLine(x, y+d-1-i, x+w, y+d-1-i)
    elif direction == wx.WEST:
      d = w
      draw_line = lambda i: self.DrawLine(x+w-1-i, y, x+w-1-i, y+h)
    slope_breaks       = (0,     d//10+1,     d//5+1,       d)
    step_adjustements  = (  0.6,          1.2,        1.4)
    slopes = [ x*step/d for x in step_adjustements ]
    red_green_slopes = [ x*58 for x in slopes ]
    blue_slopes      = [ x*44 for x in slopes ]
    ranges = [ range(slope_breaks[i], slope_breaks[i+1])
               for i in range(len(slope_breaks)-1) ]
    for range, red_green_slope, blue_slope in zip(
      ranges, red_green_slopes, blue_slopes):
      for i in range:
        r = int(colour.Red()   - i*red_green_slope)
        g = int(colour.Green() - i*red_green_slope)
        b = int(colour.Blue()  - i*blue_slope)
        self.SetPen(wx.Pen(wx.Colour(r,g,b)))
        draw_line(i)


class MouseClickButtonMixin(object):

  def __init__(self):
    self._pressing = False
    self.Bind(wx.EVT_LEFT_DOWN, self.OnLeftDown)
    self.Bind(wx.EVT_LEFT_UP, self.OnLeftUp)
    self.colour = self.normal_colour
    self.Bind(wx.EVT_LEAVE_WINDOW, self.OnLeaveWindow)
    self.Bind(wx.EVT_ENTER_WINDOW, self.OnEnterWindow)

  def OnLeftDown(self, event):
    if not self.IsEnabled(): return
    self._pressing = True
    self.CaptureMouse()
    self.colour = self.pressed_colour
    self.Refresh()

  def OnLeftUp(self, event):
    if not self.IsEnabled(): return
    if self.HasCapture():
      self.ReleaseMouse()
      if self._pressing and self.Rect.Contains(event.Position):
        self.OnClick(event)
      self._pressing = False
      self.colour = self.normal_colour
      self.Refresh()

  def OnLeaveWindow(self, event):
    if not self.IsEnabled(): return
    if self.HasCapture() and self._pressing:
      self.colour = self.normal_colour
      self.Refresh()

  def OnEnterWindow(self, event):
    if not self.IsEnabled(): return
    if self.HasCapture() and self._pressing:
      self.colour = self.pressed_colour
      self.Refresh()


class InspectorHeader(wx.PyControl, MouseClickButtonMixin):

  normal_colour = wx.Colour(237, 237, 235)
  pressed_colour = wx.Colour(200, 200, 198)
  horizontal_margin = 2
  vertical_margin = 2

  def __init__(self, parent, label=""):
    wx.PyControl.__init__(self, parent, style=wx.BORDER_NONE)
    MouseClickButtonMixin.__init__(self)

    self.Label = label
    self.SetFont(wx.NORMAL_FONT)

    self.Bind(wx.EVT_SIZING, self.OnResize)
    self.Bind(wx.EVT_SIZE, self.OnResize)

    # to reduce flicker: use BufferedPaintDC in handling EVT_PAINT
    # and ignore EVT_ERASE_BACKGROUND
    self.Bind(wx.EVT_PAINT, self.OnPaint)
    self.Bind(wx.EVT_ERASE_BACKGROUND, lambda event: None)

    self._opened = True

  def DoGetBestSize(self):
    try:
      return self._best_size
    except AttributeError:
      dc = wx.ClientDC(self)
      dc.SetFont(self.Font)
      w_txt, h_txt = dc.GetTextExtent(self.Label)
      self.triangle_base_length = 2*(h_txt//2) - 4
      h_txt += 2*self.vertical_margin
      w_txt += 4*self.vertical_margin + self.triangle_base_length
      self._best_size = (w_txt, h_txt)
      return self._best_size

  def OnPaint(self, event):
    dc = wx.BufferedPaintDC(self)
    dc.SetFont(self.Font)
    dc.FillWith3DGradient(self.Rect, self.colour,
                          direction=wx.SOUTH, step=0.6)
    w_t = self.triangle_base_length
    h_t = w_t//2
    h = self.GetSize()[1]
    dc.SetBrush(wx.BLACK_BRUSH)
    dc.SetPen(wx.BLACK_PEN)
    if self._opened:
      dc.DrawPolygon((wx.Point(0, -h_t), wx.Point(w_t, -h_t),
                              wx.Point(h_t, 0) ),
                     xoffset=self.horizontal_margin,
                     yoffset=(h-h_t)//2 + h_t)
    else:
      dc.DrawPolygon((wx.Point(0, -w_t), wx.Point(0, 0),
                              wx.Point(h_t, -h_t) ),
                     xoffset=self.horizontal_margin + h_t,
                     yoffset=(h-w_t)//2 + w_t)
    dc.DrawText(self.Label, w_t + 3*self.horizontal_margin,
                            self.vertical_margin)
    dc.Destroy()

  def OnResize(self, event):
    event.Skip()
    self.Refresh()

  def OnClick(self, event):
    self._opened = not self._opened
    self.on_click()


class Inspector(wx.Panel):

  def __init__(self, parent, id=wx.ID_ANY, label="", colour=wx.BLACK,
               pos=wx.DefaultPosition, size=wx.DefaultSize, style=0):
    assert parent.GetSizer() is not None
    super(Inspector, self).__init__(parent, id)
    self._header = InspectorHeader(self, label=label)
    self._header.on_click = self.Toggle
    self._pane = wx.Panel(self)
    self._expanded = True
    s = wx.BoxSizer(wx.VERTICAL)
    s.Add(self._header, 0, wx.EXPAND, 5)
    s.Add(self._pane, flag=wx.LEFT|wx.RIGHT|wx.TOP, border=5)
    self.SetSizer(s)

  def IsExpanded(self):
    return self._expanded

  def Collapse(self, f):
    self._expanded = not f
    self._update()

  def Toggle(self):
    self._expanded = not self._expanded
    self._update()

  def DoLayout(self):
    self.Sizer.Layout()

  def _update(self):
    if self._expanded:
      self._pane.Show()
    else:
      self._pane.Hide()
    top = wx.GetTopLevelParent(self)
    top_sizer = top.GetSizer()
    top_sizer.SetSizeHints(top)
    if self._expanded:
      top.Fit()
    else:
      sz = top_sizer.CalcMin()
      top.SetClientSize(sz)

  def GetLabel(self):
    return self._header.GetLabel()

  def GetPane(self):
    return self._pane

  def DoGetBestSize(self):
    return self.Sizer.CalcMin()


class InspectorToolFrame(wx.MiniFrame):

  def __init__(self, parent, id=wx.ID_ANY,
               pos=wx.DefaultPosition, size=wx.DefaultSize):
    if pos is wx.DefaultPosition and wx.Platform == '__WXMAC__':
      pos = (0, 26)
    super(InspectorToolFrame, self).__init__(
      parent, id, title=" ",
      pos=pos, size=size,
      style=wx.CAPTION|wx.CLOSE_BOX)
    s = wx.BoxSizer(wx.VERTICAL)
    self.SetSizer(s)
    self.Bind(wx.EVT_CLOSE, self.on_close)

  def on_close(self, event):
    self.Hide()

  def move_parent_out_of_the_way(self):
    x,y,w,h = self.GetRect()
    xp,yp = self.Parent.GetPosition()
    if wx.Platform == '__WXGTK__': gap = 10
    else: gap = 5
    xp = max(xp, x + w + gap)
    self.Parent.Move((xp,yp))

  def Layout(self):
    s = self.Sizer
    for i in self.Children:
      s.Add(i, 0, wx.EXPAND)
    w = max([ i.GetBestSize()[0] for i in self.Children ])
    s.SetMinSize((w,-1))
    s.SetSizeHints(self)


class Slider(wx.Slider):

  def __init__(self, parent, id=wx.ID_ANY,
               value=0, minValue=0, maxValue=100,
               pos=wx.DefaultPosition, size=wx.DefaultSize,
               style=wx.SL_HORIZONTAL,
               validator=wx.DefaultValidator,
               name=wx.SliderNameStr):
    kwds = copy_init_args(locals())
    w,h = kwds.size
    if w == -1: w = 150
    kwds.size = (w,h)
    wx.Slider.__init__(self, **kwds.__dict__)


if __name__ == '__main__':
  a = wx.App(redirect=False)

  class GradientTestFrame(wx.Frame):

    def __init__(self):
      super(GradientTestFrame, self).__init__(None, pos=(0,-1))
      size = (120, 90)
      box = wx.BoxSizer(wx.VERTICAL)
      for direction in (wx.NORTH, wx.EAST, wx.SOUTH, wx.WEST):
        p = wx.Window(self, style=wx.BORDER_NONE)
        p.SetMinSize(size)
        box.Add(p)
        p.Bind(wx.EVT_PAINT, self.make_on_paint(p, direction))
      self.SetSizer(box)
      box.SetSizeHints(self)
      self.Show()

    def make_on_paint(window, direction):
      def on_paint(event):
        dc = wx.PaintDC(window)
        dc.FillWith3DGradient(window.ClientRect,
                              colour=wx.Colour(237, 237, 235),
                              direction=direction)
        del dc
      return on_paint
    make_on_paint = staticmethod(make_on_paint)

  gradient_test_frame = GradientTestFrame()


  class InspectorHeaderTestFrame(wx.Frame):

    def __init__(self):
      super(InspectorHeaderTestFrame, self).__init__(None, pos=(300,-1))
      box = wx.BoxSizer(wx.VERTICAL)
      inspector = InspectorHeader(self, label="Title")
      box.Add(inspector, flag=wx.EXPAND)
      self.log = wx.TextCtrl(self, style=wx.TE_MULTILINE|wx.BORDER_NONE,
                                   size=(80, 240))
      self.i = 0
      inspector.on_click = self.log_click
      box.Add(self.log, proportion=1, flag=wx.ALL|wx.EXPAND, border=5)
      self.SetSizer(box)
      box.SetSizeHints(self)
      self.Show()

    def log_click(self):
      self.i += 1
      self.log.AppendText("Click #%i\n" % self.i)

  inspector_header_test_frame = InspectorHeaderTestFrame()

  w1 = wx.Frame(None, pos=(0, 500))
  s = wx.BoxSizer(wx.VERTICAL)
  w1.SetSizer(s)
  s.Add(Slider(w1, -1, 5, 0, 10, wx.DefaultPosition, (100,-1)))
  s.Add(Slider(w1, -1, 5, 0, 10, wx.DefaultPosition, (-1,-1)))
  s.Add(Slider(w1, size=(150,-1)))
  s.Add(Slider(w1, size=(-1,-1)))
  s.Add(Slider(w1))
  w1.Fit()
  a.SetTopWindow(w1)

  w = InspectorToolFrame(w1, pos=(100, 500))

  i1 = Inspector(w, label="Header")
  def f():
    print("Click in 'Header'")
  i1.on_click_in_header = f
  pane = i1.GetPane()
  top = wx.BoxSizer(wx.VERTICAL)
  s = wx.BoxSizer(wx.HORIZONTAL)
  s.Add(wx.Button(pane, label="Click me!"))
  s.Add(wx.CheckBox(pane, label="Check me!"))
  top.Add(s, flag=wx.ALL, border=5)
  pane.SetSizer(top)

  i2 = Inspector(w, label="Longer header")
  def g():
    print("Click in 'Longer header'")
  i2.on_click_in_header = g
  pane = i2.GetPane()
  s = wx.BoxSizer(wx.HORIZONTAL)
  s.Add(wx.StaticText(pane, label="Static"))
  s.Add(wx.StaticText(pane, label="..."))
  pane.SetSizer(s)

  w.Layout()

  w.move_parent_out_of_the_way()
  w.Show()
  w1.Show()

  a.MainLoop()


 *******************************************************************************


 *******************************************************************************
crys3d/wx_model_viewer.py
from __future__ import absolute_import, division, print_function

# XXX: To keep these classes as clean as possible, selections are handled
# entirely in wx_selection_editor.py.
# TODO: hide nonbonded point for any atom that has an ellipsoid drawn
# TODO: clean up handling of changes in atom count

from crys3d import wx_tools
from crys3d.model import model_data
# pyopengl GLU imports may change location of gltbx imports (e.g. quadrics),
# so place these first
from gltbx.gl import *
from gltbx.glu import *
from gltbx.wx_viewer import wxGLWindow
import gltbx.util
from gltbx import viewer_utils, quadrics
import gltbx
import libtbx.phil
from libtbx.introspection import method_debug_log
from libtbx import adopt_init_args
import wx
import six
from six.moves import zip

debug = method_debug_log()

opengl_phil = libtbx.phil.parse("""
opengl {
  line_width = 2
    .type = int
    .style = spinner min:1 max:10
  nonbonded_line_width = 2
    .type = int
    .style = spinner min:1 max:10
  hydrogen_bond_width = 2
    .type = int
    .style = spinner min:1 max:10
  map_radius = 10
    .type = int
    .style = spinner min:1 max:40
  base_atom_color = 1.0 1.0 0.0
    .type = floats
    .style = color
  background_color = 0.0 0.0 0.0
    .type = floats
    .style = color
  default_coloring = *rainbow element b chain
    .type = choice
  default_representation = *all_atoms trace bonded_only
    .type  = choice
  show_hydrogens = False
    .type = bool
  label_clicked_atom = True
    .type = bool
  use_atom_color_for_labels = True
    .type = bool
  orthographic = False
    .type = bool
    .style = noauto
  animate_zoom = False
    .type = bool
}
""")

#-----------------------------------------------------------------------
# XXX: this class contains only the information needed for OpenGL commands,
# which are also implemented as methods here.
class model_scene (object) :
  def __init__ (self, bonds, points, b_iso, b_aniso, atom_colors, atom_labels,
      atom_radii, visibility, noncovalent_bonds, atomic_bonds, ribbon=None) :
    adopt_init_args(self, locals())
    self.clear_lists()
    self.clear_labels()
    self.update_visibility(visibility)

  @debug
  def clear_lists (self) :
    self.points_display_list = None
    self.lines_display_list = None
    self.spheres_display_list = None
    self.ellipsoid_display_list = None
    self.selection_display_list = None
    self.labels_display_list = None
    self.nc_display_list = None
    self.ribbon_display_list = None

  @debug
  def clear_labels (self) :
    from scitbx.array_family import flex
    self.show_labels = flex.bool(self.points.size(), False)
    self.labels_display_list = None

  @debug
  def add_label (self, i_seq) :
    self.show_labels[i_seq] = True
    self.labels_display_list = None

  @debug
  def update_colors (self, atom_colors) :
    assert atom_colors.size() == self.points.size()
    self.atom_colors = atom_colors

  @debug
  def update_bonds (self, bonds) :
    if (bonds.size() != self.points.size()) :
      raise RuntimeError("Mismatch in bonds versus points arrays: %d, %d" %
        (bonds.size(), self.points.size()))
    self.bonds = bonds

  @debug
  def update_visibility (self, visibility) :
    assert visibility.atoms_visible.size() == self.points.size()
    self.atoms_visible = visibility.atoms_visible
    self.bonds_visible = visibility.bonds_visible
    self.points_visible = visibility.points_visible
    self.spheres_visible = self.atoms_visible # XXX: what to do here?
    self.visible_atom_count = visibility.visible_atoms_count
    self.clear_lists()

  def draw_points (self) :
    if self.points_display_list is None :
      self.points_display_list = gltbx.gl_managed.display_list()
      self.points_display_list.compile()
      viewer_utils.draw_points(
        points = self.points,
        atom_colors = self.atom_colors,
        points_visible = self.points_visible)
      self.points_display_list.end()
    self.points_display_list.call()

  def draw_lines (self) :
    if self.lines_display_list is None :
      self.lines_display_list = gltbx.gl_managed.display_list()
      self.lines_display_list.compile()
      viewer_utils.draw_bonds(
        points = self.points,
        bonds  = self.bonds,
        atom_colors = self.atom_colors,
        bonds_visible = self.bonds_visible)
      self.lines_display_list.end()
    self.lines_display_list.call()

  def draw_ribbon (self) :
    if (self.ribbon is None) :
      return
    if (self.ribbon_display_list is None) :
      self.ribbon_display_list = gltbx.gl_managed.display_list()
      self.ribbon_display_list.compile()
      self.ribbon.draw_ribbon(
        atom_colors=self.atom_colors,
        atoms_visible=self.bonds_visible)
      self.ribbon_display_list.end()
    self.ribbon_display_list.call()

  def draw_spheres (self, scale_factor=1.0) :
    if self.spheres_display_list is None :
      self.spheres_display_list = gltbx.gl_managed.display_list()
      self.spheres_display_list.compile()
      glPolygonMode(GL_FRONT_AND_BACK, GL_FILL)
      atom_radii = self.atom_radii
      atom_colors = self.atom_colors
      spheres_visible = self.spheres_visible
      for i_seq, point in enumerate(self.points) :
        if spheres_visible[i_seq] :
          glColor3f(*atom_colors[i_seq])
          glPushMatrix()
          glTranslated(*point)
          gltbx.util.SolidSphere(radius=atom_radii[i_seq] * scale_factor,
                                 slices=50, stacks=50)
          glPopMatrix()
      self.spheres_display_list.end()
    self.spheres_display_list.call()

  def draw_ellipsoids (self, proto_ellipsoid) :
    if self.ellipsoid_display_list is None :
      self.ellipsoid_display_list = gltbx.gl_managed.display_list()
      self.ellipsoid_display_list.compile()
      points = self.points
      atoms_visible = self.atoms_visible
      atom_colors = self.atom_colors
      for i_seq, uij in enumerate(self.b_aniso) :
        if atoms_visible[i_seq] and uij[0] != -1 :
          col = list(atom_colors[i_seq]) + [1.0]
          glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, col)
          glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT, [0.1, 0.1, 0.1, 1.0])
          glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR, [0.1, 0.1, 0.1, 1.0])
          proto_ellipsoid.draw(points[i_seq], uij)
      self.ellipsoid_display_list.end()
    self.ellipsoid_display_list.call()

  def draw_labels (self, font, use_atom_color=False) :
    glDisable(GL_LIGHTING)
    if (self.labels_display_list is None) :
      self.labels_display_list = gltbx.gl_managed.display_list()
      self.labels_display_list.compile()
      points = self.points
      atoms_visible = self.atoms_visible
      atom_colors = self.atom_colors
      atom_labels = self.atom_labels
      for i_seq, show_label in enumerate(self.show_labels) :
        if atoms_visible[i_seq] and show_label :
          if use_atom_color :
            glColor3f(*atom_colors[i_seq])
          glRasterPos3f(*points[i_seq])
          font.render_string(atom_labels[i_seq])
      self.labels_display_list.end()
    self.labels_display_list.call()

  def draw_noncovalent_bonds (self) :
    if self.noncovalent_bonds is None :
      return
    if self.nc_display_list is None :
      self.nc_display_list = gltbx.gl_managed.display_list()
      self.nc_display_list.compile()
      viewer_utils.draw_noncovalent_bonds(
        points=self.points,
        bonds=self.noncovalent_bonds,
        bonds_visible=self.bonds_visible)
      self.nc_display_list.end()
    self.nc_display_list.call()

########################################################################
# VIEWER CLASS
#
UPDATE_MODEL_ID = wx.NewId()
ADD_MODEL_ID = wx.NewId()
class AddModelEvent (wx.PyEvent) :
  event_id = ADD_MODEL_ID
  recenter = True
  def __init__ (self, model_id, pdb_hierarchy, atomic_bonds) :
    wx.PyEvent.__init__(self)
    self.data = (model_id, pdb_hierarchy, atomic_bonds)
    self.SetEventType(self.event_id)

class UpdateModelEvent (AddModelEvent) :
  event_id = UPDATE_MODEL_ID
  recenter = False

class model_viewer_mixin (wxGLWindow) :
  def __init__ (self, *args, **kwds) :
    wxGLWindow.__init__(self, *args, **kwds)
    self.Bind(wx.EVT_LEFT_DCLICK, self.OnDoubleClick)
    self.Connect(-1, -1, UPDATE_MODEL_ID, self.OnUpdateModel)
    self.Connect(-1, -1, ADD_MODEL_ID, self.OnAddModel)
    self.model_panel = None
    self.minimum_covering_sphere = None
    self.show_object = {}
    self.pick_object = {}
    self.model_objects = []
    self.model_ids = []
    self.scene_objects = {}
    self.model_colors = {}
    self.model_reps = {}
    self.update_scene = False
    self.buffer_factor = 2 # see gltbx.wx_viewer
    self.min_slab = 4
    self.min_viewport_use_fraction = 0.1
    self.min_dist = 4.0
    self.sphere_scale_factor = 1.0
    self.update_settings(opengl_phil.extract())
    self.closest_point_i_seq     = None
    self.closest_point_model_id  = None
    # toggles for viewable objects
    self.flag_show_fog                     = True
    self.flag_show_lines                   = True
    self.flag_show_points                  = True
    self.flag_show_spheres                 = True
    self.flag_use_lights                   = True
    self.flag_show_labels                  = True
    self.flag_show_trace                   = False
    self.flag_show_ribbon                  = True
    self.flag_show_noncovalent_bonds       = True
    self.flag_show_hydrogens               = False
    self.flag_show_ellipsoids              = True
    self.flag_smooth_lines                 = True
    self.flag_recenter_on_click            = False
    self.flag_show_context_menu            = True #False

  @debug
  def InitGL(self):
    gltbx.util.handle_error()
    bgcolor = self.settings.opengl.background_color + [0.0]
    glClearColor(*bgcolor)
    self.minimum_covering_sphere_display_list = None
    glDepthFunc(GL_LESS)
    glEnable(GL_ALPHA_TEST)
    glEnable(GL_DEPTH_TEST)
    glEnable(GL_BLEND)
    # XXX: line smoothing is pretty essential for wireframe representation;
    # the problem with nvidia cards is really only a problem for the isomesh
    # in wx_map_viewer.py.
    glEnable(GL_LINE_SMOOTH)
    glHint(GL_LINE_SMOOTH_HINT, GL_NICEST)
    self.initialize_modelview()
    glPolygonMode(GL_FRONT_AND_BACK, GL_FILL)
    self.proto_ellipsoid = quadrics.proto_ellipsoid(slices=32, stacks=32)
    gltbx.util.handle_error()

  @debug
  def initialize_modelview (self) :
    if self.minimum_covering_sphere is not None :
      wxGLWindow.initialize_modelview(self)
    else :
      self.setup_lighting()

  def OnRedrawGL (self, event=None) :
    self.check_and_update_model_scenes()
    if self.minimum_covering_sphere is None :
      gltbx.util.handle_error()
      glClear(GL_COLOR_BUFFER_BIT)
      glClear(GL_DEPTH_BUFFER_BIT)
      glFlush()
      self.SwapBuffers()
      gltbx.util.handle_error()
    else :
      wxGLWindow.OnRedrawGL(self, event)

  def get_clipping_distances (self) :
    slab = self.far - self.near
    clip = (1.0 - self.slab_scale) * (slab / 2.0)
    near = self.near + clip
    far = self.far - clip
    if near < self.min_near :
      near = self.min_near
    if near > far or far < (near + self.min_slab) :
      far = near + self.min_slab
    return (near, far)

  def check_and_update_model_scenes (self) :
    if self.update_scene :
      self.update_scene_objects()
      self.update_scene = False

  def DrawGL(self):
    if self.GL_uninitialised or len(self.scene_objects) == 0 :
      return
    if self.flag_show_points :
      self.draw_points()
    if self.flag_show_lines :
      self.draw_lines()
    if self.flag_show_ribbon :
      self.draw_ribbon()
    if self.flag_show_spheres :
      self.draw_spheres()
    if self.flag_show_ellipsoids :
      self.draw_ellipsoids()
    if self.flag_show_labels :
      self.draw_labels()
    if self.flag_show_noncovalent_bonds :
      self.draw_noncovalent_bonds()

  def draw_points (self) :
    glDisable(GL_LIGHTING)
    glLineWidth(self.settings.opengl.nonbonded_line_width)
    for model_id, model in self.iter_models() :
      if self.show_object[model_id] and model.flag_show_points :
        self.scene_objects[model_id].draw_points()

  def draw_spheres (self) :
    glMatrixMode(GL_MODELVIEW)
    if self.flag_use_lights :
      glEnable(GL_LIGHTING)
      glEnable(GL_LIGHT0)
      glEnable(GL_NORMALIZE)
    glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, [1.0,1.0,1.0,1.0])
    glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT, [0.1, 0.1, 0.1, 1.0])
    glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR, [0.1, 0.1, 0.1, 1.0])
    for model_id, model in self.iter_models() :
      if self.show_object[model_id] and model.flag_show_spheres :
        self.scene_objects[model_id].draw_spheres(self.sphere_scale_factor)

  def draw_lines (self) :
    glEnable(GL_LINE_SMOOTH)
    glEnable(GL_BLEND)
    glHint(GL_LINE_SMOOTH_HINT, GL_NICEST)
    glDisable(GL_LIGHTING)
    glLineWidth(self.settings.opengl.line_width)
    for model_id, model in self.iter_models() :
      if self.show_object[model_id] and model.flag_show_lines :
        self.scene_objects[model_id].draw_lines()

  def draw_ribbon (self) :
    glEnable(GL_LINE_SMOOTH)
    glEnable(GL_BLEND)
    glHint(GL_LINE_SMOOTH_HINT, GL_NICEST)
    glDisable(GL_LIGHTING)
    glLineWidth(self.settings.opengl.line_width)
    for model_id, model in self.iter_models() :
      if self.show_object[model_id] and model.flag_show_ribbon :
        self.scene_objects[model_id].draw_ribbon()

  def draw_ellipsoids (self) :
    glMatrixMode(GL_MODELVIEW)
    if self.flag_use_lights :
      glShadeModel(GL_SMOOTH)
      glEnable(GL_DEPTH_TEST)
      glEnable(GL_LIGHTING)
      glEnable(GL_LIGHT0)
      glEnable(GL_NORMALIZE)
    glPolygonMode(GL_FRONT_AND_BACK, GL_FILL)
    proto_ellipsoid = self.proto_ellipsoid
    for model_id, model in self.iter_models() :
      if self.show_object[model_id] and model.flag_show_ellipsoids :
        self.scene_objects[model_id].draw_ellipsoids(proto_ellipsoid)

  def draw_labels (self) :
    glDisable(GL_LIGHTING)
    use_atom_color = self.settings.opengl.use_atom_color_for_labels
    if not use_atom_color :
      glColor3f(1.0, 1.0, 1.0)
    font = gltbx.fonts.ucs_bitmap_8x13
    font.setup_call_lists()
    for model_id, model in self.iter_models() :
      if self.show_object[model_id] and model.flag_show_labels :
        self.scene_objects[model_id].draw_labels(font, use_atom_color)

  def draw_noncovalent_bonds (self) :
    glDisable(GL_LIGHTING)
    glColor3f(0.0, 1.0, 0.0)
    glEnable(GL_LINE_STIPPLE)
    glLineStipple(4, 0xAAAA)
    glLineWidth(self.settings.opengl.hydrogen_bond_width)
    for model_id, model in self.iter_models() :
      if self.show_object[model_id] and model.flag_show_noncovalent_bonds :
        self.scene_objects[model_id].draw_noncovalent_bonds()
    glDisable(GL_LINE_STIPPLE)

  @debug
  def refresh_bg_color (self) :
    (r, g, b) = tuple(self.settings.opengl.background_color)
    glClearColor(r, g, b, 0.0)

  #---------------------------------------------------------------------
  # Non-OpenGL code below here
  #
  def update_settings (self, params, redraw=False) :
    assert (len(params.opengl.base_atom_color) ==
            len(params.opengl.background_color) == 3)
    self.settings = params
    if params.opengl.animate_zoom :
      self.animation_time = 1
    else :
      self.animation_time = 0
    self.toggle_hydrogens(params.opengl.show_hydrogens)
    self.r_back = params.opengl.background_color[0]
    self.g_back = params.opengl.background_color[1]
    self.b_back = params.opengl.background_color[2]
    if redraw :
      self.update_scene = True

  def iter_models (self) :
    for model_id, model_object in zip(self.model_ids, self.model_objects) :
      yield (model_id, model_object)

  def get_model (self, object_id) :
    for model in self.model_objects :
      if model.object_id == object_id :
        return model
    return None

  def set_model_state (self, object_id, model_state) :
    model = self.get_model(object_id)
    for name in model_state :
      setattr(model, name, model_state[name])
    model.set_draw_mode(model_state["draw_mode"])
    #model.recalculate_visibility()
    self.update_scene = True

  @debug
  def add_model (self, model_id, pdb_hierarchy, atomic_bonds=None) :
    assert isinstance(model_id, str)
    model = model_data(model_id, pdb_hierarchy, atomic_bonds,
      base_color=self.settings.opengl.base_atom_color)
    self._add_model(model_id, model)

  def delete_model (self, model_id) :
    if model_id in self.model_ids :
      i = self.model_ids.index(model_id)
      self.model_ids.pop(i)
      self.model_objects.pop(i)
      if model_id in self.scene_objects :
        self.scene_objects.pop(model_id)
    self.update_scene = True

  def _add_model (self, model_id, model) :
    model.set_draw_mode(draw_mode=self.settings.opengl.default_representation,
      color_mode=self.settings.opengl.default_coloring)
    self.model_ids.append(model_id)
    self.model_objects.append(model)
    self.show_object[model_id] = True
    self.pick_object[model_id] = True
    self.update_scene = True

  def update_model (self, model_id, pdb_hierarchy, atomic_bonds,
      xray_structure=None) :
    model = self.get_model(model_id)
    if model is not None :
      special_position_settings = None
      if (xray_structure is not None):
        special_position_settings = xray_structure.special_position_settings()
      model.update_structure(
        pdb_hierarchy=pdb_hierarchy,
        atomic_bonds=atomic_bonds,
        special_position_settings=special_position_settings)
      model.set_draw_mode(model.draw_mode)
      if model_id in self.scene_objects :
        self.scene_objects.pop(model_id)
      self.update_scene = True
    else :
      self.add_model(model_id, pdb_hierarchy, atomic_bonds)

  def update_model_from_xray_structure (self, model_id, xray_structure) :
    model = self.get_model(model_id)
    if model is not None :
      model.update_from_xray_structure(xray_structure)
      self.update_scene = True

  def set_noncovalent_bonds (self, model_id, bonded_atoms, auto_show=False) :
    if isinstance(bonded_atoms, list) :
      from scitbx.array_family import shared
      bonded_atoms = shared.stl_set_unsigned(bonded_atoms)
    model = self.get_model(model_id)
    if model is not None :
      model.set_noncovalent_bonds(bonded_atoms)
      if auto_show :
        model.flag_show_noncovalent_bonds = True
      self.update_scene = True

  def set_sec_str (self, model_id, sec_str) :
    model = self.get_model(model_id)
    if (model is not None) :
      model.initialize_cartoon(sec_str)
      self.update_scene = True

  def update_mcs (self, points, recenter_and_zoom=True, buffer=0) :
    from scitbx.math import minimum_covering_sphere, sphere_3d
    mcs = minimum_covering_sphere(points=points,
                                  epsilon=0.1)
    if buffer > 0 :
      self.minimum_covering_sphere = sphere_3d(
        center=mcs.center(),
        radius=mcs.radius() + buffer)
    else :
      self.minimum_covering_sphere = mcs
    if (recenter_and_zoom) and (not self.GL_uninitialised) :
      self.move_rotation_center_to_mcs_center()
      self.fit_into_viewport()

  def zoom_object (self, object_id) :
    self.update_scene_objects()
    assert object_id in self.scene_objects
    self.update_mcs(self.scene_objects[object_id].points)

  @debug
  def unzoom (self, event=None) :
    self.update_scene_objects()
    if len(self.scene_objects) > 0 :
      from scitbx.array_family import flex
      points = flex.vec3_double()
      for object_id, scene in six.iteritems(self.scene_objects) :
        points.extend(scene.points)
      self.update_mcs(points)

  @debug
  def recenter_on_atom (self, object_id, i_seq) :
    assert object_id is not None and i_seq >= 0
    scene = self.scene_objects.get(object_id)
    if scene is not None and i_seq < scene.points.size() :
      self.rotation_center = scene.points[i_seq]
      self.move_to_center_of_viewport(self.rotation_center)

  @debug
  def process_pick_points (self) :
    self.closest_point_object_id = None
    self.closest_point_i_seq = None
    if self.pick_points is not None and len(self.scene_objects) > 0 :
      for object_id in self.model_ids :
        if self.show_object[object_id] and self.pick_object[object_id] :
          scene = self.scene_objects.get(object_id)
          if scene is None :
            continue
          closest_point_i_seq = viewer_utils.closest_visible_point(
            points = scene.points,
            atoms_visible = scene.atoms_visible,
            point0 = self.pick_points[0],
            point1 = self.pick_points[1]
          )
          if closest_point_i_seq is not None :
            self.closest_point_i_seq = closest_point_i_seq
            self.closest_point_object_id = object_id
            break
    if self.closest_point_i_seq is not None :
      clicked_scene = self.scene_objects.get(self.closest_point_object_id)
      if self.settings.opengl.label_clicked_atom :
        clicked_scene.add_label(self.closest_point_i_seq)
      if self.flag_recenter_on_click :
        self.recenter_on_atom(self.closest_point_object_id,
          self.closest_point_i_seq)

  @debug
  def update_scene_objects (self) :
    from scitbx.array_family import flex
    points = flex.vec3_double()
    for object_id, model in self.iter_models() :
      current_scene = self.scene_objects.get(object_id)
      if current_scene is None or model.is_changed :
        current_scene = model.get_scene_data()
        self.scene_objects[object_id] = current_scene
        model.reset()
      else :
        model.update_scene_data(current_scene)
      points.extend(current_scene.points)
    if points.size() == 0 :
      points.append((0,0,0))
    self.update_mcs(points, recenter_and_zoom=False)

  @debug
  def process_key_stroke (self, key) :
    if key == ord('u') :
      self.unzoom()
    elif key == ord('h') :
      self.flag_show_hydrogens = not self.flag_show_hydrogens
      self.toggle_hydrogens(self.flag_show_hydrogens)
      self.update_scene = True
    elif key == ord('e') :
      self.flag_show_ellipsoids = not self.flag_show_ellipsoids
      self.toggle_ellipsoids(self.flag_show_ellipsoids)
      self.update_scene = True
    elif key == ord('l') :
      self.flag_show_labels = not self.flag_show_labels
      self.update_scene = True
    elif key == ord('t') :
      self.flag_show_trace = not self.flag_show_trace
      if self.flag_show_trace :
        self.set_draw_mode("trace")
      else :
        self.set_draw_mode("all_atoms")
      self.update_scene = True
    elif key == ord('b') :
      self.set_color_mode("b")
    elif key == ord('r') :
      self.set_color_mode("rainbow")
    elif key == ord('y') :
      self.set_color_mode("element")
    elif key == 8 : # delete, at least on Mac
      self.clear_all_labels()
      self.update_scene = True
    elif key == ord('q') :
      app = wx.GetApp()
      app.Exit()
    else :
      return False

  def toggle_visibility (self, show_object, object_id=None) :
    for model_id, model in self.iter_models() :
      if object_id is None or object_id == model_id :
        print(model_id, show_object)
        self.show_object[model_id] = show_object
    self.update_scene = True

  def hide_models (self, object_id=None) :
    for model_id in self.model_ids :
      if object_id is None or model_id == object_id :
        self.show_object[model_id] = False

  def show_all (self) :
    for model_id in self.model_ids :
      self.show_object[model_id] = True

  @debug
  def set_draw_mode (self, draw_mode, object_id=None) :
    for model_id, model in self.iter_models() :
      if object_id is None or object_id == model_id :
        model.set_draw_mode(draw_mode)
    self.update_scene = True

  @debug
  def set_color_mode (self, color_mode, object_id=None) :
    for model_id, model in self.iter_models() :
      if object_id is None or object_id == model_id :
        model.set_color_mode(color_mode)
    self.update_scene = True

  def set_model_base_color (self, color, object_id=None) :
    assert len(color) == 3
    for model_id, model in self.iter_models() :
      if object_id is None or object_id == model_id :
        model.set_base_color(color)
    self.update_scene = True

  def toggle_ellipsoids (self, show_ellipsoids, object_id=None) :
    for model_id, model in self.iter_models() :
      if object_id is None or object_id == model_id :
        model.toggle_ellipsoids(show_ellipsoids)

  def toggle_hydrogens (self, show_hydrogens, object_id=None) :
    for model_id, model in self.iter_models() :
      if object_id is None or object_id == model_id :
        model.toggle_hydrogens(show_hydrogens)

  # TODO: something smarter - temporary toggle for draw_mode?
  def toggle_trace (self, show_trace, object_id=None) :
    for model_id, model in self.iter_models() :
      if object_id is None or object_id == model_id :
        if show_trace :
          model.set_draw_mode("trace")
        else :
          model.set_draw_mode("all_atoms")
    self.update_scene = True

  def toggle_ribbon (self, show_ribbon, object_id=None) :
    self.flag_show_ribbon = show_ribbon
    for model_id, model in self.iter_models() :
      if (object_id is None) or (object_id == model_id) :
        if show_ribbon :
          model.set_draw_mode("ribbon")
        else :
          model.set_draw_mode("all_atoms")
    self.update_scene = True

  def toggle_labels (self, show_labels) :
    self.flag_show_labels = show_labels

  def clear_all_labels (self) :
    for object_id, scene in six.iteritems(self.scene_objects) :
      scene.clear_labels()

  #---------------------------------------------------------------------
  def show_model_controls (self) :
    if (self.model_panel is None) :
      frame_rect = self.GetParent().GetRect()
      display_rect = wx.GetClientDisplayRect()
      x_start = frame_rect[0] + frame_rect[2]
      if (x_start > (display_rect[2] - 400)) :
        x_start = display_rect[2] - 400
      pos = (x_start, frame_rect[1] + 10)
      self.model_panel = wx_tools.ModelControlPanel(self, -1,
        title="Model controls",
        style=wx.CLOSE_BOX|wx.CAPTION|wx.SYSTEM_MENU,
        pos=pos)
      self.model_panel.Show()

  #---------------------------------------------------------------------
  # EVENTS
  @debug
  def OnUpdate (self, event) :
    self.update_scene_objects()
    if getattr(event, "recenter", False) and (not self.GL_uninitialised) :
      self.move_rotation_center_to_mcs_center()
      self.fit_into_viewport()

  def OnUpdateModel (self, event) :
    (model_id, pdb_hierarchy, atomic_bonds) = event.data
    self.update_model(model_id, pdb_hierarchy, atomic_bonds)
    self.OnRedrawGL()

  def OnAddModel (self, event) :
    (model_id, pdb_hierarchy, atomic_bonds) = event.data
    self.add_model(model_id, pdb_hierarchy, atomic_bonds)
    self.OnRedrawGL()

  def OnChar (self, *args, **kwds) :
    super(model_viewer_mixin, self).OnChar(*args, **kwds)
    if self.update_scene :
      self.OnRedrawGL()

  def OnDoubleClick (self, event) :
    self.get_pick_points((event.GetX(), event.GetY()))
    self.process_pick_points()
    if self.closest_point_i_seq is not None :
      self.recenter_on_atom(self.closest_point_object_id,
        self.closest_point_i_seq)

  def OnMouseWheel (self, event) :
    scale = event.GetWheelRotation()
    if False : #event.ShiftDown() :
      # FIXME what was this supposed to do?
      self.fog_end_offset -= scale
    else :
      self.slab_scale += 0.01 * scale
      if self.slab_scale > 1.0 :
        self.slab_scale = 1.0
      elif self.slab_scale < 0.01 :
        self.slab_scale = 0.01
    self.OnRedrawGL()

  def OnChangeModelColor (self, event) :
    menu = event.GetEventObject()
    model_id = menu.GetTitle()
    model = self.get_model(model_id)
    if model is not None :
      base_color = [ int(x*255) for x in model.base_color ]
      new_color = wx.GetColourFromUser(self, base_color)
      new_color = [ x / 255 for x in new_color ]
      model.set_base_color(new_color)
      model.refresh()
      self.update_scene = True

  def thread_safe_add_model (self, model_id, pdb_hierarchy, atomic_bonds) :
    wx.PostEvent(self, AddModelEvent(model_id, pdb_hierarchy, atomic_bonds))

  def thead_safe_update_model (self, model_id, pdb_hierarchy, atomic_bonds) :
    wx.PostEvent(self, UpdateModelEvent(model_id, pdb_hierarchy, atomic_bonds))


 *******************************************************************************


 *******************************************************************************
crys3d/wx_selection_editor.py
from __future__ import absolute_import, division, print_function

# TODO: move selection logic to separate module

from crys3d.model import model_data
from crys3d.wx_model_viewer import model_scene, model_viewer_mixin
from crys3d.reverse_selection import mouse_selection_manager
import gltbx.gl_managed
from gltbx.gl import *
from gltbx.glu import *
from gltbx import viewer_utils
from scitbx import graphics_utils
import iotbx.phil
import wx
import six
from six import string_types

viewer_phil = iotbx.phil.parse("""
include scope crys3d.wx_model_viewer.opengl_phil
selections {
  selection_color = 1.0 1.0 1.0
    .type = floats
    .style = color
  use_global_selection_color = True
    .type = bool
  line_padding = 2
    .type = int
}
""", process_includes=True)

class model_data_with_selection (model_data, mouse_selection_manager) :
  def __init__ (self, *args, **kwds) :
    self.flag_show_selection = True
    self.flag_allow_selection = True
    self.flag_show_all_selected_atoms = False
    self._cached_colors = None
    mouse_selection_manager.__init__(self)
    model_data.__init__(self, *args, **kwds)

  def get_scene_data (self) :
    if self.atoms.size() != self.visibility.atoms_visible.size() :
      self.recalculate_visibility()
    atomic_bonds = self.atomic_bonds
    #if not self.flag_show_hydrogens :
    #  atomic_bonds = atomic_bonds & ~self.hydrogen_flag
    scene = model_scene_with_selection(bonds=self.current_bonds,
      points=self.atoms.extract_xyz(),
      b_iso=self.atoms.extract_b(),
      b_aniso=self.atoms.extract_uij(),
      atom_colors=self.atom_colors,
      atom_labels=self.atom_labels,
      atom_radii=self.atom_radii,
      visibility=self.visibility,
      noncovalent_bonds=self.noncovalent_bonds,
      atomic_bonds=atomic_bonds,
      ribbon=self.ribbon)
    scene.flag_show_all_selected_atoms = self.flag_show_all_selected_atoms
    self.update_scene_data(scene)
    return scene

  def update_scene_data (self, scene) :
    if self.flag_show_hydrogens :
      scene.update_selection(self.atom_selection)
    else :
      scene.update_selection(self.atom_selection & ~self.hydrogen_flag)
    model_data.update_scene_data(self, scene)

  def update_structure (self, pdb_hierarchy, atomic_bonds,
      special_position_settings=None,
      mmtbx_selection_function=None) :
    model_data.update_structure(self, pdb_hierarchy, atomic_bonds,
      special_position_settings=special_position_settings)
    mouse_selection_manager.update_selection_handlers(self, pdb_hierarchy,
      mmtbx_selection_function=mmtbx_selection_function,
      special_position_settings=special_position_settings)

  def recalculate_visibility (self) :
    model_data.recalculate_visibility(self)
    self.visibility.get_selection_visibility(
      bonds          = self.current_bonds,
      atoms_selected = self.atom_selection)

  def selection_callback (self, *args, **kwds) :
    self.recalculate_visibility()
    mouse_selection_manager.selection_callback(self, *args, **kwds)

  def highlight_atoms (self, selection_string) :
    if selection_string is None :
      self.is_changed = True
      if self._cached_colors is not None :
        self.atom_colors = self._cached_colors
      else :
        self.set_color_mode(self.color_mode)
    else :
      atom_selection = self.get_atom_selection(selection_string)
      if atom_selection is not None and atom_selection.count(True) != 0 :
        self._cached_colors = self.atom_colors
        #self.set_color_mode(self.color_mode)
        self.is_changed = True
        self.atom_colors = graphics_utils.scale_selected_colors(
          input_colors=self.atom_colors,
          selection=~atom_selection,
          scale=0.5)

#-----------------------------------------------------------------------
class model_scene_with_selection (model_scene) :
  def __init__ (self, *args, **kwds) :
    from scitbx.array_family import flex
    self.flag_show_all_selected_atoms = False
    model_scene.__init__(self, *args, **kwds)
    self.selection_draw_mode = "bonds_and_atoms"
    self.update_selection(flex.bool(self.points.size(), False))

  def clear_lists (self) :
    self.selection_display_list = None
    model_scene.clear_lists(self)

  def update_selection (self, atom_selection) :
    self.atom_selection = atom_selection
    self.selection_i_seqs = atom_selection.iselection()
    self.selected_atom_count = self.selection_i_seqs.size()
    self.selection_display_list = None

  def update_visibility (self, visibility) :
    model_scene.update_visibility(self, visibility)
    if self.flag_show_all_selected_atoms :
      self.selected_points_visible = visibility.selected_points_visible
      self.selected_bonds_visible = self.atom_selection
    else :
      self.selected_points_visible = visibility.selected_points_visible
      self.selected_bonds_visible = visibility.selected_bonds_visible

  def get_selected_xyz (self) :
    points = self.points
    for i_seq in self.selection_i_seqs :
      yield points[i_seq]

  # XXX: this is still gross.
  def draw_selection (self, color, use_global_color=False) :
    from scitbx.array_family import flex
    if self.selected_atom_count == 0 :
      return
    if self.selection_display_list is None :
      if use_global_color :
        selection_colors = flex.vec3_double(self.points.size(), color)
      else :
        selection_colors = self.atom_colors
      self.selection_display_list = gltbx.gl_managed.display_list()
      self.selection_display_list.compile()
      draw_mode = self.selection_draw_mode
      if draw_mode is None :
        draw_mode = "bonds_and_atoms"
      if draw_mode == "bonds_and_atoms" :
        viewer_utils.draw_points(
          points         = self.points,
          atom_colors    = selection_colors,
          points_visible = self.selected_points_visible,
          cross_radius   = 0.4)
        if self.flag_show_all_selected_atoms :
          bonds = self.atomic_bonds
        else :
          bonds = self.bonds
        viewer_utils.draw_bonds(
          points        = self.points,
          bonds         = bonds,
          atom_colors   = selection_colors,
          bonds_visible = self.selected_bonds_visible)
      elif draw_mode == "points" :
        viewer_utils.draw_points(
          points         = self.points,
          atom_colors    = selection_colors,
          points_visible = self.atom_selection,
          cross_radius   = 0.4)
      elif draw_mode == "spheres" :
        atom_selection = self.atom_selection
        atom_radii = self.atom_radii
        glPolygonMode(GL_FRONT_AND_BACK, GL_FILL)
        for i_seq, point in enumerate(self.points) :
          if atom_selection[i_seq] :
            glColor3f(*selection_colors[i_seq])
            glPushMatrix()
            glTranslated(*point)
            gltbx.util.SolidSphere(radius=atom_radii[i_seq],
                                   slices=50, stacks=50)
            glPopMatrix()
      self.selection_display_list.end()
    self.selection_display_list.call()

########################################################################
# VIEWER CLASS
class selection_editor_mixin (model_viewer_mixin) :
  mouse_modes = ["Rotate view", "Toggle chain", "Toggle residue",
    "Toggle atom", "Select range", "Deselect range", "Select single residue",
    "Select single atom", "Select residue pair", "Select atom pair"]
  def __init__ (self, *args, **kwds) :
    self.left_button_mode = 0
    self.flag_select_all_conformers = True
    self.flag_show_selections = True
    self.flag_enable_mouse_selection = True
    self.current_atom_i_seq = None
    self.current_object_id = None
    self._callback = print_cb
    self._in_range_selection = False
    self.buffer_selection_sphere = 5
    model_viewer_mixin.__init__(self, *args,**kwds)
    self.settings = viewer_phil.extract()

  def DrawGL (self) :
    model_viewer_mixin.DrawGL(self)
    if self.flag_show_selections :
      self.draw_selections()

  def draw_selections (self) :
    line_width = (self.settings.opengl.line_width +
                  (2 * self.settings.selections.line_padding))
    glLineWidth(line_width)
    glEnable(GL_LINE_SMOOTH)
    glHint(GL_LINE_SMOOTH_HINT, GL_NICEST)
    for object_id, scene in six.iteritems(self.scene_objects) :
      if self.show_object[object_id] :
        scene.draw_selection(color=self.settings.selections.selection_color,
          use_global_color=self.settings.selections.use_global_selection_color)

  #---------------------------------------------------------------------
  def zoom_selections (self) :
    from scitbx.array_family import flex
    points = flex.vec3_double()
    for object_id, scene in six.iteritems(self.scene_objects) :
      if self.show_object[object_id] :
        for point in scene.get_selected_xyz() :
          points.append(point)
    if points.size() == 0 :
      for object_id, scene in six.iteritems(self.scene_objects) :
        if self.show_object[object_id] :
          points.extend(scene.points)
    if points.size() != 0 :
      self.update_mcs(points, buffer=self.buffer_selection_sphere)

  def set_selection (self, object_id, selection_string) :
    for model_id, model in self.iter_models() :
      if object_id is None or model_id == object_id :
        model.apply_selection(selection_string)
        self.update_scene = True

  def clear_selections (self) :
    for model_id, model in self.iter_models() :
      model.clear_selection()
    self.update_scene = True

  def add_model (self, model_id, pdb_hierarchy, atomic_bonds,
      xray_structure=None,
      mmtbx_selection_function=None) :
    assert isinstance(model_id, string_types)
    special_position_settings = None
    if (xray_structure is not None) :
      special_position_settings = xray_structure.special_position_settings()
    model = model_data_with_selection(model_id, pdb_hierarchy, atomic_bonds,
      special_position_settings=special_position_settings,
      base_color=self.settings.opengl.base_atom_color)
    model.set_mmtbx_selection_function(mmtbx_selection_function)
    model.set_selection_callback(self._callback)
    self._add_model(model_id, model)

  def process_key_stroke (self, key) :
    if key == ord('S') :
      self.flag_show_selections = not self.flag_show_selections
      self.update_scene = True
    elif key == ord('z') :
      self.zoom_selections()
    elif key >= 49 and key <= 57 : # 1-7
      self.set_left_button_mode(key - 49)
    elif key == 27 : # escape
      self.clear_selections()
      self.update_scene = True
    else :
      return model_viewer_mixin.process_key_stroke(self,key)
    return True

  def set_left_button_mode (self, mode) :
    self.left_button_mode = mode
    self._in_range_selection = False

  def show_all_selected_atoms (self, show=True) :
    #self.flag_show_all_selected_atoms = show
    for model_id, model in self.iter_models() :
      model.flag_show_all_selected_atoms = show
    for object_id, scene in six.iteritems(self.scene_objects) :
      scene.flag_show_all_selected_atoms = show
    self.update_scene = True

  def highlight_selection (self, object_id, selection_string) :
    for model_id, model in self.iter_models() :
      if object_id is None or model_id == object_id :
        model.highlight_atoms(selection_string)
        self.update_scene = True

  def clear_highlights (self) :
    for model_id, model in self.iter_models() :
      model.highlight_atoms(None)
    self.update_scene = True

  #---------------------------------------------------------------------
  def set_selection_callback (self, callback) :
    assert hasattr(callback, "__call__")
    self._callback = callback

  def set_overwrite_mode (self, overwrite=True) :
    for model_id, model in self.iter_models() :
      model.set_overwrite_mode(overwrite)

  def pick_selection_object (self, object_id) :
    for model_id in self.pick_object :
      if model_id == object_id :
        self.pick_object[model_id] = True
        self.show_object[model_id] = True
      else :
        self.pick_object[model_id] = False

  def save_selected_atom (self) : #, object_id, i_seq) :
    self.current_object_id = self.closest_point_object_id
    self.current_atom_i_seq = self.closest_point_i_seq

  def toggle_chain_selection (self) :
    model = self.get_model(self.current_object_id)
    if model is not None :
      model.toggle_chain_selection(self.current_atom_i_seq)
      return True

  def toggle_residue_selection (self) :
    model = self.get_model(self.current_object_id)
    if model is not None :
      model.toggle_residue_selection(self.current_atom_i_seq,
        ignore_altloc=self.flag_select_all_conformers)
      return True

  def toggle_atom_selection (self) :
    model = self.get_model(self.current_object_id)
    if model is not None :
      model.toggle_atom_selection(self.current_atom_i_seq)
      return True

  def process_range_selection (self, deselect=False) :
    model = self.get_model(self.current_object_id)
    if model is not None :
      if self._in_range_selection :
        try :
          model.end_range_selection(self.current_atom_i_seq, deselect,
            ignore_altloc=self.flag_select_all_conformers)
        finally :
          self._in_range_selection = False
      else :
        model.start_range_selection(self.current_atom_i_seq)
        self._in_range_selection = True
      return True

  def process_range_deselection (self) :
    return self.process_range_selection(deselect=True)

  def select_single_residue (self) :
    model = self.get_model(self.current_object_id)
    if model is not None :
      model.select_single_residue(self.current_atom_i_seq)
      return True

  def select_single_atom (self) :
    model = self.get_model(self.current_object_id)
    if model is not None :
      model.select_single_atom(self.current_atom_i_seq)
      return True

  def select_residue_pair (self) :
    model = self.get_model(self.current_object_id)
    if model is not None :
      model.select_pair(self.current_atom_i_seq)
      return True

  def select_atom_pair (self) :
    model = self.get_model(self.current_object_id)
    if model is not None :
      model.select_pair(self.current_atom_i_seq, selection_type="atom")
      return True

  # TODO: finish this?
  def context_selection_menu (self) :
    menu = wx.Menu()
    toggle_chain = menu.Append(-1, "Toggle chain selection")
    self.Bind(wx.EVT_MENU, self.OnToggleChain, toggle_chain)
    self.PopupMenu(menu)
    menu.Destroy()

  def OnLeftClick (self, event) :
    model_viewer_mixin.OnLeftClick(self, event)
    if self.left_button_mode != 0 and not self.was_dragged :
      self.get_pick_points((self.xmouse, self.ymouse))
      self.process_pick_points()
      if (self.closest_point_i_seq is not None and
          self.flag_enable_mouse_selection) :
        self.save_selected_atom()
        methods = ["toggle_chain_selection",
                   "toggle_residue_selection",
                    "toggle_atom_selection",
                    "process_range_selection",
                    "process_range_deselection",
                    "select_single_residue",
                    "select_single_atom",
#                    "context_selection_menu",
                    "select_residue_pair",
                    "select_atom_pair",]
        for i, method in enumerate(methods) :
          if self.left_button_mode == (i + 1) :
            self.update_scene = getattr(self, method).__call__()
            if method == "select_single_residue" :
              self.show_all_selected_atoms()
            break

  def OnDoubleClick (self, event) :
    if self.left_button_mode == 0 :
      model_viewer_mixin.OnDoubleClick(self, event)

  # Handlers for selection menu events
  def OnToggleChain (self, event) :
    pass

  def OnToggleResidue (self, event) :
    pass

def print_cb (selection_string, atom_selection) :
  print("%s (%s)" % (selection_string, atom_selection.iselection().size()))

#---end


 *******************************************************************************


 *******************************************************************************
crys3d/wx_tools.py
from __future__ import absolute_import, division, print_function

import wx
from six.moves import zip

draw_modes = [
  ("trace", "Backbone trace"),
  ("all_atoms", "All atoms"),
  ("bonded_only", "Bonded atoms")
]
draw_flags = [ ("flag_show_hydrogens", "Show hydrogens"),
               ("flag_show_ellipsoids", "Show B-factor ellipsoids"),
               ("flag_show_labels", "Show labels"),
               ("flag_show_noncovalent_bonds", "Show non-covalent bonds"), ]
color_modes = [ ("rainbow", "Sequence (rainbow)"),
                ("b", "Isotropic B-factor"),
                ("element", "Atomic element"),
                ("chain", "Chain ID"), ]

def set_tiny_font (control) :
  font = control.GetFont()
  font.SetPointSize(10)
  control.SetFont(font)

def set_tiny_bold_font (control) :
  font = control.GetFont()
  font.SetPointSize(10)
  font.SetWeight(wx.FONTWEIGHT_BOLD)
  control.SetFont(font)


class EllipsizePaths(object):
  def __init__(self, parent, pathlst):
    self.csize = (300, -1)
    self.__ellipsispaths__ = [ (p, wx.Control.Ellipsize(p, wx.ClientDC(parent),
                                 wx.ELLIPSIZE_START,
                                  self.csize[0]-60)
                                )
                          for p in pathlst
                          ]
  def length(self):
    return len(self.__ellipsispaths__)
  def getpaths(self):
    return [ep[0] for ep in self.__ellipsispaths__]
  def getpath(self, i):
    return self.__ellipsispaths__[i][0]
  def getellipspaths(self):
    return [ep[1] for ep in self.__ellipsispaths__]
  def getellipspath(self, i):
    return self.__ellipsispaths__[i][1]


class ModelControlPanel (wx.MiniFrame) :
  def __init__ (self, *args, **kwds) :
    super(ModelControlPanel, self).__init__(*args, **kwds)
    self.Bind(wx.EVT_CLOSE, self.OnClose, self)
    self.Bind(wx.EVT_WINDOW_DESTROY, self.OnDestroy, self)
    self.parent = self.GetParent()
    self.model_id = None
    self.inner_panel = wx.Panel(self, -1)
    self.panel_sizer = wx.BoxSizer(wx.VERTICAL)
    self.inner_panel.SetSizer(self.panel_sizer)
    self.panel1 = wx.Panel(self.inner_panel, -1, style=wx.RAISED_BORDER)
    self.panel_sizer.Add(self.panel1, 0)
    self.sizer = wx.BoxSizer(wx.VERTICAL)
    self.sizer.Add(self.inner_panel, 0, wx.EXPAND)
    szr1 = wx.BoxSizer(wx.HORIZONTAL)
    self.panel1.SetSizer(szr1)
    txt1 = wx.StaticText(self.panel1, -1, "Model:")
    set_tiny_bold_font(txt1)
    self.ep = EllipsizePaths(self, self.parent.model_ids)
    chooser = wx.Choice(self.panel1, -1,
      choices = self.ep.getellipspaths() ,
      size=self.ep.csize)
    set_tiny_font(chooser)
    self.Bind(wx.EVT_CHOICE, self.OnChooseModel, chooser)
    self.model_chooser = chooser
    szr1.Add(txt1, 0, wx.ALL|wx.ALIGN_CENTER_VERTICAL, 5)
    szr1.Add(chooser, 0, wx.RIGHT|wx.TOP|wx.BOTTOM|wx.ALIGN_CENTER_VERTICAL, 5)
    self.panel2 = wx.Panel(self.inner_panel, -1)
    if (self.ep.length() > 0) :
      chooser.SetSelection(0)
      self.set_model(self.ep.getpath(0))
    else :
      self.sizer.Fit(self.inner_panel)
      self.Fit()
    self.panel_sizer.Layout()


  def refresh_model_list (self) :
    self.ep = EllipsizePaths(self, self.parent.model_ids)
    models = self.ep.getpaths()
    nsel = min( self.model_chooser.GetSelection(), self.ep.length() -1 )
    current_model = self.ep.getpath(nsel) if nsel >= 0 else None
    self.model_chooser.SetItems( self.ep.getellipspaths() )
    if (current_model in models) :
      self.model_chooser.SetSelection( nsel)
    else :
      self.set_model(None)

  def set_model (self, model_id) :
    self.panel_sizer.Detach(self.panel2)
    self.panel2.Destroy()
    self.model_id = model_id
    self.panel2 = wx.Panel(self.inner_panel, -1)
    self.panel_sizer.Add(self.panel2, 1)
    if (model_id is not None) :
      p = self.panel2
      szr2 = wx.BoxSizer(wx.VERTICAL)
      self.panel2.SetSizer(szr2)
      visibility_ctrl = wx.CheckBox(p, -1,
        label="Model visible")
      if self.parent.show_object.get(model_id, False) :
        visibility_ctrl.SetValue(True)
      self.Bind(wx.EVT_CHECKBOX, self.OnSetVisibility, visibility_ctrl)
      set_tiny_bold_font(visibility_ctrl)
      szr2.Add(visibility_ctrl, 0, wx.ALL, 5)
      szr3 = wx.BoxSizer(wx.HORIZONTAL)
      txt = wx.StaticText(p, -1, "Show atoms:", size=(120,-1))
      set_tiny_bold_font(txt)
      szr3.Add(txt, 0, wx.ALL|wx.ALIGN_CENTER_VERTICAL, 5)
      viewer = self.parent
      model = viewer.get_model(model_id)
      modes = [ label for name, label in draw_modes ]
      mode_choice = wx.Choice(p, -1,
        choices=modes)
      set_tiny_font(mode_choice)
      for (name, label) in draw_modes :
        if (model.draw_mode == name) :
          mode_choice.SetStringSelection(label)
          break
      self.Bind(wx.EVT_CHOICE, self.OnChooseDrawMode, mode_choice)
      szr3.Add(mode_choice, 0, wx.RIGHT|wx.TOP|wx.BOTTOM|wx.ALIGN_CENTER_VERTICAL,
        5)
      szr2.Add(szr3)
      szr4 = wx.BoxSizer(wx.HORIZONTAL)
      txt2 = wx.StaticText(p, -1, "Color by:", size=(120,-1))
      set_tiny_bold_font(txt2)
      szr4.Add(txt2, 0, wx.ALL|wx.ALIGN_CENTER_VERTICAL, 5)
      color_choice = wx.Choice(p, -1,
        choices=[ label for name, label in color_modes ])
      set_tiny_font(color_choice)
      for name, label in color_modes :
        if (model.color_mode == name) :
          color_choice.SetStringSelection(label)
          break
      self.Bind(wx.EVT_CHOICE, self.OnChooseColorMode, color_choice)
      szr4.Add(color_choice, 0,
        wx.RIGHT|wx.TOP|wx.BOTTOM|wx.ALIGN_CENTER_VERTICAL, 5)
      szr2.Add(szr4)
      txt3 = wx.StaticText(p, -1, "Other display options:")
      set_tiny_bold_font(txt3)
      szr2.Add(txt3, 0, wx.ALL, 5)
      szr5 = wx.BoxSizer(wx.HORIZONTAL)
      szr5.Add((10,-1))
      szr2.Add(szr5)
      szr6 = wx.GridSizer(cols=2)
      szr5.Add(szr6)
      for name, label in draw_flags :
        box = wx.CheckBox(p, -1, label=label)
        self.Bind(wx.EVT_CHECKBOX, self.OnSetFlag, box)
        box.SetValue(getattr(model, name))
        set_tiny_font(box)
        szr6.Add(box)
      szr2.Fit(p)
      delete_btn = wx.Button(p, -1, label="Delete model")
      set_tiny_font(delete_btn)
      self.Bind(wx.EVT_BUTTON, self.OnDeleteModel, delete_btn)
      szr2.Add(delete_btn, 0, wx.ALL|wx.ALIGN_CENTER_HORIZONTAL, 5)
    self.panel_sizer.Layout()
    self.sizer.Fit(self.inner_panel)
    self.Fit()

  def OnChooseModel (self, event) :
    model_id = event.GetEventObject().GetSelection()
    self.set_model(self.ep.getpath(model_id))

  def OnSetVisibility (self, event) :
    visible = event.GetEventObject().GetValue()
    self.parent.toggle_visibility(visible, self.model_id)
    self.parent.Refresh()

  def OnChooseDrawMode (self, event) :
    mode_label = str(event.GetEventObject().GetStringSelection())
    model = self.parent.get_model(self.model_id)
    if (model is not None) :
      for mode, label in draw_modes :
        if (mode_label == label) :
          model.set_draw_mode(mode)
          self.parent.update_scene = True
          self.parent.Refresh()
          break

  def OnChooseColorMode (self, event) :
    mode_label = str(event.GetEventObject().GetStringSelection())
    model = self.parent.get_model(self.model_id)
    if (model is not None) :
      for mode, label in color_modes :
        if (mode_label == label) :
          model.set_color_mode(mode)
          self.parent.update_scene = True
          self.parent.Refresh()
          break

  def OnSetFlag (self, event) :
    box = event.GetEventObject()
    flag_value = box.GetValue()
    label = str(box.GetLabel())
    model = self.parent.get_model(self.model_id)
    if (model is not None) :
      for flag_name, flag_label in draw_flags :
        if (label == flag_label) :
          setattr(model, flag_name, flag_value)
          model.refresh()
          self.parent.update_scene = True
          self.parent.Refresh()
          break

  def OnClose (self, event) :
    self.Destroy()

  def OnDestroy (self, event) :
    self.parent.model_panel = None

  def OnDeleteModel (self, event) :
    self.parent.delete_model(self.model_id)
    self.refresh_model_list()
    self.parent.Refresh()
    self.Refresh()

class MapControlPanel (wx.MiniFrame) :
  def __init__ (self, *args, **kwds) :
    super(MapControlPanel, self).__init__(*args, **kwds)
    self.Bind(wx.EVT_CLOSE, self.OnClose, self)
    self.Bind(wx.EVT_WINDOW_DESTROY, self.OnDestroy, self)
    self.parent = self.GetParent()
    self.map_id = None
    self.inner_panel = wx.Panel(self, -1)
    self.panel_sizer = wx.BoxSizer(wx.VERTICAL)
    self.inner_panel.SetSizer(self.panel_sizer)
    self.panel1 = wx.Panel(self.inner_panel, -1, style=wx.RAISED_BORDER)
    self.panel_sizer.Add(self.panel1, 0)
    self.sizer = wx.BoxSizer(wx.VERTICAL)
    self.sizer.Add(self.inner_panel, 0, wx.EXPAND)
    szr1 = wx.BoxSizer(wx.HORIZONTAL)
    self.panel1.SetSizer(szr1)
    txt1 = wx.StaticText(self.panel1, -1, "Map:")
    set_tiny_bold_font(txt1)
    self.ep = EllipsizePaths(self, self.parent.map_ids)
    chooser = wx.Choice(self.panel1, -1,
      choices = self.ep.getellipspaths() ,
      size=self.ep.csize)
    set_tiny_font(chooser)
    self.Bind(wx.EVT_CHOICE, self.OnChooseMap, chooser)
    self.map_chooser = chooser
    szr1.Add(txt1, 0, wx.ALL|wx.ALIGN_CENTER_VERTICAL, 5)
    szr1.Add(chooser, 0, wx.RIGHT|wx.TOP|wx.BOTTOM|wx.ALIGN_CENTER_VERTICAL, 5)
    self.panel2 = wx.Panel(self.inner_panel, -1)
    if (len(self.parent.map_ids) > 0) :
      chooser.SetSelection(0)
      self.set_map(self.parent.map_ids[0])
    else :
      self.sizer.Fit(self.inner_panel)
      self.Fit()
    self.panel_sizer.Layout()

  def refresh_map_list (self) :
    self.ep = EllipsizePaths(self, self.parent.map_ids)
    maps = self.ep.getpaths()
    nsel = min( self.map_chooser.GetSelection(), self.ep.length() -1 )
    current_map = self.ep.getpath(nsel) if nsel >= 0 else None
    self.map_chooser.SetItems( self.ep.getellipspaths() )
    #import code, traceback; code.interact(local=locals(), banner="".join( traceback.format_stack(limit=10) ) )
    if (current_map in maps) :
      self.map_chooser.SetSelection( nsel)
      self.set_map(current_map)
    else :
      self.set_map(None)

  def set_map (self, map_id) :
    self.panel_sizer.Detach(self.panel2)
    self.panel2.Destroy()
    self.map_id = map_id
    if (map_id is not None) :
      map_object = self.parent.get_map(map_id)
      self.panel2 = wx.Panel(self.inner_panel, -1)
      self.panel_sizer.Add(self.panel2, 1)
      p = self.panel2
      szr2 = wx.BoxSizer(wx.VERTICAL)
      self.panel2.SetSizer(szr2)
      visibility_ctrl = wx.CheckBox(p, -1,
        label="Map visible")
      visibility_ctrl.SetValue(self.parent.show_object[map_id])
      set_tiny_bold_font(visibility_ctrl)
      szr2.Add(visibility_ctrl, 0, wx.ALL, 5)
      self.Bind(wx.EVT_CHECKBOX, self.OnSetVisibility, visibility_ctrl)
      panel = self.panel2
      self.ctrls = []
      for iso_level, color in zip(map_object.iso_levels, map_object.colors) :
        level_sizer = wx.BoxSizer(wx.HORIZONTAL)
        slider = wx.Slider(panel,
                           size=(160,-1),
                           minValue=-100,
                           maxValue=100,
                           value=int(iso_level * 10),
                           style=wx.SL_AUTOTICKS)
        level_txt = wx.TextCtrl(panel,
                                size=(64,-1),
                                style=wx.TE_READONLY|wx.TE_RIGHT)
        set_tiny_font(level_txt)
        level_txt.SetValue("%.2f" % iso_level)
        initial_color = [ int(x*255) for x in color ]
        color_ctrl = wx.lib.colourselect.ColourSelect(panel,
                                                      colour=initial_color)
        level_sizer.Add(slider, 0, wx.ALL, 5)
        level_sizer.Add(level_txt, 0, wx.ALL, 5)
        level_sizer.Add(color_ctrl, 0, wx.ALL, 5)
        szr2.Add(level_sizer, 1, wx.ALL, 5)
        self.ctrls.append((slider, level_txt, color_ctrl))
      self.attach_mouse_wheel = wx.CheckBox(panel,
        label="Attach mouse wheel to this map")
      set_tiny_bold_font(self.attach_mouse_wheel)
      self.attach_mouse_wheel.SetValue(map_id == self.parent.selected_map_id)
      szr2.Add(self.attach_mouse_wheel, 0, wx.ALL, 5)
      self.Bind(wx.EVT_CHECKBOX, self.OnAttachMouse, self.attach_mouse_wheel)
      self.Bind(wx.EVT_SLIDER, self.OnUpdate)
      self.Bind(wx.lib.colourselect.EVT_COLOURSELECT, self.OnUpdate)
      delete_btn = wx.Button(p, -1, label="Delete map")
      set_tiny_font(delete_btn)
      self.Bind(wx.EVT_BUTTON, self.OnDeleteMap, delete_btn)
      szr2.Fit(panel)
      szr2.Add(delete_btn, 0, wx.ALL|wx.ALIGN_CENTER_HORIZONTAL, 5)
    self.panel_sizer.Layout()
    self.sizer.Fit(self.inner_panel)
    self.Fit()

  def OnUpdate (self, event) :
    source_ctrl = event.GetEventObject()
    map_object = self.parent.get_map(self.map_id)
    for i, (s, t, c) in enumerate(self.ctrls) :
      if source_ctrl is s :
        new_level = s.GetValue() / 10.0
        map_object.iso_levels[i] = new_level
        t.SetValue("%.2f" % new_level)
        self.parent.update_maps = True
      elif source_ctrl is c :
        new_color = c.GetValue()
        new_color = [ x / 255.0 for x in new_color ]
        map_object.colors[i] = new_color
        self.parent.update_maps = True
    self.parent.OnRedrawGL()

  def refresh_iso_levels (self) :
    map_object = self.parent.get_map(self.map_id)
    levels = map_object.iso_levels
    assert len(levels) == len(self.ctrls)
    for i, (s, t, c) in enumerate(self.ctrls) :
      s.SetValue(int(10 * levels[i]))
      t.SetValue("%.2f" % levels[i])

  def refresh_attach_mouse (self) :
    self.attach_mouse_wheel.SetValue(self.map_id==self.parent.selected_map_id)

  def OnAttachMouse (self, event) :
    if self.attach_mouse_wheel.GetValue() == True :
      self.parent.set_selected_map(self.map_id)
    else :
      self.parent.set_selected_map(None)

  def OnChooseMap (self, event) :
    map_id = event.GetEventObject().GetSelection()
    #import code, traceback; code.interact(local=locals(), banner="".join( traceback.format_stack(limit=10) ) )
    self.set_map(self.ep.getpath(map_id))

  def OnSetVisibility (self, event) :
    visible = event.GetEventObject().GetValue()
    self.parent.toggle_visibility(visible, self.map_id)
    self.parent.Refresh()

  def OnClose (self, event) :
    self.Destroy()

  def OnDestroy (self, event) :
    self.parent.map_panel = None

  def OnDeleteMap (self, event) :
    self.parent.delete_map(self.map_id)
    self.refresh_map_list()
    self.parent.Refresh()


 *******************************************************************************
