

 *******************************************************************************
mmtbx/ncs/__init__.py


 *******************************************************************************


 *******************************************************************************
mmtbx/ncs/cartesian_restraints.py
from __future__ import absolute_import, division, print_function
from scitbx.array_family import flex

import boost_adaptbx.boost.python as bp
from six.moves import zip
ext = bp.import_ext("mmtbx_ncs_cartesian_restraints_ext")
from mmtbx_ncs_cartesian_restraints_ext import *

from cctbx import adptbx
import scitbx.restraints
from scitbx.math import superpose
from scitbx import matrix
from libtbx.str_utils import show_string
from libtbx.utils import Sorry
from libtbx import adopt_init_args
from itertools import count
import sys
from libtbx.str_utils import line_breaker
from mmtbx.ncs.ncs_params import global_ncs_params
from mmtbx.ncs.ncs_restraints_group_list import class_ncs_restraints_group_list

class cartesian_ncs_manager(object):
  def __init__(self, model, ncs_params, ext_groups=None):
    # create bunch of group objects
    self.ncs_params = ncs_params
    self.n_excessive_site_distances = None
    self.ncs_restraints_group_list = class_ncs_restraints_group_list()
    if self.ncs_params is None:
      self.ncs_params = global_ncs_params.extract().ncs
    if ext_groups is not None:
      self.groups_list = ext_groups
    else:
      self.groups_list = []
      ncs_obj = model.get_ncs_obj()
      if ncs_obj is None:
        return
      self.ncs_restraints_group_list = ncs_obj.get_ncs_restraints_group_list()
      ncs_groups_selection_string_list = self.ncs_restraints_group_list.get_array_of_str_selections()
      for i_gr, gr in enumerate(self.ncs_restraints_group_list):
        n_copies = gr.get_number_of_copies()
        registry = pair_registry(n_seq=model.get_number_of_atoms(), n_ncs=n_copies+1)
        for i_copy, c in enumerate(gr.copies):
          for i_seq, j_seq in zip(gr.master_iselection, c.iselection):
            stat, i_diag = registry.enter(
                i_seq=i_seq, j_seq=j_seq, j_ncs=i_copy+1)
        for i_pair,pair in enumerate(registry.selection_pairs()):
          if (pair[0].size() < 2):
            detail = ["do not produce any pairs",
                      "produce only one pair"][pair[0].size()]
            raise Sorry("\n".join([
              "NCS restraints selections %s of matching atoms:" % detail,
              "  Reference selection: %s" % show_string(self.selection_strings[0]),
              "      Other selection: %s" % show_string(
                self.selection_strings[i_pair+1])]))
        g = _group(selection_strings=ncs_groups_selection_string_list[i_gr],
            registry=registry,
            u_average_min=1.e-6,)
        self.groups_list.append(g)

  def select(self, selection):
    iselection = selection
    if isinstance(selection, flex.bool):
      iselection = selection.iselection()
    ext_groups = []
    for group in self.groups_list:
      ext_groups.append(group.select(iselection))
    new_manager = cartesian_ncs_manager(
        model=None,
        ncs_params=self.ncs_params,
        ext_groups=ext_groups)
    new_manager.ncs_restraints_group_list = \
        self.ncs_restraints_group_list.select(selection)
    return new_manager

  def energies_adp_iso(self,
        u_isos,
        average_power,
        compute_gradients=True,
        gradients=None,
        normalization=False):
    result = scitbx.restraints.energies(
      compute_gradients=compute_gradients,
      gradients=gradients,
      gradients_size=u_isos.size(),
      gradients_factory=flex.double,
      normalization=normalization)
    result.rms_with_respect_to_averages = []
    if (self.ncs_params.b_factor_weight is None
        or self.ncs_params.b_factor_weight <= 0):
      result.rms_with_respect_to_averages = [None]*len(self.groups_list)
    else:
      for group in self.groups_list:
        contribution = group.energies_adp_iso(
            u_isos=u_isos,
            b_factor_weight=self.ncs_params.b_factor_weight,
            average_power=average_power,
            compute_gradients=compute_gradients,
            gradients=result.gradients)
        result += contribution
        result.rms_with_respect_to_averages.append(
            contribution.rms_with_respect_to_average)
    result.finalize_target_and_gradients()
    return result

  def show_adp_iso_differences_to_average(self,
         u_isos,
         site_labels,
         out=None,
         prefix=""):
    if (self.ncs_params.b_factor_weight is None
        or self.ncs_params.b_factor_weight <= 0):
      print(prefix+"  b_factor_weight: %s  =>  restraints disabled" % (
          str(self.ncs_params.b_factor_weight)), file=out)
      return
    for i_group,group in enumerate(self.groups_list):
      print(prefix + "NCS restraint group %d:" % (i_group+1), file=out)
      energies_adp_iso = group.energies_adp_iso(
        u_isos=u_isos,
        b_factor_weight=self.ncs_params.b_factor_weight,
        average_power=1,
        compute_gradients=False)
      print(prefix + "  weight: %.6g" % energies_adp_iso.weight, file=out)
      energies_adp_iso.show_differences_to_average(
        site_labels=site_labels, out=out, prefix=prefix+"  ")

  def get_n_groups(self):
    return len(self.groups_list)

  def register_additional_isolated_sites(self, number):
    for group in self.groups_list:
      group.register_additional_isolated_sites(number=number)

  def compute_operators(self, sites_cart):
    for group in self.groups_list:
      group.compute_operators(sites_cart=sites_cart)

  def energies_sites(self,
        sites_cart,
        compute_gradients=True,
        gradients=None,
        normalization=False):
    self.compute_operators(sites_cart=sites_cart)
    result = scitbx.restraints.energies(
      compute_gradients=compute_gradients,
      gradients=gradients,
      gradients_size=sites_cart.size(),
      gradients_factory=flex.vec3_double,
      normalization=normalization)
    result.rms_with_respect_to_averages = []
    if (self.ncs_params.coordinate_sigma is None
        or self.ncs_params.coordinate_sigma <= 0):
      result.rms_with_respect_to_averages = [None]*len(self.groups_list)
    else:
      for group in self.groups_list:
        contribution = group.energies_sites(
            sites_cart=sites_cart,
            coordinate_sigma = self.ncs_params.coordinate_sigma,
            compute_gradients=compute_gradients,
            gradients=result.gradients)
        result += contribution
        result.rms_with_respect_to_averages.append(
            contribution.rms_with_respect_to_average)
    result.finalize_target_and_gradients()
    return result

  def show_operators(self, sites_cart, out=None, prefix=""):
    for i_group,group in enumerate(self.groups_list):
      print(prefix + "NCS restraint group %d:" % (i_group+1), file=out)
      group.show_operators(sites_cart=sites_cart, out=out, prefix=prefix+"  ")

  def as_pdb(self, sites_cart, out):
    result = out
    pr = "REMARK   3  "
    print(pr+"NCS DETAILS.", file=result)
    print(pr+" NUMBER OF NCS GROUPS : %-6d" % self.get_n_groups(), file=result)
    for i_group, group in enumerate(self.groups_list):
      print(pr+" NCS GROUP : %-6d"%(i_group+1), file=result)
      selection_strings = group.selection_strings
      for i_op,pair,mx,rms in zip(
          count(1),
          group.selection_pairs,
          group.matrices,
          group.rms):
        print(pr+"  NCS OPERATOR : %-d" % i_op, file=result)
        lines = line_breaker(selection_strings[0], width=34)
        for i_line, line in enumerate(lines):
          if(i_line == 0):
            print(pr+"   REFERENCE SELECTION: %s"%line, file=result)
          else:
            print(pr+"                      : %s"%line, file=result)
        lines = line_breaker(selection_strings[i_op], width=34)
        for i_line, line in enumerate(lines):
          if(i_line == 0):
            print(pr+"   SELECTION          : %s"%line, file=result)
          else:
            print(pr+"                      : %s"%line, file=result)
        print(pr+"   ATOM PAIRS NUMBER  : %-d" % len(pair[0]), file=result)
        print(pr+"   RMSD               : %-10.3f" % rms, file=result)
    return result.getvalue()

  def as_cif_block(self, cif_block, hierarchy, scattering_type):
    self.ncs_restraints_group_list.as_cif_block(
        cif_block=cif_block,
        hierarchy=hierarchy,
        scattering_type=scattering_type,
        ncs_type='cartesian NCS')
    return cif_block

  def get_n_excessive_sites_distances(self):
    return self.n_excessive_site_distances

  def show_sites_distances_to_average(self,
         sites_cart,
         site_labels,
         excessive_distance_limit=None,
         out=None,
         prefix=""):
    self.compute_operators(sites_cart)
    n_excessive = 0
    if (self.ncs_params.coordinate_sigma is None or
        self.ncs_params.coordinate_sigma <= 0):
      print(prefix+"  coordinate_sigma: %s  =>  restraints disabled" % (
          str(self.ncs_params.coordinate_sigma)), file=out)
      return n_excessive
    for i_group,group in enumerate(self.groups_list):
      print(prefix + "NCS restraint group %d:" % (i_group+1), file=out)
      print(prefix + "  coordinate_sigma: %.6g" % (
        self.ncs_params.coordinate_sigma), file=out)
      energies_sites = group.energies_sites(
        sites_cart=sites_cart,
        coordinate_sigma = self.ncs_params.coordinate_sigma,
        compute_gradients=False)
      print(prefix + "  weight:  %.6g" % energies_sites.weight, file=out)
      n_excessive += energies_sites.show_distances_to_average(
        site_labels=site_labels,
        excessive_distance_limit=excessive_distance_limit,
        out=out,
        prefix=prefix+"  ")
    self.n_excessive_site_distances = n_excessive
    return n_excessive

  def selection_restrained(self, n_seq=None):
    if (n_seq is None):
      n_seq = -1
      for group in self.groups_list:
        for pair in group.selection_pairs:
          for sel in pair:
            n_seq = max(n_seq, flex.max(sel))
      n_seq += 1
    result = flex.bool(n_seq, False)
    for group in self.groups_list:
      for pair in group.selection_pairs:
        for sel in pair:
          result.set_selected(sel, True)
    return result

class _group(object):
  """
  DO NOT USE THIS CLASS ANYWERE ELSE.
  This class is exclusively used in cartesian NCS restraints.
  It is being created by cartesian_ncs_manager here and not used anywhere
  outside this file.
  """
  def __init__(self,
        selection_strings,
        registry,
        u_average_min):
      adopt_init_args(self, locals())
      self.selection_pairs = registry.selection_pairs()
      self.matrices = []
      self.rms = []

  def register_additional_isolated_sites(self, number):
    self.registry.register_additional_isolated_sites(number=number)

  def select(self, iselection):
    if(not isinstance(iselection, flex.size_t)):
      iselection = iselection.iselection()
    return _group(
      selection_strings=self.selection_strings,
      registry=self.registry.proxy_select(iselection=iselection),
      u_average_min=self.u_average_min)

  def compute_operators(self, sites_cart):
    for pair in self.selection_pairs:
      superposition = superpose.least_squares_fit(
        reference_sites=sites_cart.select(pair[0]),
        other_sites=sites_cart.select(pair[1]))
      rtmx = matrix.rt((superposition.r, superposition.t))
      self.matrices.append(rtmx)
      x = sites_cart.select(pair[0])
      y = rtmx * sites_cart.select(pair[1])
      d_sq = (x-y).dot()
      self.rms.append(flex.mean(d_sq)**0.5)

  def show_operators(self,
      sites_cart,
      n_slots_difference_histogram=6,
      out=None,
      prefix=""):
    self.compute_operators(sites_cart)
    if (out is None): out = sys.stdout
    # selection_strings = self.group.selection_strings
    for i_op,pair,mx,rms in zip(
          count(1),
          self.selection_pairs,
          self.matrices,
          self.rms):
      print(prefix + "NCS operator %d:" % i_op, file=out)
      print(prefix + "  Reference selection:", \
        show_string(self.selection_strings[0]), file=out)
      print(prefix + "      Other selection:", \
        show_string(self.selection_strings[i_op]), file=out)
      print(prefix + "  Number of atom pairs:", len(pair[0]), file=out)
      print(mx.r.mathematica_form(
        label="Rotation", format="%.6g", one_row_per_line=True,
        prefix=prefix+"  "), file=out)
      print(mx.t.mathematica_form(
        label="Translation", format="%.6g", prefix=prefix+"  "), file=out)
      x = sites_cart.select(pair[0])
      y = mx * sites_cart.select(pair[1])
      d_sq = (x-y).dot()
      if (n_slots_difference_histogram is not None):
        print(prefix + "  Histogram of differences:", file=out)
        diff_histogram = flex.histogram(
          data=flex.sqrt(d_sq), n_slots=n_slots_difference_histogram)
        diff_histogram.show(
          f=out, prefix=prefix+"    ", format_cutoffs="%8.6f")
      print(prefix + "  RMS difference with respect to the reference: %8.6f" %(rms), file=out)

  def energies_adp_iso(self,
        u_isos,
        b_factor_weight,
        average_power,
        compute_gradients=True,
        gradients=None):
    return _energies_adp_iso(
      group=self,
      u_isos=u_isos,
      b_factor_weight=b_factor_weight,
      average_power=average_power,
      compute_gradients=compute_gradients,
      gradients=gradients)

  def energies_sites(self,
        sites_cart,
        coordinate_sigma,
        compute_gradients=True,
        gradients=None,
        sites_average=None):
    return _energies_sites(
      group=self,
      sites_cart=sites_cart,
      coordinate_sigma=coordinate_sigma,
      compute_gradients=compute_gradients,
      gradients=gradients,
      sites_average=sites_average)

class _energies_adp_iso(scitbx.restraints.energies):

  def __init__(self,
        group,
        u_isos,
        b_factor_weight,
        average_power,
        compute_gradients,
        gradients):
    scitbx.restraints.energies.__init__(self,
      compute_gradients=compute_gradients,
      gradients=gradients,
      gradients_size=u_isos.size(),
      gradients_factory=flex.double,
      normalization=False)
    self.group = group
    self.u_isos = u_isos
    self.average_power = average_power
    # XXX registry should be condensed to map of std::vectors
    #     then all the code below and adp_iso_residual_sum could
    #     become a method of the reduced registry
    max_index = 0
    for pair in self.group.selection_pairs:
      max_index = max(max_index, pair[0][-1])
    u_isos_sum = flex.double(max_index+1, 0)
    u_isos_count = flex.size_t(max_index+1, 0)
    for pair in self.group.selection_pairs:
      u_isos_sum.set_selected(pair[0], u_isos.select(pair[0]))
      u_isos_count.set_selected(pair[0], 1)
    for pair in self.group.selection_pairs:
      u_isos_sum.add_selected(pair[0], u_isos.select(pair[1]))
      u_isos_count.set_selected(pair[0], u_isos_count.select(pair[0])+1)
    sel = u_isos_count == 0
    u_isos_count.set_selected(sel, 1)
    u_isos_average = u_isos_sum / u_isos_count.as_double()
    u_isos_count.set_selected(sel, 0)
    sel = (~sel).iselection()
    self.rms_with_respect_to_average = flex.double()
    def residual_contribution(u_isos_current, u_isos_average):
      diff = u_isos_current - u_isos_average
      self.rms_with_respect_to_average.append(adptbx.u_as_b(
        flex.mean_sq(diff)**0.5))
      self.number_of_restraints += diff.size()
    residual_contribution(
      u_isos_current=u_isos.select(sel),
      u_isos_average=u_isos_average.select(sel))
    for pair in self.group.selection_pairs:
      residual_contribution(
        u_isos_current=u_isos.select(pair[1]),
        u_isos_average=u_isos_average.select(pair[0]))
    self.weight = b_factor_weight
    self.residual_sum = self.group.registry.adp_iso_residual_sum(
      weight=self.weight,
      average_power=self.average_power,
      u_isos=u_isos,
      u_average_min=self.group.u_average_min,
      gradients=self.gradients)
    self.finalize_target_and_gradients()
    self.u_isos_count = u_isos_count
    self.u_isos_average = u_isos_average

  def show_differences_to_average(self, site_labels, out=None, prefix=""):
    if (out is None): out = sys.stdout
    assert len(site_labels) == self.u_isos.size()
    max_label_size = 1
    for label in site_labels:
      max_label_size = max(max_label_size, len(label))
    fmt = "  %%%ds: %%7.2f - %%7.2f = %%8.4f" % max_label_size
    def show_selection(i_ncs, pair):
      print(prefix + "NCS selection:", \
        show_string(self.group.selection_strings[i_ncs]), file=out)
      print(prefix + " "*(max_label_size+2) \
        + "    B-iso   NCS ave  Difference", file=out)
      u_isos_current = self.u_isos.select(pair[1])
      u_isos_average = self.u_isos_average.select(pair[0])
      for i,c,a in zip(pair[1], u_isos_current, u_isos_average):
        c = adptbx.u_as_b(c)
        a = adptbx.u_as_b(a)
        print(prefix + fmt % (site_labels[i], c, a, c-a), file=out)
    sel = (self.u_isos_count != 0).iselection()
    show_selection(i_ncs=0, pair=[sel, sel])
    for i_ncs,pair in zip(count(1), self.group.selection_pairs):
      show_selection(i_ncs=i_ncs, pair=pair)


class _energies_sites(scitbx.restraints.energies):

  def __init__(self,
        group,
        sites_cart,
        coordinate_sigma,
        compute_gradients,
        gradients,
        sites_average):
    scitbx.restraints.energies.__init__(self,
      compute_gradients=compute_gradients,
      gradients=gradients,
      gradients_size=sites_cart.size(),
      gradients_factory=flex.vec3_double,
      normalization=False)
    self.group = group
    self.sites_cart = sites_cart
    selection_pairs = self.group.selection_pairs
    max_index = 0
    for pair in selection_pairs:
      max_index = max(max_index, pair[0][-1])
    sites_sum = flex.vec3_double(max_index+1, (0,0,0))
    sites_count = flex.size_t(max_index+1, 0)
    for pair in selection_pairs:
      sites_sum.set_selected(pair[0], sites_cart.select(pair[0]))
      sites_count.set_selected(pair[0], 1)
    for pair,op in zip(selection_pairs, self.group.matrices):
      sites_sum.add_selected(pair[0], op*sites_cart.select(pair[1]))
      sites_count.set_selected(pair[0], sites_count.select(pair[0])+1)
    sel = sites_count == 0
    sites_count.set_selected(sel, 1)
    if (sites_average is not None):
      assert sites_average.size() == sites_count.size()
    else:
      sites_average = sites_sum / sites_count.as_double()
    sites_count.set_selected(sel, 0)
    sel = (~sel).iselection()
    assert coordinate_sigma > 0
    self.weight = 1/coordinate_sigma**2
    self.rms_with_respect_to_average = flex.double()
    if (self.gradients is not None):
      self.gradients.add_selected(
        sel,
        self.residual_contribution(
          sites_current=sites_cart.select(sel),
          sites_average=sites_average.select(sel)))
      for pair,op in zip(selection_pairs, self.group.matrices):
        self.gradients.add_selected(
          pair[1],
          self.residual_contribution(
            sites_current=sites_cart.select(pair[1]),
            sites_average=op.inverse() * sites_average.select(pair[0])))
    else:
      self.residual_contribution(
        sites_current=sites_cart.select(sel),
        sites_average=sites_average.select(sel))
      for pair,op in zip(selection_pairs, self.group.matrices):
        self.residual_contribution(
          sites_current=sites_cart.select(pair[1]),
          sites_average=op.inverse() * sites_average.select(pair[0]))
    self.finalize_target_and_gradients()
    self.sites_count = sites_count
    self.sites_average = sites_average

  def residual_contribution(self, sites_current, sites_average):
    diff = sites_current - sites_average
    self.rms_with_respect_to_average.append(flex.mean(diff.dot())**0.5)
    self.number_of_restraints += diff.size()
    self.residual_sum += self.weight * diff.sum_sq()
    if (self.gradients is not None):
      return (2 * self.weight) * diff

  def show_distances_to_average(self,
        site_labels,
        excessive_distance_limit=None,
        out=None,
        prefix=""):
    if (out is None): out = sys.stdout
    assert len(site_labels) == self.sites_cart.size()
    max_label_size = 1
    for label in site_labels:
      max_label_size = max(max_label_size, len(label))
    fmt = "  %%%ds: %%8.4f" % max_label_size
    def show_selection(i_ncs, pair, op):
      print(prefix + "NCS selection:", \
        show_string(self.group.selection_strings[i_ncs]), file=out)
      print(prefix + " "*(max_label_size+2) \
        + "  Distance to NCS average", file=out)
      sites_current = self.sites_cart.select(pair[1])
      if (op is None):
        sites_average = self.sites_average.select(pair[0])
      else:
        sites_average = op.inverse() * self.sites_average.select(pair[0])
      n_excessive = 0
      for i,c,a in zip(pair[1], sites_current, sites_average):
        abs_diff = abs(matrix.col(c) - matrix.col(a))
        print(prefix + fmt % (site_labels[i], abs_diff), end=' ', file=out)
        if (excessive_distance_limit is not None
            and abs_diff >= excessive_distance_limit):
          print("EXCESSIVE", end=' ', file=out)
          n_excessive += 1
        print(file=out)
      return n_excessive
    sel = (self.sites_count != 0).iselection()
    n_excessive = show_selection(i_ncs=0, pair=[sel, sel], op=None)
    for i_ncs,pair,op in zip(count(1),
                             self.group.selection_pairs,
                             self.group.matrices):
      n_excessive += show_selection(i_ncs=i_ncs, pair=pair, op=op)
    return n_excessive


 *******************************************************************************


 *******************************************************************************
mmtbx/ncs/ligands.py

# TODO tests!

"""
Post-fitting cleanup of ligand positions to match NCS operations present in
protein model.  This can be used to recover cases where one copy is placed
successfully but another misses due to interfering protein atoms, weak density,
false positive in empty protein density, etc.  It can also accelerate ligand
placement for large structures if at least one copy is already placed with high
confidence.  Should only be used when the initial placement (e.g. LigandFit CC)
is sufficiently good.

Usually this will be called via the command mmtbx.apply_ncs_to_ligand.
"""

from __future__ import absolute_import, division, print_function
from libtbx.utils import Sorry, null_out
from libtbx.str_utils import make_sub_header
from libtbx import adopt_init_args, group_args
import copy
from math import sqrt
import sys
from six.moves import zip

debug = True

ncs_ligand_phil = """
d_min = 2.5
  .type = float
max_rmsd = 2.0
  .type = float
min_cc = 0.7
  .type = float
min_cc_reference = 0.85
  .type = float
min_2fofc = 1.0
  .type = float
min_dist_center = 5
  .type = float
remove_clashing_atoms = True
  .type = bool
clash_cutoff = 2.0
  .type = float
write_sampled_pdbs = False
  .type = bool
"""

def resid_str(atom):
  labels = atom.fetch_labels()
  return "%s %s" % (labels.resname, labels.resid())

def xyz_distance(xyz1, xyz2):
  x1,y1,z1 = xyz1
  x2,y2,z2 = xyz2
  return sqrt((x2-x1)**2 + (y2-y1)**2 + (z2-z1)**2)

class group_operators(object):
  """
  Object for storing information about NCS relationships relative to an
  atom selection, i.e. given four identical chains A, B, C, and D, this might
  store information about chain B and the NCS operators for approximate
  superpositioning on chains A, C, and D.
  """
  def __init__(self, selection, sele_str, sites_cart):
    self.selection = selection
    self.selection_string = sele_str
    self.center_of_mass = sites_cart.select(selection).mean()
    self.operators = []
    self.op_selections = []

  def add_operator(self, ops, sele_str):
    """
    Save an NCS operator and corresponding atom selection.
    """
    self.operators.append(ops)
    self.op_selections.append(sele_str)

  def distance_from_center(self, sites):
    """
    Compute the distance between centers-of-mass of this selection and the
    given sites.  Used to determine ligand-protein chain relationships.
    """
    c_o_m = sites.mean()
    return xyz_distance(c_o_m, self.center_of_mass)

  def show_summary(self, out=None, prefix=""):
    """
    Print out selections and NCS operators.
    """
    if (out is None) : out = sys.stdout
    print(prefix+"Reference selection: %s" % self.selection_string, file=out)
    for op, op_sele in zip(self.operators, self.op_selections):
      print(prefix+"  Selection: %s" % op_sele, file=out)
      print(prefix+"  Rotation:", file=out)
      print(prefix+"    %6.4f  %6.4f  %6.4f" % op.r.elems[0:3], file=out)
      print(prefix+"    %6.4f  %6.4f  %6.4f" % op.r.elems[3:6], file=out)
      print(prefix+"    %6.4f  %6.4f  %6.4f" % op.r.elems[6:9], file=out)
      print(prefix+"  Translation:", file=out)
      print(prefix+"    %6.4f  %6.4f  %6.4f" % op.t.elems, file=out)
      print("", file=out)
    print("", file=out)

class sample_operators(object):
  """
  Determines an appropriate "reference" ligand, and samples the density around
  sites transformed by each operator, applying the best operator to the
  other ligand copies if meeting cutoff criteria.
  """
  def __init__(self,
      pdb_hierarchy,
      fmodel,
      ncs_operators,
      ligands,
      params,
      log=None):
    if (log is None) : log = sys.stdout
    if (params is None):
      params = master_phil().fetch().extract()
    adopt_init_args(self, locals())
    self.xray_structure = fmodel.xray_structure.deep_copy_scatterers()
    xrs_ncs = fmodel.xray_structure.deep_copy_scatterers()
    from iotbx.pdb import hierarchy
    self.setup_maps()
    best_cc = 0
    best_k = -1
    best_ligand = None
    other_ligands = []
    print("Identifying reference ligand...", file=log)
    def show_map_stats(prefix, stats):
      print("   %s: CC = %5.3f  mean = %6.2f" % (prefix, stats.cc,
        stats.map_mean), file=log)
    for k, ligand in enumerate(ligands):
      atoms = ligand.atoms()
      start = self.get_sites_cc(atoms)
      show_map_stats("Ligand %d" % (k+1), start)
      if (start.cc > best_cc) and (start.cc > params.min_cc_reference):
        best_ligand = ligand
        best_k = k
        best_cc = best_cc
    if (best_ligand is None):
      raise Sorry("No ligand with acceptable CC (>%.2f) found." %
        params.min_cc_reference)
    best_atoms = best_ligand.atoms()
    for k, ligand in enumerate(ligands):
      if (ligand is not best_ligand):
        other_ligands.append(ligand)
    print("Copy #%d was the best, using that as reference" % (best_k+1), file=log)
    print("", file=log)
    sites_ref = best_ligand.atoms().extract_xyz()
    min_dist = sys.maxsize
    best_group = None
    shifts = ncs_operators.get_ncs_groups_shifts(
      self.xray_structure.sites_cart(),
      sites_ref
      )
    for i, s in enumerate(shifts):
      dxyz = xyz_distance(s[0], (0,0,0))
      if (dxyz < min_dist):
        best_group = i
        min_dist = dxyz
    array_of_str_selections = ncs_operators.get_array_of_str_selections()[0]
    if (best_group is not None):
      print("This appears to be bound to the selection \"%s\"" % \
        array_of_str_selections[best_group], file=log)
    if best_group==0: pass
    else:
      print('best_group',best_group)
      assert 0
    # always have the first ligand in the master
    self.new_ligands = []
    for j, operator in enumerate(ncs_operators[0].copies):
      new_ligand = best_ligand.detached_copy()
      atoms = new_ligand.atoms()
      sites_new = operator.r.elems * sites_ref + operator.t.elems
      sites_mean = sites_new.mean()
      for other in other_ligands :
        sites_other_mean = other.atoms().extract_xyz().mean()
        dxyz = xyz_distance(sites_other_mean, sites_new.mean())
        if (dxyz < params.min_dist_center):
          print("  operator %d specifies an existing ligand" % (j+1), file=log)
          break
      else :
        atoms.set_xyz(sites_new)
        stats_new = self.get_sites_cc(best_atoms, sites_new)
        show_map_stats("NCS op. %2d" % (j+1), stats_new)
        if (params.write_sampled_pdbs):
          lig_rg = hierarchy.residue_group()
          lig_rg.resseq = j+1
          lig_rg.append_atom_group(new_ligand)
          f = open("ncs_ligand_%d.pdb" % (j+1), "w")
          for atom in new_ligand.atoms():
            f.write(atom.format_atom_record()+"\n")
          f.close()
        # XXX ideally, given multiple high-quality ligand placements, we should
        # probably try sampling NCS operations for all of these and pick the
        # best new CC, rather than assuming that the best starting ligand will
        # superpose best on the density.
        if (stats_new.cc > params.min_cc):
          print("  operator %d has acceptable CC (%.3f)" % (j+1,
            stats_new.cc), file=log)
          self.new_ligands.append(new_ligand)

  def setup_maps(self):
    """
    Create 2mFo-DFc, mFo-DFc, and Fc maps.
    """
    map_helper = self.fmodel.electron_density_map()
    map_coeffs = map_helper.map_coefficients("2mFo-DFc")
    diff_map_coeffs = map_helper.map_coefficients("mFo-DFc")
    fft_map = map_coeffs.fft_map(resolution_factor=1/3.)
    diff_fft_map = diff_map_coeffs.fft_map(resolution_factor=1/3.)
    fft_map.apply_sigma_scaling()
    diff_fft_map.apply_sigma_scaling()
    fcalc = map_helper.map_coefficients("Fc")
    fcalc_map = fcalc.fft_map(resolution_factor=1/3.)
    fcalc_map.apply_sigma_scaling()
    self.unit_cell = map_coeffs.unit_cell()
    self.real_map = fft_map.real_map()
    self.diff_map = diff_fft_map.real_map()
    self.n_real = self.real_map.focus()
    self.m_real = self.real_map.all()
    self.fcalc_real_map = fcalc_map.real_map()

  def get_new_fcalc_map(self, sites_new, i_seqs):
    xrs_new = self.xray_structure.deep_copy_scatterers()
    all_sites = xrs_new.sites_cart()
    all_sites.set_selected(i_seqs, sites_new)
    xrs_new.set_sites_cart(all_sites)
    self.fmodel.update_xray_structure(
      xray_structure=xrs_new,
      update_f_calc=True,
      update_f_mask=True)
    fcalc = self.fmodel.electron_density_map().map_coefficients("Fc")
    fcalc_map = fcalc.fft_map(resolution_factor=1/3.)
    fcalc_map.apply_sigma_scaling()
    # XXX now revert to original xray structure
    self.fmodel.update_xray_structure(
      xray_structure=self.xray_structure,
      update_f_calc=True,
      update_f_mask=True)
    return fcalc_map.real_map()

  def get_sites_cc(self, atoms, sites=None):
    from cctbx import maptbx
    from scitbx.array_family import flex
    radii = flex.double()
    for atom in atoms :
      if (atom.element.strip() in ["H", "D"]):
        radii.append(1.)
      else :
        radii.append(1.5)
    fcalc_map = self.fcalc_real_map
    if (sites is None):
      sites = atoms.extract_xyz()
    else :
      fcalc_map = self.get_new_fcalc_map(
        sites_new=sites,
        i_seqs=atoms.extract_i_seq())
    sel = maptbx.grid_indices_around_sites(
      unit_cell  = self.unit_cell,
      fft_n_real = self.n_real,
      fft_m_real = self.m_real,
      sites_cart = sites,
      site_radii = radii)
    m1 = self.real_map.select(sel)
    m2 = fcalc_map.select(sel)
    cc = flex.linear_correlation(x=m1, y=m2).coefficient()
    return group_args(
      cc=cc,
      map_mean=flex.mean(m1.as_1d()))

def _is_same_residue(atom1, atom2):
  labels1 = atom1.fetch_labels()
  labels2 = atom2.fetch_labels()
  return ((labels1.resid() == labels2.resid()) and
          (labels1.chain_id == labels2.chain_id) and
          (labels1.altloc == labels2.altloc))

def remove_clashing_atoms(
    xray_structure,
    pdb_hierarchy,
    ligands,
    params,
    log):
  """
  Since the transformed ligands will very frequently overlap with existing
  atoms, these need to be deleted if we are confident about the new positions.
  """
  from scitbx.array_family import flex
  pdb_atoms = pdb_hierarchy.atoms()
  selection = flex.bool(pdb_atoms.size(), True)
  pair_asu_table = xray_structure.pair_asu_table(
    distance_cutoff=params.clash_cutoff)
  #xray_structure.show_distances(params.clash_cutoff)
  # XXX for some unknown reason this doesn't work if I use the object returned
  # by pair_asu_table.extract_pair_sym_table() instead
  asu_table = pair_asu_table.table()
  remove_atoms = set([])
  for ligand in ligands :
    i_seqs = ligand.atoms().extract_i_seq()
    for i_seq in i_seqs :
      asu_dict = asu_table[i_seq]
      for j_seq, sym_ops in asu_dict.items():
        if (not _is_same_residue(pdb_atoms[i_seq], pdb_atoms[j_seq])):
          remove_atoms.add(j_seq)
  if (len(remove_atoms) > 0):
    def show_removed(atoms):
      for atom in atoms :
        print("  warning: deleting atom %s" % atom.id_str(), file=log)
    deleted = []
    bad_atoms = [ pdb_atoms[j_seq] for j_seq in remove_atoms ]
    for atom in bad_atoms :
      if (atom.i_seq in deleted) : continue
      labels = atom.fetch_labels()
      atom_group = atom.parent()
      residue_group = atom_group.parent()
      other_atoms = residue_group.atoms()
      chain = residue_group.parent()
      if (labels.resname == "HOH"):
        deleted.extend(other_atoms.extract_i_seq())
        chain.remove_residue_group(residue_group)
        show_removed(other_atoms)
      else :
        if (chain.is_protein()):
          if (atom.name.strip() in ["N","C","CA","CB","O","H","HA"]):
            show_removed(other_atoms)
            deleted.extend(other_atoms.extract_i_seq())
            chain.remove_residue_group(residue_group)
          else :
            for atom2 in other_atoms :
              if (atom2.name.strip() in ["N","C","CA","CB","O","H","HA"]):
                continue
              else :
                show_removed([atom2])
                deleted.append(atom2.i_seq)
                atom_group.remove_atom(atom2)
        else :
          deleted.append(atom.i_seq)
          show_removed([atom])
          atom_group.remove_atom(atom)
          if (len(other_atoms) == 1):
            chain.remove_residue_group(residue_group)
    n_removed = len(deleted)
    print("%d atoms removed due to clashes with ligand(s)." % n_removed, file=log)
    for i_seq in deleted :
      selection[i_seq] = False
    xrs_new = xray_structure.select(selection)
  else :
    xrs_new = xray_structure
  return xrs_new

class get_final_maps_and_cc(object):
  def __init__(self,
      fmodel,
      ligands,
      params,
      log):
    from cctbx import maptbx
    from scitbx.array_family import flex
    map_helper = fmodel.electron_density_map()
    self.two_fofc_map_coeffs = map_helper.map_coefficients("2mFo-DFc")
    self.fofc_map_coeffs = map_helper.map_coefficients("mFo-DFc")
    fft_map = self.two_fofc_map_coeffs.fft_map(resolution_factor=0.25)
    fft_map.apply_sigma_scaling()
    fcalc = map_helper.map_coefficients("Fc")
    fcalc_map = fcalc.fft_map(resolution_factor=0.25)
    fcalc_map.apply_sigma_scaling()
    real_map = fft_map.real_map()
    fcalc_real_map = fcalc_map.real_map()
    final_cc = []
    for k, ligand in enumerate(ligands):
      atoms = ligand.atoms()
      sites = flex.vec3_double()
      radii = flex.double()
      for atom in atoms :
        if (not atom.element.strip() in ["H","D"]):
          sites.append(atom.xyz)
          radii.append(1.5)
      sel = maptbx.grid_indices_around_sites(
        unit_cell  = self.two_fofc_map_coeffs.unit_cell(),
        fft_n_real = real_map.focus(),
        fft_m_real = real_map.all(),
        sites_cart = sites,
        site_radii = radii)
      m1 = real_map.select(sel)
      m2 = fcalc_real_map.select(sel)
      cc = flex.linear_correlation(x=m1, y=m2).coefficient()
      final_cc.append(cc)
      print("  Ligand %d: CC = %5.3f" % (k+1, cc), file=log)
    print("", file=log)
    self.final_cc = final_cc

  def write_maps(self, file_name):
    import iotbx.mtz
    dec = iotbx.mtz.label_decorator(phases_prefix="PH")
    mtz_dat = self.two_fofc_map_coeffs.as_mtz_dataset(
      column_root_label="2FOFCWT",
      label_decorator=dec)
    mtz_dat.add_miller_array(self.fofc_map_coeffs,
      column_root_label="FOFCWT",
      label_decorator=dec)
    mtz_dat.mtz_object().write(file_name)

def extract_ligand_residues(
    pdb_hierarchy,
    ligand_code,
    atom_selection=None,
    only_segid=None):
  """
  Extract the atom_group object(s) with given 3-character residue name.

  :param pdb_hierarchy: input model
  :param ligand_code: 3-letter residue ID
  :param atom_selection: optional flex.bool object specifying ligand selection
      to use
  :param only_segid: optional segid which ligand(s) must match
  :returns: list of atom_group objects
  """
  assert (len(pdb_hierarchy.models()) == 1)
  ligands = []
  for chain in pdb_hierarchy.models()[0].chains():
    for residue_group in chain.residue_groups():
      for atom_group in residue_group.atom_groups():
        if (atom_group.resname == ligand_code):
          use_ligand = True
          if (only_segid is not None):
            for atom in atom_group.atoms():
              if (atom.segid != only_segid):
                use_ligand = False
                break
          if (use_ligand) and (atom_selection is not None):
            for atom in atom_group.atoms():
              if (not atom_selection[atom.i_seq]):
                use_ligand = False
                break
          if (use_ligand):
            ligands.append(atom_group)
  return ligands

def combine_ligands_and_hierarchy(pdb_hierarchy, ligands, log=None):
  from iotbx.pdb import hierarchy
  if (log is None) : log = null_out()
  chain_id_counts = {}
  model = pdb_hierarchy.models()[0]
  for i_lig, ligand in enumerate(ligands):
    xyz_mean = ligand.atoms().extract_xyz().mean()
    best_chain = None
    min_dist = sys.maxsize
    for chain in model.chains():
      last_resseq = chain.residue_groups()[-1].resseq_as_int()
      if ((not chain.id in chain_id_counts) or
          (chain_id_counts[chain.id] < last_resseq)):
        chain_id_counts[chain.id] = last_resseq
      if (not chain.is_protein()) : continue
      chain_xyz_mean = chain.atoms().extract_xyz().mean()
      dist = xyz_distance(chain_xyz_mean, xyz_mean)
      if (dist < min_dist):
        min_dist = dist
        best_chain = chain
    best_chain_id = " "
    if (best_chain is not None):
      best_chain_id = best_chain.id
    new_chain = hierarchy.chain(id=best_chain_id)
    new_rg = hierarchy.residue_group()
    new_resseq = 1
    if (best_chain_id in chain_id_counts):
      new_resseq = chain_id_counts[best_chain_id] + 1
    print("  ligand %d: chain='%s' resseq=%s" % (i_lig+1,
      best_chain_id, new_resseq), file=log)
    new_rg.resseq = new_resseq
    new_rg.append_atom_group(ligand)
    new_chain.append_residue_group(new_rg)
    model.append_chain(new_chain)
    chain_id_counts[best_chain_id] = new_resseq

# Main function
class apply_ligand_ncs(object):
  """
  Wrapper class; this should be the primary entry point for external calling
  routines.

  :param pdb_hierarchy: initial model with one or more copies of the target
    ligand
  :param fmodel: mmtbx.f_model.manager object corresponding to the model
  :param ligand_code: three-letter residue name of ligand
  :param params: phil scope_extract object for ncs_ligand_phil
  :param atom_selection: selection for reference ligand (default: search for
    all copies and pick one with the best CC)
  :param add_new_ligands_to_pdb: generate combined PDB hierarchy and fmodel
    with new ligands incorporated
  :param only_segid:
  :param log: filehandle-like object
  """
  def __init__(self,
      pdb_hierarchy,
      fmodel,
      ligand_code,
      params,
      atom_selection=None,
      add_new_ligands_to_pdb=False,
      only_segid=None,
      log=None):
    if (log is None) : log = sys.stdout
    assert (ligand_code is not None) and (len(ligand_code) <= 3)
    make_sub_header("Determining NCS operators", log)
    import iotbx.ncs
    ncs_obj = iotbx.ncs.input(hierarchy=pdb_hierarchy)
    nrgl = ncs_obj.get_ncs_restraints_group_list()

    if 0:
      print("Summary of NCS operators:", file=log)
      for ncs_group in ncs_ops :
        for k, group in enumerate(ncs_group):
          group.show_summary(log, prefix="  ")
    print("Looking for ligands named %s..." % ligand_code, file=log)
    ligands = extract_ligand_residues(pdb_hierarchy, ligand_code,
      only_segid=only_segid)
    if (len(ligands) == 0):
      raise Sorry("No ligands found!")
    pdb_hierarchy.atoms().reset_i_seq()
    make_sub_header("Applying NCS to ligands", log)
    sampler = sample_operators(
      fmodel=fmodel,
      pdb_hierarchy=pdb_hierarchy,
      ncs_operators=nrgl, #ncs_ops_flat,
      params=params,
      ligands=ligands,
      log=log)
    if (len(sampler.new_ligands) > 0):
      if (params.remove_clashing_atoms):
        make_sub_header("Removing clashing atoms", log)
        xrs_new = remove_clashing_atoms(
          xray_structure=sampler.xray_structure,
          pdb_hierarchy=pdb_hierarchy,
          ligands=sampler.new_ligands,
          params=params,
          log=log)
        fmodel.update_xray_structure(
          xray_structure=xrs_new,
          update_f_calc=True,
          update_f_mask=True)
      if (add_new_ligands_to_pdb):
        combine_ligands_and_hierarchy(
          pdb_hierarchy=pdb_hierarchy,
          ligands=sampler.new_ligands,
          log=log)
        xrs_new = pdb_hierarchy.extract_xray_structure(
          crystal_symmetry=fmodel.xray_structure)
        fmodel.update_xray_structure(
          xray_structure=xrs_new,
          update_f_calc=True,
          update_f_mask=True)
    self.final_ligands = extract_ligand_residues(pdb_hierarchy, ligand_code,
      only_segid=only_segid)
    self.final_cc = get_final_maps_and_cc(
      fmodel=fmodel,
      ligands=self.final_ligands,
      params=params,
      log=log)
    self.n_ligands_start = len(ligands)
    self.n_ligands_new = len(sampler.new_ligands)
    self.pdb_hierarchy = pdb_hierarchy
    self.fmodel = fmodel

  @property
  def n_ligands(self):
    return self.n_ligands_start + self.n_ligands_new

  def write_pdb(self, file_name):
    f = open(file_name, "w")
    f.write(self.pdb_hierarchy.as_pdb_string(
      crystal_symmetry=self.fmodel.xray_structure))
    f.close()

  def write_maps(self, file_name):
    self.final_cc.write_maps(file_name)


 *******************************************************************************


 *******************************************************************************
mmtbx/ncs/ncs.py
from __future__ import absolute_import, division, print_function
# from mmtbx.ncs.ncs_utils import convert_phil_format
import sys, os, string
from operator import itemgetter
from libtbx.utils import Sorry
from libtbx.utils import null_out
import scitbx.rigid_body
from six.moves import zip
from six.moves import range
from copy import deepcopy
 # hierarchy:  there can be any number of ncs groups.
 #   each group has a set of NCS operators and centers and may apply
 #      to a part of the structure.
 #  for group in ncs.ncs_groups(): returns list of groups
 #  id=group.chain_and_residue_id() returns id of where it applies
 #  for center in group.centers(): returns list of centers of ncs regions in group
 #  for rota_matr in group.rota_matrices(): returns rota matrices
 #  for trans_orth in group.translations_orth(): returns translation matrices

 # NOTE: symmetry operators map NCS position i on to NCS position 0 (they are
 #  inverses of the operators mapping position 0 on to i).

# Defaults for tolerances:
# Set 2017-12-23 to match values in find_ncs.py; these are very relaxed...
# previous values were tol_z=0.01, tol_r=.01,abs_tol_t=.10,rel_tol_t=0.001

default_tol_z=0.01
default_tol_r=0.02
default_abs_tol_t=2.0
default_rel_tol_t=0.05

def abs(aa):
  if aa>=0:return aa
  return -aa

def is_in_range(z,z_min,z_max):
    if z<z_min or z>z_max: return False
    return True

def remove_quotes_from_chain_id(chain_residue_id):
  # remove the quotes from the chain names in group:
  if chain_residue_id is None:
     return

  [group,list_of_resseq_list]=chain_residue_id
  new_group=[]
  for chain_id in group:
    new_group.append(remove_single_quotes(chain_id))
  return [new_group,list_of_resseq_list]

def remove_single_quotes(text):
  # Remove single quotes from ends of a string if they occur on both ends.
  if not text: return text
  if not type(text)==type("abc"): return text
  if text.startswith("'") and text.endswith("'"):
    text=text[1:-1]
  return text


def is_identity(r,t,tol=1.e-2):
  identity_r=[1,0,0,0,1,0,0,0,1]
  identity_t=[0,0,0]
  for i in range(9):
    if abs(r[i]-identity_r[i])>tol: return False
  for i in range(3):
    if abs(t[i]-identity_t[i])>tol: return False
  return True

def is_same_transform(r1,t1,r2,t2,
   tol_r=default_tol_r,
   abs_tol_t=default_abs_tol_t,
   rel_tol_t=default_rel_tol_t):

    # require everything to be very similar
    for i in range(9):
      if abs(r1[i]-r2[i])>tol_r: return False
    for i in range(3):
      dd=abs(t1[i]-t2[i])
      dd2=0.5*(abs(t1[i])+abs(t2[i]))
      if dd>abs_tol_t and dd>rel_tol_t*dd2: # definitely does not match
        return False
    return True
def crystal_symmetry_to_ncs(crystal_symmetry=None):

  # convert r,t fractional to r_orth,t_orth  orthogonal
  #  r x + t = x'
  #   x_orth=Ax   A = orthogonalization_matrix
  #  r_orth  (Ax) + t_orth = Ax'
  #  A-1 r_orth A  x + A-1 t_orth = x'
  #  r= (A-1 r_orth A)     t=A-1 t_orth
  #  r_orth = A r A-1     t_orth = A t

  from scitbx import matrix
  a=matrix.sqr(crystal_symmetry.unit_cell().orthogonalization_matrix())
  a_inv=a.inverse()

  trans_orth=[]
  ncs_rota_matr=[]
  ncs_center_orth=[]
  center=matrix.col((0.41,0.43,0.39)) # just a point near center of cell
  center_orth=crystal_symmetry.unit_cell().orthogonalize(center)

  for rt_mx in crystal_symmetry.space_group().all_ops():
    r=matrix.sqr(rt_mx.r().as_rational().as_float())
    t=matrix.col(rt_mx.t().as_rational().as_float())

    # Try to put each center for this ncs operator inside the cell
    c=matrix.col(rt_mx * center) # Note: forward (not inverse)
    coordinate_offset=matrix.col(offset_inside_cell(c,
       unit_cell=crystal_symmetry.unit_cell(),orthogonalize=False))
    c_offset=c+coordinate_offset

    r_orth=matrix.sqr(a * r * a_inv)
    t_orth= matrix.col(a * (t + coordinate_offset))
    c_value=crystal_symmetry.unit_cell().orthogonalize(c_offset)

    r_orth_inv=r_orth.inverse()
    t_orth_inv=-r_orth_inv*t_orth

    ncs_rota_matr.append(r_orth_inv)
    trans_orth.append(t_orth_inv)
    ncs_center_orth.append(c_value)

    chain_residue_id= [
        len(r_orth)*[None],
        len(r_orth)*[[]]
        ]

  ncs_obj=ncs()
  ncs_obj.import_ncs_group(
       ncs_rota_matr=ncs_rota_matr,
       center_orth=ncs_center_orth,
       trans_orth=trans_orth,
       chain_residue_id=chain_residue_id)

  return ncs_obj

def offset_inside_zero_one(x):
    if x >=0.0:
      return -1.0*int(x)  # 2.1 gives -2 to place inside (0,1)
    else:
      return 1.0-int(x)   # -2.1 gives + 3 to place inside (0,1)

def offset_inside_cell(center,unit_cell,orthogonalize=True):
    # put the center inside (0,1)
    from scitbx.math import  matrix
    c=matrix.col(center)
    if orthogonalize:
      c_frac=unit_cell.fractionalize(c)
    else:
      c_frac=c
    offset_frac=[]
    for x in c_frac:
     offset_frac.append(offset_inside_zero_one(x))
    if orthogonalize:
      return unit_cell.orthogonalize(matrix.col(offset_frac))
    else:
      return matrix.col(offset_frac)

def get_ncs_from_text(text=None,text_is_ncs_spec=None,rotate_about_z=None,
    rotate_about_y=None,rotate_about_new_y=None,ncs_name=None,out=sys.stdout):
  from mmtbx.ncs.ncs import ncs
  import iotbx.pdb
  ncs_object=ncs()
  if text_is_ncs_spec:
    ncs_object.read_ncs(lines=text.splitlines())
  else: # read BIOMTR
    from cctbx.array_family import flex
    pdb_inp=iotbx.pdb.input(lines=flex.split_lines(text),source_info='string')
    ncs_object.ncs_from_pdb_input_BIOMT(pdb_inp=pdb_inp,log=out)

  if rotate_about_new_y:
    ncs_object.rotate_about_y(rot_deg=rotate_about_new_y,invert_matrices=True)
  if rotate_about_z:
    ncs_object.rotate_about_z(rot_deg=rotate_about_z,invert_matrices=True)
  if rotate_about_y:
    ncs_object.rotate_about_y(rot_deg=rotate_about_y,invert_matrices=True)
  if ncs_name:
    ncs_object.set_ncs_name(ncs_name)
  return ncs_object


def get_helical_symmetry(helical_rot_deg=None,
     helical_trans_z_angstrom=None,max_ops=None):

  from scitbx import matrix
  rot=get_rot_z(rot_deg=helical_rot_deg)
  rot_inv=rot.inverse()
  trans_along_z=matrix.col((0,0,helical_trans_z_angstrom))

  n=max(2,int(360/helical_rot_deg))
  if max_ops and n> max(1,max_ops//2): n= max(1,max_ops//2)
  rots=[]
  trans=[]
  rots.append(matrix.sqr((1,0,0,0,1,0,0,0,1),))
  trans.append(matrix.col((0,0,0,)))

  for i in range(n):
    rots=[rot*rots[0]]+rots[:]
    trans=[trans[0]-trans_along_z]+trans[:]

  for i in range(n):
    rots.append(rot_inv*rots[-1])
    trans.append(trans[-1]+trans_along_z)

  from mmtbx.ncs.ncs import ncs
  ncs_object=ncs()
  ncs_name="Helical %5.2f deg  %6.2f Z-trans " %(
        helical_rot_deg,helical_trans_z_angstrom)
  ncs_object.ncs_from_import(rot_list=rots,trans_list=trans)
  ncs_object.set_ncs_name(ncs_name)


  return ncs_object

def get_d_symmetry(n=None,two_fold_along_x=True,ncs_name=None):
  return get_c_symmetry(n=n,is_d=True,two_fold_along_x=two_fold_along_x,
     ncs_name=ncs_name)

def get_rot_z(rot_deg=None):
  import math
  theta=rot_deg*3.14159/180.
  cc=math.cos(theta)
  ss=math.sin(theta)
  from scitbx import matrix
  return matrix.sqr((cc,ss,0,-ss,cc,0,0,0,1,))

def get_rot_y(rot_deg=None):
  import math
  theta=rot_deg*3.14159/180.
  cc=math.cos(theta)
  ss=math.sin(theta)
  from scitbx import matrix
  return matrix.sqr((cc,0,ss,
                     0,1,0,
                    -ss,0,cc,
                     ))

def get_c_symmetry(n=None,is_d=False,two_fold_along_x=None,ncs_name=None):
  # generate n-fold C symmetry
  oper=get_rot_z(rot_deg=360./n)
  oper_inv=oper.inverse()
  rots=[]
  trans=[]
  from scitbx import matrix
  rots.append(matrix.sqr((1,0,0,0,1,0,0,0,1),))
  trans.append(matrix.col((0,0,0,)))

  for i in range(n-1):
    rots.append(oper_inv*rots[-1])
    trans.append(matrix.col((0,0,0,)))

  if is_d:
    if two_fold_along_x:
      d_oper=matrix.sqr((1,0,0,0,-1,0,0,0,-1,))
    else: # along y
      d_oper=matrix.sqr((-1,0,0,0,1,0,0,0,-1,))
    new_rots=[]
    new_trans=[]
    for r,t in zip(rots,trans):
      new_rots.append(d_oper*r)
      new_trans.append(t)
    rots+=new_rots
    trans+=new_trans

  from mmtbx.ncs.ncs import ncs

  ncs_object=ncs()
  ncs_object.ncs_from_import(rot_list=rots,trans_list=trans)
  if ncs_name:
    ncs_object.set_ncs_name(ncs_name)

  return ncs_object

def remove_extra(text):
  new_text=""
  for t in text:
    if not t.lower() in "()abcdefghijklmnopqrstuvwxyz":
      new_text+=t
  return new_text

def value(str):
  try:
    return int(remove_extra(str[1:]))
  except Exception as e:
    return 0


def generate_ncs_ops(symmetry=None,
   must_be_consistent_with_space_group_number = None,
   helical_rot_deg=None,
   helical_trans_z_angstrom=None,
   op_max=None,
   two_fold_along_x=None,
   include_helical_symmetry=None,
   max_helical_ops_to_check=None,
   require_helical_or_point_group_symmetry=None,
   out=sys.stdout):
  # Generate ncs objects corresponding to common point-group symmetries in
  #  conventional orientations such as C2 D7 etc.

  ncs_list=[]
  all=False
  sym_type=None
  sym_n=None
  if symmetry.lower() in ['all','any']:
    all=True
  elif symmetry.lower() in ["i"]:
    sym_type='I'
  elif symmetry.lower() in ["o"]:
    sym_type='O'
  elif symmetry.lower() in ["t"]:
    sym_type='T'
  elif symmetry.lower().startswith("d"):
    sym_type='D'
    if len(symmetry)>1:
      sym_n=value(symmetry)
  elif symmetry.lower().startswith("c"):
    sym_type='C'
    if len(symmetry)>1:
      sym_n=value(symmetry)
  elif symmetry.lower() in ['helical','helix']:
    sym_type='helical'

  print("Sym type: %s  Sym N: %s" %(
     sym_type,sym_n), file=out)
  if sym_type is None and not all:
    from libtbx.utils import Sorry
    raise Sorry("Unknown symmetry type: '%s' " %(symmetry))

  if sym_n:
    i_start=sym_n
    i_end=sym_n
  else:
    i_start=2
    if op_max is None:
      i_end=14
    else:
      i_end=op_max

  # NOTE: the (a) (b) etc designations are arbitrary

  from mmtbx.ncs.ncs import get_ncs_from_text, \
      get_c_symmetry,get_d_symmetry,get_helical_symmetry
  if sym_type=='I' or all:
    if two_fold_along_x is None or two_fold_along_x==False:
      ncs_list.append(get_ncs_from_text(text=icosahedral_b,
        text_is_ncs_spec=True,ncs_name='I (b)'))
      ncs_list.append(get_ncs_from_text(text=icosahedral_d,
        text_is_ncs_spec=True,ncs_name='I (d)'))
      ncs_list.append(get_ncs_from_text(text=icosahedral_f,
         text_is_ncs_spec=True,
         ncs_name='I (f)'))
    if two_fold_along_x is None or two_fold_along_x==True:
      ncs_list.append(get_ncs_from_text(text=icosahedral_b,
          rotate_about_z=90,
          text_is_ncs_spec=True,ncs_name='I (a)'))
      ncs_list.append(get_ncs_from_text(text=icosahedral_d,
          text_is_ncs_spec=True,rotate_about_z=90,
           ncs_name='I (c)'))
      ncs_list.append(get_ncs_from_text(text=icosahedral_f,
          rotate_about_z=90,text_is_ncs_spec=True,
          ncs_name='I (e)'))
  if sym_type=='O' or all:
    if two_fold_along_x is None or two_fold_along_x==True:
      ncs_list.append(get_ncs_from_text(text=octahedral_a,
        text_is_ncs_spec=True,ncs_name='O (a)'))
    if two_fold_along_x is None or two_fold_along_x==False:
      ncs_list.append(get_ncs_from_text(text=octahedral_a,
        rotate_about_z=45,
        text_is_ncs_spec=True,ncs_name='O (b)'))
  if sym_type=='T' or all:
    if two_fold_along_x is None or two_fold_along_x==False:
      ncs_list.append(get_ncs_from_text(text=tetrahedral_a,
        text_is_ncs_spec=True,ncs_name='T (a)'))
    if two_fold_along_x is None or two_fold_along_x==True:
      ncs_list.append(get_ncs_from_text(text=tetrahedral_a,
        # rotate_about_y=54.73563863,
        # rotate_about_z=-45,
        rotate_about_y=45,
        text_is_ncs_spec=True,ncs_name='T (b)'))
    ncs_list.append(get_ncs_from_text(text=tetrahedral_b,
           text_is_ncs_spec=True,ncs_name='T (c)'))

  if sym_type=='C' or all:
    for i in range(i_start,i_end+1):
      ncs_list.append(get_c_symmetry(n=i,ncs_name='C%d ' %(i)))
  if sym_type=='D' or all:
    for i in range(i_start,i_end+1):
      if two_fold_along_x is None or two_fold_along_x==True:
        ncs_list.append(get_d_symmetry(n=i,two_fold_along_x=True,
        ncs_name='D%d (a)' %(i)))
      if two_fold_along_x is None or two_fold_along_x==False:
        ncs_list.append(get_d_symmetry(n=i,two_fold_along_x=False,
        ncs_name='D%d (b)' %(i)))

  #  Pare down ncs_list if must_be_consistent_with_space_group_number is set
  if must_be_consistent_with_space_group_number:
    ncs_list=remove_ncs_not_consistent_with_space_group_number(
       must_be_consistent_with_space_group_number,ncs_list)

  if sym_type=='helical' or (
      all and include_helical_symmetry):
     if helical_rot_deg is not None and helical_trans_z_angstrom is not None:
      ncs_list.append(get_helical_symmetry(
       helical_rot_deg=helical_rot_deg,
       helical_trans_z_angstrom=helical_trans_z_angstrom,
       max_ops=max_helical_ops_to_check))

  return ncs_list

def remove_ncs_not_consistent_with_space_group_number(sg_number,ncs_list):
  ''' remove ncs ojbect that are not consistent with space_group number
     sg_number
   NOTE: allows ncs that has higher symmetry than sg_number
  '''

  from cctbx import crystal
  from cctbx import sgtbx
  from cctbx import uctbx
  sg = sgtbx.space_group_info(sg_number)
  uc = uctbx.unit_cell((10.,10.,10.,90.,90.,90.))
  cs = crystal.symmetry(unit_cell=uc ,space_group_info = sg)
  ncs_from_cs = crystal_symmetry_to_ncs(cs)
  # Make sure all ops of ncs_from_cs are in each ncs used
  new_ncs_list =[]
  for ncs_obj in ncs_list:
    if ncs_from_cs.is_similar_ncs_object(ncs_obj,abs_tol_t=10000):
      new_ncs_list.append(ncs_obj)
  ncs_list = new_ncs_list
  return ncs_list

# Symmetry for icosahedron in 3 settings


icosahedral_f=\
"""

Summary of NCS information
Mon Jul  2 11:08:24 2018
/Users/terwill/Downloads/view/ncs_text

source_info icosahedral_f.dat




new_ncs_group
new_operator

rota_matrix    1.0000    0.0000    0.0000
rota_matrix    0.0000    1.0000    0.0000
rota_matrix    0.0000    0.0000    1.0000
tran_orth     0.0000    0.0000    0.0000

center_orth  -14.5127   20.8478  102.7355
new_operator

rota_matrix    0.5000    0.8090   -0.3090
rota_matrix   -0.8090    0.3090   -0.5000
rota_matrix   -0.3090    0.5000    0.8090
tran_orth    -0.0000    0.0000   -0.0000

center_orth  -55.8696   46.0690   77.1756
new_operator

rota_matrix   -0.3090    0.5000   -0.8090
rota_matrix   -0.5000   -0.8090   -0.3090
rota_matrix   -0.8090    0.3090    0.5000
tran_orth     0.0000   -0.0000    0.0000

center_orth  -89.0540    7.6245   56.6665
new_operator

rota_matrix   -0.3090   -0.5000   -0.8090
rota_matrix    0.5000   -0.8090    0.3090
rota_matrix   -0.8090   -0.3090    0.5000
tran_orth    -0.0000    0.0000   -0.0000

center_orth  -68.2062  -41.3569   69.5511
new_operator

rota_matrix    0.5000   -0.8090   -0.3090
rota_matrix    0.8090    0.3090    0.5000
rota_matrix   -0.3090   -0.5000    0.8090
tran_orth    -0.0000   -0.0000   -0.0000

center_orth  -22.1372  -33.1844   98.0233
new_operator

rota_matrix   -1.0000    0.0000    0.0000
rota_matrix    0.0000   -1.0000    0.0000
rota_matrix    0.0000    0.0000    1.0000
tran_orth     0.0000    0.0000    0.0000

center_orth   14.5127  -20.8478  102.7355
new_operator

rota_matrix   -0.5000   -0.8090   -0.3090
rota_matrix    0.8090   -0.3090   -0.5000
rota_matrix    0.3090   -0.5000    0.8090
tran_orth    -0.0000    0.0000   -0.0000

center_orth   55.8696  -46.0690   77.1756
new_operator

rota_matrix    0.3090   -0.5000   -0.8090
rota_matrix    0.5000    0.8090   -0.3090
rota_matrix    0.8090   -0.3090    0.5000
tran_orth     0.0000   -0.0000    0.0000

center_orth   89.0540   -7.6245   56.6665
new_operator

rota_matrix    0.3090    0.5000   -0.8090
rota_matrix   -0.5000    0.8090    0.3090
rota_matrix    0.8090    0.3090    0.5000
tran_orth    -0.0000    0.0000   -0.0000

center_orth   68.2062   41.3569   69.5511
new_operator

rota_matrix   -0.5000    0.8090   -0.3090
rota_matrix   -0.8090   -0.3090    0.5000
rota_matrix    0.3090    0.5000    0.8090
tran_orth    -0.0000   -0.0000   -0.0000

center_orth   22.1372   33.1844   98.0233
new_operator

rota_matrix    1.0000    0.0000    0.0000
rota_matrix    0.0000   -1.0000    0.0000
rota_matrix    0.0000    0.0000   -1.0000
tran_orth     0.0000    0.0000    0.0000

center_orth  -14.5127  -20.8478  -102.7355
new_operator

rota_matrix    0.5000   -0.8090    0.3090
rota_matrix   -0.8090   -0.3090    0.5000
rota_matrix   -0.3090   -0.5000   -0.8090
tran_orth    -0.0000    0.0000   -0.0000

center_orth  -55.8696  -46.0690  -77.1756
new_operator

rota_matrix   -0.3090   -0.5000    0.8090
rota_matrix   -0.5000    0.8090    0.3090
rota_matrix   -0.8090   -0.3090   -0.5000
tran_orth     0.0000   -0.0000    0.0000

center_orth  -89.0540   -7.6245  -56.6665
new_operator

rota_matrix   -0.3090    0.5000    0.8090
rota_matrix    0.5000    0.8090   -0.3090
rota_matrix   -0.8090    0.3090   -0.5000
tran_orth    -0.0000    0.0000   -0.0000

center_orth  -68.2062   41.3569  -69.5511
new_operator

rota_matrix    0.5000    0.8090    0.3090
rota_matrix    0.8090   -0.3090   -0.5000
rota_matrix   -0.3090    0.5000   -0.8090
tran_orth    -0.0000   -0.0000   -0.0000

center_orth  -22.1372   33.1844  -98.0233
new_operator

rota_matrix   -1.0000    0.0000    0.0000
rota_matrix    0.0000    1.0000    0.0000
rota_matrix    0.0000    0.0000   -1.0000
tran_orth     0.0000    0.0000    0.0000

center_orth   14.5127   20.8478  -102.7355
new_operator

rota_matrix   -0.5000    0.8090    0.3090
rota_matrix    0.8090    0.3090    0.5000
rota_matrix    0.3090    0.5000   -0.8090
tran_orth    -0.0000    0.0000   -0.0000

center_orth   55.8696   46.0690  -77.1756
new_operator

rota_matrix    0.3090    0.5000    0.8090
rota_matrix    0.5000   -0.8090    0.3090
rota_matrix    0.8090    0.3090   -0.5000
tran_orth     0.0000   -0.0000    0.0000

center_orth   89.0540    7.6245  -56.6665
new_operator

rota_matrix    0.3090   -0.5000    0.8090
rota_matrix   -0.5000   -0.8090   -0.3090
rota_matrix    0.8090   -0.3090   -0.5000
tran_orth    -0.0000    0.0000   -0.0000

center_orth   68.2062  -41.3569  -69.5511
new_operator

rota_matrix   -0.5000   -0.8090    0.3090
rota_matrix   -0.8090    0.3090   -0.5000
rota_matrix    0.3090   -0.5000   -0.8090
tran_orth    -0.0000   -0.0000   -0.0000

center_orth   22.1372  -33.1844  -98.0233
new_operator

rota_matrix   -0.0000   -0.0000   -1.0000
rota_matrix   -1.0000    0.0000   -0.0000
rota_matrix    0.0000    1.0000   -0.0000
tran_orth     0.0000   -0.0000    0.0000

center_orth  -20.8478  102.7355   14.5127
new_operator

rota_matrix   -0.8090   -0.3090   -0.5000
rota_matrix   -0.3090   -0.5000    0.8090
rota_matrix   -0.5000    0.8090    0.3090
tran_orth    -0.0000    0.0000   -0.0000

center_orth  -46.0690   77.1756   55.8696
new_operator

rota_matrix   -0.5000   -0.8090    0.3090
rota_matrix    0.8090   -0.3090    0.5000
rota_matrix   -0.3090    0.5000    0.8090
tran_orth     0.0000   -0.0000    0.0000

center_orth   -7.6245   56.6665   89.0540
new_operator

rota_matrix    0.5000   -0.8090    0.3090
rota_matrix    0.8090    0.3090   -0.5000
rota_matrix    0.3090    0.5000    0.8090
tran_orth    -0.0000    0.0000   -0.0000

center_orth   41.3569   69.5511   68.2062
new_operator

rota_matrix    0.8090   -0.3090   -0.5000
rota_matrix   -0.3090    0.5000   -0.8090
rota_matrix    0.5000    0.8090    0.3090
tran_orth    -0.0000   -0.0000   -0.0000

center_orth   33.1844   98.0233   22.1372
new_operator

rota_matrix    0.0000    0.0000    1.0000
rota_matrix    1.0000    0.0000    0.0000
rota_matrix   -0.0000    1.0000    0.0000
tran_orth     0.0000   -0.0000    0.0000

center_orth   20.8478  102.7355  -14.5127
new_operator

rota_matrix    0.8090   -0.3090    0.5000
rota_matrix    0.3090   -0.5000   -0.8090
rota_matrix    0.5000    0.8090   -0.3090
tran_orth    -0.0000    0.0000   -0.0000

center_orth   46.0690   77.1756  -55.8696
new_operator

rota_matrix    0.5000   -0.8090   -0.3090
rota_matrix   -0.8090   -0.3090   -0.5000
rota_matrix    0.3090    0.5000   -0.8090
tran_orth     0.0000   -0.0000    0.0000

center_orth    7.6245   56.6665  -89.0540
new_operator

rota_matrix   -0.5000   -0.8090   -0.3090
rota_matrix   -0.8090    0.3090    0.5000
rota_matrix   -0.3090    0.5000   -0.8090
tran_orth    -0.0000    0.0000   -0.0000

center_orth  -41.3569   69.5511  -68.2062
new_operator

rota_matrix   -0.8090   -0.3090    0.5000
rota_matrix    0.3090    0.5000    0.8090
rota_matrix   -0.5000    0.8090   -0.3090
tran_orth    -0.0000   -0.0000   -0.0000

center_orth  -33.1844   98.0233  -22.1372
new_operator

rota_matrix   -0.0000   -0.0000   -1.0000
rota_matrix    1.0000   -0.0000   -0.0000
rota_matrix   -0.0000   -1.0000    0.0000
tran_orth    -0.0000   -0.0000   -0.0000

center_orth   20.8478  -102.7355   14.5127
new_operator

rota_matrix    0.8090    0.3090   -0.5000
rota_matrix    0.3090    0.5000    0.8090
rota_matrix    0.5000   -0.8090    0.3090
tran_orth    -0.0000    0.0000   -0.0000

center_orth   46.0690  -77.1756   55.8696
new_operator

rota_matrix    0.5000    0.8090    0.3090
rota_matrix   -0.8090    0.3090    0.5000
rota_matrix    0.3090   -0.5000    0.8090
tran_orth     0.0000   -0.0000    0.0000

center_orth    7.6245  -56.6665   89.0540
new_operator

rota_matrix   -0.5000    0.8090    0.3090
rota_matrix   -0.8090   -0.3090   -0.5000
rota_matrix   -0.3090   -0.5000    0.8090
tran_orth    -0.0000    0.0000   -0.0000

center_orth  -41.3569  -69.5511   68.2062
new_operator

rota_matrix   -0.8090    0.3090   -0.5000
rota_matrix    0.3090   -0.5000   -0.8090
rota_matrix   -0.5000   -0.8090    0.3090
tran_orth    -0.0000   -0.0000   -0.0000

center_orth  -33.1844  -98.0233   22.1372
new_operator

rota_matrix   -0.0000    0.0000    1.0000
rota_matrix   -1.0000   -0.0000   -0.0000
rota_matrix    0.0000   -1.0000   -0.0000
tran_orth    -0.0000   -0.0000    0.0000

center_orth  -20.8478  -102.7355  -14.5127
new_operator

rota_matrix   -0.8090    0.3090    0.5000
rota_matrix   -0.3090    0.5000   -0.8090
rota_matrix   -0.5000   -0.8090   -0.3090
tran_orth    -0.0000    0.0000   -0.0000

center_orth  -46.0690  -77.1756  -55.8696
new_operator

rota_matrix   -0.5000    0.8090   -0.3090
rota_matrix    0.8090    0.3090   -0.5000
rota_matrix   -0.3090   -0.5000   -0.8090
tran_orth     0.0000   -0.0000    0.0000

center_orth   -7.6245  -56.6665  -89.0540
new_operator

rota_matrix    0.5000    0.8090   -0.3090
rota_matrix    0.8090   -0.3090    0.5000
rota_matrix    0.3090   -0.5000   -0.8090
tran_orth    -0.0000    0.0000   -0.0000

center_orth   41.3569  -69.5511  -68.2062
new_operator

rota_matrix    0.8090    0.3090    0.5000
rota_matrix   -0.3090   -0.5000    0.8090
rota_matrix    0.5000   -0.8090   -0.3090
tran_orth    -0.0000   -0.0000   -0.0000

center_orth   33.1844  -98.0233  -22.1372
new_operator

rota_matrix   -0.0000   -1.0000    0.0000
rota_matrix    0.0000    0.0000    1.0000
rota_matrix   -1.0000    0.0000    0.0000
tran_orth    -0.0000    0.0000   -0.0000

center_orth  -102.7355   14.5127   20.8478
new_operator

rota_matrix    0.3090   -0.5000    0.8090
rota_matrix    0.5000    0.8090    0.3090
rota_matrix   -0.8090    0.3090    0.5000
tran_orth    -0.0000    0.0000   -0.0000

center_orth  -77.1756   55.8696   46.0690
new_operator

rota_matrix    0.8090    0.3090    0.5000
rota_matrix    0.3090    0.5000   -0.8090
rota_matrix   -0.5000    0.8090    0.3090
tran_orth     0.0000   -0.0000    0.0000

center_orth  -56.6665   89.0540    7.6245
new_operator

rota_matrix    0.8090    0.3090   -0.5000
rota_matrix   -0.3090   -0.5000   -0.8090
rota_matrix   -0.5000    0.8090   -0.3090
tran_orth    -0.0000    0.0000   -0.0000

center_orth  -69.5511   68.2062  -41.3569
new_operator

rota_matrix    0.3090   -0.5000   -0.8090
rota_matrix   -0.5000   -0.8090    0.3090
rota_matrix   -0.8090    0.3090   -0.5000
tran_orth    -0.0000   -0.0000   -0.0000

center_orth  -98.0233   22.1372  -33.1844
new_operator

rota_matrix   -0.0000    1.0000    0.0000
rota_matrix    0.0000    0.0000   -1.0000
rota_matrix   -1.0000   -0.0000   -0.0000
tran_orth    -0.0000    0.0000   -0.0000

center_orth  -102.7355  -14.5127  -20.8478
new_operator

rota_matrix    0.3090    0.5000   -0.8090
rota_matrix    0.5000   -0.8090   -0.3090
rota_matrix   -0.8090   -0.3090   -0.5000
tran_orth    -0.0000    0.0000   -0.0000

center_orth  -77.1756  -55.8696  -46.0690
new_operator

rota_matrix    0.8090   -0.3090   -0.5000
rota_matrix    0.3090   -0.5000    0.8090
rota_matrix   -0.5000   -0.8090   -0.3090
tran_orth     0.0000   -0.0000    0.0000

center_orth  -56.6665  -89.0540   -7.6245
new_operator

rota_matrix    0.8090   -0.3090    0.5000
rota_matrix   -0.3090    0.5000    0.8090
rota_matrix   -0.5000   -0.8090    0.3090
tran_orth    -0.0000    0.0000   -0.0000

center_orth  -69.5511  -68.2062   41.3569
new_operator

rota_matrix    0.3090    0.5000    0.8090
rota_matrix   -0.5000    0.8090   -0.3090
rota_matrix   -0.8090   -0.3090    0.5000
tran_orth    -0.0000   -0.0000   -0.0000

center_orth  -98.0233  -22.1372   33.1844
new_operator

rota_matrix    0.0000   -1.0000    0.0000
rota_matrix   -0.0000   -0.0000   -1.0000
rota_matrix    1.0000    0.0000   -0.0000
tran_orth    -0.0000    0.0000   -0.0000

center_orth  102.7355   14.5127  -20.8478
new_operator

rota_matrix   -0.3090   -0.5000   -0.8090
rota_matrix   -0.5000    0.8090   -0.3090
rota_matrix    0.8090    0.3090   -0.5000
tran_orth    -0.0000    0.0000   -0.0000

center_orth   77.1756   55.8696  -46.0690
new_operator

rota_matrix   -0.8090    0.3090   -0.5000
rota_matrix   -0.3090    0.5000    0.8090
rota_matrix    0.5000    0.8090   -0.3090
tran_orth     0.0000   -0.0000    0.0000

center_orth   56.6665   89.0540   -7.6245
new_operator

rota_matrix   -0.8090    0.3090    0.5000
rota_matrix    0.3090   -0.5000    0.8090
rota_matrix    0.5000    0.8090    0.3090
tran_orth    -0.0000    0.0000   -0.0000

center_orth   69.5511   68.2062   41.3569
new_operator

rota_matrix   -0.3090   -0.5000    0.8090
rota_matrix    0.5000   -0.8090   -0.3090
rota_matrix    0.8090    0.3090    0.5000
tran_orth    -0.0000   -0.0000   -0.0000

center_orth   98.0233   22.1372   33.1844
new_operator

rota_matrix   -0.0000    1.0000    0.0000
rota_matrix   -0.0000   -0.0000    1.0000
rota_matrix    1.0000    0.0000    0.0000
tran_orth     0.0000    0.0000    0.0000

center_orth  102.7355  -14.5127   20.8478
new_operator

rota_matrix   -0.3090    0.5000    0.8090
rota_matrix   -0.5000   -0.8090    0.3090
rota_matrix    0.8090   -0.3090    0.5000
tran_orth    -0.0000    0.0000   -0.0000

center_orth   77.1756  -55.8696   46.0690
new_operator

rota_matrix   -0.8090   -0.3090    0.5000
rota_matrix   -0.3090   -0.5000   -0.8090
rota_matrix    0.5000   -0.8090    0.3090
tran_orth     0.0000   -0.0000    0.0000

center_orth   56.6665  -89.0540    7.6245
new_operator

rota_matrix   -0.8090   -0.3090   -0.5000
rota_matrix    0.3090    0.5000   -0.8090
rota_matrix    0.5000   -0.8090   -0.3090
tran_orth    -0.0000    0.0000   -0.0000

center_orth   69.5511  -68.2062  -41.3569
new_operator

rota_matrix   -0.3090    0.5000   -0.8090
rota_matrix    0.5000    0.8090    0.3090
rota_matrix    0.8090   -0.3090   -0.5000
tran_orth    -0.0000   -0.0000   -0.0000

center_orth   98.0233  -22.1372  -33.1844


"""
icosahedral_d=\
"""

Summary of NCS information
Mon Jul  2 11:08:15 2018
/Users/terwill/Downloads/view/ncs_text

source_info icosahedral_d.dat




new_ncs_group
new_operator

rota_matrix    1.0000    0.0000    0.0000
rota_matrix    0.0000    1.0000    0.0000
rota_matrix    0.0000    0.0000    1.0000
tran_orth     0.0000    0.0000    0.0000

center_orth    0.0000    0.0000    0.0000
new_operator

rota_matrix    0.6708    0.1625    0.7236
rota_matrix   -0.6882    0.5000    0.5257
rota_matrix   -0.2764   -0.8507    0.4472
tran_orth     0.0000    0.0000    0.0000

center_orth    0.0000    0.0000    0.0000
new_operator

rota_matrix    0.1382   -0.4253    0.8944
rota_matrix   -0.9511   -0.3090    0.0000
rota_matrix    0.2764   -0.8507   -0.4472
tran_orth     0.0000    0.0000    0.0000

center_orth    0.0000    0.0000    0.0000
new_operator

rota_matrix    0.1382   -0.9511    0.2764
rota_matrix   -0.4253   -0.3090   -0.8507
rota_matrix    0.8944    0.0000   -0.4472
tran_orth     0.0000    0.0000    0.0000

center_orth    0.0000    0.0000    0.0000
new_operator

rota_matrix    0.6708   -0.6882   -0.2764
rota_matrix    0.1625    0.5000   -0.8507
rota_matrix    0.7236    0.5257    0.4472
tran_orth     0.0000    0.0000    0.0000

center_orth    0.0000    0.0000    0.0000
new_operator

rota_matrix    0.4472    0.0000    0.8944
rota_matrix    0.0000   -1.0000    0.0000
rota_matrix    0.8944    0.0000   -0.4472
tran_orth     0.0000    0.0000    0.0000

center_orth    0.0000    0.0000    0.0000
new_operator

rota_matrix    0.9472   -0.1625    0.2764
rota_matrix    0.1625   -0.5000   -0.8507
rota_matrix    0.2764    0.8507   -0.4472
tran_orth     0.0000    0.0000    0.0000

center_orth    0.0000    0.0000    0.0000
new_operator

rota_matrix    0.8618    0.4253   -0.2764
rota_matrix   -0.4253    0.3090   -0.8507
rota_matrix   -0.2764    0.8507    0.4472
tran_orth     0.0000    0.0000    0.0000

center_orth    0.0000    0.0000    0.0000
new_operator

rota_matrix    0.3090    0.9511    0.0000
rota_matrix   -0.9511    0.3090    0.0000
rota_matrix    0.0000   -0.0000    1.0000
tran_orth     0.0000    0.0000    0.0000

center_orth    0.0000    0.0000    0.0000
new_operator

rota_matrix    0.0528    0.6882    0.7236
rota_matrix   -0.6882   -0.5000    0.5257
rota_matrix    0.7236   -0.5257    0.4472
tran_orth     0.0000    0.0000    0.0000

center_orth    0.0000    0.0000    0.0000
new_operator

rota_matrix   -1.0000   -0.0000   -0.0000
rota_matrix   -0.0000    1.0000    0.0000
rota_matrix   -0.0000    0.0000   -1.0000
tran_orth     0.0000    0.0000    0.0000

center_orth    0.0000    0.0000    0.0000
new_operator

rota_matrix   -0.6708    0.1625   -0.7236
rota_matrix    0.6882    0.5000   -0.5257
rota_matrix    0.2764   -0.8507   -0.4472
tran_orth     0.0000    0.0000    0.0000

center_orth    0.0000    0.0000    0.0000
new_operator

rota_matrix   -0.1382   -0.4253   -0.8944
rota_matrix    0.9511   -0.3090   -0.0000
rota_matrix   -0.2764   -0.8507    0.4472
tran_orth     0.0000    0.0000    0.0000

center_orth    0.0000    0.0000    0.0000
new_operator

rota_matrix   -0.1382   -0.9511   -0.2764
rota_matrix    0.4253   -0.3090    0.8507
rota_matrix   -0.8944    0.0000    0.4472
tran_orth     0.0000    0.0000    0.0000

center_orth    0.0000    0.0000    0.0000
new_operator

rota_matrix   -0.6708   -0.6882    0.2764
rota_matrix   -0.1625    0.5000    0.8507
rota_matrix   -0.7236    0.5257   -0.4472
tran_orth     0.0000    0.0000    0.0000

center_orth    0.0000    0.0000    0.0000
new_operator

rota_matrix   -0.4472   -0.0000   -0.8944
rota_matrix   -0.0000   -1.0000    0.0000
rota_matrix   -0.8944    0.0000    0.4472
tran_orth     0.0000    0.0000    0.0000

center_orth    0.0000    0.0000    0.0000
new_operator

rota_matrix   -0.9472   -0.1625   -0.2764
rota_matrix   -0.1625   -0.5000    0.8507
rota_matrix   -0.2764    0.8507    0.4472
tran_orth     0.0000    0.0000    0.0000

center_orth    0.0000    0.0000    0.0000
new_operator

rota_matrix   -0.8618    0.4253    0.2764
rota_matrix    0.4253    0.3090    0.8507
rota_matrix    0.2764    0.8507   -0.4472
tran_orth     0.0000    0.0000    0.0000

center_orth    0.0000    0.0000    0.0000
new_operator

rota_matrix   -0.3090    0.9511   -0.0000
rota_matrix    0.9511    0.3090   -0.0000
rota_matrix   -0.0000   -0.0000   -1.0000
tran_orth     0.0000    0.0000    0.0000

center_orth    0.0000    0.0000    0.0000
new_operator

rota_matrix   -0.0528    0.6882   -0.7236
rota_matrix    0.6882   -0.5000   -0.5257
rota_matrix   -0.7236   -0.5257   -0.4472
tran_orth     0.0000    0.0000    0.0000

center_orth    0.0000    0.0000    0.0000
new_operator

rota_matrix   -0.4472    0.5257    0.7236
rota_matrix   -0.8507   -0.0000   -0.5257
rota_matrix   -0.2764   -0.8507    0.4472
tran_orth     0.0000    0.0000    0.0000

center_orth    0.0000    0.0000    0.0000
new_operator

rota_matrix   -0.6382   -0.2629    0.7236
rota_matrix   -0.2629   -0.8090   -0.5257
rota_matrix    0.7236   -0.5257    0.4472
tran_orth     0.0000    0.0000    0.0000

center_orth    0.0000    0.0000    0.0000
new_operator

rota_matrix    0.0528   -0.6882    0.7236
rota_matrix    0.6882   -0.5000   -0.5257
rota_matrix    0.7236    0.5257    0.4472
tran_orth     0.0000    0.0000    0.0000

center_orth    0.0000    0.0000    0.0000
new_operator

rota_matrix    0.6708   -0.1625    0.7236
rota_matrix    0.6882    0.5000   -0.5257
rota_matrix   -0.2764    0.8507    0.4472
tran_orth     0.0000    0.0000    0.0000

center_orth    0.0000    0.0000    0.0000
new_operator

rota_matrix    0.3618    0.5878    0.7236
rota_matrix   -0.2629    0.8090   -0.5257
rota_matrix   -0.8944   -0.0000    0.4472
tran_orth     0.0000    0.0000    0.0000

center_orth    0.0000    0.0000    0.0000
new_operator

rota_matrix   -0.4472   -0.5257    0.7236
rota_matrix    0.8507    0.0000    0.5257
rota_matrix   -0.2764    0.8507    0.4472
tran_orth     0.0000    0.0000    0.0000

center_orth    0.0000    0.0000    0.0000
new_operator

rota_matrix   -0.3618    0.2629    0.8944
rota_matrix    0.5878    0.8090   -0.0000
rota_matrix   -0.7236    0.5257   -0.4472
tran_orth     0.0000    0.0000    0.0000

center_orth    0.0000    0.0000    0.0000
new_operator

rota_matrix   -0.6708    0.6882    0.2764
rota_matrix    0.1625    0.5000   -0.8507
rota_matrix   -0.7236   -0.5257   -0.4472
tran_orth     0.0000    0.0000    0.0000

center_orth    0.0000    0.0000    0.0000
new_operator

rota_matrix   -0.9472    0.1625   -0.2764
rota_matrix    0.1625   -0.5000   -0.8507
rota_matrix   -0.2764   -0.8507    0.4472
tran_orth     0.0000    0.0000    0.0000

center_orth    0.0000    0.0000    0.0000
new_operator

rota_matrix   -0.8090   -0.5878    0.0000
rota_matrix    0.5878   -0.8090   -0.0000
rota_matrix    0.0000    0.0000    1.0000
tran_orth     0.0000    0.0000    0.0000

center_orth    0.0000    0.0000    0.0000
new_operator

rota_matrix    0.4472   -0.5257   -0.7236
rota_matrix   -0.8507   -0.0000   -0.5257
rota_matrix    0.2764    0.8507   -0.4472
tran_orth     0.0000    0.0000    0.0000

center_orth    0.0000    0.0000    0.0000
new_operator

rota_matrix    0.3618    0.2629   -0.8944
rota_matrix   -0.5878    0.8090    0.0000
rota_matrix    0.7236    0.5257    0.4472
tran_orth     0.0000    0.0000    0.0000

center_orth    0.0000    0.0000    0.0000
new_operator

rota_matrix    0.6708    0.6882   -0.2764
rota_matrix   -0.1625    0.5000    0.8507
rota_matrix    0.7236   -0.5257    0.4472
tran_orth     0.0000    0.0000    0.0000

center_orth    0.0000    0.0000    0.0000
new_operator

rota_matrix    0.9472    0.1625    0.2764
rota_matrix   -0.1625   -0.5000    0.8507
rota_matrix    0.2764   -0.8507   -0.4472
tran_orth     0.0000    0.0000    0.0000

center_orth    0.0000    0.0000    0.0000
new_operator

rota_matrix    0.8090   -0.5878   -0.0000
rota_matrix   -0.5878   -0.8090    0.0000
rota_matrix   -0.0000    0.0000   -1.0000
tran_orth     0.0000    0.0000    0.0000

center_orth    0.0000    0.0000    0.0000
new_operator

rota_matrix    0.4472    0.5257   -0.7236
rota_matrix    0.8507    0.0000    0.5257
rota_matrix    0.2764   -0.8507   -0.4472
tran_orth     0.0000    0.0000    0.0000

center_orth    0.0000    0.0000    0.0000
new_operator

rota_matrix    0.6382   -0.2629   -0.7236
rota_matrix    0.2629   -0.8090    0.5257
rota_matrix   -0.7236   -0.5257   -0.4472
tran_orth     0.0000    0.0000    0.0000

center_orth    0.0000    0.0000    0.0000
new_operator

rota_matrix   -0.0528   -0.6882   -0.7236
rota_matrix   -0.6882   -0.5000    0.5257
rota_matrix   -0.7236    0.5257   -0.4472
tran_orth     0.0000    0.0000    0.0000

center_orth    0.0000    0.0000    0.0000
new_operator

rota_matrix   -0.6708   -0.1625   -0.7236
rota_matrix   -0.6882    0.5000    0.5257
rota_matrix    0.2764    0.8507   -0.4472
tran_orth     0.0000    0.0000    0.0000

center_orth    0.0000    0.0000    0.0000
new_operator

rota_matrix   -0.3618    0.5878   -0.7236
rota_matrix    0.2629    0.8090    0.5257
rota_matrix    0.8944   -0.0000   -0.4472
tran_orth     0.0000    0.0000    0.0000

center_orth    0.0000    0.0000    0.0000
new_operator

rota_matrix   -0.4472   -0.8507   -0.2764
rota_matrix    0.5257   -0.0000   -0.8507
rota_matrix    0.7236   -0.5257    0.4472
tran_orth     0.0000    0.0000    0.0000

center_orth    0.0000    0.0000    0.0000
new_operator

rota_matrix    0.3090   -0.9511    0.0000
rota_matrix    0.9511    0.3090   -0.0000
rota_matrix    0.0000    0.0000    1.0000
tran_orth     0.0000    0.0000    0.0000

center_orth    0.0000    0.0000    0.0000
new_operator

rota_matrix    0.3618   -0.5878    0.7236
rota_matrix    0.2629    0.8090    0.5257
rota_matrix   -0.8944    0.0000    0.4472
tran_orth     0.0000    0.0000    0.0000

center_orth    0.0000    0.0000    0.0000
new_operator

rota_matrix   -0.3618   -0.2629    0.8944
rota_matrix   -0.5878    0.8090    0.0000
rota_matrix   -0.7236   -0.5257   -0.4472
tran_orth     0.0000    0.0000    0.0000

center_orth    0.0000    0.0000    0.0000
new_operator

rota_matrix   -0.8618   -0.4253    0.2764
rota_matrix   -0.4253    0.3090   -0.8507
rota_matrix    0.2764   -0.8507   -0.4472
tran_orth     0.0000    0.0000    0.0000

center_orth    0.0000    0.0000    0.0000
new_operator

rota_matrix    0.4472   -0.8507    0.2764
rota_matrix   -0.5257   -0.0000    0.8507
rota_matrix   -0.7236   -0.5257   -0.4472
tran_orth     0.0000    0.0000    0.0000

center_orth    0.0000    0.0000    0.0000
new_operator

rota_matrix   -0.3090   -0.9511   -0.0000
rota_matrix   -0.9511    0.3090    0.0000
rota_matrix   -0.0000    0.0000   -1.0000
tran_orth     0.0000    0.0000    0.0000

center_orth    0.0000    0.0000    0.0000
new_operator

rota_matrix   -0.3618   -0.5878   -0.7236
rota_matrix   -0.2629    0.8090   -0.5257
rota_matrix    0.8944    0.0000   -0.4472
tran_orth     0.0000    0.0000    0.0000

center_orth    0.0000    0.0000    0.0000
new_operator

rota_matrix    0.3618   -0.2629   -0.8944
rota_matrix    0.5878    0.8090   -0.0000
rota_matrix    0.7236   -0.5257    0.4472
tran_orth     0.0000    0.0000    0.0000

center_orth    0.0000    0.0000    0.0000
new_operator

rota_matrix    0.8618   -0.4253   -0.2764
rota_matrix    0.4253    0.3090    0.8507
rota_matrix   -0.2764   -0.8507    0.4472
tran_orth     0.0000    0.0000    0.0000

center_orth    0.0000    0.0000    0.0000
new_operator

rota_matrix    0.4472    0.8507    0.2764
rota_matrix    0.5257    0.0000   -0.8507
rota_matrix   -0.7236    0.5257   -0.4472
tran_orth     0.0000    0.0000    0.0000

center_orth    0.0000    0.0000    0.0000
new_operator

rota_matrix   -0.1382    0.9511   -0.2764
rota_matrix   -0.4253   -0.3090   -0.8507
rota_matrix   -0.8944   -0.0000    0.4472
tran_orth     0.0000    0.0000    0.0000

center_orth    0.0000    0.0000    0.0000
new_operator

rota_matrix   -0.8090    0.5878    0.0000
rota_matrix   -0.5878   -0.8090    0.0000
rota_matrix    0.0000   -0.0000    1.0000
tran_orth     0.0000    0.0000    0.0000

center_orth    0.0000    0.0000    0.0000
new_operator

rota_matrix   -0.6382    0.2629    0.7236
rota_matrix    0.2629   -0.8090    0.5257
rota_matrix    0.7236    0.5257    0.4472
tran_orth     0.0000    0.0000    0.0000

center_orth    0.0000    0.0000    0.0000
new_operator

rota_matrix    0.1382    0.4253    0.8944
rota_matrix    0.9511   -0.3090   -0.0000
rota_matrix    0.2764    0.8507   -0.4472
tran_orth     0.0000    0.0000    0.0000

center_orth    0.0000    0.0000    0.0000
new_operator

rota_matrix   -0.4472    0.8507   -0.2764
rota_matrix   -0.5257    0.0000    0.8507
rota_matrix    0.7236    0.5257    0.4472
tran_orth     0.0000    0.0000    0.0000

center_orth    0.0000    0.0000    0.0000
new_operator

rota_matrix    0.1382    0.9511    0.2764
rota_matrix    0.4253   -0.3090    0.8507
rota_matrix    0.8944   -0.0000   -0.4472
tran_orth     0.0000    0.0000    0.0000

center_orth    0.0000    0.0000    0.0000
new_operator

rota_matrix    0.8090    0.5878   -0.0000
rota_matrix    0.5878   -0.8090   -0.0000
rota_matrix   -0.0000   -0.0000   -1.0000
tran_orth     0.0000    0.0000    0.0000

center_orth    0.0000    0.0000    0.0000
new_operator

rota_matrix    0.6382    0.2629   -0.7236
rota_matrix   -0.2629   -0.8090   -0.5257
rota_matrix   -0.7236    0.5257   -0.4472
tran_orth     0.0000    0.0000    0.0000

center_orth    0.0000    0.0000    0.0000
new_operator

rota_matrix   -0.1382    0.4253   -0.8944
rota_matrix   -0.9511   -0.3090    0.0000
rota_matrix   -0.2764    0.8507    0.4472
tran_orth     0.0000    0.0000    0.0000

center_orth    0.0000    0.0000    0.0000


"""
tetrahedral_a=\
"""
new_operator
rota_matrix  1.000  0.000  0.000
rota_matrix  0.000  1.000  0.000
rota_matrix  0.000  0.000  1.000
tran_orth  0.000  0.000  0.000
center_orth  0.000  0.000  0.000
new_operator
rota_matrix  0.833  0.289  -0.471
rota_matrix  -0.288  -0.500  -0.816
rota_matrix  -0.472  0.816  -0.334
tran_orth  0.000  0.000  0.000
center_orth  0.000  0.000  0.000
new_operator
rota_matrix  -0.668  -0.577  -0.471
rota_matrix  -0.578  0.003  0.816
rota_matrix  -0.469  0.817  -0.335
tran_orth  0.000  0.000  0.000
center_orth  0.000  0.000  0.000
new_operator
rota_matrix  -0.166  0.290  0.943
rota_matrix  0.867  0.499  -0.001
rota_matrix  -0.471  0.817  -0.334
tran_orth  0.000  0.000  0.000
center_orth  0.000  0.000  0.000
new_operator
rota_matrix  -0.500  0.866  -0.000
rota_matrix  -0.866  -0.500  0.000
rota_matrix  0.000  0.001  1.000
tran_orth  0.000  0.000  0.000
center_orth  0.000  0.000  0.000
new_operator
rota_matrix  -0.667  0.577  -0.471
rota_matrix  0.578  0.000  -0.816
rota_matrix  -0.471  -0.817  -0.333
tran_orth  0.000  0.000  0.000
center_orth  0.000  0.000  0.000
new_operator
rota_matrix  0.833  -0.290  -0.471
rota_matrix  0.287  -0.501  0.816
rota_matrix  -0.473  -0.815  -0.335
tran_orth  0.000  0.000  0.000
center_orth  0.000  0.000  0.000
new_operator
rota_matrix  -0.168  -0.288  0.943
rota_matrix  -0.866  0.501  -0.001
rota_matrix  -0.472  -0.816  -0.334
tran_orth  0.000  0.000  0.000
center_orth  0.000  0.000  0.000
new_operator
rota_matrix  -0.500  -0.866  0.000
rota_matrix  0.866  -0.500  0.001
rota_matrix  -0.000  0.000  1.000
tran_orth  0.000  0.000  0.000
center_orth  0.000  0.000  0.000
new_operator
rota_matrix  -0.166  -0.866  -0.471
rota_matrix  -0.289  0.500  -0.817
rota_matrix  0.943  0.000  -0.333
tran_orth  0.000  0.000  0.000
center_orth  0.000  0.000  0.000
new_operator
rota_matrix  -0.165  0.866  -0.471
rota_matrix  0.291  0.499  0.816
rota_matrix  0.942  -0.002  -0.335
tran_orth  0.000  0.000  0.000
center_orth  0.000  0.000  0.000
new_operator
rota_matrix  0.334  -0.001  0.943
rota_matrix  -0.001  -1.000  -0.001
rota_matrix  0.943  -0.001  -0.334
tran_orth  0.000  0.000  0.000
center_orth  0.000  0.000  0.000
"""


tetrahedral_b=\
"""
new_operator
rota_matrix  1.000  0.000  0.000
rota_matrix  0.000  1.000  0.000
rota_matrix  0.000  0.000  1.000
tran_orth  0.000  0.000  0.000
center_orth  0.000  0.000  0.000
new_operator
rota_matrix  -1.000  0.001  0.001
rota_matrix  0.001  0.333  0.943
rota_matrix  0.000  0.943  -0.333
tran_orth  0.000  0.000  0.000
center_orth  0.000  0.000  0.000
new_operator
rota_matrix  0.499  0.288  0.818
rota_matrix  0.867  -0.166  -0.470
rota_matrix  0.001  0.943  -0.333
tran_orth  0.000  0.000  0.000
center_orth  0.000  0.000  0.000
new_operator
rota_matrix  0.498  -0.287  -0.818
rota_matrix  -0.867  -0.167  -0.469
rota_matrix  -0.002  0.943  -0.332
tran_orth  0.000  0.000  0.000
center_orth  0.000  0.000  0.000
new_operator
rota_matrix  -0.500  0.866  -0.000
rota_matrix  -0.866  -0.500  -0.000
rota_matrix  -0.000  0.000  1.000
tran_orth  0.000  0.000  0.000
center_orth  0.000  0.000  0.000
new_operator
rota_matrix  0.499  -0.866  0.001
rota_matrix  -0.289  -0.166  0.943
rota_matrix  -0.817  -0.471  -0.334
tran_orth  0.000  0.000  0.000
center_orth  0.000  0.000  0.000
new_operator
rota_matrix  -0.498  0.287  0.818
rota_matrix  -0.289  0.834  -0.469
rota_matrix  -0.817  -0.471  -0.332
tran_orth  0.000  0.000  0.000
center_orth  0.000  0.000  0.000
new_operator
rota_matrix  0.000  0.574  -0.819
rota_matrix  0.578  -0.668  -0.469
rota_matrix  -0.816  -0.473  -0.332
tran_orth  0.000  0.000  0.000
center_orth  0.000  0.000  0.000
new_operator
rota_matrix  -0.500  -0.866  0.000
rota_matrix  0.866  -0.500  -0.000
rota_matrix  0.000  -0.000  1.000
tran_orth  0.000  0.000  0.000
center_orth  0.000  0.000  0.000
new_operator
rota_matrix  0.501  0.866  0.001
rota_matrix  0.289  -0.168  0.943
rota_matrix  0.816  -0.472  -0.334
tran_orth  0.000  0.000  0.000
center_orth  0.000  0.000  0.000
new_operator
rota_matrix  -0.000  -0.577  0.817
rota_matrix  -0.578  -0.667  -0.470
rota_matrix  0.816  -0.472  -0.333
tran_orth  0.000  0.000  0.000
center_orth  0.000  0.000  0.000
new_operator
rota_matrix  -0.498  -0.288  -0.818
rota_matrix  0.289  0.834  -0.470
rota_matrix  0.818  -0.470  -0.332
tran_orth  0.000  0.000  0.000
center_orth  0.000  0.000  0.000
"""
octahedral_a=\
"""
new_operator
rota_matrix  1.0  0.0  0.0
rota_matrix  0.0  1.0  0.0
rota_matrix  0.0  0.0  1.0
tran_orth  0.0  0.0  0.0
center_orth  0.0  0.0  0.0
new_operator
rota_matrix  0.0  -1.0  -0.0
rota_matrix  1.0  0.0  0.0
rota_matrix  -0.0  -0.0  1.0
tran_orth  0.0  0.0  0.0
center_orth  0.0  0.0  0.0
new_operator
rota_matrix  -1.0  0.0  -0.0
rota_matrix  -0.0  -1.0  0.0
rota_matrix  -0.0  0.0  1.0
tran_orth  0.0  0.0  0.0
center_orth  0.0  0.0  0.0
new_operator
rota_matrix  0.0  1.0  -0.0
rota_matrix  -0.0  -0.0  -1.0
rota_matrix  -1.0  0.0  0.0
tran_orth  0.0  0.0  0.0
center_orth  0.0  0.0  0.0
new_operator
rota_matrix  0.0  -0.0  1.0
rota_matrix  -0.0  1.0  0.0
rota_matrix  -1.0  -0.0  0.0
tran_orth  0.0  0.0  0.0
center_orth  0.0  0.0  0.0
new_operator
rota_matrix  -1.0  0.0  -0.0
rota_matrix  0.0  -0.0  -1.0
rota_matrix  -0.0  -1.0  0.0
tran_orth  0.0  0.0  0.0
center_orth  0.0  0.0  0.0
new_operator
rota_matrix  -0.0  0.0  -1.0
rota_matrix  1.0  -0.0  -0.0
rota_matrix  -0.0  -1.0  -0.0
tran_orth  0.0  0.0  0.0
center_orth  0.0  0.0  0.0
new_operator
rota_matrix  -0.0  1.0  -0.0
rota_matrix  -1.0  -0.0  0.0
rota_matrix  0.0  0.0  1.0
tran_orth  0.0  0.0  0.0
center_orth  0.0  0.0  0.0
new_operator
rota_matrix  -0.0  -1.0  -0.0
rota_matrix  0.0  0.0  -1.0
rota_matrix  1.0  -0.0  0.0
tran_orth  0.0  0.0  0.0
center_orth  0.0  0.0  0.0
new_operator
rota_matrix  1.0  -0.0  -0.0
rota_matrix  -0.0  0.0  -1.0
rota_matrix  0.0  1.0  0.0
tran_orth  0.0  0.0  0.0
center_orth  0.0  0.0  0.0
new_operator
rota_matrix  -0.0  -0.0  1.0
rota_matrix  0.0  -1.0  -0.0
rota_matrix  1.0  0.0  0.0
tran_orth  0.0  0.0  0.0
center_orth  0.0  0.0  0.0
new_operator
rota_matrix  -0.0  -0.0  1.0
rota_matrix  1.0  0.0  0.0
rota_matrix  -0.0  1.0  0.0
tran_orth  0.0  0.0  0.0
center_orth  0.0  0.0  0.0
new_operator
rota_matrix  0.0  0.0  -1.0
rota_matrix  -0.0  -1.0  -0.0
rota_matrix  -1.0  0.0  -0.0
tran_orth  0.0  0.0  0.0
center_orth  0.0  0.0  0.0
new_operator
rota_matrix  0.0  -1.0  0.0
rota_matrix  -0.0  0.0  1.0
rota_matrix  -1.0  -0.0  -0.0
tran_orth  0.0  0.0  0.0
center_orth  0.0  0.0  0.0
new_operator
rota_matrix  -0.0  1.0  0.0
rota_matrix  0.0  -0.0  1.0
rota_matrix  1.0  0.0  -0.0
tran_orth  0.0  0.0  0.0
center_orth  0.0  0.0  0.0
new_operator
rota_matrix  0.0  -0.0  -1.0
rota_matrix  -1.0  0.0  -0.0
rota_matrix  0.0  1.0  -0.0
tran_orth  0.0  0.0  0.0
center_orth  0.0  0.0  0.0
new_operator
rota_matrix  -1.0  -0.0  0.0
rota_matrix  0.0  0.0  1.0
rota_matrix  -0.0  1.0  -0.0
tran_orth  0.0  0.0  0.0
center_orth  0.0  0.0  0.0
new_operator
rota_matrix  1.0  0.0  0.0
rota_matrix  0.0  -1.0  -0.0
rota_matrix  0.0  0.0  -1.0
tran_orth  0.0  0.0  0.0
center_orth  0.0  0.0  0.0
new_operator
rota_matrix  0.0  1.0  0.0
rota_matrix  1.0  -0.0  -0.0
rota_matrix  -0.0  0.0  -1.0
tran_orth  0.0  0.0  0.0
center_orth  0.0  0.0  0.0
new_operator
rota_matrix  -1.0  0.0  0.0
rota_matrix  0.0  1.0  -0.0
rota_matrix  -0.0  -0.0  -1.0
tran_orth  0.0  0.0  0.0
center_orth  0.0  0.0  0.0
new_operator
rota_matrix  0.0  -1.0  0.0
rota_matrix  -1.0  -0.0  -0.0
rota_matrix  0.0  -0.0  -1.0
tran_orth  0.0  0.0  0.0
center_orth  0.0  0.0  0.0
new_operator
rota_matrix  1.0  0.0  0.0
rota_matrix  -0.0  -0.0  1.0
rota_matrix  0.0  -1.0  -0.0
tran_orth  0.0  0.0  0.0
center_orth  0.0  0.0  0.0
new_operator
rota_matrix  -0.0  0.0  -1.0
rota_matrix  0.0  1.0  0.0
rota_matrix  1.0  -0.0  -0.0
tran_orth  0.0  0.0  0.0
center_orth  0.0  0.0  0.0
new_operator
rota_matrix  -0.0  0.0  1.0
rota_matrix  -1.0  -0.0  -0.0
rota_matrix  0.0  -1.0  0.0
tran_orth  0.0  0.0  0.0
center_orth  0.0  0.0  0.0
"""

icosahedral_b=\
"""

Summary of NCS information
Mon Jul  2 11:07:59 2018
/Users/terwill/Downloads/view/ncs_text

source_info icosahedral_b.dat




new_ncs_group
new_operator

rota_matrix    1.0000   -0.0000    0.0000
rota_matrix    0.0000    1.0000    0.0000
rota_matrix    0.0000   -0.0000    1.0000
tran_orth     0.0000    0.0000    0.0000

center_orth    0.0000    0.0000    0.0000
new_operator

rota_matrix    0.3090    0.9511   -0.0001
rota_matrix   -0.9511    0.3090   -0.0002
rota_matrix   -0.0001    0.0002    1.0000
tran_orth     0.0000    0.0000    0.0000

center_orth    0.0000    0.0000    0.0000
new_operator

rota_matrix   -0.8090    0.5878   -0.0003
rota_matrix   -0.5878   -0.8090   -0.0001
rota_matrix   -0.0003    0.0001    1.0000
tran_orth     0.0000    0.0000    0.0000

center_orth    0.0000    0.0000    0.0000
new_operator

rota_matrix   -0.8090   -0.5878   -0.0003
rota_matrix    0.5878   -0.8090    0.0001
rota_matrix   -0.0003   -0.0001    1.0000
tran_orth     0.0000    0.0000    0.0000

center_orth    0.0000    0.0000    0.0000
new_operator

rota_matrix    0.3090   -0.9511   -0.0001
rota_matrix    0.9511    0.3090    0.0002
rota_matrix   -0.0001   -0.0002    1.0000
tran_orth     0.0000    0.0000    0.0000

center_orth    0.0000    0.0000    0.0000
new_operator

rota_matrix   -0.9473   -0.1623    0.2761
rota_matrix   -0.1623   -0.5000   -0.8507
rota_matrix    0.2761   -0.8507    0.4473
tran_orth     0.0000    0.0000    0.0000

center_orth    0.0000    0.0000    0.0000
new_operator

rota_matrix   -0.4471   -0.5256   -0.7238
rota_matrix    0.8508    0.0000   -0.5256
rota_matrix    0.2762   -0.8508    0.4471
tran_orth     0.0000    0.0000    0.0000

center_orth    0.0000    0.0000    0.0000
new_operator

rota_matrix    0.6709   -0.1623   -0.7236
rota_matrix    0.6881    0.5000    0.5259
rota_matrix    0.2764   -0.8507    0.4471
tran_orth     0.0000    0.0000    0.0000

center_orth    0.0000    0.0000    0.0000
new_operator

rota_matrix    0.8617    0.4255    0.2765
rota_matrix   -0.4255    0.3090    0.8506
rota_matrix    0.2765   -0.8506    0.4473
tran_orth     0.0000    0.0000    0.0000

center_orth    0.0000    0.0000    0.0000
new_operator

rota_matrix   -0.1384    0.4255    0.8943
rota_matrix   -0.9511   -0.3090   -0.0002
rota_matrix    0.2763   -0.8506    0.4474
tran_orth     0.0000    0.0000    0.0000

center_orth    0.0000    0.0000    0.0000
new_operator

rota_matrix   -0.8617   -0.4255   -0.2765
rota_matrix   -0.4255    0.3090    0.8506
rota_matrix   -0.2765    0.8506   -0.4473
tran_orth     0.0000    0.0000    0.0000

center_orth    0.0000    0.0000    0.0000
new_operator

rota_matrix   -0.6709    0.1623    0.7236
rota_matrix    0.6881    0.5000    0.5259
rota_matrix   -0.2764    0.8507   -0.4471
tran_orth     0.0000    0.0000    0.0000

center_orth    0.0000    0.0000    0.0000
new_operator

rota_matrix    0.4471    0.5256    0.7238
rota_matrix    0.8508    0.0000   -0.5256
rota_matrix   -0.2762    0.8508   -0.4471
tran_orth     0.0000    0.0000    0.0000

center_orth    0.0000    0.0000    0.0000
new_operator

rota_matrix    0.9473    0.1623   -0.2761
rota_matrix   -0.1623   -0.5000   -0.8507
rota_matrix   -0.2761    0.8507   -0.4473
tran_orth     0.0000    0.0000    0.0000

center_orth    0.0000    0.0000    0.0000
new_operator

rota_matrix    0.1384   -0.4255   -0.8943
rota_matrix   -0.9511   -0.3090   -0.0002
rota_matrix   -0.2763    0.8506   -0.4474
tran_orth     0.0000    0.0000    0.0000

center_orth    0.0000    0.0000    0.0000
new_operator

rota_matrix    0.8090    0.5878    0.0003
rota_matrix    0.5878   -0.8090    0.0001
rota_matrix    0.0003    0.0001   -1.0000
tran_orth     0.0000    0.0000    0.0000

center_orth    0.0000    0.0000    0.0000
new_operator

rota_matrix    0.8090   -0.5878    0.0003
rota_matrix   -0.5878   -0.8090   -0.0001
rota_matrix    0.0003   -0.0001   -1.0000
tran_orth     0.0000    0.0000    0.0000

center_orth    0.0000    0.0000    0.0000
new_operator

rota_matrix   -0.3090   -0.9511    0.0001
rota_matrix   -0.9511    0.3090   -0.0002
rota_matrix    0.0001   -0.0002   -1.0000
tran_orth     0.0000    0.0000    0.0000

center_orth    0.0000    0.0000    0.0000
new_operator

rota_matrix   -1.0000    0.0000    0.0000
rota_matrix    0.0000    1.0000    0.0000
rota_matrix    0.0000    0.0000   -1.0000
tran_orth     0.0000    0.0000    0.0000

center_orth    0.0000    0.0000    0.0000
new_operator

rota_matrix   -0.3090    0.9511    0.0001
rota_matrix    0.9511    0.3090    0.0002
rota_matrix    0.0001    0.0002   -1.0000
tran_orth     0.0000    0.0000    0.0000

center_orth    0.0000    0.0000    0.0000
new_operator

rota_matrix   -0.1384    0.9511    0.2763
rota_matrix   -0.4255   -0.3090    0.8506
rota_matrix    0.8943    0.0002    0.4474
tran_orth     0.0000    0.0000    0.0000

center_orth    0.0000    0.0000    0.0000
new_operator

rota_matrix   -0.4476    0.0000    0.8943
rota_matrix    0.0000   -1.0000   -0.0000
rota_matrix    0.8943   -0.0000    0.4476
tran_orth     0.0000    0.0000    0.0000

center_orth    0.0000    0.0000    0.0000
new_operator

rota_matrix   -0.1384   -0.9511    0.2763
rota_matrix    0.4255   -0.3090   -0.8506
rota_matrix    0.8943   -0.0002    0.4474
tran_orth     0.0000    0.0000    0.0000

center_orth    0.0000    0.0000    0.0000
new_operator

rota_matrix    0.3618   -0.5878   -0.7236
rota_matrix    0.2630    0.8090   -0.5257
rota_matrix    0.8944   -0.0001    0.4472
tran_orth     0.0000    0.0000    0.0000

center_orth    0.0000    0.0000    0.0000
new_operator

rota_matrix    0.3618    0.5878   -0.7236
rota_matrix   -0.2630    0.8090    0.5257
rota_matrix    0.8944    0.0001    0.4472
tran_orth     0.0000    0.0000    0.0000

center_orth    0.0000    0.0000    0.0000
new_operator

rota_matrix    0.4471   -0.8508   -0.2762
rota_matrix   -0.5256    0.0000   -0.8508
rota_matrix    0.7238    0.5256   -0.4471
tran_orth     0.0000    0.0000    0.0000

center_orth    0.0000    0.0000    0.0000
new_operator

rota_matrix   -0.3618   -0.2630   -0.8944
rota_matrix   -0.5878    0.8090   -0.0001
rota_matrix    0.7236    0.5257   -0.4472
tran_orth     0.0000    0.0000    0.0000

center_orth    0.0000    0.0000    0.0000
new_operator

rota_matrix   -0.6709    0.6881   -0.2764
rota_matrix    0.1623    0.5000    0.8507
rota_matrix    0.7236    0.5259   -0.4471
tran_orth     0.0000    0.0000    0.0000

center_orth    0.0000    0.0000    0.0000
new_operator

rota_matrix   -0.0531    0.6881    0.7237
rota_matrix    0.6881   -0.5000    0.5259
rota_matrix    0.7237    0.5259   -0.4469
tran_orth     0.0000    0.0000    0.0000

center_orth    0.0000    0.0000    0.0000
new_operator

rota_matrix    0.6379   -0.2630    0.7238
rota_matrix    0.2630   -0.8090   -0.5257
rota_matrix    0.7238    0.5257   -0.4469
tran_orth     0.0000    0.0000    0.0000

center_orth    0.0000    0.0000    0.0000
new_operator

rota_matrix    0.0531   -0.6881   -0.7237
rota_matrix    0.6881   -0.5000    0.5259
rota_matrix   -0.7237   -0.5259    0.4469
tran_orth     0.0000    0.0000    0.0000

center_orth    0.0000    0.0000    0.0000
new_operator

rota_matrix    0.6709   -0.6881    0.2764
rota_matrix    0.1623    0.5000    0.8507
rota_matrix   -0.7236   -0.5259    0.4471
tran_orth     0.0000    0.0000    0.0000

center_orth    0.0000    0.0000    0.0000
new_operator

rota_matrix    0.3618    0.2630    0.8944
rota_matrix   -0.5878    0.8090   -0.0001
rota_matrix   -0.7236   -0.5257    0.4472
tran_orth     0.0000    0.0000    0.0000

center_orth    0.0000    0.0000    0.0000
new_operator

rota_matrix   -0.4471    0.8508    0.2762
rota_matrix   -0.5256    0.0000   -0.8508
rota_matrix   -0.7238   -0.5256    0.4471
tran_orth     0.0000    0.0000    0.0000

center_orth    0.0000    0.0000    0.0000
new_operator

rota_matrix   -0.6379    0.2630   -0.7238
rota_matrix    0.2630   -0.8090   -0.5257
rota_matrix   -0.7238   -0.5257    0.4469
tran_orth     0.0000    0.0000    0.0000

center_orth    0.0000    0.0000    0.0000
new_operator

rota_matrix   -0.3618    0.5878    0.7236
rota_matrix    0.2630    0.8090   -0.5257
rota_matrix   -0.8944    0.0001   -0.4472
tran_orth     0.0000    0.0000    0.0000

center_orth    0.0000    0.0000    0.0000
new_operator

rota_matrix    0.1384    0.9511   -0.2763
rota_matrix    0.4255   -0.3090   -0.8506
rota_matrix   -0.8943    0.0002   -0.4474
tran_orth     0.0000    0.0000    0.0000

center_orth    0.0000    0.0000    0.0000
new_operator

rota_matrix    0.4476   -0.0000   -0.8943
rota_matrix   -0.0000   -1.0000    0.0000
rota_matrix   -0.8943    0.0000   -0.4476
tran_orth     0.0000    0.0000    0.0000

center_orth    0.0000    0.0000    0.0000
new_operator

rota_matrix    0.1384   -0.9511   -0.2763
rota_matrix   -0.4255   -0.3090    0.8506
rota_matrix   -0.8943   -0.0002   -0.4474
tran_orth     0.0000    0.0000    0.0000

center_orth    0.0000    0.0000    0.0000
new_operator

rota_matrix   -0.3618   -0.5878    0.7236
rota_matrix   -0.2630    0.8090    0.5257
rota_matrix   -0.8944   -0.0001   -0.4472
tran_orth     0.0000    0.0000    0.0000

center_orth    0.0000    0.0000    0.0000
new_operator

rota_matrix   -0.1384   -0.4255    0.8943
rota_matrix    0.9511   -0.3090    0.0002
rota_matrix    0.2763    0.8506    0.4474
tran_orth     0.0000    0.0000    0.0000

center_orth    0.0000    0.0000    0.0000
new_operator

rota_matrix    0.8617   -0.4255    0.2765
rota_matrix    0.4255    0.3090   -0.8506
rota_matrix    0.2765    0.8506    0.4473
tran_orth     0.0000    0.0000    0.0000

center_orth    0.0000    0.0000    0.0000
new_operator

rota_matrix    0.6709    0.1623   -0.7236
rota_matrix   -0.6881    0.5000   -0.5259
rota_matrix    0.2764    0.8507    0.4471
tran_orth     0.0000    0.0000    0.0000

center_orth    0.0000    0.0000    0.0000
new_operator

rota_matrix   -0.4471    0.5256   -0.7238
rota_matrix   -0.8508    0.0000    0.5256
rota_matrix    0.2762    0.8508    0.4471
tran_orth     0.0000    0.0000    0.0000

center_orth    0.0000    0.0000    0.0000
new_operator

rota_matrix   -0.9473    0.1623    0.2761
rota_matrix    0.1623   -0.5000    0.8507
rota_matrix    0.2761    0.8507    0.4473
tran_orth     0.0000    0.0000    0.0000

center_orth    0.0000    0.0000    0.0000
new_operator

rota_matrix    0.0531    0.6881   -0.7237
rota_matrix   -0.6881   -0.5000   -0.5259
rota_matrix   -0.7237    0.5259    0.4469
tran_orth     0.0000    0.0000    0.0000

center_orth    0.0000    0.0000    0.0000
new_operator

rota_matrix   -0.6379   -0.2630   -0.7238
rota_matrix   -0.2630   -0.8090    0.5257
rota_matrix   -0.7238    0.5257    0.4469
tran_orth     0.0000    0.0000    0.0000

center_orth    0.0000    0.0000    0.0000
new_operator

rota_matrix   -0.4471   -0.8508    0.2762
rota_matrix    0.5256    0.0000    0.8508
rota_matrix   -0.7238    0.5256    0.4471
tran_orth     0.0000    0.0000    0.0000

center_orth    0.0000    0.0000    0.0000
new_operator

rota_matrix    0.3618   -0.2630    0.8944
rota_matrix    0.5878    0.8090    0.0001
rota_matrix   -0.7236    0.5257    0.4472
tran_orth     0.0000    0.0000    0.0000

center_orth    0.0000    0.0000    0.0000
new_operator

rota_matrix    0.6709    0.6881    0.2764
rota_matrix   -0.1623    0.5000   -0.8507
rota_matrix   -0.7236    0.5259    0.4471
tran_orth     0.0000    0.0000    0.0000

center_orth    0.0000    0.0000    0.0000
new_operator

rota_matrix   -0.3618    0.2630   -0.8944
rota_matrix    0.5878    0.8090    0.0001
rota_matrix    0.7236   -0.5257   -0.4472
tran_orth     0.0000    0.0000    0.0000

center_orth    0.0000    0.0000    0.0000
new_operator

rota_matrix    0.4471    0.8508   -0.2762
rota_matrix    0.5256    0.0000    0.8508
rota_matrix    0.7238   -0.5256   -0.4471
tran_orth     0.0000    0.0000    0.0000

center_orth    0.0000    0.0000    0.0000
new_operator

rota_matrix    0.6379    0.2630    0.7238
rota_matrix   -0.2630   -0.8090    0.5257
rota_matrix    0.7238   -0.5257   -0.4469
tran_orth     0.0000    0.0000    0.0000

center_orth    0.0000    0.0000    0.0000
new_operator

rota_matrix   -0.0531   -0.6881    0.7237
rota_matrix   -0.6881   -0.5000   -0.5259
rota_matrix    0.7237   -0.5259   -0.4469
tran_orth     0.0000    0.0000    0.0000

center_orth    0.0000    0.0000    0.0000
new_operator

rota_matrix   -0.6709   -0.6881   -0.2764
rota_matrix   -0.1623    0.5000   -0.8507
rota_matrix    0.7236   -0.5259   -0.4471
tran_orth     0.0000    0.0000    0.0000

center_orth    0.0000    0.0000    0.0000
new_operator

rota_matrix    0.4471   -0.5256    0.7238
rota_matrix   -0.8508    0.0000    0.5256
rota_matrix   -0.2762   -0.8508   -0.4471
tran_orth     0.0000    0.0000    0.0000

center_orth    0.0000    0.0000    0.0000
new_operator

rota_matrix   -0.6709   -0.1623    0.7236
rota_matrix   -0.6881    0.5000   -0.5259
rota_matrix   -0.2764   -0.8507   -0.4471
tran_orth     0.0000    0.0000    0.0000

center_orth    0.0000    0.0000    0.0000
new_operator

rota_matrix   -0.8617    0.4255   -0.2765
rota_matrix    0.4255    0.3090   -0.8506
rota_matrix   -0.2765   -0.8506   -0.4473
tran_orth     0.0000    0.0000    0.0000

center_orth    0.0000    0.0000    0.0000
new_operator

rota_matrix    0.1384    0.4255   -0.8943
rota_matrix    0.9511   -0.3090    0.0002
rota_matrix   -0.2763   -0.8506   -0.4474
tran_orth     0.0000    0.0000    0.0000

center_orth    0.0000    0.0000    0.0000
new_operator

rota_matrix    0.9473   -0.1623   -0.2761
rota_matrix    0.1623   -0.5000    0.8507
rota_matrix   -0.2761   -0.8507   -0.4473
tran_orth     0.0000    0.0000    0.0000

center_orth    0.0000    0.0000    0.0000


"""


class ncs_group:  # one group of NCS operators and center and where it applies
  def __init__(self, ncs_rota_matr=None, center_orth=None, trans_orth=None,
      chain_residue_id=None,source_of_ncs_info=None,rmsd_list=None,
      ncs_domain_pdb=None,
      residues_in_common_list=None,cc=None,note=None,
       exclude_h=None,exclude_d=None):
    self._chain_residue_id=chain_residue_id  # just one of these
    self._rmsd_list=rmsd_list
    self._residues_in_common_list=residues_in_common_list
    self._centers=center_orth
    self._translations_orth=trans_orth
    self._rota_matrices=ncs_rota_matr
    if self._centers is not None:
      self._n_ncs_oper=len(self._centers)
    elif self._rmsd_list is not None:
      self._n_ncs_oper=len(self._rmsd_list)
    else:
      self._n_ncs_oper=0
    self._source_of_ncs_info=source_of_ncs_info
    self._ncs_domain_pdb=ncs_domain_pdb
    self._cc=cc
    self._note=note
    self._exclude_h=exclude_h
    self._exclude_d=exclude_d
    self._have_helical_symmetry=False
    self._have_point_group_symmetry=False

  def __repr__(self):
    return "NCS group with %s ops" %(self._n_ncs_oper)

  def apply_cob_to_vector(self,vector=None,
         change_of_basis_operator=None,
         coordinate_offset=None,
         unit_cell=None,new_unit_cell=None):
    if coordinate_offset is not None:
      from scitbx.math import  matrix
      new_vector=matrix.col(vector)+matrix.col(coordinate_offset)
    elif change_of_basis_operator:
      frac=unit_cell.fractionalize(vector)
      new_frac = change_of_basis_operator.c() * frac
      new_vector=new_unit_cell.orthogonalize(new_frac)
    return new_vector


  def copy_rot_trans(self,list_of_matrices,list_of_translations,
      change_of_basis_operator=None,
      coordinate_offset=None,
      scale_factor=None,
      unit_cell=None,new_unit_cell=None):
    # if change_of_basis_operator is None, then return copy of what we have
    from scitbx.math import  matrix
    new_list_of_matrices=[]
    new_list_of_translations=[]
    if change_of_basis_operator is not None:
      a=  matrix.sqr(new_unit_cell.orthogonalization_matrix()) \
        * change_of_basis_operator.c().as_rational().r \
        * matrix.sqr(unit_cell.fractionalization_matrix())
      a_inv=a.inverse()
    else:
      a=None
    for ncs_r,ncs_t in zip(list_of_matrices,list_of_translations):
      if scale_factor is not None:
        # expand by scale_factor about (0,0,0). Affects all translations
        new_list_of_matrices.append(deepcopy(ncs_r))
        new_list_of_translations.append(scale_factor*matrix.col(ncs_t))
      elif change_of_basis_operator is None and coordinate_offset is None:
        new_list_of_matrices.append(deepcopy(ncs_r))
        new_list_of_translations.append(deepcopy(ncs_t))
      elif coordinate_offset is not None:
        # TT 2015-11-02 special case of below where cob is just a translation
        # R' =  R
        # T' =  T + t - R t
        new_list_of_matrices.append(deepcopy(ncs_r))  # these are the same
        from scitbx import matrix
        delta = ncs_r * matrix.col(coordinate_offset)
        t_prime=matrix.col(ncs_t) + \
          matrix.col(coordinate_offset) - matrix.col(delta)
        new_list_of_translations.append(t_prime)

      else:
        # tt 2011-10-02
        # Formula for conversion of NCS rotation matrix and translation
        # relating two points in coordinate system to a second coordinate system
        # The change-of-basis operator is new_x = a x + t
        # The NCS operator is y = R x + T (in original coordinate system)
        # Then if NCS operator in new coordinate system is y' = R' x' + T':
        # R' = a R a_inv
        # T' = a T + t - a R a_inv t = transformed T minus R' * t
        #
        # Derivation:
        # x' and y' (values in new coordinate system) can be written:
        #   x'=a x + t
        #   y'=a y + t
        # Or rewriting:
        #   x= a_inv (x' - t)
        #   y= a_inv (y' - t)
        # Then as y = R x + T  (in original coordinate system), we can say:
        #   a_inv (y' - t) = R (a_inv (x' - t) ) + T
        # Or...
        #   y' = [a R a_inv] x' - [a R a_inv ] t + t + a t
        # So that:
        #   R' = a R a_inv
        #   T' = a T + t - a R a_inv t = transformed T minus R' * t

        # matrices are a ncs_r a_inv
        ncs_r_prime=a * ncs_r * a_inv
        new_list_of_matrices.append(ncs_r_prime)

        # translation vectors are partly a * ncs_t + t (the cob operator)
        frac=unit_cell.fractionalize(ncs_t)
        new_frac = change_of_basis_operator.c() * frac
        new_ncs_t=new_unit_cell.orthogonalize(new_frac)
        # translation vectors depend on the change of basis and the rotation
        # as well as the change-of-basis operator
        t_as_col=change_of_basis_operator.c().t().as_rational().as_float()
        # the basis translation in orig coordinate system
        cob_trans=unit_cell.orthogonalize(t_as_col)
        # correction for the basis translation in new coordinate system
        delta = ncs_r_prime * cob_trans
        t_prime=matrix.col(new_ncs_t) - matrix.col(delta)
        new_list_of_translations.append(t_prime)

    return new_list_of_matrices,new_list_of_translations

  def copy_vector_list(self,list_of_vectors,
      change_of_basis_operator=None,
      coordinate_offset=None,
      scale_factor=None,
         unit_cell=None,new_unit_cell=None):
    from scitbx.math import  matrix
    new_vector_list=[]
    for vector in list_of_vectors:
      if scale_factor is not None:
        new_vector=scale_factor*matrix.col(vector)
      elif change_of_basis_operator is None and coordinate_offset is None:
        new_vector=deepcopy(vector)
      else:
        new_vector=self.apply_cob_to_vector(vector=vector,
          change_of_basis_operator=change_of_basis_operator,
          coordinate_offset=coordinate_offset,
           unit_cell=unit_cell,new_unit_cell=new_unit_cell)
      new_vector_list.append(new_vector)
    return new_vector_list

  def deep_copy(self,change_of_basis_operator=None,unit_cell=None,
      coordinate_offset=None,
      new_unit_cell=None,
      scale_factor=None,
      extract_point_group_symmetry=None,
      ops_to_keep=None,
      hierarchy_to_match_order=None):  # make full copy;
    # optionally apply change-of-basis operator (requires old, new unit cells)
    # optionally apply coordinate_offset (adding coordinate_offset to coords)
    # optionally sort operators to match order in hierarchy
    # optionally apply scale factor (magnification)
    # optionally keep only ops_to_keep operators
    # optionaly extract point group symmetry

    # Can do only one of the above five things at most
    assert [change_of_basis_operator,scale_factor,
      coordinate_offset,ops_to_keep,hierarchy_to_match_order,
      extract_point_group_symmetry].count(None)>=4

    if hierarchy_to_match_order and self._chain_residue_id is not None:
      return self.deep_copy_order(
         hierarchy_to_match_order=hierarchy_to_match_order)

    if ops_to_keep is not None:
      return self.deep_copy_ops_to_keep(ops_to_keep=ops_to_keep)

    if extract_point_group_symmetry:
      return self.extract_point_group_symmetry()

    from mmtbx.ncs.ncs import ncs
    new=ncs_group()
    new._chain_residue_id=self._chain_residue_id
    new._rmsd_list=deepcopy(self._rmsd_list)
    new._residues_in_common_list=deepcopy(self._residues_in_common_list)

    # centers simply get affected by the change of basis operator if present
    #   or scale_factor
    new._centers=self.copy_vector_list(self._centers,
      change_of_basis_operator=change_of_basis_operator,
      coordinate_offset=coordinate_offset,
      scale_factor=scale_factor,
         unit_cell=unit_cell,new_unit_cell=new_unit_cell)

    # matrices and translations may need to be adjusted if change of basis set
    #  Scale_factor applied to translations
    new._rota_matrices,new._translations_orth=self.copy_rot_trans(
       self._rota_matrices,self._translations_orth,
         scale_factor=scale_factor,
         coordinate_offset=coordinate_offset,
         unit_cell=unit_cell,new_unit_cell=new_unit_cell)

    new._n_ncs_oper=deepcopy(self._n_ncs_oper)
    new._source_of_ncs_info=self._source_of_ncs_info
    new._ncs_domain_pdb=deepcopy(self._ncs_domain_pdb)
    new._cc=deepcopy(self._cc)
    new._note=deepcopy(self._note)
    new._exclude_h=self._exclude_h
    new._exclude_d=self._exclude_d
    return new

  def deep_copy_ops_to_keep(self,ops_to_keep=None):
    # keep only ops_to_keep operators
    assert ops_to_keep is not None

    new=self.deep_copy() # exact copy.  Now remove all except ops_to_keep

    new._n_ncs_oper=0
    new._rota_matrices=[]
    new._rota_matrices_inv=[]
    new._translations_orth=[]
    new._translations_orth_inv=[]
    new._residues_in_common_list=[]
    new._centers=[]

    new._rmsd_list=[]
    new._residues_in_common_list=[]

    if self._chain_residue_id:
      [group,residue_range_list]=self._chain_residue_id
    else:
      group=self._n_ncs_oper*[None]
      residue_range_list=self._n_ncs_oper*[None]
    new_residue_range_list=[]
    new_group=[]

    for i in range(self._n_ncs_oper):
      if i in ops_to_keep:
        new._n_ncs_oper+=1
        new._rota_matrices.append(self.rota_matrices()[i])
        new._rota_matrices_inv.append(self.rota_matrices_inv()[i])
        new._translations_orth.append(self.translations_orth()[i])
        new._translations_orth_inv.append(self.translations_orth_inv()[i])
        new._rmsd_list.append(self._rmsd_list[i])
        new._residues_in_common_list.append(self._residues_in_common_list[i])
        new._centers.append(self._centers[i])
        new_residue_range_list.append(residue_range_list[i])
        new_group.append(group[i])

    if self._chain_residue_id:
      new._chain_residue_id=[new_group,new_residue_range_list]
    else:
      new._chain_residue_id=None
    return new

  def get_order_dict(self,hierarchy_to_match_order=None):
    self.chain_id_from_index={}
    self.index_from_chain_id={}
    i=0
    for m in hierarchy_to_match_order.models()[:1]:
      for chain in m.chains():
        id=remove_single_quotes(chain.id)
        self.chain_id_from_index[i]=id
        self.index_from_chain_id[id]=i
        i+=1

  def get_new_group(self,hierarchy_to_match_order=None):
    # change the order of the operators to match hierarchy
    self.get_order_dict(hierarchy_to_match_order=hierarchy_to_match_order)

    # figure out what is the new order of groups
    sort_list=[]
    [group,residue_range_list] = self._chain_residue_id
    for x in group:
      id=self.index_from_chain_id.get(x)
      assert id is not None
      sort_list.append([id,x])
    sort_list.sort(key=itemgetter(0))
    new_group=[]
    for [id,x] in sort_list:
      new_group.append(x)

    # Identify which operator is the new first one
    first_chain_id=new_group[0]
    i=0
    first_op=None
    for chain_id in group:
      if chain_id==first_chain_id:
        first_op=i
      i+=1
    assert first_op is not None
    return new_group,first_op

  def deep_copy_order(self,hierarchy_to_match_order=None):  # make full copy;
    assert self._chain_residue_id is not None

    # Get the new order of chain IDs
    new_group,first_op=self.get_new_group(
      hierarchy_to_match_order=hierarchy_to_match_order)

    from mmtbx.ncs.ncs import ncs
    new=ncs_group()
    new._chain_residue_id=self._chain_residue_id
    new._rmsd_list=deepcopy(self._rmsd_list)
    new._residues_in_common_list=deepcopy(self._residues_in_common_list)

    # now adjust all the operators so that the reference is first_op
    # operator j maps copy j on to copy 0.
    # we want operator j to map copy j onto copy first_op. First map to
    #  copy 0 then map copy 0 to copy first_op
    #  Rx + T =  Rinv_fo (Rj x + Tj) + Tinv_fo
    #  ==> R= Rinv_fo Rj   T = Rinv_fo Tj + Tinv_fo
    # check: if fo=0 then Rinv_fo=U Tinv_fo=0 -> R=Rj and T=Tj ok.

    # centers are the same
    new._centers=deepcopy(self._centers)
    new._rota_matrices=[]
    new._translations_orth=[]
    r_first_op_inv=self._rota_matrices[first_op].inverse()
    t_first_op_inv=-1.*r_first_op_inv*self._translations_orth[first_op]

    for r,t in zip(self._rota_matrices,self._translations_orth):
      new_r=r_first_op_inv*r
      new_t=r_first_op_inv*t + t_first_op_inv

      new._rota_matrices.append(new_r)
      new._translations_orth.append(new_t)
    new._n_ncs_oper=deepcopy(self._n_ncs_oper)
    new._source_of_ncs_info=self._source_of_ncs_info
    new._ncs_domain_pdb=deepcopy(self._ncs_domain_pdb)
    new._cc=deepcopy(self._cc)
    new._note=deepcopy(self._note)
    new._exclude_h=self._exclude_h
    new._exclude_d=self._exclude_d

    # Now just change the order of everything
    translations_orth=[]
    rota_matrices=[]
    centers=[]
    rmsd_list=[]
    residues_in_common_list=[]
    group=[]
    residue_range_list=[]
    # NOTE: [group,residue_range_list] = new._chain_residue_id

    for chain_id in new_group:
      for t,r,c,rmsd,res_in_common,g,res_range in zip(
          new._translations_orth,
          new._rota_matrices,
          new._centers,
          new._rmsd_list,
          new._residues_in_common_list,
          new._chain_residue_id[0],
          new._chain_residue_id[1]):
        if g==chain_id: # this is the one
          translations_orth.append(t)
          rota_matrices.append(r)
          centers.append(c)
          rmsd_list.append(rmsd)
          residues_in_common_list.append(res_in_common)
          group.append(g)
          residue_range_list.append(res_range)

    new._translations_orth=translations_orth
    new._rota_matrices=rota_matrices
    new._centers=centers
    new._rmsd_list=rmsd_list  # NOTE will not be correct perhaps leave out
    new._residues_in_common_list=residues_in_common_list
    new._chain_residue_id=[group,residue_range_list]

    assert group==new_group
    chain_residue_id=[group,residue_range_list]
    return new


  def display_summary(self,verbose=None):
    text=""
    text+="\nSummary of NCS group with "+str(self.n_ncs_oper())+" operators:"
    i=0
    if verbose:
      if self._chain_residue_id:
        text+="\nID of chain/residue where these apply: "+\
           str(self._chain_residue_id)
      if self._rmsd_list and self._chain_residue_id:
        text+="\nRMSD (A) from chain "+str(self._chain_residue_id[0][0])+':'+\
         self.print_list(self._rmsd_list)
      if self._residues_in_common_list and self._chain_residue_id:
        text+="\nNumber of residues matching chain "+\
            str(self._chain_residue_id[0][0])+':'+\
             str(self._residues_in_common_list)
      if self._source_of_ncs_info:
        text+="\nSource of NCS info: "+str(self._source_of_ncs_info)
      if self._ncs_domain_pdb:
        text+="\nNCS domains represented by: "+str(self._ncs_domain_pdb)
      if self._cc:
        text+="\nCorrelation of NCS: "+str(self._cc)
      if self._note:
        text+="\nNOTE: "+str(self._note)
      for center,trans_orth,ncs_rota_matr in zip (
         self._centers, self._translations_orth,self._rota_matrices):
        if center is None: continue
        i+=1
        text+="\n\nOPERATOR "+str(i)
        text+="\nCENTER: "+" %8.4f  %8.4f  %8.4f" %tuple(center)
        r = ncs_rota_matr.elems
        text+="\n\nROTA 1: "+" %8.4f  %8.4f  %8.4f" %tuple(r[0:3])
        text+="\nROTA 2: "+" %8.4f  %8.4f  %8.4f" %tuple(r[3:6])
        text+="\nROTA 3: "+" %8.4f  %8.4f  %8.4f" %tuple(r[6:9])
        text+="\nTRANS:  "+" %8.4f  %8.4f  %8.4f" %tuple(trans_orth)
      text+="\n"
    return text

  def format_group_specification(self):
    if not self._chain_residue_id or len(self._chain_residue_id)<2:
      return ""

    # Need to test for existence because we might have operators or
    # chain specifications but not both

    if self._chain_residue_id is not None:
      [group,residue_range_list] = self._chain_residue_id
    else:
      group=self.n_ncs_oper()*[None]
      residue_range_list=self.n_ncs_oper()*[None]

    if self._centers is not None:
      [centers, translations_orth,rota_matrices]=\
         [self._centers, self._translations_orth,self._rota_matrices]
    else:
      centers=self.n_ncs_oper()*[None]
      translations_orth=self.n_ncs_oper()*[None]
      rota_matrices=self.n_ncs_oper()*[None]

    if self._rmsd_list is not None:
       rmsd_list=self._rmsd_list
    else:
      rmsd_list=self.n_ncs_oper()*[None]

    if self._residues_in_common_list is not None:
       residues_in_common_list=self._residues_in_common_list
    else:
      residues_in_common_list=self.n_ncs_oper()*[None]

    text="\nnew_ncs_group\n"
    if self._cc is not None: text+="NCS_CC "+str(self._cc)+"\n"
    if self._note is not None: text+="NOTE "+str(self._note)+"\n"
    if self._ncs_domain_pdb is not None:
      text+="  NCS_DOMAIN_PDB "+str(self._ncs_domain_pdb)+"\n"

    count=0
    for id,residue_ranges, center,trans_orth,ncs_rota_matr, \
        rmsd,common in zip (
        group,residue_range_list,
        centers, translations_orth,rota_matrices,
        rmsd_list,residues_in_common_list):
     count+=1
     text+='new_operator\n'
     if center is not None:
       for j in range(3):
         text+="\nrota_matrix "+" %8.4f  %8.4f  %8.4f" %tuple(
          ncs_rota_matr.elems[j*3:j*3+3])
       text+="\ntran_orth  "+" %8.4f  %8.4f  %8.4f" %tuple(trans_orth)
       text+="\n"
       text+="\ncenter_orth "+" %8.4f  %8.4f  %8.4f" %tuple(center)
       text+="\n"

     if id is not None: text+="CHAIN "+str(id)+ "\n"
     if rmsd is not None: text+="RMSD "+str(rmsd)+ "\n"
     if common is not None: text+="MATCHING "+str(common)+ "\n"

     if residue_ranges is not None and residue_ranges:
       for residue_range in residue_ranges:
         text+="  RESSEQ "
         text+=str(residue_range[0])+":"+str(residue_range[1])+"\n"
       text+="\n"
    return text

  def format_for_phenix_refine(self, prefix="pdb_interpretation.ncs_group"):
    if not self._chain_residue_id or len(self._chain_residue_id)<2:
      return ""
    exclude=""
    if self._exclude_h: exclude+=" and (not element H) "
    if self._exclude_d: exclude+=" and (not element D) "
    [group,residue_range_list] = self._chain_residue_id
    count=0
    text = []
    for id,residue_ranges in zip (group,residue_range_list):
      count+=1
      if count==1:
        text.append("%s {"%prefix)
        l = "  reference = chain '{}'".format(id)
      else:
        l = "  selection = chain '{}'".format(id)
      if residue_ranges:
        first=True
        for residue_range in residue_ranges:
          if first:
            first=False
            l += " and (resseq "
          else:
            l += " or resseq  "
          l += str(residue_range[0])+":"+str(residue_range[1])
        l += " ) " + exclude
      text.append(l)
    text.append("}")
    text = '\n'.join(text)
    return text

  def format_for_biomt(self,crystal_number=None,skip_identity_if_first=False,
       ncs_domain_pdb=True):

    serial_number=0
    from iotbx.mtrix_biomt import container

    result=container()
    for t,r in zip (
       self.translations_orth_inv(),self.rota_matrices_inv()):
      serial_number+=1
      result.add(r,t,serial_number, coordinates_present=False)

    return result.format_BIOMT_pdb_string()

  def format_for_resolve(self,crystal_number=None,skip_identity_if_first=False,
       ncs_domain_pdb=True):
    text="new_ncs_group"
    if ncs_domain_pdb and self._ncs_domain_pdb is not None:
        text+="\nncs_domain_pdb "+str(self._ncs_domain_pdb)+"\n"
    i=0
    for center,trans_orth,ncs_rota_matr in zip (
       self._centers, self._translations_orth,self._rota_matrices):
      i+=1
      if i==1 and skip_identity_if_first and \
        is_identity(ncs_rota_matr,trans_orth): continue
      for j in range(3):
       text+="\nrota_matrix "+" %8.4f  %8.4f  %8.4f" %tuple(
          ncs_rota_matr[j*3:j*3+3])
      text+="\ntran_orth  "+" %8.4f  %8.4f  %8.4f" %tuple(trans_orth)
      text+="\n"
      text+="\ncenter_orth "+" %8.4f  %8.4f  %8.4f" %tuple(center)
      if crystal_number is not None:
        text+="\ncrystal_number "+str(crystal_number)
      text+="\n"
    return text

  def n_ncs_oper(self):
    return self._n_ncs_oper

  def chain_residue_id(self):
    return self._chain_residue_id

  def rmsd_list(self):
    return self._rmsd_list

  def cc(self):
    return self._cc

  def note(self):
    return self._note

  def add_rmsd_list(self,rmsd_list):
    self._rmsd_list=rmsd_list

  def add_cc(self,cc):
    self._cc=cc

  def add_note(self,note):
    self._note=note

  def residues_in_common_list(self):
    return self._residues_in_common_list

  def add_residues_in_common_list(self,residues_in_common_list):
    self._residues_in_common_list=residues_in_common_list

  def add_chain_residue_id(self,chain_residue_id):
    self._chain_residue_id=chain_residue_id


  def centers(self):
    return self._centers

  def translations_orth(self):
    return self._translations_orth

  def rota_matrices(self):
    return self._rota_matrices

  def translations_orth_inv(self):
    if not hasattr(self,"_translations_orth_inv"):
      self.get_inverses()
    return self._translations_orth_inv

  def rota_matrices_inv(self):
    if not hasattr(self,"_rota_matrices_inv"):
      self.get_inverses()
    return self._rota_matrices_inv

  def delete_inv(self):
    if hasattr(self,"_rota_matrices_inv"):
      del self._rota_matrices_inv
    if hasattr(self,"_translations_orth_inv"):
      del self._translations_orth_inv

  def adjust_magnification(self,magnification=None):
    if not magnification or magnification==1:
      return # nothing to do

    self._translations_orth=self.copy_vector_list(self._translations_orth,
      scale_factor=magnification)
    self._centers=self.copy_vector_list(self._centers,
      scale_factor=magnification)

    self.get_inverses()

  def invert_matrices(self):
    self.get_inverses()
    # move the inverses to std
    self._translations_orth=deepcopy(self._translations_orth_inv)
    self._rota_matrices=deepcopy(self._rota_matrices_inv)
    self.get_inverses()

  def rotate_matrices(self,rot=None):
    translations_orth_rot=deepcopy(self._translations_orth)
    rota_matrices_rot=deepcopy(self._rota_matrices)

    self._translations_orth=[]
    self._rota_matrices=[]

    # create r_rot, t_rot such that r_rot x + t_rot is the same as
    #       rot * ( r [rot_inv x ] + t) : rotate x to orig, apply, r t, rotate back
    # r_rot(x)+t_rot ==  rot * ( r [rot_inv x ] + t)
    #  So:  t_rot=rot t
    #       r_rot=rot r rot_inv

    rot_inv=rot.inverse()
    for r,t in zip(rota_matrices_rot,translations_orth_rot):
      r_rot=rot *(r*rot_inv)
      t_rot=rot*t
      self._rota_matrices.append(r_rot)
      self._translations_orth.append(t_rot)
    self.get_inverses()

  def get_inverses(self):
    self._translations_orth_inv=[]
    self._rota_matrices_inv=[]
    for r,t in zip(self.rota_matrices(),self.translations_orth()):
      r_inv=r.inverse()
      t_inv=-1.*r_inv*t
      self._rota_matrices_inv.append(r_inv)
      self._translations_orth_inv.append(t_inv)

  def rotations_translations_forward_euler(self):
    # note usual rt is from molecule j to molecule 1. Here it is opposite.
    from scitbx.math import euler_angles
    rotations_forward_euler=[]
    translations_forward_euler=[]
    for r,t in zip(self._rota_matrices,self._translations_orth):
      r_inv=r.inverse()
      t_inv=-1.*r_inv*t
      r_inv_euler=euler_angles.zyz_angles(r_inv)
      rotations_forward_euler.append(r_inv_euler)
      translations_forward_euler.append(t_inv)
    return rotations_forward_euler,translations_forward_euler

  def source_of_ncs_info(self):
    return self._source_of_ncs_info

  def ncs_domain_pdb(self):
    return self._ncs_domain_pdb

  def print_list(self,list_of_real):
    text=""
    for number in list_of_real:
     text+="  "+str(self.round(number,2))
    return text

  def round(self,value,n_digit):  # round off value to n_digit digits
    if type(value) == type(1):
       return self.round(float(value),n_digit)
    if type(value) != type(1.0):
       return self.round(0.0,1)

    if n_digit == 0:
      rounder=1
    else:
      rounder=10**n_digit
    if value >= 0:
      rounded=float(int(0.5+value*rounder))/rounder
    else:
      value1=-1.*value
      rounded=float(int(0.5+value1*rounder))/rounder
      rounded=-1.*rounded
    return rounded

  def extract_point_group_symmetry(self,
   tol_r=None,
   abs_tol_t=None,
   rel_tol_t=None):
    # sequentially remove operators until pg symmetry is achieved or none
    # are left
   ops_to_keep=[self.identity_op_id()]
   n_ops=len(self.rota_matrices_inv())
   for test_op in range(n_ops):
     if test_op in ops_to_keep: continue
     test_ops_to_keep=ops_to_keep+[test_op]
     new_group=self.deep_copy(
         ops_to_keep=test_ops_to_keep)
     if new_group.is_point_group_symmetry(
         tol_r=default_tol_r,
         abs_tol_t=default_abs_tol_t,
         rel_tol_t=default_rel_tol_t,
         symmetry_to_match=self):  # test_op keeps us in the original set
       ops_to_keep.append(test_op)
   new_group=self.deep_copy(
         ops_to_keep=ops_to_keep)
   if new_group.is_point_group_symmetry(
         tol_r=default_tol_r,
         abs_tol_t=default_abs_tol_t,
         rel_tol_t=default_rel_tol_t):
     return new_group
   else:
     return None

  def is_similar_ncs_group(self, other,
   tol_r=default_tol_r,
   abs_tol_t=default_abs_tol_t,
   rel_tol_t=default_rel_tol_t,
   allow_self_contained_in_other = True):
    '''
     return True if all operations of self match one of other
    '''

    if (not allow_self_contained_in_other) and \
       len(self.rota_matrices_inv()) != len(other.rota_matrices_inv()):
      return False

    if len(self.rota_matrices_inv()) < 1:
      return False

    for r,t in zip(self.rota_matrices_inv(),self.translations_orth_inv()):
        is_similar=False
        for r2,t2 in zip(other.rota_matrices_inv(),
           other.translations_orth_inv()):
          if is_same_transform(r,t,r2,t2,tol_r=tol_r,
            abs_tol_t=abs_tol_t,rel_tol_t=rel_tol_t):
            is_similar=True
            break
        if not is_similar:
          return False
    return True

  def is_point_group_symmetry(self,
   tol_r=default_tol_r,
   abs_tol_t=default_abs_tol_t,
   rel_tol_t=default_rel_tol_t,
   symmetry_to_match=None):
    # return True if any 2 sequential operations is a member of the
    #  set.  Test by sequentially applying all pairs of
    # operators and verifying that the result is a member of the set

    # Allow checking self operators vs some other symmetry object if desired:

    if len(self.rota_matrices_inv()) < 2:
      return False

    if symmetry_to_match is None:
      symmetry_to_match=self

    for r,t in zip(self.rota_matrices_inv(),self.translations_orth_inv()):
      for r1,t1 in zip(self.rota_matrices_inv(),self.translations_orth_inv()):
        new_r = r1 * r
        new_t = (r1 * t) + t1
        is_similar=False
        for r2,t2 in zip(symmetry_to_match.rota_matrices_inv(),
           symmetry_to_match.translations_orth_inv()):
          if is_same_transform(new_r,new_t,r2,t2,tol_r=tol_r,
            abs_tol_t=abs_tol_t,rel_tol_t=rel_tol_t):
            is_similar=True
            break
        if not is_similar:
          return False
    self._have_point_group_symmetry=True
    self.tol_r=tol_r
    self.abs_tol_t=abs_tol_t
    self.rel_tol_t=rel_tol_t
    return True

  def sort_by_z_translation(self,tol_z=0.01,
       allow_negative_z_translation = False):
    n=len(self.rota_matrices_inv())
    z_translations=[]
    sort_z_translations=[]
    for i1 in range(n): # figure out if translation is along z
      z_translations.append(self.translations_orth_inv()[i1][2])
      sort_z_translations.append([self.translations_orth_inv()[i1][2],i1])
    rota_matrices_sav=deepcopy(self._rota_matrices)
    translations_orth_sav=deepcopy(self._translations_orth)

    # sort the z-translations to reorder the matrices. Could be backwards
    sort_z_translations = sorted(sort_z_translations, key = lambda s: s[0])
    #sort_z_translations.sort()
    sorted_indices=[]
    sorted_z=[]
    n_plus_one=0
    n_minus_one=0
    delta=None
    all_same_delta=True
    for z,i1 in sort_z_translations:
      if sorted_indices:
        if i1==sorted_indices[-1]+1: n_plus_one+=1
        if i1==sorted_indices[-1]-1: n_minus_one+=1
        delta_z=z-sorted_z[-1]
        if delta is None:
          delta=delta_z
        elif abs(delta-delta_z)>tol_z:
          is_helical=False # XX not used
      sorted_indices.append(i1)
      sorted_z.append(z)
    if allow_negative_z_translation and n_minus_one>n_plus_one:
      sorted_indices.reverse()
      self._helix_z_translation= -1 * delta
    else:
      self._helix_z_translation=delta

    # Reorder the operators:
    self._rota_matrices=len(rota_matrices_sav)*[None]
    self._translations_orth=len(rota_matrices_sav)*[None]
    for i1,i2 in zip(sorted_indices,range(n)):
      self._rota_matrices[i2]=rota_matrices_sav[i1]
      self._translations_orth[i2]=translations_orth_sav[i1]
    self.delete_inv() # remove the inv matrices/rotations so they regenerate
    if len(self._rota_matrices)<2:
      self._helix_theta=None
    else:
      self._helix_theta=self.get_theta_along_z(
        self._rota_matrices[0],self._rota_matrices[1])
    self.get_inverses()
    return sorted_indices

  def get_trans_along_z(self,t0,t1):
    return t1[2]-t0[2]

  def get_theta_along_z(self,m0,m1):
    import math
    cost=m0[0]
    sint=m0[1]
    t0=180.*math.atan2(sint,cost)/3.14159
    cost=m1[0]
    sint=m1[1]
    t1=180.*math.atan2(sint,cost)/3.14159
    delta_rot = t1 - t0
    if delta_rot > 180:
      delta_rot = delta_rot - 360
    if delta_rot <= -180:
      delta_rot = delta_rot + 360
    return delta_rot

  def is_helical_along_z(self,tol_z=0.01,
   tol_r=default_tol_r,
   abs_tol_t=default_abs_tol_t,
   rel_tol_t=default_rel_tol_t):
    # This assumes the operators are in order, but allow special case
    #   where the identity operator is placed at the beginning but belongs
    #   at the end
    # Also assumes the axis of helical symmetry is parallel to the Z-axis.
    #   and returns False if not

    # For helical symmetry sequential application of operators moves up or
    #  down the list by an index depending on the indices of the operators.
    if len(self.rota_matrices_inv()) < 2:
      return False
    if self.is_point_group_symmetry(tol_r=tol_r,
            abs_tol_t=abs_tol_t,rel_tol_t=rel_tol_t):
      return False

    n=len(self.rota_matrices_inv())
    if n < 3:
      return False

    is_helical=True
    rota_matrices_sav=deepcopy(self._rota_matrices)
    translations_orth_sav=deepcopy(self._translations_orth)
    sorted_indices=self.sort_by_z_translation(tol_z=tol_z)

    offset_list=[]
    n_missing_list=[]
    self.helix_oper_forwards=None
    self.helix_oper_reverse=None
    self.helix_oper_identity=None
    for i1 in range(n): # figure out offset made by this self.helix_operator
      offset,n_missing=self.oper_adds_offset(i1,tol_r=tol_r,
          abs_tol_t=abs_tol_t,rel_tol_t=rel_tol_t)
      offset_list.append(offset)
      n_missing_list.append(n_missing)
      if offset==1:self.helix_oper_forwards=sorted_indices[i1]
      if offset==-1:self.helix_oper_reverse=sorted_indices[i1]
      if offset==0:self.helix_oper_identity=sorted_indices[i1]
    # offset_list should be one instance of each value and will be 0 at the
    #  operator that is unity
    if None in offset_list:
      is_helical=False

    if is_helical:
      ii=offset_list.index(0)
      if not is_identity(
          self.rota_matrices_inv()[ii],self.translations_orth_inv()[ii]):
        is_helical=False

    if is_helical:
      for i1 in range(n):
        if n_missing_list[i1] != abs(i1-ii):
          is_helical=False
          break
    if is_helical:
      offset_list.sort()
      start_value=offset_list[0]
      expected_list=list(range(start_value,start_value+n))
      if offset_list != expected_list:
        is_helical=False
    # restore
    sys.stdout.flush()
    self._rota_matrices=rota_matrices_sav
    self._translations_orth=translations_orth_sav
    self.delete_inv() # remove the inv matrices/rotations so they regenerate
    if is_helical:
      self._have_helical_symmetry=True
      self.tol_z=tol_z
      self.tol_r=tol_r
      self.abs_tol_t=abs_tol_t
      self.rel_tol_t=rel_tol_t
      return True
    else:
      return False

  def get_forwards_reverse_helix(self,r1=None,t1=None,r2=None,t2=None):
    # get the forwards and reverse transforms, deciding which is which based
    # on the order of operators supplied for r1 t1 and r2 t2
    assert self._have_helical_symmetry
    for dir in ['forwards','reverse']:
      if dir=='forwards':
        r_forwards,t_forwards=self.helix_rt_forwards()
        r_reverse,t_reverse=self.helix_rt_reverse()
      else:
        r_forwards,t_forwards=self.helix_rt_reverse()
        r_reverse,t_reverse=self.helix_rt_forwards()

      # apply to n-1 and see if we get n:
      new_r = r_forwards*r1
      new_t= (r_forwards* t1) + t_forwards
      if is_same_transform(new_r,new_t,r2,t2,
         tol_r=self.tol_r,
         abs_tol_t=self.abs_tol_t,
         rel_tol_t=self.rel_tol_t):
        return r_forwards,t_forwards,r_reverse,t_reverse
    from libtbx.utils import Sorry
    raise Sorry(
     "Unable to find forward and reverse operators for this helical symmetry")

  def get_helix_parameters(self,tol_z=default_tol_z):
    from libtbx import group_args
    helix_z_translation=self.get_helix_z_translation()
    helix_theta=self.get_helix_theta()
    if helix_z_translation is not None and helix_theta is not None:
      return group_args(helix_z_translation=helix_z_translation,
        helix_theta=helix_theta)

  def extend_helix_operators(self,z_range=None,tol_z=default_tol_z,
      max_operators=None):
    assert self._have_helical_symmetry
    # extend the operators to go from -z_range to z_range
    rota_matrices_inv_sav=deepcopy(self.rota_matrices_inv())
    translations_orth_inv_sav=deepcopy(self.translations_orth_inv())
    # only apply centers if some existing ones are not zero
    have_non_zero_c=False
    from scitbx import matrix
    for c in self._centers:
      if list(c)!=[0,0,0]:
        have_non_zero_c=True
        break

    sort_list=[]
    for r,t,c in zip(rota_matrices_inv_sav,translations_orth_inv_sav,self._centers):
      z_value=t[2]
      sort_list.append([z_value,r,t,c])
    sort_list.sort(key=itemgetter(0))
    z_first,r_first,t_first,c_first=sort_list[0]
    z_last,r_last,t_last,c_last=sort_list[-1]
    z_next_to_last,r_next_to_last,t_next_to_last,c_next_to_last=sort_list[-2]
    z_translation=self.get_helix_z_translation()
    if not z_translation:
      from libtbx.utils import Sorry
      raise Sorry("Cannot apply extension of helical NCS operators with no"+
        " Z-translation")

    # Figure out which direction to add single shifts to each end
    r_forwards,t_forwards,r_reverse,t_reverse=self.get_forwards_reverse_helix(
      r1=r_next_to_last,t1=t_next_to_last,r2=r_last,t2=t_last)

    if max_operators:
      max_new_each_direction=max(0,
          (1+max_operators-len(rota_matrices_inv_sav))//2)
    else:
      max_new_each_direction=None

    # Add on at end until we get to z_max (or z_min if z_translation<0)
    r_list=[r_last]
    t_list=[t_last]
    c_list=[c_last]
    while 1:
      new_r = r_forwards*r_list[-1]
      new_t= (r_forwards * t_list[-1]) + t_forwards
      new_c= (r_forwards*c_list[-1])+t_forwards
      if max_new_each_direction and len(c_list)>=max_new_each_direction:
        break
      elif is_in_range(new_t[2],-z_range,z_range):
        r_list.append(new_r)
        t_list.append(new_t)
        c_list.append(new_c)
      else:
        break
    rota_matrices_inv=rota_matrices_inv_sav+r_list[1:]
    translations_orth_inv=translations_orth_inv_sav+t_list[1:]
    centers=self._centers+c_list[1:]

    # and for other end
    r_list=[r_first]
    t_list=[t_first]
    c_list=[c_first]
    while 1:
      new_r = r_reverse*r_list[-1]
      new_t= (r_reverse * t_list[-1]) + t_reverse
      new_c= (r_reverse*c_list[-1])+t_reverse
      if max_new_each_direction and len(c_list)>=max_new_each_direction:
        break
      elif is_in_range(new_t[2],-z_range,z_range):
        r_list.append(new_r)
        t_list.append(new_t)
        c_list.append(new_c)
      else:
        break
    rota_matrices_inv+=r_list[1:]
    translations_orth_inv+=t_list[1:]
    centers+=c_list[1:]
    # Now we have a new set...invert and save them
    self._n_ncs_oper=len(rota_matrices_inv)
    self._rota_matrices=[]
    self._translations_orth=[]
    self._centers=[]
    for r_inv,t_inv,c in zip(rota_matrices_inv,translations_orth_inv,centers):
      r_std=r_inv.inverse()
      t_std=-1.*r_std*t_inv
      self._rota_matrices.append(r_std)
      self._translations_orth.append(t_std)
      if have_non_zero_c:
        self._centers.append(c)
      else:
        self._centers.append(matrix.col((0,0,0)))

    if self._rmsd_list:
      self._rmsd_list=len(rota_matrices_inv)*[None]
    if self._residues_in_common_list:
       self._residues_in_common_list=len(rota_matrices_inv)*[None]

    if self._chain_residue_id:
       self._chain_residue_id= [
        len(rota_matrices_inv)*[None],
        len(rota_matrices_inv)*[[]]
         ]

    self.delete_inv()
    self.get_inverses()

    # And reorder them now...
    self.sort_by_z_translation(tol_z=tol_z)

  def get_helix_z_translation(self):
    assert self._have_helical_symmetry
    if hasattr(self,'_helix_z_translation'):
      return self._helix_z_translation
    return None

  def get_helix_theta(self):
    assert self._have_helical_symmetry
    if hasattr(self,'_helix_theta'):
      return self._helix_theta
    return None

  def helix_rt_reverse(self):
    assert self._have_helical_symmetry
    # Return r and t for moving one reverse in a helix
    if not hasattr(self,'helix_oper_reverse') or not self.helix_oper_reverse:
      if not hasattr(self,'helix_oper_forwards') or \
         not self.helix_oper_forwards: # no info, quit
        return None,None
      else: # generate from forwards:
        r_forwards,t_forwards=self.helix_rt_forwards()
        r_reverse=r_forwards.inverse()
        t_reverse=-1.*r_reverse*t_forwards
        return r_reverse,t_reverse

    i1=self.helix_oper_reverse
    r1=self.rota_matrices_inv()[i1]
    t1=self.translations_orth_inv()[i1]
    return r1,t1

  def helix_rt_forwards(self):
    assert self._have_helical_symmetry
    # Return r and t for moving one forwards in a helix
    if not hasattr(self,'helix_oper_forwards') or not self.helix_oper_forwards:
      if not hasattr(self,'helix_oper_reverse') or \
         not self.helix_oper_reverse: # no info, quit
        return None,None
      else: # generate from reverse:
        r_reverse,t_reverse=self.helix_rt_reverse()
        r_forwards=r_reverse.inverse()
        t_forwards=-1.*r_forwards*t_reverse
        return r_forwards,t_forwards

    i1=self.helix_oper_forwards
    r1=self.rota_matrices_inv()[i1]
    t1=self.translations_orth_inv()[i1]
    return r1,t1

  def oper_adds_offset(self,i1,tol_r=None,abs_tol_t=None,rel_tol_t=None):
    # figure out what operator is created from operator i1 + any other one
    n=len(self.rota_matrices_inv())
    r1=self.rota_matrices_inv()[i1]
    t1=self.translations_orth_inv()[i1]
    offset_list=[]
    missing_list=[]
    for i in range(n): # apply i1+i and see what k we get (k-i should be const)
      r=self.rota_matrices_inv()[i]
      t=self.translations_orth_inv()[i]
      new_r = r1 * r
      new_t = (r1 * t) + t1
      match_offset=None
      for j in range(n):
        r2=self.rota_matrices_inv()[j]
        t2=self.translations_orth_inv()[j]
        if is_same_transform(new_r,new_t,r2,t2,
           tol_r=tol_r,
           abs_tol_t=abs_tol_t,
           rel_tol_t=rel_tol_t):
          match_offset=j-i
      if match_offset is not None:
        if not match_offset in offset_list: offset_list.append(match_offset)
      else:
        missing_list.append(i)
    if len(offset_list)==1:
      return offset_list[0],len(missing_list)
    else:
      return None,None



  def identity_op_id(self):
    # return id of identity operator
    id=0
    for center,trans_orth,ncs_rota_matr in zip (
       self._centers, self._translations_orth,self._rota_matrices):
      if is_identity(ncs_rota_matr,trans_orth):
         return id
      id+=1
    return None

  def map_inside_unit_cell(self,unit_cell=None):
    # map all the operators inside the unit cell.  Must be supplied
    assert unit_cell is not None
    if len(self._centers)==0: return

    new_centers=[]
    new_translations_orth=[]
    from scitbx.math import  matrix
    #rotation matrices do not change, just translations
    # find the identity:
    first_coordinate_offset=None
    for center,trans_orth,ncs_rota_matr in zip (
       self._centers, self._translations_orth,self._rota_matrices):
      if is_identity(ncs_rota_matr,trans_orth):
        first_coordinate_offset=matrix.col(offset_inside_cell(
          center,unit_cell=unit_cell))
        break
    if first_coordinate_offset is None:
      raise Sorry("Identity not found in NCS matrices?")
    for center,trans_orth,ncs_rota_matr in zip (
       self._centers, self._translations_orth,self._rota_matrices):
      coordinate_offset=offset_inside_cell(center,unit_cell=unit_cell)

      new_centers.append(matrix.col(center)+matrix.col(coordinate_offset))
      #  T'=T - R x_i + x_1
      delta = matrix.col(ncs_rota_matr * matrix.col(coordinate_offset))
      t_prime=matrix.col(trans_orth) - delta + first_coordinate_offset
      new_translations_orth.append(t_prime)

    self._centers=new_centers
    self._translations_orth=new_translations_orth

  def add_identity_op(self):
    if self.identity_op_id() is not None:
       return # nothing to do

    from scitbx import matrix

    self._rota_matrices.append(matrix.sqr(
      [1.,0.,0.]+[0.,1.,0.]+[0.,0.,1.]))
    self._translations_orth.append(matrix.col([0.,0.,0.]))
    self._centers.append(matrix.col([0.,0.,0.]))
    self._n_ncs_oper+=1

class ncs:
  def __init__(self,exclude_h=None,exclude_d=None):
    self._ncs_groups=[]  # each group is an ncs_group object
    self.source_info=None
    self._ncs_read=False
    self._exclude_h=exclude_h
    self._exclude_d=exclude_d
    self._ncs_obj = None
    self._ncs_name = None # an optional name like "D3"
    self._shift_cart = (0,0,0)  # shift to place object in original location

  def __repr__(self):
    text = "NCS object with %s groups: " %(len(self._ncs_groups))
    for g in self._ncs_groups:
      text+=str(g)
    return text

  def deep_copy(self,change_of_basis_operator=None,unit_cell=None,
      coordinate_offset=None,
      scale_factor=None,
      new_unit_cell=None,
      ops_to_keep=None,
      extract_point_group_symmetry=None,
      hierarchy_to_match_order=None):  # make a copy
    from mmtbx.ncs.ncs import ncs

    # make new ncs object with same overall params as this one:
    new=ncs(exclude_h=self._exclude_h,exclude_d=self._exclude_d)
    new.source_info=self.source_info
    new._ncs_name=self._ncs_name
    new._ncs_read=self._ncs_read
    new._shift_cart=deepcopy(self._shift_cart)  # shift_cart is what was applied
    if coordinate_offset:
       new._shift_cart=tuple(
         [a+b for a,b in zip(new._shift_cart,coordinate_offset)])
    # deep_copy over all the ncs groups:
    for ncs_group in self._ncs_groups:
      new_group=ncs_group.deep_copy(
         change_of_basis_operator=change_of_basis_operator,
         coordinate_offset=coordinate_offset,
         scale_factor=scale_factor,
         unit_cell=unit_cell,new_unit_cell=new_unit_cell,
         ops_to_keep=ops_to_keep,
         extract_point_group_symmetry=extract_point_group_symmetry,
         hierarchy_to_match_order=hierarchy_to_match_order)

      new._ncs_groups.append(new_group)
    return new

  def change_of_basis(self,change_of_basis_operator=None,unit_cell=None,
      new_unit_cell=None):
    if change_of_basis_operator is None or unit_cell is None or\
        new_unit_cell is None:
       raise Sorry("For change of basis unit_cell, "+
           "new_unit_cell and operator are all required")
    return self.deep_copy(change_of_basis_operator=change_of_basis_operator,
      unit_cell=unit_cell,new_unit_cell=new_unit_cell)

  def magnification(self,scale_factor=None):
    if scale_factor is None:
       raise Sorry("For magnification a scale factor is required.")
    return self.deep_copy(scale_factor=scale_factor)

  def set_shift_cart(self,shift_cart):
    self._shift_cart=shift_cart

  def shift_cart(self):
    return self._shift_cart

  def coordinate_offset(self,coordinate_offset=None,unit_cell=None,
      new_unit_cell=None):
    # NOTE: Returns new object, self is unchanged.
    if coordinate_offset is None:
       raise Sorry("For coordinate_offset an offset is required.")
    return self.deep_copy(coordinate_offset=coordinate_offset)

  def map_inside_unit_cell(self,unit_cell=None):
    # map all the operators inside the unit cell.  Must be supplied and the
    # centers for the operators must exist and not be zero
    for ncs_group in self._ncs_groups:
      ncs_group.map_inside_unit_cell(unit_cell=unit_cell)

  def ncs_read(self):
    return self._ncs_read

  def ncs_groups(self):
    return self._ncs_groups

  def identity_op_id_in_first_group(self): # identity operartor in first (usually main) NCS group
    if self._ncs_groups:
      return self._ncs_groups[0].identity_op_id()
    else:
      return None

  def ncs_oper_in_first_group(self): # copies in first (usually main) NCS group
    if self._ncs_groups:
      return self._ncs_groups[0].n_ncs_oper()
    else:
      return None

  def rotate_about_z(self,rot_deg=None,invert_matrices=True):
    # Rotate all the ops by rot_deg about z
    if invert_matrices:
      rot_deg=-rot_deg
    oper=get_rot_z(rot_deg=rot_deg)
    self.rotate_matrices(rot=oper)

  def rotate_about_y(self,rot_deg=None,invert_matrices=True):
    # Rotate all the ops by rot_deg about y
    if invert_matrices:
      rot_deg=-rot_deg
    oper=get_rot_y(rot_deg=rot_deg)
    self.rotate_matrices(rot=oper)

  def ncs_from_pdb_input_BIOMT(self,pdb_inp=None,log=None,quiet=False,
     invert_matrices=True):
    p=pdb_inp.process_BIOMT_records()
    if not p:
      print("No BIOMT records available", file=log)
      return

    self.ncs_from_import(rot_list=p.r,trans_list=p.t,invert_matrices=invert_matrices)

  def ncs_from_import(self,rot_list=None,trans_list=None,invert_matrices=True):

    self.init_ncs_group()

    for r,t in zip(rot_list,trans_list):
      self._rota_matrix=r.as_list_of_lists()
      self._trans=list(t)
      self._center=[0.,0.,0.]
      self.save_oper()

    self.save_existing_group_info()
    # Invert them (we use mapping from operator i to 1 ; biomt is 1 to i
    if invert_matrices:
      self.invert_matrices()

    self._ncs_read=True


  def select_first_ncs_group(self):
    # just keep the first ncs group and remove others:
    self._ncs_groups=self._ncs_groups[:1]
    return self

  def select_first_ncs_operator(self):
    # just keep the first ncs operator in the first group and remove others:
    self.select_first_ncs_group()
    if self._ncs_groups:
      self._ncs_groups=[self._ncs_groups[0].deep_copy(ops_to_keep=[0])] #  keep first only
    return self

  def set_unit_ncs(self):  # just make a single ncs operator

    self.init_ncs_group()

    self._rota_matrix=[[1.,0.,0.],[0.,1.,0.],[0.,0.,1.]]
    self._trans=[0.,0.,0.]
    self._center=[0.,0.,0.]
    self.save_oper()

    self.save_existing_group_info()
    self._ncs_read=True

  def read_ncs(self,file_name=None,lines=[],source_info="",log=None,quiet=False):
    if not log: log=sys.stdout
    if not quiet:
      if file_name:
        print("Reading NCS information from: ",file_name, file=log)
    if source_info:
       print(" based on ",source_info, file=log)
       self.source_info=source_info
    else:
       self.source_info=str(file_name)
    if file_name:
      if not os.path.isfile(file_name):
        raise Sorry("The file "+str(file_name)+" does not seem to exist?")
      else:
        with open(file_name) as f:
          lines=f.readlines()
    self.init_ncs_group()

    read_something=False

    for line in lines:
      if not line : continue
      spl=line.split()
      if len(spl)<1: continue
      key=spl[0].lower()
      if key=='transformations' and len(spl)>1 and \
         spl[1].lower()=='formatted':  # start all over!
         self._ncs_groups=[]
         self.init_ncs_group()
      elif key=='new_ncs_group': # start new group
        self.save_existing_group_info()
      # NOTE: new operator signified by rota_matrix or new_operator
      elif key=='new_operator':
        self.save_oper()
      elif key=='rota_matrix': # read set of rota
        if self._rota_matrix and \
            len(self._rota_matrix)==3 or len(self._rota_matrix)==0:
          self.save_oper()
        set=self.get_3_values_after_key(line)
        self._rota_matrix.append(set)

      elif key=='tran_orth': # read translation
        self._trans=self.get_3_values_after_key(line)
      elif key=='center_orth': # read translation
        self._center=self.get_3_values_after_key(line)
      elif key=='ncs_cc': # read  cc
        self._cc=self.get_1_value_after_key(line)
      elif key=='note' or key=='note:': # read anything
        self._note=" ".join(line.split()[1:])
      elif key=='chain':
        self._chain=self.get_1_char_after_key(line)
      elif key=='resseq':
        self._resseq_list.append(self.get_res_range_after_key(line))
      elif key=='rmsd':
        self._rmsd=self.get_1_value_after_key(line)
      elif key=='matching':
        self._residues_in_common=self.get_1_value_after_key(line)
      elif key=='source_info':
        self.source_info=self.get_1_char_after_key(line)
      elif key=='ncs_domain_pdb':
        self._ncs_domain_pdb=self.get_1_char_after_key(line)
      elif len(spl)==3 and spl[0]=='No' and spl[1]=='NCS' and spl[2]=='found':
        read_something=True
      else:
        pass
    self.save_existing_group_info()
    if read_something or len(self._ncs_groups) > 0:
      self._ncs_read=True
    else: # Try as biomtr
      import iotbx.pdb
      try:
        pdb_inp = iotbx.pdb.input(lines=lines,source_info=file_name)
        self.ncs_from_pdb_input_BIOMT(pdb_inp=pdb_inp,log=log,quiet=quiet)
      except Exception as e:
        pass

  def save_existing_group_info(self):

        self.save_oper()
        if self._n_ncs_oper > 0:  # save last-read ncs group.
          self.save_ncs_group()


  def get_res_range_after_key(self,line):
    spl = line.replace(':', ' ').split()
    if  len(spl)<3:
      raise Sorry("Cannot interpret this NCS file"+"\n"+str(line))
    start,end=None,None
    try:
      start=int(spl[1])
      end=int(spl[2])
    except Exception:
      raise Sorry("Cannot interpret this NCS file"+"\n"+str(line))
    return [start,end]

  def get_1_char_after_key(self,line):
    spl=line.split()
    if  len(spl)<2:
      raise Sorry("Cannot interpret this NCS file"+"\n"+str(line))
    char=None
    try:
      char=spl[1]
    except Exception:
      raise Sorry("Cannot interpret this NCS file"+"\n"+str(line))
    return char

  def get_1_value_after_key(self,line):
    spl=line.split()
    if  len(spl)<2:
      raise Sorry("Cannot interpret this NCS file"+"\n"+str(line))
    cc=None
    try:
      cc=float(spl[1])
    except Exception:
      raise Sorry("Cannot interpret this NCS file"+"\n"+str(line))
    return cc

  def get_3_values_after_key(self,line):
    spl=line.split()
    if  len(spl)<4:
      raise Sorry("Cannot interpret this NCS file"+"\n"+str(line))
    set=[]
    try:
      for item in spl[1:4]:
        set.append(float(item))
    except Exception:
      raise Sorry("Cannot interpret this NCS file"+"\n"+str(line))
    return set

  def init_ncs_group(self):
     self._n_ncs_oper=0
     self._ncs_trans_orth=[]
     self._ncs_rota_matr=[]
     self._ncs_center_orth=[]
     self.init_oper()
     self._rmsd_list=[]
     self._residues_in_common_list=[]
     self._cc=None
     self._note=None
     self._ncs_domain_pdb=None
     self._chain_residue_id=[]

     self._list_of_resseq_list=[]
     self._group=[]

  def init_oper(self):
     self._rota_matrix=[]
     self._trans=None
     self._center=None
     self._rmsd=None
     self._residues_in_common=None
     self._resseq_list=[]
     self._chain=None

  def save_oper(self):
     # decide if there is anything to save:

     have_oper=True
     for item in (self._trans,self._rota_matrix,self._center):
       if not item:
          have_oper=False
     if self._rota_matrix and len(self._rota_matrix)!=3:
          raise Sorry("Cannot interpret this NCS file (rotations not understood)")
     if self._trans and len(self._trans)!=3:
          raise Sorry("Cannot interpret this NCS file (translations not understood)")
     have_something=False
     if have_oper or self._rmsd or self._residues_in_common:
       have_something=True
     if not have_something: return
     self._n_ncs_oper+=1
     if have_oper:
       from scitbx import matrix
       self._ncs_trans_orth.append(matrix.col(self._trans))
       self._ncs_rota_matr.append(matrix.sqr(
         self._rota_matrix[0]+self._rota_matrix[1]+self._rota_matrix[2] ))
       self._ncs_center_orth.append(matrix.col(self._center))
     else:
       self._ncs_trans_orth.append(None)
       self._ncs_rota_matr.append(None)
       self._ncs_center_orth.append(None)
     self._rmsd_list.append(self._rmsd)
     self._residues_in_common_list.append(self._residues_in_common)
     self._list_of_resseq_list.append(self._resseq_list)
     self._group.append(self._chain)

     self.init_oper()

  def import_ncs_group(self,ncs_rota_matr=None,
       center_orth=None,
       trans_orth=None,
       chain_residue_id=None,
       residues_in_common_list=None,
       rmsd_list=None,
       ncs_domain_pdb=None,
       cc=None,
       source_of_ncs_info=None,
       ncs_group_object=None):

     if not ncs_group_object:
       list_length=None
       if center_orth is None and trans_orth:
         center_orth=len(trans_orth)*[(0,0,0)]
       for lst in [trans_orth,ncs_rota_matr,center_orth]:
         if not lst or len(lst)<1:
           print("Length too short:",type(lst),lst, end=' ')
           if lst is not None:
             print(len(lst))
           else:
             print("0")
           raise Sorry("The NCS operators in this file appear incomplete?")
         if not list_length: list_length=len(lst)
         if list_length!=len(lst):
           print("Length of list incorrect:",type(lst),lst,len(lst),list_length)
           raise Sorry("The NCS operators in this file appear incomplete?")
       ncs_group_object=ncs_group(
         ncs_rota_matr=ncs_rota_matr,
         center_orth=center_orth,
         trans_orth=trans_orth,
         chain_residue_id=remove_quotes_from_chain_id(chain_residue_id),
         residues_in_common_list=residues_in_common_list,
         rmsd_list=rmsd_list,
         source_of_ncs_info=source_of_ncs_info,
         ncs_domain_pdb=ncs_domain_pdb,
         cc=cc,
         exclude_h=self._exclude_h,exclude_d=self._exclude_d)
     self._ncs_groups.append(ncs_group_object)

  def save_ncs_group(self):
     # check that there is something  here:
     have_something=False
     for lst in [self._ncs_trans_orth,
         self._ncs_rota_matr,self._ncs_center_orth,
         self._residues_in_common_list,self._rmsd_list]:
        if lst and self._n_ncs_oper and \
           len(lst) != self._n_ncs_oper:
          print("Lengh of list does not match number of operators:",\
             type(lst),lst,self._n_ncs_oper)
          raise Sorry("The NCS operators in this file appear incomplete?")
        if lst is not None and len(lst)<1:
          print("Length of operators too short:",lst,len(lst))
          raise Sorry("The NCS operators in this file appear incomplete?")
        if lst is not None: have_something=True
     if not have_something: return
     self._chain_residue_id=[self._group,self._list_of_resseq_list]
     ncs_group_object=ncs_group(
       ncs_rota_matr=self._ncs_rota_matr,
       center_orth=self._ncs_center_orth,
       trans_orth=self._ncs_trans_orth,
       source_of_ncs_info=self.source_info,
       ncs_domain_pdb=self._ncs_domain_pdb, # 041309
       rmsd_list=self._rmsd_list,
       residues_in_common_list=self._residues_in_common_list,
       chain_residue_id=self._chain_residue_id,
       cc=self._cc,note=self._note)
     self._ncs_groups.append(ncs_group_object)
     self.init_ncs_group()

  def show_summary(self, verbose=True, log = None):
    return self.display_all(verbose=verbose, log = log)

  def display_all(self,verbose=True,log=None):
    if log==None:
      log=sys.stdout
    count=0
    text=""
    if self._ncs_name:
      text+="NCS TYPE: %s " %(self._ncs_name)

    for ncs_group in self._ncs_groups:
      count+=1
      text+="\n\nGROUP "+str(count)
      text+=ncs_group.display_summary(verbose=verbose)
    text+="\n\n"
    log.write(text)
    return text

  def shift_cart(self):
    if self._shift_cart:
      return self._shift_cart
    else:
      return (0,0,0)

  def shift_back_cart(self):
    return tuple([-a for a in self.shift_cart()])

  def as_ncs_spec_string(self, format = 'ncs_spec'):
    '''
     shifts to original location and returns text string
    '''
    assert format in ['ncs_spec','phil']
    shifted_ncs=self.coordinate_offset(coordinate_offset=self.shift_back_cart())
    if format == 'ncs_spec':
      return shifted_ncs.format_all_for_group_specification(
         log=null_out(),quiet=True,out=null_out())
    elif format == 'phil':
      return shifted_ncs.format_all_for_phenix_refine(
         quiet=True,out=null_out())


  def format_all_for_group_specification(self,log=None,quiet=True,out=None,
       file_name=None):
    if file_name is not None:
       out=open(file_name,'w')
    if out==None:
       out=sys.stdout
    if log==None:
      log=sys.stdout
    elif hasattr(out,'name'):
      print("NCS written as ncs object information to:"\
        ,out.name, file=log)
    all_text=""
    text="Summary of NCS information\n"
    import time,os
    text+=time.ctime()+"\n"
    text+=os.getcwd()+"\n\n"
    if self.source_info is not None:
      text+="source_info "+str(self.source_info)+"\n"
    if not self._ncs_groups:
      text+="No NCS found\n"
    if out is not None or not quiet: out.write("\n"+text+"\n\n")
    for ncs_group in self._ncs_groups:
      text=ncs_group.format_group_specification()
      if out is not None or not quiet: out.write("\n"+text+"\n\n")
      all_text+="\n"+text
    all_text+="\n"
    if out is not None and file_name is not None:
      out.close()
    return all_text

  def format_all_for_biomt(self,log=None,quiet=False,out=None,):
    if out==None:
       out=sys.stdout
    if log==None:
      log=sys.stdout
    else:
      print("\n\nNCS operators written in BIOMT format :",out.name, file=log)
    all_text=""
    if self._ncs_groups and len(self._ncs_groups)>1:
      print(
      "\nWARNING: BIOMT format cannot be used for more than one NCS group",
       "\nOnly writing out one NCS group",file=log)
    for ncs_group in self._ncs_groups[:1]:
      text=ncs_group.format_for_biomt()
      if not quiet: out.write("\n"+text+"\n\n")
      all_text+="\n"+text
    return all_text

  def format_all_for_resolve(self,log=None,quiet=False,out=None,
      crystal_number=None,skip_identity_if_first=False,ncs_domain_pdb=True):
    if out==None:
       out=sys.stdout
    if log==None:
      log=sys.stdout
    else:
      print("\n\nNCS operators written in format for resolve to:",out.name, file=log)
    all_text=""
    for ncs_group in self._ncs_groups:
      text=ncs_group.format_for_resolve(crystal_number=crystal_number,
         skip_identity_if_first=skip_identity_if_first,
         ncs_domain_pdb=ncs_domain_pdb)
      if not quiet: out.write("\n"+text+"\n\n")
      all_text+="\n"+text
    return all_text

  def format_all_for_phenix_refine(self,quiet=False,out=None,
        prefix="refinement.pdb_interpretation.ncs_group"):
    '''
    This function is an older version of creating phil for phenix refine,
    it is modified to replicate a new phil parameters that can handle
    selection to the level of atoms, "format_phil_for_phenix_refine".

    When it will still can be used in the older form, which allows only
    residue level selection.
    '''
    if hasattr(self._ncs_obj,'show'):
      if prefix == 'refinement.pdb_interpretation.ncs_group':
        prefix="pdb_interpretation"
      if quiet:
        out = null_out()
      elif out is None:
        out=sys.stdout
      all_text = self._ncs_obj.show(format='phil',log=null_out(),header=False)
      # all_text = convert_phil_format(all_text,to_type=prefix)
      if all_text:
        if not quiet:
          print(all_text + '\n', file=out)
      return all_text
    else:
      # this is only being used when only a spec file is provided
      if out == None:
        out=sys.stdout
      all_text=""
      for ncs_group in self._ncs_groups:
        text= ncs_group.format_for_phenix_refine(prefix=prefix)
        if text:
          if not quiet: out.write(text+'\n')
          all_text+="\n"+text
      return all_text

  def format_phil_for_phenix_refine(self,log=None,quiet=False,out=None):
    """ Writes NCS phil selection in phenix_refine format """
    if out==None: out=sys.stdout
    phil_str = self._ncs_obj.show(format='phil',log=null_out(),header=False)
    # ncs_str = convert_phil_format(phil_str,to_type="ncs")
    ncs_str = phil_str
    if ncs_str:
      if not quiet: out.write(ncs_str + '\n')
    return ncs_str

  def format_phil_for_ncs(self,log=None,quiet=False,out=None):
    """ Writes NCS phil selection in NCS format """
    if out==None: out=sys.stdout
    if log==None:
      log=sys.stdout
    else:
      msg  = "NCS phil selection written in ncs selection format to:"
      print(msg,out.name, file=log)
    phil_str = self._ncs_obj.show(format='phil',log=null_out(),header=False)
    if phil_str:
      if not quiet: out.write(phil_str + '\n')
    return phil_str

  def set_ncs_name(self,ncs_name):
    self._ncs_name=ncs_name

  def get_ncs_name(self):
    return self._ncs_name

  def add_source_info(self,source_info):
    if self.source_info is None:
       self.source_info=str(source_info)
    else:
       self.source_info+=str(source_info)

  def add_cc_list(self,cc_list):
   if len(self._ncs_groups) != len(cc_list):
     raise Sorry("Number of NCS groups does not match length of cc_list...")
   for ncs_group,cc in zip(self._ncs_groups,cc_list):
    ncs_group.add_cc(cc)

  def overall_note(self):
    overall_note=""
    for ncs_group in self._ncs_groups:
      if ncs_group._note is not None:
        overall_note+=" "+ncs_group._note
    return overall_note

  def overall_cc(self):
    cc_all=0.
    n=0
    for ncs_group in self._ncs_groups:
      if ncs_group._cc is not None:
        cc_all+=ncs_group._cc
        n+=1
    if n>0:
      cc_all=cc_all/float(n)
    else:
      cc_all=None
    return cc_all

  def overall_rmsd(self):
    rmsd_all=0.
    n=0
    for ncs_group in self._ncs_groups:
      if ncs_group.rmsd_list() is not None:
        for rmsd in ncs_group.rmsd_list():
          if rmsd:
            rmsd_all+=rmsd
            n+=1
    if n>0:
      rmsd_all=rmsd_all/float(n)
    else:
      rmsd_all=None
    return rmsd_all

  def max_operators(self):
    n_max=0
    for ncs_group in self._ncs_groups:
      if ncs_group and ncs_group.n_ncs_oper()>n_max:
        n_max=ncs_group.n_ncs_oper()
    return n_max

  def is_similar_ncs_object(self, other,
   tol_r=default_tol_r,
   abs_tol_t=default_abs_tol_t,
   rel_tol_t=default_rel_tol_t,
   allow_self_contained_in_other = True):
    '''
      Determine if self and other are similar ncs objects
      ncs groups do not have to be in same order
    '''
    if not self._ncs_groups and not other._ncs_groups:
      return True  # nothing there for either one

    if self.shift_cart() != other.shift_cart():
      return False
    if not self._ncs_groups:
      return False
    if not other._ncs_groups:
      return False
    if len(self._ncs_groups) != len (other._ncs_groups):
      return False
    for ncs_group in self._ncs_groups:
      found=False
      for other_ncs_group in other._ncs_groups:
        if ncs_group.is_similar_ncs_group(other_ncs_group,tol_r=tol_r,
            abs_tol_t=abs_tol_t,rel_tol_t=rel_tol_t,
            allow_self_contained_in_other = allow_self_contained_in_other):
          found=True
          break
      if not found:
        return False
    return True

  def is_point_group_symmetry(self,
   tol_r=default_tol_r,
   abs_tol_t=default_abs_tol_t,
   rel_tol_t=default_rel_tol_t):
    if not self._ncs_groups:
      return False
    for ncs_group in self._ncs_groups[:1]:
      if not ncs_group.is_point_group_symmetry(tol_r=tol_r,
            abs_tol_t=abs_tol_t,rel_tol_t=rel_tol_t):
        return False
    return True

  def adjust_magnification(self,magnification=None):
    if not self._ncs_groups:
      return self
    for ncs_group in self._ncs_groups:
      ncs_group.adjust_magnification(magnification=magnification)
    return self

  def rotate_matrices(self,rot=None):
    if not self._ncs_groups:
      return
    for ncs_group in self._ncs_groups:
      ncs_group.rotate_matrices(rot=rot)

  def invert_matrices(self):
    if not self._ncs_groups:
      return
    for ncs_group in self._ncs_groups:
      ncs_group.invert_matrices()

  def sort_by_z_translation(self,tol_z=default_tol_z):
    if not self._ncs_groups:
      return
    for ncs_group in self._ncs_groups:
      ncs_group.sort_by_z_translation(tol_z=tol_z)

  def extend_helix_operators(self,z_range=None,tol_z=default_tol_z,
      max_operators=None):
    if not self._ncs_groups:
      return
    for ncs_group in self._ncs_groups:
      ncs_group.extend_helix_operators(z_range=z_range,tol_z=tol_z,
        max_operators=max_operators)

  def get_helix_parameters(self,z_range=None,tol_z=default_tol_z,
      max_operators=None):
    if not self._ncs_groups:
      return
    # return values for group 0
    return self._ncs_groups[0].get_helix_parameters(tol_z=tol_z,)

  def is_helical_along_z(self,
   tol_r=default_tol_r,
   abs_tol_t=default_abs_tol_t,
   rel_tol_t=default_rel_tol_t):
    if not self._ncs_groups:
      return False
    for ncs_group in self._ncs_groups:
      if not ncs_group.is_helical_along_z(tol_r=tol_r,
            abs_tol_t=abs_tol_t,rel_tol_t=rel_tol_t):
        return False
    return True

  def add_identity_op(self):
    for ncs_group in self._ncs_groups:
      if ncs_group.identity_op_id() is None:
        ncs_group.add_identity_op()


  def apply_ncs_to_sites(self, sites_cart=None,ncs_obj=None,
      exclude_identity=False,ncs_id=None):

    if type(sites_cart) == type((1,2,3)): # it was a single site
      from scitbx.array_family import flex
      sites_cart = flex.vec3_double((sites_cart,))

    if not ncs_obj:
      ncs_obj = self
    from scitbx.array_family import flex
    new_sites_cart=flex.vec3_double()
    if (not ncs_obj or ncs_obj.max_operators()<=1):
      if exclude_identity:
        return new_sites_cart  # nothing as we exclude identity
      else:
        return sites_cart

    ncs_group=ncs_obj.ncs_groups()[0]
    from scitbx.matrix import col

    if ncs_id is not None:
      t=ncs_group.translations_orth_inv()[ncs_id]
      r=ncs_group.rota_matrices_inv()[ncs_id]
      for site in sites_cart:
        new_sites_cart.append(r * col(site)  + t)
      return new_sites_cart

    if exclude_identity:
      identity_op=ncs_group.identity_op_id()
    else:
      identity_op=None
    ii=-1
    for t,r in zip(
       ncs_group.translations_orth_inv(),ncs_group.rota_matrices_inv()):
      ii+=1
      if exclude_identity and ii==identity_op: continue
      for site in sites_cart:
        new_sites_cart.append(r * col(site)  + t)
    return new_sites_cart


test_ncs_info="""

new_ncs_group
NCS_CC 0.92
new_operator

rota_matrix    1.0000    0.0000    0.0000
rota_matrix    0.0000    1.0000    0.0000
rota_matrix    0.0000    0.0000    1.0000
tran_orth     0.0000    0.0000    0.0000

center_orth   30.2920   -2.8923   16.6160
CHAIN A
RMSD 0.2
MATCHING 12.0
  RESSEQ 1:26

new_operator

rota_matrix   -0.9971    0.0424   -0.0635
rota_matrix   -0.0297   -0.9816   -0.1889
rota_matrix   -0.0703   -0.1864    0.9800
tran_orth    70.9461    5.2622    3.7549

center_orth   39.8735    3.8824   16.7239
CHAIN B
RMSD 0.1
MATCHING 15.0
  RESSEQ 101:126



new_ncs_group
NCS_CC 0.95
new_operator

rota_matrix    1.0000    0.0000    0.0000
rota_matrix    0.0000    1.0000    0.0000
rota_matrix    0.0000    0.0000    1.0000
tran_orth     0.0000    0.0000    0.0001

center_orth   31.2920   -2.8923   16.6160
CHAIN A
RMSD 0.6
MATCHING 13.0
  RESSEQ 1:25

new_operator

rota_matrix   -0.9970    0.0424   -0.0635
rota_matrix   -0.0297   -0.9816   -0.1889
rota_matrix   -0.0703   -0.1864    0.9800
tran_orth    70.9461    5.2622    3.7549

center_orth   38.8735    3.8824   16.7239
CHAIN B
RMSD 0.5
MATCHING 11.0
  RESSEQ 101:124


"""

test1_ncs_info="""
new_ncs_group
new_operator

rota_matrix    1.0000    0.0000    0.0000
rota_matrix    0.0000    1.0000    0.0000
rota_matrix    0.0000    0.0000    1.0000
tran_orth     0.0000    0.0000    0.0000

center_orth   0.0000    0.0000    0.0000
new_operator

rota_matrix    0.3090    0.9500   -0.0000
rota_matrix   -0.9500    0.3090    0.0000
rota_matrix    0.0000   -0.0000    1.0000
tran_orth   -23.0000  147.0000    0.0000

center_orth   0.0000    0.0000    0.0000
"""
def euler_frac_to_rot_trans(euler_values,frac,unit_cell):
    # TT get RT in cctbx form from euler angles and fractional translation as
    #   used in phaser. Note: Specific for phaser EULER FRAC

    ncs_rota_matr_inv=scitbx.rigid_body.euler(
      euler_values[2],euler_values[1],euler_values[0],"zyz").rot_mat()
    ncs_rota_matr=ncs_rota_matr_inv.inverse()

    orth=unit_cell.orthogonalize(frac)
    trans_orth=-1.*ncs_rota_matr*orth
    return ncs_rota_matr,trans_orth
#####################################################



if __name__=="__main__":
  log=sys.stdout
  args=sys.argv[1:]
  if 'exercise' in args:
    file_name='TEST.NCS'
    f=open(file_name,'w')
    f.write(test_ncs_info)
    f.close()
    ncs_object=ncs()
    ncs_object.read_ncs(file_name,source_info=file_name)
    ncs_object.display_all()
    file2='TEST2.NCS'
    text=ncs_object.format_all_for_group_specification(file_name=file2)

    if not text or text != test_ncs_info:
     print("NOT OK ...please compare TEST.NCS (std) vs TEST2.NCS (output)")
     ff=open('txt.dat','w')
     ff.write(text)
     ff.close()
    else:

     print ("Running exercise_1")
     ncs_object=ncs()
     ncs_object.read_ncs(lines=test1_ncs_info.splitlines())
     ncs_lines=ncs_object.format_all_for_group_specification().splitlines()
     biomt_lines=ncs_object.format_all_for_biomt().splitlines()

     biomt_ncs_object=ncs()
     biomt_ncs_object.read_ncs(lines=biomt_lines)

     biomt_text=biomt_ncs_object.display_all()

     std_ncs_object=ncs()
     std_ncs_object.read_ncs(lines=ncs_lines)
     std_ncs_text=std_ncs_object.display_all()
     print ("STANDARD \n %s \n BIOMTR \n %s " %(
       std_ncs_text, biomt_text))
     for a,b in zip(std_ncs_text.splitlines(),biomt_text.splitlines()):
       assert a.strip()==b.strip()

     assert std_ncs_object.is_similar_ncs_object(biomt_ncs_object)
     new_ncs_obj=ncs()
     # Shift ncs coordinates, make ncs with both, make sure can find
     #   similarity even if order is different
     new_ncs_obj._ncs_groups=deepcopy(std_ncs_object._ncs_groups)
     offset_ncs=std_ncs_object.deep_copy(coordinate_offset=(10,10,10))
     assert not offset_ncs.is_similar_ncs_object(biomt_ncs_object)
     new_ncs_obj._ncs_groups.append(deepcopy(offset_ncs._ncs_groups[0]))
     second_ncs_obj=ncs()
     second_ncs_obj._ncs_groups=deepcopy(offset_ncs._ncs_groups)
     second_ncs_obj._ncs_groups.append(deepcopy(std_ncs_object._ncs_groups[0]))
     assert not new_ncs_obj.is_similar_ncs_object(biomt_ncs_object)
     assert new_ncs_obj.is_similar_ncs_object(second_ncs_obj)
     print("OK")

  elif len(args)>0 and args[0] and os.path.isfile(args[0]):
    ncs_object=ncs()
    ncs_object.read_ncs(args[0],source_info=args[0])
    ncs_object.display_all()
    if 1:
      file2='OUTPUT.NCS'
      text=ncs_object.format_all_for_group_specification(file_name=file2)
      print("IS point-group: ", end=' ')
      print(ncs_object.is_point_group_symmetry())
      print("IS helical:", end=' ')
      print(ncs_object.is_helical_along_z())
    if 1:
      file3='OUTPUT2.NCS'
      new_ncs_object=ncs_object.deep_copy(ops_to_keep=[0,1,6])
      text=new_ncs_object.format_all_for_group_specification(file_name=file3)
      print(text)
      print("IS point-group: ", end=' ')
      print(new_ncs_object.is_point_group_symmetry())
      print("IS helical:", end=' ')
      print(new_ncs_object.is_helical_along_z())


 *******************************************************************************


 *******************************************************************************
mmtbx/ncs/ncs_params.py
from __future__ import absolute_import, division, print_function

import iotbx.phil
import mmtbx.geometry_restraints.torsion_restraints.torsion_ncs

global_ncs_params = iotbx.phil.parse("""\
  ncs
    .caption = Parameter controls for NCS refinement (restrained, constrained)
    .short_caption = Global NCS
    .style = scrolled menu_item auto_align box
  {
    type = *torsion cartesian constraints
      .type = choice(multi=False)
      .short_caption = NCS type
      .caption = torsion-angle global constraints
      .style = bold noauto
    constraints
      .caption = Parameter controls for strict NCS refinement
      .expert_level=2
    {
      refine_operators = True
        .type = bool
        .expert_level=2
      apply_to_coordinates = True
        .type = bool
        .expert_level=2
      apply_to_adp = True
        .type = bool
        .expert_level=2
    }
    coordinate_sigma=0.05
      .type = float
      .expert_level=1
    restrain_b_factors = False
      .type = bool
      .short_caption = Restrain NCS-related B-factors
      .help = If enabled, b-factors will be restrained for NCS-related atoms. \
        Otherwise, atomic b-factors will be refined independently, and \
        b_factor_weight will be set to 0.0
      .style = bold
    b_factor_weight=10
      .type=float
      .short_caption = Weight on NCS-related B-factor restraints
    excessive_distance_limit = 1.5
      .type = float
      .style = bold
    special_position_warnings_only = False
      .type = bool
      .expert_level=2
    torsion
      .style = noauto menu_item auto_align box
      .short_caption = Torsion-angle NCS
    {
      include scope mmtbx.geometry_restraints.torsion_restraints.torsion_ncs.torsion_ncs_params
    }
  }""",process_includes=True)


 *******************************************************************************


 *******************************************************************************
mmtbx/ncs/ncs_restraints_group_list.py
from __future__ import absolute_import, division, print_function
from six.moves import cStringIO as StringIO
from scitbx.math import superpose
from scitbx.array_family import flex
from scitbx import matrix
import mmtbx.ncs.ncs_utils as nu
import scitbx.rigid_body
from libtbx.utils import null_out, Sorry
from libtbx.test_utils import approx_equal
import iotbx.cif.model
from six.moves import zip


class NCS_copy():
  def __init__(self,copy_iselection, rot, tran, str_selection=None, rmsd=999):
    """
    used for NCS groups list copies

    Attributes:
      iselection (flex.size_t): NCS copy selection
      r (matrix obj): rotation matrix from master to this copy
      t (matrix obj): translation vector from master to this copy
    """
    self.iselection = copy_iselection
    self.str_selection = str_selection
    self.r = rot
    self.t = tran
    self.rmsd = rmsd

  def __eq__(self, other):
    return approx_equal(self.r, other.r, out=null_out()) and approx_equal(self.t, other.t, out=null_out())

  def deep_copy(self):
    res = NCS_copy(
        self.iselection.deep_copy(),
        matrix.sqr(self.r),
        matrix.col(self.t),
        self.str_selection,
        self.rmsd)
    return res

  def select(self, selection):
    self.iselection = iselection_select(self.iselection, selection)
    self.str_selection = None # it is not valid anymore
    self.rmsd = 999

def iselection_select(isel, sel):
  x = flex.bool(sel.size(), False)
  x.set_selected(isel, True)
  res = x.select(sel).iselection()
  return res

class NCS_restraint_group(object):

  def __init__(self,master_iselection, str_selection=None):
    """
    used for NCS groups list

    Attributes:
      master_iselection (flex.size_t): NCS group master copy selection
      copies (list): list of NCS_copy objects
    """
    self.master_iselection = master_iselection
    self.master_str_selection = str_selection
    self.copies = []

  def __eq__(self, other):
    result = True
    for sc, oc in zip(self.copies, other.copies):
      result &= sc == oc
    return result

  def setup_selection_set(self):
    self.set_master_iselection = set(self.master_iselection)
    self.list_master_iselection = list(self.master_iselection)

  def get_iselections_list(self):
    """
    Returns all iselections in the group in one list
    """
    return [self.master_iselection] + [c.iselection for c in self.copies]

  def update_i_seqs(self, old_i_seqs):
    """
    correct iseqs using supplied list
    """
    if old_i_seqs is None:
      return
    for n,i in enumerate(self.master_iselection):
      self.master_iselection[n] = old_i_seqs[i]
    for c in self.copies:
      for n, i in enumerate(c.iselection):
        c.iselection[n] = old_i_seqs[i]

  def split_by_chains(self, hierarchy):
    # actually splitting. Looking for chains only in master. If some corner
    # case arise when it is not enough, will have to do something.
    # For example, chains in master and copy do not match with each other by
    # number of atoms. E.g. atoms belong to these chains:
    # master: AAAAABBBB
    #   copy: CCCDDDDDD
    #
    # Note, that I don't recalculate rotation/translation matrices!
    #
    # Looks like there's no tests for this functionality
    #
    from mmtbx.ncs.ncs_search import get_bool_selection_to_keep

    if len(hierarchy.select(self.master_iselection).only_model().chains()) == 1:
      return [self.deep_copy()]
    result = []
    selected_h = hierarchy.select(self.master_iselection)
    assert self.master_iselection.size() == selected_h.atoms_size()
    # shortcut (same chain ids)
    c_ids = [c.id for c in selected_h.only_model().chains()]
    if len(set(c_ids)) == 1:
      # assuming the configuration of copies is the same
      return [self.deep_copy()]

    for chain in selected_h.only_model().chains():
      c_iseqs = chain.atoms().extract_i_seq()
      to_keep = get_bool_selection_to_keep(
          big_selection=self.master_iselection,
          small_selection=c_iseqs)
      new_group = NCS_restraint_group(
          master_iselection = self.master_iselection.select(to_keep),
          str_selection = None)
      for old_copy in self.copies:
        new_copy = NCS_copy(
            copy_iselection=old_copy.iselection.select(to_keep),
            rot=matrix.sqr(old_copy.r),
            tran=matrix.col(old_copy.t),
            str_selection=None)
        new_group.append_copy(new_copy)
      result.append(new_group)
    return result

  def append_copy(self, copy):
    self.copies.append(copy)

  def get_number_of_copies(self):
    return len(self.copies)

  def deep_copy(self):
    result = NCS_restraint_group(
        master_iselection=self.master_iselection.deep_copy(),
        str_selection=self.master_str_selection)
    for c in self.copies:
      result.copies.append(c.deep_copy())
    return result

  def select(self, selection):
    """
    Modifies the selections of master and copies according the "selection"
    - Keep the order of selected atoms
    - Keep only atoms that appear in master and ALL copies
    Also modify "selection" to include ncs related atoms only if selected in
    both master and ALL ncs copies (The modified selection is not returned in
    current version)

    Args:
      selection (flex.bool): atom selection
    """
    from mmtbx.ncs.ncs_utils import selected_positions, remove_items_from_selection
    assert isinstance(selection, flex.bool)


    iselection = selection.iselection(True)
    sel_set = set(iselection)
    m = set(self.master_iselection)
    m_list = [(pos,indx) for pos,indx in enumerate(list(self.master_iselection))]
    m_in_sel = m.intersection(sel_set)
    common_selection_pos = {pos for (pos,indx) in m_list if indx in m_in_sel}
    for ncs in self.copies:
      c = set(ncs.iselection)
      c_list = [(pos,indx) for pos,indx in enumerate(list(ncs.iselection))]
      copy_in_sel = c.intersection(sel_set)
      include_set = {pos for (pos,indx) in c_list if indx in copy_in_sel}
      common_selection_pos.intersection_update(include_set)
      if not bool(common_selection_pos): break
    # use the common_selection_pos to update all selections
    self.master_iselection, not_included = selected_positions(
      self.master_iselection,common_selection_pos)
    iselection = remove_items_from_selection(iselection,not_included)
    for ncs in self.copies:
      ncs.iselection, not_included = selected_positions(
        ncs.iselection,common_selection_pos)
      iselection = remove_items_from_selection(iselection,not_included)
    for c in self.copies:
      assert self.master_iselection.size() == c.iselection.size(), "%s\n%s" % (
          list(self.master_iselection), list(c.iselection))

    # This is to handle renumbering properly
    self.master_iselection = iselection_select(self.master_iselection, selection)
    self.master_str_selection = None
    for c in self.copies:
      c.select(selection)

  def whole_group_iselection(self):
    isel = self.master_iselection.deep_copy()
    for cp in self.copies:
      isel.extend(cp.iselection)
    # make sure sequential order of selection indices
    return flex.sorted(isel)

  def make_nth_copy_master(self, n):
    """
    n - index of the copy to become master, starting with 0
    master becomes nth copy
    """
    # switch master and copy selection
    assert n < self.get_number_of_copies()
    self.master_iselection, self.copies[n].iselection = \
      self.copies[n].iselection, self.master_iselection
    t_sel = self.copies[n].str_selection
    self.copies[n].str_selection = self.master_str_selection
    self.master_str_selection = t_sel
    # Adjust rotation and translation for the new master
    r = self.copies[n].r = (self.copies[n].r.transpose())
    t = self.copies[n].t = -(self.copies[n].r * self.copies[n].t)
    # change all other rotations and translations to the new master
    for i, c in enumerate(self.copies):
      if i == n: continue
      # change translation before rotation
      c.t = (c.r * t + c.t)
      c.r = (c.r * r)

class class_ncs_restraints_group_list(list):
  def __init__(self, *args):
    super(class_ncs_restraints_group_list, self).__init__(*args)
    for g in self:
      assert isinstance(g, NCS_restraint_group)

  def __eq__(self, other):
    result = self.get_n_groups() == other.get_n_groups()
    for sg, og in zip(self, other):
      result &= (sg == og)
    return result

  def setup_sets(self):
    for g in self:
      g.setup_selection_set()

  def get_copy_iseqs(self, iseqs):
    """get iseqs from copies for proxy. E.g. for bond:
    iseqs = [1,2]

    Args:
        iseqs (iterable): iseqs of original proxy

    Returns:
        [[3,4], [5,6], [7,8]]
    """
    result = []
    # self.setup_sets()
    # print("iseqs in get_copy_iseqs:", iseqs)
    for gr in self:
      if iseqs[0] in gr.set_master_iselection:
        # check the rest are in:
        for iseq in iseqs[1:]:
          assert iseq in gr.set_master_iselection
        # now iterate over input iseqs and populate the result
        for i in range(gr.get_number_of_copies()):
          result.append([])
        for in_iseq in iseqs:
          # find the index:
          iseq_idex = gr.list_master_iselection.index(in_iseq)
          for i, c in enumerate(gr.copies):
            result[i].append(c.iselection[iseq_idex])
        return result
    return result

  def get_n_groups(self):
    return len(self)

  def update_str_selections_if_needed(
      self, hierarchy, asc=None, chains_info=None):
    from mmtbx.ncs.ncs_search import get_chains_info
    from iotbx.pdb.atom_selection import selection_string_from_selection
    if asc is None:
      asc = hierarchy.atom_selection_cache()
    if chains_info is None:
      chains_info = get_chains_info(hierarchy)
    for gr in self:
      if gr.master_str_selection is None:
        gr.master_str_selection = selection_string_from_selection(
            hierarchy,
            gr.master_iselection,
            chains_info,
            asc)
        for c in gr.copies:
          if c.str_selection is None:
            c.str_selection = selection_string_from_selection(
                hierarchy,
                c.iselection,
                chains_info,
                asc)

  def deep_copy(self):
    result = class_ncs_restraints_group_list()
    for gr in self:
      result.append(gr.deep_copy())
    return result

  def select(self, selection):
    assert isinstance(selection, flex.bool)
    result = self.deep_copy()
    for gr in result:
      gr.select(selection)
    return result

  def split_by_chains(self, hierarchy):
    new_groups = class_ncs_restraints_group_list()
    for g in self:
      new_gs = g.split_by_chains(hierarchy)
      new_groups += new_gs
    return new_groups

  def filter_out_small_groups(self, min_n_atoms=3):
    new_groups = class_ncs_restraints_group_list()
    for g in self:
      if g.master_iselection.size() >= min_n_atoms:
        new_groups.append(g.deep_copy())
    return new_groups

  def update_i_seqs(self, old_i_seqs):
    """
    correct iseqs using supplied list
    """
    for group in self:
      group.update_i_seqs(old_i_seqs)

  def filter_ncs_restraints_group_list(self, whole_h, ncs_obj):
    """ Remove ncs groups where master or copy does not cover whole chain
    (some atoms are left behind).
    Reason for this - when big moves are likely (e.g. in real-space refine or
    model idealization), the chain can get a big gap in place where NCS ends.
    This leads to undesired artefacts in refinement.
    """
    def whole_chain_in_ncs(whole_h, master_iselection):
      m_c_id = whole_h.atoms()[master_iselection[0]].parent().parent().parent().id
      for chain in ncs_obj.truncated_hierarchy.only_model().chains():
        if chain.id == m_c_id:
          if chain.atoms_size() <= master_iselection.size():
            return True
          else:
            return False
    n_gr_to_remove = []
    for i, ncs_gr in enumerate(self):
      if not whole_chain_in_ncs(whole_h, ncs_gr.master_iselection):
        n_gr_to_remove.append(i)
        continue
      for c in ncs_gr.copies:
        if not whole_chain_in_ncs(whole_h, c.iselection):
          n_gr_to_remove.append(i)
          break
    result = self.deep_copy()
    for i in reversed(n_gr_to_remove):
      del result[i]
    return result

  def recalculate_ncs_transforms(self, asu_site_cart):
    """
    Re-evaluate the rotation and translation in the ncs groups list, base on
    the ncs groups selection and the atoms location.
    Updates self.

    Args:
      asu_site_cart (flex.vec_3): the complete ASU sites cart (coordinates)
    """
    for gr in self:
      m_sel = gr.master_iselection
      for cp in gr.copies:
        c_sel = cp.iselection
        # other_sites are the master, reference_sites are the copies
        lsq_fit_obj = superpose.least_squares_fit(
            reference_sites = asu_site_cart.select(c_sel),
            other_sites     = asu_site_cart.select(m_sel))
        cp.r = lsq_fit_obj.r
        cp.t = lsq_fit_obj.t
        cp.rmsd = asu_site_cart.select(c_sel).rms_difference(lsq_fit_obj.other_sites_best_fit())

  def check_for_max_rmsd(self,
      sites_cart,
      chain_max_rmsd=10.0,
      log=StringIO()):
    """
    Check that all copies relate correctly to master via the transforms

    Args:
      sites_cart: Atom coordinates
      chain_max_rmsd (float): maximum allowed rmsd between coordinates copies

    Returns:
      nrgl_ok (bool): True when ncs_restraints_group_list is OK
    """
    nrgl_ok = True
    for i,gr in enumerate(self):
      master_xyz = sites_cart.select(gr.master_iselection)
      for j,cp in enumerate(gr.copies):
        copy_xyz = sites_cart.select(cp.iselection)
        xyz = cp.r.elems * master_xyz + cp.t
        rmsd = copy_xyz.rms_difference(xyz)
        nrgl_ok &= (rmsd <= chain_max_rmsd)
        if (rmsd > chain_max_rmsd):
          print('Allowed rmsd : {}, rmsd: {}'.format(chain_max_rmsd,rmsd), file=log)
    return nrgl_ok

  def shift_translation_to_center(self, shifts):
    """
    Add shifts to the translation component of ncs_restraints_group_list
    towards the center of coordinates

    Args:
      shifts (list): [mu_1, mu_1, mu_2...] where the mu stands
        for the shift of the master copy to the coordinate center mu is (dx,dy,dz)

    Returns:
      new ncs_restraints_group_list
    """
    new_list = []
    if bool(shifts):
      new_list = self.deep_copy()
      i = 0
      for nrg in new_list:
        for ncs_copy in nrg.copies:
          mu = shifts[i]
          i += 1
          # Only the translation is changing
          t = ncs_copy.r.elems * mu + ncs_copy.t - mu
          ncs_copy.t = matrix.col(t[0])
    return new_list

  def shift_translation_back_to_place(self, shifts):
    """
    shifts to the translation component of ncs_restraints_group_list from the
    center of coordinates back to place

    Args:
      shifts (list): [mu_1, mu_1, mu_2...] where the mu stands
        for the shift of the master copy to the coordinate center mu is (dx,dy,dz)

    Returns:
      new ncs_restraints_group_list
    """
    if bool(shifts):
      i = 0
      new_list = self.deep_copy()
      for nrg in new_list:
        for ncs_copy in nrg.copies:
          mu = shifts[i]
          i += 1
          # Only the translation is changing
          t = mu - ncs_copy.r.elems * mu + ncs_copy.t
          ncs_copy.t = matrix.col(t[0])
    else:
      new_list = ncs_restraints_group_list
    return new_list

  def _show(self, hierarchy=None, brief=True):
    """
    For debugging
    """
    #print("debugging output of ncs_restraints_group_list")
    for group in self:
      print("Master str selection:", group.master_str_selection)
      if not brief:
        print(list(group.master_iselection))
      if hierarchy is not None:
        print(hierarchy.select(group.master_iselection).as_pdb_string()) # PDB OK - debugging output
      for c in group.copies:
        print("Copy str selection:", c.str_selection)
        if not brief:
          print(list(c.iselection))
        # print "rot", list(c.r)
        # print "tran", list(c.t)
        if hierarchy is not None:
          print(hierarchy.select(c.iselection).as_pdb_string()) # PDB OK - debugging output
      print("="*30)
    #print("end debugging output of ncs_restraints_group_list")


  def get_ncs_groups_centers(self, sites_cart):
    """
    calculate the center of coordinate for the master of each ncs copy

    Args:
      sites_cart

    Returns:
      shifts (list): [mu_1, mu_1, mu_2...] where the mu stands
      for the shift of the master copy to the coordinate center mu is (dx,dy,dz)
    """
    shifts = []
    for nrg in self:
      master_ncs_selection = nrg.master_iselection
      master_xyz = sites_cart.select(master_ncs_selection)
      mu_m = flex.vec3_double([master_xyz.mean()])
      # add a copy of the master coordinate center for each copy
      for ncs_copy in nrg.copies:
        shifts.append(mu_m)
    return shifts

  def get_ncs_groups_shifts(self, sites_cart, current):
    shifts = []
    for nrg in self:
      master_ncs_selection = nrg.master_iselection
      master_xyz = sites_cart.select(master_ncs_selection)
      mu_m = flex.vec3_double([master_xyz.mean()])
      shifts.append(mu_m-current.mean())
      for ncs_copy in nrg.copies:
        asu_selection = ncs_copy.iselection
        asu_xyz = sites_cart.select(asu_selection)
        mu_i = flex.vec3_double([asu_xyz.mean()])
        shifts.append(mu_i-current.mean())
    return shifts

  def get_all_copies_selection(self):
    result = flex.size_t()
    for nrg in self:
      for c in nrg.copies:
        result.extend(c.iselection)
    return flex.sorted(result)

  def get_extended_ncs_selection(self, refine_selection):
    """
    Args:
      refine_selection (flex.size_t): of all ncs related copies and
        non ncs related parts to be included in selection (to be refined)

    Returns:
      (flex.siz_t): selection of all ncs groups master ncs selection and
        non ncs related portions that are being refined (exclude NCS copies)
    """
    if not refine_selection:
      refine_selection = []
    refine_selection = set(refine_selection)
    total_master_ncs_selection = set()
    total_ncs_related_selection = set()
    for nrg in self:
      master_ncs_selection = nrg.master_iselection
      total_master_ncs_selection.update(set(master_ncs_selection))
      for ncs_copy in nrg.copies:
        asu_selection = ncs_copy.iselection
        total_ncs_related_selection.update(set(asu_selection))
    if refine_selection:
      # make sure all ncs related parts are in refine_selection
      all_ncs = total_master_ncs_selection | total_ncs_related_selection
      not_all_ncs_related_atoms_selected = bool(all_ncs - refine_selection)
      if not_all_ncs_related_atoms_selected:
        msg = 'refine_selection does not contain all ncs related atoms'
        raise Sorry(msg)
      #
      extended_ncs_selection = refine_selection - total_ncs_related_selection
      return flex.size_t(list(extended_ncs_selection))
    else:
      # if refine_selection is None
      return flex.size_t(list(total_master_ncs_selection))

  def concatenate_rot_tran(self):
    """
    Concatenate rotation angles, corresponding to the rotation
    matrices and scaled translation vectors to a single long flex.double object

    Returns:
      flex.double : [(alpha_1,beta_1,gamma_1,Tx_1,Ty_1,Tz_1)...]
    """
    x = []
    for gr in self:
      for tr in gr.copies:
        x.extend(list(nu.rotation_to_angles(rotation=tr.r.elems))
                 + list(tr.t.elems))
    return flex.double(x)

  def update_rot_tran(self, x):
    """
    Convert the refinable parameters, rotations angles and
    scaled translations, back to rotation matrices and translation vectors and
    updates the transforms_obj (ncs_restraints_group_list)
    !!! IN PLACE !!!

    Args:
      x : a flex.double of the form (theta_1,psi_1,phi_1,tx_1,ty_1,tz_1,..
        theta_n,psi_n,phi_n,tx_n/s,ty_n/s,tz_n/s). where n is the number of
        transformations.

    Returns:
      Nothing
    """
    i = 0
    for gr in self:
      copies = []
      for tr in gr.copies:
        the,psi,phi =x[i*6:i*6+3]
        rot = scitbx.rigid_body.rb_mat_xyz(
          the=the, psi=psi, phi=phi, deg=False)
        tran = matrix.rec(x[i*6+3:i*6+6],(3,1))
        tr.r = (rot.rot_mat())
        tr.t = tran
        copies.append(tr)
        i += 1
      gr.copies = copies

  def get_array_of_str_selections(self):
    """
    Returns array of phil selection strings e.g. for the exapmle above in
    print_ncs_phil_param:
    [['(Chain A)','(chain C)','(chain E)'],['(chain B)','(chain D)','(chain F)']]
    """
    result = []
    for gr in self:
      group = [gr.master_str_selection]
      for c in gr.copies:
        group.append(c.str_selection)
      result.append(group)
    return result

  def unique_with_biomt(self, hierarchy):
    # first we need to check if it is possible.
    # Criteria:
    # - all model is covered by NCS
    # - every chain is fully covered by NCS
    # self.filter_ncs_restraints_group_list
    # also limiting to 1 NCS group. Not clear how to describe multiple groups
    # where operations need to performed on a different chains

    assert len(self) == 1

    cif_block = iotbx.cif.model.block()


    resulting_hierarchy = hierarchy.select(self[0].master_iselection)
    master_label_asym_ids = []
    for c in resulting_hierarchy.only_model().chains():
      lai = resulting_hierarchy.get_label_asym_id(c.residue_groups()[0])
      master_label_asym_ids.append(lai)

    pdbx_struct_assembly_gen_loop = iotbx.cif.model.loop(header=(
        '_pdbx_struct_assembly_gen.assembly_id',
        '_pdbx_struct_assembly_gen.oper_expression',
        '_pdbx_struct_assembly_gen.asym_id_list',))

    pdbx_struct_assembly_loop = iotbx.cif.model.loop(header=(
        '_pdbx_struct_assembly.id',
        '_pdbx_struct_assembly.details',
        '_pdbx_struct_assembly.method_details',
        '_pdbx_struct_assembly.oligomeric_details',
        '_pdbx_struct_assembly.oligomeric_count',))

    pdbx_struct_oper_list_loop = iotbx.cif.model.loop(header=(
       '_pdbx_struct_oper_list.id',
       '_pdbx_struct_oper_list.type',
       '_pdbx_struct_oper_list.name',
       '_pdbx_struct_oper_list.symmetry_operation',
       '_pdbx_struct_oper_list.matrix[1][1]',
       '_pdbx_struct_oper_list.matrix[1][2]',
       '_pdbx_struct_oper_list.matrix[1][3]',
       '_pdbx_struct_oper_list.matrix[2][1]',
       '_pdbx_struct_oper_list.matrix[2][2]',
       '_pdbx_struct_oper_list.matrix[2][3]',
       '_pdbx_struct_oper_list.matrix[3][1]',
       '_pdbx_struct_oper_list.matrix[3][2]',
       '_pdbx_struct_oper_list.matrix[3][3]',
       '_pdbx_struct_oper_list.vector[1]',
       '_pdbx_struct_oper_list.vector[2]',
       '_pdbx_struct_oper_list.vector[3]',))

    master_asym_id = ','.join(master_label_asym_ids)
    pdbx_struct_assembly_gen_loop.add_row({
        '_pdbx_struct_assembly_gen.assembly_id':'1',
        '_pdbx_struct_assembly_gen.oper_expression':'(1-%d)' % (len(self[0].copies)+1),
        '_pdbx_struct_assembly_gen.asym_id_list': master_asym_id,
      })

    pdbx_struct_assembly_loop.add_row({
        '_pdbx_struct_assembly.id': '1',
        '_pdbx_struct_assembly.details': 'Symmetry assembly',
        '_pdbx_struct_assembly.method_details': '?',
        '_pdbx_struct_assembly.oligomeric_details': '?',
        '_pdbx_struct_assembly.oligomeric_count': '?',
      })

    # put in identity transform
    oper_id = 1
    row = [oper_id, 'point symmetry operation', '?', '?']
    row.extend([1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0])
    pdbx_struct_oper_list_loop.add_row(row)

    for i_ncs_copy, ncs_copy in enumerate(self[0].copies):
      oper_id = i_ncs_copy + 2
      row = [oper_id, 'point symmetry operation', '?', '?']
      row.extend(ncs_copy.r)
      row.extend(ncs_copy.t)
      pdbx_struct_oper_list_loop.add_row(row)

    cif_block.add_loop(pdbx_struct_assembly_gen_loop)
    cif_block.add_loop(pdbx_struct_assembly_loop)
    cif_block.add_loop(pdbx_struct_oper_list_loop)

    return self[0].master_iselection, cif_block


  def as_cif_block(self, cif_block, hierarchy, scattering_type, ncs_type):
    """
    Let me lay out what I found and please correct me if I am wrong in any detail.
    There are some questions along as well. Then I will implement the correct NCS
    output in Phenix.
    We look at NCS groups in the following way:
    ncs_group {
      reference = chain 'C'
      selection = chain 'E'
      selection = chain 'G'
      selection = chain 'I'
    }
    ncs_group {
      reference = chain 'D'
      selection = chain 'F'
      selection = chain 'H'
      selection = chain 'J'
    }
    In this example we have 2 NCS groups with 4 chains in each. For simplicity,
    let's assume that whole chains are included. This means that chains C,E,G,I
    are NCS-related and (almost) identical. The same is for chains D,F,H,J.
    Chains in different NCS groups does not match each other. We also know relation
    (rotation/translation matrices) between chains C<--E, C<--G and C<--I.
    Same goes to the second group.

    Now I will try to translate this into mmCIF terminology:
    Ensemble - each of ncs_group.
    Domain - each of the reference/selection chains.
    If so, then mmCIF should have loops as following:
     _struct_ncs_ens.id
     _struct_ncs_ens.details
    en1 ?
    en2 ?
    We almost never know any useful details, so I'm putting ? here.
    Or will it be better to put something else very generic?
    Then we list 'domains' (we will put valid Phenix atom selection syntax in details):
    loop_
        _struct_ncs_dom.id
        _struct_ncs_dom.pdbx_ens_id
        _struct_ncs_dom.details
         d1 en1  'Chains C'
         d2 en1  'Chains E'
         d3 en1  'Chains G'
         d4 en1  'Chains I'
         d1 en2  'Chains D'
         d2 en2  'Chains F'
         d3 en2  'Chains H'
         d4 en2  'Chains J'

    And to relate everything to matrices:
    _struct_ncs_ens_gen.dom_id_1
    _struct_ncs_ens_gen.dom_id_2
    _struct_ncs_ens_gen.ens_id
    _struct_ncs_ens_gen.oper_id
    d1 d2 en1 op1
    d1 d3 en1 op2
    d1 d4 en1 op3
    d1 d2 en2 op4
    d1 d3 en2 op5
    d1 d4 en2 op6

    Question: Here is an important question: should we output matrices defining
    how to align dom_id_2 onto dom_id_1 or another way around?

    Answer (John Berrisford): "NCS operators are defined by struct_ncs_ens_gen.
    This defines which domain moves onto the other. Dom_id_1 doesn't move,
    dom_id_2 is transformed by the operator."
    http://mmcif.wwpdb.org/dictionaries/mmcif_pdbx_v50.dic/Categories/struct_ncs_ens_gen.html


    Content of _struct_ncs_oper
    (matrices themselves) seems trivial, so omitting from this example.

    Now I'm guessing _struct_ncs_dom_lim was designed with the ability to
    provide more than one residue-level interval for each 'domain' and
    pdbx_component_id is for numbering these intervals. In our simple case there
    will be only one row for each domain:
    loop_
        _struct_ncs_dom_lim.dom_id
        _struct_ncs_dom_lim.pdbx_ens_id
        _struct_ncs_dom_lim.pdbx_component_id
        _struct_ncs_dom_lim.beg_label_alt_id
        _struct_ncs_dom_lim.beg_label_asym_id
        _struct_ncs_dom_lim.beg_label_comp_id
        _struct_ncs_dom_lim.beg_label_seq_id
        _struct_ncs_dom_lim.end_label_alt_id
        _struct_ncs_dom_lim.end_label_asym_id
        _struct_ncs_dom_lim.end_label_comp_id
        _struct_ncs_dom_lim.end_label_seq_id
         d1 en1 1 .  C PRO  1  . C GLY  29
         d2 en1 1 .  E PRO  1  . E GLY  29
         d3 en1 1 .  G PRO  1  . G GLY  29
         d4 en1 1 .  I PRO  1  . I GLY  29
         d1 en2 1 .  D PRO  31 . D GLY  59
         d2 en2 1 .  F PRO  31 . F GLY  59
         d3 en2 1 .  H PRO  31 . H GLY  59
         d4 en2 1 .  J PRO  31 . J GLY  59
    Can we omit _struct_ncs_dom_lim loop? We will put valid Phenix atom selection
    syntax in selection_details in this loop.

    JB: "Please do not omit _struct_ncs_dom_lim - this provides
    the exact details of which residues from which chain have to be transformed
    with the NCS operator.  This is the bit read by users such as pdb_redo when
    they are re-refining the structures. Note in struct_ncs_dom_lim there are
    fields for auth_asym_id (chain ID in PDB speak) and
    label_asym_id (mmCIF only chain identifiers). Please do not mix these two."

    Then, after refinement, we can construct _refine_ls_restr_ncs where
    pdbx_ordinal - is just ordinal number in this loop
    dom_id - domain id (== _struct_ncs_ens_gen.dom_id_1 == _struct_ncs_dom.id)
    pdbx_ens_id - ensemble id (== _struct_ncs_ens_gen.ens_id == _struct_ncs_ens.id )
    pdbx_asym_id - chain id from the first component (_struct_ncs_dom_lim.pdbx_component_id)?
    There is an example of domain with 3 components:
    http://mmcif.wwpdb.org/dictionaries/mmcif_pdbx_v50.dic/Categories/struct_ncs_dom_lim.html
    and chain A is chosen for this asym_id:
    http://mmcif.wwpdb.org/dictionaries/mmcif_pdbx_v50.dic/Categories/refine_ls_restr_ncs.html
    Do I understand correctly that you expect information on only 3 domains from
    each ensemble (marked 'selection' in Phenix notation) and it should show
    how this particular domain relates to the first one ('reference' in Phenix notation)?

    JB: "yes, refine_ls_restr_ncs describes the refinement result and gives the
    details of moving domain 2 onto domain 1 - i.e. how well do they overlay if
    the transform is applied. So domain 1 doesn't need to be described here - it
    would fit perfectly to itself (we hope!)"

    _struct_ncs_oper.code is 'given' since in Phenix we never omit NCS-related
    parts of model.
    """
    #
    def _consecutive_ranges(isel):
      '''
      Split selection into consecutive ranges that can be represented
      by ncs_dom_lim. Maybe useful elsewhere.
      '''
      result = []
      start_index = 0
      cur_index = 1
      atoms = hierarchy.atoms()
      # shortcut: if all atoms form consecutive range and in one chain:
      if ( (isel[-1] -isel[0] == len(isel)-1)
          and (hierarchy.get_label_asym_id_iseq(isel[0]) == \
                hierarchy.get_label_asym_id_iseq(isel[-1]))):
        return [isel]

      seq_id = hierarchy.get_label_seq_id_iseq(isel[0])
      seq_id = int(seq_id) if seq_id !='.' else 0
      asym_id = hierarchy.get_label_asym_id_iseq(isel[0])
      while cur_index < len(isel):
        if cur_index >= len(isel):
          break
        seq_id_1 = seq_id
        asym_id_1 = asym_id
        #
        seq_id = hierarchy.get_label_seq_id_iseq(isel[cur_index])
        seq_id = int(seq_id) if seq_id !='.' else 0
        asym_id = hierarchy.get_label_asym_id_iseq(isel[cur_index])
        # print ('  DEBUG: seq_id, asym_id,', seq_id, asym_id, seq_id_1, asym_id_1)
        if (
            # consecutive indices and no chain break
            (isel[cur_index]-isel[cur_index-1] == 1
                and asym_id == asym_id_1)
            # same chain, same or next resid, no indices check (missing atom, etc)
            or (asym_id == asym_id_1
                and abs(seq_id - seq_id_1) <= 1 )
            ):
          cur_index += 1
        else: # end range
          # assert start_index != cur_index-1 # maybe needed for 1 atom chains, like ions
          result.append(isel[start_index:cur_index])
          start_index = cur_index
          cur_index += 1
      if start_index != cur_index-1:
        result.append(isel[start_index:cur_index])
      # print ('Debug result', [list(x) for x in result])
      return result

    def _get_struct_ncs_dom_lim_row(dom_id, comp_id, r):
      return {
          "_struct_ncs_dom_lim.pdbx_ens_id": struct_ncs_ens_id,
          "_struct_ncs_dom_lim.dom_id": dom_id,
          "_struct_ncs_dom_lim.pdbx_component_id": comp_id,
          "_struct_ncs_dom_lim.beg_label_alt_id": hierarchy.get_label_alt_id_iseq(r[0]),
          "_struct_ncs_dom_lim.beg_label_asym_id": hierarchy.get_label_asym_id_iseq(r[0]),
          "_struct_ncs_dom_lim.beg_label_comp_id": hierarchy.atoms()[r[0]].parent().resname.strip(),
          "_struct_ncs_dom_lim.beg_label_seq_id": hierarchy.get_label_seq_id_iseq(r[0]),
          "_struct_ncs_dom_lim.end_label_alt_id": hierarchy.get_label_alt_id_iseq(r[-1]),
          "_struct_ncs_dom_lim.end_label_asym_id": hierarchy.get_label_asym_id_iseq(r[-1]),
          "_struct_ncs_dom_lim.end_label_comp_id": hierarchy.atoms()[r[-1]].parent().resname.strip(),
          "_struct_ncs_dom_lim.end_label_seq_id": hierarchy.get_label_seq_id_iseq(r[-1])}

    ncs_ens_loop = iotbx.cif.model.loop(header=(
      "_struct_ncs_ens.id",
      "_struct_ncs_ens.details"))
    ncs_dom_loop = iotbx.cif.model.loop(header=(
      "_struct_ncs_dom.pdbx_ens_id",
      "_struct_ncs_dom.id",
      "_struct_ncs_dom.details"))
    ncs_dom_lim_loop = iotbx.cif.model.loop(header=(
      "_struct_ncs_dom_lim.pdbx_ens_id",
      "_struct_ncs_dom_lim.dom_id",
      "_struct_ncs_dom_lim.pdbx_component_id",
      #"_struct_ncs_dom_lim.pdbx_refine_code", # no need, from CCP4
      "_struct_ncs_dom_lim.beg_label_alt_id",
      "_struct_ncs_dom_lim.beg_label_asym_id",
      "_struct_ncs_dom_lim.beg_label_comp_id",
      "_struct_ncs_dom_lim.beg_label_seq_id",
      "_struct_ncs_dom_lim.end_label_alt_id",
      "_struct_ncs_dom_lim.end_label_asym_id",
      "_struct_ncs_dom_lim.end_label_comp_id",
      "_struct_ncs_dom_lim.end_label_seq_id",))

    ncs_oper_loop = iotbx.cif.model.loop(header=(
      "_struct_ncs_oper.id",
      "_struct_ncs_oper.code",
      "_struct_ncs_oper.matrix[1][1]",
      "_struct_ncs_oper.matrix[1][2]",
      "_struct_ncs_oper.matrix[1][3]",
      "_struct_ncs_oper.matrix[2][1]",
      "_struct_ncs_oper.matrix[2][2]",
      "_struct_ncs_oper.matrix[2][3]",
      "_struct_ncs_oper.matrix[3][1]",
      "_struct_ncs_oper.matrix[3][2]",
      "_struct_ncs_oper.matrix[3][3]",
      "_struct_ncs_oper.vector[1]",
      "_struct_ncs_oper.vector[2]",
      "_struct_ncs_oper.vector[3]",
      "_struct_ncs_oper.details"))

    ncs_ens_gen_loop = iotbx.cif.model.loop(header=(
      "_struct_ncs_ens_gen.ens_id",
      "_struct_ncs_ens_gen.dom_id_1",
      "_struct_ncs_ens_gen.dom_id_2",
      "_struct_ncs_ens_gen.oper_id"))

    refine_ls_restr_ncs_loop = iotbx.cif.model.loop(header=(
      "_refine_ls_restr_ncs.pdbx_ordinal",
      "_refine_ls_restr_ncs.pdbx_ens_id",
      "_refine_ls_restr_ncs.dom_id",
      "_refine_ls_restr_ncs.pdbx_refine_id",
      "_refine_ls_restr_ncs.pdbx_asym_id",
      "_refine_ls_restr_ncs.pdbx_type",
      "_refine_ls_restr_ncs.weight_position",
      "_refine_ls_restr_ncs.weight_B_iso",
      "_refine_ls_restr_ncs.rms_dev_position",
      "_refine_ls_restr_ncs.rms_dev_B_iso",
      "_refine_ls_restr_ncs.ncs_model_details"))

    self.update_str_selections_if_needed(hierarchy)
    self.recalculate_ncs_transforms(hierarchy.atoms().extract_xyz())
    if cif_block is None:
      cif_block = iotbx.cif.model.block()
    if len(self) == 0:
      return cif_block
    refine_ls_restr_ncs_pdbx_ordinal = 1
    n_oper = 1
    for i_group, group in enumerate(self):
      struct_ncs_ens_id = 'ens_%d' % (i_group+1)
      ncs_ens_loop.add_row({"_struct_ncs_ens.id" : struct_ncs_ens_id})
      # master loops
      master_dom_id = 'd_1'
      ncs_dom_loop.add_row({
          "_struct_ncs_dom.pdbx_ens_id":struct_ncs_ens_id,
          "_struct_ncs_dom.id":master_dom_id,
          "_struct_ncs_dom.details":"%s" % group.master_str_selection.replace("'", '"')})
      ranges = _consecutive_ranges(group.master_iselection)
      for i_r, r in enumerate(ranges):
        ncs_dom_lim_loop.add_row(_get_struct_ncs_dom_lim_row(master_dom_id, i_r+1, r))
      # now get to copies
      for i_ncs_copy, ncs_copy in enumerate(group.copies):
        copy_dom_id = 'd_%d' % (i_ncs_copy+2) # no 0, 1-master
        ncs_dom_loop.add_row({
            "_struct_ncs_dom.pdbx_ens_id":struct_ncs_ens_id,
            "_struct_ncs_dom.id":copy_dom_id,
            "_struct_ncs_dom.details":'%s' % ncs_copy.str_selection.replace("'", '"')})

        ranges = _consecutive_ranges(ncs_copy.iselection)
        for i_r, r in enumerate(ranges):
          ncs_dom_lim_loop.add_row(_get_struct_ncs_dom_lim_row(copy_dom_id, i_r+1, r))
        oper_id = 'op_%d' % n_oper
        n_oper += 1
        ncs_ens_gen_loop.add_row({
            "_struct_ncs_ens_gen.dom_id_1":copy_dom_id,
            "_struct_ncs_ens_gen.dom_id_2":master_dom_id,
            "_struct_ncs_ens_gen.ens_id":struct_ncs_ens_id,
            "_struct_ncs_ens_gen.oper_id":oper_id})
        row = [oper_id, 'given']
        row.extend(ncs_copy.r)
        row.extend(ncs_copy.t)
        row.append('?')
        ncs_oper_loop.add_row(row)

        refine_ls_restr_ncs_loop.add_row({
            "_refine_ls_restr_ncs.pdbx_ordinal": refine_ls_restr_ncs_pdbx_ordinal,
            "_refine_ls_restr_ncs.dom_id": copy_dom_id,
            "_refine_ls_restr_ncs.pdbx_refine_id": scattering_type,
            "_refine_ls_restr_ncs.pdbx_ens_id": struct_ncs_ens_id,
            "_refine_ls_restr_ncs.pdbx_asym_id": "'%s'" % hierarchy.get_label_asym_id_iseq(group.master_iselection[0]),
            "_refine_ls_restr_ncs.pdbx_type": ncs_type,
            "_refine_ls_restr_ncs.weight_position": '?', # weight_position
            "_refine_ls_restr_ncs.weight_B_iso": '?', # weight_B_iso
            "_refine_ls_restr_ncs.rms_dev_position": ncs_copy.rmsd,
            "_refine_ls_restr_ncs.rms_dev_B_iso": '?', # rms_dev_B_iso
            "_refine_ls_restr_ncs.ncs_model_details": '?', # model_details
            })
        refine_ls_restr_ncs_pdbx_ordinal += 1
      cif_block.add_loop(ncs_ens_loop)
      cif_block.add_loop(ncs_dom_loop)
      cif_block.add_loop(ncs_dom_lim_loop)
      cif_block.add_loop(ncs_oper_loop)
      cif_block.add_loop(ncs_ens_gen_loop)
      cif_block.add_loop(refine_ls_restr_ncs_loop)
    return cif_block


 *******************************************************************************


 *******************************************************************************
mmtbx/ncs/ncs_search.py
from __future__ import absolute_import, division, print_function
from scitbx.array_family import flex
from scitbx.math import superpose
from libtbx.utils import Sorry
import sys
from six.moves import cStringIO as StringIO
import iotbx.pdb
from iotbx.pdb.hierarchy import new_hierarchy_from_chain
from mmtbx.ncs.ncs_restraints_group_list import class_ncs_restraints_group_list, \
    NCS_restraint_group, NCS_copy
from mmtbx.refinement.flip_peptide_side_chain import should_be_flipped, \
    flippable_sidechains

import six
from six.moves import zip
from six.moves import range

__author__ = 'Youval, massively rewritten by Oleg'


class Chains_info(object):
  """ Container for hierarchy analysis """
  def __init__(self):
    self.res_names = []
    self.resid = []
    self.atom_names = []
    self.atom_selection = []
    self.flat_atom_selection = flex.size_t([])
    self.chains_atom_number = 0
    self.no_altloc = []
    self.gap_residue = []
    self.center_of_coordinates = None

  def __str__(self):
    assert 0
    res = StringIO()
    print("res_names:", self.res_names, file=res)
    print("self.resid", self.resid, file=res)
    print("self.atom_names", self.atom_names, file=res)
    print("self.atom_selection", self.atom_selection, file=res)
    print("self.flat_atom_selection", list(self.flat_atom_selection), file=res)
    print("self.chains_atom_number", self.chains_atom_number, file=res)
    print("self.no_altloc", self.no_altloc, file=res)
    print("self.center_of_coordinates", self.center_of_coordinates, file=res)
    return res.getvalue()

def get_chain_xyz(hierarchy, chain_id):
  for chain in hierarchy.only_model().chains():
    if chain.id == chain_id:
      return chain.atoms().extract_xyz()

def shortcut_1(
    hierarchy,
    chains_info,
    chain_similarity_threshold,
    chain_max_rmsd,
    log,
    residue_match_radius):
  """
  Checking the case when whole hierarchy was produced by multiplication of
  molecule with BIOMT or MTRIX matrices (or both). In this case we are expecting
  to find identical chains with 0 rmsd between them.
  """
  assert chains_info is not None
  assert len(chains_info) > 1
  empty_result = class_ncs_restraints_group_list()

  # new convenience structure: {<n_atoms>:[ch_id, ch_id, ch_id]}
  n_atom_chain_id_dict = {}
  for k,v in six.iteritems(chains_info):
    if v.chains_atom_number not in n_atom_chain_id_dict:
      n_atom_chain_id_dict[v.chains_atom_number] = [k]
    else:
      n_atom_chain_id_dict[v.chains_atom_number].append(k)
  print("n_atom_chain_id_dict", n_atom_chain_id_dict, file=log)
  for k,v in six.iteritems(n_atom_chain_id_dict):
    if len(v) == 1:
      print("No shortcut, there is a chain with unique number of atoms:", v, file=log)
      return empty_result
  # now we starting to check atom names, align chains, check rmsd and
  # populate result. If at some point we are not satisfied with any measure,
  # we will return empty result.
  result = class_ncs_restraints_group_list()
  for n_atoms, chains_list in six.iteritems(n_atom_chain_id_dict):
    # this should make one ncs group
    master_chain_id = chains_list[0]
    ncs_gr = NCS_restraint_group(
        master_iselection=chains_info[master_chain_id].flat_atom_selection.deep_copy(),
        str_selection="chain '%s'" % master_chain_id)
    master_xyz = get_chain_xyz(hierarchy, master_chain_id)
    for copy_chain_id in chains_list[1:]:
      # these are copies
      for a, b in zip(chains_info[master_chain_id].atom_names, chains_info[copy_chain_id].atom_names):
        if list(a)!=list(b):
          print("No shortcut, atom names are not identical", file=log)
          return empty_result
      copy_xyz = get_chain_xyz(hierarchy, copy_chain_id)
      lsq_fit_obj = superpose.least_squares_fit(
          reference_sites = copy_xyz,
          other_sites     = master_xyz)
      r = lsq_fit_obj.r
      t = lsq_fit_obj.t
      rmsd = copy_xyz.rms_difference(lsq_fit_obj.other_sites_best_fit())
      print("rmsd", master_chain_id, copy_chain_id, rmsd, file=log)
      #
      # XXX should we compare rmsd to chain_max_rmsd to be more relaxed and
      #     process more structures quickly?
      #
      if rmsd is None or rmsd > 0.2:
        print("No shortcut, low rmsd:", rmsd, "for chains", master_chain_id, copy_chain_id, file=log)
        return empty_result
      # seems like a good enough copy
      c = NCS_copy(
          copy_iselection=chains_info[copy_chain_id].flat_atom_selection.deep_copy(),
          rot=r,
          tran=t,
          str_selection="chain '%s'" % copy_chain_id,
          rmsd=rmsd)
      ncs_gr.append_copy(c)
    result.append(ncs_gr)
  print("Shortcut complete.", file=log)
  return result

def find_ncs_in_hierarchy(ph,
                          chains_info=None,
                          chain_max_rmsd=5.0,
                          log=None,
                          chain_similarity_threshold=0.85,
                          residue_match_radius=4.0):
  """
  Find NCS relation in hierarchy

  Args:
    ph (object): hierarchy
    use_minimal_master_ncs (bool): use maximal or minimal common chains
        in master ncs groups
    chain_max_rmsd (float): limit of rms difference chains when aligned together
    residue_match_radius (float): max allow distance difference between pairs of matching
      atoms of two residues
    chain_similarity_threshold (float): min similarity between matching chains

  Return:
    groups_list - class_ncs_restraints_group_list
  """
  if not log: log = sys.stdout
  if chains_info is None:
    chains_info = get_chains_info(ph)
  # Get the list of matching chains
  match_dict = search_ncs_relations(
    ph=ph,
    chains_info=chains_info,
    chain_similarity_threshold=chain_similarity_threshold,
    chain_max_rmsd=chain_max_rmsd,
    residue_match_radius=residue_match_radius,
    log=None)
  # new, the basic way of processing, by Oleg.
  return ncs_grouping_and_group_dict(match_dict, ph)


def _get_rmsds2(master_xyz, copy_xyz, cur_ttg):
  """
  This function is for debugging purposes and should not be called (not used
  presently).
  """
  xyz = cur_ttg[2][0].elems * master_xyz + cur_ttg[2][1]
  # rmsd1 = 0
  # if copy_xyz.size() == xyz.size():
  rmsd1 = copy_xyz.rms_difference(xyz)
  xyz = cur_ttg[2][0].elems * master_xyz + cur_ttg[2][1]
  # rmsd2 = 0
  # if copy_xyz.size() == xyz.size():
  rmsd2 = copy_xyz.rms_difference(xyz)
  # print "rmsds:", rmsd1, rmsd2
  return rmsd1, rmsd2

def _get_rmsds(hierarchy, cache, cur_ttg, master, copy):
  """
  This function is for debugging purposes and not called.
  Similar check will be performed later in execution and in case of
  wrong grouping will raise Sorry: bad phil records.
  """
  str_sel_m = "chain "+" or chain ".join(cur_ttg[0]+[master])
  str_sel_c = "chain "+" or chain ".join(cur_ttg[1]+[copy])
  sel1 = cache.selection("chain "+" or chain ".join(cur_ttg[0]+[master]))
  sel2 = cache.selection("chain "+" or chain ".join(cur_ttg[1]+[copy]))
  # print "sel1, sel2", str_sel_m, "|", str_sel_c
  master_xyz = hierarchy.select(sel1).atoms().extract_xyz()
  copy_xyz = hierarchy.select(sel2).atoms().extract_xyz()
  xyz = cur_ttg[2][0].elems * master_xyz + cur_ttg[2][1]
  rmsd1 = 0
  if copy_xyz.size() == xyz.size():
    rmsd1 = copy_xyz.rms_difference(xyz)

  str_sel_m = "chain "+" or chain ".join(cur_ttg[0]+[copy])
  str_sel_c = "chain "+" or chain ".join(cur_ttg[1]+[master])
  # print "sel1, sel2", str_sel_m, "|", str_sel_c
  sel1 = cache.selection("chain "+" or chain ".join(cur_ttg[0]+[copy]))
  sel2 = cache.selection("chain "+" or chain ".join(cur_ttg[1]+[master]))
  # print "sel1, sel2", sel1, sel2
  master_xyz = hierarchy.select(sel1).atoms().extract_xyz()
  copy_xyz = hierarchy.select(sel2).atoms().extract_xyz()
  xyz = cur_ttg[2][0].elems * master_xyz + cur_ttg[2][1]
  rmsd2 = 0
  if copy_xyz.size() == xyz.size():
    rmsd2 = copy_xyz.rms_difference(xyz)
  return rmsd1, rmsd2


def get_bool_selection_to_keep(big_selection, small_selection):
  """
  given 2 iselections (they are sorted), returns bool selection of size
  big selection showing what are the matches with small selection.
  Rather fast algorithm but may be beneficial to transfer to C++
  O(n+m), where n,m - sizes of selections
  """
  assert big_selection.size() >= small_selection.size()
  result = flex.bool(big_selection.size(), False)
  i_in_big = 0
  i_in_small = 0
  size_small = small_selection.size()
  size_big = big_selection.size()
  n_matches = 0
  nw = 0
  while (i_in_big < size_big) and (i_in_small < size_small):
    if big_selection[i_in_big] == small_selection[i_in_small]:
      result[i_in_big] = True
      i_in_big += 1
      i_in_small += 1
      n_matches += 1
    elif big_selection[i_in_big] > small_selection[i_in_small]:
      i_in_small += 1
      nw += 1
    else:
      i_in_big += 1
  # this assert is optional, in general case it is not guaranteed that
  # all numbers from small selection are present in big selection.
  assert n_matches == size_small, "%d %d" % (n_matches, size_small)
  return result

def get_preliminary_ncs_groups(match_dict):
  pairs = sorted(match_dict.keys())
  chains_in_groups = []
  preliminary_ncs_groups = []
  while len(pairs) > 0:
    # print "  pairs", pairs
    # take the first one, should be new group
    n_not_in_groups = 0
    n_not_in_groups += pairs[0][0] not in chains_in_groups
    n_not_in_groups += pairs[0][1] not in chains_in_groups
    # print "n_not_in_groups", n_not_in_groups
    if n_not_in_groups == 2:
      # make new group
      preliminary_ncs_groups.append({
          pairs[0][0]:pairs[0],
          pairs[0][1]:pairs[0]})
      chains_in_groups.append(pairs[0][0])
      chains_in_groups.append(pairs[0][1])
      curr_masters = pairs[0]
      pairs.pop(0)
      # print "  curr_masters", curr_masters
      # check all the rest pairs to see if they can add something to this group
      pairs_to_remove = []
      for pair in pairs:
        # print "    checking", pair
        if pair[0] == curr_masters[0]:
          if pair[1] not in curr_masters:
            # add pair[1]
            # print "      adding 0"
            if pair[1] not in chains_in_groups:
              preliminary_ncs_groups[-1][pair[1]] = pair
              chains_in_groups.append(pair[1])
            pairs_to_remove.append(pair)

        if pair[1] == curr_masters[0]:
          if pair[0] not in curr_masters:
            # print "      adding 1"
            # add pair[1]
            if pair[0] not in chains_in_groups:
              preliminary_ncs_groups[-1][pair[0]] = pair
              chains_in_groups.append(pair[0])
            pairs_to_remove.append(pair)
      for p in pairs_to_remove:
        pairs.remove(p)

    elif n_not_in_groups == 0:
      # print "    popping the first"
      pairs.pop(0)
    elif n_not_in_groups == 1:
      # should never happen
      # print "    n_not_in_groups==1"
      pairs.pop(0)
      # assert 0
    # print "prel_ncs_gr", preliminary_ncs_groups
  return preliminary_ncs_groups


def ncs_grouping_and_group_dict(match_dict, hierarchy):
  """
  The implementation of simplest way to do NCS grouping. Maximum one chain
  in selection.
  Do the job of minimal_master_ncs_grouping/minimal_ncs_operators_grouping.
  """
  ncs_restraints_group_list = class_ncs_restraints_group_list()
  preliminary_ncs_groups = get_preliminary_ncs_groups(match_dict)

  # now we need to just transform preliminary_ncs_groups using match_dict
  # into ncs_restraints_group_list. This means that for every dict in preliminary_ncs_groups
  # we need to determine master, and find out rot and transl functions for all
  # the rest chains (selections). Master is going to be the first in
  # alphabetical order.

  for prel_gr_dict in preliminary_ncs_groups:
    # print "==============="
    sorted_gr_chains = sorted(prel_gr_dict.keys())

    # master should be the chain with minimal number of selected atoms
    # just to make it easier filter out the rest of chains
    # print "sorted_gr_chains", sorted_gr_chains
    # print "prel_gr_dict", prel_gr_dict
    min_n_atoms = 1e100
    master = None
    for ch in sorted_gr_chains:
      sel, _,_ = get_info_from_match_dict(match_dict, prel_gr_dict[ch], ch)
      if sel.size() < min_n_atoms:
        min_n_atoms = sel.size()
        master = ch
    assert master is not None
    # print "selected master first:", master

    # second option to master selection:
    # let's try to select common chain to be a master. I'm not sure that this
    # will be always possible though
    # also, we should try to determine the smallest selection for the master
    # chain straight away
    all_pairs = list(prel_gr_dict.values())
    left = set(all_pairs[0])
    # print "left", left
    # print "all_pairs", all_pairs
    # FIXME indexing dict.values order changes with py2/3
    for i in all_pairs[1:]:
      left = left & set(i)
    # should be 1 (a lot of chains) or 2 (if there only 2 chains)
    # if len
    if len(left) == 0:
      # means that all something like
      # all_pairs = [('chain C', 'chain E'), ('chain A', 'chain E'),
      #              ('chain A', 'chain C')]
      # any should work then?...

      # master = all_pairs[0][0]
      master = sorted_gr_chains[0]

    # assert len(left) > 0
    # print "left", left
    elif len(left) > 1:
      master = sorted(left)[0]
    else:
      master = left.pop()


    # selecting smallest master key - for no reason actually
    key_with_smallest_selection = None
    len_of_smallest_selection = 1e100
    for ch, key in six.iteritems(prel_gr_dict):
      # print "ch, master, key:", ch, master, key
      if master in key:
        master_sel, master_res, master_rmsd = get_info_from_match_dict(
                match_dict, key, master)
        if master_sel.size() < len_of_smallest_selection:
          len_of_smallest_selection = master_sel.size()
          key_with_smallest_selection = key
    # print "key_with_smallest_selection, len_of_smallest_selection",key_with_smallest_selection, len_of_smallest_selection
    # print "selected master second:", master

    assert master is not None
    assert master in key_with_smallest_selection, "%s, %s" % (master, key_with_smallest_selection)

    #
    # Let's do intersection of all master selection to determine
    # the minimum selection suitable to all copies.
    min_master_selection = None
    for ch, key in six.iteritems(prel_gr_dict):
      if master in key:
        master_sel, master_res, master_rmsd = get_info_from_match_dict(
                match_dict, key, master)
        if min_master_selection is None:
          min_master_selection = master_sel
        else:
          min_master_selection = min_master_selection.intersection(master_sel)
    # print "size of min_master_selection", min_master_selection.size()

    # create a new group
    g = NCS_restraint_group(
        master_iselection=min_master_selection,
        str_selection=None)
    for ch_copy in sorted_gr_chains:
      # print "ch_copy", ch_copy
      master_size = min_master_selection.size()
      copy_sel, copy_res, m_sel = get_copy_master_selections_from_match_dict(
          match_dict, prel_gr_dict, master, ch_copy)
      if copy_sel is None:
        # print " Continue"
        continue
      new_copy_sel = copy_sel
      new_master_sel = min_master_selection
      if copy_sel.size() > min_master_selection.size():
        # clean copy sel
        # print "copy is bigger", copy_sel.size(), min_master_selection.size()
        filter_sel = get_bool_selection_to_keep(
            big_selection=m_sel,
            small_selection=min_master_selection)
        new_copy_sel = copy_sel.select(filter_sel)
      elif copy_sel.size() < min_master_selection.size():
        assert 0, "This should never be the case"
      if new_master_sel.size() > 0 and new_copy_sel.size() > 0:
        r,t,copy_rmsd = my_get_rot_trans(
            ph=hierarchy,
            master_selection=new_master_sel,
            copy_selection=new_copy_sel,
            master_chain_id = master,
            copy_chain_id = ch_copy)
        c = NCS_copy(
            copy_iselection=new_copy_sel,
            rot=r,
            tran=t,
            str_selection=None,
            rmsd = copy_rmsd)
        g.append_copy(c)
        assert master_size == new_copy_sel.size(), "%d %d" % (master_size, new_copy_sel.size())
    ncs_restraints_group_list.append(g)
  return ncs_restraints_group_list


def get_info_from_match_dict(match_dict, key, chain):
  # print "    chain, key in get_info:", chain, key
  assert chain in key, "Mismatch between key and chain %s %s" % (chain, key)
  [sel_1,sel_2,res_1,res_2,_,_,rmsd] = match_dict[key]
  # print "sel_1,sel_2,res_1,res_2,_,_,rmsd", sel_1,sel_2,res_1,res_2,rmsd
  if chain == key[0]:
    return sel_1, res_1, rmsd
  else:
    return sel_2, res_2, rmsd

def get_copy_master_selections_from_match_dict(
    match_dict, prel_gr_dict, master, ch_copy):
  # copy_sel, copy_res, copy_rmsd = get_info_from_match_dict(
  #     match_dict,prel_gr_dict[ch_copy], ch_copy if ch_copy1 is None else ch_copy1)
  # in prel_gr_dict we want to find value with both master and ch_copy
  # return copy_sel, copy_res, m_sel
  key = None
  for v in six.itervalues(prel_gr_dict):
    if v == (master, ch_copy) or v == (ch_copy, master):
      key = v
      break
  if key is None:
    # print "  key is None, master, ch_copy", master, ch_copy
    return None, None, None
  # print "  key:", key
  [sel_1,sel_2,res_1,res_2,_,_,rmsd] = match_dict[key]
  if master == key[0]:
    return sel_2, res_2, sel_1
  else:
    return sel_1, res_1, sel_2


def make_flips_if_necessary_torsion(const_h, flip_h):
  """ 3 times faster than other (removed) procedure."""
  assert len(flip_h.models()) == 1, len(flip_h.models())
  assert len(const_h.models()) == 1, len(const_h.models())
  # const_h.write_pdb_file(file_name="const.pdb")
  # flip_h.write_pdb_file(file_name="flip.pdb")
  assert const_h.atoms_size() == flip_h.atoms_size()
  original_atoms_size = const_h.atoms_size()
  flipped_other_selection = flex.size_t([])
  ch_const = const_h.only_model().chains()
  ch_flip = flip_h.only_model().chains()
  # looks like moving residue groups when there are 2 chains with the same id
  for another_ch in ch_const[1:]:
    if another_ch.id == ch_const[0].id:
      for rg in another_ch.residue_groups():
        ch_const[0].append_residue_group(rg.detached_copy())
  for another_ch in ch_flip[1:]:
    if another_ch.id == ch_flip[0].id:
      for rg in another_ch.residue_groups():
        ch_flip[0].append_residue_group(rg.detached_copy())
  ch_c = ch_const[0]
  ch_f = ch_flip[0]
  const_h.reset_atom_i_seqs()
  flip_h.reset_atom_i_seqs()
  for residue, res_flip in zip(ch_c.residues(), ch_f.residues()):
    if (residue.resname in flippable_sidechains
        and should_be_flipped(residue, res_flip)):
      fl_atom_list = flippable_sidechains[residue.resname]
      iseqs = flex.size_t([0]*residue.atoms_size())
      for i, a in enumerate(residue.atoms()):
        try:
          ind = fl_atom_list.index(a.name)
          if ind == 3 or ind == 5:
            iseqs[i+1] = a.i_seq
          elif ind == 4 or ind == 6:
            iseqs[i-1] = a.i_seq
          else:
            iseqs[i] = a.i_seq
        except ValueError:
          iseqs[i] = a.i_seq
        except IndexError:
          if i == len(iseqs)-1:
            # this is for case where the last atom is not present
            iseqs[i] = a.i_seq
      flipped_other_selection.extend(iseqs)
    else:
      flipped_other_selection.extend(residue.atoms().extract_i_seq())
  assert flipped_other_selection.size() == original_atoms_size, "%d %d" % (
      flipped_other_selection.size(), original_atoms_size)
  # assert flipped_other_selection.size() == const_h.atoms_size()
  return flipped_other_selection

def my_selection(ph, ch_id, sel_list_extended_original):
  """custom-made selection function for selecting one
    chain - whole or parts. Speed reasons.

  Args:
      ph (_type_): hierarchy
      ch_id (str): chain id which will be selected
      sel_list_extended_original (flex.size_t): selection

  Returns:
      root: new hierarchy
  """
  # Make sure we are not changing incoming array
  sel_list_extended = sel_list_extended_original.deep_copy()
  min_iseq = sel_list_extended[0]
  new_h = None
  prev_minus = 0
  for chain in ph.only_model().chains():
    if chain.id == ch_id:
      if new_h is None:
        # append first chain and tweak selections
        new_h = new_hierarchy_from_chain(chain)
        min_iseq = chain.atoms()[0].i_seq
        sel_list_extended -= min_iseq
      else:
        # append extra chain and tweak selection
        new_start_iseq = new_h.atoms_size()
        old_start_iseq = chain.atoms()[0].i_seq - prev_minus
        dif = old_start_iseq - new_start_iseq - min_iseq
        new_h.only_model().append_chain(chain.detached_copy())
        for i in range(len(sel_list_extended)):
          if sel_list_extended[i] >= old_start_iseq-min_iseq:
            # new = old - old + new
            sel_list_extended[i] -= dif
        prev_minus += dif
  return new_h.select(sel_list_extended)

def get_match_rmsd(ph, ch_a_id,ch_b_id,list_a,list_b):
  """get RMSD of the match

  Args:
      ph (_type_): hierarchy
      ch_a_id (str): one chain id
      ch_b_id (str): another chain id
      list_a (flex.size_t): one selection
      list_b (flex.size_t): another selection

  Returns:
      rmsd, ref_sites, other_sites_best, r,t
  """
  assert len(ph.models()) == 1
  # [ch_a_id,ch_b_id,list_a,list_b] = match

  if len(list_a) == 0 or len(list_b) == 0:
    # e.g. 3liy (whole chain in AC)
    return None, None, None, None, None
  #
  # attempt to avoid selection of huge model
  # This is absolutely necessary for models of size > ~ 50 Mb in PDB format.
  # This brings runtime of this function alone for:
  # 3iyw ( 75 Mb)  88 -> 10 seconds. Total runtime  220 -> 160s.
  # 5vu2 (150 Mb) 506 -> 22 seconds. Total runtime 1067 -> 573s.
  # As one can easily see, now runtime of this function is ~N,
  # where N - size of molecule.
  # More shocking results should be expected for
  # even larger molecules (1.2Gb is currently the max).
  # At this point no hierarchy selections left in this module.
  #
  other_h = my_selection(ph, ch_a_id, list_a)
  ref_h = my_selection(ph, ch_b_id, list_b)
  #
  other_atoms = other_h.atoms()
  ref_atoms = ref_h.atoms()
  #
  # Here we want to flip atom names, even before chain alignment, so
  # we will get correct chain RMSD
  flipped_other_selection = make_flips_if_necessary_torsion(
      ref_h.deep_copy(), other_h.deep_copy())
  # if flipped_other_selection is not None:
  other_sites = other_atoms.select(flipped_other_selection).extract_xyz()
  # else:
  #   other_sites = other_atoms.extract_xyz()
  ref_sites = ref_atoms.extract_xyz()
  lsq_fit_obj = superpose.least_squares_fit(
    reference_sites = ref_sites,
    other_sites     = other_sites)
  r = lsq_fit_obj.r
  t = lsq_fit_obj.t
  # todo: find r_2*A = r*A + t (where the translation is zero)
  # use B = r*A + t, r_2*A = B , r_2 = B*A.inverse()
  other_sites_best = lsq_fit_obj.other_sites_best_fit()
  rmsd = round(ref_sites.rms_difference(other_sites_best),4)
  # print "chain rmsd after flip:", rmsd
  return rmsd, ref_sites, other_sites_best, r,t

def remove_far_atoms(list_a, list_b,
                     res_list_a,res_list_b,
                     ref_sites,other_sites,
                     residue_match_radius=4.0):
  """
  When comparing lists of matching atoms, remove residues where some atoms are
  are locally misaligned, for example when matching residues are
  perpendicular to each other rather than being close to parallel.

  The criteria used:
  For each matching residues, the difference between distance of farthest
  matching atoms pair and the distance of closest pair mast be < residue_match_radius

  Args:
    list_a, list_a (list of list): list of residues atoms
    res_list_a,res_list_b (list): list of residues in chains
    ref_sites,other_sites (flex.vec3): atoms coordinates
    residue_match_radius (float): max allow distance difference

  Returns:
    Updated arguments:
      sel_a,sel_b,
      res_list_a_new,res_list_b_new,
      ref_sites_new,other_sites_new
  """
  # check every residue for consecutive distance
  # print "list_a"
  # print list(list_a[0])
  # print "list_b", list(list_b)
  # print "res_list_a", res_list_a
  # print "res_list_b", res_list_b
  res_list_a_new = []
  res_list_b_new = []
  ref_sites_new = flex.vec3_double([])
  other_sites_new = flex.vec3_double([])
  sel_a = flex.size_t([])
  sel_b = flex.size_t([])
  current_pos = 0
  for i in range(len(res_list_a)):
    # find the matching atoms form each residue (work on small sections)
    res_len = list_a[i].size()
    res_ref_sites = ref_sites[current_pos:current_pos+res_len]
    res_other_sites = other_sites[current_pos:current_pos+res_len]
    current_pos += res_len
    xyz_diff = abs(res_ref_sites.as_double() - res_other_sites.as_double())
    (min_d,max_d,_) = xyz_diff.min_max_mean().as_tuple()
    # print "current match radius:", max_d-min_d
    if (max_d - min_d) <= residue_match_radius:
      ref_sites_new.extend(res_ref_sites)
      other_sites_new.extend(res_other_sites)
      sel_a.extend(list_a[i])
      sel_b.extend(list_b[i])
      res_list_a_new.append(res_list_a[i])
      res_list_b_new.append(res_list_b[i])
    else:
      pass
      # print ("removing poorly matching residue:",i,max_d - min_d)
  return sel_a,sel_b,res_list_a_new,res_list_b_new,ref_sites_new,other_sites_new

def search_ncs_relations(ph=None,
                         chains_info = None,
                         chain_similarity_threshold=0.85,
                         chain_max_rmsd=2.0,
                         residue_match_radius=4,
                         log=None):
  """
  Search for NCS relations between chains or parts of chains, in a protein
  hierarchy

  Args:
    ph (object): hierarchy
    chains_info (dict): values are object containing
      res_name (list of str): list of residues names
      resid (list of str): list of residues sequence number, resid
      atom_names (list of flex.str): per residue atom names
      atom_selection (list of flex.size_t()): per residue atom selections
      chains_atom_number (int): list of number of atoms in each chain

  Returns:
    msg (str): message regarding matching residues with different atom number
    match_dict(dict): key:(chains_id_a,chains_id_b)
                      val:[selection_a,selection_b,
                           res_list_a,res_list_b,rot,trans,rmsd]

  """
  assert len(ph.models()) == 1
  # print "searching ncs relations..."
  if not log: log = StringIO()
  if not chains_info:
    assert bool(ph)
    chains_info = get_chains_info(ph)
  # collect all chain IDs
  msg = ''
  sorted_ch = sorted(chains_info)

  n_chains = len(sorted_ch)
  chains_in_copies = set()
  match_dict = {}
  for i in range(n_chains-1):
    m_ch_id = sorted_ch[i]

    if m_ch_id in chains_in_copies:
      continue

    master_n_res = len(chains_info[m_ch_id].res_names)
    seq_m = chains_info[m_ch_id].res_names
    if master_n_res == 0:
      continue
    # get residue lists for master
    for j in range(i+1,n_chains):
      c_ch_id = sorted_ch[j]
      copy_n_res = len(chains_info[c_ch_id].res_names)
      # This is quick sequence similarity check
      frac_d = min(copy_n_res,master_n_res)/max(copy_n_res,master_n_res)
      if frac_d < chain_similarity_threshold:
        continue
      seq_c = chains_info[c_ch_id].res_names
      # get residue lists for copy
      res_sel_m, res_sel_c, similarity = mmtbx_res_alignment(
          seq_a=seq_m,seq_b=seq_c,
          min_percent=chain_similarity_threshold)
      sel_m, sel_c, sel_m_flat, sel_c_flat, res_sel_m,res_sel_c,new_msg = get_matching_atoms(
        chains_info,m_ch_id,c_ch_id,res_sel_m,res_sel_c)
      if len(res_sel_m) > 0 and len(res_sel_c) > 0:
        msg += new_msg
        if similarity > chain_similarity_threshold:
          rmsd, ref_sites, other_sites_best, r,t = get_match_rmsd(
              ph,m_ch_id,c_ch_id,sel_m_flat,sel_c_flat)
          if rmsd is not None and rmsd <= chain_max_rmsd:
            # get the chains atoms and convert selection to flex bool
            sel_aa,sel_bb,res_list_a,res_list_b,ref_sites,other_sites_best = \
              remove_far_atoms(
                sel_m, sel_c,
                res_sel_m,res_sel_c,
                ref_sites,other_sites_best,
                residue_match_radius=residue_match_radius)
            match_dict[m_ch_id,c_ch_id]=[sel_aa,sel_bb,res_list_a,res_list_b,r,t,rmsd]
          if rmsd < chain_max_rmsd:
            chains_in_copies.add(c_ch_id)
          # print "  good"
  # loop over all chains
  if msg:
    print(msg, file=log)
  return match_dict

def mmtbx_res_alignment(seq_a, seq_b,
                        min_percent=0.85, atomnames=False):
  # Check for the basic cases (shortcut for obvious cases)
  a = len(seq_a)
  b = len(seq_b)
  if (a == 0) or (b == 0): return [], [], 0
  if ",".join(seq_a) == ",".join(seq_b):
    return list(range(a)), list(range(a)), 1.0
  norm_seq_a = seq_a
  norm_seq_b = seq_b
  if not atomnames:
    norm_seq_a = ""
    norm_seq_b = ""
    from iotbx.pdb.amino_acid_codes import one_letter_given_three_letter, \
        one_letter_given_three_letter_modified_aa
    merged_one_given_three = one_letter_given_three_letter.copy()
    merged_one_given_three.update(one_letter_given_three_letter_modified_aa)
    merged_one_given_three.update({
        "A": "A",
        "C": "C",
        "G": "G",
        "U": "U",
        "DA": "A",
        "DC": "C",
        "DG": "G",
        "DT": "T"})
    for l in seq_a:
      one_letter = merged_one_given_three.get(l.strip(), 'X')
      norm_seq_a += one_letter
    for l in seq_b:
      one_letter = merged_one_given_three.get(l.strip(), 'X')
      norm_seq_b += one_letter
  from mmtbx.alignment import align
  # print norm_seq_a
  # STOP()
  obj = align(
      norm_seq_a,
      norm_seq_b,
      gap_opening_penalty=1, # default
      gap_extension_penalty=0.5, # default is 1
      similarity_function="identity")
  alignment = obj.extract_alignment()
  sim1 = alignment.calculate_sequence_identity()
  # print "Sequence identity is", sim1
  # alignment.pretty_print(block_size=60)
  al_a, al_b = alignment.exact_match_selections()
  # alignment.pretty_print()

  if sim1 < min_percent:
    # chains are too different, return empty arrays
    return flex.size_t([]), flex.size_t([]), sim1
  return al_a, al_b, sim1


def get_matching_atoms(chains_info,a_id,b_id,res_num_a,res_num_b):
  """
  Get selection of matching chains, match residues atoms
  We keep only residues with continuous matching atoms

  Residues with alternative locations and of different size are excluded

  Args:
    chains_info
    a_id,b_id (str): Chain IDs
    res_num_a/b (list of int): indices of matching residues position

  Returns:
    sel_a/b (list of lists): matching atoms selection
    sel_a/b_flat (list): matching atoms (sel_a/b) flattened selection -
      faster to create on the go then convert sel_a/b later. Literally:
      sel_a_flat = [x for y in sel_a for x in y].sort()
    res_num_a/b (list of int): updated res_num_a/b
    msg (str): message regarding matching residues with different atom number
  """
  sel_a = []
  sel_b = []
  sel_a_flat = flex.size_t([])
  sel_b_flat = flex.size_t([])
  # check if any of the residues has alternate locations
  a_altloc = bool(chains_info[a_id].no_altloc)
  if a_altloc:
    a_altloc = chains_info[a_id].no_altloc.count(False) > 0
  b_altloc = bool(chains_info[b_id].no_altloc)
  if b_altloc:
    b_altloc = chains_info[b_id].no_altloc.count(False) > 0
  test_altloc = a_altloc or b_altloc
  res_num_a_updated = []
  res_num_b_updated = []
  residues_with_different_n_atoms = []
  for (i,j) in zip(res_num_a,res_num_b):
    # iterate over atoms in residues
    # print "working with", i,j, chains_info[a_id].res_names[i], chains_info[a_id].resid[i], chains_info[b_id].res_names[j]
    if chains_info[a_id].res_names[i].strip() != chains_info[b_id].res_names[j].strip():
      # This is happening in rare cases when 2 chains have different ions in them.
      # All ions and exotic residues get replaced with 'X' single character for
      # alignment and can be matched with each other.
      # Filtering them out here was more targeted solution compared to changing
      # cctbx_project/mmtbx/alignment.py function identity(a, b).
      # Strip() was added because one user had RNA residue ids aligned differently,
      # e.g. skipping:  '  U' != 'U  '
      # print "skipping: ", "'%s' != '%s'" % (chains_info[a_id].res_names[i], chains_info[b_id].res_names[j])
      continue
    sa = flex.size_t(chains_info[a_id].atom_selection[i])
    sb = flex.size_t(chains_info[b_id].atom_selection[j])
    dif_res_size = sa.size() != sb.size()
    # print "sizes:", sa.size(), sb.size(),
    atoms_names_a = chains_info[a_id].atom_names[i]
    atoms_names_b = chains_info[b_id].atom_names[j]
    resid_a = chains_info[a_id].resid[i]
    altloc = False
    if test_altloc:
      if a_altloc:
        altloc |= (not chains_info[a_id].no_altloc[i])
      if b_altloc:
        altloc |= (not chains_info[b_id].no_altloc[j])
    if dif_res_size:
      # select only atoms that exist in both residues
      atoms_a,atoms_b,similarity = mmtbx_res_alignment(
        seq_a=atoms_names_a, seq_b=atoms_names_b,
        min_percent=0.2, atomnames=True)
      # get the number of the atom in the chain
      sa = flex.size_t(atoms_a) + sa[0]
      sb = flex.size_t(atoms_b) + sb[0]
    if dif_res_size or altloc:
      residues_with_different_n_atoms.append(resid_a)
      if altloc:
        sa = flex.size_t([])
        sb = flex.size_t([])
    # keep only residues with continuous matching atoms
    if sa.size() != 0 and sb.size() != 0:
      res_num_a_updated.append(i)
      res_num_b_updated.append(j)
      sel_a.append(sa)
      sel_b.append(sb)
      sel_a_flat.extend(sa)
      sel_b_flat.extend(sb)
  if residues_with_different_n_atoms:
    problem_res_nums = [x.strip() for x in residues_with_different_n_atoms]
    msg = "NCS related residues with different number of atoms, selection "
    msg += a_id + ':' + b_id + '\n['
    msg += ','.join(problem_res_nums) + ']\n'
  else:
    msg = ''

  # Not faster downstream when working with resulting arrays but keep
  # as flex.size_t
  a_perm = flex.sort_permutation(sel_a_flat)
  sel_a_flat = sel_a_flat.select(a_perm)
  b_perm = flex.sort_permutation(sel_b_flat)
  sel_b_flat = sel_b_flat.select(b_perm)
  return sel_a,sel_b,sel_a_flat,sel_b_flat,res_num_a_updated,res_num_b_updated,msg

def get_chains_info(ph, selection_list=None):
  """
  Collect information about chains or segments of the hierarchy according to
  selection strings
  Exclude water atoms
  When there are alternate conformations, we use the first one

  Args:
    ph : pdb_hierarchy

  Returns:
    chains_info (dict): values are object containing
      res_name (list of str): list of residues names
      resid (list of str): list of residues sequence number, resid
      atom_names (list of flex.str): per residue atom names
      atom_selection (list of flex.size_t()): per residue atom selections
      chains_atom_number (int): list of number of atoms in each chain
    exclude_water (bool): exclude water
  """

  chains_info =  {}
  if ph.models_size() == 0:
    return None
  # asc = ph.atom_selection_cache()
  model  = ph.models()[0]
  # build chains_info from hierarchy
  # print "in get_chains_info"
  for chain in model.chains():
    # print "ch_id", ch.id
    gr = True
    if chain.id not in chains_info:
      chains_info[chain.id] = Chains_info()
      gr = False
      # This is very time-consuming
      # ph_sel = ph.select(asc.selection("chain '%s'" % ch.id))
      # coc = flex.vec3_double([ph_sel.atoms().extract_xyz().mean()])
      # chains_info[ch.id].center_of_coordinates = coc
      chains_info[chain.id].center_of_coordinates = None
      # put the rest of the chain into it
      ch = chain.detached_copy()
      first = True
      for c in model.chains():
        if c.id == ch.id and first:
          first = False
        elif c.id == ch.id:
          for rg in c.residue_groups():
            ch.append_residue_group(rg.detached_copy())
      # Done putting the rest of the chain
      chains_info[ch.id].flat_atom_selection.extend(ch.atoms().extract_i_seq())
      chains_info[ch.id].chains_atom_number += ch.atoms_size()
      conf = ch.conformers()[0]
      len_conf = len(ch.conformers())
      # Warning devs: the following assert fails when there is no main conf
      # in a residue
      # assert len(ch.residue_groups()) == len(conf.residues())
      for rg, res in zip(ch.residue_groups(), conf.residues()):
        chains_info[ch.id].resid.append(rg.resid())
        chains_info[ch.id].res_names.append(rg.atom_groups()[0].resname)
        # atoms = res.atoms()
        atoms = rg.atom_groups()[0].atoms()
        # print "rg.atom_groups_size()", rg.atom_groups_size()
        if rg.atom_groups_size() > 1:
          present_anames = [a.name for a in atoms]
          for add_rgs in rg.atom_groups()[1:]:
            for a in add_rgs.atoms():
              # print "       getting atom '%s'" % a.name, a.name not in present_anames
              if a.name not in present_anames:
                atoms.append(a)
                present_anames.append(a.name)
        chains_info[ch.id].atom_names.append(atoms.extract_name())
        chains_info[ch.id].atom_selection.append(atoms.extract_i_seq())
        chains_info[ch.id].no_altloc.append(not rg.have_conformers() or len_conf==1)
        chains_info[ch.id].gap_residue.append(gr)
        # print ("  ", rg.id_str(), rg.have_conformers(), not res.is_pure_main_conf, "|noaltloc:", (not rg.have_conformers() or len_conf==1), "size:", atoms.size(), "gr:", gr)
        # for a in atoms:
        #   print ("    ", a.id_str())
        gr = False
  return chains_info

def my_get_rot_trans(
    ph,
    master_selection,
    copy_selection,
    master_chain_id,
    copy_chain_id):
  """
  Get rotation and translation using superpose.

  This function is used only when phil parameters are provided. In this case
  we require the selection of NCS master and copies to be correct.
  Correct means:
    1) residue sequence in master and copies is exactly the same
    2) the number of atoms in master and copies is exactly the same

  One can get exact selection strings by ncs_object.show(verbose=True)

  Args:
    ph : hierarchy
    master/copy_selection: master and copy iselections
  """

  other_h = my_selection(ph,master_chain_id, master_selection)
  ref_h = my_selection(ph,copy_chain_id, copy_selection)
  other_sites = other_h.atoms().extract_xyz()
  ref_sites = ref_h.atoms().extract_xyz()

  assert other_sites.size() == ref_sites.size(), "%d, %d" % (
      other_sites.size(), ref_sites.size())
  if ref_sites.size() > 0:
    lsq_fit_obj = superpose.least_squares_fit(
        reference_sites = ref_sites,
        other_sites     = other_sites)
    r = lsq_fit_obj.r
    t = lsq_fit_obj.t
    rmsd = ref_sites.rms_difference(lsq_fit_obj.other_sites_best_fit())
    return r,t,rmsd
  else:
    return None, None, None


 *******************************************************************************


 *******************************************************************************
mmtbx/ncs/ncs_utils.py
from __future__ import absolute_import, division, print_function
from scitbx.array_family import flex
from scitbx import matrix
import scitbx.rigid_body
from cctbx import xray
import random
import math
import mmtbx.monomer_library.server
from mmtbx.refinement.flip_peptide_side_chain import should_be_flipped, \
    flip_residue
from six.moves import zip
from six.moves import range


__author__ = 'Youval, massively rewritten by Oleg'

def flip_atoms_in_ncs_groups(hierarchy, ncs_restraints_group_list, mon_lib_srv=None):
  """
  XXX
  XXX not used, only tested. May have some value.
  XXX
  This function will actually modify hierarchy by making necessary flips
  in ncs-related residues. Flip will be made by exchanging atom coordinates.
  Will make all copies consistent with master.
  """
  if mon_lib_srv is None:
    mon_lib_srv = mmtbx.monomer_library.server.server()
  for ncs_gr in ncs_restraints_group_list:
    master_isel = ncs_gr.master_iselection
    chains_master = hierarchy.select(master_isel).only_model().chains()
    for copy in ncs_gr.copies:
      copy_isel = copy.iselection
      chains_copy = hierarchy.select(copy_isel).only_model().chains()
      for ch_m, ch_c in zip(chains_master, chains_copy):
        for r_m, r_c in zip(ch_m.residues(), ch_c.residues()):
          # print "working on ", r_m.id_str(), r_c.id_str()
          if should_be_flipped(r_m, r_c):
            flip_residue(r_c, mon_lib_srv)

def rotation_to_angles(rotation, deg=False):
  """
  Get the rotation angles around the axis x,y,z for rotation r
  Such that r = Rx*Ry*Rz
  Those angles are the Tait-Bryan angles form of Euler angles

  Note that typically there are two solutions, and this function will return
  only one. In the case that cos(beta) == 0 there are infinite number of
  solutions, the function returns the one where gamma = 0

  Args:
    r : (flex.double) of the form (Rxx,Rxy,Rxz,Ryx,Ryy,Ryz,Rzx,Rzy,Rzz)
    deg : When False use radians, when True use degrees

  Returns:
    angles (flex.double): (alpha, beta, gamma) rotation angles around the x,y,z
  """
  # make sure the rotation data type is flex.double
  if not isinstance(rotation,type(flex.double([]))):
    rotation = flex.double(rotation)
  (Rxx,Rxy,Rxz,Ryx,Ryy,Ryz,Rzx,Rzy,Rzz) = rotation.round(8)
  if Rxz not in [1,-1]:
    beta = math.asin(Rxz)
    # beta2 = math.pi - beta
    # using atan2 to take into account the possible different angles and signs
    alpha = math.atan2(-Ryz/math.cos(beta),Rzz/math.cos(beta))
    gamma = math.atan2(-Rxy/math.cos(beta),Rxx/math.cos(beta))
    # alpha2 = math.atan2(-Ryz/math.cos(beta2),Rzz/math.cos(beta2))
    # gamma2 = math.atan2(-Rxy/math.cos(beta2),Rxx/math.cos(beta2))
  elif Rxz == 1:
    beta = math.pi/2
    alpha = math.atan2(Ryx,Ryy)
    gamma = 0.0
  elif Rxz == -1:
    beta = -math.pi/2
    alpha = math.atan2(-Ryx,Ryy)
    gamma = 0.0
  else:
    raise ArithmeticError("Can't calculate rotation angles")

  angles = flex.double((alpha,beta,gamma))
  # angles2 = flex.double((alpha2,beta2,gamma2))

  if deg:
    # Convert to degrees
    angles = 180*angles/math.pi
    angles = angles.round(5)
    # angles2 = 180*angles2/math.pi
  return angles

def shake_transformations(x,
                          shake_angles_sigma      = 0.035,
                          shake_translation_sigma = 0.5):
  """
  XXX
  XXX Used here in get_weight().
  XXX Not clear what relation MTRIX have to this function at all...
  XXX

  Shake rotation matrices and translation vectors of a rotation matrices and
  translation vectors from the MTRIX records in a PDB file.

  Args:
    x (flex.double): [(alpha_1,beta_1,gamma_1,Tx_1/s,Ty_1/s,Tz_1/s)...]
    shake_angles_sigma (float): the sigma (in radians) of the random gaussian
      shaking of the rotation angles
    shake_translation_sigma (float): the sigma (in angstrom) of the random
      gaussian shaking of the translation

  Return:
    new_x (flex.double): The shaken x
  """
  new_x = flex.double([])
  for i in range(0,len(x),6):
    new_x.append(random.gauss(x[i+0],shake_angles_sigma))
    new_x.append(random.gauss(x[i+1],shake_angles_sigma))
    new_x.append(random.gauss(x[i+2],shake_angles_sigma))
    new_x.append(random.gauss(x[i+3],shake_translation_sigma))
    new_x.append(random.gauss(x[i+4],shake_translation_sigma))
    new_x.append(random.gauss(x[i+5],shake_translation_sigma))
  return new_x

def compute_transform_grad(grad_wrt_xyz,
                           xyz_asu,
                           x,
                           ncs_restraints_group_list):
  """
  XXX
  XXX Consider making it method of class_ncs_restraints_group_list
  XXX

  Compute gradient in respect to the rotation angles and the translation
  vectors. R = Rx(the)Ry(psi)Rz(phi)

  Args:
    grad_wrt_xyz (flex.double): gradients with respect to xyz.
    ncs_restraints_group_list: list containing ncs_restraint_group objects
    transforms_obj (ncs_group_object): containing information in rotation
      matrices and to which chains they apply
    xyz_asu (flex.vec3): The coordinates sites cart of the complete ASU
    x (flex double): The angles, in the form
      (theta_1,psi_1,phi_1,tx_1,ty_1,tz_1,..
      theta_n,psi_n,phi_n,tx_n/s,ty_n/s,tz_n/s)

  Returns:
    g (flex.double): the gradient
  """
  g = []
  grad_wrt_xyz = flex.vec3_double(grad_wrt_xyz)
  i = 0
  for nrg in ncs_restraints_group_list:
    xyz_ncs_transform = xyz_asu.select(nrg.master_iselection)
    xyz_len = xyz_ncs_transform.size()
    # calc the coordinates of the master NCS at its coordinates center system
    mu_c = flex.vec3_double([xyz_ncs_transform.sum()]) * (1/xyz_len)
    xyz_cm = xyz_ncs_transform - flex.vec3_double(list(mu_c) * xyz_len)
    for nrg_copy in nrg.copies:
      grad_ncs_wrt_xyz = grad_wrt_xyz.select(nrg_copy.iselection)
      assert xyz_len == grad_ncs_wrt_xyz.size()
      grad_wrt_t = list(grad_ncs_wrt_xyz.sum())
      # Sum angles gradient over the coordinates
      # Use the coordinate center for rotation
      m = grad_ncs_wrt_xyz.transpose_multiply(xyz_cm)
      m = matrix.sqr(m)
      # Calculate gradient with respect to the rotation angles
      the,psi,phi = x[i*6:i*6+3]
      rot = scitbx.rigid_body.rb_mat_xyz(
        the=the, psi=psi, phi=phi, deg=False)
      g_the = (m * rot.r_the().transpose()).trace()
      g_psi = (m * rot.r_psi().transpose()).trace()
      g_phi = (m * rot.r_phi().transpose()).trace()
      g.extend([g_the, g_psi, g_phi])
      g.extend(grad_wrt_t)
      i += 1
  return flex.double(g)

def get_weight(fmodel=None,
               restraints_manager=None,
               sites=None,
               transformations=None,
               u_iso=None,
               ncs_restraints_group_list=None,
               refine_selection=None,
               minimized_obj=None):
  """
  Calculates weights for refinements by slightly shaking the minimized
  parameters and taking the ratio:
  (restraint manager grad norm / parameters gradient norm)


  When calling this function during refinement macro cycle, the minimized
  object, "minimized_obj" , may contains fmodel, restraints_manager,
  refinement type info (sites, transformations, u_iso) and
  ncs_restraints_group_list.


  Args:
    fmodel : F-model object
    restraints_manager: Restraints manager object
    sites (bool): Refine by sites
    u_iso (bool): Refine using u_iso
    transformations (bool): Refine using transformations
      rotations, translations (matrix objects):
    ncs_restraints_group_list: list of ncs_restraint_group objects
    refine_selection (flex.size_t): selection of all ncs related copies and
      non ncs related parts to be included in selection (to be refined)
    minimized_obj:Minimization object containing all the other
      parameters above

  Returns:
    weight (int):

  Example:
  >>>get_weight(minimized_obj=minimized_obj)

  or

  >>>get_weight(fmodel=fmodel,
                restraints_manager=grm,
                sites=sites,
                transformations=transformations,
                u_iso=u_iso,
                ncs_restraints_group_list=ncs_restraints_group_list,
                refine_selection=refine_selection)
  """
  grm  = restraints_manager
  extended_ncs_selection = None
  # extract parameters from minimized_obj
  if minimized_obj:
    mo = minimized_obj
    fmodel = mo.fmodel
    grm = mo.grm
    sites = mo.sites
    transformations = mo.transformations
    u_iso = mo.u_iso
    ncs_restraints_group_list = mo.ncs_restraints_group_list
  # del: consider deleting the code below
  #   if hasattr(mo,'extended_ncs_selection'):
  #     extended_ncs_selection = mo.extended_ncs_selection
  # if not extended_ncs_selection:
  #   extended_ncs_selection = get_extended_ncs_selection(
  #     ncs_restraints_group_list=ncs_restraints_group_list,
  #     refine_selection=refine_selection)

  # make sure sufficient input is provided
  assert bool(fmodel), 'F-model is not provided'
  assert bool(grm), 'F-restraints_manager is not provided'
  assert [sites,transformations,u_iso].count(True)==1, 'Refinement type Error'
  #
  have_transforms = ncs_restraints_group_list != []
  fmdc = fmodel.deep_copy()
  if sites:
    fmdc.xray_structure.shake_sites_in_place(mean_distance=0.3)
  elif u_iso:
    fmdc.xray_structure.shake_adp()
  elif transformations and have_transforms:
    x = ncs_restraints_group_list.concatenate_rot_tran()
    x = shake_transformations(
      x = x,
      shake_angles_sigma=0.035,
      shake_translation_sigma=0.5)
  fmdc.update_xray_structure(xray_structure = fmdc.xray_structure,
    update_f_calc=True)
  fmdc.xray_structure.scatterers().flags_set_grads(state=False)
  if sites or transformations:
    xray.set_scatterer_grad_flags(
      scatterers = fmdc.xray_structure.scatterers(),
      site       = True)
    # fmodel gradients
    gxc = flex.vec3_double(fmdc.one_time_gradients_wrt_atomic_parameters(
      site = True).packed())
    # restraints manager, energy sites gradients
    gc = grm.energies_sites(
      sites_cart        = fmdc.xray_structure.sites_cart(),
      compute_gradients = True).gradients
  elif u_iso:
    # Create energies_site gradient, to create geometry_restraints_manager
    # plain_pair_sym_table needed for the energies_adp_iso
    import mmtbx.refinement.adp_refinement
    temp = mmtbx.refinement.adp_refinement.adp_restraints_master_params
    iso_restraints = temp.extract().iso
    gc = grm.energies_sites(
      sites_cart        = fmdc.xray_structure.sites_cart(),
      compute_gradients = True).gradients
    xray.set_scatterer_grad_flags(
      scatterers = fmdc.xray_structure.scatterers(),
      u_iso      = True)
    # fmodel gradients
    gxc = fmdc.one_time_gradients_wrt_atomic_parameters(
      u_iso = True).as_double()
    # manager restraints, energy sites gradients
    gc = grm.energies_adp_iso(
      xray_structure    = fmdc.xray_structure,
      parameters        = iso_restraints,
      use_u_local_only  = iso_restraints.use_u_local_only,
      use_hd            = False,
      compute_gradients = True).gradients
  if transformations and have_transforms:
    # Apply NCS relations to gradients
    gxc = compute_transform_grad(
      grad_wrt_xyz      = gxc.as_double(),
      ncs_restraints_group_list = ncs_restraints_group_list,
      xyz_asu           = fmdc.xray_structure.sites_cart(),
      x                 = x)
    gc = compute_transform_grad(
      grad_wrt_xyz      = gc.as_double(),
      ncs_restraints_group_list = ncs_restraints_group_list,
      xyz_asu           = fmdc.xray_structure.sites_cart(),
      x                 = x)

  weight = 1.
  gc_norm  = gc.norm()
  gxc_norm = gxc.norm()
  if(gxc_norm != 0.0):
    weight = gc_norm / gxc_norm

  weight =min(weight,1e6) # limit the weight max value
  return weight

def apply_transforms(ncs_coordinates,
                     ncs_restraints_group_list,
                     total_asu_length,
                     extended_ncs_selection,
                     round_coordinates = True,
                     center_of_coordinates = None):
  """
  Apply transformation to ncs_coordinates,
  and round the results if round_coordinates is True

  Args:
    ncs_coordinates (flex.vec3): master ncs coordinates
    ncs_restraints_group_list: list of ncs_restraint_group objects
    total_asu_length (int): Complete ASU length
      extended_ncs_selection (flex.size_t): master ncs and non-ncs related parts
    center_of_coordinates : when not None, contains the center of coordinate of
      the master for each ncs copy

  Returns:
    (flex.vec3_double): Asymmetric or biological unit parts that are related via
      ncs operations
  """
  asu_xyz = flex.vec3_double([(0,0,0)]*total_asu_length)
  asu_xyz.set_selected(extended_ncs_selection,ncs_coordinates)

  # get the rotation and translation for the native coordinate system
  if bool(center_of_coordinates):
    ncs_restraints_group_list = ncs_restraints_group_list.shift_translation_back_to_place(
        shifts = center_of_coordinates)
  for nrg in ncs_restraints_group_list:
    master_ncs_selection = flex.bool(total_asu_length,nrg.master_iselection)
    for ncs_copy in nrg.copies:
      copy_selection = flex.bool(total_asu_length,ncs_copy.iselection)
      ncs_xyz = asu_xyz.select(master_ncs_selection)
      new_sites = ncs_copy.r.elems * ncs_xyz + ncs_copy.t
      asu_xyz.set_selected(copy_selection,new_sites)
  if round_coordinates:
    return flex.vec3_double(asu_xyz).round(3)
  else:
    return flex.vec3_double(asu_xyz)

def selected_positions(selection,positions):
  """
  Returns only the selected indices in the positions specified in "positions"
  keeping the order

  Args:
    selection (flex.size_t): Atoms selection
    positions (set or list): the allowed positions in the selections

  Returns:
    (flex.size_t, flex.size_t): (selected atoms, atoms, not selected)

  Examples::
    >>>a = flex.size_t([1,2,5,6,4])
    >>>pos = {0,3,4}
    >>>s,d = selected_positions(a,pos)
    >>>list(s)
    [1,6,4]
    >>>list(d)
    [2,5]
  """
  assert isinstance(selection,flex.size_t)
  if isinstance(positions,set): positions = flex.size_t(list(positions))
  if isinstance(positions,list): positions = flex.size_t(positions)
  include = flex.bool(selection.size(),positions)
  not_include = ~include
  return selection.select(include), selection.select(not_include)

def remove_items_from_selection(selection,remove):
  """
  Remove a set of atoms from "selection"

  Args:
    selection (flex.size_t): atom selection
    remove (flex.size_t): atoms to remove from selection

  Returns:
    (flex.size_t): modified atom selection

  Examples::
    >>>a = flex.size_t([1,2,5,6,4])
    >>>r = flex.size_t([2,5])
    >>>s = remove_items_from_selection(a,r,10)
    >>>list(s)
    [1,6,4]
  """
  selection = list(selection)
  remove = set(remove)
  new_selection = [x for x in selection if not (x in remove)]
  return flex.size_t(new_selection)

def get_list_of_best_ncs_copy_map_correlation(
      ncs_groups,
      xray_structure=None,
      fmodel=None,
      map_data=None,
      d_min=None):
  """
  Finds the copy with best map correlation in each ncs group

  Returns:
    best_list (list of int): list of the copy with the best map correlation.
      (the master copy is 0)
  """
  assert [fmodel,d_min].count(None) in [0,1]
  assert [fmodel,map_data].count(None)==1
  assert [d_min,map_data].count(None) in [0,2]
  assert [xray_structure, fmodel].count(None)==1
  import mmtbx.maps.correlation
  best_list = []
  if(fmodel is None):
    mp = mmtbx.maps.correlation.from_map_and_xray_structure_or_fmodel(
      xray_structure = xray_structure,
      fmodel         = fmodel,
      map_data       = map_data,
      d_min          = d_min)
  else:
    mp = mmtbx.maps.correlation.from_map_and_xray_structure_or_fmodel(
      fmodel = fmodel)
  for nrg in ncs_groups:
    selections = nrg.get_iselections_list()
    cc = mp.cc(selections=selections)
    i_seq = cc.index(max(cc)) # best matching copy
    if(i_seq == 0): continue
    #
    c_i = i_seq-1
    nrg.make_nth_copy_master(c_i)

def get_refine_selection(refine_selection=None,number_of_atoms=None):
  """ populate refine_selection with all atoms if no selection is given  """
  if not bool(refine_selection):
      # select to refine all atoms
      assert bool(number_of_atoms)
      selection_list = range(number_of_atoms)
      refine_selection = flex.size_t(selection_list)
  return refine_selection


 *******************************************************************************


 *******************************************************************************
mmtbx/ncs/tncs.py
from __future__ import absolute_import, division, print_function
import cctbx.array_family.flex # import dependency
import boost_adaptbx.boost.python as bp
from six.moves import zip
from six.moves import range
ext = bp.import_ext("mmtbx_ncs_ext")
from scitbx.array_family import flex
from cctbx import sgtbx
from libtbx import adopt_init_args
from scitbx import lbfgsb
import math
import scitbx.math
from scitbx.math import matrix
import sys
from scitbx.math import superpose
import mmtbx.alignment
from libtbx.test_utils import approx_equal
from boost_adaptbx import graph
from boost_adaptbx.graph import connected_component_algorithm
import iotbx.pdb
import scitbx.minimizers

class groups(object):

  def __init__(self,
               pdb_hierarchy,
               crystal_symmetry,
               angular_difference_threshold_deg=5.,
               sequence_identity_threshold=90.,
               quiet=False):
    h = pdb_hierarchy
    superposition_threshold = 2*sequence_identity_threshold - 100.
    n_atoms_all = h.atoms_size()
    s_str = "altloc ' ' and (protein or nucleotide)"
    h = h.select(h.atom_selection_cache().selection(s_str))
    h1 = iotbx.pdb.hierarchy.root()
    h1.append_model(h.models()[0].detached_copy())
    unit_cell = crystal_symmetry.unit_cell()
    result = {}
    if not quiet:
      print("Find groups of chains related by translational NCS")
    # double loop over chains to find matching pairs related by pure translation
    for c1 in h1.chains():
      c1.parent().remove_chain(c1)
      nchains = len(h1.models()[0].chains())
      if([c1.is_protein(), c1.is_na()].count(True)==0): continue
      r1 = list(c1.residues())
      c1_seq = "".join(c1.as_sequence())
      sc_1_tmp = c1.atoms().extract_xyz()
      h1_p1 = h1.expand_to_p1(crystal_symmetry=crystal_symmetry)
      for (ii,c2) in enumerate(h1_p1.chains()):
        orig_c2 = h1.models()[0].chains()[ii%nchains]
        r2 = list(c2.residues())
        c2_seq = "".join(c2.as_sequence())
        sites_cart_1, sites_cart_2 = None,None
        sc_2_tmp = c2.atoms().extract_xyz()
        # chains are identical
        if(c1_seq==c2_seq and sc_1_tmp.size()==sc_2_tmp.size()):
          sites_cart_1 = sc_1_tmp
          sites_cart_2 = sc_2_tmp
          p_identity = 100.
        # chains are not identical, do alignment
        else:
          align_obj = mmtbx.alignment.align(seq_a = c1_seq, seq_b = c2_seq)
          alignment = align_obj.extract_alignment()
          matches = alignment.matches()
          equal = matches.count("|")
          total = len(alignment.a) - alignment.a.count("-")
          p_identity = 100.*equal/max(1,total)
          if(p_identity>superposition_threshold):
            sites_cart_1 = flex.vec3_double()
            sites_cart_2 = flex.vec3_double()
            for i1, i2, match in zip(alignment.i_seqs_a, alignment.i_seqs_b,
                                     matches):
              if(i1 is not None and i2 is not None and match=="|"):
                r1i, r2i = r1[i1], r2[i2]
                assert r1i.resname==r2i.resname, [r1i.resname,r2i.resname,i1,i2]
                for a1 in r1i.atoms():
                  for a2 in r2i.atoms():
                    if(a1.name == a2.name):
                      sites_cart_1.append(a1.xyz)
                      sites_cart_2.append(a2.xyz)
                      break
        # superpose two sequence-aligned chains
        if([sites_cart_1,sites_cart_2].count(None)==0):
          lsq_fit_obj = superpose.least_squares_fit(
            reference_sites = sites_cart_1,
            other_sites     = sites_cart_2)
          angle = lsq_fit_obj.r.rotation_angle()
          t_frac = unit_cell.fractionalize((sites_cart_1-sites_cart_2).mean())
          t_frac = [math.modf(t)[0] for t in t_frac] # put into [-1,1]
          radius = flex.sum(flex.sqrt((sites_cart_1-
            sites_cart_1.mean()).dot()))/sites_cart_1.size()*4./3.
          fracscat = min(c1.atoms_size(),c2.atoms_size())/n_atoms_all
          result.setdefault( frozenset([c1,orig_c2]), [] ).append( [p_identity,[lsq_fit_obj.r, t_frac, angle, radius, fracscat]] )
        else:
          result.setdefault( frozenset([c1,orig_c2]), [] ).append( [p_identity,None] )
    # Build graph
    g = graph.adjacency_list()
    vertex_handle = {}
    for key in result:
      seqid = result[key][0][0]
      sup = min( result[key],key=lambda s:0 if s[1] is None else s[1][2])[1]
      result[key] = [seqid,sup]
      if ((seqid > sequence_identity_threshold) and (sup[2] < angular_difference_threshold_deg)):
        (c1,c2) = key
        if (c1 not in vertex_handle):
          vertex_handle[c1] = g.add_vertex(label=c1)
        if (c2 not in vertex_handle):
          vertex_handle[c2] = g.add_vertex(label=c2)
        g.add_edge(vertex1=vertex_handle[c1],vertex2=vertex_handle[c2])
    # Do connected component analysis and compose final tNCS pairs object
    components = connected_component_algorithm.connected_components(g)
    import itertools
    self.ncs_pairs = []
    self.tncsresults = [ 0, "", [], 0.0 ]
    for (i,group) in enumerate(components):
      chains = [g.vertex_label(vertex=v) for v in group]
      fracscats = []
      radii = []
      for pair in itertools.combinations(chains,2):
        sup = result[frozenset(pair)][1]
        fracscats.append(sup[-1])
        radii.append(sup[-2])
      fs = sum(fracscats)/len(fracscats)
      self.tncsresults[3] = fs # store fracscat in array
      rad = sum(radii)/len(radii)
      #import code, traceback; code.interact(local=locals(), banner="".join( traceback.format_stack(limit=10) ) )
      maxorder = 1
      vectors = []
      previous_id = next(itertools.combinations(chains,2))[0].id
      for pair in itertools.combinations(chains,2):
        sup = result[frozenset(pair)][1]
        ncs_pair = ext.pair(
          r = sup[0],
          t = sup[1],
          radius = rad,
          radius_estimate = rad,
          fracscat = fs,
          rho_mn = flex.double(), # rho_mn undefined, needs to be set later
          id = i)
        self.ncs_pairs.append(ncs_pair)
        # show tNCS pairs in group
        fmt="group %d chains %s <> %s angle: %4.2f trans.vect.: (%s) fracscat: %5.3f"
        t = ",".join([("%6.3f"%t_).strip() for t_ in sup[1]]).strip()
        if not quiet:
          print(fmt%(i, pair[0].id, pair[1].id, sup[2], t, fs))
        if pair[0].id == previous_id:
          maxorder += 1
          orthoxyz = unit_cell.orthogonalize( sup[1] )
          vectors.append(( sup[1], orthoxyz, sup[2] ))
        else:
          previous_id = pair[0].id
          maxorder = 1
          vectors = []
        if maxorder > self.tncsresults[0]:
          self.tncsresults[0] = maxorder
          self.tncsresults[1] = previous_id
          self.tncsresults[2] = vectors
    if not quiet:
      print("Largest TNCS order, peptide chain, fracvector, orthvector, angle, fracscat = ", \
       str(self.tncsresults))
    #import code, traceback; code.interact(local=locals(), banner="".join( traceback.format_stack(limit=10) ) )

def initialize_rho_mn(ncs_pairs, d_spacings_data, binner, rms=0.5):
  """
  Initialize rho_mn
    rhoMN = exp(-(2*pi^2/3)*(rms/d)^2, and rms=0.4-0.8 is probably a good guess.
  """
  n_bins = binner.n_bins_used()
  rho_mn_initial = flex.double(n_bins, 0)
  cntr=0
  for i_bin in binner.range_used():
    sel_bin = binner.selection(i_bin)
    if(sel_bin.count(True)>0):
      arg = (2*math.pi**2/3)*(rms/flex.mean(d_spacings_data.select(sel_bin)))**2
      rho_mn_initial[cntr] = math.exp(-1*arg)
    cntr+=1
  for p in ncs_pairs:
    p.set_rhoMN(rho_mn_initial)

class potential(object):

  def __init__(self, f_obs, ncs_pairs, reflections_per_bin,
               bound_flags=None, lower_bound=None, upper_bound=None):
    adopt_init_args(self, locals())
    # Create bins
    f_obs.setup_binner(reflections_per_bin = reflections_per_bin)
    self.binner = f_obs.binner()
    n_bins = self.binner.n_bins_used()
    self.n_bins = n_bins
    self.SigmaN = None
    self.update_SigmaN()
    self.x = None
    #
    self.rbin = flex.int(f_obs.data().size(), -1)
    for i_bin in self.binner.range_used():
      for i_seq in self.binner.array_indices(i_bin):
        self.rbin[i_seq] = i_bin-1 # i_bin starts with 1, not 0 !
    assert flex.min(self.rbin)==0
    assert flex.max(self.rbin)==n_bins-1
    # Extract symmetry matrices
    self.sym_matrices = []
    for m_as_string in f_obs.space_group().smx():
      o = sgtbx.rt_mx(symbol=str(m_as_string), t_den=f_obs.space_group().t_den())
      m_as_double = o.r().as_double()
      self.sym_matrices.append(m_as_double)
    self.gradient_evaluator = None
    self.target_and_grads = ext.tncs_eps_factor_refinery(
        tncs_pairs               = self.ncs_pairs,
        f_obs                    = self.f_obs.data(),
        sigma_f_obs              = self.f_obs.sigmas(),
        rbin                     = self.rbin,
        SigmaN                   = self.SigmaN,
        space_group              = self.f_obs.space_group(),
        miller_indices           = self.f_obs.indices(),
        fractionalization_matrix = self.f_obs.unit_cell().fractionalization_matrix(),
        sym_matrices             = self.sym_matrices)

    self.update()

  def set_x(self, x):
    self.x = x

  def set_bounds(self, bound_flags, lower_bound, upper_bound):
    self.bound_flags = bound_flags
    self.lower_bound = lower_bound
    self.upper_bound = upper_bound

  def update(self, x=None):
    self.x = x
    if(self.gradient_evaluator=="rhoMN"):
      size = len(self.ncs_pairs)
      for i, ncs_pair in enumerate(self.ncs_pairs):
        ncs_pair.set_rhoMN(x[i*self.n_bins:(i+1)*self.n_bins])
      self.target_and_grads.update_pairs(self.ncs_pairs)
    elif(self.gradient_evaluator=="radius"):
      for ncs_pair, x_ in zip(self.ncs_pairs, x):
        ncs_pair.set_radius(x_)
      self.target_and_grads = ext.tncs_eps_factor_refinery(
        tncs_pairs               = self.ncs_pairs,
        f_obs                    = self.f_obs.data(),
        sigma_f_obs              = self.f_obs.sigmas(),
        rbin                     = self.rbin,
        SigmaN                   = self.SigmaN,
        space_group              = self.f_obs.space_group(),
        miller_indices           = self.f_obs.indices(),
        fractionalization_matrix = self.f_obs.unit_cell().fractionalization_matrix(),
        sym_matrices             = self.sym_matrices)
      self.target_and_grads.set_compute_gradients_radius()

  def update_SigmaN(self):
    if(self.SigmaN is None):
      eps = self.f_obs.epsilons().data().as_double()
    else:
      eps = self.target_and_grads.tncs_epsfac()
    self.SigmaN = flex.double(self.f_obs.data().size(), 0)
    for i_bin in self.binner.range_used():
      bin_sel = self.f_obs.binner().selection(i_bin)
      f_obs_bin = self.f_obs.select(bin_sel)
      f_obs_bin_data = f_obs_bin.data()
      f_obs_bin_data_size = f_obs_bin_data.size()
      if(f_obs_bin_data_size>0):
        eps_bin = eps.select(bin_sel)
        sn = flex.sum(f_obs_bin_data*f_obs_bin_data/eps_bin)/f_obs_bin_data_size
        self.SigmaN = self.SigmaN.set_selected(bin_sel, sn)
    assert self.SigmaN.all_gt(0)

  def set_refine_radius(self):
    self.gradient_evaluator = "radius"
    self.target_and_grads.set_compute_gradients_radius()
    return self

  def set_refine_rhoMN(self):
    self.gradient_evaluator = "rhoMN"
    self.target_and_grads.set_compute_gradients_rho_mn()
    return self

  def target(self):
    return self.target_and_grads.target()

  def gradients(self):
    if(self.gradient_evaluator=="rhoMN"):
      return self.target_and_grads.gradient_rhoMN()
    elif(self.gradient_evaluator=="radius"):
      return self.target_and_grads.gradient_radius()
    else: assert 0

def finite_differences_grad_radius(ncs_pairs, f_obs, reflections_per_bin,
      tolerance):
  reflections_per_bin = min(f_obs.data().size(), reflections_per_bin)
  f_obs.setup_binner(reflections_per_bin = reflections_per_bin)
  binner = f_obs.binner()
  n_bins = binner.n_bins_used()
  #
  radii = flex.double()
  for ncs_pair in ncs_pairs:
    radii.append(ncs_pair.radius)
  #
  pot = potential(f_obs = f_obs, ncs_pairs = ncs_pairs,
      reflections_per_bin = reflections_per_bin)
  pot = pot.set_refine_radius()
  t = pot.target()
  g_exact = pot.gradients()
  #print "Exact:", list(g_exact)
  #
  eps = 1.e-4
  #
  g_fd = []
  for i, rad in enumerate(radii):
    radii_p = radii.deep_copy()
    radii_m = radii.deep_copy()
    radii_p[i] = radii[i]+eps
    radii_m[i] = radii[i]-eps
    #
    pot.update(x = flex.double(radii_p))
    t1 = pot.target()
    #
    pot.update(x = flex.double(radii_m))
    t2 = pot.target()
    #
    g_fd_ = (t1-t2)/(2*eps)
    g_fd.append(g_fd_)
  #print "Finite diff.:",g_fd
  relative_error = flex.double()
  for g1,g2 in zip(g_exact, g_fd):
    #print "exact: %10.6f fd: %10.6f"%(g1,g2)
    relative_error.append( abs((g1-g2)/(g1+g2))*2.*100. )
  mmm = relative_error.min_max_mean().as_tuple()
  print("min/max/mean of |(g_exact-g_fd)/(g_exact+g_fd)|*100.*2:",\
    "%6.4f %6.4f %6.4f"%mmm)
  # assert approx_equal(mmm, [0,0,0], tolerance) # reinstate after proper constraints

def finite_differences_rho_mn(ncs_pairs, f_obs, reflections_per_bin,
      tolerance):
  reflections_per_bin = min(f_obs.data().size(), reflections_per_bin)
  f_obs.setup_binner(reflections_per_bin = reflections_per_bin)
  binner = f_obs.binner()
  n_bins = binner.n_bins_used()
  #
  pot = potential(f_obs = f_obs, ncs_pairs = ncs_pairs,
      reflections_per_bin = reflections_per_bin)
  pot = pot.set_refine_rhoMN()
  t = pot.target()
  g_exact = pot.gradients()
  #
  rho_mn = flex.double()
  for p in ncs_pairs:
    rho_mn.extend(p.rho_mn)
  #
  eps = 1.e-6
  #
  g_fd = []
  for i, rho_mn_i in enumerate(rho_mn):
    rho_mn_p = rho_mn.deep_copy()
    rho_mn_p[i] = rho_mn_i + eps
    rho_mn_m = rho_mn.deep_copy()
    rho_mn_m[i] = rho_mn_i - eps
    #
    pot.update(x = rho_mn_p)
    t1 = pot.target()
    #
    pot.update(x = rho_mn_m)
    t2 = pot.target()
    #
    g_fd_ = (t1-t2)/(2*eps)
    g_fd.append(g_fd_)
  relative_error = flex.double()
  for g1,g2 in zip(g_exact, g_fd):
    #print "exact: %10.6f fd: %10.6f"%(g1,g2)
    relative_error.append( abs((g1-g2)/(g1+g2))*2.*100. )
  mmm = relative_error.min_max_mean().as_tuple()
  print("min/max/mean of |(g_exact-g_fd)/(g_exact+g_fd)|*100.*2:",\
    "%6.4f %6.4f %6.4f"%mmm)
  # assert approx_equal(mmm, [0,0,0], tolerance) # reinstate after proper constraints

class compute_eps_factor(object):

  def __init__(self, f_obs, pdb_hierarchy, reflections_per_bin):
    f_obs = f_obs.deep_copy()
    if(not f_obs.sigmas_are_sensible()):
      f_obs.set_sigmas(sigmas = flex.double(f_obs.data().size(), 0.0))
    reflections_per_bin = min(f_obs.data().size(), reflections_per_bin)
    f_obs.setup_binner(reflections_per_bin = reflections_per_bin)
    self.unit_cell = f_obs.unit_cell()
    #
    self.ncs_pairs = groups(
      pdb_hierarchy    = pdb_hierarchy,
      crystal_symmetry = f_obs.crystal_symmetry()).ncs_pairs
    initialize_rho_mn(
      ncs_pairs       = self.ncs_pairs,
      d_spacings_data = f_obs.d_spacings().data(),
      binner          = f_obs.binner())
    self.epsfac = None
    if(len(self.ncs_pairs)>0):
      # Radii
      radii = flex.double()
      rad_lower_bound = flex.double()
      rad_upper_bound = flex.double()
      for ncs_pair in self.ncs_pairs:
        radii.append(ncs_pair.radius)
        rad_lower_bound.append(ncs_pair.radius/3)
        rad_upper_bound.append(ncs_pair.radius*3)
      # Target and gradients evaluator
      pot = potential(f_obs = f_obs, ncs_pairs = self.ncs_pairs,
        reflections_per_bin = reflections_per_bin)
      for it in range(2):
        # refine eps fac
        rho_mn = flex.double()
        for ncs_pair in self.ncs_pairs:
          rho_mn.extend(ncs_pair.rho_mn)
        pot.set_x(x = rho_mn)
        pot.set_bounds(
          bound_flags = flex.int(rho_mn.size(), 2),
          lower_bound = flex.double(rho_mn.size(), 0.),
          upper_bound = flex.double(rho_mn.size(), 1.))
        m = scitbx.minimizers.lbfgs(
           mode='lbfgsb', max_iterations=100, calculator=pot.set_refine_rhoMN())
        # refine radius
        radii = flex.double()
        for ncs_pair in self.ncs_pairs:
          radii.append(ncs_pair.radius)
        pot.set_x(x = radii)
        pot.set_bounds(
          bound_flags = flex.int(radii.size(), 2),
          lower_bound = rad_lower_bound,
          upper_bound = rad_upper_bound)
        m = scitbx.minimizers.lbfgs(
           mode='lbfgsb', max_iterations=100, calculator=pot.set_refine_radius())
      self.epsfac = pot.target_and_grads.tncs_epsfac()

  def show_summary(self, log=None):
    if(self.epsfac is None): return None
    if(log is None): log = sys.stdout
    for i, ncs_pair in enumerate(self.ncs_pairs):
      print("tNCS pair: %d"%i, file=log)
      print("  Group ID:", ncs_pair.id, file=log)
      angle = matrix.sqr(ncs_pair.r).rotation_angle()
      t = ",".join([("%6.3f"%t_).strip() for t_ in ncs_pair.t]).strip()
      t_cart = ",".join([("%6.3f"%t_).strip()
        for t_ in self.unit_cell.orthogonalize(ncs_pair.t)]).strip()
      r = ",".join([("%8.6f"%r_).strip() for r_ in ncs_pair.r]).strip()
      print("  Translation (fractional): (%s)"%t, file=log)
      print("  Translation (Cartesian):  (%s)"%t_cart, file=log)
      print("  Rotation (deg): %-5.2f"%angle, file=log)
      print("  Rotation matrix: (%s)"%r, file=log)
      print("  Radius: %-6.3f"%ncs_pair.radius, file=log)
      print("  Radius (estimate): %-6.1f"%ncs_pair.radius_estimate, file=log)
      print("  fracscat:", ncs_pair.fracscat, file=log)
    print("tNCS eps factor: min,max,mean: %6.4f %6.4f %6.4f"%\
      self.epsfac.min_max_mean().as_tuple(), file=log)

if __name__ == '__main__':
  xtal = iotbx.pdb.input(file_name= sys.argv[1] )
  hroot = xtal.construct_hierarchy()
  xtalsym = xtal.crystal_symmetry()
  groups(hroot, xtalsym, float(sys.argv[2]))


 *******************************************************************************
