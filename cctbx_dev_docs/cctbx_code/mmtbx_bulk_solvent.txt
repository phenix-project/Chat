

 *******************************************************************************
mmtbx/bulk_solvent/__init__.py
from __future__ import absolute_import, division, print_function
import cctbx.array_family.flex # import dependency

import boost_adaptbx.boost.python as bp
ext = bp.import_ext("mmtbx_bulk_solvent_ext")
from mmtbx_bulk_solvent_ext import *
from mmtbx.bulk_solvent.multi_mask_bulk_solvent import multi_mask_bulk_solvent # special import


 *******************************************************************************


 *******************************************************************************
mmtbx/bulk_solvent/bulk_solvent_and_scaling.py
from __future__ import absolute_import, division, print_function
from mmtbx import bulk_solvent
import iotbx.phil
from cctbx.array_family import flex
from cctbx import adptbx
from libtbx import group_args

import boost_adaptbx.boost.python as bp
from six.moves import range
ext = bp.import_ext("mmtbx_f_model_ext")

master_params = iotbx.phil.parse("""\
  bulk_solvent = True
    .type = bool
  anisotropic_scaling = True
    .type = bool
  k_sol_b_sol_grid_search = True
    .type = bool
    .expert_level=2
  minimization_k_sol_b_sol = True
    .type = bool
    .expert_level=2
  minimization_b_cart = True
    .type = bool
    .expert_level=2
  target = ls_wunit_k1 *ml
    .type = choice
  symmetry_constraints_on_b_cart = True
    .type = bool
    .expert_level=2
  k_sol_max = 0.6
    .type = float
    .expert_level=2
  k_sol_min = 0.0
    .type = float
    .expert_level=2
  b_sol_max = 300.0
    .type = float
    .expert_level=2
  b_sol_min = 0.0
    .type = float
    .expert_level=2
  k_sol_grid_search_max = 0.6
    .type = float
    .expert_level=2
  k_sol_grid_search_min = 0.0
    .type = float
    .expert_level=2
  b_sol_grid_search_max = 80.0
    .type = float
    .expert_level=2
  b_sol_grid_search_min = 20.0
    .type = float
    .expert_level=2
  k_sol_step = 0.2
    .type = float
    .expert_level=2
  b_sol_step = 20.0
    .type = float
    .expert_level=2
  number_of_macro_cycles = 1
    .type = int
    .expert_level=2
  max_iterations = 25
    .type = int
    .expert_level=3
  min_iterations = 25
    .type = int
    .expert_level=3
  fix_k_sol = None
    .type = float
    .expert_level=2
  fix_b_sol = None
    .type = float
    .expert_level=2
  fix_b_cart
    .expert_level=2
    .style = box
  {
    b11 = None
      .type = float
    b22 = None
      .type = float
    b33 = None
      .type = float
    b12 = None
      .type = float
    b13 = None
      .type = float
    b23 = None
      .type = float
  }
""")

def k_sol_b_sol_b_cart_minimizer(
      fmodel_kbu,
      params        = None,
      refine_k_sol  = False,
      refine_b_sol  = False,
      refine_u_star = False,
      refine_kbu    = False):
  if(params is None): params = master_params.extract()
  fmodel_core_data_work = fmodel_kbu.core_data_work()
  import mmtbx.bulk_solvent.kbu_refinery as kbu_refinery
  obj = kbu_refinery.tgc(
    f_obs   = fmodel_kbu.f_obs,
    f_calc  = fmodel_kbu.f_calc,
    f_masks = fmodel_kbu.f_masks,
    ss      = fmodel_kbu.ss,
    k_sols  = list(fmodel_core_data_work.data.k_sols()),
    b_sols  = list(fmodel_core_data_work.data.b_sols()),
    u_star  = fmodel_core_data_work.data.u_star)
  if(not refine_kbu):
    if(refine_k_sol and refine_b_sol):
      obj.set_refine_kb()
      obj.minimize_kb(use_curvatures_options=[False,True],
        n_cycles=params.number_of_macro_cycles)
    if(refine_u_star):
      obj.set_refine_u()
      obj.minimize_u(n_cycles=params.number_of_macro_cycles)
  else:
    obj.minimize_kbu(n_cycles=5)
  return obj

def _extract_fix_b_cart(fix_b_cart_scope):
  fbs = fix_b_cart_scope
  b_cart = [fbs.b11,fbs.b22,fbs.b33,fbs.b12,fbs.b13,fbs.b23]
  if(b_cart.count(None) > 0): return None
  else: return b_cart

class bulk_solvent_and_scales(object):

  def __init__(self,
               fmodel_kbu = None,
               params = None,
               log    = None):
    self.fmodel_kbu = fmodel_kbu
    start_target = self.fmodel_kbu.r_factor()
    self.params = params
    self.log = log
    if(self.params is None): self.params = master_params.extract()
    if([self.params.bulk_solvent,
        self.params.anisotropic_scaling].count(True) > 0):
      if(not self.params.bulk_solvent):
        self.params.k_sol_b_sol_grid_search = False
        self.params.minimization_k_sol_b_sol = False
      if(not self.params.anisotropic_scaling):
        self.params.minimization_b_cart = False
      params_target = self.params.target
      if(self.fmodel_kbu.check_f_mask_all_zero()):
        self.params.bulk_solvent = False
        self.params.k_sol_b_sol_grid_search = False
        self.params.minimization_k_sol_b_sol = False
      macro_cycles = list(range(1, self.params.number_of_macro_cycles+1))
      mask_ok = not self.fmodel_kbu.check_f_mask_all_zero()
      if(self.params.fix_k_sol is not None and mask_ok):
        assert self.params.bulk_solvent
        assert not self.params.k_sol_b_sol_grid_search
        assert not self.params.minimization_k_sol_b_sol
        self.fmodel_kbu.update(k_sols = self.params.fix_k_sol)
      if(self.params.fix_b_sol is not None and mask_ok):
        assert self.params.bulk_solvent
        assert not self.params.k_sol_b_sol_grid_search
        assert not self.params.minimization_k_sol_b_sol
        self.fmodel_kbu.update(b_sols = self.params.fix_b_sol)
      fix_b_cart = _extract_fix_b_cart(fix_b_cart_scope= self.params.fix_b_cart)
      if(fix_b_cart is not None):
        assert self.params.anisotropic_scaling
        assert not self.params.minimization_b_cart
        self.fmodel_kbu.update(b_cart = fix_b_cart)
      target = self.fmodel_kbu.r_factor()
      for mc in macro_cycles:
        if(self.params.k_sol_b_sol_grid_search and mc == macro_cycles[0] and
           len(self.fmodel_kbu.f_masks)==1):
          ksol,bsol,b_cart,target = self._ksol_bsol_grid_search()
          self.fmodel_kbu.update(k_sols = ksol, b_sols = bsol, b_cart = b_cart)
          assert abs(target-self.fmodel_kbu.r_factor()) < 1.e-6
        if(self.params.minimization_k_sol_b_sol):
          ksol, bsol, target = self._ksol_bsol_cart_minimizer()
          self.fmodel_kbu.update(k_sols = ksol, b_sols = bsol)
          assert abs(target-self.fmodel_kbu.r_factor())<1.e-6
        if(self.params.minimization_b_cart):
          b_cart,target = self._b_cart_minimizer()
          self.fmodel_kbu.update(b_cart = b_cart)
          assert abs(target-self.fmodel_kbu.r_factor())<1.e-6
      ksols = list(self.k_sols()[:])
      do_update = False
      for ik in range(len(ksols)):
        if(abs(ksols[ik]) < 0.01):
          ksols[ik] = 0.
          do_update = True
      if( do_update ):
        if( ksols.count(0) == len(ksols) ):
          bsol = [0.]
        if(len(ksols)>len(bsol) and len(bsol)==1):
          bsol = bsol*len(ksols)
        self.fmodel_kbu.update(k_sols = ksols, b_sols = bsol)

  def k_sols(self):
    return self.fmodel_kbu.k_sols()

  def b_sols(self):
    return self.fmodel_kbu.b_sols()

  def b_cart(self):
    return self.fmodel_kbu.b_cart()

  def format_scale_matrix(self, m=None, log=None):
    sm = m
    if(sm is None): sm = self.b_cart()
    out = log
    if(sm is None):
      print("  k_anisotropic=1", file=log)
      return
    if(len(sm)<=6):
      print("      b_cart(11,22,33,12,13,23):",\
        ",".join([str("%8.4f"%i).strip() for i in sm]), file=out)

  def u_star(self):
    return self.fmodel_kbu.u_star()

  def _ksol_bsol_grid_search(self):
    # XXX HERE
    start_r_factor = self.fmodel_kbu.r_factor()
    final_ksol   = self.fmodel_kbu.data.k_sols()
    final_bsol   = self.fmodel_kbu.data.b_sols()
    final_b_cart = self.fmodel_kbu.b_cart()
    final_r_factor = start_r_factor

    k_sols = kb_range(0.6,
                      0.0,
                      0.1)
    b_sols = kb_range(80.,
                      10,
                      5)
    assert len(self.fmodel_kbu.f_masks)==1
    o = bulk_solvent.k_sol_b_sol_k_anisotropic_scaler_twin(
      f_obs          = self.fmodel_kbu.f_obs.data(),
      f_calc         = self.fmodel_kbu.f_calc.data(),
      f_mask         = self.fmodel_kbu.f_masks[0].data(),
      ss             = self.fmodel_kbu.ss,
      k_sol_range    = flex.double(k_sols),
      b_sol_range    = flex.double(b_sols),
      miller_indices = self.fmodel_kbu.f_obs.indices(),
      r_ref          = start_r_factor)
    if(o.updated()):
      assert o.r() < start_r_factor
      final_r_factor = o.r()
      final_ksol     = o.k_sol()
      final_bsol     = o.b_sol()
      final_b_cart   = adptbx.u_as_b(adptbx.u_star_as_u_cart(
        self.fmodel_kbu.f_obs.unit_cell(), o.u_star()))
      self.fmodel_kbu.update(
        k_sols=[final_ksol],
        b_sols=[final_bsol],
        b_cart=final_b_cart)
      assert self.fmodel_kbu.r_factor() <= start_r_factor
      if(final_ksol < 0.01):
        final_ksol=0
        self.fmodel_kbu.update(
          k_sols=[final_ksol])
        final_r_factor = self.fmodel_kbu.r_factor()
      else:
        o = k_sol_b_sol_b_cart_minimizer(
          fmodel_kbu = self.fmodel_kbu,
          refine_kbu = True)
        if(o.kbu.r_factor() < final_r_factor):
          final_b_cart = adptbx.u_as_b(adptbx.u_star_as_u_cart(
            self.fmodel_kbu.f_obs.unit_cell(), o.kbu.u_star()))
          final_ksol = list(o.kbu.k_sols())
          final_bsol = list(o.kbu.b_sols())
          self.fmodel_kbu.update(
            k_sols=final_ksol,
            b_sols=final_bsol,
            b_cart=final_b_cart)
        else:
          self.fmodel_kbu.update(
            k_sols=[final_ksol],
            b_sols=[final_bsol],
            b_cart=final_b_cart)
        final_r_factor = self.fmodel_kbu.r_factor()
        assert self.fmodel_kbu.r_factor() <= start_r_factor
    self.fmodel_kbu.update(
      k_sols = final_ksol,
      b_sols = final_bsol,
      b_cart = final_b_cart)
    assert abs(self.fmodel_kbu.r_factor()-final_r_factor) < 1.e-6
    assert self.fmodel_kbu.r_factor() <= start_r_factor
    return final_ksol, final_bsol, final_b_cart, final_r_factor

  def _ksol_bsol_cart_minimizer(self):
    start_r_factor = self.fmodel_kbu.r_factor()
    final_ksol     = self.fmodel_kbu.data.k_sols()
    final_bsol     = self.fmodel_kbu.data.b_sols()
    final_r_factor = self.fmodel_kbu.r_factor()
    ksol, bsol     = self._k_sol_b_sol_minimization_helper()
    self.fmodel_kbu.update(k_sols = ksol, b_sols = bsol)
    r_factor = self.fmodel_kbu.r_factor()
    if(r_factor < final_r_factor):
      final_ksol = ksol
      final_bsol = bsol
      final_r_factor = r_factor
    assert final_r_factor <= start_r_factor
    return final_ksol, final_bsol, final_r_factor

  def r_factor(self):
    return self.fmodel_kbu.r_factor()

  def r_all(self):
    return self.r_factor()

  def _b_cart_minimizer(self):
    start_r_factor = self.fmodel_kbu.r_factor()
    final_b_cart   = self.fmodel_kbu.b_cart()
    final_r_factor = self.fmodel_kbu.r_factor()
    b_cart = self._b_cart_minimizer_helper()
    self.fmodel_kbu.update(b_cart = b_cart)
    r_factor = self.fmodel_kbu.r_factor()
    if(r_factor < final_r_factor):
      final_b_cart = b_cart
      final_r_factor = r_factor
    assert final_r_factor <= start_r_factor
    return final_b_cart, final_r_factor

  def _b_cart_minimizer_helper(self, n_macro_cycles = 1):
    r_start = self.fmodel_kbu.r_factor()
    b_start = self.fmodel_kbu.b_cart()
    for u_cycle in range(n_macro_cycles):
      u_min = k_sol_b_sol_b_cart_minimizer(
        fmodel_kbu    = self.fmodel_kbu,
        params        = self.params,
        refine_u_star = True).kbu.u_star()
      b_cart = adptbx.u_as_b(
        adptbx.u_star_as_u_cart(self.fmodel_kbu.f_obs.unit_cell(),u_min))
      self.fmodel_kbu.update(b_cart = b_cart)
    r_final = self.fmodel_kbu.r_factor()
    if(r_final >= r_start):
      self.fmodel_kbu.update(b_cart = b_start)
      return b_start
    else: return b_cart

  def _k_sol_b_sol_minimization_helper(self):
    ksol_orig = self.fmodel_kbu.data.k_sols()
    bsol_orig = self.fmodel_kbu.data.b_sols()
    r_start   = self.fmodel_kbu.r_factor()
    minimizer_obj = k_sol_b_sol_b_cart_minimizer(
      fmodel_kbu   = self.fmodel_kbu,
      params       = self.params,
      refine_k_sol = True,
      refine_b_sol = True)
    ksol = list(minimizer_obj.kbu.k_sols())
    bsol = list(minimizer_obj.kbu.b_sols())
    assert type(ksol) is list
    assert len(ksol) >= 1
    ksol = [max(self.params.k_sol_min, min(self.params.k_sol_max, v))
      for v in ksol]
    for i in range(len(bsol)):
      if(bsol[i] > self.params.b_sol_max): bsol[i] = self.params.b_sol_max
      if(bsol[i] < self.params.b_sol_min): bsol[i] = self.params.b_sol_min
    self.fmodel_kbu.update(k_sols = ksol, b_sols = bsol)
    r_end = self.fmodel_kbu.r_factor()
    if(r_end >= r_start):
      self.fmodel_kbu.update(k_sols = ksol_orig, b_sols = bsol_orig)
      return ksol_orig, bsol_orig
    else: return ksol, bsol

  def k_masks(self):
    return self.fmodel_kbu.k_masks()

  def k_anisotropic(self):
    return self.fmodel_kbu.k_anisotropic()

  def k_isotropic(self):
    return self.fmodel_kbu.k_isotropic()

  def apply_back_trace_of_overall_exp_scale_matrix(self, xray_structure=None):
    if(xray_structure is None): return None
    k_sol, b_sol, b_cart = self.k_sols(), self.b_sols(), self.b_cart()
    assert len(k_sol)==1 # XXX Only one mask!
    k_sol = k_sol[0]
    b_sol = b_sol[0]
    #
    xrs = xray_structure
    if(xrs is None): return
    b_min = min(b_sol, xrs.min_u_cart_eigenvalue()*adptbx.u_as_b(1.))
    if(b_min < 0): xrs.tidy_us()
    b_iso = (b_cart[0]+b_cart[1]+b_cart[2])/3.0
    b_test = b_min+b_iso
    if(b_test < 0.0): b_adj = b_iso + abs(b_test) + 0.001
    else: b_adj = b_iso
    b_cart_new = [b_cart[0]-b_adj,b_cart[1]-b_adj,b_cart[2]-b_adj,
                  b_cart[3],      b_cart[4],      b_cart[5]]
    b_sol_new = b_sol + b_adj
    xrs.shift_us(b_shift = b_adj)
    b_min = min(b_sol_new, xrs.min_u_cart_eigenvalue()*adptbx.u_as_b(1.))
    assert b_min >= 0.0
    xrs.tidy_us()
    #
    assert self.fmodel_kbu
    k_masks = [ext.k_mask(self.fmodel_kbu.ss, k_sol, b_sol_new)]
    u_star=adptbx.u_cart_as_u_star(
      self.fmodel_kbu.f_obs.unit_cell(), adptbx.b_as_u(b_cart_new))
    k_anisotropic = ext.k_anisotropic(self.fmodel_kbu.f_obs.indices(), u_star)
    self.fmodel_kbu = self.fmodel_kbu.update(
      b_sols = [b_sol_new],
      b_cart = b_cart_new)
    return group_args(
      xray_structure = xrs,
      b_adj          = b_adj,
      b_sol          = b_sol_new,
      b_cart         = b_cart_new)

def kb_range(x_max, x_min, step):
  sc = 1000.
  return [i/sc for i in range(int(x_min*sc), int(x_max*sc)+1, int(step*sc))]

class ksol_bsol_result(object):
  def __init__(self, k_sol, b_sol, b_cart, r_factor):
    self.k_sol = k_sol
    self.b_sol = b_sol
    self.b_cart = b_cart
    self.r_factor = r_factor


 *******************************************************************************


 *******************************************************************************
mmtbx/bulk_solvent/example.py
"""
Utility script to process bulk (model,data) pairs
"""

from __future__ import absolute_import, division, print_function
import os, sys
import iotbx.pdb
from libtbx.utils import null_out
from scitbx.array_family import flex
from iotbx import reflection_file_reader
from iotbx import reflection_file_utils
from libtbx.utils import null_out
import mmtbx.f_model
from libtbx import easy_mp
from mmtbx.bulk_solvent import mosaic
from libtbx import group_args
from libtbx.test_utils import approx_equal
from libtbx import easy_pickle
import traceback
from iotbx import extract_xtal_data

pdb_files = "/net/cci/pdb_mirror/pdb/"
hkl_files = "/net/cci-filer2/raid1/share/pdbmtz/mtz_files/"

def get_files_sorted(pdb_files, hkl_files):
  ifn_p = open("/".join([pdb_files,"INDEX"]),"r")
  ifn_r = os.listdir(hkl_files)
  pdbs  = flex.std_string()
  mtzs  = flex.std_string()
  codes = flex.std_string()
  sizes = flex.double()
  cntr=0
  for lp in ifn_p.readlines():
    lp = lp.strip()
    pdb_file_name = "/".join([pdb_files,lp])
    assert os.path.isfile(pdb_file_name)
    pdb_code = lp[-11:-7]
    #
    # FOR DEBUGGING
    #if pdb_code != "4w71": continue
    #
    #
    lr = lp.replace("pdb","r")
    hkl_file_name = "/".join([hkl_files,"%s.mtz"%pdb_code])
    if(os.path.isfile(hkl_file_name)):
      cntr+=1
      s = os.path.getsize(pdb_file_name) + os.path.getsize(hkl_file_name)
      pdbs  .append(pdb_file_name)
      mtzs  .append(hkl_file_name)
      codes .append(pdb_code)
      sizes .append(s)
      #if codes.size()==100: break
  print("Total:", cntr)
  sel = flex.sort_permutation(sizes)
  pdbs  = pdbs .select(sel)
  mtzs  = mtzs .select(sel)
  codes = codes.select(sel)
  sizes = sizes.select(sel)
  return pdbs, mtzs, codes, sizes

def get_data(pdbf, mtzf):
  pdb_inp = iotbx.pdb.input(file_name=pdbf)
  xrs = pdb_inp.xray_structure_simple()
  #
  selection = xrs.scatterers().extract_occupancies() > 0
  xrs = xrs.select(selection)
  selection = ~xrs.hd_selection()
  xrs = xrs.select(selection)
  #
  #xrs.switch_to_neutron_scattering_dictionary()
  #
  reflection_file = reflection_file_reader.any_reflection_file(
    file_name=mtzf, ensure_read_access=False)
  rfs = reflection_file_utils.reflection_file_server(
    crystal_symmetry=xrs.crystal_symmetry(),
    force_symmetry=True,
    reflection_files=[reflection_file],
    err=null_out())
  determine_data_and_flags_result = extract_xtal_data.run(
    reflection_file_server  = rfs,
    keep_going              = True,
    extract_r_free_flags    = True,
    force_non_anomalous     = True,
    allow_mismatch_flags    = True)
  f_obs        = determine_data_and_flags_result.f_obs
  r_free_flags = determine_data_and_flags_result.r_free_flags
  fmodel = mmtbx.f_model.manager(
    f_obs          = f_obs,
    r_free_flags   = r_free_flags,
    xray_structure = xrs)
  fmodel.update_all_scales(
    remove_outliers         = True,
    apply_scale_k1_to_f_obs = True
    )
  # Skip
  rw = fmodel.r_work()
  rf = fmodel.r_free()
  if(fmodel.f_obs().d_min()>3):           return None
  if(fmodel.f_obs().completeness()<0.95): return None
  if(rw>0.25):                            return None
  if(rf<=rw):                             return None
  if(abs(rf-rw)*100<2):                   return None
  if(fmodel.f_obs().resolution_filter(d_min=8).completeness()<0.95): return None
  #
  def f_obs():        return fmodel.f_obs()
  def r_free_flags(): return fmodel.r_free_flags()
  def f_calc():       return fmodel.f_calc()
  def flags():        return fmodel.r_free_flags()
  return group_args(
    f_obs          = f_obs,
    r_free_flags   = r_free_flags,
    xray_structure = fmodel.xray_structure,
    f_calc         = f_calc,
    flags          = flags)

def get_fmodel(o, f_mask, remove_outliers, log):
  fo, fm = o.f_obs().common_sets(f_mask)
  fc, fm = o.f_calc().common_sets(f_mask)

  bin_selections = fo.log_binning(
        n_reflections_in_lowest_resolution_bin = 100)

  fmodel = mmtbx.f_model.manager(
    bin_selections = bin_selections,
    f_obs        = fo,
    r_free_flags = o.r_free_flags(),
    f_calc       = fc,
    f_mask       = fm)
  fmodel.update_all_scales(
    remove_outliers         = remove_outliers,
    apply_scale_k1_to_f_obs = False
    )
  fmodel.show(show_header=False, show_approx=False, log = log)
  print(fmodel.r_factors(prefix="  "), file=log)
  mc = fmodel.electron_density_map().map_coefficients(
    map_type   = "mFobs-DFmodel",
    isotropize = True,
    exclude_free_r_reflections = False)
  return group_args(fmodel = fmodel, mc = mc)

class compute(object):
  def __init__(self, D, log):
    self.log = log
    #
    print("-"*79, file=log)
    print("A-2013, all defaults", file=log)
    step_default = min(0.8, D.f_obs().d_min()/4)
    if(step_default < 0.15): step_default = 0.15
    f_mask = mosaic.get_f_mask(
      xrs  = D.xray_structure,
      ma   = D.f_obs(),
      step = step_default)
    self.fmodel_2013 = get_fmodel(
      o = D, f_mask = f_mask, remove_outliers = False, log = self.log).fmodel
    #
    # Compute masks and F_masks (Mosaic)
    print("-"*79, file=log)
    print("Mosaic", file=log)
    self.mm = mosaic.f_masks(
      xray_structure          = D.xray_structure,
      step                    = 0.6,
      volume_cutoff           = 50,
      mean_diff_map_threshold = 0.5,
      r_sol                   = 1.1, # whole
      r_shrink                = 0.9, # whole
      f_obs                   = self.fmodel_2013.f_obs(),
      f_calc                  = self.fmodel_2013.f_calc(),
      log                     = log)
    #
    if(self.mm.do_mosaic):
      ######
      print("-"*79, file=log)
      print("A-2013, opt step/radii", file=log)
      f_mask_opt = mosaic.get_f_mask(
        xrs      = D.xray_structure,
        ma       = self.fmodel_2013.f_obs(),
        step     = 0.6,
        r_shrink = 0.9,
        r_sol    = 1.1)
      o = get_fmodel(o = self.fmodel_2013, f_mask = f_mask_opt,
        remove_outliers = False, log = self.log)
      self.fmodel_2013_opt = o.fmodel
      self.mc_whole_mask   = o.mc
      ######
      print("-"*79, file=log)
      print("A-2013, opt step/radii, using largest mask only", file=log)
      o = get_fmodel(o = self.fmodel_2013, f_mask = self.mm.f_mask_0,
        remove_outliers = False, log = self.log)
      self.fmodel_0 = o.fmodel
      self.mc_0     = o.mc

  def do_mosaic(self, alg):
    print("-"*79, file=self.log)
    print("Refine k_masks", file=self.log)
    assert approx_equal(self.fmodel_2013_opt.f_obs().data(),
      self.fmodel_0.f_obs().data())
    assert approx_equal(self.fmodel_2013_opt.f_calc().data(),
      self.fmodel_0.f_calc().data())

    if(self.fmodel_0.r_two_bins_lowest() < self.fmodel_2013_opt.r_two_bins_lowest()):
      fmodel = self.fmodel_0
    else:
      fmodel = self.fmodel_2013_opt

    result = mosaic.refinery(
      fmodel  = fmodel,
      fv      = self.mm.FV,
      alg     = alg,
      log     = self.log)
    print("", file=self.log)
    result.fmodel.show(show_header=False, show_approx=False, log = self.log)
    print(result.fmodel.r_factors(prefix="  "), file=self.log)
    return result

def get_map(mc, cg):
  fft_map = mc.fft_map(crystal_gridding = cg)
  #fft_map.apply_sigma_scaling()
  md = fft_map.real_map_unpadded()
  sd = md.sample_standard_deviation()
  #return fft_map.real_map_unpadded()
  return md/sd, sd

def map_stat(m, conn, i, map_sd):
  selection = conn==i
  blob = m.select(selection.iselection())
  mi,ma,me = flex.min(blob), flex.max(blob), flex.mean(blob)
  sd = blob.sample_standard_deviation()
  return group_args(mi=mi, ma=ma, me=me, sd=sd, map_sd=map_sd)

def run_one(args):
  pdbf, mtzf, code, alg = args
  # FILTER OUT NON-P1 and non X-ray/neutron
  pdb_inp = iotbx.pdb.input(file_name=pdbf)
  cs = pdb_inp.crystal_symmetry()
  #
  if(cs.space_group_number() != 1): return
  exp_type = pdb_inp.get_experiment_type()
  if not (exp_type.is_xray() or exp_type.is_neutron()): return
  #
  #log = sys.stdout
  log = open("%s.log"%code,"w")
  try:
    D = get_data(pdbf, mtzf)
    if(D is None):
      log.close()
      if(os.path.isfile("%s.log"%code)): os.remove("%s.log"%code)
      return
    # main
    o = compute(D=D, log=log)
    log.flush()
    ### SKIP
    if(not o.mm.do_mosaic or len(o.mm.regions.values())<1):
      log.close()
      if(os.path.isfile("%s.log"%code)): os.remove("%s.log"%code)
      return
    ###
    mbs = o.do_mosaic(alg=alg)
    # write maps
    if(o.mm.mFoDFc_0 is not None):
      mtz_dataset = o.mc_0.as_mtz_dataset(column_root_label='FistMask')
      mtz_dataset.add_miller_array(
        miller_array=o.mc_whole_mask, column_root_label="WholeMask")
      mtz_dataset.add_miller_array(
        miller_array=mbs.mc, column_root_label="Mosaic")
      mtz_object = mtz_dataset.mtz_object()
      mtz_object.write(file_name = "%s_mc.mtz"%code)
      # map stats
      map_0        , sd_map_0         = get_map(mc=o.mm.mFoDFc_0,   cg=o.mm.crystal_gridding)
      map_WholeMask, sd_map_WholeMask = get_map(mc=o.mc_whole_mask, cg=o.mm.crystal_gridding)
      map_Mosaic   , sd_map_Mosaic    = get_map(mc=mbs.mc,          cg=o.mm.crystal_gridding)
      ###
      #write_map_file(cg=o.mm.crystal_gridding, mc=o.mm.mc,         file_name="first.ccp4")
      #write_map_file(cg=o.mm.crystal_gridding, mc=o.mc_whole_mask, file_name="whole.ccp4")
      #write_map_file(cg=o.mm.crystal_gridding, mc=mbs.mc,          file_name="mosaic.ccp4")
      ###
      for region in o.mm.regions.values():
        region.m_0         = map_stat(m=map_0,         conn = o.mm.conn, i=region.id, map_sd=sd_map_0        )
        region.m_WholeMask = map_stat(m=map_WholeMask, conn = o.mm.conn, i=region.id, map_sd=sd_map_WholeMask)
        region.m_Mosaic    = map_stat(m=map_Mosaic,    conn = o.mm.conn, i=region.id, map_sd=sd_map_Mosaic   )
    #
    result = group_args(
      code            = code,
      d_min           = o.fmodel_2013.f_obs().d_min(),
      r_2013          = o.fmodel_2013.r_factors(as_string=False),
      r_2013_opt      = o.fmodel_2013_opt.r_factors(as_string=False),
      r_mosaic        = mbs.fmodel.r_factors(as_string=False),
      r_largest_mask  = o.fmodel_0.r_factors(as_string=False),
      solvent_content = o.mm.solvent_content,
      regions         = o.mm.regions)
    easy_pickle.dump("%s.pkl"%code, result)
    log.close()
  except: # intentional
    print("FAILED:", file=log)
    traceback.print_exc(file=log)
    log.close()

def write_map_file(cg, mc, file_name):
  from iotbx import mrcfile
  fft_map = mc.fft_map(crystal_gridding=cg)
  fft_map.apply_sigma_scaling()
  map_data = fft_map.real_map_unpadded()
  mrcfile.write_ccp4_map(
    file_name   = file_name,
    unit_cell   = cg.unit_cell(),
    space_group = cg.space_group(),
    map_data    = map_data,
    labels      = flex.std_string([""]))

def run(cmdargs):
  if(len(cmdargs)==1):
    alg = cmdargs[0]
    assert alg in ["alg0", "alg2", "alg4", "alg4a"]
    if alg=="None": alg=None
    NPROC=70
    pdbs, mtzs, codes, sizes = get_files_sorted(pdb_files, hkl_files)
    argss = []
    for pdb, mtz, code in zip(pdbs, mtzs, codes):
      if(os.path.isfile("%s.log"%code) and
         os.path.isfile("%s.pkl"%code) and
         os.path.isfile("%s_mc.mtz"%code)): continue
      argss.append([pdb, mtz, code, alg])
    if(NPROC>1):
      stdout_and_results = easy_mp.pool_map(
        processes    = NPROC,
        fixed_func   = run_one,
        args         = argss,
        func_wrapper = "buffer_stdout_stderr")
    else:
      for args in argss:
        run_one(args)
  else:
    assert len(cmdargs) == 3
    # Usage: python example.py 4qnn.pdb 4qnn.mtz alg4
    pdb, mtz, alg = cmdargs
    assert alg in ["alg0", "alg2", "alg4", "alg4a"]
    if alg=="None": alg=None
    assert os.path.isfile(pdb)
    assert os.path.isfile(mtz)
    code = os.path.abspath(pdb)[:-4]
    run_one([pdb, mtz, code, alg])

if (__name__ == "__main__"):
  run(sys.argv[1:])


 *******************************************************************************


 *******************************************************************************
mmtbx/bulk_solvent/example2.py
"""
Utility script to process bulk (model,data) pairs
"""

from __future__ import absolute_import, division, print_function
import os, sys
import iotbx.pdb
from scitbx.array_family import flex
import mmtbx.f_model
from libtbx import easy_mp
from mmtbx.bulk_solvent import mosaic
from mmtbx.bulk_solvent import example
from libtbx import group_args
from libtbx import easy_pickle
import traceback
from cctbx import maptbx
from mmtbx import masks
import boost_adaptbx.boost.python as bp
asu_map_ext = bp.import_ext("cctbx_asymmetric_map_ext")


from cctbx.masks import vdw_radii_from_xray_structure
ext = bp.import_ext("mmtbx_masks_ext")

pdb_files = "/net/cci/pdb_mirror/pdb/"
hkl_files = "/net/cci-filer2/raid1/share/pdbmtz/mtz_files/"

def get_files_sorted(pdb_files, hkl_files):
  ifn_p = open("/".join([pdb_files,"INDEX"]),"r")
  ifn_r = os.listdir(hkl_files)
  pdbs  = flex.std_string()
  mtzs  = flex.std_string()
  codes = flex.std_string()
  sizes = flex.double()
  cntr=0
  for lp in ifn_p.readlines():
    lp = lp.strip()
    pdb_file_name = "/".join([pdb_files,lp])
    assert os.path.isfile(pdb_file_name)
    pdb_code = lp[-11:-7]
    #
    # FOR DEBUGGING
    #if pdb_code != "4w71": continue
    #
    #
    lr = lp.replace("pdb","r")
    hkl_file_name = "/".join([hkl_files,"%s.mtz"%pdb_code])
    if(os.path.isfile(hkl_file_name)):
      cntr+=1
      s = os.path.getsize(pdb_file_name) + os.path.getsize(hkl_file_name)
      pdbs  .append(pdb_file_name)
      mtzs  .append(hkl_file_name)
      codes .append(pdb_code)
      sizes .append(s)
      #if codes.size()==100: break
  print("Total:", cntr)
  sel = flex.sort_permutation(sizes)
  pdbs  = pdbs .select(sel)
  mtzs  = mtzs .select(sel)
  codes = codes.select(sel)
  sizes = sizes.select(sel)
  return pdbs, mtzs, codes, sizes

def get_fmodel(o, f_mask, remove_outliers):
  fo, fm = o.f_obs().common_sets(f_mask)
  fc, fm = o.f_calc().common_sets(f_mask)
  fmodel = mmtbx.f_model.manager(
    f_obs  = fo,
    f_calc = fc,
    f_mask = fm)
  fmodel.update_all_scales(
    remove_outliers         = remove_outliers,
    apply_scale_k1_to_f_obs = False)
  return fmodel

class compute(object):
  def __init__(self, pdbf, mtzf):
    #
    D = example.get_data(pdbf, mtzf)
    #step = 0.4
    step = D.f_obs().d_min()/4
    #
    f_mask = mosaic.get_f_mask(
      xrs  = D.xray_structure,
      ma   = D.f_obs(),
      step = step)
    fmodel_2013 = get_fmodel(
      o = D, f_mask = f_mask, remove_outliers = True)
    fmodel_2013.show(show_header=False, show_approx=False)
    #print(fmodel_2013.r_work(d_min=11.188))
    #print(fmodel_2013.resolution_filter(d_min=11.188).r_work())
    #STOP()
    #
    rr = [0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 1.1, 1.2, 1.3, 1.4, 1.5]
    #
    r_sol_best = None
    r_best = 99999
    for r_solvent in rr:
      fmodel = try_triplet(
        xrs         = D.xray_structure,
        fmodel      = fmodel_2013,
        step        = 0.4,
        r_solvent   = 0.8,
        r_shrink    = 0.9,
        filter_mask = True)
      fmodel.show(show_header=False, show_approx=False)
      STOP()
      r = fmodel.resolution_filter(d_min=10).r_work()
      if(r<r_best):
        r_sol_best = r_solvent
        r_best = r
      print(r, r_solvent)
    print(r_sol_best)



def run_one(args):
  pdbf, mtzf, code = args
  # FILTER OUT NON-P1 and non X-ray/neutron
  pdb_inp = iotbx.pdb.input(file_name=pdbf)
  cs = pdb_inp.crystal_symmetry()
  #
  if(cs.space_group_number() != 1): return
  exp_type = pdb_inp.get_experiment_type()
  if not (exp_type.is_xray() or exp_type.is_neutron()): return

  #log = sys.stdout
  #log = open("%s.log"%code,"w")
  if 1:#try:
    # main
    o = compute(pdbf=pdbf, mtzf=mtzf)
#    #log.flush()
#    ### SKIP
#    if(not o.mm.do_mosaic or o.fmodel_2013.r_work()>0.30 or
#       len(o.mm.regions.values())<1):
#      log.close()
#      if(os.path.isfile("%s.log"%code)): os.remove("%s.log"%code)
#      return
#    ###
#    result = group_args(
#      code            = code,
#      d_min           = o.fmodel_2013.f_obs().d_min(),
#      r_2013          = o.fmodel_2013.r_factors(as_string=False),
#      r_2013_04       = o.fmodel_2013_04.r_factors(as_string=False),
#      r_filtered      = o.fmodel_filtered.r_factors(as_string=False),
#      r_mosaic        = mbs.fmodel.r_factors(as_string=False),
#      r_largest_mask  = r_largest_mask,
#      solvent_content = o.mm.solvent_content,
#      regions         = o.mm.regions)
#    easy_pickle.dump("%s.pkl"%code, result)
#    log.close()
#  except: # intentional
#    print("FAILED:", file=log)
#    traceback.print_exc(file=log)
#    log.close()

def get_mask_p1(xrs, step, r_shrink, r_solvent):
  #crystal_gridding = maptbx.crystal_gridding(
  #  unit_cell        = xrs.unit_cell(),
  #  space_group_info = xrs.space_group_info(),
  #  symmetry_flags   = maptbx.use_space_group_symmetry,
  #  step             = step)
  #n_real = crystal_gridding.n_real()
  #mask_p1 = mmtbx.masks.mask_from_xray_structure(
  #  xray_structure           = xrs,
  #  p1                       = True,
  #  for_structure_factors    = False,
  #  n_real                   = n_real,
  #  solvent_radius           = r_solvent,
  #  shrink_truncation_radius = r_shrink,
  #  in_asu                   = False).mask_data
  #maptbx.unpad_in_place(map=mask_p1)

  crystal_gridding = maptbx.crystal_gridding(
    unit_cell        = xrs.unit_cell(),
    space_group_info = xrs.space_group_info(),
    symmetry_flags   = maptbx.use_space_group_symmetry,
    step             = step)
  n_real = crystal_gridding.n_real()
  atom_radii = vdw_radii_from_xray_structure(xray_structure = xrs)
  mask_params = masks.mask_master_params.extract()
  grid_step_factor = 1.962/step
  mask_params.solvent_radius           = r_solvent
  mask_params.shrink_truncation_radius = r_shrink

  o = mmtbx.masks.bulk_solvent(
      xray_structure              = xrs,
      ignore_zero_occupancy_atoms = False,
      solvent_radius              = mask_params.solvent_radius,
      shrink_truncation_radius    = mask_params.shrink_truncation_radius,
      ignore_hydrogen_atoms       = False,
      gridding_n_real             = n_real,
      atom_radii                  = atom_radii)
  mask_p1 = o.data.as_double()
  print(mask_p1)

  return mask_p1

def try_triplet(xrs, fmodel, step, r_solvent, r_shrink, filter_mask):
  mask_p1 = get_mask_p1(
    xrs       = xrs,
    step      = step,
    r_shrink  = r_shrink,
    r_solvent = r_solvent)
  if(filter_mask):
    mask_p1 = mosaic.filter_mask(
      mask_p1          = mask_p1,
      volume_cutoff    = 100,
      crystal_symmetry = xrs.crystal_symmetry())
  mask = asu_map_ext.asymmetric_map(
    xrs.crystal_symmetry().space_group().type(), mask_p1).data()
  f_mask = fmodel.f_obs().structure_factors_from_asu_map(
    asu_map_data = mask_p1, n_real = mask_p1.accessor().all())
  fmodel = mmtbx.f_model.manager(
    f_obs          = fmodel.f_obs(),
    r_free_flags   = fmodel.r_free_flags(),
    f_calc         = fmodel.f_calc(),
    bin_selections = fmodel.bin_selections,
    f_mask         = f_mask)
  fmodel.update_all_scales(remove_outliers=False, apply_scale_k1_to_f_obs=False)
  return fmodel

def run(cmdargs):
  if(len(cmdargs)==1):
    NPROC=70
    pdbs, mtzs, codes, sizes = get_files_sorted(pdb_files, hkl_files)
    argss = []
    for pdb, mtz, code in zip(pdbs, mtzs, codes):
      argss.append([pdb, mtz, code])
    if(NPROC>1):
      stdout_and_results = easy_mp.pool_map(
        processes    = NPROC,
        fixed_func   = run_one,
        args         = argss,
        func_wrapper = "buffer_stdout_stderr")
    else:
      for args in argss:
        run_one(args)
  else:
    assert len(cmdargs) == 2
    # Usage: python example.py 4qnn.pdb 4qnn.mtz
    pdb, mtz = cmdargs
    assert os.path.isfile(pdb)
    assert os.path.isfile(mtz)
    code = os.path.abspath(pdb)[:-4]
    run_one([pdb, mtz, code])

if (__name__ == "__main__"):
  run(sys.argv[1:])


 *******************************************************************************


 *******************************************************************************
mmtbx/bulk_solvent/f_model_all_scales.py
from __future__ import absolute_import, division, print_function
from cctbx.array_family import flex
from cctbx import adptbx
from mmtbx import bulk_solvent
from cctbx.array_family import flex
from cctbx import adptbx
import mmtbx
from libtbx import group_args
import mmtbx.arrays
import mmtbx.bulk_solvent.scaler
from libtbx.test_utils import approx_equal
from libtbx.math_utils import ifloor, iceil
import mmtbx.f_model
import mmtbx.bulk_solvent.bulk_solvent_and_scaling as bss
from six.moves import zip, range

class run(mmtbx.f_model.manager):
  """
  This is a very specialized routine to perform complex protocols of updating
  all scales of fmodel, including case of twininng, presence of H and lileky
  more. Inside it pretends to be fmodel proper (done by dictionary updates
  before and after - any better ideas of how to do it nicer are welcome!).
  """

  def __init__(self,
               fmodel,
               apply_back_trace,
               remove_outliers,
               fast,
               params,
               refine_hd_scattering,
               log):
    ### Must be first thing here
    self.__dict__.update(fmodel.__dict__)
    # From this point on: self = fmodel
    ###
    russ = self.compute(apply_back_trace = apply_back_trace, remove_outliers =
      remove_outliers, fast = fast, params = params,
      refine_hd_scattering = refine_hd_scattering, log = log)
    ### Must be next to last...
    fmodel.__dict__.update(self.__dict__)
    ### ...and this one is last
    self.russ = russ

  def compute(self, apply_back_trace, remove_outliers, fast,
              params, refine_hd_scattering, log):
    assert [self.arrays.core_twin, self.twin_law].count(None) in [0,2]
    self.show(prefix = "start", log = log)
    self.reset_all_scales()
    self.show(prefix = "re-set all scales", log = log)
    if(remove_outliers and not self.twinned()):
      for iii in range(5):
        self.remove_outliers(use_model = False, log = None) # XXX
      self.show(prefix = "remove outliers", log = log)
    result = None
    if(self.twinned()):
      for cycle in range(2):
        if(log is not None): print("cycle %d:"%cycle, file=log)
        self.update_twin_fraction()
        self.show(prefix = "update twin fraction", log = log)
        result = self.update_solvent_and_scale_twin(log = log,
          refine_hd_scattering = refine_hd_scattering)
    else:
      result = self.update_solvent_and_scale_2(
        fast                 = fast,
        params               = params,
        apply_back_trace     = apply_back_trace,
        refine_hd_scattering = refine_hd_scattering,
        log                  = log)
    #XXX if(remove_outliers and not self.twinned()):
    #XXX   self.remove_outliers(use_model = True, log = None) # XXX
    if(remove_outliers and not self.twinned()):
      for iii in range(5):
        self.remove_outliers(use_model = True, log = None) # XXX
      self.show(prefix = "remove outliers", log = log)
    return result

  def reset_all_scales(self):
    size = self.f_obs().data().size()
    zero_c = flex.complex_double(size,0)
    zero_d = flex.double(size,0)
    one_d  = flex.double(size,1)
    f_part1_twin = self.f_calc_twin()
    f_part2_twin = self.f_calc_twin()
    if(f_part1_twin is not None):
      f_part1_twin = self.f_calc_twin().array(data=zero_c)
      f_part2_twin = self.f_calc_twin().array(data=zero_c)
    self.update_core(
      f_part1       = self.f_calc().array(data=zero_c),
      f_part2       = self.f_calc().array(data=zero_c),
      f_part1_twin  = f_part1_twin,
      f_part2_twin  = f_part2_twin,
      k_isotropic   = one_d,
      k_anisotropic = one_d,
      k_mask        = [zero_d]*len(self.k_masks()))

  def show(self, prefix, log, r=None):
    if(log is None): return
    if(r is None): r = self.r_all()
    m = "%24s: r(all,work,free)=%6.4f %6.4f %6.4f n_refl.: %d"%(prefix, r,
      self.r_work(), self.r_free(), self.f_obs().data().size())
    if(not self.twinned()):
      print(m, file=log)
    else:
      print(m+" twin_fraction=%4.2f"%self.twin_fraction, file=log)

  def need_to_refine_hd_scattering_contribution(self):
    if(self.xray_structure is None): return False
    refine_hd_scattering = True
    hd_selection = self.xray_structure.hd_selection()
    occ_h_all_zero = self.xray_structure.select(
      hd_selection).scatterers().extract_occupancies().all_eq(0.0) # riding H
    if(self.xray_structure.guess_scattering_type_neutron() or
       hd_selection.count(True)==0 or
       not occ_h_all_zero):
      refine_hd_scattering = False
    return refine_hd_scattering

  def update_solvent_and_scale_2(self, fast, params, apply_back_trace,
                                 refine_hd_scattering, log):
    if(params is None): params = bss.master_params.extract()
    if(self.xray_structure is not None):
      # Figure out Fcalc and Fmask based on presence of H
      hd_selection = self.xray_structure.hd_selection()
      xrs_no_h = self.xray_structure.select(~hd_selection)
      xrs_h    = self.xray_structure.select(hd_selection)
    # Create data container for scalers. If H scattering is refined then it is
    # assumed that self.f_calc() does not contain H contribution at all.
    fmodel_kbu = mmtbx.f_model.manager_kbu(
      f_obs   = self.f_obs(),
      f_calc  = self.f_calc(),
      f_masks = self.f_masks(),
      ss      = self.ss)
    # Compute k_total and k_mask using one of the two methods (anal or min).
    # Note: this intentionally ignores previously existing f_part1 and f_part2.
    #
    k_sol, b_sol, b_cart, b_adj = [None,]*4
    if(fast): # analytical
      assert len(fmodel_kbu.f_masks)==1
      result = mmtbx.bulk_solvent.scaler.run_simple(
        fmodel_kbu     = fmodel_kbu,
        r_free_flags   = self.r_free_flags(),
        bulk_solvent   = params.bulk_solvent,
        aniso_scale    = params.anisotropic_scaling,
        bin_selections = self.bin_selections)
      r_all_from_scaler = result.r_all() # must be here, before apply_back_trace
    else: # using minimization: exp solvent and scale model (k_sol,b_sol,b_cart)
      result = bss.bulk_solvent_and_scales(
        fmodel_kbu = fmodel_kbu,
        params     = params)
      k_sol, b_sol, b_cart = result.k_sols(), result.b_sols(), result.b_cart()
      r_all_from_scaler = result.r_all() # must be here, before apply_back_trace
    if(apply_back_trace and len(fmodel_kbu.f_masks)==1 and
       self.xray_structure is not None):
      o = result.apply_back_trace_of_overall_exp_scale_matrix(
        xray_structure = self.xray_structure)
      b_adj = o.b_adj
      if(not fast): b_sol, b_cart = [o.b_sol], o.b_cart
      self.update_xray_structure(
        xray_structure = o.xray_structure,
        update_f_calc  = True)
      fmodel_kbu = fmodel_kbu.update(f_calc = self.f_calc())
      self.show(prefix = "overall B=%s to atoms"%str("%7.2f"%o.b_adj).strip(),
        log = log)
    # Update self with new arrays so that H correction knows current R factor.
    # If no H to account for, then this is the final result.
    k_masks       = result.k_masks()
    k_anisotropic = result.k_anisotropic()
    k_isotropic   = result.k_isotropic()
    self.update_core(
      k_mask        = k_masks,
      k_anisotropic = k_anisotropic,
      k_isotropic   = k_isotropic)
    self.show(prefix = "bulk-solvent and scaling", log = log)
    # Consistency check
    if(not apply_back_trace):
      assert approx_equal(self.r_all(), r_all_from_scaler)
    # Add contribution from H (if present and riding). This goes to f_part2.
    kh, bh = 0, 0
    if(refine_hd_scattering and
       self.need_to_refine_hd_scattering_contribution()):
      # Obsolete previous contribution f_part2
      f_part2 = fmodel_kbu.f_calc.array(data=fmodel_kbu.f_calc.data()*0)
      self.update_core(f_part2 = f_part2)
      xrs_h = xrs_h.set_occupancies(value=1).set_b_iso(value = 0)
      f_h = self.compute_f_calc(xray_structure = xrs_h)
      # Accumulate all mask contributions: Fcalc_atoms+Fbulk_1+...+Fbulk_N
      data = fmodel_kbu.f_calc.data()
      for k_mask_, f_mask_ in zip(k_masks, fmodel_kbu.f_masks):
        data = data + k_mask_*f_mask_.data()
      f_calc_plus_f_bulk_no_scales = fmodel_kbu.f_calc.array(data = data)
      # Consistency check
      assert approx_equal(self.f_model().data(),
        f_calc_plus_f_bulk_no_scales.data()*k_isotropic*k_anisotropic)
      assert approx_equal(self.f_model_no_scales().data(),
        f_calc_plus_f_bulk_no_scales.data())
      #
      # Compute contribution from H (F_H)
      #
      # Coarse sampling
      b_mean = flex.mean(xrs_no_h.extract_u_iso_or_u_equiv())*adptbx.u_as_b(1.)
      b_min = int(max(0,b_mean)*0.5)
      b_max = int(b_mean*1.5)
      sc = 1000.
      kr=[i/sc for i in range(ifloor(0*sc), iceil(1.5*sc)+1, int(0.1*sc))]
      br=[i/sc for i in range(ifloor(b_min*sc), iceil(b_max*sc)+1, int(5.*sc))]
      o = bulk_solvent.k_sol_b_sol_k_anisotropic_scaler_twin(
        f_obs       = fmodel_kbu.f_obs.data(),
        f_calc      = f_calc_plus_f_bulk_no_scales.data(),
        f_mask      = f_h.data(),
        k_total     = k_isotropic*k_anisotropic,
        ss          = fmodel_kbu.ss,
        k_sol_range = flex.double(kr),
        b_sol_range = flex.double(br),
        r_ref       = self.r_work())
      if(o.updated()):
        f_part2 = f_h.array(data = o.k_mask()*f_h.data())
        kh, bh = o.k_sol(), o.b_sol()
        self.show(prefix = "add H (%4.2f, %6.2f)"%(kh, bh), log = log, r=o.r())
      # Fine sampling
      k_min = max(0,o.k_sol()-0.1)
      k_max = o.k_sol()+0.1
      b_min = max(0,o.b_sol()-5.)
      b_max = o.b_sol()+5.
      kr=[i/sc for i in range(ifloor(k_min*sc),iceil(k_max*sc)+1,int(0.01*sc))]
      br=[i/sc for i in range(ifloor(b_min*sc),iceil(b_max*sc)+1,int(1.*sc))]
      o = bulk_solvent.k_sol_b_sol_k_anisotropic_scaler_twin(
        f_obs       = fmodel_kbu.f_obs.data(),
        f_calc      = f_calc_plus_f_bulk_no_scales.data(),
        f_mask      = f_h.data(),
        k_total     = k_isotropic*k_anisotropic,
        ss          = fmodel_kbu.ss,
        k_sol_range = flex.double(kr),
        b_sol_range = flex.double(br),
        r_ref       = o.r())
      if(o.updated()):
        f_part2 = f_h.array(data = o.k_mask()*f_h.data())
        kh, bh = o.k_sol(), o.b_sol()
        self.show(prefix = "add H (%4.2f, %6.2f)"%(kh, bh), log = log, r=o.r())
      # THIS HELPS if fast=true is used, see how it works in reality
      #
      if(fast):
        fmodel_kbu_ = mmtbx.f_model.manager_kbu(
          f_obs   = self.f_obs(),
          f_calc  = f_calc_plus_f_bulk_no_scales,
          f_masks = [f_part2],
          ss      = self.ss)
        result = mmtbx.bulk_solvent.scaler.run_simple(
          fmodel_kbu     = fmodel_kbu_,
          r_free_flags   = self.r_free_flags(),
          bulk_solvent   = params.bulk_solvent,
          aniso_scale    = params.anisotropic_scaling,
          bin_selections = self.bin_selections)
        f_part2 = f_part2.array(data = result.core.k_mask()*f_part2.data())
        k_isotropic   = result.core.k_isotropic*result.core.k_isotropic_exp
        k_anisotropic = result.core.k_anisotropic
      # Update self with final scales
      self.update_core(
        k_mask        = k_masks,
        k_anisotropic = k_anisotropic,
        k_isotropic   = k_isotropic,
        f_part2       = f_part2)
      # Make sure what came out of scaling matches what self thinks it really is
      # It must match at least up to 1.e-6.
      self.show(prefix = "add H (%4.2f, %6.2f)"%(kh, bh), log = log)
      if(fast):
        assert approx_equal(result.r_work(), self.r_work(), 1.e-4)
      else:
        assert approx_equal(self.r_all(), o.r()), [self.r_all(), o.r()]
    return group_args(
      k_sol  = k_sol,
      b_sol  = b_sol,
      b_cart = b_cart,
      k_h    = kh,
      b_h    = bh,
      b_adj  = b_adj)

  def update_solvent_and_scale_twin(self, refine_hd_scattering, log):
    if(not self.twinned()): return
    assert len(self.f_masks()) == 1
    # Re-set all scales to unit or zero
    self.show(prefix = "update scales twin start", log = log)
    self.reset_all_scales()
    self.show(prefix = "reset f_part, k_(total,mask)", log = log)
    f_calc_data      = self.f_calc().data()
    f_calc_data_twin = self.f_calc_twin().data()
    # Initial trial set
    sc = 1000.
    ksr = [i/sc for i in range(ifloor(0*sc), iceil(0.6*sc)+1,  int(0.05*sc))]
    bsr = [i/sc for i in range(ifloor(0*sc), iceil(150.*sc)+1, int(10.*sc))]
    o_kbu_sol = bulk_solvent.k_sol_b_sol_k_anisotropic_scaler_twin(
      f_obs          = self.f_obs().data(),
      f_calc_1       = f_calc_data,
      f_calc_2       = f_calc_data_twin,
      f_mask_1       = self.arrays.core.f_masks[0].data(),
      f_mask_2       = self.arrays.core_twin.f_masks[0].data(),
      ss             = self.ss,
      twin_fraction  = self.twin_fraction,
      k_sol_range    = flex.double(ksr),
      b_sol_range    = flex.double(bsr),
      miller_indices = self.f_obs().indices(), #XXX ??? What about twin-related?
      unit_cell      = self.f_obs().unit_cell(),
      r_ref          = self.r_all())
    if(o_kbu_sol.updated()):
      self.update(
        k_mask        = o_kbu_sol.k_mask(),
        k_anisotropic = o_kbu_sol.k_anisotropic())
    # Second (finer) trial set
    k_min = max(o_kbu_sol.k_sol()-0.05, 0)
    k_max = min(o_kbu_sol.k_sol()+0.05, 0.6)
    ksr = [i/sc for i in range(ifloor(k_min*sc), iceil(k_max*sc)+1, int(0.01*sc))]
    b_min = max(o_kbu_sol.b_sol()-10, 0)
    b_max = min(o_kbu_sol.b_sol()+10, 150)
    bsr = [i/sc for i in range(ifloor(b_min*sc), iceil(b_max*sc)+1, int(1.*sc))]
    o_kbu_sol = bulk_solvent.k_sol_b_sol_k_anisotropic_scaler_twin(
      f_obs          = self.f_obs().data(),
      f_calc_1       = f_calc_data,
      f_calc_2       = f_calc_data_twin,
      f_mask_1       = self.arrays.core.f_masks[0].data(),
      f_mask_2       = self.arrays.core_twin.f_masks[0].data(),
      ss             = self.ss,
      twin_fraction  = self.twin_fraction,
      k_sol_range    = flex.double(ksr),
      b_sol_range    = flex.double(bsr),
      miller_indices = self.f_obs().indices(), #XXX ??? What about twin-related?
      unit_cell      = self.f_obs().unit_cell(),
      r_ref          = o_kbu_sol.r())
    if(o_kbu_sol.updated()):
      self.update(
        k_mask        = o_kbu_sol.k_mask(),
        k_anisotropic = o_kbu_sol.k_anisotropic())
      # Disable due to rare failures. Technically they should always match. But
      # since different routines are used tiny disagreements are possible.
      # See examples in : /net/anaconda/raid1/afonine/work/bugs/twin_refinement
      #assert approx_equal(self.r_all(), o_kbu_sol.r(), 1.e-5)
      ##############
      # use apply_back_trace in if below
      if(self.xray_structure is not None):
        o = mmtbx.bulk_solvent.scaler.tmp(
          xray_structure = self.xray_structure,
          k_anisotropic  = o_kbu_sol.k_anisotropic(),
          k_masks        = [o_kbu_sol.k_mask()],
          ss             = self.ss)
        self.update_xray_structure(
          xray_structure = o.xray_structure,
          update_f_calc  = True)
      #############
        self.update(
          k_mask        = o.k_masks,
          k_anisotropic = o.k_anisotropic)

    self.show(prefix = "bulk-solvent and scaling", log = log)
    #
    # Add contribution from H (if present and riding). This goes to f_part2.
    #
    kh, bh = 0, 0
    if(refine_hd_scattering and
       self.need_to_refine_hd_scattering_contribution()):
      hd_selection = self.xray_structure.hd_selection()
      xrs_no_h = self.xray_structure.select(~hd_selection)
      xrs_h    = self.xray_structure.select(hd_selection)
      # Accumulate all mask contributions: Fcalc_atoms+Fbulk_1+...+Fbulk_N
      data = self.f_calc().data()+self.f_masks()[0].data()*self.k_masks()[0]
      f_calc_plus_f_bulk_no_scales = self.f_calc().array(data = data)
      data = self.f_calc_twin().data()+\
        self.f_masks_twin()[0].data()*self.k_masks_twin()[0]
      f_calc_plus_f_bulk_no_scales_twin = self.f_calc_twin().array(data = data)
      # Initial FH contribution
      xrs_h = xrs_h.set_occupancies(value=1).set_b_iso(value = 0)
      f_h = self.compute_f_calc(xray_structure = xrs_h)
      f_h_twin = self.compute_f_calc(xray_structure = xrs_h,
        miller_array = self.f_calc_twin())
      # Coarse sampling
      b_mean = flex.mean(xrs_no_h.extract_u_iso_or_u_equiv())*adptbx.u_as_b(1.)
      b_min = int(max(0,b_mean)*0.5)
      b_max = int(b_mean*1.5)
      sc = 1000.
      kr=[i/sc for i in range(ifloor(0*sc), iceil(1.5*sc)+1, int(0.1*sc))]
      br=[i/sc for i in range(ifloor(b_min*sc), iceil(b_max*sc)+1, int(5.*sc))]
      obj = bulk_solvent.k_sol_b_sol_k_anisotropic_scaler_twin(
        f_obs          = self.f_obs().data(),
        f_calc_1       = f_calc_plus_f_bulk_no_scales.data(),
        f_calc_2       = f_calc_plus_f_bulk_no_scales_twin.data(),
        f_mask_1       = f_h.data(),
        f_mask_2       = f_h_twin.data(),
        ss             = self.ss,
        twin_fraction  = self.twin_fraction,
        k_sol_range    = flex.double(kr),
        b_sol_range    = flex.double(br),
        miller_indices = self.f_obs().indices(), # XXX What about twin-related?
        unit_cell      = self.f_obs().unit_cell(),
        r_ref          = self.r_work())
      if(obj.updated()):
        f_part2      = f_h.array(     data = obj.k_mask()*f_h.data())
        f_part2_twin = f_h_twin.array(data = obj.k_mask()*f_h_twin.data())
        kh, bh = obj.k_sol(), obj.b_sol()
      # Fine sampling
      k_min = max(0,obj.k_sol()-0.1)
      k_max = obj.k_sol()+0.1
      b_min = max(0,obj.b_sol()-5.)
      b_max = obj.b_sol()+5.
      kr=[i/sc for i in range(ifloor(k_min*sc),iceil(k_max*sc)+1,int(0.01*sc))]
      br=[i/sc for i in range(ifloor(b_min*sc),iceil(b_max*sc)+1,int(5.*sc))]
      obj = bulk_solvent.k_sol_b_sol_k_anisotropic_scaler_twin(
        f_obs          = self.f_obs().data(),
        f_calc_1       = f_calc_plus_f_bulk_no_scales.data(),
        f_calc_2       = f_calc_plus_f_bulk_no_scales_twin.data(),
        f_mask_1       = f_h.data(),
        f_mask_2       = f_h_twin.data(),
        ss             = self.ss,
        twin_fraction  = self.twin_fraction,
        k_sol_range    = flex.double(kr),
        b_sol_range    = flex.double(br),
        miller_indices = self.f_obs().indices(), # XXX What about twin-related?
        unit_cell      = self.f_obs().unit_cell(),
        r_ref          = obj.r())
      if(obj.updated()):
        f_part2      = f_h.array(     data = obj.k_mask()*f_h.data())
        f_part2_twin = f_h_twin.array(data = obj.k_mask()*f_h_twin.data())
        kh, bh = obj.k_sol(), obj.b_sol()
      self.update_core(
        f_part2       = f_part2,
        f_part2_twin  = f_part2_twin,
        k_anisotropic = obj.k_anisotropic())
      self.show(prefix = "add H (%4.2f, %6.2f)"%(kh, bh), log = log)
    b_cart = adptbx.u_as_b(adptbx.u_star_as_u_cart(
                             self.f_obs().unit_cell(), o_kbu_sol.u_star()))
    return group_args(
      k_sol  = o_kbu_sol.k_sol(),
      b_sol  = o_kbu_sol.b_sol(),
      b_cart = b_cart,
      k_h    = kh,
      b_h    = bh)


 *******************************************************************************


 *******************************************************************************
mmtbx/bulk_solvent/kbu_refinery.py
from __future__ import absolute_import, division, print_function
from cctbx.array_family import flex
import mmtbx.f_model
import mmtbx.f_model
from scitbx import lbfgs as scitbx_lbfgs
from libtbx import adopt_init_args
import random
from mmtbx import bulk_solvent
from six.moves import range

def lbfgs_run(target_evaluator,
              min_iterations=0,
              max_iterations=None,
              traditional_convergence_test=1,
              use_curvatures=False):
  ext = scitbx_lbfgs.ext
  minimizer = ext.minimizer(target_evaluator.n)
  minimizer.error = None
  if (traditional_convergence_test):
    is_converged = ext.traditional_convergence_test(target_evaluator.n)
  else:
    raise RuntimeError
    is_converged = ext.drop_convergence_test(min_iterations)
  try:
    icall = 0
    requests_f_and_g = True
    requests_diag = use_curvatures
    while 1:
      if (requests_f_and_g):
        icall += 1
      x, f, g, d = target_evaluator(
        requests_f_and_g=requests_f_and_g,
        requests_diag=requests_diag)
      #if (requests_diag):
      #  print "x,f,d:", tuple(x), f, tuple(d)
      #else:
      #  print "x,f:", tuple(x), f
      if (use_curvatures):
        if (d is None): d = flex.double(x.size())
        have_request = minimizer.run(x, f, g, d)
      else:
        have_request = minimizer.run(x, f, g)
      if (have_request):
        requests_f_and_g = minimizer.requests_f_and_g()
        requests_diag = minimizer.requests_diag()
        continue
      assert not minimizer.requests_f_and_g()
      assert not minimizer.requests_diag()
      if (traditional_convergence_test):
        if (minimizer.iter() >= min_iterations and is_converged(x, g)): break
      else:
        if (is_converged(f)): break
      if (max_iterations is not None and minimizer.iter() >= max_iterations):
        break
      if (use_curvatures):
        have_request = minimizer.run(x, f, g, d)
      else:
        have_request = minimizer.run(x, f, g)
      if (not have_request): break
      requests_f_and_g = minimizer.requests_f_and_g()
      requests_diag = minimizer.requests_diag()
  except RuntimeError as e:
    minimizer.error = str(e)
  minimizer.n_calls = icall
  return minimizer

class refinement_flags(object):
  def __init__(self, refine_k=False, refine_b=False, refine_kb=False,
               refine_u=False):
    adopt_init_args(self, locals())

class minimizer:

  def __init__(self, tgc, min_iterations=0, max_iterations=25):
    adopt_init_args(self, locals())
    self.x = self.tgc.x()
    self.n = self.x.size()

  def run(self, use_curvatures=0):
    self.minimizer = lbfgs_run(
      target_evaluator=self,
      min_iterations=self.min_iterations,
      max_iterations=self.max_iterations,
      use_curvatures=use_curvatures)
    self(requests_f_and_g=True, requests_diag=False)
    return self

  def __call__(self, requests_f_and_g, requests_diag):
    self.tgc.update(x=self.x)
    if (not requests_f_and_g and not requests_diag):
      requests_f_and_g = True
      requests_diag = True
    if (requests_f_and_g):
      self.f = self.tgc.target()
      self.g = self.tgc.gradients()
      self.d = None
    if (requests_diag):
      self.d = self.tgc.curvatures()
      #assert self.d.all_ne(0)
      if(self.d.all_eq(0)): self.d=None
      else:
        self.d = 1 / self.d
    return self.x, self.f, self.g, self.d

class tgc(object):
  def __init__(self,
               f_obs,
               f_calc,
               f_masks,
               ss,
               k_sols=None,
               b_sols=None,
               ps=None,
               u_star=[0,0,0,0,0,0], b_max=300, b_min=0, k_min=0.001, k_max=50):
    if(ps is not None): assert [k_sols, b_sols].count(None) == 2
    else:               assert [k_sols, b_sols].count(None) == 0
    adopt_init_args(self, locals())
    self.kbu = mmtbx.f_model.manager_kbu(
      f_obs   = self.f_obs,
      f_calc  = self.f_calc,
      f_masks = self.f_masks,
      ss      = self.ss,
      k_sols  = self.k_sols,
      b_sols  = self.b_sols,
      u_star  = self.u_star)
    self.t_g_c = None
    self.use_scale=None
    self.refine_kb=False
    self.refine_k=False
    self.refine_b=False
    self.refine_u=False
    self.refine_p=False
    self.space_group = self.f_obs.space_group()
    self.adp_constraints = self.space_group.adp_constraints()

  def set_refine_kb(self):
    self.refine_kb=True
    self.refine_u=False
    self.refine_k=False
    self.refine_b=False
    self.refine_p=False

  def set_refine_k(self):
    self.refine_k=True
    self.refine_b=False
    self.refine_kb=False
    self.refine_u=False
    self.refine_p=False

  def set_refine_b(self):
    self.refine_k=False
    self.refine_b=True
    self.refine_kb=False
    self.refine_u=False
    self.refine_p=False

  def set_refine_u(self):
    self.refine_k=False
    self.refine_b=False
    self.refine_kb=False
    self.refine_u=True
    self.refine_p=False
    u_star = self.space_group.average_u_star(u_star = self.kbu.u_star())
    self.kbu.update(u_star = u_star)
    assert self.adp_constraints.n_independent_params() <= 6

  def set_refine_p(self):
    self.refine_kb=False
    self.refine_u=False
    self.refine_k=False
    self.refine_b=False
    self.refine_p=True

  def set_use_scale(self, value):
    assert value in [True, False]
    self.use_scale=value

  def normalize(self, parameters, p_min, p_max):
    result = flex.double()
    for p in parameters:
      if(p < p_min): p = p_min
      if(p > p_max): p = p_max
      result.append(p)
    return result

  def x(self):
    if(self.refine_k):
      return self.normalize(self.kbu.k_sols(), self.k_min, self.k_max)
    if(self.refine_b):
      return self.normalize(self.kbu.b_sols(), self.b_min, self.b_max)
    if(self.refine_kb):
      x =      self.normalize(self.kbu.k_sols(), self.k_min, self.k_max)
      x.extend(self.normalize(self.kbu.b_sols(), self.b_min, self.b_max))
      return x
    if(self.refine_u):
      #return flex.double(self.kbu.u_star())
      return flex.double(
        self.adp_constraints.independent_params(self.kbu.u_star()))

  def target(self):
    return self.t_g_c.target()

  def gradients(self):
    if(self.refine_k): return self.t_g_c.grad_k_sols()
    if(self.refine_b): return self.t_g_c.grad_b_sols()
    if(self.refine_kb):
      g=self.t_g_c.grad_k_sols()
      g.extend(self.t_g_c.grad_b_sols())
      return g
    if(self.refine_u):
      #return flex.double(self.t_g_c.grad_u_star())
      return flex.double(
        self.adp_constraints.independent_gradients(all_gradients=self.t_g_c.grad_u_star()))

  def curvatures(self):
    # XXX No curvatures for u_star !
    if(self.refine_k): return self.t_g_c.curv_k_sols()
    if(self.refine_b): return self.t_g_c.curv_b_sols()
    if(self.refine_kb):
      d = self.t_g_c.curv_k_sols()
      d.extend(self.t_g_c.curv_b_sols())
      return d

  def update(self, x):
    if(self.refine_k): self.kbu.update(k_sols=x)
    if(self.refine_b): self.kbu.update(b_sols=x)
    if(self.refine_kb):
      self.kbu.update(
        k_sols=x[:len(x)//2],
        b_sols=x[len(x)//2:])
    if(self.refine_u):
      #u_star = x
      u_star = self.adp_constraints.all_params(list(x))
      self.kbu.update(u_star = list(u_star))
    if(self.use_scale):
      sc = bulk_solvent.scale(self.f_obs.data(), self.kbu.data.f_model)
    else:
      sc = 1.0
    self.t_g_c = bulk_solvent.ls_kbp_sol_u_star(
      f_model     = self.kbu.data,
      f_obs       = self.f_obs.data(),
      scale       = sc,
      kb_sol_grad = self.refine_k or self.refine_b or self.refine_kb,
      p_sol_grad  = False,
      u_star_grad = self.refine_u,
      kb_sol_curv = self.refine_k or self.refine_b or self.refine_kb,
      p_sol_curv  = False)

  def minimize_k_once(self, use_curvatures):
    self.set_refine_k()
    self.set_use_scale(value = True)
    return minimizer(tgc = self).run(use_curvatures=use_curvatures)

  def minimize_b_once(self, use_curvatures):
    self.set_refine_b()
    return minimizer(tgc = self).run(use_curvatures=use_curvatures)

  def minimize_kb_sequential(self, use_curvatures_options=[False, True],
                                    n_cycles=5):
    #print "start r:", self.kbu.r_factor()
    for use_curvatures in use_curvatures_options*n_cycles:
      self.set_use_scale(value = True)
      m = self.minimize_k_once(use_curvatures=use_curvatures)
      #print "k_sols r:", self.kbu.r_factor(), "curv:", use_curvatures
      m = self.minimize_b_once(use_curvatures=use_curvatures)
      #print "b_sols r:", self.kbu.r_factor(), "curv:", use_curvatures

  def minimize_kbu_sequential(self, use_curvatures_options=[False, True],
                                    n_cycles=5):
    #print "start r:", self.kbu.r_factor()
    for use_curvatures in use_curvatures_options*n_cycles:
      self.set_use_scale(value = True)
      m = self.minimize_k_once(use_curvatures=use_curvatures)
      #print "k_sols r:", self.kbu.r_factor(), "curv:", use_curvatures
      m = self.minimize_b_once(use_curvatures=use_curvatures)
      #print "b_sols r:", self.kbu.r_factor(), "curv:", use_curvatures
      m = self.minimize_kb_once(use_curvatures=use_curvatures)
      #print "kb_sols r:", self.kbu.r_factor(), "curv:", use_curvatures
      m = self.minimize_u_once()
      #print "u_star r:", self.kbu.r_factor(), "curv:", use_curvatures

  def minimize_kb_once(self, use_curvatures):
    self.set_refine_kb()
    return minimizer(tgc = self).run(use_curvatures=use_curvatures)

  def minimize_u_once(self):
    self.set_refine_u()
    return minimizer(tgc = self).run(use_curvatures=False)

  def minimize_u(self, n_cycles=5):
    #print "minimize_u, r:", self.kbu.r_factor()
    for it in range(n_cycles):
      start_r = self.kbu.r_factor()
      save_b_cart = self.kbu.b_cart()
      self.set_refine_u()
      self.set_use_scale(value = True)
      minimizer(tgc = self).run(use_curvatures=False)
      #print "  minimize_u, r:", self.kbu.r_factor()
      r = self.kbu.r_factor()
      bc = list(flex.abs(flex.double(self.kbu.b_cart())))
      if(r>start_r and r>1.e-2 and max(bc)>100):
        self.kbu.update(b_cart = save_b_cart)
        break

  def minimize_kb(self, use_curvatures_options,
                  set_use_scale_options=[True, False], n_cycles=5):
    #print "minimize_kb, r:", self.kbu.r_factor()
    for use_curvatures in use_curvatures_options*n_cycles:
      start_r = self.kbu.r_factor()
      save_k_sols = self.kbu.k_sols()
      save_b_sols = self.kbu.b_sols()
      #self.set_use_scale(value = random.choice(set_use_scale_options))
      self.set_use_scale(value = True)
      m = self.minimize_kb_once(use_curvatures=use_curvatures)
      r = self.kbu.r_factor()
      if(r>start_r and r>1.e-2 and (flex.min(self.kbu.k_sols())<0 or
         flex.max(self.kbu.k_sols())>1 or flex.min(self.kbu.b_sols())<0 or
         flex.max(self.kbu.k_sols())>100.)):
        self.kbu.update(k_sols = save_k_sols, b_sols = save_b_sols)
      #print "  minimize_kb, r:", self.kbu.r_factor()
#      assert m.minimizer.n_calls == m.minimizer.nfun()

  def minimize_kbu(self, n_cycles=10):
    #print "minimize_kbu start r:", self.kbu.r_factor()
    for use_curvatures in [False, True]*n_cycles:
      #print "  minimize_kbu r:", self.kbu.r_factor()
      start_r = self.kbu.r_factor()
      save_k_sols = self.kbu.k_sols()
      save_b_sols = self.kbu.b_sols()
      save_b_cart = self.kbu.b_cart()
      #self.set_use_scale(value = random.choice([True, False]))
      self.set_use_scale(value = True)
      m = self.minimize_kb_once(use_curvatures=use_curvatures)
      r = self.kbu.r_factor()
      if(r>start_r and r>1.e-2 and (flex.min(self.kbu.k_sols())<0 or
         flex.max(self.kbu.k_sols())>1 or flex.min(self.kbu.b_sols())<0 or
         flex.max(self.kbu.k_sols())>100.)):
        self.kbu.update(k_sols = save_k_sols, b_sols = save_b_sols)
#      assert m.minimizer.n_calls == m.minimizer.nfun()
      m = self.minimize_u_once()
 #     assert m.minimizer.n_calls == m.minimizer.nfun()
      r = self.kbu.r_factor()
      bc = list(flex.abs(flex.double(self.kbu.b_cart())))
      if(r>start_r and r>1.e-2 and max(bc)>100):
        self.kbu.update(b_cart = save_b_cart)
        break

  def show_k_sols(self):
    print("k_sols:", [round(k,3) for k in self.kbu.k_sols()], self.kbu.r_factor())

  def show_kbu(self):
    print("k_sols:", [round(k,3) for k in self.kbu.k_sols()])
    print("b_sols:", [round(b,3) for b in self.kbu.b_sols()])
    print("b_cart:", [round(b,3) for b in self.kbu.b_cart()])


 *******************************************************************************


 *******************************************************************************
mmtbx/bulk_solvent/mosaic.py
from __future__ import absolute_import, division, print_function
from cctbx.array_family import flex
from scitbx import matrix
import math
from libtbx import adopt_init_args
import scitbx.lbfgs
from mmtbx.bulk_solvent import kbu_refinery
from cctbx import maptbx
import mmtbx.masks
import boost_adaptbx.boost.python as bp
asu_map_ext = bp.import_ext("cctbx_asymmetric_map_ext")
from libtbx import group_args
from mmtbx import bulk_solvent
from collections import OrderedDict
import mmtbx.f_model
import sys
from libtbx.test_utils import approx_equal
from libtbx.utils import Sorry
from cctbx import miller

from mmtbx import masks
from cctbx.masks import vdw_radii_from_xray_structure
ext = bp.import_ext("mmtbx_masks_ext")
mosaic_ext = bp.import_ext("mmtbx_mosaic_ext")

from scitbx import minimizers

APPLY_SCALE_K1_TO_FOBS = False

def moving_average(x, n):
  r = []
  for i, xi in enumerate(x):
    s = 0
    cntr = 0
    for j in range(max(0,i-n), min(i+n+1, len(x))):
      s+=x[j]
      cntr+=1
    s = s/cntr
    r.append(s)
  return r

# Utilities used by algorithm 2 ------------------------------------------------

class minimizer2(object):

  def __init__(self, calculator, min_iterations=0, max_iterations=2000):
    adopt_init_args(self, locals())
    self.x = self.calculator.x
    self.n = self.x.size()
    self.cntr=0

  def run(self, use_curvatures):
    self.minimizer = kbu_refinery.lbfgs_run(
      target_evaluator=self,
      min_iterations=self.min_iterations,
      max_iterations=self.max_iterations,
      use_curvatures=use_curvatures)
    self(requests_f_and_g=True, requests_diag=use_curvatures)
    return self

  def __call__(self, requests_f_and_g, requests_diag):
    self.cntr+=1
    self.calculator.update_target_and_grads(x=self.x)
    if (not requests_f_and_g and not requests_diag):
      requests_f_and_g = True
      requests_diag = True
    if (requests_f_and_g):
      self.f = self.calculator.target()
      self.g = self.calculator.gradients()
      self.d = None
    if (requests_diag):
      self.d = self.calculator.curvatures()
      #assert self.d.all_ne(0)
      if(self.d.all_eq(0)): self.d=None
      else:
        self.d = 1 / self.d
    #print "step: %4d"%self.cntr, "target:", self.f, "params:", \
    #  " ".join(["%10.6f"%i for i in self.x]) #, math.log(self.f)
    return self.x, self.f, self.g, self.d

class tg(object):
  def __init__(self, x, i_obs, F, use_curvatures,
               bound_flags=None, lower_bound=None, upper_bound=None):
    self.x = x
    self.i_obs = i_obs
    self.F = F
    self.t = None
    self.g = None
    self.d = None
    self.bound_flags=bound_flags
    self.lower_bound=lower_bound
    self.upper_bound=upper_bound
    # Needed to do sums from small to large to prefent loss
    s = flex.sort_permutation(self.i_obs.data())
    self.i_obs = self.i_obs.select(s)
    self.F = [f.select(s) for f in self.F]
    #
    self.sum_i_obs = flex.sum(self.i_obs.data()) # needed for Python version
    self.use_curvatures=use_curvatures
    self.tgo = mosaic_ext.alg2_tg(
      F     = [f.data() for f in self.F],
      i_obs = self.i_obs.data())
    self.update_target_and_grads(x=x)

  def update(self, x):
    self.update_target_and_grads(x = x)

  def update_target_and_grads(self, x):
    self.x = x
    self.tgo.update(self.x)
    self.t = self.tgo.target()
    self.g = self.tgo.gradient()
#
# Reference implementation in Python
#    s = 1 #180/math.pi
#    i_model = flex.double(self.i_obs.data().size(),0)
#    for n, kn in enumerate(self.x):
#      for m, km in enumerate(self.x):
#        tmp = self.F[n].data()*flex.conj(self.F[m].data())
#        i_model += kn*km*flex.real(tmp)
#        #pn = self.F[n].phases().data()*s
#        #pm = self.F[m].phases().data()*s
#        #Fn = flex.abs(self.F[n].data())
#        #Fm = flex.abs(self.F[m].data())
#        #i_model += kn*km*Fn*Fm*flex.cos(pn-pm)
#    diff = i_model - self.i_obs.data()
#    #print (flex.min(diff), flex.max(diff))
#    t = flex.sum(diff*diff)/4
#    #
#    g = flex.double()
#    for j in range(len(self.F)):
#      tmp = flex.double(self.i_obs.data().size(),0)
#      for m, km in enumerate(self.x):
#        tmp += km * flex.real( self.F[j].data()*flex.conj(self.F[m].data()) )
#        #pj = self.F[j].phases().data()*s
#        #pm = self.F[m].phases().data()*s
#        #Fj = flex.abs(self.F[j].data())
#        #Fm = flex.abs(self.F[m].data())
#        #tmp += km * Fj*Fm*flex.cos(pj-pm)
#      g.append(flex.sum(diff*tmp))
#    self.t = t/self.sum_i_obs
#    self.g = g/self.sum_i_obs
#    #print (self.t,t1)
#    #print (list(self.g))
#    #print (list(g1))
#    #print ()
#    #assert approx_equal(self.t, t1, 5)
#    #assert approx_equal(self.g, g1, 1.e-6)
#
    if self.use_curvatures:
      d = flex.double()
      for j in range(len(self.F)):
        tmp1 = flex.double(self.i_obs.data().size(),0)
        tmp2 = flex.double(self.i_obs.data().size(),0)
        for m, km in enumerate(self.x):
          zz = flex.real( self.F[j].data()*flex.conj(self.F[m].data()) )
          tmp1 += km * zz
          tmp2 += zz
          #pj = self.F[j].phases().data()*s
          #pm = self.F[m].phases().data()*s
          #Fj = flex.abs(self.F[j].data())
          #Fm = flex.abs(self.F[m].data())
          #tmp += km * Fj*Fm*flex.cos(pj-pm)
        d.append(flex.sum(tmp1*tmp1 + tmp2))
      self.d=d

  def target(self): return self.t

  def gradients(self): return self.g

  def gradient(self): return self.gradients()

  def curvatures(self): return self.d/self.sum_i_obs
#-------------------------------------------------------------------------------

def write_map_file(crystal_symmetry, map_data, file_name):
  from iotbx import mrcfile
  mrcfile.write_ccp4_map(
    file_name   = file_name,
    unit_cell   = crystal_symmetry.unit_cell(),
    space_group = crystal_symmetry.space_group(),
    map_data    = map_data,
    labels      = flex.std_string([""]))

def thiken_bins(bins, n, ds):
  result = []
  group = []
  cntr = 0
  for bin in bins:
    bs = bin.count(True)
    if bs>=n and len(group)==0:
      result.append(bin)
      cntr=0
    else:
      group.append(bin)
      cntr += bs
    if cntr>=n:
      result.append(group)
      group = []
      cntr = 0
  #
  for i, r in enumerate(result):
    if(not isinstance(r, flex.bool)):
      r0 = r[0]
      for r_ in r:
        r0 = r0 | r_
      result[i] = r0
  #
  if(len(result)==0):
    result = [flex.bool(bins[0].size(), True)]
  #
  tmp=[]
  for i, bin in enumerate(result):
    ds_ = ds.select(bin)
    mi, ma = flex.min(ds_), flex.max(ds_)
    if(mi<3 and ma>=3 and len(tmp)>0):
      tmp[i-1] = tmp[i-1] | bin
    else:
      tmp.append(bin)
  result = tmp
  #
  return result

class refinery(object):
  def __init__(self, fmodel, fv, alg, log = sys.stdout):
    assert alg in ["alg0", "alg2", "alg4", "alg4a"]
    self.log             = log
    self.fv              = fv
    self.f_obs           = fmodel.f_obs()
    self.r_free_flags    = fmodel.r_free_flags()
    k_mask_overall       = fmodel.k_masks()[0]
    bin_selections_input = fmodel.bin_selections
    self.f_calc          = fmodel.f_calc()
    phase_source_init    = fmodel.f_model()
    k_total              = fmodel.k_total()
    self.F               = [self.f_calc.deep_copy()] + list(self.fv.keys())
    n_zones_start        = len(self.F)
    r4_start             = fmodel.r_work4()
    r4_best              = r4_start
    del fmodel
    self.fmodel          = None
    r4_start             = None
    r4_best              = None
    self.fmodel_best     = None
    self.n_regions       = None
    #

    #alg_save = alg

    for it in range(5):

      #if it in [0,1]:
      #  alg = "alg4a"
      #else:
      #  alg = alg_save

      #
      if(it==1):
        r4_start         = self.fmodel.r_work4()
        r4_best          = r4_start
        self.fmodel_best = self.fmodel.deep_copy()
      if(it>1):
        r4 = self.fmodel.r_work4()
        if(abs(round(r4-r4_start,4))<1.e-4):
          break
        r4_start = r4

      self._print("cycle: %2d (regions: %d)"%(it, len(self.F[1:])))
      self._print("  Region #:                  "+"".join(["%7d"%fv[f] for f in self.F[1:]]))

      f_obs   = self.f_obs.deep_copy()
      if it>0: k_total = self.fmodel.k_total()
      i_obs   = f_obs.customized_copy(data = f_obs.data()*f_obs.data())
      K_MASKS = OrderedDict()

      if(alg.endswith('a')):
        self.bin_selections = [self.f_calc.d_spacings().data()>4]
      else:
        self.bin_selections = thiken_bins(
          bins=bin_selections_input, n=50*len(self.F), ds=self.f_calc.d_spacings().data())
      for i_bin, sel in enumerate(self.bin_selections):
        d_max, d_min = f_obs.select(sel).d_max_min()
        #if d_max<3 or d_min<3: continue
        if d_max<3: continue
        bin = "  bin %2d: %5.2f-%-5.2f: "%(i_bin, d_max, d_min)
        F = [f.select(sel) for f in self.F]
        k_total_sel = k_total.select(sel)
        #
        F_scaled = [f.customized_copy(data=f.data()*k_total_sel) for f in F]
        # algorithm_0
        if(alg.startswith("alg0")):
          k_masks = algorithm_0(
            f_obs = f_obs.select(sel),
            F     = F_scaled,
            kt=k_total_sel)
        # algorithm_4
        if(alg.startswith("alg4")):
          if it==0: phase_source = phase_source_init.select(sel)
          else:     phase_source = self.fmodel.f_model().select(sel)
          k_masks = algorithm_4(
            f_obs             = self.f_obs.select(sel),
            F                 = F_scaled,
            auto_converge_eps = 0.0001,
            phase_source = phase_source)
        # algorithm_2
        if(alg.startswith("alg2")):
          k_masks = algorithm_2(
            i_obs          = i_obs.select(sel),
            F              = F_scaled,
            x              = self._get_x_init(i_bin),
            use_curvatures = False)

        self._print(bin+" ".join(["%6.2f"%k for k in k_masks]) )
        K_MASKS[sel] = [k_masks, k_masks]
      #
      if(len(self.F)==2): break # stop and fall back onto using largest mask
      #
      f_calc_data = self.f_calc.data().deep_copy()
      f_bulk_data = flex.complex_double(self.f_calc.data().size(), 0)
      k_mask_0 = None
      for sel, k_masks in zip(K_MASKS.keys(), K_MASKS.values()):
        k_masks = k_masks[0] # 1 is shifted!
        f_bulk_data_ = flex.complex_double(sel.count(True), 0)
        for i_mask, k_mask in enumerate(k_masks):
          if i_mask==0:
            f_calc_data = f_calc_data.set_selected(sel,
              f_calc_data.select(sel)*k_mask)
            k_mask_0 = k_mask
            continue
          if k_mask_0 is not None: k_mask = k_mask/k_mask_0
          f_bulk_data_ += self.F[i_mask].data().select(sel)*k_mask
        f_bulk_data = f_bulk_data.set_selected(sel,f_bulk_data_ )
      #

      #if it in [0,1]:
      #  self.update_F(K_MASKS, cutoff=0)
      #else:
      #  self.update_F(K_MASKS, cutoff=0.03)
      self.update_F(K_MASKS, cutoff=0.03)


      f_bulk = self.f_calc.customized_copy(data = f_bulk_data)

      if(len(self.F)==2):
        self.fmodel = mmtbx.f_model.manager(
          f_obs          = self.f_obs,
          r_free_flags   = self.r_free_flags,
          f_calc         = self.f_calc,
          f_mask         = self.F[1],
          k_mask         = flex.double(f_obs.data().size(),1)
          )
        self.fmodel.update_all_scales(remove_outliers=False,
          apply_scale_k1_to_f_obs = APPLY_SCALE_K1_TO_FOBS)
        self._print(self.fmodel.r_factors(prefix="  "))
      else:
        self.fmodel = mmtbx.f_model.manager(
          f_obs          = self.f_obs,
          r_free_flags   = self.r_free_flags,
          #f_calc         = self.f_obs.customized_copy(data = f_calc_data),
          f_calc         = self.f_calc,
          bin_selections = bin_selections_input,
          #bin_selections = self.bin_selections,
          f_mask         = f_bulk,
          k_mask         = flex.double(f_obs.data().size(),1)
          )
        self.fmodel.update_all_scales(remove_outliers=False,
          apply_scale_k1_to_f_obs = APPLY_SCALE_K1_TO_FOBS)
        #
        self.fmodel = mmtbx.f_model.manager(
          f_obs          = self.f_obs,
          r_free_flags   = self.r_free_flags,
          #f_calc         = self.f_obs.customized_copy(data = f_calc_data),
          bin_selections = bin_selections_input,
          f_calc         = self.fmodel.f_calc(),
          f_mask         = self.fmodel.f_bulk(),
          k_mask         = flex.double(f_obs.data().size(),1)
          )
        self.fmodel.update_all_scales(remove_outliers=False,
          apply_scale_k1_to_f_obs = APPLY_SCALE_K1_TO_FOBS)
        self._print(self.fmodel.r_factors(prefix="  "))
      #
      r4 = self.fmodel.r_work4()
      if(r4_best is not None and r4<=r4_best):
        r4_best = r4
        self.fmodel_best = self.fmodel.deep_copy()
    #
    self.fmodel = self.fmodel_best
    self.n_regions = len(self.F)-1


  #def update_k_masks(self, K_MASKS):
  #  tmp = []
  #  for i_mask, F in enumerate(self.F):
  #    k_masks = [k_masks_bin[i_mask] for k_masks_bin in K_MASKS.values()]
  #    found = False
  #    for i_bin, k_masks_bin in enumerate(K_MASKS.values()):
  #      if(not found and k_masks_bin[i_mask]<=0.009):
  #        found = True
  #        K_MASKS.values()[i_bin][i_mask]=0
  #      elif found:
  #        K_MASKS.values()[i_bin][i_mask]=0

  def _print(self, m):
    if(self.log is not None):
      print(m, file=self.log)

  def update_F(self, K_MASKS, cutoff=0.03):
    tmp = []
    for i_mask, F in enumerate(self.F):
      k_masks = [k_masks_bin[1][i_mask] for k_masks_bin in K_MASKS.values()]
      #print(i_mask, flex.mean(flex.double(k_masks)), [round(i,2) for i in k_masks])
      if(i_mask == 0):                        tmp.append(self.F[0])
      #elif moving_average(k_masks,2)[0]>=cutoff: tmp.append(F)
      elif flex.mean(flex.double(k_masks))>0.01: tmp.append(F)
      self.F = tmp[:]

  def _get_x_init(self, i_bin):
    return flex.double([1] + [1]*len(self.F[1:]))
    #k_maks1_init = 0.35 - i_bin*0.35/len(self.bin_selections)
    #x = flex.double([1,k_maks1_init])
    #x.extend( flex.double(len(self.F)-2, 0.1))
    #return x

def get_f_mask(xrs, ma, step, option = 2, r_shrink = None, r_sol = None):
  #
  result = ma.deep_copy()
  sel = ma.d_spacings().data()>=3
  ma = ma.select(sel)
  #
  crystal_gridding = maptbx.crystal_gridding(
    unit_cell        = xrs.unit_cell(),
    space_group_info = xrs.space_group_info(),
    symmetry_flags   = maptbx.use_space_group_symmetry,
    step             = step)
  n_real = crystal_gridding.n_real()
  atom_radii = vdw_radii_from_xray_structure(xray_structure = xrs)
  mask_params = masks.mask_master_params.extract()
  grid_step_factor = ma.d_min()/step
  if(r_shrink is not None): mask_params.shrink_truncation_radius = r_shrink
  if(r_sol is not None):    mask_params.solvent_radius           = r_sol
  mask_params.grid_step_factor = grid_step_factor
  # 1
  if(option==1):
    asu_mask = ext.atom_mask(
      unit_cell                = xrs.unit_cell(),
      group                    = xrs.space_group(),
      resolution               = ma.d_min(),
      grid_step_factor         = grid_step_factor,
      solvent_radius           = mask_params.solvent_radius,
      shrink_truncation_radius = mask_params.shrink_truncation_radius)
    asu_mask.compute(xrs.sites_frac(), atom_radii)
    fm_asu = asu_mask.structure_factors(ma.indices())
    f_mask = ma.set().array(data = fm_asu)
  # 2
  elif(option==2):
    asu_mask = ext.atom_mask(
      unit_cell                = xrs.unit_cell(),
      space_group              = xrs.space_group(),
      gridding_n_real          = n_real,
      solvent_radius           = mask_params.solvent_radius,
      shrink_truncation_radius = mask_params.shrink_truncation_radius)
    asu_mask.compute(xrs.sites_frac(), atom_radii)
    fm_asu = asu_mask.structure_factors(ma.indices())
    f_mask = ma.set().array(data = fm_asu)
  # 3
  elif(option==3):
    mask_p1 = mmtbx.masks.mask_from_xray_structure(
      xray_structure           = xrs,
      p1                       = True,
      for_structure_factors    = True,
      solvent_radius           = mask_params.solvent_radius,
      shrink_truncation_radius = mask_params.shrink_truncation_radius,
      n_real                   = n_real,
      in_asu                   = False).mask_data
    maptbx.unpad_in_place(map=mask_p1)
    mask = asu_map_ext.asymmetric_map(
      xrs.crystal_symmetry().space_group().type(), mask_p1).data()
    f_mask = ma.structure_factors_from_asu_map(
      asu_map_data = mask, n_real = n_real)
  # 4
  elif(option==4):
    f_mask = masks.bulk_solvent(
      xray_structure              = xrs,
      ignore_zero_occupancy_atoms = False,
      solvent_radius              = mask_params.solvent_radius,
      shrink_truncation_radius    = mask_params.shrink_truncation_radius,
      ignore_hydrogen_atoms       = False,
      grid_step                   = step,
      atom_radii                  = atom_radii).structure_factors(
        miller_set = ma)
  elif(option==5):
    o = mmtbx.masks.bulk_solvent(
      xray_structure              = xrs,
      ignore_zero_occupancy_atoms = False,
      solvent_radius              = mask_params.solvent_radius,
      shrink_truncation_radius    = mask_params.shrink_truncation_radius,
      ignore_hydrogen_atoms       = False,
      gridding_n_real             = n_real,
      atom_radii                  = atom_radii)
    assert approx_equal(n_real, o.data.accessor().all())
    f_mask = o.structure_factors(ma)
  elif(option==6):
    # XXX No control over n_real, so results with others don't match
    mask_manager = masks.manager(
      miller_array      = ma,
      miller_array_twin = None,
      mask_params       = mask_params)
    f_mask = mask_manager.shell_f_masks(xray_structure=xrs, force_update=True)[0]
  else: assert 0
  #
  data = flex.complex_double(result.indices().size(), 0)
  data = data.set_selected(sel, f_mask.data())
  result = result.array(data = data)
  return result

def filter_mask(mask_p1, volume_cutoff, crystal_symmetry,
                for_structure_factors = False):
  co = maptbx.connectivity(
    map_data                   = mask_p1,
    threshold                  = 0.01,
    preprocess_against_shallow = True,
    wrapping                   = True)
  mi, ma = flex.min(mask_p1), flex.max(mask_p1)
  print (mask_p1.size(), (mask_p1<0).count(True))
  assert mi == 0, mi
  assert ma == 1, ma
  a,b,c    = crystal_symmetry.unit_cell().parameters()[:3]
  na,nb,nc = mask_p1.accessor().all()
  step = flex.mean(flex.double([a/na, b/nb, c/nc]))
  if(crystal_symmetry.space_group_number() != 1):
    co.merge_symmetry_related_regions(space_group=crystal_symmetry.space_group())
  conn = co.result().as_double()
  z = zip(co.regions(),range(0,co.regions().size()))
  sorted_by_volume = sorted(z, key=lambda x: x[0], reverse=True)
  for i_seq, p in enumerate(sorted_by_volume):
    v, i = p
    if(i==0): continue # skip macromolecule
    # skip small volume
    volume = v*step**3
    if volume < volume_cutoff:
      conn = conn.set_selected(conn==i, 0)
  conn = conn.set_selected(conn>0, 1)
  if for_structure_factors:
    conn = conn / crystal_symmetry.space_group().order_z()
  return conn


def modify(fofc, R, cutoff, crystal_gridding, mask=None):
  G = fofc.g_function(R=R)

  fft_map = fofc.fft_map(crystal_gridding = crystal_gridding)
  fft_map.apply_volume_scaling()
  map_data = fft_map.real_map_unpadded()

  if mask is not None: map_data = map_data*mask

  sel = map_data<cutoff
  map_data = map_data.set_selected(sel, cutoff)

  B = miller.structure_factor_box_from_map(
    crystal_symmetry=fofc.crystal_symmetry(),
    map=map_data, n_real=None,
     anomalous_flag=False, include_000=True)
  GB = B.g_function(R=R)
  B = B.customized_copy(data = B.data()*GB)
  fft_map = B.fft_map(crystal_gridding = crystal_gridding)
  fft_map.apply_volume_scaling()
  map_data = fft_map.real_map_unpadded()

  print(flex.min(map_data), flex.max(map_data), flex.mean(map_data))

  map_data = map_data.set_selected(map_data<abs(flex.min(map_data)), 0)

  print(flex.min(map_data), flex.max(map_data), flex.mean(map_data))

  F=B


  #F = fofc.structure_factors_from_map(map = map_data, in_place_fft=False,
  #  use_scale=True, use_sg=False)
  #
  #F = F.customized_copy(data = F.data()*G)
  #
  #fft_map = F.fft_map(crystal_gridding = crystal_gridding)
  #fft_map.apply_volume_scaling()
  #map_data = fft_map.real_map_unpadded()

  mtz_dataset = F.as_mtz_dataset(column_root_label = "F")
  mtz_object = mtz_dataset.mtz_object()
  mtz_object.write(file_name = "map.mtz")

  write_map_file(crystal_symmetry=fofc.crystal_symmetry(),
    map_data=map_data, file_name="map.ccp4")

  return map_data

class mask_and_regions(object):
  def __init__(self,
      xray_structure,
      crystal_gridding,
      step=0.6,
      r_sol=1.1,
      r_shrink=0.9,
      volume_cutoff=50,
      wrapping=True,
      force_symmetry=True,
      log=None,
      modifier=None
      ):
    """
    Split 0/1 traditional bulk-solvent mask into a series of isolated masks
    covering the whole unit cell in P1.
    """
    self.crystal_gridding = crystal_gridding
    self.crystal_symmetry = xray_structure.crystal_symmetry()
    self.step = step
    # Compute mask in P1
    self.mask_p1 = mmtbx.masks.mask_from_xray_structure(
      xray_structure           = xray_structure,
      p1                       = True,
      for_structure_factors    = True,
      solvent_radius           = r_sol,
      shrink_truncation_radius = r_shrink,
      n_real                   = self.crystal_gridding.n_real(),
      in_asu                   = False).mask_data
    maptbx.unpad_in_place(map=self.mask_p1)
    #
    # TO-DO: instead of excluding, add them as mosaic regions, may be?
    #
    tmp  = flex.double(flex.grid(self.mask_p1.all()), 1)
    if(modifier is not None):
      modifier = modifier * self.mask_p1
      sel = modifier <  -2.0 # XXX Depending on this, results can vary a lot
      modifier = modifier.set_selected(sel, 1)
      modifier = modifier.set_selected(~sel, 0)
      co = maptbx.connectivity(
        map_data                   = modifier,
        threshold                  = 0.01,
        preprocess_against_shallow = False,
        wrapping                   = wrapping)
      if(force_symmetry and xray_structure.space_group().type().number() != 1):
        co.merge_symmetry_related_regions(
          space_group = xray_structure.space_group())
      conn = co.result().as_double()
      z = zip(co.regions(),range(0,co.regions().size()))
      sorted_by_volume = sorted(z, key=lambda x: x[0], reverse=True)
      for i_seq, p in enumerate(sorted_by_volume):
        v, i = p
        if(i==0): continue
        # Skip small volume regions
        volume = v*self.step**3
        tmp = tmp.set_selected(conn==i, 0)
        if(volume_cutoff is not None and volume < volume_cutoff):
          break
    modifier = tmp
    #
    #
    # Solvent fraction
    self.solvent_content=100.*(self.mask_p1!=0).count(True)/self.mask_p1.size()
    if(log is not None):
      print("Solvent content: %7.3f"%self.solvent_content, file=log)
    # Connectivity
    co = maptbx.connectivity(
      map_data                   = self.mask_p1 * modifier, #!!!!!!!!!!!!!!!!!!!
      threshold                  = 0.01,
      preprocess_against_shallow = False, # XXX WHY False?
      wrapping                   = wrapping)
    if(force_symmetry and xray_structure.space_group().type().number() != 1):
      co.merge_symmetry_related_regions(
        space_group = xray_structure.space_group())
    # Regions
    self.conn = co.result().as_double() # 0 = protein, 1 = solvent, >1 = other
    z = zip(co.regions(),range(0,co.regions().size()))
    self.sorted_by_volume = sorted(z, key=lambda x: x[0], reverse=True)
    self.n_regions_total = co.regions().size()
    print("Total number of regions: %d"%self.n_regions_total, file=log)
    #
    if(log is not None):
      print("Regions (V > %d):"%volume_cutoff, file=log)
      print("  #   #   Vol. (A^3)    uc(%)", file=log)
    self.small_selection = flex.size_t()
    self.regions = []
    cntr = 0
    for i_seq, p in enumerate(self.sorted_by_volume):
      v, i = p
      # skip macromolecule
      if(i==0): continue
      # Region (i)selection
      iselection = (self.conn==i).iselection()
      # Skip small volume regions
      volume = v*self.step**3
      uc_fraction = v*100./self.conn.size()
      if(volume_cutoff is not None and volume < volume_cutoff):
        self.small_selection.extend(iselection)
        continue
      # Region
      region = group_args(
        i_seq       = cntr,
        i           = i,
        volume      = volume,
        uc_fraction = uc_fraction,
        iselection  = iselection)
      cntr+=1
      self.regions.append(region)
      if(log is not None):
        print("%3d %3d %12.3f %8.4f"%(region.i_seq, region.i, region.volume,
          region.uc_fraction), file=log)
    #
    self.n_regions = len(self.regions)
    print("Number of regions (V > %d): %d"%(
      volume_cutoff, self.n_regions), file=log)

  def get_selection(self, region):
    result = flex.bool(self.conn.size(), region.iselection)
    result.resize(self.conn.accessor())
    return result

  def get_region_asu_mask(self, region, map_data=None, write=False):
    # This is ASU mask, NOT P1 !
    selection = self.get_selection(region = region)
    mask_i = flex.double(flex.grid(self.crystal_gridding.n_real()), 0)
    mask_i = mask_i.set_selected(selection, 1)
    if(map_data is not None):
      mask_i = mask_i * map_data # may beed to divide by max value of map_data
    if(write): # This write P1 mask for region
      write_map_file(
        crystal_symmetry = self.crystal_symmetry,
        map_data         = mask_i,
        file_name        = "mask_%s.mrc"%str(round(region.volume,3)))
    return asu_map_ext.asymmetric_map(
      self.crystal_symmetry.space_group().type(), mask_i).data()

  def _mask_to_sf(self, mask_data, miller_array, d_min_cutoff=3):
    # Cutoff incoming Miller array
    result = miller_array.deep_copy()
    d_spacings    = miller_array.d_spacings().data()
    sel           = d_spacings >= 3
    miller_array_ = miller_array.select(sel)
    # Compute SF for truncated Miller array
    mask_asu = asu_map_ext.asymmetric_map(
      self.crystal_symmetry.space_group().type(), mask_data).data()
    sf = miller_array_.structure_factors_from_asu_map(
        asu_map_data = mask_asu, n_real = self.crystal_gridding.n_real())
    # Inflate Miller array to original hkl set before returning
    data = flex.complex_double(d_spacings.size(), 0)
    data = data.set_selected(sel, sf.data())
    return result.set().array(data=data)

  def f_mask_whole(self, miller_array):
    return self._mask_to_sf(mask_data=self.mask_p1, miller_array=miller_array)

  def f_mask_whole_filtered(self, miller_array):
    mask_p1_corrected = self.mask_p1.deep_copy()
    sel = flex.bool(self.conn.size(), self.small_selection)
    sel.resize(self.conn.accessor())
    mask_p1_corrected = mask_p1_corrected.set_selected(sel, 0)
    return self._mask_to_sf(
      mask_data=mask_p1_corrected, miller_array=miller_array)

class f_masks(object):
  def __init__(self,
               mask_and_regions,
               crystal_gridding,
               xray_structure,
               f_obs,
               f_calc=None,
               r_free_flags=None,
               mean_diff_map_threshold=0.5,
               log = None,
               write_masks=False):
    """
    Compute Fmask(whole), Fmask(main) and list of mosaic contributions.
    Fmask match input miller array set but zeroed out in 3A-better resolution.
    """
    adopt_init_args(self, locals())
    #
    self.d_spacings   = f_obs.d_spacings().data()
    self.sel_gte3     = self.d_spacings >= 3
    self.miller_array = f_obs.select(self.sel_gte3)
    #
    self.crystal_symmetry = self.xray_structure.crystal_symmetry()
    self.n_real = self.crystal_gridding.n_real()
    #
    f_mask_data_main = flex.complex_double(f_obs.data().size(), 0)
    self.f_mask_main = None
    self.FV          = OrderedDict()
    self.mFoDFc_main = None
    self.diff_map    = None # mFo-DFc map computed using F_mask_0 (main mask)
    #
    if(log is not None):
      print("Regions satisfying volume and map criteria:", file=log)
      print("                                   mFo-DFc (sigma)", file=log)
      print("  #   Vol. (A^3)    uc(%)     min     max    mean      sd", file=log)
    #
    for region in self.mask_and_regions.regions:
      f_mask_i = None # must be here inside the loop!
      # Compute i-th region mask
      mask_i_asu = self.mask_and_regions.get_region_asu_mask(region = region)
      # Compute F_mask_0 (F_mask for main mask)
      if(region.uc_fraction >= 1):
        f_mask_i = self.compute_f_mask_i(mask_i_asu)
        f_mask_data_main += f_mask_i.data()
      # Compute mFo-DFc map using main mask (once done computing main mask!)
      if(region.uc_fraction < 1 and self.diff_map is None and
         self.f_calc is not None and mean_diff_map_threshold is not None):
        self.diff_map = self.compute_diff_map(f_mask_data = f_mask_data_main)
      if(self.diff_map is not None):
        # Analyze mFo-DFc map in the i-th region
        map_info = self._get_map_info(iselection = region.iselection)
        # Skip regions with weak mean density
        if(map_info.mean is not None and map_info.mean < mean_diff_map_threshold):
          continue
        if(log is not None):
          print("%3d"%region.i_seq,"%12.3f"%region.volume,
                "%8.4f"%round(region.uc_fraction,4), map_info.string, file=log)
      else:
        print("%3d"%region.i_seq,"%12.3f"%region.volume,
              "%8.4f"%round(region.uc_fraction,4), file=log)
      # Compute F_mask for i-th region
      if(f_mask_i is None):
        f_mask_i = self.compute_f_mask_i(mask_i_asu)
      # Compose result object
      self.FV[f_mask_i] = region.i_seq
    # END OF LOOP OVER REGIONS



    """

    #self.FV          = OrderedDict()
    #self.FV[f_obs.customized_copy(data = f_mask_data_main)] = 0

    self.diff_map = self.compute_diff_map(f_mask_data = f_mask_data_main)

    mask_ = mmtbx.masks.mask_from_xray_structure(
      xray_structure           = self.xray_structure,
      p1                       = True,
      for_structure_factors    = True,
      #solvent_radius           = 0.5,
      #shrink_truncation_radius = 0.5,
      n_real                   = self.n_real,
      in_asu                   = False).mask_data
    maptbx.unpad_in_place(map=mask_)

    mc = self.mFoDFc_main
    fft_map = mc.fft_map(
      symmetry_flags   = maptbx.use_space_group_symmetry,
      crystal_gridding = self.crystal_gridding)
    fft_map.apply_volume_scaling()
    map_data = fft_map.real_map_unpadded() #* mask_

    map_data = map_data.set_selected(map_data<0,0)

    #sgt = self.f_obs.space_group().type()
    #asu_map = asu_map_ext.asymmetric_map(sgt, map_data)
    #map_data_asu = asu_map.data()
    #map_data_asu = map_data_asu.shift_origin()
    #
    #asu_map = asu_map_ext.asymmetric_map(sgt, map_data_asu,
    #  self.crystal_gridding.n_real())
    #f_mask_i = self.f_calc.customized_copy(
    #  indices = self.f_calc.indices(),
    #  data    = asu_map.structure_factors(self.f_calc.indices() ))

    def _sf_from_map(map_data):
      return self.f_calc.structure_factors_from_map(
        map            = map_data,
        use_scale      = True,
        anomalous_flag = False,
        use_sg         = False)

    #f_mask_i = _sf_from_map(map_data = map_data)
    #
    #
    #self.FV[f_mask_i] = -99

    OFFSET = region.i_seq+1
    print("<><><><><><><><><><>")
    dmd = modify(fofc=self.mFoDFc_main, R=2, cutoff=0.3, #0.1/10,
       crystal_gridding=self.crystal_gridding,
       mask = self.mask_and_regions.mask_p1)
    #dmd = map_data
    #STOP()

    mask_p1 = self.mask_and_regions.mask_p1.deep_copy()

    #mask_ = mmtbx.masks.mask_from_xray_structure(
    #  xray_structure           = self.xray_structure,
    #  p1                       = True,
    #  for_structure_factors    = True,
    #  solvent_radius           = 0.5,
    #  shrink_truncation_radius = 0.5,
    #  n_real                   = self.n_real,
    #  in_asu                   = False).mask_data
    #maptbx.unpad_in_place(map=mask_)
    #dmd = dmd * mask_

    co = maptbx.connectivity(
      map_data                   = dmd,
      threshold                  = 0.04, #0.001/10,
      preprocess_against_shallow = False,
      wrapping                   = True)
    if(xray_structure.space_group().type().number() != 1): # not P1
      co.merge_symmetry_related_regions(
        space_group = xray_structure.space_group())
    conn = co.result().as_double()
    z = zip(co.regions(),range(0,co.regions().size()))
    sorted_by_volume = sorted(z, key=lambda x: x[0], reverse=True)
    for i_seq, p in enumerate(sorted_by_volume):
      i_seq = OFFSET + i_seq
      v, i = p

      #if(i==0 or i==1): continue
      if i==0: continue

      step=0.6
      volume = v*step**3
      volume_cutoff = 2500
      if(volume_cutoff is not None and volume < volume_cutoff): continue
      uc_fraction = v*100./conn.size()
      print(i, "%3d"%i_seq,"%12.3f"%volume, "%8.4f"%round(uc_fraction,4),
            "%7s"%str(None), file=log)
      iselection = (conn==i).iselection()
      selection = flex.bool(conn.size(), iselection)
      selection.resize(conn.accessor())

      mask_p1 = mask_p1.set_selected(selection, 0)

      region = group_args(
        i           = i,
        i_seq       = i_seq,
        volume      = volume,
        uc_fraction = uc_fraction,
        iselection  = iselection)
      self.mask_and_regions.regions.append( region )

      dmd_i = dmd.deep_copy()
      mask_i_asu = dmd_i.set_selected(~selection, 0)
      #mask_i_asu = mask_i_asu.set_selected(mask_i_asu>0, 1)
      f_mask_i = _sf_from_map(map_data=mask_i_asu)

      #mask_i_asu = mask_i_asu/flex.max(mask_i_asu)
      #mask_i_asu = self.mask_and_regions.get_region_asu_mask(region = region, map_data=dmd_i)
      #mask_i_asu = mask_i_asu/flex.max(mask_i_asu)
      #
      #f_mask_i = self.compute_f_mask_i(mask_i_asu)
      self.FV[f_mask_i] = -1*i_seq
    print("<><><><><><><><><><>")


    fmodel = mmtbx.f_model.manager(
      f_obs        = self.f_obs,
      f_calc       = self.f_calc,
      r_free_flags = self.r_free_flags,
      f_mask       = _sf_from_map(map_data=mask_p1))
    fmodel.update_all_scales(remove_outliers=True,
      apply_scale_k1_to_f_obs = APPLY_SCALE_K1_TO_FOBS)
    mc = fmodel.electron_density_map().map_coefficients(
      map_type   = "mFobs-DFmodel",
      isotropize = False,
      exclude_free_r_reflections = True)
    mtz_dataset = mc.as_mtz_dataset(column_root_label = "F")
    mtz_object = mtz_dataset.mtz_object()
    mtz_object.write(file_name = "map2.mtz")
    """


    #
    # Determine number of secondary regions. Must happen here!
    # Preliminarily if need to do mosaic.

    self.n_regions = len(self.FV.values())
    print("Number of regions (mean(mFo-DFc) >= %s): %d"%(
      mean_diff_map_threshold, self.n_regions), file=log)
    if(self.n_regions==0):
      raise Sorry("Region selection criteria lead to no regions")
    self.do_mosaic = False
    if(self.n_regions>1 and flex.max(self.d_spacings)>6):
      self.do_mosaic = True
    # Finalize main Fmask
    self.f_mask_main = f_obs.customized_copy(data = f_mask_data_main)
    # Delete large objects from memory
    del self.diff_map

  def _get_sum_f_masks(self):
    f_masks = list(self.FV.keys())
    data = f_masks[0].data().deep_copy()
    for f in f_masks[1:]:
      data += f.data()
    return self.f_obs.set().array(data = data)

  def _get_map_info(self, iselection):
    if(self.diff_map is None):
      return group_args(min=None, max=None, mean=None, sd=None,
                        string="   None    None    None    None")
    blob = self.diff_map.select(iselection)
    mi,ma,me = flex.min(blob), flex.max(blob), flex.mean(blob)
    sd = blob.sample_standard_deviation()
    return group_args(min=mi, max=ma, mean=me, sd=sd,
                      string="%7.3f %7.3f %7.3f %7.3f"%(mi,ma,me,sd))

  def _inflate(self, f):
    data = flex.complex_double(self.d_spacings.size(), 0)
    data = data.set_selected(self.sel_gte3, f.data())
    return self.f_obs.set().array(data = data)

  def compute_f_mask_i(self, mask_i_asu):
    return self._inflate(self.miller_array.structure_factors_from_asu_map(
      asu_map_data = mask_i_asu, n_real = self.n_real))

  def compute_diff_map(self, f_mask_data):
    if(self.f_calc is None): return None
    f_mask = self.f_obs.customized_copy(data = f_mask_data)
    fmodel = mmtbx.f_model.manager(
      f_obs        = self.f_obs,
      f_calc       = self.f_calc,
      r_free_flags = self.r_free_flags,
      f_mask       = f_mask)
    fmodel.update_all_scales(remove_outliers=True,
      apply_scale_k1_to_f_obs = APPLY_SCALE_K1_TO_FOBS)
    self.mFoDFc_main = fmodel.electron_density_map().map_coefficients(
      map_type   = "mFobs-DFmodel",
      isotropize = False,
      exclude_free_r_reflections = True)
    fft_map = self.mFoDFc_main.fft_map(crystal_gridding = self.crystal_gridding)
    fft_map.apply_sigma_scaling()
    return fft_map.real_map_unpadded()

def algorithm_0(f_obs, F, kt):
  """
  Grid search
  """
  fc, f_masks = F[0], F[1:]
  k_mask_trial_range=[]
  s = -1
  while s<1:
    k_mask_trial_range.append(s)
    s+=0.0001
  r = []
  fc_data = fc.data()
  for i, f_mask in enumerate(f_masks):
    #print("mask ",i)
    assert f_obs.data().size() == fc.data().size()
    assert f_mask.data().size() == fc.data().size()
    #print (bulk_solvent.r_factor(f_obs.data(),fc_data))
    kmask_, k_ = \
      bulk_solvent.k_mask_and_k_overall_grid_search(
        f_obs.data()*kt,
        fc_data*kt,
        f_mask.data()*kt,
        flex.double(k_mask_trial_range),
        flex.bool(fc.data().size(),True))
    r.append(kmask_)
    fc_data += fc_data*k_ + kmask_*f_mask.data()
    #print (bulk_solvent.r_factor(f_obs.data(),fc_data + kmask_*f_mask.data(),k_))
  r = [1,]+r
  return r

def algorithm_2(i_obs, F, x, use_curvatures, use_lbfgsb, macro_cycles=10,
                max_iterations=100):
  """
  Unphased one-step search
  """
  assert use_curvatures in [True, False, None]
  assert use_lbfgsb in [True, False, None]
  upper = flex.double([1.1] + [12]*(x.size()-1))
  lower = flex.double([0.9] + [0]*(x.size()-1))
  for it in range(macro_cycles):
    x = x.set_selected(x<0,1.e-6)
    if(use_curvatures is True): # Curvatures only
      calculator = tg(i_obs = i_obs, F=F, x = x, use_curvatures=True)
      m = minimizer2(
        max_iterations=max_iterations, calculator=calculator).run(use_curvatures=True)
      x = m.x
      x = x.set_selected(x<0,1.e-6)
    elif(use_curvatures is False): # No curvatures at all
      calculator = tg(i_obs = i_obs, F=F, x = x, use_curvatures=False)
      if(use_lbfgsb is True):
        m = scitbx.minimizers.lbfgs(
           mode='lbfgsb', max_iterations=max_iterations, calculator=calculator)
      else:
        m = scitbx.minimizers.lbfgs(
           mode='lbfgs', max_iterations=max_iterations, calculator=calculator)
      x = m.x
      x = x.set_selected(x<0,1.e-6)
    elif(use_curvatures is None):
      calculator = tg(i_obs = i_obs, F=F, x = x, use_curvatures=True)
      m = minimizer2(
        max_iterations=max_iterations, calculator=calculator).run(use_curvatures=True)
      x = m.x
      x = x.set_selected(x<0,1.e-6)
      calculator = tg(i_obs = i_obs, F=F, x = x, use_curvatures=False,
        bound_flags=flex.int(x.size(),2), lower_bound=lower, upper_bound=upper)
      if(use_lbfgsb is True):
        m = scitbx.minimizers.lbfgs(
           mode='lbfgsb', max_iterations=max_iterations, calculator=calculator)
      else:
        m = scitbx.minimizers.lbfgs(
           mode='lbfgs', max_iterations=max_iterations, calculator=calculator)
      x = m.x
      x = x.set_selected(x<0,1.e-6)
  return m.x

def algorithm_3(i_obs, fc, f_masks):
  """
  Unphased two-step search
  """
  F = [fc]+f_masks
  Gnm = []
  cs = {}
  cntr=0
  nm=[]
  # Compute and store Gnm
  for n, Fn in enumerate(F):
    for m, Fm in enumerate(F):
      if m < n:
        continue
      Gnm.append( flex.real( Fn.data()*flex.conj(Fm.data()) ) )
      cs[(n,m)] = cntr
      cntr+=1
      nm.append((n,m))
  # Keep track of indices for "upper triangular matrix vs full"
  for k,v in zip(list(cs.keys()), list(cs.values())):
    i,j=k
    if i==j: continue
    else: cs[(j,i)]=v
  # Generate and solve system Ax=b, x = A_1*b
  A = []
  b = []
  for u, Gnm_u in enumerate(Gnm):
    for v, Gnm_v in enumerate(Gnm):
      scale = 2
      n,m=nm[v]
      if n==m: scale=1
      A.append( flex.sum(Gnm_u*Gnm_v)*scale )
    b.append( flex.sum(Gnm_u * i_obs.data()) )
  A = matrix.sqr(A)
  A_1 = A.inverse()
  b = matrix.col(b)
  x = A_1 * b
  # Expand Xmn from solution x
  Xmn = []
  for n, Fn in enumerate(F):
    rows = []
    for m, Fm in enumerate(F):
      x_ = x[cs[(n,m)]]
      rows.append(x_)
    Xmn.append(rows)
  # Do formula (19)
  lnK = []
  for j, Fj in enumerate(F):
    t1 = flex.sum( flex.log( flex.double(Xmn[j]) ) )
    t2 = 0
    for n, Fn in enumerate(F):
      for m, Fm in enumerate(F):
        t2 += math.log(Xmn[n][m])
    t2 = t2 / (2*len(F))
    lnK.append( 1/len(F)*(t1-t2) )
  return [math.exp(x) for x in lnK]

def algorithm_4(f_obs, F, phase_source, max_cycles=100, auto_converge_eps=1.e-7,
                use_cpp=True, x_init=None):
  """
  Phased simultaneous search (alg4)
  """
  fc, f_masks = F[0], F[1:]
  if(x_init is not None):
    assert x_init.size() == len(f_masks)
    # Apply scale
    tmp = []
    for fm, s in zip(f_masks, x_init):
      fm = fm.array(data = fm.data()*s)
      tmp.append(fm)
    f_masks = tmp
  #
  fc = fc.deep_copy()
  F = [fc]+f_masks
  # C++ version
  if(use_cpp):
    result = mosaic_ext.alg4(
      [f.data() for f in F],
      f_obs.data(),
      phase_source.data(),
      max_cycles,
      auto_converge_eps)
  else:
    # Python version (1.2-3 times slower, but much more readable!)
    cntr = 0
    x_prev = None
    while True:
      f_obs_cmpl = f_obs.phase_transfer(phase_source = phase_source)
      A = []
      b = []
      for j, Fj in enumerate(F):
        A_rows = []
        for n, Fn in enumerate(F):
          Gjn = flex.real( Fj.data()*flex.conj(Fn.data()) )
          A_rows.append( flex.sum(Gjn) )
        Hj = flex.real( Fj.data()*flex.conj(f_obs_cmpl.data()) )
        b.append(flex.sum(Hj))
        A.extend(A_rows)
      A = matrix.sqr(A)
      A_1 = A.inverse()
      b = matrix.col(b)
      x = A_1 * b
      #
      fc_d = flex.complex_double(phase_source.indices().size(), 0)
      for i, f in enumerate(F):
        fc_d += f.data()*x[i]
      phase_source = phase_source.customized_copy(data = fc_d)
      x_ = x[:]
      #
      cntr+=1
      if(cntr>max_cycles): break
      if(x_prev is None): x_prev = x_[:]
      else:
        max_diff = flex.max(flex.abs(flex.double(x_prev)-flex.double(x_)))
        if(max_diff<=auto_converge_eps): break
        x_prev = x_[:]
    result = x_
  if(x_init is not None):
    for i,tmp in enumerate(x_init):
      result[i+1] = result[i+1] * x_init[i]
  return result


 *******************************************************************************


 *******************************************************************************
mmtbx/bulk_solvent/multi_mask_bulk_solvent.py
from __future__ import absolute_import, division, print_function
from cctbx.array_family import flex
import mmtbx.f_model
from cctbx import maptbx
import mmtbx.masks
import mmtbx.bulk_solvent
import boost_adaptbx.boost.python as bp
from six.moves import zip
from six.moves import range
asu_map_ext = bp.import_ext("cctbx_asymmetric_map_ext")
from mmtbx import map_tools
import cctbx.miller
from libtbx.test_utils import approx_equal

def ccp4_map(cg, file_name, mc=None, map_data=None):
  assert [mc, map_data].count(None)==1
  if(map_data is None):
    map_data = get_map(mc=mc, cg=cg)
  from iotbx import mrcfile
  mrcfile.write_ccp4_map(
      file_name=file_name,
      unit_cell=cg.unit_cell(),
      space_group=cg.space_group(),
      #gridding_first=(0,0,0),# This causes a bug (map gets shifted)
      #gridding_last=n_real,  # This causes a bug (map gets shifted)
      map_data=map_data,
      labels=flex.std_string([""]))

def get_k_mask(method, f_obs, f_calc, f_mask, ss, sel):
  obj = method(
    f_obs     = f_obs,
    f_calc    = f_calc,
    f_mask    = f_mask,
    selection = sel)
  k_mask = obj.x_best
  r = obj.r_best
  if(abs(k_mask) < 1.e-6):
    one = flex.double(ss.select(sel).size(),1.)
    ks = flex.double([k/100 for k in range(-105,105,1)])
    #ks = flex.double(
    #  [k_mask]+[k/100. for k in range(int((k_mask-k_mask)*100.), int((k_mask+k_mask)*100.))])
    bs = flex.double([0,])
    res = mmtbx.bulk_solvent.ksol_bsol_grid_search(
      f_obs.select(sel),
      f_calc.select(sel),
      f_mask.select(sel),
      ks,
      bs,
      ss.select(sel),
      1,
      one,
      one,
      r)
    k_mask, b_sol, r = res
    #print k_mask
  return k_mask, r

def loop_work(fmodel, f_masks, method):
  #
  sel_free =  fmodel.r_free_flags().data()
  sel_work = ~sel_free
  f_bulk_data_all = flex.complex_double(fmodel.f_obs().data().size(), 0)

  k_anisotropic = fmodel.k_isotropic()*fmodel.k_anisotropic()*fmodel.scale_k1()

  f_obs_w          = fmodel.f_obs().select(sel_work)
  f_calc_w         = fmodel.f_calc().select(sel_work)
  f_masks_w        = [f.select(sel_work) for f in f_masks]
  k_anisotropic_w  = k_anisotropic.select(sel_work)
  bin_selections_w = [b.select(sel_work) for b in fmodel.bin_selections]
  ss_w             = fmodel.ss.select(sel_work)

  f_obs_f          = fmodel.f_obs().select(sel_free)
  f_calc_f         = fmodel.f_calc().select(sel_free)
  f_masks_f        = [f.select(sel_free) for f in f_masks]
  k_anisotropic_f  = k_anisotropic.select(sel_free)
  bin_selections_f = [b.select(sel_free) for b in fmodel.bin_selections]
  ss_f             = fmodel.ss.select(sel_free)
  #

  f_obs_w = f_obs_w.array(data = f_obs_w.data()/(k_anisotropic_w))
  f_obs_f = f_obs_f.array(data = f_obs_f.data()/(k_anisotropic_f))
  #
  F   = f_calc_w.deep_copy().data()
  F_f = f_calc_f.deep_copy().data()
  FB   = 0
  FB_f = 0
  r_best = 999
  for i, f in enumerate(f_masks_w):
    f_f = f_masks_f[i]
    f_bulk_data_w = flex.complex_double(f_obs_w.data().size(), 0)
    f_bulk_data_f = flex.complex_double(f_obs_f.data().size(), 0)
    k_masks = flex.double()
    for sel_w, sel_f in zip(bin_selections_w, bin_selections_f):
      k_mask, r = get_k_mask(
        method = method,
        f_obs  = f_obs_w.data(),
        f_calc = F,
        f_mask = f.data(),
        ss     = ss_w,
        sel    = sel_w)
      k_masks.append(k_mask)
    #if(k_masks[0]<0 or abs(k_masks[0])<1.e-3): k_masks *= 0.
    for i, k_mask in enumerate(k_masks):
      #if k_mask<0: k_mask=0.
      sel_w, sel_f = bin_selections_w[i], bin_selections_f[i]
      f_bulk_data_w = f_bulk_data_w.set_selected(sel_w, k_mask*f.data().select(sel_w))
      f_bulk_data_f = f_bulk_data_f.set_selected(sel_f, k_mask*f_f.data().select(sel_f))
    #
    F    = F    + f_bulk_data_w
    F_f  = F_f  + f_bulk_data_f
    FB   = FB   + f_bulk_data_w
    FB_f = FB_f + f_bulk_data_f
    #
    rw1 = mmtbx.bulk_solvent.r_factor(f_obs_w.data(),   F)
    rf1 = mmtbx.bulk_solvent.r_factor(f_obs_f.data(), F_f)
    if(rf1<r_best):
      r_best = rf1
    else:
      FB   = FB   - f_bulk_data_w
      FB_f = FB_f - f_bulk_data_f
      F   = F   - f_bulk_data_w
      F_f = F_f - f_bulk_data_f
    rw2 = mmtbx.bulk_solvent.r_factor(f_obs_w.data(),   F)
    rf2 = mmtbx.bulk_solvent.r_factor(f_obs_f.data(), F_f)
    #print "%7.5f %7.5f <> %7.5f %7.5f %7.5f"%(rw1, rf1, rw2, rf2,  rf2-rw2)
  #
  f_bulk_data_all = f_bulk_data_all.set_selected(sel_work, FB)
  f_bulk_data_all = f_bulk_data_all.set_selected(sel_free, FB_f)
  f_bulk = fmodel.f_obs().array(data = f_bulk_data_all)
  return f_bulk

def run_method(fmodel, f_masks, one, method):
  f_bulk = loop_work(fmodel=fmodel, f_masks=f_masks, method = method)
  fmodel = mmtbx.f_model.manager(
    f_obs         = fmodel.f_obs(),
    r_free_flags  = fmodel.r_free_flags(),
    f_calc        = fmodel.f_calc(),
    k_mask        = one,
    f_mask        = f_bulk)
  fmodel.update_all_scales(remove_outliers=False, update_f_part1=False)
  return fmodel

def helper_3(
      fmodel,
      f_masks,
      log):
  #f_masks = fmodel.f_masks() #+ f_masks[0:]
  for i in range(len(f_masks)):
    f_masks[i] = f_masks[i].common_set(fmodel.f_obs())
  one = flex.double(fmodel.ss.size(), 1.)
  method_1 = \
    mmtbx.bulk_solvent.overall_and_bulk_solvent_scale_coefficients_analytical
  method_2 = mmtbx.bulk_solvent.bulk_solvent_scale_coefficients_analytical
  # Run methods
  fmodel_1 = run_method(fmodel=fmodel, f_masks=f_masks, one=one, method=method_1)
  fmodel_2 = run_method(fmodel=fmodel, f_masks=f_masks, one=one, method=method_2)
  #
  #print "="*79
  #fmodel_1.show()
  #print fmodel_1.r_work(), fmodel_1.r_free(), fmodel_1.r_work_low()
  #print "="*79
  #fmodel_2.show()
  #print fmodel_2.r_work(), fmodel_2.r_free(), fmodel_2.r_work_low()
  #
  if(fmodel_1.r_free()<fmodel_2.r_free()):
    if(fmodel_1.r_work_low()<fmodel_2.r_work_low()):
      return fmodel_1, 1
    else:
      return fmodel_2, 2
  else:
    if(fmodel_2.r_work_low()<fmodel_1.r_work_low()):
      return fmodel_2, 2
    else:
      return fmodel_1, 1
################################################################################

def compute_map(fmodel, crystal_gridding, map_type):
  map_coefficients = map_tools.electron_density_map(
    fmodel = fmodel).map_coefficients(
      map_type         = map_type,
      isotropize       = True,
      fill_missing     = False)
  fft_map = cctbx.miller.fft_map(
    crystal_gridding     = crystal_gridding,
    fourier_coefficients = map_coefficients)
  fft_map.apply_sigma_scaling()
  return fft_map.real_map_unpadded()

def get_fmodel_and_grid_step(f_obs, r_free_flags, xrs):
  mask_params = mmtbx.masks.mask_master_params.extract()
  mask_params.grid_step_factor=5.
  fmodel_1 = mmtbx.f_model.manager(
    f_obs          = f_obs,
    r_free_flags   = r_free_flags,
    mask_params    = mask_params,
    xray_structure = xrs)
  fmodel_1.update_all_scales(remove_outliers=True, update_f_part1=False)
  rw1, rf1, rwl1 = fmodel_1.r_work(), fmodel_1.r_free(), fmodel_1.r_work_low()
  #
  fmodel_2 = mmtbx.f_model.manager(
    f_obs          = f_obs,
    r_free_flags   = r_free_flags,
    xray_structure = xrs)
  fmodel_2.update_all_scales(remove_outliers=True, update_f_part1=False)
  rw2, rf2, rwl2 = fmodel_2.r_work(), fmodel_2.r_free(), fmodel_2.r_work_low()
  if(rf1<rf2 and rwl1<rwl2): return fmodel_1, 5.
  else:                      return fmodel_2, 4.

def get_mask_1(fmodel, grid_step_factor):
  grid_step = fmodel.f_obs().d_min()*(1./grid_step_factor)
  if(grid_step < 0.15): grid_step = 0.15
  grid_step = min(0.8, grid_step)
  crystal_gridding = maptbx.crystal_gridding(
    unit_cell = fmodel.xray_structure.unit_cell(),
    space_group_info = fmodel.xray_structure.space_group_info(),
    symmetry_flags   = maptbx.use_space_group_symmetry,
    step             = grid_step)
  n_real = crystal_gridding.n_real()
  # Compute mask in P1
  mask_data_p1 = mmtbx.masks.mask_from_xray_structure(
    xray_structure        = fmodel.xray_structure,
    p1                    = True,
    for_structure_factors = True,
    n_real                = n_real,
    in_asu                = False).mask_data
  maptbx.unpad_in_place(map=mask_data_p1)
  return mask_data_p1, n_real, crystal_gridding

def get_mask_2(fmodel, grid_step_factor):
  sgt = fmodel.xray_structure.space_group().type()
  mask_params = mmtbx.masks.mask_master_params.extract()
  mask_params.grid_step_factor = grid_step_factor
  asu_mask_obj = mmtbx.masks.asu_mask(
    xray_structure = fmodel.xray_structure,
    d_min          = fmodel.f_obs().d_min(),
    mask_params    = mask_params).asu_mask
  mask_data_p1 = asu_mask_obj.mask_data_whole_uc()
  maptbx.unpad_in_place(map=mask_data_p1)
  n_real = mask_data_p1.all()
  crystal_gridding = maptbx.crystal_gridding(
    unit_cell             = fmodel.xray_structure.unit_cell(),
    space_group_info      = fmodel.xray_structure.space_group_info(),
    symmetry_flags        = maptbx.use_space_group_symmetry,
    pre_determined_n_real = n_real)

  #n_real = mask_data_p1.all()
  #mask_data_p1 = asu_map_ext.asymmetric_map(sgt, mask_data_p1, n_real).symmetry_expanded_map()
  #maptbx.unpad_in_place(map=mask_data_p1)

  return mask_data_p1, n_real, crystal_gridding

class multi_mask_bulk_solvent(object):
  def __init__(self, fmodel, log=None):
    # Commonly used objects
    xrs = fmodel.xray_structure
    sgt = xrs.space_group().type()
    # Compute default fmodel and decide on grid step
    fmodel, self.grid_step_factor = get_fmodel_and_grid_step(
      f_obs        = fmodel.f_obs(),
      r_free_flags = fmodel.r_free_flags(),
      xrs          = xrs)
    #fmodel.show()
    #print fmodel.r_work(), fmodel.r_free()
    ###
    mask_data_p1, n_real, crystal_gridding = get_mask_1(fmodel=fmodel,
      grid_step_factor=self.grid_step_factor)
    #ccp4_map(cg=crystal_gridding, file_name="m1.ccp4", map_data=mask_data_p1_)
    #xxx1 = fmodel.f_obs().structure_factors_from_map(map=mask_data_p1,
    #   use_scale = True, anomalous_flag = False, use_sg = False)

    #mask_data_p1, n_real, crystal_gridding = get_mask_2(fmodel=fmodel,
    #  grid_step_factor=self.grid_step_factor)
    #print n_real
    #STOP()
    #xxx2 = fmodel.f_obs().structure_factors_from_map(map=mask_data_p1,
    #   use_scale = True, anomalous_flag = False, use_sg = False)
    #
    #assert approx_equal(xxx1.data(), xxx2.data())

    #print mask_data_p1.all(), mask_data_p1.focus(), mask_data_p1.origin()
    #print mask_data_p1_2.all(), mask_data_p1_2.focus(), mask_data_p1_2.origin()
    #print mask_data_p1_1.count(0), mask_data_p1_2.count(0)
    #assert approx_equal(mask_data_p1_1, mask_data_p1_2)
    #STOP()
    #####
    # Mask connectivity analysis
    co = maptbx.connectivity(map_data=mask_data_p1, threshold=0.01)
    conn = co.result().as_double()
    # Convert result of connectivity analysis from P1 to ASU (in-place)
    conn = asu_map_ext.asymmetric_map(sgt, conn).data()
    # Find unique indices and regions in reduced (P1->ASU) conn
    region_indices = flex.double()
    region_volumes = flex.double()
    for i in conn:
      if not i in region_indices: region_indices.append(i)
    for l in region_indices:
      szl = conn.count(l)*100./conn.size()
      region_volumes.append(szl)
    s = flex.sort_permutation(region_volumes, reverse=True)
    region_volumes = region_volumes.select(s)
    region_indices = region_indices.select(s)
    # Convert P1 mask into ASU
    mask_data_asu = asu_map_ext.asymmetric_map(sgt, mask_data_p1).data()
    conn.reshape(mask_data_asu.accessor()) #XXX still need it?
    f_masks = []
    all_zero_found = False
    if(log is not None): print("Number of regions:", len(region_indices), file=log)
    mi,ma,me,diff_map_asu = None,None,None,None
    for ii, i in enumerate(region_indices):
      s = conn==i
      si = s.iselection()
      if(not all_zero_found and mask_data_asu.select(si).count(0.)>0):
        all_zero_found = True
        continue
      # DIFF MAP START
      if(region_volumes[ii]<1 and diff_map_asu is None):#(ii == 2):
        fmodel_tmp = mmtbx.f_model.manager(
          f_obs          = fmodel.f_obs(),
          r_free_flags   = fmodel.r_free_flags(),
          f_calc         = fmodel.f_calc(),
          f_mask         = f_masks[len(f_masks)-1])
        fmodel_tmp.update_all_scales(remove_outliers=False, update_f_part1=False)
        diff_map_p1 = compute_map(
          fmodel           = fmodel_tmp,
          crystal_gridding = crystal_gridding,
          map_type         = "mFo-DFc")
        diff_map_asu = asu_map_ext.asymmetric_map(sgt, diff_map_p1).data()
      if(diff_map_asu is not None):
        mi,ma,me = diff_map_asu.select(si).min_max_mean().as_tuple()
        if(ma<0. or me<0.):
          continue
      # DIFF MAP END

      #XXX this is 4 loops, may be slow. move to C++ if slow.
      mask_data_asu_i = mask_data_asu.deep_copy()
      #mask_data_asu_i = mask_data_asu_i.set_selected(s, 1).set_selected(~s, 0)
      mask_data_asu_i = mask_data_asu_i.set_selected(~s, 0)

      #if(mi is None):
      #  print "region: %5d fraction: %8.4f"%(ii, region_volumes[ii]), len(region_volumes)
      #else:
      #  print "region: %5d fraction: %8.4f"%(ii, region_volumes[ii]), len(region_volumes), "%7.3f %7.3f %7.3f"%(mi,ma,me)

      if(log is not None):
        print("region: %5d fraction: %8.4f"%(ii, region_volumes[ii]), file=log)
        log.flush()
      f_mask_i = fmodel.f_obs().structure_factors_from_asu_map(
        asu_map_data = mask_data_asu_i, n_real = n_real)
      if(len(f_masks)>0 and region_volumes[ii]>1):
        f_masks[len(f_masks)-1] = f_masks[len(f_masks)-1].array(data = f_masks[len(f_masks)-1].data()+
          f_mask_i.data())
      else:
        f_masks.append(f_mask_i)
    #
    self.fmodel_result, self.method = helper_3(
        fmodel  = fmodel,
        f_masks = f_masks,
        log     = log)
    #self.fmodel_result.show()
    #
    self.n_regions = len(region_volumes[1:])
    self.region_volumes = " ".join(["%8.4f"%(v) for v in region_volumes[1:][:10]]) # top 10


 *******************************************************************************


 *******************************************************************************
mmtbx/bulk_solvent/scaler.py
from __future__ import absolute_import, division, print_function
from scitbx.array_family import flex
import sys
from mmtbx import bulk_solvent
from cctbx import adptbx
import boost_adaptbx.boost.python as bp
from six.moves import range
ext = bp.import_ext("mmtbx_f_model_ext")
from cctbx import sgtbx
from mmtbx.bulk_solvent import kbu_refinery
import mmtbx.f_model
import math
from libtbx import group_args
import scitbx.math
from cctbx import miller
import mmtbx.arrays
import scitbx.math
from libtbx import group_args
from libtbx.test_utils import approx_equal

def moving_average(x):
  x_ = x_ = [x[0]] + list(x) + [x[len(x)-1]]
  for cycle in range(5):
    result = x_[:]
    selection = flex.bool(len(result), False)
    for i, s in enumerate(selection):
      if(i!=0 and i!=len(result)-1):
        if((result[i-1]<result[i] and result[i+1]<result[i]) or
           (result[i-1]>result[i] and result[i+1]>result[i])):
          selection[i]=True
    for i in range(len(result)):
      if(i!=0 and i!=len(result)-1 and selection[i]):
        result[i] = (x_[i-1]+x_[i]+x_[i+1])/3.
    x_ = result[:]
  return result[1:len(result)-1]

def run_simple(fmodel_kbu, bin_selections, r_free_flags, bulk_solvent,
               aniso_scale):
  if(aniso_scale):
    try_poly    = True
    try_expanal = True
    try_expmin  = False
  else:
    try_poly    = False
    try_expanal = False
    try_expmin  = False
  return run(
    f_obs            = fmodel_kbu.f_obs,
    f_calc           = fmodel_kbu.f_calc,
    f_mask           = fmodel_kbu.f_masks,
    r_free_flags     = r_free_flags,
    bulk_solvent     = bulk_solvent,
    try_poly         = try_poly,
    try_expanal      = try_expanal,
    try_expmin       = try_expmin,
    ss               = fmodel_kbu.ss,
    number_of_cycles = 100,
    bin_selections   = bin_selections)

class run(object):
  def __init__(self,
               f_obs,
               f_calc, # can be a sum: f_calc=f_hydrogens+f_calc+f_part
               f_mask, # only one shell is supported
               r_free_flags,
               ss,
               bin_selections=None,
               scale_method="combo",
               number_of_cycles=20, # termination occures much earlier
               auto_convergence_tolerance = 1.e-4,
               log=None,
               auto=True,
               auto_convergence=True,
               bulk_solvent = True,
               try_poly = True,
               try_expanal = True,
               try_expmin = False,
               verbose=False):
    if(log is None): log = sys.stdout
    self.d_hilo = 6
    assert f_obs.indices().all_eq(r_free_flags.indices())
    self.log = log
    self.scale_method = scale_method
    self.verbose = verbose
    self.r_free_flags = r_free_flags
    self.ss = ss
    self.bulk_solvent = bulk_solvent
    self.try_poly    = try_poly
    self.try_expanal = try_expanal
    self.try_expmin  = try_expmin
    self.d_spacings = f_obs.d_spacings()
    self.r_low = None
    self.poly_approx_cutoff = None
    self.f_obs = f_obs
    self.r_free_flags = r_free_flags
    self.auto_convergence = auto_convergence
    self.auto_convergence_tolerance = auto_convergence_tolerance
    self.scale_matrices = None
    self.auto = auto
    self.bin_selections = bin_selections
    self.k_exp_overall, self.b_exp_overall = None,None
    self.u_star = None
    if(self.bin_selections is None):
      self.bin_selections = self.f_obs.log_binning()
    # If R-free flags are bad - discard them and use all reflections instead.
    ifg = self.is_flags_good()
    if(ifg):
      self.selection_work = miller.array(
        miller_set = self.f_obs,
        data       = ~self.r_free_flags.data())
    else:
      self.selection_work = miller.array(
        miller_set = self.f_obs,
        data       = flex.bool(self.f_obs.data().size(), True))
    #
    self.ss = ss
    def init_result():
      return group_args(
        k_mask_bin_orig   = None,
        k_mask_bin_smooth = None,
        k_mask            = None,
        k_isotropic       = None,
        k_mask_fit_params = None)
    self.bss_result = init_result()
    if(verbose):
      print("-"*80, file=log)
      print("Overall, iso- and anisotropic scaling and bulk-solvent modeling:", file=log)
    point_group = sgtbx.space_group_info(
      symbol=f_obs.space_group().type().lookup_symbol()
      ).group().build_derived_point_group()
    self.adp_constraints = sgtbx.tensor_rank_2_constraints(
      space_group=point_group,
      reciprocal_space=True)
    self.core = mmtbx.arrays.init(f_calc = f_calc, f_masks = f_mask)
    if(abs(self.core.f_mask()).data().all_eq(0)): self.bulk_solvent=False
    self.cores_and_selections = []
    self.low_resolution_selection = self._low_resolution_selection()
    self.high_resolution_selection = self._high_resolution_selection()
    if(verbose):
      print("  Using %d resolution bins"%len(self.bin_selections), file=log)
    self.ss_bin_values=[]
    sel_positive = self.f_obs.data()>0
    self.selection_work = self.selection_work.customized_copy(
      data = self.selection_work.data() & sel_positive)
    for i_sel, sel in enumerate(self.bin_selections):
      core_selected = self.core.select(selection=sel)
      sel_use = self.selection_work.data().select(sel)
      sel_work = sel & self.selection_work.data()
      self.cores_and_selections.append([sel, core_selected, sel_use, sel_work])
      ss = self.ss.select(sel)
      self.ss_bin_values.append([
        flex.min(ss),
        flex.max(ss),
        flex.mean(ss)])
    for cycle in range(number_of_cycles):
      r_start = self.r_factor()
      r_start0 = r_start
      if(verbose):
        print("  cycle %d:"%cycle, file=log)
        print("    r(start): %6.4f"%(r_start), file=log)
      # bulk-solvent and overall isotropic scale
      if(self.bulk_solvent):
        if(cycle==0):
          # NEW
          #use_highres = False
          #if(self.f_obs.d_min() < self.d_hilo - 2):
          #  use_highres = True
          #if(use_highres):
          #  r_start = self.anisotropic_scaling(r_start = r_start, use_highres=True)
          #else:
          #  r_start = self.set_k_isotropic_exp(r_start = r_start, verbose=verbose)
          #
          #r_start = self.k_mask_grid_search(r_start=r_start)
          #
          #if(use_highres):
          #  r_start = self.anisotropic_scaling(r_start = r_start, use_highres=True)
          #else:
          #  r_start = self.set_k_isotropic_exp(r_start = r_start, verbose=verbose)
          # OLD
          for mic in [1,2]:
            r_start = self.set_k_isotropic_exp(r_start = r_start, verbose=verbose)
            r_start = self.k_mask_grid_search(r_start=r_start)
            r_start = self.set_k_isotropic_exp(r_start = r_start,  verbose=verbose)
        else:
          r_start = self.bulk_solvent_scaling(r_start = r_start)
          if(verbose):
            print("    r(bulk_solvent_scaling): %6.4f"%r_start, file=self.log)
      # anisotropic scale
      if([try_poly, try_expanal, try_expmin].count(True)):
        if(verbose): print("    anisotropic scaling:", file=log)
        r_start = self.anisotropic_scaling(r_start = r_start, use_highres=False)
      if(self.auto_convergence and self.is_converged(r_start=r_start0,
         tolerance=self.auto_convergence_tolerance)):
        break
    self.apply_overall_scale()
    if(verbose):
      print("  r(final): %6.4f"%(self.r_factor()), file=log)
      self.show()
    #
    self.r_low = self._r_low()
    self.r_high = self._r_high()
    if(verbose):
      d = self.d_spacings.data().select(self.low_resolution_selection)
      d1 = ("%7.4f"%flex.min(d)).strip()
      d2 = ("%7.4f"%flex.max(d)).strip()
      n = d.size()
      print("r(low-resolution: %s-%s A; %d reflections): %6.4f"%(
        d2,d1,n,self.r_low), file=self.log)
      print("-"*80, file=log)
    self.r_final = self.r_factor()

  def is_flags_good(self):
    """
    This function detects inadequate R-free flags.
    """
    result = True
    fd = self.r_free_flags.data()
    for i_sel, sel in enumerate(self.bin_selections):
      fd_ = fd.select(sel)
      if(fd_.count(True)==0):
        result = False
        break
    return result

  def set_k_isotropic_exp(self, r_start, verbose, b_lower_limit = -100):
    if(self.verbose):
      print("    set_k_isotropic_exp:", file=self.log)
      print("      r_start: %6.4f (r_low: %6.4f)"%(r_start,self._r_low()))
    k_iso   = flex.double(self.core.k_isotropic.size(), 1) # Done at start only!
    k_aniso = flex.double(self.core.k_isotropic.size(), 1) # Done at start only!
    arrays = mmtbx.arrays.init(
      f_calc          = self.core.f_calc,
      f_masks         = self.core.f_mask(),
      k_isotropic     = k_iso,
      k_anisotropic   = k_aniso,
      k_masks         = self.core.k_mask())
    sel = self.selection_work.data()
    #
    # At least in one example this gives more accurate answer but higher R than start!
    #
    rf = scitbx.math.gaussian_fit_1d_analytical(
      x = flex.sqrt(self.ss).select(sel),
      y = self.f_obs.data().select(sel),
      z = abs(arrays.f_model).data().select(sel))
    if(rf.b < b_lower_limit): return r_start
    k1 = rf.a * flex.exp(-self.ss * rf.b)
    r1 = self.try_scale(k_isotropic_exp = k1)
    #
    # At least in one example this gives less accurate answer but lower R than start!
    #
    o = bulk_solvent.f_kb_scaled(
      f1 = self.f_obs.data().select(sel),
      f2 = flex.abs(arrays.f_model.data()).select(sel),
      b_range = flex.double(range(-100,100,1)),
      ss = self.ss.select(sel))
    k2 = o.k() * flex.exp(-self.ss * o.b())
    r2 = self.try_scale(k_isotropic_exp = k2)
    #
    if(r1<r2):
      r = r1
      k = k1
    else:
      r = r2
      k = k2
    if(r<r_start):
      self.core = self.core.update(k_isotropic_exp = k)
    r = self.r_factor()
    if(self.verbose):
      print("      r1: %6.4f"%r1)
      print("      r2: %6.4f"%r2)
      print("      r_final: %6.4f (r_low: %6.4f)"%(r, self._r_low()))
    return r

  def try_scale(self,
                k_isotropic_exp=None,
                k_isotropic=None,
                k_mask=None,
                k_anisotropic=None,
                selection=None):
    if(k_isotropic_exp is None): k_isotropic_exp = self.core.k_isotropic_exp
    if(k_isotropic is None):     k_isotropic     = self.core.k_isotropic
    if(k_mask is None):          k_mask          = self.core.k_mask()
    if(k_anisotropic is None):   k_anisotropic   = self.core.k_anisotropic
    c = mmtbx.arrays.init(
      f_calc          = self.core.f_calc,
      f_masks         = self.core.f_mask(),
      k_isotropic_exp = k_isotropic_exp,
      k_isotropic     = k_isotropic,
      k_anisotropic   = k_anisotropic,
      k_masks         = k_mask)
    sel = self.selection_work.data()
    if(selection is not None): sel = selection & sel
    return bulk_solvent.r_factor(self.f_obs.data(), c.f_model.data(), sel)

  def r_all(self):
    return bulk_solvent.r_factor(self.f_obs.data(),
      self.core.f_model.data())

  def r_factor(self):
    return bulk_solvent.r_factor(self.f_obs.data(),
      self.core.f_model.data(), self.selection_work.data())

  def r_work(self):
    return bulk_solvent.r_factor(self.f_obs.data(),
      self.core.f_model.data(), ~self.r_free_flags.data())

  def _r_high(self):
    return bulk_solvent.r_factor(self.f_obs.data(),
      self.core.f_model.data(), self.high_resolution_selection)

  def _r_low(self):
    return bulk_solvent.r_factor(self.f_obs.data(),
      self.core.f_model.data(), self.low_resolution_selection)

  def _high_resolution_selection(self):
    return self.bin_selections[len(self.bin_selections)-1] & \
      self.selection_work.data()

  def _low_resolution_selection(self):
    return self.bin_selections[0] & self.selection_work.data()

  def populate_bin_to_individual_k_mask_linear_interpolation(self, k_mask_bin):
    assert len(k_mask_bin) == len(self.cores_and_selections)
    def linear_interpolation(x1,x2,y1,y2):
      k=0
      if(x1!=x2): k=(y2-y1)/(x2-x1)
      b = y1-k*x1
      return k,b
    result1 = flex.double(self.f_obs.size(), -1)
    result2 = flex.double(self.f_obs.size(), -1)
    result  = flex.double(self.f_obs.size(), -1)
    for i, cas in enumerate(self.cores_and_selections):
      selection, zzz, zzz, zzz = cas
      x1,x2 = self.ss_bin_values[i][0], self.ss_bin_values[i][1]
      y1 = k_mask_bin[i]
      if(i==len(k_mask_bin)-1):
        y2 = k_mask_bin[i-1]
      else:
        y2 = k_mask_bin[i+1]
      k,b = linear_interpolation(x1=x1,x2=x2,y1=y1,y2=y2)
      bulk_solvent.set_to_linear_interpolated(self.ss,k,b,selection,result1)
      result2.set_selected(selection, y1)
      r1 = self.try_scale(k_mask = result1, selection=selection) # XXX inefficient
      r2 = self.try_scale(k_mask = result2, selection=selection) # XXX inefficient
      if(r1<r2):
        bulk_solvent.set_to_linear_interpolated(self.ss,k,b,selection,result)
      else:
        result.set_selected(selection, y1)
    assert (result < 0).count(True) == 0
    return result

  def get_k_total(self, selection=None):
    if(selection is None):
      selection = flex.bool(self.core.k_isotropic.size(), True)
    scale = self.core.k_anisotropic.select(selection) * \
            self.core.k_isotropic.select(selection) * \
            self.core.k_isotropic_exp.select(selection)
    scale_k1 = bulk_solvent.scale(
      self.f_obs.data(),
      self.core.f_model.data(), selection)
    return scale*scale_k1

  def k_mask_grid_search(self, r_start):
    if(self.verbose):
      print("    k_mask_grid_search:", file=self.log)
      print("      r_start: %6.4f (r_low: %6.4f)"%(r_start,self._r_low()))
    #k_mask_trial_range = flex.double([i/1000. for i in range(0,650,50)])
    k_mask_trial_range = flex.double([i/1000. for i in range(0,1010,10)])
    k_mask             = flex.double(self.f_obs.size(), 0)
    k_mask_bin         = flex.double()
    k_isotropic        = flex.double(self.f_obs.size(), 0)
    k_total = self.get_k_total()
    for i_cas, cas in enumerate(self.cores_and_selections):
      selection, core, selection_use, sel_work = cas
      f_obs = self.f_obs.select(selection)
      k_total_ = k_total.select(selection)
      k_mask_bin_, k_isotropic_bin_ = \
        bulk_solvent.k_mask_and_k_overall_grid_search(
          f_obs.data()/k_total_,
          core.f_calc.data(),
          core.f_mask().data(),
          k_mask_trial_range,
          selection_use)
      k_mask_bin.append(k_mask_bin_)
      k_mask.set_selected(selection, k_mask_bin_)
      k_isotropic.set_selected(selection, k_isotropic_bin_)

    k_mask_bin_smooth = self.smooth(k_mask_bin)
    k_mask = self.populate_bin_to_individual_k_mask_linear_interpolation(
      k_mask_bin = k_mask_bin_smooth)

    r_try = self.try_scale(k_mask = k_mask, k_isotropic = k_isotropic)
    if(r_try<r_start):
      self.core = self.core.update(k_masks = k_mask, k_isotropic = k_isotropic)
      # ????
      self.bss_result.k_mask_bin_orig   = k_mask_bin
      self.bss_result.k_mask_bin_smooth = k_mask_bin_smooth
      self.bss_result.k_mask            = k_mask
      self.bss_result.k_isotropic       = k_isotropic
    r = self.r_factor()
    if(self.verbose):
      print("      r_final: %6.4f (r_low: %6.4f)"%(r,self._r_low()))
    return r

  def apply_overall_scale(self):
    scale_k1 = bulk_solvent.scale(self.f_obs.data(),
      self.core.f_model.data(), self.selection_work.data())
    self.core = self.core.update(k_isotropic = self.core.k_isotropic*scale_k1)

  def is_converged(self, r_start, tolerance=1.e-4):
    self.r_final = self.r_factor()
    result = False
    if((r_start<=self.r_final) or
       (r_start>self.r_final and abs(r_start-self.r_final)<tolerance)):
      result = True
    diff = abs(round(r_start,4)-round(self.r_final,4))
    if(diff<tolerance): result = True
    return result

  def show(self):
    b = self.bss_result
    print("  Statistics in resolution bins:", file=self.log)
    fmt="  %7.5f %6.2f -%6.2f %5.1f %5d %-6s %-6s %-6s  %6.3f %6.3f %8.2f %6.4f"
    f_model = self.core.f_model.data()
    print("  s^2      Resolution    Compl Nrefl k_mask                 k_iso  k_ani <Fobs>   R", file=self.log)
    print("                (A)        (%)       orig   smooth average", file=self.log)
    k_mask_bin_orig_   = str(None)
    k_mask_bin_smooth_ = str(None)
    k_mask_bin_approx_ = str(None)
    for i_sel, cas in enumerate(self.cores_and_selections):
      selection, core, selection_use, sel_work = cas
      sel = sel_work
      ss_ = self.ss_bin_values[i_sel][2]
      if(b is not None and self.bss_result.k_mask_bin_orig is not None):
        k_mask_bin_orig_ = "%6.4f"%self.bss_result.k_mask_bin_orig[i_sel]
      if(b is not None and self.bss_result.k_mask_bin_smooth is not None):
        k_mask_bin_smooth_ = "%6.4f"%self.bss_result.k_mask_bin_smooth[i_sel]
      k_mask_bin_averaged_ = "%6.4f"%flex.mean(self.core.k_mask().select(sel))
      d_             = self.d_spacings.data().select(sel)
      d_min_         = flex.min(d_)
      d_max_         = flex.max(d_)
      n_ref_         = d_.size()
      f_obs_         = self.f_obs.select(sel)
      f_obs_mean_    = flex.mean(f_obs_.data())
      k_isotropic_   = flex.mean(self.core.k_isotropic.select(sel))
      k_anisotropic_ = flex.mean(self.core.k_anisotropic.select(sel))
      cmpl_          = f_obs_.completeness(d_max=d_max_)*100.
      r_             = bulk_solvent.r_factor(f_obs_.data(),f_model.select(sel))
      print(fmt%(ss_, d_max_, d_min_, cmpl_, n_ref_,
        k_mask_bin_orig_, k_mask_bin_smooth_,k_mask_bin_averaged_,
        k_isotropic_, k_anisotropic_, f_obs_mean_, r_), file=self.log)

  def _k_isotropic_as_scale_k1(self, r_start, k_mask=None):
    k_isotropic = flex.double(self.ss.size(), -1)
    if(k_mask is None): k_mask = self.core.k_mask()
    core_data = mmtbx.arrays.init(
      f_calc          = self.core.f_calc,
      f_masks         = self.core.f_mask(),
      k_isotropic_exp = self.core.k_isotropic_exp,
      k_anisotropic   = self.core.k_anisotropic,
      k_masks         = k_mask).data
    for i_cas, cas in enumerate(self.cores_and_selections):
      selection, core, selection_use, sel_work = cas
      scale_k1 = bulk_solvent.scale(self.f_obs.data(),
        core_data.f_model, sel_work)
      k_isotropic = k_isotropic.set_selected(selection, scale_k1)
    assert k_isotropic.count(-1.) == 0
    return k_isotropic

  def estimate_scale_k1(self, cutoff=4, width=1, min_reflections=500):
    cutoff = min(cutoff, self.f_obs.d_min()+width)
    sel_high = self.d_spacings.data()<cutoff
    sel_high = sel_high & self.selection_work.data()
    scale_k1 = 1
    if(sel_high.count(True)>min_reflections):
      core = self.core.select(selection = sel_high)
      f_obs = self.f_obs.select(sel_high)
      fm = core.k_isotropic_exp * core.k_anisotropic * (core.f_calc.data() +
        core.k_mask() * core.f_mask().data())
      scale_k1 = bulk_solvent.scale(f_obs.data(), fm)
    return scale_k1

  def bulk_solvent_scaling(self, r_start):
    if(self.verbose):
      print("    bulk_solvent_scaling:", file=self.log)
      print("      r_start: %6.4f (r_low: %6.4f)"%(r_start,self._r_low()))
    k_mask     = flex.double(self.f_obs.size(), -1)
    k_mask_bin = flex.double()
    k_mask_trial_range = flex.double([i/1000. for i in range(0,1000,10)])
    k_total = self.get_k_total()
    def get_k_mask_trial_range(x, shift=0.05):
      result = flex.double([x])
      if(x > 1): x = 1
      inc = max(0,x-shift)
      while inc<=x+shift+1.e-3:
        result.append(inc)
        inc+=0.01
      return result
    for i_cas, cas in enumerate(self.cores_and_selections):
      selection, core, selection_use, sel_work = cas
      f_obs  = self.f_obs.select(selection).data()
      f_calc = core.f_calc.data()  *k_total.select(selection)
      f_mask = core.f_mask().data()*k_total.select(selection)
      if(self.scale_method == "k_iso_k_mask_anal"):
        obj = bulk_solvent.overall_and_bulk_solvent_scale_coefficients_analytical(
          f_obs     = f_obs,
          f_calc    = f_calc,
          f_mask    = f_mask,
          selection = selection_use)
        k_mask_bin.append(obj.x_best)
        k_mask.set_selected(selection, obj.x_best)
      elif(self.scale_method == "k_mask_anal"):
        obj = bulk_solvent.bulk_solvent_scale_coefficients_analytical(
          f_obs     = f_obs,
          f_calc    = f_calc,
          f_mask    = f_mask,
          selection = selection_use)
        k_mask_bin.append(obj.x_best)
        k_mask.set_selected(selection, obj.x_best)
      elif(self.scale_method == "k_mask_r_grid_search"):
        k_mask_bin_, k_isotropic_bin_ = \
          bulk_solvent.k_mask_and_k_overall_grid_search(
            f_obs,
            f_calc,
            f_mask,
            k_mask_trial_range,
            selection_use)
        k_mask_bin.append(k_mask_bin_)
        k_mask.set_selected(selection, k_mask_bin_)
      elif(self.scale_method == "combo"):
        r = flex.double()
        k = flex.double()
        #
        if(self.bss_result.k_mask_bin_orig is not None):
          x0 = self.bss_result.k_mask_bin_orig[i_cas]
          k_mask.set_selected(selection, x0)
          r0 = self.try_scale(k_mask = k_mask, selection=selection)
          r.append(r0)
          k.append(x0)
        #
        fmv = flex.min(flex.abs(f_mask).select(selection_use))
        if(abs(fmv)>1.e-9):
          obj1 = bulk_solvent.overall_and_bulk_solvent_scale_coefficients_analytical(
            f_obs     = f_obs,
            f_calc    = f_calc,
            f_mask    = f_mask,
            selection = selection_use)
          k_mask.set_selected(selection, obj1.x_best)
          k.append(obj1.x_best)
        else:
          k_mask.set_selected(selection, 0)
          k.append(0)
        r.append(self.try_scale(k_mask = k_mask, selection=selection))
        #
        s = flex.sort_permutation(r)
        x = k.select(s)[0]
        # fine-sample k_mask around minimum of LS to fall into minimum of R
        k_mask_bin_, k_isotropic_bin_ = \
          bulk_solvent.k_mask_and_k_overall_grid_search(
            f_obs,
            f_calc,
            f_mask,
            get_k_mask_trial_range(x = x),
            selection_use)
        k_mask_bin.append(k_mask_bin_)
        k_mask.set_selected(selection, k_mask_bin_)

        #k_mask_bin.append(x)
        #k_mask.set_selected(selection, x)
      else: assert 0
    #
    k_mask_bin_smooth = self.smooth(k_mask_bin)
    k_mask = self.populate_bin_to_individual_k_mask_linear_interpolation(
      k_mask_bin = k_mask_bin_smooth)
    k_isotropic = self._k_isotropic_as_scale_k1(r_start=r_start,k_mask = k_mask)

    r_try = self.try_scale(k_mask = k_mask, k_isotropic = k_isotropic)
    if(r_try<r_start):
      self.core = self.core.update(k_isotropic = k_isotropic, k_masks = k_mask)
    r = self.r_factor()
    if(self.verbose):
      print("      r_final: %6.4f (r_low: %6.4f)"%(r,self._r_low()))
    return r

  def smooth(self, x):
    result = moving_average(x = x)
    result_ = flex.double(len(result), 0)
    for i, r in enumerate(result):
      d = 1/math.sqrt(self.ss_bin_values[i][1])/2
      if(r==0 and d<3): break
      result_[i]=r
    return result_

  def format_scale_matrix(self, m=None, log=None):
    sm = m
    if(sm is None): sm = self.scale_matrices
    out = log
    if(sm is None):
      print("  k_anisotropic=1", file=log)
      return
    if(len(sm)<=6):
      print("      b_cart(11,22,33,12,13,23):",\
        ",".join([str("%8.4f"%i).strip() for i in sm]), file=out)
    else:
      v0=[]
      v1=[]
      for i, a in enumerate(sm):
        if(i in [0,2,4,6,8,10]): v1.append(a)
        else: v0.append(a)
      print("      V0:",\
        ",".join([str("%8.4f"%i).strip() for i in v0]), file=out)
      print("      V1:",\
        ",".join([str("%8.4f"%i).strip() for i in v1]), file=out)

  def anisotropic_scaling(self, r_start, use_highres):
    r_expanal, r_poly, r_expmin = None,None,None
    k_anisotropic_expanal, k_anisotropic_poly, \
      k_anisotropic_expmin = None, None, None
    scale_matrix_expanal, scale_matrix_poly, scale_matrix_expmin= None,None,None
    sel         = self.selection_work.data()

    if(use_highres):
      sel_ = self.f_obs.d_spacings().data() < self.d_hilo
      sel = sel & sel_


    f_model_abs = flex.abs(self.core.f_model_no_aniso_scale.data().select(sel))
    f_obs       = self.f_obs.data().select(sel)
    mi          = self.f_obs.indices().select(sel)
    uc          = self.f_obs.unit_cell()
    mi_all      = self.f_obs.indices()
    # try exp_anal
    if(self.try_expanal):
      obj = bulk_solvent.aniso_u_scaler(
        f_model_abs    = f_model_abs,
        f_obs          = f_obs,
        miller_indices = mi,
        adp_constraint_matrix = self.adp_constraints.gradient_sum_matrix())
      u_star = self.adp_constraints.all_params(tuple(obj.u_star_independent))
      scale_matrix_expanal = adptbx.u_as_b(adptbx.u_star_as_u_cart(uc, u_star))
      k_anisotropic_expanal = ext.k_anisotropic(mi_all, u_star)
      r_expanal = self.try_scale(k_anisotropic = k_anisotropic_expanal)
      if(self.verbose):
        print("      r_expanal: %6.4f"%r_expanal, file=self.log)
    # try poly
    if(self.try_poly):
      obj = bulk_solvent.aniso_u_scaler(
        f_model_abs    = f_model_abs,
        f_obs          = f_obs,
        miller_indices = mi,
        unit_cell      = uc)
      scale_matrix_poly = obj.a
      k_anisotropic_poly = ext.k_anisotropic(mi_all, obj.a, uc)
      r_poly = self.try_scale(k_anisotropic = k_anisotropic_poly)
      if(self.verbose):
        print("      r_poly   : %6.4f"%r_poly, file=self.log)
    # pre-analyze
    force_to_use_expmin=False
    if(k_anisotropic_poly is not None and self.auto and r_poly<r_expanal and
       (k_anisotropic_poly<=0).count(True)>0):
      force_to_use_expmin = True
      self.try_expmin = True
    # try expmin
    if(self.try_expmin):
      zero = self.f_obs.select(sel).customized_copy(data =
        flex.complex_double(f_obs.size(), 0))
      if(self.u_star is None): self.u_star = [0,0,0,0,0,0]
      fm = mmtbx.f_model.manager_kbu(
        f_obs         = self.f_obs.select(sel),
        f_calc        = self.core.f_model_no_aniso_scale.select(sel),
        f_masks       = [zero],
        f_part1       = zero,
        f_part2       = zero,
        ss            = self.ss)
      obj = kbu_refinery.tgc(
        f_obs   = self.f_obs.select(sel),
        f_calc  = self.core.f_model_no_aniso_scale.select(sel),
        f_masks = [zero],
        ss      = self.ss,
        k_sols  = [0,],
        b_sols  = [0,],
        u_star  = self.u_star)
      obj.minimize_u()
      u_star = obj.kbu.u_star()
      self.u_star = u_star
      scale_matrix_expmin = adptbx.u_as_b(adptbx.u_star_as_u_cart(uc, u_star))
      k_anisotropic_expmin = ext.k_anisotropic(mi_all, u_star)
      r_expmin = self.try_scale(k_anisotropic = k_anisotropic_expmin)
      if(self.verbose): print("    r_expmin   : %6.4f"%r_expmin, file=self.log)
      if(force_to_use_expmin):
        self.core = self.core.update(k_anisotropic = k_anisotropic_expmin)
        if(self.verbose):
          self.format_scale_matrix(m=scale_matrix_expmin)
        return self.r_factor()
    # select best
    r = [(r_expanal, k_anisotropic_expanal, scale_matrix_expanal),
         (r_poly,    k_anisotropic_poly,    scale_matrix_poly),
         (r_expmin,  k_anisotropic_expmin,  scale_matrix_expmin)]
    r_best = r_start
    k_anisotropic_best = None
    scale_matrix_best = None
    for result in r:
      r_factor, k_anisotropic, scale_matrix = result
      if(r_factor is not None and r_factor < r_best):
        r_best = r_factor
        k_anisotropic_best = k_anisotropic.deep_copy()
        scale_matrix_best = scale_matrix[:]
    if(scale_matrix_best is None):
      if(self.verbose):
        print("      result rejected due to r-factor increase", file=self.log)
    else:
      self.scale_matrices = scale_matrix_best
      self.core = self.core.update(k_anisotropic = k_anisotropic_best)
      r_aniso = self.r_factor()
      if(self.verbose):
        self.format_scale_matrix()
        print("      r_final  : %6.4f"%r_aniso, file=self.log)
    return r_best

  def overall_isotropic_kb_estimate(self):
    k_total = self.core.k_isotropic * self.core.k_anisotropic * \
      self.core.k_isotropic_exp
    r = scitbx.math.gaussian_fit_1d_analytical(x=flex.sqrt(self.ss), y=k_total)
    return r.a, r.b

  def k_masks(self):
    return self.core.k_masks

  def k_isotropic(self):
    return self.core.k_isotropic*self.core.k_isotropic_exp

  def k_anisotropic(self):
    return self.core.k_anisotropic

  def apply_back_trace_of_overall_exp_scale_matrix(self, xray_structure=None):
    k,b=self.overall_isotropic_kb_estimate()
    k_total = self.core.k_isotropic * self.core.k_anisotropic * \
      self.core.k_isotropic_exp
    k,b,r = mmtbx.bulk_solvent.fit_k_exp_b_to_k_total(k_total, self.ss, k, b)
    if(r<0.7): self.k_exp_overall,self.b_exp_overall = k,b
    if(xray_structure is None): return None
    b_adj = 0
    if([self.k_exp_overall,self.b_exp_overall].count(None)==0 and k != 0):
      bs1 = xray_structure.extract_u_iso_or_u_equiv()*adptbx.u_as_b(1.)
      def split(b_trace, xray_structure):
        b_min = xray_structure.min_u_cart_eigenvalue()*adptbx.u_as_b(1.)
        b_res = min(0, b_min + b_trace+1.e-6)
        b_adj = b_trace-b_res
        xray_structure.shift_us(b_shift = b_adj)
        return b_adj, b_res
      b_adj,b_res=split(b_trace=self.b_exp_overall,xray_structure=xray_structure)
      k_new = self.k_exp_overall*flex.exp(-self.ss*b_adj)
      bs2 = xray_structure.extract_u_iso_or_u_equiv()*adptbx.u_as_b(1.)
      diff = bs2-bs1
      assert approx_equal(flex.min(diff), flex.max(diff))
      assert approx_equal(flex.max(diff), b_adj)
      self.core = self.core.update(
        k_isotropic = self.core.k_isotropic,
        k_isotropic_exp = self.core.k_isotropic_exp/k_new,
        k_masks = [m*flex.exp(-self.ss*b_adj) for m in self.core.k_masks])
    return group_args(
      xray_structure = xray_structure,
      k_isotropic    = self.k_isotropic(),
      k_anisotropic  = self.k_anisotropic(),
      k_mask         = self.k_masks(),
      b_adj          = b_adj)

# XXX SEVERE DUPLICATION
# XXX Consolidate with analogous function in bulk_solvnet_and_scaling.py :
# XXX apply_back_trace_of_overall_exp_scale_matrix
class tmp(object):
  def __init__(self, xray_structure, k_anisotropic, k_masks, ss):
    self.xray_structure = xray_structure
    self.k_anisotropic  = k_anisotropic
    self.k_masks        = k_masks
    self.ss             = ss
    #
    k_total = self.k_anisotropic
    r = scitbx.math.gaussian_fit_1d_analytical(x=flex.sqrt(self.ss), y=k_total)
    k,b = r.a, r.b
    #
    k,b,r = mmtbx.bulk_solvent.fit_k_exp_b_to_k_total(k_total, self.ss, k, b)
    k_exp_overall, b_exp_overall = None,None
    if(r<0.7): k_exp_overall, b_exp_overall = k,b
    if(self.xray_structure is None): return None
    b_adj = 0
    if([k_exp_overall, b_exp_overall].count(None)==0 and k != 0):
      bs1 = self.xray_structure.extract_u_iso_or_u_equiv()*adptbx.u_as_b(1.)
      def split(b_trace, xray_structure):
        b_min = xray_structure.min_u_cart_eigenvalue()*adptbx.u_as_b(1.)
        b_res = min(0, b_min + b_trace+1.e-6)
        b_adj = b_trace-b_res
        xray_structure.shift_us(b_shift = b_adj)
        return b_adj, b_res
      b_adj,b_res=split(b_trace=b_exp_overall,xray_structure=self.xray_structure)
      k_new = k_exp_overall*flex.exp(-self.ss*b_adj)
      bs2 = self.xray_structure.extract_u_iso_or_u_equiv()*adptbx.u_as_b(1.)
      diff = bs2-bs1
      assert approx_equal(flex.min(diff), flex.max(diff))
      assert approx_equal(flex.max(diff), b_adj)
      self.k_anisotropic = self.k_anisotropic/k_new
      self.k_masks = [m*flex.exp(-self.ss*b_adj) for m in self.k_masks]


 *******************************************************************************


 *******************************************************************************
mmtbx/bulk_solvent/tst_aniso_scaler.py
from __future__ import absolute_import, division, print_function
from libtbx.test_utils import approx_equal
import mmtbx.f_model
import random, time
from scitbx.array_family import flex
from mmtbx import bulk_solvent
from cctbx import adptbx
from cctbx import sgtbx
from cctbx.development import random_structure
import boost_adaptbx.boost.python as bp
ext = bp.import_ext("mmtbx_f_model_ext")
from mmtbx import bulk_solvent

if(1):
  random.seed(0)
  flex.set_random_seed(0)

def run_00():
  time_aniso_u_scaler = 0
  for symbol in sgtbx.bravais_types.acentric + sgtbx.bravais_types.centric:
    #print symbol, "-"*50
    space_group_info = sgtbx.space_group_info(symbol = symbol)
    xrs = random_structure.xray_structure(
      space_group_info  = space_group_info,
      elements          = ["N"]*100,
      volume_per_atom   = 50.0,
      random_u_iso      = True)
    # XXX ad a method to adptbx to do this
    point_group = sgtbx.space_group_info(
      symbol=symbol).group().build_derived_point_group()
    adp_constraints = sgtbx.tensor_rank_2_constraints(
      space_group=point_group,
      reciprocal_space=True)
    u_star = adptbx.u_cart_as_u_star(xrs.unit_cell(),
      adptbx.random_u_cart(u_scale=1,u_min=0.1))
    u_indep = adp_constraints.independent_params(all_params=u_star)
    u_star = adp_constraints.all_params(independent_params=u_indep)
    b_cart_start=adptbx.u_as_b(adptbx.u_star_as_u_cart(xrs.unit_cell(), u_star))
    #
    tr = (b_cart_start[0]+b_cart_start[1]+b_cart_start[2])/3
    b_cart_start = [b_cart_start[0]-tr,b_cart_start[1]-tr,b_cart_start[2]-tr,
           b_cart_start[3],b_cart_start[4],b_cart_start[5]]
    tr = (b_cart_start[0]+b_cart_start[1]+b_cart_start[2])/3
    #
    #print "Input b_cart :", " ".join(["%8.4f"%i for i in b_cart_start]), "tr:", tr
    F = xrs.structure_factors(d_min = 2.0).f_calc()
    u_star = adptbx.u_cart_as_u_star(
      F.unit_cell(), adptbx.b_as_u(b_cart_start))
    fbc = mmtbx.f_model.ext.k_anisotropic(F.indices(), u_star)
    fc = F.structure_factors_from_scatterers(xray_structure=xrs).f_calc()
    f_obs = F.customized_copy(data = flex.abs(fc.data()*fbc))
    t0 = time.time()
    #
    obj = bulk_solvent.aniso_u_scaler(
      f_model_abs    = flex.abs(fc.data()),
      f_obs          = f_obs.data(),
      miller_indices = f_obs.indices(),
      adp_constraint_matrix = adp_constraints.gradient_sum_matrix())
    time_aniso_u_scaler += (time.time()-t0)
    b_cart_final = adptbx.u_as_b(adptbx.u_star_as_u_cart(f_obs.unit_cell(),
      adp_constraints.all_params(tuple(obj.u_star_independent))))
    #
    obj = bulk_solvent.aniso_u_scaler(
      f_model_abs    = flex.abs(fc.data()),
      f_obs          = f_obs.data(),
      miller_indices = f_obs.indices())
    b_cart_final2 = adptbx.u_as_b(adptbx.u_star_as_u_cart(f_obs.unit_cell(),
      tuple(obj.u_star)))
    #
    assert approx_equal(b_cart_final, b_cart_final2)
    #print "Output b_cart:", " ".join(["%8.4f"%i for i in b_cart_final])
    assert approx_equal(b_cart_start, b_cart_final, 1.e-4)
  print("Time (aniso_u_scaler only): %6.4f"%time_aniso_u_scaler)

def run_01():
  time_aniso_u_scaler = 0
  for symbol in sgtbx.bravais_types.acentric + sgtbx.bravais_types.centric:
    #print symbol, "-"*50
    space_group_info = sgtbx.space_group_info(symbol = symbol)
    xrs = random_structure.xray_structure(
      space_group_info  = space_group_info,
      elements          = ["N"]*100,
      volume_per_atom   = 50.0,
      random_u_iso      = True)
    # XXX ad a method to adptbx to do this
    point_group = sgtbx.space_group_info(
      symbol=symbol).group().build_derived_point_group()
    adp_constraints = sgtbx.tensor_rank_2_constraints(
      space_group=point_group,
      reciprocal_space=True)
    u_star = adptbx.u_cart_as_u_star(xrs.unit_cell(),
      adptbx.random_u_cart(u_scale=1,u_min=0.1))
    u_indep = adp_constraints.independent_params(all_params=u_star)
    u_star = adp_constraints.all_params(independent_params=u_indep)
    b_cart_start=adptbx.u_as_b(adptbx.u_star_as_u_cart(xrs.unit_cell(), u_star))
    #
    tr = (b_cart_start[0]+b_cart_start[1]+b_cart_start[2])/3
    b_cart_start = [b_cart_start[0]-tr,b_cart_start[1]-tr,b_cart_start[2]-tr,
           b_cart_start[3],b_cart_start[4],b_cart_start[5]]
    tr = (b_cart_start[0]+b_cart_start[1]+b_cart_start[2])/3
    #
    #print "Input b_cart :", " ".join(["%8.4f"%i for i in b_cart_start]), "tr:", tr
    F = xrs.structure_factors(d_min = 2.0).f_calc()
    F = xrs.structure_factors(d_min = 2.0).f_calc()
    u_star = adptbx.u_cart_as_u_star(
      F.unit_cell(), adptbx.b_as_u(b_cart_start))
    fbc = mmtbx.f_model.ext.k_anisotropic(F.indices(), u_star)
    fc = F.structure_factors_from_scatterers(xray_structure=xrs).f_calc()
    f_obs = F.customized_copy(data = flex.abs(fc.data()*fbc))
    #print bulk_solvent.r_factor(f_obs.data(), fmodel.f_model().data())
    obj = bulk_solvent.aniso_u_scaler(
      f_model_abs    = flex.abs(fc.data()),
      f_obs          = f_obs.data(),
      miller_indices = f_obs.indices(),
      unit_cell      = f_obs.unit_cell())
    a = obj.a
    ####
    #print "Input a :", " ".join(["%7.3f"%i for i in a])
    overall_anisotropic_scale = mmtbx.f_model.ext.k_anisotropic(
      f_obs.indices(), a, f_obs.unit_cell())
    #print bulk_solvent.r_factor(f_obs.data(), fmodel.f_model().data()*overall_anisotropic_scale)
    f_obs = abs(fc)
    f_obs = f_obs.customized_copy(data = f_obs.data() * overall_anisotropic_scale)
    #print bulk_solvent.r_factor(f_obs.data(), fmodel.f_model().data())
    #print bulk_solvent.r_factor(f_obs.data(), fmodel.f_model().data())
    t0 = time.time()
    obj = bulk_solvent.aniso_u_scaler(
      f_model_abs    = flex.abs(fc.data()),
      f_obs          = f_obs.data(),
      miller_indices = f_obs.indices(),
      unit_cell      = f_obs.unit_cell())
    time_aniso_u_scaler += (time.time()-t0)
    overall_anisotropic_scale = mmtbx.f_model.ext.k_anisotropic(
      f_obs.indices(), obj.a, f_obs.unit_cell())
    assert approx_equal(bulk_solvent.r_factor(f_obs.data(),
      fc.data()*overall_anisotropic_scale), 0.0, 1.e-2) # XXX seems to be low
    #print "Output a:", " ".join(["%7.3f"%i for i in obj.a])
    assert approx_equal(a, obj.a, 1.e-3) # XXX can it be smaller?
  print("Time (aniso_u_scaler only): %6.4f"%time_aniso_u_scaler)

def run_02():
  time_aniso_u_scaler = 0
  for symbol in sgtbx.bravais_types.acentric + sgtbx.bravais_types.centric:
    #print symbol, "-"*50
    space_group_info = sgtbx.space_group_info(symbol = symbol)
    xrs = random_structure.xray_structure(
      space_group_info  = space_group_info,
      elements          = ["N"]*100,
      volume_per_atom   = 50.0,
      random_u_iso      = True)
    xrs.scattering_type_registry(table = "wk1995")
    # XXX ad a method to adptbx to do this
    point_group = sgtbx.space_group_info(
      symbol=symbol).group().build_derived_point_group()
    adp_constraints = sgtbx.tensor_rank_2_constraints(
      space_group=point_group,
      reciprocal_space=True)
    u_star = adptbx.u_cart_as_u_star(xrs.unit_cell(),
      adptbx.random_u_cart(u_scale=1,u_min=0.1))
    u_indep = adp_constraints.independent_params(all_params=u_star)
    u_star = adp_constraints.all_params(independent_params=u_indep)
    b_cart_start=adptbx.u_as_b(adptbx.u_star_as_u_cart(xrs.unit_cell(), u_star))
    #
    tr = (b_cart_start[0]+b_cart_start[1]+b_cart_start[2])/3
    b_cart_start = [b_cart_start[0]-tr,b_cart_start[1]-tr,b_cart_start[2]-tr,
           b_cart_start[3],b_cart_start[4],b_cart_start[5]]
    tr = (b_cart_start[0]+b_cart_start[1]+b_cart_start[2])/3
    #
    #print "Input b_cart :", " ".join(["%8.4f"%i for i in b_cart_start]), "tr:", tr
    reg = xrs.scattering_type_registry(table="wk1995", d_min=1/12)
    f_000 = reg.sum_of_scattering_factors_at_diffraction_angle_0()
    F = xrs.structure_factors(d_min = 2.0).f_calc()
    i = F.indices()
    i.append([0,0,0])
    d = F.data()
    d.append(f_000)
    F = F.customized_copy(indices = i, data = d)

    u_star = adptbx.u_cart_as_u_star(
      F.unit_cell(), adptbx.b_as_u(b_cart_start))
    fbc = mmtbx.f_model.ext.k_anisotropic(F.indices(), u_star)
    fc = F.structure_factors_from_scatterers(xray_structure=xrs).f_calc()
    f_obs = F.customized_copy(data = flex.abs(fc.data()*fbc))
    #print bulk_solvent.r_factor(f_obs.data(), fmodel.f_model().data())
    obj = bulk_solvent.aniso_u_scaler(
      f_model_abs    = flex.abs(fc.data()),
      f_obs          = f_obs.data(),
      miller_indices = f_obs.indices(),
      unit_cell      = f_obs.unit_cell())
    a = obj.a
    ####
    #print "Input a :", " ".join(["%7.3f"%i for i in a])
    overall_anisotropic_scale = mmtbx.f_model.ext.k_anisotropic(
      f_obs.indices(), a, f_obs.unit_cell())
    #print bulk_solvent.r_factor(f_obs.data(), fmodel.f_model().data()*overall_anisotropic_scale)
    f_obs = abs(fc)
    f_obs = f_obs.customized_copy(data = f_obs.data() * overall_anisotropic_scale)
    #print bulk_solvent.r_factor(f_obs.data(), fmodel.f_model().data())
    #print bulk_solvent.r_factor(f_obs.data(), fmodel.f_model().data())
    t0 = time.time()
    obj = bulk_solvent.aniso_u_scaler(
      f_model_abs    = flex.abs(fc.data()),
      f_obs          = f_obs.data(),
      miller_indices = f_obs.indices(),
      unit_cell      = f_obs.unit_cell())
    time_aniso_u_scaler += (time.time()-t0)
    overall_anisotropic_scale = mmtbx.f_model.ext.k_anisotropic(
      f_obs.indices(), obj.a, f_obs.unit_cell())
    assert approx_equal(bulk_solvent.r_factor(f_obs.data(),
      fc.data()*overall_anisotropic_scale), 0.0, 1.e-2) # XXX seems to be low
    #print "Output a:", " ".join(["%7.3f"%i for i in obj.a])
    assert approx_equal(a, obj.a, 1.e-4) # XXX can it be smaller?
    assert overall_anisotropic_scale[len(overall_anisotropic_scale)-1]==1
  print("Time (aniso_u_scaler only): %6.4f"%time_aniso_u_scaler)

if (__name__ == "__main__"):
  t0 = time.time()
  run_00()
  run_01()
  run_02() # same as run_01 but with f000 added
  print("Time: %6.4f"%(time.time()-t0))
  print("OK")


 *******************************************************************************


 *******************************************************************************
mmtbx/bulk_solvent/tst_bulk_solvent_and_scaling.py
from __future__ import absolute_import, division, print_function
from iotbx import pdb
from cctbx.array_family import flex
import os
from libtbx.test_utils import approx_equal
from libtbx.utils import format_cpu_times
import mmtbx.bulk_solvent.bulk_solvent_and_scaling as bss
import random
import mmtbx.f_model
from cctbx import sgtbx
import cctbx.sgtbx.bravais_types
from cctbx.development import random_structure
import libtbx.load_env
from cctbx import adptbx
from six.moves import zip
from six.moves import range

if (1): # fixed random seed to avoid rare failures
  random.seed(0)
  flex.set_random_seed(0)

def get_xray_structure_from_file():
  pdb_file = libtbx.env.find_in_repositories(
    relative_path="phenix_regression/pdb/2ERL_noH.pdb", test=os.path.isfile)
  xray_structure = pdb.input(file_name=pdb_file).xray_structure_simple()
  return xray_structure

def get_xray_structure_random(space_group_info):
  xray_structure = random_structure.xray_structure(
      space_group_info  = space_group_info,
      elements          = ["N"]*100,
      volume_per_atom   = 50.0,
      random_u_iso      = True)
  return xray_structure

def get_f_obs_freer(d_min, k_sol, b_sol, b_cart, xray_structure,
    radial_shell_width=None):
  f_dummy = abs(xray_structure.structure_factors(d_min = d_min,
    anomalous_flag = False).f_calc())
  r_free_flags = f_dummy.generate_r_free_flags(fraction = 0.1,
                                               max_free = 99999999)
  mask_params = mmtbx.masks.mask_master_params.extract()
  if( radial_shell_width is not None ):
    mask_params.radial_shell_width = radial_shell_width
  if( type(k_sol) is list):
    mask_params.n_radial_shells = len(k_sol)
  fmodel = mmtbx.f_model.manager(
    mask_params    = mask_params,
    r_free_flags   = r_free_flags,
    f_obs          = f_dummy,
    xray_structure = xray_structure)
  fmodel.update_xray_structure(
    xray_structure = xray_structure,
    update_f_calc  = True,
    update_f_mask  = True)
  fmodel_kbu = fmodel.fmodel_kbu()
  fmodel_kbu.update(
    k_sols = k_sol,
    b_sols = b_sol,
    b_cart = b_cart)
  f_obs = abs(fmodel_kbu.f_model)
  return f_obs, r_free_flags

def get_sf(k_sol, b_sol, b_cart, xrs, miller_set=None, d_min=None, twin_law=None,
           sfg_params=None):
  random.seed(0)
  flex.set_random_seed(0)
  if(miller_set is None):
    assert d_min is not None
    f_dummy = abs(xrs.structure_factors(d_min = d_min,
      anomalous_flag = False).f_calc())
  else:
    f_dummy = miller_set
    assert d_min is None
  r_free_flags = f_dummy.generate_r_free_flags(fraction = 0.1)
  fmodel = mmtbx.f_model.manager(
    r_free_flags   = r_free_flags,
    f_obs          = f_dummy,
    sf_and_grads_accuracy_params = sfg_params,
    xray_structure = xrs,
    twin_law       = twin_law)
  ss = 1./flex.pow2(r_free_flags.d_spacings().data()) / 4.
  k_mask = mmtbx.f_model.ext.k_mask(ss, k_sol, b_sol)
  u_star = adptbx.u_cart_as_u_star(xrs.unit_cell(), adptbx.b_as_u(b_cart))
  k_anisotropic = mmtbx.f_model.ext.k_anisotropic(r_free_flags.indices(),u_star)
  fmodel.update_xray_structure(
    xray_structure = xrs,
    update_f_calc  = True,
    update_f_mask  = True)
  fmodel.update_core(
    k_mask        = k_mask,
    k_anisotropic = k_anisotropic)
  f_obs = abs(fmodel.f_model())
  return f_obs, r_free_flags

def exercise_00(d_min = 3.0, k_sol = 0.35, b_sol = 50.0,
                b_cart = [2.78, -1.54, 8.55, 0, 0, 0],):
  """
  Recover k_sol, b_sol and b_cart up to eps=1.e-6. Somewhat duplication with
  existing tests.
  """
  xrs = random_structure.xray_structure(
    space_group_info       = sgtbx.space_group_info(symbol="P212121"),
    elements               =(("O","N","C")*100),
    volume_per_atom        = 100,
    min_distance           = 1.5,
    general_positions_only = True,
    random_u_iso           = True,
    random_occupancy       = False)
  f_obs, r_free_flags = get_sf(
    d_min  = d_min,
    k_sol  = k_sol,
    b_sol  = b_sol,
    b_cart = b_cart,
    xrs    = xrs)
  fmodel = mmtbx.f_model.manager(
    r_free_flags   = r_free_flags,
    f_obs          = f_obs,
    xray_structure = xrs)
  r_work_start = fmodel.r_work()
  assert r_work_start > 0.3
  params = bss.master_params.extract()
  params.number_of_macro_cycles=4
  r = fmodel.update_all_scales(params=params, fast=False, remove_outliers=False)
  r_work_final = fmodel.r_work()
  assert approx_equal(r_work_final, 0,   1.e-5)
  assert approx_equal(r.k_sol[0], k_sol, 1.e-5)
  assert approx_equal(r.b_sol[0], b_sol, 1.e-1)
  assert approx_equal(r.b_cart, b_cart,  1.e-1)

def exercise_01_general(d_mins = [1.6,],
             solvkb = [(0,0), (0.39,58.0), (0.1,6.),(0.54,87.)],
             b_carts = [(4., 10., -14., 0, 5., 0.),
                        (0., 0., 0., 0., 0., 0.)],
             ):
  xray_structure = get_xray_structure_from_file()
  params = bss.master_params.extract()
  params.number_of_macro_cycles=3
  for fast in [True, False]:
    for d_min in d_mins:
      for kb in solvkb:
        for b_cart in b_carts:
          f_obs, r_free_flags = \
            get_f_obs_freer(d_min  = d_min,
                            k_sol  = [kb[0]],
                            b_sol  = [kb[1]],
                            b_cart = b_cart,
                            xray_structure = xray_structure)
          #
          bin_selections = []
          f_obs.setup_binner(reflections_per_bin=50)
          for i_bin in f_obs.binner().range_used():
            sel = f_obs.binner().selection(i_bin)
            bin_selections.append(sel)
          #
          fmodel = mmtbx.f_model.manager(
            r_free_flags   = r_free_flags,
            f_obs          = f_obs,
            xray_structure = xray_structure,
            bin_selections = bin_selections)
          fmodel.update_all_scales(fast=fast, params=params,
            remove_outliers=False)
          result = bss.bulk_solvent_and_scales(
            fmodel_kbu = fmodel.fmodel_kbu(), params = params)
          if(not fast):
            assert approx_equal(fmodel.r_work(), result.fmodel_kbu.r_factor())
          else:
            assert fmodel.r_work() < 0.036, fmodel.r_work()
          assert approx_equal(result.fmodel_kbu.r_factor(), 0.0, eps = 1.e-4)
          assert approx_equal(result.k_sols()[0],      kb[0],    eps = 1.e-4)
          assert approx_equal(result.b_sols()[0],      kb[1],    eps = 1.e-4)
          assert approx_equal(result.b_cart(),        b_cart,    eps = 1.e-2)

def exercise_02_b_cart_sym_constr(d_min = 2.0, tolerance = 1.e-6):
  for symbol in sgtbx.bravais_types.acentric + sgtbx.bravais_types.centric:
    space_group_info = sgtbx.space_group_info(symbol = symbol)
    xray_structure = get_xray_structure_random(space_group_info)
    sg = xray_structure.space_group()
    uc = xray_structure.unit_cell()
    u_cart_p1 = adptbx.random_u_cart(u_scale=5, u_min=5)
    u_star_p1 = adptbx.u_cart_as_u_star(uc, u_cart_p1)
    b_cart_1 = adptbx.u_star_as_u_cart(uc, u_star_p1)
    b_cart_2 = adptbx.u_star_as_u_cart(uc, sg.average_u_star(u_star = u_star_p1))
    for b_cart in (b_cart_1, b_cart_2):
      f_obs, r_free_flags = \
        get_f_obs_freer(d_min  = d_min,
                        k_sol  = 0,
                        b_sol  = 0,
                        b_cart = b_cart,
                        xray_structure = xray_structure)
      fmodel = mmtbx.f_model.manager(
        r_free_flags   = r_free_flags,
        f_obs          = f_obs,
        xray_structure = xray_structure)
      flag=True
      params = bss.master_params.extract()
      params.number_of_macro_cycles=3
      params.bulk_solvent = False
      params.anisotropic_scaling = True
      params.k_sol_b_sol_grid_search = False
      params.minimization_k_sol_b_sol = False
      params.minimization_b_cart = True
      params.symmetry_constraints_on_b_cart = flag
      params.max_iterations = 50
      params.min_iterations = 50
      result = bss.bulk_solvent_and_scales(
        fmodel_kbu = fmodel.fmodel_kbu(), params = params)
      if(flag == True and approx_equal(b_cart, b_cart_2, out=None)):
        assert approx_equal(result.b_cart(), b_cart, tolerance)
      if(flag == True and approx_equal(b_cart, b_cart_1, out=None)):
        for u2, ufm in zip(b_cart_2, result.b_cart()):
          if(abs(u2) < 1.e-6): assert approx_equal(ufm, 0.0, tolerance)

def exercise_03_do_nothing(d_min = 2.0):
  xray_structure = get_xray_structure_from_file()
  k_sol = 0.98
  b_sol = 127.0
  b_cart = [1,2,3,0,4,0]
  f_obs, r_free_flags = get_f_obs_freer(
    d_min  = d_min,
    k_sol  = k_sol,
    b_sol  = b_sol,
    b_cart = b_cart,
    xray_structure = xray_structure)
  fmodel = mmtbx.f_model.manager(
    r_free_flags   = r_free_flags,
    f_obs          = f_obs,
    xray_structure = xray_structure)
  r_work_start = fmodel.r_work()*100.
  params = bss.master_params.extract()
  params.bulk_solvent = False
  params.anisotropic_scaling = False
  fmodel.update_all_scales(params = params, fast=False, remove_outliers=False)
  result = bss.bulk_solvent_and_scales(
    fmodel_kbu = fmodel.fmodel_kbu(), params  = params)
  r_work1 = fmodel.r_work()*100.
  assert r_work_start > 0.0
  assert approx_equal(r_work1, r_work_start, eps = 1.e-6)
  assert approx_equal(result.k_sols()[0], 0, eps = 1.e-6)
  assert approx_equal(result.b_sols()[0], 0, eps = 1.e-6)
  assert approx_equal(result.b_cart(), [0,0,0,0,0,0], eps = 1.e-6)

def exercise_04_fix_k_sol_b_sol_b_cart(d_min = 2.0):
  xray_structure = get_xray_structure_from_file()
  k_sol = 0.98
  b_sol = 127.0
  b_cart = [1,2,3,0,4,0]
  f_obs, r_free_flags = get_f_obs_freer(
    d_min  = d_min,
    k_sol  = k_sol,
    b_sol  = b_sol,
    b_cart = b_cart,
    xray_structure = xray_structure)
  fmodel = mmtbx.f_model.manager(
    r_free_flags   = r_free_flags,
    f_obs          = f_obs,
    xray_structure = xray_structure)
  r_work_start = fmodel.r_work()*100.
  params = bss.master_params.extract()
  params.k_sol_b_sol_grid_search = False
  params.minimization_k_sol_b_sol = False
  params.minimization_b_cart = False
  params.fix_k_sol = k_sol
  params.fix_b_sol = b_sol
  params.fix_b_cart.b11 = b_cart[0]
  params.fix_b_cart.b22 = b_cart[1]
  params.fix_b_cart.b33 = b_cart[2]
  params.fix_b_cart.b12 = b_cart[3]
  params.fix_b_cart.b13 = b_cart[4]
  params.fix_b_cart.b23 = b_cart[5]
  result = fmodel.update_all_scales(params = params, fast = False,
    remove_outliers=False)
  r_work = fmodel.r_work()*100.
  assert r_work_start > 0.0
  assert approx_equal(r_work,          0.0, eps = 1.e-6)
  assert approx_equal(result.k_sol[0], k_sol, eps = 1.e-6)
  assert approx_equal(result.b_sol[0], b_sol, eps = 1.e-6)
  assert approx_equal(result.b_cart, b_cart, eps = 1.e-6)

def exercise_05_k_sol_b_sol_only(d_min = 2.0):
  xray_structure = get_xray_structure_from_file()
  k_sol = 0.33
  b_sol = 34.0
  b_cart = [1,2,3,0,4,0]
  f_obs, r_free_flags = get_f_obs_freer(
    d_min  = d_min,
    k_sol  = k_sol,
    b_sol  = b_sol,
    b_cart = b_cart,
    xray_structure = xray_structure)
  fmodel = mmtbx.f_model.manager(
    r_free_flags   = r_free_flags,
    f_obs          = f_obs,
    xray_structure = xray_structure)
  params = bss.master_params.extract()
  params.anisotropic_scaling = False
  params.number_of_macro_cycles=5
  u_star = adptbx.u_cart_as_u_star(
    fmodel.f_obs().unit_cell(),adptbx.b_as_u(b_cart))
  fmodel_kbu = mmtbx.f_model.manager_kbu(
    f_obs   = fmodel.f_obs(),
    f_calc  = fmodel.f_calc(),
    f_masks = fmodel.arrays.core.f_masks,
    f_part1 = fmodel.arrays.core.f_part1,
    f_part2 = fmodel.arrays.core.f_part2,
    ss      = fmodel.ss,
    u_star  = u_star)
  r_work_start = fmodel_kbu.r_factor()
  result = bss.bulk_solvent_and_scales(
    fmodel_kbu = fmodel_kbu, params = params)
  r_work = result.fmodel_kbu.r_factor()*100.
  assert r_work_start > 0.05
  #
  assert approx_equal(r_work,              0.0,   eps = 1.e-4)
  assert approx_equal(result.k_sols()[0], k_sol,  eps = 1.e-4)
  assert approx_equal(result.b_sols()[0], b_sol,  eps = 1.e-4)
  assert approx_equal(result.b_cart(),    b_cart, eps = 1.e-4)

def exercise_06_b_cart_only(d_min = 2.0):
  xray_structure = get_xray_structure_from_file()
  k_sol = 0.33
  b_sol = 34.0
  b_cart = [1,2,3,0,4,0]
  f_obs, r_free_flags = get_f_obs_freer(
    d_min  = d_min,
    k_sol  = k_sol,
    b_sol  = b_sol,
    b_cart = b_cart,
    xray_structure = xray_structure)
  fmodel = mmtbx.f_model.manager(
    r_free_flags   = r_free_flags,
    f_obs          = f_obs,
    xray_structure = xray_structure)
  fmodel_kbu = mmtbx.f_model.manager_kbu(
    f_obs   = fmodel.f_obs(),
    f_calc  = fmodel.f_calc(),
    f_masks = fmodel.arrays.core.f_masks,
    f_part1 = fmodel.arrays.core.f_part1,
    f_part2 = fmodel.arrays.core.f_part2,
    ss      = fmodel.ss,
    k_sols  = [k_sol],
    b_sols  = [b_sol])
  r_work_start = fmodel_kbu.r_factor()*100.
  params = bss.master_params.extract()
  params.bulk_solvent = False
  result = bss.bulk_solvent_and_scales(
    fmodel_kbu = fmodel_kbu, params  = params)
  r_work = result.fmodel_kbu.r_factor()*100.
  assert r_work_start > 0.0
  assert approx_equal(r_work,               0.0,  eps = 1.e-6)
  assert approx_equal(result.k_sols()[0], k_sol,  eps = 1.e-6)
  assert approx_equal(result.b_sols()[0], b_sol,  eps = 1.e-6)
  assert approx_equal(result.b_cart(),    b_cart, eps = 1.e-6)

def exercise_radial_shells(k_sol=0.33,d_min=1.5,grid_search=False,shell_width=0.6):
  xray_structure = get_xray_structure_from_file()
  b_sol = 34.0
  if( type(k_sol) is list ):
    b_sol = [b_sol,]*len(k_sol)
  b_cart = [1,2,3,0,4,0]
  f_obs, r_free_flags = get_f_obs_freer(
    d_min  = d_min,
    k_sol  = k_sol,
    b_sol  = b_sol,
    b_cart = b_cart,
    xray_structure = xray_structure,
    radial_shell_width=shell_width)
  mask_params = mmtbx.masks.mask_master_params.extract()
  mask_params.radial_shell_width = shell_width
  if( type(k_sol) is list ):
    mask_params.n_radial_shells = len(k_sol)
  else:
    mask_params.n_radial_shells = 2
  fmodel = mmtbx.f_model.manager(
    r_free_flags   = r_free_flags,
    f_obs          = f_obs,
    xray_structure = xray_structure,
    mask_params    = mask_params)
  u_star = adptbx.u_cart_as_u_star(
    fmodel.f_obs().unit_cell(),adptbx.b_as_u(b_cart))
  fmodel_kbu = fmodel.fmodel_kbu()
  fmodel_kbu.update(u_star = u_star)
  r_work_start = fmodel_kbu.r_factor()*100.
  msk = fmodel.mask_manager
  print('Solvent content: ', msk.solvent_content_via_mask)
  print('Layer volume fractions: ', msk.layer_volume_fractions)
  if( type(k_sol) is list):
    for i in range(len(k_sol)):
      if( msk.layer_volume_fractions[i] == 0. ):
        k_sol[i] = 0.
  params = bss.master_params.extract()
  params.anisotropic_scaling = False
  params.k_sol_b_sol_grid_search = grid_search
  params.number_of_macro_cycles = 10
  params.k_sol_max = 1.2
  result = bss.bulk_solvent_and_scales(
    fmodel_kbu = fmodel_kbu, params = params)
  r_work = result.fmodel_kbu.r_factor()
  print('R-work: ', r_work)
  print('Solvent radius: ', fmodel.mask_params.solvent_radius)
  assert r_work_start > 0.0
  assert approx_equal(r_work, 0.0, eps = 1.e-3)
  if( type(k_sol) is list ):
    ksols = list(result.fmodel_kbu.k_sols())
    # XXX if layer_volume_fractions=0, then ksol is more or less undefined ?
    # XXX should it be done in bulk_solvent_and_scaling.py ?
    for i in range(len(ksols)):
      if(msk.layer_volume_fractions[i] == 0.):
        ksols[i] = 0.
    assert len(k_sol) == len(ksols)
    for ik in range(len(k_sol)):
      assert approx_equal(ksols[ik], k_sol[ik], eps=0.005),[ksols[ik],k_sol[ik]]
  else:
    for ksol in result.fmodel_kbu.k_sols():
      assert approx_equal(ksol,   k_sol, eps = 1.e-3)
  n=len(result.b_sols())
  if(n>1 and type(b_sol) is float): b_sol = [b_sol,]*n
  assert approx_equal(result.b_sols(), b_sol,  eps = 1.)
  assert approx_equal(result.b_cart(), b_cart, eps = 1.e-6)

def run():
  exercise_00()
  exercise_01_general()
  exercise_02_b_cart_sym_constr()
  exercise_03_do_nothing()
  exercise_04_fix_k_sol_b_sol_b_cart()
  exercise_05_k_sol_b_sol_only()
  exercise_06_b_cart_only()
  exercise_radial_shells()
  exercise_radial_shells(k_sol=[0.33,0.5, 0.9])
  exercise_radial_shells(k_sol=[0.3,0.4,0.5],grid_search=True,shell_width=0.3)
  print("OK: ",format_cpu_times())

if (__name__ == "__main__"):
  run()


 *******************************************************************************


 *******************************************************************************
mmtbx/bulk_solvent/tst_fit_kexpb_to_ktotal.py
from __future__ import absolute_import, division, print_function
import mmtbx.bulk_solvent
from scitbx.array_family import flex
import math, time
from six.moves import range

def run(nref, k, b, k_start, b_start):
  data = flex.double()
  ss = flex.double()
  for ss_ in range(1, nref):
    ss_ = ss_/nref*1.
    y = k*math.exp(-b*ss_)
    data.append(y)
    ss.append(ss_)
  t0 = time.time()
  r = mmtbx.bulk_solvent.fit_k_exp_b_to_k_total(data, ss, k_start, b_start)
  return list(r), "Time: %6.4f"%(time.time()-t0)

if (__name__ == "__main__"):
  for i in [(10000, 1, 10, 1, 10),
            (10000,10,100,10,100),
            (10000, 5, 10, 5, 10),
            (10000, 0,  0, 0,  0),
            (10000, 90, -10, -10, 10) # outside convergence well
            ]:
    r = run(nref=i[0], k=i[1], b=i[2], k_start=i[3], b_start=i[4])
    print(r)


 *******************************************************************************


 *******************************************************************************
mmtbx/bulk_solvent/tst_flat_nonuniform.py
from __future__ import absolute_import, division, print_function
from iotbx import pdb
from cctbx.array_family import flex
from libtbx.test_utils import approx_equal
import mmtbx.f_model
from cctbx import adptbx
import iotbx.pdb
from mmtbx import f_model
from cctbx import maptbx
from mmtbx.bulk_solvent import kbu_refinery
import time
from mmtbx import bulk_solvent
from six.moves import range

pdb_str = """
CRYST1   10.000   10.000   10.000  90.00  90.00  90.00 P1
ATOM      1  O   HOH A   1       2.500   2.500   2.500  1.00 10.00           O
ATOM      1  O   HOH A   1       5.500   2.500   2.500  1.00 10.00           O
"""

def get_mask_data(xrs, d_min):
  crystal_gridding = maptbx.crystal_gridding(
    unit_cell          = xrs.unit_cell(),
    d_min              = d_min,
    resolution_factor  = 1./4,
    symmetry_flags     = maptbx.use_space_group_symmetry,
    space_group_info   = xrs.space_group_info())
  mp = mmtbx.masks.mask_master_params.extract()
  return mmtbx.masks.mask_from_xray_structure(
    xray_structure           = xrs,
    p1                       = True,
    solvent_radius           = mp.solvent_radius,
    shrink_truncation_radius = mp.shrink_truncation_radius,
    for_structure_factors    = True,
    n_real                   = crystal_gridding.n_real()).mask_data

def fd_k_sols(kbu, f_obs, eps=1.e-3):
  p = flex.double([0.1, 0.2])
  kbu.update(k_sols = p)
  tg = bulk_solvent.ls_kbp_sol_u_star(
    f_model     = kbu.data,
    f_obs       = f_obs.data(),
    scale       = 1.0,
    kb_sol_grad = True,
    p_sol_grad  = False,
    u_star_grad = True,
    kb_sol_curv = True,
    p_sol_curv  = False)
  g_k_sols_anal = list(tg.grad_k_sols())
  c_k_sols_anal = list(tg.curv_k_sols())
  print("C anal k:", c_k_sols_anal)
  #
  g_k_sols_fd = []
  c_k_sols_fd = []
  t0 = tg.target()
  for shift in [flex.double([eps,0]),
                flex.double([0,eps])]:
    # plus shift
    kbu.update(k_sols = p+shift)
    tg = bulk_solvent.ls_kbp_sol_u_star(
      f_model     = kbu.data,
      f_obs       = f_obs.data(),
      scale       = 1.0,
      kb_sol_grad = True,
      p_sol_grad  = False,
      u_star_grad = True,
      kb_sol_curv = True,
      p_sol_curv  = False)
    t1 = tg.target()
    # minus shift
    kbu.update(k_sols = p-shift)
    tg = bulk_solvent.ls_kbp_sol_u_star(
      f_model     = kbu.data,
      f_obs       = f_obs.data(),
      scale       = 1.0,
      kb_sol_grad = True,
      p_sol_grad  = False,
      u_star_grad = True,
      kb_sol_curv = True,
      p_sol_curv  = False)
    t2 = tg.target()
    g_k_sols_fd.append( (t1-t2)/(2*eps) )
    c_k_sols_fd.append( (t1+t2-2*t0)/eps**2 )
  #
  print("C df:",c_k_sols_fd)
  assert approx_equal(g_k_sols_anal, g_k_sols_fd, 1.e-4)

def fd_b_sols(kbu, f_obs):
  p = flex.double([10, 20])
  kbu.update(b_sols = p)
  tg = bulk_solvent.ls_kbp_sol_u_star(
    f_model     = kbu.data,
    f_obs       = f_obs.data(),
    scale       = 1.0,
    kb_sol_grad = True,
    p_sol_grad  = False,
    u_star_grad = True,
    kb_sol_curv = True,
    p_sol_curv  = False)
  g_b_sols_anal = list(tg.grad_b_sols())
  c_b_sols_anal = list(tg.curv_b_sols())
  print("C anal b:", c_b_sols_anal)
  #
  g_b_sols_fd = []
  c_b_sols_fd = []
  t0 = tg.target()
  for shift in [flex.double([1.e-3,0]),
                flex.double([0,1.e-3])]:
    # plus shift
    kbu.update(b_sols = p+shift)
    tg = bulk_solvent.ls_kbp_sol_u_star(
      f_model     = kbu.data,
      f_obs       = f_obs.data(),
      scale       = 1.0,
      kb_sol_grad = True,
      p_sol_grad  = False,
      u_star_grad = True,
      kb_sol_curv = True,
      p_sol_curv  = False)
    t1 = tg.target()
    # minus shift
    kbu.update(b_sols = p-shift)
    tg = bulk_solvent.ls_kbp_sol_u_star(
      f_model     = kbu.data,
      f_obs       = f_obs.data(),
      scale       = 1.0,
      kb_sol_grad = True,
      p_sol_grad  = False,
      u_star_grad = True,
      kb_sol_curv = True,
      p_sol_curv  = False)
    t2 = tg.target()
    g_b_sols_fd.append( (t1-t2)/(2*1.e-3) )
    c_b_sols_fd.append( (t1+t2-2*t0)/1.e-3**2 *2)
    #
  print("C df:",c_b_sols_fd)
  assert approx_equal(g_b_sols_anal, g_b_sols_fd)

def run(d_min  = 2.0,
        b_cart = [1,2,3,0,4,0],
        k_sols = [0.3, 0.5],
        b_sols = [50., 20.]):
  xrs=iotbx.pdb.input(source_info=None, lines=pdb_str).xray_structure_simple()
  #
  f_calc = xrs.structure_factors(d_min=d_min).f_calc()
  #
  mask_data = get_mask_data(xrs=xrs, d_min=d_min)
  n = mask_data.all()
  mask_data1 = flex.double(flex.grid(n), 0)
  mask_data2 = flex.double(flex.grid(n), 0)
  I,J,K = range(n[0]), range(n[1]), range(n[2])
  for i in I:
    for j in J:
      for k in K:
        if(i < n[0]//2 and j < n[1]//2 and k < n[2]//2):
          mask_data1[i,j,k]=mask_data[i,j,k]
        else:
          mask_data2[i,j,k]=mask_data[i,j,k]
  f_mask1 = f_calc.structure_factors_from_map(map=mask_data1,
    use_scale = True, anomalous_flag = False, use_sg = False)
  f_mask2 = f_calc.structure_factors_from_map(map=mask_data2,
    use_scale = True, anomalous_flag = False, use_sg = False)
  #
  u_star = adptbx.u_cart_as_u_star(xrs.unit_cell(), adptbx.b_as_u(b_cart))
  k_total = mmtbx.f_model.ext.k_anisotropic(f_calc.indices(), u_star)
  #
  d_spacings = f_calc.d_spacings().data()
  ss = 1./flex.pow2(d_spacings) / 4.
  k_mask1 = mmtbx.f_model.ext.k_mask(ss, k_sols[0], b_sols[0])
  k_mask2 = mmtbx.f_model.ext.k_mask(ss, k_sols[1], b_sols[1])
  #
  f_obs_data = flex.abs( k_total*(f_calc.data()+k_mask1*f_mask1.data() +
                                                k_mask2*f_mask2.data()) )
  f_obs = f_calc.array(data = f_obs_data)
  #
  kbu = f_model.manager_kbu(
    f_obs   = f_obs,
    f_calc  = f_calc,
    f_masks = [f_mask1, f_mask2],
    ss      = ss,
    k_sols  = k_sols,
    b_sols  = b_sols)
  #
  fd_k_sols(kbu=kbu, f_obs=f_obs)
  fd_b_sols(kbu=kbu, f_obs=f_obs)
  #
  u_star_ini = adptbx.u_cart_as_u_star(xrs.unit_cell(),
    adptbx.b_as_u([0.1,0.2,0.3,0,0.4,0]))
  TGCO = kbu_refinery.tgc(
    f_obs   = f_obs,
    f_calc  = f_calc,
    f_masks = [f_mask1, f_mask2],
    ss      = ss,
    k_sols  = [0.1,0.1],
    b_sols  = [10,10],
    u_star  = u_star_ini)
  TGCO.minimize_kbu(n_cycles=100)
  TGCO.show_kbu()
  assert approx_equal(TGCO.kbu.k_sols(), k_sols, 1.e-3)
  assert approx_equal(TGCO.kbu.b_sols(), b_sols, 1.e-3)
  assert approx_equal(TGCO.kbu.b_cart(), b_cart, 1.e-4)

if (__name__ == "__main__"):
  t0 = time.time()
  run()
  print("Time: %6.4f"%(time.time()-t0))
  print("OK")


 *******************************************************************************


 *******************************************************************************
mmtbx/bulk_solvent/tst_kb_sol_u_star_fd.py
from __future__ import absolute_import, division, print_function
from cctbx.development import random_structure
from cctbx.sgtbx import space_group_info
import boost_adaptbx.boost.python as bp
from six.moves import range
ext = bp.import_ext("cctbx_asymmetric_map_ext")
from cctbx_asymmetric_map_ext import *
from cctbx.array_family import flex
from cctbx import maptbx
import mmtbx.f_model
from libtbx import adopt_init_args
import mmtbx.bulk_solvent.bulk_solvent_and_scaling as bss
from libtbx.test_utils import approx_equal
from cctbx import adptbx

import boost_adaptbx.boost.python as bp
ext = bp.import_ext("mmtbx_f_model_ext")

def get_f_masks(xrs, miller_array):
  crystal_gridding = maptbx.crystal_gridding(
    unit_cell          = xrs.unit_cell(),
    d_min              = miller_array.d_min(),
    resolution_factor  = 1./4,
    symmetry_flags     = maptbx.use_space_group_symmetry,
    space_group_info   = xrs.space_group_info())
  mp = mmtbx.masks.mask_master_params.extract()
  mask_data = mmtbx.masks.mask_from_xray_structure(
    xray_structure           = xrs,
    p1                       = True,
    solvent_radius           = mp.solvent_radius,
    shrink_truncation_radius = mp.shrink_truncation_radius,
    for_structure_factors    = True,
    n_real                   = crystal_gridding.n_real()).mask_data
  n = mask_data.all()
  mask_data1 = flex.double(flex.grid(n), 0)
  mask_data2 = flex.double(flex.grid(n), 0)
  I,J,K = range(n[0]), range(n[1]), range(n[2])
  for i in I:
    for j in J:
      for k in K:
        if(i < n[0]//2 and j < n[1]//2 and k < n[2]//2):
          mask_data1[i,j,k]=mask_data[i,j,k]
        else:
          mask_data2[i,j,k]=mask_data[i,j,k]
  f_mask1 = miller_array.structure_factors_from_map(map=mask_data1,
    use_scale = True, anomalous_flag = False, use_sg = False)
  f_mask2 = miller_array.structure_factors_from_map(map=mask_data2,
    use_scale = True, anomalous_flag = False, use_sg = False)
  return [f_mask1.data(), f_mask2.data()]

class cpp_tg(object):
  def __init__(self, fmodel):
    adopt_init_args(self, locals())
    self.f_masks = get_f_masks(
      xrs=self.fmodel.xray_structure, miller_array=self.fmodel.f_calc())

  def get_tg(self, k_sol, b_sol, u_star):
    fmodel_data = ext.core(
      f_calc        = self.fmodel.f_calc().data(),
      shell_f_masks = self.f_masks,
      k_sols        = k_sol,
      b_sols        = b_sol,
      f_part1       = flex.complex_double(self.fmodel.f_calc().data().size(),0),
      f_part2       = flex.complex_double(self.fmodel.f_calc().data().size(),0),
      u_star        = list(u_star),
      hkl           = self.fmodel.f_calc().indices(),
      ss            = self.fmodel.ss)
    return bss.bulk_solvent.ls_kbp_sol_u_star(
      f_model     = fmodel_data,
      f_obs       = self.fmodel.f_obs().data(),
      scale       = 10.0,
      kb_sol_grad = True,
      p_sol_grad  = False,
      u_star_grad = True,
      kb_sol_curv = True,
      p_sol_curv  = False)

class cpp_tg_u_star_only(object):
  def __init__(self, fmodel):
    adopt_init_args(self, locals())
    self.f_masks = get_f_masks(
      xrs=self.fmodel.xray_structure, miller_array=self.fmodel.f_calc())

  def get_tg(self, k_sol, b_sol, u_star):
    fmodel_data = ext.core(
      f_calc        = self.fmodel.f_calc().data(),
      shell_f_masks = self.f_masks,
      k_sols        = k_sol,
      b_sols        = b_sol,
      f_part1       = flex.complex_double(self.fmodel.f_calc().data().size(),0),
      f_part2       = flex.complex_double(self.fmodel.f_calc().data().size(),0),
      u_star        = list(u_star),
      hkl           = self.fmodel.f_calc().indices(),
      ss            = self.fmodel.ss)
    return bss.bulk_solvent.ls_u_star(
      f_model_abs_no_k_total = flex.abs(fmodel_data.f_model_no_aniso_scale),
      f_obs                  = self.fmodel.f_obs().data(),
      miller_indices         = self.fmodel.f_calc().indices(),
      k_anisotropic          = fmodel_data.k_anisotropic)

def fd(TGO, k_sol, b_sol, u_star, param, e = 1.e-3):
  tg = TGO.get_tg(k_sol=k_sol, b_sol=b_sol, u_star=u_star).target()
  g, c = [], []
  for shift in [flex.double([e,0]),
                flex.double([0,e])]:
    if(param=="k_sol"):
      tg_p = TGO.get_tg(k_sol=k_sol+shift, b_sol=b_sol, u_star=u_star).target()
      tg_m = TGO.get_tg(k_sol=k_sol-shift, b_sol=b_sol, u_star=u_star).target()
    if(param=="b_sol"):
      tg_p = TGO.get_tg(k_sol=k_sol, b_sol=b_sol+shift, u_star=u_star).target()
      tg_m = TGO.get_tg(k_sol=k_sol, b_sol=b_sol-shift, u_star=u_star).target()
    if(param in ["k_sol", "b_sol"]):
      g.append((tg_p-tg_m)/(2*e))
      c.append((tg_p+tg_m-2*tg)/(e**2))
  if(param=="u_star"):
    e=e**2/10. # because u_star is very small
    for shift in [flex.double([e,0,0,0,0,0]),
                  flex.double([0,e,0,0,0,0]),
                  flex.double([0,0,e,0,0,0]),
                  flex.double([0,0,0,e,0,0]),
                  flex.double([0,0,0,0,e,0]),
                  flex.double([0,0,0,0,0,e])]:
      tg_p = TGO.get_tg(k_sol=k_sol, b_sol=b_sol, u_star=u_star+shift).target()
      tg_m = TGO.get_tg(k_sol=k_sol, b_sol=b_sol, u_star=u_star-shift).target()
      g.append((tg_p-tg_m)/(2*e))
  return g, c

def run_group(symbol):
  group = space_group_info(symbol);
  print("\n==")
  elements = ('C', 'N', 'O', 'H')*11
  xrs = random_structure.xray_structure(
    space_group_info = group,
    volume_per_atom = 25.,
    general_positions_only = False,
    elements = elements,
    min_distance = 1.0)
  fo = abs(xrs.structure_factors(d_min=2).f_calc())
  fmodel = mmtbx.f_model.manager(
    f_obs = fo,
    xray_structure = xrs)
  #
  k_sol=flex.double([10.35,5.34])
  b_sol=flex.double([30.0, 24.0])
  b_cart = [10,20,30,40,50,60]
  u_star = flex.double(adptbx.b_as_u(
    adptbx.u_cart_as_u_star(xrs.unit_cell(), b_cart)))
  #
  TGO = cpp_tg(fmodel=fmodel)
  tg = TGO.get_tg(k_sol=k_sol, b_sol=b_sol, u_star=u_star)
  # k_sol
  gk_a=list(tg.grad_k_sols())
  ck_a=list(tg.curv_k_sols())
  gk_fd, ck_fd=fd(TGO=TGO, k_sol=k_sol, b_sol=b_sol, u_star=u_star, param="k_sol")
  # b_sol
  gb_a=list(tg.grad_b_sols())
  cb_a=list(tg.curv_b_sols())
  gb_fd, cb_fd=fd(TGO=TGO, k_sol=k_sol, b_sol=b_sol, u_star=u_star, param="b_sol")
  # u_star
  gu_a=list(tg.grad_u_star())
  gu_fd, junk=fd(TGO=TGO, k_sol=k_sol, b_sol=b_sol, u_star=u_star, param="u_star")
  print("u_star:",gu_a)
  print("u_star:",gu_fd)
  TGO2 = cpp_tg_u_star_only(fmodel=fmodel)
  tg2 = TGO2.get_tg(k_sol=k_sol, b_sol=b_sol, u_star=u_star)
  gu_a2=list(tg2.grad_u_star())
  gu_fd2, junk=fd(TGO=TGO2, k_sol=k_sol, b_sol=b_sol, u_star=u_star, param="u_star")
  print("u_star:",gu_a2)
  print("u_star:",gu_fd2)
  #
  print("k_sol:", gk_a,  ck_a)
  print("k_sol:", gk_fd, ck_fd)
  print("b_sol:", gb_a,  cb_a)
  print("b_sol:", gb_fd, cb_fd)
  #
  assert approx_equal(gk_a, gk_fd, eps=1.e-4)
  assert approx_equal(gb_a, gb_fd, eps=1.e-4)
  assert approx_equal(ck_a, ck_fd, eps=1.e-4)
  assert approx_equal(cb_a, cb_fd, eps=1.e-4)
  assert approx_equal(gu_a, gu_fd, eps=1.e-4)
  assert approx_equal(gu_a2, gu_fd2, eps=1.e-5)

if (__name__ == "__main__"):
  for i in list(range(1,231))[:10]: # XXX Do first 10 (to save time)
    print(i)
    run_group(i)


 *******************************************************************************


 *******************************************************************************
mmtbx/bulk_solvent/tst_mosaic.py
from __future__ import absolute_import, division, print_function
import iotbx.pdb
import time
from scitbx.array_family import flex
import boost_adaptbx.boost.python as bp
asu_map_ext = bp.import_ext("cctbx_asymmetric_map_ext")
from libtbx.test_utils import approx_equal
from libtbx import group_args
from mmtbx.bulk_solvent import mosaic
from cctbx import maptbx

pdb_str = """
REMARK iotbx.pdb.box_around_molecule --buffer-layer=2 "l.pdb"
REMARK Date 2020-04-16 Time 11:24:48 PDT -0700 (1587061488.33 s)
CRYST1   36.359   37.628   51.937  90.00  90.00  90.00 P 1
SCALE1      0.027504  0.000000  0.000000        0.00000
SCALE2      0.000000  0.026576  0.000000        0.00000
SCALE3      0.000000  0.000000  0.019254        0.00000
ATOM      1  N   LYS     1       6.885  22.776  20.969  1.00  7.59           N
ATOM      2  CA  LYS     1       7.314  22.228  19.673  1.00  7.59           C
ATOM      3  C   LYS     1       7.946  20.842  19.872  1.00  7.59           C
ATOM      4  O   LYS     1       8.694  20.610  20.830  1.00  7.59           O
ATOM      5  CB  LYS     1       8.386  23.180  19.074  1.00  7.59           C
ATOM      6  CG  LYS     1       9.247  22.500  18.006  1.00  7.59           C
ATOM      7  CD  LYS     1       9.878  23.486  17.023  1.00  7.59           C
ATOM      8  CE  LYS     1      10.485  22.800  15.797  1.00  7.59           C
ATOM      9  NZ  LYS     1      11.589  23.564  15.197  1.00  7.59           N
ATOM     10  N   VAL     2       7.623  19.950  18.951  1.00  7.59           N
ATOM     11  CA  VAL     2       8.151  18.570  18.956  1.00  7.59           C
ATOM     12  C   VAL     2       9.125  18.388  17.774  1.00  7.59           C
ATOM     13  O   VAL     2       8.706  18.279  16.615  1.00  7.59           O
ATOM     14  CB  VAL     2       6.995  17.566  18.811  1.00  7.59           C
ATOM     15  CG1 VAL     2       7.458  16.107  18.839  1.00  7.59           C
ATOM     16  CG2 VAL     2       5.942  17.682  19.919  1.00  7.59           C
ATOM     17  N   PHE     3      10.429  18.362  18.082  1.00  7.59           N
ATOM     18  CA  PHE     3      11.492  18.184  17.044  1.00  7.59           C
ATOM     19  C   PHE     3      11.624  16.687  16.680  1.00  7.59           C
ATOM     20  O   PHE     3      10.965  15.828  17.278  1.00  7.59           O
ATOM     21  CB  PHE     3      12.838  18.723  17.535  1.00  7.59           C
ATOM     22  CG  PHE     3      12.867  20.253  17.666  1.00  7.59           C
ATOM     23  CD1 PHE     3      12.621  20.839  18.908  1.00  7.59           C
ATOM     24  CD2 PHE     3      13.139  21.064  16.550  1.00  7.59           C
ATOM     25  CE1 PHE     3      12.649  22.227  19.047  1.00  7.59           C
ATOM     26  CE2 PHE     3      13.170  22.456  16.691  1.00  7.59           C
ATOM     27  CZ  PHE     3      12.926  23.037  17.939  1.00  7.59           C
ATOM     28  N   GLY     4      12.501  16.403  15.705  1.00  7.59           N
ATOM     29  CA  GLY     4      12.668  15.030  15.136  1.00  7.59           C
ATOM     30  C   GLY     4      13.921  14.283  15.641  1.00  7.59           C
ATOM     31  O   GLY     4      13.936  13.660  16.698  1.00  7.59           O
ATOM     32  N   ARG     5      14.968  14.310  14.852  1.00  7.59           N
ATOM     33  CA  ARG     5      16.228  13.647  15.220  1.00  7.59           C
ATOM     34  C   ARG     5      17.276  14.116  14.269  1.00  7.59           C
ATOM     35  O   ARG     5      18.312  13.477  14.083  1.00  7.59           O
ATOM     36  CB  ARG     5      16.088  12.122  15.136  1.00  7.59           C
ATOM     37  CG  ARG     5      16.244  11.569  13.713  1.00  7.59           C
ATOM     38  CD  ARG     5      17.201  10.369  13.616  1.00  7.59           C
ATOM     39  NE  ARG     5      18.497  10.606  14.272  1.00  7.59           N
ATOM     40  CZ  ARG     5      19.669  10.101  13.843  1.00  7.59           C
ATOM     41  NH1 ARG     5      19.735   9.327  12.752  1.00  7.59           N
ATOM     42  NH2 ARG     5      20.846  10.315  14.452  1.00  7.59           N
ATOM     43  N   CYS     6      16.951  15.226  13.708  1.00  7.59           N
ATOM     44  CA  CYS     6      17.784  15.830  12.724  1.00  7.59           C
ATOM     45  C   CYS     6      17.604  17.328  12.820  1.00  7.59           C
ATOM     46  O   CYS     6      18.550  18.085  12.570  1.00  7.59           O
ATOM     47  CB  CYS     6      17.387  15.237  11.381  1.00  7.59           C
ATOM     48  SG  CYS     6      16.811  13.463  11.529  1.00  7.59           S
ATOM     49  N   GLU     7      16.380  17.698  13.181  1.00  7.59           N
ATOM     50  CA  GLU     7      16.025  19.104  13.422  1.00  7.59           C
ATOM     51  C   GLU     7      16.788  19.566  14.650  1.00  7.59           C
ATOM     52  O   GLU     7      17.483  20.605  14.594  1.00  7.59           O
ATOM     53  CB  GLU     7      14.535  19.272  13.776  1.00  7.59           C
ATOM     54  CG  GLU     7      13.544  18.630  12.807  1.00  7.59           C
ATOM     55  CD  GLU     7      12.088  18.818  13.269  1.00  7.59           C
ATOM     56  OE1 GLU     7      11.834  19.462  14.361  1.00  7.59           O
ATOM     57  OE2 GLU     7      11.117  18.334  12.571  1.00  7.59           O
ATOM     58  N   LEU     8      16.572  18.709  15.657  1.00  7.59           N
ATOM     59  CA  LEU     8      17.145  18.779  17.024  1.00  7.59           C
ATOM     60  C   LEU     8      18.668  18.726  16.953  1.00  7.59           C
ATOM     61  O   LEU     8      19.368  19.479  17.644  1.00  7.59           O
ATOM     62  CB  LEU     8      16.705  17.554  17.868  1.00  7.59           C
ATOM     63  CG  LEU     8      15.223  17.552  18.290  1.00  7.59           C
ATOM     64  CD1 LEU     8      14.857  16.367  19.199  1.00  7.59           C
ATOM     65  CD2 LEU     8      14.811  18.800  19.073  1.00  7.59           C
ATOM     66  N   ALA     9      19.135  17.819  16.116  1.00  7.59           N
ATOM     67  CA  ALA     9      20.567  17.631  15.880  1.00  7.59           C
ATOM     68  C   ALA     9      21.162  18.944  15.369  1.00  7.59           C
ATOM     69  O   ALA     9      22.210  19.398  15.847  1.00  7.59           O
ATOM     70  CB  ALA     9      20.789  16.537  14.833  1.00  7.59           C
ATOM     71  N   ALA    10      20.449  19.510  14.415  1.00  7.59           N
ATOM     72  CA  ALA    10      20.834  20.769  13.762  1.00  7.59           C
ATOM     73  C   ALA    10      20.856  21.924  14.768  1.00  7.59           C
ATOM     74  O   ALA    10      21.863  22.632  14.907  1.00  7.59           O
ATOM     75  CB  ALA    10      19.834  21.113  12.657  1.00  7.59           C
ATOM     76  N   ALA    11      19.737  22.077  15.445  1.00  7.59           N
ATOM     77  CA  ALA    11      19.533  23.156  16.424  1.00  7.59           C
ATOM     78  C   ALA    11      20.550  23.089  17.577  1.00  7.59           C
ATOM     79  O   ALA    11      21.064  24.117  18.037  1.00  7.59           O
ATOM     80  CB  ALA    11      18.128  23.068  17.022  1.00  7.59           C
ATOM     81  N   MET    12      20.843  21.881  18.046  1.00  7.59           N
ATOM     82  CA  MET    12      21.769  21.707  19.192  1.00  7.59           C
ATOM     83  C   MET    12      23.241  21.570  18.791  1.00  7.59           C
ATOM     84  O   MET    12      24.050  21.008  19.535  1.00  7.59           O
ATOM     85  CB  MET    12      21.510  20.433  19.987  1.00  7.59           C
ATOM     86  CG  MET    12      20.040  20.153  20.255  1.00  7.59           C
ATOM     87  SD  MET    12      19.771  19.276  21.782  1.00  7.59           S
ATOM     88  CE  MET    12      20.267  20.295  23.154  1.00  7.59           C
ATOM     89  N   LYS    13      23.599  22.042  17.628  1.00  7.59           N
ATOM     90  CA  LYS    13      25.018  22.041  17.228  1.00  7.59           C
ATOM     91  C   LYS    13      25.402  23.470  16.924  1.00  7.59           C
ATOM     92  O   LYS    13      26.528  23.899  17.216  1.00  7.59           O
ATOM     93  CB  LYS    13      25.279  21.185  15.985  1.00  7.59           C
ATOM     94  CG  LYS    13      26.738  21.303  15.511  1.00  7.59           C
ATOM     95  CD  LYS    13      27.030  20.558  14.205  1.00  7.59           C
ATOM     96  CE  LYS    13      28.459  20.786  13.693  1.00  7.59           C
ATOM     97  NZ  LYS    13      28.754  20.042  12.460  1.00  7.59           N
ATOM     98  N   ARG    14      24.409  24.112  16.362  1.00  7.59           N
ATOM     99  CA  ARG    14      24.453  25.507  15.943  1.00  7.59           C
ATOM    100  C   ARG    14      24.579  26.423  17.163  1.00  7.59           C
ATOM    101  O   ARG    14      25.252  27.462  17.114  1.00  7.59           O
ATOM    102  CB  ARG    14      23.161  25.834  15.192  1.00  7.59           C
ATOM    103  CG  ARG    14      23.090  27.276  14.694  1.00  7.59           C
ATOM    104  CD  ARG    14      21.790  27.573  13.941  1.00  7.59           C
ATOM    105  NE  ARG    14      21.699  28.962  13.471  1.00  7.59           N
ATOM    106  CZ  ARG    14      21.986  30.030  14.228  1.00  7.59           C
ATOM    107  NH1 ARG    14      22.389  29.887  15.498  1.00  7.59           N
ATOM    108  NH2 ARG    14      21.900  31.297  13.800  1.00  7.59           N
ATOM    109  N   HIS    15      23.925  26.009  18.236  1.00  7.59           N
ATOM    110  CA  HIS    15      23.902  26.773  19.497  1.00  7.59           C
ATOM    111  C   HIS    15      25.091  26.402  20.384  1.00  7.59           C
ATOM    112  O   HIS    15      24.947  26.239  21.606  1.00  7.59           O
ATOM    113  CB  HIS    15      22.606  26.497  20.250  1.00  7.59           C
ATOM    114  CG  HIS    15      21.375  26.945  19.465  1.00  7.59           C
ATOM    115  ND1 HIS    15      20.689  26.076  18.625  1.00  7.59           N
ATOM    116  CD2 HIS    15      20.732  28.138  19.392  1.00  7.59           C
ATOM    117  CE1 HIS    15      19.684  26.740  18.085  1.00  7.59           C
ATOM    118  NE2 HIS    15      19.695  27.971  18.532  1.00  7.59           N
ATOM    119  N   GLY    16      26.224  26.288  19.722  1.00  7.59           N
ATOM    120  CA  GLY    16      27.515  25.976  20.356  1.00  7.59           C
ATOM    121  C   GLY    16      27.351  24.947  21.474  1.00  7.59           C
ATOM    122  O   GLY    16      27.322  25.300  22.665  1.00  7.59           O
ATOM    123  N   LEU    17      27.265  23.710  21.041  1.00  7.59           N
ATOM    124  CA  LEU    17      27.120  22.558  21.931  1.00  7.59           C
ATOM    125  C   LEU    17      28.061  21.426  21.513  1.00  7.59           C
ATOM    126  O   LEU    17      28.844  20.916  22.326  1.00  7.59           O
ATOM    127  CB  LEU    17      25.710  21.960  21.825  1.00  7.59           C
ATOM    128  CG  LEU    17      24.719  22.460  22.883  1.00  7.59           C
ATOM    129  CD1 LEU    17      23.432  21.625  22.930  1.00  7.59           C
ATOM    130  CD2 LEU    17      25.276  22.433  24.305  1.00  7.59           C
ATOM    131  N   ASP    18      27.948  21.090  20.238  1.00  7.59           N
ATOM    132  CA  ASP    18      28.620  19.915  19.657  1.00  7.59           C
ATOM    133  C   ASP    18      30.052  19.676  20.134  1.00  7.59           C
ATOM    134  O   ASP    18      30.978  20.434  19.781  1.00  7.59           O
ATOM    135  CB  ASP    18      28.709  19.928  18.148  1.00  7.59           C
ATOM    136  CG  ASP    18      29.092  18.527  17.681  1.00  7.59           C
ATOM    137  OD1 ASP    18      29.745  17.749  18.487  1.00  7.59           O
ATOM    138  OD2 ASP    18      28.761  18.116  16.513  1.00  7.59           O
ATOM    139  N   ASN    19      30.098  18.577  20.881  1.00  7.59           N
ATOM    140  CA  ASN    19      31.297  18.002  21.508  1.00  7.59           C
ATOM    141  C   ASN    19      31.640  18.793  22.759  1.00  7.59           C
ATOM    142  O   ASN    19      32.793  18.795  23.212  1.00  7.59           O
ATOM    143  CB  ASN    19      32.453  18.014  20.518  1.00  7.59           C
ATOM    144  CG  ASN    19      32.303  16.937  19.444  1.00  7.59           C
ATOM    145  OD1 ASN    19      31.526  15.998  19.619  1.00  7.59           O
ATOM    146  ND2 ASN    19      33.002  17.014  18.330  1.00  7.59           N
ATOM    147  N   TYR    20      30.598  19.414  23.259  1.00  7.59           N
ATOM    148  CA  TYR    20      30.660  20.291  24.426  1.00  7.59           C
ATOM    149  C   TYR    20      31.021  19.531  25.710  1.00  7.59           C
ATOM    150  O   TYR    20      30.638  18.363  25.891  1.00  7.59           O
ATOM    151  CB  TYR    20      29.320  20.964  24.643  1.00  7.59           C
ATOM    152  CG  TYR    20      29.353  21.867  25.857  1.00  7.59           C
ATOM    153  CD1 TYR    20      29.745  23.199  25.718  1.00  7.59           C
ATOM    154  CD2 TYR    20      29.005  21.348  27.102  1.00  7.59           C
ATOM    155  CE1 TYR    20      29.786  24.026  26.840  1.00  7.59           C
ATOM    156  CE2 TYR    20      29.046  22.175  28.226  1.00  7.59           C
ATOM    157  CZ  TYR    20      29.436  23.515  28.095  1.00  7.59           C
ATOM    158  OH  TYR    20      29.474  24.317  29.189  1.00  7.59           O
ATOM    159  N   ARG    21      31.741  20.279  26.537  1.00  7.59           N
ATOM    160  CA  ARG    21      32.270  19.842  27.840  1.00  7.59           C
ATOM    161  C   ARG    21      32.600  18.353  27.808  1.00  7.59           C
ATOM    162  O   ARG    21      32.448  17.641  28.814  1.00  7.59           O
ATOM    163  CB  ARG    21      31.274  20.136  28.965  1.00  7.59           C
ATOM    164  CG  ARG    21      31.894  20.941  30.124  1.00  7.59           C
ATOM    165  CD  ARG    21      33.402  21.194  29.957  1.00  7.59           C
ATOM    166  NE  ARG    21      33.952  22.148  30.944  1.00  7.59           N
ATOM    167  CZ  ARG    21      33.855  22.000  32.276  1.00  7.59           C
ATOM    168  NH1 ARG    21      33.225  20.944  32.809  1.00  7.59           N
ATOM    169  NH2 ARG    21      34.359  22.865  33.169  1.00  7.59           N
ATOM    170  N   GLY    22      33.041  17.933  26.636  1.00  7.59           N
ATOM    171  CA  GLY    22      33.508  16.564  26.419  1.00  7.59           C
ATOM    172  C   GLY    22      32.548  15.704  25.582  1.00  7.59           C
ATOM    173  O   GLY    22      32.973  14.811  24.838  1.00  7.59           O
ATOM    174  N   TYR    23      31.357  16.113  25.408  1.00  7.59           N
ATOM    175  CA  TYR    23      30.281  15.256  24.978  1.00  7.59           C
ATOM    176  C   TYR    23      29.693  15.575  23.645  1.00  7.59           C
ATOM    177  O   TYR    23      29.373  16.716  23.359  1.00  7.59           O
ATOM    178  CB  TYR    23      29.200  15.235  25.934  1.00  7.59           C
ATOM    179  CG  TYR    23      29.546  15.136  27.383  1.00  7.59           C
ATOM    180  CD1 TYR    23      29.801  16.191  28.049  1.00  7.59           C
ATOM    181  CD2 TYR    23      29.610  13.984  28.037  1.00  7.59           C
ATOM    182  CE1 TYR    23      30.107  16.101  29.373  1.00  7.59           C
ATOM    183  CE2 TYR    23      29.913  13.894  29.364  1.00  7.59           C
ATOM    184  CZ  TYR    23      30.159  14.953  30.032  1.00  7.59           C
ATOM    185  OH  TYR    23      30.446  14.864  31.324  1.00  7.59           O
ATOM    186  N   SER    24      29.590  14.485  22.945  1.00  7.59           N
ATOM    187  CA  SER    24      29.115  14.395  21.586  1.00  7.59           C
ATOM    188  C   SER    24      27.635  14.670  21.436  1.00  7.59           C
ATOM    189  O   SER    24      26.845  14.409  22.356  1.00  7.59           O
ATOM    190  CB  SER    24      29.342  13.017  21.056  1.00  7.59           C
ATOM    191  OG  SER    24      28.951  12.294  20.706  1.00  7.59           O
ATOM    192  N   LEU    25      27.391  15.182  20.251  1.00  7.59           N
ATOM    193  CA  LEU    25      26.080  15.561  19.751  1.00  7.59           C
ATOM    194  C   LEU    25      25.282  14.385  19.635  1.00  7.59           C
ATOM    195  O   LEU    25      24.805  14.419  19.301  1.00  7.59           O
ATOM    196  CB  LEU    25      26.184  16.216  18.462  1.00  7.59           C
ATOM    197  CG  LEU    25      24.968  16.904  17.913  1.00  7.59           C
ATOM    198  CD1 LEU    25      25.007  18.139  17.926  1.00  7.59           C
ATOM    199  CD2 LEU    25      24.727  16.648  16.737  1.00  7.59           C
ATOM    200  N   GLY    26      25.184  13.422  19.943  1.00  7.59           N
ATOM    201  CA  GLY    26      24.454  12.192  20.057  1.00  7.59           C
ATOM    202  C   GLY    26      24.190  12.092  21.516  1.00  7.59           C
ATOM    203  O   GLY    26      23.136  11.743  21.904  1.00  7.59           O
ATOM    204  N   ASN    27      25.190  12.446  22.234  1.00  7.59           N
ATOM    205  CA  ASN    27      25.179  12.555  23.664  1.00  7.59           C
ATOM    206  C   ASN    27      24.305  13.749  24.005  1.00  7.59           C
ATOM    207  O   ASN    27      24.239  14.188  25.152  1.00  7.59           O
ATOM    208  CB  ASN    27      26.597  12.756  24.175  1.00  7.59           C
ATOM    209  CG  ASN    27      27.309  11.481  24.546  1.00  7.59           C
ATOM    210  OD1 ASN    27      26.734  10.632  25.196  1.00  7.59           O
ATOM    211  ND2 ASN    27      28.535  11.292  24.166  1.00  7.59           N
ATOM    212  N   TRP    28      23.646  14.249  22.971  1.00  7.59           N
ATOM    213  CA  TRP    28      22.743  15.395  23.106  1.00  7.59           C
ATOM    214  C   TRP    28      21.520  15.229  22.193  1.00  7.59           C
ATOM    215  O   TRP    28      20.541  15.977  22.290  1.00  7.59           O
ATOM    216  CB  TRP    28      23.501  16.688  22.806  1.00  7.59           C
ATOM    217  CG  TRP    28      24.528  17.012  23.881  1.00  7.59           C
ATOM    218  CD1 TRP    28      25.798  16.768  23.861  1.00  7.59           C
ATOM    219  CD2 TRP    28      24.285  17.628  25.098  1.00  7.59           C
ATOM    220  NE1 TRP    28      26.366  17.230  25.076  1.00  7.59           N
ATOM    221  CE2 TRP    28      25.463  17.732  25.786  1.00  7.59           C
ATOM    222  CE3 TRP    28      23.171  18.107  25.668  1.00  7.59           C
ATOM    223  CZ2 TRP    28      25.601  18.292  27.034  1.00  7.59           C
ATOM    224  CZ3 TRP    28      23.320  18.670  26.926  1.00  7.59           C
ATOM    225  CH2 TRP    28      24.478  18.759  27.574  1.00  7.59           C
ATOM    226  N   VAL    29      21.589  14.240  21.316  1.00  7.59           N
ATOM    227  CA  VAL    29      20.467  13.928  20.418  1.00  7.59           C
ATOM    228  C   VAL    29      19.730  12.690  20.936  1.00  7.59           C
ATOM    229  O   VAL    29      18.580  12.432  20.580  1.00  7.59           O
ATOM    230  CB  VAL    29      20.960  13.671  18.993  1.00  7.59           C
ATOM    231  CG1 VAL    29      19.826  13.316  18.022  1.00  7.59           C
ATOM    232  CG2 VAL    29      21.660  14.883  18.374  1.00  7.59           C
ATOM    233  N   CYS    30      20.419  11.949  21.784  1.00  7.59           N
ATOM    234  CA  CYS    30      19.872  10.723  22.387  1.00  7.59           C
ATOM    235  C   CYS    30      19.310  11.013  23.744  1.00  7.59           C
ATOM    236  O   CYS    30      18.486  10.422  24.147  1.00  7.59           O
ATOM    237  CB  CYS    30      20.926   9.652  22.536  1.00  7.59           C
ATOM    238  SG  CYS    30      20.299   8.030  23.121  1.00  7.59           S
ATOM    239  N   ALA    31      19.749  11.920  24.433  1.00  7.59           N
ATOM    240  CA  ALA    31      19.286  12.315  25.724  1.00  7.59           C
ATOM    241  C   ALA    31      18.038  13.144  25.600  1.00  7.59           C
ATOM    242  O   ALA    31      17.446  13.449  26.282  1.00  7.59           O
ATOM    243  CB  ALA    31      20.309  13.151  26.409  1.00  7.59           C
ATOM    244  N   ALA    32      17.656  13.496  24.729  1.00  7.59           N
ATOM    245  CA  ALA    32      16.516  14.335  24.497  1.00  7.59           C
ATOM    246  C   ALA    32      15.255  13.537  24.161  1.00  7.59           C
ATOM    247  O   ALA    32      14.170  13.813  24.572  1.00  7.59           O
ATOM    248  CB  ALA    32      16.810  15.259  23.395  1.00  7.59           C
ATOM    249  N   LYS    33      15.414  12.567  23.413  1.00  7.59           N
ATOM    250  CA  LYS    33      14.298  11.698  23.030  1.00  7.59           C
ATOM    251  C   LYS    33      13.778  10.980  24.265  1.00  7.59           C
ATOM    252  O   LYS    33      12.582  10.707  24.385  1.00  7.59           O
ATOM    253  CB  LYS    33      14.751  10.655  22.010  1.00  7.59           C
ATOM    254  CG  LYS    33      13.642   9.655  21.656  1.00  7.59           C
ATOM    255  CD  LYS    33      13.329   9.375  20.688  1.00  7.59           C
ATOM    256  CE  LYS    33      12.192   8.594  20.123  1.00  7.59           C
ATOM    257  NZ  LYS    33      11.923   8.397  19.095  1.00  7.59           N
ATOM    258  N   PHE    34      14.715  10.709  25.144  1.00  7.59           N
ATOM    259  CA  PHE    34      14.442  10.012  26.396  1.00  7.59           C
ATOM    260  C   PHE    34      13.830  10.983  27.418  1.00  7.59           C
ATOM    261  O   PHE    34      13.177  10.599  28.315  1.00  7.59           O
ATOM    262  CB  PHE    34      15.734   9.379  26.916  1.00  7.59           C
ATOM    263  CG  PHE    34      16.088   8.086  26.168  1.00  7.59           C
ATOM    264  CD1 PHE    34      16.948   8.111  25.077  1.00  7.59           C
ATOM    265  CD2 PHE    34      15.549   6.874  26.565  1.00  7.59           C
ATOM    266  CE1 PHE    34      17.261   6.930  24.389  1.00  7.59           C
ATOM    267  CE2 PHE    34      15.863   5.696  25.878  1.00  7.59           C
ATOM    268  CZ  PHE    34      16.719   5.724  24.790  1.00  7.59           C
ATOM    269  N   GLU    35      14.029  12.248  27.292  1.00  7.59           N
ATOM    270  CA  GLU    35      13.450  13.249  28.203  1.00  7.59           C
ATOM    271  C   GLU    35      12.128  13.751  27.618  1.00  7.59           C
ATOM    272  O   GLU    35      11.246  13.024  27.395  1.00  7.59           O
ATOM    273  CB  GLU    35      14.417  14.413  28.414  1.00  7.59           C
ATOM    274  CG  GLU    35      15.606  14.052  29.305  1.00  7.59           C
ATOM    275  CD  GLU    35      15.915  14.527  30.221  1.00  7.59           C
ATOM    276  OE1 GLU    35      15.201  15.367  30.323  1.00  7.59           O
ATOM    277  OE2 GLU    35      16.892  14.087  30.894  1.00  7.59           O
ATOM    278  N   SER    36      12.030  14.990  27.376  1.00  7.59           N
ATOM    279  CA  SER    36      10.829  15.638  26.828  1.00  7.59           C
ATOM    280  C   SER    36      10.333  14.922  25.582  1.00  7.59           C
ATOM    281  O   SER    36       9.374  15.300  25.028  1.00  7.59           O
ATOM    282  CB  SER    36      11.118  17.077  26.472  1.00  7.59           C
ATOM    283  OG  SER    36      11.438  17.319  26.573  1.00  7.59           O
ATOM    284  N   ASN    37      11.002  13.893  25.165  1.00  7.59           N
ATOM    285  CA  ASN    37      10.644  13.092  23.986  1.00  7.59           C
ATOM    286  C   ASN    37      10.891  13.859  22.728  1.00  7.59           C
ATOM    287  O   ASN    37      10.731  13.402  21.808  1.00  7.59           O
ATOM    288  CB  ASN    37       9.191  12.762  24.030  1.00  7.59           C
ATOM    289  CG  ASN    37       8.934  11.653  24.276  1.00  7.59           C
ATOM    290  OD1 ASN    37       9.554  10.940  23.765  1.00  7.59           O
ATOM    291  ND2 ASN    37       8.046  11.463  25.039  1.00  7.59           N
ATOM    292  N   PHE    38      11.271  15.009  22.735  1.00  7.59           N
ATOM    293  CA  PHE    38      11.539  15.907  21.626  1.00  7.59           C
ATOM    294  C   PHE    38      10.587  17.077  21.705  1.00  7.59           C
ATOM    295  O   PHE    38      10.528  17.910  20.802  1.00  7.59           O
ATOM    296  CB  PHE    38      11.338  15.161  20.312  1.00  7.59           C
ATOM    297  CG  PHE    38      12.461  14.202  20.026  1.00  7.59           C
ATOM    298  CD1 PHE    38      13.065  13.535  20.140  1.00  7.59           C
ATOM    299  CD2 PHE    38      12.888  14.000  19.659  1.00  7.59           C
ATOM    300  CE1 PHE    38      14.107  12.661  19.886  1.00  7.59           C
ATOM    301  CE2 PHE    38      13.928  13.126  19.405  1.00  7.59           C
ATOM    302  CZ  PHE    38      14.538  12.458  19.519  1.00  7.59           C
ATOM    303  N   ASN    39       9.871  17.092  22.804  1.00  7.59           N
ATOM    304  CA  ASN    39       8.883  18.126  23.075  1.00  7.59           C
ATOM    305  C   ASN    39       9.429  19.159  24.045  1.00  7.59           C
ATOM    306  O   ASN    39       9.757  18.823  25.186  1.00  7.59           O
ATOM    307  CB  ASN    39       7.631  17.512  23.612  1.00  7.59           C
ATOM    308  CG  ASN    39       6.815  17.051  22.612  1.00  7.59           C
ATOM    309  OD1 ASN    39       6.456  17.745  21.839  1.00  7.59           O
ATOM    310  ND2 ASN    39       6.504  15.912  22.575  1.00  7.59           N
ATOM    311  N   THR    40       9.682  20.200  23.417  1.00  7.59           N
ATOM    312  CA  THR    40      10.139  21.428  24.075  1.00  7.59           C
ATOM    313  C   THR    40       9.381  21.724  25.369  1.00  7.59           C
ATOM    314  O   THR    40       9.949  22.270  26.329  1.00  7.59           O
ATOM    315  CB  THR    40       9.899  22.584  23.108  1.00  7.59           C
ATOM    316  OG1 THR    40       8.500  22.801  22.957  1.00  7.59           O
ATOM    317  CG2 THR    40      10.462  22.309  21.709  1.00  7.59           C
ATOM    318  N   GLN    41       8.115  21.379  25.362  1.00  7.59           N
ATOM    319  CA  GLN    41       7.241  21.587  26.522  1.00  7.59           C
ATOM    320  C   GLN    41       7.426  20.448  27.515  1.00  7.59           C
ATOM    321  O   GLN    41       7.276  19.269  27.170  1.00  7.59           O
ATOM    322  CB  GLN    41       5.779  21.613  26.084  1.00  7.59           C
ATOM    323  CG  GLN    41       5.445  22.780  25.155  1.00  7.59           C
ATOM    324  CD  GLN    41       3.960  22.835  24.795  1.00  7.59           C
ATOM    325  OE1 GLN    41       3.169  22.063  25.337  1.00  7.59           O
ATOM    326  NE2 GLN    41       3.527  23.709  23.907  1.00  7.59           N
ATOM    327  N   ALA    42       7.752  20.830  28.730  1.00  7.59           N
ATOM    328  CA  ALA    42       7.959  19.875  29.820  1.00  7.59           C
ATOM    329  C   ALA    42       6.800  19.970  30.802  1.00  7.59           C
ATOM    330  O   ALA    42       5.704  20.437  30.454  1.00  7.59           O
ATOM    331  CB  ALA    42       9.265  20.188  30.550  1.00  7.59           C
ATOM    332  N   THR    43       7.076  19.524  32.006  1.00  7.59           N
ATOM    333  CA  THR    43       6.097  19.552  33.088  1.00  7.59           C
ATOM    334  C   THR    43       5.974  18.160  33.723  1.00  7.59           C
ATOM    335  O   THR    43       4.865  17.691  34.024  1.00  7.59           O
ATOM    336  CB  THR    43       4.756  20.035  32.529  1.00  7.59           C
ATOM    337  OG1 THR    43       4.333  19.188  31.472  1.00  7.59           O
ATOM    338  CG2 THR    43       4.830  21.460  31.962  1.00  7.59           C
ATOM    339  N   ASN    44       7.146  17.564  33.893  1.00  7.59           N
ATOM    340  CA  ASN    44       7.321  16.250  34.543  1.00  7.59           C
ATOM    341  C   ASN    44       7.656  16.505  36.026  1.00  7.59           C
ATOM    342  O   ASN    44       8.831  16.642  36.397  1.00  7.59           O
ATOM    343  CB  ASN    44       8.478  15.490  33.864  1.00  7.59           C
ATOM    344  CG  ASN    44       8.019  14.373  32.913  1.00  7.59           C
ATOM    345  OD1 ASN    44       7.076  13.648  33.223  1.00  7.59           O
ATOM    346  ND2 ASN    44       8.638  14.186  31.758  1.00  7.59           N
ATOM    347  N   ARG    45       6.595  16.572  36.833  1.00  7.59           N
ATOM    348  CA  ARG    45       6.683  16.891  38.286  1.00  7.59           C
ATOM    349  C   ARG    45       7.667  15.975  39.022  1.00  7.59           C
ATOM    350  O   ARG    45       8.557  15.366  38.412  1.00  7.59           O
ATOM    351  CB  ARG    45       5.313  16.769  38.973  1.00  7.59           C
ATOM    352  CG  ARG    45       4.701  18.139  39.307  1.00  7.59           C
ATOM    353  CD  ARG    45       4.112  18.251  40.727  1.00  7.59           C
ATOM    354  NE  ARG    45       3.281  19.462  40.887  1.00  7.59           N
ATOM    355  CZ  ARG    45       2.757  19.902  42.047  1.00  7.59           C
ATOM    356  NH1 ARG    45       2.959  19.248  43.197  1.00  7.59           N
ATOM    357  NH2 ARG    45       2.000  21.008  42.154  1.00  7.59           N
ATOM    358  N   ASN    46       7.466  15.922  40.334  1.00  7.59           N
ATOM    359  CA  ASN    46       8.321  15.140  41.239  1.00  7.59           C
ATOM    360  C   ASN    46       7.789  15.193  42.681  1.00  7.59           C
ATOM    361  O   ASN    46       7.207  16.200  43.112  1.00  7.59           O
ATOM    362  CB  ASN    46       9.735  15.722  41.217  1.00  7.59           C
ATOM    363  CG  ASN    46      10.649  15.035  40.203  1.00  7.59           C
ATOM    364  OD1 ASN    46      11.422  14.158  40.579  1.00  7.59           O
ATOM    365  ND2 ASN    46      10.610  15.384  38.931  1.00  7.59           N
ATOM    366  N   THR    47       8.028  14.087  43.373  1.00  7.59           N
ATOM    367  CA  THR    47       7.606  13.874  44.775  1.00  7.59           C
ATOM    368  C   THR    47       8.025  15.044  45.673  1.00  7.59           C
ATOM    369  O   THR    47       7.184  15.670  46.337  1.00  7.59           O
ATOM    370  CB  THR    47       8.261  12.610  45.334  1.00  7.59           C
ATOM    371  OG1 THR    47       9.676  12.753  45.328  1.00  7.59           O
ATOM    372  CG2 THR    47       7.928  11.354  44.527  1.00  7.59           C
ATOM    373  N   ASP    48       9.324  15.292  45.669  1.00  7.59           N
ATOM    374  CA  ASP    48       9.944  16.353  46.485  1.00  7.59           C
ATOM    375  C   ASP    48       9.210  17.680  46.287  1.00  7.59           C
ATOM    376  O   ASP    48       8.960  18.424  47.245  1.00  7.59           O
ATOM    377  CB  ASP    48      11.413  16.525  46.108  1.00  7.59           C
ATOM    378  CG  ASP    48      11.620  16.865  44.634  1.00  7.59           C
ATOM    379  OD1 ASP    48      10.601  17.009  43.858  1.00  7.59           O
ATOM    380  OD2 ASP    48      12.813  17.005  44.168  1.00  7.59           O
ATOM    381  N   GLY    49       8.884  17.972  45.044  1.00  7.59           N
ATOM    382  CA  GLY    49       8.128  19.189  44.728  1.00  7.59           C
ATOM    383  C   GLY    49       8.836  20.074  43.697  1.00  7.59           C
ATOM    384  O   GLY    49       8.418  21.206  43.428  1.00  7.59           O
ATOM    385  N   SER    50       9.908  19.584  43.126  1.00  7.59           N
ATOM    386  CA  SER    50      10.602  20.338  42.075  1.00  7.59           C
ATOM    387  C   SER    50      10.056  19.838  40.734  1.00  7.59           C
ATOM    388  O   SER    50      10.146  18.648  40.411  1.00  7.59           O
ATOM    389  CB  SER    50      12.116  20.140  42.210  1.00  7.59           C
ATOM    390  OG  SER    50      12.618  19.404  41.110  1.00  7.59           O
ATOM    391  N   THR    51       9.468  20.750  39.975  1.00  7.59           N
ATOM    392  CA  THR    51       8.854  20.403  38.677  1.00  7.59           C
ATOM    393  C   THR    51       9.961  19.945  37.705  1.00  7.59           C
ATOM    394  O   THR    51      10.684  18.987  37.954  1.00  7.59           O
ATOM    395  CB  THR    51       8.025  21.586  38.174  1.00  7.59           C
ATOM    396  OG1 THR    51       6.909  21.787  39.042  1.00  7.59           O
ATOM    397  CG2 THR    51       7.466  21.370  36.768  1.00  7.59           C
ATOM    398  N   ASP    52      10.120  20.602  36.573  1.00  7.59           N
ATOM    399  CA  ASP    52      11.192  20.208  35.612  1.00  7.59           C
ATOM    400  C   ASP    52      10.505  20.023  34.225  1.00  7.59           C
ATOM    401  O   ASP    52       9.792  19.014  34.014  1.00  7.59           O
ATOM    402  CB  ASP    52      12.048  19.096  36.307  1.00  7.59           C
ATOM    403  CG  ASP    52      11.702  17.621  36.065  1.00  7.59           C
ATOM    404  OD1 ASP    52      10.510  17.251  35.774  1.00  7.59           O
ATOM    405  OD2 ASP    52      12.648  16.733  36.169  1.00  7.59           O
ATOM    406  N   TYR    53      10.863  21.089  33.450  1.00  7.59           N
ATOM    407  CA  TYR    53      10.270  21.629  32.169  1.00  7.59           C
ATOM    408  C   TYR    53      11.031  21.485  30.891  1.00  7.59           C
ATOM    409  O   TYR    53      12.005  22.072  30.578  1.00  7.59           O
ATOM    410  CB  TYR    53      10.366  23.151  32.297  1.00  7.59           C
ATOM    411  CG  TYR    53       9.542  23.570  33.436  1.00  7.59           C
ATOM    412  CD1 TYR    53      10.067  23.612  34.736  1.00  7.59           C
ATOM    413  CD2 TYR    53       8.243  23.861  33.144  1.00  7.59           C
ATOM    414  CE1 TYR    53       9.201  23.915  35.788  1.00  7.59           C
ATOM    415  CE2 TYR    53       7.372  24.143  34.187  1.00  7.59           C
ATOM    416  CZ  TYR    53       7.846  24.163  35.510  1.00  7.59           C
ATOM    417  OH  TYR    53       6.974  24.412  36.516  1.00  7.59           O
ATOM    418  N   GLY    54      10.774  20.760  29.907  1.00  7.59           N
ATOM    419  CA  GLY    54      11.804  20.977  28.865  1.00  7.59           C
ATOM    420  C   GLY    54      12.536  19.702  28.546  1.00  7.59           C
ATOM    421  O   GLY    54      12.761  18.843  29.414  1.00  7.59           O
ATOM    422  N   ILE    55      12.844  19.671  27.279  1.00  7.59           N
ATOM    423  CA  ILE    55      13.426  18.525  26.599  1.00  7.59           C
ATOM    424  C   ILE    55      14.650  17.969  27.335  1.00  7.59           C
ATOM    425  O   ILE    55      14.904  16.725  27.288  1.00  7.59           O
ATOM    426  CB  ILE    55      13.830  18.937  25.182  1.00  7.59           C
ATOM    427  CG1 ILE    55      12.657  19.510  24.378  1.00  7.59           C
ATOM    428  CG2 ILE    55      14.375  17.776  24.351  1.00  7.59           C
ATOM    429  CD1 ILE    55      13.071  20.037  23.004  1.00  7.59           C
ATOM    430  N   LEU    56      15.233  19.327  28.280  1.00  7.59           N
ATOM    431  CA  LEU    56      16.456  18.859  28.938  1.00  7.59           C
ATOM    432  C   LEU    56      16.246  18.625  30.433  1.00  7.59           C
ATOM    433  O   LEU    56      17.219  18.297  31.084  1.00  7.59           O
ATOM    434  CB  LEU    56      17.595  19.846  28.712  1.00  7.59           C
ATOM    435  CG  LEU    56      18.220  19.723  27.397  1.00  7.59           C
ATOM    436  CD1 LEU    56      19.465  20.554  27.279  1.00  7.59           C
ATOM    437  CD2 LEU    56      18.572  18.301  27.046  1.00  7.59           C
ATOM    438  N   GLN    57      15.028  18.777  30.979  1.00  7.59           N
ATOM    439  CA  GLN    57      14.635  18.460  32.390  1.00  7.59           C
ATOM    440  C   GLN    57      15.522  19.216  33.381  1.00  7.59           C
ATOM    441  O   GLN    57      16.107  18.615  34.279  1.00  7.59           O
ATOM    442  CB  GLN    57      14.738  16.962  32.643  1.00  7.59           C
ATOM    443  CG  GLN    57      13.631  16.149  32.042  1.00  7.59           C
ATOM    444  CD  GLN    57      13.004  15.834  32.120  1.00  7.59           C
ATOM    445  OE1 GLN    57      13.039  15.790  33.059  1.00  7.59           O
ATOM    446  NE2 GLN    57      12.421  15.605  31.179  1.00  7.59           N
ATOM    447  N   ILE    58      15.708  20.334  33.458  1.00  7.59           N
ATOM    448  CA  ILE    58      16.296  21.449  34.129  1.00  7.59           C
ATOM    449  C   ILE    58      16.129  21.911  34.169  1.00  7.59           C
ATOM    450  O   ILE    58      15.350  22.711  34.084  1.00  7.59           O
ATOM    451  CB  ILE    58      16.944  22.051  34.283  1.00  7.59           C
ATOM    452  CG1 ILE    58      17.081  21.590  34.238  1.00  7.59           C
ATOM    453  CG2 ILE    58      17.614  23.240  34.912  1.00  7.59           C
ATOM    454  CD1 ILE    58      17.838  22.193  34.421  1.00  7.59           C
ATOM    455  N   ASN    59      16.134  21.231  36.527  1.00  7.59           N
ATOM    456  CA  ASN    59      15.558  21.103  37.874  1.00  7.59           C
ATOM    457  C   ASN    59      15.232  22.478  38.460  1.00  7.59           C
ATOM    458  O   ASN    59      16.012  23.349  38.298  1.00  7.59           O
ATOM    459  CB  ASN    59      16.537  20.388  38.791  1.00  7.59           C
ATOM    460  CG  ASN    59      16.854  18.984  38.311  1.00  7.59           C
ATOM    461  OD1 ASN    59      15.957  18.156  38.193  1.00  7.59           O
ATOM    462  ND2 ASN    59      18.091  18.663  38.022  1.00  7.59           N
ATOM    463  N   SER    60      14.163  22.645  39.121  1.00  7.59           N
ATOM    464  CA  SER    60      13.714  23.931  39.687  1.00  7.59           C
ATOM    465  C   SER    60      14.629  24.371  40.807  1.00  7.59           C
ATOM    466  O   SER    60      14.957  25.526  40.875  1.00  7.59           O
ATOM    467  CB  SER    60      12.307  23.810  40.243  1.00  7.59           C
ATOM    468  OG  SER    60      12.272  22.807  41.231  1.00  7.59           O
ATOM    469  N   ARG    61      15.002  23.487  41.663  1.00  7.59           N
ATOM    470  CA  ARG    61      15.832  23.773  42.832  1.00  7.59           C
ATOM    471  C   ARG    61      17.211  24.336  42.450  1.00  7.59           C
ATOM    472  O   ARG    61      17.962  24.739  43.340  1.00  7.59           O
ATOM    473  CB  ARG    61      16.112  22.488  43.605  1.00  7.59           C
ATOM    474  CG  ARG    61      15.392  22.368  44.903  1.00  7.59           C
ATOM    475  CD  ARG    61      15.927  21.226  45.714  1.00  7.59           C
ATOM    476  NE  ARG    61      15.842  21.333  47.128  1.00  7.59           N
ATOM    477  CZ  ARG    61      16.071  21.051  48.122  1.00  7.59           C
ATOM    478  NH1 ARG    61      16.408  20.647  47.870  1.00  7.59           N
ATOM    479  NH2 ARG    61      15.984  21.146  49.413  1.00  7.59           N
ATOM    480  N   TRP    62      17.554  24.375  41.144  1.00  7.59           N
ATOM    481  CA  TRP    62      18.920  24.802  40.765  1.00  7.59           C
ATOM    482  C   TRP    62      19.019  25.693  39.577  1.00  7.59           C
ATOM    483  O   TRP    62      19.721  26.719  39.610  1.00  7.59           O
ATOM    484  CB  TRP    62      19.735  23.616  40.589  1.00  7.59           C
ATOM    485  CG  TRP    62      19.424  22.436  41.489  1.00  7.59           C
ATOM    486  CD1 TRP    62      18.745  21.345  41.167  1.00  7.59           C
ATOM    487  CD2 TRP    62      19.810  22.316  42.836  1.00  7.59           C
ATOM    488  NE1 TRP    62      18.705  20.526  42.318  1.00  7.59           N
ATOM    489  CE2 TRP    62      19.335  21.112  43.285  1.00  7.59           C
ATOM    490  CE3 TRP    62      20.519  23.121  43.706  1.00  7.59           C
ATOM    491  CZ2 TRP    62      19.536  20.653  44.576  1.00  7.59           C
ATOM    492  CZ3 TRP    62      20.715  22.653  45.004  1.00  7.59           C
ATOM    493  CH2 TRP    62      20.245  21.476  45.416  1.00  7.59           C
ATOM    494  N   TRP    63      18.311  25.288  38.611  1.00  7.59           N
ATOM    495  CA  TRP    63      18.368  25.902  37.343  1.00  7.59           C
ATOM    496  C   TRP    63      17.220  26.841  37.095  1.00  7.59           C
ATOM    497  O   TRP    63      17.372  27.906  36.538  1.00  7.59           O
ATOM    498  CB  TRP    63      18.424  24.802  36.336  1.00  7.59           C
ATOM    499  CG  TRP    63      19.479  23.794  36.733  1.00  7.59           C
ATOM    500  CD1 TRP    63      19.320  22.479  36.895  1.00  7.59           C
ATOM    501  CD2 TRP    63      20.821  24.126  37.012  1.00  7.59           C
ATOM    502  NE1 TRP    63      20.591  21.960  37.279  1.00  7.59           N
ATOM    503  CE2 TRP    63      21.459  22.945  37.338  1.00  7.59           C
ATOM    504  CE3 TRP    63      21.550  25.320  37.006  1.00  7.59           C
ATOM    505  CZ2 TRP    63      22.813  22.882  37.663  1.00  7.59           C
ATOM    506  CZ3 TRP    63      22.914  25.245  37.332  1.00  7.59           C
ATOM    507  CH2 TRP    63      23.516  24.084  37.645  1.00  7.59           C
ATOM    508  N   CYS    64      16.023  26.536  37.464  1.00  7.59           N
ATOM    509  CA  CYS    64      15.031  27.498  37.052  1.00  7.59           C
ATOM    510  C   CYS    64      14.094  27.859  38.179  1.00  7.59           C
ATOM    511  O   CYS    64      13.967  27.132  39.140  1.00  7.59           O
ATOM    512  CB  CYS    64      14.228  26.917  35.919  1.00  7.59           C
ATOM    513  SG  CYS    64      12.598  27.264  35.783  1.00  7.59           S
ATOM    514  N   ASN    65      13.426  28.996  38.048  1.00  7.59           N
ATOM    515  CA  ASN    65      12.484  29.418  39.068  1.00  7.59           C
ATOM    516  C   ASN    65      11.139  29.370  38.658  1.00  7.59           C
ATOM    517  O   ASN    65      10.839  29.859  37.638  1.00  7.59           O
ATOM    518  CB  ASN    65      12.585  30.768  39.503  1.00  7.59           C
ATOM    519  CG  ASN    65      11.918  31.444  40.498  1.00  7.59           C
ATOM    520  OD1 ASN    65      11.156  31.623  40.447  1.00  7.59           O
ATOM    521  ND2 ASN    65      12.151  31.842  41.402  1.00  7.59           N
ATOM    522  N   ASP    66      10.389  28.815  39.491  1.00  7.59           N
ATOM    523  CA  ASP    66       9.057  28.586  39.197  1.00  7.59           C
ATOM    524  C   ASP    66       8.059  29.231  40.088  1.00  7.59           C
ATOM    525  O   ASP    66       6.912  29.137  39.806  1.00  7.59           O
ATOM    526  CB  ASP    66       8.735  27.133  39.233  1.00  7.59           C
ATOM    527  CG  ASP    66       9.433  26.325  40.279  1.00  7.59           C
ATOM    528  OD1 ASP    66       9.960  26.899  41.207  1.00  7.59           O
ATOM    529  OD2 ASP    66       9.485  25.056  40.230  1.00  7.59           O
ATOM    530  N   GLY    67       8.410  29.905  41.128  1.00  7.59           N
ATOM    531  CA  GLY    67       7.373  30.456  42.030  1.00  7.59           C
ATOM    532  C   GLY    67       6.890  29.480  42.929  1.00  7.59           C
ATOM    533  O   GLY    67       6.405  29.891  43.683  1.00  7.59           O
ATOM    534  N   ARG    68       7.065  28.196  42.840  1.00  7.59           N
ATOM    535  CA  ARG    68       6.548  27.149  43.639  1.00  7.59           C
ATOM    536  C   ARG    68       7.485  26.124  44.203  1.00  7.59           C
ATOM    537  O   ARG    68       7.072  25.317  44.852  1.00  7.59           O
ATOM    538  CB  ARG    68       5.730  26.292  42.864  1.00  7.59           C
ATOM    539  CG  ARG    68       4.869  26.049  42.086  1.00  7.59           C
ATOM    540  CD  ARG    68       4.132  24.958  41.511  1.00  7.59           C
ATOM    541  NE  ARG    68       3.540  24.998  40.233  1.00  7.59           N
ATOM    542  CZ  ARG    68       2.807  24.133  39.577  1.00  7.59           C
ATOM    543  NH1 ARG    68       2.564  23.150  40.060  1.00  7.59           N
ATOM    544  NH2 ARG    68       2.269  24.166  38.417  1.00  7.59           N
ATOM    545  N   THR    69       8.724  26.136  43.951  1.00  7.59           N
ATOM    546  CA  THR    69       9.723  25.175  44.385  1.00  7.59           C
ATOM    547  C   THR    69      10.778  25.939  45.197  1.00  7.59           C
ATOM    548  O   THR    69      11.779  26.384  44.606  1.00  7.59           O
ATOM    549  CB  THR    69      10.197  24.464  43.181  1.00  7.59           C
ATOM    550  OG1 THR    69      10.992  25.326  42.491  1.00  7.59           O
ATOM    551  CG2 THR    69       9.084  23.986  42.282  1.00  7.59           C
ATOM    552  N   PRO    70      10.411  26.012  46.486  1.00  7.59           N
ATOM    553  CA  PRO    70      11.008  26.816  47.573  1.00  7.59           C
ATOM    554  C   PRO    70      12.414  26.583  47.997  1.00  7.59           C
ATOM    555  O   PRO    70      13.009  27.468  48.615  1.00  7.59           O
ATOM    556  CB  PRO    70      10.151  26.542  48.770  1.00  7.59           C
ATOM    557  CG  PRO    70       9.074  25.561  48.345  1.00  7.59           C
ATOM    558  CD  PRO    70       9.255  25.221  46.910  1.00  7.59           C
ATOM    559  N   GLY    71      13.029  25.481  47.780  1.00  7.59           N
ATOM    560  CA  GLY    71      14.424  25.399  48.212  1.00  7.59           C
ATOM    561  C   GLY    71      15.289  25.951  47.158  1.00  7.59           C
ATOM    562  O   GLY    71      16.442  25.941  47.378  1.00  7.59           O
ATOM    563  N   SER    72      14.597  26.385  46.130  1.00  7.59           N
ATOM    564  CA  SER    72      15.053  26.968  44.853  1.00  7.59           C
ATOM    565  C   SER    72      15.957  28.196  44.992  1.00  7.59           C
ATOM    566  O   SER    72      15.572  29.233  45.507  1.00  7.59           O
ATOM    567  CB  SER    72      13.852  27.377  44.016  1.00  7.59           C
ATOM    568  OG  SER    72      13.183  28.298  44.438  1.00  7.59           O
ATOM    569  N   ARG    73      16.979  27.955  44.385  1.00  7.59           N
ATOM    570  CA  ARG    73      18.043  28.971  44.232  1.00  7.59           C
ATOM    571  C   ARG    73      18.334  29.271  42.823  1.00  7.59           C
ATOM    572  O   ARG    73      19.219  29.273  42.503  1.00  7.59           O
ATOM    573  CB  ARG    73      19.348  28.451  44.809  1.00  7.59           C
ATOM    574  CG  ARG    73      19.208  27.858  46.209  1.00  7.59           C
ATOM    575  CD  ARG    73      20.375  26.952  46.577  1.00  7.59           C
ATOM    576  NE  ARG    73      20.574  26.790  48.018  1.00  7.59           N
ATOM    577  CZ  ARG    73      21.215  25.886  48.622  1.00  7.59           C
ATOM    578  NH1 ARG    73      21.726  25.059  47.925  1.00  7.59           N
ATOM    579  NH2 ARG    73      21.398  25.730  49.937  1.00  7.59           N
ATOM    580  N   ASN    74      17.636  29.524  41.952  1.00  7.59           N
ATOM    581  CA  ASN    74      17.842  29.885  40.626  1.00  7.59           C
ATOM    582  C   ASN    74      19.287  30.049  40.191  1.00  7.59           C
ATOM    583  O   ASN    74      19.795  31.156  40.063  1.00  7.59           O
ATOM    584  CB  ASN    74      17.288  31.160  40.382  1.00  7.59           C
ATOM    585  CG  ASN    74      16.848  31.329  39.089  1.00  7.59           C
ATOM    586  OD1 ASN    74      16.765  30.506  38.637  1.00  7.59           O
ATOM    587  ND2 ASN    74      16.554  32.338  38.467  1.00  7.59           N
ATOM    588  N   LEU    75      19.981  28.995  39.915  1.00  7.59           N
ATOM    589  CA  LEU    75      21.354  29.194  39.491  1.00  7.59           C
ATOM    590  C   LEU    75      21.436  29.576  38.007  1.00  7.59           C
ATOM    591  O   LEU    75      22.418  29.879  37.505  1.00  7.59           O
ATOM    592  CB  LEU    75      22.184  27.998  39.842  1.00  7.59           C
ATOM    593  CG  LEU    75      22.411  27.926  41.279  1.00  7.59           C
ATOM    594  CD1 LEU    75      23.492  27.598  41.400  1.00  7.59           C
ATOM    595  CD2 LEU    75      22.257  28.927  42.096  1.00  7.59           C
ATOM    596  N   CYS    76      20.442  29.603  37.236  1.00  7.59           N
ATOM    597  CA  CYS    76      20.571  29.984  35.836  1.00  7.59           C
ATOM    598  C   CYS    76      19.933  31.345  35.583  1.00  7.59           C
ATOM    599  O   CYS    76      20.078  31.962  34.525  1.00  7.59           O
ATOM    600  CB  CYS    76      19.948  28.920  34.932  1.00  7.59           C
ATOM    601  SG  CYS    76      20.086  29.267  33.163  1.00  7.59           S
ATOM    602  N   ASN    77      19.228  31.803  36.403  1.00  7.59           N
ATOM    603  CA  ASN    77      18.520  33.105  36.509  1.00  7.59           C
ATOM    604  C   ASN    77      17.516  33.339  35.439  1.00  7.59           C
ATOM    605  O   ASN    77      17.539  34.312  34.704  1.00  7.59           O
ATOM    606  CB  ASN    77      19.438  34.287  36.357  1.00  7.59           C
ATOM    607  CG  ASN    77      19.402  35.149  37.560  1.00  7.59           C
ATOM    608  OD1 ASN    77      19.387  35.628  38.242  1.00  7.59           O
ATOM    609  ND2 ASN    77      19.367  35.366  37.875  1.00  7.59           N
ATOM    610  N   ILE    78      16.636  32.479  35.340  1.00  7.59           N
ATOM    611  CA  ILE    78      15.618  32.660  34.400  1.00  7.59           C
ATOM    612  C   ILE    78      14.308  32.212  34.937  1.00  7.59           C
ATOM    613  O   ILE    78      14.262  31.582  35.927  1.00  7.59           O
ATOM    614  CB  ILE    78      15.872  31.881  33.180  1.00  7.59           C
ATOM    615  CG1 ILE    78      15.822  32.194  32.238  1.00  7.59           C
ATOM    616  CG2 ILE    78      15.322  31.212  33.133  1.00  7.59           C
ATOM    617  CD1 ILE    78      16.030  31.379  31.060  1.00  7.59           C
ATOM    618  N   PRO    79      13.247  32.547  34.309  1.00  7.59           N
ATOM    619  CA  PRO    79      11.920  32.166  34.686  1.00  7.59           C
ATOM    620  C   PRO    79      11.627  30.748  34.571  1.00  7.59           C
ATOM    621  O   PRO    79      11.298  30.545  34.343  1.00  7.59           O
ATOM    622  CB  PRO    79      11.062  32.834  33.732  1.00  7.59           C
ATOM    623  CG  PRO    79      11.956  33.540  32.814  1.00  7.59           C
ATOM    624  CD  PRO    79      13.345  33.341  33.191  1.00  7.59           C
ATOM    625  N   CYS    80      11.704  29.677  34.657  1.00  7.59           N
ATOM    626  CA  CYS    80      11.570  28.304  34.393  1.00  7.59           C
ATOM    627  C   CYS    80      10.495  28.133  33.324  1.00  7.59           C
ATOM    628  O   CYS    80      10.468  27.149  32.659  1.00  7.59           O
ATOM    629  CB  CYS    80      11.218  27.672  35.634  1.00  7.59           C
ATOM    630  SG  CYS    80      12.227  27.565  37.044  1.00  7.59           S
ATOM    631  N   SER    81      10.029  29.236  33.072  1.00  7.59           N
ATOM    632  CA  SER    81       9.111  29.356  31.958  1.00  7.59           C
ATOM    633  C   SER    81       9.755  29.671  30.685  1.00  7.59           C
ATOM    634  O   SER    81       9.163  29.536  29.629  1.00  7.59           O
ATOM    635  CB  SER    81       8.035  30.322  32.221  1.00  7.59           C
ATOM    636  OG  SER    81       8.550  31.533  32.432  1.00  7.59           O
ATOM    637  N   ALA    82      10.784  29.939  30.691  1.00  7.59           N
ATOM    638  CA  ALA    82      11.596  30.363  29.594  1.00  7.59           C
ATOM    639  C   ALA    82      12.004  29.254  28.753  1.00  7.59           C
ATOM    640  O   ALA    82      12.199  29.483  27.730  1.00  7.59           O
ATOM    641  CB  ALA    82      12.787  31.067  30.021  1.00  7.59           C
ATOM    642  N   LEU    83      12.171  28.121  29.338  1.00  7.59           N
ATOM    643  CA  LEU    83      12.726  26.870  28.915  1.00  7.59           C
ATOM    644  C   LEU    83      11.685  25.872  28.378  1.00  7.59           C
ATOM    645  O   LEU    83      11.992  24.702  28.146  1.00  7.59           O
ATOM    646  CB  LEU    83      13.516  26.349  30.094  1.00  7.59           C
ATOM    647  CG  LEU    83      14.700  27.235  30.435  1.00  7.59           C
ATOM    648  CD1 LEU    83      15.637  26.626  31.443  1.00  7.59           C
ATOM    649  CD2 LEU    83      15.552  27.548  29.209  1.00  7.59           C
ATOM    650  N   LEU    84      10.460  26.392  27.876  1.00  7.59           N
ATOM    651  CA  LEU    84       9.354  25.615  27.272  1.00  7.59           C
ATOM    652  C   LEU    84       8.984  26.131  25.841  1.00  7.59           C
ATOM    653  O   LEU    84       8.216  25.545  25.108  1.00  7.59           O
ATOM    654  CB  LEU    84       8.127  25.705  28.162  1.00  7.59           C
ATOM    655  CG  LEU    84       8.121  24.858  29.368  1.00  7.59           C
ATOM    656  CD1 LEU    84       6.952  24.987  30.305  1.00  7.59           C
ATOM    657  CD2 LEU    84       8.181  23.507  29.018  1.00  7.59           C
ATOM    658  N   SER    85       9.612  27.225  25.821  1.00  7.59           N
ATOM    659  CA  SER    85       9.481  27.913  24.511  1.00  7.59           C
ATOM    660  C   SER    85      10.247  27.193  23.445  1.00  7.59           C
ATOM    661  O   SER    85      11.186  26.491  23.728  1.00  7.59           O
ATOM    662  CB  SER    85      10.127  29.272  24.621  1.00  7.59           C
ATOM    663  OG  SER    85      11.387  29.250  24.652  1.00  7.59           O
ATOM    664  N   SER    86       9.817  27.461  22.274  1.00  7.59           N
ATOM    665  CA  SER    86      10.262  26.823  21.058  1.00  7.59           C
ATOM    666  C   SER    86      11.810  26.823  20.810  1.00  7.59           C
ATOM    667  O   SER    86      12.369  25.890  20.215  1.00  7.59           O
ATOM    668  CB  SER    86       9.590  27.520  19.878  1.00  7.59           C
ATOM    669  OG  SER    86       9.089  26.897  19.079  1.00  7.59           O
ATOM    670  N   ASP    87      12.474  27.855  21.209  1.00  7.59           N
ATOM    671  CA  ASP    87      13.920  28.040  21.057  1.00  7.59           C
ATOM    672  C   ASP    87      14.627  27.710  22.292  1.00  7.59           C
ATOM    673  O   ASP    87      14.352  28.304  23.253  1.00  7.59           O
ATOM    674  CB  ASP    87      14.269  29.437  20.722  1.00  7.59           C
ATOM    675  CG  ASP    87      14.262  30.361  20.542  1.00  7.59           C
ATOM    676  OD1 ASP    87      13.886  30.047  20.801  1.00  7.59           O
ATOM    677  OD2 ASP    87      14.633  31.449  20.131  1.00  7.59           O
ATOM    678  N   ILE    88      15.146  26.937  21.645  1.00  7.59           N
ATOM    679  CA  ILE    88      15.763  26.243  22.783  1.00  7.59           C
ATOM    680  C   ILE    88      17.079  26.882  23.241  1.00  7.59           C
ATOM    681  O   ILE    88      18.007  26.191  23.684  1.00  7.59           O
ATOM    682  CB  ILE    88      16.039  24.813  22.353  1.00  7.59           C
ATOM    683  CG1 ILE    88      14.771  24.075  21.916  1.00  7.59           C
ATOM    684  CG2 ILE    88      16.656  23.964  23.465  1.00  7.59           C
ATOM    685  CD1 ILE    88      15.041  22.643  21.448  1.00  7.59           C
ATOM    686  N   THR    89      17.129  28.190  23.153  1.00  7.59           N
ATOM    687  CA  THR    89      18.329  28.965  23.513  1.00  7.59           C
ATOM    688  C   THR    89      18.698  28.830  25.011  1.00  7.59           C
ATOM    689  O   THR    89      19.864  28.589  25.360  1.00  7.59           O
ATOM    690  CB  THR    89      18.091  30.450  23.224  1.00  7.59           C
ATOM    691  OG1 THR    89      17.004  30.926  24.004  1.00  7.59           O
ATOM    692  CG2 THR    89      17.759  30.733  21.758  1.00  7.59           C
ATOM    693  N   ALA    90      17.687  28.990  25.859  1.00  7.59           N
ATOM    694  CA  ALA    90      17.836  29.019  27.345  1.00  7.59           C
ATOM    695  C   ALA    90      18.332  27.693  27.965  1.00  7.59           C
ATOM    696  O   ALA    90      18.988  27.691  29.025  1.00  7.59           O
ATOM    697  CB  ALA    90      16.490  29.331  28.002  1.00  7.59           C
ATOM    698  N   SER    91      18.006  26.590  27.314  1.00  7.59           N
ATOM    699  CA  SER    91      18.385  25.240  27.794  1.00  7.59           C
ATOM    700  C   SER    91      19.824  24.923  27.397  1.00  7.59           C
ATOM    701  O   SER    91      20.575  24.279  28.147  1.00  7.59           O
ATOM    702  CB  SER    91      17.451  24.184  27.211  1.00  7.59           C
ATOM    703  OG  SER    91      17.504  24.220  25.798  1.00  7.59           O
ATOM    704  N   VAL    92      20.186  25.360  26.207  1.00  7.59           N
ATOM    705  CA  VAL    92      21.565  25.230  25.758  1.00  7.59           C
ATOM    706  C   VAL    92      22.381  26.041  26.747  1.00  7.59           C
ATOM    707  O   VAL    92      23.473  25.626  27.164  1.00  7.59           O
ATOM    708  CB  VAL    92      21.723  25.788  24.341  1.00  7.59           C
ATOM    709  CG1 VAL    92      23.162  25.714  23.826  1.00  7.59           C
ATOM    710  CG2 VAL    92      20.874  25.050  23.305  1.00  7.59           C
ATOM    711  N   ASN    93      21.755  27.162  27.072  1.00  7.59           N
ATOM    712  CA  ASN    93      22.261  28.144  28.030  1.00  7.59           C
ATOM    713  C   ASN    93      22.422  27.479  29.394  1.00  7.59           C
ATOM    714  O   ASN    93      23.511  27.494  29.986  1.00  7.59           O
ATOM    715  CB  ASN    93      21.266  29.305  28.150  1.00  7.59           C
ATOM    716  CG  ASN    93      21.024  30.034  26.825  1.00  7.59           C
ATOM    717  OD1 ASN    93      21.960  30.586  26.249  1.00  7.59           O
ATOM    718  ND2 ASN    93      19.814  30.071  26.298  1.00  7.59           N
ATOM    719  N   CYS    94      21.313  26.919  29.857  1.00  7.59           N
ATOM    720  CA  CYS    94      21.274  26.199  31.121  1.00  7.59           C
ATOM    721  C   CYS    94      22.035  24.883  31.034  1.00  7.59           C
ATOM    722  O   CYS    94      22.797  24.511  31.925  1.00  7.59           O
ATOM    723  CB  CYS    94      19.827  25.945  31.546  1.00  7.59           C
ATOM    724  SG  CYS    94      18.888  27.442  31.937  1.00  7.59           S
ATOM    725  N   ALA    95      21.805  24.229  29.901  1.00  7.59           N
ATOM    726  CA  ALA    95      22.459  22.954  29.581  1.00  7.59           C
ATOM    727  C   ALA    95      23.967  23.102  29.773  1.00  7.59           C
ATOM    728  O   ALA    95      24.673  22.125  30.060  1.00  7.59           O
ATOM    729  CB  ALA    95      22.167  22.570  28.127  1.00  7.59           C
ATOM    730  N   LYS    96      24.389  24.341  29.608  1.00  7.59           N
ATOM    731  CA  LYS    96      25.793  24.750  29.741  1.00  7.59           C
ATOM    732  C   LYS    96      26.269  24.579  31.182  1.00  7.59           C
ATOM    733  O   LYS    96      27.017  23.640  31.496  1.00  7.59           O
ATOM    734  CB  LYS    96      25.933  26.237  29.397  1.00  7.59           C
ATOM    735  CG  LYS    96      26.704  26.488  28.103  1.00  7.59           C
ATOM    736  CD  LYS    96      26.330  25.508  26.992  1.00  7.59           C
ATOM    737  CE  LYS    96      26.184  26.178  25.627  1.00  7.59           C
ATOM    738  NZ  LYS    96      27.320  27.050  25.293  1.00  7.59           N
ATOM    739  N   LYS    97      25.795  25.518  31.973  1.00  7.59           N
ATOM    740  CA  LYS    97      26.114  25.647  33.400  1.00  7.59           C
ATOM    741  C   LYS    97      26.151  24.289  34.101  1.00  7.59           C
ATOM    742  O   LYS    97      27.036  24.018  34.922  1.00  7.59           O
ATOM    743  CB  LYS    97      25.072  26.533  34.083  1.00  7.59           C
ATOM    744  CG  LYS    97      25.225  28.006  33.698  1.00  7.59           C
ATOM    745  CD  LYS    97      24.521  28.962  34.659  1.00  7.59           C
ATOM    746  CE  LYS    97      24.633  30.423  34.220  1.00  7.59           C
ATOM    747  NZ  LYS    97      23.909  31.347  35.103  1.00  7.59           N
ATOM    748  N   ILE    98      25.195  23.443  33.782  1.00  7.59           N
ATOM    749  CA  ILE    98      25.129  22.119  34.409  1.00  7.59           C
ATOM    750  C   ILE    98      26.193  21.197  33.832  1.00  7.59           C
ATOM    751  O   ILE    98      26.779  20.369  34.532  1.00  7.59           O
ATOM    752  CB  ILE    98      23.762  21.481  34.216  1.00  7.59           C
ATOM    753  CG1 ILE    98      22.651  22.266  34.908  1.00  7.59           C
ATOM    754  CG2 ILE    98      23.692  20.059  34.786  1.00  7.59           C
ATOM    755  CD1 ILE    98      21.303  21.549  34.873  1.00  7.59           C
ATOM    756  N   VAL    99      26.444  21.333  32.556  1.00  7.59           N
ATOM    757  CA  VAL    99      27.459  20.499  31.922  1.00  7.59           C
ATOM    758  C   VAL    99      28.853  20.901  32.422  1.00  7.59           C
ATOM    759  O   VAL    99      29.867  20.318  32.026  1.00  7.59           O
ATOM    760  CB  VAL    99      27.430  20.665  30.400  1.00  7.59           C
ATOM    761  CG1 VAL    99      28.651  20.046  29.713  1.00  7.59           C
ATOM    762  CG2 VAL    99      26.213  20.006  29.744  1.00  7.59           C
ATOM    763  N   SER   100      28.902  21.890  33.313  1.00  7.59           N
ATOM    764  CA  SER   100      30.203  22.419  33.781  1.00  7.59           C
ATOM    765  C   SER   100      30.307  22.594  35.301  1.00  7.59           C
ATOM    766  O   SER   100      31.265  23.200  35.814  1.00  7.59           O
ATOM    767  CB  SER   100      30.449  23.798  33.173  1.00  7.59           C
ATOM    768  OG  SER   100      29.333  24.182  32.382  1.00  7.59           O
ATOM    769  N   ASP   101      29.353  22.070  36.023  1.00  7.59           N
ATOM    770  CA  ASP   101      29.374  22.198  37.477  1.00  7.59           C
ATOM    771  C   ASP   101      30.181  21.030  38.083  1.00  7.59           C
ATOM    772  O   ASP   101      31.188  21.209  38.763  1.00  7.59           O
ATOM    773  CB  ASP   101      27.951  22.337  37.981  1.00  7.59           C
ATOM    774  CG  ASP   101      27.206  23.447  37.224  1.00  7.59           C
ATOM    775  OD1 ASP   101      27.703  24.640  37.153  1.00  7.59           O
ATOM    776  OD2 ASP   101      26.089  23.185  36.639  1.00  7.59           O
ATOM    777  N   GLY   102      29.822  19.769  37.874  1.00  7.59           N
ATOM    778  CA  GLY   102      30.666  18.725  38.503  1.00  7.59           C
ATOM    779  C   GLY   102      30.265  17.297  38.167  1.00  7.59           C
ATOM    780  O   GLY   102      31.118  16.393  38.096  1.00  7.59           O
ATOM    781  N   ASN   103      28.984  17.096  37.990  1.00  7.59           N
ATOM    782  CA  ASN   103      28.483  15.764  37.680  1.00  7.59           C
ATOM    783  C   ASN   103      28.528  15.561  36.147  1.00  7.59           C
ATOM    784  O   ASN   103      29.115  14.621  35.637  1.00  7.59           O
ATOM    785  CB  ASN   103      27.148  15.542  38.384  1.00  7.59           C
ATOM    786  CG  ASN   103      27.383  14.991  39.807  1.00  7.59           C
ATOM    787  OD1 ASN   103      28.121  14.013  39.976  1.00  7.59           O
ATOM    788  ND2 ASN   103      26.818  15.565  40.852  1.00  7.59           N
ATOM    789  N   GLY   104      27.938  16.416  35.331  1.00  7.59           N
ATOM    790  CA  GLY   104      28.101  16.230  33.854  1.00  7.59           C
ATOM    791  C   GLY   104      26.916  15.493  33.207  1.00  7.59           C
ATOM    792  O   GLY   104      25.896  15.228  33.854  1.00  7.59           O
ATOM    793  N   MET   105      27.082  15.193  31.916  1.00  7.59           N
ATOM    794  CA  MET   105      26.026  14.547  31.113  1.00  7.59           C
ATOM    795  C   MET   105      25.268  13.553  32.003  1.00  7.59           C
ATOM    796  O   MET   105      24.143  13.133  31.670  1.00  7.59           O
ATOM    797  CB  MET   105      26.630  13.867  29.879  1.00  7.59           C
ATOM    798  CG  MET   105      27.428  14.833  28.985  1.00  7.59           C
ATOM    799  SD  MET   105      26.545  16.327  28.572  1.00  7.59           S
ATOM    800  CE  MET   105      25.245  15.972  27.407  1.00  7.59           C
ATOM    801  N   ASN   106      25.945  13.230  33.110  1.00  7.59           N
ATOM    802  CA  ASN   106      25.411  12.359  34.181  1.00  7.59           C
ATOM    803  C   ASN   106      25.234  13.207  35.432  1.00  7.59           C
ATOM    804  O   ASN   106      26.167  13.334  36.257  1.00  7.59           O
ATOM    805  CB  ASN   106      26.287  11.135  34.413  1.00  7.59           C
ATOM    806  CG  ASN   106      27.664  11.439  34.978  1.00  7.59           C
ATOM    807  OD1 ASN   106      28.002  12.598  35.185  1.00  7.59           O
ATOM    808  ND2 ASN   106      28.491  10.442  35.233  1.00  7.59           N
ATOM    809  N   ALA   107      24.042  13.669  35.367  1.00  7.59           N
ATOM    810  CA  ALA   107      23.359  14.582  36.231  1.00  7.59           C
ATOM    811  C   ALA   107      22.222  15.033  35.329  1.00  7.59           C
ATOM    812  O   ALA   107      21.997  16.246  35.172  1.00  7.59           O
ATOM    813  CB  ALA   107      24.306  15.702  36.658  1.00  7.59           C
ATOM    814  N   TRP   108      21.646  13.956  34.771  1.00  7.59           N
ATOM    815  CA  TRP   108      20.521  13.942  33.804  1.00  7.59           C
ATOM    816  C   TRP   108      19.676  12.634  33.982  1.00  7.59           C
ATOM    817  O   TRP   108      18.683  12.415  33.268  1.00  7.59           O
ATOM    818  CB  TRP   108      21.078  13.961  32.361  1.00  7.59           C
ATOM    819  CG  TRP   108      20.648  15.190  31.545  1.00  7.59           C
ATOM    820  CD1 TRP   108      19.507  15.348  30.858  1.00  7.59           C
ATOM    821  CD2 TRP   108      21.414  16.377  31.384  1.00  7.59           C
ATOM    822  NE1 TRP   108      19.534  16.660  30.285  1.00  7.59           N
ATOM    823  CE2 TRP   108      20.655  17.251  30.618  1.00  7.59           C
ATOM    824  CE3 TRP   108      22.669  16.784  31.843  1.00  7.59           C
ATOM    825  CZ2 TRP   108      21.073  18.549  30.300  1.00  7.59           C
ATOM    826  CZ3 TRP   108      23.089  18.088  31.507  1.00  7.59           C
ATOM    827  CH2 TRP   108      22.325  18.929  30.774  1.00  7.59           C
ATOM    828  N   VAL   109      20.116  11.813  34.953  1.00  7.59           N
ATOM    829  CA  VAL   109      19.535  10.467  35.317  1.00  7.59           C
ATOM    830  C   VAL   109      19.268   9.592  34.084  1.00  7.59           C
ATOM    831  O   VAL   109      19.679   8.421  34.029  1.00  7.59           O
ATOM    832  CB  VAL   109      18.197  10.552  36.077  1.00  7.59           C
ATOM    833  CG1 VAL   109      17.658   9.167  36.490  1.00  7.59           C
ATOM    834  CG2 VAL   109      18.285  11.345  37.380  1.00  7.59           C
ATOM    835  N   ALA   110      18.580  10.184  33.128  1.00  7.59           N
ATOM    836  CA  ALA   110      18.209   9.503  31.877  1.00  7.59           C
ATOM    837  C   ALA   110      19.433   9.311  30.978  1.00  7.59           C
ATOM    838  O   ALA   110      19.602   8.268  30.331  1.00  7.59           O
ATOM    839  CB  ALA   110      17.171  10.327  31.116  1.00  7.59           C
ATOM    840  N   TRP   111      20.279  10.324  30.937  1.00  7.59           N
ATOM    841  CA  TRP   111      21.497  10.252  30.122  1.00  7.59           C
ATOM    842  C   TRP   111      22.408   9.171  30.677  1.00  7.59           C
ATOM    843  O   TRP   111      22.914   8.316  29.938  1.00  7.59           O
ATOM    844  CB  TRP   111      22.267  11.568  30.131  1.00  7.59           C
ATOM    845  CG  TRP   111      23.539  11.489  29.280  1.00  7.59           C
ATOM    846  CD1 TRP   111      23.654  11.760  27.972  1.00  7.59           C
ATOM    847  CD2 TRP   111      24.819  11.098  29.756  1.00  7.59           C
ATOM    848  NE1 TRP   111      25.023  11.543  27.614  1.00  7.59           N
ATOM    849  CE2 TRP   111      25.689  11.156  28.675  1.00  7.59           C
ATOM    850  CE3 TRP   111      25.308  10.707  31.007  1.00  7.59           C
ATOM    851  CZ2 TRP   111      27.050  10.844  28.772  1.00  7.59           C
ATOM    852  CZ3 TRP   111      26.680  10.392  31.095  1.00  7.59           C
ATOM    853  CH2 TRP   111      27.509  10.459  30.029  1.00  7.59           C
ATOM    854  N   ARG   112      22.582   9.243  31.975  1.00  7.59           N
ATOM    855  CA  ARG   112      23.418   8.297  32.691  1.00  7.59           C
ATOM    856  C   ARG   112      22.863   6.889  32.558  1.00  7.59           C
ATOM    857  O   ARG   112      23.608   5.912  32.446  1.00  7.59           O
ATOM    858  CB  ARG   112      23.462   8.617  34.190  1.00  7.59           C
ATOM    859  CG  ARG   112      24.132   7.506  35.011  1.00  7.59           C
ATOM    860  CD  ARG   112      24.246   7.839  36.501  1.00  7.59           C
ATOM    861  NE  ARG   112      23.883   9.228  36.803  1.00  7.59           N
ATOM    862  CZ  ARG   112      23.829   9.739  38.039  1.00  7.59           C
ATOM    863  NH1 ARG   112      24.114   8.987  39.109  1.00  7.59           N
ATOM    864  NH2 ARG   112      23.497  11.009  38.309  1.00  7.59           N
ATOM    865  N   ASN   113      21.558   6.794  32.539  1.00  7.59           N
ATOM    866  CA  ASN   113      20.928   5.483  32.592  1.00  7.59           C
ATOM    867  C   ASN   113      20.767   4.767  31.258  1.00  7.59           C
ATOM    868  O   ASN   113      20.689   5.422  30.193  1.00  7.59           O
ATOM    869  CB  ASN   113      19.586   5.564  33.263  1.00  7.59           C
ATOM    870  CG  ASN   113      19.728   5.142  34.714  1.00  7.59           C
ATOM    871  OD1 ASN   113      20.609   4.338  35.028  1.00  7.59           O
ATOM    872  ND2 ASN   113      18.930   5.643  35.625  1.00  7.59           N
ATOM    873  N   ARG   114      20.259   5.545  30.112  1.00  7.59           N
ATOM    874  CA  ARG   114      19.889   5.135  28.754  1.00  7.59           C
ATOM    875  C   ARG   114      20.809   5.506  27.663  1.00  7.59           C
ATOM    876  O   ARG   114      20.647   4.978  26.562  1.00  7.59           O
ATOM    877  CB  ARG   114      18.524   5.820  28.470  1.00  7.59           C
ATOM    878  CG  ARG   114      17.622   5.591  29.700  1.00  7.59           C
ATOM    879  CD  ARG   114      16.120   5.571  29.514  1.00  7.59           C
ATOM    880  NE  ARG   114      15.538   4.773  28.422  1.00  7.59           N
ATOM    881  CZ  ARG   114      14.272   4.987  28.087  1.00  7.59           C
ATOM    882  NH1 ARG   114      13.588   5.934  28.760  1.00  7.59           N
ATOM    883  NH2 ARG   114      13.676   4.312  27.124  1.00  7.59           N
ATOM    884  N   CYS   115      21.731   6.434  27.948  1.00  7.59           N
ATOM    885  CA  CYS   115      22.611   6.927  26.912  1.00  7.59           C
ATOM    886  C   CYS   115      24.038   6.546  27.121  1.00  7.59           C
ATOM    887  O   CYS   115      24.761   6.124  26.167  1.00  7.59           O
ATOM    888  CB  CYS   115      22.512   8.456  26.779  1.00  7.59           C
ATOM    889  SG  CYS   115      20.831   8.880  26.337  1.00  7.59           S
ATOM    890  N   LYS   116      24.448   6.818  28.370  1.00  7.59           N
ATOM    891  CA  LYS   116      25.788   6.594  28.786  1.00  7.59           C
ATOM    892  C   LYS   116      26.255   5.204  28.388  1.00  7.59           C
ATOM    893  O   LYS   116      25.561   4.220  28.674  1.00  7.59           O
ATOM    894  CB  LYS   116      25.945   6.826  30.286  1.00  7.59           C
ATOM    895  CG  LYS   116      27.391   6.777  30.761  1.00  7.59           C
ATOM    896  CD  LYS   116      27.435   7.045  32.288  1.00  7.59           C
ATOM    897  CE  LYS   116      28.837   7.224  32.895  1.00  7.59           C
ATOM    898  NZ  LYS   116      28.779   7.665  34.314  1.00  7.59           N
ATOM    899  N   GLY   117      27.430   5.166  27.679  1.00  7.59           N
ATOM    900  CA  GLY   117      28.050   3.899  27.271  1.00  7.59           C
ATOM    901  C   GLY   117      27.341   3.164  26.137  1.00  7.59           C
ATOM    902  O   GLY   117      27.555   2.000  25.926  1.00  7.59           O
ATOM    903  N   THR   118      26.477   3.832  25.410  1.00  7.59           N
ATOM    904  CA  THR   118      25.783   3.220  24.282  1.00  7.59           C
ATOM    905  C   THR   118      26.362   3.862  23.017  1.00  7.59           C
ATOM    906  O   THR   118      27.127   4.818  23.143  1.00  7.59           O
ATOM    907  CB  THR   118      24.263   3.406  24.402  1.00  7.59           C
ATOM    908  OG1 THR   118      23.938   4.736  24.070  1.00  7.59           O
ATOM    909  CG2 THR   118      23.757   3.044  25.817  1.00  7.59           C
ATOM    910  N   ASP   119      26.048   3.362  21.818  1.00  7.59           N
ATOM    911  CA  ASP   119      26.569   3.988  20.588  1.00  7.59           C
ATOM    912  C   ASP   119      25.702   5.204  20.282  1.00  7.59           C
ATOM    913  O   ASP   119      24.770   5.173  19.449  1.00  7.59           O
ATOM    914  CB  ASP   119      26.546   3.030  19.395  1.00  7.59           C
ATOM    915  CG  ASP   119      26.801   3.738  18.095  1.00  7.59           C
ATOM    916  OD1 ASP   119      27.402   4.796  18.022  1.00  7.59           O
ATOM    917  OD2 ASP   119      26.273   3.118  17.069  1.00  7.59           O
ATOM    918  N   VAL   120      26.011   6.285  21.001  1.00  7.59           N
ATOM    919  CA  VAL   120      25.220   7.527  20.892  1.00  7.59           C
ATOM    920  C   VAL   120      25.316   8.183  19.531  1.00  7.59           C
ATOM    921  O   VAL   120      24.491   9.072  19.160  1.00  7.59           O
ATOM    922  CB  VAL   120      25.478   8.534  22.044  1.00  7.59           C
ATOM    923  CG1 VAL   120      25.154   7.923  23.430  1.00  7.59           C
ATOM    924  CG2 VAL   120      26.928   8.957  21.975  1.00  7.59           C
ATOM    925  N   GLN   121      26.334   7.762  18.773  1.00  7.59           N
ATOM    926  CA  GLN   121      26.510   8.321  17.437  1.00  7.59           C
ATOM    927  C   GLN   121      25.321   7.977  16.553  1.00  7.59           C
ATOM    928  O   GLN   121      25.052   8.653  15.553  1.00  7.59           O
ATOM    929  CB  GLN   121      27.719   7.642  16.827  1.00  7.59           C
ATOM    930  CG  GLN   121      28.877   8.586  16.806  1.00  7.59           C
ATOM    931  CD  GLN   121      29.539   8.430  15.489  1.00  7.59           C
ATOM    932  OE1 GLN   121      29.167   9.113  14.526  1.00  7.59           O
ATOM    933  NE2 GLN   121      30.458   7.464  15.430  1.00  7.59           N
ATOM    934  N   ALA   122      24.622   6.905  16.935  1.00  7.59           N
ATOM    935  CA  ALA   122      23.427   6.482  16.199  1.00  7.59           C
ATOM    936  C   ALA   122      22.384   7.595  16.097  1.00  7.59           C
ATOM    937  O   ALA   122      21.607   7.709  15.136  1.00  7.59           O
ATOM    938  CB  ALA   122      22.810   5.285  16.892  1.00  7.59           C
ATOM    939  N   TRP   123      22.359   8.432  17.127  1.00  7.59           N
ATOM    940  CA  TRP   123      21.393   9.528  17.218  1.00  7.59           C
ATOM    941  C   TRP   123      21.553  10.621  16.174  1.00  7.59           C
ATOM    942  O   TRP   123      20.605  11.371  15.868  1.00  7.59           O
ATOM    943  CB  TRP   123      21.268  10.072  18.669  1.00  7.59           C
ATOM    944  CG  TRP   123      20.703   9.027  19.570  1.00  7.59           C
ATOM    945  CD1 TRP   123      21.373   8.205  20.411  1.00  7.59           C
ATOM    946  CD2 TRP   123      19.315   8.706  19.690  1.00  7.59           C
ATOM    947  NE1 TRP   123      20.478   7.367  21.043  1.00  7.59           N
ATOM    948  CE2 TRP   123      19.223   7.644  20.594  1.00  7.59           C
ATOM    949  CE3 TRP   123      18.185   9.218  19.077  1.00  7.59           C
ATOM    950  CZ2 TRP   123      17.979   7.100  20.931  1.00  7.59           C
ATOM    951  CZ3 TRP   123      16.968   8.661  19.367  1.00  7.59           C
ATOM    952  CH2 TRP   123      16.866   7.616  20.286  1.00  7.59           C
ATOM    953  N   ILE   124      22.729  10.746  15.614  1.00  7.59           N
ATOM    954  CA  ILE   124      22.875  11.773  14.587  1.00  7.59           C
ATOM    955  C   ILE   124      23.074  11.184  13.177  1.00  7.59           C
ATOM    956  O   ILE   124      23.303  11.891  12.208  1.00  7.59           O
ATOM    957  CB  ILE   124      23.953  12.766  14.964  1.00  7.59           C
ATOM    958  CG1 ILE   124      25.198  11.964  15.324  1.00  7.59           C
ATOM    959  CG2 ILE   124      23.483  13.522  16.222  1.00  7.59           C
ATOM    960  CD1 ILE   124      26.509  12.617  14.845  1.00  7.59           C
ATOM    961  N   ARG   125      23.017   9.859  13.097  1.00  7.59           N
ATOM    962  CA  ARG   125      23.154   9.162  11.829  1.00  7.59           C
ATOM    963  C   ARG   125      22.072   9.595  10.864  1.00  7.59           C
ATOM    964  O   ARG   125      20.886   9.734  11.227  1.00  7.59           O
ATOM    965  CB  ARG   125      23.215   7.658  11.995  1.00  7.59           C
ATOM    966  CG  ARG   125      23.182   6.839  10.712  1.00  7.59           C
ATOM    967  CD  ARG   125      23.563   5.374  10.966  1.00  7.59           C
ATOM    968  NE  ARG   125      22.735   4.867  12.058  1.00  7.59           N
ATOM    969  CZ  ARG   125      21.435   4.602  11.902  1.00  7.59           C
ATOM    970  NH1 ARG   125      20.840   4.736  10.715  1.00  7.59           N
ATOM    971  NH2 ARG   125      20.716   4.182  12.948  1.00  7.59           N
ATOM    972  N   GLY   126      22.558   9.888   9.625  1.00  7.59           N
ATOM    973  CA  GLY   126      21.769  10.304   8.464  1.00  7.59           C
ATOM    974  C   GLY   126      21.435  11.750   8.447  1.00  7.59           C
ATOM    975  O   GLY   126      20.730  12.208   7.555  1.00  7.59           O
ATOM    976  N   CYS   127      21.911  12.484   9.459  1.00  7.59           N
ATOM    977  CA  CYS   127      21.537  13.870   9.473  1.00  7.59           C
ATOM    978  C   CYS   127      22.472  14.743   8.656  1.00  7.59           C
ATOM    979  O   CYS   127      23.713  14.559   8.603  1.00  7.59           O
ATOM    980  CB  CYS   127      21.384  14.487  10.907  1.00  7.59           C
ATOM    981  SG  CYS   127      20.334  13.515  11.983  1.00  7.59           S
ATOM    982  N   ARG   128      21.879  15.755   8.055  1.00  7.59           N
ATOM    983  CA  ARG   128      22.717  16.669   7.327  1.00  7.59           C
ATOM    984  C   ARG   128      23.279  17.684   8.284  1.00  7.59           C
ATOM    985  O   ARG   128      22.578  18.621   8.661  1.00  7.59           O
ATOM    986  CB  ARG   128      21.956  17.415   6.245  1.00  7.59           C
ATOM    987  CG  ARG   128      22.900  18.275   5.419  1.00  7.59           C
ATOM    988  CD  ARG   128      22.275  18.562   4.063  1.00  7.59           C
ATOM    989  NE  ARG   128      20.799  18.559   4.127  1.00  7.59           N
ATOM    990  CZ  ARG   128      19.912  18.143   3.182  1.00  7.59           C
ATOM    991  NH1 ARG   128      20.267  17.616   2.000  1.00  7.59           N
ATOM    992  NH2 ARG   128      18.606  18.264   3.443  1.00  7.59           N
ATOM    993  N   LEU   129      24.503  17.501   8.709  1.00  7.59           N
ATOM    994  CA  LEU   129      25.067  18.491   9.631  1.00  7.59           C
ATOM    995  C   LEU   129      26.363  19.028   9.072  1.00  7.59           C
ATOM    996  O   LEU   129      26.851  18.378   8.098  1.00  7.59           O
ATOM    997  CB  LEU   129      25.334  18.005  11.070  1.00  7.59           C
ATOM    998  CG  LEU   129      24.151  17.331  11.805  1.00  7.59           C
ATOM    999  CD1 LEU   129      24.715  16.261  12.759  1.00  7.59           C
ATOM   1000  CD2 LEU   129      23.399  18.364  12.610  1.00  7.59           C
TER
END
"""

def write_ccp4_map(cg, file_name, mc=None, map_data=None):
  assert [mc, map_data].count(None)==1
  if(map_data is None):
    map_data = get_map(mc=mc, cg=cg)
  from iotbx import mrcfile
  mrcfile.write_ccp4_map(
      file_name=file_name,
      unit_cell=cg.unit_cell(),
      space_group=cg.space_group(),
      #gridding_first=(0,0,0),# This causes a bug (map gets shifted)
      #gridding_last=n_real,  # This causes a bug (map gets shifted)
      map_data=map_data,
      labels=flex.std_string([""]))

def common_inputs(k_sols, for_test):
  pdb_inp = iotbx.pdb.input(source_info=None, lines = pdb_str)
  xrs = pdb_inp.xray_structure_simple()
  sgt = xrs.space_group().type()
  fc  = xrs.structure_factors(d_min=4).f_calc()
  #
  crystal_gridding = maptbx.crystal_gridding(
    unit_cell        = xrs.unit_cell(),
    space_group_info = xrs.space_group_info(),
    symmetry_flags   = maptbx.use_space_group_symmetry,
    step             = 0.5)
  mar = mosaic.mask_and_regions(
    xray_structure   = xrs,
    crystal_gridding = crystal_gridding,
    r_sol            = 1.1,
    r_shrink         = 0.9,
    volume_cutoff    = 6,
    wrapping         = True,
    force_symmetry   = True,
    log              = None)
  mm = mosaic.f_masks(
    mask_and_regions = mar,
    crystal_gridding = crystal_gridding,
    f_obs          = abs(fc),
    xray_structure = xrs)
  # Make Fobs
  f_bulk_data = flex.complex_double(fc.data().size())
  for f_mask, k_sol in zip(mm.FV.keys(), k_sols):
    f_bulk_data += f_mask.data() * k_sol
  f_obs = fc.customized_copy(data = flex.abs(fc.data()+f_bulk_data))
  i_obs = f_obs.customized_copy(data = f_obs.data()*f_obs.data())
  return group_args(mm=mm, f_obs=f_obs, i_obs=i_obs, fc=fc)

def run2():
  def rfactor(x,y):
    n = flex.sum(flex.abs(x-y))
    d = flex.sum(flex.abs(x+y))
    if(d!=0): return n/d
    else:     return None
  for it in range(1):
    k_sols = flex.random_double(6)
    answer = flex.double([1,])
    answer.extend(k_sols)
    inp = common_inputs(k_sols=k_sols, for_test=False)
    x = flex.double([1,])
    x.extend(flex.random_double(6))
    result1 = mosaic.algorithm_2(
      i_obs          = inp.i_obs,
      F              = [inp.fc]+list(inp.mm.FV.keys()),
      x              = x.deep_copy(),
      use_curvatures = True)
    result2 = mosaic.algorithm_2(
      i_obs          = inp.i_obs,
      F              = [inp.fc]+list(inp.mm.FV.keys()),
      x              = x.deep_copy(),
      use_curvatures = False)
    print (rfactor(answer, result1), rfactor(answer, result2))

def run():
  k_sols = [0.1, 0.2, 0.3, 0.4, 0.5, 0.6]
  inp = common_inputs(k_sols=k_sols, for_test=True)
  mm, f_obs, i_obs, fc = inp.mm, inp.f_obs, inp.i_obs, inp.fc
  # Initial k_sols for finite differences test and minimization (algorithm_2)
  x = flex.double([1,  .01,.01,.01, .01,.01,.01])
  # Finite differences test
  g_anal = mosaic.tg(i_obs = i_obs, F=[fc]+list(mm.FV.keys()), x=x, use_curvatures=False).gradients()
  e=1.e-6
  g_fd = flex.double()
  for i in [0,1,2,3,4,5,6]:
    x_ = x[:]
    x_[i] = x_[i]+e
    t1 = mosaic.tg(i_obs = i_obs, F=[fc]+list(mm.FV.keys()), x=x_, use_curvatures=False).target()
    x_ = x[:]
    x_[i] = x_[i]-e
    t2 = mosaic.tg(i_obs = i_obs, F=[fc]+list(mm.FV.keys()), x=x_, use_curvatures=False).target()
    g_fd.append( (t1-t2)/(2*e) )
  assert flex.sum(flex.abs(g_anal-g_fd))*2/flex.sum(flex.abs(g_anal+g_fd))<1.e-9
  #
  for use_cpp in [True, False]:
    r = mosaic.algorithm_4(
      f_obs             = f_obs,
      phase_source      = fc,
      F                 = [fc]+list(inp.mm.FV.keys()),
      auto_converge_eps = 1.e-9,
      use_cpp           = use_cpp)
    assert approx_equal(r, [1,]+k_sols)
  #
  r = mosaic.algorithm_3(
    i_obs = i_obs,
    fc = fc,
    f_masks = list(mm.FV.keys())
    )
  assert approx_equal(r, [1,]+k_sols)
  #
  r = mosaic.algorithm_2(
    i_obs = i_obs,
    F = [fc]+list(inp.mm.FV.keys()),
    x = flex.double(x),
    use_curvatures=True,
    use_lbfgsb=False)
  assert approx_equal(r, [1,]+k_sols)
  #
  r = mosaic.algorithm_2(
    i_obs = i_obs,
    F = [fc]+list(inp.mm.FV.keys()),
    x = flex.double(x),
    use_curvatures = False,
    use_lbfgsb=False,
    macro_cycles=100)
  assert approx_equal(r, [1,]+k_sols, 1.e-3)


if (__name__ == "__main__"):
  t0 = time.time()
  run()
  print ("Total time: %-8.4f"%(time.time()-t0))
  print ("OK")


 *******************************************************************************
