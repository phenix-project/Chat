

 *******************************************************************************
cctbx/regression/__init__.py


 *******************************************************************************


 *******************************************************************************
cctbx/regression/tst_adp_aniso_restraints.py
from __future__ import absolute_import, division, print_function
from cctbx.array_family import flex
from six.moves import cStringIO as StringIO
import cctbx.adp_restraints
from libtbx.test_utils import approx_equal
import libtbx.load_env
from six.moves import range

phe_pdb = """\
remark CRYST1   25.000   35.000   45.000  80.00 70.00 100.00 P 1           1
CRYST1    4.000    5.000    7.000  80.00 70.00 100.00 P 1           1
ATOM      1  CB  PHE A   1       7.767   5.853   7.671  1.00 15.00           C
ATOM      2  CG  PHE A   1       6.935   5.032   8.622  1.00 44.21           C
ANISOU    2  CG  PHE A   1     4894   5943   5958    725   -324    -10       C
ATOM      3  CD1 PHE A   1       5.918   4.176   8.140  1.00 17.66           C
ANISOU    3  CD1 PHE A   1     1321   2083   3304   1237   1214   2356       C
ATOM      4  CD2 PHE A   1       7.161   5.107  10.012  1.00 36.94           C
ANISOU    4  CD2 PHE A   1     4099   5961   3974    855     31     95       C
ATOM      5  CE1 PHE A   1       5.126   3.395   9.038  1.00 17.96           C
ATOM      6  CE2 PHE A   1       6.382   4.336  10.930  1.00 98.17           C
ATOM      7  CZ  PHE A   1       5.360   3.476  10.439  1.00 78.27           C
ATOM      8  C   PHE A   1       7.956   7.811   6.133  1.00 17.21           C
ANISOU    8  C   PHE A   1      816   2415   3307   1079   1332   2287       C
ATOM      9  O   PHE A   1       8.506   7.237   5.169  1.00 70.55           O
ANISOU    9  O   PHE A   1     8784   9152   8868     -8    122   -190       O
ATOM     10  OXT PHE A   1       8.143   9.010   6.428  1.00 27.61           O
ATOM     13  N   PHE A   1       5.875   6.461   6.183  1.00 17.13           N
ATOM     15  CA  PHE A   1       7.000   7.000   7.000  1.00 87.18           C
END
"""

def fd(xray_structure, restraints_manager, eps=1.e-2):
    uc = xray_structure.unit_cell()
    adp_ro = cctbx.adp_restraints.adp_aniso_restraints(
                                       xray_structure     = xray_structure,
                                       restraints_manager = restraints_manager,
                                       use_hd = False)
    g_aniso = adp_ro.gradients_aniso_cart
    g_iso = adp_ro.gradients_iso
    for i_seq, scatterer in enumerate(xray_structure.scatterers()):
        fl = scatterer.flags
        #print "scatterer :", i_seq, fl.use_u_iso(), fl.grad_u_iso(), \
        #                     fl.use_u_aniso(), fl.grad_u_aniso()
        if(fl.use_u_aniso()):
           for i_ind in range(6):
               xrs1 = xray_structure.deep_copy_scatterers()
               xrs2 = xray_structure.deep_copy_scatterers()
               sc1  = xrs1.scatterers()
               sc2  = xrs2.scatterers()
               us1 = sc1.extract_u_cart(uc)
               us2 = sc1.extract_u_cart(uc)
               m1 = flex.double(us1[i_seq])
               m2 = flex.double(us2[i_seq])
               m1[i_ind] = m1[i_ind] - eps
               m2[i_ind] = m2[i_ind] + eps
               us1[i_seq] = list(m1)
               us2[i_seq] = list(m2)
               sc1.set_u_cart(uc, us1)
               sc2.set_u_cart(uc, us2)
               adp_ro1 = cctbx.adp_restraints.adp_aniso_restraints(
                                       xray_structure     = xrs1,
                                       restraints_manager = restraints_manager,
                                       use_hd = False)
               adp_ro2 = cctbx.adp_restraints.adp_aniso_restraints(
                                       xray_structure     = xrs2,
                                       restraints_manager = restraints_manager,
                                       use_hd = False)
               g1 = (adp_ro2.target - adp_ro1.target)/(2*eps)
               g2 = g_aniso[i_seq][i_ind]
               #print "   fin.diff.= %10.5f anal.= %10.5f diff.= %10.5f"%(g1, g2, g1-g2)
               assert approx_equal(g1,g2,1.e-4)
        if(fl.use_u_iso()):
           sel = xray_structure.use_u_iso()
           xrs1 = xray_structure.deep_copy_scatterers()
           xrs2 = xray_structure.deep_copy_scatterers()
           sc1  = xrs1.scatterers()
           sc2  = xrs2.scatterers()
           us1 = sc1.extract_u_iso()
           us2 = sc1.extract_u_iso()
           us1[i_seq] = us1[i_seq] - eps
           us2[i_seq] = us2[i_seq] + eps
           sc1.set_u_iso(us1, sel, uc)
           sc2.set_u_iso(us2, sel, uc)
           adp_ro1 = cctbx.adp_restraints.adp_aniso_restraints(
                                      xray_structure     = xrs1,
                                      restraints_manager = restraints_manager,
                                      use_hd = False)
           adp_ro2 = cctbx.adp_restraints.adp_aniso_restraints(
                                      xray_structure     = xrs2,
                                      restraints_manager = restraints_manager,
                                      use_hd = False)
           g1 = (adp_ro2.target - adp_ro1.target)/(2*eps)
           g2 = g_iso[i_seq]
           #print "   fin.diff.= %10.5f anal.= %10.5f diff.= %10.5f"%(g1, g2, g1-g2)
           assert approx_equal(g1,g2,1.e-4)

def exercise():
  if (not libtbx.env.has_module("mmtbx")):
    print("Skipping exercise(): mmtbx module not available")
    return
  if (libtbx.env.find_in_repositories(relative_path="chem_data") is None):
    print("Skipping exercise(): chem_data directory not available")
    return
  from mmtbx.monomer_library import pdb_interpretation
  file_name = "phe_tst_adp_aniso_restraints.pdb"
  with open(file_name, "w") as f:
    f.write(phe_pdb)
  out = StringIO()
  processed_pdb_file = pdb_interpretation.run(
                                        args                     = [file_name],
                                        strict_conflict_handling = False,
                                        log                      = out)
  geo = processed_pdb_file.geometry_restraints_manager()
  xray_structure = processed_pdb_file.xray_structure()
  xray_structure.scatterers().flags_set_grads(state=False)
  xray_structure.scatterers().flags_set_grad_u_iso(
    iselection=xray_structure.use_u_iso().iselection())
  xray_structure.scatterers().flags_set_grad_u_aniso(
    iselection=xray_structure.use_u_aniso().iselection())
  adp_rm = cctbx.adp_restraints.adp_aniso_restraints(
                                           xray_structure     = xray_structure,
                                           restraints_manager = geo,
                                           use_hd = False)
  assert approx_equal(flex.mean(adp_rm.gradients_iso), 0.713756592583)
  assert approx_equal(flex.mean(adp_rm.gradients_aniso_cart.as_double()), -0.118959432097)
  assert approx_equal(adp_rm.target, 8.97112989232)
  fd(xray_structure = xray_structure, restraints_manager = geo, eps=1.e-4)

def run(args):
  assert len(args) == 0
  exercise()
  print("OK")

if (__name__ == "__main__"):
  import sys
  run(args=sys.argv[1:])


 *******************************************************************************


 *******************************************************************************
cctbx/regression/tst_adp_constraints.py
from __future__ import absolute_import, division, print_function
from cctbx import miller
from cctbx import adptbx
from cctbx.development import debug_utils
from cctbx.array_family import flex
from scitbx import matrix
from libtbx.test_utils import approx_equal
import random
import math
from six.moves import cStringIO as StringIO
import sys
from six.moves import range

random.seed(0)
flex.set_random_seed(0)

def exercise_constraint_matrix():
  expected_matrices = iter("""\
1,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,1
1,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0
1,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0
1,1,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,1,1
1,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0
1,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0
1,1,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,0
1,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0
-1,-1,-1,1,0,0,-1,-1,-1,0,1,0,-1,-1,-1,0,0,1
1,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0
1,1,0,1,0,0,1,0,1,0,1,0,0,1,1,0,0,1
1,1,0,0,0,0,0,0,1,0,0,0
1,1,0,0,0,0,0,0,1,0,0,0
1,1,0,1,0,0,1,1,2,0,1,1
0,0,1,0,0,0,2,2,0,1,0,0
0,0,1,0,0,0,2,2,0,1,0,0
1,1,1,0,0,0,0,0,0,1,1,1
1,1,1,0,0,0
1,1,1,0,0,0
2,2,2,1,1,1
1,1,1,0,0,0
-3,-3,-3,1,1,1
""".splitlines())
  from cctbx import sgtbx
  from cctbx.sgtbx.bravais_types import acentric
  for symbol in acentric:
    def check(sgi):
      expected = [float(_) for _ in next(expected_matrices).split(",")]
      gr = sgi.group()
      assert approx_equal(
        gr.adp_constraints().gradient_sum_matrix(),
        expected)
      if (gr.n_ltr() != 1):
        check(sgi.primitive_setting())
    check(sgtbx.space_group_info(symbol=symbol))

def d_dw_d_u_star_analytical(h, u_star):
  dw = adptbx.debye_waller_factor_u_star(h, u_star)
  gc = flex.double(adptbx.debye_waller_factor_u_star_gradient_coefficients(h))
  return -2*math.pi**2 * gc * dw

def d2_dw_d_u_star_d_u_star_analytical(h, u_star):
  dw = adptbx.debye_waller_factor_u_star(h, u_star)
  cc = flex.double(adptbx.debye_waller_factor_u_star_curvature_coefficients(h))
  return 4*math.pi**4 * cc * dw

def d_dw_d_u_star_finite(h, u_star, eps=1.e-6):
  result = flex.double()
  for ip in range(len(u_star)):
    vs = []
    for signed_eps in [eps,-eps]:
      u_star_eps = list(u_star)
      u_star_eps[ip] += signed_eps
      vs.append(adptbx.debye_waller_factor_u_star(h, u_star_eps))
    result.append((vs[0]-vs[1])/(2*eps))
  return result

def d2_dw_d_u_star_d_u_star_finite(h, u_star, eps=1.e-6):
  result = flex.double()
  for ip in range(len(u_star)):
    vs = []
    for signed_eps in [eps,-eps]:
      u_star_eps = list(u_star)
      u_star_eps[ip] += signed_eps
      vs.append(d_dw_d_u_star_analytical(h, u_star_eps))
    result.extend((vs[0]-vs[1])/(2*eps))
  result.reshape(flex.grid(6,6))
  return result.matrix_symmetric_as_packed_u(relative_epsilon=1.e-5)

def d_dw_d_u_indep_finite(adp_constraints, h, u_indep, eps=1.e-6):
  result = flex.double()
  for i_indep in range(len(u_indep)):
    vs = []
    for signed_eps in [eps,-eps]:
      u_indep_eps = list(u_indep)
      u_indep_eps[i_indep] += signed_eps
      u_eps = adp_constraints.all_params(u_indep_eps)
      vs.append(adptbx.debye_waller_factor_u_star(h, u_eps))
    result.append((vs[0]-vs[1])/(2*eps))
  return result

def d2_dw_d_u_indep_d_u_indep_finite(adp_constraints, h, u_indep, eps=1.e-6):
  result = flex.double()
  for i_indep in range(len(u_indep)):
    vs = []
    for signed_eps in [eps,-eps]:
      u_indep_eps = list(u_indep)
      u_indep_eps[i_indep] += signed_eps
      vs.append(d_dw_d_u_indep_finite(adp_constraints, h, u_indep_eps))
    result.extend((vs[0]-vs[1])/(2*eps))
  np = len(u_indep)
  result.reshape(flex.grid(np,np))
  return result.matrix_symmetric_as_packed_u(relative_epsilon=1.e-5)

def p2_curv(h, u_star):
  """\
h = {h0,h1,h2}
u = {{u00,0,u02},{0,u11,0},{u02,0,u22}}
dw=Exp[mtps*h.u.h]
FortranForm[D[dw,u00,u00]/dw]
FortranForm[D[dw,u00,u11]/dw]
FortranForm[D[dw,u00,u22]/dw]
FortranForm[D[dw,u00,u02]/dw]
FortranForm[D[dw,u11,u00]/dw]
FortranForm[D[dw,u11,u11]/dw]
FortranForm[D[dw,u11,u22]/dw]
FortranForm[D[dw,u11,u02]/dw]
FortranForm[D[dw,u22,u00]/dw]
FortranForm[D[dw,u22,u11]/dw]
FortranForm[D[dw,u22,u22]/dw]
FortranForm[D[dw,u22,u02]/dw]
FortranForm[D[dw,u02,u00]/dw]
FortranForm[D[dw,u02,u11]/dw]
FortranForm[D[dw,u02,u22]/dw]
FortranForm[D[dw,u02,u02]/dw]
"""
  dw = adptbx.debye_waller_factor_u_star(h, u_star)
  h0, h1, h2 = h
  u00 = u_star[0]
  u11 = u_star[1]
  u22 = u_star[2]
  u02 = u_star[4]
  mtps = -2*math.pi**2
  return [
    [dw * (h0**4*mtps**2),
     dw * (h0**2*h1**2*mtps**2),
     dw * (h0**2*h2**2*mtps**2),
     dw * (2*h0**3*h2*mtps**2)],
    [dw * (h0**2*h1**2*mtps**2),
     dw * (h1**4*mtps**2),
     dw * (h1**2*h2**2*mtps**2),
     dw * (2*h0*h1**2*h2*mtps**2)],
    [dw * (h0**2*h2**2*mtps**2),
     dw * (h1**2*h2**2*mtps**2),
     dw * (h2**4*mtps**2),
     dw * (2*h0*h2**3*mtps**2)],
    [dw * (2*h0**3*h2*mtps**2),
     dw * (2*h0*h1**2*h2*mtps**2),
     dw * (2*h0*h2**3*mtps**2),
     dw * (4*h0**2*h2**2*mtps**2)]]

def p4_curv(h, u_star):
  """\
h = {h0,h1,h2}
u = {{u11,0,0},{0,u11,0},{0,0,u22}}
dw=Exp[mtps*h.u.h]
FortranForm[D[dw,u11,u11]/dw]
FortranForm[D[dw,u11,u22]/dw]
FortranForm[D[dw,u22,u11]/dw]
FortranForm[D[dw,u22,u22]/dw]
"""
  dw = adptbx.debye_waller_factor_u_star(h, u_star)
  h0, h1, h2 = h
  u11 = u_star[1]
  u22 = u_star[2]
  mtps = -2*math.pi**2
  return [
    [dw * ((h0**2 + h1**2)**2*mtps**2),
     dw * ((h0**2 + h1**2)*h2**2*mtps**2)],
    [dw * ((h0**2 + h1**2)*h2**2*mtps**2),
     dw * (h2**4*mtps**2)]]

def p3_curv(h, u_star):
  """\
h = {h0,h1,h2}
u = {{2*u01,u01,0},{u01,2*u01,0},{0,0,u22}}
dw=Exp[mtps*h.u.h]
FortranForm[D[dw,u22,u22]/dw]
FortranForm[D[dw,u22,u01]/dw]
FortranForm[D[dw,u01,u22]/dw]
FortranForm[D[dw,u01,u01]/dw]
"""
  dw = adptbx.debye_waller_factor_u_star(h, u_star)
  h0, h1, h2 = h
  u22 = u_star[2]
  u01 = u_star[3]
  mtps = -2*math.pi**2
  return [
    [dw * (h2**4*mtps**2),
     dw * ((h0*(2*h0 + h1) + h1*(h0 + 2*h1))*h2**2*mtps**2)],
    [dw * ((h0*(2*h0 + h1) + h1*(h0 + 2*h1))*h2**2*mtps**2),
     dw * ((h0*(2*h0 + h1) + h1*(h0 + 2*h1))**2*mtps**2)]]

def p23_curv(h, u_star):
  """\
h = {h0,h1,h2}
u = {{u22,0,0},{0,u22,0},{0,0,u22}}
dw=Exp[mtps*h.u.h]
FortranForm[D[dw,u22,u22]/dw]
"""
  dw = adptbx.debye_waller_factor_u_star(h, u_star)
  h0, h1, h2 = h
  u22 = u_star[2]
  mtps = -2*math.pi**2
  return [
    [dw * ((h0**2 + h1**2 + h2**2)**2*mtps**2)]]

def compare_derivatives(ana, fin, eps=1.e-6):
  s = max(1, flex.max(flex.abs(ana)))
  assert approx_equal(ana/s, fin/s, eps=eps)

def exercise_derivatives(space_group_info, out):
  crystal_symmetry = space_group_info.any_compatible_crystal_symmetry(
    volume=1000)
  space_group = space_group_info.group()
  adp_constraints = space_group.adp_constraints()
  m = adp_constraints.row_echelon_form()
  print(matrix.rec(m, (m.size()//6, 6)).mathematica_form(
    one_row_per_line=True), file=out)
  print(list(adp_constraints.independent_indices), file=out)
  u_cart_p1 = adptbx.random_u_cart()
  u_star_p1 = adptbx.u_cart_as_u_star(crystal_symmetry.unit_cell(), u_cart_p1)
  u_star = space_group.average_u_star(u_star_p1)
  miller_set = miller.build_set(
    crystal_symmetry=crystal_symmetry, d_min=3, anomalous_flag=False)
  for h in miller_set.indices():
    grads_fin = d_dw_d_u_star_finite(h=h, u_star=u_star)
    print("grads_fin:", list(grads_fin), file=out)
    grads_ana = d_dw_d_u_star_analytical(h=h, u_star=u_star)
    print("grads_ana:", list(grads_ana), file=out)
    compare_derivatives(grads_ana, grads_fin)
    curvs_fin = d2_dw_d_u_star_d_u_star_finite(h=h, u_star=u_star)
    print("curvs_fin:", list(curvs_fin), file=out)
    curvs_ana = d2_dw_d_u_star_d_u_star_analytical(h=h, u_star=u_star)
    print("curvs_ana:", list(curvs_ana), file=out)
    compare_derivatives(curvs_ana, curvs_fin)
    #
    u_indep = adp_constraints.independent_params(u_star)
    grads_indep_fin = d_dw_d_u_indep_finite(
      adp_constraints=adp_constraints, h=h, u_indep=u_indep)
    print("grads_indep_fin:", list(grads_indep_fin), file=out)
    grads_indep_ana = flex.double(adp_constraints.independent_gradients(
      all_gradients=list(grads_ana)))
    print("grads_indep_ana:", list(grads_indep_ana), file=out)
    compare_derivatives(grads_indep_ana, grads_indep_fin)
    curvs_indep_fin = d2_dw_d_u_indep_d_u_indep_finite(
      adp_constraints=adp_constraints, h=h, u_indep=u_indep)
    print("curvs_indep_fin:", list(curvs_indep_fin), file=out)
    curvs_indep_ana = adp_constraints.independent_curvatures(
      all_curvatures=curvs_ana)
    print("curvs_indep_ana:", list(curvs_indep_ana), file=out)
    compare_derivatives(curvs_indep_ana, curvs_indep_fin)
    #
    curvs_indep_mm = None
    if (str(space_group_info) == "P 1 2 1"):
      assert list(adp_constraints.independent_indices) == [0,1,2,4]
      curvs_indep_mm = p2_curv(h, u_star)
    elif (str(space_group_info) == "P 4"):
      assert list(adp_constraints.independent_indices) == [1,2]
      curvs_indep_mm = p4_curv(h, u_star)
    elif (str(space_group_info) in ["P 3", "P 6"]):
      assert list(adp_constraints.independent_indices) == [2,3]
      curvs_indep_mm = p3_curv(h, u_star)
    elif (str(space_group_info) == "P 2 3"):
      assert list(adp_constraints.independent_indices) == [2]
      curvs_indep_mm = p23_curv(h, u_star)
    if (curvs_indep_mm is not None):
      curvs_indep_mm = flex.double(
        curvs_indep_mm).matrix_symmetric_as_packed_u()
      print("curvs_indep_mm:", list(curvs_indep_mm), file=out)
      compare_derivatives(curvs_indep_ana, curvs_indep_mm)

def run_call_back(flags, space_group_info):
  if (flags.Verbose):
    out = sys.stdout
  else:
    out = StringIO()
  exercise_derivatives(space_group_info, out=out)
  if (space_group_info.group().n_ltr() != 1):
    exercise_derivatives(space_group_info.primitive_setting(), out=out)

def run():
  exercise_constraint_matrix()
  debug_utils.parse_options_loop_space_groups(sys.argv[1:], run_call_back)

if (__name__ == "__main__"):
  run()


 *******************************************************************************


 *******************************************************************************
cctbx/regression/tst_adp_constraints_cartesian.py
from __future__ import absolute_import, division, print_function
from cctbx import adptbx, sgtbx
from cctbx.development import debug_utils
from scitbx.math import row_echelon_full_pivoting
from scitbx.array_family import flex
from libtbx.test_utils import approx_equal
import random
import sys
from six.moves import range


def f(u_cart):
  """ A non-linear function of the 6 components u_cart """
  result = 0
  u = u_cart[0]
  for i in range(1,6):
    if i%2: v = u*u
    else:   v = u*u*u
    result += v * u_cart[i]
    u = u_cart[i]
  result += u*u*u * u_cart[0]
  return result


def exercise_all_wyckoff(flags, space_group_info):
  """ Set-up crystal and constraints """
  crystal = space_group_info.any_compatible_crystal_symmetry(
    volume=1000)
  unit_cell = crystal.unit_cell()
  wyckoffs = space_group_info.wyckoff_table()
  for i in range(wyckoffs.size()):
    wyckoff_pos = wyckoffs.position(i)
    print("%s," % wyckoff_pos.letter(), end=' ')
    special_op = wyckoff_pos.special_op()
    exact_site = eval("(%s)" % special_op, {'x':0.1, 'y':0.2, 'z':0.3})
    site_symmetry = sgtbx.site_symmetry(crystal.unit_cell(),
                                        crystal.space_group(),
                                        exact_site)
    u_star_constraints = site_symmetry.adp_constraints()
    u_cart_constraints = site_symmetry.cartesian_adp_constraints(unit_cell)

    """ Compatibility of all_params for u* and u_cart """
    n = u_cart_constraints.n_independent_params()
    assert n == u_star_constraints.n_independent_params()
    basis = []
    for i in range(n):
      v = [0]*n
      v[i] = 1
      basis.append(v)
    u_cart_basis = [ u_cart_constraints.all_params(v) for v in basis ]
    u_star_basis = [ u_star_constraints.all_params(v) for v in basis ]
    u_cart_basis_bis = [ adptbx.u_star_as_u_cart(unit_cell, u)
                         for u in u_star_basis ]
    a_work = flex.double(u_cart_basis)
    u_cart_basis_echelon = row_echelon_full_pivoting(
      a_work=a_work, min_abs_pivot=1e-9)
    # the vector subspaces spanned respectively by u_cart_basis and
    # by u_cart_basis_bis should be equal
    for u in u_cart_basis_bis:
      assert u_cart_basis_echelon.is_in_row_space(
        x=flex.double(u), epsilon=1e-9)

    """ Test the independent gradient computation """
    eps = 1e-4
    v0 = tuple([ random.random() for i in range(n) ])
    u_cart_0 = u_cart_constraints.all_params(v0)
    grad_f_wrt_independent_u_cart = []
    for i in range(n):
      v_up = list(v0)
      v_up[i] += eps
      v_down = list(v0)
      v_down[i] -= eps
      der = (   f( u_cart_constraints.all_params(v_up)   )
              - f( u_cart_constraints.all_params(v_down) )
            ) / (2 * eps)
      grad_f_wrt_independent_u_cart.append(der)
    grad_f_wrt_u_cart = []
    for i in range(6):
      u_cart_up = list(u_cart_0)
      u_cart_up[i] += eps
      u_cart_down = list(u_cart_0)
      u_cart_down[i] -= eps
      der = ( f(u_cart_up) - f(u_cart_down) ) / (2 * eps)
      grad_f_wrt_u_cart.append(der)
    grad_f_wrt_independent_u_cart_1 = (
      u_cart_constraints.independent_gradients(tuple(grad_f_wrt_u_cart)))
    assert flex.max( flex.abs( flex.double(grad_f_wrt_independent_u_cart_1)
             - flex.double(grad_f_wrt_independent_u_cart) ) ) < 5*eps**2

    """ Check independent_params """
    v = tuple([ random.random() for i in range(n) ])
    u_cart = u_cart_constraints.all_params(v)
    w = u_cart_constraints.independent_params(u_cart)
    assert approx_equal(v, w, eps=1e-12)

  print()

def run():
  debug_utils.parse_options_loop_space_groups(sys.argv[1:],
                                              exercise_all_wyckoff)

if (__name__ == "__main__"):
  run()


 *******************************************************************************


 *******************************************************************************
cctbx/regression/tst_amplitude_normalisation.py
from __future__ import absolute_import, division, print_function
from cctbx import sgtbx
from cctbx import uctbx
from cctbx import miller
from cctbx import crystal
from cctbx.array_family import flex
from libtbx.test_utils import approx_equal
from libtbx import group_args
import math
from six.moves import range

class Empty(object):
  pass

def as_normalised_array(miller_array,
                        asu_contents,
                        wilson_plot=None):
  """Old python code replaced by faster C++ code."""
  from cctbx import statistics
  from cctbx import eltbx
  if not wilson_plot:
    wilson_plot = statistics.wilson_plot(miller_array, asu_contents)

  # cache scattering factor info
  gaussians = {}
  for chemical_type in asu_contents:
    gaussians.setdefault(chemical_type, eltbx.xray_scattering.wk1995(
      chemical_type).fetch())

  stol_sq = miller_array.sin_theta_over_lambda_sq()
  epsilons = miller_array.epsilons()
  e_sq_minus_1 = 0
  n_e_greater_than_2 = 0

  normalised_f_obs = flex.double()
  space_group = miller_array.space_group()
  tau = space_group.n_ltr()
  for i in range(0,miller_array.size()):
    s_sq = stol_sq.data()[i]
    f_sq = math.pow(miller_array.data()[i], 2)
    epsilon = epsilons.data()[i]

    sum_fj_sq = 0
    for chemical_type, n_atoms in asu_contents.items():
      n_atoms *= space_group.order_z()
      f0 = gaussians[chemical_type].at_stol_sq(s_sq)
      sum_fj_sq += f0 * f0 * n_atoms

    e_sq = f_sq\
         /(wilson_plot.wilson_intensity_scale_factor*math.exp(-2*wilson_plot.wilson_b*s_sq)
           *epsilon
           *tau
           *sum_fj_sq)
    normalised_f_obs.append(math.sqrt(e_sq))
    e_sq_minus_1 += abs(e_sq - 1)
    if (e_sq > 4.0): n_e_greater_than_2 += 1

  r = Empty()
  r.array = miller.array(
    miller_set=miller.set(
      crystal_symmetry=miller_array.crystal_symmetry(),
      indices=miller_array.indices()).auto_anomalous(),
    data=normalised_f_obs,
    sigmas=miller_array.sigmas())
  r.mean_e_sq_minus_1 = e_sq_minus_1/r.array.size()
  r.percent_e_sq_gt_2 = (100.0*n_e_greater_than_2)/r.array.size()

  return r

def exercise_normalised_amplitudes():
  f = {'C':10,'H':10,'N':1}
  k = 1.322
  b = 5.672
  u = uctbx.unit_cell((3,4,5,90,81,90))
  sgi = sgtbx.space_group_info("P 21")
  i = flex.miller_index(((1,-2,3), (-3,5,0), (1,0,0)))
  d = flex.double((1,2,0.1))
  s = flex.double((2,3,1.1))
  expected = flex.double(
    (0.24360789372276667, 10.918685276828379, 0.0052268772340737469))

  ms = miller.set(
      crystal_symmetry=crystal.symmetry(
        space_group_info=sgi,
        unit_cell=u),
      indices=i)
  ma = miller.array(miller_set=ms, data=d, sigmas=s)
  ma.set_observation_type_xray_amplitude()
  normalised = ma.normalised_amplitudes(
    asu_contents=f,
    wilson_plot=group_args(wilson_intensity_scale_factor=k, wilson_b=b))

  python_normalised = as_normalised_array(
    miller_array=ma,
    asu_contents=f,
    wilson_plot=group_args(wilson_intensity_scale_factor=k, wilson_b=b))

  assert normalised.array().size() == ma.size()
  assert approx_equal(normalised.array().data(),
                      python_normalised.array.data())
  assert approx_equal(normalised.array().data(), expected)

  normalisations = ms.amplitude_normalisations(
    asu_contents=f,
    wilson_plot=group_args(wilson_intensity_scale_factor=k, wilson_b=b))
  assert approx_equal((normalised.array()*normalisations).data(), d)

def run():
  exercise_normalised_amplitudes()
  print("OK")

if __name__ == '__main__':
  run()


 *******************************************************************************


 *******************************************************************************
cctbx/regression/tst_change_basis.py
from __future__ import absolute_import, division, print_function
from cctbx import sgtbx
from cctbx.development import random_structure
from cctbx.development import debug_utils
from cctbx.array_family import flex
from cctbx.regression.tst_miller import generate_random_hl
import scitbx.math
from libtbx.test_utils import approx_equal
import math
import sys
from six.moves import zip

def check_weight_without_occupancy(structure):
  order_z = structure.space_group().order_z()
  for sc in structure.scatterers():
    assert approx_equal(
      sc.weight_without_occupancy(),
      float(sc.multiplicity()) / order_z)

def check_site_symmetry_table(structure_a, cb_op, structure_b):
  tab_a = structure_a.site_symmetry_table()
  tab_b = structure_b.site_symmetry_table()
  assert tab_a.indices().all_eq(tab_b.indices())
  assert tab_a.special_position_indices().all_eq(
         tab_b.special_position_indices())
  for oa,ob in zip(tab_a.table(),tab_b.table()):
    assert str(cb_op.apply(oa.special_op())) == str(ob.special_op())
    for ma,mb in zip(oa.matrices(),ob.matrices()):
      assert str(cb_op.apply(ma)) == str(mb)
    assert ob.multiplicity() > 0

def exercise(
      space_group_info,
      anomalous_flag,
      use_u_aniso,
      n_elements=3,
      d_min=3.,
      verbose=0):
  structure_z = random_structure.xray_structure(
    space_group_info,
    elements=("Se",)*n_elements,
    volume_per_atom=200,
    random_f_prime_d_min=1.0,
    random_f_double_prime=anomalous_flag,
    random_u_iso=True,
    use_u_aniso=use_u_aniso,
    random_occupancy=True)
  check_weight_without_occupancy(structure_z)
  f_z = structure_z.structure_factors(
    anomalous_flag=anomalous_flag, d_min=d_min, algorithm="direct").f_calc()
  f_abs_z = abs(f_z)
  f_rad_z = f_z.phases()
  f_deg_z = f_z.phases(deg=True)
  hl_z = generate_random_hl(miller_set=f_z)
  hl_z_rad = hl_z.phase_integrals()
  if (0 or verbose):
    structure_z.show_summary().show_scatterers()
    print("n_special_positions:", \
          structure_z.special_position_indices().size())
  z2p_op = structure_z.space_group().z2p_op()
  z2p_op = sgtbx.change_of_basis_op(
      z2p_op.c()
    + sgtbx.tr_vec((2,-1,3), 12).new_denominator(z2p_op.c().t().den()))
  for change_hand in [False, True]:
    if (change_hand):
      z2p_op = z2p_op * sgtbx.change_of_basis_op("-x,-y,-z")
    structure_p = structure_z.change_basis(z2p_op)
    check_weight_without_occupancy(structure_p)
    check_site_symmetry_table(structure_z, z2p_op, structure_p)
    if (0 or verbose):
      structure_p.show_summary().show_scatterers()
      print("n_special_positions:", \
            structure_p.special_position_indices().size())
    assert tuple(structure_p.special_position_indices()) \
        == tuple(structure_z.special_position_indices())
    structure_pz = structure_p.change_basis(z2p_op.inverse())
    check_weight_without_occupancy(structure_pz)
    check_site_symmetry_table(structure_p, z2p_op.inverse(), structure_pz)
    assert structure_pz.unit_cell().is_similar_to(structure_z.unit_cell())
    assert structure_pz.space_group() == structure_z.space_group()
    f_pz = f_z.structure_factors_from_scatterers(
      xray_structure=structure_pz,
      algorithm="direct").f_calc()
    f_abs_pz = abs(f_pz)
    f_rad_pz = f_pz.phases()
    f_deg_pz = f_pz.phases(deg=True)
    c = flex.linear_correlation(f_abs_z.data(), f_abs_pz.data())
    assert c.is_well_defined()
    if (0 or verbose):
      print("correlation:", c.coefficient())
    assert c.coefficient() > 0.999
    f_p_cb = f_z.change_basis(z2p_op)
    f_abs_p_cb = f_abs_z.change_basis(z2p_op)
    f_rad_p_cb = f_rad_z.change_basis(z2p_op, deg=False)
    f_deg_p_cb = f_deg_z.change_basis(z2p_op, deg=True)
    hl_p_cb = hl_z.change_basis(z2p_op)
    hl_p_cb_rad = hl_p_cb.phase_integrals()
    assert approx_equal(
      hl_z_rad.change_basis(z2p_op).data(), hl_p_cb_rad.data())
    assert f_abs_p_cb.indices().all_eq(f_p_cb.indices())
    if (not change_hand):
      o = flex.order(f_abs_p_cb.indices(), f_abs_z.indices())
    else:
      o = flex.order(-f_abs_p_cb.indices(), f_abs_z.indices())
    if (f_abs_z.space_group().n_ltr() == 1):
      assert o == 0
    else:
      assert o != 0
    f_pz = f_p_cb.change_basis(z2p_op.inverse())
    f_abs_pz = f_abs_p_cb.change_basis(z2p_op.inverse())
    f_rad_pz = f_rad_p_cb.change_basis(z2p_op.inverse(), deg=False)
    f_deg_pz = f_deg_p_cb.change_basis(z2p_op.inverse(), deg=True)
    hl_pz = hl_p_cb.change_basis(z2p_op.inverse())
    hl_pz_rad = hl_pz.phase_integrals()
    assert approx_equal(hl_z_rad.data(), hl_pz_rad.data())
    for i,o in zip(hl_z.data(), hl_pz.data()):
      assert approx_equal(i, o)
    assert approx_equal(
      flex.max(flex.abs(f_pz.data() - f_z.data())), 0)
    assert flex.order(f_abs_pz.indices(), f_abs_z.indices()) == 0
    assert f_abs_pz.indices().all_eq(f_pz.indices())
    assert approx_equal(flex.max(scitbx.math.phase_error(
      phi1=f_rad_pz.data(), phi2=f_rad_z.data())), 0)
    assert approx_equal(flex.max(scitbx.math.phase_error(
      phi1=f_deg_pz.data(), phi2=f_deg_z.data(), deg=True)), 0)
    assert approx_equal(f_deg_pz.data(), f_rad_pz.data()*(180/math.pi))
    f_p_sf = f_p_cb.structure_factors_from_scatterers(
      xray_structure=structure_p,
      algorithm="direct").f_calc()
    det = abs(z2p_op.c().r().determinant())
    assert approx_equal(
      flex.max(flex.abs(f_p_sf.data()*complex(det) - f_p_cb.data())), 0)
    f_abs_p_sf = abs(f_p_sf)
    f_rad_p_sf = f_p_sf.phases()
    f_deg_p_sf = f_p_sf.phases(deg=True)
    assert approx_equal(flex.max(scitbx.math.phase_error(
      phi1=f_rad_p_sf.data(), phi2=f_rad_p_cb.data())), 0)
    assert approx_equal(flex.max(scitbx.math.phase_error(
      phi1=f_deg_p_sf.data(), phi2=f_deg_p_cb.data(), deg=True)), 0)
    c = flex.linear_correlation(f_abs_p_sf.data(), f_abs_p_cb.data())
    assert c.is_well_defined()
    if (0 or verbose):
      print("correlation:", c.coefficient())
    assert c.coefficient() > 0.999

def run_call_back(flags, space_group_info):
  for anomalous_flag in (False, True)[:]: #SWITCH
    for use_u_aniso in (False, True)[:]: #SWITCH
      exercise(
        space_group_info=space_group_info,
        anomalous_flag=anomalous_flag,
        use_u_aniso=use_u_aniso,
        verbose=flags.Verbose)

def run():
  debug_utils.parse_options_loop_space_groups(sys.argv[1:], run_call_back)

if (__name__ == "__main__"):
  run()


 *******************************************************************************


 *******************************************************************************
cctbx/regression/tst_connectivity.py
from __future__ import absolute_import, division, print_function
from scitbx.array_family import flex
import time
import iotbx.pdb
from cctbx import maptbx
from cctbx import miller
from six.moves import range
from six.moves import zip
from libtbx.test_utils import approx_equal
import boost_adaptbx.boost.python as bp
ext = bp.import_ext("cctbx_asymmetric_map_ext")
from cctbx_asymmetric_map_ext import *


def getvs(cmap, threshold, wrap=True):
  co = maptbx.connectivity(map_data=cmap, threshold=threshold, wrapping=wrap)
  map_result = co.result()
  regs = co.regions()
  coors = co.maximum_coors()
  vals = co.maximum_values()
  assert len(list(regs)) == len(list(coors)) == len(list(vals))
  # check dimensions
  assert cmap.all() == map_result.all()
  v=[0,0,0]
  for i in range(3):
    v[i] = (map_result==i).count(True)
  return v, list(co.regions())

def exercise1():
  pdb_str="""
CRYST1   10.000  10.000   10.000  90.00  90.00  90.00 P 1
HETATM    1  C    C      1       2.000   2.000   2.000  1.00 20.00           C
END
"""
  pdb_inp = iotbx.pdb.input(source_info=None, lines=pdb_str)
  xrs = pdb_inp.xray_structure_simple()
  cg = maptbx.crystal_gridding(unit_cell=xrs.unit_cell(),
      pre_determined_n_real=(100,100,100),
      space_group_info=xrs.space_group_info())
  fc = xrs.structure_factors(d_min = 1., algorithm = "direct").f_calc()
  fft_map = miller.fft_map(crystal_gridding=cg, fourier_coefficients=fc)
  map_data = fft_map.real_map_unpadded()

  # pass map and threshold value
  co = maptbx.connectivity(map_data=map_data, threshold=100.)
  # get 'map' of the same size with integers: 0 where below threshold,
  # 1,2,3... - for connected regions
  map_result = co.result()
  # to find out the number of connected region for particular point:
  assert map_result[0,0,0] == 0    # means under threshold
  assert map_result[20,20,20] == 1 # blob 1

  # get 1d array of integer volumes and transform it to list.
  volumes = list(co.regions())
  # find max volume (except volume of 0-region which will be probably max)
  max_volume = max(volumes[1:])
  # find number of the region with max volume
  max_index = volumes.index(max_volume)
  v=[0,0,0]
  for i in range(3):
    # !!! Do not do this because it's extremely slow! Used for test purposes.
    v[i] = (map_result==i).count(True)

  assert v[2] == 0
  assert v[1] < 15000
  assert v[0]+v[1]+v[2] == 1000000
  assert volumes == v[:2]

def exercise3():
  pdb_str="""
CRYST1   10.000  10.000   10.000  90.00  90.00  90.00 P 1
HETATM    1  C    C      1       2.000   2.000   2.000  1.00  2.00           C
HETATM    1  C    C      1       3.500   2.000   2.000  1.00  2.00           C
END
"""

  pdb_inp = iotbx.pdb.input(source_info=None, lines=pdb_str)
  xrs = pdb_inp.xray_structure_simple()
  cg = maptbx.crystal_gridding(unit_cell=xrs.unit_cell(),
      pre_determined_n_real=(100,100,100),
      space_group_info=xrs.space_group_info())
  fc = xrs.structure_factors(d_min = 1., algorithm = "direct").f_calc()
  fft_map = miller.fft_map(crystal_gridding=cg, fourier_coefficients=fc)
  fft_map.apply_sigma_scaling()
  map_data = fft_map.real_map_unpadded()
  #all filled
  v, volumes = getvs(map_data, -100)
  v2, volumes2 = getvs(map_data, -100, False)
  assert v == v2 == [0, 1000000, 0]
  assert v[:2] == v2[:2] == volumes == volumes2
  # can see one blob
  v, volumes = getvs(map_data, 5)
  assert v[0]+v[1]+v[2] == 1000000
  assert v[2] == 0
  assert v[:2] == volumes
  # can see separate, approx equal volume bloobs
  v, volumes = getvs(map_data, 10)
  assert v[0]+v[1]+v[2] == 1000000
  assert abs(v[1] - v[2]) < 5
  assert v == volumes
  # nothing to see
  v, volumes = getvs(map_data, 1000)
  assert v == [1000000, 0, 0]
  assert v[:1] == volumes

def exercise4():
  cmap = flex.double(flex.grid(100,100,100))
  cmap.fill(1)
  for i in range(10,20):
    for j in range(10,20):
      for k in range(10,20):
        cmap[i,j,k] = 10
  v, volumes = getvs(cmap, 5)
  v2, volumes2 = getvs(cmap, 5, False)
  assert v == v2 == [999000, 1000, 0]
  assert v[:2] == volumes == volumes2
  #print "all filled"
  v, volumes = getvs(cmap, -5)
  v2, volumes2 = getvs(cmap, -5, False)
  assert v == v2
  assert volumes == volumes2
  assert v == [0,1000000,0]
  assert v[:2] == volumes
  #print "none filled"
  v, volumes = getvs(cmap, 20)
  v2, volumes2 = getvs(cmap, 20, False)
  assert v == v2
  assert volumes == volumes2
  assert v == [1000000,0,0]
  assert v[:1] == volumes

def exercise41():
  cmap = flex.int(flex.grid(100,100,100))
  cmap.fill(1)
  for i in range(10,20):
    for j in range(10,20):
      for k in range(10,20):
        cmap[i,j,k] = 10
  v, volumes = getvs(cmap, 5)
  assert v == [999000, 1000, 0]
  assert v[:2] == volumes
  #print "all filled"
  v, volumes = getvs(cmap, -5)
  assert v == [0,1000000,0]
  assert v[:2] == volumes
  #print "none filled"
  v, volumes = getvs(cmap, 20)
  assert v == [1000000,0,0]
  assert v[:1] == volumes


def exercise5():
  #print "corner blob"
  cmap = flex.double(flex.grid(100,100,100))
  cmap.fill(0)
  for i in range(100):
    for j in range(100):
      for k in range(100):
        if (i<10 or i>=90) and (j<10 or j>=90) and (k<10 or k>=90):
          cmap[i,j,k] = 10
          #print i,j,k
  v, volumes = getvs(cmap, 5)
  assert v == [992000, 8000, 0]
  assert v[:2] == volumes

  # test wrapping = false - borders are not transparent
  v, volumes = getvs(cmap, 5, False)
  assert volumes == [992000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000]

  #print "2 blobs"
  cmap.fill(0)
  for i in range(100):
    for j in range(100):
      for k in range(100):
        if (5<i<10) and (5<j<10) and (5<k<10):
          cmap[i,j,k] = 10
        if (15<i<20) and (15<j<20) and (15<k<20):
          cmap[i,j,k] = 20
  v, volumes = getvs(cmap, 5)
  assert v == [999872,64,64]
  assert v == volumes
  v, volumes = getvs(cmap, 15)
  assert v == [999936, 64,0]
  assert v[:2] == volumes

  #print "endless blob"
  cmap.fill(0)
  for j in range(100):
    for k in range(100):
      cmap[5,j,k] = 10
  v, volumes = getvs(cmap, 5)
  assert v == [990000, 10000, 0]
  assert v[:2] == volumes

def exercise6():
  cmap = flex.double(flex.grid(100,100,100))
  #print "corner touch"
  cmap.fill(0)
  cmap[1,1,1] = cmap[2,2,2] = 10
  v, volumes = getvs(cmap, 5)
  assert v == [999998, 1, 1]
  assert v == volumes
  #print "edges touch"
  cmap.fill(0)
  cmap[1,1,1] = cmap[2,2,1] = 10
  v, volumes = getvs(cmap, 5)
  assert v == [999998, 1, 1]
  assert v == volumes
  #print "face touch"
  cmap.fill(0)
  cmap[1,1,1] = cmap[2,1,1] = 10
  v, volumes = getvs(cmap, 5)
  assert v == [999998, 2, 0]
  assert v[:2] == volumes

def exercise_volume_cutoff():
  cmap = flex.double(flex.grid(100,100,100))
  cmap.fill(0)
  for i in range(100):
    for j in range(100):
      for k in range(100):
        if (5<i<10) and (5<j<10) and (5<k<10):
          cmap[i,j,k] = 10
        if (15<i<25) and (15<j<25) and (15<k<25):
          cmap[i,j,k] = 20

  co = maptbx.connectivity(map_data=cmap, threshold=5)
  map_result = co.result()
  volumes = list(co.regions())
  #print volumes
  #[999207, 64, 729]
  vol_mask = co.volume_cutoff_mask(volume_cutoff=10)
  assert (vol_mask==1).count(True) == 793
  assert (vol_mask==0).count(True) == 999207
  vol_mask = co.volume_cutoff_mask(volume_cutoff=100)
  assert (vol_mask==1).count(True) == 729
  assert (vol_mask==0).count(True) == 999271
  vol_mask = co.volume_cutoff_mask(volume_cutoff=1000)
  assert (vol_mask==1).count(True) == 0
  assert (vol_mask==0).count(True) == 1000000

def exercise_max_values():
  cmap = flex.double(flex.grid(100,100,100))
  cmap.fill(0)
  for i in range(100):
    for j in range(100):
      for k in range(100):
        if (5<i<10) and (5<j<10) and (5<k<10):
          cmap[i,j,k] = 10
        if (15<i<25) and (15<j<25) and (15<k<25):
          cmap[i,j,k] = 20

  cmap[7,7,7] = 15
  cmap[20,20,20] = 25
  co = maptbx.connectivity(map_data=cmap, threshold=5)
  m_coors = list(co.maximum_coors())
  m_vals = list(co.maximum_values())
  vols = list(co.regions())
  assert len(m_coors) == len(m_vals) == len(vols)
  assert m_coors == [(0, 0, 0), (7, 7, 7), (20, 20, 20)]
  assert m_vals == [0.0, 15.0, 25.0]

def debug_printing(co):
  print("volumes    :",  list(co.regions()))
  print("values     :",  list(co.maximum_values()))
  print("coordinates:",  list(co.maximum_coors()))
  print("============")


def exercise_noise_elimination_two_cutoffs():
  # Purpose: eliminate noise.
  # We want to delete small blobs from the map. On the particular contouring
  # (cutoff) level we can set a threshold for volume and say: all blobs that
  # have volume less than threshold value should be deleted.
  # One more point is that we want to delete them with their 'root', meaning
  # that we are lowering threshold level and put zeros on that bigger regions.
  # But we are zeroing only those which are not merged with big good blobs.
  # Everything under second contouring level also will be zero.
  # ======================
  # From another point of view.
  # We know some threshold value for volume of good blobs on t1 contouring
  # level. We want to keep only them and clear out everything else. But the
  # keeping and clearing should be done at lower t2 contouring level.
  #
  # The result (res_mask) is 3d integer array sized as original map.
  # res_mask contain 0 for noise, 1 for valuable information.
  # Mask corresponding to t2 contouring level.
  #
  # The option "zero_all_interblob_region" by default is True, and this means
  # that everything below threshold on t2 level will be 0. If
  # zero_all_interblob_region=False then everything below threshold on t2
  # level will be 1.
  #
  #map preparation for test
  cmap = flex.double(flex.grid(100,2,2))
  cmap.fill(10)
  for i in range(10,40):
    cmap[i,1,1] = i
  for i,v in zip(range(40,60), range(40,20,-1)):
    cmap[i,1,1] = v
  for i,v in zip(range(60,70), range(20,30)):
    cmap[i,1,1] = v
  for i,v in zip(range(70,90), range(30,10,-1)):
    cmap[i,1,1] = v
  #for i in range(100):
  #  print "%d   : %d" % (i,  cmap[i,1,1])

  co1 = maptbx.connectivity(map_data=cmap, threshold=25)
  co2 = maptbx.connectivity(map_data=cmap, threshold=22)
  co3 = maptbx.connectivity(map_data=cmap, threshold=18)

  # Example 1. We have one good blob (volume>12) and one bad (volume < 12).
  # After lowering contour level they are still separate, so we want to keep
  # only big first blob, which has volume=35 on t2 contour level.
  # Here is actual call to get a mask.
  res_mask = co2.noise_elimination_two_cutoffs(
      connectivity_object_at_t1=co1,
      elimination_volume_threshold_at_t1=12,
      zero_all_interblob_region=True)
  assert (res_mask!=0).count(True) == 35
  # 2 good ===> 2 separate
  res_mask = co2.noise_elimination_two_cutoffs(
      connectivity_object_at_t1=co1,
      elimination_volume_threshold_at_t1=8)
  assert (res_mask!=0).count(True) == 50
  # 1 good, 1 bad ===> 1 big
  res_mask = co3.noise_elimination_two_cutoffs(
      connectivity_object_at_t1=co1,
      elimination_volume_threshold_at_t1=12)
  assert (res_mask!=0).count(True) == 63
  # 2 good ===> 1 big
  res_mask = co3.noise_elimination_two_cutoffs(
      connectivity_object_at_t1=co1,
      elimination_volume_threshold_at_t1=8)
  assert (res_mask!=0).count(True) == 63
  # 2 bad ===> 1 big
  res_mask = co3.noise_elimination_two_cutoffs(
      connectivity_object_at_t1=co1,
      elimination_volume_threshold_at_t1=30)
  assert (res_mask!=0).count(True) == 0

  # extreme case: nothing above t1 ==> result: everything is 0 on the mask
  co1 = maptbx.connectivity(map_data=cmap, threshold=40)
  co2 = maptbx.connectivity(map_data=cmap, threshold=22)
  res_mask = co2.noise_elimination_two_cutoffs(
      connectivity_object_at_t1=co1,
      elimination_volume_threshold_at_t1=10)
  assert (res_mask!=0).count(True) == 0

  # extreme case: everything above t1 ==> result is undefined.

  # =================================================================
  # same as above, but zero_all_interblob_region = False
  # In the first test we have 1 good blob and one bad blob. Bad one
  # will have volume=15 on t2 contouring level so we want to have 385 non-zeros
  # on resulting mask
  co1 = maptbx.connectivity(map_data=cmap, threshold=25)
  co2 = maptbx.connectivity(map_data=cmap, threshold=22)
  co3 = maptbx.connectivity(map_data=cmap, threshold=18)
  res_mask = co2.noise_elimination_two_cutoffs(
      connectivity_object_at_t1=co1,
      elimination_volume_threshold_at_t1=12,
      zero_all_interblob_region=False)
  #for i in range(100):
  #  print "%d   : %d | %d" % (i,  cmap[i,1,1], res_mask[i,1,1])
  assert (res_mask!=0).count(True) == 385

  # 2 good ===> 2 separate
  res_mask = co2.noise_elimination_two_cutoffs(
      connectivity_object_at_t1=co1,
      elimination_volume_threshold_at_t1=8,
      zero_all_interblob_region=False)
  assert (res_mask==1).count(True) == 400
  # 1 good, 1 bad ===> 1 big
  res_mask = co3.noise_elimination_two_cutoffs(
      connectivity_object_at_t1=co1,
      elimination_volume_threshold_at_t1=12,
      zero_all_interblob_region=False)
  assert (res_mask!=0).count(True) == 400
  # 2 good ===> 1 big
  res_mask = co3.noise_elimination_two_cutoffs(
      connectivity_object_at_t1=co1,
      elimination_volume_threshold_at_t1=8,
      zero_all_interblob_region=False)
  assert (res_mask!=0).count(True) == 400
  # 2 bad ===> 1 big
  res_mask = co3.noise_elimination_two_cutoffs(
      connectivity_object_at_t1=co1,
      elimination_volume_threshold_at_t1=30,
      zero_all_interblob_region=False)
  assert (res_mask!=0).count(True) == 337

  # extreme case: nothing above t1, something above t2 ==> result:
  # everything between blobs on t2 will be 1.
  co1 = maptbx.connectivity(map_data=cmap, threshold=40)
  co2 = maptbx.connectivity(map_data=cmap, threshold=22)
  res_mask = co2.noise_elimination_two_cutoffs(
      connectivity_object_at_t1=co1,
      elimination_volume_threshold_at_t1=10,
      zero_all_interblob_region=False)
  assert (res_mask!=0).count(True) == 350

def exercise_get_blobs_boundaries():
  cmap = flex.double(flex.grid(100,100,100))
  cmap.fill(1)
  for i in range(10,20):
    for j in range(10,20):
      for k in range(10,20):
        cmap[i,j,k] = 10
  co = maptbx.connectivity(map_data=cmap, threshold=5)
  # raw function:
  boundaries = co.get_blobs_boundaries()
  # how to use this:
  # boundaries[min/max, n_blob, x/y/z]
  blob_0_min_boundaries = \
      (boundaries[0,0,0], boundaries[0,0,1], boundaries[0,0,1])
  blob_0_max_boundaries = \
      (boundaries[1,0,0], boundaries[1,0,1], boundaries[1,0,1])
  # 0th blob - under the limit, covering almost whole cell
  assert blob_0_min_boundaries == (0,0,0)
  assert blob_0_max_boundaries == (99,99,99)
  # 1st blob - covers coordinates from 10 to 19 by construction
  blob_1_min_boundaries = \
      (boundaries[0,1,0], boundaries[0,1,1], boundaries[0,1,1])
  blob_1_max_boundaries = \
      (boundaries[1,1,0], boundaries[1,1,1], boundaries[1,1,1])
  assert blob_1_min_boundaries == (10,10,10)
  assert blob_1_max_boundaries == (19,19,19)
  # convinient get_blobs_boundaries_tuples
  minb, maxb = co.get_blobs_boundaries_tuples()
  assert minb == [(0,0,0), (10,10,10)]
  assert maxb == [(99,99,99), (19,19,19)]

  # ==============================
  # two blobs test
  # just add a blob to the previous cmap
  for i in range(50,70):
    for j in range(50,80):
      for k in range(50,90):
        cmap[i,j,k] = 10
  co = maptbx.connectivity(map_data=cmap, threshold=5)
  minb, maxb = co.get_blobs_boundaries_tuples()
  assert minb == [(0,0,0), (10,10,10), (50,50,50)]
  assert maxb == [(99,99,99), (19,19,19), (69,79,89)]

def exercise_expand_mask():
  # case 1: standard
  cmap = flex.double(flex.grid(30,30,30))
  cmap.fill(1)
  for i in range(10,20):
    for j in range(10,20):
      for k in range(10,20):
        cmap[i,j,k] = 10
  co = maptbx.connectivity(map_data=cmap, threshold=5)
  new_mask = co.expand_mask(id_to_expand=1, expand_size=1)
  for i in range(30):
    for j in range(30):
      for k in range(30):
        assert new_mask[i,j,k] == (i in range(9,21) and
            j in range(9,21) and k in range(9,21))

  # case 2: over boundaries
  cmap = flex.double(flex.grid(30,30,30))
  cmap.fill(1)
  cmap[1,1,1] = 10
  co = maptbx.connectivity(map_data=cmap, threshold=5)
  new_mask = co.expand_mask(id_to_expand=1, expand_size=2)
  for i in range(30):
    for j in range(30):
      for k in range(30):
        assert new_mask[i,j,k] == (i in [29,0,1,2,3] and
            j in [29,0,1,2,3] and k in [29,0,1,2,3])

def exercise_wrapping():
  cmap = flex.double(flex.grid(30,30,30))
  cmap.fill(1)
  for i in range(0,5):
    for j in range(0,5):
      for k in range(0,5):
        cmap[i,j,k] = 10
  for i in range(0,5):
    for j in range(25,30):
      for k in range(0,5):
        cmap[i,j,k] = 10
  for i in range(0,5):
    for j in range(0,5):
      for k in range(25,30):
        cmap[i,j,k] = 10

  for i in range(25,30):
    for j in range(0,5):
      for k in range(0,5):
        cmap[i,j,k] = 10
  for i in range(25,30):
    for j in range(25,30):
      for k in range(0,5):
        cmap[i,j,k] = 10
  for i in range(25,30):
    for j in range(0,5):
      for k in range(25,30):
        cmap[i,j,k] = 10

  n_in_blob = cmap.count(10)
  co = maptbx.connectivity(map_data=cmap, threshold=5, wrapping=True)
  dres = co.result().as_double()
  regs = list(co.regions())
  minb, maxb = co.get_blobs_boundaries_tuples()
  assert n_in_blob == 750
  assert regs == [26250, 750]

def exercise_preprocess_against_shallow():
  # case 1: simple
  cmap = flex.double(flex.grid(30,30,30))
  cmap.fill(1)
  for i in range(10,20):
    for j in range(10,20):
      for k in range(10,20):
        cmap[i,j,k] = 10
  for i in range(10,20):
    cmap[i,5,5] = 10
  co = maptbx.connectivity(map_data=cmap, threshold=5)
  minb, maxb = co.get_blobs_boundaries_tuples()
  assert minb == [(0, 0, 0), (10, 5, 5), (10, 10, 10)]
  assert maxb == [(29, 29, 29), (19, 5, 5), (19, 19, 19)]
  co = maptbx.connectivity(map_data=cmap, threshold=5, preprocess_against_shallow=True)
  minb, maxb = co.get_blobs_boundaries_tuples()
  assert minb == [(0, 0, 0), (10, 10, 10)]
  assert maxb == [(29, 29, 29), (19, 19, 19)] # note dissapearance of (10,5,5)(19,5,5)
  # check new map values
  for i in range(10,20):
    assert approx_equal(cmap[i,5,5], 4)


  # case 2: wrapping
  cmap = flex.double(flex.grid(30,30,30))
  cmap.fill(1)
  for i in range(10,20):
    for j in range(10,20):
      for k in range(10,20):
        cmap[i,j,k] = 10
  for i in range(10,20):
    for j in range(10,20):
      cmap[i,j,0] = 10
      cmap[i,j,29] = 10
  # standard, no wrap, 4 regions
  co = maptbx.connectivity(map_data=cmap, threshold=5, wrapping=False, preprocess_against_shallow=False)
  minb, maxb = co.get_blobs_boundaries_tuples()
  assert minb == [(0, 0, 0), (10, 10, 0), (10, 10, 10), (10, 10, 29)]
  assert maxb == [(29, 29, 29), (19, 19, 0), (19, 19, 19), (19, 19, 29)]
  # 2 small regions merged
  co = maptbx.connectivity(map_data=cmap, threshold=5, wrapping=True, preprocess_against_shallow=False)
  minb, maxb = co.get_blobs_boundaries_tuples()
  assert minb == [(0, 0, 0), (10, 10, 0), (10, 10, 10)]
  assert maxb == [(29, 29, 29), (19, 19, 29), (19, 19, 19)]
  # with wrapping the region preserved
  co = maptbx.connectivity(map_data=cmap, threshold=5, wrapping=True, preprocess_against_shallow=True)
  minb, maxb = co.get_blobs_boundaries_tuples()
  assert minb == [(0, 0, 0), (10, 10, 0), (10, 10, 10)]
  assert maxb == [(29, 29, 29), (19, 19, 29), (19, 19, 19)]

  # without wrapping - no
  co = maptbx.connectivity(map_data=cmap, threshold=5, wrapping=False, preprocess_against_shallow=True)
  minb, maxb = co.get_blobs_boundaries_tuples()
  assert minb == [(0, 0, 0), (10, 10, 10)]
  assert maxb ==[(29, 29, 29), (19, 19, 19)]

  # case 3: blob has a spike that needs to be 'shaved off'
  cmap = flex.double(flex.grid(30,30,30))
  cmap.fill(1)
  for i in range(10,20):
    for j in range(10,20):
      for k in range(10,20):
        cmap[i,j,k] = 10
  for i in range(0,10):
    cmap[i,15,15] = 10

  co = maptbx.connectivity(map_data=cmap, threshold=5, preprocess_against_shallow=False)
  volumes = list(co.regions())
  assert volumes == [25990, 1010]
  co = maptbx.connectivity(map_data=cmap, threshold=5, preprocess_against_shallow=True)
  volumes = list(co.regions())
  assert volumes == [26000, 1000]
  for i in range(0,10):
    assert approx_equal(cmap[i,15,15], 4)

  # case 4: need at least two passes
  cmap = flex.double(flex.grid(30,30,30))
  cmap.fill(1)
  cmap[10,10,10] = 10
  cmap[9,10,10] = 10
  cmap[11,10,10] = 10
  cmap[10,9,10] = 10
  cmap[10,11,10] = 10
  cmap[10,10,9] = 10
  cmap[10,10,11] = 10
  co = maptbx.connectivity(map_data=cmap, threshold=5, preprocess_against_shallow=False)
  volumes = list(co.regions())
  assert volumes == [26993, 7]
  co = maptbx.connectivity(map_data=cmap, threshold=5, preprocess_against_shallow=True)
  volumes = list(co.regions())
  assert volumes == [27000]
  assert co.preprocessing_changed_voxels == 7
  assert co.preprocessing_n_passes == 3

def write_ccp4_map(fname, unit_cell, space_group, map_data):
  from iotbx import mrcfile
  mrcfile.write_ccp4_map(
      file_name=fname,
      unit_cell=unit_cell,
      space_group=space_group,
      #gridding_first=(0,0,0),# This causes a bug (map gets shifted)
      #gridding_last=n_real,  # This causes a bug (map gets shifted)
      map_data=map_data,
      labels=flex.std_string([""]))


def exercise_symmetry_related_regions():
  pdb_str="""
CRYST1   10.000  10.000   10.000  90.00  90.00  90.00 P 4
HETATM    1  C    C      1       2.000   2.000   2.000  1.00 20.00           C
HETATM    2  C    C      2       4.000   4.000   4.000  1.00 20.00           C
END
"""

  pdb_inp = iotbx.pdb.input(source_info=None, lines=pdb_str)
  xrs = pdb_inp.xray_structure_simple()
  # xrs.show_summary()
  d_min = 1.
  fc = xrs.structure_factors(d_min=d_min).f_calc()
  symmetry_flags = maptbx.use_space_group_symmetry
  fftmap = fc.fft_map(symmetry_flags = symmetry_flags)
  rmup = fftmap.real_map_unpadded()
  # print ('rmup size', rmup.accessor().focus())
  # This produces 4 separate blobs
  co = maptbx.connectivity(
      map_data=rmup,
      threshold=400,
      wrapping=False,
      preprocess_against_shallow=False)
  original_regions = list(co.regions())
  # print ('regions', original_regions)
  assert len(original_regions) == 5
  beg_mask = co.result()
  # dv_mask = co.volume_cutoff_mask(0).as_double() ???
  # write_ccp4_map('volume_mask_1000.ccp4', fc.unit_cell(), fc.space_group(), dv_mask)

  co.merge_symmetry_related_regions(space_group=xrs.space_group())
  new_mask = co.result()
  assert beg_mask.count(0) == new_mask.count(0)
  assert beg_mask.count(1) + beg_mask.count(3) == new_mask.count(1)
  assert beg_mask.count(2) + beg_mask.count(4) == new_mask.count(2)
  assert sum(original_regions[1:]) == sum(original_regions[1:])


  new_regions = list(co.regions())
  assert len(new_regions) == 3
  assert list(co.maximum_values()) == []
  assert list(co.maximum_coors()) == []

  # ======================================================================
  # At this threshold 2 carbons merge. But one of the blob is cutted,
  # therefore producing 3 separate regions in unit cell
  co = maptbx.connectivity(
      map_data=rmup,
      # threshold=1000,
      threshold=1.1,
      wrapping=False,
      preprocess_against_shallow=True)
  original_regions = list(co.regions())
  assert len(original_regions) == 4
  # print ('regions', original_regions)
  beg_mask = co.result()
  # Particular numbers here seem to be platform-dependent
  # These should work on Mac
  # assert beg_mask.count(0) == 29019
  # assert beg_mask.count(1) == 1885
  # assert beg_mask.count(2) == 1714
  # assert beg_mask.count(3) == 150

  # assert original_regions == [29019, 1885, 1714, 150]
  co.merge_symmetry_related_regions(space_group=xrs.space_group())
  new_mask = co.result()
  # assert new_mask.count(0) == 29019
  # assert new_mask.count(1) == 3749
  assert beg_mask.count(0) == new_mask.count(0)
  assert beg_mask.count(1) + beg_mask.count(2) + beg_mask.count(3) == new_mask.count(1)

  new_regions = list(co.regions())
  assert len(new_regions) == 2
  # print('new regs', new_regions)
  # assert new_regions == [29019, 3749]
  assert list(co.maximum_values()) == []
  assert list(co.maximum_coors()) == []


def exercise_work_in_asu():
  pdb_str="""
CRYST1   10.000  10.000   10.000  90.00  90.00  90.00  P 4
HETATM    1  C    C      1       2.000   2.000   2.000  1.00 20.00           C
HETATM    2  C    C      2       4.000   4.000   4.000  1.00 20.00           C
END
"""

  from time import time
  pdb_inp = iotbx.pdb.input(source_info=None, lines=pdb_str)
  xrs = pdb_inp.xray_structure_simple()
  # xrs.show_summary()
  d_min = 1
  fc = xrs.structure_factors(d_min=d_min).f_calc()
  symmetry_flags = maptbx.use_space_group_symmetry
  fftmap = fc.fft_map(symmetry_flags = symmetry_flags)
  # rmup = fftmap.real_map_unpadded()
  rm = fftmap.real_map().deep_copy()
  maptbx.unpad_in_place(rm)
  mmm = rm.as_1d().min_max_mean()
  print (mmm.min, mmm.max, mmm.mean)
  # rmup = fftmap.real_map_unpadded()
  # print (dir(rm))
  print ("full size:", fftmap.real_map().accessor().focus())
  print(rm[0,0,0])
  # print (type(rm))
  # print (dir(rm))
  # STOP()
  # print(rmup[0,0,0])
  amap0  = asymmetric_map(xrs.space_group().type(), rm)
  # print(dir(amap0))
  mmm = amap0.data().as_1d().min_max_mean()
  print (mmm.min, mmm.max, mmm.mean)
  amap_data = amap0.data()
  write_ccp4_map('amap.ccp4', xrs.unit_cell(), xrs.space_group(), amap_data)
  write_ccp4_map('rm.ccp4', xrs.unit_cell(), xrs.space_group(), rm)
  # for i in range(50):
  #   print(i, amap_data[i,0,0])
  exp_map = amap0.symmetry_expanded_map()
  print(exp_map[0,0,0])
  # for i in range(32):
  #   for j in range(32):
  #     for k in range(32):
  #       assert approx_equal(rm[i,j,k], exp_map[i,j,k])

  # print(dir(amap0))
  # STOP()
  # This produces 2 separate blobs
  sg = xrs.space_group()
  print (dir(sg))
  print (sg.all_ops())
  print (sg.info())
  print ("amap0 size:", amap0.data().accessor().focus())
  # STOP()
  print (type(amap0.data()))
  threshold = 0.
  preprocess_against_shallow = True
  print ('threshold:', threshold)
  print ('preprocess_against_shallow', preprocess_against_shallow)
  t0 = time()
  co_amap = maptbx.connectivity(
      map_data=amap0.data(),
      # threshold=threshold,
      # space_group=xrs.space_group(),
      # uc_dimensions=exp_map.accessor().focus(),
      # wrapping=False,
      preprocess_against_shallow=preprocess_against_shallow)
  t1 = time()
  print ('amap time:', t1-t0)
  original_regions = list(co_amap.regions())
  print ('start regions:', original_regions)
  print ('max coords', list(co_amap.maximum_coors()))
  print ('max vals', list(co_amap.maximum_values()))

  # print(dir(exp_map))
  print(type(exp_map))
  print ("exp_map size:", exp_map.accessor().focus())
  t0 = time()
  co_full = maptbx.connectivity(
      map_data=rm,
      threshold=threshold,
      wrapping=False,
      preprocess_against_shallow=preprocess_against_shallow)
  t1 = time()
  print ('full time:', t1-t0)

  original_regions = list(co_full.regions())
  print ('start regions:', original_regions)
  print ('max coords', list(co_full.maximum_coors()))
  print ('max vals', list(co_full.maximum_values()))



  # STOP()
  # co.experiment_with_symmetry(
  #     space_group=xrs.space_group(),
  #     uc_dims=exp_map.accessor().focus())


  co_full.merge_symmetry_related_regions(
      space_group=xrs.space_group(),
      uc_dims=exp_map.accessor().focus())
  new_regions = list(co_full.regions())
  print ('new regions:', new_regions)
  print ('max coords', list(co_full.maximum_coors()))
  print ('max vals', list(co_full.maximum_values()))

if __name__ == "__main__":
  t0 = time.time()
  exercise1()  # examples of usage are here!
  exercise3()
  exercise4()
  exercise41()
  exercise5()
  exercise6()
  exercise_volume_cutoff()
  exercise_max_values()
  exercise_noise_elimination_two_cutoffs() # example and comment
  exercise_get_blobs_boundaries()
  exercise_expand_mask()
  exercise_wrapping()
  exercise_preprocess_against_shallow()
  exercise_symmetry_related_regions()
  # exercise_work_in_asu()
  print("OK time =%8.3f"%(time.time() - t0))


 *******************************************************************************


 *******************************************************************************
cctbx/regression/tst_connectivity_allsym.py
from __future__ import absolute_import, division, print_function

from cctbx.development import random_structure
from cctbx.sgtbx import space_group_info
import boost_adaptbx.boost.python as bp
from six.moves import range
asu_map_ext = bp.import_ext("cctbx_asymmetric_map_ext")
from cctbx_asymmetric_map_ext import *
from cctbx.array_family import flex
from cctbx import maptbx
import mmtbx.masks
import random

if (1):
  random.seed(0)
  flex.set_random_seed(0)

def run_group(symbol, preprocess_against_shallow):
  group = space_group_info(symbol)
  print("\n== space group %d"%symbol)
  xrs = random_structure.xray_structure(
    space_group_info       = group,
    volume_per_atom        = 15.,
    general_positions_only = False,
    elements               = ('C', 'N', 'O', 'H')*31,
    min_distance           = 1.0)
  sgt = xrs.space_group().type()
  #
  cg = maptbx.crystal_gridding(
    unit_cell        = xrs.unit_cell(),
    space_group_info = xrs.space_group_info(),
    symmetry_flags   = maptbx.use_space_group_symmetry,
    step             = 0.4)
  n_real = cg.n_real()
  mask_p1 = mmtbx.masks.mask_from_xray_structure(
    xray_structure        = xrs,
    p1                    = True,
    for_structure_factors = True,
    n_real                = n_real,
    in_asu                = False).mask_data
  maptbx.unpad_in_place(map=mask_p1)
  assert flex.min(mask_p1)==0
  assert flex.max(mask_p1)==1
  #
  co = maptbx.connectivity(
    map_data                   = mask_p1,
    threshold                  = 0.01,
    preprocess_against_shallow = preprocess_against_shallow,
    wrapping                   = True)
  #
  print("Regions in P1")
  regions_p1 = list(co.regions())
  s1 = flex.sum(flex.int(regions_p1))
  print(regions_p1, s1)
  conn_map_p1 = co.result().as_double()
  print(flex.min(conn_map_p1), flex.max(conn_map_p1))
  #
  print("Merge symmetry related")
  co.merge_symmetry_related_regions(space_group = xrs.space_group())
  conn_map_p1_merged = co.result().as_double()
  regions_p1_merged = list(co.regions())
  s2 = flex.sum(flex.int(regions_p1_merged))
  print(list(regions_p1_merged), s2)
  amap = asu_map_ext.asymmetric_map(sgt, conn_map_p1_merged)
  conn_map_asu = amap.data()
  conn_map_p1_restored = amap.symmetry_expanded_map()
  print(flex.min(conn_map_asu), flex.max(conn_map_asu))

  #
  mask_p1_1 = conn_map_p1_restored.set_selected(conn_map_p1_restored>0.01, 1)
  maptbx.unpad_in_place(map=mask_p1_1)
  co = maptbx.connectivity(
    map_data                   = mask_p1_1,
    threshold                  = 0.01,
    preprocess_against_shallow = preprocess_against_shallow,
    wrapping                   = True)
  print("Restored")
  regions_p1_restored = list(co.regions())
  s3 = flex.sum(flex.int(regions_p1_restored))
  print(regions_p1_restored, s3)
  conn_map_p1_restored = co.result().as_double()
  print(flex.min(conn_map_p1_restored), flex.max(conn_map_p1_restored))
  assert regions_p1 == regions_p1_restored
  #
  assert s1 == s2
  assert s2 == s3

def run(preprocess_against_shallow):
  for i in range(1,231):
    run_group(i,preprocess_against_shallow);

if (__name__ == "__main__"):
  for ppas in [True, False]:
    run(preprocess_against_shallow = ppas)


 *******************************************************************************


 *******************************************************************************
cctbx/regression/tst_coordination_sequences.py
from __future__ import absolute_import, division, print_function
from iotbx.kriber import strudat
from cctbx import crystal
import cctbx.crystal.coordination_sequences
from iotbx.option_parser import iotbx_option_parser
import libtbx.load_env
import sys, os
from six.moves import zip

def exercise_simple(structure, distance_cutoff, max_shell, verbose):
  asu_mappings = structure.asu_mappings(
    buffer_thickness=distance_cutoff)
  pair_asu_table = cctbx.crystal.pair_asu_table(
    asu_mappings=asu_mappings)
  pair_asu_table.add_all_pairs(
    distance_cutoff=distance_cutoff)
  term_table_slow = crystal.coordination_sequences.simple_and_slow(
    pair_asu_table=pair_asu_table,
    max_shell=max_shell)
  term_table_simple_asu = cctbx.crystal.coordination_sequences.simple(
    pair_asu_table=pair_asu_table,
    max_shell=max_shell)
  site_symmetry_table = structure.site_symmetry_table()
  full_pair_sym_table = pair_asu_table.extract_pair_sym_table() \
    .full_connectivity(site_symmetry_table=site_symmetry_table)
  term_table_simple_sym = cctbx.crystal.coordination_sequences.simple_sym(
    full_pair_sym_table=full_pair_sym_table,
    site_symmetry_table=site_symmetry_table,
    max_shell=max_shell)
  if (verbose):
    print("term_table_slow:")
    cctbx.crystal.coordination_sequences.show_terms(
      structure=structure,
      term_table=term_table_slow)
    print()
    print("term_table_simple_asu:")
    cctbx.crystal.coordination_sequences.show_terms(
      structure=structure,
      term_table=term_table_simple_asu)
    print()
    print("term_table_simple_sym:")
    cctbx.crystal.coordination_sequences.show_terms(
      structure=structure,
      term_table=term_table_simple_sym)
    print()
  for term_table_simple in [term_table_simple_asu, term_table_simple_sym]:
    for terms_slow,terms_simple in zip(term_table_slow, term_table_simple):
      assert terms_slow == list(terms_simple)

def exercise_shell_asu_tables(structure, verbose):
  asu_mappings = structure.asu_mappings(buffer_thickness=10)
  bond_asu_table = crystal.pair_asu_table(asu_mappings=asu_mappings)
  bond_asu_table.add_all_pairs(distance_cutoff=3.5)
  shell_asu_tables = crystal.coordination_sequences.shell_asu_tables(
    pair_asu_table=bond_asu_table,
    max_shell=3)
  site_symmetry_table = structure.site_symmetry_table()
  full_pair_sym_table = bond_asu_table.extract_pair_sym_table() \
    .full_connectivity(site_symmetry_table=site_symmetry_table)
  shell_sym_tables_orig = crystal.coordination_sequences.shell_sym_tables(
    full_pair_sym_table=full_pair_sym_table,
    site_symmetry_table=site_symmetry_table,
    max_shell=3)
  shell_sym_tables = [_.tidy(site_symmetry_table=site_symmetry_table)
    for _ in shell_sym_tables_orig]
  have_redundancies = False
  for o_pst,t_pst in zip(shell_sym_tables_orig[1:], shell_sym_tables[1:]):
    for o_pair_sym_dict,t_pair_sym_dict in zip(o_pst, t_pst):
      assert list(o_pair_sym_dict.keys()) == list(t_pair_sym_dict.keys())
      if (verbose and not have_redundancies):
        for j_seq,o_sym_ops in o_pair_sym_dict.items():
          t_sym_ops = t_pair_sym_dict[j_seq]
          if (len(t_sym_ops) != len(o_sym_ops)):
            have_redundancies = True
  if (have_redundancies):
    print("crystal.coordination_sequences.shell_sym_tables redundancies:")
    print("original:")
    o_pst.show()
    print()
    print("tidy:")
    t_pst.show()
    print()
  for shell_asu_table,shell_sym_table in zip(
        shell_asu_tables, shell_sym_tables):
    if (0 or verbose):
      pairs_1 = structure.show_distances(pair_asu_table=shell_asu_table) \
        .distances_info
      print(list(pairs_1.pair_counts))
      assert pairs_1.pair_counts == shell_asu_table.pair_counts()
      print()
    sym_table = shell_asu_table.extract_pair_sym_table(
      skip_j_seq_less_than_i_seq=False)
    asu_table = crystal.pair_asu_table(asu_mappings=asu_mappings)
    asu_table.add_pair_sym_table(sym_table=sym_table)
    if (0 or verbose):
      pairs_2 = structure.show_distances(pair_asu_table=asu_table) \
        .distances_info
      print(list(pairs_2.pair_counts))
      assert pairs_2.pair_counts == asu_table.pair_counts()
      print()
      assert pairs_1.pair_counts.all_eq(pairs_2.pair_counts)
    assert asu_table == shell_asu_table
    shell_sym_from_asu_table = shell_asu_table.extract_pair_sym_table() \
      .tidy(site_symmetry_table=site_symmetry_table)
    from six.moves import cStringIO as StringIO
    sio_sym = StringIO()
    shell_sym_table.show(f=sio_sym)
    sio_asu = StringIO()
    shell_sym_from_asu_table.show(f=sio_asu)
    from libtbx.test_utils import show_diff
    assert not show_diff(sio_sym.getvalue(), sio_asu.getvalue())

def exercise(args, distance_cutoff=3.5, max_shell=5):
  command_line = (iotbx_option_parser()
    .option(None, "--tag",
      action="store",
      type="string")
    .option(None, "--full",
      action="store_true")
    .option(None, "--verbose",
      action="store_true")
  ).process(args=args)
  co = command_line.options
  atlas_file = libtbx.env.find_in_repositories(
    relative_path="phenix_regression/misc/strudat_zeolite_atlas",
    test=os.path.isfile)
  if (atlas_file is None):
    print("Skipping exercise(): input file not available")
    return
  with open(atlas_file) as f:
    all_entries = strudat.read_all_entries(f)
  for i,entry in enumerate(all_entries.entries):
    structure = entry.as_xray_structure()
    if (co.tag is not None):
      if (co.tag != entry.tag):
        continue
    elif (not (co.full or i % 20 == 0)):
      continue
    if (co.verbose):
      print("strudat tag:", entry.tag)
    exercise_simple(
      structure, distance_cutoff, max_shell, co.verbose)
    exercise_shell_asu_tables(structure, co.verbose)

def run():
  exercise(sys.argv[1:])
  print("OK")

if (__name__ == "__main__"):
  run()


 *******************************************************************************


 *******************************************************************************
cctbx/regression/tst_create_models_or_maps.py
from __future__ import absolute_import, division, print_function
from iotbx.map_model_manager import map_model_manager
from cctbx.development.create_models_or_maps import *
from libtbx.test_utils import approx_equal
from scitbx.array_family import flex
import random

def tst_01():

  print (" test utilities in create_models_or_maps")
  flex.set_random_seed(0)
  random.seed(0)

  model=generate_model()
  assert approx_equal (
    model.get_sites_cart()[0],
    (14.476, 10.57, 8.342))

  s_model=shake_model(model,shake=2)
  assert approx_equal (
    s_model.get_sites_cart()[0],
    (14.162085804614943, 11.403509966523153, 6.450881839681677))
  map_coeffs=generate_map_coefficients(model=model)
  assert approx_equal(map_coeffs.data()[0],
     (3.70494534745-0.185333495539j))
  map_manager=generate_map(map_coeffs=map_coeffs)

  mm_2= generate_map(map_coeffs=map_coeffs,
      d_min=3.5,
      gridding=map_manager.map_data().all(),
      wrapping=True,
      origin_shift_grid_units=(100,0,0),
      low_resolution_fourier_noise_fraction=1,
      high_resolution_fourier_noise_fraction=1,
      low_resolution_real_space_noise_fraction=1,
      high_resolution_real_space_noise_fraction=1,
      )
  assert approx_equal (mm_2.map_data()[323], -0.0784650534896)
  mm_2.shift_origin()
  model.set_shift_cart(mm_2.shift_cart())
  mam=map_model_manager(map_manager=mm_2,model=model)
  mam.write_map('map.mrc')
  mam.write_model('model.pdb')

  new_mam=read_map_and_model('map.mrc','model.pdb')
  new_mam_2=read_map_and_model('model.pdb','map.mrc')
  assert new_mam.map_manager().cc_to_other_map_manager(new_mam_2.map_manager())==1




if (__name__ == "__main__"):
  import libtbx.load_env
  if libtbx.env.find_in_repositories(relative_path="chem_data") is None:
    print("Skipping exercise(): chem_data directory not available")
  else:
    tst_01()
  print ("OK")


 *******************************************************************************


 *******************************************************************************
cctbx/regression/tst_crystal.py
from __future__ import absolute_import, division, print_function
from cctbx import crystal
from cctbx import sgtbx
from cctbx import uctbx
from cctbx.development import random_structure
from cctbx.development import debug_utils
from cctbx.array_family import flex
from scitbx import matrix
from libtbx.test_utils import Exception_expected, approx_equal, show_diff
from libtbx.utils import Sorry
from six.moves import cStringIO as StringIO
import sys
from six.moves import range

def exercise_similarity():
  xs = crystal.symmetry((3,4,5), "P 2 2 2")
  assert xs.is_similar_symmetry(crystal.symmetry((3,4,5), "P 2 2 2"))
  assert xs.is_similar_symmetry(crystal.symmetry((3.001,4,5), "P 2 2 2"))
  assert not xs.is_similar_symmetry(crystal.symmetry((3.3,4,5), "P 2 2 2"))
  assert not xs.is_similar_symmetry(crystal.symmetry((3,4,5), "P 2"))

  assert xs.is_identical_symmetry(crystal.symmetry((3,4,5), "P 2 2 2"))
  assert not xs.is_identical_symmetry(crystal.symmetry((3.001,4,5), "P 2 2 2"))
  assert not xs.is_identical_symmetry(crystal.symmetry((3.3,4,5), "P 2 2 2"))
  assert not xs.is_identical_symmetry(crystal.symmetry((3,4,5), "P 2"))

  xs = crystal.symmetry((5,5,29,90,90,120), "R 3")
  ps = xs.primitive_setting()
  rs = ps.as_reference_setting()
  assert xs.is_similar_symmetry(rs)
  assert not xs.is_identical_symmetry(rs)


def exercise_symmetry():
  xs = crystal.symmetry()
  xs = crystal.symmetry(uctbx.unit_cell((3,4,5)))
  xs = crystal.symmetry((3,4,5), "P 2 2 2")
  xs = crystal.symmetry("3,4,5", "P 2 2 2")
  xs = crystal.symmetry([4,5,6], space_group_info=xs.space_group_info())
  xs = crystal.symmetry([4,5,6], space_group=xs.space_group())
  xs = crystal.symmetry([4,5,6], space_group=str(xs.space_group_info()))
  assert str(xs.unit_cell()) == "(4, 5, 6, 90, 90, 90)"
  assert xs.unit_cell().is_similar_to(uctbx.unit_cell((4,5,6)))
  assert str(xs.space_group_info()) == "P 2 2 2"
  assert str(xs.space_group_number()) == "16"
  assert str(xs.space_group().info().type().number()) == "16"
  assert xs.space_group() == xs.space_group_info().group()
  assert xs.is_compatible_unit_cell()
  try: xs = crystal.symmetry((3,4,5), "P 4 2 2")
  except Exception: pass
  else: raise Exception_expected
  try:
    xs = crystal.symmetry((3,4,5), "P 4 2 2",
      raise_sorry_if_incompatible_unit_cell=True)
  except Sorry: pass
  else: raise Exception_expected
  xs = crystal.symmetry(
    (3,4,5), "P 4 2 2", assert_is_compatible_unit_cell=False,
    force_compatible_unit_cell=False)
  assert not xs.is_compatible_unit_cell()
  xs = crystal.symmetry(
    (3,4,5), "P 4 2 2", assert_is_compatible_unit_cell=False)
  assert xs.is_compatible_unit_cell()
  xs = crystal.symmetry((5,5,29,90,90,120), "R 3")
  ps = xs.primitive_setting()
  assert ps.unit_cell().is_similar_to(
    uctbx.unit_cell((10.0885, 10.0885, 10.0885, 28.6956, 28.6956, 28.6956)))
  assert str(ps.space_group_info()) == "R 3 :R"
  rs = ps.as_reference_setting()
  assert rs.unit_cell().is_similar_to(xs.unit_cell())
  assert str(rs.space_group_info()) == "R 3 :H"
  cb = xs.change_of_basis_op_to_minimum_cell()
  mc = xs.minimum_cell()
  cm = mc.change_basis(cb.inverse())
  assert cm.unit_cell().is_similar_to(xs.unit_cell())
  assert cm.space_group() == xs.space_group()
  cb = xs.change_of_basis_op_to_niggli_cell()
  assert str(cb.c()) == "y-z,-x-z,3*z"
  nc = xs.niggli_cell()
  assert nc.unit_cell().is_similar_to(
    uctbx.unit_cell((5, 5, 10.0885, 75.6522, 75.6522, 60)))
  assert str(nc.space_group_info()) == "R 3 :H (x+z,-y+z,-3*z)"
  assert nc.unit_cell().is_niggli_cell()
  cn = nc.change_basis(cb.inverse())
  assert cn.unit_cell().is_similar_to(xs.unit_cell())
  assert cn.space_group() == xs.space_group()
  xs = crystal.symmetry((3,3,4,90,90,120), "P 31")
  ih = xs.inverse_hand()
  assert ih.unit_cell().is_similar_to(xs.unit_cell())
  assert str(ih.space_group_info()) == "P 32"
  xs = crystal.symmetry((5,3,4), "P 2 2 2")
  p1 = xs.cell_equivalent_p1()
  assert p1.unit_cell().is_similar_to(uctbx.unit_cell((5,3,4)))
  assert p1.space_group().order_z() == 1
  ri = xs.reflection_intensity_symmetry(anomalous_flag=True)
  assert ri.unit_cell().is_similar_to(xs.unit_cell())
  assert str(ri.space_group_info()) == "P 2 2 2"
  ri = xs.reflection_intensity_symmetry(anomalous_flag=False)
  assert ri.unit_cell().is_similar_to(xs.unit_cell())
  assert str(ri.space_group_info()) == "P m m m"
  ps = xs.patterson_symmetry()
  assert ps.unit_cell().is_similar_to(xs.unit_cell())
  assert str(ps.space_group_info()) == "P m m m"
  bc = ps.best_cell()
  assert bc.unit_cell().is_similar_to(uctbx.unit_cell((3,4,5)))
  assert str(bc.space_group_info()) == "P m m m"
  xs = crystal.symmetry((5,3,4,90,130,90), "P 1 2 1")
  bc = xs.best_cell()
  assert bc.unit_cell().is_similar_to(
    uctbx.unit_cell((3.91005,3,4,90,101.598,90)))
  assert str(bc.space_group_info()) == "P 1 2 1"
  cb = xs.change_of_basis_op_to_best_cell()
  assert str(cb.c()) in ["x,-y,x-z", "-x,-y,-x+z"]
  assert bc.change_basis("x,-y,x-z").unit_cell().is_similar_to(
         bc.change_basis("-x,-y,-x+z").unit_cell())
  asu = xs.direct_space_asu()
  assert asu.hall_symbol == " P 2y"
  assert len(asu.cuts) == 6
  assert asu.unit_cell is xs.unit_cell()
  asu_mappings = xs.asu_mappings(buffer_thickness=2.364)
  assert approx_equal(asu_mappings.buffer_thickness(), 2.364)
  assert approx_equal(xs.average_b_cart((1,2,3,4,5,6)), (1,2,3,0,5,0))
  #
  s = crystal.symmetry(
    unit_cell=(10,20,30,90,90,80),
    space_group_symbol="A 1 1 2")
  assert approx_equal(
    s.subtract_continuous_allowed_origin_shifts(translation_cart=[1,2,3]),
    [1,2,0])
  #
  for anomalous_flag in [False, True]:
    m = s.build_miller_set(
      anomalous_flag=anomalous_flag, d_min=8.1, d_max=8.5)
    assert m.anomalous_flag() == anomalous_flag
    if (not anomalous_flag):
      assert list(m.indices()) == [(1,0,2), (0,2,2)]
    else:
      assert list(m.indices()) == [(1,0,2), (-1,0,-2), (0,2,2), (0,-2,-2)]

def exercise_correct_rhombohedral_setting_if_necessary():
  for symbol in sgtbx.rhombohedral_hermann_mauguin_symbols:
    for p,z in [("20 20 21 90 90 120", "R"), ("31 31 31 85 85 85", "H")]:
      uc = uctbx.unit_cell(p)
      cs = crystal.symmetry(
        unit_cell=uc,
        space_group_symbol=symbol+":"+z,
        correct_rhombohedral_setting_if_necessary=True)
      assert cs.unit_cell().is_similar_to(uc)
      other_z = {
        "R": "H",
        "H": "R"}[z]
      assert not show_diff(
        cs.space_group_info().type().lookup_symbol(),
        symbol+" :"+other_z)
  cs = crystal.symmetry(
    unit_cell="20 20 21 90 89 120",
    space_group_symbol="R3:R",
    correct_rhombohedral_setting_if_necessary=True,
    assert_is_compatible_unit_cell=False)
  sio = StringIO()
  cs.show_summary(f=sio)
  assert not show_diff(sio.getvalue(), """\
Unit cell: (20.3388, 20.3388, 20.3388, 98.9315, 98.9315, 98.9315)
Space group: R 3 :R (No. 146)
""")
  assert not show_diff(sio.getvalue().rstrip(), str(cs))
  cs = crystal.symmetry(
    unit_cell="31 31 31 85 85 86",
    space_group_symbol="R3:H",
    correct_rhombohedral_setting_if_necessary=True,
    assert_is_compatible_unit_cell=False)
  sio = StringIO()
  cs.show_summary(f=sio)
  assert not show_diff(sio.getvalue(), """\
Unit cell: (36.4146, 36.4146, 31, 90, 90, 120)
Space group: R 3 :H (No. 146)
""")
  assert not show_diff(sio.getvalue().rstrip(), str(cs))

def exercise_select_crystal_symmetry():
  xs1 = crystal.symmetry(unit_cell   = "23,30,40,90,90,90",
                         space_group = "P212121" )
  xs2 = crystal.symmetry(unit_cell   = "20,30,40,90,90,90",
                         space_group = "P222" )
  resulting_symmetry = crystal.select_crystal_symmetry( from_command_line     = None,
                                                        from_parameter_file   = None,
                                                        from_coordinate_files = [xs1],
                                                        from_reflection_files = [xs2] )
  assert list( xs2.unit_cell().parameters()  ) == list( resulting_symmetry.unit_cell().parameters() )
  resulting_symmetry = crystal.select_crystal_symmetry( from_command_line     = None,
                                                        from_parameter_file   = None,
                                                        from_coordinate_files = [xs2],
                                                        from_reflection_files = [xs1] )
  assert list( xs1.unit_cell().parameters()  ) == list( resulting_symmetry.unit_cell().parameters() )

  resulting_symmetry = None
  try:
    resulting_symmetry = crystal.select_crystal_symmetry( from_command_line     = None,
                                                          from_parameter_file   = None,
                                                          from_coordinate_files = [None],
                                                          from_reflection_files = [None] )
  except AssertionError as e :
    assert str(e)=="No unit cell and symmetry information supplied"
  else: raise Exception_expected

def verify_definitions_in_paper_zwart_2007():
  # Verification of definitions in Peter Zwart's paper for the
  # CCP4 Study Weekend Jan 2007.
  #
  cb_symbol_xyz = "x-y,x+y,z"
  cb_symbol_abc = "1/2*a-1/2*b,1/2*a+1/2*b,c"
  #
  # Verify the claim that cb_symbol_abc is the inverse transpose of
  # cb_symbol_xyz.
  cb_mx_xyz = sgtbx.rt_mx(cb_symbol_xyz, r_den=12, t_den=144)
  assert sgtbx.rt_mx(cb_mx_xyz.r().inverse().transpose()).as_xyz(
    symbol_letters="abc") == cb_symbol_abc
  #
  uhmx = "C 1 2 1 (%s)" % cb_symbol_xyz
  uhma = "C 1 2 1 (%s)" % cb_symbol_abc
  sx = sgtbx.space_group_info(symbol=uhmx)
  sa = sgtbx.space_group_info(symbol=uhma)
  assert sx.group() == sa.group()
  #
  # We trust that the cctbx is self-consistent.
  structure_unconv = random_structure.xray_structure(
    space_group_info=sx,
    elements=["C"],
    volume_per_atom=100,
    general_positions_only=True)
  assert str(structure_unconv.space_group_info()) == uhmx
  cb_op = structure_unconv.change_of_basis_op_to_reference_setting()
  structure_reference = structure_unconv.change_basis(cb_op=cb_op)
  assert str(structure_reference.space_group_info()) == "C 1 2 1"
  #
  # Verify the definitions in the paper based on the assumption
  # that the cctbx is self-consistent.
  site_reference = structure_reference.scatterers()[0].site
  site_unconv_direct = cb_mx_xyz * site_reference
  assert approx_equal(
    site_unconv_direct, structure_unconv.scatterers()[0].site)

def exercise_non_crystallographic_symmetry():
  sites_cart = flex.vec3_double(
    [(0.28730079491792732, 0.14711550696452974, 0.13031757579425293),
     (0.26144164573900441, 0.26385801128667269, 0.24113874888074088),
     (0.19728759424697784, 0.93346148983888833, 0.91783953828686837)])
  n = crystal.non_crystallographic_symmetry(sites_cart=sites_cart)
  assert approx_equal(n.unit_cell().parameters(),
    (1.6650571, 2.3613899, 2.36256589, 90, 90, 90))
  assert n.space_group_info().type().number() == 1
  n = crystal.non_crystallographic_symmetry(
    sites_cart=sites_cart, min_unit_cell_length=2)
  assert approx_equal(n.unit_cell().parameters(),
    (2, 2.3613899, 2.36256589, 90, 90, 90))
  sites_cart = flex.vec3_double(
    [(0.28730079491792732, 0.14711550696452974, 0.13031757579425293)])
  n = crystal.non_crystallographic_symmetry(sites_cart=sites_cart)
  assert approx_equal(n.unit_cell().parameters(), (1, 1, 1, 90, 90, 90))
  n = crystal.non_crystallographic_symmetry(
    sites_cart=sites_cart, default_buffer_layer=1.5)
  assert approx_equal(n.unit_cell().parameters(), (3, 3, 3, 90, 90, 90))

def exercise_special_position_settings():
  xs = crystal.symmetry((3,4,5), "P 2 2 2")
  sp = crystal.special_position_settings(xs, 1, 2, False)
  assert sp.min_distance_sym_equiv() == 1
  assert sp.u_star_tolerance() == 2
  assert sp.assert_min_distance_sym_equiv() == False
  assert sp.site_symmetry((0,0,0)).multiplicity() == 1
  assert sp.site_symmetry(site=(0,0,0)).multiplicity() == 1
  assert sp.site_symmetry(site_cart=(0,0,0)).multiplicity() == 1
  assert str(sp.sym_equiv_sites((0,0,0)).special_op()) == "0,0,0"
  sites_cart = flex.vec3_double([(2,1,3), (0,0,0)])
  t = sp.site_symmetry_table(sites_cart=sites_cart)
  assert list(t.special_position_indices()) == [1]
  assert approx_equal(
    t.apply_symmetry_sites(unit_cell=xs.unit_cell(), sites_cart=sites_cart),
    sites_cart)
  #
  for min_distance_sym_equiv,special_op in [(1e-6, "0,0,0"), (0, "x,y,z")]:
    sp = crystal.special_position_settings(
      crystal_symmetry=xs,
      min_distance_sym_equiv=min_distance_sym_equiv)
    assert str(sp.sym_equiv_sites((0,0,0)).special_op()) == special_op
  #
  sites_cart = flex.vec3_double([(0,0,0)])
  sp = xs.special_position_settings()
  asu_mappings = sp.asu_mappings(buffer_thickness=3, sites_cart=sites_cart)
  assert list(asu_mappings.site_symmetry_table().special_position_indices()) \
      == [0]
  #
  pair_generator = sp.pair_generator(distance_cutoff=1, sites_cart=sites_cart)
  assert pair_generator.count_pairs() == 0
  sp0 = xs.special_position_settings(min_distance_sym_equiv=0)
  pair_generator = sp0.pair_generator(distance_cutoff=1, sites_cart=sites_cart)
  assert pair_generator.count_pairs() == 3
  #
  pair_asu_table = sp.pair_asu_table(distance_cutoff=1, sites_cart=sites_cart)
  assert pair_asu_table.table()[0].size() == 0
  pair_asu_table = sp0.pair_asu_table(distance_cutoff=1, sites_cart=sites_cart)
  assert pair_asu_table.table()[0][0].size() == 3

def exercise_site_symmetry(space_group_info):
  special_position_settings = crystal.special_position_settings(
    crystal_symmetry=space_group_info.any_compatible_crystal_symmetry(
      volume=1000))
  z2p_op = space_group_info.group().z2p_op()
  special_position_settings_p = crystal.special_position_settings(
    crystal_symmetry=special_position_settings.change_basis(z2p_op),
    min_distance_sym_equiv
      =special_position_settings.min_distance_sym_equiv()*0.99)
  wyckoff_table = space_group_info.wyckoff_table()
  for i_position in range(wyckoff_table.size()):
    site_symmetry = wyckoff_table.random_site_symmetry(
      special_position_settings=special_position_settings,
      i_position=i_position)
    s = site_symmetry.special_op()
    assert s.multiply(s) == s
    for m in site_symmetry.matrices():
      assert m.multiply(s) == s
    tab = sgtbx.site_symmetry_table()
    tab.process(site_symmetry)
    ss_ops = tab.get(0)
    assert ss_ops.multiplicity() == site_symmetry.multiplicity()
    assert ss_ops.multiplicity() * ss_ops.n_matrices() \
        == site_symmetry.space_group().order_z()
    site_p = z2p_op.c() * site_symmetry.exact_site()
    site_symmetry_p = special_position_settings_p.site_symmetry(site_p)
    ss_ops_p = ss_ops.change_basis(z2p_op)
    assert ss_ops_p.multiplicity() == site_symmetry_p.multiplicity()
    assert ss_ops_p.special_op() == site_symmetry_p.special_op()
    assert ss_ops_p.multiplicity() * ss_ops_p.n_matrices() \
        == site_symmetry_p.space_group().order_z()
    references = [str(m) for m in site_symmetry_p.matrices()]
    testees = [str(m) for m in ss_ops_p.matrices()]
    references.sort()
    testees.sort()
    assert " ".join(testees) == " ".join(references)

def exercise_subtract_continuous_allowed_origin_shifts(
      space_group_info,
      use_niggli_cell,
      n_elements=3):
  structure = random_structure.xray_structure(
    space_group_info,
    elements=["Si"]*n_elements,
    volume_per_atom=300,
    min_distance=3.,
    general_positions_only=False)
  if (use_niggli_cell):
    structure = structure.niggli_cell()
  f_obs = abs(structure.structure_factors(
    d_min=3, algorithm="direct").f_calc())
  assert f_obs.indices().size() >= 10
  transl = matrix.col(flex.random_double_point_on_sphere()) * 2.345
  transl_no_cont = matrix.col(
    structure.subtract_continuous_allowed_origin_shifts(
      translation_cart=transl))
  transl_cont = transl - transl_no_cont
  structure_transl = structure.apply_shift(
    shift=structure.unit_cell().fractionalize(transl_cont),
    recompute_site_symmetries=True)
  f_transl = abs(f_obs.structure_factors_from_scatterers(
    xray_structure=structure_transl, algorithm="direct").f_calc())
  assert approx_equal(f_transl.data(), f_obs.data())


def exercise_str_repr():
  sgi = sgtbx.space_group_info('P1')
  uc = sgi.any_compatible_unit_cell(volume=1000)
  cs = crystal.symmetry(unit_cell=None, space_group=None)
  assert eval(repr(cs)).is_similar_symmetry(cs)
  assert not show_diff(str(cs), """\
Unit cell: None
Space group: None""")
  cs = crystal.symmetry(unit_cell=uc, space_group=None)
  assert eval(repr(cs)).is_similar_symmetry(cs, 1e-8, 1e-3)
  assert not show_diff(str(cs), """\
Unit cell: (8.52593, 11.0837, 14.4941, 83, 109, 129)
Space group: None""")
  cs = crystal.symmetry(unit_cell=None, space_group=sgi.group())
  assert eval(repr(cs)).is_similar_symmetry(cs, 1e-8, 1e-3)
  assert not show_diff(str(cs), """\
Unit cell: None
Space group: P 1 (No. 1)""")
  cs = crystal.symmetry(unit_cell=uc, space_group=sgi.group())
  assert eval(repr(cs)).is_similar_symmetry(cs, 1e-8, 1e-3)
  assert not show_diff(str(cs), """\
Unit cell: (8.52593, 11.0837, 14.4941, 83, 109, 129)
Space group: P 1 (No. 1)""")


def run_call_back(flags, space_group_info):
  exercise_site_symmetry(space_group_info)
  for use_niggli_cell in [False, True]:
    exercise_subtract_continuous_allowed_origin_shifts(
      space_group_info=space_group_info,
      use_niggli_cell=use_niggli_cell)

def run():
  exercise_similarity()
  exercise_str_repr()
  exercise_symmetry()
  exercise_correct_rhombohedral_setting_if_necessary()
  exercise_non_crystallographic_symmetry()
  exercise_special_position_settings()
  exercise_select_crystal_symmetry()
  verify_definitions_in_paper_zwart_2007()
  debug_utils.parse_options_loop_space_groups(sys.argv[1:], run_call_back)

if (__name__ == "__main__"):
  run()


 *******************************************************************************


 *******************************************************************************
cctbx/regression/tst_crystal_asu_clusters.py
from __future__ import absolute_import, division, print_function
from cctbx import crystal
import cctbx.crystal.direct_space_asu
from cctbx.array_family import flex
from six.moves import range

def exercise_non_crystallographic():
  sites_cart = flex.vec3_double([
    (7.767, 5.853, 7.671),
    (6.935, 5.032, 8.622),
    (5.918, 4.176, 8.140),
    (7.161, 5.107, 10.012),
    (5.126, 3.395, 9.038),
    (6.382, 4.336, 10.930),
    (5.360, 3.476, 10.439),
    (7.956, 7.811, 6.133),
    (8.506, 7.237, 5.169),
    (8.143, 9.010, 6.428),
    (6.253, 5.840, 5.439),
    (5.364, 7.253, 5.745),
    (5.875, 6.461, 6.183),
    (5.216, 5.927, 6.782),
    (7.000, 7.000, 7.000)])
  have_one_unsorted = False
  for i_trial in range(10):
    if (i_trial > 0):
      sites_cart = sites_cart.select(
        flex.random_permutation(size=sites_cart.size()))
    asu_mappings = crystal.direct_space_asu.non_crystallographic_asu_mappings(
      sites_cart=sites_cart)
    for distance_cutoff, expected_cluster_sizes in [
          (1.0, [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]),
          (1.1, [4, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]),
          (1.5, [6, 5, 3, 1]),
          (1.6, [15])]:
      pair_asu_table = crystal.pair_asu_table(asu_mappings=asu_mappings)
      pair_asu_table.add_all_pairs(distance_cutoff=distance_cutoff)
      clusters = crystal.asu_clusters(
        pair_asu_table=pair_asu_table).sort_index_groups_by_size()
      assert [cluster.size() for cluster in clusters.index_groups] \
          == expected_cluster_sizes
      if (distance_cutoff == 1.5):
        for cluster in clusters.index_groups:
          sorted_indices = list(cluster)
          sorted_indices.sort()
          if (list(cluster) != sorted_indices):
            have_one_unsorted = True
        clusters.sort_indices_in_each_group()
        for cluster in clusters.index_groups:
          sorted_indices = list(cluster)
          sorted_indices.sort()
          assert list(cluster) == sorted_indices
  assert have_one_unsorted

def exercise_crystallographic():
  crystal_symmetry = crystal.symmetry(
    unit_cell=(10, 10, 10, 90, 90, 90),
    space_group_symbol="P 1 1 2")
  sites_frac = flex.vec3_double([
    (0.1, 0.1, 0.0),
    (0.9, 0.1, 0.0)])
  for distance_cutoff in [1,2]:
    pair_asu_table = \
      crystal_symmetry.special_position_settings().pair_asu_table(
        distance_cutoff=distance_cutoff,
        sites_frac=sites_frac)
    for strictly_in_asu in [True, False]:
      cluster = crystal.asu_clusters(
        pair_asu_table=pair_asu_table,
        strictly_in_asu=strictly_in_asu).sort_index_groups_by_size()
      cluster_sizes = [cluster.size() for cluster in cluster.index_groups]
      if (distance_cutoff == 1 or strictly_in_asu):
        assert cluster_sizes == [1, 1]
      else:
        assert cluster_sizes == [2]
  sites_frac = flex.vec3_double([
    (0.1, 0.1, 0.0),
    (0.2, 0.2, 0.0),
    (0.1, 0.3, 0.0),
    (0.9, 0.1, 0.0),
    (0.8, 0.2, 0.0)])
  for i_trial in range(10):
    if (i_trial > 0):
      sites_frac = sites_frac.select(
        flex.random_permutation(size=sites_frac.size()))
    for distance_cutoff in [1.5,2]:
      asu_mappings = crystal_symmetry.asu_mappings(
        buffer_thickness=distance_cutoff).process_sites_frac(
          original_sites=sites_frac)
      pair_asu_table = crystal.pair_asu_table(
        asu_mappings=asu_mappings).add_all_pairs(
          distance_cutoff=distance_cutoff)
      for strictly_in_asu in [True, False]:
        cluster = crystal.asu_clusters(
          pair_asu_table=pair_asu_table,
          strictly_in_asu=strictly_in_asu).sort_index_groups_by_size()
        cluster_sizes = [cluster.size() for cluster in cluster.index_groups]
        if (distance_cutoff == 1.5 or strictly_in_asu):
          assert cluster_sizes == [3, 2]
        else:
          assert cluster_sizes == [5]

def exercise():
  exercise_non_crystallographic()
  exercise_crystallographic()
  print("OK")

if (__name__ == "__main__"):
  exercise()


 *******************************************************************************


 *******************************************************************************
cctbx/regression/tst_crystal_close_packing.py
from __future__ import absolute_import, division, print_function
from iotbx.pdb.tst_pdb import dump_pdb
from cctbx.crystal import close_packing
from cctbx import crystal
from cctbx.crystal.direct_space_asu import non_crystallographic_asu_mappings
from cctbx import sgtbx
from cctbx import uctbx
from cctbx.array_family import flex
from cctbx.development import debug_utils
from scitbx import matrix
from libtbx.math_utils import ifloor, iceil
from libtbx.test_utils import approx_equal
import time
import math
import sys
from six.moves import range
from six.moves import zip

def hexagonal_sampling_cell(point_distance):
  return uctbx.unit_cell((
    point_distance, point_distance, point_distance*math.sqrt(8/3.),
    90, 90, 120))

class hexagonal_box(object):

  def __init__(self, hex_cell, vertices_cart):
    assert len(vertices_cart) > 0
    vertices_hex = hex_cell.fractionalize(sites_cart=vertices_cart)
    self.min = vertices_hex.min()
    self.max = vertices_hex.max()
    self.pivot = vertices_hex[flex.min_index(vertices_hex.dot())]

def hex_indices_as_site(point, layer=0):
  if (layer % 2 == 0):
    if (point[2] % 2 == 0):
      return [point[0],point[1],point[2]*.5]
    else:
      return [point[0]+1/3.,point[1]+2/3.,point[2]*.5]
  else:
    if (point[2] % 2 == 0):
      return [-point[0],-point[1],point[2]*.5]
    else:
      return [-point[0]-1/3.,-point[1]-2/3.,point[2]*.5]

def hcp_fill_box(cb_op_original_to_sampling, float_asu, continuous_shift_flags,
                 point_distance,
                 buffer_thickness=-1, all_twelve_neighbors=False,
                 exercise_cpp=True):
  if (exercise_cpp):
    cpp = close_packing.hexagonal_sampling_generator(
      cb_op_original_to_sampling=cb_op_original_to_sampling,
      float_asu=float_asu,
      continuous_shift_flags=continuous_shift_flags,
      point_distance=point_distance,
      buffer_thickness=buffer_thickness,
      all_twelve_neighbors=all_twelve_neighbors)
  assert point_distance > 0
  if (buffer_thickness < 0):
    buffer_thickness = point_distance * (2/3. * (.5 * math.sqrt(3)))
  if (exercise_cpp):
    assert cpp.cb_op_original_to_sampling().c()==cb_op_original_to_sampling.c()
    assert cpp.float_asu().unit_cell().is_similar_to(float_asu.unit_cell())
    assert cpp.continuous_shift_flags() == continuous_shift_flags
    assert approx_equal(cpp.point_distance(), point_distance)
    assert approx_equal(cpp.buffer_thickness(), buffer_thickness)
    assert cpp.all_twelve_neighbors() == all_twelve_neighbors
  float_asu_buffer = float_asu.add_buffer(thickness=buffer_thickness)
  hex_cell = hexagonal_sampling_cell(point_distance=point_distance)
  hex_box = hexagonal_box(
    hex_cell=hex_cell,
    vertices_cart=float_asu.shape_vertices(cartesian=True))
  hex_box_buffer = hexagonal_box(
    hex_cell=hex_cell,
    vertices_cart=float_asu_buffer.shape_vertices(cartesian=True))
  box_lower = []
  box_upper = []
  for i in range(3):
    if (continuous_shift_flags[i]):
      box_lower.append(0)
      box_upper.append(0)
    else:
      n = iceil(abs(hex_box.max[i]-hex_box.pivot[i]))
      box_lower.append(min(-2,ifloor(hex_box_buffer.min[i]-hex_box.pivot[i])))
      box_upper.append(n+max(2,iceil(hex_box_buffer.max[i]-hex_box.max[i])))
  if (exercise_cpp):
    assert list(cpp.box_lower()) == box_lower
    assert list(cpp.box_upper()) == box_upper
  hex_to_frac_matrix = (
      matrix.sqr(float_asu.unit_cell().fractionalization_matrix())
    * matrix.sqr(hex_cell.orthogonalization_matrix()))
  sites_frac = flex.vec3_double()
  for point in flex.nested_loop(begin=box_lower,
                                end=box_upper,
                                open_range=False):
    site_hex = matrix.col(hex_box.pivot) \
             + matrix.col(hex_indices_as_site(point))
    site_frac = hex_to_frac_matrix * site_hex
    if (float_asu_buffer.is_inside(site_frac)):
      sites_frac.append(site_frac)
    elif (all_twelve_neighbors):
      for offset in [(1,0,0),(1,1,0),(0,1,0),(-1,0,0),(-1,-1,0),(0,-1,0),
                     (0,0,1),(-1,-1,1),(0,-1,1),
                     (0,0,-1),(-1,-1,-1),(0,-1,-1)]:
        offset_hex = hex_indices_as_site(offset, layer=point[2])
        offset_frac = hex_to_frac_matrix * matrix.col(offset_hex)
        other_site_frac = site_frac + offset_frac
        if (float_asu.is_inside(other_site_frac)):
          sites_frac.append(site_frac)
          break
  assert sites_frac.size() > 0
  rt = cb_op_original_to_sampling.c_inv().as_double_array()
  sites_frac = rt[:9] * sites_frac
  sites_frac += rt[9:]
  if (exercise_cpp):
    assert not cpp.at_end()
    cpp_sites_frac = cpp.all_sites_frac()
    assert cpp.at_end()
    assert cpp_sites_frac.size() == sites_frac.size()
    assert approx_equal(cpp_sites_frac, sites_frac)
    cpp.restart()
    assert not cpp.at_end()
    assert approx_equal(cpp.next_site_frac(), sites_frac[0])
    assert cpp.count_sites() == sites_frac.size()-1
    assert cpp.at_end()
    cpp.restart()
    n = 0
    for site in cpp: n += 1
    assert n == sites_frac.size()
  return sites_frac

def hexagonal_close_packing_sampling(crystal_symmetry,
                                     symmetry_flags,
                                     point_distance,
                                     buffer_thickness,
                                     all_twelve_neighbors):
  s = close_packing.setup_hexagonal_sampling(
    crystal_symmetry=crystal_symmetry,
    symmetry_flags=symmetry_flags)
  sites_frac = hcp_fill_box(
    cb_op_original_to_sampling=s.cb_op_original_to_sampling,
    float_asu=s.float_asu,
    continuous_shift_flags=s.continuous_shift_flags,
    point_distance=point_distance,
    buffer_thickness=buffer_thickness,
    all_twelve_neighbors=all_twelve_neighbors)
  return crystal_symmetry.unit_cell().orthogonalize(sites_frac=sites_frac)

def check_distances(sites_cart, point_distance, verbose):
  asu_mappings = non_crystallographic_asu_mappings(sites_cart=sites_cart)
  distance_cutoff = point_distance * math.sqrt(2) * 0.99
  simple_pair_generator = crystal.neighbors_simple_pair_generator(
    asu_mappings=asu_mappings,
    distance_cutoff=distance_cutoff)
  pair_generator = crystal.neighbors_fast_pair_generator(
    asu_mappings=asu_mappings,
    distance_cutoff=distance_cutoff)
  assert simple_pair_generator.count_pairs() == pair_generator.count_pairs()
  pair_generator.restart()
  neighbors = {}
  for pair in pair_generator:
    assert pair.j_seq != pair.i_seq
    assert pair.j_sym == 0
    assert approx_equal(pair.dist_sq, point_distance**2)
    neighbors[pair.i_seq] = neighbors.get(pair.i_seq, 0) + 1
    neighbors[pair.j_seq] = neighbors.get(pair.j_seq, 0) + 1
  n_dict = {}
  for n in neighbors.values():
    n_dict[n] = n_dict.get(n, 0) + 1
  if (verbose):
    print(n_dict)
  if (len(neighbors) > 0):
    assert max(neighbors.values()) <= 12

def check_with_grid_tags(inp_symmetry, symmetry_flags,
                         sites_cart, point_distance,
                         strictly_inside, flag_write_pdb, verbose):
  cb_op_inp_ref = inp_symmetry.change_of_basis_op_to_reference_setting()
  if (verbose):
    print("cb_op_inp_ref.c():", cb_op_inp_ref.c())
  ref_symmetry = inp_symmetry.change_basis(cb_op_inp_ref)
  search_symmetry = sgtbx.search_symmetry(
    flags=symmetry_flags,
    space_group_type=ref_symmetry.space_group_info().type(),
    seminvariant=ref_symmetry.space_group_info().structure_seminvariants())
  assert search_symmetry.continuous_shifts_are_principal()
  continuous_shift_flags = search_symmetry.continuous_shift_flags()
  if (flag_write_pdb):
    tag_sites_frac = flex.vec3_double()
  else:
    tag_sites_frac = None
  if (strictly_inside):
    inp_tags = inp_symmetry.gridding(
      step=point_distance*.7,
      symmetry_flags=symmetry_flags).tags()
    if (tag_sites_frac is not None):
      for point in flex.nested_loop(inp_tags.n_real()):
        if (inp_tags.tags().tag_array()[point] < 0):
          point_frac_inp=[float(n)/d for n,d in zip(point, inp_tags.n_real())]
          tag_sites_frac.append(point_frac_inp)
    if (inp_tags.tags().n_independent() < sites_cart.size()):
      print("FAIL:", inp_symmetry.space_group_info(), \
                     inp_tags.tags().n_independent(), sites_cart.size())
      raise AssertionError
  else:
    inp_tags = inp_symmetry.gridding(
      step=point_distance/2.,
      symmetry_flags=symmetry_flags).tags()
    sites_frac_inp = inp_symmetry.unit_cell().fractionalize(
      sites_cart=sites_cart)
    rt = cb_op_inp_ref.c().as_double_array()
    sites_frac_ref = rt[:9] * sites_frac_inp
    sites_frac_ref += rt[9:]
    max_distance = 2 * ((.5 * math.sqrt(3) * point_distance) * 2/3.)
    if (verbose):
      print("max_distance:", max_distance)
    for point in flex.nested_loop(inp_tags.n_real()):
      if (inp_tags.tags().tag_array()[point] < 0):
        point_frac_inp = [float(n)/d for n,d in zip(point, inp_tags.n_real())]
        if (tag_sites_frac is not None):
          tag_sites_frac.append(point_frac_inp)
        point_frac_ref = cb_op_inp_ref.c() * point_frac_inp
        equiv_points = sgtbx.sym_equiv_sites(
          unit_cell=ref_symmetry.unit_cell(),
          space_group=search_symmetry.subgroup(),
          original_site=point_frac_ref,
          minimum_distance=2.e-6,
          tolerance=1.e-6)
        min_dist = sgtbx.min_sym_equiv_distance_info(
          reference_sites=equiv_points,
          others=sites_frac_ref,
          principal_continuous_allowed_origin_shift_flags
            =continuous_shift_flags).dist()
        if (min_dist > max_distance):
          print("FAIL:", inp_symmetry.space_group_info(), \
                         point_frac_ref, min_dist)
          raise AssertionError
    if (inp_tags.tags().n_independent()+10 < sites_cart.size()):
      print("FAIL:", inp_symmetry.space_group_info(), \
                     inp_tags.tags().n_independent(), sites_cart.size())
      raise AssertionError
  if (tag_sites_frac is not None):
    dump_pdb(
      file_name="tag_sites.pdb",
      crystal_symmetry=inp_symmetry,
      sites_cart=inp_symmetry.unit_cell().orthogonalize(
        sites_frac=tag_sites_frac))

def run_call_back(flags, space_group_info):
  crystal_symmetry = crystal.symmetry(
    unit_cell=space_group_info.any_compatible_unit_cell(volume=1000),
    space_group_info=space_group_info)
  if (flags.Verbose):
    print(crystal_symmetry.unit_cell())
  symmetry_flags=sgtbx.search_symmetry_flags(
      use_space_group_symmetry=True,
      use_space_group_ltr=0,
      use_seminvariants=True,
      use_normalizer_k2l=False,
      use_normalizer_l2n=False)
  point_distance = 2
  buffer_thickness = -1
  all_twelve_neighbors = False
  if (flags.strictly_inside):
    buffer_thickness = 0
  if (flags.all_twelve_neighbors):
    all_twelve_neighbors = True
  if (flags.Verbose):
    print("buffer_thickness:", buffer_thickness)
    print("all_twelve_neighbors:", all_twelve_neighbors)
  sites_cart = hexagonal_close_packing_sampling(
    crystal_symmetry=crystal_symmetry,
    symmetry_flags=symmetry_flags,
    point_distance=point_distance,
    buffer_thickness=buffer_thickness,
    all_twelve_neighbors=all_twelve_neighbors)
  if (1):
    check_distances(
      sites_cart=sites_cart,
      point_distance=point_distance,
      verbose=flags.Verbose)
  if (1):
    check_with_grid_tags(
      inp_symmetry=crystal_symmetry,
      symmetry_flags=symmetry_flags,
      sites_cart=sites_cart,
      point_distance=point_distance,
      strictly_inside=flags.strictly_inside,
      flag_write_pdb=flags.write_pdb,
      verbose=flags.Verbose)
  if (flags.write_pdb):
    dump_pdb(
      file_name="hex_sites.pdb",
      crystal_symmetry=crystal_symmetry,
      sites_cart=sites_cart)

def exercise_all_twelve_neighbors():
  sites_cart = hexagonal_close_packing_sampling(
    crystal_symmetry=crystal.symmetry(
      unit_cell=(14.4225, 14.4225, 14.4225, 90, 90, 90),
      space_group_symbol="F m -3 m"),
    symmetry_flags=sgtbx.search_symmetry_flags(
      use_space_group_symmetry=True,
      use_space_group_ltr=0,
      use_seminvariants=True,
      use_normalizer_k2l=False,
      use_normalizer_l2n=False),
    point_distance=2,
    buffer_thickness=-1,
    all_twelve_neighbors=True)
  assert len(sites_cart) == 36 # depends an float_asu, which depends on cb_op,
    # which depends on cmp_change_of_basis_mx in sgtbx/space_group_type.cpp

def exercise_groel_sampling(verbose):
  crystal_symmetry = crystal.symmetry(
    unit_cell="255.260  265.250  184.400  90.00  90.00",
    space_group_symbol="P 21 21 2")
  t00 = time.time()
  n_sites = []
  for use_space_group_symmetry in [True,False]:
    for use_seminvariants in [True,False]:
      for all_twelve_neighbors in [False,True]:
        sampling_generator = close_packing.hexagonal_sampling(
          crystal_symmetry=crystal_symmetry,
          symmetry_flags=sgtbx.search_symmetry_flags(
            use_space_group_symmetry=use_space_group_symmetry,
            use_space_group_ltr=0,
            use_seminvariants=use_seminvariants,
            use_normalizer_k2l=False,
            use_normalizer_l2n=False),
          point_distance=2,
          buffer_thickness=-1,
          all_twelve_neighbors=all_twelve_neighbors)
        t0 = time.time()
        n_sites.append(sampling_generator.count_sites())
        if (verbose):
          print(n_sites[-1], "%.2f" % (time.time() - t0))
  assert n_sites == [41712, 45319, 304200, 315809, # depends an float_asu, ...
                     162240, 170797, 1195830, 1232774]
  print("time groel_sampling: %.2f seconds" % (time.time() - t00))

def run():
  exercise_all_twelve_neighbors()
  exercise_groel_sampling(verbose=("--Verbose" in sys.argv[1:]))
  debug_utils.parse_options_loop_space_groups(sys.argv[1:], run_call_back, (
    "strictly_inside",
    "all_twelve_neighbors",
    "write_pdb"))
  print("OK")

if (__name__ == "__main__"):
  run()


 *******************************************************************************


 *******************************************************************************
cctbx/regression/tst_diffuse.py
from __future__ import absolute_import, division, print_function
from libtbx import easy_run
import libtbx.load_env
import iotbx.mtz
from libtbx.test_utils import approx_equal
import os, time

pdb_str = """
CRYST1   50.840   42.770   28.950  90.00  90.00  90.00 P 21 21 21
MODEL        1
ATOM      1  N   MET A   1      27.340  24.430   2.614  1.00  0.00           N
ATOM      2  CA  MET A   1      26.266  25.413   2.842  1.00  0.00           C
ATOM      3  C   MET A   1      26.913  26.639   3.531  1.00  0.00           C
ATOM      4  O   MET A   1      27.886  26.463   4.263  1.00  0.00           O
ATOM      5  CB  MET A   1      25.112  24.880   3.649  1.00  0.00           C
ATOM      6  CG  MET A   1      25.353  24.860   5.134  1.00  0.00           C
ATOM      7  SD  MET A   1      23.930  23.959   5.904  1.00  0.00           S
ATOM      8  CE  MET A   1      24.447  23.984   7.620  1.00  0.00           C
ATOM      9  N   GLN A   2      26.335  27.770   3.258  1.00  0.00           N
ATOM     10  CA  GLN A   2      26.850  29.021   3.898  1.00  0.00           C
ATOM     11  C   GLN A   2      26.100  29.253   5.202  1.00  0.00           C
ATOM     12  O   GLN A   2      24.865  29.024   5.330  1.00  0.00           O
ATOM     13  CB  GLN A   2      26.733  30.148   2.905  1.00  0.00           C
ATOM     14  CG  GLN A   2      26.882  31.546   3.409  1.00  0.00           C
ATOM     15  CD  GLN A   2      26.786  32.562   2.270  1.00  0.00           C
ATOM     16  OE1 GLN A   2      27.783  33.160   1.870  1.00  0.00           O
ATOM     17  NE2 GLN A   2      25.562  32.733   1.806  1.00  0.00           N
ATOM     18  N   ILE A   3      26.849  29.656   6.217  1.00  0.00           N
ATOM     19  CA  ILE A   3      26.235  30.058   7.497  1.00  0.00           C
ATOM     20  C   ILE A   3      26.882  31.428   7.862  1.00  0.00           C
ATOM     21  O   ILE A   3      27.906  31.711   7.264  1.00  0.00           O
ATOM     22  CB  ILE A   3      26.344  29.050   8.645  1.00  0.00           C
ATOM     23  CG1 ILE A   3      27.810  28.748   8.999  1.00  0.00           C
ATOM     24  CG2 ILE A   3      25.491  27.771   8.287  1.00  0.00           C
ATOM     25  CD1 ILE A   3      27.967  28.087  10.417  1.00  0.00           C
ATOM     26  N   PHE A   4      26.214  32.097   8.771  1.00  0.00           N
ATOM     27  CA  PHE A   4      26.772  33.436   9.197  1.00  0.00           C
ATOM     28  C   PHE A   4      27.151  33.362  10.650  1.00  0.00           C
ATOM     29  O   PHE A   4      26.350  32.778  11.395  1.00  0.00           O
ATOM     30  CB  PHE A   4      25.695  34.498   8.946  1.00  0.00           C
ATOM     31  CG  PHE A   4      25.288  34.609   7.499  1.00  0.00           C
ATOM     32  CD1 PHE A   4      24.147  33.966   7.038  1.00  0.00           C
ATOM     33  CD2 PHE A   4      26.136  35.346   6.640  1.00  0.00           C
ATOM     34  CE1 PHE A   4      23.812  34.031   5.677  1.00  0.00           C
ATOM     35  CE2 PHE A   4      25.810  35.392   5.267  1.00  0.00           C
ATOM     36  CZ  PHE A   4      24.620  34.778   4.853  1.00  0.00           C
ATOM     37  N   VAL A   5      28.260  33.943  11.096  1.00  0.00           N
ATOM     38  CA  VAL A   5      28.605  33.965  12.503  1.00  0.00           C
ATOM     39  C   VAL A   5      28.638  35.461  12.900  1.00  0.00           C
ATOM     40  O   VAL A   5      29.522  36.103  12.320  1.00  0.00           O
ATOM     41  CB  VAL A   5      29.963  33.317  12.814  1.00  0.00           C
ATOM     42  CG1 VAL A   5      30.211  33.394  14.304  1.00  0.00           C
ATOM     43  CG2 VAL A   5      29.957  31.838  12.352  1.00  0.00           C
TER
ENDMDL
MODEL        2
ATOM      1  N   MET A   1      27.840  24.430   2.614  1.00  0.00           N
ATOM      2  CA  MET A   1      26.766  25.413   2.842  1.00  0.00           C
ATOM      3  C   MET A   1      27.413  26.639   3.531  1.00  0.00           C
ATOM      4  O   MET A   1      28.386  26.463   4.263  1.00  0.00           O
ATOM      5  CB  MET A   1      25.612  24.880   3.649  1.00  0.00           C
ATOM      6  CG  MET A   1      25.853  24.860   5.134  1.00  0.00           C
ATOM      7  SD  MET A   1      24.430  23.959   5.904  1.00  0.00           S
ATOM      8  CE  MET A   1      24.947  23.984   7.620  1.00  0.00           C
ATOM      9  N   GLN A   2      26.835  27.770   3.258  1.00  0.00           N
ATOM     10  CA  GLN A   2      27.350  29.021   3.898  1.00  0.00           C
ATOM     11  C   GLN A   2      26.600  29.253   5.202  1.00  0.00           C
ATOM     12  O   GLN A   2      25.365  29.024   5.330  1.00  0.00           O
ATOM     13  CB  GLN A   2      27.233  30.148   2.905  1.00  0.00           C
ATOM     14  CG  GLN A   2      27.382  31.546   3.409  1.00  0.00           C
ATOM     15  CD  GLN A   2      27.286  32.562   2.270  1.00  0.00           C
ATOM     16  OE1 GLN A   2      28.283  33.160   1.870  1.00  0.00           O
ATOM     17  NE2 GLN A   2      26.062  32.733   1.806  1.00  0.00           N
ATOM     18  N   ILE A   3      27.349  29.656   6.217  1.00  0.00           N
ATOM     19  CA  ILE A   3      26.735  30.058   7.497  1.00  0.00           C
ATOM     20  C   ILE A   3      27.382  31.428   7.862  1.00  0.00           C
ATOM     21  O   ILE A   3      28.406  31.711   7.264  1.00  0.00           O
ATOM     22  CB  ILE A   3      26.844  29.050   8.645  1.00  0.00           C
ATOM     23  CG1 ILE A   3      28.310  28.748   8.999  1.00  0.00           C
ATOM     24  CG2 ILE A   3      25.991  27.771   8.287  1.00  0.00           C
ATOM     25  CD1 ILE A   3      28.467  28.087  10.417  1.00  0.00           C
ATOM     26  N   PHE A   4      26.714  32.097   8.771  1.00  0.00           N
ATOM     27  CA  PHE A   4      27.272  33.436   9.197  1.00  0.00           C
ATOM     28  C   PHE A   4      27.651  33.362  10.650  1.00  0.00           C
ATOM     29  O   PHE A   4      26.850  32.778  11.395  1.00  0.00           O
ATOM     30  CB  PHE A   4      26.195  34.498   8.946  1.00  0.00           C
ATOM     31  CG  PHE A   4      25.788  34.609   7.499  1.00  0.00           C
ATOM     32  CD1 PHE A   4      24.647  33.966   7.038  1.00  0.00           C
ATOM     33  CD2 PHE A   4      26.636  35.346   6.640  1.00  0.00           C
ATOM     34  CE1 PHE A   4      24.312  34.031   5.677  1.00  0.00           C
ATOM     35  CE2 PHE A   4      26.310  35.392   5.267  1.00  0.00           C
ATOM     36  CZ  PHE A   4      25.120  34.778   4.853  1.00  0.00           C
ATOM     37  N   VAL A   5      28.760  33.943  11.096  1.00  0.00           N
ATOM     38  CA  VAL A   5      29.105  33.965  12.503  1.00  0.00           C
ATOM     39  C   VAL A   5      29.138  35.461  12.900  1.00  0.00           C
ATOM     40  O   VAL A   5      30.022  36.103  12.320  1.00  0.00           O
ATOM     41  CB  VAL A   5      30.463  33.317  12.814  1.00  0.00           C
ATOM     42  CG1 VAL A   5      30.711  33.394  14.304  1.00  0.00           C
ATOM     43  CG2 VAL A   5      30.457  31.838  12.352  1.00  0.00           C
TER
ENDMDL
END
"""
#phenix.diffuse pdb=m.pdb probabilities=0.5,0.5 resolution=4.0 prefix=tst
def exercise():
  fo = open("tst_diffuse.pdb","w")
  print(pdb_str, file=fo)
  fo.close()
  cmd_list = [
    "pdb=tst_diffuse.pdb",
    "probabilities=0.5,0.5",
    "resolution=4.0",
    "prefix=tst_diffuse"]
  file_location = os.path.join(abs(libtbx.env.bin_path), 'phenix.diffuse')
  if os.path.isfile(file_location):
    cmd_list.insert(0, 'phenix.diffuse')
  else:
    import cctbx
    file_location = os.path.join(
      os.path.dirname(cctbx.__file__),
      'command_line',
      'diffuse.py')
    cmd_list.insert(0, 'python %s ' % file_location)
  cmd = " ".join(cmd_list)
  if 0: print(cmd)
  assert not easy_run.call(cmd)
  mas = iotbx.mtz.object(file_name="tst_diffuse.mtz").as_miller_arrays()
  assert len(mas) == 1
  ma = mas[0]
  assert ma.data().size() == 937, ma.data().size()
  assert approx_equal(ma.d_max_min(), (32.728, 4.0), 1.e-3)
  assert approx_equal((ma.data()/1000.).min_max_mean().as_tuple(),
    (0.001, 6.118, 0.35456), 1.e-3)
  assert ma.info().labels == ['I', 'SIGI']
  assert approx_equal(ma.unit_cell().parameters(),
    (50.84,42.77,28.95,90.0,90.0,90.0), 1.e-2)

if __name__ == '__main__':
  t0 = time.time()
  exercise()
  print("Time: %5.2f"%(time.time()-t0))
  print("OK")


 *******************************************************************************


 *******************************************************************************
cctbx/regression/tst_direct_scaling.py
from __future__ import absolute_import, division, print_function
import random
from six.moves import range
random.seed(0)
from scitbx.array_family import flex
flex.set_random_seed(0)
from math import pow,pi
from cctbx import sgtbx
from cctbx.development import random_structure
from cctbx.xray.structure_factors.from_scatterers_direct_parallel import direct_summation_simple
from cctbx.xray.structure_factors.from_scatterers_direct_parallel import direct_summation_cuda_platform
from libtbx.utils import wall_clock_time, show_times_at_exit
from libtbx.test_utils import approx_equal
from libtbx import table_utils

def show_times_vs_complexity(times, header):

  table_header = [ "# HKL",
           "cpu-time",
           "simple-tm",
           "fft-time","R(%)",
           "gpu_d-tm",
           "gpu_f-tm","R(%)",
           "d-min(angstrom)" ]
  table_data = [table_header]
  for i,t,d,g,gf,gfR,s,f,fR in times:
    table_row = ["%.0f"%i,"%.2f"%t,"%.2f"%s,"%.2f"%f,"%.2f"%fR,
                 "%.2f"%g,"%.2f"%gf,"%.5f"%gfR,"%5.2f"%d]
    table_data.append(table_row)
  print(table_utils.format(table_data,has_header=True,justify="left",
    prefix="| ",postfix=" |"))

def show_diagnostics(xs):
  #help(xs.scatterers())
  print(list(xs.scatterers().extract_labels()))
  print(list(xs.scatterers().extract_occupancies()))
  print(list(xs.scatterers().extract_scattering_types()))
  print(list(xs.scatterers().extract_sites()))
  print()
  print(list(xs.scatterers().extract_u_cart(xs.unit_cell())))
  print()
  print(list(xs.scatterers().extract_u_iso()))
  print()
  print(list(xs.scatterers().extract_u_star()))

def exercise_direct(space_group_info,
                    elements,
                    anomalous_flag=False,
                    use_random_u_iso=False,
                    verbose=0):
  xs = random_structure.xray_structure(
    space_group_info=space_group_info,
    elements=elements,
    random_u_iso=use_random_u_iso,
    volume_per_atom=18.6,
    min_distance=1.2)
  #show_diagnostics(xs)

  reciprocal_volume = xs.unit_cell().reciprocal().volume()
  times = []

  cuda_platform = direct_summation_cuda_platform()
  cuda_platform_float = direct_summation_cuda_platform(float_t="float")

  direct_reference = True

  for x in range(1,7):
    print("There are %d scatterers"%len(elements))
    number_of_reflections = pow(10.,x)
    Volume = number_of_reflections *  reciprocal_volume * 2. #2 P1 asymmetric units
    Volume *= space_group_info.group().order_z() # take space group into acct.
    recip_radius = pow(3.*Volume/(4.*pi),1./3.)
    d_min = 1./recip_radius

    if 0:
      cos_sin_table = math_module.cos_sin_table(2**10)
    if 1:
      cos_sin_table = False

    if direct_reference:
      timer = wall_clock_time()
      cpu_direct = xs.structure_factors(d_min=d_min,algorithm="direct",
                                            cos_sin_table=cos_sin_table)
      cpu_time = timer.elapsed()
      cpu_direct_f = cpu_direct.f_calc()

      timer = wall_clock_time()
      simple_direct = xs.structure_factors(d_min=d_min,algorithm=direct_summation_simple())
      simple_time = timer.elapsed()
      simple_direct_f = simple_direct.f_calc()
    else:
      cpu_time=0
      simple_time=0

    timer = wall_clock_time()
    gpu_direct = xs.structure_factors(d_min=d_min,algorithm=cuda_platform)
    gpu_time = timer.elapsed()
    gpu_direct_f = gpu_direct.f_calc()
    gpu_amplitude = gpu_direct_f.as_amplitude_array()
    sum_amp = flex.sum(gpu_amplitude.data())

    timer = wall_clock_time()
    gpuf_direct = xs.structure_factors(d_min=d_min,algorithm=cuda_platform_float)
    gpuf_time = timer.elapsed()
    gpuf_direct_f = gpuf_direct.f_calc()
    gpuf_amplitude = gpuf_direct_f.as_amplitude_array()

    abs_diff = flex.abs(gpuf_amplitude.data() - gpu_amplitude.data())
    sum_diff = flex.sum(abs_diff)
    gpuf_Rfactor = 100.*sum_diff/sum_amp

    timer = wall_clock_time()
    fft_algorithm = xs.structure_factors(d_min=d_min,algorithm="fft")
    fft_time = timer.elapsed()
    fft_f = fft_algorithm.f_calc()
    fft_amplitude = fft_f.as_amplitude_array()
    abs_diff = flex.abs(fft_amplitude.data() - gpu_amplitude.data())
    sum_diff = flex.sum(abs_diff)
    fft_Rfactor = 100.*sum_diff/sum_amp

    times.append((number_of_reflections,cpu_time,d_min,
                  gpu_time,
                  gpuf_time,gpuf_Rfactor,
                  simple_time,
                  fft_time,fft_Rfactor))
    # doesn't assert correctly: assert approx_equal(cpu_direct_f.data(), fft_f.data())
    if direct_reference:
     assert approx_equal(cpu_direct_f.data(), gpu_direct_f.data(), eps=1e-6)
     assert approx_equal(cpu_direct_f.data(), simple_direct_f.data(), eps=1e-6)

  show_times_vs_complexity(times, header="run time vs. # reflections")

def run_scattering_type_tests():
  for C in range(35):
    for N in range(35):
      for total in range(93,99):
        elements = ['C']*C + ['N']*N + ['O']*(total-N-C)
        print("".join(elements))
        exercise_direct(sgtbx.space_group_info("P1"),elements)

def run(args,multiplier):
  show_times_at_exit()
  verbose = '--verbose' in args
  use_random_u_iso = '--use_random_u_iso' in args
  #count from 1hmg.pdb, chain A: C, 1583; N, 445; O, 495, S, 13
  elements = ['O']*19 + ['N']*18 + ['C']*62 + ['S']*1
  allelements = elements*multiplier

  if 0:
    for sn in range(1,231):
      try:
        sgi = sgtbx.space_group_info(sn)
        print("Space group",sgi,"number",sn)
        exercise_direct(sgi, allelements, use_random_u_iso=use_random_u_iso, verbose=verbose)
      except Exception as e:
        print(e)
    return

  if 0:
    for symbol in ["P1","P3","P41","P212121","I41","F432"]:
      sgi = sgtbx.space_group_info(symbol)
      print("Space group",sgi)
      exercise_direct(sgi, allelements, use_random_u_iso=use_random_u_iso, verbose=verbose)

  if 1:
    sgi = sgtbx.space_group_info("P1")
    print("Space group",sgi)
    exercise_direct(sgi, allelements, use_random_u_iso=use_random_u_iso, verbose=verbose)

if __name__ == '__main__':
  import sys

  for size in [10,20,40,80,160,320]:
    if "--fileout" in sys.argv[1:]:
      result_base = sys.argv[ sys.argv.index("--fileout") + 1 ]
      sys.stdout = open("%s%03d.log"%(result_base,size),"w")
    run(sys.argv[1:],size)


 *******************************************************************************


 *******************************************************************************
cctbx/regression/tst_direct_space_asu.py
from __future__ import absolute_import, division, print_function
from cctbx import crystal
import cctbx.crystal.direct_space_asu
from cctbx import xray
from cctbx import sgtbx
from cctbx.sgtbx.direct_space_asu import reference_table
from cctbx.sgtbx.direct_space_asu import facet_analysis
from cctbx.development import random_structure
from cctbx.development import debug_utils
from cctbx.array_family import flex
from scitbx import matrix
from libtbx.test_utils import approx_equal
from libtbx.utils import format_cpu_times
from boost_adaptbx.boost import rational
import random
import copy
import sys
from six.moves import range
from six.moves import zip

def exercise_reference_table():
  for space_group_number in range(1,230+1):
    space_group_info = sgtbx.space_group_info(number=space_group_number)
    asu = reference_table.get_asu(space_group_number)
    assert sgtbx.space_group(asu.hall_symbol) == space_group_info.group()
  #
  for space_group_number in range(1,230+1):
    asu = reference_table.get_asu(space_group_number)
    n_long_cuts = 0
    for cut in asu.cuts:
      s = str(cut)
      have_long_cut = (s.find("cut") >= 0)
      if (space_group_number != 213):
        assert not have_long_cut
      elif (have_long_cut):
        n_long_cuts += 1
    if (space_group_number == 213):
      assert n_long_cuts == 4 # done with change_basis

def exercise_cut_planes(cut_planes):
  for cut_plane in cut_planes:
    assert cut_plane.strip().is_inside(cut_plane.get_point_in_plane())

def exercise_shape_vertices(asu, unit_cell):
  volume_asu = asu.shape_only()
  asu_shape_vertices = asu.shape_vertices()
  assert len(asu_shape_vertices) >= 4
  facet_analysis_shape_vertices = facet_analysis.shape_vertices(asu)
  assert len(asu_shape_vertices) == len(facet_analysis_shape_vertices)
  asu_shape_vertices.sort()
  facet_analysis_shape_vertices.sort()
  assert asu_shape_vertices == facet_analysis_shape_vertices
  for box_min,box_max in zip(asu.box_min(shape_vertices=asu_shape_vertices),
                             asu.box_max(shape_vertices=asu_shape_vertices)):
    assert box_min < box_max
  if (unit_cell is None):
    return
  float_asu = asu.add_buffer(unit_cell=unit_cell, thickness=0)
  asu_shrunk = float_asu.add_buffer(relative_thickness=-1.e-5)
  mcs = asu.define_metric(unit_cell).minimum_covering_sphere()
  center = matrix.col(mcs.center())
  radius = mcs.radius()
  n_near_sphere_surface = 0
  for vertex in asu_shape_vertices:
    assert volume_asu.is_inside(vertex)
    float_vertex = [float(e) for e in vertex]
    assert float_asu.is_inside(float_vertex)
    assert not asu_shrunk.is_inside(float_vertex)
    r = abs(matrix.col(unit_cell.orthogonalize(float_vertex)) - center)
    assert r < radius + 1.e-5
    if (radius - r < radius * 1.e-2):
      n_near_sphere_surface += 1
  assert n_near_sphere_surface >= 2
  float_asu_shape_vertices = float_asu.shape_vertices()
  assert len(float_asu_shape_vertices) >= len(asu_shape_vertices)
  m_near_sphere_surface = 0
  for vertex in float_asu_shape_vertices:
    assert float_asu.is_inside(point=vertex)
    assert not asu_shrunk.is_inside(vertex)
    r = abs(matrix.col(unit_cell.orthogonalize(vertex)) - center)
    assert r < radius + 1.e-5
    if (radius - r < radius * 1.e-2):
      m_near_sphere_surface += 1
  assert m_near_sphere_surface >= n_near_sphere_surface
  line_asu = copy.copy(asu)
  line_asu.add_planes([(0,0,1),(1,1,1)], both_directions=True)
  assert len(line_asu.cuts) == len(asu.cuts) + 4
  assert line_asu.cuts[-2].n == (-line_asu.cuts[-1]).n

def exercise_float_asu(space_group_info, n_grid=6):
  unit_cell = space_group_info.any_compatible_unit_cell(volume=1000)
  ref_asu = reference_table.get_asu(space_group_info.type().number())
  exercise_cut_planes(ref_asu.cuts)
  inp_asu = space_group_info.direct_space_asu()
  assert sgtbx.space_group(inp_asu.hall_symbol) == space_group_info.group()
  exercise_cut_planes(inp_asu.cuts)
  exercise_shape_vertices(inp_asu, unit_cell)
  float_asu = inp_asu.add_buffer(unit_cell=unit_cell, thickness=0.001)
  cb_mx_ref_inp = space_group_info.type().cb_op().c_inv().as_rational()
  n = n_grid
  for ref_n in flex.nested_loop((-n//2,-n//2,-n//2),(n,n,n),False):
    # check correctness of space_group_info.direct_space_asu()
    ref_r = matrix.col([rational.int(g,n) for g in ref_n])
    inp_r = cb_mx_ref_inp * ref_r
    assert ref_asu.is_inside(ref_r.elems) == inp_asu.is_inside(inp_r.elems)
    # check correctness of cut_plane.add_buffer()
    inp_r = inp_r.elems
    inp_f = [float(r) for r in inp_r]
    for cut in inp_asu.cuts:
      r_cut = cut.strip()
      r_inside = r_cut.is_inside(inp_r)
      for buffer_thickness in [0.001, 1, -1][:1]:
        f_cut = cut.as_float_cut_plane().add_buffer(
          unit_cell=unit_cell,
          thickness=buffer_thickness)
        f_inside = f_cut.is_inside(inp_f)
        if (buffer_thickness < 0):
          if (r_inside != f_inside):
            assert r_inside
        elif (buffer_thickness < 0.01):
          assert r_inside == f_inside
        elif (r_inside != f_inside):
          assert f_inside
    # check correctness of float_asu.add_buffer()
    assert float_asu.is_inside(inp_f) == inp_asu.shape_only().is_inside(inp_r)
  asu_with_metric = inp_asu.define_metric(unit_cell)
  assert asu_with_metric.hall_symbol is inp_asu.hall_symbol
  assert len(asu_with_metric.cuts) == len(inp_asu.cuts)
  assert asu_with_metric.unit_cell is unit_cell
  asu_tight = asu_with_metric.as_float_asu()
  asu_buffer = asu_with_metric.add_buffer(thickness=2)
  asu_shrunk = asu_with_metric.add_buffer(relative_thickness=-1.e-5)
  vertices = facet_analysis.shape_vertices(inp_asu)
  for vertex in vertices:
    assert inp_asu.shape_only().is_inside(vertex)
  for vertex in vertices:
    assert asu_tight.is_inside(matrix.col(vertex).as_float().elems)
  for vertex in vertices:
    assert asu_buffer.is_inside(matrix.col(vertex).as_float().elems)
  for vertex in vertices:
    assert not asu_shrunk.is_inside(matrix.col(vertex).as_float().elems)

def exercise_asu_mappings(space_group_info, n_elements=10):
  structure = random_structure.xray_structure(
    space_group_info,
    elements=["Si"]*n_elements,
    volume_per_atom=1000,
    min_distance=3.,
    general_positions_only=False)
  asu_mappings = crystal.direct_space_asu.asu_mappings(
    space_group=structure.space_group(),
    asu=structure.direct_space_asu().as_float_asu(),
    buffer_thickness=4)
  asu_mappings.reserve(structure.scatterers().size())
  for scatterer in structure.scatterers():
    asu_mappings.process(original_site=scatterer.site)
  assert asu_mappings.mappings().size() == structure.scatterers().size()
  frac = asu_mappings.unit_cell().fractionalize
  for mappings in asu_mappings.mappings():
    assert asu_mappings.asu().is_inside(frac(mappings[0].mapped_site()))
    for mapping in mappings:
      assert asu_mappings.asu_buffer().is_inside(frac(mapping.mapped_site()))

def exercise_neighbors_pair_generators(structure, verbose=0):
  if (0 or verbose):
    structure.show_summary().show_scatterers()
    print()
  for buffer_thickness in [1.e-5, 2, 4]:
    asu_mappings = crystal.direct_space_asu.asu_mappings(
      space_group=structure.space_group(),
      asu=structure.direct_space_asu().as_float_asu(),
      buffer_thickness=buffer_thickness)
    asu_mappings.reserve(structure.scatterers().size())
    for scatterer in structure.scatterers():
      asu_mappings.process(scatterer.site)
    array_of_array_of_mappings = asu_mappings.mappings()
    for minimal in [False, True]:
      pair_list = []
      for i_seq in range(array_of_array_of_mappings.size()):
        array_of_mappings_i = array_of_array_of_mappings[i_seq]
        site_0 = matrix.col(array_of_mappings_i[0].mapped_site())
        for j_seq in range(i_seq, array_of_array_of_mappings.size()):
          array_of_mappings_j = array_of_array_of_mappings[j_seq]
          if (i_seq == j_seq):
            j_sym_start = 1
          else:
            j_sym_start = 0
          for j_sym in range(j_sym_start, len(array_of_mappings_j)):
            site_1 = matrix.col(array_of_mappings_j[j_sym].mapped_site())
            dist_sq = (site_1-site_0).norm_sq()
            pair_list.append((i_seq,j_seq,j_sym,dist_sq))
          if (not minimal and i_seq != j_seq):
            site_1 = matrix.col(array_of_mappings_j[0].mapped_site())
            for i_sym in range(1, len(array_of_mappings_i)):
              site_2 = matrix.col(array_of_mappings_i[i_sym].mapped_site())
              dist_sq = (site_2-site_1).norm_sq()
              pair_list.append((j_seq,i_seq,i_sym,dist_sq))
      for pair_generator_type in [crystal.neighbors_simple_pair_generator,
                                  crystal.neighbors_fast_pair_generator]:
        pair_generator = pair_generator_type(
          asu_mappings=asu_mappings,
          distance_cutoff=1.e6,
          minimal=minimal)
        mps = asu_mappings.mappings()
        sc = structure.scatterers()
        uc = structure.unit_cell()
        sg = structure.space_group()
        col = matrix.col
        pair_dict = dict([(pair[:3], pair[3]) for pair in pair_list])
        for pair in pair_generator:
          assert pair.is_active(minimal=minimal)
          key = (pair.i_seq, pair.j_seq, pair.j_sym)
          assert approx_equal(pair_dict[key], pair.dist_sq)
          del pair_dict[key]
          mp_i = mps[pair.i_seq][0]
          mp_j = mps[pair.j_seq][pair.j_sym]
          site_i = (  col(sg(mp_i.i_sym_op())*sc[pair.i_seq].site)
                    + col(mp_i.unit_shifts())).elems
          site_j = (  col(sg(mp_j.i_sym_op())*sc[pair.j_seq].site)
                    + col(mp_j.unit_shifts())).elems
          assert approx_equal(uc.orthogonalize(site_i), mp_i.mapped_site())
          assert approx_equal(uc.orthogonalize(site_j), mp_j.mapped_site())
          assert approx_equal(uc.distance(site_i, site_j)**2, pair.dist_sq)
          site_i = asu_mappings.get_rt_mx_i(pair=pair) * sc[pair.i_seq].site
          site_j = asu_mappings.get_rt_mx_j(pair=pair) * sc[pair.j_seq].site
          assert approx_equal(uc.orthogonalize(site_i), mp_i.mapped_site())
          assert approx_equal(uc.orthogonalize(site_j), mp_j.mapped_site())
          j_frac = uc.fractionalize(mp_j.mapped_site())
          assert approx_equal(
            asu_mappings.get_rt_mx_j(pair=pair).inverse() * j_frac,
            sc[pair.j_seq].site)
          assert approx_equal(
            asu_mappings.map_moved_site_to_asu(
              moved_original_site
                =asu_mappings.unit_cell().orthogonalize(sc[pair.i_seq].site),
              i_seq=pair.i_seq,
              i_sym=0),
            mp_i.mapped_site())
          assert approx_equal(
            asu_mappings.map_moved_site_to_asu(
              moved_original_site
                =asu_mappings.unit_cell().orthogonalize(sc[pair.j_seq].site),
              i_seq=pair.j_seq,
              i_sym=pair.j_sym),
            mp_j.mapped_site())
        assert len(pair_dict) == 0

def asu_mappings_is_simple_interaction_emulation(asu_mappings, pair):
  is_special_position = asu_mappings.site_symmetry_table().is_special_position
  if (is_special_position(i_seq=pair.i_seq)): return False
  if (is_special_position(i_seq=pair.j_seq)): return False
  return asu_mappings.get_rt_mx_i(pair) == asu_mappings.get_rt_mx_j(pair)

def exercise_is_simple_interaction():
  for space_group_symbol in ["P1", "P41"]:
    for shifts in flex.nested_loop((-2,-2,-2),(2,2,2),False):
      shifts = matrix.col(shifts)
      structure = xray.structure(
        crystal_symmetry=crystal.symmetry(
          unit_cell=(10,10,20,90,90,90),
          space_group_symbol=space_group_symbol),
        scatterers=flex.xray_scatterer([
          xray.scatterer(label="O", site=shifts+matrix.col((0,0,0))),
          xray.scatterer(label="N", site=shifts+matrix.col((0.5,0.5,0))),
          xray.scatterer(label="C", site=shifts+matrix.col((0.25,0.25,0)))]))
      asu_mappings = structure.asu_mappings(buffer_thickness=7)
      pair_generator = crystal.neighbors_simple_pair_generator(
        asu_mappings=asu_mappings,
        distance_cutoff=7)
      simple_interactions = {}
      for i_pair,pair in enumerate(pair_generator):
        if (asu_mappings.is_simple_interaction(pair)):
          assert asu_mappings_is_simple_interaction_emulation(
            asu_mappings, pair)
          key = (pair.i_seq,pair.j_seq)
          assert simple_interactions.get(key, None) is None
          simple_interactions[key] = 1
        else:
          assert not asu_mappings_is_simple_interaction_emulation(
            asu_mappings, pair)
      assert len(simple_interactions) == 2
      assert simple_interactions[(0,2)] == 1
      assert simple_interactions[(1,2)] == 1

def exercise_non_crystallographic_asu_mappings():
  asu_mappings = crystal.direct_space_asu.non_crystallographic_asu_mappings(
    sites_cart=flex.vec3_double())
  assert approx_equal(asu_mappings.unit_cell().parameters(), (1,1,1,90,90,90))
  asu_mappings = crystal.direct_space_asu.non_crystallographic_asu_mappings(
    sites_cart=flex.vec3_double([(2,-3,4)]))
  assert approx_equal(asu_mappings.unit_cell().parameters(), (1,1,1,90,90,90))
  for i_trial in range(10):
    offs = random.uniform(-100,100)
    sites_cart = flex.vec3_double()
    for i_site in range(10):
      sites_cart.append([random.uniform(-10+offs,10+offs) for i in range(3)])
    asu_mappings = crystal.direct_space_asu.non_crystallographic_asu_mappings(
      sites_cart=sites_cart)
    for site,asu_mapping in zip(sites_cart,asu_mappings.mappings()):
      assert len(asu_mapping) == 1
      assert asu_mapping[0].i_sym_op() == 0
      assert asu_mapping[0].unit_shifts() == (0,0,0)
      assert approx_equal(asu_mapping[0].mapped_site(), site)
    assert approx_equal(asu_mappings.mapped_sites_min(), sites_cart.min())
    assert approx_equal(asu_mappings.mapped_sites_max(), sites_cart.max())

def exercise_all(flags, space_group_info):
  exercise_float_asu(space_group_info)
  exercise_asu_mappings(space_group_info)
  exercise_neighbors_pair_generators(
    structure = random_structure.xray_structure(
      space_group_info,
      elements=["Si"]*5,
      volume_per_atom=100,
      min_distance=3.,
      general_positions_only=False),
    verbose=flags.Verbose)

def run_call_back(flags, space_group_info):
  exercise_all(flags, space_group_info)
  if (space_group_info.group().n_ltr() != 1):
    exercise_all(flags, space_group_info.primitive_setting())

def run():
  exercise_reference_table()
  for space_group_number in range(1,230+1):
    asu = reference_table.get_asu(space_group_number)
    exercise_shape_vertices(asu=asu, unit_cell=None)
  debug_utils.parse_options_loop_space_groups(
    sys.argv[1:], run_call_back, show_cpu_times=False)
  exercise_is_simple_interaction()
  exercise_non_crystallographic_asu_mappings()
  print(format_cpu_times())

if (__name__ == "__main__"):
  run()


 *******************************************************************************


 *******************************************************************************
cctbx/regression/tst_emma.py
from __future__ import absolute_import, division, print_function
from cctbx import euclidean_model_matching as emma
from iotbx.command_line.emma import get_emma_model_from_pdb
from cctbx import xray
from cctbx import crystal
from cctbx import sgtbx
from cctbx.development import random_structure
from cctbx.development import debug_utils
import iotbx.pdb
from scitbx import matrix
from libtbx.test_utils import approx_equal, show_diff
from six.moves import cStringIO as StringIO
import random
import sys
from six.moves import range
from six.moves import zip

target_p1="""
CRYST1  144.039  144.039  178.924  90.00  90.00  90.00 P 1
HETATM 8695 ZN    ZN A   1      17.869  52.603 -22.252  1.00 71.42          ZN
HETATM 8696 ZN    ZN A   2      13.880  35.387 -29.691  1.00 52.39          ZN
HETATM 8697 ZN    ZN B   1     -18.309  55.887 -22.399  1.00 69.35          ZN
HETATM 8698 ZN    ZN B   2     -16.873  38.206 -14.862  1.00 52.32          ZN
HETATM 8699 ZN    ZN C   1      17.122  50.509  37.216  1.00 71.99          ZN
HETATM 8700 ZN    ZN C   2      13.610  33.302  29.476  1.00 64.25          ZN
HETATM 8701 ZN    ZN D   1     -18.170  53.456  36.514  1.00 69.79          ZN
HETATM 8702 ZN    ZN D   2     -17.078  36.031  44.336  1.00 54.56          ZN
HETATM 8703 ZN    ZN E   1      19.385  86.977  52.280  1.00 71.29          ZN
HETATM 8704 ZN    ZN E   2      36.676  83.705  44.841  1.00 64.49          ZN
HETATM 8705 ZN    ZN F   1      17.852  51.246  51.495  1.00 69.29          ZN
HETATM 8706 ZN    ZN F   2      35.249  52.846  59.559  1.00 57.36          ZN
"""

target_p1_inverse="""
CRYST1  144.039  144.039  178.924  90.00  90.00  90.00 P 1
ATOM      1 ZN    ZN A   1     -17.869 -52.603  22.252  1.00 71.42          ZN
ATOM      2 ZN    ZN A   2     -13.880 -35.387  29.691  1.00 52.39          ZN
ATOM      3 ZN    ZN B   1      18.309 -55.887  22.399  1.00 69.35          ZN
ATOM      4 ZN    ZN B   2      16.873 -38.206  14.862  1.00 52.32          ZN
ATOM      5 ZN    ZN C   1     -17.122 -50.509 -37.216  1.00 71.99          ZN
ATOM      6 ZN    ZN C   2     -13.610 -33.302 -29.476  1.00 64.25          ZN
ATOM      7 ZN    ZN D   1      18.170 -53.456 -36.514  1.00 69.79          ZN
ATOM      8 ZN    ZN D   2      17.078 -36.031 -44.336  1.00 54.56          ZN
ATOM      9 ZN    ZN E   1     -19.385 -86.977 -52.280  1.00 71.29          ZN
ATOM     10 ZN    ZN E   2     -36.676 -83.705 -44.841  1.00 64.49          ZN
ATOM     11 ZN    ZN F   1     -17.852 -51.246 -51.495  1.00 69.29          ZN
ATOM     12 ZN    ZN F   2     -35.249 -52.846 -59.559  1.00 57.36          ZN
"""

target_p1_partial="""
CRYST1  144.039  144.039  178.924  90.00  90.00  90.00 P 1
ATOM      1 ZN    ZN A   1      38.446  73.180   3.309  1.00 71.42          ZN
ATOM      2 ZN    ZN A   2      34.457  55.964  -4.130  1.00 52.39          ZN
ATOM      3 ZN    ZN B   1       2.268  76.464   3.162  1.00 69.35          ZN
ATOM      4 ZN    ZN B   2       3.704  58.783  10.699  1.00 52.32          ZN
ATOM      5 ZN    ZN C   1      37.699  71.086  62.777  1.00 71.99          ZN
ATOM      6 ZN    ZN C   2      34.187  53.879  55.037  1.00 64.25          ZN
ATOM      7 ZN    ZN D   1       2.407  74.033  62.075  1.00 69.79          ZN
ATOM      8 ZN    ZN D   2       3.499  56.608  69.897  1.00 54.56          ZN
ATOM      9 ZN    ZN E   1      39.962 107.554  77.841  1.00 71.29          ZN
ATOM     10 ZN    ZN E   2      57.253 104.282  70.402  1.00 64.49          ZN
ATOM     11 ZN    ZN F   1      38.429  71.823  77.056  1.00 69.29          ZN
ATOM     12 ZN    ZN F   2      55.826  73.423  85.120  1.00 57.36          ZN
"""

target_p1_inverse_partial="""
CRYST1  144.039  144.039  178.924  90.00  90.00  90.00 P 1
ATOM      1 ZN    ZN A   1       2.708 -32.026  47.813  1.00 71.42          ZN
ATOM      2 ZN    ZN A   2       6.697 -14.810  55.252  1.00 52.39          ZN
ATOM      3 ZN    ZN B   1      38.886 -35.310  47.960  1.00 69.35          ZN
ATOM      4 ZN    ZN B   2      37.450 -17.629  40.423  1.00 52.32          ZN
ATOM      5 ZN    ZN C   1       3.455 -29.932 -11.655  1.00 71.99          ZN
ATOM      6 ZN    ZN C   2       6.967 -12.725  -3.915  1.00 64.25          ZN
ATOM      7 ZN    ZN D   1      38.747 -32.879 -10.953  1.00 69.79          ZN
ATOM      8 ZN    ZN D   2      37.655 -15.454 -18.775  1.00 54.56          ZN
ATOM      9 ZN    ZN E   1       1.192 -66.400 -26.719  1.00 71.29          ZN
ATOM     10 ZN    ZN E   2     -16.099 -63.128 -19.280  1.00 64.49          ZN
ATOM     11 ZN    ZN F   1       2.725 -30.669 -25.934  1.00 69.29          ZN
ATOM     12 ZN    ZN F   2     -14.672 -32.269 -33.998  1.00 57.36          ZN
"""

target_p43212="""
CRYST1  144.039  144.039  178.924  90.00  90.00  90.00 P 43 21 2
HETATM 8695 ZN    ZN A   1      17.869  52.603 -22.252  1.00 71.42          ZN
HETATM 8696 ZN    ZN A   2      13.880  35.387 -29.691  1.00 52.39          ZN
HETATM 8697 ZN    ZN B   1     -18.309  55.887 -22.399  1.00 69.35          ZN
HETATM 8698 ZN    ZN B   2     -16.873  38.206 -14.862  1.00 52.32          ZN
HETATM 8699 ZN    ZN C   1      17.122  50.509  37.216  1.00 71.99          ZN
HETATM 8700 ZN    ZN C   2      13.610  33.302  29.476  1.00 64.25          ZN
HETATM 8701 ZN    ZN D   1     -18.170  53.456  36.514  1.00 69.79          ZN
HETATM 8702 ZN    ZN D   2     -17.078  36.031  44.336  1.00 54.56          ZN
HETATM 8703 ZN    ZN E   1      19.385  86.977  52.280  1.00 71.29          ZN
HETATM 8704 ZN    ZN E   2      36.676  83.705  44.841  1.00 64.49          ZN
HETATM 8705 ZN    ZN F   1      17.852  51.246  51.495  1.00 69.29          ZN
HETATM 8706 ZN    ZN F   2      35.249  52.846  59.559  1.00 57.36          ZN
"""

target_p43212_inverse="""
CRYST1  144.039  144.039  178.924  90.00  90.00  90.00 P 41 21 2
ATOM      1 ZN    ZN A   1     -17.869 -52.603  22.252  1.00 71.42          ZN
ATOM      2 ZN    ZN A   2     -13.880 -35.387  29.691  1.00 52.39          ZN
ATOM      3 ZN    ZN B   1      18.309 -55.887  22.399  1.00 69.35          ZN
ATOM      4 ZN    ZN B   2      16.873 -38.206  14.862  1.00 52.32          ZN
ATOM      5 ZN    ZN C   1     -17.122 -50.509 -37.216  1.00 71.99          ZN
ATOM      6 ZN    ZN C   2     -13.610 -33.302 -29.476  1.00 64.25          ZN
ATOM      7 ZN    ZN D   1      18.170 -53.456 -36.514  1.00 69.79          ZN
ATOM      8 ZN    ZN D   2      17.078 -36.031 -44.336  1.00 54.56          ZN
ATOM      9 ZN    ZN E   1     -19.385 -86.977 -52.280  1.00 71.29          ZN
ATOM     10 ZN    ZN E   2     -36.676 -83.705 -44.841  1.00 64.49          ZN
ATOM     11 ZN    ZN F   1     -17.852 -51.246 -51.495  1.00 69.29          ZN
ATOM     12 ZN    ZN F   2     -35.249 -52.846 -59.559  1.00 57.36          ZN
"""

target_p43212_half="""
CRYST1  144.039  144.039  178.924  90.00  90.00  90.00 P 43 21 2
ATOM      1 ZN    ZN A   1      89.888 124.623  67.210  1.00 71.42          ZN
ATOM      2 ZN    ZN A   2      85.899 107.406  59.771  1.00 52.39          ZN
ATOM      3 ZN    ZN B   1      53.710 127.906  67.063  1.00 69.35          ZN
ATOM      4 ZN    ZN B   2      55.146 110.225  74.600  1.00 52.32          ZN
ATOM      5 ZN    ZN C   1      89.141 122.528 126.678  1.00 71.99          ZN
ATOM      6 ZN    ZN C   2      85.629 105.321 118.938  1.00 64.25          ZN
ATOM      7 ZN    ZN D   1      53.849 125.475 125.976  1.00 69.79          ZN
ATOM      8 ZN    ZN D   2      54.941 108.050 133.798  1.00 54.56          ZN
ATOM      9 ZN    ZN E   1      91.404 158.996 141.742  1.00 71.29          ZN
ATOM     10 ZN    ZN E   2     108.695 155.724 134.303  1.00 64.49          ZN
ATOM     11 ZN    ZN F   1      89.871 123.266 140.957  1.00 69.29          ZN
ATOM     12 ZN    ZN F   2     107.268 124.865 149.021  1.00 57.36          ZN
"""

target_p43212_inverse_half="""
CRYST1  144.039  144.039  178.924  90.00  90.00  90.00 P 41 21 2
ATOM      1 ZN    ZN A   1      54.150  19.416 111.714  1.00 71.42          ZN
ATOM      2 ZN    ZN A   2      58.139  36.632 119.153  1.00 52.39          ZN
ATOM      3 ZN    ZN B   1      90.328  16.132 111.861  1.00 69.35          ZN
ATOM      4 ZN    ZN B   2      88.892  33.813 104.324  1.00 52.32          ZN
ATOM      5 ZN    ZN C   1      54.897  21.510  52.246  1.00 71.99          ZN
ATOM      6 ZN    ZN C   2      58.409  38.717  59.986  1.00 64.25          ZN
ATOM      7 ZN    ZN D   1      90.189  18.563  52.948  1.00 69.79          ZN
ATOM      8 ZN    ZN D   2      89.097  35.988  45.126  1.00 54.56          ZN
ATOM      9 ZN    ZN E   1      52.634 -14.958  37.182  1.00 71.29          ZN
ATOM     10 ZN    ZN E   2      35.343 -11.686  44.621  1.00 64.49          ZN
ATOM     11 ZN    ZN F   1      54.167  20.773  37.967  1.00 69.29          ZN
ATOM     12 ZN    ZN F   2      36.770  19.173  29.903  1.00 57.36          ZN
"""

pdb6="""
CRYST1   25.000   25.000   25.000  90.00 100.00  90.00 P 1 21 1
ATOM      1  N   GLN R  92      56.308  21.768  24.816  1.00  0.00           N
ATOM      2  CA  GLN R  92      56.603  22.162  26.183  1.00  2.50           C
ATOM      3  C   GLN R  92      56.704  23.694  26.279  1.00  0.00           C
ATOM      4  O   GLN R  92      57.301  24.360  25.424  1.00  0.00           O
ATOM      5  CB  GLN R  92      57.895  21.483  26.649  1.00  0.00           C
ATOM      6  CG  GLN R  92      58.220  21.612  28.124  1.00  0.00           C
"""
pdb5="""
CRYST1   25.000   25.000   25.000  90.00 100.00  90.00 P 1 21 1
ATOM    664  N   GLN R  92      10.579  -3.235   0.175  1.00 16.04      P9   N
ATOM    665  CA  GLN R  92      10.924  -2.975   1.574  1.00 16.32      P9   C
ATOM    666  CB  GLN R  92      12.268  -3.629   1.888  0.65 16.46      P9   C
ATOM    667  CG  GLN R  92      12.787  -3.408   3.288  0.55 16.88      P9   C
ATOM    668  CD  GLN R  92      14.105  -4.123   3.509  0.51 17.19      P9   C
"""

pdb5_out=\
"""REMARK Number of scatterers: 5
REMARK At special positions: 0
REMARK Cartesian coordinates
CRYST1   25.000   25.000   25.000  90.00 100.00  90.00 P 1 21 1
SCALE1      0.040000  0.000000  0.007053        0.00000
SCALE2      0.000000  0.040000  0.000000        0.00000
SCALE3      0.000000  0.000000  0.040617        0.00000
ATOM      1  N    N      1      10.579  21.833   0.175  1.00 16.04           N
ATOM      2  CA   CA     2      10.924  22.093   1.574  1.00 16.32           C
ATOM      3  CB   CB     3      12.268  21.439   1.888  0.65 16.46           C
ATOM      4  CG   CG     4      12.787  21.660   3.288  0.55 16.88           C
ATOM      5  CD   CD     5      14.105  20.945   3.509  0.51 17.19           C
END"""


def verify_match(model1, model2, tolerance, match_rt, pairs):
  adj_tolerance = tolerance * (1 + 1.e-6)
  for pair in pairs:
    c1 = model1[pair[0]].site
    c2 = match_rt * model2[pair[1]].site
    equiv_c2 = sgtbx.sym_equiv_sites(model1.site_symmetry(c2.elems))
    dist_info = sgtbx.min_sym_equiv_distance_info(equiv_c2, c1)
    assert dist_info.dist() < adj_tolerance, str(model1.space_group_info())

def analyze_singles(model, singles):
  for i in singles:
    if (model[i].label.startswith("S")): return False
  return True

def analyze_refined_matches(model1, model2, refined_matches, verbose):
  solution_counter = 0
  for match in refined_matches:
    if (0 or verbose):
      match.show()
    verify_match(match.ref_model1, match.ref_model2, match.tolerance,
                 match.ref_eucl_rt, match.pairs)
    verify_match(model1, model2, match.tolerance,
                 match.rt, match.pairs)
    if (    analyze_singles(model1, match.singles1)
        and analyze_singles(model2, match.singles2)):
      solution_counter += 1
  if (0 or verbose):
    print("total matches:", len(refined_matches))
    print("solutions:", solution_counter)
    print()
  assert solution_counter != 0

class test_model(emma.model):

  def __init__(self, model_id="SBT", n_elements=4):
    if (model_id is None): return
    self.model_id = model_id
    pos = emma.position
    if (type(model_id) == type("")):
      if (model_id == "SBT"):
        emma.model.__init__(self,
          crystal.special_position_settings(crystal.symmetry(
            (16.8986, 16.8986, 16.8986, 61.1483, 61.1483, 61.1483),
            "R -3 m :R")),
          (pos("SI1", (-0.3584, 0.2844, 0.4622)),
           pos("SI2", (-0.2133, 0.9659, -0.6653)),
           pos("SI3", (-0.8358, 0.7, 0.3431)),
           pos("SI4", (0.4799, 1.836, 0.6598))))
      else:
        raise RuntimeError("Unknown model_id: " + model_id)
    else:
      structure = random_structure.xray_structure(
        model_id,
        elements=["S"]*n_elements,
        volume_per_atom=50.,
        min_distance=2.0)
      positions = []
      for scatterer in structure.scatterers():
        positions.append(emma.position(scatterer.label, scatterer.site))
      emma.model.__init__(self, structure, positions)

  def create_new_test_model(self, new_positions):
    new_test_model = test_model(None)
    emma.model.__init__(new_test_model, self, new_positions)
    return new_test_model

  def shuffle_positions(self):
    shuffled_positions = list(self.positions())
    random.shuffle(shuffled_positions)
    return self.create_new_test_model(shuffled_positions)

  def random_symmetry_mates(self):
    new_positions = []
    for pos in self.positions():
      equiv = sgtbx.sym_equiv_sites(self.site_symmetry(pos.site))
      i = random.randrange(equiv.coordinates().size())
      new_positions.append(emma.position(pos.label, equiv.coordinates()[i]))
    return self.create_new_test_model(new_positions)

  def apply_random_eucl_op(self, models_are_diffraction_index_equivalent=0):
    match_symmetry = emma.euclidean_match_symmetry(
      self.space_group_info(),
      use_k2l=True, use_l2n=(not models_are_diffraction_index_equivalent))
    i = random.randrange(match_symmetry.rt_mx.order_z())
    eucl_symop = match_symmetry.rt_mx(i)
    shift = [0.5 - random.random() for i in range(3)]
    allowed_shift = matrix.col(match_symmetry.filter_shift(shift, selector=1))
    new_positions = []
    for pos in self.positions():
      new_site = matrix.col(eucl_symop * pos.site) + allowed_shift
      new_positions.append(emma.position(pos.label, new_site.elems))
    return self.create_new_test_model(new_positions)

  def add_random_positions(self, number_of_new_positions=3, label="R",
                           min_distance=1.0):
    existing_sites = []
    for pos in self.positions():
      existing_sites.append(pos.site)
    new_sites = random_structure.random_sites(
      special_position_settings=self,
      existing_sites=existing_sites,
      n_new=number_of_new_positions,
      min_hetero_distance=min_distance,
      general_positions_only=False)
    new_positions = []
    i = 0
    for site in new_sites:
      i += 1
      new_positions.append(emma.position("%s%d" % (label, i), site))
    return self.create_new_test_model(self.positions() + new_positions)

  def shake_positions(self, gauss_sigma=0.2, min_distance=1.0):
    new_positions = []
    for pos in self.positions():
      new_coor = random_structure.random_modify_site(
        special_position_settings=self,
        site=pos.site,
        gauss_sigma=gauss_sigma,
        max_distance=min_distance*0.99)
      new_positions.append(emma.position(pos.label, new_coor))
    return self.create_new_test_model(new_positions)

  def random_hand(self):
    if (random.random() < 0.5):
      cb_op = sgtbx.change_of_basis_op()
    else:
      cb_op = self.space_group_info().type().change_of_hand_op()
    return self.change_basis(cb_op).reset_cb_op()

def run_call_back(flags, space_group_info):
  verbose = flags.Verbose
  if (flags.StaticModels):
    model1 = (test_model()
      .add_random_positions(2, "A")
      .shuffle_positions()
      .random_symmetry_mates()
      .apply_random_eucl_op()
      )
    model2 = (test_model()
      .add_random_positions(3, "B")
      .shuffle_positions()
      .random_symmetry_mates()
      .apply_random_eucl_op()
      .shake_positions()
      .random_hand()
      )
    for i in (0,1):
      m1 = model1
      if (i): m1 = model1.transform_to_reference_setting().reset_cb_op()
      for j in (0,1):
        m2 = model2
        if (j): m2 = model2.transform_to_reference_setting().reset_cb_op()
        if (0 or verbose):
          m1.show("Model1(%d)" % (i,))
          m2.show("Model2(%d)" % (j,))
        model_matches = emma.model_matches(m1, m2, rms_penalty_per_site=0)
        analyze_refined_matches(m1, m2, model_matches.refined_matches, verbose)
    return False
  model_core = test_model(space_group_info)
  model1 = (model_core
    .add_random_positions(2, "A")
    )
  model2 = (model_core
    .add_random_positions(3, "B")
    .shuffle_positions()
    .random_symmetry_mates()
    .apply_random_eucl_op()
    .shake_positions()
    .random_hand()
    )
  if (0 or verbose):
    model_core.show("Core")
    model1.show("Model1")
    model2.show("Model2")
  model_matches = emma.model_matches(model1, model2, rms_penalty_per_site=0)
  analyze_refined_matches(
    model1, model2, model_matches.refined_matches, verbose)
  assert model_matches.consensus_model().size() >= model1.size()-2
  assert model_matches.consensus_model(i_model=2).size() >= model2.size()-3
  model1.expand_to_p1()
  model2.as_xray_structure()
  for i1,i2,m1,m2 in [(1,2,model1,model2),(2,1,model2,model1)]:
    m2_t = model_matches.transform_model(i_model=i2)
    assert m1.unit_cell().is_similar_to(m2_t.unit_cell())
    assert m1.space_group() == m2_t.space_group()
    for pair in model_matches.refined_matches[0].pairs:
      site1 = m1.positions()[pair[i1-1]].site
      site2 = m2_t.positions()[pair[i2-1]].site
      equiv_sites1 = sgtbx.sym_equiv_sites(m1.site_symmetry(site1))
      dist_info = sgtbx.min_sym_equiv_distance_info(equiv_sites1, site2)
      assert dist_info.dist() < model_matches.tolerance + 1.e-6
      site2_closest = dist_info.sym_op() * site2
      assert approx_equal(
        m1.unit_cell().distance(site1, site2_closest),
        dist_info.dist())
    if (i1 == 1):
      singles = model_matches.refined_matches[0].singles2
    else:
      singles = model_matches.refined_matches[0].singles1
    for i_site2 in singles:
      site2 = m2_t.positions()[i_site2].site
      for i_site1 in range(len(model1.positions())):
        site1 = m1.positions()[i_site1].site
        equiv_sites1 = sgtbx.sym_equiv_sites(m1.site_symmetry(site1))
        dist_info = sgtbx.min_sym_equiv_distance_info(equiv_sites1, site2)
        if (dist_info.dist() < model_matches.tolerance - 1.e-6):
          ok = False
          for pair in model_matches.refined_matches[0].pairs:
            if (pair[i1-1] == i_site1):
              ok = True
          assert ok

def run():
  match_symmetry = emma.euclidean_match_symmetry(
    space_group_info=sgtbx.space_group_info(symbol="P1"),
    use_k2l=True,
    use_l2n=False)
  out = StringIO()
  match_symmetry.show(title="test", f=out)
  assert not show_diff(out.getvalue(), """\
euclidean_match_symmetry: test
P -1
((1, 0, 0), (0, 1, 0), (0, 0, 1))
""")
  #
  debug_utils.parse_options_loop_space_groups(sys.argv[1:], run_call_back, (
    "StaticModels",))

def tst_pdb_output():
  print("Testing pdb-output option")
  xray_scatterer = xray.scatterer( scattering_type = 'SE')
  for sg,target_list in zip(
     ['p1','p43212'],
     [
        [target_p1,target_p1_inverse,target_p1_partial,
           target_p1_inverse_partial],
        [target_p43212,target_p43212_inverse,target_p43212_half,
           target_p43212_inverse_half]
     ]
     ):
    print("Testing group of targets in %s" %(sg))
    for t1 in target_list:
      e1=get_emma_model_from_pdb(pdb_records=t1)
      for t2 in target_list:
        e2=get_emma_model_from_pdb(pdb_records=t2)
        match_list=e1.best_superpositions_on_other(
          e2)
        match=match_list[0]
        assert match
        offset_e2=match.get_transformed_model2()

        # make sure that offset_i2 is pretty much the same as e1 now.
        new_match_list=e1.best_superpositions_on_other(
          offset_e2)
        new_match=new_match_list[0]
        assert new_match
        assert approx_equal(new_match.rms,0.,eps=0.01)
        assert len(new_match.pairs)==12
        assert approx_equal(
           new_match.rt.r,matrix.sqr((1, 0, 0, 0, 1, 0, 0, 0, 1)))
        assert approx_equal(new_match.rt.t.transpose(),matrix.col((0, 0, 0)))

  print("Testing pdb-output option with different-sized entries")
  e1=get_emma_model_from_pdb(pdb_records=pdb6)
  e2=get_emma_model_from_pdb(pdb_records=pdb5)
  pdb_inp_e2=iotbx.pdb.input(source_info=None, lines=pdb5)

  match_list=e1.best_superpositions_on_other(e2)
  match=match_list[0]
  assert match
  output_pdb="output.pdb"
  offset_e2=match.get_transformed_model2(output_pdb=output_pdb,
    template_pdb_inp=pdb_inp_e2)
  with open(output_pdb) as f:
    offset_e2_text_lines=f.readlines()
  for o,e in zip(offset_e2_text_lines, pdb5_out.splitlines()):
     o=o.strip()
     e=e.strip()
     if o != e:
       print(o)
       print(e)
       assert o==e

if (__name__ == "__main__"):
  run()
  tst_pdb_output()


 *******************************************************************************


 *******************************************************************************
cctbx/regression/tst_expand_to_p1.py
from __future__ import absolute_import, division, print_function
from cctbx import miller
from cctbx.array_family import flex
from cctbx.development import random_structure
from cctbx.development import debug_utils
import scitbx.math
import sys

def exercise(
      space_group_info,
      use_primitive_setting,
      anomalous_flag,
      use_u_aniso,
      n_elements=3,
      d_min=3.,
      verbose=0):
  if (use_primitive_setting):
    space_group_info = space_group_info.primitive_setting()
  structure = random_structure.xray_structure(
    space_group_info,
    elements=("Se",)*n_elements,
    volume_per_atom=200,
    random_f_prime_d_min=1.0,
    random_f_double_prime=anomalous_flag,
    random_u_iso=True,
    use_u_aniso=use_u_aniso,
    random_occupancy=True)
  if (0 or verbose):
    structure.show_summary().show_scatterers()
    print("n_special_positions:", \
          structure.special_position_indices().size())
  structure_p1 = structure.expand_to_p1()
  assert structure_p1.scatterers()[0].label == "Se1"
  assert structure_p1.scatterers()[-1].label == ("Se%d" % n_elements)
  structure_p1 = structure.expand_to_p1(append_number_to_labels=True)
  if (0 or verbose):
    structure_p1.show_summary().show_scatterers()
  l,i = structure_p1.scatterers()[0].label.split("_")
  assert l == "Se1"
  assert int(i) == 0
  l,i = structure_p1.scatterers()[-1].label.split("_")
  assert l == ("Se%d" % n_elements)
  assert int(i) \
      == structure.site_symmetry_table().get(n_elements-1).multiplicity()-1
  assert structure_p1.special_position_indices().size() == 0
  f_calc = structure.structure_factors(
    anomalous_flag=anomalous_flag, d_min=d_min, algorithm="direct").f_calc()
  miller_set_p1 = miller.set.expand_to_p1(f_calc)
  f_calc_p1 = f_calc.expand_to_p1()
  assert flex.order(miller_set_p1.indices(), f_calc_p1.indices()) == 0
  amplitudes = abs(f_calc)
  amplitudes_p1 = amplitudes.expand_to_p1()
  assert flex.order(miller_set_p1.indices(), amplitudes_p1.indices()) == 0
  c = flex.linear_correlation(abs(f_calc_p1).data(), amplitudes_p1.data())
  assert c.is_well_defined()
  assert c.n() > 20
  if (0 or verbose):
    print("correlation:", c.coefficient())
  assert c.coefficient() > 0.999
  for phase_deg in (False, True):
    phases = f_calc.arg(phase_deg)
    phases_p1 = phases.expand_to_p1(phase_deg)
    assert flex.order(miller_set_p1.indices(), phases_p1.indices()) == 0
    f_calc_p1_phases = f_calc_p1.arg(phase_deg)
    for i,phase in enumerate(f_calc_p1_phases.data()):
      e = scitbx.math.phase_error(phase, phases_p1.data()[i], deg=phase_deg)
      assert e < 1.e-6
  ctrl_amplitudes_p1 = abs(miller_set_p1.structure_factors_from_scatterers(
    xray_structure=structure_p1,
    algorithm="direct").f_calc())
  c = flex.linear_correlation(amplitudes_p1.data(), ctrl_amplitudes_p1.data())
  assert c.is_well_defined()
  if (0 or verbose):
    print("correlation:", c.coefficient())
  assert c.coefficient() > 0.999

def run_call_back(flags, space_group_info):
  use_primitive_setting_flags = [False]
  if (space_group_info.group().conventional_centring_type_symbol() != "P"):
    use_primitive_setting_flags.append(True)
  for use_primitive_setting in use_primitive_setting_flags:
    for anomalous_flag in (False, True)[:]: #SWITCH
      for use_u_aniso in (False, True)[:]: #SWITCH
        exercise(
          space_group_info=space_group_info,
          use_primitive_setting=use_primitive_setting,
          anomalous_flag=anomalous_flag,
          use_u_aniso=use_u_aniso,
          verbose=flags.Verbose)

def run():
  debug_utils.parse_options_loop_space_groups(sys.argv[1:], run_call_back)

if (__name__ == "__main__"):
  run()


 *******************************************************************************


 *******************************************************************************
cctbx/regression/tst_f_model.py
from __future__ import absolute_import, division, print_function
from cctbx.array_family import flex
from cctbx import xray
from cctbx import sgtbx
from libtbx.test_utils import approx_equal

import random
import math
from cctbx.development import random_structure as rs

random.seed(0)
flex.set_random_seed(0)

def compare_all(tmp1,tmp2):
  assert approx_equal( tmp1.ksol(),tmp2.ksol() )
  assert approx_equal( tmp1.usol(),tmp2.usol() )
  assert approx_equal( tmp1.kpart(),tmp2.kpart() )
  assert approx_equal( tmp1.upart(),tmp2.upart() )
  assert approx_equal( tmp1.koverall(),tmp2.koverall() )
  assert approx_equal( tmp1.ustar(), tmp2.ustar() )

def tst_f_model_derivative_holder():
  dinfo = xray.f_model_core_data_derivative_holder()

  dinfo.ksol(1)
  dinfo.usol(1)
  dinfo.kpart(1)
  dinfo.upart(1)
  dinfo.koverall(1)
  dinfo.ustar( [1,1,1,1,1,1] )

  dinfo.accumulate( dinfo )
  assert( dinfo.ksol()==2 )
  assert( dinfo.usol()==2 )
  assert( dinfo.kpart()==2 )
  assert( dinfo.upart()==2 )
  assert( dinfo.koverall()==2 )
  assert( dinfo.ustar()==(2,2,2,2,2,2) )


def tst_f_model():
  tmp = rs.xray_structure(sgtbx.space_group_info( 'P1' ),
                          elements=['C']*310,
                          n_scatterers=310)

  sfs = tmp.structure_factors( False, 3.5,  ).f_calc()
  f_mod = xray.f_model_core_data( hkl = sfs.indices(),
                        f_atoms= sfs.data(),
                        f_mask = sfs.data(),
                        unit_cell = sfs.unit_cell(),
                        k_overall=1.0,
                        u_star=(0,0,0,0,0,0),
                        k_sol=1.0,
                        u_sol=0.1,
                        f_part=sfs.data(),
                        k_part=1.0,
                        u_part=0.1 )
  f_mod.refresh()

  data1 = sfs.data()[123]
  hkl1 =  sfs.indices()[123]

  fbulk = f_mod.f_bulk()[123]
  fatoms = f_mod.f_atoms()[123]
  fpart = f_mod.f_part()[123]
  fmod = f_mod.f_model()[123]
  # we have unit scale now
  assert approx_equal( fmod, fbulk+fatoms+fpart )
  # get derivatives please
  #
  # make a mock target function: T=A^2 + B^2
  # dT/dF=2F
  # dT/dA=2A
  # dT/dB=2B
  f_model_data_complex = f_mod.f_model()
  fm = flex.double()
  a = flex.double()
  b = flex.double()

  for cmplx in f_model_data_complex:
    tmp_a=cmplx.real
    tmp_b=cmplx.imag
    fm.append( math.sqrt(tmp_a*tmp_a + tmp_b*tmp_b) )
    a.append( tmp_a )
    b.append( tmp_b )

  dtdf = 2.0*fm
  dtda = 2.0*a
  dtdb = 2.0*b

  gradient_flags=flex.bool([True,True,
                            True,True,
                            True,True])

  grads_f = f_mod.d_target_d_all(dtdf,gradient_flags)
  grads_ab = f_mod.d_target_d_all(dtda, dtdb,gradient_flags)
  compare_all(grads_ab,grads_f)

  f_mod = xray.f_model_core_data( hkl = sfs.indices(),
                        f_atoms= sfs.data(),
                        f_mask = sfs.data()*0.0,
                        unit_cell = sfs.unit_cell(),
                        k_overall=1.0,
                        u_star=(0,0,0,0,0,0),
                        k_sol=0.0,
                        u_sol=0.0,
                        f_part=sfs.data()*0.0,
                        k_part=0.0,
                        u_part=0.0 )
  f_mod.refresh()
  grad_123 = f_mod.d_target_d_all(0,1,123, gradient_flags)
  assert approx_equal( grad_123.koverall(),
                       f_mod.f_model()[123].imag/f_mod.koverall() )
  tps=19.7392088
  h=hkl1[0]
  k=hkl1[1]
  l=hkl1[2]
  assert approx_equal( -2*tps*h*h*f_mod.f_model()[123].imag,
                       grad_123.ustar()[0] )
  assert approx_equal( -2*tps*k*k*f_mod.f_model()[123].imag,
                       grad_123.ustar()[1] )
  assert approx_equal( -2*tps*l*l*f_mod.f_model()[123].imag,
                       grad_123.ustar()[2] )
  assert approx_equal( -4*tps*h*k*f_mod.f_model()[123].imag,
                       grad_123.ustar()[3] )
  assert approx_equal( -4*tps*h*l*f_mod.f_model()[123].imag,
                       grad_123.ustar()[4] )
  assert approx_equal( -4*tps*k*l*f_mod.f_model()[123].imag,
                       grad_123.ustar()[5] )





  grad_123 = f_mod.d_target_d_all(1,0,123, gradient_flags)
  assert approx_equal( grad_123.koverall(),
                       f_mod.f_model()[123].real/f_mod.koverall() )
  tps=19.7392088
  h=hkl1[0]
  k=hkl1[1]
  l=hkl1[2]
  assert approx_equal( -2*tps*h*h*f_mod.f_model()[123].real,
                       grad_123.ustar()[0] )
  assert approx_equal( -2*tps*k*k*f_mod.f_model()[123].real,
                       grad_123.ustar()[1] )
  assert approx_equal( -2*tps*l*l*f_mod.f_model()[123].real,
                       grad_123.ustar()[2] )
  assert approx_equal( -4*tps*h*k*f_mod.f_model()[123].real,
                       grad_123.ustar()[3] )
  assert approx_equal( -4*tps*h*l*f_mod.f_model()[123].real,
                       grad_123.ustar()[4] )
  assert approx_equal( -4*tps*k*l*f_mod.f_model()[123].real,
                       grad_123.ustar()[5] )





  oldfm = xray.f_model_core_data( hkl = sfs.indices(),
                        f_atoms= sfs.data(),
                        f_mask = sfs.data()*1.0,
                        unit_cell = sfs.unit_cell(),
                        k_overall=1.0,
                        u_star=(0,0,0,0,0,0),
                        k_sol=1.0,
                        u_sol=0.1,
                        f_part=sfs.data()*1.0,
                        k_part=1.0,
                        u_part=0.1 )
  h=0.0001


  newfm = xray.f_model_core_data( hkl = sfs.indices(),
                        f_atoms= sfs.data(),
                        f_mask = sfs.data()*1.0,
                        unit_cell = sfs.unit_cell(),
                        k_overall=1.0,
                        u_star=(0,0,0,0,0,0),
                        k_sol=1.0,
                        u_sol=0.1,
                        f_part=sfs.data()*1.0,
                        k_part=1.0,
                        u_part=0.1 )


  newfm.renew_overall_scale_parameters(1.0+h, (0,0,0,0,0,0))
  newfm.refresh()

  tmp = oldfm.d_target_d_all(1,0,123,gradient_flags).koverall()
  tmp_d = ((oldfm.f_model()[123]-newfm.f_model()[123])/(-h)).real
  assert approx_equal( tmp,tmp_d,eps=1e-4 )
  newfm.renew_overall_scale_parameters(1, (0,0,0,0,0,0))


  newfm.renew_bulk_solvent_scale_parameters(1+h,0.1)
  tmp = oldfm.d_target_d_all(1,0,123,gradient_flags).ksol()
  tmp_d = ((oldfm.f_model()[123]-newfm.f_model()[123])/(-h)).real
  assert approx_equal( tmp,tmp_d,eps=1e-2 )
  newfm.renew_bulk_solvent_scale_parameters(1,0.1)

  newfm.renew_bulk_solvent_scale_parameters(1.0,0.1+h)
  tmp = oldfm.d_target_d_all(1,0,123,gradient_flags).usol()
  tmp_d = ((oldfm.f_model()[123]-newfm.f_model()[123])/(-h)).real
  assert approx_equal( tmp,tmp_d,eps=1e-2 )
  newfm.renew_bulk_solvent_scale_parameters(1.0,0.1)

  newfm.renew_bulk_solvent_scale_parameters(1+h,0.1)
  tmp = oldfm.d_target_d_all(0,1,123,gradient_flags).ksol()
  tmp_d = ((oldfm.f_model()[123]-newfm.f_model()[123])/(-h)).imag
  assert approx_equal( tmp,tmp_d,eps=1e-2 )
  newfm.renew_bulk_solvent_scale_parameters(1,0.1)

  newfm.renew_bulk_solvent_scale_parameters(1.0,0.1+h)
  tmp = oldfm.d_target_d_all(0,1,123,gradient_flags).usol()
  tmp_d = ((oldfm.f_model()[123]-newfm.f_model()[123])/(-h)).imag
  assert approx_equal( tmp,tmp_d,eps=1e-2 )
  newfm.renew_bulk_solvent_scale_parameters(1.0,0.1)


  newfm.renew_partial_structure_scale_parameters(1+h,0.1)
  tmp = oldfm.d_target_d_all(1,0,123,gradient_flags).kpart()
  tmp_d = ((oldfm.f_model()[123]-newfm.f_model()[123])/(-h)).real
  assert approx_equal( tmp,tmp_d,eps=1e-2 )
  newfm.renew_bulk_solvent_scale_parameters(1,0.1)

  newfm.renew_partial_structure_scale_parameters(1.0,0.1+h)
  tmp = oldfm.d_target_d_all(1,0,123,gradient_flags).upart()
  tmp_d = ((oldfm.f_model()[123]-newfm.f_model()[123])/(-h)).real
  assert approx_equal( tmp,tmp_d,eps=1e-2 )
  newfm.renew_bulk_solvent_scale_parameters(1.0,0.1)

  newfm.renew_partial_structure_scale_parameters(1+h,0.1)
  tmp = oldfm.d_target_d_all(0,1,123,gradient_flags).kpart()
  tmp_d = ((oldfm.f_model()[123]-newfm.f_model()[123])/(-h)).imag
  assert approx_equal( tmp,tmp_d,eps=1e-2 )
  newfm.renew_bulk_solvent_scale_parameters(1,0.1)

  newfm.renew_partial_structure_scale_parameters(1.0,0.1+h)
  tmp = oldfm.d_target_d_all(0,1,123,gradient_flags).upart()
  tmp_d = ((oldfm.f_model()[123]-newfm.f_model()[123])/(-h)).imag
  assert approx_equal( tmp,tmp_d,eps=1e-2 )
  newfm.renew_bulk_solvent_scale_parameters(1.0,0.1)



def run():
  tst_f_model()
  tst_f_model_derivative_holder()


if (__name__ == "__main__"):
  ()
  print("OK")


 *******************************************************************************


 *******************************************************************************
cctbx/regression/tst_fast_nv1995.py
from __future__ import absolute_import, division, print_function
from cctbx import translation_search
from cctbx import crystal
from cctbx import miller
from cctbx import xray
from cctbx import maptbx
from cctbx.development import random_structure
from cctbx.development import debug_utils
from cctbx.array_family import flex
from libtbx.test_utils import approx_equal
from scitbx import matrix
import random
import sys
from six.moves import range
from six.moves import zip

def run_fast_terms(structure_fixed, structure_p1,
                   f_obs, f_calc_fixed, f_calc_p1,
                   symmetry_flags, gridding, grid_tags,
                   n_sample_grid_points=10,
                   test_origin=False,
                   verbose=0):
  if (f_calc_fixed is None):
    f_part = flex.complex_double()
  else:
    f_part = f_calc_fixed.data()
  m = flex.double()
  for i in range(f_obs.indices().size()):
    m.append(random.random())
  assert f_obs.anomalous_flag() == f_calc_p1.anomalous_flag()
  fast_terms = translation_search.fast_terms(
    gridding=gridding,
    anomalous_flag=f_obs.anomalous_flag(),
    miller_indices_p1_f_calc=f_calc_p1.indices(),
    p1_f_calc=f_calc_p1.data())
  for squared_flag in (False, True):
    map = fast_terms.summation(
      space_group=f_obs.space_group(),
      miller_indices_f_obs=f_obs.indices(),
      m=m,
      f_part=f_part,
      squared_flag=squared_flag).fft().accu_real_copy()
    assert map.all() == gridding
    map_stats = maptbx.statistics(map)
    if (0 or verbose):
      map_stats.show_summary()
    grid_tags.build(f_obs.space_group_info().type(), symmetry_flags)
    assert grid_tags.n_grid_misses() == 0
    assert grid_tags.verify(map)
    for i_sample in range(n_sample_grid_points):
      run_away_counter = 0
      while 1:
        run_away_counter += 1
        assert run_away_counter < 1000
        if (i_sample == 0 and test_origin):
          grid_point = [0,0,0]
        else:
          grid_point = [random.randrange(g) for g in gridding]
        grid_site = [float(x)/g for x,g in zip(grid_point,gridding)]
        structure_shifted = structure_fixed.deep_copy_scatterers()
        assert structure_shifted.special_position_indices().size() == 0
        structure_shifted.add_scatterers(
          scatterers=structure_p1.apply_shift(grid_site).scatterers())
        if (structure_shifted.special_position_indices().size() == 0):
          break
        if (test_origin):
          assert i_sample != 0
      i_grid = flex.norm(f_obs.structure_factors_from_scatterers(
        xray_structure=structure_shifted, algorithm="direct").f_calc().data())
      if (squared_flag): p = 4
      else: p = 2
      map_value = map[grid_point] * f_obs.space_group().n_ltr()**p
      if (not squared_flag):
        sum_m_i_grid = flex.sum(m * i_grid)
      else:
        sum_m_i_grid = flex.sum(m * flex.pow2(i_grid))
      assert "%.6g" % sum_m_i_grid == "%.6g" % map_value, (
        sum_m_i_grid, map_value)

def run_fast_nv1995(f_obs, f_calc_fixed, f_calc_p1,
                    symmetry_flags, gridding, grid_tags, verbose):
  if (f_calc_fixed is None):
    f_part = flex.complex_double()
  else:
    f_part = f_calc_fixed.data()
  assert f_obs.anomalous_flag() == f_calc_p1.anomalous_flag()
  fast_nv1995 = translation_search.fast_nv1995(
    gridding=gridding,
    space_group=f_obs.space_group(),
    anomalous_flag=f_obs.anomalous_flag(),
    miller_indices_f_obs=f_obs.indices(),
    f_obs=f_obs.data(),
    f_part=f_part,
    miller_indices_p1_f_calc=f_calc_p1.indices(),
    p1_f_calc=f_calc_p1.data())
  assert fast_nv1995.target_map().all() == gridding
  map_stats = maptbx.statistics(fast_nv1995.target_map())
  if (0 or verbose):
    map_stats.show_summary()
  grid_tags.build(f_obs.space_group_info().type(), symmetry_flags)
  assert grid_tags.n_grid_misses() == 0
  assert grid_tags.verify(fast_nv1995.target_map())
  peak_list = maptbx.peak_list(
    data=fast_nv1995.target_map(),
    tags=grid_tags.tag_array(),
    peak_search_level=1,
    max_peaks=10,
    interpolate=True)
  if (0 or verbose):
    print("gridding:", gridding)
    for i,site in enumerate(peak_list.sites()):
      print("(%.4f,%.4f,%.4f)" % site, "%.6g" % peak_list.heights()[i])
  assert approx_equal(map_stats.max(), flex.max(peak_list.grid_heights()))
  return peak_list

def test_atom(space_group_info, use_primitive_setting,
              n_elements=3, d_min=3.,
              grid_resolution_factor=0.48, max_prime=5, verbose=0):
  if (use_primitive_setting):
    space_group_info = space_group_info.primitive_setting()
  structure = random_structure.xray_structure(
    space_group_info,
    n_scatterers=n_elements,
    volume_per_atom=150,
    min_distance=1.,
    general_positions_only=True)
  miller_set_f_obs = miller.build_set(
    crystal_symmetry=structure,
    anomalous_flag=(random.random() < 0.5),
    d_min=d_min)
  symmetry_flags = translation_search.symmetry_flags(
    is_isotropic_search_model=True,
    have_f_part=(n_elements>=2))
  gridding = miller_set_f_obs.crystal_gridding(
    symmetry_flags=symmetry_flags,
    resolution_factor=grid_resolution_factor,
    max_prime=max_prime).n_real()
  structure.build_scatterers(
    elements=["Se"]*n_elements,
    grid=gridding)
  if (0 or verbose):
    structure.show_summary().show_scatterers()
  f_obs = abs(miller_set_f_obs.structure_factors_from_scatterers(
    xray_structure=structure,
    algorithm="direct").f_calc())
  if (0 or verbose):
    f_obs.show_summary()
  if (0 or verbose):
    f_obs.show_array()
  miller_set_p1 = miller.set.expand_to_p1(f_obs)
  special_position_settings_p1 = crystal.special_position_settings(
    crystal_symmetry=miller_set_p1)
  structure_fixed = xray.structure(special_position_settings=structure)
  for scatterer in structure.scatterers():
    structure_p1 = xray.structure(
      special_position_settings=special_position_settings_p1)
    scatterer_at_origin = scatterer.customized_copy(site=(0,0,0))
    structure_p1.add_scatterer(scatterer_at_origin)
    if (0 or verbose):
      structure_p1.show_summary().show_scatterers()
    f_calc_p1 = miller_set_p1.structure_factors_from_scatterers(
      xray_structure=structure_p1,
      algorithm="direct").f_calc()
    if (0 or verbose):
      f_calc_p1.show_array()
    f_calc_fixed = None
    if (structure_fixed.scatterers().size() > 0):
      f_calc_fixed = f_obs.structure_factors_from_scatterers(
        xray_structure=structure_fixed,
        algorithm="direct").f_calc()
    symmetry_flags = translation_search.symmetry_flags(
      is_isotropic_search_model=True,
      have_f_part=(f_calc_fixed is not None))
    if (structure_fixed.scatterers().size() <= 1):
      gridding = miller_set_f_obs.crystal_gridding(
        symmetry_flags=symmetry_flags,
        resolution_factor=grid_resolution_factor,
        max_prime=max_prime).n_real()
      grid_tags = maptbx.grid_tags(gridding)
    run_fast_terms(
      structure_fixed, structure_p1,
      f_obs, f_calc_fixed, f_calc_p1,
      symmetry_flags, gridding, grid_tags,
      verbose=verbose)
    peak_list = run_fast_nv1995(
      f_obs, f_calc_fixed, f_calc_p1,
      symmetry_flags, gridding, grid_tags, verbose)
    structure_fixed.add_scatterer(scatterer)
    if (0 or verbose):
      structure_fixed.show_summary().show_scatterers()
    if (structure_fixed.scatterers().size() < n_elements):
      assert peak_list.heights()[0] < 1
    else:
      assert peak_list.heights()[0] > 0.99
  assert peak_list.heights()[0] > 0.99

def test_molecule(space_group_info, use_primitive_setting, flag_f_part,
                  d_min=3., grid_resolution_factor=0.48, max_prime=5,
                  verbose=0):
  if (use_primitive_setting):
    space_group_info = space_group_info.primitive_setting()
  elements = ("N", "C", "C", "O", "N", "C", "C", "O")
  structure = random_structure.xray_structure(
    space_group_info,
    elements=elements,
    volume_per_atom=50,
    min_distance=1.,
    general_positions_only=True,
    random_u_iso=True,
    random_occupancy=True)
  if (0 or verbose):
    structure.show_summary().show_scatterers()
  miller_set_f_obs = miller.build_set(
    crystal_symmetry=structure,
    anomalous_flag=(random.random() < 0.5),
    d_min=d_min)
  f_obs = abs(miller_set_f_obs.structure_factors_from_scatterers(
    xray_structure=structure,
    algorithm="direct").f_calc())
  if (0 or verbose):
    f_obs.show_summary()
  if (0 or verbose):
    f_obs.show_array()
  miller_set_p1 = miller.set.expand_to_p1(f_obs)
  special_position_settings_p1 = crystal.special_position_settings(
    crystal_symmetry=miller_set_p1)
  structure_p1 = xray.structure(
    special_position_settings=special_position_settings_p1)
  structure_fixed = xray.structure(special_position_settings=structure)
  for scatterer in structure.scatterers():
    if (flag_f_part and   structure_fixed.scatterers().size()
                        < structure.scatterers().size()//2):
      structure_fixed.add_scatterer(scatterer)
    else:
      structure_p1.add_scatterer(scatterer)
  if (0 or verbose):
    if (flag_f_part):
      structure_fixed.show_summary().show_scatterers()
    structure_p1.show_summary().show_scatterers()
  f_calc_fixed = None
  if (flag_f_part):
    f_calc_fixed = f_obs.structure_factors_from_scatterers(
      xray_structure=structure_fixed,
      algorithm="direct").f_calc()
  f_calc_p1 = miller_set_p1.structure_factors_from_scatterers(
    xray_structure=structure_p1,
    algorithm="direct").f_calc()
  symmetry_flags = translation_search.symmetry_flags(
    is_isotropic_search_model=False,
    have_f_part=flag_f_part)
  gridding = miller_set_f_obs.crystal_gridding(
    symmetry_flags=symmetry_flags,
    resolution_factor=grid_resolution_factor,
    max_prime=max_prime).n_real()
  grid_tags = maptbx.grid_tags(gridding)
  run_fast_terms(
    structure_fixed, structure_p1,
    f_obs, f_calc_fixed, f_calc_p1,
    symmetry_flags, gridding, grid_tags,
    test_origin=True,
    verbose=verbose)
  peak_list = run_fast_nv1995(
    f_obs, f_calc_fixed, f_calc_p1,
    symmetry_flags, gridding, grid_tags, verbose)
  assert peak_list.heights()[0] > 0.99

def test_shift(space_group_info,
               d_min=0.8, grid_resolution_factor=0.48, max_prime=5,
               verbose=0):
  n = 12 // len(space_group_info.group()) or 1
  target_structure = random_structure.xray_structure(
    space_group_info=space_group_info,
    elements=['C']*n,
    use_u_iso=False,
    use_u_aniso=False,
  )
  f_target = miller.build_set(
    crystal_symmetry=target_structure,
    anomalous_flag=False,
    d_min=d_min
  ).structure_factors_from_scatterers(
    xray_structure=target_structure,
    algorithm="direct").f_calc()
  f_obs = abs(f_target)

  indices_in_p1 = miller.set.expand_to_p1(f_target)
  target_structure_in_p1 = target_structure.expand_to_p1()

  reference_translation = matrix.col((0.1, 0.2, 0.7))
  structure_in_p1 = target_structure_in_p1.apply_shift(reference_translation)
  f_structure_in_p1 = indices_in_p1.structure_factors_from_scatterers(
    xray_structure=structure_in_p1,
    algorithm="direct").f_calc()

  symmetry_flags = translation_search.symmetry_flags(
    is_isotropic_search_model=False,
    have_f_part=False)
  gridding = f_target.crystal_gridding(
    symmetry_flags=symmetry_flags,
    resolution_factor=grid_resolution_factor,
    max_prime=max_prime).n_real()
  grid_tags = maptbx.grid_tags(gridding)
  for f_calc_in_p1 in (f_structure_in_p1,):
    peak_list = run_fast_nv1995(
      f_obs=f_obs, f_calc_fixed=None, f_calc_p1=f_calc_in_p1,
      symmetry_flags=symmetry_flags, gridding=gridding,
      grid_tags=grid_tags, verbose=verbose)
    assert peak_list.heights()[0] > 0.9
    shift = matrix.col(peak_list.sites()[0])
    assert f_target.space_group_info().is_allowed_origin_shift(
      shift + reference_translation, tolerance=0.04)

def run_call_back(flags, space_group_info):
  if (space_group_info.group().order_p() > 24 and not flags.HighSymmetry):
    print("High symmetry space group skipped.")
    return
  if (not (flags.Atom or flags.Molecule or flags.Shift)):
    flags.Atom = True
    flags.Molecule = True
  use_primitive_setting_flags = [False]
  if (space_group_info.group().conventional_centring_type_symbol() != "P"):
    use_primitive_setting_flags.append(True)
  if (flags.Atom):
    for use_primitive_setting in use_primitive_setting_flags:
      test_atom(space_group_info, use_primitive_setting,
                verbose=flags.Verbose)
  if (flags.Molecule):
    for flag_f_part in (False, True)[:]: #SWITCH
      for use_primitive_setting in use_primitive_setting_flags:
        test_molecule(space_group_info, use_primitive_setting, flag_f_part,
                      verbose=flags.Verbose)
  if flags.Shift:
    for i in range(1):
      test_shift(space_group_info, verbose=flags.Verbose)

def run():
  debug_utils.parse_options_loop_space_groups(sys.argv[1:], run_call_back, (
    "HighSymmetry",
    "Atom",
    "Molecule",
    "Shift"))

if (__name__ == "__main__"):
  run()


 *******************************************************************************


 *******************************************************************************
cctbx/regression/tst_fcalc_fft_stability.py
from __future__ import absolute_import, division, print_function
import time
import iotbx.pdb
from cctbx import maptbx
from libtbx.test_utils import approx_equal
import sys

def exercise1():
  """
  Exercise to see how much values on generated map are different on
  different platforms
  """
  pdb_str="""
CRYST1   10.000  10.000   10.000  90.00  90.00  90.00 P 4
HETATM    1  C    C      1       2.000   2.000   2.000  1.00 20.00           C
HETATM    2  C    C      2       4.000   4.000   4.000  1.00 20.00           C
END
"""

  pdb_inp = iotbx.pdb.input(source_info=None, lines=pdb_str)
  xrs = pdb_inp.xray_structure_simple()
  # xrs.show_summary()
  d_min = 1.
  fc = xrs.structure_factors(d_min=d_min).f_calc()
  symmetry_flags = maptbx.use_space_group_symmetry
  fftmap = fc.fft_map(symmetry_flags = symmetry_flags)
  rmup = fftmap.real_map_unpadded()
  nx, ny, nz = rmup.accessor().all() # 32,32,32
  if not approx_equal((nx,ny,nz), (32,32,32)):
    print('Even map dimensions are different???:', file=sys.stderr)
    print('  ', (nx, ny, nz), file=sys.stderr)
    print('  ', (32,32,32), file=sys.stderr)

  # print('dimensions:', nx,ny,nz)
  # min, max and mean values on the map
  mmm = rmup.as_1d().min_max_mean().as_tuple()

  # Mac results:
  mac_results = [[(6,6,7),   1411.8],
                 [(6,6,8),   1026.0],
                 [(0,0,0),    -23.3],
                 [(31,31,31), -23.9],
                ]

  if not approx_equal(mmm, (-25.5, 1531.7, 0.), 1):
    print('approx_equal failed:', file=sys.stderr)
    print('  ', mmm, file=sys.stderr)
    print('  ', (-25.5, 1531.7, 0.), file=sys.stderr)
  for coord, value in mac_results:
    if not approx_equal(rmup[coord], value, 1):
      print('approx_equal failed:', file=sys.stderr)
      print('  ', rmup[coord], file=sys.stderr)
      print('  ', value, file=sys.stderr)

if __name__ == "__main__":
  t0 = time.time()
  exercise1()
  print("OK time =%8.3f"%(time.time() - t0))


 *******************************************************************************


 *******************************************************************************
cctbx/regression/tst_find_best_cell.py
from __future__ import absolute_import, division, print_function
from cctbx.crystal.find_best_cell import alternative_find_best_cell as fbc
from cctbx import crystal
from cctbx import uctbx
from cctbx import sgtbx
from libtbx.test_utils import approx_equal
from six.moves import zip

def tst_find_best_cell():
  uc_array=[ uctbx.unit_cell( '40, 50, 60, 90, 90, 90' ),
             uctbx.unit_cell( '40, 60, 50, 90, 90, 90' ),
             uctbx.unit_cell( '50, 40, 60, 90, 90, 90' ),
             uctbx.unit_cell( '50, 60, 40, 90, 90, 90' ),
             uctbx.unit_cell( '60, 40, 50, 90, 90, 90' ),
             uctbx.unit_cell( '60, 50, 40, 90, 90, 90' ) ]

  uc_correct = [ uctbx.unit_cell( '40, 50, 60, 90, 90, 90' ),
                 uctbx.unit_cell( '40, 60, 50, 90, 90, 90' ),
                 uctbx.unit_cell( '40, 50, 60, 90, 90, 90' ),
                 uctbx.unit_cell( '50, 60, 40, 90, 90, 90' ),
                 uctbx.unit_cell( '40, 60, 50, 90, 90, 90' ),
                 uctbx.unit_cell( '50, 60, 40, 90, 90, 90' ) ]

  sg_info =  sgtbx.space_group_info( 'P 21 21 2' )
  sg_info_2 = sgtbx.space_group_info( 'I 21 21 21' )

  sg = sg_info.group()
  sg_2 = sg_info_2.group()

  for uc, correct in zip(uc_array,uc_correct):
    best_cell_finder = fbc( uc, sg )
    assert approx_equal( correct.parameters(),
                         best_cell_finder.return_best_cell().parameters() )

    cb_op = best_cell_finder.return_change_of_basis_op_to_best_cell()
    xs = crystal.symmetry( uc, space_group=sg)
    assert approx_equal( correct.parameters(),
                         xs.change_basis(cb_op).unit_cell().parameters() )


    best_cell_finder = fbc( uc, sg_2 )
    assert approx_equal( uc_array[0].parameters(),
                         best_cell_finder.return_best_cell().parameters() )

    xs = crystal.symmetry( uc, space_group=sg_2)
    cb_op = best_cell_finder.return_change_of_basis_op_to_best_cell()
    assert approx_equal( uc_array[0].parameters(),
                         xs.change_basis(cb_op).unit_cell().parameters() )

  # test with incomming sg not in reference setting
  uc = uctbx.unit_cell( '60, 40, 30, 90, 90, 90' )
  sg_info_3 = sgtbx.space_group_info( 'P 1 1 21' )
  sg_3 = sg_info_3.group()
  best_cell_finder =  fbc( uc, sg_3 )
  xs_best =  best_cell_finder.return_best_xs()

  uc_correct = uctbx.unit_cell( '40, 30, 60, 90, 90, 90' )
  sg_correct = sgtbx.space_group_info( 'P 1 21 1' ).group()
  assert approx_equal(  xs_best.unit_cell().parameters(),
                        uc_correct.parameters() )
  assert sg_correct == xs_best.space_group()

def run():
  tst_find_best_cell()
  print("OK")

run()


 *******************************************************************************


 *******************************************************************************
cctbx/regression/tst_fourier_transform_real_part_at_x.py
from __future__ import absolute_import, division, print_function
from six.moves import zip
def set_up_random_structure(space_group_info):
  from cctbx.development import random_structure
  xray_structure = random_structure.xray_structure(
    space_group_info       = space_group_info,
    elements               =("O", "P")*4,
    volume_per_atom        = 100,
    min_distance           = 1.5,
    general_positions_only = True,
    random_u_iso           = True,
    random_occupancy       = True)
  xray_structure.scattering_type_registry(table="wk1995")
  return xray_structure

def map_value_at_sites(structure):
  densities = []
  f_calc = structure.structure_factors(d_min = 1.0).f_calc()
  phenix_fft_map = f_calc.fft_map(resolution_factor=1/6)
  phenix_fft_map.apply_volume_scaling()
  map_3d = phenix_fft_map.real_map_unpadded()
  for scatterer in structure.scatterers():
    densities.append(map_3d.eight_point_interpolation(scatterer.site))
  return densities

def map_value_at_sites_calculated(structure):
  densities = []
  f_calc = structure.structure_factors(d_min = 1.0).f_calc() \
    .generate_bijvoet_mates() \
    .expand_to_p1()
  v = f_calc.unit_cell().volume()
  for scatterer in structure.scatterers():
    rho = f_calc.indices().fourier_transform_real_part_at_x(
      fourier_coeffs=f_calc.data(), x=scatterer.site)
    densities.append(rho/v)
  return densities

def run_call_back(flags, space_group_info):
  structure = set_up_random_structure(space_group_info)
  if (flags.Verbose):
    structure.scattering_type_registry().show()
  rho_at_sites_from_phenix_fft_map = map_value_at_sites(structure)
  rho_at_sites_calculated = map_value_at_sites_calculated(structure)
  for scatterer,rf,rc in zip(
        structure.scatterers(),
        rho_at_sites_from_phenix_fft_map,
        rho_at_sites_calculated):
     if (flags.Verbose):
       print(numstr(scatterer.site), "%.3f" % rf, "%.3f" % rc)
  from scitbx.array_family import flex
  corr = flex.linear_correlation(
    flex.double(rho_at_sites_from_phenix_fft_map),
    flex.double(rho_at_sites_calculated))
  assert corr.is_well_defined
  cc = corr.coefficient()
  if (flags.Verbose):
    print("Correlation coefficient:", cc)
  from libtbx.test_utils import is_above_limit
  assert is_above_limit(value=cc, limit=0.99)
  if (flags.Verbose):
    print()

def run(args):
  from scitbx.array_family import flex
  import random
  random.seed(0)
  flex.set_random_seed(0)
  from cctbx.development import debug_utils
  debug_utils.parse_options_loop_space_groups(args, run_call_back)

if (__name__ == "__main__"):
  import sys
  run(args=sys.argv[1:])


 *******************************************************************************


 *******************************************************************************
cctbx/regression/tst_french_wilson.py
from __future__ import absolute_import, division, print_function
from cctbx import french_wilson
from cctbx.development import random_structure
from scitbx.array_family import flex
import boost_adaptbx.boost.python as bp
from six.moves import zip
fw_ext = bp.import_ext("cctbx_french_wilson_ext")
from libtbx.utils import null_out, Sorry
from libtbx.test_utils import Exception_expected
import random

def exercise_00():
  x = flex.random_double(1000)
  y = flex.random_double(1000)
  xa = flex.double()
  ya = flex.double()
  ba = flex.bool()
  for x_, y_ in zip(x,y):
    scale1 = random.choice([1.e-6, 1.e-3, 0.1, 1, 1.e+3, 1.e+6])
    scale2 = random.choice([1.e-6, 1.e-3, 0.1, 1, 1.e+3, 1.e+6])
    b = random.choice([True, False])
    x_ = x_*scale1
    y_ = y_*scale2
    v1 = fw_ext.expectEFW(eosq=x_, sigesq=y_, centric=b)
    v2 = fw_ext.expectEsqFW(eosq=x_, sigesq=y_, centric=b)
    assert type(v1) == type(1.)
    assert type(v2) == type(1.)
    xa.append(x_)
    ya.append(y_)
    ba.append(b)
  fw_ext.is_FrenchWilson(F=xa, SIGF=ya, is_centric=ba, eps=0.001)

def exercise_01():
  """
  Sanity check - don't crash when mean intensity for a bin is zero.
  """
  xrs = random_structure.xray_structure(
    unit_cell=(50,50,50,90,90,90),
    space_group_symbol="P1",
    n_scatterers=1200,
    elements="random")
  fc = abs(xrs.structure_factors(d_min=1.5).f_calc())
  fc = fc.set_observation_type_xray_amplitude()
  cs = fc.complete_set(d_min=1.4)
  ls = cs.lone_set(other=fc)
  f_zero = ls.array(data=flex.double(ls.size(), 0))
  f_zero.set_observation_type_xray_amplitude()
  fc = fc.concatenate(other=f_zero)
  sigf = flex.double(fc.size(), 0.1) + (fc.data() * 0.03)
  fc = fc.customized_copy(sigmas=sigf)
  try :
    fc_fc = french_wilson.french_wilson_scale(miller_array=fc, log=null_out())
  except Sorry :
    pass
  else :
    raise Exception_expected
  ic = fc.f_as_f_sq().set_observation_type_xray_intensity()
  fc_fc = french_wilson.french_wilson_scale(miller_array=ic, log=null_out())

if (__name__ == "__main__"):
  exercise_00()
  exercise_01()
  print("OK")


 *******************************************************************************


 *******************************************************************************
cctbx/regression/tst_geometry_restraints.py
from __future__ import absolute_import, division, print_function
from iotbx.pdb.tst_pdb import dump_pdb
from cctbx import geometry_restraints
from iotbx.pymol import pml_stick, pml_write
from cctbx.array_family import flex
from scitbx.matrix import col, sqr
from scitbx.math import euler_angles_as_matrix
from libtbx.test_utils import approx_equal, not_approx_equal
import random
import sys
from six.moves import range
from six.moves import zip

if (1): # fixed random seed to avoid rare failures
  random.seed(0)
  flex.set_random_seed(0)

class residual_functor(object):

  def __init__(self, restraint_type, **keyword_arguments):
    assert "sites" not in keyword_arguments
    self.restraint_type = restraint_type
    self.keyword_arguments = keyword_arguments

  def __call__(self, sites):
    self.keyword_arguments["sites"] = sites
    return self.restraint_type(**self.keyword_arguments).residual()
    del self.keyword_arguments["sites"]

def finite_differences(sites, residual_obj, eps=1.e-6):
  sites_mod = sites[:]
  gradients = []
  for i_site,site in enumerate(sites):
    grad = []
    for i_x in range(3):
      t = []
      for signed_eps in [eps, -eps]:
        add = [0]*3
        add[i_x] = signed_eps
        sites_mod[i_site] = site + col(add)
        r = residual_obj(sites_mod)
        t.append(r)
        sites_mod[i_site] = site
      grad.append((t[0]-t[1])/(2*eps))
    gradients.append(grad)
  return gradients

def exercise_bond():
  for i_trial in range(5):
    sites = random_sites(n_sites=2)
    b = geometry_restraints.bond(sites=sites, distance_ideal=0, weight=0)
    distance_ideal = b.distance_model
    sigma = distance_ideal * 0.01
    weight = 1 / sigma**2
    residual_obj = residual_functor(
      restraint_type=geometry_restraints.bond,
      distance_ideal=distance_ideal,
      weight=weight)
    for i_pert in range(5):
      if (i_pert == 0):
        sites_mod = sites
      else:
        sites_mod = []
        for site in sites:
          shift = col([random.uniform(-3,3)*sigma for i in range(3)])
          sites_mod.append(site+shift)
      b = geometry_restraints.bond(
        sites=sites_mod, distance_ideal=distance_ideal, weight=weight)
      ag = b.gradients()
      fg = finite_differences(sites_mod, residual_obj)
      for analytical,finite in zip(ag,fg):
        assert approx_equal(analytical, finite)

def exercise_nonbonded(nonbonded_type, repulsion_function):
  for i_trial in range(5):
    sites = random_sites(n_sites=2)
    r = nonbonded_type(
      sites=sites,
      vdw_distance=1,
      function=repulsion_function)
    vdw_distance = r.delta
    residual_obj = residual_functor(
      restraint_type=nonbonded_type,
      vdw_distance=vdw_distance,
      function=repulsion_function)
    for i_pert in range(5):
      if (i_pert == 0):
        sites_mod = sites
      else:
        sites_mod = []
        for site in sites:
          shift = col([random.uniform(-1,1)*vdw_distance*0.05
            for i in range(3)])
          sites_mod.append(site+shift)
      r = nonbonded_type(
        sites=sites_mod,
        vdw_distance=vdw_distance,
        function=repulsion_function)
      if (   not hasattr(repulsion_function, "irexp")
          or repulsion_function.irexp <= 2
          or not_approx_equal(r.residual(), 0)):
        fg = flex.vec3_double(finite_differences(sites_mod, residual_obj)) \
          .as_double()
        ag = flex.vec3_double(r.gradients()).as_double()
        scale = max(1, flex.mean(flex.abs(fg)))
        assert approx_equal(ag/scale, fg/scale, eps=1.e-2)
  sites = [[0,0,0], [0,0,0]]
  vdw_distance = 1.8
  for i_step in range(1,100):
    delta = i_step/50.
    sites[1][0] = delta
    r = nonbonded_type(
      sites=[col(site) for site in sites],
      vdw_distance=vdw_distance,
      function=repulsion_function)
    assert approx_equal(delta, r.delta)

def exercise_angle():
  eps = 1
  n_trials = 20
  for i_trial in range(n_trials):
    if (i_trial < -99):
      if (i_trial == n_trials-1):
        eps = 0
      else:
        eps *= 0.1
      sites = [col(site) for site in [(-1,0,0),(0,0,0),(1,eps,0)]]
      angle_ideal = 170
    else:
      while 1:
        sites = random_sites(n_sites=3)
        angle_ideal = geometry_restraints.angle(
          sites, angle_ideal=0, weight=0).angle_model
        if (angle_ideal > 10):
          break
    sigma = angle_ideal * 0.1
    weight = 1 / sigma**2
    residual_obj = residual_functor(
      restraint_type=geometry_restraints.angle,
      angle_ideal=angle_ideal,
      weight=weight)
    for i_pert in range(5):
      if (i_pert == 0):
        sites_mod = sites
      else:
        sites_mod = []
        for site in sites:
          shift = col([random.uniform(3,3)*sigma for i in range(3)])
          sites_mod.append(site+shift)
      a = geometry_restraints.angle(
        sites=sites_mod, angle_ideal=angle_ideal, weight=weight)
      if (eps != 0):
        ag = a.gradients()
      fg = finite_differences(sites_mod, residual_obj)
      if (eps == 0):
        for finite in fg:
          print(finite)
          print()
      else:
        for analytical,finite in zip(ag,fg):
          if (0):
            print(analytical)
            print(finite)
          if (0):
            for x,y in zip(analytical, finite):
              if (y == 0): print(None, end=' ')
              else: print(x/y, end=' ')
            print()
          if (0):
            print()
          assert approx_equal(analytical, finite,
                              eps=max(1.e-6,max(analytical)*1.e-6))

def random_site(max_coordinate):
  return col([random.uniform(-max_coordinate, max_coordinate)
    for i in range(3)])

def random_sites(n_sites, max_coordinate=10, min_distance=0.5,
                 max_trials=1000):
  sites = []
  run_away_counter = 0
  while 1:
    run_away_counter += 1
    assert run_away_counter < max_trials
    new_site = random_site(max_coordinate)
    ok = True
    for site in sites:
      if ((new_site-site).norm_sq() < min_distance**2):
        ok = False
        break
    if (ok):
      sites.append(new_site)
      run_away_counter = 0
      if (len(sites) == n_sites):
        break
  return sites

def exercise_dihedral_core(sites, angle_ideal, angle_esd, periodicity,
                                  angle_model):
  assert periodicity > 0
  for signed_periodicity in [periodicity, -periodicity]:
    dih = geometry_restraints.dihedral(
      sites=sites,
      angle_ideal=angle_ideal,
      weight=1./angle_esd**2,
      periodicity=signed_periodicity)
    if (angle_model is not None):
      assert approx_equal(angle_model, dih.angle_model)
    ag = flex.vec3_double(dih.gradients())
    residual_obj = residual_functor(
      restraint_type=geometry_restraints.dihedral,
      angle_ideal=dih.angle_ideal,
      weight=dih.weight,
      periodicity=signed_periodicity)
    fg = flex.vec3_double(finite_differences(sites, residual_obj)).as_double()
    ag = ag.as_double()
    scale = max(1, flex.mean(flex.abs(fg)))
    assert approx_equal(ag/scale, fg/scale)

def exercise_dihedral():
  sites = [col(site) for site in [
    (1,0,0), (0,0,0), (0,1,0), (1,0,1)]]
  angle_ideal = -45
  for flip in range(2):
    if (flip != 0):
      sites = [sites[i] for i in [0,2,1,3]]
      angle_ideal *= -1
    dih = geometry_restraints.dihedral(
      sites=sites,
      angle_ideal=angle_ideal,
      weight=1)
    assert approx_equal(dih.angle_ideal, angle_ideal)
    assert approx_equal(dih.angle_model, angle_ideal)
    assert approx_equal(dih.delta, 0)
    for i_trial in range(20):
      sites_mod = []
      for site in sites:
        shift = col([random.uniform(-.1,.1) for i in range(3)])
        sites_mod.append(site+shift)
      exercise_dihedral_core(
        sites_mod, angle_ideal, angle_esd=1, periodicity=1, angle_model=None)
  for sites,angle_ideal,angle_esd,period,angle_model in dihedral_test_data:
    sites = [col(site) for site in sites]
    exercise_dihedral_core(
      sites, angle_ideal, angle_esd, period, angle_model)

def improper_permutation(sites):
  return [sites[0], sites[1], sites[3], sites[2]]

def exercise_chirality(verbose=0):
  # monomer library: CA N CB C
  sites = [col(site) for site in [
    (27.660, 9.903, 2.078),
    (28.049, 9.675, 3.486),
    (28.183, 11.269, 1.625),
    (28.085, 8.759, 1.165)]]
  chir = geometry_restraints.chirality(
    sites=sites,
    volume_ideal=-2.48,
    both_signs=False,
    weight=1)
  assert approx_equal(chir.volume_model, -2.411548478)
  assert approx_equal(chir.residual(), 0.00468561086412)
  dih = geometry_restraints.dihedral(
    sites=improper_permutation(sites),
    angle_ideal=35.26439,
    weight=1)
  assert approx_equal(dih.angle_model, 32.2587249641)
  assert approx_equal(dih.residual(), 9.03402230782)
  if (verbose):
    dump_pdb("sites.pdb", sites)
    print("volume_ideal:", chir.volume_ideal)
    print("volume_model:", chir.volume_model)
    print("angle_ideal:", dih.angle_ideal)
    print("angle model:", dih.angle_model)
  for i_trial in range(50):
    volume_ideal = chir.volume_ideal
    for both_signs in [False, True]:
      sites_mod = []
      for site in sites:
        shift = col([random.uniform(-.5,.5) for i in range(3)])
        sites_mod.append(site+shift)
      if (both_signs): volume_ideal = abs(volume_ideal)
      c = geometry_restraints.chirality(
        sites=sites_mod,
        volume_ideal=volume_ideal,
        both_signs=both_signs,
        weight=500*1/0.2**2)
      residual_obj = residual_functor(
        restraint_type=geometry_restraints.chirality,
        volume_ideal=c.volume_ideal,
        both_signs=c.both_signs,
        weight=c.weight)
      fg = flex.vec3_double(
        finite_differences(sites_mod, residual_obj)).as_double()
      ag = flex.vec3_double(
        c.gradients()).as_double()
      scale = max(1, flex.mean(flex.abs(fg)))
      assert approx_equal(ag/scale, fg/scale)
      d = geometry_restraints.dihedral(
        sites=improper_permutation(sites_mod),
        angle_ideal=dih.angle_ideal,
        weight=750)
      ag_dih = dih.gradients()
      if (verbose and i_trial == 0 and not both_signs):
        dump_pdb("sites_mod.pdb", sites_mod)
        max_g_len = 0
        for g in ag_dih:
          max_g_len = max(max_g_len, abs(col(g)))
        for g in flex.vec3_double(fg):
          max_g_len = max(max_g_len, abs(col(g)))
        sticks = []
        for site,g in zip(improper_permutation(sites_mod),ag_dih):
          sticks.append(
            pml_stick(
              begin=site,
              end=site+col(g)/max_g_len,
              colors=[[1,0,0]]*2,
              width=0.01))
        pml_write(f=open("dih.pml", "w"), label="dih", sticks=sticks)
        sticks = []
        for site,g in zip(sites_mod,flex.vec3_double(fg)):
          sticks.append(
            pml_stick(
              begin=site,
              end=site+col(g)/max_g_len,
              colors=[[0,1,0]]*2,
              width=0.01))
        pml_write(f=open("chir.pml", "w"), label="chir", sticks=sticks)

def exercise_planarity():
  weights = flex.double([1,2,3,4])
  for points,norm in [([(1,1,0), (-1,-1,0), (-1,1,0), (1,-1,0)], (0,0,1)),
                      ([(0,1,1), (0,-1,-1), (0,-1,1), (0,1,-1)], (1,0,0)),
                      ([(1,0,1), (-1,0,-1), (-1,0,1), (1,0,-1)], (0,1,0)),
                      ([(1,1,-1), (-1,-1,1), (-1,1,-1), (1,-1,1)], (0,1,1))]:
    norm = col(norm)
    norm /= abs(norm)
    for i_trial in range(5):
      for i_pert in range(5):
        if (i_trial == 0 and i_pert == 0):
          sites = [col(v) for v in points]
          rot_norm = norm
        else:
          shift = col([random.uniform(-10,10) for i in range(3)])
          rot = sqr(euler_angles_as_matrix(
            [random.uniform(0,360) for i in range(3)]))
          rot_norm = rot * norm
          if (i_pert == 0):
            sites = [rot*col(v)+shift for v in points]
          else:
            sites = []
            for v in points:
              f = 0.1
              pert = col([(random.random()-0.5)*f for i in range(3)])
              sites.append(rot*col(v)+shift+pert)
        pl = geometry_restraints.planarity(sites=sites, weights=weights)
        n = col(pl.normal())
        gradients_analytical = pl.gradients()
        if (i_pert == 0):
          assert abs(abs(n.dot(rot_norm))-1) < 1.e-5
          assert approx_equal(pl.residual(), 0)
          for grad in gradients_analytical:
            assert approx_equal(grad, [0,0,0])
        assert approx_equal(pl.residual(), pl.lambda_min())
        residual_obj = residual_functor(
          restraint_type=geometry_restraints.planarity,
          weights=weights)
        gradients_finite = finite_differences(sites, residual_obj)
        assert approx_equal(gradients_finite, gradients_analytical)

def exercise():
  exercise_bond()
  for irexp in [1,2,3,4,5]:
    for rexp in [3,4]:
      exercise_nonbonded(
        nonbonded_type=geometry_restraints.nonbonded_prolsq,
        repulsion_function=geometry_restraints.prolsq_repulsion_function(
          irexp=irexp,
          rexp=rexp))
  for irexp in [1,2,3,4,5]:
    exercise_nonbonded(
      nonbonded_type=geometry_restraints.nonbonded_inverse_power,
      repulsion_function=geometry_restraints.inverse_power_repulsion_function(
        nonbonded_distance_cutoff=1.e20,
        irexp=irexp))
  for exponent in [1,2,3]:
    exercise_nonbonded(
      nonbonded_type=geometry_restraints.nonbonded_cos,
      repulsion_function=geometry_restraints.cos_repulsion_function(
        max_residual=13,
        exponent=exponent))
  for norm_height_at_vdw_distance in [0.1,0.2,0.3]:
    exercise_nonbonded(
      nonbonded_type=geometry_restraints.nonbonded_gaussian,
      repulsion_function=geometry_restraints.gaussian_repulsion_function(
        max_residual=12,
        norm_height_at_vdw_distance=norm_height_at_vdw_distance))
  exercise_angle()
  exercise_dihedral()
  exercise_chirality(verbose="--verbose" in sys.argv[1:])
  exercise_planarity()
  print("OK")

dihedral_test_data = [
[[ [69.141,9.390,2.567],
[70.651,9.597,2.216],
[70.898,11.039,2.558],
[69.552,11.796,2.401],
], 35,15,3,-27.623156 ],
[[ [69.094,9.368,7.421],
[70.388,10.106,7.552],
[70.526,11.172,6.519],
[71.741,11.347,6.212],
], 0,30,2,-149.24817 ],
[[ [66.200,0.138,5.659],
[67.055,-1.079,5.550],
[68.451,-0.802,4.924],
[68.274,-0.562,3.439],
], 180,15,3,-73.186553 ],
[[ [67.330,-1.591,9.213],
[67.723,-0.520,10.245],
[69.155,0.070,10.088],
[70.080,-1.137,10.323],
], 180,15,3,-63.28745 ],
[[ [64.929,-1.607,9.124],
[63.628,-2.233,9.453],
[62.488,-1.199,9.105],
[61.125,-2.031,9.143],
], 180,15,3,166.85678 ],
[[ [70.128,2.016,15.960],
[70.973,2.866,16.769],
[71.244,4.032,15.846],
[70.108,4.001,14.818],
], -25,15,3,21.478587 ],
[[ [51.224,5.278,19.162],
[49.792,5.189,19.476],
[49.560,5.913,20.813],
[50.073,5.054,21.945],
], 180,15,3,-74.662005 ],
[[ [47.467,9.582,20.922],
[46.748,10.422,21.963],
[47.382,10.282,23.330],
[46.730,9.309,24.166],
], 180,15,3,-96.181112 ],
[[ [46.748,10.422,21.963],
[47.382,10.282,23.330],
[46.730,9.309,24.166],
[45.949,8.736,25.060],
], 0,15,4,-95.23452 ],
[[ [54.391,1.288,14.581],
[55.651,1.273,15.387],
[56.467,-0.004,15.273],
[55.681,-1.123,15.821],
], 180,15,3,-63.913454 ],
[[ [67.779,9.293,11.519],
[68.887,10.169,12.058],
[70.267,9.371,12.083],
[71.437,10.417,12.273],
], 180,15,3,164.95936 ],
[[ [74.272,17.569,20.340],
[74.302,18.830,21.056],
[73.048,19.608,20.974],
[72.642,20.465,21.916],
], 0,15,4,152.18051 ],
[[ [67.020,12.001,18.091],
[66.093,10.976,18.685],
[66.532,9.757,19.391],
[65.579,8.603,19.413],
], 60,15,3,-155.18126 ],
[[ [59.525,6.469,10.069],
[60.307,5.499,9.152],
[60.931,6.381,7.983],
[61.840,5.442,7.183],
], 180,15,3,173.24322 ],
[[ [54.325,-2.812,2.710],
[54.755,-1.497,2.220],
[54.490,-1.281,0.739],
[54.841,-2.246,-0.385],
], 180,15,3,-48.495407 ],
[[ [54.449,2.584,5.084],
[55.475,3.162,5.951],
[56.953,2.788,5.575],
[57.159,1.313,5.585],
], 180,15,3,-58.143716 ],
[[ [55.273,5.394,6.776],
[55.070,6.795,6.699],
[53.864,7.253,7.664],
[52.594,6.446,7.313],
], 180,15,3,-55.174556 ],
[[ [55.070,6.795,6.699],
[53.864,7.253,7.664],
[52.594,6.446,7.313],
[52.327,5.272,8.025],
], 90,20,2,93.499752 ],
[[ [59.901,2.524,-2.158],
[60.037,1.248,-1.326],
[60.057,1.643,0.158],
[60.110,0.416,1.003],
], 180,15,3,176.77171 ],
[[ [34.183,3.032,3.282],
[34.441,2.116,4.414],
[35.660,1.339,3.940],
[35.767,1.558,2.468],
], -25,15,3,-16.279611 ],
[[ [35.660,1.339,3.940],
[35.767,1.558,2.468],
[35.251,2.993,2.262],
[34.183,3.032,3.282],
], -30,15,3,-36.045859 ],
[[ [18.701,2.935,18.700],
[17.376,2.652,19.264],
[17.387,1.554,20.356],
[17.769,0.234,19.673],
], 180,15,3,-66.444499 ],
[[ [17.350,2.078,24.829],
[18.086,1.833,26.121],
[17.850,2.399,27.443],
[17.154,2.723,28.532],
], 0,15,4,53.638935 ],
[[ [15.882,6.548,24.854],
[15.228,7.545,25.766],
[16.213,8.309,26.673],
[17.715,8.339,26.304],
], 180,15,3,18.478984 ],
[[ [14.761,12.218,19.123],
[15.765,11.584,18.129],
[17.272,11.907,18.285],
[17.609,13.327,17.950],
], 180,15,3,-69.045664 ],
[[ [15.999,13.559,4.210],
[17.156,14.185,3.544],
[16.653,14.774,2.121],
[15.890,13.732,1.302],
], 180,15,3,-50.961962 ],
[[ [19.166,15.041,4.775],
[19.811,16.046,5.668],
[19.418,17.518,5.404],
[19.549,18.202,4.065],
], 180,15,3,-54.972852 ],
[[ [19.418,17.518,5.404],
[19.549,18.202,4.065],
[20.987,18.306,3.555],
[21.515,19.426,3.487],
], 0,30,2,-111.91728 ],
[[ [21.126,16.443,21.482],
[21.298,16.312,20.045],
[20.406,15.288,19.376],
[20.706,13.843,19.714],
], 180,15,3,-68.764347 ],
[[ [23.143,21.668,10.296],
[22.933,22.521,9.149],
[22.565,23.890,9.595],
[22.302,24.797,8.392],
], 180,15,3,-178.47172 ],
]

if (__name__ == "__main__"):
  exercise()


 *******************************************************************************


 *******************************************************************************
cctbx/regression/tst_geometry_restraints_2.py
from __future__ import absolute_import, division, print_function
from cctbx import geometry_restraints
from cctbx.geometry_restraints.distance_least_squares \
  import distance_and_repulsion_least_squares
import cctbx.geometry_restraints.manager
from cctbx import crystal
from cctbx.array_family import flex
from six.moves import cStringIO as StringIO
import libtbx.utils
from libtbx.test_utils import approx_equal, show_diff
import libtbx.load_env
import sys, os
from mmtbx.monomer_library import pdb_interpretation
from six.moves import range

# ============================================================
# Edit notes: show_interactions function is obsolete and removed from GRM
# 5/22/2015
# ============================================================

def exercise_with_zeolite(verbose):
  if (not libtbx.env.has_module("iotbx")):
    print("Skipping exercise_with_zeolite(): iotbx not available")
    return
  from iotbx.kriber import strudat
  atlas_file = libtbx.env.find_in_repositories(
    relative_path="phenix_regression/misc/strudat_zeolite_atlas",
    test=os.path.isfile)
  if (atlas_file is None):
    print("Skipping exercise_with_zeolite(): input file not available")
    return
  with open(atlas_file) as f:
    strudat_contents = strudat.read_all_entries(f)
  strudat_entry = strudat_contents.get("YUG")
  si_structure = strudat_entry.as_xray_structure()
  if (verbose):
    out = sys.stdout
  else:
    out = StringIO()
  drls = distance_and_repulsion_least_squares(
    si_structure=si_structure,
    distance_cutoff=3.5,
    nonbonded_repulsion_function_type="prolsq",
    n_macro_cycles=2,
    out=out)
  #
  nbp = drls.geometry_restraints_manager.pair_proxies().nonbonded_proxies
  assert nbp.n_total() > 50
    # expected is 60, but the exact number depends on the minimizer
  #
  site_labels = drls.minimized_structure.scatterers().extract_labels()
  sites_cart = drls.start_structure.sites_cart()
  pair_proxies = drls.geometry_restraints_manager.pair_proxies()
  out = StringIO()
  pair_proxies.bond_proxies.show_sorted(
    by_value="residual",
    sites_cart=sites_cart,
    site_labels=site_labels,
    f=out)
  if (verbose):
    sys.stdout.write(out.getvalue())
  assert len(out.getvalue().splitlines()) == 48*4+2
  assert out.getvalue().splitlines()[-1].find("remaining") < 0
  out = StringIO()
  pair_proxies.bond_proxies.show_sorted(
    by_value="residual",
    sites_cart=sites_cart,
    site_labels=site_labels,
    f=out,
    prefix="0^",
    max_items=28)
  if (verbose):
    sys.stdout.write(out.getvalue())
  assert not show_diff(out.getvalue().replace("e-00", "e-0"), """\
0^Bond restraints: 48
0^Sorted by residual:
0^bond O3
0^     O4
0^  ideal  model  delta    sigma   weight residual
0^  2.629  2.120  0.509 1.56e+00 4.10e-01 1.06e-01
...
0^bond SI1
0^     SI1
0^  ideal  model  delta    sigma   weight residual sym.op.
0^  3.071  3.216 -0.145 2.08e+00 2.31e-01 4.83e-03 -x+1/2,-y+1/2,-z+1
0^... (remaining 20 not shown)
""",
    selections=[range(6), range(-5,0)])
  out = StringIO()
  pair_proxies.bond_proxies.show_sorted(
    by_value="delta",
    sites_cart=sites_cart,
    site_labels=site_labels,
    f=out,
    prefix="0^",
    max_items=28)
  if (verbose):
    sys.stdout.write(out.getvalue())
  assert not show_diff(out.getvalue().replace("e-00", "e-0"), """\
0^Bond restraints: 48
0^Sorted by delta:
0^bond O3
0^     O4
0^  ideal  model  delta    sigma   weight residual
0^  2.629  2.120  0.509 1.56e+00 4.10e-01 1.06e-01
...
0^... (remaining 20 not shown)
""",
    selections=[range(6), [-1]])
  site_labels_long = ["abc"+label+"def" for label in site_labels]
  out = StringIO()
  pair_proxies.bond_proxies.show_sorted(
    by_value="residual",
    sites_cart=sites_cart,
    site_labels=site_labels_long,
    f=out,
    prefix="^0",
    max_items=28)
  if (verbose):
    sys.stdout.write(out.getvalue())
  assert not show_diff(out.getvalue().replace("e-00", "e-0"), """\
^0Bond restraints: 48
^0Sorted by residual:
^0bond abcO3def
^0     abcO4def
^0  ideal  model  delta    sigma   weight residual
^0  2.629  2.120  0.509 1.56e+00 4.10e-01 1.06e-01
...
^0bond abcSI1def
^0     abcSI1def
^0  ideal  model  delta    sigma   weight residual sym.op.
^0  3.071  3.216 -0.145 2.08e+00 2.31e-01 4.83e-03 -x+1/2,-y+1/2,-z+1
^0... (remaining 20 not shown)
""",
    selections=[range(6), range(-5,0)])
  out = StringIO()
  pair_proxies.bond_proxies.show_sorted(
    by_value="residual",
    sites_cart=sites_cart,
    f=out,
    prefix=".=",
    max_items=28)
  if (verbose):
    sys.stdout.write(out.getvalue())
  assert not show_diff(out.getvalue().replace("e-00", "e-0"), """\
.=Bond restraints: 48
.=Sorted by residual:
.=bond 4
.=     5
.=  ideal  model  delta    sigma   weight residual
.=  2.629  2.120  0.509 1.56e+00 4.10e-01 1.06e-01
...
.=bond 0
.=     0
.=  ideal  model  delta    sigma   weight residual sym.op.
.=  3.071  3.216 -0.145 2.08e+00 2.31e-01 4.83e-03 -x+1/2,-y+1/2,-z+1
.=... (remaining 20 not shown)
""",
    selections=[range(6), range(-5,0)])
  out = StringIO()
  pair_proxies.bond_proxies.show_sorted(
    by_value="residual",
    sites_cart=sites_cart,
    f=out,
    prefix="-+",
    max_items=1)
  if (verbose):
    sys.stdout.write(out.getvalue())
  assert not show_diff(out.getvalue().replace("e-00", "e-0"), """\
-+Bond restraints: 48
-+Sorted by residual:
-+bond 4
-+     5
-+  ideal  model  delta    sigma   weight residual
-+  2.629  2.120  0.509 1.56e+00 4.10e-01 1.06e-01
-+... (remaining 47 not shown)
""")
  out = StringIO()
  pair_proxies.bond_proxies.show_sorted(
    by_value="residual",
    sites_cart=sites_cart,
    f=out,
    prefix="=+",
    max_items=0)
  if (verbose):
    sys.stdout.write(out.getvalue())
  assert not show_diff(out.getvalue(), """\
=+Bond restraints: 48
=+Sorted by residual:
=+... (remaining 48 not shown)
""")
  #
  sites_cart = si_structure.sites_cart()
  site_labels = [sc.label for sc in si_structure.scatterers()]
  asu_mappings = si_structure.asu_mappings(buffer_thickness=3.5)
  for min_cubicle_edge in [0, 5]:
    pair_generator = crystal.neighbors_fast_pair_generator(
      asu_mappings=asu_mappings,
      distance_cutoff=asu_mappings.buffer_thickness(),
      minimal=False,
      min_cubicle_edge=min_cubicle_edge)
    sorted_asu_proxies = geometry_restraints.nonbonded_sorted_asu_proxies(
      asu_mappings=asu_mappings)
    while (not pair_generator.at_end()):
      p = geometry_restraints.nonbonded_asu_proxy(
        pair=next(pair_generator),
        vdw_distance=3)
      sorted_asu_proxies.process(p)
    out = StringIO()
    sorted_asu_proxies.show_sorted(
      by_value="delta",
      sites_cart=sites_cart,
      site_labels=site_labels,
      f=out,
      prefix="d%")
    if (verbose):
      sys.stdout.write(out.getvalue())
    assert not show_diff(out.getvalue(), """\
d%Nonbonded interactions: 7
d%Sorted by model distance:
...
d%nonbonded SI2
d%          SI2
d%   model   vdw sym.op.
d%   3.092 3.000 -x+1,y,-z
...
d%nonbonded SI1
d%          SI1
d%   model   vdw sym.op.
d%   3.216 3.000 -x+1/2,-y+1/2,-z+1
""",
      selections=[range(2), range(10,14), range(26,30)])
    out = StringIO()
    sorted_asu_proxies.show_sorted(
      by_value="delta",
      sites_cart=sites_cart,
      f=out,
      prefix="*j",
      max_items=5)
    if (verbose):
      sys.stdout.write(out.getvalue())
    assert not show_diff(out.getvalue(), """\
*jNonbonded interactions: 7
*jSorted by model distance:
...
*jnonbonded 0
*j          1
*j   model   vdw
*j   3.107 3.000
*jnonbonded 0
*j          0
*j   model   vdw sym.op.
*j   3.130 3.000 -x+1,y,-z+1
*j... (remaining 2 not shown)
""",
      selections=[range(2), range(-9,0)])
    out = StringIO()
    sorted_asu_proxies.show_sorted(
      by_value="delta",
      sites_cart=sites_cart,
      f=out,
      prefix="@r",
      max_items=0)
    if (verbose):
      sys.stdout.write(out.getvalue())
    assert not show_diff(out.getvalue(), """\
@rNonbonded interactions: 7
""")

enk_pdb = """\
CRYST1   10.851   13.095   21.192  90.00  90.00  90.00 P 21 21 21
ATOM      1  CA  TYR A   1       8.787   2.175   5.487  1.00  0.91           C
ATOM      2  CB  TYR A   1       8.968   2.012   6.998  1.00  1.05           C
ATOM      3  CG  TYR A   1       9.527   0.669   7.410  1.00  1.04           C
ATOM      4  CD2 TYR A   1       8.768  -0.222   8.157  1.00  1.37           C
ATOM      5  CE2 TYR A   1       9.275  -1.449   8.537  1.00  1.50           C
ATOM      6  CZ  TYR A   1      10.559  -1.798   8.175  1.00  1.15           C
ATOM      7  CE1 TYR A   1      11.334  -0.929   7.437  1.00  1.37           C
ATOM      8  CD1 TYR A   1      10.818   0.296   7.062  1.00  1.34           C
ATOM      9  C   TYR A   1       7.767   1.172   4.959  1.00  0.85           C
ATOM     10  OH  TYR A   1      11.069  -3.019   8.553  1.00  1.40           O
ATOM     11  O   TYR A   1       6.576   1.472   4.870  1.00  1.01           O
ATOM     12  N   TYR A   1       8.388   3.541   5.166  1.00  1.11           N
ATOM     13  CA  GLY A   2       7.387  -1.050   4.044  1.00  1.14           C
ATOM     14  C   GLY A   2       6.345  -1.569   5.016  1.00  0.97           C
ATOM     15  O   GLY A   2       5.234  -1.918   4.619  1.00  1.15           O
ATOM     16  N   GLY A   2       8.241  -0.020   4.608  1.00  0.93           N
ATOM     17  CA  GLY A   3       5.804  -2.100   7.324  1.00  1.36           C
ATOM     18  C   GLY A   3       4.651  -1.149   7.578  1.00  1.01           C
ATOM     19  O   GLY A   3       3.598  -1.553   8.071  1.00  1.38           O
ATOM     20  N   GLY A   3       6.706  -1.622   6.294  1.00  1.11           N
ATOM     21  CA  PHE A   4       3.819   1.134   7.419  1.00  0.89           C
ATOM     22  CB  PHE A   4       4.397   2.380   8.094  1.00  1.13           C
ATOM     23  CG  PHE A   4       4.930   2.130   9.475  1.00  1.00           C
ATOM     24  CD1 PHE A   4       6.267   1.825   9.673  1.00  1.51           C
ATOM     25  CE1 PHE A   4       6.760   1.595  10.943  1.00  1.80           C
ATOM     26  CZ  PHE A   4       5.916   1.667  12.033  1.00  1.59           C
ATOM     27  CE2 PHE A   4       4.582   1.970  11.850  1.00  1.49           C
ATOM     28  CD2 PHE A   4       4.095   2.199  10.577  1.00  1.24           C
ATOM     29  C   PHE A   4       3.185   1.509   6.084  1.00  0.94           C
ATOM     30  N   PHE A   4       4.852   0.121   7.242  1.00  0.88           N
ATOM     31  O   PHE A   4       2.361   2.421   6.010  1.00  1.47           O
ATOM     32  CA  LEU A   5       3.055   1.059   3.693  1.00  0.87           C
ATOM     33  CB  LEU A   5       3.965   0.435   2.634  1.00  1.13           C
ATOM     34  CG  LEU A   5       3.531   0.603   1.177  1.00  1.16           C
ATOM     35  CD1 LEU A   5       3.411   2.076   0.818  1.00  1.88           C
ATOM     36  CD2 LEU A   5       4.502  -0.103   0.245  1.00  1.67           C
ATOM     37  C   LEU A   5       1.634   0.527   3.541  1.00  0.87           C
ATOM     38  N   LEU A   5       3.576   0.800   5.030  1.00  0.92           N
ATOM     39  OXT LEU A   5       1.246  -0.440   4.196  1.00  1.23           O
ATOM     41  O   HOH B   1      14.655  -4.248   8.995  1.00  1.51           O
ATOM     81  H1  HOH B   1      14.954  -3.400   8.664  1.00  1.13           H
ATOM     82  H2  HOH B   1      13.712  -4.246   8.805  1.00  0.76           H
ATOM     42  O   HOH B   2      12.055  -3.540   8.243  1.00  1.81           O
ATOM     83  H1  HOH B   2      11.456  -4.167   7.841  1.00  0.96           H
ATOM     84  H2  HOH B   2      11.476  -3.010   8.803  1.00  1.17           H
ATOM     43  O   HOH B   3       9.622  -2.103   5.551  1.00  2.24           O
ATOM     85  H1  HOH B   3      10.394  -1.650   5.193  1.00  1.02           H
ATOM     86  H2  HOH B   3       9.588  -2.843   4.937  1.00  1.29           H
END
"""

def exercise_with_pdb(verbose):
  if (not libtbx.env.has_module(name="mmtbx")):
    print("Skipping exercise_with_pdb():", \
      "mmtbx.monomer_library.pdb_interpretation not available")
    return
  if (libtbx.env.find_in_repositories(relative_path="chem_data") is None):
    print("Skipping exercise_with_pdb(): chem_data directory not available")
    return
  if (verbose):
    out = sys.stdout
  else:
    out = StringIO()
  with open("tmp_cctbx_geometry_restraints.pdb", "w") as f:
    f.write(enk_pdb)
  pdb_interpretation_params = pdb_interpretation.master_params.extract()
  pdb_interpretation_params.sort_atoms=False
  processed_pdb_file = pdb_interpretation.run(
    args=["tmp_cctbx_geometry_restraints.pdb"],
    strict_conflict_handling=False,
    params=pdb_interpretation_params,
    log=out,)
  geo = processed_pdb_file.geometry_restraints_manager()
  site_labels = processed_pdb_file.xray_structure().scatterers() \
    .extract_labels()
  #
  assert approx_equal(flex.min(geo.nonbonded_model_distances()), 0.4777342)
  #
  geo._sites_cart_used_for_pair_proxies = None
  #
  sel0 = geo.simple_edge_list()
  assert len(sel0) == 46
  assert sel0[:4] == [(0, 1), (0, 8), (0, 11), (1, 2)]
  assert sel0[-4:] == [(42, 43), (42, 44), (45, 46), (45, 47)]
  geo.bond_params_table[13][14].slack = 0.1
  geo.bond_params_table[28][30].slack = 0.3
  sel = geo.simple_edge_list()
  assert sorted(set(sel0) - set(sel)) == [(13, 14), (28, 30)]
  sel = geo.simple_edge_list(omit_slack_greater_than=0.2)
  assert sorted(set(sel0) - set(sel)) == [(28, 30)]
  #
  d = geo.discard_symmetry(new_unit_cell=(10,10,10,90,90,90))
  assert d.site_symmetry_table.special_position_indices().size()==0
  #
  clusters = geo.rigid_clusters_due_to_dihedrals_and_planes(
    constrain_dihedrals_with_sigma_less_than=10)
  assert sorted([tuple(sorted(c)) for c in clusters]) == [
    (0, 8, 10, 15), (0, 8, 12, 15), (1, 2, 3, 4, 5, 6, 7, 9),
    (5, 6, 7, 9), (12, 13, 14, 19), (12, 13, 16, 19), (16, 17, 18, 29),
    (16, 17, 20, 29), (20, 28, 30, 37), (20, 28, 31, 37),
    (21, 22, 23, 24, 25, 26, 27)]

def exercise_non_crystallographic_conserving_bonds_and_angles():
  sites_cart, geo = geometry_restraints.manager \
    .construct_non_crystallographic_conserving_bonds_and_angles(
      sites_cart=flex.vec3_double([
        (10.949, 12.815, 15.189),
        (10.405, 13.954, 15.917),
        (10.779, 15.262, 15.227),
        ( 9.916, 16.090, 14.936)]),
      edge_list_bonds=[(0, 1), (1, 2), (2, 3)],
      edge_list_angles=[(0, 2), (1, 3)])
  assert approx_equal(sites_cart, [
    (6.033, 5.000, 5.253),
    (5.489, 6.139, 5.981),
    (5.863, 7.447, 5.291),
    (5.000, 8.275, 5.000)])
  assert approx_equal(geo.energies_sites(sites_cart=sites_cart).target, 0)
  sites_cart_noise = flex.vec3_double([ # Just to make all residuals unique,
    (6.043, 5.030, 5.233),              # so that the sorted bond list below
    (5.469, 6.119, 5.941),              # has the same order on all platforms.
    (5.893, 7.487, 5.281),
    (5.040, 8.225, 5.020)])
  sio = StringIO()
  geo.show_sorted(sites_cart=sites_cart_noise, f=sio)
  expected_first_part = """\
Bond | covalent geometry | restraints: 5
Sorted by residual:
bond 2
     3
  ideal  model  delta    sigma   weight residual
  1.231  1.158  0.073 1.00e-01 1.00e+02 5.35e-01
bond 1
     2
  ideal  model  delta    sigma   weight residual
  1.525  1.577 -0.052 1.00e-01 1.00e+02 2.66e-01
bond 1
     3
  ideal  model  delta    sigma   weight residual
  2.401  2.338  0.063 1.41e-01 5.00e+01 1.96e-01
bond 0
     1
  ideal  model  delta    sigma   weight residual
  1.457  1.420  0.037 1.00e-01 1.00e+02 1.37e-01
bond 0
     2
  ideal  model  delta    sigma   weight residual
  2.453  2.462 -0.009 1.41e-01 5.00e+01 3.92e-03

"""
  assert not show_diff(sio.getvalue(), expected_first_part + """\
Nonbonded | unspecified | interactions: 0

""")
  #
  sites_cart, geo = geometry_restraints.manager \
    .construct_non_crystallographic_conserving_bonds_and_angles(
      sites_cart=flex.vec3_double([
        (10.949, 12.815, 15.189),
        (10.405, 13.954, 15.917),
        (10.779, 15.262, 15.227),
        ( 9.916, 16.090, 14.936),
        (10.749, 12.615, 15.389)]),
      edge_list_bonds=[(0, 1), (1, 2), (2, 3)],
      edge_list_angles=[(0, 2), (1, 3)])
  sites_cart_noise.append(sites_cart[-1])
  sio = StringIO()
  geo.show_sorted(sites_cart=sites_cart_noise, f=sio)
  assert not show_diff(sio.getvalue(), expected_first_part + """\
Nonbonded | unspecified | interactions: 2
Sorted by model distance:
nonbonded 0
          4
   model   vdw
   0.306 1.200
nonbonded 1
          4
   model   vdw
   1.274 1.200

""")

def exercise_na_restraints_output_to_geo(verbose=False):
  for dependency in ("chem_data", "ksdssp"):
    if not libtbx.env.has_module(dependency):
      print("Skipping exercise_na_restraints_output_to_geo(): %s not available" %(
        dependency))
      return
  pdb_str_1dpl_cutted="""\
CRYST1   24.627   42.717   46.906  90.00  90.00  90.00 P 21 21 21    8
ATOM    184  P    DG A   9       9.587  13.026  19.037  1.00  6.28           P
ATOM    185  OP1  DG A   9       9.944  14.347  19.602  1.00  8.07           O
ATOM    186  OP2  DG A   9      10.654  12.085  18.639  1.00  8.27           O
ATOM    187  O5'  DG A   9       8.717  12.191  20.048  1.00  5.88           O
ATOM    188  C5'  DG A   9       7.723  12.833  20.854  1.00  5.45           C
ATOM    189  C4'  DG A   9       7.145  11.818  21.807  1.00  5.40           C
ATOM    190  O4'  DG A   9       6.435  10.777  21.087  1.00  5.77           O
ATOM    191  C3'  DG A   9       8.142  11.036  22.648  1.00  5.10           C
ATOM    192  O3'  DG A   9       8.612  11.838  23.723  1.00  5.90           O
ATOM    193  C2'  DG A   9       7.300   9.857  23.068  1.00  5.97           C
ATOM    194  C1'  DG A   9       6.619   9.536  21.805  1.00  5.97           C
ATOM    195  N9   DG A   9       7.390   8.643  20.931  1.00  5.97           N
ATOM    196  C8   DG A   9       8.074   8.881  19.775  1.00  6.62           C
ATOM    197  N7   DG A   9       8.647   7.820  19.249  1.00  6.57           N
ATOM    198  C5   DG A   9       8.308   6.806  20.141  1.00  6.22           C
ATOM    199  C6   DG A   9       8.620   5.431  20.136  1.00  6.03           C
ATOM    200  O6   DG A   9       9.297   4.803  19.296  1.00  7.21           O
ATOM    201  N1   DG A   9       8.101   4.773  21.247  1.00  6.10           N
ATOM    202  C2   DG A   9       7.365   5.351  22.260  1.00  6.24           C
ATOM    203  N2   DG A   9       6.948   4.569  23.241  1.00  7.88           N
ATOM    204  N3   DG A   9       7.051   6.652  22.257  1.00  6.53           N
ATOM    205  C4   DG A   9       7.539   7.295  21.184  1.00  5.69           C
ATOM    206  P    DC A  10      10.081  11.538  24.300  1.00  5.91           P
ATOM    207  OP1  DC A  10      10.273  12.645  25.291  1.00  7.27           O
ATOM    208  OP2  DC A  10      11.063  11.363  23.228  1.00  6.84           O
ATOM    209  O5'  DC A  10       9.953  10.128  25.026  1.00  5.75           O
ATOM    210  C5'  DC A  10       9.077   9.959  26.149  1.00  5.87           C
ATOM    211  C4'  DC A  10       9.188   8.549  26.672  1.00  5.56           C
ATOM    212  O4'  DC A  10       8.708   7.612  25.667  1.00  5.70           O
ATOM    213  C3'  DC A  10      10.580   8.059  27.007  1.00  5.27           C
ATOM    214  O3'  DC A  10      11.010   8.447  28.315  1.00  5.83           O
ATOM    215  C2'  DC A  10      10.422   6.549  26.893  1.00  5.34           C
ATOM    216  C1'  DC A  10       9.436   6.405  25.754  1.00  5.23           C
ATOM    217  N1   DC A  10      10.113   6.168  24.448  1.00  5.30           N
ATOM    218  C2   DC A  10      10.514   4.871  24.152  1.00  5.28           C
ATOM    219  O2   DC A  10      10.283   3.972  25.000  1.00  5.75           O
ATOM    220  N3   DC A  10      11.131   4.627  22.965  1.00  5.65           N
ATOM    221  C4   DC A  10      11.395   5.628  22.138  1.00  5.80           C
ATOM    222  N4   DC A  10      12.034   5.327  21.005  1.00  6.75           N
ATOM    223  C5   DC A  10      11.029   6.970  22.449  1.00  5.99           C
ATOM    224  C6   DC A  10      10.394   7.203  23.612  1.00  5.56           C
ATOM    226  O5'  DG B  11      12.424  -4.393  18.427  1.00 22.70           O
ATOM    227  C5'  DG B  11      12.380  -5.516  19.282  1.00 14.75           C
ATOM    228  C4'  DG B  11      11.969  -5.112  20.676  1.00 10.42           C
ATOM    229  O4'  DG B  11      12.972  -4.192  21.210  1.00 10.51           O
ATOM    230  C3'  DG B  11      10.649  -4.394  20.782  1.00  8.57           C
ATOM    231  O3'  DG B  11       9.618  -5.363  20.846  1.00  8.69           O
ATOM    232  C2'  DG B  11      10.822  -3.597  22.051  1.00  8.63           C
ATOM    233  C1'  DG B  11      12.236  -3.233  21.980  1.00  9.81           C
ATOM    234  N9   DG B  11      12.509  -1.902  21.305  1.00  8.66           N
ATOM    235  C8   DG B  11      13.175  -1.667  20.135  1.00  9.57           C
ATOM    236  N7   DG B  11      13.255  -0.407  19.824  1.00  9.04           N
ATOM    237  C5   DG B  11      12.613   0.235  20.869  1.00  7.63           C
ATOM    238  C6   DG B  11      12.388   1.612  21.119  1.00  7.05           C
ATOM    239  O6   DG B  11      12.723   2.590  20.419  1.00  7.81           O
ATOM    240  N1   DG B  11      11.715   1.819  22.317  1.00  6.27           N
ATOM    241  C2   DG B  11      11.264   0.828  23.159  1.00  6.05           C
ATOM    242  N2   DG B  11      10.611   1.219  24.248  1.00  5.85           N
ATOM    243  N3   DG B  11      11.483  -0.457  22.942  1.00  6.55           N
ATOM    244  C4   DG B  11      12.150  -0.687  21.797  1.00  6.84           C
ATOM    245  P    DC B  12       8.134  -5.009  20.350  1.00  8.13           P
ATOM    246  OP1  DC B  12       7.367  -6.252  20.459  1.00 10.02           O
ATOM    247  OP2  DC B  12       8.172  -4.307  19.052  1.00  9.79           O
ATOM    248  O5'  DC B  12       7.564  -3.912  21.389  1.00  8.18           O
ATOM    249  C5'  DC B  12       7.275  -4.296  22.719  1.00  8.00           C
ATOM    250  C4'  DC B  12       6.856  -3.057  23.487  1.00  8.01           C
ATOM    251  O4'  DC B  12       8.006  -2.146  23.615  1.00  7.35           O
ATOM    252  C3'  DC B  12       5.763  -2.208  22.890  1.00  7.04           C
ATOM    253  O3'  DC B  12       4.456  -2.800  23.100  1.00  9.82           O
ATOM    254  C2'  DC B  12       6.019  -0.916  23.630  1.00  6.50           C
ATOM    255  C1'  DC B  12       7.467  -0.808  23.608  1.00  7.35           C
ATOM    256  N1   DC B  12       8.040  -0.143  22.396  1.00  6.64           N
ATOM    257  C2   DC B  12       8.017   1.257  22.382  1.00  5.68           C
ATOM    258  O2   DC B  12       7.524   1.832  23.357  1.00  6.32           O
ATOM    259  N3   DC B  12       8.543   1.930  21.312  1.00  6.18           N
ATOM    260  C4   DC B  12       9.009   1.236  20.266  1.00  6.48           C
ATOM    261  N4   DC B  12       9.518   1.926  19.243  1.00  7.43           N
ATOM    262  C5   DC B  12       9.012  -0.198  20.248  1.00  6.83           C
ATOM    263  C6   DC B  12       8.502  -0.825  21.311  1.00  6.80           C
  """
  identical_portions = [
  """\
  Histogram of bond lengths:
        1.23 -     1.31: 5
        1.31 -     1.39: 25
        1.39 -     1.46: 27
        1.46 -     1.54: 25
        1.54 -     1.61: 5
  Bond restraints: 87""",
  '''\
  Histogram of bond angle deviations from ideal:
        0.00 -     1.10: 75
        1.10 -     2.19: 30
        2.19 -     3.29: 13
        3.29 -     4.38: 8
        4.38 -     5.48: 4
  Bond angle restraints: 130''',
  ]
  with open("tst_cctbx_geometry_restraints_2_na.pdb", "w") as f:
    f.write(pdb_str_1dpl_cutted)
  out1 = StringIO()
  out2 = StringIO()
  from mmtbx.monomer_library.server import MonomerLibraryServerError
  try:
    processed_pdb_file = pdb_interpretation.run(
      args=["tst_cctbx_geometry_restraints_2_na.pdb"],
      strict_conflict_handling=False,
      log=out1)
  except MonomerLibraryServerError:
    print("Skipping exercise_na_restraints_output_to_geo(): Encountered MonomerLibraryServerError.\n")
    print("Is the CCP4 monomer library installed and made available through environment variables MMTBX_CCP4_MONOMER_LIB or CLIBD_MON?")
    return
  geo1 = processed_pdb_file.geometry_restraints_manager()
  hbp = geo1.get_n_hbond_proxies()
  from mmtbx import monomer_library
  params = monomer_library.pdb_interpretation.master_params.extract()
  params.secondary_structure.enabled=True
  processed_pdb_file = pdb_interpretation.run(
    args=["tst_cctbx_geometry_restraints_2_na.pdb"],
    params=params,
    strict_conflict_handling=False,
    log=out2)
  geo2 = processed_pdb_file.geometry_restraints_manager()
  hbp = geo2.get_n_hbond_proxies()
  v_out1 = out1.getvalue()
  v_out2 = out2.getvalue()
  assert v_out2.find("""\
    Restraints generated for nucleic acids:
      6 hydrogen bonds
      12 hydrogen bond angles
      0 basepair planarities
      2 basepair parallelities
      2 stacking parallelities""") > 0
  for v in [v_out1, v_out2]:
    for portion in identical_portions:
      if not v.find(portion) > 0:
        print("This portion was not found:\n%s\n=====End of portion." % portion)
        assert 0, "the portion above does not match expected portion."
  # check .geo output
  geo_identical_portions = ["Bond | covalent geometry | restraints: 87",
      "Bond angle | covalent geometry | restraints: 130",
      "Dihedral angle | covalent geometry | restraints: 33",
      "Chirality | covalent geometry | restraints: 15",
      "Planarity | covalent geometry | restraints: 4"]
  ss_geo_portions = [
      # "Bond-like restraints: 6",
      "Bond | Bond-like | restraints: 6",
      # 'Secondary Structure restraints around h-bond angle restraints: 12',
      'Bond angle | Secondary Structure restraints around h-bond | restraints: 12',
      # "Stacking parallelity restraints: 2",
      # 'Basepair parallelity restraints: 2',
      'Parallelity | Stacking parallelity | restraints: 2',
      'Parallelity | Basepair parallelity | restraints: 2',
      "Nonbonded | unspecified | interactions: 504"]
  non_ss_geo_portions = [
      #"Bond-like restraints: 0",
      #'Secondary Structure restraints around h-bond angle restraints: 0',
      # "Parallelity restraints: 0", removed because zero
      "Nonbonded | unspecified | interactions: 526"]
  acp = processed_pdb_file.all_chain_proxies
  sites_cart = acp.sites_cart_exact()
  site_labels = [atom.id_str() for atom in acp.pdb_atoms]
  geo_out1 = StringIO()
  geo_out2 = StringIO()
  geo1.show_sorted(sites_cart=sites_cart, site_labels=site_labels, f=geo_out1)
  geo2.show_sorted(sites_cart=sites_cart, site_labels=site_labels, f=geo_out2)
  v_geo_out_noss = geo_out1.getvalue()
  v_geo_out_ss = geo_out2.getvalue()
  for portion in geo_identical_portions+ss_geo_portions:
    assert v_geo_out_ss.find(portion) >= 0, 'did not find %s\n in \n%s\n%s\n' % (
      portion,
      v_geo_out_ss,
      portion)
  for portion in geo_identical_portions+non_ss_geo_portions:
    assert v_geo_out_noss.find(portion) >= 0, 'did not find %s\n in \n%s' % (
      portion,
      v_geo_out_noss)

def exercise_hydrogen_bond_rmsd():
  for dependency in ("chem_data", "ksdssp"):
    if not libtbx.env.has_module(dependency):
      print("Skipping exercise_na_restraints_output_to_geo(): %s not available" %(
        dependency))
      return
  if not os.path.exists('tst_cctbx_geometry_restraints_2_na.pdb'):
    print('exercise_hydrogen_bond_rmsd SKIPPED')
  from libtbx import easy_run
  cmd = 'phenix.geometry_minimization tst_cctbx_geometry_restraints_2_na.pdb'
  print(cmd)
  rc=easy_run.go(cmd)
  for token in ['  87  Z', ' 130  Z']:
    for line in rc.stdout_lines:
      if line.find(token)>-1: break
    else: assert 0, 'token "%s" not found' % token
  cmd = 'phenix.geometry_minimization tst_cctbx_geometry_restraints_2_na.pdb'
  cmd += ' secondary_structure.enabled=True'
  print(cmd)
  rc=easy_run.go(cmd)
  for token in ['  87  Z', ' 130  Z']:
    for line in rc.stdout_lines:
      if line.find(token)>-1: break
    else: assert 0, 'token "%s" not found' % token

def exercise_all(args):
  verbose = "--verbose" in args
  exercise_with_zeolite(verbose=verbose)
  exercise_with_pdb(verbose=verbose)
  exercise_non_crystallographic_conserving_bonds_and_angles()
  exercise_na_restraints_output_to_geo(verbose=verbose)
  exercise_hydrogen_bond_rmsd()
  print(libtbx.utils.format_cpu_times())

if (__name__ == "__main__"):
  exercise_all(sys.argv[1:])


 *******************************************************************************


 *******************************************************************************
cctbx/regression/tst_geometry_restraints_lbfgs.py
from __future__ import absolute_import, division, print_function
from iotbx.pdb.tst_pdb import dump_pdb
from iotbx.pymol import pml_stick, pml_write
from cctbx import geometry_restraints
from cctbx import adp_restraints
import cctbx.geometry_restraints.manager
import cctbx.geometry_restraints.lbfgs
from cctbx import xray
from cctbx import crystal
import cctbx.crystal.coordination_sequences
from cctbx import sgtbx
from cctbx.array_family import flex
import scitbx.lbfgs
from scitbx import matrix
from libtbx.test_utils import approx_equal, is_below_limit, show_diff
from itertools import count
from six.moves import cStringIO as StringIO
import sys
from six.moves import range
from six.moves import zip

def exercise(verbose=0):
  distance_ideal = 1.8
  default_vdw_distance = 3.6
  vdw_1_4_factor = 3.5/3.6
  sites_cart_manual = flex.vec3_double([
    (1,3,0), (2,3,0), (3,2,0), (3,1,0), (4,1,0), (3,4,0), (4,3,0), (5,3,0),
    (6,2,0), (7,2,0), (8,3,0), (7,4,0), (6,4,0), (7,5,0), (6,6,0), (8,6,0)])
  bond_proxies = geometry_restraints.bond_sorted_asu_proxies(asu_mappings=None)
  for i_seqs in [(0,1),(1,2),(2,3),(3,4),(1,5),(2,6),(5,6),
                 (6,7),(7,8),(8,9),(9,10),(10,11),(11,12),
                 (12,7),(11,13),(13,14),(14,15),(15,13)]:
    bond_proxies.process(geometry_restraints.bond_simple_proxy(
      i_seqs=i_seqs, distance_ideal=distance_ideal, weight=100))
  angle_proxies = geometry_restraints.shared_angle_proxy()
  for i_seqs,angle_ideal in [[(0,1,2),135],
                             [(0,1,5),135],
                             [(1,2,3),135],
                             [(3,2,6),135],
                             [(2,3,4),120],
                             [(1,2,6),90],
                             [(2,6,5),90],
                             [(6,5,1),90],
                             [(5,1,2),90],
                             [(2,6,7),135],
                             [(5,6,7),135],
                             [(6,7,8),120],
                             [(6,7,12),120],
                             [(7,8,9),120],
                             [(8,9,10),120],
                             [(9,10,11),120],
                             [(10,11,12),120],
                             [(11,12,7),120],
                             [(12,7,8),120],
                             [(10,11,13),120],
                             [(12,11,13),120],
                             [(11,13,15),150],
                             [(11,13,14),150],
                             [(13,15,14),60],
                             [(15,14,13),60],
                             [(14,13,15),60]]:
    angle_proxies.append(geometry_restraints.angle_proxy(
      i_seqs=i_seqs, angle_ideal=angle_ideal, weight=1))
  if (0 or verbose):
    dump_pdb(file_name="manual.pdb", sites_cart=sites_cart_manual)
  for traditional_convergence_test in [True,False]:
    for sites_cart_selection in [True, False]:
      sites_cart = sites_cart_manual.deep_copy()
      if sites_cart_selection:
        sites_cart_selection = flex.bool(sites_cart.size(), True)
        sites_cart_selection[1] = False
      assert bond_proxies.asu.size() == 0
      bond_params_table = geometry_restraints.extract_bond_params(
        n_seq=sites_cart.size(),
        bond_simple_proxies=bond_proxies.simple)
      manager = geometry_restraints.manager.manager(
        bond_params_table=bond_params_table,
        angle_proxies=angle_proxies)
      minimized = geometry_restraints.lbfgs.lbfgs(
        sites_cart=sites_cart,
        geometry_restraints_manager=manager,
        lbfgs_termination_params=scitbx.lbfgs.termination_parameters(
          traditional_convergence_test=traditional_convergence_test,
          drop_convergence_test_max_drop_eps=1.e-20,
          drop_convergence_test_iteration_coefficient=1,
          max_iterations=1000),
        sites_cart_selection=sites_cart_selection,
        )
      assert minimized.minimizer.iter() > 100
      sites_cart_minimized_1 = sites_cart.deep_copy()
      if (0 or verbose):
        dump_pdb(
          file_name="minimized_1.pdb", sites_cart=sites_cart_minimized_1)
      bond_deltas = geometry_restraints.bond_deltas(
        sites_cart=sites_cart_minimized_1,
        proxies=bond_proxies.simple)
      angle_deltas = geometry_restraints.angle_deltas(
        sites_cart=sites_cart_minimized_1,
        proxies=angle_proxies)
      if (0 or verbose):
        for proxy,delta in zip(bond_proxies.simple, bond_deltas):
          print("bond:", proxy.i_seqs, delta)
        for proxy,delta in zip(angle_proxies, angle_deltas):
          print("angle:", proxy.i_seqs, delta)
      assert is_below_limit(
        value=flex.max(flex.abs(bond_deltas)), limit=0, eps=1.e-6)
      assert is_below_limit(
        value=flex.max(flex.abs(angle_deltas)), limit=0, eps=2.e-6)
  sites_cart += matrix.col((1,1,0)) - matrix.col(sites_cart.min())
  unit_cell_lengths = list(  matrix.col(sites_cart.max())
                           + matrix.col((1,-1.2,4)))
  unit_cell_lengths[1] *= 2
  unit_cell_lengths[2] *= 2
  xray_structure = xray.structure(
    crystal_symmetry=crystal.symmetry(
      unit_cell=unit_cell_lengths,
      space_group_symbol="P112"))
  for serial,site in zip(count(1), sites_cart):
    xray_structure.add_scatterer(xray.scatterer(
      label="C%02d"%serial,
      site=xray_structure.unit_cell().fractionalize(site)))
  if (0 or verbose):
    xray_structure.show_summary().show_scatterers()
  p1_structure = (xray_structure
    .apply_shift((-.5,-.5,0))
    .expand_to_p1()
    .apply_shift((.5,.5,0)))
  for shift in [(1,0,0), (0,1,0), (0,0,1)]:
    p1_structure.add_scatterers(p1_structure.apply_shift(shift).scatterers())
  if (0 or verbose):
    open("p1_structure.pdb", "w").write(p1_structure.as_pdb_file())
  nonbonded_cutoff = 6.5
  asu_mappings = xray_structure.asu_mappings(
    buffer_thickness=nonbonded_cutoff)
  bond_asu_table = crystal.pair_asu_table(asu_mappings=asu_mappings)
  geometry_restraints.add_pairs(bond_asu_table, bond_proxies.simple)
  shell_asu_tables = crystal.coordination_sequences.shell_asu_tables(
    pair_asu_table=bond_asu_table,
    max_shell=3)
  shell_sym_tables = [shell_asu_table.extract_pair_sym_table()
    for shell_asu_table in shell_asu_tables]
  bond_params_table = geometry_restraints.extract_bond_params(
    n_seq=sites_cart.size(),
    bond_simple_proxies=bond_proxies.simple)
  atom_energy_types = flex.std_string(sites_cart.size(), "Default")
  nonbonded_params = geometry_restraints.nonbonded_params(
    factor_1_4_interactions=vdw_1_4_factor,
    const_shrink_1_4_interactions=0,
    default_distance=default_vdw_distance)
  nonbonded_params.distance_table.setdefault(
    "Default")["Default"] = default_vdw_distance
  pair_proxies = geometry_restraints.pair_proxies(
    bond_params_table=bond_params_table,
    shell_asu_tables=shell_asu_tables,
    model_indices=None,
    conformer_indices=None,
    nonbonded_params=nonbonded_params,
    nonbonded_types=atom_energy_types,
    nonbonded_distance_cutoff_plus_buffer=nonbonded_cutoff)
  if (0 or verbose):
    print("pair_proxies.bond_proxies.n_total():", \
           pair_proxies.bond_proxies.n_total(), end=' ')
    print("simple:", pair_proxies.bond_proxies.simple.size(), end=' ')
    print("sym:", pair_proxies.bond_proxies.asu.size())
    print("pair_proxies.nonbonded_proxies.n_total():", \
           pair_proxies.nonbonded_proxies.n_total(), end=' ')
    print("simple:", pair_proxies.nonbonded_proxies.simple.size(), end=' ')
    print("sym:", pair_proxies.nonbonded_proxies.asu.size())
    print("min_distance_nonbonded: %.2f" % flex.min(
      geometry_restraints.nonbonded_deltas(
        sites_cart=sites_cart,
        sorted_asu_proxies=pair_proxies.nonbonded_proxies)))
  s = StringIO()
  pair_proxies.bond_proxies.show_histogram_of_model_distances(
    sites_cart=sites_cart,
    f=s,
    prefix="[]")
  assert s.getvalue().splitlines()[0] == "[]Histogram of bond lengths:"
  assert s.getvalue().splitlines()[5].startswith("[]      1.80 -     1.80:")
  s = StringIO()
  pair_proxies.bond_proxies.show_histogram_of_deltas(
    sites_cart=sites_cart,
    f=s,
    prefix="][")
  assert s.getvalue().splitlines()[0] == "][Histogram of bond deltas:"
  assert s.getvalue().splitlines()[5].startswith("][     0.000 -    0.000:")
  s = StringIO()
  pair_proxies.bond_proxies.show_sorted(
    by_value="residual",
    sites_cart=sites_cart,
    max_items=3,
    f=s,
    prefix=":;")
  l = s.getvalue().splitlines()
  assert l[0] == ":;Bond restraints: 18"
  assert l[1] == ":;Sorted by residual:"
  assert l[2].startswith(":;bond ")
  assert l[3].startswith(":;     ")
  assert l[4] == ":;  ideal  model  delta    sigma   weight residual"
  for i in [5,-2]:
    assert l[i].startswith(":;  1.800  1.800 ")
  assert l[-1] == ":;... (remaining 15 not shown)"
  s = StringIO()
  pair_proxies.nonbonded_proxies.show_histogram_of_model_distances(
    sites_cart=sites_cart,
    f=s,
    prefix="]^")
  assert not show_diff(s.getvalue(), """\
]^Histogram of nonbonded interaction distances:
]^      2.16 -     3.03: 3
]^      3.03 -     3.89: 12
]^      3.89 -     4.75: 28
]^      4.75 -     5.61: 44
]^      5.61 -     6.48: 54
""")
  s = StringIO()
  pair_proxies.nonbonded_proxies.show_sorted(
    by_value="delta",
    sites_cart=sites_cart,
    max_items=7,
    f=s,
    prefix=">,")
  assert not show_diff(s.getvalue(), """\
>,Nonbonded interactions: 141
>,Sorted by model distance:
>,nonbonded 15
>,          15
>,   model   vdw sym.op.
>,   2.164 3.600 -x+2,-y+1,z
...
>,nonbonded 4
>,          8
>,   model   vdw
>,   3.414 3.600
>,... (remaining 134 not shown)
""",
    selections=[range(6), range(-5,0)])
  vdw_1_sticks = []
  vdw_2_sticks = []
  for proxy in pair_proxies.nonbonded_proxies.simple:
    if (proxy.vdw_distance == default_vdw_distance):
      vdw_1_sticks.append(pml_stick(
        begin=sites_cart[proxy.i_seqs[0]],
        end=sites_cart[proxy.i_seqs[1]]))
    else:
      vdw_2_sticks.append(pml_stick(
        begin=sites_cart[proxy.i_seqs[0]],
        end=sites_cart[proxy.i_seqs[1]]))
  mps = asu_mappings.mappings()
  for proxy in pair_proxies.nonbonded_proxies.asu:
    if (proxy.vdw_distance == default_vdw_distance):
      vdw_1_sticks.append(pml_stick(
        begin=mps[proxy.i_seq][0].mapped_site(),
        end=mps[proxy.j_seq][proxy.j_sym].mapped_site()))
    else:
      vdw_2_sticks.append(pml_stick(
        begin=mps[proxy.i_seq][0].mapped_site(),
        end=mps[proxy.j_seq][proxy.j_sym].mapped_site()))
  if (0 or verbose):
    pml_write(f=open("vdw_1.pml", "w"), label="vdw_1", sticks=vdw_1_sticks)
    pml_write(f=open("vdw_2.pml", "w"), label="vdw_2", sticks=vdw_2_sticks)
  #
  i_pdb = count(2)
  for use_crystal_symmetry in [False, True]:
    if (not use_crystal_symmetry):
      crystal_symmetry = None
      site_symmetry_table = None
    else:
      crystal_symmetry = xray_structure
      site_symmetry_table = xray_structure.site_symmetry_table()
    for sites_cart in [sites_cart_manual.deep_copy(),
                       sites_cart_minimized_1.deep_copy()]:
      manager = geometry_restraints.manager.manager(
        crystal_symmetry=crystal_symmetry,
        site_symmetry_table=site_symmetry_table,
        nonbonded_params=nonbonded_params,
        nonbonded_types=atom_energy_types,
        nonbonded_function=geometry_restraints.prolsq_repulsion_function(),
        bond_params_table=bond_params_table,
        shell_sym_tables=shell_sym_tables,
        nonbonded_distance_cutoff=nonbonded_cutoff,
        nonbonded_buffer=1,
        angle_proxies=angle_proxies,
        plain_pairs_radius=5)
      manager = manager.select(selection=flex.bool(sites_cart.size(), True))
      manager = manager.select(
        iselection=flex.size_t_range(stop=sites_cart.size()))
      pair_proxies = manager.pair_proxies(sites_cart=sites_cart)
      minimized = geometry_restraints.lbfgs.lbfgs(
        sites_cart=sites_cart,
        geometry_restraints_manager=manager,
        lbfgs_termination_params=scitbx.lbfgs.termination_parameters(
          max_iterations=1000))
      if (0 or verbose):
        minimized.final_target_result.show()
        print("number of function evaluations:", minimized.minimizer.nfun())
        print("n_updates_pair_proxies:", manager.n_updates_pair_proxies)
      if (not use_crystal_symmetry):
        assert minimized.final_target_result.bond_residual_sum < 1.e-3
        assert minimized.final_target_result.nonbonded_residual_sum < 0.1
      else:
        assert minimized.final_target_result.bond_residual_sum < 1.e-2
        assert minimized.final_target_result.nonbonded_residual_sum < 0.1
      assert minimized.final_target_result.angle_residual_sum < 1.e-3
      if (0 or verbose):
        pdb_file_name = "minimized_%d.pdb" % next(i_pdb)
        print("Writing file:", pdb_file_name)
        dump_pdb(file_name=pdb_file_name, sites_cart=sites_cart)
      if (manager.site_symmetry_table is None):
        additional_site_symmetry_table = None
      else:
        additional_site_symmetry_table = sgtbx.site_symmetry_table()
      assert manager.new_including_isolated_sites(
        n_additional_sites=0,
        site_symmetry_table=additional_site_symmetry_table,
        nonbonded_types=flex.std_string()).plain_pairs_radius \
          == manager.plain_pairs_radius
      if (crystal_symmetry is not None):
        assert len(manager.plain_pair_sym_table) == 16
        if (0 or verbose):
          manager.plain_pair_sym_table.show()
  #
  xray_structure.set_u_iso(values=flex.double([
    0.77599982480241358, 0.38745781137212021, 0.20667558236418682,
    0.99759840171302094, 0.8917287406687805, 0.64780251325379845,
    0.24878590382983534, 0.59480621182194615, 0.58695637792905142,
    0.33997130213653637, 0.51258699130743735, 0.79760289141276675,
    0.39996577657875021, 0.4329328819341467, 0.70422156561726479,
    0.87260110626999332]))
  class parameters: pass
  parameters.sphere_radius = 5
  parameters.distance_power = 0.7
  parameters.average_power = 0.9
  parameters.wilson_b_weight = 1.3952
  parameters.wilson_b_weight_auto = False
  adp_energies = adp_restraints.energies_iso(
    plain_pair_sym_table=manager.plain_pair_sym_table,
    xray_structure=xray_structure,
    parameters=parameters,
    wilson_b=None,
    use_hd=False,
    use_u_local_only = False,
    compute_gradients=False,
    gradients=None,
    normalization=False,
    collect=True)
  assert adp_energies.number_of_restraints == 69
  assert approx_equal(adp_energies.residual_sum, 6.24865382467)
  assert adp_energies.gradients is None
  assert adp_energies.u_i.size() == adp_energies.number_of_restraints
  assert adp_energies.u_j.size() == adp_energies.number_of_restraints
  assert adp_energies.r_ij.size() == adp_energies.number_of_restraints
  for wilson_b in [None, 10, 100]:
    finite_difference_gradients = flex.double()
    eps = 1.e-6
    for i_scatterer in range(xray_structure.scatterers().size()):
      rs = []
      for signed_eps in [eps, -eps]:
        xray_structure_eps = xray_structure.deep_copy_scatterers()
        xray_structure_eps.scatterers()[i_scatterer].u_iso += signed_eps
        adp_energies = adp_restraints.energies_iso(
          plain_pair_sym_table=manager.plain_pair_sym_table,
          xray_structure=xray_structure_eps,
          parameters=parameters,
          wilson_b=wilson_b,
          use_u_local_only = False,
          use_hd=False,
          compute_gradients=True,
          gradients=None,
          normalization=False,
          collect=False)
        rs.append(adp_energies.residual_sum)
        assert adp_energies.gradients.size() \
            == xray_structure.scatterers().size()
        assert adp_energies.u_i == None
        assert adp_energies.u_j == None
        assert adp_energies.r_ij == None
      finite_difference_gradients.append((rs[0]-rs[1])/(2*eps))
    sel = flex.bool(xray_structure.scatterers().size(), True)
    xray_structure.scatterers().flags_set_grad_u_iso(sel.iselection())
    adp_energies = adp_restraints.energies_iso(
      plain_pair_sym_table=manager.plain_pair_sym_table,
      xray_structure=xray_structure,
      parameters=parameters,
      wilson_b=wilson_b,
      use_u_local_only = False,
      use_hd=False,
      compute_gradients=True,
      gradients=None,
      normalization=False,
      collect=False)
    assert approx_equal(adp_energies.gradients, finite_difference_gradients)
  print("OK")

if (__name__ == "__main__"):
  exercise(verbose=("--verbose" in sys.argv[1:]))


 *******************************************************************************


 *******************************************************************************
cctbx/regression/tst_grm_modifications.py
from __future__ import absolute_import, division, print_function
from mmtbx import monomer_library
import mmtbx.monomer_library.server
import mmtbx.monomer_library.pdb_interpretation
from cctbx.array_family import flex
import mmtbx.model
from six.moves import cStringIO as StringIO
#import libtbx.load_env
from cctbx import geometry_restraints
from libtbx.test_utils import show_diff, assert_lines_in_text, approx_equal
from libtbx.utils import null_out
import iotbx
from six.moves import range

raw_records1 = """\
CRYST1   60.800   60.800   97.000  90.00  90.00 120.00 P 32 2 1      6
ORIGX1      1.000000  0.000000  0.000000        0.00000
ORIGX2      0.000000  1.000000  0.000000        0.00000
ORIGX3      0.000000  0.000000  1.000000        0.00000
SCALE1      0.016447  0.009496  0.000000        0.00000
SCALE2      0.000000  0.018992  0.000000        0.00000
SCALE3      0.000000  0.000000  0.010309        0.00000
ATOM   1050  N   LYS A 135      31.992  14.930  -7.233  1.00  9.47           N
ATOM   1051  CA  LYS A 135      31.388  16.216  -7.637  1.00 12.89           C
ATOM   1052  C   LYS A 135      30.807  16.840  -6.406  1.00  6.47           C
ATOM   1053  O   LYS A 135      29.583  16.869  -6.191  1.00 15.74           O
ATOM   1054  CB  LYS A 135      30.263  16.059  -8.655  1.00 13.51           C
ATOM   1055  CG  LYS A 135      30.742  15.277  -9.843  1.00 16.23           C
ATOM   1056  CD  LYS A 135      29.612  15.131 -10.835  1.00 28.55           C
ATOM   1057  CE  LYS A 135      30.173  14.812 -12.216  1.00 34.52           C
ATOM   1058  NZ  LYS A 135      29.396  13.756 -12.899  1.00 46.18           N
TER    1294      LYS A 162
END

""".splitlines()

raw_records2 = """\
CRYST1   60.800   60.800   97.000  90.00  90.00 120.00 P 32 2 1      6
HETATM 1406  O   HOH A 282      32.366  19.942  24.727  1.00 38.09           O
END
""".splitlines()

# connect to O, distance 2.9A with symop -y+1,x-y,z-1/3
raw_records3 = """\
CRYST1   60.800   60.800   97.000  90.00  90.00 120.00 P 32 2 1      6
HETATM 1406  O   HOH A 282      32.366  19.942  24.727  1.00 38.09           O
HETATM 1407  O   HOH A 283      33.366  18.942  23.727  1.00 38.09           O
END
""".splitlines()

raw_records4 = """\
CRYST1   15.775   12.565   13.187  90.00  90.00  90.00 P 1
ATOM      1  N   MET A   1       9.821   6.568   5.000  1.00 66.07           N
ATOM      2  CA  MET A   1       9.946   7.171   6.357  1.00 66.55           C
ATOM      3  C   MET A   1      10.571   6.157   7.305  1.00 64.57           C
ATOM      4  O   MET A   1      10.775   5.000   6.933  1.00 66.25           O
ATOM      5  CB  MET A   1       8.570   7.565   6.897  1.00 69.08           C
ATOM      6  CG  MET A   1       7.723   6.373   7.299  1.00 71.37           C
ATOM      7  SD  MET A   1       6.247   6.862   8.187  1.00 76.22           S
ATOM      8  CE  MET A   1       5.000   6.694   6.892  1.00 74.93           C
END
""".splitlines()

raw_records4b = """\
CRYST1   15.775   12.565   13.187  90.00  90.00  90.00 P 1
ATOM      1  N   MET A   1       9.821   6.568   5.000  1.00 66.07           N
ATOM      2  CA  MET A   1       9.946   7.171   6.357  1.00 66.55           C
ATOM      3  C   MET A   1      10.571   6.157   7.305  1.00 64.57           C
ATOM      4  O   MET A   1      10.775   5.000   6.933  1.00 66.25           O
ATOM      5  CB  MET A   1       8.570   7.565   6.897  1.00 69.08           C
ATOM      6  CG  MET A   1       7.723   6.373   7.299  1.00 71.37           C
ATOM      7  SD  MET A   1       6.247   6.862   8.187  1.00 76.22           S
ATOM      8  CE  MET A   1      -1.000   6.694   6.892  1.00 74.93           C
END
""".splitlines()

raw_records5 = """\
CRYST1  258.687  258.687   47.103  90.00  90.00 120.00 P 63          6
ATOM    213  N   ILE A  78      87.236 -55.209   0.578  1.00179.51           N
ATOM    321  O   LYS A  93      81.801 -49.470  26.164  1.00197.87           O
"""

raw_records6 = """\
CRYST1  101.940  101.370  203.540  90.00  90.00  90.00 C 1 2 1
ATOM      1  N   GLU F 440      51.717  35.260  96.810  1.00173.09           N
ATOM      2  CA  GLU F 440      50.591  34.319  97.027  1.00158.07           C
ATOM      3  C   GLU F 440      49.903  34.410  98.438  1.00181.12           C
ATOM      4  O   GLU F 440      48.809  34.940  98.522  1.00178.50           O
ATOM      5  N   ILE F 441      50.585  34.020  99.528  1.00197.83           N
ATOM      6  CA  ILE F 441      51.029  34.946 100.496  1.00205.24           C
ATOM      7  C   ILE F 441      50.630  36.474 100.471  1.00215.52           C
ATOM      8  O   ILE F 441      50.805  37.162 101.476  1.00228.70           O
ATOM      9  N   GLY F 442      50.138  37.042  99.430  1.00196.69           N
ATOM     10  CA  GLY F 442      49.342  38.214  98.975  1.00156.00           C
ATOM     11  C   GLY F 442      48.218  38.275  97.877  1.00171.08           C
ATOM     12  O   GLY F 442      47.220  38.941  98.131  1.00175.64           O
ATOM     13  N   ILE F 443      48.268  37.635  96.688  1.00184.50           N
ATOM     14  CA  ILE F 443      47.069  37.544  95.818  1.00185.10           C
ATOM     15  C   ILE F 443      46.104  36.600  96.497  1.00180.57           C
ATOM     16  O   ILE F 443      44.887  36.627  96.262  1.00172.35           O
ATOM     17  N   LEU F 444      46.637  35.791  97.397  1.00186.46           N
ATOM     18  CA  LEU F 444      45.893  35.148  98.444  1.00184.47           C
ATOM     19  C   LEU F 444      45.942  35.880  99.806  1.00195.40           C
ATOM     20  O   LEU F 444      44.848  35.788 100.444  1.00193.90           O
"""
raw_records7 = """\
CRYST1  101.940  101.370  203.540  90.00  90.00  90.00 C 1 2 1
ATOM      1  N   ILE F 437      55.794  33.676  96.336  1.00160.31           N
ATOM      2  CA  ILE F 437      54.818  33.116  97.305  1.00161.41           C
ATOM      3  C   ILE F 437      54.482  34.092  98.461  1.00184.09           C
ATOM      4  O   ILE F 437      53.584  33.767  99.360  1.00201.20           O
ATOM      5  N   ASN F 438      55.255  35.246  98.488  1.00184.69           N
ATOM      6  CA  ASN F 438      55.094  36.686  98.818  1.00185.32           C
ATOM      7  C   ASN F 438      53.768  37.307  98.414  1.00190.11           C
ATOM      8  O   ASN F 438      52.882  37.698  99.302  1.00206.13           O
ATOM      9  N   SER F 439      53.683  37.260  97.042  1.00171.17           N
ATOM     10  CA  SER F 439      52.551  37.517  96.151  1.00180.82           C
ATOM     11  C   SER F 439      51.492  36.418  96.171  1.00176.83           C
ATOM     12  O   SER F 439      50.456  36.620  95.555  1.00163.02           O
ATOM     13  N   GLU F 440      51.717  35.260  96.810  1.00173.09           N
ATOM     14  CA  GLU F 440      50.591  34.319  97.027  1.00158.07           C
ATOM     15  C   GLU F 440      49.903  34.410  98.438  1.00181.12           C
ATOM     16  O   GLU F 440      48.809  34.940  98.522  1.00178.50           O
ATOM     17  N   ILE F 441      50.585  34.020  99.528  1.00197.83           N
ATOM     18  CA  ILE F 441      51.029  34.946 100.496  1.00205.24           C
ATOM     19  C   ILE F 441      50.630  36.474 100.471  1.00215.52           C
ATOM     20  O   ILE F 441      50.805  37.162 101.476  1.00228.70           O
"""
# excluded:
#ATOM      1  N   MET A   1       9.821   6.568   5.000  1.00 66.07           N

raw_records8 = """\
CRYST1   52.400   52.400   30.700  90.00  90.00 120.00 P 6           6
ORIGX1      1.000000  0.000000  0.000000        0.00000
ORIGX2      0.000000  1.000000  0.000000        0.00000
ORIGX3      0.000000  0.000000  1.000000        0.00000
SCALE1      0.019084  0.011018  0.000000        0.00000
SCALE2      0.000000  0.022036  0.000000        0.00000
SCALE3      0.000000  0.000000  0.032573        0.00000
ATOM    159  N   GLU A  21     -19.011 -14.048  -5.068  1.00 30.55           N
ATOM    160  CA  GLU A  21     -19.766 -14.465  -3.891  1.00 30.92           C
ATOM    161  C   GLU A  21     -19.105 -15.666  -3.211  1.00 35.35           C
ATOM    162  O   GLU A  21     -19.038 -15.734  -1.983  1.00 35.38           O
ATOM    163  CB  GLU A  21     -21.195 -14.821  -4.305  1.00 32.92           C
ATOM    164  CG  GLU A  21     -22.217 -14.782  -3.174  1.00 46.59           C
ATOM    165  CD  GLU A  21     -23.578 -15.309  -3.606  1.00 71.69           C
ATOM    166  OE1 GLU A  21     -24.218 -16.017  -2.800  1.00 69.37           O
ATOM    167  OE2 GLU A  21     -24.009 -15.022  -4.747  1.00 69.89           O
ATOM    168  N   GLU A  22     -18.619 -16.598  -4.030  1.00 31.53           N
ATOM    169  CA  GLU A  22     -17.953 -17.814  -3.566  1.00 30.28           C
ATOM    170  C   GLU A  22     -16.654 -17.504  -2.822  1.00 31.94           C
ATOM    171  O   GLU A  22     -16.408 -18.048  -1.744  1.00 30.30           O
ATOM    172  CB  GLU A  22     -17.674 -18.742  -4.753  1.00 31.45           C
ATOM    173  CG  GLU A  22     -17.177 -20.134  -4.374  1.00 41.37           C
ATOM    174  CD  GLU A  22     -16.558 -20.880  -5.546  1.00 59.74           C
ATOM    175  OE1 GLU A  22     -17.028 -20.710  -6.694  1.00 42.11           O
ATOM    176  OE2 GLU A  22     -15.599 -21.646  -5.317  1.00 54.25           O
ATOM    177  N   LEU A  23     -15.839 -16.626  -3.409  1.00 28.44           N
ATOM    178  CA  LEU A  23     -14.552 -16.219  -2.841  1.00 27.53           C
ATOM    179  C   LEU A  23     -14.712 -15.658  -1.429  1.00 29.94           C
ATOM    180  O   LEU A  23     -13.955 -16.017  -0.523  1.00 28.82           O
ATOM    181  CB  LEU A  23     -13.875 -15.185  -3.755  1.00 28.11           C
ATOM    182  CG  LEU A  23     -12.371 -14.864  -3.672  1.00 33.41           C
ATOM    183  CD1 LEU A  23     -11.984 -14.133  -2.387  1.00 35.92           C
ATOM    184  CD2 LEU A  23     -11.515 -16.114  -3.866  1.00 34.00           C
ATOM    185  N   LEU A  24     -15.700 -14.781  -1.255  1.00 26.30           N
ATOM    186  CA  LEU A  24     -16.000 -14.189   0.047  1.00 25.29           C
ATOM    187  C   LEU A  24     -16.376 -15.244   1.082  1.00 29.65           C
ATOM    188  O   LEU A  24     -16.052 -15.103   2.261  1.00 29.77           O
ATOM    189  CB  LEU A  24     -17.118 -13.147  -0.071  1.00 25.33           C
ATOM    190  CG  LEU A  24     -16.839 -11.842  -0.825  1.00 29.60           C
ATOM    191  CD1 LEU A  24     -18.092 -10.984  -0.842  1.00 30.42           C
ATOM    192  CD2 LEU A  24     -15.675 -11.066  -0.212  1.00 30.06           C
ATOM    193  N   ARG A  25     -17.051 -16.298   0.629  1.00 25.80           N
ATOM    194  CA  ARG A  25     -17.470 -17.388   1.506  1.00 25.11           C
ATOM    195  C   ARG A  25     -16.307 -18.309   1.874  1.00 27.79           C
ATOM    196  O   ARG A  25     -16.268 -18.843   2.983  1.00 27.92           O
ATOM    197  CB  ARG A  25     -18.628 -18.170   0.882  1.00 23.23           C
ATOM    198  CG  ARG A  25     -19.892 -17.339   0.708  1.00 33.72           C
ATOM    199  CD  ARG A  25     -21.050 -18.167   0.193  1.00 39.36           C
ATOM    200  NE  ARG A  25     -22.246 -17.357  -0.034  1.00 49.67           N
ATOM    201  CZ  ARG A  25     -23.186 -17.118   0.878  1.00 67.61           C
ATOM    202  NH1 ARG A  25     -23.087 -17.626   2.100  1.00 57.30           N
ATOM    203  NH2 ARG A  25     -24.233 -16.367   0.565  1.00 54.80           N
ATOM    204  N   VAL A  26     -15.368 -18.482   0.942  1.00 24.42           N
ATOM    205  CA  VAL A  26     -14.107 -19.183   1.205  1.00 24.67           C
ATOM    206  C   VAL A  26     -13.336 -18.449   2.304  1.00 28.49           C
ATOM    207  O   VAL A  26     -12.730 -19.071   3.179  1.00 28.78           O
ATOM    208  CB  VAL A  26     -13.223 -19.272  -0.070  1.00 28.72           C
ATOM    209  CG1 VAL A  26     -11.867 -19.887   0.249  1.00 28.52           C
ATOM    210  CG2 VAL A  26     -13.925 -20.074  -1.157  1.00 28.70           C
ATOM    211  N   ALA A  27     -13.375 -17.120   2.242  1.00 24.71           N
ATOM    212  CA  ALA A  27     -12.739 -16.260   3.236  1.00 24.02           C
ATOM    213  C   ALA A  27     -13.451 -16.320   4.585  1.00 27.75           C
ATOM    214  O   ALA A  27     -12.811 -16.200   5.633  1.00 28.05           O
ATOM    215  CB  ALA A  27     -12.668 -14.827   2.731  1.00 24.38           C
ATOM    216  N   VAL A  28     -14.773 -16.497   4.550  1.00 22.56           N
ATOM    217  CA  VAL A  28     -15.562 -16.707   5.766  1.00 22.49           C
ATOM    218  C   VAL A  28     -15.168 -18.028   6.426  1.00 28.43           C
ATOM    219  O   VAL A  28     -14.905 -18.062   7.634  1.00 28.37           O
ATOM    220  CB  VAL A  28     -17.094 -16.637   5.504  1.00 25.59           C
ATOM    221  CG1 VAL A  28     -17.887 -17.115   6.721  1.00 25.73           C
ATOM    222  CG2 VAL A  28     -17.504 -15.223   5.145  1.00 24.61           C
ATOM    223  N  AASN A  29     -15.101 -19.081   5.664  0.73 26.11           N
ATOM    224  CA AASN A  29     -14.718 -20.307   6.284  0.73 27.31           C
ATOM    225  C  AASN A  29     -13.257 -20.393   6.647  0.73 32.18           C
ATOM    226  O  AASN A  29     -12.947 -21.066   7.577  0.73 32.90           O
ATOM    227  CB AASN A  29     -15.331 -21.509   5.631  0.73 28.51           C
ATOM    228  CG AASN A  29     -16.814 -21.654   6.039  0.73 51.96           C
ATOM    229  OD1AASN A  29     -17.167 -22.363   6.966  0.73 47.90           O
ATOM    230  ND2AASN A  29     -17.663 -20.915   5.365  0.73 42.10           N
ATOM    231  N  BASN A  29     -15.140 -19.071   5.632  0.27 25.87           N
ATOM    232  CA BASN A  29     -14.710 -20.410   5.973  0.27 26.86           C
ATOM    233  C  BASN A  29     -13.308 -20.386   6.582  0.27 31.86           C
ATOM    234  O  BASN A  29     -13.079 -21.020   7.567  0.27 32.37           O
ATOM    235  CB BASN A  29     -14.680 -21.206   4.683  0.27 28.33           C
ATOM    236  CG BASN A  29     -14.977 -22.655   4.875  0.27 51.98           C
ATOM    237  OD1BASN A  29     -15.533 -23.029   5.867  0.27 45.83           O
ATOM    238  ND2BASN A  29     -14.576 -23.486   3.918  0.27 44.66           N
ATOM    239  N   ALA A  30     -12.413 -19.597   5.972  1.00 28.45           N
ATOM    240  CA  ALA A  30     -10.994 -19.492   6.328  1.00 29.07           C
ATOM    241  C   ALA A  30     -10.801 -18.726   7.633  1.00 34.39           C
ATOM    242  O   ALA A  30      -9.817 -18.931   8.344  1.00 35.36           O
ATOM    243  CB  ALA A  30     -10.211 -18.827   5.204  1.00 29.27           C
END
"""

raw_records9 = """\
CRYST1   41.028   41.028  183.010  90.00  90.00  90.00 P 43 21 2
SCALE1      0.024374  0.000000  0.000000        0.00000
SCALE2      0.000000  0.024374  0.000000        0.00000
SCALE3      0.000000  0.000000  0.005464        0.00000
ATOM      1  CG  HIS A 319       2.304  23.849  77.123  1.00 23.70           C
ATOM      2  ND1 HIS A 319       1.668  23.871  75.903  1.00 25.36           N
ATOM      3  CD2 HIS A 319       2.302  25.128  77.578  1.00 21.49           C
ATOM      4  CE1 HIS A 319       1.265  25.110  75.643  1.00 25.28           C
ATOM      5  NE2 HIS A 319       1.643  25.884  76.636  1.00 23.98           N
ATOM      6  HD1 HIS A 319       1.550  23.191  75.390  1.00 30.43           H
ATOM      7  HD2 HIS A 319       2.675  25.435  78.373  1.00 25.78           H
ATOM      8  HE1 HIS A 319       0.795  25.383  74.888  1.00 30.33           H
ATOM      9  HG3 MET A 338      -1.284  24.273  77.766  1.00 36.33           H
ATOM     10  CG  GLU A 362       1.743  29.061  80.665  1.00 32.98           C
ATOM     11  CD  GLU A 362       1.505  28.476  79.273  1.00 26.00           C
ATOM     12  OE1 GLU A 362       0.357  28.085  78.927  1.00 33.20           O
ATOM     13  OE2 GLU A 362       2.511  28.378  78.586  1.00 24.88           O
ATOM     14  HG2 GLU A 362       2.252  29.880  80.555  1.00 39.58           H
ATOM     15  HG3 GLU A 362       2.259  28.414  81.171  1.00 39.58           H
TER
ATOM     16  N   HIS B 304     -20.949  11.990  59.962  1.00 23.21           N
ATOM     17  CA  HIS B 304     -22.165  11.249  60.299  1.00 25.44           C
ATOM     18  C   HIS B 304     -23.349  12.161  60.500  1.00 29.20           C
ATOM     19  O   HIS B 304     -24.477  11.760  60.211  1.00 32.52           O
ATOM     20  CB  HIS B 304     -21.963  10.373  61.537  1.00 28.40           C
ATOM     21  CG  HIS B 304     -20.809   9.431  61.430  1.00 27.87           C
ATOM     22  ND1 HIS B 304     -19.517   9.806  61.733  1.00 36.76           N
ATOM     23  CD2 HIS B 304     -20.737   8.128  61.054  1.00 26.50           C
ATOM     24  CE1 HIS B 304     -18.706   8.776  61.549  1.00 36.85           C
ATOM     25  NE2 HIS B 304     -19.428   7.737  61.176  1.00 27.21           N
ATOM     26  HA  HIS B 304     -22.359  10.653  59.559  1.00 30.53           H
ATOM     27  HB2 HIS B 304     -21.805  10.948  62.303  1.00 34.08           H
ATOM     28  HB3 HIS B 304     -22.764   9.845  61.678  1.00 34.08           H
ATOM     29  HD2 HIS B 304     -21.445   7.599  60.766  1.00 31.79           H
ATOM     30  HE1 HIS B 304     -17.783   8.783  61.663  1.00 44.22           H
ATOM     31  HE2 HIS B 304     -19.128   6.944  61.034  1.00 32.64           H
ATOM     32 HG21 VAL B 315     -20.236   8.723  64.319  1.00 36.99           H
TER
HETATM   33 ZN    ZN A   8       1.797  27.888  76.692  1.00 34.36          Zn
HETATM   34  O   HOH A  57       3.694  28.411  75.816  1.00 39.92           O
HETATM   35  O   HOH A  69       5.784  26.244  75.932  1.00 38.11           O
"""

raw_records10 = """\
CRYST1   15.775   12.565   13.187  90.00  90.00  90.00 P 1
ATOM      1  N   MET A   1       9.821   1.568   5.000  1.00 66.07           N
ATOM      2  CA  HIS A   2       9.946  12.171   5.357  1.00 66.55           C
END
"""


def make_initial_grm(mon_lib_srv, ener_lib, records):
  processed_pdb_file = monomer_library.pdb_interpretation.process(
    mon_lib_srv    = mon_lib_srv,
    ener_lib       = ener_lib,
    raw_records    = records,
    force_symmetry = True)

  geometry = processed_pdb_file.geometry_restraints_manager(
    show_energies      = True,
    plain_pairs_radius = 5.0)
  xrs = processed_pdb_file.xray_structure()
  return geometry, xrs

def show_sorted_geometry(geometry, xrs, file_name):
  out = open(file_name,'w')
  geometry.show_sorted(
      sites_cart=xrs.sites_cart(),
      site_labels=xrs.scatterers().extract_labels(),
      f=out)
  out.close()

def exercise_add_new_bond_restraint_in_place(mon_lib_srv, ener_lib):
  geometry, xrs = make_initial_grm(mon_lib_srv, ener_lib, raw_records4)

  proxy = geometry_restraints.bond_simple_proxy(
    i_seqs=(0,3),
    distance_ideal=2.0,
    weight=3000)
  assert not geometry.is_bonded_atoms(0,3)
  assert not geometry.is_bonded_atoms(3,0)
  geometry.add_new_bond_restraints_in_place([proxy], xrs.sites_cart())
  assert geometry.is_bonded_atoms(0,3)
  assert geometry.is_bonded_atoms(3,0)
  assert geometry.pair_proxies().bond_proxies.simple.size() == 8
  assert geometry.pair_proxies().bond_proxies.asu.size() == 0
  # That's the way to get them:
  simple, asu = geometry.get_covalent_bond_proxies()
  assert simple.size() + asu.size() == 8
  assert geometry.pair_proxies().nonbonded_proxies.simple.size() == 8
  assert geometry.pair_proxies().nonbonded_proxies.asu.size() == 0

def exercise_add_new_bond_when_long_bond_across_ASU(mon_lib_srv, ener_lib):
  '''
  raw_records4b is same as raw_records4, except that CE is in another ASU
  --> 6A long bond to SD --> this broke the call of
  all_bonds_asu_table.add_pair_sym_table(self.shell_sym_tables[0])
  in add_new_bond_restraints_in_place() method.
  Reason for the fail: there is >5 A long bond (i.e. longer than the
  default of max_distance_between_connecting_atoms, which is 5) between
  atoms where one atom is in another ASU
  see also test phenix_regression/mmtbx/tst_pdb_interpretation_3.py
  Fixed with
  https://github.com/cctbx/cctbx_project/commit/3f84e12b8ae2cc9ec354122b231f0c69c01155f9
  '''
  geometry, xrs = make_initial_grm(mon_lib_srv, ener_lib, raw_records4b)

  proxy = geometry_restraints.bond_simple_proxy(
    i_seqs=(0,3),
    distance_ideal=2.0,
    weight=3000)
  assert not geometry.is_bonded_atoms(0,3)
  assert not geometry.is_bonded_atoms(3,0)
  geometry.add_new_bond_restraints_in_place([proxy], xrs.sites_cart())
  geometry.add_new_bond_restraints_in_place([proxy], xrs.sites_cart(),
    max_distance_between_connecting_atoms=10)

  assert geometry.is_bonded_atoms(0,3)
  assert geometry.is_bonded_atoms(3,0)
  assert geometry.pair_proxies().bond_proxies.simple.size() == 8
  assert geometry.pair_proxies().bond_proxies.asu.size() == 0
  simple, asu = geometry.get_covalent_bond_proxies()
  assert simple.size() + asu.size() == 8
  # DL: these numbers will need to be adapted
  #assert geometry.pair_proxies().nonbonded_proxies.simple.size() == 8
  #assert geometry.pair_proxies().nonbonded_proxies.asu.size() == 0

def exercise_add_super_long_bond(mon_lib_srv, ener_lib):
  # distance between the two is 26A, they are not added because of
  # max_distance_between_connecting_atoms=5 is default.
  # Inspired by 4c8q, atoms are from offending SHEET with wrong parallel/
  # antiparallel definition.
  #
  geometry, xrs = make_initial_grm(mon_lib_srv, ener_lib, raw_records5)
  proxy = geometry_restraints.bond_simple_proxy(
    i_seqs=(0,1),
    distance_ideal=2.0,
    weight=3000)
  assert not geometry.is_bonded_atoms(0,1)
  assert not geometry.is_bonded_atoms(1,0)
  geometry.add_new_bond_restraints_in_place([proxy], xrs.sites_cart(),
      max_distance_between_connecting_atoms=5)
  assert not geometry.is_bonded_atoms(0,1)
  assert not geometry.is_bonded_atoms(1,0)
  geometry.add_new_bond_restraints_in_place([proxy], xrs.sites_cart(),
      max_distance_between_connecting_atoms=30)
  assert geometry.is_bonded_atoms(0,1)
  assert geometry.is_bonded_atoms(1,0)

def exercise_bond_near_symmetry(mon_lib_srv, ener_lib):
  """ Making bond near symmetry mate:
  " N   LEU F 444 " -- " O   GLU F 440 " """
  geometry, xrs = make_initial_grm(mon_lib_srv, ener_lib, raw_records6)
  proxy = geometry_restraints.bond_simple_proxy(
    i_seqs=(16,3),
    distance_ideal=2.9,
    weight=3000)
  assert not geometry.is_bonded_atoms(16,3)
  assert not geometry.is_bonded_atoms(3,16)
  # show_sorted_geometry(geometry, xrs, 'before_xercise_bond_near_symmetry.geo')
  assert geometry.pair_proxies().bond_proxies.simple.size() == 19
  assert geometry.pair_proxies().bond_proxies.asu.size() == 0
  geometry.add_new_bond_restraints_in_place([proxy], xrs.sites_cart(),
      max_distance_between_connecting_atoms=10)
  assert geometry.is_bonded_atoms(3,16)
  # show_sorted_geometry(geometry, xrs, 'after_xercise_bond_near_symmetry.geo')
  assert geometry.pair_proxies().bond_proxies.simple.size() == 20  # assert 20
  assert geometry.pair_proxies().bond_proxies.asu.size() == 0  # assert 0

def exercise_bond_near_symmetry2(mon_lib_srv, ener_lib):
  """ Same as previous, other atoms were still failing
  Making bond near symmetry mate:
  " N   LEU F 441 " -- " O   GLU F 437 " """
  geometry, xrs = make_initial_grm(mon_lib_srv, ener_lib, raw_records7)
  proxy = geometry_restraints.bond_simple_proxy(
    i_seqs=(16,3),
    distance_ideal=2.9,
    weight=3000)
  assert not geometry.is_bonded_atoms(16,3)
  assert not geometry.is_bonded_atoms(3,16)
  # show_sorted_geometry(geometry, xrs, 'before_xercise_bond_near_symmetry2.geo')
  assert geometry.pair_proxies().bond_proxies.simple.size() == 19
  assert geometry.pair_proxies().bond_proxies.asu.size() == 0
  geometry.add_new_bond_restraints_in_place([proxy], xrs.sites_cart(),
      max_distance_between_connecting_atoms=10)
  assert geometry.is_bonded_atoms(3,16)
  # show_sorted_geometry(geometry, xrs, 'after_xercise_bond_near_symmetry2.geo')
  assert geometry.pair_proxies().bond_proxies.simple.size() == 20  # assert 20
  assert geometry.pair_proxies().bond_proxies.asu.size() == 0  # assert 0

def exercise_single_atom(mon_lib_srv, ener_lib):
  geometry, xrs = make_initial_grm(mon_lib_srv, ener_lib, raw_records1)

  # output for debugging!!!
  # show_sorted_geometry(geometry, xrs, 'before_exersice_single_atoms.geo')

  xrs_add = iotbx.pdb.input(source_info=None, lines=raw_records2) \
      .xray_structure_simple()
  proxy1 = geometry_restraints.bond_simple_proxy(
      i_seqs=(3,9),
      distance_ideal=2.0,
      weight=3000,
      origin_id=2) # just a test

  new_xrs = xrs.concatenate(xrs_add)
  all_sites_cart = new_xrs.sites_cart()
  number_of_new_atoms = len(xrs_add.sites_cart())
  new_geometry = geometry.new_included_bonded_atoms(
      proxies=[proxy1],
      sites_cart=all_sites_cart,
      site_symmetry_table=xrs_add.site_symmetry_table(),
      nonbonded_types=flex.std_string(["OH2"]*number_of_new_atoms),
      nonbonded_charges=flex.int(number_of_new_atoms, 0),
      skip_max_proxy_distance_calculation=True)
  # output for debugging!!!
  # show_sorted_geometry(new_geometry, new_xrs,
  #     'after_exersice_single_atoms.geo')
  assert new_geometry.is_bonded_atoms(3,9)

  assert new_geometry.pair_proxies().bond_proxies.simple.size() == 8
  assert new_geometry.pair_proxies().bond_proxies.asu.size() == 1
  # That's the way to get them:
  simple, asu = new_geometry.get_covalent_bond_proxies()
  assert simple.size() + asu.size() == 8
  simple, asu = new_geometry.get_all_bond_proxies()
  assert simple.size() + asu.size() == 9, "%d, %d" % (simple.size(), asu.size())
  assert new_geometry.pair_proxies().nonbonded_proxies.simple.size() == 10
  assert new_geometry.pair_proxies().nonbonded_proxies.asu.size() ==2
  assert new_geometry.get_hbond_proxies_iseqs() == [(3, 9)]
  simple, asu = new_geometry.get_covalent_bond_proxies()
  assert simple.size() + asu.size() == 8, "%d" % (simple.size() + asu.size())

def exercise_multiple_atoms(mon_lib_srv, ener_lib):
  geometry, xrs = make_initial_grm(mon_lib_srv, ener_lib, raw_records1)

  # output for debugging!!!
  # show_sorted_geometry(geometry, xrs, 'before_exersice_multiple_atoms.geo')

  xrs_add = iotbx.pdb.input(source_info=None, lines=raw_records3) \
      .xray_structure_simple()
  proxy1 = geometry_restraints.bond_simple_proxy(
      i_seqs=(3,9),
      distance_ideal=2.0,
      weight=3000)
  proxy2 = geometry_restraints.bond_simple_proxy(
      i_seqs=(4,10),
      distance_ideal=2.0,
      weight=3000)

  new_xrs = xrs.concatenate(xrs_add)
  all_sites_cart = new_xrs.sites_cart()
  number_of_new_atoms = len(xrs_add.sites_cart())
  assert geometry.pair_proxies().bond_proxies.simple.size() == 8
  assert geometry.pair_proxies().bond_proxies.asu.size() == 0
  assert geometry.pair_proxies().nonbonded_proxies.simple.size() == 10
  assert geometry.pair_proxies().nonbonded_proxies.asu.size() == 0
  new_geometry = geometry.new_included_bonded_atoms(
      proxies=[proxy1, proxy2],
      sites_cart=all_sites_cart,
      site_symmetry_table=xrs_add.site_symmetry_table(),
      nonbonded_types=flex.std_string(["OH2"]*number_of_new_atoms),
      nonbonded_charges=flex.int(number_of_new_atoms, 0),
      skip_max_proxy_distance_calculation=True)
  # output for debugging!!!
  # show_sorted_geometry(new_geometry, new_xrs,
  #     'after_exersice_multiple_atoms.geo')
  assert new_geometry.pair_proxies().bond_proxies.simple.size() == 8
  assert new_geometry.pair_proxies().bond_proxies.asu.size() == 2
  assert new_geometry.pair_proxies().nonbonded_proxies.simple.size() == 11
  assert new_geometry.pair_proxies().nonbonded_proxies.asu.size() == 4

def exercise_is_bonded_atoms(mon_lib_srv, ener_lib):
  geometry, xrs = make_initial_grm(mon_lib_srv, ener_lib, raw_records1)
  # show_sorted_geometry(geometry, xrs, 'blabla.geo')
  linked_atoms = [(0,1), (1,2), (1,4), (2,3), (4,5),(5,6), (6,7), (7,8)]
  for i in range (9):
    for j in range(9):
      assert geometry.is_bonded_atoms(i,j) == geometry.is_bonded_atoms(j,i)
      assert geometry.is_bonded_atoms(i,j) == (tuple(sorted([i,j])) in linked_atoms)

def exercise_bond_near_symmetry3(mon_lib_srv, ener_lib):
  """ Since neighbors_fast_pair_generator for non-symmetry interactions
  provides only (i,j) pair and not (j,i), and there's no sorting involved
  (no way to guess what to check), there was a bug where non-symmetry interaction
  was missed in add_new_bond_restraints_in_place.
  Actually testing that both bonds are added without symmetry operators.
  """

  from cctbx.geometry_restraints.linking_class import linking_class
  origin_ids = linking_class()
  pdb_inp = iotbx.pdb.input(source_info=None, lines=raw_records8)
  model = mmtbx.model.manager(model_input = pdb_inp, log=null_out())
  model.process(make_restraints=True)
  grm = model.get_restraints_manager().geometry
  h = model.get_hierarchy()
  proxy = geometry_restraints.bond_simple_proxy(
      i_seqs=(64,37),
      distance_ideal=2.9,
      weight=400,
      origin_id=origin_ids.get_origin_id('hydrogen bonds'))
  proxy2 = geometry_restraints.bond_simple_proxy(
      i_seqs=(72,37),
      distance_ideal=2.9,
      weight=400,
      origin_id=origin_ids.get_origin_id('hydrogen bonds'))
  grm.add_new_hbond_restraints_in_place(
      proxies=[proxy, proxy2],
      sites_cart=h.atoms().extract_xyz(),
      max_distance_between_connecting_atoms=10)
  sites_cart = h.atoms().extract_xyz()
  site_labels = model.get_xray_structure().scatterers().extract_labels()
  pair_proxies = grm.pair_proxies(flags=None, sites_cart=sites_cart)

  out = StringIO()
  pair_proxies.bond_proxies.show_sorted(
      by_value="residual",
      sites_cart=sites_cart,
      site_labels=site_labels,
      f=out,
      prefix="",
      origin_id=origin_ids.get_origin_id('hydrogen bonds'))
  outtxt = out.getvalue()
  assert not show_diff(outtxt,
"""\
Bond restraints: 2
Sorted by residual:
bond pdb=" O   ARG A  25 "
     pdb=" N  AASN A  29 "
  ideal  model  delta    sigma   weight residual
  2.900  2.934 -0.034 5.00e-02 4.00e+02 4.53e-01
bond pdb=" O   ARG A  25 "
     pdb=" N  BASN A  29 "
  ideal  model  delta    sigma   weight residual
  2.900  2.888  0.012 5.00e-02 4.00e+02 5.59e-02
"""
)

def exercise_bond_over_symmetry(mon_lib_srv, ener_lib):
  from cctbx.geometry_restraints.linking_class import linking_class
  origin_ids = linking_class()
  pdb_inp = iotbx.pdb.input(source_info=None, lines=raw_records9)
  params = mmtbx.model.manager.get_default_pdb_interpretation_params()
  params.pdb_interpretation.restraints_library.mcl=False
  model = mmtbx.model.manager(
      model_input = pdb_inp,
      log=null_out())
  model.process(pdb_interpretation_params=params, make_restraints=True)
  grm = model.get_restraints_manager().geometry
  simple, asu = grm.get_all_bond_proxies()
  assert (simple.size(), asu.size()) == (29, 0)
  h = model.get_hierarchy()
  proxy = geometry_restraints.bond_simple_proxy(
      i_seqs=(32,4),
      distance_ideal=2.9,
      weight=400,
      origin_id=origin_ids.get_origin_id('hydrogen bonds'))
  proxy2 = geometry_restraints.bond_simple_proxy(
      i_seqs=(32,24),
      distance_ideal=2.9,
      weight=400,
      origin_id=origin_ids.get_origin_id('hydrogen bonds'))
  grm.add_new_bond_restraints_in_place(
      proxies=[proxy, proxy2],
      sites_cart=h.atoms().extract_xyz())
  simple, asu = grm.get_all_bond_proxies()
  assert (simple.size(), asu.size()) == (30,2)

  sites_cart = h.atoms().extract_xyz()
  site_labels = model.get_xray_structure().scatterers().extract_labels()
  pair_proxies = grm.pair_proxies(flags=None, sites_cart=sites_cart)

  out = StringIO()
  pair_proxies.bond_proxies.show_sorted(
      by_value="residual",
      sites_cart=sites_cart,
      site_labels=site_labels,
      f=out,
      prefix="")
  outtxt = out.getvalue()
  # print(outtxt)
  #
  # Not clear why ZN-NE2 bond adds as 2 bonds.
  assert_lines_in_text(outtxt, """\
bond pdb="ZN    ZN A   8 "
     pdb=" NE2 HIS B 304 "
  ideal  model  delta    sigma   weight residual sym.op.
  2.900  2.969 -0.069 5.00e-02 4.00e+02 1.92e+00 -x-1/2,y+1/2,-z+3/4
    """)
  assert_lines_in_text(outtxt, """\
bond pdb=" NE2 HIS B 304 "
     pdb="ZN    ZN A   8 "
  ideal  model  delta    sigma   weight residual sym.op.
  2.900  2.969 -0.069 5.00e-02 4.00e+02 1.92e+00 -x-1/2,y-1/2,-z+3/4
    """)

def exercise_bond_over_symmetry_2(mon_lib_srv, ener_lib):
  """ This test is to illustrate that bond over symmetry actually
  adds 2 proxies.
  """
  from cctbx.geometry_restraints.linking_class import linking_class
  origin_ids = linking_class()
  pdb_inp = iotbx.pdb.input(source_info=None, lines=raw_records10)
  params = mmtbx.model.manager.get_default_pdb_interpretation_params()
  params.pdb_interpretation.restraints_library.mcl=False
  model = mmtbx.model.manager(
      model_input = pdb_inp,
      log=null_out())
  model.process(pdb_interpretation_params=params, make_restraints=True)
  grm = model.get_restraints_manager().geometry
  simple, asu = grm.get_all_bond_proxies()
  assert (simple.size(), asu.size()) == (0, 0)

  h = model.get_hierarchy()
  sites_cart = h.atoms().extract_xyz()
  site_labels = model.get_xray_structure().scatterers().extract_labels()
  pair_proxies = grm.pair_proxies(flags=None, sites_cart=sites_cart)

  out = StringIO()
  pair_proxies.bond_proxies.show_sorted(
      by_value="residual",
      sites_cart=sites_cart,
      site_labels=site_labels,
      f=out,
      prefix="")
  outtxt = out.getvalue()
  # print(outtxt)

  proxy = geometry_restraints.bond_simple_proxy(
      i_seqs=(0,1),
      distance_ideal=2.9,
      weight=400,
      origin_id=origin_ids.get_origin_id('hydrogen bonds'))
  grm.add_new_bond_restraints_in_place(
      proxies=[proxy],
      sites_cart=h.atoms().extract_xyz())
  simple, asu = grm.get_all_bond_proxies()
  # print(simple.size(), asu.size())
  assert (simple.size(), asu.size()) == (0,2)

  sites_cart = h.atoms().extract_xyz()
  site_labels = model.get_xray_structure().scatterers().extract_labels()
  pair_proxies = grm.pair_proxies(flags=None, sites_cart=sites_cart)

  out = StringIO()
  pair_proxies.bond_proxies.show_sorted(
      by_value="residual",
      sites_cart=sites_cart,
      site_labels=site_labels,
      f=out,
      prefix="")
  outtxt = out.getvalue()
  # print(outtxt)
  assert_lines_in_text(outtxt, """\
bond pdb=" CA  HIS A   2 "
     pdb=" N   MET A   1 "
  ideal  model  delta    sigma   weight residual sym.op.
  2.900  1.998  0.902 5.00e-02 4.00e+02 3.25e+02 x,y+1,z
bond pdb=" N   MET A   1 "
     pdb=" CA  HIS A   2 "
  ideal  model  delta    sigma   weight residual sym.op.
  2.900  1.998  0.902 5.00e-02 4.00e+02 3.25e+02 x,y-1,z
    """)

  es = grm.energies_sites(sites_cart=sites_cart, compute_gradients=True)
  out = StringIO()
  es.show(f=out)
  outtxt = out.getvalue()
  # print(outtxt)
  # do for x coordinate
  # ATOM      1  N   MET A   1       9.821   1.568   5.000  1.00 66.07           N
  # ATOM      2  CA  HIS A   2       9.946  12.171   5.357  1.00 66.55           C

  # calculation is from geometry_restraints/bond.h: gradient_0()
  # weight * 2 * delta_slack * d_distance_d_site_0(epsilon);
  # print("X gradient:", 400*2*0.902*(9.946-9.821)) # 90
  # Note that n=2 but residual sum is 325.349. 349 is chopped off in rounding in
  # cctbx/geometry_restraints/__init__py, def _bond_show_sorted_impl(...)
  # where %6.2e is used. in cctbx/geometry_restraints/energies.py: def show()
  # %.6g is used which is showing more numbers.
  assert_lines_in_text(outtxt, """\
      bond_residual_sum (n=2): 325.349""")
  # print("Gradients:", list(es.gradients))
  # Seems that gradients were splitted in half (note the X gradient is 90 8 lines above)
  assert approx_equal(list(es.gradients),
    [(45.135801792665134, -708.451544937652, 128.90784991984805), (-45.13580179266516, 708.4515449376522, -128.90784991984813)])

def exercise():
  mon_lib_srv = None
  ener_lib = None
  try:
    mon_lib_srv = monomer_library.server.server()
    ener_lib = monomer_library.server.ener_lib()
  except: # intentional
    print("Can not initialize monomer_library, skipping test.")
  if mon_lib_srv is not None and ener_lib is not None:
    exercise_add_new_bond_restraint_in_place(mon_lib_srv, ener_lib)
    exercise_single_atom(mon_lib_srv, ener_lib)
    exercise_multiple_atoms(mon_lib_srv, ener_lib)
    exercise_is_bonded_atoms(mon_lib_srv, ener_lib)
    exercise_add_super_long_bond(mon_lib_srv, ener_lib)
    exercise_bond_near_symmetry(mon_lib_srv, ener_lib)
    exercise_bond_near_symmetry2(mon_lib_srv, ener_lib)
    exercise_bond_near_symmetry3(mon_lib_srv, ener_lib)
    exercise_bond_over_symmetry(mon_lib_srv, ener_lib)
    exercise_bond_over_symmetry_2(mon_lib_srv, ener_lib)
    exercise_add_new_bond_when_long_bond_across_ASU(mon_lib_srv, ener_lib)

if (__name__ == "__main__"):
  exercise()
  print("OK")


 *******************************************************************************
