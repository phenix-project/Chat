

 *******************************************************************************
simtbx/diffBragg/mpi_logger.py
from __future__ import division, print_function
import os
import logging
import socket
HOST = socket.gethostname()
from libtbx.mpi4py import MPI
COMM = MPI.COMM_WORLD
if not hasattr(COMM, "rank"):
    COMM.rank = 0
    COMM.size = 1

# gather all hostnames and create sub-communicators for all processes on a given host
unique_hosts = COMM.gather(HOST)
HOST_MAP = None
if COMM.rank==0:
    HOST_MAP = {HOST:i for i,HOST in enumerate(set(unique_hosts))}
HOST_MAP = COMM.bcast(HOST_MAP)
HOST_COMM = COMM.Split(color=HOST_MAP[HOST])


LEVELS = {"low": logging.WARNING, "normal": logging.INFO, "high": logging.DEBUG}
DETAILED_FORMAT = 'RANK%d:%s | ' % (COMM.rank, HOST) + '%(asctime)s | %(filename)s:%(funcName)s >>  %(message)s'
SIMPLE_FORMAT = "RANK%04d "%(COMM.rank)+"| %(asctime)s | %(message)s"

from simtbx.diffBragg import utils


def _make_logger(loggername, filename=None, formatter=None, level=None, overwrite=False,
                propagate=False):
    """
    :param loggername: name for logger used throughout application
    :param filename: if logging to a file, this should be set
    :param formatter: logging Formatter object
    :param level: logging level number
    :param overwrite: whether to overwrite the existing logfile, if logging to files
    :param propagate: propagate messages to root logger, can result in duplicate messages
    :return: return the logger instance, however, once created here, the instance is accessible
            from other modules via the command logging.getLogger(loggername)
    """
    logger = logging.getLogger(loggername)
    if filename is not None:
        if COMM.rank == 0 and overwrite and os.path.exists(filename):
            os.remove(filename)
        COMM.barrier()
        handler = MPIFileHandler(filename, comm=HOST_COMM)
    else:
        handler = logging.StreamHandler()
    if formatter is not None:
        handler.setFormatter(formatter)
    if level is not None:
        logger.setLevel(level)
    logger.addHandler(handler)
    logger.propagate = propagate
    return logger


def setup_logging_from_params(params):
    """params: PHIL params, see simtbx.diffBragg.hopper phil string"""
    if params.logging.logfiles:
        if COMM.rank == 0:
            utils.safe_makedirs(params.outdir)
        COMM.barrier()
        main_level = LEVELS[params.logging.logfiles_level]
        logfile_name = params.logging.log_hostname*(HOST+"-") + params.logging.logname
        main_logger = _make_logger("diffBragg.main",
                                  os.path.join(params.outdir, logfile_name),
                                  level=main_level,
                                  overwrite=params.logging.overwrite,
                                  formatter=logging.Formatter(DETAILED_FORMAT))

        profile_name = params.logging.log_hostname*(HOST+"-") + params.profile_name
        _make_logger("diffBragg.profile",
                    os.path.join(params.outdir, profile_name),
                    level=logging.INFO,
                    overwrite=params.logging.overwrite,
                    formatter=logging.Formatter(SIMPLE_FORMAT))

        # for convenience we add a console logger for rank0 so we can optionally see output
        # even when logging to files
        if COMM.rank == 0:
            console = logging.StreamHandler()
            console.setFormatter(logging.Formatter(SIMPLE_FORMAT))
            console.setLevel(LEVELS[params.logging.rank0_level])
            main_logger.addHandler(console)

    else:
        if COMM.rank == 0:
            level = LEVELS[params.logging.rank0_level]
        else:
            level = LEVELS[params.logging.other_ranks_level]
        _make_logger("diffBragg.main", level=level, formatter=logging.Formatter(SIMPLE_FORMAT))
        _make_logger("diffBragg.profile", level=level, formatter=logging.Formatter(SIMPLE_FORMAT))


class MPIIOStream(object):
    # The class is from https://gist.github.com/sixy6e/ed35ea88ba0627e0f7dfdf115a3bf4d1

    def __init__(self, filename, comm, mode):

        self._file = MPI.File.Open(comm, filename, mode)
        self._file.Set_atomicity(True)

    def write(self, msg):
        # if for some reason we don't have a unicode string...
        try:
            msg = msg.encode()
        except AttributeError:
            pass
        self._file.Write_shared(msg)

    def sync(self):
        self._file.Sync()

    def close(self):
        self.sync()
        self._file.Close()


class MPIFileHandler(logging.StreamHandler):
    # The class is from https://gist.github.com/sixy6e/ed35ea88ba0627e0f7dfdf115a3bf4d1

    def __init__(self, filename,
                 mode=MPI.MODE_WRONLY|MPI.MODE_CREATE, comm=MPI.COMM_WORLD):
        self.filename = filename
        self.mode = mode
        self.comm = comm

        super(MPIFileHandler, self).__init__(self._open())

    def _open(self):
        stream = MPIIOStream(self.filename, self.comm, self.mode)
        return stream

    def close(self):
        if self.stream:
            self.stream.close()
            self.stream = None

    def emit(self, record):
        """
        Emit a record.
        We have to override emit, as the logging.StreamHandler has 2 calls
        to 'write'. The first for the message, and the second for the
        terminator. This posed a problem for mpi, where a second process
        could call 'write' in between these two calls and create a
        conjoined log message.
        """
        msg = self.format(record)
        self.stream.write('{}{}'.format(msg, self.terminator))
        self.flush()


def main():
    """
    A sample test run from https://gist.github.com/sixy6e/ed35ea88ba0627e0f7dfdf115a3bf4d1
    """
    comm = MPI.COMM_WORLD
    logger = logging.getLogger("node[%i]"%comm.rank)
    # logger = logging.getLogger("func-status") # another name example

    logger.setLevel(logging.DEBUG)

    mpi_handler = MPIFileHandler("test.log")
    formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
    mpi_handler.setFormatter(formatter)
    logger.addHandler(mpi_handler)

    # sample log levels
    logger.debug('debug message')
    logger.info('info message')
    logger.warning('warn message')
    logger.error('error message')
    logger.critical('critical message')


if __name__ == "__main__":
    main()


 *******************************************************************************


 *******************************************************************************
simtbx/diffBragg/parameter_errors.py
from __future__ import division

import os
import pandas
import numpy as np
from dials.array_family import flex

from shutil import copyfile
from simtbx.diffBragg import hopper_utils, utils
from dxtbx.model import ExperimentList


def load_expt_from_df(df, opt=False):
    """

    :param df: a hopper-formatted pandas dataframe with a single row
    :return: experiment
    """
    if opt:
        data_expt_name = df.opt_exp_name.values[0]
    else:
        data_expt_name = df.exp_name.values[0]
    assert os.path.exists(data_expt_name)
    data_expt = ExperimentList.from_file(data_expt_name)[0]
    return data_expt


def get_errors(phil_file,expt_name, refl_name, pkl_name, outfile_prefix=None, verbose=False, devid=0):
    """

    :param phil_file:
    :param expt_name:
    :param refl_name:
    :param pkl_name:
    :param outfile_prefix:
    :param verbose:
    :return:
    """
    params = utils.get_extracted_params_from_phil_sources(phil_file)
    Mod = hopper_utils.DataModeler(params)
    if not Mod.GatherFromExperiment(expt_name, refl_name):
        return
    df = pandas.read_pickle(pkl_name)
    Mod.SimulatorFromExperiment(df)
    if params.spectrum_from_imageset:
        data_expt = load_expt_from_df(df)
        spec = hopper_utils.downsamp_spec_from_params(params, data_expt)
    elif df.spectrum_filename.values[0] is not None:
        spec = utils.load_spectra_from_dataframe(df)
    else:
        data_expt = load_expt_from_df(df)
        spec = [(data_expt.beam.get_wavelength(), df.total_flux.values[0])]
    Mod.SIM.beam.spectrum = spec
    Mod.SIM.D.xray_beams = Mod.SIM.beam.xray_beams
    Mod.SIM.D.device_Id = devid
    target = hopper_utils.TargetFunc(Mod.SIM)
    # set up the refinement flags
    num_param = len(Mod.SIM.P)
    x0 = np.ones(num_param)

    vary = np.ones(num_param, bool)
    for p in Mod.SIM.P.values():
        if not p.refine:
            vary[p.xpos] = False

    target.vary = vary  # fixed flags
    target.x0 = np.array(x0, np.float64)

    if Mod.SIM.P["RotXYZ0_xtal0"].refine:
        Mod.SIM.D.refine(hopper_utils.ROTX_ID)
        Mod.SIM.D.refine(hopper_utils.ROTY_ID)
        Mod.SIM.D.refine(hopper_utils.ROTZ_ID)
    if Mod.SIM.P["Nabc0"].refine:
        Mod.SIM.D.refine(hopper_utils.NCELLS_ID)
    if Mod.SIM.P["Ndef0"].refine:
        Mod.SIM.D.refine(hopper_utils.NCELLS_ID_OFFDIAG)
    if Mod.SIM.P["ucell0"].refine:
        for i_ucell in range(len(Mod.SIM.ucell_man.variables)):
            Mod.SIM.D.refine(hopper_utils.UCELL_ID_OFFSET + i_ucell)
    if Mod.SIM.P["eta_abc0"].refine:
        Mod.SIM.D.refine(hopper_utils.ETA_ID)
    if Mod.SIM.P["detz_shift"].refine:
        Mod.SIM.D.refine(hopper_utils.DETZ_ID)
    if Mod.SIM.D.use_diffuse:
        Mod.SIM.D.refine(hopper_utils.DIFFUSE_ID)

    model_bragg, Jac = hopper_utils.model(x0, Mod.SIM, Mod.pan_fast_slow,compute_grad=True, dont_rescale_gradient=True)
    model_pix = model_bragg + Mod.all_background
    # TODO
    #if params.simulator.psf.use:
    #    model_pix =

    u = Mod.all_data - model_pix  # residuals, named "u" in notes

    sigma_rdout = params.refiner.sigma_r / params.refiner.adu_per_photon
    v = model_pix + sigma_rdout**2
    one_by_v = 1/v
    G = 1-2*u - u*u*one_by_v
    coef = one_by_v*(one_by_v*G - 2  - 2*u*one_by_v -u*u*one_by_v*one_by_v)

    coef_t = coef[Mod.all_trusted]
    Jac_t = Jac[:,Mod.all_trusted]
    # if we are only optimizing Fhkl, then the Hess is diagonal matrix
    diag_Hess = -.5*np.sum(coef_t*(Jac_t)**2, axis=1)
    with np.errstate(divide='ignore', invalid='ignore'):
        variance_s = 1/diag_Hess

    ## if we optimized per-shot scale along with Fhkl scales, then the Hess is an arrow matrix (diagonal with elem in first row/col)
    #name_to_i_Hess = {}
    #name_to_i_Hess["G_xtal0"] = 0
    #i_Hess = 1
    #for name in Mod.SIM.P:
    #    if name.startswith("scale_roi"):
    #        name_to_i_Hess[name] = i_Hess
    #        i_Hess += 1
    #Hess = np.zeros((len(name_to_i_Hess), len(name_to_i_Hess)))
    #scale_p = Mod.SIM.P["G_xtal0"]
    #overall_scale = scale_p.get_val(x0[scale_p.xpos])
    #name_from_i_Hess = {i:name for name,i in name_to_i_Hess.items()}

    #for name in name_to_i_Hess:
    #    p = Mod.SIM.P[name]
    #    xpos = p.xpos
    #    i_Hess = name_to_i_Hess[name]
    #    val = diag_Hess[xpos]
    #    Hess[i_Hess, i_Hess] = val

    ## offdiagonal terms
    #jac_coef_t = (.5*one_by_v*G)[Mod.all_trusted]
    #for i_Hess in range(1, len(name_to_i_Hess)):
    #    name = name_from_i_Hess[i_Hess]
    #    p = Mod.SIM.P[name]

    #    val_off_diag = jac_coef_t*Jac_t[p.xpos]
    #    val_off_diag = val_off_diag.sum() / overall_scale

    #    Hess[0, i_Hess] = val_off_diag
    #    Hess[i_Hess, 0] = val_off_diag

    Fp1 = Mod.SIM.crystal.miller_array
    Fp1_map = {h:amp for h,amp in zip(Fp1.indices(), Fp1.data())}

    sg = Mod.SIM.crystal.dxtbx_crystal.get_space_group()
    sgi = sg.info()
    to_p1 = sgi.change_of_basis_op_to_primitive_setting()
    to_ref = to_p1.inverse()
    F2 = Mod.SIM.crystal.miller_array.change_basis(to_ref)
    Fmap = {h:amp for h,amp in zip(F2.indices(), F2.data())}

    nremove = 0

    all_I = []
    all_s = []
    all_varI = []
    #assert len(Mod.roi_id_unique) == len(Mod.refls)
    flex_varI = flex.double(len(Mod.refls),0)
    flex_I = flex.double(len(Mod.refls),0)
    sel = flex.bool(len(Mod.refls), False)

    Mod.set_slices("all_refls_idx")
    #for roi_id in Mod.roi_id_unique:
    for refl_idx in Mod.all_refls_idx_unique:
        refl_idx = int(refl_idx)
        data_slc = Mod.all_refls_idx_slices[refl_idx]
        assert len(data_slc)==1
        data_slc = data_slc[0]
        roi_id = int(Mod.roi_id[data_slc][0])
        p = Mod.SIM.P["scale_roi%d" % roi_id]
        # TODO : double check scale evaluated from x=1
        scale = p.get_val(1)
        var_s = variance_s[p.xpos]
        hkl = Mod.hi_asu_perpix[data_slc][0]
        #if hkl not in Fp1_map:
        if hkl not in Fmap:
            if verbose:
                print("refl %d   has miller index thats not in Fmap: " % refl_idx, hkl)
            nremove += 1
            continue
        amp = Fmap[hkl]
        I_hkl = amp**2
        var_I = I_hkl **2 * var_s
        if var_I <= 1e-6 or var_I > 1e16:
            if verbose:
                print("refl %d  has wacky variance" % refl_idx)
            nremove += 1
            continue
        I = scale*I_hkl
        h,k,l=hkl
        if verbose:
            print("hkl=%d,%d,%d . I=%f +- %f" %(h,k,l, I, var_I))
        all_I.append(I)
        all_varI.append(var_I)
        all_s.append(scale)

        #refl_idx = int(Mod.all_refls_idx[data_slc][0])
        sel[refl_idx] = True
        flex_I[refl_idx] = I
        flex_varI[refl_idx] = var_I

        refl = Mod.refls[refl_idx]
        assert refl["scale_factor"] == scale

    Mod.refls["intensity.sum.value"] = flex_I
    Mod.refls["intensity.sum.variance"] = flex_varI
    Mod.refls["xyzobs.px.value"] = Mod.refls["xyzcal.px"]
    integ_refls = Mod.refls.select(sel)
    #all_s = np.array(all_s)
    #all_I = np.array(all_I)
    #all_varI = np.array(all_varI)
    if verbose:
        print("removed %d / %d refls" % (nremove, len(Mod.refls)))

    hopper_utils.free_SIM_mem(Mod.SIM)
    if outfile_prefix is not None:
        integ_refls.as_file(outfile_prefix+"_integrated.refl")
        copyfile(expt_name, outfile_prefix+"_integrated.expt")
    if verbose:
        print("Done.")


if __name__=="__main__":
    from argparse import ArgumentParser
    parser = ArgumentParser()
    parser.add_argument("phil", type=str, help="path to a simtbx.diffBragg phil file")
    parser.add_argument("expt", type=str, help="path to an experiment list file")
    parser.add_argument("refl", type=str, help="path to a reflection table")
    parser.add_argument("pkl", type=str,
                        help="path to a pandas pkl created by simtbx.diffBragg.hopper or simtbx.diffBragg.hopper_process")
    parser.add_argument("--loud", action="store_true", help="show more output")
    args = parser.parse_args()
    import logging

    logger = logging.getLogger("diffBragg.main")
    logger.setLevel(logging.DEBUG)
    get_errors(args.phil, args.expt, args.refl, args.pkl, verbose=args.loud)


 *******************************************************************************


 *******************************************************************************
simtbx/diffBragg/phil.py
from __future__ import absolute_import, division, print_function
from iotbx.phil import parse

#help_message = '''
#diffBragg command line utility
#'''

hopper_phil = """

filter_during_refinement {
  enable = False
    .type = bool
    .help = if True, filtering will occur each N iterations, controlled by parameter after_n
  after_n = 50
    .type = int
    .help = refiner will pause and check for outliers every after_n iterations
  threshold = 20
    .type = float
    .help = outliers are detected by looking at the distribution of per shoebox sigmaZ
    .help = and then using a median absolute deviation filter. Lower values of threshold will flag more pixels as outliers
}

filter_after_refinement {
  enable = False
    .type = bool
    .help = if True, filter, then rerun refinement if certain conditions are met (e.g. too few refinement iterations)
  max_attempts = 2
    .type = int
    .help = how many additional times to run hopper
  min_prev_niter = 50
    .type = int
    .help = only repeat if the previous refinement was fewer than this many iterations
  max_prev_sigz = 10
    .type = float
    .help = only repeat if the previous refinement had sigma Z more than this
  threshold = 20
    .type = float
    .help = outliers are detected by looking at the distribution of per shoebox sigmaZ
    .help = and then using a median absolute deviation filter. Lower values of threshold will flag more pixels as outliers
}

symmetrize_Flatt = False
  .type = bool
  .help = If True, add 3-fold symmetric mosaic blocks to the calculation of F_latt
record_device_timings = False
  .type = bool
  .help = Record the execution times of diffBragg host-dev copies and kernel executions
  .help = the results will be printed to the terminal
consider_multicrystal_shots = False
  .type = bool
  .help = If True, and if there are multiple crystals in the experiment list,
  .help = then try to model all crystals for a given shot.
debug_mode = False
  .type = bool
  .help = If True, many output files are written to explore the diffBragg models in great detail
nominal_Fhkl_only = True
  .type = bool
  .help = if refining Fhkls, only refine the ones that are assigned to a reflection table...
use_geometric_mean_Fhkl = False
  .type = bool
  .help = whether to use the geometric mean for Fhkl restraint (when betasFhkl is not None, restratin Fhkl to the mean in each res bin)
Fhkl_channel_bounds = None
  .type = floats
  .help = Energy bounds for energy-dependent structure factors. Units are eV.
  .help = If provided refine a unique structure factor correction for each bin defined by Fhkl_channel_bins
  .help = 0 and infinity are implicit. Providing a single number, e.g. 8950, will refine two sets of structure
  .help = factors: one for energies [0-8950), and another for energies [8950-infinity]
Fhkl_dspace_bins = 10
  .type = int
  .help = number of resolution bins (out to corner of detector) for computing the average structure factor intensity
  .help = One can then restrain to these values when fix.Fhkl=False by using the restraint strength betas.Fhkl (default is None in which case no restraints are applied)
try_strong_mask_only = False
  .type = bool
  .help = if strong spot masks are present in the input refls, then use them
  .help = as the trusted-flags, i.e. only run strong spot pixels through diffBragg
dilate_strong_mask = None
  .type = int
  .help = if using strong mask only for refinement, then dilate it this many iterations using
  .help = scipy.ndimage method binary_dilation (has to be >= 1)
hopper_save_freq = None
  .type = int
  .help = save the output files when the iteration number is a multiple of this argument
terminate_after_n_converged_iter = None
  .type = int
  .help = optionally converge if all parameters seem converged for this many iterations. See
  .help = converged_param_percent_change
converged_param_percent_change = 0.1
  .type = float
  .help = if a parameter's value changes by less than this amount (percent) between iterations, for a
  .help = a ceterain number of iters (determined by terminate_after_n_converged_iter), then
  .help = optimization is considered done, and is stopped
mask_highest_values = None
  .type = int
  .help = mask out the N highest-valued pixels in a shoebox when performing diffBragg refinement
use_float32 = False
  .type = bool
  .help = store pixel data and background models in 32bit arrays
  .expert_level=10
test_gathered_file = False
  .type = bool
  .help = run a quick test to ensure the gathered data file preserves information
  .expert_level=10
load_data_from_refls = False
  .type = bool
  .help = load image data, background etc from reflection tables
  .expert_level=10
gathered_output_file = None
  .type = str
  .help = optional file for storing a new hopper input file which points to the gathered data dumps
  .expert_level=10
only_dump_gathers = False
  .type = bool
  .help = only reads in image data, fits background planes, and dumps
  .help = results to disk, writes a new exper refl file at the end
  .expert_level=10
gathers_dir = None
  .type = str
  .help = folder where gathered data reflection tables
  .help = will be writen (if dump_gathers=True)
  .expert_level=10
dump_gathers = False
  .type = bool
  .help = optionally dump the loaded experimental data to reflection tables
  .help = for portability
  .expert_level=10
spectrum_from_imageset = False
  .type = bool
  .help = if True, load the spectrum from the imageset in the experiment, then probably downsample it
  .expert_level=0
gen_gauss_spec = False
  .type = bool
  .help = If the experimental data dont include spectra, one can try generating gaussian spectra.
  .help = See the diffBragg/phil.py under simulator.spectrum.gauss_spec.
use_perpixel_dark_rms = False
  .type = bool
  .help = some Jungfrau formats have per-pixel RMS values that change shot-to-shot with the dynamic
  .help = gain mode switching. If this flag is true, then the per-pixel gain modes will be extracted from the image
  .help = format . The image format class is expected to have a method named  get_pedestal_rms(self, index=None)
  .help = See the method xfel/util/jungfrau/get_pedestalRMS-from_jungfrau
isotropic {
  diffuse_gamma = False
    .type = bool
    .help = refine a single diffuse gamma parameter as opposed to 3
  diffuse_sigma = False
    .type = bool
    .help = refine a single diffuse gamma parameter as opposed to 3
}
downsamp_spec {
  skip = False
    .type = bool
    .help = if reading spectra from imageset, optionally skip the downsample portion
    .help = Note, if skip=True, then total flux will be determined by whats in the imageset spectrum (sum of the weights)
    .expert_level=10
  filt_freq = 0.07
    .type = float
    .help = low pass filter frequency in units of inverse spectrometer pixels (??)
    .expert_level=10
  filt_order = 3
    .type = int
    .help = order for bandpass butter filter
    .expert_level=10
  tail = 50
    .type = int
    .help = endpoints of the spectrum that are used in background estimation
    .expert_level=10
  delta_en = 0.5
    .type = float
    .help = final resolution of downsampled spectrum in eV
    .expert_level=0
}
filter_unpredicted_refls_in_output = True
  .type = bool
  .help = filter reflections in the output refl table for which there was no model bragg peak
  .help = after stage 1 termination
  .expert_level=10
tag = stage1
  .type = str
  .help = output name tag
  .expert_level=0
ignore_existing = False
  .type = bool
  .help = experimental, ignore expts that already have optimized models in the output dir
  .expert_level=0
global_method = *basinhopping annealing
  .type = choice
  .help = the method of global optimization to use
  .expert_level=10
nelder_mead_maxfev = 60
  .type = int
  .help = multiplied by total number of modeled pixels to get max number of iterations
  .expert_level=10
nelder_mead_fatol = 0.0001
  .type = float
  .help = nelder mead functional error tolerance
niter_per_J = 1
  .type = int
  .help = if using gradient descent, compute gradients
  .help = every niter_per_J iterations .
  .expert_level=10
rescale_params = True
  .type = bool
  .help = DEPRECATED, this parameter no longer has meaning.
  .expert_level=10
best_pickle = None
  .type = str
  .help = path to a pandas pickle containing the best models for the experiments
  .expert_level=0
betas
  .help = variances for the restraint targets
  .expert_level=0
{
  Finit = None
    .type = float
  Friedel = None
    .type = float
    .help = set this to some value to restraint Friedel mates during refinement (ensemble mode) . Lower values are
    .help = tightly restrained . (Exploratory, experimental phil param)
  ucell_a = None
    .type = float
    .help = restraint variance for unit cell a
  ucell_b = None
    .type = float
    .help = restraint variance for unit cell b
  ucell_c = None
    .type = float
    .help = restraint variance for unit cell c
  ucell_alpha = None
    .type = float
    .help = restraint variance for unit cell alpha angle
  ucell_beta = None
    .type = float
    .help = restraint variance for unit cell beta angle
  ucell_gamma = None
    .type = float
    .help = restraint variance for unit cell gamma angle
  Nvol = None
    .type = float
    .help = tightness of the Nabc volume contraint
  detz_shift = None
    .type = float
    .help = restraint variance for detector shift target
  ucell = None
    .type = floats
    .help = DEPRECATED: use e.g. betas.ucell_a instead
    .help = variances for unit cell constants in order determined by unit cell manager class (see diffBragg/refiners/crystal_systems)
  RotXYZ = None
    .type = float
    .help = restraint factor for the rotXYZ restraint
  Nabc = None
    .type = floats(size=3)
    .help = restraint factor for the ncells abc
  Ndef = None
    .type = floats(size=3)
    .help = restraint factor for the ncells def
  diffuse_sigma = None
    .type = floats(size=3)
    .help = restraint factor for diffuse sigma
  diffuse_gamma = None
    .type = floats(size=3)
    .help = restraint factor for diffuse gamma
  G = None
    .type = float
    .help = restraint factor for the scale G
  B = None
    .type = float
    .help = restraint factor for Bfactor
  eta_abc = None
    .type = floats(size=3)
    .help = restrain factor for mosaic spread angles
  spec = None
    .type = floats(size=2)
    .help = restraint factor for spectrum coefs
  Fhkl = None
    .type = float
    .help = restraint factor for structure factor intensity scales
}
dual
  .help = configuration parameters for dual annealing
  .expert_level=10
{
  initial_temp = 5230
    .type = float
    .help = init temp for dual annealing
  no_local_search = False
    .type = bool
    .help = whether to try local search procedure with dual annealing
    .help = if False, then falls back on classical simulated annealing
  visit = 2.62
    .type = float
    .help = dual_annealing visit param, see scipy optimize docs
  accept = -5
    .type = float
    .help = dual_annealing accept param, see scipy optimize docs
}
centers
  .help = restraint targets
  .expert_level=0
{
  ucell_a = None
    .type = float
    .help = restraint target for unit cell a (Angstrom)
  ucell_b = None
    .type = float
    .help = restraint target for unit cell b (Angstrom)
  ucell_c = None
    .type = float
    .help = restraint target for unit cell c (Angstrom)
  ucell_alpha = None
    .type = float
    .help = restraint target for unit cell alpha angle (deg.)
  ucell_beta = None
    .type = float
    .help = restraint target for unit cell beta angle (deg.)
  ucell_gamma = None
    .type = float
    .help = restraint target for unit cell gamma angle (deg.)
  Nvol = None
    .type = float
    .help = if provided, constrain the product Na*Nb*Nc to this value
  detz_shift = None
    .type = float
    .help = restraint target for detector shift along z-direction
  RotXYZ = None
    .type = floats(size=3)
    .help = restraint target for Umat rotations
  Nabc = None
    .type = floats(size=3)
    .help = restraint target for Nabc
  Ndef = None
    .type = floats(size=3)
    .help = restraint target for Ndef
  diffuse_sigma = None
    .type = floats(size=3)
    .help = restraint target for diffuse sigma
  diffuse_gamma = None
    .type = floats(size=3)
    .help = restraint target for diffuse gamma
  G = None
    .type = float
    .help = restraint target for scale G
  B = None
    .type = float
    .help = restraint target for Bfactor
  eta_abc = None
    .type = floats(size=3)
    .help = restraint target for mosaic spread angles in degrees
  spec = None
    .type = floats(size=2)
    .help = restraint target for specturm correction (0 + 1*Lambda )
}
skip = None
  .type = int
  .help = skip this many exp
  .expert_level=0
hess = None
  .type = str
  .help = scipy minimize hessian argument, 2-point, 3-point, cs, or None
  .expert_level=10
stepsize = 0.5
  .type = float
  .help = basinhopping stepsize
  .expert_level=10
temp = 1
  .type = float
  .help = temperature for basin hopping algo
  .expert_level=10
niter = 0
  .type = int
  .help = number of basin hopping iterations (0 just does a gradient descent and stops at the first minima encountered)
  .expert_level=0
exp_ref_spec_file = None
  .type = str
  .help = path to 3 col txt file containing file names for exper, refl, spectrum (.lam)
  .help = Note: only single-image experiment lists are supported! Uses dials.split_experiments or diffBragg.make_input_file if necessary
  .expert_level=0
method = None
  .type = str
  .help = minimizer method, usually this is L-BFGS-B (gradients) or Nelder-Mead (simplex)
  .help = other methods are experimental (see details in hopper_utils.py)
  .expert_level=0
opt_det = None
  .type = str
  .help = path to experiment with optimized detector model
  .expert_level=0
opt_beam = None
  .type = str
  .help = path to experiment with optimized beam model
  .expert_level=0
number_of_xtals = 1
  .type = int
  .help = number of crystal domains to model per shot
  .expert_level=10
sanity_test_input = True
  .type = bool
  .help = sanity test input
  .expert_level=10
outdir = None
  .type = str
  .help = output folder
  .expert_level=0
max_process = -1
  .type = int
  .help = max exp to process
  .expert_level=0
types
  .help = type of target to parameter (see diffBragg.refiners.parameters.py)
  .expert_level=10
{
  G = *ranged positive
    .type = choice
  Nabc = *ranged positive
    .type = choice
  diffuse_sigma = *ranged positive
    .type = choice
  diffuse_gamma = *ranged positive
    .type = choice
}
sigmas
  .help = sensitivity of target to parameter (experimental)
  .expert_level=10
{
  spec = [1,1]
    .type=floats(size=2)
    .help = spectrum offset and scale factor sigmas
  roiPerScale = 1
    .type = float
  detz_shift = 1
    .type = float
    .help = sensitivity shift for the overall detector shift along z-direction
  Nabc = [1,1,1]
    .type = floats(size=3)
    .help = sensitivity for Nabc
  Ndef = [1,1,1]
    .type = floats(size=3)
    .help = sensitivity for Ndef
  diffuse_sigma = [1,1,1]
    .type = floats(size=3)
    .help = sensitivity for diffuse sigma
  diffuse_gamma = [1,1,1]
    .type = floats(size=3)
    .help = sensitivity for diffuse gamma
  RotXYZ = [1e-3,1e-3,1e-3]
    .type = floats(size=3)
    .help = sensitivity for RotXYZ in radians
  G = 1
    .type = float
    .help = sensitivity for scale factor
  B = 1
    .type = float
    .help = sensitivity for Bfactor
  eta_abc = [1,1,1]
    .type = floats(size=3)
    .help = sensitivity of mosaic spread parameters
  ucell = [1,1,1,1,1,1]
    .type = floats
    .help = sensitivity for unit cell params
  Fhkl = 1
    .type = float
    .help = sensitivity for structure factors
}
init
  .help = initial value of model parameter (will be overrided if best pickle is provided)
  .expert_level=0
{
  random_Gs = None
    .type = floats
    .help = list of floats from which to select an init.G at random
  random_Nabcs = None
    .type = floats
    .help = list of random floats from which to select init.Nabc at random
  spec = [0,1]
    .type = floats(size=2)
    .help = initial offset and scale factor applied to each energy channel wavelength
  detz_shift = 0
    .type = float
    .help = initial value for the detector position overall shift along z-direction in millimeters
  Nabc = [100,100,100]
    .type = floats(size=3)
    .help = init for Nabc
  Ndef = [0,0,0]
    .type = floats(size=3)
    .help = init for Ndef
  diffuse_sigma = [.01,.01,.01]
    .type = floats(size=3)
    .help = init diffuse sigma
  diffuse_gamma = [1,1,1]
    .type = floats(size=3)
    .help = init for diffuse gamma
  RotXYZ = [0,0,0]
    .type = floats(size=3)
    .help = init for RotXYZ in radians
  G = 1
    .type = float
    .help = init for scale factor
  B = 0
    .type = float
    .help = init for B factor
  eta_abc = [0,0,0]
    .type = floats(size=3)
    .help = initial values (in degrees) for anisotropic mosaic spread about the 3 crystal axes a,b,c
    .help = Note, these can never be exactly 0 if fix.eta_abc=False
}
mins
  .help = min value allowed for parameter
  .expert_level = 0
{
  detz_shift = -10
    .type = float
    .help = min value for detector z-shift in millimeters
  Nabc = [3,3,3]
    .type = floats(size=3)
    .help = min for Nabc
  Ndef = [-200,-200,-200]
    .type = floats(size=3)
    .help = min for Ndef
  diffuse_sigma = [0,0,0]
    .type = floats(size=3)
    .help = min diffuse sigma
  diffuse_gamma = [0,0,0]
    .type = floats(size=3)
    .help = min for diffuse gamma
  RotXYZ = [-3.1415926, -3.1415926, -3.1415926]
    .type = floats(size=3)
    .help = min for rotXYZ in radians
  G = 0
    .type = float
    .help = min for scale G
  B = 0
    .type = float
    .help = min for Bfactor
  Fhkl = 0
    .type = float
    .help = min for structure factors
  eta_abc = [0,0,0]
    .type = floats(size=3)
    .help = min value (in degrees) for mosaic spread angles
  spec = [-0.01, 0.95]
    .type = floats(size=2)
    .help = min value for spectrum correction (-0.01 + Lambda *1.05)
}
maxs
  .help = max value allowed for parameter
  .expert_level = 0
{
  detz_shift = 10
    .type = float
    .help = max value for detector z-shift in millimeters
  eta = 0.1
    .type = float
    .help = maximum mosaic spread in degrees
  Nabc = [300,300,300]
    .type = floats(size=3)
    .help = max for Nabc
  Ndef = [200,200,200]
    .type = floats(size=3)
    .help = max for Ndef
  diffuse_sigma = [20,20,20]
    .type = floats(size=3)
    .help = max diffuse sigma
  diffuse_gamma = [10000,10000,10000]
    .type = floats(size=3)
    .help = max for diffuse gamma
  RotXYZ = [3.1415926, 3.1415926, 3.1415926]
    .type = floats(size=3)
    .help = max for rotXYZ in radians
  G = 1e12
    .type = float
    .help = max for scale G
  B = 1e3
    .type = float
    .help = max for Bfactor
  eta_abc = [10,10,10]
    .type = floats(size=3)
    .help = maximum value (in degrees) for mosaic spread angles
  Fhkl = 1e6
    .type = float
    .help = max for structure factors
  spec = [0.01, 1.05]
    .type = floats(size=2)
    .help = max value for spectrum correction (0.01 + Lambda *1.05)
}
fix
  .help = flags for fixing parameters during refinement
  .expert_level = 0
{
  Fhkl = True
    .type = bool
    .help = fix the structure factors scales during refinement
  spec = True
    .type = bool
    .help = fix the spectrum. If False, a spectrum correction is refined (wavelength shift and scale)
  perRoiScale = True
    .type = bool
    .help = a per-roi scale factor
  G = False
    .type = bool
    .help = fix the Bragg spot scale during refinement
  B = True
    .type = bool
    .help = fix the Bfactor during refinement
  eta_abc = True
    .type = bool
    .help = fix the mosaic spread parameters during refinement
  RotXYZ = False
    .type = bool
    .help = fix the misorientation matrix during refinement
  Nabc = False
    .type = bool
    .help = fix the diagonal mosaic domain size parameters during refinement
  Ndef = True
    .type = bool
    .help = fix the diagonal mosaic domain size parameters during refinement
  diffuse_sigma = True
    .type = bool
    .help = fix diffuse sigma
  diffuse_gamma = True
    .type = bool
    .help = fix diffuse gamma
  ucell = False
    .type = bool
    .help = fix the unit cell during refinement
  detz_shift = True
    .type = bool
    .help = fix the detector distance shift during refinement
}
relative_tilt = False
  .type = bool
  .help = fit tilt coef relative to roi corner
  .expert_level = 10
ucell_edge_perc = 10
  .type = float
  .help = precentage for allowing ucell to fluctuate during refinement
  .expert_level = 10
ucell_ang_abs = 5
  .type = float
  .help = absolute angle deviation in degrees for unit cell angles to vary during refinement
  .expert_level = 10
no_Nabc_scale = False
  .type = bool
  .help = toggle Nabc scaling of the intensity
  .expert_level = 10
use_diffuse_models = False
  .type = bool
  .help = if True, let the values of init.diffuse_sigma and init.diffuse_gamma
  .help = be used to define the diffuse scattering. Set e.g. fix.diffuse_sigma=True in order to refine them
  .expert_level = 10
diffuse_stencil_size = 0
  .type = int
  .help = Increase to add accuracy to diffuse scattering models, at the expense of longer computations
  .help = Best to increment by values of 1 when testing
diffuse_orientation = 1
  .type = int
  .help = orient the diffuse scattering features. 0 is along (a-b, a+b, c), 1 is along (a,b,c)
symmetrize_diffuse = True
  .type = bool
  .help = use the laue group rotation operators to symmetrize diffuse signals
gamma_miller_units = False
  .type = bool
  .help = if True, let the values of init.diffuse_gamma be expressed in Miller index units
  .expert_level = 10
sigma_frac = None
  .type = float
  .help = sigma for Fhkl restraints will be some fraction of the starting value
  .expert_level = 10
sanity_test_hkl_variation = False
  .type = bool
  .help = measure the variation of each HKL within the shoebox
  .expert_level = 10
sanity_test_models = False
  .type = bool
  .help = make sure best models from stage 1 are reproduced at the start
  .expert_level = 10
sanity_test_amplitudes = False
  .type = bool
  .help = if True, then quickly run a sanity check ensuring that all h,k,l are predicted
  .help = and/or in the starting miller array
  .expert_level = 10
x_write_freq = 25
  .type = int
  .help = save x arrays every x_write_freq iterations
  .expert_level = 10
percentile_cut = None
  .type = float
  .help = percentile below which pixels are masked
  .expert_level = 10
remove_duplicate_hkl = False
  .type = bool
  .help = for hopper, remove duplicate HKLs in input refl files
space_group = None
  .type = str
  .help = space group to refine structure factors in
  .expert_level = 0
first_n = None
  .type = int
  .help = refine the first n shots only
  .expert_level = 0
maxiter = 15000
  .type = int
  .help = stop refiner after this many iters
  .expert_level = 10
ftol = 1e-10
  .type = float
  .help = ftol convergence threshold for scipys L-BFGS-B
  .expert_level = 10
lbfgs_maxiter = 1e5
  .type = int
  .help = maximum number of L-BFGS-B iterations
disp = False
  .type = bool
  .help = scipy minimize convergence printouts
  .expert_level = 10
use_restraints = False
  .type = bool
  .help = enable the parameter restraints
  .expert_level = 0
min_multi = 2
  .type = int
  .help = minimum ASU multiplicity, obs that fall below this threshold
  .help = are removed from analysis
  .expert_level = 10
min_spot = 5
  .type = int
  .help = minimum spots on a shot in order to optimize that shot
  .expert_level = 10
store_wavelength_images = False
  .type = bool
  .help = for simtbx.diffBragg.hopper, optionally write subimages whose value
  .help = is the avereage wavelength per pixels, weighted by the model
logging
  .help = controls the logging module for hopper and stage_two
  .expert_level = 10
{
  show_params_at_minimum = True
    .type = bool
    .help = show the optimized parameters once a basinhopping minimum is reached
  parameters = False
    .type = bool
    .help = whether to display hopper refinement parameters at each iteration
  disable = False
    .type = bool
    .help = turn off logging
  logfiles_level = low *normal high
    .type = choice
    .help = level of the main log when writing logfiles
  logfiles = False
    .type = bool
    .help = write log files in the outputdir
  rank0_level = low *normal high
    .type = choice
    .help = console log level for rank 0, ignored if logfiles=True
  other_ranks_level = *low normal high
    .type = choice
    .help = console log level for all ranks > 0, ignored if logfiles=True
  overwrite = True
    .type = bool
    .help = overwrite the existing logfiles
  logname = mainLog
    .type = str
    .help = if logfiles=True, then write the log to this file, stored in the folder specified by outdir
    .help = if None, then defaults to main_stage1.log for hopper, main_pred.log for prediction, main_stage2.log for stage_two
  log_hostname = True
    .type = bool
    .help = prefix logfiles with host name
}
profile = False
  .type = bool
  .help = profile the workhorse functions
  .expert_level = 0
profile_name = lineProf
  .type = str
  .help = name of the output file that stores the line-by-line profile (written to folder specified by outdir)
  .help = if None, defaults to prof_stage1.log, prof_pred.log, prof_stage2.log for hopper, prediction, stage_two respectively
  .expert_level = 10
"""

simulator_phil = """
simulator {
  oversample = 0
    .type = int
    .help = pixel oversample rate (0 means auto-select)
  device_id = 0
    .type = int
    .help = device id for GPU simulation
  init_scale = 1
    .type = float
    .help = initial scale factor for this crystal simulation
  total_flux = 1e12
    .type = float
    .help = total photon flux for all energies
  crystal {
    ncells_abc = (10,10,10)
      .type = floats(size=3)
      .help = number of unit cells along each crystal axis making up a mosaic domain
    ncells_def = (0,0,0)
      .type = floats(size=3)
      .help = off-diagonal components for mosaic domain model (experimental)
    has_isotropic_ncells = False
      .type = bool
      .help = if True, ncells_abc are constrained to be the same values during refinement
    has_isotropic_mosaicity = False
      .type = bool
      .help = if True, eta_abc are constrained to be the same values during refinement
    mosaicity = 0
      .type = float
      .help = mosaic spread in degrees
    anisotropic_mosaicity = None
      .type = floats
      .help = mosaic spread 3-tuple or 6-tuple specifying anisotropic mosaicity
    num_mosaicity_samples = 1
      .type = int
      .help = the number of mosaic domains to use when simulating mosaic spread
    mos_angles_per_axis = 10
      .type = int
      .help = if doing a uniform mosaicity sampling, use this many angles per rotation axis
    num_mos_axes = 10
      .type = int
      .help = number of sampled rot axes if doing a uniform mosaicity sampling
    mosaicity_method = 2
      .type = int
      .help = 1 or 2. 1 is random sampling, 2 is even sampling
    rotXYZ_ucell = None
      .type = floats(size=9)
      .help = three missetting angles (about X,Y,Z axes), followed by
      .help = unit cell parameters. The crystal will be rotated according to
      .help = the matrix RotX*RotY*RotZ, and then the unit cell will be updated
  }
  gonio {
    delta_phi = None
      .type = float
      .help = Angular amount in degrees by which goniometer is rotated during shot
    phi_steps = 50
      .type = int
      .help = number of discrete angular positions to model
  }
  structure_factors {
    from_pdb {
      name = None
        .type = str
        .help = path to a pdb file
      add_anom = True
        .type = bool
        .help = Use the dxtbx beams wavelength to sample the henke tables
        .help = and add anomalous contributions from each atom
      k_sol = None
        .type = float
        .help = solvent component of structure factor: k_sol * exp(-b_sol*s^2/4)
      b_sol = None
        .type = float
        .help = solvent component of structure factor: k_sol * exp(-b_sol*s^2/4)
    }
    mtz_name = None
      .type = str
      .help = path to an MTZ file . If an mtz_name and from_pdb.name are both provided, then
      .help = the mtz takes precedence
    mtz_column = None
      .type = str
      .help = column in an MTZ file
    dmin = 1
      .type = float
      .help = minimum resolution for structure factor array (not applicable when F is loaded from mtz)
    dmax = None
      .type = float
      .help = maximum resolution for structure factor array (not applicable when F is loaded from mtz)
    default_F = 0
      .type = float
      .help = Default value for structure factor amps . MIssing structure factors will have this value
      .help = during simulation, for example if the mtz is incomplete. Also, if mtz_name and
      .help = from_pdb.name are both None, then a structure factor array will be created with this
      .help = value as every amplitude.
  }
  spectrum {
    filename = None
      .type = str
      .help = a .lam file (precognition) for inputting wavelength spectra
    stride = 1
      .type = int
      .help = stride of the spectrum (e.g. set to 10 to keep every 10th value in the spectrum file data)
    filename_list = None
      .type = str
      .help = path to a file containing 1 .lam filename per line
    gauss_spec {
      fwhm = 10
        .type = float
        .help = width of the gaussian in electron volts
      nchannels = 20
        .type = int
        .help = total number of spectrum energies, centered on the shots nominal energy as determined from format class
      res = 1
        .type = float
        .help = energy resolution of the spectrum
    }
  }
  beam {
    size_mm = 1
      .type = float
      .help = diameter of the beam in mm
  }
  detector {
    thick = None
      .type = float
      .help = sensor thickness in millimeters. Overrides dxtbx detector model.
      .help = Note: must also provide param `atten`, otherwise this param is ineffective
    atten = None
      .type = float
      .help = x-ray absorption length in millimeters
      .help = for sensor. Overrides dxtbx detector model.
      .help = Note: must also provide param `thick`, otherwise this param is ineffective
    force_zero_thickness = False
      .type = bool
      .help = if True, then set sensor thickness to 0
    thicksteps = 1
      .type = int
      .help = number of layers within sensor where scattering
      .help = will be averaged over (evenly divided). This is a nanoBragg attribute
  }
  psf {
    use = False
      .type = bool
      .help = optionally apply a point-spread-function to the model
    fwhm = 100
      .type = float
      .help = PSF full width half max in microns
    radius = 7
      .type = int
      .help = PSF kernel radius (in pixels)
  }
}
"""

refiner_phil = """
refiner {
  check_expt_format = True
    .type = bool
    .help = In some cases the expt is only used for the crystal model, in which case set check_expt_format=False.
    .help = If, however, the experimental data and/or spectra are to be extracted from the expt, then this
    .help = should  remain True.
  refldata_trusted = *allValid fg bg
    .type = choice
    .help = If loading data from reflection table, choose which pixels are flagged as trusted/
    .help = The default is allValid, meaning any shoebox mask value > 1.
    .help = fg is any foreground (integrated), valid pixel (mask==5).
    .help = bg is any valid pixel used for background fitting or foreground (integration).
    .help = Note, in this context, Foreground is usually the central shoebox pixels marked for integration.
  refldata_to_photons = False
    .type = bool
    .help = If loading data from reflection table, then optionally normalize by the refiner.adu_to_photon factor.
    .help = If the reflection tables were created using dials.integrate or dials.stils_process,
    .help = then you will need to set this flag to True.
  load_data_from_refl = False
    .type = bool
    .help = Rather than load data from the experiment, load data from the reflection table shoeboxes.
    .help = The data in shoeboxes is stored in float32. The shoebox bound boxes will determing the regions of
    .help = pixels used for refinement. It is assumed that shoebox background, data, and the mask are properly set.
    .help = See the method GatherFromReflectionTable in hopper_utils.
  test_gathered_file = False
    .type = bool
  gather_dir = None
    .type = str
    .help = optional dir for stashing loaded input data in refl files (mainly for tests/portability)
  break_signal = None
    .type = int
    .help = intended to be used to break out of a long refinement job prior to a timeout on a super computer
    .help = On summit, set this to 12 (SIGUSR2), at least thats what it was last I checked (July 2021)
  debug_pixel_panelfastslow = None
    .type = ints(size=3)
    .help = 3-tuple of panel ID, fast coord, slow coord. If set, show the state of diffBragg
    .help = for this pixel once refinement has finished
  gain_map_min_max = [.5,2]
    .type = floats(size=2)
    .help = the min, max allowed values for the gain correction terms
    .help = that are applied to each region (defined by region_size)
  refine_gain_map = False
    .type = bool
    .help = flag for refining a detector gain map, defined by the parameter region_size
  save_gain_freq=10
    .type = int
    .help = after how many iterations should we save the optimized gain map
  region_size = [50,50]
    .type = ints(size=2)
    .help = Used for gain correction. size of subregions in each detector module in pixels.
    .help = Each panel region will be divided into blocks of shape region_size
    .help = and a unique gain correction will be applied to each subregion.
    .help = Note, this will usually be square shaped, but its (slowDim,fastDim).
  res_ranges = None
    .type = str
    .help = resolution-defining strings, where each string is
    .help = is comma-separated substrings, formatted according to "%f-%f,%f-%f" where the first float
    .help = in each substr specifies the high-resolution for the refinement trial, and the second float
    .help = specifies the low-resolution for the refinement trial. Should be same length as max_calls
  force_symbol = None
    .type = str
    .help = a space group lookup symbol used to map input miller indices to ASU
  force_unit_cell = None
    .type = ints(size=6)
    .help = a unit cell tuple to use
  num_devices = 1
    .type = int
    .help = number of cuda devices on current node
  refine_Fcell = None
    .type = ints(size_min=1)
    .help = whether to refine the structure factor amplitudes
  refine_spot_scale = None
    .type = ints(size_min=1)
    .help = whether to refine the crystal scale factor
  refine_Nabc = False
    .type = bool
    .help = whether to refine the mosaic domain size tensor
  gain_restraint=None
    .type = floats(size=2)
    .help = if not None, apply a gain restraint to the data
    .help = This is two parameters, a center and a variance
  max_calls = [100]
    .type = ints(size_min=1)
    .help = maximum number of calls for the refinement trial
  panel_group_file = None
    .type = str
    .help = a text file with 2 columns, the first column is the panel_id and the second
    .help = column is the panel_group_id. Panels geometries in the same group are refined together
  update_oversample_during_refinement = False
    .type = bool
    .help = whether to update the oversample parameter as ncells changes
  sigma_r = 3
    .type = float
    .help = standard deviation of the dark signal fluctuation
  adu_per_photon = 1
    .type = float
    .help = how many ADUs (detector units) equal 1 photon
  use_curvatures_threshold = 10
    .type = int
    .help = how many consecutiv positive curvature results before switching to curvature mode
  curvatures = False
    .type = bool
    .help = whether to try using curvatures
  start_with_curvatures = False
    .type = bool
    .help = whether to try using curvatures in the first iteration
  tradeps = 1e-2
    .type = float
    .help = LBFGS termination parameter  (smaller means minimize for longer)
  io {
    restart_file = None
      .type = str
      .help = output file for re-starting a simulation
    output_dir = None
      .type = str
      .help = optional output directory
  }
  quiet = False
    .type = bool
    .help = silence the refiner
  verbose = 0
    .type = int
    .help = verbosity level (0-10) for nanoBragg
  num_macro_cycles = 1
    .type = int
    .help = keep repeating the same refinement scheme over and over, this many times
  ncells_mask = *000 110 101 011 111
    .type = choice
    .help = a mask specifying which ncells parameters should be the same
    .help = e.g. 110 specifies Na and Nb are refined together as one parameter
  reference_geom = None
    .type = str
    .help = path to expt list file containing a detector model
  stage_two {
    use_nominal_hkl = True
      .type = bool
      .help = use the nominal hkl as a filter for Fhkl gradients
    save_model_freq = 50
      .type = int
      .help = save the model  after this many iterations
    save_Z_freq = 25
      .type = int
      .help = save Z-scores for all pixels after this many iterations
    min_multiplicity = 1
      .type = int
      .help = structure factors whose multiplicity falls below this value
      .help = will not be refined
    Fref_mtzname = None
      .type = str
      .help = path to a reference MTZ file. if passed, this is used solely to
      .help = observe the R-factor and CC between it and the Fobs being optimized
    Fref_mtzcol = "Famp(+),Famp(-)"
      .type = str
      .help = column in the mtz file containing the data
    d_min = 2
      .type = float
      .help = high res lim for binner
    d_max = 999
      .type = float
      .help = low res lim for binner
    n_bin = 10
      .type = int
      .help = number of binner bins
  }
}
"""

roi_phil = """
roi {
  centroid = *obs cal
    .type = choice
    .help = Determines which refl table column contains the spot centroids
    .help = Shoeboxes are drawn around the centroids, and refinement uses pixels
    .help = within those shoeboxes.
    .help = obs: xyz.px.value  cal: xyzcal.px
  trusted_range = None
    .type = floats(size=2)
    .help = optional override for detector trusted range, should be (min,max)
  mask_all_if_any_outside_trusted_range = True
    .type = bool
    .help = If a reflection has any pixels which are outside the detectors
    .help = trusted range, then mask the entire reflections and surrounding
    .help = pixels. If False, then only pixels outside the range are masked.
    .help = Note: this only takes effect if mask_outside_trusted_range=True.
  mask_outside_trusted_range = False
    .type = bool
    .help = Check the dxtbx detector's trusted range and use that to mask
    .help = out-of-range pixels on a per-image basis
  only_filter_zingers_above_mean = True
    .type = bool
    .help = if fitting background, theres a zinger filter step (background_threshold)
    .help = and typically it only applies to pixels above the mean
    .help = Set this to False to filter zingers below the mean, which is useful for
    .help = data with low background signal.
  cache_dir_only = False
    .type = bool
    .help = if True, create the cache folder , populate it with the roi data, then exit
  fit_tilt = False
    .type = bool
    .help = fit tilt plane, or else background is simply an offset
  force_negative_background_to_zero = False
    .type = bool
    .help = if True and the background model evaluates to a negative number
    .help = within an ROI, then force the background to be 0 for all pixels in that ROI
  background_threshold = 3.5
    .type = float
    .help = for determining background pixels
  pad_shoebox_for_background_estimation = None
    .type = int
    .help = shoebox_size specifies the dimenstion of the shoebox used during refinement
    .help = and this parameter is used to increase that shoebox_size only during the background
    .help = estimation stage
  shoebox_size = 10
    .type = int
    .help = roi box dimension
  deltaQ = None
    .type = float
    .help = roi dimension in inverse Angstrom, such that shoeboxes at wider angles are larger.
    .help = If this parameter is supplied, shoebox_size will be ignored.
  reject_edge_reflections = True
    .type = bool
    .help = whether to reject ROIs if they occur near the detector panel edge
  reject_roi_with_hotpix = True
    .type = bool
    .help = whether to reject an ROI if it has a bad pixel
  hotpixel_mask = None
    .type = str
    .help = path to a hotpixel mask (hot pixels set to True)
  panels = None
    .type = str
    .help = panel list for refinement as a string, e.g. "0-8,10,32-40" . The ranges are inclusive,
    .help = e.g. 0-8 means panels 0,1,2,3,4,5,6,7,8
  fit_tilt_using_weights = False
    .type = bool
    .help = if not using robust estimation for background, and instead using tilt plane fit,
    .help = then this parameter will toggle the use of weights. Weights are the estimated
    .help = pixel variance, incuding readout and shot noises.
  allow_overlapping_spots = False
    .type = bool
    .help = if True, then model overlapping spots
  skip_roi_with_negative_bg = True
    .type = bool
    .help = If a region of interest contains negative background model, then skip entire region,else
    .help = mask the pixels with negative background model.
}

geometry {
  save_state_freq = 50
    .type = int
    .help = how often to save all model parameters
  save_state_overwrite = True
    .type = bool
    .help = whether to overwrite model parameter files each time they are saved
  pandas_dir = None
    .type = str
    .help = If provided, Pandas dataframes for each shot will be written here
    .help = These are the same format as those saved during stage 1
    .help = Also, data modelers will pickled and written here as well
  optimized_results_tag = None
    .type = str
    .help = optional tagname, if provided,write optimized refls/expts alongside the
    .help = input refls/expts however using this tag suffix
  refls_key = stage1_refls
    .type = str
    .help = column name for the input pickle which contains the reflection tables to be modeled
  optimize_method = *lbfgsb nelder
    .type = choice
    .help = lmfit optimization method (lbfgsb uses gradients, nelder is graientless)
  input_pkl = None
    .type = str
    .help = path to the input pickle (from hopper) containing models and experiment lists
  input_pkl_glob = None
    .type = str
    .help = path to a glob of input pandas pickles output by hopper or geometry_refiner
  optimize = False
    .type = bool
    .help = flag to specify whether to optimize the geometry
  save_optimized_det_freq = 1
    .type = int
    .help = Save the optimzied detector model every X iterations
  optimized_detector_name = "diffBragg_detector.expt"
    .type = str
    .help = basename of the experiment which will be written, and will contain the optimized detector. Note, this should be a basename only (not to be prefixed with a directory path). If a directory path is include, it will be stripped. The file will be stored in the output folder (pandas_dir)
  min {
    panel_rotations = -1,-1,-1
      .type = floats(size=3)
      .help = minimum value in degrees for a detector panel rotation
    panel_translations = -1,-1,-1
      .type = floats(size=3)
      .help = minimum value in mm for detector panel translations in X,Y,Z
  }
  max {
    panel_rotations = 1,1,1
      .type = floats(size=3)
      .help = maximum value in degrees for a detector panel rotation
    panel_translations = 1,1,1
      .type = floats(size=3)
      .help = maximum value in mm for detector panel translations in X,Y,Z
  }
  center {
    panel_rotations = 0,0,0
      .type = floats(size=3)
      .help = restraint target in degrees for panel rotations
    panel_translations = 0,0,0
      .type = floats(size=3)
      .help = restraint target in mm for detector panel translations in X,Y,Z
  }
  betas {
    panel_rot = 1e6,1e6,1e6
      .type = floats(size=3)
      .help = restraint factor for panel rotations (higher values lead to unrestrained parameters)
    panel_xyz = 1e6,1e6,1e6
      .type = floats(size=3)
      .help = restraint factor in mm for detector panel translations in X,Y,Z
    close_distances = None
      .type = float
      .help = restraint factor for the spread of detector panel Z-distances (#TODO think about this in context of tilt)
  }
  fix {
    panel_rotations = 0,0,0
      .type = ints(size=3)
      .help = refinement flags, 1 means to fix the parameter
    panel_translations = 0,0,0
      .type = ints(size=3)
      .help = refinement flags, 1 means to fix the parameter
  }
}
"""

predictions_phil = """
predictions {
  use_peak_detection = False
    .type = bool
    .help = If True, then simulations will be converted to refl tables
    .help = where each reflection is a single pixel corresponding
    .help = to the peak in the simulated spot. This is useful if one
    .help = models spatial overlaps with separate peaks
  verbose = False
    .type = bool
    .help = See more console output from prediction methods
  laue_mode = False
    .type = bool
    .help = if True, predict the per-pixel wavelenth from the model and use that for index assigment
  qcut = 0.1
    .type = float
    .help = Label predicted reflection as a strong reflection if its within this
    .help = many inverse Angstromg (q=2/Lambda sin(theta)) of an observed strong spot
  label_weak_col = "xyzobs.px.value"
    .type = str
  weak_fraction = 0.5
    .type = float
    .help = fraction of weak predictions to integrate
  threshold = 1e-3
    .type = float
    .help = value determining the cutoff for the forward model intensity. Bragg peaks will then be determined
    .help = as regions of connected values greater than the threshold
  thicksteps_override = None
    .type = int
    .help = Use to force the number of detector thickness steps to a specific value
  oversample_override = None
    .type = int
    .help = force the pixel oversample rate to this value during the forward model simulation
    .help = for maximum speed gains, set this to 1, but inspect the output!
    .expert_level=10
  use_diffBragg_mtz = False
    .type = bool
    .help = whether to use the mtz supplied to diffBragg for prediction
  Nabc_override = None
    .type = ints(size=3)
    .help = use this value of mosaic block size for every shot, useful to get more predicted spots
    .expert_level=10
  pink_stride_override = None
    .type = int
    .help = if specified, stride through the spectrum according to this interval
  default_Famplitude = 1e3
    .type = float
    .help = default structure factor amplitude for every miller index
    .help = this creates a flat prediction model, where the magnitude is dependent on the distance to the Ewald sphere
  resolution_range = [1,999]
    .type = floats(size=2)
    .help = high-res to low-res limit for prediction model
  symbol_override = None
    .type = str
    .help = specify the space group symbol to use in diffBragg (e,g, P43212),
    .help = if None, then it will be pulled from the crystal model
  method = *diffbragg exascale
    .type = choice
    .help = engine used for computing the forward model
    .help = diffbragg offers CUDA support via the DIFFBRAGG_USE_CUDA=1 environment variable specification
    .help = or openmp support using the OMP_NUM_THREADS flag
    .help = The exascale only uses CUDA (will raise error if CUDA is not confugured)
}
"""

philz = simulator_phil + refiner_phil + roi_phil + predictions_phil
phil_scope = parse(philz)


 *******************************************************************************


 *******************************************************************************
simtbx/diffBragg/prep_stage2_input.py
from __future__ import division, print_function

import pandas
import numpy as np
from dials.array_family import flex
from libtbx.mpi4py import MPI
from simtbx.diffBragg import utils
COMM = MPI.COMM_WORLD

import logging

LOGGER = logging.getLogger("diffBragg.main")

def get_equal_partition(weights, partitions):
    """
    Use Longest-processing-time-first to schedule the set of samples into partitions.

    :param weights: list of weights
    :param partitions: number of partitions
    :return: list of indices for each partition
    """
    distribution = [[] for _ in range(partitions)]
    load = np.zeros(partitions)
    descending = np.array(weights).argsort()[::-1]
    for idx in descending:
        lightest = load.argmin()
        distribution[lightest].append(idx)
        load[lightest] += weights[idx]
    return distribution

def prep_dataframe(df, refls_key="predictions", res_ranges_string=None):
    """

    :param df: input pandas dataframe for stage2
    :param refls_key: column in df containing the reflection filenames
    :param res_ranges_string: optional res_ranges_string phil param (params.refiner.res_ranges)
    :return:
    """
    # TODO make sure all pred files exist

    res_ranges = None
    if res_ranges_string is not None:
        res_ranges = utils.parse_reso_string(res_ranges_string)

    if refls_key not in list(df):
        raise KeyError("Dataframe has no key %s" % refls_key)
    nshots = len(df)
    df.reset_index(drop=True, inplace=True)
    df['index'] = df.index.values
    refl_info = df[["index", refls_key, "exp_idx"]].values

    # sort and split such that each rank will read many refls from same file
    sorted_names_and_ids = sorted(
        refl_info,
        key=lambda x: x[1])  # sort by name
    df_idx, refl_names, expt_ids = np.array_split(sorted_names_and_ids, COMM.size)[COMM.rank].T

    refls_per_shot = []
    if COMM.rank==0:
        LOGGER.info("Loading nrefls per shot")

    prev_name = ""  # keep track of the most recently read refl table file
    Rall = None
    for (i_shot, name, expt_id) in zip(df_idx, refl_names, expt_ids):
        if Rall is None or name != prev_name:
            Rall = flex.reflection_table.from_file(name)
            prev_name = name

        R = Rall.select(Rall['id'] == int(expt_id))
        if res_ranges is not None:
            num_ref = 0
            if 'rlp' not in set(R.keys()):
                raise KeyError("Cannot filter res ranges if rlp column not in refl tables")
            d = 1. / np.linalg.norm(R["rlp"], axis=1)  # resolution per refl
            for d_fine, d_coarse in res_ranges:
                d_sel = np.logical_and(d >= d_fine, d < d_coarse)
                num_ref += d_sel.sum()
        else:
            num_ref = len(R)

        if num_ref==0:
            LOGGER.critical("Reflection %s id=%d has 0 reflections !" % (name, expt_id, num_ref))
        refls_per_shot.append((i_shot, num_ref))

    refls_per_shot = COMM.reduce(refls_per_shot, root=0)
    work_distribution = None
    if COMM.rank==0:
        print("Found %d shots" % nshots)
        refls_per_shot = sorted(refls_per_shot)
        indices, weights = zip(*refls_per_shot)
        assert list(indices) == list(range(nshots)) # new sanity test

        work_distribution = get_equal_partition(weights, COMM.size)
    work_distribution = COMM.bcast(work_distribution, root=0)
    assert work_distribution is not None, "ERROR! Rank %d has no work_distribution!" % COMM.rank
    return work_distribution


if __name__ == "__main__":
    import sys
    df = pandas.read_pickle(sys.argv[1])
    new_df = prep_dataframe(df)
    new_df.to_pickle(sys.argv[2])


 *******************************************************************************


 *******************************************************************************
simtbx/diffBragg/psf.py
from __future__ import division

import numpy as np
from dials.algorithms.image.filter import convolve
import math
from scipy.signal import convolve2d
from dials.array_family import flex



def fiber2D_integ(x,y,g):
    return math.atan((x*y)/(g*math.sqrt(g*g + x*x + y*y)))/(2.0*math.pi)


def makeMoffat_integPSF(fwhm_pixel, sizeX, sizeY):
    ''' Integral form of contribution of moffat PSF to signal recorded in a square pixel'''
    g = fwhm_pixel*0.65238
    psf = np.zeros((sizeX, sizeY))
    sx = int(sizeX/2)
    sy = int(sizeY/2)
    for y in range(-sy, sy+1):
    #for y in range(sy, -(sy+1), -1):
      for x in range(-sx, sx+1):
        #for x in range(-sx, sx+1):
        # Holton 2012 paper says x,y should be pixel center; this does not seem right ?
        psf[x+sx,y+sy] = fiber2D_integ(x+1./2,y+1./2,g)-fiber2D_integ(x+1./2,y-1./2,g)-fiber2D_integ(x-1./2,y+1./2,g)+fiber2D_integ(x-1./2,y-1./2,g)
        #psf[x+sx, -y+sy] = fiber2D_integ(x+1./2,y+1./2,g)-fiber2D_integ(x+1./2,y-1./2,g)-fiber2D_integ(x-1./2,y+1./2,g)+fiber2D_integ(x-1./2,y-1./2,g)
        # Trying to get pixel center instead
        #psf[x+sx, -y+sy] = fiber2D_integ(x+1,y+1,g)-fiber2D_integ(x+1,y,g)-fiber2D_integ(x,y+1,g)+fiber2D_integ(x,y,g)
    psf = psf/psf.sum()
    psf = psf.tolist()
    psf = flex.double(psf)
    return psf


def convolve_padded_img(img, psf, sz=5):
    img = np.array(img)
    iY, iX = img.shape
    pY, pX = psf.focus()

    new_iY = iY
    if pY >= iY - sz:
        new_iY = pY + sz
    new_iX = iX
    if pX >= iX - sz:
        new_iX = pX + sz

    assert new_iX >= iX
    assert new_iY >= iY
    padX = new_iX - iX
    padY = new_iY - iY

    x = int(padX/2)
    y = int(padY/2)
    img = np.pad(img, ((y, y+1), (x, x+1)), mode='median')
    assert img.shape[0] >= pY + sz
    assert img.shape[1] >= pX + sz

    conv_img = convolve(flex.double(img), psf)
    conv_img = conv_img.as_numpy_array()[y:y+iY, x:x+iX]
    return conv_img


def convolve_with_psf(image_data, fwhm=27.0, pixel_size=177.8, psf_radius=7, sz=5, psf=None, use_scipy=True):
    ''' Given a 2D numpy array of image data, convolve with a PSF. '''
    # Currently only supporting fiber PSF i.e power law form as proposed in Holton et. al 2012, Journal of Synchotron Radiation
    if psf is None:
        xpsf=2*psf_radius+1
        ypsf=2*psf_radius+1
        fwhm_pixel=fwhm/pixel_size
        psf = makeMoffat_integPSF(fwhm_pixel, xpsf, ypsf)
    if use_scipy:
        psf_img = psf.as_numpy_array()
        med_img = (image_data[0,0] + image_data[0,-1] + image_data[-1,0] + image_data[-1,-1])*0.25 #np.median(image_data)
        convolved_image = convolve2d(image_data, psf_img, mode='same', fillvalue=med_img)

    else:
        img_shape = image_data.shape
        psf_shape = psf.focus()
        if psf_shape[0] > img_shape[0] - sz or psf_shape[1] > img_shape[1] - sz:
            convolved_image = convolve_padded_img(image_data, psf, sz)
        else:
            convolved_image = convolve(flex.double(image_data), psf)
            convolved_image = convolved_image.as_numpy_array()
    return convolved_image


if __name__=="__main__":
    psf_args = {'fwhm': 100, 'pixel_size': 80., 'psf_radius': 7}
    fwhm_pix = psf_args["fwhm"] / psf_args["pixel_size"]
    kern_size = psf_args["psf_radius"]*2 + 1
    PSF = makeMoffat_integPSF(fwhm_pix, kern_size, kern_size)

    a = np.random.random((100,100))
    a2 = convolve_with_psf(a, psf=PSF, **psf_args)
    from pylab import plt
    plt.subplot(121)
    plt.gca().set_title("without PSF")
    plt.imshow(a)
    plt.subplot(122)
    plt.gca().set_title("with PSF")
    plt.imshow(a2)
    plt.show()



 *******************************************************************************


 *******************************************************************************
simtbx/diffBragg/refiners/__init__.py
from __future__ import absolute_import, division, print_function
from .base_refiner import BaseRefiner, BreakToUseCurvatures, BreakBecauseSignal  # special import


 *******************************************************************************


 *******************************************************************************
simtbx/diffBragg/refiners/base_refiner.py

from __future__ import division
import scitbx
from abc import ABCMeta, abstractmethod
from scitbx.array_family import flex
from scitbx.lbfgs import core_parameters


# used in pixel refinement
class BreakToUseCurvatures(Exception):
    pass

class BreakBecauseSignal(Exception):
    pass

class ReachedMaxIterations(Exception):
    pass


class BaseRefiner:
    """
    This is the base class for pixel refinement
    It is a CCTBX L-BFGS refiner object, with abstract methods that must be defined
    """

    __metaclass__ = ABCMeta

    run_on_init = False

    def __init__(self):
        self.hit_break_signal = False  # internal flag in case of hitting the beak signal
        self.S = None   # instance of simtbx.nanoBragg.sim_data.SimData
        self.ignore_line_search_failed_step_at_lower_bound = False  # TODO: why is this sometimes necessary ?
        self.refine_lambda0 = False  # spectrea offset
        self.refine_lambda1 = False  # spectra scale factor
        self.m = 5  # LBFGS default core parameters
        self.maxfev = 20  # LBFGS default core parameters
        self.gtol = 0.9  # LBFGS default core parameters
        self.xtol = 1.e-16  # LBFGS default core parameters
        self.stpmin = 1.e-20  # LBFGS default core parameters
        self.stpmax = 1.e20  # LBFGS default core parameters
        self.trad_conv_eps = 0.05  # LBFGS terminator param converges whern |g| <= max(|x|,1) * trad_conv_eps
        self.drop_conv_max_eps = 1e-5  # LBFGS terminator param not sure, used in the other scitbx lbfgs convergence test
        self.mn_iter = 0  # LBFGS terminator param not sure used in lbfgs
        self.mx_iter = None  # LBFGS terminator param not sure used in lbfgs
        self.max_calls = 100000  # LBFGS terminator param how many overall iterations
        self.diag_mode = "always"  # LBFGS refiner property, whether to update curvatures at each iteration
        self.d = None   # place holder for a second derivative diagonal
        self.binner_dmin = 2  # if Fref is not None, then this defines R-factor and CC resolution binner
        self.binner_dmax = 999  # if Fref is not None, then this defines R-factor and CC resolution binner
        self.binner_nbin = 10  # if Fref is not None, then this defines R-factor and CC resolution binner
        self.Fref = None  # place holder for Fhkl reference (for computing R factors during refinement)
        self.use_curvatures = False  # whether to use the curvatures
        self.multi_panel = False  # whether the camera is multi panel or single panel
        self.hit_break_to_use_curvatures = False  # internal flag if calculating curvatures
        self.has_pre_cached_roi_data = False  # only for use in global refinement mode
        self.curv = None  # curvatures array used internally
        self.gradient_only = False  # parameter for LBFGS run method (internal to the Fortran code, see scitbx.lbfgs.__init__.py method run_c_plus_plus
        self.trad_conv = False  # traditional convergenve
        self.calc_curvatures = False  # whether to calc curvatures until a region of positive curvature is reached
        self.panel_ids = None  # list of panel_ids (same length as roi images, spot_rois, tilt_abc etc)
        self._refinement_millers = None  # flex array of refinement miller indices (computed by GlobalRefiner _setup method)

    @abstractmethod
    def _grad_accumulate(self, d):
        """d : first derivative of target for arbitrary parameter"""
        pass

    @abstractmethod
    def _curv_accumulate(self, d, d2):
        """d, d2 : first and second derivatives of target for arbitrary parameter"""
        pass

    @abstractmethod
    def _target_accumulate(self):
        pass

    @abstractmethod
    def compute_functional_and_gradients(self):
        pass

    @property
    @abstractmethod
    def x(self):
        pass

    @property
    @abstractmethod
    def n(self):
        pass

    @property
    def S(self):
        """An instance of simtbx.nanoBragg.sim_data.SimData, the simulation workhorse"""
        return self._S

    @S.setter
    def S(self, val):
        if not hasattr(val, 'D'):
            print("S should be an instance of SimData after running SimData.instantiate_diffBragg()")
        self._S = val

    @property
    def trad_conv(self):
        return self._trad_conv_test

    @trad_conv.setter
    def trad_conv(self, val):
        self._trad_conv_test = val

    @property
    def trad_conv_eps(self):
        return self._trad_conv_eps

    @trad_conv_eps.setter
    def trad_conv_eps(self, val):
        self._trad_conv_eps = val

    @property
    def drop_conv_max_eps(self):
        return self._drop_conv_max_eps

    @drop_conv_max_eps.setter
    def drop_conv_max_eps(self, val):
        self._drop_conv_max_eps = val

    @property
    def mn_iter(self):
        return self._mn_iter

    @mn_iter.setter
    def mn_iter(self, val):
        self._mn_iter = val

    @property
    def mx_iter(self):
        return self._mx_iter

    @mx_iter.setter
    def mx_iter(self, val):
        self._mx_iter = val

    @property
    def max_calls(self):
        return self._max_calls

    @max_calls.setter
    def max_calls(self, val):
        self._max_calls = val

    @property
    def _terminator(self):
        return scitbx.lbfgs.termination_parameters(
                    traditional_convergence_test=self.trad_conv,
                    traditional_convergence_test_eps=self.trad_conv_eps,
                    drop_convergence_test_max_drop_eps=self.drop_conv_max_eps,
                    min_iterations=self.mn_iter,
                    max_iterations=self.mx_iter,
                    max_calls=self.max_calls)

    @property
    def _core_param(self):
        core_param = core_parameters()
        core_param.gtol = self.gtol
        core_param.xtol = self.xtol
        core_param.stpmin = self.stpmin
        core_param.stpmax = self.stpmax
        core_param.maxfev = self.maxfev
        core_param.m = self.m
        return core_param

    @property
    def _handler(self):
        return scitbx.lbfgs.exception_handling_parameters(
            ignore_line_search_failed_step_at_lower_bound=\
                self.ignore_line_search_failed_step_at_lower_bound)

    def _setup(self):
        """
        Optional place holder for class organization
        This is called just before running the minimizer
        Typically this involves populating the x array
        with initial values and configuring the diffBragg
        instance
        """
        pass

    def run(self, setup=True, setup_only=False):
        """runs the LBFGS minimizer"""

        if setup:
            self._setup()
            if setup_only:
                return

        if self.use_curvatures:
            try:
                self.minimizer = scitbx.lbfgs.run(
                    target_evaluator=self,
                    core_params=self._core_param,
                    exception_handling_params=self._handler,
                    termination_params=self._terminator,
                    gradient_only=self.gradient_only)
            except BreakToUseCurvatures:
                self.hit_break_to_use_curvatures = True
            except BreakBecauseSignal:
                self.hit_break_signal = True
                pass

        else:
            try:
                self.diag_mode = None

                self.minimizer = scitbx.lbfgs.run(
                    target_evaluator=self,
                    core_params=self._core_param,
                    exception_handling_params=self._handler,
                    termination_params=self._terminator,
                    gradient_only=self.gradient_only)

            except BreakToUseCurvatures:
                self.hit_break_to_use_curvatures = True
                pass
            except BreakBecauseSignal:
                self.hit_break_signal = True
                pass

    @property
    def use_curvatures(self):
        return self._use_curvatures

    @use_curvatures.setter
    def use_curvatures(self, val):
        if val:
            self.calc_curvatures = True
        self._use_curvatures = val

    def compute_functional_gradients_diag(self):
        self.f, self.g = self.compute_functional_and_gradients()
        self.d = flex.double(self.curv.as_numpy_array())
        self._verify_diag()
        return self.f, self.g, self.d

    def _verify_diag(self):
        sel = (self.g != 0)
        from IPython import embed
        embed()
        self.d.set_selected(~sel, 1000)
        assert self.d.select(sel).all_gt(0)
        self.d = 1 / self.d


 *******************************************************************************


 *******************************************************************************
simtbx/diffBragg/refiners/crystal_systems/__init__.py
from __future__ import division

from .manager import CrystalSystemManager  # special import
from .tetragonal import TetragonalManager  # special import
from .monoclinic import MonoclinicManager  # special import
from .hexagonal import HexagonalManager  # special import
from .orthorhombic import OrthorhombicManager  # special import


 *******************************************************************************


 *******************************************************************************
simtbx/diffBragg/refiners/crystal_systems/hexagonal.py
from __future__ import division
from simtbx.diffBragg.refiners.crystal_systems import CrystalSystemManager
import numpy as np
from scitbx.matrix import sqr


class HexagonalManager(CrystalSystemManager):

    def __init__(self, a=77, c=264):
        self.variables = [a, c]

    @property
    def variables(self):
        return self._variables

    @variables.setter
    def variables(self, val):
        if len(val) != 2:
            raise ValueError("Hexagonal crystal system has two variables: %s" % ", ".join(self.variable_names))
        self._variables = val

    @property
    def derivative_matrices(self):
        return [self._dB_da_real,
                self._dB_dc_real]

    @property
    def second_derivative_matrices(self):
        return [self._d2B_da2_real,
                self._d2B_dc2_real]

    @property
    def a(self):
        return self.variables[0]

    @property
    def b(self):
        return self.variables[0]

    @property
    def c(self):
        return self.variables[1]

    @property
    def al(self):
        return np.pi/2

    @property
    def be(self):
        return np.pi/2

    @property
    def ga(self):
        return 2*np.pi/3

    @property
    def variable_names(self):
        return [self._names[0],
                self._names[2]]

    @property
    def _dB_da_real(self):
        return sqr((1, -.5, 0,
                    0, np.sqrt(3)/2., 0,
                    0, 0, 0))

    @property
    def _d2B_da2_real(self):
        return sqr((0, 0, 0,
                    0, 0, 0,
                    0, 0, 0))

    @property
    def _dB_dc_real(self):
        return sqr((0, 0, 0,
                    0, 0, 0,
                    0, 0, 1))

    @property
    def _d2B_dc2_real(self):
        return sqr((0, 0, 0,
                    0, 0, 0,
                    0, 0, 0))


 *******************************************************************************


 *******************************************************************************
simtbx/diffBragg/refiners/crystal_systems/manager.py
from __future__ import division

from abc import ABCMeta #, abstractproperty
import numpy as np
from scitbx.matrix import sqr

import abc
try:
    ABC = abc.ABC
    abstractproperty = lambda f: property(abc.abstractmethod(f))
except AttributeError:  # Python 2.7, abc exists, but not ABC
    ABC = abc.ABCMeta("ABC", (object,), {"__slots__": ()})
    from abc import abstractproperty

class CrystalSystemManager(object):

    __metaclass__ = ABCMeta

    @abstractproperty
    def variables(self):
        pass

    @abstractproperty
    def derivative_matrices(self):
        pass

    #@abstractproperty
    #def second_derivative_matrices(self):
    #    pass

    @abstractproperty
    def a(self):
        """unit cell a parameter"""
        pass

    @abstractproperty
    def b(self):
        """unit cell b parameter"""
        pass

    @abstractproperty
    def c(self):
        """unit cell c parameter"""
        pass

    @abstractproperty
    def al(self):
        """unit cell alpha angle"""
        pass

    @abstractproperty
    def be(self):
        """unit cell beta angle"""
        pass

    @abstractproperty
    def ga(self):
        """unit cell gamma angle"""
        pass

    @abstractproperty
    def variables(self):
        """the unit cell variables"""
        return []

    @property
    def cal(self):
        """cosine of alpha"""
        return np.cos(self.al)

    @property
    def cbe(self):
        """cosine of beta"""
        return np.cos(self.be)

    @property
    def cga(self):
        """cosine of gamma"""
        return np.cos(self.ga)

    @property
    def sal(self):
        """sine of alpha"""
        return np.sin(self.al)

    @property
    def sbe(self):
        """sine of beta"""
        return np.sin(self.be)

    @property
    def sga(self):
        """sine of gamma"""
        return np.sin(self.ga)

    @property
    def V(self):
        """unit cell volume in cubic Angstrom"""
        return self.a*self.b*self.c*np.sqrt(1-self.cal**2 - self.cbe**2-self.cga**2+2*self.cal*self.cbe*self.cga)

    @property
    def B_realspace(self):
        """
        real space B-matrix in upper triangular form
        such that the columns are a_real, b_real, c_real
        aligned according to the PDB convention
        """
        return sqr(
            (self.a, self.b*self.cga, self.c*self.cbe,
             0,      self.b*self.sga, self.c*(self.cal-self.cbe*self.cga)/self.sga,
             0,      0,               self.V/(self.a*self.b*self.sga)))

    @property
    def B_recipspace(self):
        """
        reciprocal space B-matrix in lower-triangular form
        such that it corresponds to the dxtbx Crystal get_B() method
        """
        return self.B_realspace.inverse().transpose()

    @property
    def _names(self):
        return ["a_Ang", "b_Ang", "c_Ang", "alpha_rad", "beta_rad", "gamma_rad"]

    @abstractproperty
    def variable_names(self):
        return []

    @property
    def named_variables(self):
        named_vars = {}
        for name, val in zip(self.variable_names, self.variables):
            named_vars[name] = val
        return named_vars

    @property
    def unit_cell_parameters(self):
        """
        unit cell parameter 6-tuple in Angstrom/degrees format
        returns: a,b,c, alpha, beta, gamma
        """
        return self.a, self.b, self.c, self.al*180./np.pi, self.be*180./np.pi, self.ga*180./np.pi


 *******************************************************************************


 *******************************************************************************
simtbx/diffBragg/refiners/crystal_systems/monoclinic.py
from __future__ import division
from simtbx.diffBragg.refiners.crystal_systems import CrystalSystemManager
import numpy as np
from scitbx.matrix import sqr


class MonoclinicManager(CrystalSystemManager):

    def __init__(self, a=55, b=65, c=77, beta=100*np.pi/180.):
        self.variables = [a, b, c, beta]

    @property
    def variables(self):
        return self._variables

    @variables.setter
    def variables(self, val):
        self._variables = val

    @property
    def derivative_matrices(self):
        return [self._dB_da_real, self._dB_db_real,
                self._dB_dc_real, self._dB_dbeta_real]

    @property
    def second_derivative_matrices(self):
        return [self._d2B_da2_real, self._d2B_db2_real,
                self._d2B_dc2_real, self._d2B_dbeta2_real]

    @property
    def a(self):
        return self.variables[0]

    @property
    def b(self):
        return self.variables[1]

    @property
    def c(self):
        return self.variables[2]

    @property
    def al(self):
        return np.pi/2

    @property
    def be(self):
        return self.variables[3]

    @property
    def ga(self):
        return np.pi/2

    @property
    def variable_names(self):
        return [self._names[0], self._names[1],
                self._names[2], self._names[4]]

    @property
    def _dB_da_real(self):
        return sqr((1, 0, 0,
                    0, 0, 0,
                    0, 0, 0))

    @property
    def _d2B_da2_real(self):
        return sqr((0, 0, 0,
                    0, 0, 0,
                    0, 0, 0))

    @property
    def _dB_db_real(self):
        return sqr((0, 0, 0,
                    0, 1, 0,
                    0, 0, 0))

    @property
    def _d2B_db2_real(self):
        return sqr((0, 0, 0,
                    0, 0, 0,
                    0, 0, 0))

    @property
    def _dB_dc_real(self):
        return sqr((0, 0, self.cbe,
                    0, 0, 0,
                    0, 0, np.sqrt(1-self.cbe**2)))

    @property
    def _d2B_dc2_real(self):
        return sqr((0, 0, 0,
                    0, 0, 0,
                    0, 0, 0))

    @property
    def _dB_dbeta_real(self):
        return sqr((0, 0, -self.c*self.sbe,
                    0, 0, 0,
                    0, 0, self.c*self.cbe*self.sbe/np.sqrt(1-self.cbe**2)))

    @property
    def _d2B_dbeta2_real(self):
        return sqr((0, 0, -self.c*self.cbe,
                    0, 0, 0,
                    0, 0, -self.c*np.sqrt(1-self.cbe**2)))


 *******************************************************************************


 *******************************************************************************
simtbx/diffBragg/refiners/crystal_systems/orthorhombic.py
from __future__ import division
from simtbx.diffBragg.refiners.crystal_systems import CrystalSystemManager
import numpy as np
from scitbx.matrix import sqr


class OrthorhombicManager(CrystalSystemManager):

    def __init__(self, a=55, b=65, c=77):
        self.variables = [a, b, c]

    @property
    def variables(self):
        return self._variables

    @variables.setter
    def variables(self, val):
        self._variables = val

    @property
    def derivative_matrices(self):
        return [self._dB_da_real, self._dB_db_real,
                self._dB_dc_real]

    @property
    def second_derivative_matrices(self):
        return [self._d2B_da2_real, self._d2B_db2_real,
                self._d2B_dc2_real]

    @property
    def a(self):
        return self.variables[0]

    @property
    def b(self):
        return self.variables[1]

    @property
    def c(self):
        return self.variables[2]

    @property
    def al(self):
        return np.pi/2

    @property
    def be(self):
        return np.pi/2

    @property
    def ga(self):
        return np.pi/2

    @property
    def variable_names(self):
        return [self._names[0], self._names[1],
                self._names[2]]

    @property
    def _dB_da_real(self):
        return sqr((1, 0, 0,
                    0, 0, 0,
                    0, 0, 0))

    @property
    def _d2B_da2_real(self):
        return sqr((0, 0, 0,
                    0, 0, 0,
                    0, 0, 0))

    @property
    def _dB_db_real(self):
        return sqr((0, 0, 0,
                    0, 1, 0,
                    0, 0, 0))

    @property
    def _d2B_db2_real(self):
        return sqr((0, 0, 0,
                    0, 0, 0,
                    0, 0, 0))

    @property
    def _dB_dc_real(self):
        return sqr((0, 0, 0,
                    0, 0, 0,
                    0, 0, 1))

    @property
    def _d2B_dc2_real(self):
        return sqr((0, 0, 0,
                    0, 0, 0,
                    0, 0, 0))


 *******************************************************************************


 *******************************************************************************
simtbx/diffBragg/refiners/crystal_systems/tetragonal.py
from __future__ import division

from simtbx.diffBragg.refiners.crystal_systems import CrystalSystemManager
from scitbx.matrix import sqr
import numpy as np

class TetragonalManager(CrystalSystemManager):

    def __init__(self, a=55, c=77):
        self.variables = [a, c]

    @property
    def variables(self):
        return self._variables

    @variables.setter
    def variables(self, val):
        self._variables = val

    @property
    def derivative_matrices(self):
        return [self._dB_da_real, self._dB_dc_real]

    @property
    def second_derivative_matrices(self):
        return [self._d2B_da2_real, self._d2B_dc2_real]

    @property
    def a(self):
        return self.variables[0]

    @property
    def b(self):
        return self.variables[0]

    @property
    def c(self):
        return self.variables[1]

    @property
    def al(self):
        return np.pi/2.

    @property
    def be(self):
        return np.pi/2

    @property
    def ga(self):
        return np.pi/2

    @property
    def variable_names(self):
        return [self._names[0], self._names[2]]

    @property
    def _dB_da_real(self):
        return sqr((1, 0, 0, 0, 1, 0, 0, 0, 0))

    @property
    def _dB_dc_real(self):
        return sqr((0, 0, 0, 0, 0, 0, 0, 0, 1))

    @property
    def _d2B_da2_real(self):
        return sqr((0, 0, 0, 0, 0, 0, 0, 0, 0))

    @property
    def _d2B_dc2_real(self):
        return sqr((0, 0, 0, 0, 0, 0, 0, 0, 0))


 *******************************************************************************


 *******************************************************************************
simtbx/diffBragg/refiners/geometry.py
from __future__ import division, print_function
import time
from copy import deepcopy
import os
import numpy as np
import pandas
import glob
from pylab import plt
from scipy.optimize import basinhopping
import logging
MAIN_LOGGER = logging.getLogger("diffBragg.main")

from libtbx.mpi4py import MPI
COMM = MPI.COMM_WORLD
from dials.array_family import flex
from dxtbx.model import Experiment, ExperimentList
from dxtbx.model import Detector, Panel
from simtbx.diffBragg.hopper_io import single_expt_pandas
from simtbx.diffBragg import hopper_utils, ensemble_refine_launcher
from simtbx.diffBragg.refiners.parameters import RangedParameter, Parameters
from simtbx.diffBragg import psf

# diffBragg internal indices for derivative manager
ROTXYZ_ID = 0, 1, 2
PAN_O_ID = 14
PAN_F_ID = 17
PAN_S_ID = 18
PAN_X_ID = 15
PAN_Y_ID = 16
PAN_Z_ID = 10
PAN_OFS_IDS = PAN_O_ID, PAN_F_ID, PAN_S_ID
PAN_XYZ_IDS = PAN_X_ID, PAN_Y_ID, PAN_Z_ID
DEG_TO_PI = np.pi / 180.

def convolve_model_with_psf(model_pix, SIM, pan_fast_slow, roi_id_slices, roi_id_unique):

    if not SIM.use_psf:
        return model_pix
    PSF = SIM.PSF
    psf_args = SIM.psf_args

    coords = pan_fast_slow.as_numpy_array()
    fid = coords[1::3]
    sid = coords[2::3]

    for i in roi_id_unique:
        for slc in roi_id_slices[i]:
            fvals = fid[slc]
            svals = sid[slc]
            f0 = fvals.min()
            s0 = svals.min()
            f1 = fvals.max()
            s1 = svals.max()
            fdim = int(f1-f0+1)
            sdim = int(s1-s0+1)
            img = model_pix[slc].reshape((sdim, fdim))
            img = psf.convolve_with_psf(img, psf=PSF, **psf_args)
            model_pix[slc] = img.ravel()

    return model_pix


def get_dist_from_R(R):
    """ returns prediction offset, R is reflection table"""
    x, y, _ = R['xyzobs.px.value'].parts()
    x2, y2, _ = R['xyzcal.px'].parts()
    dist = np.sqrt((x - x2) ** 2 + (y - y2) ** 2)
    return dist


class BeamParameters:
    def __init__(self, phil_params, data_modelers):
        self.parameters = []
        # initialize as the median of all lam0, lam1 values
        all_lam0 = []
        all_lam1 = []
        for i_m in data_modelers:
            m = data_modelers[i_m]
            spec0, spec1 = m.PAR.spec_coef
            lam0, lam1 = spec0.init, spec1.init
            all_lam0.append(lam0)
            all_lam1.append(lam1)
        all_lam0 = COMM.reduce(all_lam0)
        all_lam1 = COMM.reduce(all_lam1)
        global_lam0 = global_lam1 = None
        if COMM.rank==0:
            global_lam0 = np.median(all_lam0)
            global_lam1 = np.median(all_lam1)
        global_lam0 = COMM.bcast(global_lam0)
        global_lam1 = COMM.bcast(global_lam1)

        for i_p, init_val in enumerate((global_lam0, global_lam1)):
            cent = phil_params.centers.spec
            if cent is not None:
                cent = cent[i_p]
            beta = phil_params.betas.spec
            if beta is not None:
                beta = cent[i_p]
            p = RangedParameter(name="lambda%d" % i_p,
                                init=init_val,
                                sigma=phil_params.sigmas.spec[i_p],
                                minval=phil_params.mins.spec[i_p],
                                maxval=phil_params.maxs.spec[i_p],
                                fix=phil_params.fix.spec,
                                center=cent,
                                beta=beta,
                                is_global=True)
            self.parameters.append(p)


class DetectorParameters:

    def __init__(self, phil_params, panel_groups_refined, num_panel_groups):

        self.parameters = []
        GEO = phil_params.geometry
        for i_group in range(num_panel_groups):
            group_has_data = i_group in panel_groups_refined
            if not group_has_data:
                continue
            vary_rots = [not fixed_flag and group_has_data for fixed_flag in GEO.fix.panel_rotations]
            #vary_rots = [True]*3

            o = RangedParameter(name="group%d_RotOrth" % i_group,
                                init=0,
                                sigma=100,  # TODO
                                minval=GEO.min.panel_rotations[0]*DEG_TO_PI,
                                maxval=GEO.max.panel_rotations[0]*DEG_TO_PI,
                                fix=not vary_rots[0], center=0, beta=GEO.betas.panel_rot[0], is_global=True)

            f = RangedParameter(name="group%d_RotFast" % i_group,
                                init=0,
                                sigma=100,  # TODO
                                minval=GEO.min.panel_rotations[1]*DEG_TO_PI,
                                maxval=GEO.max.panel_rotations[1]*DEG_TO_PI,
                                fix=not vary_rots[1], center=0, beta=GEO.betas.panel_rot[1],
                                is_global=True)

            s = RangedParameter(name="group%d_RotSlow" % i_group,
                                init=0,
                                sigma=100,  # TODO
                                minval=GEO.min.panel_rotations[2]*DEG_TO_PI,
                                maxval=GEO.max.panel_rotations[2]*DEG_TO_PI,
                                fix=not vary_rots[2], center=0, beta=GEO.betas.panel_rot[2],
                                is_global=True)

            vary_shifts = [not fixed_flag and group_has_data for fixed_flag in GEO.fix.panel_translations]
            #vary_shifts = [True]*3
            x = RangedParameter(name="group%d_ShiftX" % i_group, init=0,
                                sigma=100,
                                minval=GEO.min.panel_translations[0]*1e-3, maxval=GEO.max.panel_translations[0]*1e-3,
                                fix=not vary_shifts[0], center=0, beta=GEO.betas.panel_xyz[0],
                                is_global=True)
            y = RangedParameter(name="group%d_ShiftY" % i_group, init=0,
                                sigma=100,
                                minval=GEO.min.panel_translations[1]*1e-3, maxval=GEO.max.panel_translations[1]*1e-3,
                                fix=not vary_shifts[1], center=0, beta=GEO.betas.panel_xyz[1],
                                is_global=True)
            z = RangedParameter(name="group%d_ShiftZ" % i_group, init=0,
                                sigma=100,
                                minval=GEO.min.panel_translations[2]*1e-3, maxval=GEO.max.panel_translations[2]*1e-3,
                                fix=not vary_shifts[2], center=0, beta=GEO.betas.panel_xyz[2],
                                is_global=True)

            self.parameters += [o, f, s, x, y, z]



class CrystalParameters:

    def __init__(self, phil_params, data_modelers):
        self.phil = phil_params
        self.parameters = []
        for i_shot in data_modelers:
            Mod = data_modelers[i_shot]

            # set the per-spot scale factors, per pixel...
            Mod.set_slices("roi_id")
            Mod.per_roi_scales_per_pix = np.ones_like(Mod.all_data)
            for roi_id, ref_idx in enumerate(Mod.refls_idx):
                if "scale_factor" in list(Mod.refls[0].keys()):
                    slcs = Mod.roi_id_slices[roi_id]
                    assert len(slcs)==1
                    slc = slcs[0]
                    init_scale = Mod.refls[ref_idx]["scale_factor"]
                    Mod.per_roi_scales_per_pix[slc] =init_scale
                else:
                    init_scale = 1

                p = RangedParameter(name="rank%d_shot%d_scale_roi%d" % (COMM.rank, i_shot, roi_id),
                                    minval=0, maxval=1e12, fix=self.phil.fix.perRoiScale,
                                    center=1, beta=1e12, init=init_scale)
                self.parameters.append(p)

            for i_N in range(3):
                p = Mod.PAR.Nabc[i_N]
                ref_p = RangedParameter(name="rank%d_shot%d_Nabc%d" % (COMM.rank, i_shot, i_N),
                                        minval=p.minval, maxval=p.maxval, fix=self.phil.fix.Nabc, init=p.init,
                                        center=p.center, beta=p.beta)
                self.parameters.append(ref_p)

            for i_N in range(3):
                p = Mod.PAR.Ndef[i_N]
                ref_p = RangedParameter(name="rank%d_shot%d_Ndef%d" % (COMM.rank, i_shot, i_N),
                                        minval=p.minval, maxval=p.maxval, fix=self.phil.fix.Ndef, init=p.init,
                                        center=p.center, beta=p.beta)
                self.parameters.append(ref_p)

            for i_eta in range(3):
                p = Mod.PAR.eta[i_eta]
                ref_p = RangedParameter(name="rank%d_shot%d_eta%d" % (COMM.rank, i_shot, i_eta),
                                        minval=p.minval, maxval=p.maxval, fix=self.phil.fix.eta_abc, init=p.init,
                                        center=p.center, beta=p.beta)
                self.parameters.append(ref_p)

            for i_rot in range(3):
                p = Mod.PAR.RotXYZ_params[i_rot]
                ref_p = RangedParameter(name="rank%d_shot%d_RotXYZ%d" % (COMM.rank, i_shot, i_rot),
                                        minval=p.minval, maxval=p.maxval, fix=self.phil.fix.RotXYZ, init=p.init,
                                        center=p.center, beta=p.beta)
                self.parameters.append(ref_p)

            p = Mod.PAR.Scale
            ref_p = RangedParameter(name="rank%d_shot%d_Scale" % (COMM.rank, i_shot),
                                    minval=p.minval, maxval=p.maxval, fix=self.phil.fix.G, init=p.init,
                                    center=p.center, beta=p.beta)
            self.parameters.append(ref_p)

            for i_uc in range(len(Mod.PAR.ucell)):
                p = Mod.PAR.ucell[i_uc]
                ref_p = RangedParameter(name="rank%d_shot%d_Ucell%d" % (COMM.rank, i_shot, i_uc),
                                        minval=p.minval, maxval=p.maxval, fix=self.phil.fix.ucell, init=p.init,
                                        center=p.center, beta=p.beta)
                self.parameters.append(ref_p)


class Target:
    def __init__(self, ref_params, save_state_freq=500, overwrite_state=True, plot=False):
        """

        :param ref_params: instance of refinement Parameters (LMP in code below)
        :param save_state_freq: how often to save all models (will be overwritten each time)
        """
        num_params = len(ref_params)
        self.vary = np.zeros(num_params).astype(bool)
        for p in ref_params.values():
            self.vary[p.xpos] = not p.fix
        self.x0 = np.ones(num_params)
        self.g = None
        self.ref_params = ref_params
        self.iternum = 0
        self.all_times = []
        self.save_state_freq = save_state_freq
        self.overwrite_state = overwrite_state
        self.med_offsets = [] # median prediction offsets(new number gets added everytime write_output_files is called)
        self.med_iternums = []
        self.plot = plot and COMM.rank==0
        if self.plot:
            self.fig = plt.figure()
            self.ax = plt.gca()
            plt.draw()
            plt.pause(0.1)

    def __call__(self, x, *args, **kwargs):
        self.iternum += 1
        t = time.time()
        self.x0[self.vary] = x
        #time_per_iter = (time.time()-self.tstart) / self.iternum

        f, self.g, self.sigmaZ = target_and_grad(self.x0, self.ref_params, *args, **kwargs)
        t = time.time()-t
        if COMM.rank==0:
            self.all_times.append(t)
            time_per_iter = np.mean(self.all_times)
            pred_offset_str = ", ".join(map(lambda x: "%.4f" %x, self.med_offsets))
            print("Iteration %d:\n\tResid=%f, sigmaZ %f, t-per-iter=%.4f sec, pred_offsets=%s"
                  % (self.iternum, f, self.sigmaZ, time_per_iter, pred_offset_str), flush=True)
        if self.iternum % self.save_state_freq==0 and self.iternum >0:
            if not self.overwrite_state:
                params = args[-1]  # phil params
                temp_pandas_dir = params.outdir
                params.outdir=params.outdir + "-iter%d" % self.iternum
            med_offset = write_output_files(self.x0, self.ref_params, *args, **kwargs)
            self.med_offsets.append(med_offset)
            self.med_iternums.append(self.iternum)
            if self.plot:
                self.ax.clear()
                self.ax.plot(self.med_iternums, self.med_offsets)
                self.ax.set_ylabel("median |xobs-xcal| (pixels)")
                self.ax.set_xlabel("iteration #")
                plt.draw()
                plt.pause(0.01)
            if not self.overwrite_state:
                params.outdir=temp_pandas_dir
        return f

    def jac(self, x, *args):
        if self.g is not None:
            return self.g[self.vary]

    def at_min_callback(self, x, f, accept):
        if COMM.rank==0:
            print("Final Iteration %d:\n\tResid=%f, sigmaZ %f" % (self.iternum, f, self.sigmaZ))


def model(x, ref_params, i_shot, Modeler, SIM, return_bragg_model=False):
    """

    :param x: rescaled parameter array (global)
    :param ref_params: simtbx.diffBragg.refiners.parameters.Parameters() instance
    :param i_shot: shot index for this data model,
        the simtbx.diffBragg.refiners.parameters.RangerParameter objs stored in ref_params
        have names which include i_shot
    :param Modeler: DataModeler for i_shot
    :param SIM: instance of sim_data.SimData
    :param return_bragg_model: if true, bypass the latter half of the method and return the Bragg scattering model
    :return: either the Bragg scattering model (if return_model), or else a 3-tuple of
        (float, dict of float, float)
        (negative log likelihood, gradient of negative log likelihood, average sigmaZ for the shot)
    """

    rotX = ref_params["rank%d_shot%d_RotXYZ%d" % (COMM.rank, i_shot, 0)]
    rotY = ref_params["rank%d_shot%d_RotXYZ%d" % (COMM.rank, i_shot, 1)]
    rotZ = ref_params["rank%d_shot%d_RotXYZ%d" % (COMM.rank, i_shot, 2)]
    Na = ref_params["rank%d_shot%d_Nabc%d" % (COMM.rank, i_shot, 0)]
    Nb = ref_params["rank%d_shot%d_Nabc%d" % (COMM.rank, i_shot, 1)]
    Nc = ref_params["rank%d_shot%d_Nabc%d" % (COMM.rank, i_shot, 2)]
    Nd = ref_params["rank%d_shot%d_Ndef%d" % (COMM.rank, i_shot, 0)]
    Ne = ref_params["rank%d_shot%d_Ndef%d" % (COMM.rank, i_shot, 1)]
    Nf = ref_params["rank%d_shot%d_Ndef%d" % (COMM.rank, i_shot, 2)]
    eta_a = ref_params["rank%d_shot%d_eta%d" % (COMM.rank, i_shot, 0)]
    eta_b = ref_params["rank%d_shot%d_eta%d" % (COMM.rank, i_shot, 1)]
    eta_c = ref_params["rank%d_shot%d_eta%d" % (COMM.rank, i_shot, 2)]
    G = ref_params["rank%d_shot%d_Scale" % (COMM.rank, i_shot)]
    num_uc_p = len(Modeler.ucell_man.variables)
    ucell_pars = [ref_params["rank%d_shot%d_Ucell%d" % (COMM.rank, i_shot, i_uc)] for i_uc in range(num_uc_p)]
    lam0 = ref_params["lambda0"]
    lam1 = ref_params["lambda1"]

    # update the rotational mosaicity here
    # update the mosaicity here
    eta_params = [eta_a, eta_b, eta_c]
    if SIM.umat_maker is not None:
        # we are modeling mosaic spread
        eta_abc = [p.get_val(x[p.xpos]) for p in eta_params]
        #if not SIM.D.has_anisotropic_mosaic_spread:
        #    eta_abc = eta_abc[0]
        SIM.update_umats_for_refinement(eta_abc)

    # update the photon energy spectrum for this shot
    SIM.beam.spectrum = Modeler.spectra
    SIM.D.xray_beams = SIM.beam.xray_beams
    # update the lambda coeff
    lambda_coef = lam0.get_val(x[lam0.xpos]), lam1.get_val(x[lam1.xpos])
    SIM.D.lambda_coefficients = lambda_coef

    # update the Bmatrix
    Modeler.ucell_man.variables = [p.get_val(x[p.xpos]) for p in ucell_pars]
    Bmatrix = Modeler.ucell_man.B_recipspace
    SIM.D.Bmatrix = Bmatrix
    for i_ucell in range(len(ucell_pars)):
        SIM.D.set_ucell_derivative_matrix(
            i_ucell + hopper_utils.UCELL_ID_OFFSET,
            Modeler.ucell_man.derivative_matrices[i_ucell])
    eta_a = ref_params["rank%d_shot%d_eta%d" % (COMM.rank, i_shot, 0)]
    eta_b = ref_params["rank%d_shot%d_eta%d" % (COMM.rank, i_shot, 1)]
    eta_c = ref_params["rank%d_shot%d_eta%d" % (COMM.rank, i_shot, 2)]
    G = ref_params["rank%d_shot%d_Scale" % (COMM.rank, i_shot)]
    num_uc_p = len(Modeler.ucell_man.variables)
    ucell_pars = [ref_params["rank%d_shot%d_Ucell%d" % (COMM.rank, i_shot, i_uc)] for i_uc in range(num_uc_p)]

    # update the rotational mosaicity here
    # update the mosaicity here
    eta_params = [eta_a, eta_b, eta_c]
    if SIM.umat_maker is not None:
        # we are modeling mosaic spread
        eta_abc = [p.get_val(x[p.xpos]) for p in eta_params]
        #if not SIM.D.has_anisotropic_mosaic_spread:
        #    eta_abc = eta_abc[0]
        SIM.update_umats_for_refinement(eta_abc)

    # update the photon energy spectrum for this shot
    SIM.beam.spectrum = Modeler.spectra
    SIM.D.xray_beams = SIM.beam.xray_beams

    # update the Bmatrix
    Modeler.ucell_man.variables = [p.get_val(x[p.xpos]) for p in ucell_pars]
    Bmatrix = Modeler.ucell_man.B_recipspace
    SIM.D.Bmatrix = Bmatrix
    for i_ucell in range(len(ucell_pars)):
        SIM.D.set_ucell_derivative_matrix(
            i_ucell + hopper_utils.UCELL_ID_OFFSET,
            Modeler.ucell_man.derivative_matrices[i_ucell])

    # update the Umat rotation matrix and the RotXYZ perturbation
    SIM.D.Umatrix = Modeler.PAR.Umatrix
    SIM.D.set_value(hopper_utils.ROTX_ID, rotX.get_val(x[rotX.xpos]))
    SIM.D.set_value(hopper_utils.ROTY_ID, rotY.get_val(x[rotY.xpos]))
    SIM.D.set_value(hopper_utils.ROTZ_ID, rotZ.get_val(x[rotZ.xpos]))

    # update the mosaic block size
    SIM.D.set_ncells_values((Na.get_val(x[Na.xpos]),
                             Nb.get_val(x[Nb.xpos]),
                             Nc.get_val(x[Nc.xpos])))
    SIM.D.Ncells_def = (Nd.get_val(x[Nd.xpos]),
                        Ne.get_val(x[Ne.xpos]),
                        Nf.get_val(x[Nf.xpos]))

    npix = int(len(Modeler.pan_fast_slow)/3.)

    # calculate the forward Bragg scattering and gradients
    SIM.D.add_diffBragg_spots(Modeler.pan_fast_slow)

    # set the scale factors per ROI
    perRoiScaleFactors = {}
    for roi_id, ref_idx in enumerate(Modeler.refls_idx):
        p = ref_params["rank%d_shot%d_scale_roi%d" % (COMM.rank, i_shot, roi_id )]
        slc = Modeler.roi_id_slices[roi_id][0]  # Note, there's always just one slice for roi_id
        if not p.refine:
            break
        scale_fac = p.get_val(x[p.xpos])
        Modeler.per_roi_scales_per_pix[slc] = scale_fac
        perRoiScaleFactors[roi_id] = (scale_fac, p)

    bragg_no_scale = (SIM.D.raw_pixels_roi[:npix]).as_numpy_array()

    # get the per-shot scale factor
    scale = G.get_val(x[G.xpos])

    #combined the per-shot scale factor with the per-roi scale factors
    all_bragg_scales = scale*Modeler.per_roi_scales_per_pix

    # scale the bragg scattering
    bragg = all_bragg_scales*bragg_no_scale
    if return_bragg_model:
        return bragg

    # this is the total forward model:
    model_pix = bragg + Modeler.all_background
    if SIM.use_psf:
        model_pix = convolve_model_with_psf(model_pix, SIM,  Modeler.pan_fast_slow, roi_id_slices=Modeler.roi_id_slices, roi_id_unique=Modeler.roi_id_unique)


    # compute the negative log Likelihood
    resid = (Modeler.all_data - model_pix)
    resid_square = resid ** 2
    V = model_pix + Modeler.nominal_sigma_rdout ** 2
    neg_LL = (.5*(np.log(2*np.pi*V) + resid_square / V))[Modeler.all_trusted].sum()

    # compute the z-score sigma as a diagnostic
    zscore_sigma = np.std((resid / np.sqrt(V))[Modeler.all_trusted])

    # store the gradients
    J = {}
    # this term is a common factor in all of the gradients
    common_grad_term = (0.5 / V * (1 - 2 * resid - resid_square / V))

    if perRoiScaleFactors:
        # the gradient in this case is the bragg scattering, scaled by only the total shot scale (G in the literature)
        bragg_no_roi = bragg_no_scale*scale

        for roi_id in perRoiScaleFactors:
            scale_fac, p = perRoiScaleFactors[roi_id]
            slc = Modeler.roi_id_slices[roi_id][0]  # theres just one slice for each roi_id
            d = p.get_deriv(x[p.xpos], bragg_no_roi[slc])

            if SIM.use_psf:
                x1,x2,y1,y2 = Modeler.rois[roi_id]
                sdim, fdim = y2-y1, x2-x1
                d_img = d.reshape((sdim, fdim))
                d_img = psf.convolve_with_psf(d_img, psf=SIM.PSF, **SIM.psf_args)
                d = d_img.ravel()

            d_trusted = Modeler.all_trusted[slc]
            common_term_slc = common_grad_term[slc]
            J[p.name] = (common_term_slc*d)[d_trusted].sum()

    # scale factor gradients
    conv_args = {"SIM": SIM, "pan_fast_slow": Modeler.pan_fast_slow, "roi_id_slices": Modeler.roi_id_slices, "roi_id_unique": Modeler.roi_id_unique}
    if not G.fix:
        bragg_no_roi_scale = bragg_no_scale*Modeler.per_roi_scales_per_pix
        scale_grad = G.get_deriv(x[G.xpos], bragg_no_roi_scale)
        scale_grad = convolve_model_with_psf(scale_grad, **conv_args)
        J[G.name] = (common_grad_term*scale_grad)[Modeler.all_trusted].sum()

    # Umat gradients
    for i_rot, rot in enumerate([rotX, rotY, rotZ]):
        if not rot.fix:
            rot_db_id = ROTXYZ_ID[i_rot]
            rot_grad = scale*SIM.D.get_derivative_pixels(rot_db_id).as_numpy_array()[:npix]
            rot_grad = rot.get_deriv(x[rot.xpos], rot_grad)
            rot_grad = convolve_model_with_psf(rot_grad, **conv_args)
            J[rot.name] = (common_grad_term*rot_grad)[Modeler.all_trusted].sum()

    # mosaic block size gradients
    if not Na.fix:
        Nabc_grad = SIM.D.get_ncells_derivative_pixels()
        for i_N, N in enumerate([Na, Nb, Nc]):
            N_grad = scale*(Nabc_grad[i_N][:npix].as_numpy_array())
            N_grad = N.get_deriv(x[N.xpos], N_grad)
            N_grad = convolve_model_with_psf(N_grad, **conv_args)
            J[N.name] = (common_grad_term*N_grad)[Modeler.all_trusted].sum()

    if not Nd.fix:
        Ndef_grad = SIM.D.get_ncells_def_derivative_pixels()
        for i_N, N in enumerate([Nf, Ne, Nf]):
            N_grad = scale*(Ndef_grad[i_N][:npix].as_numpy_array())
            N_grad = N.get_deriv(x[N.xpos], N_grad)
            N_grad = convolve_model_with_psf(N_grad, **conv_args)
            J[N.name] = (common_grad_term*N_grad)[Modeler.all_trusted].sum()

    if not eta_a.fix:
        if SIM.D.has_anisotropic_mosaic_spread:
            eta_abc_derivs = SIM.D.get_aniso_eta_deriv_pixels()
        else:
            eta_abc_derivs = [SIM.D.get_derivative_pixels(hopper_utils.ETA_ID)]
        for i_eta, eta in enumerate(eta_params):
            eta_grad = scale*(eta_abc_derivs[i_eta][:npix].as_numpy_array())
            eta_grad = eta.get_deriv(x[eta.xpos], eta_grad)
            eta_grad = convolve_model_with_psf(eta_grad, **conv_args)
            J[eta.name] = (common_grad_term*eta_grad)[Modeler.all_trusted].sum()
            if not SIM.D.has_anisotropic_mosaic_spread:
                break

    # unit cell gradients
    if not ucell_pars[0].fix:
        for i_ucell, uc_p in enumerate(ucell_pars):
            d = scale*SIM.D.get_derivative_pixels(hopper_utils.UCELL_ID_OFFSET+i_ucell).as_numpy_array()[:npix]
            d = uc_p.get_deriv(x[uc_p.xpos], d)
            d = convolve_model_with_psf(d, **conv_args)
            J[ucell_pars[i_ucell].name] = (common_grad_term*d)[Modeler.all_trusted].sum()

    if not lam0.fix:
        lambda_derivs = SIM.D.get_lambda_derivative_pixels()
        lam_params = lam0, lam1
        for d, pr in zip(lambda_derivs, lam_params):
            d = d.as_numpy_array()[:npix]
            d = pr.get_deriv(x[pr.xpos], d)
            d = convolve_model_with_psf(d, **conv_args)
            J[pr.name] = (common_grad_term*d)[Modeler.all_trusted].sum()

    # detector model gradients
    detector_derivs = []
    for diffbragg_parameter_id in PAN_OFS_IDS+PAN_XYZ_IDS:
        try:
            d = SIM.D.get_derivative_pixels(diffbragg_parameter_id).as_numpy_array()[:npix]
            d = convolve_model_with_psf(d, **conv_args)
            d = common_grad_term*scale*d
        except ValueError:
            d = None
        detector_derivs.append(d)
    names = "RotOrth", "RotFast", "RotSlow", "ShiftX", "ShiftY", "ShiftZ"
    for group_id in Modeler.unique_panel_group_ids:
        for name in names:
            J["group%d_%s" % (group_id, name)] = 0
        for pixel_rng in Modeler.group_id_slices[group_id]:
            trusted_pixels = Modeler.all_trusted[pixel_rng]
            for i_name, name in enumerate(names):
                par_name = "group%d_%s" % (group_id, name)
                det_param = ref_params[par_name]
                if det_param.fix:
                    continue
                pixderivs = detector_derivs[i_name][pixel_rng][trusted_pixels]
                pixderivs = det_param.get_deriv(x[det_param.xpos], pixderivs)
                J[par_name] += pixderivs.sum()

    return neg_LL, J, model_pix, zscore_sigma


def set_group_id_slices(Modeler, group_id_from_panel_id):
    """finds the boundaries for each panel group ID in the 1-D array of per-shot data
    Modeler: DataModeler instance with loaded data
    group_id_from_panel_id : dict where key is panel id and value is group id
    """
    Modeler.all_group_id = [group_id_from_panel_id[pid] for pid in Modeler.all_pid]
    splitter = np.where(np.diff(Modeler.all_group_id) != 0)[0]+1
    npix = len(Modeler.all_data)
    slices = [slice(V[0], V[-1]+1, 1) for V in np.split(np.arange(npix), splitter)]
    group_ids = [V[0] for V in np.split(np.array(Modeler.all_group_id), splitter)]
    group_id_slices = {}
    for i_group, slc in zip(group_ids, slices):
        if i_group not in group_id_slices:
            group_id_slices[i_group] = [slc]
        else:
            group_id_slices[i_group].append(slc)
    Modeler.unique_panel_group_ids = set(Modeler.all_group_id)
    logging.debug("Modeler has data on %d unique panel groups" % (len(Modeler.unique_panel_group_ids)))
    Modeler.group_id_slices = group_id_slices


def update_detector(x, ref_params, SIM, save=None):
    """
    Update the internal geometry of the diffBragg instance
    :param x: refinement parameters as seen by scipy.optimize (e.g. rescaled floats)
    :param ref_params: diffBragg.refiners.Parameters (dict of RangedParameters)
    :param SIM: SIM instance (instance of nanoBragg.sim_data.SimData)
    :param save: optional name to save the detector
    """
    det = SIM.detector
    if save is not None:
        new_det = Detector()
    for pid in range(len(det)):
        panel = det[pid]
        panel_dict = panel.to_dict()

        group_id = SIM.panel_group_from_id[pid]
        if group_id not in SIM.panel_groups_refined:
            fdet = panel.get_fast_axis()
            sdet = panel.get_slow_axis()
            origin = panel.get_origin()
        else:

            Oang_p = ref_params["group%d_RotOrth" % group_id]
            Fang_p = ref_params["group%d_RotFast" % group_id]
            Sang_p = ref_params["group%d_RotSlow" % group_id]
            Xdist_p = ref_params["group%d_ShiftX" % group_id]
            Ydist_p = ref_params["group%d_ShiftY" % group_id]
            Zdist_p = ref_params["group%d_ShiftZ" % group_id]

            Oang = Oang_p.get_val(x[Oang_p.xpos])
            Fang = Fang_p.get_val(x[Fang_p.xpos])
            Sang = Sang_p.get_val(x[Sang_p.xpos])
            Xdist = Xdist_p.get_val(x[Xdist_p.xpos])
            Ydist = Ydist_p.get_val(x[Ydist_p.xpos])
            Zdist = Zdist_p.get_val(x[Zdist_p.xpos])

            origin_of_rotation = SIM.panel_reference_from_id[pid]
            SIM.D.reference_origin = origin_of_rotation
            SIM.D.update_dxtbx_geoms(det, SIM.beam.nanoBragg_constructor_beam, pid,
                                     Oang, Fang, Sang, Xdist, Ydist, Zdist,
                                     force=False)
            fdet = SIM.D.fdet_vector
            sdet = SIM.D.sdet_vector
            origin = SIM.D.get_origin()

        if save is not None:
            panel_dict["fast_axis"] = fdet
            panel_dict["slow_axis"] = sdet
            panel_dict["origin"] = origin
            new_det.add_panel(Panel.from_dict(panel_dict))

    if save is not None and COMM.rank==0:
        t = time.time()
        El = ExperimentList()
        E = Experiment()
        E.detector = new_det
        El.append(E)
        El.as_file(save)
        t = time.time()-t
        #print("Saved detector model to %s (took %.4f sec)" % (save, t), flush=True )


def target_and_grad(x, ref_params, data_modelers, SIM, params):
    """
    Returns the target functional and the gradients
    :param x: float array of parameter values as seen by scipt.optimize (rescaled)
    :param ref_params: refinement parameter objects (diffBragg.refiners.parameters.Parameters() )
    :param data_modelers: dict of data modelers (one per experiment)
    :param SIM: sim_data instance
    :param params: phil parameters
    :return: 2-tuple, target and gradients
    """
    target_functional = 0
    grad = np.zeros(len(x))

    save_name = params.geometry.optimized_detector_name
    update_detector(x, ref_params, SIM, save_name)

    all_shot_sigZ = []
    for i_shot in data_modelers:
        Modeler = data_modelers[i_shot]

        neg_LL, neg_LL_grad, model_pix, per_shot_sigZ = model(x, ref_params, i_shot, Modeler, SIM)
        all_shot_sigZ.append(per_shot_sigZ)

        # accumulate the target functional for this rank/shot
        target_functional += neg_LL

        if params.use_restraints:
            for name in ref_params:
                if name.startswith("Fhkl"):
                    continue
                par = ref_params[name]
                if not par.is_global and not par.fix and par.beta is not None:
                    val = par.get_restraint_val(x[par.xpos])
                    target_functional += val

        # accumulate the gradients for this rank/shot
        for name in ref_params:
            if name in neg_LL_grad:
                par = ref_params[name]
                grad[par.xpos] += neg_LL_grad[name]
                # for restraints only update the per-shot restraint gradients here
                if params.use_restraints and not par.is_global and not par.fix and par.beta is not None:
                    grad[par.xpos] += par.get_restraint_deriv(x[par.xpos])

    # sum the target functional and the gradients across all ranks
    target_functional = COMM.bcast(COMM.reduce(target_functional))
    grad = COMM.bcast(COMM.reduce(grad))

    if params.use_restraints and params.geometry.betas.close_distances is not None:
        target_functional += np.std(SIM.D.close_distances) / params.geometry.betas.close_distances

    ## add in the detector parameter restraints
    if params.use_restraints:
        for name in ref_params:
            if name.startswith("Fhkl"):
                continue
            par = ref_params[name]
            if par.is_global and not par.fix and par.beta is not None:
                target_functional += par.get_restraint_val(x[par.xpos])
                grad[par.xpos] += par.get_restraint_deriv(x[par.xpos])

    all_shot_sigZ = COMM.reduce(all_shot_sigZ)
    if COMM.rank == 0:
        all_shot_sigZ = np.median(all_shot_sigZ)

    return target_functional, grad, all_shot_sigZ


def geom_min(params):
    """
    :param params: phil parameters (simtbx/diffBragg/phil.py)
    """

    launcher = ensemble_refine_launcher.RefineLauncher(params)
    if params.geometry.input_pkl is not None:
        df = pandas.read_pickle(params.geometry.input_pkl)
    else:
        assert params.geometry.input_pkl_glob is not None
        fnames = glob.glob(params.geometry.input_pkl_glob)
        dfs = []
        for i_f, f in enumerate(fnames):
            if i_f % COMM.size != COMM.rank:
                continue
            if COMM.rank==0:
                print("Loaing hopper pkl %d / %d" %(i_f+1, len(fnames)), flush=True)
            df_i = pandas.read_pickle(f)
            dfs.append(df_i)
        dfs = COMM.reduce(dfs)
        if COMM.rank==0:
            df = pandas.concat(dfs)
        else:
            df = None
        df = COMM.bcast(df)

    if params.skip is not None:
        df = df.iloc[params.skip:]
    if params.max_process is not None:
        df = df.iloc[:params.max_process]

    pdir = params.outdir
    assert pdir is not None, "provide a pandas_dir where output files will be generated"
    params.geometry.optimized_detector_name = os.path.join(pdir, os.path.basename(params.geometry.optimized_detector_name))
    if COMM.rank==0:
        if not os.path.exists(pdir):
            os.makedirs(pdir)
    if COMM.rank == 0:
        print("Will optimize using %d experiments" %len(df))

    from simtbx.diffBragg import mpi_logger
    mpi_logger.setup_logging_from_params(params)
    df.reset_index(drop=True, inplace=True)
    launcher.load_inputs(df, refls_key=params.geometry.refls_key)

    for i_shot in launcher.Modelers:
        Modeler = launcher.Modelers[i_shot]
        set_group_id_slices(Modeler, launcher.panel_group_from_id)

    # same on every rank:
    det_params = DetectorParameters(params, launcher.panel_groups_refined, launcher.n_panel_groups)

    beam_params = BeamParameters(params, launcher.Modelers)

    # different on each rank
    crystal_params = CrystalParameters(params,launcher.Modelers)
    crystal_params.parameters = COMM.bcast(COMM.reduce(crystal_params.parameters))

    LMP = Parameters()
    for p in crystal_params.parameters + det_params.parameters + beam_params.parameters:
        LMP.add(p)

    # use spectrum coefficients
    launcher.SIM.D.use_lambda_coefficients = True
    launcher.SIM.D.lambda_coefficients = LMP["lambda0"].init, LMP["lambda1"].init

    # attached some objects to SIM for convenience
    launcher.SIM.panel_reference_from_id = launcher.panel_reference_from_id
    launcher.SIM.panel_group_from_id = launcher.panel_group_from_id
    launcher.SIM.panel_groups_refined = launcher.panel_groups_refined

    # set the GPU device
    launcher.SIM.D.device_Id = COMM.rank % params.refiner.num_devices
    npx_str = "(rnk%d, dev%d): %d pix" %(COMM.rank, launcher.SIM.D.device_Id, launcher.NPIX_TO_ALLOC)
    npx_str = COMM.gather(npx_str)
    if COMM.rank==0:
        print("How many pixels each rank will allocate for on its device:")
        print("; ".join(npx_str))
    launcher.SIM.D.Npix_to_allocate = launcher.NPIX_TO_ALLOC

    # configure diffBragg instance for gradient computation
    if not params.fix.RotXYZ:
        for i_rot in range(3):
            launcher.SIM.D.refine(ROTXYZ_ID[i_rot])
    if not params.fix.spec:
        launcher.SIM.D.refine(hopper_utils.LAMBDA_IDS[0])
        launcher.SIM.D.refine(hopper_utils.LAMBDA_IDS[1])
    if not params.fix.eta_abc:
        launcher.SIM.D.refine(hopper_utils.ETA_ID)
    if not params.fix.Nabc:
        launcher.SIM.D.refine(hopper_utils.NCELLS_ID)
    if not params.fix.Ndef:
        launcher.SIM.D.refine(hopper_utils.NCELLS_ID_OFFDIAG)
    if not params.fix.ucell:
        for i_ucell in range(launcher.SIM.num_ucell_param):
            launcher.SIM.D.refine(hopper_utils.UCELL_ID_OFFSET + i_ucell)
    for i, diffbragg_id in enumerate(PAN_OFS_IDS):
        if not params.geometry.fix.panel_rotations[i]:
            launcher.SIM.D.refine(diffbragg_id)

    for i, diffbragg_id in enumerate(PAN_XYZ_IDS):
        if not params.geometry.fix.panel_translations[i]:
            launcher.SIM.D.refine(diffbragg_id)

    # do a barrel roll!
    target = Target(LMP, save_state_freq=params.geometry.save_state_freq, overwrite_state=params.geometry.save_state_overwrite)
    fcn_args = (launcher.Modelers, launcher.SIM, params)
    lbfgs_kws = {"jac": target.jac,
                 "method": "L-BFGS-B",
                 "args": fcn_args,
                 "options":  {"ftol": params.ftol, "gtol": 1e-10, "maxfun":1e5, "maxiter":params.lbfgs_maxiter}}

    result = basinhopping(target, target.x0[target.vary],
                          niter=params.niter,
                          minimizer_kwargs=lbfgs_kws,
                          T=params.temp,
                          callback=target.at_min_callback,
                          disp=False,
                          stepsize=params.stepsize)

    target.x0[target.vary] = result.x
    Xopt = target.x0  # optimized, rescaled parameters

    if params.geometry.optimized_results_tag is not None:
        write_output_files(Xopt, LMP, launcher.Modelers, launcher.SIM, params)

    if COMM.rank == 0:
        save_opt_det(params, target.x0, target.ref_params, launcher.SIM)


def write_output_files(Xopt, LMP, Modelers, SIM, params):
    """
    Writes refl and exper files for each experiment modeled during
    the ensemble refiner
    :param Xopt: float array of optimized rescaled parameter values
    :param LMP: simtbx.diffBragg.refiners.parameters.Parameters() object
    :param Modelers: data modelers (launcher.Modleers
    :param SIM: instance of sim_data (launcher.SIM)
    :param params: phil params, simtbx.diffBragg.phil.py
    """
    opt_det = get_optimized_detector(Xopt, LMP, SIM)
    if COMM.rank==0:
        temp = params.geometry.optimized_detector_name
        params.geometry.optimized_detector_name = os.path.splitext(temp)[0] + "_current.expt"
        save_opt_det(params, Xopt, LMP, SIM)
        params.geometry.optimized_detector_name = temp

    if params.outdir is not None and COMM.rank == 0:
        if not os.path.exists(params.outdir):
            os.makedirs(params.outdir)
        if params.debug_mode:
            refdir = os.path.join(params.outdir, "refls")
            expdir = os.path.join(params.outdir, "expts")
            moddir = os.path.join(params.outdir, "modelers")
            for dname in [refdir, expdir, moddir]:
                if not os.path.exists(dname):
                    os.makedirs(dname)

    COMM.barrier()
    lam0_lam1 = []
    for i_lam in [0,1]:
        lam_p = LMP["lambda%d"% i_lam]
        val = lam_p.get_val(Xopt[lam_p.xpos])
        lam0_lam1.append(val)

    all_shot_pred_offsets = []
    all_dfs = []
    for i_shot in Modelers:
        Modeler = Modelers[i_shot]
        # these are in simtbx.diffBragg.refiners.parameters.RangedParameter objects
        rotX = LMP["rank%d_shot%d_RotXYZ%d" % (COMM.rank, i_shot, 0)]
        rotY = LMP["rank%d_shot%d_RotXYZ%d" % (COMM.rank, i_shot, 1)]
        rotZ = LMP["rank%d_shot%d_RotXYZ%d" % (COMM.rank, i_shot, 2)]
        num_uc_p = len(Modeler.ucell_man.variables)
        ucell_pars = [LMP["rank%d_shot%d_Ucell%d" % (COMM.rank, i_shot, i_uc)] for i_uc in range(num_uc_p)]

        # convert rotation angles back to radians (thats what the parameters.RangedParamter.get_val method does)
        rotXYZ = rotX.get_val(Xopt[rotX.xpos]), \
            rotY.get_val(Xopt[rotY.xpos]), \
            rotZ.get_val(Xopt[rotZ.xpos])

        # ucell_man is an instance of
        # simtbx.diffBragg.refiners.crystal_systems.manager.Manager()
        # (for the correct xtal system)
        Modeler.ucell_man.variables = [p.get_val(Xopt[p.xpos]) for p in ucell_pars]
        ucpar = Modeler.ucell_man.unit_cell_parameters

        new_crystal = hopper_utils.new_cryst_from_rotXYZ_and_ucell(rotXYZ, ucpar, Modeler.E.crystal)
        new_exp = deepcopy(Modeler.E)
        new_exp.crystal = new_crystal
        wave, wt = map(np.array, zip(*Modeler.spectra))
        ave_wave = (wave*wt).sum()/wt.sum()
        new_exp.beam.set_wavelength(ave_wave)
        new_exp.detector = opt_det

        Modeler.best_model = model(Xopt, LMP, i_shot, Modeler, SIM, return_bragg_model=True)
        Modeler.best_model_includes_background = False

        # store the updated per-roi scale factors in the new refl table
        roi_scale_factor = flex.double(len(Modeler.refls), 1)
        for roi_id in Modeler.roi_id_unique:
            p = LMP["rank%d_shot%d_scale_roi%d" % (COMM.rank, i_shot, roi_id)]
            scale_fac = p.get_val(Xopt[p.xpos])
            test_refl_idx = Modeler.refls_idx[roi_id]
            slc = Modeler.roi_id_slices[roi_id][0]
            roi_refl_ids = Modeler.all_refls_idx[slc]
            # NOTE, just a sanity check:
            assert len(np.unique(roi_refl_ids))==1, "unique refl ids"
            refl_idx = roi_refl_ids[0]
            assert test_refl_idx==refl_idx
            roi_scale_factor[refl_idx] = scale_fac
        Modeler.refls["scale_factor"] = roi_scale_factor

        # get the new refls
        new_refl = hopper_utils.get_new_xycalcs(Modeler, new_exp, old_refl_tag="before_geom_ref")

        new_refl_fname, refl_ext = os.path.splitext(Modeler.refl_name)
        new_refl_fname = "rank%d_%s_%s%s" % (COMM.rank, os.path.basename(new_refl_fname), params.geometry.optimized_results_tag, refl_ext)
        if not new_refl_fname.endswith(".refl"):
            new_refl_fname += ".refl"
        new_refl_fname = os.path.join(params.outdir,"refls",  new_refl_fname)
        if params.debug_mode:
            new_refl.as_file(new_refl_fname)
        shot_pred_offsets = get_dist_from_R(new_refl)
        all_shot_pred_offsets += list(shot_pred_offsets)

        new_expt_fname, expt_ext = os.path.splitext(Modeler.exper_name)
        new_expt_fname = "rank%d_%s_%s%s" % (COMM.rank, os.path.basename(new_expt_fname), params.geometry.optimized_results_tag, expt_ext)

        if not new_expt_fname.endswith(".expt"):
            new_expt_fname += ".expt"

        new_expt_fname = os.path.join(params.outdir,"expts", new_expt_fname)
        new_exp_lst = ExperimentList()
        new_exp_lst.append(new_exp)
        if params.debug_mode:
            new_exp_lst.as_file(new_expt_fname)

        if params.outdir is not None:
            a,b,c,al,be,ga = ucpar
            ncells_p = [LMP["rank%d_shot%d_Nabc%d" % (COMM.rank, i_shot, i)] for i in range(3)]
            ncells_def_p = [LMP["rank%d_shot%d_Ndef%d" % (COMM.rank, i_shot, i)] for i in range(3)]
            Na,Nb,Nc = [p.get_val(Xopt[p.xpos]) for p in ncells_p]
            Nd,Ne,Nf = [p.get_val(Xopt[p.xpos]) for p in ncells_def_p]

            eta_p = [LMP["rank%d_shot%d_eta%d" % (COMM.rank, i_shot, i)] for i in range(3)]
            eta_abc = tuple([p.get_val(Xopt[p.xpos]) for p in eta_p])

            scale_p = LMP["rank%d_shot%d_Scale" %(COMM.rank, i_shot)]
            scale = scale_p.get_val(Xopt[scale_p.xpos])

            _,fluxes = zip(*SIM.beam.spectrum)
            # TODO OUTPUTDEF and LAM0, LAM1
            df= single_expt_pandas(xtal_scale=scale, Amat=new_crystal.get_A(),
                                   ncells_abc=(Na, Nb, Nc), ncells_def=(Nd, Ne, Nf),
                                   eta_abc=eta_abc,
                                   diff_gamma=(np.nan, np.nan, np.nan),
                                   diff_sigma=(np.nan, np.nan, np.nan),
                                   detz_shift=0,
                                   use_diffuse=params.use_diffuse_models,
                                   gamma_miller_units=params.gamma_miller_units,
                                   eta=np.nan,
                                   rotXYZ=tuple(rotXYZ),
                                   ucell_p = (a,b,c,al,be,ga),
                                   ucell_p_init=(np.nan, np.nan, np.nan, np.nan, np.nan, np.nan),
                                   lam0_lam1 = lam0_lam1,
                                   spec_file=Modeler.spec_name,
                                   spec_stride=params.simulator.spectrum.stride,
                                   flux=sum(fluxes), beamsize_mm=SIM.beam.size_mm,
                                   orig_exp_name=Modeler.exper_name,
                                   opt_exp_name=os.path.abspath(new_expt_fname),
                                   spec_from_imageset=params.spectrum_from_imageset,
                                   oversample=SIM.D.oversample,
                                   opt_det=params.opt_det, stg1_refls=Modeler.refl_name, stg1_img_path=None)
            all_dfs.append(df)

            # optionally save the modeler file
            if params.debug_mode:
                mod_name = os.path.splitext(os.path.basename(new_expt_fname))[0] + ".npy"
                mod_name = os.path.join(params.outdir, "modelers", mod_name)
                np.save(mod_name, Modeler)

    rank_df = pandas.concat(all_dfs)
    pandas_name = os.path.join(params.outdir, "models_rank%d.pkl" % COMM.rank)
    rank_df.to_pickle(pandas_name)

    all_shot_pred_offsets = COMM.reduce(all_shot_pred_offsets)
    if COMM.rank==0:
        median_pred_offset = np.median(all_shot_pred_offsets)
    else:
        median_pred_offset = None
    median_pred_offset = COMM.bcast(median_pred_offset)

    return median_pred_offset


def save_opt_det(phil_params, x, ref_params, SIM):
    opt_det = get_optimized_detector(x, ref_params, SIM)
    El = ExperimentList()
    E = Experiment()
    E.detector = opt_det
    El.append(E)
    El.as_file(phil_params.geometry.optimized_detector_name)
    print("Saved detector model to %s" % phil_params.geometry.optimized_detector_name )


def get_optimized_detector(x, ref_params, SIM):
    new_det = Detector()
    for pid in range(len(SIM.detector)):
        panel = SIM.detector[pid]
        panel_dict = panel.to_dict()
        group_id = SIM.panel_group_from_id[pid]
        if group_id in SIM.panel_groups_refined:

            Oang_p = ref_params["group%d_RotOrth" % group_id]
            Fang_p = ref_params["group%d_RotFast" % group_id]
            Sang_p = ref_params["group%d_RotSlow" % group_id]
            Xdist_p = ref_params["group%d_ShiftX" % group_id]
            Ydist_p = ref_params["group%d_ShiftY" % group_id]
            Zdist_p = ref_params["group%d_ShiftZ" % group_id]

            Oang = Oang_p.get_val(x[Oang_p.xpos])
            Fang = Fang_p.get_val(x[Fang_p.xpos])
            Sang = Sang_p.get_val(x[Sang_p.xpos])
            Xdist = Xdist_p.get_val(x[Xdist_p.xpos])
            Ydist = Ydist_p.get_val(x[Ydist_p.xpos])
            Zdist = Zdist_p.get_val(x[Zdist_p.xpos])

            origin_of_rotation = SIM.panel_reference_from_id[pid]
            SIM.D.reference_origin = origin_of_rotation
            SIM.D.update_dxtbx_geoms(SIM.detector, SIM.beam.nanoBragg_constructor_beam, pid,
                                     Oang, Fang, Sang, Xdist, Ydist, Zdist,
                                     force=False)
            fdet = SIM.D.fdet_vector
            sdet = SIM.D.sdet_vector
            origin = SIM.D.get_origin()
        else:
            fdet = panel.get_fast_axis()
            sdet = panel.get_slow_axis()
            origin = panel.get_origin()
        panel_dict["fast_axis"] = fdet
        panel_dict["slow_axis"] = sdet
        panel_dict["origin"] = origin

        new_det.add_panel(Panel.from_dict(panel_dict))

    return new_det


 *******************************************************************************


 *******************************************************************************
simtbx/diffBragg/refiners/parameters.py

from __future__ import absolute_import, division, print_function
import numpy as np
from numpy import sin, cos, arcsin
from collections import OrderedDict


class Parameters(OrderedDict):
  def add(self, p):
    p.xpos = len(self)
    self[p.name] = p


class RangedParameter:
  # TODO, make setting attributes named 'max' and 'min' attributes illegal
  """
  simple tool for managing parameters during refinement

  We re-parameterize to create a psuedo-free parameter
  See https://lmfit.github.io/lmfit-py/bounds.html
  """

  def __init__(self, init=0, minval=-1, maxval=1, sigma=1, fix=False, center=None, beta=None,
               name="param", is_global=False):
    """

    :param init: initial value for parameter
    :param minval: min value
    :param maxval: max value
    :param sigma: refinement sensitivity factor
    :param fix: whether to fix the parameter
    :param center: restraint center
    :param beta: restraint variance (smaller values give rise to tighter restraints)
    :param name: str, an optional name for this parameter, for bookkeeping
    :param is_global: bool, useful flag, if True, the parameter is common to all shots in a multi-shot refinement
    """
    self.misc_data = None  #custom field for user data
    self.minval = minval
    self.maxval = maxval
    self.sigma = sigma
    self.init = init
    self.fix = fix
    self.center = center
    self.beta = beta
    self.name = name
    self.is_global = is_global  # useful flag for potential APIs, specifies if the parameter is shared amongst all shots ?
    self._current_val = None  # place holder for the last value (output of get_val)
    # TODO use _rescaled_val in get_restraint_term and get_deriv in order to limit the valls to get_val
    self.xpos = 0  # position of parameter in list of params
    if fix:
      self.minval = init - 1
      self.maxval = init + 1
    self._arcsin_term = None

  def get_restraint_deriv(self, reparam_val):
    val = self.get_val(reparam_val)
    delta = self.center - val
    deriv = self.get_deriv(reparam_val, -delta/self.beta)
    return deriv

  def get_restraint_val(self, reparam_val):
    if not self.refine:
      return 0
    val = self.get_val(reparam_val)
    dist = self.center - val
    restraint_term = .5*(np.log(2*np.pi*self.beta) + dist**2/self.beta)
    return restraint_term

  @property
  def refine(self):
    return not self.fix

  @property
  def maxval(self):
    return self._maxval

  @maxval.setter
  def maxval(self, val):
    self._maxval = val

  @property
  def minval(self):
    return self._minval

  @minval.setter
  def minval(self, val):
    self._minval = val

  @property
  def rng(self):
    if self.minval >= self.maxval:
      raise ValueError("minval (%f) for RangedParameter must be less than the maxval (%f)" % (self.minval, self.maxval))
    return self.maxval - self.minval

  @property
  def arcsin_term(self):
    if self._arcsin_term is None:
      self._arcsin_term = arcsin(2 * (self.init - self.minval) / self.rng - 1)
    return self._arcsin_term

  def get_val(self, x_current):
    sin_arg = self.sigma * (x_current - 1) + self.arcsin_term
    val = (sin(sin_arg) + 1) * self.rng / 2 + self.minval
    self.value = val
    self.xvalue = x_current
    return val

  def get_deriv(self, x_current, deriv):
    cos_arg = self.sigma * (x_current - 1) + self.arcsin_term #arcsin(2 * (self.init - self.minval) / self.rng - 1)
    dtheta_dx = self.rng / 2 * cos(cos_arg) * self.sigma
    return deriv*dtheta_dx

  def get_second_deriv(self, x_current, deriv, second_deriv):
    sin_arg = self.sigma * (x_current - 1) + arcsin(2 * (self.init - self.minval) / self.rng - 1)
    cos_arg = self.sigma * (x_current - 1) + arcsin(2 * (self.init - self.minval) / self.rng - 1)
    dtheta_dx = self.rng / 2 * cos(cos_arg) * self.sigma
    d2theta_dx2 = -sin(sin_arg)*self.sigma*self.sigma * self.rng / 2.
    return dtheta_dx*dtheta_dx*second_deriv + d2theta_dx2*deriv

  @property
  def misc_data(self):
    return self._misc_data

  @misc_data.setter
  def misc_data(self, val):
    self._misc_data = val


class PositiveParameter(RangedParameter):

  def get_val(self, x_current):
    return self.init*np.exp(self.sigma*(x_current-1))

  def get_deriv(self, x_current, deriv, x_is_theta=False):
    """
    :param x_current: unscaled or rescaled parameter (see x_is_theta description)
    :param deriv: gradient array
    :param x_is_theta: optional, can skip recomputing the exponential if x_current is the unscaled parameter
    :return:
    """
    if x_is_theta:
      dtheta_dx = x_current *self.sigma
    else:
      dtheta_dx = self.get_val(x_current) * self.sigma
    return deriv*dtheta_dx


class NormalParameter(RangedParameter):

  def __init__(self, *args, **kwargs):
    super().__init__(*args, **kwargs)

  def get_val(self, x):
    return x

  def get_deriv(self, x, deriv):
    return deriv


 *******************************************************************************


 *******************************************************************************
simtbx/diffBragg/refiners/stage_two_refiner.py
from __future__ import absolute_import, division, print_function

from libtbx.mpi4py import MPI
from simtbx.diffBragg import stage_two_utils

COMM = MPI.COMM_WORLD
if not hasattr(COMM, "rank"):
    COMM.rank=0
    COMM.size=1
import time
import warnings
import signal
import logging
from copy import deepcopy
from simtbx.diffBragg import hopper_io

LOGGER = logging.getLogger("diffBragg.main")
warnings.filterwarnings("ignore")


class SignalHandler:
    def __init__(self):
        self.t = time.time()

    def handle(self, signum, frame):
        t = time.time()-self.t
        print("Recived signal ",signum," after program running for %f sec" % t)
        raise BreakBecauseSignal


SIGHAND = SignalHandler()


class Bcolors:
    HEADER = '\033[95m'
    OKBLUE = '\033[94m'
    OKGREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'

try:
    import pandas
    HAS_PANDAS = True
except ImportError:
    HAS_PANDAS = False

# TODO : consider PEP-8 ing these numpy imports, but do a NERSC massively MPI time-test first...
# for now, if it aint broke, dont fix it ...
import numpy as np
import os

from simtbx.diffBragg.refiners import BreakBecauseSignal, BreakToUseCurvatures
from dials.array_family import flex
from simtbx.diffBragg.refiners import BaseRefiner
from cctbx import miller, sgtbx
from simtbx.diffBragg.refiners.parameters import RangedParameter

# how many parameters per shot, currently just scale, B-factor (currently ignored), and Ncells abc
N_PARAM_PER_SHOT = 5


class StageTwoRefiner(BaseRefiner):

    def __init__(self, shot_modelers, sgsymbol, params):
        BaseRefiner.__init__(self)

        self.params = params
        self.trad_conv_eps = self.params.refiner.tradeps
        self.calc_curvatures = self.params.refiner.curvatures
        self.break_signal = self.params.refiner.break_signal
        self.output_dir = self.params.refiner.io.output_dir  # directory to dump progress files, these can be used to restart simulation later
        self.save_model_freq = self.params.refiner.stage_two.save_model_freq
        self.use_nominal_h = self.params.refiner.stage_two.use_nominal_hkl

        self.saveZ_freq = self.params.refiner.stage_two.save_Z_freq  # save Z-score data every N function calls
        self.break_signal = None  # check for this signal during refinement, and break refinement if signal is received (see python signal module) TODO: make work with MPI
        self.save_model = False  # whether to save the model
        self.hiasu = None  # stores Hi_asu, counts, maps to and from fcell indices
        self.rescale_params = True  # whether to rescale parameters during refinement  # TODO this will always be true, so remove the ability to disable
        self.request_diag_once = False  # LBFGS refiner property
        self.min_multiplicity = self.params.refiner.stage_two.min_multiplicity
        self.restart_file = None  # output file from previous run refinement
        self.trial_id = 0  # trial id in case multiple trials are run in sequence
        self.x_init = None  # used to restart the refiner (e.g. self.x gets updated with this)
        self.log_fcells = True  # to refine Fcell using logarithms to avoid negative Fcells
        self.refine_crystal_scale = False  # whether to refine the crystal scale factor
        self.refine_Fcell = False  # whether to refine Fhkl for each shoebox ROI
        self.use_curvatures_threshold = 7  # how many positive curvature iterations required before breaking, after which simulation can be restart with use_curvatures=True
        self.verbose = True  # whether to print during iterations
        self.iterations = 0  # iteration counter , used internally
        self.target_eval_count = 0  # target function evaluation counter, used internally
        self.shot_ids = None  # for global refinement ,
        self.log2pi = np.log(np.pi*2)

        self._sig_hand = None  # method for handling the break_signal, e.g. SIGHAND.handle defined above (theres an MPI version in global_refiner that overwrites this in stage 2)
        self._is_trusted = None  # used during refinement, 1-D array or trusted pixels corresponding to the pixels in the ROI

        self.rank = COMM.rank

        self.Modelers = shot_modelers
        self.shot_ids = sorted(self.Modelers.keys())
        # part of the re-parameterization for the per-spot scale factors requires us to take the sqrt here
        for i_shot in self.shot_ids:
            self.Modelers[i_shot].PAR.Scale.init = np.sqrt(self.Modelers[i_shot].PAR.Scale.init)
        self.n_shots = len(shot_modelers)
        self.n_shots_total = COMM.bcast(COMM.reduce(self.n_shots))
        LOGGER.debug("Loaded %d shots across all ranks" % self.n_shots_total)
        self.f_vals = []  # store the functional over time

        self._ncells_id = 9  # diffBragg internal index for Ncells derivative manager
        self._detector_distance_id = 10  # diffBragg internal index for detector_distance derivative manager
        self._panelRotO_id = 14  # diffBragg internal index for derivative manager
        self._panelRotF_id = 17  # diffBragg internal index for derivative manager
        self._panelRotS_id = 18  # diffBragg internal index for derivative manager
        self._panelX_id = 15  # diffBragg internal index for  derivative manager
        self._panelY_id = 16  # diffBragg internal index for  derivative manager
        self._fcell_id = 11  # diffBragg internal index for Fcell derivative manager
        self._eta_id = 19  # diffBragg internal index for eta derivative manager
        self._lambda0_id = 12  # diffBragg interneal index for lambda derivatives
        self._lambda1_id = 13  # diffBragg interneal index for lambda derivatives
        self._ncells_def_id = 21

        self.symbol = sgsymbol
        self.space_group = sgtbx.space_group(sgtbx.space_group_info(symbol=self.symbol).type().hall_symbol())

        self.REGIONS = None  # detector regions for gain refinement (this is a labeled array, same shape as self.S.detector
        self.num_regions = None  # the number of unique regions
        self.unique_regions = None  # the unique regions as a 1-d np.array
        self.region_params = {}  # dictionary for storuing diffBragg/refiners/parameters.RangerParameter for gain correction params

        self.I_AM_ROOT = COMM.rank==0

    def _load_gain_regions(self):
        npan = len(self.S.detector)
        nfast, nslow = self.S.detector[0].get_image_size()
        det_shape = npan, nslow, nfast
        self.REGIONS = stage_two_utils.regionize_detector(det_shape, self.params.refiner.region_size)
        self.unique_regions = np.unique(self.REGIONS)
        self.num_regions = len(self.unique_regions)

    def __call__(self, *args, **kwargs):
        _, _ = self.compute_functional_and_gradients()
        return self.x, self._f, self._g, self.d

    @property
    def n(self):
        """LBFGS property"""
        return len(self.x)

    @property
    def n_global_fcell(self):
        return self.hiasu.present_len

    @property
    def image_shape(self):
        panelXdim, panelYdim = self.S.detector[0].get_image_size()
        Npanels = len(self.S.detector)
        return Npanels, panelYdim, panelXdim

    @property
    def x(self):
        """LBFGS parameter array"""
        return self._x

    @x.setter
    def x(self, val):
        self._x = val

    def _check_keys(self, shot_dict):
        """checks that the dictionary keys are the same"""
        if not sorted(shot_dict.keys()) == self.shot_ids:
            raise KeyError("input data funky, check GlobalRefiner inputs")
        return shot_dict

    def _set_current_gain_per_pixel(self):
        M = self.Modelers[self._i_shot]
        #M._gain_region_per_pixel = self.REGIONS[M.all_pid, M.all_slow, M.all_fast]
        M.all_gain = self._gain_per_region[M._gain_region_per_pixel]

    def _evaluate_averageI(self):
        """model_Lambda means expected intensity in the pixel"""
        # NOTE: gain correction is applied to te background fit, as the background was fit to the data
        self.model_Lambda = self.Modelers[self._i_shot].all_background + self.model_bragg_spots

    def make_output_dir(self):
        if self.I_AM_ROOT and not os.path.exists(self.output_dir):
            os.makedirs(self.output_dir)
        self.Zdir = os.path.join(self.output_dir, "Z")
        self.model_dir = os.path.join(self.output_dir, "model")
        for dirname in (self.Zdir, self.model_dir):
            if self.params.debug_mode and self.I_AM_ROOT and not os.path.exists(dirname):
                os.makedirs(dirname)
        COMM.barrier()

    def _setup(self):
        # Here we go!  https://youtu.be/7VvkXA6xpqI
        if not self.params.debug_mode:
            LOGGER.info("Disabling saveZ and save_model because debug_mode=False")
            self.saveZ_freq = None
            self.save_model_freq = None
        LOGGER.info("Setup begins!")
        if self.refine_Fcell and not self.hiasu.from_idx:
            raise ValueError("Need to supply a non empty asu from idx map")
        if self.refine_Fcell and not self.hiasu.to_idx:
            raise ValueError("Need to supply a non empty idx from asu map")

        self.make_output_dir()
        self._load_gain_regions()

        self.shot_mapping = self._get_shot_mapping()
        self.n_total_shots = len(self.shot_mapping)

        test_shot = self.shot_ids[0]
        self.n_ucell_param = len(self.Modelers[test_shot].PAR.ucell_man.variables)  # not used
        self.n_total_params = self.n_total_shots*N_PARAM_PER_SHOT + self.n_global_fcell + self.num_regions

        self.spot_scale_xpos = {}
        self.Bfactor_xpos = {}
        self.Ncells_xstart = {}
        for shot_id in self.shot_ids:
            self.spot_scale_xpos[shot_id] = self.shot_mapping[shot_id]*N_PARAM_PER_SHOT
            self.Bfactor_xpos[shot_id] = self.shot_mapping[shot_id]*N_PARAM_PER_SHOT + 1
            self.Ncells_xstart[shot_id] = self.shot_mapping[shot_id]*N_PARAM_PER_SHOT + 2
        LOGGER.info("--0 create an Fcell mapping")
        if self.refine_Fcell:
            #idx, data = self.S.D.Fhkl_tuple
            #self.idx_from_p1 = {h: i for i, h in enumerate(idx)}
            self._make_p1_equiv_mapping()
            # self.p1_from_idx = {i: h for i, h in zip(idx, data)}

        # Make a mapping of panel id to parameter index and backwards
        self.pid_from_idx = {}
        self.idx_from_pid = {}

        self.x = flex.double(np.ones(self.n_total_params))
        LOGGER.info("--Setting up per shot parameters")

        self.fcell_xstart = self.n_total_shots*N_PARAM_PER_SHOT
        self.regions_xstart = self.fcell_xstart + self.n_global_fcell

        self._setup_region_refinement_parameters()
        self._setup_ncells_refinement_parameters()
        self._track_num_times_pixel_was_modeled()

        self._setup_nominal_hkl_p1()
        self._MPI_setup_global_params()
        self._MPI_sync_fcell_parameters()
        # reduce then broadcast fcell
        LOGGER.info("--combining parameters across ranks")
        self._MPI_sync_hkl_freq()  # FIXME does this do absolutely anything?

        if self.x_init is not None:
            LOGGER.info("Initializing with provided x_init array")
            self.x = self.x_init
        elif self.restart_file is not None:
            LOGGER.info("Restarting from parameter file %s" % self.restart_file)
            self.x = flex.double(np.load(self.restart_file)["x"])

        # setup the diffBragg instance
        self.D = self.S.D

        self.D.refine(self._fcell_id)
        if self.params.refiner.refine_Nabc:
            self.D.refine(self._ncells_id)
        self.D.initialize_managers()

        for sid in self.shot_ids:
            Modeler = self.Modelers[sid]
            Modeler.all_fcell_global_idx = np.array([self.hiasu.to_idx[h] for h in Modeler.hi_asu_perpix])
            Modeler.unique_i_fcell = set(Modeler.all_fcell_global_idx)
            Modeler.i_fcell_slices = self._get_i_fcell_slices(Modeler)
            self.Modelers[sid] = Modeler  # TODO: VERIFY IF THIS IS NECESSARY ?

        self._MPI_barrier()
        LOGGER.info("Setup ends!")

    def _track_num_times_pixel_was_modeled(self):
        self.pixel_was_modeled = np.zeros(self.REGIONS.shape)
        self.region_was_modeled = np.zeros(self.num_regions)
        for i_shot in self.shot_ids:
            M = self.Modelers[i_shot]
            self.pixel_was_modeled[M.all_pid, M.all_slow, M.all_fast] += 1
            M._gain_region_per_pixel = self.REGIONS[M.all_pid, M.all_slow, M.all_fast]
            M._unique_gain_regions = set(M._gain_region_per_pixel)
            for i_reg in M._unique_gain_regions:
                self.region_was_modeled[i_reg] += 1

        self.pixel_was_modeled = self._MPI_reduce_broadcast(self.pixel_was_modeled)
        self.region_was_modeled = self._MPI_reduce_broadcast(self.region_was_modeled)

    def _setup_region_refinement_parameters(self):
        self.region_params = {}
        for i_reg in range(self.num_regions):
            minGain, maxGain = self.params.refiner.gain_map_min_max
            if self.params.refiner.gain_restraint is not None:
                center,beta = self.params.refiner.gain_restraint
            else:
                center = 1
                beta = 1e10
            p = RangedParameter(init=1, minval=minGain, maxval=maxGain, sigma=1, center=center, beta=beta)
            p.xpos = self.regions_xstart + i_reg
            p.name = "region%d" % i_reg
            self.region_params[p.name] = p

    def _setup_ncells_refinement_parameters(self):
        names = "Na", "Nb", "Nc"
        for i_shot in self.shot_ids:
            Ncells_params = self.Modelers[i_shot].PAR.Nabc
            for i_n, p in enumerate(Ncells_params):
                p.xpos = self.Ncells_xstart[i_shot] + i_n
                p.name = "%s_shot%d_rank%d" % ( names[i_n], i_shot, COMM.rank)

    def _gain_restraints(self):
        if self.params.refiner.gain_restraint:
            for p in self.region_params.values():
                self.target_functional += p.get_restraint_val(self.x[p.xpos])
                self.grad[p.xpos] += p.get_restraint_deriv(self.x[p.xpos])

    def _get_i_fcell_slices(self, Modeler):
        """finds the boundaries for each fcell in the 1-D array of per-shot data"""
        # TODO move this to Data Modeler class ?
        splitter = np.where(np.diff(Modeler.all_fcell_global_idx) != 0)[0]+1
        npix = len(Modeler.all_fcell_global_idx)
        slices = [slice(V[0], V[-1]+1, 1) for V in np.split(np.arange(npix), splitter)]
        i_fcells = [V[0] for V in np.split(Modeler.all_fcell_global_idx, splitter)]
        i_fcell_slices = {}
        for i_fcell, slc in zip(i_fcells, slices):
            if i_fcell not in i_fcell_slices:
                i_fcell_slices[i_fcell] = [slc]
            else:
                i_fcell_slices[i_fcell].append(slc)
        return i_fcell_slices

    def _get_shot_mapping(self):
        """each modeled shot maps to an integer along interval [0,Nshots) """
        all_shot_ids = COMM.gather(self.shot_ids)
        shot_mapping = None
        if COMM.rank == 0:
            unique_shot_ids = set([sid for shot_ids in all_shot_ids for sid in shot_ids])
            shot_mapping = {shot_id: i_shot for i_shot, shot_id in enumerate(unique_shot_ids)}
        shot_mapping = COMM.bcast(shot_mapping)
        return shot_mapping

    def _make_p1_equiv_mapping(self):
        self.num_equivs_for_i_fcell = {}
        self.update_indices = []
        for i_fcell in range(self.n_global_fcell):
            hkl_asu = self.hiasu.from_idx[i_fcell]

            equivs = [i.h() for i in miller.sym_equiv_indices(self.space_group, hkl_asu).indices()]
            self.num_equivs_for_i_fcell[i_fcell] = len(equivs)
            self.update_indices += equivs
        self.update_indices = flex.miller_index(self.update_indices)

    def _MPI_setup_global_params(self):
        if self.I_AM_ROOT:
            LOGGER.info("--2 Setting up global parameters")
            if self.output_dir is not None:
                np.save(os.path.join(self.output_dir, "f_asu_map"), self.hiasu.from_idx)

            self._setup_fcell_params()

    def _setup_nominal_hkl_p1(self):
        Omatrix = np.reshape(self.S.crystal.Omatrix.elems, [3, 3])
        for i_shot in self.Modelers:
            MOD = self.Modelers[i_shot]
            nom_h = MOD.all_nominal_hkl
            nom_h_p1 = np.dot(nom_h, Omatrix).astype(np.int32)
            nom_h_p1 = list(map(tuple, nom_h_p1))
            self.Modelers[i_shot].all_nominal_hkl_p1 = nom_h_p1

    def _setup_fcell_params(self):
        if self.refine_Fcell:
            LOGGER.info("----loading fcell data")
            # this is the number of observations of hkl (accessed like a dictionary via global_fcell_index)
            LOGGER.info("---- -- counting hkl totes")
            LOGGER.info("compute HKL multiplicity")
            self.hkl_frequency = self.hiasu.present_idx_counter
            LOGGER.info("save HKL multiplicity")
            np.save(os.path.join(self.output_dir, "f_asu_multi"), self.hkl_frequency)
            LOGGER.info("Done ")

            LOGGER.info("local refiner symbol=%s ; nanoBragg crystal symbol: %s" % (self.symbol, self.S.crystal.symbol))
            self.fcell_init_from_i_fcell = []
            ma = self.S.crystal.miller_array
            LOGGER.info("make an Fhkl map")
            ma_map = {h: d for h,d in zip(ma.indices(), ma.data())}
            Omatrix = np.reshape(self.S.crystal.Omatrix.elems,[3,3])

            # TODO: Vectorize
            for i_fcell in range(self.n_global_fcell):
                asu_hkl = self.hiasu.from_idx[i_fcell]  # high symmetry
                P1_hkl = tuple(np.dot(Omatrix, asu_hkl).astype(int))
                fcell_val = ma_map[P1_hkl]
                self.fcell_init_from_i_fcell.append(fcell_val)
            self.fcell_init_from_i_fcell = np.array(self.fcell_init_from_i_fcell)

            self.fcell_sigmas_from_i_fcell = self.params.sigmas.Fhkl
            LOGGER.info("DONE make fcell_init")

    def _get_sausage_parameters(self, i_shot):
        pass

    def _get_rotXYZ(self, i_shot):
        vals = [self.Modelers[i_shot].RotXYZ[i_rot].init for i_rot in range(3)]
        return vals

    def _get_rotX(self, i_shot):
        pass

    def _get_rotY(self, i_shot):
        pass

    def _get_rotZ(self, i_shot):
        pass

    def _get_spectra_coefficients(self):
        pass

    def _get_ucell_vars(self, i_shot):
        vars = []
        for i in range(self.n_ucell_param):
            var = self.Modelers[i_shot].PAR.ucell[i].init
            vars.append(var)
        return vars

    def _get_panelRot_val(self, panel_id):
        pass

    def _get_panelXYZ_val(self, panel_id, i_shot=0):
        pass

    def _get_detector_distance_val(self, i_shot):
        return self.Modelers[i_shot].PAR.detz_shift.init

    def _get_ncells_def_vals(self, i_shot):
        pass

    def _get_ncells_abc(self, i_shot):
        if self.params.refiner.refine_Nabc:
            vals = []
            Nabc_p = self.Modelers[i_shot].PAR.Nabc
            for p in Nabc_p:
                xval = self.x[p.xpos]
                val = p.get_val(xval)
                vals.append(val)
        else:
            vals = [self.Modelers[i_shot].PAR.Nabc[i_N].init for i_N in range(3)]

        return vals

    def _get_eta(self, i_shot):
        # NOTE: refinement of eta not supported in this script
        vals = [self.Modelers[i_shot].PAR.eta[i_eta].init for i_eta in range(3)]
        return vals

    def _get_spot_scale(self, i_shot):
        xval = self.x[self.spot_scale_xpos[i_shot]]
        PAR = self.Modelers[i_shot].PAR
        sig = PAR.Scale.sigma
        init = PAR.Scale.init
        val = sig*(xval-1) + init
        return val

    def _get_bfactor(self, i_shot):
        xval = self.x[self.Bfactor_xpos[i_shot]]
        PAR = self.Modelers[i_shot].PAR
        sig = PAR.B.sigma
        init = PAR.B.init
        val = sig*(xval-1) + init
        return val

    def _get_bg_vals(self, i_shot, i_spot):
        pass

    def _send_ucell_gradients_to_derivative_managers(self):
        """Needs to be called once each time the orientation is updated"""
        pass

    def _run_diffBragg_current(self):
        LOGGER.info("run diffBragg for shot %d" % self._i_shot)
        pfs = self.Modelers[self._i_shot].pan_fast_slow
        if self.use_nominal_h:
            nom_h_p1 = self.Modelers[self._i_shot].all_nominal_hkl_p1
            self.D.add_diffBragg_spots(pfs, nom_h_p1)
        else:
            self.D.add_diffBragg_spots(pfs)
        LOGGER.info("finished diffBragg for shot %d" % self._i_shot)

    def _store_updated_Fcell(self):
        if not self.refine_Fcell:
            return
        xvals = self.x[self.fcell_xstart: self.fcell_xstart+self.n_global_fcell]
        if self.rescale_params and self.log_fcells:
            sigs = self.fcell_sigmas_from_i_fcell
            inits = self.fcell_init_from_i_fcell
            if self.log_fcells:
                vals = np.exp(sigs*(xvals - 1))*inits
            else:
                vals = sigs*(xvals - 1) + inits
                vals[vals < 0] = 0
        else:
            if self.log_fcells:
                vals = np.exp(xvals)
            else:
                vals = xvals
                vals [vals < 0] = 0
        self._fcell_at_i_fcell = vals

    def _update_Fcell(self):
        if not self.refine_Fcell:
            return
        update_amps = []
        for i_fcell in range(self.n_global_fcell):
            new_Fcell_amplitude = self._fcell_at_i_fcell[i_fcell]
            update_amps += [new_Fcell_amplitude] * self.num_equivs_for_i_fcell[i_fcell]

        update_amps = flex.double(update_amps)
        self.S.D.quick_Fhkl_update((self.update_indices, update_amps))

    def _update_spectra_coefficients(self):
        pass

    def _update_eta(self):

        if self.S.umat_maker is not None:
            eta_vals = self._get_eta(self._i_shot)

            if not self.D.has_anisotropic_mosaic_spread:
                assert self.S.Umats_method == 2
                assert len(set(eta_vals))==1
                eta_vals = eta_vals[0]

            LOGGER.info("eta=%f" % eta_vals)
            self.S.update_umats_for_refinement(eta_vals)

    def _symmetrize_Flatt(self):
        if self.params.symmetrize_Flatt:
            # NOTE: RotXYZ refinement disabled for this script, so offsets always 0,0,0
            RXYZU = hopper_io.diffBragg_Umat(0,0,0,self.D.Umatrix)
            Cryst = deepcopy(self.S.crystal.dxtbx_crystal)
            B_realspace = self.get_refined_Bmatrix(self._i_shot, recip=False)
            A = RXYZU * B_realspace
            A_recip = A.inverse().transpose()
            Cryst.set_A(A_recip)
            symbol = self.S.crystal.space_group_info.type().lookup_symbol()
            self.D.set_mosaic_blocks_sym(Cryst, symbol , self.params.simulator.crystal.num_mosaicity_samples,
                                        refining_eta=False) # NOTE:no eta refinement in this stage 2 script (possible in ens.hopper)

    def _set_background_plane(self):
        self.tilt_plane = self.Modelers[self._i_shot].all_background[self.roi_sel]

    def _update_sausages(self):
        pass

    def _update_rotXYZ(self):
        pass

    def _update_ncells(self):
        vals = self._get_ncells_abc(self._i_shot)
        self.D.set_ncells_values(tuple(vals))

    def _update_ncells_def(self):
        pass

    def _update_dxtbx_detector(self):
        shiftZ = self._get_detector_distance_val(self._i_shot)
        self.S.D.shift_origin_z(self.S.detector,  shiftZ)

    def _extract_spectra_coefficient_derivatives(self):
        pass

    def _pre_extract_deriv_arrays(self):
        npix = len(self.Modelers[self._i_shot].all_data)
        self._model_pix = self.D.raw_pixels_roi[:npix].as_numpy_array()

        if self.refine_Fcell:
            dF = self.D.get_derivative_pixels(self._fcell_id)
            self._extracted_fcell_deriv = dF[:npix].as_numpy_array()
            if self.calc_curvatures:
                d2F = self.D.get_second_derivative_pixels(self._fcell_id)
                self._extracted_fcell_second_deriv = d2F[:npix].as_numpy_array()

        if self.params.refiner.refine_Nabc:
            self.dNabc = [d[:npix].as_numpy_array() for d in self.D.get_ncells_derivative_pixels()]
            if self.calc_curvatures:
                raise NotImplementedError("update the code")

    def _extract_sausage_derivs(self):
        pass

    def _extract_Umatrix_derivative_pixels(self):
        pass

    def _extract_Bmatrix_derivative_pixels(self):
        pass

    def _extract_ncells_def_derivative_pixels(self):
        pass

    def _extract_mosaic_parameter_m_derivative_pixels(self):
        pass

    def _extract_detector_distance_derivative_pixels(self):
        pass

    def _extract_panelRot_derivative_pixels(self):
        pass

    def _extract_panelXYZ_derivative_pixels(self):
        pass

    def _scale_Fcell_derivative_pixels(self):
        self.fcell_deriv = self.fcell_second_deriv = 0
        if self.refine_Fcell:
            SG = self.scale_fac
            self.fcell_deriv = SG*(self._extracted_fcell_deriv)
            # handles Nan's when Fcell is 0 for whatever reason
            if self.calc_curvatures:
                self.fcell_second_deriv = SG*self._extracted_fcell_second_deriv

    def _scale_Nabc_derivative_pixels(self):
        if self.params.refiner.refine_Nabc:
            self.dNabc = [self.scale_fac*d for d in self.dNabc]

    def _get_per_spot_scale(self, i_shot, i_spot):
        pass

    def _scale_pixel_data(self):
        #Mod = self.Modelers[self._i_shot]
        #self.Bfactor_qterm = Mod.all_q_perpix**2 / 4.
        #self._expBq = np.exp(-self.b_fac**2 * self.Bfactor_qterm)
        #self.model_bragg_spots = self._expBq*self.scale_fac*(self._model_pix)
        self.model_bragg_spots_no_gains = self.scale_fac_no_gains*self._model_pix
        self.model_bragg_spots = self.scale_fac*self._model_pix
        self._scale_Fcell_derivative_pixels()
        self._scale_Nabc_derivative_pixels()

    def _update_ucell(self):
        self.D.Bmatrix = self.Modelers[self._i_shot].PAR.Bmatrix

    def _update_umatrix(self):
        self.D.Umatrix = self.Modelers[self._i_shot].PAR.Umatrix

    def _update_beams(self):
        # sim_data instance has a nanoBragg beam object, which takes spectra and converts to nanoBragg xray_beams
        self.S.beam.spectrum = self.Modelers[self._i_shot].spectra
        self.D.xray_beams = self.S.beam.xray_beams

    def _get_panels_fasts_slows(self):
        pass

    def _set_current_gain_correction_map(self):
        self._gain_per_region = np.zeros(self.num_regions)
        for i_reg in range(self.num_regions):
            gain_x = self.x[self.regions_xstart+i_reg]
            gain = self.region_params["region%d" % i_reg].get_val(gain_x)
            self._gain_per_region[i_reg] = gain

    def compute_functional_gradients_diag(self):
        self.compute_functional_and_gradients()
        return self._f, self._g, self.d

    def compute_functional_and_gradients(self):
        t = time.time()
        out = self._compute_functional_and_gradients()
        t = time.time()-t
        LOGGER.info("Took %.4f sec to compute functional and grad" % t)
        return out

    def _compute_functional_and_gradients(self):
        LOGGER.info(Bcolors.OKBLUE+"BEGIN FUNC GRAD ; Eval %d" % self.target_eval_count+Bcolors.ENDC)
        #if self.verbose:
        #    self._print_iteration_header()

        self.target_functional = 0

        self.grad = flex.double(self.n_total_params)
        if self.calc_curvatures:
            self.curv = flex.double(self.n_total_params)

        LOGGER.info("start update Fcell")
        self._store_updated_Fcell()
        self._update_Fcell()  # update the structure factor with the new x
        LOGGER.info("done update Fcell")
        self._MPI_save_state_of_refiner()
        self._update_spectra_coefficients()  # updates the diffBragg lambda coefficients if refinining spectra

        # get the gain correction image?
        self._set_current_gain_correction_map()

        tshots = time.time()

        LOGGER.info("Iterate over %d shots" % len(self.shot_ids))
        self._shot_Zscores = []
        save_model = self.save_model_freq is not None and self.target_eval_count % self.save_model_freq == 0
        if save_model:
            self._save_model_dir = os.path.join(self.model_dir, "eval%d" % self.target_eval_count)

            if self.params.debug_mode and COMM.rank == 0 and not os.path.exists(self._save_model_dir):
                os.makedirs(self._save_model_dir)
            COMM.barrier()

        if self.target_eval_count % self.params.refiner.save_gain_freq == 0:
            self._save_optimized_gain_map()

        self.all_sigZ = []

        for self._i_shot in self.shot_ids:
            self._set_current_gain_per_pixel()
            gains = self.Modelers[self._i_shot].all_gain
            self.scale_fac_no_gains = self._get_spot_scale(self._i_shot)**2
            self.scale_fac = gains*self._get_spot_scale(self._i_shot)**2

            self.b_fac = self._get_bfactor(self._i_shot)

            # TODO: Omatrix update? All crystal models here should have the same to_primitive operation, ideally
            #LOGGER.info("update models shot %d " % self._i_shot)
            self._update_beams()
            self._update_umatrix()
            self._update_ucell()
            self._update_ncells()
            self._update_ncells_def()
            self._update_rotXYZ()
            self._update_eta()  # mosaic spread
            self._symmetrize_Flatt()
            self._update_dxtbx_detector()
            self._update_sausages()

            self._run_diffBragg_current()

            # CHECK FOR SIGNAL INTERRUPT HERE
            if self.break_signal is not None:
                signal.signal(self.break_signal, self._sig_hand.handle)
                self._MPI_check_for_break_signal()

            # TODO pre-extractions for all parameters
            self._pre_extract_deriv_arrays()
            self._scale_pixel_data()
            self._evaluate_averageI()
            self._evaluate_log_averageI_plus_sigma_readout()

            self._derivative_convenience_factors()

            if self.saveZ_freq is not None and self.target_eval_count % self.saveZ_freq == 0:
                MOD = self.Modelers[self._i_shot]
                self._spot_Zscores = []
                for i_fcell in MOD.unique_i_fcell:
                    for slc in MOD.i_fcell_slices[i_fcell]:
                        sigZ = self._Zscore[slc]
                        trus = MOD.all_trusted[slc]
                        sigZ = sigZ[trus].std()
                        self._spot_Zscores.append((i_fcell, sigZ))
                self._shot_Zscores.append(self._spot_Zscores)

            if save_model:
                MOD = self.Modelers[self._i_shot]
                P = MOD.all_pid
                F = MOD.all_fast
                S = MOD.all_slow
                #G = MOD.all_gain
                M = self.model_Lambda
                B = MOD.all_background
                D = MOD.all_data
                C = self.model_bragg_spots
                Z = self._Zscore
                iF = MOD.all_fcell_global_idx
                iROI = MOD.roi_id
                trust = MOD.all_trusted

                model_info = {"p": P, "f": F, "s": S, "model": M,
                        "background": B, "data": D, "bragg": C,
                        "Zscore": Z, "i_fcell": iF, "trust": trust,
                        "i_roi": iROI}
                self._save_model(model_info)
            self._is_trusted = self.Modelers[self._i_shot].all_trusted
            self.target_functional += self._target_accumulate()
            self._spot_scale_derivatives()
            #self._Bfactor_derivatives()
            self._accumulate_Nabc_derivatives()
            self._Fcell_derivatives()
            self._gain_region_derivatives()

            trusted = self.Modelers[self._i_shot].all_trusted
            self.all_sigZ.append(np.std(self._Zscore[trusted]))
        tshots = time.time()-tshots
        LOGGER.info("Time rank worked on shots=%.4f" % tshots)
        self._MPI_barrier()
        tmpi = time.time()
        LOGGER.info("MPI aggregation of func and grad")
        self._mpi_aggregation()
        tmpi = time.time() - tmpi
        LOGGER.info("Time for MPIaggregation=%.4f" % tmpi)

        self._gain_restraints()

        LOGGER.info("Aliases")
        self._f = self.target_functional
        self._g = self.g = self.grad
        self.d = self.curv
        LOGGER.info("curvature analysis")
        self._curvature_analysis()

        # reset ROI pixels TODO: is this necessary
        LOGGER.info("Zero pixels")
        self.D.raw_pixels_roi *= 0
        self.gnorm = -1

        tsave = time.time()
        LOGGER.info("DUMP param and Zscore data")
        self._save_Zscore_data()
        tsave = time.time()-tsave
        LOGGER.info("Time to dump param and Zscore data: %.4f" % tsave)

        self.target_eval_count += 1
        self.f_vals.append(self.target_functional)

        if self.calc_curvatures and not self.use_curvatures:
            if self.num_positive_curvatures == self.use_curvatures_threshold:
                raise BreakToUseCurvatures

        LOGGER.info("DONE WITH FUNC GRAD")
        return self._f, self._g

    def callback_after_step(self, minimizer):
        self.iterations = minimizer.iter()

    def _save_model(self, model_info):
        LOGGER.info("SAVING MODEL FOR SHOT %d" % self._i_shot)
        df = pandas.DataFrame(model_info)
        df["shot_id"] = self._i_shot
        outdir = self._save_model_dir
        outname = os.path.join(outdir, "rank%d_shot%d_EVAL%d_ITER%d.pkl" % (COMM.rank, self._i_shot, self.target_eval_count, self.iterations))
        df.to_pickle(outname)

    def _save_Zscore_data(self):
        if self.saveZ_freq is None or not self.target_eval_count % self.saveZ_freq == 0:
            return
        outdir = os.path.join(self.Zdir, "rank%d_Zscore" % self.rank)
        if not os.path.exists(outdir):
            os.makedirs(outdir)
        fname = os.path.join(outdir, "sigZ_eval%d_iter%d_rank%d" % (self.target_eval_count, self.iterations, self.rank))
        np.save(fname, np.array(self._shot_Zscores, object))

    def _sanity_check_grad(self):
        pass

    def _gain_region_derivatives(self):
        if not self.params.refiner.refine_gain_map:
            return
        MOD = self.Modelers[self._i_shot]

        #dL_dG = 0.5*self.one_over_v* (MOD.all_background + 2*self.u*(MOD.all_data-MOD.all_background) - \
        #    self.u*self.u*MOD.all_background*self.one_over_v)
        dL_dG = 0.5*self.model_bragg_spots_no_gains*self.common_grad_term
        dL_dG /= MOD.all_freq

        reg_grad = np.zeros(self.num_regions)
        np.add.at(reg_grad, MOD._gain_region_per_pixel[MOD.all_trusted], dL_dG[MOD.all_trusted])

        #u_reg = set(MOD._gain_region_per_pixel)
        for i_reg in MOD._unique_gain_regions:
            xpos = self.regions_xstart+i_reg
            gain_x = self.x[xpos]
            d = self.region_params["region%d"%i_reg].get_deriv(gain_x, reg_grad[i_reg])
            self.grad[xpos] += d
        #self.grad[self.regions_xstart:self.regions_xstart+self.num_regions] += reg_grad

    def _Fcell_derivatives(self):
        if not self.refine_Fcell:
            return
        MOD = self.Modelers[self._i_shot]
        dumps = []
        for i_fcell in MOD.unique_i_fcell:

            multi = self.hkl_frequency[i_fcell]
            if multi < self.min_multiplicity:
                continue

            xpos = self.fcell_xstart + i_fcell
            Famp = self._fcell_at_i_fcell[i_fcell]
            sig = 1

            for slc in MOD.i_fcell_slices[i_fcell]:
                self.fcell_dI_dtheta = self.fcell_deriv[slc]

                if self.log_fcells:
                    # case 2 rescaling
                    sig_times_fcell = sig*Famp
                    d = sig_times_fcell*self.fcell_dI_dtheta
                else:
                    # case 1 rescaling
                    d = sig*self.fcell_dI_dtheta

                gterm = self.common_grad_term[slc]
                g_accum = d*gterm
                trust = MOD.all_trusted[slc]
                # NOTE : no need to normalize Fhkl gradients by the overlap rate - they should arise from different HKLs
                #freq = MOD.all_freq[slc]  # pixel frequency (1 is no overlaps)
                dump = (g_accum[trust].sum())*.5
                self.grad[xpos] += dump
                dumps.append(dump)
                if self.calc_curvatures:
                    raise NotImplementedError("No curvature for Fcell refinement")

    def _accumulate_Nabc_derivatives(self):
        if not self.params.refiner.refine_Nabc:
            return
        Mod = self.Modelers[self._i_shot]
        for i_n in range(3):
            p = Mod.PAR.Nabc[i_n]
            d = p.get_deriv(self.x[p.xpos],  self.dNabc[i_n])
            self.grad[p.xpos] += self._grad_accumulate(d)

    def _spot_scale_derivatives(self, return_derivatives=False):
        if not self.refine_crystal_scale:
            return
        S = np.sqrt(self.scale_fac_no_gains)
        dI_dtheta = (2./S)*self.model_bragg_spots
        d2I_dtheta2 = (2./S/S)*self.model_bragg_spots
        # second derivative is 0 with respect to scale factor
        sig = self.Modelers[self._i_shot].PAR.Scale.sigma
        d = dI_dtheta*sig
        d2 = d2I_dtheta2 *(sig**2)

        xpos = self.spot_scale_xpos[self._i_shot]
        self.grad[xpos] += self._grad_accumulate(d)
        if self.calc_curvatures:
            self.curv[xpos] += self._curv_accumulate(d, d2)

        if return_derivatives:
            return d, d2

    def _Bfactor_derivatives(self):
        LOGGER.info("derivatives of Bfactors for shot %d: current B=%e Ang^2" % (self._i_shot, self.b_fac**2))
        if self.params.fix.B:
            return
        dI_dtheta = -.5*self.model_bragg_spots*self.Bfactor_qterm * self.b_fac
        d2I_dtheta2 = 0 #-.5*self.model_bragg_spots*self.Bfactor_qterm
        # second derivative is 0 with respect to scale factor
        sig = self.Modelers[self._i_shot].PAR.B.sigma
        d = dI_dtheta*sig
        d2 = d2I_dtheta2*(sig**2)

        xpos = self.Bfactor_xpos[self._i_shot]
        self.grad[xpos] += self._grad_accumulate(d)
        if self.calc_curvatures:
            self.curv[xpos] += self._curv_accumulate(d, d2)

    def _mpi_aggregation(self):
        # reduce the broadcast summed results:
        LOGGER.info("aggregate barrier")
        self._MPI_barrier()
        LOGGER.info("Functional")
        self.target_functional = self._MPI_reduce_broadcast(self.target_functional)
        LOGGER.info("gradients")
        self.grad = self._MPI_reduce_broadcast(self.grad)
        if self.calc_curvatures:
            self.curv = self._MPI_reduce_broadcast(self.curv)
        all_sigZ = COMM.reduce(self.all_sigZ)
        if COMM.rank==0:
            LOGGER.info("F=%10.7e, sigmaZ: mean=%f, median=%f" % (self.target_functional, np.mean(all_sigZ), np.median(all_sigZ) ))

    def _curvature_analysis(self):
        self.tot_neg_curv = 0
        self.neg_curv_shots = []
        if self.calc_curvatures:
            self.is_negative_curvature = self.curv.as_numpy_array() < 0
            self.tot_neg_curv = sum(self.is_negative_curvature)

        if self.calc_curvatures and not self.use_curvatures:
            if self.tot_neg_curv == 0:
                self.num_positive_curvatures += 1
                self.d = self.curv
                self._verify_diag()
            else:
                self.num_positive_curvatures = 0
                self.d = None

        if self.use_curvatures:
            assert self.tot_neg_curv == 0
            self.request_diag_once = False
            self.diag_mode = "always"  # TODO is this proper place to set ?
            self.d = self.curv
            self._verify_diag()
        else:
            self.d = None

    def _get_refinement_string_label(self):
        refine_str = "refining "
        if self.refine_Fcell:
            refine_str += "fcell, "
        if self.refine_ncells:
            refine_str += "Ncells, "
        if self.refine_ncells_def:
            refine_str += "Ncells_def, "
        if self.refine_Bmatrix:
            refine_str += "Bmat, "
        if self.refine_Umatrix:
            refine_str += "Umat, "
        if self.refine_crystal_scale:
            refine_str += "scale, "
        if self.refine_background_planes:
            refine_str += "bkgrnd, "
        if self.refine_detdist:
            refine_str += "detector_distance, "
        if self.refine_panelRotO:
            refine_str += "panelRotO, "
        if self.refine_panelRotF:
            refine_str += "panelRotF, "
        if self.refine_panelRotS:
            refine_str += "panelRotS, "
        if self.refine_panelXY:
            refine_str += "panelXY, "
        if self.refine_panelZ:
            refine_str += "panelZ, "
        if self.refine_lambda0:
            refine_str += "Lambda0 (offset), "
        if self.refine_lambda1:
            refine_str += "Lambda1 (scale), "
        if self.refine_per_spot_scale:
            refine_str += "Per-spot scales, "
        if self.refine_eta:
            refine_str += "Eta, "
        if self.refine_blueSausages:
            refine_str += "Mosaic texture, "
        return refine_str

    def _print_iteration_header(self):
        refine_str = self._get_refinement_string_label()
        border = "<><><><><><><><><><><><><><><><>"
        if self.use_curvatures:

            LOGGER.info(
                "%s%s%s%s\nTrial%d (%s): Compute functional and gradients eval %d %s(Using Curvatures)%s\n%s%s%s%s"
                % (Bcolors.HEADER, border,border,border, self.trial_id + 1, refine_str, self.target_eval_count + 1, Bcolors.OKGREEN, Bcolors.HEADER, border,border,border, Bcolors.ENDC))
        else:
            LOGGER.info("%s%s%s%s\n, Trial%d (%s): Compute functional and gradients eval %d PosCurva %d\n%s%s%s%s"
                  % (Bcolors.HEADER, border, border, border, self.trial_id + 1, refine_str, self.target_eval_count + 1, self.num_positive_curvatures, border, border,border, Bcolors.ENDC))

    def _save_optimized_gain_map(self):
        if not self.params.refiner.refine_gain_map:
            return
        if self.I_AM_ROOT and self.output_dir is not None:
            outf = os.path.join(self.output_dir, "gain_map" )
            LOGGER.info(Bcolors.WARNING+"Saving detector gain map!"+Bcolors.ENDC)
            np.savez(outf, gain_per_region=self._gain_per_region, region_shape=self.params.refiner.region_size,
                     det_shape=self.REGIONS.shape, adu_per_photon=self.params.refiner.adu_per_photon,
                     regions=self.REGIONS,
                     num_times_pixel_was_modeled=self.pixel_was_modeled,
                     num_times_region_was_modeled=self.region_was_modeled)
            LOGGER.info("Done Saving detector gain map!")

    def _MPI_save_state_of_refiner(self):
        if self.I_AM_ROOT and self.output_dir is not None and self.refine_Fcell:
            outf = os.path.join(self.output_dir, "_fcell_trial%d_eval%d_iter%d" % (self.trial_id, self.target_eval_count, self.iterations))
            np.savez(outf, fvals=self._fcell_at_i_fcell)

    def _target_accumulate(self):
        fterm = self.log2pi + self.log_v + self.u*self.u*self.one_over_v
        M = self.Modelers[self._i_shot]
        fterm /= M.all_freq
        if self._is_trusted is not None:
            fterm = fterm[self._is_trusted]
        fterm = 0.5*(fterm.sum())
        return fterm

    def _grad_accumulate(self, d):
        gterm = d * self.one_over_v * self.one_minus_2u_minus_u_squared_over_v
        M = self.Modelers[self._i_shot]
        gterm /= M.all_freq
        if self._is_trusted is not None:
            gterm = gterm[self._is_trusted]
        gterm = 0.5*gterm.sum()
        return gterm

    def _curv_accumulate(self, d, d2):
        cterm = self.one_over_v * (d2*self.one_minus_2u_minus_u_squared_over_v -
                                   d*d*(self.one_over_v_times_one_minus_2u_minus_u_squared_over_v -
                                        (2 + 2*self.u_times_one_over_v + self.u_u_one_over_v*self.one_over_v)))
        if self._is_trusted is not None:
            cterm = cterm[self._is_trusted]
        cterm = .5 * (cterm.sum())
        return cterm

    def _derivative_convenience_factors(self):
        Mod = self.Modelers[self._i_shot]
        self.u = Mod.all_data - self.model_Lambda
        self.one_over_v = 1. / (self.model_Lambda + Mod.nominal_sigma_rdout ** 2)
        self.one_minus_2u_minus_u_squared_over_v = 1 - 2 * self.u - self.u * self.u * self.one_over_v
        if self.calc_curvatures:
            self.u_times_one_over_v = self.u*self.one_over_v
            self.u_u_one_over_v = self.u*self.u_times_one_over_v
            self.one_over_v_times_one_minus_2u_minus_u_squared_over_v = self.one_over_v*self.one_minus_2u_minus_u_squared_over_v
        self.common_grad_term = self.one_over_v * self.one_minus_2u_minus_u_squared_over_v
        self._Zscore = self.u*np.sqrt(self.one_over_v)

    def _evaluate_log_averageI(self):  # for Poisson only stats
        try:
            self.log_Lambda = np.log(self.model_Lambda)
        except FloatingPointError:
            pass
        neg_lam = self.model_Lambda <=0
        M = self.Modelers[self._i_shot]
        if any(neg_lam[M.all_trusted].ravel()):
            self.log_Lambda[neg_lam] = 1e-6
            LOGGER.warning(Bcolors.WARNING+("NEGATIVE INTENSITY IN MODEL (negative_models=%d)!" % self.num_negative_model) + Bcolors.ENDC)
        #    raise ValueError("model of Bragg spots cannot have negative intensities...")
        self.log_Lambda[neg_lam] = 0

    def _evaluate_log_averageI_plus_sigma_readout(self):
        Mod = self.Modelers[self._i_shot]
        v = self.model_Lambda + Mod.nominal_sigma_rdout ** 2
        v_is_neg = (v <= 0).ravel()
        if any(v_is_neg[Mod.all_trusted]):
            LOGGER.warning(Bcolors.WARNING+"NEGATIVE INTENSITY IN MODEL!"+Bcolors.ENDC)
        #    raise ValueError("model of Bragg spots cannot have negative intensities...")
        self.log_v = np.log(v)
        self.log_v[v <= 0] = 0  # but will I ever negative_model ?

    def get_refined_Bmatrix(self, i_shot, recip=False):
        if recip:
            return self.Modelers[i_shot].PAR.ucell_man.B_recipspace
        else:
            return self.Modelers[i_shot].PAR.ucell_man.B_realspace

    def curvatures(self):
        return self.curv

    def _MPI_sync_hkl_freq(self):
            if self.refine_Fcell:
                if self.rank != 0:
                    self.hkl_frequency = None
                self.hkl_frequency = COMM.bcast(self.hkl_frequency)

    def _MPI_sync_fcell_parameters(self):
        if not self.I_AM_ROOT:
            self.sigma_for_res_id = None
            self.res_group_id_from_fcell_index = None
            self.resolution_ids_from_i_fcell = self.fcell_sigmas_from_i_fcell = self.fcell_init_from_i_fcell = None

        if self.rescale_params:
            if self.refine_Fcell:
                self.fcell_sigmas_from_i_fcell = COMM.bcast(self.fcell_sigmas_from_i_fcell)
                self.fcell_init_from_i_fcell = COMM.bcast(self.fcell_init_from_i_fcell)

    def _MPI_sync_panel_params(self):
        if not self.I_AM_ROOT:
            self.panelRot_params = None
            self.panelX_params = None
            self.panelY_params = None
            self.panelZ_params = None
        self.panelRot_params = COMM.bcast(self.panelRot_params)
        self.panelX_params = COMM.bcast(self.panelX_params)
        self.panelY_params = COMM.bcast(self.panelY_params)
        self.panelZ_params = COMM.bcast(self.panelZ_params)

    def _MPI_reduce_broadcast(self, var):
        var = COMM.reduce(var, MPI.SUM, root=0)
        var = COMM.bcast(var, root=0)
        return var

    def _MPI_barrier(self):
        COMM.barrier()


 *******************************************************************************


 *******************************************************************************
simtbx/diffBragg/stage_two_utils.py
from __future__ import division

import numpy as np
from simtbx.diffBragg import utils
from scitbx.matrix import sqr
from simtbx.diffBragg.refiners.parameters import RangedParameter
from simtbx.nanoBragg.utils import H5AttributeGeomWriter
from simtbx.diffBragg import hopper_utils


def create_gain_map(gain_map_file, expt=None, outname=None, convert_to_photons=True):
    """
    :param gain_map_file: output from stage_two_refiner, contains info for constructing the optimized gain map
    :param expt: optional, apply the gain correction to an image in the experiment imageset, and writes an
    image file to disk containint before/after images, as well as the correction itself
    :param outname: the output file name, if expt is provided
    :param convert_to_photons: bool, usually expt's contain data that are in ADU units,
    however the optimized gain map was determined against data in photon units. Only set this to False if the expt points to
    data that are in photon units
    :return: gain map as a numpy array, same shape as tye detector
    """
    gain_data = np.load(gain_map_file)
    region_shape = tuple(gain_data["region_shape"])
    det_shape = tuple(gain_data["det_shape"])
    gain_per_region = gain_data["gain_per_region"]
    adu_per_photon = gain_data["adu_per_photon"]
    gain_map = regionize_detector(det_shape, region_shape, gain_per_region)
    region_marker = gain_data["num_times_region_was_modeled"][()]
    ntimes = gain_data["num_times_pixel_was_modeled"][()]
    mask = ntimes > 0
    region_marker = regionize_detector(det_shape, region_shape, region_marker) #.astype(np.int))
    region_marker = region_marker > 0
    if expt is not None:
        assert outname is not None
        iset = expt.imageset
        data = np.array([a.as_numpy_array() for a in iset.get_raw_data(0)])
        if convert_to_photons:
            data /= adu_per_photon
        with H5AttributeGeomWriter(outname, det_shape, 5, detector=expt.detector, beam=expt.beam) as writer:
            writer.add_image(data)
            writer.add_image(data*gain_map)
            writer.add_image(gain_map)
            writer.add_image(gain_data["regions"])
            writer.add_image(ntimes)
        maskname = outname+".mask"
        utils.save_numpy_mask_as_flex(region_marker, maskname)
        maskname2 = outname+".mask2"
        utils.save_numpy_mask_as_flex(mask, maskname2)
        print("Wrote %s and %s and %s, open with dials.image_viewer" %(outname, maskname, maskname2))

    vals = gain_map[region_marker]
    print(np.mean(vals), np.std(vals), np.min(vals), np.max(vals))
    return gain_map


def regionize_detector(det_shape, region_shape, gain_map_values=None):
    """
    Create a 3-d numpy array (shaped after a multi panel detector)
    where each pixel corresponds to a unique region of shape `region_shape`
    :param det_shape: 3 tuple, shape of the detecor (num_panels, slow_dim, fast_dim)
    :param region_shape: 2 tuple, the desired shape of each region in pixels (nslow, nfast)
    :param gain_map_values: array of gains for each region (advanced usage, one would never use this directly)
    :return: 3-d numpy array of regions
    """
    Y,X = region_shape
    regions = np.zeros(det_shape)
    if gain_map_values is None:
        regions = regions.astype(np.int32)
    numPan, slowDim, fastDim = det_shape
    nx = np.array_split(np.arange(fastDim),int(fastDim/X)+1)
    ny = np.array_split(np.arange(slowDim),int(slowDim/Y)+1)
    i_region = 0
    for pid in range(numPan):
        for j in range(len(ny)):
            for i in range(len(nx)):
                istart = nx[i][0]
                istop = nx[i][-1]+1
                jstart = ny[j][0]
                jstop = ny[j][-1]+1
                if gain_map_values is not None:
                    regions[pid,jstart:jstop, istart:istop] = gain_map_values[i_region]
                else:
                    regions[pid, jstart:jstop, istart:istop] = i_region
                i_region += 1
    return regions


def PAR_from_params(params, experiment, best=None):
    """

    :param params:  diffBragg params phil
    :param experiment: dxtbx Experiment list
    :param best: optional row of the stage 1 pandas dataframe corresponding to the experiment list
                This would contain all of the model parameters from stage 1
    :return: PAR object for storing refinement parameters
    """
    ParameterType = RangedParameter
    PAR = StageTwoParams()

    # each modeler has an experiment self.E, with a crystal attached
    if best is not None:
        experiment.crystal.set_A(best.Amats.values[0])
    PAR.Umatrix = sqr(experiment.crystal.get_U())
    PAR.Bmatrix = sqr(experiment.crystal.get_B())

    # per shot Scale factor
    initG = params.init.G if best is None else best.spot_scales.values[0]
    #TODO reconcile the need to sqrt the gain for stage_two_refiner
    PAR.Scale = ParameterType(init=initG, minval=params.mins.G, maxval=params.maxs.G, fix=params.fix.G, sigma=params.sigmas.G,
                              center=params.centers.G, beta=params.betas.G)

    PAR.Nabc = [None]*3
    PAR.Ndef = [None]*3
    PAR.eta = [None]*3
    PAR.RotXYZ_params = [None]*3
    PAR.diffuse_sigma = [None]*3
    PAR.diffuse_gamma = [None]*3

    eta_min = params.mins.eta_abc
    init_eta = params.init.eta_abc if best is None else best.eta_abc.values[0]
    if tuple(init_eta) == (0,0,0):
        eta_min=-1e-10,-1e-10,-1e-10
        if not params.simulator.crystal.num_mosaicity_samples == 1:
            raise ValueError("if all eta_abc are 0,0,0, num_mosaicity_samples should be 1")

    # TODO allow setting diffuse gamma/sigma from stage 1 (e.g. from the `best` dataframe)
    init_diffuse_sigma = params.init.diffuse_sigma
    init_diffuse_gamma = params.init.diffuse_gamma

    for i in range(3):
        initN = params.init.Nabc[i] if best is None else best.ncells.values[0][i]
        PAR.Nabc[i] = ParameterType(init=initN, minval=params.mins.Nabc[i],
                                    maxval=params.maxs.Nabc[i], fix=params.fix.Nabc, sigma=params.sigmas.Nabc[i],
                                    center=params.centers.Nabc[i] if params.centers.Nabc is not None else None,
                                    beta=params.betas.Nabc[i] if params.betas.Nabc is not None else None)

        initN = params.init.Ndef[i] if best is None else best.ncells_def.values[0][i]
        PAR.Ndef[i] = ParameterType(init=initN, minval=params.mins.Ndef[i],
                                    maxval=params.maxs.Ndef[i], fix=params.fix.Ndef, sigma=params.sigmas.Ndef[i],
                                    center=params.centers.Ndef[i] if params.centers.Ndef is not None else None,
                                    beta=params.betas.Ndef[i] if params.betas.Ndef is not None else None)

        PAR.RotXYZ_params[i] = ParameterType(init=0, minval=params.mins.RotXYZ[i],
                                            maxval=params.maxs.RotXYZ[i], fix=params.fix.RotXYZ,
                                            sigma=params.sigmas.RotXYZ[i],
                                            center=0 if params.betas.RotXYZ is not None else None, beta=params.betas.RotXYZ)

        PAR.eta[i] = ParameterType(init=init_eta[i], minval=eta_min[i],
                                       maxval=params.maxs.eta_abc[i], fix=params.fix.eta_abc,
                                       sigma=params.sigmas.eta_abc[i],
                                       center=params.betas.eta_abc[i] if params.centers.eta_abc is not None else None,
                                   beta=params.betas.eta_abc[i] if params.betas.eta_abc is not None else None)

        # TODO: diffuse scattering terms
        PAR.diffuse_sigma[i] = ParameterType(init=init_diffuse_sigma[i], minval=params.mins.diffuse_sigma[i],
                                        maxval=params.maxs.diffuse_sigma[i], fix=params.fix.diffuse_sigma,
                                        sigma=params.sigmas.diffuse_sigma[i],
                                        center=params.centers.diffuse_sigma[i] if params.centers.diffuse_sigma is not None else None,
                                             beta=params.betas.diffuse_sigma[i] if params.betas.diffuse_sigma is not None else None)

        PAR.diffuse_gamma[i] = ParameterType(init=init_diffuse_gamma[i], minval=params.mins.diffuse_gamma[i],
                                             maxval=params.maxs.diffuse_gamma[i], fix=params.fix.diffuse_gamma,
                                             sigma=params.sigmas.diffuse_gamma[i],
                                             center=params.centers.diffuse_gamma[i] if params.centers.diffuse_gamma is not None else None,
                                             beta=params.betas.diffuse_gamma[i] if params.betas.diffuse_gamma is not None else None)

    # unit cell parameters
    ucell_man = utils.manager_from_crystal(experiment.crystal)  # Note ucell man contains the best parameters (if best is not None)
    ucell_vary_perc = params.ucell_edge_perc / 100.
    PAR.ucell = []
    for i_uc, (name, val) in enumerate(zip(ucell_man.variable_names, ucell_man.variables)):
        if "Ang" in name:
            minval = val - ucell_vary_perc * val
            maxval = val + ucell_vary_perc * val
            if name == 'a_Ang':
                cent = params.centers.ucell_a
                beta = params.betas.ucell_a
            elif name == 'b_Ang':
                cent = params.centers.ucell_b
                beta = params.betas.ucell_b
            else:
                cent = params.centers.ucell_c
                beta = params.betas.ucell_c
        else:
            val_in_deg = val * 180 / np.pi
            minval = (val_in_deg - params.ucell_ang_abs) * np.pi / 180.
            maxval = (val_in_deg + params.ucell_ang_abs) * np.pi / 180.
            if name == 'alpha_rad':
                cent = params.centers.ucell_alpha
                beta = params.betas.ucell_alpha
            elif name == 'beta_rad':
                cent = params.centers.ucell_beta
                beta = params.betas.ucell_beta
            else:
                cent = params.centers.ucell_gamma
                beta = params.betas.ucell_gamma
            assert cent is not None
            assert beta is not None
            cent = cent * np.pi / 180.

        p = ParameterType(init=val, minval=minval, maxval=maxval, fix=params.fix.ucell, sigma=params.sigmas.ucell[i_uc],
                          center=cent, beta=beta)
        PAR.ucell.append(p)
    PAR.ucell_man = ucell_man

    # detector distance param:
    init_shiftZ = params.init.detz_shift *1e-3  if best is None else best.detz_shift_mm.values[0]*1e-3
    PAR.detz_shift = ParameterType(init=init_shiftZ, sigma=params.sigmas.detz_shift, minval=params.mins.detz_shift*1e-3,
                                   maxval=params.maxs.detz_shift*1e-3, fix=params.fix.detz_shift,
                                   center=params.centers.detz_shift, beta=params.betas.detz_shift)

    PAR.B = ParameterType(init=params.init.B, sigma=params.sigmas.B, minval=params.mins.B, maxval=params.maxs.B, fix=True,
                          center=params.centers.B, beta=params.betas.B)

    lam0, lam1 = params.init.spec
    if best is not None:
        lam0, lam1 = hopper_utils.get_lam0_lam1_from_pandas(best)
    PAR.spec_coef = []
    for i_p, init_val in enumerate((lam0, lam1)):
        p = ParameterType(init=init_val, sigma=params.sigmas.spec[i_p],
                          center=params.centers.spec[i_p] if params.centers.spec is not None else None,
                          beta=params.betas.spec[i_p] if params.betas.spec is not None else None,
                          fix=params.fix.spec,
                          minval=params.mins.spec[i_p], maxval=params.maxs.spec[i_p])
        PAR.spec_coef.append(p)

    return PAR


class StageTwoParams:
    def __init__(self):
        self.ucell = None
        self.RotXYZ = None
        self.Scale = None
        self.Nabc = None
        self.Ndef = None
        self.eta = None
        self.spec_coef = None
        self.Fhkl = None
        self.detz_shift = None
        self.paneRot = None
        self.PanXYZ = None
        self.diffuse_sigma = None
        self.diffuse_gamma = None


 *******************************************************************************


 *******************************************************************************
simtbx/diffBragg/tests/tst_diffBragg_Fcell_deriv.py
from __future__ import division
##from simtbx.kokkos import gpu_instance
#kokkos_run = gpu_instance(deviceId = 0)

from argparse import ArgumentParser
parser = ArgumentParser()
parser.add_argument("--kokkos", action="store_true")
parser.add_argument("--plot", action='store_true')
parser.add_argument("--curvatures", action='store_true')
args = parser.parse_args()
if args.kokkos:
    import os
    os.environ["DIFFBRAGG_USE_KOKKOS"]="1"
from simtbx.diffBragg.utils import find_diffBragg_instances
from simtbx.diffBragg.device import DeviceWrapper
with DeviceWrapper(0) as _:

    if args.plot:
        import pylab as plt
        plt.figure()
    import numpy as np
    from scipy.spatial.transform import Rotation
    from scipy.stats import linregress

    from scitbx.array_family import flex
    from scitbx.matrix import sqr
    from scitbx.matrix import rec

    from simtbx.nanoBragg.nanoBragg_crystal import NBcrystal
    from cctbx import uctbx
    from simtbx.nanoBragg.sim_data import SimData
    from dxtbx.model.crystal import Crystal

    ucell = (70, 60, 50, 90.0, 110, 90.0)
    symbol = "C121"

    a_real, b_real, c_real = sqr(uctbx.unit_cell(ucell).orthogonalization_matrix()).transpose().as_list_of_lists()
    C = Crystal(a_real, b_real, c_real, symbol)

    # random raotation
    rotation = Rotation.random(num=1, random_state=101)[0]
    Q = rec(rotation.as_quat(), n=(4, 1))
    rot_ang, rot_axis = Q.unit_quaternion_as_axis_and_angle()
    C.rotate_around_origin(rot_axis, rot_ang)

    # make a nanoBragg crystal to pass to diffBragg
    nbcryst = NBcrystal(init_defaults=True)
    nbcryst.dxtbx_crystal = C
    nbcryst.n_mos_domains = 1
    nbcryst.thick_mm = 0.01
    nbcryst.Ncells_abc = (7, 7, 7)

    # make an instance of diffBRagg, use the simData wrapper
    SIM = SimData(use_default_crystal=True)
    # overwrite the default detector with a smaller pixels one
    SIM.detector = SimData.simple_detector(300, 0.1, (700, 700))
    SIM.crystal = nbcryst
    Fcell = 1e6
    SIM.instantiate_diffBragg(oversample=0, verbose=0, interpolate=0, default_F=Fcell)
    # D is an instance of diffBragg with reasonable parameters
    # and our dxtbx crystal created above
    D = SIM.D

    D.progress_meter = True

    # initialize the derivative manager for Fcell
    fcell = 11  # internal index of fcell manager within diffBragg
    D.refine(fcell)
    D.initialize_managers()

    #roi = ((0, 699), (0, 699))
    #rX = slice(roi[0][0], roi[0][1], 1)
    #rY = slice(roi[1][0], roi[1][1], 1)
    #D.region_of_interest = roi

    # compute the scattering and its derivative
    print("Adding diffBragg spots")
    # Set all miller indices to have the same Fcell value
    indices, data = D.Fhkl_tuple
    data = flex.double(np.ones(len(indices))*Fcell)
    D.F000 = Fcell
    D.Fhkl_tuple = indices, data.deep_copy(), None
    D.compute_curvatures = True

    # NOTE optionally focus on a single Bragg peak
    #x1,x2 = 335, 365
    #y1,y2 = 155, 185
    #D.region_of_interest = (x1, x2), (y1, y2)
    D.add_diffBragg_spots()

    print("Done!")
    img = D.raw_pixels_roi.as_numpy_array()

    # reset all pixel values
    D.raw_pixels *= 0
    D.raw_pixels_roi *= 0
    first_deriv = D.get_derivative_pixels(fcell).as_numpy_array()
    if args.curvatures:
        second_deriv = D.get_second_derivative_pixels(fcell).as_numpy_array()

    # iterate over the parameters and do a finite difference test for each one
    shifts = [1e-2*(i**2) for i in range(1, 20)]
    #shifts = np.array([.5,1,2,4,8,16,32]) # 1e-3, 1e-2, 1e-1, 1, 10]
    all_error = []
    all_delta_F = []

    for i_shift, percent_shift in enumerate(shifts):

        delta_F = Fcell * percent_shift*1e-2

        D.F000 = Fcell + delta_F
        D.Fhkl_tuple = indices, data.deep_copy()+delta_F, None
        D.default_F = Fcell+delta_F
        D.add_diffBragg_spots()

        img_forward = D.raw_pixels_roi.as_numpy_array()
        # reset for next computation
        D.raw_pixels_roi *= 0
        D.raw_pixels *= 0

        finite_deriv = (img_forward-img) / delta_F
        ave_error = np.abs(finite_deriv - first_deriv).mean()
        #ave_error = np.abs(finite_deriv[bragg] - first_deriv[bragg]).mean()
        all_error.append(ave_error)
        all_delta_F.append(delta_F)

        if args.curvatures:
            # estimate the second derivative
            D.F000 = Fcell - delta_F
            D.Fhkl_tuple = indices, data.deep_copy() - delta_F, None
            D.default_F = Fcell - delta_F
            D.add_diffBragg_spots()
            img_backward = D.raw_pixels_roi.as_numpy_array()

            # reset for next computation
            D.raw_pixels_roi *= 0
            D.raw_pixels *= 0

            finite_second_deriv = (img_forward - 2*img + img_backward) / delta_F / delta_F
            assert np.allclose(finite_second_deriv, second_deriv)
            # NOTE: second derivative is a constant, doesnt depend on F_cell, hence these are always super close

        print("error=%2.7g, step=%f (%d/%d)" % (ave_error, delta_F, i_shift + 1, len(shifts)))

    if args.plot:
        plt.close()
        plt.plot(all_delta_F, all_error, 'o')
        plt.show()

    # one expects errors to scale linearly with parameter shift for finite differences
    l = linregress(all_delta_F, all_error)
    assert l.rvalue > .9999  # this is definitely a line!
    assert l.slope > 0
    assert l.pvalue < 1e-6
    assert l.intercept < 0.1*l.slope # line should go through origin
    print("Error versus parameter shift fits a line with slope=%2.7g and Correleation Coef=%2.7g" % (l.slope, l.rvalue))
    print("OK!")
    for name in find_diffBragg_instances(globals()): del globals()[name]


 *******************************************************************************


 *******************************************************************************
simtbx/diffBragg/tests/tst_diffBragg_Fhkl_complex.py
from __future__ import division
#from simtbx.kokkos import gpu_instance
#kokkos_run = gpu_instance(deviceId = 0)

from simtbx.nanoBragg.nanoBragg_crystal import NBcrystal
from dxtbx.model import Crystal
from simtbx.diffBragg.utils import  fcalc_from_pdb

import sys
if "--kokkos" in sys.argv:
    import os
    os.environ["DIFFBRAGG_USE_KOKKOS"]="1"

from simtbx.diffBragg.utils import find_diffBragg_instances
from simtbx.diffBragg.device import DeviceWrapper
with DeviceWrapper(0) as _:

    Fcomplex = fcalc_from_pdb(resolution=2, wavelength=1, algorithm='fft', ucell=(79,79,38.90,90,90), symbol="P43212",as_amplitudes=False)
    Famp = fcalc_from_pdb(resolution=2, wavelength=1, algorithm='fft', ucell=(79,79,38.90,90,90), symbol="P43212",as_amplitudes=True)

    def sim_spots(F):

        a_real = (79,0,0)
        b_real = (0,79,0)
        c_real = (0,0,38)
        C = Crystal(a_real, b_real, c_real, 'P43212')

        nbcryst = NBcrystal(init_defaults=True)
        nbcryst.dxtbx_crystal = C  # simulate ground truth
        nbcryst.thick_mm = 0.1
        nbcryst.Ncells_abc = 10,10,10

        nbcryst.miller_array = F
        print("Ground truth ncells = %f" % (nbcryst.Ncells_abc[0]))

        # ground truth detector
        from simtbx.nanoBragg.sim_data import SimData
        DET_gt = SimData.simple_detector(150, 0.177, (600, 600))

        # initialize the simulator
        SIM = SimData(use_default_crystal=True)
        SIM.detector = DET_gt
        SIM.crystal = nbcryst
        SIM.instantiate_diffBragg(oversample=0)
        SIM.D.default_F = 0
        SIM.D.progress_meter = False
        SIM.D.add_diffBragg_spots()
        SIM.D.F000 = 0
        SPOTS = SIM.D.raw_pixels.as_numpy_array()
        SIM.D.free_all()
        SIM.D.free_Fhkl2()
        return SPOTS

    A = sim_spots(Fcomplex)
    B = sim_spots(Famp)
    import numpy as np
    assert np.allclose(A,B)
    print("OK!")
    for name in find_diffBragg_instances(globals()): del globals()[name]


 *******************************************************************************


 *******************************************************************************
simtbx/diffBragg/tests/tst_diffBragg_change_of_basis.py
from __future__ import division
##from simtbx.kokkos import gpu_instance
#kokkos_run = gpu_instance(deviceId = 0)

from simtbx.nanoBragg import sim_data
from scitbx.matrix import sqr
from cctbx import uctbx
from dxtbx.model import Crystal

from simtbx.nanoBragg.nanoBragg_crystal import NBcrystal
import numpy as np
import sys
if "--kokkos" in sys.argv:
    import os
    os.environ["DIFFBRAGG_USE_KOKKOS"]="1"
from simtbx.diffBragg.utils import find_diffBragg_instances
from simtbx.diffBragg.device import DeviceWrapper
with DeviceWrapper(0) as _:
    ucell = (70, 60, 50, 90.0, 110, 90.0)
    symbol = "C121"
    a_real, b_real, c_real = sqr(uctbx.unit_cell(ucell).orthogonalization_matrix()).transpose().as_list_of_lists()
    C = Crystal(a_real, b_real, c_real, symbol)

    nbr = NBcrystal()
    nbr.dxtbx_crystal = C

    S = sim_data.SimData(use_default_crystal=True)
    S.crystal = nbr
    S.instantiate_diffBragg(auto_set_spotscale=True)
    S.D.add_diffBragg_spots()
    img = S.D.raw_pixels.as_numpy_array()

    # simulate the primitive cell directly
    to_p1 = C.get_space_group().info().change_of_basis_op_to_primitive_setting()
    Cp1 = C.change_basis(to_p1)
    nbr2 = NBcrystal()
    nbr2.dxtbx_crystal = Cp1

    S2 = sim_data.SimData()
    S2.crystal = nbr2
    S2.instantiate_diffBragg(auto_set_spotscale=True)
    S2.D.add_diffBragg_spots()
    img2 = S2.D.raw_pixels.as_numpy_array()

    # rescale because currently volume is computed incorrectly
    img2 = img2 * S.D.spot_scale / S2.D.spot_scale

    assert S.D.Omatrix == tuple(to_p1.c_inv().r().transpose().as_double())
    assert S2.D.Omatrix == (1, 0, 0, 0, 1, 0, 0, 0, 1)
    assert np.allclose(img, img2)

    print("OK")
    for name in find_diffBragg_instances(globals()): del globals()[name]


 *******************************************************************************


 *******************************************************************************
simtbx/diffBragg/tests/tst_diffBragg_deriv_rois.py
from __future__ import division
##from simtbx.kokkos import gpu_instance
#kokkos_run = gpu_instance(deviceId = 0)
from simtbx.diffBragg.utils import get_diffBragg_instance
import sys
if "--kokkos" in sys.argv:
    import os
    os.environ["DIFFBRAGG_USE_KOKKOS"]="1"
from simtbx.diffBragg.utils import find_diffBragg_instances
from simtbx.diffBragg.device import DeviceWrapper
with DeviceWrapper(0) as _:

    import numpy as np

    print ("Instantiating diffBragg")
    D = get_diffBragg_instance()
    D.vectorize_umats()
    print ("Declaring a refinement manager")
    rotX = 0
    D.refine(rotX)  # defaults full image as ROI
    D.initialize_managers()
    print ("Running diffBragg on full image")
    D.add_diffBragg_spots()
    img_sh = D.raw_pixels.as_numpy_array().shape
    print ("Extracting derivative pixels")
    full_deriv_image = D.get_derivative_pixels(rotX).as_numpy_array()
    print()
    print ("Re-running but using only the ROIs")
    rois = (20, 50, 10, 80), (10, 20, 80, 90)
    for x1, x2, y1, y2 in rois:
        print("Declarind ROI %d %d %d %d" % (x1, x2, y1, y2))
        D.raw_pixels*= 0
        D.region_of_interest = ((x1, x2), (y1, y2))
        print("Running diffBRagg on ROI")
        D.add_diffBragg_spots()
        print("Extracting derivative pixels")
        roi_deriv_image = D.get_derivative_pixels(rotX).as_numpy_array()
        assert np.allclose(roi_deriv_image, full_deriv_image.reshape(img_sh)[y1:y2, x1:x2].ravel())
        print("LOOP OVER")
    print("DONE!")
    for name in find_diffBragg_instances(globals()): del globals()[name]


 *******************************************************************************


 *******************************************************************************
simtbx/diffBragg/tests/tst_diffBragg_detdist_derivatives.py
"""
We need a way to update geometric properties
via dxtbx objects, without re-instantiating the simulator
These unit tests check our functon update_dxtbx_geoms which allows
one to update those models for beam/detector post-instantiation
"""
from __future__ import division
##from simtbx.kokkos import gpu_instance
#kokkos_run = gpu_instance(deviceId = 0)

from argparse import ArgumentParser
parser = ArgumentParser()
parser.add_argument("--kokkos", action="store_true")
parser.add_argument("--plotimages", action='store_true')
parser.add_argument("--plotlines", action='store_true')
parser.add_argument("--curvatures",action="store_true")
args = parser.parse_args()
if args.kokkos:
    import os
    os.environ["DIFFBRAGG_USE_KOKKOS"]="1"
from simtbx.diffBragg.utils import find_diffBragg_instances
from simtbx.diffBragg.device import DeviceWrapper
with DeviceWrapper(0) as _:

    from scipy.stats import linregress
    import numpy as np
    import pylab as plt
    from simtbx.nanoBragg import sim_data
    from dxtbx.model import Panel
    from scitbx.matrix import sqr, col

    # part 1:
    # simple k_diffracted derivative
    fs = np.array([1, 0, 0])
    ss = np.array([0, -1, 0])

    # FIXME:
    k_incident = np.array([0, 0, -1])

    i, j = 10, 10
    pixsize_mm = 0.11
    detdist_mm = 150
    camera_size_mm = 50, 50
    origin_z = -detdist_mm
    origin_mm = np.array([-camera_size_mm[1]/2., camera_size_mm[0]/2., origin_z])

    unit = 1e-3

    # diffracted beam
    k = origin_mm + fs*i*pixsize_mm + ss*j*pixsize_mm
    k *= unit  # convert to meters like the code

    # FIXME mod1
    k = np.array([.01685, .02055, -.15])
    #h_vals = [1e-5*2**i for i in range(20)]

    h_vals = [(2*i*(1e-2))*1e-3 for i in range(1, 30, 2)]

    all_q_err = []
    all_q_err2 = []
    all_uk_err = []
    for h in h_vals:
        # derivative of k vector w.r.t. detdist
        #origin2_mm = np.array([-camera_size_mm[1]/2., camera_size_mm[0]/2., origin_z+h])
        #k2 = origin2_mm + fs*i*pixsize_mm + ss*j*pixsize_mm
        #k2 *= unit  # convert to meters

        # FIXME mod1
        k2 = np.array([.01685, .02055, -.15+h])
        k0 = np.array([.01685, .02055, -.15-h])
        fdiff = (k2-k) / h  # / unit
        dk = np.array((0, 0, 1))


        #print ("\ndiffracted vector:")
        #print ("finite deriv", fdiff)
        #print ("deriv", dk)

        # take derivative of unit diffracted vector
        air_path = np.linalg.norm(k)
        unit_k = k / air_path

        air_path2 = np.linalg.norm(k2)
        unit_k2 = k2 / air_path2

        air_path0 = np.linalg.norm(k0)
        unit_k0 = k0 / air_path0

        fdiff = (unit_k2 - unit_k) / h  # / unit

        G = np.dot(k, dk)
        per_k = 1./air_path
        per_k3 = np.power(per_k, 3)
        per_k5 = np.power(per_k, 5)
        deriv = dk*per_k - k*(per_k3*G)
        d_unitk = deriv

        #print ("\nunit diffracted vector:")
        #print ("finite deriv", fdiff)
        #print ("deriv", d_unitk)
        err = np.abs(d_unitk-fdiff).mean()
        #print("error = %2.7g, h=%2.7g" % (err, h))
        all_uk_err.append(err)
        #print("h=%2.7g" % h)
        # now take derivative of q_vecor

        wavelen = 1.8
        q = 1 / wavelen * (unit_k - k_incident)
        q2 = 1 / wavelen * (unit_k2 - k_incident)
        q0 = 1 / wavelen * (unit_k0 - k_incident)
        fdiff = (q2 - q) / h  # / unit

        deriv = 1 / wavelen * d_unitk

        dq = 1/wavelen*d_unitk
        err = np.abs(dq-fdiff).mean()
        #print("error = %2.7g, h=%2.7g" % (err, h))
        all_q_err.append(err)

        # second derivative
        fdiff2 = (q2+q0 - 2.*q) / h/h  # / unit

        # analytical
        d_unitk2 = (3*per_k5*G*G)*k - per_k3*(np.dot(dk, dk))*k - (2*per_k3*G)*dk
        dq2 = 1 / wavelen * d_unitk2

        err2 = np.abs(dq2-fdiff2).mean()
        #print("\terror2 = %2.7g, h=%2.7g" % (err, h))
        all_q_err2.append(err2)

        print ("\nmomentum transfer vector:")
        print ("finite deriv2", fdiff2)
        print ("deriv2", dq2)

    luk = linregress(h_vals, all_uk_err)
    lq = linregress(h_vals, all_q_err)
    lq2 = linregress(np.array(h_vals)**2, all_q_err2)

    print (luk.rvalue, luk.slope)
    print (lq.rvalue, lq.slope)
    print (lq2.rvalue, lq2.slope)
    print ("\nmomentum transfer vector:")
    print ("finite deriv", fdiff)
    #print ("deriv", deriv)
    print ("deriv", dq)

    print ("\nmomentum transfer vector:")
    print ("finite deriv2", fdiff2)
    print ("deriv", dq2)

    assert luk.rvalue > 0.99
    assert lq.rvalue > 0.99
    assert lq2.rvalue > 0.99


    wavelen = 1.8
    h = h_vals[0]
    k2 = np.array([.01685, .02055, -.15 + h])
    k0 = np.array([.01685, .02055, -.15 - h])
    dk = np.array((0, 0, 1))
    air_path = np.linalg.norm(k)
    unit_k = k / air_path
    air_path2 = np.linalg.norm(k2)
    unit_k2 = k2 / air_path2
    air_path0 = np.linalg.norm(k0)
    unit_k0 = k0 / air_path0

    q = 1/wavelen * (unit_k - k_incident)
    q2 = 1/wavelen * (unit_k2 - k_incident)
    q0 = 1/wavelen * (unit_k0 - k_incident)
    fdiff = (q2-q) / h

    per_k = 1/air_path
    per_k3 = np.power(per_k, 3)
    per_k5 = np.power(per_k, 5)
    G = np.dot(dk, k)
    d_unitk = dk * per_k - k * (per_k3 * G)
    dq = 1/wavelen * d_unitk

    print ("\nunit momentum transfer vector:")
    print ("finite deriv", fdiff)
    print ("deriv", dq)


    # take derivative of V-vector
    # V = N*(U*B*q- h0)
    SIM = sim_data.SimData(use_default_crystal=True)
    C = SIM.crystal.dxtbx_crystal
    B = sqr(C.get_B()).inverse().transpose()
    U = sqr(C.get_U())
    O = SIM.crystal.Omatrix
    UBO = (U*B*O).transpose()

    nn = SIM.crystal.Ncells_abc[0]
    N = sqr((nn, 0, 0, 0, nn, 0, 0, 0, nn))
    h0 = col((4, 3, -1))
    V = N*(UBO*col(q) - h0)
    V2 = N*(UBO*col(q2)-h0)
    V0 = N*(UBO*col(q0)-h0)
    fdiff = (V2-V)/h #/unit
    fdiff2 = (V2+V0-2*V)/h/h #/unit

    deriv = N*(UBO*col(dq))
    dV = deriv

    d_unitk2 = (3 * per_k5 * G * G) * k - per_k3 * (np.dot(dk, dk)) * k - (2 * per_k3 * G) * dk
    dq2 = 1 / wavelen * d_unitk2
    dV2 = N*(UBO*col(dq2))

    print("\nV-vector")
    print("Values", V.elems)
    print("finite deriv", fdiff.elems)
    print("deriv", dV.elems)
    print("finite deriv2", fdiff2.elems)
    print("deriv2", dV2.elems)

    hrad_sqr = np.dot(V.elems, V.elems)
    hrad_sqr2 = np.dot(V2.elems, V2.elems)
    fd_hrad = (hrad_sqr2 - hrad_sqr) / h

    Fl = nn**3*np.exp(-(hrad_sqr / 0.63 * 1))
    Fl2 = nn**3*np.exp(-(hrad_sqr2 / 0.63 * 1))
    fdiff_Fl = (Fl2-Fl)/h
    dH = 2 * np.dot(V.elems, dV.elems)

    print ("\nHrad_sqr")
    print(" finite diff=%f" % fd_hrad)
    print(" derivative=%f" % dH)

    deriv_Fl = -1/.63*Fl * dH

    print("\ndFlatt")
    print ("finite deriv", fdiff_Fl)
    print("deriv: %f" % deriv_Fl)

    #deriv_Fl2 = -2/.63*((dV2*V)*Fl + (dV*dV)*Fl + (dV*V)*deriv_Fl)

    print("\n---------------------------------\n")

    # make a simple detector
    #det = sim_data.SimData.simple_detector(detector_distance_mm=200, pixelsize_mm=0.025, image_shape=(2400, 2400))

    ##############################


    #   BEGIN FINITE DIFF TEST


    ##############################

    det = sim_data.SimData.simple_detector(detector_distance_mm=150, pixelsize_mm=0.1, image_shape=(512, 512))
    orig_idx = 10  # id of origin coordinate in diffBragg

    B = SIM.beam.nanoBragg_constructor_beam

    # set the detector
    SIM.detector = det
    SIM.instantiate_diffBragg(auto_set_spotscale=True)
    D = SIM.D

    D.oversample_omega = True
    D.nopolar = True

    D.refine(orig_idx)
    D.initialize_managers()
    #D.region_of_interest = ((2070, 2130), (70, 150))
    D.add_diffBragg_spots()

    # get the simulated image and derivative
    img = D.raw_pixels_roi.as_numpy_array()
    deriv = D.get_derivative_pixels(orig_idx).as_numpy_array()
    deriv2 = D.get_second_derivative_pixels(orig_idx).as_numpy_array()
    D.raw_pixels_roi *= 0
    D.raw_pixels *= 0

    node = det[0]
    node_d = node.to_dict()
    O = node_d["origin"][0], node_d["origin"][1], node_d["origin"][2]
    distance = O[2]

    # update the detector distance
    percs = [np.power(1e-3*i, 2) for i in range(1, 30, 2)]
    all_shifts = []
    all_errors = []
    all_errors2 = []
    shifts_mm = [2*i*(1e-2) for i in range(1,30,2)]
    print (shifts_mm)

    for i_shift, p in enumerate(percs):
        # update the detector model
        #delta_shift = abs(p*1e-2*distance)
        delta_shift = shifts_mm[i_shift]  # + distance

        O2 = O[0], O[1], (distance + delta_shift)
        node_d["origin"] = O2

        det[0] = Panel.from_dict(node_d)
        D.update_dxtbx_geoms(det, B, 0)
        D.add_diffBragg_spots()
        img_forward = D.raw_pixels_roi.as_numpy_array()
        D.raw_pixels_roi *= 0
        D.raw_pixels *= 0
        delta_shift_meters = delta_shift*1e-3
        fdiff = (img_forward-img)/delta_shift_meters

        if args.curvatures:
            O2 = O[0], O[1], (distance - delta_shift)
            node_d["origin"] = O2
            det[0] = Panel.from_dict(node_d)
            D.update_dxtbx_geoms(det, B, 0)

            D.add_diffBragg_spots()
            img_backward = D.raw_pixels_roi.as_numpy_array()
            D.raw_pixels_roi *= 0
            D.raw_pixels *= 0

            fdiff2 = (img_forward - 2*img + img_backward) / delta_shift_meters / delta_shift_meters

        bragg = img > 1e-2

        error = (np.abs(fdiff[bragg] - deriv[bragg]) ).mean()
        all_errors.append(error)

        if args.curvatures:
            error2 = (np.abs(fdiff2[bragg] - deriv2[bragg]) / 1).mean()
            all_errors2.append(error2)

        all_shifts.append(delta_shift_meters)

        print("Error=%2.7g shift=%2.7g mm, originZ=%2.7g mm" % (error, delta_shift, D.distance_mm))
        if args.plotimages:
            plt.clf()
            y = slice(40, 65, 1)
            x = slice(415, 437, 1)
            plt.subplot(121)
            plt.imshow(fdiff[y, x])
            plt.title("finite diff")
            plt.subplot(122)
            plt.imshow(deriv[y, x])
            plt.title("analytical")
            plt.draw()
            plt.suptitle("originZ=%f mm, delta=%f mm, Shift %d / %d"
                         % (distance+delta_shift, delta_shift, i_shift + 1, len(percs)))
            plt.pause(0.3)
            if args.curvatures:
                plt.clf()
                plt.subplot(121)
                plt.imshow(fdiff2[y, x])
                plt.title("finite 2nd diff")
                plt.subplot(122)
                plt.imshow(deriv2[y, x])
                plt.title("analytical")
                plt.draw()
                plt.suptitle("originZ=%f mm, delta=%f mm, Shift %d / %d"
                             % (distance + delta_shift, delta_shift, i_shift + 1, len(percs)))
                plt.pause(0.3)

    print( "\n\nSecond derivative\nerror          (shift)^2\n-----------------------------")
    for err2, shift in zip(all_errors2, all_shifts):
        print ("%10.7g  %10.7g" %(err2, shift**2))

    if args.plotlines:
        plt.close()

        plt.plot(all_shifts, all_errors, 'o')
        plt.suptitle("finite 1st difference error", fontsize=16)
        plt.xlabel("h", fontsize=16)
        plt.show()

    l = linregress(all_shifts, all_errors)
    print("finite diff l.rvalue=%10.7g" % l.rvalue)
    assert l.rvalue > .99
    assert l.slope > 0
    assert l.pvalue < 1e-6
    assert l.intercept < 0.1*l.slope


    if args.curvatures:
        if args.plotlines:
            plt.close()

            plt.plot(np.array(all_shifts)**2, all_errors2, 'o')
            plt.suptitle("finite 2nd difference error", fontsize=16)
            plt.xlabel("$h^2$", fontsize=16)
            plt.show()

        l = linregress(np.array(all_shifts)**2, all_errors2)
        print("finite 2nd diff l.rvalue=%10.7g" % l.rvalue)
        assert l.rvalue > .99
        assert l.slope > 0
        assert l.pvalue < 1e-6
        assert l.intercept < 0.1*l.slope

    print("OK!")
    for name in find_diffBragg_instances(globals()): del globals()[name]


 *******************************************************************************


 *******************************************************************************
simtbx/diffBragg/tests/tst_diffBragg_diffuse_properties.py
"""
This test checks the setter and getter for Ncells parameter
"""
from __future__ import division
##from simtbx.kokkos import gpu_instance
#kokkos_run = gpu_instance(deviceId = 0)

from argparse import ArgumentParser
parser = ArgumentParser()
parser.add_argument("--kokkos", action="store_true")
parser.add_argument("--plot", action='store_true')
parser.add_argument("--onlyDiffuse", action='store_true')
parser.add_argument("--sigma", default=[1,1,1], type=float, nargs=3)
parser.add_argument("--gamma", default=[100,100,100], type=float, nargs=3)
parser.add_argument("--idx", type=int, default=0, choices=[0,1,2], help="diffuse parameter index (0,1,2 ->a,b,c)")
parser.add_argument("--stencil", type=int, default=0, help="sets the stencil property in diffBragg (default is 0)")
parser.add_argument("--laue", action="store_true", help="sets the laue group number for the spacegroup")
parser.add_argument("--grad", choices=['sigma','gamma'], default='gamma')
parser.add_argument("--orientation", choices=[0,1], type=int, help="selects orientation for aniso. model", default=0)

import pylab as plt
import os

args = parser.parse_args()
if args.kokkos:
    os.environ["DIFFBRAGG_USE_KOKKOS"] = "1"
from simtbx.diffBragg.utils import find_diffBragg_instances
from simtbx.diffBragg.device import DeviceWrapper
with DeviceWrapper(0) as _:

    from simtbx.nanoBragg import sim_data
    from simtbx.diffBragg import utils

    S = sim_data.SimData(use_default_crystal=True)
    det_shape = (1024,1024)
    S.detector = sim_data.SimData.simple_detector(180, 0.1, det_shape)
    S.instantiate_diffBragg(verbose=0, oversample=0, auto_set_spotscale=True)
    #S.D.record_time = True
    S.D.spot_scale = 100000
    S.D.use_diffuse = True
    if args.laue:
        symbol = S.crystal.space_group_info.type().lookup_symbol()
        S.D.laue_group_num = utils.get_laue_group_number(symbol)
        if symbol.replace(" ","")=="P43212":
            assert S.D.laue_group_num==7  # for default P43212
        print("Laue group number set to %d" % S.D.laue_group_num)
    S.D.stencil_size = args.stencil
    assert S.D.stencil_size== args.stencil
    print("diffuse scattering stencil size set to %d" % S.D.stencil_size)
    S.D.diffuse_gamma = tuple(args.gamma)
    S.D.diffuse_sigma = tuple(args.sigma)
    if args.orientation == 1:
        ori = (1,0,0,0,1,0,0,0,1)
    else:
        ori = (0.70710678, -0.70710678, 0.0, 0.70710678, 0.70710678, 0.0, 0.0, 0.0, 1.0)
    S.D.set_rotate_principal_axes(ori)
    print("Set the orientation as:", S.D.get_rotate_principal_axes())

    default_gamma = args.gamma
    default_sigma = args.sigma

    import numpy as np
    assert np.allclose(S.D.diffuse_gamma, args.gamma)
    assert np.allclose(S.D.diffuse_sigma, args.sigma)

    diffuse_id = 23
    S.D.refine(diffuse_id)
    S.D.add_diffBragg_spots()
    img = S.D.raw_pixels_roi.as_numpy_array()
    bragg = img > 1e-1  # select bragg scattering regions

    if args.grad == 'gamma':
        derivs_abc = list(map(lambda x: x.as_numpy_array(), S.D.get_diffuse_gamma_derivative_pixels()))
        diff_params = args.gamma
    else:
        derivs_abc = list(map(lambda x: x.as_numpy_array(), S.D.get_diffuse_sigma_derivative_pixels()))
        diff_params = args.sigma

    S.D.fix(diffuse_id)

    from scipy.stats import linregress
    perc = 0.001, 0.01, 0.1, 1, 10
    for ii in range(3):
        if ii != args.idx:
            continue

        all_error = []
        all_error2 = []
        shifts = []
        shifts2 = []
        gi = diff_params[ii]
        for i_shift, p in enumerate(perc):
            delta_gi = gi*p*0.01
            print(i_shift, delta_gi, gi)
            diff_vals = diff_params*1
            diff_vals[ii] = gi+delta_gi

            if args.grad == 'gamma':
                S.D.diffuse_gamma = tuple(diff_vals)
            else:
                S.D.diffuse_sigma = tuple(diff_vals)

            shifts.append(delta_gi)

            S.D.raw_pixels_roi *= 0
            #S.D.printout_pixel_fastslow = 10, 10
            S.D.add_diffBragg_spots()
            img2 = S.D.raw_pixels_roi.as_numpy_array()

            fdiff = (img2 - img) / delta_gi
            deriv = derivs_abc[ii]
            error = np.abs(fdiff[bragg] - deriv[bragg]).mean()
            all_error.append(error)

            print ("error=%f, step=%f" % (error, delta_gi))

        if args.plot:
            plt.plot(shifts, all_error, 'o')
            plt.show()

        l = linregress(shifts, all_error)
        assert l.rvalue > .9999  # this is definitely a line!
        assert l.slope > 0
        assert l.pvalue < 1e-6
        assert l.intercept < 0.1*l.slope # line should go through origin

    det_sh = 1024, 1024
    print("OK")
    for name in find_diffBragg_instances(globals()): del globals()[name]


 *******************************************************************************


 *******************************************************************************
simtbx/diffBragg/tests/tst_diffBragg_eta_derivs.py
from __future__ import division
##from simtbx.kokkos import gpu_instance
#kokkos_run = gpu_instance(deviceId = 0)

from argparse import ArgumentParser
parser = ArgumentParser()
parser.add_argument("--plot", action="store_true")
parser.add_argument("--curvatures", action="store_true")
parser.add_argument("--kokkos", action="store_true")
parser.add_argument("--aniso", type=int, choices=[0,1,2], default=None)
args = parser.parse_args()
if args.kokkos:
    import os
    os.environ["DIFFBRAGG_USE_KOKKOS"]="1"
from simtbx.diffBragg.utils import find_diffBragg_instances
from simtbx.diffBragg.device import DeviceWrapper
with DeviceWrapper(0) as _:

    from dxtbx.model.crystal import Crystal
    from cctbx import uctbx
    from scitbx.matrix import rec, col
    import numpy as np
    from scipy.spatial.transform import Rotation
    from scitbx.matrix import sqr
    from simtbx.nanoBragg.nanoBragg_crystal import NBcrystal
    from simtbx.nanoBragg.sim_data import SimData
    from simtbx.diffBragg.utils import fcalc_from_pdb
    import pylab as plt


    ucell = (79, 79, 38, 90, 90, 90)
    symbol = "P43212"
    N_MOS_DOMAINS = 100
    MOS_SPREAD = 1
    ANISO_MOS_SPREAD = 0.5, 0.75, 1
    eta_diffBragg_id = 19

    miller_array_GT = fcalc_from_pdb(resolution=2, wavelength=1, algorithm='fft', ucell=ucell, symbol=symbol)
    Ncells_gt = 15, 15, 15

    np.random.seed(3142019)
    # generate a random rotation
    rotation = Rotation.random(num=1, random_state=100)[0]
    Q = rec(rotation.as_quat(), n=(4, 1))
    rot_ang, rot_axis = Q.unit_quaternion_as_axis_and_angle()

    a_real, b_real, c_real = sqr(uctbx.unit_cell(ucell).orthogonalization_matrix()).transpose().as_list_of_lists()
    x = col((-1, 0, 0))
    y = col((0, -1, 0))
    z = col((0, 0, -1))
    rx, ry, rz = np.random.uniform(-180, 180, 3)
    RX = x.axis_and_angle_as_r3_rotation_matrix(rx, deg=True)
    RY = y.axis_and_angle_as_r3_rotation_matrix(ry, deg=True)
    RZ = z.axis_and_angle_as_r3_rotation_matrix(rz, deg=True)
    M = RX * RY * RZ
    a_real = M * col(a_real)
    b_real = M * col(b_real)
    c_real = M * col(c_real)
    C = Crystal(a_real, b_real, c_real, symbol)
    C.rotate_around_origin(rot_axis, rot_ang)

    # Setup the simulation and create a realistic image
    # with background and noise
    # <><><><><><><><><><><><><><><><><><><><><><><><><>
    nbcryst = NBcrystal(init_defaults=True)
    nbcryst.dxtbx_crystal = C   # simulate ground truth
    nbcryst.thick_mm = 0.1
    nbcryst.Ncells_abc = Ncells_gt  # ground truth Ncells
    nbcryst.mos_spread_deg = MOS_SPREAD
    if args.aniso is not None:
      nbcryst.anisotropic_mos_spread_deg = ANISO_MOS_SPREAD
      assert nbcryst.has_anisotropic_mosaicity
    else:
      assert not nbcryst.has_anisotropic_mosaicity

    nbcryst.n_mos_domains = N_MOS_DOMAINS
    nbcryst.miller_array = miller_array_GT
    print("Ground truth ncells = %f" % (nbcryst.Ncells_abc[0]))

    # ground truth detector
    DET_gt = SimData.simple_detector(150, 0.177, (600, 600))

    # initialize the simulator
    SIM = SimData()
    if args.aniso is None:
      SIM.Umats_method = 2
    else:
      SIM.Umats_method = 3
    SIM.detector = DET_gt
    SIM.crystal = nbcryst
    SIM.instantiate_diffBragg(oversample=1, verbose=0)
    SIM.D.refine(eta_diffBragg_id)
    SIM.D.initialize_managers()
    SIM.D.spot_scale = 100000
    SIM.D.default_F = 0
    SIM.D.progress_meter = False
    SIM.water_path_mm = 0.15
    SIM.air_path_mm = 0.1
    SIM.add_air = True
    SIM.add_water = True
    SIM.include_noise = True
    SIM.D.use_gpu = args.kokkos
    SIM.D.compute_curvatures = args.curvatures
    SIM.D.add_diffBragg_spots()

    if args.aniso is None:
      deriv = SIM.D.get_derivative_pixels(eta_diffBragg_id).as_numpy_array()
    else:
      deriv = SIM.D.get_aniso_eta_deriv_pixels()[args.aniso].as_numpy_array()

    if args.curvatures:
      if args.aniso is None:
        deriv2 = SIM.D.get_second_derivative_pixels(eta_diffBragg_id).as_numpy_array()
      else:
        deriv2 = SIM.D.get_aniso_eta_second_deriv_pixels()[args.aniso].as_numpy_array()
    SPOTS = SIM.D.raw_pixels_roi.as_numpy_array()

    SIM.D.readout_noise_adu = 1
    SIM._add_background()
    SIM._add_noise()

    # This is the ground truth image:
    img = SIM.D.raw_pixels.as_numpy_array()
    SIM.D.raw_pixels_roi *= 0
    SIM.D.raw_pixels *= 0

    all_errors = []
    all_shifts = []
    all_errors2 = []
    all_shifts2 = []
    for finite_diff_step in [1, 2, 4, 8, 16]:
      # update Umats to do finite difference test
      delta_eta = 0.001*finite_diff_step

      if args.aniso is not None:
        eta_update = list(ANISO_MOS_SPREAD)
        eta_update[args.aniso] = eta_update[args.aniso]+ delta_eta
        crystal = nbcryst.dxtbx_crystal
      else:
        eta_update = MOS_SPREAD + delta_eta
        crystal = None

      SIM.update_umats_for_refinement(eta_update)
      SIM.D.add_diffBragg_spots()

      img_forward = SIM.D.raw_pixels_roi.as_numpy_array()
      SIM.D.raw_pixels_roi *= 0
      SIM.D.raw_pixels *= 0
      fdiff = (img_forward - SPOTS) / delta_eta
      bragg = SPOTS > 1e-2
      error = (np.abs(fdiff[bragg] - deriv[bragg])).mean()
      all_errors.append(error)
      all_shifts.append(delta_eta)
      if args.curvatures:

        if args.aniso is not None:
          eta_update = list(ANISO_MOS_SPREAD)
          eta_update[args.aniso] = eta_update[args.aniso] - delta_eta
          crystal = nbcryst.dxtbx_crystal
        else:
          eta_update = MOS_SPREAD - delta_eta
          crystal= None

        SIM.update_umats_for_refinement(eta_update)

        all_shifts2.append(delta_eta ** 2)

        SIM.D.raw_pixels_roi *= 0
        SIM.D.raw_pixels *= 0
        SIM.D.add_diffBragg_spots()
        img_backward = SIM.D.raw_pixels_roi.as_numpy_array()

        fdiff2 = (img_forward - 2*SPOTS + img_backward) / delta_eta/ delta_eta

        second_deriv = deriv2
        error2 = (np.abs(fdiff2[bragg] - second_deriv[bragg]) / 1).mean()
        all_errors2.append(error2)

      print("\n\n<><><><><><><><>\n\tError:", error, "shift:", delta_eta)
      if args.curvatures:
        print("\terror2=%f, step=%f\n<><><><><><><><>\n\n" % (error2, delta_eta))

    from scipy.stats import linregress
    l = linregress(all_shifts, all_errors)
    print("finite diff l.rvalue=%10.7g" % l.rvalue)
    if args.plot:
      plt.figure()
      plt.plot(all_shifts, all_errors, 'o')
      plt.show()
      if args.curvatures:
        plt.plot(all_shifts2, all_errors2, 'o')
        plt.title("second finite diff error")
        plt.xlabel("delta eta")
        plt.show()

    assert l.rvalue > .99, "%f" % l.rvalue
    assert l.slope > 0, "%f" % l.slope
    assert l.pvalue < 1e-6, "%f" % l.pvalue
    assert l.intercept < 0.1*l.slope, "%f" % l.intercept
    if args.curvatures:
      l = linregress(all_shifts2, all_errors2)
      assert l.rvalue > .9999  # this is definitely a line!
      assert l.slope > 0
      assert l.pvalue < 1e-6
      assert l.intercept < 0.1*l.slope # line should go through origin
    print("OK")
    for name in find_diffBragg_instances(globals()): del globals()[name]


 *******************************************************************************


 *******************************************************************************
simtbx/diffBragg/tests/tst_diffBragg_hopper_refine.py
from __future__ import division
from argparse import ArgumentParser
parser = ArgumentParser()
parser.add_argument("--kokkos", action="store_true")
parser.add_argument("--curvatures", action='store_true')
parser.add_argument("--readout", type=float, default=0)
parser.add_argument("--perturb", choices=["G", "Nabc", "detz_shift", "crystal", "eta", "spec"], type=str, nargs="+", default=["crystal"] )
parser.add_argument("--eta", type=float, nargs=3, default=[.2, .1, .4])
parser.add_argument("--plot", action="store_true", help="shows the ground truth image")
parser.add_argument("--typeG", choices=["ranged", "positive"], default="ranged", type=str,  help="shows the ground truth image")
parser.add_argument("--typeNabc", choices=["ranged", "positive"], default="ranged", type=str,  help="shows the ground truth image")
parser.add_argument("--cmdlineHopper", action="store_true", help="test the command line program simtbx/command_line/hopper.py")
args = parser.parse_args()
name = "hopper_refine_%s" % "-".join(args.perturb)
import os

if args.kokkos:
    os.environ["DIFFBRAGG_USE_KOKKOS"]="1"
from simtbx.diffBragg.utils import find_diffBragg_instances
from simtbx.diffBragg.device import DeviceWrapper
with DeviceWrapper(0) as _:

    from dxtbx.model.crystal import Crystal
    from cctbx import uctbx
    from scitbx.matrix import sqr, rec, col
    import numpy as np
    from scipy.spatial.transform import Rotation
    from simtbx.nanoBragg.nanoBragg_crystal import NBcrystal
    from simtbx.nanoBragg.sim_data import SimData
    from simtbx.diffBragg import utils
    from scipy.signal import windows
    from dxtbx.model import Experiment
    from simtbx.nanoBragg import make_imageset
    from simtbx.diffBragg.phil import hopper_phil, philz
    from libtbx.phil import parse

    phil_scope = parse(hopper_phil+philz)

    ucell = (55, 65, 75, 90, 95, 90)
    ucell2 = (55.1, 65.2, 74.9, 90, 94.9, 90)
    symbol = "P121"

    # generate a random raotation
    rotation = Rotation.random(num=1, random_state=100)[0]
    Q = rec(rotation.as_quat(), n=(4, 1))
    rot_ang, rot_axis = Q.unit_quaternion_as_axis_and_angle()

    # generate a small perturbation rotation
    np.random.seed(1)
    perturb_rot_axis = np.random.random(3)
    perturb_rot_axis /= np.linalg.norm(perturb_rot_axis)
    perturb_rot_ang = 0.15  # degree random perturbtation

    # make the ground truth crystal:
    a_real, b_real, c_real = sqr(uctbx.unit_cell(ucell).orthogonalization_matrix()).transpose().as_list_of_lists()
    C = Crystal(a_real, b_real, c_real, symbol)
    C.rotate_around_origin(rot_axis, rot_ang)

    a2_real, b2_real, c2_real = sqr(uctbx.unit_cell(ucell2).orthogonalization_matrix()).transpose().as_list_of_lists()
    C2 = Crystal(a2_real, b2_real, c2_real, symbol)
    C2.rotate_around_origin(rot_axis, rot_ang)
    assert np.allclose(C2.get_U(), C.get_U())
    C2.rotate_around_origin(col(perturb_rot_axis), perturb_rot_ang)

    # Setup the simulation and create a realistic image
    # with background and noise
    # <><><><><><><><><><><><><><><><><><><><><><><><><>
    nbcryst = NBcrystal()
    nbcryst.dxtbx_crystal = C   # simulate ground truth
    nbcryst.thick_mm = 0.1
    nbcryst.isotropic_ncells = False
    if "eta" in args.perturb:
        nbcryst.n_mos_domains = 1000
        ETA_ABC_GT = args.eta
        nbcryst.anisotropic_mos_spread_deg = ETA_ABC_GT
        NCELLS_GT = 12,12,11
    else:
        NCELLS_GT = 12,12,11
    nbcryst.Ncells_abc = NCELLS_GT

    SIM = SimData(use_default_crystal=True)
    if "spec" in args.perturb:
        # initialize the simulator
        spec = SIM.beam.spectrum
        total_flux = spec[0][1]
        wave = spec[0][0]

        en = utils.ENERGY_CONV / wave
        delta_en = 1.5
        ens_gt = np.arange(en - 5, en + 6, delta_en)
        waves_gt = utils.ENERGY_CONV / ens_gt
        num_energies = len(ens_gt)
        fluxes_gt = np.ones(num_energies) * total_flux / num_energies
        fluxes_gt = fluxes_gt*windows.hann(num_energies)
        fluxes_gt /= fluxes_gt.sum()
        fluxes_gt *= total_flux

        spectrum_GT = list(zip(waves_gt, fluxes_gt))
        gt_lambda0 = waves_gt[0]
        gt_lambda1 = waves_gt[1] - waves_gt[0]
        spec_idx = np.arange(num_energies)
        assert np.allclose(waves_gt, gt_lambda0 + spec_idx*gt_lambda1)

        lam0 = np.random.normal(gt_lambda0, gt_lambda0 * 0.002)
        lam1 = np.random.normal(gt_lambda1, abs(gt_lambda1) * 0.002)
        waves_perturbed = lam0 + spec_idx * lam1
        print("ENERGY TRUTH=%.4f" % (utils.ENERGY_CONV / gt_lambda0))
        print("ENERGY PERTURBED=%.4f" % (utils.ENERGY_CONV / lam0))
        perturbed_spec = list(zip(waves_perturbed, fluxes_gt))
        SIM.beam.spectrum = spectrum_GT

    #SIM.detector = SimData.simple_detector(150, 0.1, (513, 512))
    if "eta" in args.perturb:
        shape = 513*3, 512*3
        #detdist = 70
    else:
        shape = 513, 512
    detdist = 150
    SIM.detector = SimData.simple_detector(detdist, 0.1, shape)
    SIM.crystal = nbcryst
    SIM.instantiate_diffBragg(oversample=0, auto_set_spotscale=True)
    SIM.D.default_F = 0
    SIM.D.F000 = 0
    SIM.D.progress_meter = False
    SIM.water_path_mm = 0.005
    SIM.air_path_mm = 0.1
    SIM.add_air = True
    SIM.add_Water = True
    SIM.include_noise = True
    SIM.D.verbose = 2
    SIM.D.add_diffBragg_spots()
    SIM.D.verbose = 0
    spots = SIM.D.raw_pixels.as_numpy_array()
    SIM._add_background()
    SIM.D.readout_noise_adu=args.readout
    SIM._add_noise()

    # This is the ground truth image:
    img = SIM.D.raw_pixels.as_numpy_array()
    if args.plot:
        import pylab as plt
        plt.imshow(img, vmax=100)
        plt.title("Ground truth image")
        plt.show()

    cbf_name = name + ".cbf"
    if args.cmdlineHopper:
        from IPython import embed
        embed()
        SIM.D.to_cbf(cbf_name)

    SIM.D.raw_pixels *= 0

    P = phil_scope.extract()
    E = Experiment()

    GT_spot_scale = SIM.D.spot_scale
    if "G" in args.perturb:
        P.init.G = GT_spot_scale*10
    else:
        P.init.G = GT_spot_scale

    P.types.G = args.typeG
    P.types.Nabc = args.typeNabc

    if "crystal" in args.perturb:
        E.crystal = C2
    else:
        E.crystal = C

    if "Nabc" in args.perturb:
        P.init.Nabc = 20,20,20
    else:
        P.init.Nabc = SIM.crystal.Ncells_abc

    if "detz_shift" in args.perturb:
        P.init.detz_shift = 1
    else:
        P.init.detz_shift = 0

    if "eta" in args.perturb:
        P.init.eta_abc = [0.12, 0.13, 0.14]
        P.simulator.crystal.num_mosaicity_samples = 250  # in practive, the number of mosaic domains we model should be smaller than whats in the crystal .. .
        P.simulator.crystal.has_isotropic_mosaicity = False
        P.fix.eta_abc = False

    if "spec" in args.perturb:
        P.fix.spec = False
        P.init.spec = [0,1]
        P.fix.Nabc=True
        P.fix.G=True
        P.fix.RotXYZ=True
        P.fix.ucell = True
        P.fix.detz_shift = True
        P.ftol=1e-15

    if args.perturb == ["detz_shift"]:
        P.fix.detz_shift = False
        P.fix.ucell=True
        P.fix.Nabc=True
        P.fix.G=True
        P.fix.RotXYZ=True

    E.detector = SIM.detector
    E.beam = SIM.D.beam
    E.imageset = make_imageset([img], E.beam, E.detector)
    #refls = utils.refls_from_sims([img], E.detector, E.beam, thresh=18)
    refls = utils.refls_from_sims([spots], E.detector, E.beam, thresh=18)
    print("%d REFLS" % len(refls))
    utils.refls_to_q(refls, E.detector, E.beam, update_table=True)
    utils.refls_to_hkl(refls, E.detector, E.beam, E.crystal, update_table=True)

    P.roi.shoebox_size = 20
    P.relative_tilt = False
    P.roi.fit_tilt = False
    P.roi.pad_shoebox_for_background_estimation=10
    P.roi.reject_edge_reflections = False
    P.refiner.sigma_r = SIM.D.readout_noise_adu
    P.refiner.adu_per_photon = SIM.D.quantum_gain
    P.simulator.init_scale = 1 #SIM.D.spot_scale
    P.simulator.beam.size_mm = SIM.beam.size_mm
    P.simulator.total_flux = SIM.D.flux
    P.use_restraints = False
    mtz_name = name +".mtz"
    SIM.crystal.miller_array.as_mtz_dataset(column_root_label="F").mtz_object().write(mtz_name)
    P.simulator.structure_factors.mtz_name = mtz_name
    P.simulator.structure_factors.mtz_column = "F(+),F(-)"
    P.niter = 0
    P.sigmas.RotXYZ = [1,1,1]
    P.logging.parameters=True
    P.niter_per_J = 1
    P.method="L-BFGS-B"
    P.ftol = 1e-10
    if "eta" in args.perturb:
        P.ftol=1e-8
    #P.method="Nelder-Mead"
    #P.fix.G = True
    #P.fix.Nabc =True
    #P.fix.detz_shift=True

    import logging
    import sys
    h = logging.StreamHandler(sys.stdout)
    logging.basicConfig(level=logging.DEBUG, handlers=[h])

    from simtbx.diffBragg import hopper_utils
    spec = None
    if "spec" in args.perturb:
        spec = "tst_hopper_refine_spec.lam"
        wave, wt = map(np.array, zip(*perturbed_spec))
        utils.save_spectra_file(spec, wave, wt)

    if args.cmdlineHopper:
        from dxtbx.model import ExperimentList
        el_name = "%s.expt" % name
        import_cmd = "dials.import %s output.experiments=%s" % (cbf_name, el_name)
        os.system(import_cmd)
        # add the crystal to the imported expt
        El = ExperimentList.from_file(el_name)
        El[0].crystal = E.crystal
        refl_name = "%s.refl" % name
        El.as_file(el_name)
        refls.as_file(refl_name)
        hopper_input_lst = "%s.lst" % name
        with open(hopper_input_lst, "w") as o:
            o.write("%s %s\n" % (os.path.abspath(el_name), os.path.abspath(refl_name)))

        # save the above modified phil params to a file to be read in by hopper
        phil_file = name+ ".phil"
        modified_phil = phil_scope.format(python_object=P)
        with open(phil_file, 'w') as o:
            modified_phil.show(o)
        outdir = name + ".outdir"
        cmd = "hopper %s exp_ref_spec_file=%s outdir=%s logging.rank0_level=high" % (phil_file, hopper_input_lst, outdir)
        os.system(cmd)
        # TODO open the pandas output file and optimized expt in outdir and verify the optimized parameters are similar to ground
        exit()

    P.record_device_timings = True
    Eopt,_, Mod, SIM_used_by_hopper, x = hopper_utils.refine(E, refls, P, spec=spec, return_modeler=True)
    if SIM_used_by_hopper.D.record_timings:
        SIM_used_by_hopper.D.show_timings(MPI_RANK=0)

    G, rotX,rotY, rotZ, Na,Nb,Nc,_,_,_,_,_,_,_,_,_,a,b,c,al,be,ga,detz_shift = hopper_utils.get_param_from_x(x, Mod)
    eta_abc_opt = hopper_utils.get_mosaicity_from_x(x, Mod, SIM_used_by_hopper)

    print("Na, Nb, Nc= %f %f %f" % (Na, Nb, Nc))
    print("eta_abc optimized:", eta_abc_opt)

    # check crystal
    Copt = Eopt.crystal
    misset, misset_init = utils.compare_with_ground_truth(*C.get_real_space_vectors(), dxcryst_models=[Copt, E.crystal], symbol=symbol)
    print(misset_init, "init misset with ground truth")
    print(misset, "misset with ground truth")
    if "detz_shift" in args.perturb or "spec" in args.perturb:
        assert misset < 0.007, misset
    else:
        assert misset < 0.005, misset

    # check mosaic domain
    assert all(np.subtract(NCELLS_GT, [Na,Nb,Nc]) < 0.2), "%d, %d, %d" % (Na,Nb,Nb)

    # check spot scale
    perc_diff_G = abs(GT_spot_scale - G)/ GT_spot_scale * 100
    print("spot scale gt: %f; spot scale opt: %f; percent diff: %f %%" % (GT_spot_scale, G, perc_diff_G))
    max_Gperc = 1
    if "eta" in args.perturb:
        max_Gperc = 2
    assert perc_diff_G < max_Gperc, perc_diff_G

    # check detz
    print("detdist shift %f (should be 0)" % detz_shift)
    assert detz_shift < 0.2, detz_shift

    ucell_diff_init = np.abs(np.subtract(ucell , ucell2))
    ucell_diff = np.abs(np.subtract(ucell , Copt.get_unit_cell().parameters()))

    init_dev, init_dev_ang = ucell_diff_init[:3].sum(), ucell_diff_init[-3:].sum()
    dev, dev_ang = ucell_diff[:3].sum(), ucell_diff[-3:].sum()
    print("initial ucell dev: %f Angstrom; %f degree" % (init_dev, init_dev_ang))
    print("optimized ucell dev: %f Angstrom; %f degree" % (dev, dev_ang))
    assert dev_ang < init_dev_ang and dev_ang < 0.025, "init: %f curr: %f" % (init_dev_ang, dev_ang)
    if "detz_shift" not in args.perturb:
        assert dev < init_dev and dev < 0.025, "init: %f  curr: %f" % (init_dev, dev)

    if "eta" in args.perturb:
        print("eta_abc GT:", ETA_ABC_GT)
        u = np.array(eta_abc_opt)
        v = np.array(ETA_ABC_GT)
        perc_diff = np.abs(u-v) / v * 100.
        assert np.all(perc_diff < 22)  # this is acceptable for now, as we simulated with 5000 blocks, yet modeled with 600
    print("OK")

    if "spec" in args.perturb:
        p0 = Mod.P["lambda_offset"]
        p1 = Mod.P["lambda_scale"]
        coef = p0.get_val(x[p0.xpos]), p1.get_val(x[p1.xpos])
        waves_refined = coef[0] + coef[1] * waves_perturbed
        fluxsum = sum(fluxes_gt)
        en_ref_com = utils.ENERGY_CONV / (sum(fluxes_gt * waves_refined) / fluxsum)
        en_com = utils.ENERGY_CONV / (sum(fluxes_gt * waves_gt) / fluxsum)
        en_init_com = utils.ENERGY_CONV / (sum(fluxes_gt * waves_perturbed) / fluxsum)

        print("Before refinement: COM energy=%f" % en_init_com)
        print("AFTER refinement: COM energy=%f" % en_ref_com)
        print("Ground truth COM energy = %f" % en_com)
        assert abs(en_ref_com - en_com) < 1

    del SIM_used_by_hopper.D
    for name in find_diffBragg_instances(globals()): del globals()[name]


 *******************************************************************************


 *******************************************************************************
simtbx/diffBragg/tests/tst_diffBragg_hopper_refine_Fhkl.py
from __future__ import division
import glob
from argparse import ArgumentParser
parser = ArgumentParser()
parser.add_argument("--kokkos", action="store_true")
parser.add_argument("--nolog", action="store_true")
parser.add_argument("--readout", type=float, default=3)
parser.add_argument("--scale", type=float, default=1)
parser.add_argument("--perturb", choices=["G", "Nabc"], type=str, nargs="+", default=None)
parser.add_argument("--plot", action="store_true")
parser.add_argument("--beta", default=None, type=float)
parser.add_argument("--sigmaFhkl", default=1, type=float)
parser.add_argument("--sigmaG", default=1, type=float)
parser.add_argument("--maxiter", default=None, type=int)
parser.add_argument("--geo", action="store_true")
args = parser.parse_args()
import os

if args.kokkos:
    os.environ["DIFFBRAGG_USE_KOKKOS"]="1"
from simtbx.diffBragg.utils import find_diffBragg_instances
from simtbx.diffBragg.device import DeviceWrapper
with DeviceWrapper(0) as _:

    import logging
    import sys
    import pandas
    import numpy as np

    from cctbx import miller
    from dials.array_family import flex
    from simtbx.nanoBragg.nanoBragg_crystal import NBcrystal
    from simtbx.nanoBragg.sim_data import SimData
    from simtbx.diffBragg import hopper_utils
    from simtbx.diffBragg import utils
    from simtbx.diffBragg.hopper_ensemble_utils import load_inputs
    from dxtbx.model import Experiment
    from simtbx.nanoBragg import make_imageset
    from simtbx.diffBragg.phil import hopper_phil, philz
    from libtbx.phil import parse

    phil_scope = parse(hopper_phil+philz)


    p65_cryst = {'__id__': 'crystal',
                 'real_space_a': (43.32309880004587, 25.5289818883498, 60.49634260901813),
                 'real_space_b': (34.201635357808115, -38.82573591182249, -59.255697149884924),
                 'real_space_c': (41.42476391176581, 229.70849483520402, -126.60059788183489),
                 'space_group_hall_symbol': ' P 65 2 (x,y,z+1/12)',
                 'ML_half_mosaicity_deg': 0.06671930026192037,
                 'ML_domain_size_ang': 6349.223840307989}
    from dxtbx.model.crystal import CrystalFactory
    p65_C = CrystalFactory.from_dict(p65_cryst)
    ucell = p65_C.get_unit_cell().parameters()
    symbol = p65_C.get_space_group().info().type().lookup_symbol()

    # Setup the simulation and create a realistic image
    # with background and noise
    # <><><><><><><><><><><><><><><><><><><><><><><><><>
    nbcryst = NBcrystal()
    nbcryst.dxtbx_crystal = p65_C
    nbcryst.thick_mm = 0.005
    nbcryst.isotropic_ncells = False
    NCELLS_GT = 12,12,11
    nbcryst.Ncells_abc = NCELLS_GT
    nbcryst.space_group = "P6522"
    ma = utils.make_miller_array(symbol, ucell, d_min=1.5)
    np.random.seed(0)
    new_data = ma.d_spacings().data()*10

    ma = miller.array(ma.set(), new_data).set_observation_type_xray_amplitude()
    ma_map = {h:v for h,v in zip(ma.indices(), ma.data())}
    nbcryst.miller_array = ma
    assert ma.is_xray_amplitude_array()

    SIM = SimData(use_default_crystal=False)
    shape = 1000, 1001
    detdist = 140
    SIM.detector = SimData.simple_detector(detdist, 0.1, shape)
    SIM.crystal = nbcryst
    SIM.instantiate_diffBragg(oversample=1, auto_set_spotscale=True, default_F=0)

    # test the code for computing the acerage structure factor intensity with resolution
    # (this is why we set the structure factor data to be the same as the resolution (x10)
    num_dspace_bins = 10
    SIM.set_dspace_binning(num_dspace_bins, verbose=True)
    dspace_bins = SIM.D.dspace_bins
    ave_I_cell = SIM.D.ave_I_cell()[0]
    assert len(ave_I_cell) == num_dspace_bins
    assert len(dspace_bins) == num_dspace_bins + 1
    aves = []
    dspaces = []
    for i, (d1,d2) in enumerate(zip(dspace_bins, dspace_bins[1:])):
        ave_val = np.sqrt(ave_I_cell[i]) / 10.
        if not args.geo: assert d1 < ave_val < d2
        aves.append(ave_val)
        dspaces.append(.5*(d1+d2))

    print("1 0 7: ", ma.value_at_index((1,0,7)))
    SIM.D.default_F = 0
    SIM.D.F000 = 0
    SIM.D.progress_meter = False
    SIM.water_path_mm = 0.005
    SIM.air_path_mm = 0.1
    SIM.add_air = True
    SIM.add_Water = True
    SIM.include_noise = True
    SIM.D.verbose = 2
    SIM.D.add_diffBragg_spots()
    SIM.D.verbose = 0
    spots = SIM.D.raw_pixels.as_numpy_array()
    SIM._add_background()
    SIM.D.readout_noise_adu=args.readout
    SIM._add_noise()

    # This is the ground truth image:
    img = SIM.D.raw_pixels.as_numpy_array()
    if args.plot:
        import pylab as plt
        plt.imshow(img, vmax=100)
        plt.title("Ground truth image")
        plt.figure()
        plt.plot(dspaces, aves)
        plt.xlabel("Angstrom")
        plt.show()
    SIM.D.raw_pixels *= 0
    #pfs = 0,270,175
    #utils.show_diffBragg_state(SIM.D, pfs)
    SIM.D.raw_pixels *= 0

    P = phil_scope.extract()
    P.debug_mode=True
    E = Experiment()

    P.init.G = SIM.D.spot_scale
    E.crystal = p65_C

    P.init.Nabc = SIM.crystal.Ncells_abc
    P.init.detz_shift = 0

    E.detector = SIM.detector
    E.beam = SIM.D.beam
    E.imageset = make_imageset([img], E.beam, E.detector)
    refls = utils.refls_from_sims([spots], E.detector, E.beam, thresh=18)
    print("%d REFLS" % len(refls))
    utils.refls_to_q(refls, E.detector, E.beam, update_table=True)
    utils.refls_to_hkl(refls, E.detector, E.beam, E.crystal, update_table=True)

    P.roi.shoebox_size = 10
    P.roi.allow_overlapping_spots = True
    P.relative_tilt = False
    P.roi.fit_tilt = False
    P.roi.pad_shoebox_for_background_estimation=10
    P.roi.reject_edge_reflections = False
    P.refiner.sigma_r = SIM.D.readout_noise_adu
    P.refiner.adu_per_photon = SIM.D.quantum_gain
    P.simulator.init_scale = 1
    P.simulator.beam.size_mm = SIM.beam.size_mm
    P.simulator.oversample = SIM.D.oversample
    P.simulator.total_flux = SIM.D.flux
    P.use_restraints = False


    mset = ma.set()
    ma_map_keys, ma_map_values = list(ma_map.keys()), np.array(list(ma_map.values()))
    ma_map_values2 = np.random.normal(ma_map_values, scale=args.scale*ma_map_values)
    bad_map = {h:v for h,v in zip(ma_map_keys, ma_map_values2)}
    if args.scale ==0:
        assert np.allclose(ma_map_values, ma_map_values2)

    new_amps = flex.double()
    for h in mset.indices():
        amp = bad_map[h]
        new_amps.append(amp)

    ma2 = miller.array(mset, new_amps).set_observation_type_xray_amplitude()

    ma2_map = {h:v for h,v in zip(ma2.indices(), ma2.data())}
    name = "hopper_refine_Fhkl.mtz"
    print("1 0 7: ", ma2.value_at_index((1,0,7)))
    assert ma2.is_xray_amplitude_array()
    ma2.as_mtz_dataset(column_root_label="F").mtz_object().write(name)
    P.simulator.structure_factors.mtz_name = name
    P.simulator.structure_factors.mtz_column = "F(+),F(-)"
    P.logging.parameters=False
    P.method="L-BFGS-B"
    P.ftol = 1e-10
    P.space_group = symbol
    P.fix.Fhkl = False
    P.betas.Fhkl = args.beta
    P.fix.G = True
    P.types.G = "positive"
    P.centers.G = SIM.D.spot_scale*2
    P.betas.G=1e8
    P.use_restraints = args.beta is not None
    P.sigmas.G = args.sigmaG
    P.sigmas.Fhkl = args.sigmaFhkl
    if args.perturb is not None and "G" in args.perturb:
        P.fix.G = False
        P.init.G = SIM.D.spot_scale*10
        #P.maxs.G = SIM.D.spot_scale*100
    P.use_geometric_mean_Fhkl = args.geo
    P.fix.ucell=True
    P.fix.RotXYZ=True
    P.fix.Nabc=True
    if args.perturb is not None and "Nabc" in args.perturb:
        P.fix.Nabc = False
        P.init.Nabc = 20,20,18
    P.fix.detz_shift=True

    if not args.nolog:
        h = logging.StreamHandler(sys.stdout)
        logging.basicConfig(level=logging.DEBUG, handlers=[h])
    #del SIM.D

    P.outdir="_temp_fhkl_refine"
    if args.maxiter is not None:
        P.lbfgs_maxiter = args.maxiter
    P.record_device_timings = True
    Eopt,_, Mod,SIM_from_hopper, x = hopper_utils.refine(E, refls, P, return_modeler=True, free_mem=False)
    SIM_from_hopper.D.show_timings(0)

    logging.disable()
    print("\nResults\n<><><><><><>")

    Mod.exper_name = "dummie.expt"
    Mod.refl_name = "dummie.refl"
    Mod.save_up(x, SIM_from_hopper)

    # we can track the dominant hkls in each shoebox occuring within the diffBragg model
    #count_stats = utils.track_fhkl(Mod)
    #
    #
    #main_hkls = []
    #for i_roi in count_stats:
    #    stats = count_stats[i_roi]
    #    stats = sorted( list(stats.items()), key=lambda x: x[1])
    #    main_hkl, frac = stats[-1]
    #    print(main_hkl, frac)
    #    main_hkls.append(main_hkl)

    # this should agree with what we put into diffBragg in the reflection tables
    main_hkls_from_refls = utils.map_hkl_list(list(Mod.refls["miller_index"]), symbol=P.space_group)
    #assert len(set(main_hkls)) == len(set(main_hkls_from_refls))
    # good.

    # Now, this should also agree with the refined fhkl values, stored in the data table
    # the modeler save_up method creates an output file containing the refined fhkl values

    fnames = glob.glob("%s/Fhkl_scale/rank*/*.npz" % P.outdir)
    assert len(fnames)==1
    fhkl_f= fnames[0]
    fhkl_dat = np.load(fhkl_f)
    asu = list(map(tuple,fhkl_dat['asu_hkl']))
    asu_corrections = fhkl_dat['scale_fac']
    asu_corrections_var = fhkl_dat['scale_var']
    asu_is_nominal = fhkl_dat["is_nominal_hkl"]
    scale = {h:s for h,s in zip(asu, asu_corrections)}
    scale_var = {h:s for h,s in zip(asu, asu_corrections_var)}
    is_nominal = {h:is_nom for h,is_nom in zip(asu,  asu_is_nominal)}

    num_not_nominal = 0
    # TODO: figure out why some main_hkls are missing from is_nominal
    for hkl in main_hkls_from_refls:
        if hkl not in is_nominal:
            continue
        if not is_nominal[hkl]:
            num_not_nominal += 1

    nominal_hkl_corrections = {h:s for h,s in zip(asu, asu_corrections) if is_nominal[h]}
    not_nominal_hkl_corrections = {h:s for h,s in zip(asu, asu_corrections) if not is_nominal[h]}

    nominal_hkl_init = {h:1 for h in asu if is_nominal[h]}
    not_nominal_hkl_init = {h:1 for h in asu if not is_nominal[h]}


    def compute_r_factor_with_gt(corrections):
        gt_data = flex.double()
        opt_data = flex.double()
        flx_hkls = flex.miller_index()
        for hkl, scale in corrections.items():
            gt_amp = ma_map[hkl]
            gt_data.append(gt_amp)

            opt_amp = np.sqrt(scale) * ma2_map[hkl]
            opt_data.append(opt_amp)

            h,k,l = map(int, hkl)
            flx_hkls.append((h,k,l))
        mset = ma.miller_set(flx_hkls, ma.anomalous_flag())
        gt_arr = miller.array(mset, gt_data).set_observation_type_xray_amplitude()
        opt_arr = miller.array(mset, opt_data).set_observation_type_xray_amplitude()
        return gt_arr.r1_factor(opt_arr)


    r1_nominal_init = compute_r_factor_with_gt(nominal_hkl_init)
    r1_nominal = compute_r_factor_with_gt(nominal_hkl_corrections)

    r1_not_nominal_init = compute_r_factor_with_gt(not_nominal_hkl_init)
    r1_not_nominal = compute_r_factor_with_gt(not_nominal_hkl_corrections)

    print("\nResults\n<><><><><><>")
    print("For the dominant HKLs within each modeled shoebox (e.g. those with indexed reflections)")
    print("initial R1 factor=%.2f%%" % (r1_nominal_init*100))
    print("optimized R1 factor=%.2f%%" % (r1_nominal*100))

    diffs = []
    all_opts = []
    all_gts = []
    dsp_map = {d:val for d,val in zip(ma.d_spacings().indices(), ma.d_spacings().data())}
    ds = []
    for hkl in nominal_hkl_corrections:
        dsp = dsp_map[hkl]
        gt_val = ma_map[hkl]
        opt_val = np.sqrt(nominal_hkl_corrections[hkl]) * ma2_map[hkl]
        d = abs(gt_val - opt_val) / gt_val * 100
        diffs.append(d)

        all_opts.append(opt_val)
        all_gts.append(gt_val)
        ds.append(dsp)

    print("mean percent diff", np.mean(diffs))

    assert r1_nominal < r1_nominal_init, "r1_nom=%f, r1_not_nom=%f" %(r1_nominal, r1_nominal_init)
    assert r1_nominal < 0.04

    # test hopper_ensemble_refiner using this one shot
    # dump the refinement data to the reflection table format (e.g. the pixel data and background estimates)
    input_refl = os.path.join(P.outdir, "input_data.refl")
    Mod.dump_gathered_to_refl(input_refl)
    df = pandas.read_pickle("%s/pandas/rank0/stage1_dummie_0.pkl"% P.outdir)
    refl_col = "input_refls"
    df[refl_col] = [input_refl]
    P.refiner.load_data_from_refl = True
    P.refiner.check_expt_format = False

    #from simtbx.diffBragg import mpi_logger
    #P.logging.rank0_level="high"
    #mpi_logger.setup_logging_from_params(P)
    modelers = load_inputs(df, P, exper_key="opt_exp_name", refls_key=refl_col)
    modelers.outdir=P.outdir
    modelers.prep_for_refinement()
    print("Minimizing using hopper_ensemble_utils...")
    modelers.Minimize(save=True)
    if modelers.SIM.D.record_timings:
        modelers.SIM.D.show_timings(MPI_RANK=0)
    print("Done!")

    from iotbx.reflection_file_reader import any_reflection_file
    opt_F = any_reflection_file("_temp_fhkl_refine/optimized_channel0.mtz").as_miller_arrays()[0]
    opt_map = {h:v for h,v in zip(opt_F.indices(), opt_F.data())}
    hcommon = set(ma_map).intersection(opt_map)

    mset_common = ma.miller_set(flex.miller_index(list(hcommon)), ma.anomalous_flag())
    ma_vals = flex.double([ma_map[h] for h in hcommon])
    opt_vals = flex.double([opt_map[h] for h in hcommon])

    ma_common = miller.array(mset_common, ma_vals).set_observation_type_xray_amplitude()
    opt_common = miller.array(mset_common, opt_vals).set_observation_type_xray_amplitude()
    r1 = ma_common.r1_factor(opt_common)
    assert r1 < 0.04

    print("OK")
    del modelers.SIM.D
    del SIM_from_hopper.D
    for name in find_diffBragg_instances(globals()): del globals()[name]


 *******************************************************************************
