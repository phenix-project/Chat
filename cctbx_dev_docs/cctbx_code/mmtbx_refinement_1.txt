

 *******************************************************************************
mmtbx/refinement/orca.py
from __future__ import absolute_import, division, print_function
import cctbx.geometry_restraints
from cctbx.array_family import flex
import scitbx.graph.tardy_tree
from scitbx import matrix
from libtbx.math_utils import nested_loop
from six.moves import zip

def expand_model_or_conformer_indices(
      indices,
      x_n_seq,
      related_x_i_seqs):
  result = flex.size_t(x_n_seq, x_n_seq)
  for i_seq,i in enumerate(indices):
    result.set_selected(related_x_i_seqs[i_seq], i)
  assert result.count(x_n_seq) == 0
  return result

def expand_site_symmetry_table(
      site_symmetry_table,
      x_n_seq,
      related_x_i_seqs):
  x_indices = flex.size_t(x_n_seq, x_n_seq)
  for i_seq,i in enumerate(site_symmetry_table.indices()):
    x_indices.set_selected(related_x_i_seqs[i_seq], i)
  assert x_indices.count(x_n_seq) == 0
  return cctbx.sgtbx.site_symmetry_table(
    indices=x_indices,
    table=site_symmetry_table.table(),
    special_position_indices=(x_indices == 0).iselection())
  return result

def expand_bond_params_table(
      bond_params_table,
      x_n_seq,
      related_x_i_seqs):
  result = cctbx.geometry_restraints.bond_params_table(x_n_seq)
  for i_seq,bond_params_dict in enumerate(bond_params_table):
    x_i_seqs = related_x_i_seqs[i_seq]
    for j_seq,bond_params in bond_params_dict.items():
      x_j_seqs = related_x_i_seqs[j_seq]
      bond_params_scaled = bond_params.scale_weight(factor=1/
        (len(x_i_seqs)*len(x_j_seqs)))
      for x_i_seq in x_i_seqs:
        for x_j_seq in x_j_seqs:
          if (x_i_seq <= x_j_seq):
            assert x_j_seq not in result[x_i_seq]
            result[x_i_seq][x_j_seq] = bond_params_scaled
          else:
            assert x_i_seq not in result[x_j_seq]
            result[x_j_seq][x_i_seq] = bond_params_scaled
  return result

def expand_pair_sym_table(
      pair_sym_table,
      x_n_seq,
      related_x_i_seqs):
  result = cctbx.crystal.pair_sym_table(x_n_seq)
  for i_seq,pair_sym_dict in enumerate(pair_sym_table):
    x_i_seqs = related_x_i_seqs[i_seq]
    for j_seq,sym_ops in pair_sym_dict.items():
      x_j_seqs = related_x_i_seqs[j_seq]
      for x_i_seq in x_i_seqs:
        for x_j_seq in x_j_seqs:
          if (x_i_seq <= x_j_seq):
            x_sym_ops = result[x_i_seq].setdefault(
              x_j_seq, cctbx.sgtbx.stl_vector_rt_mx())
            for sym_op in sym_ops:
              x_sym_ops.append(sym_op)
          else:
            x_sym_ops = result[x_j_seq].setdefault(
              x_i_seq, cctbx.sgtbx.stl_vector_rt_mx())
            for sym_op in sym_ops:
              x_sym_ops.append(sym_op.inverse())
  return result

def expand_nonbonded_types(
      nonbonded_types,
      x_n_seq,
      related_x_i_seqs):
  result = flex.std_string(x_n_seq)
  for i_seq,s in enumerate(nonbonded_types):
    result.set_selected(related_x_i_seqs[i_seq], s)
  return result

def expand_angle_proxies(
      angle_proxies,
      x_n_seq,
      related_x_i_seqs):
  result = cctbx.geometry_restraints.shared_angle_proxy()
  angle_proxy_t = cctbx.geometry_restraints.angle_proxy
  for proxy in angle_proxies:
    i,j,k = proxy.i_seqs
    proxy_scaled = proxy.scale_weight(factor=1/(
        len(related_x_i_seqs[i])
      * len(related_x_i_seqs[j])
      * len(related_x_i_seqs[k])))
    for x_i in related_x_i_seqs[i]:
      for x_j in related_x_i_seqs[j]:
        for x_k in related_x_i_seqs[k]:
          result.append(angle_proxy_t(
            i_seqs=(x_i,x_j,x_k), proxy=proxy_scaled).sort_i_seqs())
  return result

def expand_dihedral_or_chirality_proxies(
      proxies,
      proxy_type,
      proxy_array_type,
      x_n_seq,
      related_x_i_seqs):
  result = proxy_array_type()
  for proxy in proxies:
    i,j,k,l = proxy.i_seqs
    proxy_scaled = proxy.scale_weight(factor=1/(
        len(related_x_i_seqs[i])
      * len(related_x_i_seqs[j])
      * len(related_x_i_seqs[k])
      * len(related_x_i_seqs[l])))
    for x_i in related_x_i_seqs[i]:
      for x_j in related_x_i_seqs[j]:
        for x_k in related_x_i_seqs[k]:
          for x_l in related_x_i_seqs[l]:
            result.append(proxy_type(
              i_seqs=(x_i,x_j,x_k,x_l), proxy=proxy_scaled).sort_i_seqs())
  return result

def expand_planarity_proxies(
      planarity_proxies,
      x_n_seq,
      related_x_i_seqs):
  result = cctbx.geometry_restraints.shared_planarity_proxy()
  planarity_proxy_t = cctbx.geometry_restraints.planarity_proxy
  for proxy in planarity_proxies:
    x_i_seqs_list = [tuple(related_x_i_seqs[i_seq]) for i_seq in proxy.i_seqs]
    loop_n = [len(x_i_seqs) for x_i_seqs in x_i_seqs_list]
    sym_ops = proxy.sym_ops
    weights = proxy.weights / matrix.col(loop_n).product()
    for loop_i in nested_loop(loop_n):
      i_seqs = flex.size_t([x_i_seqs[i]
        for x_i_seqs,i in zip(x_i_seqs_list, loop_i)])
      result.append(planarity_proxy_t(
        i_seqs=i_seqs, sym_ops=sym_ops, weights=weights).sort_i_seqs())
  return result

class expand(object):

  def __init__(O, labels, sites_cart, masses, geo_manager):
    from scitbx.array_family import shared
    edge_list = geo_manager.simple_edge_list(omit_slack_greater_than=0)
    tt = scitbx.graph.tardy_tree.construct(
      n_vertices=len(sites_cart),
      edge_list=edge_list,
      external_clusters=geo_manager.rigid_clusters_due_to_dihedrals_and_planes(
        constrain_dihedrals_with_sigma_less_than=10))
    orcs = tt.cluster_manager.overlapping_rigid_clusters(
      edge_sets=tt.edge_sets)
    O.labels = flex.std_string()
    O.sites_cart = flex.vec3_double()
    O.masses = flex.double()
    O.indices = []
    O.external_clusters = []
    O.related_x_i_seqs = shared.stl_vector_unsigned(sites_cart.size())
    orca_dof = 0
    for i_orc,orc in enumerate(orcs):
      external_cluster = []
      for i_seq in orc:
        x_i_seq = len(O.sites_cart)
        O.related_x_i_seqs[i_seq].append(x_i_seq)
        external_cluster.append(x_i_seq)
        O.labels.append("%s:%d" % (labels[i_seq], i_orc))
        O.sites_cart.append(sites_cart[i_seq])
        O.masses.append(masses[i_seq])
        O.indices.append((i_orc, i_seq))
      O.external_clusters.append(external_cluster)
      if (len(orc) == 1):
        orca_dof += 3
      elif (len(orc) == 2):
        orca_dof += 5
      else:
        orca_dof += 6
    print("sites_cart.size():", sites_cart.size())
    print("O.sites_cart.size():", O.sites_cart.size())
    print("original Cartesian dof:", sites_cart.size()*3)
    print("orca dof:", orca_dof)
    for i_seq,x_i_seqs in enumerate(O.related_x_i_seqs):
      O.masses /= len(x_i_seqs)
    # XXX find more direct way to get x_edge_list
    x_edge_list = []
    for i,j in edge_list:
      for x_i in O.related_x_i_seqs[i]:
        i_orc = O.indices[x_i][0]
        for x_j in O.related_x_i_seqs[j]:
          j_orc = O.indices[x_j][0]
          if (i_orc == j_orc):
            x_edge_list.append(tuple(sorted((x_i,x_j))))
    O.tardy_tree = scitbx.graph.tardy_tree.construct(
      sites=O.sites_cart,
      edge_list=x_edge_list,
      external_clusters=O.external_clusters)
    x_model_indices = expand_model_or_conformer_indices(
      indices=geo_manager.model_indices,
      x_n_seq=O.sites_cart.size(),
      related_x_i_seqs=O.related_x_i_seqs)
    x_conformer_indices = expand_model_or_conformer_indices(
      indices=geo_manager.conformer_indices,
      x_n_seq=O.sites_cart.size(),
      related_x_i_seqs=O.related_x_i_seqs)
    x_site_symmetry_table = expand_site_symmetry_table(
      site_symmetry_table=geo_manager.site_symmetry_table,
      x_n_seq=O.sites_cart.size(),
      related_x_i_seqs=O.related_x_i_seqs)
    x_bond_params_table = expand_bond_params_table(
      bond_params_table=geo_manager.bond_params_table,
      x_n_seq=O.sites_cart.size(),
      related_x_i_seqs=O.related_x_i_seqs)
    x_shell_sym_tables = []
    for shell_sym_table in geo_manager.shell_sym_tables:
      x_shell_sym_tables.append(expand_pair_sym_table(
        pair_sym_table=shell_sym_table,
        x_n_seq=O.sites_cart.size(),
        related_x_i_seqs=O.related_x_i_seqs))
    x_nonbonded_types = expand_nonbonded_types(
      nonbonded_types=geo_manager.nonbonded_types,
      x_n_seq=O.sites_cart.size(),
      related_x_i_seqs=O.related_x_i_seqs)
    x_angle_proxies = expand_angle_proxies(
      angle_proxies=geo_manager.angle_proxies,
      x_n_seq=O.sites_cart.size(),
      related_x_i_seqs=O.related_x_i_seqs)
    x_dihedral_proxies = expand_dihedral_or_chirality_proxies(
      proxies=geo_manager.dihedral_proxies,
      proxy_type=cctbx.geometry_restraints.dihedral_proxy,
      proxy_array_type=cctbx.geometry_restraints.shared_dihedral_proxy,
      x_n_seq=O.sites_cart.size(),
      related_x_i_seqs=O.related_x_i_seqs)
    x_chirality_proxies = expand_dihedral_or_chirality_proxies(
      proxies=geo_manager.chirality_proxies,
      proxy_type=cctbx.geometry_restraints.chirality_proxy,
      proxy_array_type=cctbx.geometry_restraints.shared_chirality_proxy,
      x_n_seq=O.sites_cart.size(),
      related_x_i_seqs=O.related_x_i_seqs)
    x_planarity_proxies = expand_planarity_proxies(
      planarity_proxies=geo_manager.planarity_proxies,
      x_n_seq=O.sites_cart.size(),
      related_x_i_seqs=O.related_x_i_seqs)
    O.geo_manager = cctbx.geometry_restraints.manager.manager(
      crystal_symmetry=geo_manager.crystal_symmetry,
      model_indices=x_model_indices,
      conformer_indices=x_conformer_indices,
      site_symmetry_table=x_site_symmetry_table,
      bond_params_table=x_bond_params_table,
      shell_sym_tables=x_shell_sym_tables,
      nonbonded_params=geo_manager.nonbonded_params,
      nonbonded_types=x_nonbonded_types,
      nonbonded_function=geo_manager.nonbonded_function,
      nonbonded_distance_cutoff=geo_manager.nonbonded_distance_cutoff,
      nonbonded_buffer=geo_manager.nonbonded_buffer,
      angle_proxies=x_angle_proxies,
      dihedral_proxies=x_dihedral_proxies,
      chirality_proxies=x_chirality_proxies,
      planarity_proxies=x_planarity_proxies,
      plain_pairs_radius=geo_manager.plain_pairs_radius,
      max_reasonable_bond_distance=geo_manager.max_reasonable_bond_distance,
      min_cubicle_edge=geo_manager.min_cubicle_edge)
    O.tardy_tree_rmsd_calculator = None

  def rmsd_calculator(O, tardy_tree_rmsd_calculator):
    O.tardy_tree_rmsd_calculator = tardy_tree_rmsd_calculator
    return O.rmsd_calculation

  def rmsd_calculation(O, sites_cart_1, sites_cart_2):
    return O.tardy_tree_rmsd_calculator(
      average_sites_cart(
        related_x_i_seqs=O.related_x_i_seqs, x_sites_cart=sites_cart_1),
      average_sites_cart(
        related_x_i_seqs=O.related_x_i_seqs, x_sites_cart=sites_cart_2))

def average_sites_cart(related_x_i_seqs, x_sites_cart):
  result = flex.vec3_double()
  for x_i_seqs in related_x_i_seqs:
    result.append(x_sites_cart.select(x_i_seqs).mean())
  return result


 *******************************************************************************


 *******************************************************************************
mmtbx/refinement/print_statistics.py
from __future__ import absolute_import, division, print_function
from cctbx.array_family import flex
import scitbx.math.euler_angles
from scitbx import matrix
from libtbx.utils import format_cpu_times, getenv_bool
from libtbx import adopt_init_args, slots_getstate_setstate
import sys, time
from libtbx import str_utils
from libtbx.str_utils import prefix_each_line_suffix, format_value
from libtbx import introspection
import math
from cctbx import xray
import cctbx.xray.structure_factors.global_counters
from libtbx import easy_pickle
from itertools import count
from libtbx import group_args
from six.moves import zip

enable_show_process_info = getenv_bool(
  "MMTBX_PRINT_STATISTICS_ENABLE_SHOW_PROCESS_INFO")

time_collect_and_process = 0.0

def show_times(out = None):
  if(out is None): out = sys.stdout
  total = time_collect_and_process
  if(total > 0.01):
     print("Collect and process                      = %-7.2f" % time_collect_and_process, file=out)
  return total

def show_process_info(out):
  print("\\/"*39, file=out)
  introspection.virtual_memory_info().show_if_available(out=out, show_max=True)
  xray.structure_factors.global_counters.show(out=out)
  print(format_cpu_times(), file=out)
  print("/\\"*39, file=out)
  out.flush()

def make_header(line, out=None):
  if (out is None): out = sys.stdout
  if (enable_show_process_info):
    show_process_info(out=out)
  str_utils.make_header(line, out=out, header_len=80)

def make_sub_header(text, out=None):
  if (out is None): out = sys.stdout
  str_utils.make_sub_header(text, out=out, header_len=80)

def macro_cycle_header(macro_cycle, number_of_macro_cycles, out=None):
  if (out is None): out = sys.stdout
  #show_process_info(out=out)
  header_len = 80
  macro_cycle = str(macro_cycle)
  number_of_macro_cycles = str(number_of_macro_cycles)
  macro_cycle_str = len(macro_cycle)
  number_of_macro_cycles_str = len(number_of_macro_cycles)
  line_len = len(" REFINEMENT MACRO_CYCLE "+macro_cycle+" OF "+\
             number_of_macro_cycles)+1
  fill_len = header_len - line_len
  fill_rl = fill_len//2
  fill_r = fill_rl
  fill_l = fill_rl
  if (fill_rl*2 != fill_len): fill_r +=1
  str1 = "\n"+"*"*(fill_l-1)+" REFINEMENT MACRO_CYCLE "+macro_cycle+" OF "
  str2 = number_of_macro_cycles+" "+"*"*(fill_r)+"\n"
  out_string = str1+str2
  print(out_string, file=out)
  out.flush()

def show_rigid_body_rotations_and_translations(
      out,
      prefix,
      frame,
      euler_angle_convention,
      rotations,
      translations):
  assert euler_angle_convention in ["xyz", "zyz"]
  euler_angles_as_matrix = getattr(
    scitbx.math.euler_angles, euler_angle_convention+"_matrix")
  print(prefix_each_line_suffix(
    prefix=prefix+frame, lines_as_one_string=
"                            rotation (deg)                 translation (A)   "
"\n"
"                         %s              total           xyz          total "
      % euler_angle_convention, suffix=frame), file=out)
  for i,r,t in zip(count(1), rotations, translations):
    r = list(r)
    r.reverse()
    r_total = abs(scitbx.math.r3_rotation_axis_and_angle_from_matrix(
      r=euler_angles_as_matrix(*r)).angle(deg=True))
    t_total = abs(matrix.col(t))
    print((prefix + frame +
      " group %4d: %8.3f %8.3f %8.3f %7.2f  %6.2f %6.2f %6.2f %6.2f "
        % tuple([i] + r + [r_total] + list(t) + [t_total])
      + frame).rstrip(), file=out)
  out.flush()

# these are the steps we actually want to display in the GUI
show_actions = {
   "bss" : "bss",
   "sol" : "sol",
   "ion" : "ion",
   "rbr" : "rbr",
   "realsrl" : "rsrl",
   "realsrg" : "rsrg",
   "den" : "den",
   "tardy" : "SA",
   "sacart" : "SA",
   "xyzrec" : "xyz",
   "adp" : "adp",
   "occ" : "occ",
   "fp_fdp" : "anom",
}

class refinement_monitor(object):
  __arrays__ = [
    "steps",
    "r_works",
    "r_frees",
    "geom",
    "bs_iso_max_a",
    "bs_iso_min_a",
    "bs_iso_ave_a",
    "n_solv",
    "shifts",
  ]

  def __init__(
        self,
        params,
        out=None,
        neutron_refinement = None,
        call_back_handler=None,
        is_neutron_monitor=False):
    adopt_init_args(self, locals())
    if (self.out is None): self.out = sys.stdout
    self.wilson_b = None
    self.bond_start = None
    self.angle_start= None
    self.bond_final = None
    self.angle_final= None
    self.rigid_body_shift_accumulator = None
    self.sites_cart_start = None
    for name in self.__arrays__ :
      setattr(self, name, [])
    self.is_amber_monitor = False
    self.geom = group_args(bonds=[], angles=[])

  def dump_statistics(self, file_name):
    stats = {}
    for name in self.__arrays__ :
      stats[name] = getattr(self, name)
    easy_pickle.dump(file_name, stats)

  def collect(self, model,
                    fmodel,
                    step,
                    wilson_b = None,
                    rigid_body_shift_accumulator = None):
    global time_collect_and_process
    t1 = time.time()
    if(self.sites_cart_start is None):
      self.sites_cart_start = model.get_sites_cart()
    sites_cart_curr = model.get_sites_cart()
    if(sites_cart_curr.size()==self.sites_cart_start.size()):
      self.shifts.append(
        flex.mean(flex.sqrt((self.sites_cart_start-sites_cart_curr).dot())))
    else: self.shifts.append("n/a")
    if(wilson_b is not None): self.wilson_b = wilson_b
    self.steps.append(step)
    self.r_works.append(fmodel.r_work())
    self.r_frees.append(fmodel.r_free())
    use_amber = False
    if hasattr(self.params, "amber"): # loaded amber scope
      use_amber = self.params.amber.use_amber
      self.is_amber_monitor=use_amber
    use_afitt = False
    if hasattr(self.params, "afitt"): # loaded amber scope
      use_afitt = self.params.afitt.use_afitt
    general_selection = None
    if use_afitt:
      from mmtbx.geometry_restraints import afitt
      general_selection = afitt.get_non_afitt_selection(
        model.restraints_manager,
        model.get_sites_cart(),
        model.get_hd_selection(),
        None)
    geom = model.geometry_statistics()
    if(geom is not None):
      self.geom.bonds.append(geom.bond().mean)
      self.geom.angles.append(geom.angle().mean)
    hd_sel = None
    if(not self.neutron_refinement and not self.is_neutron_monitor):
      hd_sel = model.get_hd_selection()
    b_isos = model.get_xray_structure().extract_u_iso_or_u_equiv() * math.pi**2*8
    if(hd_sel is not None): b_isos = b_isos.select(~hd_sel)
    self.bs_iso_max_a.append(flex.max_default( b_isos, 0))
    self.bs_iso_min_a.append(flex.min_default( b_isos, 0))
    self.bs_iso_ave_a.append(flex.mean_default(b_isos, 0))
    self.n_solv.append(model.number_of_ordered_solvent_molecules())
    if(len(self.geom.bonds)>0):
      if([self.bond_start,self.angle_start].count(None) == 2):
        if(len(self.geom.bonds)>0):
          self.bond_start  = self.geom.bonds[0]
          self.angle_start = self.geom.angles[0]
      if(len(self.geom.bonds)>0):
        self.bond_final  = self.geom.bonds[len(self.geom.bonds)-1]
        self.angle_final = self.geom.angles[len(self.geom.angles)-1]
      elif(len(self.geom)==1):
        self.bond_final  = self.geom.bonds[0]
        self.angle_final = self.geom.angles[0]
    if(rigid_body_shift_accumulator is not None):
      self.rigid_body_shift_accumulator = rigid_body_shift_accumulator
    t2 = time.time()
    time_collect_and_process += (t2 - t1)
    self.call_back(model, fmodel, method=step)

  def call_back(self, model, fmodel, method="monitor_collect"):
    if self.call_back_handler is not None and callable(self.call_back_handler):
      self.call_back_handler(self, model, fmodel, method)

  def show(self, out=None, remark=""):
    global time_collect_and_process
    t1 = time.time()
    max_step_len = max([len(s) for s in self.steps])
    if(out is None): out = self.out
    separator = "-"*72
    if(self.rigid_body_shift_accumulator is not None):
      print(remark + "Information about total rigid body shift of selected groups:", file=out)
      show_rigid_body_rotations_and_translations(
        out=out,
        prefix=remark,
        frame=" ",
        euler_angle_convention
          =self.rigid_body_shift_accumulator.euler_angle_convention,
        rotations=self.rigid_body_shift_accumulator.rotations,
        translations=self.rigid_body_shift_accumulator.translations)
    #
    print(remark + "****************** REFINEMENT STATISTICS STEP BY STEP ******************", file=out)
    print(remark + "leading digit, like 1_, means number of macro-cycle                     ", file=out)
    print(remark + "0    : statistics at the very beginning when nothing is done yet        ", file=out)
    if(self.params.main.bulk_solvent_and_scale):
       print(remark + "1_bss: bulk solvent correction and/or (anisotropic) scaling             ", file=out)
    if("individual_sites" in self.params.refine.strategy):
       print(remark + "1_xyz: refinement of coordinates                                        ", file=out)
    if("individual_adp" in self.params.refine.strategy):
       print(remark + "1_adp: refinement of ADPs (Atomic Displacement Parameters)              ", file=out)
    if(self.params.main.simulated_annealing):
       print(remark + "1_sar: simulated annealing refinement of x,y,z                          ", file=out)
    if(self.params.main.ordered_solvent):
       print(remark + "1_wat: ordered solvent update (add / remove)                            ", file=out)
    if("rigid_body" in self.params.refine.strategy):
       print(remark + "1_rbr: rigid body refinement                                            ", file=out)
    if("group_adp" in self.params.refine.strategy):
       print(remark + "1_gbr: group B-factor refinement                                        ", file=out)
    if("occupancies" in self.params.refine.strategy):
       print(remark + "1_occ: refinement of occupancies                                        ", file=out)
    print(remark + separator, file=out)
    #
    has_bonds_angles=True
    if len(self.geom.bonds):
      print(remark + \
        " stage r-work r-free bonds angles b_min b_max b_ave n_water shift", file=out)
      format = remark + "%s%ds"%("%",max_step_len)+\
        " %6.4f %6.4f %5.3f %6.3f %5.1f %5.1f %5.1f %3d %s"
    else:
      print(remark + \
        " stage       r-work r-free b_min b_max b_ave n_water shift", file=out)
      format = remark + "%s%ds"%("%",max_step_len)+\
        " %6.4f %6.4f %5.1f %5.1f %5.1f %3d %s"
    for a,b,c, d1,d2, e,f,g,h,i in zip(self.steps,
                                   self.r_works,
                                   self.r_frees,
                                   self.geom.bonds,
                                   self.geom.angles,
                                   self.bs_iso_min_a,
                                   self.bs_iso_max_a,
                                   self.bs_iso_ave_a,
                                   self.n_solv,
                                   self.shifts):
        if(type(1.)==type(i)): i = "     "+str("%5.3f"%i)
        else: i = "%9s"%i
        if has_bonds_angles:
          print(format % (a,b,c,d1,d2,e,f,g,h,i), file=out)
        else:
          print(format % (a,b,c,e,f,g,h,i), file=out)
    print(remark + separator, file=out)
    out.flush()
    #
    t2 = time.time()
    time_collect_and_process += (t2 - t1)

  def format_stats_for_phenix_gui(self):
    steps = []
    r_works = []
    r_frees = []
    as_ave = []
    bs_ave = []
    for i_step, label in enumerate(self.steps):
      label = label.replace(":", "")
      fields = label.split("_")
      if (len(fields) < 2):
        steps.append(label)
      else :
        cycle = fields[0]
        action = "_".join(fields[1:])
        action_label = show_actions.get(action, None)
        if (action_label is None) : continue
        steps.append(cycle + "_" + action_label)
      r_works.append(self.r_works[i_step])
      r_frees.append(self.r_frees[i_step])
      if (self.geom is not None) and (len(self.geom.bonds) != 0):
        as_ave.append(self.geom.angles[i_step])
        bs_ave.append(self.geom.bonds[i_step])
      else :
        as_ave.append(None)
        bs_ave.append(None)
    return stats_table(
      steps=steps,
      r_works=r_works,
      r_frees=r_frees,
      as_ave=as_ave,
      bs_ave=bs_ave,
      neutron_flag=self.is_neutron_monitor)

  def show_current_r_factors_summary(self, out, prefix=""):
    if (len(self.steps) == 0):
      return
    last_step = self.steps[-1].replace(":", "")
    fields = last_step.split("_")
    action_label = None
    if (len(fields) >= 2):
      cycle = fields[0]
      action = "_".join(fields[1:])
      action_label = show_actions.get(action, None)
      if (action_label is None):
        return
      action_label = cycle + "_" + action_label
    if (action_label is None):
      if (len(self.steps) == 1):
        action_label = "start"
      else :
        action_label = "end"
    print("%s%-6s  r_work=%s  r_free=%s" % (prefix,
      action_label,
      format_value("%.4f", self.r_works[-1]),
      format_value("%.4f", self.r_frees[-1])), file=out)

class stats_table(slots_getstate_setstate):
  __slots__ = [
    "steps",
    "r_works",
    "r_frees",
    "as_ave",
    "bs_ave",
    "neutron_flag",
  ]
  def __init__(self, **kwds):
    for attr in self.__slots__ :
      setattr(self, attr, kwds.get(attr))

# we need something simpler for the Phenix GUI...
class coordinate_shifts(object):
  def __init__(self, hierarchy_start, hierarchy_end):
    from scitbx.array_family import flex
    self.hierarchy_shifted = hierarchy_end.deep_copy()
    atoms_shifted = self.hierarchy_shifted.atoms()
    coords_start = {}
    for atom in hierarchy_start.atoms():
      id_str = atom.fetch_labels().id_str()
      coords_start[id_str] = atom.xyz
    def get_distance(xyz1, xyz2):
      x1,y1,z1 = xyz1
      x2,y2,z2 = xyz2
      return math.sqrt((x2-x1)**2 + (y2-y1)**2 + (z2-z1)**2)
    for i_seq, atom in enumerate(atoms_shifted):
      id_str = atom.fetch_labels().id_str()
      if (id_str in coords_start):
        atom.b = get_distance(coords_start[id_str], atom.xyz)
      else :
        atom.b = -1.0

  def get_shifts(self):
    return self.hierarchy_shifted.atoms().extract_b()

  def min_max_mean(self):
    shifts = self.hierarchy_shifted.atoms().extract_b()
    shifts = shifts.select(shifts >= 0)
    return shifts.min_max_mean()

  def save_pdb_file(self, file_name):
    f = open(file_name, "w")
    f.write(self.hierarchy_shifted.as_pdb_string())
    f.close()

class trajectory_output(object):
  """
  Callback object for saving the intermediate results of refinement as a stack
  of PDB and MTZ files.  Equivalent to the interactivity with Coot in the
  Phenix GUI, but intended for command-line use and demonstrative purposes.
  """
  def __init__(self, file_base="refine", filled_maps=True, log=sys.stdout,
      verbose=True):
    adopt_init_args(self, locals())
    self._i_trajectory = 0

  def __call__(self, monitor, model, fmodel, method="monitor_collect"):
    import iotbx.map_tools
    self._i_trajectory += 1
    file_base = "%s_traj_%d" % (self.file_base, self._i_trajectory)
    pdb_hierarchy = model.get_hierarchy()
    two_fofc_map_coeffs = fmodel.map_coefficients(map_type="2mFo-DFc",
      fill_missing=self.filled_maps)
    fofc_map_coeffs = fmodel.map_coefficients(map_type="mFo-DFc")
    iotbx.map_tools.write_map_coeffs(
      fwt_coeffs=two_fofc_map_coeffs,
      delfwt_coeffs=fofc_map_coeffs,
      file_name=file_base+".mtz")
    f = open(file_base + ".pdb", "w")
    f.write(pdb_hierarchy.as_pdb_string(
      crystal_symmetry=model.get_xray_structure()))
    f.close()
    print("wrote model to %s.pdb" % file_base, file=self.log)
    print("wrote map coefficients to %s.mtz" % file_base, file=self.log)

class annealing_callback(object):
  def __init__(self, model, monitor):
    self.model = model
    self.monitor = monitor

  def __call__(self, fmodel):
    self.monitor.call_back(model=self.model,
      fmodel=fmodel,
      method="anneal")


 *******************************************************************************


 *******************************************************************************
mmtbx/refinement/real_space/__init__.py
from __future__ import absolute_import, division, print_function
from libtbx import adopt_init_args, group_args
from scitbx.array_family import flex
from scitbx.matrix import rotate_point_around_axis
import time, sys
from cctbx import maptbx
import mmtbx.utils
from mmtbx.rotamer.rotamer_eval import RotamerEval
import iotbx.pdb
from cctbx import miller
from libtbx.str_utils import format_value
import mmtbx.model.statistics
import libtbx.load_env
from mmtbx.utils import rotatable_bonds
from cctbx.eltbx import tiny_pse
from cctbx import eltbx
from libtbx.test_utils import approx_equal
from mmtbx.maps.correlation import five_cc
import mmtbx.model
from cctbx.eltbx import tiny_pse
from cctbx import eltbx
from cctbx import crystal

# Test utils (common to all tests in this folder).
# Perhaps to move to mmtbx/regression.

import scitbx.math
from libtbx.utils import null_out
from six.moves import zip
from six.moves import range

def setup_test(pdb_answer, pdb_poor, i_pdb, d_min, resolution_factor,
               pdb_for_map = None, residues=None):
  rotamer_manager = mmtbx.idealized_aa_residues.rotamer_manager.load(
    residues = residues, rotamers = "favored_allowed")
  sin_cos_table = scitbx.math.sin_cos_table(n=10000)
  #
  pip = mmtbx.model.manager.get_default_pdb_interpretation_params()
  pip.pdb_interpretation.link_distance_cutoff=999
  pip.pdb_interpretation.clash_guard.nonbonded_distance_threshold=None
  # answer
  pdb_inp = iotbx.pdb.input(source_info=None, lines=pdb_answer)
  model_answer = mmtbx.model.manager(model_input=pdb_inp,
    log=null_out())
  model_answer.process(pdb_interpretation_params=pip,
    make_restraints=True)
  with open("answer_%s.pdb"%str(i_pdb), "w") as the_file:
    the_file.write(model_answer.model_as_pdb())
  #
  model_ = model_answer.deep_copy()
  if(pdb_for_map is not None):
    pdb_inp = iotbx.pdb.input(source_info=None, lines=pdb_for_map)
    model_ = mmtbx.model.manager(model_input=pdb_inp, log=null_out())
  #
  xrs_answer = model_.get_xray_structure()
  f_calc = xrs_answer.structure_factors(d_min = d_min).f_calc()
  fft_map = f_calc.fft_map(resolution_factor=resolution_factor)
  fft_map.apply_sigma_scaling()
  target_map = fft_map.real_map_unpadded()
  mtz_dataset = f_calc.as_mtz_dataset(column_root_label = "FCmap")
  mtz_object = mtz_dataset.mtz_object()
  mtz_object.write(file_name = "answer_%s.mtz"%str(i_pdb))
  # poor
  pdb_inp = iotbx.pdb.input(source_info=None, lines=pdb_poor)
  model_poor = mmtbx.model.manager(model_input=pdb_inp, log=null_out())
  model_poor.process(pdb_interpretation_params=pip,
    make_restraints=True)
  with open("poor_%s.pdb"%str(i_pdb), "w") as the_file:
    the_file.write(model_poor.model_as_pdb())
  #
  return group_args(
    rotamer_manager  = rotamer_manager,
    sin_cos_table    = sin_cos_table,
    target_map       = target_map,
    xrs_poor         = model_poor.get_xray_structure(),
    ph_answer        = model_answer.get_hierarchy(),
    vdw              = model_answer.get_vdw_radii(),
    mon_lib_srv      = model_answer.get_mon_lib_srv(),
    ph_poor          = model_poor.get_hierarchy(),
    rotatable_hd     = model_poor.rotatable_hd_selection(iselection=False),
    crystal_symmetry = f_calc.crystal_symmetry(),
    model_poor       = model_poor)

def check_sites_match(ph_answer, ph_refined, tol, exclude_atom_names=[]):
  s1 = flex.vec3_double()
  s2 = flex.vec3_double()
  for a1,a2 in zip(ph_answer.atoms(), ph_refined.atoms()):
    if(a1.name.strip() in exclude_atom_names): continue
    if(a1.element.strip().upper() in ["H","D"]): continue
    if(a2.element.strip().upper() in ["H","D"]): continue
    assert a1.name == a2.name, [a1.name, a2.name]
    s1.append(a1.xyz)
    s2.append(a2.xyz)
  dist = flex.max(flex.sqrt((s1 - s2).dot()))
  print(dist, tol)
  assert dist < tol,  [dist, tol]

# End test utils

class rsr_model(object):
  def __init__(self,
               model,
               map_data=None,
               d_min=None):
    adopt_init_args(self, locals())
    self.unit_cell = self.model.crystal_symmetry().unit_cell()
    self.sites_cart_start = self.model.get_sites_cart()
    self.s1 = self.sites_cart_start.deep_copy()
    self.states_collector = mmtbx.utils.states(
      pdb_hierarchy  = self.model.get_hierarchy().deep_copy(),
      #xray_structure = self.model.get_xray_structure().deep_copy_scatterers(),
      counter        = 1)
    self.states_collector.add(sites_cart = self.model.get_sites_cart())
    #
    self.five_cc = None
    self.rmsd_b = None
    self.rmsd_a = None
    self.dist_from_start = 0
    self.dist_from_previous = 0
    self.stats_evaluations = []
    self.cc_mask=None
    self.cc_box=None
    #
    self.initialize()

  def initialize(self):
    five_cc_o = five_cc(
      map               = self.map_data,
      xray_structure    = self.model.get_xray_structure(),
      d_min             = self.d_min,
      compute_cc_box    = True,
      compute_cc_image  = False,
      compute_cc_mask   = True,
      compute_cc_volume = False,
      compute_cc_peaks  = False).result
    self.cc_mask = five_cc_o.cc_mask
    self.cc_box  = five_cc_o.cc_box
    # XXX use model.statistics or better method of model!
    if(self.model.restraints_manager_available()):
      es = self.model.get_restraints_manager().geometry.energies_sites(
        sites_cart = self.model.get_sites_cart())
      self.rmsd_a = es.angle_deviations()[2]
      self.rmsd_b = es.bond_deviations()[2]

  def show(self, prefix="", log=None):
    if(log is None): log = sys.stdout
    print("%smodel-to-map fit, CC_mask: %-6.4f"%(prefix, self.cc_mask), file=log)
    print("%smoved from start:          %-6.4f"%(prefix, self.dist_from_start), file=log)
    # Update stats and print out if log is set
    self.update_statistics(prefix = prefix, log = log)

  def update_statistics(self, prefix = None, log = None):
    gs = self.model.geometry_statistics()
    result = None
    if(gs is not None):
      if (log):
        gs.show(prefix=prefix, log=log, uppercase=False)
      result = gs.result()
    self.stats_evaluations.append(group_args(
      cc       = self.cc_mask,
      geometry = result))

  def update(self, xray_structure=None, sites_cart=None):
    assert [xray_structure, sites_cart].count(None)!=0
    s0 = self.sites_cart_start
    if(xray_structure is not None):
      s2 = xray_structure.sites_cart()
      self.model.set_xray_structure(xray_structure = xray_structure)
    elif(sites_cart is not None):
      s2 = sites_cart
      self.model.set_sites_cart(sites_cart=s2)
    else:
      s2 = self.model.get_sites_cart()
    self.dist_from_start    = flex.mean(flex.sqrt((s0 - s2).dot()))
    self.dist_from_previous = flex.mean(flex.sqrt((self.s1 - s2).dot()))
    self.initialize()
    self.states_collector.add(sites_cart = s2)
    self.s1 = self.model.get_sites_cart() # must be last

def flatten(l):
  if l is None: return None
  return sum(([x] if not (isinstance(x, list) or isinstance(x, flex.size_t)) else flatten(x) for x in l), [])

def get_radii(residue, vdw_radii):
  atom_names = [a.name.strip() for a in residue.atoms()]
  converter = iotbx.pdb.residue_name_plus_atom_names_interpreter(
    residue_name = residue.resname, atom_names = atom_names)
  mon_lib_names = converter.atom_name_interpretation.mon_lib_names()
  radii = flex.double()
  for n in mon_lib_names:
    try:             radii.append(vdw_radii[n.strip()]-0.25)
    except KeyError: radii.append(1.5) # XXX U, Uranium, OXT are problems!
  return radii

def get_radius(atom, vdw_radii):
  atom_names = [atom.name.strip()]
  converter = iotbx.pdb.residue_name_plus_atom_names_interpreter(
    residue_name = atom.parent().resname, atom_names = atom_names)
  if(converter.atom_name_interpretation is not None):
    atom_names = converter.atom_name_interpretation.mon_lib_names()
  if(atom_names[0] is not None):
    n = atom_names[0].strip()
  else:
    converter = iotbx.pdb.residue_name_plus_atom_names_interpreter(
      residue_name = atom.parent().resname,
      atom_names   = [atom.element])
    n = converter.atom_name_interpretation.mon_lib_names()[0].strip()
    if(n is None): return 1.5
  try:             return vdw_radii[n.strip()]-0.25
  except KeyError: return 1.5 # XXX U, Uranium, OXT are problems!

def common_map_values(pdb_hierarchy, unit_cell, map_data):
  d = {}
  for model in pdb_hierarchy.models():
    for chain in model.chains():
      for residue_group in chain.residue_groups():
        conformers = residue_group.conformers()
        for conformer in conformers:
          residue = conformer.only_residue()
          for atom in residue.atoms():
            sf = unit_cell.fractionalize(atom.xyz)
            mv = map_data.eight_point_interpolation(sf)
            key = "%s_%s_%s"%(chain.id, residue.resname, atom.name.strip())
            d.setdefault(key, flex.double()).append(mv)
  def mean_filtered(x):
    me = flex.mean_default(x,0)
    sel  = x < me*3
    sel &= x > me/3
    return sel
  result = {}
  all_vals = flex.double()
  for v in d.values():
    all_vals.extend(v)
  sel = mean_filtered(all_vals)
  overall_mean = flex.mean_default(all_vals.select(sel),0)
  for k,v in zip(d.keys(), d.values()):
    sel = mean_filtered(v)
    if(sel.count(True)>10): result[k] = flex.mean_default(v.select(sel),0)
    else:                   result[k] = overall_mean
  return result

class side_chain_fit_evaluator(object):
  def __init__(self,
               pdb_hierarchy,
               crystal_symmetry,
               exclude_selection = None,
               rotamer_evaluator = None,
               map_data = None,
               diff_map_data = None,
               map_data_scale = 2.5,
               diff_map_data_threshold = -2.5,
               cmv = None):
    t0 = time.time()
    if(cmv is None and map_data is not None):
      cmv = common_map_values(
        pdb_hierarchy = pdb_hierarchy,
        unit_cell     = crystal_symmetry.unit_cell(),
        map_data      = map_data)
    get_class = iotbx.pdb.common_residue_names_get_class
    mainchain=["C","N","O","CA","CB"]
    self.crystal_symmetry = crystal_symmetry
    unit_cell = crystal_symmetry.unit_cell()
    self.pdb_hierarchy = pdb_hierarchy
    self.special_position_indices = self._get_special_position_indices()
    self.cntr_residues = 0
    self.cntr_poormap  = 0
    self.cntr_outliers = 0
    self.mes = []
    self._sel_outliers = flex.bool(pdb_hierarchy.atoms().size(), False)
    self._sel_poormap  = flex.bool(pdb_hierarchy.atoms().size(), False)
    self._sel_all      = flex.bool(pdb_hierarchy.atoms().size(), False)
    def skip(residue):
      if(get_class(residue.resname) != "common_amino_acid"): return True
      if(residue.resname.strip().upper() in ["ALA","GLY"]): return True
      if(self._on_spacial_position(residue)): return True
      if(exclude_selection is not None):
        for atom in residue.atoms():
          if(atom.i_seq in exclude_selection):
            return True
      return False
    for model in pdb_hierarchy.models():
      for chain in model.chains():
        for residue_group in chain.residue_groups():
          conformers = residue_group.conformers()
          if(len(conformers)>1): continue
          for conformer in residue_group.conformers():
            residue = conformer.only_residue()
            if(skip(residue)): continue
            self.cntr_residues += 1 # count all
            outlier = False
            if(rotamer_evaluator is None or
               rotamer_evaluator.evaluate_residue(residue)=="OUTLIER"):
              outlier = True
              self.cntr_outliers += 1
            for atom in residue.atoms():
              self._sel_all[atom.i_seq] = True
              if(outlier): self._sel_outliers[atom.i_seq] = True
            atoms = residue.atoms()
            need_fix = False
            poor_mainchain = False
            # Always do MSE and MET
            if(not need_fix and residue.resname in ["MSE", "MET"]):
              need_fix=True
            # Check maps now
            if(not need_fix):
              for atom in residue.atoms():
                if(atom.element_is_hydrogen()): continue
                an = atom.name.strip()
                # Check map
                if(map_data is not None):
                  key="%s_%s_%s"%(chain.id, residue.resname, an)
                  m_ref = cmv[key]
                  sf = unit_cell.fractionalize(atom.xyz)
                  m_cur = map_data.eight_point_interpolation(sf)
                  if(an in mainchain and m_cur < m_ref/map_data_scale):
                    poor_mainchain = True
                    break
                  if(not an in mainchain and m_cur < m_ref/map_data_scale):
                    need_fix = True
                    break
                # Check Fo-Fc map
                if(diff_map_data is not None):
                  sf = unit_cell.fractionalize(atom.xyz)
                  mv_diff = diff_map_data.eight_point_interpolation(sf)
                  if(an in mainchain and mv_diff < diff_map_data_threshold):
                    poor_mainchain = True
                    break
                  if(not an in mainchain and mv_diff<diff_map_data_threshold):
                    need_fix = True
                    break
              if(poor_mainchain): need_fix = False
            #
            if(need_fix):
              self._sel_poormap = self._sel_poormap.set_selected(
                atoms.extract_i_seq(), True)
              self.cntr_poormap+=1
    #
    fmt = "%-d residues out of total %-d (non-[ALA,GLY,PRO]) need to be fit."
    self.mes.append(
      fmt%(self.cntr_poormap+self.cntr_outliers, self.cntr_residues))
    self.mes.append("  rotamer outliers: %d"%self.cntr_outliers)
    self.mes.append("  poor density    : %d"%self.cntr_poormap)
    self.mes.append("time to evaluate  : %-6.3f"%(time.time()-t0))

  def show(self, log=None, prefix=""):
    if(log is None): log = sys.stdout
    for m in self.mes:
      print("%s%s"%(prefix,m), file=log)
    log.flush()

  def sel_all(self):
    return self._sel_all

  def sel_outliers_or_poormap(self):
    return self._sel_outliers | self._sel_poormap

  def sel_outliers(self):
    return self._sel_outliers

  def sel_outliers_and_poormap(self):
    return self._sel_outliers & self._sel_poormap

  def sel_poormap(self):
    return self._sel_poormap

  def _get_special_position_indices(self):
    special_position_settings = crystal.special_position_settings(
      crystal_symmetry = self.crystal_symmetry)
    site_symmetry_table = \
      special_position_settings.site_symmetry_table(
        sites_cart = self.pdb_hierarchy.atoms().extract_xyz(),
        unconditional_general_position_flags=(
          self.pdb_hierarchy.atoms().extract_occ() != 1))
    return site_symmetry_table.special_position_indices()

  def _on_spacial_position(self, residue):
    if(self.special_position_indices is None): return False
    if(self.special_position_indices.size()==0): return False
    for i_seq in residue.atoms().extract_i_seq():
      if(i_seq in self.special_position_indices): return True
    return False

class cluster(object):
  def __init__(self,
               axis,
               atoms_to_rotate,
               atom_names=None,
               vector=None,
               selection=None):
    adopt_init_args(self, locals())
    self.vector_flat = None

  def get_vector_flat(self):
    if(self.vector is not None):
      if(self.vector_flat is None):
        self.vector_flat = flex.size_t(flatten(self.vector))
    return self.vector_flat

  def show(self):
    if(self.atom_names is None): return
    cl = self
    an = self.atom_names
    print(cl.axis, ",".join([an[i].strip() for i in cl.axis]), \
        cl.atoms_to_rotate, \
        ",".join([an[i].strip() for i in cl.atoms_to_rotate]), "<>",\
        ",".join([an[i].strip() for i in cl.selection]), "<>",\
        ",".join([an[i].strip() for i in cl.get_vector_flat()]))

class aa_residue_axes_and_clusters(object):
  def __init__(self,
               residue,
               mon_lib_srv,
               backbone_sample,
               log=None):
    if log is None: log = sys.stdout
    self.clusters               = []
    atoms                       = residue.atoms()
    atoms_as_list               = list(atoms)
    atom_names                  = atoms.extract_name()
    self.weights                = flex.double()
    self.clash_eval_selection   = flex.size_t()
    self.clash_eval_h_selection = flex.bool(len(atoms_as_list), False)
    self.rsr_eval_selection     = flex.size_t()
    # Backbone sample
    backrub_axis  = []
    backrub_atoms_to_rotate = []
    backrub_atoms_to_evaluate = []
    counter = 0 # XXX DOES THIS RELY ON ORDER?
    for atom in atoms:
      an = atom.name.strip().upper()
      ae = atom.element.strip().upper()
      if(ae in ["H","D"]):
        self.clash_eval_h_selection[counter]=True
      if(an in ["N", "C"]):
        backrub_axis.append(counter)
      else:
        backrub_atoms_to_rotate.append(counter)
      if(an in ["CA", "O", "CB"]):
        backrub_atoms_to_evaluate.append(counter)
      if(not an in ["CA", "O", "CB", "C", "N", "HA", "H"]):
        self.clash_eval_selection.append(counter)
        if(not ae in ["H","D"]):
          self.rsr_eval_selection.append(counter)
      std_lbl = eltbx.xray_scattering.get_standard_label(
        label=ae, exact=True, optional=True)
      self.weights.append(tiny_pse.table(std_lbl).weight())
      #
      counter += 1
    #
    if(backbone_sample):
      if(len(backrub_axis)==2 and len(backrub_atoms_to_evaluate)>0):
        self.clusters.append(cluster(
          axis            = flex.size_t(backrub_axis),
          atom_names      = atom_names,
          atoms_to_rotate = flex.size_t(backrub_atoms_to_rotate),
          selection       = flex.size_t(backrub_atoms_to_evaluate)))
    self.axes_and_atoms_aa_specific = \
      rotatable_bonds.axes_and_atoms_aa_specific(
        residue = residue, mon_lib_srv = mon_lib_srv, log = log)
    if(self.axes_and_atoms_aa_specific is not None):
      for i_aa, aa in enumerate(self.axes_and_atoms_aa_specific):
        if(i_aa == len(self.axes_and_atoms_aa_specific)-1):
          selection = flex.size_t(aa[1])
        else:
          selection = flex.size_t([aa[1][0]])
        # Exclude pure H or D rotatable groups
        elements_to_rotate = flex.std_string()
        for etr in aa[1]:
          elements_to_rotate.append(atoms_as_list[etr].element.strip())
        c_H = elements_to_rotate.count("H")
        c_D = elements_to_rotate.count("D")
        etr_sz = elements_to_rotate.size()
        if(c_H==etr_sz or c_D==etr_sz or c_H+c_D==etr_sz):
          continue
        #
        self.clusters.append(cluster(
          axis            = flex.size_t(aa[0]),
          atom_names      = atom_names,
          atoms_to_rotate = flex.size_t(aa[1]),
          selection       = flex.size_t(selection)))
      vector_selections = []
      if(len(self.clusters)>0):
        for i_aa, aa in enumerate(self.axes_and_atoms_aa_specific):
          for aa_ in aa[0]:
            if(not aa_ in vector_selections):
              vector_selections.append(aa_)
        vector_selections.append(
          self.clusters[len(self.clusters)-1].atoms_to_rotate)
        for cl in self.clusters:
          cl.vector = vector_selections

class residue_monitor(object):
  def __init__(self,
               residue,
               id_str,
               selection_all,
               selection_sidechain=None,
               selection_backbone=None,
               selection_c=None,
               selection_n=None,
               map_cc_sidechain=None,
               map_cc_backbone=None,
               map_cc_all=None,
               rotamer_status=None):
    adopt_init_args(self, locals())

  def format_info_string(self):
    return "%7s %6s    %6s     %6s %9s"%(
      self.id_str,
      format_value("%6.3f",self.map_cc_all),
      format_value("%6.3f",self.map_cc_backbone),
      format_value("%6.3f",self.map_cc_sidechain),
      self.rotamer_status)

class structure_monitor(object):
  def __init__(self,
               pdb_hierarchy,
               xray_structure,
               target_map_object=None,
               geometry_restraints_manager=None):
    adopt_init_args(self, locals())
    self.unit_cell = self.xray_structure.unit_cell()
    self.xray_structure = xray_structure.deep_copy_scatterers()
    self.xray_structure_start = xray_structure.deep_copy_scatterers()
    self.states_collector = mmtbx.utils.states(
      pdb_hierarchy  = self.pdb_hierarchy,
      counter        = 1)
    self.states_collector.add(sites_cart = self.xray_structure.sites_cart())
    self.rotamer_manager = RotamerEval()
    self.assert_pdb_hierarchy_xray_structure_sync()
    #
    self.five_cc = None
    self.map_cc_whole_unit_cell = None
    self.map_cc_around_atoms = None
    self.map_cc_per_atom = None
    self.rmsd_b = None
    self.rmsd_a = None
    self.dist_from_start = 0
    self.dist_from_previous = 0
    self.number_of_rotamer_outliers = 0
    self.residue_monitors = None
    self.stats_evaluations = []
    #
    self.initialize()

  def assert_pdb_hierarchy_xray_structure_sync(self):
    return #XXX
    sc1 = self.xray_structure.sites_cart()
    sc2 = self.pdb_hierarchy.atoms().extract_xyz()
    assert approx_equal(sc1, sc2, 1.e-3)

  def initialize(self):
    self.assert_pdb_hierarchy_xray_structure_sync()
    # residue monitors
    self.residue_monitors = []
    backbone_atoms = ["N","CA","C","O","CB"]
    get_class = iotbx.pdb.common_residue_names_get_class
    sites_cart = self.xray_structure.sites_cart()
    current_map = self.compute_map(xray_structure = self.xray_structure)
    for model in self.pdb_hierarchy.models():
      for chain in model.chains():
        for residue_group in chain.residue_groups():
          conformers = residue_group.conformers()
          if(len(conformers)>1): continue
          for conformer in residue_group.conformers():
            residue = conformer.only_residue()
            id_str="%s%s%s"%(chain.id,residue.resname,residue.resseq.strip())
            if(get_class(residue.resname) == "common_amino_acid"):
              residue_i_seqs_backbone  = flex.size_t()
              residue_i_seqs_sidechain = flex.size_t()
              residue_i_seqs_all       = flex.size_t()
              residue_i_seqs_c         = flex.size_t()
              residue_i_seqs_n         = flex.size_t()
              for atom in residue.atoms():
                an = atom.name.strip()
                bb = an in backbone_atoms
                residue_i_seqs_all.append(atom.i_seq)
                if(bb): residue_i_seqs_backbone.append(atom.i_seq)
                else:   residue_i_seqs_sidechain.append(atom.i_seq)
                if(an == "C"): residue_i_seqs_c.append(atom.i_seq)
                if(an == "N"): residue_i_seqs_n.append(atom.i_seq)
              sca = sites_cart.select(residue_i_seqs_all)
              scs = sites_cart.select(residue_i_seqs_sidechain)
              scb = sites_cart.select(residue_i_seqs_backbone)
              if(scs.size()==0): ccs = None
              else: ccs = self.map_cc(sites_cart=scs, other_map = current_map)
              if(sca.size()==0): cca = None
              else: cca = self.map_cc(sites_cart=sca, other_map = current_map)
              if(scb.size()==0): ccb = None
              else: ccb = self.map_cc(sites_cart=scb, other_map = current_map)
              self.residue_monitors.append(residue_monitor(
                residue             = residue,
                id_str              = id_str,
                selection_sidechain = residue_i_seqs_sidechain,
                selection_backbone  = residue_i_seqs_backbone,
                selection_all       = residue_i_seqs_all,
                selection_c         = residue_i_seqs_c,
                selection_n         = residue_i_seqs_n,
                map_cc_sidechain    = ccs,
                map_cc_backbone     = ccb,
                map_cc_all          = cca,
                rotamer_status= self.rotamer_manager.evaluate_residue(residue)))
            else:
              residue_i_seqs_all = residue.atoms().extract_i_seq()
              sca = sites_cart.select(residue_i_seqs_all)
              cca = self.map_cc(sites_cart=sca, other_map = current_map)
              self.residue_monitors.append(residue_monitor(
                residue       = residue,
                id_str        = id_str,
                selection_all = residue_i_seqs_all,
                map_cc_all    = cca))
    # globals
    self.five_cc = five_cc(
        map            = self.target_map_object.map_data,
        xray_structure = self.xray_structure,
        d_min          = self.target_map_object.d_min)
    self.map_cc_whole_unit_cell = self.map_cc(other_map = current_map)
    self.map_cc_around_atoms = self.map_cc(other_map = current_map,
      sites_cart = sites_cart)
    self.map_cc_per_atom = self.map_cc(other_map = current_map,
      sites_cart = sites_cart, per_atom = True)
    if(self.geometry_restraints_manager is not None):
      es = self.geometry_restraints_manager.energies_sites(sites_cart=sites_cart)
      self.rmsd_a = es.angle_deviations()[2]
      self.rmsd_b = es.bond_deviations()[2]
    self.dist_from_start = flex.mean(self.xray_structure_start.distances(
      other = self.xray_structure))
    self.number_of_rotamer_outliers = 0
    for r in self.residue_monitors:
      if(r.rotamer_status == "OUTLIER"):
        self.number_of_rotamer_outliers += 1
    self.assert_pdb_hierarchy_xray_structure_sync()

  def compute_map(self, xray_structure):
    self.assert_pdb_hierarchy_xray_structure_sync()
    mc = self.target_map_object.miller_array.structure_factors_from_scatterers(
      xray_structure = xray_structure).f_calc()
    fft_map = miller.fft_map(
      crystal_gridding     = self.target_map_object.crystal_gridding,
      fourier_coefficients = mc)
    fft_map.apply_sigma_scaling()
    return fft_map.real_map_unpadded()

  def map_cc_histogram_per_atom(self, radius=2, n_slots=10):
    self.assert_pdb_hierarchy_xray_structure_sync()
    from mmtbx.maps import correlation
    current_map = self.compute_map(xray_structure = self.xray_structure)
    return correlation.histogram_per_atom(
      map_1      = current_map,
      map_2      = self.target_map_object.map_data,
      sites_cart = self.xray_structure.sites_cart(),
      unit_cell  = self.xray_structure.unit_cell(),
      radius     = radius,
      n_slots    = n_slots)

  def map_cc(self, other_map, sites_cart=None, atom_radius=2, per_atom=False):
    self.assert_pdb_hierarchy_xray_structure_sync()
    from mmtbx.maps import correlation
    if(sites_cart is not None):
      if(per_atom):
        result = correlation.from_map_map_atoms_per_atom(
          map_1      = other_map,
          map_2      = self.target_map_object.map_data,
          sites_cart = sites_cart,
          unit_cell  = self.xray_structure.unit_cell(),
          radius     = atom_radius)
      else:
        result = correlation.from_map_map_atoms(
          map_1      = other_map,
          map_2      = self.target_map_object.map_data,
          sites_cart = sites_cart,
          unit_cell  = self.xray_structure.unit_cell(),
          radius     = atom_radius)
    else:
      result = correlation.from_map_map(
        map_1 = other_map,
        map_2 = self.target_map_object.map_data)
    return result

  def show(self, prefix="", log=None):
    self.assert_pdb_hierarchy_xray_structure_sync()
    if(log is None): log = sys.stdout
    fmt = """%s CC_mask:                   %-6.3f
%s CC_volume:                 %-6.3f
%s CC_peaks:                  %-6.3f
%s rmsd (bonds):              %-s
%s rmsd (angles):             %-s
%s Dist. moved from start:    %-6.3f
%s Dist. moved from previous: %-6.3f
%s All-atom clashscore        %-s
%s Ramachandran plot:
%s   outliers:                %-s %%
%s   allowed:                 %-s %%
%s   favored:                 %-s %%
%s Omega angle:
%s   cis-proline:             %-s %%
%s   twisted proline:         %-s %%
%s   cis-general:             %-s %%
%s   twisted-general:         %-s %%
%s CaBLAM analysis:
%s   outliers:                %-s %%
%s   disfavored:              %-s %%
%s   ca outliers:             %-s %%
%s Rotamer outliers:          %-s %%
%s C-beta deviations:         %-s %%
"""
    mso = None
    try:
      if self.geometry_restraints_manager is not None and False:
        # XXX False at the end is intentional, because currently I want to
        # disable this 'if' branch. Reason is - nothing from extended
        # model_statistics (with GRM) is being used, so no reason to spend
        # time calculating statistics over various restraints.
        mso = mmtbx.model.statistics.geometry(
          pdb_hierarchy      = self.pdb_hierarchy,
          molprobity_scores  = libtbx.env.has_module("probe"),
          restraints_manager = self.geometry_restraints_manager)
      else:
        mso = mmtbx.model.statistics.geometry_no_grm(
          pdb_hierarchy      = self.pdb_hierarchy,
          molprobity_scores  = libtbx.env.has_module("probe"))
    except Exception:
      # some part of validation failed
      pass
    self.stats_evaluations.append(
        group_args(
          cc = group_args(
              cc_mask   = self.five_cc.result.cc_mask,
              cc_volume = self.five_cc.result.cc_volume,
              cc_peaks  = self.five_cc.result.cc_peaks),
          geometry = mso,
          rmsd_a = self.rmsd_a,
          rmsd_b = self.rmsd_b))
    if mso is not None and self.five_cc is not None:
      print(fmt%(
        # prefix, self.map_cc_whole_unit_cell,
        # prefix, self.map_cc_around_atoms,
        prefix, self.five_cc.cc_mask,
        prefix, self.five_cc.cc_volume,
        prefix, self.five_cc.cc_peaks,
        prefix, format_value("%-6.2f", self.rmsd_b).strip(),
        prefix, format_value("%-6.2f", self.rmsd_a).strip(),
        prefix, self.dist_from_start,
        prefix, self.dist_from_previous,
        prefix, format_value("%-6.2f", mso.clashscore),
        prefix,
        prefix, format_value("%-5.2f", mso.ramachandran_outliers),
        prefix, format_value("%-5.2f", mso.ramachandran_allowed),
        prefix, format_value("%-5.2f", mso.ramachandran_favored),
        prefix,
        prefix, format_value("%-5.2f", mso.cis_proline),
        prefix, format_value("%-5.2f", mso.twisted_proline),
        prefix, format_value("%-5.2f", mso.cis_general),
        prefix, format_value("%-5.2f", mso.twisted_general),
        prefix,
        prefix, format_value("%-5.2f", mso.cablam_outliers),
        prefix, format_value("%-5.2f", mso.cablam_disfavored),
        prefix, format_value("%-5.2f", mso.cablam_ca_outliers),
        prefix, format_value("%6.2f", mso.rotamer_outliers).strip(),
        prefix, format_value("%-5.2f", mso.c_beta_dev_percent)), file=log)

  def show_residues(self, map_cc_all=0.8, map_cc_sidechain=0.8, log=None):
    self.assert_pdb_hierarchy_xray_structure_sync()
    if(log is None): log = sys.stdout
    header_printed = True
    for r in self.residue_monitors:
      i1=r.map_cc_all < map_cc_all
      i2=r.rotamer_status == "OUTLIER"
      i4=r.map_cc_sidechain is not None and r.map_cc_sidechain<map_cc_sidechain
      if([i1,i2,i4].count(True)>0):
        if(header_printed):
          print("Residue     CC        CC         CC   Rotamer", file=log)
          print("     id    all  backbone  sidechain        id", file=log)
          header_printed = False
        print(r.format_info_string(), file=log)

  def update(self, xray_structure, accept_as_is=True):
    if(not accept_as_is):
      current_map = self.compute_map(xray_structure = xray_structure)
      sites_cart  = xray_structure.sites_cart()
      sites_cart_ = self.xray_structure.sites_cart()
      for r in self.residue_monitors:
        sca = sites_cart.select(r.selection_all)
        scs = sites_cart.select(r.selection_sidechain)
        scb = sites_cart.select(r.selection_backbone)
        map_cc_all       = self.map_cc(sites_cart = sca, other_map = current_map)
        map_cc_sidechain = self.map_cc(sites_cart = scs, other_map = current_map)
        map_cc_backbone  = self.map_cc(sites_cart = scb, other_map = current_map)
        flag = map_cc_all      >= r.map_cc_all and \
               map_cc_backbone >= r.map_cc_backbone and \
               map_cc_sidechain>= r.map_cc_sidechain
        if(flag):
          residue_sites_cart_new = sites_cart.select(r.selection_all)
          sites_cart_ = sites_cart_.set_selected(r.selection_all,
            residue_sites_cart_new)
      xray_structure = xray_structure.replace_sites_cart(sites_cart_)
    # re-initialize monitor
    self.dist_from_previous = flex.mean(self.xray_structure.distances(
      other = xray_structure))
    self.xray_structure = xray_structure
    self.pdb_hierarchy.adopt_xray_structure(xray_structure)
    self.initialize()
    self.states_collector.add(sites_cart = xray_structure.sites_cart())
    self.assert_pdb_hierarchy_xray_structure_sync()

def selection_around_to_negate(
      xray_structure,
      selection_within_radius,
      iselection,
      selection_good=None,
      iselection_backbone=None,
      iselection_n_external=None,
      iselection_c_external=None):
  # takes ~0.002 seconds
  if([selection_good,iselection_backbone].count(None)==0):
    selection_backbone = flex.bool(selection_good.size(), iselection_backbone)
    selection_good = selection_good.set_selected(selection_backbone, True)
  sel_around = xray_structure.selection_within(
    radius    = selection_within_radius,
    selection = flex.bool(xray_structure.scatterers().size(), iselection))
  if(selection_good is not None):
    ssb = flex.bool(selection_good.size(), iselection)
    sel_around_minus_self = sel_around.set_selected(ssb, False)
  else:
    sel_around_minus_self = flex.size_t(tuple(
      set(sel_around.iselection()).difference(set(iselection))))
  if(selection_good is not None):
    negate_selection = sel_around_minus_self & selection_good
  else:
    negate_selection = sel_around_minus_self
  if(iselection_n_external is not None and iselection_n_external.size()>0):
    negate_selection[iselection_n_external[0]]=False
  if(iselection_c_external is not None and iselection_c_external.size()>0):
    negate_selection[iselection_c_external[0]]=False
  return negate_selection

def negate_map_around_selected_atoms_except_selected_atoms(
      xray_structure,
      map_data,
      negate_selection,
      atom_radius):
  # XXX time and memory inefficient
  sites_cart_p1 = xray_structure.select(negate_selection).expand_to_p1(
    sites_mod_positive=True).sites_cart()
  around_atoms_selections = maptbx.grid_indices_around_sites(
    unit_cell  = xray_structure.unit_cell(),
    fft_n_real = map_data.focus(),
    fft_m_real = map_data.all(),
    sites_cart = sites_cart_p1,
    site_radii = flex.double(sites_cart_p1.size(), atom_radius))
  return maptbx.negate_selected_in_place(map_data=map_data,
    selection=around_atoms_selections)

class score2(object):
  def __init__(self,
               unit_cell,
               target_map,
               residue,
               vector = None,
               selection=None):
    adopt_init_args(self, locals())
    self.target = None
    self.sites_cart = None
    self.i_seqs = []
    self.weights = flex.double()
    for el in self.residue.atoms().extract_element():
      std_lbl = eltbx.xray_scattering.get_standard_label(
        label=el, exact=True, optional=True)
      self.weights.append(tiny_pse.table(std_lbl).weight())
    self.occ = self.residue.atoms().extract_occ()
    self.vector_flat = None
    if(vector is not None):
      self.vector_flat = flex.size_t(flatten(self.vector))
    self.sites_cart = self.residue.atoms().extract_xyz()
    if(selection is None): selection = self.vector_flat
    self.target = maptbx.real_space_target_simple(
      unit_cell   = self.unit_cell,
      density_map = self.target_map,
      sites_cart  = self.sites_cart,
      selection   = selection)

  def update(self, sites_cart, selection=None):
    if(selection is None): selection = self.vector_flat
    target = maptbx.real_space_target_simple(
      unit_cell   = self.unit_cell,
      density_map = self.target_map,
      sites_cart  = sites_cart,
      selection   = selection)
    if(target > self.target):
      self.sites_cart = sites_cart
      self.target = target

class score(object):
  def __init__(self,
               unit_cell,
               target_map,
               residue,
               rotamer_eval = None,
               vector = None):
    adopt_init_args(self, locals())
    self.target = None
    self.sites_cart = None
    self.i_seqs = []
    self.weights = flex.double()
    for el in self.residue.atoms().extract_element():
      std_lbl = eltbx.xray_scattering.get_standard_label(
        label=el, exact=True, optional=True)
      self.weights.append(tiny_pse.table(std_lbl).weight())
    self.occ = self.residue.atoms().extract_occ()
    self.vector_flat = flatten(self.vector)

  def compute_target(self, sites_cart, selection=None):
    sites_frac = self.unit_cell.fractionalize(sites_cart)
    result = 0
    vals = []
    if(selection is None): i_seqs = self.vector_flat
    else:                  i_seqs = selection
    for i_seq in i_seqs:
      vals.append(self.target_map.eight_point_interpolation(sites_frac[i_seq])/
        self.weights[i_seq]/self.occ[i_seq])
    #
    sz = len(vals)
    if(sz>3):
      deltas = []
      for i in range(sz):
        if(i+1<sz and i>1):
          e1=abs(vals[i])
          e2=abs(vals[i+1])
          r=e1/e2
          deltas.append(r)
      if(max(deltas)>5 or min(deltas)<1./5):
        return 0
    return sum(vals)

  def update(self, sites_cart, selection=None, tmp=None):
    target = self.compute_target(sites_cart = sites_cart, selection=selection)
    assert self.target is not None
    if(target > self.target):
      self.residue.atoms().set_xyz(sites_cart)
      fl = self.rotamer_eval is None or \
        self.rotamer_eval.evaluate_residue(residue = self.residue) != "OUTLIER"
      if(fl):
        self.target = target
        self.sites_cart = sites_cart

  def reset(self, sites_cart, selection=None):
    self.target = self.compute_target(sites_cart = sites_cart,
      selection = selection)
    self.sites_cart = sites_cart

def torsion_search(clusters, scorer, sites_cart, start, stop, step):
  def generate_range(start, stop, step):
    assert abs(start) <= abs(stop)
    inc = start
    result = []
    while abs(inc) <= abs(stop):
      result.append(inc)
      inc += step
    return result
  for i_cl, cl in enumerate(clusters):
    if(i_cl == 0): sites_cart_start = sites_cart.deep_copy()
    else:          sites_cart_start = scorer.sites_cart.deep_copy()
    scorer.reset(sites_cart=sites_cart_start, selection=cl.selection)
    sites_cart_ = scorer.sites_cart.deep_copy()
    for angle_deg in generate_range(start=start, stop=stop, step=step):
      xyz_moved = sites_cart_.deep_copy()
      for atom in cl.atoms_to_rotate:
        new_xyz = rotate_point_around_axis(
          axis_point_1 = sites_cart_[cl.axis[0]],
          axis_point_2 = sites_cart_[cl.axis[1]],
          point        = sites_cart_[atom],
          angle        = angle_deg, deg=True)
        xyz_moved[atom] = new_xyz
      scorer.update(sites_cart = xyz_moved, selection = cl.selection)
  return scorer

def generate_angles_nested(
      clusters,
      residue,
      rotamer_eval,
      nested_loop,
      include,
      states=None):
  result = []
  choices = ["ALLOWED", "FAVORED", "OUTLIER", "NONE"]
  for it in include:
    assert it in choices
  sites_cart = residue.atoms().extract_xyz()
  for angles in nested_loop:
    sites_cart_moved = sites_cart.deep_copy()
    for i, angle in enumerate(angles):
      cl = clusters[i]
      for atom_to_rotate in cl.atoms_to_rotate:
        new_site_cart = rotate_point_around_axis(
          axis_point_1 = sites_cart_moved[cl.axis[0]],
          axis_point_2 = sites_cart_moved[cl.axis[1]],
          point        = sites_cart_moved[atom_to_rotate],
          angle        = angle,
          deg          = True)
        sites_cart_moved[atom_to_rotate] = new_site_cart
    residue.atoms().set_xyz(sites_cart_moved)
    fl = str(rotamer_eval.evaluate_residue_2(residue = residue)).strip().upper()
    if(fl in include):
      if(states is not None):
        states.add(sites_cart=sites_cart_moved)
      result.append(angles)
  residue.atoms().set_xyz(sites_cart) # Was changed in place, so we restore it!
  return result

def torsion_search_nested(
      clusters,
      scorer,
      sites_cart):
  n_angles = len(clusters)
  print(n_angles)
  if(n_angles == 3):
    r1 = [-3,-7,-9]
    r2 = [3,7,9]
  elif(n_angles == 4):
    r1 = [-5,-5,-10,-10]
    r2 = [5,5,10,10]
  else: return
  nested_loop = flex.nested_loop(begin=r1, end=r2, open_range=False)
  selection = clusters[0].atoms_to_rotate
  scorer.reset(sites_cart = sites_cart, selection = selection)
  for angles in nested_loop:
    xyz_moved = sites_cart.deep_copy()
    for i, angle in enumerate(angles):
      cl = clusters[i]
      for atom in cl.atoms_to_rotate:
        new_xyz = rotate_point_around_axis(
          axis_point_1 = xyz_moved[cl.axis[0]],
          axis_point_2 = xyz_moved[cl.axis[1]],
          point        = xyz_moved[atom],
          angle        = angle, deg=True)
        xyz_moved[atom] = new_xyz
    scorer.update(sites_cart = xyz_moved, selection = selection)
  return scorer

class score3(object):
  def __init__(self,
               unit_cell,
               target_map,
               residue,
               rotamer_eval,
               exclude_hd = True):
    adopt_init_args(self, locals())
    self.target = None
    self.sites_cart = self.residue.atoms().extract_xyz()
    self.status = None
    if(self.rotamer_eval is not None):
      self.status = self.rotamer_eval.evaluate_residue(residue = self.residue)
    self.hd_sel = flex.size_t()
    if(self.exclude_hd):
      for i, atom in enumerate(self.residue.atoms()):
        if(atom.element_is_hydrogen()):
          self.hd_sel.append(i)

  def compute_target(self, sites_cart, selection=None):
    if(selection is not None):
      if(self.exclude_hd):
        selection = flex.size_t(list(set(selection)-set(self.hd_sel)))
      t = maptbx.real_space_target_simple(
        unit_cell   = self.unit_cell,
        density_map = self.target_map,
        sites_cart  = sites_cart,
        selection   = selection)
      return t/selection.size()
    else:
      t = maptbx.real_space_target_simple(
        unit_cell   = self.unit_cell,
        density_map = self.target_map,
        sites_cart  = sites_cart)
      return t/sites_cart.size()

  def update(self, sites_cart, selection=None):
    target = self.compute_target(sites_cart=sites_cart, selection=selection)
    assert self.target is not None
    if(target > self.target):
      self.residue.atoms().set_xyz(sites_cart)
      fl = self.rotamer_eval is None or \
        self.rotamer_eval.evaluate_residue(residue = self.residue) != "OUTLIER"
      if(fl):
        self.target = target
        self.sites_cart = sites_cart

  def reset(self, sites_cart, selection=None):
    self.target = self.compute_target(sites_cart = sites_cart,
      selection = selection)
    self.sites_cart = sites_cart

class score4(object):
  def __init__(self,
               unit_cell,
               target_map,
               residue,
               rotamer_eval,
               exclude_hd = True):
    adopt_init_args(self, locals())
    self.sites_cart = self.residue.atoms().extract_xyz()
    self.target = self.compute_target(sites_cart=self.sites_cart)
    self.status = None
    if(self.rotamer_eval is not None):
      self.status = self.rotamer_eval.evaluate_residue(residue = self.residue)
    self.hd_sel = flex.size_t()
    if(self.exclude_hd):
      for i, atom in enumerate(self.residue.atoms()):
        if(atom.element_is_hydrogen()):
          self.hd_sel.append(i)

  def compute_target(self, sites_cart, selection=None):
    t = maptbx.real_space_target_simple(
      unit_cell   = self.unit_cell,
      density_map = self.target_map,
      sites_cart  = sites_cart)
    return t/sites_cart.size()

  def update(self, sites_cart, selection=None):
    target = self.compute_target(sites_cart=sites_cart, selection=selection)
    assert self.target is not None
    if(target > self.target):
      self.residue.atoms().set_xyz(sites_cart)
      self.target = target
      self.sites_cart = sites_cart

  def reset(self, sites_cart, selection=None):
    self.target = self.compute_target(sites_cart = sites_cart,
      selection = selection)
    self.sites_cart = sites_cart


 *******************************************************************************


 *******************************************************************************
mmtbx/refinement/real_space/adp.py
from __future__ import absolute_import, division, print_function
import mmtbx.refinement.real_space.utils
import mmtbx.refinement.utils
from scitbx.array_family import flex
from cctbx import adptbx
from libtbx import easy_mp
from mmtbx import bulk_solvent
from libtbx.test_utils import approx_equal
from six.moves import range
from cctbx import crystal
from mmtbx.refinement import adp_refinement
from cctbx import adp_restraints
from libtbx import group_args
from libtbx.str_utils import format_value
import scitbx.minimizers

import boost_adaptbx.boost.python as bp
cctbx_maptbx_ext = bp.import_ext("cctbx_maptbx_ext")

import random
random.seed(0)
flex.set_random_seed(0)

def map_and_model_to_fmodel(map_data, xray_structure, atom_radius, d_min,
                            reset_adp=True):
  box = mmtbx.utils.extract_box_around_model_and_map(
    xray_structure = xray_structure,
    map_data       = map_data,
    box_cushion    = atom_radius)
  box.apply_mask_inplace(atom_radius = atom_radius)
  f_obs_complex = box.box_map_coefficients(d_min = d_min)
  f_obs = abs(f_obs_complex)
  if(flex.mean(f_obs.data())<1.e-6): return None
  xrs = box.xray_structure_box.deep_copy_scatterers()
  if(reset_adp):
    vals_init = xrs.extract_u_iso_or_u_equiv()
    xrs = xrs.set_b_iso(value=0)
    assert approx_equal(flex.mean(xrs.extract_u_iso_or_u_equiv()),0.)
    f_calc = f_obs.structure_factors_from_scatterers(
      xray_structure = xrs).f_calc()
    sc = flex.sum(abs(f_obs).data()*abs(f_calc).data())/ \
         flex.sum(abs(f_calc).data()*abs(f_calc).data())
    f_calc = f_calc.array(data = f_calc.data()*sc)
    o = bulk_solvent.complex_f_kb_scaled(
      f1      = f_obs_complex.data(),
      f2      = f_calc.data(),
      b_range = flex.double(range(5,505,5)),
      ss      = 1./flex.pow2(f_calc.d_spacings().data()) / 4.)
    xrs = xrs.set_b_iso(value=o.b())
    k_isotropic = flex.double(f_calc.data().size(), o.k())
    if(o.k()<1.e-6):
      k_isotropic = flex.double(f_calc.data().size(), 1)
      xrs.set_u_iso(values = vals_init)
  fmodel = mmtbx.f_model.manager(f_obs = f_obs, xray_structure = xrs)
  if(reset_adp):
    fmodel.update_core(k_isotropic = k_isotropic)
  fmodel.update(target_name="ls_wunit_k1")
  fmodel.update_all_scales(update_f_part1=False, apply_back_trace=True,
    remove_outliers=False)
  return fmodel

def get_plain_pair_sym_table(crystal_symmetry, sites_frac, plain_pairs_radius=5):
  asu_mappings = crystal.symmetry.asu_mappings(crystal_symmetry,
    buffer_thickness = plain_pairs_radius)
  special_position_settings = crystal.special_position_settings(
    crystal_symmetry = crystal_symmetry)
  sites_cart = crystal_symmetry.unit_cell().orthogonalize(sites_frac)
  site_symmetry_table = special_position_settings.site_symmetry_table(
    sites_cart = sites_cart)
  asu_mappings.process_sites_frac(
    original_sites      = sites_frac,
    site_symmetry_table = site_symmetry_table)
  pair_asu_table = crystal.pair_asu_table(asu_mappings=asu_mappings)
  pair_asu_table.add_all_pairs(distance_cutoff = plain_pairs_radius)
  return pair_asu_table.extract_pair_sym_table()

class tg(object):
  def __init__(self, fmodel, x, restraints_weight, bound_flags,
               lower_bound, upper_bound):
    self.bound_flags = bound_flags
    self.lower_bound = lower_bound
    self.upper_bound = upper_bound
    self.restraints_weight = restraints_weight
    self.fmodel = fmodel
    self.plain_pair_sym_table = None
    self.adp_iso_params = None
    if(self.restraints_weight is not None):
      self.plain_pair_sym_table = get_plain_pair_sym_table(
        crystal_symmetry = self.fmodel.xray_structure.crystal_symmetry(),
        sites_frac       = self.fmodel.xray_structure.sites_frac())
      self.adp_iso_params = \
        adp_refinement.adp_restraints_master_params.extract().iso
    self.fmodel.xray_structure.scatterers().flags_set_grads(state=False)
    self.fmodel.xray_structure.scatterers().flags_set_grad_u_iso(
      iselection = self.fmodel.xray_structure.all_selection().iselection())
    # required fields
    self.x = x
    self.t = None
    self.g = None
    self.d = None
    self.use_curvatures=False
    #
    self.weight = None
    if(self.restraints_weight is not None):
      self.weight = self._weight()
    self.tgo = self._compute(x = self.x)
    self.update_target_and_grads(x=x)

  def _weight(self):
    num = self._restraints().gradients.norm()
    den = self._data().gradient_xray.norm()
    if(den==0): return 1
    return num/den

  def _restraints(self):
    return adp_restraints.energies_iso(
      plain_pair_sym_table = self.plain_pair_sym_table,
      xray_structure       = self.fmodel.xray_structure,
      parameters           = self.adp_iso_params,
      compute_gradients    = True,
      use_u_local_only     = self.adp_iso_params.use_u_local_only,
      use_hd               = False)

  def _data(self):
    fmodels = mmtbx.fmodels(fmodel_xray = self.fmodel)
    return fmodels.target_and_gradients(compute_gradients=True)

  def _compute(self, x):
    self.fmodel.xray_structure.set_b_iso(values = x)
    self.fmodel.update_xray_structure(update_f_calc = True)
    D = self._data()
    if(self.restraints_weight is not None):
      R = self._restraints()
      self.tgo = group_args(
        target   = D.target()*self.weight + R.target*self.restraints_weight,
        gradient = D.gradient_xray*self.weight + R.gradients*self.restraints_weight)
    else:
      self.tgo = group_args(
        target   = D.target(),
        gradient = D.gradient_xray)
    return self.tgo

  def update(self, x):
    self.update_target_and_grads(x = x)

  def update_target_and_grads(self, x):
    self.x = x
    self.tgo = self._compute(x=self.x)
    self.t = self.tgo.target
    self.g = self.tgo.gradient

  def target(self): return self.t

  def gradients(self): return self.g

  def gradient(self): return self.gradients()

class ncs_aware_refinement(object):
  def __init__(self, map_model_manager, d_min, atom_radius, nproc=1,
               log = None, individual = True, restraints_weight = 1,
               group_mode = None):
    self.mmm               = map_model_manager
    self.nproc             = nproc
    self.d_min             = d_min
    self.atom_radius       = atom_radius
    self.log               = log
    self.individual        = individual
    self.restraints_weight = restraints_weight
    self.group_mode        = group_mode
    #
    ncs_groups = self.mmm.model().get_ncs_groups()
    if(ncs_groups is None or len(ncs_groups)==0):
      values = self.run_one()
      self.mmm.model().set_b_iso(values = values)
    else:
      values = self.mmm.model().get_b_iso()
      for i, g in enumerate(ncs_groups):
        values_g = self.run_one(selection = g.master_iselection)
        values = values.set_selected(g.master_iselection, values_g)
        for j, c in enumerate(g.copies):
          values = values.set_selected(c.iselection, values_g)
      self.mmm.model().set_b_iso(values = values)

  def run_one(self, selection=None):
    model = self.mmm.model()
    if(selection is not None): model = model.select(selection)
    values = model.get_b_iso()
    model.get_hierarchy().atoms().reset_i_seq()
    if(self.nproc==1):
      args = [model,]
      return self.run_one_one(args = args)
    else:
      argss = []
      selections = []
      for sel in model.macromolecule_plus_hetatms_by_chain_selections():
        model_i = model.select(sel)
        if(model_i.size()==1):
          chain_ids = " ".join([c.id for c in model_i.get_hierarchy().chains()])
          print("Skip one atom model, chains: (%s)"%chain_ids, file=self.log)
          continue
        argss.append([model_i,])
        selections.append(sel) # XXX CAN BE BIG
      stdout_and_results = easy_mp.pool_map(
        processes    = self.nproc,
        fixed_func   = self.run_one_one,
        args         = argss,
        func_wrapper = "buffer_stdout_stderr")
      for i, result in enumerate(stdout_and_results):
        values = values.set_selected(selections[i], result[1])
      model.set_b_iso(values = values)
      return values

  def run_one_one(self, args):
    model = args[0]
    log = self.log
    if(self.nproc>1): log = None
    #
    fmodel = map_and_model_to_fmodel(
      map_data       = self.mmm.map_data().deep_copy(),
      xray_structure = model.get_xray_structure(),
      atom_radius    = self.atom_radius,
      d_min          = self.d_min)
    if(fmodel is None):
      return model.get_xray_structure().extract_u_iso_or_u_equiv()*adptbx.u_as_b(1.)
    # selections for group ADP
    ph_box = model.get_hierarchy()
    ph_box.atoms().reset_i_seq()
    group_adp_sel = []
    if(self.group_mode=="one_per_residue"):
      for rg in ph_box.residue_groups():
        group_adp_sel.append(rg.atoms().extract_i_seq())
    elif(self.group_mode=="one_per_chain"):
      for chain in ph_box.chains():
        group_adp_sel.append(chain.atoms().extract_i_seq())
    else:
      assert self.group_mode is None
    if self.group_mode is not None:
      #
      b_isos = fmodel.xray_structure.extract_u_iso_or_u_equiv()*adptbx.u_as_b(1.)
      if(flex.max(b_isos)<1.e-2):
        b_isos = flex.random_double(model.size())*10
        model.set_b_iso(values = b_isos)
        fmodel.xray_structure.set_b_iso(values = b_isos)
        fmodel.update_xray_structure(xray_structure = fmodel.xray_structure,
          update_f_calc = True)
      #
      number_of_macro_cycles = 3
      if(self.individual): number_of_macro_cycles = 1
      group_b_manager = mmtbx.refinement.group.manager(
        fmodel                   = fmodel,
        selections               = group_adp_sel,
        convergence_test         = False,
        max_number_of_iterations = 50,
        number_of_macro_cycles   = number_of_macro_cycles,
        run_finite_differences_test = False,
        use_restraints           = True,
        refine_adp               = True,
        log                      = log)
      fmodel.update_all_scales(update_f_part1=False, apply_back_trace=True,
        remove_outliers=False)
      b_isos = fmodel.xray_structure.extract_u_iso_or_u_equiv()*adptbx.u_as_b(1.)
      model.set_b_iso(values = b_isos)
    #
    if(self.individual):
      if(log is not None):
        rmsb = format_value("%4.2f", model.rms_b_iso_or_b_equiv()).strip()
        print("r_work (start): %6.4f rms_B_bonded: %s"%(fmodel.r_work(),
          rmsb), file=log)
      rw = self.restraints_weight
      if(rw is not None):
        flipped = False
        for it in range(1,20):
          x = fmodel.xray_structure.extract_u_iso_or_u_equiv()*adptbx.u_as_b(1.)
          lower = flex.double(x.size(), 0)
          upper = flex.double(x.size(), flex.max(x)*2)
          calculator = tg(
            fmodel            = fmodel,
            x                 = x,
            restraints_weight = rw,
            bound_flags       = flex.int(x.size(), 2),
            lower_bound       = lower,
            upper_bound       = upper)
          rw_prev = rw
          b_isos_prev = b_isos
          rms_b_prev = model.rms_b_iso_or_b_equiv()
          m = scitbx.minimizers.lbfgs(
            mode='lbfgsb', max_iterations=100, calculator=calculator)
          b_isos = fmodel.xray_structure.extract_u_iso_or_u_equiv()*adptbx.u_as_b(1.)
          model.set_b_iso(values = b_isos)
          if(rms_b_prev is not None):
            rms_b = model.rms_b_iso_or_b_equiv()
            if(rms_b<5):
              rw = rw/2
              if(flipped):
                b_isos = b_isos_prev
                model.set_b_iso(values = b_isos)
                break
            else:
              if(rms_b > rms_b_prev):
                b_isos = b_isos_prev
                model.set_b_iso(values = b_isos)
                break
              rw = rw*2
              flipped = True
            if(log is not None):
              print(
                "r_work: %6.4f rms_B_bonded: %4.2f restraints_weight: %6.4f"%(
                fmodel.r_work(), rms_b, rw), file=log)
          if(rms_b_prev is None): break
      else:
        for it in range(1,2):
          x = fmodel.xray_structure.extract_u_iso_or_u_equiv()*adptbx.u_as_b(1.)
          ma = min(999,flex.max(x)*2)
          if ma<1: ma = 100
          lower = flex.double(x.size(), 0)
          upper = flex.double(x.size(), ma )
          calculator = tg(
            fmodel            = fmodel,
            x                 = x,
            restraints_weight = None,
            bound_flags       = flex.int(x.size(), 2),
            lower_bound       = lower,
            upper_bound       = upper)
          m = scitbx.minimizers.lbfgs(
            mode='lbfgsb', max_iterations=100, calculator=calculator)
          b_isos = fmodel.xray_structure.extract_u_iso_or_u_equiv()*adptbx.u_as_b(1.)
          model.set_b_iso(values = b_isos)
          if(log is not None):
            print("r_work: %6.4f"%fmodel.r_work(), file=log)
    #
    fmodel.xray_structure.set_b_iso(values = b_isos)
    fmodel.update_xray_structure(xray_structure = fmodel.xray_structure,
      update_f_calc = True)
    if(log is not None):
      print("r_work (final): %6.4f"%fmodel.r_work(), file=log)
    #
    return b_isos


 *******************************************************************************


 *******************************************************************************
mmtbx/refinement/real_space/explode_and_refine.py
from __future__ import absolute_import, division, print_function
from  mmtbx.refinement import geometry_minimization
import mmtbx.refinement.real_space.individual_sites
from cctbx import maptbx
from libtbx import adopt_init_args
import random, time
from scitbx.array_family import flex
from mmtbx.dynamics import simulated_annealing as sa
from cctbx import geometry_restraints
import scitbx.lbfgs
from mmtbx.building.merge_models import run as merge_models
import sys
from six.moves import range
from libtbx.test_utils import approx_equal

if (0): # fixed random seed to avoid rare failures
  random.seed(1)
  flex.set_random_seed(1)

def sa_simple(rm, xrs, ph, map_data, log):
  tmp_xrs = xrs.deep_copy_scatterers()
  ro = mmtbx.refinement.real_space.individual_sites.easy(
    map_data                    = map_data,
    xray_structure              = tmp_xrs,
    pdb_hierarchy               = ph.deep_copy(),
    geometry_restraints_manager = rm,
    rms_bonds_limit             = 0.01,
    rms_angles_limit            = 1.0,
    selection                   = None, #TODO
    log                         = log)
  weight = ro.w
  #
  from mmtbx.dynamics import simulated_annealing as sa
  tmp = xrs.deep_copy_scatterers()
  params = sa.master_params().extract()
  params.start_temperature=5000
  params.cool_rate=500
  sa.run(
    params             = params,
    xray_structure     = tmp,
    real_space         = True,
    target_map         = map_data,
    restraints_manager = rm,
    wx                 = weight,
    wc                 = 1.,
    verbose            = False,
    log                = log)
  return tmp.sites_cart()

class scorer(object):
  def __init__(self, pdb_hierarchy, unit_cell, map_data):
    adopt_init_args(self, locals())
    self.sites_cart = self.pdb_hierarchy.atoms().extract_xyz()
    self.target = maptbx.real_space_target_simple(
      unit_cell   = self.unit_cell,
      density_map = self.map_data,
      sites_cart  = self.sites_cart)

  def update(self, sites_cart):
    target = maptbx.real_space_target_simple(
      unit_cell   = self.unit_cell,
      density_map = self.map_data,
      sites_cart  = sites_cart)
    if(target > self.target):
      self.target = target
      self.sites_cart = sites_cart

class run_sa(object):
  def __init__(
        self,
        xray_structure, # XXX redundant
        pdb_hierarchy,
        restraints_manager,
        map_data,
        number_of_trials,
        nproc,
        weight):
    adopt_init_args(self, locals())
    # Initialize states collector
    self.states = mmtbx.utils.states(
      pdb_hierarchy = self.pdb_hierarchy.deep_copy())
    # SA params
    self.params = sa.master_params().extract()
    self.params.start_temperature=50000
    self.params.final_temperature=0
    self.params.cool_rate = 25000
    self.params.number_of_steps = 50
    # minimizer params
    self.grf = geometry_restraints.flags.flags(default=True)
    self.lbfgs_exception_handling_params = \
      scitbx.lbfgs.exception_handling_parameters(
        ignore_line_search_failed_step_at_lower_bound = True,
        ignore_line_search_failed_step_at_upper_bound = True,
        ignore_line_search_failed_maxfev              = True)
    # pre-compute random seeds
    random_seeds = []
    for it in range(self.number_of_trials):
      random_seeds.append(random.randint(0,10000000))
    # run SA
    self.results = []
    if(self.nproc>1):
      from libtbx import easy_mp
      stdout_and_results = easy_mp.pool_map(
        processes    = self.nproc,
        fixed_func   = self.run,
        args         = random_seeds,
        func_wrapper = "buffer_stdout_stderr")
      for so, xrs in stdout_and_results :
        self.results.append(xrs)
        self.states.add(sites_cart = xrs.sites_cart())
    else:
      for random_seed in random_seeds:
        xrs = self.run(random_seed=random_seed).deep_copy_scatterers()
        self.results.append(xrs)
        self.states.add(sites_cart = xrs.sites_cart())
    assert len(self.results) == self.number_of_trials

  def ensemble_xrs(self):
    return self.results

  def show_states(self, file_name="SA_ensemble.pdb"):
    self.states.write(file_name=file_name)

  def run(self, random_seed):
    tmp = self.xray_structure.deep_copy_scatterers()
    # Shake and minimize to get variable starting points
    tmp.shake_sites_in_place(
      rms_difference = None,
      mean_distance  = 5)
    sites_cart_ = tmp.sites_cart()
    minimized = geometry_minimization.lbfgs(
      sites_cart                        = sites_cart_,
      correct_special_position_tolerance= 1.0,
      geometry_restraints_manager       = self.restraints_manager.geometry,
      geometry_restraints_flags         = self.grf,
      lbfgs_exception_handling_params   = self.lbfgs_exception_handling_params,
      lbfgs_termination_params          = scitbx.lbfgs.termination_parameters(
        max_iterations=50))
    tmp = tmp.replace_sites_cart(new_sites = sites_cart_)
    #
    random.seed(random_seed)
    flex.set_random_seed(random_seed)
    sa.run(
      params             = self.params,
      xray_structure     = tmp,
      real_space         = True,
      target_map         = self.map_data,
      restraints_manager = self.restraints_manager,
      wx                 = self.weight,
      wc                 = 1.,
      verbose            = False)
    return tmp

class ensemble_refine(object):
  def __init__(
        self,
        pdb_hierarchy,
        ensemble_xrs,
        restraints_manager,
        target_bond_rmsd,
        target_angle_rmsd,
        map_data,
        weight,
        nproc):
    adopt_init_args(self, locals())
    self.crystal_symmetry = self.ensemble_xrs[0].crystal_symmetry()
    # initialize states collector
    self.states = mmtbx.utils.states(
      pdb_hierarchy  = self.pdb_hierarchy.deep_copy())
    # run minimization
    if(self.nproc>1):
      from libtbx import easy_mp
      stdout_and_results = easy_mp.pool_map(
        processes    = self.nproc,
        fixed_func   = self.run,
        args         = self.ensemble_xrs,
        func_wrapper = "buffer_stdout_stderr")
      for so, sites_cart in stdout_and_results :
        self.states.add(sites_cart = sites_cart)
    else:
      for xrs in self.ensemble_xrs:
        sites_cart = self.run(xray_structure=xrs)
        self.states.add(sites_cart = sites_cart)

  def show_states(self, file_name="SA_ensemble_refined.pdb"):
    self.states.write(file_name=file_name,
      crystal_symmetry=self.crystal_symmetry)

  def ensemble_pdb_hierarchy_refined(self):
    return self.states.root

  def run(self, xray_structure):
    self.pdb_hierarchy.adopt_xray_structure(xray_structure)
    ro = mmtbx.refinement.real_space.individual_sites.easy(
      map_data                    = self.map_data,
      xray_structure              = xray_structure,
      pdb_hierarchy               = self.pdb_hierarchy,
      geometry_restraints_manager = self.restraints_manager,
      rms_bonds_limit             = self.target_bond_rmsd,
      rms_angles_limit            = self.target_angle_rmsd,
      max_iterations              = 250,
      selection                   = None,
      w                           = self.weight,
      log                         = None)
    return ro.xray_structure.sites_cart()

class run(object):
  def __init__(
        self,
        xray_structure,
        pdb_hierarchy,
        map_data,
        restraints_manager,
        score_method=["merge_models",],
        resolution=None,
        mode="quick",
        target_bond_rmsd=0.02,
        target_angle_rmsd=2.0,
        number_of_trials=20,
        nproc=1,
        states=None,
        map_data_ref=None,
        fragments=None,
        show=True,
        log=None):
    if not map_data_ref:
      map_data_ref = map_data # XXX in case map_data_ref is not supplied
    adopt_init_args(self, locals())
    assert self.mode in ["quick", "thorough"]
    if(self.log is None): self.log = sys.stdout
    self.show_target(prefix="Target(start):")
    # Get refined starting model
    if(mode=="thorough"):
      weights = self.run_refine_flexible_rmsd_targets()
      er_weight = flex.mean(weights)
      sa_weight = weights[0]
    else:
      sa_weight = self.minimization(
        target_bond_rmsd  = 0.03,
        target_angle_rmsd = 3.5,
        weight            = None)
      er_weight = sa_weight
    self.show_target(prefix="Target(minimization):")
    # Generate SA ensemble of structures
    sao = run_sa(
      xray_structure     = self.xray_structure,
      pdb_hierarchy      = self.pdb_hierarchy,
      restraints_manager = self.restraints_manager,
      map_data           = self.map_data,
      number_of_trials   = self.number_of_trials,
      nproc              = self.nproc,
      weight             = sa_weight)
    self.ensemble_xrs = sao.ensemble_xrs()
    if(show): sao.show_states()
    # Refine each SA model
    self.ero = ensemble_refine(
      pdb_hierarchy       = self.pdb_hierarchy,
      ensemble_xrs        = self.ensemble_xrs,
      restraints_manager  = self.restraints_manager,
      target_bond_rmsd    = self.target_bond_rmsd,
      target_angle_rmsd   = self.target_angle_rmsd,
      map_data            = self.map_data,
      weight              = er_weight,
      nproc               = self.nproc)
    if(show): self.ero.show_states()
    # Merge SA refined models
    self.merge_models(pdb_hierarchy = self.ero.ensemble_pdb_hierarchy_refined())
    self.show_target(prefix="Target(merge):")
    # Finalize
    if(mode=="thorough"):
      self.run_refine_flexible_rmsd_targets(weights = weights)
    else:
      _ = self.minimization(
        target_bond_rmsd  = self.target_bond_rmsd,
        target_angle_rmsd = self.target_angle_rmsd,
        weight            = None)
    #
    assert approx_equal(self.xray_structure.sites_cart(),
                        self.pdb_hierarchy.atoms().extract_xyz())
    self.final_cc = None
    if(self.resolution is not None):
      self.final_cc = self.get_cc(xrs=self.xray_structure)
    self.show_target(prefix="Target(final minimization):")

  def ensemble_pdb_hierarchy_refined(self):
    return self.ero.ensemble_pdb_hierarchy_refined()

  def pdb_hierarchy_overall_best(self):
    return self.pdb_hierarchy

  def get_cc(self, xrs=None, sites_cart=None):
    if(sites_cart is not None):
      xrs = self.xray_structure.deep_copy_scatterers()
      xrs.set_sites_cart(sites_cart)
    fc = xrs.structure_factors(d_min=self.resolution).f_calc()
    fo = fc.structure_factors_from_map(map=self.map_data_ref, use_sg=False)
    return fc.map_correlation(other=fo)

  def _score_by_geometry(self, pdb_hierarchy):
    uc = self.xray_structure.unit_cell()
    sites_cart = flex.vec3_double(self.xray_structure.scatterers().size())
    # Planes
    sel = flex.size_t(self.fragments.planes_all)
    SC = scorer(
      pdb_hierarchy = self.pdb_hierarchy.select(sel),
      unit_cell     = uc,
      map_data      = self.map_data_ref)
    for model in pdb_hierarchy.models():
      SC.update(sites_cart = model.atoms().extract_xyz().select(sel))
    sites_cart = sites_cart.set_selected(sel, SC.sites_cart)
    # Chirals
    sel = flex.size_t(self.fragments.chirals_all)
    SC = scorer(
      pdb_hierarchy = self.pdb_hierarchy.select(sel),
      unit_cell     = uc,
      map_data      = self.map_data)
    for model in pdb_hierarchy.models():
      SC.update(sites_cart = model.atoms().extract_xyz().select(sel))
    sel = flex.size_t(self.fragments.chirals_unique)
    tmp = SC.sites_cart.select(self.fragments.chirals_mapping)
    sites_cart = sites_cart.set_selected(sel, tmp)
    # Dihedrals
    sel = flex.size_t(self.fragments.dihedrals_all)
    SC = scorer(
      pdb_hierarchy = self.pdb_hierarchy.select(sel),
      unit_cell     = uc,
      map_data      = self.map_data)
    for model in pdb_hierarchy.models():
      SC.update(sites_cart = model.atoms().extract_xyz().select(sel))
    sel = flex.size_t(self.fragments.dihedrals_unique)
    tmp = SC.sites_cart.select(self.fragments.dihedrals_mapping)
    sites_cart = sites_cart.set_selected(sel, tmp)
    #
    self.xray_structure.set_sites_cart(sites_cart = sites_cart)
    self.pdb_hierarchy.adopt_xray_structure(self.xray_structure)
    #
    sites_cart = sa_simple(
      rm       = self.restraints_manager, xrs=self.xray_structure,
      ph       = self.pdb_hierarchy,
      map_data = self.map_data,
      log      = None)
    self.xray_structure.set_sites_cart(sites_cart = sites_cart)
    self.pdb_hierarchy.adopt_xray_structure(self.xray_structure)
    sites_cart = sa_simple(
        rm=self.restraints_manager, xrs=self.xray_structure,
        ph=self.pdb_hierarchy,
        map_data=self.map_data,
        log=None)
    return sites_cart

  def _score_by_cc(self, pdb_hierarchy):
    t0 = time.time()
    xrs = self.xray_structure.deep_copy_scatterers()
    cc=-1
    sites_cart = None
    for model in pdb_hierarchy.models():
      sites_cart_ = model.atoms().extract_xyz()
      xrs.set_sites_cart(sites_cart = sites_cart_)
      cc_ = self.get_cc(xrs=xrs)
      if(cc_>cc):
        cc = cc_
        sites_cart = sites_cart_.deep_copy()
    return sites_cart

  def merge_models(self, pdb_hierarchy):
    #
    t0=time.time()
    sites_cart = []
    if("geometry" in self.score_method or "cc" in self.score_method):
      if("geometry" in self.score_method):
        sites_cart.append(self._score_by_geometry(pdb_hierarchy = pdb_hierarchy))
      if("cc" in self.score_method):
        sites_cart.append(self._score_by_cc(pdb_hierarchy = pdb_hierarchy))
      sites_cart_best = None
      cc_best = -1
      for sc in sites_cart:
        cc = self.get_cc(sites_cart=sc)
        if(cc>cc_best):
          cc_best = cc
          sites_cart_best = sc.deep_copy()
      self.xray_structure.set_sites_cart(sites_cart = sites_cart_best)
      self.pdb_hierarchy.adopt_xray_structure(self.xray_structure)
      self.pdb_hierarchy.write_pdb_file(file_name="merged.pdb")
    #
    if("merge_models" in self.score_method):
      from mmtbx.building.merge_models import run as merge_models
      pdb_hierarchy_merged, pdb_out = merge_models(
        map_data         = self.map_data,
        resolution       = self.resolution,
        pdb_hierarchy    = pdb_hierarchy,
        crystal_symmetry = self.xray_structure.crystal_symmetry(),
        out              = self.log)
      if(self.show):
        pdb_hierarchy_merged.write_pdb_file(
          file_name="SA_ensemble_refined_merged.pdb")
      self.xray_structure = self.xray_structure.replace_sites_cart(
        new_sites=pdb_hierarchy_merged.atoms().extract_xyz())
      self.pdb_hierarchy.adopt_xray_structure(self.xray_structure)
    print("Time (merge): %10.3f"%(time.time()-t0), file=self.log)

  def minimization(self, target_bond_rmsd, target_angle_rmsd, weight):
    ro = mmtbx.refinement.real_space.individual_sites.easy(
      map_data                    = self.map_data,
      xray_structure              = self.xray_structure,
      pdb_hierarchy               = self.pdb_hierarchy,
      geometry_restraints_manager = self.restraints_manager,
      rms_bonds_limit             = target_bond_rmsd,
      rms_angles_limit            = target_angle_rmsd,
      max_iterations              = 50,
      selection                   = None,
      w                           = weight,
      states_accumulator          = self.states,
      log                         = None)
    self.xray_structure.replace_scatterers(
      scatterers=ro.xray_structure.scatterers())
    self.pdb_hierarchy.adopt_xray_structure(self.xray_structure)
    return ro.w

  def run_refine_flexible_rmsd_targets(self, weights=None):
    t0=time.time()
    ro=None
    result = flex.double()
    pairs = [(0.10,10.,), (0.05,5.0,), (0.03,3.5,), (0.025,2.5), (0.02,2.0)]
    for i, pair in enumerate(pairs):
      if(weights is None): w = None
      else:                w = weights[i-1]
      w_opt = self.minimization(
        target_bond_rmsd  = pair[0],
        target_angle_rmsd = pair[1],
        weight            = w)
      result.append(w_opt)
    print("Time (run_refine_flexible_rmsd_targets): %10.3f"%(
      time.time()-t0), file=self.log)
    return result

  def show_target(self, prefix):
    if(self.show):
      print(prefix, maptbx.real_space_target_simple(
          unit_cell   = self.xray_structure.unit_cell(),
          density_map = self.map_data,
          sites_cart  = self.xray_structure.sites_cart()), file=self.log)


 *******************************************************************************


 *******************************************************************************
mmtbx/refinement/real_space/fit_his.py
from __future__ import absolute_import, division, print_function
from cctbx.array_family import flex
from cctbx import maptbx
import mmtbx.idealized_aa_residues.rotamer_manager
from libtbx import group_args

from mmtbx.refinement.real_space import fit_residue

import boost_adaptbx.boost.python as bp
ext = bp.import_ext("mmtbx_rotamer_fit_ext")

from mmtbx.idealized_aa_residues import all_his
from scitbx.math import superpose

import mmtbx.monomer_library.server
mon_lib_srv = mmtbx.monomer_library.server.server()

non_h_ring_atom_names = ["CG", "ND1", "CD2", "CE1", "NE2"]

def manageable_HIS(rg):
  result = group_args(
    is_true_altloc = False,
    has_h          = False,
    has_d          = False)
  resnames=[]
  elements = []
  atom_groups = rg.atom_groups()
  coords = []
  if(len(atom_groups)>3): return None # True altlocs
  for i, ag in enumerate(rg.atom_groups()):
    if(ag.resname.strip().upper()!="HIS"): return None # Not HIS
    elements.extend( [e.strip().upper() for e in ag.atoms().extract_element()] )
    for a in ag.atoms():
      if(a.name.strip().upper()=="CE1"):
        coords.append(a.xyz)
  if(len(coords)!=1): return None
  elements = list(set(elements))
  print(elements)
  result.has_h = "H" in elements
  result.has_d = "D" in elements
  return result

def match_residue_groups(rg_working, rg_to_insert):
  # Rigid-body superpose rings
  atoms_fixed  = []
  atoms_moving = []
  for n in non_h_ring_atom_names:
    for atom_to_insert in rg_to_insert.atoms():
      if(atom_to_insert.name.strip().upper() == n):
        atoms_moving.append(atom_to_insert)
    for atom_working in rg_working.atoms():
      if(atom_working.name.strip().upper() == n):
        atoms_fixed.append(atom_working)
  sites_fixed  = flex.vec3_double([a.xyz for a in atoms_fixed])
  sites_moving = flex.vec3_double([a.xyz for a in atoms_moving])
  lsq_fit_obj = superpose.least_squares_fit(
    reference_sites = sites_fixed,
    other_sites     = sites_moving)
  sites_moved = lsq_fit_obj.r.elems*rg_to_insert.atoms().extract_xyz()+lsq_fit_obj.t.elems
  # Overlay ring
  for i, atom_moving in enumerate(rg_to_insert.atoms()):
    atom_moving.set_xyz(sites_moved[i])
  # Then match the rest
  for atom_to_insert in rg_to_insert.atoms():
    for atom_working in rg_working.atoms():
      if(atom_to_insert.name.strip().upper() !=
           atom_working.name.strip().upper()): continue
      atom_to_insert.set_xyz(atom_working.xyz)
      atom_to_insert.set_b(atom_working.b)
      atom_to_insert.set_charge(atom_working.charge)
      atom_to_insert.set_fdp(atom_working.fdp)
      atom_to_insert.set_fp(atom_working.fp)
      atom_to_insert.set_occ(atom_working.occ)
      atom_to_insert.set_segid(atom_working.segid)
      atom_to_insert.set_serial(atom_working.serial)
      atom_to_insert.set_uij(atom_working.uij)
      if(not atom_to_insert.name.strip().upper() in non_h_ring_atom_names):
        atom_to_insert.set_xyz(atom_working.xyz)

def run(hierarchy, map_data, mon_lib_srv, rotamer_manager, unit_cell):
  allhis = all_his.load()

  def compute_target(rg):
     sites_cart  = rg.atoms().extract_xyz()
     t = maptbx.real_space_target_simple(
        unit_cell   = unit_cell,
        density_map = map_data,
        sites_cart  = sites_cart)
     return t/sites_cart.size()

  def per_atom(rg):
    #hs = ["CG", "ND1", "CE1", "NE2", "CD2", "HD1", "HE1", "HE2", "HD2"]
    hs = ["HD1", "HE1", "HE2", "HD2",   "DD1", "DE1", "DE2", "DD2"]
    vals = []
    for a in rg.atoms():
      if a.name.strip().upper() in hs:
        t = maptbx.real_space_target_simple(
          unit_cell   = unit_cell,
          density_map = map_data,
          sites_cart  = flex.vec3_double([a.xyz,]))
        vals.append("%s %5.2f"%(a.name.strip().upper(),t))
    return " ".join(vals)


  for c in hierarchy.chains():
    for i, rg in enumerate(c.residue_groups()):
      o = manageable_HIS(rg=rg)
      if(o is None): continue

      print("chain %s resid %s"%(c.id, rg.resid()),"-"*20)

      rg_dc = rg.detached_copy()
      rg_w  = rg
      print("  t orig:", compute_target(rg), per_atom(rg))
      for i, rg_to_insert in enumerate(allhis.main_three()):
        print("  protonation", i)

        rg_to_insert = allhis.r["d1"]

        rg_to_insert.resseq = rg_w.resseq
        match_residue_groups(rg_working=rg_w, rg_to_insert=rg_to_insert)
        print("    t start:", compute_target(rg_to_insert), per_atom(rg_to_insert))

        o = fit_residue.tune_up(
          target_map           = map_data,
          residue              = rg_to_insert,
          mon_lib_srv          = mon_lib_srv,
          rotamer_manager      = None,
          unit_cell            = unit_cell,
          exclude_hd           = False,
          torsion_search_start = -5,
          torsion_search_stop  = 5,
          torsion_search_step  = 0.1)
        print("    t final:", compute_target(o.residue), per_atom(o.residue))

        rg_to_insert = o.residue.detached_copy()
        c.remove_residue_group(rg_w)
        rg_to_insert.link_to_previous=True
        c.insert_residue_group(i=i, residue_group=rg_to_insert)
        rg_w  = rg_to_insert
        break

        if 0:
          c.remove_residue_group(rg_w)
          rg_to_insert.link_to_previous=True
          c.insert_residue_group(i=i, residue_group=rg_to_insert)
          rg_w  = rg_to_insert

  #
  hierarchy.write_pdb_file(file_name = "inserted.pdb")


 *******************************************************************************


 *******************************************************************************
mmtbx/refinement/real_space/fit_residue.py
from __future__ import absolute_import, division, print_function
from cctbx.array_family import flex
from libtbx import adopt_init_args
import mmtbx.refinement.real_space
from mmtbx.refinement.real_space import individual_sites
import math, sys
from cctbx import maptbx
import scitbx.math
import mmtbx.idealized_aa_residues.rotamer_manager
import collections
from libtbx import group_args
from collections import OrderedDict
from scitbx.matrix import rotate_point_around_axis

import boost_adaptbx.boost.python as bp
from six.moves import range
ext = bp.import_ext("mmtbx_rotamer_fit_ext")

def flatten(l):
  if l is None: return None
  return sum(([x] if not (isinstance(x, list) or isinstance(x, flex.size_t))
    else flatten(x) for x in l), [])

class monitor(object):
  def __init__(self, id_str, selection, map_data, unit_cell, weights, pairs,
               cmv, rotamer_evaluator, log):
    adopt_init_args(self, locals())
    self.states = collections.OrderedDict()

  def add(self, residue, state):
    vals = collections.OrderedDict()
    target     = 0
    target_neg = 0
    exceed_map_max_value = False
    for i in self.selection:
      atom = residue.atoms()[i]
      key = "%s_%s_%s"%(
        atom.parent().parent().parent().id, atom.parent().resname,
        atom.name.strip())
      name = atom.name.strip().upper()
      element = atom.element.strip().upper()
      if(element in ["H","D"]): continue
      mv = self.map_data.eight_point_interpolation(
        self.unit_cell.fractionalize(atom.xyz))
      vals[name] = mv
      if(mv > self.cmv[key]*3 and not element in ["S","SE"]):
        exceed_map_max_value = True
      target += mv
      if(mv < 0): target_neg += mv
    #
    rot = self.rotamer_evaluator.evaluate_residue(residue)
    self.states[state] = group_args(
      vals       = vals,
      sites_cart = residue.atoms().extract_xyz(),
      target     = target,
      target_neg = target_neg,
      exceed_map_max_value = exceed_map_max_value,
      rot        = rot)

  def finalize(self, residue):
    if(len(self.states.keys())==1 or self.selection.size()==0): return
    state = "start"
    S     = self.states["start"]
    F     = self.states["fitting"]
    try:
      T     = self.states["tuneup"]
    except KeyError:
      T = None
    #
    if((S.rot=="OUTLIER" and F.rot!="OUTLIER" and not F.exceed_map_max_value) or
       (F.target>S.target and F.target_neg>=S.target_neg and not F.exceed_map_max_value) or
       (F.target_neg>S.target_neg) or
       (S.exceed_map_max_value and not F.exceed_map_max_value)):
      state = "fitting"
    N = self.states[state]
    if(T is not None):
      if((N.rot=="OUTLIER" and T.rot!="OUTLIER" and not T.exceed_map_max_value) or
         (T.target>N.target and T.target_neg>=S.target_neg and not T.exceed_map_max_value) or
         (T.target_neg>N.target_neg) or
         (N.exceed_map_max_value and not T.exceed_map_max_value)):
        state = "tuneup"
    #
    residue.atoms().set_xyz(self.states[state].sites_cart)
    #
    if(T is not None and state != "tuneup"):
      self.add(residue = residue, state = "revert")
    #

  def show(self):
    if(len(self.states.keys())==1 or self.selection.size()==0): return
    print(self.id_str, file=self.log)
    for k,v in zip(self.states.keys(), self.states.values()):
      vals = " ".join(["%s: %5.2f"%(k_, v_)
        for k_,v_ in zip(v.vals.keys(), v.vals.values())])
      print("  %7s: score: %7.3f %s %s"%(k, v.target, vals, v.rot), file=self.log)

def find_peak(angles, values, threshold):
  peaks = []
  s = len(values)
  #print("looking at peaks", s)
  for i, a in enumerate(angles):
    v = values[i]
    if v < threshold: continue
    ip1 = i+1 if i+1 < s else abs(s-(i+1))
    ip2 = i+2 if i+2 < s else abs(s-(i+2))
    ip3 = i+3 if i+3 < s else abs(s-(i+3))
    vip1 = values[ip1]
    vip2 = values[ip2]
    vip3 = values[ip3]
    im1 = i-1
    im2 = i-2
    im3 = i-3
    vim1 = values[im1]
    vim2 = values[im2]
    vim3 = values[im3]
    #print("   ", a, v, "|", vim1,vim2,vim3,  vip1,vip2,vip3)
    stop = False
    for vv in [vip1,vip2,vip3, vim1,vim2,vim3]:
      if vv < threshold: stop=True
    if stop: continue
    fl=vim1<v and vim2<vim1 and vim3<vim2 and  vip1<v and vip2<vip1 and vip3<vip2
    #print(fl, "<>", vim1<v , vim2<vim1 , vim3<vim2 ,  vip1<v , vip2<vip1 , vip3<vip2)
    if(fl):
      peaks.append(a)
  return peaks

class find_all_conformers(object):

  def __init__(self, residue, map_data, mon_lib_srv, unit_cell, threshold,
                     rotamer_evaluator):
    adopt_init_args(self, locals())
    sites_cart = residue.atoms().extract_xyz()
    self.side_chain_selection = flex.size_t()
    for a in residue.atoms():
      if a.name.strip().upper() in ["CA","O","C","N","CB"]: continue
      if a.element_is_hydrogen(): continue
      self.side_chain_selection.append(a.i_seq)
    #
    self.target_start, _ = self._get_target(sites_cart)
    #
    co = mmtbx.refinement.real_space.aa_residue_axes_and_clusters(
      residue         = residue,
      mon_lib_srv     = mon_lib_srv,
      backbone_sample = False)
    clusters = co.clusters
    self.rsr_eval_selection = co.rsr_eval_selection

    #print()
    #print(residue.resname, residue.resseq)
    #print("hd_selection", list(self.hd_selection))
    #print("rsr_eval_selection", list(co.rsr_eval_selection))
    #for c in clusters:
    #  print(list(c.axis))
    #  print(list(c.atoms_to_rotate))
    #
    self.sites_cart_conformers_all = []
    last=False
    for i, cl in enumerate(clusters):
      if i == len(clusters)-1: last=True
      if i==0:
        self.func(cl=cl, sites_cart=sites_cart,  last=last)
      else:
        for sites_cart_ in self.sites_cart_conformers_all[:]:
          self.func(cl=cl, sites_cart=sites_cart_, last=last)
    #
    self.rotamers = {}
    tbest = None
    tmp = []
    for sites_cart in self.sites_cart_conformers_all:
      residue.atoms().set_xyz(sites_cart)
      rotamer_status = rotamer_evaluator.evaluate_residue(residue)
      if rotamer_status == "OUTLIER": continue
      t, vals = self._get_target(sites_cart=sites_cart)
      #print(rotamer_status, " ".join(["%6.2f"%v for v in vals]))
      #
      sel = vals < threshold
      if sel.count(True)>0: continue
      #if t<=self.target_start: continue
      #print(rotamer_status, " ".join(["%6.2f"%v for v in vals]), "<<<<<<<<", t)
      self.rotamers.setdefault(rotamer_status, []).append([t,sites_cart])
      tmp.append(sites_cart)
    self.sites_cart_conformers_all = tmp
    #
    #print("rotamers")
    #for k,v in self.rotamers.items():
    #  print("      ", k,[vv[0] for vv in v])

    self.unique = {}
    for k,v in self.rotamers.items():
      vbest  = -1.e9
      ssbest = None
      for it in v:
        vv, ss = it
        if vv > vbest:
          vbest = vv
          ssbest = ss
      self.unique[k] = [vbest, ssbest]
    #print("unique")
    #for k, v in self.unique.items():
    #  print("   ", k, v)
    #
    self.unique_sorted = None

  def _get_target(self, sites_cart):
    vals = flex.double()
    for sc in sites_cart.select(self.side_chain_selection):
      vals.append(self.map_data.tricubic_interpolation(
        self.unit_cell.fractionalize(sc)))
    return flex.mean(vals), vals

  def sorted_by_map_value(self, n=None):
    tbest=-9999
    scbest = None
    if self.unique=={}: return None
    for k, v in self.unique.items():
      t = v[0]
      if t > tbest:
        tbest = t
        scbest = v[1].deep_copy()
    return [scbest]

    #if self.unique_sorted is not None: return self.unique_sorted
    #self.unique_sorted = OrderedDict()
    #for k,v in self.unique.items():
    #  self.unique_sorted[v[0]] = v[1]
    #self.unique_sorted = OrderedDict(reversed(list(self.unique_sorted.items())))
    ##for k,v in self.unique_sorted.items():
    ##  print("LOOK", k,v)
    #if n is None: return self.unique_sorted
    #else:
    #  rv = list(self.unique_sorted.values())[:n]
    #  return rv

  def func(self, cl, sites_cart, last):
    if not last: points = [sites_cart[cl.atoms_to_rotate[0]]]
    else:
      points = []
      for i in cl.atoms_to_rotate:
        if not i in self.rsr_eval_selection: continue
        points.append(sites_cart[i])
    angles = flex.double()
    values = flex.double()

    #print("using axis", list(cl.axis))

    if last and len(points)>1: end=180
    else:                      end=360
    for angle in range(0, end, 1):
      vals = flex.double()
      for point in points:
        new_point = rotate_point_around_axis(
          axis_point_1 = sites_cart[cl.axis[0]],
          axis_point_2 = sites_cart[cl.axis[1]],
          point        = point,
          angle        = angle, deg=True)
        value = self.map_data.eight_point_interpolation(
          self.unit_cell.fractionalize(new_point))
        vals.append(value)
      #print(angle, flex.mean(vals))
      angles.append(angle)
      values.append(flex.mean(vals))
    peaks = find_peak(angles=angles, values=values, threshold=self.threshold)
    #print(peaks)
    for peak in peaks:
      sites_cart_ = sites_cart.deep_copy()
      for atom in cl.atoms_to_rotate:
        new_xyz = rotate_point_around_axis(
          axis_point_1 = sites_cart_[cl.axis[0]],
          axis_point_2 = sites_cart_[cl.axis[1]],
          point        = sites_cart_[atom],
          angle        = peak, deg=True)
        sites_cart_[atom] = new_xyz
      self.sites_cart_conformers_all.append(sites_cart_)

class run(object):
  def __init__(self,
               residue,
               mon_lib_srv,
               rotamer_manager,
               sin_cos_table,
               cmv,
               unit_cell,
               rotatable_hd=None,
               vdw_radii=None,
               xyzrad_bumpers=None,
               target_map=None,
               target_map_for_cb=None,
               backbone_sample=False,
               accept_only_if_max_shift_is_smaller_than=None,
               trust_map_values_real=True,
               log=None):
    adopt_init_args(self, locals())
    if(self.log is None): self.log = sys.stdout
    self.co = mmtbx.refinement.real_space.aa_residue_axes_and_clusters(
      residue         = self.residue,
      mon_lib_srv     = self.mon_lib_srv,
      backbone_sample = True,
      log             = self.log)
    self.m = None
    if(self.target_map is not None and len(self.co.clusters)>0):
      # Set weights
      AN = {"S":16, "O":8, "N":7, "C":6, "SE":34, "H":1, "D":5}
      #AN = {"S":1, "O":1, "N":1, "C":1, "SE":1, "H":1}
      self.weights = flex.double()
      for atom in self.residue.atoms():
        self.weights.append(AN[atom.element.strip().upper()])
      # Bonded pairs
      exclude = ["C","N","O","CA"]
      reference = exclude + ["CB"]
      atoms = self.residue.atoms()
      self.pairs = []
      for i, ai in enumerate(atoms):
        if(ai.name.strip() in reference):
          mv = self.target_map.eight_point_interpolation(
            self.unit_cell.fractionalize(ai.xyz))
        if(ai.name.strip() in exclude): continue
        if(ai.element.strip().upper() in ["H","S","SE"]): continue
        for j, aj in enumerate(atoms):
          if i==j: continue
          if(aj.name.strip() in exclude): continue
          if(aj.element.strip().upper() in ["H","S","SE"]): continue
          d = ai.distance(aj)
          if d < 1.6:
            pair = [i,j]
            pair.sort()
            if(not pair in self.pairs):
              self.pairs.append(pair)
      # Set monitor
      id_str=""
      if(self.residue.parent() is not None and
         self.residue.parent().parent() is not None):
         id_str+="chain: %s"%(self.residue.parent().parent().id)
      id_str+=" residue: %s %s"%(self.residue.resname, self.residue.resseq.strip())
      if(len(self.co.clusters)>1):
        msel = flex.size_t(flatten(self.co.clusters[1:][0].vector))
      else:
        msel = flex.size_t()
      self.m = monitor(
        id_str    = id_str,
        selection = msel,
        map_data  = self.target_map,
        unit_cell = self.unit_cell,
        weights   = self.weights,
        pairs     = self.pairs,
        cmv       = self.cmv,
        rotamer_evaluator = self.rotamer_manager.rotamer_evaluator,
        log       = self.log)
      self.m.add(residue = self.residue, state = "start")
    if(self.target_map is None):
      assert not backbone_sample
    # Actual calculations
    if(self.residue.resname == "PRO"): # Special case
      self.fit_proline()
    else:
      self.chi_angles = self.rotamer_manager.get_chi_angles(
        resname = self.residue.resname)
      if(len(self.co.clusters)>0):
        if(backbone_sample):
          self.fit_c_beta(c_beta_rotation_cluster = self.co.clusters[0])
        self.fit_side_chain(clusters = self.co.clusters[1:])
    if(self.m is not None):
      self.m.finalize(residue = self.residue)
      # Too bulky, but very useful. Use for debugging only.
      #self.m.show()

  def get_target_value(self, sites_cart, selection=None, target_map=None):
    if(target_map is None): target_map = self.target_map
    if(selection is None):
      return maptbx.real_space_target_simple(
        unit_cell   = self.unit_cell,
        density_map = target_map,
        sites_cart  = sites_cart)
    else:
      return maptbx.real_space_target_simple(
        unit_cell   = self.unit_cell,
        density_map = target_map,
        sites_cart  = sites_cart,
        selection   = selection)

  def get_rotamer_iterator(self):
    return mmtbx.refinement.real_space.fit_residue.get_rotamer_iterator(
      mon_lib_srv = self.mon_lib_srv,
      residue     = self.residue)

  def fit_proline(self):
    """
    PRO is a special case. Just sample two possible rotamers.
    Skip if map isn't available: can't do much in this case!
    """
    if(self.target_map is None): return
    rotamer_iterator = self.get_rotamer_iterator()
    if rotamer_iterator is None:
      id_str="chain: %s"%(self.residue.parent().parent().id)
      id_str+=" residue: %s %s"%(
        self.residue.resname, self.residue.resseq.strip())
      print("Corrupt residue: %s >>> skipping"%id_str, file=self.log)
      return None
    scorer = mmtbx.refinement.real_space.score3(
      unit_cell    = self.unit_cell,
      target_map   = self.target_map,
      residue      = self.residue,
      rotamer_eval = self.rotamer_manager.rotamer_evaluator)
    scorer.reset(sites_cart = self.residue.atoms().extract_xyz())
    for rotamer, sites_cart in rotamer_iterator:
      scorer.update(sites_cart = sites_cart)
    self.residue.atoms().set_xyz(new_xyz=scorer.sites_cart)
    self.m.add(residue = self.residue, state = "fitting")

  def fit_side_chain(self, clusters):
    rotamer_iterator = self.get_rotamer_iterator()
    if(rotamer_iterator is None): return
    selection_clash = self.co.clash_eval_selection
    selection_rsr   = self.co.rsr_eval_selection
    if(self.target_map is not None):
      start_target_value = self.get_target_value(
        sites_cart = self.residue.atoms().extract_xyz(),
        selection  = selection_rsr)
    sites_cart_start = self.residue.atoms().extract_xyz()
    sites_cart_first_rotamer = list(rotamer_iterator)[0][1]
    # From this point on the coordinates in residue are to initial rotamer!
    self.residue.atoms().set_xyz(sites_cart_first_rotamer)
    axes = []
    atr = []
    for i, angle in enumerate(self.chi_angles[0]):
      cl = clusters[i]
      axes.append(flex.size_t(cl.axis))
      atr.append(flex.size_t(cl.atoms_to_rotate))
    #
    if(self.target_map is not None and self.xyzrad_bumpers is not None):
      # Get reference map values
      ref_map_vals = flex.double()
      for a in self.residue.atoms():
        key = "%s_%s_%s"%(
          a.parent().parent().parent().id, a.parent().resname,
          a.name.strip())
        ref_map_vals.append(self.cmv[key])
      # Get radii
      radii = mmtbx.refinement.real_space.get_radii(
        residue = self.residue, vdw_radii = self.vdw_radii)
      # Exclude rotatable H from clash calculation
      tmp = flex.size_t()
      for i in selection_clash:
        if(self.rotatable_hd[self.residue.atoms()[i].i_seq]): continue
        tmp.append(i)
      selection_clash = tmp[:]
      # Ad hoc: S or SE have larger peaks!
      if(self.residue.resname in ["MET","MSE"]): scale=100
      else:                                      scale=3
      if self.trust_map_values_real:
        scaleup=1
        scaledown=1
      else:
        scaleup=10000
        scaledown=0
      moving = ext.moving(
        sites_cart       = self.residue.atoms().extract_xyz(),
        sites_cart_start = sites_cart_start,
        radii            = radii,
        weights          = self.weights,
        bonded_pairs     = self.pairs,
        ref_map_max      = ref_map_vals * scale*scaleup,
        ref_map_min      = ref_map_vals / 10   *scaledown)
      #
      ro = ext.fit(
        fixed                    = self.xyzrad_bumpers,
        axes                     = axes,
        rotatable_points_indices = atr,
        angles_array             = self.chi_angles,
        density_map              = self.target_map,
        moving                   = moving,
        unit_cell                = self.unit_cell,
        selection_clash          = selection_clash,
        selection_rsr            = selection_rsr, # select atoms to compute map target
        sin_table                = self.sin_cos_table.sin_table,
        cos_table                = self.sin_cos_table.cos_table,
        step                     = self.sin_cos_table.step,
        n                        = self.sin_cos_table.n)
    elif(self.target_map is not None and self.xyzrad_bumpers is None):
      ro = ext.fit(
        target_value             = start_target_value,
        axes                     = axes,
        rotatable_points_indices = atr,
        angles_array             = self.chi_angles,
        density_map              = self.target_map,
        all_points               = self.residue.atoms().extract_xyz(),
        unit_cell                = self.unit_cell,
        selection                = selection_rsr,
        sin_table                = self.sin_cos_table.sin_table,
        cos_table                = self.sin_cos_table.cos_table,
        step                     = self.sin_cos_table.step,
        n                        = self.sin_cos_table.n)
    else:
      ro = ext.fit(
        sites_cart_start         = sites_cart_start.deep_copy(),
        axes                     = axes,
        rotatable_points_indices = atr,
        angles_array             = self.chi_angles,
        all_points               = self.residue.atoms().extract_xyz(),
        sin_table                = self.sin_cos_table.sin_table,
        cos_table                = self.sin_cos_table.cos_table,
        step                     = self.sin_cos_table.step,
        n                        = self.sin_cos_table.n)
    sites_cart_result = ro.result()
    if(sites_cart_result.size()>0):
      dist = None
      if(self.accept_only_if_max_shift_is_smaller_than is not None):
        dist = flex.max(flex.sqrt((sites_cart_start - sites_cart_result).dot()))
      if(dist is None):
        self.residue.atoms().set_xyz(sites_cart_result)
      else:
        if(dist is not None and
           dist < self.accept_only_if_max_shift_is_smaller_than):
          self.residue.atoms().set_xyz(sites_cart_result)
        else:
          self.residue.atoms().set_xyz(sites_cart_start)
    else:
      self.residue.atoms().set_xyz(sites_cart_start)
    if(self.m): self.m.add(residue = self.residue, state = "fitting")
#    # tune up
    if(self.target_map is not None):
      tune_up(
        target_map           = self.target_map,
        residue              = self.residue,
        mon_lib_srv          = self.mon_lib_srv,
        rotamer_manager      = self.rotamer_manager.rotamer_evaluator,
        unit_cell            = self.unit_cell,
        monitor = self.m,
        torsion_search_start = -30,
        torsion_search_stop  = 30,
        torsion_search_step  = 1)

  def fit_c_beta(self, c_beta_rotation_cluster):
    selection = flex.size_t(c_beta_rotation_cluster.selection)
    sites_cart = self.residue.atoms().extract_xyz()
    sites_cart_start = sites_cart.deep_copy() # XXX
    start_target_value = self.get_target_value(
      sites_cart = sites_cart,
      selection  = selection,
      target_map = self.target_map_for_cb)
    ro = ext.fit(
      target_value             = start_target_value+1.e-6,
      axes                     = [c_beta_rotation_cluster.axis],
      rotatable_points_indices = [c_beta_rotation_cluster.atoms_to_rotate],
      angles_array             = [[i*math.pi/180] for i in range(-20,21,1)],
      density_map              = self.target_map_for_cb,
      all_points               = sites_cart,
      unit_cell                = self.unit_cell,
      selection                = selection,
      sin_table                = self.sin_cos_table.sin_table,
      cos_table                = self.sin_cos_table.cos_table,
      step                     = self.sin_cos_table.step,
      n                        = self.sin_cos_table.n)
    sites_cart_result = ro.result()
    if(sites_cart_result.size()>0):
      self.residue.atoms().set_xyz(sites_cart_result)
    else:
      self.residue.atoms().set_xyz(sites_cart_start)

class run_with_minimization(object):
  def __init__(self,
               target_map,
               residue,
               vdw_radii,
               xray_structure,
               mon_lib_srv,
               rotamer_manager,
               # This is cctbx.geometry_restraints.manager.manager
               geometry_restraints_manager,
               real_space_gradients_delta,
               selection_radius = 5,
               rms_bonds_limit = 0.03, # XXX probably needs to be much lower
               rms_angles_limit = 3.0, # XXX
               backbone_sample_angle=None,
               cmv = None,
               allow_modified_residues=False):
    adopt_init_args(self, locals())
    # load rotamer manager
    self.rotamer_manager = mmtbx.idealized_aa_residues.rotamer_manager.load(
      rotamers="favored")
    # pre-compute sin and cos tables
    self.sin_cos_table = scitbx.math.sin_cos_table(n=10000)
    self.backbone_atom_names = ["N", "CA", "O", "CB", "C"]
    self.residue_iselection = self.residue.atoms().extract_i_seq()
    assert (not self.residue_iselection.all_eq(0))
    self.residue_selection = flex.bool(
      xray_structure.scatterers().size(), self.residue_iselection)
    self.residue_backbone_selection = flex.size_t()
    for atom in self.residue.atoms():
      if(atom.name.strip() in self.backbone_atom_names):
        self.residue_backbone_selection.append(atom.i_seq)
    self.residue_backbone_selection = flex.bool(
      xray_structure.scatterers().size(), self.residue_backbone_selection)
    self.target_map_work = target_map
    self.target_map_orig = target_map.deep_copy()
    self.fit_backbone()
    negate_selection = mmtbx.refinement.real_space.selection_around_to_negate(
      xray_structure          = self.xray_structure,
      selection_within_radius = self.selection_radius,
      iselection              = self.residue.atoms().extract_i_seq())
    self.target_map_work = mmtbx.refinement.real_space.\
      negate_map_around_selected_atoms_except_selected_atoms(
        xray_structure   = self.xray_structure,
        map_data         = target_map,
        negate_selection = negate_selection,
        atom_radius      = 1.5)
    self.fit_rotamers()

  def fit_backbone(self):
    # move in place (pure geometry regularizaition of residue in question)
    self.real_space_refine(optimize_weight=False, start_trial_weight_value=0)
    # fit n-c-o-ca-cb only (ignore side chain!). XXX BAD: amino-acid specific!
    self.grid_sample_around_c_n_axis()
    # fine-tune
    self.real_space_refine(optimize_weight=True, start_trial_weight_value=50)

  def fit_rotamers(self):
    sps = self.xray_structure.special_position_settings()
    mmtbx.refinement.real_space.fit_residue.run(
      vdw_radii         = self.vdw_radii,
      target_map        = self.target_map_work,
      target_map_for_cb = self.target_map_orig,
      mon_lib_srv       = self.mon_lib_srv,
      unit_cell         = self.xray_structure.unit_cell(),
      residue           = self.residue,
      sin_cos_table     = self.sin_cos_table,
      cmv               = self.cmv,
      rotamer_manager   = self.rotamer_manager)
    sites_cart_poor = self.xray_structure.sites_cart()
    sites_cart_poor.set_selected(self.residue_iselection,
      self.residue.atoms().extract_xyz())
    self.xray_structure= self.xray_structure.replace_sites_cart(sites_cart_poor)

  def grid_sample_around_c_n_axis(self):
    sps = self.xray_structure.special_position_settings()
    scorer = mmtbx.refinement.real_space.score(
      target_map = self.target_map_work,
      residue    = self.residue,
      unit_cell  = self.xray_structure.unit_cell())
    def get_cluster(self):
      axis=[]
      atoms_to_rotate=[]
      use_in_target_selection = flex.size_t()
      counter = 0
      for atom in self.residue.atoms():
        if(atom.name.strip() in ["N", "C"]):
          axis.append(counter)
        else:
          atoms_to_rotate.append(counter)
        if(atom.name.strip() in self.backbone_atom_names):
          use_in_target_selection.append(counter)
        counter += 1
      return mmtbx.refinement.real_space.cluster(
        axis            = axis,
        atoms_to_rotate = atoms_to_rotate,
        selection       = use_in_target_selection)
    cl = get_cluster(self)
    residue_sites_cart = self.residue.atoms().extract_xyz()
    scorer.reset(
      sites_cart = residue_sites_cart,
      selection  = cl.selection)
    angle_start = 0
    angle_end = 360
    if (self.backbone_sample_angle is not None):
      assert (self.backbone_sample_angle > 0)
      angle_start = - self.backbone_sample_angle
      angle_end = self.backbone_sample_angle
    mmtbx.refinement.real_space.torsion_search(
      clusters   = [cl],
      sites_cart = residue_sites_cart,
      scorer     = scorer,
      start      = 0,
      stop       = 360,
      step       = 1)
    self.residue.atoms().set_xyz(new_xyz=scorer.sites_cart)
    selection = self.residue.atoms().extract_i_seq()
    sites_cart_poor = self.xray_structure.sites_cart()
    sites_cart_poor.set_selected(selection, scorer.sites_cart)
    self.xray_structure= self.xray_structure.replace_sites_cart(sites_cart_poor)

  def real_space_refine(self, optimize_weight, start_trial_weight_value):
    brm = individual_sites.box_refinement_manager(
      xray_structure              = self.xray_structure,
      target_map                  = self.target_map_work,
      geometry_restraints_manager = self.geometry_restraints_manager,
      real_space_gradients_delta  = 1./4,
      max_iterations              = 500)
    brm.refine(
      selection                = self.residue_selection,
      optimize_weight          = optimize_weight,
      start_trial_weight_value = start_trial_weight_value,
      selection_buffer_radius  = self.selection_radius,
      box_cushion              = 2,
      rms_bonds_limit          = self.rms_bonds_limit,
      rms_angles_limit         = self.rms_angles_limit)
    self.xray_structure = brm.xray_structure
    self.residue.atoms().set_xyz(brm.sites_cart.select(self.residue_iselection))

def get_rotamer_iterator(mon_lib_srv, residue):
  rotamer_iterator = mon_lib_srv.rotamer_iterator(
    fine_sampling = True,
    comp_id=residue.resname,
    atom_names=residue.atoms().extract_name(),
    sites_cart=residue.atoms().extract_xyz())
  if (rotamer_iterator is None):
    return None
  if (rotamer_iterator.problem_message is not None):
    return None
  if (rotamer_iterator.rotamer_info is None):
    return None
  return rotamer_iterator

class tune_up(object):
  def __init__(self,
               target_map,
               residue,
               mon_lib_srv,
               rotamer_manager,
               unit_cell,
               exclude_hd           = True,
               monitor              = None,
               torsion_search_start = -20,
               torsion_search_stop  = 20,
               torsion_search_step  = 2):
    adopt_init_args(self, locals())
    self.clusters = mmtbx.refinement.real_space.aa_residue_axes_and_clusters(
      residue         = self.residue,
      mon_lib_srv     = self.mon_lib_srv,
      backbone_sample = False).clusters
    self.score_residue = mmtbx.refinement.real_space.score3(
      unit_cell    = self.unit_cell,
      target_map   = self.target_map,
      residue      = self.residue,
      rotamer_eval = self.rotamer_manager,
      exclude_hd   = self.exclude_hd)
    mmtbx.refinement.real_space.torsion_search(
      clusters   = self.clusters,
      sites_cart = self.residue.atoms().extract_xyz(),
      scorer     = self.score_residue,
      start      = self.torsion_search_start,
      stop       = self.torsion_search_stop,
      step       = self.torsion_search_step)
    self.residue.atoms().set_xyz(new_xyz=self.score_residue.sites_cart)
    if(monitor is not None):
      monitor.add(residue = self.residue, state = "tuneup")

#
# These functions are not used anywhere. And not tested anymore.
# They are here as an example of correct backrub move, according to
# original paper https://doi.org/10.1016/j.str.2005.10.007
# Unfortunately, for proper backrub move we need previous and next residues,
# but current code is build under assumption that one residue is enough for
# rotamer fitting. One will have to reconsider this idea and do some changes
# to make it possible to do proper backrub move.
#
def _find_theta(ap1, ap2, cur_xyz, needed_xyz):
  from mmtbx.building.loop_closure.ccd import ccd_python
  f, s_home, r_norm, r_home = ccd_python._get_f_r_s(
      axis_point_1=ap1,
      axis_point_2=ap2,
      moving_coor=cur_xyz,
      fixed_coor=needed_xyz)
  b = list(2*r_norm*(f.dot(r_home)))[0]
  c = list(2*r_norm*(f.dot(s_home)))[0]
  znam = math.sqrt(b*b+c*c)
  sin_alpha = c/znam
  cos_alpha = b/znam
  alpha = math.atan2(sin_alpha, cos_alpha)
  return math.degrees(alpha)

def backrub_move(
    prev_res,
    cur_res,
    next_res,
    angle,
    move_oxygens=False,
    accept_worse_rama=False,
    rotamer_manager=None,
    rama_manager=None):
  import boost_adaptbx.boost.python as bp
  ext = bp.import_ext("mmtbx_validation_ramachandran_ext")
  from mmtbx_validation_ramachandran_ext import rama_eval
  from scitbx.matrix import rotate_point_around_axis
  from mmtbx.conformation_dependent_library.multi_residue_class import ThreeProteinResidues, \
      RestraintsRegistry

  if abs(angle) < 1e-4:
    return
  if prev_res is None or next_res is None:
    return
  saved_res = [{},{},{}]
  for i, r in enumerate([prev_res, cur_res, next_res]):
    for a in r.atoms():
      saved_res[i][a.name.strip()] = a.xyz
  if rotamer_manager is None:
    rotamer_manager = RotamerEval()
  prev_ca = prev_res.find_atom_by(name=" CA ")
  cur_ca = cur_res.find_atom_by(name=" CA ")
  next_ca = next_res.find_atom_by(name=" CA ")
  if prev_ca is None or next_ca is None or cur_ca is None:
    return
  atoms_to_move = []
  atoms_to_move.append(prev_res.find_atom_by(name=" C  "))
  atoms_to_move.append(prev_res.find_atom_by(name=" O  "))
  for atom in cur_res.atoms():
    atoms_to_move.append(atom)
  atoms_to_move.append(next_res.find_atom_by(name=" N  "))
  for atom in atoms_to_move:
    assert atom is not None
    new_xyz = rotate_point_around_axis(
        axis_point_1 = prev_ca.xyz,
        axis_point_2 = next_ca.xyz,
        point        = atom.xyz,
        angle        = angle,
        deg          = True)
    atom.xyz = new_xyz
  if move_oxygens:
    registry = RestraintsRegistry()
    if rama_manager is None:
      rama_manager = rama_eval()
    tpr = ThreeProteinResidues(geometry=None, registry=registry)
    tpr.append(prev_res)
    tpr.append(cur_res)
    tpr.append(next_res)
    phi_psi_angles = tpr.get_phi_psi_angles()
    rama_key = tpr.get_ramalyze_key()
    ev_before = rama_manager.evaluate_angles(rama_key, phi_psi_angles[0], phi_psi_angles[1])
    theta1 = _find_theta(
        ap1 = prev_ca.xyz,
        ap2 = cur_ca.xyz,
        cur_xyz = prev_res.find_atom_by(name=" O  ").xyz,
        needed_xyz = saved_res[0]["O"])
    theta2 = _find_theta(
        ap1 = cur_ca.xyz,
        ap2 = next_ca.xyz,
        cur_xyz = cur_res.find_atom_by(name=" O  ").xyz,
        needed_xyz = saved_res[1]["O"])
    for a in [prev_res.find_atom_by(name=" C  "),
        prev_res.find_atom_by(name=" O  "),
        cur_res.find_atom_by(name=" C  ")]:
      new_xyz = rotate_point_around_axis(
              axis_point_1 = prev_ca.xyz,
              axis_point_2 = cur_ca.xyz,
              point        = a.xyz,
              angle        = theta1,
              deg          = True)
      a.xyz = new_xyz
    for a in [cur_res.find_atom_by(name=" C  "),
        cur_res.find_atom_by(name=" O  "),
        next_res.find_atom_by(name=" N  ")]:
      new_xyz = rotate_point_around_axis(
              axis_point_1 = cur_ca.xyz,
              axis_point_2 = next_ca.xyz,
              point        = a.xyz,
              angle        = theta2,
              deg          = True)
      a.xyz = new_xyz
    phi_psi_angles = tpr.get_phi_psi_angles()
    rama_key = tpr.get_ramalyze_key()
    ev_after = rama_manager.evaluate_angles(rama_key, phi_psi_angles[0], phi_psi_angles[1])
    if ev_before > ev_after and not accept_worse_rama:
      for a in [prev_res.find_atom_by(name=" C  "),
          prev_res.find_atom_by(name=" O  "),
          cur_res.find_atom_by(name=" C  ")]:
        new_xyz = rotate_point_around_axis(
                axis_point_1 = prev_ca.xyz,
                axis_point_2 = cur_ca.xyz,
                point        = a.xyz,
                angle        = -theta1,
                deg          = True)
        a.xyz = new_xyz
      for a in [cur_res.find_atom_by(name=" C  "),
          cur_res.find_atom_by(name=" O  "),
          next_res.find_atom_by(name=" N  ")]:
        new_xyz = rotate_point_around_axis(
                axis_point_1 = cur_ca.xyz,
                axis_point_2 = next_ca.xyz,
                point        = a.xyz,
                angle        = -theta2,
                deg          = True)
        a.xyz = new_xyz


 *******************************************************************************


 *******************************************************************************
mmtbx/refinement/real_space/fit_residues.py
from __future__ import absolute_import, division, print_function
from cctbx.array_family import flex
from libtbx import adopt_init_args
import iotbx.pdb
import mmtbx.refinement.real_space
import mmtbx.refinement.real_space.fit_residue
import sys, time
from cctbx import crystal, maptbx
from mmtbx.maps import correlation
import boost_adaptbx.boost.python as bp
cctbx_maptbx_ext = bp.import_ext("cctbx_maptbx_ext")
fit_ext = bp.import_ext("mmtbx_rotamer_fit_ext")

import scitbx.math
from mmtbx.rotamer.rotamer_eval import RotamerEval
rotamer_manager = RotamerEval()

# XXX Keep for debugging
def write_map_file(crystal_symmetry, map_data, file_name):
  from iotbx import mrcfile
  mrcfile.write_ccp4_map(
    file_name   = file_name,
    unit_cell   = crystal_symmetry.unit_cell(),
    space_group = crystal_symmetry.space_group(),
    map_data    = map_data,
    labels      = flex.std_string([""]))

negate_map_table = {
  #"ala": False,
  "asn": 5,
  "asp": 5,
  "cys": 5,
  "gln": 6,
  "glu": 6,
  #"gly": False,
  "his": 6,
  "ile": 5,
  "leu": 5,
  "met": 6,
  "mse": 6,
  "phe": 6.5,
  #"pro": 5,#False,
  "ser": 5,
  "thr": 5,
  "trp": 7.4,
  "tyr": 7.7,
  "val": 5,
  "arg": 10,
  "lys": 8,
  "pro": 3
}

def get_map(fmodel, crystal_gridding, map_type):
  coeffs = fmodel.electron_density_map().map_coefficients(
    map_type     = map_type,
    fill_missing = False,
    isotropize   = False)
  fft_map = coeffs.fft_map(crystal_gridding = crystal_gridding)
  fft_map.apply_sigma_scaling()
  result = fft_map.real_map_unpadded()
  return result

def fit_altlocs_with_masking(model, fmodel, sin_cos_table=None,
                             rotamer_manager=None):
  log = model.log
  if rotamer_manager is None:
    rotamer_manager = mmtbx.idealized_aa_residues.rotamer_manager.load(
      residues = None, rotamers = "favored_allowed")
  if sin_cos_table is None:
    sin_cos_table = scitbx.math.sin_cos_table(n=10000)
  #
  crystal_symmetry = fmodel.xray_structure.crystal_symmetry()
  cg = maptbx.crystal_gridding(
    unit_cell        = crystal_symmetry.unit_cell(),
    space_group_info = crystal_symmetry.space_group_info(),
    symmetry_flags   = maptbx.use_space_group_symmetry,
    step             = 0.3)
  #
  map_data = get_map(fmodel=fmodel, crystal_gridding=cg, map_type='2mFo-DFc')
  #
  protein_selection = model.selection("protein")
  sites_cart = model.get_sites_cart()
  sites_cart_start = sites_cart.deep_copy()
  cis = model.get_hierarchy().get_conformer_indices()
  indices = cis.conformer_indices
  vals = list(set(cis.index_altloc_mapping.values()))
  for k,v in zip(cis.index_altloc_mapping.keys(), vals):
    if v == 0: continue
    sel  = indices == 0
    sel |= indices == v
    sel = sel & protein_selection
    model_conf = model.select(sel)
    # Compute mask for other conformers
    model_other = model.select(~sel)
    ss = "not (name CA or name O or name N or name C)"
    sssel = model_other.selection(string=ss)
    model_other = model_other.select(sssel)
    model_other = model_other.remove_hydrogens()
    mask_p1 = mmtbx.masks.mask_from_xray_structure(
      xray_structure           = model_other.get_xray_structure(),
      p1                       = True,
      for_structure_factors    = True,
      solvent_radius           = 0,
      shrink_truncation_radius = 0,
      atom_radius              = 0.5,
      n_real                   = map_data.accessor().all(),
      in_asu                   = False).mask_data
    maptbx.unpad_in_place(map=mask_p1)
    #
    map_data_masked = map_data * mask_p1
    #
    # FOR DEBUGGING
    #
    #with open("%s%d.pdb"%(k,v),"w") as fo:
    #  fo.write(model_conf.model_as_pdb())
    #write_map_file(crystal_symmetry = model.crystal_symmetry(),
    #               map_data         = map_data_masked,
    #               file_name        = "%s%d.map"%(k,v))
    #
    result = mmtbx.refinement.real_space.fit_residues.run(
      pdb_hierarchy     = model_conf.get_hierarchy(),
      vdw_radii         = model_conf.get_vdw_radii(),
      crystal_symmetry  = model_conf.crystal_symmetry(),
      map_data          = map_data_masked,
      backbone_sample   = False,
      rotatable_hd      = model_conf.rotatable_hd_selection(iselection=False),
      rotamer_manager   = rotamer_manager,
      sin_cos_table     = sin_cos_table,
      mon_lib_srv       = model_conf.get_mon_lib_srv(),
      fit_altlocs_method= "masking",
      log               = log)
    #
    sites_cart = sites_cart.set_selected(
      sel, result.pdb_hierarchy.atoms().extract_xyz())
    model_conf.set_sites_cart(result.pdb_hierarchy.atoms().extract_xyz())
    #
    # FOR DEBUGGING
    #
    #with open("%s%d_fitted.pdb"%(k,v),"w") as fo:
    #  fo.write(model_conf.model_as_pdb())
    #
    model.set_sites_cart(sites_cart)
    fmodel.xray_structure.set_sites_cart(model.get_sites_cart())
    fmodel.update_xray_structure(update_f_calc=True)
    #
    map_data = get_map(fmodel=fmodel, crystal_gridding=cg, map_type='2mFo-DFc')
  #
  # FOR DEBUGGING
  #
  #with open("fitted1.pdb","w") as fo:
  #  fo.write(model.model_as_pdb())
  #print("pre-FINAL:", fmodel.r_work())
  #
  sites_cart = model.get_sites_cart()
  uc = model.crystal_symmetry().unit_cell()
  for m in model.get_hierarchy().models():
    for chain in m.chains():
      for residue_group in chain.residue_groups():
        conformers = residue_group.conformers()
        rs = []
        for conformer in residue_group.conformers():
          residue = conformer.only_residue()
          sel = residue.atoms().extract_i_seq()

          if len(residue_group.conformers()) > 1:
            t1 = maptbx.real_space_target_simple(
              unit_cell   = uc,
              density_map = map_data,
              sites_cart  = residue.atoms().extract_xyz())
            mmtbx.refinement.real_space.fit_residue.tune_up(
               target_map           = map_data,
               residue              = residue,
               mon_lib_srv          = model.get_mon_lib_srv(),
               rotamer_manager      = rotamer_manager.rotamer_evaluator,
               unit_cell            = uc,
               monitor              = None,
               torsion_search_start = -20,
               torsion_search_stop  = 20,
               torsion_search_step  = 1)
            t2 = maptbx.real_space_target_simple(
              unit_cell   = uc,
              density_map = map_data,
              sites_cart  = residue.atoms().extract_xyz())
            if t2>t1:
              sites_cart = sites_cart.set_selected(sel, residue.atoms().extract_xyz())
            #print("             tuneup:", t1, t2)

          ts = maptbx.real_space_target_simple(
            unit_cell   = uc,
            density_map = map_data,
            sites_cart  = sites_cart_start.select(sel))
          te = maptbx.real_space_target_simple(
            unit_cell   = uc,
            density_map = map_data,
            sites_cart  = sites_cart.select(sel))
          f = ""
          if te > ts: f = "<<< better"
          r = (ts-te)/(ts+te)*100*2
          label = "%2s %5s %s%4s"%(
            chain.id, residue.resseq, conformer.altloc, residue.resname)
          #print(label, "%6.2f %6.2f %6.2f"%(ts, te, r), f)
          rs.append(r)
        #
        if len(rs)>0:
          got_better = 0
          got_worse  = 0
          for r in rs:
            if r<-1 or r<-1 : got_better+=1
            if r> 1 or r> 1 : got_worse +=1
          if got_better>0 and got_worse==0:
            #print(" "*30, "<<< fit accepted")
            for conformer in residue_group.conformers():
              sel = conformer.atoms().extract_i_seq()
              sel = flex.bool(model.size(), sel)
              sites_cart_start = sites_cart_start.set_selected(sel, sites_cart)
  #
  model.set_sites_cart(sites_cart_start)
  fmodel.xray_structure.set_sites_cart(model.get_sites_cart())
  fmodel.update_xray_structure(update_f_calc=True)
  #print("FINAL:", fmodel.r_work())
  #
  # FOR DEBUGGING
  #
  #with open("fitted2.pdb","w") as fo:
  #  fo.write(model.model_as_pdb())

class run(object):
  def __init__(self,
               pdb_hierarchy,
               crystal_symmetry,
               rotamer_manager,
               sin_cos_table,
               mon_lib_srv,
               filter_by_cc = False,
               d_min = None,
               map_data_scale = 2.5,
               diff_map_data_threshold = -2.5,
               exclude_selection=None,
               rotatable_hd=None,
               bselection=None,
               map_data=None,
               vdw_radii=None,
               backbone_sample=False, # XXX
               diff_map_data=None,
               fit_altlocs_method=None,
               log = None):
    adopt_init_args(self, locals())
    assert fit_altlocs_method in [None, 'sampling', 'masking']
    # Final filtering by CC_mask requires the map and resolution
    if self.filter_by_cc:
      assert self.d_min is not None
      assert self.map_data is not None
    #
    self.pdb_hierarchy_start = self.pdb_hierarchy.deep_copy()
    self.processed = 0
    self.total_time_residue_loop = 0
    t0 = time.time()
    self.atoms = self.pdb_hierarchy.atoms()
    self.cmv = None
    if(self.map_data is not None):
      self.cmv = mmtbx.refinement.real_space.common_map_values(
        pdb_hierarchy = self.pdb_hierarchy,
        unit_cell     = self.crystal_symmetry.unit_cell(),
        map_data      = self.map_data)
    self.mes = []
    if(self.bselection is None):
      o = mmtbx.refinement.real_space.side_chain_fit_evaluator(
        pdb_hierarchy           = self.pdb_hierarchy,
        crystal_symmetry        = self.crystal_symmetry,
        rotamer_evaluator       = self.rotamer_manager.rotamer_evaluator,
        map_data                = self.map_data,
        diff_map_data           = self.diff_map_data,
        map_data_scale          = self.map_data_scale,
        exclude_selection       = self.exclude_selection,
        diff_map_data_threshold = self.diff_map_data_threshold)
      self.mes.extend(o.mes)
      self.bselection = o.sel_all() # or all_possible() ?
    if(self.log is None): self.log = sys.stdout
    self.special_position_settings = crystal.special_position_settings(
      crystal_symmetry = self.crystal_symmetry)
    # Even better would be to pass it here. Ideally just use model
    asc = self.pdb_hierarchy.atom_selection_cache()
    self.selection_water_as_set = \
      set(asc.selection(string = "water").iselection())
    self.target_map = map_data
    self.mes.append("outliers start: %d"%self.count_outliers())
    #
    self.loop(function = self.one_residue_iteration)
    #
    self.mes.append("outliers final: %d"%self.count_outliers())
    #
    self.mes.append("residues processed: %d"%self.processed)
    if(self.processed > 0):
      self.mes.append("average time/residue: %6.4f"%(
        self.total_time_residue_loop/self.processed))
    self.mes.append("time to fit residues: %6.4f"%(time.time()-t0))
    # Final chack by CCmask per residue
    if self.filter_by_cc:
      self._filter_by_cc()

  def _filter_by_cc(self):
    def __get_map_from_hierarchy(ph):
      xrs = ph.extract_xray_structure(
        crystal_symmetry = self.crystal_symmetry)
      hd_sel = xrs.hd_selection()
      xrs = xrs.select(~hd_sel)
      fc = xrs.structure_factors(d_min=self.d_min).f_calc()
      crystal_gridding = maptbx.crystal_gridding(
        unit_cell             = xrs.unit_cell(),
        space_group_info      = xrs.space_group_info(),
        pre_determined_n_real = self.map_data.accessor().all(),
        symmetry_flags        = maptbx.use_space_group_symmetry)
      fft_map = fc.fft_map(crystal_gridding = crystal_gridding)
      return fft_map.real_map_unpadded()
    # XXX This may be a memory bottleneck (3 maps in memory!)
    map_calc_start = __get_map_from_hierarchy(ph=self.pdb_hierarchy_start)
    map_calc_final = __get_map_from_hierarchy(ph=self.pdb_hierarchy)
    #
    for m1,m2 in zip(self.pdb_hierarchy_start.models(),
                     self.pdb_hierarchy.models()):
      for c1,c2 in zip(m1.chains(), m2.chains()):
        for rg1, rg2 in zip(c1.residue_groups(), c2.residue_groups()):
          confs1 = rg1.conformers()
          confs2 = rg2.conformers()
          if(len(confs1)>1): continue
          for con1, con2 in zip(confs1, confs2):
            res1 = con1.only_residue()
            res2 = con2.only_residue()
            if(not self.bselection[res1.atoms()[0].i_seq]): continue
            atoms1, atoms2 = res1.atoms(), res2.atoms()
            dist = flex.sqrt((atoms1.extract_xyz() -
                              atoms2.extract_xyz()).dot())
            moved = False
            if(flex.max(dist) > 0.5): moved = True
            if(moved):
              sites_cart_start = flex.vec3_double()
              sites_cart_final = flex.vec3_double()
              for a1, a2 in zip(atoms1, atoms2):
                if a1.element_is_hydrogen(): continue
                sites_cart_start.append(a1.xyz)
                sites_cart_final.append(a2.xyz)
              cc_start = correlation.from_map_map_atoms(
                map_1      = map_calc_start,
                map_2      = self.map_data,
                sites_cart = sites_cart_start,
                unit_cell  = self.crystal_symmetry.unit_cell(),
                radius     = 2)
              cc_final = correlation.from_map_map_atoms(
                map_1      = map_calc_final,
                map_2      = self.map_data,
                sites_cart = sites_cart_start,
                unit_cell  = self.crystal_symmetry.unit_cell(),
                radius     = 2)
              if(cc_final < cc_start and abs(cc_final-cc_start)>0.02):
                re = self.rotamer_manager.rotamer_evaluator
                re_start = re.evaluate_residue(res1)
                re_final = re.evaluate_residue(res2)
                k = "REVERT: %s %s %s cc_start: %6.4f (%s) cc_final: %6.4f (%s)"%(
                  c1.id, str(res1.resseq), res1.resname, cc_start, re_start,
                  cc_final, re_final)
                print(k, file=self.log)
                rg2.atoms().set_xyz(rg1.atoms().extract_xyz())

  def show(self, prefix=""):
    for m in self.mes:
      print("%s%s"%(prefix,m), file=self.log)
    self.log.flush()

  def _selection_around_minus_self(self, residue, radius):
    if(self.special_position_settings is None): return None
    if(self.vdw_radii is None): return None
    residue_i_selection = flex.size_t()
    for a in residue.atoms():
      if(not a.name.strip() in ["N", "C", "O"]):
        residue_i_selection.append(a.i_seq)
    sites_cart = self.atoms.extract_xyz()
    #
    residue_b_selection = flex.bool(sites_cart.size(), residue_i_selection)
    selection_around_residue = self.special_position_settings.pair_generator(
      sites_cart      = sites_cart,
      distance_cutoff = radius
        ).neighbors_of(primary_selection = residue_b_selection).iselection()

    residue_i_selection = residue.atoms().extract_i_seq()

    selection_around_residue_minus_residue = flex.size_t(
      list(set(selection_around_residue).difference(
        set(residue_i_selection)).difference(self.selection_water_as_set)))
    # exclude rotatable H
    selection_around_residue_minus_residue_minus_rotatableH = flex.size_t()
    for s in selection_around_residue_minus_residue:
      if(not self.rotatable_hd[s]):
        selection_around_residue_minus_residue_minus_rotatableH.append(s)
    return selection_around_residue_minus_residue_minus_rotatableH

  def get_nonbonded_bumpers(self, residue, radius):
    #
    # Symmetry-related atoms are treated differently and less comprihensively
    # See fit_residue.py in "def loop(..)"
    #
    if(self.special_position_settings is None): return None
    if(self.vdw_radii is None): return None
    selection_around_residue_minus_residue_minus_rotatableH = \
      self._selection_around_minus_self(residue=residue, radius=radius)
    #
    radii = flex.double()
    sites_cart = flex.vec3_double()
    for i in selection_around_residue_minus_residue_minus_rotatableH:
      atom = self.atoms[i]
      an = atom.name.strip()
      rad = mmtbx.refinement.real_space.get_radius(
        atom = atom, vdw_radii = self.vdw_radii)
      good = True
      if(self.diff_map_data is not None):
        sf = self.crystal_symmetry.unit_cell().fractionalize(atom.xyz)
        mv = self.diff_map_data.eight_point_interpolation(sf)
        if(mv<-2.): good = False
      if(residue.resname=="CYS" and atom.parent().resname=="CYS" and an=="SG"):
        continue
      if(self.map_data is not None):
        key = "%s_%s_%s"%(
          atom.parent().parent().parent().id, atom.parent().resname, an)
        sf = self.crystal_symmetry.unit_cell().fractionalize(atom.xyz)
        mv = self.map_data.eight_point_interpolation(sf)
        if(mv < self.cmv[key]/3): good = False
      if(good):
        radii.append(rad)
        sites_cart.append(atom.xyz)
    return fit_ext.fixed(sites_cart = sites_cart, radii = radii)

  def one_residue_iteration(self, residue):
    t0 = time.time()
    negate_rad = negate_map_table[residue.resname.strip().lower()]
    if(not negate_rad): return
    xyzrad_bumpers = self.get_nonbonded_bumpers(
      residue=residue, radius=negate_rad)
    self.processed +=1
    if self.fit_altlocs_method=="masking":
      trust_map_values_real=False
    else:
      trust_map_values_real=True
    mmtbx.refinement.real_space.fit_residue.run(
      residue           = residue,
      vdw_radii         = self.vdw_radii,
      xyzrad_bumpers    = xyzrad_bumpers,
      backbone_sample   = self.backbone_sample,
      unit_cell         = self.crystal_symmetry.unit_cell(),
      target_map        = self.target_map,
      target_map_for_cb = self.target_map,
      mon_lib_srv       = self.mon_lib_srv,
      rotamer_manager   = self.rotamer_manager,
      rotatable_hd      = self.rotatable_hd,
      sin_cos_table     = self.sin_cos_table,
      cmv               = self.cmv,
      trust_map_values_real = trust_map_values_real,
      log               = self.log)
    self.total_time_residue_loop += (time.time()-t0)

  def loop(self, function):
    get_class = iotbx.pdb.common_residue_names_get_class
    for model in self.pdb_hierarchy.models():
      for chain in model.chains():
        for residue_group in chain.residue_groups():
          conformers = residue_group.conformers()
          # DEAL WITH ALTLOCS
          if(len(conformers)>1 and self.fit_altlocs_method=='sampling'):
            n = len(conformers)
            overall = {}
            for conformer in conformers:
              residue = conformer.only_residue()

              #if int(residue.resseq) != 30: continue

              #
              rn = residue.resname.strip().lower()
              if rn in ["ala", "pro", "gly"]: continue
              negate_rad = negate_map_table[residue.resname.strip().lower()]
              xrs = self.pdb_hierarchy.extract_xray_structure(
                crystal_symmetry = self.crystal_symmetry)
              negate_selection = mmtbx.refinement.real_space.selection_around_to_negate(
                xray_structure          = xrs,
                selection_within_radius = negate_rad,
                iselection              = residue_group.atoms().extract_i_seq())

              target_map_work = mmtbx.refinement.real_space.\
                negate_map_around_selected_atoms_except_selected_atoms(
                  xray_structure   = xrs,
                  map_data         = self.target_map.deep_copy(),
                  negate_selection = negate_selection,
                  atom_radius      = 1.5)

              if(get_class(residue.resname) != "common_amino_acid"): continue
              sel = residue.atoms().extract_i_seq()
              residue_dc = residue.standalone_copy()
              residue_dc.atoms().reset_i_seq()
              o = mmtbx.refinement.real_space.fit_residue.find_all_conformers(
                residue     = residue_dc,
                map_data    = target_map_work, #self.target_map,
                mon_lib_srv = self.mon_lib_srv,
                unit_cell   = self.crystal_symmetry.unit_cell(),
                threshold   = 1.0,
                rotamer_evaluator = rotamer_manager)
              for k,v in o.unique.items():
                overall.setdefault(k, []).append(v)
              #sites_cart_conformers = o.sorted_by_map_value(n=n)
              #if sites_cart_conformers is not None:
              ##  for sites_cart, conformer in zip(sites_cart_conformers, conformers):
              ##    residue = conformer.only_residue()
              ##    residue.atoms().set_xyz( sites_cart )
              #  residue.atoms().set_xyz( sites_cart_conformers[0] )
            unique = {}
            for k,v in overall.items():
              vbest  = -1.e9
              ssbest = None
              for it in v:
                vv, ss = it
                if vv > vbest:
                  vbest = vv
                  ssbest = ss
              unique[k] = [vbest, ssbest]
            if unique != {}:
              print("OVERALL unique")
              code=flex.std_string()
              vals=flex.double()
              for k, v in unique.items():
                print("   ", k, v)
                code.append(k)
                vals.append(v[0])
              sel = flex.sort_permutation(vals, reverse=True)
              print(list(vals.select(sel)))



          # SINGLE CONFORMATION
          else:
            for conformer in residue_group.conformers():
              residue = conformer.only_residue()
              if(not self.bselection[residue.atoms()[0].i_seq]): continue
              xyz_start = residue.atoms().extract_xyz()
              function(residue = residue)
              # Check for symmetry clash
              sels = self._selection_around_minus_self(residue=residue, radius=1.5)
              if(sels is not None and sels.size()>0):
                print("   revert: symmetry clash", file=self.log)
                residue.atoms().set_xyz(xyz_start)
                # XXX
                # XXX For debugging
                # XXX
                #atoms=self.pdb_hierarchy.atoms()
                #for s in sels:
                #  atom = atoms[s]
                #  key = "%s_%s_%s"%(
                #    atom.parent().parent().parent().id, atom.parent().resname, atom.name)
                #  print(key, residue.resname, "LOOK-"*10)

  def count_outliers(self):
    o = mmtbx.refinement.real_space.side_chain_fit_evaluator(
      pdb_hierarchy     = self.pdb_hierarchy,
      crystal_symmetry  = self.crystal_symmetry,
      rotamer_evaluator = self.rotamer_manager.rotamer_evaluator)
    return o.cntr_outliers

# XXX
# XXX Looks obsolete. Not used anywhere.
# XXX
# XXX Where is this used? Looks like severe duplication!
#class fix_outliers(object):
#  def __init__(self,
#               pdb_hierarchy,
#               rotamer_manager,
#               sin_cos_table,
#               mon_lib_srv,
#               f_map=None,
#               fdiff_map=None,
#               unit_cell=None,
#               accept_only_if_max_shift_is_smaller_than=None,
#               log = None):
#    adopt_init_args(self, locals())
#    assert [f_map, fdiff_map, unit_cell].count(None) in [0,3]
#    ac = accept_only_if_max_shift_is_smaller_than
#    if(self.log is None): self.log = sys.stdout
#    get_class = iotbx.pdb.common_residue_names_get_class
#    for model in self.pdb_hierarchy.models():
#      for chain in model.chains():
#        for residue_group in chain.residue_groups():
#          conformers = residue_group.conformers()
#          if(len(conformers)>1): continue
#          for conformer in residue_group.conformers():
#            residue = conformer.only_residue()
#            id_str="%s%s%s"%(chain.id,residue.resname,residue.resseq.strip())
#            if(get_class(residue.resname) == "common_amino_acid"):
#              # Idealize rotamer: move to nearest rotameric state
#              re = self.rotamer_manager.rotamer_evaluator
#              if(re.evaluate_residue(residue)=="OUTLIER"):
#                go=True
#                if([f_map, fdiff_map, unit_cell].count(None)==0):
#                  go = mmtbx.refinement.real_space.need_sidechain_fit(
#                    residue           = residue,
#                    rotamer_evaluator = self.rotamer_manager.rotamer_evaluator,
#                    mon_lib_srv       = self.mon_lib_srv,
#                    unit_cell         = self.unit_cell,
#                    f_map             = f_map,
#                    fdiff_map         = fdiff_map)
#                if(go):
#                  mmtbx.refinement.real_space.fit_residue.run(
#                    residue         = residue,
#                    backbone_sample = False,
#                    mon_lib_srv     = self.mon_lib_srv,
#                    rotamer_manager = self.rotamer_manager,
#                    sin_cos_table   = self.sin_cos_table,
#                    accept_only_if_max_shift_is_smaller_than = ac,
#                    log = self.log)


 *******************************************************************************


 *******************************************************************************
mmtbx/refinement/real_space/fit_small_molecule.py
from __future__ import absolute_import, division, print_function
from scitbx.array_family import flex
from mmtbx.refinement.real_space import individual_sites
from libtbx.test_utils import approx_equal
from cctbx import maptbx
from libtbx import adopt_init_args
import scitbx.rigid_body
import sys
from six.moves import range

def apply_rigid_body_shift(sites_cart, cm, x,y,z, the, psi, phi):
  rot_matrix = scitbx.rigid_body.rb_mat_zyz(
    the=the, psi=psi, phi=phi).rot_mat().as_mat3()
  transl = (x,y,z)
  return rot_matrix * (sites_cart-cm) + transl + cm

class scorer(object):
  def __init__(self, unit_cell, sites_frac, target_map, log=None):
    adopt_init_args(self, locals())
    self.target = maptbx.map_sum_at_sites_frac(
      map_data   = target_map,
      sites_frac = sites_frac)
    self.sites_frac_best = None
    if(log):
      print("Target (start):", self.target, file=log)

  def update(self, sites_cart):
    sites_frac = self.unit_cell.fractionalize(sites_cart)
    t = maptbx.map_sum_at_sites_frac(
      map_data   = self.target_map,
      sites_frac = sites_frac)
    if(t>self.target):
      self.target = t
      self.sites_frac_best = sites_frac.deep_copy()
      if(self.log):
        print("Target:", self.target, file=self.log)

def prepare_maps(fofc, two_fofc, fem, fofc_cutoff=2, two_fofc_cutoff=0.5,
                 fem_cutoff=0.5, connectivity_cutoff=0.5, local_average=True):
  """
  - This takes 3 maps: mFo-DFc, 2mFo-DFc and FEM and combines them into one map
    that is most suitable for real-space refinement.
  - Maps are the boxes extracted around region of interest from the whole unit
    cell map.
  - All maps are expected to be normalized by standard deviation (sigma-scaled)
    BEFORE extracting the box. There is no way to assert it at this point.
  - Map gridding equivalence is asserted.
  """
  m1,m2,m3 = fofc, two_fofc, fem
  # assert identical gridding
  for m_ in [m1,m2,m3]:
    for m__ in [m1,m2,m3]:
      assert m_.all()    == m__.all()
      assert m_.focus()  == m__.focus()
      assert m_.origin() == m__.origin()
  # binarize residual map
  sel = m1 <= fofc_cutoff
  mask = m1  .set_selected( sel, 0)
  mask = mask.set_selected(~sel, 1)
  del sel, m1
  assert approx_equal([flex.max(mask), flex.min(mask)], [1,0])
  def truncate_and_filter(m, cutoff, mask):
    return m.set_selected(m<=cutoff, 0)*mask
  # truncate and filter 2mFo-DFc map
  m2 = truncate_and_filter(m2, two_fofc_cutoff, mask)
  # truncate and filter FEM
  m3 = truncate_and_filter(m3, fem_cutoff, mask)
  del mask
  # combined maps
  def scale(m):
    sd = m.sample_standard_deviation()
    if(sd != 0): return m/sd
    else: return m
  m2 = scale(m2)
  m3 = scale(m3)
  m = (m2+m3)/2.
  del m2, m3
  m = scale(m)
  # connectivity analysis
  co = maptbx.connectivity(map_data=m, threshold=connectivity_cutoff)
  v_max=-1.e+9
  i_max=None
  for i, v in enumerate(co.regions()):
    if(i>0):
      if(v>v_max):
        v_max=v
        i_max=i
  mask2 = co.result()
  selection = mask2==i_max
  mask2 = mask2.set_selected(selection, 1)
  mask2 = mask2.set_selected(~selection, 0)
  assert mask2.count(1) == v_max
  # final filter
  m = m * mask2.as_double()
  if(local_average):
    maptbx.map_box_average(map_data=m, cutoff=0.5, index_span=1)
  return m

def shift_to_center_of_mass(xray_structure, target_map, cutoff=0.5):
  cm = xray_structure.center_of_mass()
  sites_cart = xray_structure.sites_cart()
  cmm = maptbx.center_of_mass(
    map_data=target_map, unit_cell=xray_structure.unit_cell(), cutoff=cutoff)
  x,y,z = cm[0]-cmm[0],cm[1]-cmm[1],cm[2]-cmm[2]
  sites_cart_new = apply_rigid_body_shift(sites_cart=sites_cart,
    cm=cm, x=-x,y=-y,z=-z, the=0, psi=0, phi=0)
  return xray_structure.replace_sites_cart(new_sites=sites_cart_new)

def run_refine(rsr_simple_refiner, xray_structure, scorer, log, weight):
  weight_best = None
  try:
    refined = individual_sites.refinery(
      refiner                  = rsr_simple_refiner,
      xray_structure           = xray_structure,
      start_trial_weight_value = 1.0,
      rms_bonds_limit          = 0.02,
      rms_angles_limit         = 2.0)
    scorer.update(sites_cart=refined.sites_cart_result)
    weight_best = refined.weight_final
  # except KeyboardInterrupt: raise
  except Exception:
    if(log): print("A trial failed: keep going...", file=log)
  return weight_best

def macro_cycle(
      xray_structure,
      target_map,
      geometry_restraints,
      max_iterations = 50,
      expload        = False,
      n_expload      = 1,
      log            = None):
  if(not log):
    if(log is None): log = sys.stdout
  d_min = maptbx.d_min_from_map(
      map_data  = target_map,
      unit_cell = xray_structure.unit_cell())
  all_selection = flex.bool(xray_structure.scatterers().size(),True)
  rsr_simple_refiner = individual_sites.simple(
    target_map                  = target_map,
    selection                   = all_selection,
    real_space_gradients_delta  = d_min/4,
    max_iterations              = max_iterations,
    geometry_restraints_manager = geometry_restraints)
  xray_structure = shift_to_center_of_mass(xray_structure=xray_structure,
    target_map=target_map)
  cm = xray_structure.center_of_mass()
  sites_cart = xray_structure.sites_cart()
  sc = scorer(
    unit_cell  = xray_structure.unit_cell(),
    sites_frac = xray_structure.sites_frac(),
    target_map = target_map,
    log        = log)
  weights = flex.double()
  sampling_range = range(0, 370, 50)   #[0, 90, 180, 270]
  for the in sampling_range:
    for psi in sampling_range:
      for phi in sampling_range:
        sites_cart_new = apply_rigid_body_shift(
          sites_cart=sites_cart,
          cm=cm, x=0,y=0,z=0, the=the, psi=psi, phi=phi)
        xray_structure = xray_structure.replace_sites_cart(
          new_sites=sites_cart_new)
        w = run_refine(
          rsr_simple_refiner = rsr_simple_refiner,
          xray_structure     = xray_structure,
          scorer             = sc,
          log                = log,
          weight             = flex.mean_default(weights, 1.0))
        weights.append(w)
        if(expload):
          for i in range(n_expload):
            xray_structure_ = xray_structure.deep_copy_scatterers()
            xray_structure_.shake_sites_in_place(mean_distance=1.0)
            run_refine(
              rsr_simple_refiner = rsr_simple_refiner,
              xray_structure     = xray_structure_,
              scorer             = sc,
              log                = log)
  if(log): print("Final target:", sc.target, file=log)
  return xray_structure.replace_sites_frac(new_sites=sc.sites_frac_best)


 *******************************************************************************


 *******************************************************************************
mmtbx/refinement/real_space/fit_water.py
from __future__ import absolute_import, division, print_function
from cctbx.array_family import flex
import mmtbx.refinement.real_space.rigid_body
import scitbx.lbfgs
import iotbx.pdb

def run(pdb_hierarchy,
        target_map,
        unit_cell,
        real_space_gradients_delta,
        max_allowed_shift = 1.5,
        max_iterations = 50,
        log = None):
  lbfgs_termination_params=scitbx.lbfgs.termination_parameters(
    max_iterations = max_iterations)
  get_class = iotbx.pdb.common_residue_names_get_class
  def target(target_map, sites_cart, unit_cell):
    sites_frac = unit_cell.fractionalize(sites_cart)
    result = 0
    for site_frac in sites_frac:
      result += target_map.eight_point_interpolation(site_frac)
    return result
  for model in pdb_hierarchy.models():
    for chain in model.chains():
      for residue_group in chain.residue_groups():
        for conformer in residue_group.conformers():
          for residue in conformer.residues():
            atoms = residue.atoms()
            if(get_class(name=residue.resname)=="common_water" and len(atoms)>1):
              if(log is not None):
                print("chain %s resname %s resseq %s"%(
                  chain.id, residue.resname, residue.resseq), file=log)
              sites_cart_start = atoms.extract_xyz()
              target_start = target(target_map, sites_cart_start, unit_cell)
              if(log is not None):
                print("  target_start: %6.4f"%target_start, file=log)
              target_current = target_start
              sites_cart_best = sites_cart_start.deep_copy()
              shift_range = [-0.3,0,0.3]
              for x_shift in shift_range:
                for y_shift in shift_range:
                  for z_shift in shift_range:
                    shift = flex.vec3_double(
                      [(x_shift, y_shift, z_shift)]*sites_cart_start.size())
                    sites_cart = sites_cart_start + shift
                    residue.atoms().set_xyz(sites_cart)
                    minimized = mmtbx.refinement.real_space.rigid_body.refine(
                      residue                     = residue,
                      density_map                 = target_map,
                      geometry_restraints_manager = None,
                      real_space_target_weight    = 1,
                      real_space_gradients_delta  = real_space_gradients_delta,
                      lbfgs_termination_params    = lbfgs_termination_params,
                      unit_cell                   = unit_cell)
                    sites_cart = minimized.sites_cart_residue
                    distance_moved = flex.mean(
                      flex.sqrt((sites_cart - sites_cart_start).dot()))
                    t = target(target_map, sites_cart, unit_cell)
                    if(t>=target_current and distance_moved<max_allowed_shift):
                      sites_cart_best = sites_cart.deep_copy()
                      target_current = t
              residue.atoms().set_xyz(sites_cart_best)
              target_final = target(target_map, sites_cart_best, unit_cell)
              distance_moved = flex.mean(
                flex.sqrt((sites_cart_best - sites_cart_start).dot()))
              if(log is not None):
                print("  target_final: %6.4f" % target_final, file=log)
                print("  dist. moved : %6.4f" % distance_moved, file=log)


 *******************************************************************************


 *******************************************************************************
mmtbx/refinement/real_space/individual_sites.py
from __future__ import absolute_import, division, print_function
from libtbx import adopt_init_args
import scitbx.lbfgs
from cctbx import maptbx
from cctbx.array_family import flex
from mmtbx import utils
from libtbx.test_utils import approx_equal
from cctbx import crystal
import mmtbx.refinement.minimization_ncs_constraints
import mmtbx.model
from cctbx.maptbx import minimization
from six.moves import range

class easy(object):
  """
  Simplest interface to most automated and fast real-space refinement.
  To keep it simple not all parameters are exposed.
  """
  def __init__(
        self,
        map_data,
        xray_structure,
        pdb_hierarchy,
        geometry_restraints_manager,
        gradients_method="fd",
        selection=None,
        selection_real_space=None,
        rms_bonds_limit=0.015,
        rms_angles_limit=2.0,
        max_iterations=150,
        w = None,
        states_accumulator=None,
        log=None):
    assert gradients_method in ["fd", "linear", "quadratic", "tricubic"]
    adopt_init_args(self, locals())
    es = geometry_restraints_manager.geometry.energies_sites(
      sites_cart = xray_structure.sites_cart())
    self.rmsd_angles_start = es.angle_deviations()[2]
    self.rmsd_bonds_start  = es.bond_deviations()[2]
    self.w = w
    if(self.max_iterations > 0):
      if(self.w is None):
        import mmtbx.refinement.real_space.weight
        self.weight = mmtbx.refinement.real_space.weight.run(
          map_data                    = map_data,
          xray_structure              = self.xray_structure,
          pdb_hierarchy               = self.pdb_hierarchy,
          geometry_restraints_manager = geometry_restraints_manager,
          rms_bonds_limit             = rms_bonds_limit,
          rms_angles_limit            = rms_angles_limit,
          gradients_method            = gradients_method)
        self.w = self.weight.weight
      if(selection is None):
        selection = flex.bool(self.xray_structure.scatterers().size(), True)
      refine_object = simple(
        target_map                  = map_data,
        selection                   = selection,
        selection_real_space        = selection_real_space,
        max_iterations              = max_iterations,
        geometry_restraints_manager = geometry_restraints_manager.geometry,
        states_accumulator          = states_accumulator,
        gradients_method            = gradients_method)
      refine_object.refine(
        weight = self.w, xray_structure = self.xray_structure)
      self.rmsd_bonds_final, self.rmsd_angles_final = refine_object.rmsds()
      self.xray_structure=self.xray_structure.replace_sites_cart(
        new_sites=refine_object.sites_cart(), selection=None)
      self.pdb_hierarchy.adopt_xray_structure(self.xray_structure)

class simple(object):
  def __init__(
        self,
        target_map,
        selection,
        geometry_restraints_manager,
        gradients_method="fd",
        real_space_gradients_delta=1./4,
        selection_real_space=None,
        max_iterations=150,
        states_accumulator=None,
        ncs_groups=None):
    adopt_init_args(self, locals())
    self.lbfgs_core_params = scitbx.lbfgs.core_parameters(
      stpmax = 25.0)
    self.lbfgs_termination_params = scitbx.lbfgs.termination_parameters(
      max_iterations = max_iterations)
    self.lbfgs_exception_handling_params = scitbx.lbfgs.\
      exception_handling_parameters(
        ignore_line_search_failed_step_at_lower_bound = True,
        ignore_line_search_failed_step_at_upper_bound = True,
        ignore_line_search_failed_maxfev              = True)
    self.refined = None
    self.crystal_symmetry = None
    self.site_symmetry_table = None

  def refine(self, weight, xray_structure):
    if(self.ncs_groups is None):
      self.crystal_symmetry = xray_structure.crystal_symmetry()
      self.site_symmetry_table = xray_structure.site_symmetry_table()
      self.refined = maptbx.real_space_refinement_simple.lbfgs(
        selection_variable              = self.selection,
        gradients_method                = self.gradients_method,
        selection_variable_real_space   = self.selection_real_space,
        sites_cart                      = xray_structure.sites_cart(),
        density_map                     = self.target_map,
        geometry_restraints_manager     = self.geometry_restraints_manager,
        real_space_target_weight        = weight,
        real_space_gradients_delta      = self.real_space_gradients_delta,
        lbfgs_core_params               = self.lbfgs_core_params,
        lbfgs_termination_params        = self.lbfgs_termination_params,
        lbfgs_exception_handling_params = self.lbfgs_exception_handling_params,
        states_collector                = self.states_accumulator)
    else:
      refine_selection = flex.bool(xray_structure.scatterers().size(),
        True).iselection()
      self.refined = mmtbx.refinement.minimization_ncs_constraints.\
        target_function_and_grads_real_space(
          map_data                   = self.target_map,
          xray_structure             = xray_structure.deep_copy_scatterers(),
          ncs_restraints_group_list  = self.ncs_groups,
          refine_selection           = refine_selection,
          real_space_gradients_delta = self.real_space_gradients_delta,
          restraints_manager         = self.geometry_restraints_manager,
          data_weight                = weight,
          refine_sites               = True)
      minimized = mmtbx.refinement.minimization_ncs_constraints.lbfgs(
        target_and_grads_object      = self.refined,
        xray_structure               = xray_structure.deep_copy_scatterers(),
        ncs_restraints_group_list    = self.ncs_groups,
        refine_selection             = refine_selection,
        finite_grad_differences_test = False,
        max_iterations               = self.max_iterations,
        refine_sites                 = True)

  def sites_cart(self):
    assert self.refined is not None
    if(self.ncs_groups is None):
      sites_cart = self.refined.sites_cart
    else:
      sites_cart = self.refined.xray_structure.sites_cart()
      return sites_cart #XXX TRAP
    if(self.selection):
      sites_cart.set_selected(self.selection, self.refined.sites_cart_variable)
    special_position_indices = self.site_symmetry_table.special_position_indices()
    if(special_position_indices.size()>0):
      for i_seq in special_position_indices:
        sites_cart[i_seq] = crystal.correct_special_position(
          crystal_symmetry = self.crystal_symmetry,
          special_op       = self.site_symmetry_table.get(i_seq).special_op(),
          site_cart        = sites_cart[i_seq],
          site_label       = None,
          tolerance        = 1)
    return sites_cart

  def rmsds(self):
    b,a = None,None
    es = self.geometry_restraints_manager.energies_sites(
      sites_cart = self.sites_cart())
    a = es.angle_deviations()[2]
    b = es.bond_deviations()[2]
    return b,a

class diff_map(object):
  def __init__(self,
               miller_array,
               crystal_gridding,
               map_target,
               geometry_restraints_manager,
               restraints_target_weight = 1,
               max_iterations = 500,
               min_iterations = 500):
    adopt_init_args(self, locals())
    self.step = miller_array.d_min()/4.
    self.refined = None

  def refine(self, weight, sites_cart=None, xray_structure=None):
    assert xray_structure is not None and [sites_cart,xray_structure].count(None)==1
    self.refined = minimization.run(
      xray_structure              = xray_structure,
      miller_array                = self.miller_array,
      crystal_gridding            = self.crystal_gridding,
      map_target                  = self.map_target,
      max_iterations              = self.max_iterations,
      min_iterations              = self.min_iterations,
      step                        = self.step,
      real_space_target_weight    = weight,
      restraints_target_weight    = self.restraints_target_weight,
      geometry_restraints_manager = self.geometry_restraints_manager,
      target_type                 = "diffmap")

  def sites_cart(self):
    assert self.refined is not None
    return self.refined.xray_structure.sites_cart()

class refinery(object):
  def __init__(self,
               refiner,
               xray_structure,
               start_trial_weight_value = 50.,
               weight_sample_rate = 10,
               rms_bonds_limit = 0.03,
               rms_angles_limit = 3.0,
               optimize_weight = True):
    self.rms_angles_start = None
    self.rms_bonds_start = None
    self.refiner = refiner
    self.weight_start=start_trial_weight_value
    sites_cart_start = xray_structure.sites_cart()
    self.rms_bonds_start, self.rms_angles_start  = \
      self.rmsds(sites_cart=xray_structure.sites_cart())
    self.weight_sample_rate = weight_sample_rate
    # results
    self.weight_final = None
    self.sites_cart_result = None
    self.rms_bonds_final,self.rms_angles_final = None,None
    #
    pool = {}
    bonds = flex.double()
    angles = flex.double()
    weights = flex.double()
    #
    weight = start_trial_weight_value
    weight_last = weight
    self.adjust_weight_sample_rate(weight=weight)
    if(optimize_weight):
      while True:
        self.rmsds(sites_cart=sites_cart_start) # DUMMY
        self.adjust_weight_sample_rate(weight=weight_last)
        tmp = xray_structure.deep_copy_scatterers()
        #tmp.shake_sites_in_place(
        #  rms_difference = None,
        #  mean_distance  = 0.5)
        refiner.refine(
          xray_structure = tmp,#xray_structure.deep_copy_scatterers(), # XXX
          weight     = weight)
        sites_cart_result = refiner.sites_cart()
        bd, ad = self.rmsds(sites_cart=sites_cart_result)
        bonds.append(bd)
        angles.append(ad)
        weights.append(weight)
        pool.setdefault(weight,[]).append([sites_cart_result.deep_copy(),bd,ad])
        if(refiner.geometry_restraints_manager is None): break
        weight_last = weight
        if(ad>rms_angles_limit or bd > rms_bonds_limit):
          weight -= self.weight_sample_rate
        else:
          weight += self.weight_sample_rate
        if(weight<0 or abs(weight)<1.e-6):
          self.adjust_weight_sample_rate(weight=weight)
          weight = weight_last
          weight -= self.weight_sample_rate
        #print ">>> ", "%8.4f %8.4f"%(weight, weight_last), "%6.4f %5.2f"%(bd, ad),\
        #  self.weight_sample_rate, "  f (start/final):", refiner.refined.f_start, refiner.refined.f_final
        if((weight<0 or weight>1000) or weight in weights): break
        l = bonds.size()-1
        if(bonds.size()>5 and
           abs(bonds[l]-bonds[l-1])<0.0005 and
           abs(bonds[l]-bonds[l-2])<0.0005 and
           abs(bonds[l]-bonds[l-3])<0.0005 and
           abs(bonds[l]-bonds[l-4])<0.0005 and
           abs(bonds[l]-bonds[l-5])<0.0005): break
    else:
      refiner.refine(
        xray_structure = xray_structure.deep_copy_scatterers(), # XXX
        weight     = weight)
      sites_cart_result = refiner.sites_cart()
    # select results
    if(optimize_weight):
      delta = bonds-rms_bonds_limit
      ind = (delta == flex.max_default(delta.select(delta<=0),
        flex.min(delta))).iselection()[0]
      self.weight_final = weights[ind]
      self.sites_cart_result = pool[self.weight_final][0][0]
      self.rms_bonds_final,self.rms_angles_final = \
        self.rmsds(sites_cart=self.sites_cart_result)
      assert approx_equal(pool[self.weight_final][0][2], angles[ind])
      assert approx_equal(pool[self.weight_final][0][1], bonds[ind])
      assert approx_equal(self.rms_angles_final, angles[ind])
      assert approx_equal(self.rms_bonds_final, bonds[ind])
    else:
      self.weight_final = self.weight_start
      self.sites_cart_result = sites_cart_result

  def rmsds(self, sites_cart):
    b,a = None,None
    if(self.refiner.geometry_restraints_manager is not None):
      es = self.refiner.geometry_restraints_manager.energies_sites(
        sites_cart = sites_cart)
      a = es.angle_deviations()[2]
      b = es.bond_deviations()[2]
    return b,a

  def adjust_weight_sample_rate(self, weight):
    if(  weight <= 0.01 ): self.weight_sample_rate=0.001
    elif(weight <= 0.1  ): self.weight_sample_rate=0.01
    elif(weight <= 1.0  ): self.weight_sample_rate=0.1
    elif(weight <= 10.  ): self.weight_sample_rate=1.
    elif(weight <= 100. ): self.weight_sample_rate=10.
    elif(weight <= 1000.): self.weight_sample_rate=100.

class box_refinement_manager(object):
  def __init__(self,
               xray_structure,
               target_map,
               geometry_restraints_manager,
               gradients_method="fd",
               real_space_gradients_delta=1./4,
               max_iterations = 50,
               ncs_groups = None):
    self.xray_structure = xray_structure
    self.sites_cart = xray_structure.sites_cart()
    self.target_map = target_map
    self.geometry_restraints_manager = geometry_restraints_manager
    self.max_iterations=max_iterations
    self.real_space_gradients_delta = real_space_gradients_delta
    self.weight_optimal = None
    self.ncs_groups = ncs_groups
    self.gradients_method = gradients_method

  def update_xray_structure(self, new_xray_structure):
    self.xray_structure = new_xray_structure

  def update_target_map(self, new_target_map):
    self.target_map = new_target_map

  def refine(self,
             selection,
             optimize_weight = True,
             start_trial_weight_value = 50,
             selection_buffer_radius=5,
             box_cushion=2,
             rms_bonds_limit = 0.03,
             rms_angles_limit = 3.0):
    if(self.ncs_groups is None or len(self.ncs_groups)==0): # no NCS constraints
      sites_cart_moving = self.sites_cart
      selection_within = self.xray_structure.selection_within(
        radius    = selection_buffer_radius,
        selection = selection)
      sel = selection.select(selection_within)
      iselection = flex.size_t()
      for i, state in enumerate(selection):
        if state:
          iselection.append(i)
      box = utils.extract_box_around_model_and_map(
        xray_structure = self.xray_structure.select(selection=selection_within),
        map_data       = self.target_map,
        box_cushion    = box_cushion)
      new_unit_cell = box.xray_structure_box.unit_cell()
      geo_box = self.geometry_restraints_manager.select(selection_within)
      geo_box = geo_box.discard_symmetry(new_unit_cell=new_unit_cell)
      geo_box.shift_sites_cart(box.shift_cart) # disaster happens otherwise
      map_box = box.map_box
      sites_cart_box = box.xray_structure_box.sites_cart()

      rsr_simple_refiner = simple(
        target_map                  = map_box,
        selection                   = sel,
        real_space_gradients_delta  = self.real_space_gradients_delta,
        max_iterations              = self.max_iterations,
        geometry_restraints_manager = geo_box,
        gradients_method            = self.gradients_method)
      real_space_result = refinery(
        refiner                  = rsr_simple_refiner,
        xray_structure           = box.xray_structure_box,
        optimize_weight          = optimize_weight,
        start_trial_weight_value = start_trial_weight_value,
        rms_bonds_limit = rms_bonds_limit,
        rms_angles_limit = rms_angles_limit)
      self.weight_optimal = real_space_result.weight_final
      sites_cart_box_refined = real_space_result.sites_cart_result
      shift_back = [-box.shift_cart[i] for i in range(3)]
      sites_cart_box_refined_shifted_back = \
        sites_cart_box_refined + shift_back # Sure + not - ?
      sites_cart_refined = sites_cart_box_refined_shifted_back.select(sel)
      sites_cart_moving = sites_cart_moving.set_selected(
        iselection, sites_cart_refined)
      self.xray_structure.set_sites_cart(sites_cart_moving)
      self.sites_cart = self.xray_structure.sites_cart()
    else: # NCS constraints are present
      # select on xrs, grm, ncs_groups
      grm = self.geometry_restraints_manager.select(selection)
      xrs = self.xray_structure.select(selection)
      sel = flex.bool(xrs.scatterers().size(), True)
      size = self.xray_structure.scatterers().size()
      ncs_groups_ = self.ncs_groups.select(selection=selection)
      #
      rsr_simple_refiner = simple(
        target_map                  = self.target_map,
        selection                   = sel,
        real_space_gradients_delta  = self.real_space_gradients_delta,
        max_iterations              = self.max_iterations,
        geometry_restraints_manager = grm,
        ncs_groups                  = ncs_groups_)
      real_space_result = refinery(
        refiner                  = rsr_simple_refiner,
        xray_structure           = xrs,
        optimize_weight          = optimize_weight,
        start_trial_weight_value = start_trial_weight_value,
        rms_bonds_limit          = rms_bonds_limit,
        rms_angles_limit         = rms_angles_limit)
      self.weight_optimal = real_space_result.weight_final
#      # XXX undefined
#      self.xray_structure = None #XXX undefined
#      self.sites_cart = None     #XXX undefined


class minimize_wrapper_with_map():
  def __init__(self,
      model,
      target_map,
      refine_ncs_operators=False,
      number_of_cycles=1,
      cycles_to_converge=2,
      min_mode='simple_cycles',
      resolution=3.,
      log=None):

    # completely new way of doing this. using RSR macro-cycle
    # for test compatibility:
    print("Minimizing using reference map...", file=log)
    if model.ncs_constraints_present():
      print("  Minimizing... (NCS)", file=log)
    else:
      print("  Minimizing...", file=log)
    from phenix.refinement.macro_cycle_real_space import run as rsr_mc_run
    import scitbx.math
    from phenix.refinement import rsr
    rsr_master_params = rsr.master_params_str
    import iotbx.phil
    rsr_master_params = iotbx.phil.parse(rsr_master_params, process_includes=True)
    import mmtbx.idealized_aa_residues.rotamer_manager
    sin_cos_table = scitbx.math.sin_cos_table(n=10000)
    params = rsr_master_params.extract()
    params.pdb_interpretation = model._pdb_interpretation_params.pdb_interpretation
    params.refinement.run = "minimization_global+local_grid_search"
    params.refine_ncs_operators=False
    params.refinement.macro_cycles = number_of_cycles
    params.resolution = resolution
    rotamer_manager = mmtbx.idealized_aa_residues.rotamer_manager.load(
        rotamers = "favored")
    rigid_body_selections = [] # no RBR here
    from iotbx import map_model_manager
    from iotbx import map_manager
    mm = map_manager.map_manager(
      map_data                   = target_map,
      unit_cell_grid             = target_map.all(),
      wrapping                   = False,
      unit_cell_crystal_symmetry = model.crystal_symmetry())
    mmm = map_model_manager.map_model_manager(
      model       = model,
      map_manager = mm)
    res = rsr_mc_run(
      params                = params,
      map_model_manager     = mmm,
      log                   = log,
      rotamer_manager       = rotamer_manager,
      sin_cos_table         = sin_cos_table,
      rigid_body_selections = rigid_body_selections)

    model.set_sites_cart_from_hierarchy(res.model.get_hierarchy())
    res.structure_monitor.states_collector.write(file_name="rsr_all_states.pdb")
    return





    # end ===================================================
    # Very sophisticated implementation. Need to investigate before removal.

    from mmtbx.refinement.geometry_minimization import add_rotamer_restraints
    from mmtbx.refinement.minimization_monitor import minimization_monitor
    self.model = model
    self.log = log
    print("Minimizing using reference map...", file=self.log)
    self.log.flush()

    # copy-paste from cctbx_project/mmtbx/refinement/geometry_minimization.py:
    # minimize_wrapper_for_ramachandran
    self.model.get_restraints_manager().geometry.pair_proxies(
        sites_cart=self.model.get_sites_cart())

    ncs_restraints_group_list = self.model.get_ncs_groups()
    if ncs_restraints_group_list is None:
      ncs_restraints_group_list = []
    ncs_groups=None
    if len(ncs_restraints_group_list) > 0:
      ncs_groups=ncs_restraints_group_list

    min_monitor = minimization_monitor(
        number_of_cycles=number_of_cycles,
        max_number_of_cycles=20,
        cycles_to_converge=cycles_to_converge,
        mode=min_mode)
    selection_real_space = None
    import mmtbx.refinement.real_space.weight
    self.w = 1
    print("number_of_cycles", number_of_cycles, file=log)
    print("Stats before minimization:", file=log)
    ms = self.model.geometry_statistics()
    ms.show(log=log)

    while min_monitor.need_more_cycles():
      print("Cycle number", min_monitor.get_current_cycle_n(), file=self.log)
      self.model.get_restraints_manager().geometry.\
          update_ramachandran_restraints_phi_psi_targets(
              hierarchy=self.model.get_hierarchy())
      print("  Updating rotamer restraints...", file=self.log)
      add_rotamer_restraints(
        pdb_hierarchy      = self.model.get_hierarchy(),
        restraints_manager = self.model.get_restraints_manager(),
        selection          = None,
        sigma              = 5,
        mode               = "fix_outliers",
        accept_allowed     = False,
        mon_lib_srv        = self.model.get_mon_lib_srv(),
        rotamer_manager    = self.model.get_rotamer_manager())
      self.model.set_sites_cart_from_hierarchy()

      if min_monitor.need_weight_optimization():
        # if self.w is None:
        print("  Determining weight...", file=self.log)
        self.log.flush()
        self.weight = mmtbx.refinement.real_space.weight.run(
            map_data                    = target_map,
            xray_structure              = self.model.get_xray_structure(),
            pdb_hierarchy               = self.model.get_hierarchy(),
            geometry_restraints_manager = self.model.get_restraints_manager(),
            rms_bonds_limit             = 0.015,
            rms_angles_limit            = 1.0,
            ncs_groups                  = ncs_groups)

        # division is to put more weight onto restraints. Checked. Works.
        self.w = self.weight.weight/3.0
        # self.w = self.weight.weight/15.0
        # self.w = 0
        # self.w = self.weight.weight
        for s in self.weight.msg_strings:
          print(s, file=self.log)

      if ncs_restraints_group_list is None or len(ncs_restraints_group_list)==0:
        #No NCS
        print("  Minimizing...", file=self.log)
        print("     with weight %f" % self.w, file=self.log)
        self.log.flush()
        refine_object = simple(
            target_map                  = target_map,
            selection                   = None,
            max_iterations              = 150,
            geometry_restraints_manager = self.model.get_restraints_manager().geometry,
            selection_real_space        = selection_real_space,
            states_accumulator          = None,
            ncs_groups                  = ncs_groups)
        refine_object.refine(weight = self.w, xray_structure = self.model.get_xray_structure())
        self.rmsd_bonds_final, self.rmsd_angles_final = refine_object.rmsds()
        print("RMSDS:", self.rmsd_bonds_final, self.rmsd_angles_final, file=log)
        # print >> log, "sizes:", len(refine_object.sites_cart()), len(self.xrs.scatterers())
        self.model.set_sites_cart(refine_object.sites_cart(), update_grm=True)
        # print >> log, "sizes", self.xrs.scatterers()
      else:
        # Yes NCS
        # copy-paste from macro_cycle_real_space.py
        # !!! Don't rearrange NCS groups here because master was just fixed!
        # import mmtbx.ncs.ncs_utils as nu
        # nu.get_list_of_best_ncs_copy_map_correlation(
        #     ncs_groups     = ncs_restraints_group_list,
        #     xray_structure = self.model.get_xray_structure(),
        #     map_data       = target_map,
        #     d_min          = 3)
        print("  Minimizing... (NCS)", file=self.log)
        tfg_obj = mmtbx.refinement.minimization_ncs_constraints.\
          target_function_and_grads_real_space(
            map_data                   = target_map,
            xray_structure             = self.model.get_xray_structure(),
            ncs_restraints_group_list  = ncs_restraints_group_list,
            refine_selection           = None,
            real_space_gradients_delta = 1,
            restraints_manager         = self.model.get_restraints_manager(),
            data_weight                = self.w,
            refine_sites               = True)
        minimized = mmtbx.refinement.minimization_ncs_constraints.lbfgs(
          target_and_grads_object      = tfg_obj,
          xray_structure               = self.model.get_xray_structure(),
          ncs_restraints_group_list    = ncs_restraints_group_list,
          refine_selection             = None,
          finite_grad_differences_test = False,
          max_iterations               = 100,
          refine_sites                 = True)
        self.model.set_sites_cart(tfg_obj.xray_structure.sites_cart())
      ncs_restraints_group_list.recalculate_ncs_transforms(self.model.get_sites_cart())
      ms = self.model.geometry_statistics()
      min_monitor.save_cycle_results(geometry=ms)
      ms.show(log=log)


 *******************************************************************************


 *******************************************************************************
mmtbx/refinement/real_space/occupancy.py
from __future__ import absolute_import, division, print_function
from libtbx import easy_mp
import boost_adaptbx.boost.python as bp
cctbx_maptbx_ext = bp.import_ext("cctbx_maptbx_ext")
import mmtbx.refinement.real_space.adp as dependency
import mmtbx.refinement.occupancies
import mmtbx.refinement.refinement_flags
from libtbx.utils import Sorry

def raise_ncs_and_custom_occ_selections_not_supported(occ_params, model):
  custom_occ_selections = len(occ_params.constrained_group) + \
                          len(occ_params.individual) + \
                          len(occ_params.remove_selection)
  # Safeguard against using NCS constraints and custom occupancy selections
  if(custom_occ_selections>0 and model.ncs_constraints_present()):
    msg="NCS constraints and custom occupancy selections are not supported."
    raise Sorry(msg)

class ncs_aware_refinement(object):
  def __init__(self, map_model_manager, d_min, atom_radius, occupancy_params,
               nproc=1, log = None):
    self.mmm              = map_model_manager
    self.nproc            = nproc
    self.d_min            = d_min
    self.atom_radius      = atom_radius
    self.log              = log
    self.occupancy_params = occupancy_params
    # Determine if need to do occ refinement
    f1 = self.occupancy_params.constrained_group
    if(len(f1)==1):
     if(len(f1[0].selection)==1):
       if(f1[0].selection[0] is None):
         f1 = []
    f2 = self.occupancy_params.individual
    if(len(f2)==1):
      if(len(f2)==1):
        if(f2[0] is None):
          f2 = []
    f3 = self.occupancy_params.remove_selection
    if(len(f3)==1):
      if(len(f3)==1):
        if(f3[0] is None):
          f3 = []
    custom_occ_selections = len(f1) + len(f2) + len(f3)
    # Safeguard against using NCS constraints and custom occupancy selections
    raise_ncs_and_custom_occ_selections_not_supported(
      occ_params = self.occupancy_params, model = self.mmm.model())
    self.selections = mmtbx.refinement.occupancies.occupancy_selections(
      model                              = self.mmm.model(),
      add_water                          = False,
      other_constrained_groups           = f1,
      other_individual_selection_strings = f2,
      remove_selection                   = f3,
      as_flex_arrays                     = True,
      constrain_correlated_3d_groups     = False,
      log                                = self.log)
    proceed = True
    if(self.selections is None or len(self.selections)==0):
      proceed = False
    if(proceed):
      #
      if(self.nproc>1): self.log = None
      #
      ncs_groups = self.mmm.model().get_ncs_groups()
      if(ncs_groups is None or len(ncs_groups)==0):
        values = self.run_one()
        self.mmm.model().set_occupancies(values = values)
      else:
        values = self.mmm.model().get_occ()
        for i, g in enumerate(ncs_groups):
          values_g = self.run_one(selection = g.master_iselection)
          values = values.set_selected(g.master_iselection, values_g)
          for j, c in enumerate(g.copies):
            values = values.set_selected(c.iselection, values_g)
        self.mmm.model().set_occupancies(values = values)

  def run_one(self, selection=None):
    model = self.mmm.model()
    if(selection is not None): model = model.select(selection)
    values = model.get_occ()
    if(self.nproc==1):
      args = [model,]
      return self.run_one_one(args = args)
    else:
      argss = []
      selections = []
      for c in model.get_hierarchy().chains():
        sel = c.atoms().extract_i_seq()
        argss.append([model.select(sel),])
        selections.append(sel) # XXX CAN BE BIG
      stdout_and_results = easy_mp.pool_map(
        processes    = self.nproc,
        fixed_func   = self.run_one_one,
        args         = argss,
        func_wrapper = "buffer_stdout_stderr")
      for i, result in enumerate(stdout_and_results):
        values = values.set_selected(selections[i], result[1])
      model.set_occupancies(values = values)
      return values

  def run_one_one(self, args):
    model = args[0].deep_copy()
    # selections for refinable occupancies
    selections = mmtbx.refinement.occupancies.occupancy_selections(
      model                              = model,
      add_water                          = False,
      other_constrained_groups           = self.occupancy_params.constrained_group,
      other_individual_selection_strings = self.occupancy_params.individual,
      remove_selection                   = self.occupancy_params.remove_selection,
      as_flex_arrays                     = True,
      constrain_correlated_3d_groups     = False,
      log                                = self.log)
    if(selections is None or len(selections)==0):
      return model.get_occ()
    #
    fmodel = dependency.map_and_model_to_fmodel(
      map_data       = self.mmm.map_data().deep_copy(),
      xray_structure = model.get_xray_structure(),
      atom_radius    = self.atom_radius,
      reset_adp      = False,
      d_min          = self.d_min)
    model.set_xray_structure(xray_structure = fmodel.xray_structure)
    #
    refla = mmtbx.refinement.refinement_flags.manager(
      occupancies=True, s_occupancies = selections)
    model.set_refinement_flags(flags = refla)
    if(self.log is not None):
      print("r_start: %6.4f"%fmodel.r_work(), file=self.log)
    o = mmtbx.refinement.occupancies.manager(
      fmodels                  = mmtbx.fmodels(fmodel_xray = fmodel),
      model                    = model,
      max_number_of_iterations = 50,
      number_of_macro_cycles   = 3,
      occupancy_max            = 1,
      occupancy_min            = 0,
      exclude_hd               = False,
      log                      = self.log)
    if(self.log is not None):
      print("r_final: %6.4f"%fmodel.r_work(), file=self.log)
    #
    return fmodel.xray_structure.scatterers().extract_occupancies()


 *******************************************************************************


 *******************************************************************************
mmtbx/refinement/real_space/rigid_body.py
from __future__ import absolute_import, division, print_function
from cctbx import maptbx
from cctbx.array_family import flex
import scitbx.rigid_body
import scitbx.graph.tardy_tree
import scitbx.lbfgs
from scitbx import matrix
from libtbx.test_utils import approx_equal
from libtbx import adopt_init_args
import sys
import boost_adaptbx.boost.python as bp
from six.moves import range
cctbx_maptbx_ext = bp.import_ext("cctbx_maptbx_ext")
from cctbx import miller
import mmtbx.utils

def real_space_rigid_body_gradients_simple(
      unit_cell,
      density_map,
      sites_cart_0,
      center_of_mass,
      q,
      unit_quaternion_delta=0.01,
      translation_delta=0.3):
  result = flex.double()
  q_delta = q.deep_copy()
  def get(i, delta):
    fs = []
    for signed_delta in [delta, -delta]:
      q_delta[i] = q[i] + signed_delta
      aja = matrix.rt(scitbx.rigid_body.joint_lib_six_dof_aja_simplified(
        center_of_mass=center_of_mass,
        q=q_delta))
      sites_cart_delta = aja * sites_cart_0
      rs_f = maptbx.real_space_target_simple(
        unit_cell=unit_cell,
        density_map=density_map,
        sites_cart=sites_cart_delta,
        selection=flex.bool(sites_cart_delta.size(),True))
      fs.append(rs_f)
    result.append((fs[0]-fs[1])/(2*delta))
  for i in range(4): get(i=i, delta=unit_quaternion_delta)
  for i in range(3): get(i=i+4, delta=translation_delta)
  return result

class refine(object):

  def __init__(self,
        residue,
        density_map,
        geometry_restraints_manager,
        real_space_target_weight,
        real_space_gradients_delta,
        lbfgs_termination_params,
        unit_cell,
        cctbx_geometry_restraints_flags=None,
        states_collector=None):
    self.states_collector = states_collector
    self.cctbx_geometry_restraints_flags = cctbx_geometry_restraints_flags
    self.residue = residue
    self.density_map = density_map
    self.geometry_restraints_manager = geometry_restraints_manager
    self.real_space_gradients_delta = real_space_gradients_delta
    self.real_space_target_weight = real_space_target_weight
    #
    self.unit_cell = unit_cell
    self.sites_cart_residue_0 = residue.atoms().extract_xyz()
    self.residue_center_of_mass = self.sites_cart_residue_0.mean()
    residue_tardy_tree = scitbx.graph.tardy_tree.construct(
      n_vertices=self.sites_cart_residue_0.size(),
      edge_list="all_in_one_rigid_body") \
        .build_tree() \
        .fix_near_singular_hinges(sites=None)
    self.residue_tardy_model = scitbx.rigid_body.tardy_model(
      labels=None,
      sites=self.sites_cart_residue_0,
      masses=flex.double(self.sites_cart_residue_0.size(), 1),
      tardy_tree=residue_tardy_tree,
      potential_obj=self)
    self.x = self.residue_tardy_model.pack_q()
    assert self.x.size() == 7 # other cases not implemented
    #
    self.number_of_function_evaluations = -1
    self.f_start, self.g_start = self.compute_functional_and_gradients()
    self.rs_f_start = self.rs_f
    lbfgs_exception_handling_params = scitbx.lbfgs.exception_handling_parameters(
      ignore_line_search_failed_step_at_lower_bound = True,
      ignore_line_search_failed_step_at_upper_bound = True,
      ignore_line_search_failed_maxfev              = True)
    self.minimizer = scitbx.lbfgs.run(
      target_evaluator=self,
      termination_params=lbfgs_termination_params,
      exception_handling_params = lbfgs_exception_handling_params)
    self.f_final, self.g_final = self.compute_functional_and_gradients()
    self.rs_f_final = self.rs_f
    del self.rs_f
    del self.x
    del self.residue_center_of_mass
    del self.sites_cart_residue_0
    del self.unit_cell

  def compute_functional_and_gradients(self):
    if (self.number_of_function_evaluations == 0):
      self.number_of_function_evaluations += 1
      return self.f_start, self.g_start
    self.number_of_function_evaluations += 1
    self.residue_tardy_model.unpack_q(q_packed=self.x)
    self.sites_cart_residue = self.residue_tardy_model.sites_moved()
    if(self.states_collector is not None):
      self.states_collector.add(sites_cart = self.sites_cart_residue)
    rs_f = maptbx.real_space_target_simple(
      unit_cell=self.unit_cell,
      density_map=self.density_map,
      sites_cart=self.sites_cart_residue,
      selection=flex.bool(self.sites_cart_residue.size(),True))
    rs_g = real_space_rigid_body_gradients_simple(
      unit_cell=self.unit_cell,
      density_map=self.density_map,
      sites_cart_0=self.sites_cart_residue_0,
      center_of_mass=self.residue_center_of_mass,
      q=self.x)
    self.rs_f = rs_f
    rs_f *= -self.real_space_target_weight
    rs_g *= -self.real_space_target_weight
    if (self.geometry_restraints_manager is None):
      f = rs_f
      g = rs_g
    else:
      gr_e = self.geometry_restraints_manager.energies_sites(
        sites_cart=self.sites_cart_residue,
        flags = self.cctbx_geometry_restraints_flags,
        compute_gradients=True)
      self.__d_e_pot_d_sites = gr_e.gradients
      f = rs_f + gr_e.target
      g = rs_g + self.residue_tardy_model.d_e_pot_d_q_packed()
    return f, g.as_double()

  def d_e_pot_d_sites(self, sites_moved):
    result = self.__d_e_pot_d_sites
    del self.__d_e_pot_d_sites
    return result

class refine_mz(object):
  """
  Efficient real-space rigid-body refinement. Analog of MZ rigid-body refinement
  in reciprocal space. Whole content of pdb_hierarchy is treated as one rigid
  group.
  """

  def __init__(
        self,
        map_data,
        pdb_hierarchy,  # XXX redundant inputs
        xray_structure, # XXX redundant inputs
        d_min,
        use_mask=False,
        masking_atom_radius=5,
        max_iterations=50,
        macro_cycles=1,
        prefix="",
        log=None):
    adopt_init_args(self, locals())
    self.cc_best = None
    self.sites_cart_best = None
    if(self.log is None): self.log = sys.stdout
    self.sites_cart_start = self.xray_structure.sites_cart()
    assert approx_equal(self.pdb_hierarchy.atoms().extract_xyz(),
      self.sites_cart_start, 1.e-3)
    self.crystal_gridding = maptbx.crystal_gridding(
      unit_cell             = self.xray_structure.unit_cell(),
      space_group_info      = self.xray_structure.space_group_info(),
      pre_determined_n_real = self.map_data.all())
    self.complete_set = miller.build_set(
      crystal_symmetry = self.xray_structure.crystal_symmetry(),
      anomalous_flag   = False,
      d_min            = self.d_min)
    self.cc_start = self._get_cc()
    self._show_and_track(d_min = self.d_min)
    self.d_mins = self._get_mz_resolution_limits()
    for macro_cycle in range(self.macro_cycles):
      self._refine()
    self.xray_structure.set_sites_cart(self.sites_cart_best)
    self.pdb_hierarchy.adopt_xray_structure(self.xray_structure)

  def _show_and_track(self, d_min):
    cc = self._get_cc()
    s2 = self.xray_structure.sites_cart()
    if(self.cc_best is None or cc>self.cc_best):
      self.cc_best = cc
      self.sites_cart_best = s2.deep_copy()
    if(self.log):
      fmt="%sd_min=%6.2f CC=%6.4f (best to keep CC=%6.4f), moved from start (max/mean)=%s"
      s1 = self.sites_cart_start
      d = flex.sqrt((s1-s2).dot()).min_max_mean().as_tuple()[1:]
      d_str = "%6.3f %6.3f"%d
      print(fmt%(self.prefix, d_min, cc, self.cc_best, d_str), file=self.log)
      revert = (cc<self.cc_start and abs(cc-self.cc_start)>0.1) or \
               d[0] > 10 and (cc<self.cc_start or abs(cc-self.cc_start)<0.1) or \
               cc < 0.1
      if(revert):
        self.sites_cart_best = self.sites_cart_start
        self.xray_structure.set_sites_cart(self.sites_cart_start)
        self.pdb_hierarchy.adopt_xray_structure(self.xray_structure)
        print("   >>> reversed", d[0], cc, self.cc_start, file=self.log)

  def _refine(self):
    self.lbfgs_termination_params=scitbx.lbfgs.termination_parameters(
      max_iterations = self.max_iterations)
    mask_data = self._get_mask()
    for d_min in self.d_mins:
      md = self._get_map_at_d_min(d_min=d_min)
      if(mask_data is not None):
        md = md*mask_data.as_double()
      minimized = refine(
        residue                     = self.pdb_hierarchy,
        density_map                 = md,
        geometry_restraints_manager = None,
        real_space_target_weight    = 1,
        real_space_gradients_delta  = d_min*0.25,
        lbfgs_termination_params    = self.lbfgs_termination_params,
        unit_cell                   = self.xray_structure.unit_cell())
      self.xray_structure.set_sites_cart(minimized.sites_cart_residue)
      self.pdb_hierarchy.adopt_xray_structure(self.xray_structure)
      self._show_and_track(d_min = d_min)

  def _get_mz_resolution_limits(self):
    # lowest resolution: first zone
    n_ref_lowest = 0
    d_spacing = self.complete_set.d_spacings().sort().data()
    if(d_spacing.size()<500): return ( self.complete_set.d_min(), )
    d_0 = min(d_spacing[499], 15)
    if(d_0>8.0): d_1 = 8.0
    else:
      return d_0, self.d_min
    # second zone
    if(d_1>4.0 and self.d_min<4.0):
      d_2 = 4.0
    else:
      d_2 = max(self.d_min, 4.0)
    return d_0, d_1, d_2

  def _get_mask(self):
    mask_data = None
    if(self.use_mask):
      xrs_p1 = self.xray_structure.expand_to_p1(sites_mod_positive=True)
      radii = flex.double(xrs_p1.scatterers().size(), self.masking_atom_radius)
      mask_data = cctbx_maptbx_ext.mask(
        sites_frac                  = xrs_p1.sites_frac(),
        unit_cell                   = xrs_p1.unit_cell(),
        n_real                      = self.map_data.all(),
        mask_value_inside_molecule  = 1,
        mask_value_outside_molecule = 0,
        radii                       = radii)
    return mask_data

  def _get_map(self):
    f_calc = self.xray_structure.structure_factors(d_min=self.d_min).f_calc()
    fft_map = miller.fft_map(
      crystal_gridding     = self.crystal_gridding,
      fourier_coefficients = f_calc)
    fft_map.apply_sigma_scaling() # XXX not really needed
    return fft_map.real_map_unpadded()

  def _get_cc(self):
    return flex.linear_correlation(
      x=self.map_data.as_1d(),
      y=self._get_map().as_1d()).coefficient()

  def _get_map_at_d_min(self, d_min):
    done = False
    cntr = 0
    while not done:
      if(cntr>50):
        raise RuntimeError("Number of trial resolution increments exceeded.")
      try:
        f_obs_cmpl = self.complete_set.resolution_filter(
          d_min=d_min).structure_factors_from_map(
            map            = self.map_data,
            use_scale      = True,
            anomalous_flag = False,
            use_sg         = True)
        done = True
      except KeyboardInterrupt: raise
      except Exception as e:
        if(str(e)=="cctbx Error: Miller index not in structure factor map."):
          d_min += 0.25
      cntr+=1
    fft_map = miller.fft_map(
      crystal_gridding     = self.crystal_gridding,
      fourier_coefficients = f_obs_cmpl)
    fft_map.apply_sigma_scaling()
    return fft_map.real_map_unpadded()

class refine_groups(object):

  def __init__(
        self,
        map_data,
        pdb_hierarchy,
        xray_structure,
        macro_cycles,
        d_min):
    self.pdb_hierarchy = pdb_hierarchy
    self.xray_structure = xray_structure
    # sanity check
    sites_cart_result = self.xray_structure.sites_cart().deep_copy()
    assert approx_equal(sites_cart_result,
      self.pdb_hierarchy.atoms().extract_xyz(), 1.e-4)
    #
    cs = self.xray_structure.crystal_symmetry()
    for i_chain, chain in enumerate(self.pdb_hierarchy.chains()):
      print("chain:", chain.id)
      selection = chain.atoms().extract_i_seq()
      ph = pdb_hierarchy.select(selection)
      #
      xrs_tmp = xray_structure.select(selection)
      box = mmtbx.utils.extract_box_around_model_and_map(
        xray_structure = xrs_tmp,
        map_data       = map_data,
        box_cushion    = 5,
       )
      #
      shift_back = [-box.shift_cart[i] for i in range(3)]
      ph_b       = box.pdb_hierarchy_box
      md_b       = box.map_box
      xrs_b      = box.xray_structure_box
      #
      minimized = refine_mz(
        map_data       = md_b,
        pdb_hierarchy  = ph_b,
        xray_structure = xrs_b,
        d_min          = d_min,
        macro_cycles   = macro_cycles,
        log            = None,
        prefix="  ")
      sites_cart_result = sites_cart_result.set_selected(
        selection, minimized.sites_cart_best+shift_back)
    self.xray_structure.set_sites_cart(sites_cart_result)
    self.pdb_hierarchy.adopt_xray_structure(self.xray_structure)


 *******************************************************************************


 *******************************************************************************
mmtbx/refinement/real_space/tst_aa_residue_axes_and_clusters.py
from __future__ import absolute_import, division, print_function
import iotbx.pdb
import mmtbx.monomer_library.server
import time
import mmtbx.refinement.real_space
from scitbx.array_family import flex

arg = """
ATOM      0  N   ARG A   1       8.883   8.163   7.325  1.00 11.00           N
ATOM      1  CA  ARG A   1       8.130   8.747   6.222  1.00 12.00           C
ATOM      2  C   ARG A   1       8.767   8.409   4.879  1.00 13.00           C
ATOM      3  O   ARG A   1       8.347   7.471   4.200  1.00 14.00           O
ATOM      4  CB  ARG A   1       8.027  10.265   6.388  1.00 15.00           C
ATOM      5  CG  ARG A   1       7.332  10.717   7.667  1.00 16.00           C
ATOM      6  CD  ARG A   1       5.837  10.424   7.640  1.00 17.00           C
ATOM      7  NE  ARG A   1       5.545   8.996   7.738  1.00 18.00           N
ATOM      8  CZ  ARG A   1       5.359   8.349   8.884  1.00 19.00           C
ATOM      9  NH1 ARG A   1       5.435   9.001  10.036  1.00 18.00           N
ATOM     10  NH2 ARG A   1       5.098   7.049   8.878  1.00 17.00           N
"""

arg_different_order = """
ATOM     10  NH2 ARG A   1       5.098   7.049   8.878  1.00 17.00           N
ATOM      2  C   ARG A   1       8.767   8.409   4.879  1.00 13.00           C
ATOM      4  CB  ARG A   1       8.027  10.265   6.388  1.00 15.00           C
ATOM      5  CG  ARG A   1       7.332  10.717   7.667  1.00 16.00           C
ATOM      6  CD  ARG A   1       5.837  10.424   7.640  1.00 17.00           C
ATOM      7  NE  ARG A   1       5.545   8.996   7.738  1.00 18.00           N
ATOM      0  N   ARG A   1       8.883   8.163   7.325  1.00 11.00           N
ATOM      1  CA  ARG A   1       8.130   8.747   6.222  1.00 12.00           C
ATOM      8  CZ  ARG A   1       5.359   8.349   8.884  1.00 19.00           C
ATOM      9  NH1 ARG A   1       5.435   9.001  10.036  1.00 18.00           N
ATOM      3  O   ARG A   1       8.347   7.471   4.200  1.00 14.00           O
"""

def get_object(pdb_str, backbone_sample, sort_atoms=True):
  pdb_inp = iotbx.pdb.input(source_info=None, lines = pdb_str)
  pdb_hierarchy = pdb_inp.construct_hierarchy(sort_atoms=sort_atoms)
  pdb_atoms = pdb_hierarchy.atoms()
  pdb_atoms.reset_i_seq()
  residue = pdb_hierarchy.only_residue()
  mon_lib_srv = mmtbx.monomer_library.server.server()
  t0=time.time()
  result = mmtbx.refinement.real_space.aa_residue_axes_and_clusters(
    residue         = residue,
    mon_lib_srv     = mon_lib_srv,
    backbone_sample = backbone_sample).clusters
  print(time.time()-t0)
  return result

def exercise_00():
  #
  aa = get_object(pdb_str = arg, backbone_sample=True)
  assert aa[0].vector == [1, 4, 5, 6, 7, flex.size_t([8, 9, 10])], aa[0].vector
  #
  aa = get_object(pdb_str = arg, backbone_sample=False)
  assert aa[0].vector == [1, 4, 5, 6, 7, flex.size_t([8, 9, 10])], aa[0].vector
  #
  aa = get_object(pdb_str = arg_different_order, backbone_sample=True, sort_atoms=False)
  assert aa[0].vector == [7, 2, 3, 4, 5, flex.size_t([0, 8, 9])], aa[0].vector


if (__name__ == "__main__"):
  t0 = time.time()
  exercise_00()
  print("Time: %6.2f" % (time.time()-t0))


 *******************************************************************************


 *******************************************************************************
mmtbx/refinement/real_space/tst_fit_residue_0.py
from __future__ import absolute_import, division, print_function
import time
import mmtbx.refinement.real_space.fit_residues
import mmtbx.refinement.real_space

pdb_answer = """\
CRYST1   15.538   12.841   13.194  90.00  90.00  90.00 P 1
ATOM    369  N   MSE A  67       6.949   5.583   8.194  1.00  9.89           N
ATOM    370  CA  MSE A  67       6.974   5.900   6.771  1.00 11.78           C
ATOM    375  C   MSE A  67       5.598   5.712   6.141  1.00  9.34           C
ATOM    376  O   MSE A  67       4.987   6.669   5.665  1.00 10.34           O
ATOM    371  CB  MSE A  67       8.007   5.034   6.048  1.00 20.39           C
ATOM    372  CG  MSE A  67       9.434   5.367   6.373  1.00 24.20           C
ATOM    373 SE   MSE A  67       9.847   7.212   6.188  1.00 45.90          SE
ATOM    374  CE  MSE A  67      11.413   7.254   7.196  1.00 13.67           C
TER
"""

pdb_poor0 = """\
CRYST1   15.538   12.841   13.194  90.00  90.00  90.00 P 1
ATOM    369  N   MSE A  67       6.949   5.583   8.194  1.00  9.89           N
ATOM    375  C   MSE A  67       5.598   5.712   6.141  1.00  9.34           C
ATOM    376  O   MSE A  67       5.000   6.673   5.657  1.00 10.34           O
ATOM    370  CA  MSE A  67       6.977   5.887   6.768  1.00 11.78           C
ATOM    371  CB  MSE A  67       7.997   5.000   6.052  1.00 20.39           C
ATOM    372  CG  MSE A  67       8.820   5.724   5.000  1.00 24.20           C
ATOM    373 SE   MSE A  67      10.538   6.343   5.685  1.00 45.90          Se
ATOM    374  CE  MSE A  67       9.911   7.841   6.765  1.00 13.67           C
TER
"""

def exercise(pdb_poor_str, i_pdb, d_min = 1.0, resolution_factor = 0.1):
  """
  Fit one non-standard residue: MSE.
  """
  #
  t = mmtbx.refinement.real_space.setup_test(
    pdb_answer        = pdb_answer,
    pdb_poor          = pdb_poor_str,
    i_pdb             = i_pdb,
    d_min             = d_min,
    residues          = ["MSE"],
    resolution_factor = resolution_factor)
  #
  result = mmtbx.refinement.real_space.fit_residues.run(
    pdb_hierarchy     = t.ph_poor,
    vdw_radii         = t.vdw,
    crystal_symmetry  = t.crystal_symmetry,
    map_data          = t.target_map,
    backbone_sample   = True,
    rotatable_hd      = t.rotatable_hd,
    rotamer_manager   = t.rotamer_manager,
    sin_cos_table     = t.sin_cos_table,
    mon_lib_srv       = t.mon_lib_srv)
  result.pdb_hierarchy.write_pdb_file(file_name = "refined_%s.pdb"%str(i_pdb))
  #
  mmtbx.refinement.real_space.check_sites_match(
    ph_answer  = t.ph_answer,
    ph_refined = result.pdb_hierarchy,
    tol        = 0.44)

if(__name__ == "__main__"):
  t0 = time.time()
  for i_pdb, pdb_poor_str in enumerate([pdb_poor0,]):
    exercise(
      pdb_poor_str = pdb_poor_str,
      i_pdb        = i_pdb)
  print("Time: %6.4f"%(time.time()-t0))


 *******************************************************************************


 *******************************************************************************
mmtbx/refinement/real_space/tst_fit_residue_0H.py
from __future__ import absolute_import, division, print_function
import time
import mmtbx.refinement.real_space.fit_residues
import mmtbx.refinement.real_space

pdb_answer = """\
CRYST1   15.538   12.841   13.194  90.00  90.00  90.00 P 1           0
SCALE1      0.064358  0.000000  0.000000        0.00000
SCALE2      0.000000  0.077876  0.000000        0.00000
SCALE3      0.000000  0.000000  0.075792        0.00000
ATOM   2006  N   MSE B  37       8.282   9.046   6.190  1.00 10.00           N
ATOM   2007  CA  MSE B  37       6.863   8.719   6.123  1.00 10.00           C
ATOM   2008  C   MSE B  37       6.057   9.906   5.608  1.00 10.00           C
ATOM   2009  O   MSE B  37       5.000   9.734   5.000  1.00 10.00           O
ATOM   2010  CB  MSE B  37       6.347   8.291   7.498  1.00 10.00           C
ATOM   2011  CG  MSE B  37       7.044   7.066   8.067  1.00 10.00           C
ATOM   2012 SE   MSE B  37       6.355   6.551   9.817  1.00 10.00          Se
ATOM   2013  CE  MSE B  37       7.491   5.000  10.145  1.00 10.00           C
ATOM      0  HA  MSE B  37       6.740   7.889   5.427  1.00 10.00           H
ATOM      0  HB2 MSE B  37       6.468   9.121   8.194  1.00 10.00           H
ATOM      0  HB3 MSE B  37       5.279   8.088   7.426  1.00 10.00           H
ATOM      0  HG2 MSE B  37       6.926   6.232   7.375  1.00 10.00           H
ATOM      0  HG3 MSE B  37       8.113   7.265   8.146  1.00 10.00           H
ATOM      0  HE1 MSE B  37       7.241   4.564  11.112  1.00 10.00           H
ATOM      0  HE2 MSE B  37       7.331   4.259   9.361  1.00 10.00           H
ATOM      0  HE3 MSE B  37       8.537   5.308  10.145  1.00 10.00           H
TER
"""

pdb_poor0 = """\
CRYST1   15.538   12.841   13.194  90.00  90.00  90.00 P 1
ATOM   2006  N   MSE B  37       8.282   9.046   6.190  1.00 10.00           N
ATOM   2007  CA  MSE B  37       6.863   8.719   6.123  1.00 10.00           C
ATOM   2008  C   MSE B  37       6.057   9.906   5.608  1.00 10.00           C
ATOM   2009  O   MSE B  37       5.000   9.734   5.000  1.00 10.00           O
ATOM   2010  CB  MSE B  37       6.347   8.291   7.498  1.00 10.00           C
ATOM   2011  CG  MSE B  37       4.889   7.862   7.506  1.00 10.00           C
ATOM   2012 SE   MSE B  37       4.305   7.207   9.247  1.00 10.00          Se
ATOM   2013  CE  MSE B  37       5.093   5.424   9.180  1.00 10.00           C
ATOM      9  HA  MSE B  37       6.740   7.889   5.427  1.00 10.00           H
ATOM     10  HB2 MSE B  37       6.960   7.467   7.864  1.00 10.00           H
ATOM     11  HB3 MSE B  37       6.475   9.118   8.196  1.00 10.00           H
ATOM     12  HG2 MSE B  37       4.265   8.705   7.212  1.00 10.00           H
ATOM     13  HG3 MSE B  37       4.740   7.081   6.760  1.00 10.00           H
ATOM     14  HE1 MSE B  37       4.863   4.890  10.101  1.00 10.00           H
ATOM     15  HE2 MSE B  37       4.682   4.876   8.331  1.00 10.00           H
ATOM     16  HE3 MSE B  37       6.174   5.507   9.069  1.00 10.00           H
TER
"""

def exercise(pdb_poor_str, i_pdb, d_min = 1.0, resolution_factor = 0.1):
  """
  Fit one non-standard residue: MSE with H.
  """
  #
  t = mmtbx.refinement.real_space.setup_test(
    pdb_answer        = pdb_answer,
    pdb_poor          = pdb_poor_str,
    i_pdb             = i_pdb,
    d_min             = d_min,
    residues          = ["MSE"],
    resolution_factor = resolution_factor)
  #
  result = mmtbx.refinement.real_space.fit_residues.run(
    pdb_hierarchy     = t.ph_poor,
    vdw_radii         = t.vdw,
    crystal_symmetry  = t.crystal_symmetry,
    map_data          = t.target_map,
    backbone_sample   = True,
    rotatable_hd      = t.rotatable_hd,
    rotamer_manager   = t.rotamer_manager,
    sin_cos_table     = t.sin_cos_table,
    mon_lib_srv       = t.mon_lib_srv)
  result.pdb_hierarchy.write_pdb_file(file_name = "refined_%s.pdb"%str(i_pdb))
  #
  mmtbx.refinement.real_space.check_sites_match(
    ph_answer  = t.ph_answer,
    ph_refined = result.pdb_hierarchy,
    tol        = 0.5)

if(__name__ == "__main__"):
  t0 = time.time()
  for i_pdb, pdb_poor_str in enumerate([pdb_poor0,]):
    exercise(
      pdb_poor_str = pdb_poor_str,
      i_pdb        = i_pdb)
  print("Time: %6.4f"%(time.time()-t0))


 *******************************************************************************


 *******************************************************************************
mmtbx/refinement/real_space/tst_fit_residue_1.py
from __future__ import absolute_import, division, print_function
import time
import mmtbx.refinement.real_space.fit_residues
import mmtbx.refinement.real_space

pdb_answer = """\
CRYST1   14.074   16.834   17.360  90.00  90.00  90.00 P 1
ATOM      1  N   ARG A  21       8.318  11.834   9.960  1.00 10.00           N
ATOM      2  CA  ARG A  21       7.146  11.154   9.422  1.00 10.00           C
ATOM      3  C   ARG A  21       6.012  11.120  10.440  1.00 10.00           C
ATOM      4  O   ARG A  21       5.000  10.449  10.235  1.00 10.00           O
ATOM      5  CB  ARG A  21       7.505   9.732   8.987  1.00 10.00           C
ATOM      6  CG  ARG A  21       7.923   8.820  10.129  0.70 20.00           C
ATOM      7  CD  ARG A  21       8.312   7.441   9.621  0.70 20.00           C
ATOM      8  NE  ARG A  21       8.694   6.545  10.708  0.70 20.00           N
ATOM      9  CZ  ARG A  21       7.839   5.785  11.385  0.70 20.00           C
ATOM     10  NH1 ARG A  21       6.546   5.811  11.088  0.70 20.00           N
ATOM     11  NH2 ARG A  21       8.275   5.000  12.360  0.70 20.00           N
TER
HETATM    1  U   U   B   1       9.074   7.848   5.000  1.00 10.00           U
TER
END
"""

pdb_poor0 = """\
CRYST1   14.074   16.834   17.360  90.00  90.00  90.00 P 1
ATOM      1  N   ARG A  21       8.318  11.834   9.960  1.00 10.00           N
ATOM      2  CA  ARG A  21       7.146  11.154   9.422  1.00 10.00           C
ATOM      3  C   ARG A  21       6.012  11.120  10.440  1.00 10.00           C
ATOM      4  O   ARG A  21       5.000  10.449  10.235  1.00 10.00           O
ATOM      5  CB  ARG A  21       7.505   9.732   8.987  1.00 10.00           C
ATOM      6  CG  ARG A  21       6.612   8.656   9.584  0.70 20.00           C
ATOM      7  CD  ARG A  21       6.020   7.767   8.502  0.70 20.00           C
ATOM      8  NE  ARG A  21       4.569   7.657   8.617  0.70 20.00           N
ATOM      9  CZ  ARG A  21       3.771   7.248   7.637  0.70 20.00           C
ATOM     10  NH1 ARG A  21       4.282   6.909   6.460  0.70 20.00           N
ATOM     11  NH2 ARG A  21       2.461   7.180   7.830  0.70 20.00           N
TER
HETATM    1  U   U   B   1       9.074   7.848   5.000  1.00 10.00           U
TER
"""

pdb_poor1 = """\
CRYST1   14.074   16.834   17.360  90.00  90.00  90.00 P 1
ATOM      1  N   ARG A  21       8.318  11.834   9.960  1.00 10.00           N
ATOM      2  CA  ARG A  21       7.248  10.924   9.570  1.00 10.00           C
ATOM      3  C   ARG A  21       6.012  11.120  10.440  1.00 10.00           C
ATOM      4  O   ARG A  21       5.064  10.337  10.375  1.00 10.00           O
ATOM      5  CB  ARG A  21       7.724   9.472   9.652  1.00 10.00           C
ATOM      6  CG  ARG A  21       8.797   9.112   8.637  1.00 10.00           C
ATOM      7  CD  ARG A  21       9.187   7.647   8.741  1.00 10.00           C
ATOM      8  NE  ARG A  21      10.266   7.301   7.820  1.00 10.00           N
ATOM      9  CZ  ARG A  21      10.871   6.118   7.790  1.00 10.00           C
ATOM     10  NH1 ARG A  21      10.505   5.162   8.634  1.00 10.00           N
ATOM     11  NH2 ARG A  21      11.844   5.891   6.920  1.00 10.00           N
TER
HETATM   12  U   U   B   1       9.074   7.848   5.000  1.00 10.00           U
TER
END
"""

pdb_poor2 = """\
CRYST1   14.074   16.834   17.360  90.00  90.00  90.00 P 1
ATOM      1  N   ARG A  21       8.318  11.834   9.960  1.00 10.00           N
ATOM      2  CA  ARG A  21       7.146  11.154   9.422  1.00 10.00           C
ATOM      3  C   ARG A  21       6.012  11.120  10.440  1.00 10.00           C
ATOM      4  O   ARG A  21       5.000  10.449  10.235  1.00 10.00           O
ATOM      5  CB  ARG A  21       7.505   9.732   8.987  1.00 10.00           C
ATOM      6  CG  ARG A  21       7.923   8.820  10.129  0.70 20.00           C
ATOM      7  CD  ARG A  21       8.312   7.441   9.621  0.70 20.00           C
ATOM      8  NE  ARG A  21       8.694   6.545  10.708  0.70 20.00           N
ATOM      9  CZ  ARG A  21       7.839   5.785  11.385  0.70 20.00           C
ATOM     10  NH1 ARG A  21       6.546   5.811  11.088  0.70 20.00           N
ATOM     11  NH2 ARG A  21       8.275   5.000  12.360  0.70 20.00           N
TER
HETATM    1  U   U   B   1       9.074   7.848   5.000  1.00 10.00           U
TER
END
"""

pdb_poor3 = """\
CRYST1   14.074   16.834   17.360  90.00  90.00  90.00 P 1
ATOM      1  N   ARG A  21       8.318  11.834   9.960  1.00 10.00           N
ATOM      2  CA  ARG A  21       7.146  11.154   9.422  1.00 10.00           C
ATOM      3  C   ARG A  21       6.012  11.120  10.440  1.00 10.00           C
ATOM      4  O   ARG A  21       5.000  10.449  10.235  1.00 10.00           O
ATOM      5  CB  ARG A  21       7.505   9.732   8.987  1.00 10.00           C
ATOM      6  CG  ARG A  21       8.469   9.666   7.814  0.70 20.00           C
ATOM      7  CD  ARG A  21       8.724   8.229   7.388  0.70 20.00           C
ATOM      8  NE  ARG A  21       9.667   8.147   6.277  0.70 20.00           N
ATOM      9  CZ  ARG A  21       9.331   8.301   5.000  0.70 20.00           C
ATOM     10  NH1 ARG A  21       8.070   8.545   4.668  0.70 20.00           N
ATOM     11  NH2 ARG A  21      10.255   8.208   4.054  0.70 20.00           N
TER      12      ARG A  21
HETATM    1  U   U   B   1       9.074   7.848   5.000  1.00 10.00           U
TER      14      ION B   1
END
"""

def exercise(pdb_poor_str, i_pdb, d_min = 1.0, resolution_factor = 0.1):
  """
  Fit one residue. There is a huge heavy atom nearby that overlaps with a
  plausible rotamer.
  """
  #
  t = mmtbx.refinement.real_space.setup_test(
    pdb_answer        = pdb_answer,
    pdb_poor          = pdb_poor_str,
    i_pdb             = i_pdb,
    d_min             = d_min,
    residues          = ["ARG"],
    resolution_factor = resolution_factor)
  #
  result = mmtbx.refinement.real_space.fit_residues.run(
    pdb_hierarchy     = t.ph_poor,
    vdw_radii         = t.vdw,
    crystal_symmetry  = t.crystal_symmetry,
    map_data          = t.target_map,
    backbone_sample   = True,
    rotatable_hd      = t.rotatable_hd,
    rotamer_manager   = t.rotamer_manager,
    sin_cos_table     = t.sin_cos_table,
    mon_lib_srv       = t.mon_lib_srv)
  result.pdb_hierarchy.write_pdb_file(file_name = "refined_%s.pdb"%str(i_pdb))
  #
  mmtbx.refinement.real_space.check_sites_match(
    ph_answer  = t.ph_answer,
    ph_refined = result.pdb_hierarchy,
    tol        = 0.1)

if(__name__ == "__main__"):
  t0 = time.time()
  for i_pdb, pdb_poor_str in enumerate(
    [pdb_poor0, pdb_poor1, pdb_poor2, pdb_poor3]):
    print(i_pdb, "-"*30)
    exercise(
      pdb_poor_str = pdb_poor_str,
      i_pdb        = i_pdb)
  print("Time: %6.4f"%(time.time()-t0))


 *******************************************************************************


 *******************************************************************************
mmtbx/refinement/real_space/tst_fit_residue_1H.py
from __future__ import absolute_import, division, print_function
import time
import mmtbx.refinement.real_space.fit_residues
import mmtbx.refinement.real_space

pdb_answer = """\
CRYST1   14.074   16.834   17.360  90.00  90.00  90.00 P 1
ATOM      1  N   ARG A  21       8.318  11.834   9.960  1.00 10.00           N
ATOM      2  CA  ARG A  21       7.146  11.154   9.422  1.00 10.00           C
ATOM      3  C   ARG A  21       6.012  11.120  10.440  1.00 10.00           C
ATOM      4  O   ARG A  21       5.000  10.449  10.235  1.00 10.00           O
ATOM      5  CB  ARG A  21       7.505   9.732   8.987  1.00 10.00           C
ATOM      6  CG  ARG A  21       7.923   8.820  10.129  0.70 20.00           C
ATOM      7  CD  ARG A  21       8.312   7.441   9.621  0.70 20.00           C
ATOM      8  NE  ARG A  21       8.694   6.545  10.708  0.70 20.00           N
ATOM      9  CZ  ARG A  21       7.839   5.785  11.385  0.70 20.00           C
ATOM     10  NH1 ARG A  21       6.546   5.811  11.088  0.70 20.00           N
ATOM     11  NH2 ARG A  21       8.275   5.000  12.360  0.70 20.00           N
ATOM      0  HA  ARG A  21       6.805  11.715   8.552  1.00 10.00           H   new
ATOM      0  HB2 ARG A  21       6.647   9.291   8.480  1.00 10.00           H   new
ATOM      0  HB3 ARG A  21       8.315   9.780   8.259  1.00 10.00           H   new
ATOM      0  HG2 ARG A  21       8.764   9.264  10.662  0.70 20.00           H   new
ATOM      0  HG3 ARG A  21       7.104   8.729  10.843  0.70 20.00           H   new
ATOM      0  HD2 ARG A  21       7.476   7.008   9.071  0.70 20.00           H   new
ATOM      0  HD3 ARG A  21       9.141   7.534   8.919  0.70 20.00           H   new
ATOM      0  HE  ARG A  21       9.680   6.499  10.965  0.70 20.00           H   new
ATOM      0 HH11 ARG A  21       6.207   6.415  10.339  0.70 20.00           H   new
ATOM      0 HH12 ARG A  21       5.891   5.227  11.609  0.70 20.00           H   new
ATOM      0 HH21 ARG A  21       9.268   4.978  12.592  0.70 20.00           H   new
ATOM      0 HH22 ARG A  21       7.617   4.418  12.878  0.70 20.00           H   new
TER
HETATM    1  U   U   B   1       9.074   7.848   5.000  1.00 10.00           U
TER
"""

pdb_poor0 = """\
CRYST1   14.074   16.834   17.360  90.00  90.00  90.00 P 1
ATOM      1  N   ARG A  21       8.318  11.834   9.960  1.00 10.00           N
ATOM      2  CA  ARG A  21       7.146  11.154   9.422  1.00 10.00           C
ATOM      3  C   ARG A  21       6.012  11.120  10.440  1.00 10.00           C
ATOM      4  O   ARG A  21       5.000  10.449  10.235  1.00 10.00           O
ATOM      5  CB  ARG A  21       7.505   9.732   8.987  1.00 10.00           C
ATOM      6  CG  ARG A  21       6.612   8.656   9.584  0.70 20.00           C
ATOM      7  CD  ARG A  21       6.020   7.767   8.502  0.70 20.00           C
ATOM      8  NE  ARG A  21       4.569   7.657   8.617  0.70 20.00           N
ATOM      9  CZ  ARG A  21       3.771   7.248   7.637  0.70 20.00           C
ATOM     10  NH1 ARG A  21       4.282   6.909   6.460  0.70 20.00           N
ATOM     11  NH2 ARG A  21       2.461   7.180   7.830  0.70 20.00           N
ATOM      0  HA  ARG A  21       6.805  11.715   8.552  1.00 10.00           H   new
ATOM      0  HB2 ARG A  21       7.451   9.672   7.900  1.00 10.00           H   new
ATOM      0  HB3 ARG A  21       8.538   9.528   9.267  1.00 10.00           H   new
ATOM      0  HG2 ARG A  21       7.188   8.048  10.282  0.70 20.00           H   new
ATOM      0  HG3 ARG A  21       5.809   9.122  10.155  0.70 20.00           H   new
ATOM      0  HD2 ARG A  21       6.276   8.169   7.522  0.70 20.00           H   new
ATOM      0  HD3 ARG A  21       6.465   6.774   8.565  0.70 20.00           H   new
ATOM      0  HE  ARG A  21       4.140   7.911   9.507  0.70 20.00           H   new
ATOM      0 HH11 ARG A  21       5.289   6.962   6.307  0.70 20.00           H   new
ATOM      0 HH12 ARG A  21       3.668   6.595   5.709  0.70 20.00           H   new
ATOM      0 HH21 ARG A  21       2.064   7.442   8.732  0.70 20.00           H   new
ATOM      0 HH22 ARG A  21       1.850   6.866   7.076  0.70 20.00           H   new
TER
HETATM   12  U   U   B   1       9.074   7.848   5.000  1.00 10.00           U
TER
"""

pdb_poor1 = """\
CRYST1   14.074   16.834   17.360  90.00  90.00  90.00 P 1
ATOM      1  N   ARG A  21       8.318  11.834   9.960  1.00 10.00           N
ATOM      2  CA  ARG A  21       7.248  10.924   9.570  1.00 10.00           C
ATOM      3  C   ARG A  21       6.012  11.120  10.440  1.00 10.00           C
ATOM      4  O   ARG A  21       5.064  10.337  10.375  1.00 10.00           O
ATOM      5  CB  ARG A  21       7.724   9.472   9.652  1.00 10.00           C
ATOM      6  CG  ARG A  21       8.797   9.112   8.637  1.00 10.00           C
ATOM      7  CD  ARG A  21       9.187   7.647   8.741  1.00 10.00           C
ATOM      8  NE  ARG A  21      10.266   7.301   7.820  1.00 10.00           N
ATOM      9  CZ  ARG A  21      10.871   6.118   7.790  1.00 10.00           C
ATOM     10  NH1 ARG A  21      10.505   5.162   8.634  1.00 10.00           N
ATOM     11  NH2 ARG A  21      11.844   5.891   6.920  1.00 10.00           N
ATOM      0  HA  ARG A  21       6.977  11.151   8.539  1.00 10.00           H   new
ATOM      0  HB2 ARG A  21       8.109   9.283  10.654  1.00 10.00           H   new
ATOM      0  HB3 ARG A  21       6.868   8.812   9.510  1.00 10.00           H   new
ATOM      0  HG2 ARG A  21       8.434   9.323   7.631  1.00 10.00           H   new
ATOM      0  HG3 ARG A  21       9.676   9.737   8.797  1.00 10.00           H   new
ATOM      0  HD2 ARG A  21       9.497   7.426   9.762  1.00 10.00           H   new
ATOM      0  HD3 ARG A  21       8.317   7.025   8.531  1.00 10.00           H   new
ATOM      0  HE  ARG A  21      10.575   8.012   7.158  1.00 10.00           H   new
ATOM      0 HH11 ARG A  21       9.758   5.334   9.307  1.00 10.00           H   new
ATOM      0 HH12 ARG A  21      10.970   4.255   8.610  1.00 10.00           H   new
ATOM      0 HH21 ARG A  21      12.130   6.625   6.272  1.00 10.00           H   new
ATOM      0 HH22 ARG A  21      12.307   4.982   6.898  1.00 10.00           H   new
TER
HETATM   12  U   U   B   1       9.074   7.848   5.000  1.00 10.00           U
TER
"""

pdb_poor2 = """\
CRYST1   14.074   16.834   17.360  90.00  90.00  90.00 P 1
ATOM      1  N   ARG A  21       8.318  11.834   9.960  1.00 10.00           N
ATOM      2  CA  ARG A  21       7.146  11.154   9.422  1.00 10.00           C
ATOM      3  C   ARG A  21       6.012  11.120  10.440  1.00 10.00           C
ATOM      4  O   ARG A  21       5.000  10.449  10.235  1.00 10.00           O
ATOM      5  CB  ARG A  21       7.505   9.732   8.987  1.00 10.00           C
ATOM      6  CG  ARG A  21       7.923   8.820  10.129  0.70 20.00           C
ATOM      7  CD  ARG A  21       8.312   7.441   9.621  0.70 20.00           C
ATOM      8  NE  ARG A  21       8.694   6.545  10.708  0.70 20.00           N
ATOM      9  CZ  ARG A  21       7.839   5.785  11.385  0.70 20.00           C
ATOM     10  NH1 ARG A  21       6.546   5.811  11.088  0.70 20.00           N
ATOM     11  NH2 ARG A  21       8.275   5.000  12.360  0.70 20.00           N
ATOM      0  HA  ARG A  21       6.805  11.715   8.552  1.00 10.00           H   new
ATOM      0  HB2 ARG A  21       6.647   9.291   8.480  1.00 10.00           H   new
ATOM      0  HB3 ARG A  21       8.315   9.780   8.259  1.00 10.00           H   new
ATOM      0  HG2 ARG A  21       8.764   9.264  10.662  0.70 20.00           H   new
ATOM      0  HG3 ARG A  21       7.104   8.729  10.843  0.70 20.00           H   new
ATOM      0  HD2 ARG A  21       7.476   7.008   9.071  0.70 20.00           H   new
ATOM      0  HD3 ARG A  21       9.141   7.534   8.919  0.70 20.00           H   new
ATOM      0  HE  ARG A  21       9.680   6.499  10.965  0.70 20.00           H   new
ATOM      0 HH11 ARG A  21       6.207   6.415  10.339  0.70 20.00           H   new
ATOM      0 HH12 ARG A  21       5.891   5.227  11.609  0.70 20.00           H   new
ATOM      0 HH21 ARG A  21       9.268   4.978  12.592  0.70 20.00           H   new
ATOM      0 HH22 ARG A  21       7.617   4.418  12.878  0.70 20.00           H   new
TER
HETATM   12  U   U   B   1       9.074   7.848   5.000  1.00 10.00           U
TER
"""

pdb_poor3 = """\
CRYST1   14.074   16.834   17.360  90.00  90.00  90.00 P 1
ATOM      1  N   ARG A  21       8.318  11.834   9.960  1.00 10.00           N
ATOM      2  CA  ARG A  21       7.146  11.154   9.422  1.00 10.00           C
ATOM      3  C   ARG A  21       6.012  11.120  10.440  1.00 10.00           C
ATOM      4  O   ARG A  21       5.000  10.449  10.235  1.00 10.00           O
ATOM      5  CB  ARG A  21       7.505   9.732   8.987  1.00 10.00           C
ATOM      6  CG  ARG A  21       8.469   9.666   7.814  0.70 20.00           C
ATOM      7  CD  ARG A  21       8.724   8.229   7.388  0.70 20.00           C
ATOM      8  NE  ARG A  21       9.667   8.147   6.277  0.70 20.00           N
ATOM      9  CZ  ARG A  21       9.331   8.301   5.000  0.70 20.00           C
ATOM     10  NH1 ARG A  21       8.070   8.545   4.668  0.70 20.00           N
ATOM     11  NH2 ARG A  21      10.255   8.208   4.054  0.70 20.00           N
ATOM      0  HA  ARG A  21       6.805  11.715   8.552  1.00 10.00           H   new
ATOM      0  HB2 ARG A  21       7.944   9.204   9.834  1.00 10.00           H   new
ATOM      0  HB3 ARG A  21       6.590   9.203   8.721  1.00 10.00           H   new
ATOM      0  HG2 ARG A  21       8.062  10.230   6.974  0.70 20.00           H   new
ATOM      0  HG3 ARG A  21       9.412  10.139   8.089  0.70 20.00           H   new
ATOM      0  HD2 ARG A  21       9.112   7.663   8.235  0.70 20.00           H   new
ATOM      0  HD3 ARG A  21       7.782   7.764   7.099  0.70 20.00           H   new
ATOM      0  HE  ARG A  21      10.646   7.960   6.494  0.70 20.00           H   new
ATOM      0 HH11 ARG A  21       7.356   8.615   5.393  0.70 20.00           H   new
ATOM      0 HH12 ARG A  21       7.814   8.663   3.688  0.70 20.00           H   new
ATOM      0 HH21 ARG A  21      11.225   8.018   4.306  0.70 20.00           H   new
ATOM      0 HH22 ARG A  21       9.996   8.326   3.075  0.70 20.00           H   new
TER
HETATM   12  U   U   B   1       9.074   7.848   5.000  1.00 10.00           U
TER
"""

def exercise(pdb_poor_str, i_pdb, d_min = 1.0, resolution_factor = 0.1):
  """
  Fit one residue. There is a huge heavy atom nearby that overlaps with a
  plausible rotamer. With H.
  """
  #
  t = mmtbx.refinement.real_space.setup_test(
    pdb_answer        = pdb_answer,
    pdb_poor          = pdb_poor_str,
    i_pdb             = i_pdb,
    d_min             = d_min,
    residues          = ["ARG"],
    resolution_factor = resolution_factor)
  #
  result = mmtbx.refinement.real_space.fit_residues.run(
    pdb_hierarchy     = t.ph_poor,
    vdw_radii         = t.vdw,
    crystal_symmetry  = t.crystal_symmetry,
    map_data          = t.target_map,
    backbone_sample   = True,
    rotatable_hd      = t.rotatable_hd,
    rotamer_manager   = t.rotamer_manager,
    sin_cos_table     = t.sin_cos_table,
    mon_lib_srv       = t.mon_lib_srv)
  result.pdb_hierarchy.write_pdb_file(file_name = "refined_%s.pdb"%str(i_pdb))
  #
  mmtbx.refinement.real_space.check_sites_match(
    ph_answer  = t.ph_answer,
    ph_refined = result.pdb_hierarchy,
    tol        = 0.15)

if(__name__ == "__main__"):
  t0 = time.time()
  for i_pdb, pdb_poor_str in enumerate(
                               [pdb_poor0, pdb_poor1, pdb_poor2, pdb_poor3]):
    exercise(
      pdb_poor_str = pdb_poor_str,
      i_pdb        = i_pdb)
  print("Time: %6.4f"%(time.time()-t0))


 *******************************************************************************


 *******************************************************************************
mmtbx/refinement/real_space/tst_fit_residue_2.py
from __future__ import absolute_import, division, print_function
import time
import mmtbx.refinement.real_space.fit_residues
import mmtbx.refinement.real_space

pdb_answer = """\
CRYST1   14.074   16.834   17.360  90.00  90.00  90.00 P 1
ATOM      1  N   ARG A  21       8.318  11.834   9.960  1.00 10.00           N
ATOM      2  CA  ARG A  21       7.146  11.154   9.422  1.00 10.00           C
ATOM      3  C   ARG A  21       6.012  11.120  10.440  1.00 10.00           C
ATOM      4  O   ARG A  21       5.000  10.449  10.235  1.00 10.00           O
ATOM      5  CB  ARG A  21       7.505   9.732   8.987  1.00 10.00           C
ATOM      6  CG  ARG A  21       7.923   8.820  10.129  0.70 20.00           C
ATOM      7  CD  ARG A  21       8.312   7.441   9.621  0.70 20.00           C
ATOM      8  NE  ARG A  21       8.694   6.545  10.708  0.70 20.00           N
ATOM      9  CZ  ARG A  21       7.839   5.785  11.385  0.70 20.00           C
ATOM     10  NH1 ARG A  21       6.546   5.811  11.088  0.70 20.00           N
ATOM     11  NH2 ARG A  21       8.275   5.000  12.360  0.70 20.00           N
TER
HETATM    1  U   U   B   1       9.074   7.848   5.000  1.00 10.00           U
TER
END
"""

pdb_poor1 = """\
CRYST1   14.074   16.834   17.360  90.00  90.00  90.00 P 1
ATOM      1  N   ARG A  21       8.318  11.834   9.960  1.00 10.00           N
ATOM      2  CA  ARG A  21       7.248  10.924   9.570  1.00 10.00           C
ATOM      3  C   ARG A  21       6.012  11.120  10.440  1.00 10.00           C
ATOM      4  O   ARG A  21       5.064  10.337  10.375  1.00 10.00           O
ATOM      5  CB  ARG A  21       7.724   9.472   9.652  1.00 10.00           C
ATOM      6  CG  ARG A  21       8.797   9.112   8.637  1.00 10.00           C
ATOM      7  CD  ARG A  21       9.187   7.647   8.741  1.00 10.00           C
ATOM      8  NE  ARG A  21      10.266   7.301   7.820  1.00 10.00           N
ATOM      9  CZ  ARG A  21      10.871   6.118   7.790  1.00 10.00           C
ATOM     10  NH1 ARG A  21      10.505   5.162   8.634  1.00 10.00           N
ATOM     11  NH2 ARG A  21      11.844   5.891   6.920  1.00 10.00           N
TER
END
"""

pdb_poor2 = """\
CRYST1   14.074   16.834   17.360  90.00  90.00  90.00 P 1
ATOM      1  N   ARG A  21       8.318  11.834   9.960  1.00 10.00           N
ATOM      2  CA  ARG A  21       7.146  11.154   9.422  1.00 10.00           C
ATOM      3  C   ARG A  21       6.012  11.120  10.440  1.00 10.00           C
ATOM      4  O   ARG A  21       5.000  10.449  10.235  1.00 10.00           O
ATOM      5  CB  ARG A  21       7.505   9.732   8.987  1.00 10.00           C
ATOM      6  CG  ARG A  21       7.923   8.820  10.129  0.70 20.00           C
ATOM      7  CD  ARG A  21       8.312   7.441   9.621  0.70 20.00           C
ATOM      8  NE  ARG A  21       8.694   6.545  10.708  0.70 20.00           N
ATOM      9  CZ  ARG A  21       7.839   5.785  11.385  0.70 20.00           C
ATOM     10  NH1 ARG A  21       6.546   5.811  11.088  0.70 20.00           N
ATOM     11  NH2 ARG A  21       8.275   5.000  12.360  0.70 20.00           N
TER
END
"""

pdb_poor3 = """\
CRYST1   14.074   16.834   17.360  90.00  90.00  90.00 P 1
ATOM      1  N   ARG A  21       8.318  11.834   9.960  1.00 10.00           N
ATOM      2  CA  ARG A  21       7.146  11.154   9.422  1.00 10.00           C
ATOM      3  C   ARG A  21       6.012  11.120  10.440  1.00 10.00           C
ATOM      4  O   ARG A  21       5.000  10.449  10.235  1.00 10.00           O
ATOM      5  CB  ARG A  21       7.505   9.732   8.987  1.00 10.00           C
ATOM      6  CG  ARG A  21       8.469   9.666   7.814  0.70 20.00           C
ATOM      7  CD  ARG A  21       8.724   8.229   7.388  0.70 20.00           C
ATOM      8  NE  ARG A  21       9.667   8.147   6.277  0.70 20.00           N
ATOM      9  CZ  ARG A  21       9.331   8.301   5.000  0.70 20.00           C
ATOM     10  NH1 ARG A  21       8.070   8.545   4.668  0.70 20.00           N
ATOM     11  NH2 ARG A  21      10.255   8.208   4.054  0.70 20.00           N
TER      12      ARG A  21
END
"""

def exercise(pdb_poor_str, i_pdb, d_min = 1.0, resolution_factor = 0.1):
  """
  Fit one residue. There is a huge heavy atom nearby that overlaps with a
  plausible rotamer.
  Show importance of map truncaiton.
  """
  #
  t = mmtbx.refinement.real_space.setup_test(
    pdb_answer        = pdb_answer,
    pdb_poor          = pdb_poor_str,
    i_pdb             = i_pdb,
    d_min             = d_min,
    residues          = ["ARG"],
    resolution_factor = resolution_factor)
  #
  matching_selection = t.ph_answer.atom_selection_cache().selection(
    string = "not element U")
  #
  result = mmtbx.refinement.real_space.fit_residues.run(
    pdb_hierarchy     = t.ph_poor,
    vdw_radii         = t.vdw,
    crystal_symmetry  = t.crystal_symmetry,
    map_data          = t.target_map,
    backbone_sample   = True,
    rotatable_hd      = t.rotatable_hd,
    rotamer_manager   = t.rotamer_manager,
    sin_cos_table     = t.sin_cos_table,
    mon_lib_srv       = t.mon_lib_srv)
  result.pdb_hierarchy.write_pdb_file(file_name = "refined_%s.pdb"%str(i_pdb))
  #
  mmtbx.refinement.real_space.check_sites_match(
    ph_answer  = t.ph_answer.select(matching_selection),
    ph_refined = result.pdb_hierarchy,
    tol        = 0.1)

if(__name__ == "__main__"):
  t0 = time.time()
  for i_pdb, pdb_poor_str in enumerate([pdb_poor1, pdb_poor2, pdb_poor3]):
    print(i_pdb, "-"*30)
    exercise(
      pdb_poor_str = pdb_poor_str,
      i_pdb        = i_pdb)
  print("Time: %6.4f"%(time.time()-t0))


 *******************************************************************************


 *******************************************************************************
mmtbx/refinement/real_space/tst_fit_residue_3.py
from __future__ import absolute_import, division, print_function
import time
import mmtbx.refinement.real_space.fit_residues
import mmtbx.refinement.real_space

pdb_answer = """\
CRYST1   14.074   16.834   17.360  90.00  90.00  90.00 P 1
ATOM      1  N   ARG A  21       8.318  11.834   9.960  1.00 10.00           N
ATOM      2  CA  ARG A  21       7.146  11.154   9.422  1.00 10.00           C
ATOM      3  C   ARG A  21       6.012  11.120  10.440  1.00 10.00           C
ATOM      4  O   ARG A  21       5.000  10.449  10.235  1.00 10.00           O
ATOM      5  CB  ARG A  21       7.505   9.732   8.987  1.00 10.00           C
ATOM      6  CG  ARG A  21       7.923   8.820  10.129  0.30 20.00           C
ATOM      7  CD  ARG A  21       8.312   7.441   9.621  0.30 20.00           C
ATOM      8  NE  ARG A  21       8.694   6.545  10.708  0.30 20.00           N
ATOM      9  CZ  ARG A  21       7.839   5.785  11.385  0.30 20.00           C
ATOM     10  NH1 ARG A  21       6.546   5.811  11.088  0.30 20.00           N
ATOM     11  NH2 ARG A  21       8.275   5.000  12.360  0.30 20.00           N
TER
END
"""

pdb_poor = """\
CRYST1   14.074   16.834   17.360  90.00  90.00  90.00 P 1
ATOM      1  N   ARG A  21       8.318  11.834   9.960  1.00 10.00           N
ATOM      2  CA  ARG A  21       7.248  10.924   9.570  1.00 10.00           C
ATOM      3  C   ARG A  21       6.012  11.120  10.440  1.00 10.00           C
ATOM      4  O   ARG A  21       5.064  10.337  10.375  1.00 10.00           O
ATOM      5  CB  ARG A  21       7.724   9.472   9.652  1.00 10.00           C
ATOM      6  CG  ARG A  21       8.797   9.112   8.637  1.00 10.00           C
ATOM      7  CD  ARG A  21       9.187   7.647   8.741  1.00 10.00           C
ATOM      8  NE  ARG A  21      10.266   7.301   7.820  1.00 10.00           N
ATOM      9  CZ  ARG A  21      10.871   6.118   7.790  1.00 10.00           C
ATOM     10  NH1 ARG A  21      10.505   5.162   8.634  1.00 10.00           N
ATOM     11  NH2 ARG A  21      11.844   5.891   6.920  1.00 10.00           N
TER
END
"""

pdb_poor_for_map = """\
CRYST1   14.074   16.834   17.360  90.00  90.00  90.00 P 1
ATOM      1  N   ARG A  21       8.318  11.834   9.960  1.00 10.00           N
ATOM      2  CA  ARG A  21       7.146  11.154   9.422  1.00 10.00           C
ATOM      3  C   ARG A  21       6.012  11.120  10.440  1.00 10.00           C
ATOM      4  O   ARG A  21       5.000  10.449  10.235  1.00 10.00           O
ATOM      5  CB  ARG A  21       7.505   9.732   8.987  1.00 10.00           C
ATOM      6  CG  ARG A  21       7.923   8.820  10.129  0.30 20.00           C
ATOM      7  CD  ARG A  21       8.312   7.441   9.621  0.30 20.00           C
ATOM      8  NE  ARG A  21       8.694   6.545  10.708  0.30 20.00           N
ATOM      9  CZ  ARG A  21       7.839   5.785  11.385  0.30 20.00           C
ATOM     10  NH1 ARG A  21       6.546   5.811  11.088  0.30 20.00           N
ATOM     11  NH2 ARG A  21       8.275   5.000  12.360  0.30 20.00           N
TER
ATOM      9  O   HOH B  21       8.776  10.791   4.311  1.00  5.00           O
ATOM     10  O   HOH B  22       7.708  11.548   4.090  1.00  5.00           O
ATOM     11  O   HOH B  23       9.698  10.663   3.367  1.00  5.00           O
TER
END
"""

def exercise(d_min = 1.0, resolution_factor = 0.1):
  """
  Fit one residue having weak side chain density. There is a blob nearby that
  overlaps with a plausible rotamer.
  """
 #
  t = mmtbx.refinement.real_space.setup_test(
    pdb_answer        = pdb_answer,
    pdb_poor          = pdb_poor,
    i_pdb             = 0,
    d_min             = d_min,
    resolution_factor = resolution_factor,
    residues          = ["ARG"],
    pdb_for_map       = pdb_poor_for_map)
  #
  result = mmtbx.refinement.real_space.fit_residues.run(
    pdb_hierarchy     = t.ph_poor,
    vdw_radii         = t.vdw,
    crystal_symmetry  = t.crystal_symmetry,
    map_data          = t.target_map,
    backbone_sample   = True,
    rotatable_hd      = t.rotatable_hd,
    rotamer_manager   = t.rotamer_manager,
    sin_cos_table     = t.sin_cos_table,
    mon_lib_srv       = t.mon_lib_srv)
  result.pdb_hierarchy.write_pdb_file(file_name = "refined_%s.pdb"%str(0))
  #
  mmtbx.refinement.real_space.check_sites_match(
    ph_answer  = t.ph_answer,
    ph_refined = result.pdb_hierarchy,
    tol        = 0.15)

if(__name__ == "__main__"):
  t0 = time.time()
  exercise()
  print("Time: %6.4f"%(time.time()-t0))


 *******************************************************************************


 *******************************************************************************
mmtbx/refinement/real_space/tst_fit_residue_4.py
from __future__ import absolute_import, division, print_function
import time
import mmtbx.refinement.real_space.fit_residues
import mmtbx.refinement.real_space

pdb_answer = """\
CRYST1   14.074   16.834   17.360  90.00  90.00  90.00 P 1
ATOM      1  N   ARG A  21       8.318  11.834   9.960  1.00 10.00           N
ATOM      2  CA  ARG A  21       7.146  11.154   9.422  1.00 10.00           C
ATOM      3  C   ARG A  21       6.012  11.120  10.440  1.00 10.00           C
ATOM      4  O   ARG A  21       5.000  10.449  10.235  1.00 10.00           O
ATOM      5  CB  ARG A  21       7.505   9.732   8.987  1.00 10.00           C
ATOM      6  CG  ARG A  21       7.923   8.820  10.129  0.30 20.00           C
ATOM      7  CD  ARG A  21       8.312   7.441   9.621  0.30 20.00           C
ATOM      8  NE  ARG A  21       8.694   6.545  10.708  0.30 20.00           N
ATOM      9  CZ  ARG A  21       7.839   5.785  11.385  0.30 20.00           C
ATOM     10  NH1 ARG A  21       6.546   5.811  11.088  0.30 20.00           N
ATOM     11  NH2 ARG A  21       8.275   5.000  12.360  0.30 20.00           N
TER
ATOM      9  O   HOH B  21       8.776  10.791   4.311  1.00  5.00           O
ATOM     10  O   HOH B  22       7.708  11.548   4.090  1.00  5.00           O
ATOM     11  O   HOH B  23       9.698  10.663   3.367  1.00  5.00           O
TER
END
"""

pdb_poor = """\
CRYST1   14.074   16.834   17.360  90.00  90.00  90.00 P 1
ATOM      1  N   ARG A  21       8.318  11.834   9.960  1.00 10.00           N
ATOM      2  CA  ARG A  21       7.248  10.924   9.570  1.00 10.00           C
ATOM      3  C   ARG A  21       6.012  11.120  10.440  1.00 10.00           C
ATOM      4  O   ARG A  21       5.064  10.337  10.375  1.00 10.00           O
ATOM      5  CB  ARG A  21       7.724   9.472   9.652  1.00 10.00           C
ATOM      6  CG  ARG A  21       8.797   9.112   8.637  1.00 10.00           C
ATOM      7  CD  ARG A  21       9.187   7.647   8.741  1.00 10.00           C
ATOM      8  NE  ARG A  21      10.266   7.301   7.820  1.00 10.00           N
ATOM      9  CZ  ARG A  21      10.871   6.118   7.790  1.00 10.00           C
ATOM     10  NH1 ARG A  21      10.505   5.162   8.634  1.00 10.00           N
ATOM     11  NH2 ARG A  21      11.844   5.891   6.920  1.00 10.00           N
TER
ATOM      9  O   HOH B  21       8.776  10.791   4.311  1.00  5.00           O
ATOM     10  O   HOH B  22       7.708  11.548   4.090  1.00  5.00           O
ATOM     11  O   HOH B  23       9.698  10.663   3.367  1.00  5.00           O
TER
END
"""

def exercise(d_min = 1.0, resolution_factor = 0.1):
  """
  Fit one residue having weak side chain density. There is a blob nearby that
  overlaps with a plausible rotamer.
  """
  #
  t = mmtbx.refinement.real_space.setup_test(
    pdb_answer        = pdb_answer,
    pdb_poor          = pdb_poor,
    i_pdb             = 0,
    d_min             = d_min,
    residues          = ["ARG"],
    resolution_factor = resolution_factor)
  #
  result = mmtbx.refinement.real_space.fit_residues.run(
    pdb_hierarchy     = t.ph_poor,
    vdw_radii         = t.vdw,
    crystal_symmetry  = t.crystal_symmetry,
    map_data          = t.target_map,
    backbone_sample   = True,
    rotatable_hd      = t.rotatable_hd,
    rotamer_manager   = t.rotamer_manager,
    sin_cos_table     = t.sin_cos_table,
    mon_lib_srv       = t.mon_lib_srv)
  result.pdb_hierarchy.write_pdb_file(file_name = "refined_%s.pdb"%str(0))
  #
  mmtbx.refinement.real_space.check_sites_match(
    ph_answer  = t.ph_answer,
    ph_refined = result.pdb_hierarchy,
    tol        = 0.3)

if(__name__ == "__main__"):
  t0 = time.time()
  exercise()
  print("Time: %6.4f"%(time.time()-t0))


 *******************************************************************************


 *******************************************************************************
mmtbx/refinement/real_space/tst_fit_residue_5.py
from __future__ import absolute_import, division, print_function
import time
import mmtbx.refinement.real_space
import mmtbx.refinement.real_space.fit_residue
import iotbx.pdb

pdb_answer = """\
CRYST1   14.230   10.991   17.547  90.00  90.00  90.00 P 1
ATOM     43  N   GLY A   8       3.000   7.369   9.591  1.00 10.00           N
ATOM     44  CA  GLY A   8       4.304   7.980   9.410  1.00 10.00           C
ATOM     45  C   GLY A   8       5.375   6.966   9.058  1.00 10.00           C
ATOM     46  O   GLY A   8       5.074   5.814   8.745  1.00 10.00           O
ATOM     47  N   TYR A   9       6.631   7.398   9.110  1.00 10.00           N
ATOM     48  CA  TYR A   9       7.755   6.524   8.796  1.00 10.00           C
ATOM     49  C   TYR A   9       8.787   6.527   9.918  1.00 10.00           C
ATOM     50  O   TYR A   9       9.205   7.585  10.387  1.00 10.00           O
ATOM     51  CB  TYR A   9       8.410   6.945   7.478  1.00 10.00           C
ATOM     52  CG  TYR A   9       7.484   6.880   6.284  1.00 10.00           C
ATOM     54  CD1 TYR A   9       6.750   7.991   5.889  1.00 10.00           C
ATOM     53  CD2 TYR A   9       7.345   5.709   5.552  1.00 10.00           C
ATOM     56  CE1 TYR A   9       5.903   7.937   4.798  1.00 10.00           C
ATOM     55  CE2 TYR A   9       6.500   5.645   4.459  1.00 10.00           C
ATOM     57  CZ  TYR A   9       5.782   6.761   4.087  1.00 10.00           C
ATOM     58  OH  TYR A   9       4.940   6.702   3.000  1.00 10.00           O
ATOM     59  N   ASN A  10       9.193   5.336  10.345  1.00 10.00           N
ATOM     60  CA  ASN A  10      10.177   5.199  11.413  1.00 10.00           C
ATOM     61  C   ASN A  10      11.230   4.143  11.093  1.00 10.00           C
ATOM     62  O   ASN A  10      10.900   3.000  10.778  1.00 10.00           O
ATOM     63  CB  ASN A  10       9.486   4.870  12.738  1.00 10.00           C
ATOM     64  CG  ASN A  10      10.465   4.730  13.887  1.00 10.00           C
ATOM     65  OD1 ASN A  10      10.947   3.635  14.178  1.00 10.00           O
ATOM     66  ND2 ASN A  10      10.766   5.843  14.547  1.00 10.00           N
TER
END
"""

pdb_poor = """\
CRYST1   14.230   10.991   17.547  90.00  90.00  90.00 P 1
ATOM     43  N   GLY A   8       3.000   7.369   9.591  1.00 10.00           N
ATOM     44  CA  GLY A   8       4.304   7.980   9.410  1.00 10.00           C
ATOM     45  C   GLY A   8       5.375   6.966   9.058  1.00 10.00           C
ATOM     46  O   GLY A   8       5.074   5.814   8.745  1.00 10.00           O
ATOM     47  N   TYR A   9      10.261   7.310   2.887  1.00 10.00           N
ATOM     48  CA  TYR A   9      10.362   7.269   4.341  1.00 10.00           C
ATOM     49  C   TYR A   9      11.382   6.231   4.795  1.00 10.00           C
ATOM     50  O   TYR A   9      11.354   5.084   4.350  1.00 10.00           O
ATOM     51  CB  TYR A   9       8.996   6.971   4.965  1.00 10.00           C
ATOM     52  CG  TYR A   9       9.029   6.816   6.469  1.00 10.00           C
ATOM     53  CD1 TYR A   9       9.116   7.925   7.299  1.00 10.00           C
ATOM     54  CD2 TYR A   9       8.973   5.559   7.058  1.00 10.00           C
ATOM     55  CE1 TYR A   9       9.148   7.788   8.675  1.00 10.00           C
ATOM     56  CE2 TYR A   9       9.004   5.412   8.432  1.00 10.00           C
ATOM     57  CZ  TYR A   9       9.091   6.530   9.235  1.00 10.00           C
ATOM     58  OH  TYR A   9       9.122   6.388  10.604  1.00 10.00           O
ATOM     59  N   ASN A  10       9.193   5.336  10.345  1.00 10.00           N
ATOM     60  CA  ASN A  10      10.177   5.199  11.413  1.00 10.00           C
ATOM     61  C   ASN A  10      11.230   4.143  11.093  1.00 10.00           C
ATOM     62  O   ASN A  10      10.900   3.000  10.778  1.00 10.00           O
ATOM     63  CB  ASN A  10       9.486   4.870  12.738  1.00 10.00           C
ATOM     64  CG  ASN A  10      10.465   4.730  13.887  1.00 10.00           C
ATOM     65  OD1 ASN A  10      10.947   3.635  14.178  1.00 10.00           O
ATOM     66  ND2 ASN A  10      10.766   5.843  14.547  1.00 10.00           N
TER      25      ASN A  10
END
"""

def exercise(pdb_poor_str, i_pdb = 0, d_min = 1.0, resolution_factor = 0.25):
  # Fit one residue in many-residues model
  #
  t = mmtbx.refinement.real_space.setup_test(
    pdb_answer        = pdb_answer,
    pdb_poor          = pdb_poor_str,
    i_pdb             = i_pdb,
    d_min             = d_min,
    residues          = ["GLY","TYR","ASN"],
    resolution_factor = resolution_factor)
  #
  get_class = iotbx.pdb.common_residue_names_get_class
  cmv = mmtbx.refinement.real_space.common_map_values(
    pdb_hierarchy = t.ph_poor,
    unit_cell     = t.xrs_poor.crystal_symmetry().unit_cell(),
    map_data      = t.target_map)
  for model in t.ph_poor.models():
    for chain in model.chains():
      for residue in chain.only_conformer().residues():
        if(get_class(residue.resname) == "common_amino_acid" and
           residue.resseq_as_int()==9): # take TYR9
          t0 = time.time()
          grm = t.model_poor.get_restraints_manager().geometry
          ro = mmtbx.refinement.real_space.fit_residue.run_with_minimization(
            target_map      = t.target_map,
            vdw_radii       = t.vdw,
            residue         = residue,
            xray_structure  = t.xrs_poor,
            mon_lib_srv     = t.mon_lib_srv,
            rotamer_manager = t.rotamer_manager,
            real_space_gradients_delta  = d_min*resolution_factor,
            cmv = cmv,
            geometry_restraints_manager = grm)
          sites_final = residue.atoms().extract_xyz()
          t1 = time.time()-t0
  #
  t.ph_poor.adopt_xray_structure(ro.xray_structure)
  t.ph_poor.write_pdb_file(file_name = "refined.pdb")
  #
  mmtbx.refinement.real_space.check_sites_match(
    ph_answer          = t.ph_answer,
    ph_refined         = t.ph_poor,
    exclude_atom_names = ["CD1","CD2","CE1","CE2"],
    tol                = 0.4)

if(__name__ == "__main__"):
  exercise(pdb_poor_str = pdb_poor, resolution_factor=0.2)


 *******************************************************************************


 *******************************************************************************
mmtbx/refinement/real_space/tst_fit_residue_6.py
from __future__ import absolute_import, division, print_function
import time
import mmtbx.refinement.real_space.fit_residues
import mmtbx.refinement.real_space

pdb_answer = """\
CRYST1   14.074   16.834   17.360  90.00  90.00  90.00 P 1
ATOM      1  N   ARG A  21       8.318  11.834   9.960  1.00 10.00           N
ATOM      2  CA  ARG A  21       7.171  11.092   9.451  1.00 10.00           C
ATOM      3  C   ARG A  21       6.012  11.120  10.440  1.00 10.00           C
ATOM      4  O   ARG A  21       5.017  10.416  10.266  1.00 10.00           O
ATOM      5  CB  ARG A  21       7.564   9.645   9.143  1.00 10.00           C
ATOM      6  CG  ARG A  21       8.560   9.501   8.003  1.00 10.00           C
ATOM      7  CD  ARG A  21       8.125  10.300   6.785  1.00 10.00           C
ATOM      8  NE  ARG A  21       8.926   9.982   5.607  1.00 10.00           N
ATOM      9  CZ  ARG A  21       8.893  10.674   4.473  1.00 10.00           C
ATOM     10  NH1 ARG A  21       8.093  11.727   4.359  1.00 10.00           N
ATOM     11  NH2 ARG A  21       9.655  10.313   3.451  1.00 10.00           N
END
"""

pdb_for_map = """
CRYST1   14.074   16.834   17.360  90.00  90.00  90.00 P 1
ATOM      1  O   HOH S   0       8.318  11.834   9.960  1.00 10.00           O
ATOM      2  O   HOH S   1       7.171  11.092   9.451  1.00 10.00           O
ATOM      3  O   HOH S   2       6.012  11.120  10.440  1.00 10.00           O
ATOM      4  O   HOH S   3       5.017  10.416  10.266  1.00 10.00           O
ATOM      5  O   HOH S   4       7.564   9.645   9.143  1.00 10.00           O
ATOM      6  O   HOH S   5       8.560   9.501   8.003  1.00 10.00           O
ATOM      7  O   HOH S   6       8.125  10.300   6.785  1.00 10.00           O
ATOM      8  O   HOH S   7       8.926   9.982   5.607  1.00 10.00           O
ATOM      9  O   HOH S   8       8.893  10.674   4.473  1.00 10.00           O
ATOM     10  O   HOH S   9       8.093  11.727   4.359  1.00 10.00           O
ATOM     11  O   HOH S  10       9.655  10.313   3.451  1.00 10.00           O
TER
"""

pdb_poor = """\
CRYST1   14.074   16.834   17.360  90.00  90.00  90.00 P 1
ATOM      1  N   ARG A  21       8.318  11.834   9.960  1.00 10.00           N
ATOM      2  CA  ARG A  21       7.248  10.924   9.570  1.00 10.00           C
ATOM      3  C   ARG A  21       6.012  11.120  10.440  1.00 10.00           C
ATOM      4  O   ARG A  21       5.064  10.337  10.375  1.00 10.00           O
ATOM      5  CB  ARG A  21       7.724   9.472   9.652  1.00 10.00           C
ATOM      6  CG  ARG A  21       8.797   9.112   8.637  1.00 10.00           C
ATOM      7  CD  ARG A  21       9.187   7.647   8.741  1.00 10.00           C
ATOM      8  NE  ARG A  21      10.266   7.301   7.820  1.00 10.00           N
ATOM      9  CZ  ARG A  21      10.871   6.118   7.790  1.00 10.00           C
ATOM     10  NH1 ARG A  21      10.505   5.162   8.634  1.00 10.00           N
ATOM     11  NH2 ARG A  21      11.844   5.891   6.920  1.00 10.00           N
TER
ATOM      1  O   HOH S   0       8.318  11.834   9.960  1.00 10.00           O
ATOM      2  O   HOH S   1       7.171  11.092   9.451  1.00 10.00           O
ATOM      3  O   HOH S   2       6.012  11.120  10.440  1.00 10.00           O
ATOM      4  O   HOH S   3       5.017  10.416  10.266  1.00 10.00           O
ATOM      5  O   HOH S   4       7.564   9.645   9.143  1.00 10.00           O
ATOM      6  O   HOH S   5       8.560   9.501   8.003  1.00 10.00           O
ATOM      7  O   HOH S   6       8.125  10.300   6.785  1.00 10.00           O
ATOM      8  O   HOH S   7       8.926   9.982   5.607  1.00 10.00           O
ATOM      9  O   HOH S   8       8.893  10.674   4.473  1.00 10.00           O
ATOM     10  O   HOH S   9       8.093  11.727   4.359  1.00 10.00           O
ATOM     11  O   HOH S  10       9.655  10.313   3.451  1.00 10.00           O
TER
END
"""

def exercise(d_min = 1.0, resolution_factor = 0.1):
  """
  Make sure it kicks off existing water. Simple case: no alternatives.
  """
  #
  t = mmtbx.refinement.real_space.setup_test(
    pdb_answer        = pdb_answer,
    pdb_poor          = pdb_poor,
    i_pdb             = 0,
    d_min             = d_min,
    resolution_factor = resolution_factor,
    residues          = ["ARG"],
    pdb_for_map       = pdb_for_map)
  #
  result = mmtbx.refinement.real_space.fit_residues.run(
    pdb_hierarchy     = t.ph_poor,
    vdw_radii         = t.vdw,
    crystal_symmetry  = t.crystal_symmetry,
    map_data          = t.target_map,
    backbone_sample   = True,
    rotatable_hd      = t.rotatable_hd,
    rotamer_manager   = t.rotamer_manager,
    sin_cos_table     = t.sin_cos_table,
    mon_lib_srv       = t.mon_lib_srv)
  result.pdb_hierarchy.write_pdb_file(file_name = "refined_%s.pdb"%str(0))
  #
  sel = result.pdb_hierarchy.atom_selection_cache().selection("not water")
  result_hierarchy = result.pdb_hierarchy.select(sel)
  #
  mmtbx.refinement.real_space.check_sites_match(
    ph_answer  = t.ph_answer,
    ph_refined = result_hierarchy,
    tol        = 0.4)

if(__name__ == "__main__"):
  t0 = time.time()
  exercise()
  print("Time: %6.4f"%(time.time()-t0))


 *******************************************************************************


 *******************************************************************************
mmtbx/refinement/real_space/tst_fit_residue_7.py
from __future__ import absolute_import, division, print_function
import time
import mmtbx.refinement.real_space.fit_residues
import mmtbx.refinement.real_space

pdb_answer = """\
CRYST1   20.000   20.000   20.000  90.00  90.00  90.00 P 1
ATOM      1  N   PRO H 308       8.327   5.395   8.395  1.00 13.20           N
ATOM      2  CA  PRO H 308       9.300   4.740   7.514  1.00  8.82           C
ATOM      3  C   PRO H 308       8.901   4.816   6.043  1.00  9.64           C
ATOM      4  O   PRO H 308       7.821   4.340   5.693  1.00 11.48           O
ATOM      5  CB  PRO H 308       9.296   3.291   8.005  1.00  6.98           C
ATOM      6  CG  PRO H 308       8.840   3.381   9.418  1.00 10.47           C
ATOM      7  CD  PRO H 308       7.827   4.490   9.456  1.00  9.83           C
TER
"""

pdb_poor = """\
CRYST1   20.000   20.000   20.000  90.00  90.00  90.00 P 1
ATOM      1  N   PRO H 308       8.327   5.395   8.395  1.00 13.20           N
ATOM      2  CA  PRO H 308       9.300   4.740   7.514  1.00  8.82           C
ATOM      3  C   PRO H 308       8.901   4.816   6.043  1.00  9.64           C
ATOM      4  O   PRO H 308       7.821   4.340   5.693  1.00 11.48           O
ATOM      5  CB  PRO H 308       9.296   3.291   8.005  1.00  6.98           C
ATOM      6  CG  PRO H 308       7.942   3.104   8.592  1.00 10.47           C
ATOM      7  CD  PRO H 308       7.572   4.422   9.209  1.00  9.83           C
TER
"""

def exercise(pdb_poor_str, i_pdb, d_min = 1.0, resolution_factor = 0.1):
  """
  Fit PRO. PRO is a special case. No H.
  """
  #
  t = mmtbx.refinement.real_space.setup_test(
    pdb_answer        = pdb_answer,
    pdb_poor          = pdb_poor_str,
    i_pdb             = i_pdb,
    d_min             = d_min,
    residues          = ["PRO"],
    resolution_factor = resolution_factor)
  #
  result = mmtbx.refinement.real_space.fit_residues.run(
    pdb_hierarchy     = t.ph_poor,
    vdw_radii         = t.vdw,
    crystal_symmetry  = t.crystal_symmetry,
    map_data          = t.target_map,
    backbone_sample   = True,
    rotatable_hd      = t.rotatable_hd,
    rotamer_manager   = t.rotamer_manager,
    sin_cos_table     = t.sin_cos_table,
    mon_lib_srv       = t.mon_lib_srv)
  result.pdb_hierarchy.write_pdb_file(file_name = "refined_%s.pdb"%str(i_pdb))
  #
  mmtbx.refinement.real_space.check_sites_match(
    ph_answer  = t.ph_answer,
    ph_refined = result.pdb_hierarchy,
    tol        = 0.002)

def exercise_2(pdb_poor_str, i_pdb, d_min = 1.0, resolution_factor = 0.1):
  """
  Fit PRO. PRO is a special case. No H.
  Same as above, but without a map.
  """
  #
  t = mmtbx.refinement.real_space.setup_test(
    pdb_answer        = pdb_answer,
    pdb_poor          = pdb_poor_str,
    i_pdb             = i_pdb,
    d_min             = d_min,
    residues          = ["PRO"],
    resolution_factor = resolution_factor)
  #
  result = mmtbx.refinement.real_space.fit_residues.run(
    pdb_hierarchy     = t.ph_poor,
    vdw_radii         = t.vdw,
    crystal_symmetry  = t.crystal_symmetry,
    # map_data          = t.target_map,
    # backbone_sample   = True,
    rotatable_hd      = t.rotatable_hd,
    rotamer_manager   = t.rotamer_manager,
    sin_cos_table     = t.sin_cos_table,
    mon_lib_srv       = t.mon_lib_srv)
  result.pdb_hierarchy.write_pdb_file(file_name = "refined_%s.pdb"%str(i_pdb))

if(__name__ == "__main__"):
  t0 = time.time()
  exercise(
    pdb_poor_str = pdb_poor,
    i_pdb        = 0)
  exercise_2(
    pdb_poor_str = pdb_poor,
    i_pdb        = 1)
  print("Time: %6.4f"%(time.time()-t0))


 *******************************************************************************


 *******************************************************************************
mmtbx/refinement/real_space/tst_fit_residue_full_sampling.py
from __future__ import absolute_import, division, print_function
import time
import mmtbx.refinement.real_space
import iotbx.pdb
from libtbx.utils import null_out
from scitbx.matrix import rotate_point_around_axis
from mmtbx.rotamer.rotamer_eval import RotamerEval
from mmtbx.idealized_aa_residues import sample_rotamers
from cctbx import maptbx
from scitbx.array_family import flex

pdb_good = """\
CRYST1   21.207   17.255   22.844  90.00  90.00  90.00 P 1
ATOM      1  N   TRP L 148      14.260  10.871  17.844  1.00 22.69           N
ATOM      2  CA  TRP L 148      14.094  10.389  16.478  1.00 19.52           C
ATOM      3  C   TRP L 148      14.872   9.095  16.265  1.00 21.40           C
ATOM      4  O   TRP L 148      15.903   8.867  16.898  1.00 21.95           O
ATOM      5  CB  TRP L 148      14.553  11.451  15.476  1.00 18.93           C
ATOM      6  CG  TRP L 148      14.396  11.033  14.046  1.00 16.05           C
ATOM      7  CD1 TRP L 148      15.328  10.415  13.265  1.00 15.60           C
ATOM      8  CD2 TRP L 148      13.234  11.204  13.225  1.00 15.47           C
ATOM      9  NE1 TRP L 148      14.819  10.190  12.008  1.00 17.97           N
ATOM     10  CE2 TRP L 148      13.535  10.665  11.958  1.00 16.42           C
ATOM     11  CE3 TRP L 148      11.968  11.759  13.437  1.00 16.97           C
ATOM     12  CZ2 TRP L 148      12.618  10.666  10.909  1.00 15.78           C
ATOM     13  CZ3 TRP L 148      11.059  11.759  12.395  1.00 17.54           C
ATOM     14  CH2 TRP L 148      11.389  11.216  11.147  1.00 17.61           C
ATOM     15  HA  TRP L 148      13.155  10.207  16.317  1.00 19.52           H
ATOM     16  HB2 TRP L 148      14.028  12.255  15.610  1.00 18.93           H
ATOM     17  HB3 TRP L 148      15.492  11.640  15.629  1.00 18.93           H
ATOM     18  HD1 TRP L 148      16.184  10.180  13.542  1.00 15.60           H
ATOM     19  HE1 TRP L 148      15.239   9.813  11.359  1.00 17.97           H
ATOM     20  HE3 TRP L 148      11.742  12.122  14.264  1.00 16.97           H
ATOM     21  HZ2 TRP L 148      12.834  10.306  10.079  1.00 15.78           H
ATOM     22  HZ3 TRP L 148      10.215  12.126  12.525  1.00 17.54           H
ATOM     23  HH2 TRP L 148      10.757  11.230  10.464  1.00 17.61           H
ATOM     24  N   TYR L 192      11.041   5.312   9.916  1.00 20.96           N
ATOM     25  CA  TYR L 192      11.151   6.712  10.309  1.00 18.77           C
ATOM     26  C   TYR L 192       9.991   7.112  11.214  1.00 20.42           C
ATOM     27  O   TYR L 192       8.825   6.971  10.844  1.00 20.12           O
ATOM     28  CB  TYR L 192      11.189   7.614   9.074  1.00 15.79           C
ATOM     29  CG  TYR L 192      12.351   7.332   8.148  1.00 19.38           C
ATOM     30  CD1 TYR L 192      12.232   6.414   7.112  1.00 18.58           C
ATOM     31  CD2 TYR L 192      13.566   7.984   8.308  1.00 13.17           C
ATOM     32  CE1 TYR L 192      13.291   6.154   6.263  1.00 17.30           C
ATOM     33  CE2 TYR L 192      14.631   7.730   7.464  1.00 19.20           C
ATOM     34  CZ  TYR L 192      14.487   6.814   6.444  1.00 19.28           C
ATOM     35  OH  TYR L 192      15.544   6.558   5.601  1.00 22.20           O
ATOM     36  HA  TYR L 192      11.976   6.840  10.802  1.00 18.77           H
ATOM     37  HB2 TYR L 192      10.370   7.488   8.569  1.00 15.79           H
ATOM     38  HB3 TYR L 192      11.258   8.537   9.363  1.00 15.79           H
ATOM     39  HD1 TYR L 192      11.426   5.967   6.988  1.00 18.58           H
ATOM     40  HD2 TYR L 192      13.666   8.602   8.996  1.00 13.17           H
ATOM     41  HE1 TYR L 192      13.196   5.536   5.574  1.00 17.30           H
ATOM     42  HE2 TYR L 192      15.439   8.174   7.584  1.00 19.20           H
ATOM     43  HH  TYR L 192      16.207   7.024   5.821  1.00 22.20           H
ATOM     44  N   PHE L 209       6.405   6.669   9.777  1.00 21.36           N
ATOM     45  CA  PHE L 209       5.861   6.089   8.555  1.00 22.67           C
ATOM     46  C   PHE L 209       6.783   5.000   8.016  1.00 26.96           C
ATOM     47  O   PHE L 209       7.997   5.049   8.212  1.00 22.94           O
ATOM     48  CB  PHE L 209       5.650   7.172   7.495  1.00 24.63           C
ATOM     49  CG  PHE L 209       6.906   7.909   7.122  1.00 23.08           C
ATOM     50  CD1 PHE L 209       7.686   7.482   6.060  1.00 22.08           C
ATOM     51  CD2 PHE L 209       7.306   9.027   7.834  1.00 22.40           C
ATOM     52  CE1 PHE L 209       8.841   8.158   5.715  1.00 26.03           C
ATOM     53  CE2 PHE L 209       8.460   9.707   7.493  1.00 21.71           C
ATOM     54  CZ  PHE L 209       9.229   9.271   6.433  1.00 20.59           C
ATOM     55  HA  PHE L 209       5.000   5.686   8.750  1.00 22.67           H
ATOM     56  HB2 PHE L 209       5.299   6.759   6.691  1.00 24.63           H
ATOM     57  HB3 PHE L 209       5.015   7.822   7.835  1.00 24.63           H
ATOM     58  HD1 PHE L 209       7.430   6.732   5.574  1.00 22.08           H
ATOM     59  HD2 PHE L 209       6.792   9.325   8.549  1.00 22.40           H
ATOM     60  HE1 PHE L 209       9.357   7.862   5.000  1.00 26.03           H
ATOM     61  HE2 PHE L 209       8.719  10.457   7.979  1.00 21.71           H
ATOM     62  HZ  PHE L 209      10.006   9.727   6.202  1.00 20.59           H
TER
END
"""

pdb_poor = """\
CRYST1   21.207   17.255   22.844  90.00  90.00  90.00 P 1
ATOM      1  N   TRP L 148      14.260  10.871  17.844  1.00 22.69           N
ATOM      2  CA  TRP L 148      14.094  10.389  16.478  1.00 19.52           C
ATOM      3  C   TRP L 148      14.872   9.095  16.265  1.00 21.40           C
ATOM      4  O   TRP L 148      15.903   8.867  16.898  1.00 21.95           O
ATOM      5  CB  TRP L 148      14.553  11.451  15.476  1.00 18.93           C
ATOM      6  CG  TRP L 148      14.396  11.033  14.046  1.00 16.05           C
ATOM      7  CD1 TRP L 148      15.328  10.415  13.265  1.00 15.60           C
ATOM      8  CD2 TRP L 148      13.234  11.204  13.225  1.00 15.47           C
ATOM      9  NE1 TRP L 148      14.819  10.190  12.008  1.00 17.97           N
ATOM     10  CE2 TRP L 148      13.535  10.665  11.958  1.00 16.42           C
ATOM     11  CE3 TRP L 148      11.968  11.759  13.437  1.00 16.97           C
ATOM     12  CZ2 TRP L 148      12.618  10.666  10.909  1.00 15.78           C
ATOM     13  CZ3 TRP L 148      11.059  11.759  12.395  1.00 17.54           C
ATOM     14  CH2 TRP L 148      11.389  11.216  11.147  1.00 17.61           C
ATOM     15  HA  TRP L 148      13.155  10.207  16.317  1.00 19.52           H
ATOM     16  HB2 TRP L 148      14.028  12.255  15.610  1.00 18.93           H
ATOM     17  HB3 TRP L 148      15.492  11.640  15.629  1.00 18.93           H
ATOM     18  HD1 TRP L 148      16.184  10.180  13.542  1.00 15.60           H
ATOM     19  HE1 TRP L 148      15.239   9.813  11.359  1.00 17.97           H
ATOM     20  HE3 TRP L 148      11.742  12.122  14.264  1.00 16.97           H
ATOM     21  HZ2 TRP L 148      12.834  10.306  10.079  1.00 15.78           H
ATOM     22  HZ3 TRP L 148      10.215  12.126  12.525  1.00 17.54           H
ATOM     23  HH2 TRP L 148      10.757  11.230  10.464  1.00 17.61           H
ATOM     24  N   TYR L 192      11.041   5.312   9.916  1.00 20.96           N
ATOM     25  CA  TYR L 192      11.151   6.712  10.309  1.00 18.77           C
ATOM     26  C   TYR L 192       9.991   7.112  11.214  1.00 20.42           C
ATOM     27  O   TYR L 192       8.825   6.971  10.844  1.00 20.12           O
ATOM     28  CB  TYR L 192      11.189   7.614   9.074  1.00 15.79           C
ATOM     29  CG  TYR L 192      12.585   7.885   8.559  1.00 19.38           C
ATOM     30  CD1 TYR L 192      12.786   8.551   7.356  1.00 18.58           C
ATOM     31  CD2 TYR L 192      13.702   7.478   9.276  1.00 13.17           C
ATOM     32  CE1 TYR L 192      14.060   8.801   6.883  1.00 17.30           C
ATOM     33  CE2 TYR L 192      14.980   7.724   8.810  1.00 19.20           C
ATOM     34  CZ  TYR L 192      15.152   8.386   7.613  1.00 19.28           C
ATOM     35  OH  TYR L 192      16.422   8.633   7.145  1.00 22.20           O
ATOM     36  HA  TYR L 192      11.976   6.840  10.802  1.00 18.77           H
ATOM     37  HB2 TYR L 192      10.687   7.189   8.360  1.00 15.79           H
ATOM     38  HB3 TYR L 192      10.785   8.467   9.297  1.00 15.79           H
ATOM     39  HD1 TYR L 192      12.050   8.832   6.862  1.00 18.58           H
ATOM     40  HD2 TYR L 192      13.589   7.030  10.083  1.00 13.17           H
ATOM     41  HE1 TYR L 192      14.178   9.248   6.075  1.00 17.30           H
ATOM     42  HE2 TYR L 192      15.718   7.444   9.300  1.00 19.20           H
ATOM     43  HH  TYR L 192      16.991   8.329   7.682  1.00 22.20           H
ATOM     44  N   PHE L 209       6.405   6.669   9.777  1.00 21.36           N
ATOM     45  CA  PHE L 209       5.861   6.089   8.555  1.00 22.67           C
ATOM     46  C   PHE L 209       6.783   5.000   8.016  1.00 26.96           C
ATOM     47  O   PHE L 209       7.997   5.049   8.212  1.00 22.94           O
ATOM     48  CB  PHE L 209       5.650   7.172   7.495  1.00 24.63           C
ATOM     49  CG  PHE L 209       6.906   7.909   7.122  1.00 23.08           C
ATOM     50  CD1 PHE L 209       7.686   7.482   6.060  1.00 22.08           C
ATOM     51  CD2 PHE L 209       7.306   9.027   7.834  1.00 22.40           C
ATOM     52  CE1 PHE L 209       8.841   8.158   5.715  1.00 26.03           C
ATOM     53  CE2 PHE L 209       8.460   9.707   7.493  1.00 21.71           C
ATOM     54  CZ  PHE L 209       9.229   9.271   6.433  1.00 20.59           C
ATOM     55  HA  PHE L 209       5.000   5.686   8.750  1.00 22.67           H
ATOM     56  HB2 PHE L 209       5.299   6.759   6.691  1.00 24.63           H
ATOM     57  HB3 PHE L 209       5.015   7.822   7.835  1.00 24.63           H
ATOM     58  HD1 PHE L 209       7.430   6.732   5.574  1.00 22.08           H
ATOM     59  HD2 PHE L 209       6.792   9.325   8.549  1.00 22.40           H
ATOM     60  HE1 PHE L 209       9.357   7.862   5.000  1.00 26.03           H
ATOM     61  HE2 PHE L 209       8.719  10.457   7.979  1.00 21.71           H
ATOM     62  HZ  PHE L 209      10.006   9.727   6.202  1.00 20.59           H
TER      63      PHE L 209
END
"""

def main(use_mask):
  #
  # SETUP INPUTS: read good model, compute map from it
  #
  pdb_inp = iotbx.pdb.input(source_info=None, lines=pdb_good)
  model_good = mmtbx.model.manager(model_input=pdb_inp, log=null_out())
  mon_lib_srv = model_good.get_mon_lib_srv()
  with open("model_good.pdb", "w") as fo:
    fo.write(model_good.model_as_pdb())
  xrs_good = model_good.get_xray_structure()
  f_calc = xrs_good.structure_factors(d_min = 2).f_calc()
  crystal_gridding = maptbx.crystal_gridding(
    unit_cell        = xrs_good.unit_cell(),
    space_group_info = xrs_good.space_group_info(),
    symmetry_flags   = maptbx.use_space_group_symmetry,
    step             = 0.5)
  fft_map = f_calc.fft_map(crystal_gridding=crystal_gridding)
  fft_map.apply_sigma_scaling()
  target_map = fft_map.real_map_unpadded()
  #
  # Read poor model (same as good model except one residue side chain)
  #
  pdb_inp = iotbx.pdb.input(source_info=None, lines=pdb_poor)
  model_poor = mmtbx.model.manager(model_input=pdb_inp, log=null_out())
  with open("model_poor.pdb", "w") as fo:
    fo.write(model_poor.model_as_pdb())
  h_poor = model_poor.get_hierarchy()
  sites_cart_all = model_poor.get_sites_cart()
  uc = model_poor.crystal_symmetry().unit_cell()
  #
  # Track states
  #
  states = model_poor.get_states_collector()
  #
  # This is the residue (number 192) we will be working on (sampling rotamers)
  #
  for m in h_poor.models():
    for c in m.chains():
      for r in c.residues():
        if r.resseq_as_int()==192:
          residue = r
          selection = r.atoms().extract_i_seq()
          break
  #
  # Mask neighjbors. If any trial rotamer atom hits mask value 0 it will be
  # rejected.
  #
  if(use_mask):
    sel_to_mask = ~flex.bool(model_poor.size(), selection)
    mask = maptbx.mask(
      xray_structure = model_poor.get_xray_structure().select(sel_to_mask),
      n_real         = crystal_gridding.n_real(),
      mask_value_inside_molecule = 0,
      mask_value_outside_molecule = 1,
      solvent_radius = 0,
      atom_radius = None)
  #
  # Sample all rotamers
  #
  clusters = mmtbx.refinement.real_space.aa_residue_axes_and_clusters(
    residue         = residue,
    mon_lib_srv     = mon_lib_srv,
    backbone_sample = False).clusters
  rotamer_eval = RotamerEval()
  nested_loop = sample_rotamers.get_nested_loop(
    n=len(clusters), fine=False, start=0, end=360)
  sites_cart = residue.atoms().extract_xyz()
  score_best = -1.e9
  sites_cart_best = None
  for angles in nested_loop:
    sites_cart_moved = sites_cart.deep_copy()
    score=0
    for i, angle in enumerate(angles):
      cl = clusters[i]
      for atom_to_rotate in cl.atoms_to_rotate:
        new_site_cart = rotate_point_around_axis(
          axis_point_1 = sites_cart_moved[cl.axis[0]],
          axis_point_2 = sites_cart_moved[cl.axis[1]],
          point        = sites_cart_moved[atom_to_rotate],
          angle        = angle,
          deg          = True)
        sites_cart_moved[atom_to_rotate] = new_site_cart
    residue.atoms().set_xyz(sites_cart_moved)
    sites_frac_moved = uc.fractionalize(sites_cart_moved)
    # Check if trial rotamer bumps into neighor atoms
    hit_neighbour = False
    if(use_mask):
      for site_frac in sites_frac_moved:
        mv = mask.value_at_closest_grid_point(site_frac)
        if abs(mv)<1.e-6: hit_neighbour = True
        score += target_map.eight_point_interpolation(site_frac)
    # Evaluate rotemeric state
    fl = str(rotamer_eval.evaluate_residue_2(residue = residue)).strip().upper()
    # Accept rotamer if it is not OUTLIER and does not clash with neighbours
    if(fl in ["ALLOWED", "FAVORED"] and not hit_neighbour):
      tmp = sites_cart_all.deep_copy()
      tmp = tmp.set_selected(selection, sites_cart_moved)
      states.add(sites_cart=tmp)
      if(score > score_best):
        score_best = score
        sites_cart_best = sites_cart_moved.deep_copy()
  #
  # Write multi-model file that contains all accepted rotamers
  #
  states.write(file_name="all_states_UseMask%s.pdb"%str(use_mask),
    crystal_symmetry=model_poor.crystal_symmetry())
  #
  # Set best fitting rotamer and write final model
  #
  residue.atoms().set_xyz(sites_cart_best)
  with open("model_fitted.pdb", "w") as fo:
    fo.write(model_poor.model_as_pdb())
  #
  # Assert fitted model matches the answer
  #
  if use_mask:
    s1 = model_good.get_sites_cart()
    s2 = model_poor.get_sites_cart()
    max_dist = flex.max(flex.sqrt((s1 - s2).dot()))
    assert max_dist < 0.1

if(__name__ == "__main__"):
  t0 = time.time()
  for use_mask in [True, False]:
    main(use_mask = use_mask)
  print(time.time()-t0)


 *******************************************************************************
