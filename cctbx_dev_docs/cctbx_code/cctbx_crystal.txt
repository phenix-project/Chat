

 *******************************************************************************
cctbx/crystal/__init__.py
from __future__ import absolute_import, division, print_function
# -*- coding: utf-8 -*-
from cctbx.array_family import flex
import boost_adaptbx.boost.python as bp
from six.moves import range
from six.moves import zip
ext = bp.import_ext("cctbx_crystal_ext")
from cctbx_crystal_ext import *
from cctbx.crystal.find_best_cell import find_best_cell
from cctbx import sgtbx
from cctbx import uctbx
from cctbx import covariance, geometry
from libtbx.containers import OrderedDict
from libtbx.forward_compatibility import object
from scitbx.array_family import shared
from scitbx import stl
import scitbx.stl.set
import scitbx.stl.vector
import libtbx
from libtbx.utils import Keep, Sorry
import sys
from libtbx.utils import format_float_with_standard_uncertainty \
     as format_float_with_su
import math
from scitbx import matrix
import scitbx.cubicle_neighbors
cubicles_max_memory_allocation_set(
  number_of_bytes=scitbx.cubicle_neighbors.cubicles_max_memory_allocation_get())

pair_sym_ops = sgtbx.stl_vector_rt_mx

pair_asu_j_sym_groups = scitbx.stl.vector.set_unsigned
pair_asu_j_sym_group = scitbx.stl.set.unsigned

class symmetry(object):
  """This class represents the symmetry of a crystal and bundles information on its unit cell and space group.
  """
  def __setstate__(self, state):
    if sys.version_info.major > 2:
      from libtbx.easy_pickle import fix_py2_pickle
      state = fix_py2_pickle(state)
    for name,value in state.items():
      setattr(self, name, value)

  def __init__(self,
        unit_cell=None,
        space_group_symbol=None,
        space_group_info=None,
        space_group=None,
        correct_rhombohedral_setting_if_necessary=False,
        assert_is_compatible_unit_cell=True,
        raise_sorry_if_incompatible_unit_cell=False,
        force_compatible_unit_cell=True):
    """Initialises a new crystal.symmetry class object from different input data. Only one of space_group, space_group_info and space_group_symbol may be used.

    :param unit_cell:          object specifying the unit_cell properties
    :type unit_cell:           cctbc.uctbx.ext.unit_cell or tuple(lattice parameters)
    :param space_group_symbol: Hermann-Mauguin symbol of the crystallographic space group
    :type space_group_symbol:  string
    :param space_group_info:   object describing the desired space group
    :type space_group_info:    cctbx.sgtbx.space_group_info
    :param space_group:        the desired space group of the symmetry class
    :type space_group:         cctbx.sgtbx.space_group
    :param correct_rhombohedral_setting_if_necessary: If set to 'True' an automatic conversion between rhombohedral and hexagonal basis will be done
    :type correct_rhombohedral_setting_if_necessary:  boolean
    :param assert_is_compatible_unit_cell: If set to 'True' a consistency check will be performed on the relation of space group to lattice parameters
    :type assert_is_compatible_unit_cell:  boolean
    :param force_compatible_unit_cell:     If set to 'True' the crystal parameters will be averaged to comply with the restrictions of the space group
    :type force_compatible_unit_cell:      boolean

    :returns: a new crystal.symmetry class with desired properties
    :rtype: cctbx.crystal.symmetry
    """
    assert [space_group_symbol, space_group_info, space_group].count(None)>=2
    if (    unit_cell is not None
        and not isinstance(unit_cell, uctbx.ext.unit_cell)):
      unit_cell = uctbx.unit_cell(unit_cell)
    self._unit_cell = unit_cell
    self._space_group_info = space_group_info
    if (self._space_group_info is None):
      if (space_group_symbol is not None):
        self._space_group_info = sgtbx.space_group_info(
          symbol=space_group_symbol)
      elif (space_group is not None):
        if (isinstance(space_group, sgtbx.space_group)):
          self._space_group_info = sgtbx.space_group_info(group=space_group)
        else:
          self._space_group_info = sgtbx.space_group_info(symbol=space_group)
    if (self.unit_cell() is not None and self.space_group_info() is not None):
      if (correct_rhombohedral_setting_if_necessary):
        sgi = self.space_group_info()
        z = sgi.group().conventional_centring_type_symbol()
        if (z == "P"):
          if (self.unit_cell().is_conventional_hexagonal_basis()):
            ls = sgi.type().lookup_symbol()
            if (ls.endswith(" :R")):
              self._space_group_info = sgi.reference_setting()
        elif (z == "R"):
          if (self.unit_cell().is_conventional_rhombohedral_basis()):
            ls = sgi.type().lookup_symbol()
            if (ls.endswith(" :H")):
              self._space_group_info = sgi.primitive_setting()
      if (assert_is_compatible_unit_cell):
        if (raise_sorry_if_incompatible_unit_cell):
          if (not self.is_compatible_unit_cell()):
            raise Sorry(("The space group '%s' is incompatible with unit cell "+
              "parameters %s.") % (str(self._space_group_info),
              str(self._unit_cell.parameters())))
        else :
          assert self.is_compatible_unit_cell(), \
            "Space group is incompatible with unit cell parameters."
      if (force_compatible_unit_cell):
        self._unit_cell = self.space_group().average_unit_cell(
          self._unit_cell)

  def _copy_constructor(self, other):
    self._unit_cell = other._unit_cell
    self._space_group_info = other._space_group_info

  def customized_copy(self, unit_cell=Keep, space_group_info=Keep,
      raise_sorry_if_incompatible_unit_cell=False):
    if (unit_cell is Keep): unit_cell = self._unit_cell
    if (space_group_info is Keep): space_group_info = self._space_group_info
    return symmetry(unit_cell=unit_cell, space_group_info=space_group_info,
      raise_sorry_if_incompatible_unit_cell=\
        raise_sorry_if_incompatible_unit_cell)

  def unit_cell(self):
    return self._unit_cell

  def space_group_number(self):
    sgi = self._space_group_info
    if sgi and sgi.group() and sgi.group().info() and \
       sgi.group().info().type() and \
       (sgi.group().info().type().number() is not None):
      return sgi.group().info().type().number()
    else:
      return None

  def space_group_info(self):
    return self._space_group_info

  def space_group(self):
    sgi = self._space_group_info
    if (sgi is None): return None
    return sgi.group()

  def as_py_code(self, indent=""):
    fmt = (
      'crystal.symmetry(\n'
      '%s  unit_cell=%s,\n'
      '%s  space_group_symbol=%s\n'
      '%s)')
    return fmt % (
      indent,
      "(%.10g, %.10g, %.10g, %.10g, %.10g, %.10g)" % self.unit_cell().parameters()
      if self.unit_cell() is not None else None,
      indent,
      '"%s"' % self.space_group_info().type().lookup_symbol()
      if self.space_group_info() is not None else None,
      indent
    )

  def show_summary(self, f=None, prefix=""):
    if (f is None): f = sys.stdout
    print(self.as_str(prefix=prefix), file=f)

  def as_str(self, prefix=""):
    return (
      prefix + "Unit cell: %s\n" % self.unit_cell() +
      prefix + "Space group: %s" % (
        self.space_group_info().symbol_and_number()
        if self.space_group_info() is not None else None)
    )

  def __str__(self):
    return self.as_str()

  def __repr__(self):
    return self.as_py_code(indent="  ")

  def is_identical_symmetry(self, other):
    ''' True if identical for self and other '''
    return self.is_similar_symmetry(other,
      relative_length_tolerance = 0,
      absolute_angle_tolerance = 0,
      absolute_length_tolerance = 0,)

  def is_similar_symmetry(self,
                          other,
                          relative_length_tolerance=0.01,
                          absolute_angle_tolerance=1.,
                          absolute_length_tolerance=-9999.,
                          ):
    if (self.unit_cell() and other.unit_cell() and
        not self.unit_cell().is_similar_to(
        other.unit_cell(),
        relative_length_tolerance,
        absolute_angle_tolerance,
        absolute_length_tolerance,
        )): return False
    return self.space_group() == other.space_group()

  def is_compatible_unit_cell(self):
    return self.space_group().is_compatible_unit_cell(self.unit_cell())

  def cell_equivalent_p1(self):
    return symmetry(self.unit_cell(), space_group_symbol="P 1")

  def change_basis(self, cb_op):
    if (isinstance(cb_op, str)):
      cb_op = sgtbx.change_of_basis_op(cb_op)
    return symmetry(
      unit_cell=self.unit_cell().change_basis(cb_op),
      space_group_info=self.space_group_info().change_basis(cb_op))

  def change_of_basis_op_to_primitive_setting(self):
    return self.space_group().z2p_op()

  def primitive_setting(self):
    return self.change_basis(self.change_of_basis_op_to_primitive_setting())

  def change_of_basis_op_to_reference_setting(self):
    return self.space_group_info().type().cb_op()

  def as_reference_setting(self):
    return self.change_basis(self.change_of_basis_op_to_reference_setting())

  def change_of_basis_op_to_best_cell(self,
        angular_tolerance=None,
        best_monoclinic_beta=True):
    return find_best_cell(
      input_symmetry=self,
      angular_tolerance=angular_tolerance,
      best_monoclinic_beta=best_monoclinic_beta).cb_op()

  def best_cell(self, angular_tolerance=None):
    return self.change_basis(self.change_of_basis_op_to_best_cell(
      angular_tolerance=angular_tolerance))

  def change_of_basis_op_to_minimum_cell(self):
    z2p_op = self.space_group().z2p_op()
    r_inv = z2p_op.c_inv().r()
    p_cell = self.unit_cell().change_basis(r_inv.num(), r_inv.den())
    red = p_cell.minimum_reduction()
    p2n_op = sgtbx.change_of_basis_op(
      sgtbx.rt_mx(sgtbx.rot_mx(red.r_inv(), 1))).inverse()
    return p2n_op.new_denominators(z2p_op) * z2p_op

  def minimum_cell(self):
    return self.change_basis(self.change_of_basis_op_to_minimum_cell())

  def change_of_basis_op_to_niggli_cell(self,
        relative_epsilon=None,
        iteration_limit=None):
    z2p_op = self.space_group().z2p_op()
    r_inv = z2p_op.c_inv().r()
    p_cell = self.unit_cell().change_basis(r_inv.num(), r_inv.den())
    p2n_op = p_cell.change_of_basis_op_to_niggli_cell()
    return p2n_op.new_denominators(z2p_op) * z2p_op

  def niggli_cell(self,
        relative_epsilon=None,
        iteration_limit=None):
    return self.change_basis(self.change_of_basis_op_to_niggli_cell(
      relative_epsilon=relative_epsilon,
      iteration_limit=iteration_limit))

  def change_of_basis_op_to_inverse_hand(self):
    return self.space_group_info().type().change_of_hand_op()

  def inverse_hand(self):
    return self.change_basis(self.change_of_basis_op_to_inverse_hand())

  def reflection_intensity_symmetry(self, anomalous_flag):
    return symmetry(
      unit_cell=self.unit_cell(),
      space_group=self.space_group()
        .build_derived_reflection_intensity_group(
          anomalous_flag=anomalous_flag))

  def patterson_symmetry(self):
    return symmetry(
      unit_cell=self.unit_cell(),
      space_group=self.space_group().build_derived_patterson_group())

  def is_patterson_symmetry(self):
    return self.space_group().build_derived_patterson_group() \
        == self.space_group()

  def join_symmetry(self, other_symmetry, force=False,
      raise_sorry_if_incompatible_unit_cell=False):
    same_result = symmetry(
        unit_cell=self.unit_cell(),
        space_group_info=self.space_group_info(),
        raise_sorry_if_incompatible_unit_cell=
          raise_sorry_if_incompatible_unit_cell)
    if (other_symmetry is None):
      return same_result
    if (force == False):
      strong = self
      weak = other_symmetry
    else:
      strong = other_symmetry
      weak = self
    unit_cell = strong.unit_cell()
    space_group_info = strong.space_group_info()
    if (unit_cell is None):
      unit_cell = weak.unit_cell()
    if (space_group_info is None):
      space_group_info = weak.space_group_info()
    return symmetry(
      unit_cell=unit_cell,
      space_group_info=space_group_info,
      raise_sorry_if_incompatible_unit_cell=
        raise_sorry_if_incompatible_unit_cell)

  def subtract_continuous_allowed_origin_shifts(self, translation_cart):
    uc = self.unit_cell()
    return uc.orthogonalize(
      self.space_group_info().subtract_continuous_allowed_origin_shifts(
        translation_frac=uc.fractionalize(translation_cart)))

  def direct_space_asu(self):
    return self.space_group_info().direct_space_asu().define_metric(
      unit_cell=self.unit_cell())

  def gridding(self, d_min=None,
                     resolution_factor=None,
                     step=None,
                     symmetry_flags=None,
                     mandatory_factors=None,
                     max_prime=5,
                     assert_shannon_sampling=True):
    from cctbx import maptbx
    return maptbx.crystal_gridding(
      unit_cell=self.unit_cell(),
      d_min=d_min,
      resolution_factor=resolution_factor,
      step=step,
      symmetry_flags=symmetry_flags,
      space_group_info=self.space_group_info(),
      mandatory_factors=mandatory_factors,
      max_prime=max_prime,
      assert_shannon_sampling=assert_shannon_sampling)

  def asu_mappings(self, buffer_thickness, asu_is_inside_epsilon=None):
    import cctbx.crystal.direct_space_asu
    return direct_space_asu.asu_mappings(
      space_group=self.space_group(),
      asu=self.direct_space_asu().as_float_asu(
        is_inside_epsilon=asu_is_inside_epsilon),
      buffer_thickness=buffer_thickness)

  def average_u_cart(self, u_cart):
    from cctbx import adptbx
    return adptbx.u_star_as_u_cart(self.unit_cell(),
      self.space_group().average_u_star(
        adptbx.u_cart_as_u_star(self.unit_cell(), u_cart)))

  def average_b_cart(self, b_cart):
    return self.average_u_cart(u_cart=b_cart)

  def special_position_settings(self,
        min_distance_sym_equiv=0.5,
        u_star_tolerance=0,
        assert_min_distance_sym_equiv=True):
    return special_position_settings(
      crystal_symmetry=self,
      min_distance_sym_equiv=min_distance_sym_equiv,
      u_star_tolerance=u_star_tolerance,
      assert_min_distance_sym_equiv=assert_min_distance_sym_equiv)

  def miller_set(self, indices, anomalous_flag):
    from cctbx import miller
    return miller.set(
      crystal_symmetry=self,
      indices=indices,
      anomalous_flag=anomalous_flag)

  def build_miller_set(self, anomalous_flag, d_min, d_max=None):
    from cctbx import miller
    return miller.build_set(
      crystal_symmetry=self,
      anomalous_flag=anomalous_flag,
      d_min=d_min,
      d_max=d_max)

  def as_pdb_remark_290(self):
    raise Sorry("do not use this method - not tested yet!")
    outl = ""
    if ( self.space_group() is not None and
         self.unit_cell() is not None
         ):
      uc = self.unit_cell()
      params = list(uc.parameters())
      for i,s in enumerate(self.space_group()):
        mat = s.as_double_array()
        for j in range(3):
          outl += "REMARK 290   SMTRY%d%4d%10.6f%10.6f%10.6f%15.5f\n" %(
            j+1,
            i+1,
            mat[j*3],
            mat[j*3+1],
            mat[j*3+2],
            mat[j+9]*params[j],
          )
    return outl

  def as_cif_block(self,
      cell_covariance_matrix=None,
      format="mmcif",
      numeric_format="%.3f"):
    from iotbx.cif import model
    wformat = format.lower()
    assert wformat in ("corecif", "mmcif")
    if wformat == "mmcif":
      separator = '.'
    else:
      separator = '_'
    assert numeric_format.startswith("%")
    cif_block = model.block()
    cell_prefix = '_cell%s' % separator
    if self.space_group() is not None:
      sym_loop = model.loop(data=OrderedDict((
        ('_space_group_symop'+separator+'id',
         range(1, len(self.space_group())+1)),
        ('_space_group_symop'+separator+'operation_xyz',
         [s.as_xyz() for s in self.space_group()]))))
      cif_block.add_loop(sym_loop)
      sg_prefix = '_space_group%s' % separator
      sg_type = self.space_group_info().type()
      sg = sg_type.group()
      cif_block[sg_prefix+'crystal_system'] = sg.crystal_system().lower()
      cif_block[sg_prefix+'IT_number'] = sg_type.number()
      cif_block[sg_prefix+'name_H-M_alt'] = sg_type.lookup_symbol()
      cif_block[sg_prefix+'name_Hall'] = sg_type.hall_symbol()

      sg_prefix = '_symmetry%s' % separator
      cif_block[sg_prefix+'space_group_name_H-M'] = sg_type.lookup_symbol()
      cif_block[sg_prefix+'space_group_name_Hall'] = sg_type.hall_symbol()
      cif_block[sg_prefix+'Int_Tables_number'] = sg_type.number()

    if self.unit_cell() is not None:
      uc = self.unit_cell()
      params = list(uc.parameters())
      volume = uc.volume()
      if cell_covariance_matrix is not None:
        diag = cell_covariance_matrix.matrix_packed_u_diagonal()
        for i in range(6):
          if diag[i] > 0:
            params[i] = format_float_with_su(params[i], math.sqrt(diag[i]))
        d_v_d_params = matrix.row(uc.d_volume_d_params())
        vcv = matrix.sqr(
          cell_covariance_matrix.matrix_packed_u_as_symmetric())
        var_v = (d_v_d_params * vcv).dot(d_v_d_params)
        volume = format_float_with_su(volume, math.sqrt(var_v))
        numeric_format = "%s"
      a,b,c,alpha,beta,gamma = params
      cif_block[cell_prefix+'length_a'] = numeric_format % a
      cif_block[cell_prefix+'length_b'] = numeric_format % b
      cif_block[cell_prefix+'length_c'] = numeric_format % c
      cif_block[cell_prefix+'angle_alpha'] = numeric_format % alpha
      cif_block[cell_prefix+'angle_beta'] = numeric_format % beta
      cif_block[cell_prefix+'angle_gamma'] = numeric_format % gamma
      cif_block[cell_prefix+'volume'] = numeric_format % volume
    return cif_block

  def expand_to_p1(self, sites_cart):
    from scitbx import matrix
    result = flex.vec3_double()
    for site_cart in sites_cart:
      for smx in self.space_group().smx():
        m3 = smx.r().as_double()
        m3 = matrix.sqr(m3)
        t = smx.t().as_double()
        t = matrix.col((t[0],t[1],t[2]))
        site_frac=flex.vec3_double([self.unit_cell().fractionalize(site_cart),])
        result.append(self.unit_cell().orthogonalize(m3.elems*site_frac+t)[0])
    return result

  def is_nonsense(self):
    uc = self.unit_cell()
    if uc is None:
      return True
    if(self.space_group_info() is None or self.space_group() is None):
      return True
    ucp = uc.parameters()
    result = ((abs(1.-ucp[0])<1.e-3 and
             abs(1.-ucp[1])<1.e-3 and
             abs(1.-ucp[2])<1.e-3) or
          (abs(0.-ucp[0])<1.e-3 and
             abs(0.-ucp[1])<1.e-3 and
             abs(0.-ucp[2])<1.e-3) or
          (abs(1.-ucp[3])<1.e-3 and
             abs(1.-ucp[4])<1.e-3 and
             abs(1.-ucp[5])<1.e-3) or
          (abs(0.-ucp[3])<1.e-3 and
             abs(0.-ucp[4])<1.e-3 and
             abs(0.-ucp[5])<1.e-3))
    return result

  def is_empty(self):
    return self.unit_cell() is None and self.space_group_info() is None

  def is_incomplete(self):
    return self.unit_cell() is None or self.space_group() is None

def select_crystal_symmetry(
      from_command_line     = None,
      from_parameter_file   = None,
      from_coordinate_files = [None],
      from_reflection_files = [None],
      enforce_similarity = False,
      absolute_angle_tolerance = 1.,
      absolute_length_tolerance = -9999.):
  """Select/construct a crystal symmetry from a list of various options"""
  tmp = [from_command_line, from_parameter_file]+from_coordinate_files \
        +from_reflection_files
  if tmp.count(None)==len(tmp):
    raise AssertionError("No unit cell and symmetry information supplied")
  if len(tmp) > 0 and enforce_similarity:
    cs0 = None
    i = 0
    while cs0 is None and i<len(tmp):
      cs0 = tmp[i]
      if cs0 is not None:
        if cs0.is_nonsense() or cs0.is_empty():
          cs0 = None
      i += 1
    for cs in tmp[i:]:
      if cs and not cs.is_nonsense() and not cs.is_empty():
        is_similar_cs = cs0.is_similar_symmetry(cs,
           absolute_angle_tolerance=absolute_angle_tolerance,
           absolute_length_tolerance=absolute_length_tolerance)
        if(not is_similar_cs):
          msg = "Crystal symmetry mismatch between different files.\n"
          msg += "%s %s\n" % (cs0.unit_cell(), cs0.space_group_info())
          msg += "%s %s\n" % (cs.unit_cell(), cs.space_group_info())
          raise Sorry("%s"%(msg))
  result = symmetry(
    unit_cell=None,
    space_group_info=None)
  if (from_command_line is not None):
    result = result.join_symmetry(
      other_symmetry=from_command_line, force=False)
  if (from_parameter_file is not None):
    result = result.join_symmetry(
      other_symmetry=from_parameter_file, force=False)
  if (result.unit_cell() is None):
    for crystal_symmetry in from_reflection_files:
      if crystal_symmetry is not None:
        unit_cell = crystal_symmetry.unit_cell()
        if (unit_cell is not None):
          result = symmetry(
            unit_cell=unit_cell,
            space_group_info=result.space_group_info(),
            assert_is_compatible_unit_cell=False)
          break
  for crystal_symmetry in from_coordinate_files:
    if crystal_symmetry is not None:
      if enforce_similarity:  # usual, require compatibility here
        result = result.join_symmetry(
          other_symmetry=crystal_symmetry, force=False)
      else:  # skip incompatible symmetries (can happen e.g. in map_box)
        try:
          result = result.join_symmetry(
            other_symmetry=crystal_symmetry, force=False)
        except Exception as e:
          pass
  if (result.space_group_info() is None):
    for crystal_symmetry in from_reflection_files:
      space_group_info = None
      if crystal_symmetry is not None:
        space_group_info = crystal_symmetry.space_group_info()
      if (space_group_info is not None):
        result = symmetry(
          unit_cell=result.unit_cell(),
          space_group_info=space_group_info,
          assert_is_compatible_unit_cell=False)
        break
  if result.is_nonsense():
    return None
  if result.is_empty():
    return None
  return result

def non_crystallographic_symmetry(
      sites_cart=None,
      sites_cart_min=None,
      sites_cart_max=None,
      buffer_layer=None,
      default_buffer_layer=0.5,
      min_unit_cell_length=0):
  return symmetry(
    unit_cell=uctbx.non_crystallographic_unit_cell(
      sites_cart=sites_cart,
      sites_cart_min=sites_cart_min,
      sites_cart_max=sites_cart_max,
      buffer_layer=buffer_layer,
      default_buffer_layer=default_buffer_layer,
      min_unit_cell_length=min_unit_cell_length),
    space_group=sgtbx.space_group())

class special_position_settings(symmetry):

  def __init__(self, crystal_symmetry,
               min_distance_sym_equiv=0.5,
               u_star_tolerance=0,
               assert_min_distance_sym_equiv=True):
    symmetry._copy_constructor(self, crystal_symmetry)
    self._min_distance_sym_equiv = min_distance_sym_equiv
    self._u_star_tolerance = u_star_tolerance
    self._assert_min_distance_sym_equiv = assert_min_distance_sym_equiv

  def _copy_constructor(self, other):
    symmetry._copy_constructor(self, other)
    self._min_distance_sym_equiv = other._min_distance_sym_equiv
    self._u_star_tolerance = other._u_star_tolerance
    self._assert_min_distance_sym_equiv = other._assert_min_distance_sym_equiv

  def min_distance_sym_equiv(self):
    return self._min_distance_sym_equiv

  def u_star_tolerance(self):
    return self._u_star_tolerance

  def assert_min_distance_sym_equiv(self):
    return self._assert_min_distance_sym_equiv

  def change_basis(self, cb_op):
    return special_position_settings(
      crystal_symmetry=symmetry.change_basis(self, cb_op),
      min_distance_sym_equiv=self.min_distance_sym_equiv(),
      u_star_tolerance=self.u_star_tolerance(),
      assert_min_distance_sym_equiv=self.assert_min_distance_sym_equiv())

  def site_symmetry(self, site=None, site_cart=None):
    assert [site, site_cart].count(None) == 1
    if (site_cart is not None):
      site = self.unit_cell().fractionalize(site_cart)
    return sgtbx.site_symmetry(
      self.unit_cell(),
      self.space_group(),
      site,
      self.min_distance_sym_equiv(),
      self.assert_min_distance_sym_equiv())

  def sym_equiv_sites(self, site):
    return sgtbx.sym_equiv_sites(self.site_symmetry(site))

  def site_symmetry_table(self,
        sites_frac=None,
        sites_cart=None,
        unconditional_general_position_flags=None):
    assert (sites_frac is None) != (sites_cart is None)
    if (sites_frac is None):
      sites_frac = self.unit_cell().fractionalize(sites_cart=sites_cart)
    result = sgtbx.site_symmetry_table()
    result.process(
      unit_cell=self.unit_cell(),
      space_group=self.space_group(),
      original_sites_frac=sites_frac,
      unconditional_general_position_flags=
        unconditional_general_position_flags,
      min_distance_sym_equiv=self.min_distance_sym_equiv(),
      assert_min_distance_sym_equiv=self.assert_min_distance_sym_equiv())
    return result

  def xray_structure(self, scatterers=None):
    import cctbx.xray.structure as _
    return _(special_position_settings=self, scatterers=scatterers)

  def asu_mappings(self,
        buffer_thickness,
        sites_frac=None,
        sites_cart=None,
        site_symmetry_table=None,
        asu_is_inside_epsilon=None):
    asu_mappings = symmetry.asu_mappings(self,
      buffer_thickness=buffer_thickness,
      asu_is_inside_epsilon=asu_is_inside_epsilon)
    if (sites_frac is not None or sites_cart is not None):
      assert sites_frac is None or sites_cart is None
      if (sites_frac is None):
        sites_frac = self.unit_cell().fractionalize(sites_cart=sites_cart)
      if (site_symmetry_table is None):
        site_symmetry_table = self.site_symmetry_table(sites_frac=sites_frac)
      asu_mappings.process_sites_frac(
        original_sites=sites_frac,
        site_symmetry_table=site_symmetry_table)
    return asu_mappings

  def pair_generator(self,
        distance_cutoff,
        sites_frac=None,
        sites_cart=None,
        site_symmetry_table=None,
        asu_mappings_buffer_thickness=None,
        asu_is_inside_epsilon=None,
        minimal=False):
    assert sites_frac is not None or sites_cart is not None
    if (asu_mappings_buffer_thickness is None):
        asu_mappings_buffer_thickness = distance_cutoff
    asu_mappings = self.asu_mappings(
      buffer_thickness=asu_mappings_buffer_thickness,
      sites_frac=sites_frac,
      sites_cart=sites_cart,
      site_symmetry_table=site_symmetry_table,
      asu_is_inside_epsilon=asu_is_inside_epsilon)
    return neighbors_fast_pair_generator(
      asu_mappings=asu_mappings,
      distance_cutoff=distance_cutoff,
      minimal=minimal)

  def pair_asu_table(self,
        distance_cutoff,
        sites_frac=None,
        sites_cart=None,
        site_symmetry_table=None,
        asu_mappings_buffer_thickness=None,
        asu_is_inside_epsilon=None,
        min_cubicle_edge=5,
        distance_cutoff_epsilon=None):
    assert sites_frac is not None or sites_cart is not None
    if (asu_mappings_buffer_thickness is None):
        asu_mappings_buffer_thickness = distance_cutoff
    asu_mappings = self.asu_mappings(
      buffer_thickness=asu_mappings_buffer_thickness,
      sites_frac=sites_frac,
      sites_cart=sites_cart,
      site_symmetry_table=site_symmetry_table,
      asu_is_inside_epsilon=asu_is_inside_epsilon)
    result = pair_asu_table(asu_mappings=asu_mappings)
    if (distance_cutoff_epsilon is None):
        distance_cutoff_epsilon = asu_mappings.asu().is_inside_epsilon()
    result.add_all_pairs(
      distance_cutoff=distance_cutoff,
      min_cubicle_edge=min_cubicle_edge,
      epsilon=distance_cutoff_epsilon)
    return result

  def incremental_pairs(self,
        distance_cutoff,
        asu_is_inside_epsilon=None,
        asu_mappings_buffer_thickness=-1,
        cubicle_epsilon=-1):
    result = incremental_pairs(
      space_group=self.space_group(),
      asu=self.direct_space_asu().as_float_asu(
        is_inside_epsilon=asu_is_inside_epsilon),
      distance_cutoff=distance_cutoff,
      asu_mappings_buffer_thickness=asu_mappings_buffer_thickness,
      cubicle_epsilon=cubicle_epsilon)
    result.min_distance_sym_equiv = self._min_distance_sym_equiv
    result.assert_min_distance_sym_equiv = self._assert_min_distance_sym_equiv
    return result

  def site_cluster_analysis(self,
        min_distance=None,
        min_cross_distance=None,
        min_self_distance=None,
        general_positions_only=False,
        estimated_reduction_factor=4,
        asu_is_inside_epsilon=None,
        asu_mappings_buffer_thickness=-1,
        min_cubicle_edge=5,
        cubicle_epsilon=-1):
    if (min_cross_distance is None): min_cross_distance = min_distance
    if (min_self_distance is None): min_self_distance = min_distance
    if (min_self_distance is None): min_self_distance = min_cross_distance
    assert min_cross_distance is not None
    assert min_self_distance is not None
    result = site_cluster_analysis(
      space_group=self.space_group(),
      asu=self.direct_space_asu().as_float_asu(
        is_inside_epsilon=asu_is_inside_epsilon),
      min_cross_distance=min_cross_distance,
      min_self_distance=min_self_distance,
      general_positions_only=general_positions_only,
      estimated_reduction_factor=estimated_reduction_factor,
      asu_mappings_buffer_thickness=asu_mappings_buffer_thickness,
      min_cubicle_edge=min_cubicle_edge,
      cubicle_epsilon=cubicle_epsilon)
    result.min_distance_sym_equiv = self._min_distance_sym_equiv
    result.assert_min_distance_sym_equiv = self._assert_min_distance_sym_equiv
    return result

def correct_special_position(
      crystal_symmetry,
      special_op,
      site_frac=None,
      site_cart=None,
      site_label=None,
      tolerance=1,
      error_message="Excessive special position correction:"):
  assert (site_frac is None) != (site_cart is None)
  unit_cell = crystal_symmetry.unit_cell()
  if (site_frac is None):
    site_frac = unit_cell.fractionalize(site_cart)
  site_special_frac = special_op * site_frac
  distance_moved = unit_cell.distance(site_special_frac, site_frac)
  if (distance_moved > tolerance):
    error_message += "\n  unit_cell: %s" % str(unit_cell)
    error_message += "\n  space_group_info: %s" % str(
      crystal_symmetry.space_group_info())
    error_message += "\n  special_op: %s" % str(special_op)
    if (site_label is not None):
      error_message += "\n  site_label: %s" % site_label
    error_message += "\n  site_frac: %s" % str(site_frac)
    error_message += "\n  site_special_frac: %s" % str(site_special_frac)
    error_message += "\n  distance_moved: %g" % distance_moved
    raise AssertionError(error_message)
  if (site_cart is None):
    return site_special_frac
  return unit_cell.orthogonalize(site_special_frac)

@bp.inject_into(pair_asu_table)
class _():

  def as_nested_lists(self):
    result = []
    for i_seq, j_seq_dict in enumerate(self.table()):
      i_seq_list = [i_seq]
      for j_seq,j_sym_group in j_seq_dict.items():
        j_seq_list = [j_seq]
        for j_syms in j_sym_group:
          j_seq_list.append(list(j_syms))
        i_seq_list.append(j_seq_list)
      result.append(i_seq_list)
    return result

  def show(self, f=None, site_labels=None):
    if (f is None): f = sys.stdout
    if (site_labels is None):
      for i_seq, j_seq_dict in enumerate(self.table()):
        print("i_seq:", i_seq, file=f)
        for j_seq,j_sym_group in j_seq_dict.items():
          print("  j_seq:", j_seq, file=f)
          for j_syms in j_sym_group:
            print("    j_syms:", list(j_syms), file=f)
    else:
      assert len(site_labels) == self.table().size()
      for i_seq, j_seq_dict in enumerate(self.table()):
        print("%s(%d)" % (site_labels[i_seq], i_seq), file=f)
        for j_seq,j_sym_group in j_seq_dict.items():
          print("  %s(%d)" % (site_labels[j_seq], j_seq), file=f)
          for j_syms in j_sym_group:
            print("    j_syms:", list(j_syms), file=f)

  def show_distances(self,
        site_labels=None,
        sites_frac=None,
        sites_cart=None,
        show_cartesian=False,
        keep_pair_asu_table=False,
        out=None):
    return show_distances(
      pair_asu_table=self,
      site_labels=site_labels,
      sites_frac=sites_frac,
      sites_cart=sites_cart,
      show_cartesian=show_cartesian,
      keep_pair_asu_table=keep_pair_asu_table,
      out=out)

  def show_angles(self,
        site_labels=None,
        sites_frac=None,
        sites_cart=None,
        keep_pair_asu_table=False,
        out=None):
    return show_angles(
      pair_asu_table=self,
      site_labels=site_labels,
      sites_frac=sites_frac,
      sites_cart=sites_cart,
      keep_pair_asu_table=keep_pair_asu_table,
      out=out)

  def show_dihedral_angles(self,
        site_labels=None,
        sites_frac=None,
        sites_cart=None,
        keep_pair_asu_table=False,
        max_d=1.7,
        max_angle=170,
        out=None):
    return show_dihedral_angles(
      pair_asu_table=self,
      site_labels=site_labels,
      sites_frac=sites_frac,
      sites_cart=sites_cart,
      max_d=max_d,
      max_angle=max_angle,
      out=out)

class calculate_distances(object):

  def __init__(self,
               pair_asu_table,
               sites_frac,
               skip_j_seq_less_than_i_seq=True,
               covariance_matrix=None,
               cell_covariance_matrix=None,
               parameter_map=None):
    libtbx.adopt_init_args(self, locals())
    self.distances = flex.double()
    if self.covariance_matrix is not None:
      self.variances = flex.double()
    else:
      self.variances = None
    self.pair_counts = flex.size_t()

  def __iter__(self):
    return next(self)

  def __next__(self):

    class distance(object):
      def __init__(self,
                   distance,
                   i_seq,
                   j_seq,
                   pair_count,
                   rt_mx_ji=None,
                   i_j_sym=None,
                   variance=None):
        libtbx.adopt_init_args(self, locals())

    asu_mappings = self.pair_asu_table.asu_mappings()
    unit_cell = asu_mappings.unit_cell()
    if self.covariance_matrix is not None:
      assert self.parameter_map is not None
      cov_cart = covariance.orthogonalize_covariance_matrix(
        self.covariance_matrix, unit_cell, self.parameter_map)
    for i_seq,asu_dict in enumerate(self.pair_asu_table.table()):
      rt_mx_i_inv = asu_mappings.get_rt_mx(i_seq, 0).inverse()
      site_frac_i = self.sites_frac[i_seq]
      pair_count = 0
      dists = flex.double()
      j_seq_i_group = []
      for j_seq,j_sym_groups in asu_dict.items():
        if self.skip_j_seq_less_than_i_seq and j_seq < i_seq: continue
        site_frac_j = self.sites_frac[j_seq]
        for i_group,j_sym_group in enumerate(j_sym_groups):
          pair_count += j_sym_group.size()
          j_sym = j_sym_group[0]
          rt_mx_ji = rt_mx_i_inv.multiply(asu_mappings.get_rt_mx(j_seq, j_sym))
          dist = unit_cell.distance(site_frac_i, rt_mx_ji * site_frac_j)
          dists.append(dist)
          j_seq_i_group.append((j_seq,i_group))
      permutation = flex.sort_permutation(data=dists)
      for j_seq,i_group in flex.select(j_seq_i_group, permutation):
        site_frac_j = self.sites_frac[j_seq]
        j_sym_groups = asu_dict[j_seq]
        j_sym_group = j_sym_groups[i_group]
        for i_j_sym,j_sym in enumerate(j_sym_group):
          rt_mx_ji = rt_mx_i_inv.multiply(
            asu_mappings.get_rt_mx(j_seq, j_sym))
          site_frac_ji = rt_mx_ji * site_frac_j
          d = geometry.distance((unit_cell.orthogonalize(site_frac_i),
                                 unit_cell.orthogonalize(site_frac_ji)))
          dist = d.distance_model
          self.distances.append(dist)
          if self.covariance_matrix is not None:
            cov = covariance.extract_covariance_matrix_for_sites(
              flex.size_t((i_seq,j_seq)), cov_cart, self.parameter_map)
            if self.cell_covariance_matrix is not None:
              var = d.variance(cov, unit_cell, rt_mx_ji)
              # a bit of a hack - if the variance is approx zero, we assume
              # that the distance is constrained (e.g. as part of a rigid body)
              # unless it is a distance between two symmetry-related atoms, in
              # which case we include the cell errors into the variance calculation
              if var > 2e-16 or (i_seq == j_seq and not rt_mx_ji.is_unit_mx()):
                var = d.variance(
                  cov, self.cell_covariance_matrix, unit_cell, rt_mx_ji)
            else:
              var = d.variance(cov, unit_cell, rt_mx_ji)
            self.variances.append(var)
          else:
            var = None
          yield distance(
            dist, i_seq, j_seq, pair_count, rt_mx_ji, i_j_sym, variance=var)

      self.pair_counts.append(pair_count)

class show_distances(libtbx.slots_getstate_setstate):

  __slots__ = ["pair_asu_table", "distances_info", "have_sym"]

  def __init__(self,
        pair_asu_table,
        site_labels=None,
        sites_frac=None,
        sites_cart=None,
        show_cartesian=False,
        keep_pair_asu_table=False,
        skip_j_seq_less_than_i_seq=False,
        out=None):
    assert [sites_frac, sites_cart].count(None) == 1
    if (out is None): out = sys.stdout
    if (keep_pair_asu_table):
      self.pair_asu_table = pair_asu_table
    else:
      self.pair_asu_table = None
    asu_mappings = pair_asu_table.asu_mappings()
    unit_cell = asu_mappings.unit_cell()
    if (sites_frac is None):
      sites_frac = unit_cell.fractionalize(sites_cart=sites_cart)
    if (site_labels is None):
      label_len = len("%d" % (sites_frac.size()+1))
      label_fmt = "site_%%0%dd" % label_len
      label_len += 5
    else:
      label_len = 1
      for label in site_labels:
        label_len = max(label_len, len(label))
      label_fmt = "%%-%ds" % (label_len+1)
    self.distances_info = calculate_distances(
      pair_asu_table, sites_frac,
      skip_j_seq_less_than_i_seq=skip_j_seq_less_than_i_seq)
    self.have_sym = False
    i_seqs_done = set()
    for di in self.distances_info:
      i_seq, j_seq = di.i_seq, di.j_seq
      rt_mx_ji = di.rt_mx_ji
      from scitbx.array_family import flex
      first_time_i_seq = (i_seq not in i_seqs_done)
      if (first_time_i_seq):
        i_seqs_done.add(i_seq)
        if (site_labels is None):
          s = label_fmt % (i_seq+1)
        else:
          s = label_fmt % site_labels[i_seq]
        s += " pair count: %3d" % di.pair_count
        site_frac_i = sites_frac[i_seq]
        if (show_cartesian):
          formatted_site = [" %7.2f" % x
            for x in unit_cell.orthogonalize(site_frac_i)]
        else:
          formatted_site = [" %7.4f" % x for x in site_frac_i]
        print(("%%-%ds" % (label_len+23)) % s, \
          "<<"+",".join(formatted_site)+">>", file=out)
      if (site_labels is None):
        print(" ", label_fmt % (j_seq+1) + ":", end=' ', file=out)
      else:
        print(" ", label_fmt % (site_labels[j_seq] + ":"), end=' ', file=out)
      print("%8.4f" % di.distance, end=' ', file=out)
      if di.i_j_sym != 0:
        s = "sym. equiv."
      else:
        s = "           "
      site_frac_ji = rt_mx_ji * sites_frac[j_seq]
      if (show_cartesian):
        formatted_site = [" %7.2f" % x
          for x in unit_cell.orthogonalize(site_frac_ji)]
      else:
        formatted_site = [" %7.4f" % x for x in site_frac_ji]
      s += " (" + ",".join(formatted_site) +")"
      if (not rt_mx_ji.is_unit_mx()):
        s += " sym=" + str(rt_mx_ji)
        self.have_sym = True
      print(s, file=out)
      if first_time_i_seq and di.pair_count == 0:
        print("  no neighbors", file=out)

class calculate_angles(object):

  def __init__(self,
               pair_asu_table,
               sites_frac,
               skip_j_seq_less_than_i_seq=True,
               covariance_matrix=None,
               cell_covariance_matrix=None,
               parameter_map=None,
               conformer_indices=None):
    libtbx.adopt_init_args(self, locals())
    self.distances = flex.double()
    if self.covariance_matrix is not None:
      self.variances = flex.double()
    else:
      self.variances = None
    self.angles = flex.double()
    self.pair_counts = flex.size_t()

  def __iter__(self):
    return next(self)

  def __next__(self):

    class angle(object):
      def __init__(self,
                   angle,
                   i_seqs,
                   rt_mx_ji=None,
                   rt_mx_ki=None,
                   variance=None):
        libtbx.adopt_init_args(self, locals())

    asu_mappings = self.pair_asu_table.asu_mappings()
    unit_cell = asu_mappings.unit_cell()
    if self.covariance_matrix is not None:
      assert self.parameter_map is not None
      cov_cart = covariance.orthogonalize_covariance_matrix(
        self.covariance_matrix, unit_cell, self.parameter_map)

    ## angle is formed by j_seq-i_seq-k_seq
    for i_seq,asu_dict in enumerate(self.pair_asu_table.table()):
      rt_mx_i_inv = asu_mappings.get_rt_mx(i_seq, 0).inverse()
      site_frac_i = self.sites_frac[i_seq]
      angles = flex.double()
      for j_seq,j_sym_groups in asu_dict.items():
        site_frac_j = self.sites_frac[j_seq]
        for j_sym_group in j_sym_groups:
          for i_j_sym,j_sym in enumerate(j_sym_group):
            rt_mx_ji = rt_mx_i_inv.multiply(
              asu_mappings.get_rt_mx(j_seq, j_sym))
            site_frac_ji = rt_mx_ji * site_frac_j
            for k_seq, k_sym_groups in asu_dict.items():
              if self.skip_j_seq_less_than_i_seq and j_seq < k_seq: continue
              if k_seq == j_seq and j_sym_group.size() <= 1: continue
              if k_seq > j_seq: continue
              site_frac_k = self.sites_frac[k_seq]
              for k_sym_group in k_sym_groups:
                for i_k_sym,k_sym in enumerate(k_sym_group):
                  if j_seq == k_seq and i_j_sym <= i_k_sym: continue
                  if i_seq == k_seq and i_k_sym == 0: continue
                  if (self.conformer_indices is not None and
                      self.conformer_indices[j_seq] !=
                      self.conformer_indices[k_seq]): continue
                  rt_mx_ki = rt_mx_i_inv.multiply(
                    asu_mappings.get_rt_mx(k_seq, k_sym))
                  site_frac_ki = rt_mx_ki * site_frac_k
                  a = geometry.angle((unit_cell.orthogonalize(site_frac_ji),
                                      unit_cell.orthogonalize(site_frac_i),
                                      unit_cell.orthogonalize(site_frac_ki)))
                  angle_ = a.angle_model
                  self.angles.append(angle_)
                  if self.covariance_matrix is not None:
                    cov = covariance.extract_covariance_matrix_for_sites(
                      flex.size_t((j_seq, i_seq, k_seq)),
                      cov_cart, self.parameter_map)
                    if self.cell_covariance_matrix is not None:
                      var = a.variance(
                        cov, unit_cell, (rt_mx_ji, sgtbx.rt_mx(), rt_mx_ki))
                      # a bit of a hack - see equivalent comment in
                      # calculate_distances
                      if (var > 2e-15 or
                          (i_seq == j_seq and not rt_mx_ji.is_unit_mx()) or
                          (i_seq == k_seq and not rt_mx_ki.is_unit_mx())):
                        var = a.variance(
                          cov, self.cell_covariance_matrix, unit_cell,
                          (rt_mx_ji, sgtbx.rt_mx(), rt_mx_ki))
                    else:
                      var = a.variance(
                        cov, unit_cell, (rt_mx_ji, sgtbx.rt_mx(), rt_mx_ki))
                    self.variances.append(var)
                  else:
                    var = None
                  yield angle(angle_, (j_seq, i_seq, k_seq),
                              rt_mx_ji, rt_mx_ki, variance=var)

class show_angles(object):

  def __init__(self,
        pair_asu_table,
        site_labels=None,
        sites_frac=None,
        sites_cart=None,
        show_cartesian=False,
        keep_pair_asu_table=False,
        out=None):

    assert [sites_frac, sites_cart].count(None) == 1
    if (out is None): out = sys.stdout
    if (keep_pair_asu_table):
      self.pair_asu_table = pair_asu_table
    else:
      self.pair_asu_table = None
    rt_mxs = []
    if (site_labels is None):
      label_len = len("%d" % (sites_frac.size()+1))
      label_fmt = "site_%%0%dd" % label_len
      label_len += 5
    else:
      label_len = 1
      for label in site_labels:
        label_len = max(label_len, len(label))
      label_fmt = "%%-%ds" % (label_len+4)
      label_fmt *= 3
    angles = calculate_angles(pair_asu_table, sites_frac)
    for a in angles:
      j_seq, i_seq, k_seq = a.i_seqs
      rt_mx_ji = a.rt_mx_ji
      rt_mx_ki = a.rt_mx_ki
      if (site_labels is None):
        s = label_fmt % (j_seq+1) + ":"
      else:
        i_label = site_labels[i_seq]
        j_label = site_labels[j_seq]
        k_label = site_labels[k_seq]
        if not rt_mx_ji.is_unit_mx():
          if rt_mx_ji in rt_mxs:
            j = rt_mxs.index(rt_mx_ji) + 1
          else:
            rt_mxs.append(rt_mx_ji)
            j = len(rt_mxs)
          j_label += "*%s" %j
        if not rt_mx_ki.is_unit_mx():
          if rt_mx_ki in rt_mxs:
            k = rt_mxs.index(rt_mx_ki) + 1
          else:
            rt_mxs.append(rt_mx_ki)
            k = len(rt_mxs)
          k_label += "*%s" %k
        s = label_fmt % (j_label, i_label, k_label)
      s += " %6.2f" % a.angle
      print(s, file=out)

    self.angles = angles.angles
    self.distance = angles.distances
    for i, rt_mx in enumerate(rt_mxs):
      print("*%s" %(i+1), end=' ', file=out)
      print(rt_mx, file=out)


class dihedral_angle_def(object):
  def __init__(self, seqs, rt_mxs):
    libtbx.adopt_init_args(self, locals())

class calculate_dihedrals(object):
  def __init__(self,
               pair_asu_table,
               sites_frac,
               dihedral_defs=None, #angle definition
               skip_j_seq_less_than_i_seq=True,
               covariance_matrix=None,
               cell_covariance_matrix=None,
               parameter_map=None,
               conformer_indices=None,
               max_d = 1.9,
               max_angle = 170):
    libtbx.adopt_init_args(self, locals())
    if self.covariance_matrix is not None:
      self.variances = flex.double()
    else:
      self.variances = None
    self.dihedrals = flex.double()

  def __iter__(self):
    return self.next()

  def next(self):

    class dihedral(object):
      def __init__(self,
                   angle,
                   i_seqs,
                   rt_mxs,
                   variance=None):
        libtbx.adopt_init_args(self, locals())
      def __eq__(self, other):
        for i in range(0,4):
          if self.i_seqs[i] != other.i_seqs[i] or self.rt_mxs[i] != other.rt_mxs[i]:
            return False
        return True

    asu_mappings = self.pair_asu_table.asu_mappings()
    unit_cell = asu_mappings.unit_cell()
    if self.covariance_matrix is not None:
      assert self.parameter_map is not None
      cov_cart = covariance.orthogonalize_covariance_matrix(
        self.covariance_matrix, unit_cell, self.parameter_map)
    if self.dihedral_defs is not None:
      for ad in self.dihedral_defs:
        sites = []
        for i in range(0,4):
          site_frac = ad.rt_mxs[i] * self.sites_frac[ad.seqs[i]]
          sites.append(unit_cell.orthogonalize(site_frac))
        a = geometry.dihedral(sites)
        angle_ = a.dihedral_model
        self.dihedrals.append(angle_)
        if self.covariance_matrix is not None:
          cov = covariance.extract_covariance_matrix_for_sites(
            flex.size_t(ad.seqs), cov_cart, self.parameter_map)
          if self.cell_covariance_matrix is not None:
            var = a.variance(cov, unit_cell, ad.rt_mxs)
          else:
            var = a.variance(cov, unit_cell, ad.rt_mxs)
          self.variances.append(var)
        else:
          var = None
        yield dihedral(angle_, ad.seqs, ad.rt_mxs, variance=var)
      return
    table = self.pair_asu_table.table()
    for i_seq,i_asu_dict in enumerate(table):
      rt_mx_i_inv = asu_mappings.get_rt_mx(i_seq, 0).inverse()
      i_site_frac = self.sites_frac[i_seq]
      for j_seq,j_sym_groups in i_asu_dict.items():
        if j_seq < i_seq: continue
        rt_mx_j0_inv = asu_mappings.get_rt_mx(j_seq, 0).inverse()
        for j_sym_group in j_sym_groups:
          for j_sym_idx,j_sym in enumerate(j_sym_group):
            rt_mx_j = rt_mx_i_inv.multiply(asu_mappings.get_rt_mx(j_seq, j_sym))
            j_site_frac = rt_mx_j * self.sites_frac[j_seq]
            for k_seq, k_sym_groups in table[j_seq].items():
              if k_seq < i_seq: continue
              if (self.conformer_indices is not None and
                  self.conformer_indices[j_seq] !=
                  self.conformer_indices[k_seq]):
                continue
              rt_mx_k0_inv = asu_mappings.get_rt_mx(k_seq, 0).inverse()
              rt_mx_kj = rt_mx_j.multiply(rt_mx_j0_inv)
              for k_sym_group in k_sym_groups:
                for k_sym_idx,k_sym in enumerate(k_sym_group):
                  rt_mx_k = rt_mx_kj.multiply(asu_mappings.get_rt_mx(k_seq, k_sym))
                  k_site_frac = rt_mx_k *  self.sites_frac[k_seq]
                  if k_site_frac == i_site_frac:
                    continue
                  if unit_cell.distance(j_site_frac, k_site_frac) > self.max_d:
                    continue
                  rt_mx_lk = rt_mx_k.multiply(rt_mx_k0_inv)
                  for l_seq, l_sym_groups in table[k_seq].items():
                    if l_seq < i_seq: continue
                    if (self.conformer_indices is not None and
                        self.conformer_indices[k_seq] !=
                        self.conformer_indices[l_seq]):
                      continue
                    for l_sym_group in l_sym_groups:
                      for l_sym_idx, l_sym in enumerate(l_sym_group):
                        rt_mx_l = rt_mx_lk.multiply(asu_mappings.get_rt_mx(l_seq, l_sym))
                        l_site_frac = rt_mx_l *  self.sites_frac[l_seq]
                        if l_site_frac in (i_site_frac, j_site_frac):
                          continue
                        if unit_cell.angle(i_site_frac, j_site_frac, k_site_frac) > self.max_angle or\
                           unit_cell.angle(j_site_frac, k_site_frac, l_site_frac) > self.max_angle:
                          continue
                        rt_mxs = [sgtbx.rt_mx(), rt_mx_j, rt_mx_k, rt_mx_l]
                        sites = [i_site_frac, j_site_frac, k_site_frac, l_site_frac]
                        seqs = [i_seq, j_seq, k_seq, l_seq]
                        rtmx_count = [0,0,0,0]
                        # find the most common matrix to eliminate
                        for idx, rt_mx in enumerate(rt_mxs):
                          for idx1 in range(idx+1, 4):
                            if rt_mx == rt_mxs[idx1]:
                              rtmx_count[idx] += 1
                        max_idx = rtmx_count.index(max(rtmx_count))
                        rt_mx_inv = rt_mxs[max_idx].inverse()
                        for i in range(0, 4):
                          sites[i] = rt_mxs[i].inverse() * sites[i]
                          rt_mxs[i] = rt_mx_inv.multiply(rt_mxs[i])
                          sites[i] = unit_cell.orthogonalize(rt_mxs[i] * sites[i])
                        a = geometry.dihedral(sites)
                        angle_ = a.dihedral_model
                        self.dihedrals.append(angle_)
                        if self.covariance_matrix is not None:
                          cov = covariance.extract_covariance_matrix_for_sites(
                            flex.size_t(seqs), cov_cart, self.parameter_map)
                          if self.cell_covariance_matrix is not None:
                            var = a.variance(cov, unit_cell, rt_mxs)
                          else:
                            var = a.variance(cov, unit_cell, rt_mxs)
                          self.variances.append(var)
                        else:
                          var = None
                        yield dihedral(angle_, seqs, rt_mxs, variance=var)

class show_dihedral_angles(object):

  def __init__(self,
        pair_asu_table,
        site_labels=None,
        sites_frac=None,
        sites_cart=None,
        show_cartesian=False,
        max_d=1.7,
        max_angle=170,
        out=None):

    assert [sites_frac, sites_cart].count(None) == 1
    if (out is None): out = sys.stdout
    rt_mxs = []
    if (site_labels is None):
      label_len = len("%d" % (sites_frac.size()+1))
      label_fmt = "site_%%0%dd" % label_len
      label_len += 5
    else:
      label_len = 1
      for label in site_labels:
        label_len = max(label_len, len(label))
      label_fmt = "%%-%ds" % (label_len+4)
    angles = calculate_dihedrals(pair_asu_table, sites_frac,
      max_d=max_d, max_angle=max_angle)
    for d in angles:
      if (site_labels is None):
        s = label_fmt % (d.i_seqs[0]+1) + ":"
      else:
        s = ""
        for idx, i_seq in enumerate(d.i_seqs):
          label = label_fmt % site_labels[i_seq]
          rt_mx = d.rt_mxs[idx]
          if not rt_mx.is_unit_mx():
            if rt_mx in rt_mxs:
              j = rt_mxs.index(rt_mx) + 1
            else:
              rt_mxs.append(rt_mx)
              j = len(rt_mxs)
            label += "*%s" %j
          s += label
      s += " %6.2f" % d.angle
      print(s, file=out)

    self.dihedrals = angles.dihedrals
    for i, rt_mx in enumerate(rt_mxs):
      print("*%s %s" %(i+1, rt_mx), file=out)

class sym_pair(libtbx.slots_getstate_setstate):

  __slots__ = ["i_seq", "j_seq", "rt_mx_ji"]

  def __init__(self, i_seq, j_seq, rt_mx_ji):
    self.i_seq = i_seq
    self.j_seq = j_seq
    self.rt_mx_ji = rt_mx_ji

  def i_seqs(self):
    return (self.i_seq, self.j_seq)

@bp.inject_into(pair_sym_table)
class _():

  def iterator(self):
    for i_seq,pair_sym_dict in enumerate(self):
      for j_seq,sym_ops in pair_sym_dict.items():
        for rt_mx_ji in sym_ops:
          yield sym_pair(i_seq=i_seq, j_seq=j_seq, rt_mx_ji=rt_mx_ji)

  def tidy(self, site_symmetry_table):
    result = pair_sym_table(size=self.size())
    for i_seq,pair_sym_dict in enumerate(self):
      for j_seq,sym_ops in pair_sym_dict.items():
        sepi_objs = []
        for rt_mx_ji in sym_ops:
          if (i_seq <= j_seq):
            i, j = i_seq, j_seq
          else:
            i, j, rt_mx_ji = j_seq, i_seq, rt_mx_ji.inverse()
          for sepi_obj in sepi_objs:
            if (sepi_obj.is_equivalent(rt_mx_ji=rt_mx_ji)):
              break
          else:
            sepi_obj = site_symmetry_table \
              .symmetry_equivalent_pair_interactions(
                i_seq=i, j_seq=j, rt_mx_ji=rt_mx_ji)
            sepi_objs.append(sepi_obj)
        ri = result[i]
        ri[j] = pair_sym_ops()
        rij = ri[j]
        for rt_mx_ji in sorted([sepi_obj.get()[0] for sepi_obj in sepi_objs]):
          rij.append(rt_mx_ji)
    return result

  def full_connectivity(self, site_symmetry_table=None):
    result = pair_sym_table(size=self.size())
    for i_seq,pair_sym_dict in enumerate(self):
      ri = result[i_seq]
      for j_seq,sym_ops in pair_sym_dict.items():
        rij = ri.get(j_seq)
        if (rij is None):
          ri[j_seq] = pair_sym_ops()
          rij = ri[j_seq]
        rj = result[j_seq]
        rji = rj.get(i_seq)
        if (rji is None):
          rj[i_seq] = pair_sym_ops()
          rji = rj[i_seq]
        for rt_mx_ji in sym_ops:
          if (site_symmetry_table is None):
            rij.append(rt_mx_ji)
            if (i_seq != j_seq):
              rji.append(rt_mx_ji.inverse())
          else:
            sepi = site_symmetry_table.symmetry_equivalent_pair_interactions
            for s in sepi(
                       i_seq=i_seq,
                       j_seq=j_seq,
                       rt_mx_ji=rt_mx_ji).get():
              rij.append(s)
            if (i_seq != j_seq):
              for s in sepi(
                         i_seq=j_seq,
                         j_seq=i_seq,
                         rt_mx_ji=rt_mx_ji.inverse()).get():
                rji.append(s)
    return result

  def show(self, f=None,
        site_labels=None,
        site_symmetry_table=None,
        sites_frac=None,
        unit_cell=None):
    if (site_labels is not None):
      assert len(site_labels) == self.size()
    if (sites_frac is not None):
      assert len(sites_frac) == self.size()
      assert unit_cell is not None
    if (site_symmetry_table is not None):
      assert site_symmetry_table.indices().size() == self.size()
    if (f is None): f = sys.stdout
    def show_i():
      if (site_labels is None):
        print("i_seq:", i_seq, file=f)
      else:
        print("%s(%d)" % (site_labels[i_seq], i_seq), file=f)
    def show_j():
      if (site_labels is None):
        print("  j_seq:", j_seq, file=f)
      else:
        print("  %s(%d)" % (site_labels[j_seq], j_seq), file=f)
    for i_seq,pair_sym_dict in enumerate(self):
      show_i()
      for j_seq,sym_ops in pair_sym_dict.items():
        show_j()
        if (site_symmetry_table is None):
          if (sites_frac is None):
            for rt_mx_ji in sym_ops:
              print("   ", rt_mx_ji, file=f)
          elif (len(sym_ops) > 0):
            max_len = max([len(str(_)) for _ in sym_ops])
            fmt = "    %%-%ds  %%8.4f" % max_len
            for rt_mx_ji in sym_ops:
              d = unit_cell.distance(
                sites_frac[i_seq], rt_mx_ji * sites_frac[j_seq])
              print(fmt % (str(rt_mx_ji), d), file=f)
        else:
          max_len = 0
          sepis = []
          for rt_mx_ji in sym_ops:
            sepi = site_symmetry_table.symmetry_equivalent_pair_interactions(
              i_seq=i_seq, j_seq=j_seq, rt_mx_ji=rt_mx_ji).get()
            sepis.append(sepi)
            max_len = max(max_len, max([len(str(_)) for _ in sepi]))
          if (max_len != 0):
            fmt = "    %%-%ds%%s%%s" % max_len
            for sepi in sepis:
              d = ""
              e = ""
              for s in sepi:
                if (sites_frac is not None):
                  d = "  %8.4f" % unit_cell.distance(
                    sites_frac[i_seq], s * sites_frac[j_seq])
                print((fmt % (str(s), d, e)).rstrip(), file=f)
                e = "  sym. equiv."

  def show_distances(self,
        unit_cell,
        site_symmetry_table,
        site_labels=None,
        sites_frac=None,
        sites_cart=None,
        show_cartesian=False,
        skip_j_seq_less_than_i_seq=False,
        skip_sym_equiv=False,
        out=None):
    assert [sites_frac, sites_cart].count(None) == 1
    if (out is None): out = sys.stdout
    if (sites_frac is None):
      sites_frac = unit_cell.fractionalize(sites_cart=sites_cart)
    if (site_labels is None):
      label_len = len("%d" % (sites_frac.size()+1))
      label_fmt = "site_%%0%dd" % label_len
      label_len += 5
    else:
      label_len = max(1, max([len(_) for _ in site_labels]))
      label_fmt = "%%-%ds" % (label_len+1)
    if (skip_j_seq_less_than_i_seq):
      back_interactions = None
    else:
      back_interactions = [set() for _ in range(self.size())]
      for i_seq,pair_sym_dict in enumerate(self):
        for j_seq,sym_ops in pair_sym_dict.items():
          if (j_seq != i_seq):
            assert i_seq < j_seq
            back_interactions[j_seq].add(i_seq)
    pair_counts = flex.size_t()
    for i_seq,pair_sym_dict in enumerate(self):
      site_frac_i = sites_frac[i_seq]
      distance_info = []
      def distance_info_append(j_seq, rt_mx_ji):
        site_frac_ji = rt_mx_ji * sites_frac[j_seq]
        sepi = site_symmetry_table.symmetry_equivalent_pair_interactions(
          i_seq=i_seq, j_seq=j_seq, rt_mx_ji=rt_mx_ji).get()
        distance_info.append([
          unit_cell.distance(site_frac_i, site_frac_ji),
          j_seq,
          rt_mx_ji,
          sepi])
      for j_seq,sym_ops in pair_sym_dict.items():
        for rt_mx_ji in sym_ops:
          distance_info_append(j_seq, rt_mx_ji)
      if (back_interactions is not None):
        for j_seq in back_interactions[i_seq]:
          for rt_mx_ji_inv in self[j_seq][i_seq]:
            distance_info_append(j_seq, rt_mx_ji_inv.inverse())
      distance_info.sort()
      if (skip_sym_equiv):
        pair_count = len(distance_info)
      else:
        pair_count = sum([len(sepi) for _,_,_,sepi in distance_info])
      if (site_labels is None):
        s = label_fmt % (i_seq+1)
      else:
        s = label_fmt % site_labels[i_seq]
      s += " pair count: %3d" % pair_count
      if (show_cartesian):
        formatted_site = [" %7.2f" % x
          for x in unit_cell.orthogonalize(site_frac_i)]
      else:
        formatted_site = [" %7.4f" % x for x in site_frac_i]
      print(("%%-%ds" % (label_len+23)) % s, \
        "<<"+",".join(formatted_site)+">>", file=out)
      for distance,j_seq,_,sepi in distance_info:
        sym_equiv = "           "
        for rt_mx_ji_equiv in sepi:
          if (site_labels is None):
            print(" ", label_fmt % (j_seq+1) + ":", end=' ', file=out)
          else:
            print(" ", label_fmt % (site_labels[j_seq] + ":"), end=' ', file=out)
          print("%8.4f" % distance, end=' ', file=out)
          s = sym_equiv
          sym_equiv = "sym. equiv."
          site_frac_ji_equiv = rt_mx_ji_equiv * sites_frac[j_seq]
          if (show_cartesian):
            formatted_site = [" %7.2f" % x
              for x in unit_cell.orthogonalize(site_frac_ji_equiv)]
          else:
            formatted_site = [" %7.4f" % x for x in site_frac_ji_equiv]
          s += " (" + ",".join(formatted_site) +")"
          if (not rt_mx_ji_equiv.is_unit_mx()):
            s += " sym=" + str(rt_mx_ji_equiv)
          print(s, file=out)
          if (skip_sym_equiv):
            break
      if (pair_count == 0):
        print("  no neighbors", file=out)
      pair_counts.append(pair_count)
    return pair_counts

  def number_of_pairs_involving_symmetry(self):
    result = 0
    for i_seq,pair_sym_dict in enumerate(self):
      for j_seq,sym_ops in pair_sym_dict.items():
        for sym_op in sym_ops:
          if (not sym_op.is_unit_mx()):
            result += 1
    return result

  def simple_edge_list(self):
    result = []
    for i_seq,pair_sym_dict in enumerate(self):
      for j_seq,sym_ops in pair_sym_dict.items():
        for sym_op in sym_ops:
          if (sym_op.is_unit_mx()):
            result.append((i_seq, j_seq))
            break
    return result

  def symmetry_edge_list(self):
    result = []
    for i_seq,pair_sym_dict in enumerate(self):
      for j_seq,sym_ops in pair_sym_dict.items():
        for sym_op in sym_ops:
          if not (sym_op.is_unit_mx()):
            result.append((i_seq, j_seq, sym_op))
    return result

  def both_edge_list(self):
    simple = []
    sym = []
    for i_seq,pair_sym_dict in enumerate(self):
      for j_seq,sym_ops in pair_sym_dict.items():
        for sym_op in sym_ops:
          if (sym_op.is_unit_mx()):
            simple.append((i_seq, j_seq))
          else:
            sym.append((i_seq, j_seq, sym_op))
    return simple, sym

  def full_simple_connectivity(self):
    result = shared.stl_set_unsigned(self.size())
    for i_seq,pair_sym_dict in enumerate(self):
      for j_seq,sym_ops in pair_sym_dict.items():
        for sym_op in sym_ops:
          if (sym_op.is_unit_mx()):
            result[i_seq].insert(j_seq)
            result[j_seq].insert(i_seq)
            break
    return result

  def is_paired(self, i_seq):
    if (self[i_seq].size() != 0): return True
    for pair_sym_dict in self:
      if (i_seq in pair_sym_dict): return True
    return False

  def discard_symmetry(self):
    result = pair_sym_table()
    sym_ops = sgtbx.space_group().all_ops()
    for i_seq,self_pair_sym_dict in enumerate(self):
      d = pair_sym_dict()
      for j_seq in self_pair_sym_dict.keys():
        d[j_seq] = sym_ops
      result.append(d)
    return result

  def add_pair_sym_table_in_place(self, other):
    self_size = self.size()
    assert other.size() <= self_size
    for self_pair_sym_dict,other_pair_sym_dict in zip(self, other):
      for j_seq,other_sym_ops in other_pair_sym_dict.items():
        assert j_seq < self_size
        self_pair_sym_dict.setdefault(j_seq)
        self_pair_sym_dict[j_seq].extend(other_sym_ops)

class _clustering_mix_in(object):

  def sites_cart(self):
    return self.special_position_settings.unit_cell().orthogonalize(
      sites_frac=self.sites_frac)

  def tidy_index_groups_in_place(self):
    cluster_sizes = flex.size_t()
    for ig in self.index_groups:
      cluster_sizes.append(len(ig))
    permutation = flex.sort_permutation(cluster_sizes, reverse=True)
    sorted_index_groups = flex.select(
      sequence=self.index_groups,
      permutation=permutation)
    index_groups = []
    for i,ig in enumerate(sorted_index_groups):
      if (len(ig) == 0): break
      ig = flex.size_t(ig)
      index_groups.append(ig.select(flex.sort_permutation(data=ig)))
    self.index_groups = index_groups
    return self

def _priorities_based_on_cluster_size(scores, index_groups):
  cluster_sizes = flex.size_t()
  for ig in index_groups:
    cluster_sizes.append(len(ig))
  permutation = flex.sort_permutation(cluster_sizes, reverse=True)
  sorted_index_groups = flex.select(
    sequence=index_groups,
    permutation=permutation)
  priorities = flex.size_t()
  for i,ig in enumerate(sorted_index_groups):
    ig = flex.size_t(ig)
    priorities.extend(ig.select(
     flex.sort_permutation(data=scores.select(ig), reverse=True)))
  return priorities

class incremental_clustering(_clustering_mix_in):

  def __init__(self,
        special_position_settings,
        sites_cart,
        distance_cutoffs,
        scores=None,
        discard_special_positions=False,
        discard_not_strictly_inside_asu=False,
        initial_required_cluster_size=0):
    self.special_position_settings = special_position_settings
    self.distance_cutoffs = distance_cutoffs
    unit_cell = special_position_settings.unit_cell()
    sites_frac = unit_cell.fractionalize(sites_cart=sites_cart)
    site_symmetry_table = special_position_settings.site_symmetry_table(
      sites_frac=sites_frac)
    if (not discard_special_positions):
      for i_seq in site_symmetry_table.special_position_indices():
        sites_frac[i_seq] = site_symmetry_table.get(i_seq).special_op() \
                          * sites_frac[i_seq]
    else:
      selection = ~flex.bool(
        sites_frac.size(),
        site_symmetry_table.special_position_indices())
      site_symmetry_table = site_symmetry_table.select(selection)
      assert site_symmetry_table.n_special_positions() == 0
      sites_frac = sites_frac.select(selection)
      if (scores is not None):
        scores = scores.select(selection)
    if (discard_not_strictly_inside_asu):
      selection = special_position_settings \
        .direct_space_asu() \
        .as_float_asu().is_inside_frac(sites_frac=sites_frac)
      site_symmetry_table = site_symmetry_table.select(selection)
      sites_frac = sites_frac.select(selection)
      if (scores is not None):
        scores = scores.select(selection)
    n_sites = sites_frac.size()
    assignments = flex.size_t(range(n_sites))
    n_clusters = n_sites
    index_groups = [[i_seq] for i_seq in range(n_sites)]
    symmetry_ops = [special_position_settings.space_group()(0)] * n_sites
    get_distance = unit_cell.distance
    for i_distance_cutoff,distance_cutoff in enumerate(distance_cutoffs):
      if (n_clusters == 1): break
      asu_mappings = special_position_settings.asu_mappings(
        buffer_thickness=distance_cutoff,
        sites_frac=sites_frac,
        site_symmetry_table=site_symmetry_table)
      pair_asu_tab = pair_asu_table(asu_mappings=asu_mappings)
      pair_asu_tab.add_all_pairs(distance_cutoff=distance_cutoff)
      if (scores is None):
        scores = pair_asu_tab.pair_counts()
      if (n_clusters == n_sites):
        priorities = flex.sort_permutation(data=scores, reverse=True)
      else:
        priorities = _priorities_based_on_cluster_size(
          scores=scores,
          index_groups=index_groups)
      for i_seq in priorities:
        i_cluster = assignments[i_seq]
        if (    i_distance_cutoff != 0
            and i_distance_cutoff != len(distance_cutoffs)-1
            and len(index_groups[i_cluster])<initial_required_cluster_size):
          continue
        rt_mx_ip = asu_mappings.get_rt_mx(i_seq, 0)
        site_ip = rt_mx_ip * sites_frac[i_seq]
        j_seq_dict = pair_asu_tab.table()[i_seq]
        for j_seq,j_sym_group in j_seq_dict.items():
          j_cluster = assignments[j_seq]
          if (j_cluster == i_cluster): continue
          if (    i_distance_cutoff != 0
              and i_distance_cutoff != len(distance_cutoffs)-1
              and len(index_groups[j_cluster])<initial_required_cluster_size):
            continue
          smallest_distance = distance_cutoff*(1+1.e-6)
          best_rt_mx_jp = None
          for j_syms in j_sym_group:
            j_sym = j_syms[0]
            rt_mx_jp = asu_mappings.get_rt_mx(j_seq, j_sym)
            site_jp = rt_mx_jp * sites_frac[j_seq]
            distance = get_distance(site_ip, site_jp)
            if (smallest_distance > distance):
              smallest_distance = distance
              best_rt_mx_jp = rt_mx_jp
          assert best_rt_mx_jp is not None
          rt_mx_jp = best_rt_mx_jp
          if (   len(index_groups[i_cluster])
              >= len(index_groups[j_cluster])):
            rt_mx_c = symmetry_ops[i_seq].multiply(
              rt_mx_ip.inverse().multiply(
                rt_mx_jp.multiply(
                  symmetry_ops[j_seq].inverse())))
            for c_seq in index_groups[j_cluster]:
              index_groups[i_cluster].append(c_seq)
              assignments[c_seq] = i_cluster
              symmetry_ops[c_seq] = rt_mx_c.multiply(symmetry_ops[c_seq])
            index_groups[j_cluster] = []
          else:
            rt_mx_c = symmetry_ops[j_seq].multiply(
              rt_mx_jp.inverse().multiply(
                rt_mx_ip.multiply(
                  symmetry_ops[i_seq].inverse())))
            for c_seq in index_groups[i_cluster]:
              index_groups[j_cluster].append(c_seq)
              assignments[c_seq] = j_cluster
              symmetry_ops[c_seq] = rt_mx_c.multiply(symmetry_ops[c_seq])
            index_groups[i_cluster] = []
            i_cluster = j_cluster
          n_clusters -= 1
    assert n_clusters > 0
    for i_seq,site_frac in enumerate(sites_frac):
      sites_frac[i_seq] = symmetry_ops[i_seq] * site_frac
    self.sites_frac = sites_frac
    self.index_groups = index_groups

class distance_based_clustering(_clustering_mix_in):

  def __init__(self,
        special_position_settings,
        sites_cart,
        distance_cutoff,
        discard_special_positions=False):
    self.special_position_settings = special_position_settings
    self.distance_cutoff = distance_cutoff
    unit_cell = special_position_settings.unit_cell()
    sites_frac = unit_cell.fractionalize(sites_cart=sites_cart)
    site_symmetry_table = special_position_settings.site_symmetry_table(
      sites_frac=sites_frac)
    if (not discard_special_positions):
      for i_seq in site_symmetry_table.special_position_indices():
        sites_frac[i_seq] = site_symmetry_table.get(i_seq).special_op() \
                          * sites_frac[i_seq]
    else:
      selection = ~flex.bool(
        sites_frac.size(),
        site_symmetry_table.special_position_indices())
      site_symmetry_table = site_symmetry_table.select(selection)
      assert site_symmetry_table.n_special_positions() == 0
      sites_frac = sites_frac.select(selection)
    n_sites = sites_frac.size()
    assignments = flex.size_t(range(n_sites))
    n_clusters = n_sites
    index_groups = [[i_seq] for i_seq in range(n_sites)]
    symmetry_ops = [special_position_settings.space_group()(0)] * n_sites
    asu_mappings = special_position_settings.asu_mappings(
      buffer_thickness=distance_cutoff,
      sites_frac=sites_frac,
      site_symmetry_table=site_symmetry_table)
    pair_asu_tab = pair_asu_table(asu_mappings=asu_mappings)
    pair_asu_tab.add_all_pairs(distance_cutoff=distance_cutoff)
    pair_sym_tab = pair_asu_tab.extract_pair_sym_table()
    sym_pairs = []
    distances = flex.double()
    get_distance = unit_cell.distance
    for pair in pair_sym_tab.iterator():
      site_i = sites_frac[pair.i_seq]
      site_j = sites_frac[pair.j_seq]
      site_ji = pair.rt_mx_ji * site_j
      distance = get_distance(site_i, site_ji)
      assert distance <= distance_cutoff * (1+1.e-6), distance
      sym_pairs.append(pair)
      distances.append(distance)
    priorities = flex.sort_permutation(data=distances)
    for i_pair in priorities:
      if (n_clusters == 1): break
      pair = sym_pairs[i_pair]
      i_seq = pair.i_seq
      j_seq = pair.j_seq
      i_cluster = assignments[i_seq]
      j_cluster = assignments[j_seq]
      if (i_cluster == j_cluster): continue
      if (   len(index_groups[i_cluster])
          >= len(index_groups[j_cluster])):
        rt_mx_c = symmetry_ops[i_seq].multiply(
          pair.rt_mx_ji.multiply(
            symmetry_ops[j_seq].inverse()))
        for c_seq in index_groups[j_cluster]:
          index_groups[i_cluster].append(c_seq)
          assignments[c_seq] = i_cluster
          symmetry_ops[c_seq] = rt_mx_c.multiply(symmetry_ops[c_seq])
        index_groups[j_cluster] = []
      else:
        rt_mx_c = symmetry_ops[j_seq].multiply(
          pair.rt_mx_ji.inverse().multiply(
            symmetry_ops[i_seq].inverse()))
        for c_seq in index_groups[i_cluster]:
          index_groups[j_cluster].append(c_seq)
          assignments[c_seq] = j_cluster
          symmetry_ops[c_seq] = rt_mx_c.multiply(symmetry_ops[c_seq])
        index_groups[i_cluster] = []
      n_clusters -= 1
      assert abs(get_distance(
        symmetry_ops[i_seq]*sites_frac[i_seq],
        symmetry_ops[j_seq]*sites_frac[j_seq]) - distances[i_pair]) < 1.e-6
    assert n_clusters > 0
    for i_seq,site_frac in enumerate(sites_frac):
      sites_frac[i_seq] = symmetry_ops[i_seq] * site_frac
    self.sites_frac = sites_frac
    self.index_groups = index_groups

def cluster_erosion(sites_cart, box_size, fraction_to_be_retained):
  from scitbx import matrix
  from libtbx.math_utils import iceil
  lower_left = matrix.col(sites_cart.min())
  upper_right = matrix.col(sites_cart.max())
  sites_span = upper_right - lower_left
  n_boxes = matrix.col([iceil(x/box_size) for x in sites_span])
  box_span = n_boxes * box_size
  sites_center = (lower_left + upper_right) / 2
  box_origin = sites_center - box_span / 2
  box_coordinates = (sites_cart - box_origin) * (1./box_size)
  box_grid = flex.grid(n_boxes)
  box_counts = flex.size_t(box_grid.size_1d(), 0)
  box_members = [flex.size_t() for i in range(box_counts.size())]
  for i_seq,x in enumerate(box_coordinates):
    box_index_3d = [max(0, min(int(i), n)) for i,n in zip(x, n_boxes)]
    box_index_1d = box_grid(box_index_3d)
    box_counts[box_index_1d] += 1
    box_members[box_index_1d].append(i_seq)
  perm = flex.sort_permutation(data=box_counts, reverse=True)
  box_counts_sorted = box_counts.select(perm)
  threshold = sites_cart.size() * fraction_to_be_retained
  sum_counts = 0
  for required_counts in box_counts_sorted:
    sum_counts += required_counts
    if (sum_counts > threshold):
      break
  del box_counts_sorted
  del perm
  site_selection = flex.size_t()
  for i_box in (box_counts >= required_counts).iselection():
    site_selection.extend(box_members[i_box])
  return site_selection

def unit_crystal_symmetry():
  # returns crystal symmetry with unit cell=(1,1,1,90,90,90), sg=1
  sg=sgtbx.space_group_info(symbol='P1')
  uc=uctbx.unit_cell((1,1,1,90,90,90))
  from cctbx import crystal
  return crystal.symmetry(unit_cell=uc,space_group_info=sg)

bp.inject(ext.neighbors_simple_pair_generator, bp.py3_make_iterator)
bp.inject_into(ext.neighbors_fast_pair_generator, bp.py3_make_iterator)


 *******************************************************************************


 *******************************************************************************
cctbx/crystal/burzlaff_zimmermann_dewolff.py
'''
Reference implementation of BZW lattice characters, from Table 9.3.1 of
the International Tables.  Use of this method is not recommended.  See
counterexamples given below.

Literature:  Crystal lattices. H. Burzlaff, H. Zimmermann and P.M. de Wolff.
In International Tables for Cyrstallography, Volume A: Space-group symmetry
ed. Theo Hahn.  Dordrecht: Kluwer Academic Publishers (1996).
Note correction in the lattice_text table as given by W. Kabsch,
J. Appl. Cryst. 26: 795-800 (1993).  The 1996 edition of International
Tables is apparently uncorrected from the 1989 edition.

Author: N.K. Sauter
'''
from __future__ import absolute_import, division, print_function

from cctbx import crystal
from cctbx.uctbx import unit_cell
from scitbx import matrix
from cctbx.sgtbx.lattice_symmetry import metric_subgroups
import math
import sys

class MetricCriteria(object):
  def equal(self,A,B):
    # A == B within stated fractional tolerance
    if self.int_tol < A/B < 1./self.int_tol or \
       self.int_tol < B/A < 1./self.int_tol: return True
    else: return False

  def equal_penalty(self,A,B):
    ratio = A/B
    # assume ratio is positive; it could only be negative for those lattice
    #  characters that have failed the tolerance tests, and penalty scores
    #  will be irrelevant in those cases.
    if ratio > 1.0: ratio = 1./ratio
    return 1.-ratio

  def zero(self,Product,B):
    """
    Product == 0 within fractional tolerance referred to by the quantities B.
    Usage: zero(D,(B,C)) | zero(E,(A,C)) | zero(F,(A,B))
    Only these combinations can be used.  This translates exactly into
    a tolerance on right angle, based on formula D=b.dot(c)=|b||c|cos(theta)
    internal_tolerance=0.97 corresponds to 1.72 degrees."""
    ldot = B[0]
    rdot = B[1]
    if abs(Product/math.sqrt(ldot*rdot)) < (1.-self.int_tol):  return True
    else: return False

  def zero_penalty(self,Product,B):
    ldot = B[0]
    rdot = B[1]
    return abs(Product/math.sqrt(ldot*rdot))

  def __init__(self,unit_cell,int_tol = 0.97):
    def criteria_encoding():
      return {

      1:[AB, AC, Type(1), equal(A/2.,D), equal(A/2.,E),equal(A/2.,F)],
      2:[AB, AC, Type(1), equal(E,D), equal(F,D)],
      3:[AB, AC, Type(2), D0, E0, F0],
      5:[AB, AC, Type(2), equal(-A/3.,D), equal(-A/3.,E),equal(-A/3.,F)],
      4:[AB, AC, Type(2), equal(E,D), equal(F,D)],
      6:[AB, AC, Type(2), Dstar, equal(E,D)],
      7:[AB, AC, Type(2), Dstar, equal(F,E)],
      8:[AB, AC, Type(2), Dstar],

       9:[AB, Type(1), equal(A/2.,D), equal(A/2.,E), equal(A/2.,F)],
      10:[AB, Type(1), equal(E,D)],
      11:[AB, Type(2), D0, E0, F0],
      12:[AB, Type(2), D0, E0, equal(-A/2.,F)],
      13:[AB, Type(2), D0, E0],
      15:[AB, Type(2), equal(-A/2.,D), equal(-A/2.,E), F0],
      16:[AB, Type(2), Dstar,equal(E,D)],
      14:[AB, Type(2), equal(E,D)],
      17:[AB, Type(2), Dstar],

      18:[BC, Type(1), equal(A/4.,D), equal(A/2.,E), equal(A/2.,F)],
      19:[BC, Type(1), equal(A/2.,E), equal(A/2.,F)],
      20:[BC, Type(1), equal(F,E)],
      21:[BC, Type(2), D0, E0, F0],
      22:[BC, Type(2), equal(-B/2.,D), E0, F0],
      23:[BC, Type(2), E0, F0],
      24:[BC, Type(2), Dstar, equal(-A/3.,E), equal(-A/3.,F)],
      25:[BC, Type(2), equal(F,E)],

      26:[Type(1), equal(A/4.,D), equal(A/2.,E), equal(A/2.,F)],
      27:[Type(1), equal(A/2.,E), equal(A/2.,F)],
      28:[Type(1), equal(A/2.,E), equal(2.*D,F)],
      29:[Type(1), equal(2.*D,E), equal(A/2.,F)],
      30:[Type(1), equal(B/2.,D), equal(2.*E,F)],
      31:[Type(1)],

      32:[Type(2), D0, E0, F0],
      40:[Type(2), equal(-B/2.,D), E0, F0],
      35:[Type(2), E0, F0],
      36:[Type(2), D0, equal(-A/2.,E), F0],
      33:[Type(2), D0, F0],
      38:[Type(2), D0, E0, equal(-A/2.,F)],
      34:[Type(2), D0, E0],
      42:[Type(2), equal(-B/2.,D), equal(-A/2.,E), F0],
      41:[Type(2), equal(-B/2.,D), F0],
      37:[Type(2), equal(-A/2.,E), F0],
      39:[Type(2), E0, equal(-A/2.,F)],
      43:[Type(2), Dstar, equal(abs(2*D+F),B)],
      44:[Type(2)],

    }
    self.int_tol = int_tol

    unit_cell = self.apply_sign_correction(unit_cell)

    mm = unit_cell.metrical_matrix()
    A=mm[0]; B=mm[1]; C=mm[2]; D=mm[5]; E=mm[4]; F=mm[3];
    #print "%.0f %.0f %.0f %.0f %.0f %.0f"%(A,B,C,D,E,F)

    #Part 1.  Encoded criteria give True / False answers
    equal = self.equal
    zero = self.zero
    D0 = zero(D,(B,C))
    E0 = zero(E,(A,C))
    F0 = zero(F,(A,B))
    if D*E*F <= 0: fType=2
    elif D0 or E0 or F0:
      # should never get here if sign correction has been applied
      # cell must be treated as Type 2 even though numerically Type 1
      fType=2
    else: fType=1
    def Type(flag):
      return flag==fType

    AB = equal(A,B)
    BC = equal(B,C)
    AC = equal(A,C)

    Dstar = equal(2*abs(D+E+F),A+B)

    self.metric_tests = criteria_encoding()

    #Part 2.  Encoded criteria give numerical penalty scores
    equal = self.equal_penalty
    zero = self.zero_penalty
    D0 = zero(D,(B,C))
    E0 = zero(E,(A,C))
    F0 = zero(F,(A,B))
    if D*E*F <= 0: type_penalty = (0.0,0.0,0.0) #type 2
    elif Type(2): type_penalty = (0.0,0.0,min(D0,E0,F0)) #type 2
    else: type_penalty = (0.0,0.0,0.0) # type 1
    def Type(flag):
      return type_penalty[flag]

    AB = equal(A,B)
    BC = equal(B,C)
    AC = equal(A,C)

    Dstar = equal(2*abs(D+E+F),A+B)

    self.penalties = criteria_encoding()

    if (False): # for debugging
      for key in self.penalties:
        print(key, self.metric_tests[key], [
          "%4.2f%%"%(100.*x) for x in self.penalties[key]])

  def apply_sign_correction(self,cell):
    # Function helps accomodate the tolerance.  Cell reduction may
    # produce a mathematically type=1 cell (DEF>0), which however has D~0, or
    # E~0 or F~0.  Therefore for practical purposes it is considered type=2
    # The basis must then be inverted to make it behave similarly to
    # a mathematically type=2 basis.
    # Several of the counterexamples produce correct results if this cor-
    # rection is applied; but wrong results if the correction is commented out

    mm = cell.metrical_matrix()
    A=mm[0]; B=mm[1]; C=mm[2]; D=mm[5]; E=mm[4]; F=mm[3];
    D0 = self.zero(D,(B,C))
    E0 = self.zero(E,(A,C))
    F0 = self.zero(F,(A,B))
    if D*E*F > 0 and (D0 or E0 or F0):
      #print "%.0f %.0f %.0f %.0f %.0f %.0f"%(A,B,C,D,E,F)
      # Program only gets here if either 0 or 2 of D,E,F are negative,
      # and if D~0 or E~0 or F~0
      orth = matrix.sqr(cell.orthogonalization_matrix())
      if D0 and E0:
        if F>0: inversion = matrix.sqr((-1.,0.,0.,0.,1.,0.,0.,0.,-1.))
      elif E0 and F0:
        if D>0: inversion = matrix.sqr((-1.,0.,0.,0.,-1.,0.,0.,0.,1.))
      elif F0 and D0:
        if E>0: inversion = matrix.sqr((1.,0.,0.,0.,-1.,0.,0.,0.,-1.))
      elif E0 and F>0: inversion = matrix.sqr((-1.,0.,0.,0.,1.,0.,0.,0.,-1.))
      elif F0 and D>0: inversion = matrix.sqr((-1.,0.,0.,0.,-1.,0.,0.,0.,1.))
      elif D0 and E>0: inversion = matrix.sqr((1.,0.,0.,0.,-1.,0.,0.,0.,-1.))
      uc = unit_cell(orthogonalization_matrix=orth*inversion)
      print("Adjusted cell:",uc)
      return uc
    return cell

  def character_tests(self,):
    return self.metric_tests

  def penalty_scores(self,):
    return self.penalties

lattice_text = '''
1         cubic  cF  1,-1,1,1,1,-1,-1,1,1
2  rhombohedral  hR  1,-1,0,-1,0,1,-1,-1,-1
3         cubic  cP  1,0,0,0,1,0,0,0,1
5         cubic  cI  1,0,1,1,1,0,0,1,1
4  rhombohedral  hR  1,-1,0,-1,0,1,-1,-1,-1
6    tetragonal  tI  0,1,1,1,0,1,1,1,0
7    tetragonal  tI  1,0,1,1,1,0,0,1,1
8  orthorhombic  oI  -1,-1,0,-1,0,-1,0,-1,-1
9  rhombohedral  hR  1,0,0,-1,1,0,-1,-1,3
10   monoclinic  mC  1,1,0,1,-1,0,0,0,-1
11   tetragonal  tP  1,0,0,0,1,0,0,0,1
12    hexagonal  hP  1,0,0,0,1,0,0,0,1
13 orthorhombic  oC  1,1,0,-1,1,0,0,0,1
15   tetragonal  tI  1,0,0,0,1,0,1,1,2
16 orthorhombic  oF  -1,-1,0,1,-1,0,1,1,2
14   monoclinic  mC  1,1,0,-1,1,0,0,0,1
17   monoclinic  mC  1,-1,0,-1,-1,0,-1,0,-1
18   tetragonal  tI  0,-1,1,1,-1,-1,1,0,0
19 orthorhombic  oI  -1,0,0,0,-1,1,-1,1,1
20   monoclinic  mC  0,1,1,0,1,-1,-1,0,0
21   tetragonal  tP  0,1,0,0,0,1,1,0,0
22    hexagonal  hP  0,1,0,0,0,1,1,0,0
23 orthorhombic  oC  0,1,1,0,-1,1,1,0,0
24 rhombohedral  hR  1,2,1,0,-1,1,1,0,0
25   monoclinic  mC  0,1,1,0,-1,1,1,0,0
26 orthorhombic  oF  1,0,0,-1,2,0,-1,0,2
27   monoclinic  mC  -1,2,0,-1,0,0,0,-1,1
28   monoclinic  mC  -1,0,0,-1,0,2,0,1,0
29   monoclinic  mC  1,0,0,1,-2,0,0,0,-1
30   monoclinic  mC  0,1,0,0,1,-2,-1,0,0
31    triclinic  aP  1,0,0,0,1,0,0,0,1
32 orthorhombic  oP  1,0,0,0,1,0,0,0,1
40 orthorhombic  oC  0,-1,0,0,1,2,-1,0,0
35   monoclinic  mP  0,-1,0,-1,0,0,0,0,-1
36 orthorhombic  oC  1,0,0,-1,0,-2,0,1,0
33   monoclinic  mP  1,0,0,0,1,0,0,0,1
38 orthorhombic  oC  -1,0,0,1,2,0,0,0,-1
34   monoclinic  mP  -1,0,0,0,0,-1,0,-1,0
42 orthorhombic  oI  -1,0,0,0,-1,0,1,1,2
41   monoclinic  mC  0,-1,-2,0,-1,0,-1,0,0
37   monoclinic  mC  1,0,2,1,0,0,0,1,0
39   monoclinic  mC  -1,-2,0,-1,0,0,0,0,-1
43   monoclinic  mI  -1,0,0,-1,-1,-2,0,-1,0
44    triclinic  aP  1,0,0,0,1,0,0,0,1
'''

lattices = []

for line in lattice_text.split('\n')[1:-1]:
  line = line.strip()
  items = line.split()
  d = {'number':int(items[0]),
       'system':items[1],
       'bravais':items[2],
       'matrix':tuple([int(x) for x in items[3].split(',')])
       }
  lattices.append(d)

class LatticeCharacter(object):
  #assumes that unit_cell is already in primitive setting and NIGGLI reduced
  # tolerance is given as a percentage
  def __init__(self,unit_cell,tolerance=3.):
    self.unit_cell = unit_cell
    self.int_tol = 1.0 - tolerance/100.
    self.possible_characters = self.best_bravais__()

  def best(self):
    return self.possible_charcters[0]

  def all(self):
    return self.possible_characters

  def show_summary(self):
    for item in self.possible_characters:
      print("%2d: %2s %14s, matrix"%(item['number'],item['bravais'],
            item['system']), end=' ')
      print("%30s"%str(item['matrix']), end=' ')
      print("max_penalty=%4.2f%%"%(100.*item['penalty']))

  def show_summary_labelit_format(self):
    for item in self.possible_characters:
      print("    %2d"%(item['number'],), end=' ')
      print("     %4.2f%%"%(100.*item['penalty'],), end=' ')
      print("               %14s %2s"%(item['system'],item['bravais'],), end=' ')
      print("%30s"%str(item['matrix']))

  def best_bravais__(self):
    MC = MetricCriteria(self.unit_cell,self.int_tol)
    answers = []
    for character in lattices:
      if not False in MC.character_tests()[character['number']]:
        character['penalty'] = max(MC.penalty_scores()[character['number']])
        answers.append(character)
    return answers

def counterexamples():

  for example in [
    # Stated example known to be hR, Table lookup gives mC
    (143.11386252141878, 143.60212158695211, 191.65636462983394,
     90.01331794194698, 111.85072371897915, 119.88503851099796),

    # Stated examples known to be oC, Table lookup gives mP
    # ...but applying sign correction produces oC.
    (121.48, 122.45, 144.06,  89.94,  65.09,  89.99),
    (121.39, 122.16, 143.98,  89.94,  65.24,  89.97),

    # Stated examples known to be hP, Table lookup gives oC
    # ...but applying sign correction produces hP
    (81.003144781582421, 81.130355147032134, 169.50959209067071,
     89.896542797449115, 89.999041351249176, 60.10397864241261),
    (81.88,  81.92, 170.38,  89.95,  89.98,  60.04),
    (81.84,  81.85, 169.28,  89.94,  89.97,  60.02),
    (149.74, 149.89, 154.90, 89.96,  89.77,  60.10),

    # Stated example known to be tP, Table lookup gives oP
    (64.5259, 65.5211, 140.646,  90.0599,  90.0254,  90.0023),

    # Stated example known to be tI, Table lookup gives oI
    (100.66, 100.78, 101.00, 116.96,  95.54, 116.63), ]:

    uc = unit_cell(example)
    assert uc.is_niggli_cell()
    print("Input Niggli cell:",uc)
    print("BZW Table lookup:")
    LatticeCharacter(uc,3.0).show_summary()

    input_symmetry = crystal.symmetry(
      unit_cell=uc,space_group_symbol="P 1")
    Groups = metric_subgroups(input_symmetry, 3.0)
    Groups.show()
    print();print()

def run():
  if len(sys.argv) < 2:
    counterexamples()
    sys.exit()
  # first six arguments are unit cell parameters a,b,c,alpha,beta,gamma
  # (degrees)
  params = [float(i) for i in sys.argv[1:7]]
  uc = unit_cell(params)
  niggli = uc.is_niggli_cell()
  print("Input cell:",uc,['is not Niggli reduced','is Niggli reduced'][niggli])
  if not niggli:
    uc = uc.niggli_cell()
    print("Niggli cell:",uc)
  # last argument is percent tolerance; default 3%
  tolerance = float(sys.argv[7])
  LatticeCharacter(uc,tolerance).show_summary()

if __name__=='__main__':
  run()


 *******************************************************************************


 *******************************************************************************
cctbx/crystal/close_packing.py
from __future__ import absolute_import, division, print_function
from cctbx import crystal
from cctbx import sgtbx

hexagonal_sampling_generator=crystal.close_packing_hexagonal_sampling_generator

class setup_hexagonal_sampling(object):

  def __init__(self, crystal_symmetry, symmetry_flags):
    self.cb_op_original_to_sampling = crystal_symmetry \
      .change_of_basis_op_to_reference_setting()
    point_group_type = crystal_symmetry.space_group().point_group_type()
    add_cb_op = {"2": "z,x,y",
                 "m": "y,z,x"}.get(point_group_type, None)
    if (add_cb_op is not None):
      self.cb_op_original_to_sampling = sgtbx.change_of_basis_op(add_cb_op) \
                                      * self.cb_op_original_to_sampling
    sampling_symmetry = crystal_symmetry.change_basis(
      self.cb_op_original_to_sampling)
    search_symmetry = sgtbx.search_symmetry(
      flags=symmetry_flags,
      space_group_type=sampling_symmetry.space_group_info().type(),
      seminvariant=sampling_symmetry.space_group_info()
        .structure_seminvariants())
    expanded_symmetry = crystal.symmetry(
      unit_cell=sampling_symmetry.unit_cell(),
      space_group=search_symmetry.projected_subgroup())
    self.rational_asu = expanded_symmetry.space_group_info().direct_space_asu()
    self.rational_asu.add_planes(
      normal_directions=search_symmetry.continuous_shifts(),
      both_directions=True)
    self.float_asu=self.rational_asu.define_metric(
      unit_cell=expanded_symmetry.unit_cell()).as_float_asu()
    self.continuous_shift_flags=search_symmetry.continuous_shift_flags()

def hexagonal_sampling(crystal_symmetry,
                       symmetry_flags,
                       point_distance,
                       buffer_thickness=None,
                       all_twelve_neighbors=None):
  if (buffer_thickness is None): buffer_thickness = -1
  if (all_twelve_neighbors is None): all_twelve_neighbors = False
  s = setup_hexagonal_sampling(
    crystal_symmetry=crystal_symmetry,
    symmetry_flags=symmetry_flags)
  return hexagonal_sampling_generator(
    cb_op_original_to_sampling=s.cb_op_original_to_sampling,
    float_asu=s.float_asu,
    continuous_shift_flags=s.continuous_shift_flags,
    point_distance=point_distance,
    buffer_thickness=buffer_thickness,
    all_twelve_neighbors=all_twelve_neighbors)


 *******************************************************************************


 *******************************************************************************
cctbx/crystal/coordination_sequences.py
from __future__ import absolute_import, division, print_function
from cctbx import crystal
from cctbx import sgtbx
from cctbx.array_family import flex
from six.moves import range
from six.moves import zip

simple = crystal.coordination_sequences_simple
simple_sym = crystal.coordination_sequences_simple_sym
shell_asu_tables = crystal.coordination_sequences_shell_asu_tables
shell_sym_tables = crystal.coordination_sequences_shell_sym_tables

class node(object):

  def __init__(self, asu_mappings, i_seq, rt_mx):
    self.i_seq = i_seq
    self.rt_mx = rt_mx
    self.rt_mx_unique = str(rt_mx.multiply(asu_mappings.special_op(i_seq)))

def find_node(test_node, node_list):
  for list_node in node_list:
    if (    list_node.i_seq == test_node.i_seq
        and list_node.rt_mx_unique == test_node.rt_mx_unique):
      return True
  return False

def simple_and_slow(pair_asu_table, max_shell=10):
  asu_mappings = pair_asu_table.asu_mappings()
  term_table = []
  for i_seq_pivot,pair_asu_dict_pivot in enumerate(pair_asu_table.table()):
    rt_mx_pivot = asu_mappings.get_rt_mx(i_seq=i_seq_pivot, i_sym=0)
    if (pair_asu_dict_pivot.size() == 0):
      term_table.append([])
      continue
    nodes_middle = []
    nodes_next = [node(
      asu_mappings=asu_mappings,
      i_seq=i_seq_pivot,
      rt_mx=sgtbx.rt_mx())]
    terms = [1]
    for i_shell_minus_1 in range(max_shell):
      nodes_prev = nodes_middle
      nodes_middle = nodes_next
      nodes_next = []
      for node_m in nodes_middle:
        rt_mx_i = asu_mappings.get_rt_mx(i_seq=node_m.i_seq, i_sym=0)
        rt_mx_ni = node_m.rt_mx.multiply(rt_mx_i.inverse())
        for j_seq,j_sym_groups in pair_asu_table.table()[node_m.i_seq].items():
          for j_sym_group in j_sym_groups:
            for j_sym in j_sym_group:
              rt_mx_j = asu_mappings.get_rt_mx(i_seq=j_seq, i_sym=j_sym)
              new_node = node(
                asu_mappings=asu_mappings,
                i_seq=j_seq,
                rt_mx=rt_mx_ni.multiply(rt_mx_j))
              if (    not find_node(test_node=new_node, node_list=nodes_prev)
                  and not find_node(test_node=new_node, node_list=nodes_middle)
                  and not find_node(test_node=new_node, node_list=nodes_next)):
                nodes_next.append(new_node)
      terms.append(len(nodes_next))
    term_table.append(terms)
  return term_table

def get_kriber_coseq_file(file_name):
  result = {}
  for line in open(file_name):
    flds = line.split()
    tag = flds[0]
    terms = [int(f) for f in flds[1:]]
    result.setdefault(tag, []).append(terms)
  return result

def show_terms(structure, term_table, coseq_dict=None):
  assert len(term_table) == structure.scatterers().size()
  for scatterer,terms in zip(structure.scatterers(), term_table):
    print(scatterer.label, list(terms), end=' ')
    if (coseq_dict is not None):
      terms_to_match = list(terms[1:])
      have_match = False
      tags = list(coseq_dict.keys())
      tags.sort()
      for tag in tags:
        for coseq_terms in coseq_dict[tag]:
          n = min(len(coseq_terms), len(terms_to_match))
          if (coseq_terms[:n] == terms_to_match[:n]):
            print(tag, end=' ')
            have_match = True
      if (not have_match):
        print("Unknown", end=' ')
    print()
  sums_terms = flex.double()
  multiplicities = flex.double()
  for scatterer,terms in zip(structure.scatterers(), term_table):
    sums_terms.append(flex.sum(flex.size_t(list(terms))))
    multiplicities.append(scatterer.multiplicity())
  print("TD%d: %.2f" % (
    len(terms)-1, flex.mean_weighted(sums_terms, multiplicities)))


 *******************************************************************************


 *******************************************************************************
cctbx/crystal/direct_space_asu.py
from __future__ import absolute_import, division, print_function
from cctbx import crystal
from cctbx import sgtbx
from cctbx import uctbx
import cctbx.sgtbx.direct_space_asu
from cctbx.array_family import flex
from scitbx.math import minimum_covering_sphere
import boost_adaptbx.boost.python as bp

float_cut_plane = crystal.direct_space_asu_float_cut_plane
float_asu = crystal.direct_space_asu_float_asu
asu_mapping = crystal.direct_space_asu_asu_mapping
asu_mappings = crystal.direct_space_asu_asu_mappings

class direct_space_asu(sgtbx.direct_space_asu.direct_space_asu):

  def __init__(self, asu, unit_cell):
    sgtbx.direct_space_asu.direct_space_asu.__init__(self,
      hall_symbol=asu.hall_symbol, cuts=asu.cuts)
    self.unit_cell = unit_cell

  def minimum_covering_sphere(self, epsilon=None):
    if (epsilon is None): epsilon = 1.e-3
    points = flex.vec3_double()
    orth = self.unit_cell.orthogonalize
    for vertex in self.shape_vertices():
      points.append(orth([float(e) for e in vertex]))
    return minimum_covering_sphere(points=points, epsilon=epsilon)

  def as_float_asu(self, is_inside_epsilon=None):
    if (is_inside_epsilon is None):
      is_inside_epsilon = 1.e-6
    return float_asu(
      unit_cell=self.unit_cell,
      cuts=[cut.as_float_cut_plane() for cut in self.cuts],
      is_inside_epsilon=is_inside_epsilon)

  def add_buffer(self, thickness=None, relative_thickness=None,
                       is_inside_epsilon=None):
    return self.as_float_asu(is_inside_epsilon=is_inside_epsilon).add_buffer(
      thickness=thickness,
      relative_thickness=relative_thickness)

@bp.inject_into(float_asu)
class _():

  def add_buffer(self, thickness=None, relative_thickness=None):
    assert [thickness, relative_thickness].count(None) > 0
    if (relative_thickness is None):
      relative_thickness = 1.e-6
    if (thickness is None):
      thickness = self.unit_cell().volume()**(1/3.)*relative_thickness
    return self._add_buffer(thickness)

@bp.inject_into(asu_mappings)
class _():

  def get_rt_mx_ji(self, pair):
    return self.get_rt_mx_i(pair).inverse().multiply(self.get_rt_mx_j(pair))

def non_crystallographic_asu_mappings(
      sites_cart,
      default_buffer_layer=0.5,
      min_unit_cell_length=0):
  sites_min = sites_cart.min()
  sites_max = sites_cart.max()
  crystal_symmetry = crystal.non_crystallographic_symmetry(
      sites_cart_min=sites_min,
      sites_cart_max=sites_max,
      default_buffer_layer=default_buffer_layer,
      min_unit_cell_length=min_unit_cell_length)
  buffer_layer = uctbx.non_crystallographic_buffer_layer(
      sites_cart_min=sites_min,
      sites_cart_max=sites_max,
      default_buffer_layer=default_buffer_layer)
  sites_min = crystal_symmetry.unit_cell().fractionalize(sites_min)
  sites_max = crystal_symmetry.unit_cell().fractionalize(sites_max)
  asu_cuts = [float_cut_plane(n=n,c=c) for n,c in [
    ([1,0,0],-sites_min[0]),
    ([-1,0,0],sites_max[0]),
    ([0,1,0],-sites_min[1]),
    ([0,-1,0],sites_max[1]),
    ([0,0,1],-sites_min[2]),
    ([0,0,-1],sites_max[2]),
  ]]
  result = asu_mappings(
    space_group=crystal_symmetry.space_group(),
    asu=float_asu(
      unit_cell=crystal_symmetry.unit_cell(),
      cuts=asu_cuts).add_buffer(thickness=buffer_layer),
    buffer_thickness=0)
  result.process_sites_cart(original_sites=sites_cart)
  return result


 *******************************************************************************


 *******************************************************************************
cctbx/crystal/distance_based_connectivity.py
from __future__ import absolute_import, division, print_function
from cctbx.eltbx.distance_based_connectivity import \
  expected_bond_lengths_by_element_pair
from cctbx.eltbx.van_der_waals_radii import vdw
from scitbx.stl import map
import cctbx.crystal
import cctbx.uctbx
from scitbx.array_family import flex, shared
import six

def __build_tables():
  global expected_bond_lengths, vdw_radii
  expected_bond_lengths = map.stl_string_double()
  vdw_radii = map.stl_string_double()
  for (e1, e2), length in six.iteritems(expected_bond_lengths_by_element_pair):
    assert e1.find(":") < 0
    assert e2.find(":") < 0
    expected_bond_lengths[e1+":"+e2] = length
  for k, v in vdw.table.items():
    vdw_radii[k.upper()] = v
__build_tables()

def build_simple_two_way_bond_sets(
      sites_cart,
      elements,
      conformer_indices=None,
      search_max_distance=None,
      tolerance_factor_expected_bond_length=1.3,
      fallback_expected_bond_length=2.0,
      fallback_search_max_distance=3.0):
  assert sites_cart.size() == elements.size()
  assert (isinstance(tolerance_factor_expected_bond_length, float) or
          isinstance(tolerance_factor_expected_bond_length, int))
  assert (isinstance(fallback_expected_bond_length, float) or
          isinstance(fallback_expected_bond_length, int))
  assert (isinstance(fallback_search_max_distance, float) or
          isinstance(fallback_search_max_distance, int))
  if (conformer_indices is None):
    conformer_indices = flex.size_t(sites_cart.size(), 0)
  stripped_elements = elements.strip().upper()
  if (search_max_distance is None):
    search_max_distance = 2 * max([vdw_radii.get(e, 0.0)
      for e in stripped_elements])
    if (search_max_distance == 0.0):
      search_max_distance = fallback_search_max_distance
    else:
      search_max_distance *= tolerance_factor_expected_bond_length
  else :
    assert isinstance(search_max_distance, float)
  box_symmetry = cctbx.crystal.symmetry(
    unit_cell=cctbx.uctbx.non_crystallographic_unit_cell(
      sites_cart=sites_cart,
      buffer_layer=search_max_distance*(1+1.e-4)), # uncritical tolerance
    space_group_symbol="P1").special_position_settings()
  asu_mappings = box_symmetry.asu_mappings(
    buffer_thickness=search_max_distance,
    sites_cart=sites_cart)
  pair_generator = cctbx.crystal.neighbors_fast_pair_generator(
    asu_mappings=asu_mappings,
    distance_cutoff=search_max_distance,
    minimal=True)
  result = shared.stl_set_unsigned(sites_cart.size())
  return pair_generator.distance_based_simple_two_way_bond_sets(
    elements=stripped_elements,
    conformer_indices=conformer_indices,
    expected_bond_lengths=expected_bond_lengths,
    vdw_radii=vdw_radii,
    fallback_expected_bond_length=fallback_expected_bond_length,
    tolerance_factor_expected_bond_length=tolerance_factor_expected_bond_length)


 *******************************************************************************


 *******************************************************************************
cctbx/crystal/find_best_cell.py
from __future__ import absolute_import, division, print_function
from cctbx import sgtbx
from six.moves import range
from six.moves import zip
#from cctbx import crystal

class find_best_cell(object):

  def __init__(self,
        input_symmetry,
        angular_tolerance=None,
        best_monoclinic_beta=True):
    if (angular_tolerance is None):
      angular_tolerance = 3
    self._all_cells = []
    space_group_number = input_symmetry.space_group_info().type().number()
    if (space_group_number == 1):
      self._cb_op = input_symmetry.change_of_basis_op_to_niggli_cell()
      self._symmetry = input_symmetry.change_basis(self._cb_op)
      self._all_cells.append(self._symmetry)
      return
    if (space_group_number < 3 or space_group_number >= 75):
      self._cb_op = sgtbx.change_of_basis_op()
      self._symmetry = input_symmetry
      self._all_cells.append(self._symmetry)
      return
    standard_info = sgtbx.space_group_info(
      symbol=space_group_number,
      table_id="A1983")
    cb_op_inp_ref = input_symmetry.space_group_info().type().cb_op()
    cb_op_std_ref = standard_info.type().cb_op()
    cb_op_std_inp = cb_op_inp_ref.inverse() * cb_op_std_ref
    assert standard_info.group().change_basis(cb_op_std_inp) == input_symmetry.space_group()
    best_cb_op = sgtbx.change_of_basis_op()
    best_symmetry = input_symmetry
    if (space_group_number <= 15):
      two_fold_info = sgtbx.rot_mx_info(input_symmetry.space_group()(1).r())
      assert abs(two_fold_info.type()) == 2
      ev = list(two_fold_info.ev())
      assert ev.count(0) == 2
      unique_axis = ev.index(1)
      affine = sgtbx.find_affine(input_symmetry.space_group())
      for cb_mx in affine.cb_mx():
        cb_op = sgtbx.change_of_basis_op(cb_mx).new_denominators(best_cb_op)
        alt_symmetry = input_symmetry.change_basis(cb_op)
        if (alt_symmetry.space_group() == input_symmetry.space_group()):
          if (best_monoclinic_beta and unique_axis == 1):
            cb_op_best_beta = alt_symmetry.unit_cell() \
              .change_of_basis_op_for_best_monoclinic_beta()
            if (not cb_op_best_beta.is_identity_op()):
              cb_op.update(cb_op_best_beta)
              alt_symmetry = input_symmetry.change_basis(cb_op)
          self._all_cells.append(alt_symmetry)
          cmp_result = best_symmetry.unit_cell().compare_monoclinic(
            other=alt_symmetry.unit_cell(),
            unique_axis=unique_axis,
            angular_tolerance=angular_tolerance)
          if (cmp_result > 0):
            best_cb_op = cb_op
            best_symmetry = alt_symmetry
    else:
      assert not str(standard_info).endswith(":2")
      affine_group = sgtbx.space_group("P 4 3*").change_basis(
        cb_op_std_inp)
      for affine_s in affine_group:
        cb_op = sgtbx.change_of_basis_op(affine_s) \
          .new_denominators(best_cb_op)
        alt_symmetry = input_symmetry.change_basis(cb_op)
        if (alt_symmetry.space_group() == input_symmetry.space_group()):
          self._all_cells.append(alt_symmetry)
          cmp_result = best_symmetry.unit_cell().compare_orthorhombic(
            alt_symmetry.unit_cell())
          if (cmp_result > 0):
            best_cb_op = cb_op
            best_symmetry = alt_symmetry
    self._cb_op = best_cb_op
    self._symmetry = best_symmetry

  def cb_op(self):
    return self._cb_op

  def symmetry(self):
    return self._symmetry

  def all_cells(self):
    return self._all_cells


# this class is an implementation of an alternative method
# of finding the best cell. The above algorithm only works well for
# point groups. When translations are available in the SG,
# space group changes might occur.
# This class does the following: it determines axis permutiatons
# that do not change the spacegroup (apart from an origin shift maybe)


class alternative_find_best_cell(object):
  def __init__(self,
               unit_cell,
               space_group):
    from cctbx import crystal

    self.unit_cell = unit_cell
    self.xs = crystal.symmetry( self.unit_cell, space_group=space_group)
    self.sg_info = sgtbx.space_group_info(group=space_group)
    self.hall_symbol = self.sg_info.type().hall_symbol()
    self.best_cell = None
    self.best_cb_op = sgtbx.change_of_basis_op( 'x,y,z' )

    # now we have to go to the reference setting
    tmp = self.sg_info.change_of_basis_op_to_reference_setting()
    self.xs = self.xs.change_basis( tmp )
    self.unit_cell = self.xs.unit_cell()
    self.sg_info=self.sg_info.change_basis( tmp )
    self.best_cb_op = tmp*self.best_cb_op


    # note that the order in which the operators are checked is important!
    self.axes_permut = [ sgtbx.change_of_basis_op( 'x,y,z' ),# this will work

                         sgtbx.change_of_basis_op( '-x,z,y' ),# this might for pxxy
                         sgtbx.change_of_basis_op( 'y,x,-z' ),# this might for pxxy
                         sgtbx.change_of_basis_op( 'z,-y,x' ),# this might for pxxy

                         sgtbx.change_of_basis_op( 'z,x,y' ),# this not for pxxy
                         sgtbx.change_of_basis_op( 'y,z,x' ) # this not for pxxy
                         ]

    fix_flags = ['All',0,2,1,None,None]

    self.allowed_cb_ops = [sgtbx.change_of_basis_op( 'x,y,z' )]
    self.allowed_cb_ops_to_ref = [sgtbx.change_of_basis_op( 'x,y,z' )]

    fixed_element = None

    identity_op = sgtbx.change_of_basis_op( 'x,y,z' ).c().r()

    for cb_op, fixed in zip(self.axes_permut[1:],
                            fix_flags[1:]): # leave alone the first op
      sg_new = self.sg_info.change_basis( cb_op )
      sg_new_hall_symbol = sg_new.type().hall_symbol()
      #print self.sg_info, "--(", cb_op.as_xyz(),")-->>", sg_new, ";",
      cp_op_to_ref_rotational_part = \
        sg_new.change_of_basis_op_to_reference_setting().c().r()
      #print cp_op_to_ref_rotational_part.as_xyz()

      if  cp_op_to_ref_rotational_part == identity_op :
        # cb_op leaves sg invariantapart from may an origin shift
        self.allowed_cb_ops.append( cb_op )
        self.allowed_cb_ops_to_ref.append( sg_new.change_of_basis_op_to_reference_setting() )
        fixed_element = fixed

    # we now have allowed cb ops, as well as an indication which axis is fixed
    # we can now very easely generate all p;ossible cells
    # and check for order of cell axes among non fixed cel constants
    # the one that has all constants in proper order, is the things we are interested in
    # cell axis order is only an issue in
    # triclinic space groups
    # monoclinic spacegroups
    # orthorhombic spacegroups
    # for other sg's the order is fixed by the symmetry

    self.unit_cell_array = [ unit_cell ]
    self.order_check_array =  [self.order_check( unit_cell, fixed_element )]

    for cb_op in  self.allowed_cb_ops[1:]:
      tmp_uc = self.xs.change_basis( cb_op ).unit_cell()
      self.unit_cell_array.append( tmp_uc )
      self.order_check_array.append( self.order_check( tmp_uc, fixed_element ) )
    self.find_it()


  def order_check(self, unit_cell, fixed=None):
    prefered_order = False
    abc = [ unit_cell.parameters()[0],
            unit_cell.parameters()[1],
            unit_cell.parameters()[2] ]
    if fixed == None:
      if abc[0] <= abc[1]:
        if abc[1] <= abc[2]:
          prefered_order=True

    else:
      assert fixed >= 0
      assert fixed <= 2
      tmp_abc = []
      for ii in range(3):
        if ii != fixed:
          tmp_abc.append( abc[ ii ] )
      if tmp_abc[0] <= tmp_abc[1]:
        prefered_order = True

    return prefered_order

  def find_it(self):
    # check how many trues we have
    n_true = ( self.order_check_array ).count(True)
    best_index = None
    if n_true == 1: # there is only one solution
      best_index = self.order_check_array.index( True )
    else: # there is more then one possible solution, use the first solution one encounters
      for order, ii in zip( self.order_check_array,
                            range(len(self.order_check_array)) ):
        if order:
          best_index = ii
          break

    # Needed for cases like C 1 2 1
    if best_index == None:
      best_index = 0

    self.best_cb_op = (self.allowed_cb_ops_to_ref[ best_index ]*
                       self.allowed_cb_ops[ best_index ] *
                       self.best_cb_op)
    self.best_xs = self.xs.change_basis( self.allowed_cb_ops[ best_index ] * self.allowed_cb_ops_to_ref[ best_index ] )

    self.best_cell = self.best_xs.unit_cell()

  def return_best_cell(self):
    return self.best_cell

  def return_change_of_basis_op_to_best_cell(self):
    return self.best_cb_op

  def return_best_xs(self):
    return self.best_xs


def exercise_alternative():
  from cctbx import crystal
  cb_op = sgtbx.change_of_basis_op("x,y,z")
  for space_group_number in range(1,231):
    sgi = sgtbx.space_group_info(symbol=space_group_number)
    uc = sgi.any_compatible_unit_cell(volume=1000)
    xs = crystal.symmetry(unit_cell=uc, space_group_info=sgi).change_basis(cb_op)

    abest = alternative_find_best_cell( xs.unit_cell(),
                                        sgi.group() )
    print("Space group : ", sgi)
    print("Unit cell   : ", abest.return_best_cell().parameters())
    print("cb op       : ", abest.return_change_of_basis_op_to_best_cell().as_xyz())
    print("N cb op     : ", len( abest.allowed_cb_ops ))
    print()
    print()



def exercise():
  from cctbx import crystal
  cb_op = sgtbx.change_of_basis_op("y,z,x")
  for space_group_number in [1] + list(range(3,73)):
    sgi = sgtbx.space_group_info(symbol=space_group_number)
    uc = sgi.any_compatible_unit_cell(volume=1000)

    xs = crystal.symmetry(unit_cell=uc, space_group_info=sgi).change_basis(cb_op)

    best = find_best_cell(xs,angular_tolerance=3)
    best.symmetry().show_summary()
    print(best.cb_op().as_xyz())
    print(best.cb_op().c())
    print(len(best.all_cells()))
    print()

if (__name__ == "__main__"):
  exercise_alternative()
  exercise()


 *******************************************************************************


 *******************************************************************************
cctbx/crystal/reindex.py
from __future__ import absolute_import, division, print_function
from cctbx import sgtbx
from cctbx.sgtbx import cosets
from cctbx.sgtbx import lattice_symmetry


class reindexing_operators(object):
  def __init__(self,
               xs1,
               xs2,
               relative_length_tolerance=0.05,
               absolute_angle_tolerance=10,
               max_delta=3.0,
               anomalous_flag=True,
               out=None):
    # first we have to go to the niggli setting
    self.cb_op_to_n_1 = xs1.change_of_basis_op_to_niggli_cell()
    self.cb_op_to_n_2 = xs2.change_of_basis_op_to_niggli_cell()

    nxs1 = xs1.change_basis( self.cb_op_to_n_1 )
    nxs2 = xs2.change_basis( self.cb_op_to_n_2 )

    # get the lattice symmetry please
    lat_sym_1 = lattice_symmetry.group( nxs1.unit_cell(), max_delta  )
    lat_sym_2 = lattice_symmetry.group( nxs2.unit_cell(), max_delta )
    # and the intensity symmetry please
    int_sym_1 = nxs1.reflection_intensity_symmetry( anomalous_flag ).space_group()
    int_sym_2 = nxs2.reflection_intensity_symmetry( anomalous_flag ).space_group()

    # Now we have to find a similarity transform that maps the two niggli cells onto each other
    c_inv_rs = nxs1.unit_cell().similarity_transformations(
      other=nxs2.unit_cell(),
      relative_length_tolerance=relative_length_tolerance,
      absolute_angle_tolerance=absolute_angle_tolerance)
    min_bases_msd = None
    self.similarity_cb_op = None

    for c_inv_r in c_inv_rs:
      # make the similarity transform into a cb_op
      c_inv = sgtbx.rt_mx(sgtbx.rot_mx(c_inv_r))
      cb_op = sgtbx.change_of_basis_op(c_inv).inverse()
      # compute the mean square difference for the bases
      bases_msd = nxs1.unit_cell() \
                  .bases_mean_square_difference(
        other=nxs2.unit_cell().change_basis(cb_op=cb_op))

      # and find cb_op correspondiong to the the minimum rmsd
      if (min_bases_msd is None
          or min_bases_msd > bases_msd):
        min_bases_msd = bases_msd
        self.similarity_cb_op = cb_op
    # if nothing is found, do not continue
    self.double_cosets = None
    if (self.similarity_cb_op is not None):
      # make the common lattice group please
      common_lattice_group = lat_sym_1
      for s in lat_sym_2.build_derived_acentric_group().change_basis(
        self.similarity_cb_op ):
        try: common_lattice_group.expand_smx(s)
        except RuntimeError:
          common_lattice_group=None
          break
      if  common_lattice_group is not None:
        common_lattice_group.make_tidy()

        h1 = int_sym_1.build_derived_acentric_group().make_tidy()
        h2 = int_sym_2.build_derived_acentric_group().change_basis( self.similarity_cb_op ).make_tidy()

        # do the double coset decomposition
        self.double_cosets = cosets.double_cosets( common_lattice_group,
                                                   h1,
                                                   h2,
                                                   )
  def cb_ops_in_niggli_setting(self):
    result=[]
    if self.double_cosets is not None:
      for coset in self.double_cosets.double_cosets:
        result.append( sgtbx.change_of_basis_op(coset[0])*self.similarity_cb_op )
    return result

  def combined_cb_ops(self):
    results = []
    if self.double_cosets is not None:
    # now we need to make a combined operator wrt the incomming cell
      for coset in self.double_cosets.double_cosets:
        r =cosets.construct_nice_cb_op(coset,
                                       self.similarity_cb_op,
                                       self.cb_op_to_n_1 ,
                                     self.cb_op_to_n_2 )
        results.append( r )
    #and return it
    return( results )


 *******************************************************************************


 *******************************************************************************
cctbx/crystal/super_cell.py
from __future__ import absolute_import, division, print_function
import iotbx.pdb
from scitbx.array_family import flex
from cctbx import uctbx
import cctbx.crystal
import iotbx.pdb.utils
import boost_adaptbx.boost.python as bp
cctbx_maptbx_ext = bp.import_ext("cctbx_maptbx_ext")

def get_siiu(pdb_hierarchy, crystal_symmetry, select_within_radius):
  sites_cart = pdb_hierarchy.atoms().extract_xyz()
  sst = crystal_symmetry.special_position_settings().site_symmetry_table(
    sites_cart = sites_cart)
  siiu = {}
  # +1 is nonbonded buffer, to match nonbonded_distance_cutoff
  cutoff = select_within_radius+1
  conn_asu_mappings = crystal_symmetry.special_position_settings().\
    asu_mappings(buffer_thickness=cutoff)
  conn_asu_mappings.process_sites_cart(
    original_sites      = sites_cart,
    site_symmetry_table = sst)
  conn_pair_asu_table = cctbx.crystal.pair_asu_table(
    asu_mappings=conn_asu_mappings)
  conn_pair_asu_table.add_all_pairs(
    distance_cutoff=cutoff)
  pair_generator = cctbx.crystal.neighbors_fast_pair_generator(
    conn_asu_mappings,
    distance_cutoff=cutoff)
  all_ops_mat = []
  all_ops = []
  for pair in pair_generator:
    rt_mx_i = conn_asu_mappings.get_rt_mx_i(pair)
    rt_mx_j = conn_asu_mappings.get_rt_mx_j(pair)
    rt_mx_ji = rt_mx_i.inverse().multiply(rt_mx_j)
    #print(rt_mx_ji, str(rt_mx_ji))
    if str(rt_mx_ji)=="x,y,z": continue
    siiu.setdefault(pair.j_seq, []).append(rt_mx_ji)
    as_xyz = rt_mx_ji.as_xyz()
    if(not as_xyz in all_ops):
      all_ops.append(as_xyz)
      all_ops_mat.append(rt_mx_ji)
  for k,v in zip(siiu.keys(), siiu.values()): # remove duplicates!
    siiu[k] = list(set(v))
  return siiu, all_ops_mat

def apply_symop_sites_cart(sites_cart, op, fm, om):
  sites_frac = fm * sites_cart
  sites_frac_copy = flex.vec3_double(
    [op*site_frac for site_frac in sites_frac])
  return om*sites_frac_copy

def apply_symop_inplace_chain(chain, op, fm, om):
  sites_cart = chain.atoms().extract_xyz()
  sites_cart_copy = apply_symop_sites_cart(sites_cart, op, fm, om)
  chain.atoms().set_xyz(sites_cart_copy)

class manager(object):
  def __init__(self,
               pdb_hierarchy,
               crystal_symmetry,
               select_within_radius,
               box_buffer_layer=3,
               siiu=None,
               debug_files=False):
    # Results to be available outside
    self.super_cell_hierarchy = None # XXX sites are NOT in box center!!!
    self.super_sphere_hierarchy = None # XXX sites are NOT in box center!!!
    self.cs_super_sphere      = None
    self.siiu                 = siiu
    self.pdb_hierarchy        = pdb_hierarchy
    self.chain_op_dict        = {}
    self.fm = crystal_symmetry.unit_cell().fractionalization_matrix()
    self.om = crystal_symmetry.unit_cell().orthogonalization_matrix()
    #
    assert pdb_hierarchy.models_size() == 1, "one model is expected"
    # Get operators
    self.siiu, all_ops = get_siiu(
      pdb_hierarchy        = pdb_hierarchy,
      crystal_symmetry     = crystal_symmetry,
      select_within_radius = select_within_radius)
    # Get unique chain IDs for new symmetry copies
    all_chains = iotbx.pdb.utils.all_chain_ids()
    focus_chain_ids = pdb_hierarchy.chain_ids()
    for cid in focus_chain_ids:
      while cid in all_chains:
        all_chains.remove(cid)
    focus_ss = " or ".join(["chain %s"%it for it in focus_chain_ids])
    # Create super_cell: apply symmetry to chains and add new copies to master
    # hierarchy
    self.super_cell_hierarchy = pdb_hierarchy.deep_copy()
    cntr=0
    new_chains = []
    for op in all_ops:
      model_dc = self.super_cell_hierarchy.models()[0].detached_copy()
      new_ids = []
      for chain in model_dc.chains():
        chain_dc = chain.detached_copy()
        new_id = all_chains[cntr]
        cntr+=1
        chain_dc.id = new_id
        new_ids.append(new_id)
        apply_symop_inplace_chain(chain=chain_dc, op=op, fm=self.fm, om=self.om)
        new_chains.append(chain_dc)
      self.chain_op_dict[op] = new_ids
    for c in new_chains:
      self.super_cell_hierarchy.models()[0].append_chain(c)
    # Initiate selection to remove (outside the sphere)
    self.super_cell_hierarchy.atoms().reset_i_seq()
    self.keep_selection = flex.bool(self.super_cell_hierarchy.atoms().size(), True)
    # Move everything to the center of a big box
    box = uctbx.non_crystallographic_unit_cell_with_the_sites_in_its_center(
      sites_cart   = self.super_cell_hierarchy.atoms().extract_xyz(),
      buffer_layer = box_buffer_layer)
    self.super_cell_hierarchy.atoms().set_xyz(box.sites_cart)
    if(debug_files):
      self.super_cell_hierarchy.write_pdb_file(file_name="ss.pdb",
        crystal_symmetry = box.crystal_symmetry())
    # Create mask around focus atoms
    radii = flex.double(self.super_cell_hierarchy.atoms().size(), select_within_radius)
    uc = box.crystal_symmetry().unit_cell()
    fm_ss = box.crystal_symmetry().unit_cell().fractionalization_matrix()
    a,b,c = uc.parameters()[:3]
    step = 1.
    n_real = [int(a/step), int(b/step), int(c/step)]

    self.scasc = self.super_cell_hierarchy.atom_selection_cache()

    sel_focus = self.super_cell_hierarchy.atom_selection_cache().\
      selection(focus_ss)
    sites_frac_focus = fm_ss * self.super_cell_hierarchy.select(
      sel_focus).atoms().extract_xyz()

    mask = cctbx_maptbx_ext.mask(
      sites_frac                  = sites_frac_focus,
      unit_cell                   = uc,
      n_real                      = n_real,
      mask_value_inside_molecule  = 1,
      mask_value_outside_molecule = 0,
      radii                       = radii,
      wrapping                    = False)
    # Select the inside of the mask (discard the rest). This is super-sphere
    for chain in self.super_cell_hierarchy.chains():
      for rg in chain.residue_groups():
        sites_frac = fm_ss * rg.atoms().extract_xyz()
        inside = False
        for site_frac in sites_frac:
          if(mask.value_at_closest_grid_point(site_frac)==1):
            inside = True
            break
        if(not inside):
          #chain.remove_residue_group(rg)
          self.keep_selection.set_selected(rg.atoms().extract_i_seq(), False)
    if(debug_files):
      self.super_cell_hierarchy.write_pdb_file(file_name="ss_cut.pdb",
        crystal_symmetry = box.crystal_symmetry())
    # Shift back
    self.super_cell_hierarchy.atoms().set_xyz(
      self.super_cell_hierarchy.atoms().extract_xyz()-box.shift_vector)
    # Extract super-sphere out of super-cell
    self.super_sphere_hierarchy = self.super_cell_hierarchy.select(
      self.keep_selection, copy_atoms=True)
    self.super_sphere_hierarchy.atoms().reset_i_seq()
    #
    if(debug_files):
      self.super_sphere_hierarchy.write_pdb_file(file_name="ss_cut_shifted.pdb")
    # Box final model
    box = uctbx.non_crystallographic_unit_cell_with_the_sites_in_its_center(
      sites_cart   = self.super_sphere_hierarchy.atoms().extract_xyz(),
      buffer_layer = box_buffer_layer)
    self.cs_super_sphere = box.crystal_symmetry()
    #
    # DEBUG ONLY
    # To trigger the bug: change copy_atoms to False above, uncomment the code
    # below and run modules/cctbx_project/cctbx/crystal/tst_super_cell.py
    #
    #import mmtbx.model
    #from libtbx.utils import null_out
    #model = mmtbx.model.manager(
    #  model_input       = None,
    #  pdb_hierarchy     = self.super_cell_hierarchy,
    #  crystal_symmetry  = self.cs_super_sphere,
    #  log               = null_out())
    #model.process(make_restraints=True, grm_normalization=True)
    #STOP()

  def update(self, sites_cart, debug=False):
    """
    Change coordinates in the master (focus) hierarchy and propagate the change
    to the super-cell/sphere (self.super_cell_hierarchy,
    self.super_sphere_hierarchy). This changes self.super_cell_hierarchy and
    self.super_sphere_hierarchy inplace
    """
    assert self.pdb_hierarchy.atoms().size() == sites_cart.size()
    if(debug):
      dist1 = flex.sqrt((
         self.pdb_hierarchy.atoms().extract_xyz() -  sites_cart).dot())
      BEFORE = self.super_cell_hierarchy.atoms().extract_xyz()
    self.pdb_hierarchy.atoms().set_xyz(sites_cart)
    all_xyz = self.super_cell_hierarchy.atoms().extract_xyz()
    all_xyz.set_selected(flex.size_t(range(sites_cart.size())), sites_cart)
    for op, cids in zip(self.chain_op_dict.keys(), self.chain_op_dict.values()):
      sel_str = " or ".join(["chain %s"%it for it in cids])
      sel = self.scasc.selection(sel_str)
      sites_cart_copy = apply_symop_sites_cart(sites_cart, op, self.fm, self.om)
      all_xyz.set_selected(sel, sites_cart_copy)
    self.super_cell_hierarchy.atoms().set_xyz(all_xyz)
    self.super_sphere_hierarchy = self.super_cell_hierarchy.select(
      self.keep_selection, copy_atoms=True)
    self.super_sphere_hierarchy.atoms().reset_i_seq()
    if(debug):
      AFTER = self.super_cell_hierarchy.atoms().extract_xyz()
      dist2 = flex.sqrt((BEFORE - AFTER).dot())
      assert abs(flex.max(dist1)-flex.max(dist2))<1.e-4
    return self.super_sphere_hierarchy


 *******************************************************************************


 *******************************************************************************
cctbx/crystal/tst_distance_based_connectivity.py
from __future__ import absolute_import, division, print_function
def run(args):
  assert len(args) == 0
  from cctbx.crystal.distance_based_connectivity import \
    build_simple_two_way_bond_sets
  from scitbx.array_family import flex
  sites_cart = flex.vec3_double([
    (25.655, 43.266, 42.630),
    (24.038, 43.853, 43.337),
    (23.048, 44.525, 43.290),
    (21.223, 44.207, 41.475),
    (24.951, 47.170, 37.585),
    (19.298, 46.942, 51.808)])
  elements = flex.std_string(["S", "C", "N", "CU", "ZN", "CA"])
  bond_list = build_simple_two_way_bond_sets(
    sites_cart=sites_cart, elements=elements)
  assert [sorted(b) for b in bond_list] == [[1], [0,2], [1,3], [2], [], []]
  #
  # caffeine
  sites_cart = flex.vec3_double([
    (-2.986, 0.015, 1.643),
    (-1.545, 0.015, 1.643),
    (-0.733, 0.015, 2.801),
    (0.592, 0.015, 2.395),
    (0.618, 0.015, 1.034),
    (1.758, 0.015, 0.102),
    (3.092, -0.06, 0.694),
    (1.525, 0.015, -1.360),
    (2.489, -0.024, -2.139),
    (0.158, 0.015, -1.888),
    (-0.025, 0.024, -3.330),
    (-0.986, 0.015, -0.959),
    (-2.155, 0.008, -1.408),
    (-0.733, 0.015, 0.565),
    (-3.346, 0.016, 2.662),
    (-3.347, 0.896, 1.133),
    (-3.347, -0.868, 1.136),
    (-1.083, 0.02, 3.822),
    (3.184, -0.975, 1.26),
    (3.245, 0.785, 1.348),
    (3.835, -0.047, -0.09),
    (0.508, 0.861, -3.756),
    (-1.076, 0.113, -3.560),
    (0.358, -0.896, -3.748)
  ])
  elements = flex.std_string([
    ' C', ' N', ' C', ' N', ' C', ' N', ' C', ' C', ' O', ' N', ' C', ' C',
    ' O', ' C', ' H', ' H', ' H', ' H', ' H', ' H', ' H', ' H', ' H', ' H'])
  bonds = build_simple_two_way_bond_sets(
    sites_cart=sites_cart, elements=elements)
  assert bonds.size() == sites_cart.size()
  assert list(bonds[0]) == [1, 14, 15, 16]
  #
  print("OK")

if (__name__ == "__main__"):
  import sys
  run(args=sys.argv[1:])


 *******************************************************************************


 *******************************************************************************
cctbx/crystal/tst_ext.py
from __future__ import absolute_import, division, print_function
from cctbx import crystal
import cctbx.crystal.coordination_sequences
from cctbx import sgtbx, xray
import cctbx.crystal.direct_space_asu
from cctbx import uctbx
from cctbx.array_family import flex
from scitbx import matrix
from libtbx.test_utils import Exception_expected, approx_equal, show_diff
import hashlib
from libtbx import adopt_init_args
from itertools import count
from six.moves import cStringIO as StringIO
import sys
from six.moves import range
from six.moves import zip
from six.moves import cPickle as pickle

def exercise_symmetry():
  cs = crystal.symmetry(
    unit_cell="12.548 12.548 20.789 90.000 90.000 120.000",
    space_group_symbol="P63/mmc")
  cspc = cs.as_py_code(indent="*$")
  assert not show_diff(cspc, """\
crystal.symmetry(
*$  unit_cell=(12.548, 12.548, 20.789, 90, 90, 120),
*$  space_group_symbol="P 63/m m c"
*$)""")
  cspc = cs.as_py_code()
  cs2 = eval(cspc)
  assert cs2.is_similar_symmetry(cs, 1e-8, 1e-8)

def trial_structure(choice_of_coordinates=0):
  # zeolite framework type AFG
  from cctbx import xray
  if (choice_of_coordinates == 0):
    sites = [
      (0.2466,0.9965,0.2500),
      (0.5817,0.6706,0.1254),
      (0.2478,0.0000,0.0000)]
  else:
    sites = [
      (0.2466,0.9965,0.2500),
      (0.2478,1.0000,0.5000),
      (0.3294,0.9111,0.3746)]
  return xray.structure(
    crystal_symmetry=crystal.symmetry(
      unit_cell="12.548 12.548 20.789 90.000 90.000 120.000",
      space_group_symbol="P63/mmc"),
    scatterers=flex.xray_scatterer(
      [xray.scatterer(label="Si"+str(i), site=site)
        for i,site in enumerate(sites)]))

def trial_structure_2():
  from cctbx import xray
  return xray.structure(
    crystal_symmetry=crystal.symmetry(
      unit_cell="7.9999 9.3718 14.7362 82.625 81.527 81.726",
      space_group_symbol="P-1"),
    scatterers=flex.xray_scatterer(
      [xray.scatterer(label=label, site=site) for label, site in [
        ('Co', (0.09898,0.20553,0.24456)),
        ('S1', (0.19330, 0.47441, 0.32339)),
        ('O1', (0.28318, 0.48776, 0.23127)),
        ('O2', (0.09062, 0.59941, 0.35911)),
        ('N1', (-0.05974, 0.10727, 0.34676)),
        ('N2', (0.10173, 0.33500, 0.33941)),
        ('C1', (-0.08067, -0.08749,  0.25674)),
        ('C2', (0.36510, 0.43663, 0.39726)),
        ('C3', (-0.09941, 0.17783, 0.42309)),
        ('C4', (-0.02798, 0.31830, 0.42095)),
        ('C5', (-0.20405, 0.12510, 0.50038)),
        ('C6', (-0.12493, -0.01760, 0.34439)),
        ('C7', (-0.22987, -0.07481, 0.41954)),
        ('C8', (-0.26940, -0.00294, 0.49848)),
        ('F1', (0.46982, 0.31699, 0.37812)),
        ('F2', (0.29973, 0.41650, 0.48619)),
        ('F3', (0.45768, 0.54578, 0.38614)),
        ('H1', (-0.14014, -0.03270, 0.21285)),
        ('H2', (-0.10888, -0.18018, 0.26822)),
        ('H3', (0.03483, -0.08732, 0.23798)),
        ('H4', (-0.11972, 0.39865, 0.41790)),
        ('H5', (0.02297, 0.31775, 0.47702)),
        ('H6', (-0.22897, 0.17412, 0.55193)),
        ('H7', (-0.27205, -0.16153, 0.41707)),
        ('H8', (-0.33910, -0.04115, 0.54930))]]))

def exercise_direct_space_asu():
  cp = crystal.direct_space_asu.float_cut_plane(n=[-1,0,0], c=1)
  assert approx_equal(cp.n, [-1,0,0])
  assert approx_equal(cp.c, 1)
  assert approx_equal(cp.evaluate(point=[0,2,3]), 1)
  assert approx_equal(cp.evaluate(point=[1,2,3]), 0)
  assert cp.is_inside(point=[0.99,0,0], epsilon=0)
  assert not cp.is_inside([1.01,0,0])
  assert approx_equal(cp.get_point_in_plane(), [1,0,0])
  cp.n = [0,-1,0]
  assert approx_equal(cp.n, [0,-1,0])
  cp.c = 2
  assert approx_equal(cp.c, 2)
  assert approx_equal(cp.get_point_in_plane(), [0,2,0])
  unit_cell = uctbx.unit_cell((1,1,1,90,90,90))
  cpb = cp.add_buffer(unit_cell=unit_cell, thickness=0.5)
  assert approx_equal(cpb.n, cp.n)
  assert approx_equal(cpb.c, 2.5)
  asu = crystal.direct_space_asu_float_asu(
    unit_cell=unit_cell,
    cuts=[])
  assert asu.shape_vertices().size() == 0
  cuts = []
  for i in range(3):
    n = [0,0,0]
    n[i] = -1
    cuts.append(crystal.direct_space_asu.float_cut_plane(n=n, c=i+1))
  asu = crystal.direct_space_asu.float_asu(
    unit_cell=unit_cell,
    cuts=cuts,
    is_inside_epsilon=1.e-6)
  assert asu.unit_cell().is_similar_to(unit_cell)
  for i in range(3):
    n = [0,0,0]
    n[i] = -1
    assert approx_equal(asu.cuts()[i].n, n)
    assert approx_equal(asu.cuts()[i].c, i+1)
  assert approx_equal(asu.is_inside_epsilon(), 1.e-6)
  assert asu.is_inside([0.99,0.49,0.32])
  eps = 0.02
  assert not asu.is_inside([0.99+eps,0.49+eps,0.32+eps])
  buf_asu = asu._add_buffer(0.2)
  assert buf_asu.is_inside([0.99+0.2,0.49+0.2,0.32+0.2])
  eps = 0.02
  assert not buf_asu.is_inside([0.99+0.2+eps,0.49+0.2+eps,0.32+0.2+eps])
  assert len(asu.shape_vertices()) == 1
  for cartesian in [False,True]:
    assert approx_equal(asu.shape_vertices(
      cartesian=cartesian, epsilon=1.e-6)[0], (1.0, 2.0, 3.0))
  asu = crystal.direct_space_asu.float_asu(
    unit_cell=unit_cell,
    cuts=[crystal.direct_space_asu.float_cut_plane(n=n,c=c) for n,c in [
      [(0, 0, 1), -1/2.],
      [(-1, -1, 0), 1],
      [(0, 1, -1), 3/4.],
      [(1, 0, -1), 1/4.]]])
  assert approx_equal(asu.box_min(), [0.25, -0.25, 0.5])
  assert approx_equal(asu.box_max(), [1.25, 0.75, 1.0])
  assert approx_equal(asu.box_min(cartesian=True), [0.25, -0.25, 0.5])
  assert approx_equal(asu.box_max(cartesian=True), [1.25, 0.75, 1.0])
  asu_mappings = crystal.direct_space_asu.asu_mappings(
    space_group=sgtbx.space_group("P 2 3").change_basis(
      sgtbx.change_of_basis_op("x+1/4,y-1/4,z+1/2")),
    asu=asu,
    buffer_thickness=0.1)
  asu_mappings.reserve(n_sites_final=10)
  assert asu_mappings.space_group().order_z() == 12
  assert len(asu_mappings.asu().cuts()) == 4
  assert asu_mappings.unit_cell().is_similar_to(unit_cell)
  assert approx_equal(asu_mappings.buffer_thickness(), 0.1)
  assert approx_equal(asu_mappings.asu_buffer().box_min(),
    [0.0085786, -0.4914214, 0.4])
  assert approx_equal(asu_mappings.buffer_covering_sphere().radius(),0.8071081)
  sites_seq = [
    [3.1,-2.2,1.3],
    [-4.3,1.7,0.4]]
  assert asu_mappings.mappings().size() == 0
  assert asu_mappings.process(
    original_site=sites_seq[0],
    min_distance_sym_equiv=0.01) is asu_mappings
  assert asu_mappings.mappings().size() == 1
  site_symmetry = sgtbx.site_symmetry(
    unit_cell=asu_mappings.asu().unit_cell(),
    space_group=asu_mappings.space_group(),
    original_site=sites_seq[1],
    min_distance_sym_equiv=0.01)
  assert asu_mappings.process(
    original_site=sites_seq[1],
    site_symmetry_ops=site_symmetry) is asu_mappings
  assert asu_mappings.mappings().size() == 2
  sites_frac = flex.vec3_double([m[1-i].mapped_site()
    for i,m in enumerate(asu_mappings.mappings())])
  assert list(asu_mappings.asu().is_inside_frac(
    sites_frac=sites_frac)) == [False, True]
  assert list(asu_mappings.asu().is_inside_cart(
    sites_cart=asu_mappings.asu().unit_cell().orthogonalize(
      sites_frac=sites_frac))) == [False, True]
  assert asu_mappings.n_sites_in_asu_and_buffer() == 11
  mappings = asu_mappings.mappings()[0]
  assert len(mappings) == 5
  am = mappings[0]
  assert am.i_sym_op() == 3
  assert am.unit_shifts() == (1,3,2)
  assert asu.is_inside(am.mapped_site())
  assert approx_equal(asu_mappings.mapped_sites_min(), [0.15,-0.4,0.4])
  assert approx_equal(asu_mappings.mapped_sites_max(), [1.05,0.6,0.65])
  assert approx_equal(asu_mappings.mapped_sites_span(), [0.9,1.0,0.25])
  assert list(asu_mappings.site_symmetry_table().indices()) == [0, 0]
  for am in mappings:
    assert asu_mappings.asu_buffer().is_inside(am.mapped_site())
  o = matrix.sqr(asu_mappings.unit_cell().orthogonalization_matrix())
  f = matrix.sqr(asu_mappings.unit_cell().fractionalization_matrix())
  for i_seq,m_i_seq in enumerate(asu_mappings.mappings()):
    for i_sym in range(len(m_i_seq)):
      rt_mx = asu_mappings.get_rt_mx(i_seq, i_sym)
      assert asu_mappings.get_rt_mx(asu_mappings.mappings()[i_seq][i_sym]) \
          == rt_mx
      site_frac = rt_mx * sites_seq[i_seq]
      site_cart = asu_mappings.unit_cell().orthogonalize(site_frac)
      assert approx_equal(m_i_seq[i_sym].mapped_site(), site_cart)
      assert approx_equal(
        asu_mappings.map_moved_site_to_asu(
          moved_original_site
            =asu_mappings.unit_cell().orthogonalize(sites_seq[i_seq]),
          i_seq=i_seq,
          i_sym=i_sym),
        site_cart)
      r = matrix.sqr(rt_mx.r().inverse().as_double())
      assert approx_equal(
        asu_mappings.r_inv_cart(i_seq=i_seq, i_sym=i_sym),
        (o*r*f).elems)
  pair_generator = crystal.neighbors_simple_pair_generator(asu_mappings)
  assert not pair_generator.at_end()
  assert len(asu_mappings.mappings()[1]) == 6
  index_pairs = []
  for index_pair in pair_generator:
    index_pairs.append((index_pair.i_seq, index_pair.j_seq, index_pair.j_sym))
    assert index_pair.dist_sq == -1
    assert not pair_generator.is_simple_interaction(index_pair)
  assert pair_generator.at_end()
  assert index_pairs == [
    (0,0,1),(0,0,2),(0,0,3),(0,0,4),
    (0,1,0),(0,1,1),(0,1,2),(0,1,3),(0,1,4),(0,1,5),
    (1,0,1),(1,0,2),(1,0,3),(1,0,4),
    (1,1,1),(1,1,2),(1,1,3),(1,1,4),(1,1,5)]
  for two_flag,buffer_thickness,expected_index_pairs,expected_n_boxes in [
    (False, 0.04, [], (1,1,1)),
    (False, 0.1, [(0,0,1),(0,0,2),(0,0,3),(0,0,4)], (2,3,1)),
    (True, 0, [(0, 1, 0)], (1,1,1)),
    (True, 0.04, [(0, 1, 0), (0, 1, 1), (1, 1, 1)], (1,2,1))]:
    asu_mappings = crystal.direct_space_asu.asu_mappings(
      space_group=sgtbx.space_group("P 2 3").change_basis(
        sgtbx.change_of_basis_op("x+1/4,y-1/4,z+1/2")),
      asu=asu,
      buffer_thickness=buffer_thickness)
    assert asu_mappings.process_sites_frac(
      original_sites=flex.vec3_double([[3.1,-2.2,1.3]]),
      min_distance_sym_equiv=0.01) is asu_mappings
    assert asu_mappings.mappings().size() == 1
    if (two_flag):
      assert asu_mappings.process_sites_cart(
        original_sites=flex.vec3_double([
          asu.unit_cell().orthogonalize([-4.3,1.7,0.4])]),
        min_distance_sym_equiv=0.01) is asu_mappings
    pair_generator = crystal.neighbors_simple_pair_generator(asu_mappings)
    index_pairs = []
    for index_pair in pair_generator:
      index_pairs.append((index_pair.i_seq,index_pair.j_seq,index_pair.j_sym))
      assert index_pair.dist_sq == -1
    assert pair_generator.at_end()
    assert index_pairs == expected_index_pairs
    pair_generator.restart()
    if (len(expected_index_pairs) == 0):
      assert pair_generator.at_end()
    else:
      assert not pair_generator.at_end()
    assert pair_generator.count_pairs() == len(index_pairs)
    pair_generator.restart()
    if (two_flag):
      assert pair_generator.neighbors_of(
        primary_selection=flex.bool([True,False])).count(True) == 2
    pair_generator.restart()
    index_pairs = []
    for index_pair in pair_generator:
      index_pairs.append((index_pair.i_seq,index_pair.j_seq,index_pair.j_sym))
      assert index_pair.dist_sq == -1
    assert pair_generator.at_end()
    assert index_pairs == expected_index_pairs
    simple_pair_generator = crystal.neighbors_simple_pair_generator(
      asu_mappings=asu_mappings,
      distance_cutoff=100,
      minimal=False)
    assert approx_equal(simple_pair_generator.distance_cutoff_sq(), 100*100)
    fast_pair_generator = crystal.neighbors_fast_pair_generator(
      asu_mappings=asu_mappings,
      distance_cutoff=100,
      minimal=False,
      min_cubicle_edge=0,
      epsilon=1.e-6)
    assert approx_equal(fast_pair_generator.distance_cutoff_sq(), 100*100)
    assert approx_equal(fast_pair_generator.epsilon()/1.e-6, 1)
    assert fast_pair_generator.n_boxes() == (1,1,1)
    index_pairs = []
    dist_sq = flex.double()
    for index_pair in simple_pair_generator:
      index_pairs.append((index_pair.i_seq,index_pair.j_seq,index_pair.j_sym))
      assert index_pair.dist_sq > 0
      assert approx_equal(
        asu_mappings.diff_vec(pair=index_pair),
        index_pair.diff_vec)
      assert approx_equal(
        matrix.col(asu_mappings.diff_vec(pair=index_pair)).norm_sq(),
        index_pair.dist_sq)
      dist_sq.append(index_pair.dist_sq)
    assert simple_pair_generator.at_end()
    assert index_pairs == expected_index_pairs
    if (len(index_pairs) == 0):
      assert fast_pair_generator.at_end()
    else:
      assert not fast_pair_generator.at_end()
    index_pairs = []
    for index_pair in fast_pair_generator:
      index_pairs.append((index_pair.i_seq,index_pair.j_seq,index_pair.j_sym))
    assert index_pairs == expected_index_pairs
    assert fast_pair_generator.at_end()
    distances = flex.sqrt(dist_sq)
    if (distances.size() > 0):
      cutoff = flex.mean(distances) + 1.e-5
    else:
      cutoff = 0
    short_dist_sq = dist_sq.select(distances <= cutoff)
    for pair_generator_type in [crystal.neighbors_simple_pair_generator,
                                crystal.neighbors_fast_pair_generator]:
      if (pair_generator_type is crystal.neighbors_simple_pair_generator):
        pair_generator = pair_generator_type(
          asu_mappings=asu_mappings,
          distance_cutoff=cutoff)
      else:
        if (cutoff == 0):
          min_cubicle_edge = 1
        else:
          min_cubicle_edge = 0
        pair_generator = pair_generator_type(
          asu_mappings=asu_mappings,
          distance_cutoff=cutoff,
          minimal=False,
          min_cubicle_edge=min_cubicle_edge)
      index_pairs = []
      dist_sq = flex.double()
      for index_pair in pair_generator:
        index_pairs.append((index_pair.i_seq,index_pair.j_seq,index_pair.j_sym))
        assert index_pair.dist_sq > 0
        assert approx_equal(
          asu_mappings.diff_vec(pair=index_pair),
          index_pair.diff_vec)
        assert approx_equal(
          matrix.col(asu_mappings.diff_vec(pair=index_pair)).norm_sq(),
          index_pair.dist_sq)
        assert not asu_mappings.is_simple_interaction(pair=index_pair)
        dist_sq.append(index_pair.dist_sq)
      assert pair_generator.at_end()
      if (pair_generator_type is crystal.neighbors_simple_pair_generator):
        assert approx_equal(dist_sq, short_dist_sq)
      else:
        assert pair_generator.n_boxes() == expected_n_boxes
        short_dist_sq_sorted = short_dist_sq.select(
          flex.sort_permutation(data=short_dist_sq))
        dist_sq_sorted = dist_sq.select(
          flex.sort_permutation(data=dist_sq))
        assert approx_equal(dist_sq_sorted, short_dist_sq_sorted)
      assert pair_generator.count_pairs() == 0
      assert pair_generator.max_distance_sq() == -1
      pair_generator.restart()
      assert pair_generator.count_pairs() == len(index_pairs)
      pair_generator.restart()
      if (len(index_pairs) == 0):
        assert pair_generator.max_distance_sq() == -1
      else:
        assert approx_equal(pair_generator.max_distance_sq(), 0.1)
      pair_generator.restart()
      primary_selection = flex.bool(
        pair_generator.asu_mappings().mappings().size(), False)
      primary_selection[0] = True
      assert pair_generator.neighbors_of(
        primary_selection=primary_selection).count(False) == 0
  pair = asu_mappings.make_trial_pair(i_seq=1, j_seq=0, j_sym=0)
  assert pair.i_seq == 1
  assert pair.j_seq == 0
  assert pair.j_sym == 0
  assert not pair.is_active()
  pair = asu_mappings.make_pair(i_seq=0, j_seq=1, j_sym=1)
  assert pair.i_seq == 0
  assert pair.j_seq == 1
  assert pair.j_sym == 1
  assert pair.is_active()
  from cctbx import xray
  structure = trial_structure()
  asu_mappings = structure.asu_mappings(buffer_thickness=3.5)
  assert list(asu_mappings.site_symmetry_table().indices()) == [1,0,2]
  assert asu_mappings.n_sites_in_asu_and_buffer() == 33
  pair = asu_mappings.make_pair(i_seq=1, j_seq=0, j_sym=1)
  assert pair.i_seq == 1
  assert pair.j_seq == 0
  assert pair.j_sym == 1
  assert pair.is_active(minimal=False)
  assert not pair.is_active(minimal=True)
  for i_seq,m in enumerate(asu_mappings.mappings()):
    for i_sym in range(len(m)):
      rt_mx = asu_mappings.get_rt_mx(i_seq=i_seq, i_sym=i_sym)
      i_sym_found = asu_mappings.find_i_sym(i_seq=i_seq, rt_mx=rt_mx)
      assert i_sym_found == i_sym
      i_sym_found = asu_mappings.find_i_sym(
        i_seq=i_seq,
        rt_mx=sgtbx.rt_mx("0,0,0"))
      assert i_sym_found == -1
      if (i_sym != 0):
        pair_i_seq = max(0, i_seq-1)
        pair = asu_mappings.make_trial_pair(pair_i_seq, i_seq, i_sym)
        assert asu_mappings.get_rt_mx_i(pair=pair) \
            == asu_mappings.get_rt_mx(pair_i_seq, 0)
        assert asu_mappings.get_rt_mx_j(pair=pair) \
            == asu_mappings.get_rt_mx(i_seq, i_sym)
  assert str(asu_mappings.special_op(0)) == "x,y,1/4"
  assert str(asu_mappings.special_op(1)) == "x,y,z"
  assert str(asu_mappings.special_op(2)) == "x-1/2*y,0,0"
  asu_mappings = structure[:0].asu_mappings(buffer_thickness=3.5)
  assert asu_mappings.process_sites_frac(
    original_sites=structure.scatterers().extract_sites()) is asu_mappings
  assert asu_mappings.n_sites_in_asu_and_buffer() == 33
  asu_mappings = structure[:0].asu_mappings(buffer_thickness=3.5)
  assert asu_mappings.process_sites_frac(
    original_sites=structure.scatterers().extract_sites(),
    site_symmetry_table=structure.site_symmetry_table()) is asu_mappings
  assert asu_mappings.n_sites_in_asu_and_buffer() == 33
  asu_mappings = structure[:0].asu_mappings(buffer_thickness=3.5)
  assert asu_mappings.process_sites_cart(
    original_sites=structure.sites_cart()) is asu_mappings
  assert asu_mappings.n_sites_in_asu_and_buffer() == 33
  asu_mappings = structure[:0].asu_mappings(buffer_thickness=3.5)
  assert asu_mappings.process_sites_cart(
    original_sites=structure.sites_cart(),
    site_symmetry_table=structure.site_symmetry_table()) is asu_mappings
  assert asu_mappings.n_sites_in_asu_and_buffer() == 33

def check_pair_asu_table(asu_table, expected_asu_pairs):
  ip = count()
  for i_seq,asu_dict in enumerate(asu_table.table()):
    for j_seq,j_sym_groups in asu_dict.items():
      for j_sym_group in j_sym_groups:
        for j_sym in j_sym_group:
          if (0 or "--verbose" in sys.argv[1:] or expected_asu_pairs is None):
            print(str([i_seq, j_seq, j_sym]) + ",")
          if (expected_asu_pairs is not None):
            assert [i_seq, j_seq, j_sym] == expected_asu_pairs[next(ip)]

def exercise_pair_tables():
  d = crystal.pair_sym_dict()
  assert len(d) == 0
  sym_ops = sgtbx.space_group("P 41").all_ops()
  for i,j_sym in enumerate([10,18,13]):
    d[j_sym] = crystal.pair_sym_ops(sym_ops[:i])
    assert len(d) == i+1
    assert len(d[j_sym]) == i
    assert [str(s) for s in sym_ops[:i]] == [str(s) for s in d[j_sym]]
    d[j_sym] = sym_ops[:i]
    assert [str(s) for s in sym_ops[:i]] == [str(s) for s in d[j_sym]]
  assert [key for key in d] == [10,13,18]
  assert d[13].size() == 2
  d[13].append(sym_ops[-1])
  assert d[13].size() == 3
  del d[13][0]
  assert d[13].size() == 2
  d[13].clear()
  assert d[13].size() == 0
  t = crystal.pair_sym_table()
  t.append(d)
  assert t.size() == 1
  assert len(t[0][10]) == 0
  t.append(d)
  assert t.size() == 2
  assert len(t[1][18]) == 1
  t = crystal.pair_sym_table(3)
  for d in t:
    assert len(d) == 0
  t[1][10] = sym_ops[:2]
  assert len(t[1]) == 1
  assert len(t[1][10]) == 2
  #
  td = t.discard_symmetry()
  assert td.size() == 3
  assert [len(d) for d in td] == [0,1,0]
  assert str(td[1][10][0])=="x,y,z"
  #
  t = crystal.pair_sym_table(size=3)
  t[0].setdefault(1)
  t[0][1].append(sgtbx.rt_mx("-x,y,z"))
  t[1].setdefault(0)
  t[1][0].append(sgtbx.rt_mx("x,-y,-z"))
  u = crystal.pair_sym_table(size=2)
  u[0].setdefault(0)
  u[0][0].append(sgtbx.rt_mx("x,-y,z"))
  u[0].setdefault(1)
  u[0][1].append(sgtbx.rt_mx("x,y,-z"))
  t.add_pair_sym_table_in_place(other=u)
  sio = StringIO()
  t.show(f=sio)
  assert not show_diff(sio.getvalue(), """\
i_seq: 0
  j_seq: 0
    x,-y,z
  j_seq: 1
    -x,y,z
    x,y,-z
i_seq: 1
  j_seq: 0
    x,-y,-z
i_seq: 2
""")
  #
  t = crystal.pair_asu_table_table(3)
  for d in t:
    assert len(d) == 0
  t[1][10] = crystal.pair_asu_j_sym_groups()
  assert t[1][10].size() == 0
  t[1][10].append(crystal.pair_asu_j_sym_group())
  assert t[1][10].size() == 1
  assert t[1][10][0].size() == 0
  t[1][10][0].insert(3)
  assert t[1][10][0].size() == 1
  t[1][10].append(crystal.pair_asu_j_sym_group())
  assert t[1][10][1].size() == 0
  t[1][10][1].insert([4,5,4])
  assert t[1][10][1].size() == 2
  #
  structure = trial_structure_2()
  scattering_types = structure.scatterers().extract_scattering_types()
  asu_mappings = structure.asu_mappings(buffer_thickness=3.5)
  covalent_asu_table = crystal.pair_asu_table(asu_mappings=asu_mappings)
  assert covalent_asu_table.add_covalent_pairs(
    scattering_types=scattering_types) is covalent_asu_table
  # default tolerance is 0.5 Angstrom
  expected_pair_counts = (2, 4, 1, 1, 3, 3, 4, 4, 3, 4, 3, 3, 3,
                          3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1)
  assert approx_equal(covalent_asu_table.pair_counts(), expected_pair_counts)
  covalent_asu_table = crystal.pair_asu_table(asu_mappings=asu_mappings)
  assert covalent_asu_table.add_covalent_pairs(
    scattering_types=scattering_types, tolerance=0.8) is covalent_asu_table
  expected_pair_counts = (2, 5, 1, 1, 3, 3, 4, 4, 3, 5, 3, 3, 3,
                          3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1)
  assert approx_equal(covalent_asu_table.pair_counts(), expected_pair_counts)
  covalent_asu_table = crystal.pair_asu_table(asu_mappings=asu_mappings)
  assert covalent_asu_table.add_covalent_pairs(
    scattering_types=scattering_types,
    exclude_scattering_types=flex.std_string(["H","D"])) is covalent_asu_table
  expected_pair_counts = (2, 4, 1, 1, 3, 3, 1, 4, 3, 2, 2, 3, 2,
                          2, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0)
  assert approx_equal(covalent_asu_table.pair_counts(), expected_pair_counts)
  #
  structure.add_scatterer(xray.scatterer(label='O1a', site=(0.28, 0.48, 0.23)))
  scattering_types = structure.scatterers().extract_scattering_types()
  asu_mappings = structure.asu_mappings(buffer_thickness=3.5)
  covalent_asu_table = crystal.pair_asu_table(asu_mappings=asu_mappings)
  conformer_indices = flex.size_t(structure.scatterers().size(), 0)
  conformer_indices[2] = 1 # scatterer O1
  conformer_indices[-1] = 2 # scatterer O1a
  covalent_asu_table.add_covalent_pairs(
    scattering_types=scattering_types, conformer_indices=conformer_indices)
  assert covalent_asu_table.pair_counts()[-1] == 1
  assert covalent_asu_table.pair_counts()[2] == 1
  #
  xs = xray.structure(
    crystal_symmetry=crystal.symmetry(
      unit_cell="10 10 10 90 90 90",
      space_group_symbol="P-1"),
    scatterers=flex.xray_scatterer([
      xray.scatterer("C1", site=(0.05, 0.05, 0.05)),
      xray.scatterer("C2", site=(0.15, 0.15, 0.15)),
      xray.scatterer("C3", site=(0.25, 0.25, 0.25))]))
  scattering_types = xs.scatterers().extract_scattering_types()
  asu_mappings = xs.asu_mappings(buffer_thickness=3.5)
  covalent_asu_table = crystal.pair_asu_table(asu_mappings=asu_mappings)
  covalent_asu_table.add_covalent_pairs(scattering_types=scattering_types)
  assert approx_equal(covalent_asu_table.pair_counts(), (2, 2, 1))
  sym_excl_indices = flex.size_t([1, 1, 0])
  covalent_asu_table = crystal.pair_asu_table(asu_mappings=asu_mappings)
  covalent_asu_table.add_covalent_pairs(
    scattering_types=scattering_types, sym_excl_indices=sym_excl_indices)
  assert approx_equal(covalent_asu_table.pair_counts(), (1, 2, 1))
  xs.add_scatterer(xray.scatterer(label="C4", site=(0.16, 0.16, 0.16)))
  sym_excl_indices.append(0)
  conformer_indices = flex.size_t([0, 0, 0, 1])
  scattering_types = xs.scatterers().extract_scattering_types()
  asu_mappings = xs.asu_mappings(buffer_thickness=3.5)
  covalent_asu_table = crystal.pair_asu_table(asu_mappings=asu_mappings)
  covalent_asu_table.add_covalent_pairs(scattering_types=scattering_types,
                                        sym_excl_indices=sym_excl_indices,
                                        conformer_indices=conformer_indices)
  assert approx_equal(covalent_asu_table.pair_counts(), (1, 2, 2, 1))
  #
  xs = xray.structure(
    crystal_symmetry=crystal.symmetry(
      unit_cell="10 10 10 90 90 90",
      space_group_symbol="P1"),
    scatterers=flex.xray_scatterer([
      xray.scatterer("C1", site=(0.0, 0.0, 0.0)),
      xray.scatterer("C2", site=(-0.1, 0.1, 0.0)),
      xray.scatterer("C3", site=(0.1, 0.1, 0.0)),
      xray.scatterer("C4", site=(0.1, -0.1, 0.0)),
      xray.scatterer("C5", site=(-0.1, -0.1, 0.0)),
    ]))
  scattering_types = xs.scatterers().extract_scattering_types()
  asu_mappings = xs.asu_mappings(buffer_thickness=3.5)
  covalent_asu_table = crystal.pair_asu_table(asu_mappings=asu_mappings)
  #central to the peripheral, > sqrt(2)/2
  covalent_asu_table.add_covalent_pairs(scattering_types=scattering_types,
                                        radii={'C' : 0.71}, tolerance=0)
  assert approx_equal(covalent_asu_table.pair_counts(), (4, 1, 1, 1, 1))
  #central to the peripharal + peripheral to two neighbours, > 1
  covalent_asu_table.add_covalent_pairs(scattering_types=scattering_types,
                                        radii={'C' : 1.01}, tolerance=0)
  assert approx_equal(covalent_asu_table.pair_counts(), (4, 3, 3, 3, 3))
  #
  structure = trial_structure()
  asu_mappings = structure.asu_mappings(buffer_thickness=3.5)
  asu_table = crystal.pair_asu_table(asu_mappings=asu_mappings)
  assert asu_table.table().size() == 3
  assert not asu_table.contains(i_seq=0, j_seq=1, j_sym=2)
  assert asu_table.pair_counts().all_eq(0)
  assert list(asu_table.cluster_pivot_selection()) == [0,1,2]
  assert list(asu_table.cluster_pivot_selection(general_positions_only=True)) \
      == [1]
  assert list(asu_table.cluster_pivot_selection(max_clusters=2)) == [0,1]
  assert asu_table.add_all_pairs(distance_cutoff=3.5) is asu_table
  assert [d.size() for d in asu_table.table()] == [2,3,2]
  assert asu_table.add_all_pairs(3.5, epsilon=1.e-6) is asu_table
  assert [d.size() for d in asu_table.table()] == [2,3,2]
  expected_asu_pairs = [
    [0, 0, 2], [0, 0, 1], [0, 1, 0], [0, 1, 8],
    [1, 0, 0], [1, 1, 4], [1, 1, 1], [1, 2, 0],
    [2, 1, 0], [2, 1, 11], [2, 2, 1], [2, 2, 2]]
  check_pair_asu_table(asu_table, expected_asu_pairs)
  asu_table = crystal.pair_asu_table(asu_mappings=asu_mappings)
  for minimal in [True, False]:
    pair_generator = crystal.neighbors_fast_pair_generator(
      asu_mappings,
      distance_cutoff=3.5,
      minimal=minimal,
      min_cubicle_edge=0)
    for pair in pair_generator:
      asu_table.add_pair(pair=pair)
    asu_table.pair_counts().all_eq(4)
    assert asu_table.cluster_pivot_selection().size() == 0
    check_pair_asu_table(asu_table, expected_asu_pairs)
  for p in expected_asu_pairs:
    assert asu_table.contains(i_seq=p[0], j_seq=p[1], j_sym=p[2])
    pair = asu_mappings.make_trial_pair(*p)
    assert pair in asu_table
  f = StringIO()
  asu_table.show(f=f)
  assert f.getvalue() == """\
i_seq: 0
  j_seq: 0
    j_syms: [2]
    j_syms: [1]
  j_seq: 1
    j_syms: [0, 8]
i_seq: 1
  j_seq: 0
    j_syms: [0]
  j_seq: 1
    j_syms: [4]
    j_syms: [1]
  j_seq: 2
    j_syms: [0]
i_seq: 2
  j_seq: 1
    j_syms: [0, 11]
  j_seq: 2
    j_syms: [1, 2]
"""
  f = StringIO()
  asu_table.show(
    f=f,
    site_labels=["Si"]*3)
  assert not show_diff(f.getvalue(), """\
Si(0)
  Si(0)
    j_syms: [2]
    j_syms: [1]
  Si(1)
    j_syms: [0, 8]
Si(1)
  Si(0)
    j_syms: [0]
  Si(1)
    j_syms: [4]
    j_syms: [1]
  Si(2)
    j_syms: [0]
Si(2)
  Si(1)
    j_syms: [0, 11]
  Si(2)
    j_syms: [1, 2]
""")
  assert not asu_table.contains(i_seq=1, j_seq=1, j_sym=10)
  pair = asu_mappings.make_trial_pair(i_seq=1, j_seq=1, j_sym=10)
  assert not pair in asu_table
  assert asu_table == asu_table
  assert not asu_table != asu_table
  other = crystal.pair_asu_table(asu_mappings=asu_mappings)
  assert not asu_table == other
  assert asu_table != other
  for skip_j_seq_less_than_i_seq in [False, True]:
    sym_table = asu_table.extract_pair_sym_table(
      skip_j_seq_less_than_i_seq=skip_j_seq_less_than_i_seq)
    assert sym_table.size() == asu_table.table().size()
    expected_sym_pairs = [
      [0, 0, '-y+1,-x+1,-z+1/2'],
      [0, 0, 'x,x-y+2,-z+1/2'],
      [0, 1, '-y+1,x-y+1,-z+1/2'],
        [1, 0, '-x+y,-x+1,-z+1/2'],
      [1, 1, 'x,x-y+1,z'],
      [1, 1, '-y+1,-x+1,z'],
      [1, 2, '-x+1,-x+y+1,-z'],
        [2, 1, '-x+1,-x+y,-z'],
      [2, 2, 'y,-x+y,-z']]
    ip = count()
    for i_seq,sym_dict in enumerate(sym_table):
      for j_seq,rt_mx_list in sym_dict.items():
        for rt_mx in rt_mx_list:
          while 1:
            expected = expected_sym_pairs[next(ip)]
            if (not (skip_j_seq_less_than_i_seq and expected[1]<expected[0])):
              break
          if (0 or "--verbose" in sys.argv[1:]):
            print(str([i_seq, j_seq, str(rt_mx)]) + ",")
          assert [i_seq, j_seq, str(rt_mx)] == expected
    asu_table = crystal.pair_asu_table(asu_mappings=asu_mappings)
    assert asu_table.add_pair_sym_table(sym_table=sym_table) is asu_table
    check_pair_asu_table(asu_table, expected_asu_pairs)
    eq_flags = []
    asu_table_2 = crystal.pair_asu_table(asu_mappings=asu_mappings)
    for p in expected_sym_pairs:
      assert asu_table_2.add_pair(
        i_seq=p[0], j_seq=p[1], rt_mx_ji=sgtbx.rt_mx(p[2])) is asu_table_2
      eq_flags.append(asu_table_2 == asu_table)
      assert (asu_table_2 == asu_table) != (asu_table_2 != asu_table)
    check_pair_asu_table(asu_table_2, expected_asu_pairs)
    assert eq_flags[:-1].count(eq_flags[0]) == len(eq_flags)-1
    assert eq_flags[-1]
    #
    u_isos = flex.double([0.01,0.09,0.1])
    adp_energies = adp_iso_local_sphere_restraints_energies_functor(
      pair_sym_table=sym_table,
      orthogonalization_matrix
        =structure.unit_cell().orthogonalization_matrix(),
      sites_frac=structure.sites_frac())
    for compute_gradients in [False, True]:
      energies = adp_energies(
        u_isos=u_isos,
        compute_gradients=compute_gradients,
        collect=not compute_gradients)
      assert energies.number_of_restraints in [7,9]
      if (energies.number_of_restraints == 9):
        assert approx_equal(energies.residual_sum, 0.0258118381912)
      else:
        assert approx_equal(energies.residual_sum, 0.0129059190956)
      if (not compute_gradients):
        assert energies.gradients.size() == 0
        assert energies.u_i.size() == energies.number_of_restraints
        assert energies.u_j.size() == energies.number_of_restraints
        assert energies.r_ij.size() == energies.number_of_restraints
      else:
        if (energies.number_of_restraints == 9):
          assert approx_equal(energies.gradients,
            [-0.76572900915133457, 0.45222175022876354, 0.056750898576746159])
        else:
          assert approx_equal(energies.gradients,
            [-0.38286450457566729, 0.22611087511438174, 0.028375449288373083])
        assert approx_equal(
          energies.gradients,
          adp_energies.finite_difference_gradients(u_isos=u_isos))
        assert energies.u_i.size() == 0
        assert energies.u_j.size() == 0
        assert energies.r_ij.size() == 0
    for i_trial in range(5):
      u_isos = u_isos.select(flex.random_permutation(size=u_isos.size()))
      for distance_power in [0.3, 0.8, 1, 1.7]:
        for average_power in [0.4, 0.9, 1, 1.5]:
          energies = adp_energies(
            u_isos=u_isos,
            distance_power=distance_power,
            average_power=average_power,
            compute_gradients=True)
          assert approx_equal(
            energies.gradients,
            adp_energies.finite_difference_gradients(
              u_isos=u_isos,
              distance_power=distance_power,
              average_power=average_power))
    #
    distances = crystal.get_distances(
      pair_sym_table=sym_table,
      orthogonalization_matrix
        =structure.unit_cell().orthogonalization_matrix(),
      sites_frac=structure.sites_frac())
    if (not skip_j_seq_less_than_i_seq):
      assert approx_equal(distances,
        [3.0504188000000001, 3.1821727999999987, 3.1703090658301503,
         3.1703090658301503, 3.0177940000000003, 3.1658603999999984,
         3.1986122507292754, 3.1986122507292754, 3.1093943999999989])
    else:
      assert approx_equal(distances,
        [3.0504188000000001, 3.1821727999999987, 3.1703090658301503,
         3.0177940000000003, 3.1658603999999984, 3.1986122507292754,
         3.1093943999999989])
      f = StringIO()
      sym_table.show(f=f)
      assert f.getvalue() == """\
i_seq: 0
  j_seq: 0
    -y+1,-x+1,-z+1/2
    x,x-y+2,-z+1/2
  j_seq: 1
    -y+1,x-y+1,-z+1/2
i_seq: 1
  j_seq: 1
    x,x-y+1,z
    -y+1,-x+1,z
  j_seq: 2
    -x+1,-x+y+1,-z
i_seq: 2
  j_seq: 2
    y,-x+y,-z
"""
      f = StringIO()
      sym_table.show(
        f=f,
        site_labels=["Si"]*3)
      assert f.getvalue() == """\
Si(0)
  Si(0)
    -y+1,-x+1,-z+1/2
    x,x-y+2,-z+1/2
  Si(1)
    -y+1,x-y+1,-z+1/2
Si(1)
  Si(1)
    x,x-y+1,z
    -y+1,-x+1,z
  Si(2)
    -x+1,-x+y+1,-z
Si(2)
  Si(2)
    y,-x+y,-z
"""
      f = StringIO()
      sym_table.show(
        f=f,
        site_labels=["Si"]*3,
        site_symmetry_table=structure.site_symmetry_table())
      assert not show_diff(f.getvalue(), """\
Si(0)
  Si(0)
    -y+1,-x+1,-z+1/2
    x,x-y+2,-z+1/2
  Si(1)
    -y+1,x-y+1,-z+1/2
    -y+1,x-y+1,z       sym. equiv.
Si(1)
  Si(1)
    x,x-y+1,z
    -y+1,-x+1,z
  Si(2)
    -x+y+1,-x+1,z
Si(2)
  Si(2)
    y,-x+y,-z
    x-y,x,-z   sym. equiv.
""")
      f = StringIO()
      sym_table.show(
        f=f,
        site_labels=["Si"]*3,
        sites_frac=structure.sites_frac(),
        unit_cell=structure.unit_cell())
      assert not show_diff(f.getvalue(), """\
Si(0)
  Si(0)
    -y+1,-x+1,-z+1/2    3.0504
    x,x-y+2,-z+1/2      3.1822
  Si(1)
    -y+1,x-y+1,-z+1/2    3.1703
Si(1)
  Si(1)
    x,x-y+1,z      3.0178
    -y+1,-x+1,z    3.1659
  Si(2)
    -x+1,-x+y+1,-z    3.1986
Si(2)
  Si(2)
    y,-x+y,-z    3.1094
""")
      f = StringIO()
      sym_table.show(
        f=f,
        site_labels=["Si"]*3,
        site_symmetry_table=structure.site_symmetry_table(),
        sites_frac=structure.sites_frac(),
        unit_cell=structure.unit_cell())
      assert not show_diff(f.getvalue(), """\
Si(0)
  Si(0)
    -y+1,-x+1,-z+1/2    3.0504
    x,x-y+2,-z+1/2      3.1822
  Si(1)
    -y+1,x-y+1,-z+1/2    3.1703
    -y+1,x-y+1,z         3.1703  sym. equiv.
Si(1)
  Si(1)
    x,x-y+1,z      3.0178
    -y+1,-x+1,z    3.1659
  Si(2)
    -x+y+1,-x+1,z    3.1986
Si(2)
  Si(2)
    y,-x+y,-z    3.1094
    x-y,x,-z     3.1094  sym. equiv.
""")
      #
      structure_plus = structure.deep_copy_scatterers()
      structure_plus.add_scatterer(xray.scatterer(
        label="O",
        site=(0,0,0)))
      sym_table.append(crystal.pair_sym_dict())
      sio = StringIO()
      pair_counts = structure_plus.pair_sym_table_show_distances(
        pair_sym_table=sym_table,
        skip_j_seq_less_than_i_seq=True,
        out=sio)
      assert not show_diff(sio.getvalue(), """\
Si0  pair count:   4       <<  0.2466,  0.9965,  0.2500>>
  Si0:   3.0504             (  0.0035,  0.7534,  0.2500) sym=-y+1,-x+1,-z+1/2
  Si1:   3.1703             (  0.3294,  0.9111,  0.3746) sym=-y+1,x-y+1,-z+1/2
  Si1:   3.1703 sym. equiv. (  0.3294,  0.9111,  0.1254) sym=-y+1,x-y+1,z
  Si0:   3.1822             (  0.2466,  1.2501,  0.2500) sym=x,x-y+2,-z+1/2
Si1  pair count:   3       <<  0.5817,  0.6706,  0.1254>>
  Si1:   3.0178             (  0.5817,  0.9111,  0.1254) sym=x,x-y+1,z
  Si1:   3.1659             (  0.3294,  0.4183,  0.1254) sym=-y+1,-x+1,z
  Si2:   3.1986             (  0.7522,  0.7522,  0.0000) sym=-x+y+1,-x+1,z
Si2  pair count:   2       <<  0.2478,  0.0000,  0.0000>>
  Si2:   3.1094             (  0.0000, -0.2478,  0.0000) sym=y,-x+y,-z
  Si2:   3.1094 sym. equiv. (  0.2478,  0.2478,  0.0000) sym=x-y,x,-z
O    pair count:   0       <<  0.0000,  0.0000,  0.0000>>
  no neighbors
""")
      assert list(pair_counts) == [4,3,2,0]
      del sym_table[-1]
      sio = StringIO()
      sym_table.show_distances(
        unit_cell=structure.unit_cell(),
        site_symmetry_table=structure.site_symmetry_table(),
        sites_cart=structure.sites_cart(),
        show_cartesian=True,
        skip_j_seq_less_than_i_seq=True,
        out=sio)
      assert not show_diff(sio.getvalue(), """\
site_1 pair count:   4        <<   -3.16,   10.83,    5.20>>
  site_1:   3.0504             (   -4.68,    8.19,    5.20) sym=-y+1,-x+1,-z+1/2
  site_2:   3.1703             (   -1.58,    9.90,    7.79) sym=-y+1,x-y+1,-z+1/2
  site_2:   3.1703 sym. equiv. (   -1.58,    9.90,    2.61) sym=-y+1,x-y+1,z
  site_1:   3.1822             (   -4.75,   13.58,    5.20) sym=x,x-y+2,-z+1/2
site_2 pair count:   3        <<    3.09,    7.29,    2.61>>
  site_2:   3.0178             (    1.58,    9.90,    2.61) sym=x,x-y+1,z
  site_2:   3.1659             (    1.51,    4.55,    2.61) sym=-y+1,-x+1,z
  site_3:   3.1986             (    4.72,    8.17,    0.00) sym=-x+y+1,-x+1,z
site_3 pair count:   2        <<    3.11,    0.00,    0.00>>
  site_3:   3.1094             (    1.55,   -2.69,    0.00) sym=y,-x+y,-z
  site_3:   3.1094 sym. equiv. (    1.55,    2.69,    0.00) sym=x-y,x,-z
""")
      sio = StringIO()
      structure_plus.pair_sym_table_show_distances(
        pair_sym_table=sym_table,
        skip_sym_equiv=True,
        out=sio)
      assert not show_diff(sio.getvalue(), """\
Si0  pair count:   3       <<  0.2466,  0.9965,  0.2500>>
  Si0:   3.0504             (  0.0035,  0.7534,  0.2500) sym=-y+1,-x+1,-z+1/2
  Si1:   3.1703             (  0.3294,  0.9111,  0.3746) sym=-y+1,x-y+1,-z+1/2
  Si0:   3.1822             (  0.2466,  1.2501,  0.2500) sym=x,x-y+2,-z+1/2
Si1  pair count:   4       <<  0.5817,  0.6706,  0.1254>>
  Si1:   3.0178             (  0.5817,  0.9111,  0.1254) sym=x,x-y+1,z
  Si1:   3.1659             (  0.3294,  0.4183,  0.1254) sym=-y+1,-x+1,z
  Si0:   3.1703             (  0.7499,  0.7534,  0.2500) sym=-x+y,-x+1,-z+1/2
  Si2:   3.1986             (  0.7522,  0.7522,  0.0000) sym=-x+y+1,-x+1,z
Si2  pair count:   2       <<  0.2478,  0.0000,  0.0000>>
  Si2:   3.1094             (  0.0000, -0.2478,  0.0000) sym=y,-x+y,-z
  Si1:   3.1986             (  0.3294, -0.0889,  0.1254) sym=-y+1,x-y,z
""")
      sio = StringIO()
      structure_plus.pair_sym_table_show_distances(
        pair_sym_table=sym_table,
        skip_j_seq_less_than_i_seq=True,
        skip_sym_equiv=True,
        out=sio)
      assert not show_diff(sio.getvalue(), """\
Si0  pair count:   3       <<  0.2466,  0.9965,  0.2500>>
  Si0:   3.0504             (  0.0035,  0.7534,  0.2500) sym=-y+1,-x+1,-z+1/2
  Si1:   3.1703             (  0.3294,  0.9111,  0.3746) sym=-y+1,x-y+1,-z+1/2
  Si0:   3.1822             (  0.2466,  1.2501,  0.2500) sym=x,x-y+2,-z+1/2
Si1  pair count:   3       <<  0.5817,  0.6706,  0.1254>>
  Si1:   3.0178             (  0.5817,  0.9111,  0.1254) sym=x,x-y+1,z
  Si1:   3.1659             (  0.3294,  0.4183,  0.1254) sym=-y+1,-x+1,z
  Si2:   3.1986             (  0.7522,  0.7522,  0.0000) sym=-x+y+1,-x+1,z
Si2  pair count:   1       <<  0.2478,  0.0000,  0.0000>>
  Si2:   3.1094             (  0.0000, -0.2478,  0.0000) sym=y,-x+y,-z
""")
  #
  sites_cart = flex.vec3_double([(0,0,0), (2,0,0), (0,3,0)])
  asu_mappings = crystal.direct_space_asu.non_crystallographic_asu_mappings(
    sites_cart=sites_cart)
  bond_asu_table = crystal.pair_asu_table(asu_mappings=asu_mappings)
  bond_asu_table.add_all_pairs(distance_cutoff=3)
  f = StringIO()
  bond_asu_table.show(f=f)
  assert f.getvalue() == """\
i_seq: 0
  j_seq: 1
    j_syms: [0]
  j_seq: 2
    j_syms: [0]
i_seq: 1
  j_seq: 0
    j_syms: [0]
i_seq: 2
  j_seq: 0
    j_syms: [0]
"""
  sym_table = bond_asu_table.extract_pair_sym_table()
  f = StringIO()
  sym_table.show(f=f)
  assert f.getvalue() == """\
i_seq: 0
  j_seq: 1
    x,y,z
  j_seq: 2
    x,y,z
i_seq: 1
i_seq: 2
"""
  distances = crystal.get_distances(
    pair_sym_table=sym_table,
    sites_cart=sites_cart)
  assert approx_equal(distances, [2,3])
  #
  # Zeolite framework type ASV
  sym_table = crystal.pair_sym_table(5)
  d = sym_table[0].setdefault(0)
  d.append(sgtbx.rt_mx("x,y,-z"))
  d.append(sgtbx.rt_mx("-y+1,x,z"))
  d = sym_table[0].setdefault(1)
  d.append(sgtbx.rt_mx("x,y,z"))
  d = sym_table[0].setdefault(2)
  d.append(sgtbx.rt_mx("x,y,z"))
  d = sym_table[0].setdefault(3)
  d.append(sgtbx.rt_mx("x,y,z"))
  d.append(sgtbx.rt_mx("y,-x+1,z"))
  d = sym_table[0].setdefault(4)
  d.append(sgtbx.rt_mx("x,y,z"))
  d = sym_table[1].setdefault(4)
  d.append(sgtbx.rt_mx("x,y,z"))
  d = sym_table[2].setdefault(3)
  d.append(sgtbx.rt_mx("x,y,z"))
  d.append(sgtbx.rt_mx("y,-x+1,z"))
  d = sym_table[2].setdefault(4)
  d.append(sgtbx.rt_mx("x,y,z"))
  d = sym_table[3].setdefault(3)
  d.append(sgtbx.rt_mx("-y+1,x,z"))
  d = sym_table[3].setdefault(4)
  d.append(sgtbx.rt_mx("x,y,z"))
  d.append(sgtbx.rt_mx("-y+1,x,z"))
  d = sym_table[4].setdefault(4)
  d.append(sgtbx.rt_mx("x,-y+1,-z+1/2"))
  d.append(sgtbx.rt_mx("-x,y,-z+1/2"))
  d.append(sgtbx.rt_mx("-x,-y+1,z"))
  out = StringIO()
  sym_table.show(f=out)
  assert out.getvalue() == """\
i_seq: 0
  j_seq: 0
    x,y,-z
    -y+1,x,z
  j_seq: 1
    x,y,z
  j_seq: 2
    x,y,z
  j_seq: 3
    x,y,z
    y,-x+1,z
  j_seq: 4
    x,y,z
i_seq: 1
  j_seq: 4
    x,y,z
i_seq: 2
  j_seq: 3
    x,y,z
    y,-x+1,z
  j_seq: 4
    x,y,z
i_seq: 3
  j_seq: 3
    -y+1,x,z
  j_seq: 4
    x,y,z
    -y+1,x,z
i_seq: 4
  j_seq: 4
    x,-y+1,-z+1/2
    -x,y,-z+1/2
    -x,-y+1,z
"""
  out = StringIO()
  for i_seq in range(5):
    sym_table.proxy_select(flex.size_t([i_seq])).show(f=out)
  assert out.getvalue() == """\
i_seq: 0
  j_seq: 0
    x,y,-z
    -y+1,x,z
i_seq: 0
i_seq: 0
i_seq: 0
  j_seq: 0
    -y+1,x,z
i_seq: 0
  j_seq: 0
    x,-y+1,-z+1/2
    -x,y,-z+1/2
    -x,-y+1,z
"""
  out = StringIO()
  sym_table.proxy_select(flex.size_t([1,2,4])).show(f=out)
  assert out.getvalue() == """\
i_seq: 0
  j_seq: 2
    x,y,z
i_seq: 1
  j_seq: 2
    x,y,z
i_seq: 2
  j_seq: 2
    x,-y+1,-z+1/2
    -x,y,-z+1/2
    -x,-y+1,z
"""
  out = StringIO()
  sym_table.proxy_select(flex.size_t([3,0,2])).show(f=out)
  assert out.getvalue() == """\
i_seq: 0
  j_seq: 0
    -y+1,x,z
i_seq: 1
  j_seq: 0
    x,y,z
    y,-x+1,z
  j_seq: 1
    x,y,-z
    -y+1,x,z
  j_seq: 2
    x,y,z
i_seq: 2
  j_seq: 0
    x,y,z
    y,-x+1,z
"""
  #
  sym_table = crystal.pair_sym_table(5)
  sym_table[0].setdefault(2)
  sym_table[3].setdefault(3)
  assert [sym_table.is_paired(i_seq=i_seq) for i_seq in range(5)] \
      == [True, False, True, True, False]
  #
  asu_mappings = structure.asu_mappings(buffer_thickness=2*3.5)
  asu_table = crystal.pair_asu_table(asu_mappings=asu_mappings)
  asu_table.add_all_pairs(distance_cutoff=3.5)
  apat = asu_table.angle_pair_asu_table()
  assert apat.as_nested_lists() == [[0, [0, [20, 23]], [1, [5, 21],
    [3, 23], [2, 38]], [2, [0, 3]]], [1, [0, [7], [1], [10]], [1, [13],
    [32, 36], [20]], [2, [7], [10], [1]]], [2, [0, [0, 3]], [1, [5, 9],
    [2, 12], [3, 7]], [2, [14, 21]]]]
  asu_table = crystal.pair_asu_table(asu_mappings=asu_mappings)
  asu_table.add_all_pairs(distance_cutoff=3.1)
  assert asu_table.table()[2].size() == 0
  apat = asu_table.angle_pair_asu_table()
  assert apat.as_nested_lists() == [[0], [1], [2]]

def exercise_pair_sym_table_tidy():
  xs = trial_structure().select(flex.size_t([0,1]))
  for s10 in [sgtbx.rt_mx(_) for _ in ["-y+1,x-y+1,-z+1/2", "-y+1,x-y+1,z"]]:
    def check(i, j, s):
      _ = crystal.pair_sym_table(size=2)
      _[i].setdefault(j)
      _[i][j].append(s)
      sym_table = _.tidy(site_symmetry_table=xs.site_symmetry_table())
      sio = StringIO()
      sym_table.show(f=sio)
      assert not show_diff(sio.getvalue(), """\
i_seq: 0
  j_seq: 1
    -y+1,x-y+1,-z+1/2
i_seq: 1
""")
    check(0, 1, s10)
    check(1, 0, s10.inverse())

def exercise_fix_for_missed_interaction_inside_asu():
  """
  The cctbx machinery used to return a bond between C1
  and a symmetry equivalent C3' of C3 but it turns out
  that C1 is on a special position and its site is invariant
  under that operator moving C3 to C3' (the operator is -x+1,y,-z+3/2)
  and there is therefore a bond between C1 and C3. That it used not to be
  reported was deemed as a bug which got fixed, this file being the
  regression test for that fix.
  """
  from cctbx import xray
  xs = xray.structure(
    crystal_symmetry=crystal.symmetry(
      unit_cell=(17.0216, 8.4362, 10.2248, 90, 102.79, 90),
      space_group_symbol='hall: -C 2yc'),
    scatterers=flex.xray_scatterer((
      xray.scatterer(
                      label='C1',
                      site=(0.500000, 0.867770, 0.750000)),
      xray.scatterer(
                      label='C3',
                      site=(0.425860, 0.971240, 0.682160)),
      )))

  asu_mappings = xs.asu_mappings(buffer_thickness=2)
  pair_asu_table = crystal.pair_asu_table(asu_mappings)
  gen = crystal.neighbors_fast_pair_generator(asu_mappings,
                                              distance_cutoff=3.5,
                                              minimal=True)
  pair = next(gen)
  pair_asu_table.add_pair(pair)
  pair_sym_table = pair_asu_table.extract_pair_sym_table()
  result = []
  for i, neighbours in enumerate(pair_sym_table):
    for j, ops in neighbours.items():
      for op in ops:
        result.append((i, j, str(op)))
  assert result == [
    (0, 1, "x,y,z") ]


def exercise_all_bonds_from_inside_asu():
  from cctbx import xray
  structure = trial_structure()
  asu_mappings = structure.asu_mappings(buffer_thickness=3.5)
  asu_table = crystal.pair_asu_table(asu_mappings=asu_mappings)
  pair_generator = crystal.neighbors_fast_pair_generator(asu_mappings,
                                                         distance_cutoff=3.5)
  for pair in pair_generator:
    asu_table.add_pair(pair)
  sym_table = asu_table.extract_pair_sym_table(
    all_interactions_from_inside_asu=True)
  expected_sym_pairs = [
    [0, 0, '-y+1,-x+1,-z+1/2'],
    [0, 0, 'x,x-y+2,-z+1/2'],
    [0, 1, '-y+1,x-y+1,-z+1/2'],
    [0, 1, '-y+1,x-y+1,z'],
    [1, 1, 'x,x-y+1,z'],
    [1, 1, '-y+1,-x+1,z'],
    [1, 2, '-x+1,-x+y+1,-z'],
    [2, 2, 'y,-x+y,-z'],
    [2, 2, 'x-y,x,-z'],
  ]
  ip = count()
  for i_seq, sym_dict in enumerate(sym_table):
    for j_seq, rt_mx_list in sym_dict.items():
      for rt_mx in rt_mx_list:
        expected = expected_sym_pairs[next(ip)]
        assert [i_seq, j_seq, str(rt_mx)] == expected

  xs = xray.structure(
    crystal_symmetry=crystal.symmetry(
      unit_cell=(17.0216, 8.4362, 10.2248, 90, 102.79, 90),
      space_group_symbol='hall: -C 2yc'),
    scatterers=flex.xray_scatterer((
      xray.scatterer(
                      label='C1',
                      site=(0.500000, 0.867770, 0.750000)),
      xray.scatterer(
                      label='C3',
                      site=(0.425860, 0.971240, 0.682160)),
      )))

  asu_mappings = xs.asu_mappings(buffer_thickness=2)
  pair_asu_table = crystal.pair_asu_table(asu_mappings)
  gen = crystal.neighbors_fast_pair_generator(asu_mappings,
                                              distance_cutoff=3.5,
                                              minimal=True)
  pair = next(gen)
  pair_asu_table.add_pair(pair)

  pair_sym_table = pair_asu_table.extract_pair_sym_table(
    all_interactions_from_inside_asu=True)
  result = []
  for i, neighbours in enumerate(pair_sym_table):
    for j, ops in neighbours.items():
      for op in ops:
        result.append((i, j, str(op)))
  assert result == [
    (0, 1, "-x+1,y,-z+3/2"),
    (0, 1, "x,y,z"),
    ]

  pair_sym_table = pair_asu_table.extract_pair_sym_table(
    skip_j_seq_less_than_i_seq=False,
    all_interactions_from_inside_asu=True)
  result = []
  for i, neighbours in enumerate(pair_sym_table):
    for j, ops in neighbours.items():
      for op in ops:
        result.append((i, j, str(op)))
  assert result == [
    (0, 1, "-x+1,y,-z+3/2"),
    (0, 1, "x,y,z"),
    (1, 0, "x,y,z"),
    ]


class adp_iso_local_sphere_restraints_energies_functor(object):

  def __init__(self, pair_sym_table, orthogonalization_matrix, sites_frac):
    adopt_init_args(self, locals())

  def __call__(self,
        u_isos,
        sphere_radius=5.0,
        distance_power=0.7,
        average_power=0.5,
        compute_gradients=False,
        collect=False):
    sel = flex.bool(u_isos.size(),True)
    return crystal.adp_iso_local_sphere_restraints_energies(
      pair_sym_table=self.pair_sym_table,
      orthogonalization_matrix=self.orthogonalization_matrix,
      sites_frac=self.sites_frac,
      u_isos=u_isos,
      selection = sel,
      use_u_iso = sel,
      grad_u_iso= sel,
      sphere_radius=sphere_radius,
      distance_power=distance_power,
      average_power=average_power,
      min_u_sum=1.e-6,
      compute_gradients=compute_gradients,
      collect=collect)

  def finite_difference_gradients(self,
        u_isos,
        distance_power=0.7,
        average_power=0.5,
        eps=1.e-6):
    gs = flex.double()
    for i_u in range(u_isos.size()):
      rs = []
      for signed_eps in [eps,-eps]:
        u_isos_eps = u_isos.deep_copy()
        u_isos_eps[i_u] += signed_eps
        energies = self(
          u_isos=u_isos_eps,
          distance_power=distance_power,
          average_power=average_power)
        rs.append(energies.residual_sum)
      gs.append((rs[0]-rs[1])/(2*eps))
    return gs

def exercise_coordination_sequences_simple():
  structure = trial_structure()
  asu_mappings = structure.asu_mappings(buffer_thickness=3.5)
  asu_table = crystal.pair_asu_table(asu_mappings=asu_mappings)
  asu_table.add_all_pairs(distance_cutoff=3.5)
  term_table = crystal.coordination_sequences.simple(
    pair_asu_table=asu_table,
    max_shell=5)
  assert [list(terms) for terms in term_table] \
      == [[1,4,10,20,34,54], [1,4,10,20,34,53], [1,4,10,20,34,54]]
  asu_mappings = structure.asu_mappings(buffer_thickness=12)
  asu_table = crystal.pair_asu_table(asu_mappings=asu_mappings)
  asu_table.add_pair(i_seqs=[0, 1])
  asu_table.add_pair([0, 2])
  asu_table.add_pair([1, 2])
  expected_asu_pairs = [
    [0, 1, 78], [0, 1, 121], [0, 2, 12], [0, 2, 72],
    [1, 0, 67], [1, 2, 67],
    [2, 0, 8], [2, 0, 79], [2, 1, 107], [2, 1, 120]]
  check_pair_asu_table(asu_table, expected_asu_pairs)

def exercise_coordination_sequences_shell_asu_tables():
  structure = trial_structure()
  asu_mappings = structure.asu_mappings(buffer_thickness=12)
  asu_table = crystal.pair_asu_table(asu_mappings=asu_mappings)
  asu_table.add_all_pairs(distance_cutoff=3.5)
  expected_asu_pairs = [
    [0, 0, 25], [0, 0, 3], [0, 1, 0], [0, 1, 64],
    [1, 0, 0], [1, 1, 27], [1, 1, 4], [1, 2, 0],
    [2, 1, 0], [2, 1, 83], [2, 2, 3], [2, 2, 25]]
  check_pair_asu_table(asu_table, expected_asu_pairs)
  shell_asu_tables = crystal.coordination_sequences.shell_asu_tables(
    pair_asu_table=asu_table,
    max_shell=3)
  check_pair_asu_table(shell_asu_tables[0], expected_asu_pairs)
  s = StringIO()
  structure.show_distances(pair_asu_table=shell_asu_tables[1], out=s)
  print(file=s)
  s1_sym_table = shell_asu_tables[1].extract_pair_sym_table(
    skip_j_seq_less_than_i_seq=False)
  s1_asu_table = crystal.pair_asu_table(asu_mappings=asu_mappings)
  s1_asu_table.add_pair_sym_table(sym_table=s1_sym_table)
  structure.show_distances(pair_asu_table=s1_asu_table, out=s)
  print(file=s)
  s = s.getvalue().replace("-0.0000", " 0.0000")
  if (hashlib.md5(s.encode("ascii")).hexdigest() != "f5c02727352d26dc36762de0834199fd"):
    sys.stderr.write(s)
    print("New hexdigest:", hashlib.md5(s.encode("ascii")).hexdigest())
    raise AssertionError("Unexpected show_distances() output.")

def exercise_ext_symmetry():
  symmetry = crystal.ext.symmetry(
    unit_cell=uctbx.unit_cell([1,2,3,80,90,100]),
    space_group=sgtbx.space_group("P 2"))
  assert symmetry.unit_cell().is_similar_to(
    uctbx.unit_cell([1,2,3,80,90,100]))
  assert symmetry.space_group().order_z() == 2
  symmetry_cb = symmetry.change_basis(
    change_of_basis_op=sgtbx.change_of_basis_op("z,x,y"))
  assert symmetry_cb.unit_cell().is_similar_to(
    uctbx.unit_cell([3,1,2,100,80,90]))
  assert str(sgtbx.space_group_info(
    group=symmetry_cb.space_group())) == "P 2 1 1"

def exercise_incremental_pairs_and_site_cluster_analysis():
  sps = crystal.symmetry(
    unit_cell=(10, 10, 10, 90, 90, 90),
    space_group_symbol="P 1 1 2").special_position_settings()
  sites_frac = flex.vec3_double([
    (0.01, 0.49, 0.0),
    (0.1, 0.6, 0.0)])
  #
  incremental_pairs = sps.incremental_pairs(distance_cutoff=2)
  assert approx_equal(incremental_pairs.min_distance_sym_equiv, 0.5)
  assert incremental_pairs.assert_min_distance_sym_equiv
  assert approx_equal(incremental_pairs.asu_mappings().buffer_thickness(), 2)
  assert incremental_pairs.asu_mappings().mappings().size() == 0
  assert incremental_pairs.pair_asu_table().table().size() == 0
  #
  incremental_pairs.process_site_frac(original_site=sites_frac[0])
  assert incremental_pairs.asu_mappings().mappings().size() == 1
  assert str(incremental_pairs.asu_mappings().special_op(i_seq=0)) == "0,1/2,z"
  assert incremental_pairs.pair_asu_table().table().size() == 1
  out = StringIO()
  incremental_pairs.pair_asu_table().show(f=out)
  assert not show_diff(out.getvalue(), """\
i_seq: 0
""")
  #
  incremental_pairs.process_site_frac(
    original_site=sites_frac[1],
    site_symmetry_ops=sps.site_symmetry(site=sites_frac[1]))
  am = incremental_pairs.asu_mappings()
  assert am.mappings().size() == 2
  assert am.site_symmetry_table().indices().size() == 2
  assert str(incremental_pairs.asu_mappings().special_op(i_seq=1)) == "x,y,z"
  assert incremental_pairs.pair_asu_table().table().size() == 2
  out = StringIO()
  incremental_pairs.pair_asu_table().show(f=out)
  expected_out = """\
i_seq: 0
  j_seq: 1
    j_syms: [0, 2]
i_seq: 1
  j_seq: 0
    j_syms: [0]
"""
  assert not show_diff(out.getvalue(), expected_out)
  assert list(incremental_pairs.cubicle_size_counts().items()) == [(0,239), (1,6)]
  site_symmetry_table = incremental_pairs.asu_mappings().site_symmetry_table()
  sites_cart = sps.unit_cell().orthogonalize(sites_frac=sites_frac)
  for i_pass in range(4):
    ipv = sps.incremental_pairs(distance_cutoff=2)
    if   (i_pass == 0):
      ipv.process_sites_frac(original_sites=sites_frac)
    elif (i_pass == 1):
      ipv.process_sites_frac(
        original_sites=sites_frac,
        site_symmetry_table=site_symmetry_table)
    elif (i_pass == 2):
      ipv.process_sites_cart(original_sites=sites_cart)
    elif (i_pass == 3):
      ipv.process_sites_cart(
        original_sites=sites_cart,
        site_symmetry_table=site_symmetry_table)
    out = StringIO()
    ipv.pair_asu_table().show(f=out)
    assert not show_diff(out.getvalue(), expected_out)
  #
  site_cluster_analysis = sps.site_cluster_analysis(min_distance=2)
  assert approx_equal(site_cluster_analysis.min_cross_distance, 2)
  assert approx_equal(site_cluster_analysis.min_self_distance, 2)
  assert not site_cluster_analysis.general_positions_only
  assert approx_equal(site_cluster_analysis.min_distance_sym_equiv, 0.5)
  assert site_cluster_analysis.assert_min_distance_sym_equiv
  assert site_cluster_analysis.estimated_reduction_factor == 4
  assert approx_equal(
    site_cluster_analysis.asu_mappings().buffer_thickness(), 2)
  assert site_cluster_analysis.asu_mappings().mappings().size() == 0
  assert site_cluster_analysis.process_site_frac(original_site=sites_frac[0])
  assert site_cluster_analysis.asu_mappings().mappings().size() == 1
  assert not site_cluster_analysis.process_site_frac(
    original_site=sites_frac[1],
    site_symmetry_ops=sps.site_symmetry(site=sites_frac[1]))
  am = site_cluster_analysis.asu_mappings()
  assert am.mappings().size() == 1
  assert am.site_symmetry_table().indices().size() == 1
  #
  site = (0.7,0.3,0.1)
  for i_trial in range(10):
    assert site_cluster_analysis.process_site_frac(original_site=site)
    assert am.mappings().size() == 2
    assert am.site_symmetry_table().indices().size() == 2
    site_cluster_analysis.discard_last()
    assert am.mappings().size() == 1
    assert am.site_symmetry_table().indices().size() == 1
  try: site_cluster_analysis.discard_last()
  except RuntimeError as e:
    assert str(e) == """\
site_cluster_analysis::discard_last() failure. Potential problems are:
  - discard_last() called twice
  - insert_fixed_site_frac() called previously
  - the previous process_*() call returned false"""
  else: raise Exception_expected
  site_cluster_analysis.insert_fixed_site_frac(original_site=site)
  assert not site_cluster_analysis.process_site_frac(original_site=site)
  site = (0.3,0.1,0.3)
  assert site_cluster_analysis.process_site_frac(original_site=site)
  site_cluster_analysis.discard_last()
  site_cluster_analysis.insert_fixed_site_frac(
    original_site=site,
    site_symmetry_ops=sps.site_symmetry(site=site))
  assert not site_cluster_analysis.process_site_frac(original_site=site)
  #
  for method,sites_array in [("process_sites_frac", sites_frac),
                             ("process_sites_cart", sites_cart)]:
    for max_clusters in [0,1]:
      site_cluster_analysis = sps.site_cluster_analysis(min_distance=2)
      selection = getattr(site_cluster_analysis, method)(
        original_sites=sites_array,
        site_symmetry_table=site_symmetry_table,
        max_clusters=max_clusters)
      assert list(selection) == [0]
    site_cluster_analysis = sps.site_cluster_analysis(min_distance=1)
    selection = getattr(site_cluster_analysis, method)(
      original_sites=sites_array,
      site_symmetry_table=site_symmetry_table)
    assert list(selection) == [0,1]
    site_cluster_analysis = sps.site_cluster_analysis(
      min_distance=1,
      general_positions_only=True)
    assert site_cluster_analysis.general_positions_only
    selection = getattr(site_cluster_analysis, method)(
      original_sites=sites_array,
      site_symmetry_table=site_symmetry_table)
    assert list(selection) == [1]
    site_cluster_analysis = sps.site_cluster_analysis(min_distance=1)
    selection = getattr(site_cluster_analysis, method)(
      original_sites=sites_array,
      site_symmetry_table=site_symmetry_table,
      max_clusters=1)
    assert list(selection) == [0]
    #
    for max_clusters in [0,1]:
      site_cluster_analysis = sps.site_cluster_analysis(min_distance=2)
      selection = getattr(site_cluster_analysis, method)(
        original_sites=sites_array,
        max_clusters=max_clusters)
      assert list(selection) == [0]
    site_cluster_analysis = sps.site_cluster_analysis(min_distance=1)
    selection = getattr(site_cluster_analysis, method)(
      original_sites=sites_array)
    assert list(selection) == [0,1]
    site_cluster_analysis = sps.site_cluster_analysis(min_distance=1)
    selection = getattr(site_cluster_analysis, method)(
      original_sites=sites_array,
      max_clusters=1)
    assert list(selection) == [0]

def exercise_cubicles_max_memory():
  sites_cart = flex.vec3_double([(1,2,3), (2,3,4)])
  def fast_pair_generator_init():
    asu_mappings = crystal.direct_space_asu.non_crystallographic_asu_mappings(
      sites_cart=sites_cart)
    crystal.neighbors_fast_pair_generator(
      asu_mappings=asu_mappings,
      distance_cutoff=3,
      minimal=False,
      min_cubicle_edge=0)
  fast_pair_generator_init() # just to make sure it works
  mm = crystal.cubicles_max_memory_allocation_get()
  if (1 and mm < 333333*666666*999999):
    sites_cart.append((1.e6,2.e6,3.e6))
    try: fast_pair_generator_init()
    except RuntimeError as e:
      assert str(e).startswith("Excessive number of cubicles:")
    else: raise Exception_expected
    sites_cart.pop_back()
  if (1):
    crystal.cubicles_max_memory_allocation_set(number_of_bytes=3*6*9)
    sites_cart.append((10,20,30))
    try: fast_pair_generator_init()
    except RuntimeError as e:
      assert not show_diff(str(e), """\
Estimated memory allocation for cubicles exceeds max_number_of_bytes:
  This may be due to unreasonable parameters:
    cubicle_edge=3
    space_span=(9,18,27)
    n_cubicles=(3,6,9)
    max_number_of_bytes=162""")
    else: raise Exception_expected
    crystal.cubicles_max_memory_allocation_set(number_of_bytes=mm)
    fast_pair_generator_init()
    sites_cart.pop_back()

def exercise_asu_mappings():
  structure = trial_structure_2()
  original = structure.asu_mappings( buffer_thickness=2)
  restored = pickle.loads( pickle.dumps( original ) )

  assert original.n_sites_in_asu_and_buffer() == restored.n_sites_in_asu_and_buffer()

  for ( o, r ) in zip( original.mapped_sites_min(), restored.mapped_sites_min() ):
    assert approx_equal( o, r, 1E-7 )

  for ( o, r ) in zip( original.mapped_sites_max(), restored.mapped_sites_max() ):
    assert approx_equal( o, r, 1E-7 )

  mappings_o = original.mappings()
  mappings_r = restored.mappings()
  assert len( mappings_o ) == len( mappings_r )

  for ( sitemap_o, sitemap_r ) in zip( mappings_o, mappings_r ):
    assert len( sitemap_o ) == len( sitemap_r )

    for ( site_o, site_r ) in zip( sitemap_o, sitemap_r ):
      assert site_o.i_sym_op() == site_r.i_sym_op()
      assert site_o.unit_shifts() == site_r.unit_shifts()

      for( c_o, c_r ) in zip( site_o.mapped_site(), site_r.mapped_site() ):
        assert approx_equal( c_o, c_r, 1E-7 )

def exercise_pair_sym_table_pickling():
  # Test pickling of pair_asu_table in cctbx_project\cctbx\crystal\pair_tables_bpl.cpp
  from cctbx import geometry_restraints
  bond = geometry_restraints.bond(sites=[(1,2,3),(2,3,4)], distance_ideal=2, weight=10)
  quartz_structure = xray.structure(
    crystal_symmetry=crystal.symmetry(
    unit_cell=(5.01,5.01,5.47,90,90,120),
    space_group_symbol="P6222"),
    scatterers=flex.xray_scatterer([
      xray.scatterer(label="Si", site=(1/2.,1/2.,1/3.), u=0.2), xray.scatterer(
      label="O",
      site=(0.197,-0.197,0.83333),
      u=0)
    ])
  )
  asu_mappings = quartz_structure.asu_mappings(buffer_thickness=2)
  pair_asu_table = crystal.pair_asu_table(asu_mappings=asu_mappings)
  pair_asu_table.add_all_pairs(distance_cutoff=1.7)
  pair_sym_table = pair_asu_table.extract_pair_sym_table()
  new_asu_mappings = quartz_structure.asu_mappings(buffer_thickness=5)
  new_pair_asu_table = crystal.pair_asu_table(asu_mappings=new_asu_mappings)
  new_pair_asu_table.add_pair_sym_table(sym_table=pair_sym_table)
  ptable = pickle.loads(pickle.dumps(new_pair_asu_table))
  assert new_pair_asu_table.as_nested_lists() == ptable.as_nested_lists()


def run():
  exercise_symmetry()
  exercise_direct_space_asu()
  exercise_pair_tables()
  exercise_pair_sym_table_tidy()
  exercise_fix_for_missed_interaction_inside_asu()
  exercise_all_bonds_from_inside_asu()
  exercise_coordination_sequences_simple()
  exercise_coordination_sequences_shell_asu_tables()
  exercise_ext_symmetry()
  exercise_incremental_pairs_and_site_cluster_analysis()
  exercise_cubicles_max_memory()
  exercise_asu_mappings()
  exercise_pair_sym_table_pickling()
  print("OK")

if (__name__ == "__main__"):
  run()


 *******************************************************************************


 *******************************************************************************
cctbx/crystal/tst_super_cell.py
from __future__ import absolute_import, division, print_function
import iotbx.pdb
from cctbx.crystal import super_cell
import mmtbx.model
import libtbx.load_env
from libtbx.utils import null_out
import math
from scitbx.array_family import flex

pdb_str_1yjp = """
CRYST1   21.937    4.866   23.477  90.00 107.08  90.00 P 1 21 1      2
ATOM      1  N   GLY A   1      -9.009   4.612   6.102  1.00 16.77           N
ATOM      2  CA  GLY A   1      -9.052   4.207   4.651  1.00 16.57           C
ATOM      3  C   GLY A   1      -8.015   3.140   4.419  1.00 16.16           C
ATOM      4  O   GLY A   1      -7.523   2.521   5.381  1.00 16.78           O
ATOM      5  N   ASN A   2      -7.656   2.923   3.155  1.00 15.02           N
ATOM      6  CA  ASN A   2      -6.522   2.038   2.831  1.00 14.10           C
ATOM      7  C   ASN A   2      -5.241   2.537   3.427  1.00 13.13           C
ATOM      8  O   ASN A   2      -4.978   3.742   3.426  1.00 11.91           O
ATOM      9  CB  ASN A   2      -6.346   1.881   1.341  1.00 15.38           C
ATOM     10  CG  ASN A   2      -7.584   1.342   0.692  1.00 14.08           C
ATOM     11  OD1 ASN A   2      -8.025   0.227   1.016  1.00 17.46           O
ATOM     12  ND2 ASN A   2      -8.204   2.155  -0.169  1.00 11.72           N
ATOM     13  N   ASN A   3      -4.438   1.590   3.905  1.00 12.26           N
ATOM     14  CA  ASN A   3      -3.193   1.904   4.589  1.00 11.74           C
ATOM     15  C   ASN A   3      -1.955   1.332   3.895  1.00 11.10           C
ATOM     16  O   ASN A   3      -1.872   0.119   3.648  1.00 10.42           O
ATOM     17  CB  ASN A   3      -3.259   1.378   6.042  1.00 12.15           C
ATOM     18  CG  ASN A   3      -2.006   1.739   6.861  1.00 12.82           C
ATOM     19  OD1 ASN A   3      -1.702   2.925   7.072  1.00 15.05           O
ATOM     20  ND2 ASN A   3      -1.271   0.715   7.306  1.00 13.48           N
ATOM     21  N   GLN A   4      -1.005   2.228   3.598  1.00 10.29           N
ATOM     22  CA  GLN A   4       0.384   1.888   3.199  1.00 10.53           C
ATOM     23  C   GLN A   4       1.435   2.606   4.088  1.00 10.24           C
ATOM     24  O   GLN A   4       1.547   3.843   4.115  1.00  8.86           O
ATOM     25  CB  GLN A   4       0.656   2.148   1.711  1.00  9.80           C
ATOM     26  CG  GLN A   4       1.944   1.458   1.213  1.00 10.25           C
ATOM     27  CD  GLN A   4       2.504   2.044  -0.089  1.00 12.43           C
ATOM     28  OE1 GLN A   4       2.744   3.268  -0.190  1.00 14.62           O
ATOM     29  NE2 GLN A   4       2.750   1.161  -1.091  1.00  9.05           N
ATOM     30  N   GLN A   5       2.154   1.821   4.871  1.00 10.38           N
ATOM     31  CA  GLN A   5       3.270   2.361   5.640  1.00 11.39           C
ATOM     32  C   GLN A   5       4.594   1.768   5.172  1.00 11.52           C
ATOM     33  O   GLN A   5       4.768   0.546   5.054  1.00 12.05           O
ATOM     34  CB  GLN A   5       3.056   2.183   7.147  1.00 11.96           C
ATOM     35  CG  GLN A   5       1.829   2.950   7.647  1.00 10.81           C
ATOM     36  CD  GLN A   5       1.344   2.414   8.954  1.00 13.10           C
ATOM     37  OE1 GLN A   5       0.774   1.325   9.002  1.00 10.65           O
ATOM     38  NE2 GLN A   5       1.549   3.187  10.039  1.00 12.30           N
ATOM     39  N   ASN A   6       5.514   2.664   4.856  1.00 11.99           N
ATOM     40  CA  ASN A   6       6.831   2.310   4.318  1.00 12.30           C
ATOM     41  C   ASN A   6       7.854   2.761   5.324  1.00 13.40           C
ATOM     42  O   ASN A   6       8.219   3.943   5.374  1.00 13.92           O
ATOM     43  CB  ASN A   6       7.065   3.016   2.993  1.00 12.13           C
ATOM     44  CG  ASN A   6       5.961   2.735   2.003  1.00 12.77           C
ATOM     45  OD1 ASN A   6       5.798   1.604   1.551  1.00 14.27           O
ATOM     46  ND2 ASN A   6       5.195   3.747   1.679  1.00 10.07           N
ATOM     47  N   TYR A   7       8.292   1.817   6.147  1.00 14.70           N
ATOM     48  CA  TYR A   7       9.159   2.144   7.299  1.00 15.18           C
ATOM     49  C   TYR A   7      10.603   2.331   6.885  1.00 15.91           C
ATOM     50  O   TYR A   7      11.041   1.811   5.855  1.00 15.76           O
ATOM     51  CB  TYR A   7       9.061   1.065   8.369  1.00 15.35           C
ATOM     52  CG  TYR A   7       7.665   0.929   8.902  1.00 14.45           C
ATOM     53  CD1 TYR A   7       6.771   0.021   8.327  1.00 15.68           C
ATOM     54  CD2 TYR A   7       7.210   1.756   9.920  1.00 14.80           C
ATOM     55  CE1 TYR A   7       5.480  -0.094   8.796  1.00 13.46           C
ATOM     56  CE2 TYR A   7       5.904   1.649  10.416  1.00 14.33           C
ATOM     57  CZ  TYR A   7       5.047   0.729   9.831  1.00 15.09           C
ATOM     58  OH  TYR A   7       3.766   0.589  10.291  1.00 14.39           O
ATOM     59  OXT TYR A   7      11.358   2.999   7.612  1.00 17.49           O
TER      60      TYR A   7
HETATM   61  O   HOH A   8      -6.471   5.227   7.124  1.00 22.62           O
HETATM   62  O   HOH A   9      10.431   1.858   3.216  1.00 19.71           O
HETATM   63  O   HOH A  10     -11.286   1.756  -1.468  1.00 17.08           O
HETATM   64  O   HOH A  11      11.808   4.179   9.970  1.00 23.99           O
HETATM   65  O   HOH A  12      13.605   1.327   9.198  1.00 26.17           O
HETATM   66  O   HOH A  13      -2.749   3.429  10.024  1.00 39.15           O
HETATM   67  O   HOH A  14      -1.500   0.682  10.967  1.00 43.49           O
"""

pdb_str_3q2c = """
CRYST1   83.308   27.817   48.257  90.00 111.65  90.00 C 1 2 1
SCALE1      0.012004  0.000000  0.004765        0.00000
SCALE2      0.000000  0.035949  0.000000        0.00000
SCALE3      0.000000  0.000000  0.022295        0.00000
ATOM      1  N   PRO A   2      15.485  -5.578  -4.008  1.00106.63           N
ATOM      2  CA  PRO A   2      14.818  -5.574  -2.702  1.00103.27           C
ATOM      3  C   PRO A   2      15.479  -6.558  -1.746  1.00104.30           C
ATOM      4  O   PRO A   2      14.839  -7.506  -1.291  1.00110.99           O
ATOM      5  CB  PRO A   2      13.388  -6.036  -3.029  1.00106.01           C
ATOM      6  CG  PRO A   2      13.419  -6.509  -4.459  1.00103.99           C
ATOM      7  CD  PRO A   2      14.530  -5.765  -5.112  1.00108.07           C
ATOM      8  N   LEU A   3      16.755  -6.326  -1.457  1.00 76.14           N
ATOM      9  CA  LEU A   3      17.526  -7.192  -0.572  1.00 77.68           C
ATOM     10  C   LEU A   3      16.850  -7.375   0.789  1.00 80.25           C
ATOM     11  O   LEU A   3      16.086  -6.511   1.231  1.00 77.25           O
ATOM     12  CB  LEU A   3      18.939  -6.631  -0.382  1.00 78.55           C
ATOM     13  CG  LEU A   3      19.865  -6.560  -1.602  1.00 79.95           C
ATOM     14  CD1 LEU A   3      19.359  -5.549  -2.630  1.00 79.02           C
ATOM     15  CD2 LEU A   3      21.295  -6.233  -1.179  1.00 66.74           C
ATOM     16  N   PRO A   4      17.129  -8.506   1.458  1.00 98.25           N
ATOM     17  CA  PRO A   4      16.578  -8.793   2.789  1.00 98.84           C
ATOM     18  C   PRO A   4      16.895  -7.681   3.787  1.00 94.48           C
ATOM     19  O   PRO A   4      17.976  -7.091   3.713  1.00 94.28           O
ATOM     20  CB  PRO A   4      17.305 -10.081   3.194  1.00 98.59           C
ATOM     21  CG  PRO A   4      17.680 -10.724   1.906  1.00 92.99           C
ATOM     22  CD  PRO A   4      17.997  -9.593   0.973  1.00 92.73           C
ATOM     23  N   LYS A   5      15.969  -7.399   4.701  1.00 59.25           N
ATOM     24  CA  LYS A   5      16.211  -6.387   5.721  1.00 53.50           C
ATOM     25  C   LYS A   5      17.208  -6.898   6.753  1.00 51.59           C
ATOM     26  O   LYS A   5      17.223  -8.087   7.077  1.00 54.23           O
ATOM     27  CB  LYS A   5      14.905  -5.960   6.395  1.00 53.07           C
ATOM     28  CG  LYS A   5      14.225  -7.045   7.204  1.00 49.36           C
ATOM     29  CD  LYS A   5      12.845  -6.589   7.657  1.00 42.75           C
ATOM     30  CE  LYS A   5      12.167  -7.653   8.502  1.00 50.57           C
ATOM     31  NZ  LYS A   5      10.848  -7.202   9.030  1.00 51.11           N
ATOM     32  N   PRO A   6      18.049  -5.995   7.272  1.00 45.91           N
ATOM     33  CA  PRO A   6      19.118  -6.361   8.204  1.00 42.91           C
ATOM     34  C   PRO A   6      18.560  -6.628   9.589  1.00 40.34           C
ATOM     35  O   PRO A   6      17.359  -6.505   9.810  1.00 42.02           O
ATOM     36  CB  PRO A   6      19.991  -5.101   8.256  1.00 42.35           C
ATOM     37  CG  PRO A   6      19.398  -4.133   7.253  1.00 44.97           C
ATOM     38  CD  PRO A   6      17.988  -4.543   7.050  1.00 43.21           C
ATOM     39  N   THR A   7      19.438  -6.976  10.518  1.00 42.39           N
ATOM     40  CA  THR A   7      19.038  -7.191  11.895  1.00 37.75           C
ATOM     41  C   THR A   7      19.695  -6.130  12.757  1.00 33.81           C
ATOM     42  O   THR A   7      20.915  -6.056  12.828  1.00 41.62           O
ATOM     43  CB  THR A   7      19.462  -8.584  12.384  1.00 44.13           C
ATOM     44  OG1 THR A   7      19.111  -9.563  11.397  1.00 51.90           O
ATOM     45  CG2 THR A   7      18.779  -8.927  13.703  1.00 35.96           C
ATOM     46  N   LEU A   8      18.878  -5.303  13.398  1.00 26.28           N
ATOM     47  CA  LEU A   8      19.362  -4.217  14.243  1.00 27.06           C
ATOM     48  C   LEU A   8      19.041  -4.509  15.706  1.00 29.60           C
ATOM     49  O   LEU A   8      17.904  -4.829  16.053  1.00 29.31           O
ATOM     50  CB  LEU A   8      18.728  -2.890  13.799  1.00 25.14           C
ATOM     51  CG  LEU A   8      18.876  -1.599  14.614  1.00 20.65           C
ATOM     52  CD1 LEU A   8      20.287  -1.050  14.606  1.00 18.33           C
ATOM     53  CD2 LEU A   8      17.917  -0.559  14.063  1.00 26.48           C
ATOM     54  N   TRP A   9      20.045  -4.414  16.569  1.00 29.25           N
ATOM     55  CA  TRP A   9      19.808  -4.632  17.988  1.00 29.09           C
ATOM     56  C   TRP A   9      20.677  -3.722  18.855  1.00 31.04           C
ATOM     57  O   TRP A   9      21.518  -2.979  18.346  1.00 29.39           O
ATOM     58  CB  TRP A   9      20.005  -6.108  18.351  1.00 30.29           C
ATOM     59  CG  TRP A   9      21.430  -6.564  18.315  1.00 33.54           C
ATOM     60  CD1 TRP A   9      22.255  -6.753  19.384  1.00 30.39           C
ATOM     61  CD2 TRP A   9      22.202  -6.888  17.149  1.00 33.03           C
ATOM     62  NE1 TRP A   9      23.494  -7.172  18.959  1.00 34.81           N
ATOM     63  CE2 TRP A   9      23.486  -7.265  17.591  1.00 33.71           C
ATOM     64  CE3 TRP A   9      21.933  -6.894  15.778  1.00 32.04           C
ATOM     65  CZ2 TRP A   9      24.496  -7.644  16.711  1.00 35.53           C
ATOM     66  CZ3 TRP A   9      22.937  -7.272  14.907  1.00 35.61           C
ATOM     67  CH2 TRP A   9      24.204  -7.639  15.376  1.00 36.14           C
ATOM     68  N   ALA A  10      20.454  -3.773  20.164  1.00 32.99           N
ATOM     69  CA  ALA A  10      21.194  -2.937  21.093  1.00 31.63           C
ATOM     70  C   ALA A  10      21.880  -3.776  22.160  1.00 38.15           C
ATOM     71  O   ALA A  10      21.331  -4.776  22.631  1.00 39.89           O
ATOM     72  CB  ALA A  10      20.271  -1.933  21.737  1.00 36.46           C
ATOM     73  N   GLU A  11      23.084  -3.359  22.535  1.00 38.56           N
ATOM     74  CA  GLU A  11      23.835  -4.008  23.599  1.00 38.57           C
ATOM     75  C   GLU A  11      24.169  -2.984  24.673  1.00 40.20           C
ATOM     76  O   GLU A  11      24.746  -1.942  24.367  1.00 43.74           O
ATOM     77  CB  GLU A  11      25.121  -4.609  23.038  1.00 38.07           C
ATOM     78  CG  GLU A  11      24.885  -5.629  21.944  1.00 45.66           C
ATOM     79  CD  GLU A  11      26.164  -6.267  21.457  1.00 48.79           C
ATOM     80  OE1 GLU A  11      27.231  -5.619  21.550  1.00 48.99           O
ATOM     81  OE2 GLU A  11      26.102  -7.417  20.975  1.00 48.99           O
ATOM     82  N   PRO A  12      23.824  -3.275  25.940  1.00 34.15           N
ATOM     83  CA  PRO A  12      23.218  -4.519  26.436  1.00 37.83           C
ATOM     84  C   PRO A  12      21.748  -4.673  26.053  1.00 38.95           C
ATOM     85  O   PRO A  12      21.243  -5.797  26.031  1.00 42.06           O
ATOM     86  CB  PRO A  12      23.329  -4.383  27.962  1.00 38.94           C
ATOM     87  CG  PRO A  12      24.268  -3.232  28.198  1.00 40.87           C
ATOM     88  CD  PRO A  12      24.091  -2.329  27.034  1.00 33.86           C
ATOM     89  N   GLY A  13      21.071  -3.564  25.769  1.00 28.63           N
ATOM     90  CA  GLY A  13      19.665  -3.608  25.415  1.00 24.42           C
ATOM     91  C   GLY A  13      19.141  -2.262  24.969  1.00 24.18           C
ATOM     92  O   GLY A  13      19.877  -1.279  24.960  1.00 25.85           O
ATOM     93  N   SER A  14      17.864  -2.219  24.605  1.00 33.49           N
ATOM     94  CA  SER A  14      17.251  -1.006  24.075  1.00 35.19           C
ATOM     95  C   SER A  14      16.749  -0.065  25.167  1.00 35.94           C
ATOM     96  O   SER A  14      16.445   1.098  24.900  1.00 38.04           O
ATOM     97  CB  SER A  14      16.104  -1.361  23.135  1.00 38.06           C
ATOM     98  OG  SER A  14      15.141  -2.144  23.809  1.00 45.33           O
ATOM     99  N   VAL A  15      16.652  -0.564  26.393  1.00 27.57           N
ATOM    100  CA  VAL A  15      16.361   0.306  27.520  1.00 26.82           C
ATOM    101  C   VAL A  15      17.615   0.424  28.356  1.00 33.22           C
ATOM    102  O   VAL A  15      17.977  -0.515  29.060  1.00 41.09           O
ATOM    103  CB  VAL A  15      15.238  -0.241  28.417  1.00 30.18           C
ATOM    104  CG1 VAL A  15      14.847   0.804  29.448  1.00 29.17           C
ATOM    105  CG2 VAL A  15      14.025  -0.635  27.592  1.00 30.77           C
ATOM    106  N   ILE A  16      18.292   1.564  28.269  1.00 32.55           N
ATOM    107  CA  ILE A  16      19.470   1.784  29.094  1.00 36.32           C
ATOM    108  C   ILE A  16      19.362   3.074  29.909  1.00 36.86           C
ATOM    109  O   ILE A  16      18.959   4.119  29.404  1.00 34.13           O
ATOM    110  CB  ILE A  16      20.786   1.782  28.276  1.00 35.91           C
ATOM    111  CG1 ILE A  16      21.013   3.138  27.620  1.00 36.74           C
ATOM    112  CG2 ILE A  16      20.807   0.644  27.254  1.00 27.28           C
ATOM    113  CD1 ILE A  16      22.472   3.471  27.470  1.00 42.86           C
ATOM    114  N   THR A  17      19.726   2.988  31.181  1.00 40.41           N
ATOM    115  CA  THR A  17      19.623   4.128  32.075  1.00 38.88           C
ATOM    116  C   THR A  17      20.483   5.283  31.582  1.00 36.89           C
ATOM    117  O   THR A  17      21.406   5.085  30.797  1.00 40.95           O
ATOM    118  CB  THR A  17      20.004   3.739  33.514  1.00 36.95           C
ATOM    119  OG1 THR A  17      20.447   4.901  34.223  1.00 39.63           O
ATOM    120  CG2 THR A  17      21.108   2.700  33.508  1.00 38.83           C
ATOM    121  N   GLN A  18      20.172   6.492  32.031  1.00 40.38           N
ATOM    122  CA  GLN A  18      20.881   7.665  31.544  1.00 39.76           C
ATOM    123  C   GLN A  18      22.315   7.697  32.043  1.00 43.39           C
ATOM    124  O   GLN A  18      22.597   7.309  33.173  1.00 46.10           O
ATOM    125  CB  GLN A  18      20.168   8.955  31.947  1.00 41.08           C
ATOM    126  CG  GLN A  18      20.554  10.126  31.058  1.00 45.15           C
ATOM    127  CD  GLN A  18      20.475  11.466  31.755  1.00 47.34           C
ATOM    128  OE1 GLN A  18      20.137  11.552  32.940  1.00 47.59           O
ATOM    129  NE2 GLN A  18      20.791  12.530  31.018  1.00 42.22           N
ATOM    130  N   GLY A  19      23.219   8.170  31.192  1.00 46.53           N
ATOM    131  CA  GLY A  19      24.621   8.268  31.547  1.00 39.90           C
ATOM    132  C   GLY A  19      25.368   6.992  31.227  1.00 40.68           C
ATOM    133  O   GLY A  19      26.584   7.003  31.057  1.00 46.08           O
ATOM    134  N   SER A  20      24.635   5.888  31.149  1.00 39.27           N
ATOM    135  CA  SER A  20      25.230   4.601  30.819  1.00 41.46           C
ATOM    136  C   SER A  20      25.448   4.469  29.316  1.00 40.29           C
ATOM    137  O   SER A  20      24.853   5.209  28.531  1.00 39.63           O
ATOM    138  CB  SER A  20      24.352   3.460  31.330  1.00 41.45           C
ATOM    139  OG  SER A  20      24.267   3.490  32.744  1.00 49.64           O
ATOM    140  N   PRO A  21      26.318   3.532  28.913  1.00 39.41           N
ATOM    141  CA  PRO A  21      26.610   3.306  27.497  1.00 37.40           C
ATOM    142  C   PRO A  21      25.640   2.329  26.843  1.00 37.33           C
ATOM    143  O   PRO A  21      24.987   1.522  27.514  1.00 39.50           O
ATOM    144  CB  PRO A  21      28.011   2.673  27.523  1.00 38.85           C
ATOM    145  CG  PRO A  21      28.473   2.737  28.960  1.00 38.49           C
ATOM    146  CD  PRO A  21      27.233   2.771  29.775  1.00 41.28           C
ATOM    147  N   VAL A  22      25.552   2.415  25.523  1.00 33.52           N
ATOM    148  CA  VAL A  22      24.875   1.405  24.730  1.00 32.93           C
ATOM    149  C   VAL A  22      25.457   1.444  23.329  1.00 29.93           C
ATOM    150  O   VAL A  22      25.881   2.492  22.852  1.00 34.04           O
ATOM    151  CB  VAL A  22      23.347   1.613  24.682  1.00 31.65           C
ATOM    152  CG1 VAL A  22      23.009   2.948  24.054  1.00 30.11           C
ATOM    153  CG2 VAL A  22      22.687   0.481  23.913  1.00 28.87           C
ATOM    154  N   THR A  23      25.499   0.293  22.679  1.00 23.69           N
ATOM    155  CA  THR A  23      25.987   0.227  21.321  1.00 26.16           C
ATOM    156  C   THR A  23      24.894  -0.331  20.423  1.00 28.36           C
ATOM    157  O   THR A  23      24.357  -1.406  20.676  1.00 31.25           O
ATOM    158  CB  THR A  23      27.244  -0.653  21.228  1.00 25.03           C
ATOM    159  OG1 THR A  23      28.208  -0.209  22.189  1.00 29.25           O
ATOM    160  CG2 THR A  23      27.848  -0.572  19.844  1.00 27.87           C
ATOM    161  N   LEU A  24      24.546   0.411  19.382  1.00 38.96           N
ATOM    162  CA  LEU A  24      23.614  -0.106  18.393  1.00 40.23           C
ATOM    163  C   LEU A  24      24.379  -0.955  17.386  1.00 39.39           C
ATOM    164  O   LEU A  24      25.516  -0.644  17.033  1.00 39.33           O
ATOM    165  CB  LEU A  24      22.869   1.029  17.697  1.00 38.06           C
ATOM    166  CG  LEU A  24      22.079   1.925  18.645  1.00 37.89           C
ATOM    167  CD1 LEU A  24      21.022   2.692  17.878  1.00 36.61           C
ATOM    168  CD2 LEU A  24      21.434   1.092  19.735  1.00 37.89           C
ATOM    169  N   ARG A  25      23.748  -2.031  16.934  1.00 35.06           N
ATOM    170  CA  ARG A  25      24.406  -2.997  16.069  1.00 35.31           C
ATOM    171  C   ARG A  25      23.493  -3.374  14.914  1.00 34.80           C
ATOM    172  O   ARG A  25      22.292  -3.542  15.104  1.00 35.61           O
ATOM    173  CB  ARG A  25      24.762  -4.247  16.873  1.00 38.69           C
ATOM    174  CG  ARG A  25      25.688  -3.991  18.048  1.00 36.05           C
ATOM    175  CD  ARG A  25      27.081  -3.703  17.551  1.00 37.65           C
ATOM    176  NE  ARG A  25      27.493  -4.711  16.582  1.00 39.66           N
ATOM    177  CZ  ARG A  25      28.189  -5.800  16.889  1.00 45.65           C
ATOM    178  NH1 ARG A  25      28.568  -6.020  18.143  1.00 42.47           N
ATOM    179  NH2 ARG A  25      28.513  -6.666  15.939  1.00 46.19           N
ATOM    180  N   CYS A  26      24.066  -3.507  13.721  1.00 34.47           N
ATOM    181  CA  CYS A  26      23.309  -3.906  12.539  1.00 32.24           C
ATOM    182  C   CYS A  26      24.093  -4.927  11.723  1.00 39.91           C
ATOM    183  O   CYS A  26      25.233  -4.675  11.340  1.00 45.76           O
ATOM    184  CB  CYS A  26      22.987  -2.683  11.680  1.00 32.03           C
ATOM    185  SG  CYS A  26      22.107  -3.044  10.140  1.00 37.65           S
ATOM    186  N   GLN A  27      23.489  -6.085  11.472  1.00 54.55           N
ATOM    187  CA  GLN A  27      24.137  -7.126  10.679  1.00 57.28           C
ATOM    188  C   GLN A  27      23.205  -7.630   9.584  1.00 61.63           C
ATOM    189  O   GLN A  27      22.076  -8.036   9.863  1.00 69.61           O
ATOM    190  CB  GLN A  27      24.575  -8.285  11.574  1.00 62.26           C
ATOM    191  CG  GLN A  27      25.415  -9.338  10.863  1.00 67.17           C
ATOM    192  CD  GLN A  27      25.928 -10.416  11.801  1.00 72.17           C
ATOM    193  OE1 GLN A  27      26.616 -10.128  12.785  1.00 68.28           O
ATOM    194  NE2 GLN A  27      25.601 -11.669  11.496  1.00 77.49           N
ATOM    195  N   GLY A  28      23.683  -7.619   8.342  1.00 46.31           N
ATOM    196  CA  GLY A  28      22.832  -7.927   7.205  1.00 48.44           C
ATOM    197  C   GLY A  28      23.205  -9.140   6.373  1.00 57.20           C
ATOM    198  O   GLY A  28      22.460 -10.118   6.322  1.00 58.11           O
ATOM    199  N   SER A  29      24.352  -9.079   5.704  1.00 70.60           N
ATOM    200  CA  SER A  29      24.746 -10.139   4.781  1.00 71.88           C
ATOM    201  C   SER A  29      26.257 -10.354   4.710  1.00 85.24           C
ATOM    202  O   SER A  29      26.774 -11.339   5.238  1.00 88.84           O
ATOM    203  CB  SER A  29      24.200  -9.851   3.384  1.00 68.45           C
ATOM    204  OG  SER A  29      24.923 -10.575   2.408  1.00 70.32           O
ATOM    205  N   LEU A  30      26.958  -9.436   4.047  1.00 82.21           N
ATOM    206  CA  LEU A  30      28.400  -9.557   3.850  1.00 88.27           C
ATOM    207  C   LEU A  30      29.134  -9.384   5.173  1.00105.96           C
ATOM    208  O   LEU A  30      28.504  -9.234   6.218  1.00111.16           O
ATOM    209  CB  LEU A  30      28.890  -8.526   2.834  1.00 83.42           C
ATOM    210  CG  LEU A  30      30.281  -8.731   2.241  1.00 85.42           C
ATOM    211  CD1 LEU A  30      30.333 -10.038   1.465  1.00 83.93           C
ATOM    212  CD2 LEU A  30      30.647  -7.552   1.359  1.00 80.69           C
ATOM    213  N   GLU A  31      30.464  -9.398   5.126  1.00174.21           N
ATOM    214  CA  GLU A  31      31.276  -9.294   6.338  1.00180.00           C
ATOM    215  C   GLU A  31      31.178  -7.910   6.976  1.00176.97           C
ATOM    216  O   GLU A  31      30.961  -7.792   8.181  1.00178.75           O
ATOM    217  CB  GLU A  31      32.742  -9.637   6.041  1.00190.24           C
ATOM    218  CG  GLU A  31      33.613  -9.846   7.283  1.00198.59           C
ATOM    219  CD  GLU A  31      35.056 -10.194   6.941  1.00215.78           C
ATOM    220  OE1 GLU A  31      35.631  -9.561   6.029  1.00215.57           O
ATOM    221  OE2 GLU A  31      35.619 -11.097   7.594  1.00220.02           O
ATOM    222  N   THR A  32      31.330  -6.867   6.163  1.00184.84           N
ATOM    223  CA  THR A  32      31.342  -5.495   6.668  1.00177.96           C
ATOM    224  C   THR A  32      31.050  -4.462   5.582  1.00166.46           C
ATOM    225  O   THR A  32      30.617  -4.804   4.479  1.00159.76           O
ATOM    226  CB  THR A  32      32.725  -5.129   7.290  1.00174.76           C
ATOM    227  OG1 THR A  32      33.778  -5.505   6.390  1.00188.26           O
ATOM    228  CG2 THR A  32      32.938  -5.814   8.633  1.00163.04           C
ATOM    229  N   GLN A  33      31.240  -3.195   5.945  1.00150.13           N
ATOM    230  CA  GLN A  33      31.560  -2.112   5.001  1.00151.57           C
ATOM    231  C   GLN A  33      30.466  -1.213   4.408  1.00148.98           C
ATOM    232  O   GLN A  33      30.793  -0.177   3.823  1.00156.27           O
ATOM    233  CB  GLN A  33      32.458  -2.613   3.862  1.00154.21           C
ATOM    234  CG  GLN A  33      31.745  -2.829   2.519  1.00162.95           C
ATOM    235  CD  GLN A  33      32.724  -2.844   1.365  1.00169.47           C
ATOM    236  OE1 GLN A  33      33.850  -2.371   1.504  1.00171.83           O
ATOM    237  NE2 GLN A  33      32.306  -3.385   0.224  1.00167.22           N
ATOM    238  N   GLU A  34      29.197  -1.583   4.523  1.00 71.44           N
ATOM    239  CA  GLU A  34      28.141  -0.743   3.960  1.00 63.74           C
ATOM    240  C   GLU A  34      26.872  -0.741   4.798  1.00 52.69           C
ATOM    241  O   GLU A  34      25.837  -1.226   4.363  1.00 54.38           O
ATOM    242  CB  GLU A  34      27.831  -1.156   2.517  1.00 72.37           C
ATOM    243  CG  GLU A  34      28.723  -0.498   1.472  1.00 81.89           C
ATOM    244  CD  GLU A  34      28.332   0.943   1.183  1.00 85.22           C
ATOM    245  OE1 GLU A  34      28.419   1.788   2.102  1.00 78.83           O
ATOM    246  OE2 GLU A  34      27.939   1.227   0.030  1.00 82.48           O
ATOM    247  N   TYR A  35      26.960  -0.182   6.000  1.00 47.54           N
ATOM    248  CA  TYR A  35      25.799  -0.043   6.871  1.00 42.81           C
ATOM    249  C   TYR A  35      25.445   1.426   7.037  1.00 42.17           C
ATOM    250  O   TYR A  35      26.319   2.287   6.965  1.00 46.78           O
ATOM    251  CB  TYR A  35      26.067  -0.674   8.245  1.00 43.61           C
ATOM    252  CG  TYR A  35      26.275  -2.168   8.198  1.00 46.41           C
ATOM    253  CD1 TYR A  35      27.552  -2.716   8.230  1.00 47.05           C
ATOM    254  CD2 TYR A  35      25.192  -3.033   8.110  1.00 44.63           C
ATOM    255  CE1 TYR A  35      27.742  -4.089   8.177  1.00 52.72           C
ATOM    256  CE2 TYR A  35      25.371  -4.401   8.056  1.00 48.98           C
ATOM    257  CZ  TYR A  35      26.645  -4.925   8.088  1.00 53.69           C
ATOM    258  OH  TYR A  35      26.816  -6.291   8.033  1.00 63.69           O
ATOM    259  N   HIS A  36      24.164   1.717   7.248  1.00 46.76           N
ATOM    260  CA  HIS A  36      23.748   3.077   7.582  1.00 44.97           C
ATOM    261  C   HIS A  36      22.618   3.086   8.599  1.00 37.19           C
ATOM    262  O   HIS A  36      21.584   2.464   8.389  1.00 35.70           O
ATOM    263  CB  HIS A  36      23.332   3.868   6.339  1.00 49.45           C
ATOM    264  CG  HIS A  36      22.770   5.219   6.656  1.00 49.72           C
ATOM    265  ND1 HIS A  36      21.476   5.578   6.351  1.00 43.69           N
ATOM    266  CD2 HIS A  36      23.319   6.287   7.284  1.00 53.80           C
ATOM    267  CE1 HIS A  36      21.256   6.817   6.759  1.00 42.94           C
ATOM    268  NE2 HIS A  36      22.357   7.266   7.333  1.00 47.39           N
ATOM    269  N   LEU A  37      22.834   3.799   9.699  1.00 32.51           N
ATOM    270  CA  LEU A  37      21.846   3.928  10.757  1.00 30.38           C
ATOM    271  C   LEU A  37      21.170   5.287  10.662  1.00 33.63           C
ATOM    272  O   LEU A  37      21.786   6.254  10.216  1.00 37.58           O
ATOM    273  CB  LEU A  37      22.518   3.790  12.123  1.00 25.75           C
ATOM    274  CG  LEU A  37      21.576   3.843  13.328  1.00 30.26           C
ATOM    275  CD1 LEU A  37      20.706   2.600  13.381  1.00 28.08           C
ATOM    276  CD2 LEU A  37      22.358   3.998  14.621  1.00 31.13           C
ATOM    277  N   TYR A  38      19.905   5.360  11.072  1.00 30.74           N
ATOM    278  CA  TYR A  38      19.185   6.635  11.102  1.00 30.03           C
ATOM    279  C   TYR A  38      18.015   6.636  12.092  1.00 27.68           C
ATOM    280  O   TYR A  38      17.517   5.581  12.475  1.00 27.73           O
ATOM    281  CB  TYR A  38      18.711   7.043   9.696  1.00 29.92           C
ATOM    282  CG  TYR A  38      17.588   6.206   9.127  1.00 31.24           C
ATOM    283  CD1 TYR A  38      16.265   6.616   9.246  1.00 34.90           C
ATOM    284  CD2 TYR A  38      17.848   5.009   8.464  1.00 31.67           C
ATOM    285  CE1 TYR A  38      15.232   5.859   8.737  1.00 29.06           C
ATOM    286  CE2 TYR A  38      16.823   4.244   7.947  1.00 32.77           C
ATOM    287  CZ  TYR A  38      15.512   4.674   8.088  1.00 35.23           C
ATOM    288  OH  TYR A  38      14.477   3.919   7.571  1.00 34.61           O
ATOM    289  N   ARG A  39      17.608   7.828  12.517  1.00 28.24           N
ATOM    290  CA  ARG A  39      16.421   8.006  13.347  1.00 28.17           C
ATOM    291  C   ARG A  39      15.389   8.729  12.496  1.00 31.77           C
ATOM    292  O   ARG A  39      15.735   9.663  11.771  1.00 32.15           O
ATOM    293  CB  ARG A  39      16.763   8.832  14.580  1.00 27.17           C
ATOM    294  CG  ARG A  39      15.653   8.928  15.591  1.00 29.00           C
ATOM    295  CD  ARG A  39      16.145   9.583  16.871  1.00 30.23           C
ATOM    296  NE  ARG A  39      16.606  10.951  16.654  1.00 32.06           N
ATOM    297  CZ  ARG A  39      16.931  11.791  17.633  1.00 32.54           C
ATOM    298  NH1 ARG A  39      16.845  11.397  18.897  1.00 29.97           N
ATOM    299  NH2 ARG A  39      17.337  13.023  17.350  1.00 32.83           N
ATOM    300  N   GLU A  40      14.124   8.324  12.598  1.00 46.55           N
ATOM    301  CA  GLU A  40      13.155   8.620  11.536  1.00 55.06           C
ATOM    302  C   GLU A  40      12.334   9.922  11.544  1.00 59.80           C
ATOM    303  O   GLU A  40      12.095  10.498  10.473  1.00 66.32           O
ATOM    304  CB  GLU A  40      12.236   7.424  11.298  1.00 59.85           C
ATOM    305  CG  GLU A  40      11.478   6.961  12.514  1.00 52.88           C
ATOM    306  CD  GLU A  40      10.633   5.749  12.203  1.00 58.68           C
ATOM    307  OE1 GLU A  40       9.395   5.849  12.328  1.00 57.20           O
ATOM    308  OE2 GLU A  40      11.205   4.710  11.797  1.00 58.00           O
ATOM    309  N   LYS A  41      11.893  10.381  12.710  1.00 35.99           N
ATOM    310  CA  LYS A  41      11.136  11.626  12.766  1.00 34.46           C
ATOM    311  C   LYS A  41      12.076  12.779  13.053  1.00 33.38           C
ATOM    312  O   LYS A  41      11.731  13.946  12.867  1.00 31.03           O
ATOM    313  CB  LYS A  41      10.054  11.563  13.841  1.00 38.44           C
ATOM    314  CG  LYS A  41       9.027  10.461  13.647  1.00 36.85           C
ATOM    315  CD  LYS A  41       8.202  10.692  12.405  1.00 43.50           C
ATOM    316  CE  LYS A  41       7.190   9.575  12.186  1.00 50.50           C
ATOM    317  NZ  LYS A  41       6.189   9.525  13.290  1.00 59.24           N
ATOM    318  N   LYS A  42      13.282  12.438  13.481  1.00 31.87           N
ATOM    319  CA  LYS A  42      14.250  13.444  13.846  1.00 33.15           C
ATOM    320  C   LYS A  42      15.648  12.878  13.675  1.00 37.79           C
ATOM    321  O   LYS A  42      15.975  11.844  14.255  1.00 39.53           O
ATOM    322  CB  LYS A  42      14.007  13.869  15.292  1.00 38.19           C
ATOM    323  CG  LYS A  42      14.814  15.078  15.736  1.00 40.43           C
ATOM    324  CD  LYS A  42      14.424  15.513  17.137  1.00 35.80           C
ATOM    325  CE  LYS A  42      15.327  16.626  17.627  1.00 47.09           C
ATOM    326  NZ  LYS A  42      15.045  16.996  19.037  1.00 50.00           N
ATOM    327  N   THR A  43      16.470  13.552  12.873  1.00 53.64           N
ATOM    328  CA  THR A  43      17.815  13.060  12.574  1.00 52.24           C
ATOM    329  C   THR A  43      18.658  12.961  13.835  1.00 45.99           C
ATOM    330  O   THR A  43      18.635  13.857  14.678  1.00 48.01           O
ATOM    331  CB  THR A  43      18.561  13.952  11.552  1.00 56.40           C
ATOM    332  OG1 THR A  43      18.721  15.270  12.088  1.00 65.94           O
ATOM    333  CG2 THR A  43      17.807  14.028  10.230  1.00 59.69           C
ATOM    334  N   ALA A  44      19.395  11.863  13.958  1.00 37.33           N
ATOM    335  CA  ALA A  44      20.262  11.640  15.106  1.00 34.09           C
ATOM    336  C   ALA A  44      21.690  12.036  14.767  1.00 38.95           C
ATOM    337  O   ALA A  44      22.459  11.235  14.237  1.00 41.38           O
ATOM    338  CB  ALA A  44      20.204  10.188  15.541  1.00 33.35           C
ATOM    339  N   LEU A  45      22.042  13.275  15.084  1.00 45.66           N
ATOM    340  CA  LEU A  45      23.336  13.829  14.706  1.00 43.44           C
ATOM    341  C   LEU A  45      24.516  12.986  15.176  1.00 43.29           C
ATOM    342  O   LEU A  45      25.550  12.938  14.512  1.00 46.95           O
ATOM    343  CB  LEU A  45      23.460  15.255  15.238  1.00 46.67           C
ATOM    344  CG  LEU A  45      22.368  16.200  14.736  1.00 44.45           C
ATOM    345  CD1 LEU A  45      21.996  17.225  15.800  1.00 49.95           C
ATOM    346  CD2 LEU A  45      22.794  16.871  13.440  1.00 42.68           C
ATOM    347  N   TRP A  46      24.364  12.318  16.314  1.00 36.12           N
ATOM    348  CA  TRP A  46      25.473  11.575  16.904  1.00 37.97           C
ATOM    349  C   TRP A  46      25.958  10.446  15.999  1.00 37.72           C
ATOM    350  O   TRP A  46      27.079   9.960  16.143  1.00 41.25           O
ATOM    351  CB  TRP A  46      25.087  11.025  18.276  1.00 39.53           C
ATOM    352  CG  TRP A  46      24.063   9.946  18.210  1.00 38.49           C
ATOM    353  CD1 TRP A  46      22.709  10.086  18.346  1.00 34.41           C
ATOM    354  CD2 TRP A  46      24.304   8.554  17.983  1.00 36.17           C
ATOM    355  NE1 TRP A  46      22.095   8.864  18.217  1.00 32.14           N
ATOM    356  CE2 TRP A  46      23.052   7.906  17.996  1.00 33.24           C
ATOM    357  CE3 TRP A  46      25.458   7.789  17.773  1.00 36.92           C
ATOM    358  CZ2 TRP A  46      22.922   6.532  17.806  1.00 31.14           C
ATOM    359  CZ3 TRP A  46      25.326   6.422  17.585  1.00 34.54           C
ATOM    360  CH2 TRP A  46      24.066   5.809  17.602  1.00 31.53           C
ATOM    361  N   ILE A  47      25.114  10.034  15.064  1.00 30.79           N
ATOM    362  CA  ILE A  47      25.471   8.967  14.139  1.00 31.33           C
ATOM    363  C   ILE A  47      26.510   9.442  13.137  1.00 34.42           C
ATOM    364  O   ILE A  47      27.372   8.676  12.711  1.00 36.09           O
ATOM    365  CB  ILE A  47      24.238   8.463  13.359  1.00 32.97           C
ATOM    366  CG1 ILE A  47      23.143   8.017  14.334  1.00 29.18           C
ATOM    367  CG2 ILE A  47      24.632   7.350  12.396  1.00 28.55           C
ATOM    368  CD1 ILE A  47      21.946   7.380  13.682  1.00 25.77           C
ATOM    369  N   THR A  48      26.422  10.715  12.764  1.00 46.35           N
ATOM    370  CA  THR A  48      27.297  11.285  11.741  1.00 46.26           C
ATOM    371  C   THR A  48      28.706  11.486  12.265  1.00 42.49           C
ATOM    372  O   THR A  48      29.551  12.048  11.578  1.00 40.98           O
ATOM    373  CB  THR A  48      26.783  12.655  11.239  1.00 48.23           C
ATOM    374  OG1 THR A  48      27.011  13.654  12.243  1.00 53.86           O
ATOM    375  CG2 THR A  48      25.300  12.592  10.911  1.00 46.67           C
ATOM    376  N   ARG A  49      28.955  11.037  13.488  1.00 42.52           N
ATOM    377  CA  ARG A  49      30.264  11.220  14.094  1.00 42.89           C
ATOM    378  C   ARG A  49      30.961   9.893  14.385  1.00 43.11           C
ATOM    379  O   ARG A  49      32.084   9.872  14.880  1.00 46.37           O
ATOM    380  CB  ARG A  49      30.147  12.062  15.363  1.00 45.88           C
ATOM    381  CG  ARG A  49      29.637  13.466  15.109  1.00 45.23           C
ATOM    382  CD  ARG A  49      29.731  14.314  16.362  1.00 48.49           C
ATOM    383  NE  ARG A  49      28.425  14.550  16.977  1.00 57.01           N
ATOM    384  CZ  ARG A  49      27.981  13.944  18.078  1.00 52.45           C
ATOM    385  NH1 ARG A  49      28.730  13.047  18.709  1.00 45.07           N
ATOM    386  NH2 ARG A  49      26.778  14.239  18.552  1.00 54.17           N
ATOM    387  N   ILE A  50      30.296   8.787  14.071  1.00 38.47           N
ATOM    388  CA  ILE A  50      30.878   7.465  14.275  1.00 38.24           C
ATOM    389  C   ILE A  50      31.943   7.194  13.205  1.00 37.30           C
ATOM    390  O   ILE A  50      31.660   7.262  12.015  1.00 42.79           O
ATOM    391  CB  ILE A  50      29.784   6.366  14.248  1.00 35.72           C
ATOM    392  CG1 ILE A  50      28.698   6.655  15.292  1.00 33.68           C
ATOM    393  CG2 ILE A  50      30.385   4.996  14.495  1.00 34.98           C
ATOM    394  CD1 ILE A  50      29.169   6.534  16.724  1.00 30.85           C
ATOM    395  N   PRO A  51      33.181   6.904  13.626  1.00 37.83           N
ATOM    396  CA  PRO A  51      34.250   6.663  12.650  1.00 36.78           C
ATOM    397  C   PRO A  51      33.880   5.551  11.674  1.00 42.27           C
ATOM    398  O   PRO A  51      33.206   4.600  12.063  1.00 45.37           O
ATOM    399  CB  PRO A  51      35.430   6.229  13.524  1.00 39.06           C
ATOM    400  CG  PRO A  51      35.152   6.833  14.855  1.00 42.33           C
ATOM    401  CD  PRO A  51      33.662   6.810  15.014  1.00 37.88           C
ATOM    402  N   GLN A  52      34.323   5.672  10.426  1.00 36.89           N
ATOM    403  CA  GLN A  52      34.013   4.691   9.393  1.00 34.37           C
ATOM    404  C   GLN A  52      34.410   3.277   9.778  1.00 37.84           C
ATOM    405  O   GLN A  52      33.791   2.317   9.335  1.00 41.24           O
ATOM    406  CB  GLN A  52      34.701   5.065   8.083  1.00 42.19           C
ATOM    407  CG  GLN A  52      34.300   6.424   7.537  1.00 52.07           C
ATOM    408  CD  GLN A  52      32.837   6.485   7.103  1.00 60.88           C
ATOM    409  OE1 GLN A  52      31.965   5.859   7.709  1.00 52.64           O
ATOM    410  NE2 GLN A  52      32.565   7.250   6.046  1.00 64.89           N
ATOM    411  N   GLU A  53      35.452   3.145  10.589  1.00 44.81           N
ATOM    412  CA  GLU A  53      35.929   1.824  10.986  1.00 45.37           C
ATOM    413  C   GLU A  53      34.854   1.051  11.733  1.00 45.68           C
ATOM    414  O   GLU A  53      34.726  -0.161  11.568  1.00 47.32           O
ATOM    415  CB  GLU A  53      37.190   1.927  11.845  1.00 52.17           C
ATOM    416  CG  GLU A  53      38.425   2.389  11.090  1.00 57.62           C
ATOM    417  CD  GLU A  53      38.263   3.779  10.507  1.00 66.13           C
ATOM    418  OE1 GLU A  53      37.653   4.644  11.178  1.00 57.96           O
ATOM    419  OE2 GLU A  53      38.747   4.009   9.377  1.00 78.94           O
ATOM    420  N   LEU A  54      34.087   1.760  12.555  1.00 49.40           N
ATOM    421  CA  LEU A  54      32.988   1.160  13.303  1.00 44.43           C
ATOM    422  C   LEU A  54      31.784   0.926  12.398  1.00 45.66           C
ATOM    423  O   LEU A  54      31.272  -0.191  12.301  1.00 47.83           O
ATOM    424  CB  LEU A  54      32.588   2.060  14.474  1.00 40.98           C
ATOM    425  CG  LEU A  54      33.603   2.214  15.609  1.00 43.71           C
ATOM    426  CD1 LEU A  54      33.192   3.325  16.561  1.00 40.12           C
ATOM    427  CD2 LEU A  54      33.772   0.907  16.360  1.00 43.14           C
ATOM    428  N   VAL A  55      31.337   1.991  11.740  1.00 38.70           N
ATOM    429  CA  VAL A  55      30.210   1.919  10.816  1.00 36.21           C
ATOM    430  C   VAL A  55      30.362   0.760   9.835  1.00 38.60           C
ATOM    431  O   VAL A  55      29.386   0.093   9.497  1.00 41.48           O
ATOM    432  CB  VAL A  55      30.038   3.241  10.038  1.00 33.73           C
ATOM    433  CG1 VAL A  55      29.057   3.065   8.900  1.00 35.92           C
ATOM    434  CG2 VAL A  55      29.589   4.356  10.972  1.00 27.41           C
ATOM    435  N   LYS A  56      31.587   0.514   9.385  1.00 33.26           N
ATOM    436  CA  LYS A  56      31.847  -0.594   8.477  1.00 37.06           C
ATOM    437  C   LYS A  56      31.595  -1.929   9.155  1.00 39.64           C
ATOM    438  O   LYS A  56      31.192  -2.892   8.514  1.00 50.92           O
ATOM    439  CB  LYS A  56      33.273  -0.535   7.935  1.00 42.52           C
ATOM    440  CG  LYS A  56      33.485   0.539   6.885  1.00 47.36           C
ATOM    441  CD  LYS A  56      34.906   0.510   6.335  1.00 58.42           C
ATOM    442  CE  LYS A  56      35.113   1.583   5.274  1.00 59.33           C
ATOM    443  NZ  LYS A  56      36.527   1.647   4.813  1.00 62.90           N
ATOM    444  N   LYS A  57      31.827  -1.988  10.457  1.00 39.30           N
ATOM    445  CA  LYS A  57      31.552  -3.206  11.202  1.00 37.89           C
ATOM    446  C   LYS A  57      30.108  -3.219  11.673  1.00 36.28           C
ATOM    447  O   LYS A  57      29.672  -4.149  12.353  1.00 36.11           O
ATOM    448  CB  LYS A  57      32.495  -3.331  12.395  1.00 46.21           C
ATOM    449  CG  LYS A  57      33.929  -3.670  12.023  1.00 46.85           C
ATOM    450  CD  LYS A  57      34.798  -3.803  13.264  1.00 45.98           C
ATOM    451  CE  LYS A  57      34.816  -2.506  14.052  1.00 42.31           C
ATOM    452  NZ  LYS A  57      35.557  -2.639  15.330  1.00 40.82           N
ATOM    453  N   GLY A  58      29.366  -2.183  11.300  1.00 38.30           N
ATOM    454  CA  GLY A  58      27.974  -2.069  11.689  1.00 35.74           C
ATOM    455  C   GLY A  58      27.846  -1.817  13.175  1.00 34.31           C
ATOM    456  O   GLY A  58      26.990  -2.401  13.845  1.00 32.35           O
ATOM    457  N   GLN A  59      28.707  -0.944  13.689  1.00 35.11           N
ATOM    458  CA  GLN A  59      28.717  -0.624  15.110  1.00 31.55           C
ATOM    459  C   GLN A  59      28.510   0.862  15.329  1.00 30.96           C
ATOM    460  O   GLN A  59      29.191   1.685  14.722  1.00 31.62           O
ATOM    461  CB  GLN A  59      30.034  -1.053  15.754  1.00 37.44           C
ATOM    462  CG  GLN A  59      30.383  -2.512  15.533  1.00 39.53           C
ATOM    463  CD  GLN A  59      31.508  -2.983  16.422  1.00 33.29           C
ATOM    464  OE1 GLN A  59      31.785  -2.388  17.464  1.00 30.64           O
ATOM    465  NE2 GLN A  59      32.160  -4.065  16.020  1.00 38.92           N
ATOM    466  N   PHE A  60      27.570   1.194  16.208  1.00 30.95           N
ATOM    467  CA  PHE A  60      27.257   2.580  16.516  1.00 30.25           C
ATOM    468  C   PHE A  60      27.218   2.793  18.032  1.00 31.14           C
ATOM    469  O   PHE A  60      26.168   2.706  18.659  1.00 32.64           O
ATOM    470  CB  PHE A  60      25.931   2.974  15.861  1.00 31.42           C
ATOM    471  CG  PHE A  60      25.890   2.711  14.381  1.00 28.09           C
ATOM    472  CD1 PHE A  60      25.619   1.442  13.899  1.00 30.42           C
ATOM    473  CD2 PHE A  60      26.130   3.727  13.473  1.00 26.96           C
ATOM    474  CE1 PHE A  60      25.583   1.191  12.537  1.00 31.23           C
ATOM    475  CE2 PHE A  60      26.093   3.484  12.110  1.00 29.69           C
ATOM    476  CZ  PHE A  60      25.820   2.213  11.642  1.00 31.83           C
ATOM    477  N   PRO A  61      28.382   3.071  18.626  1.00 31.22           N
ATOM    478  CA  PRO A  61      28.515   3.173  20.078  1.00 31.16           C
ATOM    479  C   PRO A  61      27.941   4.467  20.632  1.00 35.39           C
ATOM    480  O   PRO A  61      27.935   5.493  19.954  1.00 40.01           O
ATOM    481  CB  PRO A  61      30.035   3.172  20.290  1.00 32.43           C
ATOM    482  CG  PRO A  61      30.628   2.753  18.982  1.00 29.56           C
ATOM    483  CD  PRO A  61      29.676   3.234  17.951  1.00 33.05           C
ATOM    484  N   ILE A  62      27.465   4.403  21.869  1.00 33.26           N
ATOM    485  CA  ILE A  62      27.128   5.589  22.639  1.00 34.29           C
ATOM    486  C   ILE A  62      27.734   5.397  24.020  1.00 35.54           C
ATOM    487  O   ILE A  62      27.289   4.552  24.791  1.00 38.36           O
ATOM    488  CB  ILE A  62      25.609   5.787  22.756  1.00 31.39           C
ATOM    489  CG1 ILE A  62      24.993   6.003  21.369  1.00 30.92           C
ATOM    490  CG2 ILE A  62      25.302   6.956  23.668  1.00 27.51           C
ATOM    491  CD1 ILE A  62      23.517   5.678  21.292  1.00 25.84           C
ATOM    492  N   LEU A  63      28.772   6.166  24.319  1.00 33.54           N
ATOM    493  CA  LEU A  63      29.485   6.006  25.575  1.00 33.87           C
ATOM    494  C   LEU A  63      28.654   6.483  26.755  1.00 34.09           C
ATOM    495  O   LEU A  63      28.600   5.824  27.791  1.00 38.47           O
ATOM    496  CB  LEU A  63      30.825   6.741  25.524  1.00 37.15           C
ATOM    497  CG  LEU A  63      32.008   5.927  24.994  1.00 35.23           C
ATOM    498  CD1 LEU A  63      31.614   5.123  23.763  1.00 34.73           C
ATOM    499  CD2 LEU A  63      33.198   6.826  24.697  1.00 34.34           C
ATOM    500  N   SER A  64      28.001   7.628  26.589  1.00 39.81           N
ATOM    501  CA  SER A  64      27.174   8.209  27.644  1.00 39.25           C
ATOM    502  C   SER A  64      25.839   8.693  27.085  1.00 35.86           C
ATOM    503  O   SER A  64      25.730   9.813  26.593  1.00 36.22           O
ATOM    504  CB  SER A  64      27.915   9.362  28.324  1.00 37.53           C
ATOM    505  OG  SER A  64      27.094  10.012  29.276  1.00 40.76           O
ATOM    506  N   ILE A  65      24.824   7.843  27.171  1.00 32.82           N
ATOM    507  CA  ILE A  65      23.532   8.148  26.576  1.00 33.62           C
ATOM    508  C   ILE A  65      22.802   9.294  27.285  1.00 37.58           C
ATOM    509  O   ILE A  65      22.736   9.339  28.514  1.00 37.58           O
ATOM    510  CB  ILE A  65      22.628   6.902  26.524  1.00 32.48           C
ATOM    511  CG1 ILE A  65      21.705   6.976  25.306  1.00 32.39           C
ATOM    512  CG2 ILE A  65      21.842   6.753  27.817  1.00 33.77           C
ATOM    513  CD1 ILE A  65      20.775   5.790  25.153  1.00 32.46           C
ATOM    514  N   THR A  66      22.264  10.219  26.492  1.00 37.85           N
ATOM    515  CA  THR A  66      21.488  11.340  27.004  1.00 34.24           C
ATOM    516  C   THR A  66      20.030  11.171  26.603  1.00 34.58           C
ATOM    517  O   THR A  66      19.682  10.226  25.897  1.00 33.82           O
ATOM    518  CB  THR A  66      22.002  12.678  26.446  1.00 36.56           C
ATOM    519  OG1 THR A  66      21.568  12.839  25.090  1.00 37.90           O
ATOM    520  CG2 THR A  66      23.517  12.726  26.490  1.00 37.76           C
ATOM    521  N   TRP A  67      19.181  12.094  27.043  1.00 33.92           N
ATOM    522  CA  TRP A  67      17.758  12.036  26.720  1.00 31.32           C
ATOM    523  C   TRP A  67      17.515  12.146  25.227  1.00 32.50           C
ATOM    524  O   TRP A  67      16.652  11.462  24.673  1.00 35.37           O
ATOM    525  CB  TRP A  67      17.003  13.150  27.436  1.00 32.36           C
ATOM    526  CG  TRP A  67      17.104  13.050  28.902  1.00 37.45           C
ATOM    527  CD1 TRP A  67      17.749  13.911  29.740  1.00 38.71           C
ATOM    528  CD2 TRP A  67      16.564  12.008  29.726  1.00 37.42           C
ATOM    529  NE1 TRP A  67      17.630  13.477  31.041  1.00 40.01           N
ATOM    530  CE2 TRP A  67      16.910  12.309  31.058  1.00 37.43           C
ATOM    531  CE3 TRP A  67      15.818  10.853  29.466  1.00 32.99           C
ATOM    532  CZ2 TRP A  67      16.536  11.496  32.129  1.00 35.16           C
ATOM    533  CZ3 TRP A  67      15.447  10.048  30.529  1.00 35.19           C
ATOM    534  CH2 TRP A  67      15.808  10.373  31.844  1.00 35.98           C
ATOM    535  N   GLU A  68      18.280  13.015  24.581  1.00 41.58           N
ATOM    536  CA  GLU A  68      18.090  13.300  23.168  1.00 42.76           C
ATOM    537  C   GLU A  68      18.445  12.107  22.276  1.00 42.57           C
ATOM    538  O   GLU A  68      18.168  12.122  21.081  1.00 47.68           O
ATOM    539  CB  GLU A  68      18.894  14.540  22.769  1.00 52.13           C
ATOM    540  CG  GLU A  68      18.187  15.460  21.765  1.00 68.21           C
ATOM    541  CD  GLU A  68      18.612  15.217  20.319  1.00 63.16           C
ATOM    542  OE1 GLU A  68      17.862  15.619  19.400  1.00 56.99           O
ATOM    543  OE2 GLU A  68      19.695  14.628  20.103  1.00 64.18           O
ATOM    544  N   HIS A  69      19.045  11.073  22.857  1.00 39.18           N
ATOM    545  CA  HIS A  69      19.390   9.869  22.101  1.00 36.73           C
ATOM    546  C   HIS A  69      18.189   8.958  21.846  1.00 38.57           C
ATOM    547  O   HIS A  69      18.174   8.184  20.886  1.00 37.24           O
ATOM    548  CB  HIS A  69      20.469   9.072  22.825  1.00 33.74           C
ATOM    549  CG  HIS A  69      21.834   9.664  22.709  1.00 34.44           C
ATOM    550  ND1 HIS A  69      22.764   9.216  21.795  1.00 37.89           N
ATOM    551  CD2 HIS A  69      22.432  10.668  23.391  1.00 37.54           C
ATOM    552  CE1 HIS A  69      23.875   9.917  21.920  1.00 35.09           C
ATOM    553  NE2 HIS A  69      23.699  10.806  22.882  1.00 35.96           N
ATOM    554  N   ALA A  70      17.193   9.040  22.720  1.00 39.91           N
ATOM    555  CA  ALA A  70      16.013   8.195  22.606  1.00 37.36           C
ATOM    556  C   ALA A  70      15.318   8.405  21.266  1.00 38.20           C
ATOM    557  O   ALA A  70      15.293   9.519  20.737  1.00 37.75           O
ATOM    558  CB  ALA A  70      15.059   8.476  23.748  1.00 35.90           C
ATOM    559  N   GLY A  71      14.761   7.331  20.717  1.00 36.88           N
ATOM    560  CA  GLY A  71      14.025   7.426  19.470  1.00 37.40           C
ATOM    561  C   GLY A  71      13.919   6.109  18.729  1.00 38.44           C
ATOM    562  O   GLY A  71      14.335   5.065  19.228  1.00 41.46           O
ATOM    563  N   ARG A  72      13.368   6.166  17.522  1.00 38.86           N
ATOM    564  CA  ARG A  72      13.171   4.976  16.707  1.00 37.80           C
ATOM    565  C   ARG A  72      14.251   4.899  15.640  1.00 33.74           C
ATOM    566  O   ARG A  72      14.361   5.786  14.794  1.00 34.13           O
ATOM    567  CB  ARG A  72      11.789   5.016  16.057  1.00 40.54           C
ATOM    568  CG  ARG A  72      11.116   3.664  15.920  1.00 40.52           C
ATOM    569  CD  ARG A  72       9.650   3.760  16.317  1.00 47.93           C
ATOM    570  NE  ARG A  72       8.817   2.794  15.605  1.00 54.34           N
ATOM    571  CZ  ARG A  72       8.129   3.074  14.501  1.00 56.83           C
ATOM    572  NH1 ARG A  72       8.170   4.294  13.982  1.00 57.72           N
ATOM    573  NH2 ARG A  72       7.398   2.138  13.914  1.00 53.13           N
ATOM    574  N   TYR A  73      15.048   3.837  15.687  1.00 28.12           N
ATOM    575  CA  TYR A  73      16.180   3.688  14.781  1.00 25.32           C
ATOM    576  C   TYR A  73      15.971   2.549  13.793  1.00 25.96           C
ATOM    577  O   TYR A  73      15.430   1.507  14.140  1.00 27.92           O
ATOM    578  CB  TYR A  73      17.473   3.475  15.578  1.00 25.12           C
ATOM    579  CG  TYR A  73      17.921   4.706  16.334  1.00 23.94           C
ATOM    580  CD1 TYR A  73      17.315   5.074  17.525  1.00 25.91           C
ATOM    581  CD2 TYR A  73      18.944   5.506  15.848  1.00 29.58           C
ATOM    582  CE1 TYR A  73      17.719   6.205  18.212  1.00 27.20           C
ATOM    583  CE2 TYR A  73      19.357   6.636  16.530  1.00 26.21           C
ATOM    584  CZ  TYR A  73      18.742   6.980  17.707  1.00 24.65           C
ATOM    585  OH  TYR A  73      19.151   8.105  18.380  1.00 26.73           O
ATOM    586  N   CYS A  74      16.392   2.766  12.554  1.00 31.80           N
ATOM    587  CA  CYS A  74      16.362   1.735  11.527  1.00 31.81           C
ATOM    588  C   CYS A  74      17.694   1.765  10.813  1.00 32.31           C
ATOM    589  O   CYS A  74      18.436   2.740  10.905  1.00 34.13           O
ATOM    590  CB  CYS A  74      15.252   2.004  10.513  1.00 33.70           C
ATOM    591  SG  CYS A  74      13.566   1.876  11.149  1.00 40.44           S
ATOM    592  N   CYS A  75      18.007   0.704  10.091  1.00 34.86           N
ATOM    593  CA  CYS A  75      19.234   0.712   9.325  1.00 37.28           C
ATOM    594  C   CYS A  75      19.127  -0.155   8.082  1.00 40.95           C
ATOM    595  O   CYS A  75      18.339  -1.100   8.031  1.00 39.36           O
ATOM    596  CB  CYS A  75      20.407   0.272  10.194  1.00 40.04           C
ATOM    597  SG  CYS A  75      20.860  -1.454  10.006  1.00 47.01           S
ATOM    598  N   ILE A  76      19.917   0.197   7.074  1.00 42.13           N
ATOM    599  CA  ILE A  76      20.000  -0.583   5.853  1.00 43.71           C
ATOM    600  C   ILE A  76      21.459  -0.718   5.460  1.00 47.65           C
ATOM    601  O   ILE A  76      22.280   0.143   5.767  1.00 49.05           O
ATOM    602  CB  ILE A  76      19.253   0.087   4.696  1.00 42.71           C
ATOM    603  CG1 ILE A  76      20.175   1.055   3.966  1.00 44.03           C
ATOM    604  CG2 ILE A  76      18.015   0.810   5.201  1.00 46.65           C
ATOM    605  CD1 ILE A  76      19.441   2.028   3.090  1.00 52.25           C
ATOM    606  N   TYR A  77      21.780  -1.814   4.789  1.00 46.86           N
ATOM    607  CA  TYR A  77      23.110  -2.003   4.252  1.00 47.29           C
ATOM    608  C   TYR A  77      23.008  -2.075   2.737  1.00 53.70           C
ATOM    609  O   TYR A  77      21.939  -1.844   2.176  1.00 55.80           O
ATOM    610  CB  TYR A  77      23.728  -3.283   4.812  1.00 52.16           C
ATOM    611  CG  TYR A  77      22.912  -4.517   4.537  1.00 49.48           C
ATOM    612  CD1 TYR A  77      23.185  -5.321   3.443  1.00 55.78           C
ATOM    613  CD2 TYR A  77      21.865  -4.876   5.366  1.00 54.64           C
ATOM    614  CE1 TYR A  77      22.438  -6.454   3.182  1.00 62.58           C
ATOM    615  CE2 TYR A  77      21.109  -6.007   5.114  1.00 62.30           C
ATOM    616  CZ  TYR A  77      21.400  -6.793   4.020  1.00 64.82           C
ATOM    617  OH  TYR A  77      20.649  -7.922   3.763  1.00 68.03           O
ATOM    618  N   GLY A  78      24.114  -2.386   2.071  1.00 49.20           N
ATOM    619  CA  GLY A  78      24.083  -2.570   0.633  1.00 50.24           C
ATOM    620  C   GLY A  78      25.186  -1.857  -0.121  1.00 58.52           C
ATOM    621  O   GLY A  78      25.528  -0.711   0.181  1.00 60.15           O
ATOM    622  N   SER A  79      25.742  -2.554  -1.109  1.00 73.48           N
ATOM    623  CA  SER A  79      26.799  -2.027  -1.967  1.00 73.56           C
ATOM    624  C   SER A  79      26.173  -1.392  -3.209  1.00 74.19           C
ATOM    625  O   SER A  79      25.136  -1.859  -3.671  1.00 78.84           O
ATOM    626  CB  SER A  79      27.741  -3.165  -2.377  1.00 76.10           C
ATOM    627  OG  SER A  79      27.762  -4.201  -1.404  1.00 72.14           O
ATOM    628  N   HIS A  80      26.776  -0.325  -3.737  1.00103.99           N
ATOM    629  CA  HIS A  80      26.234   0.343  -4.929  1.00116.25           C
ATOM    630  C   HIS A  80      25.516  -0.682  -5.801  1.00118.52           C
ATOM    631  O   HIS A  80      24.305  -0.605  -6.015  1.00109.53           O
ATOM    632  CB  HIS A  80      27.357   1.013  -5.725  1.00120.57           C
ATOM    633  CG  HIS A  80      26.912   1.609  -7.030  1.00121.19           C
ATOM    634  ND1 HIS A  80      26.374   2.874  -7.129  1.00116.92           N
ATOM    635  CD2 HIS A  80      26.942   1.114  -8.292  1.00115.86           C
ATOM    636  CE1 HIS A  80      26.079   3.131  -8.391  1.00109.34           C
ATOM    637  NE2 HIS A  80      26.412   2.077  -9.119  1.00110.01           N
ATOM    638  N   THR A  81      26.293  -1.621  -6.332  1.00130.09           N
ATOM    639  CA  THR A  81      25.777  -2.930  -6.707  1.00125.15           C
ATOM    640  C   THR A  81      26.400  -3.792  -5.624  1.00122.99           C
ATOM    641  O   THR A  81      27.577  -3.599  -5.292  1.00122.32           O
ATOM    642  CB  THR A  81      26.273  -3.387  -8.089  1.00121.33           C
ATOM    643  OG1 THR A  81      27.704  -3.489  -8.076  1.00127.79           O
ATOM    644  CG2 THR A  81      25.836  -2.407  -9.182  1.00114.98           C
ATOM    645  N   VAL A  82      25.661  -4.754  -5.080  1.00 57.29           N
ATOM    646  CA  VAL A  82      24.449  -5.306  -5.668  1.00 45.52           C
ATOM    647  C   VAL A  82      23.137  -4.619  -5.268  1.00 48.78           C
ATOM    648  O   VAL A  82      22.043  -5.135  -5.529  1.00 43.92           O
ATOM    649  CB  VAL A  82      24.348  -6.762  -5.237  1.00 45.57           C
ATOM    650  CG1 VAL A  82      25.728  -7.385  -5.223  1.00 43.29           C
ATOM    651  CG2 VAL A  82      23.751  -6.842  -3.844  1.00 54.32           C
ATOM    652  N   GLY A  83      23.230  -3.472  -4.611  1.00 58.23           N
ATOM    653  CA  GLY A  83      22.033  -2.711  -4.298  1.00 53.76           C
ATOM    654  C   GLY A  83      21.752  -2.494  -2.826  1.00 44.94           C
ATOM    655  O   GLY A  83      22.357  -3.128  -1.961  1.00 45.93           O
ATOM    656  N   LEU A  84      20.817  -1.589  -2.551  1.00 48.66           N
ATOM    657  CA  LEU A  84      20.426  -1.243  -1.185  1.00 57.60           C
ATOM    658  C   LEU A  84      19.358  -2.194  -0.642  1.00 54.98           C
ATOM    659  O   LEU A  84      18.549  -2.717  -1.403  1.00 56.71           O
ATOM    660  CB  LEU A  84      19.906   0.197  -1.145  1.00 52.93           C
ATOM    661  CG  LEU A  84      20.446   1.104  -0.040  1.00 46.66           C
ATOM    662  CD1 LEU A  84      21.964   1.019   0.049  1.00 49.27           C
ATOM    663  CD2 LEU A  84      20.003   2.530  -0.286  1.00 48.73           C
ATOM    664  N   SER A  85      19.360  -2.406   0.673  1.00 55.54           N
ATOM    665  CA  SER A  85      18.418  -3.321   1.319  1.00 53.87           C
ATOM    666  C   SER A  85      17.214  -2.581   1.866  1.00 50.23           C
ATOM    667  O   SER A  85      17.156  -1.356   1.835  1.00 53.14           O
ATOM    668  CB  SER A  85      19.078  -4.031   2.490  1.00 47.23           C
ATOM    669  OG  SER A  85      18.851  -3.289   3.673  1.00 42.03           O
ATOM    670  N   GLU A  86      16.259  -3.340   2.387  1.00 58.45           N
ATOM    671  CA  GLU A  86      15.102  -2.757   3.039  1.00 55.14           C
ATOM    672  C   GLU A  86      15.496  -2.309   4.432  1.00 49.03           C
ATOM    673  O   GLU A  86      16.471  -2.808   4.996  1.00 48.79           O
ATOM    674  CB  GLU A  86      13.975  -3.781   3.135  1.00 57.61           C
ATOM    675  CG  GLU A  86      13.558  -4.352   1.797  1.00 73.83           C
ATOM    676  CD  GLU A  86      12.279  -5.155   1.887  1.00 88.89           C
ATOM    677  OE1 GLU A  86      11.883  -5.518   3.017  1.00 77.70           O
ATOM    678  OE2 GLU A  86      11.673  -5.421   0.824  1.00 91.95           O
ATOM    679  N   SER A  87      14.741  -1.360   4.977  1.00 50.94           N
ATOM    680  CA  SER A  87      14.908  -0.946   6.363  1.00 44.97           C
ATOM    681  C   SER A  87      14.688  -2.130   7.292  1.00 47.20           C
ATOM    682  O   SER A  87      13.737  -2.894   7.121  1.00 51.59           O
ATOM    683  CB  SER A  87      13.905   0.154   6.724  1.00 42.81           C
ATOM    684  OG  SER A  87      14.282   1.405   6.182  1.00 47.05           O
ATOM    685  N   SER A  88      15.566  -2.282   8.276  1.00 42.29           N
ATOM    686  CA  SER A  88      15.341  -3.261   9.327  1.00 43.21           C
ATOM    687  C   SER A  88      14.100  -2.845  10.118  1.00 38.04           C
ATOM    688  O   SER A  88      13.591  -1.737   9.940  1.00 34.95           O
ATOM    689  CB  SER A  88      16.559  -3.334  10.247  1.00 38.75           C
ATOM    690  OG  SER A  88      16.791  -2.085  10.877  1.00 36.30           O
ATOM    691  N   ASP A  89      13.602  -3.726  10.980  1.00 39.49           N
ATOM    692  CA  ASP A  89      12.527  -3.336  11.888  1.00 39.13           C
ATOM    693  C   ASP A  89      13.047  -2.265  12.842  1.00 38.82           C
ATOM    694  O   ASP A  89      14.231  -2.256  13.193  1.00 36.94           O
ATOM    695  CB  ASP A  89      11.998  -4.534  12.678  1.00 36.31           C
ATOM    696  CG  ASP A  89      11.301  -5.538  11.803  1.00 37.66           C
ATOM    697  OD1 ASP A  89      10.726  -5.128  10.776  1.00 38.70           O
ATOM    698  OD2 ASP A  89      11.330  -6.738  12.138  1.00 38.00           O
ATOM    699  N   PRO A  90      12.163  -1.355  13.269  1.00 32.29           N
ATOM    700  CA  PRO A  90      12.582  -0.247  14.129  1.00 29.31           C
ATOM    701  C   PRO A  90      13.124  -0.738  15.466  1.00 28.92           C
ATOM    702  O   PRO A  90      12.702  -1.785  15.956  1.00 28.18           O
ATOM    703  CB  PRO A  90      11.283   0.534  14.343  1.00 30.64           C
ATOM    704  CG  PRO A  90      10.208  -0.469  14.127  1.00 35.15           C
ATOM    705  CD  PRO A  90      10.714  -1.335  13.019  1.00 30.40           C
ATOM    706  N   LEU A  91      14.063   0.014  16.031  1.00 31.09           N
ATOM    707  CA  LEU A  91      14.542  -0.221  17.384  1.00 24.92           C
ATOM    708  C   LEU A  91      14.095   0.947  18.250  1.00 29.78           C
ATOM    709  O   LEU A  91      14.373   2.106  17.939  1.00 31.06           O
ATOM    710  CB  LEU A  91      16.070  -0.339  17.416  1.00 26.42           C
ATOM    711  CG  LEU A  91      16.693  -0.619  18.788  1.00 24.00           C
ATOM    712  CD1 LEU A  91      16.822  -2.113  19.033  1.00 23.69           C
ATOM    713  CD2 LEU A  91      18.038   0.051  18.921  1.00 22.19           C
ATOM    714  N   GLU A  92      13.385   0.641  19.326  1.00 37.96           N
ATOM    715  CA  GLU A  92      12.960   1.660  20.264  1.00 38.42           C
ATOM    716  C   GLU A  92      14.070   1.843  21.276  1.00 40.00           C
ATOM    717  O   GLU A  92      14.234   1.020  22.176  1.00 41.00           O
ATOM    718  CB  GLU A  92      11.695   1.208  20.981  1.00 48.95           C
ATOM    719  CG  GLU A  92      10.678   0.536  20.078  1.00 52.29           C
ATOM    720  CD  GLU A  92       9.908   1.527  19.242  1.00 56.64           C
ATOM    721  OE1 GLU A  92       9.368   2.492  19.823  1.00 62.63           O
ATOM    722  OE2 GLU A  92       9.834   1.337  18.009  1.00 54.66           O
ATOM    723  N   LEU A  93      14.846   2.909  21.117  1.00 36.18           N
ATOM    724  CA  LEU A  93      15.938   3.200  22.036  1.00 33.64           C
ATOM    725  C   LEU A  93      15.441   4.095  23.153  1.00 35.15           C
ATOM    726  O   LEU A  93      15.205   5.291  22.952  1.00 32.89           O
ATOM    727  CB  LEU A  93      17.103   3.864  21.307  1.00 36.50           C
ATOM    728  CG  LEU A  93      18.319   4.236  22.159  1.00 36.82           C
ATOM    729  CD1 LEU A  93      18.764   3.054  23.014  1.00 33.05           C
ATOM    730  CD2 LEU A  93      19.466   4.745  21.282  1.00 32.63           C
ATOM    731  N   VAL A  94      15.296   3.498  24.333  1.00 37.24           N
ATOM    732  CA  VAL A  94      14.711   4.165  25.487  1.00 37.33           C
ATOM    733  C   VAL A  94      15.761   4.539  26.520  1.00 34.98           C
ATOM    734  O   VAL A  94      16.679   3.770  26.779  1.00 37.57           O
ATOM    735  CB  VAL A  94      13.690   3.252  26.173  1.00 40.14           C
ATOM    736  CG1 VAL A  94      13.049   3.968  27.355  1.00 41.17           C
ATOM    737  CG2 VAL A  94      12.645   2.777  25.169  1.00 38.15           C
ATOM    738  N   VAL A  95      15.612   5.720  27.113  1.00 34.95           N
ATOM    739  CA  VAL A  95      16.512   6.184  28.164  1.00 35.21           C
ATOM    740  C   VAL A  95      15.723   6.437  29.457  1.00 36.88           C
ATOM    741  O   VAL A  95      14.641   7.029  29.421  1.00 35.18           O
ATOM    742  CB  VAL A  95      17.239   7.475  27.738  1.00 29.19           C
ATOM    743  CG1 VAL A  95      18.426   7.730  28.640  1.00 34.06           C
ATOM    744  CG2 VAL A  95      17.686   7.379  26.287  1.00 25.66           C
ATOM    745  N   THR A  96      16.264   5.988  30.590  1.00 41.08           N
ATOM    746  CA  THR A  96      15.577   6.095  31.882  1.00 40.19           C
ATOM    747  C   THR A  96      16.462   6.663  32.993  1.00 44.24           C
ATOM    748  O   THR A  96      17.498   7.277  32.731  1.00 45.67           O
ATOM    749  CB  THR A  96      15.059   4.723  32.354  1.00 42.10           C
ATOM    750  OG1 THR A  96      16.163   3.907  32.765  1.00 46.55           O
ATOM    751  CG2 THR A  96      14.297   4.022  31.237  1.00 43.81           C
ATOM    752  N   GLY A  97      16.041   6.449  34.237  1.00 52.75           N
ATOM    753  CA  GLY A  97      16.826   6.831  35.400  1.00 49.86           C
ATOM    754  C   GLY A  97      17.140   8.313  35.459  1.00 54.81           C
ATOM    755  O   GLY A  97      18.062   8.737  36.161  1.00 56.05           O
TER
HETATM  756  O   HOH A  98      12.067   8.859  16.800  1.00 28.07           O
HETATM  757  O   HOH A  99      15.469  -4.192  14.509  1.00 28.15           O
HETATM  758  O   HOH A 100      30.272  -3.844  -4.971  1.00 41.99           O
HETATM  759  O   HOH A 101      28.845  10.037  18.238  1.00 28.48           O
HETATM  760  O   HOH A 102      15.336  16.496  12.050  1.00 27.25           O
HETATM  761  O   HOH A 103      28.284  -5.867   2.987  1.00 78.94           O
HETATM  762  O   HOH A 104      15.040  -6.243  11.030  1.00 28.00           O
HETATM  763  O   HOH A 105      12.325  -7.284  14.415  1.00 24.94           O
HETATM  764  O   HOH A 106      39.089   0.917   4.088  1.00 43.47           O
HETATM  765  O   HOH A 107      29.565   8.685  22.520  1.00 30.59           O
HETATM  766  O   HOH A 108      28.472   8.135  20.105  1.00 39.16           O
HETATM  767  O   HOH A 109      19.567  15.452  26.730  1.00 34.93           O
HETATM  768  O   HOH A 110      11.242   4.407  20.797  1.00 47.33           O
HETATM  769  O   HOH A 111      20.490  14.804  28.961  1.00 41.21           O
HETATM  770  O   HOH A 112      19.830 -10.817   9.080  1.00 45.37           O
HETATM  771  O   HOH A 113       9.668  -3.455   8.996  1.00 41.35           O
HETATM  772  O   HOH A 114      12.707   9.026  14.389  1.00 32.70           O
HETATM  773  O   HOH A 115      27.124  -5.161  14.086  1.00 44.80           O
HETATM  774  O   HOH A 116      18.786  -1.043  32.048  1.00 42.66           O
HETATM  775  O   HOH A 117      16.489  -3.839  -1.146  1.00 66.87           O
HETATM  776  O   HOH A 118      28.567  -3.762   3.599  1.00 49.63           O
HETATM  777  O   HOH A 119      14.870  18.972  20.629  1.00 54.87           O
HETATM  778  O   HOH A 120      30.431  -1.309  21.441  1.00 45.49           O
HETATM  779  O   HOH A 121       6.740   3.294  17.043  1.00 42.31           O
HETATM  780  O   HOH A 122      31.540   1.012   1.605  1.00 45.31           O
HETATM  781  O   HOH A 123      25.714   2.391   1.044  1.00 51.27           O
HETATM  782  O   HOH A 124      29.492  -4.632   0.927  1.00 56.02           O
HETATM  783  O   HOH A 125      28.713  -7.346   9.602  1.00 36.45           O
HETATM  784  O   HOH A 126      22.951 -11.873   8.814  1.00 45.23           O
HETATM  785  O   HOH A 127      28.061  -8.436  18.890  1.00 50.79           O
HETATM  786  O   HOH A 128      24.201   2.479   3.211  1.00 33.01           O
HETATM  787  O   HOH A 129      35.203  -2.342   4.420  1.00 47.07           O
END
"""

pdb_str_fraction = """
CRYST1   26.653    4.824   29.048  90.00 101.02  90.00 P 1 21 1
SCALE1      0.037519  0.000000  0.007307        0.00000
SCALE2      0.000000  0.207297  0.000000        0.00000
SCALE3      0.000000  0.000000  0.035072        0.00000
ATOM      1  N   ASN A   1      -1.695   1.735  15.868  1.00  4.33           N
ATOM      2  CA  ASN A   1      -0.410   1.041  15.831  1.00  3.38           C
ATOM      3  C   ASN A   1       0.646   1.801  16.594  1.00  5.38           C
ATOM      4  O   ASN A   1       0.646   3.030  16.628  1.00  4.56           O
ATOM      5  CB  ASN A   1       0.086   0.844  14.397  1.00  1.95           C
ATOM      6  CG  ASN A   1      -0.744  -0.143  13.631  1.00  5.60           C
ATOM      7  OD1 ASN A   1      -1.623  -0.818  14.193  1.00  4.60           O
ATOM      8  ND2 ASN A   1      -0.449  -0.270  12.345  1.00  3.71           N
ATOM      9  H1  ASN A   1      -2.362   1.198  16.458  0.00  4.33           H
ATOM     10  H2  ASN A   1      -1.564   2.685  16.269  0.00  4.33           H
ATOM     11  H3  ASN A   1      -2.073   1.815  14.903  0.00  4.33           H
ATOM     12  HA  ASN A   1      -0.557   0.062  16.287  0.00  3.38           H
ATOM     13  HB2 ASN A   1       0.046   1.798  13.872  0.00  1.95           H
ATOM     14  HB3 ASN A   1       1.111   0.475  14.423  0.00  1.95           H
ATOM     15 HD21 ASN A   1      -0.974  -0.924  11.764  0.00  3.71           H
ATOM     16 HD22 ASN A   1       0.303   0.286  11.937  0.00  3.71           H
ATOM     17  N   VAL A   2       1.575   1.065  17.191  1.00  2.21           N
ATOM     18  CA  VAL A   2       2.779   1.651  17.739  1.00  2.56           C
ATOM     19  C   VAL A   2       3.948   1.033  16.990  1.00  1.90           C
ATOM     20  O   VAL A   2       4.136  -0.192  17.019  1.00  2.64           O
ATOM     21  CB  VAL A   2       2.893   1.411  19.247  1.00  4.05           C
ATOM     22  CG1 VAL A   2       4.189   2.028  19.774  1.00  2.63           C
ATOM     23  CG2 VAL A   2       1.651   2.005  19.922  1.00  2.47           C
ATOM     24  H   VAL A   2       1.515   0.053  17.308  0.00  2.21           H
ATOM     25  HA  VAL A   2       2.784   2.728  17.573  0.00  2.56           H
ATOM     26  HB  VAL A   2       2.935   0.347  19.479  0.00  4.05           H
ATOM     27 HG11 VAL A   2       4.256   1.850  20.847  0.00  2.63           H
ATOM     28 HG12 VAL A   2       5.035   1.564  19.266  0.00  2.63           H
ATOM     29 HG13 VAL A   2       4.178   3.100  19.575  0.00  2.63           H
ATOM     30 HG21 VAL A   2       1.719   1.841  20.997  0.00  2.47           H
ATOM     31 HG22 VAL A   2       1.609   3.074  19.711  0.00  2.47           H
ATOM     32 HG23 VAL A   2       0.763   1.513  19.526  0.00  2.47           H
TER
ATOM    101  N   ASN B   1      12.281   4.857  -1.733  1.00  2.85           N
ATOM    102  CA  ASN B   1      11.027   4.097  -1.673  1.00  3.81           C
ATOM    103  C   ASN B   1       9.965   4.796  -2.471  1.00  2.59           C
ATOM    104  O   ASN B   1       9.976   6.019  -2.588  1.00  2.85           O
ATOM    105  CB  ASN B   1      10.515   3.935  -0.253  1.00  1.67           C
ATOM    106  CG  ASN B   1      11.327   2.968   0.550  1.00  3.35           C
ATOM    107  OD1 ASN B   1      12.142   2.222   0.011  1.00  4.04           O
ATOM    108  ND2 ASN B   1      11.108   2.964   1.860  1.00  3.17           N
ATOM    109  H1  ASN B   1      12.987   4.318  -2.274  0.00  2.85           H
ATOM    110  H2  ASN B   1      12.111   5.771  -2.199  0.00  2.85           H
ATOM    111  H3  ASN B   1      12.634   5.020  -0.768  0.00  2.85           H
ATOM    112  HA  ASN B   1      11.223   3.102  -2.073  0.00  3.81           H
ATOM    113  HB2 ASN B   1      10.549   4.902   0.249  0.00  1.67           H
ATOM    114  HB3 ASN B   1       9.489   3.568  -0.285  0.00  1.67           H
ATOM    115 HD21 ASN B   1      11.630   2.327   2.462  0.00  3.17           H
ATOM    116 HD22 ASN B   1      10.418   3.597   2.264  0.00  3.17           H
ATOM    117  N   VAL B   2       9.020   4.021  -2.990  1.00  1.69           N
ATOM    118  CA  VAL B   2       7.839   4.566  -3.646  1.00  0.82           C
ATOM    119  C   VAL B   2       6.641   4.104  -2.842  1.00  1.98           C
ATOM    120  O   VAL B   2       6.357   2.903  -2.783  1.00  1.64           O
ATOM    121  CB  VAL B   2       7.725   4.115  -5.114  1.00  1.73           C
ATOM    122  CG1 VAL B   2       6.390   4.611  -5.733  1.00  1.72           C
ATOM    123  CG2 VAL B   2       8.903   4.658  -5.900  1.00  2.63           C
ATOM    124  H   VAL B   2       9.046   3.002  -2.971  0.00  1.69           H
ATOM    125  HA  VAL B   2       7.881   5.655  -3.629  0.00  0.82           H
ATOM    126  HB  VAL B   2       7.734   3.026  -5.162  0.00  1.73           H
ATOM    127 HG11 VAL B   2       6.335   4.279  -6.770  0.00  1.72           H
ATOM    128 HG12 VAL B   2       5.559   4.194  -5.164  0.00  1.72           H
ATOM    129 HG13 VAL B   2       6.362   5.700  -5.689  0.00  1.72           H
ATOM    130 HG21 VAL B   2       8.816   4.335  -6.938  0.00  2.63           H
ATOM    131 HG22 VAL B   2       8.893   5.747  -5.847  0.00  2.63           H
ATOM    132 HG23 VAL B   2       9.826   4.273  -5.467  0.00  2.63           H
TER
"""

pdb_str_one_chain = """
CRYST1   21.937    4.866   23.477  90.00 107.08  90.00 P 1 21 1
SCALE1      0.045585  0.000000  0.014006        0.00000
SCALE2      0.000000  0.205508  0.000000        0.00000
SCALE3      0.000000  0.000000  0.044560        0.00000
ATOM      1  N   GLY A   1      12.928   4.612   6.102  1.00 16.77           N
ATOM      2  CA  GLY A   1      12.885   4.207   4.651  1.00 16.57           C
ATOM      3  C   GLY A   1      13.922   3.140   4.419  1.00 16.16           C
ATOM      4  O   GLY A   1      14.414   2.521   5.381  1.00 16.78           O
ATOM      5  H1  GLY A   1      11.977   4.525   6.514  0.00 16.77           H
ATOM      6  H2  GLY A   1      13.586   3.992   6.616  0.00 16.77           H
ATOM      7  H3  GLY A   1      13.250   5.598   6.177  0.00 16.77           H
ATOM      8  HA2 GLY A   1      11.900   3.815   4.398  0.00 16.57           H
ATOM      9  HA3 GLY A   1      13.100   5.065   4.014  0.00 16.57           H
ATOM     10  N   ASN A   2      14.281   2.923   3.155  1.00 15.02           N
ATOM     11  CA  ASN A   2      15.415   2.038   2.831  1.00 14.10           C
ATOM     12  C   ASN A   2      16.696   2.537   3.427  1.00 13.13           C
ATOM     13  O   ASN A   2      16.959   3.742   3.426  1.00 11.91           O
ATOM     14  CB  ASN A   2      15.591   1.881   1.341  1.00 15.38           C
ATOM     15  CG  ASN A   2      14.353   1.342   0.692  1.00 14.08           C
ATOM     16  OD1 ASN A   2      13.912   0.227   1.016  1.00 17.46           O
ATOM     17  ND2 ASN A   2      13.733   2.155  -0.169  1.00 11.72           N
ATOM     18  H   ASN A   2      13.820   3.334   2.343  0.00 15.02           H
ATOM     19  HA  ASN A   2      15.193   1.057   3.252  0.00 14.10           H
ATOM     20  HB2 ASN A   2      15.813   2.853   0.900  0.00 15.38           H
ATOM     21  HB3 ASN A   2      16.409   1.188   1.146  0.00 15.38           H
ATOM     22 HD21 ASN A   2      12.885   1.845  -0.643  0.00 11.72           H
ATOM     23 HD22 ASN A   2      14.108   3.086  -0.352  0.00 11.72           H
ATOM     24  N   ASN A   3      17.499   1.590   3.905  1.00 12.26           N
ATOM     25  CA  ASN A   3      18.744   1.904   4.589  1.00 11.74           C
ATOM     26  C   ASN A   3      19.982   1.332   3.895  1.00 11.10           C
ATOM     27  O   ASN A   3      20.065   0.119   3.648  1.00 10.42           O
ATOM     28  CB  ASN A   3      18.678   1.378   6.042  1.00 12.15           C
ATOM     29  CG  ASN A   3      19.931   1.739   6.861  1.00 12.82           C
ATOM     30  OD1 ASN A   3      20.235   2.925   7.072  1.00 15.05           O
ATOM     31  ND2 ASN A   3      20.666   0.715   7.306  1.00 13.48           N
ATOM     32  OXT ASN A   3      20.908   2.077   3.576  1.00 11.10           O
ATOM     33  H   ASN A   3      17.311   0.590   3.832  0.00 12.26           H
ATOM     34  HA  ASN A   3      18.863   2.987   4.586  0.00 11.74           H
ATOM     35  HB2 ASN A   3      17.812   1.815   6.539  0.00 12.15           H
ATOM     36  HB3 ASN A   3      18.588   0.292   6.023  0.00 12.15           H
ATOM     37 HD21 ASN A   3      21.508   0.892   7.854  0.00 13.48           H
ATOM     38 HD22 ASN A   3      20.385  -0.243   7.097  0.00 13.48           H
TER
"""

pdb_str_huge_box = """
CRYST1  109.608  105.841  108.497  90.00  90.00  90.00 P 1
SCALE1      0.009123  0.000000  0.000000        0.00000
SCALE2      0.000000  0.009448  0.000000        0.00000
SCALE3      0.000000  0.000000  0.009217        0.00000
ATOM      1  N   GLY A   1      51.028  54.855  56.745  1.00 16.77           N
ATOM      2  CA  GLY A   1      50.985  54.450  55.294  1.00 16.57           C
ATOM      3  C   GLY A   1      52.022  53.383  55.062  1.00 16.16           C
ATOM      4  O   GLY A   1      52.514  52.764  56.024  1.00 16.78           O
ATOM      5  H1  GLY A   1      50.077  54.768  57.157  0.00 16.77           H
ATOM      6  H2  GLY A   1      51.686  54.235  57.259  0.00 16.77           H
ATOM      7  H3  GLY A   1      51.350  55.841  56.820  0.00 16.77           H
ATOM      8  HA2 GLY A   1      50.000  54.058  55.041  0.00 16.57           H
ATOM      9  HA3 GLY A   1      51.200  55.308  54.657  0.00 16.57           H
ATOM     10  N   ASN A   2      52.381  53.166  53.798  1.00 15.02           N
ATOM     11  CA  ASN A   2      53.515  52.281  53.474  1.00 14.10           C
ATOM     12  C   ASN A   2      54.796  52.780  54.070  1.00 13.13           C
ATOM     13  O   ASN A   2      55.059  53.985  54.069  1.00 11.91           O
ATOM     14  CB  ASN A   2      53.691  52.124  51.984  1.00 15.38           C
ATOM     15  CG  ASN A   2      52.453  51.585  51.335  1.00 14.08           C
ATOM     16  OD1 ASN A   2      52.012  50.470  51.659  1.00 17.46           O
ATOM     17  ND2 ASN A   2      51.833  52.398  50.474  1.00 11.72           N
ATOM     18  H   ASN A   2      51.920  53.577  52.986  0.00 15.02           H
ATOM     19  HA  ASN A   2      53.293  51.300  53.895  0.00 14.10           H
ATOM     20  HB2 ASN A   2      53.913  53.096  51.543  0.00 15.38           H
ATOM     21  HB3 ASN A   2      54.509  51.431  51.789  0.00 15.38           H
ATOM     22 HD21 ASN A   2      50.985  52.088  50.000  0.00 11.72           H
ATOM     23 HD22 ASN A   2      52.208  53.329  50.291  0.00 11.72           H
ATOM     24  N   ASN A   3      55.599  51.833  54.548  1.00 12.26           N
ATOM     25  CA  ASN A   3      56.844  52.147  55.232  1.00 11.74           C
ATOM     26  C   ASN A   3      58.082  51.575  54.538  1.00 11.10           C
ATOM     27  O   ASN A   3      58.165  50.362  54.291  1.00 10.42           O
ATOM     28  CB  ASN A   3      56.778  51.621  56.685  1.00 12.15           C
ATOM     29  CG  ASN A   3      58.031  51.982  57.504  1.00 12.82           C
ATOM     30  OD1 ASN A   3      58.335  53.168  57.715  1.00 15.05           O
ATOM     31  ND2 ASN A   3      58.766  50.958  57.949  1.00 13.48           N
ATOM     32  OXT ASN A   3      59.008  52.320  54.219  1.00 11.10           O
ATOM     33  H   ASN A   3      55.411  50.833  54.475  0.00 12.26           H
ATOM     34  HA  ASN A   3      56.963  53.230  55.229  0.00 11.74           H
ATOM     35  HB2 ASN A   3      55.912  52.058  57.182  0.00 12.15           H
ATOM     36  HB3 ASN A   3      56.688  50.535  56.666  0.00 12.15           H
ATOM     37 HD21 ASN A   3      59.608  51.135  58.497  0.00 13.48           H
ATOM     38 HD22 ASN A   3      58.485  50.000  57.740  0.00 13.48           H
TER
END
"""

def exercise_00(nonbonded_distance_cutoff=4.5, write_files=False):
  """
  Exercise supercell. General.
  """
  if (libtbx.env.find_in_repositories(relative_path="chem_data") is None):
    print("Skipping exercise(): chem_data directory not available")
    return
  if(write_files):
    with open("input.pdb","w") as fo:
      fo.write(pdb_str_1yjp)
  pdb_inp = iotbx.pdb.input(source_info=None, lines=pdb_str_1yjp)
  m = mmtbx.model.manager(model_input = pdb_inp, log = null_out())
  p = m.get_default_pdb_interpretation_params()
  p.pdb_interpretation.nonbonded_distance_cutoff = nonbonded_distance_cutoff
  m.process(make_restraints=True, pdb_interpretation_params=p)
  # Figure symmetry interactions internally
  sc1 = super_cell.manager(
    pdb_hierarchy        = m.get_hierarchy(),
    crystal_symmetry     = m.crystal_symmetry(),
    select_within_radius = nonbonded_distance_cutoff)
  if(write_files):
    sc1.super_sphere_hierarchy.write_pdb_file(file_name="sc1.pdb",
      crystal_symmetry = sc1.cs_super_sphere)
  # Take symmetry interactions from restraints
  siiu = m.get_restraints_manager().geometry.pair_proxies().nonbonded_proxies.\
     get_symmetry_interacting_indices_unique(
       sites_cart = m.get_hierarchy().atoms().extract_xyz())
  sc2 = super_cell.manager(
    pdb_hierarchy        = m.get_hierarchy(),
    crystal_symmetry     = m.crystal_symmetry(),
    select_within_radius = nonbonded_distance_cutoff,
    siiu                 = siiu)
  if(write_files):
    sc2.super_sphere_hierarchy.write_pdb_file(file_name="sc2.pdb",
      crystal_symmetry = sc2.cs_super_sphere)
  # Check both ways produce the same models (chain/residue order can vary)
  assert sc1.super_sphere_hierarchy.atoms().size()==\
         sc2.super_sphere_hierarchy.atoms().size()

def exercise_01():
  """
  When increasing Rss make sure models with smaller Rss are exact subset of
  models with larger Rss (exercises the bug fix found by Goska).
  """
  def dist(r1,r2):
    return math.sqrt((r1[0]-r2[0])**2+(r1[1]-r2[1])**2+(r1[2]-r2[2])**2)
  coords = []
  for Rss in range(0,11):
    #print(Rss)
    pdb_inp = iotbx.pdb.input(source_info=None, lines = pdb_str_3q2c)
    h = pdb_inp.construct_hierarchy()
    h.atoms().reset_i_seq()
    ss = super_cell.manager(
      pdb_hierarchy = h,
      crystal_symmetry = pdb_inp.crystal_symmetry(),
      select_within_radius=Rss,
      siiu=None)
    coords.append(ss.super_sphere_hierarchy.atoms().extract_xyz())
  for i, ri in enumerate(coords):
    for j, rj in enumerate(coords):
      if(i<j):
        for site_i in ri:
          found = False
          for site_j in rj:
            d = dist(site_i, site_j)
            if(d<1.e-2):
              found = True
              break
          assert found

def _grad_from_ss(expansion):
  pdb_hierarchy_super = expansion.super_sphere_hierarchy
  ss_crystal_symmetry = expansion.cs_super_sphere
  selection = flex.bool(pdb_hierarchy_super.atoms().size(), False)
  selection = selection.set_selected(
    flex.size_t(range(expansion.pdb_hierarchy.atoms().size())), True)
  model = mmtbx.model.manager(
    model_input       = None,
    pdb_hierarchy     = pdb_hierarchy_super,
    crystal_symmetry  = ss_crystal_symmetry,
    log               = null_out())
  model.process(make_restraints=True, grm_normalization=True)
  rm = model.get_restraints_manager()
  es = rm.geometry.energies_sites(
    sites_cart        = model.get_sites_cart(),
    compute_gradients =True)
  return es.gradients.select(selection)

def exercise_02():
  """
  Check expansion via gradients.
  """
  for pdb_str in [pdb_str_huge_box,
                  pdb_str_one_chain,
                  pdb_str_1yjp,
                  pdb_str_3q2c,
                  pdb_str_fraction]:
    # gradients usual way
    pdb_inp = iotbx.pdb.input(source_info=None, lines = pdb_str)
    h = pdb_inp.construct_hierarchy()
    model = mmtbx.model.manager(
      model_input       = None,
      pdb_hierarchy     = h,
      crystal_symmetry  = pdb_inp.crystal_symmetry(),
      log               = null_out())
    model.process(make_restraints=True, grm_normalization=True)
    rm = model.get_restraints_manager()
    es = rm.geometry.energies_sites(
      sites_cart        = model.get_sites_cart(),
      compute_gradients = True)
    g1 = es.gradients
    # gradients via expansion
    expansion = super_cell.manager(
      pdb_hierarchy        = model.get_hierarchy(),
      crystal_symmetry     = model.crystal_symmetry(),
      select_within_radius = 5,
      box_buffer_layer     = 3)
    g2 = _grad_from_ss(expansion)
    # compare gradinets by means of distance
    dist = flex.sqrt((g1 - g2).dot())
    assert flex.max(dist) < 1.e-6, flex.max(dist)
    #
    # scramble sites_cart
    for it in [1,2]:
      r = model.get_hierarchy().atoms().extract_xyz()
      rs = flex.vec3_double(r.as_double()*3 + flex.random_double(r.as_double().size()))
      expansion.update(sites_cart = rs, debug=True)
      g3 = _grad_from_ss(expansion)
      dist = flex.sqrt((g1 - g3).dot())
      assert flex.max(dist) > 100., flex.max(dist) # some number like this, typically 300-600
      # set original sites
      expansion.update(sites_cart = r, debug=True)
      g4 = _grad_from_ss(expansion)
      dist = flex.sqrt((g1 - g4).dot())
      assert flex.max(dist) < 1.e-6, flex.max(dist)


if(__name__ == "__main__"):
  exercise_00()
  exercise_01()
  if libtbx.env.find_in_repositories(relative_path="chem_data") is None:
    print("Skipping exercise_02(): chem_data directory not available")
  else:
    exercise_02()


 *******************************************************************************
