

 *******************************************************************************
iotbx/detectors/__init__.py
"""Tools to read X-ray images from a variety of detectors
"""
from __future__ import absolute_import, division, print_function
import os
import re

import boost_adaptbx.boost.python as bp
ext = bp.import_ext("iotbx_detectors_ext")
from iotbx_detectors_ext import *
from iotbx_detectors_bruker_ext import Bruker_base # import dependency

class ImageException(Exception):
  pass

from iotbx.detectors.adsc import ADSCImage
from iotbx.detectors.hamamatsu import HamamatsuImage
from iotbx.detectors.mar import MARImage
from iotbx.detectors.marIP import MARIPImage
from iotbx.detectors.cbf import CBFImage
from iotbx.detectors.dtrek import DTREKImage
from iotbx.detectors.raxis import RAXISImage
from iotbx.detectors.raxis_nonsquare import NonSquareRAXISImage
from iotbx.detectors.macscience import DIPImage
from iotbx.detectors.saturn import SaturnImage
from iotbx.detectors.noir import NoirImage
from iotbx.detectors.bruker import BrukerImage
from iotbx.detectors.pilatus_minicbf import PilatusImage
from iotbx.detectors.eiger_minicbf import EigerCBFImage
from iotbx.detectors.edf import EDFImage
from iotbx.detectors.detectorbase import DetectorImageBase
from iotbx.detectors.pilatus_slice import pilatus_slice_from_file_url
from iotbx.detectors.pilatus_slice import pilatus_slice_from_http_url
from iotbx.detectors.adsc_module import ADSC_module_from_file_url
from iotbx.detectors.eiger import EIGERImage

class EDFWrapper(EDFImage, DetectorImageBase):
  def __init__(self,filename):
    EDFImage.__init__(self,filename)
    self.vendortype = "Pilatus Single Module"
  def readHeader(self):
    EDFImage.readHeader(self)
    self.parameters['PIXEL_SIZE']=0.172
    self.parameters['SIZE1']=self.parameters['Dim_1']
    self.parameters['SIZE2']=self.parameters['Dim_2']
    self.parameters['BEAM_CENTER_X']=0.0 #Dummy argument
    self.parameters['BEAM_CENTER_Y']=0.0 #Dummy argument
    self.parameters['DISTANCE']=100.0 #Dummy argument

class SMVImage(ADSCImage):
  def __init__(self,filename):
    DetectorImageBase.__init__(self,filename)
    self.vendortype = "SMV(Generic)"

all_image_types = [EDFWrapper,SaturnImage,DIPImage,NoirImage,ADSCImage,HamamatsuImage,
                  MARImage,MARIPImage,DTREKImage,RAXISImage,
                  NonSquareRAXISImage,SMVImage,PilatusImage,EigerCBFImage,CBFImage,BrukerImage]
all_image_types.insert(0, EIGERImage)

all_url_types = [pilatus_slice_from_file_url,pilatus_slice_from_http_url,
                 ADSC_module_from_file_url
]

def ImageFactory(filename,optional_index=None):
  from iotbx.detectors import url_support
  from libtbx.utils import Sorry
  if os.path.isfile(filename):
    if not os.access(filename, os.R_OK):
      raise Sorry("No read access to file %s" % filename)
    import dxtbx.format.Registry
    format_instance = dxtbx.format.Registry.get_format_class_for_file(filename)
    instance = format_instance(filename)
    if optional_index is not None:
      return instance.get_detectorbase(optional_index)
    return instance.get_detectorbase()
  A = url_support.potential_url_request(filename)
  if A.is_url_request():
    for utype in all_url_types:
      try:
        I = utype(filename)
        I.readHeader()
        return I
      except Exception:
        pass
    raise ImageException(filename+" does not work as a functioning image URL")
  raise ImageException(filename+" not recognized as any known detector image type")

def identify_dataset(path_name):
  def get_file_name_components(file_name_):
    base, ext = os.path.splitext(os.path.basename(file_name_))
    fields = base.split("_")
    suffix = fields[-1]
    common_base = "_".join(fields[:-1])
    return (common_base, suffix, ext)
  suffix = common_base = common_ext = None
  file_name = dir_name = None
  if (os.path.isfile(path_name)):
    file_name = os.path.abspath(path_name)
  elif (os.path.isdir(path_name)):
    dir_name = os.path.abspath(path_name)
  else :
    assert 0
  if (file_name is not None):
    dir_name = os.path.dirname(file_name)
    (common_base, suffix, common_ext) = get_file_name_components(file_name)
  all_files = os.listdir(dir_name)
  stacks = {}
  suffixes = {}
  extensions = {}
  for fn in all_files :
    if (common_base is not None):
      if (fn.startswith(common_base)) and (fn.endswith(common_ext)):
        (base2, suffix2, ext2) = get_file_name_components(fn)
        if (common_base in stacks):
          stacks[common_base].append(int(suffix2))
        else :
          suffixes[common_base] = "#" * len(suffix)
          stacks[common_base] = [ int(suffix2) ]
          extensions[common_base] = ext2
    else :
      (base2, suffix2, ext2) = get_file_name_components(fn)
      # FIXME probably not a comprehensive list...
      if (ext2 in [".img",".osc",".ccd",".mccd",".cbf"]):
        if (base2 in stacks):
          stacks[base2].append(int(suffix2))
        else :
          stacks[base2] = [ int(suffix2) ]
          suffixes[base2] = "#" * len(suffix2)
          extensions[base2] = ext2
  results = []
  for base in sorted(stacks.keys()):
    ranges = []
    img_start = img_last = None
    for x in sorted(stacks[base]):
      if (img_start is None):
        img_start = x
      elif (img_last is not None) and (x > (img_last + 1)):
        ranges.append((img_start, img_last))
        img_start = x
      img_last = x
    ranges.append((img_start, img_last))
    file_base = "%s_%s%s" % (base, suffixes[base], extensions[base])
    #print "%s %s" % (file_base,
    #  ", ".join([ "%d-%d" % (a,b) for (a, b) in ranges ]))
    dataset = dataset_info(
      base_name=os.path.join(dir_name, file_base),
      ranges=ranges)
    results.append(dataset)
  return results

class dataset_info(object):
  def __init__(self, base_name, ranges):
    self.base_name = base_name
    self.ranges = ranges

  def format(self):
    ranges_strs = []
    for start, end in self.ranges :
      if (start == end):
        ranges_strs.append(str(start))
      else :
        ranges_strs.append("%d-%d" % (start, end))
    return "%s (%s)" % (self.base_name, ",".join(ranges_strs))

  def __str__(self):
    return self.format()

  def get_frame_path(self, frame):
    assert isinstance(frame, int) and (frame > 0)
    serial_format = "%%0%dd" % (self.base_name.count("#"))
    format_str = re.sub("[#]{1,}", serial_format, self.base_name)
    return format_str % frame


 *******************************************************************************


 *******************************************************************************
iotbx/detectors/active_area_filter.py
from __future__ import absolute_import, division, print_function
from six.moves import range
from scitbx.array_family import flex

class active_area_filter:
  NEAR = 2
  def __init__(self,IT):
    from scitbx import matrix
    self.IT = IT
    from annlib_ext import AnnAdaptor

    reference = flex.double()

    for i in range(len(IT)//4):
      UL = matrix.col((float(IT[4*i]),float(IT[4*i+1])))
      LR = matrix.col((float(IT[4*i+2]),float(IT[4*i+3])))
      center = (UL+LR)/2.
      reference.append(center[0])
      reference.append(center[1])
    self.adapt = AnnAdaptor(data=reference,dim=2,k=self.NEAR)
  def __call__(self,predictions,hkllist,pxlsz):
    if len(self.IT) == 4:
      # We have only one tile, AnnAdaptor chokes in this case but then there is
      # only one choice of nearest neighbour anyway!
      nearest_neighbours = flex.int(len(predictions)*self.NEAR, 0)
    else:
      query = flex.double()
      for pred in predictions:
        query.append(pred[0]/pxlsz)
        query.append(pred[1]/pxlsz)
      self.adapt.query(query)
      assert len(self.adapt.nn)==len(predictions)*self.NEAR
      nearest_neighbours = self.adapt.nn
    selection = flex.bool()
    self.tile_id = flex.int()
    for p in range(len(predictions)):
      is_in_active_area = False
      for n in range(self.NEAR):
        itile = nearest_neighbours[p*self.NEAR+n]
        if self.IT[4*itile]<predictions[p][0]/pxlsz<self.IT[4*itile+2] and\
           self.IT[4*itile+1]<predictions[p][1]/pxlsz<self.IT[4*itile+3]:
          is_in_active_area = True;break
      if is_in_active_area:
        self.tile_id.append(itile)
      selection.append(is_in_active_area)
    assert selection.count(True) == len(self.tile_id)
    return predictions.select(selection),hkllist.select(selection)


 *******************************************************************************


 *******************************************************************************
iotbx/detectors/adsc.py
from __future__ import absolute_import, division, print_function
import re
from iotbx.detectors.detectorbase import DetectorImageBase

class ADSCImage(DetectorImageBase):
  def __init__(self,filename):
    DetectorImageBase.__init__(self,filename)
    self.vendortype = "ADSC"
    self.open_file = open # default: open files with built-in, unless otherwise instructed by dxtbx format

  def readHeader(self,maxlength=12288, external_keys=None): # usually 1024 is OK; require 12288 for ID19
    if not self.parameters:
      MAGIC_NUMBER = b'{\nHEADER_BYTES='
      stream = self.open_file(self.filename, 'rb')

      # Check the magic number and get the size of the header before
      # the start of the image data
      # (http://strucbio.biologie.uni-konstanz.de/ccp4wiki/index.php/SMV_file_format).
      # This obsoletes the maxlength parameter.
      assert stream.read(len(MAGIC_NUMBER)) == MAGIC_NUMBER
      while True:
        c = stream.read(1)
        if not c.isspace():
          break
      header_bytes = c
      while True:
        c = stream.read(1)
        if not c.isdigit():
          break
        header_bytes += c

      # Reread the entire header.  Only storing the remaining parts of
      # the header in self.header may break the API.
      stream.seek(0)
      self.header = stream.read(int(header_bytes))
      stream.close()

      self.parameters={'CCD_IMAGE_SATURATION':65535}

      library = [
          ('HEADER_BYTES','HEADER_BYTES',int),
          ('SIZE1','SIZE1',int),
          ('SIZE2','SIZE2',int),
          ('CCD_IMAGE_SATURATION','CCD_IMAGE_SATURATION',int),
          ('DETECTOR_SN','DETECTOR_SN',int),
          ('PIXEL_SIZE','PIXEL_SIZE',float),
          ('OSC_START','OSC_START',float),
          ('DISTANCE',r'\nDISTANCE',float),
          ('WAVELENGTH',r'\nWAVELENGTH',float),
          ('BEAM_CENTER_X',r'\nBEAM_CENTER_X',float),
          ('BEAM_CENTER_Y',r'\nBEAM_CENTER_Y',float),
          ('OSC_RANGE','OSC_RANGE',float),
          ('TWOTHETA','TWOTHETA',float),
          ('BYTE_ORDER','BYTE_ORDER',str),
          ('AXIS','AXIS',str),
          ('PHI','PHI',float),
          ('OMEGA','OMEGA',float),
          ('DATE','DATE',str),
          ]
      if external_keys is not None:
          assert len(external_keys[0]) == 3
          library = library + external_keys

      for tag,search,datatype in library:
          pattern = re.compile(search+'='+r'(.*);')
          matches = pattern.findall(self.header.decode("ascii"))
          if len(matches)>0:
            if matches[-1] not in [None,"None","unknown"]:
              self.parameters[tag] = datatype(matches[-1])
      if "TWOTHETA" not in self.parameters:
        self.parameters["TWOTHETA"]=0.0


  def dataoffset(self):
    return self.parameters['HEADER_BYTES']

  def integerdepth(self):
    return 2

  #ADSC Quantum 210, ALS beamline 5.0.2; SUN: unsigned short big endian
  #ADSC Quantum 4R, ALS beamline 5.0.3; WINDOWS: unsigned short little endian
  def getEndian(self):
    if self.parameters['BYTE_ORDER'].lower().find('big')>=0:
      return 1 #big_endian
    else:
      return 0 #little_endian

if __name__=='__main__':
  import sys
  i = sys.argv[1]
  a = ADSCImage(i)
  a.read()
  print(a.linearintdata)
  print(a.linearintdata.size())
  print(a.linearintdata.accessor().grid())
  from labelit.detectors.jpeg import JPEGImage
  j = JPEGImage(a)
  j.calcimage()
  j.write(sys.argv[2])


 *******************************************************************************


 *******************************************************************************
iotbx/detectors/adsc_minicbf.py
from __future__ import absolute_import, division, print_function

import copy
import re

from iotbx.detectors.detectorbase import DetectorImageBase
from iotbx.detectors import ImageException

class ADSCHF4MImage(DetectorImageBase):
  def __init__(self,filename):
    DetectorImageBase.__init__(self,filename)
    self.vendortype = "ADSC"
    self.vendor_specific_null_value = -1

  mandatory_keys = ['PIXEL_SIZE_UNITS', 'DISTANCE', 'PHI', 'WAVELENGTH', 'SIZE1',
    'SIZE2', 'TWOTHETA', 'DISTANCE_UNITS', 'OSC_RANGE',
    'BEAM_CENTER_X', 'BEAM_CENTER_Y',
    'CCD_IMAGE_SATURATION', 'OSC_START', 'DETECTOR_SN', 'PIXEL_SIZE',
    'AXIS']

  def fileLength(self):
    raise ImageException("file length not computed for miniCBF")

  def getEndian(self):
    raise ImageException("endian-ness not computed for miniCBF")

  def endian_swap_required(self):
    return False

  def read(self,algorithm="buffer_based"):
    self.readHeader()
    if self.linearintdata != None and\
      self.linearintdata.size()==self.size1*self.size2:
      #data has already been read
      return
    if self.bin==2:
      raise ImageException("2-by-2 binning not supported for miniCBF")
    try:
      from cbflib_adaptbx import cbf_binary_adaptor # optional package
      self.adaptor = cbf_binary_adaptor(self.filename)

      # assert algorithm in ["cbflib","cbflib_optimized","buffer_based"]

      data = self.adaptor.uncompress_implementation( algorithm
             ).uncompress_data(self.size1,self.size2)
      self.bin_safe_set_data( data )

    except Exception:
      raise ImageException("unable to read miniCBF data; contact authors")

  def readHeader(self,maxlength=12288): # usually 1024 is OK; require 12288 for ID19
    if not self.parameters:
      with open(self.filename, "rb") as fh:
        rawdata = fh.read(maxlength)

      # The tag _array_data.header_convention "SLS_1.0" could be with/without quotes "..."
      SLS_match = re.findall(b'_array_data.header_convention[ "]*SLS', rawdata)
      PILATUS_match = re.findall(b'_array_data.header_convention[ "]*PILATUS', rawdata)
      #assert len(SLS_match) + len(PILATUS_match)>=1

      # read SLS header
      headeropen = rawdata.index(b"_array_data.header_contents")
      headerclose = rawdata.index(b"_array_data.data")
      self.header = rawdata[headeropen+1:headerclose].decode("latin-1")
      self.headerlines = [x.strip() for x in self.header.split("#")]
      character_filter = re.compile(r"[\r\n,\(\);]")
      self.headerlines = [character_filter.sub("", x) for x in self.headerlines]

      self.parameters={'CCD_IMAGE_SATURATION':65535}
      for tag,search,idx,datatype in [
          ('CCD_IMAGE_SATURATION','Count_cutoff',1,int),
          ('DETECTOR_SN','Detector:',-1,str),
          ('PIXEL_SIZE','Pixel_size',1,float),
          ('PIXEL_SIZE_UNITS','Pixel_size',2,str),
          ('OSC_START','Start_angle',1,float),
          ('DISTANCE','Detector_distance',1,float),
          ('DISTANCE_UNITS','Detector_distance',2,str),
          ('WAVELENGTH',r'Wavelength',1,float),
          ('BEAM_CENTER_X',r'Beam_xy',1,float),
          ('BEAM_CENTER_Y',r'Beam_xy',2,float),
          ('OSC_RANGE','Angle_increment',1,float),
          ('TWOTHETA','Detector_2theta',1,float),
          ('AXIS','Oscillation_axis',1,str),
          ('PHI','Phi',1,float),
          ('OMEGA','OMEGA',1,float),
          ('DATE','DATE',1,str),
          ]:
          for line in self.headerlines:
            if line.find(search)==0:
              if idx==-1:
                tokens=line.split(" ")
                self.parameters[tag] = " ".join(tokens[1:len(tokens)])
                break
              self.parameters[tag] = datatype(line.split(" ")[idx])
              break
      #unit fixes
      self.parameters['DISTANCE']*={
                  'mm':1,'m':1000}[self.parameters['DISTANCE_UNITS']]
      self.parameters['PIXEL_SIZE']*={
                  'mm':1,'m':1000}[self.parameters['PIXEL_SIZE_UNITS']]
      self.parameters['BEAM_CENTER_X']*=self.parameters['PIXEL_SIZE']
      self.parameters['BEAM_CENTER_Y']*=self.parameters['PIXEL_SIZE']
      # x,y beam center swap; do not know why
      swp = copy.copy(self.parameters['BEAM_CENTER_X'])
      self.parameters['BEAM_CENTER_X']=copy.copy(self.parameters['BEAM_CENTER_Y'])
      self.parameters['BEAM_CENTER_Y']=copy.copy(swp)

      # read array size
      header_lines = []
      found_array_data_data = False
      for record in rawdata.decode("latin-1").splitlines():
        if "_array_data.data" in record:
          found_array_data_data = True
        elif not found_array_data_data:
          continue
        elif len(record.strip()) == 0:
          # http://sourceforge.net/apps/trac/cbflib/wiki/ARRAY_DATA%20Category
          #    In an imgCIF file, the encoded binary data begins after
          #    the empty line terminating the header.
          break
        header_lines.append(record)
      self.header = "\n".join(header_lines)
      self.headerlines = [x.strip() for x in self.header.split("\n")]
      self.headerlines = [character_filter.sub("", x) for x in self.headerlines]

      for tag,search,idx,datatype in [
          ('SIZE1','X-Binary-Size-Second-Dimension',-1,int),
          ('SIZE2','X-Binary-Size-Fastest-Dimension',-1,int),
          ]:
          for line in self.headerlines:
            if line.find(search)==0:
              self.parameters[tag] = datatype(line.split(" ")[idx])
              break
      if self.size1==2290 and self.size2==2100:
        self.vendortype="ADSC-HF4M"

if __name__=='__main__':
  import sys
  i = sys.argv[1]
  a = ADSCHF4MImage(i)
  a.read()
  print(a)
  print(a.parameters)
  print(a.rawdata, len(a.rawdata), a.size1*a.size2)


 *******************************************************************************


 *******************************************************************************
iotbx/detectors/adsc_module.py
from __future__ import absolute_import, division, print_function
import copy
from iotbx.detectors.adsc import ADSCImage
from scitbx.array_family import flex
from iotbx.detectors import image_divider

def ADSC_module_from_file_url(url):
  #backward compatibility with Python 2.5
  try: from urlparse import parse_qs
  except Exception: from cgi import parse_qs

  from urlparse import urlparse
  parsed = urlparse(url)
  assert parsed.scheme == "file"
  file = parsed.path.split("?")[0]
  if file == parsed.path:
    return ADSCImage(file)
  qs = parse_qs(parsed.path.split("?")[1])
  sliceindex = int(qs["slice"][0])
  object = ADSCImage(file)
  object.readHeader()
  return ADSC_module_from_object_and_slicenumber(object,sliceindex)

def ADSC_module_from_object_and_slicenumber(object,moduleindex):
  P = ADSCModule()
  P.moduleindex = moduleindex
  P.object = object
  P.copy_common_attributes_from_parent_instance(P.object)
  P.vendortype = "ADSC module"
  P.parameters = P.module_parameters(P.object)
  P.slice_callback = P.slice_callback_with_object_data
  return P

class ADSCModule(ADSCImage):
  def __init__(self):
    self.already_read_data = False

  def module_parameters(self,object):
    param = object.parameters
    #unchanged parameters first:
    result = {}
    for item in ['DISTANCE', 'PHI', 'WAVELENGTH',
    'TWOTHETA', 'OSC_RANGE',
    'CCD_IMAGE_SATURATION', 'OSC_START', 'DETECTOR_SN', 'PIXEL_SIZE',
    ]:
      result[item]=copy.copy(param[item])

    #other parameters keep a record of parent settings; but child
    # settings are deduced on-the-fly once the data are read.
    for item in ['SIZE1','SIZE2','BEAM_CENTER_X','BEAM_CENTER_Y',
    ]:
      result["PARENT_"+item]=copy.copy(param[item])

    #the final parameters require a knowledge of the module boundaries.
    # In this implementation, these boundaries are determined on the fly
    # from the raw data, implying an up-front file read.
    # The only way to avoid this (not implemented here) is to encode
    # the vendor- & model-specific module boundaries.

    object.read()
    nullvalue = vendor_specific_null_value(object)
    ID = image_divider(data = object.linearintdata, nullvalue=nullvalue)
    print("module slow interval",ID.tile_slow_interval(self.moduleindex).first, ID.tile_slow_interval(self.moduleindex).last)
    print("module fast interval",ID.tile_fast_interval(self.moduleindex).first, ID.tile_fast_interval(self.moduleindex).last)
    result["SIZE1"] = ID.tile_slow_interval(self.moduleindex).size()
    result["SIZE2"] = ID.tile_fast_interval(self.moduleindex).size()
    print("size1",result["SIZE1"],"size2",result["SIZE2"])
    return result

  def set_beam_center_convention(self,beam_center_convention):

    #previously part of the module_parameters function
    #from iotbx.detectors.context.config_detector import beam_center_convention_from_image_object
    #beam_center_convention = beam_center_convention_from_image_object(object)
    print("CC",beam_center_convention)
    assert self.object.beam_center_reference_frame == "instrument"
    nullvalue = self.object.vendor_specific_null_value
    ID = image_divider(data = self.object.linearintdata, nullvalue=nullvalue)
    from iotbx.detectors.beam_center_convention import convert_beam_instrument_to_module
    self.parameters['BEAM_CENTER_X'],self.parameters['BEAM_CENTER_Y'] = convert_beam_instrument_to_module(
      self.object, ID, self.moduleindex, beam_center_convention)
    self.beam_center_reference_frame = "imageblock"
    self.beam_center_convention = beam_center_convention
    print("old beam center",self.object.parameters['BEAM_CENTER_X'],self.object.parameters['BEAM_CENTER_Y'])
    print("for module",   self.moduleindex,"beam x,y is", self.parameters['BEAM_CENTER_X'],self.parameters['BEAM_CENTER_Y'])


  def slice_callback_with_high_performance_http_data(self):
    BYU = self.object.read()
    linearintdata = flex.int_from_byte_str(BYU)
    provisional_size = linearintdata.size()
    assert provisional_size == self.size1*self.size2
    print("size assertion OK",provisional_size)
    linearintdata.reshape(flex.grid((self.size1,self.size2)))
    del self.object #once the data are copied, close the stream
    return linearintdata

  def slice_callback_with_object_data(self):
    self.object.read()
    nullvalue = self.object.vendor_specific_null_value
    ID = image_divider(data = self.object.linearintdata, nullvalue=nullvalue)
    assert 0 <= self.moduleindex < ID.module_count()
    new_data_array = ID.tile_data(self.moduleindex)
    if self.object.linearintdata.__dict__.get("bin2by2")==True:
      new_data_array.bin2by2=True
    del self.object #once the data are copied, no need to keep the original
    return new_data_array

  def read(self):
    if self.already_read_data: return
    self.bin_safe_set_data(self.slice_callback())
    self.already_read_data = True

if __name__=='__main__':
  import sys
  sliceidx=4
  full_path_to_file = sys.argv[1]
  a = ADSCImage(full_path_to_file)
  a.read()
  print(a)
  print(a.parameters)
  print(a.rawdata, len(a.rawdata), a.size1*a.size2)
  for dataitem in ['bin', 'filename', 'header', 'headerlines', 'linearintdata', 'parameters', 'vendortype']:
    print(dataitem, end=' ')
    exec("print a.%s"%dataitem)
  print(ADSC_module_from_object_and_slicenumber(a,sliceidx))

  P = ADSC_module_from_file_url(url="file://%s?slice=%d"%(full_path_to_file,sliceidx))
  print("file://%s?slice=%d"%(full_path_to_file,sliceidx))
  print(P)


 *******************************************************************************


 *******************************************************************************
iotbx/detectors/beam_center_convention.py
"""
The position of the direct beam center is assumed to be stated in mm throughout.
The beam center is defined as the position of the beam when the twotheta setting is 0.0 degrees.

We consider two reference frames here:
  1) Instrument reference frame: Coordinate system tied to the face of the detector instrument.
    It is assumed that a) the origin of this coordinate system is located at one of the four corners of
                          the image block.
                       b) the origin is in the center of the corner pixel.
  2) Imageblock reference frame: Coordinate system tied to the slow (x) and fast (y) directions in the
     pixel data.

There are eight possible relationships between the instrument and imageblock frames.  The instrument origin
  can be in any of the four corners of the image; and for each of these, the x and y axes can be either the
  fast or slow dimensions of the image.

It is assumed that the image header gives the beam position in the instrument reference frame.
Diffraction is obviously observed and recorded in the image reference frame.
This module provides a function, convert_beam_instrument_to_imageblock() to give the corresponding
  beam position in the imageblock reference frame.  The Image Object attribute "beam_center_reference_frame"
  defines in which reference frame the beam is expressed.
"""
from __future__ import absolute_import, division, print_function
from six.moves import range

class beam_center_convention_definitions:
  def __init__(self,beam_center_convention):
    #axis reverse flag:
    #     False:  slow position determines BEAM_CENTER_X. fast position determines BEAM_CENTER_Y
    #     True:   fast position determines BEAM_CENTER_X. slow position determines BEAM_CENTER_Y
    self.ar_flag = bool(beam_center_convention & 1)

    #y-direction reverse flag:
    #     False:  BEAM_CENTER_Y increases in same direction as data pixel index
    #     True:   BEAM_CENTER_Y increases in opposite direction as data pixel index
    self.yr_flag = bool(beam_center_convention & 2)

    #x-direction reverse flag:
    #     False:  BEAM_CENTER_X increases in same direction as data pixel index
    #     True:   BEAM_CENTER_X increases in opposite direction as data pixel index
    self.xr_flag = bool(beam_center_convention & 4)

  def explicit_formulae(self):
    if beam_center_convention==0:  beam_center_in_pixels = slow,fast
    if beam_center_convention==1:  beam_center_in_pixels = fast,slow
    if beam_center_convention==2:  beam_center_in_pixels = slow,fastwidth - fast
    if beam_center_convention==3:  beam_center_in_pixels = fast,slowwidth - slow
    if beam_center_convention==4:  beam_center_in_pixels = slowwidth - slow,fast
    if beam_center_convention==5:  beam_center_in_pixels = fastwidth - fast,slow
    if beam_center_convention==6:  beam_center_in_pixels = slowwidth - slow,fastwidth - fast
    if beam_center_convention==7:  beam_center_in_pixels = fastwidth - fast,slowwidth - slow

class instrument_to_imageblock_relation:
  #while intended for conversion from instrument frame to imageblock frame, formulae will probably work
  # in both directions.
  def __init__(self,imageobject):
    self.p = imageobject.pixel_size
    self.input_beam_mm = (imageobject.beamx,imageobject.beamy)
    width_in_pixels = (imageobject.size1,imageobject.size2)
    self.width_in_mm = (width_in_pixels[0]*self.p,width_in_pixels[1]*self.p)

  def select(self,beam_center_convention):
    C = beam_center_convention_definitions(beam_center_convention)
    output_beam_mm = []
    for outidx in [0,1]:
      srcidx = int((not bool(outidx)) != (not C.ar_flag)) # is xor(outidx, ar_flag)
      direction_reverse = [C.xr_flag,C.yr_flag][outidx]
      imageblock_mm = self.input_beam_mm[srcidx]
      if direction_reverse:
        imageblock_mm = self.width_in_mm[srcidx] - imageblock_mm
      output_beam_mm.append(imageblock_mm)
    return tuple(output_beam_mm)

def convert_beam_instrument_to_imageblock(imageobject,beam_center_convention,force=False):
  if not force and imageobject.beam_center_reference_frame != "instrument": return
  converter = instrument_to_imageblock_relation(imageobject)
  imageobject.parameters['BEAM_CENTER_X'],\
  imageobject.parameters['BEAM_CENTER_Y']= converter.select(beam_center_convention)
  imageobject.beam_center_reference_frame = "imageblock"
  imageobject.beam_center_convention = beam_center_convention

def convert_beam_instrument_to_module(input_image,image_divider,moduleindex,
                                       beam_center_convention):
    # caller assures input is in instrument reference frame; uses return value in image reference frame
    input_parameters = input_image.parameters
    C = beam_center_convention_definitions(beam_center_convention)

    input_beam_mm = (input_parameters['BEAM_CENTER_X'],input_parameters['BEAM_CENTER_Y'])
    converter = instrument_to_imageblock_relation(input_image)
    input_imageblock_beam_mm = converter.select(beam_center_convention)

    input_imageblock_beam_pixels = [
      a/input_parameters["PIXEL_SIZE"] for a in input_imageblock_beam_mm]

    #correct for the origin of the slice
    module_beam_pixels = [
      input_imageblock_beam_pixels[0] - image_divider.tile_slow_interval(moduleindex).first,
      input_imageblock_beam_pixels[1] - image_divider.tile_fast_interval(moduleindex).first
    ]

    module_beam_mm = [a * input_parameters["PIXEL_SIZE"] for a in module_beam_pixels]
    return tuple(module_beam_mm)

if __name__=="__main__":
  from libtbx import adopt_init_args
  from libtbx.test_utils import show_diff
  from six.moves import StringIO
  class test_tile:
    def __init__(self,first,last):
      adopt_init_args(self, locals())
    def size(self): return self.last-self.first+1
  class test_divider:
    def tile_slow_interval(self,idx):
      if idx in [0,1,2]:  return test_tile(4,2043)
      if idx in [3,4,5]:  return test_tile(2052,4091)
      if idx in [6,7,8]:  return test_tile(4100,6139)
    def tile_fast_interval(self,idx):
      if idx in [0,3,6]:  return test_tile(4,2043)
      if idx in [1,4,7]:  return test_tile(2052,4091)
      if idx in [2,5,8]:  return test_tile(4100,6139)
  input_parameters = {'BEAM_CENTER_X':154.9,'BEAM_CENTER_Y':148.7,
                      'SIZE1':6144,'SIZE2':6144,'PIXEL_SIZE':0.051294}
  from iotbx.detectors.detectorbase import DetectorImageBase
  input_object = DetectorImageBase("no file")
  input_object.parameters = input_parameters
  ID = test_divider()
  S = StringIO()
  for convention in range(8):
    for moduleidx in range(9):
      B = convert_beam_instrument_to_module(input_object,ID,moduleidx,convention)
      print("(%.1f,%.1f)"%(B[0],B[1]), end=' ', file=S)
    print(file=S)
  assert not show_diff(S.getvalue(),
"""(154.7,148.5) (154.7,43.4) (154.7,-61.6) (49.6,148.5) (49.6,43.4) (49.6,-61.6) (-55.4,148.5) (-55.4,43.4) (-55.4,-61.6)
(148.5,154.7) (148.5,49.6) (148.5,-55.4) (43.4,154.7) (43.4,49.6) (43.4,-55.4) (-61.6,154.7) (-61.6,49.6) (-61.6,-55.4)
(154.7,166.2) (154.7,61.2) (154.7,-43.9) (49.6,166.2) (49.6,61.2) (49.6,-43.9) (-55.4,166.2) (-55.4,61.2) (-55.4,-43.9)
(148.5,160.0) (148.5,55.0) (148.5,-50.1) (43.4,160.0) (43.4,55.0) (43.4,-50.1) (-61.6,160.0) (-61.6,55.0) (-61.6,-50.1)
(160.0,148.5) (160.0,43.4) (160.0,-61.6) (55.0,148.5) (55.0,43.4) (55.0,-61.6) (-50.1,148.5) (-50.1,43.4) (-50.1,-61.6)
(166.2,154.7) (166.2,49.6) (166.2,-55.4) (61.2,154.7) (61.2,49.6) (61.2,-55.4) (-43.9,154.7) (-43.9,49.6) (-43.9,-55.4)
(160.0,166.2) (160.0,61.2) (160.0,-43.9) (55.0,166.2) (55.0,61.2) (55.0,-43.9) (-50.1,166.2) (-50.1,61.2) (-50.1,-43.9)
(166.2,160.0) (166.2,55.0) (166.2,-50.1) (61.2,160.0) (61.2,55.0) (61.2,-50.1) (-43.9,160.0) (-43.9,55.0) (-43.9,-50.1)
""")
  print("OK")


 *******************************************************************************


 *******************************************************************************
iotbx/detectors/bruker.py
from __future__ import absolute_import, division, print_function
import math
from iotbx.detectors import Bruker_base
from iotbx.detectors.detectorbase import DetectorImageBase

class BrukerImage(DetectorImageBase):
  def __init__(self,filename):
    self.filename=filename
    self.bruker = Bruker_base(filename)
    self.bin=1
    self.bin_safe_set_data(self.bruker.linearintdata())
    self.vendortype = "Bruker Proteus CCD"
    self.readHeader()

  def readHeader(self):
    self.parameters={
      # image saturation not available.  take the maximum pixel instead
      'CCD_IMAGE_SATURATION': self.bruker.ccd_image_saturation,
      'SIZE1':1024,
      'SIZE2':1024,
      'PIXEL_SIZE':self.bruker.pixel_size,
      'OSC_START':self.bruker.osc_start,
      'DISTANCE':10.0*(self.bruker.distance_cm+self.bruker.distance_delta),
      'WAVELENGTH':self.bruker.wavelength,

      #first attempt formula to support two theta offset.
      # But the resulting distl_overlay did not put the beam in exactly
      # the right position.
      'BEAM_CENTER_X':self.bruker.pixel_size*self.bruker.centerx_pix +
                      10.*self.bruker.distance_cm *
                      math.tan (math.pi*self.bruker.twotheta/180.),
      'BEAM_CENTER_Y':self.bruker.pixel_size*self.bruker.centery_pix,
      'OSC_RANGE':self.bruker.osc_range,
      'TWOTHETA':self.bruker.twotheta,
      'DETECTOR_SN':0,
    }

  def read(self):
    return

if __name__=="__main__":
  import sys
  if len(sys.argv)<2:
    pass#file = "/net/cci/dials/from_adder/sauter/rawdata/mckee/bruker/lyziph6p5_01_0001.sfrm"
  else:
    file = sys.argv[1]
  B = BrukerImage(file)
  print("B.vendortype,B.saturation",B.vendortype,B.saturation)
  print("pixel size",B.pixel_size)
  print("osc start",B.osc_start, end=' ')
  print("distance",B.distance)
  print("wavelength",B.wavelength)
  print("beamx",B.beamx)
  print("beamy",B.beamy)
  print("deltaphi",B.deltaphi)
  print("twotheta",B.twotheta)
  #for item in B.linearintdata:
  #  print item


 *******************************************************************************


 *******************************************************************************
iotbx/detectors/cbf.py
from __future__ import absolute_import, division, print_function
from iotbx.detectors.detectorbase import DetectorImageBase
from iotbx.detectors.marIP import MARIPImage

class CBFImage(MARIPImage):
  def __init__(self,filename):
    DetectorImageBase.__init__(self,filename)
    try:
      from cbflib_adaptbx import CBFAdaptor # optional package
      self.adaptor = CBFAdaptor(filename)
      # for testing only:
      '''
      self.adaptor.read_header()
      print "     size1:", self.adaptor.size1()
      print "     size2:", self.adaptor.size2()
      print "  overload:", self.adaptor.overload()
      print "wavelength:", self.adaptor.wavelength()
      print "  distance:", self.adaptor.distance()
      print "pixel size:", self.adaptor.pixel_size()
      print "     beamx:", self.adaptor.beam_index_slow*self.adaptor.pixel_size()
      print "     beamy:", self.adaptor.beam_index_fast*self.adaptor.pixel_size()
      print " osc_start:", self.adaptor.osc_start()
      print " osc_range:", self.adaptor.osc_range()
      print self.adaptor.raster_description()
      flags = self.adaptor.transform_flags()
      print flags.transpose, flags.reverse_slow, flags.reverse_fast
      '''
    except Exception:
      from iotbx.detectors.marIP import NullAdaptor
      self.adaptor = NullAdaptor()
    self.vendortype = "CBF"
    self.readHeader()
    try:
      self.vendor_specific_null_value = int(self.adaptor.undefined_value())
    except RuntimeError as e:
      self.vendor_specific_null_value = 0

  def beam_center_slow(self):
    return self.adaptor.beam_index_slow*self.adaptor.pixel_size()

  def beam_center_fast(self):
    return self.adaptor.beam_index_fast*self.adaptor.pixel_size()

  def read(self):
    T = self.adaptor.transform_flags()

    #future: use these tests to trigger in-place column & row swaps
    assert T.reverse_fast == False
    assert T.reverse_slow == False

    from cbflib_adaptbx import cbf_binary_adaptor
    M = cbf_binary_adaptor( self.filename )
    data = M.uncompress_implementation("buffer_based").uncompress_data()
    if T.transpose==True:
      #very inefficient; 0.09 sec for 3K x 3K uncompression
      #              yet 0.54 sec for in-place transpose
      # other options not tried: a) alloc & set new matrix; b) use data as is
      data.matrix_transpose_in_place()

    self.bin_safe_set_data(data)

if __name__=='__main__':
  import sys
  C = CBFImage(sys.argv[1])


 *******************************************************************************


 *******************************************************************************
iotbx/detectors/context/__init__.py


 *******************************************************************************


 *******************************************************************************
iotbx/detectors/context/camera_convention.py
from __future__ import absolute_import, division, print_function
from scitbx.array_family import flex

"Transformation specifically meant for use by spotfinder & labelit"
def Cameras(index):
  '''All ADSC detectors: index=1
         MarCCD:         index=1
  '''
  from cctbx.array_family import flex
  if index==0:  return flex.double((1,0,0,1))
  if index==1:  return flex.double((-1,0,0,-1))
  if index==2:  return flex.double((-1,0,0,1))
  if index==3:  return flex.double((1,0,0,-1))
  if index==4:  return flex.double((0,1,1,0))
  if index==5:  return flex.double((0,-1,-1,0))
  if index==6:  return flex.double((0,1,-1,0))
  if index==7:  return flex.double((0,-1,1,0))


 *******************************************************************************


 *******************************************************************************
iotbx/detectors/context/config_detector.py
from __future__ import absolute_import, division, print_function
import re,time,copy

#------------------ALS-----------------------
'''
Prior to March 2004:
Beamline 5.0.1 ADSC Q4U  s/n 401
Beamline 5.0.2 ADSC Q210 s/n 447
Beamline 5.0.3 ADSC Q4R  s/n 423
Beamline 8.2.1 ADSC Q210 s/n 445
Beamline 8.2.2 ADSC Q315 s/n 905
After March 2004:
Beamline 5.0.1 ADSC Q210 s/n 447
Beamline 5.0.2 ADSC Q315 s/n 913
Beamline 5.0.3 ADSC Q4R  s/n 423
Beamline 8.2.1 ADSC Q210 s/n 445
Beamline 8.2.1 ADSC Q315 s/n 925
Beamline 8.2.2 ADSC Q315 s/n 905
Beamline 8.3.1 ADSC Q210 s/n 442
Beamline 12.3.2 ADSC Q315 s/n 907
After Aug 2006:
Beamline 5.0.3 ADSC Q315r  s/n 923
Installed Nov 2009:
Beamline 5.0.1 ADSC Q315r s/n 931
As of March 2012:
5.0.1 don't know if it is 926 or 931 ???
5.0.2 s/n 913; s/n 442 is the service spare
5.0.3 s/n 923
8.2.1 s/n 925
8.2.2 s/n 905
8.3.1 s/n 907;
'''

def known_als_detectors(iobj):
  #new implementation.  Return [iobj.serial_number] if detector is at ALS
  sn = iobj.serial_number
  if sn in [401,423,445,905,913,923,925,913]:  return [sn]
  if sn == 447 and ADSC447_at_ALS(iobj): return [sn]
  else: return []

known_als831_detectors = [907,442,926]

def als_beam_rules(iobj): #take an ADSC image object

  beam_center_convention = 1
  #The only use for this default of 1 is for the swap_beam simulation
  # in the pipeline server.  All other known ALS images will adhere to
  # the convention of 0, if the following DENZO overrides are used:

  for tag,search,datatype in [
          ('BEAM_CENTER_X','DENZO_BEAM_CENTER_X',float),
          ('BEAM_CENTER_Y','DENZO_BEAM_CENTER_Y',float),
          ('BEAM_CENTER_X','DENZO_XBEAM',float),
          ('BEAM_CENTER_Y','DENZO_YBEAM',float),
          ]:
          bytes_encoded_search = (search+'='+r'(.*);').encode()
          pattern = re.compile(bytes_encoded_search) # python3 compatible
          matches = pattern.findall(iobj.header)
          if len(matches)>0:
            beam_center_convention = 0
            iobj.parameters[tag] = datatype(matches[-1])
  return beam_center_convention

def als_beamline831_rules(iobj):
  beam_center_convention = 5
  return beam_center_convention

#-------------------Other synchrotrons-------------------------
'''
Denzo = header has special records for Denzo beam
Beam = 0 is LABELIT default
Regression = there is a corresponding entry in LABELIT regression suite

Successful Indexing:
ADSC s/n 402  Web Denzo Beam5 Regression
ADSC s/n 403  SSRL BL11-3 Beam5
ADSC s/n 406  CHESS F1, Marian Szebenyi, reverse phi, Beam5
ADSC s/n 409  CHESS F1 upper upside-down detector, NOT reverse phi, Beam5
ADSC s/n 410  NSLS X9B
ADSC s/n 411  SSRL BL1-5 Beam5
ADSC s/n 413  Web [ESRF ID14-2 Q4] Beam0 Beam_very_close_to_center Regression
ADSC Q4  414  CHESS F3, Marian Szebenyi, reverse phi or Pringle-Shen, Beam 5
ADSC s/n 415  APS: BIOCARS 14-BM-C Beam0 (Web case 83995)
ADSC s/n 418  NSLS X4A
ADSC s/n 420  Web [ESRF ID14-3 Q4R] Beam0 Regression
ADSC Q4R 428  Web Beam0 Regression ESRF
ADSC s/n 429  Web Beam0 (no strong evidence for 0) Regression
ADSC 210 441  CHESS A1, Marian Szebenyi, reverse phi after 10/2004, Beam5
ADSC 210 443  APS IMCA-CAT 17ID, Xaiochun Yang, Beam0
ADSC 210 446  BNL X6A, Vivian Stojanoff, Beam5
ADSC 270 447  Photon Factory KEK BL-5A, Yusuke Yamada
ADSC 210 448  CHESS F2, Marian Szebenyi, reverse phi, Beam5
ADSC 270 449  Photon Factory KEK AR-NW12A, Yusuke Yamada
ADSC 210r 457 Australian Synchrotron Tom Caradoc-Davies, reverse phi, beam on center
ASSC 210r 458 APS 19-BM, installed Jan 2009
ADSC 270 471  CHESS F1, Marian Szebenyi, reverse phi, Beam5
ADSC 270 472  Photon Factory KEK AR-NE3A, Yusuke Yamada
ADSC 270 474  Photon Factory KEK BL-1A, Yusuke Yamada
ADSC 210 901  SSRL BL9-2 Beam5
ADSC s/n 902  SSRL BL11-1 Beam5
ADSC s/n 903  Web unknown location Beam5
ADSC s/n 904  APS NE-CAT [24-ID-C or 24-BM-B] Beam0 (JCSG 2003Nov beam not really tested; close to center)
ADSC s/n 906  BNL X29. convention not certain...no calibration dataset.
ADSC s/n 908  SSRL BL9-1 Beam5
ADSC s/n 910  APS BioCARS 14-BM-C installed before August 2007.
ADSC s/n 911  APS [24-ID-C or 24-BM-B] (NE-CAT), Beam0
ADSC s/n 912  Photon Factory KEK BL-17A, Yusuke Yamada
ADSC s/n 914  APS ID19
ADSC s/n 916  APS 24-ID-E (NE-CAT), Beam0
ADSC s/n 917  [ESRF ID23-1 Q315]
ADSC s/n 918  [ESRF ID29   Q315]
ADSC s/n 919  [ESRF ID14-4 Q315]
ADSC s/n 924  ESRF BM30:A French Beamline. Reverse Phi
ADSC 315r 928 Australian Synchrotron 3ID microfocus, Tom Caradoc-Davis, reverse phi, beam on center
              Looking from the source towards the detector our goniometer is horizontal
              and on the left-hand side of the beam. Facing the goniometer, a positive
              rotation turns the air-bearing clockwise.
ADSC 315r 933 AichiSR BL2S1, Nobuhisa Watanabe
Unsuccessful:
ADSC s/n 415  Web Regression Submitted virus images have wrong center - off by mm
                  Impossible to determine convention.  Subsequent images indexed
                  correctly; see above.
ADSC s/n 416  Web Beam center off by many cm; no indexing possible
ADSC s/n 444  Web Error upon image read
ADSC s/n 444  [ESRF ID14-1 Q210]
ADSC s/n 910  APS ID19 Beam0 beam perfectly centered, but it looks like
                  the phi axis is vertical. Not tested. Beginning in 2005,
                  ID19 had detector s/n 914.

Olof Svenson: all ESRF beamlines have the same coordinate system.
detector serial numbes listed at
http://www.esrf.fr/UsersAndScience/Experiments/MX/Software/PXSOFT/Denzo/
ID23-2 Mar 225, serial #5
ID13   Mar 133, serial #8
'''

def ADSC910_at_BioCARS(iobj):
  if iobj.serial_number != 910: return False
  record_date = iobj.parameters["DATE"]
  record_tse = time.mktime(time.strptime(record_date))
  #pending further information, assume 910 at BioCARS beginning in 2007
  cutoff_this = time.mktime(time.strptime("Mon Jan 01 00:00:00 2007"))
  return record_tse > cutoff_this

def ADSC447_at_ALS(iobj):
  if iobj.serial_number != 447: raise Exception("wrong sn")
  record_date = iobj.parameters["DATE"]
  try:
    record_tse = time.mktime(time.strptime(record_date))
  except ValueError:
    record_tse = time.mktime(time.strptime(record_date,"%a %b %d %H:%M:%S %Z %Y"))
  cutoff_447 = time.mktime(time.strptime("Sun Nov 01 00:00:00 2009"))
  return record_tse < cutoff_447

def other_beamlines(iobj,passthru_convention):
  beam5 = [402,403,406,409,410,411,414,418,441,446,448,471,901,902,903,908]
  beam0 = [413,415,420,428,429,443,444,457,458,904,914,916,917,918,919,924,928]
  KEK = [474,912,449,472]
  AichiSR = [933]

  if iobj.serial_number == 447:
    if not ADSC447_at_ALS(iobj):
      KEK.append(447)

  alld = beam5+beam0+known_als_detectors(iobj)+known_als831_detectors+KEK+AichiSR
  if iobj.serial_number in beam5:
    beam_center_convention = 5
  elif ADSC910_at_BioCARS(iobj):
    beam_center_convention = 0
  elif iobj.serial_number not in alld:
    print("WARNING (possibly fatal): new beamline; coordinate system unknown. Please contact the authors")
    beam_center_convention = passthru_convention
  else:
    beam_center_convention = passthru_convention
  return beam_center_convention

reference_information_ADSC_detectors = [
{'type':'Q4U', 'pixels_unbinned':10616832, 'pixels_binned':2654208},
{'type':'Q4R', 'pixels_unbinned':10616832, 'pixels_binned':2654208},
{'type':'Q210', 'pixels_unbinned':33554432, 'pixels_binned':8388608},
{'type':'Q315', 'pixels_unbinned':75497472, 'pixels_binned':18874368},
]

def set_convention(value,phil_params):
  if phil_params.convention_override != None:
     phil_params.spot_convention = copy.copy(
      phil_params.convention_override)
  else:
    phil_params.spot_convention = value

def beam_center_convention_from_image_object(imageobject,phil_params):

    if imageobject.vendortype == "ADSC":
      if imageobject.serial_number in known_als_detectors(imageobject):
        beam_center_convention = als_beam_rules(imageobject)
      else:
        beam_center_convention = 0
      set_convention(0,phil_params)
      if imageobject.serial_number in known_als831_detectors:
        beam_center_convention = als_beamline831_rules(imageobject)

      beam_center_convention = other_beamlines(imageobject,
        passthru_convention = beam_center_convention)

    elif imageobject.vendortype == "SMV(Generic)":
      beam_center_convention = 0
      set_convention(0,phil_params)

    elif imageobject.vendortype == "CBF":
      beam_center_convention = 0
      set_convention(0,phil_params)

    elif imageobject.vendortype == "MacScience":
      beam_center_convention = 0
      set_convention(0,phil_params)

    elif imageobject.vendortype == "Bruker Proteus CCD":
      beam_center_convention = 0
      set_convention(0,phil_params)

    elif imageobject.vendortype == "RigakuSaturn":
      beam_center_convention = 5
      set_convention(0,phil_params)

    elif imageobject.vendortype=="MARCCD":
      '''Explanation: there are only two test datasets:
         /net/adder/raid1/sauter/marccd/brunzelle  4 5 6 (serial#=='1')
         /net/adder/raid1/sauter/marccd/flav  1 3 (no serial #)
           For orientation, When looking at the detector from the source,
           the beamstop shadow comes in from the right of the image
           and the beam is about 15 pixels below the center.
           This is a mosaic image from our 225cm 3x3 detector - It is 3072x3072
           pixels.The format is exactly the same as the 2k marCCD images -
           just more pixels. The crystals is flavodoxin and the images were
           taken at the ESRF BM14 by Martin Walsh
         ...listed with the beam_center conventions that support these data.
         Have to choose one, so choose 1.  Later figure out if these
         were collected at different beamlines'''
      beam_center_convention = 1
      set_convention(0,phil_params)

      '''For SSRL's MarCCD, serial number 11, there is a different beam
      convention.  We assume here SSRL has the only MarCCD with this
      serial number.  There isn't any information from other beamlines
      to tell if the SSRL convention is general.'''
      try:
        from labelit.detectors.mar import CompleteMarHeader
        C = CompleteMarHeader(imageobject)
        #C.dumpHeader()
        if C.get_serial_number() in ['11']:
          beam_center_convention = 5
          #print "Using SSRL Mar CCD beam_center system"
      except Exception:pass

    elif imageobject.vendortype=="MARIP":
      beam_center_convention = 0
      set_convention(0,phil_params)
      #but note coordinate transformation going to mosflm
    elif imageobject.vendortype=="RAXIS":
      beam_center_convention = 2
      set_convention(2,phil_params)

    # XXX This is completely fictional!
    elif imageobject.vendortype=="npy_raw":
      beam_center_convention = 2
      set_convention(0,phil_params)

    # CBF format images are in EIGER test sets currently
    elif imageobject.vendortype=="EIGER":
      beam_center_convention = 0
      set_convention(0,phil_params)

    elif imageobject.vendortype=="Pilatus Single Module": # provisional support for EDF; refactor for upcoming dxtbx migration
      beam_center_convention = 0
      set_convention(0,phil_params)

    elif imageobject.vendortype == "ADSC-HF4M":
       beam_center_convention = 0
       set_convention(0,phil_params)

    else: beam_center_convention = None

    if imageobject.vendortype == "CBF" and \
       imageobject.size1==2527 and imageobject.size2==2463:
       imageobject.vendortype = "Pilatus-6M"
    if imageobject.vendortype == "Pilatus" and \
       imageobject.size1==1679 and imageobject.size2==1475:
       imageobject.vendortype = "Pilatus-2M"
    if imageobject.vendortype == "Pilatus" and \
       imageobject.size1==619 and imageobject.size2==487:
       imageobject.vendortype = "Pilatus-300K"
    if imageobject.vendortype == "Pilatus" and \
       imageobject.size1==195 and imageobject.size2==487:
       imageobject.vendortype = "Pilatus-100K"
    if imageobject.vendortype == "Pilatus" and \
       imageobject.size1==407 and imageobject.size2==487:
       imageobject.vendortype = "Pilatus-200K"
    if imageobject.vendortype in ["Pilatus-6M","Pilatus-2M","Pilatus-300K","Pilatus-100K",]:
       beam_center_convention = 0
       set_convention(0,phil_params)
       if phil_params.distl.minimum_signal_height==None:
          phil_params.distl.minimum_signal_height=2.5
       if phil_params.distl.minimum_spot_area==None or \
          phil_params.distl.minimum_spot_area > 5:
          phil_params.distl.minimum_spot_area=5
    if imageobject.vendortype in ["Eiger-16M","Eiger-9M","Eiger-4M","Eiger-1M","Eiger-500K",
                                  "Eiger2-16M","Eiger2-9M","Eiger2-4M","Eiger2-1M","Eiger2-500K"]:
       beam_center_convention = 0
       set_convention(0,phil_params)
       if phil_params.distl.minimum_signal_height==None:
          phil_params.distl.minimum_signal_height=4.0
       if phil_params.distl.minimum_spot_area==None:
          phil_params.distl.minimum_spot_area=5

    elif imageobject.vendortype == "Hamamatsu":
      beam_center_convention = 0
      set_convention(0,phil_params)

    if phil_params.distl.minimum_spot_area == None:
      phil_params.distl.minimum_spot_area = 10 # last-resort default formerly set in signal_strength.py

    assert beam_center_convention != None
    return beam_center_convention


 *******************************************************************************


 *******************************************************************************
iotbx/detectors/context/endstation.py
from __future__ import absolute_import, division, print_function
import math,time
from iotbx.detectors.context.camera_convention import Cameras
from iotbx.detectors.context.config_detector import ADSC910_at_BioCARS
import six

if six.PY3:
  def change_keys_to_strings(item):
    erase_keys = []
    for key in item:
      if isinstance(key,six.binary_type):
        erase_keys.append(key)
    for key in erase_keys:
      item[key.decode("UTF-8")]=item[key]
      del item[key]

class EndStation:
  def __init__(self):
    #set defaults
    self.mos = {}
    self.mos['mosflm_detector']="""#detector-take defaults\n"""
    self.mos['mosflm_beamline']=beamlines['ALS']
    self.set_camera_convention(1)
    self.set_rotation_axis("ROTATION HORIZ ANTI")

  def set_camera_convention(self,number):
    self.cam_con = Cameras(number)

  def camera_convention(self,):
    return self.cam_con

  def set_rotation_axis(self,axis):
    if type(axis) == type("string"):
      self.rot_axi = rotation_lookup[axis]
      self.rot_axi_string = axis
    else: #tuple type of 3-component vector elements of normalized direction
      self.rot_axi= axis

  def rotation_axis(self):
    return self.rot_axi

  def mosflm(self): return self.mos

beamlines = {
"ALS":
"""#beam
SYNCHROTRON POLARIZATION 0.9
DIVERGENCE 0.100 0.020
DISPERSION 0.0001
""",
"Australian":
"""#beam
SYNCHROTRON POLAR 0.9
DIVERGENCE 0.11 0.001
DISPER 0.001
""",
"CHESS":
"""#beam
SYNCHROTRON POLAR 0.89
DIVE 0.030 0.010
DISPER 0.0025
""",
"RAXIS":
"""#beam
""",
}

rotation_lookup = {
"ROTATION HORIZ ANTI":(0,1,0),
"ROTATION HORIZ CLOCK":(0,-1,0), #reverse phi
"ROTATION VERT ANTI":(-1,0,0),
"ROTATION VERT CLOCK":(1,0,0),
}
#ALS Quantum 4:
#omega 90 rotation horiz anti fast horiz origin ur rectang type adsc
#rmin 5 rmax 188.0 ymax 188.0 xmax 188.0 xscan 188.0 yscan 188.0

def EndStation_from_ImageObject(imageobject,phil_params):
  if six.PY3:
    change_keys_to_strings(imageobject.parameters)
  endstation = EndStation()
  endstation.set_camera_convention(1)
  endstation.set_rotation_axis("ROTATION HORIZ ANTI")

  if isinstance(imageobject.parameters.get("DETECTOR_SN",None),six.string_types) and \
    "S/N E-32-0105" in imageobject.parameters["DETECTOR_SN"]:
     # vertical goniometer axis at Max-IV
     endstation.set_rotation_axis("ROTATION VERT ANTI")
     print("MAX-IV Eiger 16M")

  if imageobject.vendortype == "Bruker Proteus CCD":
     endstation.set_rotation_axis("ROTATION VERT ANTI")
     print("BRUKER rotation", endstation.rot_axi)

  if imageobject.vendortype == "RAXIS":
     endstation.set_rotation_axis("ROTATION VERT CLOCK")

  #clockwise horizontal phi at most CHESS beamlines
  #also at Australian Synchrotron
  if imageobject.vendortype == "ADSC" and \
     imageobject.serial_number in [406,414,441,448,457,471,924,928]:
     endstation.set_rotation_axis("ROTATION HORIZ CLOCK")

  if imageobject.vendortype == "ADSC" and imageobject.serial_number == 910:
    if ADSC910_at_BioCARS(imageobject):
      endstation.set_rotation_axis("ROTATION HORIZ CLOCK")
    else:
      endstation.set_rotation_axis("ROTATION VERT ANTI") # just a hypothesis
  #vertical phi at APS 19ID
  if imageobject.vendortype == "ADSC" and \
     imageobject.serial_number in [914]:
     endstation.set_rotation_axis("ROTATION HORIZ CLOCK")

  if imageobject.vendortype == "RigakuSaturn":
     endstation.set_rotation_axis("ROTATION VERT ANTI")

  #change in phi axis rotation at CHESS A1
  if imageobject.vendortype == "ADSC" and \
     imageobject.serial_number in [441]:
       record_date = imageobject.parameters["DATE"]
       record_tse = time.mktime(time.strptime(record_date))
       cutoff_441 = time.mktime(time.strptime("Fri Oct 01 00:00:00 2004"))
       if record_tse < cutoff_441:
         endstation.set_rotation_axis("ROTATION HORIZ ANTI")

  # Special cases:  Pringle-Shen goniometer at CHESS F3
  if imageobject.vendortype == "ADSC" and \
     imageobject.serial_number in [414] and \
     phil_params.goniometer_rotation.lower().find(
       'pringle-shen')>=0 and \
     'AXIS' in imageobject.parameters and \
     imageobject.parameters['AXIS']=='phi':
       endstation.set_rotation_axis("ROTATION VERT ANTI")
       if 'OMEGA' in imageobject.parameters and \
          imageobject.parameters['OMEGA'] != 0.0 :
          omega = imageobject.parameters['OMEGA']
          from iotbx.detectors import rotate_vector_around
          endstation.set_rotation_axis(
             rotate_vector_around(endstation.rotation_axis(),
                        (0,1,0),-omega*math.pi/180.)
          )
  '''
  #tested for CHESS F1 s/n 406:
  SCANNER ROTATION HORIZ CLOCK FAST horizontal ORIGIN UR RECT TYPE ADSC
  LIMITS RMIN 5 RMAX 137.2 XMAX 96.5 YMAX 97.5 XSCAN 94.0 YSCAN 94.0
  BACKSTOP RADIUS 7.00 CENTRE 90.100 91.500
  ADCOFFSET 20
  NULLPIX 0
  GAIN 0.300
  #tested for CHESS F3 Pringle-Shen
  SCANNER ROTATION VERT ANTI FAST horizontal ORIGIN UR RECT TYPE ADSC
  LIMITS RMIN 5 RMAX 143.3 XMAX 106.8 YMAX 95.7 XSCAN 94.0 YSCAN 94.0
  BACKSTOP RADIUS 4.00 CENTRE 106.600 94.200
  GAIN 0.500
  BIAS 5
  '''
  if imageobject.vendortype == "MacScience":
    if imageobject.size1==3000:
      endstation.mos['mosflm_detector'] = """DETECTOR DIP2030\n"""
      endstation.set_rotation_axis("ROTATION HORIZ CLOCK")

  if imageobject.vendortype == "MARCCD":
   if imageobject.size1*imageobject.bin>=4096:
     parameters = {'sz' : imageobject.size1*imageobject.bin,
                   'pix': imageobject.pixel_size / imageobject.bin}
     parameters['scan']=parameters['pix']*parameters['sz']/2

     endstation.mos['mosflm_detector'] = """#MARCCD detector
LIMITS XMIN 0 XMAX xmax_tag YMIN 0 YMAX ymax_tag xscan %(scan)d yscan %(scan)d
SIZE %(sz)d %(sz)d HEADER 1 byte 4096
PIXEL %(pix)f
NULLPIX 0
#4Kx4K MarCCD format is unknown to MOSFLM, which apparently defaults
#the nullpix to 10.  This is a problem for weak-background images.
"""%parameters
     '''the correct xmax_tag and ymax_tag are added later in the interface module'''

   #identification of specific beamlines at Spring8 with Reversephi:
     # BL41XU Mar MX225HE--Serial number 40
     # BL32XU Mar MX225HE--Serial number 31
   # rely on detector serial number, uncertain how to decode geometric description
   # of rotation axis within the header.

   if imageobject.parameters["DETECTOR_SN"] in [7]:
     endstation.set_rotation_axis("ROTATION HORIZ CLOCK")
     endstation.mos['mosflm_detector'] = """
# Specific implementation for APS SER-CAT BM22, chi=180 setting
DETECTOR MARCCD
DETECTOR REVERSEPHI
SIZE 4096 4096
PIXEL 0.07324 0.07324
"""
     endstation.mos['mosflm_beamline'] = """GAIN 0.37
POLARISATION 0.99
DIVE 0.0001 0.00001
DISPER 0.0001
"""

   if imageobject.parameters["DETECTOR_SN"] in [31,40]:
     endstation.set_rotation_axis("ROTATION HORIZ CLOCK")
     endstation.mos['mosflm_detector'] = """
# Specific implementation for Spring8 BL41XU Mar MX225HE
DETECTOR MARCCD
DETECTOR REVERSEPHI
SIZE 3072 3072
PIXEL 0.07324 0.07324
LIMITS RMIN 2 RMAX 159.1 XMAX 159.1 YMAX 112.5 XSCAN 159.1 YSCAN 159.1
"""
     endstation.mos['mosflm_beamline'] = """GAIN 0.37
POLARISATION 0.99
DIVE 0.0001 0.00001
DISPER 0.0001
!offset 0.0 0.0
"""

  if imageobject.vendortype == "ADSC" and \
     endstation.rot_axi_string!="ROTATION HORIZ ANTI":

     # Rough idea of the MOSFLM LIMITS
     mmsize = imageobject.size1 * imageobject.pixel_size
     maxx = max( abs(imageobject.beamx-mmsize), abs(imageobject.beamx) )
     maxy = max( abs(imageobject.beamy-mmsize), abs(imageobject.beamy) )
     parameters = {'rotation': endstation.rot_axi_string,
                   'rmax': math.sqrt(maxx*maxx + maxy*maxy),
                   'xmax': maxx,
                   'ymax': maxy,
                   'xscan': mmsize/2.,
                   'yscan': mmsize/2.}
     if imageobject.serial_number in [457,928]: parameters['gain']=0.32
     else: parameters['gain']=0.30

     endstation.mos['mosflm_detector'] = """#detector
SCANNER %(rotation)s FAST horizontal ORIGIN UR RECT TYPE ADSC
LIMITS RMIN 5 RMAX %(rmax).1f XMAX %(xmax).1f YMAX %(ymax).1f XSCAN %(xscan).1f YSCAN %(yscan).1f
GAIN %(gain).3f
"""%parameters

     if imageobject.serial_number in [457,928]:
       endstation.mos['mosflm_beamline'] = beamlines['Australian']
     else:
       endstation.mos['mosflm_beamline'] = beamlines['CHESS']

  if imageobject.vendortype == "ADSC" and imageobject.serial_number == 910:
    if ADSC910_at_BioCARS(imageobject):
      endstation.mos['mosflm_detector']=endstation.mos['mosflm_detector']+\
       "#BIOCARS 14-BM-C S/N=910"

  if imageobject.vendortype in [ "RAXIS" ]:
     endstation.mos['mosflm_detector'] = """#detector
ADCOFFSet 5
"""
     if imageobject.serial_number.lower().find('dr. r-axis iv')==0:
       endstation.mos['mosflm_detector']=endstation.mos['mosflm_detector']+\
                                         'DETECTOR RAXISIV'
       #At least for MOSFLM 6.2.4, this seems to be important because it
       #  allows the program to accept large standard deviations for spots
       #  (above 32767).  Otherwise MOSFLM can crash with SERIOUS ERROR message.

     # Both DTrek and Raxis formats have "RAXIS" vendortype but only Raxis has "head" attribute
     if "head" in imageobject.__dict__ and \
        imageobject.head['Device'].lower().find('r-axis2')==0:
       endstation.mos['mosflm_detector']=endstation.mos['mosflm_detector']+\
                                         'detector raxis'
     endstation.mos['mosflm_beamline'] = beamlines['RAXIS']

  if imageobject.vendortype in [ "CBF" ]:
     endstation.mos['mosflm_detector'] = """#detector cbf"""

  if imageobject.vendortype in [ "Pilatus-6M" ]:
     endstation.mos['mosflm_detector'] = """#detector Pilatus-6M"""
     #flags mosflm interface to include the start & angle fix, mosflm 7.0.3 & below

  if imageobject.vendortype in [ "MARIP" ]:
     endstation.mos['mosflm_detector'] = """#detector
ADCOFFSet 5
"""#Just a guess: image plates require an offset to insure stability
   # over long integration sweeps.  Example: TM0064/11_20_01/1c3p3

  #additional information for universally specifying image size
  endstation.mos['mosflm_detector'] = endstation.mos['mosflm_detector'] + \
"\n#UIS_PIXEL %(pix)f\n#UIS_SIZE %(sz)d"%{
'sz' : imageobject.size1*imageobject.bin,
'pix': imageobject.pixel_size / imageobject.bin}
  return endstation


 *******************************************************************************


 *******************************************************************************
iotbx/detectors/context/endstation_max_iv_trial.py
from __future__ import absolute_import, division, print_function
import math,time
from iotbx.detectors.context.camera_convention import Cameras
from iotbx.detectors.context.config_detector import ADSC910_at_BioCARS

class EndStation:
  def __init__(self):
    #set defaults
    self.mos = {}
    self.mos['mosflm_detector']="""#detector-take defaults\n"""
    self.mos['mosflm_beamline']=beamlines['ALS']
    self.set_camera_convention(1)
    self.set_rotation_axis("ROTATION HORIZ ANTI")

  def set_camera_convention(self,number):
    self.cam_con = Cameras(number)

  def camera_convention(self,):
    return self.cam_con

  def set_rotation_axis(self,axis):
    if type(axis) == type("string"):
      self.rot_axi = rotation_lookup[axis]
      self.rot_axi_string = axis
    else: #tuple type of 3-component vector elements of normalized direction
      self.rot_axi= axis

  def rotation_axis(self):
    return self.rot_axi

  def mosflm(self): return self.mos

beamlines = {
"ALS":
"""#beam
SYNCHROTRON POLARIZATION 0.9
DIVERGENCE 0.100 0.020
DISPERSION 0.0001
""",
"Australian":
"""#beam
SYNCHROTRON POLAR 0.9
DIVERGENCE 0.11 0.001
DISPER 0.001
""",
"CHESS":
"""#beam
SYNCHROTRON POLAR 0.89
DIVE 0.030 0.010
DISPER 0.0025
""",
"RAXIS":
"""#beam
""",
}

rotation_lookup = {
"ROTATION HORIZ ANTI":(0,1,0),
"ROTATION HORIZ CLOCK":(0,-1,0), #reverse phi
"ROTATION VERT ANTI":(-1,0,0),
"ROTATION VERT CLOCK":(1,0,0),
}
#ALS Quantum 4:
#omega 90 rotation horiz anti fast horiz origin ur rectang type adsc
#rmin 5 rmax 188.0 ymax 188.0 xmax 188.0 xscan 188.0 yscan 188.0

def EndStation_from_ImageObject(imageobject,phil_params):
  endstation = EndStation()
  endstation.set_camera_convention(1)
  endstation.set_rotation_axis("ROTATION HORIZ ANTI")

  import six
  if isinstance(imageobject.parameters["DETECTOR_SN"],six.string_types) and \
    "S/N E-32-0105" in imageobject.parameters["DETECTOR_SN"]:
     # vertical goniometer axis at Max-IV
     endstation.set_rotation_axis("ROTATION VERT ANTI")
     print("MAX-IV Eiger 16M")
     endstation.mos['mosflm_detector'] = """
# Specific implementation for Max IV BioMAX
DETECTOR EIGE OMEGA 270
"""

  if imageobject.vendortype == "Bruker Proteus CCD":
     endstation.set_rotation_axis("ROTATION VERT ANTI")
     print("BRUKER rotation", endstation.rot_axi)

  if imageobject.vendortype == "RAXIS":
     endstation.set_rotation_axis("ROTATION VERT CLOCK")

  #clockwise horizontal phi at most CHESS beamlines
  #also at Australian Synchrotron
  if imageobject.vendortype == "ADSC" and \
     imageobject.serial_number in [406,414,441,448,457,471,924,928]:
     endstation.set_rotation_axis("ROTATION HORIZ CLOCK")

  if imageobject.vendortype == "ADSC" and imageobject.serial_number == 910:
    if ADSC910_at_BioCARS(imageobject):
      endstation.set_rotation_axis("ROTATION HORIZ CLOCK")
    else:
      endstation.set_rotation_axis("ROTATION VERT ANTI") # just a hypothesis
  #vertical phi at APS 19ID
  if imageobject.vendortype == "ADSC" and \
     imageobject.serial_number in [914]:
     endstation.set_rotation_axis("ROTATION HORIZ CLOCK")

  if imageobject.vendortype == "RigakuSaturn":
     endstation.set_rotation_axis("ROTATION VERT ANTI")

  #change in phi axis rotation at CHESS A1
  if imageobject.vendortype == "ADSC" and \
     imageobject.serial_number in [441]:
       record_date = imageobject.parameters["DATE"]
       record_tse = time.mktime(time.strptime(record_date))
       cutoff_441 = time.mktime(time.strptime("Fri Oct 01 00:00:00 2004"))
       if record_tse < cutoff_441:
         endstation.set_rotation_axis("ROTATION HORIZ ANTI")

  # Special cases:  Pringle-Shen goniometer at CHESS F3
  if imageobject.vendortype == "ADSC" and \
     imageobject.serial_number in [414] and \
     phil_params.goniometer_rotation.lower().find(
       'pringle-shen')>=0 and \
     'AXIS' in imageobject.parameters and \
     imageobject.parameters['AXIS']=='phi':
       endstation.set_rotation_axis("ROTATION VERT ANTI")
       if 'OMEGA' in imageobject.parameters and \
          imageobject.parameters['OMEGA'] != 0.0 :
          omega = imageobject.parameters['OMEGA']
          from iotbx.detectors import rotate_vector_around
          endstation.set_rotation_axis(
             rotate_vector_around(endstation.rotation_axis(),
                        (0,1,0),-omega*math.pi/180.)
          )
  '''
  #tested for CHESS F1 s/n 406:
  SCANNER ROTATION HORIZ CLOCK FAST horizontal ORIGIN UR RECT TYPE ADSC
  LIMITS RMIN 5 RMAX 137.2 XMAX 96.5 YMAX 97.5 XSCAN 94.0 YSCAN 94.0
  BACKSTOP RADIUS 7.00 CENTRE 90.100 91.500
  ADCOFFSET 20
  NULLPIX 0
  GAIN 0.300
  #tested for CHESS F3 Pringle-Shen
  SCANNER ROTATION VERT ANTI FAST horizontal ORIGIN UR RECT TYPE ADSC
  LIMITS RMIN 5 RMAX 143.3 XMAX 106.8 YMAX 95.7 XSCAN 94.0 YSCAN 94.0
  BACKSTOP RADIUS 4.00 CENTRE 106.600 94.200
  GAIN 0.500
  BIAS 5
  '''
  if imageobject.vendortype == "MacScience":
    if imageobject.size1==3000:
      endstation.mos['mosflm_detector'] = """DETECTOR DIP2030\n"""
      endstation.set_rotation_axis("ROTATION HORIZ CLOCK")

  if imageobject.vendortype == "MARCCD":
   if imageobject.size1*imageobject.bin>=4096:
     parameters = {'sz' : imageobject.size1*imageobject.bin,
                   'pix': imageobject.pixel_size / imageobject.bin}
     parameters['scan']=parameters['pix']*parameters['sz']/2

     endstation.mos['mosflm_detector'] = """#MARCCD detector
LIMITS XMIN 0 XMAX xmax_tag YMIN 0 YMAX ymax_tag xscan %(scan)d yscan %(scan)d
SIZE %(sz)d %(sz)d HEADER 1 byte 4096
PIXEL %(pix)f
NULLPIX 0
#4Kx4K MarCCD format is unknown to MOSFLM, which apparently defaults
#the nullpix to 10.  This is a problem for weak-background images.
"""%parameters
     '''the correct xmax_tag and ymax_tag are added later in the interface module'''

   #identification of specific beamlines at Spring8 with Reversephi:
     # BL41XU Mar MX225HE--Serial number 40
     # BL32XU Mar MX225HE--Serial number 31
   # rely on detector serial number, uncertain how to decode geometric description
   # of rotation axis within the header.

   if imageobject.parameters["DETECTOR_SN"] in [7]:
     endstation.set_rotation_axis("ROTATION HORIZ CLOCK")
     endstation.mos['mosflm_detector'] = """
# Specific implementation for APS SER-CAT BM22, chi=180 setting
DETECTOR MARCCD
DETECTOR REVERSEPHI
SIZE 4096 4096
PIXEL 0.07324 0.07324
"""
     endstation.mos['mosflm_beamline'] = """GAIN 0.37
POLARISATION 0.99
DIVE 0.0001 0.00001
DISPER 0.0001
"""

   if imageobject.parameters["DETECTOR_SN"] in [31,40]:
     endstation.set_rotation_axis("ROTATION HORIZ CLOCK")
     endstation.mos['mosflm_detector'] = """
# Specific implementation for Spring8 BL41XU Mar MX225HE
DETECTOR MARCCD
DETECTOR REVERSEPHI
SIZE 3072 3072
PIXEL 0.07324 0.07324
LIMITS RMIN 2 RMAX 159.1 XMAX 159.1 YMAX 112.5 XSCAN 159.1 YSCAN 159.1
"""
     endstation.mos['mosflm_beamline'] = """GAIN 0.37
POLARISATION 0.99
DIVE 0.0001 0.00001
DISPER 0.0001
!offset 0.0 0.0
"""

  if imageobject.vendortype == "ADSC" and \
     endstation.rot_axi_string!="ROTATION HORIZ ANTI":

     # Rough idea of the MOSFLM LIMITS
     mmsize = imageobject.size1 * imageobject.pixel_size
     maxx = max( abs(imageobject.beamx-mmsize), abs(imageobject.beamx) )
     maxy = max( abs(imageobject.beamy-mmsize), abs(imageobject.beamy) )
     parameters = {'rotation': endstation.rot_axi_string,
                   'rmax': math.sqrt(maxx*maxx + maxy*maxy),
                   'xmax': maxx,
                   'ymax': maxy,
                   'xscan': mmsize/2.,
                   'yscan': mmsize/2.}
     if imageobject.serial_number in [457,928]: parameters['gain']=0.32
     else: parameters['gain']=0.30

     endstation.mos['mosflm_detector'] = """#detector
SCANNER %(rotation)s FAST horizontal ORIGIN UR RECT TYPE ADSC
LIMITS RMIN 5 RMAX %(rmax).1f XMAX %(xmax).1f YMAX %(ymax).1f XSCAN %(xscan).1f YSCAN %(yscan).1f
GAIN %(gain).3f
"""%parameters

     if imageobject.serial_number in [457,928]:
       endstation.mos['mosflm_beamline'] = beamlines['Australian']
     else:
       endstation.mos['mosflm_beamline'] = beamlines['CHESS']

  if imageobject.vendortype == "ADSC" and imageobject.serial_number == 910:
    if ADSC910_at_BioCARS(imageobject):
      endstation.mos['mosflm_detector']=endstation.mos['mosflm_detector']+\
       "#BIOCARS 14-BM-C S/N=910"

  if imageobject.vendortype in [ "RAXIS" ]:
     endstation.mos['mosflm_detector'] = """#detector
ADCOFFSet 5
"""
     if imageobject.serial_number.lower().find('dr. r-axis iv')==0:
       endstation.mos['mosflm_detector']=endstation.mos['mosflm_detector']+\
                                         'DETECTOR RAXISIV'
       #At least for MOSFLM 6.2.4, this seems to be important because it
       #  allows the program to accept large standard deviations for spots
       #  (above 32767).  Otherwise MOSFLM can crash with SERIOUS ERROR message.

     # Both DTrek and Raxis formats have "RAXIS" vendortype but only Raxis has "head" attribute
     if "head" in imageobject.__dict__ and \
        imageobject.head['Device'].lower().find('r-axis2')==0:
       endstation.mos['mosflm_detector']=endstation.mos['mosflm_detector']+\
                                         'detector raxis'
     endstation.mos['mosflm_beamline'] = beamlines['RAXIS']

  if imageobject.vendortype in [ "CBF" ]:
     endstation.mos['mosflm_detector'] = """#detector cbf"""

  if imageobject.vendortype in [ "Pilatus-6M" ]:
     endstation.mos['mosflm_detector'] = """#detector Pilatus-6M"""
     #flags mosflm interface to include the start & angle fix, mosflm 7.0.3 & below

  if imageobject.vendortype in [ "MARIP" ]:
     endstation.mos['mosflm_detector'] = """#detector
ADCOFFSet 5
"""#Just a guess: image plates require an offset to insure stability
   # over long integration sweeps.  Example: TM0064/11_20_01/1c3p3

  #additional information for universally specifying image size
  endstation.mos['mosflm_detector'] = endstation.mos['mosflm_detector'] + \
"\n#UIS_PIXEL %(pix)f\n#UIS_SIZE %(sz)d"%{
'sz' : imageobject.size1*imageobject.bin,
'pix': imageobject.pixel_size / imageobject.bin}
  return endstation


 *******************************************************************************


 *******************************************************************************
iotbx/detectors/context/spot_xy_convention.py
'''
Determined 8/25/2004 for Q210 images collected at beamline 8.2.1.

The "film coordinates" needed for autoindexing are defined as follows:

MOSFLM, HKL2000 and LABELIT.  The origin is the top corner of the image
plate farthest from the storage ring, that is the top left corner when
viewed from the source.  X points down, Y points towards the storage
ring.

ADXV.  The origin is the bottom corner of the image plate farthest from
the storage ring, that is the bottom left corner when viewed from the
source.  X points toward the storage ring, Y points up.


The GUI view for each program is as follows:

HKL2000, LABELIT and ADXV.  The image emulates the view of an observer
standing at the source, i.e., with the storage ring closest to the right
edge of the image.

MOSFLM.  The image emulates the view of an observer looking toward the
source, and in addition, the image is rotated 90 clockwise.  Therefore,
the storage ring is nearest the top edge of the image, and the top edge
of the detector is at the right edge of the image.
'''
from __future__ import absolute_import, division, print_function

class spot_xy_convention:
  def __init__(self,W1,W2):
    self.W1 = W1; self.W2=W2

  def select(self,spot,index):
    if index%2==1: assert self.W1==self.W2
    if index==0:  return (spot[0],spot[1],spot[2])
    if index==1:  return (spot[1],spot[0],spot[2])
    if index==2:  return (self.W1-spot[0],spot[1],spot[2])
    if index==3:  return (spot[1],self.W1-spot[0],spot[2])
    if index==4:  return (spot[0],self.W2-spot[1],spot[2])
    if index==5:  return (self.W1-spot[1],spot[0],spot[2])
    if index==6:  return (self.W1-spot[0],self.W2-spot[1],spot[2])
    if index==7:  return (self.W1-spot[1],self.W1-spot[0],spot[2])
    if index==8:  return (spot[0],spot[1],-spot[2])
    if index==9:  return (spot[1],spot[0],-spot[2])
    if index==10:  return (self.W1-spot[0],spot[1],-spot[2])
    if index==11:  return (spot[1],self.W1-spot[0],-spot[2])
    if index==12:  return (spot[0],self.W2-spot[1],-spot[2])
    if index==13:  return (self.W1-spot[1],spot[0],-spot[2])
    if index==14:  return (self.W1-spot[0],self.W2-spot[1],-spot[2])
    if index==15:  return (self.W1-spot[1],self.W1-spot[0],-spot[2])
    raise

  def inverse(self,tspot):
    if self.index%2==1: assert self.W1==self.W2
    if self.index==0:  return (tspot[0],tspot[1],tspot[2])
    if self.index==1:  return (tspot[1],tspot[0],tspot[2])
    if self.index==2:  return (self.W1-tspot[0],tspot[1],tspot[2])
    if self.index==3:  return (tspot[1],self.W1-tspot[0],tspot[2])
    if self.index==4:  return (tspot[0],self.W2-tspot[1],tspot[2])
    if self.index==5:  return (self.W1-tspot[1],tspot[0],tspot[2])
    if self.index==6:  return (self.W1-tspot[0],self.W2-tspot[1],tspot[2])
    if self.index==7:  return (self.W1-tspot[1],self.W1-tspot[0],tspot[2])
    if self.index==8:  return (tspot[0],tspot[1],-tspot[2])
    if self.index==9:  return (tspot[1],tspot[0],-tspot[2])
    if self.index==10:  return (self.W1-tspot[0],tspot[1],-tspot[2])
    if self.index==11:  return (tspot[1],self.W1-tspot[0],-tspot[2])
    if self.index==12:  return (tspot[0],self.W2-tspot[1],-tspot[2])
    if self.index==13:  return (self.W1-tspot[1],tspot[0],-tspot[2])
    if self.index==14:  return (self.W1-tspot[0],self.W2-tspot[1],-tspot[2])
    if self.index==15:  return (self.W1-tspot[1],self.W1-tspot[0],-tspot[2])
    raise



 *******************************************************************************


 *******************************************************************************
iotbx/detectors/cspad_detector_formats.py
from __future__ import absolute_import, division, print_function

from calendar import timegm
from time import strptime
import six


def reverse_timestamp(timestamp):
  """Reverse of the xfel.cxi.cspad_ana.cspad_tbx.evt_timestamp()
  function.  From a string representation of a timestamp, @p
  timestamp, return the Unix time as a tuple of seconds and
  milliseconds.

  @param timestamp Human-readable ISO 8601 timestamp in string
                   representation
  @return          Tuple of the Unix time in seconds and milliseconds
  """

  tokens = timestamp.split('.')
  gmtime_tuple = strptime(tokens[0] + " UTC", '%Y-%m-%dT%H:%MZ%S %Z')
  return (timegm(gmtime_tuple), float(tokens[1]))


def _get_detector_format_version_dict():

  # Note: one must take daylight savings into account when defining
  # the cutoff-times for the LCLS runs.  The last shift of a run
  # generally ends at 09:00 local time the day after the last day of
  # the run.
  f = '%Y-%m-%d, %H:%M %Z'

  # We have no metrology for the first two LCLS runs
  # LCLS started operation Oct 1, 2009
  #timegm(strptime('2009-10-01, 16:00 UTC', f))
  # LCLS run 1: until Dec 17, 2009
  #timegm(strptime('2009-12-18, 17:00 UTC', f)):
  # LCLS run 2: until Sep 15, 2010
  #timegm(strptime('2010-09-16, 16:00 UTC', f)):

  return {
    'Sacla.MPCCD': {
      'address':'Sacla.MPCCD',
      'start_time':None,
      'end_time':None
    },
    'Sacla.MPCCD.8tile': {
      'address':'Sacla.MPCCD.8tile',
      'start_time':None,
      'end_time':None
    },
    # LCLS run 3: until Mar 8, 2011
    #
    # 'CXI 3.1' corresponds to a quirky, old, and deprecated version
    # of the cctbx.xfel pickle format.
    'CXI 3.2': {
      'address':'CxiDs1-0|Cspad-0',
      'start_time':timegm(strptime('2010-09-16, 16:00 UTC', f)),
      'end_time'  :timegm(strptime('2011-03-09, 17:00 UTC', f))
    },
    # LCLS run 4: until Oct 28, 2011
    'CXI 4.1': {
      'address':'CxiDs1-0|Cspad-0',
      'start_time':timegm(strptime('2011-03-09, 17:00 UTC', f)),
      'end_time'  :timegm(strptime('2011-10-29, 16:00 UTC', f))
    },
    # LCLS run 5: until May 30, 2012
    'CXI 5.1': {
      'address':'CxiDs1-0|Cspad-0',
      'start_time':timegm(strptime('2011-10-29, 16:00 UTC', f)),
      'end_time'  :timegm(strptime('2012-05-31, 16:00 UTC', f))
    },
    # LCLS run 6: until Dec 31, 2012
    'CXI 6.1': {
      'address':'CxiDs1-0|Cspad-0',
      'start_time':timegm(strptime('2012-05-31, 16:00 UTC', f)),
      'end_time'  :timegm(strptime('2013-01-01, 17:00 UTC', f))
    },
    # LCLS run 7: until Jul 31, 2013
    'CXI 7.1': {
      'address':'CxiDs1-0|Cspad-0',
      'start_time':timegm(strptime('2013-01-01, 17:00 UTC', f)),
      'end_time'  :timegm(strptime('2013-08-01, 16:00 UTC', f))
    },
    'CXI 7.d': {
      'address':'CxiDsd-0|Cspad-0',
      'start_time':timegm(strptime('2013-01-01, 17:00 UTC', f)),
      'end_time'  :timegm(strptime('2013-08-01, 16:00 UTC', f))
    },
    'XPP 7.1': {
      'address':'XppGon-0|Cspad-0',
      'start_time':timegm(strptime('2013-01-01, 17:00 UTC', f)),
      'end_time'  :timegm(strptime('2013-08-01, 16:00 UTC', f))
    },
    'XPP 7.marccd': {
      'address':'XppGon-0|marccd-0',
      'start_time':timegm(strptime('2013-01-01, 17:00 UTC', f)),
      'end_time'  :timegm(strptime('2013-08-01, 16:00 UTC', f))
    },
    # LCLS run 8: until Mar 27, 2014
    # CXI detector rebuilt in Jan 2014, before that use CXI 8.1 metrology.
    'CXI 8.1': {
      'address':'CxiDs1-0|Cspad-0',
      'start_time':timegm(strptime('2013-08-01, 16:00 UTC', f)),
      'end_time'  :timegm(strptime('2014-01-15, 17:00 UTC', f))
    },
    'CXI 8.2': {
      'address':'CxiDs1-0|Cspad-0',
      'start_time':timegm(strptime('2014-01-15, 17:00 UTC', f)),
      'end_time'  :timegm(strptime('2014-03-27, 16:00 UTC', f))
    },
    'CXI 8.d': {
      'address':'CxiDsd-0|Cspad-0',
      'start_time':timegm(strptime('2013-08-01, 16:00 UTC', f)),
      'end_time'  :timegm(strptime('2014-03-27, 16:00 UTC', f))
    },
    'XPP 8.1': {
      'address':'XppGon-0|Cspad-0',
      'start_time':timegm(strptime('2013-08-01, 16:00 UTC', f)),
      'end_time'  :timegm(strptime('2014-03-27, 16:00 UTC', f))
    },
    'XPP 8.marccd': {
      'address':'XppGon-0|marccd-0',
      'start_time':timegm(strptime('2013-08-01, 16:00 UTC', f)),
      'end_time'  :timegm(strptime('2014-03-27, 16:00 UTC', f))
    },
    'CXI 9.1': {
      'address':'CxiDs2-0|Cspad-0',
      'start_time':timegm(strptime('2014-03-27, 17:00 UTC', f)),
      'end_time'  :timegm(strptime('2014-08-05, 16:00 UTC', f))
    },
    'XPP 9.1': {
      'address':'XppGon-0|Cspad-0',
      'start_time':timegm(strptime('2014-03-27, 17:00 UTC', f)),
      'end_time'  :timegm(strptime('2014-08-05, 16:00 UTC', f))
    },
    'CXI 10.1': {
      'address':'CxiDs1-0|Cspad-0',
      'start_time':timegm(strptime('2014-10-15, 17:00 UTC', f)),
      'end_time'  :timegm(strptime('2015-03-25, 16:00 UTC', f))
    },
    'CXI 10.2': {
      'address':'CxiDs2-0|Cspad-0',
      'start_time':timegm(strptime('2014-10-15, 17:00 UTC', f)),
      'end_time'  :timegm(strptime('2015-03-25, 16:00 UTC', f))
    },
    'CXI 11.1': {
      'address':'CxiDs1-0|Cspad-0',
      'start_time':timegm(strptime('2015-03-26, 17:00 UTC', f)),
      'end_time'  :timegm(strptime('2015-05-05, 16:00 UTC', f))
    },
    'CXI 11.2': {
      'address':'CxiDs1-0|Cspad-0',
      'start_time':timegm(strptime('2015-05-05, 17:00 UTC', f)),
      'end_time'  :timegm(strptime('2015-08-11, 16:00 UTC', f))
    },
    'XPP 11.1': {
      'address':'XppGon-0|Cspad-0',
      'start_time':timegm(strptime('2015-03-26, 17:00 UTC', f)),
      'end_time'  :timegm(strptime('2015-08-11, 16:00 UTC', f))
    }
  }
_detector_format_version_dict = _get_detector_format_version_dict()


def detector_format_version(address, timestamp):
  """The detector_format_version() function returns a format version
  string appropriate for the detector whose address is given by @p
  address at the time @p time.

  @param address Full data source address of the DAQ device
  @param time    Time of the event, in number of seconds since
                 midnight, 1 January 1970 UTC (Unix time)
  @return        Format version string
  """

  if address is None:
    return None # time can be None if any time is valid for the format version

  ret = None
  for format_name, format in six.iteritems(_detector_format_version_dict):
    if address == format['address'] and \
       (format['start_time'] is None or timestamp >  format['start_time']) and \
       (format['end_time']   is None or timestamp <= format['end_time']):
      assert ret is None
      ret = format_name

  return ret


def address_and_timestamp_from_detector_format_version(format_name):
  """Reverse of detector_format_version()

  @param format_name detector format version requested
  @return tuple of address and end_time of this format version
  """

  if format_name in _detector_format_version_dict:
    return (_detector_format_version_dict[format_name]['address'],
            _detector_format_version_dict[format_name]['end_time'])
  return None, None


 *******************************************************************************


 *******************************************************************************
iotbx/detectors/detectorbase.py
from __future__ import absolute_import, division, print_function
from six.moves import range
import copy
from iotbx.detectors import ReadADSC
from scitbx.array_family import flex
import sys

class DetectorImageBase(object):
  def __init__(self,filename):
    self.filename=filename
    self.parameters=None
    self.linearintdata=None
    self.bin=1
    self.vendortype = "baseclass"
    self.beam_center_reference_frame = "instrument"#cf beam_center_convention.py
    self.beam_center_convention = None
    self.vendor_specific_null_value = 0

  def copy_common_attributes_from_parent_instance(self, parentobject):
    self.filename = copy.copy(parentobject.filename)
    self.bin = copy.copy(parentobject.bin)
    self.vendortype = copy.copy(parentobject.vendortype)
    self.beam_center_reference_frame = copy.copy(parentobject.beam_center_reference_frame)
    self.beam_center_convention = copy.copy(parentobject.beam_center_convention)
    self.header = copy.copy(parentobject.header)
    self.headerlines = copy.copy(parentobject.headerlines)

  def setBin(self,bin): #software binning.
                        # the only bin values supported are 1 & 2
    if self.bin!=1 or bin!=2: return
    if self.size1%bin!=0: return
    self.parameters['SIZE1']=self.parameters['SIZE1']//bin
    self.parameters['SIZE2']=self.parameters['SIZE2']//bin
    if 'CCD_IMAGE_SATURATION' in self.parameters:
      self.parameters['CCD_IMAGE_SATURATION']=self.parameters['CCD_IMAGE_SATURATION']*bin*bin
    self.parameters['PIXEL_SIZE']=self.parameters['PIXEL_SIZE']*bin
    self.bin = bin
    self.bin_safe_set_data(self.linearintdata)

  def set_beam_center_convention(self,beam_center_convention):
    from iotbx.detectors.beam_center_convention import convert_beam_instrument_to_imageblock
    convert_beam_instrument_to_imageblock(self,beam_center_convention)

  def fileLength(self):
    self.readHeader()
    return self.dataoffset()+self.size1*self.size2*self.integerdepth()
    # dataoffset() and integerdepth() must be defined in derived class
    # pure supposition:
    #  size1 corresponds to number of rows.  Columns are slow.
    #  size2 corresponds to number of columns.  Rows are fast.

  def getEndian(self):
    raise NotImplementedError # must be defined in derived class

  def endian_swap_required(self):
    data_is_big_endian = self.getEndian()
    import struct
    platform_is_big_endian = (
      struct.unpack('i',struct.pack('>i',3000))[0] == 3000
    )
    return data_is_big_endian != platform_is_big_endian

  def read(self):
    self.fileLength()
    self.bin_safe_set_data(
         ReadADSC(self.filename,self.dataoffset(),
         self.size1*self.bin,self.size2*self.bin,self.getEndian())
         )

  def bin_safe_set_data(self, new_data_array):
    #private interface for software binning 2 X 2.
    #  Any setting of linearintdata must be through this function
    #  self.bin==2: when data are read lazily, they must be binned
    #  new_data_array.bin2by2==True: the data have been binned
    if self.bin==2 and \
       new_data_array != None and\
       new_data_array.__dict__.get("bin2by2")!=True:
      from iotbx.detectors import Bin2_by_2
      self.linearintdata = Bin2_by_2(new_data_array)
      self.linearintdata.bin2by2 = True
    else:
      self.linearintdata = new_data_array

  def get_data_type(self):
    typehash = str(self.linearintdata.__class__)
    if typehash.find("int")>=0: return "int"
    elif typehash.find("double")>=0: return "double"

  def get_raw_data(self):
    return self.linearintdata

  def get_flex_image(self, binning=1, brightness=1.0, color_scheme=0):
    datatype = self.get_data_type()
    if datatype=="int":
      from iotbx.detectors import FlexImage
    elif datatype=="double":
      from iotbx.detectors import FlexImage_d as FlexImage
    return FlexImage(
      rawdata=self.linearintdata,
      binning=binning,
      vendortype=self.vendortype,
      brightness=brightness,
      saturation=int(getattr(self, "saturation", 65535)),
      color_scheme=color_scheme)

  data_types = dict( SIZE1=int, SIZE2=int, PIXEL_SIZE=float,
                     DISTANCE=float, TWOTHETA=float, OSC_RANGE=float,
                     OSC_START=float, PHI=float, WAVELENGTH=float,
                     BEAM_CENTER_X=float, BEAM_CENTER_Y=float,
                     CCD_IMAGE_SATURATION=int, DETECTOR_SN=str )

  def get_spotfinder(self,distl_params): #following heuristics_base.register_frames() example
    #application-specific adjustments to parameters
    #XXX this should probably be a deep copy of parameters.
    if distl_params.distl.res.inner!=None:
      distl_params.distl_lowres_limit = distl_params.distl.res.inner
    if distl_params.distl.res.outer!=None:
      distl_params.force_method2_resolution_limit = distl_params.distl.res.outer
      distl_params.distl_highres_limit = distl_params.distl.res.outer

    distl_params.distl_force_binning = False
    distl_params.distl_permit_binning = False
    distl_params.wedgelimit = 1
    distl_params.spotfinder_header_tests = False

    #unusual location for min spot area tests...
    from iotbx.detectors.context.config_detector import beam_center_convention_from_image_object
    beam_center_convention_from_image_object(self,distl_params)
    # end special min spot area treatment

    from spotfinder.applications.practical_heuristics import heuristics_base
    from spotfinder.diffraction.imagefiles import file_names
    class empty:pass
    E = empty()
    E.argv = ["Empty",self.filename]
    names = file_names(E)
    this_frame = names.frames()[0]
    process_dictionary = dict(twotheta = "%f"%self.twotheta,
       ybeam = "%f"%self.beamy,
       xbeam = "%f"%self.beamx,
       distance = "%f"%self.distance,
       wavelength = "%f"%self.wavelength,
       template = [item.template for item in names.FN if item.number==this_frame][0],
                              )
    Spotfinder = heuristics_base(process_dictionary,distl_params)
    Spotfinder.images[this_frame] = Spotfinder.oneImage(this_frame,
      Spotfinder.pd, self)
    Spotfinder.determine_maxcell(this_frame,Spotfinder.pd)
    Spotfinder.images[this_frame]['spotoutput']['relpath']=self.filename
    from spotfinder.applications.stats_distl import pretty_image_stats
    pretty_image_stats(Spotfinder,this_frame)
    return Spotfinder,this_frame

  def debug_write(self,fileout,mod_data=None):
    if "TWOTHETA" not in self.parameters:
      self.parameters["TWOTHETA"]=0.0
    from iotbx.detectors import ImageException
    try:
      endian = self.getEndian()
      if endian==1:
        self.parameters["BYTE_ORDER"]="big_endian"
      else:
        self.parameters["BYTE_ORDER"]="little_endian"
    except ImageException:
      endian = 0
      self.parameters["BYTE_ORDER"]="little_endian"

    if "DETECTOR_SN" in self.parameters:
      try:
        self.parameters["DETECTOR_SN"] = int(self.parameters["DETECTOR_SN"])
      except ValueError:
        self.parameters["DETECTOR_SN"] = 0
    else:
      self.parameters["DETECTOR_SN"] = 0

    #handle pilatus
    if self.parameters['SIZE1'] == 2527 and self.parameters['SIZE2'] == 2463:
      self.parameters['SIZE1'] = 2463
      self.parameters['SIZE2'] = 2527

    #handle eiger-1M
    if self.parameters['SIZE1'] == 1065 and self.parameters['SIZE2'] == 1030:
      self.parameters['SIZE1'] = 1030
      self.parameters['SIZE2'] = 1065

    #handle eiger-4M
    if self.parameters['SIZE1'] == 2167 and self.parameters['SIZE2'] == 2070:
      self.parameters['SIZE1'] = 2070
      self.parameters['SIZE2'] = 2167

    #handle eiger-9M
    if self.parameters['SIZE1'] == 3269 and self.parameters['SIZE2'] == 3110:
      self.parameters['SIZE1'] = 3110
      self.parameters['SIZE2'] = 3269

    #handle eiger-1M
    if self.parameters['SIZE1'] == 4371 and self.parameters['SIZE2'] == 4150:
      self.parameters['SIZE1'] = 4150
      self.parameters['SIZE2'] = 4371

    info = """{
HEADER_BYTES= 1024;
DIM=2;
BYTE_ORDER=%(BYTE_ORDER)s;
TYPE=unsigned_short;
SIZE1=%(SIZE1)4d;
SIZE2=%(SIZE2)4d;
PIXEL_SIZE=%(PIXEL_SIZE)8.6f;
TIME=0.000000;
DISTANCE=%(DISTANCE).2f;
TWOTHETA=%(TWOTHETA).2f;
PHI=%(OSC_START).3f;
OSC_START=%(OSC_START).3f;
OSC_RANGE=%(OSC_RANGE).3f;
WAVELENGTH=%(WAVELENGTH).6f;
BEAM_CENTER_X=%(BEAM_CENTER_X).2f;
BEAM_CENTER_Y=%(BEAM_CENTER_Y).2f;
CCD_IMAGE_SATURATION=65535;
DETECTOR_SN=%(DETECTOR_SN)d;
}\f"""%self.parameters
    with open(fileout, "w") as F:
      F.write(info)
      len_null=1024-len(info)
    with open(fileout, "ab") as F:
      F.write(b'\0'*len_null)

    from iotbx.detectors import WriteADSC
    if mod_data==None: mod_data=self.linearintdata
    if not mod_data.all_ge(0):
      from libtbx.utils import Sorry
      raise Sorry("Negative values not allowed when writing SMV")
    WriteADSC(fileout,mod_data,self.size1,self.size2,endian)

  def __getattr__(self, attr):
    # Returns the computed attribute value or raises an AttributeError
    # exception.  This method is only called when an attribute could
    # not be looked up in the usual places.
    if   attr=='size1' : return self.parameters['SIZE1']
    elif attr=='size2' : return self.parameters['SIZE2']
    elif attr=='npixels' : return self.parameters['SIZE1'] * self.parameters['SIZE2']
    elif attr=='saturation' : return self.parameters.get('CCD_IMAGE_SATURATION',65535)
    elif attr=='rawdata' : return self.linearintdata
    elif attr=='pixel_size' : return self.parameters['PIXEL_SIZE']
    elif attr=='osc_start' : return self.parameters.get('OSC_START',0.0)
    elif attr=='distance' : return self.parameters['DISTANCE']
    elif attr=='wavelength' : return self.parameters.get('WAVELENGTH',0.0)
    elif attr=='beamx' : return self.parameters['BEAM_CENTER_X']
    elif attr=='beamy' : return self.parameters['BEAM_CENTER_Y']
    elif attr=='deltaphi' : return self.parameters.get('OSC_RANGE',0.0)
    elif attr=='twotheta' : return self.parameters.get('TWOTHETA',0.0)
    elif attr=='serial_number' : return self.parameters['DETECTOR_SN']
    raise AttributeError

  def show_header(self, out=None):
    if (out is None):
      out = sys.stdout
    print("File:",self.filename, file=out)
    print("Number of pixels: slow=%d fast=%d"%(self.size1,self.size2), file=out)
    print("Pixel size: %f mm"%self.pixel_size, file=out)
    print("Saturation: %.0f"%self.saturation, file=out)
    print("Detector distance: %.2f mm"%self.distance, file=out)
    print("Detector 2theta swing: %.2f deg."%self.twotheta, file=out)
    print("Rotation start: %.2f deg."%self.osc_start, file=out)
    print("Rotation width: %.2f deg."%self.deltaphi, file=out)
    print("Beam center: x=%.2f mm  y=%.2f mm"%(self.beamx,self.beamy), file=out)
    print("Wavelength: %f Ang."%self.wavelength, file=out)

  # code developed for the image viewer. phil_parameters is a scope extract
  def initialize_viewer_properties(self,phil_parameters,verbose=True):

    self._invert_beam_center = False
    from iotbx.detectors.context.config_detector import \
      beam_center_convention_from_image_object
    bc = beam_center_convention_from_image_object(self,phil_parameters)
    if verbose:
      print("beam center convention: %d" % bc)
    # FIXME what about 2-4 & 6-7?
    if (bc == 0):
      self._invert_beam_center = True
      self._invert_y = True
    elif (bc == 1):
      self._invert_y = False
    elif (bc == 5):
      self._invert_y = True

    self.image_size_fast = self.size2 # width
    self.image_size_slow = self.size1 # height
    self.pixel_resolution = self.pixel_size

  def detector_coords_as_image_coords_float(self, x, y):
    """
    Convert absolute detector position (in mm) to floating-value image pixel coordinates.
    """
    dw = self.image_size_fast * self.pixel_resolution
    dh = self.image_size_slow * self.pixel_resolution
    x_frac = x / dw
    if (self._invert_y):
      y_frac = - ((y / dh) - 1.0)
    else :
      y_frac = y / dh
    return x_frac * self.image_size_fast, \
           y_frac * self.image_size_slow

  def detector_coords_as_image_coords(self, x, y):
    """
    Convert absolute detector position (in mm) to integer-value image pixel coordinates.
    """
    x_point,y_point = self.detector_coords_as_image_coords_float(x,y)
    return (int(x_point), int(y_point))

  def image_coords_as_detector_coords(self, x, y, readout=None):
    """
    Convert image pixel coordinates to absolute position on the detector
    (in mm).
    """
    dw = self.image_size_fast * self.pixel_resolution
    dh = self.image_size_slow * self.pixel_resolution
    x_frac = x / self.image_size_fast
    y_frac = y / self.image_size_slow
    x_detector = x_frac * dw
    if (self._invert_y):
      y_detector = (1.0 - y_frac) * dh
    else :
      y_detector = y_frac * dh
    return x_detector, y_detector

  def get_beam_center_mm(self):
    # FIXME Pilatus and ADSC images appear to have different conventions???
    if (self._invert_beam_center):
      center_x = self.beamy
      center_y = self.beamx
    else :
      center_x = self.beamx
      center_y = self.beamy
    return center_x, center_y

  def get_beam_center_pixels_fast_slow(self):
    center_x, center_y = self.get_beam_center_mm()
    return self.detector_coords_as_image_coords_float(center_x, center_y)

  def get_pixel_intensity(self,coords):
    try:
      return self.linearintdata[(int(coords[0]), int(coords[1]))]
    except IndexError:
      return None

  def get_tile_manager(self, phil):
    return tile_manager_base(
      phil,beam=(int(self.beamx/self.pixel_size),
                 int(self.beamy/self.pixel_size)),
           reference_image=self,
           size1=self.size1,
           size2=self.size2)


class tile_manager_base(object):

  def __init__(self, working_params, beam=None, size1=None, size2=None,
               reference_image=None):

    self.working_params = working_params
    self.beam = beam # direct beam position supplied as slow,fast pixels
    self.size1 = size1
    self.size2 = size2
    self.reference_image = reference_image

  def effective_tiling_as_flex_int(self, reapply_peripheral_margin=False,
                                   reference_image=None,
                                   encode_inactive_as_zeroes=False, **kwargs):
    """Some documentation goes here"""

    if reference_image is not None:
      self.reference_image = reference_image

    IT = self.effective_tiling_as_flex_int_impl(**kwargs)

    # Inactive margin around the edge of the sensor
    if reapply_peripheral_margin:
      try:    peripheral_margin = self.working_params.distl.peripheral_margin
      except Exception: peripheral_margin = 2
      for i in range(len(IT) // 4):
        IT[4 * i + 0] += peripheral_margin
        IT[4 * i + 1] += peripheral_margin
        IT[4 * i + 2] -= peripheral_margin
        IT[4 * i + 3] -= peripheral_margin

    if self.working_params.distl.tile_flags is not None and encode_inactive_as_zeroes is False:
      #sensors whose flags are set to zero are not analyzed by spotfinder
      #this returns an active list with fewer tiles
      expand_flags=[]
      for flag in self.working_params.distl.tile_flags :
        expand_flags=expand_flags + [flag]*4
      bool_flags = flex.bool( flex.int(expand_flags)==1 )
      return IT.select(bool_flags)

    if self.working_params.distl.tile_flags is not None and encode_inactive_as_zeroes is True:
      #sensors whose flags are set to zero are identified
      #this returns a same-length active list with some tiles set to 0,0,0,0
      expand_flags=[]
      for flag in self.working_params.distl.tile_flags :
        expand_flags=expand_flags + [flag]*4
      Zero_IT = flex.int()
      for idx in range(len(IT)):
        Zero_IT.append(expand_flags[idx]*IT[idx])
      return Zero_IT

    return IT

  def effective_tiling_as_flex_int_impl(self, **kwargs):
    assert self.reference_image is not None

    IT = flex.int()
    from iotbx.detectors import image_divider
    if self.reference_image.linearintdata is None:
      self.reference_image.readHeader()
      self.reference_image.read()
    null_value = self.reference_image.vendor_specific_null_value
    divider = image_divider(
      self.reference_image.linearintdata,
      null_value
      )

    for i in range(divider.module_count()):
      slow = divider.tile_slow_interval(i)
      fast = divider.tile_fast_interval(i)
      IT.append(slow.first)
      IT.append(fast.first)
      IT.append(slow.last+1)
      IT.append(fast.last+1)

    return IT


 *******************************************************************************


 *******************************************************************************
iotbx/detectors/dtrek.py
from __future__ import absolute_import, division, print_function
import re
import struct
from libtbx.test_utils import approx_equal
from scitbx.array_family import flex
from iotbx.detectors.detectorbase import DetectorImageBase
from iotbx.detectors import ReadDTrek

verbose=False

class DTREKImage(DetectorImageBase):
  """enforce dTREK Image Format v1.1, using Rigaku/MSC documentation."""

  def __init__(self,filename):
    DetectorImageBase.__init__(self,filename)
    self.vendortype = "RAXIS"

  def read_vendor_header(self):
    with open(self.filename, "rb") as fh:
      tag = fh.read(14)
      assert tag==b"{\nHEADER_BYTES"
      raw = [charac for charac in fh.read(6).decode("ascii", "replace") if charac.isdigit()]
      header_bytes = int("".join(raw))
      assert header_bytes%512==0
      fh.seek(0)
      padded_header = fh.read(header_bytes).decode("latin-1", "replace")
    unpadded_header = padded_header.rstrip()
    assert unpadded_header[0:2]=="{\n"
    assert unpadded_header[-2:]=="\n}"
    self.header = padded_header
    raw_key_values = unpadded_header[2:-3].split(";\n")
    self.headerlines = []; self.keys={}
    for i in raw_key_values:
      self.headerlines.append( i.split("=") )
      self.keys[self.headerlines[-1][0]]=self.headerlines[-1][1]

  def enforce_types(self):
    # mandate:=( regex_expression, python_type, length )
    # length:= 1: single variable
    #          0: unknown, could be multiple
    #         >1: definite multiple value
    self.enf= [("SIZE1",int,1),
               ("SIZE2",int,1),
               ("SATURATED_VALUE",int,1),
               ("DETECTOR_NAMES",str,0),
               (r"\n([0-9A-Za-z]+_DETECTOR_DIMENSIONS)",float,2),
               (r"\n([0-9A-Za-z]+_DETECTOR_SIZE)",float,2),
               (r"\n(ROTATION)=",float,10),
               (r"\n([0-9A-Za-z]+_GONIO_NAMES)",str,0),
               (r"\n([0-9A-Za-z]+_GONIO_UNITS)",str,0),
               (r"\n([0-9A-Za-z]+_GONIO_VALUES)",float,0),
               ("SOURCE_WAVELENGTH",float,2), #must be one wavelength
               (r"\n([0-9A-Za-z]+_SPATIAL_DISTORTION_TYPE)",str,1),
               (r"\n([0-9A-Za-z]+_SPATIAL_DISTORTION_INFO)",float,4),
               ("DETECTOR_TYPE",str,1),
               ("DATA_TYPE",str,1),
               ("BYTE_ORDER",str,1),
               ("RAXIS_COMPRESSION_RATIO",int,1),
               ("HEADER_BYTES",int,1),
              ]
    for mandate in self.enf:
      matches = re.findall(mandate[0], self.header)
      for match in matches:
        if verbose: print(match, end=' ')
        if mandate[2]==1:
          self.keys[match] = mandate[1](self.keys[match])
        else:
          all_tokens = self.tokenize(self.keys[match])
          all_values = [mandate[1](az) for az in all_tokens]
          if mandate[2] > 1: assert len(all_values)==mandate[2]
          self.keys[match] = all_values
        if verbose:
          print(self.keys[match], end=' ')
          print()

    for integer in ["SIZE1","SIZE2","SATURATED_VALUE"]:
      self.keys[integer]=int(self.keys[integer])

  def tokenize(self,string_):
    if type(string_) is list:
      return string_
    tokens = string_.split(" ")
    while "" in tokens: tokens.remove("")
    return tokens

  def generic_param_from_vendor_head(self):
      self.parameters={}
      if verbose:
       for i in self.headerlines:
        print("%29s"%i[0],self.keys[i[0]])
      # Note that SIZE1 is slow for ADSC/CBF but fast for RAXIS
      # Note that SIZE2 is fast for ADSC/CBF but slow for RAXIS
      self.parameters['SIZE1'] = self.keys["SIZE1"]
      self.parameters['SIZE2'] = self.keys["SIZE2"]
      self.parameters['CCD_IMAGE_SATURATION'] = self.keys["SATURATED_VALUE"]

      dname_prefix = self.keys["DETECTOR_NAMES"][0]

      sizes = flex.double(self.keys[dname_prefix+"DETECTOR_SIZE"])
      pixels = flex.double(self.keys[dname_prefix+"DETECTOR_DIMENSIONS"])
      pixel_sizes = sizes/pixels
      assert pixel_sizes[0]==pixel_sizes[1]
      self.parameters['PIXEL_SIZE'] = pixel_sizes[0]

      assert approx_equal(self.keys["ROTATION"][1]-self.keys["ROTATION"][0],
                          self.keys["ROTATION"][2])
      self.parameters['OSC_START'] = self.keys["ROTATION"][0]
      self.parameters['OSC_RANGE'] = self.keys["ROTATION"][2]

      distance_idx = self.keys[dname_prefix+"GONIO_NAMES"].index("Distance")
      assert self.keys[dname_prefix+"GONIO_UNITS"][distance_idx]=="mm"
      self.parameters['DISTANCE'] = self.keys[dname_prefix+"GONIO_VALUES"][distance_idx]

      assert self.keys["SOURCE_WAVELENGTH"][0]==1.0
      self.parameters['WAVELENGTH'] = self.keys["SOURCE_WAVELENGTH"][1]

      assert self.keys[dname_prefix+"SPATIAL_DISTORTION_TYPE"]=="Simple_spatial"
      check_pixel_sizes = flex.double(
        self.keys[dname_prefix+"SPATIAL_DISTORTION_INFO"][2:4])
      assert check_pixel_sizes == pixel_sizes
      beam_mm = flex.double(
        self.keys[dname_prefix+"SPATIAL_DISTORTION_INFO"][0:2])*pixel_sizes

      self.parameters['BEAM_CENTER_X'] = beam_mm[0]
      self.parameters['BEAM_CENTER_Y'] = beam_mm[1]
      tt_idx = self.keys[dname_prefix+"GONIO_NAMES"].index("2Theta")
      assert self.keys[dname_prefix+"GONIO_UNITS"][tt_idx]=="deg"
      self.parameters['TWOTHETA'] = self.keys[dname_prefix+"GONIO_VALUES"][tt_idx]
      if "DETECTOR_TYPE" in self.keys:
        self.parameters['DETECTOR_SN'] = self.keys["DETECTOR_TYPE"]
      elif (self.keys["DETECTOR_NAMES"][0] + "DETECTOR_IDENTIFICATION") in self.keys:
        self.parameters['DETECTOR_SN'] = self.keys[self.keys["DETECTOR_NAMES"][0] + "DETECTOR_IDENTIFICATION"]
      else:
        self.parameters['DETECTOR_SN'] = "No serial number"


  def readHeader(self,):
    if not self.parameters:
      self.read_vendor_header()
      self.enforce_types()
      self.generic_param_from_vendor_head()

  def getEndian(self):
    self.readHeader()
    if self.keys['BYTE_ORDER'].lower().find('big')>=0:
      return 1 #big_endian
    else:
      return 0 #little_endian

  def read(self):
    with open(self.filename, "rb") as fh:
      fh.seek(self.keys["HEADER_BYTES"])

      endian_code = {'little_endian':'<','big_endian':'>'}[self.keys["BYTE_ORDER"]]
      type_code = {'signed char':'b',
                   'unsigned char':'B',
                   'short int':'h',
                   'long int':'i',
                   'unsigned short int':'H',
                   'unsigned long int':'I',
                   'float IEEE':'f',
                  }[self.keys['Data_type']]
      type_size = {'b':1,'B':1,'h':2,'H':2,'i':4,'I':4,'f':4}[type_code]
      assert not type_code=="I" # for I, a flex.int() will exceed type limits
      array_size = self.parameters['SIZE1'] * self.parameters['SIZE2']
      rawdata = fh.read(array_size * type_size)
      #Python prototype--
      #doesn't handle raxis uncompression & is 10x slower than C++ version
      #uncoded_data = struct.unpack(endian_code+type_code*array_size,rawdata)
      #provisional_data = flex.int(uncoded_data)
      #provisional_data.reshape(flex.grid((self.parameters['SIZE2'],
      #                                  self.parameters['SIZE1'])))
      #self.bin_safe_set_data(provisional_data)
    self.bin_safe_set_data(
                ReadDTrek(raw=rawdata,type_code=type_code,
                          slow=self.parameters['SIZE2'],
                          fast=self.parameters['SIZE1'],
                          swap=self.endian_swap_required(),
                          uncompress=self.keys.get("RAXIS_COMPRESSION_RATIO",1)
                          ))


 *******************************************************************************


 *******************************************************************************
iotbx/detectors/edf.py
from __future__ import absolute_import, division, print_function
from six.moves import range
import struct
from scitbx.array_family import flex

def file_object_from_file_name(filename):
 return open(filename,"rb")

class EDFImage:
 def __init__(self,filename):
   self.obj = file_object_from_file_name(filename)
   self.headersize=0
   self.data_dimension=[0,0]
   self.parameters = {}
   self.header = []
   self.linearintdata = None

 def readHeader(self,external_keys=None):
   ptr = 0
   self.obj.seek(0)

   while True:
       newchr = self.obj.read(1).decode("latin-1")
       assert ord(newchr)!=0
       if ptr==1:  assert ord(self.header[0])==0x7b
       self.header.append(newchr)
       if newchr == "}": break
       ptr += 1

   assert self.obj.read(1).decode("latin-1") == "\n"
   self.headersize = 1 + len(self.header)
   assert self.headersize%512==0

   headertext = "".join(self.header[1:])
   headerpairs = headertext.split(";")

   for pair in headerpairs:
     bare = pair.strip()
     if bare.find("=")<0: continue
     key,value = bare.split("=")
     key,value = (key.strip(), value.strip())
     self.parameters[key]=value

   #forced typing of attributes:
   for attribute in ['run','Image','Size','Dim_1','Dim_2']:
     if attribute in self.parameters:
       self.parameters[attribute]=int(self.parameters[attribute])
   for attribute in ['count_time',]:
     if attribute in self.parameters:
       self.parameters[attribute]=float(self.parameters[attribute])

   self.type_size = {'SignedInteger':4, 'UnsignedShort':2, 'Float':4}[self.parameters['DataType']]
   assert self.parameters['Size']==self.parameters['Dim_1']*self.parameters['Dim_2']*self.type_size

 def read(self):
   self.obj.seek(self.headersize)

   endian_code = {'LowByteFirst':'<','HighByteFirst':'>'}[self.parameters['ByteOrder']]
   type_code = {'SignedInteger':'i','UnsignedInteger':'I','UnsignedShort':'H','Float':'f'}[self.parameters['DataType']]

   assert self.parameters['DataType'] == 'SignedInteger' or 'UnsignedShort'
   # if it is unsigned int, a flex.int() will exceed type limits

   rawdata = self.obj.read(self.parameters['Size'])
   uncoded_data = struct.unpack(endian_code+type_code*(self.parameters['Dim_2']*self.parameters['Dim_1']),rawdata)
   if type_code == 'f':
    self.linearintdata = flex.double(uncoded_data).iround()
   else:
    self.linearintdata = flex.int(uncoded_data)
   self.linearintdata.reshape(flex.grid((self.parameters['Dim_2'],self.parameters['Dim_1'])))

if __name__=="__main__":
 import sys
 P = EDFImage(sys.argv[1])
 P.readHeader()
 P.read()
 print("".join(P.header))
 print(P.parameters)
 count=0
 for ii in range( P.parameters["Dim_2"] ):
   for jj in range( P.parameters["Dim_1"] ):
      print(P.linearintdata[count])
      count += 1
   print()


 *******************************************************************************


 *******************************************************************************
iotbx/detectors/eiger.py
from __future__ import absolute_import, division, print_function
from iotbx.detectors.detectorbase import DetectorImageBase

vendortype_from_size = {
  (4150, 4371):"Eiger-16M",
  (3110, 3269):"Eiger-9M",
  (2070, 2167):"Eiger-4M",
  (1030, 1065):"Eiger-1M",
  (1030, 514): "Eiger-500K",
  (4148, 4362):"Eiger2-16M",
  (3108, 3262):"Eiger2-9M",
  (2068, 2162):"Eiger2-4M",
  (1028, 1062):"Eiger2-1M",
  (1028, 512): "Eiger2-500K",
}

class EIGERImage(DetectorImageBase):
  def __init__(self,filename,index=0):
    DetectorImageBase.__init__(self,filename)
    self.vendortype = "EigerX"
    self.supports_multiple_images = True
    self.img_number = index # 0-indexed to clients, internally 1-indexed
    if self.img_number == None: self.img_number = 0
    self.vendor_specific_null_value = -1

  mandatory_keys = ['PIXEL_SIZE_UNITS', 'DISTANCE', 'WAVELENGTH', 'SIZE1',
    'SIZE2', 'TWOTHETA', 'DISTANCE_UNITS', 'OSC_RANGE',
    'BEAM_CENTER_X', 'BEAM_CENTER_Y',
    'CCD_IMAGE_SATURATION', 'OSC_START', 'PIXEL_SIZE']

  def readHeader(self,dxtbx_instance,maxlength=12288): # XXX change maxlength!!!
    if not self.parameters:

      self.parameters={'CCD_IMAGE_SATURATION':65535}
      D = dxtbx_instance.get_detector()
      self.parameters['PIXEL_SIZE'] = D[0].get_pixel_size()[0]
      self.parameters['PIXEL_SIZE_UNITS'] = "mm"
      self.parameters['DISTANCE'] = D[0].get_distance()
      self.parameters['DISTANCE_UNITS'] = "mm"
      self.parameters['SIZE1'] = D[0].get_image_size()[1]
      self.parameters['SIZE2'] = D[0].get_image_size()[0]
      B = dxtbx_instance.get_beam()
      origin = D[0].get_origin()
      self.parameters['BEAM_CENTER_X'] = origin[1]
      self.parameters['BEAM_CENTER_Y'] = origin[0]
      self._image_count = dxtbx_instance.get_num_images()
      self.parameters['WAVELENGTH'] = B.get_wavelength()
      from scitbx.matrix import col
      detector_normal = D[0].get_normal()
      tt_angle_deg = col(detector_normal).angle(col((0.,0.,-1.)),deg=True)
      assert tt_angle_deg < 0.01 # assert normal to within 0.01 degree
      self.parameters['TWOTHETA'] = 0.0

      S = dxtbx_instance.get_scan()
      self.zero_oscillation = S.get_oscillation()[0]
      osc_range = S.get_oscillation()[1]
      self.parameters['OSC_RANGE'] = osc_range
      self.parameters['OSC_START'] = S.get_oscillation()[0] + self.img_number*osc_range

      #these parameters have to be set here due to the call to image_coords_as_detector_cords below.  they are normally set later.
      if "SIZE2" in self.parameters:
        self.image_size_fast = self.size2
      if "SIZE1" in self.parameters:
        self.image_size_slow = self.size1
      if "PIXEL_SIZE" in self.parameters:
        self.pixel_resolution = self.pixel_size

      self.vendortype = vendortype_from_size.get((self.size2,self.size1),self.vendortype)
      dxtbx_instance.vendortype = self.vendortype

  def read(self):
      image = self.get_raw_data_callback(self,self.img_number)
      self.bin_safe_set_data(image)

  def image_count(self):
    return self._image_count

  def integerdepth(self):
    return 2

  def dataoffset(self):
    return 0


 *******************************************************************************


 *******************************************************************************
iotbx/detectors/eiger_minicbf.py
from __future__ import absolute_import, division, print_function
import copy
import re
from iotbx.detectors.detectorbase import DetectorImageBase
from iotbx.detectors import ImageException
from iotbx.detectors.eiger import vendortype_from_size

class EigerCBFImage(DetectorImageBase):
  def __init__(self,filename):
    DetectorImageBase.__init__(self,filename)
    self.vendortype = "Eiger"
    self.vendor_specific_null_value = -1

  mandatory_keys = ['PIXEL_SIZE_UNITS', 'DISTANCE', 'PHI', 'WAVELENGTH', 'SIZE1',
    'SIZE2', 'TWOTHETA', 'DISTANCE_UNITS', 'OSC_RANGE',
    'BEAM_CENTER_X', 'BEAM_CENTER_Y',
    'CCD_IMAGE_SATURATION', 'OSC_START', 'DETECTOR_SN', 'PIXEL_SIZE',
    'AXIS']

  def fileLength(self):
    raise ImageException("file length not computed for miniCBF")

  def getEndian(self):
    raise ImageException("endian-ness not computed for miniCBF")

  def endian_swap_required(self):
    return False

  def read(self,algorithm="buffer_based"):
    self.readHeader()
    if self.linearintdata != None and\
      self.linearintdata.size()==self.size1*self.size2:
      #data has already been read
      return
    if self.bin==2:
      raise ImageException("2-by-2 binning not supported for miniCBF")
    try:
      from cbflib_adaptbx import cbf_binary_adaptor # optional package
      self.adaptor = cbf_binary_adaptor(self.filename)

      # assert algorithm in ["cbflib","cbflib_optimized","buffer_based"]

      data = self.adaptor.uncompress_implementation( algorithm
             ).uncompress_data(self.size1,self.size2)
      self.bin_safe_set_data( data )

    except Exception as e:
      raise ImageException(
          "unable to read miniCBF data; contact authors; error=\"%s\"" % \
          str(e).strip())

  def readHeader(self,maxlength=12288): # usually 1024 is OK; require 12288 for ID19
    if not self.parameters:
      with open(self.filename,"rb") as fh:
        rawdata = fh.read(maxlength)

      # The tag _array_data.header_convention "SLS_1.0" could be with/without quotes "..."
      # SLS_match = re.findall(b'_array_data.header_convention[ "]*SLS', rawdata)
      # PILATUS_match = re.findall(b'_array_data.header_convention[ "]*PILATUS', rawdata)
      #assert len(SLS_match) + len(PILATUS_match)>=1

      # read SLS header
      headeropen = rawdata.index(b"_array_data.header_contents")
      headerclose = rawdata.index(b"_array_data.data")
      self.header = rawdata[headeropen+1:headerclose].decode("latin-1")
      self.headerlines = [x.strip() for x in self.header.split("#")]
      character_filter = re.compile(r"[\r\n,\(\);]")
      self.headerlines = [character_filter.sub("", x) for x in self.headerlines]

      self.parameters={'CCD_IMAGE_SATURATION':65535}
      for tag,search,idx,datatype in [
          ('CCD_IMAGE_SATURATION','Count_cutoff',1,int),
          ('DETECTOR_SN','Detector:',-1,str),
          ('PIXEL_SIZE','Pixel_size',1,float),
          ('PIXEL_SIZE_UNITS','Pixel_size',2,str),
          ('OSC_START','Start_angle',1,float),
          ('DISTANCE','Detector_distance',1,float),
          ('DISTANCE_UNITS','Detector_distance',2,str),
          ('WAVELENGTH',r'Wavelength',1,float),
          ('BEAM_CENTER_X',r'Beam_xy',1,float),
          ('BEAM_CENTER_Y',r'Beam_xy',2,float),
          ('OSC_RANGE','Angle_increment',1,float),
          ('TWOTHETA','Detector_2theta',1,float),
          ('AXIS','Oscillation_axis',1,str),
          ('PHI','Phi',1,float),
          ('OMEGA','OMEGA',1,float),
          ('DATE','DATE',1,str),
          ]:
          for line in self.headerlines:
            if line.find(search)==0:
              if idx==-1:
                tokens=line.split(" ")
                self.parameters[tag] = " ".join(tokens[1:len(tokens)])
                break
              self.parameters[tag] = datatype(line.split(" ")[idx])
              break
      #unit fixes
      self.parameters['DISTANCE']*={
                  'mm':1,'m':1000}[self.parameters['DISTANCE_UNITS']]
      self.parameters['PIXEL_SIZE']*={
                  'mm':1,'m':1000}[self.parameters['PIXEL_SIZE_UNITS']]
      self.parameters['BEAM_CENTER_X']*=self.parameters['PIXEL_SIZE']
      self.parameters['BEAM_CENTER_Y']*=self.parameters['PIXEL_SIZE']
      # x,y beam center swap; do not know why
      swp = copy.copy(self.parameters['BEAM_CENTER_X'])
      self.parameters['BEAM_CENTER_X']=copy.copy(self.parameters['BEAM_CENTER_Y'])
      self.parameters['BEAM_CENTER_Y']=copy.copy(swp)

      # read array size
      header_lines = []
      found_array_data_data = False
      for record in rawdata.decode("latin-1").splitlines():
        if "_array_data.data" in record:
          found_array_data_data = True
        elif not found_array_data_data:
          continue
        elif len(record.strip()) == 0:
          # http://sourceforge.net/apps/trac/cbflib/wiki/ARRAY_DATA%20Category
          #    In an imgCIF file, the encoded binary data begins after
          #    the empty line terminating the header.
          break
        header_lines.append(record)
      self.header = "\n".join(header_lines)
      self.headerlines = [x.strip() for x in self.header.split("\n")]
      self.headerlines = [character_filter.sub("", x) for x in self.headerlines]

      for tag,search,idx,datatype in [
          ('SIZE1','X-Binary-Size-Second-Dimension',-1,int),
          ('SIZE2','X-Binary-Size-Fastest-Dimension',-1,int),
          ]:
          for line in self.headerlines:
            if line.find(search)==0:
              self.parameters[tag] = datatype(line.split(" ")[idx])
              break

      self.vendortype = vendortype_from_size.get((self.size2,self.size1),self.vendortype)


if __name__=='__main__':
  import sys
  i = sys.argv[1]
  a = EigerCBFImage(i)
  a.read()
  print(a)
  print(a.parameters)
  print(a.rawdata, len(a.rawdata), a.size1*a.size2)


 *******************************************************************************


 *******************************************************************************
iotbx/detectors/generic_detector.py
from __future__ import absolute_import, division, print_function
from scitbx.array_family import flex
from iotbx.detectors.detectorbase import DetectorImageBase

class GenericDetector(DetectorImageBase):
  """Generic image data, for example from electron crystallography. User
     should supply their own data here, and use the
     phenix.example_viewer command in rstbx/command_line/example_viewer.py
  """
  def __init__(self,filename):
    self.filename = filename
    self.size2 = 200
    self.size1 = 250
    self.pixel_size = 0.1
    #Fictitious vendor type to work around the beam cener convention code
    self.vendortype = "npy_raw"
    self.beamx = 10.0
    self.beamy = 12.5

  def readHeader(self):
    self.distance = 100.
    self.twotheta = 0.0
    self.wavelength = 1.0
    self.saturation = 255
    return

  def show_header(self):
    return "Generic detector with nothing in it"

  def read(self):
    # it is intended that the filename should be used to read in the raw
    #  data; but in this example just use random numbers:
    rawdata = 256*flex.random_double(self.size1*self.size2)
    rawdata.reshape(flex.grid(self.size1,self.size2))
    # this could equally well have been a imported numpy array
    #  import numpy
    #  rawdata2 = 256*numpy.random.rand(self.size1,self.size2)
    #  rawdata = flex.double(rawdata2) #conversion of numpy to cctbx-flex type

    self.linearintdata = rawdata.iround()


 *******************************************************************************


 *******************************************************************************
iotbx/detectors/hamamatsu.py
from __future__ import absolute_import, division, print_function
from iotbx.detectors.adsc import ADSCImage
from iotbx.detectors.detectorbase import DetectorImageBase

class HamamatsuImage(ADSCImage):
  """Hamamatsu CMOS Detector
  Beamline BL32XU, SPring-8
  RIKEN/SPring-8 Center
  Research Infrastructure Group,
  SR Life Science Instrumentation Unit

  1-1-1 Kouto Sayo-cho Sayo-gun
  Hyogo, 679-5148 JAPAN
  Contact: Kunio Hirata
  """
  def __init__(self,filename):
    DetectorImageBase.__init__(self,filename)
    self.vendortype = "Hamamatsu"

  def readHeader(self):
    ADSCImage.readHeader(self,external_keys=[("DETECTOR_NAME","DETECTOR_NAME",str)])
    assert self.parameters["DETECTOR_NAME"].lower().find("hamamatsu")>=0

    #above code validates the Hamamatsu signature, as in
    """HEADER_BYTES=512;
DIM=2;
BYTE_ORDER=little_endian;
TYPE=unsigned_short;
SIZE1=2352;
SIZE2=2352;
PIXEL_SIZE=0.050000;
BIN=1x1;
DETECTOR_NAME=Hamamatsu C10158DK;
DATE=Tue Jun 14 15:31:08 2011;
TIME=0.33;
DISTANCE=144.000;
OSC_RANGE=1.000;
OMEGA=1.000;
OSC_START=0.000;
TWOTHETA=0.000;
AXIS=Omega;
WAVELENGTH=1.00000;
BEAM_CENTER_X=58.425;
BEAM_CENTER_Y=58.775;
"""


 *******************************************************************************


 *******************************************************************************
iotbx/detectors/image_from_http_request.py
from __future__ import absolute_import, division, print_function
from six.moves import cStringIO as StringIO
from iotbx.detectors.adsc_module import ADSCModule
from iotbx.detectors.pilatus_slice import PilatusSlice

class attributes_from_dict:
  def __init__(self,parentdict):
    for key in parentdict.keys():
      self.__dict__[key]=parentdict[key]

def module_or_slice_from_http_request(request):
  # edit out data from list
  tags = {}
  for item in request.keys():
    assert len(request[item])==1 #list with one element
    tags[item]=request[item][0]
    if len(tags[item]) < 1000:  #short items could be converted to numbers
      try:
        tags[item] = float(tags[item])
        if tags[item]==round(tags[item],0):
          tags[item]= int(tags[item])
      except Exception: pass
      #print "posted data types",item, type(tags[item]), tags[item]
  # tags dictionary is now conditioned as to type
  tags_class = attributes_from_dict(tags)

  #Vendor selector.
  if tags["vendortype"].lower().find("adsc")>=0:
    P = ADSCModule()
  elif tags["vendortype"].lower().find("pilatus")>=0:
    P = PilatusSlice()

  P.moduleindex = tags["moduleindex"]
  P.object = StringIO(tags["adsc_data"])
  P.copy_common_attributes_from_parent_instance(tags_class)
  P.parameters = {}
  for item in ['DISTANCE', 'PHI', 'WAVELENGTH',
    'TWOTHETA', 'OSC_RANGE',
    'CCD_IMAGE_SATURATION', 'OSC_START', 'DETECTOR_SN', 'PIXEL_SIZE',
    'SIZE1','SIZE2','BEAM_CENTER_X','BEAM_CENTER_Y'
    ]:
    P.parameters[item] = tags[item]
  from iotbx.detectors.beam_center_convention import convert_beam_instrument_to_imageblock
  convert_beam_instrument_to_imageblock(P,P.beam_center_convention)
  P.slice_callback = P.slice_callback_with_high_performance_http_data
  return P


 *******************************************************************************


 *******************************************************************************
iotbx/detectors/macscience.py
from __future__ import absolute_import, division, print_function
import struct,os
from iotbx.detectors.detectorbase import DetectorImageBase
from iotbx.detectors import ReadDIP

class DIPImage(DetectorImageBase):
  def __init__(self,filename):
    DetectorImageBase.__init__(self,filename)
    self.filename = filename
    self.vendortype = "MacScience"
    self.getImageSize()

  def getImageSize(self):
    self.filesize = os.stat(self.filename)[6]
    # MacScience DIP 2030b
    assert self.filesize == 18001024 #necessary filelength for 3000x3000 image
    # other file sizes can be added here (for compatibility with
    # MacScience DIP 2020; 2000 x 2000)
    self.deduce_size = 3000

  def fileLength(self): return self.filesize

  def readHeader(self,):
    headerstart = self.deduce_size * self.deduce_size * 2 #short integers
    F = open(self.filename,'rb')
    F.seek(headerstart)
    self.rawheader = F.read(1024)
    F.close()
    assert self.rawheader[0:3] # Image file self-identifies as a DIP
    #self.getEndian() not cached anyway

    if not self.parameters:
      self.parameters={'CCD_IMAGE_SATURATION':1048576} #according to Stan Svenson
      self.parameters['SIZE1']=struct.unpack(
             self.intformat(),self.rawheader[28:32])[0]
      self.parameters['SIZE2']=struct.unpack(
             self.intformat(),self.rawheader[32:36])[0]
      assert self.size1==self.deduce_size
      assert self.size2==self.deduce_size
      self.parameters['PIXEL_SIZE'] = 0.1 # mm, just a guess
      self.parameters['OSC_START']=struct.unpack(
             self.floatformat(),self.rawheader[192:196])[0]
      self.parameters['DISTANCE']=struct.unpack(
             self.floatformat(),self.rawheader[124:128])[0]
      self.parameters['WAVELENGTH']=struct.unpack(
             self.floatformat(),self.rawheader[120:124])[0]
      self.parameters['BEAM_CENTER_X']=struct.unpack(
             self.intformat(),self.rawheader[164:168])[0] * self.pixel_size
      self.parameters['BEAM_CENTER_Y']=struct.unpack(
             self.intformat(),self.rawheader[168:172])[0] * self.pixel_size
      self.parameters['OSC_RANGE']=struct.unpack(
             self.floatformat(),self.rawheader[196:200])[0] - self.osc_start
      self.parameters['TWOTHETA']=0.0
      self.parameters["TIME"] = struct.unpack(
             self.floatformat(),self.rawheader[172:176])[0]

  def integerdepth(self):
    return 2

  def floatformat(self):
    if self.getEndian(): return '>f'
    else: return '<f'

  def intformat(self):
    if self.getEndian(): return '>i'
    else: return '<i'

  def getEndian(self):
    return struct.unpack('>i',self.rawheader[4:8])[0]==self.deduce_size
    # True for big_endian; False for little_endian

  def endian_swap_required(self):
    return struct.unpack('i',self.rawheader[4:8])[0]!=self.deduce_size

  def read(self):
    self.bin_safe_set_data( ReadDIP(self.filename,
         self.size1*self.bin,self.size2*self.bin,self.endian_swap_required())
         )


 *******************************************************************************


 *******************************************************************************
iotbx/detectors/mar.py
from __future__ import absolute_import, division, print_function

import re
import struct

from iotbx.detectors.detectorbase import DetectorImageBase
from six.moves import range

class MARImage(DetectorImageBase):
  def __init__(self,filename):
    DetectorImageBase.__init__(self,filename)
    self.vendortype = "MARCCD"

    with open(self.filename,"rb") as fh:
      byte_order = fh.read(2)
      if byte_order == b"II":
        self.endian = 0
      else:
        self.endian = 1

    assert not self.isCompressed()

  def isCompressed(self):
    if self.getEndian(): format = '>'
    else: format = '<'

    with open(self.filename,"rb") as f:
      f.seek(4)
      rawdata = f.read(4)
      ifd = struct.unpack(format+'i',rawdata)[0]

      # if ifd is 0 then there are no more Image File Directories
      while ifd:
        f.seek(ifd)

        rawdata = f.read(2)
        # get the number of directory entries in the IFD
        numentries = struct.unpack(format+'h',rawdata)[0]

        # search for compression tag
        for x in range(numentries):
          f.seek(ifd+x*12+2)
          rawdata = f.read(2)
          tag = struct.unpack(format+'h',rawdata)[0]
          if tag == 259: # value of compression tag
            f.seek(ifd+x*12+2+8) # seek to value offset
            # value is left justified in 4 byte field
            # read two bytes so can unpack as short
            rawdata = f.read(2)
            value = struct.unpack(format+'h',rawdata)[0]
            #print value
            if value == 1: # no compression
              return 0
            else:
              return 1

        f.seek(ifd+numentries*12+2)
        rawdata = f.read(4)
        ifd = struct.unpack(format+'i',rawdata)[0]

    # control should never reach this point
    assert False

  # returns 0 for little endian 'II'
  # returns 1 for big endian 'MM'
  def getEndian(self):
    return self.endian

  def readHeader(self,offset=1024):
    if not self.parameters:
      if self.getEndian(): format = '>'
      else: format = '<'

      with open(self.filename, "rb") as f:
        f.seek(2464) # seek to file_comments
        file_comments = f.read(512) # read file_comments

        parameters={}
        item = (b'Detector Serial Number',b'DETECTOR_SN') #expected integers
        pattern = re.compile(item[0]+b" = (.*)")
        matches = pattern.findall(file_comments)
        if len(matches) > 0:
          parameters[item[1]] = int(matches[-1])
        else:
          parameters[item[1]] = 0

        f.seek(offset+28)
        rawdata = f.read(8)
        header_byte_order,data_byte_order = struct.unpack(format+'ii',rawdata)

        f.seek(offset+80)
        rawdata = f.read(8)
        parameters['SIZE1'],parameters['SIZE2'] = struct.unpack(format+'ii',rawdata)
        assert parameters['SIZE1'] == parameters['SIZE2']
        f.seek(offset+88)
        rawdata = f.read(4)
        self.depth = struct.unpack(format+'i',rawdata)[0]

        f.seek(offset+104)
        rawdata = f.read(4)
        parameters['CCD_IMAGE_SATURATION'] = struct.unpack(format+'i',rawdata)[0]

        f.seek(offset+116)
        rawdata = f.read(12)
        origin,orientation,view_direction = struct.unpack(format+'iii',rawdata)

        f.seek(offset+696)
        rawdata = f.read(4)
        start_xtal_to_detector = struct.unpack(format+'i',rawdata)[0]/1000.
        f.seek(offset+728)
        rawdata = f.read(4)
        end_xtal_to_detector = struct.unpack(format+'i',rawdata)[0]/1000.
        #assert start_xtal_to_detector == end_xtal_to_detector
        #that assertion would've been nice but ESRF BM14 frames fail; instead:
        #assert the distance is greater than zero in _read_header_asserts
        parameters['DISTANCE'] = start_xtal_to_detector

        f.seek(offset+772)
        rawdata = f.read(8)
        pixelsize_x,pixelsize_y = struct.unpack(format+'ii',rawdata)
        assert pixelsize_x == pixelsize_y
        parameters['PIXEL_SIZE'] = pixelsize_x*1.0e-6 # convert from nano to milli


        f.seek(offset+644)
        rawdata = f.read(8)
        beam_center_x,beam_center_y = struct.unpack(format+'ii',rawdata)
        parameters['BEAM_CENTER_X'] = beam_center_x/1000.*parameters['PIXEL_SIZE']
        parameters['BEAM_CENTER_Y'] = beam_center_y/1000.*parameters['PIXEL_SIZE']

        # ----- phi analysis
        f.seek(offset+684)
        rawdata = f.read(4)
        parameters['OSC_START'] = struct.unpack(format+'i',rawdata)[0]/1000.

        f.seek(offset+716)
        rawdata = f.read(4)
        end_phi = struct.unpack(format+'i',rawdata)[0]/1000.

        #parameters['OSC_RANGE'] = end_phi - parameters['OSC_START']
        #would have thought this would work; but turns out unreliable because
        # software doesn't always fill in the end_phi

        # ----- rotation analysis
        f.seek(offset+736)
        rawdata = f.read(4)
        rotation_range = struct.unpack(format+'i',rawdata)[0]/1000.
        parameters['OSC_RANGE'] = rotation_range

        f.seek(offset+732)
        rawdata = f.read(4)
        rotation_axis = struct.unpack(format+'i',rawdata)[0]
        #assert rotation_axis == 4 # if it isn't phi; go back and recode to cover all cases

        # ----- omega analysis
        f.seek(offset+672)
        rawdata = f.read(4)
        parameters['OMEGA_START'] = struct.unpack(format+'i',rawdata)[0]/1000.

        f.seek(offset+704)
        rawdata = f.read(4)
        parameters['OMEGA_END'] = struct.unpack(format+'i',rawdata)[0]/1000.

        if rotation_axis == 4: # rotation axis is phi
          pass
        elif rotation_axis == 1: # rotation about omega
          parameters['OSC_START'] = parameters['OMEGA_START']

        f.seek(offset+668)
        rawdata = f.read(4)
        start_twotheta = struct.unpack(format+'i',rawdata)[0]/1000.
        f.seek(offset+700)
        rawdata = f.read(4)
        end_twotheta = struct.unpack(format+'i',rawdata)[0]/1000.
        self._assert_matching_twothetas = start_twotheta == end_twotheta
        parameters['TWOTHETA'] = start_twotheta

        f.seek(offset+908)
        rawdata = f.read(4)
        parameters['WAVELENGTH'] = struct.unpack(format+'i',rawdata)[0]*1.0e-5 # convert from femto to angstrom

      self.parameters=parameters

      self._read_header_asserts()

  def _read_header_asserts(self):
    ''' move a couple asserts here that aren't always desireable for un-initialized data '''
    assert self.parameters['DISTANCE'] > 0
    assert self._assert_matching_twothetas

  def dataoffset(self):
    return 4096

  def integerdepth(self):
    return self.depth

if __name__=='__main__':
  i = "/net/racer/scratch1/ttleese/lyso201.0002"
  #i = "/net/racer/scratch1/ttleese/oxford.tif"
  m = MARImage(i)
  print(m.isCompressed())
  #m.read()
  #print 'endian:',m.getEndian()
  #print 'serial number:',m.serial_number
  #print 'size 1:',m.size1
  #print 'size 2:',m.size2
  #print 'npixels:',m.npixels
  #print 'saturation:',m.saturation
  #print 'beamx:',m.beamx
  #print 'beamy:',m.beamy
  #print 'pixel size:',m.pixel_size
  #print 'osc start:',m.osc_start
  #print 'delta phi:',m.deltaphi
  #print 'two theta:',m.twotheta
  #print 'wav:',m.wavelength
  #print 'distance:',m.distance
  #print 'file length:',m.fileLength()


 *******************************************************************************


 *******************************************************************************
iotbx/detectors/marIP.py
from __future__ import absolute_import, division, print_function
from iotbx.detectors.detectorbase import DetectorImageBase

class NullAdaptor(object):
  def size1(self): return 0
  def size2(self): return 0
  def overload(self): return 0
  def pixel_size(self): return 0.0
  def osc_start(self): return 0.0
  def osc_range(self): return 0.0
  def distance(self): return 0.0
  def wavelength(self): return 0.0
  def twotheta(self): return 0.0
  def rawdata(self): return [0.0]

class MARIPImage(DetectorImageBase):
  def __init__(self,filename):
    DetectorImageBase.__init__(self,filename)
    try:
      from cbflib_adaptbx import Mar345Adaptor # optional package
      self.adaptor = Mar345Adaptor(filename)
    except Exception:
      self.adaptor = NullAdaptor()
    self.vendortype = "MARIP"

  def readHeader(self):
    self.parameters = {'SIZE1':self.adaptor.size1(),
                       'SIZE2':self.adaptor.size2(),
                       'CCD_IMAGE_SATURATION':self.adaptor.overload(),
                       'PIXEL_SIZE':self.adaptor.pixel_size(),
                       'OSC_START':self.adaptor.osc_start(),
                       'DISTANCE':self.adaptor.distance(),
                       'WAVELENGTH':self.adaptor.wavelength(),
                       'BEAM_CENTER_X':self.beam_center_slow(),
                       'BEAM_CENTER_Y':self.beam_center_fast(),
                       'OSC_RANGE':self.adaptor.osc_range(),
                       'TWOTHETA':self.adaptor.twotheta(),
                       'DETECTOR_SN':0
                       }

  def beam_center_slow(self):
    return self.adaptor.size1()*self.adaptor.pixel_size()/2.0

  def beam_center_fast(self):
    return self.adaptor.size2()*self.adaptor.pixel_size()/2.0

  def fileLength(self):
    return 0

  def getEndian(self):
    return 0

  def read(self):
    self.bin_safe_set_data( self.adaptor.rawdata() )

  def dataoffset(self):
    return 0

  def integerdepth(self):
    return 0

if __name__=='__main__':
  pass


 *******************************************************************************


 *******************************************************************************
iotbx/detectors/noir.py
from __future__ import absolute_import, division, print_function
import re
from iotbx.detectors.adsc import ADSCImage
from iotbx.detectors.detectorbase import DetectorImageBase

INT = (int,)
FLOAT = (float,)
STR = (str,)

class NoirImage(ADSCImage):
  def __init__(self,filename):
    DetectorImageBase.__init__(self,filename)
    self.vendortype = "RAXIS"

  def getTupleofType(self,inputstr,typefunc):
    parsed = inputstr.split(' ')
    return [typefunc(I) for I in parsed if I != '']

  def readHeader(self,maxlength=6144):
    if not self.parameters:
      with open(self.filename,"rb") as fh:
        rawdata = fh.read(maxlength)
      headeropen = rawdata.index(b"{")
      headerclose= rawdata.index(b"}")
      self.header = rawdata[headeropen+1:headerclose-headeropen].decode("latin-1")

      self.parameters={}
      for tag,search,datatype in [
          ('SATURATED_VALUE','SATURATED_VALUE',float),
          ('HEADER_BYTES','HEADER_BYTES',int),
          #('BitmapSize','BitmapSize',int),
          ('SIZE1','SIZE1',int),
          ('SIZE2','SIZE2',int),
          ('NOIR1_DETECTOR_DESCRIPTION','NOIR1_DETECTOR_DESCRIPTION',str),
          ('NOIR1_DETECTOR_DIMENSIONS','NOIR1_DETECTOR_DIMENSIONS',INT),
          ('NOIR1_DETECTOR_SIZE','NOIR1_DETECTOR_SIZE',FLOAT),
          ('NOIR1_GONIO_DESCRIPTION','NOIR1_GONIO_DESCRIPTION',str),
          ('NOIR1_GONIO_NAMES','NOIR1_GONIO_NAMES',STR),
          ('NOIR1_GONIO_NUM_VALUES','NOIR1_GONIO_NUM_VALUES',int),
          ('NOIR1_GONIO_UNITS','NOIR1_GONIO_UNITS',str),
          ('NOIR1_GONIO_VALUES','NOIR1_GONIO_VALUES',FLOAT),
          #('NOIR1_GONIO_VALUES_MAX','NOIR1_GONIO_VALUES_MAX',FLOAT),
          #('NOIR1_GONIO_VALUES_MIN','NOIR1_GONIO_VALUES_MIN',FLOAT),
#          ('PIXEL_SIZE','PIXEL_SIZE',float),
#          ('OSC_START','OSC_START',float),
          ('DISTANCE','NOIR1_ACTUAL_DISTANCE',float),
          ('WAVELENGTH','NOIR1_ACTUAL_ENERGY',float),
          ('NOIR1_SPATIAL_BEAM_POSITION','NOIR1_SPATIAL_BEAM_POSITION',FLOAT),
#          ('BEAM_CENTER_X',r'\nBEAM_CENTER_X',float),
#          ('BEAM_CENTER_Y',r'\nBEAM_CENTER_Y',float),
#          ('OSC_RANGE','OSC_RANGE',float),
          ('TWOTHETA','NOIR1_ACTUAL_THETA',float),
          ('BYTE_ORDER','BYTE_ORDER',str),
          ('AXIS','ROTATION_AXIS_NAME',str),
#          ('PHI','PHI',float),
#          ('OMEGA','OMEGA',float),
          #('DATE','DTREK_DATE_TIME',str),
          ('ROTATION',r'\nROTATION',FLOAT),
          ]:
          matches = re.findall(search+'='+r'(.*);', self.header)
          if len(matches)>0:
            if type(datatype) == type((0,1)):
              self.parameters[tag] = self.getTupleofType(
                matches[-1],datatype[0])
            else:
              self.parameters[tag] = datatype(matches[-1])
      assert self.parameters['NOIR1_DETECTOR_DESCRIPTION'].find('NOIR')>=0
      assert self.parameters['NOIR1_DETECTOR_DIMENSIONS'][0]==self.size1
      self.parameters['PIXEL_SIZE'] = self.parameters['NOIR1_DETECTOR_SIZE'][0] / self.size1
      # rounding to hundreth of degree since encoder reports six (too many) decimal places
      self.parameters['OSC_START'] = round(self.parameters['ROTATION'][0],2)
      #assert self.parameters['NOIR1_GONIO_NAMES'][5]=='Distance'
      #self.parameters['DISTANCE'] = self.parameters['NOIR1_GONIO_VALUES'][5]
      self.parameters['BEAM_CENTER_X'] = self.parameters[
        'NOIR1_SPATIAL_BEAM_POSITION'][0] * self.pixel_size
      self.parameters['BEAM_CENTER_Y'] = self.parameters[
        'NOIR1_SPATIAL_BEAM_POSITION'][1] * self.pixel_size
      self.parameters['OSC_RANGE'] = round(self.parameters[
        'ROTATION'][1] - self.parameters['ROTATION'][0],2)
      #assert self.parameters['NOIR1_GONIO_NAMES'][1]=='2Theta'
      #self.parameters['TWOTHETA'] = self.parameters['NOIR1_GONIO_VALUES'][2]
      hc = 12398
      self.parameters['WAVELENGTH'] = hc / self.parameters['WAVELENGTH']

  def read(self):
    from iotbx.detectors import ReadRAXIS
    with open(self.filename,'rb') as fh:
      fh.seek(self.dataoffset())
      chardata = fh.read(self.size1 * self.size2 * self.integerdepth() )
    self.bin_safe_set_data( ReadRAXIS(chardata,self.dataoffset(),
         self.size1*self.bin,self.size2*self.bin,
         self.endian_swap_required())
    )

if __name__=='__main__':
  import sys
  i = sys.argv[1]
  a = NoirImage(i)
  a.readHeader()
  a.read()


 *******************************************************************************


 *******************************************************************************
iotbx/detectors/npy.py
from __future__ import absolute_import, division, print_function
from six.moves import range
# -*- Mode: Python; c-basic-offset: 2; indent-tabs-mode: nil; tab-width: 8; -*-

from iotbx.detectors.detectorbase import DetectorImageBase, tile_manager_base
from scitbx.array_family          import flex
import six
from six.moves import cPickle as pickle

def image_dict_to_unicode(data):
  if not data or six.PY2: return data
  for key in list(data.keys()): # modifying dict so need list of keys up front or iterator breaks
    if isinstance(data[key], bytes):
      data[key] = data[key].decode()
    if isinstance(key, bytes):
      data[key.decode()] = data[key]
      del data[key]
  return data

class NpyImage(DetectorImageBase):
  def __init__(self, filename, source_data = None):
    DetectorImageBase.__init__(self, filename)
    self.vendortype = "npy_raw"
    self.source_data = image_dict_to_unicode(source_data)

  def readHeader(self, horizons_phil):
    version_control = horizons_phil.distl.detector_format_version

    if self.source_data == None:
      with open(self.filename, "rb") as fh:
        if six.PY3:
          cspad_data = image_dict_to_unicode(pickle.load(fh, encoding="bytes"))
        else:
          cspad_data = pickle.load(fh)
    else:
      cspad_data = self.source_data

    # XXX assert that cspad_data['image'].ndim is 2?

    self.parameters                         = {}

    if version_control == "CXI 3.1":
      import numpy
      self.parameters['SIZE1']                = cspad_data['image'].shape[0] # XXX order?
      self.parameters['SIZE2']                = cspad_data['image'].shape[1] # XXX order?
      self.parameters['PIXEL_SIZE']           = 110e-3 # XXX fiction
      self.parameters['BEAM_CENTER_X']        = 0.5 * self.parameters['SIZE1'] * self.parameters['PIXEL_SIZE']  # XXX order?
      self.parameters['BEAM_CENTER_Y']        = 0.5 * self.parameters['SIZE2'] * self.parameters['PIXEL_SIZE']  # XXX order?
      self.parameters['CCD_IMAGE_SATURATION'] = 2**14 - 1
      self.parameters['DISTANCE']             = 93   # XXX fiction
      self.parameters['OSC_START']            = 0    # XXX fiction
      self.parameters['OSC_RANGE']            = 0    # XXX fiction
      self.parameters['SATURATED_VALUE']      = 2**14 - 1
      self.parameters['TWOTHETA']             = 0    # XXX fiction
      # From Margaritondo & Rebernik Ribic (2011): the dimensionless
      # relativistic gamma-factor is derived from beam energy in MeV and
      # the electron rest mass, K is a dimensionless "undulator
      # parameter", and L is the macroscopic undulator period in
      # Aangstroem (XXX).  See also
      # http://ast.coe.berkeley.edu/srms/2007/Lec10.pdf.  XXX This
      # should really move into the pyana code, since the parameters are
      # SLAC-specific.
      gamma                         = cspad_data['beamEnrg'] / 0.510998910
      K                             = 3.5
      L                             = 3.0e8
      self.parameters['WAVELENGTH'] = L / (2 * gamma**2) * (1 + K**2 / 2)
      SI = cspad_data['image'].astype(numpy.int32)
      SI = flex.int(SI)
      self.bin_safe_set_data(SI)
    elif version_control in ["CXI 3.2","CXI 4.1","CXI 5.1","CXI 6.1","CXI 7.1","CXI 7.d","XPP 7.1","XPP 7.marccd",
                             "CXI 8.1","CXI 8.d","XPP 8.1","XPP 8.marccd","CXI 8.2","Sacla.MPCCD","CXI 9.1","XPP 9.1",
                             "CXI 10.1","CXI 10.2","CXI 11.1","CXI 11.2", "XPP 11.1","Sacla.MPCCD.8tile"]:
      self.parameters['ACTIVE_AREAS']         = cspad_data.get('ACTIVE_AREAS', None)
      self.parameters['BEAM_CENTER_X']        = cspad_data['BEAM_CENTER_X']
      self.parameters['BEAM_CENTER_Y']        = cspad_data['BEAM_CENTER_Y']
      self.parameters['CCD_IMAGE_SATURATION'] = cspad_data['CCD_IMAGE_SATURATION']
      self.parameters['DISTANCE']             = cspad_data['DISTANCE']
      self.parameters['OSC_RANGE']            = 0 # XXX fiction
      self.parameters['OSC_START']            = 0 # XXX fiction
      self.parameters['PIXEL_SIZE']           = cspad_data['PIXEL_SIZE']
      self.parameters['SATURATED_VALUE']      = cspad_data['SATURATED_VALUE']
      self.parameters['MIN_TRUSTED_VALUE']    = cspad_data.get('MIN_TRUSTED_VALUE', 0)
      self.parameters['SIZE1']                = cspad_data['SIZE1']
      self.parameters['SIZE2']                = cspad_data['SIZE2']
      self.parameters['TWOTHETA']             = 0 # XXX fiction
      self.parameters['WAVELENGTH']           = cspad_data['WAVELENGTH']
      self.bin_safe_set_data(cspad_data['DATA'])

      if (self.parameters['ACTIVE_AREAS'] is not None):
        horizons_phil.distl.detector_tiling = self.parameters['ACTIVE_AREAS']
    elif version_control is None:
      #approrpiate for detectors other than the CS-PAD diffraction detectors
      self.parameters['ACTIVE_AREAS']         = cspad_data.get('ACTIVE_AREAS', None)
      self.parameters['BEAM_CENTER_X']        = cspad_data.get('BEAM_CENTER_X',None)
      self.parameters['BEAM_CENTER_Y']        = cspad_data.get('BEAM_CENTER_Y',None)
      self.parameters['CCD_IMAGE_SATURATION'] = cspad_data['CCD_IMAGE_SATURATION']
      self.parameters['DISTANCE']             = cspad_data.get('DISTANCE',None)
      self.parameters['PIXEL_SIZE']           = cspad_data['PIXEL_SIZE']
      self.parameters['SATURATED_VALUE']      = cspad_data['SATURATED_VALUE']
      self.parameters['MIN_TRUSTED_VALUE']    = cspad_data.get('MIN_TRUSTED_VALUE', 0)
      self.parameters['SIZE1']                = cspad_data['SIZE1']
      self.parameters['SIZE2']                = cspad_data['SIZE2']
      self.parameters['WAVELENGTH']           = cspad_data['WAVELENGTH']
      if 'OSC_RANGE' in cspad_data and cspad_data['OSC_RANGE'] > 0:
        self.parameters['OSC_START']            = cspad_data.get('OSC_START',None)
        self.parameters['OSC_RANGE']            = cspad_data.get('OSC_RANGE',None)
      import math
      if  ( math.isnan(self.parameters["DISTANCE"]) ):
         self.parameters["DISTANCE"]=0.0
      self.bin_safe_set_data(cspad_data['DATA'])
      if (self.parameters['ACTIVE_AREAS'] is not None):
        horizons_phil.distl.detector_tiling = self.parameters['ACTIVE_AREAS']


    if version_control not in ["CXI 3.1", "CXI 3.2"]:
      if horizons_phil.distl.tile_translations==None and \
         horizons_phil.distl.detector_tiling is not None:
          horizons_phil.distl.tile_translations = [0]*(int(len(horizons_phil.distl.detector_tiling)/2))


  # This is nop, because all the data has been read by readHeader().
  # The header information and the data are all contained in the same
  # pickled object.
  def read(self):
    pass

  def translate_tiles(self, phil):
    if phil.distl.detector_tiling==None: return
    if phil.distl.tile_translations==None: return

    if len(phil.distl.detector_tiling) <= 16:
      # assume this is the 2x2 CS Pad for spectroscopy; do not use tile translations
      if phil.distl.detector_format_version in ["CXI 4.1"]:
        # For the Run 4 CXI detector, the first sensor is inactive and pegged high(16K).
        # For calculating display contrast it is better to eliminate the sensor.
        if self.size1 == 370: #there are two sensors; we should eliminate the first
          self.parameters['SIZE1'] = 185
          self.linearintdata = self.linearintdata[int(len(self.linearintdata)/2):]
          self.linearintdata.reshape(flex.grid(self.size1,self.size2))
        print("CXI 2x2 size",self.size1,self.size2, self.linearintdata.focus())
      return

    assert 2 * len(phil.distl.tile_translations) == len(phil.distl.detector_tiling)

    shifted_int_data_old = self.__getattr__('rawdata')
    # Use __class__ attribute to transparently transform either flex.int or flex.double
    shifted_int_data_new = shifted_int_data_old.__class__(
      flex.grid(shifted_int_data_old.focus()))

    manager = self.get_tile_manager(phil)

    for i,shift in enumerate(manager.effective_translations()):
      shift_slow = shift[0]
      shift_fast = shift[1]

      ur_slow = phil.distl.detector_tiling[4 * i + 0]
      ur_fast = phil.distl.detector_tiling[4 * i + 1]
      ll_slow = phil.distl.detector_tiling[4 * i + 2]
      ll_fast = phil.distl.detector_tiling[4 * i + 3]

      #print "Shifting tile at (%d, %d) by (%d, %d)" % (ur_slow, ur_fast, shift_slow, shift_fast)

      shifted_int_data_new.matrix_paste_block_in_place(
        block = shifted_int_data_old.matrix_copy_block(
          i_row=ur_slow,i_column=ur_fast,
          n_rows=ll_slow-ur_slow, n_columns=ll_fast-ur_fast),
        i_row = ur_slow + shift_slow,
        i_column = ur_fast + shift_fast
      )

    self.bin_safe_set_data(shifted_int_data_new)

  def correct_gain_in_place(self, filename, adu_scale, phil):
    stddev = NpyImage( filename )
    stddev.readHeader(phil)
    stddev.translate_tiles(phil)
    self.bin_safe_set_data( (adu_scale*self.linearintdata)/(1+stddev.linearintdata) )

  def correct_background_in_place(self, phil):

    """The 'in place' function actually changes the raw data in this image object"""
    active_areas = self.get_tile_manager(phil).effective_tiling_as_flex_int()
    B = active_areas

    assert len(active_areas)%4 == 0
    # apply an additional margin of 1 pixel, since we don't seem to be
    # registering the global peripheral margin.  XXX this should be changed later
    asics = [(B[i]+1,B[i+1]+1,B[i+2]-1,B[i+3]-1) for i in range(0,len(B),4)]

    for asic in asics:
      self.linearintdata.matrix_paste_block_in_place(
        block = self.correct_background_by_block(asic),
        i_row = asic[0],
        i_column = asic[1]
      )

    self.bin_safe_set_data(self.linearintdata)

  def correct_background_by_block(self, asic):
    """The 'by block' function doesn't changes the object data, it just returns the
       filtered data for a particular detector asic"""

    from iotbx.detectors.util.filters import background_correct_padded_block
    corrected_data = background_correct_padded_block(self.linearintdata, asic)
    return corrected_data

  def get_tile_manager(self, phil):
    return tile_manager(phil,beam=(int(self.beamx/self.pixel_size),
                                   int(self.beamy/self.pixel_size)),
                             size1=self.size1,
                             size2=self.size2)

  def debug_write(self,fileout,mod_data=None):
    try:
      if mod_data == None:
        mod_data = self.get_raw_data().iround()
    except AttributeError:
      pass

    DetectorImageBase.debug_write(self,fileout,mod_data)

  def getEndian(self):
    return 1   # big!  arbitrary


class tile_manager(tile_manager_base):

  def effective_translations(self):

    # if there are quadrant translations, do some extra work to apply them
    if self.working_params.distl.quad_translations != None:
      from scitbx.matrix import col
      beam = col(self.beam)
      for itile in range(len(self.working_params.distl.detector_tiling) // 4):
        tile_center = (
          col(self.working_params.distl.detector_tiling[4*itile:4*itile+2]) +
          col(self.working_params.distl.detector_tiling[4*itile+2:4*itile+4]))/2
        delta = tile_center-beam
        iquad = [(True,True),(True,False),(False,True),(False,False)
                ].index((delta[0]<0, delta[1]<0)) # UL,UR,LL,LR
        yield (self.working_params.distl.tile_translations[2 * itile + 0] +
               self.working_params.distl.quad_translations[2 * iquad + 0],
               self.working_params.distl.tile_translations[2 * itile + 1] +
               self.working_params.distl.quad_translations[2 * iquad + 1])
      return

    for i in range(len(self.working_params.distl.tile_translations) // 2):
       yield (self.working_params.distl.tile_translations[2 * i + 0],
              self.working_params.distl.tile_translations[2 * i + 1])

  def effective_tiling_as_flex_int_impl(self, **kwargs):
    import copy
    IT = flex.int(copy.copy(self.working_params.distl.detector_tiling))

    assert len(IT)%4==0 # only meaningful for groups of 4
    for itl in range(0,len(IT),4): # validate upper-left/ lower-right ordering
      assert IT[itl] < IT[itl+2]; assert IT[itl+1] < IT[itl+3]

    if self.working_params.distl.tile_translations!=None and \
      2*len(self.working_params.distl.tile_translations) == len(IT):
      #assume that the tile translations have already been applied at the time
      #the file is read; now they need to be applied to the spotfinder tile boundaries

      #check if beam position has been supplied
      self.beam = kwargs.get("beam",self.beam)

      for i,shift in enumerate(self.effective_translations()):
        shift_slow = shift[0]
        shift_fast = shift[1]
        IT[4 * i + 0] += shift_slow
        IT[4 * i + 1] += shift_fast
        IT[4 * i + 2] += shift_slow
        IT[4 * i + 3] += shift_fast
    return IT

#if __name__=='__main__':
#  import sys
#  i = sys.argv[1]
#  a = SaturnImage(i)
#  a.readHeader()
#  a.read()


 *******************************************************************************


 *******************************************************************************
iotbx/detectors/pilatus_minicbf.py
from __future__ import absolute_import, division, print_function
import copy
import re
from iotbx.detectors.detectorbase import DetectorImageBase
from iotbx.detectors import ImageException

try:
  import bz2
except ImportError:
  bz2 = None

try:
  import gzip
except ImportError:
  gzip = None

class PilatusImage(DetectorImageBase):
  def __init__(self,filename):
    DetectorImageBase.__init__(self,filename)
    self.vendortype = "Pilatus"
    self.vendor_specific_null_value = -1

  mandatory_keys = ['PIXEL_SIZE_UNITS', 'DISTANCE', 'PHI', 'WAVELENGTH', 'SIZE1',
    'SIZE2', 'TWOTHETA', 'DISTANCE_UNITS', 'OSC_RANGE',
    'BEAM_CENTER_X', 'BEAM_CENTER_Y',
    'CCD_IMAGE_SATURATION', 'OSC_START', 'DETECTOR_SN', 'PIXEL_SIZE',
    'AXIS']

  def fileLength(self):
    raise ImageException("file length not computed for miniCBF")

  def getEndian(self):
    raise ImageException("endian-ness not computed for miniCBF")

  @staticmethod
  def is_bz2(filename):
    '''Check if a file pointed at by filename is bzip2 format.'''

    if not filename.endswith('.bz2'):
      return False

    with open(filename, 'rb') as fh:
      return b'BZh' == fh.read(3)

  @staticmethod
  def is_gzip(filename):
    '''Check if a file pointed at by filename is gzip compressed.'''

    if not filename.endswith('.gz'):
      return False

    with open(filename, 'rb') as fh:
      return fh.read(2) == b"\x1f\x8b"

  @staticmethod
  def open_file(filename, mode='rb'):
    '''Open file for reading, decompressing silently if necessary,
       caching transparently if possible.'''

    if PilatusImage.is_bz2(filename):
      if bz2 is None:
        raise RuntimeError('bz2 file provided without bz2 module')
      fh_func = lambda: bz2.BZ2File(filename, mode)

    elif PilatusImage.is_gzip(filename):
      if gzip is None:
        raise RuntimeError('gz file provided without gzip module')
      fh_func = lambda: gzip.GzipFile(filename, mode)

    else:
      fh_func = lambda: open(filename, mode)

    return fh_func()

  def endian_swap_required(self):
    return False

  def read(self,algorithm="buffer_based"):
    self.readHeader()
    if self.linearintdata != None and\
      self.linearintdata.size()==self.size1*self.size2:
      #data has already been read
      return
    if self.bin==2:
      raise ImageException("2-by-2 binning not supported for miniCBF")
    try:
      from cbflib_adaptbx import cbf_binary_adaptor # optional package
      self.adaptor = cbf_binary_adaptor(self.filename)

      # assert algorithm in ["cbflib","cbflib_optimized","buffer_based"]

      data = self.adaptor.uncompress_implementation( algorithm
             ).uncompress_data(self.size1,self.size2)
      self.bin_safe_set_data( data )

    except Exception as e:
      raise ImageException(
          "unable to read miniCBF data; contact authors; error=\"%s\"" % \
          str(e).strip())

  def readHeader(self,maxlength=12288): # usually 1024 is OK; require 12288 for ID19
    if not self.parameters:
      with self.open_file(self.filename,"rb") as fh:
        rawdata = fh.read(maxlength)

      # The tag _array_data.header_convention "SLS_1.0" could be with/without quotes "..."
      # SLS_match = re.findall(b'_array_data.header_convention[ "]*SLS', rawdata)
      # PILATUS_match = re.findall(b'_array_data.header_convention[ "]*PILATUS', rawdata)
      #assert len(SLS_match) + len(PILATUS_match)>=1

      # read SLS header
      headeropen = rawdata.index(b"_array_data.header_contents")
      headerclose = rawdata.index(b"_array_data.data")
      self.header = rawdata[headeropen+1:headerclose].decode("latin-1")
      self.headerlines = [x.strip() for x in self.header.split("#")]
      character_filter = re.compile(r"[\r\n,\(\);]")
      self.headerlines = [character_filter.sub("", x) for x in self.headerlines]

      self.parameters={'CCD_IMAGE_SATURATION':65535}
      for tag,search,idx,datatype in [
          ('CCD_IMAGE_SATURATION','Count_cutoff',1,int),
          ('DETECTOR_SN','Detector:',-1,str),
          ('PIXEL_SIZE','Pixel_size',1,float),
          ('PIXEL_SIZE_UNITS','Pixel_size',2,str),
          ('OSC_START','Start_angle',1,float),
          ('DISTANCE','Detector_distance',1,float),
          ('DISTANCE_UNITS','Detector_distance',2,str),
          ('WAVELENGTH',r'Wavelength',1,float),
          ('BEAM_CENTER_X',r'Beam_xy',1,float),
          ('BEAM_CENTER_Y',r'Beam_xy',2,float),
          ('OSC_RANGE','Angle_increment',1,float),
          ('TWOTHETA','Detector_2theta',1,float),
          ('AXIS','Oscillation_axis',1,str),
          ('PHI','Phi',1,float),
          ('OMEGA','OMEGA',1,float),
          ('DATE','DATE',1,str),
          ]:
          for line in self.headerlines:
            if line.find(search)==0:
              if idx==-1:
                tokens=line.split(" ")
                self.parameters[tag] = " ".join(tokens[1:len(tokens)])
                break
              self.parameters[tag] = datatype(line.split(" ")[idx])
              break
      #unit fixes
      self.parameters['DISTANCE']*={
                  'mm':1,'m':1000}[self.parameters['DISTANCE_UNITS']]
      self.parameters['PIXEL_SIZE']*={
                  'mm':1,'m':1000}[self.parameters['PIXEL_SIZE_UNITS']]
      self.parameters['BEAM_CENTER_X']*=self.parameters['PIXEL_SIZE']
      self.parameters['BEAM_CENTER_Y']*=self.parameters['PIXEL_SIZE']
      # x,y beam center swap; do not know why
      swp = copy.copy(self.parameters['BEAM_CENTER_X'])
      self.parameters['BEAM_CENTER_X']=copy.copy(self.parameters['BEAM_CENTER_Y'])
      self.parameters['BEAM_CENTER_Y']=copy.copy(swp)

      # read array size
      header_lines = []
      found_array_data_data = False
      for record in rawdata.decode("latin-1").splitlines():
        if "_array_data.data" in record:
          found_array_data_data = True
        elif not found_array_data_data:
          continue
        elif len(record.strip()) == 0:
          # http://sourceforge.net/apps/trac/cbflib/wiki/ARRAY_DATA%20Category
          #    In an imgCIF file, the encoded binary data begins after
          #    the empty line terminating the header.
          break
        header_lines.append(record)
      self.header = "\n".join(header_lines)
      self.headerlines = [x.strip() for x in self.header.split("\n")]
      self.headerlines = [character_filter.sub("", x) for x in self.headerlines]

      for tag,search,idx,datatype in [
          ('SIZE1','X-Binary-Size-Second-Dimension',-1,int),
          ('SIZE2','X-Binary-Size-Fastest-Dimension',-1,int),
          ]:
          for line in self.headerlines:
            if line.find(search)==0:
              self.parameters[tag] = datatype(line.split(" ")[idx])
              break
      if self.size1==2527 and self.size2==2463:
        self.vendortype="Pilatus-6M"
      elif self.size1==1679 and self.size2==1475:
        self.vendortype="Pilatus-2M"
      elif self.size1==619 and self.size2==487:
        self.vendortype="Pilatus-300K"


if __name__=='__main__':
  import sys
  i = sys.argv[1]
  a = PilatusImage(i)
  a.read()
  print(a)
  print(a.parameters)
  print(a.rawdata, len(a.rawdata), a.size1*a.size2)


 *******************************************************************************


 *******************************************************************************
iotbx/detectors/pilatus_slice.py
from __future__ import absolute_import, division, print_function
import copy
from six.moves import cPickle as pickle
from iotbx.detectors.pilatus_minicbf import PilatusImage
from iotbx.detectors import ImageException
from scitbx.array_family import flex

def pilatus_slice_from_http_url(url):
  from six.moves import urllib
  parsed = urllib.parse.urlparse(url)
  assert parsed.scheme in ["http","https"]
  Response = urllib.request.urlopen(url)
  info = Response.info()
  #print info
  P = PilatusSlice()
  if "Image-slice" in info.keys():
    sliceindex = int(info["Image-slice"])
    assert 0 <= sliceindex <= 11 # slow slice section, possible index range
    P.sliceindex = sliceindex
  P.bin = int(info["Image-bin"])
  P.filename = info["Image-filename"]
  P.vendortype = "Pilatus-6M"
  P.parameters = {}
  for item in P.mandatory_keys:
      header_key = "Image-%s"%item.lower()
      P.parameters[item]=P.data_types[item](info[header_key])
  if info["Image-data_encryption"]=="pickle":
    P.slice_callback = P.slice_callback_with_portable_http_data
  elif info["Image-data_encryption"]=="byte":
    P.slice_callback = P.slice_callback_with_high_performance_http_data
  P.object = Response #hand over the data stream to the callback function
  return P

def pilatus_slice_from_file_url(url):
  from six.moves import urllib
  parsed = urllib.parse.urlparse(url)
  assert parsed.scheme == "file"
  file = parsed.path.split("?")[0]
  if file == parsed.path:
    return PilatusImage(file)
  qs = urllib.parse.parse_qs(parsed.path.split("?")[1])
  sliceindex = int(qs["slice"][0])
  object = PilatusImage(file)
  object.readHeader()
  return pilatus_slice_from_object_and_slicenumber(object,sliceindex)

def pilatus_slice_from_object_and_slicenumber(object,sliceindex):
  P = PilatusSlice()
  assert 0 <= sliceindex <= 11 # slow slice section, possible index range
  P.sliceindex = sliceindex
  P.object = object
  P.copy_common_attributes_from_parent_instance(P.object)
  P.vendortype = "Pilatus-6M" # overrides the default copy
  P.parameters = P.slice_parameters(object.parameters)
  P.slice_callback = P.slice_callback_with_object_data
  return P

class PilatusSlice(PilatusImage):
  def __init__(self):
    self.already_read_data = False

  data_types = copy.copy(PilatusImage.data_types)
  data_types.update({"PIXEL_SIZE_UNITS":str, "DISTANCE_UNITS":str, "AXIS":str})

  def slice_parameters(self,param):
    #unchanged parameters first:
    result = {}
    for item in ['PIXEL_SIZE_UNITS', 'DISTANCE', 'PHI', 'WAVELENGTH',
    'SIZE2', 'TWOTHETA', 'DISTANCE_UNITS', 'OSC_RANGE', 'BEAM_CENTER_Y',
    'CCD_IMAGE_SATURATION', 'OSC_START', 'DETECTOR_SN', 'PIXEL_SIZE',
    'AXIS']:
      result[item]=copy.copy(param[item])
    result['SIZE1']=195
    #convert beam center X (slow) back to pixels, correct for slice, back to mm
    pixels = param["BEAM_CENTER_X"] / param["PIXEL_SIZE"]
    correction = pixels - self.sliceindex * (195+17)
    result["BEAM_CENTER_X"] = correction * result["PIXEL_SIZE"]
    return result

  def slice_callback_with_portable_http_data(self):
    linearintdata = pickle.load(self.object)
    del self.object #once the data are copied, close the stream
    return linearintdata

  def slice_callback_with_high_performance_http_data(self):
    BYU = self.object.read()
    linearintdata = flex.int_from_byte_str(BYU)
    provisional_size = linearintdata.size()
    if provisional_size==480285:
      linearintdata.reshape(flex.grid((195,2463)))
    elif provisional_size==6224001:
      linearintdata.reshape(flex.grid((2527,2463)))
    else:
      raise ImageException("wrong number of pixels for Pilatus image")
    del self.object #once the data are copied, close the stream
    return linearintdata

  def slice_callback_with_object_data(self):
    self.object.read()
    start_index = 2463*((195+17)*self.sliceindex)
    stop_index = start_index + 2463*195
    linearintdata = flex.int(self.object.linearintdata[start_index:stop_index])
    linearintdata.reshape(flex.grid((195,2463)))
    del self.object #once the data are copied, no need to keep the original
    return linearintdata

  def read(self):
    if self.already_read_data: return
    self.bin_safe_set_data( self.slice_callback() )
    self.already_read_data = True

if __name__=='__main__':
  import sys
  full_path_to_file = sys.argv[1]
  a = PilatusImage(testing_file)
  a.read()
  print(a)
  print(a.parameters)
  print(a.rawdata, len(a.rawdata), a.size1*a.size2)
  for dataitem in ['bin', 'filename', 'header', 'headerlines', 'linearintdata', 'parameters', 'vendortype']:
    print(dataitem, end=' ')
    exec("print a.%s"%dataitem)
  print(pilatus_slice_from_object_and_slicenumber(a,5))

  P = pilatus_slice_from_file_url(url="file://%s?slice=5"%full_path_to_file)


 *******************************************************************************


 *******************************************************************************
iotbx/detectors/raxis.py
from __future__ import absolute_import, division, print_function
from iotbx.detectors.detectorbase import DetectorImageBase
from iotbx.detectors.raxisbase import Raxis
from iotbx.detectors import ReadRAXIS

class RAXISImage(DetectorImageBase,Raxis):
  def __init__(self,filename):
    DetectorImageBase.__init__(self,filename)
    Raxis.__init__(self,filename)
    self.vendortype = "RAXIS"

  def readHeader(self,):
    if not self.parameters:
      Raxis.readHeader(self)
      self.generic_param_from_vendor_head()

  def generic_param_from_vendor_head(self):
      self.parameters={}
      self.parameters['SIZE1'] = self.head['nSlow']
      self.parameters['SIZE2'] = self.head['nFast']
      self.parameters['CCD_IMAGE_SATURATION'] = 32767 * self.head['Ratio']
      self.parameters['PIXEL_SIZE'] = self.head['sizeFast']
      self.parameters['OSC_START'] = self.head['phistart']
      self.parameters['OSC_RANGE'] = self.head['phiend']-self.head['phistart']
      self.parameters['DISTANCE'] = self.head['distance']
      self.parameters['WAVELENGTH'] = self.head['wavelength']
      self.parameters['BEAM_CENTER_X'] = self.head['beampixels_x']*self.head[
                                                              'sizeFast']
      self.parameters['BEAM_CENTER_Y'] = self.head['beampixels_y']*self.head[
                                                              'sizeSlow']
      self.parameters['TWOTHETA'] = self.head['twotheta']
      self.parameters['DETECTOR_SN'] = self.head['operatorname']

  def dataoffset(self):
    return self.head['record_length']

  def integerdepth(self):
    return self.head['record_length']//self.head['nFast']

  def getEndian(self):
    return 1

  def read(self):
    self.fileLength()
    self.data()
    self.bin_safe_set_data( ReadRAXIS(self.CharTemp,self.integerdepth(),
         self.size1*self.bin,self.size2*self.bin,self.endian_swap_required())
    )

if __name__=='__main__':
  import sys
  i = sys.argv[1]
  a = RAXISImage(i)
  a.read()
  print(a.linearintdata)
  print(a.linearintdata.size())
  print(a.linearintdata.accessor())
  #
  #from labelit.dptbx.graphics_support import GenericImageWorker
  #W = GenericImageWorker(i)
  #W.output(sys.argv[2])


 *******************************************************************************


 *******************************************************************************
iotbx/detectors/raxis_nonsquare.py
from __future__ import absolute_import, division, print_function
from iotbx.detectors.raxisbase import Raxis
from iotbx.detectors.raxis import RAXISImage
from iotbx.detectors import ReadRAXIS,MakeSquareRAXIS

#Special class to handle Raxis-II images, containing rectangular pixels
# Array is resized so that the internal representation has square pixels
class NonSquareRAXISImage(RAXISImage):
  def __init__(self,filename):
    RAXISImage.__init__(self,filename)

  def readHeader(self,):
    if not self.parameters:
      Raxis.readHeader(self)

      self.np = int(round(self.head['sizeSlow']/self.head['sizeFast']*self.head['nFast']))

      # assume that the slow dimension has longer pixels, as for the Raxis-II
      assert self.head['sizeSlow'] > self.head['sizeFast']

      # assume that the original pixel array is square
      assert  self.head['nFast'] == self.head['nSlow']

      # assume that the extra pixels can be evenly divided by two
      assert (self.np-self.head['nSlow'])%2==0

      self.extra = (self.np-self.head['nSlow'])//2

      self.generic_param_from_vendor_head()
      self.generic_param_from_adapt_head()

  def generic_param_from_adapt_head(self):

      self.parameters['SIZE1'] = self.np
      self.parameters['SIZE2'] = self.np
      self.parameters['PIXEL_SIZE'] = self.head['sizeFast']
      self.parameters['BEAM_CENTER_X'] = (self.extra+self.head['beampixels_x']
                                         )*self.head['sizeFast']
      self.parameters['BEAM_CENTER_Y'] = self.head['beampixels_y']*self.head[
                                                              'sizeSlow']

  def read(self):
    self.fileLength()
    self.data()
    self.rawlinearintdata = ReadRAXIS(self.CharTemp,self.integerdepth(),
         self.head['nSlow']*self.bin,
         self.head['nFast']*self.bin,
         bool(self.getEndian()))

    self.bin_safe_set_data( MakeSquareRAXIS(self.np,self.extra,
                                         self.head['nSlow'],
                                         self.rawlinearintdata)
    )
    del self.rawlinearintdata


 *******************************************************************************


 *******************************************************************************
iotbx/detectors/raxisbase.py
from __future__ import absolute_import, division, print_function
from six.moves import range
import struct

header_struct = [
  ('Device',10,'s'),
  ('Version',10,'s'),
  ('Crystal',20,'s'),
  ('CrystalSystem',12,'s'),
  (None,24),
  ('SpaceGroup',12,'s'),
  ('mosaic1',4,'!f'),
  ('memo',80,'s'),
  ('reserve1',84,'s'),
  ('date',12,'s'),
  ('operatorname',20,'s'),
  ('target',4,'s'),
  ('wavelength',4,'!f'),
  ('monotype',20,'s'),
  ('mono2theta',4,'!f'),
  ('collimator',20,'s'),
  ('filter',4,'s'),
  ('distance',4,'!f'),
  ('Kv',4,'!f'),
  ('mA',4,'!f'),
  ('focus',12,'s'),
  ('Xmemo',80,'s'),
  ('cyl',4,'!i'),
  (None,60),
  ('Spindle',4,'s'),          # Crystal mount axis closest to spindle axis
  ('Xray_axis',4,'s'),        # Crystal mount axis closest to beam axis
  ('phidatum',4,'!f'),
  ('phistart',4,'!f'),
  ('phiend',4,'!f'),
  ('noscillations',4,'!i'),
  ('minutes',4,'!f'),         # Exposure time in minutes?
  ('beampixels_x',4,'!f'),
  ('beampixels_y',4,'!f'),    # Direct beam position in pixels
  ('omega',4,'!f'),
  ('chi',4,'!f'),
  ('twotheta',4,'!f'),
  ('Mu',4,'!f'),              # Spindle inclination angle?
  ('ScanTemplate',204,'s'),   # This space is now used for storing the scan
                              # templates information
  ('nFast',4,'!i'),
  ('nSlow',4,'!i'),           # Number of fast, slow pixels
  ('sizeFast',4,'!f'),
  ('sizeSlow',4,'!f'),        # Size of fast, slow direction in mm
  ('record_length',4,'!i'),   # Record length in bytes
  ('number_records',4,'!i'),  # number of records
  ('Read_start',4,'!i'),      # For partial reads, 1st read line
  ('IP_num',4,'!i'),          # Which imaging plate 1, 2 ?
  ('Ratio',4,'!f'),           # Output ratio for high value pixels
  ('Fading_start',4,'!f'),    # Fading time to start of read
  ('Fading_end',4,'!f'),      # Fading time to end of read
  ('computer',10,'s'),        # Type of computer "IRIS", "VAX", "SUN", etc
  ('plate_type',10,'s'),      # Type of IP
  ('Dr',4,'!i'),
  ('Dx',4,'!i'),
  ('Dz',4,'!i'),              # IP scanning codes??
  ('PixShiftOdd',4,'!f'),     # Pixel shift to odd lines
  ('IntRatioOdd',4,'!f'),     # Intensity ratio to odd lines
  ('MagicNum',4,'!i'),        # Magic number to indicate next values are legit
  ('NumGonAxes',4,'!i'),      # Number of goniometer axes
  ('a5x3fGonVecs',60,'!fffffffffffffff'),# Goniometer axis vectors
  ('a5fGonStart',20,'!fffff'),# Start angles for each of 5 axes
  ('a5fGonEnd',20,'!fffff'),  # End angles for each of 5 axes
  ('a5fGonOffset',20,'!fffff'),# Offset values for each of 5 axes
  ('ScanAxisNum',4,'!i'),     # Which axis is the scan axis?
  ('AxesNames',40,'s'),       # Names of the axes (space or comma separated?)'''
]
class Raxis(object):
  def __init__(self,file):
    self.file = file

  def readHeader(self,verbose=0):
    with open(self.file,'rb') as F:
      self.head={}
      seek = 0
      for item in header_struct:
        if item[0]==None:
          F.read(item[1])
        elif item[2]=='s':
          self.head[item[0]]=F.read(item[1])[0:item[1]]
          if verbose:print(item[0],self.head[item[0]])
        elif len(item[2])>2:
          rawdata = F.read(item[1])
          assert len(rawdata)==struct.calcsize(item[2])
          self.head[item[0]] = struct.unpack(item[2],rawdata)
          if verbose:print(item[0],self.head[item[0]])
        else:
          rawdata = F.read(item[1])
          assert len(rawdata)==struct.calcsize(item[2])
          self.head[item[0]] = struct.unpack(item[2],rawdata)[0]
          if verbose:print(item[0],self.head[item[0]])
        seek+=item[1]

  def data(self):
    Dim0 = self.head['nFast'] #number of fast pixels
    ToRead = self.head['record_length']
    ReadLines = self.head['number_records']

    with open(self.file,'rb') as F:
      F.seek(ToRead)
      raw_data = F.read(ToRead * ReadLines)

    # For a normal image, there should be no padding per line
    # Each line might be padded, so figure this out
    BytesPerLine = Dim0 * 2;
    if BytesPerLine < ToRead:
      # Remove all padding bytes
      raw_data = b"".join(
        raw_data[record * ToRead : record * ToRead + BytesPerLine]
        for record in range(ReadLines)
      )

    self.CharTemp = raw_data

  def dump(self):
    ptr = 0
    for x in range(0,len(CharTemp),2):
      unsigned_int = struct.unpack( "!H",self.CharTemp[x:x+2] )[0]
      if unsigned_int <= 32767:
        print(float(unsigned_int))
      else:
        print(( float(unsigned_int)+32768.0 ) * self.head['Ratio'])

if __name__=='__main__':
  R = Raxis('H-x071_0001.osc')
  R.readHeader()
  R.data()
  R.dump()


 *******************************************************************************


 *******************************************************************************
iotbx/detectors/saturn.py
from __future__ import absolute_import, division, print_function
import re
from iotbx.detectors.adsc import ADSCImage
from iotbx.detectors.detectorbase import DetectorImageBase

INT = (int,)
FLOAT = (float,)
STR = (str,)

class SaturnImage(ADSCImage):
  def __init__(self,filename):
    DetectorImageBase.__init__(self,filename)
    self.vendortype = "RigakuSaturn"

  def getTupleofType(self,inputstr,typefunc):
    parsed = inputstr.split(' ')
    return [typefunc(I) for I in parsed if I != '']

  def readHeader(self,maxlength=6144):
    if not self.parameters:
      with open(self.filename,"rb") as fh:
        rawdata = fh.read(maxlength)
      headeropen = rawdata.index(b"{")
      headerclose = rawdata.index(b"}")
      self.header = rawdata[headeropen+1:headerclose-headeropen].decode("latin-1")

      self.parameters={}
      for tag,search,datatype in [
          ('CCD_IMAGE_SATURATION','SATURATED_VALUE',float),
          ('HEADER_BYTES','HEADER_BYTES',int),
          ('BitmapSize','BitmapSize',int),
          ('SIZE1','SIZE1',int),
          ('SIZE2','SIZE2',int),
          ('CCD_DETECTOR_DESCRIPTION','CCD_DETECTOR_DESCRIPTION',str),
          ('CCD_DETECTOR_DIMENSIONS','CCD_DETECTOR_DIMENSIONS',INT),
          ('CCD_DETECTOR_SIZE','CCD_DETECTOR_SIZE',FLOAT),
          ('CCD_GONIO_DESCRIPTION','CCD_GONIO_DESCRIPTION',str),
          ('CCD_GONIO_NAMES','CCD_GONIO_NAMES',STR),
          ('CCD_GONIO_NUM_VALUES','CCD_GONIO_NUM_VALUES',int),
          ('CCD_GONIO_UNITS','CCD_GONIO_UNITS',str),
          ('CCD_GONIO_VALUES','CCD_GONIO_VALUES',FLOAT),
          ('CCD_GONIO_VALUES_MAX','CCD_GONIO_VALUES_MAX',FLOAT),
          ('CCD_GONIO_VALUES_MIN','CCD_GONIO_VALUES_MIN',FLOAT),
#          ('PIXEL_SIZE','PIXEL_SIZE',float),
#          ('OSC_START','OSC_START',float),
#          ('DISTANCE','DISTANCE',float),
          ('WAVELENGTH','SCAN_WAVELENGTH',float),
          ('CCD_SPATIAL_BEAM_POSITION','CCD_SPATIAL_BEAM_POSITION',FLOAT),
#          ('BEAM_CENTER_X',r'\nBEAM_CENTER_X',float),
#          ('BEAM_CENTER_Y',r'\nBEAM_CENTER_Y',float),
#          ('OSC_RANGE','OSC_RANGE',float),
#          ('TWOTHETA','TWOTHETA',float),
          ('BYTE_ORDER','BYTE_ORDER',str),
          ('AXIS','ROTATION_AXIS_NAME',str),
#          ('PHI','PHI',float),
#          ('OMEGA','OMEGA',float),
          ('DATE','DTREK_DATE_TIME',str),
          ('ROTATION',r'\nROTATION',FLOAT),
          ]:
          matches = re.findall(search+'='+r'(.*);', self.header)
          if len(matches)>0:
            if type(datatype) == type((0,1)):
              self.parameters[tag] = self.getTupleofType(
                matches[-1],datatype[0])
            else:
              self.parameters[tag] = datatype(matches[-1])
      assert self.parameters['CCD_DETECTOR_DESCRIPTION'].find('Saturn')>=0
      assert self.parameters['CCD_DETECTOR_DIMENSIONS'][0]==self.size1
      self.parameters['PIXEL_SIZE'] = self.parameters['CCD_DETECTOR_SIZE'
        ][0] / self.size1
      # rounding to hundreth of degree since encoder reports six (too many) decimal places
      self.parameters['OSC_START'] = round(self.parameters['ROTATION'][0],2)
      assert self.parameters['CCD_GONIO_NAMES'][5]=='Distance'
      self.parameters['DISTANCE'] = self.parameters['CCD_GONIO_VALUES'][5]
      self.parameters['BEAM_CENTER_X'] = self.parameters[
        'CCD_SPATIAL_BEAM_POSITION'][0] * self.pixel_size
      self.parameters['BEAM_CENTER_Y'] = self.parameters[
        'CCD_SPATIAL_BEAM_POSITION'][1] * self.pixel_size
      self.parameters['OSC_RANGE'] = round(self.parameters[
        'ROTATION'][1] - self.parameters['ROTATION'][0],2)
      assert self.parameters['CCD_GONIO_NAMES'][1]=='2Theta'
      self.parameters['TWOTHETA'] = self.parameters['CCD_GONIO_VALUES'][2]

  def read(self):
    from iotbx.detectors import ReadRAXIS
    with open(self.filename,'rb') as fh:
      fh.seek(self.dataoffset())
      chardata = fh.read(self.size1 * self.size2 * self.integerdepth() )
    self.bin_safe_set_data( ReadRAXIS(chardata,self.dataoffset(),
         self.size1*self.bin,self.size2*self.bin,
         self.endian_swap_required())
    )

if __name__=='__main__':
  import sys
  i = sys.argv[1]
  a = SaturnImage(i)
  a.readHeader()
  a.read()


 *******************************************************************************


 *******************************************************************************
iotbx/detectors/test_mar.py
from __future__ import absolute_import, division, print_function
import sys

class ImageWorker(object):
  def __init__(self,relpath):
    from iotbx.detectors import mar
    m = mar.MARImage(relpath)
    m.read()
    self.fi = m.get_flex_image()
    self.fi.setWindow(1.0) #fraction of original image dimension written to graphics display
    self.fi.adjust()

  def output(self,outputfile):
    import PIL.Image # dependency on Python Image Library
    im = PIL.Image.new("RGB",(self.fi.ex_size1(), self.fi.ex_size2())) # 'L' is grayscale
    r,g,b = im.split()
    r.putdata(self.fi.channel(0))
    g.putdata(self.fi.channel(1))
    b.putdata(self.fi.channel(2))
    imageout = PIL.Image.merge("RGB",(r,g,b))
    imageout.save(outputfile,"PNG")

if __name__=='__main__':
  infile = sys.argv[1]
  outfile = "/net/racer/scratch1/ttleese/test2.png"
  I = ImageWorker(infile)
  print("Finished read")
  I.output(outfile)
  print("Finished write")


 *******************************************************************************


 *******************************************************************************
iotbx/detectors/test_raxis2.py
from __future__ import absolute_import, division, print_function
# basic test reading an Raxis II image & producing a png file
# requires LABELIT and Python Image Library
# future: remove the LABELIT dependency

from six.moves import StringIO
import sys

if (__name__ == "__main__"):
  from labelit.command_line.overlay_distl import OverlayDriverClass

  filnm = sys.argv[1] # raxis-2 *.osc file
  out = sys.argv[2] # *.png file for graphical output

  ODC = OverlayDriverClass(filnm)
  ODC.pd={'xbeam':ODC.I.a.parameters['BEAM_CENTER_X'],
          'ybeam':ODC.I.a.parameters['BEAM_CENTER_Y'],
          'pixel_size':ODC.I.a.parameters['PIXEL_SIZE']}
  ODC.beam_overlay()
  ioout = StringIO()
  ODC.I.output(ioout)
  g = open(out,"wb")
  g.write(ioout.getvalue())
  g.close()


 *******************************************************************************


 *******************************************************************************
iotbx/detectors/tst_adsc.py
from __future__ import absolute_import, division, print_function
from iotbx.detectors import adsc
from libtbx.test_utils import approx_equal
import os
import bz2

adsc_file = 'adsc.img'
adsc_file_bz2 = 'adsc.img.bz2'
# file originally from
# http://cci.lbl.gov/cctbx_downloads/regression/iotbx/adsc.img

adsc_file = os.path.join(os.path.dirname(os.path.realpath(__file__)), adsc_file)
adsc_file_bz2 = os.path.join(os.path.dirname(os.path.realpath(__file__)), adsc_file_bz2)

def exercise_adscread():
  if (not os.path.isfile(adsc_file)):
    if (not os.path.isfile(adsc_file_bz2)):
      print("Skipping exercise_adscread(): input file not available")
      return
    with open(adsc_file, 'wb') as orig, bz2.BZ2File(adsc_file_bz2, 'rb') as comp:
      for data in iter(lambda : comp.read(100 * 1024), b''):
        orig.write(data)

  a = adsc.ADSCImage(adsc_file)
  a.read()
  assert a.size1 == 2304
  assert a.size2 == 2304
  assert a.npixels == 5308416
  assert approx_equal(a.pixel_size, 0.0816)
  assert a.saturation == 65535
  assert approx_equal(a.osc_start, 0)

def run():
  exercise_adscread()
  print("OK")

if __name__=="__main__":
  run()


 *******************************************************************************


 *******************************************************************************
iotbx/detectors/tst_cbf_comp_read_meth.py
from __future__ import absolute_import, division, print_function
# test comparative read methods for cbf library
# default method provided by CBFlib-0.8.1; second method is optimized read
import os
from libtbx.development.timers import Profiler
cases = ["ana/myo2_3_00001.cbf",
"insulin2009/insu_before_1_00001.cbf",
"insulin2009/insu_before_1_00262.cbf",
"insulin2009/insu_before_1_00093.cbf",
"insulin2009/insu_before_1_00112.cbf",
"insulin2009/insu_before_1_00200.cbf",
"pilatus.web.psi.ch_insulin_0.2/DATA/DATASETS/insulin_0.2/run2_1_00052.cbf",
"pilatus.web.psi.ch_insulin_0.2/DATA/DATASETS/insulin_0.2/run2_1_00010.cbf",
"pilatus.web.psi.ch_insulin_0.2/DATA/DATASETS/insulin_0.2/run2_1_00149.cbf",
"pilatus.web.psi.ch_insulin_0.2/DATA/DATASETS/insulin_0.2/run2_1_00167.cbf",
"ribosome/images/colD55A_13_1_00172.cbf",
"ribosome/images/colD55A_13_2_00276.cbf",
"ribosome/images/colD55A_13_1_00227.cbf",
"ribosome/images/colD55A_13_2_00071.cbf",
"ribosome/images/colD55A_13_1_00336.cbf",
"ribosome/images/colD55A_13_2_00225.cbf",
"ribosome/images/colD55A_13_1_00022.cbf",
"ribosome/images/colD55A_13_2_00085.cbf",
"ribosome/G817_1_00002.cbf",
"ribosome/G817_2_00001.cbf",
"pilatus_2M_graeme/insulin_1_fixed_0043.img",
"pilatus_2M_graeme/insulin_1_fixed_0289.img",
]

def generate_paths(dirpath):
  for item in cases:
    file = os.path.join(dirpath,item)
    yield file

def test_all(dirpath,timer=False):
  for file in generate_paths(dirpath):
    from iotbx.detectors.pilatus_minicbf import PilatusImage
    if timer: print (os.path.basename(file))
    P = PilatusImage(file)
    if timer: G = Profiler("cbflib no-opt    read")
    P.read(algorithm="cbflib")
    read1 = P.linearintdata
    if timer: G = Profiler("cbflib optimized read")
    P.linearintdata = None #won't read again without resetting first
    P.read(algorithm="cbflib_optimized")
    read2 = P.linearintdata
    if timer: G = Profiler("buffer-based read")
    P.linearintdata = None #won't read again without resetting first
    P.read(algorithm="buffer_based")
    read3 = P.linearintdata
    if timer: del G
    expected_image_size = {"Pilatus-6M":(2527,2463),
                           "Pilatus-2M":(1679,1475),
                           "Pilatus-300K":(619,487)}[P.vendortype]
    assert read1.accessor().focus() == read2.accessor().focus() == expected_image_size
    from cbflib_adaptbx import assert_equal
    #print "Equality of arrays from two decompress methods", assert_equal(read1,read2), "\n"
    assert assert_equal(read1,read2)
    assert assert_equal(read1,read3)

if __name__=="__main__":
  test_all(dirpath=".",timer=False)
  print ("OK")


 *******************************************************************************


 *******************************************************************************
iotbx/detectors/tst_debug_write.py
from __future__ import absolute_import, division, print_function
from six.moves import range
import os,math
from libtbx.test_utils import approx_equal
from scitbx.array_family import flex
from iotbx.detectors import adsc
from iotbx.detectors.detectorbase import DetectorImageBase

filesize=64
filename='debug_wtest_001.img'

def sinfunc(x):
  return math.sin(math.pi*x/32)

def exercise_debug_write():
  #---------Write out a test file
  D = DetectorImageBase('no_file')
  D.parameters = {'SIZE1':filesize,
                  'SIZE2':filesize,
                  'PIXEL_SIZE':0.1,
                  'DISTANCE':100.0,
                  'TWOTHETA':0.0,
                  'OSC_START':0.0,
                  'OSC_RANGE':1.0,
                  'WAVELENGTH':1.0,
                  'BEAM_CENTER_X':12.5,
                  'BEAM_CENTER_Y':12.5,
  }
  def getEndian():
    return 0
  D.getEndian = getEndian
  sindata = flex.int()
  for x in range(filesize):
    sindata.append(min(255,abs(int(256*sinfunc(x)))))
  moddata = flex.int()
  accum = 0
  for x in range(filesize):
    for y in range(filesize):
      value = sindata[x]*sindata[y]
      moddata.append(value)
      accum+=value
  D.debug_write(filename,mod_data=moddata)

  #---------Read back the test file
  a = adsc.ADSCImage(filename)
  a.read()
  assert a.size1 == filesize
  assert a.size2 == filesize
  assert a.npixels == filesize*filesize
  assert approx_equal(a.pixel_size, 0.1)
  assert approx_equal(a.osc_start, 0)
  checkaccum = 0
  for x in range(a.npixels):
    if moddata[x]!=a.linearintdata[x]:
      print(x,moddata[x],a.linearintdata[x])
    checkaccum+=a.linearintdata[x]
  assert accum == checkaccum
  os.remove(filename)

def run():
  exercise_debug_write()
  print("OK")

if __name__=="__main__":
  run()


 *******************************************************************************


 *******************************************************************************
iotbx/detectors/tst_detectors.py
from __future__ import absolute_import, division, print_function
def tst_detectors():
    import libtbx.load_env
    import os

    image_directory = libtbx.env.find_in_repositories(
        relative_path = 'bpcx_regression/use_case_xds_method')
    if not image_directory:
        print('bpcx_regression not configured, skipping test')
        return

    import iotbx.detectors
    f = iotbx.detectors.ImageFactory(
        os.path.join(image_directory, 'thau2_O0_K0_P0_1_0001.cbf'))
    f.read()
    length = len(f.get_raw_data())
    fi = f.get_flex_image()
    assert(length == fi.size1() * fi.size2())
    print('OK')

if __name__ == '__main__':
    tst_detectors()


 *******************************************************************************


 *******************************************************************************
iotbx/detectors/tst_py_cbf.py
from __future__ import absolute_import, division, print_function
from six.moves import range
import six
import iotbx.cif
import sys, email.parser, copy, hashlib, base64
from cbflib_adaptbx import uncompress,assert_equal
from iotbx.detectors.detectorbase import DetectorImageBase

class cif_binary_section:
  endline = "\r\n"
  pattern = "--CIF-BINARY-FORMAT-SECTION--"
  init_boundary = endline + pattern + endline
  final_boundary = endline + pattern + "--" + endline
  binary_string_separator=endline + endline
  if six.PY2:
    cbf_signature = chr(0x0C)+chr(0x1A)+chr(0x04)+chr(0xD5)
  else:
    cbf_signature = bytes([0x0C,0x1A,0x04,0xD5]) # Python 3 idiom

  def from_compressed_string(self,data,init,final):
    section_start = init + len(self.init_boundary)
    section_stop = final
    #offsets for section data, numbering is on the original file string
    self.init = init
    self.final = final

    divide = data.find(self.binary_string_separator.encode(),section_start,section_stop)
    assert divide > 0 # binary section consists of a header and data
    header = data[section_start:divide]

    self.header_dic = email.parser.Parser().parsestr(header.decode())
    assert self.header_dic["Content-Type"].find("x-CBF_BYTE_OFFSET")>0

    bin_start = divide + len(self.binary_string_separator)
    assert data[bin_start:bin_start+4]==self.cbf_signature
    self.data = data[bin_start+4:section_stop]
    self.data_type = "compressed"

    m = hashlib.md5()
    m.update(self.data)
    derived_digest = base64.b64encode(m.digest())
    assert self.header_dic["Content-MD5"] == derived_digest.decode() # converts to str

    self.size_fast = int(self.header_dic["X-Binary-Size-Fastest-Dimension"])
    self.size_slow = int(self.header_dic["X-Binary-Size-Second-Dimension"])
    total_elements = int(self.header_dic["X-Binary-Number-of-Elements"])
    compressed_size = int(self.header_dic["X-Binary-Size"])
    assert total_elements==self.size_fast*self.size_slow
    assert compressed_size==len(self.data)

    return self

  def uncompress_in_place(self):
    if self.data_type == "compressed":
      decompressed_data = uncompress(packed=self.data, fast=self.size_fast, slow=self.size_slow)
      self.data = decompressed_data
      self.data_type = "uncompressed"
    assert self.data_type=="uncompressed"
    return self.data

  def show(self):
    print(self.header_dic)

def get_binary_sections(raw):
  return_sections = []
  ptr = 0
  end = len(raw)
  oldinit = 0
  oldfinal = 0

  while ptr < end:
    init = raw.find(cif_binary_section.init_boundary.encode(), oldinit+1)
    if init==-1: break
    assert init > oldfinal

    final = raw.find(cif_binary_section.final_boundary.encode(), init)
    assert final > init

    return_sections.append(cif_binary_section().from_compressed_string(raw,init,final))
    oldinit = copy.copy(init)
    oldfinal = copy.copy(final)
    ptr = copy.copy(oldfinal)

  return return_sections

def get_header_sections(raw,binary_sections):
  provisional_slices = [(0,len(raw))]
  for i,section in enumerate(binary_sections):
    first = (provisional_slices[i][0],section.init)
    last = (section.final+len(cif_binary_section.final_boundary),provisional_slices[i][1])
    provisional_slices[i]=first
    provisional_slices.append(last)

  if six.PY2:
    return cif_binary_section.endline.join([raw[s[0]:s[1]] for s in provisional_slices])
  else:
    return cif_binary_section.endline.join([raw[s[0]:s[1]].decode() for s in provisional_slices])

class Goniometer:
  def __init__(self,model):
    #problem to report back to Richard Gildea; not possible to print model["_diffrn_measurement"]
    axis_id = model["_diffrn_measurement_axis.axis_id"]

    #get the PHI axis setting
    row_idx = [str(a) for a in model["_diffrn_scan_frame_axis.axis_id"]].index(axis_id)
    self.osc_start = float(model["_diffrn_scan_frame_axis.angle"][row_idx])

    row_idx = [str(a) for a in model["_diffrn_scan_axis.axis_id"]].index(axis_id)
    self.osc_range = float(model["_diffrn_scan_axis.angle_increment"][row_idx])

def get_ad_hoc_beam(model):
    row_idx = [str(a) for a in model["_axis.id"]].index("ELEMENT_X")
    beamx = float(model["_axis.offset[2]"][row_idx])
    beamy = -float(model["_axis.offset[1]"][row_idx])
    return beamx,beamy

from iotbx.detectors.cbf import CBFImage
class pyCBFImage(CBFImage):
  def __init__(self, file_name):
    DetectorImageBase.__init__(self, file_name)
    raw = open(file_name, "rb").read()
    self.binary_sections = get_binary_sections(raw)
    self.header_sections = get_header_sections(raw, self.binary_sections)

    assert len(self.binary_sections)==1

    cif = iotbx.cif.fast_reader(input_string=self.header_sections)
    self.cif_model = cif.model()
    im1 = self.cif_model["image_1"]

    self.vendortype = "CBF"
    self.readHeader()

  def readHeader(self):
    model = self.cif_model["image_1"]
    binaries = self.binary_sections
    goniometer = Goniometer(model)
    ad_hoc_beam = get_ad_hoc_beam(model)

    self.parameters = {'SIZE1': binaries[0].size_fast, #not sure about precedence; implement later
                       'SIZE2': binaries[0].size_slow,
                       'CCD_IMAGE_SATURATION':int(model["_array_intensities.overload"]),
                       'PIXEL_SIZE':self.cbf_simple_py_get_pixel_size(model),
                       'OSC_START':goniometer.osc_start,
                       'DISTANCE':float(model["_diffrn_measurement.sample_detector_distance"]),
                       'WAVELENGTH':self.cbf_simple_py_get_wavelength(model),

                       #Ad-hoc implementation to get a quick beam center.  This is valid
                       #only for winter/diamond dataset; a general implementation will be needed.
                       'BEAM_CENTER_X':ad_hoc_beam[0],
                       'BEAM_CENTER_Y':ad_hoc_beam[1],
                       'OSC_RANGE':goniometer.osc_range,
                       'TWOTHETA':0.0,  #non-zero twotheta not supported (yet)!
                       'DETECTOR_SN':0
                       }
    self.binaries = binaries

  def read(self):
    assert len(self.binaries)==1
    self.linearintdata = self.binaries[0].uncompress_in_place()

  def cbf_simple_py_get_pixel_size(self,model):
    element_number = 0 # used in C version; not implemented in py version (yet)
    axis_number = 1
    array_id = model["_diffrn_data_frame.array_id"]

    #Given the input axis_number, look in the array_structure_list
    #  Table to find the index of the axis whose precedence==axis_number,
    #  for the correct array_id
    array_mask = model["_array_structure_list.array_id"]==array_id
    precedence = [int(a) for a in model["_array_structure_list.precedence"]]
    for i in range(len(array_mask)):
      if not array_mask[i]: precedence[i]=0
    idx = precedence.index(axis_number)
    axis_index = int( model["_array_structure_list.index"][idx] )
    assert axis_index > 0

    #Now find the array element size for the given axis_index
    array_mask = model["_array_element_size.array_id"]==array_id
    index_array = [int(a) for a in model["_array_element_size.index"]]
    for i in range(len(array_mask)):
      if not array_mask[i]: index_array[i]=0
    size_index = index_array.index(axis_index)

    pixel_size = 1000. * float(model["_array_element_size.size"][size_index])
    return pixel_size

  def cbf_simple_py_get_wavelength(self,model):
    return float(model["_diffrn_radiation_wavelength.wavelength"])

def run(file_name):
  from libtbx.test_utils import approx_equal
  py_image_obj = pyCBFImage(file_name)
  py_image_obj.read()
  c_image_obj = CBFImage(file_name)
  c_image_obj.read()
  assert_equal(py_image_obj.linearintdata, c_image_obj.linearintdata)
  assert py_image_obj.size1 == c_image_obj.size1
  assert py_image_obj.size2 == c_image_obj.size2
  assert approx_equal(py_image_obj.saturation, c_image_obj.saturation)
  assert approx_equal(py_image_obj.pixel_size, c_image_obj.pixel_size)
  assert approx_equal(py_image_obj.osc_start, c_image_obj.osc_start)
  assert approx_equal(py_image_obj.deltaphi, c_image_obj.deltaphi)
  assert approx_equal(py_image_obj.wavelength, c_image_obj.wavelength)
  assert approx_equal(py_image_obj.distance, c_image_obj.distance)
  assert approx_equal(py_image_obj.beamx, c_image_obj.beamx)
  assert approx_equal(py_image_obj.beamy, c_image_obj.beamy)

if (__name__ == "__main__"):
  args = sys.argv[1:]
  for file_name in args:
    #print file_name
    run(file_name)
  print("OK")


 *******************************************************************************


 *******************************************************************************
iotbx/detectors/url_support.py
from __future__ import absolute_import, division, print_function
class potential_url_request:
  def __init__(self,text):
    self.text = text

  def is_url_request(self):
    #backward compatibility with Python 2.5
    try: from urlparse import parse_qs
    except Exception: from cgi import parse_qs

    from urlparse import urlparse
    try:
      self.parsed = urlparse(self.text)
    except Exception:
      return False

    if self.parsed.scheme in [None, ""]: return False
    self.file = self.parsed.path.split("?")[0]

    if "?" in self.parsed.path: #i.e., for file scheme, the query string is not
                          # supported. It shows up in the path instead.
      self.qs = parse_qs(self.parsed.path.split("?")[1])
    return True


 *******************************************************************************


 *******************************************************************************
iotbx/detectors/util/__init__.py


 *******************************************************************************


 *******************************************************************************
iotbx/detectors/util/filters.py
from __future__ import absolute_import, division, print_function
from six.moves import range
import math,copy
from scitbx.array_family import flex
from iotbx.detectors import low_pass_filter
from libtbx import adopt_init_args

def get_factorizable_block(asic):
  input1 = asic[2]-asic[0]
  input2 = asic[3]-asic[1]
  return (asic[0],asic[1],asic[0]+primecheck_minus(input1),
                          asic[1]+primecheck_minus(input2))

def primecheck_minus(input_m):
  residual = copy.copy(input_m)
  return_m = input_m
  while (residual%2==0): residual//=2;
  while (residual%3==0): residual//=3;
  while (residual%5==0): residual//=5;
  if (residual>1):
    return_m = primecheck_minus(return_m-1);
  return return_m;

def primecheck_plus(input_m):
  residual = copy.copy(input_m)
  return_m = input_m
  while (residual%2==0): residual//=2;
  while (residual%3==0): residual//=3;
  while (residual%5==0): residual//=5;
  if (residual>1):
    return_m = primecheck_plus(return_m+1);
  return return_m;

def hi_pass_filter(complex_data):

  sz_x = complex_data.focus()[0]
  sz_y = complex_data.focus()[1]
  for x in range(sz_x):
    #dx = min(x,sz_x-x)
    dx = abs((sz_x/2)-x)
    for y in range(sz_y):
      #dy = min(y,sz_y-y)
      dy = abs((sz_y/2)-y)
      dist = math.hypot(dx,dy)
      if dist<100.:  complex_data[(x,y)]=complex(0.,0.)
      #else:
      #  complex_data[(x,y)]*=math.exp(-dist*dist/20.)

class padded_unpadded:
  def __init__(self, data, asic):
    adopt_init_args(self,locals())

    padding = 10 # minimum padding pixels on each side
    self.input1 = input1 = asic[2]-asic[0]
    self.input2 = input2 = asic[3]-asic[1]

    self.size1 = size1 = primecheck_plus(input1+2*padding)
    self.leading1 = (size1-input1)//2
    self.trailing1 = size1-self.leading1-input1

    self.size2 = size2 = primecheck_plus(input2+2*padding)
    self.leading2 = (size2-input2)//2
    self.trailing2 = size2-self.leading2-input2

  def get_padded_input_data(self):
    result = self.data.__class__(flex.grid(self.size1,self.size2))

    result.matrix_paste_block_in_place(
      block = self.data.matrix_copy_block(
        i_row=self.asic[0],i_column=self.asic[1],
        n_rows=self.input1,
        n_columns=self.input2),
      i_row = self.leading1,
      i_column = self.leading2
    )

    leading_line = result.matrix_copy_block(
      i_row=self.leading1,i_column=0,n_rows=1,n_columns=self.size2)
    for irow in range(self.leading1):
      result.matrix_paste_block_in_place(
        block = leading_line,i_row=irow,i_column=0)

    trailing_line = result.matrix_copy_block(
      i_row=self.size1-self.trailing1-1,i_column=0,n_rows=1,n_columns=self.size2)
    for irow in range(self.trailing1):
      result.matrix_paste_block_in_place(
        block = trailing_line,i_row=self.size1-self.trailing1+irow,i_column=0)

    leading_line = result.matrix_copy_block(
      i_row=0,i_column=self.leading2,n_rows=self.size1,n_columns=1)
    for icolumn in range(self.leading2):
      result.matrix_paste_block_in_place(
        block = leading_line,i_row=0,i_column=icolumn)

    trailing_line = result.matrix_copy_block(
      i_row=0, i_column=self.size2-self.trailing2-1,n_rows=self.size2,n_columns=1)
    for icolumn in range(self.trailing2):
      result.matrix_paste_block_in_place(
        block = trailing_line,i_row=0, i_column=self.size2-self.trailing2+icolumn)

    return result

  def get_unpadded_result_data(self,corrected_data):
    return corrected_data.matrix_copy_block(
        i_row=self.leading1,i_column=self.leading2,
        n_rows=self.input1,
        n_columns=self.input2)

def background_correct_padded_block(data, raw_asic):

  Pad = padded_unpadded(data,raw_asic)

  block = Pad.get_padded_input_data()

  complex_data = flex.polar(block.as_double(),flex.double(flex.grid(block.focus())))
  from scitbx import fftpack
  fft = fftpack.complex_to_complex_2d(block.focus())
  # input data here
  fft.forward(complex_data)
  # your manipulation here
  low_pass_filter(complex_data)

  fft.backward(complex_data)
  # real data
  filtered_data = flex.real(complex_data)/(fft.n()[0]*fft.n()[1])
  # XXX change this depending on float/int data type:
  corrected_data = block - filtered_data.iround()

  return Pad.get_unpadded_result_data(corrected_data)

def background_correct(data, raw_asic):

  prime_asic = get_factorizable_block(raw_asic)
  print("Working on block",prime_asic)
  block = data.matrix_copy_block(
      i_row=prime_asic[0],i_column=prime_asic[1],
      n_rows=prime_asic[2]-prime_asic[0],
      n_columns=prime_asic[3]-prime_asic[1])

  complex_data = flex.polar(block.as_double(),flex.double(flex.grid(block.focus())))
  from scitbx import fftpack
  fft = fftpack.complex_to_complex_2d(block.focus())
  # input data here
  fft.forward(complex_data)
  # your manipulation here
  low_pass_filter(complex_data)

  fft.backward(complex_data)
  # real data
  filtered_data = flex.real(complex_data)/(fft.n()[0]*fft.n()[1])
  corrected_data = block - filtered_data.iround()

  requested_block = data.matrix_copy_block(
      i_row=raw_asic[0],i_column=raw_asic[1],
      n_rows=raw_asic[2]-raw_asic[0],
      n_columns=raw_asic[3]-raw_asic[1])
  requested_block.matrix_paste_block_in_place(
      block = corrected_data,
      i_row = prime_asic[0] - raw_asic[0],
      i_column = prime_asic[1] - raw_asic[1]
      )

  return requested_block


 *******************************************************************************
