

 *******************************************************************************
mmtbx/rotamer/__init__.py
from __future__ import absolute_import, division, print_function

def iterator(mon_lib_srv, residue, atom_selection_bool):
  atoms = residue.atoms()
  if (atom_selection_bool is not None):
    if (atom_selection_bool.select(
          indices=residue.atoms().extract_i_seq()).all_eq(False)):
      return None
  rotamer_iterator = mon_lib_srv.rotamer_iterator(
    comp_id=residue.resname,
    atom_names=residue.atoms().extract_name(),
    sites_cart=residue.atoms().extract_xyz())
  if (rotamer_iterator is None):
    return None
  if (rotamer_iterator.problem_message is not None):
    return None
  if (rotamer_iterator.rotamer_info is None):
    return None
  return rotamer_iterator

def improper_ncab_from_atoms(thisN, thisC, thisCA, thisCB):
  assert (not None in [thisN, thisC, thisCA, thisCB])
  return phi_from_sites(thisN.xyz, thisC.xyz, thisCA.xyz, thisCB.xyz)

def improper_cnab_from_atoms(thisC, thisN, thisCA, thisCB):
  assert (not None in [thisC, thisN, thisCA, thisCB])
  return phi_from_sites(thisC.xyz, thisN.xyz, thisCA.xyz, thisCB.xyz)

def omega_from_atoms(prevCA, prevC, thisN, thisCA):
  assert (not None in [prevCA, prevC, thisN, thisCA])
  return phi_from_sites(prevCA.xyz, prevC.xyz, thisN.xyz, thisCA.xyz)

def get_phi_psi_atoms(prev_res, residue, next_res):
  c1, n2, ca2, c2, n3 = None, None, None, None, None
  for atom in prev_res.atoms():
    if (atom.name == " C  "):
      c1 = atom
      break
  for atom in residue.atoms():
    if (atom.name == " N  "):
      n2 = atom
    elif (atom.name == " CA "):
      ca2 = atom
    elif (atom.name == " C  "):
      c2 = atom
  for atom in next_res.atoms():
    if (atom.name == " N  "):
      n3 = atom
  return (c1, n2, ca2, c2, n3)

def get_omega_atoms(prev_atoms, atoms):
  prevCA, prevC, thisN, thisCA = None, None, None, None
  if (prev_atoms is not None):
    for atom in prev_atoms:
      if (atom.name == " CA "): prevCA = atom
      if (atom.name == " C  "): prevC = atom
  if (atoms is not None):
    for atom in atoms:
      if (atom.name == " N  "): thisN = atom
      if (atom.name == " CA "): thisCA = atom
  return prevCA, prevC, thisN, thisCA

def is_cis_peptide(prev_atoms, atoms):
  prevCA, prevC, thisN, thisCA = get_omega_atoms(prev_atoms, atoms)
  if (not None in [ prevCA, prevC, thisN, thisCA]):
    omega = omega_from_atoms(prevCA, prevC, thisN, thisCA)
    if(omega > -30 and omega < 30):
      return True
  return False

def get_phi_psi_indices(prev_res, residue, next_res):
  (c1, n2, ca2, c2, n3) = get_phi_psi_atoms(
    prev_res=prev_res,
    residue=residue,
    next_res=next_res)
  if (not None in [c1, n2, ca2, c2, n3]):
    return [c1.i_seq, n2.i_seq, ca2.i_seq, c2.i_seq, n3.i_seq]
  return [None] * 5

def phi_from_atoms(prevC, resN, resCA, resC):
  assert (not None in [prevC, resN, resCA, resC])
  return phi_from_sites(prevC.xyz, resN.xyz, resCA.xyz, resC.xyz)

def phi_from_sites(prevC, resN, resCA, resC):
  from cctbx import geometry_restraints
  b = geometry_restraints.bond(
    sites=[prevC,resN],
    distance_ideal=1,
    weight=1)
  # check to see if residues are actually bonded.
  if (b.distance_model > 4): return None
  d = geometry_restraints.dihedral(
    sites=[prevC,resN,resCA,resC],
    angle_ideal=-40,
    weight=1)
  return d.angle_model

def psi_from_atoms(resN, resCA, resC, nextN):
  assert (not None in [resN, resCA, resC, nextN])
  return psi_from_sites(resN.xyz, resCA.xyz, resC.xyz, nextN.xyz)

def psi_from_sites(resN, resCA, resC, nextN):
  from cctbx import geometry_restraints
  b = geometry_restraints.bond(
    sites=[resC,nextN],
    distance_ideal=1,
    weight=1)
  if (b.distance_model > 4): return None
  d = geometry_restraints.dihedral(
    sites=[resN,resCA,resC,nextN],
    angle_ideal=-40,
    weight=1)
  return d.angle_model

def phi_psi_from_sites(i_seqs, sites_cart):
  assert (not None in i_seqs) and (len(i_seqs) == 5)
  phi = phi_from_sites(
    prevC=sites_cart[i_seqs[0]],
    resN=sites_cart[i_seqs[1]],
    resCA=sites_cart[i_seqs[2]],
    resC=sites_cart[i_seqs[3]])
  psi = psi_from_sites(
    resN=sites_cart[i_seqs[1]],
    resCA=sites_cart[i_seqs[2]],
    resC=sites_cart[i_seqs[3]],
    nextN=sites_cart[i_seqs[4]])
  return (phi, psi)


 *******************************************************************************


 *******************************************************************************
mmtbx/rotamer/graphics.py

from __future__ import absolute_import, division, print_function
from iotbx.data_plots import simple_matplotlib_plot

class rotarama_plot_mixin(object):
  extent = [0, 360, 0, 360]
  def __init__(self):
    assert hasattr(self, "figure")
    self._points = []
    self._xyz = [] # only used by Phenix GUI (not offline plotting)
    self.plot = self.figure.add_subplot(111)
    self.plot.set_position([0.1, 0.1, 0.85, 0.85])

  def draw_plot(self,
                 stats,
                 title,
                 points=None,
                 show_labels=True,
                 colormap='jet',
                 contours=None,
                 xyz=None,
                 extent=None,
                 y_marks=None):
    import matplotlib.cm
    self._points = []
    self._xyz = []
    cm = getattr(matplotlib.cm, colormap)
    self.plot.clear()
    if (extent is None):
      extent = self.extent
    else :
      assert (len(extent) == 4)
    print(extent)
    self.plot.imshow(stats, origin="lower", cmap=cm, extent=extent)
    if (contours is not None):
      self.plot.contour(stats, contours,
        origin="lower",
        colors='k',
        extent=extent)
    if (y_marks is None):
      self.set_labels()
    else :
      self.set_labels(y_marks=y_marks)
    self.plot.set_title(title)
    if (points is not None):
      if (xyz is not None) : assert (len(xyz) == len(points))
      for i, (x, y, label, is_outlier) in enumerate(points):
        if is_outlier :
          self.plot.plot((x,),(y,), 'bo', markerfacecolor='red')
          if show_labels :
            self.plot.text(x, y, label, color='black')
          self._points.append((x,y))
          if (xyz is not None):
            self._xyz.append(xyz[i])
        else :
          self.plot.plot((x,),(y,), 'bo', markerfacecolor='white')
    self.canvas.draw()

class ramachandran_plot_mixin(rotarama_plot_mixin):
  extent = [-179,179,-179,179]
  def set_labels(self, y_marks=()):
    self.plot.set_xlabel("Phi")
    self.plot.set_xticks([-120,-60,0,60,120])
    self.plot.set_ylabel("Psi")
    self.plot.set_yticks([-120,-60,0,60,120])

class rotamer_plot_mixin(rotarama_plot_mixin):
  def set_labels(self, y_marks=(60,180,300)):
    self.plot.set_xlabel("Chi1")
    self.plot.set_xticks([60,180,300])
    self.plot.set_ylabel("Chi2")
    self.plot.set_yticks(list(y_marks))
    self.plot.grid(True, color="0.75")

class ramachandran_plot(simple_matplotlib_plot, ramachandran_plot_mixin):
  def __init__(self, *args, **kwds):
    simple_matplotlib_plot.__init__(self, *args, **kwds)
    ramachandran_plot_mixin.__init__(self, *args, **kwds)

class rotamer_plot(simple_matplotlib_plot, rotamer_plot_mixin):
  def __init__(self, *args, **kwds):
    simple_matplotlib_plot.__init__(self, *args, **kwds)
    rotamer_plot_mixin.__init__(self, *args, **kwds)

def get_residue_ramachandran_data(ramalyze_data,
                                   position_type,
                                   residue_name,
                                   point_type):
  #if (not position_type in ["general", "glycine", "cis-proline",
  #    "trans-proline", "pre-proline", "isoleucine or valine"]):
  if (not position_type in ["General", "Gly", "cis-Pro", "trans-Pro", "pre-Pro",
                   "Ile/Val"]):
    raise ValueError("Ramachandran position type '%s' not recognized." %
      position_type)
  points, coords = [], []
  for i, residue in enumerate(ramalyze_data):
    (chain_id,resseq,resname,quality,phi,psi,status,pos_name,xyz) = residue
    if (position_type == "general"):
      if (((residue_name == '*') or (resname.upper() == residue_name.upper()))
          and (not resname in ["PRO","GLY","ILE","VAL"])):
        if ((point_type == "All") or
            (point_type=="Allowed/Outlier" and
             status in ["Allowed","OUTLIER"]) or
            (point_type == "Outlier" and status == "OUTLIER")):
          points.append((phi, psi, "%s%s" % (chain_id, resseq),
            (status == "OUTLIER")))
          coords.append(xyz)
    elif (position_type.upper() == pos_name.upper()):
      if ((point_type == "All") or
          (point_type=="Allowed/Outlier" and status in ["Allowed","OUTLIER"]) or
          (point_type == "Outlier" and status == "OUTLIER")):
        points.append((phi, psi, "%s%s" % (chain_id, resseq),
          (status == "OUTLIER")))
        coords.append(xyz)
  return (points, coords)

def format_ramachandran_plot_title(position_type, residue_type):
  title = "Ramachandran plot for "
  if (position_type == "cis-proline"):
    title += "cis-Proline"
  elif (position_type == "trans-proline"):
    title += "trans-Proline"
  elif (position_type == "glycine"):
    title += "Glycine"
  elif (position_type == "pre-proline"):
    title += "pre-Proline residues"
  elif (position_type == "isoleucine or valine"):
    title += "Ile or Val"
  else :
    if residue_type == '*' :
      title += "all non-Pro/Gly residues"
    else :
      title += residue_type
  return title

def draw_ramachandran_plot(ramalyze_data,
                            rotarama_data,
                            position_type,
                            file_name,
                            show_labels=True):
  points, coords = get_residue_ramachandran_data(
    ramalyze_data=ramalyze_data,
    position_type=position_type,
    residue_name='*',
    point_type="All")
  p = ramachandran_plot()
  title = format_ramachandran_plot_title(position_type, '*')
  # XXX where do these numbers come from?
  if position_type == "general" :
    contours = [0.1495, 0.376]
  else :
    contours = [0.2115, 0.376]
  p.draw_plot(
    stats=rotarama_data,
    title=title,
    points=points,
    xyz=coords,
    colormap="Blues",
    contours=contours)
  p.save_image(file_name)

def get_residue_rotamer_data(rotalyze_data,
                              residue_name,
                              point_type):
  points, coords = [], []
  for i, residue in enumerate(rotalyze_data):
    (chain_id,resseq,resname,quality,chi1,chi2,chi3,chi4,status,xyz)=residue
    if resname.upper() == residue_name.upper():
      if ((point_type == "All") or
          (point_type=="Outlier" and status=="OUTLIER")):
        points.append((chi1, chi2, "%s%s" % (chain_id, resseq),
          (status == "OUTLIER")))
        coords.append(xyz)
  return (points, coords)

def draw_rotamer_plot(rotalyze_data,
                       rotarama_data,
                       residue_name,
                       file_name,
                       show_labels=True):
  points, coords = get_residue_rotamer_data(
    rotalyze_data=rotalyze_data,
    residue_name=residue_name,
    point_type="All")
  p = rotamer_plot()
  title = "Chi1-Chi2 plot for %s" % residue_name
  p.draw_plot(
    stats=rotarama_data,
    title=title,
    points=points,
    xyz=coords,
    colormap="Blues",
    contours=None)
  p.save_image(file_name)


 *******************************************************************************


 *******************************************************************************
mmtbx/rotamer/n_dim_table.py
from __future__ import absolute_import, division, print_function
from scitbx.array_family import flex
from math import floor
import re
from six.moves import range


class NDimTable:

    # I now know these are class (== Java "static") variables,
    # not instance variables, although I intended for them to be instance vars.
    # I had to remove these definitions or pickling didn't work correctly --
    # restored objects had empty arrays instead of the desired data.

    #ourName = '' # identifying name for this table
    #nDim    = 0  # number of dimensions of data
    #minVal  = [] # nDim doubles, minimum allowed coordinate per dimension
    #maxVal  = [] # nDim doubles, maximum allowed coordinate per dimension
    #nBins   = [] # nDim ints, number of bins in each dimension
    #doWrap  = [] # nDim booleans, does the dimension wrap around, like a dihedral angle?
    #wBin    = [] # nDim doubles, width of each bin per dimension (nice to precalculate)
    #lookupTable = None # an array of floating point numbers; the actual data

    @staticmethod
    def createFromText(infile):
        '''Loads rotamer or Ramachandran data from a text file, returning a new object.

        Can pass in either a file handle or a file name'''
        if isinstance(infile, str):
            infile = open(infile, 'r')
        ndt = NDimTable()
        ndt.ourName = re.search(r': +"(.+)"$', infile.readline()).group(1)
        ndt.nDim = int(re.search(r': +(\d+)$', infile.readline()).group(1))
        infile.readline() # lower_bound  upper_bound  number_of_bins  wrapping
        ndt.minVal  = []
        ndt.maxVal  = []
        ndt.nBins   = []
        ndt.doWrap  = []
        ndt.wBin    = []
        data_re = re.compile(r': +([^ ]+) +([^ ]+) +([^ ]+) +([^ ]+)$')
        for i in range(ndt.nDim):
            match = data_re.search(infile.readline())
            ndt.minVal.append(float(match.group(1)))
            ndt.maxVal.append(float(match.group(2)))
            ndt.nBins.append(   int(match.group(3)))
            doWrap = match.group(4).lower().strip()
            if doWrap == "true" or doWrap == "yes" or doWrap == "on" or doWrap == "1": ndt.doWrap.append(True)
            else: ndt.doWrap.append(False)
            ndt.wBin.append((ndt.maxVal[i] - ndt.minVal[i]) / ndt.nBins[i])
        #print ndt.minVal, ndt.maxVal, ndt.nBins, ndt.doWrap, ndt.wBin
        ndt.lookupTable = flex.float(flex.grid(ndt.nBins), 0)
        if re.search(r'first', infile.readline()): valueFirst = True
        else: valueFirst = False
        #print valueFirst
        s = infile.readline()
        while s:
            fields = s.split()
            if(len(fields) <= ndt.nDim): continue
            if valueFirst:
                val = float(fields[0])
                coords = [float(fld) for fld in fields[1:ndt.nDim+1]]
            else:
                val = float(fields[ndt.nDim])
                coords = [float(fld) for fld in fields[0:ndt.nDim]]
            #print val, coords
            ndt.setValueAt( ndt.whereIs(coords), val )
            s = infile.readline()
        return ndt


    def whereIs(self, coords):
        '''Given a set of coordinates, return the bin indices'''
        bin = []
        for i in range(self.nDim):
            bin.append(int( min(floor((coords[i]-self.minVal[i])/self.wBin[i]),  self.nBins[i] - 1) ))
        return bin


    def setValueAt(self, bin, val):
        '''Given bin indices, set the value in the table'''
        self.lookupTable[ self.bin2index(bin) ] = val


    def bin2index(self, bin):
        '''Given bin indices, return a single index into the linear array'''
        idx = 0
        for i in range(self.nDim-1):
            iBin = self.wrapbin(bin[i], i)
            if iBin < 0 or iBin >= self.nBins[i]: return -1
            idx += iBin
            idx *= self.nBins[i+1]
        i = self.nDim - 1
        iBin = self.wrapbin(bin[i], i)
        if iBin < 0 or iBin >= self.nBins[i]: return -1
        idx += iBin
        return idx


    def bin2index_limit(self, bin):
        '''Given bin indices, return a single index into the linear array.

        If no bin can be found after wrapping is applied, the edge of the table is used.'''
        idx = 0
        for i in range(self.nDim-1):
            iBin = self.wrapbin(bin[i], i)
            iBin = self.clampInclusive(0, iBin, self.nBins[i]-1)  # clamp to range [ 0, nBins[i] )
            idx += iBin
            idx *= self.nBins[i+1]
        i = self.nDim - 1
        iBin = self.wrapbin(bin[i], i)
        iBin = self.clampInclusive(0, iBin, self.nBins[i]-1)  # clamp to range [ 0, nBins[i] )
        idx += iBin
        return idx

    def clampInclusive(self, minVal, theVal, maxVal):
        '''Forces theVal into the range from minVal to maxVal (inclusive)'''
        return max(minVal, min(theVal, maxVal))


    def wrapbin(self, iBin, dim):
        '''Wrap bin indices for each dimension in which it is appropriate'''
        # Python seems to have a sensible modulo operator (%),
        # unlike Java, so we don't need wrapbin much.
        if self.doWrap[dim]:
            return iBin % self.nBins[dim]
            #iBin = iBin % self.nBins[dim]
            #if iBin < 0: return iBin + self.nBins[dim]
            #else: return iBin
        else: return iBin


    def centerOf(self, bin):
        '''Returns coordinates for the center of the bin given by these indices'''
        pt = []
        for i in range(self.nDim):
            pt.append(self.minVal[i] + self.wBin[i]*(bin[i]+0.5))
        return pt


    def valueAt(self, pt):
        '''Estimates the value of the density trace at a given position,
        using linear interpolation.

        This algorithm basically consults the 2^n bins nearest in space to
        the input point, and weights their contributions according to their
        distances.

        To get a feeling for how it works, work out a linear interpolation in
        one dimension
        ( a...x.......b -- what is x in terms of a and b? )(trivial)
        and then in two dimensions (still fairly easy -- do one dimension
        first, then interpolate between those results).

        In dimensions very near the edge of the table, no interpolation is
        performed in that dimension
        (it would be impossible to do so, anyway, because there's no 2nd
        value to interpolate out *to*).

        pt - the point at which the value should be estimated
        returns - the approximate value of the density trace at the specified
        point'''

        value = 0 # The value this function is calculating!
        va_home = self.whereIs(pt) # the bin this point falls into
        va_home_ctr = self.centerOf(va_home) # center of the above bin (nearest)
        va_neighbor = [] # the diagonal nearest-neighbor bin -- to be determined
        va_contrib = [] # relative contribution of va_neighbor (balance from va_home)
        va_current = [0]*self.nDim # current bin indices we're examining in the 2nd loop below

        # Initialize va_neighbor[] and va_contrib[]
        for dim in range(self.nDim):
            # If neighbor is out-of-bounds, bin2index_limit will handle it later
            if pt[dim] < va_home_ctr[dim]:  va_neighbor.append(va_home[dim]-1)
            else:                           va_neighbor.append(va_home[dim]+1)
            va_contrib.append(abs( (pt[dim]-va_home_ctr[dim])/self.wBin[dim] )) # always on [0.0, 0.5]
        #print pt, va_home, va_home_ctr, va_neighbor, va_contrib, self.nBins

        # Loop over all bins
        # bin is used as a bit mask, with one bit per dimension
        # 0 means va_home, 1 means va_neighbor -- this way all 2^n va_neighbor bins are evaluated
        # The limit is a 30-D table, but a 2x2x...x2 table in 30-D would occupy > 4GB !!!
        for bin in range(1 << self.nDim):
            coeff = 1.0 # reset coefficient; product of a mix of elements from va_contrib[] and (1-va_contrib[])
            # Loop over all dimensions, checking the appropriate bit in bin
            for dim in range(self.nDim):
                # Bit is off -- elements are drawn from va_home[] and (1-va_contrib[])
                if bin & (1 << dim) == 0:
                    va_current[dim] = va_home[dim]
                    coeff *= 1.0 - va_contrib[dim]
                # Bit is on -- elements are drawn from va_neighbor[] and va_contrib[]
                else:
                    va_current[dim] = va_neighbor[dim]
                    coeff *= va_contrib[dim]
            #print coeff, va_current, self.lookupTable[ self.bin2index_limit(va_current) ]
            value += coeff * self.lookupTable[ self.bin2index_limit(va_current) ] # calc. va_contribution of va_currently selected bin
        return value


 *******************************************************************************


 *******************************************************************************
mmtbx/rotamer/nqh.py
from __future__ import absolute_import, division, print_function
from libtbx.utils import Sorry
import libtbx.load_env
import iotbx.pdb
import sys, re
from mmtbx.refinement.flip_peptide_side_chain import flip_residue
from iotbx.pdb.utils import all_chain_ids
from mmtbx.utils import run_reduce_with_timeout
from mmtbx.validation.clashscore import check_and_report_reduce_failure

def seg_id_to_chain_id(pdb_hierarchy):
  import string
  two_character_chain_ids = []
  segid_list = []
  seg_dict = {}
  for atom in pdb_hierarchy.atoms():
    if atom.segid not in segid_list:
      segid_list.append(atom.segid)
  lower_letters = string.ascii_lowercase
  upper_letters = string.ascii_uppercase
  two_character_chain_ids = all_chain_ids()
  for id in segid_list:
    chainID = two_character_chain_ids[0]
    seg_dict[id] = chainID
    two_character_chain_ids.remove(chainID)
  return seg_dict

def find_bare_chains_with_segids(pdb_hierarchy):
  bare_chains = False
  for chain in pdb_hierarchy.chains():
    if chain.id in ['', ' ', '  ']:
      segid = None
      for atom in chain.atoms():
        if segid == None:
          segid = atom.segid
        elif segid != None and segid != atom.segid:
          #require that each chain have a unique segid for this logic
          return False
      if segid != None and segid not in ['', ' ', '  ', '   ', '    ']:
        bare_chains = True
  return bare_chains

def assign_chain_ids(pdb_hierarchy, seg_dict):
  rename_txt = ""
  for chain in pdb_hierarchy.chains():
    if chain.id in ['', ' ', '  ']:
      segid = None
      for atom in chain.atoms():
        if segid == None:
          segid = atom.segid
        elif segid != atom.segid:
          print(segid, atom.segid)
          raise Sorry("multiple segid values defined for chain")
      new_id = seg_dict[segid]
      chain.id = new_id
      rename_txt = rename_txt + \
      "segID %s renamed chain %s for Reduce N/Q/H analysis\n" % (segid, new_id)
  return rename_txt

def force_unique_chain_ids(pdb_hierarchy):
  used_chain_ids = []
  two_char = all_chain_ids()
  #filter all used chains
  for model in pdb_hierarchy.models():
    for chain in model.chains():
      cur_id = chain.id
      if cur_id in two_char:
        two_char.remove(cur_id)
  #force unique chain ids
  for model in pdb_hierarchy.models():
    for chain in model.chains():
      cur_id = chain.id
      if cur_id not in used_chain_ids:
        used_chain_ids.append(cur_id)
      else:
        new_id = two_char[0]
        chain.id = new_id
        two_char.remove(new_id)

def get_nqh_flips(pdb_hierarchy):
  pdb_string = pdb_hierarchy.as_pdb_string()
  output = run_reduce(pdb_string=pdb_string, remove_hydrogens=True)
  user_mods = []
  score_dict = {}
  atom_notes = []
  for line in output.stdout_lines:
    if re.match(r'USER  MOD', line):
      flip = re.search(r':(.{15}):FLIP(.*):sc=.*[F|C]\(o=(.*),f=(.*)\)',line)
      if(flip):
        if flip.group(3)[-1:] == '!':
          score_o = float(flip.group(3)[:-1])
        else:
          score_o = float(flip.group(3))
        if flip.group(4)[-1:] == '!':
          score_f = float(flip.group(4)[:-1])
        else:
          score_f = float(flip.group(4))
        score_diff = score_f - score_o
        if score_f <= -2.0:
          user_mods.append('!'+flip.group(1).strip())
        else:
          user_mods.append(flip.group(1).strip())
        score_dict[flip.group(1).strip()] = score_diff
        if re.search(r'HIS',line):
          atom_notes.append([flip.group(1).strip(),flip.group(2).strip()])
  return user_mods, atom_notes, score_dict

# return true if H atoms are inconsistent with Reduce protonation state
# if no D or E H's are present, always return False to allow flip
def check_for_his_h(residue, atom_notes, key):
  atom_list =[]
  for atom in residue.atoms():
    atom_list.append(atom.name)

  #check for no H atoms
  if not (" HD1" in atom_list or " HD2" in atom_list or " HE1" in atom_list or
          " HE2" in atom_list):
    return False
  for entry in atom_notes:
    if entry[0] == key:
      if entry[1].strip() == "no HD1":
        if not ( (" HD2" in atom_list and " HE1" in atom_list and " HE2" in atom_list) and
                 not " HD1" in atom_list ):
          return True
      elif entry[1].strip() == "no HE2":
        if not ( (" HD1" in atom_list and " HD2" in atom_list and " HE1" in atom_list) and
                 not " HE2" in atom_list):
          return True
      elif entry[1].strip() == "+bothHN":
        if not (" HD1" in atom_list and " HD2" in atom_list and " HE1" in atom_list and
                " HE2" in atom_list):
          return True
  return False

def run_reduce(pdb_string, remove_hydrogens=True):
  assert (libtbx.env.has_module(name="reduce"))
  trim = " -quiet -trim -"
  build = " -quiet -build -allalt -"
  input_str = ""
  if(remove_hydrogens):
    clean = run_reduce_with_timeout(parameters=trim,
                                    stdin_lines=pdb_string)
    check_and_report_reduce_failure(clean, pdb_string, "reduce_failure.pdb")
    input_str = "\n".join(clean.stdout_lines)
  else:
    input_str = pdb_string
  output = run_reduce_with_timeout(parameters=build,
                                   stdin_lines=input_str)
  check_and_report_reduce_failure(output, input_str, "reduce_failure.pdb")
  return output

def flip_selected(pdb_hierarchy, # changed in-place
                  mon_lib_srv,
                  flip_list,
                  atom_notes,
                  score_dict,
                  log):
  sites_cart_start = pdb_hierarchy.atoms().extract_xyz()
  total_flipped = 0
  #
  # XXX TEMPORARY DISABLED. THIS DOES NOT COVER ALL. USE GRM INSTEAD OF LINK STUFF. XXX
  #
  ##find excluded residues that are covalently linked
  exclude_sidechain = []
  #for arg in apply_cif_links:
  #  for res in arg.pdbres_pair:
  #    resname = res[8:11]
  #    if resname.upper() in ['ASN', 'GLN', 'HIS']:
  #      chainID = res[11:13]
  #      resnum = res[13:-1]
  #      key = chainID.strip()+resnum+resname
  #      #exclude_sidechain.append(res[8:-1].strip())
  #      exclude_sidechain.append(key)
  #print exclude_sidechain
  for model in pdb_hierarchy.models():
    for chain in model.chains():
      for residue_group in chain.residue_groups():
        conformers = residue_group.conformers()
        for conformer in residue_group.conformers():
          residue = conformer.only_residue()
          key = chain.id+residue.resid()+residue.resname+"    "+conformer.altloc
          key = key.strip()
          if key[0:9] in exclude_sidechain:
            print(key[0:9]+' is covalently modified...skipping', file=log)
          elif '!'+key in flip_list:
            print('** '+key+' **'+' both conformations clash, **PLEASE CHECK MANUALLY**', file=log)
          elif key in flip_list:
            if residue.resname=="HIS":
              if check_for_his_h(residue, atom_notes, key)==True:
                continue
            print(key, file=log)
            # here we are going to do flips in hierarchy and then simply
            # extract xray_structure with updated coordinates
            flip_residue(residue,mon_lib_srv)
            total_flipped += 1
  print("\nTotal number of N/Q/H flips: %d\n" % total_flipped, file=log)

def flip(pdb_hierarchy, log=None, mon_lib_srv=None):
  if mon_lib_srv is None:
    mon_lib_srv = mmtbx.monomer_library.server.server()
  if(log is None): log = sys.stdout
  pdb_hierarchy.atoms().reset_i_seq()
  print("Analyzing N/Q/H residues for possible flip corrections...", file=log)
  tmp_pdb_hierarchy = pdb_hierarchy.deep_copy()
  tmp_pdb_hierarchy.atoms().reset_i_seq()
  #analyze chain/segid relationship
  bare_chains = find_bare_chains_with_segids(pdb_hierarchy=pdb_hierarchy)
  if bare_chains:
    seg_dict = seg_id_to_chain_id(pdb_hierarchy=tmp_pdb_hierarchy)
    rename_txt = assign_chain_ids(pdb_hierarchy=tmp_pdb_hierarchy,
                                        seg_dict=seg_dict)
    print(rename_txt, file=log)
  if tmp_pdb_hierarchy.overall_counts().n_duplicate_chain_ids > 0:
    force_unique_chain_ids(
      pdb_hierarchy=tmp_pdb_hierarchy)
  try:
    flip_list, atom_notes, score_dict = get_nqh_flips(
      pdb_hierarchy = tmp_pdb_hierarchy)
  except OSError as e :
    if (e.errno == 32) :
      print("WARNING: system error attempting to run Reduce", file=log)
      print("         this may indicate a crash or OS conflict", file=log)
      print("         phenix.refine will continue running, but you", file=log)
      print("         should check Asn/Gln/His residues visually.", file=log)
      print("         contact help@phenix-online.org if this problem", file=log)
      print("         occurs frequently.", file=log)
      return pdb_hierarchy
    else :
      raise e
  if len(flip_list) == 0:
    print("\nNo N/Q/H corrections needed this macrocycle", file=log)
  else:
    print("\nFlipped N/Q/H residues before XYZ refinement:", file=log)
    flip_selected(
      pdb_hierarchy = pdb_hierarchy, # changed in-place
      mon_lib_srv   = mon_lib_srv,
      flip_list     = flip_list,
      atom_notes    = atom_notes,
      score_dict    = score_dict,
      log           = log)
  return pdb_hierarchy


 *******************************************************************************


 *******************************************************************************
mmtbx/rotamer/ramachandran_eval.py
from __future__ import absolute_import, division, print_function

import boost_adaptbx.boost.python as bp
ext = bp.import_ext("mmtbx_validation_ramachandran_ext")
from mmtbx_validation_ramachandran_ext import rama_eval

# maps programatic name to file name
aminoAcids = {
    'general' : 'general',
    'glycine' : 'gly-sym',
    'proline' : 'pro',
    'prepro' : 'prepro',
}
aminoAcids_8000 = {
    'general' : 'general-noGPIVpreP',
    'glycine' : 'gly-sym',
    'cis-proline' : 'cispro',
    'trans-proline' : 'transpro',
    'pre-proline' : 'prepro-noGP',
    'isoleucine or valine' : 'ileval-nopreP',
}

#
# Why constants from ramalyze, i.e. res_types are not used here at all?
# They should be defined either here (preferably) and used everywhere or there.
#

class RamachandranEval:
  def __init__(self):
    self.rama_eval = rama_eval()

  def check_table_name(self, name):
    # This function take time to run. We have similar check in C++ and raising
    # Runtime error there if the name is not good.
    return name in aminoAcids_8000

  def evaluate(self, aaName, phiPsi):
    # assert self.check_table_name(aaName)
    return self.rama_eval.get_score(aaName, phiPsi[0],phiPsi[1])

  def evaluate_sites(self, aaName, phi_psi_i_seqs, sites_cart):
    # assert self.check_table_name(aaName)
    (phi, psi) = mmtbx.rotamer.phi_psi_from_sites(
      i_seqs=phi_psi_i_seqs,
      sites_cart=sites_cart)
    return self.evaluate(aaName, (phi,psi))


 *******************************************************************************


 *******************************************************************************
mmtbx/rotamer/ramachandran_eval_deprecated.py
from __future__ import absolute_import, division, print_function
import mmtbx.rotamer
from mmtbx.rotamer.n_dim_table import NDimTable
from mmtbx.rotamer.rotamer_eval import find_rotarama_data_dir
from mmtbx.rotamer.rotamer_eval import open_rotarama_dlite
from libtbx import easy_pickle
from libtbx.utils import Sorry
import weakref
import os

# maps programatic name to file name
aminoAcids = {
    'general' : 'general',
    'glycine' : 'gly-sym',
    'proline' : 'pro',
    'prepro' : 'prepro',
}
aminoAcids_8000 = {
    'general' : 'general-noGPIVpreP',
    'glycine' : 'gly-sym',
    'cis-proline' : 'cispro',
    'trans-proline' : 'transpro',
    'pre-proline' : 'prepro-noGP',
    'isoleucine or valine' : 'ileval-nopreP',
}

class RamachandranEval:

  # This is shared among all instances of RamachandranEval -- a class variable.
  # It holds a LOT of read-only data, so this helps save memory.
  aaTables = {} # maps "his" to a NDimTable object for histidine, etc.

  def __init__(self):
    main_aaTables = RamachandranEval.aaTables
    self.aaTables = {}
    for aa,ndt_weakref in main_aaTables.items():
      # convert existing weak references to strong references
      self.aaTables[aa] = ndt_weakref()
    rama_data_dir = find_rotarama_data_dir()
    target_db = open_rotarama_dlite(rotarama_data_dir=rama_data_dir)
    no_update = os.path.exists(os.path.join(rama_data_dir, "NO_UPDATE"))
    for aa, aafile in aminoAcids_8000.items():
      if (self.aaTables.get(aa) is not None): continue
      data_file = "rama8000-"+aafile+".data"
      pickle_file = "rama8000-"+aafile+".pickle"
      pair_info = target_db.pair_info(
        source_path=data_file,
        target_path=pickle_file,
        path_prefix=rama_data_dir)
      if (((pair_info.needs_update) and (not no_update)) or not
          os.path.exists(os.path.join(rama_data_dir, pickle_file))):
        raise Sorry(
          "chem_data/rotarama_data/*.pickle files are missing or out of date.\n"
          "  Please run\n"
          "    mmtbx.rebuild_rotarama_cache\n"
          "  to resolve this problem.\n")
      ndt = easy_pickle.load(file_name=os.path.join(
        rama_data_dir, pair_info.target.path))
      self.aaTables[aa] = ndt
      main_aaTables[aa] = weakref.ref(ndt)

  def evaluate(self, aaName, phiPsi):
    '''Evaluates the protein backbone conformation from 0.0 (worst) to 1.0 (best).

    Values below 0.0005 are considered outliers for the general case,
    or values below 0.002 for glycine, proline, and pre-proline.
    The field aaName should be one of "general", "glycine", "proline", or "prepro".
    If the aaName is not recognized, returns None.
    phiPsi is a list or tuple of angles in degrees(?): [phi, psi]'''
    ndt = self.aaTables.get(aaName.lower())
    if (ndt is None): return None
    return ndt.valueAt(phiPsi)

  def evaluate_sites(self, aaName, phi_psi_i_seqs, sites_cart):
    assert (aaName in ["general",
                       "glycine",
                       "cis-proline",
                       "trans-proline",
                       "pre-proline",
                       "isoleucine or valine"])
    (phi, psi) = mmtbx.rotamer.phi_psi_from_sites(
      i_seqs=phi_psi_i_seqs,
      sites_cart=sites_cart)
    return self.evaluate(aaName, (phi,psi))


 *******************************************************************************


 *******************************************************************************
mmtbx/rotamer/rotamer_eval.py
from __future__ import absolute_import, division, print_function
import libtbx.load_env
from libtbx import easy_pickle
from libtbx import dlite
from libtbx.utils import Sorry
from mmtbx.rotamer.sidechain_angles import PropertyFile, SidechainAngles
from mmtbx import monomer_library
import mmtbx.monomer_library.server
from cctbx.array_family import flex
import weakref
import sys, os
import iotbx.pdb
from six.moves import range

def find_rotarama_data_dir(optional=False):
  result = libtbx.env.find_in_repositories(
    os.path.join("chem_data", "rotarama_data"))
  if result is None:
    result = libtbx.env.find_in_repositories("rotarama_data")
    if result is None:
      result = libtbx.env.find_in_repositories(
        os.path.join("ext_ref_files", "rotarama_data"))
      if result is None and not optional:
        raise Sorry("""\
Can't find chem_data/rotarama_data/ directory:
  Inside chem_data, please run
    svn --quiet --non-interactive --trust-server-cert export https://github.com/rlabduke/reference_data.git/trunk/Top8000/Top8000_rotamer_pct_contour_grids rotarama_data
    svn --quiet --non-interactive --trust-server-cert --force export https://github.com/rlabduke/reference_data.git/trunk/Top8000/Top8000_ramachandran_pct_contour_grids rotarama_data
    mmtbx.rebuild_rotarama_cache
  to resolve this problem.""")
  return result

def open_rotarama_dlite(rotarama_data_dir=None):
  if (rotarama_data_dir is None):
    rotarama_data_dir = find_rotarama_data_dir()
  return dlite.try_loading_db(os.path.join(rotarama_data_dir, "rotarama.dlite"))

# maps aa name to file name
aminoAcids = {
    'arg' : 'arg',
    'asn' : 'asn',
    'asp' : 'asp',
    'cys' : 'cys',
    'gln' : 'gln',
    'glu' : 'glu',
    'his' : 'his',
    'ile' : 'ile',
    'leu' : 'leu',
    'lys' : 'lys',
    'met' : 'met',
    'phe' : 'phetyr',
    'pro' : 'pro',
    'ser' : 'ser',
    'thr' : 'thr',
    'trp' : 'trp',
    'tyr' : 'phetyr',
    'val' : 'val',
}

def mon_lib_query(residue, mon_lib_srv):
  # XXX backward compatibility 2007-08-10
  get_func = getattr(mon_lib_srv, "get_comp_comp_id", None)
  if (get_func is not None): return get_func(comp_id=residue)
  return mon_lib_srv.get_comp_comp_id_direct(comp_id=residue)

def eval_residue_completeness(residue, mon_lib_srv, ignore_hydrogens=True):
  atom_list = []
  for atom in residue.atoms():
    atom_list.append(atom.name.strip().upper())
  mlq = mon_lib_query(residue.resname.strip().upper(), mon_lib_srv)
  reference_list = []
  if(not ignore_hydrogens):
    for at in mlq.atom_dict():
      reference_list.append(at)#(atom.name.strip().upper())
  elif(mlq is not None):
    for non in mlq.non_hydrogen_atoms():
      reference_list.append(non.atom_id.strip().upper())
  missing=[]
  for atom in reference_list:
    if atom not in atom_list:
      atom_temp = atom.replace("*", "'")
      if atom.upper() == "O1P":
        atom_temp = "OP1"
      elif atom.upper() == "O2P":
        atom_temp = "OP2"
      if atom_temp not in atom_list:
        missing.append(atom)
  return missing

def eval_sidechain_completeness(pdb_hierarchy,
                                mon_lib_srv=None,
                                ignore_hydrogens=True,
                                report_whole_res=False,
                                return_ca_pos=False):
  missing_atom_list=[]
  if mon_lib_srv is None:
    mon_lib_srv = monomer_library.server.server()
  for model in pdb_hierarchy.models():
    for chain in model.chains():
      for residue_group in chain.residue_groups():
        conformers = residue_group.conformers()
        for conformer in residue_group.conformers():
          item = []
          residue = conformer.only_residue()
          if conformer.altloc == "":
            key = "%2s%5s %3s" % (chain.id, residue_group.resid(),
              residue.resname)
          else:
            key = "%2s%5s%1s%3s" % (chain.id, residue_group.resid(),
              conformer.altloc, residue.resname)
          ca_xyz = []
          for atom in residue.atoms():
            if atom.name == " CA ":
              ca_xyz = atom.xyz
          missing = eval_residue_completeness(
            residue=residue,
            mon_lib_srv=mon_lib_srv)
          if not report_whole_res:
            if len(missing) > 0:
              item.append(key)
              item.append(missing)
              if return_ca_pos:
                item.append(ca_xyz)
          else:
            item.append(key)
            item.append(missing)
            if return_ca_pos:
              item.append(ca_xyz)
          if len(item) > 0:
            missing_atom_list.append(item)
  return missing_atom_list

class RotamerEval:

  # This is shared among all instances of RotamerEval -- a class variable.
  # It holds a LOT of read-only data, so this helps save memory.
  aaTables = {} # maps "his" to a NDimTable object for histidine, etc.

  def __init__(
               self,
               sidechain_angles=None,
               mon_lib_srv=None,
               log=None,
               data_version="8000"):
#              data_version="500"):
    if sidechain_angles is None:
      sidechain_angles = SidechainAngles(True)
    self.sidechain_angles = sidechain_angles
    if mon_lib_srv is None:
      mon_lib_srv = mmtbx.monomer_library.server.server()
    if log is None:
      log = sys.stdout
    self.data_version = data_version
    if self.data_version == "8000":
      self.outlier_threshold = 0.003
      fileprefix = "rota8000-"
    else: raise Sorry("data_version given to RotamerEval not recognized.")
    self.log = log
    self.mon_lib_srv = mon_lib_srv
    self.rot_id = RotamerID()
    main_aaTables = RotamerEval.aaTables
    self.aaTables = {}
    for aa,ndt_weakref in main_aaTables.items():
        # convert existing weak references to strong references
        self.aaTables[aa] = ndt_weakref()
    rotamer_data_dir = find_rotarama_data_dir()
    no_update = os.path.exists(os.path.join(rotamer_data_dir, "NO_UPDATE"))
    target_db = open_rotarama_dlite(rotarama_data_dir=rotamer_data_dir)
    for aa, aafile in aminoAcids.items():
      if (self.aaTables.get(aa) is not None): continue
      data_file = fileprefix+aafile+".data"
      pickle_file = fileprefix+aafile+".pickle"
      pair_info = target_db.pair_info(
                    source_path=data_file,
                    target_path=pickle_file,
                    path_prefix=rotamer_data_dir)
      if (((pair_info.needs_update) and (not no_update)) or not
          os.path.exists(os.path.join(rotamer_data_dir, pickle_file))):
        raise Sorry(
          "chem_data/rotarama_data/*.pickle files are missing or out of date.\n"
          "  Please run\n"
          "    mmtbx.rebuild_rotarama_cache\n"
          "  to resolve this problem.\n")
      ndt = easy_pickle.load(file_name=os.path.join(
              rotamer_data_dir, pair_info.target.path))
      self.aaTables[aa] = ndt
      main_aaTables[aa] = weakref.ref(ndt)

  def evaluate(self, aaName, chiAngles):
    '''Evaluates the specified rotamer from 0.0 (worst) to 1.0 (best).

       Values below 0.003 are generally considered outliers.
       If the 3-letter amino acid name is not recognized, returns None.'''
    ndt = self.aaTables.get(aaName.lower())
    if (ndt is None): return None
    return ndt.valueAt(chiAngles)

  def get_atom_dict(self, residue):
    atom_dict = {}
    atoms = residue.atoms()
    for atom in atoms:
      #handle hydrogen/deuterium swaps
      if atom_dict.get(atom.name) == None:
        if atom_dict.get(atom.name.replace("H","D",1)) != None:
          del(atom_dict[atom.name.replace("H","D",1)])
        elif atom_dict.get(atom.name.replace("D","H",1)) != None:
          del(atom_dict[atom.name.replace("D","H",1)])
        atom_dict[atom.name] = atom
    return atom_dict

  def chi_angles(self, residue):
    atom_dict = self.get_atom_dict(residue)
    return self.sidechain_angles.measureChiAngles(
      res=residue,
      atom_dict=atom_dict)

  def evaluate_residue(
                       self,
                       residue=None,
                       residue_group=None): # FIXME does not work! Start using this parameter in function?
    # Warning!!! Returns "OUTLIER", "UNCLASSIFIED", rotamer name or None.
    assert [residue, residue_group].count(None) == 1
    if residue is not None:
      atoms = residue.atoms()
      resname = residue.resname.lower().strip()
    if resname == 'gly': # why ala is not here?
      return None
    elif resname == 'mse':
      resname = 'met'
    atom_dict = self.get_atom_dict(residue)
    try:
      chis = self.sidechain_angles.measureChiAngles(
               res=residue,
               atom_dict=atom_dict)
      value = self.evaluate(
                resname,
                chis)
    except Exception:
      return None
    if chis is None:
      return None
    wrap_chis = \
      self.rot_id.wrap_chis(resname, chis, symmetry=False)
    rotamer_name = self.rot_id.identify(resname, wrap_chis)
    if(rotamer_name == "EXCEPTION"):
      assert value is None
      return rotamer_name
    if rotamer_name == "" and (value >= self.outlier_threshold):
      return "UNCLASSIFIED"
    elif (value < self.outlier_threshold):
      return "OUTLIER"
    else:
      return rotamer_name

  def evaluate_residue_2(self, residue=None):
    # copy-paste from evaluate_residue, returns
    # "OUTLIER", "Allowed", "Favored" or None if something is really wrong.
    from mmtbx.validation.rotalyze import OUTLIER_THRESHOLD, ALLOWED_THRESHOLD
    if residue is not None:
      atoms = residue.atoms()
      resname = residue.resname.lower().strip()
    if resname == 'gly' or resname == 'ala':
      return None
    elif resname == 'mse':
      resname = 'met'
    atom_dict = self.get_atom_dict(residue)
    try:
      chis = self.sidechain_angles.measureChiAngles(
               res=residue,
               atom_dict=atom_dict)
      value = self.evaluate(
                resname,
                chis)
    except Exception:
      return None
    if chis is None:
      return "OUTLIER"

    if value >= ALLOWED_THRESHOLD :
      return "Favored"
    elif value >= OUTLIER_THRESHOLD:
      return "Allowed"
    else:
      return "OUTLIER"


  def nearest_rotamer_sites_cart(self, residue):
    sites_cart_result = residue.atoms().extract_xyz()
    get_class = iotbx.pdb.common_residue_names_get_class
    if(get_class(residue.resname) == "common_amino_acid"):
      sites_cart = residue.atoms().extract_xyz()
      rotamer_iterator = self.mon_lib_srv.rotamer_iterator(
          fine_sampling = True,
          comp_id       = residue.resname,
          atom_names    = residue.atoms().extract_name(),
          sites_cart    = sites_cart)
      if(rotamer_iterator is None or
         rotamer_iterator.problem_message is not None or
         rotamer_iterator.rotamer_info is None):
        rotamer_iterator = None
      if(rotamer_iterator is not None):
        dist_min = 1.e+9
        for r, rotamer_sites_cart in rotamer_iterator:
          d= flex.mean(flex.sqrt((sites_cart - rotamer_sites_cart).dot()))
          if(d < dist_min):
            dist_min = d
            sites_cart_result = rotamer_sites_cart
    return sites_cart_result

#{{{ RotamerID (new for reading in rotamer names from rotamer_names.props)
class RotamerID:

  names = {}

  def __init__(self):
    if (len(self.names) == 0):
      source_dir = self.find_source_dir()
      #f = PropertyFile()
      # can't use f.properties to read in rotamer_names.props
      # some of the rotamer names aren't unique, so they get dropped as keys!
      rota_names_list = self.process(os.path.join(source_dir, "rotamer_names.props"))
      for line in rota_names_list:
        split_line = line.split("=")
        aa_name = split_line[0].strip()
        ranges = split_line[1].strip().strip("\"")
        name_split = aa_name.split(" ")
        aa = name_split[0]
        rot_name = name_split[1]
        rot = NamedRot(aa, rot_name, ranges)
        rotList = []
        if aa in self.names:
          rotList = self.names[aa]
        rotList.append(rot)
        self.names[aa] = rotList

  def identify(self, aa_name, chis):
    aa_name = aa_name.lower()
    if(aa_name == "ala"): return "EXCEPTION"
    if aa_name not in self.names:
      raise Sorry("Unknown residue name: %s", aa_name)
    wrap_chis = self.wrap_chis(aa_name, chis)
    rotList = self.names[aa_name]
    for rot in rotList:
      if(rot.contains(wrap_chis)): return rot.rotamer_name
    return ""

  def find_source_dir(optional=False):
    result = libtbx.env.find_in_repositories(os.path.join("mmtbx", "rotamer"))
    if result is None and not optional:
      raise Sorry("""\
Can't seem to find mmtbx/rotamer/ directory.
    """)
    return result

  def process(self, fileLoc):
    rotaList = []
    try:
      f = open(fileLoc)
    except ImportError as e:
      print(fileLoc+" file not found")
      sys.exit()
    for line in f:
      if (line.startswith("#") or line == "\n"): continue
      else: rotaList.append(line)
    f.close()
    return rotaList

  def wrap_chis(self, aa_name, chis, symmetry=True):
    aa_name = aa_name.lower()
    wrap_chis = []
    for i in range(0, len(chis)):
      if chis[i] is not None:
        wrap_chis.append(chis[i] % 360)
        if wrap_chis[i] < 0:
          wrap_chis[i] += 360
      else:
        wrap_chis.append(None)
    if (symmetry==True):
      wrap_chis = self.wrap_sym(aa_name, wrap_chis)
    #MOVED TO SEPARATE FUNCTION 'wrap_sym' for accurate angle reporting
    #if (aa_name == "asp" or aa_name == "glu" or aa_name == "phe" or aa_name == "tyr"):
    #  i = len(wrap_chis) - 1
    #  print wrap_chis[i]
    #  wrap_chis[i] = wrap_chis[i] % 180
    #  if wrap_chis[i] < 0:
    #    wrap_chis[i] += 180
    return wrap_chis

  def wrap_sym(self, aa_name, wrap_chis):
    aa_name = aa_name.lower()
    if (aa_name == "asp" or aa_name == "glu" or aa_name == "phe" or aa_name == "tyr"):
      i = len(wrap_chis) - 1
      if wrap_chis[i] is not None:
        wrap_chis[i] = wrap_chis[i] % 180
        if wrap_chis[i] < 0:
          wrap_chis[i] += 180
    return wrap_chis

#}}}

#{{{ NamedRot
class NamedRot:

  def __init__(self, aa, rotamer_name, bounds):
    self.aa_name = aa
    self.rotamer_name = rotamer_name
    self.bounds = [int(b) for b in bounds.split(", ")]

  def __str__(self):
    return str(self.rotamer_name) + "=" + str(self.bounds)

  def contains(self, angles):
    for i in range(0, len(self.bounds), 2):
      if (angles[i//2] is None ) or (self.bounds[i] is None): # XXX FIX OK?
        return False
      if (   angles[i//2] < self.bounds[i]
          or angles[i//2] > self.bounds[i+1]): return False
    return True
#}}}

########################################################################
def exercise(args):
  if (find_rotarama_data_dir(optional=True) is None):
    print("Skipping exercise(): rotarama_data directory not available")
  else:
    from mmtbx.command_line import rebuild_rotarama_cache
    rebuild_rotarama_cache.run()
    #
    from libtbx.test_utils import approx_equal
    #
    verbose = ("--verbose" in args)
    #
    r = RotamerEval()
    tbl = r.aaTables['val']
    assert RotamerEval().aaTables['val'] is tbl
    #
    assert tbl.whereIs([0.5]) == [0]
    assert tbl.bin2index([0]) == 0
    if r.data_version == '8000' :
      aeql = [0.9346579, 0.8926509, 0.8296402, 0.7876331,
              0.7351242, 0.6721136, 0.6511100, 0.6406083,
              0.5670958, 0.4620781, 0.4200710, 0.3885657,
              0.3570603, 0.2625444, 0.1785302, 0.1155195,
              0.0945160, 0.0945160, 0.0735124, 0.0735124]
    assert approx_equal(
     [(y*1000) for y in tbl.lookupTable[0:20]],aeql)
    assert approx_equal(r.evaluate("SER", [60]), 0.759436935186)
    #
    # Based off new (March 2015) NDFTs built from top8000-angles Makefile
    # Remaining inaccuracies are due to dihedrals being rounded off to
    # one decimal place!
    assert r.data_version == '8000'
    for aminoAcid, chiAngles, molpValue in [
      ("MET", [80.4, -172.2, 177.5] ,  9.7),
      ("GLN", [166.0, 178.0, -107.4] ,  9.7),
      ("ILE", [60.3, 162.4] , 24.2),
      ("PHE", [-60.7, 97.9] , 94.4),
      ("VAL", [-179.8] , 58.2),
      ("LYS", [-175.6, 176.2, -172.0, -174.2] , 81.8),
      ("THR", [76.7] , 10.3),
      ("LEU", [-68.2, -165.8] ,  9.1),
      ("THR", [70.7] , 25.9),
      ("LYS", [-179.3, -179.4, -151.1, -49.3] , 13.1),
      ("THR", [-63.4] , 83.9),
      ("ILE", [125.7, -175.4] ,  0.0),
      ("THR", [66.5] , 45.3),
      ("LEU", [-117.8, 30.2] ,  0.0),
      ("GLU", [-75.1, -167.9, 139.8] , 34.9),
      ("VAL", [-62.5] , 32.5),
      ("GLU", [-73.9, -54.5, -18.4] , 29.9),
      ("PRO", [-29.0] , 90.6),
      ("SER", [35.7] ,  0.5),
      ("ASP", [-80.6, -19.8] , 55.0),
      ("THR", [60.6] , 79.8),
      ("ILE", [-60.9, -54.6] , 35.5),
      ("GLU", [-169.6, -175.1, 72.8] , 30.3),
      ("ASN", [177.5, 53.8] , 30.3),
      ("VAL", [168.2] , 42.4),
      ("LYS", [-71.7, -173.9, 179.2, 179.4] , 94.0),
      ("LYS", [-60.8, 169.3, 148.9, -89.1] ,  5.7),
      ("ILE", [-70.9, 166.5] , 75.5),
      ("GLN", [176.9, 171.9, 35.2] , 55.5),
      ("ASP", [-150.1, 65.5] ,  1.0),
      ("LYS", [78.3, 138.2, 62.4, -165.4] ,  0.7),
      ("GLU", [-60.1, -76.8, -36.2] , 36.3),
      ("ILE", [-54.4, 161.0] , 30.8),
      ("PRO", [-31.6] , 60.3),
      ("PRO", [-28.4] , 96.3),
      ("ASP", [134.6, -61.7] ,  0.0),
      ("GLN", [-61.9, -179.0, -165.3] , 13.0),
      ("GLN", [-53.1, -179.9, 28.0] , 47.2),
      ("ARG", [161.7, 173.6, 174.2, -106.7] , 20.5),
      ("LEU", [-68.3, 166.9] , 81.8),
      ("ILE", [-48.9, -58.1] , 29.8),
      ("PHE", [178.0, 78.2] , 93.1),
      ("LYS", [-61.5, 173.7, -111.9, -58.8] ,  2.2),
      ("GLN", [-172.6, 177.3, 118.5] ,  9.7),
      ("LEU", [-50.8, -172.7] , 17.3),
      ("GLU", [173.0, 141.4, 172.4] ,  2.4),
      ("ASP", [-78.0, 177.6] , 74.9),
      ("ARG", [-55.9, -71.7, 114.2, -128.0] ,  0.4),
      ("THR", [59.8] , 74.3),
      ("LEU", [-60.3, -179.2] , 78.5),
      ("SER", [59.4] , 73.3),
      ("ASP", [-73.0, 157.0] , 84.8),
      ("TYR", [-63.3, 103.6] , 90.4),
      ("ASN", [-159.1, -145.0] ,  1.2),
      ("ILE", [-69.6, 176.4] , 57.3),
      ("GLN", [-79.4, -161.7, -148.4] ,  2.4),
      ("LYS", [49.7, 165.7, 154.3, 72.9] ,  3.2),
      ("GLU", [-72.2, 126.6, 36.7] ,  0.6),
      ("SER", [-73.2] , 18.8),
      ("THR", [-60.6] , 94.7),
      ("LEU", [-43.5, -170.9] ,  4.6),
      ("HIS", [-69.1, -88.8] , 80.8),
      ("LEU", [172.8, 65.9] , 43.9),
      ("VAL", [177.0] , 83.7),
      ("LEU", [-108.1, 39.2] ,  0.0),
      ("ARG", [133.9, -155.8, 27.2, -152.9] ,  0.0),
      ("LEU", [-92.5, 37.5] ,  0.1),
      ("ARG", [-146.6, 157.6, 92.9, -95.5] ,  0.9),
    ]:
      r_eval = 100*r.evaluate(aminoAcid, chiAngles)
      if (verbose):
        print(aminoAcid, "%4.1f %4.1f %4.1f" % (
          r_eval, molpValue, r_eval-molpValue))
        #print '      ("%s",' % aminoAcid, chiAngles, ',', "%4.1f)," % r_eval
    # assert approx_equal(r_eval, molpValue, eps=0.9)
    #
    # check if tables are cleared from memory if all RotamerEval instances
    # are gone
    for aa,ndt_weakref in RotamerEval.aaTables.items():
      assert ndt_weakref() is not None
    del r
    del tbl
    for aa,ndt_weakref in RotamerEval.aaTables.items():
      assert ndt_weakref() is None
    #
  print("OK")

if (__name__ == "__main__"):
    exercise(sys.argv[1:])


 *******************************************************************************


 *******************************************************************************
mmtbx/rotamer/sidechain_angles.py
from __future__ import absolute_import, division, print_function
import scitbx.math
from libtbx.utils import Sorry
import libtbx.load_env
from libtbx import group_args
import iotbx.pdb
from cctbx.array_family import flex
import mmtbx.rotamer
import sys, os
from six.moves import zip
from six.moves import range

def find_source_dir(optional=False):
  result = libtbx.env.find_in_repositories(os.path.join("mmtbx", "rotamer"))
  if result is None and not optional:
    raise Sorry("""\
Can't seem to find mmtbx/rotamer/ directory.
  """)
  return result

class PropertyFile:

  #properties = {}

  def __init__(self):
    self.properties = {}

  def process(self, fileLoc):
    try:
      f = open(fileLoc)
    except ImportError as e:
      print(fileLoc+" file not found")
      sys.exit()
    for line in f:
      if (line.startswith("#") or line == "\n"): continue
      else:
        props = line.split("=")
        self.properties[props[0].strip()] = props[1].strip().strip("\"")
    f.close()

class SidechainAngles:

  #knownAA = {}
  chisPerAA = {}
  anglesForAA = {}
  atomsForAngle = {}
  rotamersForAA = {}
  anglesForRot = {}
  atomsMoveWithAngle = {}
  resAtomsToChi = {}
  frequencies_from_rotamer = {}

  def __init__(self, show_errs):
    self.show_errors = show_errs
    source_dir = find_source_dir()
    #print source_dir
    f = PropertyFile()
    f.process(os.path.join(source_dir, "sidechain_angles.props"))
    for aa in f.properties['aminoacids'].split(","):
      #print aa + f.properties[aa+".chis"], f.properties['%s.frequencies' % aa]
      for rot, freq in zip(f.properties['%s.rotamers' % aa].split(','),
                           f.properties['%s.frequencies' % aa].split(','),
                           ):
        if not freq: continue
        self.frequencies_from_rotamer.setdefault(aa, {})
        self.frequencies_from_rotamer[aa][rot] = freq
      self.resAtomsToChi[aa] = {}
      self.chisPerAA[aa] = f.properties[aa+".chis"] #gives aaName -> # of chis
      #print f.properties[aa+".angles"].split(",")
      anglelist = f.properties[aa+".angles"].split(",")
      rotamerlist = f.properties[aa+".rotamers"].split(",")
      #print anglelist.count('')
      self.anglesForAA[aa] = anglelist #aaName -> [mobile angles]
      chi_ctr = 0
      for angle in anglelist:
        if angle != '':
          key = aa+"."+angle
          #print key
          self.atomsForAngle[key] = f.properties[key].split(",") #aaName.angle -> atoms
          chi_atoms = f.properties[key]
          if aa == 'val' and angle == 'chi1':
            chi_atoms = chi_atoms.replace('CG1', 'CG2')
          elif aa == 'thr' and angle == 'chi1':
            chi_atoms = chi_atoms.replace('OG1', 'CG2')
          elif aa == 'ile' and angle == 'chi1':
            chi_atoms = chi_atoms.replace('CG1', 'CG2')
          self.resAtomsToChi[aa][chi_atoms] = angle
          if aa == 'leu' or aa == 'val' or aa == 'thr' or aa == 'arg':
            if chi_ctr < int(f.properties[aa+".chis"]):
              key2 = key + "_atoms"
              #print f.properties[aa+".chis"]
              #print chi_ctr
              self.atomsMoveWithAngle[key] = f.properties[key2].split(",")
        chi_ctr+=1
      self.rotamersForAA[aa] = rotamerlist
      for rotamer in rotamerlist:
        if rotamer != '':
          key = aa+"."+rotamer
          self.anglesForRot[key] = f.properties[key].split(" ")

  def get_rotamers(self, residue_name):
    rotamers = {}
    aa = residue_name.lower()
    if (not aa in self.rotamersForAA):
      return None
    rotamer_list = self.rotamersForAA.get(aa)
    for rotamer in rotamer_list :
      if (rotamer != ""):
        key = aa + "." + rotamer
        rotamers[rotamer] = [ float(x) for x in self.anglesForRot[key] ]
    return rotamers

  def get_rotamer_angles(self, residue_name, rotamer_name):
    return_angles = []
    aa = residue_name.lower()
    key = aa + '.' + rotamer_name
    angles = self.anglesForRot.get(key)
    if angles is None:
      return None
    for angle in angles:
      return_angles.append(float(angle))
    return return_angles

  def get_rotamer_expectation_frequencies(self, residue_name, rotamer_name):
    aa = residue_name.lower()
    if (not aa in self.rotamersForAA): return None
    freqs = self.frequencies_from_rotamer.get(aa)
    if not freqs: return None
    return freqs.get(rotamer_name, None)

  def measureChiAngles(
        self,
        res,
        atom_dict = None,
        sites_cart = None):
    resName = res.resname.lower().strip()
    get_class = iotbx.pdb.common_residue_names_get_class
    if(get_class(res.resname) == "common_amino_acid"):
      try:
        numChis = int(self.chisPerAA[resName])
        values = []
        for i in range(numChis):
          values.append(self.measureAngle(
                          angleName="chi"+str(i+1),
                          res=res,
                          atom_dict=atom_dict,
                          sites_cart=sites_cart))
        return values
      except KeyError:
        if self.show_errors: print(resName + " is an unknown residue type")
        return None
    else:
      return None

#  def measureChiAnglesDict(self, atom_dict, resName):
#    try:
#      numChis = int(self.chisPerAA[resName])
#      values = []
#      for i in range(numChis):
#        values.append(self.measureAngle("chi"+str(i+1), res))
#      return values
#    except KeyError:
#      resName + " is unknown"

  def measureAngle(self, angleName, res, atom_dict, sites_cart=None):
    angleAtoms = self.extract_chi_atoms(
                   angleName=angleName,
                   res=res,
                   atom_dict=atom_dict)
    if angleAtoms is None:
      return None
    if sites_cart is None:
      sites = [a.xyz for a in angleAtoms]
    else:
      sites = []
      for a in angleAtoms:
        sites.append(sites_cart[a.i_seq])
    return scitbx.math.dihedral_angle(
      sites=sites, deg=True)

  def extract_chi_atoms(self, angleName, res, atom_dict=None):
    atomNamesMap = None
    if (atom_dict is None):
      atomNamesMap = makeAtomDict(res)
    else:
      atomNamesMap = atom_dict
    atomNames = self.atomsForAngle[res.resname.lower().strip()+"."+angleName]
    angleAtoms = []
    for at in atomNames:
      namelist = at.split(";")
      testAtom = None
      j = 0
      while (testAtom == None and j < len(namelist)):
        testAtom = atomNamesMap.get(namelist[j])
        j += 1
      if (testAtom != None):
        angleAtoms.append(atomNamesMap.get(testAtom.name))
      else:
        return None
    return angleAtoms

def makeAtomDict(res):
  atomNamesMap = {}
  for atom in res.atoms():
    atomNamesMap[atom.name] = atom
  return atomNamesMap

def collect_sidechain_chi_angles(pdb_hierarchy, atom_selection=None):

  angle_lookup = SidechainAngles(False)
  residue_chis = []
  if atom_selection is not None:
    if (isinstance(atom_selection, flex.bool)):
      actual_selection = atom_selection
    elif (isinstance(atom_selection, flex.size_t)):
      actual_selection = flex.bool(pdb_hierarchy.atoms_size(), False)
      actual_selection.set_selected(atom_selection, True)
  if atom_selection is None:
    actual_selection = flex.bool(pdb_hierarchy.atoms_size(), True)

  for model in pdb_hierarchy.models():
    for chain in model.chains():
      for conformer in chain.conformers():
        for residue in conformer.residues():
          n_chi = angle_lookup.chisPerAA.get(residue.resname.lower(), 0)
          try :
            n_chi = int(n_chi)
          except ValueError :
            continue
          chis = []
          altloc = residue.atoms()[0].fetch_labels().altloc
          i_seqs = []
          for i in range(1, n_chi+1):
            atoms = angle_lookup.extract_chi_atoms("chi%d" % i, residue)
            if atoms is None:
              pass
            else :
              i_seqs = [ atom.i_seq for atom in atoms ]
              if actual_selection.select(flex.size_t(i_seqs)).all_eq(True):
                chis.append(group_args(chi_id=i, i_seqs=i_seqs))
          if len(chis) > 0:
            residue_info = group_args(
              residue_name=residue.resname,
              chain_id=chain.id,
              altloc=altloc,
              resid=residue.resid(),
              chis=chis)
            residue_chis.append(residue_info)
  return residue_chis

def collect_residue_torsion_angles(pdb_hierarchy,
                                    atom_selection=None,
                                    chi_angles_only=False):
  get_class = iotbx.pdb.common_residue_names_get_class
  residue_torsions = []

  ### chi angles ###
  residue_chis = collect_sidechain_chi_angles(
                   pdb_hierarchy=pdb_hierarchy,
                   atom_selection=atom_selection)
  residue_torsions = residue_chis
  if chi_angles_only:
    return residue_torsions

  ##################

  if atom_selection is not None:
    if (isinstance(atom_selection, flex.bool)):
      actual_selection = atom_selection
    elif (isinstance(atom_selection, flex.size_t)):
      actual_selection = flex.bool(pdb_hierarchy.atoms_size(), False)
      actual_selection.set_selected(atom_selection, True)
  if atom_selection is None:
    actual_selection = flex.bool(pdb_hierarchy.atoms_size(), True)
  previous_residue = None
  next_residue = None
  for model in pdb_hierarchy.models():
    for chain in model.chains():
      for conformer in chain.conformers():
        for i_res, residue in enumerate(conformer.residues()):
          if (get_class(residue.resname) != "common_amino_acid"):
            continue
          if i_res < (len(conformer.residues())-1):
            next_residue = conformer.residues()[i_res+1]
          else:
            next_residue = None
          torsions = []
          # atoms_to_work = [prevCA, prevC, curN, curCA, curC, nextN]
          atoms_to_work = [None]*6
          atoms_to_work[2] = residue.find_atom_by(name=" N  ")
          atoms_to_work[3] = residue.find_atom_by(name=" CA ")
          atoms_to_work[4] = residue.find_atom_by(name=" C  ")
          if previous_residue is not None:
            atoms_to_work[0] = previous_residue.find_atom_by(name=" CA ")
            atoms_to_work[1] = previous_residue.find_atom_by(name=" C  ")
          if next_residue is not None:
            atoms_to_work[5] = next_residue.find_atom_by(name=" N  ")

          # atoms_to_work = [prevCA, prevC, curN, curCA, curC, nextN]
          for i in range(len(atoms_to_work)):
            if (atoms_to_work[i] is not None and
                not actual_selection[atoms_to_work[i].i_seq]):
              atoms_to_work[i] = None
          for i, name in enumerate(["omega", "phi", "psi"]):
            if atoms_to_work[i:i+4].count(None) == 0:
              angle = mmtbx.rotamer.omega_from_atoms(
                  atoms_to_work[i],
                  atoms_to_work[i+1],
                  atoms_to_work[i+2],
                  atoms_to_work[i+3])
              if angle is not None:
                i_seqs = [
                    atoms_to_work[i].i_seq,
                    atoms_to_work[i+1].i_seq,
                    atoms_to_work[i+2].i_seq,
                    atoms_to_work[i+3].i_seq]
                torsions.append(group_args(chi_id=name, i_seqs=i_seqs))
          altloc = residue.atoms()[0].fetch_labels().altloc
          if len(torsions) > 0:
            residue_info = group_args(
              residue_name=residue.resname,
              chain_id=chain.id,
              altloc=altloc,
              resid=residue.resid(),
              chis=torsions)
            residue_torsions.append(residue_info)
          previous_residue = residue
  return residue_torsions


 *******************************************************************************


 *******************************************************************************
mmtbx/rotamer/tst_geostd_vs_sidechain_angles_props.py
from __future__ import absolute_import, division, print_function
import mmtbx.monomer_library.server
import mmtbx.rotamer.sidechain_angles
import sys, os
op = os.path

def run(args):
  assert len(args) == 0
  mon_lib_srv = mmtbx.monomer_library.server.server()
  SidechainAngles = mmtbx.rotamer.sidechain_angles.SidechainAngles(
    show_errs=True)
  assert SidechainAngles.get_rotamer_expectation_frequencies('GLY', 't') is None
  assert SidechainAngles.get_rotamer_expectation_frequencies('CYS', 't')=='26.33%'
  assert SidechainAngles.get_rotamer_expectation_frequencies('CYS', 'w') is None
  for resname_dot_tor_id,atom_names_raw \
        in SidechainAngles.atomsForAngle.items():
    resname, tor_id = resname_dot_tor_id.split(".")
    resname = resname.upper()
    atom_names = tuple([atom_name.split(";")[-1].strip()
      for atom_name in atom_names_raw])
    comp = mon_lib_srv.get_comp_comp_id_direct(comp_id=resname)
    for tor in comp.tor_list:
      if (tor.id == tor_id):
        if (tor.atom_ids() == atom_names):
          annotation = "OK"
        else:
          annotation = "MISMATCH"
        break
    else:
      annotation = "MISSING"
    print(resname, tor_id, atom_names, annotation)

if (__name__ == "__main__"):
  run(args=sys.argv[1:])


 *******************************************************************************


 *******************************************************************************
mmtbx/rotamer/tst_rotamer_eval.py
from __future__ import absolute_import, division, print_function
import mmtbx.monomer_library
from scitbx.array_family import flex
import iotbx.pdb
from mmtbx.rotamer.rotamer_eval import RotamerEval
from libtbx.test_utils import approx_equal

pdb_str1 = """\
CRYST1   16.960   19.455   19.841  90.00  90.00  90.00 P 1
SCALE1      0.058962  0.000000  0.000000        0.00000
SCALE2      0.000000  0.051401  0.000000        0.00000
SCALE3      0.000000  0.000000  0.050401        0.00000
ATOM      1  N   TYR A  20      10.418  10.903   8.137  1.00 23.81           N
ATOM      2  CA  TYR A  20      10.810   9.981   7.034  1.00 35.69           C
ATOM      3  C   TYR A  20       9.703   8.988   6.760  1.00 28.94           C
ATOM      4  O   TYR A  20       9.364   8.158   7.667  1.00 25.26           O
ATOM      5  CB  TYR A  20      12.115   9.280   7.395  1.00 33.37           C
ATOM      6  CG  TYR A  20      13.316  10.201   7.509  1.00 31.48           C
ATOM      7  CD1 TYR A  20      14.071  10.517   6.393  1.00 36.91           C
ATOM      8  CD2 TYR A  20      13.704  10.721   8.703  1.00 21.36           C
ATOM      9  CE1 TYR A  20      15.188  11.317   6.471  1.00 36.56           C
ATOM     10  CE2 TYR A  20      14.835  11.519   8.817  1.00 29.56           C
ATOM     11  CZ  TYR A  20      15.540  11.837   7.694  1.00 35.08           C
ATOM     12  OH  TYR A  20      16.672  12.664   7.781  1.00 38.73           O
ATOM     13  N  AARG A  21       9.160   8.989   5.577  0.50 38.95           N
ATOM     14  CA AARG A  21       8.073   8.140   5.126  0.50 38.77           C
ATOM     15  C  AARG A  21       6.863   8.252   6.048  0.50 27.69           C
ATOM     16  O  AARG A  21       6.208   7.218   6.352  0.50 22.82           O
ATOM     17  CB AARG A  21       8.542   6.674   5.053  0.50 20.00           C
ATOM     18  CG AARG A  21       7.471   5.695   4.562  0.50 20.00           C
ATOM     19  CD AARG A  21       8.021   4.282   4.444  0.50 20.00           C
ATOM     20  NE AARG A  21       6.983   3.348   3.946  0.50 20.00           N
ATOM     21  CZ AARG A  21       5.878   3.748   3.337  0.50 20.00           C
ATOM     22  NH1AARG A  21       5.643   5.047   3.127  0.50 20.00           N
ATOM     23  NH2AARG A  21       4.997   2.854   2.938  0.50 20.00           N
ATOM     13  N  BTRP A  21       9.160   8.989   5.577  0.50 38.95           N
ATOM     14  CA BTRP A  21       8.073   8.140   5.126  0.50 38.77           C
ATOM     15  C  BTRP A  21       6.863   8.252   6.048  0.50 27.69           C
ATOM     16  O  BTRP A  21       6.208   7.218   6.352  0.50 22.82           O
ATOM     17  CB BTRP A  21       8.532   6.683   5.040  0.50 20.00           C
ATOM     18  CG BTRP A  21       9.522   6.431   3.944  0.50 20.00           C
ATOM     19  CD1BTRP A  21      10.883   6.417   4.051  0.50 20.00           C
ATOM     20  CD2BTRP A  21       9.228   6.154   2.569  0.50 20.00           C
ATOM     21  NE1BTRP A  21      11.453   6.152   2.830  0.50 20.00           N
ATOM     22  CE2BTRP A  21      10.459   5.985   1.902  0.50 20.00           C
ATOM     23  CE3BTRP A  21       8.047   6.033   1.829  0.50 20.00           C
ATOM     24  CZ2BTRP A  21      10.541   5.702   0.540  0.50 20.00           C
ATOM     25  CZ3BTRP A  21       8.131   5.752   0.478  0.50 20.00           C
ATOM     26  CH2BTRP A  21       9.368   5.590  -0.152  0.50 20.00           C
ATOM     29  N  CHIS A  21       9.160   8.989   5.577  1.00 38.95           N
ATOM     30  CA CHIS A  21       8.073   8.140   5.126  1.00 38.77           C
ATOM     31  C  CHIS A  21       6.863   8.252   6.048  1.00 27.69           C
ATOM     32  O  CHIS A  21       6.208   7.218   6.352  1.00 22.82           O
ATOM     33  CB CHIS A  21       8.533   6.684   5.037  1.00 20.00           C
ATOM     34  CG CHIS A  21       9.008   6.118   6.338  1.00 20.00           C
ATOM     35  ND1CHIS A  21       8.412   6.420   7.544  1.00 20.00           N
ATOM     36  CD2CHIS A  21      10.019   5.265   6.623  1.00 20.00           C
ATOM     37  CE1CHIS A  21       9.038   5.781   8.515  1.00 20.00           C
ATOM     38  NE2CHIS A  21      10.017   5.071   7.985  1.00 20.00           N
ATOM     32  N   GLY A  22       6.554   9.436   6.463  1.00 24.85           N
ATOM     33  CA  GLY A  22       5.410   9.707   7.327  1.00 29.53           C
ATOM     34  C   GLY A  22       5.748   9.622   8.821  1.00 33.22           C
ATOM     35  O   GLY A  22       5.479  10.518   9.577  1.00 30.06           O
ATOM     36  N   TYR A  23       6.330   8.487   9.201  1.00 27.25           N
ATOM     37  CA  TYR A  23       6.695   8.251  10.596  1.00 34.16           C
ATOM     38  C   TYR A  23       7.852   9.136  11.044  1.00 23.48           C
ATOM     39  O   TYR A  23       8.641   9.570  10.203  1.00 39.30           O
ATOM     40  CB  TYR A  23       7.052   6.786  10.831  1.00 29.65           C
ATOM     41  CG  TYR A  23       5.903   5.834  10.636  1.00 34.88           C
ATOM     42  CD1 TYR A  23       5.022   5.540  11.687  1.00 30.77           C
ATOM     43  CD2 TYR A  23       5.649   5.271   9.396  1.00 32.29           C
ATOM     44  CE1 TYR A  23       3.990   4.674  11.505  1.00 39.91           C
ATOM     45  CE2 TYR A  23       4.589   4.378   9.190  1.00 30.45           C
ATOM     46  CZ  TYR A  23       3.770   4.107  10.257  1.00 37.13           C
ATOM     47  OH  TYR A  23       2.693   3.226  10.097  1.00 38.59           O
ATOM     48  N   SER A  24       7.948   9.408  12.310  1.00 36.25           N
ATOM     49  CA  SER A  24       9.013  10.264  12.855  1.00 26.44           C
ATOM     50  C   SER A  24       9.607   9.636  14.109  1.00 20.40           C
ATOM     51  O   SER A  24       8.916   9.382  15.096  1.00 39.27           O
ATOM     52  CB  SER A  24       8.482  11.655  13.176  1.00 21.07           C
ATOM     53  OG  SER A  24       7.498  11.601  14.206  1.00 34.95           O
TER      54      SER A  24
END
"""

pdb_str2 = """\
ATOM     28  N   PRO C  29      61.293  16.365  38.366  1.00 45.42           N
ATOM     29  CA  PRO C  29      61.610  17.144  39.554  1.00 51.27           C
ATOM     30  C   PRO C  29      60.399  17.813  40.109  1.00 50.43           C
ATOM     31  O   PRO C  29      59.324  17.664  39.560  1.00 47.67           O
ATOM     32  CB  PRO C  29      62.495  18.235  38.993  1.00 49.45           C
ATOM     33  CG  PRO C  29      61.908  18.507  37.705  1.00 55.39           C
ATOM     34  CD  PRO C  29      61.575  17.152  37.157  1.00 56.41           C
"""

pdb_str3 = """\
ATOM    127  N   PRO L  18      18.596 -78.410  66.845  1.00 33.30           N
ATOM    128  CA  PRO L  18      19.467 -77.234  66.790  1.00 32.71           C
ATOM    129  C   PRO L  18      20.924 -77.585  66.494  1.00 30.96           C
ATOM    130  O   PRO L  18      21.369 -78.705  66.735  1.00 30.74           O
ATOM    131  CB  PRO L  18      19.289 -76.622  68.173  1.00 31.82           C
ATOM    132  CG  PRO L  18      19.175 -77.838  69.037  1.00 33.36           C
ATOM    133  CD  PRO L  18      18.236 -78.728  68.240  1.00 34.01           C
ATOM    134  N   ALA L  19      21.657 -76.614  65.963  1.00 28.50           N
ATOM    135  CA  ALA L  19      23.064 -76.802  65.641  1.00 27.23           C
ATOM    136  C   ALA L  19      23.816 -75.537  66.027  1.00 27.07           C
ATOM    137  O   ALA L  19      23.265 -74.434  65.976  1.00 24.32           O
ATOM    138  CB  ALA L  19      23.231 -77.079  64.157  1.00 30.04           C
ATOM    139  N   SER L  20      25.075 -75.694  66.411  1.00 24.81           N
ATOM    140  CA  SER L  20      25.874 -74.549  66.816  1.00 27.97           C
ATOM    141  C   SER L  20      27.304 -74.675  66.310  1.00 26.96           C
ATOM    142  O   SER L  20      27.912 -75.739  66.408  1.00 27.07           O
ATOM    143  CB  SER L  20      25.863 -74.436  68.344  1.00 29.31           C
ATOM    144  OG  SER L  20      26.505 -73.254  68.779  1.00 39.96           O
"""

def run(pdb_str, expected_ids):
  get_class = iotbx.pdb.common_residue_names_get_class
  mon_lib_srv = mmtbx.monomer_library.server.server()
  rotamer_manager = RotamerEval()
  pdb_inp = iotbx.pdb.input(source_info=None, lines=pdb_str)
  pdb_hierarchy = pdb_inp.construct_hierarchy()
  result_ids = []
  for residue_group in pdb_hierarchy.residue_groups():
    for conformer in residue_group.conformers():
      for residue in conformer.residues():
        sites_cart = residue.atoms().extract_xyz()
        rotamer_name = rotamer_manager.evaluate_residue(residue=residue)
        print(residue.resname, residue.resseq, rotamer_name)
        result_ids.append(rotamer_name)
        if(get_class(residue.resname) == "common_amino_acid"):
          rotamer_iterator = mon_lib_srv.rotamer_iterator(
              fine_sampling = True,
              comp_id       = residue.resname,
              atom_names    = residue.atoms().extract_name(),
              sites_cart    = sites_cart)
          if(rotamer_iterator is None or
             rotamer_iterator.problem_message is not None or
             rotamer_iterator.rotamer_info is None):
            rotamer_iterator = None
          if(rotamer_iterator is not None):
            d1_min, d2_min = 1.e+9, 1.e+9
            for r, rotamer_sites_cart in rotamer_iterator:
              sites_cart_rot = rotamer_manager.nearest_rotamer_sites_cart(
                residue=residue)
              d1= flex.mean(flex.sqrt((sites_cart - sites_cart_rot).dot()))
              d2= flex.mean(flex.sqrt((sites_cart - rotamer_sites_cart).dot()))
              if(d1 < d1_min):
                d1_min = d1
              if(d2 < d2_min):
                d2_min = d2
            assert approx_equal(d1_min, d2_min)
  assert result_ids == expected_ids

if(__name__ == "__main__"):
  run(pdb_str = pdb_str1, expected_ids=['m-80', 'OUTLIER', 'm100', 'OUTLIER', None, 'm-80', 'p'])
  run(pdb_str = pdb_str2, expected_ids=['Cg_endo'])
  run(pdb_str = pdb_str3, expected_ids=['Cg_endo', 'EXCEPTION', 't'])


 *******************************************************************************
