

 *******************************************************************************
wxtbx/__init__.py
from __future__ import absolute_import, division, print_function
import wx
import os

from libtbx.version import get_version

__version__ = get_version()

global default_font_size

MAC_OS_X_MAVERICKS = False
if (wx.Platform == '__WXMSW__'):
  default_font_size = 9
elif (wx.Platform == '__WXMAC__'):
  default_font_size = 12
  os_version = os.uname()[2].split(".")
  if (int(os_version[0]) >= 13):
    MAC_OS_X_MAVERICKS = True
else :
  default_font_size = 11

class MouseWheelTransparencyMixin(object):
  """
  This mixin provides an event handler for passing the mouse wheel event to
  the parent, presumably a ScrolledPanel or similar.  For this to happen, the
  actual class must bind wx.EVT_MOUSEWHEEL to self.OnMouseWheel.
  """
  def OnMouseWheel(self, evt):
    parent = self.GetParent()
    evt.SetId(parent.GetId())
    evt.SetEventObject(parent)
    parent.GetEventHandler().ProcessEvent(evt)

def is_unicode_build():
  return (wx.PlatformInfo[2] == 'unicode')


 *******************************************************************************


 *******************************************************************************
wxtbx/adp_statistics.py

from __future__ import absolute_import, division, print_function
from wxtbx import plots
import wx
import sys
from six.moves import range

#-----------------------------------------------------------------------
# GUI objects
class ADPStatisticsFrame(wx.Frame):
  def __init__(self, *args, **kwds):
    super(ADPStatisticsFrame, self).__init__(*args, **kwds)
    s = wx.BoxSizer(wx.VERTICAL)
    self.SetSizer(s)
    p = wx.Panel(self)
    s.Add(p, 1, wx.EXPAND)
    s2 = wx.BoxSizer(wx.VERTICAL)
    p.SetSizer(s2)
    s0 = wx.BoxSizer(wx.HORIZONTAL)
    s2.Add(s0)
    txt0 = wx.StaticText(p, -1, "PDB file:")
    s0.Add(txt0, 0, wx.ALL|wx.ALIGN_CENTER_VERTICAL, 5)
    self.file_text = wx.StaticText(p, -1, "--unknown--")
    s0.Add(self.file_text, 1, wx.ALL|wx.ALIGN_CENTER_VERTICAL|wx.EXPAND, 5)
    s1 = wx.BoxSizer(wx.HORIZONTAL)
    s2.Add(s1)
    txt00 = wx.StaticText(p, -1, "Atom selection:")
    s1.Add(txt00, 0, wx.ALL|wx.ALIGN_CENTER_VERTICAL, 5)
    self.sele_text = wx.StaticText(p, -1, "(all)")
    s1.Add(self.sele_text, 1, wx.ALL|wx.ALIGN_CENTER_VERTICAL|wx.EXPAND, 5)
    txt1 = wx.StaticText(p, -1, "Overall statistics:")
    s2.Add(txt1, 0, wx.ALL|wx.ALIGN_CENTER_VERTICAL, 5)
    if (sys.platform == "darwin"):
      size1 = (720,120)
    else :
      size1 = (720,160) # FIXME check this on Linux
    self.list1 = wx.ListCtrl(p, style=wx.LC_REPORT, size=size1)
    self.list1.InsertColumn(0, "Atom type", width=100)
    self.list1.InsertColumn(1, "# iso", width=60, format=wx.LIST_FORMAT_RIGHT)
    self.list1.InsertColumn(2, "# aniso", width=60, format=wx.LIST_FORMAT_RIGHT)
    self.list1.InsertColumn(3, "Iso min.", width=80,format=wx.LIST_FORMAT_RIGHT)
    self.list1.InsertColumn(4, "Iso max.", width=80,format=wx.LIST_FORMAT_RIGHT)
    self.list1.InsertColumn(5, "Iso mean", width=80,format=wx.LIST_FORMAT_RIGHT)
    self.list1.InsertColumn(6, "Aniso min.", width=80,
      format=wx.LIST_FORMAT_RIGHT)
    self.list1.InsertColumn(7, "Aniso max.", width=80,
      format=wx.LIST_FORMAT_RIGHT)
    self.list1.InsertColumn(8, "Aniso mean", width=80,
      format=wx.LIST_FORMAT_RIGHT)
    for i in range(9) : # FIXME this doesn't work!!!
      continue
      col = self.list1.GetColumn(i)
      font = col.GetFont()
      font.SetPointSize(9)
      col.SetFont(font)
    s2.Add(self.list1, 0, wx.ALL|wx.ALIGN_CENTER_VERTICAL, 5)
    txt2 = wx.StaticText(p, -1,
      "Distribution of isotropic (or equivalent) ADP for non-H atoms:")
    s2.Add(txt2, 0, wx.ALL|wx.ALIGN_CENTER_VERTICAL, 5)
    s3 = wx.BoxSizer(wx.HORIZONTAL)
    s3.Add((5,1))
    s2.Add(s3, 0, wx.EXPAND)
    self.list2 = wx.ListCtrl(p, style=wx.LC_REPORT, size=(300,200))
    self.list2.InsertColumn(0, "Bin", width=50)
    self.list2.InsertColumn(1, "Value range", width=180)
    self.list2.InsertColumn(2, "#atoms", width=60, format=wx.LIST_FORMAT_RIGHT)
    for i in range(3):
      continue
      col = self.list2.GetColumn(i)
      font = col.GetFont()
      font.SetPointSize(9)
      col.SetFont(font)
    s3.Add(self.list2, 0, wx.ALL|wx.ALIGN_CENTER_VERTICAL|wx.EXPAND, 5)
    self.plot1 = adp_histogram(p, figure_size=(4,3))
    s3.Add(self.plot1, 1, wx.ALL|wx.ALIGN_CENTER_VERTICAL|wx.EXPAND, 5)
    txt3 = wx.StaticText(p, -1, "Distribution of anisotropy:")
    s2.Add(txt3)
    s4 = wx.BoxSizer(wx.HORIZONTAL)
    s4.Add((5,1))
    s2.Add(s4, 0, wx.EXPAND)
    self.list3 = wx.ListCtrl(p, style=wx.LC_REPORT, size=(300,200))
    self.list3.InsertColumn(0, "Bin", width=50)
    self.list3.InsertColumn(1, "Value range", width=180)
    self.list3.InsertColumn(2, "#atoms", width=60, format=wx.LIST_FORMAT_RIGHT)
    for i in range(3):
      continue
      col = self.list3.GetColumn(i)
      font = col.GetFont()
      font.SetPointSize(9)
      col.SetFont(font)
    s4.Add(self.list3, 0, wx.ALL|wx.ALIGN_CENTER_VERTICAL|wx.EXPAND, 5)
    self.plot2 = adp_histogram(p, figure_size=(4,3))
    s4.Add(self.plot2, 1, wx.ALL|wx.ALIGN_CENTER_VERTICAL|wx.EXPAND, 5)
    s.Fit(p)
    self.Fit()

  def show_statistics(self, stats):
    file_name = getattr(stats, "file_name", None)
    if (file_name is not None):
      self.file_text.SetLabel(file_name)
    selection = getattr(stats, "selection", None)
    if (selection is not None):
      self.sele_text.SetLabel(selection)
    t1, t2, t3 = stats.format_tables()
    for row in t1 :
      i = self.list1.InsertStringItem(sys.maxunicode, str(row[0]))
      for j, value in enumerate(row[1:]):
        self.list1.SetStringItem(i, j+1, str(value))
    for row in t2 :
      i = self.list2.InsertStringItem(sys.maxunicode, str(row[0]))
      for j, value in enumerate(row[1:]):
        self.list2.SetStringItem(i, j+1, str(value))
    for row in t3 :
      i = self.list3.InsertStringItem(sys.maxunicode, str(row[0]))
      for j, value in enumerate(row[1:]):
        self.list3.SetStringItem(i, j+1, str(value))
    p1, p2 = stats.format_plots()
    y1, yrange1 = p1
    y2, yrange2 = p2
    if (not y1.all_eq(0)):
      self.plot1.convert_histogram(y1)
    if (not y2.all_eq(0)):
      self.plot2.convert_histogram(y2)

class adp_histogram(plots.histogram):
  def convert_histogram(self, bins):
    # XXX flex.histogram has already binned values, so I make new fake values
    # that matplotlib then re-bins
    values = []
    for i, x in enumerate(bins):
      values.extend([i] * x)
    self.show_histogram(values, len(bins), y_label="# of atoms")

if (__name__ == "__main__"):
  from mmtbx.command_line import b_factor_statistics
  stats = b_factor_statistics.run(sys.argv[1:])
  app = wx.App(0)
  frame = ADPStatisticsFrame(None, -1, "ADP statistics")
  frame.show_statistics(stats)
  frame.Show()
  app.MainLoop()


 *******************************************************************************


 *******************************************************************************
wxtbx/anomalous_scattering.py

from __future__ import absolute_import, division, print_function
import wxtbx.plots
from wxtbx.phil_controls import strctrl, floatctrl
from libtbx.utils import Sorry
import wx
from six.moves import range

class AnomPlot(wxtbx.plots.plot_container):
  def __init__(self, *args, **kwds):
    wxtbx.plots.plot_container.__init__(self, *args, **kwds)
    self.canvas.mpl_connect('motion_notify_event', self.parent.OnHover)

  def show_plot(self,
      elements,
      range_type="wavelength",
      range_values=(0.75,2.5),
      n_points=100,
      include_fp=True,
      table="sasaki"):
    assert (range_type in ["wavelength", "energy"])
    assert (table in ["sasaki", "henke"])
    assert (n_points >= 10)
    x_min, x_max = range_values
    assert (x_max > x_min)
    if (range_type == "wavelength"):
      x_label = "Wavelength (Angstroms)"
    else :
      x_label= "Energy (eV)"
    table_module = None
    if (table == "sasaki"):
      from cctbx.eltbx import sasaki as table_module
    elif (table == "henke"):
      from cctbx.eltbx import henke as table_module
    assert (table_module is not None)
    increment = (x_max - x_min) / n_points
    x_points = [ x_min + increment*x for x in range(n_points+1) ]
    self.figure.clear()
    ax = self.figure.add_subplot(111)
    labels = []
    for element in elements :
      try :
        scatt_table = table_module.table(element.upper())
      except ValueError as e :
        raise Sorry(str(e))
      fp = []
      fdp = []
      for x in x_points :
        if (range_type == "wavelength"):
          scatt = scatt_table.at_angstrom(x)
        else :
          scatt = scatt_table.at_ev(x)
        fp.append(scatt.fp())
        fdp.append(scatt.fdp())
      fdp_line = ax.plot(x_points, fdp)[0]
      ax.plot(x_points, fp, linestyle='--', color=fdp_line.get_color())
      labels.append("%s f''" % scatt_table.label())
      labels.append("%s f'" % scatt_table.label())
    self.figure.legend(ax.lines, labels)
    ax.set_xlabel(x_label)
    ax.set_ylabel("e-")
    self.canvas.draw()

  def OnHover(self, mpl_event):
    (xdata, ydata) = (mpl_event.xdata, mpl_event.ydata)

class AnomPlotFrame(wxtbx.plots.plot_frame):
  def draw_top_panel(self):
    self.top_panel = ControlPanel(parent=self, style=wx.SUNKEN_BORDER)
    self.statusbar = self.CreateStatusBar()

  def create_plot_panel(self):
    return AnomPlot(parent=self, figure_size=(12,6))

  def update_plot(self, *args, **kwds):
    self.plot_panel.show_plot(*args, **kwds)
    self.Refresh()

  def OnHover(self, mpl_event):
    (xdata, ydata) = (mpl_event.xdata, mpl_event.ydata)
    if (xdata is None) or (ydata is None):
      self.statusbar.SetStatusText("")
    else :
      wavelength = energy = 0
      if (xdata < 10):
        wavelength = xdata
        if (xdata != 0):
          energy = 12398 / xdata
      else :
        energy = xdata
        if (xdata != 0):
          wavelength = 12398 / energy
      status_label = "Wavelength=%.3f A   Energy=%.3f eV  e-=%.3f" % (
        wavelength, energy, ydata)
      self.statusbar.SetStatusText(status_label)

class ControlPanel(wx.Panel):
  def __init__(self, *args, **kwds):
    wx.Panel.__init__(self, *args, **kwds)
    szr = wx.BoxSizer(wx.VERTICAL)
    self.SetSizer(szr)
    szr1 = wx.BoxSizer(wx.HORIZONTAL)
    szr.Add(szr1)
    txt1 = wx.StaticText(self, -1, "Elements:")
    szr1.Add(txt1, 0, wx.ALL, 5)
    self.elem_ctrl = strctrl.StrCtrl(
      parent=self,
      name="Elements",
      size=(200,-1))
    self.elem_ctrl.SetOptional(False)
    szr1.Add(self.elem_ctrl, 0, wx.ALL, 5)
    szr1.Add(wx.StaticText(self, -1, "Table:"), 0, wx.ALL, 5)
    self.table_choice = wx.Choice(parent=self,
      choices=["Sasaki", "Henke"])
    szr1.Add(self.table_choice, 0, wx.ALL, 5)
    szr2 = wx.BoxSizer(wx.HORIZONTAL)
    szr.Add(szr2)
    self.range_choice = wx.Choice(parent=self,
      choices=["Wavelength", "Energy"])
    szr2.Add(self.range_choice, 0, wx.ALL, 5)
    self.Bind(wx.EVT_CHOICE, self.OnChangeRange, self.range_choice)
    self.range_min = floatctrl.FloatCtrl(
      parent=self, name="Range minimum")
    self.range_min.SetMin(0.5)
    self.range_min.SetMax(5.0)
    self.range_min.SetOptional(False)
    self.range_max = floatctrl.FloatCtrl(
      parent=self, name="Range maximum")
    self.range_max.SetMin(0.5)
    self.range_max.SetMax(5.0)
    self.range_max.SetOptional(False)
    szr2.Add(wx.StaticText(self, -1, "min:"), 0, wx.ALL, 5)
    szr2.Add(self.range_min, 0, wx.ALL, 5)
    szr2.Add(wx.StaticText(self, -1, "max:"), 0, wx.ALL, 5)
    szr2.Add(self.range_max, 0, wx.ALL, 5)
    btn = wx.Button(self, -1, "Redraw plot")
    self.Bind(wx.EVT_BUTTON, self.OnUpdatePlot, btn)
    szr2.Add(btn, 0, wx.ALL, 5)

  def OnChangeRange(self, evt):
    range_type = self.range_choice.GetStringSelection()
    if (range_type == "Wavelength"):
      self.range_min.SetMin(0.75)
      self.range_min.SetMax(5.0)
      self.range_max.SetMin(0.75)
      self.range_max.SetMax(5.0)
    else :
      self.range_min.SetMin(2500)
      self.range_min.SetMax(16000)
      self.range_max.SetMin(2500)
      self.range_max.SetMax(16000)

  def OnUpdatePlot(self, evt):
    elements_str = self.elem_ctrl.GetPhilValue()
    elements = elements_str.replace(",", " ").split()
    from cctbx.eltbx import chemical_elements
    allowed_list = chemical_elements.proper_upper_list()
    for elem in elements :
      if (len(elem) > 2):
        raise Sorry(
          "You must enter standard chemical element symbols (H, Zn, etc.).")
      if (not elem.upper() in allowed_list):
        raise Sorry("The symbol '%s' is not a recognized chemical element." %
          elem)
    range_min = self.range_min.GetPhilValue()
    range_max = self.range_max.GetPhilValue()
    range_type = self.range_choice.GetStringSelection().lower()
    table = self.table_choice.GetStringSelection().lower()
    if (range_max <= range_min):
      raise Sorry("The range maximum must be greater than the minimum")
    self.GetParent().update_plot(
      elements=elements,
      range_type=range_type,
      range_values=(range_min,range_max),
      table=table,
      include_fp=True)


 *******************************************************************************


 *******************************************************************************
wxtbx/app.py
from __future__ import absolute_import, division, print_function

from wxtbx import errors
import wx
import sys

class CCTBXApp(wx.App):
  def __init__(self, *args, **kwds):

    # hide GTK messages
    if kwds.pop('gtk_suppress_diagnostics', True):
      try:
        wx.App.GTKSuppressDiagnostics()
      except AttributeError:
        pass

    wx.App.__init__(self, *args, **kwds)

  def OnInit(self):
    sys.excepthook = errors.wx_excepthook
    return True

  def SetTaskbarIcon(self, icon_path, label):
    icon = wx.Icon(icon_path, wx.BITMAP_TYPE_PNG)
    if ((wx.Platform == '__WXMAC__') and (wx.VERSION >= (2,9)) and
        (hasattr(wx, "TBI_DOCK"))):
      self.icon = wx.TaskBarIcon(wx.TBI_DOCK)
    else :
      self.icon = wx.TaskBarIcon()
    self.icon.SetIcon(icon, label)


 *******************************************************************************


 *******************************************************************************
wxtbx/b_plot.py
from __future__ import absolute_import, division, print_function

from wxtbx import plots
import wx
import libtbx.phil
from libtbx.utils import Sorry
from libtbx import adopt_init_args
import sys
from six.moves import zip

master_phil = libtbx.phil.parse("""
b_plot
  .short_caption = B-factor plot
  .caption = This utility will plot the B-factors for each protein or nucleic \
    acid chain in the input PDB file.  Waters and ligands will be ignored.  \
    A more comprehensive plot is available as part of the PHENIX validation \
    program, which incorporates real-space correlation to electron density, \
    adds markers for geometry outliers, and interfaces with Coot and PyMOL.
  .style = box auto_align caption_img:icons/crystal_project/32x32/mimetypes/spreadsheet.png
{
  pdb_file = None
    .type = path
    .short_caption = PDB file
    .style = bold file_type:pdb
  average_b_over = *residue mainchain sidechain
    .type = choice(multi=False)
    .short_caption = Average B-factors over
    .style = bold
  use_z_scores = False
    .type = bool
  plot_range = *by_chain each_100_residues
    .type = choice(multi=False)
    .short_caption = Range of plot
    .caption = One_chain_at_a_time Every_100_residues
    .style = hidden
}
""")

class residue_info(object):
  def __init__(self,
                chain_id,
                resseq,
                icode,
                has_altconf,
                has_partocc,
                avg_b):
    adopt_init_args(self, locals())

class analyze(object):
  def __init__(self, pdb_hierarchy, xray_structure, params, out=sys.stdout):
    from cctbx import adptbx
    from scitbx.array_family import flex
    self.plot_range = params.plot_range
    self.chains = []
    self.residues = []
    b_isos = xray_structure.extract_u_iso_or_u_equiv() * adptbx.u_as_b(1.0)
    if params.use_z_scores: b_isos.as_z_scores()
    occ = pdb_hierarchy.atoms().extract_occ()
    model = pdb_hierarchy.models()[0]
    for chain in model.chains():
      main_conf = chain.conformers()[0]
      is_na = main_conf.is_na()
      is_protein = main_conf.is_protein()
      if (not is_protein) and (not is_na):
        print("Skipping chain '%s' - not protein or DNA/RNA." %chain.id, file=out)
        continue
      self.chains.append(chain.id)
      self.residues.append([])
      for residue_group in chain.residue_groups():
        n_conformers = len(residue_group.atom_groups())
        rg_i_seqs = residue_group.atoms().extract_i_seq()
        rg_occ = residue_group.atoms().extract_occ()
        if (params.average_b_over == "residue"):
          use_i_seqs = rg_i_seqs
        elif (params.average_b_over == "mainchain"):
          use_i_seqs = []
          if (is_protein):
            for j_seq, atom in enumerate(residue_group.atoms()):
              #alab = atom.fetch_labels()
              if (atom.name in [" N  ", " C  ", " CA ", " O  "]):
                use_i_seqs.append(rg_i_seqs[j_seq])
          else :
            raise Sorry("Mainchain-only mode not supported for nucleic acids.")
        else :
          use_i_seqs = []
          if (is_protein):
            for j_seq, atom in enumerate(residue_group.atoms()):
              if (not atom.name in [" N  ", " C  ", " CA ", " O  "]):
                use_i_seqs.append(rg_i_seqs[j_seq])
        if (len(use_i_seqs) > 0):
          has_partocc = ((flex.min(occ.select(use_i_seqs)) < 1.0) and
                         (n_conformers == 1))
          res_info = residue_info(
            chain_id=chain.id,
            resseq=residue_group.resseq_as_int(),
            icode=residue_group.icode,
            has_altconf=(n_conformers > 1),
            has_partocc=has_partocc,
            avg_b=flex.mean(b_isos.select(use_i_seqs)))
          self.residues[-1].append(res_info)

  def make_plots(self, plot_range=None):
    if (plot_range is None):
      plot_range = self.plot_range
    import numpy
    plots = []
    if (plot_range == "by_chain"):
      for chain, residues in zip(self.chains, self.residues):
        altconf_val = max(min([ resi.avg_b for resi in residues ]) - 2, 0)
        resid_start = ("%d%s" % (residues[0].resseq,residues[0].icode)).strip()
        resid_end = ("%d%s" % (residues[-1].resseq,residues[-1].icode)).strip()
        chain_vals = numpy.array([])
        is_altconf = numpy.array([])
        is_partocc = numpy.array([])
        labels = []
        last_resseq = None
        for residue in residues :
          if (last_resseq is not None):
            if (residue.resseq > (last_resseq + 1)):
              gap_size = residue.resseq - last_resseq
              chain_vals = numpy.append(chain_vals,[numpy.NaN]* gap_size)
              is_altconf = numpy.append(is_altconf,[numpy.NaN] * gap_size)
              is_partocc = numpy.append(is_partocc,[numpy.NaN] * gap_size)
              labels.extend([None] * gap_size)
          if (residue.has_altconf):
            is_altconf = numpy.append(is_altconf, altconf_val)
          else :
            is_altconf = numpy.append(is_altconf, numpy.NaN)
          if (residue.has_partocc):
            is_partocc = numpy.append(is_partocc, altconf_val)
          else :
            is_partocc = numpy.append(is_partocc, numpy.NaN)
          chain_vals = numpy.append(chain_vals,residue.avg_b)
          labels.append(("%d%s" % (residue.resseq, residue.icode)).strip())
          last_resseq = residue.resseq
        chain_label = "Chain '%s' (%s - %s)" % (chain, resid_start, resid_end)
        plots.append((chain_label, chain_vals, is_altconf, is_partocc, labels))
    return plots

def run(args=(), params=None, out=sys.stdout):
  pdb_file = params.b_plot.pdb_file
  import iotbx.pdb
  pdb_in = iotbx.pdb.input(pdb_file)
  hierarchy = pdb_in.construct_hierarchy()
  hierarchy.atoms().reset_i_seq()
  xrs = pdb_in.xray_structure_simple()
  return analyze(pdb_hierarchy=hierarchy,
    xray_structure=xrs,
    params=params.b_plot,
    out=out)

def show_plot_frame(result, parent=None):
  frame = BPlotFrame(parent, -1, "B-factor plot",
      style = wx.DEFAULT_FRAME_STYLE | wx.STAY_ON_TOP)
  plots = result.make_plots()
  if (len(plots) == 0):
    raise Sorry("No suitable chains found in PDB file.")
  frame.set_plot_data(plots)
  frame.Show()
  # Toggle it off/on to make sure it displays
  frame.OnToggleControls(None)
  frame.OnToggleControls(None)

class BPlotFrame(plots.plot_frame):
  def draw_top_panel(self):
    panel = wx.Panel(self)
    psizer = wx.BoxSizer(wx.VERTICAL)
    panel.SetSizer(psizer)
    txt1 = wx.StaticText(panel, -1, "Plot residues:")
    font = txt1.GetFont()
    font.SetWeight(wx.FONTWEIGHT_BOLD)
    txt1.SetFont(font)
    self.chooser = wx.Choice(panel, -1, choices=[], size=(200,-1))
    self.Bind(wx.EVT_CHOICE, self.OnChoosePlot, self.chooser)
    bsizer = wx.BoxSizer(wx.HORIZONTAL)
    bsizer.Add(txt1, 0, wx.ALL|wx.ALIGN_CENTER_VERTICAL, 5)
    bsizer.Add(self.chooser, 0, wx.ALL|wx.ALIGN_CENTER_VERTICAL, 5)
    psizer.Add(bsizer)
    self.top_panel = panel

  def create_plot_panel(self):
    return b_plot_panel(
      parent=self,
      figure_size=(8,6))

  def set_plot_data(self, plots):
    assert (len(plots) > 0)
    self._plot_data = plots
    all_b = []
    for avg_b in [ b for a,b,c,d,e in plots ] :
      all_b.extend(avg_b)
    self.plot_panel.set_limits(min(all_b) - 2, max(all_b) + 2)
    items = [ p[0] for p in plots ]
    self.chooser.SetItems(items)
    self.chooser.SetSelection(0)
    self.plot_panel.set_plot(self._plot_data[0])

  def OnChoosePlot(self, event):
    assert hasattr(self, "_plot_data")
    choice = event.GetEventObject().GetSelection()
    self.plot_panel.set_plot(self._plot_data[choice])

def extract_labels(labels):
  nx = len(labels)
  tickmarks = []
  show_labels = []
  if (nx <= 100):
    for i, s in enumerate(labels):
      if (s is not None) and (s.endswith("0")):
        tickmarks.append(i+1)
        show_labels.append(s)
  elif (nx <= 250):
    for i, s in enumerate(labels):
      if (s is not None) and (s[-2:] in ["00", "25", "50", "75"]):
        tickmarks.append(i+1)
        show_labels.append(s)
  elif (nx <= 500):
    for i, s in enumerate(labels):
      if (s is not None) and (s[-2:] in ["00", "50"]):
        tickmarks.append(i+1)
        show_labels.append(s)
  else :
    for i, s in enumerate(labels):
      if (s is not None) and (s.endswith("00")):
        tickmarks.append(i+1)
        show_labels.append(s)
  return (tickmarks, show_labels)

class b_plot_panel(plots.plot_container):
  def set_limits(self, ymin, ymax):
    self._ymin = ymin
    self._ymax = ymax

  def set_plot(self, plot):
    from matplotlib import cm
    from matplotlib.colors import BoundaryNorm
    from matplotlib.collections import LineCollection
    import numpy
    avg_b, is_alt, is_partial = plot[1], plot[2], plot[3]
    assert (len(avg_b) == len(is_alt) == len(is_partial))
    self.figure.clear()
    p = self.figure.add_subplot(1, 1, 1)
    p.set_ylabel("B-factor")
    p.set_xlabel("Residue")
    p.set_title("Average B-factor: %s" % plot[0])
    y = numpy.array(avg_b)
    x = numpy.linspace(1, y.size, y.size)
    points = numpy.array([x, y]).T.reshape(-1,1,2)
    y = numpy.nan_to_num(y)  # XXX to get rid of comparison errors
    yyy = y[y>0]
    b_range = numpy.linspace(yyy.min(), yyy.max(), cm.jet.N)
    norm = BoundaryNorm(b_range, 256)
    segments = numpy.concatenate([points[:-1], points[1:]], axis=1)
    lc = LineCollection(segments, cmap=cm.jet, norm=norm)
    lc.set_array(y)
    p.add_collection(lc)
    xmarks, xlabels = extract_labels(plot[4])
    p.set_xticks(xmarks)
    p.set_xticklabels(xlabels)
    p.set_ylim(self._ymin, self._ymax)
    p.set_xlim(0, len(plot[4]))
    plot_labels = ["B(iso)"]
    if (set(is_alt) != set([numpy.NaN])):
      p.plot(x, is_alt, "d", color='m')
      plot_labels.append("Alt. conf.")
    if (set(is_partial) != set([numpy.NaN])):
      p.plot(x, is_partial, "^", color='c')
      plot_labels.append("Partial occupancy")
    self.figure.legend(p.collections + p.lines, plot_labels, prop=self.get_font("legend"))
    self.canvas.draw()
    self.parent.Refresh()

def validate_params(params):
  import os
  import iotbx.pdb
  if (params.b_plot.pdb_file is None):
    raise Sorry("No PDB file defined!")
  if not os.path.isfile(params.b_plot.pdb_file):
    raise Sorry("The PDB file %s is missing" %(params.b_plot.pdb_file))
  try:
    pdb_in = iotbx.pdb.input(params.b_plot.pdb_file)
  except Exception as e:
    raise Sorry("The PDB file %s cannot be read or has no atoms?" %(params.b_plot.pdb_file))



 *******************************************************************************


 *******************************************************************************
wxtbx/bitmaps.py
from __future__ import absolute_import, division, print_function

from wx.lib.embeddedimage import PyEmbeddedImage
import wx
import libtbx.load_env
import os

blank16 = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAQAAAC1+jfqAAAAAXNSR0IArs4c6QAAAAJiS0dE"
    "AP+Hj8y/AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH2QsNFBwTBbkZpAAAABl0RVh0"
    "Q29tbWVudABDcmVhdGVkIHdpdGggR0lNUFeBDhcAAAAOSURBVCjPY2AYBaMAAQACEAABFMLA"
    "kgAAAABJRU5ErkJggg==")

icon_lib = libtbx.env.find_in_repositories(
  relative_path=os.path.join("gui_resources", "icons"),
  test=os.path.isdir)

image_cache = {}

def load_png_as_bitmap(icon_path, scale=None):
  bmp = image_cache.get(icon_path, None)
  if bmp is None :
    if (wx.Platform == '__WXMSW__') and (wx.VERSION >= (2,9)):
# libpng purists have now broken backwards compatibility when loading old images.
# This leads to unhelpful error message boxes. Suppress these temporarily with LogNull
      noLog = wx.LogNull()
      img = wx.Image(icon_path, type=wx.BITMAP_TYPE_PNG, index=-1)
    else:
      img = wx.Image(icon_path, type=wx.BITMAP_TYPE_PNG, index=-1)
    if (scale is not None):
      assert isinstance(scale, tuple)
      w, h = scale
      img = img.Scale(w, h, wx.IMAGE_QUALITY_NORMAL)
    bmp = img.ConvertToBitmap()
    image_cache[icon_path] = bmp
  return bmp

def find_crystal_icon(icon_class, name, size=32, scale=None):
  if icon_lib is not None :
    size_dir = "%dx%d" % (size, size)
    icon_path = os.path.join(icon_lib, "crystal_project", size_dir, icon_class,
      name + ".png")
    if os.path.isfile(icon_path):
      return icon_path
  return None

def fetch_icon_bitmap(*args, **kwds):
  icon_path = find_crystal_icon(*args, **kwds)
  if icon_path is None :
    return wx.NullBitmap
  icon_size = kwds.get("icon_size", None)
  if icon_size:
    scale = (icon_size, icon_size)
  else:
    scale = kwds.get("scale", None)
  return load_png_as_bitmap(icon_path, scale=scale)

def find_custom_icon(name, ext=".png", scale=None, icon_size=None):
  if icon_lib is not None :
    icon_path = os.path.join(icon_lib, "custom", name + ext)
    if os.path.isfile(icon_path):
      return icon_path
  return None

def fetch_custom_icon_bitmap(*args, **kwds):
  icon_path = find_custom_icon(*args, **kwds)
  if icon_path is None :
    return wx.NullBitmap
  icon_size = kwds.get("icon_size", None)
  if icon_size:
    scale = (icon_size, icon_size)
  else:
    scale = kwds.get("scale", None)
  return load_png_as_bitmap(icon_path, scale=scale)


 *******************************************************************************


 *******************************************************************************
wxtbx/browser.py

"""
Embedded browser windows with a minimal frame.  This will use the native web
browser library on Mac (WebKit) and Windows (IE); on Linux it will default to
the simpler wx.html.HtmlWindow.  This is used in the Phenix GUI to display
documentation.
"""

from __future__ import absolute_import, division, print_function
import wxtbx.bitmaps
import wx.html
import wx

class browser_frame(wx.Frame):
  def __init__(self, *args, **kwds):
    wx.Frame.__init__(self, *args, **kwds)
    szr = wx.BoxSizer(wx.VERTICAL)
    self.SetSizer(szr)
    self._was_shown = False
    self._is_default_viewer = False
    self.viewer = None
    _import_error = None
    if (wx.Platform == '__WXMAC__'):
      try :
        from wx import webkit
      except ImportError as e :
        _import_error = str(e)
      else :
        self.viewer = webkit.WebKitCtrl(self, -1)
        self.Bind(webkit.EVT_WEBKIT_STATE_CHANGED, self.OnChangeState,
          self.viewer)
        self.Bind(webkit.EVT_WEBKIT_BEFORE_LOAD, self.OnBeforeLoad, self.viewer)
    elif (wx.Platform == '__WXMSW__'):
      try :
        from wx.html2 import WebView
      except ImportError as e :
        _import_error = str(e)
      else :
        self.viewer = WebView.New(self)
    if (self.viewer is None) : # fallback (default on Linux)
      self.viewer = HtmlPanel(self)
      self._is_default_viewer = True
    szr.Add(self.viewer, 1, wx.EXPAND)
    self.SetupToolbar()
    self.statusbar = self.CreateStatusBar()
    if (wx.Platform != "__WXMSW__"):
      self.SetInitialSize((1024,640))
    #self.Bind(wx.EVT_WINDOW_CREATE, self.OnShow)

    # create keyboard shortcuts for zoom functions in toolbar
    if (wx.Platform == '__WXMAC__'):
      zoomInId = wx.NewId()
      zoomOutId = wx.NewId()
      zoomDefaultId = wx.NewId()
      self.Bind(wx.EVT_MENU, self.OnZoomIn, id=zoomInId)
      self.Bind(wx.EVT_MENU, self.OnZoomOut, id=zoomOutId)
      self.Bind(wx.EVT_MENU, self.OnZoomDefault, id=zoomDefaultId)
      self.accelerator_table = wx.AcceleratorTable(
        [ (wx.ACCEL_CTRL, ord('='), zoomInId),
          (wx.ACCEL_CTRL, wx.WXK_NUMPAD_ADD, zoomInId),
          (wx.ACCEL_CTRL, ord('-'), zoomOutId),
          (wx.ACCEL_CTRL, wx.WXK_NUMPAD_SUBTRACT, zoomOutId),
          (wx.ACCEL_CTRL, ord('0'), zoomDefaultId),
          (wx.ACCEL_CTRL, wx.WXK_NUMPAD0, zoomDefaultId) ])
      self.SetAcceleratorTable(self.accelerator_table)
      self.zoom_counter = 0

  def SetHomepage(self, url):
    self.home_url = url

  def SetupToolbar(self):
    if (wxtbx.bitmaps.icon_lib is None):
      return
    self.toolbar = self.CreateToolBar(style=wx.TB_TEXT)
    commands = [
      ("filesystems", "folder_home", "OnHome", "Home"),
      ("actions", "back", "OnBack", "Back"),
      ("actions", "forward", "OnForward", "Forward"),
      ("actions", "stop", "OnStop", "Stop"),
    ]
    if (not self._is_default_viewer):
      commands.append(("actions", "reload", "OnReload", "Reload"))
    for (icon_class, icon_name, fname, label) in commands :
      bmp = wxtbx.bitmaps.fetch_icon_bitmap(icon_class, icon_name, 32)
      tool_button = self.toolbar.AddLabelTool(-1, label, bmp,
        shortHelp=label, kind=wx.ITEM_NORMAL)
      self.Bind(wx.EVT_MENU, getattr(self, fname), tool_button)
    self.toolbar.AddSeparator()

    # buttons for increasing/decreasing text size
    if (wx.Platform == '__WXMAC__'):
      commands = [
        ('actions', 'zoom-in-2', 'Zoom In', 'Increase text size', 'OnZoomIn'),
        ('actions', 'zoom-out-2', 'Zoom Out', 'Decrease text size', 'OnZoomOut'),
        ('actions','zoom-fit-best','Default','Default text size','OnZoomDefault')
      ]
      for (icon_class, icon_name, label, shortHelp, fname) in commands:
        bmp = wxtbx.bitmaps.fetch_icon_bitmap(icon_class, icon_name, 128)
        tool_button = self.toolbar.AddLabelTool(
          -1, label, bmp, shortHelp=shortHelp, kind=wx.ITEM_NORMAL)
        self.Bind(wx.EVT_MENU, getattr(self, fname), tool_button)
      self.toolbar.AddSeparator()

    if (not self._is_default_viewer):
      phenix_bmp = wxtbx.bitmaps.fetch_custom_icon_bitmap("phenix.refine")
      phenix_btn = self.toolbar.AddLabelTool(-1, "PHENIX homepage", phenix_bmp,
        shortHelp="PHENIX homepage", kind=wx.ITEM_NORMAL)
      self.Bind(wx.EVT_MENU, self.OnPhenixWeb, phenix_btn)
    self.toolbar.Realize()

  def LoadURL(self, url):
    self.viewer.LoadURL(url)

  def OnShow(self, event):
    if (not self._was_shown):
      self.LoadURL(self.home_url)
      self._was_shown = True

  def OnHome(self, event):
    self.LoadURL(self.home_url)

  def OnBack(self, event):
    if self.viewer.CanGoBack():
      self.viewer.GoBack()

  def OnForward(self, event):
    if self.viewer.CanGoForward():
      self.viewer.GoForward()

  def OnReload(self, event):
    if (wx.Platform == '__WXMAC__'):
      self.viewer.Reload()
    elif (wx.Platform == '__WXMSW__'):
      self.viewer.RefreshPage()

  def OnStop(self, event):
    self.viewer.Stop()

  def OnZoomIn(self, event=None):
    if (self.viewer.CanIncreaseTextSize()):
      self.viewer.IncreaseTextSize()
      self.zoom_counter += 1

  def OnZoomOut(self, event=None):
    if (self.viewer.CanDecreaseTextSize()):
      self.viewer.DecreaseTextSize()
      self.zoom_counter -= 1

  def OnZoomDefault(self, event):
    while (self.zoom_counter != 0):
      if (self.zoom_counter > 0):
        self.OnZoomOut()
      else:
        self.OnZoomIn()

  def Open(self, url):
    self.LoadURL(url)

  def OnPhenixWeb(self, event):
    self.LoadURL("http://www.phenix-online.org")

  # XXX Mac only
  def OnChangeState(self, event):
    import wx.webkit
    state = event.GetState()
    url = event.GetURL()
    if (state == wx.webkit.WEBKIT_STATE_START):
      self.statusbar.SetStatusText("Opening %s" % url)
    elif (state == wx.webkit.WEBKIT_STATE_TRANSFERRING):
      self.statusbar.SetStatusText("Loading %s" % url)
    elif (state == wx.webkit.WEBKIT_STATE_STOP):
      self.statusbar.SetStatusText("Viewing %s" % url)
    elif (state == wx.webkit.WEBKIT_STATE_FAILED):
      self.statusbar.SetStatusText("Failed loading %s" % url)
    else :
      self.statusbar.SetStatusText("")

  def OnBeforeLoad(self, event):
    pass
    #print event.GetNavigationType()

class HtmlPanel(wx.html.HtmlWindow):
  """
  Adapter class to provide an API equivalent to WebKit/IE
  """
  def Stop(self):
    pass

  def CanGoForward(self):
    return self.HistoryCanForward()

  def GoForward(self):
    return self.HistoryForward()

  def CanGoBack(self):
    return self.HistoryCanBack()

  def GoBack(self):
    return self.HistoryBack()

  def LoadURL(self, url):
    fields = url.split("#")
    base_url = fields[0]
    self.LoadPage(base_url)
    if (len(fields) > 1):
      anchor = fields[1]
      if (self.HasAnchor(anchor)):
        # XXX calling self.ScrollToAnchor() directly doesn't work!
        wx.CallAfter(self.ScrollToAnchor, anchor)
      else :
        print("Missing anchor %s" % anchor)

if __name__ == "__main__" :
  app = wx.App(0)
  frame = browser_frame(None, -1, "wxtbx.browser example")
  #  size=(800,600))
  frame.SetHomepage("http://cci.lbl.gov")
  frame.Show()
  app.MainLoop()


 *******************************************************************************


 *******************************************************************************
wxtbx/checklistctrl.py
from __future__ import absolute_import, division, print_function

# Copyright 2010, University of California
# License: LGPL

from wx.lib.embeddedimage import PyEmbeddedImage
import wx
import sys
from six.moves import range

# from Crystal Icons (http://www.everaldo.com/crystal/)
button_ok = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACK0lEQVQ4jaWSXUhTYRjH/+/O"
    "3uPOOfs4W2oRRGI0jPYRStaIjMS6SyQoC+kD0rqJwAjqqo+bbpLoQorIhjaShIqRLUtzdaHD"
    "DywpmzZ0NIS0rDV1tg87e7uQRMps1R+em+fh91z8+RHGGP4nqr8FhFqi/ucHopNI8qip23RQ"
    "bplfMsbSGuEGpOVn5P72wVZ2wLmXqXbhIWMMJJ0OhGtEMoRk363DjbaGrjqMJcchJw1wP3jc"
    "PP8gq5FfBkZyJyoSvQthfT2RMob0PldVo83lv4nWTx5wMYpZLw0mZqIFKgDQ1JJM80d7YEPY"
    "0SHVk+0/4JX3Ja32ndHnOn7b1jTegF7aAS3VIeyJDUenI5Zoy2xEnX1RzC4WS/zVpdWmqBLF"
    "pCfiWXFXs1MStT10SNdZc+SyrfnzPQzS1xATOvibQiMklbImnrA4AHCKTK4XlTgKPwjviSwa"
    "UZCXT/u8A+UI0apzlWfNL+M9CHBvoEwR9DsDQS5LscbvzMEA5koUyjRP83av2movtPP5uo2g"
    "hIeBGjGovMII3mL6ywye1XQH+U1JS/ioElvYkRoAYu54CVemaoOMIrb5G2/m1yHMTWCCG4My"
    "BXRcfRHMqchcP1A8GsdPmbdKcad20D2qdllv2mLcZswQiIDUJPD8UlfQccJqebS28xd4UZEy"
    "9qnbyntLExfCp1nuqZzhk18rNUsJtuhSd0j0rjm/uq+OXRH+ZOhvD8fi+2k6iqel8lL5Dvo2"
    "ZEkd1D8WAAAAAElFTkSuQmCC")

empty_box = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAAlwSFlz"
    "AAALEwAACxMBAJqcGAAAAAd0SU1FB9sDCBYrMH47BnQAAAGQSURBVDjLpZO7L2xRFMZ/+5wx"
    "jhMTg0syhUgIQeN/EJFoEIUE8YpC5W8wFGqSKUWpm0QIExq3uAWSW1B4NETQSLzunWT2PM4s"
    "hcOc4xGvnaxi77XWt771rbWViPCTY3w1oSSmvg9gLyrC5xVUDIef3wLeAKXUNXAC3AF54Kk/"
    "5RYLp7ipG1rsqzS7FM6K+AHc5CXgEEi/8BUDzcDARfaC7o5OjA6jAFC1FAS4Bw6AHUC/ALBc"
    "RvcHuT2yv4uwTfNRAyumaLxqBXCADKBFREfito5MlevE+ap2ATOAc7OWIvn/jmQii1E9a9OW"
    "ayfaNY2nZ+rXf1F0FGJ+PMbqddzLRFQ+T3rjMdT49zdHTUOEreSmj6+5HWJmdIbd9B9OrWOf"
    "L50o7E5AxzOU9Fg09dY8qQ1AdHKKQ2efy9IzzNugb1jeSwAgtawxewwAEwgC1mD1GG+IGHRj"
    "Xu+Bs5xHKVUGtLhV3htjmY+O9y98ZpGAOhGpLEgq8spCIzb10VoWZO5Nv9fedUzo/g+TRcTf"
    "wnfOAyHF1dviqZJ4AAAAAElFTkSuQmCC")


blank = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAQAAAC1+jfqAAAAAXNSR0IArs4c6QAAAAJiS0dE"
    "AP+Hj8y/AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH2QsNFBwTBbkZpAAAABl0RVh0"
    "Q29tbWVudABDcmVhdGVkIHdpdGggR0lNUFeBDhcAAAAOSURBVCjPY2AYBaMAAQACEAABFMLA"
    "kgAAAABJRU5ErkJggg==")

class CheckListCtrl(wx.ListCtrl):
  use_blank = True
  def __init__(self, *args, **kwds):
    wx.ListCtrl.__init__(self, *args, **kwds)
    self.Bind(wx.EVT_LIST_ITEM_SELECTED, self.OnSelect)
    self.Bind(wx.EVT_LIST_ITEM_DESELECTED, self.OnDeSelect)
    self.Bind(wx.EVT_LEFT_DCLICK, self.OnDoubleClick)
    self.Bind(wx.EVT_CHAR, self.OnChar)
    self._checklist = []
    il = wx.ImageList(16, 16, True)
    if (self.use_blank):
      il.Add(blank.GetBitmap())
    else :
      il.Add(empty_box.GetBitmap())
    il.Add(button_ok.GetBitmap())
    self.AssignImageList(il, wx.IMAGE_LIST_SMALL)
    self._multiple_sele = not (self.GetWindowStyle() & wx.LC_SINGLE_SEL)
    tip = """\
You may check or uncheck items by double-clicking them.  You may also use \
the keyboard: arrow keys move up and down the list, Return checks items, \
backspace/delete unchecks them."""
    if self._multiple_sele :
      tip += """  You can change the status of multiple items at once by \
holding down the shift key in combination with mouse selection."""
    self.SetToolTip(wx.ToolTip(tip))

  def IsItemChecked(self, item):
    return self._checklist[item]

  def GetCheckedItems(self):
    i = 0
    items = []
    while (i < self.GetItemCount()):
      if self._checklist[i] :
        items.append(i)
      i += 1
    return items

  def GetCheckedItemsText(self):
    items = self.GetCheckedItems()
    strings = []
    for item in items :
      strings.append(str(self.GetItemText(item)))
    return strings

  def InsertStringItem(self, *args, **kwds):
    kwds['imageIndex'] = 0
    i = wx.ListCtrl.InsertStringItem(self, *args, **kwds)
    self._checklist.append(False)
    return i

  def InsertItem(self, *args, **kwds):
    kwds['imageIndex'] = 0
    i = wx.ListCtrl.InsertItem(self, *args, **kwds)
    self._checklist.append(False)
    return i

  def CheckItem(self, item, check=True):
    self._checklist[item] = check
    if check :
      self.SetItemImage(item, 1)
    else :
      self.SetItemImage(item, 0)

  def ToggleItems(self, items, check=None):
    if (len(items) == 0) : return
    assert (check in [True, False, None])
    item_status = []
    for item in items :
      item_status.append(self.IsItemChecked(item))
    if (item_status.count(True) > 0):
      for item in items :
        if (check is None):
          self.CheckItem(item, False)
        else :
          self.CheckItem(item, check)
    else :
      for item in items :
        if (check is None):
          self.CheckItem(item, True)
        else :
          self.CheckItem(item, check)

  def OnDoubleClick(self, event):
    i, flags = self.HitTest(event.GetPosition())
    if (flags & wx.LIST_HITTEST_ONITEM):
      if self._multiple_sele :
        item_list = self.GetSelectedItems()
        self.ToggleItems(item_list)
      else :
        is_checked = self.IsItemChecked(i)
        self.CheckItem(i, not is_checked)

  def GetSelectedItems(self):
    item_list = []
    item = self.GetFirstSelected()
    while (item >= 0):
      item_list.append(item)
      item = self.GetNextSelected(item)
    return item_list

  def OnChar(self, event):
    key = event.GetKeyCode()
    if (key == wx.WXK_RETURN):
      items = self.GetSelectedItems()
      self.ToggleItems(items, check=True)
    elif (key == wx.WXK_DELETE) or (key == wx.WXK_BACK):
      items = self.GetSelectedItems()
      self.ToggleItems(items, check=False)
    elif (key == wx.WXK_UP):
      item = self.GetFirstSelected()
      if (item > 0):
        self.Select(item - 1)
        self.EnsureVisible(item - 1)
    elif (key == wx.WXK_DOWN):
      items = self.GetSelectedItems()
      if (len(items) == 0) : return
      if (items[-1] < (self.GetItemCount() - 1)):
        self.Select(items[-1] + 1)
        self.EnsureVisible(items[-1] + 1)

  def UpdateParentControls(self):
    pass

  def OnSelect(self, event):
    pass

  def OnDeSelect(self, event):
    pass

def demo():
  import random
  app = wx.App(0)
  frame = wx.Frame(None, -1, "Test frame for CheckListCtrl")
  panel = wx.Panel(frame, -1)
  sizer = wx.BoxSizer(wx.VERTICAL)
  frame.SetSizer(sizer)
  sizer.Add(panel, 1, wx.EXPAND)
  sizer2 = wx.BoxSizer(wx.VERTICAL)
  panel.SetSizer(sizer2)
  txt = wx.StaticText(panel, -1, "Double-click an item to check/uncheck it.")
  sizer2.Add(txt, 0, wx.ALL, 5)
  ctrl1 = CheckListCtrl(panel, -1, size=(600,200), style=wx.LC_REPORT)
  ctrl1.InsertColumn(0, "Item name")
  ctrl1.SetColumnWidth(0, 580)
  sizer2.Add(ctrl1, 0, wx.ALL, 5)
  btn1 = wx.Button(panel, -1, "Print checked items")
  sizer2.Add(btn1, 0, wx.ALL, 5)
  def OnShow1(event):
    items = ctrl1.GetCheckedItemsText()
    print("Control 1 selection:")
    print("\n".join([ " " + item for item in items ]))
  frame.Bind(wx.EVT_BUTTON, OnShow1, btn1)
  txt2 = wx.StaticText(panel, -1, "This control will only allow you to "+
    "check/uncheck a single item at a time.")
  sizer2.Add(txt2, 0, wx.ALL, 5)
  ctrl2 = CheckListCtrl(panel, -1, size=(600,200),
    style=wx.LC_REPORT|wx.LC_SINGLE_SEL)
  ctrl2.InsertColumn(0, "Item name")
  ctrl2.InsertColumn(1, "Other data")
  ctrl2.SetColumnWidth(0, 380)
  ctrl2.SetColumnWidth(1, 200)
  sizer2.Add(ctrl2, 0, wx.ALL, 5)
  btn2 = wx.Button(panel, -1, "Print checked items")
  def OnShow2(event):
    items = ctrl2.GetCheckedItemsText()
    print("Control 2 selection:")
    print("\n".join([ " " + item for item in items ]))
  sizer2.Add(btn2, 0, wx.ALL, 5)
  frame.Bind(wx.EVT_BUTTON, OnShow2, btn2)
  for i in range(10):
    ctrl1.InsertStringItem(sys.maxunicode, "Item %d" % i)
    item = ctrl2.InsertStringItem(sys.maxunicode, "Item %d" % i)
    ctrl2.SetStringItem(item, 1, str(random.random() * 1000))
  sizer2.Layout()
  sizer.Layout()
  sizer.Fit(panel)
  frame.Fit()
  frame.Show()
  app.MainLoop()

if __name__ == "__main__" :
  demo()


 *******************************************************************************


 *******************************************************************************
wxtbx/command_line/__init__.py


 *******************************************************************************


 *******************************************************************************
wxtbx/command_line/anomalous_differences_histogram.py
# LIBTBX_PRE_DISPATCHER_INCLUDE_SH export PHENIX_GUI_ENVIRONMENT=1
# LIBTBX_PRE_DISPATCHER_INCLUDE_SH export BOOST_ADAPTBX_FPE_DEFAULT=1

from __future__ import absolute_import, division, print_function
import wxtbx.plots
from libtbx.utils import Sorry
import wx
import os
import sys

def display_file_info(file_name, obs_type="amplitudes", parent=None,
    n_bins=40, out=sys.stdout):
  from iotbx import file_reader
  hkl_in = file_reader.any_file(file_name, force_type="hkl")
  hkl_in.check_file_type("hkl")
  anom_data = []
  for array in hkl_in.file_server.miller_arrays :
    if (not array.anomalous_flag()) : continue
    if (array.is_xray_amplitude_array()) or (array.is_xray_intensity_array()):
      anom_data.append(array)
  if (len(anom_data) == 0):
    raise Sorry("No anomalous data arrays found.")
  x_label = "D_anom(F) / <F>"
  if (obs_type == "intensities"):
    x_label = "D_anom(I) / <I>"
  for array in anom_data :
    array_name = os.path.basename(file_name)+":"+array.info().label_string()
    frame = AnomHistPlotFrame(
      parent=parent,
      title="Bijvoet ratios for %s" % array_name,
      array=array,
      array_name=array_name)
    frame.Show()

class AnomHistPlotFrame(wxtbx.plots.plot_frame):
  def __init__(self, *args, **kwds):
    self._array = kwds.pop("array")
    self._array_name = kwds.pop("array_name")
    wxtbx.plots.plot_frame.__init__(self, *args, **kwds)
    self.recalculate()

  def create_plot_panel(self):
    return wxtbx.plots.histogram(parent=self, figure_size=(12,6))

  def draw_top_panel(self):
    self.top_panel = wx.Panel(parent=self, style=wx.RAISED_BORDER)
    szr = wx.BoxSizer(wx.VERTICAL)
    self.top_panel.SetSizer(szr)
    szr2 = wx.BoxSizer(wx.HORIZONTAL)
    szr.Add(szr2, 1)
    self.meas_box = wx.CheckBox(self.top_panel, label="Measurable differences only")
    szr2.Add(self.meas_box, 0, wx.ALL|wx.ALIGN_CENTER_VERTICAL, 5)
    self.log_box = wx.CheckBox(self.top_panel, label="Log scale")
    szr2.Add(self.log_box, 0, wx.ALL|wx.ALIGN_CENTER_VERTICAL, 5)
    szr2.Add(wx.StaticText(self.top_panel, label="Data type:"), 0,
      wx.ALL|wx.ALIGN_CENTER_VERTICAL, 5)
    self.obs_type = wx.Choice(self.top_panel,
      choices=["amplitudes","intensities"])
    szr2.Add(self.obs_type, 0, wx.ALL|wx.ALIGN_CENTER_VERTICAL, 5)
    szr2.Add(wx.StaticText(self.top_panel, label="# of bins:"), 0,
      wx.ALL|wx.ALIGN_CENTER_VERTICAL, 5)
    self.n_bins = wx.SpinCtrl(self.top_panel, -1)
    self.n_bins.SetValue(40)
    szr2.Add(self.n_bins, 0, wx.ALL|wx.ALIGN_CENTER_VERTICAL, 5)
    self.Bind(wx.EVT_CHECKBOX, lambda evt: self.recalculate(), self.meas_box)
    self.Bind(wx.EVT_CHECKBOX, lambda evt: self.recalculate(), self.log_box)
    self.Bind(wx.EVT_CHOICE, lambda evt: self.recalculate(), self.obs_type)
    self.Bind(wx.EVT_SPINCTRL, lambda evt: self.recalculate(), self.n_bins)

  def recalculate(self):
    from scitbx.array_family import flex
    measurable_only = self.meas_box.GetValue()
    obs_type = self.obs_type.GetStringSelection()
    n_bins = self.n_bins.GetValue()
    d_ano_rel = self._array.bijvoet_ratios(
      obs_type=obs_type,
      measurable_only=measurable_only)
    hist = flex.histogram(d_ano_rel, n_slots=n_bins)
    hist.show(f=sys.stdout)
    if (obs_type == "intensities"):
      x_label = "D_anom(I[hkl]) / I_mean[hkl]"
    else :
      x_label = "D_anom(F[hkl]) / F_mean[hkl]"
    self.show_histogram(
      data=list(d_ano_rel),
      n_bins=n_bins,
      x_label=x_label,
      y_label="# hkl",
      title="Bijvoet ratios for %s" % self._array_name,
      log_scale=self.log_box.GetValue())

  def show_histogram(self, *args, **kwds):
    self.plot_panel.show_histogram(*args, **kwds)
    self.Refresh()

def run(args=(), params=None, out=sys.stdout):
  import wxtbx.app
  app = wxtbx.app.CCTBXApp(0)
  if (len(args) == 0):
    from wxtbx.command_line.inspect_r_free_flags import ask_for_file
    file_name = ask_for_file(parent=None)
  else :
    file_name = args[0]
  display_file_info(file_name)
  app.MainLoop()

if (__name__ == "__main__"):
  run(sys.argv[1:])


 *******************************************************************************


 *******************************************************************************
wxtbx/command_line/b_plot.py
from __future__ import absolute_import, division, print_function
# LIBTBX_SET_DISPATCHER_NAME mmtbx.bfactor_plot
# LIBTBX_PRE_DISPATCHER_INCLUDE_SH export PHENIX_GUI_ENVIRONMENT=1
# LIBTBX_PRE_DISPATCHER_INCLUDE_SH export BOOST_ADAPTBX_FPE_DEFAULT=1

from wxtbx import b_plot
import wx
from libtbx.utils import Usage
import sys

def run(args):
  if (len(args) == 0):
    raise Usage("mmtbx.bfactor_plot model.pdb")
  pdb_file = args[0]
  params = b_plot.master_phil.fetch().extract()
  params.b_plot.pdb_file = pdb_file
  result = b_plot.run(params=params)
  app = wx.App(0)
  b_plot.show_plot_frame(result)
  app.MainLoop()

if (__name__ == "__main__"):
  run(sys.argv[1:])


 *******************************************************************************


 *******************************************************************************
wxtbx/command_line/inspect_r_free_flags.py
from __future__ import absolute_import, division, print_function
# LIBTBX_PRE_DISPATCHER_INCLUDE_SH export PHENIX_GUI_ENVIRONMENT=1
# LIBTBX_PRE_DISPATCHER_INCLUDE_SH export BOOST_ADAPTBX_FPE_DEFAULT=1

import wxtbx.plots
from libtbx.utils import Sorry, Abort, Usage
from libtbx import group_args
import wx
import os
import sys

def run(args):
  app = wx.App(0)
  file_name = None
  if (len(args) == 0):
    ask_for_file_name()
  else :
    file_name = args[0]
  if (file_name is None) or (not os.path.isfile(file_name)):
    raise Usage("wxtbx.inspect_r_free_flags data.mtz")
  display_file_info(file_name)
  app.MainLoop()

def ask_for_file_name(parent=None):
  import iotbx.file_reader
  file_name = wx.FileSelector(
    message="Select a reflections file",
    flags=wx.FD_OPEN,
    wildcard=iotbx.file_reader.get_wildcard_strings(["hkl"]))
  if (file_name == "") or (file_name is None):
    raise Abort()
  return file_name

def display_file_info(file_name, parent=None):
  from iotbx import reflection_file_editor
  from iotbx import file_reader
  from iotbx import data_plots
  hkl_in = file_reader.any_file(file_name, force_type="hkl")
  hkl_in.check_file_type("hkl")
  labels = []
  tables = []
  stats = []
  arrays_and_flags = hkl_in.file_server.get_r_free_flags(
    file_name=hkl_in.file_name,
    label=None,
    test_flag_value=None,
    disable_suitability_test=False,
    parameter_scope=None,
    return_all_valid_arrays=True)
  for array, test_flag_value in arrays_and_flags :
    labels.append(array.info().label_string())
    (n_bins, n_free, sse, accu) = reflection_file_editor.get_r_free_stats(
      miller_array=array,
      test_flag_value=test_flag_value)
    table = data_plots.table_data(
      title="Distribution of R-free test set",
      column_labels=["Reflection #", "Fraction counted"],
      graph_names=["Fraction free vs. resolution"],
      graph_labels=[["Reflection #", "ntest/total"]],
      graph_columns=[[0,1]],
      data=[accu.reflection_counts, accu.free_fractions])
    tables.append(table)
    stats.append(group_args(
      n_free=n_free,
      n_all=array.indices().size(),
      percent_free=n_free/array.indices().size(),
      completeness=array.completeness()))
  if (len(labels) == 0):
    raise Sorry("No recognizable R-free flags found in this file.")
  frame = wx.Frame(parent, -1, "R-free flags info",
    style=wx.DEFAULT_FRAME_STYLE)
  szr = wx.BoxSizer(wx.VERTICAL)
  frame.SetSizer(szr)
  panel = RfreeInspector(frame, -1)
  panel.set_data(
    file_name=file_name,
    labels=labels,
    tables=tables,
    stats=stats,
    flags_and_values=[ (a.data(), f) for (a, f) in arrays_and_flags ])
  szr.Add(panel, 1, wx.ALL|wx.EXPAND)
  szr.Fit(panel)
  frame.Fit()
  frame.Show()

class RfreeInspector(wx.Panel):
  def __init__(self, *args, **kwds):
    wx.Panel.__init__(self, *args, **kwds)
    self.sizer = wx.BoxSizer(wx.VERTICAL)
    grid = wx.FlexGridSizer(2, 4, 0, 0)
    self.sizer.Add(grid, 0, wx.ALL, 5)
    grid.Add(wx.StaticText(self, -1, "File name:"), 0,
      wx.ALL|wx.ALIGN_CENTER_VERTICAL, 5)
    self.file_txt = wx.TextCtrl(self, -1, size=(400,-1),
      style=wx.TE_READONLY)
    grid.Add(self.file_txt, 0, wx.ALL|wx.ALIGN_CENTER_VERTICAL, 5)
    grid.Add(wx.StaticText(self, -1, "Column(s):"), 0,
      wx.ALL|wx.ALIGN_CENTER_VERTICAL, 5)
    self.labels_choice = wx.Choice(self, -1, size=(200,-1))
    grid.Add(self.labels_choice, 0, wx.ALL|wx.ALIGN_CENTER_VERTICAL, 5)
    grid.Add(wx.StaticText(self, -1, "Completeness:"), 0,
      wx.ALL|wx.ALIGN_CENTER_VERTICAL, 5)
    self.comp_txt = wx.StaticText(self, -1, "", size=(100,-1))
    grid.Add(self.comp_txt, 0, wx.ALL|wx.ALIGN_CENTER_VERTICAL, 5)
    grid.Add(wx.StaticText(self, -1, "Test set size:"), 0,
      wx.ALL|wx.ALIGN_CENTER_VERTICAL, 5)
    self.percent_txt = wx.StaticText(self, -1, "", size=(300,-1))
    grid.Add(self.percent_txt, 0, wx.ALL|wx.ALIGN_CENTER_VERTICAL, 5)
    txt = wx.StaticText(self, -1,
"""The graph on the right shows the total number of test set \
reflections as a function of resolution.  A set picked at random will have an \
approximately straight line; if the test set was picked in thin resolution \
shells to avoid bias caused by non-crystallographic symmetry, it will \
increase in sharp steps.  CCTBX/PHENIX can not currently extend a set picked \
in shells; we suggest creating a new set in such cases.""")
    txt.Wrap(790)
    self.sizer.Add(txt, 0, wx.ALL, 5)
    plot_sizer = wx.BoxSizer(wx.HORIZONTAL)
    self.sizer.Add(plot_sizer, 1, wx.ALL|wx.EXPAND)
    self.plot1 = RfreeFlagsPlot(self,
      figure_size=(5,5))
    plot_sizer.Add(self.plot1, 1, wx.ALL|wx.EXPAND)
    self.plot2 = wxtbx.plots.iotbx_data_plot_base(
      parent=self,
      tables=[],
      size=(400,400),
      show_data_points=False)
    plot_sizer.Add(self.plot2, 1, wx.ALL|wx.EXPAND)
    self.SetSizer(self.sizer)
    self.Bind(wx.EVT_CHOICE, self.OnChooseArray, self.labels_choice)
    self.stats = []

  def set_data(self, file_name, labels, tables, stats, flags_and_values):
    self.stats = stats
    self.flags_and_values = flags_and_values
    self.file_txt.SetValue(file_name)
    self.labels_choice.SetItems(labels)
    self.labels_choice.SetSelection(0)
    self.plot2.set_tables(tables)
    self.OnChooseArray(None)

  def OnChooseArray(self, evt):
    array_selection = self.labels_choice.GetSelection()
    flags, value = self.flags_and_values[array_selection]
    self.plot1.show_pie(flags, value)
    self.plot2.set_plot(graph_name="Fraction free vs. resolution",
      table_index=array_selection)
    self.comp_txt.SetLabel("%.2f%%" %
      (100 * self.stats[array_selection].completeness))
    self.percent_txt.SetLabel("%d / %d (%.2f%%)" %
      (self.stats[array_selection].n_free, self.stats[array_selection].n_all,
       100 * self.stats[array_selection].percent_free))
    self.Refresh()

class RfreeFlagsPlot(wxtbx.plots.plot_container):
  def show_pie(self, flags, test_flag_value):
    values = sorted(list(set(flags)))
    n_values = len(values)
    labels = []
    colors = []
    counts = []
    for i, value in enumerate(values):
      if (value == test_flag_value):
        colors.append((1.,0.,0.))
      else :
        colors.append((0.5*(n_values-i)/n_values, 0.5*(n_values-i)/n_values,
          1.))
      labels.append(str(value))
      counts.append(flags.count(value))
    self.figure.clear()
    p = self.figure.add_subplot(111)
    p.set_position([0.1,0.1,0.8, 0.8])
    p.pie(counts, labels=labels, colors=colors)
    p.set_title("Flag values")
    self.canvas.draw()

if (__name__ == "__main__"):
 run(sys.argv[1:])


 *******************************************************************************


 *******************************************************************************
wxtbx/command_line/loggraph.py
# LIBTBX_SET_DISPATCHER_NAME cctbx.loggraph
# LIBTBX_PRE_DISPATCHER_INCLUDE_SH export PHENIX_GUI_ENVIRONMENT=1
# LIBTBX_PRE_DISPATCHER_INCLUDE_SH export BOOST_ADAPTBX_FPE_DEFAULT=1

from __future__ import absolute_import, division, print_function
from wxtbx import plots
import wx
import sys

def run(args):
  logfile = args[0]
  app = wx.App(0)
  frame = plots.loggraph(parent=None,
    title="Loggraph test",
    tables=None,
    processed_lines=open(logfile).readlines())
  frame.Show()
  app.MainLoop()

if __name__ == "__main__" :
  run(sys.argv[1:])


 *******************************************************************************


 *******************************************************************************
wxtbx/command_line/pdb_editor.py
from __future__ import absolute_import, division, print_function
# LIBTBX_SET_DISPATCHER_NAME phenix.pdb_editor
# LIBTBX_PRE_DISPATCHER_INCLUDE_SH export PHENIX_GUI_ENVIRONMENT=1
# LIBTBX_PRE_DISPATCHER_INCLUDE_SH export BOOST_ADAPTBX_FPE_DEFAULT=1

import wxtbx.app
from wxtbx import pdb_editor
import libtbx.load_env
import os
import sys

if (__name__ == "__main__"):
  app = wxtbx.app.CCTBXApp(0)
  bmp_path = libtbx.env.find_in_repositories(
    relative_path="gui_resources/icons/custom/tools.png",
    test=os.path.isfile)
  app.SetTaskbarIcon(bmp_path, "PDB Editor")
  frame = pdb_editor.PDBTreeFrame(None, -1, "PDB Editor")
  frame.Show()
  if (len(sys.argv) > 1):
    frame.LoadPDB(sys.argv[1])
  app.MainLoop()


 *******************************************************************************


 *******************************************************************************
wxtbx/command_line/pdb_statistics.py
from __future__ import absolute_import, division, print_function
# LIBTBX_SET_DISPATCHER_NAME mmtbx.pdb_statistics
# LIBTBX_PRE_DISPATCHER_INCLUDE_SH export PHENIX_GUI_ENVIRONMENT=1
# LIBTBX_PRE_DISPATCHER_INCLUDE_SH export BOOST_ADAPTBX_FPE_DEFAULT=1

from wxtbx.polygon_db_viewer import ConfigFrame
import wx

if (__name__ == "__main__"):
  app = wx.App(0)
  frame = ConfigFrame(None, -1, "PDB statistics from POLYGON database")
  frame.Show()
  app.MainLoop()


 *******************************************************************************


 *******************************************************************************
wxtbx/command_line/plan_sad_experiment.py
# LIBTBX_PRE_DISPATCHER_INCLUDE_SH export PHENIX_GUI_ENVIRONMENT=1

from __future__ import absolute_import, division, print_function
import wxtbx.xtriage
import wxtbx.app
import sys

if (__name__ == "__main__"):
  from mmtbx.command_line import plan_sad_experiment
  result = plan_sad_experiment.run(args=sys.argv[1:])
  app = wxtbx.app.CCTBXApp(0)
  frame = wxtbx.xtriage.XtriageFrameSingleResult(
    parent=None,
    title="Plan SAD experiment",
    size=(900,600))
  frame.SetResult(result)
  frame.Show()
  app.MainLoop()


 *******************************************************************************


 *******************************************************************************
wxtbx/command_line/plot_anomalous_scattering.py
from __future__ import absolute_import, division, print_function
# LIBTBX_SET_DISPATCHER_NAME cctbx.plot_anomalous_scattering
# LIBTBX_PRE_DISPATCHER_INCLUDE_SH export PHENIX_GUI_ENVIRONMENT=1
# LIBTBX_PRE_DISPATCHER_INCLUDE_SH export BOOST_ADAPTBX_FPE_DEFAULT=1

from wxtbx import anomalous_scattering
import wxtbx.app
import sys

def run(args):
  app = wxtbx.app.CCTBXApp(0)
  frame = anomalous_scattering.AnomPlotFrame(parent=None,
    title="Anomalous scattering plot")
  frame.Show()
  app.MainLoop()

if (__name__ == "__main__"):
  run(sys.argv[1:])


 *******************************************************************************


 *******************************************************************************
wxtbx/command_line/show_file_info.py
from __future__ import absolute_import, division, print_function
# LIBTBX_PRE_DISPATCHER_INCLUDE_SH export PHENIX_GUI_ENVIRONMENT=1
# LIBTBX_PRE_DISPATCHER_INCLUDE_SH export BOOST_ADAPTBX_FPE_DEFAULT=1

from wxtbx import info_panels
from libtbx.utils import Usage, Sorry
import wx
import os
import sys

def run(args):
  if (len(args) == 0) or (not os.path.isfile(args[-1])):
    raise Usage("wxtbx.show_file_info [options] file_name")
  app = wx.App(0)
  from iotbx import file_reader
  f = file_reader.any_file(args[-1],
    raise_sorry_if_errors=True)
  f.show_summary()
  frame = None
  if (f.file_type == "pdb"):
    frame = info_panels.PDBFileInfo(None)
  elif (f.file_type == "hkl"):
    frame = info_panels.ReflectionFileInfo(None)
  elif (f.file_type == "img"):
    frame = info_panels.ImageFileInfo(None)
  if (frame is None):
    raise Sorry("File type %s not supported for display." % f.file_type)
  frame.set_file(f.file_name)
  frame.Show()
  app.MainLoop()

if (__name__ == "__main__"):
  run(sys.argv[1:])


 *******************************************************************************


 *******************************************************************************
wxtbx/command_line/wxpython.py
# LIBTBX_SET_DISPATCHER_NAME cctbx.wxpython
# LIBTBX_PRE_DISPATCHER_INCLUDE_SH PHENIX_GUI_ENVIRONMENT=1
# LIBTBX_PRE_DISPATCHER_INCLUDE_SH export PHENIX_GUI_ENVIRONMENT
# LIBTBX_START_PYTHON
from __future__ import absolute_import, division, print_function


 *******************************************************************************


 *******************************************************************************
wxtbx/command_line/xtriage.py
# LIBTBX_PRE_DISPATCHER_INCLUDE_SH export PHENIX_GUI_ENVIRONMENT=1
# LIBTBX_SET_DISPATCHER_NAME wxtbx.xtriage
# LIBTBX_SET_DISPATCHER_NAME mmtbx.xtriage_gui

from __future__ import absolute_import, division, print_function
import wxtbx.xtriage
import wxtbx.app
import sys

if (__name__ == "__main__"):
  from mmtbx.scaling import xtriage
  result = xtriage.run(args=sys.argv[1:],
    data_file_name="xtriage_data.pkl")
  app = wxtbx.app.CCTBXApp(0)
  frame = wxtbx.xtriage.XtriageFrame(parent=None,
    title="Xtriage",
    size=(900,600))
  frame.SetResult(result)
  frame.Show()
  app.MainLoop()


 *******************************************************************************


 *******************************************************************************
wxtbx/custom_restraints.py

"""
Interface for editing custom geometry restraints (as defined in
mmtbx.monomer_library.pdb_interpretation).  Currently only bonds and angles
are supported.  The parameters are specific to phenix.refine right now but
they could theoretically be used in other programs.
"""
from __future__ import absolute_import, division, print_function

import wxtbx.bitmaps
from wxtbx import metallicbutton
from wxtbx.phil_controls import simple_dialogs
from wx.lib.agw import flatnotebook
import wx
from libtbx import str_utils
import sys
from six.moves import range

ATOM_SELECTION_BUTTONS = 1

#-----------------------------------------------------------------------
# Basic panel

class CustomRestraintsPanel(wx.Panel):
  n_atom_selections = -1
  list_label = None
  def __init__(self, *args, **kwds):
    style = kwds.get('style', 0)
    self.flag_atom_selection_buttons = (style & ATOM_SELECTION_BUTTONS)
    wx.Panel.__init__(self, *args, **kwds)
    self._default_label = "---"
    szr = wx.BoxSizer(wx.VERTICAL)
    self.SetSizer(szr)
    self.sizer = szr
    label = wx.StaticText(self, -1, self.list_label)
    font = label.GetFont()
    font.SetWeight(wx.FONTWEIGHT_BOLD)
    label.SetFont(font)
    szr.Add(label, 0, wx.ALL, 5)
    self.CreateList()
    self.Bind(wx.EVT_LIST_ITEM_SELECTED, self.OnSelect, self.lc)
    self.Bind(wx.EVT_LIST_ITEM_DESELECTED, self.OnDeSelect, self.lc)
    self.sizer.Add(self.lc, 1, wx.EXPAND|wx.ALL, 5)
    self.buttons = wx.BoxSizer(wx.HORIZONTAL)
    add_btn = self.AddControlButton(
      label="Add",
      bitmap=wxtbx.bitmaps.fetch_icon_bitmap("actions", "edit_add", 16))
    del_btn = self.AddControlButton(
      label="Delete",
      bitmap=wxtbx.bitmaps.fetch_icon_bitmap("actions", "cancel", 16))
    clear_btn = self.AddControlButton(
      label="Clear all",
      bitmap=wxtbx.bitmaps.fetch_icon_bitmap("actions", "editdelete", 16))
    update_btn = self.AddControlButton(
      label="Update selections",
      bitmap=wxtbx.bitmaps.fetch_icon_bitmap("actions", "recur", 16))
    options_btn = self.AddControlButton(
      label="Other options",
      bitmap=wxtbx.bitmaps.fetch_icon_bitmap("actions", "run", 16))
    self.Bind(wx.EVT_BUTTON, self.OnAdd, add_btn)
    self.Bind(wx.EVT_BUTTON, self.OnDelete, del_btn)
    self.Bind(wx.EVT_BUTTON, self.OnDeleteAll, clear_btn)
    self.Bind(wx.EVT_BUTTON, self.OnUpdate, update_btn)
    self.Bind(wx.EVT_BUTTON, self.OnOptionsMenu, options_btn)
    szr.Add(self.buttons, 0, wx.LEFT|wx.BOTTOM|wx.RIGHT, 5)
    self.sizer = szr
    self.CreateSelectionFields()
    szr.Layout()

  def AddControlButton(self, label, bitmap):
    btn = metallicbutton.MetallicButton(
      parent=self,
      label=label,
      bmp=bitmap,
      highlight_color=(200,220,240))
    self.buttons.Add(btn, 0, wx.RIGHT, 5)
    return btn

  def CreateList(self):
    raise NotImplementedError()

  def CreateSelectionFields(self):
    raise NotImplementedError()

  def FillSelections(self):
    selections = self.lc.GetSelections()
    assert (len(selections) == self.n_atom_selections)
    for i, sele in enumerate(selections):
      field = self.GetSelectionControl(i)
      if (sele is not None):
        field.SetValue(sele)
      else :
        field.SetValue("")

  def GetSelectionEdits(self):
    selections = []
    for i in range(self.n_atom_selections):
      field = self.GetSelectionControl(i)
      value = field.GetValue()
      if (value.isspace()) or (value == ""):
        value = None
      selections.append(value)
    return selections

  def GetSelectionControl(self, i):
    return getattr(self, "selection_%d" % (i+1))

  def ClearSelections(self):
    for i in range(self.n_atom_selections):
      field = self.GetSelectionControl(i)
      field.SetValue("")

  def OnSelect(self, event):
    self.FillSelections()

  def OnDeSelect(self, event):
    self.ClearSelections()

  def OnDeleteAll(self, evt):
    if (self.lc.GetItemCount() == 0):
      return False
    confirm = wx.MessageBox(caption="Confirm delete",
      message="Are you sure you want to delete all items in the list?")
    if (confirm == wx.OK):
      self.lc.DeleteAllItems()
      self.lc.ClearRestraints()
      self.ClearSelections()

  def __getattr__(self, name):
    return getattr(self.lc, name)

  def OnOptionsMenu(self, event):
    raise NotImplementedError()

  def OnAdd(self, event):
    selections = self.GetSelectionEdits()
    # XXX if no list item is selected but the selection fields have been
    # edited, apply those to the new selection
    item_selected = (self.lc.GetFirstSelected() >= 0)
    self.lc.AddRestraint()
    if (not item_selected) and (selections != ([None]*len(selections))):
      self.lc.SetSelections(selections)
    self.FillSelections()

  def OnDelete(self, event):
    self.lc.DeleteRestraint()

  def OnUpdate(self, event):
    selections = self.GetSelectionEdits()
    self.lc.SetSelections(selections)

  def CreateAtomSelectionButton(self, selection_ctrl):
    btn = AtomSelectionButton(
      parent=self,
      selection_ctrl=selection_ctrl)
    self.Bind(wx.EVT_BUTTON, self.GetTopLevelParent().OnView, btn)
    return btn

class AtomSelectionButton(metallicbutton.MetallicButton):
  def __init__(self, parent, selection_ctrl):
    metallicbutton.MetallicButton.__init__(self,
      parent=parent,
      label="Select...",
      bmp=wxtbx.bitmaps.fetch_icon_bitmap("actions", "select", 16),
      highlight_color=(200,220,240))
    self.selection_ctrl = selection_ctrl

class CustomBondPanel(CustomRestraintsPanel):
  n_atom_selections = 2
  list_label = "Custom bond restraints:"
  def CreateList(self):
    self.lc = BondRestraintsList(self)

  def CreateSelectionFields(self):
    edit_szr = wx.FlexGridSizer(cols=3)
    self.sizer.Add(edit_szr, 0, wx.ALL, 5)
    edit_szr.Add(wx.StaticText(self, -1, "Atom selections:"))
    for i in range(2):
      edit_field = wx.TextCtrl(self, -1, size=(540,-1),
        style=wx.TE_PROCESS_ENTER, name="bond")
      setattr(self, "selection_%d" % (i+1), edit_field)
      edit_szr.Add(edit_field, 0, wx.ALL, 5)
      select_btn = (1,1)
      if (self.flag_atom_selection_buttons):
        select_btn = self.CreateAtomSelectionButton(edit_field)
      edit_szr.Add(select_btn, 0, wx.TOP|wx.BOTTOM|wx.ALIGN_CENTER_VERTICAL, 5)
      if (i == 0) : edit_szr.Add((1,1))
      self.Bind(wx.EVT_TEXT_ENTER, self.OnUpdate, edit_field)

  def OnOptionsMenu(self, event):
    menu = wx.Menu()
    item1 = menu.Append(-1, "Set ideal distance")
    item2 = menu.Append(-1, "Set distance sigma")
    item3 = menu.Append(-1, "Set bond slack")
    item4 = menu.Append(-1, "Set symmetry operator")
    self.Bind(wx.EVT_MENU, self.lc.OnSetDistance, item1)
    self.Bind(wx.EVT_MENU, self.lc.OnSetSigma, item2)
    self.Bind(wx.EVT_MENU, self.lc.OnSetSlack, item3)
    self.Bind(wx.EVT_MENU, self.lc.OnSetSymop, item4)
    event.GetEventObject().PopupMenu(menu)
    menu.Destroy()

class CustomAnglePanel(CustomRestraintsPanel):
  n_atom_selections = 3
  list_label = "Custom angle restraints:"
  def CreateList(self):
    self.lc = AngleRestraintsList(self, size=(800,200))

  def CreateSelectionFields(self):
    edit_szr = wx.FlexGridSizer(cols=3)
    self.sizer.Add(edit_szr, 0, wx.ALL, 5)
    edit_szr.Add(wx.StaticText(self, -1, "Atom selections:"))
    for i in range(3):
      edit_field = wx.TextCtrl(self, -1, size=(540,-1),
        style=wx.TE_PROCESS_ENTER, name="angle")
      setattr(self, "selection_%d" % (i+1), edit_field)
      edit_szr.Add(edit_field, 0, wx.ALL, 5)
      select_btn = (1,1)
      if (self.flag_atom_selection_buttons):
        select_btn = self.CreateAtomSelectionButton(edit_field)
      edit_szr.Add(select_btn, 0, wx.TOP|wx.BOTTOM|wx.ALIGN_CENTER_VERTICAL, 5)
      if (i < 2) : edit_szr.Add((1,1))
      self.Bind(wx.EVT_TEXT_ENTER, self.OnUpdate, edit_field)

  def OnOptionsMenu(self, event):
    menu = wx.Menu()
    item1 = menu.Append(-1, "Set ideal angle")
    item2 = menu.Append(-1, "Set angle sigma")
    self.Bind(wx.EVT_MENU, self.lc.OnSetAngle, item1)
    self.Bind(wx.EVT_MENU, self.lc.OnSetSigma, item2)
    event.GetEventObject().PopupMenu(menu)
    menu.Destroy()

class CustomPlanarityPanel(CustomRestraintsPanel):
  n_atom_selections = 1
  list_label = "Custom planarity restraints:"
  def CreateList(self):
    self.lc = PlanarityRestraintsList(self, size=(800,200))

  def CreateSelectionFields(self):
    edit_szr = wx.FlexGridSizer(cols=3)
    self.sizer.Add(edit_szr, 0, wx.ALL, 5)
    edit_szr.Add(wx.StaticText(self, -1, "Atom selection:"))
    self.selection_1 = wx.TextCtrl(self, -1, size=(540,64),
      style=wx.TE_PROCESS_ENTER, name="plane")
    edit_szr.Add(self.selection_1, 0, wx.ALL, 5)
    select_btn = (1,1)
    if (self.flag_atom_selection_buttons):
      select_btn = self.CreateAtomSelectionButton(self.selection_1)
    edit_szr.Add(select_btn, 0, wx.TOP|wx.BOTTOM|wx.ALIGN_CENTER_VERTICAL, 5)
    self.Bind(wx.EVT_TEXT_ENTER, self.OnUpdate, self.selection_1)

  def OnOptionsMenu(self, event):
    menu = wx.Menu()
    item1 = menu.Append(-1, "Set planarity sigma")
    self.Bind(wx.EVT_MENU, self.lc.OnSetSigma, item1)
    event.GetEventObject().PopupMenu(menu)
    menu.Destroy()

#-----------------------------------------------------------------------
# ListCtrl-derived classes

class RestraintsListBase(wx.ListCtrl):
  restraint_name = None
  n_columns = -1
  def __init__(self, *args, **kwds):
    kwds['style'] = wx.LC_REPORT|wx.LC_SINGLE_SEL
    wx.ListCtrl.__init__(self, *args, **kwds)
    self.CreateColumns()
    self._params = []
    self._prefix = None

  def GetPhilPath(self):
    if (self._prefix is not None):
      return self._prefix + ".geometry_restraints.edits." + self.restraint_name
    else :
      return "geometry_restraints.edits." + self.restraint_name

  def SetPhilPrefix(self, prefix):
    self._prefix = prefix

  def ClearRestraints(self):
    self._params = []

  def AddRestraint(self):
    item = self.InsertStringItem(sys.maxunicode, "---")
    for i in range(self.n_columns - 1):
      self.SetStringItem(item, i+1, "---")
    new_params = self._index.get_template_copy(self.GetPhilPath()).extract()
    self._params.append(new_params)
    self.Select(item)

  def DeleteRestraint(self):
    item = self.GetFirstSelected()
    if (item >= 0):
      assert (item < len(self._params))
      self.DeleteItem(item)
      del self._params[item]

  def CreateColumns(self):
    raise NotImplementedError()

  def SetPhilIndex(self, index):
    self._index = index

  def SetParams(self, params):
    self._params = params
    if (self.GetItemCount() > 0):
      self.DeleteAllItems()
    self.PopulateList()

  def UpdateSelections(self, selections):
    item = self.GetFirstSelected()
    if (item >= 0):
      for i in range(len(selections)):
        sel_attr = "atom_selection_%d" % (i+1)
        assert hasattr(self._params[item], sel_attr)
        setattr(self._params[item], sel_attr, selections[i])

  def GetParams(self):
    return self._params

def fv(fs, val):
  return str_utils.format_value(fs, val, replace_none_with="---")

class BondRestraintsList(RestraintsListBase):
  restraint_name = "bond"
  def CreateColumns(self):
    self.InsertColumn(0, "Selections", width=400)
    self.InsertColumn(1, "Distance", width=100)
    self.InsertColumn(2, "Sigma", width=80)
    self.InsertColumn(3, "Slack", width=80)
    self.InsertColumn(4, "Sym. exp.", width=120)

  def PopulateList(self):
    for bond in self._params :
      selections = [bond.atom_selection_1, bond.atom_selection_2]
      sele_str = "; ".join([ fv("%s", s) for s in selections ])
      item = self.InsertStringItem(sys.maxunicode, sele_str)
      self.SetStringItem(item, 1, fv("%g", bond.distance_ideal))
      self.SetStringItem(item, 2, fv("%g", bond.sigma))
      self.SetStringItem(item, 3, fv("%g", bond.slack))
      self.SetStringItem(item, 4, fv("%s", bond.symmetry_operation))

  def GetSelections(self):
    item = self.GetFirstSelected()
    if (item >= 0):
      bond = self._params[item]
      return [bond.atom_selection_1, bond.atom_selection_2]
    return [""] * 2

  def SetSelections(self, selections):
    assert (len(selections) == 2)
    item = self.GetFirstSelected()
    if (item >= 0):
      bond = self._params[item]
      bond.atom_selection_1 = selections[0]
      bond.atom_selection_2 = selections[1]
      sele_text = "; ".join([ str(s) for s in selections ])
      self.SetStringItem(item, 0, sele_text)

  def OnSetDistance(self, event):
    item = self.GetFirstSelected()
    if (item >= 0):
      dlg = simple_dialogs.FloatDialog(
        parent=self,
        title="Ideal distance",
        label="Bond length",
        value=self._params[item].distance_ideal,
        caption="Please enter an ideal distance (in Angstroms) for the "+
          "selected bond; it will usually be a decimal number between 1 "+
          "and 4.")
      dlg.SetMin(0.1)
      dlg.SetOptional(False)
      if (dlg.ShowModal() == wx.ID_OK):
        distance_ideal = dlg.GetPhilValue()
        self._params[item].distance_ideal = distance_ideal
        self.SetStringItem(item, 1, "%g" % distance_ideal)
      dlg.Destroy()

  def OnSetSigma(self, event):
    item = self.GetFirstSelected()
    if (item >= 0):
      dlg = simple_dialogs.FloatDialog(
        parent=self,
        title="Restraint sigma",
        label="Bond sigma",
        value=self._params[item].sigma,
        caption="Please enter a sigma value (in Angstroms) for the selected "+
          "bond; it should be a decimal number between 0.01 and 1.")
      dlg.SetMin(0.001)
      dlg.SetOptional(False)
      if (dlg.ShowModal() == wx.ID_OK):
        sigma = dlg.GetPhilValue()
        self._params[item].sigma = sigma
        self.SetStringItem(item, 2, fv("%g", sigma))
      dlg.Destroy()

  def OnSetSlack(self, event):
    item = self.GetFirstSelected()
    if (item >= 0):
      dlg = simple_dialogs.FloatDialog(
        parent=self,
        title="Restraint slack",
        label="Bond slack",
        value=self._params[item].sigma,
        caption="Please enter a slack value (in Angstroms) for the selected "+
          "bond; this is the distance the bond is allowed to deviate from "+
          "ideal before the restraint will take effect.  By default this is "+
          "undefined (or zero).")
      dlg.SetMin(0)
      dlg.SetOptional(True)
      if (dlg.ShowModal() == wx.ID_OK):
        slack = dlg.GetPhilValue()
        self._params[item].slack = slack
        self.SetStringItem(item, 3, fv("%g", slack))
      dlg.Destroy()

  def OnSetSymop(self, event):
    item = self.GetFirstSelected()
    if (item >= 0):
      dlg = simple_dialogs.SymopDialog(
        parent=self,
        title="Symmetry operator",
        label="Symmetry operator",
        value=self._params[item].symmetry_operation,
        caption="You may specify a bond across symmetry mates; in this case "+
          "the symmetry operation will be applied to the coordinates of the "+
          "second atom when calculating the distance.  The operation should "+
          "be in a format like 'x,y,-z'.")
      if (dlg.ShowModal() == wx.ID_OK):
        symop = dlg.GetPhilValue()
        self._params[item].symmetry_operation = symop
        self.SetStringItem(item, 4, fv("%s", symop))

class AngleRestraintsList(RestraintsListBase):
  restraint_name = "angle"
  def CreateColumns(self):
    self.InsertColumn(0, "Selections", width=600)
    self.InsertColumn(1, "Angle", width=100)
    self.InsertColumn(2, "Sigma", width=80)

  def PopulateList(self):
    for angle in self._params :
      selections = [angle.atom_selection_1, angle.atom_selection_2,
                    angle.atom_selection_3]
      if (selections == [None, None]):
        sele_str = "---"
      else :
        sele_str = "; ".join([ str(s) for s in selections ])
      item = self.InsertStringItem(sys.maxunicode, sele_str)
      self.SetStringItem(item, 1, fv("%g", angle.angle_ideal))
      self.SetStringItem(item, 2, fv("%g", angle.sigma))

  def GetSelections(self):
    item = self.GetFirstSelected()
    if (item >= 0):
      angle = self._params[item]
      return [angle.atom_selection_1, angle.atom_selection_2,
              angle.atom_selection_3]
    return [""] * 3

  def SetSelections(self, selections):
    assert (len(selections) == 3)
    item = self.GetFirstSelected()
    if (item >= 0):
      angle = self._params[item]
      angle.atom_selection_1 = selections[0]
      angle.atom_selection_2 = selections[1]
      angle.atom_selection_3 = selections[2]
      sele_text = "; ".join([ str(s) for s in selections ])
      self.SetStringItem(item, 0, sele_text)

  def OnSetAngle(self, event):
    item = self.GetFirstSelected()
    if (item >= 0):
      dlg = simple_dialogs.FloatDialog(
        parent=self,
        title="Ideal angle",
        label="Bond angle",
        value=self._params[item].sigma,
        caption="Please enter an angle value (in degrees) for the selected "+
          "angle; it usually be a decimal number between 1 and 180.")
      dlg.SetMin(1)
      dlg.SetMax(180)
      dlg.SetOptional(False)
      if (dlg.ShowModal() == wx.ID_OK):
        angle = dlg.GetPhilValue()
        self._params[item].angle_ideal = angle
        self.SetStringItem(item, 1, "%g" % angle)
      dlg.Destroy()

  def OnSetSigma(self, event):
    item = self.GetFirstSelected()
    if (item >= 0):
      dlg = simple_dialogs.FloatDialog(
        parent=self,
        title="Restraint sigma",
        label="Bond sigma",
        value=self._params[item].sigma,
        caption="Please enter a sigma value (in degrees) for the selected "+
          "angle; it should usually be a decimal number between 1 and 5.")
      dlg.SetMin(0.1)
      dlg.SetOptional(False)
      if (dlg.ShowModal() == wx.ID_OK):
        sigma = dlg.GetPhilValue()
        self._params[item].sigma = sigma
        self.SetStringItem(item, 2, "%g" % sigma)
      dlg.Destroy()

class PlanarityRestraintsList(RestraintsListBase):
  restraint_name = "planarity"
  def CreateColumns(self):
    self.InsertColumn(0, "Atom selection", width=680)
    self.InsertColumn(1, "Sigma", width=100)

  def PopulateList(self):
    for plane in self._params :
      item = self.InsertStringItem(sys.maxunicode, fv("%s", plane.atom_selection))
      self.SetStringItem(item, 1, fv("%g", plane.sigma))

  def GetSelections(self):
    item = self.GetFirstSelected()
    if (item >= 0):
      plane = self._params[item]
      if (len(plane.atom_selection) == 0):
        return [ None ]
      return plane.atom_selection
    return [""]

  def SetSelections(self, selections):
    assert (len(selections) == 1)
    item = self.GetFirstSelected()
    if (item >= 0):
      plane = self._params[item]
      plane.atom_selection = selections
      self.SetStringItem(item, 0, fv("%s", plane.atom_selection[0]))

  def OnSetSigma(self, event):
    item = self.GetFirstSelected()
    if (item >= 0):
      dlg = simple_dialogs.FloatDialog(
        parent=self,
        title="Restraint sigma",
        label="Plane sigma",
        value=self._params[item].sigma,
        caption="Please enter a sigma value for the selected planarity "+
          "restraint; the sigma for all planes defined by the CCP4 monomer "+
          "library is 0.02.")
      dlg.SetMin(0.01)
      dlg.SetOptional(False)
      if (dlg.ShowModal() == wx.ID_OK):
        sigma = dlg.GetPhilValue()
        self._params[item].sigma = sigma
        self.SetStringItem(item, 1, "%g" % sigma)
      dlg.Destroy()

#-----------------------------------------------------------------------
# Frame class

# XXX fix for true division bug
flatnotebook.PageContainer.OnMouseWheel = lambda win, evt: False
class RestraintsFrame(wx.Frame):
  def __init__(self, *args, **kwds):
    kwds['style'] = wx.DEFAULT_FRAME_STYLE
    wx.Frame.__init__(self, *args, **kwds)
    self.sizer = wx.BoxSizer(wx.HORIZONTAL)
    self.SetSizer(self.sizer)
    tb = wx.ToolBar(self, style=wx.TB_TEXT)
    tb.SetToolBitmapSize((32,32))
    self.SetToolBar(tb)
    btn1 = tb.AddLabelTool(-1,
      label="Update and exit",
      bitmap=wxtbx.bitmaps.fetch_icon_bitmap("actions", "button_ok"),
      kind=wx.ITEM_NORMAL)
    btn2 = tb.AddLabelTool(-1,
      label="Update settings",
      bitmap=wxtbx.bitmaps.fetch_icon_bitmap("actions", "redo"),
      kind=wx.ITEM_NORMAL)
    btn3 = tb.AddLabelTool(-1,
      label="Cancel",
      bitmap=wxtbx.bitmaps.fetch_icon_bitmap("actions", "cancel"),
      kind=wx.ITEM_NORMAL)
    btn4 = tb.AddLabelTool(-1,
      label="Delete all",
      bitmap=wxtbx.bitmaps.fetch_icon_bitmap("actions", "editdelete"),
      kind=wx.ITEM_NORMAL)
    self.Bind(wx.EVT_MENU, self.OnExit, btn1)
    self.Bind(wx.EVT_MENU, self.OnUpdate, btn2)
    self.Bind(wx.EVT_MENU, self.OnCancel, btn3)
    self.Bind(wx.EVT_MENU, self.OnClearAll, btn4)
    tb.Realize()
    self.statusbar = self.CreateStatusBar()
    self.statusbar.SetStatusText("No restraints loaded.")
    self.nb = flatnotebook.FlatNotebook(
      parent=self,
      agwStyle=flatnotebook.FNB_TABS_BORDER_SIMPLE|flatnotebook.FNB_NODRAG|
        flatnotebook.FNB_NO_X_BUTTON|flatnotebook.FNB_NO_NAV_BUTTONS)
    self.bonds_panel = CustomBondPanel(self.nb, style=ATOM_SELECTION_BUTTONS)
    self.angles_panel = CustomAnglePanel(self.nb, style=ATOM_SELECTION_BUTTONS)
    self.planes_panel = CustomPlanarityPanel(self.nb,
      style=ATOM_SELECTION_BUTTONS)
    self.nb.AddPage(self.bonds_panel, "Bonds")
    self.nb.AddPage(self.angles_panel, "Angles")
    self.nb.AddPage(self.planes_panel, "Planes")
    self.sizer.Add(self.nb, 1, wx.EXPAND|wx.ALL)
    self.sizer.Fit(self.nb)
    self.Fit()
    self.Bind(wx.EVT_CLOSE, lambda evt: self.Destroy(), self)
    self.Bind(wx.EVT_WINDOW_DESTROY, self.OnDestroy, self)
    self._index = self._params = self._prefix = None

  def SetPhilIndex(self, index):
    self._index = index
    self.bonds_panel.SetPhilIndex(index)
    self.angles_panel.SetPhilIndex(index)
    self.planes_panel.SetPhilIndex(index)

  def SetParams(self, params, prefix=None):
    self._params = params
    self._prefix = prefix
    self.bonds_panel.SetPhilPrefix(prefix)
    self.angles_panel.SetPhilPrefix(prefix)
    self.planes_panel.SetPhilPrefix(prefix)
    self.SetPanelParams()
    geo_params = self.GetGeoParams()
    self.statusbar.SetStatusText(
      "%d custom bond, %d custom angle, and %d custom plane restraints loaded."
      % (len(geo_params.bond),len(geo_params.angle),len(geo_params.planarity)))

  def SetPanelParams(self):
    geo_params = self.GetGeoParams()
    self.bonds_panel.SetParams(geo_params.bond)
    self.angles_panel.SetParams(geo_params.angle)
    self.planes_panel.SetParams(geo_params.planarity)

  def GetGeoParams(self):
    geo_params_parent = self._params
    if (self._prefix is not None):
      geo_params_parent = getattr(geo_params_parent, self._prefix)
    return geo_params_parent.geometry_restraints.edits

  def GetPhilObject(self):
    geo_params = self.GetGeoParams()
    geo_params.bond = self.bonds_panel.GetParams()
    geo_params.angle = self.angles_panel.GetParams()
    geo_params.planarity = self.planes_panel.GetParams()
    self.Validate()
    new_phil = self._index.master_phil.format(python_object=self._params)
    return new_phil

  def Validate(self):
    from mmtbx.monomer_library import pdb_interpretation
    pdb_interpretation.validate_geometry_edits_params(self.GetGeoParams())

  def OnCancel(self, event):
    self.Close()

  def OnUpdate(self, event):
    self.GetPhilObject()

  def OnExit(self, event):
    self.OnUpdate(event)
    self.Close()

  def OnClearAll(self, event):
    confirm = wx.MessageBox("Are you sure you want to delete all custom "+
      "restraints?  This action cannot be undone from the restraints editor, "+
      " but clicking the Cancel "+
      "button on the toolbar will revert to the original parameters.")
    if (confirm == wx.YES):
      geo_params = self.GetGeoParams()
      geo_params.bond = []
      geo_params.angle = []
      geo_params.planarity = []
      self.SetPanelParams()

  def OnDestroy(self, event):
    pass

  def OnView(self, event):
    pass

#-----------------------------------------------------------------------
# REGRESSION TESTING
if (__name__ == "__main__"):
  from mmtbx.monomer_library import pdb_interpretation
  import iotbx.phil
  import libtbx.phil.interface
  app = wx.App(0)
  master_phil = iotbx.phil.parse(pdb_interpretation.grand_master_phil_str,
    process_includes=True)
  index = libtbx.phil.interface.index(master_phil)
  frame = RestraintsFrame(None, -1, "Custom restraints editor")
  frame.SetPhilIndex(index)
  params = index.get_python_object()
  frame.SetParams(index.get_python_object())
  frame.Show()
  app.MainLoop()


 *******************************************************************************


 *******************************************************************************
wxtbx/ensemble_validation.py

"""
Classes for display of MolProbity validation statistics for multi-model PDB
files, used in GUI for phenix.ensemble_refinement.
"""

from __future__ import absolute_import, division, print_function
from cctbx.array_family import flex
from libtbx.utils import Sorry
from wxtbx import app, path_dialogs, plots
from mmtbx.command_line import validation_summary
from wxGUI2 import AdvancedWidgets, Base
import wx
import sys
from six.moves import range
from six.moves import zip

class ensemble_validation_plot(plots.histogram):
  def show_plot(self,
      values,
      as_histogram=False,
      n_bins=10,
      reference_value=None,
      title=None):
    if (as_histogram):
      self.show_histogram(
        data=values,
        n_bins=n_bins,
        reference_value=reference_value,
        x_label="Model Score",
        y_label="Number of Models",
        title=title)
    else :
      x = list(range(1, len(values) + 1))
      self.figure.clear()
      p = self.figure.add_subplot(111)
      ax = p.plot(x, values, '-^', color=(0.0,0.5,1.0))
      if (reference_value is not None):
        p.axhline(reference_value, color='red')
      p.set_xlabel("Model Number")
      p.set_ylabel("Score")
      if (title is not None):
        p.set_title(title)
      self.canvas.draw()

# =============================================================================
class ensemble_validation_panel(wx.Panel):
  def __init__(self, *args, **kwds):
    wx.Panel.__init__(self, *args, **kwds)
    sizer = wx.BoxSizer(wx.VERTICAL)
    self.SetSizer(sizer)

    # Plot controls
    box1 = wx.BoxSizer(wx.HORIZONTAL)
    sizer.Add(box1)
    txt1 = wx.StaticText(self, label="Show statistic:")
    style = wx.LEFT|wx.TOP|wx.BOTTOM|wx.ALIGN_CENTER_VERTICAL
    box1.Add(txt1, 0, style , 5)
    self.stats_menu = wx.Choice(self,
      choices=validation_summary.molprobity_stat_labels)
    self.Bind(wx.EVT_CHOICE, self.OnSelectPlot, self.stats_menu)
    box1.Add(self.stats_menu, 0, style, 5)
    self.stats_menu.SetSelection(0)
    self.hist_box = wx.CheckBox(self, label="Display as histogram")
    box1.Add(self.hist_box, 0, style, 5)
    self.Bind(wx.EVT_CHECKBOX, self.OnSelectPlot, self.hist_box)
    n_bins_txt = wx.StaticText(self, label="Number of bins")
    box1.AddSpacer(40)
    box1.Add(n_bins_txt, 0, style, 5)
    self.n_bins_ctrl = wx.TextCtrl(self, style=wx.TE_PROCESS_ENTER,
                                   name="n_bins", size=(60, -1))
    self.n_bins_ctrl.SetValue("10")
    box1.Add(self.n_bins_ctrl, 0, style, 5)
    self.Bind(wx.EVT_TEXT_ENTER, self.OnSelectPlot, self.n_bins_ctrl)
    self.n_bins_ctrl.Disable()
    self.save_ctrl = wx.Button(parent=self, label='Export raw data')
    box1.AddSpacer(40)
    box1.Add(self.save_ctrl, 0, style, 5)
    self.Bind(wx.EVT_BUTTON, self.OnSave, self.save_ctrl)

    # Data display
    box2 = wx.BoxSizer(wx.HORIZONTAL)
    sizer.Add(box2)
    min_label = Base.BoldText(self, 'Minimum:')
    self.min_value = Base.PlainText(self, '')
    max_label = Base.BoldText(self, 'Maximum:')
    self.max_value = Base.PlainText(self, '')
    mean_label = Base.BoldText(self, 'Mean:')
    self.mean_value = Base.PlainText(self, '')
    self.value_ctrls = (self.min_value, self.max_value, self.mean_value)
    style = wx.LEFT|wx.TOP|wx.BOTTOM|wx.ALIGN_CENTER_VERTICAL
    for label, ctrl in zip([min_label, max_label, mean_label],self.value_ctrls):
      box2.Add(label, 0, style, 5)
      box2.Add(ctrl, 0, style, 5)
      box2.AddSpacer(40)
    self.plot = ensemble_validation_plot(
      parent=self,
      transparent=False)
    sizer.Add(self.plot, 1, wx.EXPAND|wx.ALL, 0)
    self.ensemble = None

  def set_ensemble(self, ensemble):
    assert (type(ensemble).__name__ == 'ensemble')
    self.ensemble = ensemble

  def OnSave(self, event):
    filename = path_dialogs.manager().select_file(
      parent=self,
      message='Save statistics as a CSV file',
      wildcard='CSV files (*.csv)|*.csv',
      current_file='statistics.csv',
      save=True)
    if (filename is not None):
      f = open(filename, 'w')
      labels = validation_summary.molprobity_stat_labels
      f.write('Statistic, Model 1, Model 2, ...\n')
      for label in labels:
        i_label = validation_summary.molprobity_stat_labels.index(label)
        stat = self.ensemble.__slots__[i_label]
        values = getattr(self.ensemble, stat)
        if ( (len(values) != 0) and (values.count(None) != len(values)) ):
          f.write('%s, ' % label +
                  ', '.join([str(v) for v in values]) + '\n')
      f.close()

  def OnSelectPlot(self, event):

    # plot line graph or histogram
    n_bins = 10
    as_histogram = self.hist_box.GetValue()
    if (as_histogram):
      self.n_bins_ctrl.Enable()
      n_bins = self.n_bins_ctrl.GetValue()
      try:
        n_bins = int(n_bins)
      except ValueError:
        raise Sorry('Please enter an integer for the number of histogram bins.')
    else:
      self.n_bins_ctrl.Disable()

    # check that n_bins is reasonable
    min_n_bins = 1
    max_n_bins = 1000
    if (n_bins < min_n_bins):
      n_bins = min_n_bins
    if (n_bins > max_n_bins):
      n_bins = max_n_bins
    self.n_bins_ctrl.SetValue(str(n_bins))

    # get attribute name and values for data
    label = self.stats_menu.GetStringSelection()
    i_label = validation_summary.molprobity_stat_labels.index(label)
    stat = self.ensemble.__slots__[i_label]
    values = getattr(self.ensemble, stat)
    if (len(values) == 0) or (values.count(None) == len(values)):
      self.plot.figure.clear()
      [ ctrl.SetLabel("") for ctrl in self.value_ctrls ]
      return
    mean = sum(values) / len(values)
    dist = [ min(values), max(values), mean ]
    [ ctrl.SetLabel("%.3f" % x) for x, ctrl in zip(dist, self.value_ctrls) ]
    self.plot.show_plot(
      values=values,
      as_histogram=as_histogram,
      n_bins=n_bins,
      reference_value=mean,
      title=label)
    self.Refresh()

# =============================================================================
class ensemble_chi_panel(wx.Panel):
  '''
  Automatic sequence of function calls
  load_data -> UpdateTable -> UpdatePlot
  OnSelect -> UpdatePlot

  load_data - initially loads data and sets up data
  UpdateTable - call this after changing threshold
  UpdatePlot - call this after changing number of histogram bins or autoscale
  '''
  def __init__(self, *args, **kwds):

    wx.Panel.__init__(self, *args, **kwds)
    self.main_window = self.GetParent().main_window
    sizer = wx.BoxSizer(wx.VERTICAL)
    self.SetSizer(sizer)

    # controls
    control_sizer = wx.BoxSizer(wx.HORIZONTAL)
    sizer.Add(control_sizer)

    self.add_text(control_sizer, 'Threshold:')
    self.threshold_control = wx.TextCtrl(self, style=wx.TE_PROCESS_ENTER,
                                         name='threshold', size=(60,-1))
    self.add_control(control_sizer, self.threshold_control)
    self.Bind(wx.EVT_TEXT_ENTER, self.UpdateTable, self.threshold_control)

    self.add_text(control_sizer, 'Number of bins:')
    self.histogram_control = wx.TextCtrl(self, style=wx.TE_PROCESS_ENTER,
                                         name='n_bins', size=(60,-1))
    self.add_control(control_sizer, self.histogram_control)
    self.Bind(wx.EVT_TEXT_ENTER, self.UpdatePlot, self.histogram_control)

    self.autoscale_control = wx.CheckBox(self, label='Autoscale x-axis')
    self.add_control(control_sizer, self.autoscale_control)
    self.Bind(wx.EVT_CHECKBOX, self.UpdatePlot, self.autoscale_control)

    self.save_control = wx.Button(parent=self, label='Export raw data')
    self.add_control(control_sizer, self.save_control)
    self.Bind(wx.EVT_BUTTON, self.OnSave, self.save_control)

    # table
    self.table = AdvancedWidgets.OutlierList(
      parent=self,
      column_labels=[ 'Residue', 'Chi1', 'Chi2', 'Chi3', 'Chi4', 'Chi5' ],
      size=(600,100),
      column_formats=[ '%s', '%.2f', '%.2f', '%.2f', '%.2f', '%.2f' ],
      style=wx.LC_REPORT|wx.LC_SINGLE_SEL|wx.LC_VIRTUAL|wx.SUNKEN_BORDER)
    self.table.SetColumnWidths([200] + [100] * 5)
    sizer.Add(self.table, 0, wx.EXPAND)
    self.table.Bind(wx.EVT_LEFT_DOWN, self.OnSelect)

    # plot
    self.plot = plots.histogram(parent=self, transparent=False)
    sizer.Add(self.plot, 1, wx.EXPAND|wx.ALL, 0)

    # set defaults
    self.threshold_control.SetValue('0.95')
    self.histogram_control.SetValue('10')
    self.autoscale_control.SetValue(False)
    self.chi_angles = None
    self.meets_threshold = None
    self.row = 0
    self.col = 1

  def load_data(self, chi_angles=None):
    # reorganize data from
    # a list of all dihedrals for each atom_group per model
    # to
    # atom_group -> list of grouped dihedral angles (e.g. all chi1 in one list)
    if (chi_angles is not None):
      n_models = len(chi_angles)
      n_groups = len(chi_angles[0]['id_str'])

      id_str = chi_angles[0]['id_str']
      xyz = chi_angles[0]['xyz']
      id_str_map = dict()
      all_angles = [ list() for i in range(n_groups) ]
      for i in range(n_groups):           # loop over atom_groups
        n_dihedrals = len(chi_angles[0]['chi_angles'][i])
        angles = [ list() for j in range(n_dihedrals) ]
        for j in range(n_models):
          dihedrals = chi_angles[j]['chi_angles'][i]
          for k in range(n_dihedrals):
            dihedral = dihedrals[k]
            if (dihedral is not None):
              angles[k].append(dihedral)

        # check if adding 360 to negative angles is helpful
        # avoids issues where angles are clustered only near 0 and 360
        for j in range(len(angles)):
          if (len(angles[j]) > 0):
            stddev_a = flex.mean_and_variance(
              flex.double(angles[j])).unweighted_sample_variance()
            dihedrals_b = flex.double(angles[j])
            for k in range(len(dihedrals_b)):
              if (dihedrals_b[k] < 0.0):
                dihedrals_b[k] += 360
            stddev_b = flex.mean_and_variance(
              dihedrals_b).unweighted_sample_variance()
            if ( (stddev_b < stddev_a) or (max(angles[j]) < 0.0) ):
              angles[j] = list(dihedrals_b)

        # store reorganized data
        all_angles[i] = angles

        # build map matching id_str with row index for fast random access
        id_str_map[id_str[i]] = i

      self.chi_angles = { 'id_str': id_str,
                          'id_str_map': id_str_map,
                          'xyz': xyz,
                          'values': all_angles }
      self.meets_threshold = [ False for i in
                               range(len(self.chi_angles['id_str'])) ]
      self.UpdateTable()
      self.UpdatePlot()

  def OnSelect(self, event=None):
    self.row, self.col = self.table.GetRowCol(event)
    if (self.col == 0):
      self.col = 1
    self.UpdatePlot()

  def OnSave(self, event=None):
    filename = path_dialogs.manager().select_file(
      parent=self,
      message='Save dihedral angles as a CSV file',
      wildcard='CSV files (*.csv)|*.csv',
      current_file='dihedrals.csv',
      save=True)
    if (filename is not None):
      f = open(filename, 'w')
      id_str = self.chi_angles['id_str']
      dihedrals = self.chi_angles['values']
      for i in range(5):
        f.write('Chi %i\n' % (i+1))
        f.write('Residue, Model 1, Model 2, ...\n')
        for j in range(len(id_str)):
          if (i < len(dihedrals[j])):
            f.write('%s, ' % id_str[j] +
                    ', '.join([str(d) for d in dihedrals[j][i]]) + '\n')
        f.write('\n\n')
      f.close()

  def UpdateTable(self, event=None):
    '''
    Construct table of residues that satisfy threshold
    '''

    # check threshold
    threshold = self.threshold_control.GetValue()
    threshold_error = 'Please enter a fraction, between 0.0 and 1.0, for the threshold.'
    try:
      threshold = float(threshold)
    except ValueError:
      raise Sorry(threshold_error)
    if ( (threshold < 0.0) or (threshold > 1.0) ):
      raise Sorry(threshold_error)
    threshold = 1.0 - threshold

    # check if dihedrals lie within 2 standard deviations of the mean.
    # for Gaussian distributions, 95% of the sample is within 2 standard
    # deviations of the mean (default threshold value)
    # set atom_group to be displayed if fraction is below threshold.
    # actual check is n_outliers/n_total > (1 - input_threshold)
    for i in range(len(self.chi_angles['id_str'])): # loop over model
      self.meets_threshold[i] = False
      for j in range(len(self.chi_angles['values'][i])): # loop over group
        dihedrals = flex.double(self.chi_angles['values'][i][j])
        if (len(dihedrals) > 0):
          mean_stddev = flex.mean_and_variance(dihedrals)
          mean = mean_stddev.mean()
          stddev = mean_stddev.unweighted_sample_standard_deviation()
          n_outliers = 0
          chi_min = mean - 2.0*stddev
          chi_max = mean + 2.0*stddev
          for k in range(len(dihedrals)):
            if ( (dihedrals[k] < chi_min) or (dihedrals[k] > chi_max) ):
              n_outliers += 1
          is_outlier = (float(n_outliers)/len(dihedrals) > threshold)
          if (is_outlier):
            self.meets_threshold[i] = True
            break

    # refresh table
    table_data = list()
    for i in range(len(self.meets_threshold)):
      if (self.meets_threshold[i]):
        row = [ '---' for j in range(8) ]
        row[0] = self.chi_angles['id_str'][i]
        row[6] = None                          # sel_str for model viewer
        row[7] = self.chi_angles['xyz'][i]     # xyz for model viewer
        for j in range(len(self.chi_angles['values'][i])):
          chi = self.chi_angles['values'][i][j]
          if ( (None not in chi) and (len(chi) > 0) ):
            row[j+1] = flex.mean(flex.double(chi))
        table_data.append(row)
    self.table.ReloadData(table_data)
    self.table.Refresh()

  def UpdatePlot(self, event=None):
    '''
    Plot histogram of chi angle for residue and angle selected in table
    '''

    # check n_bins
    n_bins = self.histogram_control.GetValue()
    try:
      n_bins = int(n_bins)
    except ValueError:
      raise Sorry('Please enter an integer for the number of histogram bins.')

    # check that n_bins is reasonable
    min_n_bins = 1
    max_n_bins = 1000
    if (n_bins < min_n_bins):
      n_bins = min_n_bins
    if (n_bins > max_n_bins):
      n_bins = max_n_bins
    self.histogram_control.SetValue(str(n_bins))

    # check autoscale option
    autoscale = self.autoscale_control.GetValue()

    # update plot with data from currently selected cell
    if (True in self.meets_threshold):
      reference_value = self.table.get_item_text(self.row, self.col)
      if (reference_value != '---'):
        id_str = self.table.get_item_text(self.row, 0)
        actual_row = self.chi_angles['id_str_map'].get(id_str, 0)
        x_label = 'Chi %i (degrees)' % self.col
        y_label = 'Numer of Models'
        title = '%s Chi %i histogram' % (id_str, self.col)
        data=self.chi_angles['values'][actual_row][self.col-1]
        x_lim = (0.0, 360.0)
        if (autoscale):
          x_lim = None
        elif(min(data) < 0.0):
          x_lim = (-180.0, 180.0)
        self.plot.show_histogram(
          data=data, n_bins=n_bins, reference_value=float(reference_value),
          x_label=x_label, y_label=y_label, title=title, x_lim=x_lim)

  # convenience functions for placing text and widgets
  def add_text(self, sizer, label,
               style=wx.LEFT|wx.TOP|wx.BOTTOM|wx.ALIGN_CENTER_VERTICAL):
    text = wx.StaticText(self, label=label)
    sizer.Add(text, 0, style, 5)

  def add_control(self, sizer, control,
                  style=wx.LEFT|wx.TOP|wx.BOTTOM|wx.ALIGN_CENTER_VERTICAL,
                  spacer=40):
    sizer.Add(control, 0, style, 5)
    sizer.AddSpacer(spacer)

# =============================================================================
if (__name__ == "__main__"):
  result = validation_summary.run(sys.argv[1:])
  if (type(result).__name__ != 'ensemble'):
    raise Sorry("Not an ensemble, graphics not available.")
  app = app.CCTBXApp(0)
  frame = wx.Frame(None, -1, "Ensemble validation")
  szr = wx.BoxSizer(wx.VERTICAL)
  panel = ensemble_validation_panel(frame)
  panel.set_ensemble(result)
  szr.Add(panel, 1, wx.EXPAND|wx.ALL)
  frame.SetSizer(szr)
  szr.Fit(panel)
  frame.Fit()
  panel.OnSelectPlot(None)
  frame.Show()
  app.MainLoop()


 *******************************************************************************


 *******************************************************************************
wxtbx/errors.py
from __future__ import absolute_import, division, print_function

from libtbx.utils import Abort, Sorry
from traceback import format_exception
import wx

def show_sorry(message):
  wx.MessageBox(message=message,
    caption="Error",
    style=wx.OK|wx.ICON_EXCLAMATION)

def wx_excepthook(type, value, traceback):
  if (type is Abort):
    pass
  elif (type is Sorry):
    show_sorry(str(value))
  else :
    message = process_exception(type, value, traceback)
    if (message is None):
      print(str(type.__name__) + ": " + str(value))
      print("".join(format_exception(type, value, traceback)))
    else :
      assert isinstance(message, str)
      show_sorry(message)

def process_exception(type, value, traceback):
  if (type is IOError):
    if (value.errno == 5) : # FIXME how to handle this?
      return ("Input/output error!  This could be a problem with your "+
        "filesystem and/or network (if an NFS mount is in use).")
    elif (value.errno == 13):
      return (("Can't write file %s - permission denied.  Please " +
        "change the permissions on the enclosing folder, or use a " +
        "different directory.") % value.filename)
    elif (value.errno == 28):
      return ("System error: no space left on device.  Please delete "+
        "or move unused files; you can remove obsolete or failed PHENIX "+
        "jobs from the job history interface, which will delete the "+
        "associated folders (if any).")
    elif (value.errno == 122):
      return ("System error: disk quota exceeded.  Please delete some "+
        "files to avoid this error (or move them to another disk).")
    elif (value.errno == 2001):
      return (("The file '%s' appears to have been moved or deleted - "+
        "can't process data.") % value.filename)
  elif (type is OSError):
    if (value.errno == 13):
      return (("Permission denied: %s.  Please change the permissions "+
        "on the enclosing folder, or use a different directory.") %
        value.filename)
    elif (value.errno == 16):
      return (("Filesystem error: %s.  This usually indicates a problem "+
        "communicating with an NFS server.") % str(value.message))
    elif (value.errno == 17):
      return (("A directory named %s already exists in the destination "+
        "directory; please move or delete it, or select a different "+
        "destination directory.") % value.filename)
  return None


 *******************************************************************************


 *******************************************************************************
wxtbx/heavy_atoms.py
from __future__ import absolute_import, division, print_function

import wxtbx.phil_controls.floatctrl
import wx.lib.mixins.listctrl
import wx
from libtbx.utils import Sorry
import sys
from six.moves import range

# XXX TEMPORARY PYTHON 3 FIX TT
class SitesList(wx.ListCtrl): #wx.lib.mixins.listctrl.CheckListCtrlMixin):
  """
  ListCtrl for displaying and editing heavy-atom sites.  Only the occupancy
  and the selection of sites may be changed.
  """
  def __init__(self, *args, **kwds):
    wx.ListCtrl.__init__(self, *args, **kwds)
    # XXX TEMPORARY PYTHON 3 FIX TT
    #wx.lib.mixins.listctrl.CheckListCtrlMixin.__init__(self)
    self._atoms = None
    self._symm = None
    self.InsertColumn(0, "#", format=wx.LIST_FORMAT_RIGHT, width=64)
    self.InsertColumn(1, "Type", width=64)
    self.InsertColumn(2, "X", format=wx.LIST_FORMAT_RIGHT, width=80)
    self.InsertColumn(3, "Y", format=wx.LIST_FORMAT_RIGHT, width=80)
    self.InsertColumn(4, "Z", format=wx.LIST_FORMAT_RIGHT, width=80)
    self.InsertColumn(5, "Occupancy", format=wx.LIST_FORMAT_RIGHT, width=120)

  def LoadFile(self, file_name):
    """
    Read sites from a PDB file.  An error will be raised if the model contains
    other residue types (protein, NA, water, etc.).
    """
    import iotbx.pdb
    pdb_in = iotbx.pdb.input(file_name)
    self._symm = pdb_in.crystal_symmetry()
    hierarchy = pdb_in.construct_hierarchy()
    counts = hierarchy.overall_counts()
    if (counts.n_models > 1):
      raise Sorry("Multi-model PDB files not allowed.")
    elif (("common_amino_acid" in counts.resname_classes) or
          ("common_nucleic_acid" in counts.resname_classes) or
          ("common_water" in counts.resname_classes)):
      raise Sorry("This PDB file appears to contain non-heavy atoms.")
    atoms = hierarchy.atoms()
    self.LoadAtoms(atoms)

  def LoadAtoms(self, atoms):
    """
    Populate the list with contents of an atom array.  This assumes that the
    contents have already been checked for suitability.
    """
    atoms.set_chemical_element_simple_if_necessary()
    self.DeleteAllItems()
    self._atoms = atoms
    for atom in atoms :
      item = self.InsertStringItem(sys.maxunicode, atom.serial.strip())
      self.SetStringItem(item, 1, atom.element.strip())
      self.SetStringItem(item, 2, "%.3f" % atom.xyz[0])
      self.SetStringItem(item, 3, "%.3f" % atom.xyz[1])
      self.SetStringItem(item, 4, "%.3f" % atom.xyz[2])
      self.SetStringItem(item, 5, "%.2f" % atom.occ)
      if hasattr(self,'CheckItem'):  # XXX Python 3 fix
        self.CheckItem(item)

  def SetSymmetry(self, symmetry):
    self._symm = symmetry

  def SaveSites(self, file_name):
    if (self._atoms is None) or (len(self._atoms) == 0):
      raise Sorry("No atoms loaded!")
    from scitbx.array_family import flex
    selection = flex.bool(self._atoms.size(), False)
    assert (len(selection) == self.GetItemCount())
    for item in range(self.GetItemCount()):
      if (self.IsChecked(item)):
        selection[item] = True
    atoms_selected = self._atoms.select(selection)
    if (len(atoms_selected) == 0):
      raise Sorry("No atoms selected!")
    f = open(file_name, "w")
    if (self._symm is not None):
      from iotbx.pdb import format_cryst1_and_scale_records
      f.write(format_cryst1_and_scale_records(self._symm) + "\n")
    for atom in atoms_selected :
      f.write(atom.format_atom_record() + "\n")
    f.close()
    wx.MessageBox(("%d atoms saved to %s.") % (len(atoms_selected), file_name))

  def ChangeOccupancy(self):
    if (self._atoms is None) or (len(self._atoms) == 0):
      raise Sorry("No atoms loaded!")
    item = self.GetFirstSelected()
    if (item < 0):
      raise Sorry("Please select a site first.")
    assert (item < len(self._atoms))
    dlg = OccupancyDialog(self, -1, "Set occupancy")
    atom = self._atoms[item]
    dlg.SetOccupancy(atom.occ, atom.serial.strip())
    if (dlg.ShowModal() == wx.ID_OK):
      new_occ = dlg.GetOccupancy()
      assert (0. <= new_occ <= 1.)
      atom.set_occ(new_occ)
      self.SetStringItem(item, 5, "%.2f" % atom.occ)

  def OnSaveSites(self, event):
    from iotbx import file_reader
    # XXX Python 3 fix needed here (flags and wildcard not allowed)
    wildcards = file_reader.get_wildcard_strings(["pdb"])
    file_name = wx.FileSelector(
      flags=wx.FD_SAVE,
      wildcard=wildcards,
      )
    if (file_name != ""):
      self.SaveSites(file_name)

  def OnChangeOccupancy(self, event):
    self.ChangeOccupancy()

  def OnLoadSites(self, event):
    from iotbx import file_reader
    wildcards = file_reader.get_wildcard_strings(["pdb"])
    file_name = wx.FileSelector(
      wildcard=wildcards)
    if (file_name != ""):
      self.LoadFile(file_name)

class OccupancyDialog(wx.Dialog):
  def __init__(self, *args, **kwds):
    wx.Dialog.__init__(self, *args, **kwds)
    style = self.GetWindowStyle()
    style |= wx.WS_EX_VALIDATE_RECURSIVELY|wx.RAISED_BORDER|wx.CAPTION
    self.SetWindowStyle(style)
    szr = wx.BoxSizer(wx.VERTICAL)
    self.SetSizer(szr)
    szr2 = wx.BoxSizer(wx.VERTICAL)
    szr.Add(szr2, 1, wx.ALL|wx.EXPAND, 10)
    self.msg_text = wx.StaticText(self, -1,
      "Changing occupancy for site <unknown> (original occupancy = 0.00).")
    szr2.Add(self.msg_text, 0, wx.ALL, 5)
    szr3 = wx.BoxSizer(wx.HORIZONTAL)
    szr2.Add(szr3)
    txt = wx.StaticText(self, -1, "New occupancy:")
    szr3.Add(txt, 0, wx.ALL|wx.ALIGN_CENTER_VERTICAL, 5)
    self.occ_ctrl = wxtbx.phil_controls.floatctrl.FloatCtrl(
      parent=self,
      size=(80,-1),
      value=0.)
    self.occ_ctrl.SetMin(0.)
    self.occ_ctrl.SetMax(1.)
    self.occ_ctrl.SetOptional(False)
    szr3.Add(self.occ_ctrl, 0, wx.ALL|wx.ALIGN_CENTER_VERTICAL, 5)
    cancel_btn = wx.Button(self, wx.ID_CANCEL)
    ok_btn = wx.Button(self, wx.ID_OK)
    ok_btn.SetDefault()
    szr4 = wx.StdDialogButtonSizer()
    szr4.Add(cancel_btn)
    szr4.Add(ok_btn, 0, wx.LEFT, 5)
    szr2.Add(szr4, 0, wx.ALL|wx.ALIGN_RIGHT, 5)
    szr.Layout()
    self.Fit()
    self.Centre(wx.BOTH)

  def SetOccupancy(self, occ, serial):
    assert (isinstance(occ, float))
    self.occ_ctrl.SetValue(occ)
    self.msg_text.SetLabel(
      "Changing occupancy for site %s (original occupancy = %.2f)." % (serial,
      occ))
    self.Refresh()

  def GetOccupancy(self):
    return self.occ_ctrl.GetPhilValue()

  def OnOkay(self, event):
    if (not self.Validate()):
      pass
    else :
      occ = self.GetOccupancy()
      self.EndModal(wx.ID_OK)

  def OnCancel(self, event):
    self.EndModal(wx.ID_CANCEL)

class sites_panel_mixin(object):
  """
  Mixin class for panel objects which contain a SitesList and buttons to
  trigger editing functions.  Should be subclassed along with wx.Panel,
  wx.Dialog, or similar.
  """
  def create_sites_list(self,
                         sizer,
                         label="Heavy atom sites",
                         show_load_button=False):
    if (label is not None):
      txt = wx.StaticText(self, -1, label + ":")
      sizer.Add(txt, 0, wx.ALL|wx.ALIGN_CENTER_VERTICAL, 5)
    self.sites_list = SitesList(self, -1,
      size=(540,200),
      style=wx.LC_REPORT|wx.LC_SINGLE_SEL)
    # XXX  TEMPORARY PYTHON 3 FIX TT
    sizer.Add(self.sites_list, 1, wx.ALL, 5) # |wx.EXPAND|wx.ALIGN_CENTER_VERTICAL, 5)
    szr2 = wx.BoxSizer(wx.HORIZONTAL)
    sizer.Add(szr2)
    if (show_load_button):
      btn0 = wx.Button(self, -1, "Load sites...")
      szr2.Add(btn0, 0, wx.TOP|wx.LEFT|wx.BOTTOM, 5)
      self.Bind(wx.EVT_BUTTON, self.sites_list.OnLoadSites)
    btn1 = wx.Button(self, -1, "Change occupancy...")
    szr2.Add(btn1, 0, wx.TOP|wx.LEFT|wx.BOTTOM, 5)
    btn2 = wx.Button(self, -1, "Save selected...")
    szr2.Add(btn2, 0, wx.TOP|wx.LEFT|wx.BOTTOM, 5)
    self.Bind(wx.EVT_BUTTON, self.sites_list.OnChangeOccupancy, btn1)
    self.Bind(wx.EVT_BUTTON, self.sites_list.OnSaveSites, btn2)

  def load_sites(self, file_name=None, atoms=None, symmetry=None):
    assert ([file_name, atoms].count(None) == 1)
    if (file_name is not None):
      assert (symmetry is None)
      self.sites_list.LoadFile(file_name)
    else :
      self.sites_list.LoadAtoms(atoms)
      if (symmetry is not None):
        self.sites_list.SetSymmetry(symmetry)

class sites_panel(sites_panel_mixin, wx.Panel):
  def __init__(self, *args, **kwds):
    wx.Panel.__init__(self, *args, **kwds)
    szr = wx.BoxSizer(wx.VERTICAL)
    self.SetSizer(szr)
    self.create_sites_list(szr, show_load_button=True)

########################################################################
# REGRESSION TESTING
def exercise():
  import iotbx.pdb
  pdb_in = iotbx.pdb.input(source_info=None, lines="""\
CRYST1   77.324  107.578   84.396  90.00  94.23  90.00 P 1 21 1
SCALE1      0.012933  0.000000  0.000956        0.00000
SCALE2      0.000000  0.009296  0.000000        0.00000
SCALE3      0.000000  0.000000  0.011881        0.00000
ATOM      1 SE   SUB     1     -27.144 -52.994 -26.775  1.00  0.00          SE
ATOM      2 SE   SUB     2     -28.543 -78.848 -28.830  0.96  0.00          SE
ATOM      3 SE   SUB     3      -6.147  -3.557 -53.677  0.87  0.00          SE
ATOM      4 SE   SUB     4      -4.949  -0.129 -55.688  0.84  0.00          SE
ATOM      5 SE   SUB     5      -2.374  -4.774 -71.923  0.84  0.00          SE
ATOM      6 SE   SUB     6     -32.758 -55.851 -15.545  0.78  0.00          SE
ATOM      7 SE   SUB     7     -27.582 -84.707 -12.897  0.77  0.00          SE
ATOM      8 SE   SUB     8     -27.552 -80.117  -9.489  0.77  0.00          SE
ATOM      9 SE   SUB     9      -3.273 -30.674 -70.235  0.69  0.00          SE
ATOM     10 SE   SUB    10      -0.502 -86.255 -44.849  0.66  0.00          SE
ATOM     11 SE   SUB    11      -4.080 -26.592 -75.056  0.66  0.00          SE
ATOM     12 SE   SUB    12       0.931 -27.847 -57.819  0.65  0.00          SE
ATOM     13 SE   SUB    13       1.508  -2.738 -67.310  0.63  0.00          SE
ATOM     14 SE   SUB    14     -30.096 -32.213 -38.946  0.58  0.00          SE
ATOM     15 SE   SUB    15      -2.988 -25.400 -54.434  0.57  0.00          SE
ATOM     16 SE   SUB    16     -30.208 -59.010 -10.822  0.52  0.00          SE
END""")
  atoms = pdb_in.construct_hierarchy().atoms()
  app = wx.App(0)
  frame = wx.Frame(None, -1, "Heavy-atom sites editor")
  sizer = wx.BoxSizer(wx.VERTICAL)
  frame.SetSizer(sizer)
  panel = sites_panel(frame)
  sizer.Add(panel, 1, wx.EXPAND)
  sizer.Fit(panel)
  frame.Fit()
  panel.load_sites(atoms=atoms, symmetry=pdb_in.crystal_symmetry())
  frame.Show()
  app.MainLoop()

if (__name__ == "__main__"):
  exercise()


 *******************************************************************************


 *******************************************************************************
wxtbx/icons.py
from __future__ import absolute_import, division, print_function
from wx.lib.embeddedimage import PyEmbeddedImage

# most of these are copied or derived from the Crystal Icons set
#   http://www.everaldo.com/crystal/
#   license: LGPL

advancedsettings = PyEmbeddedImage(
    "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")

save_all = PyEmbeddedImage(
    "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"
    "rkJggg==")

hkl_file = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAAAXNSR0IArs4c6QAAAvpQTFRF"
    "Hh79////+Pj49fX19vb2+/v7/Pz88/Pz+fn5+vr68vLy/f398fHx9PT09/f3/v7+8PDw7+/v"
    "7u7u7e3t7Ozs6+vr0dHRycnJ2NjY6urqPT09/g8PPj4+PDw8/wAAurq6AAD/t7e3/h8f5+fn"
    "6enpubm5tra24ODgtLS0uLi4/S4uu7u7Pz8//u7utbW1vb290tLS/i8v5OTk6OjovLy85ubm"
    "9+fn39/f/R4e5eXl4eHh/T4+t7f3Dw/+4uLie3v64+Pj2dnZ/E1N9OTk+rq69eXl3t7e/k9P"
    "+MjI+2xs+Ojo/r6+/D09uLj4+0xM/h4elpb2PDz7/c3N/Ozs/b29/C0t+qqq+NjYLS38+oqK"
    "+4uL+urq/T09+nt7+3t79sbGior5+cnJ+bm59sfH/n5++np6+pqa9re3enr6/k5O+mpq/X19"
    "9tbWeXn409Pz/j8//y8v/Fxc+8vL9ubm+enppaX1/d3d/S0t+bq6+YmJ9dXV/G1t+ltb/6+v"
    "+YqK+5ub+Li4+7u7/j4++Kio+ampeHj4qan4/m5u/I2N+6ur/e3t+4yMyMj4/U5O/8/P/s7O"
    "97e3+mtr3g8P/Hx898fHPDz8pqb2/z8/+ImJh4f3iIj3+3x8/+/v/V5e/w8P+srKa2v6++vr"
    "+5yc96en/Z6etrb2/39//x8f+dnZXFz7+NnZ09PT+JiY/l9fPT394uLy95eXw8Pz/W5uu4uL"
    "+Xp63Nzc/9/f/Y6O2traubn53wAAx8f37i8v9cXF/K2t/5+f+svL5ub2vD09eXn5bD09/V1d"
    "vW5u+1tb/n9/iIj4vV1d/H19/i4uu5ub99fXuqqqPS0tbW1tTj8/Tx8f+IiI+ZmZxcX1qKj4"
    "7wAA/NzcS0v6/U1N1NTUzs7O0tLy/o6O19f3/ExM/19fuamp+JmZy8vL/F1duYmJ+9vbzLy8"
    "/L29/t7e+tra/09P/29vzMzMzc3N/IyM/p6evwAAPT38/Jyc/Z2d/4+P/Gxsl5eX+2trmZn4"
    "mZn5bm5uPGhEvQAAAAF0Uk5TAEDm2GYAAAABYktHRACIBR1IAAAACXBIWXMAAAsTAAALEwEA"
    "mpwYAAAAB3RJTUUH2QkZFSQ2/VuIhwAAAUhJREFUOMuN01FugkAQBmAQlhXYFbWapjGp0aiJ"
    "+tCY9GEO0QPMNXqVvvQQPVlv0WEW8Ify4Dzx8GX+2dklih6pdJrnxmRlWVVxXJVZPk29Wx7u"
    "IJkMhBFRLBGMCQdgNhCVCgQDEasAkA4F0d5MACQp/RNZ3gPppie+Y6oyAF4E9qB6jhKBiksj"
    "iMJZAFjyEjMjFXvpQXSLYwCFJVJBEyJNuUkKgJ/TaUe78/l4/Npur9f3X3qjCiNcwdZ/yBxh"
    "HxvSsyBgttYTBUE561kAsOOisN6/yhyfJD1qgXuYcw1EkKxDeliuJwVw7oq6L2MALBZz55z2"
    "SGx3cwCWIuatYG4EglbIpJwkQUwBPKlQYFkqpCBohaSw9xz2AWDVE+zDThG0oplD73YGYN2I"
    "Blh9Hz2wXvVSggDwMiYSAAcU3cbuwDyP1kM/fvQHQgcvwPJisBMAAAAASUVORK5CYII=")

hklview_2d = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAAZiS0dE"
    "AEQARABEUhLlYwAAAAlwSFlzAAALEgAACxIB0t1+/AAAAAd0SU1FB9sFBAAGFyYmfCoAAAOO"
    "SURBVFjD7ZfPS2NXFMc/9+VGfU4SJ3GmhKkZdKGZmkXoLlmUFmkR1MJshIGmKdKVDFOaf6AM"
    "hS5czsr+WJS+CAUz0BGSRTbCgG1c2DCBQiGKDkRoKxpmaiYZk+jrwuSZTBIVkzqbOZvc9+Xk"
    "nXO/55zvfRfe2Gs2AXDlsx/1wWt9lxr46e5zXvw0I6Tj87D+ze0POx6gWD5ie7eIVTUBsLae"
    "w6qauOHoAsD1Xjf3ZViXlq4env7zsqPBy4c6yY0cdz64zlo6x8c+B49+28OqmvjqExcW1cSX"
    "325i6epB/ps/JPHnfsd3XyzpDbi114SlwsjREeQPjhDWT3/W3X3v/C91tqomRgZUAH6vlKBa"
    "kv3CIWt//4EUQlDS8/Q5clzt7e54En/lj39vvH2CPcsf8DxvQQiBVAQI5YjHX3/UkYCpVIpU"
    "KoXX68Xr9bb0e/eLX1EEKEKANImO7VjTNMLhMJqmGdj6+jqzs7N1ftIkEAIURQjMbSSgaVpd"
    "sGY2PDzM/Px8HWY2CRQhkEKAlBdPIBgMNjxXS3CaSXnMgFQEbTGwt7cHQH9/PwCqqqKqKoVC"
    "gUKhgKqqpNNpUqkULpcLr9eLqqoVBkARQpy7BwKBAIFAoA5LJBIkEgnjORaLGWWpJtcMO+4B"
    "0T4DU1NTF/pflQEplPP3wMLCwpk+ExMTDAwM4HK5cDgcLTEpBUIB2c4UrKysEIvF8Hg8TE5O"
    "YrfbcbvduN3uOr9mWHUKWupANBolGo02NFy1htXaJpNJlpaWyGazBr61tUWpVDp9Ck50oHkC"
    "fr8fv99/asN5PB5sNhujo6PYbDYDX1xcZHt7uy6hubm5hgQUAQzefajPPHiiX8Sy2ay+sbGh"
    "7+zs6OVyuaVfsVjUNzc367CZB0/0wbsPdam0IcV2ux273X52x5vNDA0NNWVAES2aMB6PE4/H"
    "T31xOp0mEokAGMKzurpKJBIhnU6fOYaGDjRjIBwOG+vx8XFDiGrHMRaLsby8zPT0tNGcmqaR"
    "yWQYGxtjZGSk/kup9BJp7nmVgUYharbzWuwsZlp2fiX4CQMVHXhViKo7rl3XHi7VdSgUIhQK"
    "1Z0FwWCQTCZzrsPIOA2b9UBtEgBOpxOn09nyhap6/Onl8/nw+XznkmIhQO7m8nhvXufeD0l2"
    "9vOXcid4y9rL+7du8t3jJII73/9ypdt8e+ja1Uu9mGztPuPFQenRm7vha7f/APVHmKiUVF97"
    "AAAAAElFTkSuQmCC")

clear_left = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABmJLR0QA/wD/AP+gvaeTAAAA"
    "CXBIWXMAAAsSAAALEgHS3X78AAAAB3RJTUUH1AMODhoSqw5f4wAAAy5JREFUeJztlz1L7EAU"
    "ht+ZTPwqZBsFW1s7QdzehQhyBftVK3/D4t+wsPUPCBYXG1nsRbC3UMtsMhuTIETWNTkWcoZk"
    "s9Hs5V72Fg6EzEdy3mfOzDmTCCLCNIucqvoPwP8AoCZ9QQjx628IE9HviQGEEAQAS0tLo/11"
    "BE1da73L9doALH5/fw8hBCzLgmVZICLYtm1A0jSFUgpSfq5ulmWQUhqAw8NDXF1dGbu1AFj8"
    "7u4OSZJASgmllJn5YDCAlNKIDodDWJZlABg0yzKkaVqw/S0Ai19fX+Pl5QW2bYOIIKXEzMwM"
    "hBCQUhpBAJBSQgiBLMuMt4gIRIT39/f6ACx+fn6OOI6hlIJlWZBSwnEcdLtd01ZKmeUgIjSb"
    "Tdze3hpbVR6oDEMWPz09Rb/fRxAE5u44DgCg1WohiiKEYYgwDBHHMcIwRLPZBABsbGzg+fnZ"
    "9MdxjOFw+D0Aix8fH8PzPPi+j16vB6012u124dm9vT1oreF5HoIgwPb2dmHccRxorREEAbTW"
    "GAwGXwOweLvdhu/7cF0XruvC8zz0ej10Op0S8NHREbTWODg4KI2dnJxAaw2tNXzfx9vbW1Ev"
    "H58svrW1BcuyzJorpWDbtgk9pRTOzs7GOa9QOp0OlFLIsgxEhDRNcXFxgYeHh91SImLxtbU1"
    "BEFgdjbfGYbrOzs7uLy8rBTf3983YSmlRJZlAFBaApUXX1lZQRRFBWGu50F4t29ubuLm5qYk"
    "3mq1TChyEiIiCCHGAxCREEKQ67poNBpGkC82xHW+np6exs6+2+1ifX3dtNkTRFTaA2YJGCKK"
    "IiwsLBgRNsBGGKbf71e6H/jMmqurq+Yd9sBoGBYSEUMkSQLbtgsQ+XuSJCXBRqOBKIoKfY+P"
    "j1heXjZtPisqAfIQ+XyeNzA6AwCYm5uDEALz8/N4fX0tjPm+j8XFRdOudRYwRJqmhaOW83re"
    "iFLKjAGAbdsFyNnZ2YINjoYvAfIQ+TzB68hhxfsiDwjAQDJcfnz0K/zLw4ghRvoKYlXG85t2"
    "9N3aAFUQFc+V+sbNeCIPTApRB2q01P4qJqLvP/z+oIg6lP+yTP2/4Adg6gAfe1qwcw05VlEA"
    "AAAASUVORK5CYII=")

hklview_3d = PyEmbeddedImage(
    "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"
    "TkSuQmCC")

search = PyEmbeddedImage(
    "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"
    "gg==")

pdb_file = PyEmbeddedImage(
    "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"
    "AloAAAAASUVORK5CYII=")

img_file = PyEmbeddedImage(
    "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"
    "LL0h/wc3DLvFAY/bOAAAAABJRU5ErkJggg==")

viewmag = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACFElEQVQ4jZWT30tTcRjGn+85"
    "Lo7T2XJ1PG79MH9gBI2xiIggatRVRasbQxndRGBRQpdGF0KIF7srm0iLCKI/wLqREKHIm4yg"
    "oqDmNsd+lLa1zdX0cPZ0sQyjnWAPPLzw5eXDA8/7FSSxrsHBa3Ik+qm5VCypirLpW1dX78rk"
    "5Pga/iOxDrh46Yq2UshenpmZtaiaRkM3oLW1Ojq79zwI35uYMyWQhP9cn8131BciuURymWSY"
    "5BOSU979h+/3ne8/QBK1LAkhpHQyfn0i/EgBkATwEAABFAGk5l+9cKyW9VsnT/mlWgEkAI0t"
    "W1y9PZ3aXgAzleobAOwAsB1AqkxrOZNOOMwA2/Z5DtkA6ABaJKBZB6wAPgJIA+hwunbLsmxR"
    "zQBLAroKYKcB9GQAuwX4UQFOAHgJQHW5tG5dX82ZAX5OP338NrOGVhnwSIC3Up2tAILPY2gr"
    "ZhcLkiR9MW0BgDYWDMW+GvxL0RVyLDjOQGBgxKyFht+QjBDi2OyzqZDnoO+40qjKhlGiUcrM"
    "j46OJPoHBm5GFmJH2p3aWauifP8nwUbbbDYFQEdTk3Wz2+2WSMJisUyfPuPnu/cfFkju2rhf"
    "M1Yt2+32uUDgAj9Hosu5fN5aN4AkNKfzzdWhIebyhVQ8vqjUDQAgVFV9PTx8gyQjyWS6vaFm"
    "NSZileLdqqrzxVIpcffO7eyf31iPhBAyqjdk/AIEL4Xptl+gaQAAAABJRU5ErkJggg==")

symmetry = PyEmbeddedImage(
    "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")


 *******************************************************************************


 *******************************************************************************
wxtbx/info_panels.py
from __future__ import absolute_import, division, print_function

# Assorted info boxes for displaying essential file information

import wxtbx.plots
import wxtbx.icons
import wx
import wx.lib
import re
from six.moves import cStringIO as StringIO
import os
import sys

from libtbx.utils import to_unicode, to_str

ALN_FLAGS = wx.ALL|wx.ALIGN_CENTER_VERTICAL

class InfoPanelBase(wx.MiniFrame):
  def __init__(self, *args, **kwds):
    kwds = dict(kwds)
    kwds['style'] = wx.CAPTION|wx.CLOSE_BOX|wx.RESIZE_BORDER
    if (wx.Platform == '__WXMSW__'):
      kwds['style'] |= wx.SYSTEM_MENU
    wx.MiniFrame.__init__(self, *args, **kwds)
    self.panel = wx.lib.scrolledpanel.ScrolledPanel(
      self, -1, style=wx.RAISED_BORDER)
    self.panel.SetupScrolling()
    self.panel_sizer = wx.BoxSizer(wx.VERTICAL)
    self.panel.SetSizer(self.panel_sizer)
    self.info_panel = None
    self.file_name = None
    self.Bind(wx.EVT_CLOSE, self.OnClose)
    self.Bind(wx.EVT_WINDOW_DESTROY, self.OnDestroy)

  def set_text(self, filename, text):
    '''
    Basic function for setting the title to a filename and displaying text
    '''
    self.SetTitle('Information for %s' %
                  os.path.basename(to_unicode(filename)))
    panel_text = wx.StaticText(self.panel, -1, text)
    self.panel_sizer.Add(panel_text, 0)
    self.panel.Layout()
    self.panel_sizer.Fit(self.panel)
    self.Fit()

  def OnClose(self, event):
    self.Destroy()

  def OnDestroy(self, event):
    pass

class ReflectionFileInfo(InfoPanelBase):
  def __init__(self, *args, **kwds):
    super(ReflectionFileInfo, self).__init__(*args, **kwds)
    self.miller_arrays = None
    self._hkl_in = None
    self._current_array = None
    box = wx.BoxSizer(wx.HORIZONTAL)
    self.panel_sizer.Add(box, 0)
    bmp = wx.StaticBitmap(self.panel, -1, wxtbx.icons.hkl_file.GetBitmap())
    box.Add(bmp, 0, ALN_FLAGS, 5)
    grid = wx.FlexGridSizer(cols=2)
    box.Add(grid, 0, ALN_FLAGS, 5)
    txt1 = wx.StaticText(self.panel, -1, "File name:")
    font = txt1.GetFont()
    font.SetWeight(wx.FONTWEIGHT_BOLD)
    txt1.SetFont(font)
    grid.Add(txt1, 0, ALN_FLAGS, 5)
    self.file_txt = wx.StaticText(self.panel, -1, "(None)")
    grid.Add(self.file_txt, 0, ALN_FLAGS, 5)
    txt3 = wx.StaticText(self.panel, -1, "Data array:")
    txt3.SetFont(font)
    grid.Add(txt3, 0, ALN_FLAGS, 5)
    self.array_choice = wx.Choice(self.panel, -1, size=(200,-1))
    grid.Add(self.array_choice, 0, ALN_FLAGS, 5)
    self.Bind(wx.EVT_CHOICE, self.OnChangeArray, self.array_choice)
    self.Centre(wx.BOTH)

  def OnChangeArray(self, event):
    array_label = self.array_choice.GetStringSelection()
    self.set_miller_array(array_label)

  def set_file(self, file_name):
    self.file_name = os.path.abspath(file_name)
    from iotbx import file_reader
    self._hkl_in = file_reader.any_file(file_name, force_type="hkl",
      raise_sorry_if_errors=True,
      raise_sorry_if_not_expected_format=True)
    self._hkl_in.check_file_type("hkl")
    self.SetTitle("Info for %s" % to_unicode(self.file_name))
    self.file_txt.SetLabel(to_unicode(self.file_name))
    self.miller_arrays = self._hkl_in.file_server.miller_arrays
    labels = [ array.info().label_string() for array in self.miller_arrays ]
    self.array_choice.SetItems(labels)
    self.array_choice.SetSelection(0)
    self.set_miller_array(labels[0])

  def set_miller_array(self, array_label):
    assert (self.file_name is not None) and (self.miller_arrays is not None)
    array = None
    for array_ in self.miller_arrays :
      if (array_.info().label_string() == array_label):
        array = array_
    assert (array is not None)
    self._current_array = array
    info_out = StringIO()
    array.show_comprehensive_summary(f=info_out)
    array.show_comprehensive_summary()
    info_list = info_out.getvalue().splitlines()
    if (self.info_panel is not None):
      self.panel_sizer.Detach(self.info_panel)
      self.info_panel.Destroy()
    self.info_panel = wx.Panel(self.panel, -1)
    self.panel_sizer.Add(self.info_panel, 1, wx.ALL|wx.EXPAND)
    szr = wx.BoxSizer(wx.VERTICAL)
    self.info_panel.SetSizer(szr)
    box = wx.StaticBox(self.info_panel, -1, "Array info:")
    box_szr = wx.StaticBoxSizer(box, wx.VERTICAL)
    szr.Add(box_szr, 1, wx.EXPAND|wx.ALL, 5)
    grid = wx.FlexGridSizer(cols=2)
    box_szr.Add(grid, 1, wx.EXPAND)
    for line in info_list[1:] :
      fields = line.split(":")
      label = fields[0]
      value = ":".join(fields[1:])
      txt1 = wx.StaticText(self.info_panel, -1, label + ":")
      font = txt1.GetFont()
      font.SetWeight(wx.FONTWEIGHT_BOLD)
      txt1.SetFont(font)
      grid.Add(txt1, 0, ALN_FLAGS, 5)
      txt2 = wx.StaticText(self.info_panel, -1, value)
      font2 = txt2.GetFont()
      font2.SetFamily(wx.FONTFAMILY_MODERN)
      txt2.SetFont(font2)
      grid.Add(txt2, 0, ALN_FLAGS, 5)
    if (array.is_complex_array()):
      btn = wx.Button(self.info_panel, -1, "Show map statistics")
      szr.Add(btn, 0, wx.ALL, 5)
      self.Bind(wx.EVT_BUTTON, self.OnShowMapStats, btn)
    szr.Fit(self.info_panel)
    self.panel.Layout()
    self.panel_sizer.Fit(self.panel)
    self.Fit()

  def OnShowMapStats(self, event):
    map_info = MapCoeffsInfo(self.GetTopLevelParent(), -1,
      "Map statistics for %s" % self._current_array.info().label_string())
    map_info.set_file(self.file_name)
    map_info.set_map_coeffs(self._current_array)
    map_info.Show()

class PDBFileInfo(InfoPanelBase):
  def __init__(self, *args, **kwds):
    super(PDBFileInfo, self).__init__(*args, **kwds)
    self._pdb_in = None
    self._hierarchy = None
    box = wx.BoxSizer(wx.HORIZONTAL)
    self.panel_sizer.Add(box, 0)
    bmp = wx.StaticBitmap(self.panel, -1, wxtbx.icons.pdb_file.GetBitmap())
    box.Add(bmp, 0, ALN_FLAGS, 5)
    grid = wx.FlexGridSizer(cols=2)
    box.Add(grid, 0, ALN_FLAGS, 5)
    txt1 = wx.StaticText(self.panel, -1, "File name:")
    font = txt1.GetFont()
    font.SetWeight(wx.FONTWEIGHT_BOLD)
    txt1.SetFont(font)
    grid.Add(txt1, 0, ALN_FLAGS, 5)
    self.file_txt = wx.StaticText(self.panel, -1, "(None)")
    grid.Add(self.file_txt, 0, ALN_FLAGS, 5)
    self.Centre(wx.BOTH)

  def set_file(self, file_name):
    self.file_name = os.path.abspath(file_name)
    from iotbx import file_reader
    import iotbx.pdb
    self._pdb_in = file_reader.any_file(file_name, force_type="pdb",
      raise_sorry_if_errors=True,
      raise_sorry_if_not_expected_format=True)
    self._pdb_in.check_file_type("pdb")
    self._hierarchy = self._pdb_in.file_object.hierarchy
    info_list = iotbx.pdb.show_file_summary(
      pdb_in=self._pdb_in.file_object,
      hierarchy=self._hierarchy)
    self.SetTitle("Info for %s" % to_unicode(self.file_name))
    self.file_txt.SetLabel(to_unicode(self.file_name))
    if (self.info_panel is not None):
      self.panel_sizer.Detach(self.info_panel)
      self.info_panel.Destroy()
    self.info_panel = wx.Panel(self.panel, -1)
    self.panel_sizer.Add(self.info_panel, 1, wx.ALL|wx.EXPAND)
    szr = wx.BoxSizer(wx.VERTICAL)
    self.info_panel.SetSizer(szr)
    box = wx.StaticBox(self.info_panel, -1, "File contents:")
    box_szr = wx.StaticBoxSizer(box, wx.VERTICAL)
    szr.Add(box_szr, 1, wx.EXPAND|wx.ALL, 5)
    grid = wx.FlexGridSizer(cols=2)
    box_szr.Add(grid, 1, wx.EXPAND)
    for label, value in info_list :
      txt1 = wx.StaticText(self.info_panel, -1, label + ":")
      font = txt1.GetFont()
      font.SetWeight(wx.FONTWEIGHT_BOLD)
      txt1.SetFont(font)
      grid.Add(txt1, 0, ALN_FLAGS, 5)
      str_value = to_str(value)
      alert = False
      if (str_value.endswith("***")):
        str_value = re.sub(r"\s*\*\*\*", "", str_value)
        alert = True
      txt2 = wx.StaticText(self.info_panel, -1, str_value)
      font2 = txt2.GetFont()
      font2.SetFamily(wx.FONTFAMILY_MODERN)
      if (alert):
        font2.SetWeight(wx.FONTWEIGHT_BOLD)
        txt2.SetForegroundColour((200,0,0))
        txt1.SetForegroundColour((200,0,0))
      txt2.SetFont(font2)
      grid.Add(txt2, 0, ALN_FLAGS, 5)
    if (len(self._hierarchy.models()) == 1):
      if (len(self._hierarchy.models()[0].chains()) > 1):
        btn = wx.Button(self.info_panel, -1, "B-factors by chain...")
        szr.Add(btn, 0, wx.ALL, 5)
        self.Bind(wx.EVT_BUTTON, self.OnShowChainBstats, btn)
    szr.Fit(self.info_panel)
    self.panel.Layout()
    self.panel_sizer.Fit(self.panel)
    self.Fit()

  def OnShowChainBstats(self, event):
    assert (self._hierarchy is not None)
    b_panel = PDBChainBisoPanel(self)
    b_panel.set_file(
      file_name=self.file_name,
      hierarchy=self._hierarchy)
    b_panel.Show()

class PDBChainBisoPanel(InfoPanelBase):
  def __init__(self, *args, **kwds):
    super(PDBChainBisoPanel, self).__init__(*args, **kwds)
    self._hierarchy = None
    box = wx.BoxSizer(wx.HORIZONTAL)
    self.panel_sizer.Add(box, 0)
    bmp = wx.StaticBitmap(self.panel, -1, wxtbx.icons.pdb_file.GetBitmap())
    box.Add(bmp, 0, ALN_FLAGS, 5)
    grid = wx.FlexGridSizer(cols=2)
    box.Add(grid, 0, ALN_FLAGS, 5)
    txt1 = wx.StaticText(self.panel, -1, "File name:")
    font = txt1.GetFont()
    font.SetWeight(wx.FONTWEIGHT_BOLD)
    txt1.SetFont(font)
    grid.Add(txt1, 0, ALN_FLAGS, 5)
    self.file_txt = wx.StaticText(self.panel, -1, "(None)")
    grid.Add(self.file_txt, 0, ALN_FLAGS, 5)
    self.Centre(wx.BOTH)

  def set_file(self, file_name, hierarchy=None):
    self.file_name = os.path.abspath(file_name)
    from scitbx.array_family import flex
    if (hierarchy is None):
      from iotbx import file_reader
      import iotbx.pdb
      pdb_in = file_reader.any_file(file_name, force_type="pdb",
        raise_sorry_if_errors=True,
        raise_sorry_if_not_expected_format=True)
      pdb_in.check_file_type("pdb")
      hierarchy = pdb_in.file_object.hierarchy
    if (len(hierarchy.models()) > 1):
      raise Sorry("Multi-MODEL PDB files not supported.")
    self._hierarchy = hierarchy
    self.SetTitle("B-factors by chain for %s" % to_unicode(self.file_name))
    self.file_txt.SetLabel(to_unicode(self.file_name))
    chain_list = wx.ListCtrl(self.panel, -1, style=wx.LC_REPORT, size=(480,160))
    chain_list.InsertColumn(0, "Chain info")
    chain_list.InsertColumn(1, "Mean B-iso (range)")
    chain_list.SetColumnWidth(0, 260)
    chain_list.SetColumnWidth(1, 200)
    for chain in hierarchy.models()[0].chains():
      n_res = len(chain.residue_groups())
      chain_atoms = chain.atoms()
      n_atoms = len(chain_atoms)
      main_conf = chain.conformers()[0]
      chain_type = "other"
      if (main_conf.is_protein()):
        chain_type = "protein"
      elif (main_conf.is_na()):
        chain_type = "nucleic acid"
      chain_info = "'%s' (%s, %d res., %d atoms)" % (chain.id, chain_type,
        n_res, n_atoms)
      b_iso = chain_atoms.extract_b()
      b_max = flex.max(b_iso)
      b_min = flex.min(b_iso)
      b_mean = flex.mean(b_iso)
      b_info = "%.2f (%.2f - %.2f)" % (b_mean, b_min, b_max)
      item = chain_list.InsertStringItem(sys.maxunicode, chain_info)
      chain_list.SetStringItem(item, 1, b_info)
    self.panel_sizer.Add(chain_list, 1, wx.EXPAND|wx.ALL, 5)
    self.panel.Layout()
    self.panel_sizer.Fit(self.panel)
    self.Fit()

class ImageFileInfo(InfoPanelBase):
  def __init__(self, *args, **kwds):
    super(ImageFileInfo, self).__init__(*args, **kwds)
    self._img_in = None
    box = wx.BoxSizer(wx.HORIZONTAL)
    self.panel_sizer.Add(box, 0)
    bmp = wx.StaticBitmap(self.panel, -1, wxtbx.icons.img_file.GetBitmap())
    box.Add(bmp, 0, ALN_FLAGS, 5)
    grid = wx.FlexGridSizer(cols=2)
    box.Add(grid, 0, ALN_FLAGS, 5)
    txt1 = wx.StaticText(self.panel, -1, "File name:")
    font = txt1.GetFont()
    font.SetWeight(wx.FONTWEIGHT_BOLD)
    txt1.SetFont(font)
    grid.Add(txt1, 0, ALN_FLAGS, 5)
    self.file_txt = wx.StaticText(self.panel, -1, "(None)")
    grid.Add(self.file_txt, 0, ALN_FLAGS, 5)
    self.Centre(wx.BOTH)

  def set_file(self, file_name):
    self.file_name = os.path.abspath(file_name)
    from iotbx import file_reader
    img_in = file_reader.any_file(
      file_name=file_name,
      valid_types=["img"],
      force_type="img",
      raise_sorry_if_errors=True,
      raise_sorry_if_not_expected_format=True)
    img_in.assert_file_type("img")
    self._img_in = img_in
    out = StringIO()
    img_in.file_object.show_header()
    img_in.file_object.show_header(out=out)
    self.SetTitle("Info for %s" % to_unicode(self.file_name))
    self.file_txt.SetLabel(to_unicode(self.file_name))
    if (self.info_panel is not None):
      self.panel_sizer.Detach(self.info_panel)
      self.info_panel.Destroy()
    self.info_panel = wx.Panel(self.panel, -1)
    self.panel_sizer.Add(self.info_panel, 1, wx.ALL|wx.EXPAND)
    szr = wx.BoxSizer(wx.VERTICAL)
    self.info_panel.SetSizer(szr)
    box = wx.StaticBox(self.info_panel, -1, "File contents:")
    box_szr = wx.StaticBoxSizer(box, wx.VERTICAL)
    szr.Add(box_szr, 1, wx.EXPAND|wx.ALL, 5)
    grid = wx.FlexGridSizer(cols=2)
    box_szr.Add(grid, 1, wx.EXPAND)
    for line in out.getvalue().splitlines()[1:] :
      label, value = line.strip().split(":")
      txt1 = wx.StaticText(self.info_panel, -1, label + ":")
      font = txt1.GetFont()
      font.SetWeight(wx.FONTWEIGHT_BOLD)
      txt1.SetFont(font)
      grid.Add(txt1, 0, ALN_FLAGS, 5)
      txt2 = wx.StaticText(self.info_panel, -1, value)
      font2 = txt2.GetFont()
      font2.SetFamily(wx.FONTFAMILY_MODERN)
      txt2.SetFont(font2)
      grid.Add(txt2, 0, ALN_FLAGS, 5)
    szr.Fit(self.info_panel)
    self.panel.Layout()
    self.panel_sizer.Fit(self.panel)
    self.Fit()

class MapCoeffsInfo(InfoPanelBase):
  def __init__(self, *args, **kwds):
    super(MapCoeffsInfo, self).__init__(*args, **kwds)
    self._current_array = None
    self._current_map = None
    box = wx.BoxSizer(wx.HORIZONTAL)
    self.panel_sizer.Add(box, 0)
    bmp = wx.StaticBitmap(self.panel, -1, wxtbx.icons.hkl_file.GetBitmap())
    box.Add(bmp, 0, ALN_FLAGS, 5)
    grid = wx.FlexGridSizer(cols=2)
    box.Add(grid, 0, ALN_FLAGS, 5)
    txt1 = wx.StaticText(self.panel, -1, "File name:")
    font = txt1.GetFont()
    font.SetWeight(wx.FONTWEIGHT_BOLD)
    txt1.SetFont(font)
    grid.Add(txt1, 0, ALN_FLAGS, 5)
    self.file_txt = wx.StaticText(self.panel, -1, "(None)")
    grid.Add(self.file_txt, 0, ALN_FLAGS, 5)
    txt3 = wx.StaticText(self.panel, -1, "Map coefficients:")
    txt3.SetFont(font)
    grid.Add(txt3, 0, ALN_FLAGS, 5)
    self.map_txt = wx.StaticText(self.panel, -1, "(None)")
    grid.Add(self.map_txt, 0, ALN_FLAGS, 5)

  def set_file(self, file_name):
    self.file_txt.SetLabel(to_unicode(file_name))

  def set_map_coeffs(self, array):
    assert (array.is_complex_array())
    self.map_txt.SetLabel(str(array.info().label_string()))
    self._current_array = array
    map = array.fft_map(resolution_factor=0.25)
    self._current_map = map
    self.info_panel = wx.Panel(self.panel, -1)
    self.panel_sizer.Add(self.info_panel, 1, wx.ALL|wx.EXPAND)
    szr = wx.BoxSizer(wx.VERTICAL)
    self.info_panel.SetSizer(szr)
    box = wx.StaticBox(self.info_panel, -1, "Map info:")
    box_szr = wx.StaticBoxSizer(box, wx.VERTICAL)
    szr.Add(box_szr, 1, wx.EXPAND|wx.ALL, 5)
    grid = wx.FlexGridSizer(cols=2)
    box_szr.Add(grid, 0, wx.EXPAND)
    import iotbx.map_tools
    info_list = iotbx.map_tools.get_map_summary(map)
    for label, value in info_list :
      txt1 = wx.StaticText(self.info_panel, -1, label + ":")
      font = txt1.GetFont()
      font.SetWeight(wx.FONTWEIGHT_BOLD)
      txt1.SetFont(font)
      grid.Add(txt1, 0, ALN_FLAGS, 5)
      str_value = to_str(value)
      alert = False
      if (str_value.endswith("***")):
        str_value = re.sub(r"\s*\*\*\*", "", str_value)
        alert = True
      txt2 = wx.StaticText(self.info_panel, -1, str_value)
      font2 = txt2.GetFont()
      font2.SetFamily(wx.FONTFAMILY_MODERN)
      if (alert):
        font2.SetWeight(wx.FONTWEIGHT_BOLD)
        txt2.SetForegroundColour((200,0,0))
        txt1.SetForegroundColour((200,0,0))
      txt2.SetFont(font2)
      grid.Add(txt2, 0, ALN_FLAGS, 5)
    self.histogram = wxtbx.plots.histogram(self.info_panel, figure_size=(6,4))
    self.draw_plot(n_bins=20, log_scale=False)
    box_szr.Add(self.histogram, 1, wx.EXPAND, 5)
    hbox = wx.BoxSizer(wx.HORIZONTAL)
    box_szr.Add(hbox, 0, wx.TOP, 5)
    ip = self.info_panel
    btn = wx.Button(ip, -1, "Save plot to file...")
    self.Bind(wx.EVT_BUTTON, lambda evt: self.histogram.save_image(), btn)
    hbox.Add(btn, 0, ALN_FLAGS, 5)
    hbox.Add(wx.StaticText(ip, label="Number of bins:"), 0, ALN_FLAGS, 5)
    self.n_bins_ctrl = wx.SpinCtrl(ip, value="20", min=10, max=50, initial=20)
    self.Bind(wx.EVT_SPINCTRL, self.OnRedraw, self.n_bins_ctrl)
    hbox.Add(self.n_bins_ctrl, 0, ALN_FLAGS, 5)
    self.log_scale_box = wx.CheckBox(ip, label="Use log scale for Y-axis")
    hbox.Add(self.log_scale_box, 0, ALN_FLAGS, 5)
    self.Bind(wx.EVT_CHECKBOX, self.OnRedraw, self.log_scale_box)
    szr.Fit(self.info_panel)
    self.panel.Layout()
    self.panel_sizer.Fit(self.panel)
    self.Fit()

  def OnRedraw(self, event):
    self.draw_plot(
      n_bins = self.n_bins_ctrl.GetValue(),
      log_scale = self.log_scale_box.GetValue())

  def draw_plot(self, n_bins, log_scale):
    self.histogram.figure.clear()
    self.histogram.show_histogram(
      data=self._current_map.real_map(False).as_1d().as_numpy_array(),
      n_bins=n_bins,#n_bins,
      reference_value=0.0,
      x_label="Sigma level",
      y_label="Number of points",
      title="Distribution of grid values (spacing=d_min/4)",
      log_scale=log_scale)
    self.Refresh()

if (__name__ == "__main__"):
  import libtbx.load_env
  pdb1 = libtbx.env.find_in_repositories(
    relative_path="phenix_regression/pdb/2C30.pdb",
    test=os.path.isfile)
  hkl1 = libtbx.env.find_in_repositories(
    relative_path="phenix_regression/wizards/partial_refine_001_map_coeffs.mtz",
    test=os.path.isfile)
  img1 = "/net/cci/dials/jcsg/1vph/data/jcsg/ssrl1/9_2/20040718/TB0723W/11318/11318_2_017.img"
  assert (not None in [pdb1, hkl1])
  app = wx.App(0)
  frame1 = ReflectionFileInfo(None)
  frame1.set_file(hkl1)
  frame1.Show()
  frame2 = PDBFileInfo(None)
  frame2.set_file(pdb1)
  frame2.Show()
  frame2b = PDBChainBisoPanel(None)
  frame2b.set_file(pdb1)
  frame2b.Show()
  if (os.path.exists(img1)):
    frame3 = ImageFileInfo(None)
    frame3.set_file(img1)
    frame3.Show()
  app.MainLoop()


 *******************************************************************************


 *******************************************************************************
wxtbx/layout.py
from __future__ import absolute_import, division, print_function

import wx

__default_border__ = 5
class SizerContainer(object):
  __default_text_width__ = 480
  if (wx.Platform == '__WXMAC__'):
    __default_font_size__ = 12
    __default_label_size__ = 16
  elif (wx.Platform == '__WXGTK__'):
    __default_font_size__ = 11
    __default_label_size__ = 14
  else :
    __default_font_size__ = 11
    __default_label_size__ = 14

  def __init__(self):
    self._panel_list = []
    self._boxes = {}
    self._box_labels = []
    self._sizer_stack = []
    self._font_size = self.__default_font_size__
    self._label_size = self.__default_label_size__
    self._text_width = self.__default_text_width__
    self._current_sizer = None
    self._current_panel = None
    self.main_sizer = None
    self._label_font = wx.Font(self._label_size, wx.FONTFAMILY_DEFAULT,
      wx.NORMAL, wx.BOLD)

  def get_panel(self):
    return self._current_panel

  #--- properties
  def set_font_size(self, font_size):
    assert isinstance(font_size, int)
    self._font_size = font_size

  def reset_font_size(self):
    self._font_size = self.__default_font_size__

  def set_text_width(self, width):
    assert isinstance(width, int)
    self._text_width = width

  def set_panel(self, panel):
    self._current_panel = panel

  def set_main_sizer(self, sizer):
    assert (self.main_sizer is None) and (len(self._sizer_stack) == 0)
    self.main_sizer = sizer
    self._sizer_stack.append(sizer)
    self._current_sizer = sizer

  #--- sizer management
  def get_current_sizer(self):
    return self._current_sizer

  def _start_box(self, sizer_type, label="", border=0, indent=None,
      expand=False, proportion=0, center=False):
    assert (sizer_type in [wx.HORIZONTAL, wx.VERTICAL])
    self._sizer_stack.append(self._current_sizer)
    new_sizer = wx.BoxSizer(sizer_type)
    flags = wx.ALL
    if expand :
      flags |= wx.EXPAND
    if center :
      flags |= wx.ALIGN_CENTER
    self._current_sizer.Add(new_sizer, proportion, flags, border)
    self._current_sizer = new_sizer
    if (indent is not None):
      assert isinstance(indent, int)
      self._current_sizer.Add((indent, -1))

  def start_hbox(self, *args, **kwds):
    self._start_box(wx.HORIZONTAL, *args, **kwds)

  def start_vbox(self, *args, **kwds):
    self._start_box(wx.VERTICAL, *args, **kwds)

  def start_grid(self, rows=0, cols=2, proportion=0, flags=0):
    self._sizer_stack.append(self._current_sizer)
    grid_sizer = wx.FlexGridSizer(rows, cols, 0, 0)
    self._current_sizer.Add(grid_sizer, proportion, flags)
    self._current_sizer = grid_sizer

  def start_section(self, label="", proportion=0, label_font=None,
      label_size=None):
    box = wx.StaticBox(self.get_panel(), -1, label, style=wx.NO_BORDER)
    if (label_font is None):
      label_font = self._label_font
    if (label_size is None):
      label_size = self._label_size
    label_font.SetPointSize(label_size)
    box.SetFont(label_font)
    box_sizer = wx.StaticBoxSizer(box, wx.VERTICAL)
    self._current_sizer.Add(box_sizer, proportion, wx.ALL|wx.EXPAND, 5)
    self._sizer_stack.append(self._current_sizer)
    self._current_sizer = box_sizer
    self._boxes[label] = box
    self._box_labels.append(label)

  def end_current(self):
    self._current_sizer = self._sizer_stack.pop()

  def end_box(self):
    self.end_current()

  def end_grid(self):
    self.end_current()

  def end_section(self, pad=0):
    if (pad > 0):
      self._current_sizer.Add((10, pad))
    self.end_current()

  def start_toggle_section(self, label="Details. . .", label2=None,
      collapsed=True, proportion=0, expand=False):
    self.start_vbox(proportion=proportion, expand=expand)
    # TODO???

  #--- control layout
  def Add(self, control, proportion=0, flags=0, border=__default_border__):
    self.get_current_sizer().Add(control, proportion, flags, border)

  def Detach(self, control):
    control.GetSizer().Detach(control)

  def add_expanding_widget(self, control, proportion=0, border=5):
    self.Add(control, proportion, wx.ALL|wx.EXPAND, border)

  def add_centered_widget(self, control):
    self.Add(control, 0, wx.ALL|wx.ALIGN_CENTER_VERTICAL, 5)

  def add_centered_widgets(self, *args):
    for control in args :
      self.add_centered_widget(control)

  def add_row_widget(self, control, proportion=0, border=10):
    self.Add(control, proportion, wx.ALL|wx.EXPAND, border)

  def add_spacer(self, width=10, height=-1):
    assert (width > 0) or (height > 0)
    self._current_sizer.Add((width, height))

  def place_widget_row(self, *args):
    self.start_box()
    for control in args :
      self.add_row_widget(control)
    self.add_spacer(10, 1)
    self.end_box()

  #--- text creation
  def _add_text(self, text, bold=False, mono=False, font_size=None,
      text_color=(0,0,0), width=None, set_explicit_width=False):
    if (font_size is None):
      font_size = self._font_size
    if (width is None):
      width = self._text_width
    size = wx.DefaultSize
    if (width is not None) and (set_explicit_width):
      size = (width, -1)
    text_widget = wx.StaticText(
      parent=self.get_panel(),
      id=-1,
      label=text,
      size=size)
    font = text_widget.GetFont()
    font.SetPointSize(font_size)
    if bold :
      font.SetWeight(wx.FONTWEIGHT_BOLD)
    if mono :
      font.SetFamily(wx.FONTFAMILY_MODERN)
    text_widget.SetFont(font)
    if (text_color != (0,0,0)):
      text_widget.SetForegroundColour((text_color))
    if (width is not None):
      text_widget.Wrap(width)
    self.add_centered_widget(text_widget)
    return text_widget

  def add_text(self, text, **kwds):
    return self._add_text(text, **kwds)

  def add_bold_text(self, text, **kwds):
    kwds['bold'] = True
    return self._add_text(text, **kwds)

  def add_mono_text(self, text, **kwds):
    kwds['mono'] = True
    return self._add_text(text, **kwds)

  def add_italic_text(self, text, **kwds) : # FIXME
    return self._add_text(text, **kwds)

  #--- other controls
  def add_bitmap(self, bmp):
    if isinstance(bmp, wx.Image):
      bmp = bmp.ConvertToBitmap()
    img = wx.StaticBitmap(self.get_panel(), -1, bmp)
    self.add_centered_widget(img)

  def add_line(self, width=None, expand=False):
    if (width is None):
      width = self._text_width
    line = wx.StaticLine(self.get_panel(), -1, size=(width,2),
      style=wx.LI_HORIZONTAL)
    flags = wx.ALIGN_CENTER
    if expand :
      flags |= wx.EXPAND
    self._current_sizer.Add(line, 0, flags, 5)

  #--- debugging
  def show_sizers(self):
    indent = 0
    for sizer in self._sizer_stack :
      print("%s%s" % (" "*indent, type(sizer).__name__))
      indent += 2

########################################################################
# TESTING
if (__name__ == "__main__"):
  class TestPanel(wx.Panel, SizerContainer):
    def __init__(self, *args, **kwds):
      wx.Panel.__init__(self, *args, **kwds)
      SizerContainer.__init__(self)
      self.set_panel(self)
      main_sizer = wx.BoxSizer(wx.VERTICAL)
      self.SetSizer(main_sizer)
      self.set_main_sizer(main_sizer)

  app = wx.App(0)
  frame = wx.Frame(None, -1, "Test frame")
  p = TestPanel(frame, -1)
  p.start_hbox()
  p.add_bold_text("Bold text")
  p.add_mono_text("Mono text")
  p.add_text("Plain text")
  p.end_box()
  p.add_bold_text("Bold text, font size = 14, color = red",
    text_color=(255,0,0),
    font_size=14)
  p.start_section("New section")
  p.start_hbox()
  try :
    import wxtbx.bitmaps
    p.add_bitmap(wxtbx.bitmaps.fetch_icon_bitmap("filesystems", "folder_home"))
    p.add_text("Caption with bitmap")
  except ImportError :
    p.add_text("wxtbx.bitmaps not found, disabled")
  p.end_box()
  p.end_section()
  p.start_section("Another section (proportion=1)", label_size=12, proportion=1)
  p.set_text_width(720)
  p.set_font_size(9)
  p.add_text("  ".join(["The quick brown fox jumped over the lazy dogs."]*10))
  p.reset_font_size()
  p.add_line(expand=True)
  p.add_italic_text("Normal size")
  p.end_section()
  p.main_sizer.Fit(p)
  frame.Fit()
  frame.Show()
  app.MainLoop()


 *******************************************************************************


 *******************************************************************************
wxtbx/listeditor.py
from __future__ import absolute_import, division, print_function

from wxtbx import metallicbutton
import wxtbx.bitmaps
import wx
import sys

class ListEditor(wx.Panel):
  def __init__(self, *args, **kwds):
    wx.Panel.__init__(self, *args, **kwds)
    self._default_label = "---"
    szr = wx.BoxSizer(wx.VERTICAL)
    self.SetSizer(szr)
    self.sizer = szr
    self.CreateList()
    self.buttons = wx.BoxSizer(wx.HORIZONTAL)
    add_btn = self.AddControlButton(
      label="Add",
      bitmap=wxtbx.bitmaps.fetch_icon_bitmap("actions", "edit_add", 16))
    self.Bind(wx.EVT_BUTTON, self.OnAdd, add_btn)
    del_btn = self.AddControlButton(
      label="Delete",
      bitmap=wxtbx.bitmaps.fetch_icon_bitmap("actions", "cancel", 16))
    self.Bind(wx.EVT_BUTTON, self.OnDelete, del_btn)
    clear_btn = self.AddControlButton(
      label="Clear all",
      bitmap=wxtbx.bitmaps.fetch_icon_bitmap("actions", "editdelete", 16))
    self.Bind(wx.EVT_BUTTON, self.OnDeleteAll, clear_btn)
    update_btn = self.AddControlButton(
      label="Update item",
      bitmap=wxtbx.bitmaps.fetch_icon_bitmap("actions", "recur", 16))
    self.Bind(wx.EVT_BUTTON, self.OnUpdate, update_btn)
    szr.Add(self.buttons, 0, wx.LEFT|wx.BOTTOM|wx.RIGHT, 5)
    edit_szr = wx.BoxSizer(wx.HORIZONTAL)
    edit_label = wx.StaticText(
      parent=self,
      label="Edit selected:")
    edit_szr.Add(edit_label, 0, wx.RIGHT|wx.ALIGN_CENTER_VERTICAL, 5)
    self.edit = wx.TextCtrl(
      parent=self,
      size=(300,-1),
      style=wx.TE_PROCESS_ENTER)
    self.Bind(wx.EVT_TEXT_ENTER, self.OnUpdate, self.edit)
    edit_szr.Add(self.edit, 1, wx.EXPAND|wx.RIGHT|wx.ALIGN_CENTER_VERTICAL, 5)
    szr.Add(edit_szr, 0, wx.EXPAND|wx.TOP|wx.LEFT|wx.BOTTOM, 5)
    szr.Layout()
    self.sizer = szr
    self._label = None
    self._callback = None

  def CreateList(self):
    self.list = wx.ListCtrl(
      parent=self,
      id=-1,
      style=wx.LC_REPORT|wx.LC_SINGLE_SEL)
    self.list.InsertColumn(0, "Items", width=460)
    self.list.SetMinSize((480,160))
    if (hasattr(self.list, "SetItemSpacing")) and (wx.VERSION < (2,9)):
      self.list.SetItemSpacing(5)
    self.Bind(wx.EVT_LIST_ITEM_SELECTED, self.OnSelect, self.list)
    self.Bind(wx.EVT_LIST_ITEM_DESELECTED, self.OnDeSelect, self.list)
    self.sizer.Add(self.list, 1, wx.EXPAND|wx.ALL, 5)

  def SetLabel(self, label, font_weight=wx.FONTWEIGHT_BOLD):
    if (self._label is not None):
      self._label.SetLabel(label)
    else :
      self._label = wx.StaticText(parent=self, label=label)
      font = self._label.GetFont()
      font.SetWeight(font_weight)
      self._label.SetFont(font)
      self.sizer.Insert(0, self._label, 0, wx.TOP|wx.LEFT, 5)
    self.sizer.Layout()

  def SetColumnHeader(self, header):
    col = self.list.GetColumn(0)
    col.SetText(header)
    self.list.SetColumn(0, col)

  def SetToolTip(self, tool_tip):
    if isinstance(tool_tip, str):
      self.list.SetToolTip(wx.ToolTip(tool_tip))
    else :
      self.list.SetToolTip(tool_tip)

  def AddControlButton(self, label, bitmap):
    btn = metallicbutton.MetallicButton(
      parent=self,
      label=label,
      bmp=bitmap,
      highlight_color=(200,220,240))
    self.buttons.Add(btn, 0, wx.RIGHT, 5)
    return btn

  def AddItem(self, item):
    return self.list.InsertStringItem(sys.maxunicode, item)

  def OnAdd(self, event):
    i = self.AddItem(self._default_label)
    self.list.Select(i, 1)
    self.edit.SetFocus()
    self.call_back()

  def OnDelete(self, event):
    i = self.list.GetFirstSelected()
    if (i >= 0):
      self.list.DeleteItem(i)
    self.edit.SetValue("")
    self.call_back()

  def OnUpdate(self, event):
    evt_type = event.GetEventType()
    txt = self.edit.GetValue()
    if (txt == "") or (txt is None):
      txt = self._default_label
    i = self.list.GetFirstSelected()
    if (i == -1):
      if (event.GetEventType() == wx.EVT_TEXT_ENTER.typeId):
        i = self.AddItem(txt)
        self.list.Select(i, 1)
    else :
      self.list.SetItemText(i, txt)
    self.list.SetFocus()
    self.call_back()

  def OnSelect(self, event):
    item = self.list.GetFirstSelected()
    txt = str(self.list.GetItemText(item))
    if (txt == self._default_label):
      txt = ""
    self.edit.SetValue(txt)
    self.call_back()

  def OnDeSelect(self, event):
    self.edit.SetValue("")
    self.call_back()

  def SetDefaultItemLabel(self, label):
    self._default_label = label

  def GetValues(self):
    items = []
    i = 0
    n = self.list.GetItemCount()
    while (i < n):
      txt = str(self.list.GetItemText(i))
      if (txt == self._default_label):
        txt = None
      items.append(txt)
      i += 1
    return items

  def DeleteAllItems(self):
    self.list.DeleteAllItems()
    self.call_back()

  def OnDeleteAll(self, evt):
    if (self.list.GetItemCount() == 0):
      return False
    confirm = wx.MessageBox(caption="Confirm delete",
      message="Are you sure you want to delete all items in the list?")
    if (confirm == wx.OK):
      self.DeleteAllItems()

  def SetSelectedValue(self, txt):
    i = self.list.GetFirstSelected()
    if (i == -1):
      return
    self.list.SetItemText(i, txt)
    self.edit.SetValue(txt)

  def GetSelectedValue(self):
    i = self.list.GetFirstSelected()
    if (i == -1):
      return None
    return str(self.list.GetItemText(i))

  def SetCallback(self, callback):
    assert hasattr(callback, "__call__")
    self._callback = callback

  def call_back(self):
    if (self._callback is not None):
      self._callback()

if __name__ == "__main__" :
  app = wx.App(0)
  frame = wx.Frame(None, -1, "Test frame")
  szr = wx.BoxSizer(wx.VERTICAL)
  frame.SetSizer(szr)
  panel = ListEditor(parent=frame)
  panel.SetLabel("TLS groups:")
  panel.SetColumnHeader("Atom selection")
  szr.Add(panel, 1, wx.EXPAND)
  szr.Layout()
  szr.Fit(panel)
  frame.Fit()
  frame.Show()
  app.MainLoop()


 *******************************************************************************


 *******************************************************************************
wxtbx/metallicbutton.py
from __future__ import absolute_import, division, print_function

# Copyright 2010 University of California
# derived from wx.lib.platebtn (see copyright below).

###############################################################################
# Name: platebtn.py                                                           #
# Purpose: PlateButton is a flat label button with support for bitmaps and    #
#          drop menu.                                                         #
# Author: Cody Precord <cprecord@editra.org>                                  #
# Copyright: (c) 2007 Cody Precord <staff@editra.org>                         #
# Licence: wxWindows Licence                                                  #
###############################################################################

__all__ = ["MetallicButton", "AdjustAlpha", "AdjustColour",
           "GetHighlightColour",
           "GRADIENT_NORMAL", "GRADIENT_PRESSED", "GRADIENT_HIGHLIGHT",
           "MB_STYLE_DEFAULT", "GB_STYLE_BOLD_LABEL", "GB_STYLE_DROPARROW"]


import wx.lib.wordwrap
import wx.lib.imageutils
from wx.lib.colourutils import *

from wxtbx import wx4_compatibility as wx4c

# Used on OSX to get access to carbon api constants
CAPTION_SIZE = 9
LABEL_SIZE = 11
if wx.Platform == '__WXMAC__':
  try:
    from Carbon import Appearance as CarbonAppearance
  except Exception:
    CarbonAppearance = None
elif (wx.Platform == '__WXMSW__'):
  CAPTION_SIZE = 9
  LABEL_SIZE = 11

GRADIENT_NORMAL = 0
GRADIENT_PRESSED = 1
GRADIENT_HIGHLIGHT = 2

MB_STYLE_DEFAULT = 1
MB_STYLE_BOLD_LABEL = 2
MB_STYLE_DROPARROW = 4

WxCtrl = wx4c.get_wx_mod(wx, wx.Control)
class MetallicButton(WxCtrl):
  def __init__ (self,
                parent,
                id_=wx.ID_ANY,
                label='',
                label2='',
                bmp=None,
                pos=wx.DefaultPosition,
                size=wx.DefaultSize,
                style=MB_STYLE_DEFAULT,
                name=wx.ButtonNameStr,
                start_color=(218,218,218),
                gradient_percent=15.0,
                highlight_color=(230,230,230),
                label_size=LABEL_SIZE,
                caption_size=CAPTION_SIZE,
                button_margin=2,
                disable_after_click=0,
                bmp2=None):

    WxCtrl.__init__(self, parent, id_, pos, size, wx.NO_BORDER, name=name)
    self.InheritAttributes()

    self._bmp = dict(enable=bmp)
    self._margin = button_margin
    if bmp is not None :
      img = bmp.ConvertToImage()
      #img = img.ConvertToGreyscale(.795, .073, .026)
      wx.lib.imageutils.grayOut(img)
      self._bmp['disable'] = img.ConvertToBitmap()
    else :
      self._bmp['disable'] = None
    self._bmp2 = bmp2
    self._use_secondary_bitmap = False
    self._label2_font = self.GetFont()
    self._label2_font.SetPointSize(caption_size)
    # XXX this crashes on wxOSX_Cocoa!
    if (not 'wxOSX-cocoa' in wx.PlatformInfo):
      self._label2_font.SetStyle(wx.FONTSTYLE_ITALIC)
      # with wx4c.set_font_style(wx.FONTSTYLE_ITALIC) as fs:
      #   self._label2_font.SetStyle(fs)
    font_size = label_size
    self._label_font = self.GetFont()
    self._label_font.SetPointSize(label_size)
    if style & MB_STYLE_BOLD_LABEL :
      self._label_font.SetWeight(wx.FONTWEIGHT_BOLD)
      # with wx4c.set_font_weight(wx.FONTWEIGHT_BOLD) as fw:
      #   self._label2_font.SetWeight(fw)
    self.SetFont(self._label_font)
    #self._label2_font = wx.Font(caption_size, wx.SWISS, wx.ITALIC, wx.NORMAL)

    self._menu = None
    self.SetLabel(label)
    self._label2 = label2
    self._style = style
    #self._size = tuple(size)
    self._state = dict(pre=GRADIENT_NORMAL, cur=GRADIENT_NORMAL)
    self._color = self.__InitColors(start_color, highlight_color,
      gradient_percent)
    self._caption_lines = None
    self._disable_after_click = disable_after_click

    # Setup Initial Size
    self.SetInitialSize(size)

    # Event Handlers
    self.Bind(wx.EVT_PAINT, self.OnPaint)
    self.Bind(wx.EVT_ERASE_BACKGROUND, self.OnErase)
    self.Bind(wx.EVT_SET_FOCUS, self.OnFocus)
    self.Bind(wx.EVT_KILL_FOCUS, self.OnKillFocus)

    # Mouse Events
    self.Bind(wx.EVT_LEFT_DOWN, self.OnLeftDown)
    self.Bind(wx.EVT_LEFT_UP, self.OnLeftUp)
    self.Bind(wx.EVT_LEFT_DCLICK, self.OnDoubleClick)
    self.Bind(wx.EVT_ENTER_WINDOW, self.OnEnter)
    self.Bind(wx.EVT_LEAVE_WINDOW, self.OnLeave)

    # Other events
    self.Bind(wx.EVT_KEY_UP, self.OnKeyUp)
    self.Bind(wx.EVT_CONTEXT_MENU, self.OnContextMenu)

  def OnPaint(self, event):
    self.__DrawButton()

  def __DrawBitmap(self, gc):
    """Draw the bitmap if one has been set
    @param gc: GCDC to draw with
    @return: x cordinate to draw text at

    """
    bmp = None
    if (self._use_secondary_bitmap):
      assert (self._bmp2 is not None)
      bmp = self._bmp2
    elif self.IsEnabled():
      bmp = self._bmp['enable']
    else:
      bmp = self._bmp['disable']

    if bmp is not None and bmp.IsOk():
      bw, bh = bmp.GetSize()
      cw, ch = self.GetSize()
      if ch > (bh + 4) : # (self._margin * 2)):
        ypos = int(((ch - bh) / 2) - (self._margin / 2) + 1)
        xpos = int(self._margin + 2)
      else :
        ypos = 0
        xpos = 0
      gc.DrawBitmap(bmp, xpos, ypos, useMask=bmp.GetMask() != None)
      return bw + 6
    else:
      return 6

  def __DrawDropArrow(self, gc, xpos, ypos):
    """Draw a drop arrow if needed and restore pen/brush after finished
    @param gc: GCDC to draw with
    @param xpos: x cord to start at
    @param ypos: y cord to start at

    """
    if self._menu is not None or self._style & MB_STYLE_DROPARROW:
      # Positioning needs a little help on Windows
      if wx.Platform == '__WXMSW__':
        xpos -= 2
      tripoints = [(xpos, ypos), (xpos + 6, ypos), (xpos + 3, ypos + 5)]
      brush_b = gc.GetBrush()
      pen_b = gc.GetPen()
      gc.SetPen(wx.TRANSPARENT_PEN)
      gc.SetBrush(wx.Brush(gc.GetTextForeground()))
      gc.DrawPolygon(tripoints)
      gc.SetBrush(brush_b)
      gc.SetPen(pen_b)
    else:
      pass

  def __DrawHighlight(self, gc, width, height):
    """Draw the main highlight/pressed state
    @param gc: GCDC to draw with
    @param width: width of highlight
    @param height: height of highlight

    """
    if self._state['cur'] == GRADIENT_PRESSED:
      color = self._color['press_start']
      end_color = self._color['press_end']
    else:
      color = self._color['hlight_start']
      end_color = self._color['hlight_end']

    rad = 0

    gc.SetBrush(wx.TRANSPARENT_BRUSH)
    rgc = gc.GetGraphicsContext()
    brush = rgc.CreateLinearGradientBrush(0, 1, 0, height, color, end_color)
    rgc.SetBrush(brush)
    gc.DrawRectangle(1, 1, width-2, height-2)

  def __DrawCaption(self, gc, xpos, ypos):
    if self._label2 != '' :
      gc.SetFont(self._label2_font)
      min_w, min_h = self.GetSize() #self._size
      if min_w == -1 :
        min_w = 120
      txt_w = min_w - xpos - 10
      if False : #self._caption_lines is not None :
        lines = self._caption_lines
      else :
        if (wx.Platform in ['__WXGTK__', '__WXMSW__']):
          dc = wx.ClientDC(self)
          dc.SetFont(self._label2_font)
          #txt_w += 100
        else :
          dc = gc
        lines = wx.lib.wordwrap.wordwrap(self._label2,
          width=txt_w,
          dc=dc) #wx.MemoryDC())
      offset = 0
      for line in lines.splitlines():
        line_w, line_h = gc.GetTextExtent(line)
        gc.DrawText(line.rstrip(), xpos, ypos + offset)
        offset += line_h + 2

  def __PostEvent(self):
    """Post a button event to parent of this control"""
    bevt = wx.CommandEvent(wx.wxEVT_COMMAND_BUTTON_CLICKED, self.GetId())
    bevt.SetEventObject(self)
    bevt.SetString(self.GetLabel())
    wx.PostEvent(self.GetParent(), bevt)

  def __DrawButton(self):
    """Draw the button"""
    dc = wx.AutoBufferedPaintDCFactory(self)
    gc = wx.GCDC(dc)

    # Setup
    dc.SetBrush(wx.WHITE_BRUSH)
    gc.SetBrush(wx.WHITE_BRUSH)
    gc.SetFont(self.GetFont())
    #gc.SetBackgroundMode(wx.TRANSPARENT)

    # Calc Object Positions
    width, height = self.GetSize()
    #get text dimensions from dc rather than gc as gc reports wrong height for empty strings on Windows
    tw, th = dc.GetTextExtent(self.GetLabel())
    if self._label2 != '' :
      txt_y = 4 #th + 4 #height - th - 4
      txt2_y = th + 8
    else :
      txt_y = max((height - th) / 2 - 1, 1)
      txt2_y = None
    #print height, th, txt_y, txt2_y
    #gc.SetBrush(wx.TRANSPARENT_BRUSH)
    #gc.DrawRectangle(0, 0, width, height)
    gc.SetPen(wx.Pen((100,100,100)))
    gc.SetBrush(wx.Brush((240,240,240)))
    gc.DrawRectangle(0,0,width,height)
    gc.SetPen(wx.TRANSPARENT_PEN)

    if self._state['cur'] == GRADIENT_HIGHLIGHT:
      gc.SetTextForeground(self._color['htxt'])
      self.__DrawHighlight(gc, width, height)

    elif self._state['cur'] == GRADIENT_PRESSED:
      gc.SetTextForeground(self._color['htxt'])
      if wx.Platform == '__WXMAC__':
        brush = wx.Brush((100,100,100))
        if CarbonAppearance:
          brush.MacSetTheme(CarbonAppearance.kThemeBrushFocusHighlight)
        with wx4c.set_pen_style(wx.PENSTYLE_SOLID) as pstyle:
          pen = wx.Pen(brush.GetColour(), 1, pstyle)
      else:
        pen = wx.Pen(AdjustColour(self._color['press_start'], -80, 220), 1)
      #gc.SetPen(pen)

      self.__DrawHighlight(gc, width, height)
      txt_x = self.__DrawBitmap(gc)
      gc.DrawText(self.GetLabel(), int(txt_x + 2), int(txt_y))
      self.__DrawCaption(gc, txt_x + 2, txt2_y)
      self.__DrawDropArrow(gc, width - 10, (height / 2) - 2)

    else:
      rgc = gc.GetGraphicsContext()
      #gc.SetPen(wx.TRANSPARENT_PEN)
      color =  wx.Colour(218,218,218)
      brush = rgc.CreateLinearGradientBrush(0, 1, 0, height,
        self._color['gradient_start'], self._color['gradient_end'])
      rgc.SetBrush(brush)
      gc.DrawRectangle(1, 2, width-2, height-3)
      if self.IsEnabled():
        gc.SetTextForeground(self.GetForegroundColour())
      else:
        txt_c = wx.SystemSettings.GetColour(wx.SYS_COLOUR_GRAYTEXT)
        gc.SetTextForeground(txt_c)

    # Draw bitmap and text
    if self._state['cur'] != GRADIENT_PRESSED:
      txt_x = self.__DrawBitmap(gc)
      gc.DrawText(self.GetLabel(), int(txt_x + 2), int(txt_y))
      self.__DrawCaption(gc, txt_x + 2, txt2_y)
      #self.__DrawDropArrow(gc, txt_x + tw + 6, (height / 2) - 2)

  def __InitColors(self, start_color, highlight_color, gradient_percent):
    """Initialize the default colors"""
    start_color = wx.Colour(*start_color)
    start_hcolor = wx.Colour(*highlight_color) #GetHighlightColour()
    start_pcolor = AdjustColour(start_hcolor, -12)
    if gradient_percent != 0 :
      end_color = AdjustColour(start_color, gradient_percent)
      end_hcolor = AdjustColour(start_hcolor, gradient_percent)
      end_pcolor = AdjustColour(start_pcolor, gradient_percent)
    else :
      end_color = start_color
      end_hcolor = start_hcolor
      end_pcolor = start_pcolor
    colors = dict(default=True,
                  gradient_start=start_color,
                  gradient_end=end_color,
                  hlight_start=start_hcolor,
                  hlight_end=end_hcolor,
                  press_start=start_pcolor,
                  press_end=end_pcolor,
                  htxt=wx.Colour(0,0,0))
    # BestLabelColour(self.GetForegroundColour()))
    return colors

  #---- End Private Member Function ----#

  #---- Public Member Functions ----#
  def AcceptsFocus(self):
    """Can this window have the focus?"""
    return self.IsEnabled()

  @property
  def BitmapDisabled(self):
    """Property for accessing the bitmap for the disabled state"""
    return self._bmp['disable']

  @property
  def BitmapLabel(self):
    """Property for accessing the default bitmap"""
    return self._bmp['enable']

  # Aliases
  BitmapFocus = BitmapLabel
  BitmapHover = BitmapLabel
  BitmapSelected = BitmapLabel

  def Disable(self):
    """Disable the control"""
    WxCtrl.Disable(self)
    self.Refresh()

  def DoGetBestSize(self):
    """Calculate the best size of the button
    @return: wx.Size

    """
    width = 8
    height = 10
    label_width = 0
    label_height = 0
    caption_width = 0
    caption_height = 0
    if self._bmp['enable'] is not None:
      bsize = self._bmp['enable'].GetSize()
      width += (bsize[0] + 12)
      height = bsize[1] + (self._margin * 2)
    else:
      width += 10

    if self.GetLabel():
      lsize = self.GetTextExtent(self.GetLabel())
      label_width = lsize[0]
      label_height = lsize[1]

    if self._label2 != '' :
      if wx.Platform == '__WXMAC__' :
        with wx4c.create_measuring_context() as context:
          dc = context
          gfont = dc.CreateFont(self._label2_font, self.GetForegroundColour())
      else :
        dc = wx.ClientDC(self)
        gfont = self._label2_font
        #dc = wx.MemoryDC()
      dc.SetFont(gfont)
      min_w, min_h = self.GetSize() #self._size
      if min_w == -1 :
        min_w = 120
      txt_w = min_w - width - 10
      if wx.Platform == '__WXGTK__' :
        txt_w += 40
      lines = wx.lib.wordwrap.wordwrap(self._label2,
        width=txt_w,
        dc=dc)
      self._caption_lines = lines
      offset = 0
      if wx.Platform == "__WXMAC__" :
        buffer = 4
      else :
        buffer = 0
      for line in lines.splitlines():
        line_w, line_h = dc.GetTextExtent(line)
        if line_w > caption_width :
          caption_width = line_w
        caption_height += line_h + buffer
      if (wx.Platform == '__WXMSW__'):
        caption_height += 4
    width += max(caption_width, label_width) + 4
    height = max(caption_height + label_height + 12, height)

    if self._menu is not None or self._style & MB_STYLE_DROPARROW :
       width += 12

    if width < self.GetSize()[0] : #self._size[0] :
      width = self.GetSize()[0]
    best = wx.Size(int(width), int(height))
    self.CacheBestSize(best)
    return best

  def Enable(self, enable=True):
    """Enable/Disable the control"""
    WxCtrl.Enable(self, enable)
    self.Refresh()

  def GetBackgroundBrush(self, dc):
    """Get the brush for drawing the background of the button
    @return: wx.Brush
    @note: used internally when on gtk

    """
    if wx.Platform == '__WXMAC__' : #or self._style & PB_STYLE_NOBG:
      return wx.TRANSPARENT_BRUSH

    bkgrd = self.GetBackgroundColour()
    with wx4c.set_brush_style(wx.BRUSHSTYLE_SOLID) as bstyle:
        brush = wx.Brush(bkgrd, bstyle)
    my_attr = self.GetDefaultAttributes()
    p_attr = self.GetParent().GetDefaultAttributes()
    my_def = bkgrd == my_attr.colBg
    p_def = self.GetParent().GetBackgroundColour() == p_attr.colBg
    if my_def and not p_def:
      bkgrd = self.GetParent().GetBackgroundColour()
      with wx4c.set_brush_style(wx.BRUSHSTYLE_SOLID) as bstyle:
        brush = wx.Brush(bkgrd, bstyle)
    return brush

  def GetBitmapDisabled(self):
    """Get the bitmap of the disable state
    @return: wx.Bitmap or None

    """
    return self._bmp['disable']

  def GetBitmapLabel(self):
    """Get the label bitmap
    @return: wx.Bitmap or None

    """
    return self._bmp['enable']

  # GetBitmap Aliases for BitmapButton api
  GetBitmapFocus = GetBitmapLabel
  GetBitmapHover = GetBitmapLabel

  # Alias for GetLabel
  GetLabelText = WxCtrl.GetLabel

  def GetMenu(self):
    """Return the menu associated with this button or None if no
    menu is associated with it.

    """
    return getattr(self, '_menu', None)

  def HasTransparentBackground(self):
    """Override setting of background fill"""
    return True

  @property
  def LabelText(self):
    """Property for getting the label of the button"""
    return self.GetLabel()

  #---- Event Handlers ----#

  def OnErase(self, evt):
    """Trap the erase event to keep the background transparent
    on windows.
    @param evt: wx.EVT_ERASE_BACKGROUND

    """
    pass

  def OnFocus(self, evt):
    """Set the visual focus state if need be"""
    if not self.IsEnabled():
      return
    if self._state['cur'] == GRADIENT_NORMAL:
        self.SetState(GRADIENT_HIGHLIGHT)

  def OnKeyUp(self, evt):
    """Execute a single button press action when the Return key is pressed
    and this control has the focus.
    @param evt: wx.EVT_KEY_UP

    """
    if evt.GetKeyCode() == wx.WXK_SPACE:
      self.SetState(GRADIENT_PRESSED)
      self.__PostEvent()
      wx.CallLater(100, self.SetState, GRADIENT_HIGHLIGHT)
    else:
      evt.Skip()

  def OnKillFocus(self, evt):
    """Set the visual state back to normal when focus is lost
    unless the control is currently in a pressed state.

    """
    # Note: this delay needs to be at least as much as the on in the KeyUp
    #       handler to prevent ghost highlighting from happening when
    #       quickly changing focus and activating buttons
    if self._state['cur'] != GRADIENT_PRESSED:
      self.SetState(GRADIENT_NORMAL)
      self.Refresh()

  def OnLeftDown(self, evt):
    """Sets the pressed state and depending on the click position will
    show the popup menu if one has been set.

    """
    if not self.IsEnabled():
      return
    pos = evt.GetPosition()
    self.SetState(GRADIENT_PRESSED)
    size = self.GetSize()
    if pos[0] >= size[0] - 16:
      if self._menu is not None:
        self.ShowMenu()

    self.SetFocus()

  def OnLeftUp(self, evt):
    """Post a button event if the control was previously in a
    pressed state.
    @param evt: wx.MouseEvent

    """
    if not self.IsEnabled():
      return
    if self._state['cur'] == GRADIENT_PRESSED:
      pos = evt.GetPosition()
      size = self.GetSize()
      if self._disable_after_click > 0 :
        self.Enable(False)
      self.__PostEvent()
    self.SetState(GRADIENT_HIGHLIGHT)
    if self._disable_after_click > 0 :
      wx.CallLater(self._disable_after_click, lambda : self.Enable(True))

  def OnMenuClose(self, evt):
    """Refresh the control to a proper state after the menu has been
    dismissed.
    @param evt: wx.EVT_MENU_CLOSE

    """
    mpos = wx.GetMousePosition()
    if self.HitTest(self.ScreenToClient(mpos)) != wx.HT_WINDOW_OUTSIDE:
      self.SetState(GRADIENT_HIGHLIGHT)
    else:
      self.SetState(GRADIENT_NORMAL)
    evt.Skip()

  def OnEnter(self, evt):
    if not self.IsEnabled():
      return
    self.SetState(GRADIENT_HIGHLIGHT)

  def OnLeave(self, evt):
    if not self.IsEnabled():
      return
    self.SetState(GRADIENT_NORMAL)

  def OnDoubleClick(self, evt):
    if not self.IsEnabled():
      return
    self.ToggleState()

  def OnContextMenu(self, evt):
    if not self.IsEnabled():
      return
    self.ShowMenu()

  #---- End Event Handlers ----#

  def SetBitmap(self, bmp):
    """Set the bitmap displayed in the button
    @param bmp: wx.Bitmap

    """
    self._bmp['enable'] = bmp
    img = bmp.ConvertToImage()
    img = img.ConvertToGreyscale(.795, .073, .026) #(.634, .224, .143)
    self._bmp['disable'] = img.ConvertToBitmap()
    self.InvalidateBestSize()

  def SetBitmapDisabled(self, bmp):
    """Set the bitmap for the disabled state
    @param bmp: wx.Bitmap

    """
    self._bmp['disable'] = bmp

  # Aliases for SetBitmap* functions from BitmapButton
  SetBitmapFocus = SetBitmap
  SetBitmapHover = SetBitmap
  SetBitmapLabel = SetBitmap
  SetBitmapSelected = SetBitmap

  def SetFocus(self):
    """Set this control to have the focus"""
    if self._state['cur'] != GRADIENT_PRESSED:
      self.SetState(GRADIENT_HIGHLIGHT)
    WxCtrl.SetFocus(self)

  def SetFont(self, font):
    """Adjust size of control when font changes"""
    WxCtrl.SetFont(self, font)
    self.InvalidateBestSize()

  def SetLabel(self, label):
    """Set the label of the button
    @param label: lable string

    """
    WxCtrl.SetLabel(self, label)
    self.InvalidateBestSize()

  def SetLabelColor(self, normal, hlight=wx.NullColour):
    """Set the color of the label. The optimal label color is usually
    automatically selected depending on the button color. In some
    cases the colors that are choosen may not be optimal.

    The normal state must be specified, if the other two params are left
    Null they will be automatically guessed based on the normal color. To
    prevent this automatic color choices from happening either specify
    a color or None for the other params.

    @param normal: Label color for normal state
    @keyword hlight: Color for when mouse is hovering over

    """
    self._color['default'] = False
    self.SetForegroundColour(normal)

    if hlight is not None:
      if hlight.IsOk():
        self._color['htxt'] = hlight
      else:
        self._color['htxt'] = BestLabelColour(normal)

    if wx.Platform == '__WXMSW__':
      self.GetParent().RefreshRect(self.GetRect(), False)
    else:
      self.Refresh()

  def SetMenu(self, menu):
    """Set the menu that can be shown when clicking on the
    drop arrow of the button.
    @param menu: wxMenu to use as a PopupMenu
    @note: Arrow is not drawn unless a menu is set

    """
    if self._menu is not None:
      self.Unbind(wx.EVT_MENU_CLOSE)

    self._menu = menu
    self.Bind(wx.EVT_MENU_CLOSE, self.OnMenuClose)
    self.InvalidateBestSize()

  def SetPressColor(self, color):
    """Set the color used for highlighting the pressed state
    @param color: wx.Color
    @note: also resets all text colours as necessary

    """
    self._color['default'] = False
    if color.Alpha() == 255:
      self._color['hlight'] = AdjustAlpha(color, 200)
    else:
      self._color['hlight'] = color
    #self._color['press'] = AdjustColour(color, -10, 160)
    self._color['htxt'] = BestLabelColour(self._color['hlight'])
    self.Refresh()

  def SetState(self, state):
    """Manually set the state of the button
    @param state: one of the MB_* values
    @note: the state may be altered by mouse actions

    """
    self._state['pre'] = self._state['cur']
    self._state['cur'] = state
    if wx.Platform == '__WXMSW__':
      self.GetParent().RefreshRect(self.GetRect(), False)
    else:
      self.Refresh()

  def SetWindowStyle(self, style):
    """Sets the window style bytes, the updates take place
    immediately no need to call refresh afterwards.
    @param style: bitmask of PB_STYLE_* values

    """
    self._style = style
    self.Refresh()

  def SetWindowVariant(self, variant):
    """Set the variant/font size of this control"""
    WxCtrl.SetWindowVariant(self, variant)
    self.InvalidateBestSize()

  def ShouldInheritColours(self):
    """Overridden base class virtual. If the parent has non-default
    colours then we want this control to inherit them.

    """
    return True

  def ShowMenu(self):
    """Show the dropdown menu if one is associated with this control"""
    if self._menu is not None:
      size = self.GetSize()
      adj = wx.Platform == '__WXMAC__' and 3 or 0

      xpos = 1
      self.PopupMenu(self._menu, (xpos, size[1] + adj))

  def ToggleState(self):
    """Toggle button state"""
    if self._state['cur'] != GRADIENT_PRESSED:
      self.SetState(GRADIENT_PRESSED)
    else:
      self.SetState(GRADIENT_HIGHLIGHT)

  def SwapBitmap(self):
    assert (self._bmp2 is not None)
    if (self._use_secondary_bitmap):
      self._use_secondary_bitmap = False
    else :
      self._use_secondary_bitmap = True

if __name__ == "__main__" :
  from wx.lib.embeddedimage import PyEmbeddedImage
  folder_home = PyEmbeddedImage(
    "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"
    "9vloG3iG4j+/GQJ2mLhyHwAAAABJRU5ErkJggg==")
  getfolder_homeData = folder_home.GetData
  getfolder_homeImage = folder_home.GetImage
  getfolder_homeBitmap = folder_home.GetBitmap

  app = wx.App(0)
  frame = wx.Frame(None, -1, "Test frame", style=wx.DEFAULT_FRAME_STYLE)
  frame_sizer = wx.BoxSizer(wx.VERTICAL)
  frame.SetSizer(frame_sizer)
  panel = wx.Panel(frame, -1)
  frame_sizer.Add(panel)
  panel_sizer = wx.BoxSizer(wx.VERTICAL)
  panel.SetSizer(panel_sizer)
  btn1 = MetallicButton(
    parent=panel,
    label="Simple button",
    button_margin=4)
  panel_sizer.Add(btn1, 0, wx.ALL|wx.EXPAND, 10)
  btn2 = MetallicButton(
    parent=panel,
    label="Button with bitmap",
    bmp=folder_home.GetBitmap(),
    button_margin=4)
  panel_sizer.Add(btn2, 0, wx.ALL|wx.EXPAND, 10)
  btn3 = MetallicButton(
    parent=panel,
    label="Disabled button",
    bmp=folder_home.GetBitmap(),
    button_margin=4)
  btn3.Enable(False)
  panel_sizer.Add(btn3, 0, wx.ALL|wx.EXPAND, 10)
  btn4 = MetallicButton(
    parent=panel,
    style=MB_STYLE_BOLD_LABEL,
    label="Button with bitmap and BOLD caption",
    label2="This is the button caption that I can't figure out how to wrap "+
      "properly on any platform (but especially Linux!).",
    bmp=folder_home.GetBitmap(),
    button_margin=4,
    size=(320,-1))
  panel_sizer.Add(btn4, 0, wx.ALL|wx.EXPAND, 10)
  panel_sizer.Fit(panel)
  #frame_sizer.Fit(frame)
  frame.Fit()
  frame.Show()
  app.MainLoop()


 *******************************************************************************


 *******************************************************************************
wxtbx/misc_dialogs.py

"""
Various convenience dialogs (and associated wrapper functions).
"""

from __future__ import absolute_import, division, print_function
from wxtbx.utils import add_ok_cancel_buttons
import wx
from libtbx.utils import Abort
import os.path

class ChoiceDialog(wx.Dialog):
  """
  Dialog containing a single wx.Choice control.  Optionally includes a button
  to flag the selected action as the default for future choices.
  """
  def __init__(self, title, message, choices,
      parent=None,
      choiceLabel=None,
      defaultChoice=-1,
      captionImage=None,
      showDefaultButton=False):
    super(ChoiceDialog, self).__init__(
      parent=parent,
      title=title)
    outer_sizer = wx.BoxSizer(wx.VERTICAL)
    self.SetSizer(outer_sizer)
    szr = wx.BoxSizer(wx.VERTICAL)
    outer_sizer.Add(szr, 1, wx.EXPAND|wx.ALL, 5)
    if (captionImage is not None):
      assert 0
    else :
      caption = wx.StaticText(parent=self, label=message)
      caption.Wrap(480)
      szr.Add(caption, 0, wx.ALL|wx.ALIGN_CENTER_VERTICAL, 5)
    choice_box = wx.BoxSizer(wx.HORIZONTAL)
    szr.Add(choice_box)
    if (choiceLabel is not None):
      label = wx.StaticText(parent=self, label=choiceLabel)
      choice_box.Add(label, 0, wx.ALL|wx.ALIGN_CENTER_VERTICAL, 5)
    self.chooser = wx.Choice(parent=self, choices=choices)
    self.chooser.SetMinSize((200,-1))
    choice_box.Add(self.chooser, 0, wx.ALL|wx.ALIGN_CENTER_VERTICAL, 5)
    if (defaultChoice >= 0):
      self.chooser.SetSelection(defaultChoice)
    self.default_btn = None
    if (showDefaultButton):
      self.default_btn = wx.CheckBox(parent=self,
        label="Always do this in the future")
      szr.Add(self.default_btn, 0, wx.ALL|wx.ALIGN_CENTER_VERTICAL, 5)
    add_ok_cancel_buttons(self, szr)
    self.Centre(wx.BOTH)
    outer_sizer.Fit(self)

  def GetChoice(self):
    return self.chooser.GetSelection()

  def GetChoiceString(self):
    return self.chooser.GetStringSelection()

  def GetDefault(self):
    if (self.default_button is not None):
      return self.default_button.GetValue()
    return None

def ChoiceSelector(
    title,
    message,
    choices,
    parent=None,
    choiceLabel=None,
    defaultChoice=0,
    captionImage=None):
  """
  Convenience method for ChoiceDialog (minus default checkbox).  Returns the
  selected string value.
  """
  dlg = ChoiceDialog(
    parent=parent,
    title=title,
    message=message,
    choices=choices,
    defaultChoice=defaultChoice,
    choiceLabel=choiceLabel,
    captionImage=captionImage)
  choice = None
  if (dlg.ShowModal() == wx.ID_OK):
    choice = dlg.GetChoiceString()
  wx.CallAfter(dlg.Destroy)
  if (choice is None):
    raise Abort()
  return choice

def get_shelx_file_data_type(file_name):
  data_type = ChoiceSelector(
    title="SHELX reflection file input",
    message=("The data in this SHELX-format file (%s) may be "+
      "either amplitudes or intensities.  If you know what the data type "+
      "should be, please select from the list below and click 'Okay'.") %
      os.path.basename(file_name),
    choices=["unknown", "amplitudes", "intensities"],
    choiceLabel="Experimental data type:")
  if (data_type == "unknown"):
    data_type = None
  return data_type

if (__name__ == "__main__"):
  app = wx.App(0)
  print(get_shelx_file_data_type("data.hkl"))


 *******************************************************************************


 *******************************************************************************
wxtbx/monitor.py
from __future__ import absolute_import, division, print_function

import wxtbx.bitmaps
from wxtbx import metallicbutton
from wx.lib.agw import flatnotebook as fnb
import wx

class StatusPanel(wx.Panel):
  def __init__(self, *args, **kwds):
    wx.Panel.__init__(self, *args, **kwds)
    self.sizer = wx.BoxSizer(wx.VERTICAL)
    self.SetSizer(self.sizer)
    self.content_sizer = wx.BoxSizer(wx.VERTICAL)
    self._errors = []
    self._btns = {}
    self._current_status = None
    self._status_warn = False
    self._std_font = wx.Font(9, wx.FONTFAMILY_DEFAULT, wx.NORMAL,wx.NORMAL)
    self._warn_font = wx.Font(9, wx.FONTFAMILY_DEFAULT, wx.NORMAL, wx.BOLD)
    self._btn_font = wx.Font(10, wx.FONTFAMILY_DEFAULT, wx.NORMAL,wx.NORMAL)
    self.btn_sizer = wx.BoxSizer(wx.HORIZONTAL)
    self.sizer.Add(self.btn_sizer)
    s2 = wx.BoxSizer(wx.HORIZONTAL)
    self.sizer.Add(s2)
    status_label = wx.StaticText(self, -1, "Status:")
    status_label.SetFont(self._warn_font)
    s2.Add(status_label, 0, wx.TOP|wx.LEFT|wx.RIGHT|wx.ALIGN_LEFT, 5)
    self.status = wx.StaticText(self, -1, "N/A")
    self.status.SetFont(self._std_font)
    s2.Add(self.status, 0, wx.TOP|wx.LEFT|wx.RIGHT|wx.ALIGN_LEFT, 5)
    self.sizer.Add(self.content_sizer)

  def AddActionButton(self, label, icon=None):
    bmp = None
    if (icon is not None):
      bmp = wxtbx.bitmaps.fetch_icon_bitmap("actions", icon, 16)
    btn = metallicbutton.MetallicButton(
      parent=self,
      label=label,
      bmp=bmp,
      highlight_color=(200,220,240))
    btn.SetFont(self._std_font)
    if (len(self._btns) == 0):
      self.btn_sizer.Add((5,1))
    self.btn_sizer.Add(btn, 0, wx.TOP|wx.RIGHT|wx.ALIGN_LEFT, 5)
    self._btns[label] = btn
    return btn

  def GetButton(self, label):
    return self._btns.get(label, None)

  def CreateErrorBox(self):
    error_txt = wx.StaticText(self, -1, "Errors:")
    error_txt.SetFont(wx.Font(9, wx.FONTFAMILY_DEFAULT, wx.NORMAL, wx.BOLD))
    self.sizer.Add(error_txt, 0, wx.TOP|wx.LEFT|wx.RIGHT|wx.ALIGN_LEFT, 5)
    self.errors = wx.TextCtrl(self, -1, size=(400,120),
      style=wx.TE_MULTILINE|wx.TE_READONLY|wx.NO_BORDER)
    self.errors.SetFont(wx.Font(9, wx.MODERN, wx.NORMAL, wx.NORMAL))
    self.sizer.Add(self.errors, 1, wx.ALL|wx.EXPAND|wx.ALIGN_LEFT, 5)

  def UpdateErrors(self, errors):
    if (len(self._errors) != len(errors)):
      self.errors.SetValue("\n".join(errors))

  def UpdateStatus(self, status, warn=False):
    if (self._current_status != status):
      self.status.SetLabel(status)
      if (warn != self._status_warn):
        self._status_warn = warn
        if warn :
          self.status.SetFont(self._warn_font)
          self.status.SetForegroundColour((200,0,0))
        else :
          self.status.SetFont(self._std_font)
          self.status.SetForegroundColour((0,0,0))
      self.sizer.Layout()

class MonitorWindow(wx.MiniFrame):
  def __init__(self, *args, **kwds):
    wx.MiniFrame.__init__(self, *args, **kwds)
    #self.panel = wx.Panel(self)
    self.nb = fnb.FlatNotebook(
      parent=self,
      agwStyle=fnb.FNB_FF2|fnb.FNB_NO_NAV_BUTTONS|fnb.FNB_NO_X_BUTTON|fnb.FNB_NODRAG)
    self.sizer = wx.BoxSizer(wx.VERTICAL)
    self.sizer.Add(self.nb, 1)
    self.SetSizer(self.sizer)
    #self.panel_sizer = wx.BoxSizer(wx.VERTICAL)
    #self.panel.SetSizer(self.panel_sizer)
    self._panels = {}
    self._errors = {}
    self.timer = None
    self.Bind(wx.EVT_CLOSE, self.OnClose)
    self.Bind(wx.EVT_WINDOW_DESTROY, self.OnDestroy)

  def AddPanel(self, title, panel_name):
    p = StatusPanel(self.nb, -1, style=wx.NO_BORDER)
    p.CreateErrorBox()
    self._panels[panel_name] = p
    self.nb.AddPage(p, title)

  def GetPanel(self, panel_name):
    return self._panels[panel_name]

  def UpdateStatus(self, panel_name, status, errors, warn=False):
    p = self._panels[panel_name]
    p.UpdateErrors(errors)
    p.UpdateStatus(status, warn=warn)
    self.Refresh()

  def OnClose(self, event):
    if (self.timer is not None):
      self.timer.Stop()
    self.Destroy()

  def OnDestroy(self, event) : # XXX override this in subclasses
    pass

  def OnTimer(self, event):
    pass

  def StartTimer(self, wait=30):
    self.timer = wx.Timer(owner=self)
    self.Bind(wx.EVT_TIMER, self.OnTimer)
    self.timer.Start(wait * 1000)

if (__name__ == "__main__"):
  app = wx.App(0)
  f = MonitorWindow(None, -1, "Test monitor window",
    style=wx.CAPTION|wx.CLOSE_BOX)
  f.AddPanel("Coot", "coot")
  f.GetPanel("coot").AddActionButton("Quit", "stop")
  #f.GetPanel("coot").
  f.AddPanel("PyMOL", "pymol")
  f.Fit()
  f.Show()
  f.UpdateStatus("coot", status="7 socket timeouts",
    errors=["12:14:01 :: connection refused",
            "12:14:04 :: broken pipe",
            "12:14:05 :: broken pipe",],
    warn=True)
  f.UpdateStatus("pymol", status="running",
    errors=[],
    warn=False)
  app.MainLoop()


 *******************************************************************************


 *******************************************************************************
wxtbx/mtz_dump.py

from __future__ import absolute_import, division, print_function
import wxtbx.app
from libtbx.utils import Sorry
import wx
import sys

columns = [ "Order", "Label", "#valid", "%valid", "min", "max", "type", ]
column_widths = [ 60, 100, 80, 80, 100, 100, 100 ]

aln_flags = wx.ALL|wx.ALIGN_CENTER_VERTICAL

class MtzInspectionFrame(wx.Frame):
  def __init__(self, *args, **kwds):
    wx.Frame.__init__(self, *args, **kwds)
    self.sizer = wx.BoxSizer(wx.VERTICAL)
    self.SetSizer(self.sizer)
    self.panel = MtzContentsPanel(self)
    self.sizer.Add(self.panel, 1, wx.ALL|wx.EXPAND, 0)
    self.sizer.Fit(self.panel)
    self.Fit()

  def SetMtzFile(self, *args, **kwds):
    self.panel.SetMtzFile(*args, **kwds)
    self.sizer.Fit(self.panel)
    self.Fit()

  def OnOpen(self, event):
    from wxtbx import path_dialogs
    file_name = path_dialogs.manager().select_file(
      parent=self,
      message="Choose an MTZ file to view",
      wildcard="MTZ files (*.mtz)|*.mtz")
    if (file_name is not None):
      self.SetMtzFile(file_name)

class MtzContentsPanel(wx.Panel):
  def __init__(self, *args, **kwds):
    wx.Panel.__init__(self, *args, **kwds)
    self.sizer = wx.BoxSizer(wx.VERTICAL)
    self.SetSizer(self.sizer)
    grid1 = wx.FlexGridSizer(cols=2)
    lbl1 = wx.StaticText(self, label="Title:")
    self.title_txt = wx.StaticText(self, label="", size=(300,-1))
    lbl2 = wx.StaticText(self, label="Space group:")
    self.sg_txt = wx.StaticText(self, label="", size=(300,-1))
    lbl3 = wx.StaticText(self, label="Resolution:")
    self.d_max_min_txt = wx.StaticText(self, label="", size=(300,-1))
    lbl4 = wx.StaticText(self, label="Select dataset:")
    self.dataset_chooser = wx.Choice(self, size=(400,-1))
    self.Bind(wx.EVT_CHOICE, self.OnChooseDataset, self.dataset_chooser)
    grid1.Add(lbl1, 0, aln_flags, 5)
    grid1.Add(self.title_txt, 0, aln_flags, 5)
    grid1.Add(lbl2, 0, aln_flags, 5)
    grid1.Add(self.sg_txt, 0, aln_flags, 5)
    grid1.Add(lbl3, 0, aln_flags, 5)
    grid1.Add(self.d_max_min_txt, 0, aln_flags, 5)
    grid1.Add(lbl4, 0, aln_flags, 5)
    grid1.Add(self.dataset_chooser, 0, aln_flags, 5)
    self.sizer.Add(grid1, 0, wx.ALL|wx.EXPAND)
    self._dataset_panels = []
    self._crystals_and_datasets = []
    self._dataset_labels = []
    self._mtz_obj = None

  def SetMtzFile(self, file_name):
    from iotbx import mtz
    try :
      self._mtz_obj = mtz.object(file_name=file_name)
    except RuntimeError as e :
      raise Sorry(("The file '%s' could not be read as an MTZ file "+
        "(original error: %s)") % (file_name, str(e)))
    self.title_txt.SetLabel(self._mtz_obj.title())
    self.sg_txt.SetLabel(str(self._mtz_obj.space_group_name()))
    self.d_max_min_txt.SetLabel("%g - %g Angstrom" %
      self._mtz_obj.max_min_resolution())
    self._dataset_labels = []
    self._crystals_and_datasets = []
    for i_crystal, crystal in enumerate(self._mtz_obj.crystals()):
      if (crystal.name() == "HKL_base"):
        continue
      for i_dataset, dataset in enumerate(crystal.datasets()):
        label = "/%s/%s" % (crystal.name(), dataset.name())
        self._crystals_and_datasets.append((crystal, dataset))
        self._dataset_labels.append(label)
    self.dataset_chooser.SetItems(self._dataset_labels)
    p = MtzDatasetPanel(self, style=wx.RAISED_BORDER)
    self._dataset_panels.append(p)
    self.sizer.Add(p, 1, wx.ALL|wx.EXPAND, 0)
    if (len(self._dataset_labels) > 0):
      self.dataset_chooser.SetSelection(0)
      self.OnChooseDataset(None)

  def OnChooseDataset(self, event):
    if (len(self._dataset_panels) == 0) : return
    sel = self.dataset_chooser.GetSelection()
    crystal, dataset = self._crystals_and_datasets[sel]
    p = self._dataset_panels[0]
    p.SetMtzDataset(
      crystal=crystal,
      dataset=dataset,
      n_refl=self._mtz_obj.n_reflections())
    self.Layout()
    self.sizer.Fit(self)
    self.Fit()

class MtzDatasetPanel(wx.Panel):
  def __init__(self, *args, **kwds):
    wx.Panel.__init__(self, *args, **kwds)
    self.sizer = wx.BoxSizer(wx.VERTICAL)
    self.SetSizer(self.sizer)
    grid = wx.FlexGridSizer(cols=2)
    lbl1 = wx.StaticText(self, label="Unit cell:")
    self.uc_txt = wx.StaticText(self, label="", size=(300,-1))
    lbl2 = wx.StaticText(self, label="Wavelength:")
    self.wl_txt = wx.StaticText(self, label="", size=(300,-1))
    grid.Add(lbl1, 0, aln_flags, 5)
    grid.Add(self.uc_txt, 0, aln_flags, 5)
    grid.Add(lbl2, 0, aln_flags, 5)
    grid.Add(self.wl_txt, 0, aln_flags, 5)
    self.sizer.Add(grid, 0, wx.ALL|wx.EXPAND)
    self.lc = MtzColumnList(self, -1, size=(720,240), style=wx.LC_REPORT)
    self.sizer.Add(self.lc, 1, wx.ALL|wx.EXPAND, 5)
    #self.sizer.Fit(self)
    self.Fit()

  def SetMtzDataset(self, crystal, dataset, n_refl):
    self.lc.DeleteAllItems()
    self.lc.SetNReflections(n_refl)
    self.uc_txt.SetLabel("%g %g %g %g %g %g" % crystal.unit_cell().parameters())
    self.wl_txt.SetLabel("%g" % dataset.wavelength())
    self.lc.AddMtzDataset(dataset)
    self.Layout()
    self.Refresh()

class MtzColumnList(wx.ListCtrl):
  def __init__(self, *args, **kwds):
    style = kwds.get('style', 0)
    if (not style & wx.LC_REPORT):
      style &= wx.LC_REPORT
    kwds['style'] = style
    wx.ListCtrl.__init__(self, *args, **kwds)
    self.n_refl = None
    for i, label in enumerate(columns):
      self.InsertColumn(i, label)
      self.SetColumnWidth(i, column_widths[i])

  def SetNReflections(self, n_refl):
    self.n_refl = n_refl

  def AddMtzColumn(self, fields):
    assert (len(fields) == len(columns))
    n = self.GetItemCount() + 1
    item = self.InsertStringItem(sys.maxunicode, str(n))
    for i, field in enumerate(fields[:-2]):
      self.SetStringItem(item, i+1, field)
    self.SetStringItem(item, len(fields)-1, "%s %s" % (fields[-2], fields[-1]))

  def AddMtzDataset(self, dataset):
    assert (self.n_refl is not None)
    for i_col, column in enumerate(dataset.columns()):
      fields = column.format_fields_for_mtz_dump(self.n_refl)
      self.AddMtzColumn(fields)

if (__name__ == "__main__"):
  app = wxtbx.app.CCTBXApp(0)
  frame = MtzInspectionFrame(None, title="Inspect MTZ file contents")
  if (len(sys.argv) == 0):
    frame.OnOpen(None)
  else :
    frame.SetMtzFile(sys.argv[1])
  frame.Show()
  app.MainLoop()


 *******************************************************************************


 *******************************************************************************
wxtbx/path_dialogs.py

from __future__ import absolute_import, division, print_function
from wxtbx.utils import add_ok_cancel_buttons, std_sizer_flags
from wxtbx.phil_controls import choice_multi, path
import wx
from libtbx.utils import Abort, Sorry, to_unicode
import libtbx.path
import os.path
from six.moves import zip

class manager(object):
  """
  Because wxPython is inconsistent (if not outright buggy on some platforms)
  in its selection of the starting directory for the file/folder dialogs,
  this manager remembers where it was last opened.  This is not the same as
  using the wx.FD_CHANGE_DIR flag, which actually changes the working
  directory.  Instead, a manager can be associated with a specific window (or
  group of windows), so that any changes in path are localized.
  """
  def __init__(self, start_dir=None):
    if (start_dir is None):
      start_dir = os.getcwd()
    assert os.path.isdir(start_dir), start_dir
    self.start_dir = start_dir
    self.last_dir = start_dir

  def reset_dir(self):
    self.last_dir = self.start_dir

  def set_current_dir(self, dir_name):
    assert os.path.isdir(dir_name)
    self.last_dir = dir_name

  def select_file(self,
                   parent,
                   message,
                   style=wx.FD_OPEN,
                   wildcard="All files (*.*)|*.*",
                   current_file=None,
                   multiple=False,
                   save=None):
    if (save):
      style = wx.FD_SAVE
    default_dir = self.last_dir
    default_file = ""
    if (current_file is not None) and (current_file != ""):
      if (os.path.isabs(current_file)):
        default_dir, default_file = os.path.split(current_file)
      else :
        default_file = current_file
    default_dir = to_unicode(default_dir)
    default_file = to_unicode(default_file)
    dlg = wx.FileDialog(
      parent=parent,
      message=message,
      defaultDir=default_dir,
      defaultFile=default_file,
      style=style,
      wildcard=wildcard)
    if (dlg.ShowModal() == wx.ID_OK):
      new_path = None
      if (multiple):
        new_path = dlg.GetPaths()
        if (new_path is not None) and (len(new_path) > 0):
          new_dir = os.path.dirname(new_path[0])
          if (os.path.isdir(new_dir)):
            self.last_dir = new_dir
      else :
        new_path = dlg.GetPath()
        if (new_path != ""):
          self.last_dir = os.path.dirname(new_path)
        else :
          new_path = None
      wx.CallAfter(dlg.Destroy)
      return new_path
    else :
      wx.CallAfter(dlg.Destroy)
      raise Abort()

  def select_directory(self,
                        parent,
                        message,
                        current_path,
                        style):
    default_path = self.last_dir
    if (current_path is not None) and (current_path != ""):
      default_path = current_path
    default_path = to_unicode(default_path)
    if wx.version().startswith('3'):
      new_path = wx.DirSelector(
        message=message,
        defaultPath=default_path,
        style=style|wx.DD_NEW_DIR_BUTTON,
        parent=parent)
    else:
      new_path = wx.DirSelector(
        message=message,
        default_path=default_path,
        style=style|wx.DD_NEW_DIR_BUTTON,
        parent=parent)
    if (new_path != ""):
      return new_path
    return None

class DirectoryCleanupDialog(wx.Dialog):
  def __init__(self, *args, **kwds):
    wx.Dialog.__init__(self, *args, **kwds)
    outer_sizer = wx.BoxSizer(wx.VERTICAL)
    self.SetSizer(outer_sizer)
    szr = wx.BoxSizer(wx.VERTICAL)
    outer_sizer.Add(szr, 0, wx.ALL, 5)
    txt = wx.StaticText(self, label="Please select the file and/or directory "+
      "type(s) you want to delete.  You will be prompted to confirm this "+
      "action once a list of targeted paths has been collected.")
    txt.Wrap(500)
    szr.Add(txt, 0, wx.ALL, 5)
    grid = wx.FlexGridSizer(cols=2, rows=2)
    szr.Add(grid, 0, wx.ALL, 5)
    grid.Add(wx.StaticText(self, label="Directory:"), 0, std_sizer_flags, 5)
    self.dir_ctrl = path.PathCtrl(parent=self,
      name="Directory",
      style=path.WXTBX_PHIL_PATH_DIRECTORY|path.WXTBX_PHIL_PATH_DEFAULT_CWD)
    self.dir_ctrl.SetOptional(False)
    grid.Add(self.dir_ctrl, 0, std_sizer_flags, 5)
    grid.Add(wx.StaticText(self, label="Items to remove:"), 0,
      std_sizer_flags, 5)
    self.remove_ctrl = choice_multi.MultiChoiceCtrl(
      parent=self,
      name="Items to remove")
    self.remove_ctrl.SetCols(2)
    items = [ "kin", "geo", "map", "probe", "temp", ]
    labels = [ "Kinemage files (.kin)", "Geometry files (.geo)",
      "Map files (.ccp4, .xplor)", "Probe files (probe.txt)",
      "Temporary folders (TEMP0)", ]
    for choice, label in zip(items, labels):
      self.remove_ctrl.AddChoice("*" + choice, label)
    self.remove_ctrl.Realize()
    grid.Add(self.remove_ctrl, 0, std_sizer_flags, 5)
    add_ok_cancel_buttons(self, szr)
    self.Fit()
    self.Centre(wx.BOTH)

  def SetDirectory(self, dir_name):
    assert os.path.isdir(dir_name)
    self.dir_ctrl.SetValue(dir_name)

  def GetDirectory(self):
    return self.dir_ctrl.GetPhilValue()

  def GetChoices(self):
    return self.remove_ctrl.GetPhilValue()

class ConfirmCleanupDialog(wx.Dialog):
  def __init__(self, parent, cleanup_obj):
    wx.Dialog.__init__(self, parent=parent, title="Confirm delete")
    outer_sizer = wx.BoxSizer(wx.VERTICAL)
    self.SetSizer(outer_sizer)
    szr = wx.BoxSizer(wx.VERTICAL)
    outer_sizer.Add(szr, 0, wx.ALL, 5)
    txt = wx.StaticText(self, label=("%d file(s) and %d directories have "+
      "been found matching the specified criteria; this will save %s of "+
      "disk space.  Their paths are listed below.  Click OK to "+
      "confirm, or Cancel to abort.  You will not be able to recover these "+
      "paths once they have been deleted!") % (cleanup_obj.n_files,
        cleanup_obj.n_dirs, cleanup_obj.get_freed_space()))
    txt.Wrap(480)
    szr.Add(txt, 0, std_sizer_flags, 5)
    list_font = wx.Font(10, wx.FONTFAMILY_MODERN, wx.NORMAL, wx.NORMAL)
    if (cleanup_obj.n_dirs > 0):
      szr.Add(wx.StaticText(self, label="Directories to remove:"), 0,
        std_sizer_flags, 5)
      dir_box = wx.TextCtrl(self,
        style=wx.TE_MULTILINE|wx.TE_READONLY|wx.TE_DONTWRAP,
        size=(480, 200))
      dir_box.SetFont(list_font)
      szr.Add(dir_box, 0, std_sizer_flags, 5)
      for dir_name in cleanup_obj.dir_paths :
        dir_box.AppendText(dir_name + "\n")
    if (cleanup_obj.n_files > 0):
      szr.Add(wx.StaticText(self, label="Files to remove:"), 0,
        std_sizer_flags, 5)
      file_box = wx.TextCtrl(self,
        style=wx.TE_MULTILINE|wx.TE_READONLY|wx.TE_DONTWRAP,
        size=(480, 200))
      file_box.SetFont(list_font)
      szr.Add(file_box, 0, std_sizer_flags, 5)
      for file_name in cleanup_obj.file_paths :
        file_box.AppendText(file_name + "\n")
    add_ok_cancel_buttons(self, szr)
    self.Fit()
    self.Centre(wx.BOTH)

def clean_out_directory(parent=None, dir_name=None):
  if (dir_name is None):
    dir_name = os.getcwd()
  dlg1 = DirectoryCleanupDialog(
    parent=parent,
    title="Clean up directory",
    style=wx.CAPTION|wx.CLOSE_BOX|wx.RAISED_BORDER|\
      wx.WS_EX_VALIDATE_RECURSIVELY)
  dlg1.SetDirectory(dir_name)
  dlg2 = None
  try :
    if (dlg1.ShowModal() == wx.ID_OK):
      dir_name = dlg1.GetDirectory()
      choices = dlg1.GetChoices()
      cleanup_obj = libtbx.path.clean_out_directory(
        path_name=dir_name,
        delete_kin_files="kin" in choices,
        delete_geo_files="geo" in choices,
        delete_map_files="map" in choices,
        delete_probe_files="probe" in choices,
        delete_temp_dirs="temp" in choices)
      if (cleanup_obj.n_total == 0):
        raise Sorry("No files or directories matching the specified criteria.")
      else :
        dlg2 = ConfirmCleanupDialog(
          parent=parent,
          cleanup_obj=cleanup_obj)
        if (dlg2.ShowModal() == wx.ID_OK):
          cleanup_obj.run()
          wx.MessageBox(message="Action complete; %s of disk space freed." %
            cleanup_obj.get_freed_space())
          return cleanup_obj
        else :
          raise Abort()
    else :
      raise Abort()
  finally :
    dlg1.Destroy()
    if (dlg2 is not None) : dlg2.Destroy()

if (__name__ == "__main__"):
  app = wx.App(0)
  mgr = manager()
  fn = mgr.select_file(parent=None,
    message="Select a file")
  print(fn)


 *******************************************************************************


 *******************************************************************************
wxtbx/pdb_editor.py

from __future__ import absolute_import, division, print_function
import wxtbx.bitmaps
from wxtbx.phil_controls import simple_dialogs
from wxtbx.phil_controls import strctrl, intctrl
from wxtbx import symmetry_dialog
from wxtbx import path_dialogs
from wx.lib.embeddedimage import PyEmbeddedImage
from wx.lib.agw import customtreectrl
import wx
from libtbx.utils import Abort, Sorry, to_unicode, to_str
import string
import os

b_iso_icon = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAADnRFWHRTb2Z0d2FyZQBQeU1P"
    "TPa/er0AAAAYdEVYdFVSTABodHRwOi8vd3d3LnB5bW9sLm9yZ5iPN04AAAHrSURBVDiNxZLP"
    "TlNBFMa/mTNzL4XeIt6SCIKmRBKXpTSRujDxDdy4dmMXJr6BCzcufAX/4BPwFK4sxMREEzeG"
    "KpoiNo2tFHrnzp05LtqiWOKWb3Uy853fmZz5gPOW+Pdgfv5hOQiW6lovVaXMVQDJRNGmMc2d"
    "vb36q/8CFhYeV7S+/CwIrla1vgSiCEIoMDs412VjvjR2d+/UzgTE8b21XG7t+dTU9WoQLEOp"
    "GER5EGkADGuPYe0PHgzev2k2794c98lxQTRXVyquKnURRLMgilAoTGN1NUCpFGJmZhZaF0UY"
    "XrmxsrJVmQAAqEuZhxAhhNAgUigWBTY2gFoNiGMJohyILkhA3h83KQDI52+VpZyWgIAQAgCD"
    "mZEkQLsNCAFk2Z+ZQ+9fAADw3oA5hfcJmFM4Z9DpaGxvD729noNzQw9zilOAfv/1uzC85p3r"
    "Sef6kLIPIRSShJGmwWhACucO4VwX1u77M15w9MLa/QdEhdHXeRAZCKFH9wmc+4k0/eq9P355"
    "svxxEQTLLcCvC6EWh3vwYDbwfgDnfiHLOrD2Gw8GHxqt1qMnEwBjPn0Pw9Jb7w/XvTeLw30c"
    "wbkesqwNaz9zknxsHBw8PcnAqSCNFUW3y1JGdaK5qpRhBRBMVNg0prnT7W5NRPn89RuLodCO"
    "WgQHYQAAAABJRU5ErkJggg==")

b_aniso_icon = PyEmbeddedImage(
    "iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAADnRFWHRTb2Z0d2FyZQBQeU1P"
    "TPa/er0AAAAYdEVYdFVSTABodHRwOi8vd3d3LnB5bW9sLm9yZ5iPN04AAAFnSURBVDiNzdLP"
    "ahNRHMXxz0xCtCOaYkVpFLLpSnHTCdLH6MJHsNZtt6661wew6COIO5/CjAbciBRBkSYtBNv0"
    "nzOxuS4yDbEVXepZ/S6X7zmH3738a0V/unxKeoGVeaIaCtr3ef5Xg8ekV9lokt7ELGo4xjbZ"
    "e1bWeAeVs/A6aZ03d2ks4Baux7F6FElCENE4JrzkNVSn4bVx5fYdNHEDV+p1cbNJv0+36+Jo"
    "JGbxlIlPh3ssJmwsYB5zuJwk4qUlWi2iyDAEOYZToZMGt2ldI51DHQkqMzPs7rK5Ke/1DELw"
    "Dd/pnDOIeDBbglUEnOzv0+nIi8JeCHbwFV9onzNAq1KCQxyhKAo/yrlfwp/J1qeecmIQ8/aI"
    "9BB7yMet5OV5Gx84OWB1evETgwFZlzQpoRpGOCjTd8gGrD4hmzaY/IMGW0NaOY3DEuriEz7S"
    "7vHo2Rm43N2vWubhJdLqOH0UePHqN+D/o5/JPnJ7ZjEAWAAAAABJRU5ErkJggg==")

def format_model(model):
  return "model '%s'" % model.id

def format_chain(chain):
  return "chain '%s'" % chain.id

def format_residue_group(rg):
  return "residue %s (resseq='%s', icode='%s') [%s]" % \
    (rg.resid().strip(), rg.resseq, rg.icode,
      ",".join([ ag.resname for ag in rg.atom_groups() ]))

def format_atom_group(ag):
  return "atom group %s (altloc='%s')" % (ag.resname, ag.altloc)

def format_atom(atom):
  if (atom.hetero):
    prefix = "hetatm"
  else :
    prefix = "atom"
  return "%s '%s' (x=%.3f, y=%.3f, z=%.3f, b=%.2f, occ=%.2f, elem='%s', charge='%s')" % (prefix, atom.name, atom.xyz[0], atom.xyz[1], atom.xyz[2], atom.b,
      atom.occ, atom.element, atom.charge)
  #return "atom '%s'" % atom.name

def remove_objects_recursive(pdb_object):
  parent = pdb_object.parent()
  pdb_type = type(pdb_object).__name__
  if (pdb_type == 'atom'):
    parent.remove_atom(pdb_object)
    if (len(parent.atoms()) == 0):
      remove_objects_recursive(parent)
  elif (pdb_type == 'atom_group'):
    parent.remove_atom_group(pdb_object)
    if (len(parent.atom_groups()) == 0):
      remove_objects_recursive(parent)
  elif (pdb_type == 'residue_group'):
    parent.remove_residue_group(pdb_object)
    if (len(parent.residue_groups()) == 0):
      remove_objects_recursive(parent)
  elif (pdb_type == 'chain'):
    parent.remove_chain(pdb_object)
    if (len(parent.chains()) == 0):
      remove_objects_recursive(parent)
  else :
    if (len(parent.models()) == 1):
      raise Sorry("You must have at least one MODEL in the PDB file.")
    parent.remove_model(pdb_object)

def has_aniso_atoms(pdb_object):
  pdb_type = type(pdb_object).__name__
  if (pdb_type == 'atom'):
    return (pdb_object.uij != (-1,-1,-1,-1,-1,-1))
  else :
    for atom in pdb_object.atoms():
      if (atom.uij != (-1,-1,-1,-1,-1,-1)):
        return True
  return False

class PDBTree(customtreectrl.CustomTreeCtrl):
  max_states = 5 # maximum number of reverts possible
  def __init__(self, *args, **kwds):
    kwds = dict(kwds)
    kwds['agwStyle'] = wx.TR_HAS_VARIABLE_ROW_HEIGHT|wx.TR_HAS_BUTTONS| \
      wx.TR_TWIST_BUTTONS|wx.TR_HIDE_ROOT|wx.TR_MULTIPLE
    customtreectrl.CustomTreeCtrl.__init__(self, *args, **kwds)
    self.il = wx.ImageList(16,16)
    self.il.Add(b_iso_icon.GetBitmap())
    self.il.Add(b_aniso_icon.GetBitmap())
    self.SetImageList(self.il)
    self.Bind(wx.EVT_TREE_KEY_DOWN, self.OnChar)
    self.Bind(wx.EVT_TREE_ITEM_RIGHT_CLICK, self.OnRightClick)
    self.Bind(wx.EVT_LEFT_DCLICK, self.OnDoubleClick)
    self.frame = self.GetTopLevelParent()
    # FIXME
    #self.Bind(wx.EVT_TREE_BEGIN_DRAG, self.OnStartDrag)
    #self.Bind(wx.EVT_TREE_END_DRAG, self.OnEndDrag)
    self.DeleteAllItems()
    self.path_mgr = path_dialogs.manager()
    self.dt = PDBTreeDropTarget(self)
    self.SetDropTarget(self.dt)

  def DeleteAllItems(self):
    customtreectrl.CustomTreeCtrl.DeleteAllItems(self)
    self.AddRoot("pdb_hierarchy")
    self._hierarchy_stack = []
    self._hierarchy_actions = []
    self._changes_made = False
    self._hierarchy = None
    self._hierarchy_start = None
    self._i_state = 0
    self._crystal_symmetry = None
    self._space_group = None
    self._unit_cell = None

  def PushState(self, action="edit", set_changes_flag=True):
    del self._hierarchy_stack[self._i_state+1:]
    del self._hierarchy_actions[self._i_state+1:]
    self._hierarchy_stack.append(self._hierarchy.deep_copy())
    self._hierarchy_actions.append(action)
    if (len(self._hierarchy_stack) > self.max_states):
      del self._hierarchy_stack[0]
      del self._hierarchy_actions[0]
    if (set_changes_flag):
      self._changes_made = True
    self._i_state = len(self._hierarchy_stack) - 1
    if wx.VERSION < (4,0):
      self.frame.EnableUndo(True)
    #print self._hierarchy_stack
    #print self._hierarchy_actions
    #print self._i_state

  def SetHierarchy(self, pdb_hierarchy):
    self.DeleteAllItems()
    self._hierarchy = pdb_hierarchy
    self._hierarchy_start = pdb_hierarchy
    self.PushState("starting model", set_changes_flag=False)
    self.PopulateTree(pdb_hierarchy)

  def SetCrystalSymmetry(self, crystal_symmetry):
    self._crystal_symmetry = crystal_symmetry
    if (crystal_symmetry is not None):
      self._unit_cell = crystal_symmetry.unit_cell()
      self._space_group = crystal_symmetry.space_group()
    else :
      self._unit_cell = self._space_group = None

  def SetState(self):
    #print "SetState(): n_states:", len(self._hierarchy_stack)
    #print "SetState(): i_state:", self._i_state
    #print "SetState(): action:", self._hierarchy_actions[self._i_state]
    customtreectrl.CustomTreeCtrl.DeleteAllItems(self)
    self.AddRoot("pdb_hierarchy")
    self._hierarchy = self._hierarchy_stack[self._i_state]
    self.PopulateTree(self._hierarchy)
    self.Refresh()

  def PopulateTree(self, pdb_hierarchy):
    root_node = self.GetRootItem()
    for model in pdb_hierarchy.models():
      self._InsertModelItem(root_node, model)

  def _InsertModelItem(self, root_node, model, index=None):
    model_node = None
    if (index is None):
      model_node = self.AppendItem(root_node, format_model(model), data=model)
    else :
      model_node = self.InsertItemByIndex(root_node, index,
        format_model(model), data=model)
    for chain in model.chains():
      self._InsertChainItem(model_node, chain)
    self.Expand(model_node)
    return model_node

  def _InsertChainItem(self, model_node, chain, index=None):
    chain_node = None
    if (index is None):
      chain_node = self.AppendItem(model_node, format_chain(chain), data=chain)
    else :
      chain_node = self.InsertItemByIndex(model_node, index,
        format_chain(chain), data=chain)
    for rg in chain.residue_groups():
      self._InsertResidueGroupItem(chain_node, rg)
    return chain_node

  def _InsertResidueGroupItem(self, chain_node, residue_group, index=None):
    rg_node = None
    if (index is None):
      rg_node = self.AppendItem(chain_node, format_residue_group(residue_group),
        data=residue_group)
    else :
      print("index =", index)
      rg_node = self.InsertItemByIndex(chain_node, index,
        format_residue_group(residue_group), data=residue_group)
    for ag in residue_group.atom_groups():
      self._InsertAtomGroupItem(rg_node, ag)
    return rg_node

  def _InsertAtomGroupItem(self, rg_node, atom_group, index=None):
    ag_node = None
    if (index is None):
      ag_node = self.AppendItem(rg_node, format_atom_group(atom_group),
        data=atom_group)
    else :
      ag_node = self.InsertItemByIndex(rg_node, index,
        format_atom_group(atom_group), data=atom_group)
    for atom in atom_group.atoms():
      self._InsertAtomItem(ag_node, atom)
    return ag_node

  def _InsertAtomItem(self, ag_node, atom, index=None):
    atom_node = None
    if (index is None):
      atom_node = self.AppendItem(ag_node, format_atom(atom), data=atom)
    else :
      atom_node = self.InsertItemByIndex(ag_node, index, format_atom(atom),
        data=atom)
    if (atom.uij == (-1,-1,-1,-1,-1,-1)):
      self.SetItemImage(atom_node, 0)
    else :
      self.SetItemImage(atom_node, 1)
    return atom_node

  def PropagateAtomChanges(self, node):
    child, cookie = self.GetFirstChild(node)
    if (child is None):
      pdb_object = self.GetItemPyData(node)
      if (type(pdb_object).__name__ == 'atom'):
        self.SetItemText(node, format_atom(pdb_object))
        if (pdb_object.uij == (-1,-1,-1,-1,-1,-1)):
          self.SetItemImage(node, 0)
        else :
          self.SetItemImage(node, 1)
      else :
        print("Can't modify object %s'" % type(pdb_object).__name__)
    else :
      while (child is not None):
        self.PropagateAtomChanges(child)
        child, cookie = self.GetNextChild(node, cookie)

  def FindItem(self, pdb_object):
    root_node = self.GetRootItem()
    return self._FindItem(root_node, pdb_object)

  def _FindItem(self, node, pdb_object):
    child, cookie = self.GetFirstChild(node)
    if (child is None):
      if (self.GetItemPyData(node) == pdb_object):
        return child
      return None
    while (child is not None):
      if (self.GetItemPyData(child) == pdb_object):
        return child
      item = self._FindItem(child, pdb_object)
      if (item is not None):
        return item
      child, cookie = self.GetNextChild(node, cookie)
    return None

  def _ApplyToAtoms(self, item, pdb_object, modify_action):
    assert (hasattr(modify_action, "__call__"))
    if (type(pdb_object).__name__ == 'atom'):
      modify_action(pdb_object)
      self.SetItemText(item, format_atom(pdb_object))
    else :
      for atom in pdb_object.atoms():
        modify_action(atom)
      self.PropagateAtomChanges(item)

  def GetSelectedObject(self, object_type=None):
    item = self.GetSelection()
    pdb_object = self.GetItemPyData(item)
    if (object_type is not None):
      assert (type(pdb_object).__name__ == object_type)
    return item, pdb_object

  def GetSelectionInfo(self):
    from scitbx.array_family import flex
    selection = flex.bool(self._hierarchy.atoms_size(), False)
    object_types = set([])
    for item in self.GetSelections():
      pdb_object = self.GetItemPyData(item)
      pdb_type = type(pdb_object).__name__
      object_types.add(pdb_type)
      if (pdb_type == 'atom'):
        selection[pdb_object.i_seq] = True
      else :
        for atom in pdb_object.atoms():
          selection[atom.i_seq] = True
    return list(object_types), selection.count(True)

  def FindInsertionIndex(self, pdb_object):
    pass

  def HaveUnsavedChanges(self):
    return self._changes_made

  def SaveChanges(self):
    self._changes_made = False

  def DeselectAll(self):
    items = self.GetSelections()
    for item in items :
      self.SelectItem(item, False)

  def Undo(self):
    if (self._i_state == 0):
      raise Sorry(("No more changes left to undo (only the previous %d "+
        "states will be remembered)") % self.max_states)
    else :
      print("Undoing action: %s" % self._hierarchy_actions[self._i_state])
      self._i_state -= 1
      self.SetState()
      if (self._i_state == 0):
        self.frame.EnableUndo(False)
      self.frame.EnableRedo(True)

  def Redo(self):
    if (self._i_state == len(self._hierarchy_stack) - 1):
      raise Sorry("No more changes to redo.")
    else :
      self._i_state += 1
      print("Restoring action: %s" % self._hierarchy_actions[self._i_state])
      self.SetState()
      self.frame.EnableUndo(True)
      if (self._i_state == len(self._hierarchy_stack) - 1):
        self.frame.EnableRedo(False)

  #---------------------------------------------------------------------
  # UI events
  def OnChar(self, event):
    evt2 = event.GetKeyEvent()
    key = evt2.GetKeyCode()
    shift_down = evt2.ShiftDown()
    all_items = self.GetSelections()
    last_item = None
    if (len(all_items) > 0):
      last_item = all_items[-1]
    if (last_item is None):
      first_item, cookie = self.GetFirstChild(self.GetRootItem())
      if (first_item is not None):
        self.SelectItem(first_item)
    elif (key == wx.WXK_SPACE) or (key == wx.WXK_TAB):
      for item in all_items :
        if (self.IsExpanded(item)):
          self.Collapse(item)
        else :
          self.Expand(item)
    elif (key == wx.WXK_LEFT):
      parent = self.GetItemParent(last_item)
      if (parent != self.GetRootItem()):
        if (not shift_down):
            self.DeselectAll()
        self.SelectItem(parent)
    elif (key == wx.WXK_RIGHT):
      first_child, cookie = self.GetFirstChild(last_item)
      if (first_child is not None):
        if (not shift_down):
          self.DeselectAll()
        self.SelectItem(first_child)
    elif (key == wx.WXK_DOWN):
      next_item = self.GetNextSibling(last_item)
      if (next_item is None):
        parent = self.GetItemParent(last_item)
        first_sibling, cookie = self.GetFirstChild(parent)
        # if the current node has no siblings, select the first child instead
        if (first_sibling == last_item):
          next_item, cookie = self.GetFirstChild(last_item)
        else :
          next_item = first_sibling
      if (next_item is not None):
        if (not shift_down):
          self.DeselectAll()
        self.SelectItem(next_item)
    elif (key == wx.WXK_UP):
      first_item = all_items[0]
      prev_item = self.GetPrevSibling(first_item)
      if (prev_item is None):
        parent = self.GetItemParent(first_item)
        prev_item = self.GetLastChild(parent)
      if (prev_item is not None):
        if (not shift_down):
          self.DeselectAll()
        self.SelectItem(prev_item)
    elif (key == wx.WXK_DELETE) or (key == wx.WXK_BACK):
      self.DeleteSelected()
    elif (key == wx.WXK_RETURN):
      self.ActionsForSelection(source_window=self)

  def OnRightClick(self, event):
    self.ActionsForSelection(source_window=self)

  # XXX is this useful or not?
  def OnDoubleClick(self, event):
    pass

  # TODO
  def OnStartDrag(self, event):
    items = self.GetSelections()
    object_types, n_atoms = self.GetSelectionInfo()
    if (len(object_types) == 1):
      event.Allow()
      data = wx.CustomDataObject(wx.CustomDataFormat('pdb_object'))
      data.SetData(object_types[0])
      drop_source = wx.DropSource(self)
      drop_source.SetData(data)
      result = drop_source.DoDragDrop(flags=wx.Drag_DefaultMove)
      print(result)
      self.Refresh()

  def OnDrop(self, x, y):
    print(x, y)
    return True

  def OnEndDrag(self, event):
    print(1)

  #---------------------------------------------------------------------
  # action menus
  def ActionsForSelection(self, source_window):
    all_sel = self.GetSelections()
    if (len(all_sel) == 0):
      raise Sorry("You must select an object in the PDB hierarchy to edit.")
    elif (len(all_sel) > 1):
      object_types, n_atoms = self.GetSelectionInfo()
      labels_and_actions = [
        ("Set occupancy...", self.OnSetOccupancy),
        ("Set B-factor...", self.OnSetBfactor),
        ("Set segment ID...", self.OnSetSegID),
        ("Convert to isotropic", self.OnSetIsotropic),
      ]
      if (len(object_types) == 1):
        labels_and_actions.extend([
          ("Delete object(s)...", self.OnDeleteObject),
          ("Apply rotation/translation...", self.OnMoveSites),
        ])
        if (self._crystal_symmetry is not None):
          labels_and_actions.extend([
            ("Apply symmetry operator...", self.OnApplySymop),
          ])
      if (object_types == ["residue_group"]):
        labels_and_actions.extend([
          ("Renumber residues...", self.OnRenumberResidues),
        ])
      labels_and_actions.extend([
          ("Toggle ATOM/HETATM...", self.OnSetAtomType),
          ("Reset element field...", self.OnResetElement),
          ("Set altloc...", self.OnSetAltlocOther),
      ])
      self.ShowMenu(labels_and_actions, source_window)
    else :
      sel = self.GetSelection()
      pdb_object = self.GetItemPyData(sel)
      if (pdb_object is not None):
        pdb_type = type(pdb_object).__name__
        if (pdb_type == "atom"):
          self.ShowAtomMenu(
            atom=pdb_object,
            source_window=source_window)
        elif (pdb_type == "atom_group"):
          self.ShowAtomGroupMenu(
            atom_group=pdb_object,
            source_window=source_window)
        elif (pdb_type == "residue_group"):
          self.ShowResidueGroupMenu(
            residue_group=pdb_object,
            source_window=source_window)
        elif (pdb_type == "chain"):
          self.ShowChainMenu(
            chain=pdb_object,
            source_window=source_window)
        elif (pdb_type == "model"):
          self.ShowModelMenu(
            model=pdb_object,
            source_window=source_window)
        else :
          raise RuntimeError("Unrecognized object type '%s'" % pdb_type)

  def ShowAtomMenu(self, atom, source_window):
    labels_and_actions = [
      ("Set name...", self.OnSetName),
      ("Set occupancy...", self.OnSetOccupancy),
      ("Set B-factor...", self.OnSetBfactor),
      ("Set element...", self.OnSetElement),
      ("Set charge...", self.OnSetCharge),
      ("Convert to isotropic", self.OnSetIsotropic),
      ("Delete atom", self.OnDeleteObject),
      ("Apply rotation/translation...", self.OnMoveSites),
      ("Toggle ATOM/HETATM...", self.OnSetAtomType),
      ("Reset element field...", self.OnResetElement),
    ]
    if (self._crystal_symmetry is not None):
      labels_and_actions.extend([
        ("Apply symmetry operator...", self.OnApplySymop),
      ])
    self.ShowMenu(labels_and_actions, source_window)

  def ShowAtomGroupMenu(self, atom_group, source_window):
    labels_and_actions = [
      ("Set altloc...", self.OnSetAltloc),
      ("Set occupancy...", self.OnSetOccupancy),
      ("Set B-factor...", self.OnSetBfactor),
      ("Set residue name...", self.OnSetResname),
      ("Convert to isotropic", self.OnSetIsotropic),
      ("Delete atom group", self.OnDeleteObject),
      ("Clone atom group", self.OnCloneAtoms),
      ("Apply rotation/translation...", self.OnMoveSites),
      ("Toggle ATOM/HETATM...", self.OnSetAtomType),
      ("Reset element field...", self.OnResetElement),
    ]
    if (atom_group.resname == "MET"):
      labels_and_actions.append(("Convert to SeMet", self.OnConvertMet))
    elif (atom_group.resname == "MSE"):
      labels_and_actions.append(("Convert to Met", self.OnConvertSeMet))
    labels_and_actions.append([
      ("Separate atoms...", self.OnSeparateAtoms),
    ])
    if (self._crystal_symmetry is not None):
      labels_and_actions.extend([
        ("Apply symmetry operator...", self.OnApplySymop),
      ])
    self.ShowMenu(labels_and_actions, source_window)

  def ShowResidueGroupMenu(self, residue_group, source_window):
    labels_and_actions = [
      ("Set residue number...", self.OnSetResseq),
      ("Set insertion code...", self.OnSetIcode),
      ("Set segment ID...", self.OnSetSegID),
      ("Set B-factor...", self.OnSetBfactor),
      ("Convert to isotropic", self.OnSetIsotropic),
      ("Delete residue", self.OnDeleteObject),
      ("Split residue", self.OnSplitResidue),
      ("Apply rotation/translation...", self.OnMoveSites),
      ("Insert residues after...", self.OnInsertAfter),
      ("Renumber residue...", self.OnRenumberResidues),
      ("Toggle ATOM/HETATM...", self.OnSetAtomType),
      ("Reset element field...", self.OnResetElement),
    ]
    if (len(residue_group.atom_groups()) == 1):
      labels_and_actions.append(("Set occupancy...", self.OnSetOccupancy))
    labels_and_actions.append([
      ("Separate atoms...", self.OnSeparateAtoms),
    ])
    if (self._crystal_symmetry is not None):
      labels_and_actions.extend([
        ("Apply symmetry operator...", self.OnApplySymop),
      ])
    self.ShowMenu(labels_and_actions, source_window)

  def ShowChainMenu(self, chain, source_window):
    labels_and_actions = [
      ("Set chain ID...", self.OnSetChainID),
      ("Set segment ID...", self.OnSetSegID),
      ("Set B-factor...", self.OnSetBfactor),
      ("Convert to isotropic", self.OnSetIsotropic),
      ("Delete chain", self.OnDeleteObject),
      ("Apply rotation/translation...", self.OnMoveSites),
      ("Toggle ATOM/HETATM...", self.OnSetAtomType),
      ("Reset element field...", self.OnResetElement),
      ("Add residues...", self.OnAddResidues),
      ("Renumber residues...", self.OnRenumberChain),
      ("Reset residue numbers...", self.OnResetNumbering),
    ]
    if (len(chain.conformers()) > 1):
      labels_and_actions.append(
        ("Delete alternate conformers", self.OnDeleteAltConfs))
    else :
      labels_and_actions.extend([
        ("Set altloc...", self.OnSetAltlocOther),
        ("Set occupancy...", self.OnSetOccupancy)])
    model = chain.parent()
    if (len(model.chains()) > 1):
      labels_and_actions.append(
        ("Merge with other chain...", self.OnMergeChain))
    if (self._crystal_symmetry is not None):
      labels_and_actions.extend([
        ("Apply symmetry operator...", self.OnApplySymop),
      ])
    self.ShowMenu(labels_and_actions, source_window)

  def ShowModelMenu(self, model, source_window):
    labels_and_actions = [
      ("Convert to isotropic", self.OnSetIsotropic),
      ("Delete model", self.OnDeleteObject),
      ("Apply rotation/translation...", self.OnMoveSites),
      ("Add chain(s)...", self.OnAddChain),
      ("Split model...", self.OnSplitModel),
      ("Toggle ATOM/HETATM...", self.OnSetAtomType),
      ("Reset element field...", self.OnResetElement),
    ]
    self.ShowMenu(labels_and_actions, source_window)

  def ShowMenu(self, items, source_window):
    def add_to_menu(m, label, action):
      item = m.Append(-1, label)
      source_window.Bind(wx.EVT_MENU, action, item)
    menu = wx.Menu()
    for entry in items :
      if isinstance(entry, list):
        advanced_menu = wx.Menu()
        menu.AppendMenu(-1, "Advanced options", advanced_menu)
        for label, action in entry :
          add_to_menu(advanced_menu, label, action)
      else :
        label, action = entry
        add_to_menu(menu, label, action)
    source_window.PopupMenu(menu)
    menu.Destroy()

  #---------------------------------------------------------------------
  # PROPERTY EDITING ACTIONS
  # atom
  def OnSetName(self, event):
    item, atom = self.GetSelectedObject('atom')
    new_name = self.GetNewName(atom.name)
    assert (new_name is not None) and (1 <= len(new_name) <= 4)
    if (new_name != atom.name):
      atom_group = atom.parent()
      for other_atom in atom_group.atoms():
        if (other_atom.name == new_name) and (atom != other_atom):
          confirm_action(("The atom group to which this atom belongs already "+
          "has another atom named \"%s\".  Are you sure you want to rename "+
          "the selected atom?") % new_name)
      atom.name = "%-4s" % new_name
      self.SetItemText(item, format_atom(atom))
      self.PushState("changed atom name ('%s' -> '%s')" % (atom.name,new_name))

  # atom
  def OnSetElement(self, event):
    item, atom = self.GetSelectedObject('atom')
    new_elem = self.GetNewElement(atom.element)
    assert (new_elem is None) or (len(new_elem) <= 2)
    if (new_elem != atom.element):
      if (new_elem is None) or (new_elem.isspace()):
        atom.element = '  '
      else :
        new_elem = new_elem.strip()
        atom.element = '%2s' % new_elem
      # TODO validate element symbol
      self.SetItemText(item, format_atom(atom))
      self.PushState("changed atom element to '%s'" % atom.element)

  # atom
  def OnSetCharge(self, event):
    item, atom = self.GetSelectedObject('atom')
    new_charge = self.GetNewCharge(atom.charge)
    assert (new_charge is None) or (-9 <= new_charge <= 9)
    if (new_charge in [0, None]):
      atom.charge = '  '
    elif (new_charge < 0):
      atom.charge = '%d-' % abs(new_charge)
    else :
      atom.charge = '%d+' % new_charge
    self.SetItemText(item, format_atom(atom))
    self.PushState("set atom charge to %s" % new_charge)

  # atom
  def OnSetXYZ(self, event):
    pass

  # atom_group
  def OnSetAltloc(self, event):
    """
    Change the altloc ID of an atom group.  This actually checks whether a
    split residue is having a blank altloc set, unlike the alternate function
    for arbitrary selections below.
    """
    item, atom_group = self.GetSelectedObject()
    new_altloc = self.GetNewAltloc(atom_group.altloc)
    assert (new_altloc is None) or (len(new_altloc) in [0,1])
    if (new_altloc != atom_group.altloc):
      if (new_altloc in [None, '']):
        rg = atom_group.parent()
        if (len(rg.atom_groups()) > 1):
          confirm_action("You have specified a blank altloc ID for this atom "+
            "group, but it is part of a residue containing multiple "+
            "conformations.  Are you sure this is what you want to do?")
        atom_group.altloc = ''
      else :
        atom_group.altloc = new_altloc
      self.SetItemText(item, format_atom_group(atom_group))
      self.PushState("set altloc to '%s'" % new_altloc)

  # atom_group
  def OnSetResname(self, event):
    item, atom_group = self.GetSelectedObject('atom_group')
    new_resname = self.GetNewResname(atom_group.resname)
    assert (new_resname is not None) and (len(new_resname) in [1,2,3])
    if (atom_group.resname != new_resname):
      atom_group.resname = new_resname
      self.SetItemText(item, format_atom_group(atom_group))
      rg_item = self.GetItemParent(item)
      self.SetItemText(rg_item, format_residue_group(atom_group.parent()))
      self.PushState("set resname to '%s" % new_resname)

  # atom_group (resname == MET)
  def OnConvertMet(self, event):
    item, atom_group = self.GetSelectedObject('atom_group')
    assert (atom_group.resname == "MET")
    atom_group.resname = "MSE"
    for atom in atom_group.atoms():
      if (atom.name == ' SD '):
        atom.name = ' SE '
        atom.element = 'Se'
        break
    self.SetItemText(item, format_atom_group(atom_group))
    rg_item = self.GetItemParent(item)
    self.SetItemText(rg_item, format_residue_group(atom_group.parent()))
    self.PropagateAtomChanges(item)
    self.PushState("converted MET to MSE")

  # atom_group (resname == MSE)
  def OnConvertSeMet(self, event):
    item, atom_group = self.GetSelectedObject('atom_group')
    assert (atom_group.resname == "MSE")
    atom_group.resname = "MET"
    for atom in atom_group.atoms():
      if (atom.name == ' SE '):
        atom.name = ' SD '
        atom.element = ' S'
        break
    self.SetItemText(item, format_atom_group(atom_group))
    rg_item = self.GetItemParent(item)
    self.SetItemText(rg_item, format_residue_group(atom_group.parent()))
    self.PropagateAtomChanges(item)
    self.PushState("converted MSE to MET")

  # residue_group
  def OnSetIcode(self, event):
    item, residue_group = self.GetSelectedObject('residue_group')
    new_icode = self.GetNewIcode(residue_group.icode)
    assert (new_icode is None) or (len(new_icode) == 1)
    if (new_icode != residue_group.icode):
      if (new_icode is None):
        residue_group.icode = ' '
      else :
        residue_group.icode = new_icode
      self.SetItemText(item, format_residue_group(residue_group))
      self.PushState("set insertion code to '%s'" % new_icode)

  def OnSetResseq(self, event):
    item, residue_group = self.GetSelectedObject('residue_group')
    new_resseq = self.GetNewResseq(residue_group.resseq_as_int())
    assert (new_resseq is not None)
    if (new_resseq != residue_group.resseq_as_int()):
      residue_group.resseq = "%4d" % new_resseq
      self.SetItemText(item, format_residue_group(residue_group))
      self.PushState("set residue number to '%s'" % new_resseq)

  def OnRenumberResidues(self, event):
    items = self.GetSelections()
    resseq_shift = self.GetResseqShift()
    if (resseq_shift is not None) and (resseq_shift != 0):
      for item in items :
        residue_group = self.GetItemPyData(item)
        assert (type(residue_group).__name__ == 'residue_group')
        resseq = residue_group.resseq_as_int()
        new_resseq = resseq + resseq_shift
        if (new_resseq > 9999) or (new_resseq < -999):
          raise NotImplementedError("Hybrid36 support not available.")
        else :
          residue_group.resseq = "%4d" % new_resseq
        self.SetItemText(item, format_residue_group(residue_group))
      self.PushState("renumber residues by '%d'" % resseq_shift)

  # chain
  def OnSetChainID(self, event):
    item, chain = self.GetSelectedObject('chain')
    new_id = self.GetNewChainID(chain.id)
    if (new_id != chain.id):
      if (new_id is None) or (new_id.isspace()):
        chain.id = ' '
      else :
        chain.id = "%2s" % new_id
      self.SetItemText(item, format_chain(chain))
      self.PushState("set chain ID to '%s'" % new_id)

  # chain
  def OnRenumberChain(self, event):
    item, chain = self.GetSelectedObject('chain')
    resseq_shift = self.GetResseqShift()
    if (resseq_shift is not None) and (resseq_shift != 0):
      child, cookie = self.GetFirstChild(item)
      while (child is not None):
        residue_group = self.GetItemPyData(child)
        assert (type(residue_group).__name__ == 'residue_group')
        resseq = residue_group.resseq_as_int()
        new_resseq = resseq + resseq_shift
        if (new_resseq > 9999) or (new_resseq < -999):
          raise NotImplementedError("Hybrid36 support not available.")
        else :
          residue_group.resseq = "%4d" % new_resseq
        self.SetItemText(child, format_residue_group(residue_group))
        child, cookie = self.GetNextChild(item, cookie)
      self.PushState("incremented residue numbers by %d" % resseq_shift)

  # chain
  def OnResetNumbering(self, event):
    item, chain = self.GetSelectedObject('chain')
    confirm = wx.MessageBox("This will renumber all residues in the chain "+
      "to start from 1, and reset the insertion code to blank.  Are you "+
      "sure you want to do this?", style=wx.YES_NO)
    if (confirm == wx.YES):
      i_res = 1
      child, cookie = self.GetFirstChild(item)
      while (child is not None):
        residue_group = self.GetItemPyData(child)
        assert (type(residue_group).__name__ == 'residue_group')
        residue_group.resseq = "%4d" % i_res
        i_res += 1
        self.SetItemText(child, format_residue_group(residue_group))
        child, cookie = self.GetNextChild(item, cookie)
      self.PushState("reset numbering for chain '%s'" % chain.id)

  # model
  def OnSetModelID(self, event):
    pass

  # all
  def OnSetOccupancy(self, event):
    items = self.GetSelections()
    new_occ = None
    for item in items :
      pdb_object = self.GetItemPyData(item)
      pdb_type = type(pdb_object).__name__
      occ = None
      if (pdb_type == 'atom'):
        occ = pdb_object.occ
      else :
        all_occ = pdb_object.atoms().extract_occ()
        if (all_occ.all_eq(all_occ[0])):
          occ = all_occ[0]
      if (new_occ is None):
        new_occ = self.GetNewOccupancy(occ)
      assert (0 <= new_occ <= 1.0)
      def apply_occ(atom) : atom.occ = new_occ
      self._ApplyToAtoms(item, pdb_object, apply_occ)

  # all
  def OnSetBfactor(self, event):
    items = self.GetSelections()
    new_b = None
    for item in items :
      pdb_object = self.GetItemPyData(item)
      pdb_type = type(pdb_object).__name__
      b_iso = None
      if (pdb_type == 'atom'):
        b_iso = pdb_object.b
      else :
        all_b = pdb_object.atoms().extract_b()
        if (all_b.all_eq(all_b[0])):
          b_iso = all_b[0]
      if (new_b is None):
        new_b = self.GetNewBiso(b_iso)
        assert (0 < new_b < 1000)
      def apply_b(atom) : atom.b = new_b
      self._ApplyToAtoms(item, pdb_object, apply_b)

  # all
  def OnSetIsotropic(self, event):
    items = self.GetSelections()
    for item in items :
      pdb_object = self.GetItemPyData(item)
      def set_isotropic(atom):
        atom.set_uij(new_uij=(-1.0, -1.0, -1.0, -1.0, -1.0, -1.0))
      self._ApplyToAtoms(item, pdb_object, set_isotropic)

  # all
  def OnSetSegID(self, event):
    items = self.GetSelections()
    new_segid = None
    for item in items :
      pdb_object = self.GetItemPyData(item)
      pdb_type = type(pdb_object).__name__
      segid = None
      if (pdb_type == 'atom'):
        segid = pdb_object.segid
      else :
        from scitbx.array_family import flex
        segids = flex.std_string([ a.segid for a in pdb_object.atoms() ])
        if (segids.all_eq(segids[0])):
          segid = segids[0]
      if (segid is not None) and (segid.isspace()):
        segid = None
      if (new_segid is None):
        new_segid = self.GetNewSegID(segid)
      if (new_segid != segid):
        def apply_segid(atom) : atom.segid = new_segid
        self._ApplyToAtoms(item, pdb_object, apply_segid)

  # all
  def OnSetAltlocOther(self, event):
    """
    Set the altloc for an arbitrary collection of atoms, not just an atom
    group.
    """
    items = self.GetSelections()
    new_altloc = None
    for item in items :
      pdb_object = self.GetItemPyData(item)
      if (type(pdb_object).__name__ in ["residue_group", "chain"]):
        if (len(pdb_object.conformers()) > 1):
          raise Sorry("One or more residues in the selection contain "+
            "alternate conformers; you may only set the altloc identifier "+
            "for a single conformer at a time.")
      elif (type(pdb_object).__name__ == "atom"):
        atom_group = pdb_object.parent()
        ag_item = self.FindItem(atom_group)
        if (not ag_item in items):
          raise Sorry(("You have selected the atom '%s' to have its altloc "
            "identifier changed, but not the parent atom group.  Because the "+
            "altloc ID is an atom group property, you must set it for the "+
            "entire atom group, not individual atoms.") % pdb_object.id_str())
    new_altloc = self.GetNewAltloc("")
    modified = []
    for item in items :
      pdb_object = self.GetItemPyData(item)
      if (type(pdb_object) == 'atom_group'):
        pdb_object.altloc = new_altloc
        modified.append(pdb_object.memory_id())
        self.SetItemText(item, format_atom_group(pdb_object))
      else:
        atoms = []
        if (type(pdb_object) == 'atom'):
          atoms = [ pdb_object]
        else :
          atoms = pdb_object.atoms()
        for atom in atoms :
          atom_group = atom.parent()
          if (not atom_group.memory_id() in modified):
            atom_group.altloc = new_altloc
            modified.append(atom_group.memory_id())
            ag_item = self.FindItem(atom_group)
            self.SetItemText(ag_item, format_atom_group(atom_group))
    self.PushState("set altloc to %s" % new_altloc)

  # all
  def OnMoveSites(self, event):
    style = 0
    if (self._crystal_symmetry is not None):
      if (self._crystal_symmetry.unit_cell() is not None):
        style = simple_dialogs.RT_DIALOG_ENABLE_FRACTIONAL
    dlg = simple_dialogs.RTDialog(
      parent=self,
      title="Rotation/translation operator",
      wxtbxStyle=style)
    rt = None
    fractional = False
    if (dlg.ShowModal() == wx.ID_OK):
      rt = dlg.GetMatrix()
      fractional = dlg.IsFractional()
    wx.CallAfter(dlg.Destroy)
    if (rt is None):
      raise Abort()
    self.ApplyTransformation(rt, fractional=fractional)
    self.PushState("moved sites")

  # all
  def OnApplySymop(self, event):
    if (self._space_group is None):
      raise Sorry("No space group defined.")
    space_group = self._crystal_symmetry.space_group()
    space_group_info = space_group.info()
    dlg = simple_dialogs.SymopChoiceDialog(
      parent=self,
      title="Apply symmetry operator",
      label="Valid symmetry operators",
      caption="Please select a symmetry operator from the list of choices "+
        "supported for space group '%s'" % str(space_group_info))
    dlg.SetSpaceGroup(space_group)
    if (dlg.ShowModal() == wx.ID_OK):
      smx = dlg.GetValue()
    wx.CallAfter(dlg.Destroy)
    if (smx is None):
      raise Abort()
    from scitbx import matrix
    r = smx.r().as_double()
    t = smx.t().as_double()
    rt = matrix.rt((r,t))
    self.ApplyTransformation(rt, fractional=True)
    self.PushState("applied symop '%s'" % str(smx))

  def ApplyTransformation(self, rt, fractional=False):
    items = self.GetSelections()
    unit_cell = None
    if (fractional):
      unit_cell = self._crystal_symmetry.unit_cell()
      assert (unit_cell is not None)
    # FIXME
    for item in items :
      pdb_object = self.GetItemPyData(item)
      if has_aniso_atoms(pdb_object):
        confirm_action("This action will invalidate any ANISOU records "+
          "present in the selected atoms, which will automatically be "+
          "converted to isotropic.  Are you sure you want to continue?")
        break
    for item in items :
      pdb_object = self.GetItemPyData(item)
      pdb_type = type(pdb_object).__name__
      if (pdb_type == 'atom'):
        from scitbx.array_family import flex
        sites = flex.vec3_double([pdb_object.xyz])
        if (fractional):
          sites = unit_cell.fractionalize(sites_cart=sites)
        sites = rt.r.elems * sites + rt.t.elems
        if (fractional):
          sites = unit_cell.orthogonalize(sites_frac=sites)
        pdb_object.xyz = sites[0]
        if (pdb_object.uij != (-1,-1,-1,-1,-1,-1)):
          pdb_object.uij = (-1,-1,-1,-1,-1,-1)
        self.SetItemText(item, format_atom(pdb_object))
      else :
        atoms = pdb_object.atoms()
        sites = atoms.extract_xyz()
        if (fractional):
          sites = unit_cell.fractionalize(sites_cart=sites)
        sites = rt.r.elems * sites + rt.t.elems
        if (fractional):
          sites = unit_cell.orthogonalize(sites_frac=sites)
        atoms.set_xyz(sites)
        for atom in atoms :
          if (atom.uij != (-1,-1,-1,-1,-1,-1)):
            atom.uij = (-1,-1,-1,-1,-1,-1)
        self.PropagateAtomChanges(item)

  # all
  def OnResetElement(self, event):
    items = self.GetSelections()
    n_changed = n_unassigned = 0
    for item in items :
      pdb_object = self.GetItemPyData(item)
      pdb_type = type(pdb_object).__name__
      if (pdb_type == 'atom'):
        pdb_object.element = ''
        pdb_object.set_chemical_element_simple_if_necessary()
        if (pdb_object.element == ''):
          n_unassigned += 1
        else :
          n_changed += 1
      else :
        for atom in pdb_object.atoms():
          atom.element = ''
          atom.set_chemical_element_simple_if_necessary()
          if (atom.element == ''):
            n_unassigned += 1
          else :
            n_changed += 1
      self.PropagateAtomChanges(item)
    self.PushState("reset chemical element field")
    if (n_unassigned > 0):
      wx.MessageBox(("WARNING: %d atoms now have blank element fields because "+
        "the element could not be automatically determined from the atom "+
        "name.  You may need to set these manually!") % n_unassigned)
    elif (n_changed > 0):
      wx.MessageBox("Chemical element reset for %d atoms." % n_changed)

  # all
  def OnSetAtomType(self, event):
    items = self.GetSelections()
    n_hetatm = n_atom = 0
    for item in items :
      pdb_object = self.GetItemPyData(item)
      pdb_type = type(pdb_object).__name__
      if (pdb_type == 'atom'):
        if (pdb_object.hetero):
          n_hetatm += 1
        else :
          n_atom += 1
      else :
        for atom in pdb_object.atoms():
          if (atom.hetero):
            n_hetatm += 1
          else :
            n_atom += 1
    atom_type = "ATOM"
    if (n_atom == 0) and (n_hetatm > 0):
      atom_type = "HETATM"
    new_type = self.GetAtomType(atom_type)
    for item in items :
      pdb_object = self.GetItemPyData(item)
      pdb_type = type(pdb_object).__name__
      if (pdb_type == 'atom'):
        if (new_type == "HETATM"):
          pdb_object.hetero = True
        else :
          pdb_object.hetero = False
      else :
        for atom in pdb_object.atoms():
          if (new_type == "HETATM"):
            atom.hetero = True
          else :
            atom.hetero = False
      self.PropagateAtomChanges(item)
    self.PushState("set record types to %s" % new_type)

  #---------------------------------------------------------------------
  # HIERARCHY EDITING
  def OnDeleteObject(self, event):
    self.DeleteSelected()

  def DeleteSelected(self):
    object_types, n_atoms = self.GetSelectionInfo()
    if (len(object_types) > 1):
      raise Sorry(("Multiple object types selected (%s) - you may only delete "+
        "one type of object at a time.") % (" ".join(object_types)))
    confirm_action("Are you sure you want to delete the selected %d atom(s)?"
      % n_atoms)
    for item in self.GetSelections():
      pdb_object = self.GetItemPyData(item)
      self._DeleteObject(item, pdb_object)
    self._hierarchy.atoms().reset_i_seq()
    self.PushState("deleted %d atoms" % n_atoms)

  def _DeleteObject(self, item, pdb_object):
    remove_objects_recursive(pdb_object)
    self._RemoveItem(item)

  def _RemoveItem(self, item):
    parent_item = self.GetItemParent(item)
    self.DeleteChildren(item)
    self.Delete(item)
    while (not self.HasChildren(parent_item)):
      del_item = parent_item
      parent_item = self.GetItemParent(del_item)
      self.Delete(del_item)

  # chain
  def OnDeleteAltConfs(self, event):
    item, chain = self.GetSelectedObject('chain')
    n_alt_atoms = 0
    n_alt_residues = 0
    for residue_group in chain.residue_groups():
      atom_groups = residue_group.atom_groups()
      if (len(atom_groups) > 1):
        n_alt_residues += 1
        for ag in atom_groups[1:] :
          n_alt_atoms += len(ag.atoms())
    if (n_alt_atoms == 0):
      raise Sorry("No alternate conformations found in this chain.")
    confirm_action(("There are %d residues with alternate conformations; "+
      "removing these will delete %d atoms from the model.  Are you sure "+
      "you want to continue?") % (n_alt_residues, n_alt_atoms))
    # TODO more control over what happens to remaining atom_groups
    child, cookie = self.GetFirstChild(item)
    while (child is not None):
      residue_group = self.GetItemPyData(child)
      assert (type(residue_group).__name__ == 'residue_group')
      atom_groups = residue_group.atom_groups()
      if (len(atom_groups) > 1):
        first_group = atom_groups[0]
        first_group.altloc = ''
        for atom in first_group.atoms():
          atom.occ = 1.0
        child2, cookie2 = self.GetFirstChild(child)
        self.SetItemText(child2, format_atom_group(first_group))
        for atom_group in atom_groups[1:] :
          residue_group.remove_atom_group(atom_group)
          item2 = self.FindItem(atom_group)
          assert (item2 is not None)
          self.DeleteChildren(item2)
          self.Delete(item2)
        self.SetItemText(child, format_residue_group(residue_group))
      child, cookie = self.GetNextChild(item, cookie)
    self._hierarchy.atoms().reset_i_seq()
    self.PushState("deleted %d atoms with alternate conformations" %
      n_alt_atoms)

  # atom_group
  def OnCloneAtoms(self, event):
    item, target_atom_group = self.GetSelectedObject('atom_group')
    residue_group = target_atom_group.parent()
    atom_groups = residue_group.atom_groups()
    assert (len(atom_groups) > 0)
    start_occ = 1/(len(atom_groups) + 1)
    new_occ = self.GetNewOccupancy(start_occ, new=True)
    self._AddAtomGroup(
      item=self.GetItemParent(item),
      residue_group=residue_group,
      new_group=target_atom_group.detached_copy(),
      new_occ=new_occ)
    self._hierarchy.atoms().reset_i_seq()
    self.PushState("cloned atom group")

  # atom_group, residue_group
  def OnSeparateAtoms(self, event):
    item, pdb_object = self.GetSelectedObject()
    assert (type(pdb_object).__name__ in ["atom_group", "residue_group"])
    confirm_action("This action will divide all atoms in the selected "+
      "residue into separate residues, and renumber them starting "+
      "from 1.  Are you sure you want to do this?")
    if (type(pdb_object).__name__ == "atom_group"):
      self.SeparateAtoms(item, pdb_object)
    else :
      for atom_group in pdb_object.atom_groups():
        ag_item = self.FindItem(atom_group)
        self.SeparateAtoms(ag_item, atom_group)

  def SeparateAtoms(self, item, atom_group):
    import iotbx.pdb.hierarchy
    rg_item = self.GetItemParent(item)
    chain_item = self.GetItemParent(rg_item)
    assert (not None in [rg_item, chain_item])
    rg = atom_group.parent()
    chain = rg.parent()
    i = 1
    for atom in atom_group.atoms():
      atom_new = atom.detached_copy()
      atom_group.remove_atom(atom)
      atom_item = self.FindItem(atom)
      self.Delete(atom_item)
      ag_new = iotbx.pdb.hierarchy.atom_group(resname=atom_group.resname,
        altloc=atom_group.altloc)
      ag_new.append_atom(atom_new)
      rg_new = iotbx.pdb.hierarchy.residue_group(resseq="%d" % i)
      rg_new.append_atom_group(ag_new)
      chain.append_residue_group(rg_new)
      self._InsertResidueGroupItem(chain_item, rg_new)
      i += 1
    self.Delete(item)
    if (len(rg.atoms()) == 0):
      chain.remove_residue_group(rg)
      self.Delete(rg_item)
    self.PushState("split residue")

  # residue_group
  def OnSplitResidue(self, event):
    item, residue_group = self.GetSelectedObject('residue_group')
    atom_groups = residue_group.atom_groups()
    assert (len(atom_groups) > 0)
    start_occ = 1/(len(atom_groups) + 1)
    new_occ = self.GetNewOccupancy(start_occ, new=True)
    self._AddAtomGroup(
      item=item,
      residue_group=residue_group,
      new_group=atom_groups[0].detached_copy(),
      new_occ=new_occ)
    self._hierarchy.atoms().reset_i_seq()
    self.PushState("split residue")

  def _AddAtomGroup(self, item, residue_group, new_group, new_occ):
    atom_groups = residue_group.atom_groups()
    for atom in new_group.atoms():
      atom.occ = new_occ
    for atom_group in atom_groups :
      for atom in atom_group.atoms():
        atom.occ = max(0, atom.occ - new_occ/len(atom_groups))
    if (len(atom_groups) == 1):
      atom_groups[0].altloc = 'A'
      new_group.altloc = 'B'
    else :
      new_altloc = None
      for char in string.uppercase :
        for atom_group in atom_groups :
          if (atom_group.altloc == char):
            break
        else :
          new_altloc = char
      new_group.altloc = char
    residue_group.append_atom_group(new_group)
    self._InsertAtomGroupItem(item, new_group)
    self.PropagateAtomChanges(item)
    child, cookie = self.GetFirstChild(item)
    while (child is not None):
      atom_group = self.GetItemPyData(child)
      assert (type(atom_group).__name__ == 'atom_group')
      self.SetItemText(child, format_atom_group(atom_group))
      child, cookie = self.GetNextChild(item, cookie)
    self._hierarchy.atoms().reset_i_seq()

  # residue_group
  def OnInsertAfter(self, event):
    item, residue_group = self.GetSelectedObject('residue_group')
    new_residues = self.GetResiduesFromFile()
    chain = residue_group.parent()
    index = None
    for k, other_rg in enumerate(chain.residue_groups()):
      if (other_rg == residue_group):
        index = k+1
        break
    assert (index is not None)
    self._AddResidues(
      chain=chain,
      chain_node=self.GetItemParent(item),
      residues=new_residues,
      index=index)
    self._hierarchy.atoms().reset_i_seq()
    self.PushState("inserted %d residues" % len(new_residues))

  # chain
  def OnAddResidues(self, event):
    item, chain = self.GetSelectedObject('chain')
    new_residues = self.GetResiduesFromFile()
    index = self.GetInsertionIndex(chain)
    self._AddResidues(
      chain=chain,
      chain_node=item,
      residues=new_residues,
      index=index)
    self._hierarchy.atoms().reset_i_seq()
    self.PushState("added %d residues" % len(new_residues))

  # chain
  def OnMergeChain(self, event):
    item, chain = self.GetSelectedObject('chain')
    model = chain.parent()
    assert (len(model.chains()) > 1)
    target_chain = self.GetChainForMerging(model.chains(), chain)
    assert (chain != target_chain)
    target_item = self.FindItem(target_chain)
    assert (target_item is not None)
    index = self.GetInsertionIndex(target_chain)
    merge_residues = [ rg.detached_copy() for rg in chain.residue_groups() ]
    self._DeleteObject(item, chain)
    self._AddResidues(
      chain=target_chain,
      chain_node=target_item,
      residues=merge_residues,
      index=index)
    self._hierarchy.atoms().reset_i_seq()
    self.PushState("merged chain '%s' with chain '%s'" % (chain.id,
      target_chain.id))

  # model
  def OnAddChain(self, event):
    item, model = self.GetSelectedObject('model')
    new_chains = self.GetChainsFromFile()
    for chain in new_chains :
      model.append_chain(chain)
      self._InsertChainItem(item, chain)
    self._hierarchy.atoms().reset_i_seq()
    self.PushState("added %d chain(s) to model" % len(new_chains))
    self.Refresh()

  # model
  def OnSplitModel(self, event):
    item, model = self.GetSelectedObject('model')
    n_models = len(self._hierarchy.models())
    new_model = model.detached_copy()
    new_model.id = str(n_models + 1)
    self._hierarchy.append_model(new_model)
    root_node = self.GetRootItem()
    self._InsertModelItem(root_node, new_model)
    child, cookie = self.GetFirstChild(root_node)
    i_model = 1
    while (child is not None):
      other_model = self.GetItemPyData(child)
      assert (type(other_model).__name__ == 'model')
      other_model.id = str(i_model)
      self.SetItemText(child, format_model(other_model))
      child, cookie = self.GetNextChild(root_node, cookie)
      i_model += 1
    self._hierarchy.atoms().reset_i_seq()
    self.PushState("split model '%s'" % model.id)

  def _AddResidues(self, chain, chain_node, residues, index=None):
    for rg in residues :
      if (index is None):
        chain.append_residue_group(rg)
      else :
        chain.insert_residue_group(index, rg)
      self._InsertResidueGroupItem(chain_node, rg, index=index)
      if (index is not None):
        index += 1

  #---------------------------------------------------------------------
  # USER INPUT
  def GetNewName(self, name=None):
    dlg = simple_dialogs.StringDialog(
      parent=self,
      title="Set atom name",
      label="New name",
      caption="Please specify the atom name.  This is four characters in "+
        "length, but spaces will be added to the end if necessary.  Note that "+
        "leading spaces are significant, since they determine the column "+
        "alignment and the identity of the atom.  (For instance, 'CA  ' and "+
        "' CA ' have very different meanings.)",
      value=name)
    dlg.SetMinLength(1)
    dlg.SetMaxLength(4)
    dlg.SetOptional(False)
    return simple_dialogs.get_phil_value_from_dialog(dlg)

  def GetNewOccupancy(self, occ=None, new=False):
    desc_str = "selected"
    if (new):
      desc_str = "new"
    dlg = simple_dialogs.FloatDialog(
      parent=self,
      title="Set new occupancy",
      label="New occupancy",
      caption=("Please specify the occupancy for the %s atom(s); this "+
        "value represents the fraction of unit cells in which the atom(s) "+
        "is/are present, and must be a value between 0 (no contribution to "+
        "F_calc) and 1.0; note that atoms with multiple conformers should "+
        "always have a sum of occupancies of 1.0.  The precision will be "+
        "truncated to two digits after the decimal point.") % desc_str,
      value=occ)
    dlg.SetMin(0.0)
    dlg.SetMax(1.0)
    dlg.SetOptional(False)
    return simple_dialogs.get_phil_value_from_dialog(dlg)

  def GetNewBiso(self, b=None):
    dlg = simple_dialogs.FloatDialog(
      parent=self,
      title="Set new isotropic B-factor",
      label="New B_iso",
      caption="Please specify the isotropic B-factor for the selected "+
        "atom(s).  This should be a value between 0.01 and 999.9; if you "+
        "are not sure what value to use but will be performing refinement "+
        "on the modified PDB file, 20 is a good guess.  The precision will "+
        "be truncated to two digits after the decimal point.",
      value=b)
    dlg.SetMin(0.01)
    dlg.SetMax(999.99)
    dlg.SetOptional(False)
    return simple_dialogs.get_phil_value_from_dialog(dlg)

  def GetNewCharge(self, charge=None):
    if (charge is not None) and (charge.isspace()):
      charge = None
    elif (charge is not None):
      charge = int(charge)
    dlg = simple_dialogs.IntegerDialog(
      parent=self,
      title="Set new atomic charge",
      label="New charge",
      caption="Please specify the atomic charge; this should be a number "+
        "between -9 and 9, but usually between -2 and 2.  If you want to "+
        "set the charge to zero you can simply leave the field blank.",
      value=charge)
    dlg.SetMin(-9)
    dlg.SetMax(9)
    dlg.SetOptional(True)
    return simple_dialogs.get_phil_value_from_dialog(dlg)

  def GetNewElement(self, elem=None):
    if (elem is not None) and (elem.isspace()):
      elem = None
    dlg = simple_dialogs.StringDialog(
      parent=self,
      title="Set atomic element",
      label="Element symbol",
      caption="The atomic element field is optional if it can be guessed "+
        "based on the atom name, but it is best to specify explicitly.  It "+
        "must be one or two characters in length.",
      value=elem)
    dlg.SetMaxLength(2)
    dlg.SetOptional(True)
    return simple_dialogs.get_phil_value_from_dialog(dlg)

  def GetNewResseq(self, resseq):
    dlg = simple_dialogs.IntegerDialog(
      parent=self,
      title="Set residue number",
      label="Residue number",
      caption="The residue number can be any value, but the official PDB "+
        "format limits it to a range from -999 to 9999.  If you specify a "+
        "value outside of this range, it will be converted to Hybrid36 "+
        "encoding, which is recognized by Phenix, Coot, and CCP4, but not "+
        "by the PDB.",
      value=resseq)
    dlg.SetOptional(False)
    return simple_dialogs.get_phil_value_from_dialog(dlg)

  def GetNewResname(self, resname):
    dlg = simple_dialogs.StringDialog(
      parent=self,
      title="Set residue name",
      label="Residue code",
      caption="The residue name can be one to three characters, but is "+
        "nearly always three except for elemental ions.  Only alphanumeric "+
        "characters are allowed.",
      value=resname)
    dlg.SetMinLength(1)
    dlg.SetMaxLength(3)
    dlg.SetOptional(False)
    result = simple_dialogs.get_phil_value_from_dialog(dlg)
    if (not result.isalnum()):
      raise Sorry("Residue code must be alphanumeric (value: '%s')" % result)
    return result

  def GetNewIcode(self, icode):
    if (icode.isspace()):
      icode = None
    dlg = simple_dialogs.StringDialog(
      parent=self,
      title="Set residue insertion code",
      label="Insertion code",
      caption="The insertion code is a single character used to disambiguate "+
        "between multiple residues with identical numbering, such as "+
        "proteins where specific numbering is desired which may not match "+
        "the linear sequence (antibodies, proteases, proteins with "+
        "engineered insertions, etc.).",
      value=icode)
    dlg.SetMaxLength(1)
    dlg.SetOptional(True)
    return simple_dialogs.get_phil_value_from_dialog(dlg)

  def GetNewAltloc(self, altloc_id):
    if (altloc_id.isspace()):
      altloc_id = None
    dlg = simple_dialogs.StringDialog(
      parent=self,
      title="Set altloc ID",
      label="New altloc",
      caption="Please specify an altloc (i.e. conformation) identifier.  By "+
        "default this is left blank, unless the selected residue group "+
        "either has multiple conformations, or is present at partial "+
        "occupancy and interacts with one conformation of an adjacent "+
        "group.  Non-blank altloc IDs must be a single character, usually "+
        "uppercase letters.",
      value=altloc_id)
    #dlg.SetMinLength(1)
    dlg.SetMaxLength(1)
    return simple_dialogs.get_phil_value_from_dialog(dlg)

  def GetNewChainID(self, chain_id):
    if (chain_id.isspace()):
      chain_id = None
    dlg = simple_dialogs.StringDialog(
      parent=self,
      title="Set chain ID",
      label="New ID",
      caption="Please specify a chain ID.  If you have only a single chain "+
        "in your structure the chain ID may be left blank, but we recommend "+
        "labeling it 'A' instead.  Otherwise the chain ID may be up to two "+
        "characters in Phenix, Coot, and CCP4, but the official limit for "+
        "the format is one character.",
      value=chain_id)
    #dlg.SetMinLength(1)
    dlg.SetMaxLength(2)
    return simple_dialogs.get_phil_value_from_dialog(dlg)

  def GetNewSegID(self, segid):
    if (segid is not None) and (segid.isspace()):
      segid = None
    dlg = simple_dialogs.StringDialog(
      parent=self,
      title="Set segment ID",
      label="New ID",
      caption="The segment ID (segid) is an optional field for disambiguating "+
        "between chains with identical IDs, or for otherwise flagging part of "+
        "the model.  It may be up to four characters in length (with spaces "+
        "significant).  Note that while most programs in Phenix should "+
        "preserve the segid and use it for atom selections, it is no longer "+
        "accepted as part of the official PDB format.",
      value=segid)
    dlg.SetMaxLength(4)
    dlg.SetOptional(True)
    return simple_dialogs.get_phil_value_from_dialog(dlg)

  def GetResseqShift(self):
    dlg = simple_dialogs.IntegerDialog(
      parent=self,
      title="Shift residue numbers",
      label="Increment by",
      caption="You may shift the residue numbers by any amount, even if this "+
        "will make them negative; note however that the official PDB format "+
        "is limited to residue numbers between -999 and 999.  (PHENIX and "+
        "other programs can handle a much larger range using Hybrid36 "+
        "encoding, but this is not supported by the PDB.)",
      value=None)
    dlg.SetOptional(False)
    return simple_dialogs.get_phil_value_from_dialog(dlg)

  def _GetPDBFile(self):
    from iotbx import file_reader
    file_name = self.path_mgr.select_file(
      parent=self,
      message="Select PDB file to insert",
      wildcard=file_reader.get_wildcard_strings(["pdb"]))
    pdb_in = file_reader.any_file(to_str(file_name),
      force_type="pdb",
      raise_sorry_if_errors=True)
    hierarchy = pdb_in.file_object.hierarchy
    if (len(hierarchy.models()) > 1):
      raise Sorry("Multi-MODEL PDB files not supported for this action.")
    return hierarchy

  def GetChainForMerging(self, chains, merge_chain):
    assert (len(chains) > 1)
    dlg = SelectChainDialog(
      parent=self,
      title="Select chain to merge with",
      message=("You have selected to merge the chain '%s' (%d residues) with "+
        "another chain in the model; please select a target chain.") %
        (merge_chain.id, len(merge_chain.residue_groups())),
      chains=chains,
      exclude_chain=merge_chain)
    target_chain = None
    if (dlg.ShowModal() == wx.ID_OK):
      target_chain = dlg.GetChain()
    wx.CallAfter(dlg.Destroy)
    if (target_chain is None) : raise Abort()
    return target_chain

  def GetChainsFromFile(self):
    hierarchy = self._GetPDBFile()
    chains = hierarchy.models()[0].chains()
    if (len(chains) == 1):
      return [ chains[0].detached_copy() ]
    else :
      dlg = SelectChainDialog(
        parent=self,
        title="Select chains to add",
        message="Multiple chains were found in this PDB file; you may insert "+
          "them all at once, or one at a time.",
        chains=chains,
        allow_all_chains=True)
      add_chains = None
      if (dlg.ShowModal() == wx.ID_OK):
        add_chains = dlg.GetChains()
      wx.CallAfter(dlg.Destroy)
      if (add_chains is None) : raise Abort()
      return [ c.detached_copy() for c in add_chains ]

  def GetResiduesFromFile(self):
    hierarchy = self._GetPDBFile()
    chains = hierarchy.models()[0].chains()
    if (len(chains) == 1):
      return [ rg.detached_copy() for rg in chains[0].residue_groups() ]
    else :
      dlg = SelectChainDialog(
        parent=self,
        title="Select residues to add",
        message="Multiple chains were found in this PDB file; please select "+
          "the one containing the residues you wish to insert into the "+
          "selected chain.",
        chains=chains,
        allow_all_chains=False,
        show_residue_range=True)
      add_chains = resseq_start = resseq_end = None
      if (dlg.ShowModal() == wx.ID_OK):
        add_chains = dlg.GetChains()
        resseq_start, resseq_end = dlg.GetResseqRange()
      wx.CallAfter(dlg.Destroy)
      if (add_chains is None) : raise Abort()
      return [ rg.detached_copy() for rg in add_chains[0].residue_groups() ]

  def GetInsertionIndex(self, chain):
    dlg = AddResiduesDialog(
      parent=self,
      title="Insert residues")
    insert_type = resid = None
    if (dlg.ShowModal() == wx.ID_OK):
      insert_type = dlg.GetInsertionType()
      resid = dlg.GetResID()
    wx.CallAfter(dlg.Destroy)
    if (insert_type is None):
      raise Abort()
    elif (insert_type == ADD_RESIDUES_START):
      return 0
    elif (insert_type == ADD_RESIDUES_END):
      return None
    else :
      if (resid is None):
        raise Sorry("You need to specify a residue ID to insert after.")
      for k, residue_group in enumerate(chain.residue_groups()):
        if (residue_group.resid().strip() == resid.strip()):
          return k + 1
      raise Sorry("The residue ID %s was not found in the target chain." %
        resid.strip())

  def GetAtomType(self, atom_type):
    dlg = simple_dialogs.ChoiceDialog(
      parent=self,
      title="Set atom record type",
      label="Record type",
      value=None,
      caption="Please select the label for the selected atom record(s).  "+
        "This will not affect the refinement or visualization of these "+
        "atoms, but HETATM records may be handled differently by some "+
        "programs (including Phaser).")
    if (atom_type in ["ATOM", None]):
      dlg.SetChoices(["*ATOM", "HETATM"])
    else :
      dlg.SetChoices(["ATOM", "*HETATM"])
    new_type = None
    if (dlg.ShowModal() == wx.ID_OK):
      new_type = dlg.GetPhilValue()
    wx.CallAfter(dlg.Destroy)
    if (new_type is None):
      raise Abort()
    return new_type

########################################################################
# AUXILARY GUI CLASSES
class PDBTreeDropTarget(wx.DropTarget):
  def __init__(self, tree):
    wx.DropTarget.__init__(self)
    self.tree = tree
    #self.df = wx.CustomDataFormat("pdb_object")
    #self.cdo = wx.CustomDataObject(self.df)
    #self.SetDataObject(self.cdo)

  def OnDrop(self, x, y):
    return self.tree.OnDrop(x,y)

  def OnEnter(self, x, y, d):
    return d

  def OnDragOver(self, x, y, d):
    print(x, y, d)
    return d

  def OnData(self, x, y, d):
    return d

########################################################################
# INPUT DIALOGS
ADD_RESIDUES_START = 0
ADD_RESIDUES_END = 1
ADD_RESIDUES_AFTER = 2
class AddResiduesDialog(wx.Dialog):
  def __init__(self, *args, **kwds):
    super(AddResiduesDialog, self).__init__(*args, **kwds)
    style = self.GetWindowStyle()
    style |= wx.WS_EX_VALIDATE_RECURSIVELY|wx.RAISED_BORDER|wx.CAPTION
    self.SetWindowStyle(style)
    szr = wx.BoxSizer(wx.VERTICAL)
    self.SetSizer(szr)
    caption_txt = wx.StaticText(self, -1, "Please specify where to insert "+
      "the new residue.  The residue ID is the combination of residue number "+
      "and insertion code, but you only need to specify the residue number "+
      "if the insertion code is blank or irrelevant.")
    caption_txt.Wrap(480)
    szr.Add(caption_txt, 0, wx.ALL, 5)
    box = wx.BoxSizer(wx.HORIZONTAL)
    txt1 = wx.StaticText(self, -1, "Insert residues:")
    box.Add(txt1, 0, wx.ALL|wx.ALIGN_CENTER_VERTICAL, 5)
    self._insert_choice = wx.Choice(self, -1,
      choices=["at the start of the chain",
               "at the end of the chain",
               "after residue"])
    self._insert_choice.SetSelection(ADD_RESIDUES_END)
    self.Bind(wx.EVT_CHOICE, self.OnChangeInsertion, self._insert_choice)
    box.Add(self._insert_choice, 0, wx.ALL|wx.ALIGN_CENTER_VERTICAL, 5)
    txt2 = wx.StaticText(self, -1, "residue ID:")
    box.Add(txt2, 0, wx.ALL|wx.ALIGN_CENTER_VERTICAL, 5)
    self._resid_txt = strctrl.StrCtrl(
      parent=self,
      value=None,
      size=(80,-1))
    self._resid_txt.SetOptional(True)
    self._resid_txt.Enable(False)
    self._resid_txt.SetMaxLength(5)
    self._resid_txt.SetMinLength(1)
    box.Add(self._resid_txt, 0, wx.ALL|wx.ALIGN_CENTER_VERTICAL, 5)
    szr.Add(box)
    cancel_btn = wx.Button(self, wx.ID_CANCEL)
    ok_btn = wx.Button(self, wx.ID_OK)
    ok_btn.SetDefault()
    szr4 = wx.StdDialogButtonSizer()
    szr4.Add(cancel_btn)
    szr4.Add(ok_btn, 0, wx.LEFT, 5)
    szr.Add(szr4, 0, wx.ALL|wx.ALIGN_RIGHT, 5)
    szr.Layout()
    self.Fit()
    self.Centre(wx.BOTH)

  def OnChangeInsertion(self, event):
    insert_type = self._insert_choice.GetSelection()
    if (insert_type == ADD_RESIDUES_AFTER):
      self._resid_txt.SetOptional(False)
      self._resid_txt.Enable()
    else :
      self._resid_txt.SetOptional(True)
      self._resid_txt.Enable(False)

  def GetInsertionType(self):
    return self._insert_choice.GetSelection()

  def GetResID(self):
    return self._resid_txt.GetPhilValue()

class SelectChainDialog(wx.Dialog):
  def __init__(self, parent, title, message, chains, allow_all_chains=False,
      show_residue_range=False, exclude_chain=None):
    self._chains = []
    for chain in chains :
      if (chain != exclude_chain):
        self._chains.append(chain)
    self.allow_all_chains = allow_all_chains
    super(SelectChainDialog, self).__init__(parent=parent, title=title,
      style=wx.WS_EX_VALIDATE_RECURSIVELY|wx.RAISED_BORDER|wx.CAPTION)
    style = self.GetWindowStyle()
    style |= wx.WS_EX_VALIDATE_RECURSIVELY|wx.RAISED_BORDER|wx.CAPTION
    self.SetWindowStyle(style)
    szr = wx.BoxSizer(wx.VERTICAL)
    self.SetSizer(szr)
    caption_txt = wx.StaticText(self, -1, message)
    caption_txt.Wrap(480)
    szr.Add(caption_txt, 0, wx.ALL, 5)
    box = wx.FlexGridSizer(rows=2, cols=2)
    txt1 = wx.StaticText(self, -1, "Select chain:")
    box.Add(txt1, 0, wx.ALL|wx.ALIGN_CENTER_VERTICAL, 5)
    choices = []
    if (allow_all_chains):
      choices.append("All")
    for chain in self._chains :
      n_rg = len(chain.residue_groups())
      choices.append("chain '%s' (%d residues)" % (chain.id, n_rg))
    self._chain_choice = wx.Choice(self, -1, choices=choices)
    box.Add(self._chain_choice, 0, wx.ALL|wx.ALIGN_CENTER_VERTICAL, 5)
    if (show_residue_range):
      txt2 = wx.StaticText(self, -1, "Residue range (optional):")
      box.Add(txt2, 0, wx.ALL|wx.ALIGN_CENTER_VERTICAL, 5)
      box2 = wx.BoxSizer(wx.HORIZONTAL)
      box.Add(box2)
      self._resseq_start = intctrl.IntCtrl(
        parent=self,
        name="Starting resseq",
        value=None)
      self._resseq_start.SetOptional(True)
      self._resseq_end = intctrl.IntCtrl(
        parent=self,
        name="Ending resseq",
        value=None)
      self._resseq_end.SetOptional(False)
      txt3 = wx.StaticText(self, -1, "to")
      box2.Add(self._resseq_start, 0, wx.ALL|wx.ALIGN_CENTER_VERTICAL, 5)
      box2.Add(txt3, 0, wx.ALL|wx.ALIGN_CENTER_VERTICAL, 5)
      box2.Add(self._resseq_end, 0, wx.ALL|wx.ALIGN_CENTER_VERTICAL, 5)
    else :
      self._resseq_start = self._resseq_end = None
    szr.Add(box)
    cancel_btn = wx.Button(self, wx.ID_CANCEL)
    ok_btn = wx.Button(self, wx.ID_OK)
    ok_btn.SetDefault()
    szr4 = wx.StdDialogButtonSizer()
    szr4.Add(cancel_btn)
    szr4.Add(ok_btn, 0, wx.LEFT, 5)
    szr.Add(szr4, 0, wx.ALL|wx.ALIGN_RIGHT, 5)
    szr.Layout()
    self.Fit()
    self.Centre(wx.BOTH)

  def GetChains(self):
    chain_sel = self._chain_choice.GetSelection()
    if (self.allow_all_chains):
      if (chain_sel == 0):
        return self._chains
      else :
        chain_sel -= 1
    return [ self._chains[chain_sel] ]

  def GetChain(self):
    assert (not self.allow_all_chains)
    return self.GetChains()[0]

  def GetResseqRange(self):
    assert (not None in [self._resseq_start, self._resseq_end])
    return self._resseq_start.GetPhilValue(), self._resseq_end.GetPhilValue()

########################################################################
class PDBTreeFrame(wx.Frame):
  def __init__(self, *args, **kwds):
    wx.Frame.__init__(self, *args, **kwds)
    self.statusbar = self.CreateStatusBar()
    self.statusbar.SetStatusText("Right-click any item for a list of editing actions")
    # panel setup
    szr = wx.BoxSizer(wx.VERTICAL)
    self.SetSizer(szr)
    self.panel = wx.Panel(self, -1)
    szr.Add(self.panel, 1, wx.EXPAND)
    pszr = wx.BoxSizer(wx.VERTICAL)
    self.panel.SetSizer(pszr)
    szr2 = wx.BoxSizer(wx.HORIZONTAL)
    szr2.Add(wx.StaticText(self.panel, -1, "PDB file:"), 0,
      wx.ALL|wx.ALIGN_CENTER_VERTICAL, 5)
    self._path_field = wx.TextCtrl(self.panel, -1, size=(540,-1))
    szr2.Add(self._path_field, 1, wx.ALL|wx.ALIGN_CENTER_VERTICAL, 5)
    pszr.Add(szr2, 0, wx.EXPAND)
    szr3 = wx.BoxSizer(wx.HORIZONTAL)
    self._header_box = wx.CheckBox(self.panel, -1,
      "Preserve header records when saving file")
    self._header_box.SetValue(False)
    szr3.Add(self._header_box, 0, wx.ALL|wx.ALIGN_CENTER_VERTICAL, 5)
    self._serial_box = wx.CheckBox(self.panel, -1,
      "Reset atom serial numbers")
    self._serial_box.SetValue(True)
    szr3.Add(self._serial_box, 0, wx.ALL|wx.ALIGN_CENTER_VERTICAL, 5)
    pszr.Add(szr3, 0, wx.EXPAND)
    self._tree = PDBTree(self.panel, -1, style=wx.RAISED_BORDER)
    self._tree.SetMinSize((640,400))
    pszr.Add(self._tree, 1, wx.EXPAND, 2)
    # toolbar setup
    self.toolbar = self.CreateToolBar(style=wx.TB_TEXT)
    if wx.VERSION < (4,0):
      self.toolbar.AddTool = self.toolbar.AddLabelTool
    bmp = wxtbx.bitmaps.fetch_custom_icon_bitmap("phenix.pdbtools")
    btn = self.toolbar.AddTool(-1, "Load file", bmp,
      shortHelp="Load file", kind=wx.ITEM_NORMAL)
    self.Bind(wx.EVT_MENU, self.OnOpen, btn)
    bmp = wxtbx.bitmaps.fetch_icon_bitmap("actions", "save_all")
    btn = self.toolbar.AddTool(-1, "Save file", bmp,
      shortHelp="Save file", kind=wx.ITEM_NORMAL)
    self.Bind(wx.EVT_MENU, self.OnSave, btn)
    self.toolbar.AddSeparator()
    bmp = wxtbx.bitmaps.fetch_custom_icon_bitmap("tools")
    btn = self.toolbar.AddTool(-1, "Edit...", bmp, shortHelp="Edit...",
      kind=wx.ITEM_NORMAL)
    self.Bind(wx.EVT_MENU, self.OnEditModel, btn)
    bmp = wxtbx.bitmaps.fetch_custom_icon_bitmap("symmetry")
    btn = self.toolbar.AddTool(-1, "Symmetry", bmp, shortHelp="Symmetry",
      kind=wx.ITEM_NORMAL)
    self.Bind(wx.EVT_MENU, self.OnEditSymmetry, btn)
    bmp = wxtbx.bitmaps.fetch_icon_bitmap("actions", "editdelete")
    btn = self.toolbar.AddTool(-1, "Delete", bmp, shortHelp="Delete",
      kind=wx.ITEM_NORMAL)
    self.Bind(wx.EVT_MENU, self._tree.OnDeleteObject, btn)
    self.toolbar.Realize()
    # menu setup
    menu_bar = wx.MenuBar()
    file_menu = wx.Menu()
    menu_bar.Append(file_menu, "File")
    item = file_menu.Append(-1, "&Open file\tCtrl-O")
    self.Bind(wx.EVT_MENU, self.OnOpen, item)
    item = file_menu.Append(-1, "&Quit\tCtrl-Q")
    self.Bind(wx.EVT_MENU, self.OnClose, item)
    edit_menu = wx.Menu()
    #menu_bar.Append(edit_menu, "Edit")
    self.undo_item = edit_menu.Append(-1, "&Undo\tCtrl-Z")
    self.redo_item = edit_menu.Append(-1, "&Redo\tCtrl-Y")
    self.undo_item.Enable(False)
    self.redo_item.Enable(False)
    self.Bind(wx.EVT_MENU, self.OnUndo, self.undo_item)
    self.Bind(wx.EVT_MENU, self.OnRedo, self.redo_item)
    self.SetMenuBar(menu_bar)
    #
    self._pdb_in = None
    self._crystal_symmetry = None
    szr.Layout()
    self.Fit()
    self.Bind(wx.EVT_CLOSE, self.OnClose)
    self.Bind(wx.EVT_WINDOW_DESTROY, self.OnDestroy, self)
    self.path_mgr = self._tree.path_mgr
    self._callback = None
    self._callback_program = None

  def LoadPDB(self, file_name):
    from iotbx import file_reader
    f = file_reader.any_file(file_name,
      force_type="pdb",
      raise_sorry_if_errors=True)
    self._pdb_in = f
    self._crystal_symmetry = f.crystal_symmetry()
    hierarchy = f.file_object.hierarchy
    self._hierarchy = hierarchy
    atoms = hierarchy.atoms()
    atoms.reset_i_seq()
    atoms.set_chemical_element_simple_if_necessary()
    self._tree.SetHierarchy(hierarchy)
    self._tree.SetCrystalSymmetry(self._crystal_symmetry)
    self._path_field.SetValue(os.path.abspath(to_unicode(f.file_name)))
    self._tree.SetFocus()
    self.Refresh()

  def OnOpen(self, event):
    from iotbx import file_reader
    file_name = self.path_mgr.select_file(
      parent=self,
      message="Select PDB file",
      wildcard=file_reader.get_wildcard_strings(["pdb"]))
    self.LoadPDB(to_str(file_name))

  def OnSave(self, event):
    if (self._pdb_in is None):
      return
    self.Save()

  def Save(self):
    from iotbx import file_reader
    input_file = os.path.abspath(self._pdb_in.file_name)
    output_file = os.path.splitext(input_file)[0] + "_edited.pdb"
    file_name = self.path_mgr.select_file(
      parent=self,
      message="Save PDB file",
      style=wx.FD_SAVE,
      wildcard=file_reader.get_wildcard_strings(["pdb"]),
      current_file=output_file)
    save_header = self._header_box.GetValue()
    f = open(file_name, "w")
    for method in ["title_section",] :
      section_lines = getattr(self._pdb_in.file_object.input, method)()
      for line in section_lines :
        f.write(line + "\n")
    if (save_header):
      wx.MessageBox("Warning: any atom selections present in the PDB header "+
        "may be invalidated by model modifications!  Please use caution "+
        "when using the modified PDB file in any downstream applications.")
      for method in [
          "remark_section",
          "heterogen_section",
          "secondary_structure_section",] :
        section_lines = getattr(self._pdb_in.file_object.input, method)()
        for line in section_lines :
          f.write(line + "\n")
    reset_serial = self._serial_box.GetValue()
    if (reset_serial):
      self._hierarchy.atoms().reset_serial()
    pdb_out = self._hierarchy.as_pdb_string(
      crystal_symmetry=self._crystal_symmetry)
    for line in pdb_out.splitlines():
      if (not line.startswith("BREAK")):
        f.write("%s\n" % line)
    f.write("END")
    f.close()
    self._tree.SaveChanges()
    if (self._callback is not None):
      confirm_action(("Modified structure saved to %s.  Do you want "+
        "to update the file path in %s?") % (to_str(file_name),
                                             self._callback_program))
      self._callback(old_file_name=self._pdb_in.file_name,
                     new_file_name=to_str(file_name))
    else :
      wx.MessageBox("Modified structure saved to %s." % file_name)

  def OnEditSymmetry(self, event):
    dlg = symmetry_dialog.SymmetryDialog(parent=self,
      title="Edit model symmetry (CRYST1 record)",
      caption="Please enter the symmetry information for the PDB file; this "+
        "is optional or ignored in some cases (such as molecular replacement "+
        "search models), but required for many crystallography programs.")
    dlg.SetSymmetry(self._crystal_symmetry)
    if (dlg.ShowModal() == wx.ID_OK):
      old_symm = self._crystal_symmetry
      symm = dlg.GetSymmetry(allow_incomplete=True)
      #if (symm.space_group() is None) and (old_symm.space_group() is not None):
      self._crystal_symmetry = symm
    wx.CallAfter(dlg.Destroy)

  def OnEditModel(self, event):
    self._tree.ActionsForSelection(source_window=event.GetEventObject())

  def OnClose(self, event):
    if (self._pdb_in is not None) and (self._tree.HaveUnsavedChanges()):
      confirm = wx.MessageBox("You have unsaved changes - do you want to "+
        "save the modified PDB file now?", style=wx.YES_NO)
      if (confirm == wx.YES):
        self.Save()
    self.Destroy()

  def OnUndo(self, event):
    self._tree.Undo()

  def OnRedo(self, event):
    self._tree.Redo()

  def EnableRedo(self, enable=True):
    self.redo_item.Enable(enable)

  def EnableUndo(self, enable=True):
    self.undo_item.Enable(enable)

  def OnDestroy(self, event):
    pass

  def SetCallback(self, callback, program_name):
    self._callback = callback
    self._callback_program = program_name

def confirm_action(msg):
  confirm = wx.MessageBox(
    message=msg,
    style=wx.YES_NO|wx.ICON_QUESTION)
  if (confirm == wx.NO):
    raise Abort()
  return True


 *******************************************************************************


 *******************************************************************************
wxtbx/phil_controls/__init__.py
from __future__ import absolute_import, division, print_function

from libtbx.utils import Sorry
from libtbx import Auto
import wx

class PhilCtrl(object):
  def __init__(self):
    self.phil_name = None
    self.optional = False
    self._none_is_auto = False
    self._wxtbx_style = 0

  def SetUseAuto(self, enable=True):
    self._none_is_auto = enable

  def UseAuto(self):
    return getattr(self, "_none_is_auto", False)

  def ReturnNoneIfOptional(self):
    if (self.IsOptional()):
      if (self.UseAuto()):
        return Auto
      return None
    else :
      raise Sorry("Value required for '%s'." % self.GetName())

  def SetOptional(self, optional=True):
    if (optional is None) : optional = True
    self.optional = optional

  def IsOptional(self):
    return getattr(self, "optional", True)

  def SetPhilName(self, name):
    self.phil_name = name

  def GetPhilName(self):
    return getattr(self, "phil_name", None)

  def GetStringValue(self):
    raise NotImplementedError()

  def GetPhil(self, full_path=True, indent=0):
    assert (self.phil_name is not None)
    value = self.GetStringValue()
    if (full_path):
      phil_name = self.phil_name
    else :
      phil_name = self.phil_name.split(".")[-1]
    format = "%s%s = %s"
    return format % (" "*indent, phil_name, value)

  def __str__(self):
    return type(self).__name__ + (" (%s)" % self.phil_name)

  def DoSendEvent(self, original_window=None):
    event = PhilCtrlEvent(wxEVT_PHIL_CONTROL, self.GetId())
    event.SetEventObject(self)
    if (original_window is not None):
      event.SetOriginalWindow(original_window)
    self.GetEventHandler().ProcessEvent(event)

  def GetWxtbxStyle(self):
    return self._wxtbx_style

  def SetWxtbxStyle(self, style):
    assert isinstance(style, int)
    self._wxtbx_style = style
    return self

wxEVT_PHIL_CONTROL = wx.NewEventType()
EVT_PHIL_CONTROL = wx.PyEventBinder(wxEVT_PHIL_CONTROL, 1)
class PhilCtrlEvent(wx.PyCommandEvent):
  def __init__(self, eventType, eventId):
    wx.PyCommandEvent.__init__(self, eventType, eventId)
    self._original_window = None

  def SetOriginalWindow(self, window):
    assert isinstance(window, wx.Window)
    self._original_window = window

  def GetOriginalWindow(self):
    return self._original_window


 *******************************************************************************


 *******************************************************************************
wxtbx/phil_controls/array_label.py
from __future__ import absolute_import, division, print_function

from six import string_types
from wxtbx import phil_controls
import wx

class ArrayLabelCtrl(wx.Choice, phil_controls.PhilCtrl):
  def __init__(self, *args, **kwds):
    super(ArrayLabelCtrl, self).__init__(*args, **kwds)
    self._default_value = "---"
    self.Bind(wx.EVT_CHOICE, self.OnChoose)

  def SetLabel(self, label):
    print(label)
    print(type(label))
    assert (isinstance(label, string_types) or (label is None))
    if (label is None):
      self.SetSelection(0)
    else :
      self.SetStringSelection(label)

  def SetLabelChoices(self, labels):
    old_label = self.GetStringSelection()
    self.SetItems([self._default_value] + labels)
    if (old_label in labels):
      self.SetLabel(old_label)
    else :
      self.SetLabel(labels[0])
    self.Layout()

  def GetPhilValue(self):
    value = self.GetStringSelection()
    if (value == self._default_value) or (value == ""):
      return None
    else :
      return value

  def GetStringVAlue(self):
    return str(self.GetPhilValue())

  def OnChoose(self, event):
    label = self.GetPhilValue()
    print(label)

class ArrayLabelsCtrl(ArrayLabelCtrl):
  def SetLabel(self, label):
    if (isinstance(label, list)):
      assert (len(label) == 1)
      ArrayLabelCtrl.SetLabel(self, label[0])
    else :
      ArrayLabelCtrl.SetLabel(self, label)

  def GetPhilValue(self):
    value = self.GetStringSelection()
    if (value == self._default_value) or (value == ""):
      return None
    else :
      return [value]

  def GetStringVAlue(self):
    return str(ArrayLabelCtrl.GetPhilValue(self))

# testing
if (__name__ == "__main__"):
  app = wx.App(0)
  frame = wx.Frame(None, -1, "Array label test")
  panel = wx.Panel(frame, -1, size=(640,480))
  txt1 = wx.StaticText(panel, -1, "Data labels:", pos=(20,180))
  choice_ctrl = ArrayLabelCtrl(panel, -1, pos=(240,180), size=(160,-1),
    name="Data labels")
  assert (choice_ctrl.GetPhilValue() is None)
  choices1 = ["F,SIGF", "F(+),SIGF(+),F(-),SIGF(-)", "IMEAN,SIGIMEAN"]
  choice_ctrl.SetLabelChoices(choices1)
  assert (choice_ctrl.GetPhilValue() == "F,SIGF")
  choices2 = ["F(+),SIGF(+),F(-),SIGF(-)", "I(+),SIGI(+),I(-),SIGI(-)",
    "IMEAN,SIGIMEAN", "F,SIGF"]
  choice_ctrl.SetLabelChoices(choices2)
  assert (choice_ctrl.GetPhilValue() == "F,SIGF")
  frame.Fit()
  frame.Show()
  app.MainLoop()


 *******************************************************************************


 *******************************************************************************
wxtbx/phil_controls/boolctrl.py
from __future__ import absolute_import, division, print_function

from wxtbx import phil_controls
import wx
from libtbx import Auto

WXTBX_PHIL_BOOL_TRIBOOL = 1
WXTBX_PHIL_BOOL_AUTO = 2

class BoolCtrl(wx.CheckBox, phil_controls.PhilCtrl):
  def __init__(self, *args, **kwds):
    kwds = dict(kwds)
    self._bool_style = kwds.get("style", 0)
    kwds['style'] = 0
    if ((self._bool_style & WXTBX_PHIL_BOOL_TRIBOOL) or
        (self._bool_style & WXTBX_PHIL_BOOL_AUTO)):
      kwds['style'] |= wx.CHK_ALLOW_3RD_STATE_FOR_USER|wx.CHK_3STATE
    else :
      kwds['style'] |= wx.CHK_3STATE # wx.CHK_ALLOW_3RD_STATE_FOR_USER?
    wx.CheckBox.__init__(self, *args, **kwds)
    self.Bind(wx.EVT_CHECKBOX, lambda evt: self.DoSendEvent())

  def SetValue(self, value):
    if (value is None) or (value is Auto):
      assert (self.Is3State())
      self.Set3StateValue(wx.CHK_UNDETERMINED)
    else :
      if (self.Is3State()):
        if (value == True):
          self.Set3StateValue(wx.CHK_CHECKED)
        else :
          self.Set3StateValue(wx.CHK_UNCHECKED)
      else :
        wx.CheckBox.SetValue(self, value)

  def GetValue(self):
    if (self.Is3State()):
      value = self.Get3StateValue()
      if (value == wx.CHK_UNDETERMINED):
        if (self._bool_style & WXTBX_PHIL_BOOL_AUTO):
          return Auto
        else :
          return None
      else :
        return (value == wx.CHK_CHECKED)
    else :
      return wx.CheckBox.GetValue(self)

  def GetPhilValue(self):
    return self.GetValue()

  def GetStringValue(self):
    return str(self.GetValue())

if (__name__ == "__main__"):
  app = wx.App(0)
  frame = wx.Frame(None, -1, "PHIL bool test")
  panel = wx.Panel(frame, -1, size=(600,400))
  box1 = BoolCtrl(panel, label="Use NCS restraints", pos=(100,100))
  box2 = BoolCtrl(panel, label="Find NCS groups automatically", pos=(100,150))
  box3 = BoolCtrl(panel, label="Fast search mode", pos=(100,200),
    style=WXTBX_PHIL_BOOL_AUTO)
  box1.SetValue(False)
  box2.SetValue(None)
  box3.SetValue(Auto)
  assert (box1.GetValue() == box1.GetPhilValue() == False)
  assert (box2.GetValue() is None)
  assert (box3.GetValue() is Auto)
  assert (box2.GetStringValue() == "None")
  assert (box3.GetStringValue() == "Auto")
  box3.SetValue(False)
  assert (box3.GetStringValue() == "False")
  box1.SetValue(True)
  assert (box1.GetStringValue() == "True")
  def OnChange(event):
    print(event.GetEventObject().GetPhilValue())
  frame.Bind(phil_controls.EVT_PHIL_CONTROL, OnChange)
  frame.Show()
  app.MainLoop()


 *******************************************************************************


 *******************************************************************************
wxtbx/phil_controls/choice.py
from __future__ import absolute_import, division, print_function

from wxtbx import phil_controls
import wx
import re

class ChoiceCtrl(wx.Choice, phil_controls.PhilCtrl):
  def __init__(self, *args, **kwds):
    super(ChoiceCtrl, self).__init__(*args, **kwds)
    self._options = None
    self.Bind(wx.EVT_CHOICE, lambda evt: self.DoSendEvent(), self)

  def SetChoices(self, choices, captions=None, allow_none=True):
    selection = None
    is_selected = [ ("*" in choice) for choice in choices ]
    if (True in is_selected):
      selection = is_selected.index(True)
    choices = [ re.sub(r"\*", "", choice) for choice in choices ]
    if (captions is None):
      captions = list(choices) # XXX force copy
    if (len(captions) != len(choices)):
      raise RuntimeError("Wrong number of caption items for '%s':\n%s\n%s" %
        (self.GetName(), ";".join(choices), ";".join(captions)))
    if (selection is None) and (allow_none):
      captions.insert(0, "---")
      choices.insert(0, None)
      selection = 0
    # not ideal, but changing "selection = None" to "selection = 0" can break
    # other choice widgets in other GUI panels
    if (selection is None) and not (allow_none):
      selection = 0
    self._options = choices
    self.SetItems(captions)
    self.SetSelection(selection)

  def SetValue(self, value):
    selection = self._options.index(value)
    self.SetSelection(selection)

  def GetValue(self):
    raise NotImplementedError("Please use GetPhilValue()")

  def GetPhilValue(self):
    """Returns a single string."""
    return self._options[self.GetSelection()]

  def GetStringValue(self):
    """Returns the long format (all choices, '*' denotes selected)."""
    selection = self.GetSelection()
    choices_out = []
    for i, choice in enumerate(self._options):
      if (choice is None):
        continue
      elif (i == selection):
        choices_out.append("*" + choice)
      else :
        choices_out.append(choice)
    return " ".join(choices_out)

if (__name__ == "__main__"):
  app = wx.App(0)
  frame = wx.Frame(None, -1, "Choice test")
  panel = wx.Panel(frame, -1, size=(720,480))
  txt1 = wx.StaticText(panel, -1, "NCS restraint type:", pos=(20,180))
  choice1 = ChoiceCtrl(panel, -1, pos=(240,180))
  choice1.SetChoices(["torsion","dihedral"])
  txt2 = wx.StaticText(panel, -1, "Output map format:", pos=(20, 240))
  choice2 = ChoiceCtrl(panel, -1, pos=(240,240))
  choice2.SetChoices(["*ccp4", "xplor"], ["CCP4", "X-PLOR"])
  choice1.SetValue("torsion")
  assert (choice1.GetPhilValue() == "torsion")
  choice1.SetValue(None)
  assert (choice1.GetPhilValue() == None)
  assert (choice1.GetStringValue() == "torsion dihedral")
  assert (choice2.GetPhilValue() == "ccp4")
  assert (choice2.GetStringValue() == "*ccp4 xplor")
  frame.Fit()
  frame.Show()
  app.MainLoop()


 *******************************************************************************


 *******************************************************************************
wxtbx/phil_controls/choice_multi.py
from __future__ import absolute_import, division, print_function

from wxtbx import phil_controls
import wx
import six
from six.moves import zip

class MultiChoiceCtrl(wx.Panel, phil_controls.PhilCtrl):
  """
  Control for phil type 'choice(multi=True)'

  Composed of a grid of checkboxes, any or none of which may be checked.
  Each choice may be associated with an action upon clicking, such as
  opening a dialog, or with a contextual menu.

  In phil syntax, choices may be specified one of two ways:

    strategy=individual_adp+individual_sites+occupancies

    strategy = *individual_adp *individual_sites group_adp tls \
               *occupancies group_anomalous

  The first is typically used on the command line, the latter is used in
  parameter files.  When extracted as a Python object, the parameter will be
  a list of strings corresponding to the selected choices.
  """
  def __init__(self, *args, **kwds):
    super(MultiChoiceCtrl, self).__init__(*args, **kwds)
    self._n_columns = 3
    self._sizer = wx.FlexGridSizer(cols=self._n_columns, hgap=20, vgap=5)
    self.SetSizer(self._sizer)
    self._option_names = []
    self._option_controls = {}

  def SetCols(self, n_columns):
    self._n_columns = n_columns
    self._sizer.SetCols(n_columns)
    if (len(self._option_controls) > 0):
      self.Realize()

  def SetToolTip(self, tooltip):
    super(MultiChoiceCtrl, self).SetToolTip(tooltip)
    for key, ctrl in six.iteritems(self._option_controls):
      # Never reuse a Tooltip as this will may lead to a nasty crash of Python
      # So create a new tooltip for each additional control
      newtt = wx.ToolTip(tooltip.GetTip())
      ctrl.SetToolTip(newtt)

  def Realize(self):
    """Finalizes layout and fits the panel."""
    self._sizer.Layout()
    self._sizer.Fit(self)

  def GetChoiceCtrl(self, choice):
    return self._option_controls.get(choice)

  def AddChoice(self, choice, label=None):
    """Adds a checkbox to the grid.  If choice starts with '*', the box will
    be checked automatically."""
    auto_enable = False
    if (choice.startswith("*")):
      auto_enable = True
      choice = choice[1:]
    assert (not choice in self._option_names)
    if (label is None):
      label = choice
    box = wx.CheckBox(
      parent=self,
      label=label,
      name=choice)
    self.Bind(wx.EVT_CHECKBOX, self.OnCheck, box)
    #self.Bind(wx.EVT_CONTEXT_MENU, self.OnRightClick, box)
    self._sizer.Add(box) #, 0, wx.ALL|wx.ALIGN_CENTER_VERTICAL, 5)
    self._option_names.append(choice)
    self._option_controls[choice] = box
    if (auto_enable):
      box.SetValue(True)

  def Enable(self, enable=True):
    for choice in self._option_names :
      self._option_controls[choice].Enable(enable)

  def EnableChoice(self, choice, enable=True):
    """Enables or disables the checkbox corresponding to the choice."""
    self._option_controls[choice].Enable(enable)

  def SetChoice(self, choice, selected=True):
    """Select or deselect the specified choice."""
    self._option_controls[choice].SetValue(selected)

  def GetChoiceIndex(self, choice):
    if (choice in self._option_names):
      return self._option_names.index(choice)
    return None

  def GetValue(self):
    raise NotImplementedError()

  def SetValue(self, value):
    """
    Check the boxes specified by value.  A list is preferred, but either of
    the two string conventions may be used (selected choices separated by '+',
    or all choices separated by spaces with '*' denoting selected).
    """
    if (isinstance(value, str)):
      if ("+" in value):
        value = value.split("+")
      else :
        value_ = value.split()
        value = []
        for choice in value_ :
          if (choice.startswith("*")):
            value.append(choice[1:])
    assert (isinstance(value, list)) or (isinstance(value, tuple))
    for choice in self._option_names :
      box = self._option_controls[choice]
      if (choice in value):
        box.SetValue(True)
      else :
        box.SetValue(False)

  def GetPhilValue(self):
    """Returns a list of strings."""
    values = []
    for choice in self._option_names :
      box = self._option_controls[choice]
      if (box.GetValue() == True):
        values.append(choice)
    return values

  def GetStringValue(self):
    """Returns the long format (all choices, '*' denotes selected)."""
    values = []
    for choice in self._option_names :
      box = self._option_controls[choice]
      if (box.GetValue() == True):
        values.append("*" + choice)
      else :
        values.append(choice)
    return " ".join(values)

  def OnCheck(self, event):
    box = event.GetEventObject()
    self.DoSendEvent(original_window=box)

# testing
if (__name__ == "__main__"):
  app = wx.App(0)
  frame = wx.Frame(None, -1, "Multi-choice test")
  panel = wx.Panel(frame, -1, size=(720,480))
  txt1 = wx.StaticText(panel, -1, "Refinement strategy:", pos=(20,180))
  choice_ctrl = MultiChoiceCtrl(panel, -1, pos=(240,160),
    name="Refinement strategy")
  choices1 = ["*individual_adp",
                 "*individual_sites",
                 "individual_sites_real_space",
                 "tls",
                 "group_adp",
                 "*occupancies",
                 "group_anomalous"]
  labels = ["Individual B-factors", "XYZ coordinates", "Real-space", "TLS",
    "Group B-factors", "Occupancies", "Anomalous scatterers"]
  for choice, label in zip(choices1, labels):
    choice_ctrl.AddChoice(choice, label)
  choice_ctrl.Realize()
  txt2 = wx.StaticText(panel, -1, "Output formats:", pos=(20,300))
  choice_ctrl2 = MultiChoiceCtrl(panel, -1, pos=(240,300),
    name="Output formats")
  for choice in ["mtz", "pdb", "ccp4_map", "cif", "pkl"] :
    choice_ctrl2.AddChoice(choice)
  choice_ctrl2.Realize()
  choice_ctrl2.SetCols(5)
  choice_ctrl2.SetValue("mtz+pdb")
  frame.Fit()
  frame.Show()
  assert (choice_ctrl.GetPhilValue() == ["individual_adp","individual_sites",
    "occupancies"])
  assert (choice_ctrl2.GetPhilValue() == ["mtz", "pdb"])
  assert (choice_ctrl2.GetStringValue() == "*mtz *pdb ccp4_map cif pkl")
  choice_ctrl2.EnableChoice("ccp4_map", False)
  choice_ctrl2.SetChoice("cif")
  assert (choice_ctrl2.GetPhilValue() == ["mtz", "pdb", "cif"])
  choice_ctrl2.SetValue(["mtz", "pdb"])
  assert (choice_ctrl2.GetPhilValue() == ["mtz", "pdb"])
  app.MainLoop()


 *******************************************************************************
