

 *******************************************************************************
wxtbx/phil_controls/floatctrl.py
from __future__ import absolute_import, division, print_function

from wxtbx.phil_controls.text_base import ValidatedTextCtrl, TextCtrlValidator
from libtbx.utils import Sorry
from libtbx import Auto
import wx
import sys

class FloatCtrl(ValidatedTextCtrl):
  def __init__(self, *args, **kwds):
    super(FloatCtrl, self).__init__(*args, **kwds)
    self.min = float(-sys.maxsize)
    self.max = float(sys.maxsize)

  def SetMin(self, min):
    assert isinstance(min, float) or isinstance(min, int)
    self.min = float(min)

  def SetMax(self, max):
    assert isinstance(max, float) or isinstance(max, int)
    self.max = max

  def GetMin(self):
    return self.min

  def GetMax(self):
    return self.max

  def CreateValidator(self):
    return FloatValidator()

  def SetFloat(self, value):
    if (value is None) or (value is Auto):
      ValidatedTextCtrl.SetValue(self, "")
    elif (isinstance(value, float) or isinstance(value, int)):
      ValidatedTextCtrl.SetValue(self, str(value))
    elif (isinstance(value, str)):
      try : # TODO remove this after testing
        value = float(value)
      except ValueError :
        raise Sorry("Inappropriate value '%s' for %s." % (value,
          self.GetName()))
      else :
        ValidatedTextCtrl.SetValue(self, str(value))
    else :
      raise TypeError("Type '%s' not allowed!" % type(value).__name__)

  def SetValue(self, value):
    self.SetFloat(value)

  def GetPhilValue(self):
    try:
      self.Validate()
    except Exception as e:
      return self.ReturnNoneIfOptional() # probably C++ object deleted

    val_str = ValidatedTextCtrl.GetValue(self)
    if (val_str == ""):
      return self.ReturnNoneIfOptional()
    return float(val_str)

  def FormatValue(self, value):
    return str(value)

class FloatValidator(TextCtrlValidator):
  def CheckFormat(self, value):
    value = float(value)
    window = self.GetWindow()
    if (value > window.GetMax()):
      raise ValueError("Value exceeds maximum allowed (%d)." % window.GetMax())
    elif (value < window.GetMin()):
      raise ValueError("Value is less than minimum allowed (%d)." %
        window.GetMin())
    return value #return window.FormatValue(value)

if (__name__ == "__main__"):
  app = wx.App(0)
  frame = wx.Frame(None, -1, "Float control test")
  panel = wx.Panel(frame, -1, size=(600,400))
  txt1 = wx.StaticText(panel, -1, "High resolution:", pos=(100,180))
  float_ctrl = FloatCtrl(panel, -1, pos=(300,180), size=(80,-1),
    value=3,
    name="High resolution")
  float_ctrl.SetMax(20)
  float_ctrl.SetMin(1.5)
  float_ctrl.SetOptional(False)
  txt2 = wx.StaticText(panel, -1, "mFo-DFc level", pos=(100,240))
  float_ctrl2 = FloatCtrl(panel, -1, pos=(300,240), size=(80,-1),
    name="mFo-DFc level")
  btn = wx.Button(panel, -1, "Process input", pos=(400, 360))
  def OnOkay(evt):
    float1 = float_ctrl.GetPhilValue()
    float2 = float_ctrl2.GetPhilValue()
    print(type(float1).__name__, str(float1))
    print(type(float2).__name__, str(float2))
  frame.Bind(wx.EVT_BUTTON, OnOkay, btn)
  frame.Fit()
  frame.Show()
  app.MainLoop()


 *******************************************************************************


 *******************************************************************************
wxtbx/phil_controls/floats.py
from __future__ import absolute_import, division, print_function

from wxtbx.phil_controls.numbers import NumbersCtrlBase, NumbersValidator
import wx
from six.moves import range

class FloatsCtrl(NumbersCtrlBase):
  def CheckType(self, value):
    return isinstance(value, int) or isinstance(value, float)

  def CreateValidator(self):
    return FloatsValidator()

  def SetFloats(self, value):
    if (value is None):
      NumbersCtrlBase.SetValue(self, "")
    elif (isinstance(value, int) or isinstance(value, float)):
      NumbersCtrlBase.SetValue(self, str(float(value)))
    elif (isinstance(value, list) or isinstance(value, tuple)):
      NumbersCtrlBase.SetValue(self, self.FormatValue(value))

  def SetValue(self, value):
    self.SetFloats(value)

  def GetPhilValue(self):
    self.Validate()
    val_str = str(NumbersCtrlBase.GetValue(self))
    if (val_str == ""):
      return self.ReturnNoneIfOptional()
    return [ float(field) for field in val_str.split() ]

  def FormatValue(self, value):
    format = " ".join([ "%g" for x in range(len(value)) ])
    return format % tuple(value)

class FloatsValidator(NumbersValidator):
  def ConvertValue(self, value):
    return float(value)

if (__name__ == "__main__"):
  app = wx.App(0)
  frame = wx.Frame(None, -1, "Floating-point list test")
  panel = wx.Panel(frame, -1, size=(600,400))
  txt1 = wx.StaticText(panel, -1, "Search model RMSDs:", pos=(100,180))
  floats_ctrl = FloatsCtrl(panel, -1, pos=(300,180), size=(200,-1),
    value=[1.0,2.0,3.5,4.7],
    name="Search model RMSDs")
  floats_ctrl.SetMin(0.5)
  floats_ctrl.SetOptional(False)
  btn = wx.Button(panel, -1, "Process input", pos=(400, 360))
  def OnOkay(evt):
    floats = floats_ctrl.GetPhilValue()
    print(type(floats).__name__, str(floats))
  frame.Bind(wx.EVT_BUTTON, OnOkay, btn)
  frame.Fit()
  frame.Show()
  app.MainLoop()


 *******************************************************************************


 *******************************************************************************
wxtbx/phil_controls/intctrl.py
from __future__ import absolute_import, division, print_function

# XXX this is mostly redundant with wx.IntCtrl, but that control doesn't have
# a way to deal with None or Auto.

from wxtbx.phil_controls.text_base import ValidatedTextCtrl, TextCtrlValidator
from libtbx.utils import Sorry
from libtbx import Auto
import wx

class IntCtrl(ValidatedTextCtrl):
  def __init__(self, *args, **kwds):
    super(IntCtrl, self).__init__(*args, **kwds)
    # Windows int and long are both 4 bytes
    self.min = -2147483647
    self.max = 2147483647
    self._spinner = None

  def AttachSpinner(self, spinner):
    self._spinner = spinner
    spinner.Bind(wx.EVT_SPIN_DOWN, self.OnSpinDown, spinner)
    spinner.Bind(wx.EVT_SPIN_UP, self.OnSpinUp, spinner)
    spinner.SetMax(2147483647)
    spinner.SetMin(-2147483647)
    try :
      val = self.GetPhilValue()
    except Exception as e :
      print(e)
    else :
      if (not self.GetPhilValue() in [None, Auto]):
        spinner.SetValue(self.GetPhilValue())

  def Enable(self, enable=True):
    ValidatedTextCtrl.Enable(self, enable)
    if (self._spinner is not None):
      self._spinner.Enable(enable)

  def SetMin(self, min):
    assert isinstance(min, int)
    self.min = min

  def SetMax(self, max):
    assert isinstance(max, int)
    self.max = max

  def GetMin(self):
    return self.min

  def GetMax(self):
    return self.max

  def CreateValidator(self):
    return IntValidator()

  def SetInt(self, value):
    if (value is None) or (value is Auto):
      ValidatedTextCtrl.SetValue(self, "")
    elif (isinstance(value, int)):
      ValidatedTextCtrl.SetValue(self, str(value))
    elif (isinstance(value, str)):
      try : # TODO remove this after testing
        value = int(value)
      except ValueError :
        raise Sorry("Inappropriate value '%s' for %s." % (value,
          self.GetName()))
      else :
        ValidatedTextCtrl.SetValue(self, str(value))
    else :
      raise TypeError("Type '%s' not allowed!" % type(value).__name__)

  def SetValue(self, value):
    self.SetInt(value)

  def GetPhilValue(self):
    self.Validate()
    val_str = ValidatedTextCtrl.GetValue(self)
    if (val_str == ""):
      return self.ReturnNoneIfOptional()
    return int(val_str)

  def FormatValue(self, value):
    return str(value)

  def OnSpinUp(self, event):
    try :
      value = self.GetPhilValue()
    except Exception:
      value = None
    if (value in [None,Auto]) and ((self.max is None) or (self.max > 0)):
      self.SetValue(1)
      self.DoSendEvent()
    elif (not value in [None, Auto]):
      value += 1
      if (self.max is not None) and (value > self.max):
        pass
      else :
        self.SetValue(value)
        self.DoSendEvent()

  def OnSpinDown(self, event):
    try :
      value = self.GetPhilValue()
    except Exception:
      value = None
    if (value is None) and ((self.min is None) or (self.min < 0)):
      self.SetValue(-1)
      self.DoSendEvent()
    elif (value is not None):
      value -= 1
      if (self.min is not None) and (value < self.min):
        pass
      else :
        self.SetValue(value)
        self.DoSendEvent()

class IntValidator(TextCtrlValidator):
  def CheckFormat(self, value):
    value = int(value)
    window = self.GetWindow()
    if (value > window.GetMax()):
      raise ValueError("Value exceeds maximum allowed (%d)." % window.GetMax())
    elif (value < window.GetMin()):
      raise ValueError("Value is less than minimum allowed (%d)." %
        window.GetMin())
    return value # return window.FormatValue(value)

if (__name__ == "__main__"):
  app = wx.App(0)
  frame = wx.Frame(None, -1, "Integer list test")
  panel = wx.Panel(frame, -1, size=(600,400))
  txt1 = wx.StaticText(panel, -1, "Number of macro cycles:", pos=(100,180))
  int_ctrl = IntCtrl(panel, -1, pos=(300,180), size=(80,-1),
    value=3,
    name="Number of macro cycles")
  int_ctrl.SetMax(20)
  int_ctrl.SetMin(1)
  int_ctrl.SetOptional(False)
  txt2 = wx.StaticText(panel, -1, "Number of processors", pos=(100,240))
  int_ctrl2 = IntCtrl(panel, -1, pos=(300,240), size=(80,-1),
    name="Number of processors")
  spinbtn = wx.SpinButton(panel, -1, pos=(400,240), style=wx.SP_VERTICAL)
  int_ctrl2.AttachSpinner(spinbtn)
  int_ctrl2.SetMin(1)
  btn = wx.Button(panel, -1, "Process input", pos=(400, 360))
  txt3 = wx.StaticText(panel, -1, "Number of copies", pos=(100,300))
  int_ctrl3 = IntCtrl(panel, -1, pos=(300,300), size=(80,-1),
    name="Number of copies")
  int_ctrl3.SetUseAuto()
  def OnOkay(evt):
    int1 = int_ctrl.GetPhilValue()
    int2 = int_ctrl2.GetPhilValue()
    int3 = int_ctrl3.GetPhilValue()
    print(type(int1).__name__, str(int1))
    print(type(int2).__name__, str(int2))
    print(type(int3).__name__, str(int3))
  frame.Bind(wx.EVT_BUTTON, OnOkay, btn)
  def OnChange(evt):
    print(evt.GetEventObject().GetPhilValue())
  from wxtbx.phil_controls import EVT_PHIL_CONTROL
  frame.Bind(EVT_PHIL_CONTROL, OnChange)
  frame.Fit()
  frame.Show()
  app.MainLoop()


 *******************************************************************************


 *******************************************************************************
wxtbx/phil_controls/ints.py
from __future__ import absolute_import, division, print_function

from wxtbx.phil_controls.numbers import NumbersCtrlBase, NumbersValidator
from libtbx import Auto
import wx
from six.moves import range

class IntsCtrl(NumbersCtrlBase):
  def CheckType(self, value):
    return isinstance(value, int)

  def CreateValidator(self):
    return IntsValidator()

  def SetInts(self, value):
    if (value is None):
      NumbersCtrlBase.SetValue(self, "")
    elif (value is Auto):
      NumbersCtrlBase.SetValue(self, "Auto")
    elif (isinstance(value, int) or isinstance(value, float)):
      NumbersCtrlBase.SetValue(self, str(int(value)))
    elif (isinstance(value, list) or isinstance(value, tuple)):
      NumbersCtrlBase.SetValue(self, self.FormatValue(value))
    else :
      raise TypeError("Type '%s' not allowed!" % type(value).__name__)

  def SetValue(self, value):
    self.SetInts(value)

  def GetPhilValue(self):
    self.Validate()
    val_str = str(NumbersCtrlBase.GetValue(self))
    if (val_str == ""):
      return self.ReturnNoneIfOptional()
    elif (val_str == "Auto"):
      return Auto
    return [ int(field) for field in val_str.split() ]

  def FormatValue(self, value):
    format = " ".join([ "%d" for x in range(len(value)) ])
    return format % tuple(value)

class IntsValidator(NumbersValidator):
  def ConvertValue(self, value):
    return int(value)

if (__name__ == "__main__"):
  app = wx.App(0)
  frame = wx.Frame(None, -1, "Integer list test")
  panel = wx.Panel(frame, -1, size=(600,400))
  txt1 = wx.StaticText(panel, -1, "Run SA on cycle numbers:", pos=(100,180))
  ints_ctrl = IntsCtrl(panel, -1, pos=(300,180), size=(200,-1),
    value=[1,2,5,10],
    name="Run SA on cycle numbers")
  ints_ctrl.SetMin(1)
  txt2 = wx.StaticText(panel, -1, "Window color:", pos=(100,240))
  ints_ctrl2 = IntsCtrl(panel, -1, pos=(300,240), size=(200,-1),
    name="Window color")
  ints_ctrl2.SetSize(3)
  ints_ctrl2.SetMin(0)
  ints_ctrl2.SetMax(255)
  btn = wx.Button(panel, -1, "Process input", pos=(400, 360))
  def OnOkay(evt):
    ints = ints_ctrl.GetPhilValue()
    ints2 = ints_ctrl2.GetPhilValue()
    print(type(ints).__name__, str(ints))
    print(type(ints2).__name__, str(ints2))
  def OnChange(evt):
    print("OnChange")
  frame.Bind(wx.EVT_BUTTON, OnOkay, btn)
  import wxtbx.phil_controls
  frame.Bind(wxtbx.phil_controls.EVT_PHIL_CONTROL, OnChange)
  frame.Fit()
  frame.Show()
  app.MainLoop()


 *******************************************************************************


 *******************************************************************************
wxtbx/phil_controls/misc_ctrls.py

from __future__ import absolute_import, division, print_function
from wxtbx.phil_controls import strings
from wxtbx.phil_controls import strctrl
from wxtbx import phil_controls
import wx

WXTBX_ELEMENTS_CTRL_ALLOW_AX = 1
WXTBX_ELEMENTS_CTRL_ALLOW_CLUSTERS = 2

clusters = set(['TX', 'XX'])

class ElementCtrl(strctrl.StrCtrl):
  """"
  Control for entering a single element symbol or scattering type, using
  phil str type
  """
  def __init__(self, *args, **kwds):
    elements_style = kwds.get('style', 0)
    kwds['style'] = 0
    strctrl.StrCtrl.__init__(self, *args, **kwds)
    self.SetWxtbxStyle(elements_style)

  def CreateValidator(self):
    return SingleElementValidator()

class ElementsCtrl(strings.StringsCtrl):
  """
  Control for entering a list of elements (comma- or space-separated) or
  scattering types, using phil strings type
  """
  def __init__(self, *args, **kwds):
    elements_style = kwds.get('style', 0)
    kwds['style'] = 0
    strings.StringsCtrl.__init__(self, *args, **kwds)
    self.SetWxtbxStyle(elements_style)

  def CreateValidator(self):
    return ElementsValidator()

class ElementsValidator(strings.StringsValidator):
  single_element = False
  def CheckFormat(self, value):
    from cctbx.eltbx import chemical_elements
    allowed = chemical_elements.proper_upper_list() + list(clusters)
    ctrl = self.GetWindow()
    style = ctrl.GetWxtbxStyle()
    elem_strings = strings.parse_strings(value)
    if (self.single_element) and (len(elem_strings) > 1):
      raise ValueError("Only a single element may be specified here!")
    for elem in elem_strings :
      elem = elem.upper() # used in Phaser EP
      if (elem == "AX" or elem == "RX") and (style & WXTBX_ELEMENTS_CTRL_ALLOW_AX):
        pass
      elif (elem in clusters) and (style & WXTBX_ELEMENTS_CTRL_ALLOW_CLUSTERS):
        pass
      elif (not elem in allowed):
        raise ValueError("'%s' is not a valid element symbol." % elem)
    if (self.single_element):
      return elem_strings[0]
    else :
      return elem_strings

class SingleElementValidator(ElementsValidator):
  single_element = True

# TODO pop-up help
class AtomSelectionCtrl(strctrl.StrCtrl):
  """Control for editing an atom selection (phil atom_selection type)"""
  def __init__(self, *args, **kwds):
    size = kwds.get('size', None)
    if (size is None):
      kwds['size'] = (400, 40)
    strctrl.StrCtrl.__init__(self, *args, **kwds)

  def CreateValidator(self):
    return AtomSelectionValidator()

class AtomSelectionValidator(strctrl.StrValidator):
  def CheckFormat(self, value):
    # FIXME this breaks on mmtbx-supported selections!
    #import iotbx.pdb.hierarchy
    #root = iotbx.pdb.hierarchy.root()
    #sel_cache = root.atom_selection_cache()
    #atom_sel = sel_cache.selection(value)
    return value

if (__name__ == "__main__"):
  app = wx.App(0)
  frame = wx.Frame(None, -1, "Strings control test")
  panel = wx.Panel(frame, -1, size=(720,400))
  txt0 = wx.StaticText(panel, -1, "Scatterer:", pos=(20,80))
  sc_ctrl = ElementCtrl(panel, -1, pos=(200,80), size=(120,-1),
      name="Scatterer",
      style=WXTBX_ELEMENTS_CTRL_ALLOW_AX|WXTBX_ELEMENTS_CTRL_ALLOW_CLUSTERS)
  txt1 = wx.StaticText(panel, -1, "Elements:", pos=(20,180))
  elems_ctrl = ElementsCtrl(panel, -1, pos=(200,180), size=(120,-1),
      name="Elements", style=wx.TE_PROCESS_ENTER)
  txt2 = wx.StaticText(panel, -1, "Atom selection:", pos=(20,240))
  sel_ctrl = AtomSelectionCtrl(panel, -1, pos=(200,240), name="Selection")
  def OnUpdate(evt):
    print("OnUpdate:")
    print("  current scatterer:", sc_ctrl.GetPhilValue())
    elems = elems_ctrl.GetPhilValue()
    print("  current elements:", elems)
    sel = sel_ctrl.GetPhilValue()
    print("  atom selection:", sel)
  def OnOkay(evt):
    print("OnOkay:")
    print("  scatterer:", sc_ctrl.GetPhilValue())
    print("  scatterer phil:", sc_ctrl.GetStringValue())
    print("  elems:", elems_ctrl.GetPhilValue())
    print("  elems phil:", elems_ctrl.GetStringValue())
    print("  selection:", sel_ctrl.GetPhilValue())
    print("  selection phil:", sel_ctrl.GetStringValue())
  frame.Bind(phil_controls.EVT_PHIL_CONTROL, OnUpdate, sc_ctrl)
  frame.Bind(phil_controls.EVT_PHIL_CONTROL, OnUpdate, elems_ctrl)
  frame.Bind(phil_controls.EVT_PHIL_CONTROL, OnUpdate, sel_ctrl)
  btn = wx.Button(panel, -1, "Process input", pos=(400, 360))
  frame.Bind(wx.EVT_BUTTON, OnOkay, btn)
  frame.Fit()
  frame.Show()
  app.MainLoop()


 *******************************************************************************


 *******************************************************************************
wxtbx/phil_controls/numbers.py
from __future__ import absolute_import, division, print_function

# base control for 'ints' and 'floats' phil types.  see corresponding code
# in ../../libtbx/phil/__init__.py - these should probably be consolidated
# at some point

from wxtbx.phil_controls.text_base import ValidatedTextCtrl, TextCtrlValidator
from libtbx import Auto
import re

class NumbersCtrlBase(ValidatedTextCtrl):
  def __init__(self, *args, **kwds):
    super(NumbersCtrlBase, self).__init__(*args, **kwds)
    self.size = None
    self.size_min = None
    self.size_max = None
    self.value_min = None
    self.value_max = None
    self.allow_none_elements = False
    self.allow_auto_elements = False

  def CheckType(self, value):
    raise NotImplementedError()

  def InheritPhilType(self, phil_type):
    """
    Adopts the value constraints from the PHIL converter object.  'size' is
    not actually an attribute of the type, but it is also extracted here.
    """
    for attr in ["size_min", "size_max", "value_min", "value_max",
                 "allow_none_elements", "allow_auto_elements"] :
      setattr(self, attr, getattr(phil_type, attr))
    if (self.size_min == self.size_max) and (self.size is None):
      self.size = self.size_min

  def SetSize(self, size):
    assert (size is None) or (isinstance(size, int))
    self.size = size

  def SetSizeMin(self, size_min):
    assert (size_min is None) or (isinstance(size_min, int))
    self.size_min = size_min

  def SetSizeMax(self, size_max):
    assert (size_max is None) or (isinstance(size_max, int))
    self.size_max = size_max

  def SetMin(self, min):
    assert (min is None) or (self.CheckType(min))
    self.value_min = min

  def SetMax(self, max):
    assert (max is None) or (self.CheckType(max))
    self.value_max = max

class NumbersValidator(TextCtrlValidator):
  def ConvertValue(self, value):
    raise NotImplementedError()

  def CheckFormat(self, value):
    if (value in ["None", "none"]):
      return None
    elif (value in ["Auto", "auto"]):
      return Auto
    if ("," in value) or (";" in value):
      value = re.sub(",", " ", re.sub(";", " ", value))
    numbers_list = []
    for field in value.split():
      if (field == "None"):
        numbers_list.append(None)
      elif (field == "Auto"):
        numbers_list.append(Auto)
      else :
        numbers_list.append(self.ConvertValue(field))
    window = self.GetWindow()
    n_elems = len(numbers_list)
    if (window.size is not None) and (window.size != n_elems):
      raise ValueError(("Wrong number of items - %d numbers required, "+
        "but %d are entered.") % (window.size, n_elems))
    if (window.size_min is not None) and (window.size_min > n_elems):
      raise ValueError(("Wrong number of items - %d entered, but at least %d "+
        "are required.") % (n_elems, window.size_min))
    if (window.size_max is not None) and (window.size_max < n_elems):
      raise ValueError(("Wrong number of items - %d entered, but the "+
        "maximum is %d.") % (n_elems, window.size_max))
    for x in numbers_list :
      if (x is Auto) and (not window.allow_auto_elements):
        raise ValueError("Auto not allowed here.")
      elif (x is None) and (not window.allow_none_elements):
        raise ValueError("None not allowed here.")
      elif (window.value_min is not None) and (x < window.value_min):
        raise ValueError("Minimum permitted value is %g" % window.value_min)
      elif (window.value_max is not None) and (x > window.value_max):
        raise ValueError("Maximum permitted value is %g" % window.value_max)
    return numbers_list


 *******************************************************************************


 *******************************************************************************
wxtbx/phil_controls/path.py
from __future__ import absolute_import, division, print_function
from wxtbx.phil_controls import text_base
from wxtbx import phil_controls
import wxtbx.icons
from libtbx.utils import Sorry, to_unicode, to_str
from libtbx import Auto
import wx
import os
import sys

WXTBX_PHIL_PATH_SAVE = 1
WXTBX_PHIL_PATH_DIRECTORY = 2
WXTBX_PHIL_PATH_VIEW_BUTTON = 4
WXTBX_PHIL_PATH_NARROW = 8
WXTBX_PHIL_PATH_UPDATE_ON_KILL_FOCUS = 16
WXTBX_PHIL_PATH_DEFAULT_CWD = 32

class PathCtrl(wx.Panel, phil_controls.PhilCtrl):
  def __init__(self, *args, **kwds):
    phil_controls.PhilCtrl.__init__(self)
    self.SetOptional(True) # this will be overridden elsewhere if necessary
    wx.SystemOptions.SetOption("osx.openfiledialog.always-show-types", "1")
    kwds = dict(kwds)
    self._path_style = kwds.get("style", WXTBX_PHIL_PATH_VIEW_BUTTON)
    assert ((self._path_style & WXTBX_PHIL_PATH_DIRECTORY) or
            (not self._path_style & WXTBX_PHIL_PATH_DEFAULT_CWD))
    value = kwds.pop("value", None)
    kwds['style'] = wx.NO_BORDER
    self._formats = ()
    if (kwds.get("size", None) == wx.DefaultSize):
      kwds.pop("size")
    if (self._path_style & WXTBX_PHIL_PATH_NARROW):
      szr_type = wx.VERTICAL
      path_size = kwds.get("size", (300,-1))
      szr2_pad = wx.TOP
    else :
      szr_type = wx.HORIZONTAL
      path_size = kwds.get("size", (400, -1))
      szr2_pad = wx.LEFT
    kwds['size'] = wx.DefaultSize
    wx.Panel.__init__(self, *args, **kwds)
    self._formats = ()
    szr = wx.BoxSizer(szr_type)
    self.SetSizer(szr)
    self._path_text = wx.TextCtrl(self, -1, size=path_size,
      style=wx.TE_PROCESS_ENTER,
      name=self.GetName())
    self.Bind(wx.EVT_TEXT_ENTER, self.OnEnter, self._path_text)
    if (self._path_style & WXTBX_PHIL_PATH_UPDATE_ON_KILL_FOCUS):
      self._path_text.Bind(wx.EVT_KILL_FOCUS, self.OnEnter)
    self._path_text.SetValidator(PathValidator())
    self._path_text.GetValidator().Bind(wx.EVT_TEXT_ENTER, self.OnEnter)
    szr.Add(self._path_text, 0, wx.ALIGN_CENTER_VERTICAL|wx.RIGHT)
    browse_btn = wx.Button(self, -1, "Browse...")
    szr2 = wx.BoxSizer(wx.HORIZONTAL)
    szr.Add(szr2, 0, wx.ALIGN_CENTER_VERTICAL|szr2_pad, 5)
    szr2.Add(browse_btn, 0, wx.ALIGN_CENTER_VERTICAL, 5)
    self.Bind(wx.EVT_BUTTON, self.OnBrowse, browse_btn)
    self.browse_btn = browse_btn
    if (self._path_style & WXTBX_PHIL_PATH_VIEW_BUTTON):
      bitmap = wxtbx.icons.viewmag.GetBitmap()
      view_btn = wx.BitmapButton(self, -1, bitmap)
      self.Bind(wx.EVT_BUTTON, self.OnDisplayFile, view_btn)
      view_btn.Bind(wx.EVT_CONTEXT_MENU, self.OnDisplayFileMenu)
      #self.Bind(wx.EVT_RIGHT_DOWN, self.OnDisplayFileMenu, view_btn)
      szr2.Add(view_btn, 0, wx.ALIGN_CENTER_VERTICAL|wx.LEFT, 5)
    szr.Layout()
    szr.Fit(self)
    drop_target = PathDropTarget(self)
    self.SetDropTarget(drop_target)
    self.SetValue(value)
    self._pathmgr = None
    self._cached_paths = None

  def SetFormats(self, formats):
    if (isinstance(formats, str)):
      formats = formats.split(",")
    else :
      assert (isinstance(formats, list) or isisntance(formats, tuple))
    self._formats = formats

  def Clear(self):
    self._path_text.Clear()

  def GetPathStyle(self):
    return self._path_style

  def GetValue(self):
    val = self._path_text.GetValue().strip()
    # use unicode check to avoid bytes in Python 3
    check_type = bytes
    if sys.version_info.major == 2:
      check_type = unicode
    if (isinstance(val, check_type)) and wxtbx.is_unicode_build():
      return to_str(val)
    else :
      assert isinstance(val, str)
      return val

  def SetValue(self, value):
    if (value is None) or (value is Auto):
      self._path_text.SetValue("")
    else :
      value = to_unicode(value)
      self._path_text.SetValue(value)

  def SetBackgroundColour(self, *args, **kwds):
    self._path_text.SetBackgroundColour(*args, **kwds)

  def GetPhilValue(self):
    ok = self._path_text.GetValidator().Validate(self)
    if ok:
      val_str = self.GetValue()
    else:
      val_str = ""
    assert isinstance(val_str, str)
    if (val_str == ""):
      return self.ReturnNoneIfOptional()
    return val_str

  def GetStringValue(self):
    return str(self.GetPhilValue())

  def FormatValue(self, value):
    if (value != ""):
      if (not os.path.isabs(value)):
        print("ABSPATH")
        return os.path.abspath(value)
      else :
        return value
    return value

  def Validate(self):
    return self._path_text.GetValidator().Validate(self)

  def OnBrowse(self, event):
    flags = 0
    if (self._path_style & WXTBX_PHIL_PATH_SAVE):
      flags |= wx.FD_SAVE|wx.OVERWRITE_PROMPT
    else :
      flags |= wx.FD_OPEN
    path_manager = self.GetPathManager()
    new_path = None
    if (self._path_style & WXTBX_PHIL_PATH_DIRECTORY):
      new_path = path_manager.select_directory(
        message="Choose a directory: %s" % self.GetName(),
        current_path=to_unicode(self.GetValue()),
        style=flags|wx.DD_NEW_DIR_BUTTON,
        parent=self)
    else :
      from iotbx import file_reader
      wildcard = file_reader.get_wildcard_strings(self._formats)
      new_path = path_manager.select_file(
        parent=self,
        message="Choose a file: %s" % self.GetName(),
        current_file=to_unicode(self.GetValue()),
        style=flags,
        wildcard=wildcard)
    if (new_path is not None):
      if ('}' in new_path) or ('{' in new_path):
        raise Sorry("Curly brackets ({}) are not allowed in pathnames.")
      self.SetValue(new_path)
      self.DoSendEvent()

  def GetPathManager(self):
    if (self._pathmgr is None):
      main_window = self.GetTopLevelParent()
      if hasattr(main_window, "get_path_manager"):
        self._pathmgr = main_window.get_path_manager()
    if (self._pathmgr is None):
      from wxtbx import path_dialogs
      self._pathmgr = path_dialogs.manager()
    return self._pathmgr

  def OnDisplayFile(self, event):
    file_name = self.GetValue()
    if (file_name == ""):
      return
    elif (not os.path.exists(file_name)):
      raise Sorry("Path does not exist.")
    tlp = self.GetTopLevelParent()
    if (hasattr(tlp, "display_file")):
      tlp.display_file(file_name)
    else :
      print("NotImplemented")

  def OnDisplayFileMenu(self, event):
    file_name = self.GetValue()
    if (file_name == ""):
      return
    elif (not os.path.exists(file_name)):
      raise Sorry("Path does not exist.")
    tlp = self.GetTopLevelParent()
    if (hasattr(tlp, "display_file_menu")):
      tlp.display_file_menu(file_name)
    else :
      print("NotImplemented")

  def OnEnter(self, event):
    if (self._path_style & WXTBX_PHIL_PATH_DEFAULT_CWD):
      value = self.GetValue()
      if (value == ""):
        from libtbx.utils import getcwd_safe
        self.SetValue(getcwd_safe())
    self.Validate()
    self.DoSendEvent()

  def SetCachedPaths(self, paths):
    self._cached_paths = paths
    # XXX on Mac, right-clicking on the TextCtrl is already handled by the OS,
    # so only the browse button will work for this; need to check other OSes
    self.browse_btn.Bind(wx.EVT_RIGHT_DOWN, self.OnRightClick, self.browse_btn)

  def OnRightClick(self, event):
    assert (self._cached_paths is not None)
    menu = wx.Menu()
    current_path_name = self.GetValue()
    n_items = 0
    def set_path(pn):
      self.SetValue(pn)
    if (current_path_name not in [None, ""]):
      item = menu.Append(-1, current_path_name)
      self.Bind(wx.EVT_MENU, lambda evt, pn=current_path_name: set_path(pn),
        item)
      n_items +=1
    for path_name in self._cached_paths :
      if (path_name != current_path_name):
        item = menu.Append(-1, path_name)
        self.Bind(wx.EVT_MENU, lambda evt, pn=path_name: set_path(pn),
          item)
        n_items +=1
    if (n_items > 0):
      self.PopupMenu(menu)
    menu.Destroy()

class PathValidator(text_base.TextCtrlValidator):
  def CheckFormat(self, value):
    style = self.GetWindow().GetParent().GetPathStyle()
    if ('}' in value) or ('{' in value):
      raise ValueError("Curly brackets ({}) are not allowed in pathnames.")
    elif (value == ""):
      return ""
    elif (os.path.isfile(value)):
      if (style & WXTBX_PHIL_PATH_DIRECTORY):
        raise ValueError("file specified, but this parameter requires "+
          "a directory.")
      if (not os.path.isabs(value)):
        print("ABSPATH")
        return os.path.abspath(value)
      else :
        return value
    elif (os.path.isdir(value)):
      if (not style & WXTBX_PHIL_PATH_DIRECTORY):
        # XXX hack to allow app and package bundles on OS X
        if ((sys.platform == "darwin") and (value.endswith(".app") or
            (value.endswith(".pkg")))):
          pass
        else :
          raise ValueError("directory specified, but this parameter requires "+
            "a file.")
      if (not os.path.isabs(value)):
        print("ABSPATH")
        return os.path.abspath(value)
      else :
        return value
    else :
      if (style & WXTBX_PHIL_PATH_SAVE):
        return os.path.abspath(value)
      else :
        raise ValueError("path does not exist")

class PathDropTarget(wx.FileDropTarget):
  def __init__(self, window):
    wx.FileDropTarget.__init__(self)
    self.window = window

  def OnDropFiles(self, x, y, filenames):
    self.window.SetValue(filenames[-1])
    self.window.Validate()
    self.window.DoSendEvent()
    return True

if (__name__ == "__main__"):
  app = wx.App(0)
  frame = wx.Frame(None, -1, "Path test")
  panel = wx.Panel(frame, -1, size=(800,480))
  txt1 = wx.StaticText(panel, -1, "Reflections file", pos=(20,100))
  txt2 = wx.StaticText(panel, -1, "Output PDB file", pos=(20,160))
  txt3 = wx.StaticText(panel, -1, "Output directory", pos=(20,220))
  txt4 = wx.StaticText(panel, -1, "Default parameters", pos=(20,280))
  path1 = PathCtrl(panel, -1, pos=(200,100), name="Reflections file")
  path1.SetOptional(False)
  path1.SetFormats("hkl")
  path2 = PathCtrl(panel, -1, pos=(200,160), name="Output PDB file",
    style=WXTBX_PHIL_PATH_SAVE|WXTBX_PHIL_PATH_VIEW_BUTTON)
  path2.SetFormats("pdb")
  path3 = PathCtrl(panel, -1, pos=(200,220), name="Output directory",
    size=(300,-1),
    style=WXTBX_PHIL_PATH_DIRECTORY|WXTBX_PHIL_PATH_VIEW_BUTTON|
      WXTBX_PHIL_PATH_UPDATE_ON_KILL_FOCUS|WXTBX_PHIL_PATH_DEFAULT_CWD)
  path3.SetOptional(False)
  path3.SetCachedPaths(["/var/tmp", "/tmp"])
  path4 = PathCtrl(panel, -1, pos=(20,300), name="Default parameters",
    style=WXTBX_PHIL_PATH_NARROW|WXTBX_PHIL_PATH_VIEW_BUTTON)
  path4.SetFormats("phil")
  pdb_out = os.path.join(os.getcwd(), "model.pdb")
  path2.SetValue(pdb_out)
  button = wx.Button(panel, -1, "Process inputs", pos=(600,400))
  def OnProcess(event):
    print(path1.GetPhilValue())
    print(path2.GetPhilValue())
    print(path3.GetPhilValue())
    print(path4.GetPhilValue())
  def OnPhilEvent(event):
    print("PhilEvent")
  frame.Bind(wx.EVT_BUTTON, OnProcess, button)
  frame.Bind(phil_controls.EVT_PHIL_CONTROL, OnPhilEvent)
  frame.Fit()
  frame.Show()
  assert (path2.GetPhilValue() == pdb_out)
  assert (path2.GetStringValue() == pdb_out)
  try :
    path1.GetPhilValue()
  except Exception :
    pass
  else :
    raise RuntimeError("Exception expected!")
  app.MainLoop()


 *******************************************************************************


 *******************************************************************************
wxtbx/phil_controls/simple_dialogs.py
from __future__ import absolute_import, division, print_function

from wxtbx.phil_controls import intctrl, floatctrl, symop, strctrl, ints, choice
from wxtbx.utils import std_sizer_flags, add_ok_cancel_buttons
from libtbx.utils import Abort
import wx
from six.moves import range

class SimpleInputDialog(wx.Dialog):
  def __init__(self,
                parent,
                title,
                label,
                value=None,
                caption=None):
    style = wx.CAPTION|wx.CLOSE_BOX|wx.RAISED_BORDER| \
      wx.WS_EX_VALIDATE_RECURSIVELY | wx.RESIZE_BORDER
    wx.Dialog.__init__(self,
      parent=parent,
      title=title,
      style=style)
    self.sizer = wx.BoxSizer(wx.VERTICAL)
    self.SetSizer(self.sizer)
    self.inner_sizer = wx.BoxSizer(wx.VERTICAL)
    self.sizer.Add(self.inner_sizer, 1, wx.EXPAND|wx.ALL, 5)
    if (caption is not None):
      caption_txt = wx.StaticText(self, -1, caption)
      caption_txt.Wrap(480)
      self.inner_sizer.Add(caption_txt, 0, wx.ALL, 5)
    input_szr = wx.BoxSizer(wx.HORIZONTAL)
    self.inner_sizer.Add(input_szr, 0, wx.ALIGN_CENTER)
    label_txt = wx.StaticText(self, -1, label + ":")
    input_szr.Add(label_txt, 0, wx.ALL|wx.ALIGN_CENTER_VERTICAL, 5)
    self.phil_ctrl = self.CreatePhilControl(value)
    input_szr.Add(self.phil_ctrl, 0, wx.ALL|wx.ALIGN_CENTER_VERTICAL, 5)
    add_ok_cancel_buttons(self, self.sizer)
    self.Fit()
    self.Centre(wx.BOTH)

  def CreatePhilControl(self, value):
    raise NotImplementedError()

  def GetPhilValue(self):
    return self.phil_ctrl.GetPhilValue()

  def __getattr__(self, name):
    return getattr(self.phil_ctrl, name)

class IntegerDialog(SimpleInputDialog):
  def CreatePhilControl(self, value):
    return intctrl.IntCtrl(
      parent=self,
      value=value)

class FloatDialog(SimpleInputDialog):
  def CreatePhilControl(self, value):
    return floatctrl.FloatCtrl(
      parent=self,
      value=value)

class StringDialog(SimpleInputDialog):
  def CreatePhilControl(self, value):
    return strctrl.StrCtrl(
      parent=self,
      value=value)

class SymopDialog(SimpleInputDialog):
  def CreatePhilControl(self, value):
    return symop.SymopCtrl(
      parent=self,
      value=value)

class SymopChoiceDialog(SimpleInputDialog):
  def CreatePhilControl(self, value):
    return symop.SymopChoiceCtrl(
      parent=self)

class IntegersDialog(SimpleInputDialog):
  def CreatePhilControl(self, value):
    return ints.IntsCtrl(
      parent=self,
      value=value)

class ChoiceDialog(SimpleInputDialog):
  def CreatePhilControl(self, value=None):
    return choice.ChoiceCtrl(
      parent=self)

  def SetChoices(self, *args, **kwds):
    self.phil_ctrl.SetChoices(*args, **kwds)
    self.Layout()

def get_phil_value_from_dialog(dlg):
  abort = False
  if (dlg.ShowModal() == wx.ID_OK):
    value = dlg.GetPhilValue()
  else :
    abort = True
  wx.CallAfter(dlg.Destroy)
  if (abort):
    raise Abort()
  return value

def get_float_value(**kwds):
  dlg = FloatDialog(**kwds)
  return get_phil_value_from_dialog(dlg)

def get_integer_value(**kwds):
  dlg = IntegerDialog(**kwds)
  return get_phil_value_from_dialog(dlg)

def get_miller_index(**kwds):
  dlg = IntegersDialog(**kwds)
  dlg.SetSizeMin(3)
  dlg.SetSizeMax(3)
  dlg.SetOptional(False)
  result = get_phil_value_from_dialog(dlg)
  if (isinstance(result, list)):
    return tuple(result)
  return result

RT_DIALOG_ENABLE_FRACTIONAL = 1
class RTDialog(wx.Dialog):
  def __init__(self, *args, **kwds):
    kwds = dict(kwds)
    style = kwds.get('style', 0)
    style |= wx.CAPTION|wx.CLOSE_BOX|wx.RAISED_BORDER| \
      wx.WS_EX_VALIDATE_RECURSIVELY
    kwds['style'] = style
    extra_style = kwds.pop("wxtbxStyle", 0)
    wx.Dialog.__init__(self, *args, **kwds)
    szr = wx.BoxSizer(wx.VERTICAL)
    self.SetSizer(szr)
    self._r_ctrls = []
    self._t_ctrls = []
    txt = wx.StaticText(self, -1,
      "Please enter rotation and translation operations to apply.  All "+
      "values must be defined.")
    szr.Add(txt, 0, wx.ALL, 5)
    grid = wx.FlexGridSizer(rows=4, cols=4)
    szr.Add(grid, 0, wx.ALL, 5)
    label1 = wx.StaticText(self, -1, "Rotation:")
    grid.Add(label1, 0, wx.ALL|wx.ALIGN_CENTER_VERTICAL, 5)
    for i in range(3):
      if (i > 0):
        grid.Add((1,1))
      for j in range(3):
        _value = 0.0
        if (j == i):
          _value = 1.0
        ctrl = floatctrl.FloatCtrl(
          parent=self,
          name="Rotation",
          value=_value)
        ctrl.SetOptional(False)
        grid.Add(ctrl, 0, wx.ALL|wx.ALIGN_CENTER_VERTICAL, 5)
        self._r_ctrls.append(ctrl)
    label2 = wx.StaticText(self, -1, "Translation:")
    grid.Add(label2, 0, wx.ALL|wx.ALIGN_CENTER_VERTICAL, 5)
    for i in range(3):
      ctrl = floatctrl.FloatCtrl(
        parent=self,
        name="Translation",
        value=0)
      ctrl.SetOptional(False)
      grid.Add(ctrl, 0, wx.ALL|wx.ALIGN_CENTER_VERTICAL, 5)
      self._t_ctrls.append(ctrl)
    self.frac_box = None
    if (extra_style & RT_DIALOG_ENABLE_FRACTIONAL):
      self.frac_box = wx.CheckBox(self, -1, "Use fractional coordinates")
      szr.Add(self.frac_box, 0, wx.ALL|wx.ALIGN_CENTER_VERTICAL, 5)
    add_ok_cancel_buttons(self, szr)
    self.Fit()
    self.Centre(wx.BOTH)

  def GetMatrix(self):
    from scitbx import matrix
    r = [ c.GetPhilValue() for c in self._r_ctrls ]
    t = [ c.GetPhilValue() for c in self._t_ctrls ]
    return matrix.rt((r,t))

  def IsFractional(self):
    if (self.frac_box is not None):
      return self.frac_box.GetValue()
    return False

def get_rt_matrix(parent=None, enable_fractional=False):
  style = 0
  if (enable_fractional):
    style = RT_DIALOG_ENABLE_FRACTIONAL
  dlg = RTDialog(
    parent=parent,
    title="Rotation/translation operator",
    wxtbxStyle=style)
  rt = None
  if (dlg.ShowModal() == wx.ID_OK):
    rt = dlg.GetMatrix()
  wx.CallAfter(dlg.Destroy)
  if (rt is None):
    raise Abort()
  return rt

class HTTPProxyDialog(wx.Dialog):
  def __init__(self, *args, **kwds):
    wx.Dialog.__init__(self, *args, **kwds)
    szr = wx.BoxSizer(wx.VERTICAL)
    self.SetSizer(szr)
    szr2 = wx.BoxSizer(wx.VERTICAL)
    szr.Add(szr2, 0, wx.ALL|wx.ALIGN_CENTER, 10)
    txt = wx.StaticText(parent=self,
      label="Please enter the information required by your HTTP proxy.  The "+
        "authentication information may not be needed at all sites.",
      size=(400,-1))
    txt.Wrap(400)
    szr2.Add(txt)
    grid = wx.FlexGridSizer(cols=2)
    szr2.Add(grid)
    grid.Add(wx.StaticText(self, label="HTTP proxy server:"), 0,
      std_sizer_flags, 5)
    self.server_ctrl = strctrl.StrCtrl(parent=self, size=(300,-1),
      name="HTTP proxy server")
    self.server_ctrl.SetOptional(False)
    grid.Add(self.server_ctrl, 0, std_sizer_flags, 5)
    grid.Add(wx.StaticText(self, label="Proxy port:"), 0, std_sizer_flags, 5)
    self.port_ctrl = intctrl.IntCtrl(parent=self, size=(100,-1),
      name="Proxy port")
    self.port_ctrl.SetOptional(False)
    grid.Add(self.port_ctrl, 0, std_sizer_flags, 5)
    grid.Add(wx.StaticText(self, label="User name:"), 0, std_sizer_flags, 5)
    self.user_ctrl = strctrl.StrCtrl(parent=self, size=(100,-1),
      name="User name")
    self.user_ctrl.SetOptional(False)
    grid.Add(self.user_ctrl, 0, std_sizer_flags, 5)
    grid.Add(wx.StaticText(self, label="Password:"), 0, std_sizer_flags, 5)
    self.password_ctrl = strctrl.StrCtrl(parent=self, size=(200,-1),
      name="Password", style=wx.TE_PASSWORD)
    self.password_ctrl.SetOptional(False)
    grid.Add(self.password_ctrl, 0, std_sizer_flags, 5)
    add_ok_cancel_buttons(self, szr)
    szr.Layout()
    self.Fit()
    self.Centre(wx.BOTH)

  def SetProxyServer(self, server):
    self.server_ctrl.SetValue(server)

  def SetProxyUser(self, user):
    self.user_ctrl.SetValue(user)

  def SetProxyPort(self, port):
    assert isinstance(port, int)
    self.port_ctrl.SetValue(port)

  def GetProxyServer(self):
    return self.server_ctrl.GetPhilValue()

  def GetProxyPort(self):
    return self.port_ctrl.GetPhilValue()

  def GetProxyPassword(self):
    return self.password_ctrl.GetPhilValue()

  def GetProxyUser(self):
    return self.user_ctrl.GetPhilValue()

  def InstallProxy(self):
    import libtbx.utils
    libtbx.utils.install_urllib_http_proxy(
      server=self.GetProxyServer(),
      port=self.GetProxyPort(),
      user=self.GetProxyUser(),
      password=self.GetProxyPassword())

if (__name__ == "__main__"):
  app = wx.App(0)
  value1 = get_float_value(
    parent=None,
    title="Float input",
    label="Bond sigma",
    value=None,
    caption="Please enter a sigma value (in Angstroms) for the selected bond.")
  print(value1)
  value2 = get_integer_value(
    parent=None,
    title="Integer input",
    label="Number of cycles",
    value=5)
  print(value2)
  dlg = SymopDialog(
    parent=None,
    title="Symmetry operator input",
    label="Symmetry operator",
    value=None)
  print(get_phil_value_from_dialog(dlg))
  dlg = RTDialog(
    parent=None,
    title="Rotation/translation operator",
    wxtbxStyle=RT_DIALOG_ENABLE_FRACTIONAL)
  if (dlg.ShowModal() == wx.ID_OK):
    rt = dlg.GetMatrix()
  dlg = HTTPProxyDialog(None, title="HTTP proxy authentication")
  if (dlg.ShowModal() == wx.ID_OK):
    dlg.InstallProxy()


 *******************************************************************************


 *******************************************************************************
wxtbx/phil_controls/space_group.py
from __future__ import absolute_import, division, print_function

from wxtbx import phil_controls
from wxtbx.phil_controls.text_base import TextCtrlValidator
from libtbx.utils import Abort
import wx

class SpaceGroupCtrl(wx.ComboBox, phil_controls.PhilCtrl):
  def __init__(self, *args, **kwds):
    kwds = dict(kwds)
    saved_value = None
    if (kwds.get('value', '') != ""):
      saved_value = kwds['value']
      kwds['value'] = ""
    super(SpaceGroupCtrl, self).__init__(*args, **kwds)
    style = self.GetWindowStyle()
    self.SetWindowStyle(style | wx.TE_PROCESS_ENTER)
    self.SetValidator(SpaceGroupValidator())
    self.Bind(wx.EVT_TEXT_ENTER, lambda evt: self.Validate(), self)
    self.Bind(wx.EVT_KILL_FOCUS , lambda evt: self.OnKillFocus(evt), self)
    if (saved_value is not None):
      self.SetSpaceGroup(saved_value)
    self.SetToolTip(wx.ToolTip("You may use any valid space group symbol, "+
      "e.g. 'P212121', 'P 21 21 21', 'P2(1)2(1)2(1)', or '19'; these will be "+
      "converted internally to a standard format.  You can trigger this "+
      "conversion by entering a symbol and pressing 'Enter'."))
    if (wx.Platform == '__WXMAC__') and (wx.PlatformInfo[4] == 'wxOSX-cocoa'):
      self.SetMinSize(self.GetSize())

  def SetSpaceGroup(self, sg):
    from cctbx import sgtbx
    assert (type(sg).__name__ in ["NoneType", "str", "space_group", "unicode",
      "space_group_info"])
    items = self.GetItems()
    if (isinstance(sg, sgtbx.space_group)):
      sg = str(sgtbx.space_group_info(group=sg))
    elif (sg is not None):
      sg = str(sg)
    else :
      sg = ""
    if (not sg in items):
      self.Append(sg)
    self.SetStringSelection(sg)

  def SetValue(self, sg):
    self.SetSpaceGroup(sg)

  def GetPhilValue(self):
    self.Validate()
    sg = str(self.GetValue())
    if (sg == ""):
      return self.ReturnNoneIfOptional()
    from cctbx import sgtbx
    return sgtbx.space_group_info(symbol=sg)

  def GetStringValue(self):
    return str(self.GetPhilValue())

  def OnKillFocus(self, evt):
    if hasattr(self.GetParent(), 'get_philhandler_and_object'):
      # validate on Phaser MR whenever we loose focus
      philhandler, philobject = self.GetParent().get_philhandler_and_object()
      philvalue = self.GetPhilValue()
      from wxGUI2.Programs import Extensions
      Extensions.check_point_group(philhandler, philobject, philvalue)
    evt.Skip()

  def Validate(self):
    # XXX why doesn't self.Validate() work?
    if self.GetValidator().Validate(self.GetParent()):
      return True
    else :
      raise Abort()

  if (wx.Platform == "__WXMAC__") and (wx.PlatformInfo[4] != 'wxOSX-cocoa') \
    and wx.version().startswith('3'):
    def SetBackgroundColour(self, color):
      self.GetChildren()[0].SetBackgroundColour(color)

class SpaceGroupValidator(TextCtrlValidator):
  def CheckFormat(self, value):
    if len(value) == 0 :
      return ""
    from cctbx import sgtbx
    sg = str(sgtbx.space_group_info(symbol=str(value)))
    return sg

if (__name__ == "__main__"):
  app = wx.App(0)
  frame = wx.Frame(None, -1, "Space group test")
  panel = wx.Panel(frame, -1, size=(600,400))
  txt1 = wx.StaticText(panel, -1, "Space group:", pos=(100,180))
  sg_ctrl = SpaceGroupCtrl(panel, -1, pos=(200,180),
    name="Space group")
  btn = wx.Button(panel, -1, "Process input", pos=(400, 360))
  def OnOkay(evt):
    sg = sg_ctrl.GetPhilValue()
    print(type(sg).__name__, str(sg))
  frame.Bind(wx.EVT_BUTTON, OnOkay, btn)
  frame.Fit()
  frame.Show()
  app.MainLoop()


 *******************************************************************************


 *******************************************************************************
wxtbx/phil_controls/strctrl.py

from __future__ import absolute_import, division, print_function
from wxtbx.phil_controls.text_base import ValidatedTextCtrl, TextCtrlValidator
from wxtbx import phil_controls
import wxtbx
from libtbx.phil import tokenizer
from libtbx.utils import to_unicode, to_str
from libtbx import Auto
import libtbx.phil
import wx
import sys

class StrCtrl(ValidatedTextCtrl):
  def __init__(self, *args, **kwds):
    kwds = dict(kwds)
    if (kwds.get("size", wx.DefaultSize) == wx.DefaultSize):
      kwds['size'] = (200,-1)
    super(StrCtrl, self).__init__(*args, **kwds)
    self._min_len = 0
    self._max_len = sys.maxunicode

  def CreateValidator(self):
    return StrValidator()

  def SetValue(self, value):
    if (value in [None, Auto]):
      ValidatedTextCtrl.SetValue(self, "")
    else :
      if isinstance(value, str):
        if wxtbx.is_unicode_build():
          ValidatedTextCtrl.SetValue(self, to_unicode(value))
        else :
          ValidatedTextCtrl.SetValue(self, value)
      else :
        if (sys.version_info.major < 3) and (not isinstance(value, unicode)):
          raise RuntimeError("Improper value (type: %s) for control %s" %
            (type(value).__name__, self.GetName()))
        if (sys.version_info.major >= 3) and (not isinstance(value, str)):
          raise RuntimeError("Improper value (type: %s) for control %s" %
            (type(value).__name__, self.GetName()))
        ValidatedTextCtrl.SetValue(self, value)

  def GetPhilValue(self):
    self.Validate()
    val_str = self.GetValue().strip()
    if (val_str in ["", "none", "None"]):
      return self.ReturnNoneIfOptional()
    return val_str

  def GetStringValue(self):
    value = self.GetPhilValue()
    if (value is None):
      return "None"
    else :
      return parse_str(value)

  def FormatValue(self, value):
    if wxtbx.is_unicode_build():
      return to_str(value)
    else :
      return value

  def SetMinLength(self, n):
    assert (n >= 0)
    self._min_len = n

  def SetMaxLength(self, n):
    assert (n >= 1)
    self._max_len = n

  def GetMinLength(self):
    return self._min_len

  def GetMaxLength(self):
    return self._max_len

class StrValidator(TextCtrlValidator):
  def CheckFormat(self, value):
    window = self.GetWindow()
    if ("$" in value):
      raise ValueError("The dollar symbol ($) may not be used here.")
    elif (len(value) > window.GetMaxLength()):
      raise ValueError("Value must be %d characters or less." %
        window.GetMaxLength())
    elif (len(value) < window.GetMinLength()):
      raise ValueError("Value must be at least %d characters." %
        window.GetMinLength())
    return value # XXX does anything else need to be done here?

def parse_str(value):
  #value = value.decode("utf-8")
  try :
    word = tokenizer.word(value, quote_token='"""')
    phil_string = str(word)
  except ValueError as e :
    raise
  else :
    return phil_string

if (__name__ == "__main__"):
  app = wx.App(0)
  frame = wx.Frame(None, -1, "String parameter test")
  panel = wx.Panel(frame, -1, size=(720,400))
  txt1 = wx.StaticText(panel, -1, "Job title:", pos=(10,100))
  ctrl1 = StrCtrl(panel, -1, value=None, pos=(160, 100), size=(400,-1),
    name="Job title")
  txt2 = wx.StaticText(panel, -1, "Output file prefix:", pos=(10,200))
  ctrl2 = StrCtrl(panel, -1, value="refine", pos=(160,200),
    name="Output file prefix")
  ctrl2.SetOptional(False)
  btn = wx.Button(panel, -1, "Process input", pos=(400, 360))
  btn2 = wx.Button(panel, -1, "Toggle title", pos=(200, 360))
  master_phil = libtbx.phil.parse("""
    title = None
      .type = str
    prefix = None
      .type = str""")
  def OnOkay(evt):
    print("""title = %s""" % ctrl1.GetStringValue())
    title_phil = libtbx.phil.parse("""title = %s""" % ctrl1.GetStringValue())
    prefix_phil = libtbx.phil.parse("""prefix = %s""" % ctrl2.GetStringValue())
    p = master_phil.fetch(sources=[title_phil, prefix_phil]).extract()
    print("title recycled via phil:", p.title)
    print("prefix recycled via phil:", p.prefix)
    value1 = ctrl1.GetPhilValue()
    value2 = ctrl2.GetPhilValue()
    assert (p.title == value1), value1
    assert (p.prefix == value2)
  assert (ctrl1.GetPhilValue() is None)
  assert (ctrl1.GetStringValue() == "None")
  inp_str = """This string has bad; characters f\""""
  ctrl1.SetValue(inp_str)
  assert (ctrl1.GetPhilValue() == inp_str)
  #assert (ctrl1.GetStringValue() == '"This string has bad; characters f\\""')
  title_phil = libtbx.phil.parse("""title = %s""" % ctrl1.GetStringValue())
  p = master_phil.fetch(source=title_phil).extract()
  assert (p.title == inp_str)
  assert (ctrl2.GetPhilValue() == "refine")
  assert (ctrl2.GetStringValue() == '"""refine"""')
  def OnChange(evt):
    pass
  def OnToggle(evt):
    if (ctrl1.IsEnabled()) : ctrl1.Enable(False)
    else : ctrl1.Enable()
  frame.Bind(wx.EVT_BUTTON, OnOkay, btn)
  frame.Bind(phil_controls.EVT_PHIL_CONTROL, OnChange)
  frame.Bind(wx.EVT_BUTTON, OnToggle, btn2)
  frame.Fit()
  frame.Show()
  app.MainLoop()


 *******************************************************************************


 *******************************************************************************
wxtbx/phil_controls/strings.py

from __future__ import absolute_import, division, print_function
from wxtbx import phil_controls
from wxtbx.phil_controls.text_base import ValidatedTextCtrl, TextCtrlValidator
from libtbx.utils import Sorry
from libtbx.phil import strings_from_words, strings_as_words
from libtbx.phil import tokenizer
import wx

class StringsCtrl(ValidatedTextCtrl):
  def __init__(self, *args, **kwds):
    ValidatedTextCtrl.__init__(self, *args, **kwds)

  def GetPhilValue(self):
    self.Validate()
    vals = parse_strings(self.GetValue())
    if (len(vals) == 0):
      return None
    return vals

  def FormatValue(self, value):
    return " ".join([ str(w) for w in strings_as_words(value) ])

  def CreateValidator(self):
    return StringsValidator()

  def SetValue(self, value):
    if (value is None):
      ValidatedTextCtrl.SetValue(self, "")
    else :
      assert isinstance(value, list), value
      ValidatedTextCtrl.SetValue(self, self.FormatValue(value))

class StringsValidator(TextCtrlValidator):
  def CheckFormat(self, value):
    return parse_strings(value)

def parse_strings(value):
  try :
    if (value != "") and (not "\"" in value) and (not "'" in value):
      value = "\"" + "\" \"".join(value.split()) + "\""
    words = list(tokenizer.word_iterator(value))
    string_list = strings_from_words(words)
  except ValueError as e :
    raise Sorry(str(e))
  else :
    return string_list

if (__name__ == "__main__"):
  app = wx.App(0)
  frame = wx.Frame(None, -1, "Strings control test")
  panel = wx.Panel(frame, -1, size=(600,400))
  txt1 = wx.StaticText(panel, -1, "Elements:", pos=(100,180))
  elems_ctrl = StringsCtrl(panel, -1, pos=(300,180), size=(120,-1),
      name="Elements", style=wx.TE_PROCESS_ENTER)
  txt2 = wx.StaticText(panel, -1, "Labels list:", pos=(100,240))
  labels_ctrl = StringsCtrl(panel, -1, pos=(300,240), size=(200,-1),
      name="Labels list")
  txt2 = wx.StaticText(panel, -1, "Map types:", pos=(100,300))
  maps_ctrl = StringsCtrl(panel, -1, pos=(300,300), size=(200,-1),
      name="Map types")
  def OnUpdate(evt):
    elems = elems_ctrl.GetPhilValue()
    print("Current elements:", elems)
  def OnOkay(evt):
    print("elems:", elems_ctrl.GetPhilValue())
    print("elems phil:", elems_ctrl.GetStringValue())
    print("labels:", labels_ctrl.GetPhilValue())
    print("labels phil:", labels_ctrl.GetStringValue())
    print("map types:", maps_ctrl.GetPhilValue())
    print("map types phil:", maps_ctrl.GetStringValue())
  frame.Bind(phil_controls.EVT_PHIL_CONTROL, OnUpdate, elems_ctrl)
  btn = wx.Button(panel, -1, "Process input", pos=(400, 360))
  frame.Bind(wx.EVT_BUTTON, OnOkay, btn)
  frame.Fit()
  frame.Show()
  app.MainLoop()


 *******************************************************************************


 *******************************************************************************
wxtbx/phil_controls/symop.py

from __future__ import absolute_import, division, print_function
from wxtbx.phil_controls.text_base import ValidatedTextCtrl, TextCtrlValidator
from wxtbx import phil_controls
from libtbx.utils import Sorry
from libtbx import Auto
import wx

class SymopCtrl(ValidatedTextCtrl):
  def CreateValidator(self):
    return SymopValidator()

  def SetSymop(self, value):
    if type(value)==type(u'abc'): value = value.encode("ascii", "ignore")
    if (value is None) or (value is Auto):
      ValidatedTextCtrl.SetValue(self, "")
    elif (isinstance(value, str)):
      try :
        from cctbx import sgtbx
        rt_mx = sgtbx.rt_mx(symbol=value)
      except ValueError :
        raise Sorry("Inappropriate value '%s' for %s." % (value,
          self.GetName()))
      else :
        ValidatedTextCtrl.SetValue(self, str(value))
    else :
      raise TypeError("Type '%s' not allowed!" % type(value).__name__)

  def SetValue(self, value):
    self.SetSymop(value)

  def GetPhilValue(self):
    self.Validate()
    val_str = ValidatedTextCtrl.GetValue(self)
    if (val_str == ""):
      return self.ReturnNoneIfOptional()
    return val_str

  def FormatValue(self, value):
    return str(value)

class SymopValidator(TextCtrlValidator):
  def CheckFormat(self, value):
    if type(value)==type(u'abc'): value = value.encode("ascii", "ignore")
    from cctbx import sgtbx
    rt_mx = sgtbx.rt_mx(symbol=value)
    return value

class SymopChoiceCtrl(wx.Choice, phil_controls.PhilCtrl):
  def __init__(self, *args, **kwds):
    super(SymopChoiceCtrl, self).__init__(*args, **kwds)
    self._space_group = None
    self.Bind(wx.EVT_CHOICE, lambda evt: self.DoSendEvent(), self)

  def SetSpaceGroup(self, space_group):
    if (type(space_group).__name__ == "space_group_info"):
      space_group = space_group.group()
    self._space_group = space_group
    if (space_group is None):
      self.SetItems([])
    else :
      current_symop = self.GetStringSelection()
      symops = [ str(smx) for smx in space_group.smx() ]
      self.SetItems(symops)
      if (current_symop in symops):
        self.SetStringSelection(current_symop)

  def GetValue(self):
    """
    Returns a rotation/translation matrix.
    """
    if (self._space_group is not None):
      selected_symop = self.GetStringSelection()
      for smx in self._space_group.smx():
        if (str(smx) == selected_symop):
          return smx
    return None

  def GetPhilValue(self):
    """
    Returns a string if defined, otherwise None.
    """
    sel = self.GetStringSelection()
    if (sel == ""):
      return None
    return sel

  def SetValue(self, value):
    items = self.GetItems()
    if (str(value) in items):
      self.SetStringSelection(str(value))

if (__name__ == "__main__"):
  app = wx.App(0)
  frame = wx.Frame(None, -1, "Symop control test")
  panel = wx.Panel(frame, -1, size=(600,400))
  txt1 = wx.StaticText(panel, -1, "Symmetry operator:", pos=(100,180))
  sym_ctrl = SymopCtrl(panel, -1, pos=(300,180), size=(80,-1),
      name="Symmetry operator")
  txt2 = wx.StaticText(panel, -1, "Symmetry operator:", pos=(100,240))
  sym_ctrl_2 = SymopChoiceCtrl(panel, -1, pos=(300, 240), size=(160,-1),
      name="Symmetry operator choice")
  from cctbx import sgtbx
  sym_ctrl_2.SetSpaceGroup(sgtbx.space_group_info("P6322"))
  btn = wx.Button(panel, -1, "Process input", pos=(400, 360))
  def OnOkay(evt):
    symop = sym_ctrl.GetPhilValue()
    symop2 = sym_ctrl_2.GetPhilValue()
    print(symop, symop2)
  def OnPhilCtrl(evt):
    symop3 = sym_ctrl_2.GetValue()
    symop3.show_geometrical_elements()
  frame.Bind(wx.EVT_BUTTON, OnOkay, btn)
  frame.Bind(phil_controls.EVT_PHIL_CONTROL, OnPhilCtrl, sym_ctrl_2)
  frame.Fit()
  frame.Show()
  app.MainLoop()


 *******************************************************************************


 *******************************************************************************
wxtbx/phil_controls/text_base.py

from __future__ import absolute_import, division, print_function
from wxtbx import phil_controls
import wxtbx
from libtbx.utils import Abort, to_unicode, to_str
from libtbx import Auto
import wx
import sys

class ValidatedTextCtrl(wx.TextCtrl, phil_controls.PhilCtrl):
  def __init__(self, *args, **kwds):
    saved_value = None
    if (kwds.get('value', "") != ""):
      saved_value = kwds['value']
      kwds['value'] = ""
    super(ValidatedTextCtrl, self).__init__(*args, **kwds)
    font = wx.Font(wxtbx.default_font_size, wx.MODERN, wx.NORMAL, wx.NORMAL)
    self.SetFont(font)
    style = self.GetWindowStyle()
    if (not style & wx.TE_PROCESS_ENTER):
      style |= wx.TE_PROCESS_ENTER
      self.SetWindowStyle(style)
    self.SetValidator(self.CreateValidator())
    self.Bind(wx.EVT_TEXT_ENTER, self.OnEnter, self)
    self.Bind(wx.EVT_KILL_FOCUS, self.OnFocusLost, self)
    if saved_value is not None:
      if (type(saved_value) == str):
        save_value = to_unicode(saved_value)
      self.SetValue(saved_value)

  def GetValue(self):
    try:
      val = wx.TextCtrl.GetValue(self)
    except Exception as e:
      val = "" # Probably C++ object deleted
    if wxtbx.is_unicode_build():
      return to_str(val)
    else :
      assert isinstance(val, str)
      return val

  def OnEnter(self, evt=None):
    #self.Validate()
    self.DoSendEvent()

  def OnFocusLost(self, event):
    self.DoSendEvent()
    event.Skip()

  def CreateValidator(self):
    raise NotImplementedError()

  def Validate(self):
    # XXX why doesn't self.Validate() work?
    if self.GetValidator().Validate(self.GetParent()):
      return True
    else :
      raise Abort()

  def FormatValue(self, value):
    raise NotImplementedError()

  def GetPhilValue(self):
    raise NotImplementedError()

  def GetStringValue(self):
    value = self.GetPhilValue()
    if (value is not None) and (value is not Auto):
      return self.FormatValue(value)
    elif (self.UseAuto()) or (value is Auto):
      return Auto
    return None

  def Enable(self, enable=True):
    wx.TextCtrl.Enable(self, enable)
    if enable :
      self.SetBackgroundColour((255,255,255))
    else :
      self.SetBackgroundColour((200,200,200))

Validator = wx.Validator
if wx.VERSION < (4, 0):
  Validator = wx.PyValidator

class TextCtrlValidator(Validator):
  def __init__(self):
    Validator.__init__(self)
    self.Bind(wx.EVT_TEXT_ENTER, self.OnEnter)

  def Clone(self):
    return self.__class__()

  def TransferToWindow(self):
    return True

  def TransferFromWindow(self):
    return True

  def CheckFormat(self, value):
    raise NotImplementedError()

  def Validate(self, win):
    ctrl = self.GetWindow()
    try :
      value = to_unicode(ctrl.GetValue())
      # if isinstance(value, str):
      #   value = value.decode("utf-8")
      if (value == ""):
        ctrl.SetBackgroundColour(
          wx.SystemSettings.GetColour(wx.SYS_COLOUR_WINDOW))
        return True
      reformatted = self.CheckFormat(value)
      if isinstance(reformatted, str):
        reformatted = to_unicode(reformatted)
      ctrl.SetValue(reformatted)
      ctrl.SetBackgroundColour(
        wx.SystemSettings.GetColour(wx.SYS_COLOUR_WINDOW))
      #ctrl.SetFocus()
      ctrl.Refresh()
      return True
    except NotImplementedError :
      raise
    except Exception as e :
      ctrl_name = str(ctrl.GetName())
      msg = "Inappropriate value given for \"%s\": %s" %(ctrl_name,str(e))
      if (type(e).__name__ == "UnicodeEncodeError"):
        msg = ("You have entered characters which cannot be converted to "+
          "Latin characters in the control '%s'; due to limitations of the "+
          "underlying code, only the standard UTF-8 character set is "+
          "allowed.") % ctrl_name
      wx.MessageBox(caption="Format error", message=msg)
      ctrl.SetBackgroundColour("red")
      # Don't set focus on Windows since messagebox is modal and thus
      # would automatically recapture focus leading to an endless UI loop
      if (sys.platform != 'win32'):
        ctrl.SetFocus()
      ctrl.Refresh()
      return False

  def OnEnter(self, event):
    #self.Validate(None)
    ctrl = self.GetWindow()
    ctrl.DoSendEvent()


 *******************************************************************************


 *******************************************************************************
wxtbx/phil_controls/tree.py
from __future__ import absolute_import, division, print_function

from wx.lib.agw import customtreectrl
import wx
from libtbx.utils import Sorry
import re

class PhilTreeCtrl(customtreectrl.CustomTreeCtrl):
  def __init__(self, *args, **kwds):
    kwds = dict(kwds)
    kwds['agwStyle'] = wx.TR_HAS_VARIABLE_ROW_HEIGHT|wx.TR_HAS_BUTTONS| \
      wx.TR_TWIST_BUTTONS|wx.TR_HIDE_ROOT|wx.TR_SINGLE
    customtreectrl.CustomTreeCtrl.__init__(self, *args, **kwds)
    self.Bind(wx.EVT_TREE_KEY_DOWN, self.OnChar)
    self.Bind(wx.EVT_TREE_ITEM_RIGHT_CLICK, self.OnRightClick)
    self.Bind(wx.EVT_LEFT_DCLICK, self.OnDoubleClick)
    self.AddRoot("(parameters)")
    self._nodes_lookup_short = {}
    self._nodes_lookup_full = {}
    self._node_names_ordered = []
    self.ClearSearch()

  def DeleteAllItems(self):
    customtreectrl.CustomTreeCtrl.DeleteAllItems(self)
    self._nodes_lookup_short = {}
    self._nodes_lookup_full = {}
    self._node_names_ordered = []

  def ClearSearch(self):
    self._search_results = []
    self._current_search_text = None
    self._current_search_item = -1

  def SaveNode(self, node, phil_object):
    name = phil_object.name
    full_path = phil_object.full_path
    self._node_names_ordered.append((name, full_path))
    node.SetData(phil_object)
    if (name in self._nodes_lookup_short):
      self._nodes_lookup_short[name].append(node)
    else :
      self._nodes_lookup_short[name] = [node]
    if (full_path in self._nodes_lookup_full):
      self._nodes_lookup_full[full_path].append(node)
    else :
      self._nodes_lookup_full[full_path] = [node]

  def DrawPhilObject(self, phil_root):
    assert (phil_root.name == "")
    for phil_object in phil_root.objects :
      self._DrawPhilObject(phil_object, self.GetRootItem())

  def _DrawPhilObject(self, phil_object, current_node):
    if (phil_object.is_definition):
      node = self.AppendItem(current_node, phil_object.as_str().strip())
      self.SaveNode(node, phil_object)
    else :
      new_node = self.AppendItem(current_node, phil_object.name)
      self.SaveNode(new_node, phil_object)
      for object_ in phil_object.objects :
        self._DrawPhilObject(object_, new_node)
      self.Expand(new_node)

  def SearchItems(self, search_text, partial=False):
    if (search_text != self._current_search_text):
      results = []
      if ("." in search_text):
        for name, path in self._node_names_ordered :
          if (partial and (search_text in path)) or (path == search_text):
            results.extend(self._nodes_lookup_full[path])
      else :
        for name, path in self._node_names_ordered :
          if (partial and (search_text in name)) or (name == search_text):
            results.extend(self._nodes_lookup_short[name])
      self._search_results = results
    self.OnNext(None)
    return len(self._search_results)

  def OnNext(self, event):
    if (len(self._search_results) == 0):
      return
    self._current_search_item += 1
    if (self._current_search_item == len(self._search_results)):
      self._current_search_item = 0
    node = self._search_results[self._current_search_item]
    self.SelectItem(node)
    self.ScrollTo(node)

  def OnPrevious(self, event):
    if (len(self._search_results) == 0):
      return
    self._current_search_item -= 1
    if (self._current_search_item < 0):
      self._current_search_item = len(self._search_results) - 1
    node = self._search_results[self._current_search_item]
    self.SelectItem(node)
    self.ScrollTo(node)

  def OnChar(self, event):
    key = event.GetKeyCode()
    if (key == wx.WXK_DOWN):
      if (self._current_search_text is not None):
        self.OnPrevious(None)
      else :
        current_item = self.GetSelection()
        if (current_item is None):
          current_item = self.GetFirstVisibleItem()
        item = self.GetNextVisible(current_item)
        if (item is not None):
          self.SelectItem(item)
          self.ScrollTo(item)
    elif (key == wx.WXK_UP):
      if (self._current_search_text is not None):
        self.OnNext(None)
      else :
        current_item = self.GetSelection()
        if (current_item is None):
          item = self.GetFirstVisibleItem()
        else :
          item = self.GetPrevVisible(current_item)
        if (item is not None):
          self.SelectItem(item)
          self.ScrollTo(item)
    elif (key == wx.WXK_RETURN):
      item = self.GetSelection()
      self.EditNode(item)

  def OnRightClick(self, event):
    item = event.GetItem()
    self.EditNode(item)

  def OnDoubleClick(self, event):
    item = self.GetSelection()
    if (item is not None):
      self.EditNode(item)

  def EditNode(self, item):
    if (item is not None):
      phil_object = item.GetData()
      phil_object.show()

valid_text = re.compile("^[a-zA-Z]{1,}[a-zA-z0-9_]*$")
valid_text_partial = re.compile("^[a-zA-Z0-9_]*$")

class PhilTreeFrame(wx.Frame):
  def __init__(self, *args, **kwds):
    wx.Frame.__init__(self, *args, **kwds)
    self.panel = wx.Panel(self)
    szr = wx.BoxSizer(wx.VERTICAL)
    self.panel.SetSizer(szr)
    self.tree = PhilTreeCtrl(self.panel, -1, size=(600,400),
      style=wx.SUNKEN_BORDER)
    txt1 = wx.StaticText(self.panel, -1, "Search:")
    szr2 = wx.FlexGridSizer(cols=2)
    szr.Add(szr2)
    szr.Add(self.tree, 1, wx.EXPAND, 2)
    szr2.Add(txt1, 0, wx.ALL|wx.ALIGN_CENTER_VERTICAL, 5)
    szr3 = wx.BoxSizer(wx.HORIZONTAL)
    szr2.Add(szr3, 0, wx.ALIGN_CENTER_VERTICAL)
    search_box = wx.SearchCtrl(self.panel, style=wx.TE_PROCESS_ENTER,
      size=(160,-1))
    search_box.ShowCancelButton(True)
    szr3.Add(search_box, 0, wx.ALL|wx.ALIGN_CENTER_VERTICAL, 5)
    self.Bind(wx.EVT_TEXT_ENTER, self.OnSearch, search_box)
    self.Bind(wx.EVT_SEARCHCTRL_SEARCH_BTN, self.OnSearch, search_box)
    self.Bind(wx.EVT_SEARCHCTRL_CANCEL_BTN, self.OnCancel, search_box)
    self.partial_box = wx.CheckBox(self.panel, -1, "Include partial matches")
    szr3.Add(self.partial_box, 0, wx.ALL|wx.ALIGN_CENTER_VERTICAL, 5)
    self.search_result = wx.StaticText(self.panel, -1, "", size=(300,-1))
    szr2.Add((1,1))
    szr2.Add(self.search_result, 0, wx.ALL|wx.ALIGN_CENTER_VERTICAL, 5)
    szr.Layout()
    szr.Fit(self.panel)
    self.Fit()
    self.SetMinSize((480,320))

  def DrawPhilTree(self, phil_object):
    self.tree.DrawPhilObject(phil_object)
    self.Refresh()

  def OnSearch(self, event):
    search_text = event.GetEventObject().GetValue()
    partial = self.partial_box.GetValue()
    if ((partial and (not valid_text_partial.match(search_text))) or
        (not partial and (not valid_text.match(search_text)))):
      self.search_result.SetLabel("Invalid search text!")
      self.search_result.SetForegroundColour((200,0,0))
      raise Sorry("Invalid search text - only alphanumeric characters ("+
        "including) underscore are allowed.  If partial matches are not "+
        "included, the search text must also begin with a letter.")
    n_items = self.tree.SearchItems(search_text, partial)
    if (n_items == 0):
      self.search_result.SetForegroundColour((200,0,0))
    else :
      self.search_result.SetForegroundColour((0,0,0))
    self.search_result.SetLabel("%d items found" % n_items)
    self.panel.Layout()

  def OnCancel(self, event):
    event.GetEventObject().Clear()
    self.tree.ClearSearch()

if (__name__ == "__main__"):
  from mmtbx.command_line import fmodel
  app = wx.App(0)
  frame  = PhilTreeFrame(None, -1, "Phenix settings")
  frame.DrawPhilTree(fmodel.fmodel_from_xray_structure_master_params)
  frame.Show()
  app.MainLoop()


 *******************************************************************************


 *******************************************************************************
wxtbx/phil_controls/tribool.py

from __future__ import absolute_import, division, print_function
from wxtbx import phil_controls
from libtbx import Auto
import wx

WXTBX_TRIBOOL_TRUE_FALSE = 0
WXTBX_TRIBOOL_YES_NO = 1
WXTBX_TRIBOOL_DISABLE_AUTO = 2
WXTBX_TRIBOOL_AUTO_IS_NONE = 4

class TriBoolCtrl(wx.Choice, phil_controls.PhilCtrl):
  """
  Three-way boolean control: returns True, False, or Auto (optionally None).
  Can be two-way if WXTBX_TRIBOOL_DISABLE_AUTO is specified.
  """
  def __init__(self, *args, **kwds):
    phil_controls.PhilCtrl.__init__(self)
    self.SetOptional(True)
    kwds = dict(kwds)
    self._tribool_style = kwds.get("style", WXTBX_TRIBOOL_TRUE_FALSE)
    kwds['style'] = 0
    wx.Choice.__init__(self, *args, **kwds)
    items = []
    if (self._tribool_style & WXTBX_TRIBOOL_YES_NO):
      items.extend(["Yes","No"])
    else :
      items.extend(["True","False"])
    if (not self._tribool_style & WXTBX_TRIBOOL_DISABLE_AUTO):
      items.append("Auto")
    self.SetItems(items)
    self.Bind(wx.EVT_CHOICE, lambda evt: self.DoSendEvent(), self)

  def SetValue(self, value):
    if (value == True):
      self.SetSelection(0)
    elif (value == False):
      self.SetSelection(1)
    else :
      assert (value in [None, Auto])
      if (self._tribool_style & WXTBX_TRIBOOL_DISABLE_AUTO):
        self.SetSelection(wx.NOT_FOUND)
      else :
        self.SetSelection(2)

  def GetValue(self):
    return self.GetPhilValue()

  def GetPhilValue(self):
    sel = self.GetSelection()
    if (sel < 0):
      return self.ReturnNoneIfOptional()
    vals = [True, False]
    if (self._tribool_style & WXTBX_TRIBOOL_AUTO_IS_NONE):
      vals.append(None)
    else :
      vals.append(Auto)
    return vals[self.GetSelection()]

  def GetStringValue(self):
    return str(self.GetPhilValue())

if (__name__ == "__main__"):
  app = wx.App(0)
  frame = wx.Frame(None, -1, "Tribool test")
  panel = wx.Panel(frame, -1, size=(720,480))
  txt1 = wx.StaticText(panel, -1, "Hydrogens:", pos=(20,180))
  choice1 = TriBoolCtrl(panel, -1, pos=(240,180))
  choice1.SetOptional(True)
  txt2 = wx.StaticText(panel, -1, "Add waters:", pos=(20, 240))
  choice2 = TriBoolCtrl(panel, -1, pos=(240,240),
    style=WXTBX_TRIBOOL_DISABLE_AUTO)
  assert (choice1.GetPhilValue() == True)
  assert (choice2.GetPhilValue() == True)
  choice1.SetValue(None)
  assert (choice1.GetStringValue() == "Auto")
  choice2.SetOptional(False)
  choice2.SetValue(None)
  try :
    print(choice2.GetPhilValue())
  except Exception as e :
    assert (str(e) == "Value required for 'choice'.")
  else :
    assert 0
  frame.Fit()
  frame.Show()
  app.MainLoop()


 *******************************************************************************


 *******************************************************************************
wxtbx/phil_controls/unit_cell.py
from __future__ import absolute_import, division, print_function

from wxtbx.phil_controls.text_base import ValidatedTextCtrl, TextCtrlValidator
import wx

class UnitCellCtrl(ValidatedTextCtrl):
  def __init__(self, *args, **kwds):
    super(UnitCellCtrl, self).__init__(*args, **kwds)
    self.SetToolTip(wx.ToolTip(
      "If all unit cell edges are perpendicular to each "+
      "other, you only need to enter the edge lengths; the angles will be "+
      "filled in as 90 degrees each.  You can trigger this conversion by "+
      "typing in the cell lengths and pressing 'Enter'."))

  def CreateValidator(self):
    return UnitCellValidator()

  def SetUnitCell(self, uc):
    if (type(uc).__name__ == "unit_cell"):
      uc = self.FormatValue(uc)
    elif (uc is None):
      uc = ""
    from six import string_types
    assert isinstance(uc, string_types)
    wx.TextCtrl.SetValue(self, uc)

  def SetValue(self, value):
    self.SetUnitCell(value)

  def FormatValue(self, value):
    if (value is None):
      return "None"
    return "%g %g %g %g %g %g" % value.parameters()

  def GetPhilValue(self):
    self.Validate()
    val_str = str(wx.TextCtrl.GetValue(self))
    if (val_str == ""):
      return self.ReturnNoneIfOptional()
    from cctbx import uctbx
    return uctbx.unit_cell(val_str)

class UnitCellValidator(TextCtrlValidator):
  def CheckFormat(self, value):
    if (len(value) == 0):
      return ""
    from cctbx import uctbx
    uc = uctbx.unit_cell(str(value))
    return uc
#    return self.GetWindow().FormatValue(uc)

if (__name__ == "__main__"):
  app = wx.App(0)
  frame = wx.Frame(None, -1, "Unit cell test")
  panel = wx.Panel(frame, -1, size=(600,400))
  txt1 = wx.StaticText(panel, -1, "Unit cell:", pos=(100,180))
  sg_ctrl = UnitCellCtrl(panel, -1, pos=(200,180), size=(300,-1),
    name="Unit cell")
  btn = wx.Button(panel, -1, "Process input", pos=(400, 360))
  def OnOkay(evt):
    uc = sg_ctrl.GetPhilValue()
    print(type(uc).__name__, str(uc))
  frame.Bind(wx.EVT_BUTTON, OnOkay, btn)
  frame.Fit()
  frame.Show()
  app.MainLoop()


 *******************************************************************************


 *******************************************************************************
wxtbx/plots/__init__.py
from __future__ import absolute_import, division, print_function
from wxtbx import bitmaps
import wxtbx
import wx
from libtbx import object_oriented_patterns as oop
from libtbx.math_utils import ifloor
from libtbx import adopt_init_args
import operator
import math
import sys
from six.moves import range

# explicitly set locale for matplotlib 2.0.0, otherwise, on macOS,
# locale.getpreferredencoding(do_setlocale=False) returns an empty string
# for consistency, set locale according to LC_ALL for both linux and macOS
if (sys.platform != 'win32'):
  import locale
  locale.setlocale(locale.LC_ALL, '')

class plot_container(wx.BoxSizer, wxtbx.MouseWheelTransparencyMixin):
  def __init__(self,
                parent,
                figure_size=(8,6),
                font_size=12,
                title_font_size=10,
                facecolor='white',
                transparent=False,
                handle_left_click=False,
                show_data_points=True,
                point_types=('o', '^', '+', 's', 'D'),
                title_alignment="right",
                toolbar_position=None):
    wx.BoxSizer.__init__(self, wx.VERTICAL)
    adopt_init_args(self, locals())
    self._fonts = {}
    self.disabled = False
    try :
      import matplotlib
      from matplotlib.backends.backend_wxagg import FigureCanvasWxAgg
      from matplotlib.backends.backend_wxagg import FigureManager
      import matplotlib.ticker
      import matplotlib.cm
      import matplotlib.figure
      import matplotlib.font_manager
    except ImportError as e :
      print("")
      print("Error loading matplotlib module:")
      print(e)
      print("")
      self.disabled = True
      self.canvas = oop.null()
      self.figure = oop.null()
      self.text_font = oop.null()
      self.p = oop.null()
      w = int(figure_size[0] * 72)
      h = int(figure_size[1] * 72)
      panel = wx.Panel(parent=parent,
        size=(w,h))
      panel.SetBackgroundColour((150,150,150))
      szr = wx.BoxSizer(wx.VERTICAL)
      panel.SetSizer(szr)
      txt = wx.StaticText(parent=panel,
        label="Plotting disabled due to missing libraries.")
      szr.Add(txt, 1, wx.ALL|wx.ALIGN_CENTER, 10)
      txt.SetForegroundColour((255,0,0))
      font = txt.GetFont()
      font.SetWeight(wx.FONTWEIGHT_BOLD)
      txt.SetFont(font)
      txt2 = wx.StaticText(parent=panel, label="Original error:")
      txt2.SetForegroundColour((255,0,0))
      szr.Add(txt2, 1, wx.ALL|wx.ALIGN_CENTER, 10)
      txt3 = wx.StaticText(parent=panel, label=str(e))
      txt3.SetForegroundColour((255,0,0))
      szr.Add(txt3, 1, wx.ALL|wx.ALIGN_CENTER, 10)
      self.Add(panel, 1, wx.EXPAND|wx.ALL)
      self.null_fmt = oop.null()
    else :
      self.figure = matplotlib.figure.Figure(figure_size, 72, linewidth=0,
        facecolor=facecolor)
      if transparent :
        self.figure.figurePatch.set_alpha(0.0)
      self.canvas = FigureCanvasWxAgg(self.parent, -1, self.figure)
      self.canvas.toolbar = oop.null()
      try: # XXX TEMPORARY Python 3 FIX TT  conda_base/lib/python3.8/site-packages/matplotlib/backends/backend_wx.py", line 1041, in set_window_title AttributeError: 'RefinementStatsPlot' object has no attribute 'SetTitle'
        self.figmgr = FigureManager(self.canvas, 1, self)
      except Exception as e:
        pass
      if toolbar_position and self.figmgr.toolbar:
        self.figmgr.toolbar.SetPosition(toolbar_position)
      self.Add(self.canvas, 1, wx.EXPAND|wx.ALL)
      self.setup_fonts()
      self.null_fmt = matplotlib.ticker.NullFormatter()
      if self.handle_left_click :
        self.canvas.mpl_connect("button_release_event", self.OnClick)
      else :
        self.canvas.Bind(wx.EVT_CONTEXT_MENU, self.OnRightClick, self.canvas)
      if (wx.Platform == '__WXMAC__') : # FIXME MSW okay, check GTK
        self.canvas.Bind(wx.EVT_MOUSEWHEEL, self.OnMouseWheel, self.canvas)

  def GetParent(self):
    return self.parent

  def setup_fonts(self):
    import matplotlib.font_manager
    self._fonts["basic"] = matplotlib.font_manager.FontProperties(
      family = ["Courier", "Monaco", "monospace"],
      weight = "normal",
      size   = 10)
    self._fonts["value_label"] = matplotlib.font_manager.FontProperties(
      family = ["Courier", "Monaco", "monospace"],
      weight = "normal",
      size   = self.font_size)
    self._fonts["axis_label"] = matplotlib.font_manager.FontProperties(
      family = ["Helvetica", "sans-serif"],
      weight = "bold",
      size   = self.font_size)
    self._fonts["text"] = matplotlib.font_manager.FontProperties(
      family = ["Helvetica", "sans-serif"],
      weight = "normal",
      size   = self.font_size)
    self._fonts["title"] = matplotlib.font_manager.FontProperties(
      family = ["Helvetica", "sans-serif"],
      weight = "bold",
      size   = self.title_font_size)

  def get_font(self, font_type):
    font = self._fonts.get(font_type, None)
    if (font is None):
      font = self._fonts.get("basic", None)
    return font

  def GetToolBar(self):
    return None

  def OnRightClick(self, event):
    pass

  def OnClick(self, event):
    if not hasattr(event, "button"):
      raise RuntimeError("The OnClick method of plot_container handles "+
        "matplotlib events only.  Please fix your code!")
    if event.button == 1 :
      self.process_mouse_click(event)

  def process_mouse_click(self, mpl_event):
    pass

  def save_image(self, default_path="", default_filename="plot.png"):
    output_file = wx.FileSelector("Saved image name",
      default_path=default_path,
      default_filename=default_filename,
      wildcard="Adobe PDF figure (*.pdf)|*.pdf|" + \
               "PNG image (*.png)|*.png|" + \
               "Postscript figure (*.ps)|*.ps", flags=wx.FD_SAVE)
    if output_file != "" :
      if output_file[-3:] == "pdf" :
        self.figure.savefig(output_file, orientation="landscape", format="pdf")
      elif output_file[-2:] == "ps" :
        self.figure.savefig(output_file, orientation="landscape", format="ps")
      else :
        self.figure.savefig(output_file, format="png")

class histogram(plot_container):
  def show_histogram(self, data, n_bins, reference_value=None, pos=(1,1,1),
                      draw_now=True, x_label=None, y_label=None, title=None,
                      log_scale=False, x_lim=None, y_lim=None):
    assert len(pos) == 3
    self.figure.clear()
    p = self.figure.add_subplot(*pos)
    p.hist(data, n_bins, facecolor='blue', log=log_scale)
    if reference_value is not None :
      p.axvline(reference_value, color='r')
    if (x_label is not None):
      p.set_xlabel(x_label)
    if (y_label is not None):
      p.set_ylabel(y_label)
    if (x_lim is not None):
      p.set_xlim(x_lim[0], x_lim[1])
    if (y_lim is not None):
      p.set_ylim(y_lim[0], y_lim[1])
    if (title is not None):
      p.set_title(title)
    if draw_now :
      self.canvas.draw()
    return p

def convert_xyz_value_list(values, null_value=0.0):
  import numpy
  values = sorted(values, key=operator.itemgetter(0))
  x_rows = [[values[0]]]
  for i, xyz in enumerate(values[1:]):
    if (xyz[0] != x_rows[-1][-1][0]):
      x_rows.append([])
    x_rows[-1].append(xyz)
  x_values = [ x_row[0][0] for x_row in x_rows ]
  y_values = sorted([ x_rows[0][n][1] for n in range(len(x_rows[0])) ])
  assert (len(values) == (len(x_values) * len(y_values)))
  z_values = []
  for j in range(len(y_values)):
    z_values.append([])
  for i, x_row in enumerate(x_rows):
    x_row = sorted(x_row, key=operator.itemgetter(1))
    for j, (x,y,z) in enumerate(x_row):
      assert (y in y_values)
      if (z is not None):
        assert (isinstance(z, int) or isinstance(z, float))
        z_values[j].append(z)
      else :
        z_values[j].append(numpy.NaN)
      #  z_values[j].append(null_value)
  return (numpy.array(x_values), numpy.array(y_values), numpy.array(z_values))

class image_plot(plot_container):
  def show_plot(self,
                 x_data=(),
                 y_data=(),
                 z_data=(),
                 values=(),
                 x_label=None,
                 y_label=None,
                 title=None,
                 cmap=None,
                 interpolation="nearest"):
    if (len(values) > 0):
      assert (len(x_data) == len(y_data) == len(z_data) == 0)
      (x_data, y_data, z_data) = convert_xyz_value_list(values)
    from matplotlib.image import NonUniformImage
    self.figure.clear()
    ax = self.figure.add_subplot(111)
    im = NonUniformImage(ax, interpolation=interpolation)
    if (cmap is not None):
      im.set_cmap(get_colormap(cmap))
    im.set_data(x_data, y_data, z_data)
    ax.images.append(im)
    ax.set_xlim(x_data[0], x_data[-1])
    ax.set_ylim(y_data[0], y_data[-1])
    if (x_label is not None):
      ax.set_xlabel(x_label)
    if (y_label is not None):
      ax.set_ylabel(y_label)
    if (title is not None):
      ax.set_title(title)
    self.canvas.draw()

class iotbx_data_plot_base(plot_container):
  def __init__(self,
                parent,
                tables,
                size=(640,480),
                **kwds):
    adopt_init_args(self, locals())
    (x, y, w, h) = tuple(wx.GetClientDisplayRect())
    (width, height) = size
    fig_w = float(width) / 72.0
    fig_h = float(height) / 72.0
    if (fig_w * 72) > (w - 20):
      fig_w = int(math.floor((w-40) / 72))
    if (fig_h * 72) > (h - 120):
      fig_h = int(math.floor((h-160) / 72))
    plot_container.__init__(self, parent, (fig_w, fig_h), **kwds)
    self.p = self.figure.add_subplot(111)
    self.plot_type = None

  def set_tables(self, tables):
    self.tables = tables

  def set_plot(self, graph_name=None, table_name=None, table_index=0):
    table = None
    if table_name is None :
      table = self.tables[table_index]
    else :
      for t in self.tables :
        if t.title == table_name :
          table = t
    if table is not None :
      self.plot_type = getattr(table, "plot_type", "GRAPH")
      graph = table.get_graph(graph_name)
      self.show_plot(graph, reference_lines=table.get_reference_marks())

  def show_plot(self, graph, line_width=1, show_points=True, show_grid=True,
      reference_lines=None):
    if self.disabled :
      return
    self.figure.clear()
    self.graph = graph
    self.p = self.figure.add_subplot(111)
    if graph is None :
      return
    if self.plot_type == "SCATTER" :
      show_points = True
      show_lines = False
    else :
      show_lines = True
    if self.show_data_points :
      point_types = self.point_types #['o', '^', '+', 's', 'D']
    else :
      point_types = [""]
    point_index = 0
    for (x_values, y_values) in self.graph.get_plots():
      plot_type = ""
      if show_points :
        plot_type = "%s" % point_types[point_index]
        point_index += 1
        if point_index >= len(point_types):
          point_index = 0
      if show_lines :
        plot_type += "-"
      self.p.plot(x_values, y_values, plot_type, linewidth=line_width)
    if (reference_lines is not None):
      for x in reference_lines :
        if (x is not None):
          self.p.axvline(x=x, linewidth=1)
    self.format_labels()
    if show_grid :
      self.p.grid(True, color="0.75")
    self.p.set_autoscale_on(True)
    self.p.set_title(graph.name, fontproperties=self.get_font("title"),
      horizontalalignment=self.title_alignment)
    self.canvas.draw()
    self.parent.Refresh()

  def format_x_axis(self):
    if self.tables[0].x_is_inverse_d_min :
      xdata = self.tables[0].get_x_as_resolution()
      self.p.set_xlabel("Resolution",
        fontproperties=self.get_font("axis_label"))
      if (getattr(self.tables[0], "force_exact_x_labels", False)):
        xticks_ = self.tables[0].get_x_values()
      else :
        xticks_ = self.p.get_xticks()
      n_skip = max(1, ifloor(len(xticks_) / 10))
      xticks = []
      xticklabels = []
      k = 0
      while (k < len(xticks_)):
        x = xticks_[k]
        xticks.append(x)
        if (x != 0):
          if x > 0.0:
            x = math.sqrt(1 / x)
          else:
            x = -math.sqrt(1 / abs(x) )
          xticklabels.append("%.2f" % x)
        else : # FIXME?
          xticklabels.append("")
        k += n_skip
      self.p.set_xticks(xticks)
      self.p.set_xticklabels(xticklabels)
    else :
      if self.graph.x_axis_label is not None :
        self.p.set_xlabel(self.graph.x_axis_label,
          fontproperties=self.get_font("axis_label"))
      else :
        self.p.set_xlabel(self.graph.x_label,
          fontproperties=self.get_font("axis_label"))
    for ticklabel in self.p.get_xticklabels():
      ticklabel.set_fontproperties(self.get_font("value_label"))

  def axvline(self, x, **kwargs):
    if self.tables[0].x_is_inverse_d_min :
      self.p.axvline(x=(1.0 / (x**2)), **kwargs)
    else :
      self.p.axvline(x=x, **kwargs)
    self.canvas.draw()
    self.parent.Refresh()

  def format_y_axis(self):
    for ticklabel in self.p.get_yticklabels():
      ticklabel.set_fontproperties(self.get_font("value_label"))
    if self.graph.y_axis_label is not None :
      self.p.set_ylabel(self.graph.y_axis_label,
          fontproperties=self.get_font("axis_label"))

  def format_labels(self):
    self.figure.legend(self.p.lines, self.graph.y_labels,
      prop=self.get_font("text"))
    self.format_x_axis()
    self.format_y_axis()

  def show_grid(self, show=True):
    if show :
      self.p.grid(True, color="0.75")
    else :
      self.p.grid(False)
    self.canvas.draw()
    self.parent.Refresh()

  def OnRightClick(self, event):
    if (wx.Platform != '__WXMAC__') : # FIXME
      menu = wx.Menu()
      menu_item = menu.Append(-1, "Save image")
      self.parent.Bind(wx.EVT_MENU, self.OnSave, menu_item)
      self.parent.PopupMenu(menu)
      menu.Destroy()

  def OnSave(self, event=None):
    self.save_image()

class small_plot(iotbx_data_plot_base):
  def __init__(self, parent, table, size=(320,320)):
    iotbx_data_plot_base.__init__(self,
      parent=parent,
      tables=[table],
      size=size,
      font_size=9,
      title_font_size=10,
      title_alignment="center",
      point_types=('+'))

class plot_frame(wx.Frame):
  controls_on_top = True
  show_controls_default = True
  def __init__(self, *args, **kwds):
    wx.Frame.__init__(self, *args, **kwds)
    self.setup_toolbar()
    self.toolbar.Realize()
    self.sizer = wx.BoxSizer(wx.VERTICAL)
    self.draw_top_panel()
    self.plot_panel = self.create_plot_panel()
    if self.controls_on_top :
      self.sizer.Add(self.top_panel, 0, wx.EXPAND|wx.ALL)
      self.sizer.Add(self.plot_panel, 1, wx.EXPAND|wx.ALL)
    else :
      self.sizer.Add(self.plot_panel, 1, wx.EXPAND|wx.ALL)
      self.sizer.Add(self.top_panel, 0, wx.EXPAND|wx.ALL)
    self._show_controls = self.show_controls_default
    if not self.show_controls_default :
      self.top_panel.Hide()
    self.SetSizer(self.sizer)
    self.sizer.Layout()
    self.Fit()
    self.Bind(wx.EVT_CLOSE, self.OnClose, self)
    self.Bind(wx.EVT_WINDOW_DESTROY, self.OnDestroy, self)

  def setup_toolbar(self):
    tb_buttons = [
      ("Show/hide controls",
       bitmaps.fetch_icon_bitmap("apps", "advancedsettings"),
       self.OnToggleControls),
      ("Save",
       bitmaps.fetch_icon_bitmap("actions", "save_all"),
       self.OnSave),
      #("Print",
      # bitmaps.fetch_icon_bitmap("devices", "printer1"),
      # self.OnPrint),
    ]
    tb = wx.ToolBar(self, style=wx.TB_TEXT)
    tb.SetToolBitmapSize((32,32))
    self.SetToolBar(tb)
    for (name, bitmap, function) in tb_buttons :
      tool_button = tb.AddLabelTool(-1, name, bitmap, kind=wx.ITEM_NORMAL)
      self.Bind(wx.EVT_MENU, function, tool_button)
    self.toolbar = tb

  def draw_top_panel(self):
    self.top_panel = wx.Panel(parent=self, style=wx.SUNKEN_BORDER)

  def create_plot_panel(self):
    return (0,0)

  def OnExit(self, event):
    self.Close()

  def OnClose(self, event):
    wx.CallAfter(self.Destroy)

  def OnDestroy(self, event):
    pass

  def OnSave(self, event):
    self.plot_panel.save_image()

  def OnToggleControls(self, event):
    if self._show_controls :
      self._show_controls = False
      self.top_panel.Hide()
    else :
      self._show_controls = True
      self.top_panel.Show()
    self.sizer.Layout()
    self.Fit()

class loggraph(plot_frame):
  plot_type = "loggraph"
  controls_on_top = True
  show_controls_default = True
  table_selection_label = "Table:"
  plot_selection_label = "Plot:"
  def __init__(self, parent, title, tables=None, file_name=None,
      processed_lines=None):
    adopt_init_args(self, locals())
    self.tables = []
    self.graph = None
    self.table_frame = None
    self.table_chooser = None
    self.plot_chooser = None
    self.current_table = None
    self.current_plot = None
    if tables is not None :
      self.tables = tables
    elif file_name is not None or processed_lines is not None :
      self.load_log(file_name, processed_lines, update=False)
      if len(self.tables) > 0 :
        self.current_table = self.tables[0].title
        self.current_plot = self.tables[0].graph_names[0]
    plot_frame.__init__(self, parent=parent, title=title)
    self.Bind(wx.EVT_CLOSE, self.OnClose)
    self.Centre()
    self.switch_plot()

  def draw_top_panel(self):
    self.top_panel = wx.Panel(parent=self, style=wx.SUNKEN_BORDER)
    cp = self.top_panel
    cp_sizer = wx.BoxSizer(wx.VERTICAL)
    cp.SetSizer(cp_sizer)
    grid = wx.FlexGridSizer(cols=2)
    txt = wx.StaticText(self.top_panel, -1, "Table:")
    # TODO: set bold-face
    grid.Add(txt, 0, wx.ALL|wx.EXPAND, 5)
    self.table_chooser = wx.Choice(parent=cp,
      choices=[ t.title for t in self.tables])
    if (len(self.tables) > 0):
      self.table_chooser.SetSelection(0)
    self.Bind(wx.EVT_CHOICE, self.OnSelectTable, self.table_chooser)
    grid.Add(self.table_chooser, 0, wx.ALL|wx.EXPAND, 5)
    txt2 = wx.StaticText(self.top_panel, -1, "Plot:")
    grid.Add(txt2, 0, wx.ALL|wx.EXPAND, 5)
    plot_choices = self.tables[0].graph_names
    self.plot_chooser = wx.Choice(parent=cp,
      choices=plot_choices)
    if (len(plot_choices) > 0):
      self.plot_chooser.SetSelection(0)
    self.Bind(wx.EVT_CHOICE, self.OnSelectPlot, self.plot_chooser)
    grid.Add(self.plot_chooser, 0, wx.ALL|wx.EXPAND, 5)
    cp_sizer.Add(grid, 0, wx.EXPAND)
    szr = wx.BoxSizer(wx.HORIZONTAL)
    cp_sizer.Add(szr, 0, wx.EXPAND)
    grid_box = wx.CheckBox(parent=cp,
      label="Show grid")
    grid_box.SetValue(True)
    self.Bind(wx.EVT_CHECKBOX, self.OnToggleGrid, grid_box)
    szr.Add(grid_box, 0, wx.ALL|wx.ALIGN_CENTER_VERTICAL, 5)
    point_box = wx.CheckBox(parent=cp,
      label="Show data points")
    point_box.SetValue(True)
    self.Bind(wx.EVT_CHECKBOX, self.OnTogglePoints, point_box)
    szr.Add(point_box, 0, wx.ALL|wx.ALIGN_CENTER_VERTICAL, 5)
    return cp

  def create_plot_panel(self):
    self.plot = iotbx_data_plot_base(
      parent=self,
      tables=self.tables,
      transparent=False)
    return self.plot

  def load_log(self, file_name=None, processed_lines=None, update=True):
    from iotbx import data_plots
    if processed_lines :
      self.tables = data_plots.import_ccp4i_logfile(log_lines=processed_lines)
    else :
      self.tables = data_plots.import_ccp4i_logfile(file_name=file_name)
    if update :
      self.update_interface()

  def update_interface(self, update_tables=True):
    if len(self.tables) > 0 :
      if update_tables :
        table_choices = [t.title for t in self.tables]
        self.table_chooser.SetItems(table_choices)
        self.table_chooser.SetSelection(0)
      self.plot_chooser.SetItems(self.get_table().graph_names)
      self.plot_chooser.SetSelection(0)
      self.top_panel.Layout()
      self.switch_plot()

  def set_current_plot(self, plot_name):
    for t in self.tables :
      for t_plot_name in t.graph_names :
        if plot_name == t_plot_name :
          self.table_chooser.SetStringSelection(t.title)
          self.plot_chooser.SetStringSelection(plot_name)
          break
    self.switch_plot()

  def switch_plot(self):
    table = self.table_chooser.GetStringSelection()
    plot = self.plot_chooser.GetStringSelection()
    if table != "" and plot != "" :
      self.plot.set_plot(graph_name=plot, table_name=table)
      #self.Refresh()

  #--- EVENTS
  def OnSelectTable(self, event):
    table_name = self.table_chooser.GetStringSelection()
    current_plot = self.plot_chooser.GetStringSelection()
    plot_choices = []
    for t in self.tables :
      if t.title == table_name :
        plot_choices = t.graph_names
    self.plot_chooser.SetItems(plot_choices)
    if current_plot in plot_choices :
      self.plot_chooser.SetStringSelection(current_plot)
    self.switch_plot()

  def OnSelectPlot(self, event):
    self.switch_plot()

  def OnPrint(self, event):
    pass

  def OnToggleGrid(self, event):
    show = event.GetEventObject().GetValue()
    self.plot.show_grid(show)

  def OnTogglePoints(self, event):
    self.plot.show_data_points = event.GetEventObject().GetValue()
    self.switch_plot()

standard_colormaps = [ ("jet", "Rainbow"),
                       ("Greys", "Greyscale"),
                       ("Reds", "Red"),
                       ("YlGn", "Yellow/Green"),
                       ("Greens", "Green"),
                       ("Blues", "Blue"),
                     ]
colormap_names = [ cm_name for cm_id, cm_name in standard_colormaps ]
colormap_id_dict = dict([ (name, id) for id, name in standard_colormaps ])

def get_colormap(cm_name):
  import matplotlib.cm
  cm = None
  for cm_id, cm_name2 in standard_colormaps :
    if cm_name2 == cm_name :
      cm = getattr(matplotlib.cm, cm_id, None)
      break
  else :
    cm = getattr(matplotlib.cm, cm_name, None)
  if cm is None :
    cm = matplotlib.cm.jet
  return cm

def exercise():
  values = [
    (1.5, 3.0, 40.2),
    (2.5, 3.5, 35.1),
    (1.5, 3.5, 45.6),
    (2.0, 3.5, 54.2),
    (1.5, 4.5, 48.2),
    (2.5, 4.5, 28.4),
    (2.5, 4.0, 37.6),
    (2.0, 2.5, None),
    (2.0, 3.0, 29.8),
    (2.0, 4.0, 36.7),
    (2.0, 4.5, 33.2),
    (2.5, 2.5, None),
    (1.5, 2.5, 39.5),
    (2.5, 3.0, None),
    (1.5, 4.0, 50.9),
  ]
  sys.path.pop(0)
  from iotbx import data_plots
  loggraph1 = """\
$TABLE: Resolution shell statistics
$GRAPHS
:R-free vs. resolution
:A:1,3:
:FOM vs. resolution
:A:1,4:
$$
1/resol^2  Nrefl      R-free     FOM       $$
$$
0.02       2004       0.25       0.89
0.04       2084       0.23       0.88
0.06       2037       0.27       0.83
0.08       1949       0.28       0.75
0.1        1783       0.38       *
$$
"""
  app = wx.App(0)
  frame = loggraph(parent=None,
    title="Loggraph test",
    tables=None,
    processed_lines=loggraph1.splitlines())
  frame.Show()
  frame2 = wx.Frame(None, -1, "Heat map")
  panel = wx.Panel(frame2, -1)
  sizer2 = wx.BoxSizer(wx.VERTICAL)
  frame2.SetSizer(sizer2)
  sizer2.Add(panel, 1, wx.EXPAND)
  implot = image_plot(panel)
  implot.show_plot(values=values, x_label="RMSD", y_label="resolution",
    cmap="autumn")
  sizer2.Layout()
  frame2.Fit()
  frame2.Show()
  app.MainLoop()

if __name__ == "__main__" :
  exercise()


 *******************************************************************************


 *******************************************************************************
wxtbx/plots/emringer.py

"""
wxPython-specific code for displaying EM-Ringer plots.  The actual Matplotlib
plotting code lives in mmtbx.ringer.em_scoring.
"""

from __future__ import absolute_import, division, print_function
from wxtbx.phil_controls import floatctrl
from wxtbx import phil_controls
import wxtbx.plots
import wx

class peaks_plot(wxtbx.plots.plot_container):
  pass

class emringer_plot_frame(wxtbx.plots.plot_frame):
  """Base class for all frames enclosing plots."""
  def __init__(self, *args, **kwds):
    self._result = None
    wxtbx.plots.plot_frame.__init__(self, *args, **kwds)

  def SetResult(self, result):
    self._result = result
    self._load_result()

  def _load_result(self):
    raise NotImplementedError()

class peaks_plot_frame(emringer_plot_frame):
  def create_plot_panel(self):
    return peaks_plot(self)

  def draw_top_panel(self):
    wxtbx.plots.plot_frame.draw_top_panel(self)
    szr = wx.BoxSizer(wx.HORIZONTAL)
    self.top_panel.SetSizer(szr)
    label = wx.StaticText(self.top_panel, -1, "Density threshold:")
    szr.Add(label, 0, wx.ALL, 5)
    self.threshold_choice = wx.Choice(self.top_panel, -1, size=(160,-1))
    szr.Add(self.threshold_choice, 0, wx.ALL, 5)
    self.Bind(wx.EVT_CHOICE, self.OnSetThreshold, self.threshold_choice)

  def _load_result(self):
    self.threshold_choice.SetItems(["%.3f"%x for x in self._result.thresholds])
    self._set_threshold(0)

  def OnSetThreshold(self, evt):
    self._set_threshold(evt.GetEventObject().GetSelection())

  def _set_threshold(self, i):
    assert (self._result is not None)
    self._result.draw_wx_peaks_plot(
      plot=self.plot_panel,
      i_threshold=i)
    self.plot_panel.canvas.draw()

class threshold_plot(wxtbx.plots.plot_container):
  pass

class threshold_plot_frame(emringer_plot_frame):
  def create_plot_panel(self):
    return threshold_plot(self)

  def _load_result(self):
    assert (self._result is not None)
    self._result.draw_wx_progression_plot(plot=self.plot_panel)
    self.plot_panel.canvas.draw()

class rolling_plot(wxtbx.plots.plot_container):
  pass

class rolling_plot_frame(emringer_plot_frame):
  def create_plot_panel(self):
    return rolling_plot(self)

  def draw_top_panel(self):
    wxtbx.plots.plot_frame.draw_top_panel(self)
    szr = wx.BoxSizer(wx.HORIZONTAL)
    self.top_panel.SetSizer(szr)
    label1 = wx.StaticText(self.top_panel, -1, "Chain ID:")
    szr.Add(label1, 0, wx.ALL, 5)
    self.chain_choice = wx.Choice(self.top_panel, -1, size=(160,-1))
    szr.Add(self.chain_choice, 0, wx.ALL, 5)
    self.Bind(wx.EVT_CHOICE, self.OnSetChain, self.chain_choice)
    #label2 = wx.StaticText(self.top_panel, -1, "Density threshold:")
    #szr.Add(label2, 0, wx.ALL, 5)
    #self.threshold_entry = floatctrl.FloatCtrl(
    #  parent=self.top_panel,
    #  size=(80,-1),
    #  value=0,
    #  style=wx.TE_PROCESS_ENTER)
    #self.threshold_entry.SetMin(0)
    #self.threshold_entry.SetMax(1.0)
    #szr.Add(self.threshold_entry, 0, wx.ALL, 5)
    #self.Bind(phil_controls.EVT_PHIL_CONTROL, self.OnSetThreshold,
    #  self.threshold_entry)

  def _load_result(self):
    self.chain_choice.SetItems(self._result.chain_ids)
    self._redraw()

  def OnSetThreshold(self, evt):
    self._redraw()

  def OnSetChain(self, evt):
    self._redraw()

  def _redraw(self):
    chain_id = self.chain_choice.GetStringSelection()
    #threshold = self.threshold_entry.GetPhilValue()
    self._result.draw_wx_plot(
      plot=self.plot_panel,
      chain_id=chain_id)
#      threshold=threshold)
    self.plot_panel.canvas.draw()


 *******************************************************************************


 *******************************************************************************
wxtbx/plots/molprobity.py

from __future__ import absolute_import, division, print_function
from mmtbx.validation import ramalyze
from mmtbx.validation import rotalyze
from mmtbx.validation import graphics
import mmtbx.validation.utils
from wxtbx import utils
import wxtbx.plots
import wx
from math import sqrt, floor
from six.moves import range

class rotarama_plot(wxtbx.plots.plot_container):
  hit_test_radius = 3.0
  hit_test_minimum_difference = 0.5
  def __init__(self, parent, figure_size=(8,8), xyz_shift=None):
    wxtbx.plots.plot_container.__init__(self,
      parent=parent,
      figure_size=figure_size,
      handle_left_click=True)
    self.xyz_shift = xyz_shift

  def show_plot(self, *args, **kwds):
    if self.disabled : return
    self.draw_plot(*args, **kwds)
    self.parent.Refresh()

  def process_mouse_click(self, mpl_event):
    (xdata, ydata) = (mpl_event.xdata, mpl_event.ydata)
    if xdata is None or ydata is None :
      return False
    min_dist = self.hit_test_radius
    closest_point = None
    for i, (x, y) in enumerate(self._points):
      dist = sqrt((xdata - x)**2 + (ydata - y)**2)
      if dist < min_dist :
        closest_point = i
        min_dist = dist
    if closest_point is not None :
      xyz = self._xyz[closest_point]
      if (self.xyz_shift is not None):
        xyz = (xyz[0] + self.xyz_shift[0],
               xyz[1] + self.xyz_shift[1],
               xyz[2] + self.xyz_shift[2])
      self.parent.zoom_callback(xyz=xyz)

class ramalyze_plot(rotarama_plot,
                     ramalyze.ramachandran_plot_mixin):
  def __init__(self, *args, **kwds):
    rotarama_plot.__init__(self, *args, **kwds)
    ramalyze.ramachandran_plot_mixin.__init__(self)

class rotalyze_plot(rotarama_plot, rotalyze.rotamer_plot_mixin):
  def __init__(self, *args, **kwds):
    rotarama_plot.__init__(self, *args, **kwds)
    rotalyze.rotamer_plot_mixin.__init__(self)

class rotarama_frame(wxtbx.plots.plot_frame):
  frame_name = "rotarama_frame"
  show_controls_default = True
  def __init__(self, parent, title, validation):
    self._validation = validation
    wxtbx.plots.plot_frame.__init__(self,
      parent=parent,
      title=title,
      style=wx.DEFAULT_FRAME_STYLE)
    self._map_cache = {}
    self._point_cache = {}
    self._xyz_cache = {}
    self.OnUpdatePlot(None)

  def OnDestroy(self, event):
    if hasattr(self.GetParent(), self.frame_name):
      setattr(self.GetParent(), self.frame_name, None)

  def OnUpdatePlot(self, event):
    pass

  def zoom_callback(self, **kwds):
    if getattr(self.GetParent(), "main_window", None) is not None :
      self.GetParent().main_window.show_gfx_selection(**kwds)

class ramalyze_frame(rotarama_frame):
  frame_name = "rama_frame"
  def draw_top_panel(self):
    self.top_panel = wx.Panel(self)
    szr = wx.BoxSizer(wx.VERTICAL)
    self.top_panel.SetSizer(szr)
    grid = wx.FlexGridSizer(cols=4)
    szr.Add(grid, 0, wx.ALL)
    grid.Add(utils.bold_text(self.top_panel, "Position type:"), 0,
      utils.std_sizer_flags, 5)
    pos_choice = wx.Choice(parent=self.top_panel,
      choices=ramalyze.res_type_labels)
    self.Bind(wx.EVT_CHOICE, self.OnUpdatePlot, pos_choice)
    pos_choice.SetSelection(ramalyze.RAMA_GENERAL)
    grid.Add(pos_choice, 0, utils.std_sizer_flags, 5)
    grid.Add(utils.bold_text(self.top_panel, "Residue name:"), 0,
      utils.std_sizer_flags, 5)
    aa = ['ALA', 'ARG', 'ASN', 'ASP', 'CYS', 'GLN', 'GLU', 'HIS', 'LEU',
          'LYS', 'MET', 'PHE', 'SER', 'THR', 'TRP', 'TYR',]
    res_choice = wx.Choice(parent=self.top_panel,
      choices=['*']+aa)
    res_choice.SetSelection(0)
    self.Bind(wx.EVT_CHOICE, self.OnUpdatePlot, res_choice)
    res_choice.Disable()
    grid.Add(res_choice, 0, utils.std_sizer_flags, 5)
    grid.Add(utils.bold_text(self.top_panel, "Show data points:"), 0,
      utils.std_sizer_flags, 5)
    default = ramalyze.RAMALYZE_ANY
    pt_choice = wx.Choice(parent=self.top_panel,
      choices=ramalyze.rama_type_labels)
    pt_choice.SetSelection(default)
    self.Bind(wx.EVT_CHOICE, self.OnUpdatePlot, pt_choice)
    grid.Add(pt_choice, 0, utils.std_sizer_flags, 5)
    grid.Add(utils.bold_text(self.top_panel, "Color scheme:"), 0,
      utils.std_sizer_flags, 5)
    cm_choice = wx.Choice(parent=self.top_panel,
      choices=wxtbx.plots.colormap_names)
    cm_choice.SetStringSelection("Blue")
    self.Bind(wx.EVT_CHOICE, self.OnUpdatePlot, cm_choice)
    grid.Add(cm_choice, 0, utils.std_sizer_flags, 5)
    self.choices = [pos_choice, res_choice, pt_choice, cm_choice]
    self.show_labels = wx.CheckBox(self.top_panel, label="Show labels")
    self.show_labels.SetValue(True)
    self.Bind(wx.EVT_CHECKBOX, self.OnUpdatePlot, self.show_labels)
    grid.Add(self.show_labels, 0, utils.std_sizer_flags, 5)

  def get_current_state(self):
    pos_type = self.choices[0].GetSelection()
    if (pos_type != ramalyze.RAMA_GENERAL):
      self.choices[1].SetSelection(0)
      self.choices[1].Disable()
    else :
      self.choices[1].Enable()
    res_type = self.choices[1].GetStringSelection()
    pt_type = self.choices[2].GetSelection()
    cm_name = self.choices[3].GetStringSelection()
    show_labels = self.show_labels.GetValue()
    return (pos_type, res_type, pt_type, cm_name, show_labels)

  def create_plot_panel(self):
    panel = ramalyze_plot(self)
    return panel

  def set_plot_type(self,
      pos_type,
      res_type="*",
      pt_type=ramalyze.RAMALYZE_ANY,
      cm_name='jet',
      show_labels=True):
    if not pos_type in self._map_cache :
      z_data = mmtbx.validation.utils.get_rotarama_data(
        pos_type=ramalyze.res_types[pos_type],
        convert_to_numpy_array=True)
      self._map_cache[pos_type] = z_data
    if not res_type in self._point_cache :
      pass
    title = ramalyze.format_ramachandran_plot_title(
      position_type=pos_type,
      residue_type=res_type)
    points = None
    coords = None
    if not (pos_type, res_type, pt_type) in self._point_cache :
      (points, coords) = self._validation.get_plot_data(
        position_type=pos_type,
        residue_name=res_type,
        point_type=pt_type)
      self._point_cache[(pos_type, res_type, pt_type)] = points
      self._xyz_cache[(pos_type, res_type, pt_type)] = coords
    else :
      points = self._point_cache[(pos_type, res_type, pt_type)]
      coords = self._xyz_cache[(pos_type, res_type, pt_type)]
    contours = ramalyze.get_contours(pos_type)
    self.plot_panel.show_plot(
      stats=self._map_cache[pos_type],
      title=title,
      points=points,
      show_labels=show_labels,
      colormap=wxtbx.plots.colormap_id_dict[cm_name],
      contours=contours,
      xyz=coords)

  def OnUpdatePlot(self, event):
    (pos_type,res_type,pt_type,cm_name,show_labels) = self.get_current_state()
    self.set_plot_type(pos_type, res_type, pt_type, cm_name, show_labels)

class rotalyze_frame(rotarama_frame):
  frame_name = "rota_frame"
  residues = ["Arg", "Asn", "Asp", "Gln", "Glu", "His", "Ile", "Leu", "Lys",
              "Met", "Phe", "Trp", "Tyr"]

  def draw_top_panel(self):
    self.top_panel = wx.Panel(self)
    szr = wx.BoxSizer(wx.VERTICAL)
    self.top_panel.SetSizer(szr)
    grid = wx.FlexGridSizer(cols=4)
    szr.Add(grid, 0, wx.ALL)
    grid.Add(utils.bold_text(self.top_panel, "Residue name:"), 0,
      utils.std_sizer_flags, 5)
    res_choice = wx.Choice(parent=self.top_panel, choices=self.residues)
    res_choice.SetSelection(0)
    self.Bind(wx.EVT_CHOICE, self.OnUpdatePlot, res_choice)
    grid.Add(res_choice, 0, utils.std_sizer_flags, 5)
    grid.Add(utils.bold_text(self.top_panel, "Show data points:"), 0,
      utils.std_sizer_flags, 5)
    pt_names = ["All", "None", "Outlier"]
    pt_choice = wx.Choice(self.top_panel, choices=pt_names)
    pt_choice.SetSelection(0)
    self.Bind(wx.EVT_CHOICE, self.OnUpdatePlot, pt_choice)
    grid.Add(pt_choice, 0, utils.std_sizer_flags, 5)
    grid.Add(utils.bold_text(self.top_panel, "Color scheme:"), 0,
      utils.std_sizer_flags, 5)
    cm_choice = wx.Choice(parent=self.top_panel,
      choices=wxtbx.plots.colormap_names)
    cm_choice.SetSelection(5)
    self.Bind(wx.EVT_CHOICE, self.OnUpdatePlot, cm_choice)
    grid.Add(cm_choice, 0, utils.std_sizer_flags, 5)
    self.choices = [res_choice, pt_choice, cm_choice]
    self.show_labels = wx.CheckBox(self.top_panel, label="Show labels")
    self.show_labels.SetValue(False)
    self.Bind(wx.EVT_CHECKBOX, self.OnUpdatePlot, self.show_labels)
    grid.Add(self.show_labels, 0, utils.std_sizer_flags, 5)

  def get_current_state(self):
    res_type = self.choices[0].GetStringSelection()
    pt_type = self.choices[1].GetStringSelection()
    cm_name = self.choices[2].GetStringSelection()
    show_labels = self.show_labels.GetValue()
    return (res_type, pt_type, cm_name, show_labels)

  def create_plot_panel(self):
    panel = rotalyze_plot(self)
    return panel

  def set_plot_type(self, res_type, pt_type="All", cm_name='jet',
      show_labels=False):
    if not res_type in self._map_cache :
      z_data = mmtbx.validation.utils.get_rotarama_data(
        residue_type=res_type,
        db="rota",
        convert_to_numpy_array=True)
      self._map_cache[res_type] = z_data
    title = "Chi1-Chi2 plot for %s" % res_type
    points = coords = None
    if (pt_type != "None"):
      if not (res_type, pt_type) in self._point_cache :
        (points, coords) = self._validation.get_plot_data(
          residue_name=res_type.upper(),
          point_type=pt_type)
        # shift chi2 values by 180 to fit in contours
        if (res_type.lower() in ["asp", "phe", "tyr"]):
          for i in range(len(points)):
            if (points[i][1] > 180.0):
              point = list(points[i])
              point[1] -= 180.0
              points[i] = tuple(point)
        self._point_cache[(res_type, pt_type)] = points
        self._xyz_cache[(res_type, pt_type)] = coords
      else :
        points = self._point_cache[(res_type, pt_type)]
        coords = self._xyz_cache[(res_type, pt_type)]
    extent = y_marks = None
    if (res_type.lower() in ["asp", "phe", "tyr"]):
      extent = [0, 360, 0, 180]
      y_marks = [90]
    self.plot_panel.show_plot(
      stats=self._map_cache[res_type],
      title=title,
      points=points,
      show_labels=show_labels,
      colormap=wxtbx.plots.colormap_id_dict[cm_name],
      contours=None,
      xyz=coords,
      extent=extent,
      y_marks=y_marks)

  def OnUpdatePlot(self, event):
    (res_type,pt_type,cm_name,show_labels) = self.get_current_state()
    self.set_plot_type(res_type, pt_type, cm_name, show_labels)

class multi_criterion_plot(wxtbx.plots.plot_container,
    graphics.multi_criterion_plot_mixin):
  def __init__(self, parent, binner, y_limits):
    self._reset = False
    graphics.multi_criterion_plot_mixin.__init__(self,
      binner=binner,
      y_limits=y_limits)
    wxtbx.plots.plot_container.__init__(self,
      parent=parent,
      figure_size=(16,9),
      handle_left_click=True)
    self.figure.subplots_adjust(hspace=0.001)
    self.canvas.mpl_connect('motion_notify_event', self.OnHover)

  def show_plot(self, *args, **kwds):
    if self.disabled : return
    self.draw_plot(*args, **kwds)
    self.parent.Refresh()

  def OnPickRange(self, event):
    bin = self.choose_range.GetSelection()
    self.plot_range(bin)

  def OnHover(self, mpl_event):
    (xdata, ydata) = (mpl_event.xdata, mpl_event.ydata)
    if xdata is None or ydata is None :
      if self._reset :
        self.parent.residue_status.SetValue("")
      self._reset = False
      return False
    idx = int(floor(xdata))
    try :
      residue = self._current_bin.get_selected(index=idx)
    except IndexError :
      pass
    else :
      if (residue is not None):
        self.parent.residue_status.SetValue(residue.id_str())
        self._reset = True

  def process_mouse_click(self, mpl_event):
    (xdata, ydata) = (mpl_event.xdata, mpl_event.ydata)
    if xdata is None or ydata is None :
      return False
    idx = int(floor(xdata))
    selection_string = None
    xyz = None
    try :
      residue = self._current_bin.get_selected(idx)
      if (residue is not None):
        selection_string = residue.id_str()
        xyz = residue.xyz
    except IndexError :
      pass
    else :
      if ( (selection_string is not None) and (xyz is not None) ):
        self.parent.zoom_callback(selection_string=selection_string,
                                  xyz=xyz)

class multi_criterion_frame(wxtbx.plots.plot_frame):
  show_controls_default = True
  def __init__(self, parent, title, validation):
    self._binner = validation.binned_data()
    self._y_limits = validation.get_y_limits()
    wxtbx.plots.plot_frame.__init__(self,
      parent=parent,
      title=title,
      style=wx.DEFAULT_FRAME_STYLE)
    self._map_cache = {}
    self._point_cache = {}
    self._xyz_cache = {}
    self.OnUpdatePlot(None)

  def create_plot_panel(self):
    panel = multi_criterion_plot(self,
      binner=self._binner,
      y_limits=self._y_limits)
    return panel

  def draw_top_panel(self):
    self.top_panel = wx.Panel(self)
    szr = wx.BoxSizer(wx.VERTICAL)
    self.top_panel.SetSizer(szr)
    grid = wx.FlexGridSizer(cols=4)
    szr.Add(grid, 0, wx.ALL)
    grid.Add(utils.bold_text(self.top_panel, "Show residues:"), 0,
      utils.std_sizer_flags, 5)
    self.range_choice = wx.Choice(parent=self.top_panel,
      choices=self._binner.get_ranges())
    self.range_choice.SetSelection(0)
    self.Bind(wx.EVT_CHOICE, self.OnUpdatePlot, self.range_choice)
    grid.Add(self.range_choice, 0, utils.std_sizer_flags, 5)
    grid.Add(utils.bold_text(self.top_panel, "Click to zoom residue:"), 0,
      utils.std_sizer_flags, 5)
    self.residue_status = wx.TextCtrl(self.top_panel, size=(160,-1),
      style=wx.TE_READONLY)
    grid.Add(self.residue_status, 0, utils.std_sizer_flags, 5)

  def OnUpdatePlot(self, event):
    bin = self.range_choice.GetSelection()
    self.plot_panel.plot_range(bin)

  def zoom_callback(self, **kwds):
    if getattr(self.GetParent(), "main_window", None) is not None :
      self.GetParent().main_window.show_gfx_selection(**kwds)


 *******************************************************************************


 *******************************************************************************
wxtbx/polygon.py
from __future__ import absolute_import, division, print_function

import wxtbx.polygon_db_viewer
import wxtbx.bitmaps
import wx.lib.colourselect
import wx
import mmtbx.polygon.output
from libtbx import adopt_init_args
from math import radians

class wx_renderer(mmtbx.polygon.output.renderer):
  def draw_bin(self, out, start, end, angle, color):
    gc = out
    path = gc.CreatePath()
    path.MoveToPoint(start[0], start[1])
    path.AddLineToPoint(end[0], end[1])
    path.CloseSubpath()
    gc.PushState()
    gc.SetPen(wx.Pen(color, 10))
    gc.StrokePath(path)
    gc.PopState()

  def draw_box(self, out, points, color):
    gc = out
    path = gc.CreatePath()
    path.MoveToPoint(points[0][0], points[0][1])
    path.AddLineToPoint(points[1][0], points[1][1])
    path.AddLineToPoint(points[2][0], points[2][1])
    path.AddLineToPoint(points[3][0], points[3][1])
    path.AddLineToPoint(points[0][0], points[0][1])
    path.CloseSubpath()
    gc.PushState()
    gc.SetPen(wx.Pen(color, 1)) #TRANSPARENT_PEN)
    gc.SetBrush(wx.Brush(color))
    gc.FillPath(path)
    gc.PopState()

  def draw_solid_line(self, out, start, end, color):
    gc = out
    line = gc.CreatePath()
    line.MoveToPoint(start[0], start[1])
    line.AddLineToPoint(end[0], end[1])
    line.CloseSubpath()
    gc.PushState()
    if self.color_model == "gray" :
      gc.SetPen(wx.Pen("red", 2))
    else :
      gc.SetPen(wx.Pen("black", 2))
    gc.StrokePath(line)
    gc.PopState()

  def draw_dashed_line(self, out, start, end, color):
    pass

  def draw_labels(self, out, label, min, max, value, pos, angle):
    gc = out
    label_font = wx.Font(14, wx.FONTFAMILY_DEFAULT, wx.NORMAL, wx.BOLD)
    stat_font = wx.Font(12, wx.MODERN, wx.NORMAL, wx.NORMAL)
    gc.PushState()
    gc.SetPen(wx.Pen("black", 1))
    gc.SetFont(gc.CreateFont(label_font, wx.BLACK))
    (text_w, text_h) = gc.GetTextExtent(label)
    (anchor_x, anchor_y) = pos
    (text_x, text_y) = self.get_text_position(text_w, text_h, anchor_x,
      anchor_y, angle)
    gc.DrawText(label, text_x, text_y)
    gc.PopState()
    gc.PushState()
    gc.SetFont(gc.CreateFont(stat_font, wx.RED))
    (text_w, text_h) = gc.GetTextExtent(min)
    text_y += text_h + 2
    gc.DrawText(min, text_x, text_y)
    gc.PopState()
    gc.PushState()
    gc.SetFont(gc.CreateFont(stat_font, wx.BLACK))
    (text_w, text_h) = gc.GetTextExtent(value)
    text_y += text_h + 2
    gc.DrawText(value, text_x, text_y)
    gc.PopState()
    gc.PushState()
    gc.SetFont(gc.CreateFont(stat_font, wx.RED))
    (text_w, text_h) = gc.GetTextExtent(max)
    text_y += text_h + 2
    gc.DrawText(max, text_x, text_y)
    gc.PopState()

  def get_text_position(self, w, h, x, y, angle):
    if angle >= radians(60) and angle < radians(120):
      text_x = x - (w/2) - 5
      text_y = y - h - 15
    elif angle >= radians(120) and angle < radians(240):
      text_x = x - w - 15
      text_y = y - (h/2)
    elif angle >= radians(240) and angle < radians(300):
      text_x = x - (w/2)
      text_y = y
    else : # 300 =< angle < 420
      text_x = x + 5
      text_y = y - (h/2)
    return (text_x, text_y)

class PolygonPanel(wx.Panel):
  def __init__(self, parent, renderer):
    wx.Panel.__init__(self, parent, -1)
    self.renderer = renderer
    self.renderer.resize((640, 640))
    self.SetMinSize((480,480))
    self.Bind(wx.EVT_PAINT, self.OnPaint)
    self.Bind(wx.EVT_SIZE, self.OnSize)

  def OnSize(self, event):
    self.renderer.resize(self.GetSize())
    self.Refresh()

  def OnPaint(self, event):
    self.renderer.resize(self.GetSize())
    dc = wx.PaintDC(self)
    gc = wx.GraphicsContext.Create(dc)
    self.renderer.draw(gc)

  def draw_color_key(self, dc):
    gc = wx.GraphicsContext.Create(dc)
    stat_font = wx.Font(12, wx.MODERN, wx.NORMAL, wx.NORMAL)
    x = 40
    y = self.h - 10
    i = 0
    for shade in bin_colors :
      gc.PushState()
      gc.SetPen(wx.Pen(shade, 10))
      path = gc.CreatePath()
      path.MoveToPoint(x, y)
      path.AddLineToPoint(x + 40, y)
      path.CloseSubpath()
      gc.StrokePath(path)
      gc.PopState()
      if i < len(self.cutoffs):
        gc.PushState()
        gc.SetFont(gc.CreateFont(stat_font, wx.BLACK))
        gc.DrawText(str(self.cutoffs[i]), x + 50, y - 6)
        gc.PopState()
      x += 80
      i += 1

  def OnChar(self, event):
    keycode = event.GetKeyCode()
    if keycode == 32 :
      self.OnSave()

  def OnSave(self, event=None):
    rect = self.GetRect()
    bitmap = wx.EmptyBitmap(rect.width, rect.height)
    memory_dc = wx.MemoryDC()
    memory_dc.SelectObject(bitmap)
    memory_dc.SetBackgroundMode(wx.TRANSPARENT)
    gc = wx.GraphicsContext.Create(memory_dc)
    self.renderer.draw(gc)
    output_file = wx.FileSelector("Save image as:",
      default_filename="polygon.png",
      wildcard="PNG image (*.png)|*.png", flags=wx.FD_SAVE)
    if output_file != "" :
      bitmap.SaveFile(output_file, wx.BITMAP_TYPE_PNG)
    if event is not None :
      event.Skip()

  def reset_layout(self):
    pass

class PolygonFrame(wx.Frame):
  def __init__(self, parent, histogram_data, structure_stats):
    wx.Frame.__init__(self, parent, -1, "POLYGON", size=(1024,720))
    self.SetMinSize((800,500))
    adopt_init_args(self, locals())
    # XXX The 'if' below fixes the case when arrays in histogram_data are too
    # XXX small or empty. In this the POLYGON picture will not be drawn and
    # XXX the pop up window will be just a blanc window.
    if histogram_data[0][1].size() > 3:
      self.renderer = wx_renderer(histogram_data, structure_stats,
        center=(0.5, 0.475))
      self.setup_toolbar()
      main_sizer = wx.BoxSizer(wx.HORIZONTAL)
      self.SetSizer(main_sizer)
      self.main_sizer = main_sizer
      self.info_sizer = wx.BoxSizer(wx.VERTICAL)
      self.main_sizer.Add(self.info_sizer, 0, wx.ALL|wx.EXPAND)
      self.draw_top_panel()
      self.label_panel = None
      self.draw_color_key()
      self.polygon_panel = PolygonPanel(self, self.renderer)
      main_sizer.Add(self.polygon_panel, 1, wx.ALL|wx.EXPAND)
      self.Bind(wx.EVT_CLOSE, self.OnClose)
      self.Bind(wx.EVT_WINDOW_DESTROY, self.OnDestroy)

  def setup_toolbar(self):
    self.toolbar = None
    save_icon = wxtbx.bitmaps.fetch_icon_bitmap("actions", "save_all")
    plot_icon = wxtbx.bitmaps.fetch_icon_bitmap("mimetypes", "spreadsheet")
    if (save_icon is not None) and (plot_icon is not None):
      self.toolbar = wx.ToolBar(self, style=wx.TB_TEXT)
      save_btn = self.toolbar.AddLabelTool(-1, "Save", save_icon,
        kind=wx.ITEM_NORMAL)
      self.Bind(wx.EVT_MENU, self.OnSave, save_btn)
      hist_btn = self.toolbar.AddLabelTool(-1, "Show histograms", plot_icon,
        kind=wx.ITEM_NORMAL)
      self.Bind(wx.EVT_MENU, self.OnDisplayHistogram, hist_btn)
      self.SetToolBar(self.toolbar)
      self.toolbar.Realize()

  def draw_top_panel(self):
    top_panel = wx.Panel(self, -1, style=wx.SIMPLE_BORDER)
    top_sizer = wx.BoxSizer(wx.VERTICAL)
    top_panel.SetSizer(top_sizer)
    caption = wx.StaticText(top_panel, -1,
"""This graph shows histograms of the distribution of selected statistics \
across %d PDB entries of similar resolution, with the range specified by \
numbers printed in red.  Statistics for the current structure are printed in \
black; the connecting polygon (in black) shows where these values fall in the \
distribution. A typical well-refined structure will have a small and roughly \
equilateral polygon.""" %
      self.renderer.n_pdb)
    caption.Wrap(320)
    top_sizer.Add(caption, 0, wx.ALL, 5)
    mode_sizer = wx.BoxSizer(wx.HORIZONTAL)
    top_sizer.Add(mode_sizer)
    caption1 = wx.StaticText(top_panel, -1, "Color scheme:")
    mode_sizer.Add(caption1, 0, wx.ALL|wx.ALIGN_CENTER_VERTICAL, 5)
    mode_choice = wx.Choice(top_panel, -1,
      choices=["Original (relative scaling)",
               "Rainbow (by bin size)",
               "Rainbow (relative scaling)",
               "Red to blue (by bin size)",
               "Red to blue (relative scaling)",
               "Red (by bin size)",
               "Blue (by bin size)",
               "Grayscale (by bin size)"])
    mode_choice.SetSelection(1)
    mode_sizer.Add(mode_choice, 0, wx.ALL|wx.ALIGN_CENTER_VERTICAL, 5)
    self.Bind(wx.EVT_CHOICE, self.OnRecolor, mode_choice)
    caption2 = wx.StaticText(top_panel, -1,
      "Citation: Urzhumtseva et al. Acta Cryst. 2009, D65:297-300.")
    caption2.Wrap(320)
    top_sizer.Add(caption2, 0, wx.ALL, 5)
    top_sizer.Fit(top_panel)
    self.info_sizer.Add(top_panel, 1, wx.ALL|wx.EXPAND)

  def draw_color_key(self):
    if self.label_panel is not None :
      self.main_sizer.Detach(self.label_panel)
      self.label_panel.Destroy()
    lower_panel = wx.Panel(self, -1, style=wx.SIMPLE_BORDER)
    lower_sizer = wx.BoxSizer(wx.VERTICAL)
    lower_panel.SetSizer(lower_sizer)
    if self.renderer.relative_scale_colors :
      caption = wx.StaticText(lower_panel, -1,
"""Histogram bins are colored based on the ratio of the number of structures \
in each bin to the average number per bin:""")
    else :
      caption = wx.StaticText(lower_panel, -1,
"""Histogram bins are colored by the number of structures in each bin.""")
    caption.Wrap(320)
    lower_sizer.Add(caption, 0, wx.ALL, 5)
    key_sizer = wx.BoxSizer(wx.HORIZONTAL)
    key_sizer = wx.FlexGridSizer(rows=0, cols=6, vgap=0, hgap=0)
    lower_sizer.Add(key_sizer)
    colors, cutoffs = self.renderer.get_color_key()
    for i, color in enumerate(colors):
      color_widget = ColorBox(lower_panel, -1, "", color, size=(24,24))
      key_sizer.Add(color_widget, 0, wx.ALL|wx.ALIGN_CENTER_VERTICAL, 5)
      if i < len(cutoffs):
        if self.renderer.relative_scale_colors :
          label = wx.StaticText(lower_panel, -1, "=< %s" % str(cutoffs[i]))
        else :
          label = wx.StaticText(lower_panel, -1, "= %s" % str(cutoffs[i]))
        key_sizer.Add(label, 0, wx.ALL|wx.ALIGN_CENTER_VERTICAL, 5)
    lower_sizer.Fit(lower_panel)
    self.info_sizer.Add(lower_panel, 1, wx.ALL|wx.EXPAND)
    self.info_sizer.Layout()
    self.Layout()
    self.label_panel = lower_panel

  def OnRecolor(self, event):
    mode = event.GetEventObject().GetSelection()
    mode_info = [ ("original", True),
                  ("rainbow", False),
                  ("rainbow", True),
                  ("rmb", False),
                  ("rmb", True),
                  ("red", False),
                  ("blue", False),
                  ("gray", False) ]
    (model_name, relative_scaling) = mode_info[mode]
    self.renderer.set_color_model(model_name, relative_scaling)
    self.draw_color_key()
    self.Refresh()

  def OnClose(self, event):
    wx.CallAfter(self.Destroy)

  def OnDestroy(self, event):
    if self.parent is not None and hasattr(self.parent, "polygon_frame"):
      self.parent.polygon_frame = None

  def OnSave(self, event):
    self.polygon_panel.OnSave()

  def OnResize(self, event):
    #self.panel.OnResize(event)
    self.polygon_panel.Layout()

  def OnDisplayHistogram(self, event):
    keys = [ key for key, data in self.histogram_data ]
    choice = None
    dlg = wx.SingleChoiceDialog(
      parent=self,
      message="Which statistic do you want to view as a histogram?",
      caption="Select a histogram to display",
      choices=keys)
    if (dlg.ShowModal() == wx.ID_OK):
      choice = dlg.GetSelection()
    wx.CallAfter(dlg.Destroy)
    if (choice is not None):
      frame = wxtbx.polygon_db_viewer.HistogramFrame(
        parent=self)
      frame.show_histogram(
        data=self.histogram_data[choice][1],
        n_bins=10,
        reference_value=self.structure_stats[keys[choice]],
        xlabel=mmtbx.polygon.output.stat_names[keys[choice]])
      frame.Show()

class ColorBox(wx.lib.colourselect.ColourSelect):
  def OnClick(self, event):
    pass

if (__name__ == "__main__"):
  app = wx.App(0)
  stats = {
    "r_work" : 0.25,
    "r_free" : 0.28,
    "adp_mean_all" : 20.0,
    "bond_rmsd" : 0.02,
    "angle_rmsd" : 1.8,
    "clashscore" : 20.0
  }
  data = mmtbx.polygon.output.get_basic_histogram_data(d_min=2.5)
  frame = PolygonFrame(
    parent=None,
    histogram_data=data,
    structure_stats=stats)
  frame.Show()
  app.MainLoop()


 *******************************************************************************


 *******************************************************************************
wxtbx/polygon_db_viewer.py
from __future__ import absolute_import, division, print_function

from wxtbx import plots
from mmtbx import polygon
from libtbx.utils import Sorry
from libtbx import group_args
import wx
from six.moves import zip

STD_FLAGS = wx.ALL

all_keys = polygon.keys_to_show + polygon.other_numerical_keys
all_captions = polygon.key_captions + polygon.other_captions

class ConfigFrame(wx.Frame):
  def __init__(self, *args, **kwds):
    wx.Frame.__init__(self, *args, **kwds)
    self.statusbar = self.CreateStatusBar()
    self.statusbar.SetStatusText("Reference: Urzhumtseva et al. (2009) "+
      "Acta Cryst. D65:297-300.")
    p = wx.Panel(self, -1)
    szr = wx.BoxSizer(wx.VERTICAL)
    self.SetSizer(szr)
    szr.Add(p, 1, wx.EXPAND)
    szr2 = wx.BoxSizer(wx.VERTICAL)
    p.SetSizer(szr2)
    box1 = wx.StaticBox(p, -1, "Plot correlation between statistics")
    bszr = wx.StaticBoxSizer(box1, wx.VERTICAL)
    szr2.Add(bszr, 0, STD_FLAGS, 5)
    grid = wx.FlexGridSizer(cols=5)
    bszr.Add(grid, 1, wx.EXPAND)
    grid.Add(wx.StaticText(p, -1, "X axis:"), 0, STD_FLAGS, 5)
    self.x_chooser = wx.Choice(p, -1, choices=all_captions)
    grid.Add(self.x_chooser, 0, STD_FLAGS|wx.EXPAND, 5)
    grid.Add((10,1))
    grid.Add(wx.StaticText(p, -1, "Y axis:"), 0, STD_FLAGS, 5)
    self.y_chooser = wx.Choice(p, -1, choices=all_captions)
    grid.Add(self.y_chooser, 0, STD_FLAGS|wx.EXPAND, 5)
    grid.Add(wx.StaticText(p, -1, "Limits:"), 0, STD_FLAGS, 5)
    inner_szr1 = wx.BoxSizer(wx.HORIZONTAL)
    grid.Add(inner_szr1, 0)
    self.x_min = wx.TextCtrl(p, -1, "", size=(80,-1))
    inner_szr1.Add(self.x_min, 0, STD_FLAGS, 5)
    inner_szr1.Add(wx.StaticText(p, -1, "to"), 0, STD_FLAGS, 5)
    self.x_max = wx.TextCtrl(p, -1, "", size=(80,-1))
    inner_szr1.Add(self.x_max, 0, STD_FLAGS, 5)
    grid.Add((10,1))
    grid.Add(wx.StaticText(p, -1, "Limits:"), 0, STD_FLAGS, 5)
    inner_szr2 = wx.BoxSizer(wx.HORIZONTAL)
    grid.Add(inner_szr2, 0)
    self.y_min = wx.TextCtrl(p, -1, "", size=(80,-1))
    inner_szr2.Add(self.y_min, 0, STD_FLAGS, 5)
    inner_szr2.Add(wx.StaticText(p, -1, "to"), 0, STD_FLAGS, 5)
    self.y_max = wx.TextCtrl(p, -1, "", size=(80,-1))
    inner_szr2.Add(self.y_max, 0, STD_FLAGS, 5)
    plot_btn = wx.Button(p, -1, "Show plot")
    self.Bind(wx.EVT_BUTTON, self.OnPlotCorr, plot_btn)
    bszr.Add(plot_btn, 0, wx.ALIGN_RIGHT|wx.ALL, 5)
    # histogram controls
    box2 = wx.StaticBox(p, -1, "Plot histogram")
    bszr2 = wx.StaticBoxSizer(box2, wx.VERTICAL)
    szr2.Add(bszr2, 0, STD_FLAGS|wx.EXPAND, 5)
    grid2 = wx.FlexGridSizer(cols=2)
    bszr2.Add(grid2, 1, wx.EXPAND)
    grid2.Add(wx.StaticText(p, -1, "Statistic:"), 0, STD_FLAGS, 5)
    self.h_chooser = wx.Choice(p, -1, choices=all_captions)
    grid2.Add(self.h_chooser, 0, STD_FLAGS|wx.EXPAND, 5)
    grid2.Add(wx.StaticText(p, -1, "Limits:"), 0, STD_FLAGS, 5)
    inner_szr4 = wx.BoxSizer(wx.HORIZONTAL)
    grid2.Add(inner_szr4)
    self.h_min = wx.TextCtrl(p, -1, "", size=(80,-1))
    inner_szr4.Add(self.h_min, 0, STD_FLAGS, 5)
    inner_szr4.Add(wx.StaticText(p, -1, "to"), 0, STD_FLAGS, 5)
    self.h_max = wx.TextCtrl(p, -1, "", size=(80, -1))
    inner_szr4.Add(self.h_max, 0, STD_FLAGS, 5)
    grid2.Add(wx.StaticText(p, -1, "Resolution range:"), 0, STD_FLAGS, 5)
    inner_szr2 = wx.BoxSizer(wx.HORIZONTAL)
    grid2.Add(inner_szr2)
    self.d_min = wx.TextCtrl(p, -1, "", size=(80,-1))
    inner_szr2.Add(self.d_min, 0, STD_FLAGS, 5)
    inner_szr2.Add(wx.StaticText(p, -1, "to"), 0, STD_FLAGS, 5)
    self.d_max = wx.TextCtrl(p, -1, "", size=(80,-1))
    inner_szr2.Add(self.d_max, 0, STD_FLAGS, 5)
    grid2.Add(wx.StaticText(p, -1, "Number of bins:"), 0, STD_FLAGS, 5)
    inner_szr3 = wx.BoxSizer(wx.HORIZONTAL)
    grid2.Add(inner_szr3, 0, STD_FLAGS, 5)
    self.n_bins = wx.TextCtrl(p, -1, "20", size=(80,-1))
    inner_szr3.Add(self.n_bins, 0, STD_FLAGS, 5)
    inner_szr3.Add(wx.StaticText(p, -1, "Reference value:"), 0, STD_FLAGS, 5)
    self.ref_value = wx.TextCtrl(p, -1, "", size=(80,-1))
    inner_szr3.Add(self.ref_value, 0, STD_FLAGS, 5)
    hist_btn = wx.Button(p, -1, "Show histogram")
    self.Bind(wx.EVT_BUTTON, self.OnPlotHist, hist_btn)
    bszr2.Add(hist_btn, 0, wx.ALIGN_RIGHT|wx.ALL, 5)
    szr2.Layout()
    szr.Fit(p)
    self.Fit()
    self.Bind(wx.EVT_CLOSE, self.OnClose, self)
    self.Bind(wx.EVT_WINDOW_DESTROY, self.OnDestroy, self)
    self._db = None

  def get_db(self):
    if (self._db is None):
      self._db = polygon.load_db()
    return self._db

  def OnPlotCorr(self, evt):
    x_key = all_keys[self.x_chooser.GetSelection()]
    y_key = all_keys[self.y_chooser.GetSelection()]
    if (x_key == y_key):
      raise Sorry("X and Y selections are the same statistic!")
    db = self.get_db()
    x_stats = db[x_key]
    y_stats = db[y_key]
    limits = group_args(x_min=None, x_max=None, y_min=None, y_max=None)
    for lim in ["x_min", "x_max", "y_min", "y_max"] :
      lim_txt = getattr(self, lim).GetValue()
      if (lim_txt != ""):
        try :
          lim_val = float(lim_txt)
        except ValueError :
          raise Sorry("Invalid value for limit - must be a decimal number.")
        else :
          setattr(limits, lim, lim_val)
    x_values = []
    y_values = []
    for x_, y_ in zip(x_stats, y_stats):
      try :
        x = float(x_)
        y = float(y_)
      except ValueError : pass
      else :
        if   (limits.x_min is not None) and (x < limits.x_min) : continue
        elif (limits.x_max is not None) and (x > limits.x_max) : continue
        elif (limits.y_min is not None) and (y < limits.y_min) : continue
        elif (limits.y_max is not None) and (y > limits.y_max) : continue
        else :
          x_values.append(x)
          y_values.append(y)
    assert (len(x_values) == len(y_values))
    if (len(x_values) == 0):
      raise Sorry("No points within specified limits.")
    plt = CorrPlotFrame(self)
    plt.set_plot(x_values, y_values, self.x_chooser.GetStringSelection(),
      self.y_chooser.GetStringSelection())
    plt.Show()

  def OnPlotHist(self, evt):
    h_key = all_keys[self.h_chooser.GetSelection()]
    db = self.get_db()
    h_values = db[h_key]
    limits = group_args(d_min=None, d_max=None, h_min=None, h_max=None)
    for lim in ["d_min", "d_max", "h_min", "h_max"] :
      lim_txt = getattr(self, lim).GetValue()
      if (lim_txt != ""):
        try :
          lim_val = float(lim_txt)
        except ValueError :
          raise Sorry("Invalid resolution '%s' - must be a decimal number." %
            lim_txt)
        else :
          setattr(limits, lim, lim_val)
    reference_value = None
    reference_value_txt = self.ref_value.GetValue()
    if (reference_value_txt != ""):
      try :
        reference_value = float(reference_value_txt)
      except ValueError :
        raise Sorry("Invalid reference value '%s' - must be a decimal number."%
          reference_value_txt)
    try :
      n_bins = int(float(self.n_bins.GetValue()))
    except ValueError :
      raise Sorry("Number of bins must be a decimal number.")
    if n_bins < 1:
      raise Sorry("Number of bins must be a decimal number 1 or greater")

    data = []
    print(limits.h_min, limits.h_max)
    for (d_, v_) in zip(db['high_resolution'], db[h_key]):
      try :
        d_min = float(d_)
        value = float(v_)
      except ValueError : pass
      else :
        if   (limits.d_min is not None) and (d_min < limits.d_min) : continue
        elif (limits.d_max is not None) and (d_min > limits.d_max) : continue
        elif (limits.h_min is not None) and (value < limits.h_min) : continue
        elif (limits.h_max is not None) and (value > limits.h_max) : continue
        else :
          data.append(value)
    if (len(data) == 0):
      raise Sorry("No points within specified limits.")
    plt = HistogramFrame(self)
    plt.show_histogram(
      data=data,
      n_bins=n_bins,
      reference_value=reference_value,
      xlabel=self.h_chooser.GetStringSelection())
    plt.Show()

  def OnShowTable(self, evt):
    pass

  def OnClose(self, evt):
    self.Destroy()

  def OnDestroy(self, evt):
    try:
      parent = self.GetParent()
      if (parent is not None):
        parent.plot_frame = None
    except Exception as e: # parent was already deleted
      pass

class CorrPlot(plots.plot_container):
  def set_plot(self, x, y, x_label, y_label):
    from scitbx.array_family import flex
    self.figure.clear()
    ax = self.figure.add_subplot(111)
    ax.plot(x, y, '.')
    ax.set_xlabel(x_label)
    ax.set_ylabel(y_label)
    ax.grid(True, color="0.5")
    c = flex.linear_correlation(flex.double(x), flex.double(y))
    cc = c.coefficient()
    ax.set_title("%s vs. %s (%d structures, CC = %.3f)" % (x_label, y_label,
      len(x), cc))
    self.canvas.draw()
    #self.parent.statusbar.SetStatusText("Correlation coefficient (CC): %.3f" %
    #  cc)
    self.parent.Refresh()

class CorrPlotFrame(plots.plot_frame):
  show_controls_default = False
  def create_plot_panel(self):
    self.statusbar = self.CreateStatusBar()
    return CorrPlot(self, figure_size=(12,8))

  def set_plot(self, *args, **kwds):
    self.plot_panel.set_plot(*args, **kwds)

class HistogramPlot(plots.histogram):
  def show_histogram(self, data, n_bins, reference_value, xlabel):
    from scitbx.array_family import flex
    mean = flex.mean(flex.double(data))
    if not n_bins:
      raise Sorry("Number of bins must be greater than zero for histograms")
    p = plots.histogram.show_histogram(self,
      data=data,
      n_bins=int(n_bins),
      reference_value=reference_value,
      draw_now=False)
    p.axvline(mean, color='g', linewidth=2)
    p.set_ylabel("Number of structures")
    p.set_xlabel(xlabel)
    if (reference_value is not None):
      labels = ["Reference value", "Mean (%.3f)" % mean]
    else :
      labels = ["Mean (%.3f)" % mean]
    p.set_title("Distribution of %s (%d structures)" % (xlabel, len(data)))
    self.figure.legend(p.lines, labels)
    self.canvas.draw()
    self.parent.Refresh()

class HistogramFrame(plots.plot_frame):
  show_controls_default = False
  def create_plot_panel(self):
    self.statusbar = self.CreateStatusBar()
    return HistogramPlot(self, figure_size=(12,8))

  def show_histogram(self, *args, **kwds):
    self.plot_panel.show_histogram(*args, **kwds)


 *******************************************************************************


 *******************************************************************************
wxtbx/process_control.py

# TODO more comprehensive tests

from __future__ import absolute_import, division, print_function
from wx.lib.agw import pyprogress
import wx
from libtbx import thread_utils
from libtbx import runtime_utils
from libtbx import easy_pickle
from libtbx import easy_run
from libtbx.utils import Sorry, Abort, download_progress
import threading
import random
import locale
import math
import os
from six.moves import range

JOB_START_ID = wx.NewId()
LOG_UPDATE_ID = wx.NewId()
CALLBACK_ID = wx.NewId()
JOB_EXCEPTION_ID = wx.NewId()
JOB_KILLED_ID = wx.NewId()
JOB_COMPLETE_ID = wx.NewId()
JOB_PAUSE_ID = wx.NewId()
JOB_RESUME_ID = wx.NewId()
DOWNLOAD_COMPLETE_ID = wx.NewId()
DOWNLOAD_INCREMENT_ID = wx.NewId()

class SubprocessEvent(wx.PyEvent):
  event_id = None

  def __init__(self, data, **kwds):
    super(SubprocessEvent, self).__init__()
    self.data = data
    if hasattr(self, '_getAttrDict'):
      self._getAttrDict().update(kwds)
    else:
      self.__dict__.update(kwds)
    self.SetEventType(self.event_id)

class JobStartEvent(SubprocessEvent):
  event_id = JOB_START_ID

  def __init__(self, data, **kwds):
    super(JobStartEvent, self).__init__(data, **kwds)

class LogEvent(SubprocessEvent):
  event_id = LOG_UPDATE_ID

  def __init__(self, data, **kwds):
    super(LogEvent, self).__init__(data, **kwds)


class JobExceptionEvent(SubprocessEvent):
  event_id = JOB_EXCEPTION_ID

  def __init__(self, data, **kwds):
    super(JobExceptionEvent, self).__init__(data, **kwds)

class JobKilledEvent(SubprocessEvent):
  event_id = JOB_KILLED_ID

  def __init__(self, data, **kwds):
    super(JobKilledEvent, self).__init__(data, **kwds)

class JobCompleteEvent(SubprocessEvent):
  event_id = JOB_COMPLETE_ID

  def __init__(self, data, **kwds):
    super(JobCompleteEvent, self).__init__(data, **kwds)

class CallbackEvent(SubprocessEvent):
  event_id = CALLBACK_ID

  def __init__(self, data, **kwds):
    super(CallbackEvent, self).__init__(data, **kwds)

class JobPauseEvent(SubprocessEvent):
  event_id = JOB_PAUSE_ID

  def __init__(self, data, **kwds):
    super(JobPauseEvent, self).__init__(data, **kwds)

class JobResumeEvent(SubprocessEvent):
  event_id = JOB_RESUME_ID

  def __init__(self, data, **kwds):
    super(JobResumeEvent, self).__init__(data, **kwds)

class DownloadCompleteEvent(SubprocessEvent):
  event_id = DOWNLOAD_COMPLETE_ID

  def __init__(self, data, **kwds):
    super(DownloadCompleteEvent, self).__init__(data, **kwds)

class DownloadIncrementEvent(SubprocessEvent):
  event_id = DOWNLOAD_INCREMENT_ID

  def __init__(self, data, **kwds):
    super(DownloadIncrementEvent, self).__init__(data, **kwds)

def setup_stdout_logging_event(window, OnPrint):
  window.Connect(-1, -1, LOG_UPDATE_ID, OnPrint)

def setup_process_gui_events(
    window,
    OnStart=None,
    OnPrint=None,
    OnUpdate=None,
    OnExcept=None,
    OnAbort=None,
    OnComplete=None,
    OnPause=None,
    OnResume=None):
  if OnStart is not None :
    assert hasattr(OnStart, "__call__")
    window.Connect(-1, -1, JOB_START_ID, OnStart)
  if OnPrint is not None :
    assert hasattr(OnPrint, "__call__")
    window.Connect(-1, -1, LOG_UPDATE_ID, OnPrint)
  if OnUpdate is not None :
    assert hasattr(OnUpdate, "__call__")
    window.Connect(-1, -1, CALLBACK_ID, OnUpdate)
  if OnExcept is not None :
    assert hasattr(OnExcept, "__call__")
    window.Connect(-1, -1, JOB_EXCEPTION_ID, OnExcept)
  if OnAbort is not None :
    assert hasattr(OnAbort, "__call__")
    window.Connect(-1, -1, JOB_KILLED_ID, OnAbort)
  if OnComplete is not None :
    assert hasattr(OnComplete, "__call__")
    window.Connect(-1, -1, JOB_COMPLETE_ID, OnComplete)
  if OnPause is not None :
    assert hasattr(OnPause, "__call__")
    window.Connect(-1, -1, JOB_PAUSE_ID, OnPause)
  if OnResume is not None :
    assert hasattr(OnResume, "__call__")
    window.Connect(-1, -1, JOB_RESUME_ID, OnResume)

class event_agent(object):
  def __init__(self, window, **kwds):
    self.window = window
    self._kwds = dict(kwds)
    self.__dict__.update(kwds)

  def get_kwds(self):
    return self._kwds

  def callback_start(self, data):
    kwds = self.get_kwds()
    event = JobStartEvent(data, **kwds)
    wx.PostEvent(self.window, event)

  def callback_stdout(self, data):
    kwds = self.get_kwds()
    event = LogEvent(data, **kwds)
    wx.PostEvent(self.window, event)

  def callback_error(self, error, traceback_info):
    kwds = self.get_kwds()
    event = JobExceptionEvent((error, traceback_info), **kwds)
    wx.PostEvent(self.window, event)

  def callback_abort(self):
    kwds = self.get_kwds()
    event = JobKilledEvent(None, **kwds)
    wx.PostEvent(self.window, event)

  def callback_final(self, result):
    kwds = self.get_kwds()
    event = JobCompleteEvent(result, **kwds)
    wx.PostEvent(self.window, event)

  def callback_other(self, data):
    kwds = self.get_kwds()
    event = CallbackEvent(data, **kwds)
    wx.PostEvent(self.window, event)

  def callback_pause(self):
    kwds = self.get_kwds()
    event = JobPauseEvent(None, **kwds)
    wx.PostEvent(self.window, event)

  def callback_resume(self):
    kwds = self.get_kwds()
    event = JobResumeEvent(None, **kwds)
    wx.PostEvent(self.window, event)

# simplified for when the window is really the app object
class background_event_agent(event_agent):
  def callback_stdout(self, data):
    pass

  def callback_other(self, data):
    pass

class detached_process(runtime_utils.detached_process_client):
  def __init__(self, params, proxy):
    runtime_utils.detached_process_client.__init__(self, params)
    self.proxy = proxy

  def callback_start(self, data):
    self.proxy.callback_start(data)

  def callback_stdout(self, data):
    self.proxy.callback_stdout(data)

  def callback_other(self, data):
    self.proxy.callback_other(data)

  def callback_abort(self):
    self.proxy.callback_abort()

  def callback_final(self, result):
    self.proxy.callback_final(result)

  def callback_error(self, error, traceback_info):
    self.proxy.callback_error(error, traceback_info)

  def callback_pause(self):
    self.proxy.callback_pause()

  def callback_resume(self):
    self.proxy.callback_resume()

  def start(self):
    pass

# this just adds event posting callbacks to the original class
class process_with_gui_callbacks(thread_utils.process_with_callbacks):
  def __init__(self, proxy, target, args=(), kwargs={}, buffer_stdout=True):
    thread_utils.process_with_callbacks.__init__(self,
      target = target,
      args=args,
      kwargs=kwargs,
      callback_stdout = proxy.callback_stdout,
      callback_final  = proxy.callback_final,
      callback_err    = proxy.callback_error,
      callback_abort  = proxy.callback_abort,
      callback_other  = proxy.callback_other,
      callback_pause  = proxy.callback_pause,
      callback_resume = proxy.callback_resume,
      buffer_stdout   = buffer_stdout)

  def set_job(self, job):
    pass

  def purge_files(self):
    pass

class simple_gui_process(process_with_gui_callbacks):
  def __init__(self, window, target, args=(), kwargs={}):
    # XXX fix for phenix gui - is this necessary?
    proxy = event_agent(window, project_id=None, job_id=None)
    process_with_gui_callbacks.__init__(self,
      proxy=proxy,
      target=target,
      args=args,
      kwargs=kwargs,
      buffer_stdout=True)

class ThreadProgressDialog(pyprogress.PyProgress):
  def __init__(self, parent, title, message):
    pyprogress.PyProgress.__init__(self, parent, -1, title, message,
      agwStyle=wx.PD_ELAPSED_TIME|wx.PD_APP_MODAL)
    self.SetGaugeProportion(0.15)
    self.SetGaugeSteps(50)
    self.SetGaugeBackground(wx.Colour(235, 235, 235))
    self.SetFirstGradientColour(wx.Colour(235,235,235))
    self.SetSecondGradientColour(wx.Colour(120, 200, 255))

class download_file_basic(object):
  def __init__(self, window, dl_func, args):
    assert isinstance(window, wx.EvtHandler)
    assert hasattr(dl_func, "__call__")
    assert (isinstance(args, list) or isinstance(args, tuple))
    self.window = window
    window.Connect(-1, -1, DOWNLOAD_COMPLETE_ID, self.OnComplete)
    self.dl_func = dl_func
    self.args = args
    self.t = threading.Thread(target=self.run)
    self.t.start()

  def run(self):
    try :
      result = self.dl_func(self.args)
    except Exception as e :
      result = (None, str(e))
    finally :
      wx.PostEvent(self.window, DownloadCompleteEvent(result))
    return result

  def OnComplete(self, event):
    from six import string_types
    if isinstance(event.data, string_types):
      wx.MessageBox(message="File downloaded to %s" % event.data)
    else :
      wx.MessageBox(message="Error downloading file: %s" % event.data[1],
        caption="Download error", style=wx.ICON_ERROR)
    self.t.join()

class DownloadProgressDialog(wx.ProgressDialog, download_progress):
  """
  Dialog for displaying download progress.  The actual download (not
  implemented here) should be run in a separate thread, with a reasonable
  chunk size, and call download_progress.increment() as each new chunk is
  downloaded.
  """
  def __init__(self, parent, title, message):
    download_progress.__init__(self)
    wx.ProgressDialog.__init__(self, parent=parent,
      title=title,
      message=message,
      style=wx.PD_ELAPSED_TIME|wx.PD_CAN_ABORT|wx.PD_AUTO_HIDE,
      maximum=100)
    self.Connect(-1, -1, DOWNLOAD_INCREMENT_ID, self.OnIncrement)
    self.Connect(-1, -1, DOWNLOAD_COMPLETE_ID, self.OnComplete)
    self._continue = True

  def show_progress(self):
    if (not self._continue):
      return False
    locale.setlocale(locale.LC_ALL, 'en_US')
    pct = self.percent_finished()
    msg = "%s/%s KB downloaded" % (
      locale.format("%d", self.n_kb_elapsed, grouping=True),
      locale.format("%d", self.n_kb_total, grouping=True))
    evt = DownloadIncrementEvent(data=(pct, msg))
    wx.PostEvent(self, evt)
    return self._continue

  def OnIncrement(self, event):
    (cont, skip) = self.Update(value=event.data[0], newmsg=event.data[1])
    self._continue = cont

  def OnComplete(self, event):
    self.Hide()
    self.Close()
    # FIXME destroying the dialog crashes wxPython 2.9.5/osx-coocoa

  def complete(self):
    evt = DownloadCompleteEvent(data=None)
    wx.PostEvent(self, evt)

class BackgroundDownloadDialog(pyprogress.PyProgress, download_progress):
  """
  Placeholder for downloads which block the child thread; will pulse
  continuously but not show changing status.
  """
  def __init__(self, parent, title, message):
    download_progress.__init__(self)
    pyprogress.PyProgress.__init__(self, parent, -1, title, message,
      agwStyle=wx.PD_ELAPSED_TIME|wx.PD_CAN_ABORT|wx.PD_AUTO_HIDE)
    self.SetGaugeProportion(0.15)
    self.SetGaugeSteps(100)
    self.SetGaugeBackground(wx.Colour(235, 235, 235))
    self.SetFirstGradientColour(wx.Colour(235,235,235))
    self.SetSecondGradientColour(wx.Colour(120, 200, 255))
    self.Connect(-1, -1, DOWNLOAD_COMPLETE_ID, self.OnComplete)
    self._continue = True

  def show_progress(self):
    if (not self._continue):
      return False
    return self._continue

  def OnComplete(self, event):
    self.Hide()
    self.Close()

  def complete(self):
    evt = DownloadCompleteEvent(data=None)
    wx.PostEvent(self, evt)

def run_function_as_thread_in_dialog(parent, thread_function, title, message):
  dlg = ThreadProgressDialog(None, title, message)
  t = thread_utils.simple_task_thread(thread_function, dlg)
  t.start()
  while True :
    if t.is_complete() or t.exception_raised():
      #dlg.Destroy()
      dlg.Hide()
      break
    else :
      dlg.UpdatePulse()
    wx.MilliSleep(30)
  dlg.Destroy()
  wx.SafeYield()
  if t.exception_raised():
    raise RuntimeError("An exception occurred while running this process: %s" %
      t.get_error())
  return t.return_value

# TODO
class ProcessDialog(wx.Dialog):
  def __init__(self, parent, message, caption, callback=None):
    wx.Dialog.__init__(self,
      parent=parent,
      title=caption,
      style=wx.RAISED_BORDER|wx.CAPTION)
    self.callback = callback
    self.process = None
    self._error = None
    self._aborted = False
    szr = wx.BoxSizer(wx.VERTICAL)
    self.SetSizer(szr)
    szr2 = wx.BoxSizer(wx.VERTICAL)
    szr.Add(szr2, 1, wx.ALL, 5)
    msg_txt = wx.StaticText(self, -1, message)
    msg_txt.Wrap(400)
    szr2.Add(msg_txt, 0, wx.ALIGN_CENTER_HORIZONTAL|wx.ALL, 5)
    self.gauge = wx.Gauge(parent=self, size=(300,-1))
    self.gauge.SetRange(100)

    # XXX  TEMPORARY PYTHON 3 FIX TT
    #szr2.Add(self.gauge, 1, wx.ALL|wx.EXPAND|wx.ALIGN_CENTER_HORIZONTAL, 5)
    szr2.Add(self.gauge, 1, wx.ALL, 5)
    abort_btn = wx.Button(parent=self,
      label="Abort")
    self.Bind(wx.EVT_BUTTON, self.OnAbort, abort_btn)
    # XXX  TEMPORARY PYTHON 3 FIX TT
    #szr2.Add(abort_btn, 0, wx.ALL|wx.ALIGN_CENTER_HORIZONTAL, 5)
    szr2.Add(abort_btn, 0, wx.ALL, 5)
    self.SetMinSize((300,100))
    szr.Fit(self)
    self.Centre(wx.BOTH)

  def run(self, process):
    self.process = process
    self._timer = wx.Timer(owner=self)
    self.Bind(wx.EVT_TIMER, self.OnTimer)
    self._timer.Start(100)
    self.process.start()
    self.gauge.Pulse()
    return self.ShowModal()

  def OnTimer(self, event):
    if hasattr(self.process,'update'):
      self.process.update()
    self.gauge.Pulse()

  def OnAbort(self, event):
    self.process.abort()
    self._aborted = True
    self._timer.Stop()
    try:
      self.EndModal(wx.ID_CANCEL)
    except Exception as e:
      pass # C++ was deleted

  def OnError(self, event):
    self._error = event.data
    self._timer.Stop()
    try:
      self.EndModal(wx.ID_CANCEL)
    except Exception as e:
      pass # C++ was deleted

  def exception_raised(self):
    return (self._error is not None)

  def was_aborted(self):
    return (self._aborted)

  def handle_error(self):
    if isinstance(self._error, Exception):
      raise event.data
    elif isinstance(self._error, tuple):
      exception, traceback = self._error
      if (isinstance(exception, Sorry)):
        raise Sorry(str(exception))
      raise RuntimeError("""\
Error in subprocess!
 Original error: %s
 Original traceback:
%s""" % (str(exception), traceback))
    else :
      raise Sorry("error in child process: %s" % str(self._error))
   # finally :
   #   self.EndModal(wx.ID_CANCEL)

  def OnComplete(self, event):
    try :
      if (self.callback is not None):
        self.callback(event.data)
    finally :
      self._result = event.data
      self._timer.Stop()
      self.EndModal(wx.ID_OK)

  def get_result(self):
    return getattr(self, "_result", None)

def run_function_as_process_in_dialog(
    parent,
    thread_function,
    title,
    message,
    callback=None,
    project_id=None,
    job_id=None):
  dlg = ProcessDialog(
    parent=parent,
    message=message,
    caption=title,
    callback=callback)
  setup_process_gui_events(
    window=dlg,
    OnExcept=dlg.OnError,
    OnComplete=dlg.OnComplete)
  cb = event_agent(dlg, project_id=project_id, job_id=job_id)
  p = thread_utils.process_with_callbacks(
    target=thread_function,
    callback_final=cb.callback_final,
    callback_err=cb.callback_error,
    buffer_stdout=True,
    sleep_after_start=1)
  result = None
  abort = False
  if (dlg.run(p) == wx.ID_OK):
    result = dlg.get_result()
  elif dlg.exception_raised():
    dlg.handle_error()
  elif (dlg.was_aborted()):
    abort = True
  wx.CallAfter(dlg.Destroy)
  if (abort):
    raise Abort()
  return result

# TODO this is awful, needs to be re-thought
def run_function_as_detached_process_in_dialog(
    parent,
    thread_function,
    title,
    message,
    tmp_dir,
    callback=None,
    project_id=None,
    job_id=None):
  if (tmp_dir is None):
    tmp_dir = os.getcwd()
  params = runtime_utils.process_master_phil.extract()
  params.tmp_dir = tmp_dir
  if (job_id is None):
    job_id = str(os.getpid()) + "_" + str(int(random.random() * 1000))
  params.prefix = str(job_id)
  target = runtime_utils.detached_process_driver(target=thread_function)
  run_file = os.path.join(tmp_dir, "libtbx_run_%s.pkl" % job_id)
  easy_pickle.dump(run_file, target)
  params.run_file = run_file
  eff_file = os.path.join(tmp_dir, "libtbx_run_%s.eff" % job_id)
  runtime_utils.write_params(params, eff_file)
  dlg = ProcessDialog(
    parent=parent,
    message=message,
    caption=title,
    callback=callback)
  setup_process_gui_events(
    window=dlg,
    OnExcept=dlg.OnError,
    OnAbort=dlg.OnAbort,
    OnComplete=dlg.OnComplete)
  agent = event_agent(
    window=dlg,
    project_id=project_id,
    job_id=job_id)
  process = detached_process(params, proxy=agent)
  cb = event_agent(dlg, project_id=project_id, job_id=job_id)
  easy_run.call("libtbx.start_process \"%s\" &" % eff_file)
  result = None
  abort = False
  if (dlg.run(process) == wx.ID_OK):
    result = dlg.get_result()
  elif dlg.exception_raised():
    dlg.handle_error()
  elif (dlg.was_aborted()):
    abort = True
  wx.CallAfter(dlg.Destroy)
  if (abort):
    raise Abort()
  return result

########################################################################
# XXX regression testing utilities
def test_function_1(*args, **kwds):
  n = 0
  for i in range(25000):
    x = math.sqrt(i)
    print(x)
    n += x
  return n
def test_function_2(*args, **kwds):
  n = 0
  for i in range(100000):
    x = math.sqrt(i)
    n += x
  return n
def test_function_3(*args, **kwds):
  raise RuntimeError("This is a test!")


 *******************************************************************************


 *******************************************************************************
wxtbx/qstat_view.py
from __future__ import absolute_import, division, print_function

import wxtbx.bitmaps
from libtbx.queuing_system_utils import sge_utils
from libtbx.utils import Sorry
import wx
try :
  from wx.lib.agw.genericmessagedialog import GenericMessageDialog
except ImportError :
  GenericMessageDialog = wx.MessageBox

import sys, time

import getpass
user = getpass.getuser()

job_attrs = ["job_id", "state", "name", "user", "submit", "queue"]
job_labels = ["Job ID", "Status", "Name", "User", "Start time", "Queue"]
status_codes = ["d", "E", "h", "r", "R", "s", "S", "t", "T", "w"]
status_imgs = [3, 4, 0, 1, 0, 0, 0, 0, 0, 2]
col_sizes = [wx.LIST_AUTOSIZE] * 4 + [200,200]

class qsub_list_data(object):
  def __init__(self):
    self._data = []
    self._sortby = None
    self._sort_descending = False

  def Refresh(self):
    self._data = sge_utils.qstat_parse()
    if self._sortby is not None :
      self.SortItems(self._sortby, swap_order=False)

  def GetItemCount(self):
    return len(self._data)

  def GetItemText(self, item, col):
    return getattr(self._data[item], job_attrs[col])

  def GetItemImage(self, item):
    status = self._data[item].state[-1]
    img_id = status_imgs[status_codes.index(status)]
    return img_id

  def SortItems(self, col, swap_order=True):
    if swap_order :
      if self._sortby == col :
        self._sort_descending = (not self._sort_descending)
      else :
        self._sort_descending = False
    if col == 0 :
      self._data.sort(key=lambda element: int(element.job_id))
    elif col == 4 :
      fmt = "%m/%d/%Y %H:%M:%S"
      self._data.sort(key=lambda element: time.strptime(element.submit, fmt))
    else :
      attr = job_attrs[col]
      self._data.sort(key=lambda element: getattr(element, attr))
    if self._sort_descending :
      self._data.reverse()
    self._sortby = col

  def GetOwners(self, job_ids, as_list=False):
    names = []
    for job in self._data :
      if job.job_id in job_ids :
        names.append(job.user)
    if as_list :
      return names
    return list(set(names))

  def GetNames(self, job_ids):
    names = []
    for job in self._data :
      if job.job_id in job_ids :
        names.append(job.name)
    return names

class qsub_list_view(wx.ListCtrl):
  def __init__(self, *args, **kwds):
    wx.ListCtrl.__init__(self, *args, **kwds)
    self.SetupImages()
    self.Bind(wx.EVT_LIST_ITEM_SELECTED, self.OnSelect, self)
    self.Bind(wx.EVT_LIST_ITEM_DESELECTED, self.OnDeSelect, self)
    self.Bind(wx.EVT_LEFT_DCLICK, self.OnDoubleClick, self)
    self.Bind(wx.EVT_RIGHT_DOWN, self.OnRightClick, self)
    self.Bind(wx.EVT_LIST_COL_CLICK, self.OnSort, self)
    for i, label in enumerate(job_labels):
      self.InsertColumn(i, label)
      self.SetColumnWidth(i, col_sizes[i]) #wx.LIST_AUTOSIZE)
    self.dataSource = qsub_list_data()
    self.RefreshAllItems()

  def SetupImages(self):
    if wxtbx.bitmaps.icon_lib is None :
      return
    il = wx.ImageList(16, 16, True)
    #il.Add(wx.EmptyBitmap(16,16)) #EmptyImage(16,16).ConvertToBitmap())
    for icon in ["blank", "run", "recur", "stop", "status_unknown"] :
      bmp = wxtbx.bitmaps.fetch_icon_bitmap("actions", icon, 16)
      il.Add(bmp)
    self.AssignImageList(il, wx.IMAGE_LIST_SMALL)

  def OnGetItemImage(self, item):
    return self.dataSource.GetItemImage(item)

  def OnGetItemAttr(self, item):
    pass

  def OnGetItemText(self, item, col):
    return self.dataSource.GetItemText(item, col)

  def RefreshAllItems(self):
    n_items = self.dataSource.GetItemCount()
    self.SetItemCount(n_items)
    if (n_items > 0):
      self.RefreshItems(0, n_items - 1)

  def GetSelectedJobIDs(self):
    jobs = []
    item = self.GetFirstSelected()
    while item != -1 :
      jobs.append(self.dataSource.GetItemText(item, 0))
      item = self.GetNextSelected(item)
    return jobs

  def GetOwners(self, job_ids, as_list=False):
    return self.dataSource.GetOwners(job_ids, as_list=as_list)

  def GetNames(self, job_ids):
    return self.dataSource.GetNames(job_ids)

  def OnSelect(self, event):
    pass

  def OnDeSelect(self, event):
    pass

  def OnDoubleClick(self, event):
    pass

  def OnRightClick(self, event):
    pass

  def OnSort(self, event):
    col = event.GetColumn()
    self.dataSource.SortItems(col)
    self.RefreshAllItems()

  def Update(self):
    self.dataSource.Refresh()
    self.RefreshAllItems()

class queue_list_frame(wx.Frame):
  def __init__(self, *args, **kwds):
    wx.Frame.__init__(self, *args, **kwds)
    self.statusbar = self.CreateStatusBar()
    self.SetupToolbar()
    self.list_ctrl = qsub_list_view(parent=self,
      id=-1,
      size=(800,600),
      style=wx.LC_REPORT|wx.LC_VIRTUAL)
    self.Bind(wx.EVT_CLOSE, self.OnClose)
    self.Bind(wx.EVT_WINDOW_DESTROY, self.OnDestroy)
    self.Update()
    self._timer = wx.Timer(owner=self)
    self.Bind(wx.EVT_TIMER, self.OnUpdate)
    self.statusbar.Bind(wx.EVT_LEFT_DCLICK, self.OnUpdate)
    self._timer.Start(10000)

  def SetupToolbar(self):
    if wxtbx.bitmaps.icon_lib is None :
      return
    self.toolbar = self.CreateToolBar(style=wx.TB_TEXT)
    commands = [
      ("actions","reload", "OnUpdate", "Refresh list"),
      ("actions","editdelete", "OnDelete", "Delete selected"),
    ]
    for (icon_class, icon_name, fname, label) in commands :
      bmp = wxtbx.bitmaps.fetch_icon_bitmap(icon_class, icon_name, 32)
      tool_button = self.toolbar.AddLabelTool(-1, label, bmp,
        shortHelp=label, kind=wx.ITEM_NORMAL)
      self.Bind(wx.EVT_MENU, getattr(self, fname), tool_button)
    self.toolbar.Realize()

  def OnClose(self, event):
    self.Destroy()

  def OnDestroy(self, event):
    pass

  def OnUpdate(self, event):
    self.Update()

  def OnDelete(self, event):
    job_ids = self.list_ctrl.GetSelectedJobIDs()
    if len(job_ids) == 0 :
      return
    users = self.list_ctrl.GetOwners(job_ids)
    if (len(users) > 1) or (not user in users):
      raise Sorry("At least one job selected for deletion is owned by a "
        "different user; this interface only allows you to delete your own "+
        "jobs.")
    if self.ConfirmDelete(job_ids):
      try :
        success = sge_utils.qdel(job_ids=job_ids)
      except RuntimeError as e :
        raise Sorry("Error executing 'qdel' command: %s" % str(e))
      else :
        GenericMessageDialog("Job(s) deleted successfuly.", style=wx.OK)

  def SetUpdateInterval(self, interval) : # in seconds, not ms
    self._timer.Stop()
    self._timer.Start(interval * 1000)

  def Update(self):
    self.list_ctrl.Update()
    self.statusbar.SetStatusText("Last updated at %s" % get_time())

  def ConfirmDelete(self, job_ids):
    pass

def get_time():
  return time.strftime("%m-%d-%y %H:%M:%S", time.localtime())

#-----------------------------------------------------------------------
def run(args):
  app = wx.App(0)
  frame = queue_list_frame(None, -1, "SGE Queue Status")
  frame.Show()
  frame.Fit()
  app.MainLoop()

if __name__ == "__main__" :
  run(sys.argv[1:])


 *******************************************************************************


 *******************************************************************************
wxtbx/regression/process_control.py

# TODO more comprehensive tests

from __future__ import absolute_import, division, print_function
from wx.lib.agw import pyprogress
import wx
from libtbx import thread_utils
from libtbx import runtime_utils
from libtbx import easy_pickle
from libtbx import easy_run
from libtbx.utils import Sorry, Abort, download_progress
import threading
import random
import locale
import math
import os
from six.moves import range

JOB_START_ID = wx.NewId()
LOG_UPDATE_ID = wx.NewId()
CALLBACK_ID = wx.NewId()
JOB_EXCEPTION_ID = wx.NewId()
JOB_KILLED_ID = wx.NewId()
JOB_COMPLETE_ID = wx.NewId()
JOB_PAUSE_ID = wx.NewId()
JOB_RESUME_ID = wx.NewId()
DOWNLOAD_COMPLETE_ID = wx.NewId()
DOWNLOAD_INCREMENT_ID = wx.NewId()

class SubprocessEvent(wx.PyEvent):
  event_id = None

  def __init__(self, data, **kwds):
    self.data = data
    self.__dict__.update(kwds)
    wx.PyEvent.__init__(self)
    self.SetEventType(self.event_id)

class JobStartEvent(SubprocessEvent):
  event_id = JOB_START_ID

class LogEvent(SubprocessEvent):
  event_id = LOG_UPDATE_ID

class JobExceptionEvent(SubprocessEvent):
  event_id = JOB_EXCEPTION_ID

class JobKilledEvent(SubprocessEvent):
  event_id = JOB_KILLED_ID

class JobCompleteEvent(SubprocessEvent):
  event_id = JOB_COMPLETE_ID

class CallbackEvent(SubprocessEvent):
  event_id = CALLBACK_ID

class JobPauseEvent(SubprocessEvent):
  event_id = JOB_PAUSE_ID

class JobResumeEvent(SubprocessEvent):
  event_id = JOB_RESUME_ID

class DownloadCompleteEvent(SubprocessEvent):
  event_id = DOWNLOAD_COMPLETE_ID

class DownloadIncrementEvent(SubprocessEvent):
  event_id = DOWNLOAD_INCREMENT_ID

def setup_stdout_logging_event(window, OnPrint):
  window.Connect(-1, -1, LOG_UPDATE_ID, OnPrint)

def setup_process_gui_events(
    window,
    OnStart=None,
    OnPrint=None,
    OnUpdate=None,
    OnExcept=None,
    OnAbort=None,
    OnComplete=None,
    OnPause=None,
    OnResume=None):
  if OnStart is not None :
    assert hasattr(OnStart, "__call__")
    window.Connect(-1, -1, JOB_START_ID, OnStart)
  if OnPrint is not None :
    assert hasattr(OnPrint, "__call__")
    window.Connect(-1, -1, LOG_UPDATE_ID, OnPrint)
  if OnUpdate is not None :
    assert hasattr(OnUpdate, "__call__")
    window.Connect(-1, -1, CALLBACK_ID, OnUpdate)
  if OnExcept is not None :
    assert hasattr(OnExcept, "__call__")
    window.Connect(-1, -1, JOB_EXCEPTION_ID, OnExcept)
  if OnAbort is not None :
    assert hasattr(OnAbort, "__call__")
    window.Connect(-1, -1, JOB_KILLED_ID, OnAbort)
  if OnComplete is not None :
    assert hasattr(OnComplete, "__call__")
    window.Connect(-1, -1, JOB_COMPLETE_ID, OnComplete)
  if OnPause is not None :
    assert hasattr(OnPause, "__call__")
    window.Connect(-1, -1, JOB_PAUSE_ID, OnPause)
  if OnResume is not None :
    assert hasattr(OnResume, "__call__")
    window.Connect(-1, -1, JOB_RESUME_ID, OnResume)

class event_agent(object):
  def __init__(self, window, **kwds):
    self.window = window
    self._kwds = dict(kwds)
    self.__dict__.update(kwds)

  def get_kwds(self):
    return self._kwds

  def callback_start(self, data):
    kwds = self.get_kwds()
    event = JobStartEvent(data, **kwds)
    wx.PostEvent(self.window, event)

  def callback_stdout(self, data):
    kwds = self.get_kwds()
    event = LogEvent(data, **kwds)
    wx.PostEvent(self.window, event)

  def callback_error(self, error, traceback_info):
    kwds = self.get_kwds()
    event = JobExceptionEvent((error, traceback_info), **kwds)
    wx.PostEvent(self.window, event)

  def callback_abort(self):
    kwds = self.get_kwds()
    event = JobKilledEvent(None, **kwds)
    wx.PostEvent(self.window, event)

  def callback_final(self, result):
    kwds = self.get_kwds()
    event = JobCompleteEvent(result, **kwds)
    wx.PostEvent(self.window, event)

  def callback_other(self, data):
    kwds = self.get_kwds()
    event = CallbackEvent(data, **kwds)
    wx.PostEvent(self.window, event)

  def callback_pause(self):
    kwds = self.get_kwds()
    event = JobPauseEvent(None, **kwds)
    wx.PostEvent(self.window, event)

  def callback_resume(self):
    kwds = self.get_kwds()
    event = JobResumeEvent(None, **kwds)
    wx.PostEvent(self.window, event)

# simplified for when the window is really the app object
class background_event_agent(event_agent):
  def callback_stdout(self, data):
    pass

  def callback_other(self, data):
    pass

class detached_process(runtime_utils.detached_process_client):
  def __init__(self, params, proxy):
    runtime_utils.detached_process_client.__init__(self, params)
    self.proxy = proxy

  def callback_start(self, data):
    self.proxy.callback_start(data)

  def callback_stdout(self, data):
    self.proxy.callback_stdout(data)

  def callback_other(self, data):
    print("OTHER")
    self.proxy.callback_other(data)

  def callback_abort(self):
    print("ABORT")
    self.proxy.callback_abort()

  def callback_final(self, result):
    print("FINAL")
    self.proxy.callback_final(result)

  def callback_error(self, error, traceback_info):
    print("ERROR")
    self.proxy.callback_error(error, traceback_info)

  def callback_pause(self):
    self.proxy.callback_pause()

  def callback_resume(self):
    self.proxy.callback_resume()

  def start(self):
    pass

# this just adds event posting callbacks to the original class
class process_with_gui_callbacks(thread_utils.process_with_callbacks):
  def __init__(self, proxy, target, args=(), kwargs={}, buffer_stdout=True):
    thread_utils.process_with_callbacks.__init__(self,
      target = target,
      args=args,
      kwargs=kwargs,
      callback_stdout = proxy.callback_stdout,
      callback_final  = proxy.callback_final,
      callback_err    = proxy.callback_error,
      callback_abort  = proxy.callback_abort,
      callback_other  = proxy.callback_other,
      callback_pause  = proxy.callback_pause,
      callback_resume = proxy.callback_resume,
      buffer_stdout   = buffer_stdout)

  def set_job(self, job):
    pass

  def purge_files(self):
    pass

class simple_gui_process(process_with_gui_callbacks):
  def __init__(self, window, target, args=(), kwargs={}):
    # XXX fix for phenix gui - is this necessary?
    proxy = event_agent(window, project_id=None, job_id=None)
    process_with_gui_callbacks.__init__(self,
      proxy=proxy,
      target=target,
      args=args,
      kwargs=kwargs,
      buffer_stdout=True)

class ThreadProgressDialog(pyprogress.PyProgress):
  def __init__(self, parent, title, message):
    pyprogress.PyProgress.__init__(self, parent, -1, title, message,
      agwStyle=wx.PD_ELAPSED_TIME|wx.PD_APP_MODAL)
    self.SetGaugeProportion(0.15)
    self.SetGaugeSteps(50)
    self.SetGaugeBackground(wx.Colour(235, 235, 235))
    self.SetFirstGradientColour(wx.Colour(235,235,235))
    self.SetSecondGradientColour(wx.Colour(120, 200, 255))

class download_file_basic(object):
  def __init__(self, window, dl_func, args):
    assert isinstance(window, wx.EvtHandler)
    assert hasattr(dl_func, "__call__")
    assert (isinstance(args, list) or isinstance(args, tuple))
    self.window = window
    window.Connect(-1, -1, DOWNLOAD_COMPLETE_ID, self.OnComplete)
    self.dl_func = dl_func
    self.args = args
    self.t = threading.Thread(target=self.run)
    self.t.start()

  def run(self):
    try :
      result = self.dl_func(self.args)
    except Exception as e :
      result = (None, str(e))
    finally :
      wx.PostEvent(self.window, DownloadCompleteEvent(result))
    return result

  def OnComplete(self, event):
    if isinstance(event.data, str):
      wx.MessageBox(message="File downloaded to %s" % event.data)
    else :
      wx.MessageBox(message="Error downloading file: %s" % event.data[1],
        caption="Download error", style=wx.ICON_ERROR)
    self.t.join()

class DownloadProgressDialog(wx.ProgressDialog, download_progress):
  """
  Dialog for displaying download progress.  The actual download (not
  implemented here) should be run in a separate thread, with a reasonable
  chunk size, and call download_progress.increment() as each new chunk is
  downloaded.
  """
  def __init__(self, parent, title, message):
    download_progress.__init__(self)
    wx.ProgressDialog.__init__(self, parent=parent,
      title=title,
      message=message,
      style=wx.PD_ELAPSED_TIME|wx.PD_CAN_ABORT|wx.PD_AUTO_HIDE,
      maximum=100)
    self.Connect(-1, -1, DOWNLOAD_INCREMENT_ID, self.OnIncrement)
    self.Connect(-1, -1, DOWNLOAD_COMPLETE_ID, self.OnComplete)
    self._continue = True

  def show_progress(self):
    if (not self._continue):
      return False
    locale.setlocale(locale.LC_ALL, 'en_US')
    pct = self.percent_finished()
    msg = "%s/%s KB downloaded" % (
      locale.format("%d", self.n_kb_elapsed, grouping=True),
      locale.format("%d", self.n_kb_total, grouping=True))
    evt = DownloadIncrementEvent(data=(pct, msg))
    wx.PostEvent(self, evt)
    return self._continue

  def OnIncrement(self, event):
    (cont, skip) = self.Update(value=event.data[0], newmsg=event.data[1])
    self._continue = cont

  def OnComplete(self, event):
    self.Hide()
    self.Close()
    # FIXME destroying the dialog crashes wxPython 2.9.5/osx-coocoa

  def complete(self):
    evt = DownloadCompleteEvent(data=None)
    wx.PostEvent(self, evt)

class BackgroundDownloadDialog(pyprogress.PyProgress, download_progress):
  """
  Placeholder for downloads which block the child thread; will pulse
  continuously but not show changing status.
  """
  def __init__(self, parent, title, message):
    download_progress.__init__(self)
    pyprogress.PyProgress.__init__(self, parent, -1, title, message,
      agwStyle=wx.PD_ELAPSED_TIME|wx.PD_CAN_ABORT|wx.PD_AUTO_HIDE)
    self.SetGaugeProportion(0.15)
    self.SetGaugeSteps(100)
    self.SetGaugeBackground(wx.Colour(235, 235, 235))
    self.SetFirstGradientColour(wx.Colour(235,235,235))
    self.SetSecondGradientColour(wx.Colour(120, 200, 255))
    self.Connect(-1, -1, DOWNLOAD_COMPLETE_ID, self.OnComplete)
    self._continue = True

  def show_progress(self):
    if (not self._continue):
      return False
    return self._continue

  def OnComplete(self, event):
    self.Hide()
    self.Close()

  def complete(self):
    evt = DownloadCompleteEvent(data=None)
    wx.PostEvent(self, evt)

def run_function_as_thread_in_dialog(parent, thread_function, title, message):
  dlg = ThreadProgressDialog(None, title, message)
  t = thread_utils.simple_task_thread(thread_function, dlg)
  t.start()
  while True :
    if t.is_complete() or t.exception_raised():
      #dlg.Destroy()
      dlg.Hide()
      break
    else :
      dlg.UpdatePulse()
    wx.MilliSleep(30)
  dlg.Destroy()
  wx.SafeYield()
  if t.exception_raised():
    raise RuntimeError("An exception occurred while running this process: %s" %
      t.get_error())
  return t.return_value

# TODO
class ProcessDialog(wx.Dialog):
  def __init__(self, parent, message, caption, callback=None):
    wx.Dialog.__init__(self,
      parent=parent,
      title=caption,
      style=wx.RAISED_BORDER|wx.CAPTION)
    self.callback = callback
    self.process = None
    self._error = None
    self._aborted = False
    szr = wx.BoxSizer(wx.VERTICAL)
    self.SetSizer(szr)
    szr2 = wx.BoxSizer(wx.VERTICAL)
    szr.Add(szr2, 1, wx.ALL, 5)
    msg_txt = wx.StaticText(self, -1, message)
    msg_txt.Wrap(400)
    szr2.Add(msg_txt, 0, wx.ALIGN_CENTER_HORIZONTAL|wx.ALL, 5)
    self.gauge = wx.Gauge(parent=self, size=(300,-1))
    self.gauge.SetRange(100)
    szr2.Add(self.gauge, 1, wx.ALL|wx.EXPAND|wx.ALIGN_CENTER_HORIZONTAL, 5)
    abort_btn = wx.Button(parent=self,
      label="Abort")
    self.Bind(wx.EVT_BUTTON, self.OnAbort, abort_btn)
    szr2.Add(abort_btn, 0, wx.ALL|wx.ALIGN_CENTER_HORIZONTAL, 5)
    self.SetMinSize((300,100))
    szr.Fit(self)
    self.Centre(wx.BOTH)

  def run(self, process):
    self.process = process
    self.process.start()
    self.gauge.Pulse()
    return self.ShowModal()

  def OnAbort(self, event):
    self.process.abort()
    self._aborted = True
    self.EndModal(wx.ID_CANCEL)

  def OnError(self, event):
    self._error = event.data
    self.EndModal(wx.ID_CANCEL)

  def exception_raised(self):
    return (self._error is not None)

  def was_aborted(self):
    return (self._aborted)

  def handle_error(self):
    if isinstance(self._error, Exception):
      raise event.data
    elif isinstance(self._error, tuple):
      exception, traceback = self._error
      if (isinstance(exception, Sorry)):
        raise Sorry(str(exception))
      raise RuntimeError("""\
Error in subprocess!
 Original error: %s
 Original traceback:
%s""" % (str(exception), traceback))
    else :
      raise Sorry("error in child process: %s" % str(self._error))
   # finally :
   #   self.EndModal(wx.ID_CANCEL)

  def OnComplete(self, event):
    try :
      if (self.callback is not None):
        self.callback(event.data)
    finally :
      self._result = event.data
      self.EndModal(wx.ID_OK)

  def get_result(self):
    return getattr(self, "_result", None)

def run_function_as_process_in_dialog(
    parent,
    thread_function,
    title,
    message,
    callback=None,
    project_id=None,
    job_id=None):
  dlg = ProcessDialog(
    parent=parent,
    message=message,
    caption=title,
    callback=callback)
  setup_process_gui_events(
    window=dlg,
    OnExcept=dlg.OnError,
    OnComplete=dlg.OnComplete)
  cb = event_agent(dlg, project_id=project_id, job_id=job_id)
  p = thread_utils.process_with_callbacks(
    target=thread_function,
    callback_final=cb.callback_final,
    callback_err=cb.callback_error,
    buffer_stdout=True,
    sleep_after_start=1)
  result = None
  abort = False
  if (dlg.run(p) == wx.ID_OK):
    result = dlg.get_result()
  elif dlg.exception_raised():
    dlg.handle_error()
  elif (dlg.was_aborted()):
    abort = True
  wx.CallAfter(dlg.Destroy)
  if (abort):
    raise Abort()
  return result

def run_function_as_detached_process_in_dialog(
    parent,
    thread_function,
    title,
    message,
    tmp_dir,
    callback=None,
    project_id=None,
    job_id=None):
  if (tmp_dir is None):
    tmp_dir = os.getcwd()
  params = runtime_utils.process_master_phil.extract()
  params.tmp_dir = tmp_dir
  if (job_id is not None):
    job_id = str(os.getpid()) + "_" + str(int(random.random() * 1000))
  params.prefix = str(job_id)
  target = runtime_utils.detached_process_driver(target=thread_function)
  run_file = os.path.join(tmp_dir, "libtbx_run_%s.pkl" % job_id)
  easy_pickle.dump(run_file, target)
  params.run_file = run_file
  eff_file = os.path.join(tmp_dir, "libtbx_run_%s.eff" % job_id)
  runtime_utils.write_params(params, eff_file)
  dlg = ProcessDialog(
    parent=parent,
    message=message,
    caption=title,
    callback=callback)
  setup_process_gui_events(
    window=dlg,
    OnExcept=dlg.OnError,
    OnComplete=dlg.OnComplete)
  agent = event_agent(
    window=dlg,
    project_id=project_id,
    job_id=job_id)
  process = detached_process(params, proxy=agent)
  cb = event_agent(dlg, project_id=project_id, job_id=job_id)
  easy_run.call("libtbx.start_process \"%s\" &" % eff_file)
  result = None
  abort = False
  if (dlg.run(process) == wx.ID_OK):
    result = dlg.get_result()
  elif dlg.exception_raised():
    dlg.handle_error()
  elif (dlg.was_aborted()):
    abort = True
  wx.CallAfter(dlg.Destroy)
  if (abort):
    raise Abort()
  return result

def test_function_1(*args, **kwds):
  n = 0
  for i in range(25000):
    x = math.sqrt(i)
    print(x)
    n += x
  return n
def test_function_2(*args, **kwds):
  n = 0
  for i in range(100000):
    x = math.sqrt(i)
    n += x
  return n
def test_function_3(*args, **kwds):
  raise RuntimeError("This is a test!")


 *******************************************************************************


 *******************************************************************************
wxtbx/regression/tst_process_control.py

# TODO more comprehensive tests

from __future__ import absolute_import, division, print_function
from wxtbx.process_control import *

def exercise():
  from libtbx.test_utils import approx_equal, Exception_expected
  import sys
  def excepthook(*args, **kwds):
    pass
  sys._excepthook = excepthook
  app = wx.App(0)
  result = run_function_as_process_in_dialog(
    parent=None,
    thread_function=test_function_1,
    title="Test subprocess",
    message="Running test function as forked process...",
    callback=None)
  if (result is not None):
    assert approx_equal(result, 2635152.11891, eps=0.0001)
  result = run_function_as_detached_process_in_dialog(
    parent=None,
    thread_function=test_function_1,
    title="Test subprocess",
    message="Running test function as separate process...",
    tmp_dir=os.getcwd(),
    callback=None)
  if (result is not None):
    assert approx_equal(result, 2635152.11891, eps=0.0001)
  #result2 = run_function_as_thread_in_dialog(
  #  parent=None,
  #  thread_function=test_function_2,
  #  title="Test subprocess",
  #  message="Running test function in Python thread...")
  #assert approx_equal(result2, 21081692.7462, eps=0.0001)
  try :
    result = run_function_as_process_in_dialog(
      parent=None,
      thread_function=test_function_3,
      title="Test subprocess",
      message="Running test function as separate process...",
      callback=None)
  except RuntimeError :
    pass
  else :
    raise Exception_expected
    result = run_function_as_process_in_dialog(
    parent=None,
    thread_function=test_function_1,
    title="Test subprocess",
    message="Running test function as separate process...",
    callback=None)
  wx.Yield()
  print("OK")

if (__name__ == "__main__"):
  exercise()


 *******************************************************************************


 *******************************************************************************
wxtbx/reports/__init__.py
from __future__ import absolute_import, division, print_function

import wx
import sys

class PDBLinkMixin(object):
  """
  Subclass this along with wx.Frame, etc. to link to the PDB from a list of
  results.  get_pdb_id_for_viewing() must be re-implemented in subclasses.
  """
  def create_pdb_buttons(self, panel, sizer):
    szr2 = wx.BoxSizer(wx.HORIZONTAL)
    sizer.Add(szr2)
    btn1 = wx.Button(panel, -1, "Download selected structure")
    szr2.Add(btn1, 0, wx.ALL, 5)
    self.Bind(wx.EVT_BUTTON, self.OnDownload, btn1)
    btn2 = wx.Button(panel, -1, "View PDB web page")
    szr2.Add(btn2, 0, wx.ALL, 5)
    self.Bind(wx.EVT_BUTTON, self.OnViewPDB, btn2)

  def get_pdb_id_for_viewing(self):
    raise NotImplementedError()

  def OnViewPDB(self, event):
    pdb_id = self.get_pdb_id_for_viewing()
    if (pdb_id is not None):
      url = "https://www.rcsb.org/pdb/explore/explore.do?structureId=%s" %pdb_id
      if (sys.platform == "darwin"):
        from wxtbx import browser
        if (getattr(self, "web_frame", None) is None):
          self.web_frame = browser.browser_frame(self, -1, "RCSB PDB")
          self.web_frame.SetHomepage("https://www.rcsb.org")
          self.Bind(wx.EVT_WINDOW_DESTROY, self.OnCloseWWW, self.web_frame)
          self.web_frame.Show()
        self.web_frame.Raise()
        self.web_frame.Open(url)
        self.web_frame.Refresh()
      else :
        import webbrowser
        webbrowser.open( url )

  def OnDownload(self, event):
    pdb_id = self.get_pdb_id_for_viewing()
    if (pdb_id is not None):
      def download(args):
        from iotbx.cli_parser import run_program
        from mmtbx.programs import fetch
        from mmtbx.command_line.fetch_pdb import custom_args_proc
        files = run_program(program_class=fetch.Program, custom_process_arguments=custom_args_proc, args=args)[0]
        if len(files) > 0:
          return files[-1]
        return []
      from wxtbx.process_control import download_file_basic
      download_file_basic(
        window=self,
        dl_func=download,
        args=[pdb_id])

  def OnCloseWWW(self, event):
    self.web_frame = None


 *******************************************************************************


 *******************************************************************************
wxtbx/reports/blast.py
from __future__ import absolute_import, division, print_function

from wxtbx import reports
import wx
import sys

class BlastFrame(wx.Frame, reports.PDBLinkMixin):
  def __init__(self, *args, **kwds):
    super(BlastFrame, self).__init__(*args, **kwds)
    self.statusbar = self.CreateStatusBar()
    szr = wx.BoxSizer(wx.VERTICAL)
    self.SetSizer(szr)
    panel = wx.Panel(self)
    szr.Add(panel, 1, wx.EXPAND)
    pszr = wx.BoxSizer(wx.VERTICAL)
    panel.SetSizer(pszr)
    box = wx.StaticBox(panel, label="BLAST results")
    boxszr = wx.StaticBoxSizer(box, wx.VERTICAL)
    pszr.Add(boxszr, 1, wx.ALL|wx.EXPAND, 5)
    boxszr.Add(wx.StaticText(panel, -1, "Query sequence:"))
    self.seq_ctrl = wx.TextCtrl(panel, style=wx.TE_READONLY|wx.TE_MULTILINE,
      size=(600,100))
    boxszr.Add(self.seq_ctrl, 0, wx.ALL, 5)
    boxszr.Add(wx.StaticText(panel, -1, "BLAST hits in PDB:"))
    self.hit_list = BlastList(panel, style=wx.LC_REPORT|wx.LC_SINGLE_SEL,
      size=(600,240))
    #self.hit_list.SetMinSize((600,240))
    boxszr.Add(self.hit_list, 1, wx.ALL|wx.EXPAND, 5)
    self.create_pdb_buttons(panel, boxszr)
    szr.Fit(panel)
    self.Layout()
    self.Fit()
    self.SetMinSize(self.GetSize())
    self.web_frame = None

  def SetResults(self, query, results):
    assert (len(results) > 0)
    self.statusbar.SetStatusText("%d results shown (top match: %s_%s)" %
      (len(results), results[0].pdb_id, results[0].chain_id))
    self.seq_ctrl.SetValue(query)
    self.hit_list.SetResults(results)

  def get_pdb_id_for_viewing(self):
    return self.hit_list.GetSelectedID()

class BlastList(wx.ListCtrl):
  def __init__(self, *args, **kwds):
    super(BlastList, self).__init__(*args, **kwds)
    cols = ["PDB ID", "Chain ID", "E-value", "Length", "% Identity",
            "% Positives"]
    widths = [100, 80, 100, 100, 100, 100]
    r, l = wx.LIST_FORMAT_RIGHT, wx.LIST_FORMAT_LEFT
    alignments = [l, l, r, r, r, r]
    for i, col in enumerate(cols):
      self.InsertColumn(i, col, alignments[i])
      self.SetColumnWidth(i, widths[i])

  def SetResults(self, results):
    self.DeleteAllItems()
    for result in results :
      i = self.InsertStringItem(sys.maxunicode, result.pdb_id)
      self.SetStringItem(i, 1, result.chain_id)
      self.SetStringItem(i, 2, "%g" % result.evalue)
      self.SetStringItem(i, 3, "%d" % result.length)
      self.SetStringItem(i, 4, "%.2f" % result.identity)
      self.SetStringItem(i, 5, "%.2f" % result.positives)

  def GetSelectedID(self):
    item = self.GetFirstSelected()
    if (item >= 0):
      return self.GetItem(item, 0).GetText()
    return None

if (__name__ == "__main__"):
  from iotbx.file_reader import any_file
  from iotbx.bioinformatics.structure import summarize_blast_output
  seq_file = any_file(sys.argv[1], force_type="seq")
  seq_file.check_file_type("seq")
  seq_objects = seq_file.file_object
  assert (len(seq_objects) == 1)
  sequence = seq_objects[0].sequence
  results = summarize_blast_output(blast_file=sys.argv[2])
  app = wx.App(0)
  frame = BlastFrame(None, -1, "BLAST results")
  frame.SetResults(sequence, results)
  frame.Show()
  app.MainLoop()


 *******************************************************************************


 *******************************************************************************
wxtbx/reports/pdb_symmetry.py
from __future__ import absolute_import, division, print_function

from wxtbx import reports
import wx
import sys

class SymmetryListFrame(wx.Frame, reports.PDBLinkMixin):
  def __init__(self, *args, **kwds):
    super(SymmetryListFrame, self).__init__(*args, **kwds)
    self.statusbar = self.CreateStatusBar()
    szr = wx.BoxSizer(wx.VERTICAL)
    self.SetSizer(szr)
    panel = wx.Panel(self)
    szr.Add(panel, 1, wx.EXPAND)
    pszr = wx.BoxSizer(wx.VERTICAL)
    panel.SetSizer(pszr)
    box = wx.StaticBox(panel, label="Symmetry search results")
    boxszr = wx.StaticBoxSizer(box, wx.VERTICAL)
    pszr.Add(boxszr, 1, wx.ALL|wx.EXPAND, 5)
    box2 = wx.BoxSizer(wx.HORIZONTAL)
    boxszr.Add(box2)
    box2.Add(wx.StaticText(panel, -1, "Input symmetry:"), 0, wx.ALL, 5)
    self.symm_txt = wx.StaticText(panel, -1, "", size=(540,-1))
    box2.Add(self.symm_txt, 0, wx.ALL, 5)
    boxszr.Add(wx.StaticText(panel, -1, "Closest matching PDB entries:"), 0,
      wx.ALL, 5)
    self.symm_list = PDBSymmList(
      parent=self,
      style=wx.LC_REPORT|wx.LC_SINGLE_SEL,
      size=(740,200))
    boxszr.Add(self.symm_list, 1, wx.ALL|wx.EXPAND, 5)
    self.create_pdb_buttons(panel, boxszr)
    szr.Fit(panel)
    self.Layout()
    self.Fit()
    self.SetMinSize(self.GetSize())
    self.web_frame = None

  def SetResults(self, symmetry, hits):
    sg_txt = str(symmetry.space_group_info())
    uc_txt = "%g %g %g %g %g %g" % symmetry.unit_cell().parameters()
    self.symm_txt.SetLabel("%s (%s)" % (sg_txt, uc_txt))
    self.statusbar.SetStatusText("%d results shown" % len(hits))
    self.symm_list.SetResults(hits)

  def get_pdb_id_for_viewing(self):
    return self.symm_list.GetSelectedID()

class PDBSymmList(wx.ListCtrl):
  def __init__(self, *args, **kwds):
    super(PDBSymmList, self).__init__(*args, **kwds)
    cols = ["PDB ID", "RMSD", "Volume ratio", "Space group", "Unit cell"]
    widths = [100, 80, 120, 120, 300]
    r, l = wx.LIST_FORMAT_RIGHT, wx.LIST_FORMAT_LEFT
    alignments = [l, r, r, r, r]
    for i, col in enumerate(cols):
      self.InsertColumn(i, col, alignments[i])
      self.SetColumnWidth(i, widths[i])

  def SetResults(self, results):
    self.DeleteAllItems()
    for result in results :
      i = self.InsertStringItem(sys.maxunicode, result.pdb_id)
      self.SetStringItem(i, 1, "%6.3f" % result.rmsd)
      self.SetStringItem(i, 2, "%g" % result.volume_ratio)
      self.SetStringItem(i, 3, str(result.pdb_symmetry.space_group_info()))
      self.SetStringItem(i, 4, "%g %g %g %g %g %g" %
        result.pdb_symmetry.unit_cell().parameters())

  def GetSelectedID(self):
    item = self.GetFirstSelected()
    if (item >= 0):
      return self.GetItem(item, 0).GetText()
    return None

def run(args):
  from mmtbx.command_line import search_pdb_symmetry
  results = search_pdb_symmetry.run(args=args)
  app = wx.App(0)
  frame = SymmetryListFrame(None, -1, "PDB symmetry search")
  frame.SetResults(results.crystal_symmetry, results.hits)
  frame.Show()
  app.MainLoop()

if (__name__ == "__main__"):
  run(sys.argv[1:])


 *******************************************************************************


 *******************************************************************************
wxtbx/segmentedctrl.py
from __future__ import absolute_import, division, print_function

# Copyright 2010 University of California
# All rights reserved

# This is an approximate mimic of the NSSegmentedControl in Cocoa.  The
# Apple control has many more styles than this, but the basic functionality
# is the same, with three selection modes (any, one, or none).  Either
# labels, bitmaps, or both are supported.

# TODO:
#   - Windows bugs
#   - additional styles?

import wx
from six.moves import range

SEGBTN_ROUNDED_CORNERS = 1
SEGBTN_VERTICAL = 2
SEGBTN_HORIZONTAL = 4
SEGBTN_INVERT_BITMAP = 8
SEGBTN_HIGHLIGHT = 16
SEGBTN_RADIO_ALLOW_NONE = 32

SEGBTN_DEFAULT_STYLE = SEGBTN_HORIZONTAL|SEGBTN_ROUNDED_CORNERS

if wx.Platform == '__WXMAC__' :
  _DEFAULT_PADDING = 8
elif wx.Platform == '__WXGTK__' :
  _DEFAULT_PADDING = 6
else :
  _DEFAULT_PADDING = 6

class SegmentedControl(wx.Control):
  def __init__(self,
                parent,
                id=wx.ID_ANY,
                pos=wx.DefaultPosition,
                size=wx.DefaultSize,
                style=SEGBTN_DEFAULT_STYLE,
                name=wx.ButtonNameStr,
                border=0,
                pad=_DEFAULT_PADDING):
    wx.Control.__init__(self, parent, id, pos=pos, size=size,
      style=wx.NO_BORDER,
      name=name)
    self.SetBackgroundStyle(wx.BG_STYLE_CUSTOM)
    self.InheritAttributes()
    self.segments = []
    self.values = [] # for radio and toggle versions
    self._clicked_segment = None
    self._padding = _DEFAULT_PADDING
    self._border = border
    self._style = style
    self._border_color = (0, 0, 0)
    if wx.Platform == '__WXGTK__' :
      self.SetFont(wx.Font(12, wx.FONTFAMILY_DEFAULT, wx.NORMAL, wx.NORMAL))

    # Event Handlers
    self.Bind(wx.EVT_PAINT, lambda evt: self.__DrawButtons())
    self.Bind(wx.EVT_ERASE_BACKGROUND, self.OnErase)
    #self.Bind(wx.EVT_SET_FOCUS, self.OnFocus)
    #self.Bind(wx.EVT_KILL_FOCUS, self.OnKillFocus)
    self.Bind(wx.EVT_LEFT_DOWN, self.OnLeftDown)
    self.Bind(wx.EVT_LEFT_UP, self.OnLeftUp)
    #self.Bind(wx.EVT_LEFT_DCLICK, lambda evt: self.ToggleState())
    self.Bind(wx.EVT_ENTER_WINDOW, self.OnEnter)
    self.Bind(wx.EVT_LEAVE_WINDOW, self.OnLeave)
    self.Bind(wx.EVT_MOTION, self.OnMotion)

  def AddSegment(self, label="", bitmap=None):
    if label == "" and bitmap is None :
      raise RuntimeError("Must specify either a label or a bitmap or both "+
        "for SegmentControl.AddSegment().")
    self.segments.append((label, bitmap))
    self.values.append(False)

  def InsertSegment(self, index, label="", bitmap=None):
    if label == "" and bitmap is None :
      raise RuntimeError("Must specify either a label or a bitmap or both "+
        "for SegmentControl.InsertSegment().")
    self.segments.insert(index, (label, bitmap))
    self.values.append(True)

  def Realize(self):
    self.SetSize(self.DoGetBestSize())

  def SetBorderColor(self, color):
    self._border_color = color

  def DoGetBestSize(self):
    dc = wx.ClientDC(self)
    dc.SetFont(self.GetFont())
    n_seg = len(self.segments)
    buf = 1
    if n_seg == 0 :
      (w, h) = dc.GetTextExtent("XXX")
      w += self._padding * 2
      h += self._padding * 2
    else :
      txt_w, txt_h = self.__OverallSegmentContentSize(dc)
      seg_w = txt_w + (2 * self._padding)
      seg_h = txt_h + (2 * self._padding)
      if self._style & SEGBTN_VERTICAL :
        w = seg_w + 2
        h = 1 + ((seg_h + buf) * n_seg)
      else :
        w = 1 + ((seg_w + buf) * n_seg)
        h = seg_h + 2
    w += (self._border * 2)
    h += (self._border * 2)
    return (w, h)

  def __OverallSegmentContentSize(self, dc):
    max_h = 0
    max_w = 0
    for (label, bitmap) in self.segments :
      (text_w, text_h) = (0, 0)
      (bmp_w, bmp_h) = (0, 0)
      if label != "" :
        (text_w, text_h) = dc.GetTextExtent(label)
      if bitmap is not None :
        (bmp_w, bmp_h) = bitmap.GetSize()
      if label != "" and bitmap is not None :
        seg_w = max(text_w, bmp_w)
        seg_h = text_h + bmp_h + 2
      elif label != "" :
        (seg_w, seg_h) = (text_w, text_h)
      else :
        (seg_w, seg_h) = (bmp_w, bmp_h)
      if seg_h > max_h :
        max_h = seg_h
      if seg_w > max_w :
        max_w = seg_w
    return (max_w, max_h)

  def __DrawButtons(self):
    dc = wx.AutoBufferedPaintDCFactory(self)
    if wx.Platform == '__WXMSW__' :
      dc.SetBackground(wx.Brush(self.GetParent().GetBackgroundColour()))
      dc.Clear()
    gc = wx.GCDC(dc)
    gc.SetBackgroundMode(wx.TRANSPARENT)
    gc.SetFont(self.GetFont())

    (w, h) = self.GetSize() #DoGetBestSize()
    w -= (self._border * 2)
    h -= (self._border * 2)
    n_seg = len(self.segments)
    rgc = gc.GetGraphicsContext()
    if self._style & SEGBTN_VERTICAL :
      # XXX a smaller gradient looks better for vertical controls
      gradient_brush = rgc.CreateLinearGradientBrush(0, 0, w, 0, (240,240,240),
        (200,200,200))
    else :
      gradient_brush = rgc.CreateLinearGradientBrush(0, 0, 0, h, (250,250,250),
        (185,185,185))
    rgc.SetBrush(gradient_brush)
    border_pen = wx.Pen(self._border_color, 1)
    # XXX wx.GCDC on GTK draws thin black lines as thicker dark grey lines
    # due to antialiasing.
    if wx.Platform == '__WXGTK__' :
      gc.SetPen(wx.TRANSPARENT_PEN)
      dc.SetPen(border_pen)
      dc.SetBrush(wx.TRANSPARENT_BRUSH)
    else :
      gc.SetPen(border_pen)
    if self._style & SEGBTN_ROUNDED_CORNERS :
      gc.DrawRoundedRectangle(self._border, self._border, w, h, 3)
      if wx.Platform == '__WXGTK__' :
        dc.DrawRoundedRectangle(self._border, self._border, w, h, 3)
    else :
      gc.DrawRectangle(self._border, self._border, w, h)
      if wx.Platform == '__WXGTK__' :
        dc.DrawRectangle(self._border, self._border, w, h)
    gc.SetPen(wx.TRANSPARENT_PEN)
    gc.SetBrush(wx.TRANSPARENT_BRUSH)
    if n_seg == 0 :
      gc.SetTextForeground('red')
      gc.DrawText("XXX", self._padding, self._padding)
    else :
      gc.SetTextForeground('black')
      gc.SetPen(wx.Pen('black', 1)) #BLACK_PEN)
      buf = 1
      (txt_w, txt_h) = self.__OverallSegmentContentSize(gc)
      if self._style & SEGBTN_VERTICAL :
        seg_w = w - 2
        seg_h = ((h - 1) / n_seg) - buf
      else :
        seg_w = ((w - 1) / n_seg) - buf
        seg_h = h -  2
      current_x = 1 + self._border
      current_y = 1 + self._border
      for i, (label, bitmap) in enumerate(self.segments):
        gc.SetPen(border_pen)
        dc.SetPen(border_pen)
        (txt_x, txt_y) = (self._padding + 1, self._padding + 1)
        if self._style & SEGBTN_VERTICAL :
          if i > 0 :
            dc.DrawLine(int(self._border), int(current_y), int(w + self._border - 1),
              int(current_y))
            current_y += 1
          txt_y += current_y
          txt_x += self._border
        else :
          if i > 0 :
            dc.DrawLine(int(current_x), int(self._border + 1), int(current_x),
              int(h + self._border - 1))
            current_x += 1
          txt_x += current_x
          txt_y += self._border
        if ((self.HasCapture() and i == self._clicked_segment) or
             self.values[i] == True):
          xo = current_x + (seg_w / 2)
          yo = current_y + (seg_h / 2)
          radius  = max(seg_w, seg_h) - 1
          brush = rgc.CreateRadialGradientBrush(xo, yo, xo, yo, radius,
            (220,220,220), (120,120,120))
          rgc.SetBrush(brush)
          gc.SetPen(wx.TRANSPARENT_PEN)
          if self._style & SEGBTN_ROUNDED_CORNERS and (i == 0 or i == n_seg):
            gc.DrawRoundedRectangle(int(current_x), int(current_y), int(seg_w), int(seg_h), 1)
          else :
            gc.DrawRectangle(int(current_x), int(current_y), int(seg_w), int(seg_h))
          #gc.DrawRectangle(current_x, current_y, total_w, total_h)
        rgc.SetBrush(gradient_brush)
        gc.SetBrush(wx.TRANSPARENT_BRUSH)
        gc.SetPen(wx.BLACK_PEN)
        label_w, label_h = gc.GetTextExtent(label)
        if bitmap is not None :
          (img_w, img_h) = bitmap.GetSize()
          img_x, img_y = txt_x, txt_y
          if label != "" :
            if wx.Platform == '__WXGTK__' :
              img_y -= 4
            extra_h_space = seg_w - img_w - (self._padding * 2)
            extra_v_space = seg_w - img_h - label_h - (self._padding * 2)
          else :
            extra_h_space = seg_w - img_w - (self._padding * 2)
            extra_v_space = seg_h - img_h - (self._padding * 2)
          if extra_h_space > 0 :
            img_x += extra_h_space / 2
          if extra_v_space > 0 :
            img_y += extra_v_space / 2
          gc.DrawBitmap(bitmap, img_x, img_y, bitmap.GetMask() != None)
          txt_y += img_h
          if (wx.Platform == '__WXMSW__'):
            txt_y -= 2
        if label != "" :
          #print seg_w, label_w
          extra_w = seg_w - label_w - (self._padding*2)
          if extra_w > 0 :
            txt_x += extra_w / 2
          extra_h = seg_h - label_h - (self._padding*2)
          if extra_h > 0 :
            txt_y += extra_h / 2
          gc.DrawText(label, int(txt_x), int(txt_y))
        if self._style & SEGBTN_VERTICAL :
          current_y += seg_h
        else :
          current_x += seg_w

  def HandleClick(self):
    pass

  def HitTest(self, event):
    x, y = event.GetPositionTuple()
    dc = wx.ClientDC(self)
    n_seg = len(self.segments)
    buf = 1
    (w, h) = self.DoGetBestSize()
    if self._style & SEGBTN_VERTICAL :
      seg_w = w - 2
      seg_h = ((h - 1) / n_seg) - buf
    else :
      seg_w = ((w - 1) / n_seg) - buf
      seg_h = h -  2
    if n_seg == 0 :
      return None
    elif (x < 1 or x > (w - 1)) or (y < 1 or y > (h-1)):
      return None
    elif self._style & SEGBTN_VERTICAL :
      current_y = 1
      for i in range(n_seg):
        max_y = current_y + seg_h
        if y > current_y and y < max_y :
          return i
        current_y = max_y
    else :
      current_x = 1
      for i in range(n_seg):
        max_x = current_x + seg_w -1
        if x >= current_x and x < max_x :
          return i
        current_x = max_x + 2
    return None

  def OnLeftDown(self, event):
    segment_id = self.HitTest(event)
    self._have_mouse = True
    self._clicked_segment = segment_id
    self.CaptureMouse()
    self.SetFocus()
    self.Refresh()

  def OnLeftUp(self, event):
    if self.HasCapture():
      self.ReleaseMouse()
    segment_id = self.HitTest(event)
    if segment_id is not None and segment_id == self._clicked_segment :
      self.HandleClick()
    self._clicked_segment = None
    self.Refresh()

  def OnEnter(self, event):
    if event.LeftDown():
      self.CaptureMouse()
      self.Refresh()

  def OnLeave(self, event):
    pass
    if self.HasCapture():
      self.ReleaseMouse()
      self.Refresh()
#      self._clicked_segment = None

  def OnMotion(self, event):
    return
    if not self.IsEnabled():
      return
    x,y = event.GetPositionTuple()
    w,h = self.GetClientSizeTuple()
    if (x<0 or y<0 or x>=w or y>=h) and self.HasCapture():
      #self._clicked_segment = None
      print(-3)
      self.ReleaseMouse()
      self.Refresh()
      return
    elif event.LeftDown():
      print(-2)
      self.CaptureMouse()
      self.Refresh()
      return
    event.Skip()

  def OnErase(self, event):
    pass

  def OnFocus(self, event):
    pass

  def OnKillFocus(self, event):
    pass

class SegmentedButtonControl(SegmentedControl):
  def HandleClick(self):
    bevt = wx.CommandEvent(wx.wxEVT_COMMAND_BUTTON_CLICKED, self.GetId())
    bevt.SetEventObject(self)
    bevt.SetString(self.GetLabel())
    bevt.SetClientData(self._clicked_segment)
    wx.PostEvent(self.GetParent(), bevt)
    self._clicked_segment = None

class SegmentedRadioControl(SegmentedControl):
  def HandleClick(self):
    index = self._clicked_segment
    assert index >= 0
    if self.values[index] == True and self._style & SEGBTN_RADIO_ALLOW_NONE :
      self.values[index] = False
    elif not self.values[index] :
      self.SetSelection(index)
    bevt = wx.CommandEvent(wx.wxEVT_COMMAND_RADIOBUTTON_SELECTED, self.GetId())
    bevt.SetEventObject(self)
    bevt.SetString(self.GetLabel())
    bevt.SetClientData(self.GetSelection())
    wx.PostEvent(self.GetParent(), bevt)
    self._clicked_segment = None

  def GetSelection(self):
    assert self.values.count(True) <= 1
    if True in self.values :
      return self.values.index(True)
    return -1

  def SetSelection(self, index):
    self.values = [False] * len(self.segments)
    self.values[index] = True

class SegmentedToggleControl(SegmentedControl):
  def HandleClick(self):
    index = self._clicked_segment
    assert index >= 0
    old_value = self.values[index]
    self.values[index] = not old_value
    bevt = wx.CommandEvent(wx.wxEVT_COMMAND_TOGGLEBUTTON_CLICKED, self.GetId())
    bevt.SetEventObject(self)
    bevt.SetString(self.GetLabel())
    bevt.SetClientData(self._clicked_segment)
    wx.PostEvent(self.GetParent(), bevt)
    self._clicked_segment = None

  def GetValue(self, index):
    return self.values[index]

  def SetValue(self, index, value):
    self.values[index] = value

#-----------------------------------------------------------------------
if __name__ == "__main__" :
  def OnButton(evt):
    print("Button clicked: %d" % evt.GetClientData())
  def OnRadio(evt):
    print("Radio button selection: %d" % evt.GetClientData())
  def OnToggle(evt):
    index = evt.GetClientData()
    print("Toggle button clicked: %d, %s" % (index,
      evt.GetEventObject().GetValue(index)))
  try :
    from wxtbx import bitmaps
  except ImportError :
    bitmaps = None
  app = wx.App(0)
  frame = wx.Frame(None, -1, "Test frame")
  toolbar = frame.CreateToolBar()
  panel = wx.Panel(frame, -1, size=(640,480))
  sizer = wx.BoxSizer(wx.HORIZONTAL)
  panel.SetSizer(sizer)
  v_sizer = wx.BoxSizer(wx.VERTICAL)
  btn = SegmentedButtonControl(panel,
    style=SEGBTN_HORIZONTAL) #|SEGBTN_AUTOSIZE)
  btn.AddSegment("Prev")
  btn.AddSegment("Home")
  btn.AddSegment("Search")
  btn.AddSegment("Help")
  btn.AddSegment("Next")
  frame.Bind(wx.EVT_BUTTON, OnButton, btn)
  v_sizer.Add(wx.StaticText(panel, -1, "Standard buttons"), 0, wx.ALL, 5)
  v_sizer.Add(btn, 0, wx.ALL, 5)
  sizer.Add(v_sizer)
  if True :
    tbtn = SegmentedButtonControl(toolbar,
      style=SEGBTN_HORIZONTAL|SEGBTN_ROUNDED_CORNERS,
      border=4)
    tbtn.AddSegment("Prev")
    tbtn.AddSegment("Home")
    tbtn.AddSegment("Search")
    tbtn.AddSegment("Help")
    tbtn.AddSegment("Next")
    tbtn.Realize()
    (w,h) = tbtn.GetSize()
    toolbar.SetToolBitmapSize((h,h))
    frame.Bind(wx.EVT_BUTTON, OnButton, tbtn)
    toolbar.AddControl(tbtn)
    #toolbar.AddControl(wx.Button(toolbar, -1, "Hello"))
    btn2 = SegmentedRadioControl(panel)
    btn2.AddSegment("Rotate")
    btn2.AddSegment("Pan")
    btn2.AddSegment("Zoom")
    btn2.SetSelection(0)
    frame.Bind(wx.EVT_RADIOBUTTON, OnRadio, btn2)
    v_sizer.Add(wx.StaticText(panel, -1, "Radio buttons"), 0, wx.ALL, 5)
    v_sizer.Add(btn2, 0, wx.ALL, 5)
    btn3 = SegmentedToggleControl(panel)
    btn3.AddSegment("Maps")
    btn3.AddSegment("Models")
    btn3.AddSegment("Selection")
    btn3.Realize()
    frame.Bind(wx.EVT_TOGGLEBUTTON, OnToggle, btn3)
    v_sizer.Add(wx.StaticText(panel, -1, "Toggle buttons"), 0, wx.ALL, 5)
    v_sizer.Add(btn3, 0, wx.ALL, 5)
    if (bitmaps is not None) and (bitmaps.icon_lib is not None):
      bmp1 = bitmaps.fetch_icon_bitmap("actions", "1leftarrow", 16)
      bmp2 = bitmaps.fetch_icon_bitmap("actions", "gohome", 16)
      bmp3 = bitmaps.fetch_icon_bitmap("actions", "viewmag", 16)
      bmp4 = bitmaps.fetch_icon_bitmap("actions", "1rightarrow", 16)
      btn4 = SegmentedButtonControl(panel)
      btn4.AddSegment(bitmap=bmp1)
      btn4.AddSegment(bitmap=bmp2)
      btn4.AddSegment(bitmap=bmp3)
      btn4.AddSegment(bitmap=bmp4)
      v_sizer.Add(wx.StaticText(panel, -1, "Bitmap buttons"), 0, wx.ALL, 5)
      v_sizer.Add(btn4, 0, wx.ALL, 5)
      frame.Bind(wx.EVT_BUTTON, OnButton, btn4)
      btn5 = SegmentedButtonControl(panel,
        style=SEGBTN_ROUNDED_CORNERS)
      btn5.AddSegment(label="Back", bitmap=bmp1)
      btn5.AddSegment(label="Home", bitmap=bmp2)
      btn5.AddSegment(label="Search", bitmap=bmp3)
      btn5.AddSegment(label="Next", bitmap=bmp4)
      btn5.SetFont(wx.Font(9, wx.FONTFAMILY_DEFAULT, wx.NORMAL, wx.NORMAL))
      v_sizer.Add(wx.StaticText(panel, -1, "Bitmaps and text"), 0, wx.ALL, 5)
      v_sizer.Add(btn5, 0, wx.ALL, 5)
      frame.Bind(wx.EVT_BUTTON, OnButton, btn5)
    vbtn1 = SegmentedButtonControl(panel,
      style=SEGBTN_VERTICAL)
    vbtn1.AddSegment("Up")
    vbtn1.AddSegment("Home")
    vbtn1.AddSegment("Search")
    vbtn1.AddSegment("Down")
    frame.Bind(wx.EVT_BUTTON, OnButton, vbtn1)
    sizer.Add(vbtn1, 0, wx.ALL, 20)
    vbtn2 = SegmentedButtonControl(panel,
      style=SEGBTN_VERTICAL|SEGBTN_ROUNDED_CORNERS,
      border=8)
    vbtn2.AddSegment("Up")
    vbtn2.AddSegment("Home")
    vbtn2.AddSegment("Search")
    vbtn2.AddSegment("Down")
    frame.Bind(wx.EVT_BUTTON, OnButton, vbtn2)
    sizer.Add(vbtn2, 0, wx.ALL, 20)
  sizer.Layout()
  sizer.Fit(panel)
  frame.Fit()
  toolbar.Realize()
  frame.Show()
  app.MainLoop()


 *******************************************************************************


 *******************************************************************************
wxtbx/sequence_view.py

# Copyright 2010 University of California
#
# Sequence view and selection window, with optional secondary structure
# annotation.  The outer window and PDB processing methods depend on CCTBX,
# but the panels can be adapted to any other framework.

# FIXME use numbering/resids in PDB file

# TODO: show existing CCTBX atom selection?

from __future__ import absolute_import, division, print_function
import wx
import wx.lib.scrolledpanel
import math, sys, os
from six.moves import range
from wxtbx.wx4_compatibility import create_measuring_context # XXX PYTHON 3 FIX

WXTBX_SEQ_SELECT_NONE = 1
WXTBX_SEQ_SELECT_SINGLE = 2
WXTBX_SEQ_SELECT_MULTIPLE = 4
WXTBX_SEQ_SELECT_RANGE = 8
WXTBX_SEQ_SELECT_ANY = 16
WXTBX_SEQ_SHOW_LINE_NUMBERS = 32
WXTBX_SEQ_SHOW_LABELS = 64
WXTBX_SEQ_SHOW_TOOLTIP = 128
WXTBX_SEQ_SHOW_SELECTIONS = 256
WXTBX_SEQ_ENABLE_SELECT_STRUCTURE = 512
WXTBX_SEQ_ENABLE_SELECT_MISSING = 1024
WXTBX_SEQ_FANCY_HELICES = 2048
WXTBX_SEQ_SINGLE_CLICK_SELECTION = 4096
WXTBX_SEQ_MSA_SELECT_ALL = 8192

WXTBX_SEQ_DEFAULT_STYLE = WXTBX_SEQ_SHOW_LINE_NUMBERS | \
                          WXTBX_SEQ_SHOW_SELECTIONS | \
                          WXTBX_SEQ_ENABLE_SELECT_STRUCTURE | \
                          WXTBX_SEQ_ENABLE_SELECT_MISSING | \
                          WXTBX_SEQ_FANCY_HELICES

class sequence_panel(wx.Panel):
  tooltip = "Double-click a residue to select it; hold down Shift to select \
multiple residues."
  __bg_color = (255,255,255)
  line_sep = 28
  line_width = 50
  line_height = 16
  line_indent = 16
  start_offset = 0
  char_w = 10 # XXX Python 3 Fix
  char_h = 10 # XXX Python 3 Fix

  def __init__(self, *args, **kwds):
    wx.Panel.__init__(self, *args, **kwds)
    if self.__bg_color is not None :
      self.SetBackgroundColour(self.__bg_color)
    #from scitbx.array_family import flex, shared
    self.sequences = []
    self.sequence_labels = []
    self.char_boxes = [] #shared.stl_set_unsigned()
    self.highlights = []
    self.highlight_colors = []
    self.selected_residues = [] #flex.bool()
    self.selection_color = (255, 255, 0)
    self._last_x = None
    self._last_y = None
    self.resseq_offset = 0
    self._style = WXTBX_SEQ_DEFAULT_STYLE | WXTBX_SEQ_SELECT_ANY
    self.txt_font = wx.Font(14, wx.MODERN, wx.NORMAL, wx.NORMAL)
    self.Bind(wx.EVT_PAINT, self.OnPaint)
    self.Bind(wx.EVT_LEFT_DCLICK, self.OnDoubleClick)
    self.Bind(wx.EVT_LEFT_DOWN, self.OnLeftDown)
    self.Bind(wx.EVT_LEFT_UP, self.OnLeftUp)
    self.Bind(wx.EVT_RIGHT_DOWN, self.OnRightDown)
    self.Bind(wx.EVT_RIGHT_UP, self.OnRightUp)
    self.tip = wx.ToolTip(self.tooltip)
    self.SetToolTip(self.tip)
    self.tip.Enable(False)

  def SetStyle(self, style):
    self._style = style
    self.enable_tooltip(style & WXTBX_SEQ_SHOW_TOOLTIP)

  def enable_tooltip(self, enable=True):
    self.tip.Enable(enable)

  def OnPaint(self, event):
    dc = wx.AutoBufferedPaintDCFactory(self)
    # XXX is there any reason not to do this on all systems?  test on Linux
    if (wx.Platform == "__WXMSW__"):
      dc.SetBackground(wx.WHITE_BRUSH)
      dc.SetBackgroundMode(wx.SOLID)
      dc.Clear()
    gc = wx.GraphicsContext.Create(dc)
    self.paint(gc)

  def paint(self, gc):
    self.paint_sequence(gc)

  def paint_sequence(self, gc):
    gc.SetBrush(wx.TRANSPARENT_BRUSH)
    gc_txt_font = gc.CreateFont(self.txt_font, (0,0,0))
    if hasattr(gc,'SetFont'): gc.SetFont(gc_txt_font) #  #  XXX Python 3 fix
    black_pen = wx.Pen((0,0,0), 1)
    (char_w, char_h) = self.get_char_size(gc)
    if (self._style & WXTBX_SEQ_SHOW_SELECTIONS):
      if (self._style & WXTBX_SEQ_MSA_SELECT_ALL):
        pass
      else :
        for k_seq in range(self.n_seqs()):
          for j, (i_start, i_end) in enumerate(self.get_selected_ranges()):
            gc.SetPen(wx.Pen((0,0,0), 1))
            gc.SetBrush(wx.Brush(self.selection_color))
            self.draw_box_around_residues(k_seq, i_start, i_end, gc)
    gc.SetBrush(wx.TRANSPARENT_BRUSH)
    for k_seq in range(self.n_seqs()):
      xpos = self.line_indent
      ypos = self.get_line_sep()
      v_offset = k_seq * self.line_height
      i = 0
      while i < len(self.sequences[k_seq]):
        j = i
        line_start = self.start_offset + i + 1
        line_end = line_start + self.line_width - 1
        line = self.sequences[k_seq][i:i+self.line_width]
        line_w = self.line_width * char_w
        label_start, label_end = self.get_line_labels(k_seq, i)
        label_w = self.get_label_width(gc)
        if (label_start is not None):
          gc.DrawText(label_start, xpos, ypos + v_offset)
          xpos += label_w
        if (label_end is not None):
          gc.DrawText(label_end, xpos + label_w + line_w, ypos + v_offset)
        for j, char in enumerate(line):
          i_seq = i+j
          if i_seq in self.highlights :
            color = self.highlight_colors[self.highlights.index(i_seq)]
            if hasattr(gc,'SetFont'): gc.SetFont(gc.CreateFont(self.txt_font, color)) #  XXX Python 3 fix
          gc.DrawText(char, xpos, ypos + v_offset)
          if hasattr(gc,'SetFont'): gc.SetFont(gc_txt_font) #  XXX Python 3 fix
          xpos += char_w
        i += self.line_width
        ypos += self.get_line_spacing()
        xpos = self.line_indent
    return gc

  def draw_box_around_residues(self, k_seq, i_start, i_end, gc):
    ranges = self.get_contiguous_ranges(i_start, i_end)
    char_w, char_h = self.get_char_size(gc)
    for (seg_start, seg_end) in ranges :
      (x1, y1, nx, ny) = self.get_char_position(k_seq, seg_start)
      (nx, ny, x2, y2) = self.get_char_position(k_seq, seg_end)
      line = gc.CreatePath()
      line.MoveToPoint(x1 - 1, y1 - 1)
      line.AddLineToPoint(x2 - 1, y1 - 1)
      line.AddLineToPoint(x2 - 1, y2 - 1)
      line.AddLineToPoint(x1 - 1, y2 - 1)
      line.CloseSubpath()
      gc.PushState()
      gc.FillPath(line)
      gc.StrokePath(line)
      gc.PopState()
      #gc.DrawRectangle(x1, y1, x2 - x1, y2 - y1)

  def DoGetBestSize(self):
    #dc = wx.GraphicsContext.CreateMeasuringContext() #ClientDC(self)
    dc = create_measuring_context()
    if hasattr(dc,'SetFont'): dc.SetFont(self.txt_font) #  #  XXX Python 3 fix
    i = 0
    (panel_w, panel_h) = (32, 32)
    char_w, char_h = self.get_char_size(dc)
    line_w = char_w * self.line_width
    if (self._style & WXTBX_SEQ_SHOW_LABELS):
      line_w += self.get_label_width(dc)
    elif (self._style & WXTBX_SEQ_SHOW_LINE_NUMBERS):
      if hasattr(dc, 'GetTextExtent'): #  XXX Python 3 fix
        line_w += dc.GetTextExtent("X" * 16)[0]
      else:
        line_w += self.char_w * 16

    panel_w += line_w
    n_lines = int(math.ceil(self.sequence_length() / self.line_width))
    panel_h += n_lines * self.get_line_spacing()
    return (max(480, panel_w), max(240, panel_h))

  def set_sequence(self, seq, resseq_offset=0):
    self.set_sequences([seq])
    self.resseq_offset = resseq_offset

  def set_sequences(self, seqs, labels=(), resseq_offset=0):
    self.sequences = [ "".join(seq.splitlines()) for seq in seqs ]
    assert (len(set([ len(s) for s in self.sequences ])) == 1)
    assert (len(labels) == 0) or (len(labels) == len(seqs))
    if (len(self.sequence_labels) != 0):
      assert (len(self.sequence_labels) == len(seqs))
    else :
      self.sequence_labels = labels
    self.resseq_offset = resseq_offset
    self.build_boxes()
    self.clear_highlights()
    self.clear_selection()
    self.InvalidateBestSize()

  def set_sequence_labels(self, labels):
    assert (len(labels) == len(self.sequences))
    self.sequence_labels = labels
    self.build_boxes()
    self.InvalidateBestSize()

  def n_seqs(self):
    return len(self.sequences)

  def sequence_length(self):
    if (self.n_seqs() > 0):
      return len(self.sequences[0])
    return 0

  def get_line_sep(self):
    return self.line_sep

  def get_line_spacing(self):
    return ((self.n_seqs() - 1) * self.line_height) + self.get_line_sep()

  def get_line_labels(self, k_seq, i_seq):
    line_start = self.resseq_offset + i_seq + 1
    line_end = line_start + self.line_width - 1
    if (self._style & WXTBX_SEQ_SHOW_LABELS):
      label_start = self.sequence_labels[k_seq]
      label_end = None
    elif (self._style & WXTBX_SEQ_SHOW_LINE_NUMBERS):
      label_start = "%6d  " % line_start
      label_end = "  %-6d" % line_end
    return (label_start, label_end)

  def get_label_width(self, dc):
    if (self._style & WXTBX_SEQ_SHOW_LABELS):
      if (len(self.sequence_labels) > 0):
        n_chars = max([ len(l) for l in self.sequence_labels ])
      else :
        n_chars = 0
    elif (self._style & WXTBX_SEQ_SHOW_LINE_NUMBERS):
      n_chars = 6
    else :
      n_chars = 0
    if hasattr(dc, 'GetTextExtent'): #  XXX Python 3 fix
      return dc.GetTextExtent("X" * (n_chars + 2))[0]
    else:
      return self.char_w * (n_chars+2)

  def get_char_size(self, dc=None):
    if dc is None :
      #dc = wx.GraphicsContext.CreateMeasuringContext() #ClientDC(self)
      dc = create_measuring_context()
      if hasattr(dc,'SetFont'): dc.SetFont(self.txt_font) #  #  XXX Python 3 fix
    if hasattr(dc, 'GetTextExtent'): #  XXX Python 3 fix
      line_w, char_h = dc.GetTextExtent("X" * 50)
    else:
      line_w, char_h = self.char_w * 50, self.char_h
    if wx.Platform == '__WXGTK__' :
      char_w = max(12, line_w / 50)
    elif wx.Platform == '__WXMAC__' :
      char_w = max(10, line_w / 50)
    elif (wx.Platform == '__WXMSW__'):
      char_w = max(10, line_w / 50)
    else :
      raise RuntimeError("Platform not supported!")
    char_h = max(16, char_h)
    return (char_w, char_h)

  def build_boxes(self):
    #dc = wx.GraphicsContext.CreateMeasuringContext() #ClientDC(self)
    dc = create_measuring_context()
    if hasattr(dc,'SetFont'): dc.SetFont(self.txt_font) #  #  XXX Python 3 fix
    char_w, char_h = self.get_char_size(dc)
    x_start = 16
    x_start += self.get_label_width(dc)
    self.char_boxes = [ [] for k_seq in range(self.n_seqs()) ]
    for i_seq in range(self.sequence_length()):
      n_lines = int(math.floor((i_seq-self.start_offset) / self.line_width))
      n_prev_chars = (i_seq - self.start_offset) % self.line_width
      x = x_start + (char_w * n_prev_chars)
      y_start = self.get_line_sep() + (n_lines * self.get_line_spacing())
      for k_seq in range(self.n_seqs()):
        v_offset = k_seq * self.line_height
        y = y_start + v_offset
        self.char_boxes[k_seq].append((x, y, x + char_w - 1, y + char_h - 1))

  def get_char_position(self, k_seq, i_seq):
    if i_seq >= len(self.char_boxes[k_seq]):
      print(i_seq, len(self.char_boxes[k_seq]))
    return tuple(self.char_boxes[k_seq][i_seq])

  def get_contiguous_ranges(self, i_start, i_end):
    assert (i_start < i_end) or (i_start == i_end)
    (char_w, char_h) = self.get_char_size()
    line_start = int(math.floor((i_start-self.start_offset) / self.line_width))
    line_end = int(math.floor((i_end - self.start_offset) / self.line_width))
    ranges = []
    seg_start = i_start
    while line_start < line_end :
      seg_end = ((line_start + 1) * self.line_width) - 1
      ranges.append((seg_start, seg_end))
      line_start += 1
      seg_start = seg_end + 1
    ranges.append((seg_start, i_end))
    return ranges

  def get_selected_ranges(self):
    ranges = []
    last_start = None
    last_end = None
    for i_seq, selected in enumerate(self.selected_residues):
      if self.selected_residues[i_seq] :
        if last_end is not None :
          if last_end < (i_seq - 1):
            ranges.append((last_start, last_end))
            last_start = i_seq
        else :
          last_start = i_seq
        last_end = i_seq
      elif last_end is not None :
        ranges.append((last_start, last_end))
        last_start = None
        last_end = None
    if last_end is not None :
      ranges.append((last_start, last_end))
    return ranges

  def is_on_char(self, x, y):
    return None # TODO

  def clear_highlights(self):
    self.highlights = []
    self.highlight_colors = []

  def highlight_char(self, i_seq, color=(255,0,0)):
    if i_seq in self.highlights :
      i = self.highlights.index(i_seq)
      self.highlights.pop(i)
      self.highlight_colors.pop(i)
    self.highlights.append(i_seq)
    self.highlight_colors.append(color)

  def set_highlights(self, indices, **kwds):
    for i_seq in indices :
      self.highlight_char(i_seq, **kwds)

  def clear_selection(self):
    self.selected_residues = [False] * self.sequence_length()
    self.update_frame()

  def select_chars(self, i_start, i_end, box=True):
    assert (i_end < self.sequence_length()) and (i_start <= i_end)
    for i_seq in range(i_start, i_end + 1):
      self.selected_residues[i_seq] = box
    self.update_frame()

  def update_frame(self):
    frame = self.GetParent().GetParent()
    frame.callback_on_select()

  def get_selection_info(self):
    ranges = self.get_selected_ranges()
    inc = self.resseq_offset + 1
    if len(ranges) == 0 :
      txt = ""
    elif len(ranges) == 1 and ranges[0][0] == ranges[0][1] :
      txt = "SELECTED: residue %d" % (ranges[0][0] + inc)
    else :
      txt_ranges = []
      for (x, y) in ranges :
        if x == y : txt_ranges.append(str(x+inc))
        else : txt_ranges.append("%d-%d" % (x+inc, y+inc))
      txt = "SELECTED: residues %s" % ", ".join(txt_ranges)
    return txt

  def get_atom_selection(self):
    ranges = self.get_selected_ranges()
    inc = self.resseq_offset + 1
    if len(ranges) == 0 :
      return None
    elif len(ranges) == 1 and ranges[0][0] == ranges[0][1] :
      return "(resseq %d)" % (ranges[0][0] + inc)
    else :
      resseqs = []
      for (x, y) in ranges :
        if x == y : resseqs.append("resseq %d" % (x + inc))
        else : resseqs.append("resseq %d:%d" % (x+inc, y+inc))
      return "(" + " or ".join(resseqs) + ")"

  def deselect_chars(self, i_start, i_end):
    self.select_chars(i_start, i_end, False)

  def select_residue(self, x, y):
    for k_seq in range(self.n_seqs()):
      for i_seq, box in enumerate(self.char_boxes[k_seq]):
        if (self.sequences[k_seq][i_seq] == '-'):
          continue
        (x1, y1, x2, y2) = box
        if (x > x1 and x < x2) and (y > y1 and y < y2):
          if self._style & WXTBX_SEQ_SELECT_RANGE :
            self.process_range_selection(i_seq)
          else :
            if self.selected_residues[i_seq] :
              self.selected_residues[i_seq] = False
            else :
              self.selected_residues[i_seq] = True
          self.update_frame()
          return True
    return False

  def process_range_selection(self, i_seq):
    n_selected = self.selected_residues.count(True)
    if n_selected == 0 :
      self.selected_residues[i_seq] = True
    elif n_selected == 1 :
      j_seq = self.selected_residues.index(True)
      if j_seq != i_seq :
        for k_seq in range(min(i_seq, j_seq), max(i_seq+1,j_seq)):
          self.selected_residues[k_seq] = True
    else :
      self.clear_selection()
      self.selected_residues[i_seq] = True

  def OnClear(self, event):
    self.clear_selection()
    self.Refresh()

  def OnHelp(self, event):
    self.enable_tooltip(True)

  #---------------------------------------------------------------------
  # MOUSE EVENTS
  def clear_mouse(self):
    self._last_x = None
    self._last_y = None

  def record_mouse(self, x, y):
    self._last_x = None
    self._last_y = None

  def OnDoubleClick(self, event):
    (x, y) = (event.GetX(), event.GetY())

  def OnLeftUp(self, event):
    (x, y) = (event.GetX(), event.GetY())

  def OnLeftDown(self, event):
    (x, y) = (event.GetX(), event.GetY())

  def OnRightDown(self, event):
    (x, y) = (event.GetX(), event.GetY())

  def OnRightUp(self, event):
    (x, y) = (event.GetX(), event.GetY())

#-----------------------------------------------------------------------
class sequence_with_structure_panel(sequence_panel):
  tooltip = """\
Double-click on any residue or secondary-structure element to select the \
residue(s).  Holding down shift enables multiple selections."""
  line_sep = 64

  def __init__(self, *args, **kwds):
    sequence_panel.__init__(self, *args, **kwds)
    self.structure = ""
    self.selected_helices = []
    self.selected_strands = []
    self.selected_linkers = []
    self.selected_missing = []

  def paint(self, gc):
    self.paint_sequence(gc)
    self.paint_structure(gc)

  def paint_structure(self, gc):
    helices = self.get_helices()
    if self._style & WXTBX_SEQ_FANCY_HELICES :
      helix_pen = wx.Pen('red', 1)
      h_helix_pen = wx.Pen((255,50,50), 2)
      for k, (i_start, i_end) in enumerate(helices):
        if k in self.selected_helices :
          color_inner_start = (255, 220, 220)
          color_inner_end = (255, 240, 240)
          color_outer_start = (255, 170, 170)
          color_outer_end = (255, 220, 220)
          gc.SetPen(h_helix_pen)
        else :
          color_inner_start = (255, 150, 150)
          color_inner_end = (255, 200, 200)
          color_outer_start = (255, 100, 100)
          color_outer_end = (255, 150, 150)
          gc.SetPen(helix_pen)
        bounds = self.get_region_bounds(i_start, i_end)
        for box in bounds :
          (x1, y1, x2, y2) = box
          strips = make_helix(x1 - 1, y1, x2, y2)
          def draw_strip(strip, brush):
            gc.PushState()
            gc.SetBrush(brush) #wx.Brush(strip_color))
            path = gc.CreatePath()
            path.MoveToPoint(strip[0][0], strip[0][1])
            for x, y in strip[1:] :
              path.AddLineToPoint(x, y)
            path.CloseSubpath()
            gc.FillPath(path)
            gc.StrokePath(path)
            gc.PopState()
          inner_brush = gc.CreateLinearGradientBrush(x1-1, y1-2, x1-1, y2+2,
            color_inner_start, color_inner_end)
          for i, strip in enumerate(strips):
            if (i % 2) == 0 :
              draw_strip(strip, inner_brush)
          outer_brush = gc.CreateLinearGradientBrush(x1-1, y1-2, x1-1, y2+2,
            color_outer_start, color_outer_end)
          for i, strip in enumerate(strips):
            if (i % 2) == 1 :
              draw_strip(strip, outer_brush)
        gc.SetPen(helix_pen)
    else :
      helix_pen = wx.Pen('red', 1)
      h_helix_pen = wx.Pen((255,50,50), 2)
      for k, (i_start, i_end) in enumerate(helices):
        bounds = self.get_region_bounds(i_start, i_end)
        if k in self.selected_helices :
          color_start = (200, 100, 100)
          color_end = (255, 200, 200)
          gc.SetPen(h_helix_pen)
        else :
          color_start = (255, 50, 50)
          color_end = (255, 150, 150)
          gc.SetPen(helix_pen)
        for box in bounds :
          (x1, y1, x2, y2) = box
          helix_brush = gc.CreateLinearGradientBrush(x1 - 1, y1, x1 - 1, y2,
            color_start, color_end)
          gc.SetBrush(helix_brush)
          gc.DrawRoundedRectangle(x1 - 1, y1, x2 - x1 + 1, 16, 4)
        gc.SetPen(helix_pen)
    strands = self.get_strands()
    strand_pen = wx.Pen((0, 100, 255), 2)
    h_strand_pen = wx.Pen('blue', 2)
    for k, (i_start, i_end) in enumerate(strands):
      color_start = (0, 100, 255)
      color_end = (50, 200, 255)
      bounds = self.get_region_bounds(i_start, i_end)
      if k in self.selected_strands :
        color_start = (0, 200, 200)
        color_end = (50, 255, 255)
        gc.SetPen(h_strand_pen)
      else :
        gc.SetPen(strand_pen)
      for j, box in enumerate(bounds):
        (x1, y1, x2, y2) = box
        strand_brush = gc.CreateLinearGradientBrush(x1, y1 + 4, x1, y2-4,
          color_start, color_end)
        gc.SetBrush(strand_brush)
        if j == (len(bounds) - 1):
          segments = strand_as_arrow(x1, y1, x2, y2)
        else :
          segments = strand_as_box(x1, y1, x2, y2)
        line = gc.CreatePath()
        line.MoveToPoint(segments[0][0], segments[0][1])
        for segment in segments[1:] :
          line.AddLineToPoint(segment[0], segment[1])
        line.CloseSubpath()
        gc.PushState()
        gc.StrokePath(line)
        gc.FillPath(line)
        gc.PopState()
      gc.SetPen(strand_pen)
    missing = self.get_missing()
    if (wx.Platform == '__WXGTK__') : # dashed pen freezes on Linux
      missing_pen = wx.Pen((150, 150, 150), 4)
    elif (wx.Platform in ['__WXMAC__', '__WXMSW__']):
      missing_pen = wx.Pen((150, 150, 150), 4, style=wx.SHORT_DASH)
    h_missing_pen = wx.Pen((255, 255, 0), 12)
    for k, (i_start, i_end) in enumerate(missing):
      bounds = self.get_region_bounds(i_start, i_end)
      for j, box in enumerate(bounds):
        (x1, y1, x2, y2) = box
        line = gc.CreatePath()
        line.MoveToPoint(x1, y1 + 8)
        line.AddLineToPoint(x2, y1 + 8)
        line.CloseSubpath()
        if k in self.selected_missing :
          gc.PushState()
          gc.SetPen(h_missing_pen)
          gc.StrokePath(line)
          gc.PopState()
        gc.PushState()
        gc.SetPen(missing_pen)
        gc.StrokePath(line)
        gc.PopState()
    other = self.get_linkers()
    other_pen = wx.Pen((0,0,0), 4)
    h_other_pen = wx.Pen((255, 255, 0), 12)
    for k, (i_start, i_end) in enumerate(other):
      bounds = self.get_region_bounds(i_start, i_end)
      for j, box in enumerate(bounds):
        (x1, y1, x2, y2) = box
        line = gc.CreatePath()
        line.MoveToPoint(x1, y1 + 8)
        line.AddLineToPoint(x2, y1 + 8)
        line.CloseSubpath()
        if k in self.selected_linkers :
          gc.PushState()
          gc.SetPen(h_other_pen)
          gc.StrokePath(line)
          gc.PopState()
        gc.PushState()
        gc.SetPen(other_pen)
        gc.StrokePath(line)
        gc.PopState()

  def get_line_sep(self):
    #if (self.structure == ""):
    #  return sequence_panel.line_sep
    return self.line_sep

  def set_structure(self, ss):
    self.structure = "".join(ss.splitlines())
    assert ((self.sequence_length() == 0) or
            (len(self.structure) == self.sequence_length()))
    self.clear_highlights()
    self.clear_structure_selections()
    self.InvalidateBestSize()

  def apply_missing_residue_highlights(self):
    ranges = self.get_missing()
    for i_start, i_end in ranges :
      for i_seq in range(i_start, i_end + 1):
        self.highlights.append(i_seq)
        self.highlight_colors.append((150,150,150))

  def get_region_bounds(self, i_start, i_end):
    (char_w, char_h) = self.get_char_size()
    ranges = self.get_contiguous_ranges(i_start, i_end)
    boxes = []
    for (seg_start, seg_end) in ranges :
      (x1, y1, nx, ny) = self.get_char_position(0, seg_start)
      y1 -= 24
      (nx, y2, x2, ny) = self.get_char_position(0, seg_end)
      y2 -= 8
      boxes.append((x1, y1, x2, y2))
    return boxes

  def get_sec_str_motif(self, code):
    sections = []
    current_start = None
    for i, char in enumerate(self.structure):
      if char == code :
        if current_start is None :
          current_start = i
      else :
        if current_start is not None :
          sections.append((current_start, i-1))
          current_start = None
    if current_start is not None :
      sections.append((current_start, len(self.structure) - 1))
    return sections

  def get_helices(self):
    return self.get_sec_str_motif('H')

  def get_strands(self):
    return self.get_sec_str_motif('S')

  def get_linkers(self):
    return self.get_sec_str_motif('L')

  def get_missing(self):
    return self.get_sec_str_motif('X')

  def get_region_by_id(self, code, idx):
    sections = self.get_sec_str_motif(code)
    if idx < len(sections):
      return sections[idx]

  def is_on_helix(self, x, y):
    return self.is_on_region(x, y, self.get_helices(), tolerance=2)

  def is_on_strand(self, x, y):
    return self.is_on_region(x, y, self.get_strands())

  def is_on_linker(self, x, y):
    return self.is_on_region(x, y, self.get_linkers(), tolerance=-2)

  def is_on_missing(self, x, y):
    return self.is_on_region(x, y, self.get_missing(), tolerance=-2)

  def is_on_region(self, x, y, regions, tolerance=0):
    for k, (i_start, i_end) in enumerate(regions):
      bounds = self.get_region_bounds(i_start, i_end)
      for (x1, y1, x2, y2) in bounds :
        if ((x > x1 and x < x2) and
            (y > (y1-tolerance) and y < (y2+tolerance))):
          return k
    return None

  def clear_structure_selections(self):
    self.selected_helices = []
    self.selected_strands = []
    self.selected_linkers = []
    self.selected_missing = []

  def select_helix(self, x, y):
    idx = self.is_on_helix(x, y)
    if idx is not None :
      (helix_start, helix_end) = self.get_region_by_id('H', idx)
      if not idx in self.selected_helices :
        #print "helix %d" % idx
        self.selected_helices.append(idx)
        self.select_chars(helix_start, helix_end)
      else :
        self.selected_helices.remove(idx)
        self.deselect_chars(helix_start, helix_end)
      return True
    return False

  def select_strand(self, x, y):
    idx = self.is_on_strand(x, y)
    if idx is not None :
      (strand_start, strand_end) = self.get_region_by_id('S', idx)
      if not idx in self.selected_strands :
        #print "strand %d" % idx
        self.selected_strands.append(idx)
        self.select_chars(strand_start, strand_end)
      else :
        self.selected_strands.remove(idx)
        self.deselect_chars(strand_start, strand_end)
      return True
    return False

  def select_linker(self, x, y):
    idx = self.is_on_linker(x, y)
    if idx is not None :
      (linker_start, linker_end) = self.get_region_by_id('L', idx)
      if not idx in self.selected_linkers :
        #print "linker %d" % idx
        self.selected_linkers.append(idx)
        self.select_chars(linker_start, linker_end)
      else :
        self.selected_linkers.remove(idx)
        self.deselect_chars(linker_start, linker_end)
      return True
    return False

  def select_missing(self, x, y):
    if not (self._style & WXTBX_SEQ_ENABLE_SELECT_MISSING):
      return False
    idx = self.is_on_missing(x, y)
    if idx is not None :
      (region_start, region_end) = self.get_region_by_id('X', idx)
      if not idx in self.selected_missing :
        #print "missing segment %d" % idx
        self.selected_missing.append(idx)
        self.select_chars(region_start, region_end)
      else :
        self.selected_missing.remove(idx)
        self.deselect_chars(region_start, region_end)
      return True
    return False

  def process_click(self, x, y, shift_down=False):
    if not (self._style & WXTBX_SEQ_SELECT_MULTIPLE):
      if (self._style & WXTBX_SEQ_SELECT_ANY) and shift_down :
        pass
      else :
        self.clear_structure_selections()
        if not (self._style & WXTBX_SEQ_SELECT_RANGE):
          self.clear_selection()
    if self.select_residue(x, y):
      pass
    elif (self._style & WXTBX_SEQ_ENABLE_SELECT_STRUCTURE):
      if (self._style & WXTBX_SEQ_SELECT_RANGE):
        self.clear_structure_selections()
        self.clear_selection()
      if self.select_helix(x, y):
        pass
      elif self.select_strand(x, y):
        pass
      elif self.select_linker(x, y):
        pass
      elif self.select_missing(x, y):
        pass
      else :
        self.clear_structure_selections()
        self.clear_selection()
    self.Refresh()
    print(self.get_selected_ranges())

  def OnDoubleClick(self, event):
    (x, y) = (event.GetX(), event.GetY())
    self.process_click(x, y, event.ShiftDown())

  def OnClear(self, event):
    self.clear_structure_selections()
    sequence_panel.OnClear(self, event)

def strand_as_arrow(x1, y1, x2, y2):
  segments = []
  segments.append((x1, y1 + 4))
  segments.append((x2 - 7, y1 + 4))
  segments.append((x2 - 7, y1))
  segments.append((x2, y1 + 8))
  segments.append((x2 - 7, y2))
  segments.append((x2 - 7, y2 - 4))
  segments.append((x1, y2 - 4))
  return segments

def strand_as_box(x1, y1, x2, y2):
  segments = []
  segments.append((x1, y1 + 4))
  segments.append((x2, y1 + 4))
  segments.append((x2, y2 - 4))
  segments.append((x1, y2 - 4))
  return segments

def make_helix(x1, y1, x2, y2, strip_width=10, strip_height=20):
  y_center = y1 + ((y2 - y1) / 2)
  x_start = x1
  strips = []
  strips.append(((x_start, y_center),
                 (x_start + strip_width, y_center),
                 (x_start + (strip_width * 1.5), y_center + (strip_height/2)),
                 (x_start + (strip_width * 0.5), y_center + (strip_height/2))))
  x_start += (strip_width * 0.5)
  y_start = y_center + (strip_height / 2)
  y_end = y_center - (strip_height / 2)
  while x_start < (x2 - (strip_width * 1.5)):
    strips.append(((x_start, y_start),
                   (x_start + strip_width, y_start),
                   (x_start + (strip_width * 2), y_end),
                   (x_start + strip_width, y_end)))
    x_start += strip_width
    y_tmp = y_start
    y_start = y_end
    y_end = y_tmp
  if x_start < (x2 - strip_width):
    strips.append(((x_start, y_start),
                   (x_start + strip_width, y_start),
                   (x_start + (strip_width * 1.5), y_center),
                   (x_start + (strip_width * 0.5), y_center)))
  return strips

########################################################################
class control_panel(wx.Panel):
  def __init__(self, *args, **kwds):
    wx.Panel.__init__(self, *args, **kwds)
    szr = wx.BoxSizer(wx.VERTICAL)
    self.SetSizer(szr)
    box = wx.BoxSizer(wx.HORIZONTAL)
    box.Add(wx.StaticText(self, -1, "Select chain:"), 0, wx.ALL, 5)
    self.chain_select = wx.Choice(self, -1)
    box.Add(self.chain_select, 0, wx.ALL, 5)
    self.clear_btn = wx.Button(self, -1, "Clear selection")
    box.Add(self.clear_btn, 0, wx.ALL|wx.ALIGN_CENTER_VERTICAL, 5)
    self.help_btn = wx.Button(self, wx.ID_HELP)
    box.Add(self.help_btn, 0, wx.ALL|wx.ALIGN_CENTER_VERTICAL, 5)
    szr.Add(box)
    szr.Fit(self)

  def bind_events(self, frame, view):
    self.Bind(wx.EVT_BUTTON, view.OnClear, self.clear_btn)
    self.Bind(wx.EVT_BUTTON, view.OnHelp, self.help_btn)
    self.Bind(wx.EVT_CHOICE, frame.OnSelectChain, self.chain_select)
    self.Bind(wx.EVT_BUTTON, frame.OnHelp, self.help_btn)

# XXX keep this general so it can be embedded in other windows
class sequence_window(object):
  cp_style = wx.NO_BORDER
  seq_panel_style = WXTBX_SEQ_DEFAULT_STYLE
  def create_main_panel(self, sizer=None):
    if sizer is None :
      sizer = self.sizer
    outer_panel = wx.lib.scrolledpanel.ScrolledPanel(self, -1)
    szr2 = wx.BoxSizer(wx.VERTICAL)
    outer_panel.SetSizer(szr2)
    panel = sequence_with_structure_panel(outer_panel, -1)
    panel.SetStyle(self.seq_panel_style)
    szr2.Add(panel, 1, wx.EXPAND)
    szr2.Layout()
    szr2.Fit(outer_panel)
    sizer.Add(outer_panel, 1, wx.EXPAND)
    outer_panel.SetupScrolling()
    self.seq_panel = panel
    self.outer_panel = outer_panel
    if getattr(self, "control_panel", None) is not None :
      self.control_panel.bind_events(self, self.seq_panel)

  def create_control_panel(self, sizer=None):
    if sizer is None :
      sizer = self.sizer
    cp = control_panel(self, -1, style=self.cp_style)
    sizer.Add(cp, 0, wx.EXPAND)
    self.control_panel = cp
    if getattr(self, "seq_panel", None) is not None :
      self.control_panel.bind_events(self, self.seq_panel)

  def load_pdb_file(self, file_name, ignore_unk=False):
    import iotbx.pdb
    pdb_in = iotbx.pdb.input(file_name)
    pdb_hierarchy = pdb_in.construct_hierarchy()
    pdb_hierarchy.atoms().reset_i_seq()
    self.set_pdb_data(pdb_hierarchy, ignore_unk=ignore_unk)

  def set_pdb_data(self, pdb_hierarchy, ignore_unk=False):
    from mmtbx import secondary_structure
    sec_str = secondary_structure.manager(pdb_hierarchy)
    sec_str.show_summary()
    self.set_data(
      pdb_hierarchy=pdb_hierarchy,
      sec_str=sec_str,
      auto_select=True,
      ignore_unk=ignore_unk)

  def set_data(self, pdb_hierarchy, sec_str, auto_select=True,
                ignore_unk=False, verbose=False):
    self.pdb_hierarchy = pdb_hierarchy
    self.sec_str = sec_str
    self._chain_cache = {}
    self._seq_cache = {}
    self._ss_cache = {}
    for chain in pdb_hierarchy.models()[0].chains():
      if (ignore_unk):
        segids = chain.atoms().extract_segid()
        if (segids.all_eq('UNK ')):
          if (verbose):
            print("Skipping unknown residues in chain %s" % chain.id)
          continue
      conf = chain.conformers()[0]
      if not conf.is_protein():
        if (verbose):
          print("Skipping non-protein chain %s" % chain.id)
        continue
      if chain.id in self._chain_cache :
        n = 2
        while True :
          new_id = "%s (%d)" % (chain.id, n)
          if not (new_id in self._chain_cache):
            self._chain_cache[new_id] = chain
            break
          n += 1
      else :
        self._chain_cache[chain.id] = chain
    self.control_panel.chain_select.SetItems(sorted(self._chain_cache.keys()))
    self.control_panel.Layout()
    if auto_select :
      self.control_panel.chain_select.SetSelection(0)
      chain_id = str(self.control_panel.chain_select.GetStringSelection())
      self.set_current_chain(chain_id)

  def set_current_chain(self, chain_id):
    chain = self._chain_cache.get(chain_id, None)
    if chain is not None :
      chain_conf = chain.conformers()[0]
      if chain_id in self._seq_cache :
        seq = self._seq_cache[chain_id]
        ss = self._ss_cache[chain_id]
      else :
        helix_sele = self.sec_str.helix_selection()
        sheet_sele = self.sec_str.beta_selection()
        seq = chain_conf.as_padded_sequence()
        ss = chain_conf.as_sec_str_sequence(helix_sele, sheet_sele)
        self._seq_cache[chain_id] = seq
        self._ss_cache[chain_id] = ss
      offset = 0
      n_res = len(seq)
      while (offset < n_res):
        if (seq[0:50] == "X"*50):
          seq = seq[50:]
          ss = ss[50:]
        else :
          # print "seq:", seq[offset:offset+50]
          break
        offset += 50
      self.set_sequence(seq, resseq_offset=offset)
      self.set_structure(ss)
      self.reset_layout()
      self.seq_panel.Refresh()

  def set_chain_sequence_data(self, data):
    assert isinstance(data, list)
    assert ((len(data) == 0) or (type(data[0]).__name__ == "chain"))
    self._seq_data = data
    ids = [ chain.chain_id for chain in data ]
    self.control_panel.chain_select.SetItems(ids)
    if (len(ids) > 0):
      self.set_current_alignment(0)

  def set_current_alignment(self, index):
    assert (index < len(self._seq_data))
    chain = self._seq_data[index]
    seqs = chain.get_alignment(include_sec_str=True)
    self.set_sequences([seqs[0], seqs[1]], labels=["PDB", "sequence"])
    self.set_structure(seqs[2])
    self.reset_layout()
    self.seq_panel.Refresh()

  def set_sequence(self, *args, **kwds):
    self.seq_panel.set_sequence(*args, **kwds)

  def set_sequences(self, *args, **kwds):
    self.seq_panel.set_sequences(*args, **kwds)

  def set_sequence_labels(self, *args, **kwds):
    self.seq_panel.set_sequence_labels(*args, **kwds)

  def reset_layout(self):
    pass

  def set_structure(self, sec_str):
    self.seq_panel.set_structure(sec_str)
    self.seq_panel.apply_missing_residue_highlights()

  def get_selection_base(self):
    chain_id = str(self.control_panel.chain_select.GetStringSelection())
    return "chain '%s'" % chain_id

  def callback_on_select(self):
    pass

  def OnSelectChain(self, evt):
    if (getattr(self, "_seq_data", None) is not None):
      self.set_current_alignemnt(evt.GetEventObject().GetSelection())
    else :
      chain_id = str(evt.GetEventObject().GetStringSelection())
      self.set_current_chain(chain_id)

  def OnClose(self, evt):
    self.Destroy()

  def OnDestroy(self, evt):
    pass

  def OnHelp(self, evt):
    pass

class sequence_frame_mixin(wx.Frame):
  cp_style = wx.SIMPLE_BORDER
  def __init__(self, *args, **kwds):
    wx.Frame.__init__(self, *args, **kwds)
    szr = wx.BoxSizer(wx.VERTICAL)
    self.SetSizer(szr)
    self.sizer = szr
    self.create_main_panel()
    self.create_control_panel()
    self.statusbar = self.CreateStatusBar()
    self.Bind(wx.EVT_CLOSE, self.OnClose)
    self.Bind(wx.EVT_WINDOW_DESTROY, self.OnDestroy)
    self._chain_cache = []
    self._selection_callback = None

  def reset_layout(self):
    self.seq_panel.Layout()
    self.outer_panel.Layout()
    self.sizer.Layout()
    (w, h) = self.seq_panel.DoGetBestSize()
    (w2, h2) = self.control_panel.GetSize()
    if w <= 750 and h <= 550 :
      self.outer_panel.SetMinSize((w,h))
      self.SetSize((w+50, h+h2+50))
    else :
      self.SetSize((800,600))

class sequence_frame(sequence_frame_mixin, sequence_window):
  def callback_on_select(self):
    txt = self.seq_panel.get_selection_info()
    self.statusbar.SetStatusText(txt)

class msa_frame(sequence_frame_mixin, sequence_window):
  seq_panel_style = WXTBX_SEQ_SHOW_SELECTIONS | \
                    WXTBX_SEQ_SHOW_LABELS | \
                    WXTBX_SEQ_ENABLE_SELECT_STRUCTURE | \
                    WXTBX_SEQ_ENABLE_SELECT_MISSING | \
                    WXTBX_SEQ_FANCY_HELICES | \
                    WXTBX_SEQ_SELECT_SINGLE

class selection_editor_frame(sequence_frame_mixin, sequence_window):
  seq_panel_style = WXTBX_SEQ_DEFAULT_STYLE | WXTBX_SEQ_SELECT_ANY

#-----------------------------------------------------------------------
def run(args):
  pdb_file = args[-1]
  app = wx.App(0)
  frame = sequence_frame(None, -1, "Sequence display for %s" %
    os.path.basename(pdb_file))
  frame.load_pdb_file(pdb_file)
  if wx.Platform == '__WXMAC__' :
    frame.Fit()
  frame.Show()
  if "--range" in args :
    frame.seq_panel.SetStyle(WXTBX_SEQ_DEFAULT_STYLE|WXTBX_SEQ_SELECT_RANGE)
  app.MainLoop()

def run_test():
  app = wx.App(0)
  exercise_simple_frame()
  app.MainLoop()

def exercise_simple_frame():
  frame = sequence_frame(None, -1, "Demo of sequence display")
  frame.set_sequence(("X" * 5) + 'VLSEGEWQLVLHVWAKVEADVAGHGQDILIRLFKSHPETLEKFDRFKHLKTEAEMKASEDLKKHGVTVLTALGAILKKKGHHEAELKPLAQSHATKHKIPIKYLEFISEAIIHVLHSRHPGDFGADAQGAMNKALELFRKDIAAKYKELGYQG', resseq_offset=50)
  frame.set_structure(("X" * 5) + 'LLLHHHHHHHHHHHHHHHHLHHHHHHHHHHHHHHHLHHHHHLLHHHHLLLLHHHHHHLHHHHHHHHHHHHHHHHHHHHLLLLHHHHHHHHHHHHHLLLLLHHHHHHHHHHHHHHHHHHLLLLLLHHHHHHHHHHHHHHHHHHHHHHHHHLLLL')
  frame.reset_layout()
  frame.Show()

__test_seqs = [
  "---VLSEGEW---QLVLHVWAKVEADVAGHGQDILIRLFKSHPESTLEKFDRFKHLKTEAEMKASEDLKKHGVTVLTALGAILKKK------GHHEAELKPLAQSHATKHKIPIKYLEFISEAIIHVLHSRHPGDFGADAQGAMNKALELFRKDIAAKYKELGYQGANQ",
  "------EGEWMRTQLVLHVWAKVEADVAGHGQDILIKLFKSHPE-TLEKFDRFKHLKTEAEMKASEDLKKHGVTVLTALGAILKKKMQVEHNGHHEAELKPLAQSHATKHKIPIKYLEFISEAIIHVLHSRHPGDFGADAQGAMNKALELFRKDIAAKYKELGYQG---",
  "MAVVLSEGEWM--QLVLHVWAKVEADVAGHGQDILIRLFKSHPESTLEKFDRFKHLKTEAEMKASEDLKKHGVTVLTALGAILKKK--VEH-GHHEAELKPLAQSHATKHKIPIKYLEFISEAIIHVLHSRHPGDFGADAQGAMNKALELFRKDIAAKYKEL-------"]
__test_labels = [
    "Protein A (H. sapiens)",
    "Protein B (M. musculus)",
    "Protein C (B. taurus)",]

def exercise_msa_frame():
  frame = msa_frame(None, -1, "Demo of multiple sequence alignment")
  frame.set_sequences(__test_seqs, labels=__test_labels)
  frame.set_structure('------LLLHHHHHHHHHHHHHHHHLHHHHHHHHHHHHHHHLHH-HHHLLHHHHLLLLHHHHHHLHHHHHHHHHHHHHHHHHHHHLLLLLLLLLLHHHHHHHHHHHHHLLLLLHHHHHHHHHHHHHHHHHHLLLLLLHHHHHHHHHHHHHHHHHHHHHHHHHLLLL---')
  frame.reset_layout()
  frame.Show()

def exercise_msa_frame_large():
  frame = msa_frame(None, -1, "Really big sequence alignment")
  seqs = [ s*10 for s in __test_seqs ]
  labels = __test_labels
  frame.set_sequences(seqs, labels=labels)
  frame.reset_layout()
  frame.Show()

def exercise():
  app = wx.App(0)
  exercise_simple_frame()
  exercise_msa_frame()
  exercise_msa_frame_large()
  app.MainLoop()

if __name__ == "__main__" :
#  run_test()
  if "--test" in sys.argv :
    exercise()
  else :
    run(sys.argv[1:])


 *******************************************************************************


 *******************************************************************************
wxtbx/symmetry_dialog.py
from __future__ import absolute_import, division, print_function

from wxtbx.phil_controls import space_group, unit_cell
from wxtbx.utils import add_ok_cancel_buttons
import wxtbx.icons
from libtbx.utils import Sorry, Abort
import wx
from six.moves import zip

class SymmetryDialog(wx.Dialog):
  def __init__(self, *args, **kwds):
    caption = kwds.get("caption",
      "Missing or incomplete symmetry information.  Please enter a space "+
      "group and unit cell.")
    if ("caption" in kwds):
      del kwds['caption']
    super(SymmetryDialog, self).__init__(*args, **kwds)
    style = self.GetWindowStyle()
    style |= wx.WS_EX_VALIDATE_RECURSIVELY|wx.RAISED_BORDER|wx.CAPTION
    self.SetWindowStyle(style)
    szr = wx.BoxSizer(wx.VERTICAL)
    self.SetSizer(szr)
    szr2 = wx.BoxSizer(wx.VERTICAL)
    szr.Add(szr2, 0, wx.ALL|wx.EXPAND, 10)
    caption_sizer = wx.BoxSizer(wx.HORIZONTAL)
    bmp = wx.StaticBitmap(self, -1, wxtbx.icons.symmetry.GetBitmap())
    caption_sizer.Add(bmp, 0, wx.ALIGN_CENTER_VERTICAL|wx.ALL, 5)
    txt = wx.StaticText(self, -1, caption)
    txt.Wrap(480)
    caption_sizer.Add(txt, 0, wx.ALIGN_CENTER_VERTICAL|wx.ALL, 5)
    szr2.Add(caption_sizer, 0, wx.ALL, 0)
    szr3 = wx.FlexGridSizer(rows=3, cols=2)
    szr2.Add(szr3, 0, wx.ALL, 0)
    txt2 = wx.StaticText(self, -1, "Unit cell:")
    self.unit_cell_ctrl = unit_cell.UnitCellCtrl(
      parent=self,
      id=-1,
      size=(300,-1),
      name="Unit cell")
    txt3 = wx.StaticText(self, -1, "Space group:")
    self.space_group_ctrl = space_group.SpaceGroupCtrl(
      parent=self,
      id=-1,
      name="Space group")
    szr3.Add(txt2, 0, wx.ALL|wx.ALIGN_CENTER_VERTICAL, 5)
    szr3.Add(self.unit_cell_ctrl, 0, wx.ALL|wx.ALIGN_CENTER_VERTICAL, 5)
    szr3.Add(txt3, 0, wx.ALL|wx.ALIGN_CENTER_VERTICAL, 5)
    szr3.Add(self.space_group_ctrl, 0, wx.ALL|wx.ALIGN_CENTER_VERTICAL, 5)
    szr3.Add((1,1), 0, wx.ALL, 5)
    load_btn = wx.Button(self, -1, "Load symmetry from file...")
    szr3.Add(load_btn, 0, wx.ALL, 5)
    self.Bind(wx.EVT_BUTTON, self.OnLoadSymmetry, load_btn)
    add_ok_cancel_buttons(self, szr2)
    szr.Layout()
    self.Fit()
    self.Centre(wx.BOTH)

  def SetUnitCell(self, uc):
    self.unit_cell_ctrl.SetValue(uc)

  def SetSpaceGroup(self, sg):
    self.space_group_ctrl.SetValue(sg)

  def SetSymmetry(self, symm):
    if (symm is not None):
      self.SetSpaceGroup(symm.space_group_info())
      self.SetUnitCell(symm.unit_cell())

  def GetSymmetry(self, allow_incomplete=False):
    uc = self.unit_cell_ctrl.GetPhilValue()
    sg = self.space_group_ctrl.GetPhilValue()
    if (not allow_incomplete):
      if (uc is None):
        raise Sorry("Missing unit cell parameters.")
      elif (sg is None):
        raise Sorry("Missing space group.")
    from cctbx import crystal
    symm = crystal.symmetry(
      unit_cell=uc,
      space_group_info=sg)
    return symm

  def OnLoadSymmetry(self, event):
    file_name = wx.FileSelector(
      message="Select a reflection or PDB file containing symmetry",
      flags=wx.FD_OPEN)
    if (file_name != ""):
      from iotbx import crystal_symmetry_from_any
      symm = crystal_symmetry_from_any.extract_from(file_name)
      if (symm is not None):
        space_group = symm.space_group_info()
        if (space_group is not None):
          self.space_group_ctrl.SetSpaceGroup(space_group)
        unit_cell = symm.unit_cell()
        if (unit_cell is not None):
          self.unit_cell_ctrl.SetUnitCell(unit_cell)
      else :
        raise Sorry("This file does not contain valid symmetry information.")

  def OnOkay(self, event):
    print(1)
    if (not self.Validate()):
      pass
    else :
      symm = self.GetSymmetry()
      self.EndModal(wx.ID_OK)

  def OnCancel(self, event):
    self.EndModal(wx.ID_CANCEL)

class SymmetryChoiceDialog(wx.Dialog):
  def __init__(self, *args, **kwds):
    default_caption = "The input data specify multiple unique symmetry "+ \
      "and/or unit cell parameters.  Please select the consensus settings "+\
      "from the menus below."
    caption = kwds.pop("caption", default_caption)
    if (caption is None):
      caption = default_caption
    super(SymmetryChoiceDialog, self).__init__(*args, **kwds)
    style = self.GetWindowStyle()
    style |= wx.WS_EX_VALIDATE_RECURSIVELY|wx.RAISED_BORDER|wx.CAPTION
    self.SetWindowStyle(style)
    szr = wx.BoxSizer(wx.VERTICAL)
    self.SetSizer(szr)
    szr2 = wx.BoxSizer(wx.VERTICAL)
    szr.Add(szr2, 1, wx.ALL|wx.EXPAND, 10)
    caption_sizer = wx.BoxSizer(wx.HORIZONTAL)
    bmp = wx.StaticBitmap(self, -1, wxtbx.icons.symmetry.GetBitmap())
    caption_sizer.Add(bmp, 0, wx.ALIGN_CENTER_VERTICAL|wx.ALL, 5)
    txt = wx.StaticText(self, -1, caption)
    txt.Wrap(480)
    caption_sizer.Add(txt, 0, wx.ALIGN_CENTER_VERTICAL|wx.ALL, 5)
    szr2.Add(caption_sizer, 0, wx.ALL, 0)
    szr3 = wx.BoxSizer(wx.HORIZONTAL)
    txt2 = wx.StaticText(self, -1, "Space group:")
    szr3.Add(txt2, 0, wx.ALIGN_CENTER_VERTICAL|wx.ALL, 5)
    self.space_group_chooser = wx.Choice(self, -1, size=(200,-1))
    szr3.Add(self.space_group_chooser, 0, wx.ALIGN_CENTER_VERTICAL|wx.ALL, 5)
    szr2.Add(szr3, 0, wx.ALL, 5)
    szr4 = wx.BoxSizer(wx.HORIZONTAL)
    txt3 = wx.StaticText(self, -1, "Unit cell:")
    szr4.Add(txt3, 0, wx.ALIGN_CENTER_VERTICAL|wx.ALL, 5)
    self.unit_cell_chooser = wx.Choice(self, -1, size=(400,-1))
    szr4.Add(self.unit_cell_chooser, 0, wx.ALIGN_CENTER_VERTICAL|wx.ALL, 5)
    szr2.Add(szr4, 0, wx.ALL, 5)
    add_ok_cancel_buttons(self, szr2)
    szr.Layout()
    self.Fit()
    self.Centre(wx.BOTH)
    self.unit_cells = []
    self.space_groups = []

  def SetUnitCells(self, unit_cells, source_info=None):
    assert (source_info is None) or (len(source_info) == len(unit_cells))
    self.unit_cells = unit_cells
    if (source_info is None):
      choices = [ "%g %g %g %g %g %g" % uc.parameters() for uc in unit_cells ]
    else :
      choices = [ "%s (%s)" % ("%g %g %g %g %g %g" % uc.parameters(), si)
         for (uc, si) in zip(unit_cells, source_info) ]
    self.unit_cell_chooser.SetItems(choices)

  def SetSpaceGroups(self, space_groups, source_info=None):
    assert (source_info is None) or (len(source_info) == len(space_groups))
    self.space_groups = space_groups
    if (source_info is None):
      choices = [ str(sg) for sg in space_groups ]
    else :
      choices = [ "%s (%s)" % (str(sg), si)
                  for (sg, si) in zip(space_groups, source_info) ]
    self.space_group_chooser.SetItems(choices)

  def GetUnitCell(self):
    if (len(self.unit_cells) == 0) : return None
    sel = self.unit_cell_chooser.GetSelection()
    return self.unit_cells[sel]

  def GetSpaceGroup(self):
    if (len(self.space_groups) == 0) : return None
    sel = self.space_group_chooser.GetSelection()
    return self.space_groups[sel]

def get_unique_symmetry(
    space_groups=(),
    unit_cells=(),
    sg_source_info=None,
    uc_source_info=None,
    parent=None,
    caption=None):
  assert (len(space_groups) > 0) or (len(unit_cells) > 0)
  non_unique = False
  for i_cell, uc in enumerate(unit_cells):
    j_cell = i_cell + 1
    while (j_cell < len(unit_cells)):
      if (not uc.is_similar_to(unit_cells[j_cell])):
        non_unique = True
        break
      j_cell += 1
  for i_sg, sg in enumerate(space_groups):
    j_sg = i_sg + 1
    sg_number = sg.group().type().number()
    while (j_sg < len(space_groups)):
      other_number = space_groups[j_sg].group().type().number()
      if (sg_number != other_number):
        non_unique = True
        break
      j_sg += 1
  final_cell = final_group = None
  if (non_unique):
    dlg = SymmetryChoiceDialog(parent=parent,
      title="Select unit cell and/or space group",
      caption=caption)
    dlg.SetUnitCells(unit_cells=unit_cells, source_info=uc_source_info)
    dlg.SetSpaceGroups(space_groups=space_groups, source_info=sg_source_info)
    if (dlg.ShowModal() == wx.ID_OK):
      final_cell = dlg.GetUnitCell()
      final_group = dlg.GetSpaceGroup()
    wx.CallAfter(dlg.Destroy)
    if (final_cell is None) and (final_group is None):
      raise Abort()
  else :
    final_cell = unit_cells[0]
    final_group = space_groups[0]
  from cctbx import crystal
  return crystal.symmetry(
    unit_cell=final_cell,
    space_group_info=final_group)

if (__name__ == "__main__"):
  app = wx.App(0)
  dlg = SymmetryDialog(None, -1, "Enter symmetry")
  dlg.SetSpaceGroup("P21")
  if (dlg.ShowModal() == wx.ID_OK):
    symm = dlg.GetSymmetry()
    assert (symm.space_group_info() is not None)
    assert (symm.unit_cell() is not None)
  wx.CallAfter(dlg.Destroy)
  from cctbx import uctbx, sgtbx
  unit_cells = [
    uctbx.unit_cell((10,20,30,90,90,90)),
    uctbx.unit_cell((11,21,29,90.05,90.2,89.8)),
  ]
  source_info = [ "File 1", "File 2" ]
  space_groups = [sgtbx.space_group_info("P21"), sgtbx.space_group_info("P1")]
  symm = get_unique_symmetry(
    space_groups=space_groups,
    unit_cells=unit_cells,
    sg_source_info=source_info,
    uc_source_info=source_info)
  symm.show_summary()


 *******************************************************************************


 *******************************************************************************
wxtbx/tables.py

"""
Various tools and controls for displaying tabular data.
"""

from __future__ import absolute_import, division, print_function
import wxtbx.plots
import wx
import sys

class TableView(wx.ListCtrl):
  """
  Table display using wx.ListCtrl in combination with iotbx.data_plots.
  """
  def __init__(self, *args, **kwds):
    style = kwds.get("style", 0)
    if (not style & wx.LC_REPORT):
      style = style | wx.LC_REPORT
      kwds['style'] = style
    super(TableView, self).__init__(*args, **kwds)
    self._table = None

  def SetTable(self, table):
    self._table = table
    w, h = self.GetSize()
    rows = self._table.export_rows()
    labels = rows[0]
    col_width = ((w - 20) / len(labels))
    for i_lab, label in enumerate(labels):
      self.InsertColumn(i_lab, label)
      self.SetColumnWidth(i_lab, col_width)
    for row in rows[1:] :
      assert len(row) == len(labels), labels
      idx = self.InsertStringItem(sys.maxunicode, row[0])
      for i, cell in enumerate(row[1:]):
        self.SetStringItem(idx, i+1, cell)

  def OnViewGraphs(self, evt):
    """
    Open a wxtbx.plots.loggraph_frame window with the table.
    """
    assert hasattr(self._table, "get_graph")
    graph_frame = wxtbx.plots.loggraph(
      parent=self.GetParent(),
      title=self._table.title,
      tables=[self._table])
    graph_frame.Show()

# TESTING
if (__name__ == "__main__"):
  from iotbx import data_plots
  table = data_plots.table_data(
    title = "Resolution shell statistics",
    column_labels = ["1/resol^2", "Nrefl", "R-free", "FOM"],
    graph_names = ["R-free vs. resolution", "FOM vs. resolution"],
    graph_columns = [[0,2], [0,3]],
    data = [[0.02, 0.04, 0.06, 0.08, 0.10],
            [2004, 2084, 2037, 1949, 1783],
            [0.25, 0.23, 0.27, 0.28, 0.38],
            [0.89, 0.88, 0.83, 0.75, None]])
  app = wx.App(0)
  frame = wx.Frame(parent=None, title="Test frame", size=(600,280))
  panel = wx.Panel(parent=frame)
  ctrl = TableView(panel, pos=(10,10), size=(580,180))
  ctrl.SetTable(table)
  btn = wx.Button(parent=panel, label="Show graphs", pos=(10,210))
  frame.Bind(wx.EVT_BUTTON, ctrl.OnViewGraphs, btn)
  frame.Show()
  app.MainLoop()


 *******************************************************************************


 *******************************************************************************
wxtbx/utils.py

from __future__ import absolute_import, division, print_function
from libtbx import object_oriented_patterns as oop
from libtbx.utils import to_unicode
import wx.lib.colourselect
import wx

UNICODE_BUILD = (wx.PlatformInfo[2] == 'unicode')

class SettingsToolBase(object):
  def __init__(self, *args, **kwds):
    self.parent = self.GetParent()
    self.settings = self.parent.settings
    self._controls = {}
    assert hasattr(self.parent, "update_settings")

  def add_controls(self):
    raise NotImplementedError()

  def get_control(self, name):
    return self._controls.get(name, oop.null())

  def create_controls(self,
                       setting,
                       label,
                       captions=None,
                       min=-2147483647,
                       max=2147483647):
    panel = self.panel
    value = getattr(self.settings, setting)
    ctrls = []
    if isinstance(value, bool):
      box = wx.CheckBox(panel, -1, label)
      self._controls[setting] = box
      box.SetValue(value)
      ctrls.append(box)
      self.Bind(wx.EVT_CHECKBOX,
        lambda evt: self.update_values(evt, setting),
        box)
    elif isinstance(value, int) and (captions is None):
      txt = wx.StaticText(panel, -1, label)
      ctrls.append(txt)
      spinctrl = wx.SpinCtrl(panel, -1)
      spinctrl.SetValue(value)
      spinctrl.SetRange(min, max)
      self._controls[setting] = spinctrl
      ctrls.append(spinctrl)
      self.Bind(wx.EVT_SPINCTRL,
        lambda evt: self.update_values(evt, setting),
        spinctrl)
    elif isinstance(value, int) and isinstance(captions, list):
      txt = wx.StaticText(panel, -1, label)
      ctrls.append(txt)
      choice = wx.Choice(panel, -1, choices=captions)
      choice.SetSelection(value)
      self._controls[setting] = choice
      ctrls.append(choice)
      self.Bind(wx.EVT_CHOICE,
        lambda evt: self.update_values(evt, setting),
        choice)
    else :
      assert 0
    return ctrls

  def update_values(self, evt, setting):
    assert hasattr(self.settings, setting)
    ctrl = evt.GetEventObject()
    if isinstance(ctrl, wx.Choice):
      value = ctrl.GetSelection()
    elif (type(ctrl).__name__ in ["CheckBox", "SpinCtrl", "Slider"]):
      value = ctrl.GetValue()
    elif isinstance(ctrl, wx.lib.colourselect.ColourSelect):
      value = [ x / 255.0 for x in ctrl.GetValue() ]
    assert (type(value) == type(getattr(self.settings, setting)))
    setattr(self.settings, setting, value)
    self.parent.update_settings()

class SettingsFrame(wx.MiniFrame, SettingsToolBase):
  def __init__(self, *args, **kwds):
    wx.MiniFrame.__init__(self, *args, **kwds)
    SettingsToolBase.__init__(self, *args, **kwds)
    self.sizer = wx.BoxSizer(wx.VERTICAL)
    self.SetSizer(self.sizer)
    self.panel = wx.Panel(self, -1)
    self.panel_sizer = wx.BoxSizer(wx.VERTICAL)
    self.panel.SetSizer(self.panel_sizer)
    self.sizer.Add(self.panel, 1, wx.EXPAND)
    self.add_controls()
    self.sizer.Fit(self.panel)
    self.Fit()
    self.Bind(wx.EVT_CLOSE, self.OnClose, self)
    self.Bind(wx.EVT_WINDOW_DESTROY, self.OnDestroy, self)

  def OnClose(self, event):
    self.Destroy()

  def OnDestroy(self, event):
    self.parent.settings_window = None

class SettingsPanel(wx.Panel, SettingsToolBase):
  def __init__(self, *args, **kwds):
    wx.Panel.__init__(self, *args, **kwds)
    SettingsToolBase.__init__(self, *args, **kwds)
    self.panel = self
    self.panel_sizer = wx.BoxSizer(wx.VERTICAL)
    self.SetSizer(self.panel_sizer)
    self.add_controls()

def bold_text(parent, label):
  txt = wx.StaticText(parent, label=label)
  font = txt.GetFont()
  font.SetWeight(wx.FONTWEIGHT_BOLD)
  txt.SetFont(font)
  return txt

std_sizer_flags = wx.ALL|wx.ALIGN_CENTER_VERTICAL

def add_ok_cancel_buttons(self, sizer):
  assert isinstance(self, wx.Dialog)
  ok_btn = wx.Button(self, wx.ID_OK)
  cancel_btn = wx.Button(self, wx.ID_CANCEL)
  btn_szr = wx.StdDialogButtonSizer()
  btn_szr.Add(cancel_btn, 0, wx.ALL, 5)
  btn_szr.Add(ok_btn, 0, wx.ALL, 5)
  ok_btn.SetDefault()
  btn_szr.Realize()
  sizer.Add(btn_szr, 0, wx.ALL|wx.ALIGN_RIGHT, 5)
  return ok_btn, cancel_btn

class LogViewer(wx.TextCtrl):
  font_size = 12
  if (wx.Platform == '__WXGTK__'):
    font_size = 11
  if (wx.Platform == '__WXMSW__'):
    font_size = 9
  def __init__(self, *args, **kwds):
    kwds['style'] = wx.TE_MULTILINE|wx.TE_WORDWRAP|wx.TE_READONLY
    wx.TextCtrl.__init__(self, *args, **kwds)
    #self.SetFont(wx.Font(self.font_size, wx.MODERN, wx.NORMAL, wx.NORMAL))
    self.character_limit = 16000000  # ~ 200,000 lines @ 80 characters/line

  def Clear(self):
    wx.TextCtrl.Clear(self)
    self.SetFont(wx.Font(self.font_size, wx.MODERN, wx.NORMAL, wx.NORMAL))

  def WriteText(self, text):
    if UNICODE_BUILD :
      text = to_unicode(text)
    self.SetFont(wx.Font(self.font_size, wx.MODERN, wx.NORMAL, wx.NORMAL))
    wx.TextCtrl.WriteText(self, text)

  def AppendText(self, text):
    if UNICODE_BUILD :
      text = to_unicode(text)
    self.SetFont(wx.Font(self.font_size, wx.MODERN, wx.NORMAL, wx.NORMAL))
    wx.TextCtrl.AppendText(self, text)
    # keep text to be a certain size for performance
    if (self.GetLastPosition() > self.character_limit):
      self.Remove(0,len(text))

if (__name__ == "__main__"):
  app = wx.App(0)
  frame = wx.Frame(None, title="Test frame")
  panel = wx.Panel(frame, -1, size=(600,400))
  log = LogViewer(panel, size=(580,380), pos=(10,10))
  frame.Show()
  log.WriteText("This is a log line\n")
  angstrom = u"\u00C5".encode("utf-8", "strict").strip()
  log.WriteText("This is line containing special characters: %s" % angstrom)
  app.MainLoop()


 *******************************************************************************


 *******************************************************************************
wxtbx/windows.py

"""
Miscellaneous custom wxPython windowing objects.
"""

from __future__ import absolute_import, division, print_function
import wx

class ChoiceBook(wx.Panel):
  """
  Notebook-like container with a wx.Choice control instead of tabs.
  """
  def __init__(self, *args, **kwds):
    super(ChoiceBook, self).__init__(*args, **kwds)
    szr = wx.BoxSizer(wx.VERTICAL)
    self.SetSizer(szr)
    self._pages = []
    self._current_page = None
    self._was_shown = False
    self._chooser = wx.Choice(parent=self, size=(400,-1))
    szr.Add(self._chooser, 0, wx.ALL|wx.ALIGN_CENTER, 5)
    self._page_sizer = szr #wx.BoxSizer(wx.VERTICAL)
    #szr.Add(self._page_sizer, 1, wx.EXPAND|wx.ALL)
    self.Bind(wx.EVT_CHOICE, self.OnChoose, self._chooser)

  def AddPage(self, page, label):
    """
    Add a panel to the notebook (and the label to the wx.Choice).
    """
    self._pages.append(page)
    self.GetSizer().Add(page, 1, wx.ALL|wx.EXPAND, 0)
    page.Hide()
    items = list(self._chooser.GetItems())
    items.append(label)
    self._chooser.SetItems(items)

  def InsertPage(self, index, page, label):
    """
    Insert a panel in the notebook (and the label to the wx.Choice) at the
    specified index.
    """
    self._pages.insert(0, page)
    self.GetSizer().Add(page, 1, wx.ALL|wx.EXPAND, 0)
    page.Hide()
    items = list(self._chooser.GetItems())
    items.insert(0, label)
    self._chooser.SetItems(items)

  def GetPage(self, i_page):
    return self._pages[i_page]

  def SetPage(self, i_page):
    if (self._current_page is not None):
      self._current_page.Hide()
    self._current_page = self.GetPage(i_page)
    self._current_page.Layout()
    if hasattr(self._current_page, "SetupScrolling") : # scrolledpanel hack
      self._current_page.SetupScrolling(scrollToTop=False)
    self._current_page.Show()
    self._chooser.SetSelection(i_page)
    self.Layout()

  def SetSelection(self, i_page):
    self.SetPage(i_page)

  def GetPageIndex(self, page):
    for i_page, other in enumerate(self._pages):
      if (other is page):
        return i_page
    return -1

  def GetPageCount(self):
    return len(self._pages)

  def OnChoose(self, evt):
    i_page = self._chooser.GetSelection()
    self.SetPage(i_page)

if (__name__ == "__main__"):
  import wx.lib.scrolledpanel
  app = wx.App(0)
  frame = wx.Frame(None, title="Test frame", size=(800,600))
  nb = ChoiceBook(frame)
  page = wx.lib.scrolledpanel.ScrolledPanel(nb, style=wx.SUNKEN_BORDER)
  szr = wx.BoxSizer(wx.VERTICAL)
  page.SetSizer(szr)
  txt  = wx.StaticText(page, -1, "This is some text")
  szr.Add(txt, 0, wx.ALL|wx.ALIGN_CENTER_VERTICAL, 200)
  nb.AddPage(page, "Page 1")
  nb.SetPage(0)
  frame.Show()
  app.MainLoop()


 *******************************************************************************


 *******************************************************************************
wxtbx/wx4_compatibility.py
from __future__ import absolute_import, division, print_function

'''
Author      : Lyubimov, A.Y.
Created     : 04/14/2014
Last Changed: 11/05/2018
Description : wxPython 3-4 compatibility tools

The context managers, classes, and other tools below can be used to make the
GUI code compatible with wxPython 3 and 4. Mostly, the tools convert the
functions, enumerations, and classes which have been renamed in wxPython 4;
the name mismatches result in exceptions.

Use case 1: subclassing wx.PyControl or wx.Control:

from wxtbx import wx4_compatibility as wx4c
WxCtrl = wx4c.get_wx_mod(wx, wx.Control)
class MyCustomControl(WxCtrl): ...


Use case 2: brush style (NOTE: you can do that with fonts as well, but it
doesn't seem to be necessary):

from wxtbx import wx4_compatibility as wx4c
bkgrd = self.GetBackgroundColour()
with wx4c.set_brush_style(wx.BRUSHSTYLE_SOLID) as bstyle:
    brush = wx.Brush(bkgrd, bstyle)


Use case 3: Toolbars

from wxtbx import wx4_compatibility as wx4c, bitmaps
class MyFrame(wx.Frame):
  def __init__(self, parent, id, title, *args, **kwargs):
    wx.Frame.__init__(self, parent, id, title, *args, **kwargs)

    self.toolbar = wx4c.ToolBar(self, style=wx.TB_TEXT)
    self.quit_button = self.toolbar.AddTool(toolId=wx.ID_ANY,
                                             label='Quit',
                                             kind=wx.ITEM_NORMAL,
                                             bitmap=bitmaps.fetch_icon_bitmap('actions', 'exit')
                                             shortHelp='Exit program')
    ...
    self.SetToolBar(self.toolbar)
    self.toolbar.Realize()


'''

import wx
from contextlib import contextmanager
import importlib

wx4 = wx.__version__[0] == '4'

modnames = [
  ('PyControl', 'Control'),
  ('PyDataObjectSimple', 'DataObjectSimple'),
  ('PyDropTarget', 'DropTarget'),
  ('PyEvtHandler', 'EvtHandler'),
  ('PyImageHandler', 'ImageHandler'),
  ('PyLocale', 'Locale'),
  ('PyLog', 'Log'),
  ('PyPanel', 'Panel'),
  ('PyPickerBase', 'PickerBase'),
  ('PyPreviewControlBar', 'PreviewControlBar'),
  ('PyPreviewFrame', 'PreviewFrame'),
  ('PyPrintPreview', 'PrintPreview'),
  ('PyScrolledWindow', 'ScrolledWindow'),
  ('PySimpleApp', 'App'),
  ('PyTextDataObject', 'TextDataObject'),
  ('PyTimer', 'Timer'),
  ('PyTipProvider', 'adv.TipProvider'),
  ('PyValidator', 'Validator'),
  ('PyWindow'', Window')
]

font_families = [
  (wx.DEFAULT, wx.FONTFAMILY_DEFAULT),
  (wx.DECORATIVE, wx.FONTFAMILY_DECORATIVE),
  (wx.ROMAN, wx.FONTFAMILY_ROMAN),
  (wx.SCRIPT, wx.FONTFAMILY_SCRIPT),
  (wx.SWISS, wx.FONTFAMILY_SWISS),
  (wx.MODERN, wx.FONTFAMILY_MODERN),
  (wx.TELETYPE, wx.FONTFAMILY_TELETYPE)
]

font_weights = [
  (wx.NORMAL, wx.FONTWEIGHT_NORMAL),
  (wx.LIGHT, wx.FONTWEIGHT_LIGHT),
  (wx.BOLD, wx.FONTWEIGHT_BOLD)
]

font_styles = [
  (wx.NORMAL, wx.FONTSTYLE_NORMAL),
  (wx.ITALIC, wx.FONTSTYLE_ITALIC),
  (wx.SLANT, wx.FONTSTYLE_SLANT)
]

pen_styles = [
  (wx.SOLID, wx.PENSTYLE_SOLID),
  (wx.DOT, wx.PENSTYLE_DOT),
  (wx.LONG_DASH, wx.PENSTYLE_LONG_DASH),
  (wx.SHORT_DASH, wx.PENSTYLE_SHORT_DASH),
  (wx.DOT_DASH, wx.PENSTYLE_DOT_DASH),
  (wx.USER_DASH, wx.PENSTYLE_USER_DASH),
  (wx.TRANSPARENT, wx.PENSTYLE_TRANSPARENT)
]

brush_styles = [
  (wx.SOLID, wx.BRUSHSTYLE_SOLID),
  (wx.TRANSPARENT, wx.BRUSHSTYLE_TRANSPARENT),
  (wx.STIPPLE_MASK_OPAQUE, wx.BRUSHSTYLE_STIPPLE_MASK_OPAQUE),
  (wx.STIPPLE_MASK, wx.BRUSHSTYLE_STIPPLE_MASK),
  (wx.STIPPLE, wx.BRUSHSTYLE_STIPPLE),
  (wx.BDIAGONAL_HATCH, wx.BRUSHSTYLE_BDIAGONAL_HATCH),
  (wx.CROSSDIAG_HATCH, wx.BRUSHSTYLE_CROSSDIAG_HATCH),
  (wx.FDIAGONAL_HATCH, wx.BRUSHSTYLE_FDIAGONAL_HATCH),
  (wx.CROSS_HATCH, wx.BRUSHSTYLE_CROSS_HATCH),
  (wx.HORIZONTAL_HATCH, wx.BRUSHSTYLE_HORIZONTAL_HATCH),
  (wx.VERTICAL_HATCH, wx.BRUSHSTYLE_VERTICAL_HATCH),
]

def find_module(module):
  for m in modnames:
    if module.__name__ in m:
      return m

def find_enum(enums, item):
  for en in enums:
    if item in en:
      value = en[1] if wx4 else en[0]
      return value

def get_wx_mod(base, module):
  mname = find_module(module)[1] if wx4 else find_module(module)[0]
  bname = base.__name__
  if '.' in mname:
    spl = [i for i in mname.split('.') if i != bname]
    modname = '.'.join(spl[:-1])
    mod = importlib.import_module('{}.{}'.format(bname, modname))
    return getattr(mod, spl[-1])
  else:
    return getattr(base, mname)

@contextmanager
def wx_mod(base, module):
  ''' Identify and import the appropriate wxPython module '''
  yield get_wx_mod(base, module)

@contextmanager
def set_font_style(style):
  yield find_enum(font_styles, style)

@contextmanager
def set_font_weight(weight):
  yield find_enum(font_weights, weight)

@contextmanager
def set_font_family(family):
  yield find_enum(font_families, family)

@contextmanager
def set_pen_style(style):
  yield find_enum(pen_styles, style)

@contextmanager
def set_brush_style(style):
  yield find_enum(brush_styles, style)

@contextmanager
def create_measuring_context():
  dc = wx.GraphicsContext.Create() if wx4 else \
    wx.GraphicsContext.CreateMeasuringContext()
  yield dc

class Wx3ToolBar(wx.ToolBar):
  ''' Special toolbar class that accepts wxPython 4-style AddTool command and
  converts it to a wxPython 3-style AddLabelTool command '''
  def __init__(self, parent, id=wx.ID_ANY, pos=wx.DefaultPosition,
               size=wx.DefaultSize, style=wx.TB_HORIZONTAL, name='toolbar'):
    wx.ToolBar.__init__(self, parent, id, pos, size, style, name)

  def AddTool(self, toolId, label, bitmap, bmpDisabled=wx.NullBitmap,
              kind=wx.ITEM_NORMAL, shortHelp='', longHelp='',
              clientData=None):
    ''' Override to make this a very thin wrapper for AddLabelTool, which in
    wxPython 3 is the same as AddTool in wxPython 4 '''
    return self.AddLabelTool(id=toolId, label=label, bitmap=bitmap,
                             bmpDisabled=bmpDisabled, kind=kind,
                             shortHelp=shortHelp, longHelp=longHelp,
                             clientData=clientData)

class Wx4ToolBar(wx.ToolBar):
  ''' Special toolbar class that accepts wxPython 3-style AddLabelTool command
  and converts it to a wxPython 4-style AddTool command '''
  def __init__(self, parent, id=wx.ID_ANY, pos=wx.DefaultPosition,
               size=wx.DefaultSize, style=wx.TB_HORIZONTAL, name='toolbar'):
    wx.ToolBar.__init__(self, parent, id, pos, size, style, name)

  def AddLabelTool(self, id, label, bitmap, bmpDisabled=wx.NullBitmap,
              kind=wx.ITEM_NORMAL, shortHelp='', longHelp='',
              clientData=None):
    ''' Override to make this a very thin wrapper for AddTool, which in
    wxPython 4 is the same as AddLabelTool in wxPython 3 '''
    return self.AddTool(toolId=id, label=label, bitmap=bitmap,
                        bmpDisabled=bmpDisabled, kind=kind,
                        shortHelp=shortHelp, longHelp=longHelp,
                        clientData=clientData)

# Use this ToolBar class to create toolbars in frames
ToolBar = Wx4ToolBar if wx4 else Wx3ToolBar


 *******************************************************************************


 *******************************************************************************
wxtbx/xtriage.py

"""
Classes for displaying Xtriage results using wxPython (and matplotlib).
"""

from __future__ import absolute_import, division, print_function
from wxtbx import metallicbutton
import wxtbx.misc_dialogs
import wxtbx.path_dialogs
import wxtbx.windows
import wxtbx.tables
import wxtbx.plots
import mmtbx.scaling
import wx.lib.scrolledpanel
from libtbx.utils import Sorry, to_unicode
from libtbx import easy_pickle, easy_run
import wx
import os.path
import sys
from six.moves import range

TEXT_WIDTH = 800

class wx_panel(wx.lib.scrolledpanel.ScrolledPanel):
  def OnChildFocus(self, evt):
    pass

class wx_output_base(mmtbx.scaling.xtriage_output):
  """
  Implements wxPython controls for Xtriage output handler, independent of
  window type.
  """
  gui_output = True
  def __init__(self, *args, **kwds):
    super(wx_output_base, self).__init__(*args, **kwds)
    self._current_panel = None
    self._current_sizer = None
    self._sections = {}
    self._graphs = []
    self._tables = []
    self._in_box = False

  def create_panel(self):
    raise NotImplementedError()

  def add_panel(self, panel, title):
    raise NotImplementedError()

  def show_big_header(self, text) : pass

  def show_header(self, title):
    """
    Creates a new notebook page with the specified title.  This will be the
    output panel for all subsequent method calls until show_header() is called
    again.
    """
    panel = self.create_panel()
    szr = wx.BoxSizer(wx.VERTICAL)
    panel.SetSizer(szr)
    self._current_panel = panel
    self._current_sizer = szr
    self.add_panel(panel, title)

  def show_sub_header(self, title):
    """
    Create a wx.StaticBox
    """
    assert (self._current_panel is not None)
    if (self._in_box):
      self._current_sizer = self._current_panel.GetSizer()
    box = wx.StaticBox(parent=self._current_panel,
      label=title,
      style=wx.NO_BORDER)
    box_szr = wx.StaticBoxSizer(box, wx.VERTICAL)
    self._current_sizer.Add(box_szr, 0, wx.ALL|wx.EXPAND, 5)
    self._current_sizer = box_szr
    self._sections[title] = box
    self._in_box = True

  def show_text(self, text):
    """
    Create wx.StaticText object(s) with automatic wrapping.  Double-newlines
    will be treated as paragraph breaks, otherwise newlines are replaced by
    spaces.
    """
    assert (self._current_panel is not None)
    blocks = text.split("\n\n")
    for block in blocks :
      block = " ".join([ l.strip() for l in block.splitlines() ]).strip()
      wxtxt = wx.StaticText(parent=self._current_panel,
                            label=to_unicode(block))
      wxtxt.Wrap(TEXT_WIDTH)
      self._current_sizer.Add(wxtxt, 0, wx.ALL, 5)

  def show_preformatted_text(self, text):
    """
    Draw monospaced text, preserving the original formatting.
    """
    assert (self._current_panel is not None)
    if text.startswith("\n"):
      text = text[1:]
    wx_txt = wx.StaticText(parent=self._current_panel,
      label=text)
    font = wx_txt.GetFont()
    font2 = wx.Font(font.GetPointSize(), wx.FONTFAMILY_MODERN, wx.NORMAL,
      wx.FONTWEIGHT_NORMAL) #  Python 3 Fix  , face="Courier")
    # FIXME this seems not to work on wxPython 3/Mac OS 10.9
    wx_txt.SetFont(font2)
    self._current_sizer.Add(wx_txt, 0, wx.ALL, 5)

  def warn(self, text):
    """
    Create wx.StaticText object(s) with automatic wrapping.  Font will be
    boldface with red foreground.
    """
    assert (self._current_panel is not None)
    blocks = text.split("\n\n")
    for block in blocks :
      block = " ".join([ l.strip() for l in block.splitlines() ]).strip()
      wxtxt = wx.StaticText(parent=self._current_panel,
        label=block)
      font = wxtxt.GetFont()
      font.SetWeight(wx.FONTWEIGHT_BOLD)
      wxtxt.SetFont(font)
      wxtxt.SetForegroundColour((240,0,0))
      wxtxt.Wrap(TEXT_WIDTH)
      self._current_sizer.Add(wxtxt, 0, wx.ALL, 5)

  def show_lines(self, text):
    assert (self._current_panel is not None)
    wxtxt = wx.StaticText(parent=self._current_panel,
      label=text)
    wxtxt.Wrap(TEXT_WIDTH)
    self._current_sizer.Add(wxtxt, 0, wx.ALL, 5)

  def show_paragraph_header(self, text):
    """
    Draws left-aligned boldface text in a slightly larger font.
    """
    assert (self._current_panel is not None)
    wx_text = wx.StaticText(
      parent=self._current_panel,
      label=text)
    font = wx_text.GetFont()
    font.SetWeight(wx.FONTWEIGHT_BOLD)
    font.SetPointSize(14)
    wx_text.SetFont(font)
    self._current_sizer.Add(wx_text, 0, wx.ALL, 5)

  def show_table(self, table, indent=0, plot_button=False,
      equal_widths=None):
    """
    Draw a wx.ListCtrl and populate from the table.  Can optionally include
    a button to launch a graph viewer window; this is used when the table
    contains more than one graph.
    """
    assert (self._current_panel is not None)
    height = min(400, max(80, 20 + (20*table.n_rows)))
    width = TEXT_WIDTH - 40
    wxtable = wxtbx.tables.TableView(
      parent=self._current_panel,
      style=wx.LC_REPORT|wx.SIMPLE_BORDER,
      size=(width, height))
    wxtable.SetTable(table)
    self._tables.append(wxtable)
    self._current_sizer.Add(wxtable, 0, wx.ALL|wx.EXPAND, 5)
    if (plot_button):
      assert hasattr(table, "get_graph")
      btn = wx.Button(parent=self._current_panel, label="Show graphs")
      self._current_sizer.Add(btn, 0, wx.ALL, 5)
      self.Bind(wx.EVT_BUTTON, wxtable.OnViewGraphs, btn)

  def show_plot(self, table):
    """
    Create an inline matplotlib plot, using the wxtbx.plots.loggraph wrapper.
    """
    assert (self._current_panel is not None)
    graph = wxtbx.plots.iotbx_data_plot_base(
      parent=self._current_panel,
      tables=[table],
      size=(TEXT_WIDTH - 40, min(500, TEXT_WIDTH * 0.75)))
    graph.set_plot(table.only_plot())
    self._graphs.append((graph, table.title))
    self._current_sizer.Add(graph, 0, wx.ALL|wx.EXPAND, 5)

  def show_plots_row(self, tables):
    szr = wx.BoxSizer(wx.HORIZONTAL)
    self._current_sizer.Add(szr, 0, wx.EXPAND)
    plot_w = (TEXT_WIDTH / 3) - 10
    plot_dimensions = (plot_w, min(360, plot_w * 0.9))
    for table in tables :
      graph = wxtbx.plots.small_plot(
        parent=self._current_panel,
        table=table,
        size=plot_dimensions)
      graph.set_plot(table.only_plot())
      self._graphs.append((graph, table.title))
      szr.Add(graph, 0, wx.ALL|wx.EXPAND, 5)

  def show_text_columns(self, rows, indent=0):
    prefix = " "*indent
    n_cols = len(rows[0])
    sizer = wx.FlexGridSizer(cols=n_cols) # Remove rows Python 3 fix
    self._current_sizer.Add(sizer)
    for row in rows :
      assert (len(row) == n_cols)
      txt1 = wx.StaticText(parent=self._current_panel, label=prefix+row[0])
      font = txt1.GetFont()
      font.SetWeight(wx.FONTWEIGHT_BOLD)
      txt1.SetFont(font)
      sizer.Add(txt1, 0, wx.ALL|wx.ALIGN_CENTER_VERTICAL, 5)
      for cell in row[1:] :
        txt_cell = wx.StaticText(parent=self._current_panel, label=cell)
        sizer.Add(txt_cell, 0, wx.ALL|wx.ALIGN_CENTER_VERTICAL, 5)

  def newline(self):
    pass

  def OnSaveImage(self, event):
    graph_names = [ title for (graph, title) in self._graphs ]
    selected = wxtbx.misc_dialogs.ChoiceSelector(
      title="Save plot image",
      message="Please choose a plot to save:",
      choices=graph_names,
      defaultChoice=0)
    graph_index = graph_names.index(selected)
    (graph, title) = self._graphs[graph_index]
    graph.save_image()

  def add_change_symmetry_button(self):
    data_file = os.path.join(os.getcwd(), "xtriage_data.pkl")
    if (not os.path.exists(data_file)):
      return
    btn = wx.Button(parent=self._current_panel,
      label="Save data in selected setting...")
    btn.data_file = data_file
    btn.symm_table = self._tables[-1]
    self._current_sizer.Add(btn, 0, wx.ALL, 5)
    self.Bind(wx.EVT_BUTTON, OnChangeSymmetry, btn)

  def show_issues(self, issues):
    """
    Display a list of possible issues with traffic light-like symbols
    indicating severity.  Each item is a button that links to the appropriate
    results section (if defined).
    """
    grid = wx.FlexGridSizer(cols=1) # Remove rows Python 3 fix
    self._current_sizer.Add(grid, 0, wx.ALL, 10)
    for severity, message, linkto in issues :
      ctrl = DrawStatusLightControl(parent=self._current_panel,
        #size=(32,32),
        message=message,
        name=linkto,
        level=severity)#style=wx.SIMPLE_BORDER).SetLevel(severity)
      self.Bind(wx.EVT_BUTTON, self.OnShowSection, ctrl)
      grid.Add(ctrl, 0, wx.ALL|wx.EXPAND, 0)

  def OnShowSection(self, evt):
    """
    Change the page selection in response to clicking on one of the issue
    summaries, and scroll the corresponding results section into view.
    """
    section_name = evt.GetEventObject().GetName()
    if (section_name is None) or (section_name == "button") : return
    section = self._sections.get(section_name)
    assert (section is not None), section_name
    page = section.GetParent()
    self.SetPage(self.GetPageIndex(page))
    page.ScrollChildIntoView(section)

class wx_output(wx_output_base, wxtbx.windows.ChoiceBook):
  """
  Xtriage output implemented as a wxPython notebook.
  """
  def SetupScrolling(self):
    """
    Initialize scrollbars on child panels.
    """
    for i_page in range(self.GetPageCount()):
      panel = self.GetPage(i_page)
      panel.Layout()
      panel.SetupScrolling(scrollToTop=True)

  def create_panel(self):
    return wx_panel(parent=self, style=wx.SUNKEN_BORDER)

  def add_panel(self, panel, title):
    if (title == "Twinning and intensity statistics summary"):
      self.InsertPage(0, panel, title)
    elif (title == "Xtriage summary"):
      self.InsertPage(0, panel, title)
    else :
      self.AddPage(panel, title)

class wx_output_panel(wx_output_base, wx_panel):
  """
  Single panel for displaying an individual Xtriage result.  If more than
  one section is displayed (corresponding to multiple notebook pages in the
  standard window), an error will be raised.
  """
  def create_panel(self):
    assert (self._current_panel is None)
    return self

  def add_panel(self, panel, title):
    pass

def DrawStatusLightControl(parent, message, name, level):
  """
  Create a control (based on wxtbx.metallicbutton) with a traffic light-like
  symbol indicating the severity of a message, with the actual message next to
  it.
  """
  bmp = wx.EmptyBitmap(32, 32)
  dc = wx.MemoryDC()
  dc.SelectObject(bmp)
  gc = wx.GraphicsContext.Create(dc)
  dc.Clear()
  if (level == 0):
    gc.SetBrush(wx.Brush((0,255,0)))
  elif (level == 1):
    gc.SetBrush(wx.Brush((255,255,0)))
  elif (1 < level < 2):
    gc.SetBrush(wx.Brush((255,140,0)))
  else :
    gc.SetBrush(wx.Brush((255,0,0)))
  gc.DrawEllipse(4, 4, 28, 28)

  # delete contexts after drawing is complete and before setting mask
  # (fixes Windows error, not an issue with OS X or Linux)
  del gc
  del dc

  bmp.SetMask(wx.Mask(bmp,wx.WHITE))
  btn = metallicbutton.MetallicButton(
    parent=parent,
    label2=message,
    size=(800,-1),
    caption_size=12,
    bmp=bmp)
  btn.SetFont(parent.GetFont())
  if (name is not None):
    btn.SetName(name)
  return btn

class XtriageFrame(wx.Frame):
  """
  Frame for displaying a wx_output notebook independently (used in AutoSol
  and similar apps).
  """
  def __init__(self, *args, **kwds):
    super(XtriageFrame, self).__init__(*args, **kwds)
    self.output_panel = self.create_panel()
    self.SetupToolbar()
    self._result = None

  def create_panel(self):
    return wx_output(parent=self)

  def SetupToolbar(self):
    self.toolbar = self.CreateToolBar(style=wx.TB_TEXT)
    self.AddAppSpecificButtons()
    bmp = wxtbx.bitmaps.fetch_icon_bitmap("mimetypes", "spreadsheet")
    btn = self.toolbar.AddLabelTool(-1, "Save graph", bmp,
      shortHelp="Save graph", kind=wx.ITEM_NORMAL)
    self.Bind(wx.EVT_MENU, self.output_panel.OnSaveImage, btn)
    bmp = wxtbx.bitmaps.fetch_icon_bitmap("mimetypes", "txt")
    btn = self.toolbar.AddLabelTool(-1, "View log file", bmp,
      shortHelp="View log file", kind=wx.ITEM_NORMAL)
    self.Bind(wx.EVT_MENU, self.OnDisplayLog, btn)
    self.toolbar.Realize()

  def AddAppSpecificButtons(self):
    pass

  def SetResult(self, result):
    self._result = result
    result.show(out=self.output_panel)
    self.output_panel.SetupScrolling()
    if hasattr(self.output_panel, "SetPage"):
      self.output_panel.SetPage(0)

  def OnDisplayLog(self, event):
    if (self._result.log_file_name is not None):
      if (sys.platform == "darwin"):
        easy_run.call("open -a TextEdit %s" % self._result.log_file_name)
      else :
        pass

class XtriageFrameSingleResult(XtriageFrame):
  def create_panel(self):
    return wx_output_panel(parent=self)

def OnChangeSymmetry(event):
  from mmtbx.scaling.xtriage import change_symmetry
  button = event.GetEventObject()
  data_file = button.data_file
  assert (data_file is not None) and os.path.isfile(data_file)
  item = button.symm_table.GetFirstSelected()
  if (item == -1):
    raise Sorry("Please select a symmetry setting first!")
  default_file = os.path.join(os.path.dirname(data_file), "reindexed.mtz")
  file_name = wxtbx.path_dialogs.manager().select_file(
    parent=button,
    message="Output data file in new symmetry",
    style=wx.FD_SAVE,
    wildcard="MTZ files (*.mtz)|*.mtz",
    current_file=default_file)
  data = easy_pickle.load(data_file)
  space_group_symbol = str(button.symm_table.GetItemText(item))
  change_symmetry(
    miller_array=data,
    space_group_symbol=space_group_symbol,
    file_name=str(file_name),
    log=sys.stdout)
  assert os.path.isfile(file_name)
  wx.MessageBox(("The data (as amplitudes) have been saved to %s "+
      "with the selected symmetry setting.") % file_name)


 *******************************************************************************
