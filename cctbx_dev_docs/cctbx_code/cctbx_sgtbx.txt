

 *******************************************************************************
cctbx/sgtbx/__init__.py
from __future__ import absolute_import, division, print_function
from cctbx import uctbx

import boost_adaptbx.boost.python as bp
from six.moves import range
from six.moves import zip
ext = bp.import_ext("cctbx_sgtbx_ext")
from cctbx_sgtbx_ext import *

import libtbx

rhombohedral_hermann_mauguin_symbols = [
  "R 3",
  "R -3",
  "R 3 2",
  "R 3 m",
  "R 3 c",
  "R -3 m",
  "R -3 c"]

class empty: pass

from cctbx.array_family import flex
from scitbx import matrix
from boost_adaptbx.boost import rational
import random
import sys

bp.inject(ext.space_group_symbol_iterator, bp.py3_make_iterator)

def vec3_rat_from_str(s):
  flds = s.split(",")
  assert len(flds) == 3
  result = []
  for fld in flds:
    slash_count = fld.count("/")
    assert slash_count < 2
    if (slash_count == 0):
      n, d = int(fld), 1
    else:
      n, d = [int(t) for t in fld.split("/")]
    result.append(rational.int(n, d))
  return result

@bp.inject_into(ext.space_group)
class _():

  def smx(self, with_inversion=False):
    if with_inversion: n = 2*self.n_smx()
    else: n = self.n_smx()
    for i_smx in range(n):
      yield self(i_smx)

  def ltr(self):
    for i in range(self.n_ltr()):
      yield self(i,0,0).t()

  def info(self):
    return space_group_info(group=self)

  def adp_constraints(self):
    return tensor_rank_2_constraints(space_group=self, reciprocal_space=True)

  def cartesian_adp_constraints(self, unit_cell):
    return tensor_rank_2_cartesian_constraints(unit_cell, self)


class any_generator_set(object):

  def __init__(self, space_group,
               z2c_r_den=cb_r_den, z2c_t_den=cb_t_den):
    self.space_group = space_group
    gen_set = ext.any_generator_set(space_group=space_group,
                                    z2p_r_den=cb_r_den,
                                    z2p_t_den=cb_t_den)
    gen_set.set_primitive()
    self.non_primitive_generators = gen_set.z_gen()
    self.primitive_generators = gen_set.p_gen()


class space_group_info(object):

  __safe_for_unpickling__ = True

  def __init__(self,
        symbol=None,
        table_id=None,
        group=None,
        number=None,
        space_group_t_den=None):
    assert [symbol, group, number].count(None) >= 2
    if (number is not None):
      symbol = str(number)
    if (symbol is None):
      assert table_id is None
      if (space_group_t_den is not None):
        assert space_group_t_den == group.t_den()
      self._group = group
    else:
      assert group is None
      if (table_id is None):
        symbols = space_group_symbols(symbol)
      else:
        if (isinstance(symbol, int)): symbol = str(symbol)
        symbols = space_group_symbols(symbol, table_id)
      if (space_group_t_den is None):
        self._group = space_group(
          space_group_symbols=symbols)
      else:
        self._group = space_group(
          space_group_symbols=symbols, t_den=space_group_t_den)
    if (self._group is not None):
      self._group.make_tidy()
    self._space_group_info_cache = empty()

  def _copy_constructor(self, other):
    self._group = other._group
    self._space_group_info_cache = other._space_group_info_cache

  def __getstate__(self):
    return (self._group,)

  def __setstate__(self, state):
    self._group = state[0]
    self._space_group_info_cache = empty()

  def group(self):
    return self._group

  def type(self, tidy_cb_op=True, r_den=None, t_den=None):
    cache = self._space_group_info_cache
    cache_type = getattr(cache, "_type", None)
    if (cache_type is None):
      f = self._group.t_den() // sg_t_den
      if (r_den is None): r_den = f * cb_r_den
      if (t_den is None): t_den = f * cb_t_den
    else:
      cache_type_params = cache._type_params
      if (r_den is None): r_den = cache_type_params[1]
      if (t_den is None): t_den = cache_type_params[2]
    type_params = (tidy_cb_op, r_den, t_den)
    if (cache_type is None or cache_type_params != type_params):
      cache._type_params = type_params
      cache._type = cache_type = space_group_type(*(self._group,)+type_params)
    return cache_type

  def any_generator_set(self):
    cache = self._space_group_info_cache
    try:
      return cache._generators
    except AttributeError:
      cache._generators = any_generator_set(self.group())
      return cache._generators

  def reciprocal_space_asu(self):
    cache = self._space_group_info_cache
    if (not hasattr(cache, "_reciprocal_space_asu")):
      cache._reciprocal_space_asu = reciprocal_space_asu(self.type())
    return cache._reciprocal_space_asu

  def direct_space_asu(self):
    from cctbx.sgtbx.direct_space_asu import reference_table
    cache = self._space_group_info_cache
    if (not hasattr(cache, "_direct_space_asu")):
      reference_asu = reference_table.get_asu(self.type().number())
      cache._direct_space_asu = reference_asu.change_basis(
        self.change_of_basis_op_to_reference_setting().inverse())
    return cache._direct_space_asu

  def brick(self):
    cache = self._space_group_info_cache
    if (not hasattr(cache, "_brick")):
      cache._brick = brick(self.type())
    return cache._brick

  def wyckoff_table(self):
    cache = self._space_group_info_cache
    if (not hasattr(cache, "_wyckoff_table")):
      cache._wyckoff_table = wyckoff_table(self.type())
    return cache._wyckoff_table

  def structure_seminvariants(self):
    cache = self._space_group_info_cache
    if (not hasattr(cache, "_structure_seminvariants")):
      cache._structure_seminvariants = structure_seminvariants(self._group)
    return cache._structure_seminvariants

  def reference_setting(self):
    cache = self._space_group_info_cache
    if (not hasattr(cache, "_reference_setting")):
      cache._reference_setting = space_group_info(symbol=self.type().number())
    return cache._reference_setting

  def change_of_basis_op_to_reference_setting(self):
    return self.type().cb_op()

  def is_reference_setting(self):
    return self.change_of_basis_op_to_reference_setting().is_identity_op()

  def as_reference_setting(self):
    return self.change_basis(self.change_of_basis_op_to_reference_setting())

  def change_basis(self, cb_op):
    if (isinstance(cb_op, str)):
      cb_op = change_of_basis_op(cb_op)
    return space_group_info(group=self.group().change_basis(cb_op))

  def change_of_basis_op_to_other_hand(self):
    return self.type().change_of_hand_op()

  def change_hand(self):
    return self.change_basis(self.change_of_basis_op_to_other_hand())

  def change_of_basis_op_to_primitive_setting(self):
    return self.group().z2p_op()

  def primitive_setting(self):
    return self.change_basis(self.change_of_basis_op_to_primitive_setting())

  def change_of_basis_op_to(self, other):
    """ The change of basis from self to other.
    This method strives to return a mere origin shift.
    """
    self_to_ref_op = self.change_of_basis_op_to_reference_setting()
    other_to_ref_op = other.change_of_basis_op_to_reference_setting()

    # early exit if other is not the same space group in a different setting
    self_as_reference = self.change_basis(self_to_ref_op)
    other_as_reference = other.change_basis(other_to_ref_op)
    if self_as_reference.group() != other_as_reference.group(): return None

    # the obvious answer: if it is a mere shift, return it
    obvious_result = other_to_ref_op.inverse()*self_to_ref_op
    if obvious_result.c().r().is_unit_mx(): return obvious_result

    # otherwise, let's try to find an origin shift by hand
    # see test case exercise_change_of_basis_between_arbitrary_space_groups
    # in regression/tst_sgtbx.py for the motivation for this code.
    self_z2p_op = self.change_of_basis_op_to_primitive_setting()
    other_z2p_op = other.change_of_basis_op_to_primitive_setting()
    primitive_self = self.change_basis(self_z2p_op)
    primitive_other = other.change_basis(other_z2p_op)
    if (   set([ op.r() for op in primitive_self.group() ])
        == set([ op.r() for op in primitive_other.group() ])):
      self_tr_info_for_r = dict([ (op.r(), translation_part_info(op))
                                  for op in primitive_self.group() ])
      origin_shift = matrix.mutable_zeros(3)
      for op in primitive_other.group():
        self_ti = self_tr_info_for_r[op.r()]
        other_ti = translation_part_info(op)
        if self_ti.intrinsic_part() != other_ti.intrinsic_part():
          origin_shift = None
          break
        delta = other_ti.origin_shift().minus(
             self_ti.origin_shift()).mod_positive()
        delta_num = delta.num()
        for i in range(3):
          if origin_shift[i] == 0:
            origin_shift[i] = 24//delta.den()*delta_num[i]
        if origin_shift.elems.count(0) == 0: break
      if origin_shift is not None:
        origin_shift = tr_vec(origin_shift, tr_den=24)
        if not origin_shift.is_zero():
          cb_op = change_of_basis_op(
            rt_mx(origin_shift)).new_denominators(24, 144)
          cb_op = other_z2p_op.inverse()*cb_op*self_z2p_op
          cb_op.mod_positive_in_place()
          tentative_other = self.change_basis(cb_op)
          if tentative_other.group() == other.group():
            return cb_op

    # no origin shift has been found, so return the obvious answer
    return obvious_result

  def reflection_intensity_equivalent_groups(self, anomalous_flag=True):
    result = []
    reference_group = self.reference_setting().group()
    reference_crystal_system = reference_group.crystal_system()
    reference_reflection_intensity_group = reference_group \
      .build_derived_reflection_intensity_group(anomalous_flag=anomalous_flag)
    reference_reflection_intensity_group.make_tidy()
    for space_group_symbols in space_group_symbol_iterator():
      if (space_group_symbols.crystal_system() != reference_crystal_system):
        continue
      other_sg = space_group(space_group_symbols)
      if (other_sg.build_derived_reflection_intensity_group(
            anomalous_flag=anomalous_flag)
          == reference_reflection_intensity_group):
        result.append(other_sg.change_basis(
          self.change_of_basis_op_to_reference_setting().inverse()))
    return result

  def __str__(self):
    cache = self._space_group_info_cache
    if (not hasattr(cache, "_lookup_symbol")):
      cache._lookup_symbol = self.type().lookup_symbol()
    return cache._lookup_symbol

  def __repr__(self):
    cache = self._space_group_info_cache
    if (not hasattr(cache, "_lookup_symbol")):
      cache._lookup_symbol = self.type().lookup_symbol()
    return 'sgtbx.space_group_info(symbol="%s")' % cache._lookup_symbol

  def symbol_and_number(self):
    return "%s (No. %d)" % (str(self), self.type().number())

  def show_summary(self, f=None, prefix="Space group: "):
    if (f is None): f = sys.stdout
    print("%s%s" % (prefix, self.symbol_and_number()), file=f)

  def number_of_continuous_allowed_origin_shifts(self):
    return self.structure_seminvariants() \
      .number_of_continuous_allowed_origin_shifts()

  def subtract_continuous_allowed_origin_shifts(self, translation_frac):
    cb_op = self.change_of_basis_op_to_reference_setting()
    return cb_op.c_inv() * self.reference_setting().structure_seminvariants() \
      .subtract_principal_continuous_shifts(
        translation=cb_op.c() * translation_frac)

  def is_allowed_origin_shift(self, shift, tolerance):
    """
    Determine whether the specified fractional coordinate shift is allowed
    under the space group rules.

    :param shift: tuple specifying fractional coordinate shift
    :param tolerance: tolerance for coordinate shifts outside the allowed
                      range
    :returns: Python boolean
    """
    from libtbx.math_utils import iround
    is_ltr = lambda v: max([ abs(x-iround(x)) for x in v ]) < tolerance
    z2p_op = self.group().z2p_op()
    primitive_self = self.change_basis(z2p_op)
    primitive_shift = z2p_op.c() * shift
    if is_ltr(primitive_shift):
      return True
    for s in primitive_self.any_generator_set().primitive_generators:
      w_m_i = s.r().minus_unit_mx()
      t = w_m_i * primitive_shift
      if not is_ltr(t):
        return False
    else:
      return True

  def any_compatible_unit_cell(self, volume=None, asu_volume=None):
    """
    Generate a unit cell of arbitrary dimensions (optionally filling the
    desired volume) with parameters compatible with the specified space
    group.

    :param volume: desired unit cell volume
    :param asu_volume: desired volume of the asymmetric unit
    :returns: uctbx.unit_cell object
    """
    assert [volume, asu_volume].count(None) == 1
    if (volume is None):
      volume = asu_volume * self.group().order_z()
    sg_number = self.type().number()
    if   (sg_number <   3):
      params = (1., 1.3, 1.7, 83, 109, 129)
    elif (sg_number <  16):
      params = (1., 1.3, 1.7, 90, 109, 90)
    elif (sg_number <  75):
      params = (1., 1.3, 1.7, 90, 90, 90)
    elif (sg_number < 143):
      params = (1., 1., 1.7, 90, 90, 90)
    elif (sg_number < 195):
      params = (1., 1., 1.7, 90, 90, 120)
    else:
      params = (1., 1., 1., 90, 90, 90)
    unit_cell = uctbx.unit_cell(params).change_basis(
      cb_op=self.change_of_basis_op_to_reference_setting().inverse())
    f = (volume / unit_cell.volume())**(1/3.)
    params = list(unit_cell.parameters())
    for i in range(3): params[i] *= f
    return uctbx.unit_cell(params)

  def any_compatible_crystal_symmetry(self, volume=None, asu_volume=None):
    from cctbx import crystal
    return crystal.symmetry(
      unit_cell=self.any_compatible_unit_cell(
        volume=volume, asu_volume=asu_volume),
      space_group_info=self)

  def cif_symmetry_code(self, rt_mx, full_code=False, sep="_"):
    """ The symmetry code for the given rt_mx in the given space group as
        required by the CIF:

        http://www.iucr.org/__data/iucr/cifdic_html/1/cif_core.dic/Igeom_angle_site_symmetry_.html

        With the default full_code=False, if the translation term is zero,
        just the index of the symmetry operation is returned.
    """
    group = self._group
    cache = self._space_group_info_cache
    if not hasattr(cache, "_index_lookup_table"):
      lookup = {}
      for i, op in enumerate(group):
        lookup.setdefault(op.r(), {})
        lookup[op.r()][op.t().mod_positive()] = i
      cache._index_lookup_table = lookup
    rt_mx = rt_mx.new_denominators(group.r_den(), group.t_den())
    tr_vecs = cache._index_lookup_table[rt_mx.r()]
    t_mod_positive = rt_mx.t().mod_positive()
    idx = tr_vecs[t_mod_positive]
    t_diff = rt_mx.t().minus(group[idx].t())
    if not full_code and t_diff.is_zero():
      return "%i" %(idx+1)
    klm = tuple([int(i) + 5 for i in t_diff.as_double()])
    return "%i%s" %(idx+1, sep) + "%i%i%i" %(klm)

def reference_space_group_infos():
  for number in range(1,230+1):
    yield space_group_info(number=number)

@bp.inject_into(tr_vec)
class _():

  def as_rational(self):
    return matrix.col(rational.vector(self.num(), self.den()))

class le_page_1982_delta_details:

  def __init__(self, reduced_cell, rot_mx, deg=False):
    orth = matrix.sqr(reduced_cell.orthogonalization_matrix())
    frac = matrix.sqr(reduced_cell.fractionalization_matrix())
    r_info = rot_mx.info()
    self.type = r_info.type()
    self.u = rot_mx.info().ev()
    self.h = rot_mx.transpose().info().ev()
    self.t = orth * matrix.col(self.u)
    self.tau = matrix.row(self.h) * frac
    if (abs(self.type) == 1):
      self.delta = 0.0
    else:
      self.delta = self.t.accute_angle(self.tau, deg=deg)

@bp.inject_into(rot_mx)
class _():

  def as_rational(self):
    return matrix.sqr(rational.vector(self.num(), self.den()))

  def le_page_1982_delta_details(self, reduced_cell, deg=False):
    return le_page_1982_delta_details(
      reduced_cell=reduced_cell, rot_mx=self, deg=deg)

  def le_page_1982_delta(self, reduced_cell, deg=False):
    return self.le_page_1982_delta_details(
      reduced_cell=reduced_cell, deg=deg).delta

  def lebedev_2005_perturbation(self, reduced_cell):
    s = matrix.sym(sym_mat3=reduced_cell.metrical_matrix())
    m = self.as_rational().as_float()
    r = m.transpose() * s * m
    sirms = s.inverse() * (r-s)
    return ((sirms * sirms).trace() / 12)**0.5


@bp.inject_into(rot_mx_info)
class _():

  def basis_of_invariant(self):
    from cctbx.math_module import basis_of_mirror_plane_with_normal
    if not hasattr(self, '_basis_of_invariant'):
      if self.type() == 1:
        basis = ((1,0,0), (0,1,0), (0,0,1))
      elif self.type() == -2:
        basis = basis_of_mirror_plane_with_normal(self.ev())
      elif self.type() < 0:
        basis = ()
      else:
        basis = (self.ev(), )
      self._basis_of_invariant = basis
    return self._basis_of_invariant

  def __str__(self):
    result = "% i" % self.type()
    if self.sense() == -1: result += "^%i" % self.sense()
    result += " |(%i, %i, %i)" % self.ev()
    return result

@bp.inject_into(translation_part_info)
class _():

  def __str__(self):
    result = "+(%s) @(%s) t_l=(%s)" % (self.intrinsic_part().mod_positive(),
                                       self.origin_shift().mod_positive(),
                                       self.location_part().mod_positive())
    return result


@bp.inject_into(ext.rt_mx)
class _():

  def __getinitargs__(self):
    return (flex.int(self.as_int_array() + (self.r().den(), self.t().den())),)

  def as_rational(self):
    return matrix.rt((self.r().as_rational(), self.t().as_rational()))

  def as_4x4_rational(self):
    r = self.r().as_rational().elems
    t = self.t().as_rational().elems
    zero = rational.int(0)
    one = rational.int(1)
    return matrix.rec((
      r[0], r[1], r[2], t[0],
      r[3], r[4], r[5], t[1],
      r[6], r[7], r[8], t[2],
      zero, zero, zero,  one), (4, 4))

  def show_geometrical_elements(self, out=None):
    if out is None: out = sys.stdout
    r_info = self.r().info()
    t_info = translation_part_info(self)
    print("%s %s" % (r_info, t_info), file=out)

@bp.inject_into(ext.search_symmetry_flags)
class _():

  def show_summary(self, f=None):
    if (f is None): f = sys.stdout
    print("use_space_group_symmetry:", self.use_space_group_symmetry(), file=f)
    print("use_space_group_ltr:", self.use_space_group_ltr(), file=f)
    print("use_normalizer_k2l:", self.use_normalizer_k2l(), file=f)
    print("use_normalizer_l2n:", self.use_normalizer_l2n(), file=f)
    print("use_seminvariants:", self.use_seminvariants(), file=f)

class special_op_simplified_term(libtbx.slots_getstate_setstate):

  __slots__ = ["i_vars", "multipliers", "constant"]

  def __init__(O, i_vars, multipliers, constant):
    assert len(i_vars) == len(multipliers)
    assert multipliers.count(0) == 0
    O.i_vars = i_vars
    O.multipliers = multipliers
    O.constant = constant

  def is_identity(O):
    if (len(O.multipliers) != 1): return False
    if (O.multipliers[0] != 1): return False
    if (O.constant != 0): return False
    return True

  def __str__(O):
    s = ""
    for i,m in zip(O.i_vars, O.multipliers):
      if (m < 0):
        s += "-"
        m = -m
      elif (len(s) != 0):
        s += "+"
      if (m != 1):
        s += str(m) + "*"
      s += "xyz"[i]
    c = O.constant
    if (c != 0 or len(s) == 0):
      if (c < 0):
        s += "-"
        c = -c
      elif (len(s) != 0):
        s += "+"
      s += str(c)
    return s

class special_op_simplified(libtbx.slots_getstate_setstate):

  __slots__ = ["terms"]

  def __init__(O, terms):
    O.terms = terms

  def __str__(O):
    return ",".join([str(term) for term in O.terms])

  def shelx_fvar_encoding(self, fvars, site, p_tolerance=1e-5):
    from iotbx.shelx import fvar_encoding
    return fvar_encoding.site_constraints_special_op_simplified(
      O=self, fvars=fvars, site=site, p_tolerance=p_tolerance)

def special_op_simplifier(special_op):
  rt = special_op.as_rational()
  r = rt.r
  t = rt.t
  rows = [r[:3], r[3:6], r[6:]]
  terms = [None, None, None]
  r0 = rational.int(0)
  r1 = rational.int(1)
  n_done = 0
  for i_row,row in enumerate(rows):
    if (row == (0,0,0)):
      terms[i_row] = special_op_simplified_term([], [], t[i_row])
      n_done += 1
  if (n_done == 3):
    return special_op_simplified(terms=terms)
  if (n_done == 0):
    m, v = [], []
    for i in range(3):
      m.append([r[i+0], r[i+3]])
      v.append(r[i+6])
    from scitbx.matrix import row_echelon
    free_vars = row_echelon.form_rational(m, v)
    if (len(free_vars) == 0):
      sol = row_echelon.back_substitution_rational(m, v, free_vars, [None]*2)
      if (sol is not None and sol.count(0) == 0):
        for i_row in [0,1]:
          terms[i_row] = special_op_simplified_term([i_row], [r1], r0)
        terms[2] = special_op_simplified_term(
          [0,1], sol, t[2] - sol[0]*t[0] - sol[1]*t[1])
        return special_op_simplified(terms=terms)
  for i_row in range(3):
    if (terms[i_row] is not None): continue
    terms[i_row] = special_op_simplified_term([i_row], [r1], r0)
    for j_row in range(i_row+1,3):
      if (terms[j_row] is not None): continue
      m = matrix.linearly_dependent_pair_scaling_factor(
        vector_1=rows[i_row], vector_2=rows[j_row])
      if (m is None): continue
      assert m != 0
      terms[j_row] = special_op_simplified_term(
        [i_row], [m], t[j_row] - m*t[i_row])
  return special_op_simplified(terms=terms)

@bp.inject_into(ext.site_symmetry_ops)
class _():

  def __getinitargs__(self):
    return (self.multiplicity(), self.special_op(), self.matrices())

  def special_op_simplified(self):
    return special_op_simplifier(special_op=self.special_op())

  def shelx_fvar_encoding(self, fvars, site, p_tolerance=1e-5):
    from iotbx.shelx import fvar_encoding
    return fvar_encoding.site_constraints_site_symmetry_ops(
      O=self, fvars=fvars, site=site, p_tolerance=p_tolerance)

@bp.inject_into(ext.site_symmetry_table)
class _():

  def __getinitargs__(self):
    return (self.indices(), self.table(), self.special_position_indices())

  def apply_symmetry_sites(self, unit_cell, sites_cart):
    sites_frac = unit_cell.fractionalize(sites_cart=sites_cart)
    for i_seq in self.special_position_indices():
      sites_frac[i_seq] = self.get(i_seq=i_seq).special_op() \
                        * sites_frac[i_seq]
    return unit_cell.orthogonalize(sites_frac=sites_frac)

  def show_special_position_shifts(self,
        special_position_settings,
        site_labels,
        sites_frac_original=None,
        sites_cart_original=None,
        sites_frac_exact=None,
        sites_cart_exact=None,
        out=None,
        prefix=""):
    assert [sites_frac_original, sites_cart_original].count(None) == 1
    assert [sites_frac_exact, sites_cart_exact].count(None) == 1
    if (out is None): out = sys.stdout
    print(prefix + "Number of sites at special positions:", \
      self.special_position_indices().size(), file=out)
    if (self.special_position_indices().size() > 0):
      label_len = 5
      for i_seq in self.special_position_indices():
        label_len = max(label_len, len(site_labels[i_seq]))
      label_fmt = "%%-%ds"%label_len
      print(prefix \
        + "  Minimum distance between symmetrically equivalent sites: %.4g" % (
        special_position_settings.min_distance_sym_equiv()), file=out)
      print(prefix + "  " + label_fmt%"Label" \
        + "   Mult   Shift    Fractional coordinates", file=out)
      uc = special_position_settings.unit_cell()
      if (sites_frac_original is None):
        sites_frac_original = uc.fractionalize(sites_cart=sites_cart_original)
      if (sites_frac_exact is None):
        sites_frac_exact = uc.fractionalize(sites_cart=sites_cart_exact)
      for i_seq in self.special_position_indices():
        so = sites_frac_original[i_seq]
        se = sites_frac_exact[i_seq]
        special_ops = self.get(i_seq=i_seq)
        print(prefix + "  " + label_fmt%site_labels[i_seq] \
          + "  %4d  %7.3f (%8.4f %8.4f %8.4f) original" % (
          (special_ops.multiplicity(), uc.distance(so, se)) + so), file=out)
        print(prefix + label_fmt%"" \
          + "   site sym %-6s"%special_position_settings.site_symmetry(se) \
              .point_group_type() \
          + "(%8.4f %8.4f %8.4f) exact"%se, file=out)
        s = str(special_ops.special_op())
        print(prefix + label_fmt%"" + " "*(18+max(0,(26-len(s))//2)), s, file=out)

  def discard_symmetry(self):
    assert len(self.table())>0
    site_sym = self.table()[0]
    assert site_sym.is_point_group_1()
    return site_symmetry_table(
      indices=flex.size_t(self.indices().size(), 0),
      table=[site_symmetry_ops(1, site_sym.special_op(), site_sym.matrices())],
      special_position_indices=flex.size_t())

  def symmetry_equivalent_pair_interactions(self, i_seq, j_seq, rt_mx_ji):
    return symmetry_equivalent_pair_interactions(
      site_symmetry_ops_i=self.get(i_seq),
      site_symmetry_ops_j=self.get(j_seq),
      i_seq_eq_j_seq=(i_seq == j_seq),
      rt_mx_ji=rt_mx_ji)

  def pack_coordinates(self, sites_frac):
    assert sites_frac.size() == self.indices().size()
    result = flex.double()
    for i_seq,x in enumerate(sites_frac):
      if (self.is_special_position(i_seq)):
        x = self.get(i_seq).site_constraints().independent_params(x)
      for _ in x: result.append(_)
    return result

  def unpack_coordinates(self, packed_coordinates):
    result = flex.vec3_double()
    ix = 0
    jx = 0
    for i_tab in self.indices():
      if (i_tab == 0):
        jx = ix + 3
        x = list(packed_coordinates[ix:jx])
      else:
        sc = self.table()[i_tab].site_constraints()
        jx = ix + sc.n_independent_params()
        x = sc.all_params(list(packed_coordinates[ix:jx]))
      ix = jx
      result.append(x)
    assert jx == packed_coordinates.size()
    return result

  def pack_gradients(self, g_frac):
    assert g_frac.size() == self.indices().size()
    result = flex.double()
    for i_seq,g in enumerate(g_frac):
      if (self.is_special_position(i_seq)):
        g = self.get(i_seq).site_constraints().independent_gradients(g)
      for _ in g: result.append(_)
    return result

@bp.inject_into(wyckoff_position)
class _():

  def special_op_simplified(self):
    return special_op_simplifier(special_op=self.special_op())

@bp.inject_into(wyckoff_table)
class _():

  def random_site_symmetry(self,
        special_position_settings,
        i_position,
        unit_shift_range=(-5,6),
        tolerance=1.e-8):
    position = self.position(i_position)
    run_away_counter = 0
    while 1:
      run_away_counter += 1
      assert run_away_counter < 1000
      site = position.special_op() * [random.random() for i in range(3)]
      if (unit_shift_range is not None):
        site = [x + random.randrange(*unit_shift_range) for x in site]
      site_symmetry = special_position_settings.site_symmetry(site)
      if (site_symmetry.distance_moved() < tolerance):
        assert site_symmetry.multiplicity() == position.multiplicity()
        return site_symmetry

@bp.inject_into(structure_seminvariants)
class _():

  def __str__(self):
    result = []
    for vm in self.vectors_and_moduli():
      result.append((vm.m,) + vm.v)
    return '\n'.join([ "%i: (%i, %i, %i)" % item for item in result ])

  def number_of_continuous_allowed_origin_shifts(self):
    return self.select(False).size()

class symmetry_equivalent_pair_interactions(libtbx.slots_getstate_setstate):

  __slots__ = ["site_symmetry_ops_j", "registry"]

  def __init__(O,
        site_symmetry_ops_i,
        site_symmetry_ops_j,
        i_seq_eq_j_seq,
        rt_mx_ji):
    O.site_symmetry_ops_j = site_symmetry_ops_j
    O.registry = {}
    ssm_i =   site_symmetry_ops_i.matrices()
    ssm_j = O.site_symmetry_ops_j.matrices()
    if (not i_seq_eq_j_seq and len(ssm_i) == 1 and len(ssm_j) == 1):
      # just for fast handling of common case
      rt_mx_ji = rt_mx_ji.cancel()
      O.registry[rt_mx_ji] = rt_mx_ji
      return
    sso_j = O.site_symmetry_ops_j.special_op()
    def add(mi, rt_mx_ji):
      rt_mx_ji_eq = mi.multiply(rt_mx_ji)
      rs = rt_mx_ji_eq.multiply(sso_j)
      if (rs not in O.registry):
        best = rt_mx_ji_eq
        for mj in ssm_j:
          best = min(best, rt_mx_ji_eq.multiply(mj))
        O.registry[rs] = best
    for mi in ssm_i:
      add(mi, rt_mx_ji)
    if (i_seq_eq_j_seq):
      rt_mx_ji_inv = rt_mx_ji.inverse()
      for mi in ssm_i:
        add(mi, rt_mx_ji_inv)

  def get(O):
    result = list(O.registry.values())
    result.sort()
    return result

  def is_equivalent(O, rt_mx_ji):
    sso_j = O.site_symmetry_ops_j.special_op()
    rs = rt_mx_ji.multiply(sso_j)
    return rs in O.registry

def compare_cb_op_as_hkl(a, b):
  # Deprecated. Do not use.
  if (len(a) < len(b)): return -1
  if (len(a) > len(b)): return  1
  from libtbx.math_utils import cmp
  return cmp(a, b)


 *******************************************************************************


 *******************************************************************************
cctbx/sgtbx/boost_python/tst_N_fold_rot.py
from __future__ import absolute_import, division, print_function
from scitbx import matrix
from libtbx.math_utils import iround
from cctbx import sgtbx
from cctbx.uctbx import unit_cell

'''Test the calculation of point-group symmetry operations by comparison
to published matrices.'''

cubic = unit_cell((10.,10.,10.,90.,90.,90.))
hexag = unit_cell((10.,10.,16.,90.,90.,120.))

ersatz_tests = """\n\n\n\n
2,1,0 0 1,-1 0 0 0 -1 0 0 0 1
2,1,0 1 -1,-1 0 0 0 0 -1 0 -1 0"""

IT96_Table_11_2 = """
Matrices for point-group symmetry operations and orientation of corresponding
symmetry elements, referred to a cubic, tetragonal, orthorhombic, monoclinic,
triclinic, or rhombohedral coordinate system, International Tables for
Crystallography, Volume A, 4th revised edition, 1996, p. 797.
1,1,1 1 1,1 0 0 0 1 0 0 0 1
3,1,1 1 1,0 0 1 1 0 0 0 1 0
3,-1,1 1 1,0 1 0 0 0 1 1 0 0
-1,1,0 0 0,-1 0 0 0 -1 0 0 0 -1
-3,1,1 1 1,0 0 -1 -1 0 0 0 -1 0
-3,-1,1 1 1,0 -1 0 0 0 -1 -1 0 0
2,1,0 0 1,-1 0 0 0 -1 0 0 0 1
3,1,1 -1 -1,0 0 -1 -1 0 0 0 1 0
3,-1,1 -1 -1,0 -1 0 0 0 1 -1 0 0
2,1,1 1 0,0 1 0 1 0 0 0 0 -1
2,1,1 -1 0,0 -1 0 -1 0 0 0 0 -1
4,1,0 0 1,0 -1 0 1 0 0 0 0 1
4,-1,0 0 1,0 1 0 -1 0 0 0 0 1
-2,1,0 0 1,1 0 0 0 1 0 0 0 -1
-3,1,1 -1 -1,0 0 1 1 0 0 0 -1 0
-3,-1,1 -1 -1,0 1 0 0 0 -1 1 0 0
-2,1,1 1 0,0 -1 0 -1 0 0 0 0 1
-2,1,1 -1 0,0 1 0 1 0 0 0 0 1
-4,1,0 0 1,0 1 0 -1 0 0 0 0 -1
-4,-1,0 0 1,0 -1 0 1 0 0 0 0 -1
2,1,0 1 0,-1 0 0 0 1 0 0 0 -1"""

IT96_Table_11_3 = """
Matrices for point-group symmetry operations and orientation of corresponding
symmetry elements, referred to a hexagonal coordinate system,
International Tables for Crystallography, Volume A, 4th revised edition,
1996, p. 798.
1,1,1 1 1,1 0 0 0 1 0 0 0 1
2,1,1 -1 0,0 -1 0 -1 0 0 0 0 -1
-2,1,1 1 0,0 -1 0 -1 0 0 0 0 1
6,1,0 0 1,1 -1 0 1 0 0 0 0 1
-3,1,0 0 1,0 1 0 -1 1 0 0 0 -1
-2,1,1 2 0,1 -1 0 0 -1 0 0 0 1
2,1,0 1 0,-1 0 0 -1 1 0 0 0 -1
-6,-1,0 0 1,0 -1 0 1 -1 0 0 0 -1"""

class CompareToInternationalTables:
  def __init__(self):
    self.coord_system_lookup = {
      'ersatz_tests':cubic,'IT96_Table_11_2':cubic,'IT96_Table_11_3':hexag}

  def test_list(self,key):
    niggli_cell=self.coord_system_lookup[key]
    frac = matrix.sqr(niggli_cell.fractionalization_matrix())
    orth = matrix.sqr(niggli_cell.orthogonalization_matrix())
    for item in globals()[key].split('\n')[5:]:
      type_plus_minus = int(item.split(',')[0])
      sense = int(item.split(',')[1])
      direct_space_axis = [int(x) for x in item.split(',')[2].split(' ')]
      reference_W = tuple([int(x) for x in item.split(',')[3].split(' ')])
      D = matrix.col(direct_space_axis)
      cartesian_axis = orth*D
      W_cart = matrix.sqr(
        sgtbx.n_fold_operator_from_axis_direction(
          ev_cart=cartesian_axis, n=abs(type_plus_minus), sense=sense))
      W_frac = frac*W_cart*orth
      W_as_int = matrix.sqr([iround(e) for e in W_frac.elems])
      if type_plus_minus<0: W_as_int = -1 * W_as_int
      assert W_as_int.elems == reference_W

if __name__=='__main__':
  C = CompareToInternationalTables()
  C.test_list('ersatz_tests')
  C.test_list('IT96_Table_11_2') #test non-hexagonal cells
  C.test_list('IT96_Table_11_3') #test hexagonal cells
  print("OK")


 *******************************************************************************


 *******************************************************************************
cctbx/sgtbx/boost_python/tst_sgtbx.py
from __future__ import absolute_import, division, print_function
from cctbx.sgtbx import subgroups
from cctbx.array_family import flex
from cctbx import sgtbx
from cctbx import uctbx
from libtbx import complex_math
from libtbx.utils import format_cpu_times
from libtbx.test_utils import Exception_expected, approx_equal, \
  not_approx_equal, show_diff
import libtbx.load_env
import math
import weakref
from six.moves import range
from six.moves import zip
try:
  from six.moves import cPickle as pickle
except ImportError:
  import pickle
from six.moves import cStringIO as StringIO
import os

ad_hoc_1992_pairs = """\
Abm2 Aem2
Bma2 Bme2
B2cm B2em
C2mb C2me
Cm2a Cm2e
Ac2m Ae2m
Aba2 Aea2
Bba2 Bbe2
B2cb B2eb
C2cb C2ce
Cc2a Cc2e
Ac2a Ae2a
Cmca Cmce
Ccmb Ccme
Abma Aema
Acam Aeam
Bbcm Bbem
Bmab Bmeb
Cmma Cmme
Abmm Aemm
Bmcm Bmem
Ccca Ccce
Abaa Aeaa
Bbcb Bbeb
""".splitlines()

def exercise_symbols():
  s = sgtbx.space_group_symbols("p 2")
  assert s.number() == 3
  assert s.schoenflies() == "C2^1"
  assert s.qualifier() == "b"
  assert s.hermann_mauguin() == "P 1 2 1"
  assert s.extension() == "\0"
  assert s.change_of_basis_symbol() == ""
  assert s.universal_hermann_mauguin() == "P 1 2 1"
  assert s.hall() == " P 2y"
  s = sgtbx.space_group_symbols("p 2", "A")
  assert s.hall() == " P 2y"
  s = sgtbx.space_group_symbols("p 2", "I")
  assert s.hall() == " P 2"
  s = sgtbx.space_group_symbols(146)
  assert s.hall() == " R 3"
  s = sgtbx.space_group_symbols(146, "r")
  assert s.hall() == " P 3*"
  s = sgtbx.space_group_symbols(146, "", "A1983")
  assert s.hall() == " R 3"
  s = sgtbx.space_group_symbols(146, "", "I1952")
  assert s.hall() == " P 3*"
  assert s.point_group_type() == "3"
  assert s.laue_group_type() == "-3"
  assert s.crystal_system() == "Trigonal"
  o = StringIO()
  for hm in ["P2(1)", "P3112", "P3212", "P6122", "P6522", "P6222", "P6422",
             "Pnnn:1"]:
    s = sgtbx.space_group_symbols("%s (z, x, y)" % hm)
    assert s.change_of_basis_symbol() == "z,x,y"
    assert s.universal_hermann_mauguin().endswith(" (z,x,y)")
    print(s.hall(), file=o)
  assert not show_diff(o.getvalue(), """\
 P 2yb (z,x,y)
 P 31 2 (z+1/3,x,y)
 P 32 2 (z+1/6,x,y)
 P 61 2 (z+5/12,x,y)
 P 65 2 (z+1/12,x,y)
 P 62 2 (z+1/3,x,y)
 P 64 2 (z+1/6,x,y)
 P 2 2 -1n (z,x,y)
""")
  s = sgtbx.space_group_symbols("P222(1)")
  assert s.hall() == " P 2c 2"
  s = sgtbx.space_group_symbols("P 31 1 2 (x,y,z-1/3)")
  assert s.hall() == " P 31 2"
  symbols = {
    "  hall p 3  ": "p 3  ",
    " hall:   p 4": "p 4",
    " hall :   p 6": "p 6",
    " p    1 21/n     1": "-P 2yn",
    "C  6  v  #  1": " P 6 -2",
    "1  2": "-C 2y",
  }
  for symbol,hall in symbols.items():
    assert sgtbx.space_group_symbols(symbol).hall() == hall, symbol
  i = sgtbx.space_group_symbol_iterator()
  assert id(i) == id(iter(i))
  assert i.next().universal_hermann_mauguin() == "P 1"
  assert i.next().universal_hermann_mauguin() == "P -1"
  assert len(tuple(i)) == 528
  i = sgtbx.space_group_symbol_iterator()
  n = 0
  for s in i:
    n += 1
    hm = s.universal_hermann_mauguin()
    assert sgtbx.space_group_symbols(hm).universal_hermann_mauguin() == hm
  assert n == 530
  #
  short_symbols_i = [
    "P2", "P21", "B2", "C2", "Pm", "Pb", "Pc", "Bm", "Cm", "Bb", "Cc", "P2/m",
    "P21/m", "B2/m", "C2/m", "P2/b", "P2/c", "P21/b", "P21/c", "B2/b", "C2/c"]
  expected_numbers_i=[3,4,5,5,6,7,7,8,8,9,9,10,11,12,12,13,13,14,14,15,15]
  assert [sgtbx.space_group_symbols(short, "I").number()
    for short in short_symbols_i] == expected_numbers_i
  short_symbols_a = [
   "P2", "P21", "C2", "A2", "I2", "Pm", "Pc", "Pn", "Pa", "Cm", "Am", "Im",
   "Cc", "An", "Ia", "Aa", "Cn", "Ic", "P2/m", "P21/m", "C2/m", "A2/m",
   "I2/m", "P2/c", "P2/n", "P2/a", "P21/c", "P21/n", "P21/a", "C2/c", "A2/n",
   "I2/a", "A2/a", "C2/n", "I2/c"]
  expected_numbers_a = [
    3,4,5,5,5,6,7,7,7,8,8,8,9,9,9,9,9,9,10,11,
    12,12,12,13,13,13,14,14,14,15,15,15,15,15,15]
  assert [sgtbx.space_group_symbols(short, "A").number()
    for short in short_symbols_a] == expected_numbers_a
  symbols_cpp = libtbx.env.under_dist("cctbx", "sgtbx/symbols.cpp")
  if (not os.path.isfile(symbols_cpp)):
    print("Skipping checks based on %s: file not available" % symbols_cpp)
  else:
    f = open(symbols_cpp)
    for volume,table_name,short_symbols in [
          ("I", "vol_i_short_mono_hm_dict", short_symbols_i),
          ("A", "vol_a_short_mono_hm_dict", short_symbols_a)]:
      for line in f:
        if (line.find(table_name) > 0): break
      else: raise AssertionError
      symbol_pairs = []
      for line in f:
        if (line.find("{ 0, 0 },") > 0): break
        for c in '{},"': line = line.replace(c,"")
        symbol_pairs.append(line.split())
      else: raise AssertionError
      assert len(symbol_pairs) == len(short_symbols)
      for expected_short,(short,long) in zip(short_symbols,symbol_pairs):
        assert expected_short == short
        assert sgtbx.space_group_symbols(short, volume).hall() \
            == sgtbx.space_group_symbols(long, volume).hall()
    f.close()
  #
  s = sgtbx.space_group_symbols
  try: s("(x,y,z)")
  except RuntimeError as e:
    assert str(e) == "cctbx Error: Space group symbol not recognized: (x,y,z)"
  else: raise Exception_expected
  try: s("P3:2")
  except RuntimeError as e:
    assert str(e) == "cctbx Error: Space group symbol not recognized: P3:2"
  else: raise Exception_expected
  try: s(300)
  except RuntimeError as e:
    assert str(e) == "cctbx Error: Space group number out of range: 300"
  else: raise Exception_expected
  try: s(space_group_number=1, table_id="x")
  except RuntimeError as e:
    assert str(e) == "cctbx Error: table_id not recognized: x"
  else: raise Exception_expected
  for extension in ["1", ":1"]:
    try: s(space_group_number=75, extension=extension)
    except RuntimeError as e:
      assert str(e) == "cctbx Error: Space group symbol not recognized: 75:1"
    else: raise Exception_expected
  try: s(space_group_number=75, extension="x")
  except RuntimeError as e:
    assert str(e) == "cctbx Error: Space group symbol not recognized: 75:x"
  else: raise Exception_expected
  #
  for cabc,cxyz in [("2/3a+1/3b+1/3c, -1/3a+1/3b+1/3c, -1/3a-2/3b+1/3c",
                     "x+z,-x+y+z,-y+z"),
                    ("-1/3a-2/3b+1/3c, 2/3a+1/3b+1/3c, -1/3a+1/3b+1/3c",
                     "x+z,-x+y+z,-y+z")]:
    symbols = s("R 3 m :h (%s)" % cabc)
    assert str(sgtbx.space_group_info(group=sgtbx.space_group(symbols))) \
        == "R 3 m :R"
  #
  a83_symbols = []
  for symbol in "Aem2 Aea2 Cmce Cmme Ccce CCCE:1".split():
    a83_symbols.append(str(sgtbx.space_group_info(symbol=symbol)))
  assert a83_symbols == [
    "A b m 2", "A b a 2", "C m c a", "C m m a", "C c c a :2", "C c c a :1"]
  for pair in ad_hoc_1992_pairs:
    o,n = [sgtbx.space_group_info(symbol=symbol) for symbol in pair.split()]
    assert o.group() == n.group()
  #
  def check(symbols, uhm):
    for symbol in symbols:
      s = sgtbx.space_group_symbols(symbol=symbol, table_id="")
      assert s.universal_hermann_mauguin() == uhm
  check(["R3", "H3", " h 3 "], "R 3 :H")
  check(["R32", "H32", "_h_3_2_"], "R 3 2 :H")
  check(["R3m", "H3m", " h 3 m "], "R 3 m :H")
  check(["R3c", "H3c", "_h_3_c_"], "R 3 c :H")
  check(["R-3", "H-3", " h -3 "], "R -3 :H")
  check(["R-3m", "H-3m", " h -3 m "], "R -3 m :H")
  check(["R-3c", "H-3c", " h -3 c "], "R -3 c :H")

def exercise_tr_vec():
  tr_vec = sgtbx.tr_vec
  t = tr_vec()
  assert t.num() == (0,0,0)
  assert t.den() == sgtbx.sg_t_den
  t = tr_vec(13)
  assert t.num() == (0,0,0)
  assert t.den() == 13
  t = tr_vec((1,2,3))
  assert t.num() == (1,2,3)
  assert t.den() == sgtbx.sg_t_den
  t = tr_vec((1,2,3), 13)
  assert t.num() == (1,2,3)
  assert t.den() == 13
  assert t == t
  assert not t != t
  s = tr_vec((1,2,3), 12)
  assert not t == s
  assert t != s
  s = tr_vec((1,2,4), 13)
  assert not t == s
  assert t != s
  assert t.is_valid()
  assert not t.is_zero()
  t = tr_vec(0)
  assert not t.is_valid()
  assert t.is_zero()
  t = tr_vec((2,4,-2)).new_denominator(6)
  assert t.den() == 6
  assert t.num() == (1,2,-1)
  t = t.scale(3)
  assert t.den() == 18
  assert t.num() == (3,6,-3)
  t = t.mod_positive()
  assert t.den() == 18
  assert t.num() == (3,6,15)
  t = t.mod_short()
  assert t.den() == 18
  assert t.num() == (3,6,-3)
  t = t.cancel()
  assert t.den() == 6
  assert t.num() == (1,2,-1)
  assert t.as_double() == (1./6,2./6,-1./6)
  a = tr_vec((1,2,3), 12)
  b = tr_vec((9,0,1), 12)
  c = a.plus(b)
  assert c.den() == 6
  assert c.num() == (5,1,2)
  c = a.minus(b)
  assert c.den() == 6
  assert c.num() == (-4,1,1)
  a = tr_vec((-1,0,2), 4)
  assert str(a) == "-1/4,0,1/2"
  assert a.as_string() == "-1/4,0,1/2"
  assert a.as_string(True) == "-.25,0,.5"
  assert a.as_string(False, ";") == "-1/4;0;1/2"

def exercise_rot_mx():
  tr_vec = sgtbx.tr_vec
  rot_mx = sgtbx.rot_mx
  rot_mx_info = sgtbx.rot_mx_info
  r = rot_mx()
  assert r.den() == 1
  assert r.num() == (1,0,0,0,1,0,0,0,1)
  r = rot_mx(2)
  assert r.den() == 2
  assert r.num() == (2,0,0,0,2,0,0,0,2)
  r = rot_mx(2, 3)
  assert r.den() == 2
  assert r.num() == (6,0,0,0,6,0,0,0,6)
  r = rot_mx((1,0,-1,1,1,0,0,-1,-1))
  assert r.den() == 1
  assert r.num() == (1,0,-1,1,1,0,0,-1,-1)
  r = rot_mx((1,0,-1,1,1,0,0,-1,-1), 2)
  assert r.den() == 2
  assert r.num() == (1,0,-1,1,1,0,0,-1,-1)
  assert r == r
  assert not r != r
  s = rot_mx((1,0,-1,1,1,0,0,-1,-1), 3)
  assert not r == s
  assert r != s
  s = rot_mx((1,0,-1,2,1,0,0,-1,-1), 2)
  assert not r == s
  assert r != s
  assert r.is_valid()
  assert not r.is_unit_mx()
  r = rot_mx(0)
  assert not r.is_valid()
  r = rot_mx()
  assert r.is_unit_mx()
  r = rot_mx(2, 1)
  assert r.is_unit_mx()
  r = rot_mx().minus_unit_mx()
  assert r.den() == 1
  assert r.num() == (0,0,0,0,0,0,0,0,0)
  r = rot_mx((1,0,-1,1,1,0,0,-1,-1)).minus_unit_mx()
  assert r.den() == 1
  assert r.num() == (0,0,-1,1,0,0,0,-1,-2)
  r = rot_mx(12, 3).new_denominator(4)
  assert r.den() == 4
  assert r.num() == (12,0,0,0,12,0,0,0,12)
  r = r.scale(3)
  assert r.den() == 12
  assert r.num() == (36,0,0,0,36,0,0,0,36)
  assert r.determinant() == 27
  r = rot_mx(range(9), 2).transpose()
  assert r.num() == (0, 3, 6, 1, 4, 7, 2, 5, 8)
  assert r.den() == 2
  assert rot_mx().inverse().num() == rot_mx().num()
  r3 = (0,-1,0,1,-1,0,0,0,1)
  r = rot_mx(r3).inverse()
  assert r.den() == 1
  assert r.num() == (-1,1,0,-1,0,0,0,0,1)
  assert rot_mx(r3).inverse().inverse().num() == r3
  r = rot_mx((3,0,0,0,3,0,0,0,3), 6).cancel()
  assert r.den() == 2
  assert r.num() == (1,0,0,0,1,0,0,0,1)
  r = rot_mx((0,-1,1,1,0,1,-1,1,1)).scale(12)
  s = r.inverse()
  assert s.den() == 12
  assert s.num() == (-4,8,-4,-8,4,4,4,4,4)
  s = r.inverse_cancel()
  assert s.den() == 3
  assert s.num() == (-1,2,-1,-2,1,1,1,1,1)
  assert rot_mx().multiply(rot_mx()).is_unit_mx()
  assert rot_mx(r3).multiply(rot_mx(r3)) == rot_mx(r3).inverse()
  assert rot_mx(r3).multiply(rot_mx(r3).multiply(rot_mx(r3))).is_unit_mx()
  assert rot_mx().multiply(tr_vec((1,2,3), 12)) == tr_vec((1,2,3), 12)
  assert rot_mx().multiply(tr_vec((2,4,6), 12)) == tr_vec((1,2,3), 6)
  assert rot_mx(r3).multiply(tr_vec((1,2,3), 8)) == tr_vec((-2,-1,3), 8)
  assert rot_mx(r3).multiply(tr_vec((4,-4,2), 8)) == tr_vec((2,4,1), 4)
  assert rot_mx((6,0,0,0,6,0,0,0,6), 3).divide(2) == rot_mx()
  assert rot_mx(r3).divide(2).as_double() == (0,-1./2,0,1./2,-1./2,0,0,0,1./2)
  assert rot_mx(r3).type() == 3
  assert rot_mx(r3).order() == 3
  assert rot_mx(r3).order(3) == 3
  assert rot_mx(1, -1).type() == -1
  assert rot_mx(1, -1).order() == 2
  assert rot_mx(1, -1).order(-1) == 2
  assert rot_mx().accumulate() == rot_mx((1,0,0,0,1,0,0,0,1))
  assert rot_mx((-1,0,0,0,-1,0,0,0,-1)).accumulate() \
      == rot_mx((0,0,0,0,0,0,0,0,0))
  assert rot_mx(r3).accumulate() == rot_mx((0,0,0,0,0,0,0,0,3))
  assert rot_mx((0,1,0,-1,0,0,0,0,-1)).accumulate() \
      == rot_mx((0,0,0,0,0,0,0,0,0))
  i = rot_mx_info(rot_mx())
  assert i.type() == 1
  assert i.ev() == (0,0,0)
  assert i.basis_of_invariant() == ((1,0,0), (0,1,0), (0,0,1))
  assert i.sense() == 0
  i = rot_mx().info()
  assert i.type() == 1
  assert i.ev() == (0,0,0)
  assert i.basis_of_invariant() == ((1,0,0), (0,1,0), (0,0,1))
  assert i.sense() == 0
  i = rot_mx_info(rot_mx((-1,0,0,0,-1,0,0,0,1)))
  assert i.type() == 2
  assert i.ev() == (0,0,1), i.ev()
  assert i.basis_of_invariant() == (i.ev(),)
  assert i.sense() == 0
  i = rot_mx_info(rot_mx((-1,0,0,0,1,0,0,0,-1)))
  assert i.type() == 2
  assert i.ev() == (0,1,0), i.ev()
  assert i.basis_of_invariant() == (i.ev(),)
  assert i.sense() == 0
  i = rot_mx_info(rot_mx((1,0,0,0,-1,0,0,0,-1)))
  assert i.type() == 2
  assert i.ev() == (1,0,0), i.ev()
  assert i.basis_of_invariant() == (i.ev(),)
  i = rot_mx_info(rot_mx((1,0,0,0,1,0,0,0,-1)))
  assert i.type() == -2
  assert i.ev() == (0,0,1), i.ev()
  assert i.basis_of_invariant() == ((1,0,0), (0,1,0))
  assert i.sense() == 0
  i = rot_mx_info(rot_mx((1,0,0,0,-1,0,0,0,1)))
  assert i.type() == -2
  assert i.ev() == (0,1,0), i.ev()
  assert i.basis_of_invariant() == ((1,0,0), (0,0,1))
  assert i.sense() == 0
  i = rot_mx_info(rot_mx((-1,0,0,0,1,0,0,0,1)))
  assert i.type() == -2
  assert i.ev() == (1,0,0), i.ev()
  assert i.basis_of_invariant() == ((0,1,0), (0,0,1))
  assert i.sense() == 0
  i = rot_mx_info(rot_mx((0,-1,0,-1,0,0,0,0,1)))
  assert i.type() == -2
  assert i.ev() == (1,1,0), i.ev()
  assert i.basis_of_invariant() == ((0,0,1), (-1,1,0))
  i = rot_mx_info(rot_mx((1,0,0,0,0,1,0,1,0)))
  assert i.type() == -2
  assert i.ev() == (0,-1,1), i.ev()
  assert i.basis_of_invariant() == ((1,0,0), (0,1,1))
  assert i.sense() == 0
  i = rot_mx_info(rot_mx((0,-1,0,1,-1,0,0,0,1)))
  assert i.type() == 3
  assert i.ev() == (0,0,1), i.ev()
  assert i.basis_of_invariant() == (i.ev(), )
  assert i.sense() == 1
  i = rot_mx_info(rot_mx((0,-1,0,1,-1,0,0,0,1)).inverse())
  assert i.type() == 3
  assert i.ev() == (0,0,1), i.ev()
  assert i.basis_of_invariant() == (i.ev(), )
  assert i.sense() == -1
  i = rot_mx_info(rot_mx((0,1,0,-1,1,0,0,0,-1)))
  assert i.type() == -3
  assert i.ev() == (0,0,1), i.ev()
  assert i.basis_of_invariant() == ()
  assert i.sense() == 1
  i = rot_mx_info(rot_mx((0,1,0,-1,1,0,0,0,-1)).inverse())
  assert i.type() == -3
  assert i.ev() == (0,0,1), i.ev()
  assert i.basis_of_invariant() == ()
  assert i.sense() == -1
  i = rot_mx_info(rot_mx((0,0,1,0,1,0,-1,0,0)))
  assert i.type() == 4
  assert i.ev() == (0,1,0), i.ev()
  assert i.basis_of_invariant() == (i.ev(),)
  assert i.sense() == 1
  i = rot_mx_info(rot_mx((0,0,1,0,1,0,-1,0,0)).inverse())
  assert i.type() == 4
  assert i.ev() == (0,1,0), i.ev()
  assert i.basis_of_invariant() == (i.ev(),)
  assert i.sense() == -1
  i = rot_mx_info(rot_mx((0,0,-1,0,-1,0,1,0,0)))
  assert i.type() == -4
  assert i.ev() == (0,1,0), i.ev()
  assert i.basis_of_invariant() == ()
  assert i.sense() == 1
  i = rot_mx_info(rot_mx((0,0,-1,0,-1,0,1,0,0)).inverse())
  assert i.type() == -4
  assert i.ev() == (0,1,0), i.ev()
  assert i.basis_of_invariant() == ()
  assert i.sense() == -1
  i = rot_mx_info(rot_mx((1,0,0,0,1,-1,0,1,0)))
  assert i.type() == 6
  assert i.ev() == (1,0,0), i.ev()
  assert i.basis_of_invariant() == (i.ev(),)
  assert i.sense() == 1
  i = rot_mx_info(rot_mx((1,0,0,0,1,-1,0,1,0)).inverse())
  assert i.type() == 6
  assert i.ev() == (1,0,0), i.ev()
  assert i.basis_of_invariant() == (i.ev(),)
  assert i.sense() == -1
  i = rot_mx_info(rot_mx((-1,0,0,0,-1,1,0,-1,0)))
  assert i.type() == -6
  assert i.ev() == (1,0,0), i.ev()
  assert i.basis_of_invariant() == ()
  assert i.sense() == 1
  i = rot_mx_info(rot_mx((-1,0,0,0,-1,1,0,-1,0)).inverse())
  assert i.type() == -6
  assert i.ev() == (1,0,0), i.ev()
  assert i.basis_of_invariant() == ()
  assert i.sense() == -1
  i = rot_mx_info(rot_mx((0,0,1,1,0,0,0,1,0)))
  assert i.type() == 3
  assert i.ev() == (1,1,1), i.ev()
  assert i.basis_of_invariant() == (i.ev(),)
  assert i.sense() == 1
  i = rot_mx_info(rot_mx((0,0,1,1,0,0,0,1,0)).inverse())
  assert i.type() == 3
  assert i.ev() == (1,1,1), i.ev()
  assert i.basis_of_invariant() == (i.ev(),)
  assert i.sense() == -1
  i = rot_mx_info(rot_mx((0,-1,0,-1,0,0,0,0,-1)))
  assert i.type() == 2
  assert i.ev() == (-1,1,0), i.ev()
  assert i.basis_of_invariant() == (i.ev(),)
  assert i.sense() == 0
  i = rot_mx_info(rot_mx((-1,1,0,0,1,0,0,0,-1)))
  assert i.type() == 2
  assert i.ev() == (1,2,0), i.ev()
  assert i.basis_of_invariant() == (i.ev(),)
  r = rot_mx((-1,1,0,0,1,0,0,0,-1))
  assert r.as_xyz() == "-x+y,y,-z"
  assert r.as_hkl() == "-h,h+k,-l"
  r = rot_mx([-2,3,5,1,4,-2,-3,2,-1],6)
  assert approx_equal(r * [0.2,0.1,-0.5], [-0.4333333, 0.2666667, 0.01666667])
  assert approx_equal([0.2,0.1,-0.5] * r, [0.2, 0, 0.21666667])
  assert str(r * sgtbx.vec3_rat_from_str("1/5,1/10,-1/2")) \
      == "(-13/30, 4/15, 1/60)"

def exercise_rt_mx():
  tr_vec = sgtbx.tr_vec
  rot_mx = sgtbx.rot_mx
  rt_mx = sgtbx.rt_mx
  s = rt_mx()
  assert s.r().den() == 1
  assert s.t().den() == sgtbx.sg_t_den
  s = rt_mx(2)
  assert s.r().den() == 2
  assert s.t().den() == sgtbx.sg_t_den
  s = rt_mx(2, 3)
  assert s.r().den() == 2
  assert s.t().den() == 3
  r = rot_mx((-1,1,0,0,1,0,0,0,-1))
  t = tr_vec((1,2,3))
  s = rt_mx(r, t)
  assert s.r() == r
  assert s.t() == t
  s = rt_mx(r)
  assert s.r() == r
  assert s.t() == tr_vec()
  s = rt_mx(r, 3)
  assert s.r() == r
  assert s.t() == tr_vec(3)
  s = rt_mx(t)
  assert s.r() == rot_mx()
  assert s.t() == t
  s = rt_mx(t, 3)
  assert s.r() == rot_mx(3)
  assert s.t() == t
  p = sgtbx.parse_string("x,y,z")
  assert p.string() == "x,y,z"
  s = rt_mx(p)
  assert s.is_unit_mx()
  p = sgtbx.parse_string("-x,-y+1/2,z")
  s = rt_mx(p)
  assert s.as_xyz() == "-x,-y+1/2,z"
  p = sgtbx.parse_string("-x,-y+1/2,z;")
  s = rt_mx(p, ";")
  assert s.as_xyz() == "-x,-y+1/2,z"
  p = sgtbx.parse_string("-  x,- y + 1/2, z ;")
  s = rt_mx(p, ";", 2)
  assert s.r().den() == 2
  assert s.as_xyz() == "-x,-y+1/2,z"
  p = sgtbx.parse_string("-  x,-1* y + .5, z ;")
  s = rt_mx(p, ";", 2, 4)
  assert s.r().den() == 2
  assert s.t().den() == 4
  assert s.as_xyz() == "-x,-y+1/2,z"
  s = rt_mx("1/2+x,-y,z")
  assert s.as_xyz() == "x+1/2,-y,z"
  s = rt_mx("x-y,x,z+5/6#", "#")
  assert s.as_xyz() == "x-y,x,z+5/6"
  s = rt_mx("-y,x-y,z+.66666666#", "#", 3)
  assert s.r().den() == 3
  assert s.as_xyz() == "-y,x-y,z+2/3"
  s = rt_mx("y,y-x,z+1/6#", "#", 3, 6)
  assert s.r().den() == 3
  assert s.t().den() == 6
  assert s.as_xyz() == "y,-x+y,z+1/6"
  assert rt_mx("y,y-x,z+1/6") == rt_mx("y,-x+y,z+1/6")
  assert not rt_mx("y,y-x,z+1/6") != rt_mx("y,-x+y,z+1/6")
  assert not rt_mx("y,y-x,z-1/6") == rt_mx("y,-x+y,z+1/6")
  assert rt_mx("y,y-x,z-1/6") != rt_mx("y,-x+y,z+1/6")
  assert rt_mx().is_valid()
  assert not rt_mx(0).is_valid()
  assert rt_mx("-x,-y,-z", "", 2, 3).unit_mx() == rt_mx(2, 3)
  assert rt_mx().is_unit_mx()
  assert not rt_mx("-x,-y,-z").is_unit_mx()
  assert rt_mx("0.667+x, 0.333+y, 0.333+z").as_xyz() == 'x+2/3,y+1/3,z+1/3'
  s = rt_mx("y,y-x,z+1/4", "", 3, 8)
  assert str(s) == "y,-x+y,z+1/4"
  assert s.as_xyz() == str(s)
  assert s.as_xyz(False) == str(s)
  assert s.as_xyz(True) == "y,-x+y,z+.25"
  assert s.as_xyz(False, False) == str(s)
  assert s.as_xyz(False, True) == "y,-x+y,1/4+z"
  assert s.as_xyz(False, False, "xyz") == str(s)
  assert s.as_xyz(False, False, "abc") == "b,-a+b,c+1/4"
  assert s.as_xyz(False, False, "xyz", ",") == str(s)
  assert s.as_xyz(False, False, "xyz", " ; ") == "y ; -x+y ; z+1/4"
  assert s.as_int_array() == (0,3,0,-3,3,0,0,0,3,0,0,2)
  assert s.as_double_array() == (0,1,0,-1,1,0,0,0,1,0,0,0.25)
  assert s.new_denominators(6).r().den() == 6
  assert s.new_denominators(9,16).r().den() == 9
  assert s.new_denominators(9,16).t().den() == 16
  assert s.new_denominators(rt_mx("x,y,z", "", 9, 16)).r().den() == 9
  assert s.new_denominators(rt_mx("x,y,z", "", 9, 16)).t().den() == 16
  assert rt_mx("x-1/2,y+4/3,z-1/3").mod_positive() \
      == rt_mx("x+1/2,y+1/3,z+2/3")
  assert rt_mx("x-1/2,y+5/3,z-2/3").mod_short() \
      == rt_mx("x+1/2,y-1/3,z+1/3")
  assert rt_mx("x-y,x,z+5/6").inverse() == rt_mx("y,-x+y,z-5/6")
  s = rt_mx("y,y-x,z+1/6")
  assert s.refine_gridding((1,1,1)) == (1,1,6)
  assert rt_mx("y,y-x,z+1/6", "", 2, 24).cancel() \
      == rt_mx("y,y-x,z+1/6", "", 1, 6)
  assert rt_mx("x-y,x,z+5/6").inverse_cancel() \
      == rt_mx("y,-x+y,z-5/6")
  assert rt_mx("x-y,x,z+5/6").inverse_cancel() \
      == rt_mx("y,-x+y,z-5/6").cancel()
  assert rt_mx("x-y,x,z+5/6").multiply(rt_mx("y,-x+y,z-5/6")).is_unit_mx()
  i = sgtbx.translation_part_info(rt_mx())
  assert i.intrinsic_part().is_zero()
  assert i.location_part().is_zero()
  assert i.origin_shift().is_zero()
  i = sgtbx.translation_part_info(rt_mx("-y,x-y,z+1/3"))
  assert i.intrinsic_part().as_double() == (0,0,1./3)
  assert i.location_part().is_zero()
  assert i.origin_shift().is_zero()
  i = sgtbx.translation_part_info(rt_mx("-x+y,-x+1/4,z+2/3"))
  assert i.intrinsic_part().as_double() == (0,0,2./3)
  assert i.location_part().as_double() == (0,-1./4,0)
  assert i.origin_shift().as_double() == (1./12,1./6,0)
  assert approx_equal(rt_mx("z,x,y") * (2,3,4), (4,2,3))
  assert str(rt_mx("z,x,y") * sgtbx.vec3_rat_from_str("2,-1/7,10/-4")) \
      == "(-5/2, 2, -1/7)"
  r = (-1,1,0,0,1,0,0,0,-1)
  t = (1/12.,2/12.,3/12.)
  assert str(rt_mx(r, t)) == "-x+y+1/12,y+1/6,-z+1/4"
  assert str(rt_mx(r, t, 2)) == "-x+y+1/12,y+1/6,-z+1/4"
  assert str(rt_mx(r, t, 2, 24)) == "-x+y+1/12,y+1/6,-z+1/4"
  assert str(rt_mx("+0*x-1*y+0*z,+0*x+0*y+1*z,-1*x+0*y-1*z")) == "-y,z,-x-z"
  assert str(rt_mx("-x+y,-x+1/4,z+2/3") + (2,-1,3)) == "-x+y+2,-x-3/4,z+11/3"
  for m in [rt_mx("x,y,z"), rt_mx(0,0), rt_mx("-x+y+2,-x-3/4,z+11/3")]:
    p = pickle.dumps(m)
    l = pickle.loads(p)
    assert l == m
  v = sgtbx.stl_vector_rt_mx()
  v.append(rt_mx("-x+y+2,-x-3/4,z+11/3"))
  v.append(rt_mx("x,y,z"))
  assert [str(elem) for elem in v] == ["-x+y+2,-x-3/4,z+11/3", "x,y,z"]
  p = pickle.dumps(v)
  l = pickle.loads(p)
  assert [str(elem) for elem in l] == ["-x+y+2,-x-3/4,z+11/3", "x,y,z"]
  l.extend(v)
  assert l.size() == 4
  l.clear()
  assert l.size() == 0
  assert str(rt_mx("z,x,y") + (1,2,-3)) == "z+1,x+2,y-3"
  assert str(rt_mx("z+1/6,x,y") + tr_vec((1,2,-3),12)) == "z+1/4,x+1/6,y-1/4"
  assert str(rt_mx("-x+y,y,-z")) == "-x+y,y,-z"
  assert str(rt_mx("-h,h+k,-l")) == "-x+y,y,-z"
  try: rt_mx("h,x,z")
  except ValueError as e:
    assert not show_diff(str(e), """\
Parse error: mix of x,y,z and h,k,l notation:
  h,x,z
  __^""")
  else: raise Exception_expected
  try: rt_mx("")
  except ValueError as e:
    assert not show_diff(str(e), """\
Parse error: unexpected end of input:
  \n\
  ^""")
  else: raise Exception_expected
  try: rt_mx("x, ")
  except ValueError as e:
    assert not show_diff(str(e), """\
Parse error: unexpected end of input:
  x, \n\
  ___^""")
  else: raise Exception_expected
  try: rt_mx("x")
  except ValueError as e:
    assert not show_diff(str(e), """\
Parse error: not enough row expressions:
  x
  _^""")
  else: raise Exception_expected
  try: rt_mx("x,y,x,z")
  except ValueError as e:
    assert not show_diff(str(e), """\
Parse error: too many row expressions:
  x,y,x,z
  _____^""")
  try: rt_mx("x++")
  except ValueError as e:
    assert not show_diff(str(e), """\
Parse error: unexpected character:
  x++
  __^""")
  try: rt_mx("a, b, c")
  except ValueError as e:
    assert not show_diff(str(e), """\
Parse error: a,b,c notation not supported in this context:
  a, b, c
  ^""")
  else: raise Exception_expected
  #
  s = rt_mx("y-13/2,y-x+8/3,z+1/4")
  site_frac_1 = (4.2, -5.2, 8.9)
  site_frac_2 = (-2.1, -7.2, 12.9)
  assert s.unit_shifts_minimum_distance(
    site_frac_1=site_frac_1,
    site_frac_2=site_frac_2) == (18, -3, -4)
  su = s.add_unit_shifts_minimum_distance(
    site_frac_1=site_frac_1,
    site_frac_2=site_frac_2)
  assert str(su) == "y+23/2,-x+y-1/3,z-15/4"
  assert approx_equal(su*site_frac_2, (4.3, -5.4333333, 9.15))
  #
  try:
    sgtbx.rt_mx(symbol="h,k,1", r_den=12, t_den=144)
  except ValueError as e:
    assert not show_diff(str(e), """\
h,k,l matrix symbol must not include a translation part:
  input symbol: "h,k,1"
  translation part: (0, 0, 1)""")
  else: raise Exception_expected

def exercise_change_of_basis_op():
  rt_mx = sgtbx.rt_mx
  change_of_basis_op = sgtbx.change_of_basis_op
  c = change_of_basis_op(rt_mx(), rt_mx())
  assert c.is_identity_op()
  c = change_of_basis_op(rt_mx())
  assert c.is_identity_op()
  c = change_of_basis_op("z,x,y")
  c = change_of_basis_op("z,x,y;junk", ";")
  c = change_of_basis_op("z,x,y;junk", ";", 3)
  c = change_of_basis_op("z,x,y;junk", ";", 3, 4)
  assert not c.is_identity_op()
  assert c.c().r().den() == 3
  assert c.c().t().den() == 4
  assert c.c_inv().r().den() == 3
  assert c.c_inv().t().den() == 4
  assert str(c.c()) == "z,x,y"
  assert str(c.c_inv()) == "y,z,x"
  d = c.identity_op()
  assert d.is_identity_op()
  assert d.c().r().den() == 3
  assert d.c().t().den() == 4
  assert d.c_inv().r().den() == 3
  assert d.c_inv().t().den() == 4
  assert str(d.c()) == "x,y,z"
  assert str(d.c_inv()) == "x,y,z"
  assert d.is_valid()
  d = change_of_basis_op(0, 0)
  assert not d.is_valid()
  d = c.new_denominators(4, 5)
  assert d.c().r().den() == 4
  assert d.c().t().den() == 5
  d = d.new_denominators(c)
  assert d.c().r().den() == 3
  assert d.c().t().den() == 4
  c = change_of_basis_op("z,x,y")
  assert c.select(False) == c.c()
  assert c.select(True) == c.c_inv()
  d = c.inverse()
  assert c.c() == d.c_inv()
  assert d.c() == c.c_inv()
  c = change_of_basis_op("x+3/2,y-5/4,z+1/3")
  c.mod_positive_in_place()
  assert str(c.c()) == "x+1/2,y+3/4,z+1/3"
  assert str(c.mod_short().c()) == "x+1/2,y-1/4,z+1/3"
  assert str(c.mod_short().c_inv()) == "x+1/2,y+1/4,z-1/3"
  c.mod_short_in_place()
  assert str(c.c()) == "x+1/2,y-1/4,z+1/3"
  assert str(c.c_inv()) == "x+1/2,y+1/4,z-1/3"
  c = change_of_basis_op("z,x,y")
  assert str(c.apply(rt_mx("-x,-y,z"))) == "x,-y,-z"
  xf = c((0.1,0.2,0.3))
  for i in range(3): assert approx_equal(xf[i], (0.3,0.1,0.2)[i])
  c.update(change_of_basis_op("z,x,y"))
  assert str(c.c()) == "y,z,x"
  assert (c * c.inverse()).is_identity_op()
  c = change_of_basis_op("z,x,y")
  u = uctbx.unit_cell((2,3,5))
  assert approx_equal(c.apply(u).parameters(), (5,2,3,90,90,90))
  assert c.apply((1,2,3)) == (3,1,2)
  i = flex.miller_index(((1,2,3),(2,3,4)))
  assert tuple(c.apply(i)) == ((3,1,2),(4,2,3))
  assert c.apply_results_in_non_integral_indices(miller_indices=i).size() == 0
  d = change_of_basis_op("-x,-y,2z")
  assert list(d.apply_results_in_non_integral_indices(miller_indices=i)) == [0]
  i = i.select(flex.size_t([1,0]))
  assert list(d.apply_results_in_non_integral_indices(miller_indices=i)) == [1]
  s = pickle.dumps(c)
  l = pickle.loads(s)
  assert str(c.c()) == str(l.c())
  for s in ["-x+y,y,-z", "-h,h+k,-l", "-a,a+b,-c"]:
    c = change_of_basis_op(s)
    assert c.as_xyz() == "-x+y,y,-z"
    assert c.as_hkl() == "-h,h+k,-l"
    assert c.as_abc() == "-a,a+b,-c"
  c = change_of_basis_op("-a+1/8,a+b-1/3,-c+2/3")
  assert c.as_xyz() == "-x+y+11/24,y+1/3,-z+2/3"
  assert c.as_abc() == "-a+1/8,a+b-1/3,-c+2/3"
  assert c.inverse().as_xyz() == "-x+y+1/8,y-1/3,-z+2/3"
  a = c.c().as_4x4_rational()
  b = c.c_inv().as_4x4_rational()
  assert str(a.elems).replace(" ","") \
      == "(-1,1,0,11/24,0,1,0,1/3,0,0,-1,2/3,0,0,0,1)"
  assert (a*b).elems == (1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)
  assert str(b.transpose().elems).replace(" ","") \
      == "(-1,0,0,0,1,1,0,0,0,0,-1,0,1/8,-1/3,2/3,1)"
  assert c.symbol() == "-a+1/8,a+b-1/3,-c+2/3"
  assert c.inverse().symbol() == "-x+y+1/8,y-1/3,-z+2/3"
  assert str(c) == c.symbol()
  assert str(c.inverse()) == c.inverse().symbol()

def exercise_space_group():
  tr_vec = sgtbx.tr_vec
  rt_mx = sgtbx.rt_mx
  space_group = sgtbx.space_group
  g = space_group()
  p = sgtbx.parse_string("P 1")
  g = space_group(p)
  p = sgtbx.parse_string("P 1")
  g = space_group(p, False)
  p = sgtbx.parse_string("P 1")
  g = space_group(p, False, False)
  p = sgtbx.parse_string("P 1")
  g = space_group(p, False, False, False)
  assert g.t_den() == sgtbx.sg_t_den
  p = sgtbx.parse_string("P 1")
  g = space_group(p, False, False, False, 2*sgtbx.sg_t_den)
  assert g.t_den() == 2*sgtbx.sg_t_den
  g = space_group("P 1")
  g = space_group("P 1", True)
  g = space_group("1", False, True)
  g = space_group("1", False, True, True)
  g = space_group("1", False, True, True, 3*sgtbx.sg_t_den)
  assert g.t_den() == 3*sgtbx.sg_t_den
  g = space_group(sgtbx.space_group_symbols(1))
  g = space_group(g)
  g.reset()
  assert g.r_den() == 1
  assert g.t_den() == sgtbx.sg_t_den
  g.reset(6)
  assert g.r_den() == 1
  assert g.t_den() == 6
  g.reset()
  assert g.expand_ltr(tr_vec()) is g
  assert g.n_ltr() == 1
  g.reset()
  g.expand_ltr(tr_vec((6,0,0)))
  assert g.n_ltr() == 2
  g.reset()
  g.expand_ltr(tr_vec((4,0,0)))
  assert g.n_ltr() == 3
  g.reset()
  assert g.f_inv() == 1
  assert not g.is_centric()
  assert not g.is_origin_centric()
  assert g.expand_inv(tr_vec((0,0,0))) is g
  assert g.f_inv() == 2
  assert g.is_centric()
  assert g.is_origin_centric()
  g.reset()
  g.expand_inv(tr_vec((1,2,3)))
  assert g.is_centric()
  assert not g.is_origin_centric()
  g.reset()
  assert g.n_smx() == 1
  assert g.expand_smx(rt_mx("-x,-y,z")) is g
  assert g.n_smx() == 2
  g = sgtbx.space_group()
  assert g.expand_smx("-x,y,-z") is g
  assert not g.is_tidy()
  assert g.make_tidy() is g
  assert g.is_tidy()
  assert g.order_z() == 2
  g.expand_smx("-x,-y,-z")
  assert g.order_z() == 4
  assert not g.is_tidy()
  for s in g:
    assert g.contains(smx=s)
  assert not g.contains(smx=sgtbx.rt_mx("y,z,x"))
  for z,n in (("P",1), ("a",2), ("B",2),("c",2), ("I",2), ("r",3), ("F",4)):
    g.reset()
    g.expand_conventional_centring_type(z)
    assert g.n_ltr() == n
  p = sgtbx.parse_string("P 4")
  g.reset()
  g.parse_hall_symbol(p)
  assert g.order_z() == 4
  assert len(g) == 4
  assert g.n_equivalent_positions() == 4
  p = sgtbx.parse_string("P 2x")
  g.parse_hall_symbol(p, True)
  assert g.order_z() == 8
  p = sgtbx.parse_string("-1")
  g.parse_hall_symbol(p, False, True)
  assert g.order_z() == 16
  g = space_group("P 4")
  c = sgtbx.change_of_basis_op("x,y,z")
  h = g.change_basis(c)
  assert g == h
  c = sgtbx.change_of_basis_op("z,x,y")
  h = g.change_basis(c)
  assert g != h
  g = space_group("P 4x")
  assert g == h
  g = space_group("P 6")
  assert g.order_p() == 6
  assert g.order_z() == 6
  g = space_group("-F 2 2")
  assert g.order_p() == 8
  assert g.order_z() == 32
  j = 0
  for i_ltr in range(g.n_ltr()):
    for i_inv in range(g.f_inv()):
      for i_smx in range(g.n_smx()):
        assert g(i_ltr, i_inv, i_smx) == g(j)
        assert g[j] == g(j)
        j += 1
  assert len(tuple(g)) == g.order_z()
  g = space_group("P 3")
  g.expand_smx(rt_mx("-x,-y,z"))
  h = space_group("P 2")
  h.expand_smx(rt_mx("-x+y,-x,z"))
  gx = [str(s) for s in g]
  hx = [str(s) for s in h]
  assert gx != hx
  g.make_tidy()
  h.make_tidy()
  gx = [str(s) for s in g]
  hx = [str(s) for s in h]
  assert gx == hx
  assert g == h
  assert not g != h
  for z in "PABCIRF":
    assert space_group(z + " 1").conventional_centring_type_symbol() == z
  assert space_group("P 1").z2p_op().is_identity_op()
  assert not space_group("R 1").z2p_op().is_identity_op()
  assert not space_group("R 1").construct_z2p_op().is_identity_op()
  assert space_group("P 3").is_chiral()
  assert not space_group("-P 3").is_chiral()
  g = space_group("P 41 (1,2,-1)")
  m = flex.miller_index(((0,0,1), (0,0,4), (1,0,0)))
  assert g.is_sys_absent((0,0,1))
  assert not g.is_sys_absent((0,0,4))
  assert tuple(g.is_sys_absent(m)) == (True,False,False)
  assert g.is_centric((1,0,0))
  assert not g.is_centric((0,0,4))
  assert tuple(g.is_centric(m)) == (False,False,True)
  p = g.phase_restriction((1,0,0))
  assert not p.sys_abs_was_tested()
  assert p.ht() == 2
  assert g.is_valid_phase((1,0,0), p.ht_angle())
  assert g.is_valid_phase((1,0,0), p.ht_angle(), False)
  assert g.is_valid_phase((1,0,0), p.ht_angle(True), True)
  assert not g.is_valid_phase((1,0,0), p.ht_angle()+math.pi/180, False)
  assert g.is_valid_phase((1,0,0), p.ht_angle()+math.pi/180, False, 1.e6)
  assert approx_equal(g.nearest_valid_phases(
    miller_indices=flex.miller_index([(1,2,3),(1,0,0)]),
    phases=flex.double([0.123,0.234])), [0.123, 0.52359877559829882])
  assert approx_equal(g.nearest_valid_phases(
    miller_indices=flex.miller_index([(1,2,3),(1,0,0)]),
    phases=flex.double([123,234]),
    deg=True), [123, 210])
  assert g.multiplicity((1,2,3), False) == 8
  assert g.multiplicity((1,2,3), True) == 4
  assert tuple(g.multiplicity(m, False)) == (2,2,4)
  assert tuple(g.multiplicity(m, True)) == (1,1,4)
  assert g.epsilon((1,2,3)) == 1
  assert tuple(g.epsilon(m)) == (4,4,1)
  gm = space_group("F 2 2 -1d")
  def check(s, m):
    assert gm.multiplicity(sgtbx.vec3_rat_from_str(s)) == m
  check("1/4,1/4,1/4", 8)
  check("1/4,1/4,-1/4", 8)
  check("1/8,1/8,1/8", 16)
  check("5/8,5/8,5/8", 16)
  check("1/9,1/4,1/4", 16)
  check("1/4,1/9,1/4", 16)
  check("1/4,1/4,1/9", 16)
  check("1/7,1/5,1/9", 32)
  u = uctbx.unit_cell((3, 3, 4, 90, 90, 120))
  assert u.is_similar_to(space_group("P 6").average_unit_cell(u))
  assert space_group("P 6").is_compatible_unit_cell(u)
  assert space_group("P 6").is_compatible_unit_cell(u, 0.01)
  assert space_group("P 6").is_compatible_unit_cell(u, 0.01, 1)
  assert not space_group("P 3*").is_compatible_unit_cell(u)
  assert space_group("P 3*").average_unit_cell(u).is_similar_to(
    uctbx.unit_cell((3.3665, 3.3665, 3.3665, 97.6056, 97.6056, 97.6056)),
    1.e-5, 1.e-3)
  assert space_group("P 3*").is_compatible_unit_cell(u, 1, 30)
  u = uctbx.unit_cell((95.2939, 95.2939, 98.4232, 94.3158, 115.226, 118.822))
  g = space_group("C 2y (x+y,-x+y+z,z)")
  assert g.is_compatible_unit_cell(u)
  assert approx_equal(g.average_u_star(u_star=range(6,0,-1)),
    (6.5, 5.5, 4.0, 3.5, 2.5, 1.5))
  g = space_group("C 2 -2c")
  h = g.build_derived_reflection_intensity_group(anomalous_flag=True)
  assert h == space_group("C 2 -2")
  h = h.build_derived_acentric_group()
  assert h == space_group("C 2 -2")
  h = g.build_derived_reflection_intensity_group(anomalous_flag=False)
  assert h == space_group("-C 2 2")
  h = h.build_derived_acentric_group()
  assert h == space_group("C 2 2")
  h = g.build_derived_patterson_group()
  assert h == space_group("-C 2 2")
  h = g.build_derived_point_group()
  assert h == space_group("P 2 -2")
  h = g.build_derived_laue_group()
  assert h == space_group("-P 2 2")
  assert g.point_group_type() == "mm2"
  assert g.laue_group_type() == "mmm"
  assert g.crystal_system() == "Orthorhombic"
  for s in sgtbx.space_group_symbol_iterator():
    g = space_group(s)
    m = g.match_tabulated_settings()
    assert s.number() == m.number()
    assert not g.build_derived_acentric_group().is_centric()
  g = space_group("P 31")
  assert g.gridding() == (1,1,3)
  assert g.refine_gridding((2,1,4)) == (2,2,12)
  mod_p = ["x,y,z", "-y,x-y,z+1/3", "-x+y,-x,z+2/3"]
  mod_s = ["x,y,z", "-y,x-y,z+1/3", "-x+y,-x,z-1/3"]
  assert [str(s) for s in g.all_ops()] == mod_p
  assert [str(s) for s in g.all_ops(0)] == mod_p
  assert [str(s) for s in g.all_ops(1)] == mod_p
  assert [str(s) for s in g.all_ops(-1)] == mod_s
  assert [str(s) for s in g.all_ops(-1, False)] == mod_s
  assert [str(s) for s in g.all_ops(-1, True)] == mod_s
  assert g.all_ops(0, False)[1].t().den() == sgtbx.sg_t_den
  assert g.all_ops(0, True)[1].t().den() == 3
  g = space_group("P 31")
  assert g.type().number() == 144
  p = pickle.dumps(g)
  l = pickle.loads(p)
  assert g == l
  #
  g = space_group("-P 4 2")
  for c in ["c-1/3,a+1/4,b-1/8", "z-1/3,x+1/2,y-1/4"]:
    c = sgtbx.change_of_basis_op(c)
    for cc in [c.as_xyz(), c.as_abc()]:
      h = space_group("-P 4 2 (%s)" % cc)
      cc = sgtbx.change_of_basis_op(cc)
      assert g.change_basis(cc) == h
      assert h.change_basis(cc.inverse()) == g
      for ccc in [cc.inverse().as_xyz(), cc.inverse().as_abc()]:
        ccc = sgtbx.change_of_basis_op(ccc)
        assert h.change_basis(ccc) == g
  cxyz = "2/3*x-1/3*y-1/3*z,1/3*x+1/3*y-2/3*z,1/3*x+1/3*y+1/3*z"
  chkl = "h-k,k-l,h+k+l"
  cabc = "a-b,b-c,a+b+c"
  for c in [cxyz, chkl, cabc]:
    assert sgtbx.change_of_basis_op(c).as_xyz() == cxyz
    assert sgtbx.change_of_basis_op(c).as_hkl() == chkl
    assert sgtbx.change_of_basis_op(c).as_abc() == cabc
  r = space_group("P 3* -2") # R 3 m :r
  h = space_group('R 3 -2"') # R 3 m :h
  for c in [cxyz, chkl, cabc]:
    t = space_group("P 3* -2 (%s)" % c)
    c = sgtbx.change_of_basis_op(c)
    assert r.change_basis(c) == t
    assert t == h
    assert c.inverse().as_xyz() == "x+z,-x+y+z,-y+z"
    assert c.inverse().as_hkl() \
        == "2/3*h+1/3*k+1/3*l,-1/3*h+1/3*k+1/3*l,-1/3*h-2/3*k+1/3*l"
    assert c.inverse().as_abc() \
        == "2/3*a+1/3*b+1/3*c,-1/3*a+1/3*b+1/3*c,-1/3*a-2/3*b+1/3*c"
    for ci in [c.inverse().as_xyz(),
               c.inverse().as_hkl(),
               c.inverse().as_abc()]:
      t = space_group('R 3 -2" (%s)' % ci)
      ci = sgtbx.change_of_basis_op(ci)
      assert h.change_basis(ci) == t
      assert t == r
  #
  try: space_group("-P 4 2 (p)")
  except ValueError as e:
    assert not show_diff(str(e), """\
Parse error: unexpected character:
  -P 4 2 (p)
  ________^""")
  else: raise Exception_expected
  try: space_group("-P 4 2 (x,x,x)")
  except RuntimeError as e:
    assert not show_diff(str(e), """\
cctbx Error: Rotation matrix is not invertible.""")
  else: raise Exception_expected
  sg = space_group("-P 2ac 2ab")
  cb = sgtbx.change_of_basis_op("x+1/12,y+1/12,z-1/12")
  sg1 = sg.change_basis(cb)
  assert sg1.is_centric() and not sg1.is_origin_centric()
  icb = sg1.change_of_origin_realising_origin_centricity()
  sg2 = sg1.change_basis(icb)
  assert sg2.is_origin_centric()
  assert str(cb * icb) == "a,b,c+1/2"
  #
  sg = space_group()
  s = sgtbx.rt_mx(2, 12)
  assert s.r().den() == 2
  assert s.t().den() == 12
  try: sg.expand_smx(s)
  except RuntimeError as e:
    assert str(e) == "cctbx Error: sgtbx::space_group::expand_smx():" \
      " rotation-part denominator must be 1 (implementation limitation)."
  else: raise Exception_expected
  s = sgtbx.rt_mx(1, 24)
  assert s.r().den() == 1
  assert s.t().den() == 24
  try: sg.expand_smx(s)
  except RuntimeError as e:
    assert str(e) == "cctbx Error: sgtbx::space_group::expand_smx():" \
      " incompatible translation-part denominator."
  else: raise Exception_expected
  #
  sg = space_group("-I 4bd 2c 3")
  sg.make_tidy()
  prev_s = None
  for s in list(sg.smx())[1:]:
    if (prev_s is not None):
      assert prev_s < s
      assert prev_s <= s
      assert s > prev_s
      assert s >= prev_s
      assert s != prev_s
      assert not (s == prev_s)
    prev_s = s
  #
  for s in sg:
    c = rt_mx(str(s))
    assert c == s
    assert hash(c) == hash(s)
  #
  sa = sgtbx.rt_mx(symbol="x+1/4,z+1/4,y+1/4")
  assert sa.r().den() == 1
  sx = sa.new_denominators(r_den=2, t_den=24)
  sb = sgtbx.rt_mx(symbol="x+1/4,z-1/4,y+1/4")
  assert sb.r().den() == 1
  sy = sb.new_denominators(r_den=2, t_den=24)
  sc = sgtbx.rt_mx(symbol="-x,y,z")
  assert sc.r().den() == 1
  sz = sc.new_denominators(r_den=2, t_den=24)
  assert sa == sx
  assert not (sa < sa)
  assert not (sa < sx)
  assert not (sx < sa)
  assert not (sx < sx)
  assert sa != sb
  assert sa < sb
  assert sa < sy
  assert sx < sb
  assert sx < sy
  assert sa != sc
  assert not (sa < sc)
  assert not (sa < sz)
  assert not (sx < sc)
  assert not (sx < sz)
  assert not sa < sa
  assert sa <= sa
  assert not sa > sa
  assert sa >= sa
  assert sa <= sb
  assert not (sa > sb)
  assert not (sa >= sb)
  #
  a = sgtbx.rt_mx("-z,-y,-x+2*z", r_den=1, t_den=12)
  b = sgtbx.rt_mx("x,y,z", r_den=1, t_den=12)
  assert not a == b
  assert a != b

def exercise_space_group_type():
  space_group = sgtbx.space_group
  space_group_type = sgtbx.space_group_type
  t = space_group_type()
  assert t.group() == space_group()
  assert t.number() == 1
  assert t.cb_op().is_identity_op()
  t = space_group_type("P 2")
  assert t.hall_symbol() == " P 2y"
  assert t.universal_hermann_mauguin_symbol() == "P 1 2 1"
  t = space_group_type("P 2", "a1983")
  assert t.hall_symbol() == " P 2y"
  assert t.universal_hermann_mauguin_symbol() == "P 1 2 1"
  t = space_group_type("P 2", "i1952")
  assert t.hall_symbol() == " P 2y (z,x,y)"
  assert t.universal_hermann_mauguin_symbol() == "P 1 2 1 (c,a,b)"
  t = space_group_type("P 3")
  assert len(t.addl_generators_of_euclidean_normalizer(False, False)) == 0
  assert len(t.addl_generators_of_euclidean_normalizer(True, False)) == 1
  assert len(t.addl_generators_of_euclidean_normalizer(False, True)) == 2
  assert len(t.addl_generators_of_euclidean_normalizer(True, True)) == 3
  g = t.expand_addl_generators_of_euclidean_normalizer(False, False)
  assert g == t.group()
  j = t.expand_addl_generators_of_euclidean_normalizer(True, False).type()
  assert j.lookup_symbol() == "P -3"
  j = t.expand_addl_generators_of_euclidean_normalizer(False, True).type()
  assert j.lookup_symbol() == "P 6 m m"
  j = t.expand_addl_generators_of_euclidean_normalizer(True, True).type()
  assert j.lookup_symbol() == "P 6/m m m"
  assert not space_group_type("P 3").is_enantiomorphic()
  assert space_group_type("P 31").is_enantiomorphic()
  assert space_group_type("P -1").change_of_hand_op().is_identity_op()
  assert str(space_group_type("P 1").change_of_hand_op().c()) == "-x,-y,-z"
  assert str(space_group_type("P 31").change_of_hand_op().c()) == "-x,-y,-z"
  assert str(space_group_type("I41").change_of_hand_op().c()) == "-x+1/2,-y,-z"
  g = space_group(sgtbx.space_group_symbols("C c c a :1"))
  t = sgtbx.space_group_type(group=g, tidy_cb_op=False)
  assert not t.cb_op_is_tidy()
  assert t.hall_symbol(tidy_cb_op=False) == "-C 2a 2ac (x+1/2,-y+1/4,-z-1/4)"
  assert t.hall_symbol(tidy_cb_op=True) == "-C 2a 2ac (x+1/2,y-1/4,z+1/4)"
  assert t.hall_symbol() == "-C 2a 2ac (x+1/2,y-1/4,z+1/4)"
  assert t.universal_hermann_mauguin_symbol(tidy_cb_op=False) \
      == "C c c a :2 (a+1/2,-b+1/4,-c-1/4)"
  assert t.universal_hermann_mauguin_symbol(tidy_cb_op=True) \
      == "C c c a :2 (a+1/2,b+1/4,c-1/4)"
  assert t.universal_hermann_mauguin_symbol() \
      == "C c c a :2 (a+1/2,b+1/4,c-1/4)"
  p = pickle.dumps(t)
  l = pickle.loads(p)
  assert l.group() == t.group()
  assert not l.cb_op_is_tidy()
  t = g.change_basis(g.z2p_op()).type()
  assert t.cb_op_is_tidy()
  h = "-C 2a 2ac (x-y-1/4,x+y+1/4,z+1/4)"
  assert t.hall_symbol() == h
  assert t.hall_symbol(tidy_cb_op=True) == h
  assert t.hall_symbol(tidy_cb_op=False) == h
  u = "C c c a :2 (x-y-1/4,x+y+1/4,z+1/4)"
  assert t.universal_hermann_mauguin_symbol() == u
  assert t.universal_hermann_mauguin_symbol(tidy_cb_op=True) == u
  assert t.universal_hermann_mauguin_symbol(tidy_cb_op=False) == u
  assert t.lookup_symbol() == u
  assert g.type().lookup_symbol() == "C c c a :1"
  p = pickle.dumps(t)
  l = pickle.loads(p)
  assert l.group() == t.group()
  assert l.cb_op_is_tidy()
  #
  for s in sgtbx.space_group_symbol_iterator():
    uhm_in = s.universal_hermann_mauguin() + " (z+1/4, x-1/4, y+3/4)"
    g_out = sgtbx.space_group(sgtbx.space_group_symbols(uhm_in))
    uhm_out = g_out.type().universal_hermann_mauguin_symbol()
    if (uhm_out != uhm_in):
      g_out2 = sgtbx.space_group(sgtbx.space_group_symbols(uhm_out))
      assert g_out2 == g_out
      uhm_out2 = g_out2.type().universal_hermann_mauguin_symbol()
      assert uhm_out2 == uhm_out
    if (uhm_out.find("(") >= 0):
      ehm, cb = uhm_out.split("(")
      assert cb[-1] == ")"
      g_out2 = sgtbx.space_group(sgtbx.space_group_symbols(ehm)) \
        .change_basis(sgtbx.change_of_basis_op(cb[:-1]))
      assert g_out2 == g_out
    g_out = g_out.change_basis(g_out.z2p_op()) # primitive setting
    uhm_out = g_out.type().universal_hermann_mauguin_symbol()
    g_out2 = sgtbx.space_group(sgtbx.space_group_symbols(uhm_out))
    assert g_out2 == g_out
    uhm_out2 = g_out2.type().universal_hermann_mauguin_symbol()
    assert uhm_out2 == uhm_out
    if (uhm_out.find("(") >= 0):
      ehm, cb = uhm_out.split("(")
      assert cb[-1] == ")"
      g_out2 = sgtbx.space_group(sgtbx.space_group_symbols(ehm)) \
        .change_basis(sgtbx.change_of_basis_op(cb[:-1]))
      assert g_out2 == g_out
  #
  # ensure universal_hermann_mauguin_symbol ":H" is consistently upper-case
  t = sgtbx.space_group_type("r -3 M :h (3*z,-x+2*z,-y+z)")
  assert t.universal_hermann_mauguin_symbol() == "R -3 m :H (3*z,-x+2*z,-y+z)"
  assert t.lookup_symbol() == "R -3 m :H (3*z,-x+2*z,-y+z)"
  t = sgtbx.space_group_type("r -3 M :h")
  assert t.universal_hermann_mauguin_symbol() == "R -3 m :H"
  assert t.lookup_symbol() == "R -3 m :H"
  #
  for pair in [line.split() for line in ad_hoc_1992_pairs]:
    o,n = [sgtbx.space_group_info(symbol=symbol) for symbol in pair]
    for ad_hoc_1992 in [False, True]:
      l1 = o.type().lookup_symbol(ad_hoc_1992=ad_hoc_1992)
      l2 = n.type().lookup_symbol(ad_hoc_1992=ad_hoc_1992)
      assert not show_diff(l1, l2)
      assert l1.replace(" ", "").startswith(pair[int(ad_hoc_1992)])
  sgi = sgtbx.space_group_info(symbol="Ae2a").primitive_setting()
  assert not show_diff(
    sgi.type().lookup_symbol(), "A b a 2 (x,y-z,y+z)")
  assert not show_diff(
    sgi.type().lookup_symbol(ad_hoc_1992=True), "A e a 2 (x,y-z,y+z)")
  #
  def all_t_zero(g): # this simple test is correct only for reference settings
    assert g.make_tidy()
    for s in g.smx():
      if (not s.t().is_zero()): return False
    return True
  n_symmorphic = 0
  for sgi in sgtbx.reference_space_group_infos():
    is_symmorphic = sgi.type().is_symmorphic()
    assert is_symmorphic == all_t_zero(sgi.group())
    if (is_symmorphic):
      n_symmorphic += 1
  assert n_symmorphic == 73

def exercise_phase_info():
  phase_info = sgtbx.phase_info
  g = sgtbx.space_group("P 61 (1 2 0)")
  p = phase_info(g, (1,2,3))
  assert p.sys_abs_was_tested()
  p = phase_info(g, (1,2,3), False)
  assert p.sys_abs_was_tested()
  p = phase_info(g, (1,2,3), True)
  assert not p.sys_abs_was_tested()
  p = phase_info(g, (0,0,6))
  assert not p.is_sys_absent()
  p = phase_info(g, (0,0,1))
  assert p.is_sys_absent()
  p = phase_info(g, (1,0,0))
  assert p.is_centric()
  p = phase_info(g, (0,0,2))
  assert not p.is_centric()
  p = phase_info(g, (1,0,0))
  assert p.ht() == 2
  assert p.t_den() == g.t_den()
  assert approx_equal(p.ht_angle(), float(p.ht()) / p.t_den() * math.pi)
  assert p.ht_angle(False) == p.ht_angle()
  assert approx_equal(p.ht_angle(True), p.ht_angle()*180/math.pi)
  p = phase_info(sgtbx.space_group("P 2ac 2ab"), (0,10,8))
  assert approx_equal(p.nearest_valid_phase(1.e-15), 0)
  assert approx_equal(p.nearest_valid_phase(-1.e-15), 0)
  assert approx_equal(p.nearest_valid_phase(math.pi/2-1.e-6), 0)
  assert approx_equal(p.nearest_valid_phase(math.pi/2+1.e-6), math.pi)
  assert approx_equal(p.nearest_valid_phase(math.pi-1.e-15), math.pi)
  assert approx_equal(p.nearest_valid_phase(math.pi+1.e-15), math.pi)
  p = phase_info(g, (1,0,0))
  phi = p.ht_angle()
  assert approx_equal(p.nearest_valid_phase(phi+1.e-15), phi)
  assert approx_equal(p.nearest_valid_phase(phi-1.e-15), phi)
  assert approx_equal(p.nearest_valid_phase(phi+math.pi/2-1.e-6), phi)
  assert approx_equal(p.nearest_valid_phase(phi+math.pi/2+1.e-6), phi+math.pi)
  assert approx_equal(p.nearest_valid_phase(phi+math.pi+1.e-15), phi+math.pi)
  assert approx_equal(p.nearest_valid_phase(phi+math.pi-1.e-15), phi+math.pi)
  for i in range(-3, 4):
    phi = p.ht_angle() + i * math.pi
    assert p.is_valid_phase(phi)
    assert p.is_valid_phase(phi*180/math.pi, True)
    assert p.is_valid_phase(phi, False, 1.e-6)
    phi = p.ht_angle() + i * math.pi + math.pi / 180
    assert not p.is_valid_phase(phi)
    assert not p.is_valid_phase(phi*180/math.pi, True)
    assert not p.is_valid_phase(phi, False, 1.e-6)
    assert p.is_valid_phase(phi, False, 1.e6)
    assert p.is_valid_phase(p.nearest_valid_phase(phi))
    assert p.is_valid_phase(p.nearest_valid_phase(phi, False), False)
    assert p.is_valid_phase(p.nearest_valid_phase(phi+1.e-15, False), False)
    assert p.is_valid_phase(p.nearest_valid_phase(phi-1.e-15, False), False)
    assert p.is_valid_phase(p.nearest_valid_phase(phi+math.pi+1.e-15, False), False)
    assert p.is_valid_phase(p.nearest_valid_phase(phi+math.pi-1.e-15, False), False)
    assert p.is_valid_phase(p.nearest_valid_phase(phi, True), True)
    assert p.is_valid_phase(p.nearest_valid_phase(phi+1.e-15, True), True)
    assert p.is_valid_phase(p.nearest_valid_phase(phi-1.e-15, True), True)
    assert p.is_valid_phase(p.nearest_valid_phase(phi+180+1.e-15, True), True)
    assert p.is_valid_phase(p.nearest_valid_phase(phi+180-1.e-15, True), True)
  for i in range(-3, 4):
    phi = p.ht_angle() + i * math.pi
    f = complex_math.polar((1, phi))
    assert approx_equal(f, p.valid_structure_factor(f))
    f = complex_math.polar((1, phi+math.pi/2))
    assert approx_equal(abs(p.valid_structure_factor(f)), 0)
    f = complex_math.polar((1, phi+math.pi/3))
    assert approx_equal(abs(p.valid_structure_factor(f)), 0.5)
    f = complex_math.polar((1, phi+math.pi/4))
    assert approx_equal(abs(p.valid_structure_factor(f)), math.sqrt(2)/2)
    f = complex_math.polar((1, phi+math.pi/6))
    assert approx_equal(abs(p.valid_structure_factor(f)), math.sqrt(3)/2)
    f = complex_math.polar((1, phi-math.pi/6))
    assert approx_equal(abs(p.valid_structure_factor(f)), math.sqrt(3)/2)
    f = complex_math.polar((2, phi+math.pi/6))
    assert approx_equal(abs(p.valid_structure_factor(f)), math.sqrt(3))
    f = complex_math.polar((3, phi+math.pi/6))
    assert approx_equal(abs(p.valid_structure_factor(f)), 3*math.sqrt(3)/2)

def exercise_reciprocal_space_asu():
  reciprocal_space_asu = sgtbx.reciprocal_space_asu
  t = sgtbx.space_group_type("P 1 2 1")
  a = reciprocal_space_asu(t)
  assert a.cb_op().c() == t.cb_op().c()
  assert a.is_reference()
  assert a.reference_as_string() == "k>=0 and (l>0 or (l==0 and h>=0))"
  assert a.is_inside((1,2,3))
  assert not a.is_inside((-1,-2,-3))
  assert a.which((1,2,3)) == 1
  assert a.which((-1,-2,-3)) == -1
  t = sgtbx.space_group_type("P 1 1 2")
  a = reciprocal_space_asu(t)
  assert not a.is_reference()
  t = sgtbx.space_group_type("P 3 1 2")
  a = reciprocal_space_asu(t)
  assert a.which((-1,0,1)) == 0

def exercise_brick():
  tr_vec = sgtbx.tr_vec
  brick = sgtbx.brick
  t = sgtbx.space_group_type("P 1 2 1")
  b = brick(t)
  assert b.as_string() == "0<=x<=1/2; 0<=y<1; 0<=z<1"
  assert b.as_string() == str(b)
  assert b.is_inside(tr_vec((6,2,3)))
  assert not b.is_inside(tr_vec((7,2,3)))

def exercise_site_symmetry():
  site_symmetry = sgtbx.site_symmetry
  u = uctbx.unit_cell((3,4,5,80,100,110))
  g = sgtbx.space_group("P 2")
  s = site_symmetry(u, g, (0,0,0))
  s = site_symmetry(u, g, (0,0,0), 0.5)
  s = site_symmetry(
    unit_cell=u,
    space_group=g,
    original_site=(0.05,0,0),
    min_distance_sym_equiv=0.5,
    assert_min_distance_sym_equiv=True)
  assert s.unit_cell().parameters() == u.parameters()
  assert s.space_group() == g
  assert s.original_site() == (0.05,0,0)
  assert approx_equal(s.min_distance_sym_equiv(), 0.5)
  assert s.exact_site() == (0,0,0)
  assert approx_equal(s.distance_moved(), u.distance((0.05,0,0), (0,0,0)))
  assert s.shortest_distance() > 0.5
  assert s.check_min_distance_sym_equiv()
  assert s.multiplicity() == 1
  assert str(s.special_op()) == "0,0,z"
  assert not s.is_point_group_1()
  assert s.point_group_type() == "2"
  assert [str(o) for o in s.unique_ops()] == ["0,0,z"]
  assert sgtbx.rt_mx("-x,-y,z") in s
  cb_op = sgtbx.change_of_basis_op("z,x,y")
  sc = s.change_basis(cb_op=cb_op)
  assert str(sc.special_op()) == "x,0,0"
  assert str(sc.matrices()[0]) == "x,y,z"
  assert str(sc.matrices()[1]) == "x,-y,-z"
  assert str(s.matrices()[1]) == "-x,-y,z"
  assert sgtbx.rt_mx("x,-y,-z") in sc
  assert sc.multiplicity() == 1
  cb_op = sgtbx.change_of_basis_op("-x,-y,-z") # negative determinant
  sc = s.change_basis(cb_op=cb_op)
  assert str(sc.special_op()) == "0,0,z"
  assert sc.multiplicity() == 1
  u = uctbx.unit_cell((10,10,15,90,90,120))
  g = sgtbx.space_group("-P 3 2")
  s = site_symmetry(unit_cell=u, space_group=g, original_site=(0,0,0))
  assert s.multiplicity() == 1
  a = (5,2,3,-1,2,-2)
  assert not s.is_compatible_u_star(u_star=a)
  assert s.is_compatible_u_star(u_star=a, tolerance=1.e6)
  a = s.average_u_star(u_star=a)
  assert s.is_compatible_u_star(u_star=a)
  assert len(s.matrices()) == 12
  assert str(s.matrices()[1]) == "-y,x-y,z"
  t = sgtbx.site_symmetry_table()
  t.reserve(5)
  assert t.indices().size() == 0
  t.process(site_symmetry_ops=s)
  assert t.indices().size() == 1
  assert t.n_special_positions() == 1
  assert list(t.special_position_indices()) == [0]
  assert t.n_unique() == 2
  t.process(site_symmetry_ops=s)
  assert t.indices().size() == 2
  assert t.n_unique() == 2
  s2 = site_symmetry(unit_cell=u, space_group=g, original_site=(0.5,0.5,0.5))
  assert s2.multiplicity() == 3
  t.process(site_symmetry_ops=s2)
  assert t.indices().size() == 3
  assert t.n_unique() == 3
  t.process(site_symmetry_ops=s)
  assert t.indices().size() == 4
  assert t.n_unique() == 3
  s3 = site_symmetry(unit_cell=u, space_group=g, original_site=(0.25,0.66,0.0))
  assert s3.multiplicity() == 12
  assert s3.is_point_group_1()
  assert s3 == s3
  assert not (s3 != s3)
  assert not (s3 == s2)
  assert s3 != s2
  t.process(site_symmetry_ops=s3)
  assert t.indices().size() == 5
  assert t.n_unique() == 3
  assert len(t.table()) == 3
  assert list(t.indices()) == [1,1,2,1,0]
  assert t.n_special_positions() == 4
  assert list(t.special_position_indices()) == [0,1,2,3]
  assert t.is_special_position(i_seq=0)
  assert not t.is_special_position(i_seq=4)
  assert t.get(0).multiplicity() == s.multiplicity()
  assert t.get(1).multiplicity() == s.multiplicity()
  assert t.get(2).multiplicity() == s2.multiplicity()
  assert t.get(3).multiplicity() == s.multiplicity()
  assert t.get(4).multiplicity() == s3.multiplicity()
  assert t.get(0).special_op() == s.special_op()
  assert t.get(1).special_op() == s.special_op()
  assert t.get(2).special_op() == s2.special_op()
  assert t.get(3).special_op() == s.special_op()
  assert t.get(4).special_op() == s3.special_op()
  assert t.get(0).n_matrices() == 12
  assert t.get(1).n_matrices() == 12
  assert t.get(2).n_matrices() == 4
  assert t.get(3).n_matrices() == 12
  assert t.get(4).n_matrices() == 1
  for i in range(5):
    assert t.get(i).n_matrices() * t.get(i).multiplicity() == g.order_z()
  assert not t.get(0).is_point_group_1()
  assert t.get(4).is_point_group_1()
  assert str(t.get(0).matrices()[0]) == "x,y,z"
  assert str(t.get(4).matrices()[0]) == "x,y,z"
  tc = t.deep_copy()
  assert list(tc.indices()) == [1,1,2,1,0]
  tc.process(site_symmetry_ops=s2)
  assert list(tc.indices()) == [1,1,2,1,0,2]
  assert list(t.indices()) == [1,1,2,1,0]
  cb_op = sgtbx.change_of_basis_op("y,z,x")
  tcb = t.change_basis(cb_op=cb_op)
  assert list(tcb.indices()) == list(t.indices())
  assert list(tcb.special_position_indices()) \
      == list(t.special_position_indices())
  for tcbt,tt in zip(tcb.table(), t.table()):
    for a,b in zip(tcbt.matrices(), tt.matrices()):
      assert str(a) == str(cb_op.apply(b))
  t.process(site_symmetry_ops=s3)
  assert list(t.indices()) == [1,1,2,1,0,0]
  assert list(tc.indices()) == [1,1,2,1,0,2]
  assert list(t.special_position_indices()) == [0,1,2,3]
  assert list(tc.special_position_indices()) == [0,1,2,3,5]
  ts = tc.select(selection=flex.size_t([5,0,4,1]))
  assert list(ts.indices()) == [1,2,0,2]
  assert ts.get(0).special_op() == tc.get(5).special_op()
  assert ts.get(1).special_op() == tc.get(0).special_op()
  assert ts.get(2).special_op() == tc.get(4).special_op()
  assert ts.get(3).special_op() == tc.get(1).special_op()
  ts = tc.select(selection=flex.bool([True,True,False,False,True,True]))
  assert ts.get(0).special_op() == tc.get(0).special_op()
  assert ts.get(1).special_op() == tc.get(1).special_op()
  assert ts.get(2).special_op() == tc.get(4).special_op()
  assert ts.get(3).special_op() == tc.get(5).special_op()
  ts = tc.select(selection=flex.size_t())
  assert ts.indices().size() == 0
  for i in range(tc.indices().size()):
    s = tc.get(i)
    p = pickle.dumps(s)
    l = pickle.loads(p)
    assert l.multiplicity() == s.multiplicity()
    assert l.special_op() == s.special_op()
    if (i == 0):
      assert len(s.matrices()) == 12
      assert len(l.matrices()) == 12
    for unpickled,original in zip(l.matrices(), s.matrices()):
      assert unpickled == original
  p = pickle.dumps(ts)
  l = pickle.loads(p)
  assert l.indices().size() == 0
  assert l.table() == ()
  assert l.special_position_indices().size() == 0
  p = pickle.dumps(tc)
  l = pickle.loads(p)
  assert list(l.indices()) == [1,1,2,1,0,2]
  assert len(l.table()) == 3
  assert str(l.table()[0].special_op()) == "x,y,z"
  for unpickled,original in zip(l.table(), tc.table()):
    assert unpickled.special_op() == original.special_op()
    for unp,orig in zip(unpickled.matrices(), original.matrices()):
      assert unp == orig
  assert list(l.special_position_indices()) == [0,1,2,3,5]
  original_sites_frac=flex.vec3_double([
    (0,0,0),
    (0.25,0.66,0.0),
    (0,0,0),
    (0.5,0.5,0.5)])
  t = sgtbx.site_symmetry_table()
  t.process(
    unit_cell=u,
    space_group=g,
    original_sites_frac=original_sites_frac)
  assert list(t.indices()) == [1,0,1,2]
  #
  d = t.discard_symmetry()
  assert list(d.indices()) == [0,0,0,0]
  assert len(d.table())==1
  assert d.table()[0].is_point_group_1()
  assert d.table()[0].multiplicity() == 1
  assert d.special_position_indices().size()==0
  #
  t = sgtbx.site_symmetry_table()
  t.process(
    unit_cell=u,
    space_group=g,
    original_sites_frac=original_sites_frac,
    min_distance_sym_equiv=100,
    assert_min_distance_sym_equiv=False)
  assert list(t.indices()) == [1,2,1,3]
  for ugpf,ti in [
        ([False,False,False,False], [1,0,1,2]),
        ([False,False,True,False], [1,0,0,2]),
        ([True,False,False,False], [0,0,1,2]),
        ([True,False,True,False], [0,0,0,1]),
        ([True,False,True,True], [0,0,0,0]),
        ([True,True,True,True], [0,0,0,0])]:
    t = sgtbx.site_symmetry_table()
    t.process(
      unit_cell=u,
      space_group=g,
      original_sites_frac=original_sites_frac,
      unconditional_general_position_flags=flex.bool(ugpf))
    assert list(t.indices()) == ti
  #
  u = uctbx.unit_cell((3,4,5,80,100,110))
  g = sgtbx.space_group("P 2")
  #
  ss = site_symmetry(
    unit_cell=u,
    space_group=g,
    original_site=(0,0,0))
  assert str(ss.special_op()) == "0,0,z"
  ss = site_symmetry(
    unit_cell=u,
    space_group=g,
    original_site=(0,0,0),
    min_distance_sym_equiv=0)
  assert str(ss.special_op()) == "x,y,z"
  #
  ss = site_symmetry(
    unit_cell=u,
    space_group=g,
    original_site=(1.05,-2,0.123))
  assert str(ss.special_op()) == "1,-2,z"
  sc = ss.site_constraints()
  assert sc.row_echelon_lcm == 12
  assert list(sc.row_echelon_form()) == [24, 0, 0, 0, 24, 0]
  assert approx_equal(sc.row_echelon_constants, [24, -48])
  assert list(sc.independent_indices) == [2]
  assert sc.n_independent_params() == 1
  assert sc.n_dependent_params() == 2
  ip = sc.independent_params(all_params=(7,8,0.123))
  assert approx_equal(ip, [0.123])
  ap = sc.all_params(independent_params=ip)
  assert sc.all_shifts([0.128]) == (0, 0, 0.128)
  assert approx_equal(ap, [1.0,-2.0,0.123])
  assert sc.gradient_sum_matrix().focus() == (1,3)
  assert approx_equal(sc.gradient_sum_matrix(), [0,0,1])
  ig = sc.independent_gradients(
    all_gradients=flex.double([0.1,0.2,0.5]))
  assert approx_equal(ig, [0.5])
  ig = sc.independent_gradients((0.1,0.2,0.5))
  assert approx_equal(ig, [0.5])
  ic = sc.independent_curvatures(
    all_curvatures=flex.double([0.1,0.2,0.5,0.3,0.2,-0.1]))
  assert approx_equal(ic, [-0.1])
  #
  u = uctbx.unit_cell((3,4,5,80,100,110))
  g = sgtbx.space_group("P 2")
  s1 = site_symmetry(u, g, (0.1,0.2,0.3))
  s2 = site_symmetry(u, g, (0,0,0))
  s3 = site_symmetry(u, g, (0.5,0.5,0))
  assert str(s1.special_op()) == "x,y,z"
  assert str(s2.special_op()) == "0,0,z"
  assert str(s3.special_op()) == "1/2,1/2,z"
  t = sgtbx.site_symmetry_table()
  t.process(insert_at_index=0, site_symmetry_ops=s1)
  assert list(t.indices()) == [0]
  assert list(t.special_position_indices()) == []
  t.process(insert_at_index=0, site_symmetry_ops=s2)
  assert list(t.indices()) == [1,0]
  assert list(t.special_position_indices()) == [0]
  t = sgtbx.site_symmetry_table()
  t.process(insert_at_index=0, site_symmetry_ops=s2)
  assert list(t.indices()) == [1]
  assert list(t.special_position_indices()) == [0]
  t.process(insert_at_index=0, site_symmetry_ops=s1)
  assert list(t.indices()) == [0,1]
  assert list(t.special_position_indices()) == [1]
  t.process(insert_at_index=1, site_symmetry_ops=s3)
  assert list(t.indices()) == [0,2,1]
  assert list(t.special_position_indices()) == [1,2]
  t.process(insert_at_index=0, site_symmetry_ops=s2)
  assert list(t.indices()) == [1,0,2,1]
  assert list(t.special_position_indices()) == [0,2,3]
  t.process(insert_at_index=4, site_symmetry_ops=s3)
  assert list(t.indices()) == [1,0,2,1,2]
  assert list(t.special_position_indices()) == [0,2,3,4]
  t.process(insert_at_index=0, site_symmetry_ops=s1)
  assert list(t.indices()) == [0,1,0,2,1,2]
  assert list(t.special_position_indices()) == [1,3,4,5]
  t.process(insert_at_index=6, site_symmetry_ops=s1)
  assert list(t.indices()) == [0,1,0,2,1,2,0]
  assert list(t.special_position_indices()) == [1,3,4,5]
  #
  u = uctbx.unit_cell((3,4,5,80,100,110))
  g = sgtbx.space_group("-P")
  site_c = site_symmetry(u, g, (0, 1, 0.5)).site_constraints()
  assert site_c.all_shifts(()) == (0, 0, 0)
  #
  u = uctbx.unit_cell((2, 2, 2, 80, 80, 80))
  g = sgtbx.space_group("R 3 (-y+z, x+z, -x+y+z)")
  site_c = site_symmetry(u, g, (0.1, 0.1, 0.1)).site_constraints()
  assert site_c.all_shifts((0.128,)) == (0.128, 0.128, 0.128)
  #
  # zeolite framework type AFX
  u = uctbx.unit_cell((13.674, 13.674, 19.695, 90, 90, 120))
  g = sgtbx.space_group_info(symbol="P 63/m m c").group()
  sites_frac = flex.vec3_double([
    (0.0003, 0.2268, 0.0788),
    (0.3328, 0.4398, 0.1712),
    (0.1134, 0.2268, 0.0788),
    (-1.38778e-17, 0.22665, 0),
    (-0.11325, 0.11325, 0.0788),
    (0.05365, 0.3333, 0.125),
    (0.2199, 0.4398, 0.1712),
    (0.3328, 0.4398, 0.25),
    (0.4465, 0.5535, 0.1712)])
  t = sgtbx.site_symmetry_table()
  t.process(
    unit_cell=u,
    space_group=g,
    original_sites_frac=sites_frac)
  p = t.pack_coordinates(sites_frac=sites_frac)
  assert approx_equal(p, [
    0.0003, 0.2268, 0.0788, 0.3328, 0.4398, 0.1712, 0.2268, 0.0788,
    0.22665, 0.11325, 0.0788, 0.05365, 0.3333, 0.125, 0.4398, 0.1712,
    0.3328, 0.4398, 0.5535, 0.1712])
  u = t.unpack_coordinates(packed_coordinates=p)
  assert approx_equal(u, sites_frac)
  g_frac = flex.vec3_double([
    (1.839276, -1.015489, -1.653259),
    (-2.14052, 1.040399, 1.653738),
    (9.844995, -2.218571, -2.054126),
    (2.329357, -4.063528, -12.55558),
    (-1.555214, -2.032991, -6.204481),
    (8.35847, -4.185706, 0.005703849),
    (-3.121928, -1.143936, 2.110444),
    (-1.765163, 4.062308, 12.57375),
    (1.473678, 1.973169, 6.160302)])
  p = t.pack_gradients(g_frac=g_frac)
  assert approx_equal(p, [
    1.839276, -1.015489, -1.653259, -2.14052, 1.040399, 1.653738,
    2.703927, -2.054126, -4.063528, -0.477777, -6.204481, 8.35847,
    -4.185706, 0.005703849, -2.7049, 2.110444, -1.765163, 4.062308,
    0.499491, 6.160302])

def exercise_wyckoff():
  space_group_type = sgtbx.space_group_type
  wyckoff_table = sgtbx.wyckoff_table
  assert wyckoff_table(space_group_type("P 1")).size() == 1
  sg_type = space_group_type("P m m m")
  w = wyckoff_table(sg_type)
  assert w.space_group_type().group() == sg_type.group()
  assert w.size() == 27
  assert w.position(0).special_op().is_unit_mx()
  assert w.position("@").special_op().is_unit_mx()
  assert w.position("n").special_op() == w.position(13).special_op()
  assert w.lookup_index("@") == 0
  assert w.lookup_index("k") == 16
  for i in range(w.size()):
    assert w.lookup_index(w.position(i).letter()) == i
  p = w.position("t")
  assert p.multiplicity() == 2
  assert p.point_group_type() == "mm2"
  assert [str(s) for s in p.unique_ops(sg_type.group())] \
      == ["1/2,1/2,z", "1/2,1/2,-z"]
  u = uctbx.unit_cell((2,3,4))
  g = sg_type.group()
  x = (0.5,0.,0.123)
  ss = sgtbx.site_symmetry(u, g, x)
  m = w.mapping(ss)
  ww = weakref.ref(w)
  del w # to verify life-time support
  assert u.is_similar_to(m.unit_cell())
  assert approx_equal(m.original_site(), x)
  assert m.position().letter() == "s"
  assert m.position().point_group_type() == "mm2"
  assert str(m.sym_op()) == "x,y,z"
  assert approx_equal(m.representative_site(), x)
  assert approx_equal(m.exact_site(), x)
  assert m.distance_moved() < 1.e-6
  assert str(m.special_op()) == "1/2,0,z"
  assert ww().size() == 27
  del m
  assert ww().size() == 27
  del p
  assert ww() is None
  w = wyckoff_table(sg_type)
  x = (-2.52, 1.123, -4.97)
  ss = sgtbx.site_symmetry(u, g, x)
  m = w.mapping(ss)
  assert u.is_similar_to(m.unit_cell())
  assert approx_equal(m.original_site(), x)
  assert m.position().letter() == "o"
  assert m.position().point_group_type() == "mm2"
  assert str(m.sym_op()) == "x+3,y,z+5"
  assert approx_equal(m.representative_site(), (0.5,1.123,0))
  assert approx_equal(m.exact_site(), (-2.5,1.123,-5))
  assert approx_equal(m.distance_moved(), u.length((-0.02,0,-0.03)))
  assert str(m.special_op()) == "-5/2,y,-5"
  m = w.mapping(u, x)
  assert u.is_similar_to(m.unit_cell())
  assert approx_equal(m.original_site(), x)
  assert m.position().letter() == "b"
  assert m.position().point_group_type() == "mmm"
  xyz = str(m.sym_op())
  assert xyz in ("x+3,y-1,z+5", "x+3,-y+1,z+5"), xyz
  assert approx_equal(m.representative_site(), (0.5,0,0))
  assert approx_equal(m.exact_site(), (-2.5, 1.0, -5.0))
  assert approx_equal(m.distance_moved(), u.length((-0.02,0.123,-0.03)))
  assert str(m.special_op()) == "-5/2,1,-5"
  m = w.mapping(u, x, 0.2)
  assert m.position().letter() == "o"
  assert str(m.sym_op()) in ("x+3,y-2,z+5", "x+3,-y+2,z+5")
  if (str(m.sym_op()) == "x+3,y-2,z+5"):
    assert approx_equal(m.representative_site(), (0.5,1.123-2,0))
  else:
    assert approx_equal(m.representative_site(), (0.5,-1.123+2,0))
  assert approx_equal(m.exact_site(), (-2.5,1.123,-5))
  assert approx_equal(m.distance_moved(), u.length((-0.02,0,-0.03)))
  assert str(m.special_op()) == "-5/2,y,-5"
  #
  sg_type = space_group_type("P 42/n c m")
  w = wyckoff_table(sg_type)
  assert str(w.position(3).special_op()) == "1/2*x-1/2*y,-1/2*x+1/2*y,1/2"
  assert str(w.position(3).special_op_simplified()) == "x,-x,1/2"

def exercise_sym_equiv_sites():
  sym_equiv_sites = sgtbx.sym_equiv_sites
  u = uctbx.unit_cell((8,8,11,90,90,120))
  sg_type = sgtbx.space_group_type("P 3 1 2")
  g = sg_type.group()
  wtab = sgtbx.wyckoff_table(sg_type)
  for x,mult,sym_i in (((0,0,0), 1, (0,)),
                      ((1./5,-1./5,1.5), 3, (0,1,2)),
                      ((-1./3,1./3,0.123), 2, (0,3)),
                      ((1./4,1./5,1./3), 6, (0,1,2,3,4,5))):
    ss = sgtbx.site_symmetry(u, g, x)
    assert ss.multiplicity() == mult
    wm = wtab.mapping(u, x)
    assert wm.position().multiplicity() == mult
    for m in (ss, wm):
      e = sym_equiv_sites(m)
      assert e.unit_cell().is_similar_to(u)
      assert e.space_group() == g
      assert e.original_site() == x
      assert e.special_op() == ss.special_op()
      assert e.max_accepted_tolerance() < 0
      assert e.coordinates().size() == mult
      if (mult == 6):
        c = tuple(e.coordinates())
        vfy = ((1./4, 0.2, 1./3),
               (-1./5, 1./20, 1./3),
               (-1./20, -1./4, 1./3),
               (-1./5, -1./4, -1./3),
               (1./4, 1./20, -1./3),
               (-1./20, 1./5, -1./3))
        for i in range(6):
          assert approx_equal(c[i], vfy[i])
      assert tuple(e.sym_op_indices()) == sym_i
      assert e.is_special_position() \
          == (len(e.coordinates()) < e.space_group().order_z())
      for i in range(e.coordinates().size()):
        assert e.sym_op(i) == g(sym_i[i])
    for i in range(2):
      if (i == 0):
        e = sym_equiv_sites(g, x)
      if (i == 1):
        e = sym_equiv_sites(g, x, u)
        assert e.unit_cell().is_similar_to(u)
      assert e.space_group() == g
      assert e.original_site() == x
      assert not e.special_op().is_valid()
      assert e.max_accepted_tolerance() < 0
      assert e.coordinates().size() == g.order_z()
    e = sym_equiv_sites(u, g, x, ss.special_op())
    assert e.unit_cell().is_similar_to(u)
    assert e.space_group() == g
    assert e.original_site() == x
    assert e.special_op() == ss.special_op()
    assert e.max_accepted_tolerance() < 0
    assert e.coordinates().size() == mult
    for i in range(4):
      if (i == 0):
        e = sym_equiv_sites(
          unit_cell=u,
          space_group=g,
          original_site=x,
          site_symmetry_ops=ss)
      elif (i == 1):
        e = sym_equiv_sites(
          unit_cell=u,
          space_group=g,
          original_site=x)
      elif (i == 2):
        e = sym_equiv_sites(
          unit_cell=u,
          space_group=g,
          original_site=x,
          minimum_distance=0.1)
      elif (i == 3):
        e = sym_equiv_sites(
          unit_cell=u,
          space_group=g,
          original_site=x,
          minimum_distance=0.1,
          tolerance=0.001)
      assert e.unit_cell().is_similar_to(u)
      assert e.space_group() == g
      assert e.original_site() == x
      if (i == 0):
        assert e.special_op().is_valid()
        assert e.max_accepted_tolerance() < 0
      else:
        assert not e.special_op().is_valid()
        assert e.max_accepted_tolerance() >= 0
      assert e.coordinates().size() == mult
    e = sym_equiv_sites(u, g, x, 100, 50)
    assert e.coordinates().size() == 1
    for i in range(6):
      if (i == 0):
        e = sym_equiv_sites(
          site_symmetry=ss)
      elif (i == 1):
        e = sym_equiv_sites(
          unit_cell=u,
          space_group=g,
          original_site=x,
          site_symmetry_ops=ss)
      elif (i == 2):
        e = sym_equiv_sites(
          wyckoff_mapping=wm)
      elif (i == 3):
        e = sym_equiv_sites(
          unit_cell=u,
          space_group=g,
          original_site=x,
          special_op=ss.special_op())
      elif (i == 4):
        e = sym_equiv_sites(
          unit_cell=u,
          space_group=g,
          original_site=x,
          special_op=ss.special_op(),
          multiplicity=ss.multiplicity())
      elif (i == 5):
        e = sym_equiv_sites(
          unit_cell=u,
          space_group=g,
          original_site=x)
      d = sgtbx.min_sym_equiv_distance_info(reference_sites=e, other=x)
      assert d.i_other() == 0
      assert str(d.sym_op()) == "x,y,z"
      assert d.continuous_shifts() == (0,0,0)
      assert approx_equal(d.diff(), (0,0,0))
      assert approx_equal(d.dist(), 0)
      assert approx_equal(d.sym_op() * x, x)
      a = d.apply(sites_frac=e.coordinates())
      assert a.size() == e.coordinates().size()
      for i,y in enumerate(e.coordinates()):
        assert approx_equal(a[i], y)
      for i,y in enumerate(e.coordinates()):
        d = sgtbx.min_sym_equiv_distance_info(e, y)
        assert approx_equal(d.dist(), 0)
        assert approx_equal(d.sym_op() * y, x)
      d = sgtbx.min_sym_equiv_distance_info(
        reference_sites=e,
        others=flex.vec3_double([(x[0]+0.1,x[1]+0.2,x[2]+0.3), x]))
      assert d.i_other() == 1
      assert approx_equal(d.continuous_shifts(), (0,0,0))
      assert approx_equal(d.dist(), 0)
  x = (1.732, -1.414, 2.236)
  for hall_symbol in ("P 1",
                      "P -1 (2,-1,1)",
                      "R 1 (3,2,-1)",
                      "P -4 2 3 (2,1,-1)",
                      "-P 2ab 2bc 3 (1,2,-2)",
                      "F -4 2 3 (-2,2,-1)",
                      "-F 2uv 2vw 3 (1,-2,-1)"):
    g = sgtbx.space_group(hall_symbol)
    e = sym_equiv_sites(g, x)
    c = e.coordinates()
    assert c.size() == g.order_z()
    for i,v in enumerate(c):
      assert approx_equal(g(i) * x, v)
  g = sgtbx.space_group()
  e = sym_equiv_sites(g, (0.016, 0.895, 0.111), uctbx.unit_cell(()))
  d = sgtbx.min_sym_equiv_distance_info(e, (0.939, 0.128, 0.178))
  assert approx_equal(d.dist()**2, 0.064707)
  for hall_symbol,shift_flags in (("P 1", (True,True,True)),
                                  ("P 2", (False,False,True)),
                                  ("P -2", (True,True,False)),
                                  ("P 3x", (True,False,False)),
                                  ("P 3 2", (False,False,False))):
    for x in ((1.732, -1.414, 2.236), (0.939, 0.128, 0.178)):
      g = sgtbx.space_group(hall_symbol)
      e = sym_equiv_sites(g, x, uctbx.unit_cell(()))
      d = sgtbx.min_sym_equiv_distance_info(
        reference_sites=e,
        other=x,
        principal_continuous_allowed_origin_shift_flags=shift_flags)
      assert approx_equal(d.continuous_shifts(), (0,0,0))
      assert approx_equal(d.dist(), 0)
      shift = [s * f for s,f in zip(shift_flags, (0.123,0.234,0.345))]
      for y in e.coordinates():
        d = sgtbx.min_sym_equiv_distance_info(e, y, shift_flags)
        assert approx_equal(d.dist(), 0)
        assert approx_equal(d.sym_op() * y, x)
        z = [y[i]+shift[i] for i in (0,1,2)]
        d = sgtbx.min_sym_equiv_distance_info(e, z, shift_flags)
        assert approx_equal(d.dist(), 0)
        if (shift_flags != (0,0,0)):
          assert not_approx_equal(d.sym_op() * z, x)
        else:
          assert approx_equal(d.sym_op() * z, x)
        fz = flex.vec3_double(1, z)
        assert approx_equal(d.apply(fz)[0], x)
  g = sgtbx.space_group()
  e = sym_equiv_sites(g, (0.1,0.2,0.3), u)
  d = sgtbx.min_sym_equiv_distance_info(e, (0.2,0.4,0.1))
  assert approx_equal(d.diff(), (-0.1,-0.2,0.2))
  assert approx_equal(d.dist(), u.length((-0.1,-0.2,0.2)))
  #
  u = uctbx.unit_cell((3,4,5,80,100,110))
  g = sgtbx.space_group("P 2")
  e = sym_equiv_sites(unit_cell=u, space_group=g, original_site=(0,0,0))
  assert e.coordinates().size() == 1
  e = sym_equiv_sites(
    unit_cell=u,
    space_group=g,
    original_site=(0,0,0),
    minimum_distance=0,
    tolerance=0)
  assert e.coordinates().size() == 2

def exercise_seminvariant():
  space_group = sgtbx.space_group
  structure_seminvariants = sgtbx.structure_seminvariants
  tests = (
    ("P 1",  [((1, 0, 0), 0), ((0, 1, 0), 0), ((0, 0, 1), 0)]),
    ("-P 1", [((1, 0, 0), 2), ((0, 1, 0), 2), ((0, 0, 1), 2)]),

    ("P 2",   [((1, 0, 0), 2), ((0, 1, 0), 2), ((0, 0, 1), 0)]),
    ("P 2y",  [((1, 0, 0), 2), ((0, 1, 0), 0), ((0, 0, 1), 2)]),
    ("P 2x",  [((1, 0, 0), 0), ((0, 1, 0), 2), ((0, 0, 1), 2)]),
    ("P -2",  [((1, 0, 0), 0), ((0, 1, 0), 0), ((0, 0, 1), 2)]),
    ("P -2y", [((1, 0, 0), 0), ((0, 1, 0), 2), ((0, 0, 1), 0)]),
    ("P -2x", [((1, 0, 0), 2), ((0, 1, 0), 0), ((0, 0, 1), 0)]),

    ("P 2 2",   [((1, 0, 0), 2), ((0, 1, 0), 2), ((0, 0, 1), 2)]),
    ("P -2 2",  [((1, 0, 0), 0), ((0, 1, 0), 2), ((0, 0, 1), 2)]),
    ("P -2 -2", [((1, 0, 0), 2), ((0, 1, 0), 0), ((0, 0, 1), 2)]),
    ("P 2 -2",  [((1, 0, 0), 2), ((0, 1, 0), 2), ((0, 0, 1), 0)]),
    ("-P 2 2",  [((1, 0, 0), 2), ((0, 1, 0), 2), ((0, 0, 1), 2)]),

    ("P 3",   [((0, 0, 1), 0), ((1, 2, 0), 3)]),
    ("P 3y",  [((0, 1, 0), 0), ((1, 0, 2), 3)]),
    ("P 3x",  [((1, 0, 0), 0), ((0, 1, 2), 3)]),
    ("P 3*",  [((1, 1, 1), 0)]),
    ("-P 3",  [((0, 0, 1), 2)]),
    ("-P 3y", [((0, 1, 0), 2)]),
    ("-P 3x", [((1, 0, 0), 2)]),
    ("-P 3*", [((1, 1, 1), 2)]),

    ("P 3 2",  [((2, 4, 3), 6)]),
    ("P 3y 2", [((2, 3, 4), 6)]),
    ("P 3x 2", [((3, 2, 4), 6)]),

    ('P 3 2"',  [((0, 0, 1), 2)]),
    ('P 3y 2"', [((0, 1, 0), 2)]),
    ('P 3x 2"', [((1, 0, 0), 2)]),

    ("P 4",   [((0, 0, 1), 0), ((1, 1, 0), 2)]),
    ("P 4y",  [((0, 1, 0), 0), ((1, 0, 1), 2)]),
    ("P 4x",  [((1, 0, 0), 0), ((0, 1, 1), 2)]),
    ("-P 4",  [((0, 0, 1), 2), ((1, 1, 0), 2)]),
    ("-P 4y", [((0, 1, 0), 2), ((1, 0, 1), 2)]),
    ("-P 4x", [((1, 0, 0), 2), ((0, 1, 1), 2)]),

    ("P 6",  [((0, 0, 1), 0)]),
    ("P 6y", [((0, 1, 0), 0)]),
    ("P 6x", [((1, 0, 0), 0)]),

    ("-C 2 2",   [((1, 0, 0), 2), ((0, 0, 1), 2)]),
    ("-I 2 2",   [((1, 0, 0), 2), ((0, 1, 0), 2)]),
    ("-F 2 2",   [((1, 0, 0), 2)]),
    ("-I 4",     [((0, 0, 1), 2)]),
    ("-I 2 2 3", []),

    ("C 2y",    [((0, 1, 0), 0), ((0, 0, 1), 2)]),
    ("C -2y",   [((1, 0, 0), 0), ((0, 0, 1), 0)]),
    ("C 2 -2",  [((1, 0, 0), 2), ((0, 0, 1), 0)]),
    ("C 2 2",   [((1, 0, 0), 2), ((0, 0, 1), 2)]),
    ("A 2 -2",  [((1, 0, 0), 2), ((0, 0, 1), 0)]),
    ("I 2 -2",  [((1, 0, 0), 2), ((0, 0, 1), 0)]),
    ("I 2 2",   [((1, 0, 0), 2), ((0, 1, 0), 2)]),
    ("F 4 2 3", [((1, 0, 0), 2)]),
    ("F 2 2",   [((1, 1, 1), 4)]),
    ("I 4",     [((0, 0, 1), 0)]),
    ("I 4 2",   [((0, 0, 1), 2)]),
    ("I -4",    [((2, 0, 1), 4)]),
    ("F 2 -2",  [((0, 0, 1), 0)]),
    ("I 2 3",   []),
  )
  for hs,vfy in tests:
    g = space_group(hs)
    ss = structure_seminvariants(space_group=g)
    assert ss.size() == len(ss.vectors_and_moduli())
    assert [(vm.v, vm.m) for vm in ss.vectors_and_moduli()] == vfy
  ss = structure_seminvariants(space_group("P 2 -2"))
  assert ss.is_ss(miller_index=(2,-2,0))
  assert ss.apply_mod(miller_index=(2,-2,0)) == (0,0,0)
  assert not ss.is_ss((2,1,0))
  assert ss.apply_mod((2,1,0)) == (0,1,0)
  ss = structure_seminvariants(space_group("C 2y"))
  assert ss.is_ss((2,0,4))
  assert ss.apply_mod((2,0,4)) == (0,0)
  assert not ss.is_ss((2,1,4))
  assert ss.apply_mod((2,1,4)) == (1,0)
  ss = structure_seminvariants(space_group("C 2 2"))
  assert ss.is_ss((4,2,6))
  assert ss.apply_mod((4,2,6)) == (0,0)
  assert not ss.is_ss((3,2,4))
  assert ss.apply_mod((3,2,4)) == (1,0)
  assert ss.apply_mod((2,3,5)) == (0,1)
  assert ss.apply_mod((3,3,5)) == (1,1)
  ss = structure_seminvariants(space_group("I 4"))
  assert ss.is_ss((1,3,0))
  assert ss.apply_mod((1,3,0)) == (0,)
  assert not ss.is_ss((1,3,4))
  assert ss.apply_mod((1,3,4)) == (4,)
  ss = structure_seminvariants(space_group("I 2 3"))
  assert ss.is_ss((1,3,4))
  assert ss.apply_mod((1,3,4)) == ()
  ss = structure_seminvariants(space_group("I -4"))
  assert ss.gridding() == (2,1,4)
  assert ss.refine_gridding(grid=(3,2,10)) == (6,2,20)
  ss = structure_seminvariants(space_group("P -2x"))
  a = ss.grid_adapted_moduli(dim=(3,5,7))
  assert [vm.m for vm in a] == [2,5,7]
  ss = structure_seminvariants(space_group("P 3*"))
  a = ss.grid_adapted_moduli((3,5,7))
  assert [vm.m for vm in a] == [3*5*7]
  a = ss.grid_adapted_moduli((3,5,12))
  assert [vm.m for vm in a] == [60]
  ss = structure_seminvariants(space_group("P 2 -2"))
  ss_continuous = ss.select(discrete=False)
  assert ss_continuous.size() == 1
  assert ss_continuous.vectors_and_moduli()[0].m == 0
  assert ss_continuous.vectors_and_moduli()[0].v == (0,0,1)
  ss_discrete = ss.select(discrete=True)
  assert ss_discrete.size() == 2
  assert ss_discrete.vectors_and_moduli()[0].m == 2
  assert ss_discrete.vectors_and_moduli()[0].v == (1,0,0)
  assert ss_discrete.vectors_and_moduli()[1].m == 2
  assert ss_discrete.vectors_and_moduli()[1].v == (0,1,0)
  assert ss.continuous_shifts_are_principal()
  assert ss.principal_continuous_shift_flags() == (False,False,True)
  assert approx_equal(
    ss.subtract_principal_continuous_shifts(translation=[1,2,3]), [1,2,0])
  ss = structure_seminvariants(space_group("P 3*"))
  assert not ss.continuous_shifts_are_principal()
  assert ss.principal_continuous_shift_flags(assert_principal=False) \
      == (True,True,True)
  assert approx_equal(
    ss.subtract_principal_continuous_shifts(
      translation=[1,2,3], assert_principal=False), [0,0,0])

def exercise_lattice_symmetry():
  reduced_cell = uctbx.unit_cell((12,13,14,80,83,86))
  lattice_group = sgtbx.lattice_symmetry_group(
    reduced_cell=reduced_cell,
    max_delta=3,
    enforce_max_delta_for_generated_two_folds=False)
  assert lattice_group.order_z() == 1
  assert sgtbx.lattice_symmetry_find_max_delta(
    reduced_cell=reduced_cell, space_group=lattice_group) < 1.e-10

def exercise_lattice_symmetry_options():
  niggli_cell = uctbx.unit_cell((405.08382,411.53719,417.48903,
                                  89.97113,89.77758,89.90342))
  testing_combinations=[(0.9,True,10),(0.9,False,10),
                        (1.4,True,10),(1.4,False,30),
                        (1.8,True,30),(1.8,False,30)]
  for max_delta,enforce,n_subgrps in testing_combinations:
    group = sgtbx.lattice_symmetry_group(
      reduced_cell=niggli_cell,
      max_delta=max_delta,
      enforce_max_delta_for_generated_two_folds=enforce)
    group_info = sgtbx.space_group_info(group=group)
    subgrs = subgroups.subgroups(group_info).groups_parent_setting()
    assert len(subgrs) == n_subgrps

def exercise_find_affine():
  for sym,n in [("P 1",67704),("P 2",104),("C 2y",36),("B 2x",36),("A 2z",36)]:
    group = sgtbx.space_group(sym)
    for use_p1_algorithm in [False, True]:
      affine = sgtbx.find_affine(group, 2)
      cb_mx = affine.cb_mx()
      assert len(cb_mx) == n
      if (group.n_smx() == 1): break

def exercise_search_symmetry():
  f = sgtbx.search_symmetry_flags(use_space_group_symmetry=True)
  f = sgtbx.search_symmetry_flags(
    use_space_group_symmetry=False,
    use_space_group_ltr=1,
    use_seminvariants=False,
    use_normalizer_k2l=True,
    use_normalizer_l2n=False)
  assert not f.use_space_group_symmetry()
  assert f.use_space_group_ltr() > 0
  assert not f.use_seminvariants()
  assert f.use_normalizer_k2l()
  assert not f.use_normalizer_l2n()
  assert f == f
  assert not f != f
  assert f == sgtbx.search_symmetry_flags(False, 1, False, True, False)
  assert not f != sgtbx.search_symmetry_flags(False, 1, False, True, False)
  assert f != sgtbx.search_symmetry_flags(True, 0, True, False, True)
  assert not f == sgtbx.search_symmetry_flags(False, 0, True, False, True)
  for use_space_group_symmetry in [False, True]:
    for use_space_group_ltr in [-1,0,1]:
      for use_seminvariants in [False, True]:
        for use_normalizer_k2l in [False, True]:
          for use_normalizer_l2n in [False, True]:
            f = sgtbx.search_symmetry_flags(
              use_space_group_symmetry,
              use_space_group_ltr,
              use_seminvariants,
              use_normalizer_k2l,
              use_normalizer_l2n)
            p = pickle.dumps(f)
            l = pickle.loads(p)
            assert l == f
  sg143 = sgtbx.space_group_info("P 3")
  ss143 = sg143.structure_seminvariants()
  sg146 = sgtbx.space_group_info("R 3 h")
  ss146 = sg146.structure_seminvariants()
  sg149 = sgtbx.space_group_info("P 3 1 2")
  ss149 = sg149.structure_seminvariants()
  s = sgtbx.search_symmetry(
    flags=sgtbx.search_symmetry_flags(False, 0, False, False, False),
    space_group_type=sg149.type())
  assert s.subgroup().type().lookup_symbol() == "P 1"
  s = sgtbx.search_symmetry(
    flags=sgtbx.search_symmetry_flags(True, 0, False, False, False),
    space_group_type=sg149.type())
  assert s.subgroup().type().lookup_symbol() == "P 3 1 2"
  s = sgtbx.search_symmetry(
    flags=sgtbx.search_symmetry_flags(False, 1, False, False, False),
    space_group_type=sg149.type())
  assert s.subgroup().type().lookup_symbol() == "P 1"
  s = sgtbx.search_symmetry(
    flags=sgtbx.search_symmetry_flags(False, 0, True, False, False),
    space_group_type=sg149.type(),
    seminvariant=ss149)
  assert s.subgroup() \
      == sgtbx.space_group("P 1 (-1/3*y-1/3*z,1/3*y-2/3*z,1/2*x)")
  assert s.continuous_shifts() == ()
  assert s.continuous_shifts_are_principal()
  assert s.continuous_shift_flags(assert_principal=True) == (False,False,False)
  s = sgtbx.search_symmetry(
    flags=sgtbx.search_symmetry_flags(False, 0, False, True, False),
    space_group_type=sg149.type())
  assert s.subgroup() == sgtbx.space_group("-P 1")
  s = sgtbx.search_symmetry(
    flags=sgtbx.search_symmetry_flags(False, 0, False, False, True),
    space_group_type=sg149.type())
  assert s.subgroup() == sgtbx.space_group("P 2z")
  s = sgtbx.search_symmetry(
    flags=sgtbx.search_symmetry_flags(True, 0, False, True, False),
    space_group_type=sg149.type())
  assert s.subgroup().type().lookup_symbol() == "P -3 1 m"
  s = sgtbx.search_symmetry(
    flags=sgtbx.search_symmetry_flags(True, 0, False, True, True),
    space_group_type=sg149.type())
  assert s.flags() == sgtbx.search_symmetry_flags(True, 0, False, True, True)
  assert s.subgroup().type().lookup_symbol() == "P 6/m m m"
  s = sgtbx.search_symmetry(
    flags=sgtbx.search_symmetry_flags(True, 0, True, True, True),
    space_group_type=sg149.type(),
    seminvariant=ss149)
  assert s.subgroup() \
      == sgtbx.space_group("-P 6 2 (1/3*x+1/3*y,-1/3*x+2/3*y,1/2*z)")
  s = sgtbx.search_symmetry(
    flags=sgtbx.search_symmetry_flags(False, 1, False, False, False),
    space_group_type=sg146.type())
  assert s.subgroup() == sgtbx.space_group("R 1")
  s = sgtbx.search_symmetry(
    flags=sgtbx.search_symmetry_flags(True, 0, False, True, False),
    space_group_type=sg146.type())
  assert s.subgroup() == sgtbx.space_group("R -3")
  s = sgtbx.search_symmetry(
    flags=sgtbx.search_symmetry_flags(True, 0, False, True, True),
    space_group_type=sg146.type())
  assert s.subgroup() == sgtbx.space_group('-R 3 2"')
  s = sgtbx.search_symmetry(
    flags=sgtbx.search_symmetry_flags(True, 0, False, True, True),
    space_group_type=sg146.type())
  assert s.subgroup() == sgtbx.space_group('-R 3 2"')
  s = sgtbx.search_symmetry(
    flags=sgtbx.search_symmetry_flags(False, 0, False, False, False),
    space_group_type=sg146.type(),
    seminvariant=ss146)
  assert s.subgroup().type().lookup_symbol() == "P 1"
  s = sgtbx.search_symmetry(
    flags=sgtbx.search_symmetry_flags(False, 0, True, False, False),
    space_group_type=sg146.type(),
    seminvariant=ss146)
  assert s.subgroup() == sgtbx.space_group("R 1")
  s = sgtbx.search_symmetry(
    flags=sgtbx.search_symmetry_flags(False, -1, True, False, False),
    space_group_type=sg146.type(),
    seminvariant=ss146)
  assert s.subgroup() == sgtbx.space_group("P 1")
  s = sgtbx.search_symmetry(
    flags=sgtbx.search_symmetry_flags(False, 0, True, False, False),
    space_group_type=sg143.type(),
    seminvariant=ss143)
  assert s.subgroup().type().hall_symbol() \
      == " P 1 (2/3*x-1/3*y,1/3*x+1/3*y,z)"
  assert s.continuous_shifts() == ((0,0,1),)
  assert s.continuous_shifts_are_principal()
  assert s.continuous_shift_flags() == (False,False,True)
  s = sgtbx.search_symmetry(
    flags=sgtbx.search_symmetry_flags(True, 0, True, True, True),
    space_group_type=sg143.type(),
    seminvariant=ss143)
  assert s.subgroup().type().hall_symbol() \
      == "-P 6 2 (1/3*x+1/3*y,-1/3*x+2/3*y,z)"
  assert s.continuous_shifts() == ((0,0,1),)
  sg1 = sgtbx.space_group_info(number=1)
  ss1 = sg1.structure_seminvariants()
  s = sgtbx.search_symmetry(
    flags=sgtbx.search_symmetry_flags(True, 0, True, True, True),
    space_group_type=sg1.type(),
    seminvariant=ss1)
  assert s.subgroup() == sgtbx.space_group("-P 1")
  assert s.continuous_shifts() == ((1, 0, 0), (0, 1, 0), (0, 0, 1))
  assert s.continuous_shifts_are_principal()
  assert s.continuous_shift_flags() == (True,True,True)
  sg6 = sgtbx.space_group_info(number=6)
  ss6 = sg6.structure_seminvariants()
  s = sgtbx.search_symmetry(
    flags=sgtbx.search_symmetry_flags(True, 0, True, True, True),
    space_group_type=sg6.type(),
    seminvariant=ss6)
  assert s.subgroup() == sgtbx.space_group("-P 2y (x,1/2*y,z)")
  assert s.continuous_shifts() == ((1, 0, 0), (0, 0, 1))
  assert s.continuous_shift_flags() == (True,False,True)
  sg146r = sgtbx.space_group_info("R 3 r")
  ss146r = sg146r.structure_seminvariants()
  s = sgtbx.search_symmetry(
    flags=sgtbx.search_symmetry_flags(False, 0, True, False, False),
    space_group_type=sg146r.type(),
    seminvariant=ss146r)
  assert s.subgroup() == sgtbx.space_group("P 1")
  assert s.continuous_shifts() == ((1, 1, 1),)
  assert not s.continuous_shifts_are_principal()
  assert s.continuous_shift_flags(assert_principal=False) == (True,True,True)
  sg144 = sgtbx.space_group_info("P 31")
  ss144 = sg144.structure_seminvariants()
  s = sgtbx.search_symmetry(
    flags=sgtbx.search_symmetry_flags(True, 0, True, False, False),
    space_group_type=sg144.type(),
    seminvariant=ss144)
  assert s.subgroup() == sgtbx.space_group("P 31 (1/3*x+1/3*y,-1/3*x+2/3*y,z)")
  assert s.projected_subgroup() \
      == sgtbx.space_group("P 3 (1/3*x+1/3*y,-1/3*x+2/3*y,z)")

def exercise_tensor_rank_2_constraints():
  u = uctbx.unit_cell((12,12,15,90,90,120))
  g = sgtbx.space_group("P 6 2")
  ss = sgtbx.site_symmetry(u, g, (0,0,0))
  tr2ca = sgtbx.tensor_rank_2_constraints
  tr2cb = sgtbx.rank_2_tensor_constraints
  for tr2c in (tr2ca,tr2cb):
    for c in (tr2c(
                space_group=g,
                reciprocal_space=False),
              tr2c(
                symmetry_matrices=ss.matrices(),
                i_first_matrix_to_use=1,
                reciprocal_space=False)):
      assert list(c.row_echelon_form()) \
          == [1,-1,0,0,0,0,0,1,0,2,0,0,0,0,0,0,1,1,0,0,0,0,0,1]
    for c in [tr2c(
                space_group=g,
                reciprocal_space=True),
              tr2c(
                symmetry_matrices=ss.matrices(),
                i_first_matrix_to_use=1,
                reciprocal_space=True),
              ss.adp_constraints()]:
      assert list(c.row_echelon_form()) \
          == [1,-1,0,0,0,0,0,1,0,-2,0,0,0,0,0,0,1,-1,0,0,0,0,0,1]
      assert list(c.independent_indices) == [2,3]
      assert approx_equal(c.gradient_sum_matrix(), [0,0,1,0,0,0, 2,2,0,1,0,0])
      assert c.n_independent_params() == 2
      assert c.n_dependent_params() == 4
      assert approx_equal(c.independent_params(all_params=[1,2,3,4,5,6]), [3,4])
      assert approx_equal(c.all_params(independent_params=[1,2]), [4,4,1,2,0,0])
      a = [1,2,3,4,5,6]
      s = [3+1/3.,3+1/3.,3,-3-1/3.,0,0]
      assert approx_equal(c.independent_gradients(all_gradients=a), [3,10])
      assert approx_equal(c.independent_gradients(all_gradients=s), [3,10])
      a = flex.double(range(1,22))
      assert approx_equal(c.independent_curvatures(all_curvatures=a),[12,35,116])

def exercise_hashing():
  # rt_mx
  sg = sgtbx.space_group('P 4 2 3')
  op_set = set([ op for op in sg ])
  assert len(op_set) == len(sg)
  for g in sg:
    assert g in op_set

  # rot_mx, tr_vec
  d = {}
  for op in sg:
    d.setdefault(op.r(), set())
    d[op.r()].add(op.t())
  for g in sg:
    assert g.r() in d
    assert g.t() in d[g.r()]

  # space_group
  symbol_set = set([ symbol.hall()
                     for symbol in sgtbx.space_group_symbol_iterator() ])
  assert len(symbol_set) == 527
  sg_list = [ sgtbx.space_group(symbol).make_tidy() for symbol in symbol_set ]
  sg_set = set(sg_list)
  assert len(sg_set) == len(sg_list)
  for sg in sg_list:
    assert sg in sg_set

  sg = sgtbx.space_group('P 2z')
  sg.expand_smx(sgtbx.rt_mx('-x, y, -z'))
  try:
    hash(sg)
    raise Exception_expected
  except RuntimeError as e:
    assert str(e).find("tidy") != -1

def exercise_fractional_mod():
  assert approx_equal(
    sgtbx.fractional_mod_positive((-0.1, 0.2, -0.3)),
    (0.9, 0.2, 0.7))
  assert approx_equal(
    sgtbx.fractional_mod_short((0.4, 0.9, 0.7)),
    (0.4, -0.1, -0.3))


def exercise_repr():
  for i in range(1, 231):
    sgi = sgtbx.space_group_info(number=i)
    assert eval(repr(sgi)).group() == sgi.group()


def run():
  exercise_repr()
  exercise_symbols()
  exercise_tr_vec()
  exercise_rot_mx()
  exercise_rt_mx()
  exercise_change_of_basis_op()
  exercise_space_group()
  exercise_space_group_type()
  exercise_phase_info()
  exercise_reciprocal_space_asu()
  exercise_brick()
  exercise_site_symmetry()
  exercise_wyckoff()
  exercise_sym_equiv_sites()
  exercise_seminvariant()
  exercise_lattice_symmetry()
  exercise_lattice_symmetry_options()
  exercise_find_affine()
  exercise_search_symmetry()
  exercise_tensor_rank_2_constraints()
  exercise_hashing()
  exercise_fractional_mod()
  print(format_cpu_times())

if (__name__ == "__main__"):
  run()


 *******************************************************************************


 *******************************************************************************
cctbx/sgtbx/bravais_types.py
from __future__ import absolute_import, division, print_function
from six.moves import range
acentric = (
"P 1",
"P 1 2 1",
"C 1 2 1",
"P 2 2 2",
"C 2 2 2",
"F 2 2 2",
"I 2 2 2",
"P 4 2 2",
"I 4 2 2",
"P 6 2 2",
"R 3 2 :H",
"P 4 3 2",
"I 4 3 2",
"F 4 3 2",
)

centric = (
"P -1",
"P 1 2/m 1",
"C 1 2/m 1",
"P m m m",
"C m m m",
"F m m m",
"I m m m",
"P 4/m m m",
"I 4/m m m",
"P 6/m m m",
"R -3 m :H",
"P m -3 m",
"I m -3 m",
"F m -3 m",
)

class bravais_lattice(object):
  """Reference:  Table 1.2 (page 4) and Table 2.1.1 (page 13) of
  International Tables for Crystallography, Volume A Space Group Symmetry,
  ed. Theo Hahn, Fourth, revised edition, Kluwer Academic Publishers, 1996.
  """

  def __init__(self,
               symbol=None,
               group=None,
               number=None):
    from cctbx import sgtbx
    self.space_group_info = sgtbx.space_group_info(symbol=symbol,
                                                   group=group,
                                                   number=number)
    self.space_group = self.space_group_info.group()
    self.crystal_system = self.space_group.crystal_system()
    self.centring_symbol = self.space_group.conventional_centring_type_symbol()

  crystal_family_symbols = {"Triclinic":'a',
                            "Monoclinic":'m',
                            "Orthorhombic":'o',
                            "Tetragonal":'t',
                            "Trigonal":'h',
                            "Hexagonal":'h',
                            "Cubic":'c'
                            }

  def __str__(self):
    return "%s%s"%(self.crystal_family_symbols[self.crystal_system],
                   self.centring_symbol)

  def __eq__(self, other):
    return str(self) == str(other)

  def __ne__(self, other):
    return str(self) != str(other)

def tst_bravais_types(verbose):
  from cctbx import sgtbx
  from cctbx.sgtbx.subgroups import subgroups

  bravais_types_reference = {"aP":2,"mP":8,"mC":5,"mA":0,"mI":0,"mB":0,"oP":30,"oC":11,
                             "oA":4,"oB":0,"oI":9,"oF":5,"tP":49,"tI":19,"hP":45,"hR":7,
                             "cP":15,"cI":10,"cF":11}

  bravais_types_tally = {}
  for key in bravais_types_reference: bravais_types_tally[key]=0

  crystal_systems_reference = {"Triclinic":2,"Monoclinic":13,"Orthorhombic":59,"Tetragonal":68,
                               "Trigonal":25,"Hexagonal":27,"Cubic":36}
  crystal_systems_tally = {}
  for key in crystal_systems_reference: crystal_systems_tally[key]=0

  for space_group_number in range(1,231):
    space_group_info = sgtbx.space_group_info(number=space_group_number)
    GC = bravais_lattice(number=space_group_number)
    GC_1 = bravais_lattice(group=space_group_info.group())
    GC_2 = bravais_lattice(symbol=str(space_group_info))
    assert GC == GC_1
    assert GC == GC_2
    bravais_types_tally[str(GC)]+=1
    crystal_systems_tally[GC.crystal_system]+=1
    if verbose:
      GC.space_group_info.show_summary()
      print(str(GC), GC.crystal_system)

    # idea, not fully implemented--more extensive testing by generating all subgroups
    if False:
      subgrs = subgroups(parent_group_info).groups_parent_setting()
      for subgroup in subgrs:
        subgroup_info = sgtbx.space_group_info(group=subgroup)
        subgroup_info.show_summary()
        bravais_lattice(subgroup_info.type().lookup_symbol())

  return (bravais_types_tally==bravais_types_reference and
          crystal_systems_tally==crystal_systems_reference)

def exercise():
  from cctbx import sgtbx
  import sys
  for symbol in acentric + centric:
    space_group_info = sgtbx.space_group_info(symbol=symbol)
    assert str(space_group_info) == symbol
    assert space_group_info.is_reference_setting()
  if ("--Verbose" in sys.argv[1:]):
    for symbol in centric:
      print("/* %s */ %d," % (
        symbol, sgtbx.space_group_info(symbol=symbol).type().number()))
  assert tst_bravais_types(verbose=("--Verbose" in sys.argv[1:]))
  print("OK")

if (__name__ == "__main__"):
  exercise()


 *******************************************************************************


 *******************************************************************************
cctbx/sgtbx/cosets.py
from __future__ import absolute_import, division, print_function
from cctbx import sgtbx
from scitbx.array_family import flex
import sys
from six.moves import range

class partition_t(list): pass

class left_decomposition(object):
  def __init__(self, g, h):
    g_lattice_translations = [ g(i,0,0).mod_short() for i in range(g.n_ltr())]

    if self.is_subgroup(g,h):
      self.h_name = str( sgtbx.space_group_info( group = h ) )
      self.g_name = str( sgtbx.space_group_info( group = g ) )
      g = [s for s in g] # for speed, convert to plain Python list
      h = [s for s in h]
      assert len(g) % len(h) == 0
      assert h[0].is_unit_mx()
      self.partition_indices = [-1] * len(g)
      self.partitions = []
      for i,gi in enumerate(g):
        if (self.partition_indices[i] != -1): continue
        self.partition_indices[i] = len(self.partitions)
        partition = partition_t([gi])
        for hj in h[1:]:
          gihj = gi.multiply(hj)
          for k in range(i+1,len(g)):
            if (self.partition_indices[k] != -1): continue
            gk = g[k]
            tmp_g = gk.inverse().multiply( gihj ).mod_short()
            if tmp_g.as_xyz() in [ltr.as_xyz() for ltr in g_lattice_translations]:
              self.partition_indices[k] = len(self.partitions)
              partition.append(gk)
              break
          else:
            raise RuntimeError("h is not a subgroup of g")
        if (len(partition) != len(h)):
          raise RuntimeError("h is not a subgroup of g")
        self.partitions.append(partition)
      if (len(self.partitions) * len(h) != len(g)):
        raise RuntimeError("h is not a subgroup of g")
      #sort cosets by operator order
      self.sort_cosets()
    else:
      raise RuntimeError("h is not a subgroup of g")

  def is_subgroup(self, g, h):
    tst_group = str( sgtbx.space_group_info(group=g) )
    tst_group = sgtbx.space_group_info( tst_group ).group()
    h = [s for s in h]
    for s in h:
      tst_group.expand_smx( s )
    if str(sgtbx.space_group_info(group=tst_group)) == str( sgtbx.space_group_info(group=g) ):
      return True
    else:
      return False

  def sort_cosets(self):
    new_partitions = []
    for pp in self.partitions:
      orders = []
      for op in pp:
        orders.append( op.r().info().type() )
      orders = flex.sort_permutation( flex.int(orders) )
      tmp = partition_t()
      for ii in orders:
        tmp.append( pp[ii] )
      new_partitions.append( tmp )
    self.partitions = new_partitions

  def show(self,out=None, cb_op=None, format="cosets_form"):
    from cctbx.sgtbx.literal_description import literal_description
    if out is None:
      out = sys.stdout
    count=0
    group_g = self.g_name
    group_h = self.h_name
    if cb_op is not None:
      group_g = str( sgtbx.space_group_info( self.g_name ).change_basis( cb_op ) )
      group_h = str( sgtbx.space_group_info( self.h_name ).change_basis( cb_op ) )

    print("Left cosets of :", file=out)
    print("  subgroup  H: %s"%( group_h ), file=out)
    print("  and group G: %s"%( group_g ), file=out)
    for part in self.partitions:
      extra_txt="   (all operators from H)"

      tmp_group = sgtbx.space_group_info( self.h_name ).group()
      tmp_group.expand_smx( part[0] )
      if cb_op is None:
        tmp_group = sgtbx.space_group_info( group=tmp_group)
      else:
        tmp_group = sgtbx.space_group_info( group=tmp_group).change_basis(cb_op)

      if count>0:
        extra_txt = "   (H+coset[%i] = %s)"%(count,tmp_group)
      print(file=out)
      print("  Coset number : %5s%s"%(count, extra_txt), file=out)
      print(file=out)
      count += 1
      for item in part:
        tmp_item = None
        if cb_op is None:
          tmp_item = item
        else:
          tmp_item = cb_op.apply( item )

        print(literal_description(tmp_item).select(format), file=out)


class left_decomposition_point_groups_only(object):

  def __init__(self, g, h):
    def convert_to_plain_list(group): # for speed
      assert group.n_ltr() == 1
      result = []
      for s in group:
        assert s.t().is_zero()
        result.append(s)
      return result
    g = convert_to_plain_list(group=g)
    h = convert_to_plain_list(group=h)
    assert len(g) % len(h) == 0
    assert h[0].is_unit_mx()
    self.partition_indices = [-1] * len(g)
    self.partitions = []
    for i,gi in enumerate(g):
      if (self.partition_indices[i] != -1): continue
      self.partition_indices[i] = len(self.partitions)
      partition = [gi]
      for hj in h[1:]:
        gihj = gi.multiply(hj)
        for k in range(i+1,len(g)):
          if (self.partition_indices[k] != -1): continue
          gk = g[k]
          if (gk.r().num() == gihj.r().num()):
            self.partition_indices[k] = len(self.partitions)
            partition.append(gk)
            break
        else:
          raise RuntimeError("h is not a subgroup of g")
      if (len(partition) != len(h)):
        raise RuntimeError("h is not a subgroup of g")
      self.partitions.append(partition)
    if (len(self.partitions) * len(h) != len(g)):
      raise RuntimeError("h is not a subgroup of g")

  def best_partition_representatives(self,
        cb_op=None,
        omit_first_partition=False,
        omit_negative_determinants=False):
    result = []
    for partition in self.partitions:
      best_choice, best_choice_as_hkl = None, None
      for choice in partition:
        if (omit_first_partition and choice.is_unit_mx()):
          assert best_choice is None
          break
        if (omit_negative_determinants and choice.r().determinant() < 0):
          continue
        if (cb_op is not None):
          choice = cb_op.apply(choice)
        choice_as_hkl = choice.r().as_hkl()
        if (best_choice_as_hkl is None
            or sgtbx.compare_cb_op_as_hkl(
                 best_choice_as_hkl, choice_as_hkl) > 0):
          best_choice, best_choice_as_hkl = choice, choice_as_hkl
      if (best_choice is not None):
        result.append(best_choice)
    return result

def double_unique(g, h1, h2):
  """g is the supergroup
     h1 and h2 are subgroups
  """
  # Make lists of symops for all groups
  g = [s for s in g]
  h1 = [s for s in h1]
  h2 = [s for s in h2]
  # this is our final result
  result = []
  # This set keeps track of equivalent symops
  done = set()
  #
  for a in g:
    if (str( a ) in done): continue
    result.append(a)
    for hi in h1:
      for hj in h2:
        b = hi.multiply(a).multiply(hj)
        done.add(str( b ))
  return result

def construct_nice_cb_op(coset,
                         sym_transform_1_to_2,
                         to_niggli_1,
                         to_niggli_2):
  best_choice = None
  best_choice_as_hkl = None
  to_niggli_2 = to_niggli_2.new_denominators( to_niggli_1 )
  sym_transform_1_to_2 = sym_transform_1_to_2.new_denominators( to_niggli_1 )

  for coset_element in coset:
    tmp_coset_element = sgtbx.change_of_basis_op(coset_element)
    tmp_coset_element = tmp_coset_element.new_denominators( to_niggli_1 )
    tmp_op = to_niggli_1.inverse() \
           * (tmp_coset_element * sym_transform_1_to_2) \
           * to_niggli_2
    if (best_choice_as_hkl is None
        or sgtbx.compare_cb_op_as_hkl(
             best_choice_as_hkl, tmp_op.as_hkl()) > 0):
      best_choice = tmp_op
      best_choice_as_hkl =  tmp_op.as_hkl()
  assert best_choice is not None

  tmptmp = sgtbx.change_of_basis_op(coset[0])

  return best_choice

class double_cosets(object):
  def __init__(self,g, h1, h2, enforce_det_ge_1=True):
    """g is the supergroup
       h1 and h2 are subgroups
    """
    # Make lists of symops for all groups
    g = [s for s in g]
    h1 = [s for s in h1]
    h2 = [s for s in h2]

    # a list of lists with our double cosets
    self.double_cosets = []

    #
    for a in g:
      # first we have to check whether or not
      # this symmetry operator is allready in a coset we
      # might have constructured earlier
      if not self.is_in_list_of_cosets( a ):
        # not present, make de double coset please
        tmp_double_coset = []
        tmp_double_coset.append( a )
        # The other members will now be made
        for hi in h1:
          for hj in h2:
            b = hi.multiply(a).multiply(hj)
            #check if this element is allready in this coset please
            if not self.is_in_coset( b, tmp_double_coset ):
              tmp_double_coset.append( b )
        self.double_cosets.append( tmp_double_coset )
    if enforce_det_ge_1:
      self.clear_up_cosets()

  def clear_up_cosets(self):
    temp_cosets = []
    for cs in self.double_cosets:
      if cs[0].r().determinant() > 0:
        temp_cosets.append( cs )
    self.double_cosets = temp_cosets

  def is_in_coset(self, a, coset_list):
    found_it=False
    for hi in coset_list:
      if ( str(hi.mod_positive() ) == str(a.mod_positive() ) ):
        found_it = True
        break
    return found_it

  def is_in_list_of_cosets( self, a ):
    found_it = False
    for cs in self.double_cosets:
      if self.is_in_coset( a, cs ):
        found_it = True
    return found_it

  def have_duplicates(self):
    n_cosets = len(self.double_cosets)
    for ics in range(n_cosets):
      tmp_cs = self.double_cosets[ics]
      for jcs in range(n_cosets):
        if ics != jcs :
          tmp_cs_2 = self.double_cosets[jcs]
          # now check each element of tmp_cs
          for hi in tmp_cs:
            if (self.is_in_coset(hi, tmp_cs_2)): return True
    return False

  def show(self,out=None):
    if out == None:
      out = sys.stdout
    print("The double cosets are listed below", file=out)
    for cs in self.double_cosets:
      for a in cs:
        print("("+str(a)+")    ", end=' ', file=out)
      print(file=out)

def test_double_coset_decomposition():
  from  cctbx.sgtbx import subgroups
  for space_group_number in range(17,44):
    parent_group_info = sgtbx.space_group_info(space_group_number)
    subgrs = subgroups.subgroups(parent_group_info).groups_parent_setting()
    g = parent_group_info.group()
    for h1 in subgrs:
      for h2 in subgrs:
        tmp_new = double_cosets(g, h1, h2)
        assert not tmp_new.have_duplicates()

def test_lattice_translation_aware_left_decomposition():
  from cctbx import crystal
  def generate_cases():
    yield { 'group':crystal.symmetry( space_group_info = sgtbx.space_group_info( 'C 2 2 21' ),
                                      unit_cell = (74.033, 96.747, 109.085, 90, 90, 90) ),
         'subgroup':crystal.symmetry( space_group_info = sgtbx.space_group_info( 'C 2 1 1' ),
                                      unit_cell = (74.033, 96.747, 109.085, 89.98, 90, 90) )}
    yield { 'group':crystal.symmetry( space_group_info = sgtbx.space_group_info( 'F 2 3' ),
                                      unit_cell = (124.059, 124.059, 124.059, 90, 90, 90) ),
         'subgroup':crystal.symmetry( space_group_info = sgtbx.space_group_info( 'R 3 :H (-1/2*x+z,1/2*x-1/2*y+z,1/2*y+z)' ),
                                      unit_cell = (124.059, 124.059, 124.059, 90.0003, 90.0003, 90.0003) )}
    yield { 'group':crystal.symmetry( space_group_info = sgtbx.space_group_info( 'P 6 2 2' ),
                                      unit_cell = (94.705, 94.705, 57.381, 90, 90, 120) ),
         'subgroup':crystal.symmetry( space_group_info = sgtbx.space_group_info( 'P 6' ),
                                      unit_cell = (94.705, 94.705, 57.381, 90, 90, 120) )}
    yield { 'group':crystal.symmetry( space_group_info = sgtbx.space_group_info( 'I 2 3' ),
                                      unit_cell = (80.8965, 80.8965, 80.8965, 90, 90, 90) ),
         'subgroup':crystal.symmetry( space_group_info = sgtbx.space_group_info( 'R 3 :H (y+1/2*z,-x+1/2*z,x-y+1/2*z)' ),
                                      unit_cell = (80.8965, 80.8965, 80.8965, 89.993, 89.993, 89.993) )}
    yield { 'group':crystal.symmetry( space_group_info = sgtbx.space_group_info( 'P 61 2 2' ),
                                      unit_cell = (115.7, 115.7, 247.2, 90, 90, 120) ),
         'subgroup':crystal.symmetry( space_group_info = sgtbx.space_group_info( 'P 31 2 1 (a,b,c-1/6)' ),
                                      unit_cell = (115.7, 115.7, 247.2, 90, 90, 120) )}
    yield { 'group':crystal.symmetry( space_group_info = sgtbx.space_group_info( 'P 41 21 2' ),
                                      unit_cell = (64.766, 64.766, 270.651, 90, 90, 90) ),
         'subgroup':crystal.symmetry( space_group_info = sgtbx.space_group_info( 'P 41 (a,b+1/2,c)' ),
                                      unit_cell = (64.766, 64.766, 270.651, 90, 90, 90) )}
    yield { 'group':crystal.symmetry( space_group_info = sgtbx.space_group_info( 'I 4 2 2' ),
                                      unit_cell = (124.282, 124.282, 117.485, 90, 90, 90) ),
         'subgroup':crystal.symmetry( space_group_info = sgtbx.space_group_info( 'I 2 1 1' ),
                                      unit_cell = (124.265, 124.299, 117.485, 89.9919, 90, 90) )}
    yield { 'group':crystal.symmetry( space_group_info = sgtbx.space_group_info( 'P 43 21 2' ),
                                      unit_cell = (100.228, 100.228, 294.099, 90, 90, 90) ),
         'subgroup':crystal.symmetry( space_group_info = sgtbx.space_group_info( 'C 2 2 21 (x-y,x+y,z)' ),
                                      unit_cell = (100.228, 100.228, 294.099, 90, 90, 90.0036) )}
    yield { 'group':crystal.symmetry( space_group_info = sgtbx.space_group_info( 'P 43 3 2' ),
                                      unit_cell = (170.4, 170.4, 170.4, 90, 90, 90) ),
         'subgroup':crystal.symmetry( space_group_info = sgtbx.space_group_info( 'P 21 3' ),
                                      unit_cell = (170.4, 170.4, 170.4, 90, 90, 90) )}
    yield { 'group':crystal.symmetry( space_group_info = sgtbx.space_group_info( 'R 3 2 :H' ),
                                      unit_cell = (221.819, 221.819, 55.601, 90, 90, 120) ),
         'subgroup':crystal.symmetry( space_group_info = sgtbx.space_group_info( 'C 1 2 1 (3/2*a-1/2*b+c,b,c)' ),
                                      unit_cell = (221.835, 221.787, 55.601, 90, 89.9905, 119.993) )}
    yield { 'group':crystal.symmetry( space_group_info = sgtbx.space_group_info( 'P 64 2 2' ),
                                      unit_cell = (142.63, 142.63, 108.35, 90, 90, 120) ),
         'subgroup':crystal.symmetry( space_group_info = sgtbx.space_group_info( 'P 31' ),
                                      unit_cell = (142.63, 142.63, 108.35, 90, 90, 120) )}
    yield { 'group':crystal.symmetry( space_group_info = sgtbx.space_group_info( 'I 41 3 2' ),
                                      unit_cell = (134.242, 134.242, 134.242, 90, 90, 90) ),
         'subgroup':crystal.symmetry( space_group_info = sgtbx.space_group_info( 'I 21 3' ),
                                      unit_cell = (134.242, 134.242, 134.242, 90, 90, 90) )}
    yield { 'group':crystal.symmetry( space_group_info = sgtbx.space_group_info( 'P 41 21 2' ),
                                      unit_cell = (86.8055, 86.8055, 75.688, 90, 90, 90) ),
         'subgroup':crystal.symmetry( space_group_info = sgtbx.space_group_info( 'P 21 21 21 (a+1/4,b,c-3/8)' ),
                                      unit_cell = (86.782, 86.829, 75.688, 90, 90, 90) )}
    yield { 'group':crystal.symmetry( space_group_info = sgtbx.space_group_info( 'P 31 2 1' ),
                                      unit_cell = (97.868, 97.868, 208.953, 90, 90, 120) ),
         'subgroup':crystal.symmetry( space_group_info = sgtbx.space_group_info( 'C 1 2 1 (x+y,-x+y,z)' ),
                                      unit_cell = (97.8535, 97.8535, 208.953, 89.9913, 90.0087, 119.971) )}
    yield { 'group':crystal.symmetry( space_group_info = sgtbx.space_group_info( 'I 4 3 2' ),
                                      unit_cell = (121.805, 121.805, 121.805, 90, 90, 90) ),
         'subgroup':crystal.symmetry( space_group_info = sgtbx.space_group_info( 'I 2 3' ),
                                      unit_cell = (121.805, 121.805, 121.805, 90, 90, 90) )}
    yield { 'group':crystal.symmetry( space_group_info = sgtbx.space_group_info( 'P 43 2 2' ),
                                      unit_cell = (67.472, 67.472, 174.41, 90, 90, 90) ),
         'subgroup':crystal.symmetry( space_group_info = sgtbx.space_group_info( 'P 2 2 21 (a,b,c-1/4)' ),
                                      unit_cell = (67.479, 67.465, 174.41, 90, 90, 90) )}
    yield { 'group':crystal.symmetry( space_group_info = sgtbx.space_group_info( 'C 2 2 21' ),
                                      unit_cell = (47.623, 120.166, 57.648, 90, 90, 90) ),
         'subgroup':crystal.symmetry( space_group_info = sgtbx.space_group_info( 'P 1 (a+b,a-b,-c)' ),
                                      unit_cell = (47.623, 120.166, 57.648, 90.0124, 89.86, 89.9641) )}
    yield { 'group':crystal.symmetry( space_group_info = sgtbx.space_group_info( 'I 2 2 2' ),
                                      unit_cell = (57.816, 75.599, 155.949, 90, 90, 90) ),
         'subgroup':crystal.symmetry( space_group_info = sgtbx.space_group_info( 'P 1 (b+c,a+c,a+b)' ),
                                      unit_cell = (57.816, 75.599, 155.949, 89.9824, 90.0357, 90.02) )}
    yield { 'group':crystal.symmetry( space_group_info = sgtbx.space_group_info( 'P 41 21 2' ),
                                      unit_cell = (97.6539, 97.6539, 215.352, 90, 90, 90) ),
         'subgroup':crystal.symmetry( space_group_info = sgtbx.space_group_info( 'C 1 2 1 (x-y,x+y,z-1/4)' ),
                                      unit_cell = (97.6539, 97.6539, 215.352, 90, 90, 90.022) )}
    yield { 'group':crystal.symmetry( space_group_info = sgtbx.space_group_info( 'P 62 2 2' ),
                                      unit_cell = (58.306, 58.306, 137.882, 90, 90, 120) ),
         'subgroup':crystal.symmetry( space_group_info = sgtbx.space_group_info( 'P 32 1 2 (a,b,c-1/6)' ),
                                      unit_cell = (58.306, 58.306, 137.882, 90, 90, 120) )}
    yield { 'group':crystal.symmetry( space_group_info = sgtbx.space_group_info( 'P 3 2 1' ),
                                      unit_cell = (56.2477, 56.2477, 158.706, 90, 90, 120) ),
         'subgroup':crystal.symmetry( space_group_info = sgtbx.space_group_info( 'C 1 2 1 (x+y,-x+y,z)' ),
                                      unit_cell = (56.2235, 56.2235, 158.706, 89.9654, 90.0346, 119.915) )}
    yield { 'group':crystal.symmetry( space_group_info = sgtbx.space_group_info( 'F 2 2 2' ),
                                      unit_cell = (88.492, 90.284, 90.6894, 90, 90, 90) ),
         'subgroup':crystal.symmetry( space_group_info = sgtbx.space_group_info( 'C 1 2 1 (a,b,a+2*c)' ),
                                      unit_cell = (88.492, 90.284, 90.6894, 90, 89.9856, 90) )}
    yield { 'group':crystal.symmetry( space_group_info = sgtbx.space_group_info( 'I 41' ),
                                      unit_cell = (59.2061, 59.2061, 59.48, 90, 90, 90) ),
         'subgroup':crystal.symmetry( space_group_info = sgtbx.space_group_info( 'P 1 (b+c,a+c,a+b)' ),
                                      unit_cell = (59.1874, 59.2247, 59.48, 90.0179, 89.956, 89.9542) )}
    yield { 'group':crystal.symmetry( space_group_info = sgtbx.space_group_info( 'P 3 1 2' ),
                                      unit_cell = (56.9, 56.9, 62.77, 90, 90, 120) ),
         'subgroup':crystal.symmetry( space_group_info = sgtbx.space_group_info( 'P 3' ),
                                      unit_cell = (56.9, 56.9, 62.77, 90, 90, 120) )}
    yield { 'group':crystal.symmetry( space_group_info = sgtbx.space_group_info( 'P 43' ),
                                      unit_cell = (54.111, 54.111, 71.637, 90, 90, 90) ),
         'subgroup':crystal.symmetry( space_group_info = sgtbx.space_group_info( 'P 1 1 21' ),
                                      unit_cell = (54.09, 54.132, 71.637, 90, 90, 90.04) )}
    yield { 'group':crystal.symmetry( space_group_info = sgtbx.space_group_info( 'P 4 3 2' ),
                                      unit_cell = (122.638, 122.638, 122.638, 90, 90, 90) ),
         'subgroup':crystal.symmetry( space_group_info = sgtbx.space_group_info( 'P 2 3' ),
                                      unit_cell = (122.638, 122.638, 122.638, 90, 90, 90) )}
    yield { 'group':crystal.symmetry( space_group_info = sgtbx.space_group_info( 'P 62' ),
                                      unit_cell = (115.246, 115.246, 67.375, 90, 90, 120) ),
         'subgroup':crystal.symmetry( space_group_info = sgtbx.space_group_info( 'P 1 1 2' ),
                                      unit_cell = (115.246, 115.242, 67.375, 90, 90, 119.997) )}
    yield { 'group':crystal.symmetry( space_group_info = sgtbx.space_group_info( 'P 63' ),
                                      unit_cell = (103.371, 103.371, 91.38, 90, 90, 120) ),
         'subgroup':crystal.symmetry( space_group_info = sgtbx.space_group_info( 'P 1 1 21' ),
                                      unit_cell = (103.35, 103.36, 91.38, 90, 90, 119.97) )}
    yield { 'group':crystal.symmetry( space_group_info = sgtbx.space_group_info( 'P 65 2 2' ),
                                      unit_cell = (183.226, 183.226, 141.117, 90, 90, 120) ),
         'subgroup':crystal.symmetry( space_group_info = sgtbx.space_group_info( 'C 1 2 1 (x-y,2*x,z)' ),
                                      unit_cell = (183.108, 183.285, 141.117, 90.0433, 90, 119.968) )}
    yield { 'group':crystal.symmetry( space_group_info = sgtbx.space_group_info( 'F 41 3 2' ),
                                      unit_cell = (228.763, 228.763, 228.763, 90, 90, 90) ),
         'subgroup':crystal.symmetry( space_group_info = sgtbx.space_group_info( 'I 41 (c,a+b,-a+b)' ),
                                      unit_cell = (228.574, 228.858, 228.858, 90, 90, 90) )}

  for case in generate_cases():
    C = left_decomposition(g=case['group'].space_group(), h = case['subgroup'].space_group())

    # double check that the first partition is identical to the subgroup:
    for element in case['subgroup'].space_group():
      assert element in C.partitions[0]

    # make sure each coset is equal to the product of the coset representative and the subgroup
    for x in range(1,len(C.partitions)):
      part = C.partitions[x]
      coset_representative = part[0]
      for element in case['subgroup'].space_group():
        assert coset_representative.multiply(element).mod_short().as_xyz() in [
          i.mod_short().as_xyz() for i in part]

def run():
  test_double_coset_decomposition()
  test_lattice_translation_aware_left_decomposition()
  print("OK")

if (__name__ == "__main__"):
  run()


 *******************************************************************************


 *******************************************************************************
cctbx/sgtbx/direct_space_asu/__init__.py
from __future__ import absolute_import, division, print_function
from cctbx import sgtbx
from cctbx.sgtbx.direct_space_asu import cut_plane
from cctbx.sgtbx.direct_space_asu.short_cuts import r1
from scitbx import matrix
import sys
from six.moves import range

class direct_space_asu(object):

  def __init__(self, hall_symbol, cuts=[]):
    self.hall_symbol = hall_symbol
    self.cuts = cuts[:]

  def __copy__(self):
    return direct_space_asu(
      hall_symbol=self.hall_symbol,
      cuts=self.cuts)

  def __and__(self, obj):
    self.cuts.append(obj)
    return self

  def show_summary(self, f=None):
    if (f == None): f = sys.stdout
    print("Hall symbol:", self.hall_symbol, file=f)
    print("Number of cuts:", len(self.cuts), file=f)
    return self

  def show_comprehensive_summary(self, f=None):
    if (f == None): f = sys.stdout
    self.show_summary(f)
    for cut in self.cuts:
      print("    &", cut, file=f)
    return self

  def is_inside(self, point, shape_only=False):
    """Check if a given point in direct space is inside the asymmetric unit.
    The coordinates of the point are expected to be factional coordinates.
    To use cartesian coordinates you can use something like:
    asu.is_inside(unit_cell.fractionalize(site_cart)).

    :param shape_only: If set to 'True' ??? #XXX what exactly is this option for?
    :type shape_only: boolean

    :returns: True if point is inside the asymmetric unit
    :rtype: boolean
    """
    if (shape_only):
      for cut in self.cuts:
        if (cut.evaluate(point) < 0): return False
    else:
      for cut in self.cuts:
        if (not cut.is_inside(point)): return False
    return True

  def in_which_cuts(self, point):
    result = []
    for cut in self.cuts:
      if (cut.evaluate(point) == 0):
        result.append(cut)
    return result

  def extract_all_cuts(self):
    result = []
    for cut in self.cuts:
      cut.extract_all_cuts(result)
    return result

  def shape_only(self):
    result = direct_space_asu(self.hall_symbol)
    for cut in self.cuts:
      result.cuts.append(cut.strip())
    return result

  def shape_vertices(self):
    result = set()
    cuts = self.cuts
    n_cuts = len(cuts)
    for i0 in range(0,n_cuts-2):
      for i1 in range(i0+1,n_cuts-1):
        for i2 in range(i1+1,n_cuts):
          m = matrix.rec(cuts[i0].n+cuts[i1].n+cuts[i2].n,(3,3))
          d = m.determinant()
          if (d != 0):
            m_inv = m.co_factor_matrix_transposed() * (r1/d)
            b = matrix.col([-cuts[i0].c,-cuts[i1].c,-cuts[i2].c])
            vertex = m_inv * b
            if (self.is_inside(vertex, shape_only=True)):
              result.add(vertex.elems)
    return sorted(result)

  def _box_corner(self, shape_vertices, min_or_max):
    if (shape_vertices is None):
      shape_vertices = self.shape_vertices()
    if (len(shape_vertices) == 0):
      return None
    result = list(shape_vertices[0])
    for vertex in shape_vertices[1:]:
      for i in range(3):
        result[i] = min_or_max(result[i], vertex[i])
    return result

  def box_min(self, shape_vertices=None):
    return self._box_corner(shape_vertices, min)

  def box_max(self, shape_vertices=None):
    return self._box_corner(shape_vertices, max)

  def add_plane(self, normal_direction, point=None):
    if (point is None):
      point = self.box_min()
    self.cuts.append(cut_plane.cut(
      n=normal_direction,
      c=-(matrix.col(normal_direction).dot(matrix.col(point)))))

  def add_planes(self, normal_directions, point=None, both_directions=False):
    if (point is None):
      point = self.box_min()
    for normal_direction in normal_directions:
      self.add_plane(normal_direction=normal_direction, point=point)
      if (both_directions):
        self.cuts.append(-self.cuts[-1])

  def change_basis(self, cb_op):
    if (not isinstance(cb_op, sgtbx.change_of_basis_op)):
      cb_op = sgtbx.change_of_basis_op(cb_op)
    cb_hall_symbol = None
    if (self.hall_symbol is not None):
      space_group_info = sgtbx.space_group_info("Hall: " + self.hall_symbol)
      cb_space_group_info = space_group_info.change_basis(cb_op)
      cb_hall_symbol = cb_space_group_info.type().hall_symbol()
    cb_asu = direct_space_asu(cb_hall_symbol)
    for cut in self.cuts:
      cb_asu.cuts.append(cut.change_basis(cb_op))
    return cb_asu

  def define_metric(self, unit_cell):
    import cctbx.crystal.direct_space_asu
    return cctbx.crystal.direct_space_asu.direct_space_asu(
      asu=self, unit_cell=unit_cell)

  def add_buffer(self, unit_cell, thickness=None, relative_thickness=None):
    return self.define_metric(unit_cell).add_buffer(
      thickness=thickness,
      relative_thickness=relative_thickness)


 *******************************************************************************


 *******************************************************************************
cctbx/sgtbx/direct_space_asu/check_redundancies.py
from __future__ import absolute_import, division, print_function
from cctbx.sgtbx.direct_space_asu import reference_table
from cctbx.web.asu_gallery import jv_asu
from cctbx import sgtbx
from scitbx import matrix
from scitbx.python_utils import dicts
from scitbx.python_utils import command_line
from libtbx import easy_run
from boost_adaptbx.boost import rational
import sys, os
from libtbx.math_utils import cmp
from six.moves import range
from six.moves import zip

class colored_grid_point(object):

  def __init__(self, site, color):
    self.site = tuple(site)
    self.color = color

def sample_asu(asu, n=(12,12,12), shape=False, is_stripped_asu=False):
  n_redundancies = 0
  u_grid=[]
  for i in range(n[0]):
     b = []
     for j in range(n[1]):
        c = []
        for k in range(n[2]):
           c.append(0)
        b.append(c)
     u_grid.append(b)
  r_grid = []
  colored_grid_points = []
  for i in range(-n[0]//2, n[0]+1):
    b = []
    for j in range(-n[1]//2, n[1]+1):
      c = []
      for k in range(-n[2]//2, n[2]+1):
        frac = rational.vector((i,j,k), n)
        f = asu.is_inside(frac)
        fv = asu.is_inside(frac, shape_only=True)
        if (len(asu.in_which_cuts(frac)) != 0 and fv):
          colored_grid_points.append(colored_grid_point(
            frac,
            jv_asu.select_color(f)))
        if (shape):
          if (not fv): assert not f
        else:
          fv = False
        if (f or fv):
          i_pr = i % n[0]
          j_pr = j % n[1]
          k_pr = k % n[2]
          if (u_grid[i_pr][j_pr][k_pr] != 0):
            n_redundancies += 1
            if (not is_stripped_asu):
              print("Redundancy at" , (i,j,k), (i_pr,j_pr,k_pr))
          if (f):
            u_grid[i_pr][j_pr][k_pr] = 1
            c.append(1)
          else:
            u_grid[i_pr][j_pr][k_pr] = 2
            c.append(2)
        else:
          c.append(0)
      b.append(c)
    r_grid.append(b)
  return u_grid, r_grid, colored_grid_points, n_redundancies

def check_compatibility_with_sampling_grid(asu):
  print("Shape vertices:")
  n_outside_sampling_grid = 0
  for vertex in asu.shape_vertices():
    s = ""
    for v in vertex:
      if (v < -rational.int(1,2) or v > 1):
        s = " outside sampling grid"
        n_outside_sampling_grid += 1
        break
    print("  %s%s" % (str(vertex), s))
  assert n_outside_sampling_grid == 0

def check_asu(group_type_number, asu, n, is_stripped_asu, soft_mode):
  sg_info = sgtbx.space_group(asu.hall_symbol).info()
  sg_info.show_summary()
  if (group_type_number > 0):
    assert sg_info.type().number() == group_type_number
  print("Gridding:", n)
  ops = sg_info.group()
  check_compatibility_with_sampling_grid(asu=asu)
  sys.stdout.flush()
  u_grid, r_grid, colored_grid_points, sampling_n_redundancies = sample_asu(
    asu, n, is_stripped_asu=is_stripped_asu)
  n_redundancies = 0
  redundancies = {}
  for i in range(n[0]):
    for j in range(n[1]):
      for k in range(n[2]):
        n_redundancies += grid_asu(
          ops=ops, n=n, u_grid=u_grid, r_grid=r_grid, i=i,j=j,k=k,
          sampling_n_redundancies=sampling_n_redundancies,
          redundancies=redundancies,
          soft_mode=soft_mode)
  print("number of redundancies: %d+%d," % (
    sampling_n_redundancies, n_redundancies), end=' ')
  sg_info.show_summary()
  sys.stdout.flush()
  redundancies = sort_redundancies(redundancies)
  recolor_grid_points(
    n, colored_grid_points, redundancies, not is_stripped_asu)
  jv_asu.asu_as_jvx(
    group_type_number, asu, colored_grid_points=colored_grid_points)
  if (not is_stripped_asu):
    analyze_redundancies(asu, n, redundancies)
    if (not soft_mode):
      assert sampling_n_redundancies == 0
      assert n_redundancies == 0
  sys.stdout.flush()

class color_server(object):

  def __init__(self):
    self.color_pairs = (
      ((0,0,255), (153,204,255)),
      ((255,255,0), (255,153,0)),
      ((255,0,255), (255,102,153)),
      ((51,51,51), (178,178,178)))
    self.i = -1

  def next(self):
    if (self.i < len(self.color_pairs)-1):
      self.i += 1
    return self.color_pairs[self.i]

def recolor_grid_points(gridding, colored_grid_points, redundancies, verbose):
  color_srv = color_server()
  processed_points = {}
  for symop,pairs in redundancies:
    if (verbose):
      print("Coloring %d redundancies:" % len(pairs), symop)
    sys.stdout.flush()
    colored_point_dict = {}
    for colored_point in colored_grid_points:
      colored_point_dict[colored_point.site] = colored_point
    colors = next(color_srv)
    for pair in pairs:
      for point,color in zip(pair, colors):
        frac = tuple(rational.vector(point, gridding))
        if (not frac in processed_points):
          processed_points[frac] = 1
          colored_point_dict[frac].color = color

def iround(x):
  if (x < 0):
    return int(x-0.5)
  return int(x+0.5)

def rt_plus_unit_shifts(rt, unit_shifts):
  return sgtbx.rt_mx(rt.r(), rt.t().plus(sgtbx.tr_vec(unit_shifts, 1)))

def rt_times_grid_point(rt, i_grid, n):
  grid_point = matrix.col([i_grid[i]/float(n[i]) for i in range(3)])
  rotat = matrix.sqr(rt.r().as_double())
  trans = matrix.col(rt.t().as_double())
  eq_pt = rotat*grid_point+trans
  eq_gpt = [0,0,0]
  unit_shifts = [0,0,0]
  for i in range(3):
    eg = iround(eq_pt.elems[i]*n[i])
    eq_gpt[i] = eg % n[i]
    u = float(eq_gpt[i] - eg) / n[i]
    unit_shifts[i] = iround(u)
    assert abs(u - unit_shifts[i]) < 1.e-5
  return tuple(eq_gpt), rt_plus_unit_shifts(rt, unit_shifts)

def u_index_as_r_index(n, u_index, r_grid, allow_ambiguity):
  r_index = None
  for ui in (0,-1,1):
    ri = u_index[0] + ui * n[0]
    qi = ri + n[0]//2
    if (qi < 0 or qi >= n[0]//2+n[0]+1): continue
    for uj in (0,-1,1):
      rj = u_index[1] + uj * n[1]
      qj = rj + n[1]//2
      if (qj < 0 or qj >= n[1]//2+n[1]+1): continue
      for uk in (0,-1,1):
        rk = u_index[2] + uk * n[2]
        qk = rk + n[2]//2
        if (qk < 0 or qk >= n[2]//2+n[2]+1): continue
        if (r_grid[qi][qj][qk] != 0):
          if (r_index is None):
            r_index, unit_shifts = (ri,rj,rk), (ui,uj,uk)
          else:
            assert allow_ambiguity, "Double redundancy."
  assert r_index is not None
  return r_index, unit_shifts

def grid_asu(
      ops,
      n,
      u_grid,
      r_grid,
      i,j,k,
      sampling_n_redundancies,
      redundancies,
      soft_mode):
  result = 0
  marker = 0
  for rt in ops:
    eq_gpt, rtu = rt_times_grid_point(rt, (i,j,k), n)
    #assert str(rt_times_grid_point(rtu, (i,j,k), n)[1]) == str(rtu)
    if (u_grid[i][j][k] != 0):
      marker = 1
      if (eq_gpt[0] != i or eq_gpt[1] != j or eq_gpt[2] != k):
        if (u_grid[eq_gpt[0]][eq_gpt[1]][eq_gpt[2]] != 0):
          r_pivot, us_pivot = u_index_as_r_index(n, (i,j,k), r_grid,
            allow_ambiguity=sampling_n_redundancies!=0)
          u_eq, rtu = rt_times_grid_point(rt, r_pivot, n)
          r_eq, us_eq = u_index_as_r_index(n, u_eq, r_grid,
            allow_ambiguity=sampling_n_redundancies!=0)
          rtuu = rt_plus_unit_shifts(rtu, us_eq)
          s = str(rtuu)
          v = r_pivot, r_eq
          #print "Redundancy at", v, s
          result += 1
          try: redundancies[s].append(v)
          except KeyboardInterrupt: raise
          except Exception: redundancies[s] = [v]
    else:
      if (u_grid[eq_gpt[0]][eq_gpt[1]][eq_gpt[2]] != 0):
        marker = 1
        break
  if (marker != 1):
    print("Orbit does not intersect with asymmetric unit", (i,j,k))
    assert soft_mode
  return result

def compare_redundancies(a, b):
  # Deprecated. Do not use
  return cmp(len(b[1]), len(a[1]))

def sort_redundancies(redundancies):
  return sorted(redundancies.items(), key=lambda element: len(element[1]), reverse=True)

def str_ev(ev):
  return "[%d,%d,%d]" % ev

def slice(pairs, i):
  result = []
  for pair in pairs:
    result.append(pair[i])
  return result

def rt_mx_analysis(s):
  r_info = sgtbx.rot_mx_info(s.r())
  t_info = sgtbx.translation_part_info(s)
  t_intrinsic = str(t_info.intrinsic_part().mod_positive())
  t_shift = str(t_info.origin_shift().mod_positive())
  if (r_info.type() == 1):
    return ("1", "-", "-", "-")
  if (r_info.type() == -1):
    return (str(r_info.type()), "-", "-", "location=(%s)" % (t_shift,))
  if (abs(r_info.type()) == 2):
    return (str(r_info.type()),
            "axis="+str_ev(r_info.ev()),
            "(%s)" % (t_intrinsic,),
            "location=(%s)" % (t_shift,))
  sense = "+"
  if (r_info.sense() < 0):
    sense = "-"
  return (str(r_info.type())+sense,
          "axis="+str_ev(r_info.ev()),
          "(%s)" % (t_intrinsic,),
          "location=(%s)" % (t_shift,))

def analyze_redundancies(asu, n, redundancies, verbose=1):
  if (len(redundancies) == 0): return
  print("Overview:")
  for symop, pairs in redundancies:
    print(symop, ": number of redundancies:", len(pairs))
    print("  ", rt_mx_analysis(sgtbx.rt_mx(symop)))
  print("Details:")
  for symop, pairs in redundancies:
    print(symop, ": number of redundancies:", len(pairs))
    print("  ", rt_mx_analysis(sgtbx.rt_mx(symop)))
    all_cuts = dicts.with_default_factory(dict)
    not_in_cuts = {}
    for pair in pairs:
      for point in pair:
        cuts = asu.in_which_cuts(rational.vector(point, n))
        if (len(cuts) == 0):
          not_in_cuts[point] = 1
        all_cuts[tuple(cuts)][point] = 1
    print("    In cuts:")
    for cuts,points in all_cuts.items():
      print("     ", end=' ')
      show_amp = False
      for cut in cuts:
        if (show_amp): print("&", end=' ')
        print(cut, end=' ')
        show_amp = True
      print("#points: %d:" % len(points), end=' ')
      # FIXME : ordering of keys in py2/3 is different
      print(str(list(points.keys())[:4]).replace(" ", ""))
    if (verbose):
      print("    Pairs:")
      for pair in pairs:
        print("      ", pair)
    if (len(not_in_cuts) > 0):
      print("    Not in cuts:")
      for point in not_in_cuts.keys():
        print("     ", point)
      raise AssertionError("Some redundant points not in any cuts.")
    print()

def check_multiplicities(asu, n):
  space_group = sgtbx.space_group(asu.hall_symbol)
  all_cuts = asu.extract_all_cuts()
  print("Total number of cuts:", len(all_cuts))
  def get_code(point):
    result = 0
    bit = 1
    for cut in all_cuts:
      if (cut.evaluate(point) == 0):
        result += bit
      bit *= 2
    return result
  mults_by_code = {}
  for i in range(-n[0]//2, n[0]+1):
    for j in range(-n[1]//2, n[1]+1):
      for k in range(-n[2]//2, n[2]+1):
        point = rational.vector((i,j,k), n)
        if (asu.is_inside(point)):
          code = get_code(point)
          if (code != 0):
            m = space_group.multiplicity(site=point)
            mults_by_code.setdefault(code, set()).add(m)
  for code,mults in mults_by_code.items():
    if (len(mults) != 1):
      print("PROBLEM:", space_group.type().number(), mults_by_code)
      break
  else:
    print("cut intersection multiplicities unique:")
    order_z = space_group.order_z()
    tab_codes = []
    for code in sorted(mults_by_code.keys()):
      m = list(mults_by_code[code])[0]
      if (m != order_z):
        print(code, m)
        tab_codes.append((code, m))
    print("Number of cut intersection codes:", len(tab_codes))

def test_all(n):
  for space_group_number in range(1, 231):
    cmd = "cctbx.python %s" % sys.argv[0] \
        + " %d,%d,%d " % n +str(space_group_number)
    print(cmd)
    sys.stdout.flush()
    easy_run.call(cmd)
    print()
    sys.stdout.flush()

if (__name__=="__main__"):
  flags = command_line.parse_options(sys.argv[1:], [
    "show_asu",
    "strip",
    "strip_grid",
    "strip_polygons",
    "enantiomorphic",
    "soft",
    "multiplicities",
    "plane_group",
  ])
  assert len(flags.regular_args) > 0
  gridding = flags.regular_args[0].split(",")
  assert len(gridding) in (1,3)
  gridding = tuple([int(n) for n in gridding])
  if (len(gridding) == 1): gridding *= 3
  if (not os.path.isdir("asu_gallery")):
    os.mkdir("asu_gallery")
  if (len(flags.regular_args) == 1):
    if (not flags.enantiomorphic):
      test_all(gridding)
    else:
      flags.regular_args.extend([str(i) for i in
       (76, 78, 91, 95, 92, 96,
        144, 145, 151, 153, 152, 154,
        169, 170, 171, 172, 178, 179, 180, 181,
        212, 213)])
  if (len(flags.regular_args) > 1):
    for arg in flags.regular_args[1:]:
      numbers = [int(n) for n in arg.split('-')]
      assert len(numbers) in (1,2)
      if (len(numbers) == 1): numbers *= 2
      for group_type_number in range(numbers[0], numbers[1]+1):
        if (not flags.plane_group):
          asu_original = reference_table.get_asu(group_type_number)
          assert sgtbx.space_group(asu_original.hall_symbol) \
              == sgtbx.space_group_info(number=group_type_number).group()
        else:
          from cctbx.sgtbx.direct_space_asu import plane_group_reference_table
          asu_original = plane_group_reference_table.get_asu(
            point_group_number=group_type_number)
          print("Plane group number:", group_type_number)
          group_type_number *= -1
        asu = asu_original
        if (flags.strip or flags.strip_polygons):
          asu = asu_original.shape_only()
        print("Writing asu_gallery files")
        jv_asu.asu_as_jvx(group_type_number, asu)
        if (flags.strip_grid):
          asu = asu_original.shape_only()
        if (flags.show_asu):
          asu.show_comprehensive_summary()
        check_asu(
          group_type_number=group_type_number,
          asu=asu,
          n=gridding,
          is_stripped_asu=(flags.strip or flags.strip_grid),
          soft_mode=flags.soft)
        if (flags.multiplicities):
          check_multiplicities(
            asu=asu_original,
            n=gridding)


 *******************************************************************************


 *******************************************************************************
cctbx/sgtbx/direct_space_asu/cut_plane.py
from __future__ import absolute_import, division, print_function
from libtbx import slots_getstate_setstate
from scitbx import matrix
from boost_adaptbx.boost import rational
import string
from six.moves import range
from six.moves import zip

class cut_expr_ops(slots_getstate_setstate):

  __slots__ = []

  def __and__(self, other): return cut_expression("&", self, other)
  def __or__(self, other): return cut_expression("|", self, other)

class cut_expression(cut_expr_ops):

  __slots__ = ["op", "lhs", "rhs"]

  def __init__(self, op, lhs, rhs):
    self.op = op
    self.lhs = lhs
    self.rhs = rhs

  def __repr__(self):
    if (self.op == "&"):
      if (isinstance(self.lhs, cut) or self.lhs.op == "&"):
        lhs = str(self.lhs)
      else:
        lhs = "(" + str(self.lhs) + ")"
      if (isinstance(self.rhs, cut) or self.rhs.op == "&"):
        return lhs + " & " + str(self.rhs)
      return lhs + " & (" + str(self.rhs) + ")"
    if (self.op == "|"):
      return str(self.lhs) + " | " + str(self.rhs)
    raise RuntimeError

  def as_xyz(self):
    if (self.op == "&"):
      if (isinstance(self.lhs, cut) or self.lhs.op == "&"):
        lhs = self.lhs.as_xyz()
      else:
        lhs = "(" + self.lhs.as_xyz() + ")"
      if (isinstance(self.rhs, cut) or self.rhs.op == "&"):
        return lhs + " & " + self.rhs.as_xyz()
      return lhs + " & (" + self.rhs.as_xyz() + ")"
    if (self.op == "|"):
      return self.lhs.as_xyz() + " | " + self.rhs.as_xyz()
    raise RuntimeError

  def is_inside(self, point):
    if (self.op == "&"):
      return self.lhs.is_inside(point) and self.rhs.is_inside(point)
    if (self.op == "|"):
      return self.lhs.is_inside(point) or self.rhs.is_inside(point)
    raise RuntimeError

  def extract_all_cuts(self, result):
    self.lhs.extract_all_cuts(result)
    self.rhs.extract_all_cuts(result)

  def change_basis(self, cb_op):
    return cut_expression(
      self.op,
      self.lhs.change_basis(cb_op),
      self.rhs.change_basis(cb_op))

class cut(cut_expr_ops):

  __slots__ = ["n", "c", "inclusive", "cut_expr"]

  def __init__(self, n, c, inclusive=True, cut_expr=None):
    assert inclusive in (True, False)
    assert cut_expr is None or isinstance(cut_expr, cut_expr_ops)
    self.n = tuple(n)
    self.c = c
    self.inclusive = inclusive
    self.cut_expr = cut_expr

  def __repr__(self):
    s = self.base_symbol()
    if (not self.inclusive): s = "+" + s
    if (self.has_cuts()):
      if (("*" in s or "/" in s) and s[-1] in string.digits):
        s = "(" + s + ")"
      s += "(" + str(self.cut_expr) + ")"
    return s

  def as_xyz(self):
    n_negative = 0
    n_non_zero = 0
    for n in self.n:
      if (n < 0): n_negative += 1
      if (n != 0): n_non_zero += 1
    if (n_non_zero == 1):
      if (n_negative == 0):
        f = 1
      else:
        f = -1
    else:
      if (self.c > 0): n_negative += 1
      if (n_negative <= n_non_zero//2):
        f = 1
      else:
        f = -1
    s = ""
    for n,x in zip(self.n, "xyz"):
      nf = n * f
      if (nf == 0): continue
      if (nf > 0): s += "+"
      if (abs(nf) != 1):
        s += "%s*%s" % (str(nf), x)
      else:
        if (nf < 0): s += "-"
        s += x
    if (s[0] == "+"):
      s = s[1:]
    if (f > 0):
      s += ">"
    else:
      s += "<"
    if (self.inclusive):
      s += "="
    s += str(-self.c*f)
    if (self.has_cuts()):
      s += " [" + self.cut_expr.as_xyz() + "]"
    return s

  def base_symbol(self):
    from cctbx.sgtbx.direct_space_asu import short_cuts
    n = tuple(self.n)
    minus_n = tuple([-e for e in n])
    matching_n = None
    for key,value in short_cuts.__dict__.items():
      if (isinstance(value, cut)):
        if (value.n == n):
          if (value.c == self.c):
            return key
          elif (value.c == -self.c):
            return "-~"+key
          elif (value.c == 1):
            assert matching_n is None
            if (self.c < 0):
              matching_n = "-~"+key
            else:
              matching_n = key
        elif (value.n == minus_n):
          if (value.c == -self.c):
            return "-"+key
          elif (value.c == self.c):
            return "~"+key
          elif (value.c == 1):
            assert matching_n is None
            if (self.c < 0):
              matching_n = "-"+key
            else:
              matching_n = "~"+key
    c = short_cuts.r1 * self.c
    num = c.numerator()
    abs_num = abs(num)
    den = c.denominator()
    if (matching_n is None):
      if (num == 0):
        s = "0"
      else:
        s = "r1"
        if (num < 0): s = "-"+s
        if (abs_num != 1): s += "*"+str(abs_num)
        if (den != 1): s += "/"+str(den)
      return "cut(" + str(self.n).replace(" ", "") + "," + s + ")"
    s = matching_n
    assert num != 0
    if (abs_num != 1): s += "*"+str(abs_num)
    if (den != 1): s += "/"+str(den)
    return s

  def __pos__(self):
    "unsets inclusive flag"
    assert self.inclusive == True
    assert self.cut_expr is None
    return cut(self.n, self.c, inclusive=False)

  def __neg__(self):
    "-n, -c: flips inside/outside"
    return cut(n=[-e for e in self.n], c=-self.c,
               inclusive=self.inclusive, cut_expr=self.cut_expr)

  def __invert__(self):
    "-n, c"
    return cut(n=[-e for e in self.n], c=self.c,
               inclusive=self.inclusive, cut_expr=self.cut_expr)

  def __mul__(self, other):
    assert isinstance(other, int)
    return cut(n=self.n, c=other*self.c,
               inclusive=self.inclusive, cut_expr=self.cut_expr)

  def __truediv__(self, other):
    assert isinstance(other, int)
    assert other != 0
    assert self.c != 0
    return cut(n=self.n, c=rational.int(1)*self.c/other,
               inclusive=self.inclusive, cut_expr=self.cut_expr)

  def __div__(self, other):
    return self.__truediv__(other)

  def one(self):
    return cut(n=self.n, c=1,
               inclusive=self.inclusive, cut_expr=self.cut_expr)

  def __call__(self, expr):
    assert self.inclusive == True
    assert self.cut_expr is None
    return cut(self.n, self.c, cut_expr=expr)

  def has_cuts(self):
    return self.cut_expr is not None

  def evaluate(self, point):
    result = self.c
    for i in range(3):
      result += self.n[i] * point[i]
    return result

  def is_inside(self, point):
    i = self.evaluate(point)
    if (i < 0): return False
    if (i > 0): return True
    if (not self.has_cuts()): return self.inclusive
    return self.cut_expr.is_inside(point)

  def extract_all_cuts(self, result):
    result.append(self)
    if (self.has_cuts()):
      self.cut_expr.extract_all_cuts(result)

  def strip(self):
    return cut(self.n, self.c)

  def change_basis(self, cb_op):
    r_inv_tp = cb_op.c_inv().r().as_rational().transpose()
    t = cb_op.c().t().as_rational()
    np = r_inv_tp * matrix.col(self.n)
    cp = self.c - np.dot(t)
    if (self.has_cuts()):
      return cut(np.elems, cp, inclusive=self.inclusive,
        cut_expr=self.cut_expr.change_basis(cb_op))
    return cut(np.elems, cp, inclusive=self.inclusive)

  def lcm_of_denominators(self, start_lcm=1):
    result = start_lcm
    for e in self.n:
      result = rational.lcm(result, rational.int(e).denominator())
    result = rational.lcm(result, rational.int(self.c).denominator())
    return result

  def get_point_in_plane(self):
    result = [0,0,0]
    for i in range(3):
      if (self.n[i] != 0):
        result[i] = -rational.int(self.c) / self.n[i]
        return result
    raise RuntimeError("cut_plane normal vector is the null vector.")

  def as_float_cut_plane(self):
    from cctbx.crystal.direct_space_asu import float_cut_plane
    result = float_cut_plane(n=[float(e) for e in self.n], c=float(self.c))
    return result


 *******************************************************************************


 *******************************************************************************
cctbx/sgtbx/direct_space_asu/facet_analysis.py
from __future__ import absolute_import, division, print_function
from operator import itemgetter
from cctbx.sgtbx.direct_space_asu import cut_plane
from cctbx.array_family import flex
from scitbx import matrix
import scitbx.math
from boost_adaptbx.boost import rational
from six.moves import range
from six.moves import zip

def intersection(cuts):
  assert len(cuts) == 3
  m = flex.int()
  t = flex.int()
  denominator = 1
  for cut in cuts:
    denominator = cut.lcm_of_denominators(start_lcm=denominator)
  for cut in cuts:
    for e in cut.n: m.append(int(e * denominator))
    t.append(-int(cut.c * denominator))
  m.reshape(flex.grid(3,3))
  t.reshape(flex.grid(3,1))
  r = scitbx.math.row_echelon_form_t(m, t)
  assert r in (2,3)
  if (r != 3): return None
  t.reshape(flex.grid(3))
  sol = flex.int(3)
  d = scitbx.math.row_echelon_back_substitution_int(m, t, sol)
  assert d > 0
  return tuple([rational.int(s,d) for s in sol])

def eliminate_outside_vertices(other_cuts, vertices):
  result = {}
  for vertex in vertices.keys():
    for cut in other_cuts:
      if (cut.evaluate(vertex) < 0):
        break
    else:
      result[vertex] = vertices[vertex]
  return result

def polygon_vertices(pivot, other_cuts):
  result = {}
  n = len(other_cuts)
  for i in range(n-1):
    for j in range(i+1,n):
      vertex = intersection(cuts=(pivot, other_cuts[i], other_cuts[j]))
      if (vertex is not None):
        result.setdefault(vertex, []).append((i,j))
  return eliminate_outside_vertices(other_cuts=other_cuts, vertices=result)

def depth1_cuts(expr, op_and="&", op_or="|"):
  if (isinstance(expr, cut_plane.cut)):
    return [[expr]]
  assert isinstance(expr, cut_plane.cut_expression)
  lhs = depth1_cuts(expr.lhs, op_and, op_or)
  rhs = depth1_cuts(expr.rhs, op_and, op_or)
  if (expr.op == op_or):
    return lhs + rhs
  assert expr.op == op_and
  result = []
  for l in lhs:
    for r in rhs:
      result.append(l + r)
  return result

def face_vertices(asu, i_pivot):
  pivot = asu.cuts[i_pivot]
  other_cuts = asu.cuts[:i_pivot] + asu.cuts[i_pivot+1:]
  if (not pivot.has_cuts()):
    return [(polygon_vertices(pivot, other_cuts), pivot.inclusive)]
  cuts_inside = depth1_cuts(pivot.cut_expr)
  cuts_outside = depth1_cuts(pivot.cut_expr, "|", "&")
  result = []
  for cut in cuts_inside:
    result.append((polygon_vertices(pivot, other_cuts + cut), True))
  for cut in cuts_outside:
    cut = [-f for f in cut]
    result.append((polygon_vertices(pivot, other_cuts + cut), False))
  return result

def sense_of_polygon(cut_n, polygon):
  assert len(polygon) >= 3
  row = matrix.row
  p00 = row(polygon[0][0])
  rows = [row(cut_n), row(polygon[-1][0])-p00, row(polygon[1][0])-p00]
  d = matrix.col(rows).resolve_partitions().determinant()
  assert d != 0
  return d

def trace_polygon(
      polygon,
      begin_cut_index,
      end_cut_index,
      unused_face_vertices):
  i_vertex = -1
  for vertex,list_of_other_cut_indices in unused_face_vertices:
    i_vertex += 1
    for cut_indices in list_of_other_cut_indices:
      if (cut_indices[0] != end_cut_index):
        cut_indices = list(cut_indices)
        cut_indices.reverse()
        cut_indices = tuple(cut_indices)
      if (cut_indices[0] == end_cut_index):
        full_polygon = trace_polygon(
          polygon=polygon+[(vertex, cut_indices)],
          begin_cut_index=begin_cut_index,
          end_cut_index=cut_indices[1],
          unused_face_vertices=
              unused_face_vertices[:i_vertex]
            + unused_face_vertices[i_vertex+1:])
        if (full_polygon is not None):
          return full_polygon
  if (len(unused_face_vertices) > 0): return None
  if (end_cut_index != begin_cut_index): return None
  return polygon

def face_polygons(asu, i_pivot):
  vertex_dicts = face_vertices(asu=asu, i_pivot=i_pivot)
  result = []
  for vertex_dict,flag in vertex_dicts:
    # FIXME ordering of lists in items changes in python2/3
    vertex_list = list(vertex_dict.items())
    vertex,list_of_other_cut_indices = vertex_list[0]
    for other_cut_indices in list_of_other_cut_indices:
      polygon = trace_polygon([(vertex, other_cut_indices)],
                              other_cut_indices[0],
                              other_cut_indices[1],
                              vertex_list[1:])
      if (polygon is not None): break
    if (polygon is not None):
      if (sense_of_polygon(asu.cuts[i_pivot].n, polygon) < 0):
        polygon.reverse()
      result.append((polygon, flag))
  return result

def asu_polygons(asu):
  result = []
  for i_pivot in range(len(asu.cuts)):
    result.append(face_polygons(asu=asu, i_pivot=i_pivot))
  verify_asu_polygons(asu=asu, list_of_polygons=result)
  return result

def extract_polygon_vertices(list_of_polygons):
  result = {}
  for polygons in list_of_polygons:
    for polygon,inclusive_flag in polygons:
      for vertex,cut_indices in polygon:
        result[vertex] = 1
  return list(result.keys())

def shape_vertices(asu):
  return extract_polygon_vertices(asu_polygons(asu.shape_only()))

def line_sample_point(a, b, f, gridding):
  return [a[i]+rational.int(f,gridding)*(b[i]-a[i]) for i in range(3)]

def verify_asu_polygons(asu, list_of_polygons, gridding=13):
  for polygons in list_of_polygons:
    for polygon,inclusive_flag in polygons:
      n = len(polygon)
      for i in range(n-1):
        for j in range(i+2,min(n,n+i-1)):
          a, b = polygon[i][0], polygon[j][0]
          for f in range(1, gridding):
            x = line_sample_point(a, b, f, gridding)
            assert asu.is_inside(x) == inclusive_flag

def collect_cuts(expr):
  if (expr is None): return []
  if (isinstance(expr, cut_plane.cut)):
    return [expr]
  assert isinstance(expr, cut_plane.cut_expression)
  lhs = collect_cuts(expr.lhs)
  rhs = collect_cuts(expr.rhs)
  for cut in rhs:
    if (not cut in lhs):
      lhs.append(cut)
  return lhs

def is_one_of(cut_list, addl_cut):
  for cut in cut_list:
    if (cut.n == addl_cut.n and cut.c == addl_cut.c):
      return True
  return False

def all_cut_points(asu):
  result = {}
  for pivot in asu.cuts:
    for first_cut in collect_cuts(pivot.cut_expr):
      for second_cut in collect_cuts(first_cut.cut_expr):
        all_cuts = (pivot, first_cut, second_cut)
        if (second_cut.has_cuts()):
          assert isinstance(second_cut.cut_expr, cut_plane.cut)
          assert second_cut.cut_expr.inclusive == False
          assert is_one_of(all_cuts, second_cut)
        point = intersection(cuts=all_cuts)
        assert point is not None
        if (asu.is_inside(point, shape_only=True)):
          result[point] = 1
  return list(result.keys())

def get_edge_vertices(list_of_polygons):
  result = {}
  for polygons in list_of_polygons:
    for polygon,inclusive_flag in polygons:
      n = len(polygon)
      for i in range(n):
        j = (i+1) % n
        v1 = polygon[i][0]
        v2 = polygon[j][0]
        key = (v1,v2)
        if (key not in result):
          key = (v2,v1)
        result[key] = 1
  return list(result.keys())

def edge_position(edge_end_points, other_point):
  a = edge_end_points[0]
  b = edge_end_points[1]
  x = other_point
  f = None
  for i in range(3):
    d_i = b[i] - a[i]
    if (f is None):
      if (d_i != 0):
        f = (x[i] - a[i]) / d_i
      else:
        if (x[i] != a[i]): return None
    else:
      y_i = a[i] + f * d_i
      if (y_i != x[i]): return None
  return f

class edge_with_cut_points(object):

  __slots__ = ["end_points", "cut_points"]

  def __init__(self, end_points, cut_points):
    self.end_points = tuple(end_points)
    self.cut_points = tuple(cut_points)

  def show_points(self):
    print("end points:", self.end_points)
    print("cut points:", self.cut_points)

  def cut_point_positions(self):
    return [edge_position(self.end_points, point) for point in self.cut_points]

  def sorted_cut_points(self):
    packed = list(zip(self.cut_points, self.cut_point_positions()))
    packed.sort(key=itemgetter(1))
    return [p[0] for p in packed]

  def sort_cut_points(self):
    return edge_with_cut_points(self.end_points, self.sorted_cut_points())

  def all_points(self):
    return (self.end_points[0],) + self.cut_points + (self.end_points[1],)

  def join_point(self, point):
    f = edge_position(self.end_points, point)
    if (f is None or f == 0 or f == 1 or point in self.cut_points):
      return f, self
    if (f < 0):
      return f, edge_with_cut_points(
        (point, self.end_points[1]),
        (self.end_points[0],) + self.cut_points)
    elif (f > 1):
      return f, edge_with_cut_points(
        (self.end_points[0], point),
        self.cut_points + (self.end_points[1],))
    return f, edge_with_cut_points(
      self.end_points,
      self.cut_points + (point,))

  def join_edge(self, edge):
    result = self
    linear_dependent = True
    for point in edge:
      f, result = result.join_point(point)
      if (f is None): linear_dependent = False
    return linear_dependent, result

class edge_segment(object):

  __slots__ = ["vertex", "vertex_inclusive_flag", "edge_inclusive_flag"]

  def __init__(self, vertex, vertex_inclusive_flag, edge_inclusive_flag):
    self.vertex = vertex
    self.vertex_inclusive_flag = vertex_inclusive_flag
    self.edge_inclusive_flag = edge_inclusive_flag

class consolidated_edges_with_cut_points(object):

  __slots__ = ["asu", "list"]

  def __init__(self, asu, list_of_polygons):
    self.asu = asu
    self.list = []
    addl_cut_points = all_cut_points(asu)
    for edge in get_edge_vertices(list_of_polygons):
      self.add(edge, addl_cut_points)
    self.list = [ec.sort_cut_points() for ec in self.list]

  def add(self, edge, addl_cut_points):
    for i in range(len(self.list)):
      linear_dependent, self.list[i] = self.list[i].join_edge(edge)
      if (linear_dependent): return
    edge_and_cuts = edge_with_cut_points(edge, ())
    for listed_edge_and_cuts in self.list:
      for point in listed_edge_and_cuts.all_points():
        f, edge_and_cuts = edge_and_cuts.join_point(point)
    for point in addl_cut_points:
      f, edge_and_cuts = edge_and_cuts.join_point(point)
    self.list.append(edge_and_cuts)

  def get_segments(self, edge_and_cuts):
    points = edge_and_cuts.all_points()
    result = []
    for i in range(len(points)-1):
      vertices = (points[i], points[i+1])
      mid_point = (
        (matrix.col(vertices[0]) + matrix.col(vertices[1])) / 2).elems
      result.append(edge_segment(
        vertex=vertices[0],
        vertex_inclusive_flag=self.asu.is_inside(vertices[0]),
        edge_inclusive_flag=self.asu.is_inside(mid_point)))
    result.append(edge_segment(
      vertex=points[-1],
      vertex_inclusive_flag=self.asu.is_inside(points[-1]),
      edge_inclusive_flag=None))
    return result

  def get_all_segments(self):
    result = []
    for edge_and_cuts in self.list:
      result.append(self.get_segments(edge_and_cuts))
    self.verify_edge_segments(result)
    return result

  def verify_edge_segments(self, all_edge_segments, gridding=13):
    for edge_segments in all_edge_segments:
      for i_segment in range(len(edge_segments)-1):
        a = edge_segments[i_segment].vertex
        b = edge_segments[i_segment+1].vertex
        is_inside = None
        for f in range(1, gridding):
          x = line_sample_point(a, b, f, gridding)
          if (is_inside is None):
            is_inside = self.asu.is_inside(x)
          else:
            assert is_inside == self.asu.is_inside(x)

def get_all_edge_segments(asu, list_of_polygons):
  return consolidated_edges_with_cut_points(
    asu, list_of_polygons).get_all_segments()

def get_all_vertices(all_edge_segments):
  result = {}
  for edge_segments in all_edge_segments:
    for segment in edge_segments:
      if (segment.vertex in result):
        assert result[segment.vertex] == segment.vertex_inclusive_flag
      else:
        result[segment.vertex] = segment.vertex_inclusive_flag
  return result


 *******************************************************************************


 *******************************************************************************
cctbx/sgtbx/direct_space_asu/plane_group_reference_table.py
from __future__ import absolute_import, division, print_function
from cctbx.sgtbx.direct_space_asu import direct_space_asu
from cctbx.sgtbx.direct_space_asu.short_cuts import *
from six.moves import range

def asu_01(): # p_1 (s.g. 1)
  return (direct_space_asu('P 1')
    & x0
    & +x1
    & y0
    & +y1
    & z0
    & +z1
)

def asu_02(): # p_2 (s.g. 3)
  return (direct_space_asu('P 2')
    & x0(y2)
    & x2(y2)
    & y0
    & +y1
    & z0
    & +z1
)

def asu_03(): # p_m (s.g. 6)
  return (direct_space_asu('P -2x')
    & x0
    & x2
    & y0
    & +y1
    & z0
    & +z1
)

def asu_04(): # p_g (s.g. 7)
  return (direct_space_asu('P -2xb')
    & x0(+y2)
    & x2(+y2)
    & y0
    & +y1
    & z0
    & +z1
)

def asu_05(): # c_m (s.g. 8)
  return (direct_space_asu('C -2x')
    & x0
    & x2
    & y0
    & +y2
    & z0
    & +z1
)

def asu_06(): # p_2_m_m (s.g. 25)
  return (direct_space_asu('P 2 -2')
    & x0
    & x2
    & y0
    & y2
    & z0
    & +z1
)

def asu_07(): # p_2_m_g (s.g. 28)
  return (direct_space_asu('P 2 -2a')
    & x0(y2)
    & x4
    & y0
    & +y1
    & z0
    & +z1
)

def asu_08(): # p_2_g_g (s.g. 32)
  return (direct_space_asu('P 2 -2ab')
    & x0
    & x2(-y0)
    & y0
    & +y2
    & z0
    & +z1
)

def asu_09(): # c_2_m_m (s.g. 35)
  return (direct_space_asu('C 2 -2')
    & x0
    & x4(y4)
    & y0
    & y2
    & z0
    & +z1
)

def asu_10(): # p_4 (s.g. 75)
  return (direct_space_asu('P 4')
    & x0(-y0)
    & x2
    & y0
    & y2(-x2)
    & z0
    & +z1
)

def asu_11(): # p_4_m_m (s.g. 99)
  return (direct_space_asu('P 4 -2')
    & x0
    & y2
    & -p0
    & z0
    & +z1
)

def asu_12(): # p_4_g_m (s.g. 100)
  return (direct_space_asu('P 4 -2ab')
    & x0(-y0)
    & y0
    & m2
    & z0
    & +z1
)

def asu_13(): # p_3 (s.g. 143)
  return (direct_space_asu('P 3')
    & x0(-y0)
    & y0
    & k1
    & m1(-h1 | -k1)
    & h1
    & z0
    & +z1
)

def asu_14(): # p_3_m_1 (s.g. 156)
  return (direct_space_asu('P 3 -2"')
    & h0
    & m1
    & k0
    & z0
    & +z1
)

def asu_15(): # p_3_1_m (s.g. 157)
  return (direct_space_asu('P 3 -2')
    & y0
    & k1
    & m1(y3)
    & p0
    & z0
    & +z1
)

def asu_16(): # p_6 (s.g. 168)
  return (direct_space_asu('P 6')
    & y0
    & k1
    & m1(y3)
    & p0(-y0)
    & z0
    & +z1
)

def asu_17(): # p_6_m_m (s.g. 183)
  return (direct_space_asu('P 6 -2')
    & y0
    & k1
    & -h0
    & z0
    & +z1
)

def get_asu(point_group_number):
  return eval("asu_%02d" % point_group_number)()

if (__name__ == "__main__"):
  for i in range(1,17+1):
    get_asu(i).show_summary()


 *******************************************************************************


 *******************************************************************************
cctbx/sgtbx/direct_space_asu/proto/__init__.py
from __future__ import absolute_import, division, print_function
import sys
import boost_adaptbx.boost.python as bp
ext = bp.import_ext("cctbx_sgtbx_asu_ext")
from cctbx_sgtbx_asu_ext import *

def asu_show_(asu, f=None):
  if f is None:
    f = sys.stdout
  print(asu.as_string(), file=f)


direct_space_asu.show_comprehensive_summary = asu_show_


 *******************************************************************************


 *******************************************************************************
cctbx/sgtbx/direct_space_asu/proto/generate_cpp_asu_table.py
from __future__ import absolute_import, division, print_function
from scitbx.source_generators.utils import join_open
import cctbx
from cctbx.sgtbx.direct_space_asu import reference_table
from cctbx.sgtbx.direct_space_asu.cut_plane import cut
from six.moves import range


head1 = """\
///
/// Generated code. DO NOT EDIT
///
/// Generator: cctbx/sgtbx/direct_space_asu/proto/generate_cpp_asu_table.py
///
/// Dependencies: cctbx/sgtbx/direct_space_asu/reference_table.py
///
"""

head2 = """\
#include "reference_table.h"

namespace cctbx { namespace sgtbx { namespace asu {

namespace {

typedef sg_vec3 vvv;
"""

# replacement for cut.base_symbol
def base_symbol_cpp(thecut):
  from cctbx.sgtbx.direct_space_asu import short_cuts
  n = tuple(thecut.n)
  minus_n = tuple([-e for e in n])
  matching_n = None
  for key,value in short_cuts.__dict__.items():
    if (isinstance(value, cut)):
      if (value.n == n):
        if (value.c == thecut.c):
          return key
        elif (value.c == -thecut.c):
          return "-~"+key
        elif (value.c == 1):
          assert matching_n is None
          if (thecut.c < 0):
            matching_n = "-~"+key
          else:
            matching_n = key
      elif (value.n == minus_n):
        if (value.c == -thecut.c):
          return "-"+key
        elif (value.c == thecut.c):
          return "~"+key
        elif (value.c == 1):
          assert matching_n is None
          if (thecut.c < 0):
            matching_n = "-"+key
          else:
            matching_n = "~"+key
  c = short_cuts.r1 * thecut.c
  num = c.numerator()
  abs_num = abs(num)
  den = c.denominator()
  if (matching_n is None):
    if (num == 0):
      s = "0"
    else:
      s = "r1"
      if (num < 0): s = "-"+s
      if (abs_num != 1): s += "*"+str(abs_num)
      if (den != 1): s += "/"+str(den)
    return "cut(vvv" + str(thecut.n).replace(" ", "") + "," + s + ")"
  s = matching_n
  assert num != 0
  if (abs_num != 1): s += "*"+str(abs_num)
  if (den != 1): s += "/"+str(den)
  return s


cctbx.sgtbx.direct_space_asu.cut_plane.cut.base_symbol = base_symbol_cpp
# direct_space_asu.cut_plane.cut.base_symbol = base_symbol_cpp
# cut_plane.cut.base_symbol = base_symbol_cpp

def out_cpp(asu, f):
  i=0
  for cut in asu.cuts:
    if( i!=0 ):
      print("    &", cut, file=f)
    else:
      print("     ", cut, file=f)
    i = i + 1


def show_cpp(sg, f):
  asu = reference_table.get_asu(sg)
  func = "asu_%03d"%sg
  print("facet_collection::pointer ", func, "()   //  Hall: ", asu.hall_symbol, file=f)
  print("{\n  return facet_collection_asu(", file=f)
  out_cpp(asu, f)
  print("  );\n}\n", file=f)
  return func


def make_md5(path):
  import md5
  import libtbx
  import libtbx.load_env
  real_path = libtbx.env.under_dist( "cctbx", path )
  m = md5.new()
  m.update("\n".join(open(real_path).read().splitlines()))
  return "// " + path + ' ' + m.hexdigest()

def run(dr):
  f = join_open(dr, "reference_table.cpp", "w")
  s1md5 = make_md5("sgtbx/direct_space_asu/reference_table.py")
  s2md5 = make_md5("sgtbx/direct_space_asu/proto/generate_cpp_asu_table.py")
  s3md5 = make_md5("sgtbx/direct_space_asu/short_cuts.py")
  print(s1md5, '\n', s2md5, '\n', s3md5)
  print(head1, file=f)
  # comma in print adds one whitespace between parameters
  # so it is better to use + to concatanete strings
  # to avoid trailing white spaces
  print("////////////////\n" + s1md5 + "\n" + s2md5 + "\n" + s3md5 + "\n////////////////\n", file=f)
  print(head2, file=f)
  table = "asu_func asu_table[230] = {"
  i = 0
  for sg in range(1,231):
    if( i%8 == 0 ):
      table += "\n "
    func = show_cpp(sg, f)
    table += " "
    table += func
    if i<229 :
      table += ","
    i += 1
  print("} // end of unnamed namespace\n\n" + table + "\n};\n\n}}}\n", file=f)


if (__name__ == "__main__"):
  run(".")



 *******************************************************************************


 *******************************************************************************
cctbx/sgtbx/direct_space_asu/proto/tst_asu.py
from __future__ import absolute_import, division, print_function
import sys
from six.moves import cStringIO as StringIO
import cctbx
from boost_adaptbx.boost.rational import int as rint
from cctbx.sgtbx import space_group_info
from cctbx.sgtbx.direct_space_asu import proto as new_asu
from cctbx.crystal import direct_space_asu_float_asu
from libtbx.test_utils import approx_equal
from libtbx.utils import format_cpu_times
from six.moves import range
from six.moves import zip

# For usage type:
#   cctbx.python tst_asu.py -h

# test groups, tests are very slow, so keep very few groups here
SpaceGroups = ('P 1 1 21',  'P 21 21 21', 'I 1 m 1')
NSteps = 11 # number of grid points in one dimenssion

cout = StringIO()

def step_v(n, mn, mx):
  step = ()
  box = ()
  for a,b in zip(mn,mx):
    box += tuple( [b-a] )
    step += tuple( [(b-a)/rint(n)] )
  v = rint( n*n*n ) / (box[0]*box[1]*box[2])
  return step, v

def loop_grid(asu, n, mn, mx, asu2=None):
  assert (asu2 is None) or isinstance(asu, new_asu.direct_space_asu)
  first_is_new = False
  step, vv = step_v(n, mn, mx)
  grid = ()
  for s in step:
    g = rint(1) / s
    g = g.numerator()//g.denominator() + 1
    assert g > 0, "Step = "+str(step)
    grid += tuple([g])
  mna = list(mn)
  mxa = list(mx)
  for i in range(3):
    mna[i] -= 5*step[i]
    mna[i] *= grid[i]
    mna[i] = mna[i].numerator()//mna[i].denominator()-1
    mxa[i] += 5*step[i]
    mxa[i] *= grid[i]
    mxa[i] = mxa[i].numerator()//mxa[i].denominator()+1
  print("grid test  step= ", step, "  min= ", mna, "  max= ", mxa, \
      "   grid=", grid, file=cout)
  if isinstance(asu, new_asu.direct_space_asu):
    import copy
    # TODO: implement
    # asu_opt = copy.copy(asu)
    # asu_opt.optimize_for_grid(grid)
    # assert asu_opt.is_optimized() and (not asu.is_optimized())
    first_is_new = True
    # max_p = asu_opt.get_optimized_grid_limits()
    # print >>cout, "grid limits: ", max_p
  result = 0

  i = mna[0]
  while i <= mxa[0] :
    ii = rint(i,grid[0])
    j = mna[1]
    while j <= mxa[1] :
      jj = rint(j,grid[1])
      k = mna[2]
      while k <= mxa[2] :
        kk = rint(k,grid[2])
        b = asu.is_inside((ii,jj,kk)) # rational test
        if b :
          result += 1
        if first_is_new:
          num = (i, j, k)
          den = grid
          where = asu.where_is(num,den) # integer test
          #TODO: implement? assert b == asu.is_inside(num,den)
          assert ( b and (where==1 or where==-1)) or ( (not b) and where==0 )
          #TODO: implemnt where_opt = asu_opt.where_is( num ) # optimized test
          #  assert where_opt == where
          #TODO: implement? assert b == asu_opt.is_inside(num)
        if asu2 is not None :
          assert b == asu2.is_inside( (ii,jj,kk) ) # rational test
        k += 1
      j += 1
    i += 1

  shape = result / vv
  return (result,shape)

def compare(spgr, n=NSteps, verbose=False):
  if verbose:
    print(cout.getvalue())
  cout.truncate(0)
  grp = space_group_info(spgr)
  print("Comparing asus for group: ", spgr, "  n-steps= ", n, file=cout)
  asuo = grp.direct_space_asu()
  print("=== Original python asu ===", file=cout)
  asuo.show_comprehensive_summary(cout)
  print(":: raw facets", file=cout)
  as_raw_asu(asuo, cout)
  mxo = tuple( asuo.box_max() )
  mno = tuple( asuo.box_min() )
  print("box  min= ", mno, "   max= ", mxo, file=cout)
  ### NEW C++ ASU
  asun = new_asu.direct_space_asu(grp.type())
  print("=== New C++ asu ===", file=cout)
  asun.show_comprehensive_summary(cout)
  mnn = asun.box_min()
  mxn = asun.box_max()
  print("box  min= ", mnn, "   max= ", mxn, file=cout)
  assert mnn == mno
  assert mxn == mxo
  old_vertices = asuo.shape_vertices()
  new_vertices = asun.shape_vertices() # C++  sorted list
  assert len(old_vertices) == len(new_vertices)
  # TODO: the following seems to use the same ordering operation
  # as mine in C++
  old_vertices = sorted(old_vertices)
  for a,b in zip(old_vertices,new_vertices):
    print(a, " == ", b, file=cout)
    assert a == b, str(a)+" != "+str(b)
  ins,v = loop_grid(asun, n, mnn, mxn, asuo)
  print("N inside = ", ins, "   volume = ", v,  \
      "   expected volume = ", rint(1,grp.group().order_z()), file=cout)
  ### SHAPE ONLY
  asun.shape_only()
  asuo = asuo.shape_only()
  mxo2 = tuple( asuo.box_max() )
  mno2 = tuple( asuo.box_min() )
  mnn2 = asun.box_min()
  mxn2 = asun.box_max()
  assert mxo2 == mxo
  assert mno2 == mno
  assert mxn2 == mxn
  assert mnn2 == mnn
  loop_grid(asun, n, mnn, mxn, asuo)
  unit_cell = grp.any_compatible_unit_cell(volume=5000.0)
  fasun = asun.as_float_asu( unit_cell, 1.0E-6);
  fasuo = cctbx.crystal.direct_space_asu_float_asu(
    unit_cell=unit_cell,
    cuts=[cut.as_float_cut_plane() for cut in asuo.cuts],
    is_inside_epsilon=1.e-6)
  # python sucks big: still (in 2.5) there is no float.epsilon/max/tiny/etc
  assert approx_equal(fasun.is_inside_epsilon(), fasuo.is_inside_epsilon(),
      1.0E-100)
  assert len(fasun.cuts()) == len(fasuo.cuts()), \
    "%d != %d"%(len(fasuo.cuts()),len(fasun.cuts()))
  assert ((len(fasun.cuts()) < 200) & (len(fasun.cuts()) > 3)), \
    len(fasun.cuts())
  if verbose:
    print(cout.getvalue())
  cout.truncate(0)

def compare_groups(groups=SpaceGroups, n=NSteps, verbose=False):
  for sg in groups:
    compare(sg, n, verbose)


def as_raw(c ):
  result = ""
  if isinstance(c, cctbx.sgtbx.direct_space_asu.cut_plane.cut):
    if not c.inclusive:
      result = "+"
    result = result + "cut(" + str(c.n)+ ", " + str(c.c) +")"
    if c.has_cuts():
      result = result + " [ " + as_raw(c.cut_expr) + " ]"
  elif isinstance(c, cctbx.sgtbx.direct_space_asu.cut_plane.cut_expression):
    result = "(" + as_raw(c.lhs) + str(c.op) + as_raw(c.rhs) + ")"
  else:
    assert False, c.__class_
  return result

def as_raw_asu(asu, f=None):
  if (f == None): f = sys.stdout
  for cut in asu.cuts:
    print("  & ", as_raw(cut), file=f)


def run():
  import libtbx.option_parser as optparse
  parser = optparse.OptionParser()
  parser.add_option("-v", "--verbose", action="store_true", dest="verbose",
      default=False, help="be verbose")
  parser.add_option("-g", "--space_group", action="store", type="string",
      dest="space_group", help="space group symbol or number or all or all530")
  parser.add_option("-n", "--n_steps", action="store", type="int",
      dest="n_steps", default=NSteps, help="number of grid points in one"
      +" dimension of the asu box")
  parser.add_option("--groups_file", action="store", type="string",
      dest="groups_file", help="file containing space groups, one per line")

  (opts, args) = parser.parse_args()

  groups = []
  if not opts.groups_file is None:
    tmp_file = open(opts.groups_file, "r")
    for line in tmp_file.readlines(): # newlines retained
      groups.append( line.strip() ) # removes whitespace in the begining and end
    tmp_file.close()
  if (opts.space_group is None) & (len(groups)==0):
    groups.extend(SpaceGroups)
  elif opts.space_group == "all" :
    for isg in range(1,231):
      groups.append(str(isg))
  elif opts.space_group == "all530":
    it = cctbx.sgtbx.space_group_symbol_iterator()
    while( True ):
      symbol = next(it)
      # TODO: the following  does not work
      #if( symbol.number()==0 ):
      #  break
      groups.append(symbol.hermann_mauguin())
      if( symbol.number()==230 ):
        break
  elif not opts.space_group is None:
    groups.append(opts.space_group)

  print("Number of groups: ", len(groups), file=cout)
  print("Options= ", opts, file=cout)
  compare_groups(groups, opts.n_steps, opts.verbose)
  print(format_cpu_times())


if (__name__ == "__main__"):
  try:
    run()
  except Exception :
    log = cout.getvalue()
    if len(log) != 0:
      print("<<<<<<<< Start Log:")
      print(log)
      print(">>>>>>>> End Log")
    raise


 *******************************************************************************


 *******************************************************************************
cctbx/sgtbx/direct_space_asu/reference_table.py
from __future__ import absolute_import, division, print_function
from cctbx.sgtbx.direct_space_asu import direct_space_asu
from cctbx.sgtbx.direct_space_asu.short_cuts import *
from six.moves import range

change_of_basis_tab = {
   78: ( 76, "a,b,-c+1"),
   95: ( 91, "-a+1,b,c"),
  145: (144, "b,a,c"),
  154: (152, "b,a,c"),
  170: (169, "b,a,c"),
  172: (171, "-b+1,-a+1,c"),
  181: (180, "b+1,-a-b,-c+1/6"),
  213: (212, "-b,c+1/2,a-1/2")
}

def apply_change_of_basis(target_sg_no):
  source_sg_no, cb_expr = change_of_basis_tab[target_sg_no]
  return get_asu(source_sg_no).change_basis(cb_expr)

def asu_001(): # P 1
  return (direct_space_asu('P 1')
    & x0
    & +x1
    & y0
    & +y1
    & z0
    & +z1
  )

def asu_002(): # P -1
  return (direct_space_asu('-P 1')
    & x0(y0(z2) & y2(z2))
    & x2(y0(z2) & y2(z2))
    & y0
    & +y1
    & z0
    & +z1
  )

def asu_003(): # P 1 2 1
  return (direct_space_asu('P 2y')
    & x0
    & +x1
    & y0
    & +y1
    & z0(x2)
    & z2(x2)
  )

def asu_004(): # P 1 21 1
  return (direct_space_asu('P 2yb')
    & x0
    & +x1
    & y0
    & +y1
    & z0(x0(+y2) & x2(+y2))
    & z2(x0(+y2) & x2(+y2))
  )

def asu_005(): # C 1 2 1
  return (direct_space_asu('C 2y')
    & x0(z2)
    & x2(z2)
    & y0
    & +y2
    & z0
    & +z1
  )

def asu_006(): # P 1 m 1
  return (direct_space_asu('P -2y')
    & x0
    & +x1
    & y0
    & y2
    & z0
    & +z1
  )

def asu_007(): # P 1 c 1
  return (direct_space_asu('P -2yc')
    & x0
    & +x1
    & y0(+z2)
    & y2(+z2)
    & z0
    & +z1
  )

def asu_008(): # C 1 m 1
  return (direct_space_asu('C -2y')
    & x0
    & +x1
    & y0
    & y4(+x2)
    & z0
    & +z1
  )

def asu_009(): # C 1 c 1
  return (direct_space_asu('C -2yc')
    & x0
    & +x1
    & y0(+z2)
    & y4(+z2)
    & z0
    & +z1
  )

def asu_010(): # P 1 2/m 1
  return (direct_space_asu('-P 2y')
    & x0(z2)
    & x2(z2)
    & y0
    & y2
    & z0
    & +z1
  )

def asu_011(): # P 1 21/m 1
  return (direct_space_asu('-P 2yb')
    & x0
    & +x1
    & y0(z0(x2) & z2(x2))
    & y4
    & z0
    & +z1
  )

def asu_012(): # C 1 2/m 1
  return (direct_space_asu('-C 2y')
    & x0(z2)
    & x2(z2)
    & y0
    & y4(x4(z2))
    & z0
    & +z1
  )

def asu_013(): # P 1 2/c 1
  return (direct_space_asu('-P 2yc')
    & x0(z0(y2) & z4)
    & x2(z0(y2) & z4)
    & y0
    & +y1
    & z0
    & +z2
  )

def asu_014(): # P 1 21/c 1
  return (direct_space_asu('-P 2ybc')
    & x0(y0(z2))
    & +x1
    & y0(x2(z2))
    & y4(+z2)
    & z0
    & +z1
  )

def asu_015(): # C 1 2/c 1
  return (direct_space_asu('-C 2yc')
    & x0(z4)
    & x2(z4)
    & y0
    & +y2
    & z0(y4(x4))
    & z2(-y4(x4))
  )

def asu_016(): # P 2 2 2
  return (direct_space_asu('P 2 2')
    & x0(z2)
    & x2(z2)
    & y0(z2)
    & y2(z2)
    & z0
    & +z1
  )

def asu_017(): # P 2 2 21
  return (direct_space_asu('P 2c 2')
    & x0(-z4 & z1*3/4)
    & x2(-z4 & z1*3/4)
    & y0(z2)
    & y2(z2)
    & z0
    & +z1
  )

def asu_018(): # P 21 21 2
  return (direct_space_asu('P 2 2ab')
    & x0
    & x2(-y0)
    & y0
    & +y2
    & z0
    & +z1
  )

def asu_019(): # P 21 21 21
  return (direct_space_asu('P 2ac 2ab')
    & x0
    & +x2
    & y0(-z2)
    & y2(z2)
    & z0(+y2)
    & +z1
  )

def asu_020(): # C 2 2 21
  return (direct_space_asu('C 2c 2')
    & x0(z4)
    & x2(-z4)
    & y0
    & y2(-z0)
    & z0
    & +z2
  )

def asu_021(): # C 2 2 2
  return (direct_space_asu('C 2 2')
    & x0(z2)
    & x4(y4)
    & y0(z2)
    & y2(z2)
    & z0
    & +z1
  )

def asu_022(): # F 2 2 2
  return (direct_space_asu('F 2 2')
    & x0(z2)
    & x4(-z4 & z1*3/4)
    & y0(z2)
    & y4(-z4 & z1*3/4)
    & z0
    & +z1
  )

def asu_023(): # I 2 2 2
  return (direct_space_asu('I 2 2')
    & x0
    & x2(-y0)
    & y0
    & y2(-z0)
    & z0
    & z2(-x0)
  )

def asu_024(): # I 21 21 21
  return (direct_space_asu('I 2b 2c')
    & x0(y4)
    & x2(y4)
    & y0(z4)
    & y2(z4)
    & z0(x4)
    & z2(x4)
  )

def asu_025(): # P m m 2
  return (direct_space_asu('P 2 -2')
    & x0
    & x2
    & y0
    & y2
    & z0
    & +z1
  )

def asu_026(): # P m c 21
  return (direct_space_asu('P 2c -2')
    & x0
    & x2
    & y0(+z2)
    & y2(+z2)
    & z0
    & +z1
  )

def asu_027(): # P c c 2
  return (direct_space_asu('P 2 -2c')
    & x0(+z2)
    & x2(+z2)
    & y0(+z2)
    & y2(+z2)
    & z0
    & +z1
  )

def asu_028(): # P m a 2
  return (direct_space_asu('P 2 -2a')
    & x0(y2)
    & x4
    & y0
    & +y1
    & z0
    & +z1
  )

def asu_029(): # P c a 21
  return (direct_space_asu('P 2c -2ac')
    & x0(+z2)
    & x4(+z2)
    & y0
    & +y1
    & z0
    & +z1
  )

def asu_030(): # P n c 2
  return (direct_space_asu('P 2 -2bc')
    & x0(y2)
    & x2(y2)
    & y0
    & +y1
    & z0
    & +z2
  )

def asu_031(): # P m n 21
  return (direct_space_asu('P 2ac -2')
    & x0
    & x2
    & y0(+z2)
    & y2(+z2)
    & z0
    & +z1
  )

def asu_032(): # P b a 2
  return (direct_space_asu('P 2 -2ab')
    & x0
    & x2(-y0)
    & y0
    & +y2
    & z0
    & +z1
  )

def asu_033(): # P n a 21
  return (direct_space_asu('P 2c -2n')
    & x0
    & +x2
    & y0(+z2)
    & y2(+z2)
    & z0
    & +z1
  )

def asu_034(): # P n n 2
  return (direct_space_asu('P 2 -2n')
    & x0
    & x2(-y0)
    & y0
    & +y2
    & z0
    & +z1
  )

def asu_035(): # C m m 2
  return (direct_space_asu('C 2 -2')
    & x0
    & x4(y4)
    & y0
    & y2
    & z0
    & +z1
  )

def asu_036(): # C m c 21
  return (direct_space_asu('C 2c -2')
    & x0
    & x2
    & y0
    & +y2
    & z0
    & +z2
  )

def asu_037(): # C c c 2
  return (direct_space_asu('C 2 -2c')
    & x0(+z2)
    & x4(y4)
    & y0(+z2)
    & y2(+z2)
    & z0
    & +z1
  )

def asu_038(): # A m m 2
  return (direct_space_asu('A 2 -2')
    & x0
    & x2
    & y0
    & y2
    & z0
    & +z2
  )

def asu_039(): # A b m 2
  return (direct_space_asu('A 2 -2b')
    & x0(+z2)
    & x2(+z2)
    & y0(+z2)
    & y4
    & z0
    & +z1
  )

def asu_040(): # A m a 2
  return (direct_space_asu('A 2 -2a')
    & x0(+z2)
    & x4
    & y0(+z2)
    & y2(+z2)
    & z0
    & +z1
  )

def asu_041(): # A b a 2
  return (direct_space_asu('A 2 -2ab')
    & x0
    & x2(-y0)
    & y0
    & +y2
    & z0
    & +z2
  )

def asu_042(): # F m m 2
  return (direct_space_asu('F 2 -2')
    & x0
    & x4(+z2)
    & y0
    & y4(+z2)
    & z0
    & +z1
  )

def asu_043(): # F d d 2
  return (direct_space_asu('F 2 -2d')
    & x0
    & x4(-y0(+z2))
    & y0
    & +y4
    & z0
    & +z1
  )

def asu_044(): # I m m 2
  return (direct_space_asu('I 2 -2')
    & x0
    & x2
    & y0
    & y2
    & z0
    & +z2
  )

def asu_045(): # I b a 2
  return (direct_space_asu('I 2 -2c')
    & x0
    & x2(-y0)
    & y0
    & +y2
    & z0
    & +z2
  )

def asu_046(): # I m a 2
  return (direct_space_asu('I 2 -2a')
    & x0(y2)
    & x4
    & y0
    & +y1
    & z0
    & +z2
  )

def asu_047(): # P m m m
  return (direct_space_asu('-P 2 2')
    & x0
    & x2
    & y0
    & y2
    & z0
    & z2
  )

def asu_048(): # P n n n :2
  return (direct_space_asu('-P 2ab 2bc')
    & x0(-y0(z2))
    & x4(-z4 & z1*3/4)
    & ~y4(-z4 & z1*3/4)
    & y4(-z4 & z1*3/4)
    & z0
    & +z1
  )

def asu_049(): # P c c m
  return (direct_space_asu('-P 2 2c')
    & x0(z4)
    & x2(z4)
    & y0(z4)
    & y2(z4)
    & z0
    & z2
  )

def asu_050(): # P b a n :2
  return (direct_space_asu('-P 2ab 2b')
    & x0(-y2)
    & x4(-y4 & y1*3/4)
    & y0
    & +y1
    & z0(-y4 & y1*3/4)
    & z2(-y4 & y1*3/4)
  )

def asu_051(): # P m m a
  return (direct_space_asu('-P 2a 2a')
    & x0(z2)
    & x4
    & y0
    & y2
    & z0
    & +z1
  )

def asu_052(): # P n n a
  return (direct_space_asu('-P 2a 2bc')
    & x0
    & +x1
    & y0(-x4 & x34)
    & y4(z4)
    & z0(-x2)
    & z2(-x2)
  )

def asu_053(): # P m n a
  return (direct_space_asu('-P 2ac 2')
    & x0
    & x2
    & y0
    & +y1
    & z0(y2)
    & z4(x4)
  )

def asu_054(): # P c c a
  return (direct_space_asu('-P 2a 2ac')
    & x0(-z4)
    & x2(z4)
    & y0(-x4)
    & y2(-x4)
    & z0
    & +z2
  )

def asu_055(): # P b a m
  return (direct_space_asu('-P 2 2ab')
    & x0
    & x2(-y0)
    & y0
    & +y2
    & z0
    & z2
  )

def asu_056(): # P c c n
  return (direct_space_asu('-P 2ab 2ac')
    & x0(y2(-z0))
    & x4(-y4 & y1*3/4)
    & y0
    & +y1
    & z0
    & +z2
  )

def asu_057(): # P b c m
  return (direct_space_asu('-P 2c 2b')
    & x0(-y2)
    & x2(-y2)
    & y0
    & +y1
    & z0(-y4 & y1*3/4)
    & z4
  )

def asu_058(): # P n n m
  return (direct_space_asu('-P 2 2n')
    & x0
    & x2(-y0)
    & y0
    & +y2
    & z0
    & z2
  )

def asu_059(): # P m m n :2
  return (direct_space_asu('-P 2ab 2a')
    & x0(-y0(z2))
    & x4
    & ~y4
    & y4
    & z0
    & +z1
  )

def asu_060(): # P b c n
  return (direct_space_asu('-P 2n 2ab')
    & x0(z4)
    & x2(-z4)
    & y0
    & y2(-x0(-z0))
    & z0
    & +z2
  )

def asu_061(): # P b c a
  return (direct_space_asu('-P 2ac 2ab')
    & x0
    & x2(-y0(-z0))
    & y0
    & +y2
    & z0
    & +z2
  )

def asu_062(): # P n m a
  return (direct_space_asu('-P 2ac 2n')
    & x0
    & x2(-y0(-z0))
    & y0(+z2)
    & y4
    & z0
    & +z1
  )

def asu_063(): # C m c m
  return (direct_space_asu('-C 2c 2')
    & x0
    & x2
    & y0
    & +y2
    & z0(y4(x4))
    & z4
  )

def asu_064(): # C m c a
  return (direct_space_asu('-C 2ac 2')
    & x0
    & x4(z4)
    & y0
    & +y2
    & z0(y4)
    & z2(+y4)
  )

def asu_065(): # C m m m
  return (direct_space_asu('-C 2 2')
    & x0
    & x4(y4)
    & y0
    & y2
    & z0
    & z2
  )

def asu_066(): # C c c m
  return (direct_space_asu('-C 2 2c')
    & x0(z4)
    & x4(y4)
    & y0(z4)
    & y2(z4)
    & z0
    & z2
  )

def asu_067(): # C m m a
  return (direct_space_asu('-C 2a 2')
    & x0
    & x2
    & y0(x4)
    & y4
    & z0(x4)
    & z2(x4)
  )

def asu_068(): # C c c a :2
  return (direct_space_asu('-C 2a 2ac')
    & x0(z4)
    & x2(z4)
    & y0(x4)
    & y4(z4)
    & z0(+x2 & y4(x4))
    & +z2
  )

def asu_069(): # F m m m
  return (direct_space_asu('-F 2 2')
    & x0
    & x4(z4)
    & y0
    & y4(z4)
    & z0
    & z2
  )

def asu_070(): # F d d d :2
  return (direct_space_asu('-F 2uv 2vw')
    & x0(-y0(z2))
    & x8(-z8 & z1*5/8)
    & ~y8(-z1*3/8 & z1*7/8)
    & y8(-z8 & z1*5/8)
    & z0
    & +z1
  )

def asu_071(): # I m m m
  return (direct_space_asu('-I 2 2')
    & x0
    & x4(y4(z4))
    & y0
    & y2
    & z0
    & z2
  )

def asu_072(): # I b a m
  return (direct_space_asu('-I 2 2c')
    & x0(z4)
    & x4(y4(z4))
    & y0(z4)
    & y2(z4)
    & z0
    & z2
  )

def asu_073(): # I b c a
  return (direct_space_asu('-I 2b 2c')
    & x0(y4)
    & x4(z4(y4))
    & y0(z4)
    & y2(-z4)
    & z0
    & +z2
  )

def asu_074(): # I m m a
  return (direct_space_asu('-I 2b 2')
    & x0
    & x4(-z4 & z1*3/4)
    & y0(z2)
    & y4
    & z0
    & +z1
  )

def asu_075(): # P 4
  return (direct_space_asu('P 4')
    & x0(-y0)
    & x2
    & y0
    & y2(-x2)
    & z0
    & +z1
  )

def asu_076(): # P 41 (enantiomorph of 76)
  return (direct_space_asu('P 4w')
    & x0(+z4)
    & x2(+z4)
    & y0(+z1*3/4)
    & y2(+z1*3/4)
    & z0
    & +z1
  )

def asu_077(): # P 42
  return (direct_space_asu('P 4c')
    & x0(+z2)
    & x2(+z2)
    & y0(+z2)
    & y2(+z2)
    & z0
    & +z1
  )

def asu_078(): # P 43 (enantiomorph of 78)
  return apply_change_of_basis(78)

def asu_079(): # I 4
  return (direct_space_asu('I 4')
    & x0(-y0)
    & x2
    & y0
    & y2(-x2)
    & z0
    & +z2
  )

def asu_080(): # I 41
  return (direct_space_asu('I 4bw')
    & x0(y2)
    & x2(y2)
    & y0
    & +y1
    & z0
    & +z4
  )

def asu_081(): # P -4
  return (direct_space_asu('P -4')
    & x0(-y0(z2))
    & x2
    & y0
    & y2(-x2(z2))
    & z0
    & +z1
  )

def asu_082(): # I -4
  return (direct_space_asu('I -4')
    & x0(z0(-y0))
    & x2(-y0(z4))
    & y0
    & y2(-x0(z4))
    & z0
    & z2(-y0)
  )

def asu_083(): # P 4/m
  return (direct_space_asu('-P 4')
    & x0(-y0)
    & x2
    & y0
    & y2(-x2)
    & z0
    & z2
  )

def asu_084(): # P 42/m
  return (direct_space_asu('-P 4c')
    & x0(-y0(z4))
    & x2
    & y0
    & y2(-x2(z4))
    & z0
    & z2
  )

def asu_085(): # P 4/n :2
  return (direct_space_asu('-P 4a')
    & ~x4(-~y4)
    & x4(z0(-~y4) & z2(-~y4))
    & ~y4
    & y4(-x4)
    & z0(-y0(-x0))
    & z2(-y0(-x0))
  )

def asu_086(): # P 42/n :2
  return (direct_space_asu('-P 4bc')
    & ~x4(-~y4(z4))
    & x4(z0(-~y4) & z2(+-~y4))
    & ~y4
    & y4(-x4(z4))
    & z0(-y0(-x0))
    & z2(-y0(-x0))
  )

def asu_087(): # I 4/m
  return (direct_space_asu('-I 4')
    & x0(-y0)
    & x2
    & y0
    & y2(-x2)
    & z0
    & z4(y4(x4) & x2(-y0))
  )

def asu_088(): # I 41/a :2
  return (direct_space_asu('-I 4ad')
    & x0
    & x4
    & y0(-x0(z2) | -x4(+z4))
    & y4(-x0(-z8 & z1*5/8))
    & z0
    & +z1
  )

def asu_089(): # P 4 2 2
  return (direct_space_asu('P 4 2')
    & x0(p0)
    & x2
    & y0
    & y2(-x2)
    & z0(p0)
    & z2(p0)
  )

def asu_090(): # P 4 21 2
  return (direct_space_asu('P 4ab 2ab')
    & x0
    & x2(-y0)
    & y0
    & y2(-x0)
    & z0(p0)
    & z2(p0)
  )

def asu_091(): # P 41 2 2 (enantiomorph of 95)
  return (direct_space_asu('P 4w 2c')
    & x0(z8(-y0))
    & +x1
    & y0
    & +y1
    & z0(x2)
    & z8(m1)
  )

def asu_092(): # P 41 21 2 (enantiomorph of 96)
  return (direct_space_asu('P 4abw 2nw')
    & x0
    & +x1
    & y0
    & +y1
    & z0(p0)
    & z8(-y2)
  )

def asu_093(): # P 42 2 2
  return (direct_space_asu('P 4c 2')
    & x0(y2)
    & x2(y2)
    & y0
    & +y1
    & z0(y2)
    & z4(-p0 & m1)
  )

def asu_094(): # P 42 21 2
  return (direct_space_asu('P 4n 2n')
    & x0(-y0)
    & x2(z2(-y2))
    & y0(z2(-x0))
    & +y2
    & z0(p0)
    & z2(p0)
  )

def asu_095(): # P 43 2 2 (enantiomorph of 91)
  return apply_change_of_basis(95)

def asu_096(): # P 43 21 2 (enantiomorph of 92)
  # cannot be superimposed with enantiomorphic asu 92
  return (direct_space_asu('P 4nw 2abw')
    & x0
    & +x1
    & y0
    & +y1
    & z0(p0)
    & z8(-x2)
  )

def asu_097(): # I 4 2 2
  return (direct_space_asu('I 4 2')
    & x0(-y0)
    & x2
    & y0
    & y2(-x2)
    & z0(p0)
    & z4(m2)
  )

def asu_098(): # I 41 2 2
  return (direct_space_asu('I 4bw 2bw')
    & x0(y2)
    & x2(y2)
    & y0
    & +y1
    & z0(m1 & -p0)
    & z8(-y4 & y1*3/4)
  )

def asu_099(): # P 4 m m
  return (direct_space_asu('P 4 -2')
    & x0
    & y2
    & z0
    & +z1
    & -p0
  )

def asu_100(): # P 4 b m
  return (direct_space_asu('P 4 -2ab')
    & x0(-y0)
    & y0
    & z0
    & +z1
    & m2
  )

def asu_101(): # P 42 c m
  return (direct_space_asu('P 4c -2c')
    & x0(+z2)
    & y2(+z2)
    & z0
    & +z1
    & -p0
  )

def asu_102(): # P 42 n m
  return (direct_space_asu('P 4n -2n')
    & x0(+z2)
    & y2(+z2)
    & z0
    & +z1
    & -p0
  )

def asu_103(): # P 4 c c
  return (direct_space_asu('P 4 -2c')
    & x0(-y0)
    & x2
    & y0
    & y2(-x2)
    & z0
    & +z2
  )

def asu_104(): # P 4 n c
  return (direct_space_asu('P 4 -2n')
    & x0(-y0)
    & x2
    & y0
    & y2(-x2)
    & z0
    & +z2
  )

def asu_105(): # P 42 m c
  return (direct_space_asu('P 4c -2')
    & x0
    & x2
    & y0
    & y2
    & z0
    & +z2
  )

def asu_106(): # P 42 b c
  return (direct_space_asu('P 4c -2ab')
    & x0(-y0)
    & x2
    & y0
    & +y2
    & z0
    & +z2
  )

def asu_107(): # I 4 m m
  return (direct_space_asu('I 4 -2')
    & x0
    & y2
    & z0
    & +z2
    & -p0
  )

def asu_108(): # I 4 c m
  return (direct_space_asu('I 4 -2c')
    & x0(-y0)
    & y0
    & z0
    & +z2
    & m2
  )

def asu_109(): # I 41 m d
  return (direct_space_asu('I 4bw -2')
    & x0
    & x2
    & y0
    & y2
    & z0
    & +z4
  )

def asu_110(): # I 41 c d
  return (direct_space_asu('I 4bw -2c')
    & x0(-y0)
    & x2
    & y0
    & +y2
    & z0
    & +z4
  )

def asu_111(): # P -4 2 m
  return (direct_space_asu('P -4 2')
    & x0(z2)
    & y2(z2)
    & z0
    & +z1
    & -p0
  )

def asu_112(): # P -4 2 c
  return (direct_space_asu('P -4 2c')
    & x0(z4 & z0(-y0))
    & x2(z4)
    & y0(z4)
    & y2(z4 & z0(-x2))
    & z0
    & +z2
  )

def asu_113(): # P -4 21 m
  return (direct_space_asu('P -4 2ab')
    & x0(-y0(z2))
    & y0
    & z0
    & +z1
    & m2
  )

def asu_114(): # P -4 21 c
  return (direct_space_asu('P -4 2n')
    & x0(-y0)
    & x2
    & y0
    & y2(-x2(-z0))
    & z0
    & +z2
  )

def asu_115(): # P -4 m 2
  return (direct_space_asu('P -4 -2')
    & x0
    & x2
    & y0
    & y2
    & z0(p0)
    & z2(p0)
  )

def asu_116(): # P -4 c 2
  return (direct_space_asu('P -4 -2c')
    & x0(y2)
    & x2(y2 & z0(-y2))
    & y0
    & +y1
    & z0(y2 & y0(-x0))
    & z4(m1 & -p0)
  )

def asu_117(): # P -4 b 2
  return (direct_space_asu('P -4 -2ab')
    & x0(z0(-y0) & z2(-y0))
    & x2(-y0)
    & y0
    & +y2
    & z0(m2)
    & z2(m2)
  )

def asu_118(): # P -4 n 2
  return (direct_space_asu('P -4 -2n')
    & x0(y2)
    & x2(y2)
    & y0
    & +y1
    & z0(y2(-x2) & x0(-y0))
    & z4(~p2 & -m2)
  )

def asu_119(): # I -4 m 2
  return (direct_space_asu('I -4 -2')
    & x0
    & x2
    & y0
    & y2
    & z0(p0)
    & z4(m2)
  )

def asu_120(): # I -4 c 2
  return (direct_space_asu('I -4 -2c')
    & x0(z0(-y0))
    & x2(-y0)
    & y0
    & +y2
    & z0(m2)
    & z4(p0)
  )

def asu_121(): # I -4 2 m
  return (direct_space_asu('I -4 2')
    & x0
    & y2(-x0(z4))
    & z0
    & z2(-x0)
    & -p0
  )

def asu_122(): # I -4 2 d
  return (direct_space_asu('I -4 2bw')
    & x0(y2 & z0(-y0))
    & x2(y2)
    & y0
    & +y1
    & z0(y2(-x2))
    & z8(-y4 & y1*3/4)
  )

def asu_123(): # P 4/m m m
  return (direct_space_asu('-P 4 2')
    & x0
    & y2
    & z0
    & z2
    & -p0
  )

def asu_124(): # P 4/m c c
  return (direct_space_asu('-P 4 2c')
    & x0(-y0)
    & x2
    & y0
    & y2(-x2)
    & z0
    & z4(p0)
  )

def asu_125(): # P 4/n b m :2
  return (direct_space_asu('-P 4a 2b')
    & ~x4(-~y4)
    & ~y4
    & z0(p0)
    & z2(p0)
    & -m0
  )

def asu_126(): # P 4/n n c :2
  return (direct_space_asu('-P 4a 2bc')
    & ~x4(-~y4)
    & x4
    & ~y4
    & y4(-x4)
    & z0(-y0(-x0) & x4(-~y4))
    & z4(p0)
  )

def asu_127(): # P 4/m b m
  return (direct_space_asu('-P 4 2ab')
    & x0(-y0)
    & y0
    & z0
    & z2
    & m2
  )

def asu_128(): # P 4/m n c
  return (direct_space_asu('-P 4 2n')
    & x0(-y0)
    & x2
    & y0
    & y2(-x2)
    & z0
    & z4(m2)
  )

def asu_129(): # P 4/n m m :2
  return (direct_space_asu('-P 4a 2a')
    & ~x4
    & y4
    & z0(-m0)
    & z2(-m0)
    & -p0
  )

def asu_130(): # P 4/n c c :2
  return (direct_space_asu('-P 4a 2ac')
    & ~x4(-~y4)
    & x4(z0(-~y4))
    & ~y4
    & y4(-x4)
    & z0(-y0(-x0))
    & z4(-m0)
  )

def asu_131(): # P 42/m m c
  return (direct_space_asu('-P 4c 2')
    & x0
    & x2
    & y0
    & y2
    & z0
    & z4(p0)
  )

def asu_132(): # P 42/m c m
  return (direct_space_asu('-P 4c 2c')
    & x0(z4)
    & y2(z4)
    & z0
    & z2
    & -p0
  )

def asu_133(): # P 42/n b c :2
  return (direct_space_asu('-P 4ac 2b')
    & ~x4
    & x4(-z0 | -~y4)
    & ~y4
    & +y4
    & z0(-y0(-x0))
    & z4(p0)
  )

def asu_134(): # P 42/n n m :2
  return (direct_space_asu('-P 4ac 2bc')
    & ~x4(z4)
    & ~y4(z4)
    & z0(p0)
    & z2(p0)
    & -m0
  )

def asu_135(): # P 42/m b c
  return (direct_space_asu('-P 4c 2ab')
    & x0(z4(-y0))
    & x2(-y0)
    & y0
    & +y2
    & z0
    & z4(m2)
  )

def asu_136(): # P 42/m n m
  return (direct_space_asu('-P 4n 2n')
    & x0(z4)
    & y2(z4(-x0))
    & z0
    & z2
    & -p0
  )

def asu_137(): # P 42/n m c :2
  return (direct_space_asu('-P 4ac 2a')
    & ~x4
    & x4
    & ~y4
    & y4
    & z0(-y0(-x0))
    & z4(-m0)
  )

def asu_138(): # P 42/n c m :2
  return (direct_space_asu('-P 4ac 2ac')
    & ~x4
    & y4(-~x4(z4))
    & z0(-m0)
    & z2(-m0 & ~x4(-y4))
    & -p0
  )

def asu_139(): # I 4/m m m
  return (direct_space_asu('-I 4 2')
    & x0
    & y2
    & z0
    & z4(m2)
    & -p0
  )

def asu_140(): # I 4/m c m
  return (direct_space_asu('-I 4 2c')
    & x0(-y0)
    & y0
    & z0
    & z4(p0)
    & m2
  )

def asu_141(): # I 41/a m d :2
  return (direct_space_asu('-I 4bd 2')
    & x0
    & x2
    & ~y4
    & y4
    & z0(-y0)
    & z8(-p4)
  )

def asu_142(): # I 41/a c d :2
  return (direct_space_asu('-I 4bd 2c')
    & x0(z8(-~y4) & z0(-y0))
    & x2(-~y4)
    & ~y4
    & +y4
    & z0(x4)
    & z8(m4)
  )

def asu_143(): # P 3
  return (direct_space_asu('P 3')
    & x0(-y0)
    & y0
    & z0
    & +z1
    & k1
    & m1(-h1 | -k1)
    & h1
  )

def asu_144(): # P 31 (enantiomorph of 145)
  return (direct_space_asu('P 31')
    & x0
    & +x1
    & y0
    & +y1
    & z0
    & +z3
  )

def asu_145(): # P 32 (enantiomorph of 144)
  return apply_change_of_basis(145)

def asu_146(): # R 3 :H
  return (direct_space_asu('R 3')
    & x0(-y0)
    & y0
    & z0
    & +z3
    & k1
    & m1(-h1 | -k1)
    & h1
  )

def asu_147(): # P -3
  return (direct_space_asu('-P 3')
    & x0(-y0)
    & y0
    & z0(p0(-y0))
    & z2(p0(-y0))
    & k1
    & m1(-h1 | -k1)
    & h1
  )

def asu_148(): # R -3 :H
  return (direct_space_asu('-R 3')
    & x0(-y0)
    & y0
    & z0(p0(-y0))
    & z6(-h0(x3) | -k0(-y0 | -m1))
    & k1
    & m1(-h1 | -k1)
    & h1
  )

def asu_149(): # P 3 1 2
  return (direct_space_asu('P 3 2')
    & x0(-y0)
    & y0
    & z0(-h0 | -k0)
    & z2(-h0 | -k0)
    & k1
    & m1(-h1 | -k1)
    & h1
  )

def asu_150(): # P 3 2 1
  return (direct_space_asu('P 3 2"')
    & x0(-y0)
    & y0
    & z0(p0)
    & z2(p0)
    & k1
    & m1(-h1 | -k1)
    & h1
  )

def asu_151(): # P 31 1 2 (enantiomorph of 153)
  return (direct_space_asu('P 31 2 (0 0 4)')
    & x0
    & +x1
    & y0
    & +y1
    & z0(-h0 | -h1)
    & z6(-k0 | -k1)
  )

def asu_152(): # P 31 2 1 (enantiomorph of 154)
  return (direct_space_asu('P 31 2"')
    & x0
    & +x1
    & y0
    & +y1
    & z0(-p0)
    & z6(-p0)
  )

def asu_153(): # P 32 1 2 (enantiomorph of 151)
  # cannot be superimposed with enantiomorphic asu 151
  return (direct_space_asu('P 32 2 (0 0 2)')
    & x0
    & +x1
    & y0
    & +y1
    & z0(-h0 | -h1)
    & z6(x0(-y0) & m1)
 )

def asu_154(): # P 32 2 1 (enantiomorph of 152)
  return apply_change_of_basis(154)

def asu_155(): # R 3 2 :H
  return (direct_space_asu('R 3 2"')
    & x0(-y0)
    & y0
    & z0(p0)
    & z6(x3 & ~p3)
    & k1
    & m1(-h1 | -k1)
    & h1
  )

def asu_156(): # P 3 m 1
  return (direct_space_asu('P 3 -2"')
    & z0
    & +z1
    & h0
    & m1
    & k0
  )

def asu_157(): # P 3 1 m
  return (direct_space_asu('P 3 -2')
    & y0
    & z0
    & +z1
    & k1
    & m1(y3)
    & p0
  )

def asu_158(): # P 3 c 1
  return (direct_space_asu('P 3 -2"c')
    & x0(-y0)
    & y0
    & z0
    & +z2
    & k1
    & m1(-h1 | -k1)
    & h1
  )

def asu_159(): # P 3 1 c
  return (direct_space_asu('P 3 -2c')
    & x0(-y0)
    & y0
    & z0
    & +z2
    & k1
    & m1(-h1 | -k1)
    & h1
  )

def asu_160(): # R 3 m :H
  return (direct_space_asu('R 3 -2"')
    & z0
    & +z3
    & h0
    & m1
    & k0
  )

def asu_161(): # R 3 c :H
  return (direct_space_asu('R 3 -2"c')
    & x0(-y0)
    & y0
    & z0
    & +z6
    & k1
    & m1(-h1 | -k1)
    & h1
  )

def asu_162(): # P -3 1 m
  return (direct_space_asu('-P 3 2')
    & y0
    & z0(-h0)
    & z2(-h0)
    & k1
    & m1(y3)
    & p0
  )

def asu_163(): # P -3 1 c
  return (direct_space_asu('-P 3 2c')
    & x0(-y0)
    & y0
    & z0(p0(-y0))
    & z4(-h0 | -k0)
    & k1
    & m1(-h1 | -k1)
    & h1
  )

def asu_164(): # P -3 m 1
  return (direct_space_asu('-P 3 2"')
    & y0(z2)
    & z0
    & +z1
    & k1
    & -h0
  )

def asu_165(): # P -3 c 1
  return (direct_space_asu('-P 3 2"c')
    & x0(-y0)
    & y0
    & z0(p0(-y0))
    & z4(p0)
    & k1
    & m1(-h1 | -k1)
    & h1
  )

def asu_166(): # R -3 m :H
  return (direct_space_asu('-R 3 2"')
    & z0(p0)
    & z6(x3)
    & h0
    & m1
    & k0
  )

def asu_167(): # R -3 c :H
  return (direct_space_asu('-R 3 2"c')
    & x0(-y0)
    & y0
    & z0(p0(-y0))
    & z12(y3 & p3)
    & k1
    & m1(-h1 | -k1)
    & h1
  )

def asu_168(): # P 6
  return (direct_space_asu('P 6')
    & y0
    & z0
    & +z1
    & k1
    & m1(y3)
    & p0(-y0)
  )

def asu_169(): # P 61 (enantiomorph of 170)
  return (direct_space_asu('P 61')
    & x0
    & +x1
    & y0
    & +y1
    & z0
    & +z6
  )

def asu_170(): # P 65 (enantiomorph of 169)
  return apply_change_of_basis(170)

def asu_171(): # P 62 (enantiomorph of 172)
  return (direct_space_asu('P 62')
    & x1(y2)
    & y0(x2)
    & z0
    & +z3
    & p0(y2)
  )

def asu_172(): # P 64 (enantiomorph of 171)
  return apply_change_of_basis(172)

def asu_173(): # P 63
  return (direct_space_asu('P 6c')
    & x0(-y0)
    & y0
    & z0
    & +z2
    & k1
    & m1(-h1 | -k1)
    & h1
  )

def asu_174(): # P -6
  return (direct_space_asu('P -6')
    & x0(-y0)
    & y0
    & z0
    & z2
    & k1
    & m1(-h1 | -k1)
    & h1
  )

def asu_175(): # P 6/m
  return (direct_space_asu('-P 6')
    & y0
    & z0
    & z2
    & k1
    & m1(y3)
    & p0(-y0)
  )

def asu_176(): # P 63/m
  return (direct_space_asu('-P 6c')
    & x0(-y0)
    & y0
    & z0(p0(-y0))
    & z4
    & k1
    & m1(-h1 | -k1)
    & h1
  )

def asu_177(): # P 6 2 2
  return (direct_space_asu('P 6 2')
    & y0
    & z0(-h0)
    & z2(-h0)
    & k1
    & m1(y3)
    & p0(-y0)
  )

def asu_178(): # P 61 2 2 (enantiomorph of 179)
  return (direct_space_asu('P 61 2 (0 0 5)')
    & x0
    & +x1
    & y0
    & +y1
    & z0(p0)
    & z12(-h0 | -h1)
  )

def asu_179(): # P 65 2 2 (enantiomorph of 178)
  # cannot be superimposed with enantiomorphic asu 178
  return (direct_space_asu('P 65 2 (0 0 1)')
    & x0
    & +x1
    & y0
    & +y1
    & z0(p0)
    & z12(m1 & x0(-y0))
  )

def asu_180(): # P 62 2 2 (enantiomorph of 181)
  return (direct_space_asu('P 62 2 (0 0 4)')
    & x1(y2)
    & y0(x2)
    & z0(k1)
    & z6(-h0)
    & p0(y2)
  )

def asu_181(): # P 64 2 2 (enantiomorph of 180)
  result = apply_change_of_basis(181)
  assert result.hall_symbol == " P 64 2 (x,y,z+1/6)"
  result.hall_symbol = "P 64 2 (0 0 2)" # Int. Tab. Vol. B compatibility
  return result

def asu_182(): # P 63 2 2
  return (direct_space_asu('P 6c 2c')
    & x0(-y0)
    & y0
    & z0(p0)
    & z4(-h0 | -k0)
    & k1
    & m1(-h1 | -k1)
    & h1
  )

def asu_183(): # P 6 m m
  return (direct_space_asu('P 6 -2')
    & y0
    & z0
    & +z1
    & k1
    & -h0
  )

def asu_184(): # P 6 c c
  return (direct_space_asu('P 6 -2c')
    & y0
    & z0
    & +z2
    & k1
    & m1(y3)
    & p0(-y0)
  )

def asu_185(): # P 63 c m
  return (direct_space_asu('P 6c -2')
    & y0
    & z0
    & +z2
    & k1
    & m1(y3)
    & p0
  )

def asu_186(): # P 63 m c
  return (direct_space_asu('P 6c -2c')
    & y0(+z2)
    & z0
    & +z1
    & k1
    & -h0
  )

def asu_187(): # P -6 m 2
  return (direct_space_asu('P -6 2')
    & z0
    & z2
    & h0
    & m1
    & k0
  )

def asu_188(): # P -6 c 2
  return (direct_space_asu('P -6c 2')
    & x0(-y0)
    & y0
    & z0(-h0 | -k0)
    & z4
    & k1
    & m1(-h1 | -k1)
    & h1
  )

def asu_189(): # P -6 2 m
  return (direct_space_asu('P -6 -2')
    & y0
    & z0
    & z2
    & k1
    & m1(y3)
    & p0
  )

def asu_190(): # P -6 2 c
  return (direct_space_asu('P -6c -2c')
    & x0(-y0)
    & y0
    & z0(p0)
    & z4
    & k1
    & m1(-h1 | -k1)
    & h1
  )

def asu_191(): # P 6/m m m
  return (direct_space_asu('-P 6 2')
    & y0
    & z0
    & z2
    & k1
    & -h0
  )

def asu_192(): # P 6/m c c
  return (direct_space_asu('-P 6 2c')
    & y0
    & z0
    & z4(-h0)
    & k1
    & m1(y3)
    & p0(-y0)
  )

def asu_193(): # P 63/m c m
  return (direct_space_asu('-P 6c 2')
    & y0
    & z0(-h0)
    & z4
    & k1
    & m1(y3)
    & p0
  )

def asu_194(): # P 63/m m c
  return (direct_space_asu('-P 6c 2c')
    & z0(p0)
    & z4
    & h0
    & m1
    & k0
  )

def asu_195(): # P 2 3
  return (direct_space_asu('P 2 2 3')
    & z0(y2 & x2)
    & m1(-y2)
    & zy0(-zx0)
    & zx0
  )

def asu_196(): # F 2 3
  return (direct_space_asu('F 2 2 3')
    & p0(m2)
    & ~xz2(-zy0)
    & zx2(yz0)
    & -yz0
    & zy0
  )

def asu_197(): # I 2 3
  return (direct_space_asu('I 2 2 3')
    & z0(x2)
    & p0(-zy0)
    & +m1
    & zy0
  )

def asu_198(): # P 21 3
  return (direct_space_asu('P 2ac 2ab 3')
    & x0(-y0)
    & x2
    & y2(+z0 & x2(+z2))
    & zx2(m2)
    & zx0(p0)
    & -yz0
    & zy0
  )

def asu_199(): # I 21 3
  return (direct_space_asu('I 2b 2c 3')
    & x2(-y4)
    & y2(-z4)
    & z0(x4)
    & zx0(-zy0(+x2))
    & zy0
  )

def asu_200(): # P m -3
  return (direct_space_asu('-P 2 2 3')
    & x2
    & y2
    & z0
    & zx0(-zy0)
    & zy0
  )

def asu_201(): # P n -3 :2
  return (direct_space_asu('-P 2ab 2bc 3')
    & ~z4(x4)
    & p0(-zy0(-x0))
    & m2(-zy0(x2))
    & zy0
  )

def asu_202(): # F m -3
  return (direct_space_asu('-F 2 2 3')
    & z0
    & p0(x4)
    & ~xz2(-zy0)
    & zy0
  )

def asu_203(): # F d -3 :2
  return (direct_space_asu('-F 2uv 2vw 3')
    & p0(-zy0(-x0))
    & m4(-zy0 | -yz4(~z4))
    & zy0
    & yz4
  )

def asu_204(): # I m -3
  return (direct_space_asu('-I 2 2 3')
    & x2
    & z0
    & p0(-zy0(x4))
    & zy0
  )

def asu_205(): # P a -3
  return (direct_space_asu('-P 2ac 2ab 3')
    & x2(-z0(-zy0))
    & y2(-zy0)
    & z0
    & zx0(-zy0)
    & zy0
  )

def asu_206(): # I a -3
  return (direct_space_asu('-I 2b 2c 3')
    & z0(x4)
    & zx0(-zy0)
    & ~xz2
    & zy0
    & ~yz2(-zx0)
  )

def asu_207(): # P 4 3 2
  return (direct_space_asu('P 4 2 3')
    & z0(x2)
    & p0
    & m1(-p0)
    & zy0(x2)
  )

def asu_208(): # P 42 3 2
  return (direct_space_asu('P 4n 2 3')
    & zx0(-zy0)
    & -xz0(yz0)
    & zx2(y4)
    & ~xz2(y4)
    & zy0
    & -yz0
    & zy2(-x4)
    & ~yz2(-x4)
  )

def asu_209(): # F 4 3 2
  return (direct_space_asu('F 4 2 3')
    & p0(z0)
    & m2(z0)
    & zy0
    & -yz0(-zy0)
  )

def asu_210(): # F 41 3 2
  return (direct_space_asu('F 4d 2 3')
    & y8(-~xz4)
    & z8(m4)
    & p0(-zx0)
    & m2(-~xz2)
    & -yz0(z0)
    & zx0
    & ~xz2
  )

def asu_211(): # I 4 3 2
  return (direct_space_asu('I 4 2 3')
    & z0(p0)
    & zx0(-zy0)
    & ~xz2(y4)
    & zy0
    & ~yz2(-x4)
  )

def asu_212(): # P 43 3 2 (enantiomorph of 213)
  return (direct_space_asu('P 4acd 2ab 3')
    & zx2
    & -yz0(-zx2)
    & ~yz2(tx0)
    & -tx0(x8)
    & ty0(y8)
    & tz2(-x1*3/8)
  )

def asu_213(): # P 41 3 2 (enantiomorph of 212)
  return apply_change_of_basis(213)

def asu_214(): # I 41 3 2
  return (direct_space_asu('I 4bd 2c 3')
    & x8(~yz4)
    & y8(~xz4)
    & ~y8(-~zx1/4)
    & -zx0(zy0)
    & -zy0
    & ~zy4(-y0)
    & dy8(~p4)
  )

def asu_215(): # P -4 3 m
  return (direct_space_asu('P -4 2 3')
    & z0(x2)
    & p0
    & m1
    & zy0
  )

def asu_216(): # F -4 3 m
  return (direct_space_asu('F -4 2 3')
    & p0
    & m2
    & zy0
    & -yz0
  )

def asu_217(): # I -4 3 m
  return (direct_space_asu('I -4 2 3')
    & x2(-z0(y4))
    & z0
    & p0
    & zy0
  )

def asu_218(): # P -4 3 n
  return (direct_space_asu('P -4n 2 3')
    & x2(-z0(y4))
    & y2(-z0(x4))
    & z0
    & zx0(-zy0)
    & zy0
  )

def asu_219(): # F -4 3 c
  return (direct_space_asu('F -4a 2 3')
    & p0
    & m2(-p0(z0))
    & zy0
    & -yz0(-p0 | -zy0(x4))
  )

def asu_220(): # I -4 3 d
  return (direct_space_asu('I -4bd 2c 3')
    & -x4(-z0(-y1*3/8))
    & x2
    & -y4(-x2(-z8))
    & y2(-z4)
    & z0
    & zx0(-zy0)
    & zy0
  )

def asu_221(): # P m -3 m
  return (direct_space_asu('-P 4 2 3')
    & x2
    & z0
    & p0
    & zy0
  )

def asu_222(): # P n -3 n :2
  return (direct_space_asu('-P 4a 2bc 3')
    & x34(z4(y2) | -zy0)
    & -z4
    & p0(-zy0(z2))
    & zy0
  )

def asu_223(): # P m -3 n
  return (direct_space_asu('-P 4n 2 3')
    & z0
    & zx0(-zy0)
    & ~xz2(y4)
    & zy0
    & ~yz2(x4)
  )

def asu_224(): # P n -3 m :2
  return (direct_space_asu('-P 4bc 2bc 3')
    & p0
    & ~xz1(y2)
    & zx2(y2)
    & -~yz2
    & zy0
  )

def asu_225(): # F m -3 m
  return (direct_space_asu('-F 4 2 3')
    & z0
    & p0
    & m2
    & zy0
  )

def asu_226(): # F m -3 c
  return (direct_space_asu('-F 4a 2 3')
    & z0
    & p0
    & m2(-p0)
    & zy0(x4)
  )

def asu_227(): # F d -3 m :2
  return (direct_space_asu('-F 4vw 2vw 3')
    & -y0(-xz0)
    & p0
    & m4
    & yz4
    & zy0
  )

def asu_228(): # F d -3 c :2
  return (direct_space_asu('-F 4ud 2vw 3')
    & -y0(zx1/4)
    & p0(-zy0)
    & m4
    & yz4(-zy0(x8))
    & zy0
  )

def asu_229(): # I m -3 m
  return (direct_space_asu('-I 4 2 3')
    & z0
    & p0
    & ~xz2(y4)
    & zy0
  )

def asu_230(): # I a -3 d
  return (direct_space_asu('-I 4bd 2c 3')
    & x8(~zy4 & ~yz4)
    & ~x8(y0(-z4))
    & y8(-~xz4)
    & ~y8(~zx1/4)
    & z4(y0)
    & -zx0
    & -xz0(-z0)
    & -zy0(zx0)
    & -yz0
  )

def get_asu(space_group_number):
  return eval("asu_%03d" % space_group_number)()

if (__name__ == "__main__"):
  for i in range(1,231):
    get_asu(i).show_summary()


 *******************************************************************************
