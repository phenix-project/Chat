

 *******************************************************************************
mmtbx/regression/real_space_refine_chain/tst_01.py
from __future__ import absolute_import, division, print_function
import time, os, random
import iotbx.pdb
import mmtbx.utils
from mmtbx import monomer_library
from scitbx.array_family import flex
import mmtbx.refinement.real_space.explode_and_refine
from mmtbx.geometry_restraints import reference
from iotbx import reflection_file_reader
import libtbx.load_env

#if (1):
#  random.seed(0)
#  flex.set_random_seed(0)

def ccp4_map(crystal_symmetry, file_name, map_data):
  from iotbx import mrcfile
  mrcfile.write_ccp4_map(
      file_name=file_name,
      unit_cell=crystal_symmetry.unit_cell(),
      space_group=crystal_symmetry.space_group(),
      #gridding_first=(0,0,0),# This causes a bug (map gets shifted)
      #gridding_last=n_real,  # This causes a bug (map gets shifted)
      map_data=map_data,
      labels=flex.std_string([""]))

def run(prefix="tst_00"):
  # Poor model that we want to refine so it matches the answer
  pdb_file = libtbx.env.find_in_repositories(
    relative_path="mmtbx/regression/real_space_refine_chain/poor_model.pdb",
    test=os.path.isfile)
  mtz_file = libtbx.env.find_in_repositories(
    relative_path="mmtbx/regression/real_space_refine_chain/poor_map.mtz",
    test=os.path.isfile)
  pdb_inp = iotbx.pdb.input(file_name=pdb_file)
  ph_poor = pdb_inp.construct_hierarchy()
  ph_poor.atoms().reset_i_seq()
  xrs_poor = pdb_inp.xray_structure_simple()
  # Initialize states accumulator
  states = mmtbx.utils.states(pdb_hierarchy=ph_poor)
  states.add(sites_cart = xrs_poor.sites_cart())
  # Compute target map
  mas = reflection_file_reader.any_reflection_file(file_name =
    mtz_file).as_miller_arrays()
  assert len(mas)==1
  fc = mas[0]

  fft_map = fc.fft_map(resolution_factor = 0.25)
  fft_map.apply_sigma_scaling()
  target_map_data = fft_map.real_map_unpadded()
  ccp4_map(crystal_symmetry=fc.crystal_symmetry(), file_name="map.ccp4",
    map_data=target_map_data)
  # Build geometry restraints
  params = monomer_library.pdb_interpretation.master_params.extract()
  params.nonbonded_weight=200
  #params.peptide_link.ramachandran_restraints=True
  #params.peptide_link.rama_potential="oldfield"
  #print dir(params)
  #STOP()
  processed_pdb_file = monomer_library.pdb_interpretation.process(
    mon_lib_srv              = monomer_library.server.server(),
    ener_lib                 = monomer_library.server.ener_lib(),
    file_name              = pdb_file,
    params                   = params,
    #crystal_symmetry = fc.crystal_symmetry(),
    strict_conflict_handling = True,
    force_symmetry           = True,
    log                      = None)

  geometry = processed_pdb_file.geometry_restraints_manager(
    show_energies                = False,
    plain_pairs_radius           = 5,
    assume_hydrogens_all_missing = True)
  restraints_manager = mmtbx.restraints.manager(
    geometry      = geometry,
    normalization = True)

  #for a in ph_answer.atoms():
  #  print a.i_seq, a.name, a.xyz
    #STOP()

  #ref_xyz = flex.vec3_double([(14.323, 35.055, 14.635), (16.099, 12.317, 16.37)])
  #selection = flex.size_t([1,76])
  #
  #restraints_manager.geometry.adopt_reference_coordinate_restraints_in_place(
  #  reference.add_coordinate_restraints(
  #    sites_cart = ref_xyz,
  #    selection = selection,
  #    sigma = 0.1))

  # Do real-space refinement
  t0=time.time()
  ear = mmtbx.refinement.real_space.explode_and_refine.run(
    xray_structure          = xrs_poor,
    pdb_hierarchy           = ph_poor,
    map_data                = target_map_data,
    restraints_manager      = restraints_manager,
    states                  = states)
  print("Time: %6.4f"%(time.time()-t0))
  ear.pdb_hierarchy.write_pdb_file(file_name="%s_refined.pdb"%prefix)
  states.write(file_name="%s_refined_all_states.pdb"%prefix)

if (__name__ == "__main__"):
  rs = 3292014
  random.seed(rs)
  flex.set_random_seed(rs)
  run()
  print("OK")


 *******************************************************************************


 *******************************************************************************
mmtbx/regression/tls/__init__.py


 *******************************************************************************


 *******************************************************************************
mmtbx/regression/tls/tst_formula_t_S_10_vs_11_2igd.py
from __future__ import absolute_import, division, print_function
from mmtbx.tls import tools
import time
import iotbx.pdb
import mmtbx.tls.tools
from scitbx import matrix
from mmtbx.tls import analysis
import math
from scitbx.array_family import flex
from six.moves import range

pdb_str_CA = """
REMARK   3  TLS DETAILS.
REMARK   3   NUMBER OF TLS GROUPS: 1
REMARK   3   ORIGIN: CENTER OF MASS
REMARK   3   TLS GROUP : 1
REMARK   3    SELECTION: all
REMARK   3    ORIGIN FOR THE GROUP (A):   8.7338  28.3021  16.6793
REMARK   3    T TENSOR
REMARK   3      T11:   0.0695 T22:   0.0842
REMARK   3      T33:   0.0992 T12:   0.0039
REMARK   3      T13:  -0.0041 T23:   0.0014
REMARK   3    L TENSOR
REMARK   3      L11:   2.1725 L22:   0.5881
REMARK   3      L33:   1.1562 L12:   0.4879
REMARK   3      L13:  -0.0881 L23:   0.2404
REMARK   3    S TENSOR
REMARK   3      S11:   0.0512 S12:   0.0543 S13:   0.0992
REMARK   3      S21:  -0.0892 S22:  -0.0659 S23:  -0.0441
REMARK   3      S31:  -0.0042 S32:  -0.0302 S33:   0.0147
CRYST1   35.050   40.500   42.370  90.00  90.00  90.00 P 21 21 21
SCALE1      0.028531  0.000000  0.000000        0.00000
SCALE2      0.000000  0.024691  0.000000        0.00000
SCALE3      0.000000  0.000000  0.023602        0.00000
ATOM      1  CA  THR A   6       6.096  14.546  15.382  1.00  1.21           C
ATOM      2  CA  THR A   7       4.643  17.379  17.472  1.00  0.67           C
ATOM      3  CA  TYR A   8       7.031  20.308  17.626  1.00 -0.75           C
ATOM      4  CA  LYS A   9       6.715  23.191  20.108  1.00 -0.06           C
ATOM      5  CA  LEU A  10       7.484  26.896  19.736  1.00 -0.50           C
ATOM      6  CA  VAL A  11       8.313  28.973  22.814  1.00 -0.68           C
ATOM      7  CA  ILE A  12       7.745  32.666  21.951  1.00  0.00           C
ATOM      8  CA  ASN A  13       9.367  35.454  23.951  1.00  2.73           C
ATOM      9  CA  GLY A  14       8.223  38.436  21.869  1.00  4.26           C
ATOM     10  CA  LYS A  15       7.732  42.071  22.635  1.00  4.20           C
ATOM     11  CA  THR A  16       3.910  41.794  22.427  1.00 -1.15           C
ATOM     12  CA  LEU A  17       3.328  38.080  21.651  1.00 -2.50           C
ATOM     13  CA  LYS A  18       4.268  35.598  24.351  1.00 -2.00           C
ATOM     14  CA  GLY A  19       3.567  31.957  25.117  1.00 -1.89           C
ATOM     15  CA  GLU A  20       3.694  28.633  23.293  1.00 -1.20           C
ATOM     16  CA  THR A  21       2.207  27.042  20.183  1.00 -0.48           C
ATOM     17  CA  THR A  22       2.609  23.707  18.385  1.00 -0.37           C
ATOM     18  CA  THR A  23       2.682  22.183  14.916  1.00  1.08           C
ATOM     19  CA  LYS A  24       2.823  18.625  13.556  1.00  2.05           C
ATOM     20  CA  ALA A  25       5.312  17.719  10.843  1.00 -0.46           C
ATOM     21  CA  VAL A  26       7.260  14.854   9.299  1.00 -1.58           C
ATOM     22  CA  ASP A  27      10.612  16.526  10.001  1.00 -1.52           C
ATOM     23  CA  ALA A  28      12.142  19.541  11.794  1.00  0.14           C
ATOM     24  CA  GLU A  29      12.712  21.542   8.632  1.00  0.11           C
ATOM     25  CA  THR A  30       9.005  21.472   7.817  1.00 -1.33           C
ATOM     26  CA  ALA A  31       8.121  22.548  11.353  1.00  0.02           C
ATOM     27  CA  GLU A  32      10.719  25.317  11.217  1.00  0.13           C
ATOM     28  CA  LYS A  33       9.139  26.736   8.061  1.00  0.27           C
ATOM     29  CA  ALA A  34       5.654  26.682   9.658  1.00  0.18           C
ATOM     30  CA  PHE A  35       6.940  28.471  12.774  1.00 -0.71           C
ATOM     31  CA  LYS A  36       8.915  31.065  10.827  1.00 -0.16           C
ATOM     32  CA  GLN A  37       5.784  31.817   8.802  1.00 -0.29           C
ATOM     33  CA  TYR A  38       3.757  32.125  12.022  1.00 -0.88           C
ATOM     34  CA  ALA A  39       6.322  34.523  13.495  1.00 -0.11           C
ATOM     35  CA  ASN A  40       6.375  36.639  10.306  1.00  0.84           C
ATOM     36  CA  ASP A  41       2.536  36.702  10.145  1.00 -0.52           C
ATOM     37  CA  ASN A  42       2.519  38.093  13.718  1.00 -0.69           C
ATOM     38  CA  GLY A  43       5.296  40.638  13.264  1.00  0.34           C
ATOM     39  CA  VAL A  44       7.921  38.823  15.338  1.00  0.90           C
ATOM     40  CA  ASP A  45      11.526  39.426  14.290  1.00  3.57           C
ATOM     41  CA  GLY A  46      13.865  37.643  16.623  1.00  2.59           C
ATOM     42  CA  VAL A  47      16.614  35.096  17.081  1.00 -1.03           C
ATOM     43  CA  TRP A  48      16.026  31.364  17.129  1.00 -1.89           C
ATOM     44  CA  THR A  49      17.146  28.133  18.719  1.00 -1.92           C
ATOM     45  CA  TYR A  50      16.165  24.543  17.999  1.00 -1.32           C
ATOM     46  CA  ASP A  51      16.716  21.634  20.410  1.00 -0.77           C
ATOM     47  CA  ASP A  52      16.413  18.270  18.691  1.00  0.97           C
ATOM     48  CA  ALA A  53      16.219  16.432  22.049  1.00  4.22           C
ATOM     49  CA  THR A  54      12.971  18.177  23.062  1.00  1.37           C
ATOM     50  CA  LYS A  55      11.609  19.022  19.577  1.00 -0.72           C
ATOM     51  CA  THR A  56      11.365  22.651  20.684  1.00 -0.98           C
ATOM     52  CA  PHE A  57      12.052  25.886  18.846  1.00 -1.21           C
ATOM     53  CA  THR A  58      12.461  29.177  20.755  1.00 -1.19           C
ATOM     54  CA  VAL A  59      12.275  32.720  19.421  1.00 -1.14           C
ATOM     55  CA  THR A  60      13.202  35.851  21.380  1.00 -0.88           C
ATOM     56  CA  GLU A  61      12.989  39.521  20.535  1.00  1.06           C
TER
END
"""

pdb_str_CACON = """
REMARK   3  TLS DETAILS.
REMARK   3   NUMBER OF TLS GROUPS: 1
REMARK   3   ORIGIN: CENTER OF MASS
REMARK   3   TLS GROUP : 1
REMARK   3    SELECTION: all
REMARK   3    ORIGIN FOR THE GROUP (A):   8.6859  28.4733  16.7346
REMARK   3    T TENSOR
REMARK   3      T11:   0.0691 T22:   0.0854
REMARK   3      T33:   0.1047 T12:   0.0048
REMARK   3      T13:  -0.0039 T23:  -0.0005
REMARK   3    L TENSOR
REMARK   3      L11:   2.1972 L22:   0.5110
REMARK   3      L33:   1.3269 L12:   0.5440
REMARK   3      L13:   0.0026 L23:   0.2089
REMARK   3    S TENSOR
REMARK   3      S11:   0.0612 S12:   0.0383 S13:   0.0986
REMARK   3      S21:  -0.0977 S22:  -0.0764 S23:  -0.0418
REMARK   3      S31:  -0.0211 S32:  -0.0272 S33:   0.0152
CRYST1   35.050   40.500   42.370  90.00  90.00  90.00 P 21 21 21
SCALE1      0.028531  0.000000  0.000000        0.00000
SCALE2      0.000000  0.024691  0.000000        0.00000
SCALE3      0.000000  0.000000  0.023602        0.00000
ATOM      1  N   THR A   6       5.628  14.116  14.075  1.00 -0.14           N
ATOM      2  CA  THR A   6       6.096  14.546  15.382  1.00  0.86           C
ATOM      3  C   THR A   6       5.411  15.882  15.727  1.00  0.13           C
ATOM      4  O   THR A   6       5.231  16.716  14.846  1.00  1.04           O
ATOM      5  N   THR A   7       5.084  16.089  17.004  1.00  0.55           N
ATOM      6  CA  THR A   7       4.643  17.379  17.472  1.00  0.42           C
ATOM      7  C   THR A   7       5.853  18.199  17.897  1.00  0.02           C
ATOM      8  O   THR A   7       6.635  17.775  18.761  1.00  3.64           O
ATOM      9  N   TYR A   8       5.998  19.354  17.311  1.00 -1.13           N
ATOM     10  CA  TYR A   8       7.031  20.308  17.626  1.00 -0.96           C
ATOM     11  C   TYR A   8       6.384  21.477  18.386  1.00 -1.13           C
ATOM     12  O   TYR A   8       5.253  21.855  18.136  1.00  1.22           O
ATOM     13  N   LYS A   9       7.151  22.068  19.294  1.00 -0.54           N
ATOM     14  CA  LYS A   9       6.715  23.191  20.108  1.00 -0.24           C
ATOM     15  C   LYS A   9       7.502  24.425  19.761  1.00 -0.91           C
ATOM     16  O   LYS A   9       8.703  24.345  19.462  1.00  0.55           O
ATOM     17  N   LEU A  10       6.854  25.585  19.831  1.00 -0.60           N
ATOM     18  CA  LEU A  10       7.484  26.896  19.736  1.00 -0.67           C
ATOM     19  C   LEU A  10       7.237  27.653  21.022  1.00 -0.77           C
ATOM     20  O   LEU A  10       6.081  27.852  21.422  1.00  0.79           O
ATOM     21  N   VAL A  11       8.311  28.092  21.657  1.00 -0.91           N
ATOM     22  CA  VAL A  11       8.313  28.973  22.814  1.00 -0.87           C
ATOM     23  C   VAL A  11       8.589  30.397  22.266  1.00 -0.99           C
ATOM     24  O   VAL A  11       9.615  30.605  21.632  1.00  0.68           O
ATOM     25  N   ILE A  12       7.658  31.314  22.493  1.00 -0.10           N
ATOM     26  CA  ILE A  12       7.745  32.666  21.951  1.00 -0.24           C
ATOM     27  C   ILE A  12       7.922  33.678  23.059  1.00 -0.20           C
ATOM     28  O   ILE A  12       7.053  33.835  23.928  1.00  0.88           O
ATOM     29  N   ASN A  13       9.057  34.372  23.043  1.00  1.02           N
ATOM     30  CA  ASN A  13       9.367  35.454  23.951  1.00  2.42           C
ATOM     31  C   ASN A  13       9.451  36.755  23.159  1.00  2.65           C
ATOM     32  O   ASN A  13      10.525  37.295  22.962  1.00  3.78           O
ATOM     33  N   GLY A  14       8.318  37.243  22.670  1.00  3.66           N
ATOM     34  CA  GLY A  14       8.223  38.436  21.869  1.00  3.84           C
ATOM     35  C   GLY A  14       7.950  39.692  22.643  1.00  3.14           C
ATOM     36  O   GLY A  14       7.646  39.596  23.871  1.00  6.24           O
ATOM     37  N   LYS A  15       8.054  40.804  21.975  1.00  3.35           N
ATOM     38  CA  LYS A  15       7.732  42.071  22.635  1.00  3.60           C
ATOM     39  C   LYS A  15       6.257  42.190  23.003  1.00 -0.24           C
ATOM     40  O   LYS A  15       5.977  42.698  24.043  1.00  3.00           O
ATOM     41  N   THR A  16       5.349  41.732  22.127  1.00 -1.64           N
ATOM     42  CA  THR A  16       3.910  41.794  22.427  1.00 -1.81           C
ATOM     43  C   THR A  16       3.272  40.435  22.393  1.00 -3.01           C
ATOM     44  O   THR A  16       2.195  40.299  22.987  1.00  0.66           O
ATOM     45  N   LEU A  17       3.854  39.437  21.763  1.00 -2.63           N
ATOM     46  CA  LEU A  17       3.328  38.080  21.651  1.00 -2.98           C
ATOM     47  C   LEU A  17       4.186  37.184  22.514  1.00 -2.79           C
ATOM     48  O   LEU A  17       5.396  37.109  22.337  1.00  0.26           O
ATOM     49  N   LYS A  18       3.557  36.473  23.453  1.00 -2.77           N
ATOM     50  CA  LYS A  18       4.268  35.598  24.351  1.00 -2.40           C
ATOM     51  C   LYS A  18       3.460  34.329  24.578  1.00 -2.72           C
ATOM     52  O   LYS A  18       2.235  34.355  24.675  1.00 -1.00           O
ATOM     53  N   GLY A  19       4.160  33.211  24.736  1.00 -2.52           N
ATOM     54  CA  GLY A  19       3.567  31.957  25.117  1.00 -2.20           C
ATOM     55  C   GLY A  19       4.126  30.802  24.327  1.00 -2.08           C
ATOM     56  O   GLY A  19       5.355  30.755  24.092  1.00 -0.35           O
ATOM     57  N   GLU A  20       3.289  29.842  23.994  1.00 -2.15           N
ATOM     58  CA  GLU A  20       3.694  28.633  23.293  1.00 -1.43           C
ATOM     59  C   GLU A  20       2.621  28.265  22.255  1.00 -1.41           C
ATOM     60  O   GLU A  20       1.437  28.479  22.482  1.00 -0.28           O
ATOM     61  N   THR A  21       3.079  27.640  21.179  1.00 -0.73           N
ATOM     62  CA  THR A  21       2.207  27.042  20.183  1.00 -0.68           C
ATOM     63  C   THR A  21       2.866  25.745  19.700  1.00 -0.64           C
ATOM     64  O   THR A  21       3.984  25.412  20.101  1.00  0.50           O
ATOM     65  N   THR A  22       2.147  25.001  18.859  1.00 -0.43           N
ATOM     66  CA  THR A  22       2.609  23.707  18.385  1.00 -0.54           C
ATOM     67  C   THR A  22       2.283  23.535  16.910  1.00 -0.03           C
ATOM     68  O   THR A  22       1.334  24.152  16.388  1.00  1.60           O
ATOM     69  N   THR A  23       2.999  22.625  16.268  1.00  0.08           N
ATOM     70  CA  THR A  23       2.682  22.183  14.916  1.00  0.94           C
ATOM     71  C   THR A  23       3.082  20.724  14.791  1.00  0.72           C
ATOM     72  O   THR A  23       3.965  20.253  15.484  1.00  3.94           O
ATOM     73  N   LYS A  24       2.489  20.032  13.836  1.00  1.40           N
ATOM     74  CA  LYS A  24       2.823  18.625  13.556  1.00  1.88           C
ATOM     75  C   LYS A  24       3.526  18.598  12.186  1.00  0.44           C
ATOM     76  O   LYS A  24       3.089  19.260  11.239  1.00  1.80           O
ATOM     77  N   ALA A  25       4.612  17.830  12.094  1.00 -0.69           N
ATOM     78  CA  ALA A  25       5.312  17.719  10.843  1.00 -0.66           C
ATOM     79  C   ALA A  25       6.098  16.407  10.770  1.00 -1.76           C
ATOM     80  O   ALA A  25       6.446  15.811  11.785  1.00 -0.29           O
ATOM     81  N   VAL A  26       6.448  16.040   9.546  1.00 -1.94           N
ATOM     82  CA  VAL A  26       7.260  14.854   9.299  1.00 -1.91           C
ATOM     83  C   VAL A  26       8.714  15.045   9.672  1.00 -2.12           C
ATOM     84  O   VAL A  26       9.432  14.072   9.914  1.00  0.90           O
ATOM     85  N   ASP A  27       9.221  16.273   9.700  1.00 -2.07           N
ATOM     86  CA  ASP A  27      10.612  16.526  10.001  1.00 -1.87           C
ATOM     87  C   ASP A  27      10.736  17.942  10.570  1.00 -1.92           C
ATOM     88  O   ASP A  27       9.811  18.770  10.534  1.00 -0.67           O
ATOM     89  N   ALA A  28      11.911  18.229  11.106  1.00 -0.78           N
ATOM     90  CA  ALA A  28      12.142  19.541  11.794  1.00 -0.15           C
ATOM     91  C   ALA A  28      12.174  20.683  10.816  1.00 -0.64           C
ATOM     92  O   ALA A  28      11.745  21.792  11.167  1.00  1.48           O
ATOM     93  N   GLU A  29      12.656  20.492   9.584  1.00 -0.63           N
ATOM     94  CA  GLU A  29      12.712  21.542   8.632  1.00 -0.14           C
ATOM     95  C   GLU A  29      11.307  22.028   8.263  1.00 -1.18           C
ATOM     96  O   GLU A  29      11.082  23.232   8.087  1.00  0.02           O
ATOM     97  N   THR A  30      10.368  21.120   8.131  1.00 -1.46           N
ATOM     98  CA  THR A  30       9.005  21.472   7.817  1.00 -1.49           C
ATOM     99  C   THR A  30       8.367  22.269   8.951  1.00 -1.23           C
ATOM    100  O   THR A  30       7.682  23.269   8.742  1.00 -0.09           O
ATOM    101  N   ALA A  31       8.601  21.802  10.188  1.00 -0.98           N
ATOM    102  CA  ALA A  31       8.121  22.548  11.353  1.00 -0.13           C
ATOM    103  C   ALA A  31       8.748  23.937  11.415  1.00 -0.59           C
ATOM    104  O   ALA A  31       8.051  24.901  11.739  1.00  0.74           O
ATOM    105  N   GLU A  32      10.048  24.036  11.158  1.00 -0.47           N
ATOM    106  CA  GLU A  32      10.719  25.317  11.217  1.00 -0.03           C
ATOM    107  C   GLU A  32      10.069  26.311  10.244  1.00 -0.35           C
ATOM    108  O   GLU A  32       9.834  27.465  10.577  1.00  0.77           O
ATOM    109  N   LYS A  33       9.765  25.875   9.026  1.00 -0.33           N
ATOM    110  CA  LYS A  33       9.139  26.736   8.061  1.00  0.18           C
ATOM    111  C   LYS A  33       7.767  27.197   8.527  1.00 -0.30           C
ATOM    112  O   LYS A  33       7.400  28.364   8.365  1.00  1.03           O
ATOM    113  N   ALA A  34       6.967  26.300   9.133  1.00 -0.05           N
ATOM    114  CA  ALA A  34       5.654  26.682   9.658  1.00  0.11           C
ATOM    115  C   ALA A  34       5.813  27.704  10.762  1.00 -0.79           C
ATOM    116  O   ALA A  34       5.034  28.686  10.833  1.00  0.64           O
ATOM    117  N   PHE A  35       6.745  27.528  11.666  1.00 -0.78           N
ATOM    118  CA  PHE A  35       6.940  28.471  12.774  1.00 -0.83           C
ATOM    119  C   PHE A  35       7.513  29.793  12.317  1.00 -0.91           C
ATOM    120  O   PHE A  35       7.128  30.833  12.863  1.00 -0.22           O
ATOM    121  N   LYS A  36       8.408  29.812  11.346  1.00 -0.44           N
ATOM    122  CA  LYS A  36       8.915  31.065  10.827  1.00 -0.30           C
ATOM    123  C   LYS A  36       7.793  31.837  10.117  1.00 -0.74           C
ATOM    124  O   LYS A  36       7.745  33.048  10.259  1.00  0.39           O
ATOM    125  N   GLN A  37       6.904  31.157   9.421  1.00 -0.76           N
ATOM    126  CA  GLN A  37       5.784  31.817   8.802  1.00 -0.37           C
ATOM    127  C   GLN A  37       4.860  32.399   9.857  1.00 -1.78           C
ATOM    128  O   GLN A  37       4.396  33.535   9.732  1.00 -0.52           O
ATOM    129  N   TYR A  38       4.554  31.635  10.899  1.00 -1.35           N
ATOM    130  CA  TYR A  38       3.757  32.125  12.022  1.00 -1.03           C
ATOM    131  C   TYR A  38       4.366  33.371  12.623  1.00 -2.04           C
ATOM    132  O   TYR A  38       3.658  34.355  12.914  1.00 -1.22           O
ATOM    133  N   ALA A  39       5.680  33.368  12.879  1.00 -1.26           N
ATOM    134  CA  ALA A  39       6.322  34.523  13.495  1.00 -0.33           C
ATOM    135  C   ALA A  39       6.196  35.741  12.534  1.00 -0.77           C
ATOM    136  O   ALA A  39       5.868  36.832  12.978  1.00  0.43           O
ATOM    137  N   ASN A  40       6.473  35.540  11.269  1.00 -0.25           N
ATOM    138  CA  ASN A  40       6.375  36.639  10.306  1.00  0.62           C
ATOM    139  C   ASN A  40       4.948  37.178  10.237  1.00 -0.63           C
ATOM    140  O   ASN A  40       4.744  38.408  10.195  1.00  0.73           O
ATOM    141  N   ASP A  41       3.959  36.296  10.203  1.00 -1.01           N
ATOM    142  CA  ASP A  41       2.536  36.702  10.145  1.00 -0.75           C
ATOM    143  C   ASP A  41       2.135  37.538  11.355  1.00 -0.27           C
ATOM    144  O   ASP A  41       1.210  38.351  11.240  1.00  3.89           O
ATOM    145  N   ASN A  42       2.798  37.366  12.472  1.00 -1.71           N
ATOM    146  CA  ASN A  42       2.519  38.093  13.718  1.00 -1.05           C
ATOM    147  C   ASN A  42       3.500  39.153  14.001  1.00 -0.84           C
ATOM    148  O   ASN A  42       3.496  39.762  15.071  1.00  1.80           O
ATOM    149  N   GLY A  43       4.380  39.512  13.118  1.00 -0.68           N
ATOM    150  CA  GLY A  43       5.296  40.638  13.264  1.00 -0.09           C
ATOM    151  C   GLY A  43       6.444  40.406  14.185  1.00 -0.46           C
ATOM    152  O   GLY A  43       7.010  41.360  14.689  1.00  3.93           O
ATOM    153  N   VAL A  44       6.830  39.148  14.452  1.00 -0.10           N
ATOM    154  CA  VAL A  44       7.921  38.823  15.338  1.00  0.52           C
ATOM    155  C   VAL A  44       9.187  38.697  14.541  1.00  2.55           C
ATOM    156  O   VAL A  44       9.242  37.875  13.641  1.00  8.31           O
ATOM    157  N   ASP A  45      10.215  39.430  14.941  1.00  1.33           N
ATOM    158  CA  ASP A  45      11.526  39.426  14.290  1.00  3.19           C
ATOM    159  C   ASP A  45      12.590  39.242  15.400  1.00  2.39           C
ATOM    160  O   ASP A  45      13.024  40.161  16.071  1.00  5.21           O
ATOM    161  N   GLY A  46      12.977  38.020  15.568  1.00  2.42           N
ATOM    162  CA  GLY A  46      13.865  37.643  16.623  1.00  2.26           C
ATOM    163  C   GLY A  46      14.903  36.645  16.228  1.00 -0.41           C
ATOM    164  O   GLY A  46      15.180  36.396  15.052  1.00  3.36           O
ATOM    165  N   VAL A  47      15.570  36.098  17.262  1.00 -1.18           N
ATOM    166  CA  VAL A  47      16.614  35.096  17.081  1.00 -1.32           C
ATOM    167  C   VAL A  47      16.094  33.770  17.609  1.00 -2.02           C
ATOM    168  O   VAL A  47      15.264  33.714  18.514  1.00 -0.66           O
ATOM    169  N   TRP A  48      16.607  32.691  17.009  1.00 -2.24           N
ATOM    170  CA  TRP A  48      16.026  31.364  17.129  1.00 -2.13           C
ATOM    171  C   TRP A  48      16.996  30.329  17.636  1.00 -2.80           C
ATOM    172  O   TRP A  48      18.172  30.281  17.232  1.00 -2.00           O
ATOM    173  N   THR A  49      16.488  29.379  18.438  1.00 -1.97           N
ATOM    174  CA  THR A  49      17.146  28.133  18.719  1.00 -2.14           C
ATOM    175  C   THR A  49      16.225  26.967  18.352  1.00 -1.90           C
ATOM    176  O   THR A  49      15.003  27.094  18.322  1.00 -0.77           O
ATOM    177  N   TYR A  50      16.851  25.803  18.146  1.00 -1.29           N
ATOM    178  CA  TYR A  50      16.165  24.543  17.999  1.00 -1.57           C
ATOM    179  C   TYR A  50      16.920  23.500  18.836  1.00 -1.97           C
ATOM    180  O   TYR A  50      18.136  23.407  18.737  1.00 -1.13           O
ATOM    181  N   ASP A  51      16.179  22.734  19.627  1.00 -1.26           N
ATOM    182  CA  ASP A  51      16.716  21.634  20.410  1.00 -1.05           C
ATOM    183  C   ASP A  51      16.100  20.316  19.901  1.00 -1.56           C
ATOM    184  O   ASP A  51      14.901  20.089  20.079  1.00 -0.00           O
ATOM    185  N   ASP A  52      16.901  19.511  19.280  1.00 -0.41           N
ATOM    186  CA  ASP A  52      16.413  18.270  18.691  1.00  0.58           C
ATOM    187  C   ASP A  52      16.029  17.280  19.777  1.00  1.69           C
ATOM    188  O   ASP A  52      15.274  16.349  19.487  1.00  6.79           O
ATOM    189  N   ALA A  53      16.572  17.391  20.979  1.00  1.22           N
ATOM    190  CA  ALA A  53      16.219  16.432  22.049  1.00  3.82           C
ATOM    191  C   ALA A  53      14.808  16.646  22.496  1.00  2.74           C
ATOM    192  O   ALA A  53      14.159  15.682  22.904  1.00 10.40           O
ATOM    193  N   THR A  54      14.305  17.841  22.535  1.00  0.72           N
ATOM    194  CA  THR A  54      12.971  18.177  23.062  1.00  1.09           C
ATOM    195  C   THR A  54      11.998  18.581  21.984  1.00 -0.14           C
ATOM    196  O   THR A  54      10.856  18.904  22.252  1.00  2.59           O
ATOM    197  N   LYS A  55      12.459  18.636  20.724  1.00 -0.87           N
ATOM    198  CA  LYS A  55      11.609  19.022  19.577  1.00 -1.00           C
ATOM    199  C   LYS A  55      11.021  20.391  19.797  1.00 -1.06           C
ATOM    200  O   LYS A  55       9.855  20.639  19.464  1.00  1.55           O
ATOM    201  N   THR A  56      11.822  21.313  20.323  1.00 -1.19           N
ATOM    202  CA  THR A  56      11.365  22.651  20.684  1.00 -1.17           C
ATOM    203  C   THR A  56      12.208  23.723  20.010  1.00 -1.28           C
ATOM    204  O   THR A  56      13.443  23.727  20.120  1.00 -0.50           O
ATOM    205  N   PHE A  57      11.506  24.659  19.368  1.00 -1.32           N
ATOM    206  CA  PHE A  57      12.052  25.886  18.846  1.00 -1.39           C
ATOM    207  C   PHE A  57      11.773  27.014  19.836  1.00 -1.48           C
ATOM    208  O   PHE A  57      10.708  27.005  20.471  1.00 -0.08           O
ATOM    209  N   THR A  58      12.672  27.973  19.913  1.00 -1.33           N
ATOM    210  CA  THR A  58      12.461  29.177  20.755  1.00 -1.37           C
ATOM    211  C   THR A  58      12.794  30.401  19.934  1.00 -1.22           C
ATOM    212  O   THR A  58      13.821  30.406  19.257  1.00  0.75           O
ATOM    213  N   VAL A  59      11.971  31.424  20.012  1.00 -1.18           N
ATOM    214  CA  VAL A  59      12.275  32.720  19.421  1.00 -1.36           C
ATOM    215  C   VAL A  59      12.184  33.794  20.482  1.00 -1.53           C
ATOM    216  O   VAL A  59      11.223  33.845  21.246  1.00  0.21           O
ATOM    217  N   THR A  60      13.188  34.674  20.499  1.00 -1.25           N
ATOM    218  CA  THR A  60      13.202  35.851  21.380  1.00 -1.17           C
ATOM    219  C   THR A  60      13.440  37.095  20.606  1.00 -1.70           C
ATOM    220  O   THR A  60      14.327  37.147  19.737  1.00  0.23           O
ATOM    221  N   GLU A  61      12.727  38.144  20.962  1.00 -0.48           N
ATOM    222  CA  GLU A  61      12.989  39.521  20.535  1.00  0.66           C
ATOM    223  C   GLU A  61      13.742  40.237  21.642  1.00  2.54           C
ATOM    224  O   GLU A  61      14.145  39.578  22.584  1.00  8.39           O
TER
END
"""

def exercise_00(pdb_str, formula):
  """
  CA and main-chain fragments of 2igd.
  """
  pdb_inp = iotbx.pdb.input(source_info=None, lines = pdb_str)
  pdb_hierarchy = pdb_inp.construct_hierarchy()
  asc = pdb_hierarchy.atom_selection_cache()
  cs = pdb_inp.crystal_symmetry_from_cryst1()
  tls_extract = mmtbx.tls.tools.tls_from_pdb_inp(
    remark_3_records = pdb_inp.extract_remark_iii_records(3),
    pdb_hierarchy    = pdb_hierarchy)
  #
  deg_to_rad_scale = math.pi/180
  tls_params_one_group = tls_extract.tls_params[0]
  T = matrix.sym(sym_mat3=tls_params_one_group.t)
  L = matrix.sym(sym_mat3=tls_params_one_group.l)
  S = matrix.sqr(tls_params_one_group.s)
  origin = tls_params_one_group.origin
  tlso = tools.tlso(
    t      = T.as_sym_mat3(),
    l      = L.as_sym_mat3(),
    s      = S,
    origin = origin)
  log = open("analysis.log","w")
  r = analysis.run(T=T, L=L*(deg_to_rad_scale**2), S=S*deg_to_rad_scale,
    log=log, find_t_S_using_formula=formula).self_check(show=False)
  log.close()
  #
  rs = flex.double()
  for trial in range(10):
    o = tools.u_tls_vs_u_ens(pdb_str=pdb_str,
      dx       = r.dx,
      dy       = r.dy,
      dz       = r.dz,
      sx       = r.sx,
      sy       = r.sy,
      sz       = r.sz,
      lx       = r.l_x,
      ly       = r.l_y,
      lz       = r.l_z,
      tx       = r.tx,
      ty       = r.ty,
      tz       = r.tz,
      vx       = r.v_x,
      vy       = r.v_y,
      vz       = r.v_z,
      w_M_lx   = r.w_M_lx,
      w_M_ly   = r.w_M_ly,
      w_M_lz   = r.w_M_lz,
      origin   = origin,
      n_models = 10000,
      assert_similarity=False)
    rs.append(o.r)
  return flex.mean(rs)

if (__name__ == "__main__"):
  t0 = time.time()
  for formula in ["10","11"]:
    print("formula:", formula)
    for i, pdb_str in enumerate([pdb_str_CA, pdb_str_CACON]):
      r = exercise_00(pdb_str=pdb_str, formula=formula)
      print("  ", i, r)
      if(formula=="10"):
        if(i==0): assert r<0.04
        if(i==1): assert r>0.08
      if(formula=="11"):
        if(i==0): assert r<0.02
        if(i==1): assert r<0.02


 *******************************************************************************


 *******************************************************************************
mmtbx/regression/tls/tst_formula_t_S_10_vs_11_4muy.py
from __future__ import absolute_import, division, print_function
from mmtbx.tls import tools
import time
import iotbx.pdb
import mmtbx.tls.tools
from scitbx import matrix
from mmtbx.tls import analysis
import math
from scitbx.array_family import flex
from six.moves import range

pdb_str= """
REMARK   3
REMARK   3   TLS GROUP : 6
REMARK   3    NUMBER OF COMPONENTS GROUP : 1
REMARK   3    COMPONENTS        C SSSEQI   TO  C SSSEQI
REMARK   3    RESIDUE RANGE :   A    65        A    77
REMARK   3    ORIGIN FOR THE GROUP (A):   5.7798  -4.9101  20.8090
REMARK   3    T TENSOR
REMARK   3      T11:   0.1766 T22:   0.1958
REMARK   3      T33:   0.1284 T12:  -0.0119
REMARK   3      T13:  -0.0231 T23:   0.0335
REMARK   3    L TENSOR
REMARK   3      L11:   0.2047 L22:   0.2291
REMARK   3      L33:   0.4446 L12:   0.0057
REMARK   3      L13:   0.2320 L23:   0.2028
REMARK   3    S TENSOR
REMARK   3      S11:   0.0460 S12:   0.0164 S13:  -0.0519
REMARK   3      S21:   0.0242 S22:   0.0228 S23:  -0.0546
REMARK   3      S31:   0.0280 S32:   0.0569 S33:  -0.0688
REMARK   3
CRYST1   70.190   80.460  110.890  90.00  90.00  90.00 P 21 21 21
SCALE1      0.014247  0.000000  0.000000        0.00000
SCALE2      0.000000  0.012429  0.000000        0.00000
SCALE3      0.000000  0.000000  0.009018        0.00000
ATOM      1  N   ASP A  65      14.147  -9.221  30.281  1.00 41.09           N
ANISOU    1  N   ASP A  65     5329   5873   4409   -633  -1875    965       N
ATOM      2  CA  ASP A  65      15.252  -9.249  29.320  1.00 42.10           C
ANISOU    2  CA  ASP A  65     5520   5848   4628   -454  -1645    509       C
ATOM      3  C   ASP A  65      15.235 -10.537  28.501  1.00 40.51           C
ANISOU    3  C   ASP A  65     5402   5699   4291   -472  -2125    624       C
ATOM      4  O   ASP A  65      14.791 -11.574  28.982  1.00 39.28           O
ANISOU    4  O   ASP A  65     5521   5937   3467   -466  -2793    943       O
ATOM      5  CB  ASP A  65      16.599  -9.117  30.052  1.00 44.12           C
ANISOU    5  CB  ASP A  65     5578   6377   4807   -323  -1759    465       C
ATOM      6  CG  ASP A  65      16.805  -7.734  30.675  1.00 47.85           C
ANISOU    6  CG  ASP A  65     6211   6644   5326   -533  -1632    224       C
ATOM      7  OD1 ASP A  65      16.037  -6.794  30.359  1.00 51.97           O
ANISOU    7  OD1 ASP A  65     6898   6544   6303    -15   -411    599       O
ATOM      8  OD2 ASP A  65      17.748  -7.584  31.482  1.00 51.60           O
ANISOU    8  OD2 ASP A  65     6250   7759   5593   -575  -1695   -226       O
ATOM      9  N   GLY A  66      15.695 -10.453  27.254  1.00 43.04           N
ANISOU    9  N   GLY A  66     5541   6021   4789   -564  -1568    173       N
ATOM     10  CA  GLY A  66      15.771 -11.614  26.358  1.00 42.81           C
ANISOU   10  CA  GLY A  66     5506   6041   4718   -265  -1800    137       C
ATOM     11  C   GLY A  66      14.469 -11.953  25.645  1.00 42.08           C
ANISOU   11  C   GLY A  66     5383   5987   4617   -209  -1639     57       C
ATOM     12  O   GLY A  66      14.459 -12.761  24.719  1.00 44.05           O
ANISOU   12  O   GLY A  66     5670   6379   4687   -247  -2191   -161       O
ATOM     13  N   ALA A  67      13.374 -11.318  26.052  1.00 39.31           N
ANISOU   13  N   ALA A  67     5011   5498   4427   -513  -1743    269       N
ATOM     14  CA  ALA A  67      12.035 -11.711  25.610  1.00 34.72           C
ANISOU   14  CA  ALA A  67     4873   4883   3435   -220  -1759    605       C
ATOM     15  C   ALA A  67      11.747 -11.272  24.182  1.00 34.65           C
ANISOU   15  C   ALA A  67     4719   5070   3375   -468  -1676    626       C
ATOM     16  O   ALA A  67      12.465 -10.435  23.611  1.00 33.02           O
ANISOU   16  O   ALA A  67     4398   5086   3060   -343  -2075    876       O
ATOM     17  CB  ALA A  67      10.980 -11.142  26.553  1.00 32.29           C
ANISOU   17  CB  ALA A  67     4476   4659   3132   -444  -1922    573       C
ATOM     18  N   ILE A  68      10.695 -11.864  23.612  1.00 33.06           N
ANISOU   18  N   ILE A  68     4600   4702   3256   -324  -1651    731       N
ATOM     19  CA  ILE A  68      10.159 -11.446  22.326  1.00 31.69           C
ANISOU   19  CA  ILE A  68     4462   4593   2985   -258  -1327    634       C
ATOM     20  C   ILE A  68       8.993 -10.516  22.600  1.00 28.77           C
ANISOU   20  C   ILE A  68     4017   4426   2485   -420  -1554    771       C
ATOM     21  O   ILE A  68       8.102 -10.863  23.367  1.00 29.09           O
ANISOU   21  O   ILE A  68     3969   4498   2585   -247  -1612    861       O
ATOM     22  CB  ILE A  68       9.711 -12.658  21.487  1.00 33.33           C
ANISOU   22  CB  ILE A  68     4545   4700   3419   -415  -1435    543       C
ATOM     23  CG1 ILE A  68      10.950 -13.475  21.091  1.00 33.58           C
ANISOU   23  CG1 ILE A  68     4108   5209   3440   -686  -2083    -48       C
ATOM     24  CG2 ILE A  68       8.940 -12.220  20.244  1.00 33.93           C
ANISOU   24  CG2 ILE A  68     4626   4880   3386   -228  -1345    557       C
ATOM     25  CD1 ILE A  68      10.723 -14.965  21.116  1.00 35.38           C
ANISOU   25  CD1 ILE A  68     4273   5208   3961   -444  -2399   -116       C
ATOM     26  N   LEU A  69       9.020  -9.336  21.977  1.00 27.70           N
ANISOU   26  N   LEU A  69     3666   4241   2616   -537  -1183    594       N
ATOM     27  CA  LEU A  69       7.993  -8.311  22.153  1.00 25.86           C
ANISOU   27  CA  LEU A  69     3574   4169   2081   -532  -1071    868       C
ATOM     28  C   LEU A  69       7.413  -8.016  20.799  1.00 25.13           C
ANISOU   28  C   LEU A  69     3441   4069   2036   -439  -1021    734       C
ATOM     29  O   LEU A  69       8.156  -7.877  19.831  1.00 26.34           O
ANISOU   29  O   LEU A  69     3552   4318   2137   -465   -987   1038       O
ATOM     30  CB  LEU A  69       8.613  -7.021  22.657  1.00 27.46           C
ANISOU   30  CB  LEU A  69     3857   4296   2280   -543   -940    640       C
ATOM     31  CG  LEU A  69       7.850  -6.047  23.563  1.00 28.66           C
ANISOU   31  CG  LEU A  69     4059   4448   2381   -330   -907    634       C
ATOM     32  CD1 LEU A  69       8.040  -4.642  23.035  1.00 30.10           C
ANISOU   32  CD1 LEU A  69     4062   4597   2774   -143   -556    890       C
ATOM     33  CD2 LEU A  69       6.379  -6.345  23.802  1.00 27.33           C
ANISOU   33  CD2 LEU A  69     3995   4289   2097   -164  -1171    609       C
ATOM     34  N   ILE A  70       6.097  -7.893  20.738  1.00 24.58           N
ANISOU   34  N   ILE A  70     3388   4002   1947   -615   -905    886       N
ATOM     35  CA  ILE A  70       5.415  -7.521  19.506  1.00 22.86           C
ANISOU   35  CA  ILE A  70     3182   3660   1841   -534   -756    774       C
ATOM     36  C   ILE A  70       4.678  -6.222  19.803  1.00 22.24           C
ANISOU   36  C   ILE A  70     3080   3605   1762   -608   -710    693       C
ATOM     37  O   ILE A  70       3.979  -6.128  20.805  1.00 23.02           O
ANISOU   37  O   ILE A  70     3306   3725   1714   -573   -615    824       O
ATOM     38  CB  ILE A  70       4.422  -8.609  19.076  1.00 22.84           C
ANISOU   38  CB  ILE A  70     3207   3610   1862   -508   -784    792       C
ATOM     39  CG1 ILE A  70       5.161  -9.951  18.912  1.00 23.90           C
ANISOU   39  CG1 ILE A  70     3382   3677   2020   -472   -958    841       C
ATOM     40  CG2 ILE A  70       3.706  -8.190  17.801  1.00 22.46           C
ANISOU   40  CG2 ILE A  70     3286   3414   1832   -387   -736    764       C
ATOM     41  CD1 ILE A  70       4.279 -11.135  18.629  1.00 24.53           C
ANISOU   41  CD1 ILE A  70     3665   3599   2056   -465  -1065    836       C
ATOM     42  N   PHE A  71       4.860  -5.208  18.973  1.00 21.59           N
ANISOU   42  N   PHE A  71     3035   3501   1667   -533   -584    589       N
ATOM     43  CA  PHE A  71       4.050  -3.990  19.088  1.00 21.28           C
ANISOU   43  CA  PHE A  71     2952   3507   1624   -540   -545    564       C
ATOM     44  C   PHE A  71       2.699  -4.237  18.451  1.00 21.01           C
ANISOU   44  C   PHE A  71     2922   3406   1654   -432   -574    613       C
ATOM     45  O   PHE A  71       2.629  -4.859  17.388  1.00 20.73           O
ANISOU   45  O   PHE A  71     2910   3342   1624   -180   -454    644       O
ATOM     46  CB  PHE A  71       4.686  -2.798  18.386  1.00 21.03           C
ANISOU   46  CB  PHE A  71     2929   3405   1654   -406   -537    615       C
ATOM     47  CG  PHE A  71       6.072  -2.463  18.847  1.00 21.48           C
ANISOU   47  CG  PHE A  71     2935   3594   1629   -484   -470    627       C
ATOM     48  CD1 PHE A  71       6.392  -2.412  20.202  1.00 21.38           C
ANISOU   48  CD1 PHE A  71     2856   3630   1635   -537   -462    666       C
ATOM     49  CD2 PHE A  71       7.055  -2.167  17.930  1.00 21.64           C
ANISOU   49  CD2 PHE A  71     2901   3553   1766   -462   -479    813       C
ATOM     50  CE1 PHE A  71       7.668  -2.084  20.609  1.00 21.79           C
ANISOU   50  CE1 PHE A  71     2851   3665   1763   -604   -328    661       C
ATOM     51  CE2 PHE A  71       8.334  -1.823  18.329  1.00 22.27           C
ANISOU   51  CE2 PHE A  71     2976   3735   1750   -509   -523    728       C
ATOM     52  CZ  PHE A  71       8.647  -1.798  19.675  1.00 21.40           C
ANISOU   52  CZ  PHE A  71     2754   3687   1689   -412   -381    695       C
ATOM     53  N   SER A  72       1.633  -3.709  19.049  1.00 20.51           N
ANISOU   53  N   SER A  72     2877   3406   1506   -663   -396    573       N
ATOM     54  CA  SER A  72       0.286  -3.952  18.532  1.00 20.43           C
ANISOU   54  CA  SER A  72     2885   3288   1590   -494   -528    655       C
ATOM     55  C   SER A  72       0.022  -3.221  17.213  1.00 20.34           C
ANISOU   55  C   SER A  72     2949   3214   1563   -483   -511    618       C
ATOM     56  O   SER A  72       0.781  -2.352  16.810  1.00 19.70           O
ANISOU   56  O   SER A  72     2751   3296   1435   -422   -264    418       O
ATOM     57  CB  SER A  72      -0.781  -3.534  19.540  1.00 20.57           C
ANISOU   57  CB  SER A  72     2835   3406   1571   -642   -526    686       C
ATOM     58  OG  SER A  72      -0.997  -2.142  19.497  1.00 20.81           O
ANISOU   58  OG  SER A  72     2841   3421   1642   -600   -568    401       O
ATOM     59  N   ALA A  73      -1.106  -3.558  16.591  1.00 20.66           N
ANISOU   59  N   ALA A  73     3019   3240   1590   -496   -570    636       N
ATOM     60  CA  ALA A  73      -1.494  -3.007  15.297  1.00 20.78           C
ANISOU   60  CA  ALA A  73     3052   3312   1531   -448   -482    632       C
ATOM     61  C   ALA A  73      -1.626  -1.490  15.347  1.00 20.78           C
ANISOU   61  C   ALA A  73     3069   3352   1471   -345   -372    612       C
ATOM     62  O   ALA A  73      -1.458  -0.821  14.356  1.00 19.73           O
ANISOU   62  O   ALA A  73     2880   3148   1466   -287   -376    550       O
ATOM     63  CB  ALA A  73      -2.806  -3.638  14.814  1.00 20.21           C
ANISOU   63  CB  ALA A  73     3001   3095   1581   -346   -502    688       C
ATOM     64  N   HIS A  74      -1.886  -0.956  16.539  1.00 20.28           N
ANISOU   64  N   HIS A  74     2845   3313   1546   -227   -507    527       N
ATOM     65  CA  HIS A  74      -2.151   0.462  16.721  1.00 19.54           C
ANISOU   65  CA  HIS A  74     2627   3313   1483   -230   -398    516       C
ATOM     66  C   HIS A  74      -0.912   1.311  16.604  1.00 20.14           C
ANISOU   66  C   HIS A  74     2915   3371   1366   -422   -203    470       C
ATOM     67  O   HIS A  74      -1.040   2.504  16.391  1.00 20.61           O
ANISOU   67  O   HIS A  74     3071   3383   1374   -333   -275    486       O
ATOM     68  CB  HIS A  74      -2.819   0.697  18.100  1.00 19.53           C
ANISOU   68  CB  HIS A  74     2576   3370   1474   -350   -395    536       C
ATOM     69  CG  HIS A  74      -3.892  -0.291  18.378  1.00 20.17           C
ANISOU   69  CG  HIS A  74     2778   3481   1402   -502   -335    465       C
ATOM     70  ND1 HIS A  74      -3.648  -1.473  19.035  1.00 20.32           N
ANISOU   70  ND1 HIS A  74     2804   3504   1412   -589   -338    501       N
ATOM     71  CD2 HIS A  74      -5.167  -0.364  17.933  1.00 20.96           C
ANISOU   71  CD2 HIS A  74     2842   3608   1513   -472   -453    616       C
ATOM     72  CE1 HIS A  74      -4.753  -2.193  19.063  1.00 20.52           C
ANISOU   72  CE1 HIS A  74     2829   3533   1432   -616   -376    493       C
ATOM     73  NE2 HIS A  74      -5.686  -1.541  18.398  1.00 21.01           N
ANISOU   73  NE2 HIS A  74     2823   3553   1607   -639   -538    401       N
ATOM     74  N   GLY A  75       0.272   0.715  16.755  1.00 19.61           N
ANISOU   74  N   GLY A  75     2921   3134   1395   -466   -239    494       N
ATOM     75  CA  GLY A  75       1.529   1.447  16.690  1.00 19.84           C
ANISOU   75  CA  GLY A  75     2854   3233   1449   -434   -313    568       C
ATOM     76  C   GLY A  75       2.053   1.917  18.043  1.00 20.08           C
ANISOU   76  C   GLY A  75     2817   3329   1483   -566   -371    623       C
ATOM     77  O   GLY A  75       1.343   1.866  19.044  1.00 20.58           O
ANISOU   77  O   GLY A  75     2776   3576   1468   -608   -380    598       O
ATOM     78  N   VAL A  76       3.283   2.420  18.046  1.00 20.15           N
ANISOU   78  N   VAL A  76     2801   3358   1497   -543   -361    612       N
ATOM     79  CA  VAL A  76       3.920   2.883  19.288  1.00 20.26           C
ANISOU   79  CA  VAL A  76     2836   3378   1483   -616   -338    616       C
ATOM     80  C   VAL A  76       4.742   4.126  19.020  1.00 20.38           C
ANISOU   80  C   VAL A  76     2724   3525   1491   -675   -311    640       C
ATOM     81  O   VAL A  76       5.161   4.379  17.886  1.00 19.93           O
ANISOU   81  O   VAL A  76     2697   3305   1567   -666   -306    759       O
ATOM     82  CB  VAL A  76       4.819   1.795  19.881  1.00 20.01           C
ANISOU   82  CB  VAL A  76     2771   3329   1500   -616   -357    499       C
ATOM     83  CG1 VAL A  76       3.984   0.589  20.254  1.00 19.79           C
ANISOU   83  CG1 VAL A  76     2688   3366   1464   -624   -298    445       C
ATOM     84  CG2 VAL A  76       5.928   1.389  18.912  1.00 20.07           C
ANISOU   84  CG2 VAL A  76     2741   3346   1537   -552   -350    559       C
ATOM     85  N   SER A  77       4.954   4.909  20.069  1.00 20.67           N
ANISOU   85  N   SER A  77     2833   3545   1475   -699   -282    650       N
ATOM     86  CA  SER A  77       5.808   6.071  19.998  1.00 21.19           C
ANISOU   86  CA  SER A  77     3018   3514   1519   -731   -326    708       C
ATOM     87  C   SER A  77       7.265   5.677  19.776  1.00 21.98           C
ANISOU   87  C   SER A  77     2962   3688   1701   -726   -450    738       C
ATOM     88  O   SER A  77       7.671   4.545  20.040  1.00 21.51           O
ANISOU   88  O   SER A  77     2983   3649   1538   -724   -225    670       O
ATOM     89  CB  SER A  77       5.716   6.869  21.283  1.00 20.97           C
ANISOU   89  CB  SER A  77     2887   3496   1582   -716   -450    654       C
ATOM     90  OG  SER A  77       6.230   6.070  22.318  1.00 20.53           O
ANISOU   90  OG  SER A  77     2828   3335   1636   -702   -509    561       O
TER
END
"""

def exercise_00(pdb_str, formula):
  """
  TLS group 6 of 4muy.
  """
  pdb_inp = iotbx.pdb.input(source_info=None, lines = pdb_str)
  pdb_hierarchy = pdb_inp.construct_hierarchy()
  asc = pdb_hierarchy.atom_selection_cache()
  cs = pdb_inp.crystal_symmetry_from_cryst1()
  tls_extract = mmtbx.tls.tools.tls_from_pdb_inp(
    remark_3_records = pdb_inp.extract_remark_iii_records(3),
    pdb_hierarchy    = pdb_hierarchy)
  #
  deg_to_rad_scale = math.pi/180
  tls_params_one_group = tls_extract.tls_params[0]
  T = matrix.sym(sym_mat3=tls_params_one_group.t)
  L = matrix.sym(sym_mat3=tls_params_one_group.l)
  S = matrix.sqr(tls_params_one_group.s)
  origin = tls_params_one_group.origin
  tlso = tools.tlso(
    t      = T.as_sym_mat3(),
    l      = L.as_sym_mat3(),
    s      = S,
    origin = origin)
  log = open("analysis.log","w")
  r = analysis.run(T=T, L=L*(deg_to_rad_scale**2), S=S*deg_to_rad_scale,
    log=log, find_t_S_using_formula=formula).self_check(show=False)
  log.close()
  #
  rs = flex.double()
  for trial in range(10):
    o = tools.u_tls_vs_u_ens(pdb_str=pdb_str,
      dx       = r.dx,
      dy       = r.dy,
      dz       = r.dz,
      sx       = r.sx,
      sy       = r.sy,
      sz       = r.sz,
      lx       = r.l_x,
      ly       = r.l_y,
      lz       = r.l_z,
      tx       = r.tx,
      ty       = r.ty,
      tz       = r.tz,
      vx       = r.v_x,
      vy       = r.v_y,
      vz       = r.v_z,
      w_M_lx   = r.w_M_lx,
      w_M_ly   = r.w_M_ly,
      w_M_lz   = r.w_M_lz,
      origin   = origin,
      n_models = 10000,
      assert_similarity=False)
    rs.append(o.r)
  return flex.mean(rs)

if (__name__ == "__main__"):
  t0 = time.time()
  for formula in ["10","11"]:
    print("formula:", formula)
    r = exercise_00(pdb_str=pdb_str, formula=formula)
    print("  ", r)
    if(formula=="10"): assert r>0.55
    if(formula=="11"): assert r<0.06


 *******************************************************************************


 *******************************************************************************
mmtbx/regression/tls/tst_get_t_scheme.py
from __future__ import absolute_import, division, print_function
from cctbx.array_family import flex
import math, sys, random
from libtbx.test_utils import approx_equal
from libtbx.utils import format_cpu_times
import random, copy
from cctbx import sgtbx
from cctbx import adptbx
from cctbx.development import random_structure
import scitbx.math

from mmtbx.tls import tools
from mmtbx_tls_ext import *
from six.moves import range

if (1): # fixed random seed to avoid rare failures
  random.seed(0)
  flex.set_random_seed(0)

def branch_3_mn():
  m = None
  n = None
  small = 1.e-15
  for i in range(10000):
      m2=[]
      n2=[]
      for i in range(4):
          r1 = random.random()
          r2 = random.random()
          r3 = random.random()
          if(r3 > 0.1):
             r1 = r2
          m2.append(r1)
          n2.append(r2)
      p1 = 0.5 * (m2[0]+m2[3] + math.sqrt(4*m2[1]*m2[2]+(m2[0]-m2[3])**2))
      p2 = 0.5 * (m2[0]+m2[3] - math.sqrt(4*m2[1]*m2[2]+(m2[0]-m2[3])**2))
      q1 = 0.5 * (n2[0]+m2[3] + math.sqrt(4*n2[1]*n2[2]+(n2[0]-n2[3])**2))
      q2 = 0.5 * (n2[0]+m2[3] - math.sqrt(4*n2[1]*n2[2]+(n2[0]-n2[3])**2))
      if(min(p1,p2) > 0.0 and min(q1,q2) > 0.0):
          r = random.random()
          if(r > 0.5):
             r1 = r3
             r2 = r2
          m = [m2[0],m2[3],r1,m2[1],0,0]
          n = [n2[0],n2[3],r2,n2[1],0,0]
          if([adptbx.is_positive_definite(m),
              adptbx.is_positive_definite(n)].count(True)==2):
              esm = adptbx.eigensystem(m)
              esn = adptbx.eigensystem(n)
              vn = esn.values()
              vm = esm.values()
              mmin = flex.min(flex.double(vm))
              nmin = flex.min(flex.double(vn))
              if(abs(abs(mmin) - abs(nmin)) < small and mmin> 0. and nmin> 0.):
                  for i, v in enumerate(vn):
                      if(abs(abs(nmin) - v) < small): break
                  for j, v in enumerate(vm):
                      if(abs(abs(mmin) - v) < small): break
                  vecn = flex.double(esn.vectors(i))
                  vecm = flex.double(esm.vectors(j))
                  if(flex.mean(vecm-vecn) < small): break
              else:
                m = None
                n = None
  assert [m,n] != [None,None]
  assert [adptbx.is_positive_definite(m),
          adptbx.is_positive_definite(n)].count(True)==2
  r = random.random()
  if(r > 0.5):
     m = adptbx.random_rotate_ellipsoid(u_cart = m)
     n = adptbx.random_rotate_ellipsoid(u_cart = n)
  return m,n

def branch_2_mn(small):
  m=[]
  n=[]
  while (len(n)==0 or len(m)==0):
    r1 = random.random()
    r2 = random.random()
    r3 = random.random()
    if(r1 >= r2 and r2 >= r3 and r3>  0.0):
       r = random.random()
       if(r > 0.5):
          m = [r1,r2,r3,0,0,0]
       else:
          m = [r1,r1,r1,0,0,0]
       assert adptbx.is_positive_definite(m,small)
    if(r1 >= r2 and r2 >= r3 and r3 >  0.0):
       r = random.random()
       if(r > 0.5):
          n = [r1,r3,r2,0,0,0]
       else:
          n = [r1,r1,r1,0,0,0]
       assert adptbx.is_positive_definite(n,small)
  r = random.random()
  if(r > 0.5):
     m = adptbx.random_rotate_ellipsoid(u_cart = m)
     n = adptbx.random_rotate_ellipsoid(u_cart = n)
  return m,n

def zero_mat(x):
  for i_seq, v in enumerate(x):
    if(abs(v) < 1.e-4): x[i_seq]=0.0
  return x

def factor(x, i):
  if(i < 50000): scale = 0.01
  else: scale = 10.0
  for i_seq, v in enumerate(x):
    x[i_seq]=v*scale
  return x

def exercise_branch_2_1(small = 1.e-9):
  m = [2,1,2,0,0,0]
  n = [2,1,1,0,0,0]
  counter = 0
  trials = 100000
  i = 0
  branch_0       = 0
  branch_1       = 0
  branch_1_1     = 0
  branch_1_2     = 0
  branch_1_2_1   = 0
  branch_1_2_2   = 0
  branch_1_2_3   = 0
  branch_1_2_3_1 = 0
  branch_1_2_3_2 = 0
  while i < trials:
      i += 1
      m = [2,1,2,0,0,0]
      n = [2,1,1,0,0,0]
      counter += 1
      c = scitbx.math.euler_angles_as_matrix(
                    [random.uniform(0,360) for j in range(3)], deg=True).elems
      r = random.random()
      if(r<0.25):
         m = adptbx.c_u_c_transpose(c, m)
         n = adptbx.c_u_c_transpose(c, n)
      elif(r>=0.25 and r < 0.5):
         m = adptbx.c_u_c_transpose(c, m)
      elif(r>=0.5 and r < 0.75):
         n = adptbx.c_u_c_transpose(c, n)
      else:
         r = random.random()
         run_away = 1000
         while run_away > 0:
            run_away -= 1
            r = random.random()
            if(r<0.33):
               m = adptbx.c_u_c_transpose(c, m)
               n = adptbx.c_u_c_transpose(c, n)
            elif(r>=0.33 and r < 0.66):
               m = adptbx.c_u_c_transpose(c, m)
            else:
               n = adptbx.c_u_c_transpose(c, n)
            m = adptbx.c_u_c_transpose(c, m)
            n = adptbx.c_u_c_transpose(c, n)
            m = [m[0],m[1],m[2],m[3]*random.choice((0,1)),m[4]*random.choice((0,1)),m[5]*random.choice((0,1))]
            n = [n[0],n[1],n[2],n[3]*random.choice((0,1)),n[4]*random.choice((0,1)),n[5]*random.choice((0,1))]
            m = factor(list(m), i)
            n = factor(list(n), i)
            if(adptbx.is_positive_definite(m,small) and
               adptbx.is_positive_definite(n,small)): break


      m_dc = copy.deepcopy(m)
      n_dc = copy.deepcopy(n)
      qq = tools.common(n,m,small)
      #assert approx_equal(m,m_dc)
      #assert approx_equal(n,n_dc)

      if(qq.branch_0()      ):   branch_0       += 1
      if(qq.branch_1()      ):   branch_1       += 1
      if(qq.branch_1_1()    ):   branch_1_1     += 1
      if(qq.branch_1_2()    ):   branch_1_2     += 1
      if(qq.branch_1_2_1()  ):   branch_1_2_1   += 1
      if(qq.branch_1_2_2()  ):   branch_1_2_2   += 1
      if(qq.branch_1_2_3()  ):   branch_1_2_3   += 1
      if(qq.branch_1_2_3_1()):   branch_1_2_3_1 += 1
      if(qq.branch_1_2_3_2()):   branch_1_2_3_2 += 1

      if (counter >= 10000):
         counter = 0
         print("."*30)
         print("i= ", i, "out of ", trials)
         print("branch_0       = ", branch_0)
         print("branch_1       = ", branch_1)
         print("branch_1_1     = ", branch_1_1)
         print("branch_1_2     = ", branch_1_2)
         print("branch_1_2_1   = ", branch_1_2_1)
         print("branch_1_2_2   = ", branch_1_2_2)
         print("branch_1_2_3   = ", branch_1_2_3)
         print("branch_1_2_3_1 = ", branch_1_2_3_1)
         print("branch_1_2_3_2 = ", branch_1_2_3_2)
         sys.stdout.flush()


def exercise_2(small = 1.e-9):
  m = [2,1,2,0,0,0]
  n = [2,2,1,0,0,0]
  m_dc = copy.deepcopy(m)
  n_dc = copy.deepcopy(n)
  qq = tools.common(n,m,small)
  assert approx_equal(m,m_dc)
  assert approx_equal(n,n_dc)
  assert qq.t() == (2.0, 1.0, 1.0, 0.0, 0.0, 0.0)


def exercise(small = 1.e-9):
  for symbol in ["P 1"]:
      space_group_info = sgtbx.space_group_info(symbol = symbol)
      random_xray_structure = random_structure.xray_structure(
                                       space_group_info  = space_group_info,
                                       elements          = ["N"]*10,
                                       volume_per_atom   = 50.0,
                                       random_u_iso      = False,
                                       u_iso             = adptbx.b_as_u(20.0))
      sg = random_xray_structure.space_group()
      uc = random_xray_structure.unit_cell()
      print(symbol, uc)
      print()
      sys.stdout.flush()
      counter = 0
      trials = 100000
      i = 0
      branch_0       = 0
      branch_1       = 0
      branch_1_1     = 0
      branch_1_2     = 0
      branch_1_2_1   = 0
      branch_1_2_2   = 0
      branch_1_2_3   = 0
      branch_1_2_3_1 = 0
      branch_1_2_3_2 = 0

      while i < trials:
          i += 1
          counter += 1
          r = random.random()
          if(r < 0.333):
             m = adptbx.random_u_cart(u_scale=20.*random.random(), u_min=0)
             n = adptbx.random_u_cart(u_scale=20.*random.random(), u_min=0)
             while 1:
               for ind in range(6):
                   r = random.random()
                   m = flex.double(m)
                   if(r > 0.5):
                      m[ind] = n[ind]
               m = list(m)
               if(adptbx.is_positive_definite(m,0) and
                  adptbx.is_positive_definite(n,0)): break
          elif(r>=0.333 and r<0.66):
             m,n = branch_3_mn()
          else:
             m,n = branch_2_mn(0)
          m_dc = copy.deepcopy(m)
          n_dc = copy.deepcopy(n)
          m = factor(list(m), i)
          n = factor(list(n), i)
          qq = tools.common(n,m,small)
          #assert approx_equal(m,m_dc)
          #assert approx_equal(n,n_dc)

          if(qq.branch_0()      ):   branch_0       += 1
          if(qq.branch_1()      ):   branch_1       += 1
          if(qq.branch_1_1()    ):   branch_1_1     += 1
          if(qq.branch_1_2()    ):   branch_1_2     += 1
          if(qq.branch_1_2_1()  ):   branch_1_2_1   += 1
          if(qq.branch_1_2_2()  ):   branch_1_2_2   += 1
          if(qq.branch_1_2_3()  ):   branch_1_2_3   += 1
          if(qq.branch_1_2_3_1()):   branch_1_2_3_1 += 1
          if(qq.branch_1_2_3_2()):   branch_1_2_3_2 += 1


          if (counter >= 10000):
             counter = 0
             print("."*30, symbol)
             print("i= ", i, "out of ", trials)
             print("branch_0       = ", branch_0)
             print("branch_1       = ", branch_1)
             print("branch_1_1     = ", branch_1_1)
             print("branch_1_2     = ", branch_1_2)
             print("branch_1_2_1   = ", branch_1_2_1)
             print("branch_1_2_2   = ", branch_1_2_2)
             print("branch_1_2_3   = ", branch_1_2_3)
             print("branch_1_2_3_1 = ", branch_1_2_3_1)
             print("branch_1_2_3_2 = ", branch_1_2_3_2)
             sys.stdout.flush()

def exercise_x1():
  u_iso = flex.double([1.0,2.0,3.0,4.0,5.0])
  t = tools.t_from_u_cart(u_iso, 1.e-9)
  assert t == (1.0, 1.0, 1.0, 0.0, 0.0, 0.0)
  u_iso = flex.double([7.0,2.0,3.0,9.0,5.0])
  t = tools.t_from_u_cart(u_iso, 1.e-9)
  assert t == (2.0, 2.0, 2.0, 0.0, 0.0, 0.0)

def run():
  exercise_x1()
  exercise()
  exercise_branch_2_1()
  exercise_2()
  print("OK: ",format_cpu_times())

if (__name__ == "__main__"):
  run()


 *******************************************************************************


 *******************************************************************************
mmtbx/regression/tls/tst_tls.py
from __future__ import absolute_import, division, print_function
from mmtbx.tls import tools
from mmtbx import monomer_library
import mmtbx.monomer_library.server
import mmtbx.monomer_library.pdb_interpretation
import iotbx.pdb.remark_3_interpretation
from libtbx.test_utils import approx_equal
from libtbx.utils import format_cpu_times
import libtbx.load_env
import os
from six.moves import zip

params = monomer_library.pdb_interpretation.master_params.extract()
params.flip_symmetric_amino_acids = False

def uaniso_from_tls_and_back():
  mon_lib_srv = monomer_library.server.server()
  ener_lib = monomer_library.server.ener_lib()
  pdb_file = libtbx.env.find_in_repositories(
    relative_path="phenix_regression/pdb/1OC2_tst.pdb",
    test=os.path.isfile)
  processed_pdb_file = monomer_library.pdb_interpretation.process(
                                       mon_lib_srv               = mon_lib_srv,
                                       ener_lib                  = ener_lib,
                                       params = params,
                                       file_name                 = pdb_file,
                                       raw_records               = None,
                                       force_symmetry            = True)
  xray_structure = processed_pdb_file.xray_structure()
  selections = []
  for string in ["chain A", "chain B"]:
      selections.append(processed_pdb_file.all_chain_proxies.selection(
                                                              string = string))
  input_tls_data = iotbx.pdb.remark_3_interpretation.extract_tls_parameters(
    remark_3_records=processed_pdb_file.all_chain_proxies.pdb_inp
      .extract_remark_iii_records(iii=3),
    pdb_hierarchy = processed_pdb_file.all_chain_proxies.pdb_hierarchy,
    chain_ids=[]).tls_params
  tls_params = []
  for item in input_tls_data:
      tls_params.append(tools.tlso(t      = item.t,
                                   l      = item.l,
                                   s      = item.s,
                                   origin = item.origin))
  tools.show_tls(tlsos = tls_params)
  u_cart_from_tls = tools.u_cart_from_tls(
                        sites_cart = xray_structure.sites_cart(),
                        selections = selections,
                        tlsos      = tls_params)

  i = 0
  for utls,atom in zip(u_cart_from_tls,
                       processed_pdb_file.all_chain_proxies.pdb_atoms):
    updb = atom.uij
    #i += 1
    #print "      ", i
    #print "%6.4f %6.4f %6.4f %6.4f %6.4f %6.4f "% \
    #                         (utls[0],utls[1],utls[2],utls[3],utls[4],utls[5])
    #print "%6.4f %6.4f %6.4f %6.4f %6.4f %6.4f "% \
    #                         (updb[0],updb[1],updb[2],updb[3],updb[4],updb[5])
    assert approx_equal(utls,updb, 1.e-4)

  tlsos_initial = []
  for input_tls_data_ in input_tls_data:
      tlsos_initial.append(tools.tlso(
                                   t = ([0.0,0.0,0.0,0.0,0.0,0.0]),
                                   l = ([0.0,0.0,0.0,0.0,0.0,0.0]),
                                   s = ([0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0]),
                                   origin = input_tls_data_.origin))
  tls_from_uanisos = tools.tls_from_uanisos(
    number_of_macro_cycles       = 300,
    max_iterations               = 1000,
    xray_structure = xray_structure,
    selections     = selections,
    tlsos_initial  = tlsos_initial)
  print("\nTLS from Uaniso:\n")
  tools.show_tls(tlsos = tls_from_uanisos)

  for input_tls_data_,tls_from_uanisos_ in zip(tls_params,tls_from_uanisos):
    assert approx_equal(input_tls_data_.t,      tls_from_uanisos_.t, 1.e-4)
    assert approx_equal(input_tls_data_.l,      tls_from_uanisos_.l, 1.e-4)
    assert approx_equal(input_tls_data_.s,      tls_from_uanisos_.s, 1.e-4)
    assert approx_equal(input_tls_data_.origin, tls_from_uanisos_.origin, 1.e-3)
  #
  print(format_cpu_times())

if (__name__ == "__main__"):
  uaniso_from_tls_and_back()


 *******************************************************************************


 *******************************************************************************
mmtbx/regression/tls/tst_tls_analysis.py
from __future__ import absolute_import, division, print_function
from mmtbx.tls import analysis
import os
import libtbx.load_env
from scitbx import matrix
from libtbx.test_utils import approx_equal

def extract(file_name):
  of = open(file_name, "r")
  start  = False
  start_T=False
  start_L=False
  start_S=False
  T=[]
  L=[]
  S=[]
  for l in of.readlines():
    l=l.strip()
    if(l.count("TLS BUILT FROM THE BASE ELEMENTS")):
      start=True
    if(start):
      if(l.startswith("matrix T")):
        start_T=True
      if(l.startswith("matrix L")):
        start_L=True
      if(l.startswith("matrix S")):
        start_S=True
    if(start_T and len(l.split())==3):
      if(len(T)<3): T.append(l)
      else:         start_T=False
    if(start_L and len(l.split())==3):
      if(len(L)<3): L.append(l)
      else:         start_L=False
    if(start_S and len(l.split())==3):
      if(len(S)<3): S.append(l)
      else:         start_S=False
  of.close()
  def convert(m):
    return matrix.sqr([
      float(m[0].split()[0]), float(m[0].split()[1]), float(m[0].split()[2]),
      float(m[1].split()[0]), float(m[1].split()[1]), float(m[1].split()[2]),
      float(m[2].split()[0]), float(m[2].split()[1]), float(m[2].split()[2])
    ])
  T = convert(T)
  L = convert(L)
  S = convert(S)
  return T, L, S

files = [
  "dec04_test000.mes",
  "dec04_test001.mes",
  "dec04_test002.mes",
  "dec04_test003.mes",
  "dec04_test004.mes",
  "dec04_test005.mes",
  "dec04_test012.mes",
  "dec04_test013.mes",
  "dec04_test014.mes",
  "dec04_test015.mes",
  "dec04_test021.mes",
  "dec04_test022.mes",
  "dec04_test023.mes",
  "dec04_test024.mes",
  "dec04_test033.mes",
  "dec04_test034.mes",
  "dec04_test035.mes",
  "dec04_test044.mes",
  "dec04_test113.mes",
  "dec04_test114.mes",
  "dec04_test115.mes",
  "dec04_test144.mes",
  "dec04_test145.mes",
  "dec04_test146.mes",
  "dec04_test147.mes",
  "dec04_test148.mes",
  "dec04_test149.mes",
  "dec04_test159.mes",

  "dec04_test168.mes",
  "dec04_test169.mes",
  "dec04_test215.mes"
]

def run():
  for fn in files:
    try:
      fn_ = libtbx.env.find_in_repositories(
        relative_path="mmtbx/regression/tls/data_tls_analysis/%s"%fn,
        test=os.path.isfile)
      of = open("phenix_"+fn, "w")
      T, L, S = extract(fn_)
      # test python implementation
      r = analysis.run(T=T, L=L, S=S, log=of, implementation='python')
      # test c++ implementation
      r2 = analysis.run(T=T, L=L, S=S, log=of, implementation='c++')
      # test equivalence
      assert approx_equal(r.result.dx, r2.result.dx, 1e-4)
      assert approx_equal(r.result.dy, r2.result.dy, 1e-4)
      assert approx_equal(r.result.dz, r2.result.dz, 1e-4)
      assert approx_equal(r.result.l_x, r2.result.l_x, 1e-4)
      assert approx_equal(r.result.l_y, r2.result.l_y, 1e-4)
      assert approx_equal(r.result.l_z, r2.result.l_z, 1e-4)
      assert approx_equal(r.result.sx, r2.result.sx, 1e-4)
      assert approx_equal(r.result.sy, r2.result.sy, 1e-4)
      assert approx_equal(r.result.sz, r2.result.sz, 1e-4)
      assert approx_equal(r.result.tx, r2.result.tx, 1e-4)
      assert approx_equal(r.result.ty, r2.result.ty, 1e-4)
      assert approx_equal(r.result.tz, r2.result.tz, 1e-4)
      assert approx_equal(r.result.v_x, r2.result.v_x, 1e-4)
      assert approx_equal(r.result.v_x_M, r2.result.v_x_M, 1e-4)
      assert approx_equal(r.result.v_y, r2.result.v_y, 1e-4)
      assert approx_equal(r.result.v_y_M, r2.result.v_y_M, 1e-4)
      assert approx_equal(r.result.v_z, r2.result.v_z, 1e-4)
      assert approx_equal(r.result.v_z_M, r2.result.v_z_M, 1e-4)
      assert approx_equal(r.result.w_L_lx, r2.result.w_L_lx, 1e-4)
      assert approx_equal(r.result.w_L_ly, r2.result.w_L_ly, 1e-4)
      assert approx_equal(r.result.w_L_lz, r2.result.w_L_lz, 1e-4)
      assert approx_equal(r.result.w_M_lx, r2.result.w_M_lx, 1e-4)
      assert approx_equal(r.result.w_M_ly, r2.result.w_M_ly, 1e-4)
      assert approx_equal(r.result.w_M_lz, r2.result.w_M_lz, 1e-4)

      of.close()
      print(fn, "OK")
    except Exception as e:
      print(fn, str(e))


if (__name__ == "__main__"):
  run()


 *******************************************************************************


 *******************************************************************************
mmtbx/regression/tls/tst_tls_as_xyz.py
from __future__ import absolute_import, division, print_function
from scitbx.array_family import flex
from libtbx import easy_run
import iotbx.pdb

pdb_str = """
REMARK   3  TLS DETAILS.
REMARK   3   NUMBER OF TLS GROUPS: 2
REMARK   3   ORIGIN: CENTER OF MASS
REMARK   3   TLS GROUP : 1
REMARK   3    SELECTION: CHAIN A
REMARK   3    ORIGIN FOR THE GROUP (A):   8.7338  28.3021  16.6793
REMARK   3    T TENSOR
REMARK   3      T11:   0.0695 T22:   0.0842
REMARK   3      T33:   0.0992 T12:   0.0039
REMARK   3      T13:  -0.0041 T23:   0.0014
REMARK   3    L TENSOR
REMARK   3      L11:   2.1725 L22:   0.5881
REMARK   3      L33:   1.1562 L12:   0.4879
REMARK   3      L13:  -0.0881 L23:   0.2404
REMARK   3    S TENSOR
REMARK   3      S11:   0.0512 S12:   0.0543 S13:   0.0992
REMARK   3      S21:  -0.0892 S22:  -0.0659 S23:  -0.0441
REMARK   3      S31:  -0.0042 S32:  -0.0302 S33:   0.0147
REMARK   3   TLS GROUP : 2
REMARK   3    SELECTION: CHAIN B
REMARK   3    ORIGIN FOR THE GROUP (A):  18.7338  48.3021  46.6793
REMARK   3    T TENSOR
REMARK   3      T11:   0.0695 T22:   0.0842
REMARK   3      T33:   0.0992 T12:   0.0039
REMARK   3      T13:  -0.0041 T23:   0.0014
REMARK   3    L TENSOR
REMARK   3      L11:   2.1725 L22:   0.5881
REMARK   3      L33:   1.1562 L12:   0.4879
REMARK   3      L13:  -0.0881 L23:   0.2404
REMARK   3    S TENSOR
REMARK   3      S11:   0.0512 S12:   0.0543 S13:   0.0992
REMARK   3      S21:  -0.0892 S22:  -0.0659 S23:  -0.0441
REMARK   3      S31:  -0.0042 S32:  -0.0302 S33:   0.0147
REMARK   3
CRYST1   35.050   40.500   42.370  90.00  90.00  90.00 P 21 21 21
SCALE1      0.028531  0.000000  0.000000        0.00000
SCALE2      0.000000  0.024691  0.000000        0.00000
SCALE3      0.000000  0.000000  0.023602        0.00000
ATOM      1  CA  THR A   6       6.096  14.546  15.382  1.00  0.00           C
ATOM      2  CA  THR A   7       4.643  17.379  17.472  1.00  0.00           C
ATOM      3  CA  TYR A   8       7.031  20.308  17.626  1.00  0.00           C
ATOM      4  CA  LYS A   9       6.715  23.191  20.108  1.00  0.00           C
ATOM      5  CA  LEU A  10       7.484  26.896  19.736  1.00  0.00           C
ATOM      6  CA  VAL A  11       8.313  28.973  22.814  1.00  0.00           C
ATOM      7  CA  ILE A  12       7.745  32.666  21.951  1.00  0.00           C
ATOM      8  CA  ASN A  13       9.367  35.454  23.951  1.00  0.00           C
ATOM      9  CA  GLY A  14       8.223  38.436  21.869  1.00  0.00           C
ATOM     10  CA  LYS A  15       7.732  42.071  22.635  1.00  0.00           C
ATOM     11  CA  THR A  16       3.910  41.794  22.427  1.00  0.00           C
ATOM     12  CA  LEU A  17       3.328  38.080  21.651  1.00  0.00           C
ATOM     13  CA  LYS A  18       4.268  35.598  24.351  1.00  0.00           C
ATOM     14  CA  GLY A  19       3.567  31.957  25.117  1.00  0.00           C
ATOM     15  CA  GLU A  20       3.694  28.633  23.293  1.00  0.00           C
ATOM     16  CA  THR A  21       2.207  27.042  20.183  1.00  0.00           C
ATOM     17  CA  THR A  22       2.609  23.707  18.385  1.00  0.00           C
ATOM     18  CA  THR A  23       2.682  22.183  14.916  1.00  0.00           C
ATOM     19  CA  LYS A  24       2.823  18.625  13.556  1.00  0.00           C
ATOM     20  CA  ALA A  25       5.312  17.719  10.843  1.00  0.00           C
ATOM     21  CA  VAL A  26       7.260  14.854   9.299  1.00  0.00           C
ATOM     22  CA  ASP A  27      10.612  16.526  10.001  1.00  0.00           C
ATOM     23  CA  ALA A  28      12.142  19.541  11.794  1.00  0.00           C
ATOM     24  CA  GLU A  29      12.712  21.542   8.632  1.00  0.00           C
ATOM     25  CA  THR A  30       9.005  21.472   7.817  1.00  0.00           C
ATOM     26  CA  ALA A  31       8.121  22.548  11.353  1.00  0.00           C
ATOM     27  CA  GLU A  32      10.719  25.317  11.217  1.00  0.00           C
ATOM     28  CA  LYS A  33       9.139  26.736   8.061  1.00  0.00           C
ATOM     29  CA  ALA A  34       5.654  26.682   9.658  1.00  0.00           C
ATOM     30  CA  PHE A  35       6.940  28.471  12.774  1.00  0.00           C
ATOM     31  CA  LYS A  36       8.915  31.065  10.827  1.00  0.00           C
ATOM     32  CA  GLN A  37       5.784  31.817   8.802  1.00  0.00           C
ATOM     33  CA  TYR A  38       3.757  32.125  12.022  1.00  0.00           C
ATOM     34  CA  ALA A  39       6.322  34.523  13.495  1.00  0.00           C
ATOM     35  CA  ASN A  40       6.375  36.639  10.306  1.00  0.00           C
ATOM     36  CA  ASP A  41       2.536  36.702  10.145  1.00  0.00           C
ATOM     37  CA  ASN A  42       2.519  38.093  13.718  1.00  0.00           C
ATOM     38  CA  GLY A  43       5.296  40.638  13.264  1.00  0.00           C
ATOM     39  CA  VAL A  44       7.921  38.823  15.338  1.00  0.00           C
ATOM     40  CA  ASP A  45      11.526  39.426  14.290  1.00  0.00           C
ATOM     41  CA  GLY A  46      13.865  37.643  16.623  1.00  0.00           C
ATOM     42  CA  VAL A  47      16.614  35.096  17.081  1.00  0.00           C
ATOM     43  CA  TRP A  48      16.026  31.364  17.129  1.00  0.00           C
ATOM     44  CA  THR A  49      17.146  28.133  18.719  1.00  0.00           C
ATOM     45  CA  TYR A  50      16.165  24.543  17.999  1.00  0.00           C
ATOM     46  CA  ASP A  51      16.716  21.634  20.410  1.00  0.00           C
ATOM     47  CA  ASP A  52      16.413  18.270  18.691  1.00  0.00           C
ATOM     48  CA  ALA A  53      16.219  16.432  22.049  1.00  0.00           C
ATOM     49  CA  THR A  54      12.971  18.177  23.062  1.00  0.00           C
ATOM     50  CA  LYS A  55      11.609  19.022  19.577  1.00  0.00           C
ATOM     51  CA  THR A  56      11.365  22.651  20.684  1.00  0.00           C
ATOM     52  CA  PHE A  57      12.052  25.886  18.846  1.00  0.00           C
ATOM     53  CA  THR A  58      12.461  29.177  20.755  1.00  0.00           C
ATOM     54  CA  VAL A  59      12.275  32.720  19.421  1.00  0.00           C
ATOM     55  CA  THR A  60      13.202  35.851  21.380  1.00  0.00           C
ATOM     56  CA  GLU A  61      12.989  39.521  20.535  1.00  0.00           C
TER
ATOM      1  CA  THR B   6      18.094  36.747  38.683  1.00  0.00           C
ATOM      2  CA  THR B   7      17.002  37.634  42.222  1.00  0.00           C
ATOM      3  CA  TYR B   8      18.786  40.734  43.451  1.00  0.00           C
ATOM      4  CA  LYS B   9      18.872  41.840  47.104  1.00  0.00           C
ATOM      5  CA  LEU B  10      18.852  45.310  48.658  1.00  0.00           C
ATOM      6  CA  VAL B  11      20.333  45.838  52.123  1.00  0.00           C
ATOM      7  CA  ILE B  12      18.910  49.102  53.545  1.00  0.00           C
ATOM      8  CA  ASN B  13      20.640  50.975  56.357  1.00  0.00           C
ATOM      9  CA  GLY B  14      18.382  54.043  56.519  1.00  0.00           C
ATOM     10  CA  LYS B  15      17.597  56.519  59.219  1.00  0.00           C
ATOM     11  CA  THR B  16      14.034  55.170  59.682  1.00  0.00           C
ATOM     12  CA  LEU B  17      13.836  52.292  57.150  1.00  0.00           C
ATOM     13  CA  LYS B  18      16.034  49.280  57.805  1.00  0.00           C
ATOM     14  CA  GLY B  19      16.242  45.699  56.592  1.00  0.00           C
ATOM     15  CA  GLU B  20      16.278  43.860  53.274  1.00  0.00           C
ATOM     16  CA  THR B  21      14.098  43.538  50.182  1.00  0.00           C
ATOM     17  CA  THR B  22      14.399  41.766  46.823  1.00  0.00           C
ATOM     18  CA  THR B  23      13.529  42.164  43.156  1.00  0.00           C
ATOM     19  CA  LYS B  24      13.775  39.919  40.086  1.00  0.00           C
ATOM     20  CA  ALA B  25      15.298  41.242  36.875  1.00  0.00           C
ATOM     21  CA  VAL B  26      17.040  40.230  33.662  1.00  0.00           C
ATOM     22  CA  ASP B  27      20.109  42.345  34.455  1.00  0.00           C
ATOM     23  CA  ALA B  28      21.647  44.472  37.241  1.00  0.00           C
ATOM     24  CA  GLU B  29      20.766  47.787  35.639  1.00  0.00           C
ATOM     25  CA  THR B  30      17.068  46.930  35.697  1.00  0.00           C
ATOM     26  CA  ALA B  31      17.284  45.873  39.341  1.00  0.00           C
ATOM     27  CA  GLU B  32      19.190  49.044  40.204  1.00  0.00           C
ATOM     28  CA  LYS B  33      16.417  51.191  38.731  1.00  0.00           C
ATOM     29  CA  ALA B  34      13.747  49.286  40.715  1.00  0.00           C
ATOM     30  CA  PHE B  35      15.711  49.704  43.961  1.00  0.00           C
ATOM     31  CA  LYS B  36      16.449  53.384  43.382  1.00  0.00           C
ATOM     32  CA  GLN B  37      12.736  53.956  42.785  1.00  0.00           C
ATOM     33  CA  TYR B  38      11.911  52.051  45.988  1.00  0.00           C
ATOM     34  CA  ALA B  39      14.398  54.150  47.965  1.00  0.00           C
ATOM     35  CA  ASN B  40      13.011  57.407  46.510  1.00  0.00           C
ATOM     36  CA  ASP B  41       9.393  56.311  47.200  1.00  0.00           C
ATOM     37  CA  ASN B  42      10.372  55.772  50.867  1.00  0.00           C
ATOM     38  CA  GLY B  43      12.371  58.965  51.313  1.00  0.00           C
ATOM     39  CA  VAL B  44      15.806  57.334  51.476  1.00  0.00           C
ATOM     40  CA  ASP B  45      18.685  59.472  50.212  1.00  0.00           C
ATOM     41  CA  GLY B  46      21.939  57.654  50.662  1.00  0.00           C
ATOM     42  CA  VAL B  47      25.055  56.218  49.087  1.00  0.00           C
ATOM     43  CA  TRP B  48      25.136  52.936  47.216  1.00  0.00           C
ATOM     44  CA  THR B  49      27.244  49.886  46.524  1.00  0.00           C
ATOM     45  CA  TYR B  50      26.676  46.957  44.186  1.00  0.00           C
ATOM     46  CA  ASP B  51      28.485  43.605  44.454  1.00  0.00           C
ATOM     47  CA  ASP B  52      28.165  41.547  41.287  1.00  0.00           C
ATOM     48  CA  ALA B  53      29.434  38.394  43.060  1.00  0.00           C
ATOM     49  CA  THR B  54      26.490  38.319  45.499  1.00  0.00           C
ATOM     50  CA  LYS B  55      23.900  40.218  43.402  1.00  0.00           C
ATOM     51  CA  THR B  56      23.461  42.607  46.326  1.00  0.00           C
ATOM     52  CA  PHE B  57      22.940  46.353  46.449  1.00  0.00           C
ATOM     53  CA  THR B  58      23.434  48.296  49.708  1.00  0.00           C
ATOM     54  CA  VAL B  59      22.228  51.780  50.588  1.00  0.00           C
ATOM     55  CA  THR B  60      23.245  53.732  53.695  1.00  0.00           C
ATOM     56  CA  GLU B  61      22.160  57.082  55.047  1.00  0.00           C
TER
END
"""

def run(file_name = "tst_tls_as_xyz.pdb"):
  of = open(file_name,"w")
  print(pdb_str, file=of)
  of.close()
  uc = iotbx.pdb.input(file_name=file_name).crystal_symmetry().unit_cell()
  #for n in range(10,100,10)+range(100,1000,100)+range(1000,10001,1000)+[15000,20000]:
  for n in [1000,]:
    assert not easy_run.call("phenix.tls_as_xyz %s n_models=%s > tst_tls_as_xyz.log"%(
      file_name,str(n)))
    for i in [0,1]:
      u1 = iotbx.pdb.input(file_name=
        "tst_tls_as_xyz_u_from_ensemble_%s.pdb"%str(i)
        ).xray_structure_simple().scatterers().extract_u_cart(uc)
      u2 = iotbx.pdb.input(file_name=
        "tst_tls_as_xyz_u_from_tls_%s.pdb"%str(i)
        ).xray_structure_simple().scatterers().extract_u_cart(uc)

    u1, u2 = u1.as_double(), u2.as_double()
    cc = flex.linear_correlation(x=u1, y=u2).coefficient()
    r = flex.sum(flex.abs(flex.abs(u1)-flex.abs(u2)))/\
        flex.sum(flex.abs(flex.abs(u1)+flex.abs(u2)))*2
    print("%5d %6.4f %6.4f"%(n, cc, r))
  assert cc>0.99, cc
  assert r<0.06, r

if (__name__ == "__main__"):
  run()


 *******************************************************************************


 *******************************************************************************
mmtbx/regression/tls/tst_tls_optimise_amplitudes.py
from __future__ import absolute_import, division, print_function

import numpy
from mmtbx.tls.utils import TLSMatrices
from mmtbx.tls.optimise_amplitudes import \
  MultiGroupMultiDatasetUijAmplitudeFunctionalAndGradientCalculator, \
  OptimiseAmplitudes, OptimisationWeights
from scitbx.array_family import flex
from libtbx.test_utils import approx_equal, raises
from six.moves import zip
from six.moves import range

rran = numpy.random.random
iran = numpy.random.choice

numpy.random.seed(123232)

TLSMatrices.set_precision(12)

T_ONLY = [1.,1.,1.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.]
L_ONLY = [0.,0.,0.,0.,0.,0.,1.,1.,1.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.]

TLS_MATRICES = [
  [0.88875254,0.266694873,0.493991604,-0.280846445,0.018132653,0.128202717,0.109792777,0.143780355,0.111757325,0.00745827,0.044408043,0.004683883,-0.031880059,0.087486387,-0.035440044,0.053723107,-0.093285664,-0.126741771,0.078707102,0.047063985,0.125165723],
  [0.244377462,0.459148081,0.710013128,-0.008898371,0.07279876,0.036277241,3.755718081,2.739489028,2.134579946,-0.200385262,0.074588032,-0.023382499,0.00048379,0.229469716,-0.187382678,-0.05705213,0.308356068,0.219549925,0.260721724,0.137599684,-0.308839858],
  [0.29790555,0.765985455,0.362144247,0.188051876,-0.07468928,0.176222813,1.157009238,1.603540537,1.146982202,0.076470473,0.076337332,-0.036514342,-0.057413883,-0.4930283,-0.141063091,0.199094828,0.180380061,0.564268854,0.271176005,0.192103145,-0.122966178],
  [0.550613174,0.642391951,0.512539873,0.186990637,-0.018948302,0.182865203,0.696794749,1.168473012,1.459255982,0.122241174,-0.070965716,-0.127405648,-0.126672963,-0.057326201,0.307248593,0.23402513,-0.081293525,-0.457364662,-0.270995819,0.131106455,0.207966488],
  [0.801839264,0.111567149,0.473172234,0.111448705,0.01322435,0.053023611,0.119600352,0.158201942,0.501511288,-0.00097325,0.038852731,-0.020179123,0.094859837,0.027409079,0.027958886,-0.036977684,0.115684103,-0.023249574,-0.167599437,0.028274946,-0.21054394],
  [0.476189761,0.185513316,0.494838237,0.079787304,0.186996542,0.089705044,6.468559896,0.03302114,1.360918838,-0.092774147,-0.470033825,0.142680478,0.007373318,0.322513481,-0.087204939,-0.102689013,0.085596047,-0.037679444,-0.183875771,-0.048267033,-0.092969365],
  [0.271946335,0.353828607,0.011539801,-0.012010653,-0.03669219,-0.006760052,23.89487928,3.564598018,0.086574587,-1.913464478,0.89104049,-0.011635907,0.00083053,-0.00120248,-0.06596398,0.059314995,0.042902408,0.001580523,-0.013344186,0.103940739,-0.043732938],
  [0.436887477,0.558232952,0.172244124,0.292168093,-0.130328728,-0.074615062,3.137593554,0.025205525,0.920908537,-0.108005337,0.00472811,0.015510299,-0.000822308,0.118599046,-0.151446932,0.029991796,0.042430554,-0.009368142,0.000888338,0.153578145,-0.041608246],
  [0.507487457,0.513473662,0.465150239,-0.024656406,0.052695005,0.030032721,9.358808433,1.113449297,12.326819619,-0.988256782,1.235061392,-1.371684512,0.454760772,-0.522429055,0.566566556,0.34528893,-0.057886461,-0.28449733,-0.171754982,-0.103504915,-0.396874311],
  [0.708808312,0.55187043,0.429938391,0.197257684,-3.9774e-05,-0.054427743,0.178345211,0.297789551,0.087920317,-0.003702672,-0.002424311,0.000192857,-0.029460632,0.037160795,0.061827225,0.276788373,0.000147768,-0.235898673,0.018602792,-0.125798933,0.029312864],
  [0.151113427,0.654574237,0.240882778,-0.018212974,-0.014025963,0.100180189,0.285310135,2.881490187,11.011691132,-0.437653779,-0.698453455,0.157185441,-0.1905967,-0.166253585,-0.151567002,0.150109019,0.444896847,-0.230918972,0.078079958,0.50626905,-0.254300147],
]

def get_optimisation_test_set(
  n_grp,
  n_dst,
  n_atm,
  atomic_amplitude=1.0,
  random_dataset_order=False,
  ):
  """Generate a test set of random uijs for optimisation"""

  assert n_grp > 0
  assert n_grp <= len(TLS_MATRICES)
  assert n_dst > 0
  assert n_atm > 3

  target_uijs = numpy.zeros((n_dst, n_atm, 6))

  # Default to equal weights
  target_weights = flex.double(flex.grid((n_dst, n_atm)), 1.0)

  # Create atomic base
  atomic_values_numpy = rran(n_atm*6).reshape((n_atm,6))
  real_atomic_amps = atomic_amplitude * rran(n_atm)
  atomic_base = flex.sym_mat3_double(atomic_values_numpy)

  # Create atomic total and add to target
  atomic_uijs = real_atomic_amps.reshape((n_atm,1)) * atomic_values_numpy
  for i_dst in range(n_dst):
    target_uijs[i_dst] = atomic_uijs

  # Generate a random set of amplitudes
  real_group_amps = rran(n_grp*n_dst).reshape((n_grp,n_dst))

  # Output lists of base uijs and atoms they are associated with
  base_uijs = []
  base_sels = []

  # Mapping of elements to datasets
  if random_dataset_order is True:
    dataset_hash = flex.size_t(numpy.concatenate([flex.random_permutation(n_dst) for _ in range(n_grp)]))
  else:
    dataset_hash = flex.size_t(list(range(n_dst)) * n_grp)

  # base counter
  i_cnt = 0
  for i_grp in range(n_grp):
    # Number of atoms in this group -- at least 2
    if n_grp == 1:
      n_atm_this = n_atm
    else:
      n_atm_this = max(2,iran(n_atm))
    # Which atoms are covered by this group
    i_sel = iran(n_atm, size=n_atm_this, replace=False)
    # Generate some uijs for this
    tls_m = TLSMatrices(TLS_MATRICES[i_grp])
    for _ in range(n_dst):
      # Which dataset?
      i_dst = dataset_hash[i_cnt]
      i_cnt += 1
      # Generate random coordinates
      x_ = 50.0*(-0.5+rran(n_atm_this*3).reshape((n_atm_this,3)))
      x_ = flex.vec3_double(x_)
      # Generate the base elements
      u_ = tls_m.uijs(x_, origin=(0.,0.,0.))
      base_uijs.append(flex.sym_mat3_double(u_))
      base_sels.append(flex.size_t(i_sel))
      # Generate the amplitude-multiplied equivalent
      u_m = (real_group_amps[i_grp,i_dst]*tls_m).uijs(x_, origin=(0.,0.,0.))
      target_uijs[i_dst, i_sel, :] += numpy.array(u_m)
  # Reshape
  target_uijs = flex.sym_mat3_double(target_uijs.reshape((n_dst*n_atm,6)))
  target_uijs.reshape(flex.grid((n_dst,n_atm)))

  return (
    target_uijs, target_weights, \
    base_uijs, base_sels, dataset_hash, \
    atomic_base, \
    real_group_amps.flatten(), real_atomic_amps,
  )

def resort_amplitudes_by_dataset_hash(
  n_grp,
  n_dst,
  dataset_hash,
  real_group_amps,
  ):
  """Sorted the real amplitudes into the order that they will be returned by the optimiser"""
  sorted_group_amps = []
  i_cnt = 0
  for i_grp in range(n_grp):
    for _ in range(n_dst):
      i_dst = dataset_hash[i_cnt]
      i_cnt += 1
      sorted_group_amps.append(real_group_amps[i_grp*n_dst+i_dst])
  return sorted_group_amps

def calculate_expected_f_and_g_least_squares(
  n_grp,
  n_dst,
  n_atm,
  target_uijs,
  target_weights,
  base_uijs,
  base_sels,
  dataset_hash,
  atomic_base,
  current_amplitudes_base,
  atomic_mask = None,
  ):
  """Calculate what we expect from the current functional and gradients"""

  # Atomics always start with unitary amplitudes
  current_amplitudes_atomic = flex.double(n_atm, 1.0)

  if atomic_mask is None:
    atomic_mask = flex.bool(n_dst, True)

  functional = 0.0
  gradients = numpy.zeros(n_grp*n_dst+n_atm)

  target_uijs_numpy = numpy.array(target_uijs).reshape((n_dst,n_atm,6))
  target_weights_numpy = numpy.array(target_weights).reshape((n_dst,n_atm))
  atomic_uijs_numpy = numpy.array(current_amplitudes_atomic).reshape((n_atm,1)) * numpy.array(atomic_base)

  for i_dst in range(n_dst):
    b_sel = [i_b for i_b, i_d in enumerate(dataset_hash) if i_d==i_dst]
    total_uij = numpy.zeros((n_atm, 6))
    # Add up contributions from different components
    for i_b in b_sel:
      amp = current_amplitudes_base[i_b]
      uijs = base_uijs[i_b]
      atms = base_sels[i_b]
      assert len(uijs) == len(atms)
      for i_atm, u in zip(atms, uijs):
        total_uij[i_atm] += amp*numpy.array(u)
    total_uij += atomic_uijs_numpy
    delta_uijs = (target_uijs_numpy[i_dst] - total_uij)

    # Calculate functional (least squares)
    for u, w in zip(delta_uijs, target_weights_numpy[i_dst]):
      assert len(u) == 6
      functional += numpy.sum(w * u * u)

    # Calculate gradients (for each base element)
    for i_b in b_sel:
      uijs = base_uijs[i_b]
      atms = base_sels[i_b]
      assert len(uijs) == len(atms)
      for i_atm, ug in zip(atms, uijs):
        ud = delta_uijs[i_atm]
        w = target_weights_numpy[i_dst, i_atm]
        gradients[i_b] += numpy.sum(-2.0 * w * ud * ug)

    if atomic_mask[i_dst]:
      for i_atm in range(n_atm):
        ur = atomic_base[i_atm]
        ud = delta_uijs[i_atm]
        w = target_weights_numpy[i_dst, i_atm]
        w2 = float(n_dst) / sum(atomic_mask)
        gradients[-n_atm+i_atm] += numpy.sum(-2.0 * w * ud * ur * w2)

  return functional, gradients

def calculate_expected_f_and_g_sum_of_amplitudes(
  n_grp, n_dst, n_atm,
  target_weights,
  dataset_hash,
  current_amplitudes,
  atomic_base,
  overall_weight,
  atomic_mask = None,
  ):

  mult = overall_weight

  dataset_weights = target_weights.as_numpy_array().mean(axis=1)
  assert len(dataset_weights) == n_dst

  amplitude_sums = numpy.zeros(n_dst)

  assert len(current_amplitudes) == n_grp*n_dst + n_atm

  for i, a in enumerate(current_amplitudes[:n_grp*n_dst]):
    amplitude_sums[dataset_hash[i]] += a

  atomic_amps = (numpy.array(current_amplitudes[-n_atm:]).reshape((n_atm,1)) * numpy.array(atomic_base))
  atomic_amps = atomic_amps[:,0:3].mean(axis=1)
  assert len(atomic_amps) == n_atm

  # Add to all datasets
  amplitude_sums[:] += atomic_amps.sum()

  f = mult * (amplitude_sums * dataset_weights).sum()
  g = flex.double(
    [mult * dataset_weights[i_dst] for i_dst in dataset_hash] +
    [mult * dataset_weights.sum()]*n_atm
  )

  return f,g

def calculate_expected_f_and_g_sum_of_amplitudes_squared(
  n_grp,
  n_dst,
  n_atm,
  target_weights,
  dataset_hash,
  current_amplitudes,
  atomic_base,
  overall_weight,
  atomic_mask = None,
  ):

  mult = overall_weight

  dataset_weights = target_weights.as_numpy_array().mean(axis=1)
  assert len(dataset_weights) == n_dst

  amplitude_sums = numpy.zeros(n_dst)

  assert len(current_amplitudes) == n_grp*n_dst + n_atm

  for i, a in enumerate(current_amplitudes[:n_grp*n_dst]):
    amplitude_sums[dataset_hash[i]] += a

  atomic_amps = (numpy.array(current_amplitudes[-n_atm:]).reshape((n_atm,1)) * numpy.array(atomic_base))
  atomic_amps = atomic_amps[:,0:3].mean(axis=1)
  assert len(atomic_amps) == n_atm

  # Add to all datasets
  amplitude_sums[:] += atomic_amps.sum()

  f = mult * (amplitude_sums * amplitude_sums * dataset_weights).sum()
  g = flex.double(
    [2.0 * mult * amplitude_sums[i_dst] * dataset_weights[i_dst] for i_dst in dataset_hash] +
    [2.0 * mult * (amplitude_sums * dataset_weights).sum()]*n_atm
  )

  return f,g

def calculate_expected_f_and_g_sum_of_squared_amplitudes(
  n_grp,
  n_dst,
  n_atm,
  target_weights,
  dataset_hash,
  current_amplitudes,
  atomic_base,
  overall_weight,
  atomic_mask=None,
  ):

  mult = overall_weight

  dataset_weights = target_weights.as_numpy_array().mean(axis=1)
  assert len(dataset_weights) == n_dst

  dataset_weights_base = numpy.array([dataset_weights[i_dst] for i_dst in dataset_hash])

  assert len(current_amplitudes) == n_grp*n_dst + n_atm

  group_amplitudes = current_amplitudes[:n_grp*n_dst]

  atomic_amps = (numpy.array(current_amplitudes[-n_atm:]).reshape((n_atm,1)) * numpy.array(atomic_base))
  atomic_amps = atomic_amps[:,0:3].mean(axis=1)
  assert len(atomic_amps) == n_atm

  f = mult * (
    (group_amplitudes * group_amplitudes * dataset_weights_base).sum() +
    (atomic_amps * atomic_amps * dataset_weights.sum()).sum()
  )
  g = flex.double(
    list(2.0 * mult * group_amplitudes * dataset_weights_base) +
    list(2.0 * mult * atomic_amps * dataset_weights.sum())
  )

  return f,g

def tst_optimisation_weights():

  wgts_dbl = rran(3)
  wgts_dict = dict(
    sum_of_amplitudes = wgts_dbl[0],
    sum_of_squared_amplitudes = wgts_dbl[1],
    sum_of_amplitudes_squared = wgts_dbl[2],
  )

  # Initialise from dict
  weights = OptimisationWeights(**wgts_dict)
  assert approx_equal(weights.sum_of_amplitudes, wgts_dbl[0])
  assert approx_equal(weights.sum_of_squared_amplitudes, wgts_dbl[1])
  assert approx_equal(weights.sum_of_amplitudes_squared, wgts_dbl[2])

  print('OK')

def tst_optimise_amplitudes_single_group():
  """Check that very basic optimisation reaches expected values regardless of starting values"""

  n_grp = 1
  n_atm = 10

  for n_dst in [1,5]:
    for g_amp_start in [0.0, 1.0, None]:
      for r_amp_mult in [0.0, 1.0]:

        # Get a random set of values to test
        target_uijs, target_weights, \
          base_uijs, base_sels, dataset_hash, \
          atomic_base, \
          real_group_amps, real_atomic_amps \
            = get_optimisation_test_set(n_grp, n_dst, n_atm, atomic_amplitude=r_amp_mult)

        if r_amp_mult == 0.0:
          assert not real_atomic_amps.any()

        # Starting values
        if g_amp_start is not None:
          base_amplitudes_start = flex.double(n_grp*n_dst, g_amp_start)
        else:
          base_amplitudes_start = flex.double(rran(n_grp*n_dst))

        # Since not given, amplitudes start at 1.0 for atomic
        atomic_amplitudes_start = flex.double(n_atm, 1.0)

        # Optimise
        opt = OptimiseAmplitudes(
          target_uijs = target_uijs,
          target_weights = target_weights,
          base_amplitudes = base_amplitudes_start,
          base_uijs = base_uijs,
          base_atom_indices = base_sels,
          base_dataset_hash = dataset_hash,
          atomic_uijs = atomic_base,
          atomic_amplitudes = None,
          atomic_optimisation_mask = None,
          optimisation_weights = None,
          convergence_tolerance=1e-08,
        ).run()

        assert approx_equal(list(opt.initial), list(base_amplitudes_start) + list(atomic_amplitudes_start), 1e-6)
        assert approx_equal(list(opt.result), list(real_group_amps) + list(real_atomic_amps), 1e-6)

  print('OK')

def tst_optimise_amplitudes_multiple_groups_with_atomic():
  """Check that multiple partial groups optimise correctly with atomic level"""

  n_grp = 3
  n_dst = 5
  n_atm = 10

  # Get a random set of values to test
  target_uijs, target_weights, \
    base_uijs, base_sels, dataset_hash, \
    atomic_base, \
    real_group_amps, real_atomic_amps \
      = get_optimisation_test_set(n_grp, n_dst, n_atm)

  # Starting values
  base_amplitudes_start = flex.double(n_grp*n_dst, 0.0)
  atomic_amplitudes_start = flex.double(n_atm, 0.0)

  opt = OptimiseAmplitudes(
    target_uijs = target_uijs,
    target_weights = target_weights,
    base_amplitudes = base_amplitudes_start,
    base_uijs = base_uijs,
    base_atom_indices = base_sels,
    base_dataset_hash = dataset_hash,
    atomic_uijs = atomic_base,
    atomic_amplitudes = atomic_amplitudes_start,
    atomic_optimisation_mask = None,
    optimisation_weights = None,
    convergence_tolerance=1e-08,
  ).run()

  assert approx_equal(list(opt.initial), list(base_amplitudes_start) + list(atomic_amplitudes_start), 1e-6)
  assert approx_equal(list(opt.result), list(real_group_amps) + list(real_atomic_amps), 1e-6)

  ########################################################
  # Check that shuffling the input lists has the expected effect
  ########################################################

  n_base = n_grp * n_dst
  i_perm = iran(n_base, size=n_base, replace=False)
  # Reorder the base elements by random permutation
  base_uijs = [base_uijs[i] for i in i_perm]
  base_sels = [base_sels[i] for i in i_perm]
  dataset_hash = flex.size_t([dataset_hash[i] for i in i_perm])
  base_amplitudes_start = flex.double([base_amplitudes_start[i] for i in i_perm])

  opt = OptimiseAmplitudes(
    target_uijs = target_uijs,
    target_weights = target_weights,
    base_amplitudes = base_amplitudes_start,
    base_uijs = base_uijs,
    base_atom_indices = base_sels,
    base_dataset_hash = dataset_hash,
    atomic_uijs = atomic_base,
    atomic_amplitudes = atomic_amplitudes_start,
    atomic_optimisation_mask = None,
    optimisation_weights = None,
    convergence_tolerance=1e-08,
  ).run()

  assert approx_equal(list(opt.initial), list(base_amplitudes_start) + list(atomic_amplitudes_start), 1e-6)
  assert approx_equal(list(opt.result), list([real_group_amps[i] for i in i_perm]) + list(real_atomic_amps), 1e-6)

  print('OK')

def tst_optimise_amplitudes_multiple_groups_permuted_dataset_order():

  n_grp = 3
  n_dst = 5
  n_atm = 10

  # Get a random set of values to test
  target_uijs, target_weights, \
    base_uijs, base_sels, dataset_hash, \
    atomic_base, \
    real_group_amps, real_atomic_amps \
      = get_optimisation_test_set(n_grp, n_dst, n_atm, random_dataset_order=True)

  sorted_group_amps = resort_amplitudes_by_dataset_hash(
    n_grp=n_grp, n_dst=n_dst,
    dataset_hash=dataset_hash,
    real_group_amps=real_group_amps,
  )

  # Starting values
  base_amplitudes_start = flex.double(n_grp*n_dst, 0.0)
  atomic_amplitudes_start = flex.double(n_atm, 0.0)

  opt = OptimiseAmplitudes(
    target_uijs = target_uijs,
    target_weights = target_weights,
    base_amplitudes = base_amplitudes_start,
    base_uijs = base_uijs,
    base_atom_indices = base_sels,
    base_dataset_hash = dataset_hash,
    atomic_uijs = atomic_base,
    atomic_amplitudes = atomic_amplitudes_start,
    atomic_optimisation_mask = None,
    optimisation_weights = None,
    convergence_tolerance=1e-08,
  ).run()

  assert approx_equal(list(opt.initial), list(base_amplitudes_start) + list(atomic_amplitudes_start), 1e-6)
  assert approx_equal(list(opt.result), list(sorted_group_amps) + list(real_atomic_amps), 1e-6)

  print('OK')

def tst_functional_gradient_calculator():
  """Check that the functional and gradients are calculated as expected"""

  n_grp = 3
  n_dst = 5
  n_atm = 10

  for atomic_mask_size in [None, 1, 2, 3]:
    if atomic_mask_size is not None:
      atomic_mask = flex.bool(n_dst, False)
      n_sel = max(n_dst, atomic_mask_size)
      atomic_mask.set_selected(flex.size_t(iran(n_dst, size=n_sel, replace=False)), True)
      assert sum(atomic_mask) == n_sel
    else:
      atomic_mask = None

    target_uijs, target_weights, \
      base_uijs, base_sels, dataset_hash, \
      atomic_base, \
      real_group_amps, real_atomic_amps \
        = get_optimisation_test_set(n_grp, n_dst, n_atm)

    # Starting values - randomise
    base_amplitudes_start = flex.random_double(n_grp*n_dst)

    ########################################################
    # Check least-squares f/g
    ########################################################

    functional, gradients = calculate_expected_f_and_g_least_squares(
      n_grp = n_grp,
      n_dst = n_dst,
      n_atm = n_atm,
      target_uijs = target_uijs,
      target_weights = target_weights,
      base_uijs = base_uijs,
      base_sels = base_sels,
      dataset_hash = dataset_hash,
      atomic_base = atomic_base,
      current_amplitudes_base = base_amplitudes_start,
      atomic_mask = atomic_mask,
    )

    f_g_calculator = MultiGroupMultiDatasetUijAmplitudeFunctionalAndGradientCalculator(
      target_uijs = target_uijs,
      target_weights = target_weights,
      base_amplitudes = base_amplitudes_start,
      base_uijs = base_uijs,
      base_atom_indices = base_sels,
      base_dataset_hash = dataset_hash,
      atomic_uijs = atomic_base,
      weight_sum_of_amplitudes = 0.0,
      weight_sum_of_amplitudes_squared = 0.0,
      weight_sum_of_squared_amplitudes = 0.0,
    )
    if atomic_mask:
      f_g_calculator.set_atomic_optimisation_mask(atomic_mask)

    f, g = f_g_calculator.compute_functional_and_gradients()

    assert approx_equal(f, functional)
    assert approx_equal(list(g), list(gradients))

    ########################################################
    # check that correct solution gives no functional and gradient
    ########################################################

    correct_amplitudes = flex.double(list(real_group_amps) + list(real_atomic_amps))

    # Manually set amplitudes
    f_g_calculator.set_current_amplitudes(correct_amplitudes)

    f, g = f_g_calculator.compute_functional_and_gradients()

    assert approx_equal(f, 0.0)
    assert g.all_approx_equal(0.0)

    ########################################################
    # Calculate gradients for weight_sum_of_amplitudes
    ########################################################

    # !!! Still using the correct solution so that those functional and gradient components are zero

    wgt = rran()

    f_g_calculator = MultiGroupMultiDatasetUijAmplitudeFunctionalAndGradientCalculator(
      target_uijs = target_uijs,
      target_weights = target_weights,
      base_amplitudes = base_amplitudes_start,
      base_uijs = base_uijs,
      base_atom_indices = base_sels,
      base_dataset_hash = dataset_hash,
      atomic_uijs = atomic_base,
      weight_sum_of_amplitudes = wgt,
      weight_sum_of_amplitudes_squared = 0.0,
      weight_sum_of_squared_amplitudes = 0.0,
    )
    if atomic_mask:
      f_g_calculator.set_atomic_optimisation_mask(atomic_mask)

    f_g_calculator.set_current_amplitudes(correct_amplitudes)

    functional, gradients = calculate_expected_f_and_g_sum_of_amplitudes(
      n_grp = n_grp,
      n_dst = n_dst,
      n_atm = n_atm,
      target_weights = target_weights,
      dataset_hash = dataset_hash,
      current_amplitudes = f_g_calculator.get_current_amplitudes(),
      atomic_base = atomic_base,
      overall_weight = wgt,
    )

    f, g = f_g_calculator.compute_functional_and_gradients()

    assert approx_equal(f, functional)
    assert approx_equal(list(g), list(gradients))

    ########################################################
    # Calculate gradients for weight_sum_of_amplitudes_squared
    ########################################################

    # !!! Still using the correct solution so that those functional and gradient components are zero

    wgt = rran()

    f_g_calculator = MultiGroupMultiDatasetUijAmplitudeFunctionalAndGradientCalculator(
      target_uijs = target_uijs,
      target_weights = target_weights,
      base_amplitudes = base_amplitudes_start,
      base_uijs = base_uijs,
      base_atom_indices = base_sels,
      base_dataset_hash = dataset_hash,
      atomic_uijs = atomic_base,
      weight_sum_of_amplitudes = 0.0,
      weight_sum_of_amplitudes_squared = wgt,
      weight_sum_of_squared_amplitudes = 0.0,
    )
    if atomic_mask:
      f_g_calculator.set_atomic_optimisation_mask(atomic_mask)

    f_g_calculator.set_current_amplitudes(correct_amplitudes)

    functional, gradients = calculate_expected_f_and_g_sum_of_amplitudes_squared(
      n_grp = n_grp,
      n_dst = n_dst,
      n_atm = n_atm,
      target_weights = target_weights,
      dataset_hash = dataset_hash,
      current_amplitudes = f_g_calculator.get_current_amplitudes(),
      atomic_base = atomic_base,
      overall_weight = wgt,
    )

    f, g = f_g_calculator.compute_functional_and_gradients()

    assert approx_equal(f, functional)
    assert approx_equal(list(g), list(gradients))

    ########################################################
    # Calculate gradients for weight_sum_of_squared_amplitudes
    ########################################################

    # !!! Still using the correct solution so that those functional and gradient components are zero

    wgt = rran()

    f_g_calculator = MultiGroupMultiDatasetUijAmplitudeFunctionalAndGradientCalculator(
      target_uijs = target_uijs,
      target_weights = target_weights,
      base_amplitudes = base_amplitudes_start,
      base_uijs = base_uijs,
      base_atom_indices = base_sels,
      base_dataset_hash = dataset_hash,
      atomic_uijs = atomic_base,
      weight_sum_of_amplitudes = 0.0,
      weight_sum_of_amplitudes_squared = 0.0,
      weight_sum_of_squared_amplitudes = wgt,
    )
    if atomic_mask:
      f_g_calculator.set_atomic_optimisation_mask(atomic_mask)

    f_g_calculator.set_current_amplitudes(correct_amplitudes)

    functional, gradients = calculate_expected_f_and_g_sum_of_squared_amplitudes(
      n_grp = n_grp,
      n_dst = n_dst,
      n_atm = n_atm,
      target_weights = target_weights,
      dataset_hash = dataset_hash,
      current_amplitudes = f_g_calculator.get_current_amplitudes(),
      atomic_base = atomic_base,
      overall_weight = wgt,
    )

    f, g = f_g_calculator.compute_functional_and_gradients()

    assert approx_equal(f, functional)
    assert approx_equal(list(g), list(gradients))

    ########################################################
    # Turn on all weights and non-optimal solution
    ########################################################

    wgts = rran(3)

    f_g_calculator = MultiGroupMultiDatasetUijAmplitudeFunctionalAndGradientCalculator(
      target_uijs = target_uijs,
      target_weights = target_weights,
      base_amplitudes = base_amplitudes_start,
      base_uijs = base_uijs,
      base_atom_indices = base_sels,
      base_dataset_hash = dataset_hash,
      atomic_uijs = atomic_base,
      weight_sum_of_amplitudes = wgts[0],
      weight_sum_of_amplitudes_squared = wgts[1],
      weight_sum_of_squared_amplitudes = wgts[2],
    )
    if atomic_mask:
      f_g_calculator.set_atomic_optimisation_mask(atomic_mask)

    flsq, glsq = calculate_expected_f_and_g_least_squares(
      n_grp = n_grp,
      n_dst = n_dst,
      n_atm = n_atm,
      target_uijs = target_uijs,
      target_weights = target_weights,
      base_uijs = base_uijs,
      base_sels = base_sels,
      dataset_hash = dataset_hash,
      atomic_base = atomic_base,
      current_amplitudes_base = base_amplitudes_start,
      atomic_mask = atomic_mask,
    )

    fw1, gw1 = calculate_expected_f_and_g_sum_of_amplitudes(
      n_grp = n_grp,
      n_dst = n_dst,
      n_atm = n_atm,
      target_weights = target_weights,
      dataset_hash = dataset_hash,
      current_amplitudes = f_g_calculator.get_current_amplitudes(),
      atomic_base = atomic_base,
      overall_weight = wgts[0],
    )

    fw2, gw2 = calculate_expected_f_and_g_sum_of_amplitudes_squared(
      n_grp = n_grp,
      n_dst = n_dst,
      n_atm = n_atm,
      target_weights = target_weights,
      dataset_hash = dataset_hash,
      current_amplitudes = f_g_calculator.get_current_amplitudes(),
      atomic_base = atomic_base,
      overall_weight = wgts[1],
    )

    fw3, gw3 = calculate_expected_f_and_g_sum_of_squared_amplitudes(
      n_grp = n_grp,
      n_dst = n_dst,
      n_atm = n_atm,
      target_weights = target_weights,
      dataset_hash = dataset_hash,
      current_amplitudes = f_g_calculator.get_current_amplitudes(),
      atomic_base = atomic_base,
      overall_weight = wgts[2],
    )

    f, g = f_g_calculator.compute_functional_and_gradients()

    assert approx_equal(f, flsq+fw1+fw2+fw3)
    assert approx_equal(list(g), list(glsq+gw1+gw2+gw3))

    ########################################################
    # Make some amplitudes negative and recalculate - negative amplitudes should be set to zero
    ########################################################

    # Starting values
    base_amplitudes_start = flex.double(n_grp*n_dst, 0.0)

    functional, gradients = calculate_expected_f_and_g_least_squares(
      n_grp = n_grp,
      n_dst = n_dst,
      n_atm = n_atm,
      target_uijs = target_uijs,
      target_weights = target_weights,
      base_uijs = base_uijs,
      base_sels = base_sels,
      dataset_hash = dataset_hash,
      atomic_base = atomic_base,
      current_amplitudes_base = base_amplitudes_start,
      atomic_mask = atomic_mask,
    )

    f_g_calculator = MultiGroupMultiDatasetUijAmplitudeFunctionalAndGradientCalculator(
      target_uijs = target_uijs,
      target_weights = target_weights,
      base_amplitudes = base_amplitudes_start,
      base_uijs = base_uijs,
      base_atom_indices = base_sels,
      base_dataset_hash = dataset_hash,
      atomic_uijs = atomic_base,
      weight_sum_of_amplitudes = 0.0,
      weight_sum_of_amplitudes_squared = 0.0,
      weight_sum_of_squared_amplitudes = 0.0,
    )
    if atomic_mask:
      f_g_calculator.set_atomic_optimisation_mask(atomic_mask)

    f, g = f_g_calculator.compute_functional_and_gradients()

    assert approx_equal(f, functional)
    assert approx_equal(list(g), list(gradients))

    # Now make some amplitudes negative
    base_amplitudes_start.set_selected(flex.size_t(iran(n_grp*n_dst)), -0.5)
    base_amplitudes_start.set_selected(flex.size_t(iran(n_grp*n_dst)), -200.)

    f_g_calculator = MultiGroupMultiDatasetUijAmplitudeFunctionalAndGradientCalculator(
      target_uijs = target_uijs,
      target_weights = target_weights,
      base_amplitudes = base_amplitudes_start,
      base_uijs = base_uijs,
      base_atom_indices = base_sels,
      base_dataset_hash = dataset_hash,
      atomic_uijs = atomic_base,
      weight_sum_of_amplitudes = 0.0,
      weight_sum_of_amplitudes_squared = 0.0,
      weight_sum_of_squared_amplitudes = 0.0,
    )
    if atomic_mask:
      f_g_calculator.set_atomic_optimisation_mask(atomic_mask)

    f, g = f_g_calculator.compute_functional_and_gradients()

    assert approx_equal(f, functional)
    assert approx_equal(list(g), list(gradients))

  print('OK')

def tst_functional_gradient_calculator_permuted_dataset_order():

  n_grp = 3
  n_dst = 5
  n_atm = 10

  for atomic_mask_size in [None, 1, 2, 3]:
    if atomic_mask_size is not None:
      atomic_mask = flex.bool(n_dst, False)
      n_sel = max(n_dst, atomic_mask_size)
      atomic_mask.set_selected(flex.size_t(iran(n_dst, size=n_sel, replace=False)), True)
      assert sum(atomic_mask) == n_sel
    else:
      atomic_mask = None

    target_uijs, target_weights, \
      base_uijs, base_sels, dataset_hash, \
      atomic_base, \
      real_group_amps, real_atomic_amps \
        = get_optimisation_test_set(n_grp, n_dst, n_atm, random_dataset_order=True)

    # Starting values - randomise
    base_amplitudes_start = flex.random_double(n_grp*n_dst)

    wgts = rran(3)

    f_g_calculator = MultiGroupMultiDatasetUijAmplitudeFunctionalAndGradientCalculator(
      target_uijs = target_uijs,
      target_weights = target_weights,
      base_amplitudes = base_amplitudes_start,
      base_uijs = base_uijs,
      base_atom_indices = base_sels,
      base_dataset_hash = dataset_hash,
      atomic_uijs = atomic_base,
      weight_sum_of_amplitudes = wgts[0],
      weight_sum_of_amplitudes_squared = wgts[1],
      weight_sum_of_squared_amplitudes = wgts[2],
    )
    if atomic_mask:
      f_g_calculator.set_atomic_optimisation_mask(atomic_mask)

    flsq, glsq = calculate_expected_f_and_g_least_squares(
      n_grp = n_grp,
      n_dst = n_dst,
      n_atm = n_atm,
      target_uijs = target_uijs,
      target_weights = target_weights,
      base_uijs = base_uijs,
      base_sels = base_sels,
      dataset_hash = dataset_hash,
      atomic_base = atomic_base,
      current_amplitudes_base = base_amplitudes_start,
      atomic_mask = atomic_mask,
    )

    fw1, gw1 = calculate_expected_f_and_g_sum_of_amplitudes(
      n_grp = n_grp,
      n_dst = n_dst,
      n_atm = n_atm,
      target_weights = target_weights,
      dataset_hash = dataset_hash,
      current_amplitudes = f_g_calculator.get_current_amplitudes(),
      atomic_base = atomic_base,
      overall_weight = wgts[0],
    )

    fw2, gw2 = calculate_expected_f_and_g_sum_of_amplitudes_squared(
      n_grp = n_grp,
      n_dst = n_dst,
      n_atm = n_atm,
      target_weights = target_weights,
      dataset_hash = dataset_hash,
      current_amplitudes = f_g_calculator.get_current_amplitudes(),
      atomic_base = atomic_base,
      overall_weight = wgts[1],
    )

    fw3, gw3 = calculate_expected_f_and_g_sum_of_squared_amplitudes(
      n_grp = n_grp,
      n_dst = n_dst,
      n_atm = n_atm,
      target_weights = target_weights,
      dataset_hash = dataset_hash,
      current_amplitudes = f_g_calculator.get_current_amplitudes(),
      atomic_base = atomic_base,
      overall_weight = wgts[2],
    )

    f, g = f_g_calculator.compute_functional_and_gradients()

    assert approx_equal(f, flsq+fw1+fw2+fw3)
    assert approx_equal(list(g), list(glsq+gw1+gw2+gw3))

  print('OK')

def tst_functional_gradient_calculator_invalid_arguments():
  """Check errors are raised as expected"""

  n_grp = 3
  n_dst = 5
  n_atm = 10

  target_uijs, target_weights, \
    base_uijs, base_sels, dataset_hash, \
    atomic_base, \
    real_group_amps, real_atomic_amps \
      = get_optimisation_test_set(n_grp, n_dst, n_atm)

  ########################################################
  # Check expected error messages are raised
  ########################################################

  # Starting values
  base_amplitudes_start = flex.double(n_grp*n_dst, 1.0)

  wgt_kw_args = dict(
    weight_sum_of_amplitudes = 0.0,
    weight_sum_of_amplitudes_squared = 0.0,
    weight_sum_of_squared_amplitudes = 0.0,
  )

  # Should not error
  f_g_calculator = MultiGroupMultiDatasetUijAmplitudeFunctionalAndGradientCalculator(
    target_uijs = target_uijs,
    target_weights = target_weights,
    base_amplitudes = base_amplitudes_start,
    base_uijs = base_uijs,
    base_atom_indices = base_sels,
    base_dataset_hash = dataset_hash,
    atomic_uijs = atomic_base,
    **wgt_kw_args
  )
  f, g = f_g_calculator.compute_functional_and_gradients()

  # target_uijs

  msg = "invalid target_uijs: must be 2-dimensional flex array (currently 3)"
  with raises(Exception) as e:
    f_g_calculator = MultiGroupMultiDatasetUijAmplitudeFunctionalAndGradientCalculator(
      target_uijs = flex.sym_mat3_double(flex.grid((n_dst-1,n_atm,5)), (1.,1.,1.,0.,0.,0.)),
      target_weights = target_weights,
      base_amplitudes = base_amplitudes_start,
      base_uijs = base_uijs,
      base_atom_indices = base_sels,
      base_dataset_hash = dataset_hash,
      atomic_uijs = atomic_base,
      **wgt_kw_args
    )
  assert msg == str(e.value), '"{}" does not match "{}"'.format(msg, str(e.value))

  # target_weights

  msg = "invalid dimension of target_weights (dimension 3): must be same dimension as target_uijs (dimension 2)"
  with raises(Exception) as e:
    f_g_calculator = MultiGroupMultiDatasetUijAmplitudeFunctionalAndGradientCalculator(
      target_uijs = target_uijs,
      target_weights = flex.double(flex.grid((n_dst,n_atm,5)), 1.0),
      base_amplitudes = base_amplitudes_start,
      base_uijs = base_uijs,
      base_atom_indices = base_sels,
      base_dataset_hash = dataset_hash,
      atomic_uijs = atomic_base,
      **wgt_kw_args
    )
  assert msg == str(e.value)

  msg = "incompatible dimension of target_weights (axis 0): must be same size as target_uijs ({} != {})".format(n_dst, n_dst-1)
  with raises(Exception) as e:
    f_g_calculator = MultiGroupMultiDatasetUijAmplitudeFunctionalAndGradientCalculator(
      target_uijs = flex.sym_mat3_double(flex.grid((n_dst-1,n_atm)), (1.,1.,1.,0.,0.,0.)),
      target_weights = target_weights,
      base_amplitudes = base_amplitudes_start,
      base_uijs = base_uijs,
      base_atom_indices = base_sels,
      base_dataset_hash = dataset_hash,
      atomic_uijs = atomic_base,
      **wgt_kw_args
    )
  assert msg == str(e.value)

  msg = "incompatible dimension of target_weights (axis 1): must be same size as target_uijs ({} != {})".format(n_atm, n_atm+1)
  with raises(Exception) as e:
    f_g_calculator = MultiGroupMultiDatasetUijAmplitudeFunctionalAndGradientCalculator(
      target_uijs = flex.sym_mat3_double(flex.grid((n_dst,n_atm+1)), (1.,1.,1.,0.,0.,0.)),
      target_weights = target_weights,
      base_amplitudes = base_amplitudes_start,
      base_uijs = base_uijs,
      base_atom_indices = base_sels,
      base_dataset_hash = dataset_hash,
      atomic_uijs = atomic_base,
      **wgt_kw_args
    )
  assert msg == str(e.value)

  # base components

  msg = "invalid input base components. base_amplitudes (length {}), base_uijs (length {}) and base_atom_indices (length {}) must all be the same length"
  with raises(Exception) as e:
    f_g_calculator = MultiGroupMultiDatasetUijAmplitudeFunctionalAndGradientCalculator(
      target_uijs = target_uijs,
      target_weights = target_weights,
      base_amplitudes = flex.double(n_grp*n_dst-1, 1.0),
      base_uijs = base_uijs,
      base_atom_indices = base_sels,
      base_dataset_hash = dataset_hash,
      atomic_uijs = atomic_base,
      **wgt_kw_args
    )
  assert msg.format(n_grp*n_dst-1, n_grp*n_dst, n_grp*n_dst) == str(e.value)
  with raises(Exception) as e:
    f_g_calculator = MultiGroupMultiDatasetUijAmplitudeFunctionalAndGradientCalculator(
      target_uijs = target_uijs,
      target_weights = target_weights,
      base_amplitudes = base_amplitudes_start,
      base_uijs = base_uijs[:-1],
      base_atom_indices = base_sels[:-1],
      base_dataset_hash = dataset_hash,
      atomic_uijs = atomic_base,
      **wgt_kw_args
    )
  assert msg.format(n_grp*n_dst, n_grp*n_dst-1, n_grp*n_dst-1) == str(e.value)
  with raises(Exception) as e:
    f_g_calculator = MultiGroupMultiDatasetUijAmplitudeFunctionalAndGradientCalculator(
      target_uijs = target_uijs,
      target_weights = target_weights,
      base_amplitudes = base_amplitudes_start,
      base_uijs = base_uijs[:-1],
      base_atom_indices = base_sels,
      base_dataset_hash = dataset_hash,
      atomic_uijs = atomic_base,
      **wgt_kw_args
    )
  assert msg.format(n_grp*n_dst, n_grp*n_dst-1, n_grp*n_dst) == str(e.value)
  with raises(Exception) as e:
    f_g_calculator = MultiGroupMultiDatasetUijAmplitudeFunctionalAndGradientCalculator(
      target_uijs = target_uijs,
      target_weights = target_weights,
      base_amplitudes = base_amplitudes_start,
      base_uijs = base_uijs,
      base_atom_indices = base_sels[:-1],
      base_dataset_hash = dataset_hash,
      atomic_uijs = atomic_base,
      **wgt_kw_args
    )
  assert msg.format(n_grp*n_dst, n_grp*n_dst, n_grp*n_dst-1) == str(e.value)

  msg = "incompatible pair (element 2) in base_uijs/base_atom_indices: pairwise elements must be the same length ({} and {})".format(n_atm+1, len(base_uijs[2]))
  with raises(Exception) as e:
    f_g_calculator = MultiGroupMultiDatasetUijAmplitudeFunctionalAndGradientCalculator(
      target_uijs = target_uijs,
      target_weights = target_weights,
      base_amplitudes = base_amplitudes_start,
      base_uijs = base_uijs[:2] + [flex.sym_mat3_double(n_atm+1)] + base_uijs[3:],
      base_atom_indices = base_sels,
      base_dataset_hash = dataset_hash,
      atomic_uijs = atomic_base,
      **wgt_kw_args
    )
  assert msg == str(e.value)

  msg = "incompatible pair (element 2) in base_uijs/base_atom_indices: pairwise elements must be the same length ({} and {})".format(len(base_sels[2]), n_atm+1)
  with raises(Exception) as e:
    f_g_calculator = MultiGroupMultiDatasetUijAmplitudeFunctionalAndGradientCalculator(
      target_uijs = target_uijs,
      target_weights = target_weights,
      base_amplitudes = base_amplitudes_start,
      base_uijs = base_uijs,
      base_atom_indices = base_sels[:2] + [flex.size_t_range(n_atm+1)] + base_sels[3:],
      base_dataset_hash = dataset_hash,
      atomic_uijs = atomic_base,
      **wgt_kw_args
    )
  assert msg == str(e.value)

  msg = "invalid selection in base_atom_indices ({}): attempting to select atom outside of array (size {})".format(n_atm, n_atm)
  with raises(Exception) as e:
    f_g_calculator = MultiGroupMultiDatasetUijAmplitudeFunctionalAndGradientCalculator(
      target_uijs = target_uijs,
      target_weights = target_weights,
      base_amplitudes = base_amplitudes_start,
      base_uijs = base_uijs[:2] + [flex.sym_mat3_double(n_atm+1)] + base_uijs[3:],
      base_atom_indices = base_sels[:2] + [flex.size_t_range(n_atm+1)] + base_sels[3:],
      base_dataset_hash = dataset_hash,
      atomic_uijs = atomic_base,
      **wgt_kw_args
    )
  assert msg == str(e.value)

  # dataset_hash

  msg = "invalid base_dataset_hash (length {}): must be same length as base_amplitudes, base_uijs & base_atom_indices (length {})".format(len(dataset_hash)-1, len(dataset_hash))
  with raises(Exception) as e:
    f_g_calculator = MultiGroupMultiDatasetUijAmplitudeFunctionalAndGradientCalculator(
      target_uijs = target_uijs,
      target_weights = target_weights,
      base_amplitudes = base_amplitudes_start,
      base_uijs = base_uijs,
      base_atom_indices = base_sels,
      base_dataset_hash = flex.size_t(list(dataset_hash)[:-1]),
      atomic_uijs = atomic_base,
      **wgt_kw_args
    )
  assert msg == str(e.value), (msg, str(e.value))

  msg = "invalid value in base_dataset_hash ({}): attempts to select element outside range of target_uijs (size {})".format(n_dst-1, n_dst-1)
  with raises(Exception) as e:
    f_g_calculator = MultiGroupMultiDatasetUijAmplitudeFunctionalAndGradientCalculator(
      target_uijs = flex.sym_mat3_double(flex.grid((n_dst-1,n_atm)), (1.,1.,1.,0.,0.,0.)),
      target_weights = flex.double(flex.grid((n_dst-1,n_atm)), 1.0), # need to resize this also
      base_amplitudes = base_amplitudes_start,
      base_uijs = base_uijs,
      base_atom_indices = base_sels,
      base_dataset_hash = dataset_hash,
      atomic_uijs = atomic_base,
      **wgt_kw_args
    )
  assert msg == str(e.value), (msg, str(e.value))

  msg = "Dataset index {} is not present in base_dataset_hash -- this dataset has no base elements associated with it.".format(n_dst)
  with raises(Exception) as e:
    f_g_calculator = MultiGroupMultiDatasetUijAmplitudeFunctionalAndGradientCalculator(
      target_uijs = flex.sym_mat3_double(flex.grid((n_dst+1,n_atm)), (1.,1.,1.,0.,0.,0.)),
      target_weights = flex.double(flex.grid((n_dst+1,n_atm)), 1.0), # need to resize this also
      base_amplitudes = base_amplitudes_start,
      base_uijs = base_uijs,
      base_atom_indices = base_sels,
      base_dataset_hash = dataset_hash,
      atomic_uijs = atomic_base,
      **wgt_kw_args
    )
  assert msg == str(e.value), (msg, str(e.value))

  # atomic uijs

  msg = "invalid size of atomic_uijs ({}): must match 2nd dimension of target_uijs ({})".format(n_atm-1, n_atm)
  with raises(Exception) as e:
    f_g_calculator = MultiGroupMultiDatasetUijAmplitudeFunctionalAndGradientCalculator(
      target_uijs = target_uijs,
      target_weights = target_weights,
      base_amplitudes = base_amplitudes_start,
      base_uijs = base_uijs,
      base_atom_indices = base_sels,
      base_dataset_hash = dataset_hash,
      atomic_uijs = flex.sym_mat3_double(n_atm-1),
      **wgt_kw_args
    )
  assert msg == str(e.value), (msg, str(e.value))

  # atomic mask

  f_g_calculator = MultiGroupMultiDatasetUijAmplitudeFunctionalAndGradientCalculator(
    target_uijs = target_uijs,
    target_weights = target_weights,
    base_amplitudes = base_amplitudes_start,
    base_uijs = base_uijs,
    base_atom_indices = base_sels,
    base_dataset_hash = dataset_hash,
    atomic_uijs = atomic_base,
    **wgt_kw_args
  )
  # should not error
  f_g_calculator.set_atomic_optimisation_mask(flex.bool(n_dst, True))
  f_g_calculator.set_atomic_optimisation_mask(flex.bool(n_dst, False))
  # should error
  msg = "Input array (size {}) must be the same length as number of datasets ({})".format(n_dst-1, n_dst)
  with raises(Exception) as e:
    f_g_calculator.set_atomic_optimisation_mask(flex.bool(n_dst-1, True))
  assert msg == str(e.value)
  msg = "Input array (size {}) must be the same length as number of datasets ({})".format(n_dst+1, n_dst)
  with raises(Exception) as e:
    f_g_calculator.set_atomic_optimisation_mask(flex.bool(n_dst+1, True))
  assert msg == str(e.value)

  # setting amplitudes

  # should not error
  f_g_calculator.set_current_amplitudes(flex.double(n_grp*n_dst+n_atm))
  # should error
  msg = "Input array (size {}) must be the same length as current_amplitudes (size {})".format(n_grp*n_dst+n_atm-1, n_grp*n_dst+n_atm)
  with raises(Exception) as e:
    f_g_calculator.set_current_amplitudes(flex.double(n_grp*n_dst+n_atm-1))
  assert msg == str(e.value)

  print('OK')

if __name__ == "__main__":
  tst_optimisation_weights()
  tst_optimise_amplitudes_single_group()
  tst_optimise_amplitudes_multiple_groups_with_atomic()
  tst_optimise_amplitudes_multiple_groups_permuted_dataset_order()
  tst_functional_gradient_calculator()
  tst_functional_gradient_calculator_permuted_dataset_order()
  tst_functional_gradient_calculator_invalid_arguments()


 *******************************************************************************


 *******************************************************************************
mmtbx/regression/tls/tst_tls_refinement_fft.py
from __future__ import absolute_import, division, print_function
from mmtbx.tls import tools
import mmtbx.f_model
import mmtbx.model
from mmtbx import monomer_library
import mmtbx.monomer_library.server
from cctbx.array_family import flex
from libtbx.test_utils import approx_equal
from libtbx.utils import format_cpu_times
import libtbx.load_env
import random
import sys, os
import iotbx.pdb
from six.moves import zip

def exercise_2(eps = 1.e-6):
###> Get started from PDB
  mon_lib_srv = monomer_library.server.server()
  ener_lib = monomer_library.server.ener_lib()
  pdb_file = libtbx.env.find_in_repositories(
    relative_path="phenix_regression/pdb/phe_abc_tlsanl_out_geometry_minimized.pdb",
    test=os.path.isfile)
  model = mmtbx.model.manager(model_input=iotbx.pdb.input(file_name=pdb_file))
  model.process(make_restraints=True)
  model.setup_scattering_dictionaries(scattering_table="wk1995")
  model.get_xray_structure().convert_to_isotropic()
  u_iso_start = model.get_xray_structure().extract_u_iso_or_u_equiv()
  model.get_xray_structure().convert_to_anisotropic()

  selections = []
  selection_strings = ["chain A", "chain B", "chain C"]
  for string in selection_strings:
      selections.append(model.selection(string = string))
################
  selection = flex.bool(model.get_number_of_atoms(), True)
  class refinement_flags: pass
  refinement_flags.adp_tls = selections
  model.set_refinement_flags(refinement_flags)
  model.determine_tls_groups(selection_strings=selections, generate_tlsos=selections)
  model.set_refinement_flags(refinement_flags)
  xray_structure = model.get_xray_structure()
################
###> Get TLS <-> Ucart
  T_initial = []
  L_initial = []
  S_initial = []
  T_initial.append([0.11,0.22,0.33,0.12,0.13,0.23])
  L_initial.append([1.11,1.22,1.33,1.12,1.13,1.23])
  S_initial.append([0.11,0.12,0.13,0.21,0.22,0.23,0.31,0.32,-0.33])

  T_initial.append([0.22,0.44,0.66,0.24,0.26,0.46])
  L_initial.append([2.22,2.44,2.66,2.24,2.26,2.46])
  S_initial.append([0.22,0.24,0.26,0.42,0.44,0.46,0.62,0.64,-0.66])

  T_initial.append([0.33,0.66,0.99,0.36,0.39,0.69])
  L_initial.append([2.33,2.66,2.99,2.36,2.39,2.69])
  S_initial.append([0.22,0.24,0.26,0.42,0.44,0.46,0.62,0.64,-0.66])

  tlsosA = tools.generate_tlsos(selections     = selections,
                                xray_structure = xray_structure,
                                T              = T_initial,
                                L              = L_initial,
                                S              = S_initial)

  tlsos = tools.generate_tlsos(selections     = selections,
                               xray_structure = xray_structure,
                               T              = T_initial,
                               L              = L_initial,
                               S              = S_initial)
  tlsos = tools.make_tlso_compatible_with_u_positive_definite(
                  tlsos                                       = tlsos,
                  xray_structure                              = xray_structure.deep_copy_scatterers(),
                  selections                                  = selections,
                  max_iterations                              = 50,
                  number_of_u_nonpositive_definite            = 0,
                  eps                                         = eps,
                  number_of_macro_cycles_for_tls_from_uanisos = 30)

  u_cart_answer = tools.u_cart_from_tls(sites_cart = xray_structure.sites_cart(),
                                         selections = selections,
                                         tlsos      = tlsos)
  xray_structure.scatterers().set_u_cart(xray_structure.unit_cell(),
                                                                 u_cart_answer)

  assert approx_equal(u_cart_answer,
        xray_structure.scatterers().extract_u_cart(xray_structure.unit_cell()))


  tools.show_tls(tlsos = tlsos, text = "ANSWER")

###> Set up fmodel
  sfg_params = mmtbx.f_model.sf_and_grads_accuracy_master_params.extract()
  sfg_params.algorithm = "direct"
  sfg_params.cos_sin_table = False
  dummy = xray_structure.structure_factors(algorithm = sfg_params.algorithm,
                                           d_min     = 2.0).f_calc()
  f_obs = abs(dummy.structure_factors_from_scatterers(
                           xray_structure = xray_structure,
                           algorithm      = sfg_params.algorithm,
                           cos_sin_table  = sfg_params.cos_sin_table).f_calc())
  flags = f_obs.generate_r_free_flags(fraction=0.01, max_free=2000)

  fmodel = mmtbx.f_model.manager(xray_structure    = xray_structure,
                                 f_obs             = f_obs,
                                 r_free_flags      = flags,
                                 target_name       = "ls_wunit_k1",
                                 sf_and_grads_accuracy_params = sfg_params)
  fmodel.info(free_reflections_per_bin=250, max_number_of_bins=30).show_all()
  xray_structure.convert_to_isotropic()
  xray_structure.set_b_iso(value = 25.0)
  fmodel.update_xray_structure(xray_structure = xray_structure,
                               update_f_calc  = True)
  fmodel.info(free_reflections_per_bin=250, max_number_of_bins=30).show_all()
  print("*"*80)
###> TLS refinement against xray data
  if (not "--comprehensive" in sys.argv[1:]):
          number_of_macro_cycles   = 1
          max_number_of_iterations = 3
  else:
          number_of_macro_cycles   = 100
          max_number_of_iterations = 50

  for start_tls_value in [None]:#[0.0, tlsosA, None]:
  #for start_tls_value in [None]:
      print(" \n "+str(start_tls_value) + " \n ")
      fmodel_cp = fmodel.deep_copy()
      #for sc in fmodel_cp.xray_structure.scatterers():
      #  sc.flags.set_use_u_aniso(True)
      fmodel_cp.xray_structure.convert_to_anisotropic()

      if(start_tls_value is None):
         run_finite_differences_test = True
      else: run_finite_differences_test = False
      model.set_xray_structure(fmodel_cp.xray_structure)
      tls_refinement_manager = tools.tls_refinement(
                     fmodel                      = fmodel_cp,
                     model                       = model,
                     selections                  = selections,
                     selections_1d               = None,
                     refine_T                    = 1,
                     refine_L                    = 1,
                     refine_S                    = 1,
                     number_of_macro_cycles      = number_of_macro_cycles,
                     max_number_of_iterations    = max_number_of_iterations,
                     start_tls_value             = start_tls_value,
                     run_finite_differences_test = run_finite_differences_test,
                     eps                         = eps)
      u_cart = tls_refinement_manager.fmodel.xray_structure.scatterers().extract_u_cart(
                                                        xray_structure.unit_cell())
      if("--comprehensive" in sys.argv[1:]):
         format   = "%10.6f %10.6f %10.6f %10.6f %10.6f %10.6f"
         counter = 0
         if(start_tls_value == tlsosA): tolerance = 1.e-6
         else: tolerance = 0.02
         for m1,m2 in zip(u_cart_answer, u_cart):
             counter += 1
             if(counter < 10):
                print("1=" + format % (m1[0],m1[1],m1[2],m1[3],m1[4],m1[5]))
                print("2=" + format % (m2[0],m2[1],m2[2],m2[3],m2[4],m2[5]))
             assert approx_equal(m1,m2, tolerance)

def exercise(args):
  forever = False
  random_seed = None
  for arg in args:
    if (arg == "--forever"):
      forever = True
    elif (arg.startswith("--random_seed=")):
      random_seed = int(arg.split("=", 1)[1])
  if (random_seed is None):
    random_seed = flex.get_random_seed()
  while True:
    print("random_seed:", random_seed)
    random.seed(random_seed)
    flex.set_random_seed(value=random_seed)
    exercise_2()
    if (not forever): break
    random_seed += 1
  print(format_cpu_times())

if (__name__ == "__main__"):
  exercise(sys.argv[1:])


 *******************************************************************************


 *******************************************************************************
mmtbx/regression/tls/tst_tls_utils.py
from __future__ import absolute_import, division, print_function

import math
import numpy
from mmtbx.tls.utils import *
from scitbx.array_family import flex
from libtbx.test_utils import approx_equal, not_approx_equal
from libtbx.test_utils import raises
from six.moves import zip
from six.moves import range

rran = numpy.random.random
iran = numpy.random.choice

numpy.random.seed(123232)

TLSMatrices.set_precision(12)
TLSAmplitudes.set_precision(12)

# Maximum tolerable rounding error
MAT_RND_TOL = (0.51)*(10**(-TLSMatrices.get_precision()))
AMP_RND_TOL = (0.51)*(10**(-TLSAmplitudes.get_precision()))
# For errors in the last decimal place
LAST_DP_TOL = 10.0 * max(10**(-TLSMatrices.get_precision()),
              10**(-TLSAmplitudes.get_precision()))

TEST_LENGTHS = [1,2,3]
TEST_TARGETS = [0.25,1.0,3.3]

TLSMATRICES = [
    [0.88875254,0.266694873,0.493991604,-0.280846445,0.018132653,0.128202717,0.109792777,0.143780355,0.111757325,0.00745827,0.044408043,0.004683883,-0.031880059,0.087486387,-0.035440044,0.053723107,-0.093285664,-0.126741771,0.078707102,0.047063985,0.125165723],
    [0.244377462,0.459148081,0.710013128,-0.008898371,0.07279876,0.036277241,3.755718081,2.739489028,2.134579946,-0.200385262,0.074588032,-0.023382499,0.00048379,0.229469716,-0.187382678,-0.05705213,0.308356068,0.219549925,0.260721724,0.137599684,-0.308839858],
    [0.29790555,0.765985455,0.362144247,0.188051876,-0.07468928,0.176222813,1.157009238,1.603540537,1.146982202,0.076470473,0.076337332,-0.036514342,-0.057413883,-0.4930283,-0.141063091,0.199094828,0.180380061,0.564268854,0.271176005,0.192103145,-0.122966178],
    [0.550613174,0.642391951,0.512539873,0.186990637,-0.018948302,0.182865203,0.696794749,1.168473012,1.459255982,0.122241174,-0.070965716,-0.127405648,-0.126672963,-0.057326201,0.307248593,0.23402513,-0.081293525,-0.457364662,-0.270995819,0.131106455,0.207966488],
    [0.801839264,0.111567149,0.473172234,0.111448705,0.01322435,0.053023611,0.119600352,0.158201942,0.501511288,-0.00097325,0.038852731,-0.020179123,0.094859837,0.027409079,0.027958886,-0.036977684,0.115684103,-0.023249574,-0.167599437,0.028274946,-0.21054394],
    [0.476189761,0.185513316,0.494838237,0.079787304,0.186996542,0.089705044,6.468559896,0.03302114,1.360918838,-0.092774147,-0.470033825,0.142680478,0.007373318,0.322513481,-0.087204939,-0.102689013,0.085596047,-0.037679444,-0.183875771,-0.048267033,-0.092969365],
    [0.271946335,0.353828607,0.011539801,-0.012010653,-0.03669219,-0.006760052,23.89487928,3.564598018,0.086574587,-1.913464478,0.89104049,-0.011635907,0.00083053,-0.00120248,-0.06596398,0.059314995,0.042902408,0.001580523,-0.013344186,0.103940739,-0.043732938],
    [0.436887477,0.558232952,0.172244124,0.292168093,-0.130328728,-0.074615062,3.137593554,0.025205525,0.920908537,-0.108005337,0.00472811,0.015510299,-0.000822308,0.118599046,-0.151446932,0.029991796,0.042430554,-0.009368142,0.000888338,0.153578145,-0.041608246],
    [0.507487457,0.513473662,0.465150239,-0.024656406,0.052695005,0.030032721,9.358808433,1.113449297,12.326819619,-0.988256782,1.235061392,-1.371684512,0.454760772,-0.522429055,0.566566556,0.34528893,-0.057886461,-0.28449733,-0.171754982,-0.103504915,-0.396874311],
    [0.708808312,0.55187043,0.429938391,0.197257684,-3.9774e-05,-0.054427743,0.178345211,0.297789551,0.087920317,-0.003702672,-0.002424311,0.000192857,-0.029460632,0.037160795,0.061827225,0.276788373,0.000147768,-0.235898673,0.018602792,-0.125798933,0.029312864],
    [0.151113427,0.654574237,0.240882778,-0.018212974,-0.014025963,0.100180189,0.285310135,2.881490187,11.011691132,-0.437653779,-0.698453455,0.157185441,-0.1905967,-0.166253585,-0.151567002,0.150109019,0.444896847,-0.230918972,0.078079958,0.50626905,-0.254300147],
  ]

# Matrices that are valid if tolerance > 1e-6
LS = (180. / math.pi)**2
INVALID_TLS_MATRICES = [
    [1.,1.,-1e-6,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.],
    [0.,0.,0.,0.,0.,0.,LS,LS,-LS*1e-6,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.],
  ]

def get_TLS_values():
  vals = rran(21)
  obj = TLSMatrices(values=vals)
  assert approx_equal(obj.get("TLS"), vals, MAT_RND_TOL)
  return obj, vals

def get_TLS_amplitudes(n):
  vals = rran(n)
  obj = TLSAmplitudes(values=vals)
  assert approx_equal(obj.values, vals, AMP_RND_TOL)
  return obj, vals

def tst_set_precision():
  for cl in [TLSMatrices, TLSAmplitudes]:
    initial = cl.get_precision()
    for i in range(5):
      precision = i
      cl.set_precision(precision)
      assert precision == cl.get_precision()
    # Check is class method
    precision = 2
    a = cl(list(range(21)))
    b = cl(list(range(21)))
    a.set_precision(precision)
    assert b.get_precision() == precision
    # Set back to original
    cl.set_precision(initial)
    assert cl.get_precision() == initial

  print('OK')

def tst_set_tolerance():
  for cl in [TLSMatrices, TLSAmplitudes]:
    initial = cl.get_tolerance()
    for i in range(6):
      tolerance = 10.0**(-i)
      cl.set_tolerance(tolerance)
      assert tolerance == cl.get_tolerance()
    # Check is class method
    tolerance = 0.1
    a = cl(list(range(21)))
    b = cl(list(range(21)))
    a.set_tolerance(tolerance)
    assert b.get_tolerance() == tolerance
    # Set back to original
    cl.set_tolerance(initial)
    assert cl.get_tolerance() == initial

  print('OK')

def tst_TLSMatrices():
  """Check classes operating as expected (copying where should be copying rather than referencing...)"""

  for _ in range(5):

    # A
    a, a_vals = get_TLS_values()

    # A - with zero trace of S
    a2_vals = a_vals.copy()
    a2_vals[20] = -(
        round(a2_vals[12], a.get_precision()) +
        round(a2_vals[16], a.get_precision())
        )

    # B
    b, b_vals = get_TLS_values()

    # B2 - Test initialisation from matrices
    b2 = TLSMatrices(T=b_vals[0:6], L=b_vals[6:12], S=b_vals[12:21])

    # Addition of another instance
    c = a + b
    c_vals = (a_vals.round(a.get_precision()) + b_vals.round(b.get_precision()))

    # Multiplication by scalar
    d = (5.0*a)
    d_vals = (5.0*a_vals.round(a.get_precision()))

    # Check vals stored and extracted properly
    assert approx_equal(a.T+a.L+a.S, a_vals, MAT_RND_TOL) # matrices are returned as tuples
    assert approx_equal(a.get("TLS"), a_vals, MAT_RND_TOL)
    assert approx_equal(a.get("T"), a_vals[0:6], MAT_RND_TOL)
    assert approx_equal(a.get("L"), a_vals[6:12], MAT_RND_TOL)
    assert approx_equal(a.get("S"), a_vals[12:21], MAT_RND_TOL)
    assert approx_equal(b.get("TLS"), b_vals, MAT_RND_TOL)
    assert approx_equal(b.get("T"), b_vals[0:6], MAT_RND_TOL)
    assert approx_equal(b.get("L"), b_vals[6:12], MAT_RND_TOL)
    assert approx_equal(b.get("S"), b_vals[12:21], MAT_RND_TOL)
    # Check initialisation from matrices
    assert approx_equal(b2.get("TLS"), b_vals, MAT_RND_TOL)
    # Checks addition (needs greater tolerance)
    assert approx_equal(c.get("TLS"), c_vals, MAT_RND_TOL)
    assert approx_equal(c.get("T"), c_vals[0:6], MAT_RND_TOL)
    assert approx_equal(c.get("L"), c_vals[6:12], MAT_RND_TOL)
    assert approx_equal(c.get("S"), c_vals[12:21], MAT_RND_TOL)
    # Checks multiplication by scalar (need greater tolerance)
    assert approx_equal(d.get("TLS"), d_vals, MAT_RND_TOL)
    assert approx_equal(d.get("T"), d_vals[0:6], MAT_RND_TOL)
    assert approx_equal(d.get("L"), d_vals[6:12], MAT_RND_TOL)
    assert approx_equal(d.get("S"), d_vals[12:21], MAT_RND_TOL)

    # Check values are not being added/multiplied in place
    for _ in range(5):
      # Check addition
      assert approx_equal((a+a).get(), (a+a).get(), 0.0)
      # Check left- and right-multiplication
      assert approx_equal((5.0*a).get(), (5.0*a).get(), 0.0)
      assert approx_equal((a*5.0).get(), (a*5.0).get(), 0.0)
      # Check commutativity
      assert approx_equal((5.0*a).get(), (a*5.0).get(), 0.0)
    assert approx_equal(a.get("TLS"), a_vals, MAT_RND_TOL)

    # Check copies - reset
    a_copy = a.copy()
    a_copy.reset()
    assert approx_equal(a.get(), a_vals, MAT_RND_TOL)
    # Check copies - set
    a_copy = a.copy()
    a_copy.set(list(range(21)))
    assert approx_equal(a.get(), a_vals, MAT_RND_TOL)
    # Check initialisation from other does not affect original
    a_copy = TLSMatrices(a)
    assert approx_equal(a_copy.get(), a_vals, MAT_RND_TOL)
    a_copy.reset()
    assert approx_equal(a.get(), a_vals, MAT_RND_TOL)

    # Check addition in place
    a.add(b)
    assert approx_equal(a.get(), c_vals, MAT_RND_TOL)
    assert approx_equal(b.get(), b_vals, MAT_RND_TOL) # Check b unchanged
    # Check multiplication in place
    a.multiply(10.0)
    assert approx_equal(a.get(), 10.0*c_vals, MAT_RND_TOL)
    # set back to original values
    a.set(a_vals, "TLS")
    assert approx_equal(a.get(), a_vals, MAT_RND_TOL)

    # Order of the letters should not matter (always returns T-L-S)
    assert a.get("TL") == a.get("LT")
    assert a.get("LS") == a.get("SL")
    assert a.get("TS") == a.get("ST")
    assert a.get("TLS") == a.get("STL")
    assert a.get("TLS") == a.get("LST")
    assert a.get("TLS") == a.get("TSL")
    assert a.get("TLS") == a.get("LTS")
    assert a.get("TLS") == a.get("SLT")

    # Check values can be replaced correctly
    assert approx_equal(a.get(), a_vals, MAT_RND_TOL) # Check values are correct at start
    # T
    new_t = rran(6).tolist()
    a.set(values=new_t, component_string="T")
    assert approx_equal(a.get("T"), new_t, MAT_RND_TOL)
    # L
    new_l = rran(6).tolist()
    a.set(values=new_l, component_string="L")
    assert approx_equal(a.get("L"), new_l, MAT_RND_TOL)
    # S but not Szz
    new_s = rran(8).tolist()
    a.set(new_s, "S", include_szz=False)
    new_s_all = new_s + [-(round(new_s[0], a.get_precision()) + round(new_s[4], a.get_precision()))]
    assert len(new_s_all) == 9
    assert approx_equal(a.get("S"), new_s_all, MAT_RND_TOL)
    assert approx_equal(a.get("S")[8], new_s_all[8]) # This number is pre-rounded so should be "exact""
    # S
    new_s = rran(9).tolist()
    a.set(new_s, "S", include_szz=True)
    assert approx_equal(a.get("S"), new_s, MAT_RND_TOL)
    # all
    assert approx_equal(a.get(), new_t+new_l+new_s, MAT_RND_TOL)
    assert approx_equal(a.get("TLS"), new_t+new_l+new_s, MAT_RND_TOL)
    # set all values except Szz
    a.set(a_vals[:-1], "TLS", include_szz=False)
    assert approx_equal(a.get(), a2_vals, MAT_RND_TOL)
    assert approx_equal(a.get()[20], a2_vals[20]) # This number is pre-rounded in a2_vals
    # set back to original values
    a.set(a_vals, "TLS", include_szz=True)
    assert approx_equal(a.get(), a_vals, MAT_RND_TOL)

  print('OK')

def tst_TLSMatrices_counts():
  """Test that number of non-zero parameters are identifed correctly, etc"""

  letter_combinations = ["T","L","S","TL","LS","TS","TLS"]

  for _ in range(5):

    # Get values & object
    a, a_vals = get_TLS_values()
    assert (a_vals!=0.0).all()
    # Test reset function
    a.reset()
    assert approx_equal(a.get(), [0.0]*21, 0.0)

    # Test setting values to zero
    for letts in [""]+letter_combinations:
      # Get a fresh set of matrices each time
      a, a_vals = get_TLS_values()
      assert (a_vals!=0.0).all()
      # Set selected matrices to zero
      for l in letts:
        v = a.get(l)
        a.set([0.0]*len(v), l)
      # Test ANY
      for t_l in letter_combinations:
        non_zero_l = ''.join(set(t_l).difference(letts))
        ret = a.any(t_l)
        assert ret == bool(non_zero_l)
        # High tolerance -- always false
        assert not a.any(t_l, 1e3)
      # Test NPARAMS (number of non-zero values)
      if letts == "":
        n_non_zero = 21
      else:
        n_non_zero = 21 - len(a.get(letts))
      assert a.n_params(free=False, non_zero=True) == n_non_zero
      assert a.n_params(free=True, non_zero=True) == n_non_zero - int("S" not in letts)

    # Test setting values to non-zero
    for letts in [""]+letter_combinations:
      # Get a fresh set of matrices each time
      a = TLSMatrices()

      # Set random values that should be rounded to zero
      for l in letts:
        v = list(a.get(l))
        i = numpy.random.randint(len(v))
        v[i] = 0.49*(10.**(-a.get_precision()))
        a.set(v, l)
      # Test ANY
      for t_l in letter_combinations:
        ret = a.any(t_l)
        assert ret == False # ALL values should have rounded to zero
        # High tolerance -- always false
        assert not a.any(t_l, 1e3)
      # Test NPARAMS
      assert a.n_params(free=False, non_zero=True) == 0
      assert a.n_params(free=True, non_zero=True) == 0
      assert a.n_params(free=False, non_zero=False) == 21
      assert a.n_params(free=True, non_zero=False) == 20

      # Set selected matrices to non-zero
      for l in letts:
        v = list(a.get(l))
        i = numpy.random.randint(len(v))
        # Set values just abovd the rounding/tolerance limit
        v[i] = 2.0*max(10.**(-a.get_precision()), a.get_tolerance())
        a.set(v, l)
      # Test ANY
      for t_l in letter_combinations:
        non_zero_l = ''.join(set(t_l).intersection(letts))
        ret = a.any(t_l)
        assert ret == bool(non_zero_l)
        # High tolerance -- always false
        assert not a.any(t_l, 1e3)
      # Test NPARAMS (number of non-zero values)
      if letts == "":
        n_non_zero = 0
      else:
        n_non_zero = len(a.get(letts))
      assert a.n_params(free=False, non_zero=True) == n_non_zero
      assert a.n_params(free=True, non_zero=True) == n_non_zero - int("S" in letts)
      assert a.n_params(free=False, non_zero=False) == 21
      assert a.n_params(free=True, non_zero=False) == 20

  print('OK')

def tst_TLSMatrices_fails():
  """Check that exceptions are raised where expected"""

  # Tolerances & Precision
  with raises(Exception) as e:
    TLSMatrices.set_precision(2.3) # must be int
  with raises(Exception) as e:
    TLSMatrices.set_tolerance(-0.1) # must be greater than 0.0
  with raises(Exception) as e:
    TLSMatrices.set_tolerance(0.0) # must be greater than 0.0

  # Check doesn't error with the correct length
  a = TLSMatrices(T=list(range(6)), L=list(range(6)), S=list(range(9)))

  # Check length of input matrices
  for tt,ll,ss in [
      (5, 6, 9),
      (7, 6, 9),
      (6, 5, 9),
      (6, 7, 9),
      (6, 6, 8),
      (6, 6, 10),
      ]:
    with raises(Exception) as e:
      a = TLSMatrices(rran(tt),rran(ll),rran(ss))
    assert "Python argument types in" in str(e.value)

  # Check setting values with incorrect size array
  msg = "Mismatch between the length of the selected matrices and the length of the input array"
  a = TLSMatrices()
  for l, sel in [
      (6,  "T"),
      (6,  "L"),
      (9,  "S"),
      (12, "TL"),
      (15, "TS"),
      (15, "LS"),
      (21, "TLS"),
      ]:
    a.set(rran(l), sel)
    with raises(Exception) as e:
      a.set(rran(l-1), sel)
    assert msg == str(e.value)
    with raises(Exception) as e:
      a.set(rran(l+1), sel)
    assert msg == str(e.value)
    if "S" in sel:
      a.set(rran(l-1), sel, include_szz=False)
      with raises(Exception) as e:
        a.set(rran(l-2), sel, include_szz=False)
      assert msg == str(e.value)
      with raises(Exception) as e:
        a.set(rran(l), sel, include_szz=False)
      assert msg == str(e.value)

  # Check length of input array
  for i in [20,22]:
    with raises(Exception) as e:
      a = TLSMatrices(list(range(i)))
    assert "Input values must have length 21" == str(e.value)

  # Invalid letters in the selection strings
  a = TLSMatrices(TLSMATRICES[0])
  for s in ["", "F", "TLSD", "2T"]:
    with raises(ValueError) as e:
      a.any(s)
    if not s:
      assert "Empty string provided: '{}'".format(s) == str(e.value)
    else:
      assert "Invalid letters in string (not T, L or S): '{}'".format(s) == str(e.value)

    with raises(ValueError) as e:
      a.get(s)
    if not s:
      assert "Empty string provided: '{}'".format(s) == str(e.value)
    else:
      assert "Invalid letters in string (not T, L or S): '{}'".format(s) == str(e.value)

  # Multipliers must be positive
  with raises(Exception) as e:
    a.multiply(-0.1) # must be greater than 0.0
  assert "Multiplier must be positive" == str(e.value)

  a.multiply(0.0) # can be equal to zero!

  # Negative tolerances!
  msg = "Tolerance provided must either be positive or -1"
  # Allowed to be -1
  a.any("TLS", -1)
  # Any
  with raises(Exception) as e:
    a.any("TLS", -0.1)
  assert msg == str(e.value)
  # Decompose
  with raises(Exception) as e:
    a.decompose(-0.1)
  assert msg == str(e.value)
  # Valid
  with raises(Exception) as e:
    a.is_valid(-0.1)
  assert msg == str(e.value)
  # Normalise
  with raises(Exception) as e:
    a.normalise([(1,2,3)],(0,0,0),1.0,-0.1)
  assert msg == str(e.value)

  # Negative/zero-value target values!
  msg = "target must be positive"
  with raises(Exception) as e:
    a.normalise([(1,2,3)],(0,0,0),0.0)
  assert msg == str(e.value)
  with raises(Exception) as e:
    a.normalise([(1,2,3)],(0,0,0),-1.0)
  assert msg == str(e.value)

  print('OK')

def tst_TLSMatrices_uijs():
  """Check that uijs are generated from coordinates as expected"""

  from mmtbx.tls import tlso, uaniso_from_tls_one_group
  from scitbx.linalg.eigensystem import real_symmetric

  for vals in TLSMATRICES:

    # Initialise
    a = TLSMatrices(vals)
    # Test sets of matrices are valid
    assert a.is_valid()

    # Get a set of random coordinates
    n_atm = 5
    coords = rran(n_atm*3).reshape(n_atm,3)
    origin = rran(3)

    # Reference Uijs
    tls_obj = tlso(t=a.T, l=a.L, s=a.S, origin=(0.0,0.0,0.0)) # Set origin to zero and subtract from coords as manual check
    uij_ref = uaniso_from_tls_one_group(tls_obj, coords-origin, zeroize_trace=False)
    uij_ref_np = numpy.array(uij_ref)

    # Uijs from the class being tested
    uij_test = a.uijs(coords, origin)
    uij_test_np = numpy.array(uij_test)

    # Compare (should be identical because class calls the uaniso function)
    assert approx_equal(uij_ref_np.flatten(), uij_test_np.flatten(), 0.0)

    # Calculate average eigenvalue of output uijs
    # TODO: verify that real_symmetric returns non-dict, I assume its an eigensystem-y instance
    eigs = [real_symmetric(u).values() for u in uij_test]
    orig_mean_eig = numpy.mean(eigs)

    for target in TEST_TARGETS:
      # Extract copy to test normalisation
      b = a.copy()
      # Normalise
      mult = b.normalise(coords, origin, target=target)
      assert approx_equal(orig_mean_eig, target*mult, LAST_DP_TOL)
      # Extract normalised uijs
      uij_norm = b.uijs(coords, origin)
      uij_norm_np = numpy.array(uij_norm)
      # Check average eigenvalue
      # TODO: see above todo
      eigs = [real_symmetric(u).values() for u in uij_norm]
      mean_eig_norm = numpy.mean(eigs)
      assert approx_equal(mean_eig_norm, target, LAST_DP_TOL)
      # Check that normalised values related to original values by multiplier
      uij_comp_np = mult*uij_norm_np
      assert approx_equal(uij_comp_np.flatten(), uij_test_np.flatten(), LAST_DP_TOL)

  print('OK')

def tst_TLSAmplitudes():
  """Exercise the TLSAmplitudes class"""

  for length in TEST_LENGTHS:

    # Initialise from array
    a, a_vals = get_TLS_amplitudes(length)

    # Initialise from length
    b = TLSAmplitudes(length)
    assert b.size() == length
    # Check values intialised to 1
    assert approx_equal(b.values, [1.0]*length, 0.0)
    # Set values using set function
    b_vals = rran(length)
    b.set(b_vals)
    assert approx_equal(b.values, b_vals, AMP_RND_TOL)

    # Addition of another instance
    c = a + b
    c_vals = (a_vals.round(a.get_precision()) + b_vals.round(b.get_precision()))

    # Multiplication by scalar
    d = (5.0*a)
    d_vals = (5.0*a_vals.round(a.get_precision()))

    # Intialise from other
    e = TLSAmplitudes(a)

    # Check initial values
    assert approx_equal(a.values, a_vals, AMP_RND_TOL)
    assert approx_equal(b.values, b_vals, AMP_RND_TOL)
    assert approx_equal(c.values, c_vals, AMP_RND_TOL)
    assert approx_equal(d.values, d_vals, AMP_RND_TOL)
    assert approx_equal(e.values, a_vals, AMP_RND_TOL)
    assert approx_equal(e.values, a.values, 0.0)

    assert a.any()
    assert b.any()
    assert c.any()
    assert d.any()
    assert e.any()

    assert not a.any(1e3)
    assert not b.any(1e3)
    assert not c.any(1e3)
    assert not d.any(1e3)
    assert not e.any(1e3)

    assert a.size() == length
    assert b.size() == length
    assert c.size() == length
    assert d.size() == length
    assert e.size() == length

    # Check get
    assert approx_equal(a.values, a.get(list(range(a.size()))), 0.0)
    assert approx_equal(b.values, b.get(list(range(b.size()))), 0.0)
    assert approx_equal(c.values, c.get(list(range(c.size()))), 0.0)
    assert approx_equal(d.values, d.get(list(range(d.size()))), 0.0)
    assert approx_equal(e.values, e.get(list(range(e.size()))), 0.0)

    # Check reset works
    e.reset()
    assert approx_equal(e.values, [1.0]*e.size(), 0.0)
    assert e.any()
    # Check that a is unchanged by e.reset())
    assert approx_equal(a.values, a_vals, AMP_RND_TOL)

    # Check values are not being added/multiplied in place
    for _ in range(5):
      # Check addition
      assert approx_equal((a+a).values, (a+a).values, 0.0)
      # Check left- and right-multiplication
      assert approx_equal((5.0*a).values, (5.0*a).values, 0.0)
      assert approx_equal((a*5.0).values, (a*5.0).values, 0.0)
      # Check commutativity
      assert approx_equal((5.0*a).values, (a*5.0).values, 0.0)
    # Final check against initial values
    assert approx_equal(a.values, a_vals, AMP_RND_TOL)

    # Check indexing
    for i in range(a.size()):
      assert approx_equal(a[i], a_vals[i], AMP_RND_TOL)

    # Check addition in place
    a.add(b)
    assert approx_equal(a.values, c_vals, AMP_RND_TOL)
    assert approx_equal(b.values, b_vals, AMP_RND_TOL) # Check b unchanged
    # Check multiplication in place
    mult = 10.0
    a.multiply(mult)
    assert approx_equal(a.values, mult*c_vals, AMP_RND_TOL)
    # set back to original values
    a.set(a_vals)
    assert approx_equal(a.values, a_vals, AMP_RND_TOL)
    assert approx_equal(b.values, b_vals, AMP_RND_TOL)

    # Test setting subset of values
    selection = iran(a.size(), size=min(3,a.size()), replace=False)
    new_vals = rran(len(selection)).tolist()
    chg_a_vals = a_vals.copy()
    assert approx_equal(a_vals, chg_a_vals, 0.0)
    for new_idx, chg_idx in enumerate(selection):
      assert chg_a_vals[chg_idx] != new_vals[new_idx] # Check that new values are different!
      chg_a_vals[chg_idx] = new_vals[new_idx]
    assert approx_equal(chg_a_vals[selection], new_vals, AMP_RND_TOL) # Check that values are set correctly
    a_chg = a.copy()
    assert approx_equal(a_chg.values, a_vals, AMP_RND_TOL)
    a_chg.set(new_vals, list(selection.astype(numpy.uint)))
    assert approx_equal(a_chg.values, chg_a_vals, AMP_RND_TOL)

    # Test reset and n_params
    for _ in range(5):

      # All non-zero
      assert a_vals.all()
      assert a.any()
      assert approx_equal(a.values, a_vals, AMP_RND_TOL)
      assert a.n_params(non_zero=True) == a.size()
      assert a.n_params(non_zero=False) == a.size()

      # Set all values to one
      a.reset()
      assert a.any()
      assert approx_equal(a.values, [1.0]*a.size(), 0.0)
      assert a.n_params(non_zero=True) == a.size()
      assert a.n_params(non_zero=False) == a.size()
      # Set some values to non-one
      selection = iran(a.size(), size=min(3,a.size()), replace=False).tolist()
      new_vals = rran(len(selection)).tolist()
      a.set(new_vals, selection)
      for i, v in enumerate(a.values):
        if i in selection:
          assert approx_equal(v, new_vals[selection.index(i)], AMP_RND_TOL)
        else:
          assert v == 1.0
      assert a.n_params(non_zero=True) == a.size() - new_vals.count(0.0)
      assert a.n_params(non_zero=False) == a.size()

      # Set all values to zero
      a.zero_values()
      assert not a.any()
      assert approx_equal(a.values, [0.0]*a.size(), 0.0)
      assert a.n_params(non_zero=True) == 0
      assert a.n_params(non_zero=False) == a.size()
      # Set some values to non-zero
      selection = iran(a.size(), size=min(3,a.size()), replace=False).tolist()
      new_vals = rran(len(selection)).tolist()
      a.set(new_vals, selection)
      for i, v in enumerate(a.values):
        if i in selection:
          assert approx_equal(v, new_vals[selection.index(i)], AMP_RND_TOL)
        else:
          assert v == 0.0
      assert a.n_params(non_zero=True) == len(new_vals) - new_vals.count(0.0)
      assert a.n_params(non_zero=False) == a.size()
      assert a.any()

      # Set all values to original
      a.set(a_vals.tolist(), list(range(a.size()))) # set all values by selection, just to mix things up
      assert approx_equal(a.values, a_vals, AMP_RND_TOL)
      assert a.n_params(non_zero=True) == a.size()
      assert a.n_params(non_zero=False) == a.size()
      # Set some values to zero
      new_vals = [0.0, 100.0, 0.0, 34.5, 1e-4, -1e-4][:a.size()] # make sure values not longer than a
      selection = iran(a.size(), size=len(new_vals), replace=False).tolist()
      assert len(selection) == len(new_vals)
      a.set(new_vals, selection)
      for i, v in enumerate(a.values):
        if i in selection:
          assert approx_equal(v, new_vals[selection.index(i)], AMP_RND_TOL)
        else:
          assert approx_equal(v, a_vals[i], AMP_RND_TOL)
      assert a.n_params(non_zero=True) == a.size() - numpy.round(new_vals, a.get_precision()).tolist().count(0.0)
      assert a.n_params(non_zero=False) == a.size()

      # Set all values to original
      a.set(a_vals.tolist(), list(range(a.size()))) # set all values by selection, just to mix things up
      assert approx_equal(a.values, a_vals, AMP_RND_TOL)
      assert a.n_params(non_zero=True) == a.size()
      assert a.n_params(non_zero=False) == a.size()
      # Set some values to negative
      selection = iran(a.size(), size=min(4,a.size()), replace=False).tolist()
      new_vals = [-1.0*v for v in a.get(selection)]
      a.set(new_vals, selection)
      for i, v in enumerate(a.values):
        if i in selection:
          assert approx_equal(v, -a_vals[i], AMP_RND_TOL)
        else:
          assert approx_equal(v, a_vals[i], AMP_RND_TOL)
      assert a.n_params(non_zero=True) == a.size()
      assert a.n_params(non_zero=False) == a.size()
      # Zero negative values and test they are zero
      a.zero_negative_values()
      for i, v in enumerate(a.values):
        if i in selection:
          assert v == 0.0
        else:
          assert approx_equal(v, a_vals[i], AMP_RND_TOL)
      assert a.n_params(non_zero=True) == a.size() - len(selection)
      assert a.n_params(non_zero=False) == a.size()

      # Reset for next loop, etc
      a.set(a_vals.tolist(), list(range(a.size()))) # set all values by selection, just to mix things up
      assert approx_equal(a.values, a_vals, AMP_RND_TOL)
      assert a.n_params(non_zero=True) == a.size()
      assert a.n_params(non_zero=False) == a.size()

  print('OK')

def tst_TLSAmplitudes_fails():
  """Check that exceptions are raised where expected"""

  # Tolerances & Precision
  with raises(Exception) as e:
    TLSAmplitudes.set_precision(2.3) # must be int
  with raises(Exception) as e:
    TLSAmplitudes.set_tolerance(-0.1) # must be greater than 0.0
  with raises(Exception) as e:
    TLSAmplitudes.set_tolerance(0.0) # must be greater than 0.0

  with raises(Exception) as e:
    TLSAmplitudes(0)

  a = TLSAmplitudes(10)
  b = TLSAmplitudes(11)

  # Adding incompatible lengths
  with raises(Exception) as e:
    a+b
  assert "TLSAmplitudes must have the same length" == str(e.value)
  with raises(Exception) as e:
    a.add(b)
  assert "TLSAmplitudes must have the same length" == str(e.value)

  # Negative tolerances!
  msg = "Tolerance provided must either be positive or -1"
  # Allowed to be -1
  a.any(-1)
  # Any
  with raises(Exception) as e:
    a.any(-0.1)
  assert msg == str(e.value)

  # Invalid selections!
  with raises(Exception) as e:
    a.get([])
  assert "No indices given for selection" == str(e.value)
  with raises(Exception) as e:
    a.get([a.size()])
  assert "Selection indices out of range of TLSAmplitudes" == str(e.value)
  with raises(Exception) as e:
    a.get(list(range(a.size()))+[0])
  assert "Selection indices cannot be longer than TLSAmplitudes" == str(e.value)

  # Valid, but odd, selections -- maybe change later
  a.get([1,1,1,1])

  # Invalid selections -- setting values
  with raises(Exception) as e:
    a.set(list(range(a.size()-1)))
  assert "Input array must be the same length as TLSAmplitudes" == str(e.value)
  with raises(Exception) as e:
    a.set(list(range(a.size()+1)))
  assert "Input array must be the same length as TLSAmplitudes" == str(e.value)
  # No selection
  with raises(Exception) as e:
    a.set([],[])
  assert "No indices given for selection" == str(e.value)
  # Negative indices!
  with raises(Exception) as e:
    a.set([],[])
  assert "No indices given for selection" == str(e.value)
  # Mismatching size
  for n in range(1,a.size()):
    with raises(Exception) as e:
      a.set(rran(n-1), iran(a.size(), size=n, replace=False).astype(numpy.uint))
    assert "Input values must be the same length as input selection" == str(e.value)
    with raises(Exception) as e:
      a.set(rran(n+1), iran(a.size(), size=n, replace=False).astype(numpy.uint))
    assert "Input values must be the same length as input selection" == str(e.value)
  # Negative indices
  with raises(OverflowError) as e:
    a.set([1], [-1])
  assert ("can't convert negative value to unsigned" == str(e.value) or
          "negative overflow" in str(e.value) or
          "can't convert negative value to unsigned" in str(e.value))

  # Negative/zero-value target values!
  msg = "target must be positive"
  with raises(Exception) as e:
    a.normalise(0.0)
  assert msg == str(e.value)
  with raises(Exception) as e:
    a.normalise(-1.0)
  assert msg == str(e.value)

  print('OK')

def tst_TLSMatricesAndAmplitudes():
  """Exercise the TLSMatricesAndAmplitudes class"""

  for length in TEST_LENGTHS:

    # Iterate through test matrices
    for a_mats in TLSMATRICES:
      a_amps = rran(length)
      # Initialise from existing classes (objects are passed by reference!)
      a_m = TLSMatrices(a_mats)
      a_a = TLSAmplitudes(a_amps)
      a = TLSMatricesAndAmplitudes(a_m, a_a)

      # Check values passed through
      assert approx_equal(a.matrices.get("TLS"), a_mats, MAT_RND_TOL)
      assert approx_equal(a.amplitudes.values     , a_amps, AMP_RND_TOL)
      # Double check that values are the same
      assert approx_equal(a_m.T, a.matrices.T, 0.0)
      assert approx_equal(a_m.L, a.matrices.L, 0.0)
      assert approx_equal(a_m.S, a.matrices.S, 0.0)
      assert approx_equal(a_a.values, a.amplitudes.values, 0.0)

      # Initialise from other
      b = TLSMatricesAndAmplitudes(a)
      assert approx_equal(b.matrices.get("TLS"), a.matrices.get("TLS"), 0.0)
      assert approx_equal(b.amplitudes.values  , a.amplitudes.values, 0.0)

      # Initialise from copy
      c = a.copy()
      assert approx_equal(c.matrices.get("TLS"), a.matrices.get("TLS"), 0.0)
      assert approx_equal(c.amplitudes.values  , a.amplitudes.values, 0.0)

      # Initialise from length
      d = TLSMatricesAndAmplitudes(length)

      # Initialise straight from values
      e = TLSMatricesAndAmplitudes(a_mats, a_amps)

      # Check that a is using objects by reference, and that b & c are initialised by values from a
      a.reset()
      assert approx_equal(a.matrices.get("TLS"), [0.0]*21, 0.0)
      assert approx_equal(a.amplitudes.values  , [1.0]*length, 0.0)
      # Original objects should also be affected (same object)
      assert approx_equal(a_m.get("TLS")     , [0.0]*21, 0.0)
      assert approx_equal(a_a.values          , [1.0]*length, 0.0)
      # Check b & c are not reset (copied by reference)
      assert approx_equal(b.matrices.get("TLS"), a_mats, MAT_RND_TOL)
      assert approx_equal(b.amplitudes.values  , a_amps, AMP_RND_TOL)
      assert approx_equal(c.matrices.get("TLS"), a_mats, MAT_RND_TOL)
      assert approx_equal(c.amplitudes.values  , a_amps, AMP_RND_TOL)
      # Reset b and check c unaffected
      b.reset()
      assert approx_equal(b.matrices.get("TLS"), [0.0]*21, 0.0)
      assert approx_equal(b.amplitudes.values  , [1.0]*length, 0.0)
      assert approx_equal(c.matrices.get("TLS"), a_mats, MAT_RND_TOL)
      assert approx_equal(c.amplitudes.values  , a_amps, AMP_RND_TOL)

      # Check d that defaults are intialised as expected
      assert approx_equal(d.matrices.get("TLS"), [0.0]*21, 0.0)
      assert approx_equal(d.amplitudes.values  , [1.0]*length, 0.0)

      # Check e is initialised correctly
      assert approx_equal(e.matrices.get("TLS"), a_mats, MAT_RND_TOL)
      assert approx_equal(e.amplitudes.values  , a_amps, AMP_RND_TOL)

  print('OK')

def tst_TLSMatricesAndAmplitudes_counts():
  """Test that number of non-zero parameters are identifed correctly, etc"""

  for length in TEST_LENGTHS:

    # Iterate through test matrices
    for a_mats in TLSMATRICES:
      a_amps = rran(length)
      a = TLSMatricesAndAmplitudes(a_mats, a_amps.tolist())
      assert approx_equal(a.matrices.get("TLS"), a_mats, MAT_RND_TOL)
      assert approx_equal(a.amplitudes.values     , a_amps, AMP_RND_TOL)

      # Check tolerances
      assert not a.is_null()
      assert not a.is_null(-1, -1)
      assert not a.is_null(0.0, 0.0)
      assert a.is_null(1e3, -1)
      assert a.is_null(-1, 1e3)
      assert a.is_null(1e3, 1e3)

      # Check null function + n_params
      assert not a.is_null()
      # All should be non-zero
      assert a.n_params(free=True, non_zero=True)   == 20 + length
      assert a.n_params(free=True, non_zero=False)  == 20 + length
      assert a.n_params(free=False, non_zero=True)  == 21 + length
      assert a.n_params(free=False, non_zero=False) == 21 + length
      # Set matrices to zero
      a.matrices.reset()
      assert a.is_null()
      # Matrices are null, amplitudes not
      assert a.n_params(free=True, non_zero=True)   == length
      assert a.n_params(free=True, non_zero=False)  == 20 + length
      assert a.n_params(free=False, non_zero=True)  == length
      assert a.n_params(free=False, non_zero=False) == 21 + length
      # Reset back to original values
      a.matrices.set(a_mats)
      assert not a.is_null()
      # All should be non-zero
      assert a.n_params(free=True, non_zero=True)   == 20 + length
      assert a.n_params(free=True, non_zero=False)  == 20 + length
      assert a.n_params(free=False, non_zero=True)  == 21 + length
      assert a.n_params(free=False, non_zero=False) == 21 + length
      # Set amplitudes to one -- NOT NULL
      a.amplitudes.reset()
      assert not a.is_null()
      # Amplitudes are all one
      assert a.n_params(free=True, non_zero=True)   == 20 + length
      assert a.n_params(free=True, non_zero=False)  == 20 + length
      assert a.n_params(free=False, non_zero=True)  == 21 + length
      assert a.n_params(free=False, non_zero=False) == 21 + length
      # Set amplitudes to zero -- NULL
      a.amplitudes.zero_values()
      assert a.is_null()
      # Amplitudes are all one
      assert a.n_params(free=True, non_zero=True)   == 20
      assert a.n_params(free=True, non_zero=False)  == 20 + length
      assert a.n_params(free=False, non_zero=True)  == 21
      assert a.n_params(free=False, non_zero=False) == 21 + length

      # Reset to original values
      a.amplitudes.set(a_amps)
      assert approx_equal(a.matrices.get("TLS"), a_mats, MAT_RND_TOL)
      assert approx_equal(a.amplitudes.values     , a_amps, AMP_RND_TOL)
      assert not a.is_null()

  print('OK')

def tst_TLSMatricesAndAmplitudes_fails():
  """Check that exceptions are raised where expected"""

  m=TLSMatrices()
  a=TLSAmplitudes(10)
  with raises(Exception) as e:
    TLSMatricesAndAmplitudes(m,m)
  with raises(Exception) as e:
    TLSMatricesAndAmplitudes(a,a)
  with raises(Exception) as e:
    TLSMatricesAndAmplitudes(a,m)

  with raises(Exception) as e:
    TLSMatricesAndAmplitudes(rran(20), rran(10))
  assert "Matrix values must have length 21" == str(e.value)

  with raises(Exception) as e:
    TLSMatricesAndAmplitudes(rran(20), rran(10))
  assert "Matrix values must have length 21" == str(e.value)

  with raises(Exception) as e:
    TLSMatricesAndAmplitudes(rran(10), rran(21))
  assert "Matrix values must have length 21" == str(e.value)

  with raises(Exception) as e:
    TLSMatricesAndAmplitudes(rran(21), [])
  assert "Amplitude values must have length greater than 0" == str(e.value)

  # For use throughout
  n_dst = 3
  n_atm = 2
  assert n_dst>2 # needed for later
  assert n_atm>1 # needed for later
  assert n_dst != n_atm # need different otherwise cannot test for swaps of n_dst and n_atm
  ma = TLSMatricesAndAmplitudes(n_dst)

  # Tolerances
  ma.is_null(0.0, 0.0) # values can be zero
  ma.is_null(-1, -1) # values can be -1
  msg = "Tolerance provided must either be positive or -1"
  with raises(Exception) as e:
    ma.is_null(-0.1, -1)
  assert msg == str(e.value)
  with raises(Exception) as e:
    ma.reset_if_null(-0.1, -1)
  assert msg == str(e.value)
  with raises(Exception) as e:
    ma.is_null(-1, -0.1)
  assert msg == str(e.value)
  with raises(Exception) as e:
    ma.reset_if_null(-1, -0.1)
  assert msg == str(e.value)

  # Coordinates sets for following tests
  sites = flex.vec3_double(rran(n_dst*n_atm*3).reshape(n_dst*n_atm, 3).tolist())
  sites.reshape(flex.grid(n_dst,n_atm))
  origins = rran(n_dst*3).reshape(n_dst,3)

  # Check this doesn't break it
  ma.copy().normalise_by_amplitudes(1.0)
  ma.copy().normalise_by_matrices(sites, origins, 1.0)
  # Normalise (target values)
  msg = "target must be positive"
  with raises(Exception) as e:
    ma.normalise_by_amplitudes(-0.1)
  assert msg == str(e.value)
  with raises(Exception) as e:
    ma.normalise_by_matrices(sites, origins, -0.1)
  assert msg == str(e.value)

  # Compatibility of sites/origins arrays (normalise and uijs)
  # Array has swapped axes
  msg = "Mismatch between the size of origins and first dimension of sites_carts"
  new_sites = flex.vec3_double(rran(n_dst*n_atm*3).reshape(n_dst*n_atm, 3).tolist())
  new_sites.reshape(flex.grid(n_atm,n_dst)) # swap axes
  with raises(Exception) as e:
    ma.normalise_by_matrices(new_sites, origins)
  assert msg == str(e.value)
  with raises(Exception) as e:
    ma.uijs(new_sites, origins)
  assert msg == str(e.value)
  # sites is too short/long
  msg = "Mismatch between the size of origins and first dimension of sites_carts"
  for n_tmp in [n_dst-1, n_dst+1]:
    new_sites = flex.vec3_double(rran(n_tmp*n_atm*3).reshape(n_tmp*n_atm, 3).tolist())
    new_sites.reshape(flex.grid(n_tmp,n_atm))
    with raises(Exception) as e:
      ma.normalise_by_matrices(new_sites, origins)
    assert msg == str(e.value)
    with raises(Exception) as e:
      ma.uijs(new_sites, origins)
    assert msg == str(e.value)
    # Sites/origins compatible but not same length as amplitudes
    new_origins = rran(n_tmp*3).reshape(n_tmp, 3).tolist()
    ma.copy().normalise_by_matrices(new_sites, new_origins) # Should not error -- does not use amplitudes
    with raises(Exception) as e:
      ma.uijs(new_sites, new_origins)
    assert "Mismatch between the size of TLSAmplitudes and the input arrays" == str(e.value)

  # Check dimension of sites_carts
  msg = "sites_carts must be 2-dimensional array of size (n_dst, n_atm)"
  # Make 3-d array of sites
  n_fake = 2 # length of new dimension
  new_sites = flex.vec3_double(rran(n_fake*n_dst*n_atm*3).reshape(n_fake*n_dst*n_atm, 3).tolist())
  new_sites.reshape(flex.grid(n_fake,n_atm,n_dst))
  with raises(Exception) as e:
    ma.normalise_by_matrices(new_sites, origins)
  assert msg == str(e.value)
  with raises(Exception) as e:
    ma.uijs(new_sites, origins)
  assert msg == str(e.value)
  # Make 1-d array of sites
  new_sites = flex.vec3_double(rran(n_atm*3).reshape(n_atm, 3).tolist())
  new_sites.reshape(flex.grid(n_atm))
  with raises(Exception) as e:
    ma.normalise_by_matrices(new_sites, origins)
  assert msg == str(e.value)
  with raises(Exception) as e:
    ma.uijs(new_sites, origins)
  assert msg == str(e.value)
  # Make other 1-d array
  new_sites = flex.vec3_double(rran(n_atm*3).reshape(n_atm, 3))
  with raises(Exception) as e:
    ma.normalise_by_matrices(new_sites, origins)
  assert msg == str(e.value)
  with raises(Exception) as e:
    ma.uijs(new_sites, origins)
  assert msg == str(e.value)

  # Check error when origins is 2-dimensional
  n_fake = 2 # length of new dimension
  new_origins = flex.vec3_double(rran(n_fake*n_atm*3).reshape(n_fake*n_atm, 3).tolist())
  new_origins.reshape(flex.grid(n_fake,n_atm))
  with raises(Exception) as e:
    ma.normalise_by_matrices(sites, new_origins)
  assert "Python argument types in" in str(e.value)

  # Make new sites/origins for subset of ampls for use below
  t_n_dst = n_dst - 1
  new_sites = flex.vec3_double(rran(t_n_dst*n_atm*3).reshape(t_n_dst*n_atm, 3).tolist())
  new_sites.reshape(flex.grid(t_n_dst,n_atm))
  new_origins = rran(t_n_dst*3).reshape(t_n_dst,3)

  # Selection compatibility with sites and origins
  msg = "Mismatch between the size of selection and the input arrays"
  for l in [t_n_dst-1, t_n_dst+1]:
    # Selection too short
    sel = iran(n_dst, size=l, replace=False)
    with raises(Exception) as e:
      ma.uijs(new_sites, new_origins, sel.astype(numpy.uint))
    assert msg == str(e.value)
  # Invalid selection
  sel = iran(n_dst, size=t_n_dst, replace=False)
  sel[-1] = n_dst # larger than allowed
  with raises(Exception) as e:
    ma.uijs(new_sites, new_origins, sel.astype(numpy.uint))
  assert "Selection indices out of range of TLSAmplitudes" == str(e.value)

  print('OK')

def tst_TLSMatricesAndAmplitudes_valid():
  """Check that whole object is valid/invalid based on components"""

  length = 10
  indices = [3,5]
  tol = 1e-6

  for fail_mat in INVALID_TLS_MATRICES:
    a_amps = rran(length)
    assert (a_amps<1.0).all()
    a = TLSMatricesAndAmplitudes(fail_mat, a_amps.tolist())
    for i in range(length):
      assert a.expand()[i].is_valid(tol)
      assert a.is_valid(flex.size_t([i]), tol)
    assert a.is_valid(tol)
    assert a.is_valid(flex.size_t(indices), tol)
    a.amplitudes.set([12., 1.1], flex.size_t(indices))
    assert not a.is_valid(tol)
    assert not a.is_valid(flex.size_t(indices), tol)
    assert a.is_valid(flex.size_t([i for i in range(length) if i not in indices]), tol)
    for i in range(length):
      if i in indices:
        assert not a.expand()[i].is_valid(tol)
        assert not a.is_valid(flex.size_t([i]), tol)
      else:
        assert a.expand()[i].is_valid(tol)
        assert a.is_valid(flex.size_t([i]), tol)

  print('OK')

def tst_TLSMatricesAndAmplitudes_uijs():
  """Test uijs generated correctly"""

  for length in TEST_LENGTHS:

    # Iterate through test matrices
    for a_mats in TLSMATRICES:
      a_amps = rran(length)
      a = TLSMatricesAndAmplitudes(a_mats, a_amps.tolist())
      assert approx_equal(a.matrices.get("TLS"), a_mats, MAT_RND_TOL)
      assert approx_equal(a.amplitudes.values, a_amps, AMP_RND_TOL)

      # Get a set of random coordinates
      n_atm = 5
      coords = rran(length*n_atm*3).reshape(length,n_atm,3)
      origns = rran(length*3).reshape(length,3)

      # Format coordinates into flex array
      sites = flex.vec3_double(coords.reshape(length*n_atm, 3).tolist())
      sites.reshape(flex.grid(length,n_atm))
      # Uijs from the testing class
      all_uijs = a.uijs(sites, origns)
      # Reformat to numpy array for slicing
      all_uijs_np = numpy.array(all_uijs).reshape(length,n_atm,6)

      # Check expand
      exp = a.expand() # these also used later
      for i, m in enumerate(exp):

        # Check expanded matrices have correct values
        exp_amp = round(a_amps[i], a.amplitudes.get_precision())
        exp_mat = numpy.round(a_mats, a.matrices.get_precision())
        assert approx_equal(m.get("TLS"), exp_amp*exp_mat, LAST_DP_TOL)

        # Check that uij from this class equals that expected from the container class
        this_uij = m.uijs(coords[i].tolist(), origns[i].tolist())
        assert approx_equal(numpy.array(this_uij).flatten(), all_uijs_np[i].flatten())

      # Reshape to 1d and round for convenience
      all_uijs_np = all_uijs_np.reshape(length*n_atm,6)

      # Test normalise by amplitudes
      for target in TEST_TARGETS:

        # Create copy to operate on
        new_a = a.copy()

        # Apply normalisation
        mult = new_a.normalise_by_amplitudes(target=target)

        # Average amplitude should now be target
        mean_amp = numpy.mean(new_a.amplitudes.values)
        assert approx_equal(mean_amp, target, LAST_DP_TOL)

        # Check expanded matrices are the same
        new_exp = new_a.expand()
        for new, orig in zip(new_exp, exp):
          assert approx_equal(new.get("TLS"), orig.get("TLS"))

      # Test normalise by matrices
      from scitbx.linalg.eigensystem import real_symmetric
      for target in TEST_TARGETS:

        # Create copy to operate on
        new_a = a.copy()

        # Apply normalisation
        new_a.normalise_by_matrices(sites, origns, target)

        # Average uij eigenvalue from Matrices object should now be target
        uijs = [new_a.matrices.uijs(coords[i], origns[i]) for i in range(length)]
        # TODO: see above todo
        eigenvalues = [[list(real_symmetric(u).values()) for u in uijs[i]] for i in range(length)]
        mean_eig = numpy.mean(eigenvalues)
        assert approx_equal(mean_eig, target, LAST_DP_TOL)

        # Check expanded matrices are the same
        new_exp = new_a.expand()
        for new, orig in zip(new_exp, exp):
          assert approx_equal(new.get("TLS"), orig.get("TLS"))

        # Output uijs should still be the same
        new_uijs = new_a.uijs(sites, origns)
        new_uijs_np = numpy.array(new_uijs)
        assert approx_equal(new_uijs_np.flatten(), all_uijs_np.flatten(), LAST_DP_TOL)

  print('OK')

def tst_TLSMatricesAndAmplitudesList():
  """Exercise the TLSMatricesAndAmplitudesList class"""

  for length in [1,2,3]:
    for n_dst in [1,2,3]:
      mal = TLSMatricesAndAmplitudesList(length=length, n_amplitudes=n_dst)
      assert mal.is_null()
      assert mal.size() == length
      assert mal.n_params(free=False, non_zero=False) == (21 + n_dst) * length
      assert mal.n_params(free=True, non_zero=False) == (20 + n_dst) * length
      assert mal.n_params(free=False, non_zero=True) == (n_dst) * length # initialised with all matrices zero
      assert mal.n_params(free=True, non_zero=True) == (n_dst) * length # initialised with all matrices zero
      for i, ma in enumerate(mal):
        assert ma.amplitudes.size() == n_dst
        ma.matrices.set(rran(21))
        assert not mal.is_null()
        ma.amplitudes.set(rran(n_dst))
        assert not mal.is_null()
        for j in range(length):
          if i==j: continue
          ma2 = mal.get(j)
          assert not_approx_equal(list(ma.amplitudes.values), list(ma2.amplitudes.values))
          assert not_approx_equal(list(ma.matrices.get("TLS")), list(ma2.matrices.get("TLS")))
        assert mal.n_params(free=False, non_zero=False) == (21 + n_dst) * length
        assert mal.n_params(free=True, non_zero=False) == (20 + n_dst) * length
        assert mal.n_params(free=False, non_zero=True) == 21*(i+1) + (n_dst) * length
        assert mal.n_params(free=True, non_zero=True) == 20*(i+1) + (n_dst) * length
      assert mal.n_params(free=False, non_zero=False) == (21 + n_dst) * length
      assert mal.n_params(free=True, non_zero=False) == (20 + n_dst) * length
      assert mal.n_params(free=False, non_zero=True) == (21 + n_dst) * length
      assert mal.n_params(free=True, non_zero=True) == (20 + n_dst) * length

      # Reset all matrices
      mal.reset_matrices()
      assert mal.is_null()
      for ma in mal:
        assert not ma.matrices.any("TLS")
        assert ma.amplitudes.any()
        assert ma.is_null()
      assert mal.n_params(free=False, non_zero=False) == (21 + n_dst) * length
      assert mal.n_params(free=True, non_zero=False) == (20 + n_dst) * length
      assert mal.n_params(free=False, non_zero=True) == (n_dst) * length
      assert mal.n_params(free=True, non_zero=True) == (n_dst) * length
      # This should mean all are null
      mal.reset_null_modes()
      assert mal.is_null()
      for ma in mal:
        assert not ma.matrices.any("TLS")
        assert approx_equal(ma.amplitudes.values, [1.0]*n_dst)
        assert ma.is_null()
      assert mal.n_params(free=False, non_zero=False) == (21 + n_dst) * length
      assert mal.n_params(free=True, non_zero=False) == (20 + n_dst) * length
      assert mal.n_params(free=False, non_zero=True) == (n_dst) * length
      assert mal.n_params(free=True, non_zero=True) == (n_dst) * length
      # Reset all to non-zero
      for i, ma in enumerate(mal):
        ma.matrices.set(rran(21))
        ma.amplitudes.set(rran(n_dst))
        assert not ma.is_null()
        assert not mal.is_null()
      assert not mal.is_null()
      assert mal.n_params(free=False, non_zero=False) == (21 + n_dst) * length
      assert mal.n_params(free=True, non_zero=False) == (20 + n_dst) * length
      assert mal.n_params(free=False, non_zero=True) == (21 + n_dst) * length
      assert mal.n_params(free=True, non_zero=True) == (20 + n_dst) * length

      # Zero selection of amplitudes
      sel = iran(length, size=max(1,length-1), replace=False)
      mal.zero_amplitudes(sel.astype(numpy.uint))
      if length == 1:
        assert mal.is_null()
      else:
        assert not mal.is_null()
      for i, ma in enumerate(mal):
        if i in sel:
          exp = True
        else:
          exp = False
        assert True == ma.matrices.any("TLS")
        assert exp == (not ma.amplitudes.any())
        assert exp == ma.is_null()
      assert mal.n_params(free=False, non_zero=False) == (21 + n_dst) * length
      assert mal.n_params(free=True, non_zero=False) == (20 + n_dst) * length
      assert mal.n_params(free=False, non_zero=True) == (21 + n_dst) * length - n_dst * len(sel)
      assert mal.n_params(free=True, non_zero=True) == (20 + n_dst) * length - n_dst * len(sel)
      # Only selection should be null
      mal.reset_null_modes()
      for i, ma in enumerate(mal):
        if i in sel:
          exp = True
          assert approx_equal(ma.amplitudes.values, [1.0]*n_dst)
        else:
          exp = False
          assert not_approx_equal(ma.amplitudes.values, [1.0]*n_dst)
        assert exp == (not ma.matrices.any("TLS"))
        assert exp == ma.is_null()
      assert mal.n_params(free=False, non_zero=False) == (21 + n_dst) * length
      assert mal.n_params(free=True, non_zero=False) == (20 + n_dst) * length
      assert mal.n_params(free=False, non_zero=True) == 21 * (length - len(sel)) + n_dst * length
      assert mal.n_params(free=True, non_zero=True) == 20 * (length - len(sel)) + n_dst * length
      # Reset all to non-zero
      for i, ma in enumerate(mal):
        ma.matrices.set(rran(21))
        ma.amplitudes.set(rran(n_dst))
        assert not ma.is_null()
        assert not mal.is_null()
      assert mal.n_params(free=False, non_zero=False) == (21 + n_dst) * length
      assert mal.n_params(free=True, non_zero=False) == (20 + n_dst) * length
      assert mal.n_params(free=False, non_zero=True) == (21 + n_dst) * length
      assert mal.n_params(free=True, non_zero=True) == (20 + n_dst) * length

      # Check modes with zero matrices are reset
      sel = iran(length, size=max(1,length-1), replace=False)
      for i, ma in enumerate(mal):
        if i in sel:
          ma.matrices.reset()
      mal.reset_null_modes()
      # Only selection should be null
      for i, ma in enumerate(mal):
        if i in sel:
          exp = True
          assert approx_equal(ma.amplitudes.values, [1.0]*n_dst)
        else:
          exp = False
          assert not_approx_equal(ma.amplitudes.values, [1.0]*n_dst)
        assert exp == (not ma.matrices.any("TLS"))
        assert exp == ma.is_null()
      assert mal.n_params(free=False, non_zero=False) == (21 + n_dst) * length
      assert mal.n_params(free=True, non_zero=False) == (20 + n_dst) * length
      assert mal.n_params(free=False, non_zero=True) == (21 + n_dst) * length - 21 * len(sel)
      assert mal.n_params(free=True, non_zero=True) == (20 + n_dst) * length - 20 * len(sel)
      # Reset all to non-zero
      for i, ma in enumerate(mal):
        ma.matrices.set(rran(21))
        ma.amplitudes.set(rran(n_dst))
        assert not ma.is_null()

      # Set random amplitudes to negative and then check they are zero-d
      isel = iran(length)
      asel = iran(n_dst, max(1,n_dst-1), replace=False)
      ma = mal.get(isel)
      ma.amplitudes.set(-rran(len(asel)), asel.astype(numpy.uint))
      prev_v = ma.amplitudes.values
      for i, v in enumerate(prev_v):
        if i in asel:
          assert v<0.0
        else:
          assert v>0.0
      mal.zero_negative_amplitudes()
      for i_ma, ma in enumerate(mal):
        if i_ma == isel:
          for i_v, v in enumerate(ma.amplitudes.values):
            if i_v in asel:
              assert v==0.0
            else:
              assert v==prev_v[i_v]
        else:
          assert ma.amplitudes.n_params(non_zero=True) == n_dst
      assert mal.n_params(free=False, non_zero=False) == (21 + n_dst) * length
      assert mal.n_params(free=True, non_zero=False) == (20 + n_dst) * length
      assert mal.n_params(free=False, non_zero=True) == (21 + n_dst) * length - len(asel)
      assert mal.n_params(free=True, non_zero=True) == (20 + n_dst) * length - len(asel)

  # Test initialisation from arrays
  mats = flex.double(rran(3*21).tolist())
  mats.reshape(flex.grid((3,21)))
  amps = flex.double(rran(3*10).tolist())
  amps.reshape(flex.grid((3,10)))
  mal = TLSMatricesAndAmplitudesList(mats, amps)
  assert not mal.is_null()
  for i, m in enumerate(mal):
    assert approx_equal(m.matrices.get(), mats[21*i:21*(i+1)])
    assert approx_equal(m.amplitudes.get(), amps[10*i:10*(i+1)])
  mats.set_selected(flex.bool(flex.grid(mats.all()), True), 0.0)
  amps.set_selected(flex.bool(flex.grid(amps.all()), True), 0.0)
  assert mats.all_eq(0.0)
  assert amps.all_eq(0.0)
  assert not mal.is_null()

  # Test reset
  mal.reset()
  assert mal.is_null()
  for ma in mal:
    assert ma.is_null()

  # Test uijs
  n_atm = 2
  n_dst = 3
  n_mod = 4
  mal = TLSMatricesAndAmplitudesList(length=n_mod, n_amplitudes=n_dst)
  for i, mats in enumerate(TLSMATRICES[:n_mod]):
    ma = mal[i]
    ma.matrices.set(mats)
    ma.amplitudes.set(rran(3))

  # For all modes
  coord_scale = 20.0 # set suitable scale for coordinates in angstrom
  rand_coords = (coord_scale*rran(n_dst*n_atm*3)).reshape(n_dst*n_atm, 3).tolist()
  sites = flex.vec3_double(rand_coords)
  sites.reshape(flex.grid(n_dst,n_atm))
  origins = rran(n_dst*3).reshape(n_dst,3)
  all_uijs = mal.uijs(sites, origins)
  sum_uijs = flex.sym_mat3_double(flex.grid((n_dst, n_atm)))
  assert all_uijs.all() == sum_uijs.all()
  for ma in mal:
    new_uijs = ma.uijs(sites, origins)
    assert new_uijs.all() == (n_dst, n_atm)
    sum_uijs = sum_uijs + new_uijs
  assert approx_equal(numpy.array(all_uijs).flatten(), numpy.array(sum_uijs).flatten())
  # And from an amplitudes selection
  n_tmp = max(1,n_dst-2)
  sel = iran(n_dst, size=n_tmp, replace=False)
  sites = flex.vec3_double(rran(n_tmp*n_atm*3).reshape(n_tmp*n_atm, 3).tolist())
  sites.reshape(flex.grid(n_tmp,n_atm))
  origins = rran(n_tmp*3).reshape(n_tmp,3)
  all_uijs = mal.uijs(sites, origins, sel.astype(numpy.uint))
  sum_uijs = flex.sym_mat3_double(flex.grid((n_tmp, n_atm)))
  assert all_uijs.all() == sum_uijs.all()
  for i, ma in enumerate(mal):
    new_uijs = ma.uijs(sites, origins, sel.astype(numpy.uint))
    assert new_uijs.all() == (n_tmp, n_atm)
    sum_uijs = sum_uijs + new_uijs
  assert approx_equal(numpy.array(all_uijs).flatten(), numpy.array(sum_uijs).flatten())

  # Check copy creates separate object
  mal = TLSMatricesAndAmplitudesList(length=n_mod, n_amplitudes=n_dst)
  for ma in mal:
    ma.matrices.set(rran(21))
    ma.amplitudes.set(rran(n_dst))
  mal_c = mal.copy()
  for i in range(n_mod):
    assert approx_equal(list(mal[i].matrices.get("TLS")), list(mal_c[i].matrices.get("TLS")))
    assert approx_equal(list(mal[i].amplitudes.values), list(mal_c[i].amplitudes.values))
  mal_c.reset_matrices()
  for i in range(n_mod):
    assert mal[i].matrices.any()
    assert not mal_c[i].matrices.any()
    assert approx_equal(list(mal[i].amplitudes.values), list(mal_c[i].amplitudes.values))

  print('OK')

def tst_TLSMatricesAndAmplitudesList_fails():
  """Check that exceptions are raised where expected"""

  n_mod = 4
  n_dst = 3
  n_atm = 2

  mal = TLSMatricesAndAmplitudesList(length=n_mod, n_amplitudes=n_dst)

  # Check indexing errors
  with raises(Exception) as e:
    mal[n_mod+1]
  assert "index out of range of TLSMatricesAndAmplitudesList" == str(e.value)

  # Tolerances
  mal.copy().reset_null_modes(0.0, 0.0) # values can be zero
  mal.copy().reset_null_modes(-1, -1) # values can be -1
  msg = "Tolerance provided must either be positive or -1"
  with raises(Exception) as e:
    mal.reset_null_modes(-0.1, -1)
  assert msg == str(e.value)
  with raises(Exception) as e:
    mal.reset_null_modes(-1, -0.1)
  assert msg == str(e.value)

  # Set some values
  for i, ma in enumerate(mal):
    ma.matrices.set(TLSMATRICES[i])
    ma.amplitudes.set(rran(n_dst))

  # Coordinates sets for following tests
  sites = flex.vec3_double(rran(n_dst*n_atm*3).reshape(n_dst*n_atm, 3).tolist())
  sites.reshape(flex.grid(n_dst,n_atm))
  origins = rran(n_dst*3).reshape(n_dst,3)

  # Compatibility of sites/origins arrays (normalise and uijs)
  # Array has swapped axes
  msg = "Mismatch between the size of origins and first dimension of sites_carts"
  new_sites = flex.vec3_double(rran(n_dst*n_atm*3).reshape(n_dst*n_atm, 3).tolist())
  new_sites.reshape(flex.grid(n_atm,n_dst)) # swap axes
  with raises(Exception) as e:
    mal.uijs(new_sites, origins)
  assert msg == str(e.value)
  # sites is too short/long
  msg = "Mismatch between the size of origins and first dimension of sites_carts"
  for n_tmp in [n_dst-1, n_dst+1]:
    new_sites = flex.vec3_double(rran(n_tmp*n_atm*3).reshape(n_tmp*n_atm, 3).tolist())
    new_sites.reshape(flex.grid(n_tmp,n_atm))
    with raises(Exception) as e:
      mal.uijs(new_sites, origins)
    assert msg == str(e.value)
    # Sites/origins compatible but not same length as amplitudes
    new_origins = rran(n_tmp*3).reshape(n_tmp, 3).tolist()
    with raises(Exception) as e:
      mal.uijs(new_sites, new_origins)
    assert "Mismatch between the size of TLSAmplitudes and the input arrays" == str(e.value)

  # Check dimension of sites_carts
  msg = "sites_carts must be 2-dimensional array of size (n_dst, n_atm)"
  # Make 3-d array of sites
  n_fake = 2 # length of new dimension
  new_sites = flex.vec3_double(rran(n_fake*n_dst*n_atm*3).reshape(n_fake*n_dst*n_atm, 3).tolist())
  new_sites.reshape(flex.grid(n_fake,n_atm,n_dst))
  with raises(Exception) as e:
    mal.uijs(new_sites, origins)
  assert msg == str(e.value)
  # Make 1-d array of sites
  new_sites = flex.vec3_double(rran(n_atm*3).reshape(n_atm, 3).tolist())
  new_sites.reshape(flex.grid(n_atm))
  with raises(Exception) as e:
    mal.uijs(new_sites, origins)
  assert msg == str(e.value)
  # Make other 1-d array
  new_sites = flex.vec3_double(rran(n_atm*3).reshape(n_atm, 3))
  with raises(Exception) as e:
    mal.uijs(new_sites, origins)
  assert msg == str(e.value)

  # Make new sites/origins for subset of ampls for use below
  t_n_dst = n_dst - 1
  new_sites = flex.vec3_double(rran(t_n_dst*n_atm*3).reshape(t_n_dst*n_atm, 3).tolist())
  new_sites.reshape(flex.grid(t_n_dst,n_atm))
  new_origins = rran(t_n_dst*3).reshape(t_n_dst,3)

  # Selection compatibility with sites and origins
  msg = "Mismatch between the size of selection and the input arrays"
  for l in [t_n_dst-1, t_n_dst+1]:
    # Selection too short
    sel = iran(n_dst, size=l, replace=False)
    with raises(Exception) as e:
      mal.uijs(new_sites, new_origins, sel.astype(numpy.uint))
    assert msg == str(e.value)
  # Invalid selection
  sel = iran(n_dst, size=t_n_dst, replace=False)
  sel[-1] = n_dst # larger than allowed
  with raises(Exception) as e:
    mal.uijs(new_sites, new_origins, sel.astype(numpy.uint))
  assert "Selection indices out of range of TLSAmplitudes" == str(e.value)

  print('OK')

if __name__ == "__main__":
  tst_set_precision()
  tst_set_tolerance()
  tst_TLSMatrices()
  tst_TLSMatrices_counts()
  tst_TLSMatrices_fails()
  tst_TLSMatrices_uijs()
  tst_TLSAmplitudes()
  tst_TLSAmplitudes_fails()
  tst_TLSMatricesAndAmplitudes()
  tst_TLSMatricesAndAmplitudes_counts()
  tst_TLSMatricesAndAmplitudes_fails()
  tst_TLSMatricesAndAmplitudes_valid()
  tst_TLSMatricesAndAmplitudes_uijs()
  tst_TLSMatricesAndAmplitudesList()
  tst_TLSMatricesAndAmplitudesList_fails()


 *******************************************************************************


 *******************************************************************************
mmtbx/regression/tls/tst_u_tls_vs_u_ens_00.py
from __future__ import absolute_import, division, print_function
from mmtbx.tls import tools
import time
from six.moves import range

pdb_str_1 = """
CRYST1   10.000   10.000   10.000  90.00  90.00  90.00 P1
ATOM      1  CA  THR A   6       0.000   0.000   0.000  1.00  0.00           C
ATOM      1  CA  THR B   6       3.000   0.000   0.000  1.00  0.00           C
"""

pdb_str_2 = """
CRYST1   10.000   10.000   10.000  90.00  90.00  90.00 P1
ATOM      1  CA  THR A   6       0.000   0.000   0.000  1.00  0.00           C
ATOM      1  CA  THR B   6       0.000   3.000   0.000  1.00  0.00           C
"""

pdb_str_3 = """
CRYST1   10.000   10.000   10.000  90.00  90.00  90.00 P1
ATOM      1  CA  THR A   6       0.000   0.000   0.000  1.00  0.00           C
ATOM      1  CA  THR B   6       0.000   0.000   3.000  1.00  0.00           C
"""

pdb_str_4 = """
CRYST1   10.000   10.000   10.000  90.00  90.00  90.00 P1
ATOM      1  CA  THR A   6       0.000   0.000   0.000  1.00  0.00           C
ATOM      1  CA  THR B   6       1.000   2.000   3.000  1.00  0.00           C
"""

def exercise_00():
  xs=[0,0,0]
  ys=[0,0,0]
  zs=[0,0,0]
  for pdb_str in [pdb_str_1, pdb_str_2, pdb_str_3, pdb_str_4]:
    print(pdb_str)
    for d in [[0.05,0.06,0.07], ]:
      dx,dy,dz = d
      for x in range(3):
        for y in range(3):
          for z in range(3):
            if(x!=y and x!=z and y!=z):
              xs_ = xs[:]
              ys_ = ys[:]
              zs_ = zs[:]
              xs_[x]=1
              ys_[y]=1
              zs_[z]=1
              tools.u_tls_vs_u_ens(pdb_str=pdb_str,
                dx=dx,dy=dy,dz=dz, sx=0.5,sy=0.4,sz=0.3, lx=xs_,ly=ys_,lz=zs_)
              print()

if (__name__ == "__main__"):
  t0 = time.time()
  exercise_00()
  print("Time: %6.4f"%(time.time()-t0))
  print("OK")


 *******************************************************************************


 *******************************************************************************
mmtbx/regression/tls/tst_u_tls_vs_u_ens_01.py
from __future__ import absolute_import, division, print_function
from mmtbx.tls import tools
import math
import time

pdb_str_1 = """
CRYST1   10.000   10.000   10.000  90.00  90.00  90.00 P1
ATOM      1  CA  THR A   6       0.000   0.000   0.000  1.00  0.00           C
ATOM      1  CA  THR B   6       3.000   0.000   0.000  1.00  0.00           C
"""

pdb_str_2 = """
CRYST1   10.000   10.000   10.000  90.00  90.00  90.00 P1
ATOM      1  CA  THR A   6       0.000   0.000   0.000  1.00  0.00           C
ATOM      1  CA  THR B   6       0.000   3.000   0.000  1.00  0.00           C
"""

pdb_str_3 = """
CRYST1   10.000   10.000   10.000  90.00  90.00  90.00 P1
ATOM      1  CA  THR A   6       0.000   0.000   0.000  1.00  0.00           C
ATOM      1  CA  THR B   6       0.000   0.000   3.000  1.00  0.00           C
"""

pdb_str_4 = """
CRYST1   10.000   10.000   10.000  90.00  90.00  90.00 P1
ATOM      1  CA  THR A   6       0.000   0.000   0.000  1.00  0.00           C
ATOM      1  CA  THR B   6       1.000   2.000   3.000  1.00  0.00           C
"""

def exercise_01():
  sqrt = math.sqrt
  ls = []
  ls.append( [(sqrt(2)/2, sqrt(2)/2, 0), (-sqrt(2)/2, sqrt(2)/2, 0), (0,0,1)] )
  ls.append( [(1,0,0), (0, sqrt(2)/2, sqrt(2)/2), (0, -sqrt(2)/2, sqrt(2)/2)] )
  ls.append( [(sqrt(3)/2, 1/2, 0), (-1/2, sqrt(3)/2, 0), (0,0,1)] )
  ls.append( [(1,0,0), (0, sqrt(3)/2, 1/2), (0, -1/2, sqrt(3)/2)] )
  for pdb_str in [pdb_str_1, pdb_str_2, pdb_str_3, pdb_str_4]:
    for ls_ in ls:
      lx,ly,lz = ls_
      print(lx,ly,lz)
      tools.u_tls_vs_u_ens(pdb_str=pdb_str,
          dx=0.05,dy=0.06,dz=0.07,
          sx=0.5, sy=0.4, sz=0.3,
          lx=lx, ly=ly, lz=lz)

if (__name__ == "__main__"):
  t0 = time.time()
  exercise_01()
  print("Time: %6.4f"%(time.time()-t0))
  print("OK")


 *******************************************************************************


 *******************************************************************************
mmtbx/regression/tls/tst_u_tls_vs_u_ens_02.py
from __future__ import absolute_import, division, print_function
from mmtbx.tls import tools
import time
from six.moves import range

pdb_str_1 = """
CRYST1   10.000   10.000   10.000  90.00  90.00  90.00 P1
ATOM      1  CA  THR A   6       0.000   0.000   0.000  1.00  0.00           C
ATOM      1  CA  THR B   6       3.000   0.000   0.000  1.00  0.00           C
"""

pdb_str_2 = """
CRYST1   10.000   10.000   10.000  90.00  90.00  90.00 P1
ATOM      1  CA  THR A   6       0.000   0.000   0.000  1.00  0.00           C
ATOM      1  CA  THR B   6       0.000   3.000   0.000  1.00  0.00           C
"""

pdb_str_3 = """
CRYST1   10.000   10.000   10.000  90.00  90.00  90.00 P1
ATOM      1  CA  THR A   6       0.000   0.000   0.000  1.00  0.00           C
ATOM      1  CA  THR B   6       0.000   0.000   3.000  1.00  0.00           C
"""

pdb_str_4 = """
CRYST1   10.000   10.000   10.000  90.00  90.00  90.00 P1
ATOM      1  CA  THR A   6       0.000   0.000   0.000  1.00  0.00           C
ATOM      1  CA  THR B   6       1.000   2.000   3.000  1.00  0.00           C
"""

def exercise_02():
  xs=[0,0,0]
  ys=[0,0,0]
  zs=[0,0,0]
  for pdb_str in [pdb_str_1, pdb_str_2, pdb_str_3, pdb_str_4]:
    print(pdb_str)
    for t in [[0.05,0.07,0.09], ]:
      tx,ty,tz = t
      for x in range(3):
        for y in range(3):
          for z in range(3):
            if(x!=y and x!=z and y!=z):
              xs_ = xs[:]
              ys_ = ys[:]
              zs_ = zs[:]
              xs_[x]=1
              ys_[y]=1
              zs_[z]=1
              tools.u_tls_vs_u_ens(pdb_str=pdb_str,
                tx=tx,ty=ty,tz=tz, vx=xs_,vy=ys_,vz=zs_,
                n_models=1000)
              print()

if (__name__ == "__main__"):
  t0 = time.time()
  exercise_02()
  print("Time: %6.4f"%(time.time()-t0))
  print("OK")


 *******************************************************************************


 *******************************************************************************
mmtbx/regression/tls/tst_u_tls_vs_u_ens_03.py
from __future__ import absolute_import, division, print_function
from mmtbx.tls import tools
import math
import time

pdb_str_1 = """
CRYST1   10.000   10.000   10.000  90.00  90.00  90.00 P1
ATOM      1  CA  THR A   6       0.000   0.000   0.000  1.00  0.00           C
ATOM      1  CA  THR B   6       3.000   0.000   0.000  1.00  0.00           C
"""

pdb_str_2 = """
CRYST1   10.000   10.000   10.000  90.00  90.00  90.00 P1
ATOM      1  CA  THR A   6       0.000   0.000   0.000  1.00  0.00           C
ATOM      1  CA  THR B   6       0.000   3.000   0.000  1.00  0.00           C
"""

pdb_str_3 = """
CRYST1   10.000   10.000   10.000  90.00  90.00  90.00 P1
ATOM      1  CA  THR A   6       0.000   0.000   0.000  1.00  0.00           C
ATOM      1  CA  THR B   6       0.000   0.000   3.000  1.00  0.00           C
"""

pdb_str_4 = """
CRYST1   10.000   10.000   10.000  90.00  90.00  90.00 P1
ATOM      1  CA  THR A   6       0.000   0.000   0.000  1.00  0.00           C
ATOM      1  CA  THR B   6       1.000   2.000   3.000  1.00  0.00           C
"""

def exercise_03():
  sqrt = math.sqrt
  vs = []
  vs.append( [(sqrt(2)/2, sqrt(2)/2, 0), (-sqrt(2)/2, sqrt(2)/2, 0), (0,0,1)] )
  vs.append( [(1,0,0), (0, sqrt(2)/2, sqrt(2)/2), (0, -sqrt(2)/2, sqrt(2)/2)] )
  vs.append( [(sqrt(3)/2, 1/2, 0), (-1/2, sqrt(3)/2, 0), (0,0,1)] )
  vs.append( [(1,0,0), (0, sqrt(3)/2, 1/2), (0, -1/2, sqrt(3)/2)] )
  for pdb_str in [pdb_str_1, pdb_str_2, pdb_str_3, pdb_str_4]:
    for vs_ in vs:
      vx,vy,vz = vs_
      print(vx,vy,vz)
      tools.u_tls_vs_u_ens(pdb_str=pdb_str,
          tx=0.05,ty=0.07,tz=0.09,
          vx=vx, vy=vy, vz=vz,
          n_models=1000)

if (__name__ == "__main__"):
  t0 = time.time()
  exercise_03()
  print("Time: %6.4f"%(time.time()-t0))
  print("OK")


 *******************************************************************************


 *******************************************************************************
mmtbx/regression/tls/tst_u_tls_vs_u_ens_04.py
from __future__ import absolute_import, division, print_function
from mmtbx.tls import tools
import math
import time
from six.moves import zip

pdb_str_1 = """
CRYST1   10.000   10.000   10.000  90.00  90.00  90.00 P1
ATOM      1  CA  THR A   6       0.000   0.000   0.000  1.00  0.00           C
ATOM      1  CA  THR B   6       3.000   0.000   0.000  1.00  0.00           C
"""

pdb_str_2 = """
CRYST1   10.000   10.000   10.000  90.00  90.00  90.00 P1
ATOM      1  CA  THR A   6       0.000   0.000   0.000  1.00  0.00           C
ATOM      1  CA  THR B   6       0.000   3.000   0.000  1.00  0.00           C
"""

pdb_str_3 = """
CRYST1   10.000   10.000   10.000  90.00  90.00  90.00 P1
ATOM      1  CA  THR A   6       0.000   0.000   0.000  1.00  0.00           C
ATOM      1  CA  THR B   6       0.000   0.000   3.000  1.00  0.00           C
"""

pdb_str_4 = """
CRYST1   10.000   10.000   10.000  90.00  90.00  90.00 P1
ATOM      1  CA  THR A   6       0.000   0.000   0.000  1.00  0.00           C
ATOM      1  CA  THR B   6       1.000   2.000   3.000  1.00  0.00           C
"""

def exercise_04():
  sqrt = math.sqrt
  ls = []
  ls.append( [(sqrt(2)/2, sqrt(2)/2, 0), (-sqrt(2)/2, sqrt(2)/2, 0), (0,0,1)] )
  ls.append( [(1,0,0), (0, sqrt(2)/2, sqrt(2)/2), (0, -sqrt(2)/2, sqrt(2)/2)] )
  ls.append( [(sqrt(3)/2, 1/2, 0), (-1/2, sqrt(3)/2, 0), (0,0,1)] )
  ls.append( [(1,0,0), (0, sqrt(3)/2, 1/2), (0, -1/2, sqrt(3)/2)] )
  vs = ls[:]
  vs.reverse()
  for pdb_str in [pdb_str_1, pdb_str_2, pdb_str_3, pdb_str_4]:
    for ls_, vs_ in zip(ls,vs):
      lx,ly,lz = ls_
      vx,vy,vz = vs_
      print(lx,ly,lz)
      print(vx,vy,vz)
      tools.u_tls_vs_u_ens(pdb_str=pdb_str,
          dx=0.05,dy=0.06,dz=0.07,
          sx=0.3, sy=0.2, sz=0.1,
          lx=lx, ly=ly, lz=lz,
          tx=0.06,ty=0.08,tz=0.09,
          vx=vx, vy=vy, vz=vz,
          w_M_lx=[0.1,0.2,0.3], w_M_ly=[-0.4,-0.3,-0.1], w_M_lz=[-0.2,0.1,0.3])

if (__name__ == "__main__"):
  t0 = time.time()
  exercise_04()
  print("Time: %6.4f"%(time.time()-t0))
  print("OK")


 *******************************************************************************


 *******************************************************************************
mmtbx/regression/tncs/tst_epsfac_and_radius.py
from __future__ import absolute_import, division, print_function
import cctbx.array_family.flex # import dependency
import boost_adaptbx.boost.python as bp
ext = bp.import_ext("mmtbx_ncs_ext")
import iotbx.pdb
from mmtbx.ncs import tncs
import libtbx.load_env
import os, time

def exercise_00(reflections_per_bin=150):
  """
  tncs_epsfac calculation with radius refinement
  """
  pdb_file = libtbx.env.find_in_repositories(
    relative_path="mmtbx/regression/tncs/model_1.pdb",
    test=os.path.isfile)
  pdb_inp = iotbx.pdb.input(file_name=pdb_file)
  xray_structure = pdb_inp.xray_structure_simple()
  for b in [0, 50, 100, 200, 400, 800]:
    xray_structure = xray_structure.set_b_iso(value=b)
    print("B: %5.1f"%b)
    for d_min in [2,3,4,6,8]:
      f_obs = abs(xray_structure.structure_factors(d_min=d_min).f_calc())
      f_obs = f_obs.set_observation_type_xray_amplitude()
      result = tncs.compute_eps_factor(
        f_obs               = f_obs,
        pdb_hierarchy       = pdb_inp.construct_hierarchy(),
        reflections_per_bin = reflections_per_bin)
      M2 = f_obs.second_moments_centric_acentric(
        reflections_per_bin = reflections_per_bin)
      M2_corr = f_obs.second_moments_centric_acentric(
        reflections_per_bin = reflections_per_bin,
        eps_fac = result.epsfac)
      fmt="  d_min: %5.1f R: refined %4.1f estimate %4.1f 2nd Mom.:"
      print(fmt%(d_min, result.ncs_pairs[0].radius,
        result.ncs_pairs[0].radius_estimate), "%s %4.2f"%M2[0], "%s %4.2f"%M2_corr[0])
  # this shows summary for the result corresponding to last trial B and d_min
  result.show_summary()

def exercise_01(reflections_per_bin=150):
  """
  tncs_epsfac calculation with radius refinement
  """
  pdb_file = libtbx.env.find_in_repositories(
    relative_path="mmtbx/regression/tncs/model_4.pdb",
    test=os.path.isfile)
  pdb_inp = iotbx.pdb.input(file_name=pdb_file)
  xray_structure = pdb_inp.xray_structure_simple()
  xray_structure = xray_structure.set_b_iso(value=10)
  f_obs = abs(xray_structure.structure_factors(d_min=2).f_calc())
  f_obs = f_obs.set_observation_type_xray_amplitude()
  result = tncs.compute_eps_factor(
    f_obs               = f_obs,
    pdb_hierarchy       = pdb_inp.construct_hierarchy(),
    reflections_per_bin = reflections_per_bin)
  result.show_summary()
  M2 = f_obs.second_moments_centric_acentric(
    reflections_per_bin = reflections_per_bin)
  M2_corr = f_obs.second_moments_centric_acentric(
    reflections_per_bin = reflections_per_bin,
    eps_fac = result.epsfac)
  print("%s %4.2f"%M2[0], "%s %4.2f"%M2_corr[0])

if (__name__ == "__main__"):
  t0 = time.time()
  exercise_00()
  exercise_01()
  print("Time: %6.3f"%(time.time()-t0))
  print("OK")


 *******************************************************************************


 *******************************************************************************
mmtbx/regression/tncs/tst_fd.py
from __future__ import absolute_import, division, print_function
import cctbx.array_family.flex # import dependency
import boost_adaptbx.boost.python as bp
ext = bp.import_ext("mmtbx_ncs_ext")
import iotbx.pdb
from scitbx.array_family import flex
from mmtbx.ncs import tncs
import libtbx.load_env
import os, time

def f_obs_and_tncs_pairs_from_pdb(file_name, reflections_per_bin):
  pdb_file = libtbx.env.find_in_repositories(
    relative_path="mmtbx/regression/tncs/%s"%file_name,
    test=os.path.isfile)
  pdb_inp = iotbx.pdb.input(file_name=pdb_file)
  xray_structure = pdb_inp.xray_structure_simple()
  xray_structure = xray_structure.set_b_iso(value=10)
  f_obs = abs(xray_structure.structure_factors(d_min=2.0).f_calc())
  f_obs.set_sigmas(sigmas = flex.double(f_obs.data().size(), 0.0))
  reflections_per_bin = min(f_obs.data().size(), reflections_per_bin)
  f_obs.setup_binner(reflections_per_bin = reflections_per_bin)
  print(f_obs.binner().n_bins_used())
  ncs_pairs = tncs.groups(
    pdb_hierarchy    = pdb_inp.construct_hierarchy(),
    crystal_symmetry = f_obs.crystal_symmetry()).ncs_pairs
  tncs.initialize_rho_mn(
    ncs_pairs       = ncs_pairs,
    d_spacings_data = f_obs.d_spacings().data(),
    binner          = f_obs.binner())
  return f_obs, ncs_pairs

def exercise_00(file_name, reflections_per_bin=150):
  """
  Finite differences test for radii.
  """
  f_obs, ncs_pairs = f_obs_and_tncs_pairs_from_pdb(file_name = file_name,
    reflections_per_bin = reflections_per_bin)
  tncs.finite_differences_grad_radius(ncs_pairs=ncs_pairs,
    f_obs=f_obs, reflections_per_bin=reflections_per_bin, tolerance=1.)

def exercise_01(file_name, reflections_per_bin=5000):
  """
  Finite differences test for rho_mn.
  """
  f_obs, ncs_pairs = f_obs_and_tncs_pairs_from_pdb(file_name = file_name,
    reflections_per_bin = reflections_per_bin)
  tncs.finite_differences_rho_mn(ncs_pairs=ncs_pairs,
    f_obs=f_obs, reflections_per_bin=reflections_per_bin, tolerance=1.)

def run():
  for file_name in ["model_2.pdb", "model_4.pdb"]:
    print(file_name)
    exercise_00(file_name = file_name)
    exercise_01(file_name = file_name)

if (__name__ == "__main__"):
  t0 = time.time()
  run()
  print("Time: %6.3f"%(time.time()-t0))
  print("OK")


 *******************************************************************************


 *******************************************************************************
mmtbx/regression/tncs/tst_moments.py
from __future__ import absolute_import, division, print_function
import cctbx.array_family.flex # import dependency
import boost_adaptbx.boost.python as bp
ext = bp.import_ext("mmtbx_ncs_ext")
import iotbx.pdb
from mmtbx.ncs import tncs
import libtbx.load_env
import os, time


def exercise_01(reflections_per_bin=150):
  """
  tncs_epsfac calculation with radius refinement
  """
  pdb_file = libtbx.env.find_in_repositories(
    relative_path="mmtbx/regression/tncs/model_3.pdb",
    test=os.path.isfile)
  pdb_inp = iotbx.pdb.input(file_name=pdb_file)
  xray_structure = pdb_inp.xray_structure_simple()
  xray_structure = xray_structure.set_b_iso(value=10)
  f_obs = abs(xray_structure.structure_factors(d_min=2).f_calc())
  f_obs = f_obs.set_observation_type_xray_amplitude()
  result = tncs.compute_eps_factor(
    f_obs               = f_obs,
    pdb_hierarchy       = pdb_inp.construct_hierarchy(),
    reflections_per_bin = reflections_per_bin)
  result.show_summary()
  M2 = f_obs.second_moments_centric_acentric(
    reflections_per_bin = reflections_per_bin)
  M2_corr = f_obs.second_moments_centric_acentric(
    reflections_per_bin = reflections_per_bin,
    eps_fac = result.epsfac)
  print("%s %4.2f"%M2[0], "%s %4.2f"%M2_corr[0])

if (__name__ == "__main__"):
  t0 = time.time()
  exercise_01()
  print("Time: %6.3f"%(time.time()-t0))
  print("OK")


 *******************************************************************************


 *******************************************************************************
mmtbx/regression/tncs/tst_pair.py
from __future__ import absolute_import, division, print_function
import cctbx.array_family.flex # import dependency
import boost_adaptbx.boost.python as bp
ext = bp.import_ext("mmtbx_ncs_ext")
from mmtbx_ncs_ext import *
from libtbx.test_utils import approx_equal

def esercise_00():
  p = pair(
    r = ([1,2,3,4,5,6,7,8,9]),
    t = ([10,11,12]),
    radius=13,
    radius_estimate=13.5,
    fracscat=15,
    rho_mn=([1,2,3,4,5]),
    id=0)
  assert approx_equal(p.r,[1,2,3,4,5,6,7,8,9])
  assert approx_equal(p.t,[10,11,12])
  assert approx_equal(p.radius, 13)
  assert approx_equal(p.radius_estimate, 13.5)
  assert approx_equal(p.fracscat, 15)
  assert approx_equal(p.rho_mn,[1,2,3,4,5])
  # exercise set
  p.set_radius(10)
  p.set_rhoMN([5,4,3,2,1])
  assert p.id==0
  p.set_id(9)
  assert p.id==9
  assert approx_equal(p.radius, 10)
  assert approx_equal(p.rho_mn, [5,4,3,2,1])

if (__name__ == "__main__"):
  esercise_00()


 *******************************************************************************


 *******************************************************************************
mmtbx/regression/tst_add_arrows_on_plot.py
from __future__ import absolute_import, division, print_function

import iotbx.pdb
import mmtbx.model
from mmtbx.validation.ramalyze import ramalyze
from libtbx.utils import null_out
from mmtbx.validation.comparama import add_arrows_on_plot
from PIL import Image
import sys

pdb_str = """\
ATOM     13  CB  PHE A   1      11.914  10.410  11.811  1.00  2.00           C
ATOM     14  CG  PHE A   1      11.204   9.472  12.746  1.00  2.00           C
ATOM     15  CD1 PHE A   1      10.636   8.301  12.273  1.00  2.00           C
ATOM     16  CD2 PHE A   1      11.105   9.762  14.096  1.00  2.00           C
ATOM     17  CE1 PHE A   1       9.982   7.436  13.131  1.00  2.00           C
ATOM     18  CE2 PHE A   1      10.452   8.901  14.958  1.00  2.00           C
ATOM     19  CZ  PHE A   1       9.890   7.737  14.475  1.00  2.00           C
ATOM     20  C   PHE A   1      11.828  12.443  10.351  1.00  2.00           C
ATOM     21  O   PHE A   1      11.808  12.365   9.123  1.00  2.00           O
ATOM     22  OXT PHE A   1      12.531  13.314  10.864  1.00  2.00           O
ATOM     23  N   PHE A   1       9.929  10.880  10.444  1.00  2.00           N
ATOM     24  CA  PHE A   1      11.008  11.488  11.213  1.00  2.00           C
"""

if sys.version_info.major == 3:
  reference_hist = [111080, 832, 645, 454, 418, 493, 367, 300, 35369, 3421, 3425,
      2800, 6623, 3317, 3801, 5680, 4466, 2545, 3101, 6944, 4291, 3131, 2951, 7023,
      3692, 4041, 6628, 3158, 4796, 2898, 7657, 4096, 3801, 3587, 3854, 3537, 4890,
      4091, 3587, 3009, 4167, 4325, 4150, 4352, 3538, 2828, 5329, 3801, 3292, 5082,
      4422, 3831, 3152, 4909, 181, 3619, 4733, 3719, 5605, 3585, 3953, 5574, 3838,
      4220, 4338, 4548, 4489, 6016, 177, 4237, 3851, 5842, 3676, 190, 4039, 5281,
      4486, 160, 5604, 5165, 5124, 5061, 204, 3877, 5619, 5073, 163, 5418, 5699,
      5611, 3980, 169, 4868, 4803, 5978, 492, 5741, 6204, 4623, 4828, 171, 5429,
      5100, 6493, 212, 5612, 6487, 5382, 146, 5911, 167, 7058, 5374, 183, 6380,
      5939, 174, 6249, 149, 6416, 6960, 189, 4397, 6641, 183, 9214, 173, 6352,
      5709, 167, 6852, 6559, 194, 8242, 215, 7655, 8511, 231, 6710, 8460, 225,
      8304, 229, 7659, 5498, 242, 8875, 8216, 235, 6256, 259, 6766, 7324, 382,
      5556, 4558, 314, 2906, 4187, 483, 5357, 7129, 8638, 8572, 194, 8010, 9463,
      10799, 9357, 224, 9640, 10362, 12175, 11532, 142, 9828, 11768, 11544, 13342,
      180, 11391, 10993, 13748, 14714, 153, 14131, 13286, 14024, 13413, 159, 16377,
      13557, 14695, 15592, 227, 16446, 17763, 18111, 15007, 16149, 36102, 18526,
      16362, 31815, 20678, 17826, 31510, 18366, 20699, 40545, 19413, 18308, 71554,
      20806, 20887, 41381, 11834, 7784, 26093, 30002, 34972, 73903, 51140, 45714,
      46026, 100884, 71777, 45025, 116852, 73026, 57319, 80114, 128337, 80770,
      42360, 63809, 119274, 155963, 142218, 187110, 321, 1474, 308, 288, 483,
      498, 512, 649974, 505, 399, 1054, 658, 560, 803, 2555, 1680574, 170332,
      823, 771, 668, 448, 361, 408, 465, 370, 326, 319, 530, 297, 278, 395, 242,
      404, 431, 489, 383, 262, 350, 284, 215, 219, 418, 240, 314, 286, 324, 313,
      631, 362, 255, 200, 239, 288, 258, 516, 239, 193, 243, 196, 192, 275, 197,
      275, 351, 604, 218, 608, 479, 474, 484, 238, 374, 859, 623, 554, 497, 490,
      534, 1279, 849, 593, 1036, 620, 1263, 1469, 1072, 939, 1475, 2079, 1447,
      2112, 1760, 2244, 198, 3461, 2839, 2921, 3671, 3293, 3388, 3352, 2694, 3187,
      3752, 3379, 3750, 3721, 2146, 4432, 2573, 3158, 4458, 3067, 4239, 3058, 2872,
      4124, 3044, 3740, 4064, 3871, 3109, 3135, 4809, 2974, 4911, 2910, 3724, 3793,
      3517, 3837, 3547, 4892, 4074, 3614, 2988, 4168, 4292, 4126, 4505, 3497, 2838,
      5270, 4121, 3410, 5083, 4571, 3927, 3226, 4934, 208, 3842, 4722, 3708, 5693,
      3572, 4003, 5625, 3951, 4236, 4396, 4533, 4523, 5990, 7895, 5889, 3602, 4026,
      5345, 4489, 5632, 10153, 5093, 3892, 5588, 5364, 5440, 5708, 5685, 8716, 4854,
      5954, 5728, 6251, 4657, 4813, 10403, 6540, 5673, 6485, 5354, 5980, 7121, 11608,
      5962, 6319, 6464, 7013, 4423, 6748, 15193, 5714, 6922, 6559, 8318, 7587, 8594,
      7069, 16662, 7694, 5518, 8955, 8260, 6291, 6768, 12704, 4636, 3051, 9454, 15659,
      8566, 17290, 20063, 19878, 23600, 21359, 24691, 22381, 44661, 14115, 27075,
      29490, 27835, 31731, 35710, 30885, 36067, 34703, 31758, 38644, 31559, 38877,
      40511, 37468, 55208, 41349, 41617, 19555, 26204, 65031, 73896, 96401, 103653,
      114721, 92347, 142025, 137029, 127955, 122449, 162137, 176160, 282055, 46609,
      1222, 57, 68, 131, 648593, 69, 95, 102, 1622466, 170311, 807, 785, 523, 405,
      412, 411, 455, 314, 263, 284, 469, 267, 323, 446, 201, 403, 353, 434, 298,
      459, 236, 390, 198, 199, 327, 215, 219, 251, 220, 180, 546, 290, 252, 310,
      175, 148, 156, 153, 289, 323, 222, 189, 183, 162, 183, 158, 305, 224, 203,
      145, 264, 235, 198, 232, 243, 180, 245, 271, 213, 244, 247, 338, 518, 264,
      280, 301, 283, 280, 223, 242, 248, 174, 182, 205, 212, 222, 185, 185, 256,
      242, 251, 328, 233, 258, 244, 229, 229, 191, 238, 135, 191, 175, 172, 172,
      608, 228, 194, 140, 248, 197, 168, 141, 273, 207, 203, 195, 628, 223, 209,
      763, 459, 155, 384, 423, 170, 212, 329, 276, 767, 550, 176, 404, 393, 130,
      567, 435, 411, 1165, 305, 487, 540, 405, 927, 593, 381, 1231, 1503, 263,
      1119, 904, 253, 1402, 2043, 192, 1418, 2355, 374, 1722, 209, 2249, 3477,
      192, 2822, 2844, 190, 6657, 3311, 3228, 2933, 6559, 3294, 3764, 5594, 4429,
      2501, 3093, 6897, 4169, 3053, 2883, 6933, 3700, 4069, 6585, 3098, 4840,
      2938, 7625, 3781, 3843, 7177, 8231, 7459, 7013, 8260, 4377, 6246, 8872,
      8228, 8102, 8164, 8155, 9150, 3608, 9406, 7688, 8702, 10320, 7920, 9387,
      9164, 9996, 10177, 8832, 10517, 10902, 9471, 9508, 11512, 10730, 10088,
      27937, 11955, 18027, 17409, 19413, 20024, 11725, 21371, 22652, 24248, 22257,
      20345, 12632, 9443, 15697, 25745, 20229, 20001, 33230, 23040, 24600, 24570,
      41748, 27233, 29590, 30321, 52224, 67385, 66304, 69771, 79316, 92443, 82585,
      45118, 138556, 199942, 206844, 278981, 250313, 338002, 328632, 1268, 167,
      2271005, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 5760000]
else:
  reference_hist = [111089, 836, 637, 524, 406, 484, 368, 330, 35365, 3425, 3430,
      2874, 6621, 3319, 3814, 5685, 4456, 2546, 3099, 6959, 4282, 3118, 2946, 7024,
      3701, 4054, 6626, 3163, 4803, 2889, 7661, 3841, 3806, 3582, 3856, 3572, 4895,
      4091, 3593, 3004, 4158, 4326, 4148, 4351, 3545, 2824, 5323, 3804, 3288, 5080,
      4432, 3836, 3150, 4903, 176, 3621, 4734, 3721, 5605, 3713, 3947, 5576, 3834,
      4074, 4341, 4516, 4486, 6125, 167, 4234, 3849, 5846, 3673, 190, 4043, 5274,
      4479, 162, 5600, 5164, 5128, 5060, 197, 3880, 5616, 5074, 160, 5423, 5706,
      5613, 3979, 192, 4865, 4808, 5978, 244, 5740, 6205, 4624, 4826, 170, 5429,
      5115, 6512, 207, 5615, 6481, 5404, 150, 5902, 171, 7064, 5376, 185, 6381,
      5978, 169, 6250, 147, 6452, 6961, 189, 4390, 6728, 180, 9208, 179, 6143,
      5709, 195, 6850, 6673, 188, 8240, 223, 7655, 8523, 229, 6712, 8464, 235,
      8303, 229, 7666, 5498, 237, 8868, 8217, 231, 6255, 266, 6768, 7325, 383,
      5549, 4734, 317, 2913, 4195, 257, 5362, 7136, 8627, 8674, 190, 8008, 9467,
      10811, 9351, 213, 9642, 10356, 12179, 11535, 138, 9827, 11768, 11539, 13338,
      187, 11383, 10984, 13745, 14754, 159, 14130, 13284, 14078, 13418, 166, 16377,
      13380, 14727, 15585, 224, 16505, 17762, 18118, 15012, 16175, 36093, 18533,
      16372, 31832, 20683, 17827, 31507, 18379, 20700, 40547, 19430, 18316, 71553,
      20799, 20889, 41387, 11831, 7775, 26087, 30085, 34971, 73909, 51143, 45512,
      46024, 100879, 71774, 45164, 116843, 73022, 57321, 80118, 128338, 80769,
      42354, 63785, 119293, 155957, 142223, 187109, 319, 1472, 320, 292, 489,
      491, 514, 649983, 506, 409, 1023, 758, 554, 790, 2583, 1680397, 170342,
      828, 761, 739, 433, 353, 410, 495, 366, 330, 323, 604, 295, 280, 408, 246,
      396, 431, 488, 398, 252, 338, 278, 218, 227, 430, 240, 317, 293, 314, 317,
      378, 365, 252, 199, 277, 293, 256, 523, 234, 183, 244, 196, 192, 281, 193,
      269, 354, 601, 217, 617, 484, 472, 478, 234, 374, 862, 623, 554, 625, 484,
      537, 1276, 701, 597, 1004, 617, 1372, 1458, 1069, 936, 1478, 2077, 1447,
      2114, 1753, 2238, 200, 3458, 2838, 2926, 3669, 3284, 3391, 3349, 2694, 3184,
      3757, 3387, 3753, 3721, 2169, 4429, 2576, 3159, 4210, 3066, 4240, 3067, 2862,
      4111, 3029, 3768, 4062, 3856, 3134, 3137, 4836, 2990, 4903, 2914, 3730, 3794,
      3520, 3838, 3585, 4886, 4076, 3612, 3026, 4169, 4291, 4119, 4592, 3494, 2834,
      5275, 3912, 3410, 5111, 4570, 4040, 3220, 4932, 216, 3842, 4733, 3706, 5694,
      3576, 4013, 5624, 3951, 4243, 4396, 4528, 4516, 5991, 7891, 5887, 3609, 4028,
      5346, 4490, 5625, 10329, 5096, 3899, 5596, 5139, 5443, 5714, 5673, 8819, 4850,
      5953, 5731, 6263, 4650, 4802, 10405, 6535, 5677, 6487, 5351, 5979, 7121, 11603,
      5958, 6326, 6457, 7004, 4420, 6787, 15200, 5713, 6920, 6614, 8322, 7595, 8594,
      6892, 16694, 7687, 5515, 9014, 8259, 6298, 6773, 12730, 4627, 3057, 9466, 15676,
      8571, 17291, 20060, 19892, 23600, 21361, 24708, 22389, 44660, 14108, 27077, 29496,
      27832, 31723, 35703, 30968, 36066, 34709, 31761, 38442, 31557, 38871, 40509,
      37607, 55200, 41344, 41619, 19558, 26206, 65030, 73890, 96394, 103654, 114729,
      92341, 142022, 137028, 127952, 122462, 162141, 176165, 282054, 46617, 1221, 56,
      78, 100, 648693, 63, 81, 131, 1622289, 170322, 811, 775, 597, 387, 403, 412,
      487, 310, 267, 288, 543, 265, 325, 458, 206, 393, 356, 431, 313, 451, 223,
      383, 201, 207, 340, 213, 224, 258, 209, 185, 293, 294, 248, 309, 211, 155,
      154, 159, 284, 315, 222, 187, 183, 168, 181, 150, 309, 220, 203, 155, 269,
      233, 191, 229, 245, 181, 246, 271, 341, 238, 248, 336, 371, 267, 248, 298,
      392, 270, 219, 240, 250, 173, 181, 208, 205, 215, 186, 183, 254, 246, 251,
      320, 235, 257, 245, 224, 234, 197, 241, 133, 215, 172, 175, 173, 359, 228,
      195, 141, 248, 196, 168, 156, 291, 201, 201, 186, 648, 237, 202, 710, 511,
      169, 385, 424, 209, 207, 330, 276, 804, 551, 175, 398, 480, 127, 562, 441,
      202, 1164, 333, 486, 653, 399, 926, 601, 381, 1242, 1501, 265, 1123, 914,
      252, 1403, 2049, 192, 1413, 2348, 375, 1718, 207, 2256, 3479, 193, 2823,
      2836, 366, 6660, 3318, 3236, 2708, 6562, 3301, 3753, 5696, 4425, 2499, 3097,
      6909, 4162, 3042, 2885, 6928, 3704, 4071, 6581, 3097, 4840, 2933, 7621, 3789,
      3833, 7168, 8227, 7500, 7020, 8258, 4375, 6300, 8876, 8236, 8102, 7988, 8187,
      9143, 3606, 9467, 7685, 8709, 10326, 7945, 9378, 9171, 10006, 10194, 8837,
      10518, 10899, 9484, 9509, 11514, 10748, 10096, 27936, 11948, 18029, 17415,
      19410, 20016, 11718, 21454, 22651, 24254, 22260, 20143, 12629, 9439, 15695,
      25884, 20221, 19996, 33232, 23044, 24601, 24569, 41742, 27226, 29591, 30329,
      52218, 67382, 66303, 69768, 79329, 92447, 82589, 45118, 138564, 199941, 206843,
      278991, 250282, 338102, 328626, 1254, 196, 2270828, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5760000]

def exercise_1(prefix="tst_add_arrows_on_plot_1"):
  model = mmtbx.model.manager(
      model_input = iotbx.pdb.input(source_info=None, lines=pdb_str))
  rama = ramalyze(model.get_hierarchy(), out=null_out())
  plots = rama.get_plots(
      show_labels=True,
      point_style='bo',
      markersize=1,
      markeredgecolor="black",
      dpi=300,
      markerfacecolor="white")

  ad_testing = []
  ad_testing.append( ((60,-120), (120, -120)) )
  ad_testing.append( ((-125, 120), (-125,  179)) )
  ad_testing.append( ((-120, 120), (-120, -120)) ) # wrapping up
  ad_testing.append( ((-115, -120), (-115, 120)) ) # wrapping down
  ad_testing.append( ((120, -60), (-120, -60)) ) # wrapping right
  ad_testing.append( ((-120, -65), (120, -65)) ) # wrapping left
  ad_testing.append( ((120, 0), (-120, 60)) ) # diag right
  ad_testing.append( ((-120, 55), (120, -5)) )# diag left
  ad_testing.append( ((-60, 120), (0, -120)) ) # diag up
  ad_testing.append( ((5, -120), (-55, 120)) ) # diag up
  ad_testing.append( ((150, 150), (-150, -150)) ) # going to top right corner straight
  ad_testing.append( ((140, 155), (-130, -140)) ) # going to top right corner not straight
  ad_testing.append( ((150, -150), (-150, 150)) ) # going to bottom right corner straight
  ad_testing.append( ((140, -155), (-130, 140)) ) # going to bottom right corner not straight
  ad_testing.append( ((-150, 150), (150, -150)) ) # going to top left corner straight
  ad_testing.append( ((-140, 155), (130, -140)) ) # going to top left corner not straight
  ad_testing.append( ((-150, -150), (150, 150)) ) # going to bottom left corner straight
  ad_testing.append( ((-140, -155), (130, 140)) ) # going to bottom left corner not straight

  plot = plots[0]
  add_arrows_on_plot(
      plot,
      ad_testing,
      color="red")
  plot_file_name = "%s.png" % prefix
  plot.save_image(plot_file_name, dpi=300)

  img = Image.open(plot_file_name)
  hist = img.histogram()
  # print(hist)
  hist_ok = True
  for ref, res in zip(reference_hist, hist):
    if (ref != res) and not (0.98 < ref/res < 1.02):
      hist_ok = False
      # print (ref, res, ref/res)
  assert hist_ok

if __name__ == '__main__':
  exercise_1()


 *******************************************************************************


 *******************************************************************************
mmtbx/regression/tst_add_h_to_water.py
from __future__ import absolute_import, division, print_function
from mmtbx.hydrogens import find as find_hydrogens
import mmtbx.model
import iotbx.pdb
from cctbx import miller
from scitbx.array_family import flex
from libtbx.test_utils import approx_equal, show_diff
from libtbx.utils import format_cpu_times
from six.moves import cStringIO as StringIO
from six.moves import zip

input_model = """\
CRYST1   15.000   15.000   15.000  80.00  70.00 100.00 P 1

HETATM    1  O   HOH X   1      20.319  10.959   7.882  1.00  1.00           O
HETATM    2  H1  HOH X   2      20.158  13.476  10.359  1.00  2.00           H
HETATM    3  O   HOH X   2      19.563  13.548   9.584  1.00  1.00           O

HETATM    4  O   HOH     1      17.253  15.650  10.892  1.00  2.00           O
HETATM    5  H1  HOH     1      18.134  15.627  11.321  1.00  2.00           H
HETATM    6  H2  HOH     1      17.375  15.320   9.977  1.00  2.00           H
HETATM    7  O   HOH     2       5.150  11.586  12.474  1.00  3.00           O

ATOM      8  CB  PHE A   1      11.914  10.410  11.811  1.00  2.00           C
ATOM      9  CG  PHE A   1      11.204   9.472  12.746  1.00  2.00           C
ATOM     10  CD2 PHE A   1      10.636   8.301  12.273  1.00  2.00           C
ATOM     11  CD1 PHE A   1      11.105   9.762  14.096  1.00  2.00           C
ATOM     12  CE2 PHE A   1       9.982   7.436  13.131  1.00  2.00           C
ATOM     13  CE1 PHE A   1      10.452   8.901  14.958  1.00  2.00           C
ATOM     14  CZ  PHE A   1       9.890   7.737  14.475  1.00  2.00           C
ATOM     15  C   PHE A   1      11.828  12.443  10.351  1.00  2.00           C
ATOM     16  O   PHE A   1      11.808  12.365   9.123  1.00  2.00           O
ATOM     17  OXT PHE A   1      12.531  13.314  10.864  1.00  2.00           O
ATOM     18  N   PHE A   1       9.929  10.880  10.444  1.00  2.00           N
ATOM     19  CA  PHE A   1      11.008  11.488  11.213  1.00  2.00           C

ATOM     20  O   HOH Q   1      15.736  13.074   8.108  1.00  4.00           O
ATOM     21  D1  HOH Q   1      14.756  13.074   8.108  1.00  4.00           D

ATOM     22  O   HOH S   1      14.337  16.126   9.974  1.00  5.00           O
ATOM     23  H2  HOH S   1      15.083  16.615   9.567  1.00  5.00           H
ATOM     24  O   HOH S   2       9.491  12.823  15.494  1.00  6.00           O
END
"""

expected_result = """\
CRYST1   15.000   15.000   15.000  80.00  70.00 100.00 P 1
SCALE1      0.066667  0.011755 -0.028131        0.00000
SCALE2      0.000000  0.067695 -0.017615        0.00000
SCALE3      0.000000  0.000000  0.073308        0.00000
HETATM    1  O   HOH X   1      20.319  10.959   7.882  1.00  1.00           O
HETATM    2  H1  HOH X   1      19.339  10.959   7.882  1.00  1.00           H
HETATM    3  H2  HOH X   1      19.339  10.959   7.882  1.00  1.00           H
HETATM    4  H1  HOH X   2      20.024  13.469  10.445  1.00  2.00           H
HETATM    5  O   HOH X   2      19.563  13.548   9.584  1.00  1.00           O
HETATM    6  H2  HOH X   2      18.608  13.419   9.761  1.00  1.00           H
HETATM    7  O   HOH     1      17.253  15.650  10.892  1.00  2.00           O
HETATM    8  H1  HOH     1      18.146  15.616  11.293  1.00  2.00           H
HETATM    9  H2  HOH     1      17.357  15.408   9.948  1.00  2.00           H
HETATM   10  O   HOH     2       5.150  11.586  12.474  1.00  3.00           O
HETATM   11  H1  HOH     2       4.364  12.000  12.888  1.00  3.00           H
HETATM   12  H2  HOH     2       5.938  11.998  12.886  1.00  3.00           H
ATOM     13  CB  PHE A   1      11.914  10.410  11.811  1.00  2.00           C
ATOM     14  CG  PHE A   1      11.204   9.472  12.746  1.00  2.00           C
ATOM     15  CD2 PHE A   1      10.636   8.301  12.273  1.00  2.00           C
ATOM     16  CD1 PHE A   1      11.105   9.762  14.096  1.00  2.00           C
ATOM     17  CE2 PHE A   1       9.982   7.436  13.131  1.00  2.00           C
ATOM     18  CE1 PHE A   1      10.452   8.901  14.958  1.00  2.00           C
ATOM     19  CZ  PHE A   1       9.890   7.737  14.475  1.00  2.00           C
ATOM     20  C   PHE A   1      11.828  12.443  10.351  1.00  2.00           C
ATOM     21  O   PHE A   1      11.808  12.365   9.123  1.00  2.00           O
ATOM     22  OXT PHE A   1      12.531  13.314  10.864  1.00  2.00           O
ATOM     23  N   PHE A   1       9.929  10.880  10.444  1.00  2.00           N
ATOM     24  CA  PHE A   1      11.008  11.488  11.213  1.00  2.00           C
ATOM     25  O   HOH Q   1      15.736  13.074   8.108  1.00  4.00           O
ATOM     26  D1  HOH Q   1      14.941  12.899   7.563  1.00  4.00           D
ATOM     27  D2  HOH Q   1      16.514  12.892   7.541  1.00  4.00           D
ATOM     28  O   HOH S   1      14.337  16.126   9.974  1.00  5.00           O
ATOM     29  H2  HOH S   1      14.968  16.680   9.469  1.00  5.00           H
ATOM     30  H1  HOH S   1      14.734  15.233  10.041  1.00  5.00           H
ATOM     31  O   HOH S   2       9.491  12.823  15.494  1.00  6.00           O
ATOM     32  H1  HOH S   2       8.899  13.604  15.494  1.00  6.00           H
ATOM     33  H2  HOH S   2       8.914  12.031  15.494  1.00  6.00           H
END
"""

def exercise_01():
  import libtbx.load_env
  if (not libtbx.env.has_module("reduce")):
    print("Reduce not installed, needed for model.add_hydrogens(). skipping")
    return

  pdb_file_name = "add_h_to_hoh.pdb"
  tmp_f = open(pdb_file_name, "w")
  tmp_f.write(input_model)
  tmp_f.close()
  pdb_inp = iotbx.pdb.input(source_info=None, file_name=pdb_file_name)
  model = mmtbx.model.manager(
    model_input = pdb_inp,
    log = None)
  model.process(make_restraints=True)
  ####
  model.add_hydrogens(correct_special_position_tolerance=1.0)
  result = StringIO()
  pdb_str = model.model_as_pdb()
  result.write(pdb_str)
  result = result.getvalue().splitlines()
  ####
  result1 = []

  # for r1 in result:
  for r1 in iotbx.pdb.input(
      source_info = None, lines=result).construct_hierarchy().\
      as_pdb_string().split("\n"):
    if(r1.startswith("ATOM") or r1.startswith("HETATM")): result1.append(r1)
  result2 = []
  # for r2 in expected_result.splitlines():
  for r2 in iotbx.pdb.input(
      source_info = None, lines=expected_result).construct_hierarchy().\
      as_pdb_string().split("\n"):
    if(r2.startswith("ATOM") or r2.startswith("HETATM")): result2.append(r2)
  assert len(result1) == len(result2)
  print("\n".join(result1))
  print("==="*30)
  print("\n".join(result2))
  print("==="*30)
  for r1, r2 in zip(result1, result2):
    r1 = r1[:30] + r1[60:]
    r2 = r2[:30] + r2[60:]
    print("r1", r1)
    print("r2", r2)
    print()
    # assert not show_diff(r1, r2)
    show_diff(r1, r2)
    # XXX It is not clear why H1 should have Bfactor=2 and not H2.
  ####
  cntr = 0
  xrs1 = iotbx.pdb.pdb_input(source_info = None, lines = flex.std_string(
      expected_result.splitlines())).\
      construct_hierarchy().extract_xray_structure()
  xrs2 = iotbx.pdb.pdb_input(source_info = None, lines = flex.std_string(result)
    ).construct_hierarchy().extract_xray_structure()
  for s1, s2 in zip(xrs1.scatterers(), xrs2.scatterers()):
    if(s1.element_symbol().strip() not in ['H','D']):
      assert s1.element_symbol().strip() == s2.element_symbol().strip()
      assert approx_equal(s1.site, s2.site, 0.03)
      cntr += 1
  assert cntr == 19

model_good = """\
CRYST1   15.000   15.000   15.000  80.00  70.00 100.00 P 1
ATOM      1  CB  PHE A   1      12.073   9.948  11.650  1.00  5.00           C
ATOM      2  CG  PHE A   1      11.316   9.114  12.643  1.00  5.00           C
ATOM      3  CD1 PHE A   1      10.646   7.971  12.240  1.00  5.00           C
ATOM      4  CD2 PHE A   1      11.276   9.472  13.980  1.00  5.00           C
ATOM      5  CE1 PHE A   1       9.949   7.202  13.152  1.00  5.00           C
ATOM      6  CE2 PHE A   1      10.581   8.706  14.897  1.00  5.00           C
ATOM      7  CZ  PHE A   1       9.916   7.570  14.482  1.00  5.00           C
ATOM      8  C   PHE A   1      12.110  11.913  10.097  1.00  5.00           C
ATOM      9  O   PHE A   1      12.051  11.781   8.875  1.00  5.00           O
ATOM     10  OXT PHE A   1      12.892  12.748  10.551  1.00  5.00           O
ATOM     11  N   PHE A   1      10.096  10.513  10.307  1.00  5.00           N
ATOM     12  CA  PHE A   1      11.240  11.067  11.021  1.00  5.00           C
HETATM   13  O   HOH     1      13.866  16.009  12.098  1.00  3.00           O
HETATM   14  H1  HOH     1      13.327  16.140  12.905  1.00  3.00           H
HETATM   15  H2  HOH     1      14.117  16.901  11.777  1.00  3.00           H
HETATM   16  O   HOH     2      17.215  16.288  11.122  1.00  3.00           O
HETATM   17  H1  HOH     2      17.912  15.900  10.553  1.00  3.00           H
HETATM   18  H2  HOH     2      17.641  16.523  11.973  1.00  3.00           H
HETATM   19  O   HOH     3       8.927  12.312  13.459  1.00  3.00           O
HETATM   20  H1  HOH     3       8.879  11.933  14.362  1.00  3.00           H
HETATM   21  H2  HOH     3       8.721  11.584  12.835  1.00  3.00           H
HETATM   22  O   HOH     4      16.005  11.974   8.964  1.00  3.00           O
HETATM   23  H1  HOH     4      16.817  12.516   9.046  1.00  3.00           H
HETATM   24  H2  HOH     4      15.632  12.153   8.076  0.00  3.00           H
HETATM   25  O   HOH     5      13.626   9.207   8.521  1.00  3.00           O
HETATM   26  H1  HOH     5      13.711   9.868   7.803  1.00  3.00           H
HETATM   27  H2  HOH     5      14.464   9.228   9.028  0.00  3.00           H
HETATM   28  O   HOH     6       9.841  14.509  11.210  1.00  3.00           O
HETATM   29  H1  HOH     6      10.096  14.540  12.156  1.00  3.00           H
HETATM   30  H2  HOH     6       9.341  13.676  11.079  0.00  3.00           H
END
"""
model_bad = """\
CRYST1   15.000   15.000   15.000  80.00  70.00 100.00 P 1
ATOM      1  CB  PHE A   1      12.073   9.948  11.650  1.00  5.00           C
ATOM      2  CG  PHE A   1      11.316   9.114  12.643  1.00  5.00           C
ATOM      3  CD1 PHE A   1      10.646   7.971  12.240  1.00  5.00           C
ATOM      4  CD2 PHE A   1      11.276   9.472  13.980  1.00  5.00           C
ATOM      5  CE1 PHE A   1       9.949   7.202  13.152  1.00  5.00           C
ATOM      6  CE2 PHE A   1      10.581   8.706  14.897  1.00  5.00           C
ATOM      7  CZ  PHE A   1       9.916   7.570  14.482  1.00  5.00           C
ATOM      8  C   PHE A   1      12.110  11.913  10.097  1.00  5.00           C
ATOM      9  O   PHE A   1      12.051  11.781   8.875  1.00  5.00           O
ATOM     10  OXT PHE A   1      12.892  12.748  10.551  1.00  5.00           O
ATOM     11  N   PHE A   1      10.096  10.513  10.307  1.00  5.00           N
ATOM     12  CA  PHE A   1      11.240  11.067  11.021  1.00  5.00           C
HETATM   13  O   HOH     1      13.866  16.009  12.098  1.00  3.00           O
HETATM   14  H1  HOH     1      13.114  16.628  12.001  0.00  3.00           H
HETATM   15  H2  HOH     1      13.771  15.335  11.392  0.00  3.00           H
HETATM   16  O   HOH     2      17.215  16.288  11.122  1.00  3.00           O
HETATM   17  H1  HOH     2      16.474  16.378  10.487  0.00  3.00           H
HETATM   18  H2  HOH     2      17.045  15.476  11.644  0.00  3.00           H
HETATM   19  O   HOH     3       8.927  12.312  13.459  1.00  3.00           O
HETATM   20  H1  HOH     3       8.895  11.898  14.347  0.00  3.00           H
HETATM   21  H2  HOH     3       7.999  12.412  13.159  0.00  3.00           H
HETATM   22  O   HOH     4      16.005  11.974   8.964  1.00  3.00           O
HETATM   23  H1  HOH     4      16.427  11.730   9.814  0.00  3.00           H
HETATM   24  H2  HOH     4      16.642  11.748   8.255  0.00  3.00           H
HETATM   25  O   HOH     5      13.626   9.207   8.521  1.00  3.00           O
HETATM   26  H1  HOH     5      13.711   9.868   7.803  0.00  3.00           H
HETATM   27  H2  HOH     5      14.464   9.228   9.028  0.00  3.00           H
HETATM   28  O   HOH     6       9.839  14.506  11.213  1.00  3.00           O
HETATM   29  H1  HOH     6      10.483  13.917  10.766  0.00  3.00           H
HETATM   30  H2  HOH     6       9.067  14.586  10.614  0.00  3.00           H
END
"""
expected_result2 = """\

==================== Fit water hydrogens into residual map ====================


                    ----------find peak-candidates----------

Number of peaks found at mFobs-DFmodel map (map cutoff=6.50 sigma)= 9
Filter by distance & map next to the model:
   mapped sites are within: 0.981 - 1.005
   number of sites selected in [dist_min= 0.70, dist_max= 1.05]: 9 from: 9
   mapped sites are within: 0.981 - 1.005

peak=   26.730 closest distance to pdb=" O   HOH     1 " =    0.989
peak=   24.366 closest distance to pdb=" O   HOH     1 " =    0.984
peak=   26.526 closest distance to pdb=" O   HOH     2 " =    1.000
peak=   24.945 closest distance to pdb=" O   HOH     2 " =    0.998
peak=   24.980 closest distance to pdb=" O   HOH     3 " =    0.989
peak=   24.312 closest distance to pdb=" O   HOH     3 " =    0.984
peak=   24.152 closest distance to pdb=" O   HOH     4 " =    1.004
peak=   24.564 closest distance to pdb=" O   HOH     5 " =    0.988
peak=   24.243 closest distance to pdb=" O   HOH     6 " =    1.007

                  ----------6D rigid body fit of HOH----------

Fit quality:
 0.027
 0.040
 0.021
 0.020
 0.007
 0.025
"""

def exercise_02():
  for file_name, input_model in [("m_good.pdb",model_good), ("m_bad.pdb",model_bad)]:
    tmp_f = open(file_name, "w")
    tmp_f.write(input_model)
    tmp_f.close()
  xrs_exact = iotbx.pdb.pdb_input(
    file_name = "m_good.pdb").xray_structure_simple()
  model = mmtbx.model.manager(
      model_input = iotbx.pdb.input(file_name="m_bad.pdb"))
  xrs_part = model.get_xray_structure()
  miller_set = miller.build_set(
    crystal_symmetry = xrs_exact.crystal_symmetry(),
    anomalous_flag   = False,
    d_min            = 0.6)
  f_obs = abs(miller_set.structure_factors_from_scatterers(
    xray_structure = xrs_exact,
    algorithm      = "direct",
    cos_sin_table  = False).f_calc())
  sf_par = mmtbx.f_model.sf_and_grads_accuracy_master_params.extract()
  sf_par.algorithm = "direct"
  sf_par.cos_sin_table = False
  fmodel = mmtbx.f_model.manager(
    xray_structure               = xrs_part,
    sf_and_grads_accuracy_params = sf_par,
    target_name                  = "ls_wunit_k1",
    f_obs                        = f_obs)
  #
  out = StringIO()
  params = find_hydrogens.all_master_params().extract()
  params.map_cutoff=6.5
  find_hydrogens.run(fmodel=fmodel, model=model, log=out, params=params)

if (__name__ == "__main__"):
  exercise_01()
  exercise_02()
  print(format_cpu_times())


 *******************************************************************************
