

 *******************************************************************************
mmtbx/ions/__init__.py
# -*- coding: utf-8; py-indent-offset: 2 -*-
"""
This package is used to model elemental ions in crystal structures. It handles
both identification and building of ions, but relies on the solvent module to
flag candidate sites for screening.

Notes
-----
.. [1] Echols, N. et al. Automated identification of elemental ions in
       macromolecular crystal structures. Acta Crystallogr. D. Biol.
       Crystallogr. 70, 1104â€“14 (2014).
"""

from __future__ import absolute_import, division, print_function
import iotbx.cif
from libtbx import group_args, Auto, slots_getstate_setstate
from libtbx.utils import Sorry
from libtbx import group_args
from math import exp
import time
import os
import sys

DEFAULT_IONS = ["MG", "CA", "ZN", "CL"]
HALIDES = ["F", "CL", "BR", "IOD"]
TRANSITION_METALS = ["MN", "FE", "CO", "CU", "NI", "ZN", "PT"]
SUPPORTED = TRANSITION_METALS + HALIDES + ["NA", "MG", "K", "CA", "CD", "HG"]

def _cif_param_as_list(param):
  if (param == ".") : return None
  return param.split(",")

def _cif_param_as_int(param):
  if (param == ".") : return None
  return int(param)

def _cif_param_as_float(param):
  if (param == ".") : return None
  return float(param)

class metal_parameters(group_args):
  def __str__(self):
    return "%s%+d" % (self.element.upper(), self.charge)

  def charge_as_int(self):
    """
    Gets the charge of a parameter as an integer.

    Returns
    -------
    int
    """
    return self.charge

  def scattering_type(self):
    """
    Makes a string showing the element and its associated charge. Note that this
    format is slightly different from the __str__ method, which puts the +/-
    between the element symbol and the charge number.

    Returns
    -------
    str

    Examples
    --------
    >>> from mmtbx.ions import metal_parameters
    >>> print metal_parameters(element="FE", charge=3)
    FE+3
    >>> print metal_parameters(element="FE", charge=3).scattering_type()
    FE3+
    >>> print metal_parameters(element="CL", charge=-1).scattering_type()
    CL1-
    """
    charge_symbol = ""
    if (self.charge > 0):
      charge_symbol = "+"
    elif (self.charge < 0):
      charge_symbol = "-"
    s = "%2s%1d%s" % (self.element.strip(), abs(self.charge), charge_symbol)
    return s

class parameter_server(slots_getstate_setstate):
  """
  Class for retrieving information from ion_parameters.cif

  Attributes
  ----------
  params : iotbx.cif.model.block
  """

  __slots__ = ["params", "_metal_params", "_charge_params", "_resname_elem",
               "_default_charges"]
  def __init__(self):
    params_path = os.path.join(os.path.split(__file__)[0],
      "ion_parameters.cif")
    assert os.path.isfile(params_path)
    cif_model = iotbx.cif.reader(file_path=params_path).model()
    self.params = cif_model["ions"]
    self._metal_params = {}
    self._charge_params = {}
    self._resname_elem = {}
    self._default_charges = {}

  def is_supported_element(self, symbol):
    """
    Checks if symbol is a supported element by this parameter server.

    Parameters
    ----------
    symbol : str

    Returns
    -------
    bool
    """
    return symbol in self.params['_lib_valence.atom_symbol']

  def is_supported_donor(self, symbol):
    """
    Checks if an element is a supported donor atom.

    Parameters
    ----------
    symbol : str

    Returns
    -------
    bool
    """
    return symbol in self.params['_lib_valence.donor_symbol']

  def get_valence_params(self, atom1, atom2):
    """
    Gets the valence parameters (r_0 and b) used for calculating valences from
    bond distances.

    Parameters
    ----------
    atom1 : mmtbx.ions.metal_parameters
    atom2 : mmtbx.ions.metal_parameters

    Returns
    -------
    float or None
        r_0 in the equation exp((r - r_0) / b)
    float or None
        b in the equation exp((r - r_0) / b)

    Examples
    --------
    >>> from mmtbx.ions import server, metal_parameters
    >>> zn_params = metal_parameters(element="ZN", charge=2)
    >>> n_params = metal_parameters(element="N", charge=-3)
    >>> print server.get_valence_params(zn_params, n_params)
    (1.77, 0.37)
    """
    for i_elem, symbol in enumerate(self.params['_lib_valence.atom_symbol']):
      if (symbol == atom1.element):
        i_charge = int(self.params['_lib_valence.atom_charge'][i_elem])
        i_other = self.params['_lib_valence.donor_symbol'][i_elem]
        i_other_charge = int(self.params['_lib_valence.donor_charge'][i_elem])
        if ((i_charge == atom1.charge_as_int()) and
            (i_other == atom2.element) and
            (i_other_charge == atom2.charge_as_int())):
          valence = float(self.params['_lib_valence.value'][i_elem])
          return valence, 0.37
    charge1 = atom1.charge_as_int()
    charge2 = atom2.charge_as_int()
    return None, None

  def _get_default_charge(self, element):
    if element in self._default_charges:
      return self._default_charges[element]
    p = self.params
    for i_elem, elem in enumerate(p["_lib_charge.element"]):
      if elem == element:
        charge = int(p["_lib_charge.charge"][i_elem])
        self._default_charges[element] = charge
        return charge
    return 0

  def _get_charge_params(self, resname, element=None):
    resname = resname.strip().upper()
    if element is not None:
      element = element.strip().upper()
    p = self.params
    if element is None:
      # Determine the element from the residue name (I.E. "HOH" => "O")
      if resname in self._resname_elem:
        element = self._resname_elem[resname]
      else:
        resn_elements = [(resn, p["_lib_charge.element"][i_resn])
                         for i_resn, resn in enumerate(p["_lib_charge.resname"])
                         if resn == resname]
        if len(resn_elements) > 1:
          raise Sorry("Ambiguous element for residue: " + resname)
        elif len(resn_elements) < 1:
          raise Sorry("Unknown element for residue: " + resname)
        element = resn_elements[0][1]
        self._resname_elem[resname] = element
    if (resname, element) in self._charge_params:
      return self._charge_params[(resname, element)]
    for i_resn, resn in enumerate(p["_lib_charge.resname"]):
      if resn == resname and element == p["_lib_charge.element"][i_resn]:
        elem_charge = \
          p["_lib_charge.element"][i_resn], int(p["_lib_charge.charge"][i_resn])
        break
    else:
      elem_charge = element, self._get_default_charge(element)
    self._charge_params[(resname, element)] = elem_charge
    return elem_charge

  def get_element(self, atom):
    """
    Gets the element associated with an atom.

    Parameters
    ----------
    atom : iotbx.pdb.hierarchy.atom or str

    Returns
    -------
    str
    """
    if isinstance(atom, str):
      resname = atom.strip().upper()
      if resname in self.params["_lib_charge.element"]:
        return resname
    else:
      if hasattr(atom, "element") and isinstance(atom.element, str):
        return atom.element.strip().upper()
      resname = atom.fetch_labels().resname.strip().upper()
    return self._get_charge_params(resname=resname)[0]

  def get_charge(self, atom):
    """
    Gets the charge associated with an atom or element.

    Parameters
    ----------
    atom : iotbx.pdb.hierarchy.atom or str

    Returns
    -------
    int

    Examples
    --------
    >>> from iotbx.pdb.hierarchy import atom
    >>> from mmtbx.ions import server
    >>> atom_dummy = atom()
    >>> atom_dummy.element = "N"
    >>> atom_dummy.charge = "-3"
    >>> print server.get_charge(atom_dummy)
    -3
    >>> print server.get_charge("N")
    -3
    """
    if isinstance(atom, str):
      atom = atom.strip().upper()
      try:
        charge = self._get_charge_params(resname=atom)[1]
      except Sorry:
        charge = self._get_charge_params(resname="", element=atom)[1]
    else:
      charge = atom.charge
      if not isinstance(charge, int):
        charge = atom.charge_as_int()
      if charge != 0:
        return charge
      resname = atom.fetch_labels().resname.strip().upper()
      element = atom.element.strip().upper()
      charge = self._get_charge_params(resname=resname, element=element)[1]
    return charge

  def get_charges(self, atom):
    """
    Retrieves all charges that are expected to be associated with an atom or
    element within ion_parameters.cif. This list is manually updated based on
    the ligand IDs listed by the PDB.

    Parameters
    ----------
    atom : iotbx.pdb.hierarchy.atom or str

    Returns
    -------
    list of int

    Examples
    --------
    >>> from mmtbx.ions import server
    >>> print server.get_charges("CU")
    [1, 2, 3]
    >>> print server.get_charges("ZN")
    [2]
    """
    element = self.get_element(atom)
    p = self.params
    charges = set()
    for i_elem, elem in enumerate(p["_lib_charge.element"]):
      if elem == element:
        charges.add(int(p["_lib_charge.charge"][i_elem]))
    return sorted(charges)

  def get_metal_parameters(self, element):
    """
    Gets all metal parameters associated with an element.

    Parameters
    ----------
    element : str

    Returns
    -------
    mmtbx.ions.metal_parameters or None
    """
    p = self.params
    for i_elem, symbol in enumerate(p['_lib_elems.element']):
      if (symbol == element.upper()):
        if (symbol in self._metal_params):
          return self._metal_params[symbol]
        assert (p['_lib_ligands.element'][i_elem] == symbol)
        params = metal_parameters(
          element=symbol,
          charge=_cif_param_as_int(p['_lib_elems.charge'][i_elem]),
          vec_sum_cutoff=_cif_param_as_float(
            p["_lib_elems.vec_sum_cutoff"][i_elem]),
          coord_num_lower=_cif_param_as_int(
            p["_lib_elems.coord_num_lower"][i_elem]),
          coord_num_upper=_cif_param_as_int(
            p["_lib_elems.coord_num_upper"][i_elem]),
          min_coordinating_non_waters=_cif_param_as_int(
            p["_lib_elems.min_coordinating_non_waters"][i_elem]),
          cvbs_lower=_cif_param_as_float(p['_lib_elems.cvbs_lower'][i_elem]),
          cvbs_upper=_cif_param_as_float(p['_lib_elems.cvbs_upper'][i_elem]),
          cvbs_expected=_cif_param_as_float(
            p['_lib_elems.cvbs_expected'][i_elem]),
          allowed_coordinating_atoms=_cif_param_as_list(
            p['_lib_ligands.allowed_coordinating_atoms'][i_elem]),
          allowed_coordinating_residues=_cif_param_as_list(
            p['_lib_ligands.allowed_coordinating_residues'][i_elem]),
          allowed_geometries=_cif_param_as_list(
            p['_lib_ligands.allowed_geometries'][i_elem]),
          allowed_backbone_atoms=_cif_param_as_list(
            p['_lib_ligands.allowed_backbone_atoms'][i_elem]))
        self._metal_params[symbol] = params
        return params
    return None

  def calculate_valence(self, ion, donor, distance):
    """
    Calculates the single valence contribution of one ion donor pair,
    separated by distance. ion and donor should be AtomGuess objects.

    Parameters
    ----------
    ion : mmtbx.ions.metal_parameters
    donor : mmtbx.ions.metal_parameters
    distance : float

    Returns
    -------
    float

    Examples
    --------
    >>> from mmtbx.ions import server, metal_parameters
    >>> ion = server.get_metal_parameters("ZN")
    >>> donor = metal_parameters(element="N", charge="-3")
    >>> valence = server.calculate_valence(ion, donor, 2.20)
    >>> print round(valence, 2)
    0.31
    """
    element = donor.element
    if (not self.is_supported_donor(element)):
      return 0
    r_0, b = self.get_valence_params(ion, donor)
    if (r_0 is None):
      # Try again, this time using the default charge for the donor
      donor = metal_parameters(
        charge=self.get_charge(element),
        element=element)
      r_0, b = self.get_valence_params(ion, donor)
      if r_0 is None:
        return 0
    return exp((r_0 - distance) / b)

  def calculate_valences(self, ion, nearby_atoms):
    """
    Calculates all of the valence contributions between ion and each
    atom of nearby_atoms, each element of which should be a tuple of an
    atom and a vector from the ion's location.

    Parameters
    ----------
    ion : mmtbx.ions.metal_parameters
    nearby_atoms : list of mmtbx.ions.environment.atom_contact

    Returns
    -------
    list of scitbx.matrix.rec
        List of vectors, whose magnitudes are equal to the valence contributions
        from each donor atom.

    Examples
    --------
    >>> from libtbx import group_args
    >>> from iotbx.pdb.hierarchy import atom
    >>> from mmtbx.ions import server
    >>> from mmtbx.ions.environment import atom_contact
    >>> from scitbx.matrix import rec
    >>> ion = server.get_metal_parameters("ZN")
    >>> vector_1 = rec([2.0, 0, 0], [1, 3])
    >>> vector_2 = rec([-2.0, 0, 0], [1, 3])
    >>> vector_3 = rec([0, 2.0, 0], [1, 3])
    >>> vector_4 = rec([0, 0, 2.0], [1, 3])
    >>> atom_dummy = atom()
    >>> atom_dummy.element = "N"
    >>> atom_dummy.charge = "-3"
    >>> atom_dummy.occ = 1
    >>> atom_dummy.parent = lambda: group_args(atoms=lambda: [])
    >>> donors = [atom_contact(atom_dummy, vector_1, None, None),
    ...           atom_contact(atom_dummy, vector_2, None, None),
    ...           atom_contact(atom_dummy, vector_3, None, None),
    ...           atom_contact(atom_dummy, vector_4, None, None)]
    >>> vectors = server.calculate_valences(ion, donors)
    >>> bvs = sum(abs(i) for i in vectors)
    >>> print round(bvs, 2)
    2.15
    """
    vectors = []
    for contact in nearby_atoms:
      donor = metal_parameters(
        element=contact.element,
        charge=contact.charge)
      distance = abs(contact.vector)
      valence = self.calculate_valence(ion, donor, distance) * contact.occ
      if valence == 0:
        if ((donor.element not in ["H", "C", "AX"]) and
            (not self.is_supported_donor(donor.element))):
          pass
      elif distance != 0:
        vectors.append(contact.vector / distance * valence)
    return vectors

def check_supported(elements):
  """
  Checks if elements are supported by ion identitication process.

  Parameters
  ----------
  elements : list of str

  Returns
  -------
  bool

  Raises
  ------
  libtbx.utils.Sorry

  Examples
  --------
  >>> from mmtbx.ions import check_supported
  >>> check_supported(["CA", "ZN", "FE"])
  True
  """
  if (elements is None):
    raise Sorry("No elements specified for ion picking - must be either "+
      "'Auto' or a comma-separated list of element symbols.")
  elif (elements is not Auto):
    # XXX somehow comma-separation of phil strings fields doesn't work
    if isinstance(elements, str) or isinstance(elements, unicode):
      elements = elements.replace(",", " ").split()
    elif (isinstance(elements, list)) and (len(elements) == 1):
      elements = elements[0].split(",")
    if (elements == ['X']) : # XXX hack for testing - X is "dummy" element
      return True
    for elem in elements :
      if (not elem.strip().upper() in SUPPORTED):
        raise Sorry(
          ("Identification of ions with element symbol '%s' is not supported! "+
          "Choices are: %s") % (elem, " ".join(SUPPORTED)))
  return True

# global parameter_server instance
server = parameter_server()

class atom_type_flags(object):
  """
  Simple container for information about the identity of an atom via a set of
  enumerated boolean flags.  The responsibility for toggling these flags based
  on analysis of the site is left to external code.

  Parameters
  ----------
  name: element symbol or HOH

  Examples
  --------
  >>> flags = atom_type_flags("HOH")
  >>> if (fofc_map_value > 3.0):
  ...   flags.high_fofc = True
  """
  flag_names_and_labels = [
    # these flags usually indicate a heavier atom type
    ("low_b_iso", "Abnormally low B-factor"),
    ("high_occ", "Abnormally high occupancy"),
    ("high_fofc", "mFo-DFc peak"),
    ("high_two_fofc", "Abnormally high 2mFo-DFc map value"),
    ("high_anom", "Anomalous map peak"),
    ("high_fdp", "Abnormally high refined f''"),
    # the next set suggest a lighter element (or water, or nothing)
    ("high_b_iso", "Abnormally high B-factor"),
    ("low_occ", "Abnormally low occupancy"),
    ("low_two_fofc", "Low 2mFo-DFc map value"),
    ("low_fofc", "mFo-DFc hole"),
    ("low_anom", "Poor anomalous map value"),
    ("low_fdp", "Abnormally low refined f''"),
    #
    ("bad_geom", "Unexpected coordination geometry"),
    ("missing_geom", "No recognizable coordination geometry"),
    ("bad_vectors", "Bad coordination vectors"),
    ("bad_valence", "Bad bond valence sum"),
    ("too_few_non_waters", "Too few non-water coordinating atoms"),
    ("too_few_coord", "Too few coordinating atoms"),
    ("too_many_coord", "Too many coordinating atoms"),
    ("like_coord", "Coordinating atom of same charge"),
    ("bad_coord_atom", "Disallowed or unusual coordinating atom"),
    ("bad_coord_residue", "Disallowed or unusual coordinating residue"),
    ("very_bad_valence", "Very bad bond valence sum"),
    ("bad_halide", "Poor halide site"),
    ("coord_geom",
      "Appears to be coordinating another site with distinct geometry"),
    ("close_contact", "Unusually close contact to oxygen atom"),
  ]
  __slots__ = [ fl for (fl, label) in flag_names_and_labels ] + ["name"]
  def __init__(self, name):
    self.name = name
    for attr in self.__slots__[:-1] :
      setattr(self, attr, False)

  def get_flag_captions(self):
    """
    Retrieve a list of strings describing the issues that have been identified.
    These will have '+++' or '---' appended if they indicate that the actual
    element is heavier or lighter than the current refined scatterer type.
    """
    captions = []
    for i_attr, attr in enumerate(self.__slots__[:-1]):
      if getattr(self, attr):
        if (i_attr < 6) : # probably something heavier
          captions.append("%s (+++)" % self.flag_names_and_labels[i_attr][1])
        elif (6 <= i_attr < 12) : # probably something lighter
          captions.append("%s (---)" % self.flag_names_and_labels[i_attr][1])
        else :
          captions.append(self.flag_names_and_labels[i_attr][1])
    return captions

  def show(self, out=sys.stdout, prefix=""):
    """
    Print out a list of all issues that have been identified.
    """
    captions = self.get_flag_captions()
    if (len(captions) == 0):
      print(prefix+"(No problems detected.)", file=out)
    else :
      print(prefix+"The following problems were detected with %s:" %\
        self.name, file=out)
      have_plus = have_minus = False
      for caption in caption :
        print(prefix+"  %s" % caption, file=out)
        if ("---" in caption) : have_minus = True
        elif ("+++" in caption) : have_plus = True
      if (have_plus or have_minus):
        print(prefix+\
          "(+++ indicates a heavier element, --- indicates a lighter one)", file=out)


 *******************************************************************************


 *******************************************************************************
mmtbx/ions/build.py
"""
Deals with modifying a structure to include unbuilt and misidentified ions.
"""

from __future__ import absolute_import, division, print_function
from libtbx.str_utils import make_sub_header
from libtbx.utils import null_out
from libtbx import Auto
import sys

svm_params = ""
try :
  from mmtbx.ions import svm     # import dependency
  from libsvm import svmutil # import dependency
except ImportError :
  pass
else :
  svm_params = """
use_svm = True
  .type = bool
  .short_caption = Use Support Vector Machine to classify candidate ions
  .expert_level = 1
include scope mmtbx.ions.svm.svm_phil_str
"""

ion_building_params_str = """
debug = False
  .type = bool
  .short_caption = Debugging mode (verbose)
ion_chain_id = X
  .type = str
  .input_size = 80
  .short_caption = Ion chain ID
initial_occupancy = 1.0
  .type = float(value_min=0.01)
  .input_size = 80
  .help = Occupancy for newly placed ions - if less than 1.0, the occupancy \
    may be refined automatically in future runs of phenix.refine.
initial_b_iso = Auto
  .type = float(value_min=1.0)
  .input_size = 80
  .short_caption = Initial B-iso
refine_ion_occupancies = True
  .type = bool
  .help = Toggles refinement of occupancies for newly placed ions.  This \
    will only happen if the occupancy refinement strategy is selected.
refine_ion_adp = *Auto isotropic anisotropic none
  .type = choice
  .short_caption = Refine ion B-factor
  .help = B-factor refinement type for newly placed ions.  At medium-to-high \
    resolution, anisotropic refinement may be preferrable for the heavier \
    elements.
refine_anomalous = True
  .type = bool
  .short_caption = Model anomalous scattering
  .help = If True and the wavelength is specified, any newly placed ions will \
    have anomalous scattering factors refined.  This is \
    unlikely to affect R-factors but should flatten the anomalous LLG map.
max_distance_between_like_charges = 3.5
  .type = float
%s
""" % svm_params

def find_and_build_ions(
      manager,
      fmodels,
      model,
      wavelength,
      params,
      nproc=1,
      elements=Auto,
      out=None,
      run_ordered_solvent=False,
      occupancy_strategy_enabled=False,
      group_anomalous_strategy_enabled=False,
      use_svm=None):
  """
  Analyzes the water molecules in a structure and re-labels them as ions if
  they scatter and bind environments that we expect of that ion.

  Parameters
  ----------
  manager : mmtbx.ions.identity.manager
  fmodels : mmtbx.fmodels
  model : mmtbx.model.manager
  wavelength : float
  params : libtbx.phil.scope_extract
  nproc : int, optional
  elements : list of str, optional
  out : file, optional
  run_ordered_solvent : bool, optional
  occupancy_strategy_enabled : bool, optional
  group_anomalous_strategy_enabled : bool, optional
  use_svm : bool, optional

  See Also
  --------
  mmtbx.ions.identify.manager.analyze_waters
  """
  import mmtbx.refinement.minimization
  from mmtbx.refinement.anomalous_scatterer_groups import \
    get_single_atom_selection_string
  from mmtbx.refinement import anomalous_scatterer_groups
  import mmtbx.ions.identify
  import mmtbx.ions.svm
  from cctbx.eltbx import sasaki
  from cctbx import crystal
  from cctbx import adptbx
  from cctbx import xray
  from scitbx.array_family import flex
  import scitbx.lbfgs
  if (use_svm is None):
    use_svm = getattr(params, "use_svm", False)
  assert (1.0 >= params.initial_occupancy >= 0)
  fmodel = fmodels.fmodel_xray()
  anomalous_flag = fmodel.f_obs().anomalous_flag()
  if (out is None) : out = sys.stdout
  model.set_xray_structure(fmodel.xray_structure)
  model.get_xray_structure().tidy_us()
  pdb_hierarchy = model.get_hierarchy()
  pdb_atoms = pdb_hierarchy.atoms()
  pdb_atoms.reset_i_seq()
  # FIXME why does B for anisotropic waters end up negative?
  u_iso = model.get_xray_structure().extract_u_iso_or_u_equiv()
  for i_seq, atom in enumerate(pdb_atoms):
    labels = atom.fetch_labels()
    if (labels.resname == "HOH") and (atom.b < 0):
      assert (u_iso[i_seq] >= 0)
      atom.b = adptbx.u_as_b(u_iso[i_seq])
  if (manager is None):
    manager_class = None
    if (use_svm):
      manager_class = mmtbx.ions.svm.manager
      if params.svm.svm_name == "merged_high_res" :
        params.find_anomalous_substructure = False
        params.use_phaser = False
    manager = mmtbx.ions.identify.create_manager(
      pdb_hierarchy=pdb_hierarchy,
      geometry_restraints_manager=model.restraints_manager.geometry,
      fmodel=fmodel,
      wavelength=wavelength,
      params=params,
      nproc=nproc,
      verbose=params.debug,
      log=out,
      manager_class=manager_class)
  else :
    grm = model.get_restraints_manager().geometry
    connectivity = grm.shell_sym_tables[0].full_simple_connectivity()
    manager.update_structure(
      pdb_hierarchy=pdb_hierarchy,
      xray_structure=fmodel.xray_structure,
      connectivity=connectivity,
      log=out)
    manager.update_maps()
  model.update_anomalous_groups(out=out)
  make_sub_header("Analyzing water molecules", out=out)
  manager.show_current_scattering_statistics(out=out)
  anomalous_groups = []
  # XXX somehow comma-separation of phil strings fields doesn't work
  if (isinstance(elements, list)) and (len(elements) == 1):
    elements = elements[0].split(",")
  water_ion_candidates = manager.analyze_waters(
    out=out,
    candidates=elements)
  modified_iselection = flex.size_t()
  default_b_iso = manager.get_initial_b_iso()
  # Build in the identified ions
  for_building = []
  if (use_svm):
    for result in water_ion_candidates :
      for_building.append((result.i_seq, result.final_choice))
  else :
    for i_seq, final_choices, two_fofc in water_ion_candidates :
      if (len(final_choices) == 1):
        for_building.append((i_seq, final_choices[0]))
  skipped = []
  if (len(for_building) > 0):
    make_sub_header("Adding %d ions to model" % len(for_building), out)
    for k, (i_seq, final_choice) in enumerate(for_building):
      atom = manager.pdb_atoms[i_seq]
      skip = False
      for other_i_seq, other_ion in for_building[:k] :
        if (other_i_seq in skipped) : continue
        if (((other_ion.charge > 0) and (final_choice.charge > 0)) or
            ((other_ion.charge < 0) and (final_choice.charge < 0))):
          other_atom = manager.pdb_atoms[other_i_seq]
          dxyz = atom.distance(other_atom)
          if (dxyz < params.max_distance_between_like_charges):
            print("  %s (%s%+d) is only %.3fA from %s (%s%+d), skipping for now" %\
              (atom.id_str(), final_choice.element, final_choice.charge, dxyz,
               other_atom.id_str(), other_ion.element, other_ion.charge), file=out)
            skipped.append(i_seq)
            skip = True
            break
      if (skip) : continue
      print("  %s becomes %s%+d" % \
          (atom.id_str(), final_choice.element, final_choice.charge), file=out)
      refine_adp = params.refine_ion_adp
      if (refine_adp == "Auto"):
        if (fmodel.f_obs().d_min() <= 1.5):
          refine_adp = "anisotropic"
        elif (fmodel.f_obs().d_min() < 2.5):
          atomic_number = sasaki.table(final_choice.element).atomic_number()
          if (atomic_number >= 19):
            refine_adp = "anisotropic"
      # Modify the atom object - this is clumsy but they will be grouped into
      # a single chain at the end of refinement
      initial_b_iso = params.initial_b_iso
      if (initial_b_iso is Auto):
        initial_b_iso = manager.guess_b_iso_real(i_seq)
      element = final_choice.element
      if (element == "IOD") : # FIXME
        element = "I"
      modified_atom = model.convert_atom(
        i_seq=i_seq,
        scattering_type=final_choice.scattering_type(),
        atom_name=element,
        element=element,
        charge=final_choice.charge,
        residue_name=final_choice.element,
        initial_occupancy=params.initial_occupancy,
        initial_b_iso=initial_b_iso,
        chain_id=params.ion_chain_id,
        segid="ION",
        refine_adp=refine_adp,
        refine_occupancies=False) #params.refine_ion_occupancies)
      if (params.refine_anomalous) and (anomalous_flag):
        scatterer = model.get_xray_structure().scatterers()[i_seq]
        if (wavelength is not None):
          fp_fdp_info = sasaki.table(final_choice.element).at_angstrom(
            wavelength)
          scatterer.fp = fp_fdp_info.fp()
          scatterer.fdp = fp_fdp_info.fdp()
          print("    setting f'=%g, f''=%g" % (scatterer.fp,
            scatterer.fdp), file=out)
        group = xray.anomalous_scatterer_group(
          iselection=flex.size_t([i_seq]),
          f_prime=scatterer.fp,
          f_double_prime=scatterer.fdp,
          refine=["f_prime","f_double_prime"],
          selection_string=get_single_atom_selection_string(modified_atom),
          update_from_selection=True)
        anomalous_groups.append(group)
      modified_iselection.append(i_seq)
  if (len(modified_iselection) > 0):
    scatterers = model.get_xray_structure().scatterers()
    # FIXME not sure this is actually working as desired...
    site_symmetry_table = model.get_xray_structure().site_symmetry_table()
    for i_seq in site_symmetry_table.special_position_indices():
      scatterers[i_seq].site = crystal.correct_special_position(
        crystal_symmetry=model.get_xray_structure(),
        special_op=site_symmetry_table.get(i_seq).special_op(),
        site_frac=scatterers[i_seq].site,
        site_label=scatterers[i_seq].label,
        tolerance=1.0)
    model.get_xray_structure().replace_scatterers(scatterers=scatterers)
    model.set_xray_structure(model.get_xray_structure())
    def show_r_factors():
       return "r_work=%6.4f r_free=%6.4f" % (fmodel.r_work(), fmodel.r_free())
    fmodel.update_xray_structure(
      xray_structure=model.get_xray_structure(),
      update_f_calc=True,
      update_f_mask=True)
    n_anom = len(anomalous_groups)
    refine_anomalous = anomalous_flag and params.refine_anomalous and n_anom>0
    refine_occupancies = ((params.refine_ion_occupancies or refine_anomalous)
      and ((not occupancy_strategy_enabled) or
           (model.refinement_flags.s_occupancies is None) or
           (len(model.refinement_flags.s_occupancies) == 0)))
    if (refine_anomalous):
      if (model.have_anomalous_scatterer_groups() and
          (group_anomalous_strategy_enabled)):
        model.set_anomalous_scatterer_groups(
            model.get_anomalous_scatterer_groups()+anomalous_groups)
        refine_anomalous = False
    if (refine_occupancies) or (refine_anomalous):
      print("", file=out)
      print("  occupancy refinement (new ions only): start %s" % \
        show_r_factors(), file=out)
      fmodel.xray_structure.scatterers().flags_set_grads(state = False)
      fmodel.xray_structure.scatterers().flags_set_grad_occupancy(
        iselection = modified_iselection)
      lbfgs_termination_params = scitbx.lbfgs.termination_parameters(
        max_iterations = 25)
      minimized = mmtbx.refinement.minimization.lbfgs(
        restraints_manager       = None,
        fmodels                  = fmodels,
        model                    = model,
        is_neutron_scat_table    = False,
        lbfgs_termination_params = lbfgs_termination_params)
      fmodel.xray_structure.adjust_occupancy(
        occ_max   = 1.0,
        occ_min   = 0,
        selection = modified_iselection)
      zero_occ = []
      for i_seq in modified_iselection :
        occ = fmodel.xray_structure.scatterers()[i_seq].occupancy
        if (occ == 0):
          zero_occ.append(i_seq)
      fmodel.update_xray_structure(
        update_f_calc=True,
        update_f_mask=True)
      print("                                        final %s" % \
        show_r_factors(), file=out)
      if (len(zero_occ) > 0):
        print("  WARNING: occupancy dropped to zero for %d atoms:", file=out)
        atoms = model.get_atoms()
        for i_seq in zero_occ :
          print("    %s" % atoms[i_seq].id_str(suppress_segid=True), file=out)
      print("", file=out)
    if (refine_anomalous):
      assert fmodel.f_obs().anomalous_flag()
      print("  anomalous refinement (new ions only): start %s" % \
        show_r_factors(), file=out)
      fmodel.update(target_name="ls")
      anomalous_scatterer_groups.minimizer(
        fmodel=fmodel,
        groups=anomalous_groups)
      fmodel.update(target_name="ml")
      print("                                        final %s" % \
        show_r_factors(), file=out)
      print("", file=out)
  return manager

def clean_up_ions(fmodel, model, params, log=None, verbose=True):
  """
  Parameters
  ----------
  fmodel : mmtbx.f_model.manager
  model : mmtbx.model.manager
  params : libtbx.phil.scope_extract
  log : file, optional
  verbose : bool, optional

  Returns
  -------
  mmtbx.model.manager
      An updated model with ions corrected.
  """
  if (log is None):
    log = null_out()
  import mmtbx.ions.utils
  ion_selection = model.selection(
    "segid ION")
  ion_iselection = ion_selection.iselection()
  if (len(ion_iselection) == 0):
    print("  No ions (segid=ION) found.", file=log)
    return model
  n_sites_start = model.get_number_of_atoms()
  new_model = model.select(~ion_selection)
  ion_model = model.select(ion_selection)
  ion_pdb_hierarchy = ion_model.get_hierarchy()
  ion_atoms = ion_pdb_hierarchy.atoms()
  ion_xrs = ion_model.get_xray_structure()
  perm = mmtbx.ions.utils.sort_atoms_permutation(
    pdb_atoms=ion_pdb_hierarchy.atoms(),
    xray_structure=ion_model.get_xray_structure())
  nonbonded_types = ion_model.restraints_manager.geometry.nonbonded_types
  nonbonded_charges = ion_model.restraints_manager.geometry.nonbonded_charges
  ion_atoms = ion_atoms.select(perm)
  new_model.append_single_atoms(
    new_xray_structure=ion_xrs.select(perm),
    atom_names=[ atom.name for atom in ion_atoms ],
    residue_names=[ atom.fetch_labels().resname for atom in ion_atoms ],
    nonbonded_types=nonbonded_types.select(perm),
    nonbonded_charges=nonbonded_charges.select(perm),
    chain_id=params.ion_chain_id,
    segids=[ "ION" for atom in ion_atoms ],
    refine_occupancies=params.refine_ion_occupancies,
    refine_adp="isotropic",
    reset_labels=True,
    conformer_indices=None)
  n_sites_end = new_model.get_number_of_atoms()
  new_hierarchy = new_model.get_hierarchy()
  n_sites_pdb = new_hierarchy.atoms_size()
  assert (n_sites_start == n_sites_end == n_sites_pdb)
  new_selection = new_hierarchy.atom_selection_cache().selection("segid ION")
  ion_atoms = new_hierarchy.atoms().select(new_selection)
  if (verbose):
    print("  Final list of ions:", file=log)
    for atom in ion_atoms :
      print("    %s" % atom.id_str(), file=log)
    print("", file=log)
  fmodel.update_xray_structure(new_model.get_xray_structure())
  return new_model


 *******************************************************************************


 *******************************************************************************
mmtbx/ions/environment.py
# -*- coding: utf-8; py-indent-offset: 2 -*-
"""
Deals with examing the atoms around a site and recognizing distinct and useful
chemical environments.
"""

from __future__ import absolute_import, division, print_function
from mmtbx import ions
from iotbx.pdb import common_residue_names_get_class as get_class
from cctbx.eltbx import sasaki
from scitbx.matrix import col
from libtbx.utils import Sorry
from libtbx import slots_getstate_setstate
from collections import Counter
from six.moves import range

# Enums for the chemical environments supported by this module
N_SUPPORTED_ENVIRONMENTS = 14
chem_carboxy, \
  chem_amide, \
  chem_backbone, \
  chem_water, \
  chem_sulfate, \
  chem_phosphate, \
  chem_disulfide, \
  chem_nitrogen_primary, \
  chem_nitrogen_secondary, \
  chem_nitrogen_tertiary, \
  chem_chloride, \
  chem_oxygen, \
  chem_nitrogen, \
  chem_sulfur = range(N_SUPPORTED_ENVIRONMENTS)

CHEM_ENV_LABELS = [
  "Coordinating carboxy group",
  "Coordinating amide group",
  "Coordinating backbone atom",
  "Coordinating water molecule",
  "Coordinating sulfate group",
  "Coordinating phosphate group",
  "Coordinating disulfide group",
  "Coordinating primary nitrogen",
  "Coordinating secondary nitrogen",
  "Coordinating tertiary nitrogen",
  "Coordinating chloride",
  "Coordinating oxygen",
  "Coordinating nitrogen",
  "Coordinating sulfur",
  ]

class ScatteringEnvironment(slots_getstate_setstate):
  """
  Container for information summarizing a site's scattering environment.

  Attributes
  ----------
  d_min : float
  wavelengeth : float
  fp : float
  fpp : float
  b_iso : float
  b_mean_hoh : float
  occ : float
  fo_density : tuple of float, float
  fofo_density : tuple of float, float
  anom_density : tuple of float, float
  pai : float
      Principal axes of inertia at site, currently unused.
  """
  __slots__ = ["d_min", "wavelength", "fp", "fpp", "b_iso", "b_mean_hoh", "occ",
               "fo_density", "fofc_density", "anom_density", "pai"]
  def __init__(self,
      i_seq,
      manager,
      fo_map=None,
      fofc_map=None,
      anom_map=None,
      fo_density=None,
      fofc_density=None,
      anom_density=None):
    assert ([fo_map, fo_density].count(None) == 1)
    assert ([fofc_map, fofc_density].count(None) == 1)
    assert ([anom_map, anom_density].count(None) >= 1)
    atom = manager.pdb_atoms[i_seq]
    self.d_min = manager.fmodel.f_obs().d_min()
    self.wavelength = manager.wavelength
    self.fp, self.fpp = manager.get_fp(i_seq), manager.get_fpp(i_seq)
    site_frac = manager.unit_cell.fractionalize(atom.xyz)
    if (fo_density is not None):
      self.fo_density = fo_density
    else :
      self.fo_density = ions.utils.fit_gaussian(manager.unit_cell, atom.xyz,
        fo_map)
    if (fofc_density is not None):
      self.fofc_density = fofc_density
    else :
      self.fofc_density = (fofc_map.eight_point_interpolation(site_frac), 0,)
    if anom_density is not None:
      self.anom_density = anom_density
    elif anom_map is not None:
      self.anom_density = (anom_map.eight_point_interpolation(site_frac), 0,)
    else:
      self.anom_density = None, None
    self.b_iso = manager.get_b_iso(i_seq)
    self.b_mean_hoh = manager.b_mean_hoh
    self.occ = atom.occ
    self.pai = manager.principal_axes_of_inertia(i_seq).center_of_mass()

# TODO
#  def is_outlier(self, element):
#    """
#    Indicate whether the scattering is consistent with the given element (which
#    is assumed to be the refined scattering type).
#    """
#    flags = []
#    fp_fdp = None
#    if (self.wavelength is not None):
#      table = sasaki.table(element)
#      fp_fdp = table.at_angstrom(self.wavelength)
#    if (self.fpp is not None):
#      if (fp_fdp is not None):
#        fdp_expected = fp_fdp.fdp()
#        if (self.fpp > fdp_expected*1.2):
#          flags.append(flag_anom_high
#    if (self.anom_density is not None):
#      if (fp_fdp.wave

class atom_contact(slots_getstate_setstate):
  """
  Container for information about an interacting atom.  Most of the methods
  are simply wrappers for frequently called operations on the atom object, but
  symmetry-aware.

  Attributes
  ----------
  atom : iotbx.pdb.hierarchy.atom
  charge : int
  element : str
  rt_mx : cctbx.sgtbx.rt_mx
  site_cart : tuple of float, float, float
  vector : scitbx.matrix.rec
  """
  __slots__ = ["atom", "vector", "site_cart", "rt_mx", "is_carboxy_terminus",
               "element", "charge"]
  def __init__(self, atom, vector, site_cart, rt_mx):
    self.atom = atom.fetch_labels()
    self.is_carboxy_terminus = _is_carboxy_terminus(atom)
    self.vector = vector
    self.site_cart = site_cart
    self.rt_mx = rt_mx
    self.element = ions.server.get_element(atom)
    self.charge = ions.server.get_charge(atom)

  def distance(self):
    """
    Actual distance from target atom.

    Returns
    -------
    float
        Distance, in angstroms.
    """
    return abs(self.vector)

  def distance_from(self, other):
    """
    Distance from another coordinating atom.

    Parameters
    ----------
    other : mmtbx.ions.environment.atom_contact

    Returns
    -------
    float
        Distance, in angstroms.
    """
    return abs(self.vector - other.vector)

  def id_str(self, suppress_rt_mx=False):
    """
    Creates a string from the atom's id string and the symmetry operator
    associated with that site.

    Parameters
    ----------
    suppress_rt_mx : bool, optional
        Don't include symmetry operator information in the string.

    Returns
    -------
    str
    """
    if (not self.rt_mx.is_unit_mx()) and (not suppress_rt_mx):
      return self.atom.id_str() + " " + str(self.rt_mx)
    else :
      return self.atom.id_str()

  def atom_name(self):
    """
    Retrieves the coordinating atom's name (i.e. "OX1")

    Returns
    -------
    str
    """
    return self.atom.name.strip()

  def resname(self):
    """
    Retrieves the residue name associated with te coordinating atom (i.e. "ARG")

    Returns
    -------
    str
    """
    return self.atom.fetch_labels().resname.strip().upper()

  @property
  def occ(self):
    """
    Occupancy of the coordinating atom.

    Returns
    -------
    float
    """
    return self.atom.occ

  def atom_i_seq(self):
    """
    Retrieves the sequence ID of the coordinating atom.

    Returns
    -------
    int
    """
    return self.atom.i_seq

  def altloc(self):
    """
    Retrieves the alternate conformation label, if any, of the coordinating
    atom.

    Returns
    -------
    str
    """
    return self.atom.fetch_labels().altloc.strip()

  def atom_id_no_altloc(self, suppress_rt_mx=False):
    """
    Unique identifier for an atom, ignoring the altloc but taking the symmetry
    operator (if any) into account.

    Parameters
    ----------
    suppress_rt_mx : bool, optional

    Returns
    -------
    str
    """
    labels = self.atom.fetch_labels()
    base_id = labels.chain_id + labels.resid() + self.atom.name
    if (self.rt_mx.is_unit_mx()) or (suppress_rt_mx):
      return base_id
    else :
      return base_id + " " + str(self.rt_mx)

  def __eq__(self, other):
    """
    Equality operator, taking symmetry into account but ignoring the
    altloc identifier.

    Parameters
    ----------
    other : mmtbx.ions.environment.atom_contact

    Returns
    -------
    bool
    """
    return (other.atom_id_no_altloc() == self.atom_id_no_altloc())

  def __abs__(self):
    return self.distance()

  def __str__(self):
    return self.id_str()

class ChemicalEnvironment(slots_getstate_setstate):
  """
  Container for information summarizing a site's chemical environment.

  Attributes
  ----------
  atom : iotbx.pdb.hierarchy.atom
  contacts : list of mmtbx.ions.environment.atom_contact
  contacts_no_alts : list of mmtbx.ions.environment.atom_contact
  chemistry : collections.Counter of int, int
  geometry : list of tuples of str, float
  """
  __slots__ = ["atom", "contacts", "contacts_no_alts", "chemistry", "geometry"]

  def __init__(self, i_seq, contacts, manager):
    """
    Parameters
    ----------
    i_seq : int
    contacts : list of mmtbx.ions.environment.atom_contact
    manager : mmtbx.ions.identify.manager
    """
    self.atom = manager.pdb_atoms[i_seq].fetch_labels()

    self.contacts = contacts
    self.contacts_no_alts = []

    # Filter down the list of contacts so it doesn't include alt locs
    for index, contact in enumerate(contacts):
      if contact.element in ["H", "D"]:
        continue

      no_alt_loc = True
      for other_contact in contacts[index + 1:]:
        if _same_atom_different_altloc(contact.atom, other_contact.atom) and \
          contact.rt_mx == other_contact.rt_mx:
          no_alt_loc = False
          break
      if no_alt_loc:
        self.contacts_no_alts.append(contact)

    self.chemistry = self._get_chemical_environment(
      self.contacts_no_alts, manager)
    self.geometry = ions.geometry.find_coordination_geometry(
      self.contacts_no_alts, minimizer_method=True)

    # We can either store the contacts or generate a list of valences for all of
    # the atom types we want to test. I'm choosing the former because it's more
    # flexible down the road and contacts is pickable anyways.
    # self.valences = None

  def get_valence(self, element, charge=None):
    """
    Calculates the BVS and VECSUM for a given element / charge identity.

    Parameters
    ----------
    element : str
        The element identity to calculate valences for.
    charge : int, optional
        The charge to calculate valences for.

    Returns
    -------
    float
        Bond-valence sum (BVS).
    float
        Vector sum (VECSUM).

    Notes
    -----
    .. [1] MÃ¼ller, P., KÃ¶pke, S. & Sheldrick, G. M. Is the bond-valence method
           able to identify metal atoms in protein structures? Acta
           Crystallogr. D. Biol. Crystallogr. 59, 32â€“7 (2003).
    """
    if charge is None:
      charge = ions.server.get_charge(element)
    ion_params = ions.metal_parameters(element=element, charge=charge)
    vectors = ions.server.calculate_valences(ion_params, self.contacts)
    bvs = sum(abs(i) for i in vectors)
    if bvs > 0:
      vecsum = abs(sum(vectors, col((0, 0, 0)))) / bvs
    else:
      vecsum = 0
    return bvs, vecsum

  def _get_chemical_environment(self, contacts, manager):
    """
    Examines an atom contact object for chemical properties useful to ion
    picking. These properties include degree of connectivitiy, presence in
    carboxy and amide groups, disulfide bonds, and so on.

    Parameters
    ----------
    contacts : list of mmtbx.ions.atom_contact
        The contact objects to examine the chemical environments of. Generally
        created by manager.find_nearby_atoms.
    manager : mmtbx.ions.identify.manager
        The ions manager that created contact. Used for auxillary information
        such as bond connectivity.

    Returns
    -------
    collections.Counter
        The chemical environments found for contacts.
    """
    def _non_hydrogen_neighbors(seq):
      """
      Parameters
      ----------
      seq : int
          The atom.i_seq to find the neighbors of.

      Returns
      -------
      list of int
          A list of neighboring atoms that does not include any hydrogens.
      """
      neighbors = []
      for other in manager.connectivity[seq]:
        other_atom = manager.pdb_atoms[other]
        if ions.server.get_element(other_atom) not in ["H", "D"]:
          neighbors.append(other)
      return neighbors

    def _n_non_altlocs(i_seqs):
      """
      Count the number of neighbors, filtering out those that are alt-locs of
      other neighboring atoms.
      """
      non_alt_locs = []
      for index, i_seq in enumerate(i_seqs):
        no_alt_loc = True
        for j_seq in i_seqs[index + 1:]:
          if _same_atom_different_altloc(
              manager.pdb_atoms[i_seq], manager.pdb_atoms[j_seq]):
            no_alt_loc = False
            break
        if no_alt_loc:
          non_alt_locs.append(i_seq)
      return len(non_alt_locs)

    chem_env = Counter()

    for contact in contacts:
      # Add any of our included elements
      element = contact.element
      i_seq = contact.atom.i_seq
      neighbor_elements = [ions.server.get_element(manager.pdb_atoms[i])
                           for i in _non_hydrogen_neighbors(i_seq)]

      n_neighbors = _n_non_altlocs(_non_hydrogen_neighbors(i_seq))

      # Check for waters, sulfates, phosphates, chlorides, etc
      if element == "CL":
        chem_env[chem_chloride] += 1
      elif element == "O":
        chem_env[chem_oxygen] += 1
        if get_class(contact.resname()) in ["common_water"]:
          chem_env[chem_water] += 1
        elif "S" in neighbor_elements:
          chem_env[chem_sulfate] += 1
        elif "P" in neighbor_elements:
          chem_env[chem_phosphate] += 1
      elif element == "N":
        chem_env[chem_nitrogen] += 1
        # Check the degree of connectivity on nitrogens
        if n_neighbors == 1:
          chem_env[chem_nitrogen_primary] += 1
        elif n_neighbors == 2:
          chem_env[chem_nitrogen_secondary] += 1
        elif n_neighbors == 3:
          chem_env[chem_nitrogen_tertiary] += 1
        elif n_neighbors != 0:
          raise Sorry("Nitrogen with more than three coordinating atoms: " +
                      contact.atom.id_str())
      elif element == "S":
        chem_env[chem_sulfur] += 1
        # Check for disulfide bridges
        if "S" in neighbor_elements:
          chem_env[chem_disulfide] += 1

      # Check for backbone nitrogens
      if contact.atom.name.strip().upper() in ["N", "C", "O", "CA"] and \
        get_class(contact.resname()) in ["common_amino_acid"]:
        chem_env[chem_backbone] += 1

      # Check for carboxy / amide groups
      if element in ["O", "N"] and n_neighbors == 1:
        for j_seq in _non_hydrogen_neighbors(i_seq):
          j_atom = manager.pdb_atoms[j_seq]
          if ions.server.get_element(j_atom) in ["C"]:
            for k_seq in manager.connectivity[j_seq]:
              k_neighbors = _non_hydrogen_neighbors(k_seq)
              k_atom = manager.pdb_atoms[k_seq]
              if k_seq != i_seq and _n_non_altlocs(k_neighbors) in [1]:
                k_element = ions.server.get_element(k_atom)
                if set([element, k_element]) == set(["O", "O"]):
                  chem_env[chem_carboxy] += 1
                elif set([element, k_element]) == set(["N", "O"]):
                  chem_env[chem_amide] += 1

    return chem_env

def find_nearby_atoms(
    i_seq,
    xray_structure,
    pdb_atoms,
    asu_mappings,
    asu_table,
    connectivity,
    far_distance_cutoff=3.0,
    near_distance_cutoff=1.5,
    filter_by_bonding=True):
  """
  Given site in the structure, return a list of nearby atoms with the
  supplied cutoff, and the vectors between them and the atom's site. Takes
  into account symmetry operations when finding nearby sites.

  Parameters
  ----------
  i_seq : int
  xray_structure : cctbx.xray.structure.structure
  pdb_atoms : iotbx.pdb.hierarchy.af_shared_atom
  asu_mappings : cctbx.crystal.direct_space_asu.asu_mappings
  asu_table : cctbx.crystal.pair_tables.pair_asu_table
  connectivity : scitbx.array_family.shared.stl_set_unsigned
  far_distance_cutoff : float, optional
  near_distance_cutoff : float, optional
  filter_by_bonding : bool, optional

  Returns
  -------
  list of mmtbx.ions.environment.atom_contact
  """
  contacts = []
  unit_cell = xray_structure.unit_cell()
  sites_frac = xray_structure.sites_frac()
  site_frac = sites_frac[i_seq]
  asu_dict = asu_table[i_seq]
  site_i = sites_frac[i_seq]
  rt_mx_i_inv = asu_mappings.get_rt_mx(i_seq, 0).inverse()
  atom_i = pdb_atoms[i_seq]
  # Create the primary list of contacts
  for j_seq, j_sym_groups in asu_dict.items():
    site_j = sites_frac[j_seq]
    atom_j = pdb_atoms[j_seq]
    # Filter out hydrogens
    if atom_j.element.upper().strip() in ["H", "D"]:
      continue
    # Filter out alternate conformations of this atom
    if _same_atom_different_altloc(atom_i, atom_j):
      continue
    # Gather up contacts with all symmetric copies
    for j_sym_group in j_sym_groups:
      for j_sym_id in j_sym_group :
        rt_mx = rt_mx_i_inv.multiply(asu_mappings.get_rt_mx(j_seq, j_sym_id))
        site_ji = rt_mx * site_j
        site_ji_cart = unit_cell.orthogonalize(site_ji)
        vec_i = col(unit_cell.orthogonalize(site_frac=site_frac))
        vec_ji = col(site_ji_cart)
        assert abs(vec_i - vec_ji) < far_distance_cutoff + 0.5
        contact = atom_contact(
          atom = atom_j,
          vector = vec_i - vec_ji,
          site_cart = site_ji_cart,
          rt_mx = rt_mx)
        # XXX I have no idea why the built-in handling of special positions
        # doesn't catch this for us
        if (j_seq == i_seq) and (not rt_mx.is_unit_mx()):
          continue
        if contact.distance() < near_distance_cutoff:
          continue
        contacts.append(contact)
  # Filter out carbons that are judged to be "contacts", but are actually
  # just bonded to genuine coordinating atoms.  This is basically just a
  # way to handle sidechains such as His, Asp/Glu, or Cys where the carbons
  # may be relatively close to the metal site.
  if filter_by_bonding and (connectivity is not None):
    filtered = []
    all_i_seqs = [contact.atom_i_seq() for contact in contacts]
    for contact in contacts:
      # oxygen is always allowed, other elements may not be
      if contact.element not in ["C", "P", "S", "N"]:
        filtered.append(contact)
        continue
      # Remove atoms within 1.9 A contact distance
      if any(other_contact != contact and
             contact.distance_from(other_contact) < 1.9 and
             contact.distance() > other_contact.distance()
             for other_contact in contacts):
        continue
      # Examine the mode connectivity to catch more closely bonded atoms
      bonded_j_seqs = []
      for j_seq in connectivity[contact.atom_i_seq()]:
        if (j_seq in all_i_seqs):
          bonded_j_seqs.append(j_seq)
      for j_seq in bonded_j_seqs:
        other_contact = contacts[all_i_seqs.index(j_seq)]
        if other_contact.element in ["N", "O", "S"] and \
          abs(other_contact) < abs(contact):
          break
      else:
        filtered.append(contact)
    contacts = filtered
  return contacts

########################################################################
# UTILITY METHODS
#
def _is_carboxy_terminus(pdb_object):
  """
  Checks if an atom or residue is part of a carboxy terminus.

  Parameters
  ----------
  pdb_object : iotbx.pdb.hierarchy.atom or iotbx.pdb.hierarchy.residue_group or
               iotbx.pdb.hierarchy.atom_group

  Returns
  -------
  bool

  .. note:: Deprecated in favor ChemicalEnvironment._get_chemical_environment in
            the SVM code.
  """
  atoms = None
  if (type(pdb_object).__name__ == "atom"):
    atoms = pdb_object.parent().atoms()
  else :
    assert (type(pdb_object).__name__ in ['residue_group','atom_group'])
    atoms = pdb_object.atoms()
  for atom in atoms :
    if (atom.name.strip() == "OXT"):
      return True
  return False

def _same_atom_different_altloc(atom1, atom2):
  """
  Determines whether atom1 and atom2 differ only by their alternate location.

  Parameters
  ----------
  atom1 : iotbx.pdb.hierarchy.atom
  atom2 : iotbx.pdb.hierarchy.atom

  Returns
  -------
  bool
  """

  label1, label2 = [i.fetch_labels() for i in [atom1, atom2]]
  name1, name2 = atom1.name.strip(), atom2.name.strip()
  chain1, chain2 = label1.chain_id, label2.chain_id
  res1, res2 = label1.resid(), label2.resid()
  return name1 == name2 and chain1 == chain2 and res1 == res2


 *******************************************************************************


 *******************************************************************************
mmtbx/ions/geometry.py
# -*- coding: utf-8; py-indent-offset: 2 -*-
"""
This module provides tools for examining a set of vectors and find the geometry
that best fits from a set of built in shapes.
"""

from __future__ import absolute_import, division, print_function
from scitbx.matrix import col
from collections import OrderedDict
try:
  from collections.abc import Iterable
except ImportError:
  from collections import Iterable
from math import sqrt
from six.moves import zip


def _bond_angles(vectors):
  """
  Creates a list of angles (In degrees) between all two-element combinations
  in vectors.

  Parameters
  ----------
  vectors : scitbx.matrix.col

  Returns
  -------
  list of float
  """

  return [(v1, v2, v1.angle(v2, deg=True))
          for index, v1 in enumerate(vectors)
          for v2 in vectors[index + 1:]]

def _is_tetrahedron(vectors, dev_cutoff=20):
  """
  Tetrahedrons have four vertices, with angles between all pairs of vertices
  uniformly about 104.5 degrees.

  Parameters
  ----------
  vectors : list scitbx.matrix.col
  dev_cutoff : float, optional

  Returns
  -------
  bool
  """

  if len(vectors) > 4 or len(vectors) < 3:
    return

  angles = _bond_angles(vectors)
  deviation = sqrt(sum(abs(i[2] - 104.5) ** 2 for i in angles) / len(vectors))

  if deviation <= dev_cutoff:
    return deviation, 4 - len(vectors)

def _is_trigonal_plane(vectors, dev_cutoff=20):
  """
  Triangular planar geometry has three vertices (By definition all on the same
  equatorial plane). The expected angles are 120 degrees between neighboring
  vertices.

  Parameters
  ----------
  vectors : list scitbx.matrix.col
  dev_cutoff : float, optional

  Returns
  -------
  bool
  """
  if len(vectors) != 3:
    return

  angles = _bond_angles(vectors)
  a_120s = []

  for angle in angles:
    a_120s.append(angle[2] - 120)

  deviation = sqrt(sum(i ** 2 for i in a_120s) / len(angles))

  if deviation <= dev_cutoff:
    return deviation, 3 - len(vectors)

def _is_square_plane(vectors, dev_cutoff=20):
  """
  Square planar geometry has four vertices, all on the same equatorial plane.
  The expected angles are 90 degrees between neighboring vertices and 180
  degrees between vertices across from one another.

  Parameters
  ----------
  vectors : list scitbx.matrix.col
  dev_cutoff : float, optional

  Returns
  -------
  bool
  """

  if len(vectors) != 4:
    return

  angles = _bond_angles(vectors)

  # Expect 2x 180 degrees and 4x 90 degrees
  a_90s = []
  a_180s = []

  for angle in angles:
    if abs(angle[2] - 90) < abs(angle[2] - 180):
      a_90s.append(angle[2] - 90)
    else:
      a_180s.append(angle[2] - 180)

  # With up to one atom missing, we must have 2 to 4 90 degree angles and 1 to 2
  # 180 degree angles
  if len(a_90s) < 2 or len(a_90s) > 4 or len(a_180s) < 1 or len(a_180s) > 2:
    return

  deviation = sqrt(sum(i ** 2 for i in a_90s + a_180s) / len(angles))

  if deviation <= dev_cutoff:
    return deviation, 4 - len(vectors)

def _is_square_pyramid(vectors, dev_cutoff=20):
  """
  Square bipyramids have five vertices, four on the same equatorial plane with
  one above. The expected angles are all either 90 degrees or 180 degrees.

  Parameters
  ----------
  vectors : list scitbx.matrix.col
  dev_cutoff : float, optional

  Returns
  -------
  bool
  """
  if len(vectors) != 5:
    return

  angles = _bond_angles(vectors)
  a_90s, a_180s = [], []

  for angle in angles:
    if abs(angle[2] - 90) < abs(angle[2] - 180):
      a_90s.append(angle[2] - 90)
    else:
      a_180s.append(angle[2] - 180)

  if len(a_90s) != 8 or len(a_180s) != 2:
    return

  deviation = sqrt(sum(i ** 2 for i in a_90s + a_180s) / len(angles))

  if deviation <= dev_cutoff:
    return deviation, 5 - len(vectors)

def _is_octahedron(vectors, dev_cutoff=20):
  """
  Octahedrons have six vertices (Their name comes from their eight faces).
  The expected angles are all either 90 degrees (Next to each other),
  or 180 degrees (Across from each other).

  Another name for this shape is square bipyramidal.

  Parameters
  ----------
  vectors : list scitbx.matrix.col
  dev_cutoff : float, optional

  Returns
  -------
  bool
  """
  if len(vectors) != 6:
    return

  angles = _bond_angles(vectors)
  a_90s, a_180s = [], []

  for angle in angles:
    if abs(angle[-1] - 90) < abs(angle[-1] - 180):
      a_90s.append(angle[-1] - 90)
    else:
      a_180s.append(angle[-1] - 180)

  if len(a_180s) > 3 or len(a_180s) < 2 or len(a_90s) < 8 or len(a_90s) > 12:
    return

  deviation = sqrt(sum(i ** 2 for i in a_90s + a_180s) / len(angles))

  if deviation <= dev_cutoff:
    return deviation, 6 - len(vectors)

def _is_trigonal_pyramid(vectors, dev_cutoff=15):
  """
  Trigional pyramids have four vertices. Three vertices form a plane with
  angles of 120 degrees between each pair. The last vertex resides axial
  to the plane, at 90 degrees from all of the equatorial vertices.

  Parameters
  ----------
  vectors : list scitbx.matrix.col
  dev_cutoff : float, optional

  Returns
  -------
  bool
  """
  if len(vectors) != 4:
    return

  angles = _bond_angles(vectors)
  a_90s, a_120s = [], []

  for angle in angles:
    if abs(angle[2] - 90) < abs(angle[2] - 120):
      a_90s.append(angle[2] - 90)
    else:
      a_120s.append(angle[2] - 120)

  if len(a_90s) < 2 or len(a_90s) > 4 or len(a_120s) < 2 or len(a_120s) > 4:
    return

  deviation = sqrt(sum(i ** 2 for i in a_90s + a_120s) / len(angles))

  if deviation <= dev_cutoff:
    return deviation, 4 - len(vectors)

def _is_trigonal_bipyramid(vectors, dev_cutoff=15):
  """
  Trigonal bipyramids have five vertices. Three vertices form a plane in the
  middle and the angles between all three are 120 degrees. The two other
  vertices reside axial to the plane, at 90 degrees from all the equatorial
  vertices.

  Parameters
  ----------
  vectors : list scitbx.matrix.col
  dev_cutoff : float, optional

  Returns
  -------
  bool
  """
  if len(vectors) > 5 or len(vectors) < 4:
    return

  angles = _bond_angles(vectors)

  # Grab the two axial vectors
  ax1, ax2, axial_angle = max(angles, key=lambda x: abs(x[-1]))

  if axial_angle < 150:
    # Missing one of the two axial vectors, just quit
    return

  base_to_axials = []
  equatorial_angles = []

  for v1, v2, angle in angles:
    # Python has no boolean xor!
    # Grab the angles between the two endpoints of the bipyramid and the base
    if (v1 in [ax1, ax2]) != (v2 in [ax1, ax2]):
      base_to_axials += angle,
    elif (v1 not in [ax1, ax2]) and (v2 not in [ax1, ax2]):
      equatorial_angles += angle,

  deviants = [axial_angle - 180]
  deviants += [i - 90 for i in base_to_axials]
  deviants += [i - 120 for i in equatorial_angles]
  deviation = sqrt(sum(i ** 2 for i in deviants) / len(deviants))

  if deviation <= dev_cutoff:
    return deviation, 5 - len(vectors)

def _is_pentagonal_bipyramid(vectors, dev_cutoff=15):
  """
  Pentagonal bipyramids have seven vertices. Five vertices form a plane in the
  middle and the angles between all five are 72 degrees. The two other vertices
  reside axial to the plane, at 90 degrees from all the equatorial vertices.

  Parameters
  ----------
  vectors : list scitbx.matrix.col
  dev_cutoff : float, optional

  Returns
  -------
  bool
  """
  if len(vectors) > 7 or len(vectors) < 6:
    return

  angles = _bond_angles(vectors)

  # Determine which two vectors define the axial angles
  axials = []
  for v1 in vectors:
    v_angles = []
    for v2 in vectors:
      if v2 != v1:
        v_angles.append(v1.angle(v2, deg=True))

    a_180s = len([i for i in v_angles if abs(i - 180) < 20])
    a_90s = len([i for i in v_angles if abs(i - 90) < 20])

    if a_180s > 0  and a_90s > 4:
      axials.append(v1)

  if len(axials) != 2:
    # Couldn't determine axial angles
    return

  ax1, ax2 = axials
  axial_angle = ax1.angle(ax2, deg=True)

  base_to_axials = []
  equatorial_angles = []

  for v1, v2, angle in angles:
    # Python has no boolean xor!
    # Grab the angles between the two endpoints of the bipyramid and the base
    if (v1 in [ax1, ax2]) != (v2 in [ax1, ax2]):
      base_to_axials += angle,
    elif (v1 not in [ax1, ax2]) and (v2 not in [ax1, ax2]):
      equatorial_angles += angle,

  deviants = [axial_angle - 180]
  deviants += [i - 90 for i in base_to_axials]
  deviants += [min(abs(i - 72), abs(i - 144)) for i in equatorial_angles]
  deviation = sqrt(sum(i ** 2 for i in deviants) / len(deviants))

  if deviation <= dev_cutoff:
    return deviation, 7 - len(vectors)

def _is_trigonal_prism(vectors, dev_cutoff=15):
  """
  Triangular prisms are defined by 3 vertices in a triangular pattern on two
  aligned planes. Unfortunately, the angles are dependent on the length and
  width of the prism. Need more examples to come up with a better way of
  detecting this shape.

  For now, this code is experimental.

  Parameters
  ----------
  vectors : list scitbx.matrix.col
  dev_cutoff : float, optional

  Returns
  -------
  bool
  """
  if len(vectors) != 6:
    return

  angles = _bond_angles(vectors)
  a_85s, a_135s = [], []

  for angle in angles:
    if abs(angle[-1] - 85) < abs(angle[-1] - 135):
      a_85s.append(angle[-1] - 85)
    else:
      a_135s.append(angle[-1] - 135)

  if len(a_85s) != 9 and len(a_135s) != 6:
    return

  deviation = sqrt(sum(i ** 2 for i in a_85s + a_135s) / len(angles))

  if deviation < dev_cutoff:
    return deviation, 6 - len(vectors)

SUPPORTED_GEOMETRIES_OLD = OrderedDict([
  ("tetrahedral", _is_tetrahedron),
  ("trigonal_planar", _is_trigonal_plane),
  ("square_planar", _is_square_plane),
  ("square_pyramidal", _is_square_pyramid),
  ("octahedral", _is_octahedron),
  ("trigonal_pyramidal", _is_trigonal_pyramid),
  ("trigonal_bipyramidal", _is_trigonal_bipyramid),
  ("pentagonal_bipyramidal", _is_pentagonal_bipyramid),
  ("trigonal_prism", _is_trigonal_prism),
  ])

def _concatenate(*args):
  """
  Reduces a list of a mixture of elements and lists down to a single list.

  Parameters
  ----------
  args : tuple of (object or list of object)

  Returns
  -------
  list
  """
  lst = []
  for arg in args:
    if isinstance(arg, list):
      for elem in arg:
        lst.append(elem)
    else:
      lst.append(arg)
  return lst

def _tetrahedron():
  """
  Returns
  -------
  list of scitbx.matrix.col
  """
  return [
    col([1, 1, 1]),
    col([-1, -1, 1]),
    col([-1, 1, -1]),
    col([1, -1, -1]),
    ]

def _octahedron():
  """
  Returns
  -------
  list of scitbx.matrix.col
  """
  return _bipyramid(_square_plane())

def _trigonal_plane():
  """
  Returns
  -------
  list of scitbx.matrix.col
  """
  return [
    col([0, 1, 0]),
    col([-sqrt(3) / 2, -1 / 2, 0]),
    col([sqrt(3) / 2, -1 / 2, 0]),
    ]

def _square_plane():
  """
  Returns
  -------
  list of scitbx.matrix.col
  """
  return [
    col([0, 1, 0]),
    col([0, -1, 0]),
    col([1, 0, 0]),
    col([-1, 0, 0]),
    ]

def _pyramid(base):
  """
  Returns
  -------
  list of scitbx.matrix.col
  """
  return _concatenate(base, col([0, 0, 1]))

def _bipyramid(base):
  """
  Returns
  -------
  list of scitbx.matrix.col
  """
  return _concatenate(base, col([0, 0, 1]), col([0, 0, -1]))

def _square_pyramid():
  """
  Returns
  -------
  list of scitbx.matrix.col
  """
  return _pyramid(_square_plane())

def _square_bipyramid():
  """
  Returns
  -------
  list of scitbx.matrix.col
  """
  return _bipyramid(_square_plane())

def _trigonal_pyramid():
  """
  Returns
  -------
  list of scitbx.matrix.col
  """
  return _pyramid(_trigonal_plane())

def _trigonal_bipyramid():
  """
  Returns
  -------
  list of scitbx.matrix.col
  """
  return _bipyramid(_trigonal_plane())

def _trigonal_prism():
  """
  Returns
  -------
  list of scitbx.matrix.col
  """
  return _concatenate(
    [i + col([0, 0, 1]) for i in _trigonal_plane()],
    [i + col([0, 0, -1]) for i in _trigonal_plane()],
    )

def _pentagon():
  """
  Create a list of vectors in the shape of a planar pentagon.

  Returns
  -------
  list of scitbx.matrix.col

  See Also
  --------
  http://mathworld.wolfram.com/Pentagon.html
  """
  c_1 = (sqrt(5) - 1) / 4
  c_2 = (sqrt(5) + 1) / 4
  s_1 = sqrt(10 + 2 * sqrt(5)) / 4
  s_2 = sqrt(10 - 2 * sqrt(5)) / 4

  return [
    col([1, 0, 0]),
    col([c_1, s_1, 0]),
    col([-c_2, s_2, 0]),
    col([-c_2, -s_2, 0]),
    col([c_1, -s_1, 0]),
    ]

def _pentagonal_pyramid():
  """
  Returns
  -------
  list of scitbx.matrix.col
  """
  return _pyramid(_pentagon())

def _pentagonal_bipyramid():
  """
  Creates a square bipyramid shape.

  Returns
  -------
  list of scitbx.matrix.col
  """
  return _bipyramid(_pentagon())

def _square_pyramid_bidentate_miss_1():
  """
  Creates a square pyramid shape with one vertex replaced with a bidentate
  coordination group. One vertex is missing in this shape.

  Returns
  -------
  list of scitbx.matrix.col
  """
  return _concatenate(
    _square_plane(),
    col([sqrt(2) / 2, sqrt(2) / 2, -1]),
    col([-sqrt(2) / 2, -sqrt(2) / 2, -1]),
    )

def _square_pyramid_bidentate_miss_2():
  """
  Creates a square pyramid shape with one vertex replaced with a bidentate
  coordination group. One vertex is missing in this shape.

  Returns
  -------
  list of scitbx.matrix.col
  """
  return [
    col([0, 1, 0]),
    col([0, -1, 0]),
    col([-1, 0, 0]),
    col([0, 0, 1]),
    col([sqrt(2) / 2, sqrt(2) / 2, -1]),
    col([-sqrt(2) / 2, -sqrt(2) / 2, -1]),
    ]

def _square_pyramid_bidentate_miss_3():
  """
  Creates a square pyramid shape with one vertex replaced with a bidentate
  coordination group. One vertex is missing in this shape.

  Returns
  -------
  list of scitbx.matrix.col
  """
  return [
    col([0, 1, 0]),
    col([0, -1, 0]),
    col([-1, 0, 0]),
    col([1, 0, 0]),
    col([sqrt(2) / 2, sqrt(2) / 2, -1]),
    col([-sqrt(2) / 2, -sqrt(2) / 2, -1]),
    ]

def _square_pyramid_bidentate():
  """
  Creates a square pyramid shape with one vertex replaced with a bidentate
  coordination group.

  Returns
  -------
  list of scitbx.matrix.col
  """
  return _concatenate(
    _square_pyramid(),
    col([sqrt(2) / 2, sqrt(2) / 2, -1]),
    col([-sqrt(2) / 2, -sqrt(2) / 2, -1])
    )

def _pentagonal_pyramid_bidentate():
  """
  Creates a pentagonal pyramid shape with one vertex replaced with a bidentate
  coordination group.

  Returns
  -------
  list of scitbx.matrix.col
  """
  return _concatenate(
    _pentagonal_pyramid(),
    col([sqrt(2) / 2, sqrt(2) / 2, -1]),
    col([-sqrt(2) / 2, -sqrt(2) / 2, -1]),
    )

def _pentagonal_bibidentate_miss_1():
  """
  A planar pentagon with bidentate atoms coordinating directly above and
  below. One vertex from the plane is missing in this shape.

  Returns
  -------
  list of scitbx.matrix.col
  """
  return _concatenate(
    col([sqrt(2) / 2, sqrt(2) / 2, 1]),
    col([-sqrt(2) / 2, -sqrt(2) / 2, 1]),
    col([sqrt(2) / 2, sqrt(2) / 2, -1]),
    col([-sqrt(2) / 2, -sqrt(2) / 2, -1]),
    *_pentagon()[:-1]
    )

def _pentagonal_bibidentate_miss_2():
  """
  A planar pentagon with bidentate atoms coordinating directly above and
  below. One vertex from the plane is missing in this shape.

  Returns
  -------
  list of scitbx.matrix.col
  """
  return _concatenate(
    col([sqrt(2) / 2, sqrt(2) / 2, 1]),
    col([-sqrt(2) / 2, -sqrt(2) / 2, 1]),
    col([sqrt(2) / 2, sqrt(2) / 2, -1]),
    col([-sqrt(2) / 2, -sqrt(2) / 2, -1]),
    *_pentagon()[1:]
    )

def _pentagonal_bibidentate_miss_3():
  """
  A planar pentagon with bidentate atoms coordinating directly above and
  below. One vertex from the plane is missing in this shape.

  Returns
  -------
  list of scitbx.matrix.col
  """
  pentagon = _pentagon()
  return _concatenate(
    col([sqrt(2) / 2, sqrt(2) / 2, 1]),
    col([-sqrt(2) / 2, -sqrt(2) / 2, 1]),
    col([sqrt(2) / 2, sqrt(2) / 2, -1]),
    col([-sqrt(2) / 2, -sqrt(2) / 2, -1]),
    pentagon[0],
    pentagon[1],
    pentagon[3],
    pentagon[4],
    )

def _pentagonal_bibidentate_miss_4():
  """
  A planar pentagon with bidentate atoms coordinating directly above and
  below. One vertex from a bidentate coordinator is missing in this shape.

  Returns
  -------
  list of scitbx.matrix.col
  """
  return _concatenate(
    _pentagon(),
    col([sqrt(2) / 2, sqrt(2) / 2, 1]),
    col([-sqrt(2) / 2, -sqrt(2) / 2, 1]),
    col([-sqrt(2) / 2, -sqrt(2) / 2, -1]),
    )

def _pentagonal_bibidentate_miss_5():
  """
  A planar pentagon with bidentate atoms coordinating directly above and
  below. One vertex from a bidentate coordinator is missing in this shape.

  Returns
  -------
  list of scitbx.matrix.col
  """
  return _concatenate(
    _pentagon(),
    col([sqrt(2) / 2, sqrt(2) / 2, 1]),
    col([-sqrt(2) / 2, -sqrt(2) / 2, 1]),
    col([sqrt(2) / 2, sqrt(2) / 2, -1]),
    )

def _pentagonal_bibidentate():
  """
  A planar pentagon with bidentate atoms coordinating directly above and below.

  Returns
  -------
  list of scitbx.matrix.col
  """
  return _concatenate(
    _pentagon(),
    col([sqrt(2) / 2, sqrt(2) / 2, 1]),
    col([-sqrt(2) / 2, -sqrt(2) / 2, 1]),
    col([sqrt(2) / 2, sqrt(2) / 2, -1]),
    col([-sqrt(2) / 2, -sqrt(2) / 2, -1]),
    )

def _see_saw():
  """
  An octahedron missing two adjacent points.

  Returns
  -------
  list of scitbx.matrix.col
  """
  return [
    col([1, 0, 0]),
    col([-1, 0, 0]),
    col([0, 1, 0]),
    col([0, 0, 1]),
    ]

def _three_legs():
  """
  Better name? Imagine 3 orthogonal vectors pointed in the x, y, and z
  directions.

  Returns
  -------
  list of scitbx.matrix.col
  """
  return [
    col([1, 0, 0]),
    col([0, 1, 0]),
    col([0, 0, 1]),
    ]

SUPPORTED_GEOMETRIES = OrderedDict([
  (3, [
    ("three_legs", _three_legs, 15),
    ("trigonal_plane", _trigonal_plane, 15),
    ]),
  (4, [
    ("tetrahedron", _tetrahedron, 15),
    ("square_plane", _square_plane, 20),
    ("trigonal_pyramid", _trigonal_pyramid, 15),
    ("see_saw", _see_saw, 15),
    ]),
  (5, [
    ("square_pyramid", _square_pyramid, 15),
    ("trigonal_bipyramid", _trigonal_bipyramid, 15),
    ("pentagon", _pentagon, 15)
    ]),
  (6, [
    ("octahedron", _octahedron, 15),
    ("trigonal_prism", _trigonal_prism, 15),
    ("pentagonal_pyramid", _pentagonal_pyramid, 15),
    ("square_pyramid_bidentate_miss", [_square_pyramid_bidentate_miss_1,
                                       _square_pyramid_bidentate_miss_2,
                                       _square_pyramid_bidentate_miss_3], 15),
    ]),
  (7, [
    ("pentagonal_bipyramid", _pentagonal_bipyramid, 15),
    ("square_pyramid_bidentate", _square_pyramid_bidentate, 15),
    ]),
  (8, [
    ("pentagonal_pyramid_bidentate", _pentagonal_pyramid_bidentate, 15),
    ("pentagonal_bibidentate_miss", [_pentagonal_bibidentate_miss_1,
                                     _pentagonal_bibidentate_miss_2,
                                     _pentagonal_bibidentate_miss_3], 15),
  ]),
  (9, [
    ("pentagonal_bibidentate", _pentagonal_bibidentate, 15),
  ]),
  ])

SUPPORTED_GEOMETRY_NAMES = \
  [lst_i[0] for vals in SUPPORTED_GEOMETRIES.values() for lst_i in vals]

def _angles_deviation(vectors_a, vectors_b):
  """
  Calculates the root mean square of the angle deviation (in degrees) between
  two lists of vectors.

  Parameters
  ----------
  vectors_a : list of scitbx.matrix.col
  vectors_b : list of scitbx.matrix.col

  Returns
  -------
  float
  """
  assert len(vectors_a) == len(vectors_b)

  angles_a = [vec.angle(vec_o, deg=True)
              for index, vec in enumerate(vectors_a)
              for vec_o in vectors_a[index + 1:]]

  angles_b = [vec.angle(vec_o, deg=True)
              for index, vec in enumerate(vectors_b)
              for vec_o in vectors_b[index + 1:]]

  angles_a.sort()
  angles_b.sort()

  angle_deviation = sqrt(sum((i - j) ** 2 for i, j in zip(angles_a, angles_b))
                   / len(angles_a))

  return angle_deviation

def find_coordination_geometry(nearby_atoms, minimizer_method=False,
                               cutoff=2.9):
  """
  Searches through a list of geometries to find those that fit nearby_atom.

  Geometries are recognized by generating a list of all combinations of angles
  between the vectors and comparing them against the angles among the vectors
  of the ideal geometry.

  Parameters
  ----------
  nearby_atoms: list of mmtbx.ions.environment.atom_contact
      A list of atom contacts, indicating the vertices of the shape to be
      recognized.
  minimizer_method: bool, optional
      Optional parameter to use the new, more efficient version of geometry
      recognition. The old method will be depreciated in later versions of
      cctbx.
  cutoff: float, optional
      A cutoff distance, past which vectors are not included in geometry
      calculations.

  Returns
  -------
  list of tuples of str, float
      A list of found geometries. Each tuple contains the name of the geometry
      in string form followed by the deviation from ideal angles.

  See Also
  --------
  mmtbx.ions.geometry.SUPPORTED_GEOMETRY_NAMES,
  mmtbx.ions.geometry.SUPPORTED_GEOMETRIES_OLD
  """

  # Filter out overlapping atoms, we just want an idea of the coordinating
  # geometry, even if it is two different atoms are occupying the same spot.
  non_overlapping = []
  for index, contact in enumerate(nearby_atoms):
    if all(contact.distance_from(other) > 0.5
           for other in nearby_atoms[index + 1:]):
      non_overlapping.append(contact)

  # Filter out contacts > cutoff away
  filtered = []
  for contact in non_overlapping:
    if contact.distance() < cutoff:
      filtered.append(contact.vector)

  geometries = []
  if minimizer_method:
    n_vectors = len(filtered)

    if n_vectors not in SUPPORTED_GEOMETRIES:
      return geometries

    for name, func, rmsa_cutoff in SUPPORTED_GEOMETRIES[n_vectors]:
      if isinstance(func, Iterable):
        rmsa = min(_angles_deviation(filtered, i()) for i in func)
      else:
        rmsa = _angles_deviation(filtered, func())

      if rmsa < rmsa_cutoff:
        geometries.append((name, rmsa))

    if geometries:
      geometries.sort(key=lambda x: x[-1])
      geometries = [geometries[0]]
  else:
    for name, func in SUPPORTED_GEOMETRIES_OLD.items():
      val = func(filtered)
      if val:
        deviation = val[0]
        geometries.append((name, deviation))

  return geometries


 *******************************************************************************


 *******************************************************************************
mmtbx/ions/halides.py

"""
Functions specific to identifying halide ions.  Very preliminary - needs
much more sophisticated analysis.
"""

from __future__ import absolute_import, division, print_function
from mmtbx.ions import server
from scitbx.matrix import col, distance_from_plane
from libtbx import Auto

chloride_params_str = """
max_distance_to_amide_n = 3.5
  .type = float
  .input_size = 80
  .help = Max distance to amide N atom
max_distance_to_cation = 3.5
  .type = float
  .input_size = 80
min_distance_to_anion = 3.5
  .type = float
  .input_size = 80
min_distance_to_other_sites = 2.1
  .type = float
  .input_size = 80
max_distance_to_hydroxyl = 3.5
  .type = float
delta_amide_h_angle = 20
  .type = float
  .input_size = 80
  .help = Allowed deviation (in degrees) from ideal N-H-X angle
delta_planar_angle = 10
  .type = float
  .input_size = 80
max_deviation_from_plane = 0.8
  .type = float
"""

def is_negatively_charged_oxygen(atom_name, resname):
  """
  Determine whether the oxygen atom of interest is either negatively charged
  (usually a carboxyl group or sulfate/phosphate), or has a lone pair (and
  no hydrogen atom) that would similarly repel anions.

  Parameters
  -----------
  atom_name : str
  resname : str

  Returns
  -------
  bool
  """
  if ((atom_name in ["OD1","OD2","OE1","OE2"]) and
      (resname in ["GLU","ASP","GLN","ASN"])):
    return True
  elif ((atom_name == "O") and (not resname in ["HOH","WAT"])):
    return True # sort of - the lone pair acts this way
  elif ((len(atom_name) == 3) and (atom_name[0:2] in ["O1","O2","O3"]) and
        (atom_name[2] in ["A","B","G"])):
    return True
  elif (resname in ["SO4","PO4"]):
    return True
  return False

# XXX distance cutoff may be too generous, but 0.5 is too strict
def _is_coplanar_with_sidechain(atom, residue, distance_cutoff=0.75):
  """
  Given an isolated atom and an interacting residue with one or more amine
  groups, determine whether the atom is approximately coplanar with the terminus
  of the sidechain (and thus interacting with the amine hydrogen(s) along
  approximately the same axis as the N-H bond).

  Parameters
  ----------
  atom : iotbx.pdb.hierarchy.atom
  residue : iotbx.pdb.hierarchy.residue
  distance_cutoff : float, optional

  Returns
  -------
  bool
  """
  sidechain_sites = []
  resname = residue.resname
  for other in residue.atoms():
    name = other.name.strip()
    if (resname == "ARG") and (name in ["NH1","NH2","NE"]):
      sidechain_sites.append(other.xyz)
    elif (resname == "GLN") and (name in ["OE1","NE2","CD"]):
      sidechain_sites.append(other.xyz)
    elif (resname == "ASN") and (name in ["OD1","ND2","CG"]):
      sidechain_sites.append(other.xyz)
  if (len(sidechain_sites) != 3) : # XXX probably shouldn't happen
    return False
  D = distance_from_plane(atom.xyz, sidechain_sites)
  #print atom.id_str(), D
  return (D <= distance_cutoff)

def is_favorable_halide_environment(
    i_seq,
    contacts,
    pdb_atoms,
    sites_frac,
    connectivity,
    unit_cell,
    params,
    assume_hydrogens_all_missing=Auto):
  """
  Detects if an atom's site exists in a favorable environment for a halide
  ion. This includes coordinating by a positively charged sidechain or backbone
  as well as an absense of negatively charged coordinating groups.

  Parameters
  ----------
  i_seq : int
  contacts : list of mmtbx.ions.environment.atom_contact
  pdb_atoms : iotbx.pdb.hierarchy.af_shared_atom
  sites_frac : tuple of float, float, float
  connectivity : scitbx.array_family.shared.stl_set_unsigned
  unit_cell : uctbx.unit_cell
  params : libtbx.phil.scope_extract
  assume_hydrogens_all_missing : bool, optional

  Returns
  -------
  bool
  """
  if (assume_hydrogens_all_missing in [None, Auto]):
    elements = pdb_atoms.extract_element()
    assume_hydrogens_all_missing = not ("H" in elements or "D" in elements)
  atom = pdb_atoms[i_seq]
  binds_amide_hydrogen = False
  near_cation = False
  near_lys = False
  near_hydroxyl = False
  xyz = col(atom.xyz)
  min_distance_to_cation = max(unit_cell.parameters()[0:3])
  min_distance_to_hydroxyl = min_distance_to_cation
  for contact in contacts :
    # to analyze local geometry, we use the target site mapped to be in the
    # same ASU as the interacting site
    def get_site(k_seq):
      return unit_cell.orthogonalize(
        site_frac = (contact.rt_mx * sites_frac[k_seq]))
    other = contact.atom
    resname = contact.resname()
    atom_name = contact.atom_name()
    element = contact.element
    distance = abs(contact)
    j_seq = other.i_seq
    # XXX need to figure out exactly what this should be - CL has a
    # fairly large radius though (1.67A according to ener_lib.cif)
    if (distance < params.min_distance_to_other_sites):
      return False
    if not element in ["C", "N", "H", "O", "S"]:
      charge = server.get_charge(element)
      if charge < 0 and distance <= params.min_distance_to_anion:
        # Nearby anion that is too close
        return False
      if charge > 0 and distance <= params.max_distance_to_cation:
        # Nearby cation
        near_cation = True
        if (distance < min_distance_to_cation):
          min_distance_to_cation = distance
    # Lysine sidechains (can't determine planarity)
    elif (atom_name in ["NZ"] and #, "NE", "NH1", "NH2"] and
          resname in ["LYS"] and
          distance <= params.max_distance_to_cation):
      near_lys = True
      if (distance < min_distance_to_cation):
        min_distance_to_cation = distance
    # sidechain amide groups, no hydrogens (except Arg)
    # XXX this would be more reliable if we also calculate the expected
    # hydrogen positions and use the vector method below
    elif (atom_name in ["NZ","NH1","NH2","ND2","NE2"] and
          resname in ["ARG","ASN","GLN"] and
          (assume_hydrogens_all_missing or resname == "ARG") and
          distance <= params.max_distance_to_cation):
      if (_is_coplanar_with_sidechain(atom, other.parent(),
            distance_cutoff = params.max_deviation_from_plane)):
        binds_amide_hydrogen = True
        if (resname == "ARG") and (distance < min_distance_to_cation):
          min_distance_to_cation = distance
    # hydroxyl groups - note that the orientation of the hydrogen is usually
    # arbitrary and we can't determine precise bonding
    elif ((atom_name in ["OG1", "OG2", "OH1"]) and
          (resname in ["SER", "THR", "TYR"]) and
          (distance <= params.max_distance_to_hydroxyl)):
      near_hydroxyl = True
      if (distance < min_distance_to_hydroxyl):
        min_distance_to_hydroxyl = distance
    # Backbone amide, explicit H
    elif atom_name in ["H"]:
      # TODO make this more general for any amide H?
      xyz_h = col(contact.site_cart)
      bonded_atoms = connectivity[j_seq]
      if (len(bonded_atoms) != 1):
        continue
      xyz_n = col(get_site(bonded_atoms[0]))
      vec_hn = xyz_h - xyz_n
      vec_hx = xyz_h - xyz
      angle = abs(vec_hn.angle(vec_hx, deg = True))
      # If Cl, H, and N line up, Cl binds the amide group
      if abs(angle - 180) <= params.delta_amide_h_angle:
        binds_amide_hydrogen = True
      else :
        pass #print "%s N-H-X angle: %s" % (atom.id_str(), angle)
    # Backbone amide, implicit H
    elif atom_name in ["N"] and assume_hydrogens_all_missing:
      xyz_n = col(contact.site_cart)
      bonded_atoms = connectivity[j_seq]
      ca_same = c_prev = None
      for k_seq in bonded_atoms :
        other2 = pdb_atoms[k_seq]
        if other2.name.strip().upper() in ["CA"]:
          ca_same = col(get_site(k_seq))
        elif other2.name.strip().upper() in ["C"]:
          c_prev = col(get_site(k_seq))
      if ca_same is not None and c_prev is not None:
        xyz_cca = (ca_same + c_prev) / 2
        vec_ncca = xyz_n - xyz_cca
        # 0.86 is the backbone N-H bond distance in geostd
        xyz_h = xyz_n + (vec_ncca.normalize() * 0.86)
        vec_nh = xyz_n - xyz_h
        vec_nx = xyz_n - xyz
        angle = abs(vec_nh.angle(vec_nx, deg = True))
        if abs(angle - 180) <= params.delta_amide_h_angle:
          binds_amide_hydrogen = True
    # sidechain NH2 groups, explicit H
    elif ((atom_name in ["HD1","HD2"] and resname in ["ASN"]) or
          (atom_name in ["HE1","HE2"] and resname in ["GLN"])):
          # XXX not doing this for Arg because it can't handle the bidentate
          # coordination
          #(atom_name in ["HH11","HH12","HH21","HH22"] and resname == "ARG")):
      bonded_atoms = connectivity[j_seq]
      assert (len(bonded_atoms) == 1)
      xyz_n = col(get_site(bonded_atoms[0]))
      xyz_h = col(contact.site_cart)
      vec_nh = xyz_n - xyz_h
      vec_xh = xyz - xyz_h
      angle = abs(vec_nh.angle(vec_xh, deg = True))
      if abs(angle - 180) <= params.delta_amide_h_angle:
        binds_amide_hydrogen = True
      else :
        pass #print "%s amide angle: %s" % (atom.id_str(), angle)
  # now check again for negatively charged sidechain (etc.) atoms (e.g.
  # carboxyl groups), but with some leeway if a cation is also nearby.
  # backbone carbonyl atoms are also excluded.
  for contact in contacts :
    if (contact.altloc() not in ["", "A"]):
      continue
    resname = contact.resname()
    atom_name = contact.atom_name()
    distance = abs(contact)
    if ((distance < 3.2) and
        (distance < (min_distance_to_cation + 0.2)) and
        is_negatively_charged_oxygen(atom_name, resname)):
      #print contact.id_str(), distance
      return False
  return (binds_amide_hydrogen or near_cation or near_lys)


 *******************************************************************************


 *******************************************************************************
mmtbx/ions/identify.py
# -*- coding: utf-8; py-indent-offset: 2 -*-
"""
Examines a structure for metal ions. Can iterate over all atoms, examining
their density and chemical environment to determine if they are correctly
identified, or if there are better candidate ions that they can be replaced
with.

See mmtbx.ions.build to actually modify the structure, the code in this module
handles ion identification, but only prints out messages to a log.
"""

from __future__ import absolute_import, division, print_function
from mmtbx.ions.geometry import find_coordination_geometry
from mmtbx.ions import environment
from mmtbx.ions import halides
from mmtbx.ions import utils
from mmtbx import validation
import mmtbx.ions
from iotbx.pdb import common_residue_names_water as WATER_RES_NAMES
from cctbx.eltbx import sasaki, henke
from cctbx import crystal, adptbx
from scitbx.array_family import flex
from scitbx.matrix import col
from libtbx.str_utils import make_sub_header, format_value, framed_output
from libtbx import group_args, adopt_init_args, Auto
from libtbx.utils import null_out, Sorry
from libtbx import easy_mp
import libtbx.load_env
import libtbx.phil
from math import sqrt
from six.moves import cStringIO as StringIO
import operator
import time
import sys
from libtbx.math_utils import cmp
from six.moves import zip
from six.moves import range
from six import string_types

ion_identification_phil_str = """
require_valence = False
  .type = bool
  .help = Toggles the use of valence calculations
  .short_caption = Require good bond valence
ambiguous_valence_cutoff = 0.5
  .type = float
  .help = "Cutoff to uniquely select one of many metals by comparing its observed and expected valence"
d_min_strict_valence = 1.5
  .type = float
  .short_caption = Resolution limit for strict valence rules
anom_map_type = *residual simple llg
  .type = choice
  .help = Type of anomalous difference map to use.  Default is a residual \
    map, showing only unmodeled scattering.
find_anomalous_substructure = Auto
  .type = bool
use_phaser = True
  .type = bool
  .help = Toggles the use of Phaser for calculation of f-prime values.
  .short_caption = Use Phaser to calculate f-double-prime
aggressive = False
  .type = bool
  .help = Toggles more permissive settings for flagging waters as heavier \
    elements.  Not recommended for automated use.
map_sampling_radius = 2.0
  .type = float
  .input_size = 80
  .short_caption = Sampling radius
water
  .short_caption = Water filtering
  .style = box auto_align
{
  min_2fofc_level = 1.8
    .type = float
    .input_size = 80
    .help = Minimum water 2mFo-DFc map value.  Waters below this cutoff will \
      not be analyzed further.
    .short_caption = Min. allowed 2mFo-DFc map value
  max_fofc_level = 3.0
    .type = float
    .input_size = 80
    .help = Maximum water mFo-DFc map value
    .short_caption = Max. expected mFo-DFc map value
  max_anom_level = 3.0
    .type = float
    .input_size = 80
    .help = Maximum water anomalous map value
    .short_caption = Max. expected anomalous map value
  max_occ = 1.0
    .type = float
    .input_size = 80
    .help = Maximum water occupancy
    .short_caption = Max. expected occupancy
  min_b_iso = 1.0
    .type = float
    .input_size = 80
    .help = Minimum water isotropic B-factor
    .short_caption = Min. expected B-factor
  fp_max = 1.0
    .type = float
  fpp_max = 0
    .type = float
  max_stddev_b_iso = 5
    .type = float
    .input_size = 80
    .short_caption = Max. standard deviations below mean B-iso
  min_frac_b_iso = 0.2
    .type = float
    .input_size = 80
    .short_caption = Min. fraction of mean B-iso
  min_frac_calpha_b_iso = 0.75
    .type = float
  max_frac_calpha_2fofc = 1.2
    .type = float
  min_2fofc_coordinating = 0.9
    .type = float
    .help = Minimum 2mFo-DFc for waters involved in coordination shells.
}
phaser
  .short_caption = Phaser options
  .caption = These parameters control the identification of anomalous \
    scatterers using Phaser substructure completion.
  .style = box auto_align
{
  llgc_ncycles = None
    .type = int
    .short_caption = Number of cycles
  distance_cutoff = 1.5
    .type = float
    .input_size = 80
    .short_caption = Min. required separation from other atoms
  distance_cutoff_same_site = 0.7
    .type = float
    .input_size = 80
    .short_caption = Max. separation from mapped atom
  fpp_ratio_min = 0.2
    .type = float
    .input_size = 80
    .help = Minimum ratio of refined/theoretical f-double-prime.
    .short_caption = Min. f-double-prime ratio
  fpp_ratio_max = 1.1
    .type = float
    .input_size = 80
    .help = Maximum ratio of refined/theoretical f-double-prime.
    .short_caption = Max. f-double-prime ratio
}
chloride
  .short_caption = Chloride ions
  .style = box auto_align
{
  %s
}
""" % halides.chloride_params_str

def ion_master_phil():
  return libtbx.phil.parse(ion_identification_phil_str, process_includes=True)

# various constants
WATER, WATER_POOR, LIGHT_ION, HEAVY_ION = range(4)
NUC_PHOSPHATE_BINDING = ["MG", "CA", "MN"]

class manager(object):
  """
  Wrapper object for extracting local environment and adding or modifying
  scatterers.
  """

  def __init__(self,
                fmodel,
                pdb_hierarchy,
                xray_structure,
                params = None,
                wavelength = None,
                connectivity = None,
                nproc = 1,
                verbose = False,
                log = None):
    if (log is None) : log = null_out()
    self.fmodel = fmodel
    self.atoms_to_props = {}
    self.params = params
    self.wavelength = wavelength
    self.nproc = nproc
    self.phaser_substructure = None
    self.flag_refine_substructure = False
    self.fpp_from_phaser_ax_sites = None
    self.site_fp = None
    self.site_fdp = None
    self.use_svm = getattr(params, "use_svm", None)
    self._map_values = {}
    self._map_gaussian_fits = {}
    self.anomalous_flag = None
    if (fmodel is not None):
      self.anomalous_flag = fmodel.f_obs().anomalous_flag()
    self.update_structure(
      pdb_hierarchy = pdb_hierarchy,
      xray_structure = xray_structure,
      connectivity = connectivity,
      log = log)
    self.update_maps()
    # The default behavior is to refine the anomalous structure when possible;
    # this can use either the CCTBX anomalous group refinement or Phaser's
    # substructure completion (but not both).  Some additional machinery is
    # required to handle this distinction.
    refine_substructure = False
    if (params is not None):
      refine_substructure = params.find_anomalous_substructure
    if (refine_substructure is Auto):
      refine_substructure = fmodel.f_obs().anomalous_flag() and \
                            (wavelength is not None)
    if (refine_substructure):
      if (wavelength is None):
        raise Sorry("Wavelength required when "+
                    "find_anomalous_substructure=True.")
      elif (not fmodel.f_obs().anomalous_flag()):
        raise Sorry("Anomalous data required when "+
                    "find_anomalous_substructure=True.")
      if ((params.use_phaser) and (libtbx.env.has_module("phaser"))):
        print("  Running Phaser substructure completion...", file=log)
        t1 = time.time()
        phaser_result = find_anomalous_scatterers(
          fmodel = fmodel,
          pdb_hierarchy = pdb_hierarchy,
          wavelength = wavelength,
          verbose = verbose,
          log = log,
          n_cycles = params.phaser.llgc_ncycles)
        t2 = time.time()
        print("    time: %.1fs" % (t2-t1), file=log)
        if (phaser_result is None):
          print("  ERROR: Phaser substructure completion failed!", file=log)
        else :
          self.phaser_substructure = phaser_result.atoms()
          if (len(self.phaser_substructure) == 0):
            print("  No anomalous scatterers found!", file=log)
          else :
            print("  %d anomalous scatterers found" % \
              len(self.phaser_substructure), file=log)
            self.analyze_substructure(log = log, verbose = True)
      else :
        self.flag_refine_substructure = True
        self.refine_anomalous_substructure(log = log)

  def water_selection(self):
    """
    Fetchs the selection for all waters in the model.

    Returns
    -------
    scitbx.array_family.flex.size_t
    """
    sel_cache = self.pdb_hierarchy.atom_selection_cache()
    sel_str = "({}) and element O and altloc ' '".format(
      " or ".join([ "resname " + i for i in WATER_RES_NAMES ]))
    return sel_cache.selection(sel_str).iselection()

  def refine_anomalous_substructure(self, log):
    """
    Run simple "substructure completion" implemented using CCTBX tools (the
    command-line equivalent is mmtbx.refine_anomalous_substructure).  A faster
    alternative to Phaser, but not clear how effective this is at the moment.

    Parameters
    ----------
    log : file
    """
    from mmtbx.refinement import anomalous_scatterer_groups
    fmodel_tmp = self.fmodel.deep_copy()
    # XXX should we only be refining f''?
    anom_groups = anomalous_scatterer_groups.refine_anomalous_substructure(
      fmodel = fmodel_tmp,
      pdb_hierarchy = self.pdb_hierarchy,
      wavelength = self.wavelength,
      reset_water_u_iso = True,
      verbose = True,
      use_all_anomalous = True,
      out = log)
    scatterers = fmodel_tmp.xray_structure.scatterers()
    self.use_fdp = flex.bool(scatterers.size(), False)
    self.site_fp = flex.double(scatterers.size(), 0)
    self.site_fdp = flex.double(scatterers.size(), 0)
    for group in anom_groups :
      for i_seq in group.iselection :
        sc = scatterers[i_seq]
        self.use_fdp[i_seq] = True
        self.site_fp[i_seq] = sc.fp
        self.site_fdp[i_seq] = sc.fdp

  def update_structure(self, pdb_hierarchy, xray_structure,
      connectivity = None, log = None, refine_if_necessary = True):
    """
    Set the current atomic data: PDB hierarchy, Xray structure, and simple
    connectivity list.

    Parameters
    ----------
    pdb_hierarchy : iotbx.pdb.hierarchy.root
    xray_structure : cctbx.xray.structure.structure
    connectivity : ...
    log : file, optional
    refine_if_necessary : bool, optional
    """
    self.pdb_hierarchy = pdb_hierarchy
    self.xray_structure = xray_structure
    if self.fmodel:
      self.fmodel.update_xray_structure(xray_structure, update_f_calc = True)
    self.sites_frac = self.xray_structure.sites_frac()
    self.sites_cart = self.xray_structure.sites_cart()
    self.connectivity = connectivity
    self.pdb_atoms = pdb_hierarchy.atoms()
    assert not self.pdb_atoms.extract_i_seq().all_eq(0)
    self.unit_cell = xray_structure.unit_cell()
    self.use_fdp = flex.bool(xray_structure.scatterers().size(), False)
    self.ax_chain = None
    self._pair_asu_cache = {}
    self.u_iso_all = xray_structure.extract_u_iso_or_u_equiv()
    # Extract some information about the structure, including B-factor
    # statistics for non-HD atoms and waters
    sctr_keys = xray_structure.scattering_type_registry().type_count_dict()
    self.hd_present = ("H" in sctr_keys) or ("D" in sctr_keys)
    sel_cache = pdb_hierarchy.atom_selection_cache()
    self.carbon_sel = sel_cache.selection("element C").iselection()
    self.calpha_sel = sel_cache.selection("name CA and element C").iselection()
    assert (len(self.carbon_sel) > 0)
    water_sel = self.water_selection()
    self.n_waters = len(water_sel)
    not_hd_sel = sel_cache.selection("not (element H or element D)").iselection()
    self.n_heavy = len(not_hd_sel)
    u_iso_all_tmp = self.u_iso_all.select(not_hd_sel)
    self.b_mean_all = adptbx.u_as_b(flex.mean(u_iso_all_tmp))
    self.b_stddev_all = adptbx.u_as_b(
       u_iso_all_tmp.standard_deviation_of_the_sample())
    self.b_mean_calpha = 0
    if (len(self.calpha_sel) > 0):
      self.b_mean_calpha = adptbx.u_as_b(flex.mean(self.u_iso_all.select(
        self.calpha_sel)))
    self.b_mean_hoh = self.b_stddev_hoh = None
    if (self.n_waters > 0):
      u_iso_hoh = self.u_iso_all.select(water_sel)
      self.b_mean_hoh = adptbx.u_as_b(flex.mean(u_iso_hoh))
      self.b_stddev_hoh = adptbx.u_as_b(
        u_iso_hoh.standard_deviation_of_the_sample())
    if (self.phaser_substructure is not None):
      self.analyze_substructure(log = log)
    elif (self.flag_refine_substructure) and (refine_if_necessary):
      self.refine_anomalous_substructure(log = log)

  def get_initial_b_iso(self):
    """
    Calculates the isotropic b-factor to assign to newly labeled ions during the
    building process. Uses either the mean b-factor of waters or of all atoms if
    the former is unavailable.

    Returns
    -------
    float
    """
    if (getattr(self, "b_mean_hoh", None) is not None):
      return self.b_mean_hoh
    else :
      return self.b_mean_all

  def get_map(self, map_type):
    """
    Creates the real-space version of a given map type.

    Parameters
    ----------
    map_type : str

    Returns
    -------
    scitbx.array_family.flex.double
    """
    map_coeffs = self.fmodel.map_coefficients(
      map_type = map_type,
      exclude_free_r_reflections = True,
      fill_missing = True,
      pdb_hierarchy = self.pdb_hierarchy)
    if (map_coeffs is None):
      return None
    return map_coeffs.fft_map(resolution_factor = 0.25,
      ).apply_sigma_scaling().real_map_unpadded()

  def update_maps(self):
    """
    Generate new maps for the current structure, including anomalous map if
    data are anomalous.

    If Phaser is installed and anomalous data are available, the anomalous
    log-likelihood gradient (LLG) map can be used instead of the conventional
    anomalous difference map. This is only really useful if the anomalous
    scattering of existing atoms is modeled (and ideally, refined).
    """
    if self.fmodel is None:
      return
    def fft_map(map_coeffs, resolution_factor = 0.25):
      return map_coeffs.fft_map(resolution_factor = resolution_factor,
        ).apply_sigma_scaling().real_map_unpadded()
    map_types = ["2mFo-DFc", "mFo-DFc"]
    map_keys = ["2mFo-DFc", "mFo-DFc"]
    if (self.fmodel.f_obs().anomalous_flag()):
      if (self.params.anom_map_type == "phaser"):
        map_types.append("llg")
      elif (self.params.anom_map_type == "residual"):
        map_types.append("anom_residual")
      else :
        map_types.append("anom")
      map_keys.append("anom")
    if (self.use_svm):
      map_types.append("mFo")
      map_keys.append("mFo")
    # To save memory, we sample atomic positions immediately and throw out
    # the actual maps (instead of keeping up to 3 in memory)
    sites_frac = self.xray_structure.sites_frac()
    sites_cart = self.xray_structure.sites_cart()
    self._principal_axes_of_inertia = [ None ] * len(sites_frac)
    self._map_variances = [ None ] * len(sites_frac)
    self._map_gaussian_fits = {}
    self.calpha_mean_two_fofc = 0
    for map_type, map_key in zip(map_types, map_keys):
      real_map = self.get_map(map_type)
      if (real_map is not None):
        # Gather values for map peaks at each site
        self._map_values[map_key] = flex.double(sites_frac.size(), 0)
        self._map_gaussian_fits[map_key] = [ None ] * len(sites_frac)
        for i_seq, site_frac in enumerate(sites_frac):
          atom = self.pdb_atoms[i_seq]
          resname = atom.fetch_labels().resname.strip().upper()
          if (resname in WATER_RES_NAMES + mmtbx.ions.SUPPORTED or
              atom.segid.strip().upper() in ["ION"]):
            value = real_map.eight_point_interpolation(site_frac)
            self._map_values[map_key][i_seq] = value
            if (self.use_svm):
              gaussian_fit = utils.fit_gaussian(
                unit_cell=self.unit_cell,
                site_cart=atom.xyz,
                real_map=real_map)
              self._map_gaussian_fits[map_key][i_seq] = gaussian_fit

        if map_type in ["2mFo-DFc"]:
          # Gather values on map variance and principal axes of interia
          from cctbx import maptbx
          for i_seq, site_cart in enumerate(sites_cart):
            resname = self.pdb_atoms[i_seq].fetch_labels().resname.strip()
            if resname in WATER_RES_NAMES + mmtbx.ions.SUPPORTED:
              # XXX not totally confident about how I'm weighting this...
              p_a_i = maptbx.principal_axes_of_inertia(
                real_map = real_map,
                site_cart = site_cart,
                unit_cell = self.unit_cell,
                radius = self.params.map_sampling_radius)
              self._principal_axes_of_inertia[i_seq] = p_a_i
              variance = maptbx.spherical_variance_around_point(
                real_map = real_map,
                unit_cell = self.unit_cell,
                site_cart = site_cart,
                radius = self.params.map_sampling_radius)
              self._map_variances[i_seq] = variance
            elif (i_seq in self.calpha_sel):
              # Also collect some info in average C_alpha 2FoFc peak heights
              self.calpha_mean_two_fofc += real_map.eight_point_interpolation(
                sites_frac[i_seq])
        del real_map

    if (self.calpha_mean_two_fofc > 0):
      n_calpha = len(self.calpha_sel)
      assert (n_calpha > 0)
      self.calpha_mean_two_fofc /= n_calpha

    # Gather info on carbons' average Fo peak height for use in estimating other
    # sites' atomic weight
    self.carbon_fo_values = None
    if (len(self.carbon_sel) > 0):
      self.carbon_fo_values = flex.double()
      self._map_values["mFo"] = flex.double(sites_frac.size(), 0)
      fo_map = fft_map(self.fmodel.map_coefficients(
        map_type = "mFo",
        exclude_free_r_reflections = True,
        fill_missing = True))

      for i_seq, site_frac in enumerate(sites_frac):
        resname = self.pdb_atoms[i_seq].fetch_labels().resname.strip()
        element = self.pdb_atoms[i_seq].element.strip()
        if (element == "C") or ((element == "O") and (resname in WATER_RES_NAMES)):
          map_value = fo_map.eight_point_interpolation(site_frac)
          self._map_values["mFo"][i_seq] = map_value
          if (element == "C"):
            self.carbon_fo_values.append(map_value)
      del fo_map

  def show_current_scattering_statistics(self, out=sys.stdout):
    """
    Prints out information about an entire model's scattering statistics, such
    as mean map heights and b-factors for carbons and waters.

    Parameters
    ----------
    out : file, optional
    """
    print("", file=out)
    print("Model and map statistics:", file=out)
    print("  mean mFo map height @ carbon: %s" % format_value("%.2f",
      flex.max(self.carbon_fo_values)), file=out)
    if (self.calpha_mean_two_fofc > 0):
      print("  mean 2mFo-DFc map height @ C-alpha: %s" % format_value(
        "%.2f", self.calpha_mean_two_fofc), file=out)
    print("  mean B-factor: %s" % format_value("%.2f", self.b_mean_all), file=out)
    if (self.b_mean_calpha > 0):
      print("  mean C-alpha B-factor: %s" % format_value("%.2f",
        self.b_mean_calpha), file=out)
    print("  mean water B-factor: %s" % format_value("%.2f",
      self.b_mean_hoh), file=out)
    n_water_fofc_peaks = 0
    n_water_anom_peaks = 0
    water_sel = self.water_selection()
    print("  %d water molecules" % len(water_sel), file=out)
    for i_seq in water_sel :
      map_stats = self.map_stats(i_seq)
      if (map_stats.fofc >= 3.0):
        n_water_fofc_peaks += 1
      if (map_stats.anom is not None) and (map_stats.anom >= 3.0):
        n_water_anom_peaks += 1
    print("  %d waters have mFo-DFc map >= 3.0 sigma" % \
      n_water_fofc_peaks, file=out)
    if (self.anomalous_flag):
      print("  %d waters have anomalous map >= 3.0 sigma" % \
        n_water_anom_peaks, file=out)
    print("", file=out)

  def get_strict_valence_flag(self):
    """
    Checks whether the resolution of a model is high enough to use more strict
    thresholds for ion valences.

    Returns
    -------
    bool
    """
    d_min = self.fmodel.f_obs().d_min()
    return (d_min < self.params.d_min_strict_valence)

  def find_nearby_atoms(self, i_seq, far_distance_cutoff = 3.0,
      near_distance_cutoff = 1.5, filter_by_bonding = True,
      filter_by_two_fofc = True):
    """
    Given site in the structure, return a list of contacts, optionally
    filtering by connectivity and 2mFo-DFc map level.

    Parameters
    ----------
    i_seq : int
    far_distance_cutoff : float, optional
    near_distance_cutoff : float, optional
    filter_by_bonding : bool, optional
    fitler_by_two_fofc : bool, optional

    Returns
    -------
    list of mmtbx.ions.environment.atom_contact
    """
    assert (i_seq < len(self.sites_frac))
    # Use pair_asu_table to find atoms within distance_cutoff of one another,
    # taking into account potential cell symmetry.
    # XXX should probably move this up, but it seems relatively fast
    pair_asu_table, asu_mappings, asu_table = self._pair_asu_cache.get(
      far_distance_cutoff, (None,None,None))
    if (pair_asu_table is None):
      pair_asu_table = self.xray_structure.pair_asu_table(
        distance_cutoff = far_distance_cutoff)
      asu_mappings = pair_asu_table.asu_mappings()
      asu_table = pair_asu_table.table()
      self._pair_asu_cache[far_distance_cutoff] = (pair_asu_table, asu_mappings,
        asu_table)
    contacts = environment.find_nearby_atoms(
      i_seq=i_seq,
      xray_structure=self.xray_structure,
      pdb_atoms=self.pdb_atoms,
      asu_mappings=asu_mappings,
      asu_table=asu_table,
      connectivity=self.connectivity,
      far_distance_cutoff=far_distance_cutoff,
      near_distance_cutoff=near_distance_cutoff,
      filter_by_bonding=filter_by_bonding)
    # Discard waters in poor density
    if (filter_by_two_fofc):
      filtered = []
      for contact in contacts :
        if (contact.resname() in WATER_RES_NAMES):
          two_fofc = self._map_values["2mFo-DFc"][contact.atom_i_seq()]
          if two_fofc < self.params.water.min_2fofc_coordinating:
            continue
        filtered.append(contact)
      contacts = filtered
    return contacts

  def guess_b_iso_real(self, i_seq):
    """
    Guess an approximate B_iso for an atom by averaging the values for
    coordinating atoms.  This should partially compensate for the deflation of
    the B-factor due to incorrect scattering type, and consequently make the
    occupancy refinement more accurate.

    Parameters
    ----------
    i_seq : int

    Returns
    -------
    float
    """
    contacts = self.find_nearby_atoms(i_seq, far_distance_cutoff = 3.0)
    if (len(contacts) == 0):
      return adptbx.u_as_b(self.u_iso_all[i_seq])
    u_iso_sum = 0
    for contact in contacts :
      u_iso_sum += self.u_iso_all[contact.atom_i_seq()]
    return adptbx.u_as_b(u_iso_sum / len(contacts))

  def principal_axes_of_inertia(self, i_seq):
    """
    Extracts the map grid points around a site, and calculates the axes of
    inertia (using the density values as weights). This is used to calculate
    the sphericity of the blob of density around a site.

    Parameters
    ----------
    i_seq : int

    Returns
    -------
    ...
    """
    return self._principal_axes_of_inertia[i_seq]

  def get_map_sphere_variance(self, i_seq):
    """
    Calculate the density levels for points on a sphere around a given point.
    This will give us some indication whether the density falls off in the
    expected manner around a single atom.

    Parameters
    ----------
    i_seq : int

    Returns
    -------
    float
    """
    return self._map_variances[i_seq]

  def get_b_iso(self, i_seq):
    """
    Calculates the isotropic b-factor of a site.

    Parameters
    ----------
    i_seq : int

    Returns
    -------
    float
    """
    sc = self.xray_structure.scatterers()[i_seq]
    return adptbx.u_as_b(sc.u_iso_or_equiv(self.unit_cell))

  def map_stats(self, i_seq):
    """
    Given a site in the structure, find the signal of the 2FoFc, FoFc, and
    anomalous map (When available).

    Parameters
    ----------
    i_seq : int

    Returns
    -------
    group_args
        Object with .two_fofc, .fofc, and .anom properties for the associated
        signals in each map.
    """
    value_2fofc = self._map_values["2mFo-DFc"][i_seq]
    value_fofc = self._map_values["mFo-DFc"][i_seq]
    value_anom = None
    if ("anom" in self._map_values):
      value_anom = self._map_values["anom"][i_seq]
    return group_args(
      two_fofc = value_2fofc,
      fofc = value_fofc,
      anom = value_anom)

  def get_map_gaussian_fit(self, map_type, i_seq):
    """
    Retrieves the two parameters of a gaussian function, fit to a given map at
    a site.

    Parameters
    ----------
    map_type : str
    i_seq : int

    Returns
    -------
    (tuple of float, float) or None
    """
    map_gaussians = self._map_gaussian_fits.get(map_type, None)
    if (map_gaussians is not None):
      return map_gaussians[i_seq]
    return None

  def guess_molecular_weight(self, i_seq):
    """
    Guesses the molecular weight of a site by scaling the signal from
    the mFo map by the average signal from carbon atoms.

    Parameters
    ----------
    i_seq : int

    Returns
    -------
    float
    """
    map_values = self._map_values.get("mFo", None)
    if (map_values is None) : return None
    height = map_values[i_seq]
    mean_carbon = flex.mean(self.carbon_fo_values)
    assert (mean_carbon > 0)
    return 6 * height / mean_carbon

  def _find_atoms_near_site(self,
      site_cart,
      distance_cutoff = 1.5,
      distance_cutoff_same_site = 0.5):
    """
    Given an XYZ coordinate, finds atoms near that site, separating out those
    which are close enough to be essentially equivalent.  Used to analyze the
    anomalously-scattering substructure calculated by Phaser.

    Parameters
    ----------
    site_cart : tuple of float, float, float
    distance_cutoff : float, optional
    distance_cutoff_same_site : float, optional

    Returns
    -------
    same_atoms : list of group_args
        List of atoms within distance_cutoff_same_site of site_cart, and and
        other_atoms, the rest of the atoms within distance_cutoff of site_cart.
    """
    site_frac = self.unit_cell.fractionalize(site_cart = site_cart)
    sites_frac = flex.vec3_double([site_frac])
    asu_mappings = self.xray_structure.asu_mappings(buffer_thickness =
      distance_cutoff + 0.1)
    asu_mappings.process_sites_frac(sites_frac,
      min_distance_sym_equiv = self.xray_structure.min_distance_sym_equiv())
    pair_generator = crystal.neighbors_fast_pair_generator(
      asu_mappings = asu_mappings,
      distance_cutoff = distance_cutoff)
    n_xray = self.xray_structure.scatterers().size()
    same_atoms = []
    other_atoms = []
    # Iterate through all interacting pairs of atoms in the structure
    # within distance_cutoff of each other
    for pair in pair_generator:
      # Find a pair where one's sequence ID is < n_xray and the other's
      # is >= n_xray and gather the site information about it
      if (pair.i_seq < n_xray and pair.j_seq < n_xray) or \
        (pair.i_seq >= n_xray and pair.j_seq >= n_xray):
        continue
      rt_mx_i = asu_mappings.get_rt_mx_i(pair)
      rt_mx_j = asu_mappings.get_rt_mx_j(pair)
      rt_mx_ji = rt_mx_i.inverse().multiply(rt_mx_j)
      new_site_frac = rt_mx_ji * site_frac
      new_site_cart = self.unit_cell.orthogonalize(site_frac = new_site_frac)
      atom_seq = pair.i_seq if pair.i_seq < n_xray else pair.j_seq
      site_info = group_args(
        i_seq = atom_seq,
        rt_mx = rt_mx_ji,
        new_site_cart = new_site_cart,
        distance = sqrt(pair.dist_sq))
      if site_info.distance < distance_cutoff_same_site:
        same_atoms.append(site_info)
      else:
        other_atoms.append(site_info)
    same_atoms.sort(key = lambda x: x.distance)
    other_atoms.sort(key = lambda x: x.distance)
    return same_atoms, other_atoms

  def analyze_substructure(self, log = None, verbose = True):
    """
    Given a list of AX pseudo-atoms placed by Phaser, finds the nearest real
    atoms, and if possible determines their equivalence.

    Parameters
    ----------
    log : file, optional
    verbose : bool, optional
    """
    def ax_atom_id(atom):
      """
      Parameters
      ----------
      atom : iotbx.pdb.hierarchy.atom

      Returns
      -------
      str
      """
      return "AX %s (fpp=%.3f)" % (atom.serial.strip(), atom.occ)

    assert (self.phaser_substructure is not None)
    self.fpp_from_phaser_ax_sites = flex.double(self.pdb_atoms.size(), -1)
    if (log is None) or (not verbose) : log = null_out()

    def _filter_site_infos(site_infos):
      """
      Parameters
      ----------
      site_infos : list of group_args

      Returns
      -------
      list of group_args
      """
      # Organize a dictionary, keyed with each site's atom i_seq
      from collections import OrderedDict
      i_seqs = OrderedDict()
      for site_info in site_infos:
        if site_info.i_seq in i_seqs:
          i_seqs[site_info.i_seq].append(site_info)
        else:
          i_seqs[site_info.i_seq] = [site_info]
      # If we are picking from multiple of the same i_seq, select the closest
      for val in i_seqs.values():
        # Prefer unit operators
        if any(i.rt_mx.is_unit_mx() for i in val):
          for site_info in val:
            if not site_info.rt_mx.is_unit_mx():
              val.remove(site_info)
        val.sort(key = lambda x: x.distance)
      return [i[0] for i in i_seqs.values()]

    make_sub_header("Analyzing Phaser anomalous substructure", out = log)
    for atom in self.phaser_substructure :
      print(ax_atom_id(atom), file=log)
      same_atoms, other_atoms = self._find_atoms_near_site(
        atom.xyz,
        distance_cutoff=self.params.phaser.distance_cutoff,
        distance_cutoff_same_site=self.params.phaser.distance_cutoff_same_site)

      same_atoms, other_atoms = \
        _filter_site_infos(same_atoms), _filter_site_infos(other_atoms)

      if len(same_atoms) == 0:
        print("  No match for %s" % ax_atom_id(atom), file=log)
        for other_atom in other_atoms:
          print("    %s (distance = %.3f)" % \
                (self.pdb_atoms[other_atom.i_seq].id_str(), other_atom.distance), file=log)
      elif len(same_atoms) == 1:
        print("  %s maps to %s" % \
          (ax_atom_id(atom), self.pdb_atoms[same_atoms[0].i_seq].id_str()), file=log)
        self.use_fdp[same_atoms[0].i_seq] = True
        self.fpp_from_phaser_ax_sites[same_atoms[0].i_seq] = atom.occ
      else :
        print("  ambiguous results for %s:" % ax_atom_id(atom), file=log)
        for same_atom in same_atoms:
          print("    %s" % self.pdb_atoms[same_atom.i_seq].id_str(), file=log)
    print("", file=log)

  def get_fpp(self, i_seq):
    """
    Retrieve the refined f'' for a site.  Because this can come from either the
    built-in anomalous refinement or Phaser, it is handled differently than
    the f' retrieval.

    Parameters
    ----------
    i_seq : int

    Returns
    -------
    float or None
    """
    if (not self.use_fdp[i_seq]):
      return None
    if (self.fpp_from_phaser_ax_sites is None):
      return self.site_fdp[i_seq]
    fpp = self.fpp_from_phaser_ax_sites[i_seq]
    if (fpp < 0) : fpp = None
    return fpp

  def get_fp(self, i_seq):
    """
    Retrieve the refined f' for a site.

    Parameters
    ----------
    i_seq : int

    Returns
    -------
    float or None
    """
    if (self.site_fp is None) or (not self.use_fdp[i_seq]):
      return None
    return self.site_fp[i_seq]

  def looks_like_halide_ion(self,
      i_seq,
      element = "CL",
      assume_hydrogens_all_missing = Auto):
    """
    Given a site, analyze the nearby atoms (taking geometry into account) to
    guess whether it might be a halide ion.  Among other things, halides will
    often be coordinated by amide hydrogens, and not in close contact with
    negatively charged atoms.  Note that this procedure has a very high
    false positive rate when used by itself, so additional information about
    the electron count (map, occ, b) is absolutely essential.

    Parameters
    ----------
    i_seq : int
    element : str
    assume_hydrogens_all_missing : bool, optional

    Returns
    -------
    bool
    """
    atom = self.pdb_atoms[i_seq]
    sites_frac = self.xray_structure.sites_frac()
    assert element.upper() in mmtbx.ions.HALIDES
    # discard atoms with B-factors greater than mean-1sigma for waters
    if ((self.b_mean_hoh is not None) and
        (atom.b > self.b_mean_hoh - self.b_stddev_hoh)):
      return False
    nearby_atoms = self.find_nearby_atoms(
      i_seq,
      far_distance_cutoff = 4.0,
      filter_by_bonding = False)
    favorable_environment = halides.is_favorable_halide_environment(
      i_seq=i_seq,
      contacts=nearby_atoms,
      pdb_atoms=self.pdb_atoms,
      sites_frac=self.xray_structure.sites_frac(),
      unit_cell=self.unit_cell,
      connectivity=self.connectivity,
      params = self.params.chloride,
      assume_hydrogens_all_missing=assume_hydrogens_all_missing)
    # TODO something smart...
    # the idea here is to determine whether the blob of density around the
    # site is approximately spherical and limited in extent.
    pai = self.principal_axes_of_inertia(i_seq)
    map_variance = self.get_map_sphere_variance(i_seq)
    good_map_falloff = False
    if ((map_variance is not None) and
        (map_variance.mean < 1.5) and
        (map_variance.standard_deviation < 0.4)) : # XXX very arbitrary
      good_map_falloff = True
    # XXX probably need something more sophisticated here too.  a CL which
    # coordinates a metal (e.g. in 4aqi) may not have a clear blob, but
    # will still be detectable by other criteria.
    return favorable_environment

  def analyze_water(self,
      i_seq,
      debug = True,
      candidates = Auto,
      no_final = False,
      out = sys.stdout):
    """
    Examines the environment around a single atom to determine if it is actually
    a misidentified metal ion.

    no_final is used internally, when candidates is not Auto, to try all of the
    Auto without selecting any as a final choice when none of the elements in
    candidates appear to probable ion identities.

    Parameters
    ----------
    i_seq : int
    debug : bool, optional
    candidates : list of str, optional
    no_file : bool, optional
    out : file, optional

    Returns
    -------
    mmtbx.ions.identify.water_result
    """

    atom = self.pdb_atoms[i_seq]
    # Keep track of this in case we find nothing from the user-specific candidates
    auto_candidates = candidates is Auto
    if auto_candidates:
      candidates = mmtbx.ions.DEFAULT_IONS
    elif isinstance(candidates, string_types):
      candidates = candidates.replace(",", " ").split()
    candidates = [i.strip().upper() for i in candidates]
    if (candidates == ['X']) : # XXX hack for testing - X is "dummy" element
      candidates = []

    resname = atom.fetch_labels().resname.strip().upper()
    assert resname in WATER_RES_NAMES

    atom_props = self.atoms_to_props[i_seq]
    final_choice = None

    # Gather some quick statistics on the atom and see if it looks like water
    atom_type = atom_props.get_atom_type(params=self.params.water,
      aggressive=self.params.aggressive)
    if (atom_type == WATER_POOR) : # not trustworthy, skip
      #_PRINT_DEBUG("SKIPPING %s" % atom.id_str())
      return None

    # XXX everything SVM-related happens in mmtbx.ions.svm, using a subclass of
    # this one
    assert (not self.use_svm)

    # Filter out metals based on whether they are more or less eletron-dense
    # in comparison with water
    filtered_candidates = []
    halide_candidates = False
    nuc_phosphate_site = atom_props.looks_like_nucleotide_phosphate_site()
    max_carbon_fo_map_value = sys.maxsize
    if (self.carbon_fo_values is not None):
      max_carbon_fo_map_value = flex.max(self.carbon_fo_values)

    for symbol in candidates :
      elem = mmtbx.ions.server.get_metal_parameters(symbol)
      if (elem is None):
        if (symbol in mmtbx.ions.HALIDES) : # halides are special!
          halide_candidates = True
          continue
        else :
          raise Sorry("Element '%s' not supported!" % symbol)

      # If we definitely look like water or a light ion, only look at the
      # metals isoelectronic with water.
      if ((atom_type in [WATER, LIGHT_ION]) and
          (symbol not in ["NA", "MG", "F", "NE"])):
        continue

      if (nuc_phosphate_site) and (not symbol in NUC_PHOSPHATE_BINDING):
        continue

      n_elec = sasaki.table(symbol.upper()).atomic_number() - elem.charge
      # lighter elements are not expected to have any anomalous signal
      if (n_elec <= 12) and (atom_props.fpp is not None and atom_props.fpp > 0.1):
        continue
      mass_ratio = atom_props.estimated_weight / max(n_elec, 1)
      # note that anomalous peaks are more important than the 2mFo-DFc level
      if (mass_ratio < 0.4) and (atom_type == WATER):
        continue

      filtered_candidates.append(elem)

    # if len(filtered_candidates) == 0 and not halide_candidates:
    #   return None

    # Try each different ion and see what is reasonable
    def try_candidates(require_valence = True):
      """
      Parameters
      ----------
      require_valence : bool, optional

      Returns
      -------
      list of tuple of mmtbx.ions.metal_parameters, float
      list of tuple of mmtbx.ions.metal_parameters, float
      """
      reasonable = []
      unreasonable = []
      for elem_params in filtered_candidates:
        # Try the ion with check_ion_environment()
        atom_props.check_ion_environment(
          ion_params = elem_params,
          wavelength = self.wavelength,
          require_valence = require_valence)
        atom_props.check_fpp_ratio(
          ion_params = elem_params,
          wavelength = self.wavelength,
          fpp_ratio_min = self.params.phaser.fpp_ratio_min,
          fpp_ratio_max = self.params.phaser.fpp_ratio_max)
        identity = str(elem_params)
        if atom_props.is_correctly_identified(identity = identity):
          reasonable.append((elem_params, atom_props.score[identity]))
        else :
          unreasonable.append((elem_params, atom_props.score[identity]))
      return reasonable, unreasonable

    # first try with bond valence included in criteria - then if that doesn't
    # yield any hits, try again without valences
    reasonable, unreasonable = try_candidates(require_valence = True)
    valence_used = True
    if (len(reasonable) == 0) and (not self.params.require_valence):
      reasonable, unreasonable = try_candidates(require_valence = False)
      if (len(reasonable) > 0):
        valence_used = False

    looks_like_halide = False
    if (not (reasonable or atom_type < HEAVY_ION or nuc_phosphate_site)):
      # try halides now
      candidate_halides = set(candidates).intersection(mmtbx.ions.HALIDES)
      filtered_halides = []
      for element in candidate_halides :
        fpp_ratio = atom_props.check_fpp_ratio(
          ion_params = mmtbx.ions.metal_parameters(element = element,
            charge = -1),
          wavelength = self.wavelength,
          fpp_ratio_min = self.params.phaser.fpp_ratio_min,
          fpp_ratio_max = self.params.phaser.fpp_ratio_max)
        # XXX chlorides are tricky, because they tend to be partial occupancy
        # anyway and the f'' is already small, so prone to error here
        if (fpp_ratio is not None) and (element != "CL"):
          if ((fpp_ratio < self.params.phaser.fpp_ratio_min) or
              (fpp_ratio > self.params.phaser.fpp_ratio_max)):
            #print "fpp_ratio:", fpp_ratio
            continue
        if (self.looks_like_halide_ion(i_seq = i_seq, element = element)):
          filtered_halides.append(element)

      looks_like_halide = (len(filtered_halides) > 0)
      reasonable += [(mmtbx.ions.metal_parameters(element = halide,
                      charge = -1), 0) for halide in filtered_halides]

    # If we can't find anything reasonable, relax our constraints...
    # Look for something that is a compatible ligand, an apparent fpp,
    # and compatible geometries
    if (len(reasonable) == 0) and (not self.params.require_valence):
      compatible = [params for params in filtered_candidates
                    if atom_props.has_compatible_ligands(str(params))]
      for ion_params in compatible :
        atomic_number = sasaki.table(ion_params.element).atomic_number()
        weight_ratio = 0
        if (atom_props.estimated_weight is not None):
          weight_ratio = atom_props.estimated_weight / (atomic_number - \
            ion_params.charge)
        # special handling for transition metals, but only if the user has
        # explicitly requested one (and there is no ambiguity)
        if ((ion_params.element in mmtbx.ions.TRANSITION_METALS) and
            (atom_type == HEAVY_ION) and
            #(atom_props.peak_2fofc > max_carbon_fo_map_value) and
            (not auto_candidates) and
            (atom_props.is_compatible_site(ion_params))):
          n_good_res = atom_props.number_of_favored_ligand_residues(ion_params,
            distance = 2.7)
          n_total_coord_atoms = atom_props.number_of_atoms_within_radius(2.8)
          # if we see at least one favorable residue coordinating the atom
          # and no more than six atoms total, accept the current guess
          if ((n_good_res >= 1) and (2 <= n_total_coord_atoms <= 6)):
            reasonable.append((ion_params, 0))
          else : pass
            #print "n_good_res = %d, n_total_coord_atoms = %d" % (n_good_res,
            #  n_total_coord_atoms)
        elif ((ion_params.element in ["K","CA"]) and
              (atom_type == HEAVY_ION) and
              (not auto_candidates) and
              (atom_props.is_compatible_site(ion_params))):
          n_good_res = atom_props.number_of_favored_ligand_residues(ion_params,
            distance = 2.9, exclude_atoms = ["O"])
          n_bb_oxygen = atom_props.number_of_backbone_oxygens(
            distance_cutoff = 2.9)
          n_total_coord_atoms = atom_props.number_of_atoms_within_radius(
            distance_cutoff = 2.9)
          if ((n_good_res + n_bb_oxygen) >= 2) and (n_total_coord_atoms >= 4):
            reasonable.append((ion_params, 0))
        # another special case: very heavy ions, which are probably not binding
        # physiologically
        elif ((atomic_number > 30) and (atom_type == HEAVY_ION) and
              (((weight_ratio > 0.5) and (weight_ratio < 1.05)) or
               (atom_props.fp > 10)) and
              (not auto_candidates) and
              (atom_props.is_compatible_site(ion_params,
                ignore_valence=not self.get_strict_valence_flag()))):
          n_total_coord_atoms = atom_props.number_of_atoms_within_radius(2.8)
          if (n_total_coord_atoms >= 3):
            reasonable.append((ion_params, 0))
        else : pass
          #print atom.id_str(), atomic_number, looks_like_water, weight_ratio, \
          #  atom_props.is_compatible_site(ion_params)
      if (len(compatible) == 1) and (not self.get_strict_valence_flag()):
        inaccuracies = atom_props.inaccuracies[str(ion_params)]
        if (compatible[0] in atom_props.fpp_ratios and
            atom_props.BAD_FPP not in inaccuracies and
            not inaccuracies.intersection([atom_props.BAD_GEOMETRY,
                                           atom_props.NO_GEOMETRY])):
          _PRINT_DEBUG(atom.id_str())
          _PRINT_DEBUG(filtered_candidates)
          _PRINT_DEBUG(compatible)

    if (len(reasonable) == 1):
      final_choice = reasonable[0][0]

    if (not reasonable) and (not auto_candidates):
      # Couldn't find anything from what the user suggested, try the other
      # default candidates and just let the user know about them
      result = self.analyze_water(
        i_seq = i_seq,
        debug = debug,
        no_final = True,
        out = out)
      if (result.final_choice is not None):
        return result
    return water_result(
      atom_props = atom_props,
      filtered_candidates = filtered_candidates,
      matching_candidates = reasonable,
      rejected_candidates = unreasonable,
      nuc_phosphate_site = nuc_phosphate_site,
      atom_type = atom_type,
      looks_like_halide = looks_like_halide,
      ambiguous_valence_cutoff = self.params.ambiguous_valence_cutoff,
      valence_used = valence_used,
      final_choice = final_choice,
      wavelength = self.wavelength,
      no_final = no_final)

  def _extract_waters(self):
    model = self.pdb_hierarchy.only_model()
    water_i_seqs = []
    for chain in model.chains():
      for residue_group in chain.residue_groups():
        atom_groups  = residue_group.atom_groups()
        if (len(atom_groups) > 1):
          continue
        for atom_group in atom_groups :
          resname = atom_group.resname.strip().upper()
          if (resname in WATER_RES_NAMES):
            atoms = atom_group.atoms()
            if (len(atoms) == 1) : # otherwise it probably has hydrogens, skip
              water_i_seqs.append(atoms[0].i_seq)
    return water_i_seqs

  def analyze_waters(self, out = sys.stdout, debug = True, candidates = Auto):
    """
    Iterates through all of the waters in a model, examining the maps and local
    environment to check their identity and suggest likely ions where
    appropriate.

    Parameters
    ----------
    out : file, otpional
    debug : bool, optional
    candidates : list of str, optional

    Returns
    -------
    list of tuple of int, mmtbx.ions.metal_parameters
        i_seq and metal parameters which indicate that waters of i_seq would be
        better changed to that new metal identity.
    """
    waters = self.water_selection()
    print("", file=out)
    print("  %d waters to analyze" % len(waters), file=out)
    if (len(waters) == 0) : return
    nproc = easy_mp.get_processes(self.nproc)
    ions = []
    self.atoms_to_props = dict((i_seq, AtomProperties(i_seq, self))
                               for i_seq in waters)
    if (nproc == 1):
      print("", file=out)
      for water_i_seq in waters :
        t1 = time.time()
        water_props = self.analyze_water(
          i_seq = water_i_seq,
          debug = debug,
          candidates = candidates,
          out = out)
        if (water_props is not None):
          water_props.show_summary(out = out, debug = debug)
          map_stats = self.map_stats(water_i_seq)
          if ((water_props.final_choice is not None) and
              (not water_props.no_final)):
            ions.append((water_i_seq, [water_props.final_choice],
              map_stats.two_fofc))
        t2 = time.time()
        #print "%s: %.3fs" % (self.pdb_atoms[water_i_seq].id_str(), t2-t1)
    else :
      print("  Parallelizing across %d processes" % nproc, file=out)
      print("", file=out)
      analyze_water = _analyze_water_wrapper(manager = self,
        debug = debug,
        candidates = candidates,
        out = out)
      results = easy_mp.pool_map(
        fixed_func = analyze_water,
        args = waters,
        processes = nproc)
      for result in results :
        if (result is None):
          continue
        water_i_seq, final_choice, result_str = result
        if (result_str is not None):
          print(result_str, file=out)
        if final_choice is not None :
          map_stats = self.map_stats(water_i_seq)
          ions.append((water_i_seq, [final_choice], map_stats.two_fofc))

    return sorted(ions, key=operator.itemgetter(2), reverse=True)

  def validate_ion(self, i_seq, out = sys.stdout, debug = True):
    """
    Examines one site in the model and determines if it was correctly modelled,
    returning a boolean indicating correctness.

    Parameters
    ----------
    i_seq : int
    out : file, optional
    debug : bool, optional
    """

    atom_props = self.atoms_to_props[i_seq]
    element = mmtbx.ions.server.get_element(atom_props.atom)
    elem_params = mmtbx.ions.server.get_metal_parameters(element)

    if elem_params is not None:
      atom_type = atom_props.get_atom_type(params=self.params.water)
      atom_props.check_ion_environment(
        ion_params = elem_params,
        wavelength = self.wavelength,
        require_valence = self.params.require_valence)
      atom_props.check_fpp_ratio(
        ion_params = elem_params,
        wavelength = self.wavelength,
        fpp_ratio_min = self.params.phaser.fpp_ratio_min,
        fpp_ratio_max = self.params.phaser.fpp_ratio_max)
    elif element in mmtbx.ions.HALIDES:
      identity = atom_props.identity()
      atom_props.inaccuracies[identity] = set()

      if not self.looks_like_halide_ion(i_seq = i_seq, element = element):
        atom_props.inaccuracies[identity].add(atom_props.BAD_HALIDE)
    else:
      raise Sorry("Element '%s' not supported:\n%s" %
                  (element, atom_props.atom.format_atom_record()))

    return atom_props

  def validate_ions(self, out = sys.stdout, debug = True, segid = None):
    """
    Iterate over all the ions built into the model by this module and double
    check their correctness. Looks for tell-tale signs such as negative peaks
    in the mFo-DFc and anomalous difference maps, abnormal b-factor, and
    disallowed chemical environments.

    Prints out a table of bad ions and their information and returns a list of
    their sites' i_seqs.

    Parameters
    ----------
    out : file, optional
    debug : bool, optional
    segid : str, optional
        If present, only validate ions with this segid.
    """

    if segid is None:
      ions = []
      for model in self.pdb_hierarchy.models():
        for chain in model.chains():
          for residue_group in chain.residue_groups():
            for atom_group in residue_group.atom_groups():
              if atom_group.resname.strip() in mmtbx.ions.SUPPORTED:
                atoms = atom_group.atoms()
                assert (len(atoms) == 1)
                for atom in atoms:
                  ions += atom.i_seq,
    else:
      sel_cache = self.pdb_hierarchy.atom_selection_cache()
      ions = sel_cache.selection("segid {0}".format(segid)).iselection()

    if len(ions) == 0:
      return
    ion_status = []

    self.atoms_to_props = dict((i_seq, AtomProperties(i_seq, self))
                               for i_seq in ions)
    for i_seq in ions:
      atom_props = self.validate_ion(
        i_seq = i_seq,
        debug = debug)
      ion_status.append((atom_props, atom_props.is_correctly_identified()))
    scatterers = self.xray_structure.scatterers()
    headers = ("atom", "occ", "b_iso", "2mFo-DFc", "mFo-DFc", "fp", "fdp",
               "ratio", "BVS", "VECSUM")
    fmt = "%-15s %-5s  %-5s  %-8s  %-7s  %-5s  %-5s  %-5s %-5s  %-6s"
    box = framed_output(out, title = "Validating new ions", width = 80)
    print(fmt % headers, file=box)
    print(" " + ("-" * 75), file=box)
    for props, okay_flag in ion_status :
      i_seq = props.atom.i_seq
      sc = scatterers[i_seq]
      fp = fdp = None
      if (sc.flags.use_fp_fdp):
        fp = sc.fp
        fdp = sc.fdp
      # XXX props.atom.b does not work here!
      b_iso = adptbx.u_as_b(sc.u_iso_or_equiv(unit_cell = self.unit_cell))
      identity = props.identity()
      def ff(fs, val) : return format_value(fs, val, replace_none_with = "---")
      print(fmt % (props.atom.id_str(suppress_segid = True)[5:-1],
        ff("%.2f", props.atom.occ), ff("%.2f", b_iso),
        ff("%.2f", props.peak_2fofc), ff("%.2f", props.peak_fofc),
        ff("%.2f", fp), ff("%.2f", fdp),
        ff("%.2f", None if self.wavelength is None else fdp / sasaki.table(
            mmtbx.ions.server.get_element(props.atom)).at_angstrom(self.wavelength).fdp()),
        ff("%.2f", props.valence_sum.get(identity)),
        ff("%.2f", props.vector_sum.get(identity))), file=box)
      # print >> box, props.geometries
      if not okay_flag:
        print("\n".join("!!! " + props.error_strs[i]
                                for i in props.inaccuracies[identity]), file=box)
      print("", file=box)
    box.close()

class _analyze_water_wrapper(object):
  """
  Simple wrapper for calling manager.analyze_water with keyword arguments
  in a parallelized loop.  Because the water_result object is not pickle-able,
  we only return the final ion choice and summary string.
  """
  def __init__(self, manager, **kwds):
    self.manager = manager
    self.kwds = dict(kwds)

  def __call__(self, i_seq):
    try:
      result = self.manager.analyze_water(i_seq, **(self.kwds))
      out = StringIO()
      if (result is not None):
        result.show_summary(out = out,
          debug = self.kwds.get("debug", False))
      result_str = out.getvalue()
      if (result_str == "") : result_str = None
      final_choice = None
      # only accept final choice if it's in the original list of elements
      if (not getattr(result, "no_final", False)):
        final_choice = getattr(result, "final_choice", None)
        #_PRINT_DEBUG("final_choice = %s" % final_choice)
      return i_seq, final_choice, result_str
    except KeyboardInterrupt :
      return (None, None, None)

class _validate_ion_wrapper(object):
  """
  Simple wrapper for calling manager.validate_ion with keyword arguments
  in a parallelized loop.  Because the water_result object is not pickle-able,
  we only return the final ion choice and summary string.
  """
  def __init__(self, manager, **kwds):
    self.manager = manager
    self.kwds = dict(kwds)

  def __call__(self, i_seq):
    try:
      correct = self.manager.validate_ion(i_seq, **(self.kwds))
      return i_seq, correct
    except KeyboardInterrupt :
      return (None, None)

class ion_result(validation.atom):
  """
  Class for validation results for an ion site. This includes information about
  both the atom modeled at that site as well as its chemical and scattering
  environment.
  """
  __slots__ = validation.atom.__slots__ + ["chem_env", "scatter_env"]

  def show(self, out = sys.stdout, prefix = ""):
    pass

  def show_brief(self, out = sys.stdout, prefix = ""):
    # Print brief statistics for lines in a table
    pass

class water_result(object):
  """
  Container for storing the results of manager.analyze_water for later display
  and retrieval.
  """
  def __init__(self,
      atom_props,
      filtered_candidates,
      matching_candidates,
      rejected_candidates,
      nuc_phosphate_site,
      atom_type,
      looks_like_halide,
      ambiguous_valence_cutoff,
      valence_used,
      final_choice,
      wavelength=None,
      no_final = False):
    adopt_init_args(self, locals())

  def show_summary(self, out = None, debug = False):
    """
    Prints out a summary of a site's chemical and scattering environment.

    Parameters
    ----------
    out : file, optional
    debug : bool, optional
    """
    if (out is None) : out = sys.stdout
    results = self.matching_candidates
    if (len(results) > 0):
      self.atom_props.show_properties(identity = "HOH", out = out)
      if (self.nuc_phosphate_site):
        print("  appears to be nucleotide coordination site", file=out)
      if (self.no_final):
        print("  Found potential ion%s outside of specified set:" % \
          ("s" if len(results) > 1 else ""), file=out)
      if (self.final_choice is not None):
        # We have one result that we are reasonably certain of
        elem_params, score = results[0]
        if elem_params.element not in mmtbx.ions.HALIDES:
          self.atom_props.show_ion_results(
            identity = str(self.final_choice),
            out = out,
            valence_used = self.valence_used,
            confirmed = True)
        else:
          print("  Probable anion:", str(elem_params), file=out)
        print("", file=out)
      elif (len(results) > 1):
        # We have a couple possible identities for the atom
        below_cutoff = [ elem_params for elem_params, score in results
                        if score < self.ambiguous_valence_cutoff]
        if len(below_cutoff) == 1:
          elem_params = below_cutoff[0]
          print("  ambigous results, best valence from %s" % \
            str(elem_params), file=out)
          self.atom_props.show_ion_results(
            identity = str(elem_params),
            out = out,
            valence_used = True)
          print("", file=out)
        else:
          ions = [str(i[0]) for i in sorted(results, key = lambda x: x[1])]
          print("  ambiguous results, could be %s" % ", ".join(ions), file=out)
          for elem_params, score in results :
            self.atom_props.show_ion_results(identity = str(elem_params),
              out = out)
          print("", file=out)
    else:
      if (self.atom_type != WATER) or (self.nuc_phosphate_site):
        self.atom_props.show_properties(identity = "HOH", out = out)
        if (self.nuc_phosphate_site):
          print("  appears to be nucleotide coordination site", file=out)
        # try anions now
        if (self.looks_like_halide):
          print("  Probable cation: %s" % str(self.final_choice), file=out)
          print("", file=out)
        else:
          # atom is definitely not water, but no reasonable candidates found
          # print out why all the metals we tried failed
          if (debug) and (len(self.filtered_candidates) > 0):
            print("  insufficient data to identify atom", file=out)
            possible = True
            for params in self.filtered_candidates:
              if (self.atom_props.has_compatible_ligands(str(params))):
                if possible:
                  print("  possible candidates:", file=out)
                  possible = False
                self.atom_props.show_ion_results(identity = str(params),
                  out = out)
              else :
                print("  incompatible ligands for %s" % str(params), file=out)
            #print >> out, "  rejected as unsuitable:"
            #for params in self.rejected_candidates:
            #  if (self.atom_props.has_compatible_ligands(str(params))):
            #    self.atom_props.show_ion_results(identity = str(params),
            #      out = out)
            #  else :
            #    print >> out, "  incompatible ligands for %s" % str(params)
          print("", file=out)

class AtomProperties(object):
  """
  Collect physical attributes of an atom, including B, occupancy, and map
  statistics, and track those which are at odds with its chemical identity.
  """

  LOW_B, HIGH_B, LOW_OCC, HIGH_OCC, NO_2FOFC_PEAK, FOFC_PEAK, FOFC_HOLE, \
    ANOM_PEAK, NO_ANOM_PEAK, BAD_GEOMETRY, NO_GEOMETRY, BAD_VECTORS, \
    BAD_VALENCES, TOO_FEW_NON_WATERS, TOO_FEW_COORD, TOO_MANY_COORD, \
    LIKE_COORD, BAD_COORD_ATOM, BAD_FPP, BAD_COORD_RESIDUE, VERY_BAD_VALENCES, \
    BAD_HALIDE, HIGH_2FOFC, COORDING_GEOMETRY, CLOSE_CONTACT \
    = range(25)

  error_strs = {
    LOW_B: "Abnormally low b-factor",
    HIGH_B: "Abnormally high b-factor",
    LOW_OCC: "Abnormally low occupancy",
    HIGH_OCC: "Abnormally high occupancy",
    NO_2FOFC_PEAK: "No 2mFo-DFc map peak",
    FOFC_PEAK: "Peak in mFo-DFc map",
    FOFC_HOLE: "Negative peak in dFo-mFc map",
    ANOM_PEAK: "Peak in the anomalous map",
    NO_ANOM_PEAK: "No peak in the anomalous map",
    BAD_GEOMETRY: "Unexpected geometry for coordinating atoms",
    NO_GEOMETRY: "No distinct geometry for coordinating atoms",
    BAD_VECTORS: "VECSUM above cutoff",
    BAD_VALENCES: "BVS above or below cutoff",
    TOO_FEW_NON_WATERS: "Too few non-water coordinating atoms",
    TOO_FEW_COORD: "Too few coordinating atoms",
    TOO_MANY_COORD: "Too many coordinating atoms",
    LIKE_COORD: "Like charge coordinating like",
    BAD_COORD_ATOM: "Disallowed coordinating atom",
    BAD_FPP: "Bad refined f'' value",
    BAD_COORD_RESIDUE: "Disallowed coordinating residue",
    VERY_BAD_VALENCES: "BVS far above or below cutoff",
    BAD_HALIDE: "Bad halide site",
    HIGH_2FOFC: "Unexpectedly high 2mFo-DFc value",
    COORDING_GEOMETRY: "No distinct geometry and coordinating another atom with distinct geometry",
    CLOSE_CONTACT : "Close contact to oxygen atom",
    }

  def __init__(self, i_seq, manager):
    self.i_seq = i_seq
    self.atom = manager.pdb_atoms[i_seq].fetch_labels()
    self.resname = self.atom.resname.strip().upper()
    self.d_min = manager.fmodel.f_obs().d_min()
    self.anomalous_flag = manager.fmodel.f_obs().anomalous_flag()
    self.strict_valence = manager.get_strict_valence_flag()

    # Grab all the atoms within 3.5 Angstroms
    nearby_atoms_unfiltered = manager.find_nearby_atoms(
      i_seq = i_seq,
      far_distance_cutoff = 3.5)
    self.nearby_atoms = []
    nearby_atoms_no_alts = []
    for contact in nearby_atoms_unfiltered :
      if (contact.element not in ["H", "D"]):
        self.nearby_atoms.append(contact)
        for other in nearby_atoms_no_alts :
          if (other == contact):
            break
        else :
          nearby_atoms_no_alts.append(contact)

    self.residue_counts = utils.count_coordinating_residues(
      self.nearby_atoms)
    self.geometries = find_coordination_geometry(nearby_atoms_no_alts)

    map_stats = manager.map_stats(i_seq)
    self.peak_2fofc = map_stats.two_fofc
    self.peak_fofc = map_stats.fofc
    self.peak_anom = map_stats.anom
    self.estimated_weight = manager.guess_molecular_weight(i_seq)
    self.b_iso = manager.get_b_iso(i_seq)
    # cache global properties
    self.b_mean_hoh = manager.b_mean_hoh
    self.b_stddev_hoh = manager.b_stddev_hoh
    self.b_mean_calpha = manager.b_mean_calpha
    self.calpha_mean_two_fofc = manager.calpha_mean_two_fofc

    self.inaccuracies = {}
    self.ignored = {}
    self.vectors = {}
    self.valence_sum = {}
    self.vector_sum = {}
    self.score = {}
    self.fpp_expected = {}
    self.expected_params = {}
    self.bad_coords = {}

    # Determine the f'' value if possible using phaser or anomalous refinement
    self.fpp = manager.get_fpp(i_seq)
    self.fpp_ratios = {}
    self.fp = manager.get_fp(i_seq)
    self.manager = manager

  def is_correctly_identified(self, identity = None):
    """
    Calculates whether factors indicate that the atom was correctly identified.

    Parameters
    ----------
    identity : mmtbx.ions.metal_parameters

    Returns
    -------
    bool
    """
    if identity is None:
      identity = self.identity()

    return len(self.inaccuracies[identity]) == 0

  def has_compatible_ligands(self, identity):
    """
    Indicates whether the coordinating atoms are of the allowed type (e.g.
    no N or S atoms coordinating CA, etc.) and residue (e.g. Ser is not an
    appropriate ligand for ZN).

    Parameters
    ----------
    identity : mmtbx.ions.metal_parameters

    Returns
    -------
    bool
    """
    return ((len(self.bad_coords[identity]) == 0) and
            (not self.BAD_COORD_RESIDUE in self.inaccuracies[identity]))

  def is_compatible_site(self, ion_params, require_anom = True,
      ignore_valence=False):
    """
    More minimal criteria for determining whether a site is chemically
    compatible, allowing for incomplete coordination shells.

    Parameters
    ----------
    ion_params : mmtbx.ions.metal_parameters
    require_anom : bool, optional
    ignore_valence : bool, optional

    Returns
    -------
    bool
    """
    inaccuracies = self.inaccuracies[str(ion_params)]
    anom_allowed = self.is_compatible_anomalous_scattering(ion_params) or \
                   (not require_anom)
    return (self.has_compatible_ligands(str(ion_params)) and
            (not self.TOO_MANY_COORD in inaccuracies) and
            (ignore_valence or (not self.VERY_BAD_VALENCES in inaccuracies))
            and (not self.BAD_COORD_RESIDUE in inaccuracies) and
            (anom_allowed))

  def number_of_favored_ligand_residues(self, ion_params, distance = 3.0,
      exclude_atoms = ()):
    """
    Counts the number of preferred residues coordinating the atom.  Used for
    approximate detection of transition-metal binding sites.

    Parameters
    ----------
    ion_params : mmtbx.ions.metal_parameters
    distance : float, optional
    exclude_atoms : tuple of ...

    Returns
    -------
    int
    """
    n_res = 0
    resids = []
    for contact in self.nearby_atoms:
      if (contact.atom_name() in exclude_atoms):
        continue
      if (contact.distance() < distance):
        labels = contact.atom.fetch_labels()
        other_resname = contact.resname()
        other_resid = labels.chain_id + labels.resid()
        if ((ion_params.allowed_coordinating_residues is not None) and
            (other_resname in ion_params.allowed_coordinating_residues) and
            (not other_resid in resids)):
          n_res += 1
          resids.append(other_resid)
    return n_res

  def number_of_atoms_within_radius(self, distance_cutoff):
    """
    Counts the number of coordinating atoms within a given radius.

    Parameters
    ----------
    float

    Returns
    -------
    int
    """
    n_atoms = 0
    atom_ids = []
    for contact in self.nearby_atoms:
      other_id = contact.atom_id_no_altloc()
      if (not other_id in atom_ids):
        if (contact.distance() < distance_cutoff):
          n_atoms += 1
        atom_ids.append(other_id) # check for alt confs.
    return n_atoms

  def number_of_backbone_oxygens(self, distance_cutoff=3.0):
    """
    Counts the number of backbone oxygens coordinating a site.

    Parameters
    ----------
    distance_cutoff : float, optional

    Returns
    -------
    int
    """
    n_bb_ox = 0
    for contact in self.nearby_atoms :
      if (contact.atom_name() == "O"):
        if (contact.distance() <= distance_cutoff):
          if (not contact.resname() in WATER_RES_NAMES):
            n_bb_ox += 1
    return n_bb_ox

  # FIXME needs to be refactored and combined with check_fpp_ratio
  def is_compatible_anomalous_scattering(self, ion_params):
    # lighter elements should have effectively no anomalous scattering
    if (ion_params.element.upper() in ["MG", "NA"]):
      return ((self.fpp is None) and (self.peak_anom is not None) and
              (self.peak_anom < 1.0))
    else :
      # XXX somewhat dangerous - we really need f'' for this to work reliably
      if (self.fpp is None):
        return (self.peak_anom is not None) and (self.peak_anom > 3.0)
      identity = self.identity(ion = ion_params)
      if (identity in self.fpp_ratios):
        return (not self.BAD_FPP in self.inaccuracies[identity])
    return False

  # XXX obsolete, delete?
  def atom_weight(self, manager):
    """
    Evaluates whether factors indicate that the atom is lighter, heavier, or
    isoelectric to what it is currently identified as.

    Parameters
    ----------
    manager : mmtbx.ions.identify.manager

    Returns
    -------
    int
        -1 if lighter, 0 if isoelectronic, and 1 if heavier.
    """
    identity = "HOH" if self.resname in WATER_RES_NAMES else self.identity()
    # Waters that don't have B-factors at least 1 stddev below the mean are
    # presumed to be correct
    if (identity == "HOH" and
        (self.atom.b > manager.b_mean_hoh - manager.b_stddev_hoh)):
      return 0
    if self.is_correctly_identified(identity = identity):
      return 0
    # B-factors/occupancies?
    if self.FOFC_PEAK in self.inaccuracies[identity] or self.atom.b < 1:
      return 1
    if self.FOFC_HOLE in self.inaccuracies[identity]:
      return -1
    return 0

  def check_ion_environment(self,
      ion_params,
      wavelength = None,
      require_valence = True):
    """
    Checks whether or not the specified ion satisfies the metal-coordination
    parameters, specified by ion_params, such as valence sum, geometry, etc.
    The criteria used here are quite strict, but many of the analyses are
    saved for later if we want to use looser critera.

    Parameters
    ----------
    ion_params : mmtbx.ions.metal_parameters
    wavelength : float, optional
    require_valence : bool, optional
    """
    from iotbx.pdb import common_residue_names_get_class as get_class

    identity = self.identity(ion_params)
    inaccuracies = self.inaccuracies[identity] = set()
    self.expected_params[identity] = ion_params
    ignored = self.ignored[identity] = set()

    # if the atom is clearly not a water, optionally relax some rules.  this
    # will be more sensitive for transition metals, without finding a lot of
    # spurious Mg/Na sites.
    strict_rules = require_valence or \
      self.is_correctly_identified(identity = "HOH") or \
      self.strict_valence or \
      ion_params.element in ["NA","MG"]

    # Check for all non-overlapping atoms within 3 A of the metal
    n_closest = 0
    coord_atoms = []
    for i_pair, contact1 in enumerate(self.nearby_atoms):
      distance = contact1.distance()
      if (distance < 3.0):
        for contact2 in self.nearby_atoms[(i_pair+1):] :
          if ((contact1 == contact2) or
              (contact1.distance_from(contact2) <= 0.3)):
            break
        else :
          coord_atoms.append(contact1)
          if (distance < 2.7):
            n_closest += 1

    if len(coord_atoms) < ion_params.coord_num_lower:
      inaccuracies.add(self.TOO_FEW_COORD)

    if n_closest > ion_params.coord_num_upper:
      inaccuracies.add(self.TOO_MANY_COORD)

    # Coordinating atoms closer than 3.0 A are not positively charged
    n_non_water = 0
    self.bad_coords[identity] = []

    for contact in self.nearby_atoms:
      other_name = contact.atom_name()
      other_resname = contact.resname()
      other_element = contact.element

      if (not other_resname in WATER_RES_NAMES):
        n_non_water += 1
      else:
        # Everything can potentially be coordinated by water
        continue

      if (contact.distance() < 3.0):
        # XXX: So, we have a a fair number of rules restricting nitrogens and
        # nitrogen-containing residues from coordinating a number of cations.
        #
        # However, this rule is dependent on the protonation of the nitrogen,
        # if the pKa is low at the site, it is possible for a metal to
        # coordinate the residue fine.
        #
        # We want a complex rule that takes into account coordinating geometry,
        # density signal, and the presence of other coordinating atoms that
        # might drop the site's pKa enough to lose the hydrogen.
        if ((ion_params.allowed_coordinating_atoms is not None) and
            (other_element not in ion_params.allowed_coordinating_atoms)):
          self.bad_coords[identity].append(contact)
          inaccuracies.add(self.BAD_COORD_ATOM)
        if (get_class(other_resname) == "common_amino_acid"):
          # limit elements allowed to bind to backbone atoms (mainly carbonyl
          # oxygen)
          if ((other_name in ["C","N","O","CA","H","HA"]) and
              ((ion_params.allowed_backbone_atoms is None) or
               (not other_name in ion_params.allowed_backbone_atoms))):
            if (other_name == "O") and (contact.is_carboxy_terminus):
              pass # C-terminal carboxyl group is allowed
            else :
              self.bad_coords[identity].append(contact)
              inaccuracies.add(self.BAD_COORD_ATOM)
          # Check if atom is of an allowed residue type, if part of a sidechain
          if (ion_params.allowed_coordinating_residues is not None):
            allowed = ion_params.allowed_coordinating_residues
            if ((not other_resname in allowed) and
                (other_name not in ["C", "O", "N", "CA", "OXT"])):
                # XXX probably just O
              self.bad_coords[identity].append(contact)
              inaccuracies.add(self.BAD_COORD_RESIDUE)
        elif (cmp(0, mmtbx.ions.server.get_charge(contact.atom)) ==
              cmp(0, ion_params.charge)):
          # Check if coordinating atom is of opposite charge
          self.bad_coords[identity].append(contact)
          inaccuracies.add(self.LIKE_COORD)
        elif (ion_params.charge > 0 and
            other_element in ["N"] and
            other_resname in ["LYS", "ARG", "ASN", "GLN"]):
          # Coordinating nitrogen most likely positive.
          #
          # Ignore nitrogens without a charge label that are on positively
          # charged amino acids.
          self.bad_coords[identity].append(contact)
          inaccuracies.add(self.LIKE_COORD)

    # Check the number of coordinating waters
    if (n_non_water < ion_params.min_coordinating_non_waters):
      inaccuracies.add(self.TOO_FEW_NON_WATERS)

    # Check the geometry of the coordinating atoms
    if ion_params.allowed_geometries and strict_rules:
      allowed = [i[0] in ion_params.allowed_geometries
                 for i in self.geometries]
      if "any" in ion_params.allowed_geometries:
        pass
      elif not self.geometries:
        if strict_rules:
          inaccuracies.add(self.NO_GEOMETRY)
      elif not any(allowed):
        inaccuracies.add(self.BAD_GEOMETRY)
      else:
        strict_rules = False

    # If no distinct geometry, check that none of the coordinating have distinct
    # geometry, either
    if self.geometries == []:
      for contact in self.nearby_atoms:
        o_atom = contact.atom
        if o_atom.i_seq in self.manager.atoms_to_props:
          o_geometry = self.manager.atoms_to_props[o_atom.i_seq].geometries
          if o_geometry != []:
            inaccuracies.add(self.COORDING_GEOMETRY)

    # Check for reasonable vector/valence values
    vectors = mmtbx.ions.server.calculate_valences(ion_params,
      self.nearby_atoms)
    self.vectors[identity] = vectors

    self.valence_sum[identity] = sum([abs(i) for i in vectors])
    self.vector_sum[identity] = abs(sum(vectors, col((0, 0, 0))))

    if self.vector_sum[identity] > ion_params.vec_sum_cutoff:
      if (strict_rules):
        inaccuracies.add(self.BAD_VECTORS)
      else :
        ignored.add(self.BAD_VECTORS)

    # XXX I am not sure how low a valence sum we want to allow, but many
    # structures with non-physiological cation binding have partial and/or
    # irregular coordination shells
    if (self.valence_sum[identity] < ion_params.cvbs_expected * 0.25 or
        self.valence_sum[identity] > ion_params.cvbs_expected * 1.25):
      inaccuracies.add(self.VERY_BAD_VALENCES)
    else:
      if (self.valence_sum[identity] < ion_params.cvbs_lower or
          self.valence_sum[identity] > ion_params.cvbs_upper):
        if strict_rules:
          inaccuracies.add(self.BAD_VALENCES)
        else :
          ignored.add(self.BAD_VALENCES)

    self.score[identity] = abs(self.valence_sum[identity] -
                               ion_params.cvbs_expected)

  # FIXME this really needs to be refactored and combined with the method
  # is_compatible_anomalous_scattering
  def check_fpp_ratio(self,
      ion_params,
      wavelength,
      fpp_ratio_min = 0.3,
      fpp_ratio_max = 1.05):
    """
    Compare the refined and theoretical f'' values if available.

    Parameters
    ----------
    ion_params : mmtbx.ions.metal_parameters
    wavelength : float
    fpp_ratio_min : float, optional
    fpp_ratio_max : float, optional

    Returns
    -------
    float
        f'' / f''_expected
    """
    identity = str(ion_params)
    inaccuracies = self.inaccuracies.get(identity, None)
    if (inaccuracies is None):
      inaccuracies = self.inaccuracies[identity] = set()
    if (ion_params.element.upper() in ["MG", "NA"]):
      if (self.fpp is not None) or (self.peak_anom is not None and self.peak_anom > 1):
        inaccuracies.add(self.BAD_FPP)
    else :
      # XXX in theory the fpp_ratio should be no more than 1.0 unless we are
      # right on the peak wavelength.  in practice Phaser can overshoot a little
      # bit, so we need to be more tolerant.  picking the maximum f'' from the
      # Sasaki and Henke tables will also limit the ratio.
      if (wavelength is not None) and (self.anomalous_flag):
        fpp_expected_sasaki = sasaki.table(ion_params.element).at_angstrom(
          wavelength).fdp()
        fpp_expected_henke = henke.table(ion_params.element).at_angstrom(
          wavelength).fdp()
        self.fpp_expected[identity] = max(fpp_expected_sasaki,
          fpp_expected_henke)
        if (self.fpp is not None) and (self.fpp_expected[identity] != 0):
          self.fpp_ratios[identity] = self.fpp / self.fpp_expected[identity]
          if ((self.fpp_ratios[identity] > fpp_ratio_max) or
              ((self.fpp >= 0.2) and
               (self.fpp_ratios[identity] < fpp_ratio_min))):
            inaccuracies.add(self.BAD_FPP)
        elif (self.fpp_expected[identity] > 0.75) and (self.peak_anom < 2):
          inaccuracies.add(self.BAD_FPP)
    return self.fpp_ratios.get(identity)

  def show_properties(self, identity, out = sys.stdout):
    """
    Show atomic properties that are independent of the suspected identity.

    Parameters
    ----------
    identity : mmtbx.ions.metal_parameters
    out : file, optional
    """
    print("%s:" % self.atom.id_str(), file=out)
    b_flag = ""
    if (self.LOW_B in self.inaccuracies[identity]):
      b_flag = " <<<"
    elif (self.HIGH_B in self.inaccuracies[identity]):
      b_flag = " !!!"
    print("  B-factor:      %6.2f%s" % (self.atom.b, b_flag), file=out)
    occ_flag = ""
    if (self.LOW_OCC in self.inaccuracies[identity]):
      occ_flag = " !!!"
    elif (self.HIGH_OCC in self.inaccuracies[identity]):
      occ_flag = " <<<"
    print("  Occupancy:     %6.2f%s" % (self.atom.occ, occ_flag), file=out)
    twofofc_flag = ""
    if (self.NO_2FOFC_PEAK in self.inaccuracies[identity]):
      twofofc_flag = " !!!"
    elif (self.HIGH_2FOFC in self.inaccuracies[identity]):
      twofofc_flag = " <<<"
    print("  2mFo-DFc map:  %6.2f%s" % (self.peak_2fofc, twofofc_flag), file=out)
    fofc_flag = ""
    if (self.FOFC_PEAK in self.inaccuracies[identity]):
      fofc_flag = " <<<"
    elif (self.FOFC_HOLE in self.inaccuracies[identity]):
      fofc_flag = " !!!"
    print("  mFo-DFc map:   %6.2f%s" % (self.peak_fofc, fofc_flag), file=out)
    if (self.peak_anom is not None):
      anom_flag = ""
      if (self.ANOM_PEAK in self.inaccuracies[identity]):
        anom_flag = " <<<"
      elif (self.NO_ANOM_PEAK in self.inaccuracies[identity]):
        anom_flag = " !!!"
      print("  Anomalous map: %6.2f%s" % (self.peak_anom, anom_flag), file=out)
    if (self.estimated_weight is not None):
      print("  Approx. mass:  %6d" % self.estimated_weight, file=out)
    if self.fpp is not None:
      fpp_flag = ""
      if (self.fpp >= 0.2):
        fpp_flag = " <<<"
      print("  f'':           %6.2f%s" % (self.fpp, fpp_flag), file=out)
      print("  f'' ratio:     %s" % format_value("%6.2f",
        self.fpp_ratios.get(identity)), file=out)
    if self.nearby_atoms is not None:
      angstrom = u"\N{ANGSTROM SIGN}".encode("utf-8", "strict")
      degree = u"\N{DEGREE SIGN}".encode("utf-8", "strict")

      print("  Nearby atoms: (%d within 3.0 %s)" % \
        (len([i for i in self.nearby_atoms if i.distance() < 3]), angstrom), file=out)

      for contact in self.nearby_atoms :
        print("    %s (%5.3f %s)" % \
        (contact.id_str(), contact.distance(), angstrom), file=out)

      if self.geometries:
        print("  Coordinating geometry:", file=out)
        for geometry, deviation in self.geometries:
          print("    %-15s (average deviation: %.3f%s)" % \
            (geometry, deviation, degree), file=out)

  def show_ion_results(self, identity = None, out = sys.stdout,
      confirmed = False, valence_used = True):
    """
    Show statistics for a proposed element identity.

    Parameters
    ----------
    identity : mmtbx.ions.metal_parameters
    out : file, optional
    confirmed : bool, optional
    valence_used : bool, optional
    """

    if not identity:
      identity = self.identity(self.atom)

    inaccuracies = self.inaccuracies.get(identity, set([]))
    ignored = self.ignored.get(identity, set([]))

    if identity != self.identity():
      if (confirmed):
        print("  Probable cation: %s" % identity, file=out)
      else :
        print("  Atom as %s:" % identity, file=out)
    else:
      print("    %s:" % self.atom.id_str(), file=out)

    if identity in self.vector_sum and self.vector_sum[identity] is not None:
      problem = ((self.BAD_VECTORS in inaccuracies) or
                 (self.BAD_VECTORS in ignored))

      print("    Vector sum:  %6.3f %s" % \
        (self.vector_sum[identity], " !!!" if problem else ""), file=out)

    if identity in self.valence_sum and self.valence_sum[identity] is not None:
      problem = inaccuracies.union(ignored).intersection(
        [self.BAD_VALENCES, self.VERY_BAD_VALENCES])

      print("    Valence sum: %6.3f" % self.valence_sum[identity], file=out)
      if valence_used:
        print("(expected: %6.3f) %s" % \
        (self.expected_params[identity].cvbs_expected, " !!!" if problem else ""), end=' ', file=out)

    if self.NO_GEOMETRY in inaccuracies:
      print("    No distinct geometry !!!", file=out)

    if self.BAD_GEOMETRY in inaccuracies:
      print("    Unexpected geometry  !!!", file=out)

    bad_coord = [self.LIKE_COORD, self.BAD_COORD_ATOM, self.BAD_COORD_RESIDUE]
    if inaccuracies.intersection(bad_coord):
      print("    Bad coordinating atom%s:" % \
         ("s" if len(self.bad_coords[identity]) != 1 else ""), file=out)
      angstrom = u"\u00C5".encode("utf-8", "strict").strip()
      for atom, vector in self.bad_coords[identity]:
        print("    %s (%5.3f %s) !!!" % \
          (atom.id_str(), abs(vector), angstrom), file=out)

    if self.TOO_FEW_NON_WATERS in inaccuracies:
      print("    Too few coordinating non-waters !!!", file=out)
    if self.TOO_FEW_COORD in inaccuracies:
      print("    Too few coordinating atoms !!!", file=out)
    if self.TOO_MANY_COORD in inaccuracies:
      print("    Too many coordinating atoms !!!", file=out)

    if (self.fpp is not None) and (identity in self.fpp_ratios):
      print("    f'' ratio:   %6.3f%s" % \
         (self.fpp_ratios[identity], " !!!" if self.BAD_FPP in inaccuracies else ""), file=out)

  # XXX can we get away with just one oxygen?
  def looks_like_nucleotide_phosphate_site(self,
      min_phosphate_oxygen_atoms = 2,
      distance_cutoff = 2.5) : # XXX wild guess
    """
    Decide whether the atom is coordinating phosphate oxygens from a
    nucleotide, based on common atom names.

    Parameters
    ----------
    min_phosphate_oxygen_atoms : int, optional
    distance_cutoff : float, optional

    Returns
    -------
    bool
    """
    n_phosphate_oxygens = 0
    for contact in self.nearby_atoms :
      atom_name = contact.atom_name()
      if (len(atom_name) < 3) or (contact.element not in ["O"]):
        continue
      if ((atom_name[0:2] in ["O1","O2","O3"]) and
          (atom_name[2] in ["A","B","G"])):
        if (contact.distance() <= distance_cutoff):
          n_phosphate_oxygens += 1
    return (n_phosphate_oxygens == min_phosphate_oxygen_atoms)

  def identity(self, ion=None):
    """
    Covers an atom into a string representing its element and charge.

    Parameters
    ----------
    ion : iotbx.pdb.hierarchy.atom, optional

    Returns
    -------
    str
    """
    if ion is None:
      ion = self.atom
    element = mmtbx.ions.server.get_element(ion)
    charge = mmtbx.ions.server.get_charge(ion)
    return "{}{:+}".format(element, charge)

  def get_atom_type(self, params, aggressive=False):
    """
    Checks the atom characteristics against what we would expect for a water.
    Updates self with any inaccuracies noticed (Surpringly low b-factor,
    high occupancy, etc).  Note that HEAVY_ION does not necessarily rule out
    NA/MG, as these often have mFo-DFc peaks at high resolution.

    Parameters
    ----------
    params : libtbx.phil.scope_extract
    aggressive : bool, optional

    Returns
    -------
    int
        One of WATER, WATER_POOR, HEAVY_ION, LIGHT_ION
    """
    inaccuracies = self.inaccuracies["HOH"] = set()
    atom_type = WATER
    # Skip over water if the 2mFo-DFc or mFo-DFc value is too low
    if ((self.peak_2fofc < params.min_2fofc_level) or
        (self.peak_fofc < -2.0)):
      return WATER_POOR
    if (self.fpp is not None) and (self.fpp > params.fpp_max):
      return HEAVY_ION
    if (self.fp is not None) and (self.fp > params.fp_max):
      return HEAVY_ION
    if self.peak_anom is not None and self.peak_anom > params.max_anom_level:
      inaccuracies.add(self.ANOM_PEAK)
      atom_type = HEAVY_ION
    if self.peak_fofc > params.max_fofc_level:
      inaccuracies.add(self.FOFC_PEAK)
      atom_type = HEAVY_ION
    if self.atom.occ > params.max_occ: # this will probably never happen...
      inaccuracies.add(self.HIGH_OCC)
      atom_type = HEAVY_ION
    # very low B-factors automatically trigger a check
    if (self.atom.b < params.min_b_iso):
      inaccuracies.add(self.LOW_B)
      atom_type = HEAVY_ION
    elif (self.b_stddev_hoh is not None) and (self.b_stddev_hoh > 0):
      # high B-factor relative to other waters
      z_value = (self.b_iso - self.b_mean_hoh) / self.b_stddev_hoh
      if z_value < -params.max_stddev_b_iso:
        inaccuracies.add(self.LOW_B)
      elif self.atom.b < self.b_mean_hoh * params.min_frac_b_iso:
        inaccuracies.add(self.LOW_B)
      if (atom_type == WATER) and (self.LOW_B in inaccuracies):
        atom_type = LIGHT_ION
    if (aggressive) and (atom_type == WATER):
      # high B-factor relative to C-alpha
      if (self.b_mean_calpha > 0):
        relative_b = self.b_iso / self.b_mean_calpha
        if (relative_b < params.min_frac_calpha_b_iso):
          inaccuracies.add(self.LOW_B)
          atom_type = LIGHT_ION
      # high 2Fo-Fc relative to C-alpha
      if (self.calpha_mean_two_fofc > 0):
        relative_2fofc = self.peak_2fofc / self.calpha_mean_two_fofc
        if (relative_2fofc > params.max_frac_calpha_2fofc):
          inaccuracies.add(self.HIGH_2FOFC)
          atom_type = LIGHT_ION
    # check for close contacts
    for i_pair, contact1 in enumerate(self.nearby_atoms):
      if (contact1.element.strip() == "O"):
        distance = contact1.distance()
        if (distance < 2.4):
          inaccuracies.add(self.CLOSE_CONTACT)
          if (atom_type < LIGHT_ION):
            atom_type = LIGHT_ION
    return atom_type

def find_anomalous_scatterers(*args, **kwds):
  """
  Wrapper for corresponding method in phaser.substructure, if phaser is
  available and configured.
  """
  if (not libtbx.env.has_module("phaser")):
    if "log" in kwds:
      print("Phaser not available", file=kwds["log"])
    return None
  from phaser import substructure
  return substructure.find_anomalous_scatterers(*args, **kwds)

def create_manager(
    pdb_hierarchy,
    geometry_restraints_manager,
    fmodel,
    wavelength,
    params,
    resolution_factor = 0.25,
    nproc = Auto,
    verbose = False,
    log = None,
    manager_class=None):
  """
  Wrapper around mmtbx.ions.identify.manager init method. Retrieves the
  connectivity and xray_structure from fmodel automatically.

  Parameters
  ----------
  pdb_hierarchy : iotbx.pdb.hierarchy.root
  geometry_restraints_manager : cctbx.geometry_restraints.manager.manager
  fmodel : mmtbx.f_model.manager
  wavelength : float
  params : libtbx.phil.scope_extract
  resolution_factor : float, optional
  nproc : int, optional
  verbose : bool, optional
  log : file, optional
  manager_class : class, optional

  Returns
  -------
  mmtbx.ions.identify.manager or mmtbx.ions.svm.manager
  """
  connectivity = \
    geometry_restraints_manager.shell_sym_tables[0].full_simple_connectivity()
  if (manager_class is None):
    manager_class = manager
  manager_obj = manager_class(
    fmodel = fmodel,
    pdb_hierarchy = pdb_hierarchy,
    xray_structure = fmodel.xray_structure,
    connectivity = connectivity,
    wavelength = wavelength,
    params = params,
    nproc = nproc,
    verbose = verbose,
    log = log)
  return manager_obj

def _PRINT_DEBUG(*args):
  """
  Prints a debugging message to stderr.
  """
  print(sys.stderr, args, file=sys.stderr)


 *******************************************************************************


 *******************************************************************************
mmtbx/ions/svm/__init__.py
# -*- coding: utf-8; py-indent-offset: 2 -*-
"""
A set of functions to act upon ChemicalEnvironment and ScatteringEnvironment and
produce a single class and vector of features for use with a classifier.

This module relies on a SVM classifier generated by the module within
phenix_dev.ion_identification.nader_ml. See that module's description for more
details.

See Also
--------
phenix_dev.ion_identification.nader_ml
"""

from __future__ import absolute_import, division, print_function

try:
  from collections.abc import Iterable
except ImportError:
  from collections import Iterable
from six import string_types
from six.moves import cStringIO as StringIO
from ctypes import c_double
import errno
import os
import sys

from libtbx import Auto, slots_getstate_setstate_default_initializer
from libtbx.easy_pickle import load
from libtbx.str_utils import make_sub_header
from libtbx.utils import Sorry
import libtbx.load_env
from cctbx.eltbx import sasaki
from iotbx.pdb import common_residue_names_water as WATER_RES_NAMES
from mmtbx.ions.environment import N_SUPPORTED_ENVIRONMENTS
from mmtbx.ions.geometry import SUPPORTED_GEOMETRY_NAMES
import mmtbx.ions.identify
from mmtbx.ions.svm import utils
from six.moves import zip
from six.moves import range

try : # XXX required third-party dependencies
  import numpy as np
  from libsvm import svm
  from libsvm import svmutil
except ImportError :
  svm = None
  svmutil = None
  np = None

CLASSIFIERS_PATH = libtbx.env.find_in_repositories(
  relative_path = "chem_data/classifiers",
  test = os.path.isdir,
  )

_DEFAULT_SVM_NAME = "merged_high_res"
#_DEFAULT_SVM_NAME = "heavy"
_CLASSIFIER = {}
_CLASSIFIER_OPTIONS = {}

ALLOWED_IONS = [
  "HOH", "MN", "ZN", "FE", "NI", "CA", "NA", "MG", "CL", "CU", "CO", "CD", "K",
  ]

def _get_classifier(svm_name=None):
  """
  If need be, initializes, and then returns a classifier trained to
  differentiate between different ions and water. Also returns of options for
  gathering features.

  To use the classifier, you will need to pass it to
  svm.libsvm.svm_predict_probability. Ion prediction is already encapsulated by
  predict_ion, so most users should just call that.

  Parameters
  ----------
  svm_name : str, optional
      The SVM to use for prediction. By default, the SVM trained on heavy atoms
      and calcium in the presence of anomalous data is used. See
      chem_data/classifiers for a full list of SVMs available.

  Returns
  -------
  svm.svm_model
      The libsvm classifier used to predict the identities of ion sites.
  dict of str, bool
      Options to pass to ion_vector when collecting features about these sites.
  tuple of ((tuple of numpy.array of float, numpy.array of float),
            tuple of float)
      The scaling parameters passed to scale_to.
  numpy.array of bool
      The features of the vector that were selected as important for
      classification. Useful for both asserting that ion_vector is returning
      something of the correct size as well as only selection features that
      actually affect classification.

  See Also
  --------
  svm.libsvm.svm_predict_probability
  mmtbx.ions.svm.predict_ion
  phenix_dev.ion_identification.nader_ml.ions_train_svms
  """
  assert (svmutil is not None)
  global _CLASSIFIER, _CLASSIFIER_OPTIONS

  if not svm_name or str(svm_name) == "Auto" :
    svm_name = _DEFAULT_SVM_NAME

  if svm_name not in _CLASSIFIER:
    svm_path = os.path.join(CLASSIFIERS_PATH, "{}.model".format(svm_name))
    options_path = os.path.join(CLASSIFIERS_PATH,
                                "{}_options.pkl".format(svm_name))
    try:
      _CLASSIFIER[svm_name] = svmutil.svm_load_model(svm_path)
    except IOError as err:
      if err.errno != errno.ENOENT:
        raise err
      else:
        _CLASSIFIER[svm_name] = None
        _CLASSIFIER_OPTIONS[svm_name] = (None, None, None)
    _CLASSIFIER_OPTIONS[svm_name] = load(options_path)

  vector_options, scaling, features = _CLASSIFIER_OPTIONS[svm_name]
  from libtbx.utils import to_str
  tmp = {}
  for key, item in vector_options.items():
    key=to_str(key)
    if key=='elements':
      tmp[key]=[]
      for e in item:
        tmp[key].append(to_str(e))
    else:
      tmp[key]=item
  vector_options=tmp
  return _CLASSIFIER[svm_name], vector_options, scaling, features

def ion_class(chem_env):
  """
  Returns the class name associated with the ion, analogous to the chemical
  ID.

  Parameters
  ----------
  chem_env : mmtbx.ions.environment.ChemicalEnvironment
      The object to extract the ion class from.

  Returns
  -------
  str
      The class associated with the ion (i.e. "HOH" or "ZN").
  """
  if hasattr(chem_env.atom, "segid") and chem_env.atom.segid.strip():
    name = chem_env.atom.segid.strip().upper()
  else:
    name = chem_env.atom.resname.strip().upper()
  if name in WATER_RES_NAMES:
    name = "HOH"
  return name

def ion_vector(chem_env, scatter_env, use_scatter=True, use_chem=True,
               b_iso=True, occ=True, diff_peak=True, geometry=True,
               elements=None, valence=True, anom=True, ratios=True,
               anom_peak=False, d_min=True):
  """
  Creates a vector containing all of the useful properties contained
  within ion. Merges together the vectors from ion_*_vector().

  Parameters
  ----------
  chem_env : mmtbx.ions.environment.ChemicalEnvironment
      A object containing information about the chemical environment at a site.
  scatter_env : mmtbx.ions.environment.ScatteringEnvironment, optional
      An object containing information about the scattering environment at a
      site.
  use_scatter : bool, optional
      Include information derived from the scattering environment (b-factor,
      occupancy, FoFc peak, 2FoFc peak and width, f'' values)
  use_chem : bool, optional
      Include information derived from the chemical environment (Geometry,
      coordinating atom identities, valences).
  b_iso : bool, optional
      Include the atom's refined isotropic b-factor, divided by the mean
      b-factor of solvent molecules in the structure.
  occ : bool, optional
      Include the atom's refined occupancy.
  diff_peak : bool, optional
      Include the difference map peak height.
  geometry : bool, optional
      Include information about the presence of various geometries.
  elements : list of str, optional
      List of elements to include when calculating BVS, VECSUM, and f''_expected
       values. If unset, takes the list from mmtbx.ions.ALLOWED_IONS.
  valence : bool, optional
      Include BVS and VECSUM values.
  anom : bool, optional
      Include anomalous scattering information.
  ratios : bool, optional
      Use f'' / f'' expected, instead of raw f'' and f' values.
  anom_peak : bool, optional
      Whether to use the actual height of the anomalous map instead of the
      calculated f'' values.
  d_min : bool, optional
      Include the high resolution associated with the model as a feature.

  Returns
  -------
  numpy.array of float
      A vector containing quantitative properties for classification.

  See Also
  --------
  ion_model_vector()
  ion_electron_density_vector()
  ion_geometry_vector()
  ion_nearby_atoms_vector()
  ion_valence_vector()
  ion_anomalous_vector()
  """
  assert (np is not None)
  return np.concatenate((
    ion_model_vector(scatter_env, d_min=d_min),
    ion_electron_density_vector(
      scatter_env, b_iso=b_iso, occ=occ, diff_peak=diff_peak)
    if use_scatter else [],
    ion_geometry_vector(chem_env)
    if use_chem and geometry else [],
    ion_nearby_atoms_vector(chem_env)
    if use_chem else [],
    ion_valence_vector(chem_env, elements=elements)
    if use_chem and valence else [],
    ion_anomalous_vector(scatter_env, elements=elements, ratios=ratios,
                         anom_peak=anom_peak)
    if use_scatter and anom else [],
    ))

def ion_model_vector(scatter_env, d_min=True, nearest_res=0.5):
  """
  Creates a vector containing information about the general properties of the
  model in which the site is found. Currently this only includes the minimum
  resolution of the data set.

  Parameters
  ----------
  scatter_env : mmtbx.ions.environment.ScatteringEnvironment
      An object containing information about the scattering environment at a
      site.
  d_min : bool, optional
      Include the high resolution associated with the model as a feature.
  nearest_res : float, optional
      If not None, the nearest value to round d_min to. This value has no effect
      if nearest_res is False.

  Returns
  -------
  numpy.array of float
      A vector containing quantitative properties for classification.
  """
  if not d_min:
    return np.array([], dtype=float)

  d_min = scatter_env.d_min
  if nearest_res is not None:
    # Rounds d_min to the nearest value divisible by nearest_res
    factor = 1 / nearest_res
    d_min = round(d_min * factor) / factor
  return np.array([ d_min, ], dtype=float)

def ion_electron_density_vector(scatter_env, b_iso=False, occ=False,
                                diff_peak=False):
  """
  Creates a vector containing information about the electron density around
  the site. Currently this only includes the site's peak in the 2FoFc map. May
  be expanded in the future to include information about the volume of density
  around the site.

  Parameters
  ----------
  scatter_env : mmtbx.ions.environment.ScatteringEnvironment
      An object containing information about the scattering environment at a
      site.
  b_iso : bool, optional
      Include the atom's refined isotropic b-factor, divided by the mean
      b-factor of solvent molecules in the structure.
  occ : bool, optional
      Include the atom's refined occupancy.
  diff_peak : bool, optional
      Include the difference map peak height.

  Returns
  -------
  numpy.array of float
      A vector containing quantitative properties for classification.
  """
  props = [
    scatter_env.fo_density[0],
    scatter_env.fo_density[1],
  ]
  if diff_peak:
    props.append(scatter_env.fofc_density[0])
  if b_iso:
    props.append(
      scatter_env.b_iso /
      (scatter_env.b_mean_hoh if scatter_env.b_mean_hoh != 0 else 15))
  if occ:
    props.append(scatter_env.occ)
  return np.array(props, dtype=float)

def ion_geometry_vector(chem_env, geometry_names=None):
  """
  Creates a vector for a site's geometry. For each geometry in geometry_names
  the vector contains a 1 if that geometry is present at the site and 0
  otherwise.

  A single boolean was chosen after some trial and error with an SVM as
  differences in deviations < 15 degrees were not found to be significant in
  helping to diffentiate ions.

  Parameters
  ----------
  chem_env : mmtbx.ions.environment.ChemicalEnvironment
      A object containing information about the chemical environment at a site.
  geometry_names : list of str, optional
      A list of geometry names to check for. If unset, take names from
      mmtbx.ions.SUPPORTED_GEOMETRY_NAMES.

  Returns
  -------
  numpy.array of float
      A vector containing quantitative properties for classification.
  """
  if geometry_names is None:
    geometry_names = SUPPORTED_GEOMETRY_NAMES

  present_geometry_names = [i[0] for i in chem_env.geometry]
  return np.fromiter((i in present_geometry_names for i in geometry_names),
                     dtype=float)

def ion_nearby_atoms_vector(chem_env, environments=None):
  """
  Creates a vector for the identities of the ions surrounding a site. Returns
  a vector with a count of coordinating nitrogens, oxygens, sulfurs, and
  chlorines.

  Parameters
  ----------
  chem_env : mmtbx.ions.environment.ChemicalEnvironment
      A object containing information about the chemical environment at a site.
  environments : list of int, optional
      A list of environments to check for. If unset, takes values from
      mmtbx.ions.environment.N_SUPPORTED_ENVIRONMENTS.

  Returns
  -------
  numpy.array of float
      A vector containing quantitative properties for classification.
  """

  if environments is None:
    environments = range(N_SUPPORTED_ENVIRONMENTS)

  return np.fromiter((chem_env.chemistry[i] for i in environments),
                     dtype=float)

def ion_valence_vector(chem_env, elements=None):
  """
  Calculate the BVS and VECSUM values for a variety of ion identities.

  Parameters
  ----------
  chem_env : mmtbx.ions.environment.ChemicalEnvironment
      A object containing information about the chemical environment at a site.
  elements : list of str, optional
      List of elements to include when calculating BVS and VECSUM values. If
      unset, takes the list from mmtbx.ions.ALLOWED_IONS.

  Returns
  -------
  numpy.array of float
      A vector containing quantitative properties for classification.
  """

  if elements is None:
    elements = [i for i in ALLOWED_IONS if i not in WATER_RES_NAMES]
  ret = []

  for element in elements:
    ret.append(chem_env.get_valence(
      element=element,
      charge=mmtbx.ions.server.get_charge(element)))

  # Flatten the list
  return _flatten_list(ret)

def ion_anomalous_vector(scatter_env, elements=None, ratios=True,
                         anom_peak=False):
  """
  Creates a vector of the anomalous features of a site. These can either include
  the f'' / f''_expected for a variety of ion identities or the exact anomalous
  peak height.

  Parameters
  ----------
  scatter_env : mmtbx.ions.environment.ScatteringEnvironment
      An object containing information about the scattering environment at a
      site.
  elements : list of str, optional
      List of elements to include when calculating f''_expected values. If
      unset, takes the list from mmtbx.ions.ALLOWED_IONS.
  ratios : bool, optional
      If False, instead of calculating ratios, just return a vector of the
      wavelength, f', and f''.
  anom_peak : bool, optional
      Whether to use the actual height of the anomalous map instead of the
      calculated f'' values.

  Returns
  -------
  numpy.array of float
      A vector containing quantitative properties for classification.
  """

  if elements is None:
    elements = [i for i in ALLOWED_IONS if i not in WATER_RES_NAMES]

  if scatter_env.fpp is None or scatter_env.wavelength is None:
    if ratios:
      return np.zeros(len(elements))
    else:
      return np.zeros(1)

  if anom_peak:
    height = scatter_env.anom_density[0]
  else:
    height = scatter_env.fpp

  if ratios:
    ret = np.fromiter((
      height / sasaki.table(element).at_angstrom(scatter_env.wavelength).fdp()
      for element in elements), float)
  else:
    ret = _flatten_list([height,])
  return ret

def predict_ion(chem_env, scatter_env, elements=None, svm_name=None):
  """
  Uses the trained classifier to predict the ions that most likely fit a given
  list of features about the site.

  Parameters
  ----------
  chem_env : mmtbx.ions.environment.ChemicalEnvironment
      A object containing information about the chemical environment at a site.
  scatter_env : mmtbx.ions.environment.ScatteringEnvironment, optional
      An object containing information about the scattering environment at a
      site.
  elements : list of str, optional
      A list of elements to include within the prediction. Must be a subset of
      mmtbx.ions.svm.ALLOWED_IONS. Note: Water is not added to elements by
      default.
  svm_name : str, optional
      The SVM to use for prediction. By default, the SVM trained on heavy atoms
      and calcium in the presence of anomalous data is used

  Returns
  -------
  list of tuple of str, float or None
      A sorted list of classes and the predicted probabilities associated with
      each or None if the trained classifier cannot be loaded.
  """

  # Load the classifier and the parameters used to interact with it
  classifier, vector_options, scaling, features = _get_classifier(svm_name)

  if classifier is None or vector_options is None:
    return None

  # Convert our data into a format that libsvm will accept
  vector = ion_vector(chem_env, scatter_env, **vector_options)
  vector = utils.scale_to([vector], scaling[0], scaling[1])[0]

  assert len(vector) == len(features)

  vector = vector[features]

  xi = svm.gen_svm_nodearray(
    list(vector), isKernel=classifier.param.kernel_type == svm.PRECOMPUTED,
    )[0]

  nr_class = classifier.get_nr_class()
  # prob_estimates isn't actually read by svm_predict_probability, it is only
  # written to with the final estimates. We just need to allocate space for it.
  prob_estimates = (c_double * nr_class)()
  svm.libsvm.svm_predict_probability(classifier, xi, prob_estimates)
  probs = prob_estimates[:nr_class]
  labels = [ALLOWED_IONS[i] for i in classifier.get_labels()]

  lst = list(zip(labels, probs))
  lst.sort(key=lambda x: -x[-1])

  if elements is not None:
    for element in elements:
      if element not in ALLOWED_IONS:
        raise Sorry("Unsupported element '{}'".format(element))

    # Filter out elements the caller does not care about
    classes, probs = [], []
    for element, prob in lst:
      if element in elements:
        classes.append(element)
        probs.append(prob)

    # Re-normalize the probabilities
    total = sum(probs)
    probs = [i / total for i in probs]
    lst = list(zip(classes, probs))

  return lst

def _flatten_list(lst):
  """
  Turn a tree main out of lists into one flat numpy array. Converts all Nones
  into zeros and integers into floats in the process.

  Parameters
  ----------
  lst : list or  list of list or list of list of list or ...
      A list to be flattened

  Returns
  -------
  numpy.array of float
      A flat list of values.
  """

  def _flatten(lst):
    """
    Returns a generator for each element in the flattened version of lst.
    """

    for item in lst:
      if isinstance(item, Iterable) and not isinstance(item, string_types):
        for sub in _flatten(item):
          yield sub
      else:
        yield item

  return np.fromiter(
    (float(i) if i is not None else 0. for i in _flatten(lst)),
    dtype=float
    )

# Adapters for main identification/building routines
svm_phil_str = """
svm
  .expert_level = 3
{
  svm_name = *Auto heavy merged_high_res
    .type = choice
    .help = "Name of SVM classifier to use"
  filtered_outputs = True
    .type = bool
    .help = "Apply an filter to the outputs of the SVM, ensuring they are chemically sane"
  min_score = 0.2
    .type = float
  min_score_above = 0.1
    .type = float
  min_fraction_of_next = 2.0
    .type = float
}
"""

class svm_prediction(slots_getstate_setstate_default_initializer):
  """
  Contains information about a SVM's prediction of a site's identity.

  Attributes
  ----------
  i_seq : int
  pdb_id_str : str
  atom_info_str : str
  map_stats : group_args
  atom_types : list of str
  scores : list of float
      Probabilities associated with each element listed by atom_types.
  final_choice : mmtbx.ions.metal_parameters
  """
  __slots__ = ["i_seq", "pdb_id_str", "atom_info_str", "map_stats",
               "atom_types", "scores", "final_choice"]

  def show(self, out=sys.stdout, prefix=""):
    """
    Shows information about a SVM's prediction of a site's identity.

    Parameters
    ----------
    out : file, optional
    prefix : str, optional
    """
    for line in self.atom_info_str.splitlines():
      print(prefix+line.rstrip(), file=out)
    print(prefix+"SVM scores:", file=out)
    scores = sorted(zip(self.atom_types, self.scores), key=lambda x: -x[1])
    for elem, score in scores:
      print(prefix+"  %4s : %.3f" % (elem, score), file=out)
    if (self.final_choice is not None):
      print(prefix+"Final choice: %s" % self.final_choice, file=out)

  def show_brief(self, out=sys.stdout, prefix=""):
    """
    Shows a brief description of a SVM's prediction of a site's identity, for
    use in output as a table.

    Parameters
    ----------
    out : file, optional
    prefix : str, optional
    """
    final_choice = self.final_choice
    if (final_choice is None):
      final_choice = "----"
      best_score = "----"
    else :
      for atom_type, score in zip(self.atom_types, self.scores):
        if (atom_type == final_choice.element):
          best_score = "%5.3f" % score
          break
    print(prefix+"%s   %4s  %5s  %5.2f  %5.2f" % \
      (self.pdb_id_str, final_choice.element, best_score,
       self.map_stats.two_fofc, self.map_stats.fofc), file=out)

class manager(mmtbx.ions.identify.manager):
  def analyze_water(self, i_seq, debug=True, candidates=Auto,
      filter_outputs=True):
    """
    Analyzes a single water site using a SVM to decide whether to re-assign it
    as an ion.

    Parameters
    ----------
    i_seq : int
    debug : bool, optional
    candidates : list of str, optional

    Returns
    -------
    svm_prediction or None
    """
    atom_props = mmtbx.ions.identify.AtomProperties(i_seq, self)
    expected_atom_type = atom_props.get_atom_type(
      params=self.params.water)
    if (expected_atom_type == mmtbx.ions.identify.WATER_POOR):
      return None
    auto_candidates = candidates is Auto
    if auto_candidates:
      candidates = mmtbx.ions.DEFAULT_IONS
    elif isinstance(candidates, string_types):
      candidates = candidates.replace(",", " ").split()
    candidates = [i.strip().upper() for i in candidates]
    if (candidates == ['X']) : # XXX hack for testing - X is "dummy" element
      candidates = []
    if auto_candidates:
      candidates = None
    else:
      candidates.append("HOH")
    from mmtbx.ions.environment import ScatteringEnvironment, \
      ChemicalEnvironment
    chem_env = ChemicalEnvironment(
      i_seq,
      atom_props.nearby_atoms,
      self)
    scatter_env = ScatteringEnvironment(
      i_seq=i_seq,
      manager=self,
      fo_density=self.get_map_gaussian_fit("mFo", i_seq),
      fofc_density=self.get_map_gaussian_fit("mFo-DFc", i_seq),
      anom_density=self.get_map_gaussian_fit("anom", i_seq))
    predictions = predict_ion(
      chem_env, scatter_env,
      elements=candidates,
      svm_name=self.params.svm.svm_name)
    if (predictions is not None) and filter_outputs :
      predictions = utils.filter_svm_outputs(
        chem_env=chem_env,
        scatter_env=scatter_env,
        predictions=predictions)
    if (predictions is not None) and (len(predictions) > 0):
      final_choice = None
      predictions.sort(key=lambda x: -x[1])
      best_guess, best_score = predictions[0]
      if (best_guess != "HOH"):
        if len(predictions) == 1:
          final_choice = mmtbx.ions.server.get_metal_parameters(best_guess)
        else:
          next_guess, next_score = predictions[1]
          if ((best_score >= self.params.svm.min_score) and
              (best_score>=(next_score*self.params.svm.min_fraction_of_next))):
            final_choice = mmtbx.ions.server.get_metal_parameters(best_guess)
      atom_info_out = StringIO()
      atom_props.show_properties(identity="HOH", out=atom_info_out)
      result = svm_prediction(
        i_seq=i_seq,
        pdb_id_str=self.pdb_atoms[i_seq].id_str(),
        atom_info_str=atom_info_out.getvalue(),
        map_stats=self.map_stats(i_seq),
        atom_types=[ pred[0] for pred in predictions ],
        scores=[ pred[1] for pred in predictions ],
        final_choice=final_choice)
      return result
    return None

  def analyze_waters(self, out=sys.stdout, debug=True, candidates=Auto):
    """
    Uses a SVM to analyze all of a model's water sites and decide whether to
    re-assign them as ions.

    Parameters
    ----------
    out : file, optional
    debug : bool, optional
    candidates : list of str, optional

    Returns
    -------
    list of svm_prediction
    """
    waters = self._extract_waters()
    print("  %d waters to analyze" % len(waters), file=out)
    print("", file=out)
    if (len(waters) == 0) : return
    #nproc = easy_mp.get_processes(self.nproc)
    predictions = []
    for i_seq in waters :
      prediction = self.analyze_water(
        i_seq=i_seq,
        debug=debug,
        candidates=candidates,
        filter_outputs=self.params.svm.filtered_outputs)
      if (prediction is not None):
        predictions.append(prediction)
    filtered = []
    for result in predictions :
      if (debug):
        result.show(out=out, prefix="  ")
        print("", file=out)
      if (result.final_choice is not None):
        filtered.append(result)
    if (len(filtered) == 0):
      print("", file=out)
      print("  No waters could be classified as possible ions.", file=out)
    else :
      make_sub_header("Predicted ions", out=out)
      for result in filtered :
        result.show_brief(out=out, prefix="  ")
    return filtered


 *******************************************************************************


 *******************************************************************************
mmtbx/ions/svm/dump_sites.py
# -*- coding: utf-8; py-indent-offset: 2 -*-
"""
A script to open a model and its data and dump out all information about its
ions sites to a pickle file.

Run this module with:

phenix.python -m mmtbx.ions.svm.dump_sites [args]
"""

from __future__ import absolute_import, division, print_function

import os
import sys

from libtbx import easy_pickle
from libtbx.str_utils import make_header
from mmtbx import ions
from mmtbx.ions.environment import ChemicalEnvironment, ScatteringEnvironment
from mmtbx.ions.identify import WATER_RES_NAMES
from mmtbx.ions.svm.utils import iterate_sites
from mmtbx.command_line import load_model_and_data

def master_phil():
  from mmtbx.command_line import generate_master_phil_with_inputs
  return generate_master_phil_with_inputs(
    enable_automatic_twin_detection=True,
    enable_pdb_interpretation_params=True,
    enable_stop_for_unknowns=False,
    phil_string="""
include scope mmtbx.ions.identify.ion_master_phil
include scope mmtbx.ions.svm.svm_phil_str
debug = True
  .type = bool
elements = Auto
  .type = str
use_svm = False
  .type = bool
nproc = Auto
  .type = int
""")

def _main(args, out=sys.stdout):
  """
  Main entry point to this script.

  Parameters
  ----------
  args : list of str
      List of arguments, should not include the first argument with the
      executable name.
  out : file, optional
  """
  usage_string = """\
phenix.python -m mmtbx.ions.svm.dump_sites model.pdb data.mtz [options ...]

Utility to dump information about the properties of water and ion sites in a
model. This properties include local environment, electron density maps, and
atomic properties.
"""
  cmdline = load_model_and_data(
    args=args,
    master_phil=master_phil(),
    out=out,
    process_pdb_file=True,
    create_fmodel=True,
    prefer_anomalous=True,
    set_wavelength_from_model_header=True,
    set_inelastic_form_factors="sasaki",
    usage_string=usage_string,
    )

  params = cmdline.params
  params.use_svm = True

  make_header("Inspecting sites", out=out)

  manager = ions.identify.create_manager(
    pdb_hierarchy=cmdline.pdb_hierarchy,
    fmodel=cmdline.fmodel,
    geometry_restraints_manager=cmdline.geometry,
    wavelength=params.input.wavelength,
    params=params,
    verbose=params.debug,
    nproc=params.nproc,
    log=out,
    )

  manager.show_current_scattering_statistics(out=out)

  sites = dump_sites(manager)

  out_name = os.path.splitext(params.input.pdb.file_name[0])[0] + "_sites.pkl"
  print("Dumping to", out_name, file=out)
  easy_pickle.dump(out_name, sites)

def dump_sites(manager):
  """
  Iterate over all the ions and waters built into the model and dump out
  information about their properties.

  Parameters
  ----------
  manager : mmtbx.ions.identify.manager

  Returns
  -------
  list of tuple of mmtbx.ions.environment.ChemicalEnvironment, \
  mmtbx.ions.environment.ScatteringEnvironment
  """

  atoms = iterate_sites(
    manager.pdb_hierarchy,
    res_filter=ions.SUPPORTED + WATER_RES_NAMES,
    split_sites=True,
    )

  # Can't pickle entire AtomProperties because they include references to the
  # Atom object. Instead, gather what properties we want and store them in a
  # second list
  properties = []
  for atom in atoms:
    map_stats = manager.map_stats(atom.i_seq)
    fo_density = manager.get_map_gaussian_fit("mFo", atom.i_seq)
    chem_env = ChemicalEnvironment(
      atom.i_seq,
      manager.find_nearby_atoms(atom.i_seq, far_distance_cutoff=3.5),
      manager,
      )
    scatter_env = ScatteringEnvironment(
      atom.i_seq,
      manager,
      fo_density=fo_density,
      fofc_density=(map_stats.fofc, 0),
      anom_density=(map_stats.anom, 0),
      )
    properties.append((chem_env, scatter_env))

  return properties

if __name__ == "__main__":
  _main(sys.argv[1:])


 *******************************************************************************


 *******************************************************************************
mmtbx/ions/svm/tst_classifier_01.py
 # -*- coding: utf-8; py-indent-offset: 2 -*-

from __future__ import absolute_import, division, print_function
from mmtbx.ions.svm.dump_sites import master_phil
from mmtbx.ions.environment import ChemicalEnvironment, ScatteringEnvironment
from mmtbx import ions
from mmtbx.ions.identify import WATER_RES_NAMES, AtomProperties
from mmtbx.ions.svm import ion_class, predict_ion
from mmtbx.regression.make_fake_anomalous_data import generate_calcium_inputs
import mmtbx.command_line
import libtbx.load_env
import warnings
import os
import sys
import time

def exercise(prefix="ions_svm_classifier_01"):
  wavelength = 1.025
  mtz_file, pdb_file = generate_calcium_inputs(
      file_base=prefix,
      anonymize = True)
  null_out = libtbx.utils.null_out()

  cmdline = mmtbx.command_line.load_model_and_data(
    args = [pdb_file, mtz_file, "wavelength={}".format(wavelength),
            "use_phaser=True", "use_svm=True"],
    master_phil = master_phil(),
    out = null_out,
    process_pdb_file = True,
    create_fmodel = True,
    prefer_anomalous = True,
    set_inelastic_form_factors = "sasaki",
    )

  os.remove(pdb_file)
  os.remove(mtz_file)
  os.remove(os.path.splitext(mtz_file)[0] + "_fmodel.eff")
  os.remove(os.path.splitext(mtz_file)[0] + ".pdb")

  manager = ions.identify.create_manager(
    pdb_hierarchy = cmdline.pdb_hierarchy,
    fmodel = cmdline.fmodel,
    geometry_restraints_manager = cmdline.geometry,
    wavelength = cmdline.params.input.wavelength,
    params = cmdline.params,
    nproc = cmdline.params.nproc,
    log = null_out,
    manager_class = ions.svm.manager,
    )

  # Build a list of properties of each water / ion site
  waters = []
  for chain in manager.pdb_hierarchy.only_model().chains():
    for residue_group in chain.residue_groups():
      atom_groups = residue_group.atom_groups()
      if (len(atom_groups) > 1) : # alt conf, skip
        continue
      for atom_group in atom_groups :
        # Check for non standard atoms in the residue
        # Or a label indicating the residue is a water
        resname = atom_group.resname.strip().upper()

        if (resname in WATER_RES_NAMES):
          atoms = atom_group.atoms()
          if (len(atoms) == 1) : # otherwise it probably has hydrogens, skip
            waters.append(atoms[0].i_seq)

  assert len(waters) > 0

  atom_props = [AtomProperties(i_seq, manager) for i_seq in waters]

  for atom_prop in atom_props:
    i_seq = atom_prop.i_seq
    chem_env = ChemicalEnvironment(
      i_seq,
      manager.find_nearby_atoms(i_seq, far_distance_cutoff = 3.5),
      manager,
      )
    scatter_env = ScatteringEnvironment(
      i_seq, manager,
      fo_density = manager.get_map_gaussian_fit("mFo", i_seq),
      fofc_density = manager.get_map_gaussian_fit("mFo-DFc", i_seq),
      anom_density = manager.get_map_gaussian_fit("anom", i_seq),
      )
    resname = ion_class(chem_env)
    assert resname != ""

    predictions = predict_ion(chem_env, scatter_env,
                              elements = ["HOH", "ZN", "CA"])
    if predictions is None:
      print("Could not load SVM classifier")
      print("Skipping {}".format(os.path.split(__file__)[1]))
      return

    if resname != predictions[0][0]:
      print("Prediction ({}) did not match expected: {}" \
        .format(predictions[0][0], resname))
      for element, prob in predictions:
        print("  {}: {:.2f}".format(element, prob))
      sys.exit()

  print("OK")

if __name__ == "__main__":
  if (not libtbx.env.find_in_repositories("chem_data")):
    warnings.warn("chem_data not available, skipping this test")
  else :
    try :
      import svm
    except ImportError :
      warnings.warn("libsvm not available, skipping this test")
    else :
      t0 = time.time()
      exercise()
      print("Time: %6.2f"%(time.time()-t0))
      print("OK")


 *******************************************************************************


 *******************************************************************************
mmtbx/ions/svm/tst_classifier_02.py
 # -*- coding: utf-8; py-indent-offset: 2 -*-

from __future__ import absolute_import, division, print_function
from mmtbx.ions.svm.dump_sites import master_phil
from mmtbx.ions.environment import ChemicalEnvironment, ScatteringEnvironment
from mmtbx import ions
from mmtbx.ions.identify import WATER_RES_NAMES, AtomProperties
from mmtbx.ions.svm import ion_class, predict_ion
from mmtbx.regression.make_fake_anomalous_data import generate_zinc_inputs
import mmtbx.command_line
import libtbx.load_env
import warnings
import os
import sys
import time

def exercise(prefix="tst_classifier_02"):
  wavelength = 1.54
  mtz_file, pdb_file = generate_zinc_inputs(
      file_base=prefix,
      anonymize = True)
  null_out = libtbx.utils.null_out()

  cmdline = mmtbx.command_line.load_model_and_data(
    args = [pdb_file, mtz_file, "wavelength={}".format(wavelength),
            "use_phaser=True", "use_svm=True"],
    master_phil = master_phil(),
    out = null_out,
    process_pdb_file = True,
    create_fmodel = True,
    prefer_anomalous = True,
    set_inelastic_form_factors = "sasaki",
    )

  os.remove(pdb_file)
  os.remove(mtz_file)
  os.remove(os.path.splitext(mtz_file)[0] + "_fmodel.eff")
  os.remove(os.path.splitext(mtz_file)[0] + ".pdb")

  manager = ions.identify.create_manager(
    pdb_hierarchy = cmdline.pdb_hierarchy,
    fmodel = cmdline.fmodel,
    geometry_restraints_manager = cmdline.geometry,
    wavelength = cmdline.params.input.wavelength,
    params = cmdline.params,
    nproc = cmdline.params.nproc,
    log = null_out,
    manager_class = ions.svm.manager,
    )

  # Build a list of properties of each water / ion site
  waters = []
  for chain in manager.pdb_hierarchy.only_model().chains():
    for residue_group in chain.residue_groups():
      atom_groups = residue_group.atom_groups()
      if (len(atom_groups) > 1) : # alt conf, skip
        continue
      for atom_group in atom_groups :
        # Check for non standard atoms in the residue
        # Or a label indicating the residue is a water
        resname = atom_group.resname.strip().upper()

        if (resname in WATER_RES_NAMES):
          atoms = atom_group.atoms()
          if (len(atoms) == 1) : # otherwise it probably has hydrogens, skip
            waters.append(atoms[0].i_seq)

  assert len(waters) > 0

  atom_props = [AtomProperties(i_seq, manager) for i_seq in waters]

  for atom_prop in atom_props:
    i_seq = atom_prop.i_seq
    chem_env = ChemicalEnvironment(
      i_seq,
      manager.find_nearby_atoms(i_seq, far_distance_cutoff = 3.5),
      manager,
      )
    scatter_env = ScatteringEnvironment(
      i_seq, manager,
      fo_density = manager.get_map_gaussian_fit("mFo", i_seq),
      fofc_density = manager.get_map_gaussian_fit("mFo-DFc", i_seq),
      anom_density = manager.get_map_gaussian_fit("anom", i_seq),
      )
    resname = ion_class(chem_env)
    assert resname != ""

    predictions = predict_ion(chem_env, scatter_env,
                              elements = ["HOH", "ZN", "CA"])
    if predictions is None:
      print("Could not load SVM classifier")
      print("Skipping {}".format(os.path.split(__file__)[1]))
      return

    if resname != predictions[0][0]:
      print("Prediction ({}) did not match expected: {}" \
        .format(predictions[0][0], resname))
      for element, prob in predictions:
        print("  {}: {:.2f}".format(element, prob))
      sys.exit()

  print("OK")

if __name__ == "__main__":
  if (not libtbx.env.find_in_repositories("chem_data")):
    warnings.warn("chem_data not available, skipping this test")
  else :
    try :
      import svm
    except ImportError :
      warnings.warn("libsvm not available, skipping this test")
    else :
      t0 = time.time()
      exercise()
      print("Time: %6.2f"%(time.time()-t0))
      print("OK")


 *******************************************************************************


 *******************************************************************************
mmtbx/ions/svm/utils.py
# -*- coding: utf-8; py-indent-offset: 2 -*-
"""
Utility functions used within this module.
"""
from __future__ import absolute_import, division, print_function

try : # XXX required third-party dependencies
  import numpy as np
except ImportError :
  np = None

from libtbx import Auto
from mmtbx.ions import server
from mmtbx.ions import halides
from scitbx.matrix import col

def iterate_sites(pdb_hierarchy, split_sites=False, res_filter=None):
  """
  Returns a generator iterating over all atoms in pdb_hierarchy. Optionally
  skips sites with alternate conformations and can filter by residue name.

  Parameters
  ----------
  pdb_hierarchy: iotbx.pdb.hierarchy.root
  split_sites: bool, optional
      Indicates whether to iterate over sites with alternate conformations, by
      default they are not included.
  res_filter: list of str, optional
      List of residue names to include, by default, all residues are examined.

  Returns
  -------
  generator of iotbx.pdb.hierarchy.atom
  """

  for model in pdb_hierarchy.models():
    for chain in model.chains():
      for residue_group in chain.residue_groups():
        for atom_group in residue_group.atom_groups():
          resname = atom_group.resname.strip().upper()
          if atom_group.altloc.strip() != "" and not split_sites:
            continue
          if res_filter is None or resname in res_filter:
            atoms = atom_group.atoms()
            if len(atoms) == 1:
              atom = atoms[0]
              element = atom.element.strip().upper()
              if element in ["H", "D"]:
                continue
              yield atom

def _is_favorable_halide_environment(
    chem_env, scatter_env, assume_hydrogens_all_missing=Auto,
    ):
  assume_hydrogens_all_missing = True
  atom = chem_env.atom
  binds_amide_hydrogen = False
  near_cation = False
  near_lys = False
  near_hydroxyl = False
  xyz = col(atom.xyz)
  min_distance_to_cation = None
  min_distance_to_hydroxyl = min_distance_to_cation
  for contact in chem_env.contacts:
    other = contact.atom
    resname = contact.resname()
    atom_name = contact.atom_name()
    element = contact.element
    distance = abs(contact)
    # XXX need to figure out exactly what this should be - CL has a
    # fairly large radius though (1.67A according to ener_lib.cif)
    if distance < 2.5:
      return False
    if not element in ["C", "N", "H", "O", "S"]:
      charge = server.get_charge(element)
      if charge < 0 and distance <= 3.5:
        # Nearby anion that is too close
        return False
      if charge > 0 and distance <= 3.5:
        # Nearby cation
        near_cation = True
        if min_distance_to_cation is None or \
          distance < min_distance_to_cation:
          min_distance_to_cation = distance
    # Lysine sidechains (can't determine planarity)
    elif (atom_name in ["NZ"] and #, "NE", "NH1", "NH2"] and
          resname in ["LYS"] and
          distance <= 3.5):
      near_lys = True
      if min_distance_to_cation is None or \
        distance < min_distance_to_cation:
        min_distance_to_cation = distance
    # sidechain amide groups, no hydrogens (except Arg)
    # XXX this would be more reliable if we also calculate the expected
    # hydrogen positions and use the vector method below
    elif (atom_name in ["NZ", "NH1", "NH2", "ND2", "NE2"] and
          resname in ["ARG", "ASN", "GLN"] and
          (assume_hydrogens_all_missing or resname == "ARG") and
          distance <= 3.5):
      binds_amide_hydrogen = True
      if resname == "ARG" and (
          min_distance_to_cation is None or
          distance < min_distance_to_cation):
        min_distance_to_cation = distance
    # hydroxyl groups - note that the orientation of the hydrogen is usually
    # arbitrary and we can't determine precise bonding
    elif ((atom_name in ["OG1", "OG2", "OH1"]) and
          (resname in ["SER", "THR", "TYR"]) and
          (distance <= 3.5)):
      near_hydroxyl = True
      if distance < min_distance_to_hydroxyl:
        min_distance_to_hydroxyl = distance
    # Backbone amide, implicit H
    elif atom_name in ["N"] and assume_hydrogens_all_missing:
      binds_amide_hydrogen = True
      # xyz_n = col(contact.site_cart)
      # bonded_atoms = connectivity[j_seq]
      # ca_same = c_prev = None
      # for k_seq in bonded_atoms:
      #   other2 = pdb_atoms[k_seq]
      #   if other2.name.strip().upper() in ["CA"]:
      #     ca_same = col(get_site(k_seq))
      #   elif other2.name.strip().upper() in ["C"]:
      #     c_prev = col(get_site(k_seq))
      # if ca_same is not None and c_prev is not None:
      #   xyz_cca = (ca_same + c_prev) / 2
      #   vec_ncca = xyz_n - xyz_cca
      #   # 0.86 is the backbone N-H bond distance in geostd
      #   xyz_h = xyz_n + (vec_ncca.normalize() * 0.86)
      #   vec_nh = xyz_n - xyz_h
      #   vec_nx = xyz_n - xyz
      #   angle = abs(vec_nh.angle(vec_nx, deg=True))
      #   if abs(angle - 180) <= 20:
      #     binds_amide_hydrogen = True
  # now check again for negatively charged sidechain (etc.) atoms (e.g.
  # carboxyl groups), but with some leeway if a cation is also nearby.
  # backbone carbonyl atoms are also excluded.
  for contact in chem_env.contacts:
    if contact.altloc() not in ["", "A"]:
      continue
    resname = contact.resname()
    atom_name = contact.atom_name()
    distance = abs(contact)
    if ((distance < 3.2) and
        (min_distance_to_cation is not None and
         distance < (min_distance_to_cation + 0.2)) and
        halides.is_negatively_charged_oxygen(atom_name, resname)):
      return False
  return binds_amide_hydrogen or near_cation or near_lys

def filter_svm_outputs(chem_env, scatter_env, predictions):
  """
  Applies a simple set of filters to the accepted ions that might match a given
  chemical and scattering environment to help catch corner cases where the SVM
  might fail.

  Parameters
  ----------
  chem_env : mmtbx.ions.environment.ChemicalEnvironment
  scatter_env : mmtbx.ions.environment.ScatteringEnvironment
  elements : list of str

  Returns
  -------
  list of str
  """
  bvs_ratio = 0.5
  vecsum_cutoff = 0.6
  ok_elements = []
  for element, score in predictions:
    if element != "HOH":
      if scatter_env.fo_density[0] < 1:
        continue
      if element not in ["NA", "MG"]:
        if scatter_env.fofc_density[0] < 0:
          continue
      bvs, vecsum = chem_env.get_valence(element)
      # bvs <= 0.5 * lower or bvs >= 1.5 * upper
      if element not in ["F", "CL", "BR", "I"]:
        # Require cations have okay BVS values
        charges = server.get_charges(element)
        if bvs <= (1 - bvs_ratio) * min(charges):
          continue
        if bvs >= (1 + bvs_ratio) * max(charges):
          continue
      else:
        # Require halides be touching at least one atom with a positive charge
        if not _is_favorable_halide_environment(chem_env, scatter_env):
          continue
        # if len(chem_env.contacts) == 0 or \
        #   not any(server.get_charge(i.atom) > 0 for i in chem_env.contacts):
        #   print [(i.atom.id_str(), server.get_charge(i.atom)) for i in chem_env.contacts]
        #   continue
      if vecsum > vecsum_cutoff:
        continue
      if any(abs(i.vector) < 1.8 for i in chem_env.contacts):
        continue
    ok_elements.append((element, score))
  return ok_elements

def scale_to(matrix, source, target):
  """
  Given an upper and lower bound for each row of matrix, scales the values to be
  within the range specified by target.

  Parameters
  ----------
  matrix : numpy.array of float
      The matrix to be scaled.
  source : tuple of numpy.array of float
      The upper and lower bound on the values of each row in the original
      matrix.
  target : tuple of float
      The target range to scale to.

  Returns
  -------
  matrix : numpy.array of float
      The matrix with scaled values.

  Examples
  --------
  >>> from mmtbx.ions.svm.utils import scale_to
  >>> import numpy as np
  >>> matrix = np.array([[0, 1, 2],
                         [2, 3, 4],
                         [1, 2, 3]])
  >>> source = (np.array([2, 3, 4]),
                np.array([0, 1, 2]))
  >>> target = (0, 1)
  >>> scale_to(matrix, source, target)
  array([[ 1. ,  1. ,  1. ],
         [ 0. ,  0. ,  0. ],
         [ 0.5,  0.5,  0.5]])
  """
  matrix = np.array(matrix)
  keep_rows = source[0] != source[1]
  matrix = matrix[:, keep_rows]
  source = (source[0][keep_rows], source[1][keep_rows])
  return (matrix - source[0]) * (target[1] - target[0]) / \
    (source[1] - source[0]) + target[0]


 *******************************************************************************


 *******************************************************************************
mmtbx/ions/tst_environment.py
 # -*- coding: utf-8; py-indent-offset: 2 -*-

from __future__ import absolute_import, division, print_function
from mmtbx.ions.environment import ChemicalEnvironment
import mmtbx.ions.identify
from mmtbx import ions
import mmtbx.monomer_library.pdb_interpretation
from mmtbx import monomer_library
from mmtbx.ions.environment import chem_carboxy, chem_amide, chem_backbone, \
     chem_water, chem_phosphate, \
     chem_nitrogen_primary, chem_nitrogen_secondary, \
     chem_chloride, chem_oxygen, chem_nitrogen, chem_sulfur
import libtbx.load_env
from collections import OrderedDict, Counter
import os
import sys
from six.moves import zip
from six.moves import range


def exercise():
  if not libtbx.env.has_module("phenix_regression"):
    print("Skipping {}".format(os.path.split(__file__)[1]))
    return

  models = OrderedDict([
    ("2qng", [
      Counter({chem_oxygen: 7, chem_carboxy: 2, chem_water: 2,
               chem_backbone: 3}),
      Counter({chem_oxygen: 6, chem_carboxy: 3, chem_water: 1,
               chem_backbone: 2}),
      ]),
    ("3rva", [
      Counter({chem_oxygen: 6, chem_carboxy: 4, chem_water: 2}),
      Counter({chem_nitrogen: 1, chem_oxygen: 4, chem_nitrogen_secondary: 1,
               chem_carboxy: 3, chem_water: 1}),
      Counter({chem_nitrogen: 4, chem_nitrogen_primary: 1,
               chem_nitrogen_secondary: 3, chem_backbone: 3}),
      ]),
    ("1mjh", [
      Counter({chem_oxygen: 6, chem_water: 3, chem_phosphate: 3}),
      Counter({chem_oxygen: 6, chem_water: 3, chem_phosphate: 3}),
      ]),
    ("4e1h", [
      Counter({chem_oxygen: 6, chem_carboxy: 4}),
      Counter({chem_oxygen: 6, chem_carboxy: 3}),
      Counter({chem_oxygen: 6, chem_carboxy: 3}),
      ]),
    ("2xuz", [
      Counter({chem_oxygen: 6}),
      ]),
    ("3zli", [
      Counter({chem_nitrogen: 2, chem_oxygen: 4, chem_nitrogen_secondary: 2,
               chem_carboxy: 1, chem_water: 1}),
      Counter({chem_sulfur: 4}),
      Counter({chem_nitrogen: 2, chem_oxygen: 4, chem_nitrogen_secondary: 2,
               chem_carboxy: 1, chem_water: 1}),
      Counter({chem_sulfur: 4}),
      ]),
    ("3e0f", [
      Counter({chem_nitrogen: 2, chem_oxygen: 4, chem_nitrogen_secondary: 2,
               chem_carboxy: 2, chem_phosphate: 2}),
      Counter({chem_nitrogen: 2, chem_oxygen: 2, chem_nitrogen_secondary: 2,
               chem_carboxy: 1, chem_phosphate: 1}),
      Counter({chem_nitrogen: 2, chem_oxygen: 3, chem_nitrogen_secondary: 2,
               chem_carboxy: 2, chem_phosphate: 1}),
      ]),
    ("3dkq", [
      Counter({chem_nitrogen: 4, chem_oxygen: 1, chem_nitrogen_secondary: 4,
               chem_carboxy: 1}),
      Counter({chem_nitrogen: 2, chem_oxygen: 1, chem_nitrogen_secondary: 2,
               chem_carboxy: 1}),
      Counter({chem_nitrogen: 4, chem_oxygen: 1, chem_nitrogen_secondary: 4,
               chem_carboxy: 1}),
      ]),
    ("2o8q", [
      Counter({chem_nitrogen: 3, chem_oxygen: 3, chem_nitrogen_secondary: 3,
               chem_water: 3}),
      Counter({chem_nitrogen: 3, chem_oxygen: 3, chem_nitrogen_secondary: 3,
               chem_water: 3}),
      ]),
    ("1tgg", [
      Counter({chem_oxygen: 5, chem_chloride: 1, chem_carboxy: 4,
               chem_water: 1}),
      Counter({chem_oxygen: 3, chem_chloride: 2, chem_carboxy: 3}),
      Counter({chem_oxygen: 4, chem_chloride: 2, chem_carboxy: 4}),
      ]),
    ("3zu8", [
      Counter({chem_oxygen: 7, chem_carboxy: 3, chem_water: 1,
                      chem_backbone: 2}),
      Counter({chem_nitrogen: 4, chem_oxygen: 1, chem_nitrogen_primary: 1,
               chem_nitrogen_secondary: 3, chem_carboxy: 1, chem_backbone: 3}),
      ]),
    ("1ofs", [
      Counter({chem_nitrogen: 1, chem_oxygen: 4, chem_nitrogen_secondary: 1,
               chem_carboxy: 3, chem_water: 1}),
      Counter({chem_oxygen: 7, chem_amide: 1, chem_carboxy: 3, chem_water: 2,
               chem_backbone: 1}),
      Counter({chem_nitrogen: 1, chem_oxygen: 5, chem_nitrogen_secondary: 1,
               chem_carboxy: 3, chem_water: 2}),
      Counter({chem_oxygen: 7, chem_amide: 1, chem_carboxy: 3, chem_water: 2,
               chem_backbone: 1}),
      ]),
    ("3ul2", [
      Counter({chem_oxygen: 7, chem_amide: 1, chem_carboxy: 3, chem_water: 2,
               chem_backbone: 1}),
      Counter({chem_nitrogen: 1, chem_oxygen: 5, chem_nitrogen_secondary: 1,
               chem_carboxy: 3, chem_water: 2}),
      Counter({chem_oxygen: 7, chem_amide: 1, chem_carboxy: 3, chem_backbone: 1,
               chem_water: 2}),
      Counter({chem_nitrogen: 1, chem_oxygen: 5, chem_nitrogen_secondary: 1,
               chem_carboxy: 3, chem_water: 2}),
      Counter({chem_oxygen: 7, chem_amide: 1, chem_carboxy: 3, chem_water: 2,
               chem_backbone: 1}),
      Counter({chem_nitrogen: 1, chem_oxygen: 5, chem_nitrogen_secondary: 1,
               chem_carboxy: 3, chem_water: 2}),
      Counter({chem_oxygen: 7, chem_amide: 1, chem_carboxy: 3, chem_water: 2,
               chem_backbone: 1}),
      Counter({chem_nitrogen: 1, chem_oxygen: 5, chem_nitrogen_secondary: 1,
               chem_carboxy: 3, chem_water: 2}),
      ]),
    ("3snm", [
      Counter({chem_oxygen: 5, chem_amide: 1, chem_carboxy: 3,
               chem_backbone: 1}),
      Counter({chem_nitrogen: 1, chem_oxygen: 3, chem_nitrogen_secondary: 1,
               chem_carboxy: 3}),
      ]),
    ("3qlq", [
      Counter({chem_oxygen: 7, chem_amide: 1, chem_carboxy: 3, chem_water: 2,
               chem_backbone: 1}),
      Counter({chem_nitrogen: 1, chem_oxygen: 5, chem_nitrogen_secondary: 1,
               chem_carboxy: 3, chem_water: 2}),
      Counter({chem_nitrogen: 1, chem_oxygen: 5, chem_nitrogen_secondary: 1,
               chem_carboxy: 3, chem_water: 2}),
      Counter({chem_oxygen: 7, chem_amide: 1, chem_carboxy: 3, chem_water: 2,
               chem_backbone: 1}),
      Counter({chem_nitrogen: 1, chem_oxygen: 5, chem_nitrogen_secondary: 1,
               chem_carboxy: 3, chem_water: 2}),
      Counter({chem_oxygen: 7, chem_amide: 1, chem_carboxy: 3, chem_water: 2,
               chem_backbone: 1}),
      Counter({chem_oxygen: 7, chem_amide: 1, chem_carboxy: 3, chem_water: 2,
               chem_backbone: 1}),
      Counter({chem_nitrogen: 1, chem_oxygen: 5, chem_nitrogen_secondary: 1,
               chem_carboxy: 3, chem_water: 2}),
      ]),
    ("2gdf", [
      Counter({chem_nitrogen: 1, chem_oxygen: 4, chem_nitrogen_secondary: 1,
               chem_carboxy: 3, chem_water: 1}),
      Counter({chem_oxygen: 6, chem_amide: 1, chem_carboxy: 3, chem_water: 1,
               chem_backbone: 1}),
      Counter({chem_nitrogen: 1, chem_oxygen: 4, chem_nitrogen_secondary: 1,
               chem_carboxy: 3, chem_water: 1}),
      Counter({chem_oxygen: 6, chem_amide: 1, chem_carboxy: 3, chem_water: 1,
               chem_backbone: 1}),
      ]),
    ("1q8h", [
      Counter({chem_oxygen: 7, chem_carboxy: 6, chem_water: 1}),
      Counter({chem_oxygen: 7, chem_carboxy: 4, chem_water: 3}),
      Counter({chem_oxygen: 8, chem_carboxy: 6, chem_water: 2}),
      ]),
  ])

  for model, expected_environments in models.items():
    pdb_path = libtbx.env.find_in_repositories(
      relative_path = os.path.join(
        "phenix_regression", "mmtbx", "ions", model + ".pdb"),
      test = os.path.isfile
      )

    mon_lib_srv = monomer_library.server.server()
    ener_lib = monomer_library.server.ener_lib()
    processed_pdb_file = monomer_library.pdb_interpretation.process(
      mon_lib_srv = mon_lib_srv,
      ener_lib = ener_lib,
      file_name = pdb_path,
      raw_records = None,
      force_symmetry = True,
      log = libtbx.utils.null_out()
      )

    geometry = \
      processed_pdb_file.geometry_restraints_manager(show_energies = False)
    xray_structure = processed_pdb_file.xray_structure()
    pdb_hierarchy = processed_pdb_file.all_chain_proxies.pdb_hierarchy
    connectivity = geometry.shell_sym_tables[0].full_simple_connectivity()

    manager = mmtbx.ions.identify.manager(
      fmodel = None,
      pdb_hierarchy = pdb_hierarchy,
      xray_structure = xray_structure,
      connectivity = connectivity)

    elements = set(ions.DEFAULT_IONS + ions.TRANSITION_METALS)
    elements.difference_update(["CL"])

    metals = [i_seq for i_seq, atom in enumerate(manager.pdb_atoms)
             if atom.fetch_labels().resname.strip().upper() in elements]
    assert len(metals) == len(expected_environments)

    for index, metal, expected_environment in \
      zip(range(len(metals)), metals, expected_environments):
      env = ChemicalEnvironment(
        metal,
        manager.find_nearby_atoms(metal, filter_by_two_fofc = False),
        manager
        )
      if env.chemistry != expected_environment:
        print("Problem detecting chemistry environment in", model, index)
        print("Found:    ", env.chemistry)
        print("Should be:", expected_environment)
        sys.exit()

  print("OK")

if __name__ == "__main__":
  exercise()


 *******************************************************************************


 *******************************************************************************
mmtbx/ions/tst_geometries.py
 # -*- coding: utf-8; py-indent-offset: 2 -*-
from __future__ import absolute_import, division, print_function
from mmtbx.ions.geometry import find_coordination_geometry
import mmtbx.ions.identify
from mmtbx import ions
import mmtbx.monomer_library.pdb_interpretation
from mmtbx import monomer_library
import libtbx.load_env
from collections import OrderedDict
import os
import sys
from six.moves import zip
from six.moves import range

def exercise():
  if not libtbx.env.has_module("phenix_regression"):
    print("Skipping {}".format(os.path.split(__file__)[1]))
    return

  models = OrderedDict([
    ("2qng", [["pentagonal_bipyramid"],
              ["octahedron"]]),
    ("3rva", [["square_pyramid_bidentate_miss"],
              ["trigonal_bipyramid"],
              ["square_plane"]]),
    ("1mjh", [["octahedron"],
              ["octahedron"]]),
    ("4e1h", [["octahedron"],
              ["octahedron"],
              ["octahedron"]]),
    ("2xuz", [["trigonal_prism"]]),
    ("3zli", [["octahedron"],
              ["tetrahedron"],
              ["octahedron"],
              ["tetrahedron"],]),
    ("3e0f", [["square_pyramid_bidentate_miss"],
              ["trigonal_pyramid"],
              ["square_pyramid"]]),
    ("3dkq", [["square_pyramid"],
              ["three_legs"],
              ["square_pyramid"]]),
    ("2o8q", [["octahedron"],
              ["octahedron"]]),
    ("1tgg", [["octahedron"],
              ["square_pyramid"],
              ["see_saw"]]),
    ("3zu8", [["pentagonal_bipyramid"],
              []]),
    ("1ofs", [["square_pyramid"],
              ["square_pyramid_bidentate"],
              ["octahedron"],
              ["square_pyramid_bidentate"]]),
    ("3ul2", [["square_pyramid_bidentate"],
              ["octahedron"],
              ["square_pyramid_bidentate"],
              ["octahedron"],
              ["square_pyramid_bidentate"],
              ["octahedron"],
              ["square_pyramid_bidentate"],
              ["octahedron"],]),
    ("3snm", [[],
              ["see_saw"]]),
    ("3qlq", [["square_pyramid_bidentate"],
              ["octahedron"],
              ["octahedron"],
              ["square_pyramid_bidentate"],
              ["octahedron"],
              ["square_pyramid_bidentate"],
              ["square_pyramid_bidentate"],
              ["octahedron"]]),
    ("2gdf", [["square_pyramid"],
              ["square_pyramid_bidentate_miss"],
              ["square_pyramid"],
              ["square_pyramid_bidentate_miss"]]),
    ("1q8h", [["trigonal_prism"],
              ["square_pyramid_bidentate"],
              ["square_pyramid_bidentate_miss"]]),
  ])

  for model, geometries in models.items():
    pdb_path = libtbx.env.find_in_repositories(
      relative_path = os.path.join(
        "phenix_regression", "mmtbx", "ions", model + ".pdb"),
        test = os.path.isfile
      )

    mon_lib_srv = monomer_library.server.server()
    ener_lib = monomer_library.server.ener_lib()
    processed_pdb_file = monomer_library.pdb_interpretation.process(
      mon_lib_srv = mon_lib_srv,
      ener_lib = ener_lib,
      file_name = pdb_path,
      raw_records = None,
      force_symmetry = True,
      log = libtbx.utils.null_out()
      )

    geometry = \
      processed_pdb_file.geometry_restraints_manager(show_energies = False)
    xray_structure = processed_pdb_file.xray_structure()
    pdb_hierarchy = processed_pdb_file.all_chain_proxies.pdb_hierarchy
    connectivity = geometry.shell_sym_tables[0].full_simple_connectivity()

    manager = mmtbx.ions.identify.manager(
      fmodel = None,
      pdb_hierarchy = pdb_hierarchy,
      xray_structure = xray_structure,
      connectivity = connectivity)

    elements = set(ions.DEFAULT_IONS + ions.TRANSITION_METALS)
    elements.difference_update(["CL"])

    metals = [i_seq for i_seq, atom in enumerate(manager.pdb_atoms)
             if atom.fetch_labels().resname.strip().upper() in elements]
    assert len(metals) == len(geometries)

    for index, metal, expected_geometry in \
      zip(range(len(metals)), metals, geometries):
      contacts = manager.find_nearby_atoms(metal, filter_by_two_fofc = False)
      found = find_coordination_geometry(contacts, minimizer_method = True)
      geometry_names = [i[0] for i in found]

      if geometry_names != expected_geometry:
        print("Problem detecting geometries in", model, index)
        print(manager.pdb_atoms[metal].id_str())
        print("Found geometries:", geometry_names)
        print("Should be:", expected_geometry)
        sys.exit()

  print("OK")

if __name__ == "__main__":
  exercise()


 *******************************************************************************


 *******************************************************************************
mmtbx/ions/tst_parameters.py
# -*- coding: utf-8; py-indent-offset: 2 -*-
from __future__ import absolute_import, division, print_function

def exercise():
  from mmtbx.ions import server as s
  import iotbx.pdb.hierarchy
  import iotbx.pdb
  from cctbx.eltbx import chemical_elements

  # Assert that valence parameters exist for all common ions with their
  # coordinating atoms
  for elem in ["NA", "MG", "K", "CA", "MN", "FE", "NI", "CO", "CU", "ZN", "CD"]:
    params = s.get_metal_parameters(elem)
    assert (len(params.allowed_coordinating_atoms) > 0)
    assert (params.charge is not None)
    for elem2 in params.allowed_coordinating_atoms :
      atom1 = iotbx.pdb.hierarchy.atom()
      atom1.name = elem
      atom1.element = elem
      atom1.charge = "+" + str(params.charge)
      atom2 = iotbx.pdb.hierarchy.atom()
      atom2.name = elem2
      atom2.element = elem2
      atom2.charge = "{:+}".format(s.get_charge(elem2))
      assert (s.get_valence_params(atom1, atom2) != (None, None))

  # Make sure we don't crash on any ion residue names
  for elem in chemical_elements.proper_upper_list():
    s.get_element(elem)
    s.get_charge(elem)

  # Make sure we don't crash on any common residue names either
  from mmtbx import monomer_library
  from mmtbx.rotamer.rotamer_eval import mon_lib_query
  mon_lib_srv = monomer_library.server.server()
  common_residues = [getattr(iotbx.pdb, i) for i in dir(iotbx.pdb)
                     if i.startswith("common_residue_names") and
                     isinstance(getattr(iotbx.pdb, i), list)]

  common_atoms = {
    "H": -1,
    "C": 4,
    "N": -3,
    "O": -2,
    "S": -2,
    }
  for common in common_residues:
    for resn in common:
      mlq = mon_lib_query(resn, mon_lib_srv)
      if mlq is None:
        continue
      for atom in mlq.atom_dict().values():
        elem, charge = s._get_charge_params(resname = resn,
                                            element = atom.type_symbol)
        from libtbx import group_args
        class GAtom(group_args):
          def fetch_labels(self):
            return group_args(resname = self.resname)
          def id_str(self):
            return "gatom=\"{} {}\"".format(self.resname, self.element)
          def charge_as_int(self):
            return int(self.charge)
        gatom = GAtom(
          element = atom.type_symbol,
          resname = resn,
          charge = "0",
          )
        get_charge_val, get_elem_val = s.get_charge(gatom), s.get_element(gatom)
        if elem in common_atoms:
          assert charge == common_atoms[elem]
        assert get_charge_val == charge
        assert get_elem_val == elem

  # And we support all waters
  for resn in iotbx.pdb.common_residue_names_water:
    assert s.get_element(resn) == "O"
    assert s.get_charge(resn) == -2

  print("OK")

if (__name__ == "__main__"):
  exercise()


 *******************************************************************************


 *******************************************************************************
mmtbx/ions/tst_pick_approx_zn.py

from __future__ import absolute_import, division, print_function
import os, time
from six.moves import cStringIO as StringIO
from mmtbx.ions.svm.dump_sites import master_phil
from mmtbx.ions.tst_symmetry_axis import get_analyze_waters_result
from iotbx.data_manager import DataManager

def exercise():
  from mmtbx.regression.make_fake_anomalous_data import generate_zinc_inputs
  base = "tst_pick_approx_zn"
  mtz_file, pdb_file = generate_zinc_inputs(file_base=base, anonymize = True)
  time.sleep(2)

  dm = DataManager()
  m = dm.get_model(pdb_file)
  dm.process_miller_array_file(mtz_file)
  fmo = dm.get_fmodel(scattering_table="n_gaussian")
  xrs = m.get_xray_structure()
  xrs.set_inelastic_form_factors(photon = 1.54, table = "sasaki")
  fmo.update_xray_structure(xrs, update_f_calc = True)
  params = master_phil().extract()
  params.input.wavelength = 1.54
  params.use_phaser=False
  params.elements='CA,ZN'
  params.nproc=1
  out = StringIO()
  result = get_analyze_waters_result(m,fmo,params,out)

  n_zn = 0
  for line in out.getvalue().splitlines():
    if "Probable cation: ZN+2" in line:
      n_zn += 1
  if n_zn != 1:
    print(out.getvalue().splitlines())
    raise RuntimeError("Expected 1 ZN+2, found %d" % n_zn)
  os.remove(pdb_file)
  os.remove(mtz_file)
  # "zn_frag_hoh.pdb" => "zn_frag_fmodel.eff"
  os.remove(os.path.splitext(pdb_file)[0][:-4] + ".pdb")
  os.remove(os.path.splitext(pdb_file)[0][:-4] + "_fmodel.eff")
  print("OK")

if (__name__ == "__main__"):
  exercise()


 *******************************************************************************


 *******************************************************************************
mmtbx/ions/tst_pick_ca.py

from __future__ import absolute_import, division, print_function
import os,time
from six.moves import cStringIO as StringIO
from mmtbx.ions.svm.dump_sites import master_phil
from mmtbx.ions.tst_symmetry_axis import get_analyze_waters_result
from iotbx.data_manager import DataManager

def exercise():
  from mmtbx.regression.make_fake_anomalous_data import generate_calcium_inputs
  base = "tst_pick_ca"
  mtz_file, pdb_file = generate_calcium_inputs(file_base=base, anonymize=True)
  time.sleep(2)

  wavelength = 1.1
  dm = DataManager()
  m = dm.get_model(pdb_file)
  dm.process_miller_array_file(mtz_file)
  fmo = dm.get_fmodel(scattering_table="n_gaussian")
  params = master_phil().extract()
  params.input.wavelength = 1.1
  params.phaser.fpp_ratio_max=1.2
  params.use_phaser=False
  params.nproc=1
  out = StringIO()
  result = get_analyze_waters_result(m,fmo,params,out)

  n_ca = 0
  for line in out.getvalue().splitlines():
    if "Probable cation: CA+2" in line:
      n_ca += 1
  if (n_ca != 1):
    print(out.getvalue().splitlines())
    raise RuntimeError("Expected 1 Ca2+, found %d" % n_ca)
  os.remove(pdb_file)
  os.remove(mtz_file)
  os.remove(os.path.splitext(pdb_file)[0][:-4] + ".pdb")
  os.remove(os.path.splitext(pdb_file)[0][:-4] + "_fmodel.eff")
  print("OK")

if (__name__ == "__main__"):
  exercise()


 *******************************************************************************


 *******************************************************************************
mmtbx/ions/tst_pick_ca_svm.py

from __future__ import absolute_import, division, print_function
import os
from six.moves import cStringIO as StringIO
from mmtbx.ions.svm.dump_sites import master_phil
from mmtbx.ions.tst_symmetry_axis import get_analyze_waters_result
from iotbx.data_manager import DataManager
import mmtbx.ions.svm

def exercise():
  try :
    from libsvm import svm      # import dependency
    from libsvm import svmutil  # import dependency
  except ImportError :
    print("libsvm not available, skipping this test")
    return
  from mmtbx.regression.make_fake_anomalous_data import generate_calcium_inputs
  base = "tst_pick_ca_svm"
  mtz_file, pdb_file = generate_calcium_inputs(file_base=base, anonymize=True)

  wavelength = 1.1
  dm = DataManager()
  m = dm.get_model(pdb_file)
  dm.process_miller_array_file(mtz_file)
  fmo = dm.get_fmodel(scattering_table="n_gaussian")
  xrs = m.get_xray_structure()
  xrs.set_inelastic_form_factors(photon = 1.54, table = "sasaki")
  fmo.update_xray_structure(xrs, update_f_calc = True)
  params = master_phil().extract()
  params.input.wavelength = wavelength
  params.use_svm=True
  params.elements='CA,ZN'
  params.use_phaser=False
  params.nproc=1
  manager_class = mmtbx.ions.svm.manager

  out = StringIO()
  result = get_analyze_waters_result(m,fmo,params,out,
    manager_class = manager_class)

  os.remove(pdb_file)
  os.remove(mtz_file)
  # "zn_frag_hoh.pdb" => "zn_frag_fmodel.eff"
  os.remove(os.path.splitext(pdb_file)[0][:-4] + ".pdb")
  os.remove(os.path.splitext(pdb_file)[0][:-4] + "_fmodel.eff")

  n_ca = 0
  for line in out.getvalue().splitlines():
    if ("Final choice: CA" in line):
      n_ca += 1
  if (n_ca != 1):
    print(out.getvalue().splitlines())
    raise RuntimeError("Expected 1 Ca2+, found %d" % n_ca)
  print("OK")

if (__name__ == "__main__"):
  exercise()


 *******************************************************************************


 *******************************************************************************
mmtbx/ions/tst_pick_k.py

from __future__ import absolute_import, division, print_function
import os, time
from libtbx import easy_run
from six.moves import cStringIO as StringIO
from mmtbx.ions.svm.dump_sites import master_phil
from mmtbx.ions.tst_symmetry_axis import get_analyze_waters_result
from iotbx.data_manager import DataManager

def exercise():
  # FIXME
  print("Temporarily disabled, skipping")
  return
  # the function below does not exist????
  from mmtbx.regression.make_fake_anomalous_data import generate_potassium_inputs
  base = "tst_pick_k"
  mtz_file, pdb_file = generate_potassium_inputs(file_base=base, anonymize=True)
  time.sleep(2)

#  dm = DataManager()
#  m = dm.get_model(pdb_file)
#  dm.process_miller_array_file(mtz_file)
#  fmo = dm.get_fmodel(scattering_table="n_gaussian")
#  params = master_phil().extract()
#  params.elements='K,MG'
#  params.use_phaser=False
#  params.nproc=1
#  out = StringIO()
#  result = get_analyze_waters_result(m,fmo,params,out)

  args = [pdb_file, mtz_file, "nproc=1", "elements=K,MG", "use_phaser=False"]
  result = easy_run.fully_buffered("mmtbx.water_screen %s" % " ".join(args)
    ).raise_if_errors()
  n_k = 0
  for line in result.stdout_lines :
    if ("Probable cation: K+1" in line):
      n_k += 1
  assert n_k == 3
  os.remove(pdb_file)
  os.remove(mtz_file)
  # "zn_frag_hoh.pdb" => "zn_frag_fmodel.eff"
  os.remove(os.path.splitext(pdb_file)[0][:-4] + "_fmodel.eff")
  print("OK")

if (__name__ == "__main__"):
  exercise()


 *******************************************************************************


 *******************************************************************************
mmtbx/ions/tst_pick_mg.py

from __future__ import absolute_import, division, print_function
import os, time
from six.moves import cStringIO as StringIO
from mmtbx.ions.svm.dump_sites import master_phil
from mmtbx.ions.tst_symmetry_axis import get_analyze_waters_result
from iotbx.data_manager import DataManager


def exercise():
  from mmtbx.regression.make_fake_anomalous_data import generate_magnessium_inputs
  base = "tst_pick_mg"
  mtz_file, pdb_file = generate_magnessium_inputs(file_base=base, anonymize=True)
  time.sleep(2)

  dm = DataManager()
  m = dm.get_model(pdb_file)
  dm.process_miller_array_file(mtz_file)
  fmo = dm.get_fmodel(scattering_table="n_gaussian")
  params = master_phil().extract()
  params.use_phaser=False
  params.elements='MG'
  out = StringIO()
  result = get_analyze_waters_result(m,fmo,params,out)

  n_mg = 0
  for line in out.getvalue().splitlines():
    if ("Probable cation: MG+2" in line):
      n_mg += 1
  if n_mg != 2:
    print("\n".join(result.stdout_lines))
    raise RuntimeError("Expected 2 MG+2, found %d" % n_mg)
  os.remove(pdb_file)
  os.remove(mtz_file)
  # "zn_frag_hoh.pdb" => "zn_frag_fmodel.eff"
  os.remove(os.path.splitext(pdb_file)[0][:-4] + ".pdb")
  os.remove(os.path.splitext(pdb_file)[0][:-4] + "_fmodel.eff")
  print("OK")

if __name__ == "__main__":
  exercise()


 *******************************************************************************


 *******************************************************************************
mmtbx/ions/tst_pickle.py
from __future__ import absolute_import, division, print_function
import os
from pickle import loads, dumps
from types import MethodType
import libtbx
from mmtbx import ions
from mmtbx.ions import environment
from mmtbx.regression.make_fake_anomalous_data import generate_zinc_inputs
import mmtbx.utils
import iotbx.phil
from iotbx.data_manager import DataManager

def exercise(prefix="mmtbx_ions_tst_pickle"):
  wavelength = 1.025
  mtz_file, pdb_file = generate_zinc_inputs(
      file_base=prefix,
      anonymize = False)
  null_out = libtbx.utils.null_out()

  dm = DataManager()
  m = dm.get_model(pdb_file)
  xrs = m.get_xray_structure()
  dm.process_miller_array_file(mtz_file)
  fmo = dm.get_fmodel(scattering_table="n_gaussian")

  os.remove(pdb_file)
  os.remove(mtz_file)

  xrs.set_inelastic_form_factors(photon = wavelength, table = "sasaki")
  fmo.update_xray_structure(xrs, update_f_calc = True)
  m.process(make_restraints=True)

  phil_str = '''
include scope mmtbx.ions.identify.ion_master_phil
include scope mmtbx.ions.svm.svm_phil_str
'''
  params = iotbx.phil.parse(input_string = phil_str,
    process_includes=True).extract()

  manager = ions.identify.create_manager(
    pdb_hierarchy = m.get_hierarchy(),
    fmodel = fmo,
    geometry_restraints_manager = m.get_restraints_manager().geometry,
    wavelength = wavelength,
    params = params,
    nproc = 1,
    log = null_out
    )

  manager.validate_ions(out = null_out)

  fo_map = manager.get_map("mFo")
  fofc_map = manager.get_map("mFo-DFc")

  for atom_props in manager.atoms_to_props.values():
    chem_env = environment.ChemicalEnvironment(
      atom_props.i_seq,
      manager.find_nearby_atoms(atom_props.i_seq, far_distance_cutoff = 3.5),
      manager
      )
    new_chem_env = loads(dumps(chem_env))
    for attr in dir(chem_env):
      if attr == "atom":
        # The two won't be directly comparable, but we will trust atom_labels is
        # tested fully in its own module
        assert chem_env.atom.id_str() == new_chem_env.atom.id_str()
      elif not attr.startswith("_") and \
        not isinstance(getattr(chem_env, attr), MethodType):
        assert getattr(chem_env, attr) == getattr(new_chem_env, attr)

    scatter_env = environment.ScatteringEnvironment(
      atom_props.i_seq, manager, fo_map, fofc_map
      )
    new_scatter_env = loads(dumps(scatter_env))
    for attr in dir(scatter_env):
      if not attr.startswith("_") and \
        not isinstance(getattr(scatter_env, attr), MethodType):
        assert getattr(scatter_env, attr) == getattr(new_scatter_env, attr)

  del fo_map
  del fofc_map

  print("OK")

if __name__ == "__main__":
  exercise()


 *******************************************************************************
