

 *******************************************************************************
iotbx/regression/tst_hierarchy_long_resname_1.py
from __future__ import absolute_import, division, print_function
import time
import iotbx.pdb
from libtbx.test_utils import assert_lines_in_text

# ------------------------------------------------------------------------------

# from https://github.com/wwPDB/extended-wwPDB-identifier-examples
# https://github.com/wwPDB/extended-wwPDB-identifier-examples/blob/main/Models/7fgz-extended_CCD_code-model.cif
mmcif_str = '''
data_XXXX
#
loop_
_atom_site.group_PDB
_atom_site.id
_atom_site.type_symbol
_atom_site.label_atom_id
_atom_site.label_alt_id
_atom_site.label_comp_id
_atom_site.label_asym_id
_atom_site.label_entity_id
_atom_site.label_seq_id
_atom_site.pdbx_PDB_ins_code
_atom_site.Cartn_x
_atom_site.Cartn_y
_atom_site.Cartn_z
_atom_site.occupancy
_atom_site.B_iso_or_equiv
_atom_site.pdbx_formal_charge
_atom_site.auth_seq_id
_atom_site.auth_comp_id
_atom_site.auth_asym_id
_atom_site.auth_atom_id
_atom_site.pdbx_PDB_model_num
ATOM   2140 N  N   . LYS A 1 261 ? 0.399   -10.171 39.802 1.00 40.11 ? 279 LYS A N   1
ATOM   2141 C  CA  . LYS A 1 261 ? -0.169  -9.988  41.173 1.00 43.86 ? 279 LYS A CA  1
ATOM   2142 C  C   . LYS A 1 261 ? 0.687   -9.011  41.991 1.00 41.94 ? 279 LYS A C   1
ATOM   2143 O  O   . LYS A 1 261 ? 1.044   -7.920  41.556 1.00 39.32 ? 279 LYS A O   1
ATOM   2144 C  CB  . LYS A 1 261 ? -0.260  -11.336 41.902 1.00 46.47 ? 279 LYS A CB  1
ATOM   2145 C  CG  . LYS A 1 261 ? -1.583  -12.074 41.713 1.00 49.13 ? 279 LYS A CG  1
ATOM   2146 C  CD  . LYS A 1 261 ? -1.611  -13.468 42.315 1.00 51.03 ? 279 LYS A CD  1
ATOM   2147 C  CE  . LYS A 1 261 ? -2.923  -13.799 42.993 1.00 52.86 ? 279 LYS A CE  1
ATOM   2148 N  NZ  . LYS A 1 261 ? -3.209  -12.856 44.100 1.00 54.19 ? 279 LYS A NZ  1
HETATM 2149 CA CA  . CA  B 2 .   ? -17.362 -22.385 28.047 1.00 15.20 ? 301 CA  A CA  1
HETATM 2150 N  N1  . 7ZTVU C 3 .   ? -7.743  -6.355  8.243  1.00 18.72 ? 302 7ZTVU A N1  1
HETATM 2151 C  C2  . 7ZTVU C 3 .   ? -8.462  -5.534  9.265  1.00 16.68 ? 302 7ZTVU A C2  1
HETATM 2152 C  C3  . 7ZTVU C 3 .   ? -8.092  -5.865  10.711 1.00 17.35 ? 302 7ZTVU A C3  1
HETATM 2153 N  N4  . 7ZTVU C 3 .   ? -7.975  -7.334  10.767 1.00 17.04 ? 302 7ZTVU A N4  1
HETATM 2154 C  C5  . 7ZTVU C 3 .   ? -6.781  -7.689  10.027 1.00 17.11 ? 302 7ZTVU A C5  1
HETATM 2155 C  C6  . 7ZTVU C 3 .   ? -7.363  -7.730  8.633  1.00 16.97 ? 302 7ZTVU A C6  1
HETATM 2156 C  C7  . 7ZTVU C 3 .   ? -8.071  -7.951  12.064 1.00 16.77 ? 302 7ZTVU A C7  1
HETATM 2157 C  C8  . 7ZTVU C 3 .   ? -8.490  -9.440  12.025 1.00 16.60 ? 302 7ZTVU A C8  1
HETATM 2158 O  O8  . 7ZTVU C 3 .   ? -8.391  -10.140 10.781 1.00 14.14 ? 302 7ZTVU A O8  1
HETATM 2159 C  C9  . 7ZTVU C 3 .   ? -8.438  -6.311  6.935  1.00 20.13 ? 302 7ZTVU A C9  1
HETATM 2160 C  C10 . 7ZTVU C 3 .   ? -7.646  -6.965  5.796  1.00 22.62 ? 302 7ZTVU A C10 1
HETATM 2161 S  S   . 7ZTVU C 3 .   ? -8.372  -6.708  4.279  1.00 24.90 ? 302 7ZTVU A S   1
HETATM 2162 O  O1S . 7ZTVU C 3 .   ? -7.579  -7.371  3.224  1.00 25.47 ? 302 7ZTVU A O1S 1
HETATM 2163 O  O2S . 7ZTVU C 3 .   ? -8.533  -5.211  4.078  1.00 25.01 ? 302 7ZTVU A O2S 1
HETATM 2164 O  O3S . 7ZTVU C 3 .   ? -9.691  -7.326  4.282  1.00 26.42 ? 302 7ZTVU A O3S 1
HETATM 2165 N  N1  . 7ZTVU D 3 .   ? -11.233 1.732   10.446 1.00 74.61 ? 303 7ZTVU A N1  1
HETATM 2166 C  C2  . 7ZTVU D 3 .   ? -11.682 2.495   9.264  1.00 77.03 ? 303 7ZTVU A C2  1
HETATM 2167 C  C3  . 7ZTVU D 3 .   ? -11.907 3.979   9.617  1.00 76.82 ? 303 7ZTVU A C3  1
HETATM 2168 N  N4  . 7ZTVU D 3 .   ? -12.335 4.282   11.022 1.00 73.77 ? 303 7ZTVU A N4  1
HETATM 2169 C  C5  . 7ZTVU D 3 .   ? -12.654 3.123   11.908 1.00 69.90 ? 303 7ZTVU A C5  1
HETATM 2170 C  C6  . 7ZTVU D 3 .   ? -12.333 1.719   11.409 1.00 69.07 ? 303 7ZTVU A C6  1
HETATM 2171 C  C7  . 7ZTVU D 3 .   ? -11.415 5.232   11.725 1.00 71.46 ? 303 7ZTVU A C7  1
HETATM 2172 C  C8  . 7ZTVU D 3 .   ? -12.126 5.976   12.871 1.00 70.74 ? 303 7ZTVU A C8  1
HETATM 2173 O  O8  . 7ZTVU D 3 .   ? -11.360 5.921   14.096 1.00 61.89 ? 303 7ZTVU A O8  1
HETATM 2174 C  C9  . 7ZTVU D 3 .   ? -10.756 0.357   10.142 1.00 74.40 ? 303 7ZTVU A C9  1
HETATM 2175 C  C10 . 7ZTVU D 3 .   ? -10.121 -0.289  11.396 1.00 75.92 ? 303 7ZTVU A C10 1
HETATM 2176 S  S   . 7ZTVU D 3 .   ? -8.757  -1.214  11.091 1.00 77.53 ? 303 7ZTVU A S   1
HETATM 2177 O  O1S . 7ZTVU D 3 .   ? -7.735  -0.305  10.525 1.00 74.01 ? 303 7ZTVU A O1S 1
HETATM 2178 O  O2S . 7ZTVU D 3 .   ? -9.042  -2.313  10.141 1.00 83.78 ? 303 7ZTVU A O2S 1
HETATM 2179 O  O3S . 7ZTVU D 3 .   ? -8.264  -1.864  12.321 1.00 70.44 ? 303 7ZTVU A O3S 1
HETATM 2180 O  O   . HOH E 4 .   ? 10.567  -6.539  28.064 1.00 30.11 ? 401 HOH A O   1
HETATM 2181 O  O   . HOH E 4 .   ? 2.856   -8.848  40.692 1.00 32.14 ? 402 HOH A O   1
HETATM 2182 O  O   . HOH E 4 .   ? -10.577 -29.762 22.833 1.00 22.07 ? 403 HOH A O   1
HETATM 2183 O  O   . HOH E 4 .   ? 14.705  -5.437  13.988 1.00 28.06 ? 404 HOH A O   1
'''

def test1():
  """
  Test correct reading of long residue name mmCIF file into hierarchy.
  Testing output to pdb and cif.
  """
  inp = iotbx.pdb.input(lines=mmcif_str.split("\n"), source_info=None)
  h = inp.construct_hierarchy()
  chains = list(h.overall_counts().chain_ids.keys())
  chains.sort()
  answer = ['A']
  assert (chains == answer), '%s %s' % (chains, answer)
  # print(h.overall_counts().resnames)
  resnames = sorted(h.overall_counts().resnames.keys())
  assert resnames == [' CA', '7ZTVU', 'HOH', 'LYS'], resnames

  o_pdb_str = h.as_pdb_string()
  # print(o_pdb_str)
  # Note here incorrect/trimmed residue names
  # There's no way to correctly output resnames longer than 3 char in PDB format
  # print(o_pdb_str)
  assert o_pdb_str == ""
#   assert_lines_in_text(o_pdb_str, """\
# ATOM      8  CE  LYS A 279      -2.923 -13.799  42.993  1.00 52.86           C
# ATOM      9  NZ  LYS A 279      -3.209 -12.856  44.100  1.00 54.19           N
# TER
# HETATM   10 CA    CA A 301     -17.362 -22.385  28.047  1.00 15.20          CA
# HETATM   11  C10 7ZTVU A 302      -7.646  -6.965   5.796  1.00 22.62           C
# HETATM   12  C2  7ZTVU A 302      -8.462  -5.534   9.265  1.00 16.68           C
#     """)

  o_cif_str = "%s" % h.as_cif_block()
  # print(o_cif_str)
  assert_lines_in_text(o_cif_str, """\
ATOM     8  CE   .  LYS    A  279  ?   -2.92300  -13.79900  42.99300  1.000  52.86000  C   ?  A  ?  1  1
ATOM     9  NZ   .  LYS    A  279  ?   -3.20900  -12.85600  44.10000  1.000  54.19000  N   ?  A  ?  1  1
HETATM  10  CA   .  CA     A  301  ?  -17.36200  -22.38500  28.04700  1.000  15.20000  CA  ?  B  ?  .  1
HETATM  11  C10  .  7ZTVU  A  302  ?   -7.64600   -6.96500   5.79600  1.000  22.62000  C   ?  C  ?  .  1
HETATM  12  C2   .  7ZTVU  A  302  ?   -8.46200   -5.53400   9.26500  1.000  16.68000  C   ?  C  ?  .  1
    """)

def test2():
  """
  Testing selections
  """
  inp = iotbx.pdb.input(lines=mmcif_str.split("\n"), source_info=None)
  h = inp.construct_hierarchy()
  asc = h.atom_selection_cache()
  s = asc.iselection("resname 7ZTVU")
  assert list(s) == list(range(10,40)), list(s)
  s = asc.iselection("resname 7ZTVU and name N1")
  assert list(s) == [18,33], list(s)

if (__name__ == "__main__"):
  t0 = time.time()
  test1()
  test2()
  print("OK. Time: %8.3f"%(time.time()-t0))


 *******************************************************************************


 *******************************************************************************
iotbx/regression/tst_hierarchy_long_resname_2.py
from __future__ import absolute_import, division, print_function
import time
from libtbx.test_utils import assert_lines_in_text
import iotbx.pdb
import iotbx.cif
import mmtbx.model
from mmtbx import monomer_library

# ------------------------------------------------------------------------------

# from https://github.com/wwPDB/extended-wwPDB-identifier-examples
# https://github.com/wwPDB/extended-wwPDB-identifier-examples/blob/main/Models/7fgz-extended_CCD_code-model.cif
mmcif_str = '''
data_XXXX
#
loop_
_atom_site.group_PDB
_atom_site.id
_atom_site.type_symbol
_atom_site.label_atom_id
_atom_site.label_alt_id
_atom_site.label_comp_id
_atom_site.label_asym_id
_atom_site.label_entity_id
_atom_site.label_seq_id
_atom_site.pdbx_PDB_ins_code
_atom_site.Cartn_x
_atom_site.Cartn_y
_atom_site.Cartn_z
_atom_site.occupancy
_atom_site.B_iso_or_equiv
_atom_site.pdbx_formal_charge
_atom_site.auth_seq_id
_atom_site.auth_comp_id
_atom_site.auth_asym_id
_atom_site.auth_atom_id
_atom_site.pdbx_PDB_model_num
ATOM   2140 N  N   . LYS A 1 261 ? 0.399   -10.171 39.802 1.00 40.11 ? 279 LYS A N   1
ATOM   2141 C  CA  . LYS A 1 261 ? -0.169  -9.988  41.173 1.00 43.86 ? 279 LYS A CA  1
ATOM   2142 C  C   . LYS A 1 261 ? 0.687   -9.011  41.991 1.00 41.94 ? 279 LYS A C   1
ATOM   2143 O  O   . LYS A 1 261 ? 1.044   -7.920  41.556 1.00 39.32 ? 279 LYS A O   1
ATOM   2144 C  CB  . LYS A 1 261 ? -0.260  -11.336 41.902 1.00 46.47 ? 279 LYS A CB  1
ATOM   2145 C  CG  . LYS A 1 261 ? -1.583  -12.074 41.713 1.00 49.13 ? 279 LYS A CG  1
ATOM   2146 C  CD  . LYS A 1 261 ? -1.611  -13.468 42.315 1.00 51.03 ? 279 LYS A CD  1
ATOM   2147 C  CE  . LYS A 1 261 ? -2.923  -13.799 42.993 1.00 52.86 ? 279 LYS A CE  1
ATOM   2148 N  NZ  . LYS A 1 261 ? -3.209  -12.856 44.100 1.00 54.19 ? 279 LYS A NZ  1
HETATM 2180 O  O   . longHOH E 4 .   ? -3.209  -12.856 46.100 1.00 30.11 ? 401 longHOH A O   1
'''

ligand_cif = """\
data_comp_list
loop_
_chem_comp.id
_chem_comp.three_letter_code
_chem_comp.name
_chem_comp.group
_chem_comp.number_atoms_all
_chem_comp.number_atoms_nh
_chem_comp.desc_level
_chem_comp.initial_date
_chem_comp.modified_date
_chem_comp.source
 longHOH  longHOH  'water                    '  ligand  3  1  .  2012-10-17  2022-03-18
;
Directly from eLBOW using geometry from QM method PBEh-3c with CPCM solvent model
Validated by Mogul as GRAND
;

data_comp_longHOH
loop_
_chem_comp_atom.comp_id
_chem_comp_atom.atom_id
_chem_comp_atom.type_symbol
_chem_comp_atom.type_energy
_chem_comp_atom.charge
_chem_comp_atom.partial_charge
_chem_comp_atom.x
_chem_comp_atom.y
_chem_comp_atom.z
 longHOH  O   O  OH2   0  -0.881  -23.1198  18.3926  -21.5996
 longHOH  H1  H  HOH2  0   0.440  -22.1601  18.3725  -21.6036
 longHOH  H2  H  HOH2  0   0.440  -23.3469  18.3903  -20.6669

loop_
_chem_comp_bond.comp_id
_chem_comp_bond.atom_id_1
_chem_comp_bond.atom_id_2
_chem_comp_bond.type
_chem_comp_bond.value_dist
_chem_comp_bond.value_dist_esd
_chem_comp_bond.value_dist_neutron
 longHOH  O  H1  single  0.850  0.020  0.980
 longHOH  O  H2  single  0.850  0.020  0.980

loop_
_chem_comp_angle.comp_id
_chem_comp_angle.atom_id_1
_chem_comp_angle.atom_id_2
_chem_comp_angle.atom_id_3
_chem_comp_angle.value_angle
_chem_comp_angle.value_angle_esd
 longHOH  H2  O  H1  103.91  3.000
"""

def test1():
  """
  Creating restraints for long residue name:
    HOH changed to longHOH, cif copied from modules/chem_data/geostd/h/data_HOH.cif
  """

  inp = iotbx.pdb.input(lines=mmcif_str.split("\n"), source_info=None)
  cif_object = iotbx.cif.reader(input_string = ligand_cif).model()
  cif_objects = [('bla.cif', cif_object)]
  model = mmtbx.model.manager(model_input = inp, restraint_objects = cif_objects)
  model.process(make_restraints=True)
  geo_str = model.restraints_as_geo()
  # print(geo_str)
  for l in [
      'bond pdb=" NZ  LYS A 279 "',
      '     pdb=" O   longHOH A 401 "',
      'nonbonded pdb=" CD  LYS A 279 "',
      '          pdb=" O   longHOH A 401 "']:
    assert_lines_in_text(geo_str, l)
  model_cif = model.model_as_mmcif()
  # print(model_cif)
  for l in [
      'longHOH H2 O H1 103.91 3.000',
      'data_comp_longHOH',
      '   HETATM 10 O . longHOH A 401 ? -3.20900 -12.85600 46.10000 1.000 30.11000 O ? B ? . 1']:
    assert_lines_in_text(model_cif, l)
  model_pdb = model.model_as_pdb()
  assert not model.can_be_output_as_pdb()

if (__name__ == "__main__"):
  t0 = time.time()
  mon_lib_srv = None
  try:
    mon_lib_srv = monomer_library.server.server()
  except: # intentional
    print("Can not initialize monomer_library, skipping test.")
  if mon_lib_srv is not None:
    test1()
  print("OK. Time: %8.3f"%(time.time()-t0))


 *******************************************************************************


 *******************************************************************************
iotbx/regression/tst_hierarchy_long_resname_3.py
from __future__ import absolute_import, division, print_function
import time
from libtbx.test_utils import assert_lines_in_text
import iotbx.pdb
import iotbx.cif
import mmtbx.model
from mmtbx import monomer_library
from libtbx.utils import Sorry
from six.moves import cStringIO as StringIO

# ------------------------------------------------------------------------------

# from https://github.com/wwPDB/extended-wwPDB-identifier-examples
# https://github.com/wwPDB/extended-wwPDB-identifier-examples/blob/main/Models/7fgz-extended_CCD_code-model.cif
mm_cif = '''
data_XXXX
#
loop_
_atom_site.group_PDB
_atom_site.id
_atom_site.type_symbol
_atom_site.label_atom_id
_atom_site.label_alt_id
_atom_site.label_comp_id
_atom_site.label_asym_id
_atom_site.label_entity_id
_atom_site.label_seq_id
_atom_site.pdbx_PDB_ins_code
_atom_site.Cartn_x
_atom_site.Cartn_y
_atom_site.Cartn_z
_atom_site.occupancy
_atom_site.B_iso_or_equiv
_atom_site.pdbx_formal_charge
_atom_site.auth_seq_id
_atom_site.auth_comp_id
_atom_site.auth_asym_id
_atom_site.auth_atom_id
_atom_site.pdbx_PDB_model_num
ATOM   2140 N  N   . LYS A 1 261 ? 0.399   -10.171 39.802 1.00 40.11 ? 279 LYS A N   1
ATOM   2141 C  CA  . LYS A 1 261 ? -0.169  -9.988  41.173 1.00 43.86 ? 279 LYS A CA  1
ATOM   2142 C  C   . LYS A 1 261 ? 0.687   -9.011  41.991 1.00 41.94 ? 279 LYS A C   1
ATOM   2143 O  O   . LYS A 1 261 ? 1.044   -7.920  41.556 1.00 39.32 ? 279 LYS A O   1
ATOM   2144 C  CB  . LYS A 1 261 ? -0.260  -11.336 41.902 1.00 46.47 ? 279 LYS A CB  1
ATOM   2145 C  CG  . LYS A 1 261 ? -1.583  -12.074 41.713 1.00 49.13 ? 279 LYS A CG  1
ATOM   2146 C  CD  . LYS A 1 261 ? -1.611  -13.468 42.315 1.00 51.03 ? 279 LYS A CD  1
ATOM   2147 C  CE  . LYS A 1 261 ? -2.923  -13.799 42.993 1.00 52.86 ? 279 LYS A CE  1
ATOM   2148 N  NZ  . LYS A 1 261 ? -3.209  -12.856 44.100 1.00 54.19 ? 279 LYS A NZ  1
HETATM 2150 N  N1  . 7ZTVU C 3 .   ? -7.743  -6.355  8.243  1.00 18.72 ? 302 7ZTVU A N1  1
HETATM 2151 C  C2  . 7ZTVU C 3 .   ? -8.462  -5.534  9.265  1.00 16.68 ? 302 7ZTVU A C2  1
HETATM 2152 C  C3  . 7ZTVU C 3 .   ? -8.092  -5.865  10.711 1.00 17.35 ? 302 7ZTVU A C3  1
HETATM 2153 N  N4  . 7ZTVU C 3 .   ? -7.975  -7.334  10.767 1.00 17.04 ? 302 7ZTVU A N4  1
HETATM 2154 C  C5  . 7ZTVU C 3 .   ? -6.781  -7.689  10.027 1.00 17.11 ? 302 7ZTVU A C5  1
HETATM 2155 C  C6  . 7ZTVU C 3 .   ? -7.363  -7.730  8.633  1.00 16.97 ? 302 7ZTVU A C6  1
HETATM 2156 C  C7  . 7ZTVU C 3 .   ? -8.071  -7.951  12.064 1.00 16.77 ? 302 7ZTVU A C7  1
HETATM 2157 C  C8  . 7ZTVU C 3 .   ? -8.490  -9.440  12.025 1.00 16.60 ? 302 7ZTVU A C8  1
HETATM 2158 O  O8  . 7ZTVU C 3 .   ? -8.391  -10.140 10.781 1.00 14.14 ? 302 7ZTVU A O8  1
HETATM 2159 C  C9  . 7ZTVU C 3 .   ? -8.438  -6.311  6.935  1.00 20.13 ? 302 7ZTVU A C9  1
HETATM 2160 C  C10 . 7ZTVU C 3 .   ? -7.646  -6.965  5.796  1.00 22.62 ? 302 7ZTVU A C10 1
HETATM 2161 S  S   . 7ZTVU C 3 .   ? -8.372  -6.708  4.279  1.00 24.90 ? 302 7ZTVU A S   1
HETATM 2162 O  O1S . 7ZTVU C 3 .   ? -7.579  -7.371  3.224  1.00 25.47 ? 302 7ZTVU A O1S 1
HETATM 2163 O  O2S . 7ZTVU C 3 .   ? -8.533  -5.211  4.078  1.00 25.01 ? 302 7ZTVU A O2S 1
HETATM 2164 O  O3S . 7ZTVU C 3 .   ? -9.691  -7.326  4.282  1.00 26.42 ? 302 7ZTVU A O3S 1
HETATM 2165 N  N1  . 7ZTVU D 3 .   ? -11.233 1.732   10.446 1.00 74.61 ? 303 7ZTVU A N1  1
HETATM 2166 C  C2  . 7ZTVU D 3 .   ? -11.682 2.495   9.264  1.00 77.03 ? 303 7ZTVU A C2  1
HETATM 2167 C  C3  . 7ZTVU D 3 .   ? -11.907 3.979   9.617  1.00 76.82 ? 303 7ZTVU A C3  1
HETATM 2168 N  N4  . 7ZTVU D 3 .   ? -12.335 4.282   11.022 1.00 73.77 ? 303 7ZTVU A N4  1
HETATM 2169 C  C5  . 7ZTVU D 3 .   ? -12.654 3.123   11.908 1.00 69.90 ? 303 7ZTVU A C5  1
HETATM 2170 C  C6  . 7ZTVU D 3 .   ? -12.333 1.719   11.409 1.00 69.07 ? 303 7ZTVU A C6  1
HETATM 2171 C  C7  . 7ZTVU D 3 .   ? -11.415 5.232   11.725 1.00 71.46 ? 303 7ZTVU A C7  1
HETATM 2172 C  C8  . 7ZTVU D 3 .   ? -12.126 5.976   12.871 1.00 70.74 ? 303 7ZTVU A C8  1
HETATM 2173 O  O8  . 7ZTVU D 3 .   ? -11.360 5.921   14.096 1.00 61.89 ? 303 7ZTVU A O8  1
HETATM 2174 C  C9  . 7ZTVU D 3 .   ? -10.756 0.357   10.142 1.00 74.40 ? 303 7ZTVU A C9  1
HETATM 2175 C  C10 . 7ZTVU D 3 .   ? -10.121 -0.289  11.396 1.00 75.92 ? 303 7ZTVU A C10 1
HETATM 2176 S  S   . 7ZTVU D 3 .   ? -8.757  -1.214  11.091 1.00 77.53 ? 303 7ZTVU A S   1
HETATM 2177 O  O1S . 7ZTVU D 3 .   ? -7.735  -0.305  10.525 1.00 74.01 ? 303 7ZTVU A O1S 1
HETATM 2178 O  O2S . 7ZTVU D 3 .   ? -9.042  -2.313  10.141 1.00 83.78 ? 303 7ZTVU A O2S 1
HETATM 2179 O  O3S . 7ZTVU D 3 .   ? -8.264  -1.864  12.321 1.00 70.44 ? 303 7ZTVU A O3S 1
'''

ligand_cif = """\
data_comp_list
loop_
_chem_comp.id
_chem_comp.three_letter_code
_chem_comp.name
_chem_comp.group
_chem_comp.number_atoms_all
_chem_comp.number_atoms_nh
_chem_comp.desc_level
 7ZTVU         7ZTVU '2-[4-(2-hydroxyethyl)piperazin-1-yl]ethanesulfonic acid' ligand 32 15 .
#
data_comp_7ZTVU
#
loop_
_chem_comp_atom.comp_id
_chem_comp_atom.atom_id
_chem_comp_atom.type_symbol
_chem_comp_atom.type_energy
_chem_comp_atom.charge
_chem_comp_atom.partial_charge
_chem_comp_atom.x
_chem_comp_atom.y
_chem_comp_atom.z
 7ZTVU         N1     N   NT     0    .      -0.5253    0.0932   -1.5549
 7ZTVU         C2     C   CH2    0    .       0.9262    0.1022   -1.5401
 7ZTVU         C3     C   CH2    0    .       1.4857    0.1109   -0.1192
 7ZTVU         N4     N   NT     0    .       0.9247    1.1836    0.6816
 7ZTVU         C5     C   CH2    0    .      -0.5267    1.1746    0.6669
 7ZTVU         C6     C   CH2    0    .      -1.0863    1.1660   -0.7540
 7ZTVU         C7     C   CH2    0    .       1.3954    1.0634    2.0495
 7ZTVU         C8     C   CH2    0    .       2.1337    2.3395    2.4478
 7ZTVU         O8     O   OH1    0    .       2.5312    2.2499    3.7877
 7ZTVU         C9     C   CH2    0    .      -1.0063   -1.1833   -1.0588
 7ZTVU         C10    C   CH2    0    .      -1.8024   -1.8881   -2.1549
 7ZTVU         S      S   S      0    .      -2.4815   -3.4426   -1.5057
 7ZTVU         O1S    O   OS     0    .      -3.5911   -3.1842   -0.5146
 7ZTVU         O2S    O   OS     0    .      -3.2186   -4.2088   -2.5779
 7ZTVU         O3S    O   OS    -1    .      -1.3827   -4.2775   -0.8928
 7ZTVU         H21    H   HCH2   0    .       1.2877   -0.7819   -2.0541
 7ZTVU         H22    H   HCH2   0    .       1.2768    0.9870   -2.0606
 7ZTVU         H31    H   HCH2   0    .       1.2556   -0.8376    0.3543
 7ZTVU         H32    H   HCH2   0    .       2.5623    0.2348   -0.1669
 7ZTVU         H51    H   HCH2   0    .      -0.8883    2.0588    1.1809
 7ZTVU         H52    H   HCH2   0    .      -0.8774    0.2898    1.1874
 7ZTVU         H61    H   HCH2   0    .      -0.8561    2.1144   -1.2275
 7ZTVU         H62    H   HCH2   0    .      -2.1629    1.0420   -0.7063
 7ZTVU         H71    H   HCH2   0    .       2.0691    0.2167    2.1269
 7ZTVU         H72    H   HCH2   0    .       0.5490    0.9138    2.7113
 7ZTVU         H81    H   HCH2   0    .       1.4752    3.1923    2.3222
 7ZTVU         H82    H   HCH2   0    .       3.0087    2.4624    1.8185
 7ZTVU         HO8    H   HOH1   0    .       3.0956    2.9773    3.9980
 7ZTVU         H91    H   HCH2   0    .      -0.1620   -1.8008   -0.7712
 7ZTVU         H92    H   HCH2   0    .      -1.6444   -1.0192   -0.1971
 7ZTVU        H101    H   HCH2   0    .      -1.1503   -2.1015   -2.9952
 7ZTVU        H102    H   HCH2   0    .      -2.6144   -1.2471   -2.4811
#
loop_
_chem_comp_bond.comp_id
_chem_comp_bond.atom_id_1
_chem_comp_bond.atom_id_2
_chem_comp_bond.type
_chem_comp_bond.value_dist
_chem_comp_bond.value_dist_esd
 7ZTVU   N1      C2    single        1.452 0.020
 7ZTVU   N1      C6    single        1.452 0.020
 7ZTVU   N1      C9    single        1.452 0.020
 7ZTVU   C2      C3    single        1.527 0.020
 7ZTVU   C2      H21   single        1.085 0.020
 7ZTVU   C2      H22   single        1.085 0.020
 7ZTVU   C3      N4    single        1.452 0.020
 7ZTVU   C3      H31   single        1.085 0.020
 7ZTVU   C3      H32   single        1.085 0.020
 7ZTVU   N4      C5    single        1.452 0.020
 7ZTVU   N4      C7    single        1.452 0.020
 7ZTVU   C5      C6    single        1.527 0.020
 7ZTVU   C5      H51   single        1.085 0.020
 7ZTVU   C5      H52   single        1.085 0.020
 7ZTVU   C6      H61   single        1.085 0.020
 7ZTVU   C6      H62   single        1.085 0.020
 7ZTVU   C7      C8    single        1.527 0.020
 7ZTVU   C7      H71   single        1.085 0.020
 7ZTVU   C7      H72   single        1.085 0.020
 7ZTVU   C8      O8    single        1.401 0.020
 7ZTVU   C8      H81   single        1.085 0.020
 7ZTVU   C8      H82   single        1.085 0.020
 7ZTVU   O8      HO8   single        0.944 0.020
 7ZTVU   C9      C10   single        1.527 0.020
 7ZTVU   C9      H91   single        1.085 0.020
 7ZTVU   C9      H92   single        1.085 0.020
 7ZTVU   C10     S     single        1.816 0.020
 7ZTVU   C10    H101   single        1.085 0.020
 7ZTVU   C10    H102   single        1.085 0.020
 7ZTVU   S       O1S   deloc         1.510 0.020
 7ZTVU   S       O2S   deloc         1.510 0.020
 7ZTVU   S       O3S   deloc         1.510 0.020
"""

def test1():
  """
  Creating restraints for long residue name
  """
  #dumping to disk if needed:
  # for name, s in [('model', mm_cif), ('restr', ligand_cif)]:
  #   with open('%s.cif' % name, 'w') as f:
  #     f.write(s)
  inp = iotbx.pdb.input(lines=mm_cif.split("\n"), source_info=None)
  cif_object = iotbx.cif.reader(input_string = ligand_cif).model()
  cif_objects = [('bla.cif', cif_object)]
  model = mmtbx.model.manager(
      model_input = inp,
      restraint_objects = cif_objects)
  try:
    model.process(make_restraints=True)
    geo_str = model.restraints_as_geo()
  except Sorry as e:
    pass
  # print(geo_str)
  for l in [
    'bond pdb=" C10 7ZTVU A 303 "',
    '     pdb=" S   7ZTVU A 303 "',
    'nonbonded pdb=" C2  7ZTVU A 302 "',
    '          pdb=" O8  7ZTVU A 302 "',
    ]:
    # print(geo_str.find(l),l)
    assert_lines_in_text(geo_str, l)
  model_cif = model.model_as_mmcif()
   # print(model_cif)
  for l in [
    'HETATM 10 C10 . 7ZTVU A 302 ? -7.64600 -6.96500 5.79600 1.000 22.62000 C ? B ? . 1',
    '7ZTVU N1 C2 single 1.452 0.020',
    'data_comp_7ZTVU',
    ]:
    assert_lines_in_text(model_cif, l)
  assert not model.can_be_output_as_pdb()

def test2():
  """
  Try creating restraints for long residue name without cif.
  Check error message formatting (atom.quote() function)
  """
  #dumping to disk if needed:
  # for name, s in [('model', mm_cif), ('restr', ligand_cif)]:
  #   with open('%s.cif' % name, 'w') as f:
  #     f.write(s)
  inp = iotbx.pdb.input(lines=mm_cif.split("\n"), source_info=None)
  cif_object = iotbx.cif.reader(input_string = ligand_cif).model()
  cif_objects = [('bla.cif', cif_object)]
  mlog = StringIO()
  model = mmtbx.model.manager(
      model_input = inp,
      log = mlog)
  try:
    model.process(make_restraints=True)
  except Sorry as e:
    mlog_txt = mlog.getvalue()
    # print(str(e))
    # print(mlog_txt)
    assert_lines_in_text(mlog_txt, """ "HETATM   15  C7  7ZTVU A 302 .*.     C  " """)


if (__name__ == "__main__"):
  t0 = time.time()
  mon_lib_srv = None
  try:
    mon_lib_srv = monomer_library.server.server()
  except: # intentional
    print("Can not initialize monomer_library, skipping test.")
  if mon_lib_srv is not None:
    test1()
    test2()
  print("OK. Time: %8.3f"%(time.time()-t0))


 *******************************************************************************


 *******************************************************************************
iotbx/regression/tst_hierarchy_long_resname_4.py

from __future__ import absolute_import, division, print_function
import time
from libtbx.test_utils import assert_lines_in_text
import iotbx.pdb
import iotbx.cif
import mmtbx.model
from mmtbx import monomer_library
from libtbx.utils import Sorry
from six.moves import cStringIO as StringIO

# ------------------------------------------------------------------------------

# from 1yjp, Gln4 replaced with longGLY, restraints adapted form monomer library
mm_cif = '''
data_XXXX
#
loop_
_atom_site.group_PDB
_atom_site.id
_atom_site.type_symbol
_atom_site.label_atom_id
_atom_site.label_alt_id
_atom_site.label_comp_id
_atom_site.label_asym_id
_atom_site.label_entity_id
_atom_site.label_seq_id
_atom_site.pdbx_PDB_ins_code
_atom_site.Cartn_x
_atom_site.Cartn_y
_atom_site.Cartn_z
_atom_site.occupancy
_atom_site.B_iso_or_equiv
_atom_site.pdbx_formal_charge
_atom_site.auth_seq_id
_atom_site.auth_comp_id
_atom_site.auth_asym_id
_atom_site.auth_atom_id
_atom_site.pdbx_PDB_model_num
ATOM   1  N N   . GLY A 1 1 ? -9.009  4.612  6.102  1.00 16.77 ? 1  GLY A N   1
ATOM   2  C CA  . GLY A 1 1 ? -9.052  4.207  4.651  1.00 16.57 ? 1  GLY A CA  1
ATOM   3  C C   . GLY A 1 1 ? -8.015  3.140  4.419  1.00 16.16 ? 1  GLY A C   1
ATOM   4  O O   . GLY A 1 1 ? -7.523  2.521  5.381  1.00 16.78 ? 1  GLY A O   1
ATOM   5  N N   . ASN A 1 2 ? -7.656  2.923  3.155  1.00 15.02 ? 2  ASN A N   1
ATOM   6  C CA  . ASN A 1 2 ? -6.522  2.038  2.831  1.00 14.10 ? 2  ASN A CA  1
ATOM   7  C C   . ASN A 1 2 ? -5.241  2.537  3.427  1.00 13.13 ? 2  ASN A C   1
ATOM   8  O O   . ASN A 1 2 ? -4.978  3.742  3.426  1.00 11.91 ? 2  ASN A O   1
ATOM   9  C CB  . ASN A 1 2 ? -6.346  1.881  1.341  1.00 15.38 ? 2  ASN A CB  1
ATOM   10 C CG  . ASN A 1 2 ? -7.584  1.342  0.692  1.00 14.08 ? 2  ASN A CG  1
ATOM   11 O OD1 . ASN A 1 2 ? -8.025  0.227  1.016  1.00 17.46 ? 2  ASN A OD1 1
ATOM   12 N ND2 . ASN A 1 2 ? -8.204  2.155  -0.169 1.00 11.72 ? 2  ASN A ND2 1
ATOM   13 N N   . ASN A 1 3 ? -4.438  1.590  3.905  1.00 12.26 ? 3  ASN A N   1
ATOM   14 C CA  . ASN A 1 3 ? -3.193  1.904  4.589  1.00 11.74 ? 3  ASN A CA  1
ATOM   15 C C   . ASN A 1 3 ? -1.955  1.332  3.895  1.00 11.10 ? 3  ASN A C   1
ATOM   16 O O   . ASN A 1 3 ? -1.872  0.119  3.648  1.00 10.42 ? 3  ASN A O   1
ATOM   17 C CB  . ASN A 1 3 ? -3.259  1.378  6.042  1.00 12.15 ? 3  ASN A CB  1
ATOM   18 C CG  . ASN A 1 3 ? -2.006  1.739  6.861  1.00 12.82 ? 3  ASN A CG  1
ATOM   19 O OD1 . ASN A 1 3 ? -1.702  2.925  7.072  1.00 15.05 ? 3  ASN A OD1 1
ATOM   20 N ND2 . ASN A 1 3 ? -1.271  0.715  7.306  1.00 13.48 ? 3  ASN A ND2 1
ATOM   21 N N   . longGLY A 1 4 ? -1.005  2.228  3.598  1.00 10.29 ? 4  longGLY A N   1
ATOM   22 C CA  . longGLY A 1 4 ? 0.384   1.888  3.199  1.00 10.53 ? 4  longGLY A CA  1
ATOM   23 C C   . longGLY A 1 4 ? 1.435   2.606  4.088  1.00 10.24 ? 4  longGLY A C   1
ATOM   24 O O   . longGLY A 1 4 ? 1.547   3.843  4.115  1.00 8.86  ? 4  longGLY A O   1
ATOM   30 N N   . GLN A 1 5 ? 2.154   1.821  4.871  1.00 10.38 ? 5  GLN A N   1
ATOM   31 C CA  . GLN A 1 5 ? 3.270   2.361  5.640  1.00 11.39 ? 5  GLN A CA  1
ATOM   32 C C   . GLN A 1 5 ? 4.594   1.768  5.172  1.00 11.52 ? 5  GLN A C   1
ATOM   33 O O   . GLN A 1 5 ? 4.768   0.546  5.054  1.00 12.05 ? 5  GLN A O   1
ATOM   34 C CB  . GLN A 1 5 ? 3.056   2.183  7.147  1.00 11.96 ? 5  GLN A CB  1
ATOM   35 C CG  . GLN A 1 5 ? 1.829   2.950  7.647  1.00 10.81 ? 5  GLN A CG  1
ATOM   36 C CD  . GLN A 1 5 ? 1.344   2.414  8.954  1.00 13.10 ? 5  GLN A CD  1
ATOM   37 O OE1 . GLN A 1 5 ? 0.774   1.325  9.002  1.00 10.65 ? 5  GLN A OE1 1
ATOM   38 N NE2 . GLN A 1 5 ? 1.549   3.187  10.039 1.00 12.30 ? 5  GLN A NE2 1
ATOM   39 N N   . ASN A 1 6 ? 5.514   2.664  4.856  1.00 11.99 ? 6  ASN A N   1
ATOM   40 C CA  . ASN A 1 6 ? 6.831   2.310  4.318  1.00 12.30 ? 6  ASN A CA  1
ATOM   41 C C   . ASN A 1 6 ? 7.854   2.761  5.324  1.00 13.40 ? 6  ASN A C   1
ATOM   42 O O   . ASN A 1 6 ? 8.219   3.943  5.374  1.00 13.92 ? 6  ASN A O   1
ATOM   43 C CB  . ASN A 1 6 ? 7.065   3.016  2.993  1.00 12.13 ? 6  ASN A CB  1
ATOM   44 C CG  . ASN A 1 6 ? 5.961   2.735  2.003  1.00 12.77 ? 6  ASN A CG  1
ATOM   45 O OD1 . ASN A 1 6 ? 5.798   1.604  1.551  1.00 14.27 ? 6  ASN A OD1 1
ATOM   46 N ND2 . ASN A 1 6 ? 5.195   3.747  1.679  1.00 10.07 ? 6  ASN A ND2 1
ATOM   47 N N   . TYR A 1 7 ? 8.292   1.817  6.147  1.00 14.70 ? 7  TYR A N   1
ATOM   48 C CA  . TYR A 1 7 ? 9.159   2.144  7.299  1.00 15.18 ? 7  TYR A CA  1
ATOM   49 C C   . TYR A 1 7 ? 10.603  2.331  6.885  1.00 15.91 ? 7  TYR A C   1
ATOM   50 O O   . TYR A 1 7 ? 11.041  1.811  5.855  1.00 15.76 ? 7  TYR A O   1
ATOM   51 C CB  . TYR A 1 7 ? 9.061   1.065  8.369  1.00 15.35 ? 7  TYR A CB  1
ATOM   52 C CG  . TYR A 1 7 ? 7.665   0.929  8.902  1.00 14.45 ? 7  TYR A CG  1
ATOM   53 C CD1 . TYR A 1 7 ? 6.771   0.021  8.327  1.00 15.68 ? 7  TYR A CD1 1
ATOM   54 C CD2 . TYR A 1 7 ? 7.210   1.756  9.920  1.00 14.80 ? 7  TYR A CD2 1
ATOM   55 C CE1 . TYR A 1 7 ? 5.480   -0.094 8.796  1.00 13.46 ? 7  TYR A CE1 1
ATOM   56 C CE2 . TYR A 1 7 ? 5.904   1.649  10.416 1.00 14.33 ? 7  TYR A CE2 1
ATOM   57 C CZ  . TYR A 1 7 ? 5.047   0.729  9.831  1.00 15.09 ? 7  TYR A CZ  1
ATOM   58 O OH  . TYR A 1 7 ? 3.766   0.589  10.291 1.00 14.39 ? 7  TYR A OH  1
ATOM   59 O OXT . TYR A 1 7 ? 11.358  2.999  7.612  1.00 17.49 ? 7  TYR A OXT 1
'''

ligand_cif = """\
data_comp_list
loop_
_chem_comp.id
_chem_comp.three_letter_code
_chem_comp.name
_chem_comp.group
_chem_comp.number_atoms_all
_chem_comp.number_atoms_nh
_chem_comp.desc_level
_chem_comp.initial_date
_chem_comp.modified_date
_chem_comp.source
 longGLY longGLY 'GLYCINE                             ' L-peptide 7 4 . 2009-08-12 2012-12-06
;
Copy of CCP4 Monomer Library entry.
Added neutron distances
;
#
data_comp_longGLY
#
loop_
_chem_comp_atom.comp_id
_chem_comp_atom.atom_id
_chem_comp_atom.type_symbol
_chem_comp_atom.type_energy
_chem_comp_atom.partial_charge
 longGLY           N      N    NH1      -0.204
 longGLY           H      H    HNH1      0.204
 longGLY           CA     C    CH2       0.002
 longGLY           HA1    H    HCH2      0.051
 longGLY           HA2    H    HCH2      0.051
 longGLY           C      C    C         0.318
 longGLY           O      O    O        -0.422
loop_
_chem_comp_tree.comp_id
_chem_comp_tree.atom_id
_chem_comp_tree.atom_back
_chem_comp_tree.atom_forward
_chem_comp_tree.connect_type
 longGLY      N      n/a    CA     START
 longGLY      H      N      .      .
 longGLY      CA     N      C      .
 longGLY      HA1    CA     .      .
 longGLY      HA2    CA     .      .
 longGLY      C      CA     .      END
 longGLY      O      C      .      .
loop_
_chem_comp_bond.comp_id
_chem_comp_bond.atom_id_1
_chem_comp_bond.atom_id_2
_chem_comp_bond.type
_chem_comp_bond.value_dist
_chem_comp_bond.value_dist_esd
_chem_comp_bond.value_dist_neutron
 longGLY      N      H         coval       0.860    0.020    1.020
 longGLY      N      CA        coval       1.451    0.016    1.451
 longGLY      CA     HA1       coval       0.970    0.020    1.090
 longGLY      CA     HA2       coval       0.970    0.020    1.090
 longGLY      CA     C         coval       1.516    0.018    1.516
 longGLY      C      O         coval       1.231    0.020    1.231
loop_
_chem_comp_angle.comp_id
_chem_comp_angle.atom_id_1
_chem_comp_angle.atom_id_2
_chem_comp_angle.atom_id_3
_chem_comp_angle.value_angle
_chem_comp_angle.value_angle_esd
 longGLY      H      N      CA      114.000    3.000
 longGLY      HA1    CA     HA2     109.000    3.000
 longGLY      HA2    CA     C       109.000    3.000
 longGLY      HA1    CA     C       109.000    3.000
 longGLY      N      CA     HA1     110.000    3.000
 longGLY      N      CA     HA2     110.000    3.000
 longGLY      N      CA     C       113.300    2.900
 longGLY      CA     C      O       120.800    2.100
"""

def test1():
  """
  Creating restraints for long residue name
  """
  #dumping to disk if needed:
  # for name, s in [('model', mm_cif), ('restr', ligand_cif)]:
  #   with open('%s.cif' % name, 'w') as f:
  #     f.write(s)
  inp = iotbx.pdb.input(lines=mm_cif.split("\n"), source_info=None)
  cif_object = iotbx.cif.reader(input_string = ligand_cif).model()
  cif_objects = [('bla.cif', cif_object)]
  model = mmtbx.model.manager(
      model_input = inp,
      restraint_objects = cif_objects)
  try:
    model.process(make_restraints=True)
    geo_str = model.restraints_as_geo()
  except Sorry as e:
    pass
  # print(geo_str)
  for l in [
    'bond pdb=" C   ASN A   3 "',
    '     pdb=" N   longGLY A   4 "',
    'nonbonded pdb=" C   longGLY A   4 "',
    '          pdb=" CD  GLN A   5 "',
    ]:
    # print(geo_str.find(l),l)
    assert_lines_in_text(geo_str, l)
  model_cif = model.model_as_mmcif()
  # print(model_cif)
  for l in [
    '   ATOM 21 N . longGLY A 4 ? -1.00500 2.22800 3.59800 1.000 10.29000 N ? B ? . 1',
    'longGLY N H coval 0.860 0.020 1.020',
    'data_comp_longGLY',
    ]:
    assert_lines_in_text(model_cif, l)
  model_pdb = model.model_as_pdb()
  # print(model_pdb)
  assert not model.can_be_output_as_pdb()

def test2():
  """
  Try creating restraints for long residue name without cif.
  Check error message formatting in
  Number of atoms with unknown nonbonded energy
  (atom.quote() function)
  """
  #dumping to disk if needed:
  # for name, s in [('model', mm_cif), ('restr', ligand_cif)]:
  #   with open('%s.cif' % name, 'w') as f:
  #     f.write(s)
  inp = iotbx.pdb.input(lines=mm_cif.split("\n"), source_info=None)
  # cif_object = iotbx.cif.reader(input_string = ligand_cif).model()
  # cif_objects = [('bla.cif', cif_object)]
  mlog = StringIO()
  model = mmtbx.model.manager(
      model_input = inp,
      log = mlog)
  try:
    model.process(make_restraints=True)
  except Sorry as e:
    mlog_txt = mlog.getvalue()
    # print(str(e))
    print(mlog_txt)
    assert_lines_in_text(mlog_txt, """ "ATOM     22  CA  longGLY A   4 .*.     C  " """)
    assert_lines_in_text(mlog_txt, """ Unknown residues: {'longGLY': 1} """)


if (__name__ == "__main__"):
  t0 = time.time()
  mon_lib_srv = None
  try:
    mon_lib_srv = monomer_library.server.server()
  except: # intentional
    print("Can not initialize monomer_library, skipping test.")
  if mon_lib_srv is not None:
    test1()
    test2()
  print("OK. Time: %8.3f"%(time.time()-t0))


 *******************************************************************************


 *******************************************************************************
iotbx/regression/tst_hierarchy_merge_atoms_at_end_to_residues.py
from __future__ import absolute_import, division, print_function
import iotbx.pdb

def exercise_1():
  pdb_str_1 = """\
ATOM   1492  N   TYR 1   7     -13.645   6.683   6.147  1.00 14.70           N
ATOM   1493  CA  TYR 1   7     -12.778   7.010   7.299  1.00 15.18           C
ATOM   1494  C   TYR 1   7     -11.334   7.197   6.885  1.00 15.91           C
ATOM   1495  O   TYR 1   7     -10.896   6.677   5.855  1.00 15.76           O
ATOM   1496  CB  TYR 1   7     -12.876   5.931   8.369  1.00 15.35           C
ATOM   1497  CG  TYR 1   7     -14.272   5.795   8.902  1.00 14.45           C
ATOM   1498  CD1 TYR 1   7     -14.727   6.622   9.920  1.00 14.80           C
ATOM   1499  CD2 TYR 1   7     -15.166   4.887   8.327  1.00 15.68           C
ATOM   1500  CE1 TYR 1   7     -16.033   6.515  10.416  1.00 14.33           C
ATOM   1501  CE2 TYR 1   7     -16.457   4.772   8.796  1.00 13.46           C
ATOM   1502  CZ  TYR 1   7     -16.890   5.595   9.831  1.00 15.09           C
ATOM   1503  OH  TYR 1   7     -18.171   5.455  10.291  1.00 14.39           O
ATOM   1504  OXT TYR 1   7     -10.579   7.865   7.612  1.00 17.49           O
ATOM   1505  H   TYR 1   7     -13.863   5.691   6.055  0.00 14.70           H
ATOM   1506  HA  TYR 1   7     -13.122   7.951   7.728  0.00 15.18           H
ATOM   1507  HB2 TYR 1   7     -12.217   6.188   9.199  0.00 15.35           H
ATOM   1508  HB3 TYR 1   7     -12.579   4.974   7.941  0.00 15.35           H
ATOM   1509  HD1 TYR 1   7     -14.061   7.362  10.338  0.00 14.80           H
ATOM   1510  HD2 TYR 1   7     -14.841   4.267   7.504  0.00 15.68           H
ATOM   1511  HE1 TYR 1   7     -16.365   7.135  11.236  0.00 14.33           H
ATOM   1512  HE2 TYR 1   7     -17.129   4.047   8.362  0.00 13.46           H
ATOM   1513  HH  TYR 1   7     -18.330   6.073  11.035  0.00 14.39           H
TER
ATOM   1560  N   GLN 3   4     -20.932   4.661  -3.598  1.00 10.29           N
ATOM   1561  CA  GLN 3   4     -22.321   4.321  -3.199  1.00 10.53           C
ATOM   1562  C   GLN 3   4     -23.372   5.039  -4.088  1.00 10.24           C
ATOM   1563  O   GLN 3   4     -23.484   6.276  -4.115  1.00  8.86           O
ATOM   1564  CB  GLN 3   4     -22.593   4.581  -1.711  1.00  9.80           C
ATOM   1565  CG  GLN 3   4     -23.881   3.891  -1.213  1.00 10.25           C
ATOM   1566  CD  GLN 3   4     -24.441   4.477   0.089  1.00 12.43           C
ATOM   1567  OE1 GLN 3   4     -24.681   5.701   0.190  1.00 14.62           O
ATOM   1568  NE2 GLN 3   4     -24.687   3.594   1.091  1.00  9.05           N
ATOM   1569  H   GLN 3   4     -20.775   5.669  -3.622  0.00 10.29           H
ATOM   1570  HA  GLN 3   4     -22.442   3.248  -3.346  0.00 10.53           H
ATOM   1571  HB2 GLN 3   4     -22.701   5.654  -1.552  0.00  9.80           H
ATOM   1572  HB3 GLN 3   4     -21.757   4.199  -1.125  0.00  9.80           H
ATOM   1573  HG2 GLN 3   4     -24.650   3.992  -1.979  0.00 10.25           H
ATOM   1574  HG3 GLN 3   4     -23.667   2.837  -1.036  0.00 10.25           H
ATOM   1575 HE21 GLN 3   4     -25.060   3.924   1.981  0.00  9.05           H
ATOM   1576 HE22 GLN 3   4     -24.499   2.601   0.953  0.00  9.05           H
TER
ATOM         H2  GLN 1   4     -23.584   6.695   2.944  1.00 10.29           H
TER
ATOM         HC  GLN 3   4     -23.988   4.503  -4.665  1.00 10.24           H
TER
"""
  h = iotbx.pdb.input(lines=pdb_str_1, source_info=None).construct_hierarchy()
  atoms_in_chains = [(c.id, c.atoms_size()) for c in h.only_model().chains()]
  print (atoms_in_chains)
  assert atoms_in_chains == [('1', 22), ('3', 17), ('1', 1), ('3', 1)], atoms_in_chains

  h.merge_atoms_at_end_to_residues()
  atoms_in_chains2 = [(c.id, c.atoms_size()) for c in h.only_model().chains()]
  # Note that the second chain '3' is removed and there's no chain with zero atoms.
  print (atoms_in_chains2)
  assert atoms_in_chains2 == [('1', 22), ('3', 18), ('1', 1)], atoms_in_chains

if (__name__ == "__main__"):
  exercise_1()
  print("OK")


 *******************************************************************************


 *******************************************************************************
iotbx/regression/tst_hierarchy_occupancies_rounding.py
from __future__ import absolute_import, division, print_function
import iotbx.pdb
from scitbx.array_family import flex
from libtbx.test_utils import assert_lines_in_text

def tst_1():
  pdb_str = """\
ATOM   3705  N   PRO A 839     -72.061   7.475  91.699  1.00 19.22           N
ATOM   3706  CA  PRO A 839     -71.162   6.864  90.749  1.00 15.72           C
ATOM   3707  C   PRO A 839     -70.566   7.946  89.845  1.00 19.35           C
ATOM   3708  O   PRO A 839     -71.127   9.016  89.760  1.00 16.63           O
ATOM   3709  CB  PRO A 839     -72.065   5.933  89.906  1.00 21.17           C
ATOM   3710  CG  PRO A 839     -73.211   5.597  90.858  1.00 24.24           C
ATOM   3711  CD  PRO A 839     -73.429   6.917  91.585  1.00 16.35           C
ATOM   3719  N  AMET A 840     -69.536   7.589  89.072  0.22 22.15           N
ATOM   3720  CA AMET A 840     -68.907   8.564  88.135  0.22 20.67           C
ATOM   3721  C  AMET A 840     -69.805   8.754  86.915  0.22 19.08           C
ATOM   3722  O  AMET A 840     -70.492   7.790  86.550  0.22 20.65           O
ATOM   3723  CB AMET A 840     -67.538   8.082  87.621  0.22 21.34           C
ATOM   3724  CG AMET A 840     -66.422   8.081  88.677  0.22 26.22           C
ATOM   3725  SD AMET A 840     -64.849   7.459  88.020  0.22 35.67           S
ATOM   3726  CE AMET A 840     -64.456   8.716  86.804  0.22 27.23           C
ATOM   3736  N  BMET A 840     -69.531   7.591  89.077  0.42 22.17           N
ATOM   3737  CA BMET A 840     -68.906   8.565  88.135  0.42 20.62           C
ATOM   3738  C  BMET A 840     -69.810   8.756  86.920  0.42 18.97           C
ATOM   3739  O  BMET A 840     -70.488   7.791  86.549  0.42 20.61           O
ATOM   3740  CB BMET A 840     -67.543   8.081  87.610  0.42 21.27           C
ATOM   3741  CG BMET A 840     -66.418   8.078  88.653  0.42 26.27           C
ATOM   3742  SD BMET A 840     -64.866   7.435  87.968  0.42 35.93           S
ATOM   3743  CE BMET A 840     -65.243   5.686  87.845  0.42 17.98           C
ATOM   3753  N  CMET A 840     -69.533   7.590  89.075  0.36 22.17           N
ATOM   3754  CA CMET A 840     -68.906   8.564  88.135  0.36 20.64           C
ATOM   3755  C  CMET A 840     -69.808   8.756  86.919  0.36 19.02           C
ATOM   3756  O  CMET A 840     -70.489   7.791  86.549  0.36 20.62           O
ATOM   3757  CB CMET A 840     -67.542   8.079  87.611  0.36 21.30           C
ATOM   3758  CG CMET A 840     -66.426   8.032  88.663  0.36 26.24           C
ATOM   3759  SD CMET A 840     -64.891   7.366  87.964  0.36 35.95           S
ATOM   3760  CE CMET A 840     -63.880   7.218  89.436  0.36 19.93           C
ATOM   3770  N   ASP A 841     -69.924   9.986  86.413  1.00 20.11           N
ATOM   3771  CA  ASP A 841     -70.719  10.250  85.211  1.00 23.77           C
ATOM   3772  C   ASP A 841     -72.158   9.760  85.347  1.00 26.73           C
ATOM   3773  O   ASP A 841     -72.719   9.126  84.444  1.00 26.93           O
ATOM   3774  CB  ASP A 841     -70.043   9.623  83.985  1.00 20.96           C
ATOM   3775  CG  ASP A 841     -68.601  10.057  83.840  1.00 38.39           C
ATOM   3776  OD1 ASP A 841     -68.357  11.284  83.832  1.00 51.85           O
ATOM   3777  OD2 ASP A 841     -67.711   9.179  83.749  1.00 53.14           O
"""
  h = iotbx.pdb.input(lines=pdb_str, source_info=None).construct_hierarchy()
  h_atoms = h.atoms()
  ogs = h.occupancy_groups_simple()
  # set occupancy values that will be rounded wrong
  test_occ = [0.225, 0.225, 0.55]
  for i, g in enumerate(ogs[0]):
    h_atoms.select(flex.size_t(g)).set_occ(flex.double([test_occ[i]]*len(g)))
  # observe wrong rounding
  wrong_pdb_str = h.as_pdb_string()
  assert_lines_in_text(wrong_pdb_str, """\
ATOM      8  N  AMET A 840     -69.536   7.589  89.072  0.23 22.15           N
ATOM      9  CA AMET A 840     -68.907   8.564  88.135  0.23 20.67           C
ATOM     10  C  AMET A 840     -69.805   8.754  86.915  0.23 19.08           C
ATOM     11  O  AMET A 840     -70.492   7.790  86.550  0.23 20.65           O
ATOM     12  CB AMET A 840     -67.538   8.082  87.621  0.23 21.34           C
ATOM     13  CG AMET A 840     -66.422   8.081  88.677  0.23 26.22           C
ATOM     14  SD AMET A 840     -64.849   7.459  88.020  0.23 35.67           S
ATOM     15  CE AMET A 840     -64.456   8.716  86.804  0.23 27.23           C
ATOM     16  N  BMET A 840     -69.531   7.591  89.077  0.23 22.17           N
ATOM     17  CA BMET A 840     -68.906   8.565  88.135  0.23 20.62           C
ATOM     18  C  BMET A 840     -69.810   8.756  86.920  0.23 18.97           C
ATOM     19  O  BMET A 840     -70.488   7.791  86.549  0.23 20.61           O
ATOM     20  CB BMET A 840     -67.543   8.081  87.610  0.23 21.27           C
ATOM     21  CG BMET A 840     -66.418   8.078  88.653  0.23 26.27           C
ATOM     22  SD BMET A 840     -64.866   7.435  87.968  0.23 35.93           S
ATOM     23  CE BMET A 840     -65.243   5.686  87.845  0.23 17.98           C
ATOM     24  N  CMET A 840     -69.533   7.590  89.075  0.55 22.17           N
ATOM     25  CA CMET A 840     -68.906   8.564  88.135  0.55 20.64           C
ATOM     26  C  CMET A 840     -69.808   8.756  86.919  0.55 19.02           C
ATOM     27  O  CMET A 840     -70.489   7.791  86.549  0.55 20.62           O
ATOM     28  CB CMET A 840     -67.542   8.079  87.611  0.55 21.30           C
ATOM     29  CG CMET A 840     -66.426   8.032  88.663  0.55 26.24           C
ATOM     30  SD CMET A 840     -64.891   7.366  87.964  0.55 35.95           S
ATOM     31  CE CMET A 840     -63.880   7.218  89.436  0.55 19.93           C
    """)
  h.round_occupancies_in_place(2)
  correct_pdb_str = h.as_pdb_string()
  assert_lines_in_text(correct_pdb_str, """\
ATOM      8  N  AMET A 840     -69.536   7.589  89.072  0.23 22.15           N
ATOM      9  CA AMET A 840     -68.907   8.564  88.135  0.23 20.67           C
ATOM     10  C  AMET A 840     -69.805   8.754  86.915  0.23 19.08           C
ATOM     11  O  AMET A 840     -70.492   7.790  86.550  0.23 20.65           O
ATOM     12  CB AMET A 840     -67.538   8.082  87.621  0.23 21.34           C
ATOM     13  CG AMET A 840     -66.422   8.081  88.677  0.23 26.22           C
ATOM     14  SD AMET A 840     -64.849   7.459  88.020  0.23 35.67           S
ATOM     15  CE AMET A 840     -64.456   8.716  86.804  0.23 27.23           C
ATOM     16  N  BMET A 840     -69.531   7.591  89.077  0.22 22.17           N
ATOM     17  CA BMET A 840     -68.906   8.565  88.135  0.22 20.62           C
ATOM     18  C  BMET A 840     -69.810   8.756  86.920  0.22 18.97           C
ATOM     19  O  BMET A 840     -70.488   7.791  86.549  0.22 20.61           O
ATOM     20  CB BMET A 840     -67.543   8.081  87.610  0.22 21.27           C
ATOM     21  CG BMET A 840     -66.418   8.078  88.653  0.22 26.27           C
ATOM     22  SD BMET A 840     -64.866   7.435  87.968  0.22 35.93           S
ATOM     23  CE BMET A 840     -65.243   5.686  87.845  0.22 17.98           C
ATOM     24  N  CMET A 840     -69.533   7.590  89.075  0.55 22.17           N
ATOM     25  CA CMET A 840     -68.906   8.564  88.135  0.55 20.64           C
ATOM     26  C  CMET A 840     -69.808   8.756  86.919  0.55 19.02           C
ATOM     27  O  CMET A 840     -70.489   7.791  86.549  0.55 20.62           O
ATOM     28  CB CMET A 840     -67.542   8.079  87.611  0.55 21.30           C
ATOM     29  CG CMET A 840     -66.426   8.032  88.663  0.55 26.24           C
ATOM     30  SD CMET A 840     -64.891   7.366  87.964  0.55 35.95           S
ATOM     31  CE CMET A 840     -63.880   7.218  89.436  0.55 19.93           C
    """)

if (__name__ == "__main__"):
  tst_1()
  print('OK')


 *******************************************************************************


 *******************************************************************************
iotbx/regression/tst_hierarchy_pdb_v3.py
from __future__ import absolute_import, division, print_function
import time
import iotbx.pdb

# ------------------------------------------------------------------------------

# from https://github.com/wwPDB/extended-wwPDB-identifier-examples
# https://github.com/wwPDB/extended-wwPDB-identifier-examples/blob/main/Models/7fgz-extended_CCD_code-model.cif
mmcif_str = '''
data_XXXX
#
loop_
_atom_site.group_PDB
_atom_site.id
_atom_site.type_symbol
_atom_site.label_atom_id
_atom_site.label_alt_id
_atom_site.label_comp_id
_atom_site.label_asym_id
_atom_site.label_entity_id
_atom_site.label_seq_id
_atom_site.pdbx_PDB_ins_code
_atom_site.Cartn_x
_atom_site.Cartn_y
_atom_site.Cartn_z
_atom_site.occupancy
_atom_site.B_iso_or_equiv
_atom_site.pdbx_formal_charge
_atom_site.auth_seq_id
_atom_site.auth_comp_id
_atom_site.auth_asym_id
_atom_site.auth_atom_id
_atom_site.pdbx_PDB_model_num
ATOM   2140 N  N   . LYS A 1 261 ? 0.399   -10.171 39.802 1.00 40.11 ? 279 LYS A N   1
ATOM   2141 C  CA  . LYS A 1 261 ? -0.169  -9.988  41.173 1.00 43.86 ? 279 LYS A CA  1
ATOM   2142 C  C   . LYS A 1 261 ? 0.687   -9.011  41.991 1.00 41.94 ? 279 LYS A C   1
ATOM   2143 O  O   . LYS A 1 261 ? 1.044   -7.920  41.556 1.00 39.32 ? 279 LYS A O   1
ATOM   2144 C  CB  . LYS A 1 261 ? -0.260  -11.336 41.902 1.00 46.47 ? 279 LYS A CB  1
ATOM   2145 C  CG  . LYS A 1 261 ? -1.583  -12.074 41.713 1.00 49.13 ? 279 LYS A CG  1
ATOM   2146 C  CD  . LYS A 1 261 ? -1.611  -13.468 42.315 1.00 51.03 ? 279 LYS A CD  1
ATOM   2147 C  CE  . LYS A 1 261 ? -2.923  -13.799 42.993 1.00 52.86 ? 279 LYS A CE  1
ATOM   2148 N  NZ  . LYS A 1 261 ? -3.209  -12.856 44.100 1.00 54.19 ? 279 LYS A NZ  1
HETATM 2149 CA CA  . CA  B 2 .   ? -17.362 -22.385 28.047 1.00 15.20 ? 301 CA  A CA  1
HETATM 2150 N  N1  . 7ZTVU C 3 .   ? -7.743  -6.355  8.243  1.00 18.72 ? 302 7ZTVU A N1  1
HETATM 2151 C  C2  . 7ZTVU C 3 .   ? -8.462  -5.534  9.265  1.00 16.68 ? 302 7ZTVU A C2  1
HETATM 2152 C  C3  . 7ZTVU C 3 .   ? -8.092  -5.865  10.711 1.00 17.35 ? 302 7ZTVU A C3  1
HETATM 2153 N  N4  . 7ZTVU C 3 .   ? -7.975  -7.334  10.767 1.00 17.04 ? 302 7ZTVU A N4  1
HETATM 2154 C  C5  . 7ZTVU C 3 .   ? -6.781  -7.689  10.027 1.00 17.11 ? 302 7ZTVU A C5  1
HETATM 2155 C  C6  . 7ZTVU C 3 .   ? -7.363  -7.730  8.633  1.00 16.97 ? 302 7ZTVU A C6  1
HETATM 2156 C  C7  . 7ZTVU C 3 .   ? -8.071  -7.951  12.064 1.00 16.77 ? 302 7ZTVU A C7  1
HETATM 2157 C  C8  . 7ZTVU C 3 .   ? -8.490  -9.440  12.025 1.00 16.60 ? 302 7ZTVU A C8  1
HETATM 2158 O  O8  . 7ZTVU C 3 .   ? -8.391  -10.140 10.781 1.00 14.14 ? 302 7ZTVU A O8  1
HETATM 2159 C  C9  . 7ZTVU C 3 .   ? -8.438  -6.311  6.935  1.00 20.13 ? 302 7ZTVU A C9  1
HETATM 2160 C  C10 . 7ZTVU C 3 .   ? -7.646  -6.965  5.796  1.00 22.62 ? 302 7ZTVU A C10 1
HETATM 2161 S  S   . 7ZTVU C 3 .   ? -8.372  -6.708  4.279  1.00 24.90 ? 302 7ZTVU A S   1
HETATM 2162 O  O1S . 7ZTVU C 3 .   ? -7.579  -7.371  3.224  1.00 25.47 ? 302 7ZTVU A O1S 1
HETATM 2163 O  O2S . 7ZTVU C 3 .   ? -8.533  -5.211  4.078  1.00 25.01 ? 302 7ZTVU A O2S 1
HETATM 2164 O  O3S . 7ZTVU C 3 .   ? -9.691  -7.326  4.282  1.00 26.42 ? 302 7ZTVU A O3S 1
HETATM 2165 N  N1  . 7ZTVU D 3 .   ? -11.233 1.732   10.446 1.00 74.61 ? 303 7ZTVU A N1  1
HETATM 2166 C  C2  . 7ZTVU D 3 .   ? -11.682 2.495   9.264  1.00 77.03 ? 303 7ZTVU A C2  1
HETATM 2167 C  C3  . 7ZTVU D 3 .   ? -11.907 3.979   9.617  1.00 76.82 ? 303 7ZTVU A C3  1
HETATM 2168 N  N4  . 7ZTVU D 3 .   ? -12.335 4.282   11.022 1.00 73.77 ? 303 7ZTVU A N4  1
HETATM 2169 C  C5  . 7ZTVU D 3 .   ? -12.654 3.123   11.908 1.00 69.90 ? 303 7ZTVU A C5  1
HETATM 2170 C  C6  . 7ZTVU D 3 .   ? -12.333 1.719   11.409 1.00 69.07 ? 303 7ZTVU A C6  1
HETATM 2171 C  C7  . 7ZTVU D 3 .   ? -11.415 5.232   11.725 1.00 71.46 ? 303 7ZTVU A C7  1
HETATM 2172 C  C8  . 7ZTVU D 3 .   ? -12.126 5.976   12.871 1.00 70.74 ? 303 7ZTVU A C8  1
HETATM 2173 O  O8  . 7ZTVU D 3 .   ? -11.360 5.921   14.096 1.00 61.89 ? 303 7ZTVU A O8  1
HETATM 2174 C  C9  . 7ZTVU D 3 .   ? -10.756 0.357   10.142 1.00 74.40 ? 303 7ZTVU A C9  1
HETATM 2175 C  C10 . 7ZTVU D 3 .   ? -10.121 -0.289  11.396 1.00 75.92 ? 303 7ZTVU A C10 1
HETATM 2176 S  S   . 7ZTVU D 3 .   ? -8.757  -1.214  11.091 1.00 77.53 ? 303 7ZTVU A S   1
HETATM 2177 O  O1S . 7ZTVU D 3 .   ? -7.735  -0.305  10.525 1.00 74.01 ? 303 7ZTVU A O1S 1
HETATM 2178 O  O2S . 7ZTVU D 3 .   ? -9.042  -2.313  10.141 1.00 83.78 ? 303 7ZTVU A O2S 1
HETATM 2179 O  O3S . 7ZTVU D 3 .   ? -8.264  -1.864  12.321 1.00 70.44 ? 303 7ZTVU A O3S 1
HETATM 2180 O  O   . HOH E 4 .   ? 10.567  -6.539  28.064 1.00 30.11 ? 401 HOH A O   1
HETATM 2181 O  O   . HOH E 4 .   ? 2.856   -8.848  40.692 1.00 32.14 ? 402 HOH A O   1
HETATM 2182 O  O   . HOH E 4 .   ? -10.577 -29.762 22.833 1.00 22.07 ? 403 HOH A O   1
HETATM 2183 O  O   . HOH E 4 .   ? 14.705  -5.437  13.988 1.00 28.06 ? 404 HOH A O   1
'''
mmcif_str_1 = '''data_default
loop_
  _struct_asym.id
   A
   B

loop_
  _chem_comp.id
   GLYD
   GLYHABC

loop_
  _atom_site.group_PDB
  _atom_site.id
  _atom_site.label_atom_id
  _atom_site.label_alt_id
  _atom_site.label_comp_id
  _atom_site.auth_asym_id
  _atom_site.auth_seq_id
  _atom_site.pdbx_PDB_ins_code
  _atom_site.Cartn_x
  _atom_site.Cartn_y
  _atom_site.Cartn_z
  _atom_site.occupancy
  _atom_site.B_iso_or_equiv
  _atom_site.type_symbol
  _atom_site.pdbx_formal_charge
  _atom_site.label_asym_id
  _atom_site.label_entity_id
  _atom_site.label_seq_id
  _atom_site.pdbx_PDB_model_num
   ATOM 1 CA . GLYG ABCDEFG 1 ? 12.47000 12.95700 8.06900 1.000 30.00000 C ? A ? 1 1
   ATOM 2 CA . GLYHABCD DEFGHIL 1 ? 12.47000 12.95700 8.06900 1.000 30.00000 C ? B ? 1 1
'''

def test1():
  """
  Test methods in conversion_tables with mmcif_str
  """
  inp = iotbx.pdb.input(lines=mmcif_str.split("\n"), source_info=None)
  ph = inp.construct_hierarchy()

  from iotbx.pdb.forward_compatible_pdb_cif_conversion import forward_compatible_pdb_cif_conversion
  conversion_info = forward_compatible_pdb_cif_conversion(hierarchy = ph)
  print(conversion_info.conversion_as_remark_hetnam_string())

def test2():
  """
  Test methods in conversion_tables with mmcif_str_1
  """
  inp = iotbx.pdb.input(lines=mmcif_str_1.split("\n"), source_info=None)
  ph = inp.construct_hierarchy()

  from iotbx.pdb.forward_compatible_pdb_cif_conversion import forward_compatible_pdb_cif_conversion
  conversion_info = forward_compatible_pdb_cif_conversion(hierarchy = ph)
  print(conversion_info.conversion_as_remark_hetnam_string())

def test3():
  """
  Test methods in conversion_tables with mmcif_str_1 and
    set_conversion_tables_from_remark_hetnam_records
  """
  inp = iotbx.pdb.input(lines=mmcif_str_1.split("\n"), source_info=None)
  ph = inp.construct_hierarchy()

  from iotbx.pdb.forward_compatible_pdb_cif_conversion import forward_compatible_pdb_cif_conversion
  conversion_info = forward_compatible_pdb_cif_conversion(hierarchy = ph,
    residue_conversion_as_remark = True)
  remark_hetnam_string = conversion_info.conversion_as_remark_hetnam_string()

  new_conversion_info = forward_compatible_pdb_cif_conversion()
  new_conversion_info.set_conversion_tables_from_remark_hetnam_records(
    remark_hetnam_records = remark_hetnam_string.splitlines())
  new_remark_hetnam_string = new_conversion_info.conversion_as_remark_hetnam_string()
  print(new_remark_hetnam_string)
  assert remark_hetnam_string == new_remark_hetnam_string

def test3a():
  """
  Test methods in conversion_tables with mmcif_str_1 and
    set_conversion_tables_from_remark_hetnam_records
  """
  inp = iotbx.pdb.input(lines=mmcif_str_1.split("\n"), source_info=None)
  ph = inp.construct_hierarchy()

  from iotbx.pdb.forward_compatible_pdb_cif_conversion import forward_compatible_pdb_cif_conversion
  conversion_info = forward_compatible_pdb_cif_conversion(hierarchy = ph,
    residue_conversion_as_remark = False,
    residue_conversion_as_hetnam = True,
     )
  remark_hetnam_string = conversion_info.conversion_as_remark_hetnam_string()
  print("OLD\n",remark_hetnam_string)

  new_conversion_info = forward_compatible_pdb_cif_conversion(
     residue_conversion_as_remark = False,
     residue_conversion_as_hetnam = True,
     )
  new_conversion_info.set_conversion_tables_from_remark_hetnam_records(
    remark_hetnam_records = remark_hetnam_string.splitlines())
  new_remark_hetnam_string = new_conversion_info.conversion_as_remark_hetnam_string()
  print("NEW\n",new_remark_hetnam_string)
  assert remark_hetnam_string == new_remark_hetnam_string

def test4():
  """
  Test methods in conversion_tables with mmcif_str_1 and
    set_conversion_tables_from_remark_hetnam_records and read remarks as part
    of input string
  """
  inp = iotbx.pdb.input(lines=mmcif_str_1.split("\n"), source_info=None)
  ph = inp.construct_hierarchy()

  from iotbx.pdb.forward_compatible_pdb_cif_conversion import forward_compatible_pdb_cif_conversion
  conversion_info = forward_compatible_pdb_cif_conversion(hierarchy = ph)
  remark_hetnam_string = conversion_info.conversion_as_remark_hetnam_string()

  # convert to forward_compatible_pdb
  conversion_info.convert_hierarchy_to_forward_compatible_pdb_representation(ph)
  new_string = ph.as_pdb_string()
  print("NEW STRING (forward_compatible_pdb)\n%s" %(new_string))
  new_inp = iotbx.pdb.input(lines=(remark_hetnam_string + new_string).split("\n"),
      source_info=None,
      )
  new_remark_hetnam_string = "\n".join(new_inp.remark_section())
  new_ph = new_inp.construct_hierarchy()
  print("New ph as string:\n",new_ph.as_pdb_string())

  from iotbx.pdb.forward_compatible_pdb_cif_conversion import forward_compatible_pdb_cif_conversion
  new_conversion_info = forward_compatible_pdb_cif_conversion()
  new_conversion_info.set_conversion_tables_from_remark_hetnam_records(
    remark_hetnam_records = new_remark_hetnam_string.splitlines())
  updated_remark_hetnam_string = new_conversion_info.conversion_as_remark_hetnam_string()
  print("\nNew remark string:\n",new_remark_hetnam_string)
  print("\nUpdated remark string:\n",updated_remark_hetnam_string)
  assert remark_hetnam_string == updated_remark_hetnam_string

def test5():
  """
  Test standard uses of forward_compatible_pdb to hierarchy conversions
  """

  print("\nTest 5, standard uses of forward_compatible_pdb to hierarchy conversions")

  # Get a hierarchy that is not forward_compatible_pdb compatible
  from iotbx.pdb.forward_compatible_pdb_cif_conversion import pdb_or_mmcif_string_as_hierarchy
  ph = pdb_or_mmcif_string_as_hierarchy(mmcif_str_1).hierarchy

  # Write a forward_compatible_pdb compatible string with conversion information in REMARKs
  from iotbx.pdb.forward_compatible_pdb_cif_conversion import hierarchy_as_forward_compatible_pdb_string
  forward_compatible_pdb_string =  hierarchy_as_forward_compatible_pdb_string(ph)
  print("Hierarchy as forward_compatible_pdb string with REMARKS:\n%s" %(forward_compatible_pdb_string))

  # convert forward_compatible_pdb_string to a hierarchy
  from iotbx.pdb.forward_compatible_pdb_cif_conversion import pdb_or_mmcif_string_as_hierarchy
  new_ph = pdb_or_mmcif_string_as_hierarchy(forward_compatible_pdb_string).hierarchy
  new_forward_compatible_pdb_string =  hierarchy_as_forward_compatible_pdb_string(new_ph)
  print("Hierarchy after writing/reading as forward_compatible_pdb string with REMARKS:\n%s" %(new_forward_compatible_pdb_string))
  assert forward_compatible_pdb_string == new_forward_compatible_pdb_string

  # strip off REMARKS from forward_compatible_pdb_string, read in and apply conversions
  from iotbx.pdb.forward_compatible_pdb_cif_conversion import forward_compatible_pdb_cif_conversion
  conversion_info = forward_compatible_pdb_cif_conversion(ph)
  forward_compatible_pdb_string_no_remarks = remove_remarks_hetnam(forward_compatible_pdb_string)
  print("forward_compatible_pdb_string with no remarks:\n%s\n" %(forward_compatible_pdb_string_no_remarks))

  updated_ph = pdb_or_mmcif_string_as_hierarchy(forward_compatible_pdb_string_no_remarks).hierarchy
  # Apply the conversions to obtain a full representation in updated_ph
  conversion_info.convert_hierarchy_to_full_representation(updated_ph)

  # Get updated forward_compatible_pdb string
  updated_forward_compatible_pdb_string =  hierarchy_as_forward_compatible_pdb_string(updated_ph)
  print("Hierarchy after writing/reading as forward_compatible_pdb string without REMARKS and restoring conversion:\n%s" %(updated_forward_compatible_pdb_string))
  assert updated_forward_compatible_pdb_string == forward_compatible_pdb_string

  # Initialize conversion_info with unique_values_dict
  conversion_info = forward_compatible_pdb_cif_conversion(ph)
  unique_values_dict = {}
  unique_values_dict['chain_id'] = \
     conversion_info._unique_chain_ids_from_hierarchy(ph)
  unique_values_dict['resname'] = \
      conversion_info._unique_resnames_from_hierarchy(ph)
  new_conversion_info = forward_compatible_pdb_cif_conversion(
    unique_values_dict = unique_values_dict)
  print("\nConversion info using unique_values_dict:")
  print(conversion_info.conversion_as_remark_hetnam_string())
  assert conversion_info.conversion_as_remark_hetnam_string() == new_conversion_info.conversion_as_remark_hetnam_string()

def test6():
  print("Testing use of ph.as_mmcif_string(segid_as_auth_segid=True)")

  # Get a hierarchy
  from iotbx.pdb.forward_compatible_pdb_cif_conversion import pdb_or_mmcif_string_as_hierarchy
  ph = pdb_or_mmcif_string_as_hierarchy(mmcif_str_1).hierarchy
  # Add segid to the hierarchy
  i = 0
  for model in ph.models():
    for chain in model.chains():
        for residue_group in chain.residue_groups():
          for atom_group in residue_group.atom_groups():
            for atom in atom_group.atoms():
              atom.set_segid('UNK')
  # assert ph.as_pdb_string().find("UNK")>-1
  assert ph.as_mmcif_string().find("UNK") == -1
  assert ph.as_mmcif_string(segid_as_auth_segid=True).find("UNK") > -1
  # Test removing segid
  ph.remove_segid()
  assert ph.as_mmcif_string(segid_as_auth_segid=True).find("UNK") == -1

def remove_remarks_hetnam(text):
  new_text_list = []
  for line in text.splitlines():
    if line.startswith("REMARK"):continue
    if line.startswith("HETNAM"):continue
    new_text_list.append(line)
  return "\n".join(new_text_list)
if (__name__ == "__main__"):
  t0 = time.time()
  test1()
  test2()
  test3()
  test3a()
  test4()
  test5()
  test6()
  print("OK. Time: %8.3f"%(time.time()-t0))


 *******************************************************************************


 *******************************************************************************
iotbx/regression/tst_lattice_symmetry.py
from __future__ import absolute_import, division, print_function
from libtbx.test_utils import show_diff
from libtbx import easy_run
import sys

def run_and_compare(commands, expected_output):
  def digest(lines):
    result = []
    for line in lines:
      if (line.strip().startswith("Change of basis: ")): continue
      if (line.strip().startswith("Inverse: ")): continue
      result.append(line)
    result.sort()
    return "\n".join(result)+"\n"
  for command in commands:
    lines = easy_run.fully_buffered(
      command=command).raise_if_errors().stdout_lines
    assert not show_diff(digest(lines), digest(expected_output.splitlines()))

def exercise(args):
  assert len(args) == 0
  run_and_compare(
    ['iotbx.lattice_symmetry'
       ' --unit_cell="12.7923,12.8923,29.4356,102.846,103.846,22.7475"'],
    """\

Input
=====

Unit cell: (12.7923, 12.8923, 29.4356, 102.846, 103.846, 22.7475)
Space group: P 1 (No. 1)

Angular tolerance: 3.000 degrees

Similar symmetries
==================

Symmetry in minimum-lengths cell: C 1 2/m 1 (z,x-y,2*y) (No. 12)
      Input minimum-lengths cell: (5.06616, 12.7923, 29.1526, 78.6285, 87.746, 79.7351)
           Symmetry-adapted cell: (5.06616, 12.7923, 29.2944, 77.3884, 87.7702, 79.7351)
            Conventional setting: I 1 2/m 1 (No. 12)
                       Unit cell: (5.06616, 57.1752, 12.8923, 90, 102.483, 90)
                 Change of basis: -x+1/2*z,-1/2*z,-x-y+1/2*z
                         Inverse: -x-y,x-z,-2*y
      Maximal angular difference: 1.323 degrees

Symmetry in minimum-lengths cell: P -1 (No. 2)
      Input minimum-lengths cell: (5.06616, 12.7923, 29.1526, 78.6285, 87.746, 79.7351)
           Symmetry-adapted cell: (5.06616, 12.7923, 29.1526, 78.6285, 87.746, 79.7351)
            Conventional setting: P -1 (No. 2)
                       Unit cell: (5.06616, 12.7923, 29.1526, 78.6285, 87.746, 79.7351)
                 Change of basis: -y,x+y-z,z
                         Inverse: x+y+z,-x,z
      Maximal angular difference: 0.000 degrees

""")
  #
  run_and_compare(
    ['iotbx.lattice_symmetry --unit_cell=12,12.2,12.1,89,90,92 F',
     'cctbx.lattice_symmetry'],
    """\

Input
=====

Unit cell: (12, 12.2, 12.1, 89, 90, 92)
Space group: P 1 (-a+b+c,a-b+c,a+b-c) (No. 1)

Angular tolerance: 3.000 degrees

Similar symmetries
==================

Symmetry in minimum-lengths cell: F m -3 m (-x+y+z,x-y+z,x+y-z) (No. 225)
      Input minimum-lengths cell: (8.40567, 8.51612, 8.52071, 61.4489, 61.5879, 60.4641)
           Symmetry-adapted cell: (8.55619, 8.55619, 8.55619, 60, 60, 60)
            Conventional setting: F m -3 m (No. 225)
                       Unit cell: (12.1003, 12.1003, 12.1003, 90, 90, 90)
                 Change of basis: z,-x,-y
                         Inverse: -y,-z,x
      Maximal angular difference: 2.236 degrees

Symmetry in minimum-lengths cell: I 4/m m m (y-z,-x+z,x+z) (No. 139)
      Input minimum-lengths cell: (8.40567, 8.51612, 8.52071, 61.4489, 61.5879, 60.4641)
           Symmetry-adapted cell: (8.55628, 8.55614, 8.55614, 60.0011, 59.9994, 59.9994)
            Conventional setting: I 4/m m m (No. 139)
                       Unit cell: (8.55628, 8.55628, 12.1, 90, 90, 90)
                 Change of basis: -x+y,-x-y,z
                         Inverse: -1/2*x-1/2*y,1/2*x-1/2*y,z
      Maximal angular difference: 2.236 degrees

Symmetry in minimum-lengths cell: I 4/m m m (-y+z,x-z,y+z) (No. 139)
      Input minimum-lengths cell: (8.40567, 8.51612, 8.52071, 61.4489, 61.5879, 60.4641)
           Symmetry-adapted cell: (8.53852, 8.59142, 8.53852, 59.7948, 60.4103, 59.7948)
            Conventional setting: I 4/m m m (No. 139)
                       Unit cell: (8.59142, 8.59142, 12, 90, 90, 90)
                 Change of basis: -y+z,y+z,-x
                         Inverse: -z,-1/2*x+1/2*y,1/2*x+1/2*y
      Maximal angular difference: 2.236 degrees

Symmetry in minimum-lengths cell: I 4/m m m (y+z,-y+z,x-z) (No. 139)
      Input minimum-lengths cell: (8.40567, 8.51612, 8.52071, 61.4489, 61.5879, 60.4641)
           Symmetry-adapted cell: (8.57387, 8.57387, 8.52071, 60.2049, 60.2049, 59.5902)
            Conventional setting: I 4/m m m (No. 139)
                       Unit cell: (8.52071, 8.52071, 12.2, 90, 90, 90)
                 Change of basis: -x+z,-x-z,-y
                         Inverse: -1/2*x-1/2*y,-z,1/2*x-1/2*y
      Maximal angular difference: 2.236 degrees

Symmetry in minimum-lengths cell: R -3 m :R (No. 166)
      Input minimum-lengths cell: (8.40567, 8.51612, 8.52071, 61.4489, 61.5879, 60.4641)
           Symmetry-adapted cell: (8.481, 8.481, 8.481, 61.1714, 61.1714, 61.1714)
            Conventional setting: R -3 m :H (No. 166)
                       Unit cell: (8.63072, 8.63072, 20.5883, 90, 90, 120)
                 Change of basis: 4/3*x-2/3*y+2/3*z,2/3*x+2/3*y+4/3*z,-1/3*x-1/3*y+1/3*z
                         Inverse: 1/2*x-z,-1/2*x+1/2*y-z,1/2*y+z
      Maximal angular difference: 1.474 degrees

Symmetry in minimum-lengths cell: R -3 m :H (x+z,-y+z,-3*z) (No. 166)
      Input minimum-lengths cell: (8.40567, 8.51612, 8.52071, 61.4489, 61.5879, 60.4641)
           Symmetry-adapted cell: (8.481, 8.481, 8.63072, 60.5722, 60.5722, 60)
            Conventional setting: R -3 m :H (No. 166)
                       Unit cell: (8.481, 8.481, 21.3218, 90, 90, 120)
                 Change of basis: -4/3*x-2/3*y-2/3*z,-2/3*x+2/3*y-4/3*z,1/3*x-1/3*y-1/3*z
                         Inverse: -1/2*x+z,-1/2*x+1/2*y-z,-1/2*y-z
      Maximal angular difference: 1.498 degrees

Symmetry in minimum-lengths cell: R -3 m :H (-y+z,-3*z,x+z) (No. 166)
      Input minimum-lengths cell: (8.40567, 8.51612, 8.52071, 61.4489, 61.5879, 60.4641)
           Symmetry-adapted cell: (8.53148, 8.58082, 8.53148, 60.19, 60, 60.19)
            Conventional setting: R -3 m :H (No. 166)
                       Unit cell: (8.53148, 8.53148, 21.0788, 90, 90, 120)
                 Change of basis: -2/3*x+2/3*y+4/3*z,2/3*x+4/3*y+2/3*z,-1/3*x+1/3*y-1/3*z
                         Inverse: -1/2*x+1/2*y-z,1/2*y+z,1/2*x-z
      Maximal angular difference: 2.177 degrees

Symmetry in minimum-lengths cell: R -3 m :H (-3*z,x+z,-y+z) (No. 166)
      Input minimum-lengths cell: (8.40567, 8.51612, 8.52071, 61.4489, 61.5879, 60.4641)
           Symmetry-adapted cell: (8.53148, 8.58082, 8.58082, 60, 59.8085, 59.8085)
            Conventional setting: R -3 m :H (No. 166)
                       Unit cell: (8.58082, 8.58082, 20.8371, 90, 90, 120)
                 Change of basis: 2/3*x-4/3*y+2/3*z,4/3*x-2/3*y-2/3*z,1/3*x+1/3*y+1/3*z
                         Inverse: 1/2*y+z,-1/2*x+z,1/2*x-1/2*y+z
      Maximal angular difference: 2.177 degrees

Symmetry in minimum-lengths cell: I m m m (y-z,-x+z,x+z) (No. 71)
      Input minimum-lengths cell: (8.40567, 8.51612, 8.52071, 61.4489, 61.5879, 60.4641)
           Symmetry-adapted cell: (8.40567, 8.55614, 8.55614, 61.1489, 60.58, 60.58)
            Conventional setting: I m m m (No. 71)
                       Unit cell: (8.40567, 8.70429, 12.1, 90, 90, 90)
                 Change of basis: x+y,-x+y,z
                         Inverse: 1/2*x-1/2*y,1/2*x+1/2*y,z
      Maximal angular difference: 1.187 degrees

Symmetry in minimum-lengths cell: I m m m (-y+z,x-z,y+z) (No. 71)
      Input minimum-lengths cell: (8.40567, 8.51612, 8.52071, 61.4489, 61.5879, 60.4641)
           Symmetry-adapted cell: (8.53852, 8.51612, 8.53852, 60.0867, 60.9908, 60.0867)
            Conventional setting: I m m m (No. 71)
                       Unit cell: (8.51612, 8.66606, 12, 90, 90, 90)
                 Change of basis: -y+z,y+z,-x
                         Inverse: -z,-1/2*x+1/2*y,1/2*x+1/2*y
      Maximal angular difference: 2.000 degrees

Symmetry in minimum-lengths cell: I m m m (y+z,-y+z,x-z) (No. 71)
      Input minimum-lengths cell: (8.40567, 8.51612, 8.52071, 61.4489, 61.5879, 60.4641)
           Symmetry-adapted cell: (8.57387, 8.57387, 8.52071, 60.2049, 60.2049, 59.5902)
            Conventional setting: I m m m (No. 71)
                       Unit cell: (8.52071, 8.52071, 12.2, 90, 90, 90)
                 Change of basis: -x+z,-x-z,-y
                         Inverse: -1/2*x-1/2*y,-z,1/2*x-1/2*y
      Maximal angular difference: 2.236 degrees

Symmetry in minimum-lengths cell: F m m m (-x+y+z,x-y+z,x+y-z) (No. 69)
      Input minimum-lengths cell: (8.40567, 8.51612, 8.52071, 61.4489, 61.5879, 60.4641)
           Symmetry-adapted cell: (8.55628, 8.59142, 8.52071, 60, 60.4101, 59.5899)
            Conventional setting: F m m m (No. 69)
                       Unit cell: (12, 12.1, 12.2, 90, 90, 90)
                 Change of basis: x,z,-y
                         Inverse: x,-z,y
      Maximal angular difference: 2.236 degrees

Symmetry in minimum-lengths cell: C 1 2/m 1 (x+y,-x+y,x-y+z) (No. 12)
      Input minimum-lengths cell: (8.40567, 8.51612, 8.52071, 61.4489, 61.5879, 60.4641)
           Symmetry-adapted cell: (8.55628, 8.59142, 8.52071, 60, 60.4101, 59.5899)
            Conventional setting: I 1 2/m 1 (No. 12)
                       Unit cell: (8.52071, 12.2, 8.52071, 90, 90.4755, 90)
                 Change of basis: x-z,y,x+z
                         Inverse: 1/2*x+1/2*z,y,-1/2*x+1/2*z
      Maximal angular difference: 2.236 degrees

Symmetry in minimum-lengths cell: C 1 2/m 1 (x-y+z,x+y,-x+y) (No. 12)
      Input minimum-lengths cell: (8.40567, 8.51612, 8.52071, 61.4489, 61.5879, 60.4641)
           Symmetry-adapted cell: (8.40567, 8.59142, 8.52071, 61.1478, 61.0005, 60.1608)
            Conventional setting: I 1 2/m 1 (No. 12)
                       Unit cell: (8.40567, 12.1, 8.70429, 90, 90.9476, 90)
                 Change of basis: x+y,z,x-y
                         Inverse: 1/2*x+1/2*z,1/2*x-1/2*z,y
      Maximal angular difference: 1.001 degrees

Symmetry in minimum-lengths cell: C 1 2/m 1 (-x+y,x-y+z,x+y) (No. 12)
      Input minimum-lengths cell: (8.40567, 8.51612, 8.52071, 61.4489, 61.5879, 60.4641)
           Symmetry-adapted cell: (8.55628, 8.51612, 8.52071, 60.2943, 60.9905, 59.8794)
            Conventional setting: I 1 2/m 1 (No. 12)
                       Unit cell: (8.51612, 12, 8.66606, 90, 90.4716, 90)
                 Change of basis: y-z,x,-y-z
                         Inverse: y,1/2*x-1/2*z,-1/2*x-1/2*z
      Maximal angular difference: 2.000 degrees

Symmetry in minimum-lengths cell: C 1 2/m 1 (z,x-y,x+y) (No. 12)
      Input minimum-lengths cell: (8.40567, 8.51612, 8.52071, 61.4489, 61.5879, 60.4641)
           Symmetry-adapted cell: (8.40567, 8.51842, 8.51842, 61.4489, 61.0277, 61.0277)
            Conventional setting: I 1 2/m 1 (No. 12)
                       Unit cell: (8.40567, 8.70429, 12.1, 90, 90.7257, 90)
                 Change of basis: x+y,x-y,-z
                         Inverse: 1/2*x+1/2*y,1/2*x-1/2*y,-z
      Maximal angular difference: 1.172 degrees

Symmetry in minimum-lengths cell: C 1 2/m 1 (x+y,z,x-y) (No. 12)
      Input minimum-lengths cell: (8.40567, 8.51612, 8.52071, 61.4489, 61.5879, 60.4641)
           Symmetry-adapted cell: (8.46339, 8.51612, 8.46339, 60.9617, 61.5908, 60.9617)
            Conventional setting: I 1 2/m 1 (No. 12)
                       Unit cell: (8.51612, 8.66606, 12, 90, 91.4324, 90)
                 Change of basis: y-z,y+z,x
                         Inverse: z,1/2*x+1/2*y,-1/2*x+1/2*y
      Maximal angular difference: 1.474 degrees

Symmetry in minimum-lengths cell: C 1 2/m 1 (x-y,x+y,z) (No. 12)
      Input minimum-lengths cell: (8.40567, 8.51612, 8.52071, 61.4489, 61.5879, 60.4641)
           Symmetry-adapted cell: (8.46108, 8.46108, 8.52071, 61.5187, 61.5187, 60.4668)
            Conventional setting: I 1 2/m 1 (No. 12)
                       Unit cell: (8.52071, 8.52071, 12.2, 90, 92.1185, 90)
                 Change of basis: x-z,-x-z,y
                         Inverse: 1/2*x-1/2*y,z,-1/2*x-1/2*y
      Maximal angular difference: 0.860 degrees

Symmetry in minimum-lengths cell: C 1 2/m 1 (-z,-2*x+z,x+y) (No. 12)
      Input minimum-lengths cell: (8.40567, 8.51612, 8.52071, 61.4489, 61.5879, 60.4641)
           Symmetry-adapted cell: (8.53686, 8.61072, 8.52071, 60.3452, 60.0626, 59.589)
            Conventional setting: I 1 2/m 1 (No. 12)
                       Unit cell: (8.52071, 8.52071, 12.2, 90, 90.6981, 90)
                 Change of basis: x+z,x-z,y
                         Inverse: 1/2*x+1/2*y,z,1/2*x-1/2*y
      Maximal angular difference: 2.177 degrees

Symmetry in minimum-lengths cell: C 1 2/m 1 (-z,-x+y,2*x+z) (No. 12)
      Input minimum-lengths cell: (8.40567, 8.51612, 8.52071, 61.4489, 61.5879, 60.4641)
           Symmetry-adapted cell: (8.46339, 8.51612, 8.61299, 60.3713, 60.9859, 59.7937)
            Conventional setting: I 1 2/m 1 (No. 12)
                       Unit cell: (8.66606, 8.51612, 12, 90, 91.4076, 90)
                 Change of basis: -y-z,-y+z,-x
                         Inverse: -z,-1/2*x-1/2*y,-1/2*x+1/2*y
      Maximal angular difference: 1.498 degrees

Symmetry in minimum-lengths cell: C 1 2/m 1 (-x+y,z,2*x-z) (No. 12)
      Input minimum-lengths cell: (8.40567, 8.51612, 8.52071, 61.4489, 61.5879, 60.4641)
           Symmetry-adapted cell: (8.40567, 8.51842, 8.59369, 61.1477, 60.7211, 60.4369)
            Conventional setting: I 1 2/m 1 (No. 12)
                       Unit cell: (8.70429, 8.40567, 12.1, 90, 90.7008, 90)
                 Change of basis: x-y,x+y,z
                         Inverse: 1/2*x+1/2*y,-1/2*x+1/2*y,z
      Maximal angular difference: 1.187 degrees

Symmetry in minimum-lengths cell: P -1 (No. 2)
      Input minimum-lengths cell: (8.40567, 8.51612, 8.52071, 61.4489, 61.5879, 60.4641)
           Symmetry-adapted cell: (8.40567, 8.51612, 8.52071, 61.4489, 61.5879, 60.4641)
            Conventional setting: P -1 (No. 2)
                       Unit cell: (8.40567, 8.51612, 8.52071, 61.4489, 61.5879, 60.4641)
                 Change of basis: -x-y-z,x-y+z,-x+y+z
                         Inverse: -1/2*x-1/2*z,-1/2*x-1/2*y,1/2*y+1/2*z
      Maximal angular difference: 0.000 degrees

""")
  #
  run_and_compare(
    ['iotbx.lattice_symmetry --unit_cell="22.54 22.64 6.35 90.1 89.9 90.3" I',
     'cctbx.lattice_symmetry 1'],
    """\

Input
=====

Unit cell: (22.54, 22.64, 6.35, 90.1, 89.9, 90.3)
Space group: P 1 (b+c,a+c,a+b) (No. 1)

Angular tolerance: 3.000 degrees

Similar symmetries
==================

Symmetry in minimum-lengths cell: I 4/m m m (-y+z,x+y,-x+y) (No. 139)
      Input minimum-lengths cell: (6.35, 16.245, 16.3194, 87.6037, 78.9224, 78.7296)
           Symmetry-adapted cell: (6.35, 16.2861, 16.2861, 87.8219, 78.7581, 78.7581)
            Conventional setting: I 4/m m m (No. 139)
                       Unit cell: (22.5901, 22.5901, 6.35, 90, 90, 90)
                 Change of basis: x,y,z
                         Inverse: x,y,z
      Maximal angular difference: 0.316 degrees

Symmetry in minimum-lengths cell: I m m m (y-z,-x+z,x+z) (No. 71)
      Input minimum-lengths cell: (6.35, 16.245, 16.3194, 87.6037, 78.9224, 78.7296)
           Symmetry-adapted cell: (6.35, 16.2861, 16.2861, 87.5777, 78.7581, 78.7581)
            Conventional setting: I m m m (No. 71)
                       Unit cell: (6.35, 22.54, 22.64, 90, 90, 90)
                 Change of basis: -z,-x,y
                         Inverse: -y,z,-x
      Maximal angular difference: 0.316 degrees

Symmetry in minimum-lengths cell: F m m m (x-y+z,-2*z,2*y) (No. 69)
      Input minimum-lengths cell: (6.35, 16.245, 16.3194, 87.6037, 78.9224, 78.7296)
           Symmetry-adapted cell: (6.35, 16.245, 16.327, 87.8218, 78.7867, 78.7293)
            Conventional setting: F m m m (No. 69)
                       Unit cell: (6.35, 31.8634, 32.0307, 90, 90, 90)
                 Change of basis: -z,-1/2*x-1/2*y,-1/2*x+1/2*y
                         Inverse: -y-z,-y+z,-x
      Maximal angular difference: 0.290 degrees

Symmetry in minimum-lengths cell: C 1 2/m 1 (-x+y,z,2*x-z) (No. 12)
      Input minimum-lengths cell: (6.35, 16.245, 16.3194, 87.6037, 78.9224, 78.7296)
           Symmetry-adapted cell: (6.35, 16.245, 16.327, 87.5777, 78.7867, 78.7293)
            Conventional setting: I 1 2/m 1 (No. 12)
                       Unit cell: (22.54, 6.35, 22.64, 90, 90.3, 90)
                 Change of basis: x,-z,y
                         Inverse: x,z,-y
      Maximal angular difference: 0.141 degrees

Symmetry in minimum-lengths cell: C 1 2/m 1 (x-y,2*y,z) (No. 12)
      Input minimum-lengths cell: (6.35, 16.245, 16.3194, 87.6037, 78.9224, 78.7296)
           Symmetry-adapted cell: (6.35, 16.245, 16.3194, 87.8479, 78.9224, 78.7293)
            Conventional setting: C 1 2/m 1 (No. 12)
                       Unit cell: (6.35, 31.8634, 16.3194, 90, 101.078, 90)
                 Change of basis: -1/2*x+1/2*y-z,-1/2*x-1/2*y,-x+y
                         Inverse: -y-1/2*z,-y+1/2*z,-x+1/2*z
      Maximal angular difference: 0.254 degrees

Symmetry in minimum-lengths cell: C 1 2/m 1 (x+y,z,-2*y) (No. 12)
      Input minimum-lengths cell: (6.35, 16.245, 16.3194, 87.6037, 78.9224, 78.7296)
           Symmetry-adapted cell: (6.35, 16.245, 16.327, 87.8219, 78.7867, 78.7296)
            Conventional setting: C 1 2/m 1 (No. 12)
                       Unit cell: (6.35, 32.0307, 16.245, 90, 101.27, 90)
                 Change of basis: 1/2*x+1/2*y-z,-1/2*x+1/2*y,x+y
                         Inverse: -y+1/2*z,y+1/2*z,-x+1/2*z
      Maximal angular difference: 0.290 degrees

Symmetry in minimum-lengths cell: C 1 2/m 1 (z,x-y,x+y) (No. 12)
      Input minimum-lengths cell: (6.35, 16.245, 16.3194, 87.6037, 78.9224, 78.7296)
           Symmetry-adapted cell: (6.35, 16.2822, 16.2822, 87.6037, 78.8263, 78.8263)
            Conventional setting: I 1 2/m 1 (No. 12)
                       Unit cell: (6.35, 22.54, 22.64, 90, 90.1, 90)
                 Change of basis: -z,x,-y
                         Inverse: y,-z,-x
      Maximal angular difference: 0.316 degrees

Symmetry in minimum-lengths cell: C 1 2/m 1 (x-y+z,x+y,-x+y) (No. 12)
      Input minimum-lengths cell: (6.35, 16.245, 16.3194, 87.6037, 78.9224, 78.7296)
           Symmetry-adapted cell: (6.35, 16.2899, 16.2822, 87.5777, 78.826, 78.6902)
            Conventional setting: I 1 2/m 1 (No. 12)
                       Unit cell: (6.35, 22.64, 22.54, 90, 90.1, 90)
                 Change of basis: -z,y,x
                         Inverse: z,y,-x
      Maximal angular difference: 0.316 degrees

Symmetry in minimum-lengths cell: P -1 (No. 2)
      Input minimum-lengths cell: (6.35, 16.245, 16.3194, 87.6037, 78.9224, 78.7296)
           Symmetry-adapted cell: (6.35, 16.245, 16.3194, 87.6037, 78.9224, 78.7296)
            Conventional setting: P -1 (No. 2)
                       Unit cell: (6.35, 16.245, 16.3194, 87.6037, 78.9224, 78.7296)
                 Change of basis: -y+z,x+y,-x+y
                         Inverse: 1/2*y-1/2*z,1/2*y+1/2*z,x+1/2*y+1/2*z
      Maximal angular difference: 0.000 degrees

""")
  #
  run_and_compare(
    ['iotbx.lattice_symmetry'
       ' --unit_cell="78.9 82.3 57.0 90 93.4 90.1" C --delta=1.4'],
    """\

Input
=====

Unit cell: (78.9, 82.3, 57, 90, 93.4, 90.1)
Space group: P 1 (a+b,a-b,-c) (No. 1)

Angular tolerance: 1.400 degrees

Similar symmetries
==================

Symmetry in minimum-lengths cell: R -3 m :R (No. 166)
      Input minimum-lengths cell: (56.9558, 57, 57.0552, 92.3502, 92.4166, 92.3543)
           Symmetry-adapted cell: (57.0037, 57.0037, 57.0037, 92.3737, 92.3737, 92.3737)
            Conventional setting: R -3 m :H (No. 166)
                       Unit cell: (82.2678, 82.2678, 94.5557, 90, 90, 120)
                 Change of basis: -2/3*x+2/3*z,-1/3*x-y+1/3*z,2/3*x+1/3*z
                         Inverse: -1/2*x+z,1/2*x-y,x+z
      Maximal angular difference: 0.100 degrees

Symmetry in minimum-lengths cell: C 1 2/m 1 (x-y,x+y,z) (No. 12)
      Input minimum-lengths cell: (56.9558, 57, 57.0552, 92.3502, 92.4166, 92.3543)
           Symmetry-adapted cell: (56.9779, 56.9779, 57.0552, 92.3834, 92.3834, 92.3543)
            Conventional setting: C 1 2/m 1 (No. 12)
                       Unit cell: (78.9065, 82.2173, 57.0552, 90, 93.4431, 90)
                 Change of basis: 1/2*x+1/2*y+1/2*z,-1/2*x-1/2*y+1/2*z,x-y
                         Inverse: 1/2*x-1/2*y+1/2*z,1/2*x-1/2*y-1/2*z,x+y
      Maximal angular difference: 0.065 degrees

Symmetry in minimum-lengths cell: C 1 2/m 1 (x+y,z,x-y) (No. 12)
      Input minimum-lengths cell: (56.9558, 57, 57.0552, 92.3502, 92.4166, 92.3543)
           Symmetry-adapted cell: (57.0055, 57, 57.0055, 92.3522, 92.4166, 92.3522)
            Conventional setting: C 1 2/m 1 (No. 12)
                       Unit cell: (78.9, 82.3, 57, 90, 93.4, 90)
                 Change of basis: x,y,z
                         Inverse: x,y,z
      Maximal angular difference: 0.100 degrees

Symmetry in minimum-lengths cell: C 1 2/m 1 (z,x-y,x+y) (No. 12)
      Input minimum-lengths cell: (56.9558, 57, 57.0552, 92.3502, 92.4166, 92.3543)
           Symmetry-adapted cell: (56.9558, 57.0276, 57.0276, 92.3502, 92.3854, 92.3854)
            Conventional setting: C 1 2/m 1 (No. 12)
                       Unit cell: (78.9783, 82.2861, 56.9558, 90, 93.446, 90)
                 Change of basis: 1/2*x-1/2*y+1/2*z,1/2*x-1/2*y-1/2*z,x+y
                         Inverse: 1/2*x+1/2*y+1/2*z,-1/2*x-1/2*y+1/2*z,x-y
      Maximal angular difference: 0.069 degrees

Symmetry in minimum-lengths cell: P -1 (No. 2)
      Input minimum-lengths cell: (56.9558, 57, 57.0552, 92.3502, 92.4166, 92.3543)
           Symmetry-adapted cell: (56.9558, 57, 57.0552, 92.3502, 92.4166, 92.3543)
            Conventional setting: P -1 (No. 2)
                       Unit cell: (56.9558, 57, 57.0552, 92.3502, 92.4166, 92.3543)
                 Change of basis: x+y,z,x-y
                         Inverse: 1/2*x+1/2*z,1/2*x-1/2*z,y
      Maximal angular difference: 0.000 degrees

""")
  assert tst_instability_on_the_lepage_tolerance()
  print("OK")

def tst_instability_on_the_lepage_tolerance():
  """Basic idea:  we introduced the Lepage tolerance to solve the problem
     that numerically-determined or experimentally-determined twofolds do
     not fall at exact positions.  However, when the input is exact, we
     expect to be able to reduce the tolerance to zero."""

  def give_cases():
    from cctbx import crystal
    from cctbx.uctbx import unit_cell
    from cctbx.sgtbx import space_group_info
    pdb =["1vjg/P 32 2 1/(56.192, 56.192, 129.318, 90, 90, 120)/16",
          "1vjz/P 43 21 2/(64.684, 64.684, 202.189, 90, 90, 90)/10",
          "1vl6/P 65/(143.963, 143.963, 163.428, 90, 90, 120)/16",
          "1vlc/P 3 2 1/(118.78, 118.78, 56.699, 90, 90, 120)/16",
          "2ash/C 1 2 1/(169.467, 99.422, 124.163, 90, 123.8, 90)/2",
          "2etj/P 31/(51.821, 51.821, 76.293, 90, 90, 120)/16",
          "2qyv/P 21 21 2/(173.922, 84.293, 123.204, 90, 90, 90)/5"]
    for header in pdb:
      tokens=header.split("/")
      case = {"pdb_code":tokens[0],"centring_type":tokens[1][0],
              "unit_cell":unit_cell(eval(tokens[2])),
              "expected_centrosymmetric_subgroups_of_metric":int(tokens[3])}
      case["symmetry"]=crystal.symmetry(space_group_info=
                         space_group_info(tokens[1]),
                         unit_cell=case["unit_cell"])
      yield case

  from cctbx.sgtbx.lattice_symmetry import metric_subgroups
  for small_max_delta in [1.E-6, 0.0]:
    for case in give_cases():
      G = metric_subgroups(case["symmetry"],
                         max_delta=small_max_delta,bravais_types_only=False)
    assert len(G.result_groups)==case["expected_centrosymmetric_subgroups_of_metric"]

  return True



if (__name__ == "__main__"):
  exercise(sys.argv[1:])


 *******************************************************************************


 *******************************************************************************
iotbx/regression/tst_map_manager.py
from __future__ import absolute_import, division, print_function
import os
from iotbx.data_manager import DataManager
from iotbx.map_manager import map_manager
from libtbx.test_utils import approx_equal

def test_01():

  # Source data (map and model)

  data_dir = os.path.dirname(os.path.abspath(__file__))
  data_ccp4 = os.path.join(data_dir, 'data',
                          'non_zero_origin_map.ccp4')
  data_pdb = os.path.join(data_dir, 'data',
                          'non_zero_origin_model.pdb')


  # Read in map data with data_manager
  dm = DataManager(['real_map'])
  dm.set_overwrite(True)

  # Next step uses map_manager to do the actual reading
  dm.process_real_map_file(data_ccp4)
  mm = dm.get_real_map()

  # Shift the origin of the map; starts at (100,100,100)
  print (mm.map_data().origin())
  assert mm.map_data().origin() == (100,100,100)
  assert mm.origin_shift_grid_units == (0,0,0)
  mm.shift_origin()
  assert mm.map_data().origin() == (0,0,0)
  assert mm.origin_shift_grid_units == (100,100,100)
  mm.show_summary()

  # test cc_to_other_map
  assert mm.cc_to_other_map_manager(mm) == 1

  # test writing and reading file
  dm.write_real_map_file(mm, filename = 'test_map_manager.ccp4',
     overwrite = True)
  dm.process_real_map_file('test_map_manager.ccp4')
  new_mm=dm.get_real_map('test_map_manager.ccp4')
  os.remove('test_map_manager.ccp4')
  new_mm.shift_origin()
  # Check whether gridding and crystal_symmetry are similar for mm, new_mm
  assert new_mm.is_similar(mm)
  assert approx_equal(new_mm.map_data()[3125],mm.map_data()[3125])


  # test writing and reading file without shifting origin
  dm = DataManager(['real_map'])
  dm.set_overwrite(True)
  dm.process_real_map_file(data_ccp4)
  mm = dm.get_real_map()
  mm.show_summary()
  dm.write_real_map_file(mm, filename = 'test_map_manager.ccp4',
     overwrite = True)
  new_mm = map_manager('test_map_manager.ccp4')
  assert (new_mm.is_similar(mm))
  new_mm.shift_origin()
  assert (not new_mm.is_similar(mm))

  # get map_data
  dm = DataManager(['real_map'])
  dm.set_overwrite(True)
  dm.process_real_map_file(data_ccp4)
  mm = dm.get_real_map()
  mm.shift_origin()
  map_data = mm.map_data()
  assert approx_equal(map_data[15, 10, 19], 0.38, eps = 0.01)

  # get crystal_symmetry
  cs = mm.crystal_symmetry()
  assert approx_equal(cs.unit_cell().parameters()[0] , 22.41, eps = 0.01)

  # and full cell symmetry
  full_cs = mm.unit_cell_crystal_symmetry()
  assert approx_equal(full_cs.unit_cell().parameters()[0] ,
       149.4066, eps = 0.01)

  # write map directly:
  mm.write_map('test_direct.ccp4')

  # read back directly
  new_mm = map_manager('test_direct.ccp4')
  assert (not new_mm.is_similar(mm))

  new_mm.shift_origin()
  assert mm.is_similar(new_mm)
  assert approx_equal(new_mm.map_data()[3125],mm.map_data()[3125])

  # deep_copy
  new_mm = mm.deep_copy()
  assert new_mm.is_similar(mm)
  assert approx_equal(new_mm.map_data()[3125],mm.map_data()[3125])

  # deep_copy a map without shifting origin
  # Make a DataManager that can write a map coeffs file too
  dm = DataManager(['miller_array', 'real_map'])
  dm.set_overwrite(True)
  dm.process_real_map_file(data_ccp4)
  omm = dm.get_real_map()
  omm.show_summary()
  new_omm = omm.deep_copy()
  assert new_omm.is_similar(omm)
  assert (not new_omm.is_similar(mm))

  # customized_copy
  new_mm = mm.customized_copy(map_data = mm.map_data().deep_copy())
  assert new_mm.is_similar(mm)


  # Initialize with parameters
  mm_para = map_manager(
     unit_cell_grid =  mm.unit_cell_grid,
     unit_cell_crystal_symmetry =  mm.unit_cell_crystal_symmetry(),
     origin_shift_grid_units =  mm.origin_shift_grid_units,
     map_data = mm.map_data(),
     wrapping = False)
  assert mm_para.is_similar(mm)

  # Adjust origin and gridding:
  mm_read = map_manager(data_ccp4)
  mm_read.shift_origin()
  mm.show_summary()
  mm_read.show_summary()
  mm_read.set_original_origin_and_gridding((10, 10, 10),
       gridding = (100, 100, 100))
  mm_read.show_summary()
  assert (not mm_read.is_similar(mm))
  assert (mm_read.origin_is_zero())

  # Set program name
  mm_read.set_program_name('test program')
  assert mm_read.program_name == 'test program'

  # Set limitation
  mm_read.add_limitation('map_is_sharpened')
  assert mm_read.limitations == ['map_is_sharpened']

  # Add a label
  mm_read.add_label('TEST LABEL')
  assert mm_read.labels[0] == 'TEST LABEL'
  mm_read.write_map('map_with_labels.mrc')
  new_mm = map_manager('map_with_labels.mrc')
  assert 'TEST LABEL' in new_mm.labels
  assert new_mm.is_in_limitations('map_is_sharpened')
  assert new_mm.labels[0].find('test program')>-1

  # Remove backslashes
  mm_read.add_label('TEST \\LABEL')
  assert mm_read.labels[0] == 'TEST \\LABEL'
  mm_read.write_map('map_with_labels.mrc')
  new_mm = map_manager('map_with_labels.mrc')
  assert 'TEST /LABEL' in new_mm.labels
  assert new_mm.is_in_limitations('map_is_sharpened')
  assert new_mm.labels[0].find('test program')>-1

  # change the cell dimensions
  mm_read = map_manager(data_ccp4)
  mm_read.shift_origin()
  assert mm_read.is_similar(mm)
  assert approx_equal(mm_read.pixel_sizes(),
        (0.7470, 0.7231, 0.7374) , eps = 0.001)
  from cctbx import crystal
  new_uc_params = list(
    mm_read.unit_cell_crystal_symmetry().unit_cell().parameters())
  new_uc_params[0]+= 10
  new_cs = crystal.symmetry(new_uc_params, 1)
  mm_read.set_unit_cell_crystal_symmetry(new_cs)
  assert not mm_read.crystal_symmetry().is_similar_symmetry(
      mm.crystal_symmetry())
  assert not mm_read.is_similar(mm)
  mm_read.show_summary()
  assert approx_equal(mm_read.pixel_sizes(),
       (0.7970, 0.7231, 0.7374) , eps = 0.001)

  # Read a map directly
  mm_read = map_manager(data_ccp4)
  mm_read.shift_origin()
  assert mm_read.is_similar(mm)

  # Set log
  import sys
  mm.set_log(sys.stdout)

  # Add map_data
  new_mm = mm_read.customized_copy(map_data = mm.map_data().deep_copy())
  assert new_mm.is_similar(mm)

  # replace data
  new_mm.set_map_data(map_data = mm.map_data().deep_copy())
  assert new_mm.is_similar(mm)

  # create a full-sized map from this one
  mm_full_size = mm_read.deep_copy().as_full_size_map()
  assert not mm_full_size.is_similar(mm_read)
  print (mm_full_size.map_data().origin(), mm_read.map_data().origin())
  print (mm_full_size.map_data().all(), mm_read.map_data().all())

  # Apply a mask to edges of a map
  assert approx_equal(new_mm.map_data().as_1d().min_max_mean().max,
                          mm.map_data().as_1d().min_max_mean().max)
  assert approx_equal( (new_mm.map_data()[0], mm.map_data()[0]),
         (0.0, 0.0))
  new_mm.create_mask_around_edges(boundary_radius = 3)
  new_mm.soft_mask(soft_mask_radius = 3)
  assert approx_equal(new_mm.map_data().as_1d().as_1d().min_max_mean().max,
                          mm.map_data().as_1d().as_1d().min_max_mean().max)
  new_mm.apply_mask(set_outside_to_mean_inside = True)
  assert approx_equal( (new_mm.map_data()[0], mm.map_data()[0]),
         (0.0116108613152, 0.0))


  dm.process_real_map_file('test_map_manager.ccp4')
  new_mm = dm.get_real_map('test_map_manager.ccp4')
  new_mm.show_summary()
  assert (not new_mm.is_similar(mm))
  new_mm.shift_origin()
  new_mm.show_summary()
  assert new_mm.is_similar(mm)
  os.remove('test_map_manager.ccp4')

  # Check origin_shifts
  print (new_mm.origin_shift_grid_units)
  print (new_mm.shift_cart())
  assert approx_equal(new_mm.origin_shift_grid_units, (100, 100, 100))
  assert approx_equal(new_mm.shift_cart(),
       (-74.70333099365234, -72.30750274658205, -73.7437515258789))

  # Convert to map coeffs, write out, read back, convert back to map

  map_coeffs = mm.map_as_fourier_coefficients(d_min = 3)
  mtz_dataset = map_coeffs.as_mtz_dataset(column_root_label = 'F')
  mtz_object = mtz_dataset.mtz_object()
  dm.write_miller_array_file(mtz_object, filename = "map_coeffs.mtz")
  # Note these Fourier coeffs correspond to working map (not original position)

  array_labels = dm.get_miller_array_labels("map_coeffs.mtz")
  labels = array_labels[0]
  dm.get_reflection_file_server(filenames = ["map_coeffs.mtz"],
       labels = [labels])
  miller_arrays = dm.get_miller_arrays()
  new_map_coeffs = miller_arrays[0]
  mm_from_map_coeffs = mm.fourier_coefficients_as_map_manager(
      map_coeffs = new_map_coeffs)

  assert mm_from_map_coeffs.is_similar(mm)

  # Find map symmetry in a map
  data_d7 = os.path.join(data_dir, 'data',
                          'D7.ccp4')
  dm = DataManager(['real_map',  'model'])
  dm.process_real_map_file(data_d7)
  dm.process_model_file(data_pdb)
  mm = dm.get_real_map(data_d7)
  model = dm.get_model(data_pdb)
  mm.shift_origin()
  mm.set_original_origin_and_gridding(original_origin=(0,0,0))

  # Box it so it is not so easy to find symmetry
  from cctbx.maptbx.box import with_bounds
  box=with_bounds(mm,lower_bounds=(2,2,2),
   upper_bounds=(43,43,43))
  new_mm=box.map_manager()
  new_mm.find_map_symmetry(symmetry='d7',min_ncs_cc=0.8,
    include_helical_symmetry=False)
  ncs_obj=new_mm.ncs_object()
  assert ncs_obj is not None
  print ("NCS: ",new_mm.ncs_object().as_ncs_spec_string())
  another_mm = map_manager(
     unit_cell_grid =  new_mm.unit_cell_grid,
     unit_cell_crystal_symmetry =  new_mm.unit_cell_crystal_symmetry(),
     origin_shift_grid_units =  new_mm.origin_shift_grid_units,
     map_data = new_mm.map_data(),
     ncs_object = ncs_obj,
     wrapping = False)
  assert another_mm.is_similar(new_mm)
  assert ncs_obj.is_similar_ncs_object(another_mm.ncs_object())
  assert new_mm.is_similar(another_mm)

  # Resample with different gridding
  resampled_mm = another_mm.resample_on_different_grid(
    target_grid_spacing = .3)
  assert tuple(resampled_mm.unit_cell_grid) == (67, 67, 67)
  assert tuple(resampled_mm.origin_shift_grid_units) == (3 , 3, 3)

  # Reset crystal_symmetry of map with ncs object
  another_mm.set_unit_cell_crystal_symmetry(
     unit_cell_crystal_symmetry=another_mm.unit_cell_crystal_symmetry())
  assert not new_cs.is_similar_symmetry(
    another_mm.unit_cell_crystal_symmetry())
  shift_cart =  another_mm.shift_cart()
  another_mm.set_unit_cell_crystal_symmetry(unit_cell_crystal_symmetry=new_cs)
  assert shift_cart !=  another_mm.shift_cart()
  assert approx_equal(another_mm.ncs_object().shift_cart(), another_mm.shift_cart())

  # Get resolution
  assert approx_equal(new_mm.resolution(force=True, method='d99') ,
    3.73886)
  assert approx_equal(new_mm.resolution(force=True, method='d_min') ,
    0.888888888889)
  assert approx_equal(new_mm.resolution(force=True, method='d9') ,
    0.888888888889)
  assert approx_equal(new_mm.resolution(force=True, method='d99') ,
    3.73886)
  assert approx_equal(new_mm.resolution() ,
    3.73886)

  # Adjust model and ncs symmetry to match this map
  assert model.shift_cart()  is None
  new_mm.set_model_symmetries_and_shift_cart_to_match_map(model)
  assert approx_equal (model.shift_cart() ,
       (-0.888888888888889, -0.8888888888888891, -0.888888888888889))
  sc = model.get_sites_cart()
  from scitbx.matrix import col
  sc_absolute = sc - col(model.shift_cart())
  assert approx_equal(new_mm.sites_cart_to_sites_cart_absolute(sc),
     sc_absolute)
  assert approx_equal(new_mm.sites_cart_absolute_to_sites_cart(sc_absolute),
     sc)
  assert new_mm.is_compatible_ncs_object(ncs_obj)
  ncs_obj.set_shift_cart((0,0,0))
  assert not new_mm.is_compatible_ncs_object(ncs_obj)

  new_mm.set_ncs_object_shift_cart_to_match_map(ncs_obj)
  new_mm.set_ncs_object(ncs_obj)
  assert new_mm.is_compatible_ncs_object(new_mm.ncs_object())
  new_mm.show_summary()

  new_mm.shift_origin(desired_origin=(11,1,1))
  print (new_mm.shift_cart(),new_mm.ncs_object().shift_cart())
  assert new_mm.is_compatible_ncs_object(new_mm.ncs_object())
  new_mm.shift_origin()
  assert new_mm.is_compatible_ncs_object(new_mm.ncs_object())

  # filter a map
  dm = DataManager()
  mm = dm.get_real_map(data_d7)

  low_pass_filtered=mm.deep_copy()
  low_pass_filtered.resolution_filter(d_min=2.5)

  high_pass_filtered=mm.deep_copy()
  high_pass_filtered.resolution_filter(d_max=2.5)

  gaussian=mm.deep_copy()
  gaussian.gaussian_filter(smoothing_radius=1)

  randomize=mm.deep_copy()
  randomize.randomize(random_seed=1)
  assert approx_equal(randomize.map_map_cc(mm),0.7,.10)

  binary=mm.deep_copy()
  binary.binary_filter(threshold=0.5)

  scaled=mm.deep_copy()
  scaled.scale_map(10)

  assert approx_equal(
     (mm.map_data().as_1d()[1073],low_pass_filtered.map_data().as_1d()[1073],
       high_pass_filtered.map_data().as_1d()[1073],
       gaussian.map_data().as_1d()[1073],binary.map_data().as_1d()[1073],
       scaled.map_data().as_1d()[1073]),
      (0.0171344596893,0.0227163900537,-0.0072717454565,0.0149086679298,0.0,
        0.171344596893))

  info=mm.get_density_along_line((5,5,5),(10,10,10))
  assert approx_equal([info.along_density_values[4]]+list(info.along_sites[4]),
    [-0.562231123447 , 8.0, 8.0, 8.0])
  from iotbx.map_model_manager import map_model_manager
  extra_map_manager_id_list = ["low_pass_filtered",
    # "high_pass_filtered",
    "gaussian",
    "binary"]

  expected_cc= [ 1,
     # -0.038380049155,
     0.975273714961,
     0.866785173385]
  mam=map_model_manager(
    map_manager=mm,
    extra_map_manager_list =  [low_pass_filtered,
     # high_pass_filtered,
     gaussian,
     binary],
    extra_map_manager_id_list = extra_map_manager_id_list,)
  for other_id,cc in zip(extra_map_manager_id_list,expected_cc):
   assert approx_equal(cc,
      mam.map_map_cc(map_id='map_manager',other_map_id=other_id), eps = 0.05 )

# this test requires the solve_resolve module
def test_02():

  data_dir = os.path.dirname(os.path.abspath(__file__))
  data_d7 = os.path.join(data_dir, 'data', 'D7.ccp4')

  # find_separated atoms in a map
  dm = DataManager()
  mm = dm.get_real_map(data_d7)
  sites_cart = mm.trace_atoms_in_map(dist_min=1,n_atoms=10)
  assert sites_cart.size() == 10 # Note: zero if not available

if (__name__  ==  '__main__'):
  test_01()
  test_02()
  print ("OK")


 *******************************************************************************


 *******************************************************************************
iotbx/regression/tst_map_manager_2.py
from __future__ import division
import iotbx.pdb
import mmtbx.model
from scitbx.matrix import col
from scitbx.array_family import flex

pdb_str = """
CRYST1   12.650   11.560   10.720  90.00  90.00  90.00 P 1
ATOM      1  N   GLY B   1       7.650   6.063   5.176  1.00 10.00           N
ATOM      2  CA  GLY B   1       6.683   5.000   5.000  1.00 10.00           C
ATOM      3  C   GLY B   1       5.326   5.383   5.551  1.00 10.00           C
ATOM      4  O   GLY B   1       5.000   6.560   5.720  1.00 10.00           O
TER
END
"""

def tst_01():
  # Load model
  pdb_inp = iotbx.pdb.input(source_info=None, lines=pdb_str)
  xrs = pdb_inp.xray_structure_simple()
  # Compute Fourier map (Fcalc)
  fc = xrs.structure_factors(d_min=1).f_calc()

  mm = fc.as_map_manager()

  result = mm.peak_search(max_peaks = 3)

  # expected sites
  sc = xrs.sites_cart()

  # Make sure we have sites and sites_cart ok
  sc_found = flex.vec3_double(result.sites_cart)
  sites_frac_found = flex.vec3_double(result.sites)
  sc_found_2= mm.crystal_symmetry().unit_cell().orthogonalize(sites_frac_found)
  assert (sc_found_2 - sc_found).rms_length() < 0.001

  sc_found_absolute = result.sites_cart_absolute
  assert (sc_found_absolute -
      (sc_found - col(mm.shift_cart()))).rms_length() < 0.001

  # List peaks with their heights and match to expected
  for site_cart, height in zip( result.sites_cart, result.heights):
    one_site_list = flex.vec3_double([site_cart])
    dist, ii,jj = sc.min_distance_between_any_pair_with_id(one_site_list)
    assert dist < 0.2

if(__name__ == "__main__"):
  tst_01()
  print ("OK")


 *******************************************************************************


 *******************************************************************************
iotbx/regression/tst_map_manager_wrapping.py
from __future__ import absolute_import, division, print_function

from cctbx.development import random_structure
from cctbx.sgtbx import space_group_info
import boost_adaptbx.boost.python as bp
from six.moves import range
asu_map_ext = bp.import_ext("cctbx_asymmetric_map_ext")
from cctbx_asymmetric_map_ext import *
from cctbx.array_family import flex
from cctbx import maptbx
import random
import iotbx.map_manager

if (1):
  random.seed(0)
  flex.set_random_seed(0)

def run():
  result = flex.bool()
  for sgn in range(1,231):
    group = space_group_info(sgn)
    xrs = random_structure.xray_structure(
      space_group_info       = group,
      volume_per_atom        = 25.,
      general_positions_only = False,
      elements               = ('C', 'N', 'O', 'H')*30,
      min_distance           = 1.0)
    sgt = xrs.space_group().type()
    fc = xrs.structure_factors(d_min=2).f_calc()
    fft_map = fc.fft_map(symmetry_flags = maptbx.use_space_group_symmetry,
      resolution_factor=1./3)
    map_data = fft_map.real_map_unpadded()
    n_real = map_data.all()
    mm = iotbx.map_manager.map_manager(
      map_data                   = map_data,
      unit_cell_grid             = map_data.accessor().all(),
      unit_cell_crystal_symmetry = xrs.crystal_symmetry(),
      origin_shift_grid_units    = [0,0,0],
      wrapping                   = True)
    assert mm.is_consistent_with_wrapping() in [True,None]
    assert mm.map_data().all() == n_real
    new_mm=mm.as_full_size_map()
    assert new_mm.map_data().all() == n_real

    # Now cut off edges and should not work:
    from iotbx.map_model_manager import map_model_manager
    mmm=map_model_manager(map_manager=mm)
    upper_bounds=tuple([x-1 for x in mm.map_data().all()])
    mmm.box_all_maps_with_bounds_and_shift_origin(lower_bounds=(1,1,1), upper_bounds=upper_bounds)
    mm=mmm.map_manager()
    assert mm.is_consistent_with_wrapping() in [None,False]
    assert mm.map_data().all() != n_real
    new_mm=mm.as_full_size_map()
    assert new_mm.map_data().all() == n_real

if (__name__ == "__main__"):
  run()
  print ("OK")


 *******************************************************************************


 *******************************************************************************
iotbx/regression/tst_map_model_manager.py
from __future__ import absolute_import, division, print_function
import os
import libtbx.load_env
from iotbx.data_manager import DataManager
from iotbx.map_model_manager import _match_map_model_ncs, map_model_manager
from iotbx.phil import parse
from libtbx.program_template import ProgramTemplate
from libtbx.test_utils import approx_equal
from libtbx.utils import Sorry
from libtbx.test_utils import show_diff

def test_01():

  # Source data

  data_dir = os.path.dirname(os.path.abspath(__file__))
  data_ccp4 = os.path.join(data_dir, 'data',
                          'non_zero_origin_map.ccp4')
  data_pdb = os.path.join(data_dir, 'data',
                          'non_zero_origin_model.pdb')
  data_ncs_spec = os.path.join(data_dir, 'data',
                          'non_zero_origin_ncs_spec.ncs_spec')

  # DataManager

  dm = DataManager(['ncs_spec','model', 'real_map', 'phil'])
  dm.set_overwrite(True)

  # Read in map and model and ncs

  map_file=data_ccp4
  dm.process_real_map_file(map_file)
  mm = dm.get_real_map(map_file)

  model_file=data_pdb
  dm.process_model_file(model_file)
  model = dm.get_model(model_file)

  ncs_file=data_ncs_spec
  dm.process_ncs_spec_file(ncs_file)
  ncs = dm.get_ncs_spec(ncs_file)

  ncs_dc = ncs.deep_copy()

  mmmn = _match_map_model_ncs()
  mmmn.add_map_manager(mm)
  mmmn.add_model(model)
  mmmn.add_ncs_object(ncs)

  # Save it
  mmmn_dc=mmmn.deep_copy()

  # Test creating mmm from model:
  mmm_from_model = model.as_map_model_manager(create_model_map = False)
  mmm_from_model = model.as_map_model_manager(create_model_map = True,
    resolution = 5)
  assert mmm_from_model.map_manager() is not None

  # Make sure we can add an ncs object that is either shifted or not
  mmmn_dcdc=mmmn.deep_copy()
  new_mmmn = _match_map_model_ncs()
  new_mmmn.add_map_manager(mmmn_dcdc.map_manager())
  new_mmmn.add_model(mmmn_dcdc.model())
  new_mmmn.add_ncs_object(mmmn_dcdc.ncs_object())
  assert new_mmmn.ncs_object().shift_cart() == new_mmmn.map_manager().shift_cart()

  mmmn_dcdc=mmmn.deep_copy()
  new_mmmn = _match_map_model_ncs()
  new_mmmn.add_map_manager(mmmn_dcdc.map_manager())
  new_mmmn.add_model(mmmn_dcdc.model())
  new_mmmn.add_ncs_object(ncs_dc)
  assert new_mmmn.ncs_object().shift_cart() == new_mmmn.map_manager().shift_cart()


  original_ncs=mmmn.ncs_object()
  assert approx_equal((24.0528, 11.5833, 20.0004),
     tuple(original_ncs.ncs_groups()[0].translations_orth()[-1]),
     eps=0.1)

  assert tuple(mmmn._map_manager.origin_shift_grid_units) == (0,0,0)

  # Shift origin to (0,0,0)
  mmmn=mmmn_dc.deep_copy()  # fresh version of _match_map_model_ncs
  mmmn.shift_origin()
  new_ncs=mmmn.ncs_object()
  assert tuple(mmmn._map_manager.origin_shift_grid_units) == (100,100,100)

  mmmn.write_model('s.pdb')
  mmmn.write_map('s.mrc')

  shifted_ncs=mmmn.ncs_object()
  assert approx_equal((-153.758, -74.044, -127.487),
      tuple(shifted_ncs.ncs_groups()[0].translations_orth()[-1]),eps=0.1)


  # Shift a model and shift it back

  mmmn=mmmn_dc.deep_copy()  # fresh version of _match_map_model_ncs
  model=mmmn.model()
  shifted_model=mmmn.shift_model_to_match_working_map(model=model)
  model_in_original_position=mmmn.shift_model_to_match_original_map(
      model=shifted_model)
  assert (approx_equal(model.get_sites_cart(), # not a copy
                      shifted_model.get_sites_cart()))
  assert approx_equal(model.get_sites_cart(),
                      model_in_original_position.get_sites_cart())

  # test data_manager map_model_manager
  generated_mmm = dm.get_map_model_manager()
  print(generated_mmm)
  assert(isinstance(generated_mmm,map_model_manager))


  # Generate a map and model

  import sys
  mmm=map_model_manager(log=sys.stdout)
  mmm.generate_map()
  model=mmm.model()
  mm=mmm.map_manager()
  assert approx_equal(
     model.get_sites_cart()[0], (14.476, 10.57, 8.34) ,eps=0.01)
  assert approx_equal(mm.map_data()[10,10,10],-0.0506,eps=0.001)
  # Save it
  mmm_dc=mmm.deep_copy()

  # Create model from sites
  mmm_sites = mmm_dc.deep_copy()
  from scitbx.array_family import flex
  sites_cart = flex.vec3_double()
  sites_cart.append((3,4,5))
  mmm_sites.model_from_sites_cart(sites_cart = sites_cart,
    model_id = 'new_model')
  assert mmm_sites.get_model_by_id('new_model').get_sites_cart()[0] == (3,4,5)
  ph_sites = mmm_sites.get_model_by_id('new_model').get_hierarchy()
  text_sites = mmm_sites.get_model_by_id('new_model').model_as_pdb()

  # Create model from hierarchy
  mmm_sites = mmm_dc.deep_copy()
  mmm_sites.model_from_hierarchy(hierarchy = ph_sites,
    model_id = 'new_model')
  assert mmm_sites.get_model_by_id('new_model').get_sites_cart()[0] == (3,4,5)

  # Create model from text
  mmm_sites = mmm_dc.deep_copy()
  mmm_sites.model_from_text(text = text_sites,
    model_id = 'new_model')
  assert mmm_sites.get_model_by_id('new_model').get_sites_cart()[0] == (3,4,5)



  # Set crystal_symmetry and unit_cell_crystal_symmetry and shift_cart
  # Box and shift the map_model_manager so we have new coordinate system
  mmm_sites.box_all_maps_around_model_and_shift_origin(box_cushion=4.5)
  new_model = mmm_sites.get_model_by_id('new_model')
  assert approx_equal((3., 4., 5.0),
     mmm_sites.get_model_by_id('new_model').get_sites_cart()[0])

  # arbitrarily set unit_cell crystal symmetry of model to
  #  match crystal_symmetry. First have to set shift_cart to None
  new_model.set_shift_cart(shift_cart = None)
  new_model.set_unit_cell_crystal_symmetry_and_shift_cart()
  assert new_model.crystal_symmetry() != mmm_sites.crystal_symmetry()

  # now set crystal symmetries and shift cart of model to match the manager
  mmm_sites.set_model_symmetries_and_shift_cart_to_match_map(new_model)
  assert new_model.crystal_symmetry().is_similar_symmetry(
    mmm_sites.crystal_symmetry())
  assert new_model.unit_cell_crystal_symmetry().is_similar_symmetry(
    mmm_sites.unit_cell_crystal_symmetry())
  assert new_model.shift_cart() == mmm_sites.shift_cart()

  # Import hierarchy into a model and set symmetries and shift to match
  mmm_sites.model_from_hierarchy(
   hierarchy = mmm_sites.model().get_hierarchy(),
   model_id='model_from_hierarchy')
  assert not show_diff(mmm_sites.get_model_by_id('model_from_hierarchy').model_as_pdb(),
     mmm_sites.get_model_by_id('model').model_as_pdb())


  # Check on wrapping
  assert not mm.wrapping()  # this one should not wrap because it is zero at edges

  # Make a new one with no buffer so it is not zero at edges
  mmm=map_model_manager()
  mmm.generate_map(box_cushion=0)
  mm=mmm.map_manager()
  # check its compatibility with wrapping
  assert mm.is_consistent_with_wrapping()
  mmm.show_summary()

  # now box it
  sel=mmm.model().selection("resseq 221:221")
  new_model=mmm.model().deep_copy().select(sel)
  new_mmm=map_model_manager(model=new_model,map_manager=mm.deep_copy())
  new_mmm.box_all_maps_around_model_and_shift_origin()
  new_mm=new_mmm.map_manager()

  assert not new_mm.wrapping()
  assert not new_mm.is_consistent_with_wrapping()

  # now box it with selection
  new_mmm_1=map_model_manager(
      model=mmm.model().deep_copy(),map_manager=mm.deep_copy())
  new_mmm_1.box_all_maps_around_model_and_shift_origin(
      selection_string="resseq 221:221")
  new_mm_1=new_mmm_1.map_manager()

  assert not new_mm_1.wrapping()
  assert not new_mm_1.is_consistent_with_wrapping()
  assert new_mm_1.map_data().all()== new_mm.map_data().all()

  # create map_model_manager with just half-maps
  mm1=mm.deep_copy()
  mm2=mm.deep_copy()
  map_data=mm2.map_data()
  map_data+=1.
  new_mmm=map_model_manager(model=mmm.model().deep_copy(),
    map_manager_1=mm1,
    map_manager_2=mm2)
  assert new_mmm._map_dict.get('map_manager') is None # should not be any yet
  assert approx_equal(new_mmm.map_manager().map_data()[232],
     mm.deep_copy().map_data()[232]+0.5)
  assert new_mmm._map_dict.get('map_manager') is not None # now should be there

  # generate map data from a model
  mm1=mm.deep_copy()
  mm2=mm.deep_copy()
  new_mmm=map_model_manager(model=mmm.model().deep_copy(), map_manager=mm1)
  mmm.generate_map(model=mmm.model())
  mm=mmm.map_manager()
  mmm.show_summary()

  # check get_map_model_manager function
  dm = DataManager(['model'])
  assert not hasattr(dm, 'get_map_model_manager')
  dm = DataManager(['real_map'])
  assert not hasattr(dm, 'get_map_model_manager')
  dm = DataManager(['sequence'])
  assert not hasattr(dm, 'get_map_model_manager')
  dm = DataManager(['model', 'real_map'])
  assert hasattr(dm, 'get_map_model_manager')

  # usage
  dm.get_map_model_manager(model_file=data_pdb, map_files=data_ccp4)
  dm.get_map_model_manager(model_file=data_pdb, map_files=[data_ccp4])
  dm.get_map_model_manager(model_file=data_pdb, map_files=[data_ccp4, data_ccp4, data_ccp4])
  dm.get_map_model_manager(model_file=data_pdb, map_files=data_ccp4, ignore_symmetry_conflicts=True)

  # errors
  try:
    dm.get_map_model_manager(model_file=data_pdb, map_files=data_ccp4, from_phil=True)
  except Sorry as e:
    assert 'from_phil is set to True' in str(e)
  try:
    dm.get_map_model_manager(model_file=data_pdb, map_files=data_ccp4, abc=123)
  except TypeError as e:
    assert 'unexpected keyword argument' in str(e)
  try:
    dm.get_map_model_manager(model_file=data_pdb, map_files=[data_ccp4, data_ccp4])
  except Sorry as e:
    assert '1 full map and 2 half maps' in str(e)

  # PHIL
  class test_program(ProgramTemplate):
    master_phil_str = '''
include scope iotbx.map_model_manager.map_model_phil_str
'''
  working_phil_str = '''
  map_model {
    full_map = %s
    half_map = %s
    half_map = s.mrc
    model = %s
  }
''' % (data_ccp4, data_ccp4, data_pdb)

  master_phil = parse(test_program.master_phil_str, process_includes=True)
  working_phil = master_phil.fetch(parse(working_phil_str))
  tp = test_program(dm, working_phil.extract())

  try:
    dm.get_map_model_manager(from_phil=True)
  except Exception as e:
    assert 'ignore_symmetry_conflicts' in str(e)
  try:
    dm.get_map_model_manager(from_phil=True, ignore_symmetry_conflicts=True)
  except AssertionError:
    pass

# ----------------------------------------------------------------------------

if (__name__ == '__main__'):
  if libtbx.env.find_in_repositories(relative_path='chem_data') is not None:
    test_01()
  else:
    print('Skip test_01, chem_data not available')
  print ("OK")


 *******************************************************************************


 *******************************************************************************
iotbx/regression/tst_map_model_manager_2.py
from __future__ import absolute_import, division, print_function
import iotbx.mrcfile
from cctbx.array_family import flex
import os, sys
from libtbx.test_utils import approx_equal
from libtbx.utils import Sorry
from mmtbx.model import manager as model_manager
from iotbx.data_manager import DataManager
from iotbx import mrcfile

def exercise(file_name=None, pdb_file_name = None, map_file_name = None ,
    split_pdb_file_name = None,
    ncs_pdb_file_name = None,
    out = sys.stdout):

  # Set up source data

  if not os.path.isfile(file_name):
    raise Sorry("Missing the file: %s" %(file_name)+"\n")

  print ("Reading from %s" %(file_name))
  from iotbx.map_manager import map_manager
  m = map_manager(file_name)

  print ("Header information from %s:" %(file_name))
  m.show_summary(out = out)

  map_data = m.map_data().deep_copy()
  crystal_symmetry = m.crystal_symmetry()
  unit_cell_parameters = m.crystal_symmetry().unit_cell().parameters()

  print ("\nMap origin: %s Extent %s"  %( map_data.origin(), map_data.all()))
  print ("Original unit cell, not just unit cell of part in this file): %s" %(
     str(unit_cell_parameters)))

  grid_point = (1, 2, 3)
  if map_data.origin() !=  (0, 0, 0): # make sure it is inside
    from scitbx.matrix import col
    grid_point = tuple (col(grid_point)+col(map_data.origin()))
  print ("\nValue of map_data at grid point %s: %.3f" %(str(grid_point),
    map_data[grid_point]))
  print ("Map data is %s" %(type(map_data)))

  random_position = (10, 5, 7.9)
  point_frac = crystal_symmetry.unit_cell().fractionalize(random_position)
  value_at_point_frac = map_data.eight_point_interpolation(point_frac)
  print ("Value of map_data at coordinates %s: %.3f" %(
      str(random_position), value_at_point_frac))

  map_data_as_float = map_data.as_float()
  print ("Map data as float is %s" %(type(map_data_as_float)))


  # make a little model
  sites_cart = flex.vec3_double( ((8, 10, 12), (14, 15, 16)))
  model = model_manager.from_sites_cart(
         atom_name = ' CA ',
         resname = 'ALA',
         chain_id = 'A',
         b_iso = 30.,
         occ = 1.,
         scatterer = 'C',
         sites_cart = sites_cart,
         crystal_symmetry = crystal_symmetry)


  # Move map and a model to place origin at (0, 0, 0)
  # map data is new copy but model is shifted in place.

  from iotbx.map_model_manager import map_model_manager
  mam = map_model_manager(
          map_manager =  m,
          model     = model.deep_copy(),
    )

  # Read in map and model and split up
  dm = DataManager()
  aa = dm.get_map_model_manager(model_file=pdb_file_name,
    map_files=map_file_name)
  cc = dm.get_map_model_manager(model_file=ncs_pdb_file_name,
    map_files=map_file_name)
  bb = dm.get_map_model_manager(model_file=split_pdb_file_name,
    map_files=map_file_name)

  # Merge by models
  a = aa.deep_copy()
  n_starting_models = len(list(a.model().get_hierarchy().models()))
  box_info = a.split_up_map_and_model_by_boxes()
  # Change the hierarchy in a box
  small_hierarchy = box_info.mmm_list[0].model().get_hierarchy()
  # delete an atom
  for m in small_hierarchy.models():
    for chain in m.chains()[:1]:
       chain.remove_residue_group(i = 0)
  box_info.mmm_list[0].model().reset_after_changing_hierarchy()  # REQUIRED
  # Put everything back together
  a.merge_split_maps_and_models(box_info = box_info,
      allow_changes_in_hierarchy = True)
  n_merged_models = len(list(a.model().get_hierarchy().models()))
  assert n_starting_models == 1
  assert n_merged_models == 7


  # Merge in various ways
  for selection_method in ['by_ncs_groups', 'by_chain', 'by_segment',
       'supplied_selections', 'boxes']:
    if selection_method == 'boxes':
      choices = [True, False]
    else:
      choices = [True]
    if selection_method == 'by_chain':
      mask_choices = [True,False]
    else:
      mask_choices = [False]
    for select_final_boxes_based_on_model in choices:
      for skip_empty_boxes in choices:
        for mask_choice in mask_choices:
          if selection_method == 'by_ncs_groups':
            a=cc.deep_copy()
          if mask_choice: # use split model
            a=bb.deep_copy()
          else: # usual
            a=aa.deep_copy()
          print ("\nRunning split_up_map_and_model with \n"+
            "select_final_boxes_based_on_model="+
           "%s   skip_empty_boxes=%s selection_method=%s" %(
            select_final_boxes_based_on_model,skip_empty_boxes,selection_method))

          if selection_method == 'by_chain':
            print ("Mask around unused atoms: %s" %(mask_choice))
            box_info = a.split_up_map_and_model_by_chain(
              mask_around_unselected_atoms=mask_choice)
          elif selection_method == 'by_segment':
            box_info = a.split_up_map_and_model_by_segment()
          elif selection_method == 'supplied_selections':
            selection = a.model().selection('all')
            box_info = a.split_up_map_and_model_by_supplied_selections(
              selection_list = [selection])
          elif selection_method == 'by_ncs_groups':
            box_info = a.split_up_map_and_model_by_ncs_groups()
          elif selection_method == 'boxes':
            box_info = a.split_up_map_and_model_by_boxes(
              skip_empty_boxes = skip_empty_boxes,
              select_final_boxes_based_on_model =
                select_final_boxes_based_on_model)
          assert box_info is not None
          print (selection_method,skip_empty_boxes,
              len(box_info.selection_list),
              box_info.selection_list[0].count(True))
          assert (selection_method,skip_empty_boxes,
              len(box_info.selection_list),
              box_info.selection_list[0].count(True)) in [
                ('by_chain',True,3,19),
                ("by_chain",True,1,86,),
                ("by_segment",True,1,86,),
                ("supplied_selections",True,1,86,),
                ("by_ncs_groups",True,1,86),
                ("boxes",True,7,9),
                ("boxes",False,12,0,),
                ("boxes",True,13,1,),
                ("boxes",False,36,0,),
                ], 'failed to find %s %s %s %s' % (
                    selection_method,
                    skip_empty_boxes,
                    len(box_info.selection_list),
                    box_info.selection_list[0].count(True))

          # Change the coordinates in one box
          small_model = box_info.mmm_list[0].model()
          small_sites_cart = small_model.get_sites_cart()
          from scitbx.matrix import col
          small_sites_cart += col((1,0,0))
          small_model.set_crystal_symmetry_and_sites_cart(
            sites_cart = small_sites_cart,
            crystal_symmetry = small_model.crystal_symmetry())
          # Put everything back together
          a.merge_split_maps_and_models(box_info = box_info)


  mam.box_all_maps_around_model_and_shift_origin()

  shifted_crystal_symmetry = mam.model().crystal_symmetry()
  shifted_model = mam.model()
  shifted_map_data = mam.map_data()

  print ("\nOriginal map origin (grid units):", map_data.origin())
  print ("Original model:\n", model.model_as_pdb())

  print ("Shifted map origin:", shifted_map_data.origin())
  print ("Shifted model:\n", shifted_model.model_as_pdb())


  # Save the map_model manager
  mam_dc=mam.deep_copy()
  print ("dc",mam)
  print ("dc mam_dc",mam_dc)

  # Mask map around atoms
  mam=mam_dc.deep_copy()
  print ("dc mam_dc dc",mam_dc)
  print (mam)
  mam.mask_all_maps_around_atoms(mask_atoms_atom_radius = 3,
     set_outside_to_mean_inside=True, soft_mask=False)
  print ("Mean before masking", mam.map_data().as_1d().min_max_mean().mean)
  assert approx_equal(mam.map_data().as_1d().min_max_mean().mean,
      -0.0585683621466)
  print ("Max before masking", mam.map_data().as_1d().min_max_mean().max)
  assert approx_equal(mam.map_data().as_1d().min_max_mean().max,
      -0.0585683621466)

  # Mask map around atoms, with soft mask
  mam=mam_dc.deep_copy()
  mam.mask_all_maps_around_atoms(mask_atoms_atom_radius = 3, soft_mask = True,
    soft_mask_radius = 5, set_outside_to_mean_inside=True)
  print ("Mean after first masking", mam.map_data().as_1d().min_max_mean().mean)
  assert approx_equal(mam.map_data().as_1d().min_max_mean().mean,
      0, eps= 0.05)
  print ("Max after first masking", mam.map_data().as_1d().min_max_mean().max)
  assert approx_equal(mam.map_data().as_1d().min_max_mean().max,
       0.10, eps = 0.05)

  # Mask map around atoms again
  mam.mask_all_maps_around_atoms(mask_atoms_atom_radius = 3,
     set_outside_to_mean_inside = True, soft_mask=False)
  print ("Mean after second masking", mam.map_data().as_1d().min_max_mean().mean)
  assert approx_equal(mam.map_data().as_1d().min_max_mean().mean,
     0, eps=0.1)
  print ("Max after second masking", mam.map_data().as_1d().min_max_mean().max)
  assert approx_equal(mam.map_data().as_1d().min_max_mean().max,
      0, eps=0.1)

  # Mask around edges
  mam=mam_dc.deep_copy()
  mam.mask_all_maps_around_edges( soft_mask_radius = 3)
  print ("Mean after masking edges", mam.map_data().as_1d().min_max_mean().mean)
  assert approx_equal(mam.map_data().as_1d().min_max_mean().mean,
      0, eps=0.05)
  print ("Max after masking edges", mam.map_data().as_1d().min_max_mean().max)
  assert approx_equal(mam.map_data().as_1d().min_max_mean().max,
      0.20, eps= 0.05)


  print ("\nWriting map_data and model in shifted position (origin at 0, 0, 0)")

  output_file_name = 'shifted_map.ccp4'
  print ("Writing to %s" %(output_file_name))
  mrcfile.write_ccp4_map(
      file_name = output_file_name,
      crystal_symmetry = shifted_crystal_symmetry,
      map_data = shifted_map_data, )

  output_file_name = 'shifted_model.pdb'
  f = open(output_file_name, 'w')
  print (shifted_model.model_as_pdb(), file=f)
  f.close()


  print ("\nWriting map_data and model in original position (origin at %s)" %(
      str(mam.map_manager().origin_shift_grid_units)))

  output_file_name = 'new_map_original_position.ccp4'
  print ("Writing to %s" %(output_file_name))
  mrcfile.write_ccp4_map(
      file_name = output_file_name,
      crystal_symmetry = shifted_crystal_symmetry,
      map_data = shifted_map_data,
      origin_shift_grid_units = mam.map_manager().origin_shift_grid_units)
  print (shifted_model.model_as_pdb())
  output_pdb_file_name = 'new_model_original_position.pdb'
  f = open(output_pdb_file_name, 'w')
  print (shifted_model.model_as_pdb(), file=f)
  f.close()

  # Write as mmcif
  output_cif_file_name = 'new_model_original_position.cif'
  f = open(output_cif_file_name, 'w')
  print (shifted_model.model_as_mmcif(),file = f)
  f.close()


  # Read the new map and model
  import iotbx.pdb
  with open(output_pdb_file_name) as f:
    lines = f.read()
  new_model =  model_manager(
     model_input = iotbx.pdb.input(
         source_info = None,
         lines = flex.split_lines(lines)),
         crystal_symmetry = crystal_symmetry)
  assert new_model.model_as_pdb() == model.model_as_pdb()

  with open(output_cif_file_name) as f:
    f.read()
  new_model_from_cif =  model_manager(
     model_input = iotbx.pdb.input(
         source_info = None,
         lines = flex.split_lines(lines)),
         crystal_symmetry = crystal_symmetry)
  assert new_model_from_cif.model_as_pdb() == model.model_as_pdb()

  # Read and box the original file again in case we modified m in any
  #   previous tests
  m = map_manager(file_name)
  mam=map_model_manager(model=model.deep_copy(),map_manager=m)
  mam.box_all_maps_around_model_and_shift_origin()

  file_name = output_file_name
  print ("Reading from %s" %(file_name))
  new_map = iotbx.mrcfile.map_reader(file_name = file_name, verbose = False)
  new_map.data = new_map.data.shift_origin()
  print ("Header information from %s:" %(file_name))
  new_map.show_summary(out = out)
  assert new_map.map_data().origin() == mam.map_manager().map_data().origin()
  assert new_map.crystal_symmetry().is_similar_symmetry(mam.map_manager().crystal_symmetry())

  # make a map_model_manager with lots of maps and model and ncs
  from mmtbx.ncs.ncs import ncs
  ncs_object=ncs()
  ncs_object.set_unit_ncs()
  mam = map_model_manager(
          map_manager =  m,
          ncs_object =  ncs_object,
          map_manager_1 =  m.deep_copy(),
          map_manager_2 =  m.deep_copy(),
          extra_model_list =  [model.deep_copy(),model.deep_copy()],
          extra_model_id_list = ["model_1","model_2"],
          extra_map_manager_list =  [m.deep_copy(),m.deep_copy()],
          extra_map_manager_id_list = ["extra_1","extra_2"],
          model     = model.deep_copy(),
    )


  # make a map_model_manager with lots of maps and model and ncs and run
  # with wrapping and ignore_symmetry_conflicts on
  from mmtbx.ncs.ncs import ncs
  ncs_object=ncs()
  ncs_object.set_unit_ncs()
  m.set_ncs_object(ncs_object.deep_copy())
  mam2 = map_model_manager(
          map_manager =  m.deep_copy(),
          ncs_object =  ncs_object.deep_copy(),
          map_manager_1 =  m.deep_copy(),
          map_manager_2 =  m.deep_copy(),
          extra_model_list =  [model.deep_copy(),model.deep_copy()],
          extra_model_id_list = ["model_1","model_2"],
          extra_map_manager_list =  [m.deep_copy(),m.deep_copy()],
          extra_map_manager_id_list = ["extra_1","extra_2"],
          model     = model.deep_copy(),
          ignore_symmetry_conflicts = True,
          wrapping = m.wrapping(),
    )
  assert mam.map_manager().is_similar(mam2.map_manager())
  assert mam.map_manager().is_similar(mam2.map_manager_1())
  for m in mam2.map_managers():
    assert mam.map_manager().is_similar(m)
  assert mam.model().shift_cart() == mam2.model().shift_cart()
  assert mam.model().shift_cart() == mam2.get_model_by_id('model_2').shift_cart()



  print ("OK")

if __name__ == "__main__":
  args = sys.argv[1:]
  if not args or len(args)<3:
    import libtbx.load_env
    file_name = libtbx.env.under_dist(
      module_name = "iotbx",
      path = "ccp4_map/tst_input.map")
    split_pdb_file_name = libtbx.env.under_dist(
      module_name = "iotbx",
      path = "regression/data/non_zero_origin_model_split.pdb")
    pdb_file_name = libtbx.env.under_dist(
      module_name = "iotbx",
      path = "regression/data/non_zero_origin_model.pdb")
    map_file_name = libtbx.env.under_dist(
      module_name = "iotbx",
      path = "regression/data/non_zero_origin_map.ccp4")
    ncs_pdb_file_name = libtbx.env.under_dist(
      module_name = "iotbx",
      path = "regression/data/non_zero_origin_ncs_model.pdb")
    args = [file_name,pdb_file_name, map_file_name,split_pdb_file_name,
        ncs_pdb_file_name]
  if libtbx.env.find_in_repositories(relative_path='chem_data') is not None:
    exercise(file_name = args[0], pdb_file_name=args[1], map_file_name=args[2],
     split_pdb_file_name=args[3],ncs_pdb_file_name=args[4])
  else:
    print('chem_data is not available, skipping')


 *******************************************************************************


 *******************************************************************************
iotbx/regression/tst_map_model_manager_3.py
from __future__ import absolute_import, division, print_function
from cctbx.array_family import flex
import os, sys
from libtbx.utils import Sorry
from libtbx.test_utils import approx_equal
from mmtbx.model import manager as model_manager
from iotbx.data_manager import DataManager

def exercise(file_name, out = sys.stdout):

  # Set up source data
  if not os.path.isfile(file_name):
    raise Sorry("Missing the file: %s" %(file_name)+"\n")

  print ("Reading from %s" %(file_name))
  from iotbx.map_manager import map_manager

  m = map_manager(file_name)

  # make a little model
  sites_cart = flex.vec3_double( ((8, 10, 12), (14, 15, 16)))
  model = model_manager.from_sites_cart(
         atom_name = ' CA ',
         resname = 'ALA',
         chain_id = 'A',
         b_iso = 30.,
         occ = 1.,
         scatterer = 'C',
         sites_cart = sites_cart,
         crystal_symmetry = m.crystal_symmetry())

  # make a map_model_manager with lots of maps and model and ncs
  from iotbx.map_model_manager import map_model_manager

  from mmtbx.ncs.ncs import ncs
  ncs_object=ncs()
  ncs_object.set_unit_ncs()
  mask_mm=m.deep_copy()
  mask_mm.set_is_mask(True)
  mam = map_model_manager(
          map_manager =  m,
          ncs_object =  ncs_object,
          map_manager_1 =  m.deep_copy(),
          map_manager_2 =  m.deep_copy(),
          extra_map_manager_list =  [m.deep_copy(),m.deep_copy(),m.deep_copy()],
          extra_map_manager_id_list = ["extra_1","extra_2","map_manager_mask"],
          model     = model.deep_copy(),)
  print (mam.map_manager())
  print (mam.model())
  print (mam.map_manager_1())
  print (mam.map_manager_2())
  print (mam.map_manager_mask())
  print (mam.map_manager().ncs_object())
  all_map_names=mam.map_id_list()
  for id in all_map_names:
    print("Map_manager %s: %s " %(id,mam.get_map_manager_by_id(id)))

  # Check the method all_objects_have_same_symmetry_and_shift_cart()
  # It should apply to changes in crystal_symmetry, unit_cell_crystal_symmetry,
  #   and shift_cart in model, map_model_manager, map_manager, and ncs_object

  print("\nChecking crystal_symmetry, unit_cell_crystal_symmetry, shift_cart"+
     " consistency")

  from cctbx import uctbx
  from cctbx import crystal
  from iotbx.map_model_manager import all_objects_have_same_symmetry_and_shift_cart

  # Change gridding on a map
  new_mam = mam.deep_copy()
  assert new_mam.check_consistency(stop_on_errors=False,print_errors=True)
  new_mm = new_mam.map_manager().resample_on_different_grid(n_real=(15,16,17))
  new_mam._map_dict['test'] = new_mm
  assert not new_mam.check_consistency(stop_on_errors=False,print_errors=True)

  # Check consistencies of cs, unit_cell cs and shift_cart

  for delta in [0.00001,0.15]:
    # Check unit_cell dims in model crystal_symmetry (this also checks for
    #   map_model_manager as its model is used to return crystal_symmetry).
    new_mam = mam.deep_copy()
    object_list = [new_mam, new_mam.model(), new_mam.map_manager_1(),
       new_mam.map_manager().ncs_object()]
    assert all_objects_have_same_symmetry_and_shift_cart(object_list)
    assert new_mam.check_consistency(stop_on_errors=False,print_errors=True)
    cs = new_mam.crystal_symmetry()
    shift_cart = new_mam.shift_cart()
    # Now change some objects outside the map_model_manager
    params = list(cs.unit_cell().parameters()[:6])
    params[1] += delta
    new_uc = uctbx.unit_cell(params)
    new_cs = crystal.symmetry(unit_cell=new_uc, space_group=cs.space_group())
    print("\nNew CS: ",new_cs)
    new_mam.model().set_crystal_symmetry(new_cs)
    print("\nCHECK WITH DELTA",delta)
    if delta < 0.01:
      assert all_objects_have_same_symmetry_and_shift_cart(object_list)
      assert new_mam.check_consistency(stop_on_errors=False,print_errors=True)
    else:
      assert not all_objects_have_same_symmetry_and_shift_cart(object_list,
        print_errors=True)
      assert not new_mam.check_consistency(stop_on_errors=False,print_errors=True)

  for delta in [None]:
    # Check SG in map_manager
    new_mam = mam.deep_copy()
    object_list = [new_mam, new_mam.model(), new_mam.map_manager_1(),
       new_mam.map_manager().ncs_object()]
    assert all_objects_have_same_symmetry_and_shift_cart(object_list)
    new_mam.map_manager().set_crystal_symmetry_of_partial_map(
      space_group_number=6)
    print("\nCHECK WITH new SG")
    assert not all_objects_have_same_symmetry_and_shift_cart(object_list,
        print_errors=True)

  for delta in [0.00001,0.15]:
    # Check unit_cell in model unit_cell_crystal_symmetry angles
    new_mam = mam.deep_copy()
    object_list = [new_mam, new_mam.model(), new_mam.map_manager_1(),
       new_mam.map_manager().ncs_object()]
    cs = new_mam.unit_cell_crystal_symmetry()
    shift_cart = new_mam.shift_cart()
    assert all_objects_have_same_symmetry_and_shift_cart(object_list)
    params = list(cs.unit_cell().parameters()[:6])
    params[4] += delta
    new_uc = uctbx.unit_cell(params)
    new_cs = crystal.symmetry(unit_cell=new_uc, space_group=cs.space_group())
    print("\nNew CS: ",new_cs)
    new_mam.model().set_unit_cell_crystal_symmetry(new_cs)
    print("\nCHECK WITH DELTA",delta)
    if delta < 0.01:
      assert all_objects_have_same_symmetry_and_shift_cart(object_list)
    else:
      assert not all_objects_have_same_symmetry_and_shift_cart(object_list,
        print_errors=True)

  for delta in [0.00001,0.15]:
    # Check unit_cell angles in model crystal_symmetry
    new_mam = mam.deep_copy()
    object_list = [new_mam, new_mam.model(), new_mam.map_manager_1(),
       new_mam.map_manager().ncs_object()]
    cs = new_mam.crystal_symmetry()
    shift_cart = new_mam.shift_cart()
    assert all_objects_have_same_symmetry_and_shift_cart(object_list)
    params = list(cs.unit_cell().parameters()[:6])
    params[4] += delta
    new_uc = uctbx.unit_cell(params)
    new_cs = crystal.symmetry(unit_cell=new_uc, space_group=cs.space_group())
    print("\nNew CS: ",new_cs)
    new_mam.model().set_crystal_symmetry(new_cs)
    print("\nCHECK WITH DELTA",delta)
    if delta < 0.01:
      assert all_objects_have_same_symmetry_and_shift_cart(object_list)
    else:
      assert not all_objects_have_same_symmetry_and_shift_cart(object_list,
        print_errors=True)

  for delta in [0.00001,0.15]:
    # Check shift_cart
    new_mam = mam.deep_copy()
    object_list = [new_mam, new_mam.model(), new_mam.map_manager_1(),
       new_mam.map_manager().ncs_object()]
    cs = new_mam.crystal_symmetry()
    shift_cart = new_mam.shift_cart()
    assert all_objects_have_same_symmetry_and_shift_cart(object_list)
    params = list(shift_cart)
    params[1] += delta
    new_shift_cart = params
    print("\nNew SC: ",new_shift_cart)
    new_mam.model().set_shift_cart(new_shift_cart)
    print("\nCHECK SC WITH DELTA",delta)
    if delta < 0.01:
      assert all_objects_have_same_symmetry_and_shift_cart(object_list)
    else:
      assert not all_objects_have_same_symmetry_and_shift_cart(object_list,
        print_errors=True)

  for delta in [0.00001,0.15]:
    # Check shift_cart in ncs object
    new_mam = mam.deep_copy()
    object_list = [new_mam, new_mam.model(), new_mam.map_manager_1(),
       new_mam.map_manager().ncs_object()]
    cs = new_mam.crystal_symmetry()
    shift_cart = new_mam.shift_cart()
    assert all_objects_have_same_symmetry_and_shift_cart(object_list)
    params = list(shift_cart)
    params[1] += delta
    new_shift_cart = params
    print("\nNew SC: ",new_shift_cart)
    new_mam.map_manager().ncs_object().set_shift_cart(new_shift_cart)
    print("\nCHECK SC ncs WITH DELTA",delta)
    if delta < 0.01:
      assert all_objects_have_same_symmetry_and_shift_cart(object_list)
      assert new_mam.map_manager().check_consistency(print_errors=True,
         stop_on_errors=True)
    else:
      assert not all_objects_have_same_symmetry_and_shift_cart(object_list,
        print_errors=True)
      assert not new_mam.map_manager().check_consistency(print_errors=True,
         stop_on_errors=False)


  dm = DataManager(['model','miller_array', 'real_map', 'phil','ncs_spec'])
  dm.set_overwrite(True)

  # Create a model with ncs
  from iotbx.regression.ncs.tst_ncs import pdb_str_5
  file_name='tst_mam.pdb'
  f=open(file_name,'w')
  print (pdb_str_5, file = f)
  f.close()

  # Generate map data from this model (it has ncs)
  mmm=map_model_manager()
  mmm.generate_map(box_cushion=0, file_name=file_name,n_residues=500, d_min=3)
  ncs_mam=mmm.deep_copy()
  ncs_mam_copy=mmm.deep_copy()

  # Make sure this model has 126 sites (42 sites times 3-fold ncs)
  assert ncs_mam.model().get_sites_cart().size() == 126
  assert approx_equal (ncs_mam.model().get_sites_cart()[0],
    (23.560999999999996, 8.159, 10.660000000000002), 1e-4)

  # Get just unique part (42 sites)
  unique_mam=ncs_mam.extract_all_maps_around_model(select_unique_by_ncs=True)
  assert unique_mam.model().get_sites_cart().size() == 42
  assert approx_equal (unique_mam.model().get_sites_cart()[0],
    (18.740916666666664, 13.1794, 16.10544), 1e-3)

  # Make sure that the extraction did not change the original but does change
  #   the extracted part
  assert (unique_mam.model().get_sites_cart()[0] !=
     ncs_mam.model().get_sites_cart()[0])  # it was a deep copy so original stays

  # Shift back the extracted part and make sure it matches the original now
  shifted_back_unique_model=mmm.get_model_from_other(unique_mam.deep_copy())
  assert approx_equal (shifted_back_unique_model.get_sites_cart()[0],
    (23.560999999999996, 8.158999999999997, 10.66), 1e-4)

  # Change the extracted model
  sites_cart=unique_mam.model().get_sites_cart()
  sites_cart[0]=(1,1,1)
  unique_mam.model().get_hierarchy().atoms().set_xyz(sites_cart)
  # Note; setting xyz in hierarchy does not set xrs by itself. do that now:
  unique_mam.model().set_sites_cart_from_hierarchy(multiply_ncs=False)

  # Make sure we really changed it
  assert approx_equal (unique_mam.model().get_sites_cart()[0], (1,1,1))

  # Now propagate all the changes in this unique part to entire original model
  #   using NCS
  ncs_mam.propagate_model_from_other(other = unique_mam,
    model_id = 'model',
    other_model_id = 'model')
  # ...and check that copy 1 and copy 2 both change
  assert approx_equal (ncs_mam.model().get_sites_cart()[0],
     (5.820083333333333, -4.020400000000001, -4.445440000000001), 1e-3)
  assert approx_equal (ncs_mam.model().get_sites_cart()[42],
     (38.41904613024224, 17.233251085893276, 2.5547442135142524), 1e-3)

  # Find ncs from map or model
  nn=ncs_mam_copy
  nn.write_map('ncs.ccp4')
  nn.write_model('ncs.pdb')
  ncs_object=nn.get_ncs_from_model()
  dm.write_ncs_spec_file(ncs_object,'ncs.ncs_spec')
  print ("NCS from map",ncs_object)
  nn.set_ncs_object(ncs_object)
  print ("NCS now: ",nn.ncs_object())
  nn.get_ncs_from_map(ncs_object=ncs_object)
  print ("ncs cc:",nn.ncs_cc())
  assert approx_equal(nn.ncs_cc(),0.961915979834,eps=0.01)

  # Make a deep_copy
  dc=mam.deep_copy()
  new_mam=mam.deep_copy()
  assert mam.map_manager().map_data()[0]==new_mam.map_manager().map_data()[0]

  # Make a customized_copy
  new_mam=mam.customized_copy(model_dict={'model':mam.model()})
  assert new_mam.model() is mam.model()
  assert not new_mam.map_dict() is mam.map_dict()

  new_mam=mam.customized_copy(model_dict={'model':mam.model()},
    map_dict=mam.map_dict())
  assert new_mam.model() is mam.model()
  assert new_mam.map_dict() is mam.map_dict()
  print (mam)

  # Add a map
  mam = dc.deep_copy()
  print (mam.map_id_list())
  assert len(mam.map_id_list()) == 6
  mam.add_map_manager_by_id(mam.map_manager().deep_copy(),'new_map_manager')
  print (mam.map_id_list())
  assert len(mam.map_id_list()) == 7

  # duplicate a map
  mam = dc.deep_copy()
  print (mam.map_id_list())
  assert len(mam.map_id_list()) == 6
  mam.duplicate_map_manager('map_manager','new_map_manager')
  print (mam.map_id_list())
  assert len(mam.map_id_list()) == 7

  # resolution_filter a map
  mam = dc.deep_copy()
  print (mam.map_id_list())
  mam.duplicate_map_manager('map_manager','new_map_manager')
  mam.resolution_filter(map_id='new_map_manager',d_min=3.5,d_max=6)

  # Add a model
  mam = dc.deep_copy()
  print (mam.model_id_list())
  assert len(mam.model_id_list()) == 1
  mam.add_model_by_id(mam.model().deep_copy(),'new_model')
  print (mam.model_id_list())
  assert len(mam.model_id_list()) == 2

  # Initialize a map
  mam1=new_mam.deep_copy()
  mam1.initialize_maps(map_value=6)
  assert mam1.map_manager().map_data()[225] == 6

  # Create mask around density and apply to all maps
  mam1=new_mam.deep_copy()
  mam1.mask_all_maps_around_density(solvent_content=0.5,
    soft_mask=False,)
  s = (mam1.get_map_manager_by_id('mask').map_data() > 0.5)
  assert approx_equal( (s.count(True),s.size()), (1024,2048))

  # Create soft mask around density and apply to all maps
  mam1=new_mam.deep_copy()
  mam1.mask_all_maps_around_density(solvent_content=0.5,
    soft_mask=True,)
  s = (mam1.get_map_manager_by_id('mask').map_data() > 0.5)

  # Create mask around edges and apply to all maps
  mam1=new_mam.deep_copy()
  mam1.write_map('before.ccp4')
  mam1.mask_all_maps_around_edges(soft_mask_radius=8)
  mam1.write_map('after.ccp4')
  mam1.write_map(map_id = 'mask',file_name='mask.ccp4')
  s = (mam1.get_map_manager_by_id('mask').map_data() > 0.5)
  assert approx_equal( (s.count(True),s.size()), (1496, 2048))

  # Create a  mask around atoms and apply to all maps
  new_mam.mask_all_maps_around_atoms(mask_atoms_atom_radius=8,
      soft_mask=False)
  s = (new_mam.get_map_manager_by_id('mask').map_data() > 0.5)
  assert approx_equal( (s.count(True),s.size()), (138,2048))

  # Create a soft mask around atoms and apply to all maps
  new_mam.mask_all_maps_around_atoms(mask_atoms_atom_radius=8,
      soft_mask=True)
  s = (new_mam.get_map_manager_by_id('mask').map_data() > 0.5)
  assert approx_equal( (s.count(True),s.size()), (1924,2048))

  # Create a soft mask around atoms and do not do anything with it
  new_mam.create_mask_around_atoms(mask_atoms_atom_radius=8,
      soft_mask=True)
  s = (new_mam.get_map_manager_by_id('mask').map_data() > 0.5)
  assert approx_equal( (s.count(True),s.size()), (1924,2048))

  # Create a soft mask around atoms; do not do anything with it, wrapping =true
  dummy_mam=new_mam.deep_copy()
  dummy_mam.map_manager().set_wrapping(True)
  dummy_mam.create_mask_around_atoms(mask_atoms_atom_radius=8,
      soft_mask=True)
  s = (dummy_mam.get_map_manager_by_id('mask').map_data() > 0.5)
  assert approx_equal( (s.count(True),s.size()), (1924,2048))

  # Mask around edges and do not do anything with it
  mam=dc.deep_copy()
  mam.create_mask_around_edges()
  s = (mam.get_map_manager_by_id('mask').map_data() > 0.5)
  mam.write_map(map_id='mask',file_name='edge.ccp4')
  assert approx_equal( (s.count(True),s.size()), (1792,2048))

  # Mask around density and to not do anything with it
  mam=dc.deep_copy()
  mam.create_mask_around_density(soft_mask=False)
  s = (mam.get_map_manager_by_id('mask').map_data() > 0.5)
  assert approx_equal( (s.count(True),s.size()), (856,2048))

  # Apply the current mask to one map
  mam.apply_mask_to_map('map_manager')
  s = (mam.map_manager().map_data() > 0.)
  assert approx_equal( (s.count(True),s.size()), (424,2048))
  s = (mam.map_manager().map_data() != 0.)
  assert approx_equal( (s.count(True),s.size()), (856,2048))
  assert approx_equal ((mam.map_manager().map_data()[225]),-0.0418027862906)

  # Apply any mask to one map
  mam.apply_mask_to_map('map_manager',mask_id='mask')
  s = (mam.map_manager().map_data() > 0.)
  assert approx_equal( (s.count(True),s.size()), (424,2048))
  s = (mam.map_manager().map_data() != 0.)
  assert approx_equal( (s.count(True),s.size()), (856,2048))
  assert approx_equal ((mam.map_manager().map_data()[225]),-0.0418027862906)

  # Apply the mask to all maps
  mam.apply_mask_to_maps()
  s = (mam.map_manager().map_data() > 0.)
  assert approx_equal( (s.count(True),s.size()), (424,2048))
  s = (mam.map_manager().map_data() != 0.)
  assert approx_equal( (s.count(True),s.size()), (856,2048))
  assert approx_equal ((mam.map_manager().map_data()[225]),-0.0418027862906)

  # Apply the mask to all maps, setting outside value to mean inside
  mam.apply_mask_to_maps(set_outside_to_mean_inside=True)
  s = (mam.map_manager().map_data() > 0.)
  assert approx_equal( (s.count(True),s.size()), (424,2048))
  s = (mam.map_manager().map_data() != 0.)
  assert approx_equal( (s.count(True),s.size()), (2048,2048))
  assert approx_equal ((mam.map_manager().map_data()[2047]),-0.0759598612785)
  s = (mam.get_map_manager_by_id('mask').map_data() >  0).as_1d()
  inside = mam.map_manager().map_data().as_1d().select(s)
  outside = mam.map_manager().map_data().as_1d().select(~s)
  assert approx_equal ((inside.min_max_mean().max,outside.min_max_mean().max),
   (0.317014873028,-0.0159585822888))


  # Make a new map and model, get mam and box with selection
  mmm=map_model_manager()
  mmm.generate_map(box_cushion=0,wrapping=True, d_min=3)
  mam=mmm
  mam_dc=mam.deep_copy()
  new_mm_1=mam.map_manager()
  assert approx_equal( (mmm.map_data().all(),new_mm_1.map_data().all()),
     ((18, 25, 20),(18, 25, 20)))

  # Get local fsc or randomized map
  dc=mam_dc.deep_copy()
  dc.map_manager().set_wrapping(False)
  map_coeffs = dc.map_manager().map_as_fourier_coefficients(d_min=3)
  from cctbx.development.create_models_or_maps import generate_map
  new_mm_1 = generate_map(map_coeffs=map_coeffs,
    d_min=3,
    low_resolution_real_space_noise_fraction=1,
    high_resolution_real_space_noise_fraction=50,
    map_manager=dc.map_manager(),
    random_seed=124321)
  new_mm_2 = generate_map(map_coeffs=map_coeffs,
    d_min=3,
    low_resolution_real_space_noise_fraction=1,
    high_resolution_real_space_noise_fraction=50,
    map_manager=dc.map_manager(),
    random_seed=734119)
  dc.add_map_manager_by_id(new_mm_1,'map_manager_1')
  dc.add_map_manager_by_id(new_mm_2,'map_manager_2')
  cc=dc.map_map_cc()
  fsc_curve=dc.map_map_fsc()
  dc.set_log(sys.stdout)
  dc.local_fsc(n_boxes = 1)

  # Get map-map FSC
  dc=mam_dc.deep_copy()
  dc.duplicate_map_manager(map_id='map_manager',new_map_id='filtered')
  dc.resolution_filter(d_min=3.5, d_max=10, map_id='filtered')
  dc.create_mask_around_atoms()
  fsc_curve=dc.map_map_fsc(
      map_id_1='map_manager',map_id_2='filtered',mask_id='mask',
      resolution=3.5,fsc_cutoff = 0.97)
  assert approx_equal(fsc_curve.d_min, 3.44, eps=0.01)
  assert approx_equal (fsc_curve.fsc.fsc[-1],0.7097, eps = 0.01)

  # Get map-map CC
  dc=mam_dc.deep_copy()
  dc.duplicate_map_manager(map_id='map_manager',new_map_id='filtered')
  dc.resolution_filter(d_min=3.5, d_max=6, map_id='filtered')
  cc=dc.map_map_cc('map_manager','filtered')
  assert approx_equal(cc , 0.6504435255003295)

  # Get map-map CC with mask
  dc=mam_dc.deep_copy()
  dc.duplicate_map_manager(map_id='map_manager',new_map_id='filtered')
  dc.create_mask_around_density(mask_id='filtered')
  cc=dc.map_map_cc('map_manager','filtered',mask_id='mask')
  assert approx_equal(cc , 0.4515628372038732)

  # box around model
  mam=mam_dc.deep_copy()
  mam.box_all_maps_around_model_and_shift_origin(
      selection_string="resseq 221:221")
  new_mm_1=mam.map_manager()
  assert approx_equal( (mam_dc.map_data().all(),new_mm_1.map_data().all()),
    ((18, 25, 20),(24, 20, 20)))

  # box around model and add soft mask to edges
  mam=mam_dc.deep_copy()
  mam.box_all_maps_around_model_and_shift_origin(
      selection_string="resseq 221:221",
      soft_mask_around_edges = True)
  new_mm_2=mam.map_manager()
  assert approx_equal( (mam_dc.map_data().all(),new_mm_2.map_data().all()),
    ((18, 25, 20),(40,35,38)))

  # extract_around_model (get new mam)
  new_mam_dc=mam_dc.extract_all_maps_around_model(
      selection_string="resseq 221:221")
  new_mm_1a=new_mam_dc.map_manager()
  assert approx_equal( (mam_dc.map_data().all(),new_mm_1a.map_data().all()),
    ((18, 25, 20),(24, 20, 20)))
  assert approx_equal(new_mm_1.map_data(),new_mm_1a.map_data())

  # extract_around_model (get new mam) and soft_mask_around_edges
  new_mam_dc=mam_dc.extract_all_maps_around_model(
      selection_string="resseq 221:221", soft_mask_around_edges = True)
  new_mm_2a=new_mam_dc.map_manager()
  assert approx_equal( (mam_dc.map_data().all(),new_mm_2a.map_data().all()),
    ((18, 25, 20),(40,35,38)))
  assert approx_equal(new_mm_2.map_data(),new_mm_2a.map_data())

  # box around_density
  mam2=mam_dc.deep_copy()
  mam2.box_all_maps_around_density_and_shift_origin(box_cushion=0)
  new_mm_2=mam2.map_manager()
  assert approx_equal( (mam_dc.map_data().all(),new_mm_2.map_data().all()),
    ((18, 25, 20),(16, 18, 18)))

  # extract_around_density (get new mam)
  mam2=mam_dc.deep_copy()
  mam2_b=mam2.extract_all_maps_around_density(box_cushion=0)
  new_mm_2=mam2_b.map_manager()
  assert approx_equal( (mam_dc.map_data().all(),new_mm_2.map_data().all()),
    ((18, 25, 20),(16, 18, 18)))

  # Repeat as map_model_manager:
  mmm=mam_dc.as_map_model_manager().deep_copy()
  mmm.box_all_maps_around_model_and_shift_origin(
      selection_string="resseq 221:221")
  new_mm_1a=mmm.map_manager()
  assert approx_equal( (mam_dc.map_data().all(),new_mm_1a.map_data().all()),
    ((18, 25, 20),(24, 20, 20)))
  assert approx_equal(new_mm_1.map_data(),new_mm_1a.map_data())

  # box around density
  mam = mam_dc.deep_copy()
  mam.box_all_maps_around_density_and_shift_origin(box_cushion=0,soft_mask_around_edges=False)
  new_mm_1=mam.map_manager()
  assert approx_equal( (mam_dc.map_data().all(),new_mm_1.map_data().all()),
    ((18,25 , 20),(16, 18, 18)))

  # box around density and soft mask edges
  mam = mam_dc.deep_copy()
  mam.box_all_maps_around_density_and_shift_origin(box_cushion=0,
   soft_mask_around_edges=True)
  new_mm_1=mam.map_manager()
  assert approx_equal( (mam_dc.map_data().all(),new_mm_1.map_data().all()),
    ((18, 25 , 20),(18, 25, 20)))

  # extract around density (get new mam)
  mam1=mam_dc.deep_copy()
  mam1.extract_all_maps_around_density(box_cushion=0)
  new_mm_1=mam1.map_manager()
  assert approx_equal( (mmm.map_data().all(),new_mm_1.map_data().all()),
    ((24, 20, 20),(18, 25, 20)))

  # create mask around density, then box around mask (i.e., box around density)
  mam.create_mask_around_density(soft_mask=False)
  mam.box_all_maps_around_mask_and_shift_origin(box_cushion=3)
  new_mm_1=mam.map_manager()
  assert approx_equal( (mmm.map_data().all(),new_mm_1.map_data().all()),
    ((24, 20, 20),(18, 25, 20)))

  # box with bounds
  mam.box_all_maps_with_bounds_and_shift_origin(lower_bounds=(10,10,10),
     upper_bounds=(15,15,15))
  new_mm_1=mam.map_manager()
  assert approx_equal( (mmm.map_data().all(),new_mm_1.map_data().all()),
    ((24, 20, 20),(6, 6, 6)))

  # extract with bounds
  mam=mam_dc.deep_copy()
  mam_1=mam.extract_all_maps_with_bounds(lower_bounds=(10,10,10),
     upper_bounds=(15,15,15))
  new_mm_1=mam_1.map_manager()
  assert approx_equal( (mmm.map_data().all(),new_mm_1.map_data().all()),
    ((24, 20, 20),(6, 6, 6)))

  # box with unique
  mam=mam_dc.deep_copy()
  mam.box_all_maps_around_unique_and_shift_origin(
      molecular_mass=2500,resolution=3)
  new_mm_1=mam.map_manager()
  assert approx_equal( (mmm.map_data().all(),new_mm_1.map_data().all()),
    ((24, 20, 20),(18, 25, 20)))

  # extract with unique
  mam=mam_dc.deep_copy()
  mam_1=mam.extract_all_maps_around_unique(
      molecular_mass=2500,resolution=3)
  new_mm_1=mam_1.map_manager()
  assert approx_equal( (mmm.map_data().all(),new_mm_1.map_data().all()),
    ((24,20, 20),(18, 25, 20)))

  # extract a box and then restore model into same reference as current mam
  mam=mam_dc.deep_copy()
  mam.box_all_maps_with_bounds_and_shift_origin(lower_bounds=(2,2,2),
     upper_bounds=(17,17,17))
  print("mam:",mam.model().get_sites_cart()[0],mam.map_manager().origin_is_zero())
  # extract a box
  box_mam=mam.extract_all_maps_with_bounds(lower_bounds=(10,10,10),
     upper_bounds=(15,15,15))
  box_model=box_mam.model()
  matched_box_model=mam.get_model_from_other(box_mam)
  assert approx_equal(matched_box_model.get_sites_cart()[0],mam.model().get_sites_cart()[0])

  # Convert a map to fourier coefficients
  mam=mam_dc.deep_copy()
  ma=mam.map_as_fourier_coefficients(d_min=3)
  assert approx_equal(ma.d_min(),3.01655042414)


  mam.add_map_from_fourier_coefficients(ma, map_id='new_map_manager')
  cc=flex.linear_correlation(
   mam.get_map_manager_by_id('map_manager').map_data().as_1d(),
   mam.get_map_manager_by_id('new_map_manager').map_data().as_1d()).coefficient()
  assert (cc >= 0.99)

  # Get map-model CC
  dc=mam_dc.extract_all_maps_around_model(
      selection_string="(name ca or name cb or name c or name o) "+
        "and resseq 221:221", box_cushion=0)
  cc=dc.map_model_cc(resolution=3)
  assert approx_equal (cc, 0.817089390421)

  # Get map-model density
  dc=mam_dc.extract_all_maps_around_model(
      selection_string="(name ca or name cb or name c or name o) "+
        "and resseq 221:221", box_cushion=0)
  density=dc.density_at_model_sites(selection_string = 'name ca')
  assert approx_equal (density.min_max_mean().mean, 0.841152333991)


  # Remove model outside map
  dc.remove_model_outside_map(boundary=0)
  assert (mam_dc.model().get_sites_cart().size(),
     dc.model().get_sites_cart().size()) == (86, 4)

  # shift a model to match the map
  dc=mam_dc.extract_all_maps_around_model(
      selection_string="(name ca or name cb or name c or name o) "+
        "and resseq 221:221", box_cushion=0)
  actual_model=dc.model().deep_copy()
  working_model=dc.model().deep_copy()
  working_model.set_shift_cart((0,0,0))
  working_model.set_sites_cart(working_model.get_sites_cart()-actual_model.shift_cart())
  dc.shift_any_model_to_match(working_model)
  assert approx_equal (actual_model.get_sites_cart()[0],working_model.get_sites_cart()[0])


if __name__ == "__main__":
  args = sys.argv[1:]
  import libtbx.load_env
  if not args:
    file_name = libtbx.env.under_dist(
      module_name = "iotbx",
      path = "ccp4_map/tst_input.map")
    args = [file_name]
  if libtbx.env.has_module("phenix"):
    exercise(file_name = args[0])
  else:
    print("Skipped: Requires phenix module")

  print ("OK")


 *******************************************************************************


 *******************************************************************************
iotbx/regression/tst_map_model_manager_4.py
from __future__ import absolute_import, division, print_function
import sys, os
from scitbx.array_family import flex
from libtbx.test_utils import approx_equal


data_dir = os.path.dirname(os.path.abspath(__file__))
random_map_a = os.path.join(data_dir, 'data', "mmma.ccp4")
random_map_b = os.path.join(data_dir, 'data', "mmmb.ccp4")

def get_map_model_managers():
  # Set up source data
  from iotbx.map_model_manager import map_model_manager
  mmm = map_model_manager()
  mmm.generate_map(wrapping=True, d_min=3)
  second_model=mmm.model().deep_copy()
  mmm.box_all_maps_with_bounds_and_shift_origin(
    lower_bounds=[-1,-1,0], upper_bounds=[30, 40, 32])
  mmm.map_manager().set_wrapping(False)
  mmm.set_log(sys.stdout)

  #now get a second one

  from scitbx import matrix
  r=matrix.sqr((-0.8090,0.5878,0.0000,
   -0.5878,-0.8090,-0.0000,
   0.0000,-0.0000,1.0000,))
  t = matrix.col((100,0,0))
  new_sites_cart = r.elems*mmm.model().get_sites_cart() + t.elems
  second_model.set_sites_cart(new_sites_cart)
  from cctbx.maptbx.box import shift_and_box_model
  second_model = shift_and_box_model(second_model)

  second_mmm = map_model_manager(model=second_model)
  second_mmm.generate_map(model=second_model,wrapping=True, d_min=3)
  second_mmm.box_all_maps_around_model_and_shift_origin(box_cushion=10)
  second_mmm.map_manager().set_wrapping(False)
  second_mmm.set_log(sys.stdout)

  print(mmm.model().get_sites_cart()[0])
  print(second_mmm.model().get_sites_cart()[0])
  return mmm, second_mmm

def exercise( out = sys.stdout):


  # test shift_aware_rt

  mmm1, mmm2 = get_map_model_managers()
  initial_shift_aware_rt_info= mmm1.shift_aware_rt_to_superpose_other(mmm2)
  initial_rt_info=initial_shift_aware_rt_info.working_rt_info(from_obj=mmm2,to_obj=mmm1)

  model_2=mmm2.model().apply_selection_string("resseq 222:235")
  mmm2.set_model(model_2)
  shift_aware_rt_info= mmm1.shift_aware_rt_to_superpose_other(mmm2)
  rt_info=shift_aware_rt_info.working_rt_info(from_obj=mmm2,to_obj=mmm1)
  assert shift_aware_rt_info.is_similar(initial_shift_aware_rt_info,tol=0.002)

  shift_aware_rt = mmm1.shift_aware_rt(working_rt_info=rt_info,
     from_obj = mmm2, to_obj = mmm1)

  shift_aware_rt = mmm1.map_manager().shift_aware_rt(working_rt_info=rt_info,
     from_obj = mmm2, to_obj = mmm1)
  print (mmm1, mmm2)
  sites_cart_2 = mmm2.model().get_sites_cart()
  mapped_sites_cart = shift_aware_rt.apply_rt(sites_cart=sites_cart_2,
    from_obj=mmm2, to_obj=mmm1)
  assert approx_equal(mapped_sites_cart,mmm1.model().apply_selection_string("resseq 222:235").get_sites_cart(), eps=0.01)
  working_rt_info = shift_aware_rt.working_rt_info(from_obj=mmm2, to_obj=mmm1)
  mapped_sites_cart =working_rt_info.r.elems * mmm2.model().get_sites_cart() + working_rt_info.t.elems
  assert approx_equal(mapped_sites_cart,mmm1.model().apply_selection_string("resseq 222:235").get_sites_cart(), eps=0.01)

  inverse_shift_aware_rt = shift_aware_rt.inverse()
  mapped_sites_cart = inverse_shift_aware_rt.apply_rt(sites_cart=mmm1.model().apply_selection_string("resseq 222:235").get_sites_cart(),from_obj=mmm1,to_obj=mmm2)
  assert approx_equal(mapped_sites_cart,mmm2.model().get_sites_cart(), eps=0.01)

  mmm1, mmm2 = get_map_model_managers()

  # get r,t to map mmm2 model on mmm1 model
  shift_aware_rt_info= mmm1.shift_aware_rt_to_superpose_other(mmm2)
  rt_info=shift_aware_rt_info.working_rt_info(from_obj=mmm2,to_obj=mmm1)

  # get mmm2 map superimposed on mmm1 map (in region where it is defined, zero
  #   outside that region)

  new_mm = mmm1.superposed_map_manager_from_other(other=mmm2)
  new_mm.write_map('super.ccp4')
  mmm1.write_map('orig.ccp4')
  mmm1.write_model('orig.pdb')

  new_mm = mmm1.superposed_map_manager_from_other(other=mmm2,
    selection_string="resseq 221:225")
  assert approx_equal(new_mm.map_map_cc(mmm1.map_manager()),0.994645868918,eps=0.01)
  new_mm.write_map('super_221-225.ccp4')

  new_mm = mmm1.superposed_map_manager_from_other(other=mmm2,
     working_rt_info = rt_info)
  assert approx_equal(new_mm.map_map_cc(mmm1.map_manager()),0.994645868918,eps=0.01)
  new_mm.write_map('super_221-225.ccp4')

  # get a local resolution map (this one should look pretty constant!)
  mmm1.set_resolution(3)
  mmma = mmm1.deep_copy()
  model = mmm1.model()
  mmma.remove_model_by_id('model')
  mmmb = mmma.deep_copy()

  mmma.map_manager().randomize(random_seed=23412,d_min=3,high_resolution_fourier_noise_fraction=10,low_resolution_noise_cutoff=5)
  mmmb.map_manager().randomize(random_seed=887241,d_min=3,high_resolution_fourier_noise_fraction=10,low_resolution_noise_cutoff=5)

  #  We are going to read in these maps so that we have a constant value
  from iotbx.data_manager import DataManager
  dm = DataManager()
  mmma_map = dm.get_real_map(random_map_a)
  mmmb_map = dm.get_real_map(random_map_b)
  mmma_map.shift_origin()
  mmmb_map.shift_origin()
  mmma.add_map_manager_by_id(map_id="map_manager", map_manager=mmma_map)
  mmmb.add_map_manager_by_id(map_id="map_manager", map_manager=mmmb_map)

  assert approx_equal(mmma.map_manager().map_map_cc(mmmb.map_manager()),
    0.16,0.10)
  from iotbx.map_model_manager import map_model_manager
  model.set_b_iso(flex.double(model.get_sites_cart().size(),0))
  local_mmm=map_model_manager(map_manager_1=mmma.map_manager(),
    map_manager_2=mmmb.map_manager(), model = model)
  local_mmm.set_resolution(3)
  local_mmm.local_fsc()

  from iotbx.data_manager import DataManager
  dm = DataManager()
  dm.set_overwrite(True)

  cc_before = local_mmm.map_model_cc()
  print ("Working with randomized maps cc = ",cc_before)
  dc = local_mmm.deep_copy()
  dc.set_log(sys.stdout)
  cc_before = dc.map_model_cc()
  dc.half_map_sharpen(n_bins=15)
  cc_after = dc.map_model_cc(map_id='map_manager_scaled')
  print("CC before, after half map sharpen: ",cc_before,cc_after)
  assert approx_equal((cc_before,cc_after), (0.80, 0.80), eps=0.10)

  dc = local_mmm.deep_copy()
  dc.set_log(sys.stdout)
  cc_before = dc.map_model_cc()
  dc.model_sharpen(n_bins=15, local_sharpen=False, anisotropic_sharpen=False,
    optimize_b_eff=False)
  cc_after = dc.map_model_cc(map_id='map_manager_scaled')
  print("CC before, after std model sharpen: ",cc_before,cc_after)
  assert approx_equal ((cc_before,cc_after), (0.80,0.90), eps =0.10)
  model_sharpened_mm = dc.get_map_manager_by_id(map_id='map_manager_scaled')

  dc = local_mmm.deep_copy()
  dc.set_log(sys.stdout)
  cc_before = dc.map_model_cc()
  dc.model_sharpen(local_sharpen=True,n_boxes=1,n_bins=15)
  cc_after = dc.map_model_cc(map_id='map_manager_scaled')
  print("CC before, after local model sharpen n_boxes=1: ",cc_before,cc_after)
  assert approx_equal ((cc_before,cc_after), (0.80,0.90), eps =0.10)
  model_sharpened_mm = dc.get_map_manager_by_id(map_id='map_manager_scaled')

  dc = local_mmm.deep_copy()
  dc.set_log(sys.stdout)
  dc.add_map_manager_by_id(model_sharpened_mm,'external_map')
  cc_before = dc.map_map_cc(map_id='map_manager',other_map_id='external_map')
  dc.external_sharpen(n_bins=15,map_id_external_map='external_map')
  cc_after = dc.map_map_cc(map_id='map_manager_scaled',other_map_id='external_map')
  print("CC before, after external sharpen n_boxes=1: ",cc_before,cc_after)
  assert approx_equal ((cc_before,cc_after), (0.7,0.95),eps=0.10)

  dc = local_mmm.deep_copy()
  dc.set_log(sys.stdout)
  dc.add_map_manager_by_id(model_sharpened_mm,'external_map')
  cc_before = dc.map_map_cc(map_id='map_manager',other_map_id='external_map')
  dc.external_sharpen(local_sharpen=True,n_boxes=1,
     n_bins=15,map_id_external_map='external_map')
  cc_after = dc.map_map_cc(map_id='map_manager_scaled',other_map_id='external_map')
  print("CC before, after external sharpen local n_boxes=1: ",cc_before,cc_after)
  assert approx_equal ((cc_before,cc_after), (0.70,0.95),eps=0.10)


  dc = local_mmm.deep_copy()
  dc.set_log(sys.stdout)
  dc._local_sharpen(map_id_scaled_list=['map_manager_scaled'], map_id_to_be_scaled_list=['map_manager'],
     n_bins=15, n_boxes=1)
  cc = dc.map_model_cc()
  assert approx_equal (cc, 0.80, eps=0.1)

  # create a mask around density
  dc.create_mask_around_density(soft_mask=False)
  count = dc.get_map_manager_by_id('mask').map_data().count(1)
  print(count)
  assert 8000 < count < 14000
  dc.expand_mask(buffer_radius = 2)
  count = dc.get_map_manager_by_id('mask').map_data().count(1)
  print(count)
  assert count == 1

  # Test mask and map info functions
  mmm1, mmm2 = get_map_model_managers()
  mmm1.create_mask_around_density(soft_mask=False)
  mask_info = mmm1.mask_info(quiet=True)
  map_info = mmm1.map_info()
  mask_info_by_id = mmm1.mask_info(mask_id = 'mask',quiet=True)
  map_info_by_id = mmm1.map_info(map_id = 'map_manager')
  assert mask_info() == mask_info_by_id()
  assert map_info() == map_info_by_id()
  assert approx_equal(mask_info.fraction_marked, 0.207070707071, eps=0.01)

  assert approx_equal(map_info.fraction_above_sigma_cutoff, 0.0577876984127)

  # create a spherical mask around a point
  print("Spherical masks", )
  dc = mmm1.deep_copy()
  dc.mask_info(quiet=True)
  print (dc.mask_info(quiet=True).marked_points )
  assert dc.mask_info(quiet=True).marked_points in  [9184, 9318, 8862]
  dc.create_spherical_mask()
  dc.mask_info(quiet=True)
  print (dc.mask_info(quiet=True).marked_points)
  assert dc.mask_info(quiet=True).marked_points in [1311, 1286, 1354]
  dc.create_spherical_mask(soft_mask_radius=1)
  dc.mask_info(quiet=True)
  print (dc.mask_info(quiet=True).marked_points)
  assert dc.mask_info(quiet=True).marked_points in [8990,]
  dc.create_spherical_mask(soft_mask=False)
  dc.mask_info(quiet=True)
  print (dc.mask_info(quiet=True).marked_points)
  assert dc.mask_info(quiet=True).marked_points in [1566, 1458, 1812]
  dc.create_spherical_mask(mask_radius = 4)
  dc.mask_info(quiet=True)
  print (dc.mask_info(quiet=True).marked_points)
  assert dc.mask_info(quiet=True).marked_points in [886, 914, 820]
  dc.create_spherical_mask(soft_mask=False, mask_radius = 4)
  dc.mask_info(quiet=True)
  print (dc.mask_info(quiet=True).marked_points)
  assert dc.mask_info(quiet=True).marked_points == 654



if __name__ == "__main__":
  try:
    from phenix.command_line import superpose_pdbs  # special import
    exercise()
  except ImportError:
    print('Skipping tst_map_model_manager_4 tests becuase Phenix is not available.')
  print ("OK")


 *******************************************************************************


 *******************************************************************************
iotbx/regression/tst_map_model_manager_9_remove_origin_shift_and_unit_cell_crystal_symmetry.py
from __future__ import absolute_import, division, print_function
from iotbx.data_manager import DataManager
import os


def exercise():
  data_dir = os.path.dirname(os.path.abspath(__file__))
  data_ccp4 = os.path.join(data_dir, 'data',
                          'non_zero_origin_map.ccp4')
  data_model = os.path.join(data_dir, 'data',
                          'non_zero_origin_model.pdb')

  dm = DataManager()
  mmm = dm.get_map_model_manager(
    model_file = data_model,
    map_files  = data_ccp4)

  box_mmm = mmm.extract_all_maps_around_model()

  box_cs = box_mmm.crystal_symmetry()

  assert not box_mmm.crystal_symmetry().is_similar_symmetry(
     mmm.crystal_symmetry())
  assert box_mmm.unit_cell_crystal_symmetry().is_similar_symmetry(
     mmm.unit_cell_crystal_symmetry())

  box_mmm.remove_origin_shift_and_unit_cell_crystal_symmetry()
  assert box_mmm.crystal_symmetry().is_similar_symmetry(box_cs)
  assert box_mmm.unit_cell_crystal_symmetry().is_similar_symmetry(box_cs)
  assert not box_mmm.unit_cell_crystal_symmetry().is_similar_symmetry(
     mmm.crystal_symmetry())
  file_name = box_mmm.write_model("model.cif", format ='cif')
  box_mmm.write_map("map.ccp4")

  new_mmm = dm.get_map_model_manager(
    model_file = file_name,
    map_files  = "map.ccp4")

  assert new_mmm.crystal_symmetry().is_similar_symmetry(box_cs)
  assert new_mmm.unit_cell_crystal_symmetry().is_similar_symmetry(box_cs)

if (__name__ == "__main__"):
  import time
  t0 = time.time()
  exercise()
  print("Time: %6.4f"%(time.time()-t0))
  print("OK")


 *******************************************************************************


 *******************************************************************************
iotbx/regression/tst_map_model_manager_9_remove_origin_shift_and_unit_cell_crystal_symmetry_cif.py
from __future__ import absolute_import, division, print_function
from iotbx.data_manager import DataManager
import os

def exercise():
  data_dir = os.path.dirname(os.path.abspath(__file__))
  data_ccp4 = os.path.join(data_dir, 'data',
                          'non_zero_origin_map.ccp4')
  data_model = os.path.join(data_dir, 'data',
                          'non_zero_origin_model.cif')
  #
  dm = DataManager()
  mmm = dm.get_map_model_manager(
    model_file = data_model,
    map_files  = data_ccp4)

  box_mmm = mmm.extract_all_maps_around_model()

  box_cs = box_mmm.crystal_symmetry()

  assert not box_mmm.crystal_symmetry().is_similar_symmetry(
     mmm.crystal_symmetry())
  assert box_mmm.unit_cell_crystal_symmetry().is_similar_symmetry(
     mmm.unit_cell_crystal_symmetry())

  box_mmm.remove_origin_shift_and_unit_cell_crystal_symmetry()
  assert box_mmm.crystal_symmetry().is_similar_symmetry(box_cs)
  assert box_mmm.unit_cell_crystal_symmetry().is_similar_symmetry(box_cs)
  assert not box_mmm.unit_cell_crystal_symmetry().is_similar_symmetry(
     mmm.crystal_symmetry())
  file_name = box_mmm.write_model("model.cif", format ='cif')
  box_mmm.write_map("map.ccp4")

  new_mmm = dm.get_map_model_manager(
    model_file = file_name,
    map_files  = "map.ccp4")

  assert new_mmm.crystal_symmetry().is_similar_symmetry(box_cs)
  assert new_mmm.unit_cell_crystal_symmetry().is_similar_symmetry(box_cs)

if (__name__ == "__main__"):
  import time
  t0 = time.time()
  exercise()
  print("Time: %6.4f"%(time.time()-t0))
  print("OK")


 *******************************************************************************


 *******************************************************************************
iotbx/regression/tst_map_model_manager_call_consistency.py
from __future__ import absolute_import, division, print_function
from iotbx.map_manager import map_manager
from iotbx.map_model_manager import map_model_manager
from cctbx.maptbx import box
from cctbx.maptbx.mask import create_mask_around_edges, \
      create_mask_around_atoms, create_mask_around_density
import cctbx
from libtbx.introspection import getfullargspec

def get_method_text(key, base_method_name):
  if key == 'init':
    return "box.%s.__init__" %(base_method_name)
  elif key == 'box_all_maps':
    return "box_all_maps_%s_and_shift_origin" %(base_method_name)
  elif key == 'extract_all_maps':
    return "extract_all_maps_%s" %(base_method_name)
  if key == 'init_mask':
    return "cctbx.maptbx.mask.create_mask_%s.__init__" %(base_method_name)
  if key == 'create_mask':
    return "map_model_manager.create_mask_%s" %(base_method_name)
  else:
    raise AssertionError("unknown key for get_method_text")

def get_method(key, base_method_name):
  if key == 'init':
    return getattr(getattr(box,base_method_name),"__init__")
  elif key == 'box_all_maps':
    method_name = "box_all_maps_%s_and_shift_origin" %(base_method_name)
    return  getattr(map_model_manager, method_name)
  elif key == 'extract_all_maps':
    method_name = "extract_all_maps_%s" %(base_method_name)
    return  getattr(map_model_manager, method_name)
  if key == 'init_mask':
    if base_method_name == 'around_edges':
      return create_mask_around_edges.__init__
    elif base_method_name == 'around_atoms':
      return create_mask_around_atoms.__init__
    elif base_method_name == 'around_density':
      return create_mask_around_density.__init__
  elif key == 'create_mask':
    method_name = "create_mask_%s" %(base_method_name)
    return  getattr(map_model_manager, method_name)
  else:
    raise AssertionError("unknown key for get_method")

def all_expected_in_found(found = None, expected = None):
  for x in expected:
    if not x in found:
      print("Expected to find",x," but did not")
      return False
  return True

def check_args(text, method,expected_args,group_text,
       allow_extra_in_found=None):
    found_args = getfullargspec(method).args
    expected_args = sorted(expected_args)
    found_args = sorted(found_args)
    print ("\n%s :\nExpected :%s \nFound   : %s" %(
       text,str(expected_args),str(found_args)))
    if expected_args == found_args:
      return
    elif allow_extra_in_found and all_expected_in_found(
      found = found_args, expected = expected_args):
      return
    else:  # give message
      error_message="""

FAIL : Args for %s do not match expected.
Expected :%s
Found    :%s

 If you change args for
    %s
Make sure that all of these are changed to match and also change expected
to match in iotbx/regression/tst_map_model_manager_call_consistency.py
""" %(
        text,str(expected_args),str(found_args),group_text)
      raise AssertionError (error_message)

def test_01():

  #  Making sure that all the convenience calls to each basic method for boxing
  #  have the same parameters as the basic method
  #  Base calls are in cctbx.maptbx.box and cctbx.maptbx.mask.
  #  Matching calls are in map_manager, map_model_manager

  # Args that should appear in all calls to all methods
  common_args = ['self',]

  # Args that should be in common for all calls to specific methods
  method_args_dict = {
    'with_bounds': ['lower_bounds', 'upper_bounds',
    'model_can_be_outside_bounds',
    'stay_inside_current_map', 'use_cubic_boxing','require_match_unit_cell_crystal_symmetry'],
    'around_model':[ 'box_cushion','model_can_be_outside_bounds',
      'stay_inside_current_map', 'use_cubic_boxing',
      'require_match_unit_cell_crystal_symmetry'],
    'around_density':[ 'box_cushion','threshold', 'get_half_height_width',
       'stay_inside_current_map', 'use_cubic_boxing',
       'model_can_be_outside_bounds',
      'require_match_unit_cell_crystal_symmetry',],
    'around_mask':[ 'box_cushion','model_can_be_outside_bounds',
      'stay_inside_current_map', 'use_cubic_boxing',
      'require_match_unit_cell_crystal_symmetry'],
    'around_unique':['box_cushion', 'target_ncs_au_model',
        'stay_inside_current_map', 'use_cubic_boxing',
        'use_symmetry_in_extract_unique', 'regions_to_keep',
         'require_match_unit_cell_crystal_symmetry',
    'residues_per_region','keep_this_region_only',
        'solvent_content', 'resolution', 'sequence', 'molecular_mass',
         'symmetry', 'chain_type', 'keep_low_density', 'soft_mask',
         'mask_expand_ratio'],
   }

  # Args that should appear in map_manager and map_model_manager calls for
  #   specific methods
  manager_method_args_dict = {
    'with_bounds': [],
    'around_model':['selection', 'selection_string', 'select_unique_by_ncs'],
    'around_density':['map_id'],
    'around_mask':['mask_id'],
    'around_unique':[],
   }

  # Args that should appear in init calls for
  #   specific methods
  init_method_args_dict = {
    'with_bounds': [],
    'around_model':[],
    'around_density':[],
    'around_mask':['mask_as_map_manager'],
    'around_unique':[],
   }

  # Args that should appear in calls that are __init__
  init_args = ['map_manager', 'model', 'wrapping', 'log']

  # Args that should appear in calls that are "extract_xxx"
  extract_args = []

  # Args that should appear in calls that are "box_all_maps_xxx"
  box_all_maps_args = ['extract_box']

  base_method_name_list = method_args_dict.keys()
  assert method_args_dict.keys() == manager_method_args_dict.keys()


  for base_method_name in base_method_name_list:
    print ("\nExpected and actual args in calls for %s" %(base_method_name))
    group_text ="""
    cctbx.mmtbx.box.%s
    iotbx.map_model_manager.extract_all_maps_%s
    iotbx.map_model_manager.box_all_maps_%s_and_shift_origin""" %(
      base_method_name,base_method_name,base_method_name)

    # Check call in cctbx.maptbx.box.xxx.__init__
    method = get_method('init',base_method_name)
    text = get_method_text('init',base_method_name)
    expected_args = common_args + method_args_dict[base_method_name] + \
      init_method_args_dict[base_method_name] + init_args
    check_args(text,method,expected_args,group_text)


    # Check call in iotbx.map_model_manager box_all_maps_xxx_and_shift_origin
    method = get_method('box_all_maps',base_method_name)
    text = get_method_text('box_all_maps',base_method_name)

    expected_args = common_args + method_args_dict[base_method_name] + \
       manager_method_args_dict[base_method_name] + box_all_maps_args
    check_args(text,method,expected_args,group_text,
       allow_extra_in_found = True)

    # Check call in iotbx.map_model_manager extract_all_maps_xxx
    method = get_method('extract_all_maps',base_method_name)
    text = get_method_text('extract_all_maps',base_method_name)

    expected_args = common_args + method_args_dict[base_method_name] + \
       manager_method_args_dict[base_method_name] + extract_args
    check_args(text,method,expected_args,group_text,
       allow_extra_in_found = True)

def test_02():
  # Make sure calls in map_model_manager to
  # create_mask_around_edges
  # create_mask_around_atoms
  # create_mask_around_density
  #  have args matching the main methods in cctbx.maptbx.mask

  # Just put what is expected here and ask programmer to change in both
  #  places if they change one

  init_arg_dict = {
     'around_atoms':['self', 'mask_atoms_atom_radius', 'model',
          'invert_mask','xray_structure', 'map_manager','n_real', 'wrapping'],
     'around_edges':['self', 'boundary_radius', 'map_manager'],
     'around_density':['self', 'map_manager','resolution','molecular_mass',
        'sequence','solvent_content'],
  }
  method_arg_dict = {
     'around_atoms':['self', 'soft_mask_radius', 'mask_atoms_atom_radius',
          'invert_mask','soft_mask', 'mask_id', 'model'],
     'around_edges':['self', 'boundary_radius', 'mask_id',],
     'around_density':['self', 'resolution', 'solvent_content', 'soft_mask',
           'soft_mask_radius', 'mask_id','map_id'],
  }
  assert init_arg_dict.keys() == method_arg_dict.keys()

  #  Check them out...
  for base_method_name in init_arg_dict.keys():
    print ("\nExpected and actual args in calls for %s" %(base_method_name))
    group_text ="""
      cctbx.mmtbx.mask.create_mask_around_%s
      iotbx.map_model_manager.create_mask_around_%s""" %(
        base_method_name,base_method_name)

    method = get_method('init_mask',base_method_name)
    text = get_method_text('init_mask',base_method_name)
    expected_args = init_arg_dict[base_method_name]
    check_args(text,method,expected_args,group_text)

    method = get_method('create_mask',base_method_name)
    text = get_method_text('create_mask',base_method_name)
    expected_args = method_arg_dict[base_method_name]
    check_args(text,method,expected_args,group_text,allow_extra_in_found=True)


if (__name__  ==  '__main__'):
  test_01()
  test_02()
  print ("OK")


 *******************************************************************************


 *******************************************************************************
iotbx/regression/tst_map_model_manager_cif.py
from __future__ import absolute_import, division, print_function
import os
import libtbx.load_env
from iotbx.data_manager import DataManager
from iotbx.map_model_manager import _match_map_model_ncs, map_model_manager
from iotbx.phil import parse
from libtbx.program_template import ProgramTemplate
from libtbx.test_utils import approx_equal
from libtbx.utils import Sorry
from libtbx.test_utils import show_diff

def test_01():

  # Source data

  data_dir = os.path.dirname(os.path.abspath(__file__))
  data_ccp4 = os.path.join(data_dir, 'data',
                          'non_zero_origin_map.ccp4')
  data_pdb = os.path.join(data_dir, 'data',
                          'non_zero_origin_model.cif')
  data_ncs_spec = os.path.join(data_dir, 'data',
                          'non_zero_origin_ncs_spec.ncs_spec')

  # DataManager

  dm = DataManager(['ncs_spec','model', 'real_map', 'phil'])
  dm.set_overwrite(True)

  # Read in map and model and ncs

  map_file=data_ccp4
  dm.process_real_map_file(map_file)
  mm = dm.get_real_map(map_file)

  model_file=data_pdb
  dm.process_model_file(model_file)
  model = dm.get_model(model_file)

  ncs_file=data_ncs_spec
  dm.process_ncs_spec_file(ncs_file)
  ncs = dm.get_ncs_spec(ncs_file)

  ncs_dc = ncs.deep_copy()

  mmmn = _match_map_model_ncs()
  mmmn.add_map_manager(mm)
  mmmn.add_model(model)
  mmmn.add_ncs_object(ncs)

  # Save it
  mmmn_dc=mmmn.deep_copy()

  # Test creating mmm from model:
  mmm_from_model = model.as_map_model_manager(create_model_map = False)
  mmm_from_model = model.as_map_model_manager(create_model_map = True,
    resolution = 5)
  assert mmm_from_model.map_manager() is not None

  # Make sure we can add an ncs object that is either shifted or not
  mmmn_dcdc=mmmn.deep_copy()
  new_mmmn = _match_map_model_ncs()
  new_mmmn.add_map_manager(mmmn_dcdc.map_manager())
  new_mmmn.add_model(mmmn_dcdc.model())
  new_mmmn.add_ncs_object(mmmn_dcdc.ncs_object())
  assert new_mmmn.ncs_object().shift_cart() == new_mmmn.map_manager().shift_cart()

  mmmn_dcdc=mmmn.deep_copy()
  new_mmmn = _match_map_model_ncs()
  new_mmmn.add_map_manager(mmmn_dcdc.map_manager())
  new_mmmn.add_model(mmmn_dcdc.model())
  new_mmmn.add_ncs_object(ncs_dc)
  assert new_mmmn.ncs_object().shift_cart() == new_mmmn.map_manager().shift_cart()


  original_ncs=mmmn.ncs_object()
  assert approx_equal((24.0528, 11.5833, 20.0004),
     tuple(original_ncs.ncs_groups()[0].translations_orth()[-1]),
     eps=0.1)

  assert tuple(mmmn._map_manager.origin_shift_grid_units) == (0,0,0)

  # Shift origin to (0,0,0)
  mmmn=mmmn_dc.deep_copy()  # fresh version of _match_map_model_ncs
  mmmn.shift_origin()
  new_ncs=mmmn.ncs_object()
  assert tuple(mmmn._map_manager.origin_shift_grid_units) == (100,100,100)

  mmmn.write_model('s.pdb')
  mmmn.write_map('s.mrc')

  shifted_ncs=mmmn.ncs_object()
  assert approx_equal((-153.758, -74.044, -127.487),
      tuple(shifted_ncs.ncs_groups()[0].translations_orth()[-1]),eps=0.1)


  # Shift a model and shift it back

  mmmn=mmmn_dc.deep_copy()  # fresh version of _match_map_model_ncs
  model=mmmn.model()
  shifted_model=mmmn.shift_model_to_match_working_map(model=model)
  model_in_original_position=mmmn.shift_model_to_match_original_map(
      model=shifted_model)
  assert (approx_equal(model.get_sites_cart(), # not a copy
                      shifted_model.get_sites_cart()))
  assert approx_equal(model.get_sites_cart(),
                      model_in_original_position.get_sites_cart())

  # test data_manager map_model_manager
  generated_mmm = dm.get_map_model_manager()
  print(generated_mmm)
  assert(isinstance(generated_mmm,map_model_manager))


  # Generate a map and model

  import sys
  mmm=map_model_manager(log=sys.stdout)
  mmm.generate_map()
  model=mmm.model()
  mm=mmm.map_manager()
  assert approx_equal(
     model.get_sites_cart()[0], (14.476, 10.57, 8.34) ,eps=0.01)
  assert approx_equal(mm.map_data()[10,10,10],-0.0506,eps=0.001)
  # Save it
  mmm_dc=mmm.deep_copy()

  # Create model from sites
  mmm_sites = mmm_dc.deep_copy()
  from scitbx.array_family import flex
  sites_cart = flex.vec3_double()
  sites_cart.append((3,4,5))
  mmm_sites.model_from_sites_cart(sites_cart = sites_cart,
    model_id = 'new_model')
  assert mmm_sites.get_model_by_id('new_model').get_sites_cart()[0] == (3,4,5)
  ph_sites = mmm_sites.get_model_by_id('new_model').get_hierarchy()
  text_sites = mmm_sites.get_model_by_id('new_model').model_as_pdb()

  # Create model from hierarchy
  mmm_sites = mmm_dc.deep_copy()
  mmm_sites.model_from_hierarchy(hierarchy = ph_sites,
    model_id = 'new_model')
  assert mmm_sites.get_model_by_id('new_model').get_sites_cart()[0] == (3,4,5)

  # Create model from text
  mmm_sites = mmm_dc.deep_copy()
  mmm_sites.model_from_text(text = text_sites,
    model_id = 'new_model')
  assert mmm_sites.get_model_by_id('new_model').get_sites_cart()[0] == (3,4,5)



  # Set crystal_symmetry and unit_cell_crystal_symmetry and shift_cart
  # Box and shift the map_model_manager so we have new coordinate system
  mmm_sites.box_all_maps_around_model_and_shift_origin(box_cushion=4.5)
  new_model = mmm_sites.get_model_by_id('new_model')
  assert approx_equal((3., 4., 5.0),
     mmm_sites.get_model_by_id('new_model').get_sites_cart()[0])

  # arbitrarily set unit_cell crystal symmetry of model to
  #  match crystal_symmetry. First have to set shift_cart to None
  new_model.set_shift_cart(shift_cart = None)
  new_model.set_unit_cell_crystal_symmetry_and_shift_cart()
  assert new_model.crystal_symmetry() != mmm_sites.crystal_symmetry()

  # now set crystal symmetries and shift cart of model to match the manager
  mmm_sites.set_model_symmetries_and_shift_cart_to_match_map(new_model)
  assert new_model.crystal_symmetry().is_similar_symmetry(
    mmm_sites.crystal_symmetry())
  assert new_model.unit_cell_crystal_symmetry().is_similar_symmetry(
    mmm_sites.unit_cell_crystal_symmetry())
  assert new_model.shift_cart() == mmm_sites.shift_cart()

  # Import hierarchy into a model and set symmetries and shift to match
  mmm_sites.model_from_hierarchy(
   hierarchy = mmm_sites.model().get_hierarchy(),
   model_id='model_from_hierarchy')
  assert not show_diff(mmm_sites.get_model_by_id('model_from_hierarchy').model_as_pdb(),
     mmm_sites.get_model_by_id('model').model_as_pdb())


  # Check on wrapping
  assert not mm.wrapping()  # this one should not wrap because it is zero at edges

  # Make a new one with no buffer so it is not zero at edges
  mmm=map_model_manager()
  mmm.generate_map(box_cushion=0)
  mm=mmm.map_manager()
  # check its compatibility with wrapping
  assert mm.is_consistent_with_wrapping()
  mmm.show_summary()

  # now box it
  sel=mmm.model().selection("resseq 221:221")
  new_model=mmm.model().deep_copy().select(sel)
  new_mmm=map_model_manager(model=new_model,map_manager=mm.deep_copy())
  new_mmm.box_all_maps_around_model_and_shift_origin()
  new_mm=new_mmm.map_manager()

  assert not new_mm.wrapping()
  assert not new_mm.is_consistent_with_wrapping()

  # now box it with selection
  new_mmm_1=map_model_manager(
      model=mmm.model().deep_copy(),map_manager=mm.deep_copy())
  new_mmm_1.box_all_maps_around_model_and_shift_origin(
      selection_string="resseq 221:221")
  new_mm_1=new_mmm_1.map_manager()

  assert not new_mm_1.wrapping()
  assert not new_mm_1.is_consistent_with_wrapping()
  assert new_mm_1.map_data().all()== new_mm.map_data().all()

  # create map_model_manager with just half-maps
  mm1=mm.deep_copy()
  mm2=mm.deep_copy()
  map_data=mm2.map_data()
  map_data+=1.
  new_mmm=map_model_manager(model=mmm.model().deep_copy(),
    map_manager_1=mm1,
    map_manager_2=mm2)
  assert new_mmm._map_dict.get('map_manager') is None # should not be any yet
  assert approx_equal(new_mmm.map_manager().map_data()[232],
     mm.deep_copy().map_data()[232]+0.5)
  assert new_mmm._map_dict.get('map_manager') is not None # now should be there

  # generate map data from a model
  mm1=mm.deep_copy()
  mm2=mm.deep_copy()
  new_mmm=map_model_manager(model=mmm.model().deep_copy(), map_manager=mm1)
  mmm.generate_map(model=mmm.model())
  mm=mmm.map_manager()
  mmm.show_summary()

  # check get_map_model_manager function
  dm = DataManager(['model'])
  assert not hasattr(dm, 'get_map_model_manager')
  dm = DataManager(['real_map'])
  assert not hasattr(dm, 'get_map_model_manager')
  dm = DataManager(['sequence'])
  assert not hasattr(dm, 'get_map_model_manager')
  dm = DataManager(['model', 'real_map'])
  assert hasattr(dm, 'get_map_model_manager')

  # usage
  dm.get_map_model_manager(model_file=data_pdb, map_files=data_ccp4)
  dm.get_map_model_manager(model_file=data_pdb, map_files=[data_ccp4])
  dm.get_map_model_manager(model_file=data_pdb, map_files=[data_ccp4, data_ccp4, data_ccp4])
  dm.get_map_model_manager(model_file=data_pdb, map_files=data_ccp4, ignore_symmetry_conflicts=True)

  # errors
  try:
    dm.get_map_model_manager(model_file=data_pdb, map_files=data_ccp4, from_phil=True)
  except Sorry as e:
    assert 'from_phil is set to True' in str(e)
  try:
    dm.get_map_model_manager(model_file=data_pdb, map_files=data_ccp4, abc=123)
  except TypeError as e:
    assert 'unexpected keyword argument' in str(e)
  try:
    dm.get_map_model_manager(model_file=data_pdb, map_files=[data_ccp4, data_ccp4])
  except Sorry as e:
    assert '1 full map and 2 half maps' in str(e)

  # PHIL
  class test_program(ProgramTemplate):
    master_phil_str = '''
include scope iotbx.map_model_manager.map_model_phil_str
'''
  working_phil_str = '''
  map_model {
    full_map = %s
    half_map = %s
    half_map = s.mrc
    model = %s
  }
''' % (data_ccp4, data_ccp4, data_pdb)

  master_phil = parse(test_program.master_phil_str, process_includes=True)
  working_phil = master_phil.fetch(parse(working_phil_str))
  tp = test_program(dm, working_phil.extract())

  try:
    dm.get_map_model_manager(from_phil=True)
  except Exception as e:
    assert 'ignore_symmetry_conflicts' in str(e)
  try:
    dm.get_map_model_manager(from_phil=True, ignore_symmetry_conflicts=True)
  except AssertionError:
    pass

# ----------------------------------------------------------------------------

if (__name__ == '__main__'):
  if libtbx.env.find_in_repositories(relative_path='chem_data') is not None:
    test_01()
  else:
    print('Skip test_01, chem_data not available')
  print ("OK")


 *******************************************************************************


 *******************************************************************************
iotbx/regression/tst_map_model_manager_external_sharpening_7.py
from __future__ import absolute_import, division, print_function
import libtbx.load_env
from iotbx.regression.tst_map_model_manager_model_sharpening_5 import test_01
# ----------------------------------------------------------------------------

if (__name__ == '__main__'):
  if libtbx.env.find_in_repositories(relative_path='chem_data') is not None:
    test_01(method = 'half_map_sharpen')
  else:
    print('Skip test_01, chem_data not available')
  print ("OK")



 *******************************************************************************


 *******************************************************************************
iotbx/regression/tst_map_model_manager_half_map_sharpening_6.py
from __future__ import absolute_import, division, print_function
import libtbx.load_env
from iotbx.regression.tst_map_model_manager_model_sharpening_5 import test_01
# ----------------------------------------------------------------------------

if (__name__ == '__main__'):
  if libtbx.env.find_in_repositories(relative_path='chem_data') is not None:
    test_01(method = 'model_sharpen')
  else:
    print('Skip test_01, chem_data not available')
  print ("OK")



 *******************************************************************************


 *******************************************************************************
iotbx/regression/tst_map_model_manager_local_resolution_10.py
from __future__ import absolute_import, division, print_function
import libtbx.load_env
from iotbx.regression.tst_map_model_manager_model_sharpening_5 import test_01
# ----------------------------------------------------------------------------

if (__name__ == '__main__'):
  if libtbx.env.find_in_repositories(relative_path='chem_data') is not None:
    test_01(method = 'local_resolution_map')
  else:
    print('Skip test_01, chem_data not available')
  print ("OK")



 *******************************************************************************


 *******************************************************************************
iotbx/regression/tst_map_model_manager_model_sharpening_5.py
from __future__ import absolute_import, division, print_function
import os, sys
import libtbx.load_env
from iotbx.data_manager import DataManager
from iotbx.map_model_manager import map_model_manager

def test_01(method = 'model_sharpen',
   expected_results=None):

  # Source data

  data_dir = os.path.dirname(os.path.abspath(__file__))
  data_ccp4 = os.path.join(data_dir, 'data',
                          'non_zero_origin_map.ccp4')
  data_pdb = os.path.join(data_dir, 'data',
                          'non_zero_origin_model.pdb')
  data_ncs_spec = os.path.join(data_dir, 'data',
                          'non_zero_origin_ncs_spec.ncs_spec')

  # Read in data

  dm = DataManager(['ncs_spec','model', 'real_map', 'phil'])
  dm.set_overwrite(True)

  map_file=data_ccp4
  dm.process_real_map_file(map_file)
  mm = dm.get_real_map(map_file)

  model_file=data_pdb
  dm.process_model_file(model_file)
  model = dm.get_model(model_file)

  ncs_file=data_ncs_spec
  dm.process_ncs_spec_file(ncs_file)
  ncs = dm.get_ncs_spec(ncs_file)

  mmm=map_model_manager(
    model = model,
    map_manager_1 = mm.deep_copy(),
    map_manager_2 = mm.deep_copy(),
    ncs_object = ncs,
    wrapping = False)
  mmm.add_map_manager_by_id(
     map_id='external_map',map_manager=mmm.map_manager().deep_copy())
  if method == 'local_resolution_map':
    mmm.generate_map(map_id = 'map_manager_2')
    dd = mmm.resolution()
  else:
    mmm.set_resolution(3)
  mmm.set_log(sys.stdout)

  dc = mmm.deep_copy()

  sharpen_method = getattr(mmm,method)

  # sharpen by method (can be model_sharpen, half_map_sharpen or
  #     external_sharpen and also local_resolution_map)

  if method == 'local_resolution_map':
    mm = sharpen_method()
    x = mm.map_data().as_1d().min_max_mean()
    from libtbx.test_utils import approx_equal
    assert approx_equal((x.min,x.max,x.mean),
      (1.9835316316768663, 2.3146054110530336, 2.1600110833032353),
       eps = 0.01)

  else: # usual
    sharpen_method(anisotropic_sharpen = False, n_bins=10)
    assert mmm.map_model_cc() > 0.9
    sharpen_method(anisotropic_sharpen = False, n_bins=10,
       local_sharpen = True)
    assert mmm.map_model_cc() > 0.9
    sharpen_method(anisotropic_sharpen = True, n_bins=10)
    assert mmm.map_model_cc() > 0.9
    sharpen_method(anisotropic_sharpen = True, n_bins=10,
       local_sharpen = True, n_boxes = 1)
    assert mmm.map_model_cc() > 0.9


# ----------------------------------------------------------------------------

if (__name__ == '__main__'):
  if libtbx.env.find_in_repositories(relative_path='chem_data') is not None:
    test_01(method = 'model_sharpen')
  else:
    print('Skip test_01, chem_data not available')
  print ("OK")



 *******************************************************************************


 *******************************************************************************
iotbx/regression/tst_map_model_manager_model_sharpening_5_cif.py
from __future__ import absolute_import, division, print_function
import os, sys
import libtbx.load_env
from iotbx.data_manager import DataManager
from iotbx.map_model_manager import map_model_manager

def test_01(method = 'model_sharpen',
   expected_results=None):

  # Source data

  data_dir = os.path.dirname(os.path.abspath(__file__))
  data_ccp4 = os.path.join(data_dir, 'data',
                          'non_zero_origin_map.ccp4')
  data_pdb = os.path.join(data_dir, 'data',
                          'non_zero_origin_model.cif')
  data_ncs_spec = os.path.join(data_dir, 'data',
                          'non_zero_origin_ncs_spec.ncs_spec')

  # Read in data

  dm = DataManager(['ncs_spec','model', 'real_map', 'phil'])
  dm.set_overwrite(True)

  map_file=data_ccp4
  dm.process_real_map_file(map_file)
  mm = dm.get_real_map(map_file)

  model_file=data_pdb
  dm.process_model_file(model_file)
  model = dm.get_model(model_file)

  ncs_file=data_ncs_spec
  dm.process_ncs_spec_file(ncs_file)
  ncs = dm.get_ncs_spec(ncs_file)

  mmm=map_model_manager(
    model = model,
    map_manager_1 = mm.deep_copy(),
    map_manager_2 = mm.deep_copy(),
    ncs_object = ncs,
    wrapping = False)
  mmm.add_map_manager_by_id(
     map_id='external_map',map_manager=mmm.map_manager().deep_copy())
  mmm.set_resolution(3)
  mmm.set_log(sys.stdout)

  dc = mmm.deep_copy()

  sharpen_method = getattr(mmm,method)

  # sharpen by method (can be model_sharpen, half_map_sharpen or
  #     external_sharpen)

  sharpen_method(anisotropic_sharpen = False, n_bins=10)
  assert mmm.map_model_cc() > 0.9
  sharpen_method(anisotropic_sharpen = False, n_bins=10,
     local_sharpen = True)
  assert mmm.map_model_cc() > 0.9
  sharpen_method(anisotropic_sharpen = True, n_bins=10)
  assert mmm.map_model_cc() > 0.9
  sharpen_method(anisotropic_sharpen = True, n_bins=10,
     local_sharpen = True, n_boxes = 1)
  assert mmm.map_model_cc() > 0.9


# ----------------------------------------------------------------------------

if (__name__ == '__main__'):
  if libtbx.env.find_in_repositories(relative_path='chem_data') is not None:
    test_01(method = 'model_sharpen')
  else:
    print('Skip test_01, chem_data not available')
  print ("OK")



 *******************************************************************************


 *******************************************************************************
iotbx/regression/tst_map_model_manager_tls_from_map_8.py
from __future__ import absolute_import, division, print_function
import os, sys
import libtbx.load_env
from iotbx.data_manager import DataManager
from iotbx.map_model_manager import map_model_manager
from libtbx.test_utils import approx_equal

def test_01():

  # Source data

  data_dir = os.path.dirname(os.path.abspath(__file__))
  data_ccp4 = os.path.join(data_dir, 'data',
                          'non_zero_origin_map.ccp4')
  data_pdb = os.path.join(data_dir, 'data',
                          'non_zero_origin_model.pdb')
  data_ncs_spec = os.path.join(data_dir, 'data',
                          'non_zero_origin_ncs_spec.ncs_spec')

  # Read in data

  dm = DataManager(['ncs_spec','model', 'real_map', 'phil'])
  dm.set_overwrite(True)

  map_file=data_ccp4
  dm.process_real_map_file(map_file)
  mm = dm.get_real_map(map_file)

  model_file=data_pdb
  dm.process_model_file(model_file)
  model = dm.get_model(model_file)

  ncs_file=data_ncs_spec
  dm.process_ncs_spec_file(ncs_file)
  ncs = dm.get_ncs_spec(ncs_file)

  mmm=map_model_manager(
    model = model,
    map_manager_1 = mm.deep_copy(),
    map_manager_2 = mm.deep_copy(),
    ncs_object = ncs,
    wrapping = False)
  mmm.add_map_manager_by_id(
     map_id='external_map',map_manager=mmm.map_manager().deep_copy())
  mmm.set_resolution(3)
  mmm.set_log(sys.stdout)

  dc = mmm.deep_copy()


  # Model sharpening
  mmm = dc.deep_copy()
  tls_info=mmm.tls_from_map(n_bins=10,
    model_id = 'model',
    map_id = 'map_manager',
    iterations = 1,
   )
  tlso = tls_info.tlso_list[0]
  print ("t:", tlso.t)
  print ("l:", tlso.l)
  print ("s:", tlso.s)
  print ("origin:", tlso.origin)

  assert approx_equal(tlso.t,
(1.180418902258779, 1.1747521845606608, 1.178996799712174, -0.08474662674769494, -0.022609295693646402, 0.0649209491344932)
 ,eps=.001)
  assert approx_equal(tlso.l,
(-0.002159404807991249, -0.002107964765763024, 0.0008301439376854558, -5.973347993775719e-05, -0.000134276871934738, -9.05515898670584e-05)
 ,eps=.001)
  assert approx_equal(tlso.s,
(2.9348223335616302e-08, 5.52441087256425e-09, -5.382459681103171e-09, 4.3530347434547015e-09, -2.3559464233595e-08, 4.217968590464982e-09, -4.380707049750269e-09, 1.9232725033868253e-09, -5.788759082799497e-09)
 ,eps=.001)
  assert approx_equal(tlso.origin,
(-64.70331931297399, -62.30573551948903, -63.743687240164604)
 ,eps=.001)


  print("TLS: ",tlso.t,tlso.l,tlso.s,tlso.origin)


# ----------------------------------------------------------------------------

if (__name__ == '__main__'):
  if libtbx.env.find_in_repositories(relative_path='chem_data') is not None:
    test_01()
  else:
    print('Skip test_01, chem_data not available')
  print ("OK")



 *******************************************************************************


 *******************************************************************************
iotbx/regression/tst_map_tools.py

from __future__ import absolute_import, division, print_function
from iotbx import file_reader
from iotbx import map_tools
import iotbx.pdb.hierarchy
from iotbx import mtz
from scitbx.array_family import flex
import os

def exercise_map_tools():
  prefix = "tmp_iotbx_map_tools"
  pdb_file = prefix + ".pdb"
  mtz_file = prefix + ".mtz"
  pdb_in = iotbx.pdb.input(source_info=None, lines="""\
ATOM      1  N   GLY P  -1     -22.866  -2.627  15.217  1.00  0.00           N
ATOM      2  CA  GLY P  -1     -22.714  -3.068  16.621  1.00  0.00           C
ATOM      3  C   GLY P  -1     -21.276  -3.457  16.936  1.00  0.00           C
ATOM      4  O   GLY P  -1     -20.538  -3.887  16.047  1.00  0.00           O
ATOM      5  H1  GLY P  -1     -22.583  -3.364  14.590  1.00  0.00           H
ATOM      6  H2  GLY P  -1     -22.293  -1.817  15.040  1.00  0.00           H
ATOM      7  H3  GLY P  -1     -23.828  -2.392  15.027  1.00  0.00           H
ATOM      8  HA2 GLY P  -1     -23.016  -2.261  17.288  1.00  0.00           H
ATOM      9  HA3 GLY P  -1     -23.352  -3.933  16.803  1.00  0.00           H
""")
  xrs = pdb_in.xray_structure_simple()
  hierarchy = pdb_in.construct_hierarchy()
  with open(pdb_file, "w") as f:
    f.write(hierarchy.as_pdb_string(xrs))
  fc = xrs.structure_factors(d_min=1.5).f_calc()
  dec = mtz.label_decorator(phases_prefix="PH")
  # part 1: phenix.refine style
  mtz_data = fc.as_mtz_dataset(
    column_root_label="2FOFCWT",
    label_decorator=dec)
  mtz_data.add_miller_array(fc,
    column_root_label="2FOFCWT_no_fill",
    label_decorator=dec)
  mtz_data.add_miller_array(fc,
    column_root_label="FOFCWT",
    label_decorator=dec)
  mtz_data.add_miller_array(fc,
    column_root_label="ANOM",
    label_decorator=dec)
  mtz_data.mtz_object().write(mtz_file)
  converted = map_tools.auto_convert_map_coefficients(
    mtz_file=mtz_file,
    pdb_file=pdb_file)
  assert (not None in [converted.f_map,converted.diff_map,converted.anom_map])
  assert (converted.f_map == "tmp_iotbx_map_tools_2mFo-DFc.ccp4")
  assert (converted.f_map_type == "2mFo-DFc")
  server = map_tools.server(mtz_file)
  files = server.convert_phenix_maps(file_base=prefix)
  files = [ os.path.basename(file_name) for file_name in files ]
  assert (files == ['tmp_iotbx_map_tools_anomalous.ccp4',
    'tmp_iotbx_map_tools_mFo-DFc.ccp4', 'tmp_iotbx_map_tools_2mFo-DFc.ccp4',
    'tmp_iotbx_map_tools_2mFo-DFc_no_fill.ccp4'])
  for fn in files :
    assert os.path.isfile(fn)
    os.remove(fn)
  file_name = server.convert_any_map(
    f_label="2FOFCWT,PH2FOFCWT",
    phi_label=None,
    fom_label=None,
    use_standard_map_names=True)
  assert (file_name == "tmp_iotbx_map_tools_2mFo-DFc.ccp4")
  assert os.path.isfile(file_name)
  # part 2: Phaser/Refmac style
  mtz_data = fc.as_mtz_dataset(
    column_root_label="FWT",
    label_decorator=mtz.ccp4_label_decorator())
  mtz_data.add_miller_array(fc,
    column_root_label="DELFWT",
    label_decorator=mtz.ccp4_label_decorator())
  mtz_data.mtz_object().write(mtz_file)
  converted = map_tools.auto_convert_map_coefficients(
    mtz_file=mtz_file,
    pdb_file=pdb_file)
  assert (not None in [converted.f_map, converted.diff_map])
  assert (converted.f_map == 'tmp_iotbx_map_tools_FWT.ccp4')
  assert (converted.f_map_type == "2mFo-DFc")
  server = map_tools.server(mtz_file)
  map_files = server.convert_ccp4_map(pdb_file=pdb_file)
  map_files = [ os.path.basename(file_name) for file_name in map_files ]
  assert (map_files == ['tmp_iotbx_map_tools_FWT.ccp4',
    'tmp_iotbx_map_tools_DELFWT.ccp4'])
  # part 3: Resolve style
  mtz_data = fc.as_mtz_dataset(
    column_root_label="FWT",
    label_decorator=mtz.ccp4_label_decorator())
  ampl = abs(fc)
  phases = fc.phases()
  fom = fc.customized_copy(
    data=flex.double(fc.data().size(), 1),
    observation_type=None)
  mtz_data.add_miller_array(ampl, column_root_label="FP")
  mtz_data.add_miller_array(phases, column_root_label="PHIM")
  mtz_data.add_miller_array(fom, column_root_label="FOMM")
  mtz_data.mtz_object().write(mtz_file)
  server = map_tools.server(mtz_file)
  map_file = server.convert_resolve_map(pdb_file=None,
    force=False)
  assert (map_file == 'tmp_iotbx_map_tools.ccp4')
  assert os.path.exists(map_file)
  # write_map_coefficients_generic
  map_tools.write_map_coefficients_generic(
    map_coeffs=[fc, fc.generate_bijvoet_mates(), fc, fc],
    map_types=["2mFo-DFc", "mFo-DFc", "anom", "other"],
    file_name="tmp_iotbx_map_tools2.mtz")
  mtz_in = file_reader.any_file("tmp_iotbx_map_tools2.mtz")
  labels = [a.info().label_string() for a in mtz_in.file_server.miller_arrays]
  assert (labels == ['2FOFCWT,PH2FOFCWT', 'FOFCWT,PHFOFCWT', 'ANOM,PHANOM',
                     'other,PHother'])

if (__name__ == "__main__"):
  exercise_map_tools()
  print("OK")


 *******************************************************************************


 *******************************************************************************
iotbx/regression/tst_merging_statistics.py

from __future__ import absolute_import, division, print_function
from iotbx.command_line import merging_statistics
from cctbx.array_family import flex
from libtbx.test_utils import approx_equal, Exception_expected, show_diff
from libtbx.utils import Sorry
import libtbx.load_env
from six.moves import cStringIO as StringIO
import os
import sys


def exercise(debug=False):
  if not libtbx.env.has_module("phenix_regression"):
    print("phenix_regression not configured, skipping.")
    return
  hkl_file = libtbx.env.find_in_repositories(
    relative_path="phenix_regression/wizards/help_tests/test_help/p9_se_w2.sca",
    test=os.path.isfile)
  assert hkl_file is not None
  args = [
    hkl_file,
    "space_group=I4",
    "unit_cell=113.949,113.949,32.474,90,90,90",
    "loggraph=True",
  ]
  if debug:
    args.append("debug=True")
    print(" ".join(args))
  out = StringIO()
  result = merging_statistics.run(args, out=out)
  if debug:
    print(out.getvalue())
  assert ("R-merge: 0.073" in out.getvalue())
  assert ("R-meas:  0.079" in out.getvalue())
  assert ("""  1.81   1.74  12528   2073    6.04  97.05    1449.2     5.2    0.252    0.275    0.110    0.294   0.967   0.281""" in out.getvalue()), out.getvalue()
  cif_block = result.as_cif_block()
  assert "_reflns_shell" in cif_block
  assert approx_equal(float(cif_block["_reflns.pdbx_Rpim_I_all"]), result.overall.r_pim)
  assert approx_equal(float(cif_block["_reflns.pdbx_CC_half"]), result.overall.cc_one_half)
  assert approx_equal(float(cif_block["_reflns.percent_possible_obs"]), result.overall.completeness * 100.0)
  assert approx_equal(
    flex.int(cif_block["_reflns_shell.number_measured_obs"]),
    [15737, 15728, 15668, 15371, 14996, 14771, 13899, 13549, 13206, 12528])
  assert "_reflns_shell.pdbx_CC_half" in cif_block
  remark_200 = result.as_remark_200(wavelength=0.9792).splitlines()
  assert ("REMARK 200  <I/SIGMA(I)> FOR SHELL         : 5.1536" in remark_200),"\n".join(remark_200)
  assert ("REMARK 200  WAVELENGTH OR RANGE        (A) : 0.9792" in remark_200)
  # test resolution cutoffs
  args2 = list(args[:-1]) + ["high_resolution=2.5", "low_resolution=15"]
  out = StringIO()
  merging_statistics.run(args2, out=out)
  if debug:
    print(out.getvalue())
  assert ("Resolution: 14.96 - 2.50" in out.getvalue())
  # extend binning
  args2 = list(args[:-1]) + ["high_resolution=1.5", "low_resolution=100",
    "--extend_d_max_min"]
  out = StringIO()
  merging_statistics.run(args2, out=out)
  if debug:
    print(out.getvalue())
  assert ("Resolution: 100.00 - 1.50" in out.getvalue())
  assert ("  1.55   1.50      0      0    0.00   0.00       0.0     0.0     None     None     None     0.000   0.000""" in out.getvalue())
  args2 = args + ["json.file_name=merging_stats.json", "json.indent=2",
                  "mmcif.file_name=merging_stats.mmcif", "mmcif.data_name=test"]
  out = StringIO()
  merging_statistics.run(args2, out=out)
  assert os.path.exists("merging_stats.json")
  with open("merging_stats.json", "rb") as f:
    import json
    d = json.load(f)
    list(d.keys())  #FIXME why am I here?
    expected_keys = [
      'n_obs', 'd_star_sq_max', 'i_over_sigma_mean', 'completeness',
      'cc_one_half', 'r_meas', 'd_star_sq_min', 'cc_anom', 'r_pim',
      'i_mean', 'cc_one_half_critical_value', 'r_merge', 'multiplicity',
      'cc_one_half_significance', 'n_uniq', 'anom_completeness', 'anom_signal',
      'delta_i_mean_over_sig_delta_i_mean',
    ]
    for k in expected_keys:
      assert k in d
    assert approx_equal(
      d['i_over_sigma_mean'],
      [20.66560600258035, 20.345307828448572, 18.349521604862186,
       16.032340432560876, 15.111031030727927, 12.289599369298855,
       10.059003053756124, 8.042714696129208, 6.297114205813105,
       5.153613598686054]
    )
    assert approx_equal(
      d['n_obs'],
      [15737, 15728, 15668, 15371, 14996, 14771, 13899, 13549, 13206, 12528]
    )
    assert 'overall' in d
    assert approx_equal(d['overall']['i_mean'], 18672.03367141032)
    assert approx_equal(d['overall']['multiplicity'], 6.747367444449599)
  import iotbx.cif
  assert os.path.exists("merging_stats.mmcif")
  cif = iotbx.cif.reader("merging_stats.mmcif").model()
  assert approx_equal(float(cif["test"]["_reflns.pdbx_CC_half"]), 0.997601585888)
  assert list(cif["test"]["_reflns_shell.number_measured_obs"]) == ['15737', '15728', '15668', '15371', '14996', '14771', '13899', '13549', '13206', '12528']
  #
  args3 = args + ["anomalous=True"]
  result = merging_statistics.run(args3, out=out)
  assert approx_equal(result.overall.anom_signal, 0.0835294960933567)
  assert approx_equal(result.overall.anom_completeness, 0.9836098441180893)
  assert approx_equal(result.overall.delta_i_mean_over_sig_delta_i_mean, 1.1764137800824204)
  # these should crash
  args2 = list(args[:-1]) + ["high_resolution=15", "low_resolution=2.5"]
  try :
    merging_statistics.run(args2, out=out)
  except Sorry:
    pass
  else :
    raise Exception_expected
  args2 = list(args[:-1]) + ["high_resolution=1.5", "low_resolution=1.6"]
  try :
    merging_statistics.run(args2, out=out)
  except Sorry:
    pass
  else :
    raise Exception_expected
  # change space group
  args = [
    hkl_file,
    "space_group=I422",
    "unit_cell=113.949,113.949,32.474,90,90,90",
    "loggraph=True",
  ]
  if debug:
    args.append("debug=True")
    print(" ".join(args))
  out = StringIO()
  merging_statistics.run(args, out=out)
  if debug:
    print(out.getvalue())
  assert (" 28.49   3.76  15737   1224   12.86  99.84   47967.0    11.6    0.482    0.500    0.135    0.136   0.973  -0.513" in out.getvalue()), out.getvalue()
  # exercise 2: estimate resolution cutoffs (and symmetry_file argument)
  hkl_file = libtbx.env.find_in_repositories(
    relative_path="phenix_regression/harvesting/unmerged.sca",
    test=os.path.isfile)
  assert hkl_file is not None
  symm_file = libtbx.env.find_in_repositories(
    relative_path="phenix_regression/harvesting/refine.mtz",
    test=os.path.isfile)
  assert symm_file is not None
  args = [
    hkl_file,
    "symmetry_file=\"%s\"" % symm_file,
    "--estimate_cutoffs",
  ]
  out = StringIO()
  merging_statistics.run(args, out=out)
  if debug:
    print(out.getvalue())
  for line in """\
  resolution of all data          :   2.000
  based on CC(1/2) >= 0.33        :   2.000
  based on mean(I/sigma) >= 2.0   :   2.253
  based on R-merge < 0.5          :   2.372
  based on R-meas < 0.5           :   2.520
  based on completeness >= 90%    :   2.000
  based on completeness >= 50%    :   2.000""".splitlines():
    assert line in out.getvalue(), out.getvalue()
  # check suitable error emitted given merged input mtz (not containing M_ISYM column)
  out = StringIO()
  hkl_file = libtbx.env.find_in_repositories(
    relative_path="phenix_regression/reflection_files/i_anomalous.mtz",
    test=os.path.isfile)
  assert hkl_file is not None

  # Test that merged anomalous data are already merged.
  try:
    merging_statistics.run([hkl_file, "anomalous=True"], out=out)
  except Sorry as e:
    assert str(e) == 'The data in i_anomalous(+),SIGi_anomalous(+),i_anomalous(-),SIGi_anomalous(-) are already merged.  Only unmerged (but scaled) data may be used in this program.'
  else: raise Exception_expected

  # Test that merged anomalous data can still be merged as non-anomalous data.
  merging_statistics.run([hkl_file], out=out)

  # test use_internal_variance option
  out = StringIO()
  hkl_file = libtbx.env.find_in_repositories(
    relative_path="phenix_regression/wizards/help_tests/test_help/unmerged.mtz",
    test=os.path.isfile)
  assert hkl_file is not None
  args = [hkl_file, "use_internal_variance=False"]
  result = merging_statistics.run(args, out=out)
  assert approx_equal(result.overall.i_over_sigma_mean, 4.4867598237199)
  assert approx_equal(result.overall.unmerged_i_over_sigma_mean, 2.559049577429115)
  args = [hkl_file,
          #"use_internal_variance=True" # this is the default behaviour
          ]
  result = merging_statistics.run(args, out=out)
  assert approx_equal(result.overall.i_over_sigma_mean, 4.063574245292925)
  assert approx_equal(result.overall.unmerged_i_over_sigma_mean, 2.559049577429115)
  # test eliminate_sys_absent option
  out = StringIO()
  hkl_file = libtbx.env.find_in_repositories(
    relative_path="phenix_regression/reflection_files/AUTOMATIC_DEFAULT_scaled_unmerged_WAVE1.mtz",
    test=os.path.isfile)
  assert hkl_file is not None
  args = [hkl_file,
          #"eliminate_sys_absent=True" # default behaviour
          ]
  result = merging_statistics.run(args, out=out)
  assert approx_equal(result.overall.d_max, 43.069972142418365)
  assert result.overall.n_obs == 118981, result.overall.n_obs
  args = [hkl_file, "binning_method=counting_sorted",
          "eliminate_sys_absent=False", "n_bins=20",
          "cc_one_half_significance_level=0.01"]
  result = merging_statistics.run(args, out=out)
  assert len(result.bins) == 20
  assert approx_equal(result.overall.d_max, 52.445602416992195)
  assert result.overall.n_obs == 119045, result.overall.n_obs
  assert approx_equal(result.bins[0].cc_anom, 0.879550520045)
  assert approx_equal(result.bins[0].r_anom, 0.12112581576975405)
  assert result.bins[0].cc_anom_significance is True
  assert approx_equal(result.bins[0].cc_anom_critical_value, 0.0873548986308)
  assert approx_equal(result.cc_one_half_overall, 0.931122967496)
  assert approx_equal(result.cc_one_half_sigma_tau_overall, 0.9280192675969664)
  assert approx_equal(result.bins[0].cc_one_half, 0.9969293192434535)
  assert approx_equal(result.bins[0].cc_one_half_sigma_tau, 0.9968045160775104)
  assert result.bins[0].cc_one_half_significance is True
  assert result.bins[0].cc_one_half_sigma_tau_significance is True
  assert approx_equal(result.bins[-1].cc_one_half, 0.675340867481686)
  assert approx_equal(result.bins[-1].cc_one_half_sigma_tau, 0.6711734115834956)
  assert result.bins[-1].cc_one_half_significance is True
  assert result.bins[-1].cc_one_half_sigma_tau_significance is True
  #
  args2 = args + ["anomalous=True"]
  result = merging_statistics.run(args2, out=out)
  app = result.overall.anom_probability_plot_all_data
  assert approx_equal(app.slope, 1.6747371892218779)
  assert approx_equal(app.intercept, 0.03443233016003127)
  assert app.n_pairs == 24317
  assert app.expected_delta is None
  app = result.overall.anom_probability_plot_expected_delta
  assert approx_equal(app.slope, 1.2190614967160294)
  assert approx_equal(app.intercept, 0.031151653693628906)
  assert app.n_pairs == 15365
  assert app.expected_delta == 0.9
  d = result.overall.as_dict()
  for k in ("anom_probability_plot_all_data", "anom_probability_plot_expected_delta"):
    assert list(d[k].keys()) == ["slope", "intercept", "n_pairs", "expected_delta"], list(d[k].keys())
  out = StringIO()
  result.overall.show_anomalous_probability_plot(out)
  assert not show_diff(out.getvalue(),
                       """\
Anomalous probability plot (all data):
  slope:     1.675
  intercept: 0.034
  n_pairs:   24317
Anomalous probability plot (expected delta = 0.9):
  slope:     1.219
  intercept: 0.031
  n_pairs:   15365
""")

  args = [hkl_file, "binning_method=counting_sorted",
          "eliminate_sys_absent=False", "n_bins=20",
          "reflections_per_bin=2000",
          "cc_one_half_significance_level=0.01"]
  result = merging_statistics.run(args, out=out)
  assert len(result.bins) == 12


if __name__ == "__main__":
  exercise(debug=("--debug" in sys.argv))
  print("OK")


 *******************************************************************************


 *******************************************************************************
iotbx/regression/tst_miller_sort_asu.py

from __future__ import absolute_import, division, print_function
from cctbx import crystal
from cctbx import miller

def exercise_sort():
  expected_unsorted_data="""    4 I 4
  1  0  0  0  1  0  0  0  1
  0  0  0
  0 -1  0  1  0  0  0  0  1
  0  0  0
  0  1  0 -1  0  0  0  0  1
  0  0  0
 -1  0  0  0 -1  0  0  0  1
  0  0  0
   0   0   4   0   0   4     0 1 0  1 80331.8  8648.0
   0   0  12   0   0  12     0 1 0  1104526.7 11623.3
   0   0  -4   0   0   4     0 2 0  1 44883.6  4527.6
   0   0  -8   0   0   8     0 2 0  1 41134.1  4431.9
   0   0   8   0   0   8     0 1 0  1 50401.8  5464.6
   0   0   8   0   0   8     0 1 0  1 53386.0  5564.1
   0   0  -8   0   0   8     0 2 0  1119801.4 12231.2
   0   0  12   0   0  12     0 1 0  1105312.9 12602.2
   0   0  16   0   0  16     0 1 0  1 14877.6  2161.5
"""
  expected_sorted_data="""    4 I 4
  1  0  0  0  1  0  0  0  1
  0  0  0
  0 -1  0  1  0  0  0  0  1
  0  0  0
  0  1  0 -1  0  0  0  0  1
  0  0  0
 -1  0  0  0 -1  0  0  0  1
  0  0  0
   0   0   4   0   0   4     0 1 0  1 80331.8  8648.0
   0   0  -4   0   0   4     0 2 0  1 44883.6  4527.6
   0   0   8   0   0   8     0 1 0  1 50401.8  5464.6
   0   0   8   0   0   8     0 1 0  1 53386.0  5564.1
   0   0  -8   0   0   8     0 2 0  1 41134.1  4431.9
   0   0  -8   0   0   8     0 2 0  1119801.4 12231.2
   0   0  12   0   0  12     0 1 0  1104526.7 11623.3
   0   0  12   0   0  12     0 1 0  1105312.9 12602.2
   0   0  16   0   0  16     0 1 0  1 14877.6  2161.5
"""

  from cctbx.xray import observation_types
  from cctbx.array_family import flex
  xs = crystal.symmetry((113.949,113.949,32.474,90.000,90.000,90.000), "I4")
  mi = flex.miller_index((
  (0,0,4),
  (0,0,12),
  (0,0,-4),
  (0,0,-8),
  (0,0,8),
  (0,0,8),
  (0,0,-8),
  (0,0,12),
  (0,0,16),
   ))
  data = flex.double(( 80331.8, 104526.7, 44883.6, 41134.1, 50401.8, 53386.0, 119801.4, 105312.9, 14877.6,))
  sigmas = flex.double((8648.0, 11623.3, 4527.6, 4431.9, 5464.6, 5564.1, 12231.2, 12602.2, 2161.5,))
  ms = miller.set(xs, mi,anomalous_flag=True)
  i_obs = miller.array(ms, data=data, sigmas=sigmas).set_observation_type(
    observation_types.intensity() )

  i_obs.export_as_scalepack_unmerged(file_name='unsorted.sca',
     scale_intensities_for_scalepack_merge=True)
  i_obs=i_obs.sort(by_value="asu_indices")
  i_obs.export_as_scalepack_unmerged(file_name='sorted.sca',
     scale_intensities_for_scalepack_merge=True)
  with open('unsorted.sca') as f:
    unsorted = f.read()
  with open('sorted.sca') as f:
    sorted = f.read()
  assert unsorted==expected_unsorted_data
  assert sorted==expected_sorted_data

def exercise():
  exercise_sort()
  print("OK")

if __name__ == "__main__" :
  exercise()
#---end


 *******************************************************************************


 *******************************************************************************
iotbx/regression/tst_mmcif_input.py
from __future__ import absolute_import, division, print_function
import iotbx.pdb

cif_str = """\
data_1YJP
_cell.entry_id           1YJP
_cell.length_a           21.937
_cell.length_b           4.866
_cell.length_c           23.477
_cell.angle_alpha        90.00
_cell.angle_beta         107.08
_cell.angle_gamma        90.00
_cell.Z_PDB              2
_cell.pdbx_unique_axis   ?
_pdbx_database_status.recvd_initial_deposition_date   2005-01-15
loop_
_atom_site.group_PDB
_atom_site.id
_atom_site.type_symbol
_atom_site.label_atom_id
_atom_site.label_alt_id
_atom_site.label_comp_id
_atom_site.label_asym_id
_atom_site.label_entity_id
_atom_site.label_seq_id
_atom_site.pdbx_PDB_ins_code
_atom_site.Cartn_x
_atom_site.Cartn_y
_atom_site.Cartn_z
_atom_site.occupancy
_atom_site.B_iso_or_equiv
_atom_site.pdbx_formal_charge
_atom_site.auth_seq_id
_atom_site.auth_comp_id
_atom_site.auth_asym_id
_atom_site.auth_atom_id
_atom_site.pdbx_PDB_model_num
ATOM   1  N N   . GLY A 1 1 ? -9.009  4.612  6.102  1.00 16.77 ? 1  GLY A N   1
ATOM   2  C CA  . GLY A 1 1 ? -9.052  4.207  4.651  1.00 16.57 ? 1  GLY A CA  1
ATOM   3  C C   . GLY C 1 1 ? -8.015  3.140  4.419  1.00 16.16 ? 1  GLY CC C   1
ATOM   4  O O   . GLY D 1 1 ? -7.523  2.521  5.381  1.00 16.78 ? 1  GLY DDDD O   1
"""


def exercise_extract_header_year(prefix="iotbx_tst_mmcif_segids"):
  cif_inp = iotbx.pdb.input(lines=cif_str, source_info=None)
  # print(cif_inp.deposition_date())
  # print(cif_inp.extract_header_year())
  assert cif_inp.deposition_date() == "2005-01-15"
  assert cif_inp.extract_header_year() == 2005

  # now the same but with ?

  cif_str_2 = cif_str.replace('2005-01-15', '?')
  cif_inp_2 = iotbx.pdb.input(lines=cif_str_2, source_info=None)
  # print(cif_inp_2.deposition_date())
  # print(cif_inp_2.extract_header_year())
  assert cif_inp_2.deposition_date() == '?'
  assert cif_inp_2.extract_header_year() == None

def exercise_label_to_auth_asym_id_dictionary():
  cif_inp = iotbx.pdb.input(lines=cif_str, source_info=None)
  res = cif_inp.label_to_auth_asym_id_dictionary()
  # print(res)
  assert res == {'A': 'A', 'C': 'CC', 'D': 'DDDD'}, res

if __name__ == "__main__":
  exercise_extract_header_year()
  exercise_label_to_auth_asym_id_dictionary()


 *******************************************************************************


 *******************************************************************************
iotbx/regression/tst_mmcif_multimodel.py
from __future__ import absolute_import, division, print_function

import iotbx.pdb

pdb_str_1 = """\
CRYST1   21.937    4.866   23.477  90.00 107.08  90.00 P 1 21 1      2
MODEL        1
ATOM      1  N   GLY A   1      -9.009   4.612   6.102  1.00 16.77           N
ATOM      2  CA  GLY A   1      -9.052   4.207   4.651  1.00 16.57           C
ATOM      3  C   GLY A   1      -8.015   3.140   4.419  1.00 16.16           C
ATOM      4  O   GLY A   1      -7.523   2.521   5.381  1.00 16.78           O
ATOM      5  N   ASN A   2      -7.656   2.923   3.155  1.00 15.02           N
ATOM      6  CA  ASN A   2      -6.522   2.038   2.831  1.00 14.10           C
ATOM      7  C   ASN A   2      -5.241   2.537   3.427  1.00 13.13           C
ATOM      8  O   ASN A   2      -4.978   3.742   3.426  1.00 11.91           O
ATOM      9  CB  ASN A   2      -6.346   1.881   1.341  1.00 15.38           C
ATOM     10  CG  ASN A   2      -7.584   1.342   0.692  1.00 14.08           C
ATOM     11  OD1 ASN A   2      -8.025   0.227   1.016  1.00 17.46           O
ATOM     12  ND2 ASN A   2      -8.204   2.155  -0.169  1.00 11.72           N
ATOM     13  N   ASN A   3      -4.438   1.590   3.905  1.00 12.26           N
ATOM     14  CA  ASN A   3      -3.193   1.904   4.589  1.00 11.74           C
ATOM     15  C   ASN A   3      -1.955   1.332   3.895  1.00 11.10           C
ATOM     16  O   ASN A   3      -1.872   0.119   3.648  1.00 10.42           O
ATOM     17  CB  ASN A   3      -3.259   1.378   6.042  1.00 12.15           C
ATOM     18  CG  ASN A   3      -2.006   1.739   6.861  1.00 12.82           C
ATOM     19  OD1 ASN A   3      -1.702   2.925   7.072  1.00 15.05           O
ATOM     20  ND2 ASN A   3      -1.271   0.715   7.306  1.00 13.48           N
ENDMDL
MODEL        2
ATOM     21  N   GLN A   4      -1.005   2.228   3.598  1.00 10.29           N
ATOM     22  CA  GLN A   4       0.384   1.888   3.199  1.00 10.53           C
ATOM     23  C   GLN A   4       1.435   2.606   4.088  1.00 10.24           C
ATOM     24  O   GLN A   4       1.547   3.843   4.115  1.00  8.86           O
ATOM     25  CB  GLN A   4       0.656   2.148   1.711  1.00  9.80           C
ATOM     26  CG  GLN A   4       1.944   1.458   1.213  1.00 10.25           C
ATOM     27  CD  GLN A   4       2.504   2.044  -0.089  1.00 12.43           C
ATOM     28  OE1 GLN A   4       2.744   3.268  -0.190  1.00 14.62           O
ATOM     29  NE2 GLN A   4       2.750   1.161  -1.091  1.00  9.05           N
ATOM     30  N   GLN A   5       2.154   1.821   4.871  1.00 10.38           N
ATOM     31  CA  GLN A   5       3.270   2.361   5.640  1.00 11.39           C
ATOM     32  C   GLN A   5       4.594   1.768   5.172  1.00 11.52           C
ATOM     33  O   GLN A   5       4.768   0.546   5.054  1.00 12.05           O
ATOM     34  CB  GLN A   5       3.056   2.183   7.147  1.00 11.96           C
ATOM     35  CG  GLN A   5       1.829   2.950   7.647  1.00 10.81           C
ATOM     36  CD  GLN A   5       1.344   2.414   8.954  1.00 13.10           C
ATOM     37  OE1 GLN A   5       0.774   1.325   9.002  1.00 10.65           O
ATOM     38  NE2 GLN A   5       1.549   3.187  10.039  1.00 12.30           N
ATOM     39  N   ASN A   6       5.514   2.664   4.856  1.00 11.99           N
ATOM     40  CA  ASN A   6       6.831   2.310   4.318  1.00 12.30           C
ATOM     41  C   ASN A   6       7.854   2.761   5.324  1.00 13.40           C
ATOM     42  O   ASN A   6       8.219   3.943   5.374  1.00 13.92           O
ATOM     43  CB  ASN A   6       7.065   3.016   2.993  1.00 12.13           C
ATOM     44  CG  ASN A   6       5.961   2.735   2.003  1.00 12.77           C
ATOM     45  OD1 ASN A   6       5.798   1.604   1.551  1.00 14.27           O
ATOM     46  ND2 ASN A   6       5.195   3.747   1.679  1.00 10.07           N
ENDMDL
MODEL        3
ATOM     47  N   TYR A   7       8.292   1.817   6.147  1.00 14.70           N
ATOM     48  CA  TYR A   7       9.159   2.144   7.299  1.00 15.18           C
ATOM     49  C   TYR A   7      10.603   2.331   6.885  1.00 15.91           C
ATOM     50  O   TYR A   7      11.041   1.811   5.855  1.00 15.76           O
ATOM     51  CB  TYR A   7       9.061   1.065   8.369  1.00 15.35           C
ATOM     52  CG  TYR A   7       7.665   0.929   8.902  1.00 14.45           C
ATOM     53  CD1 TYR A   7       6.771   0.021   8.327  1.00 15.68           C
ATOM     54  CD2 TYR A   7       7.210   1.756   9.920  1.00 14.80           C
ATOM     55  CE1 TYR A   7       5.480  -0.094   8.796  1.00 13.46           C
ATOM     56  CE2 TYR A   7       5.904   1.649  10.416  1.00 14.33           C
ATOM     57  CZ  TYR A   7       5.047   0.729   9.831  1.00 15.09           C
ATOM     58  OH  TYR A   7       3.766   0.589  10.291  1.00 14.39           O
ATOM     59  OXT TYR A   7      11.358   2.999   7.612  1.00 17.49           O
ENDMDL
END
"""

def tst_1():
  h = iotbx.pdb.input(source_info=None, lines=pdb_str_1).construct_hierarchy()
  cb = h.as_cif_block()
  print(dir(cb))
  print(cb.keys())

  # Make sure model number gets changed
  assert list(cb['_atom_site.pdbx_PDB_model_num']) == [
      '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1',
      '2', '2', '2', '2', '2', '2', '2', '2', '2', '2', '2', '2', '2', '2', '2', '2', '2', '2', '2', '2', '2', '2', '2', '2', '2', '2',
      '3', '3', '3', '3', '3', '3', '3', '3', '3', '3', '3', '3', '3']
  # Make sure residue ids get reset
  assert list(cb['_atom_site.label_seq_id']) == [
      '1', '1', '1', '1', '2', '2', '2', '2', '2', '2', '2', '2', '3', '3', '3', '3', '3', '3', '3', '3',
      '1', '1', '1', '1', '1', '1', '1', '1', '1', '2', '2', '2', '2', '2', '2', '2', '2', '2', '3', '3', '3', '3', '3', '3', '3', '3',
      '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1']
  # Make sure atom ids get reset
  assert list(cb['_atom_site.id']) == [
      '1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '20',
      '1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '20', '21', '22', '23', '24', '25', '26',
      '1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12', '13']

if __name__ == '__main__':
  tst_1()


 *******************************************************************************


 *******************************************************************************
iotbx/regression/tst_mmcif_segids.py
from __future__ import absolute_import, division, print_function
import iotbx.pdb
from six.moves import cStringIO as StringIO

pdb_str = """\
ATOM      1  C5'   U     5      97.750 -47.885 -63.217  1.00 83.53      A16S C
ATOM      2  O5'   U     5      98.491 -48.524 -62.188  1.00 79.28      A16S O
ATOM      3  C4'   U     5      96.316 -48.337 -63.206  1.00 86.16      A16S C
ATOM      4  O4'   U     5      95.819 -48.280 -61.845  1.00 86.45      A16S O
ATOM      5  C3'   U     5      95.333 -47.485 -63.995  1.00 87.46      A16S C
ATOM      6  O3'   U     5      95.360 -47.739 -65.396  1.00 87.28      A16S O
ATOM      7  C2'   U     5      94.014 -47.773 -63.286  1.00 84.71      A16S C
ATOM      8  O2'   U     5      93.532 -49.058 -63.634  1.00 85.00      A16S O
ATOM      9  C1'   U     5      94.476 -47.853 -61.835  1.00 84.81      A16S C
ATOM     10  N1    U     5      94.415 -46.549 -61.136  1.00 89.08      A16S N
ATOM     11  C2    U     5      94.346 -46.619 -59.764  1.00 90.22      A16S C
ATOM     12  O2    U     5      94.352 -47.676 -59.164  1.00 86.48      A16S O
ATOM     13  N3    U     5      94.297 -45.413 -59.117  1.00 91.22      A16S N
ATOM     14  C4    U     5      94.296 -44.164 -59.695  1.00 88.42      A16S C
ATOM     15  O4    U     5      94.242 -43.169 -58.977  1.00 87.55      A16S O
ATOM     16  C5    U     5      94.358 -44.166 -61.121  1.00 88.94      A16S C
ATOM     17  C6    U     5      94.408 -45.329 -61.773  1.00 89.00      A16S C
ATOM  99999  P     C   172      78.677  39.674 -73.035  1.00136.18      B23S P
ATOM  99999  C5'   C   172      78.936  39.931 -75.628  1.00129.50      B23S C
ATOM  99999  O5'   C   172      78.085  39.757 -74.507  1.00131.05      B23S O
ATOM  99999  C4'   C   172      78.137  39.999 -76.900  1.00127.67      B23S C
ATOM  99999  O4'   C   172      77.604  38.690 -77.227  1.00128.58      B23S O
ATOM  99999  C3'   C   172      76.907  40.883 -76.846  1.00128.68      B23S C
ATOM  99999  O3'   C   172      77.201  42.258 -76.974  1.00129.72      B23S O
ATOM  99999  C2'   C   172      76.054  40.323 -77.972  1.00130.33      B23S C
ATOM  99999  O2'   C   172      76.544  40.754 -79.232  1.00129.46      B23S O
ATOM  99999  C1'   C   172      76.335  38.830 -77.835  1.00131.16      B23S C
ATOM  99999  N1    C   172      75.328  38.158 -76.984  1.00132.38      B23S N
ATOM  99999  C2    C   172      74.039  37.935 -77.483  1.00130.56      B23S C
ATOM  99999  O2    C   172      73.763  38.302 -78.634  1.00128.13      B23S O
ATOM  99999  N3    C   172      73.131  37.313 -76.697  1.00130.47      B23S N
ATOM  99999  C4    C   172      73.464  36.923 -75.469  1.00131.73      B23S C
ATOM  99999  N4    C   172      72.544  36.315 -74.719  1.00129.68      B23S N
ATOM  99999  C5    C   172      74.765  37.140 -74.941  1.00132.57      B23S C
ATOM  99999  C6    C   172      75.656  37.757 -75.722  1.00131.42      B23S C
ATOM  99999  OP1   C   172      79.530  40.865 -72.814  1.00135.64      B23S O
ATOM  99999  OP2   C   172      77.560  39.387 -72.106  1.00132.48      B23S O1-
ATOM  99999  N   PRO    44      38.238  25.445 -61.632  1.00 58.89      BL28 N
ATOM  99999  CA  PRO    44      38.138  24.574 -62.799  1.00 58.30      BL28 C
ATOM  99999  C   PRO    44      38.531  23.151 -62.439  1.00 58.13      BL28 C
ATOM  99999  O   PRO    44      38.794  22.820 -61.286  1.00 57.98      BL28 O
ATOM  99999  CB  PRO    44      39.136  25.191 -63.776  1.00 56.49      BL28 C
ATOM  99999  CG  PRO    44      40.143  25.804 -62.902  1.00 55.93      BL28 C
ATOM  99999  CD  PRO    44      39.395  26.345 -61.727  1.00 56.81      BL28 C

"""

def exercise(prefix="iotbx_tst_mmcif_segids"):
  """
  Properly output segids when chain ids are empty. Case for Ribosome community.
  After making it work, it should be moved to cctbx_project/iotbx/regression.
  """
  out = StringIO()
  pdb_inp = iotbx.pdb.input(lines=pdb_str, source_info=None)
  h = pdb_inp.construct_hierarchy()
  print("Original:")
  print(h.as_pdb_string())
  assert len(h.only_model().chains()) == 3
  assert [x.id for x in h.only_model().chains()] == [' ', ' ', ' ']
  assert [x.segid for x in h.atoms()] == ['A16S', 'A16S', 'A16S', 'A16S', 'A16S',
      'A16S', 'A16S', 'A16S', 'A16S', 'A16S', 'A16S', 'A16S', 'A16S', 'A16S',
      'A16S', 'A16S', 'A16S', 'B23S', 'B23S', 'B23S', 'B23S', 'B23S', 'B23S',
      'B23S', 'B23S', 'B23S', 'B23S', 'B23S', 'B23S', 'B23S', 'B23S', 'B23S',
      'B23S', 'B23S', 'B23S', 'B23S', 'B23S', 'BL28', 'BL28', 'BL28', 'BL28',
      'BL28', 'BL28', 'BL28']
  cif_block = h.as_cif_block()
  cif = iotbx.cif.model.cif()
  cif['test'] = cif_block
  cif.show(out=out, align_columns=True)
  lines = out.getvalue()
  assert "  ATOM  20  OP2  .  C    B23S  172  ?  77.56000   39.38700  -72.10600  1.000  132.48000  O  1-  B  ?  .  1" in lines
  print(lines)

if __name__ == "__main__":
  exercise()


 *******************************************************************************


 *******************************************************************************
iotbx/regression/tst_mmcif_to_from_hierarchy.py
from __future__ import absolute_import, division, print_function
import time
import iotbx.pdb

# ------------------------------------------------------------------------------

# from https://github.com/wwPDB/extended-wwPDB-identifier-examples
# https://github.com/wwPDB/extended-wwPDB-identifier-examples/blob/main/Models/7fgz-extended_CCD_code-model.cif
mmcif_str= '''data_phenix
loop_
  _atom_site.group_PDB
  _atom_site.id
  _atom_site.label_atom_id
  _atom_site.label_alt_id
  _atom_site.label_comp_id
  _atom_site.auth_asym_id
  _atom_site.auth_seq_id
  _atom_site.pdbx_PDB_ins_code
  _atom_site.Cartn_x
  _atom_site.Cartn_y
  _atom_site.Cartn_z
  _atom_site.occupancy
  _atom_site.B_iso_or_equiv
  _atom_site.type_symbol
  _atom_site.pdbx_formal_charge
  _atom_site.label_asym_id
  _atom_site.label_entity_id
  _atom_site.label_seq_id
  _atom_site.pdbx_PDB_model_num
  ATOM     1  N    .  LYS  A  278  ?    0.39900  -10.17100  39.80200  1.000  40.11000  N   ?  A  ?  1  1
  ATOM     2  CA   .  LYS  A  278  ?   -0.16900   -9.98800  41.17300  1.000  43.86000  C   ?  A  ?  1  1
  ATOM     3  C    .  LYS  A  278  ?    0.68700   -9.01100  41.99100  1.000  41.94000  C   ?  A  ?  1  1
  ATOM     4  O    .  LYS  A  278  ?    1.04400   -7.92000  41.55600  1.000  39.32000  O   ?  A  ?  1  1
  ATOM     5  CB   .  LYS  A  278  ?   -0.26000  -11.33600  41.90200  1.000  46.47000  C   ?  A  ?  1  1
  ATOM     6  CG   .  LYS  A  278  ?   -1.58300  -12.07400  41.71300  1.000  49.13000  C   ?  A  ?  1  1
  ATOM     7  CD   .  LYS  A  278  ?   -1.61100  -13.46800  42.31500  1.000  51.03000  C   ?  A  ?  1  1
  ATOM     8  CE   .  LYS  A  278  ?   -2.92300  -13.79900  42.99300  1.000  52.86000  C   ?  A  ?  1  1
  ATOM     9  N    .  LYS  A  279  ?    0.39900  -10.17100  39.80200  1.000  40.11000  N   ?  B  ?  1  1
  ATOM    10  CA   .  LYS  A  279  ?   -0.16900   -9.98800  41.17300  1.000  43.86000  C   ?  B  ?  1  1
  ATOM    11  C    .  LYS  A  279  ?    0.68700   -9.01100  41.99100  1.000  41.94000  C   ?  B  ?  1  1
  ATOM    12  O    .  LYS  A  279  ?    1.04400   -7.92000  41.55600  1.000  39.32000  O   ?  B  ?  1  1
  ATOM    13  CB   .  LYS  A  279  ?   -0.26000  -11.33600  41.90200  1.000  46.47000  C   ?  B  ?  1  1
  ATOM    14  CG   .  LYS  A  279  ?   -1.58300  -12.07400  41.71300  1.000  49.13000  C   ?  B  ?  1  1
  ATOM    15  CD   .  LYS  A  279  ?   -1.61100  -13.46800  42.31500  1.000  51.03000  C   ?  B  ?  1  1
  ATOM    16  CE   .  LYS  A  279  ?   -2.92300  -13.79900  42.99300  1.000  52.86000  C   ?  B  ?  1  1
  ATOM    17  NZ   .  LYS  A  279  ?   -3.20900  -12.85600  44.10000  1.000  54.19000  N   ?  B  ?  1  1
  HETATM  18  CA   .  CA   A  301  ?  -17.36200  -22.38500  28.04700  1.000  15.20000  CA  ?  C  ?  .  1
  HETATM  19  C10  .  7ZT  A  302  ?   -7.64600   -6.96500   5.79600  1.000  22.62000  C   ?  D  ?  .  1
  HETATM  20  C2   .  7ZT  A  302  ?   -8.46200   -5.53400   9.26500  1.000  16.68000  C   ?  D  ?  .  1
  HETATM  21  C3   .  7ZT  A  302  ?   -8.09200   -5.86500  10.71100  1.000  17.35000  C   ?  D  ?  .  1
  HETATM  22  C5   .  7ZT  A  302  ?   -6.78100   -7.68900  10.02700  1.000  17.11000  C   ?  D  ?  .  1
  HETATM  23  C6   .  7ZT  A  302  ?   -7.36300   -7.73000   8.63300  1.000  16.97000  C   ?  D  ?  .  1
  HETATM  24  C7   .  7ZT  A  302  ?   -8.07100   -7.95100  12.06400  1.000  16.77000  C   ?  D  ?  .  1
  HETATM  25  C8   .  7ZT  A  302  ?   -8.49000   -9.44000  12.02500  1.000  16.60000  C   ?  D  ?  .  1
  HETATM  26  C9   .  7ZT  A  302  ?   -8.43800   -6.31100   6.93500  1.000  20.13000  C   ?  D  ?  .  1
  HETATM  27  N1   .  7ZT  A  302  ?   -7.74300   -6.35500   8.24300  1.000  18.72000  N   ?  D  ?  .  1
  HETATM  28  N4   .  7ZT  A  302  ?   -7.97500   -7.33400  10.76700  1.000  17.04000  N   ?  D  ?  .  1
  HETATM  29  O1S  .  7ZT  A  302  ?   -7.57900   -7.37100   3.22400  1.000  25.47000  O   ?  D  ?  .  1
  HETATM  30  O2S  .  7ZT  A  302  ?   -8.53300   -5.21100   4.07800  1.000  25.01000  O   ?  D  ?  .  1
  HETATM  31  O3S  .  7ZT  A  302  ?   -9.69100   -7.32600   4.28200  1.000  26.42000  O   ?  D  ?  .  1
  HETATM  32  O8   .  7ZT  A  302  ?   -8.39100  -10.14000  10.78100  1.000  14.14000  O   ?  D  ?  .  1
  HETATM  33  S    .  7ZT  A  302  ?   -8.37200   -6.70800   4.27900  1.000  24.90000  S   ?  D  ?  .  1
  HETATM  34  C10  .  7ZT  A  303  ?  -10.12100   -0.28900  11.39600  1.000  75.92000  C   ?  E  ?  .  1
  HETATM  35  C2   .  7ZT  A  303  ?  -11.68200    2.49500   9.26400  1.000  77.03000  C   ?  E  ?  .  1
  HETATM  36  C3   .  7ZT  A  303  ?  -11.90700    3.97900   9.61700  1.000  76.82000  C   ?  E  ?  .  1
  HETATM  37  C5   .  7ZT  A  303  ?  -12.65400    3.12300  11.90800  1.000  69.90000  C   ?  E  ?  .  1
  HETATM  38  C6   .  7ZT  A  303  ?  -12.33300    1.71900  11.40900  1.000  69.07000  C   ?  E  ?  .  1
  HETATM  39  C7   .  7ZT  A  303  ?  -11.41500    5.23200  11.72500  1.000  71.46000  C   ?  E  ?  .  1
  HETATM  40  C8   .  7ZT  A  303  ?  -12.12600    5.97600  12.87100  1.000  70.74000  C   ?  E  ?  .  1
  HETATM  41  C9   .  7ZT  A  303  ?  -10.75600    0.35700  10.14200  1.000  74.40000  C   ?  E  ?  .  1
  HETATM  42  N1   .  7ZT  A  303  ?  -11.23300    1.73200  10.44600  1.000  74.61000  N   ?  E  ?  .  1
  HETATM  43  N4   .  7ZT  A  303  ?  -12.33500    4.28200  11.02200  1.000  73.77000  N   ?  E  ?  .  1
  HETATM  44  O1S  .  7ZT  A  303  ?   -7.73500   -0.30500  10.52500  1.000  74.01000  O   ?  E  ?  .  1
  HETATM  45  O2S  .  7ZT  A  303  ?   -9.04200   -2.31300  10.14100  1.000  83.78000  O   ?  E  ?  .  1
  HETATM  46  O3S  .  7ZT  A  303  ?   -8.26400   -1.86400  12.32100  1.000  70.44000  O   ?  E  ?  .  1
  HETATM  47  O8   .  7ZT  A  303  ?  -11.36000    5.92100  14.09600  1.000  61.89000  O   ?  E  ?  .  1
  HETATM  48  S    .  7ZT  A  303  ?   -8.75700   -1.21400  11.09100  1.000  77.53000  S   ?  E  ?  .  1
  HETATM  49  O    .  HOH  A  401  ?   10.56700   -6.53900  28.06400  1.000  30.11000  O   ?  F  ?  .  1
  HETATM  50  O    .  HOH  A  402  ?    2.85600   -8.84800  40.69200  1.000  32.14000  O   ?  F  ?  .  1
  HETATM  51  O    .  HOH  A  403  ?  -10.57700  -29.76200  22.83300  1.000  22.07000  O   ?  F  ?  .  1
  HETATM  52  O    .  HOH  A  404  ?   14.70500   -5.43700  13.98800  1.000  28.06000  O   ?  F  ?  .  1

loop_
  _chem_comp.id
  7ZT
  CA
  HOH
  LYS

loop_
  _struct_asym.id
  A
  B
  C
  D
  E
  F

'''

def test1():
  """
  Test correct reading of mmCIF file with multiple label_asym_id (multiple chains with
    same chain_id) into hierarchy and writing back and forth to mmCIF.
  """
  inp = iotbx.pdb.input(lines=mmcif_str.split("\n"), source_info=None)
  h = inp.construct_hierarchy()
  text = h.as_mmcif_string()
  for a,b in zip(mmcif_str.splitlines(),text.splitlines()):
    if a != b:
      print("from mmCIF text: %s" %(a))
      print("From hierarchy : %s" %(b))
      assert a==b
  assert text == mmcif_str
  chains = list(h.overall_counts().chain_ids.keys())
  chains.sort()
  answer = ['A']
  assert (chains == answer), '%s %s' % (chains, answer)
  resnames = sorted(h.overall_counts().resnames.keys())
  assert resnames == [' CA', '7ZT', 'HOH', 'LYS'], resnames

  # write as mmCIF string
  mmcif_text = h.as_mmcif_string()

  new_h = iotbx.pdb.input(lines=mmcif_text.split("\n"), source_info=None).construct_hierarchy()
  # as PDB:
  for a,b in zip(h.as_pdb_string().splitlines(),new_h.as_pdb_string().splitlines()):
    if a != b:
      print("Original as PDB: %s" %(a))
      print("From CIF as PDB: %s" %(b))
      assert a==b
  # As mmCIF
  for a,b in zip(h.as_mmcif_string().splitlines(),new_h.as_mmcif_string().splitlines()):
    if a != b:
      print("Original as CIF: %s" %(a))
      print("From CIF as CIF: %s" %(b))
      assert a==b

  assert h.is_similar_hierarchy(new_h)
  for a,b in zip(new_h.as_mmcif_string().splitlines(),mmcif_str.splitlines()):
    if a != b:
      print("From hierarchy: %s" %(a))
      print("Original CIF  : %s" %(b))
      assert a == b
  assert new_h.as_mmcif_string() == mmcif_str


if (__name__ == "__main__"):
  t0 = time.time()
  test1()
  print("OK. Time: %8.3f"%(time.time()-t0))


 *******************************************************************************


 *******************************************************************************
iotbx/regression/tst_mrc_io.py
from __future__ import absolute_import, division, print_function
import iotbx.mrcfile
from cctbx.array_family import flex
from cctbx import crystal
from libtbx.utils import Sorry
import math

def run():
  m = flex.double(flex.grid(10,20,30), 1)
  m[1,2,3] = float('nan')
  assert math.isnan(m[1,2,3])
  cs = crystal.symmetry((10,20,30, 90,90,90), "P1")
  iotbx.mrcfile.write_ccp4_map(
    file_name   = "map_with_nan.mrc",
    unit_cell   = cs.unit_cell(),
    space_group = cs.space_group(),
    map_data    = m,
    labels      = flex.std_string(["Some text"]))
  exception = None
  try: o = iotbx.mrcfile.map_reader(file_name="map_with_nan.mrc")
  except Sorry as e: exception = str(e)
  assert exception == "Input map file contains 'nan':  not a valid map file"

if(__name__ == "__main__"):
  run()


 *******************************************************************************


 *******************************************************************************
iotbx/regression/tst_mtz_as_cif.py
from __future__ import absolute_import, division, print_function
import os
import libtbx.load_env
if (libtbx.env.has_module("ccp4io")):
  from iotbx import mtz
else:
  mtz = None
from libtbx.test_utils import approx_equal
import iotbx.cif

def get_array_by_label(miller_arrays, label):
  for ma in miller_arrays:
    if label in list(ma.info().labels):
      return ma

def exercise():
  if mtz is None:
    print("Skipping iotbx/regression/tst_mtz_as_cif.py: ccp4io not available")
    return
  from iotbx.command_line import mtz_as_cif

  file_name = libtbx.env.find_in_repositories(
    relative_path="phenix_regression/reflection_files/1akg.mtz",
    test=os.path.isfile)
  if file_name is None:
    print("Skipping 1akg.mtz test: input file not available")
  else:
    mtz_as_cif.run(args=[file_name])
    assert os.path.exists("1akg.reflections.cif")
    miller_arrays = iotbx.cif.reader(
      file_path="1akg.reflections.cif").as_miller_arrays()
    mtz_arrays = mtz.object(file_name=file_name).as_miller_arrays()
    assert '_refln.F_meas_au' in miller_arrays[0].info().labels
    assert '_refln.F_meas_sigma_au' in miller_arrays[0].info().labels
    assert approx_equal(
      get_array_by_label(miller_arrays, '_refln.F_meas_au').data(),
      get_array_by_label(mtz_arrays, 'FOBS').data())
    assert approx_equal(
      get_array_by_label(miller_arrays, '_refln.F_meas_au').sigmas(),
      get_array_by_label(mtz_arrays, 'FOBS').sigmas())
    flags1 = get_array_by_label(miller_arrays,'_refln.pdbx_r_free_flag').data()
    flags2 = get_array_by_label(mtz_arrays, 'R-free-flags').data()
    assert flags1.all_eq(flags2)

  file_name = libtbx.env.find_in_repositories(
    relative_path="phenix_regression/reflection_files/1zff.mtz",
    test=os.path.isfile)
  if file_name is None:
    print("Skipping 1zff.mtz test: input file not available")
  else:
    mtz_as_cif.run(args=[file_name])
    assert os.path.exists("1zff.reflections.cif")
    miller_arrays = iotbx.cif.reader(
      file_path="1zff.reflections.cif").as_miller_arrays()
    mtz_arrays = mtz.object(file_name=file_name).as_miller_arrays()
    #assert approx_equal(
      #get_array_by_label(miller_arrays, '_refln.F_calc_au').data(),
      #get_array_by_label(mtz_arrays, 'FC').data())
    assert approx_equal(
      get_array_by_label(miller_arrays, '_refln.F_meas_au').data(),
      get_array_by_label(mtz_arrays, 'F').data(), eps=1e-3)
    assert approx_equal(
      get_array_by_label(miller_arrays, '_refln.F_meas_au').sigmas(),
      get_array_by_label(mtz_arrays, 'F').sigmas(), eps=1e-3)
    assert approx_equal(
      get_array_by_label(miller_arrays, '_refln.pdbx_FWT').data(),
      get_array_by_label(mtz_arrays, '2FOFCWT').data(), eps=1e-2)
    assert approx_equal(
      get_array_by_label(miller_arrays, '_refln.pdbx_DELFWT').data(),
      get_array_by_label(mtz_arrays, 'FOFCWT').data(), eps=1e-3)
    assert approx_equal(
      get_array_by_label(miller_arrays, '_refln.fom').data(),
      get_array_by_label(mtz_arrays, 'FOM').data(), eps=1e-3)

  file_name = libtbx.env.find_in_repositories(
    relative_path="phenix_regression/reflection_files/l.mtz",
    test=os.path.isfile)
  if file_name is None:
    print("Skipping l.mtz test: input file not available")
  else:
    mtz_as_cif.run(args=[file_name])
    assert os.path.exists("l.reflections.cif")
    miller_arrays = iotbx.cif.reader(
      file_path="l.reflections.cif").as_miller_arrays()
    mtz_arrays = mtz.object(file_name=file_name).as_miller_arrays()
    f_anom_cif = get_array_by_label(miller_arrays, '_refln.pdbx_F_plus')
    f_anom_mtz = get_array_by_label(mtz_arrays, 'F-obs(+)')
    f_anom_cif, f_anom_mtz = f_anom_cif.common_sets(
      f_anom_mtz, assert_no_singles=True)
    rfree_cif = get_array_by_label(miller_arrays, '_refln.pdbx_r_free_flag')
    rfree_mtz = get_array_by_label(mtz_arrays, 'R-free-flags(+)')
    assert f_anom_cif.anomalous_flag()
    assert f_anom_mtz.anomalous_flag()
    assert not rfree_cif.anomalous_flag()
    assert rfree_mtz.anomalous_flag()
    assert approx_equal(f_anom_cif.data(), f_anom_mtz.data(), 1e-2)
    assert approx_equal(f_anom_cif.sigmas(), f_anom_mtz.sigmas(), 1e-2)
    assert rfree_mtz.data().all_eq(
      rfree_cif.generate_bijvoet_mates().common_set(rfree_mtz).data())

  file_name = libtbx.env.find_in_repositories(
    relative_path="phenix_regression/reflection_files/outside_4_exptl_fobs_phases_freeR_flags.mtz",
    test=os.path.isfile)
  if file_name is None:
    print("Skipping outside_4_exptl_fobs_phases_freeR_flags.mtz test: input file not available")
  else:
    mtz_as_cif.run(
      args=[file_name,
            'mtz_labels=HLAM HLBM HLCM HLDM',
            'cif_labels=_refln.pdbx_HL_A_iso _refln.pdbx_HL_B_iso _refln.pdbx_HL_C_iso _refln.pdbx_HL_D_iso',
            'output_file=custom_cif_labels.cif'])
    assert os.path.exists("custom_cif_labels.cif")
    miller_arrays = iotbx.cif.reader(
      file_path="custom_cif_labels.cif").as_miller_arrays()
    mtz_arrays = mtz.object(file_name=file_name).as_miller_arrays()
    HL_coeffs_cif = get_array_by_label(miller_arrays, '_refln.pdbx_HL_A_iso')
    HL_coeffs_mtz = get_array_by_label(mtz_arrays, 'HLAM')
    assert HL_coeffs_cif.is_hendrickson_lattman_array()
    assert HL_coeffs_mtz.is_hendrickson_lattman_array()
    assert approx_equal(HL_coeffs_cif.data(), HL_coeffs_mtz.data())

  file_name = libtbx.env.find_in_repositories(
    relative_path="phenix_regression/reflection_files/r1wqzsf.mtz",
    test=os.path.isfile)
  if file_name is None:
    print("Skipping r1wqzsf.mtz test: input file not available")
  else:
    mtz_as_cif.run(
      args=[file_name])
    assert os.path.exists("r1wqzsf.reflections.cif")
    miller_arrays = iotbx.cif.reader(
      file_path="r1wqzsf.reflections.cif").as_miller_arrays()
    mtz_arrays = mtz.object(file_name=file_name).as_miller_arrays()
    fobs_cif = get_array_by_label(miller_arrays, '_refln.F_meas_au')
    fobs_mtz = get_array_by_label(mtz_arrays, 'FOBS_N')
    assert approx_equal(fobs_cif.data(), fobs_mtz.data())
    assert approx_equal(fobs_cif.sigmas(), fobs_mtz.sigmas())
    rfree_cif = get_array_by_label(miller_arrays, '_refln.pdbx_r_free_flag')
    rfree_mtz = get_array_by_label(mtz_arrays, 'R-free-flags')
    assert rfree_cif.data().all_eq(rfree_mtz.data())

  file_name = libtbx.env.find_in_repositories(
    relative_path="phenix_regression/reflection_files/ur0013.sf.mtz",
    test=os.path.isfile)
  if file_name is None:
    print("Skipping ur0013.sf.mtz test: input file not available")
  else:
    mtz_as_cif.run(
      args=[file_name])
    assert os.path.exists("ur0013.sf.reflections.cif")
    cif_reader = iotbx.cif.reader(
      file_path="ur0013.sf.reflections.cif")
    miller_arrays = cif_reader.as_miller_arrays()
    cif_object = cif_reader.model()
    assert list(cif_object.keys()) == ['ur0013.sf_neutron']
    mtz_arrays = mtz.object(file_name=file_name).as_miller_arrays()
    iobs_cif = get_array_by_label(miller_arrays, '_refln.pdbx_I_plus')
    iobs_mtz = get_array_by_label(mtz_arrays, 'IOBS_N(+)')
    assert iobs_cif.anomalous_flag()
    assert iobs_mtz.anomalous_flag()
    iobs_cif, iobs_mtz = iobs_cif.common_sets(iobs_mtz, assert_no_singles=True)
    assert approx_equal(iobs_cif.data(), iobs_mtz.data())
    assert approx_equal(iobs_cif.sigmas(), iobs_mtz.sigmas())

  file_name = libtbx.env.find_in_repositories(
    relative_path="phenix_regression/reflection_files/1aba_test.mtz",
    test=os.path.isfile)
  if file_name is None:
    print("Skipping 1aba_test.mtz test: input file not available")
  else:
    mtz_as_cif.run(
      args=[file_name])

def run():
  exercise()
  print("OK")

if __name__ == '__main__':
  run()


 *******************************************************************************


 *******************************************************************************
iotbx/regression/tst_patterson.py

from __future__ import absolute_import, division, print_function
from libtbx import easy_run
import libtbx.load_env
import os

def exercise_simple():
  mtz_file = libtbx.env.find_in_repositories(
    relative_path="phenix_regression/reflection_files/ha_patterson.mtz",
    test=os.path.isfile)
  if (mtz_file is None):
    print("phenix_regression not available, skipping")
    return
  result = easy_run.fully_buffered("cctbx.patterson_map \"%s\"" % mtz_file
    ).raise_if_errors()
  assert (result.return_code == 0)

if (__name__ == "__main__"):
  exercise_simple()
  print("OK")


 *******************************************************************************


 *******************************************************************************
iotbx/regression/tst_pdb_as_cif.py
from __future__ import absolute_import, division, print_function
from libtbx.utils import null_out
from six.moves import cStringIO as StringIO
import os.path
import iotbx.pdb

from iotbx.cli_parser import run_program
from mmtbx.programs import pdb_as_cif

def exercise_01():
  if (os.path.isfile("tst_pdb_as_cif_1.cif")):
    os.remove("tst_pdb_as_cif_1.cif")
  with open("tst_pdb_as_cif_1.pdb", "w") as f:
    f.write("""\
CRYST1   97.470  113.870  196.190  90.00  90.00  90.00 P 21 21 21   16
SCALE1      0.010260  0.000000  0.000000        0.00000
SCALE2      0.000000  0.008782  0.000000        0.00000
SCALE3      0.000000  0.000000  0.005097        0.00000
ATOM      1  N   MET A  43       8.153  31.407  59.548  1.00182.68           N
ATOM      2  CA  MET A  43       8.561  30.228  58.722  1.00182.68           C
ATOM      3  C   MET A  43       9.997  29.817  59.022  1.00182.68           C
ATOM      4  O   MET A  43      10.910  30.123  58.254  1.00182.68           O
ATOM      5  CB  MET A  43       8.435  30.557  57.229  1.00182.68           C
ATOM      6  CG  MET A  43       7.111  30.162  56.605  1.00182.68           C
ATOM      7  SD  MET A  43       6.779  28.394  56.836  1.00182.68           S
ATOM      8  CE  MET A  43       7.824  27.649  55.560  1.00182.68           C
ATOM      9  N   LEU A  44      10.187  29.092  60.119  1.00182.68           N
ATOM     10  CA  LEU A  44      11.515  28.652  60.526  1.00182.68           C
ATOM     11  C   LEU A  44      12.314  27.929  59.481  1.00182.68           C
ATOM     12  O   LEU A  44      11.991  26.807  59.098  1.00182.68           O
ATOM     13  CB  LEU A  44      11.428  27.808  61.775  1.00182.68           C
ATOM     14  CG  LEU A  44      11.367  28.820  62.893  1.00182.68           C
ATOM     15  CD1 LEU A  44      10.820  28.175  64.124  1.00182.68           C
ATOM     16  CD2 LEU A  44      12.755  29.420  63.073  1.00182.68           C
""")
  run_program(program_class=pdb_as_cif.Program,
              args=["tst_pdb_as_cif_1.pdb"],
              logger=null_out(),
              )
  assert os.path.isfile("tst_pdb_as_cif_1.cif")
  cif_in = iotbx.pdb.input("tst_pdb_as_cif_1.cif")
  hierarchy = cif_in.construct_hierarchy()
  if (os.path.isfile("tst_pdb_as_cif_2.cif")):
    os.remove("tst_pdb_as_cif_2.cif")
  with open("tst_pdb_as_cif_2.pdb", "w") as f:
    f.write("""\
CRYST1    1.000    1.000    1.000  90.00  90.00  90.00 P 1
SCALE1      1.000000  0.000000  0.000000        0.00000
SCALE2      0.000000  1.000000  0.000000        0.00000
SCALE3      0.000000  0.000000  1.000000        0.00000
ATOM      1 N    ALA     1      26.216  26.069  22.329  1.00  4.70
ATOM      2 CA   ALA     1      25.368  26.545  21.218  1.00  6.09
ATOM      3 C    ALA     1      26.005  26.154  19.885  1.00 11.13
ATOM      4 O    ALA     1      27.207  25.902  19.835  1.00 16.15
ATOM      5 CB   ALA     1      25.434  28.079  21.272  1.00  4.53
ATOM      6 N    GLY     2      25.198  26.203  18.856  1.00  8.14
ATOM      7 CA   GLY     2      25.677  25.977  17.535  1.00 10.65
ATOM      8 C    GLY     2      26.113  24.580  17.267  1.00  9.83
ATOM      9 O    GLY     2      26.154  23.705  18.108  1.00  9.22
""")
  out = StringIO()
  try:
    run_program(program_class=pdb_as_cif.Program,
                args=["tst_pdb_as_cif_2.pdb"],
                logger=out,
                )
  except Exception as e:
    pass
  if 0:
    assert (out.getvalue() == """\
  Converting tst_pdb_as_cif_2.pdb to mmCIF format.
  Error converting tst_pdb_as_cif_2.pdb to mmCIF format:
    Missing element symbol for 7 atoms.
  """)
  assert not os.path.isfile("tst_pdb_as_cif_2.cif")

def exercise_02():
  if (os.path.isfile("tst_pdb_as_cif_2.cif")):
    os.remove("tst_pdb_as_cif_2.cif")
  with open("tst_pdb_as_cif_2.pdb", "w") as f:
    f.write("""\
CRYST1  209.050  447.220  608.960  90.00  90.00  90.00 P 21 21 21
ATOM  99999  N3    U   367     -23.562  29.366 106.688  1.00135.52      A16S N
ANISOU99999  N3    U   367    20423  14326  16741  -1922  -2828  -1650  A16S N
ATOM  A0000  C4    U   367     -23.357  30.626 106.161  1.00133.22      A16S C
ANISOUA0000  C4    U   367    20015  14160  16442  -1873  -2801  -1645  A16S C
""")
  run_program(program_class=pdb_as_cif.Program,
              args=["tst_pdb_as_cif_2.pdb"],
              logger=null_out(),
              )
  assert os.path.isfile("tst_pdb_as_cif_2.cif")
  with open("tst_pdb_as_cif_2.cif", "r") as inp:
    lines = inp.readlines()
  cntr = 0
  for l in lines:
    l = l.strip()
    # These are for align_columns=True in iotbx.cif.write_whole_cif_file()
    # if(l.startswith("ATOM   99999  N3  .  U  .  367  ?")): cntr+=1
    # if(l.startswith("ATOM  100000  C4  .  U  .  367  ?")): cntr+=1
    # if(l.startswith("99999  N3  .  U  .  367  ?")): cntr+=1
    # if(l.startswith("100000  C4  .  U  .  367  ?")): cntr+=1

    # These are for align_columns=False in iotbx.cif.write_whole_cif_file()
    if(l.startswith("ATOM 1 N3 . U A16S 367 ? ")): cntr+=1
    if(l.startswith("ATOM 2 C4 . U A16S 367 ?")): cntr+=1
    if(l.startswith("1 N3 . U A16S 367 ? ")): cntr+=1
    if(l.startswith("2 C4 . U A16S 367 ?")): cntr+=1
  assert cntr == 4, cntr

if (__name__ == "__main__"):
  import mmtbx.monomer_library.server
  try:
    mon_lib_srv = mmtbx.monomer_library.server.server()
  except mmtbx.monomer_library.server.MonomerLibraryServerError:
    print("Can not initialize monomer_library, skipping tst_pdb_as_cif.")
  else:
    exercise_01()
    exercise_02()
  print("OK")


 *******************************************************************************
