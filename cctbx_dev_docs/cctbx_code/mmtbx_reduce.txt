

 *******************************************************************************
mmtbx/reduce/InteractionGraph.py
##################################################################################
#                Copyright 2021-2022 Richardson Lab at Duke University
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

##################################################################################
# This is a set of functions that implement Reduce's Interaction Graphs.  These are
# functions that produce Boost graphs of Movers, enabling easy determination
# of Cliques (connected components of this graph).

from __future__ import print_function, nested_scopes, generators, division
from __future__ import absolute_import

from boost_adaptbx import graph
import mmtbx.reduce.Movers as Movers
import boost_adaptbx.boost.python as bp
bp.import_ext("mmtbx_probe_ext")
import mmtbx_probe_ext as probeExt

bp.import_ext("mmtbx_reduce_ext")
from mmtbx_reduce_ext import PairsOverlap as _PairsOverlap
from mmtbx_reduce_ext import FindOverlappingMoversAABB as _FindOverlappingMoversAABB
from mmtbx_reduce_ext import AtomMoverLists

def InteractionGraphAllPairs(movers, extraAtomInfoMap, probeRadius = 0.25):
  """Tests for overlap of all possible positions of all movable atoms between each
  pair of Movers in the set of Movers passed in to construct the
  graph of which overlap across all possible orientations of each.

  :param movers: flex array of movers to add to the graph.  Note that this list must
  not be modified after the graph has been constructed because that will change the
  index of its elements, making the graph point to the wrong elements (or to elements
  that no longer exist).
  :param extraAtomInfoMap: probe.ExtraAtomInfoMap that can be used to look
  up the information for atoms whose values need to be changed.  Can be
  obtained by calling mmtbx.probe.Helpers.getExtraAtomInfo().
  :param probeRadius: Radius of the probe to use to determine neighbor contact.
  If it is not set, the default value of 0.25 will be used.
  :returns (1) An undirected Boost graph whose nodes are indices into the movers list
  and whose edges indicate which Movers might overlap in any of their states.  Note that
  the mover list must not be modified after the graph has been constructed because
  that will change the index of its elements, making the graph point to the wrong
  elements (or to elements that no longer exist). (2) An AtomMoverLists class that
  can look up using atom i_seq as the index and returns the list of Movers that the
  atom interacts with; each has at least the Mover that it is a part of and may
  contain additional ones when they overlap.
  """

  # Run the AABB test to get a superset of the list of pairs that we need to check for
  # overlap.  If we try to brute-force all of the Movers against all of the others, it
  # takes too long.
  myGraph = _InteractionGraphAABB(movers, extraAtomInfoMap, probeRadius)

  # List indexed by atom i_seq that returns the list of Movers that atom interacts
  # with.
  atomMoverLists = AtomMoverLists()
  for m in movers:
    coarses = m.CoarsePositions()
    for a in coarses.atoms:
      atomMoverLists.AddAtomMoverEntry(a.i_seq, m)

  # For each pair of movers that are connected by an edge in the graph produced
  # by the AABB algorithm to see if they actually overlap.  If not, remove that edge.
  for e in myGraph.edges():
    sourceMover = myGraph.vertex_label( myGraph.source(e) )
    targetMover = myGraph.vertex_label( myGraph.target(e) )
    if not _PairsOverlap(sourceMover, targetMover,
        extraAtomInfoMap, probeRadius,
        atomMoverLists):
      myGraph.remove_edge( e )

  return myGraph, atomMoverLists

#######################################################################################################
# Internal helper functions defined here

def _InteractionGraphAABB(movers, extraAtomInfoMap, probeRadius = 0.25):
  """Uses the overlap of the axis-aligned bounding boxes (AABBs) of all possible
  positions of all movable atoms in the set of movers passed in to construct the
  graph of which might overlap across all possible orientations of each.  The use
  of bounding boxes makes this an overestimate but its time complexity is linear
  in the product of the number of movers times the number of atoms times the number
  of possible positions for each and quadratic in the number of Movers.

  :param movers: flex array of movers to add to the graph.  Note that this list must
  not be modified after the graph has been constructed because that will change the
  index of its elements, making the graph point to the wrong elements (or to elements
  that no longer exist).
  :param extraAtomInfoMap: probe.ExtraAtomInfoMap that can be used to look
  up the information for atoms whose values need to be changed.  Can be
  obtained by calling mmtbx.probe.Helpers.getExtraAtomInfo().
  :param probeRadius: Radius of the probe to use to determine neighbor contact.
  If it is not set, the default value of 0.25 will be used.
  :returns An undirected Boost graph whose nodes are indices into the movers list
  and whose edges indicate which Movers might overlap in any of their states.  Note that
  the mover list must not be modified after the graph has been constructed because
  that will change the index of its elements, making the graph point to the wrong
  elements (or to elements that no longer exist).
  """

  # Add all of the Movers as nodes in the graph
  # Compute the axis-aligned bounding box for each Mover
  ret = graph.adjacency_list(
        vertex_type = "list",   # List so that deletions do not invalidate iterators and descriptors
        )

  # Find the pairs of indices of Movers that have overlapping AABBs
  pairs = _FindOverlappingMoversAABB(movers, extraAtomInfoMap, probeRadius)

  # Add all of the Movers as nodes in the graph
  verts = []
  for m in movers:
    verts.append(ret.add_vertex(m))

  # For each pair of Movers whose bounding boxes overlap, add an
  # edge to the graph.
  for p in pairs:
    ret.add_edge( vertex1 = verts[p[0]], vertex2 = verts[p[1]])

  return ret

# This function has been moved into C++ for speed. The original Python function
# is below and commented out.
"""Helper function that tells whether any pair of atoms from two Movers overlap.
:param mover1: The first Mover
:param atoms1: Atom list for the first Mover
:param positions1: probe.PositionReturn.positions holding possible positions for each.
:param mover2: The second Mover
:param atoms2: Atom list for the second Mover
:param positions2: probe.PositionReturn.positions holding possible positions for each.
:param extraAtomInfoMap: probe.ExtraAtomInfoMap that can be used to look
up the information for atoms whose values need to be changed.  Can be
obtained by calling mmtbx.probe.Helpers.getExtraAtomInfo().
:param ProbeRad: Probe radius
:param atomMoverSets: Parameter that is modified in place to record all Movers that
a particular atom interacts with.  An entry is created whenever there is overlap
with an atom in another Mover.  Indexed by i_seq number of the atom.
:returns True if a pair of atoms with one from each overlap, False if not.
def _PairsOverlap(mover1, atoms1, positions1,
                  mover2, atoms2, positions2, extraAtomInfoMap, probeRad, atomMoverSets):

  # Construct look-up tables for the radii of each atom to pull these calculations
  # outside of the loops.
  radii1 = []
  for ai1 in range(len(atoms1)):
    radii1.append(extraAtomInfoMap.getMappingFor(atoms1[ai1]).vdwRadius)
  radii2 = []
  for ai2 in range(len(atoms2)):
    radii2.append(extraAtomInfoMap.getMappingFor(atoms2[ai2]).vdwRadius)

  ret = False
  for p1 in positions1:
    for ai1 in range(len(p1)):
      r1 = radii1[ai1]
      x1 = p1[ai1][0]
      y1 = p1[ai1][1]
      z1 = p1[ai1][2]
      limit1 = 2*probeRad + r1
      for p2 in positions2:
        for ai2 in range(len(p2)):
          r2 = radii2[ai2]
          dx = x1 - p2[ai2][0]
          dy = y1 - p2[ai2][1]
          dz = z1 - p2[ai2][2]
          dSquared = dx*dx + dy*dy + dz*dz
          limit = limit1 + r2
          limitSquared = limit*limit
          if dSquared <= limitSquared:
            # Add the opposite Mover to each atom; they interact
            atomMoverSets[atoms1[ai1].i_seq].add(mover2)
            atomMoverSets[atoms2[ai2].i_seq].add(mover1)
            # Set the return value to True but do not quit looking
            # because we need to catalog all of the atomMoverSets
            # interactions, not just the first one found.
            ret = True
  return ret
"""

#######################################################################################################
# Test code and objects below here

from iotbx import pdb
import math
from boost_adaptbx.graph import connected_component_algorithm as cca

def Test():
  """Test function for all functions provided above.
  returns: Empty string on success, string describing the problem on failure.
  """

  # Construct a set of Mover/atoms that will be used to test the routines.  They will all be part of the
  # same residue and they will all have the same unit radius in the extraAtomInfo associated with them.
  # There will be a set of five along the X axis, with one pair overlapping slightly and the others
  # spaced 0.45 units apart so that they will overlap when using a probe radius of 0.25 (diameter 0.5).
  # There will be another one that is obliquely located away from the first such that it will overlap
  # in a bounding-box test but not in a true atom-comparison test for a probe with radius 0.25.  There
  # will be a final one 10 units above the origin.
  rad = 1.0
  probeRad = 0.25
  locs = [ [0.0, 0.0, 0.0], [1.9, 0.0, 0.0] ]
  for i in range(1,4):
    loc = [1.9 + 2.1*i, 0.0, 0.0]
    locs.append(loc)
  delta = 2*rad + 2*probeRad - 0.1
  dist = - delta * math.cos(math.pi/4)
  dist = - delta * math.sin(math.pi/4)
  locs.append([dist, dist, 0.0])
  locs.append([0.0, 0.0, 10.0])

  name = " H  ";
  ag = pdb.hierarchy.atom_group()
  ag.resname = "LYS"
  atoms = pdb.hierarchy.af_shared_atom()
  extras = []
  movers = []
  baseAtom = pdb.hierarchy.atom()
  for i in range(len(locs)):
    a = pdb.hierarchy.atom(parent = ag, other=baseAtom)
    a.name = name
    a.xyz = locs[i]
    atoms.append(a)
    e = probeExt.ExtraAtomInfo(rad)
    extras.append(e)
    # Fix the sequence numbers, which are otherwise all 0
    atoms.reset_i_seq()
    extrasMap = probeExt.ExtraAtomInfoMap(atoms, extras)
    movers.append(Movers.MoverNull(a, extrasMap))

  # Generate a table of parameters and expected results.  The first entry in each row is
  # the probe radius.  The second is the expected number of connected components.
  # The third is the size of the largest connected component.
  _expectedCases = [
    [ 0.0, 5, 3 ],
    [ probeRad, 2, 6 ],
    [ 100, 1, 7 ]
  ]

  # Specify the probe radius and run the test.  Compare the results to what we expect.
  for i, e in enumerate(_expectedCases):
    probeRadius = e[0]
    g = _InteractionGraphAABB(movers, extrasMap, probeRadius)

    # Find the connected components of the graph and compare their counts and maximum size to
    # what is expected.
    components = cca.connected_components( graph = g )
    if len(components) != e[1]:
      return "AABB Expected "+str(e[1])+" components, found "+str(len(components))+" for case "+str(i)
    maxLen = -1
    for c in components:
      if len(c) > maxLen:
        maxLen = len(c)
    if maxLen != e[2]:
      return "AABB Expected max sized component of "+str(e[2])+", found "+str(maxLen)+" for case "+str(i)

  # Generate a table of parameters and expected results.  The first entry in each row is
  # the probe radius.  The second is the expected number of connected components.
  # The third is the size of the largest connected component.
  # The fourth (not present in the AABB table above) is the set of expected sizes of
  # atomMoverSets across all atoms; not one per atom but across all atoms what answers are
  # expected.  The easiest to explain is the 100-radius entry, which should have all atoms interacting
  # with all Movers so the only answer across all atoms is 7.  The 0-radius case has only one pair
  # of overlaps, so only up to 2 Movers per atom.  The middle case has some Movers overlapping with
  # two neighbors, so up to 3 Movers associated with a given atom.
  _expectedCases = [
    # One of the pairs actually does not overlap for the all-pairs test.  Other conditions are the same
    # as the AABB tests.
    [ 0.0, 6, 2, {1,2} ],
    [ probeRad, 2, 6, {1,2,3} ],
    [ 100, 1, 7, {7} ]
  ]

  # Specify the probe radius and run the test.  Compare the results to what we expect.
  for i, e in enumerate(_expectedCases):
    probeRadius = e[0]
    g, am = InteractionGraphAllPairs(movers, extrasMap, probeRadius)

    # Find the connected components of the graph and compare their counts and maximum size to
    # what is expected.
    components = cca.connected_components( graph = g )
    if len(components) != e[1]:
      return "Expected "+str(e[1])+" components, found "+str(len(components))+" for case "+str(i)
    maxLen = -1
    for c in components:
      if len(c) > maxLen:
        maxLen = len(c)
    if maxLen != e[2]:
      return "Expected max sized component of "+str(e[2])+", found "+str(maxLen)+" for case "+str(i)

    # Check atom/Mover overlaps by finding the set of lengths that are present across all atoms.
    lengths = set()
    for a in atoms:
      lengths.add(len(am.GetAtomMoverList(a.i_seq)))
    if lengths != e[3]:
      return "Expected set of overlap counts "+str(e[3])+", found "+str(lengths)+" for case "+str(i)

  return ""

# If we're run on the command line, test our classes and functions.
if __name__ == '__main__':

  ret = Test()
  if len(ret) == 0:
    print('Success!')
  else:
    print(ret)

  assert (len(ret) == 0)


 *******************************************************************************


 *******************************************************************************
mmtbx/reduce/Movers.py
##################################################################################
#                Copyright 2021-2023 Richardson Lab at Duke University
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import print_function, nested_scopes, generators, division
from __future__ import absolute_import
import math
import scitbx.matrix, scitbx.math
from scitbx.array_family import flex
from iotbx import pdb
import mmtbx_probe_ext as probe
import traceback
from mmtbx.probe.Helpers import rvec3, lvec3, dihedralChoicesForRotatableHydrogens
from mmtbx_reduce_ext import RotateAtomDegreesAroundAxisDir, FindPosesFor

##################################################################################
# This is a set of classes that implement Reduce's "Movers".  These are sets of
# atoms that have more than one potential set of locations.
#  - They may have a-priori preferences for some locations over others.
#  - They may have both coarse locations that they test and a set of fine
#    locations around each coarse location.
#  - They may have final tune-up behaviors once their final locations are selected.
#
# There are two basic types of Movers:
#  - Rotator: One or more Hydrogen atoms that have a set of orientations spinning
#    around a common axis.
#  - Flipper: A structure that has pairs of atom groups that have similar densities, such
#    that flipping them across a center axis produces similar density fits.
#    They sometimes have optional hydrogen placements in the atom groups.
#
# All Movers have the following methods, parameters, and return types:
#  - type PositionReturn: (
#       flex<atom> atoms,
#       flex<flex<vec3>> positions,
#       flex<flex<probe.ExtraAtomInfo>> extraInfos,
#       flex<flex<bool>> deleteMes,
#       std::vector<double> preferenceEnergies
#    )
#       The atoms element has a list of all of the atoms to be adjusted.
#       The other elements each have a list of entries, where there is one entry
#     for each set of positions.  For the elements that have a double list, the
#     outer list is per entry and the inner list is per atom in the atoms element,
#     each with a corresponding list index.
#       The positions element has the new location of each atom in each set of positions.
#     This array may be shorter in length than the number of atoms because
#     some Movers do not need to change the position for all atoms (for flips, all atoms
#     are involved in fixup but not moved during optimization).  The index in
#     this array will match the index in the atoms array so the earliest atoms will be
#     changed if a subset is present.
#       The extraInfos element has the new ExtraAtomInfo for each atom in each set of positions.
#     This array may be shorter in length than the number of atoms (and may be empty) because
#     some Movers do not need to change the information for any or all atoms.  The index in
#     this array will match the index in the atoms array so the earliest atoms will be
#     changed if a subset is present.
#       The deleteMes element tells whether each atom in each set of positions should be
#     deleted.  This means that it should be ignored in all calculations and also should be
#     deleted from the model if this configuration is chosen.  This array may be shorter in
#     length than the number of atoms (and may be empty) because some Movers do not need to
#     change the information for any or all atoms.  The index in this array will match the
#     index in the atoms array so the earliest atoms will be deleted if a subset is present.
#       The preferenceEnergies entry holds an additional bias term that should be added to
#     the Probe score for each set of positions before comparing them with each other.
#  - PositionReturn CoarsePositions()
#  - PositionReturn FinePositions(coarseIndex)
#     The coarseIndex indicates the index (0 for the first) of the relevant coarse
#       orientation.
#     The list of atoms returned here must match the list returned for this index
#       by CoarsePositions().
#     The return values are the same as for CoarsePositions and they list potential
#       fine motions around the particular coarse position (not including the position
#       itself).  This function can be used by optimizers that wish to do heavy-weight
#       operations at a coarse resolution and then lightweight operations at a finer
#       scale; other optimizers may choose to ask for all of the fine positions and
#       append them to the coarse positions and globally optimize.
#     Note: Some Movers will return empty arrays.
#  - type FixUpReturn: (
#       flex<atom> atoms,
#       flex<vec3> positions,
#       flex<probe.ExtraAtomInfo> extraInfos,
#       flex<bool> deleteMes
#    )
#       These are lists with one entry per atom telling the same information as the
#     PositionReturn does, but only for a single set of positions.
#  - FixUpReturn FixUp(coarseIndex)
#     The coarseIndex indicates the index (0 for the first) of the relevant coarse
#       orientation that was finally chosen.
#     Note: This function may ask to modify atoms other than the ones reported in the
#       coarse and fine position functions.  This is to enable optimizing bonds
#       for Flippers.  None of these depend on fine index.
#     Note: Some Movers will return empty arrays.  This indicates that no fix-up is
#       needed and the atoms are in their final positions.
#
#  - str PoseDescription: (
#       int coarseIndex,   # Coarse position index
#       int fineIndex      # Fine position index
#       bool fixedUp       # Did we do fixup on Movers that have this?
#    )
#     Returns a human-readible description of the state.  This must have the same
#       number of words in all cases for all Movers to make things easier for a
#       program to parse.
#
# The caller is responsible for moving the specified atoms to their positions,
# modifying the ExtraAtomInfo, and deleting/ignoring them before dong any calculations
# with them.  After selecting the coarse or fine adjustment, they must call FixUp()
# and apply any final changes that it returns.
#
# The InteractionGraph.py script provides functions for determining which pairs of
# Movers have overlaps between movable atoms.

##################################################################################
import boost_adaptbx.boost.python as bp
bp.import_ext("mmtbx_reduce_ext")
from mmtbx_reduce_ext import PositionReturn
#class PositionReturn(object):
#  # Return type from CoarsePosition() and FinePosition() calls.
#  def __init__(self, atoms, positions, extraInfos, deleteMes, preferenceEnergies):
#    self.atoms = atoms
#    self.positions = positions
#    self.extraInfos = extraInfos
#    self.deleteMes = deleteMes
#    self.preferenceEnergies = preferenceEnergies

##################################################################################
class FixUpReturn(object):
  # Return type from FixUp() calls.
  def __init__(self, atoms, positions, extraInfos, deleteMes):
    self.atoms = atoms
    self.positions = positions
    self.extraInfos = extraInfos
    self.deleteMes = deleteMes

##################################################################################
class MoverNull(object):
  '''A trivial Mover that returns a single result atom at a single location.
     Useful as a simple and fast test case for programs that use Movers.
     It also serves as a basic example of how to develop a new Mover.
  '''
  def __init__(self, atom, extraAtomInfoMap):
    """Constructs a MoverNull.
       :param atom: Single atom to be moved.
       :param extraAtomInfoMap: probe.ExtraAtomInfoMap that can be used to look
       up the information for atoms whose values need to be changed.  Can be
       obtained by calling mmtbx.probe.Helpers.getExtraAtomInfo().
    """
    self._atom = atom
    # Make a copy of the extra information so that we can be sure it is not modified
    # elsewhere before we return it.
    self._extraAtomInfo = probe.ExtraAtomInfo(extraAtomInfoMap.getMappingFor(self._atom))
    self._coarsePositions = PositionReturn(
        # Single array of atoms
        [ self._atom ],
        # List of lists of positions.  Must be a list rather than a tuple
        [ [ [ self._atom.xyz[0], self._atom.xyz[1], self._atom.xyz[2] ] ] ],
        # Array of arrays of ExtraAtomInfos
        # Return a copy of our data so that someone won't modify it outside of us
        [ [ probe.ExtraAtomInfo(self._extraAtomInfo) ] ],
        # Array of array of DeleteMes
        [ [ False ] ],
        # Single array of preference energies
        [ 0.0 ]
    )

  def CoarsePositions(self):
    # returns: The original atom at its original position.
    return self._coarsePositions
  def FinePositions(self, coarseIndex):
    # returns: No fine positions for any coarse position.
    return PositionReturn([], [], [], [], [])
  def FixUp(self, coarseIndex):
    # No fixups for any coarse index.
    return FixUpReturn([], [], [], [])
  def PoseDescription(self, coarseIndex, fineIndex, fixedUp):
    if coarseIndex >= len(self.CoarsePositions().positions) or fineIndex is not None and (
        fineIndex > 0 and fineIndex >= len(self.FinePositions(0).positions)):
      return "Unrecognized state . ."
    else:
      return "Original location . ."

##################################################################################
class _MoverRotator(object):
  def __init__(self, atoms, axis, dihedral, offset, coarseRange, coarseStepDegrees = 15.0,
                doFineRotations = True, fineStepDegrees = 1.0,
                preferenceFunction = None, preferredOrientationScale = 1.0):
    """Constructs a Rotator, to be called by a derived class or test program but
       not usually user code.
       A base class for types of Movers that rotate one or more atoms around a single
       axis.  The derived class must determine the initial position for each atom, and
       a preferred-energies function that maps from an angle that is 0 at the initial
       location to an energy.  The range of coarse rotations is also specified, along
       with a flag telling whether fine rotations are allowed.  The coarse step size
       can also be specified, overriding the value from coarseStepDegrees.
       :param atoms: flex array of atoms that will be rotated.  These should be
       placed in one of the preferred orientations if there are any.
       :param axis: flex array with two scitbx::vec3<double> points, the first
       of which is the origin and the second is a vector pointing in the direction
       of the axis of rotation.  Positive rotations will be right-handed rotations
       around this axis.
       :param dihedral: Angle of rotatation in degrees.  Specifies the clockwise
       rotation of the conventional first hydrogen (lowest numbered) in the atoms
       list compared to the atom in the conventional branch three neighbors away.
       The initial rotation for the atoms rotates them back to 0.
       :param offset: Angle of rotation in degrees.  Specifies the desired clockwise
       rotation of the conventional first hydrogen (lowest numbered) in the atoms
       list away from the dihedral.  This is specified separately because we need to
       know it for reporting purposes.  It is added to the negative of the dihedral
       to determine the initial rotation to make for all of the atoms.  It specifies
       the starting orientation (effective 0 degrees) that the coarse and fine steps
       are taken from.
       :param coarseRange: Range in degrees that the atoms can rotate around the axis
       from the starting position.  The range is considered closed on the negative
       end and open on the positive: [-coarseRange..coarseRange).  For example a
       range of 180 will rotate all the way around, from -180 (inclusive) to just
       slightly less than +180.
       :param coarseStepDegrees: The coarse step to take.
       To test only two orientations, doFineRotations should be set
       to False, coarseRange to 180, and coarseStepDegrees to 180.
       :param doFineRotations: Specifies whether fine rotations are allowed for
       this instance.  To test only two orientations, this should be set
       to False, coarseRange to 180, and coarseStepDegrees to 180.
       :param fineStepDegrees: The fine step to take.
       :param preferenceFunction: A function that takes a floating-point
       argument in degrees of rotation about the specified axis and produces
       a floating-point energy value that is multiplied by the value of
       preferredOrientationScale and then added to the energy
       returned for this orientation by CoarsePositions() and FinePositions().
       For the default value of None, no addition is performed.
       :param preferredOrientationScale: How much to scale the preferred-orientation
       energy by before adding it to the total.
    """
    self._atoms = atoms
    self._axis = axis
    self._coarseRange = coarseRange
    self._coarseStepDegrees = coarseStepDegrees
    self._doFineRotations = doFineRotations
    self._preferenceFunction = preferenceFunction
    self._fineStepDegrees = fineStepDegrees
    self._preferredOrientationScale = preferredOrientationScale
    self._offset = offset

    # Rotate the atoms so that the conventional atom is at the expected initial
    # orientation before other rotations are made.  This rotates them around the axis by an angle that
    # is the sum of the offset and the dihedral, placing the conventional atom at the
    # specified offset from a 0 dihedral angle.  The other atoms maintain their relative rotations
    # with the conventional atom.
    for atom in atoms:
      atom.xyz = RotateAtomDegreesAroundAxisDir(axis[0], axis[1], atom, offset + dihedral)

    # Make a list of coarse angles to try based on the coarse range (inclusive
    # for negative and exclusive for positive) and the step size.  We always
    # try 0 degrees.
    # Store the angles for use by CoarsePositions() and FinePositions()
    self._coarseAngles = [0.0]
    curStep = self._coarseStepDegrees
    while curStep <= self._coarseRange:
      # The interval is closed on the left, so we place
      self._coarseAngles.append(-curStep)
      # We only place on the right if we're strictly less than because
      # the interval is open on the right.
      if curStep < self._coarseRange:
        self._coarseAngles.append(curStep)
      curStep += self._coarseStepDegrees

    # Make a list of fine angles to try to cover half the coarse step size (inclusive
    # for negative and exclusive for positive) using the fine step size.  We never
    # try +0 degrees because that is the location of the coarse rotation.
    self._fineAngles = []
    curStep = self._fineStepDegrees
    fineRange = self._coarseStepDegrees / 2
    while curStep <= fineRange:
      # The interval is closed on the left, so we place
      self._fineAngles.append(-curStep)
      # We only place on the right if we're strictly less than because
      # the interval is open on the right.
      if curStep < fineRange:
        self._fineAngles.append(curStep)
      curStep += self._fineStepDegrees

    # Coarse positions
    self._coarsePositions = self._computeCoarsePositions()

    # Fine positions, one list per coarse index
    self._finePositions = self._computeFinePositions()

  def _preferencesFor(self, angles, scale):
    """Return the preference energies for the specified angles, scaled by the scale.
       :param angles: List of angles to compute the preferences at.
       :param scale: Scale factor to apply to the resulting energy function that is
       evaluated at the angles.
       :returns Energy function evaluated at the angles multiplied by the scale factor.
       If there is no energy function all entries are 0.0.
    """
    preferences = [0.0] * len(angles)
    if self._preferenceFunction is not None:
      for i, a in enumerate(angles):
        preferences[i] = self._preferenceFunction(a) * scale
    return preferences

  def _posesFor(self, angles):
    """Return the atom poses for the specified angles.
       :param angles: List of angles to compute the poses at.
       :returns List of flex.vec3_double entries, where each entry records the
       positions of all atoms when rotated about the axis by the associated angle.
       There is one entry in the list for each angle.
    """
    return FindPosesFor(angles, self._atoms, self._axis[0], self._axis[1])

  def _computeCoarsePositions(self):
    return PositionReturn(self._atoms,
      self._posesFor(self._coarseAngles),
      [ [] ]  * len(self._coarseAngles),
      [ [] ]  * len(self._coarseAngles),
      self._preferencesFor(self._coarseAngles, self._preferredOrientationScale))

  def CoarsePositions(self):

    # Return the atoms, coarse-angle poses, and coarse-angle preferences
    return self._coarsePositions

  def _computeFinePositions(self):
    ret = []
    for coarseIndex in range(len(self._coarsePositions.positions)):

      if not self._doFineRotations:
        # No fine positions for any coarse position.
        ret.append(PositionReturn([], [], [], [], []))
        continue

      # We add the range of values to the coarse angle we're starting with to provide
      # the list of fine angles to try.
      angles = []
      try:
        ca = self._coarseAngles[coarseIndex]
      except Exception as e:
        raise ValueError("MoverRotator.FinePositions(): Bad coarseIndex: "+str(e))
      for fa in self._fineAngles:
        angle = fa + ca
        angles.append(angle)

      # Return the atoms and poses along with the preferences.
      ret.append(PositionReturn(self._atoms,
        self._posesFor(angles),
        [ [] ] * len(angles),
        [ [] ] * len(angles),
        self._preferencesFor(angles, self._preferredOrientationScale))
        )
      continue

    return ret

  def FinePositions(self, coarseIndex):
    return self._finePositions[coarseIndex]

  def FixUp(self, coarseIndex):
    # No fixups for any coarse index.
    return FixUpReturn([], [], [], [])

  def PoseDescription(self, coarseIndex, fineIndex, fixedUp):
    if coarseIndex >= len(self.CoarsePositions().positions) or fineIndex is not None and (
        fineIndex > 0 and fineIndex >= len(self.FinePositions(0).positions)):
      return "Unrecognized state . ."
    else:
      fineOffset = 0
      if fineIndex is not None and fineIndex >= 0:
        fineOffset = self._fineAngles[fineIndex]
      angle = self._offset + self._coarseAngles[coarseIndex] + fineOffset
      while angle > 180: angle -= 360
      while angle < -180: angle += 360
      return "Angle {:.1f} deg .".format(angle)

##################################################################################
class MoverSingleHydrogenRotator(_MoverRotator):
  def __init__(self, atom, bondedNeighborLists, extraAtomInfoMap,
                hParameters, potentialAcceptors = [],
                potentialTouches = [],
                coarseStepDegrees = 10.0,
                fineStepDegrees = 1.0, preferredOrientationScale = 1.0):
    """ A Mover that rotates a single Hydrogen around an axis from its bonded partner
       to the single bonded partner of its partner.  This is designed for use with OH,
       SH, and SeH configurations.  For partner-partner atoms that are bonded to a
       tetrahedron, the starting orientation is aligned between two of the edges of
       the tetrahedron.  For partner-partner atoms that are bonded to two atoms, the
       starting orientation is in the plane of these atoms and the partner-partner atom.
       :param atom: Hydrogen atom that will be rotated.  It must be bonded to a single
       atom, and that atom must also be bonded to a single other atom.  NOTE: As a side
       effect, this Hydrogen is immediately rotated to lie either in the plane of the two
       friends of the partner atom or to be between two of friends if there are three.
       :param bondedNeighborLists: A dictionary that contains an entry for each atom in the
       structure that the atom from the first parameter interacts with that lists all of the
       bonded atoms.  Can be obtained by calling probe.Helpers.getBondedNeighborLists().
       :param extraAtomInfoMap: probe.ExtraAtomInfoMap that can be used to look
       up the information for atoms.  Can be obtained by calling
       mmtbx.probe.Helpers.getExtraAtomInfo().
       :param hParameters: List indexed by sequence ID that stores the riding
       coefficients for hydrogens that have associated dihedral angles.  This can be
       obtained by calling model.setup_riding_h_manager() and then model.get_riding_h_manager().
       :param potentialAcceptors: A flex array of atoms that are nearby potential acceptors.
       Coarse orientations are added that aim the hydrogen in the direction of these potential
       partners.
       :param potentialTouches: A flex array of atoms that are nearby potential touches/clashes.
       :param coarseStepDegrees: The coarse step to take.
       :param fineStepDegrees: The fine step to take.
       :param preferredOrientationScale: How much to scale the preferred-orientation
       energy by before adding it to the total.
    """
    # @todo All callers and tests

    # Check the conditions to make sure we've been called with a valid atom.  This is a hydrogen with
    # a single bonded neighbor that has a single other bonded partner that has 2-3 other bonded friends.
    # Find the friends bonded to the partner besides the neighbor, which will be used to
    # determine the initial orientation for the hydrogen.
    if atom.element != "H":
      raise ValueError("MoverSingleHydrogenRotator(): Atom is not a hydrogen")
    neighbors = bondedNeighborLists[atom]
    if len(neighbors) != 1:
      raise ValueError("MoverSingleHydrogenRotator(): Atom does not have a single bonded neighbor")
    neighbor = neighbors[0]
    partners = bondedNeighborLists[neighbor]
    if len(partners) != 2:  # Me and one other
      raise ValueError("MoverSingleHydrogenRotator(): Atom does not have a single bonded neighbor's neighbor")
    partner = partners[0]
    if partner.i_seq == atom.i_seq:
      partner = partners[1]
    bonded = bondedNeighborLists[partner]
    friends = []
    for b in bonded:
      if b.i_seq != neighbor.i_seq:
        friends.append(b)

    # Determine the preference function (180 or 120) based on friends bonding structure
    # NOTE: We replace the preferenceFunction with None below to match original reduce
    # behavior. We leave the math in here so that if we later decide to have a preference
    # it will be correctly determined based on the number of neighbors.
    # @todo Consider parameterizing the magic constant of 0.1 for the preference magnitude
    if len(friends) == 2:
      # There are two neighbors, so our function repeats every 180 degrees
      def preferenceFunction(degrees): return 0.1 + 0.1 * math.cos(degrees * (math.pi/180) * (360/180))
    elif len(friends) == 3:
      # There are three neighbors, so our function repeats every 120 degrees
      def preferenceFunction(degrees): return 0.1 + 0.1 * math.cos(degrees * (math.pi/180) * (360/120))
    else:
      raise ValueError("MoverSingleHydrogenRotator(): Atom's bonded neighbor's neighbor does not have 2-3 other bonds "+
      "it has "+str(len(friends)))
    # Original Reduce did not have a preference, so we remove that here.
    preferenceFunction = None

    # Determine the axis to rotate around, which starts at the partner atom and points at the neighbor.
    normal = (rvec3(neighbor.xyz) - rvec3(partner.xyz)).normalize()
    axis = flex.vec3_double([partner.xyz, normal])

    # Make a list that contains the hydrogen and its bonded neighbor so that its neighbor will
    # be included in energy calculations.  The neighbor will be rotating about an axis that
    # includes it, so will not be moved.
    atoms = [ atom, neighbor ]

    # Move the atom so that it is in one of the preferred locations.  The preferred location depends on
    # whether there are two or three friends, it wants to be in the plane if there are two of them and it
    # wants to be between two edges if there are three.  It turns out that rotating it to point away from
    # the conventional-branch friend works in both of those cases.
    conventionalH, conventionalFriend = dihedralChoicesForRotatableHydrogens(atoms,
      hParameters, friends)
    sites = [ conventionalH.xyz, partner.xyz, neighbor.xyz, conventionalFriend.xyz ]
    dihedral = scitbx.math.dihedral_angle(sites=sites, deg=True)
    offset = 180

    # Construct our parent class, which will do all of the actual work based on our inputs.
    _MoverRotator.__init__(self, atoms, axis, dihedral, offset, 180, coarseStepDegrees = coarseStepDegrees,
      fineStepDegrees = fineStepDegrees, preferenceFunction = preferenceFunction,
      preferredOrientationScale = preferredOrientationScale)

    # Now add orientations that point in the direction of the potential acceptors.
    # Then select from the original angles the one that has the best contact with
    # any touching atoms that is at least the coarse step size away from pointing
    # towards an acceptor.
    # We replace the original coarse angles with this set of 1+ angles to reduce the
    # number of angles to check and to ensure that we always check potential acceptors.

    ###########################
    # Helper utility function to sort atoms consistently from run to run so that we get
    # the same ordering on coarse angles.
    def atomID(a):
      # Return the ID of the atom, which includes its chain, residue name,
      # residue number, atom name, and alternate separated by spaces. This
      # is used to sort the atoms. This must work in the case where we have
      # test atoms that are not completely fleshed out.
      try:
        return ( a.parent().parent().parent().id + a.parent().resname +
          str(a.parent().parent().resseq_as_int()) + a.name + a.parent().altloc )
      except Exception:
        return ""
    #
    ###########################

    # Compute the dihedral angle from the Hydrogen to each potential acceptor through
    # the partner and neighbor.  This is the amount to rotate the hydrogen by.
    # Sort these so that we get the same order each time the program is run.
    acceptorAngles = []
    for a in sorted(potentialAcceptors, key=lambda x:atomID(x)):
      sites = [ atom.xyz, partner.xyz, neighbor.xyz, a.xyz ]
      degrees = scitbx.math.dihedral_angle(sites=sites, deg=True)
      # The degrees can be None in degenerate cases.  We avoid adding an entry in that case.
      # The atom will have been placed in the correct initial orientation by the _MoverRotator
      # constructor, so our dihedral measurement here is with respect to that new location.
      # This means that we merely have to add the degrees offset to its current rotation.
      if degrees is not None:
        acceptorAngles.append(degrees)

    # Find the coarse angle that has the least best contact with potential touches
    # which may also be one of the acceptors (for a weak hydrogen bond, the score
    # can be better for a touch than for an overlap).
    # This is the one whose gap is closest to 0.
    bestTouchAngle = 0
    bestTouchGap = 1e100
    ra = extraAtomInfoMap.getMappingFor(atom).vdwRadius
    for i, ang in enumerate(self._coarseAngles):
      # Find minimum gap with clashing atoms at this angle. This number is
      # negative when there is a clash. It reports the atom that we're most
      # in contact with at this angle.
      minGap = 1e100
      for pt in potentialTouches:
        rt = extraAtomInfoMap.getMappingFor(pt).vdwRadius
        # Measure from the first atom's position (the Hydrogen) at this position to the potential touch
        distance = (rvec3(self._coarsePositions.positions[i][0]) - rvec3(pt.xyz)).length()
        gap = distance - (ra + rt)
        if gap < minGap:
          minGap = gap
      # Find the minimum gap distance that is closest to zero, either
      # above or below zero. This is the one with the best just-touch
      # value.
      if abs(minGap) < bestTouchGap:
        bestTouchGap = abs(minGap)
        bestTouchAngle = ang

    # Check every coarse angle to see whether it is at least 45 degrees away from
    # any of the acceptor angles or the best touch angle.  If it is, then we add
    # it to the list of coarse angles to try. This ensures that we try at least
    # sparsely in all directions.

    sofar = [bestTouchAngle]
    sofar.extend(acceptorAngles)
    for ang in self._coarseAngles:
      minAng = 360
      for a in sofar:
        diff = abs(a - ang)
        if diff < minAng:
          minAng = diff
      if minAng >= 45:
        sofar.append(ang)

    # Replace the coarse angles with the ones that we have found.
    self._coarseAngles = sofar

    # Recompute the coarse and fine positions given the new angles we want to test
    self._coarsePositions = self._computeCoarsePositions()
    self._finePositions = self._computeFinePositions()

##################################################################################
class MoverNH3Rotator(_MoverRotator):
  def __init__(self, atom, bondedNeighborLists, hParameters, coarseStepDegrees = 15.0,
                fineStepDegrees = 1.0, preferredOrientationScale = 1.0):
    """ A Mover that rotates three Hydrogens around an axis from their bonded Nitrogen neighbor
       to the single bonded partner of its partner.  This is designed for use with NH3+,
       whose partner-partner atoms are bonded to a tetrahedron (two Carbons and a Hydrogen)
       of friends.
       The starting orientation has one of the Hydrogens aligned between two of the edges of
       the tetrahedron.
       :param atom: Nitrogen atom bonded to the three Hydrogens that will be rotated.
       It must be bonded to three Hydrogens and a single other
       atom, and the other atom must be bonded to three other atoms.  NOTE: As a side
       effect, the Hydrogens are immediately rotated to lie between two of the friends.
       :param bondedNeighborLists: A dictionary that contains an entry for each atom in the
       structure that the atom from the first parameter interacts with that lists all of the
       bonded atoms.  Can be obtained by calling probe.Helpers.getBondedNeighborLists().
       the value.
       :param hParameters: List indexed by sequence ID that stores the riding
       coefficients for hydrogens that have associated dihedral angles.  This can be
       obtained by calling model.setup_riding_h_manager() and then model.get_riding_h_manager().
       :param fineStepDegrees: The fine step to take.
       :param preferredOrientationScale: How much to scale the preferred-orientation
       energy by before adding it to the total.
    """

    # The Nitrogen is the neighbor in these calculations, making this code symmetric with the other
    # class code.
    neighbor = atom

    # Check the conditions to make sure we've been called with a valid atom.  This is a Nitrogen with
    # three hydrogens bonded and a single bonded neighbor that has 3 other bonded friends.
    # Find the friends bonded to the partner besides the neighbor, which will be used to
    # determine the initial orientation for the hydrogens.
    if neighbor.element != "N":
      raise ValueError("MoverNH3Rotator(): atom is not a Nitrogen")
    partners = bondedNeighborLists[neighbor]
    if len(partners) != 4:
      raise ValueError("MoverNH3Rotator(): atom does not have four bonded neighbors")
    hydrogens = []
    for a in partners:
      if a.element_is_hydrogen():
        hydrogens.append(a)
      else:
        partner = a
    if len(hydrogens) != 3:
      raise ValueError("MoverNH3Rotator(): atom does not have three bonded hydrogens")
    bonded = bondedNeighborLists[partner]
    friends = []
    for b in bonded:
      if b.i_seq != neighbor.i_seq:
        friends.append(b)
    if len(friends) < 3:
      raise ValueError("MoverNH3Rotator(): Partner does not have at least three bonded friends")

    preferenceFunction = None

    # If we have exactly three neighbors, then we set a preference function that prefers
    # the staggered orientation. If there are more, we just leave things alone.
    if len(friends) == 3:

      # Set the preference function to prefer 120-degree rotations away from the starting location.
      # @todo Consider parameterizing the magic constant of 0.1 for the preference magnitude
      # (for example, we might use preferredOrientationScale for this and not set a separate one?)
      def preferenceFunction(degrees): return 0.1 + 0.1 * math.cos(degrees * (math.pi/180) * (360/120))

    # Determine the axis to rotate around, which starts at the partner and points at the neighbor.
    normal = (rvec3(neighbor.xyz) - rvec3(partner.xyz)).normalize()
    axis = flex.vec3_double([partner.xyz, normal])

    # Move the Hydrogens so that they are in one of the preferred locations by rotating the
    # conventional one of them to point away from the conventional one of the friends.
    conventionalH, conventionalFriend = dihedralChoicesForRotatableHydrogens(hydrogens,
      hParameters, friends)
    sites = [ conventionalH.xyz, partner.xyz, neighbor.xyz, conventionalFriend.xyz ]
    dihedral = scitbx.math.dihedral_angle(sites=sites, deg=True)
    offset = 180

    # Make a list that contains the hydrogens and their bonded neighbor so that the neighbor will
    # be included in energy calculations.  The neighbor will be rotating about an axis that
    # includes it, so will not be moved.
    atoms = [ neighbor ]
    atoms.extend(hydrogens)

    # Construct our parent class, which will do all of the actual work based on our inputs.
    _MoverRotator.__init__(self, atoms, axis, dihedral, offset, 60, coarseStepDegrees,
      fineStepDegrees = fineStepDegrees, preferenceFunction = preferenceFunction,
      preferredOrientationScale = preferredOrientationScale)

##################################################################################
class MoverAromaticMethylRotator(_MoverRotator):
  def __init__(self, atom, bondedNeighborLists, hParameters):
    """ A Mover that rotates three Hydrogens around an axis from their bonded Carbon neighbor
       to the single bonded partner of its partner.  This is designed for use with Aromatic
       CH3 (Methly) groups, whose partner-partner atoms are bonded to an aromatic ring, having
       two friends.
       The starting orientation has one of the Hydrogens pointing away from the plane of the ring.
       The only other preferred orientation is having that hydrogen point out the other side
       of the ring, so we only do 180-degree coarse and no fine rotation.
       :param atom: Carbon atom bonded to the three Hydrogens that will be rotated.
       It must be bonded to three Hydrogens and a single other
       atom, and the other atom must be bonded to two other atoms.  NOTE: As a side
       effect, the Hydrogens are immediately rotated to lie perpendicular to the friends.
       :param bondedNeighborLists: A dictionary that contains an entry for each atom in the
       structure that the atom from the first parameter interacts with that lists all of the
       bonded atoms.  Can be obtained by calling probe.Helpers.getBondedNeighborLists().
       :param hParameters: List indexed by sequence ID that stores the riding
       coefficients for hydrogens that have associated dihedral angles.  This can be
       obtained by calling model.setup_riding_h_manager() and then model.get_riding_h_manager().
    """

    # The Carbon is the neighbor in these calculations, making this code symmetric with the other
    # class code.
    neighbor = atom

    # Check the conditions to make sure we've been called with a valid atom.  This is a Carbon with
    # three hydrogens bonded and a single bonded neighbor that has 2 other bonded friends.
    # Find the friends bonded to the partner besides the neighbor, which will be used to
    # determine the initial orientation for the hydrogens.
    if neighbor.element != "C":
      raise ValueError("MoverAromaticMethylRotator(): atom is not a Carbon")
    partners = bondedNeighborLists[neighbor]
    if len(partners) != 4:
      raise ValueError("MoverAromaticMethylRotator(): atom does not have four bonded neighbors")
    hydrogens = []
    for a in partners:
      if a.element_is_hydrogen():
        hydrogens.append(a)
      else:
        partner = a
    if len(hydrogens) != 3:
      raise ValueError("MoverAromaticMethylRotator(): atom does not have three bonded hydrogens")
    bonded = bondedNeighborLists[partner]
    friends = []
    for b in bonded:
      if b.i_seq != neighbor.i_seq:
        friends.append(b)
    if len(friends) != 2:
      raise ValueError("MoverAromaticMethylRotator(): Partner does not have two bonded friends")

    # Determine the axis to rotate around, which starts at the partner and points at the neighbor.
    normal = (rvec3(neighbor.xyz) - rvec3(partner.xyz)).normalize()
    axis = flex.vec3_double([partner.xyz, normal])

    # Move the Hydrogens so that they are in one of the preferred locations by rotating the
    # conventional one of them to point away from the conventional one of the friends plus 90 degrees.
    conventionalH, conventionalFriend = dihedralChoicesForRotatableHydrogens(hydrogens,
      hParameters, friends)
    sites = [ conventionalH.xyz, partner.xyz, neighbor.xyz, conventionalFriend.xyz ]
    dihedral = scitbx.math.dihedral_angle(sites=sites, deg=True)
    offset = 180 + 90

    # Make a list that contains the hydrogens and their bonded neighbor so that the neighbor will
    # be included in energy calculations.  The neighbor will be rotating about an axis that
    # includes it, so will not be moved.
    atoms = [ neighbor ]
    atoms.extend(hydrogens)

    # Construct our parent class, which will do all of the actual work based on our inputs.
    # We have a coarse step size of 180 degrees and a range of 180 degrees and do not
    # allow fine rotations.
    _MoverRotator.__init__(self, atoms, axis, dihedral, offset, 180, 180, doFineRotations = False)

##################################################################################
class MoverTetrahedralMethylRotator(_MoverRotator):
  def __init__(self, atom, bondedNeighborLists, hParameters, coarseStepDegrees = 15.0,
                  fineStepDegrees = 1.0, preferredOrientationScale = 1.0):
    """ A Mover that rotates three Hydrogens around an axis from their bonded Carbon neighbor
       to the single bonded partner of its partner.  This is designed for use with tetrahedral
       partners whose partner-partner atoms are bonded to three friends but can also be used
       with Methyl's attached to partners with a single other bond like the S in MET.
       The starting orientation has the Hydrogens pointing between the side of the tetrahedron.
       It can rotate to any angle to optimize for hydrogen bonds.
       Note: Reduce does not normally rotate these groups because it is not worth the computational
       cost to do so (and because this can mask mis-placed atoms by forming spurious hydrogen
       bonds), but it will construct them so that they will be aligned staggered to the
       tetrahedron.
       Construct these in Reduce so that they will be staggered but do not optimize them.
       :param atom: Carbon atom bonded to the three Hydrogens that will be rotated.
       It must be bonded to three Hydrogens and a single other
       atom, and the other atom must be bonded to three other atoms.  NOTE: As a side
       effect, the Hydrogens are immediately rotated to lie staggered.
       :param bondedNeighborLists: A dictionary that contains an entry for each atom in the
       structure that the atom from the first parameter interacts with that lists all of the
       bonded atoms.  Can be obtained by calling probe.Helpers.getBondedNeighborLists().
       :param hParameters: List indexed by sequence ID that stores the riding
       coefficients for hydrogens that have associated dihedral angles.  This can be
       obtained by calling model.setup_riding_h_manager() and then model.get_riding_h_manager().
       :param coarseStepDegrees: The coarse step to take.
       :param fineStepDegrees: The fine step to take.
       :param preferredOrientationScale: How much to scale the preferred-orientation
       energy by before adding it to the total.
    """

    # The Carbon is the neighbor in these calculations, making this code symmetric with the other
    # class code.
    neighbor = atom

    # Check the conditions to make sure we've been called with a valid atom.  This is a Carbon with
    # three hydrogens bonded and a single bonded neighbor that has 2 other bonded friends.
    # Find the friends bonded to the partner besides the neighbor, which will be used to
    # determine the initial orientation for the hydrogens.
    if neighbor.element != "C":
      raise ValueError("MoverTetrahedralMethylRotator(): atom is not a Carbon")
    partners = bondedNeighborLists[neighbor]
    if len(partners) != 4:
      raise ValueError("MoverTetrahedralMethylRotator(): atom does not have four bonded neighbors")
    hydrogens = []
    for a in partners:
      if a.element_is_hydrogen():
        hydrogens.append(a)
      else:
        partner = a
    if len(hydrogens) != 3:
      raise ValueError("MoverTetrahedralMethylRotator(): atom does not have three bonded hydrogens")
    bonded = bondedNeighborLists[partner]
    friends = []
    for b in bonded:
      if b.i_seq != neighbor.i_seq:
        friends.append(b)
    if len(friends) != 1 and len(friends) != 3:
      raise ValueError("MoverTetrahedralMethylRotator(): Partner does not have one or three bonded friends")

    # Determine the axis to rotate around, which starts at the partner and points at the neighbor.
    normal = (rvec3(neighbor.xyz) - rvec3(partner.xyz)).normalize()
    axis = flex.vec3_double([partner.xyz, normal])

    # Set the preference function to like 120-degree rotations away from the starting location.
    # @todo Consider parameterizing the magic constant of 0.1 for the preference magnitude
    def preferenceFunction(degrees): return 0.1 + 0.1 * math.cos(degrees * (math.pi/180) * (360/120))

    # Move the Hydrogens so that they are in one of the preferred locations by rotating the
    # conventional one of them to point away from the conventional one of the friends.
    conventionalH, conventionalFriend = dihedralChoicesForRotatableHydrogens(hydrogens,
      hParameters, friends)
    sites = [ conventionalH.xyz, partner.xyz, neighbor.xyz, conventionalFriend.xyz ]
    dihedral = scitbx.math.dihedral_angle(sites=sites, deg=True)
    offset = 180

    # Make a list that contains the hydrogens and their bonded neighbor so that the neighbor will
    # be included in energy calculations.  The neighbor will be rotating about an axis that
    # includes it, so will not be moved.
    atoms = [ neighbor ]
    atoms.extend(hydrogens)

    # Construct our parent class, which will do all of the actual work based on our inputs.
    _MoverRotator.__init__(self, atoms, axis, dihedral, offset, 180, fineStepDegrees = fineStepDegrees,
      preferenceFunction = preferenceFunction,
      preferredOrientationScale = preferredOrientationScale)

##################################################################################
class MoverAmideFlip(object):
  def __init__(self, nh2Atom, caAtomName, bondedNeighborLists, nonFlipPreference):
    """Constructs a Mover that will handle flipping an NH2 with an O, both of which
       are attached to the same Carbon atom (and each of which has no other bonds).
       This Mover will move the hydrogens so that they are located at +/-120 degrees from the
       Carbon-Oxygen bond in the plane of the Nitrogen, Carbon, and Oxygen and at the same
       distance from the Nitrogen as at least one of them started out.
       This Mover uses a simple swap of the center positions of the heavy atoms (with
       repositioning of the Hydrogens to lie in the plane with the other three atoms)
       for its testing, but during FixUp it adjusts the bond lengths of the Oxygen
       and the Nitrogen; per Protein Science Vol 27:293-315.
       This handles flips for Asn and Gln.
       :param nh2Atom: Nitrogen atom that is attached to two Hydrogens.
       :param ca2AtomName: Name of the Alpha Carbon for the amino acid -- the atom around which the
       rigid body is rotated for the final docking motion.  All atoms linked to before
       this one is reached will be included in the list of movable atoms -- there is one
       more of these for Gln than for Asn.
       :param bondedNeighborLists: A dictionary that contains an entry for each atom in the
       structure that the atom from the first parameter interacts with that lists all of the
       bonded atoms.  Can be obtained by calling probe.Helpers.getBondedNeighborLists().
       :param nonFlipPreference: Score amount by which the original orientation is preferred
       over the flipped orientation.  This will bias things so that the flipped orientation
       is not chosen unless it is this much better than the original.
    """

    # Store away our constructor arguments that we need for later.
    self._nonFlipPreference = nonFlipPreference

    # Verify that we've been run on a valid structure and get a list of all of the
    # atoms up to and including the pivot atom.
    if nh2Atom.element != "N":
      raise ValueError("MoverAmideFlip(): nh2Atom is not a Nitrogen")
    partners = bondedNeighborLists[nh2Atom]
    if len(partners) != 3:
      raise ValueError("MoverAmideFlip(): nh2Atom does not have three bonded neighbors")
    nh2Hydrogens = []
    hinge = None
    for a in partners:
      if a.element_is_hydrogen():
        nh2Hydrogens.append(a)
      else:
        hinge = a
    if len(nh2Hydrogens) != 2:
      raise ValueError("MoverAmideFlip(): nh2Atom does not have two bonded hydrogens")
    if hinge is None:
      raise ValueError("MoverAmideFlip(): nh2Atom does not have bonded (hinge) Carbon friend")

    bonded = bondedNeighborLists[hinge]
    oyxgen = None
    pivot = None
    for b in bonded:
      if b.element == "O":
        oxygen = b
      elif b.element == "C":
        pivot = b
    if pivot is None:
      raise ValueError("MoverAmideFlip(): Hinge does not have bonded (pivot) Carbon friend")
    if oxygen is None:
      raise ValueError("MoverAmideFlip(): Hinge does not have bonded oxygen friend")
    if len(bondedNeighborLists[oxygen]) != 1:
      raise ValueError("MoverAmideFlip(): Oxygen has more than one bonded neighbor")
    self._atoms = [ nh2Hydrogens[0], nh2Hydrogens[1], nh2Atom, oxygen, hinge, pivot ]

    # Find any linking atoms between the pivot atom and the Alpha Carbon and add them to the list.
    # Also add hydrogens that are bound to the pivot and linker atoms.
    linkers = []
    prevID = hinge.i_seq
    foundAlpha = False
    cur = pivot
    linkerHydrogens = []
    while not foundAlpha:
      bonded = bondedNeighborLists[cur]
      link = None
      if len(bonded) != 4:
        raise ValueError("MoverAmideFlip(): Linker chain has an element with other than four bonds")
      for b in bonded:
        if b.i_seq == prevID:
          continue
        elif b.element == "C":
          link = b
        elif b.element_is_hydrogen():
          linkerHydrogens.append(b)
      if link is None:
        raise ValueError("MoverAmideFlip(): Did not find Carbon in linker chain step")
      if link.name.strip().upper() == caAtomName.strip().upper():
        caAtom = link
        foundAlpha = True
      else:
        linkers.append(link)
        prevID = cur.i_seq
        cur = link
    if len(linkerHydrogens) != 2*(len(linkers)+1):
      raise ValueError("MoverAmideFlip(): Linker carbons do not have two Hydrogens each: "+
        str(len(linkers))+","+str(len(linkerHydrogens)))
    self._atoms.extend(linkers)
    self._atoms.extend(linkerHydrogens)

    #########################
    # Compute the original positions for the Hydrogens such that they are at the same distance from
    # the Nitrogen as one of them started out and located at +/-120 degrees from the
    # Carbon-Nitrogen bond in the plane of the Nitrogen, Carbon, and Oxygen. The first one should
    # point back towards the mainchain and the second more towards the Oxygen.
    # @todo This assumes that all placement is done like Hydrogenate does, where the first-listed
    # atom is the lower-numbered one.
    cToN = lvec3(nh2Atom.xyz) - lvec3(hinge.xyz)
    cToO = rvec3(oxygen.xyz) - rvec3(hinge.xyz)

    # Normal to the plane containing Nitrogen, Carbon, and Oxygen
    normal = lvec3(scitbx.matrix.cross_product_matrix(cToN) * cToO).normalize()

    hBond0Len = (rvec3(nh2Hydrogens[0].xyz) - rvec3(nh2Atom.xyz)).length()
    hBond1Len = (rvec3(nh2Hydrogens[1].xyz) - rvec3(nh2Atom.xyz)).length()
    nh2Hydrogens[0].xyz = lvec3(nh2Atom.xyz) + ((-cToN.normalize()) * hBond0Len).rotate_around_origin(normal, 120 * math.pi/180)
    nh2Hydrogens[1].xyz = lvec3(nh2Atom.xyz) + ((-cToN.normalize()) * hBond1Len).rotate_around_origin(normal,-120 * math.pi/180)

    #########################
    # Compute the new positions for the Hydrogens such that they are at the same distance from
    # the Oxygen as one of them is from the Nitrogen and located at +/-120 degrees from the
    # Carbon-Oxygen bond in the plane of the Nitrogen, Carbon, and Oxygen.
    cToO = lvec3(oxygen.xyz) - lvec3(hinge.xyz)
    cToN = rvec3(nh2Atom.xyz) - rvec3(hinge.xyz)

    # Normal to the plane containing Nitrogen, Carbon, and Oxygen
    normal = lvec3(scitbx.matrix.cross_product_matrix(cToO) * cToN).normalize()

    hBond0Len = (rvec3(nh2Hydrogens[0].xyz) - rvec3(nh2Atom.xyz)).length()
    hBond1Len = (rvec3(nh2Hydrogens[1].xyz) - rvec3(nh2Atom.xyz)).length()
    newH0 = lvec3(oxygen.xyz) + ((-cToO.normalize()) * hBond0Len).rotate_around_origin(normal, 120 * math.pi/180)
    newH1 = lvec3(oxygen.xyz) + ((-cToO.normalize()) * hBond1Len).rotate_around_origin(normal,-120 * math.pi/180)

    #########################
    # Compute the list of positions for all of the atoms. This consists of the original
    # location and the flipped location where we swap the locations of the two heavy atoms
    # and bring the Hydrogens along for the ride.

    startPos = []
    for a in self._atoms:
      startPos.append(a.xyz)

    newPos = startPos[:]
    newPos[0] = newH0
    newPos[1] = newH1
    newPos[2] = oxygen.xyz
    newPos[3] = nh2Atom.xyz

    # Only consider the first 5 atoms when optimizing, the four that move and the one they may shield
    self._coarsePositions = [ startPos[:5], newPos[:5] ]

    #########################
    # Compute the list of Fixup returns.
    hingeIndex = 4
    firstDockIndex = 3
    secondDockIndex = 2
    movable = _rotateHingeDock(self._atoms, hingeIndex, firstDockIndex, secondDockIndex, caAtom)

    # No fix-up for coarse position 0, do the above adjustment for position 1
    self._fixUpPositions = [ [], movable ]

  def CoarsePositions(self):
    # returns: The two possible coarse positions with an energy penalty of -nonFlipPreference for the flipped.
    # The -nonFlipPreference penalty is to prevent uncertain flips from happening -- unless the
    # score is this much better we leave it alone.
    return PositionReturn(self._atoms, self._coarsePositions,
      [ [], [] ],
      [ [], [] ],
      [0.0, -self._nonFlipPreference])

  def FinePositions(self, coarseIndex):
    # returns: No fine positions for any coarse position.
    return PositionReturn([], [], [], [], [])

  def FixUp(self, coarseIndex):
    # Return the appropriate fixup
    return FixUpReturn(self._atoms, self._fixUpPositions[coarseIndex], [], [])

  def PoseDescription(self, coarseIndex, fineIndex, fixedUp):
    if coarseIndex == 1:
      if fixedUp:
        fString = 'AnglesAdjusted'
      else:
        fString = 'AnglesNotAdjusted'
    else:
      fString = '.'
    if coarseIndex >= len(self.CoarsePositions().positions) or fineIndex is not None and (
        fineIndex > 0 and fineIndex >= len(self.FinePositions(0).positions)):
      return "Unrecognized state ."
    elif coarseIndex == 0:
      return "Unflipped . . {}".format(fString)
    else:
      return "Flipped . . {}".format(fString)

##################################################################################
class MoverHisFlip(object):
  def __init__(self, ne2Atom, bondedNeighborLists, extraAtomInfoMap, nonFlipPreference,
               enabledFlipStates = 3, enableFixup = True):
    """Constructs a Mover that will handle flipping a Histidine ring.
       This Mover uses a simple swap of the center positions of the heavy atoms (with
       repositioning of the Hydrogens to lie in the same directions)
       for its testing, but during FixUp it adjusts the bond lengths and angles for
       additional atoms per Protein Science Vol 27:293-315.
       :param ne2Atom: NE2 atom within the Histidine ring.
       :param bondedNeighborLists: A dictionary that contains an entry for each atom in the
       structure that the atom from the first parameter interacts with that lists all of the
       bonded atoms.  Can be obtained by calling probe.Helpers.getBondedNeighborLists().
       :param extraAtomInfoMap: probe.ExtraAtomInfoMap that can be used to look
       up the information for atoms whose values need to be changed.  Can be
       obtained by calling mmtbx.probe.Helpers.getExtraAtomInfo().
       :param nonFlipPreference: Score amount by which the original orientation is preferred
       over the flipped orientation.  This will bias things so that the flipped orientation
       :param enabledFlipStates: Which flip states are enabled? A value of 3 enables both,
       a value of 1 enables non-flipped and a value of 2 enables flipped. If only one state
       is enabled.
       :param enableFixup: This allows the constructor to disable fixup by making it the same
       as not fixed up. This is used by the FlipKin generation code.
    """

    # Store away our constructor arguments that we need for later.
    self._nonFlipPreference = nonFlipPreference
    self._enabledFlipStates = enabledFlipStates
    self._enableFixup = enableFixup

    # Verify that we've been run on a valid structure and get a list of all of the
    # atoms up to and including the pivot atom.
    if ne2Atom.element != "N":
      raise ValueError("MoverHisFlip(): ne2Atom is not a Nitrogen")
    partners = bondedNeighborLists[ne2Atom]
    if len(partners) < 3:
      raise ValueError("MoverHisFlip(): NE2 does not have three bonded neighbors")
    hydrogens = []
    carbons = []
    for a in partners:
      if a.element_is_hydrogen():
        hydrogens.append(a)
      elif a.element == "C":
        carbons.append(a)
    if len(hydrogens) != 1:
      raise ValueError("MoverHisFlip(): NE2 does not have one bonded hydrogen (probably ionically bound)")
    if len(carbons) != 2:
      raise ValueError("MoverHisFlip(): NE2 does not have two bonded carbons")
    ne2HAtom = hydrogens[0]

    # Determine if the first Carbon is CE1, which is bonded to two Nitrogens (zero Carbons).  If not,
    # then the second one must be.  Fill in CD2 and CE1 based on this information, then we
    # can check them and continue parsing.
    cTest = carbons[0]
    bonded = bondedNeighborLists[cTest]
    if len(bonded) != 3:
      raise ValueError("MoverHisFlip(): NE2 neighbor does not have three bonded neighbors")
    cs = 0
    for b in bonded:
      if b.element == "C":
        cs += 1
    if cs == 0:
      ce1Atom = carbons[0]
      cd2Atom = carbons[1]
    else:
      ce1Atom = carbons[1]
      cd2Atom = carbons[0]

    # Find the Hydrogen on CE1.
    bonded = bondedNeighborLists[ce1Atom]
    if len(bonded) != 3:
      raise ValueError("MoverHisFlip(): CE1 does not have three bonded neighbors")
    ce1HAtom = None
    for b in bonded:
      if b.element_is_hydrogen():
        ce1HAtom = b
    if ce1HAtom is None:
      raise ValueError("MoverHisFlip(): Could not find Hydrogen attached to CE1")

    # Find the Hydrogen on CD2.
    bonded = bondedNeighborLists[cd2Atom]
    if len(bonded) != 3:
      raise ValueError("MoverHisFlip(): CD2 does not have three bonded neighbors")
    cd2HAtom = None
    for b in bonded:
      if b.element_is_hydrogen():
        cd2HAtom = b
    if cd2HAtom is None:
      raise ValueError("MoverHisFlip(): CD2 does not have a bonded hydrogen")

    # Find CG on the other side of CD2.
    cgAtom = None
    bonded = bondedNeighborLists[cd2Atom]
    if len(bonded) < 2:
      raise ValueError("MoverHisFlip(): CD2 does not have at least two bonded neighbors")
    for b in bonded:
      if b.i_seq != cd2Atom.i_seq and b.element == "C":
        cgAtom = b
    if cgAtom is None:
      raise ValueError("MoverHisFlip(): Could not find CG")

    # Find CB and ND1 on the other side of CG
    cbAtom = None
    nd1Atom = None
    bonded = bondedNeighborLists[cgAtom]
    if len(bonded) != 3:
      raise ValueError("MoverHisFlip(): CG does not have three bonded neighbors")
    for b in bonded:
      if b.i_seq == cd2Atom.i_seq: # We already know about CD2
        continue
      elif b.element == "N":
        nd1Atom = b
      elif b.element == "C":
        cbAtom = b
    if nd1Atom is None:
      raise ValueError("MoverHisFlip(): Could not find ND1")
    if cbAtom is None:
      raise ValueError("MoverHisFlip(): Could not find CB")

    # Find the Hydrogen attached to ND1
    partners = bondedNeighborLists[nd1Atom]
    if len(partners) < 3:
      raise ValueError("MoverHisFlip(): ND1 does not have three bonded neighbors")
    hydrogens = []
    carbons = []
    for a in partners:
      if a.element_is_hydrogen():
        hydrogens.append(a)
      elif a.element == "C":
        carbons.append(a)
    if len(hydrogens) != 1:
      raise ValueError("MoverHisFlip(): ND1 does not have one bonded hydrogen (probably ionically bound)")
    if len(carbons) != 2:
      raise ValueError("MoverHisFlip(): ND1 does not have two bonded carbons")
    nd1HAtom = hydrogens[0]

    # Find CA on the other side of CB and find CBs Hydrogens
    caAtom = None
    cbHydrogens = []
    bonded = bondedNeighborLists[cbAtom]
    if len(bonded) != 4:
      raise ValueError("MoverHisFlip(): CB does not have four bonded neighbors, has "+str(len(bonded)))
    for b in bonded:
      if b.i_seq == cgAtom.i_seq:
        continue
      elif b.element == "C":
        caAtom = b
      elif b.element_is_hydrogen():
        cbHydrogens.append(b)
    if caAtom is None:
      raise ValueError("MoverHisFlip(): Could not find CA")
    if len(cbHydrogens) != 2:
      raise ValueError("MoverHisFlip(): Could not find Hydrogens on CB")

    self._atoms = [ ne2Atom, ne2HAtom, ce1Atom, ce1HAtom, nd1Atom, nd1HAtom, cd2Atom, cd2HAtom,
      cgAtom, cbAtom, cbHydrogens[0], cbHydrogens[1] ]

    #########################
    # Compute the new positions for the Hydrogens such that they are at the same distance from
    # their swapped parent atoms and in the direction of the Hydrogens from the original atoms at
    # each location.  We swap ND1 with CD2 and NE2 with CE1.
    nd1HVec = lvec3(nd1HAtom.xyz) - lvec3(nd1Atom.xyz)
    ne2HVec = lvec3(ne2HAtom.xyz) - lvec3(ne2Atom.xyz)
    ce1HVec = lvec3(ce1HAtom.xyz) - lvec3(ce1Atom.xyz)
    cd2HVec = lvec3(cd2HAtom.xyz) - lvec3(cd2Atom.xyz)

    nd1HNew = lvec3(cd2Atom.xyz) + nd1HVec.length() * cd2HVec.normalize()
    cd2HNew = lvec3(nd1Atom.xyz) + cd2HVec.length() * nd1HVec.normalize()
    ce1HNew = lvec3(ne2Atom.xyz) + ce1HVec.length() * ne2HVec.normalize()
    ne2HNew = lvec3(ce1Atom.xyz) + ne2HVec.length() * ce1HVec.normalize()

    #########################
    # There are eight possible states for the flipped Histidine.  The first four
    # use the original orientation and the second four use the swapped or fixed-up
    # orientation.  The swapped orientation is used for the coarse tests and if
    # one is accepted, then the fixed-up orienations are used in place of the swapped.
    #   For each location, we have four cases of Hydrogen
    # placement; both (as found), first N Hydrogen removed, second N Hydrogen
    # removed, and both Hydrogens removed.  When a Hydrogen is removed, the associated
    # N is turned into an Acceptor; when it is present, the N is not an acceptor.

    #########################
    # Compute the list of positions for all of the atoms. This consists of the original
    # location and the flipped location where we swap the locations of the two pairs of heavy atoms
    # and bring the Hydrogens along for the ride.
    # We only put the options in place for the enabled flip states.

    startPos = []
    for a in self._atoms:
      startPos.append(a.xyz)

    newPos = startPos[:]
    newPos[0] = ce1Atom.xyz   # ne2 moved to this location
    newPos[1] = ne2HNew
    newPos[2] = ne2Atom.xyz   # ce1 moved to this location
    newPos[3] = ce1HNew
    newPos[4] = cd2Atom.xyz   # nd1 moved to this location
    newPos[5] = nd1HNew
    newPos[6] = nd1Atom.xyz   # cd2 moved to this location
    newPos[7] = cd2HNew

    self._coarsePositions = []
    if self._enabledFlipStates & 1:
      for i in range(4):
        # Only move the first 9 atoms when optimizing, the ones that move and the one they may shield.
        self._coarsePositions.append(startPos[:9])
    if self._enabledFlipStates & 2:
      for i in range(4):
        # Only move the first 9 atoms when optimizing, the ones that move and the one they may shield.
        self._coarsePositions.append(newPos[:9])

    #########################
    # Compute the list of Fixup returns.
    hingeIndex = 8
    firstDockIndex = 0
    secondDockIndex = 2
    fixedUp = _rotateHingeDock(self._atoms, hingeIndex, firstDockIndex, secondDockIndex, caAtom)

    # No fix-up for coarse positions 0-3, do the above adjustment for position3 4-7
    self._fixUpPositions = [ ]
    if self._enabledFlipStates & 1:
      for i in range(4):
        self._fixUpPositions.append([])
    if self._enabledFlipStates & 2:
      for i in range(4):
        if enableFixup:
          self._fixUpPositions.append(fixedUp)
        else:
          self._fixUpPositions.append([])

    #########################
    # Compute the ExtraAtomInfo and deleteMe values.  They are all as provided and False
    # for the initial configuration (0th and 4th).  The first Hydrogen and
    # Nitrogen are removed and adjusted for cases 1&3, 5&7, the second for 2&3 and 6&7.
    # We make copies of each by constructing new ones so we can independently change them.
    self._extras = []
    self._deleteMes = []
    for i in range(len(self._coarsePositions)):
      # Copy the initial values
      extras = []
      deleteMes = []
      for a in self._atoms:
        extras.append(probe.ExtraAtomInfo(extraAtomInfoMap.getMappingFor(a)))
        deleteMes.append(False)

      # Replace any that need it for this configuration.
      if i % 4 == 1 or i % 4 == 3: # Remove the Hydrogen from NE2
        extras[0].isAcceptor = True
        deleteMes[1] = True

      if i % 4 == 2 or i % 4 == 3: # Remove the Hydrogen from ND1
        extras[4].isAcceptor = True
        deleteMes[5] = True

      # Append to the lists.
      self._extras.append(extras)
      self._deleteMes.append(deleteMes)

    #########################
    # Compute the preference energies.
    # There is an energy penalty of -nonFlipPreference
    # for the flipped orientations, and a penalty of -0.05 for keeping both Hydrogens;
    # The doubly-deprotenated case (both Hydrogens removed) has a penalty of -1.0.
    # The -nonFlipPreference penalty is to prevent uncertain flips from happening -- unless the
    # score is this much better we leave it alone.
    self._preferenceEnergies = []
    if self._enabledFlipStates & 1:
      self._preferenceEnergies.extend([ 0.0 - 0.05,  0.0,  0.0,  0.0 - 1.0])
    if self._enabledFlipStates & 2:
      self._preferenceEnergies.extend([
        -self._nonFlipPreference - 0.05,
        -self._nonFlipPreference,
        -self._nonFlipPreference,
        -self._nonFlipPreference - 1.0])

  def CoarsePositions(self):
    # returns: The potential coarse positions.
    return PositionReturn(self._atoms, self._coarsePositions,
      self._extras, self._deleteMes, self._preferenceEnergies)

  def FinePositions(self, coarseIndex):
    # returns: No fine positions for any coarse position.
    return PositionReturn([], [], [], [], [])

  def FixUp(self, coarseIndex):
    # Return the appropriate fixup
    return FixUpReturn(self._atoms, self._fixUpPositions[coarseIndex],
      self._extras[coarseIndex], self._deleteMes[coarseIndex])

  def PoseDescription(self, coarseIndex, fineIndex, fixedUp):
    if self._enabledFlipStates == 3:
      if coarseIndex >= len(self.CoarsePositions().positions) or fineIndex is not None and (
          fineIndex > 0 and fineIndex >= len(self.FinePositions(0).positions)):
        return "Unrecognized state . ."
      elif coarseIndex < 4:
        ret = "Unflipped"
      else:
        ret = "Flipped"
    elif self._enabledFlipStates == 1:
      ret = "Unflipped"
    elif self._enabledFlipStates == 2:
      ret = "Flipped"
    else:
      return "Unrecognized flip states ."

    if coarseIndex % 4 == 0 or coarseIndex % 4 == 1:
      ret += " HD1Placed"
    else:
      ret += " HD1NotPlaced"
    if coarseIndex % 4 == 0 or coarseIndex % 4 == 2:
      ret += " HE2Placed"
    else:
      ret += " HE2NotPlaced"
    # First, check to see if we are in a state where fixup might occur; this is when we
    # have been locked into the flipped state or when we are allowed to choose either state
    # and we're in the uppper half of the coarse positions. If not, we just print '.'
    # because fixup was never an option. If we are, check whether fixup is enabled and if
    # so and we've been told above to fix up, then report angles adjusted.
    if (self._enabledFlipStates == 2) or (
       (self._enabledFlipStates == 3) and (coarseIndex >= len(self._coarsePositions) / 2)):
      if self._enableFixup and fixedUp:
        ret += ' AnglesAdjusted'
      else:
        ret += ' AnglesNotAdjusted'
    else:
      ret += ' .'
    return ret

##################################################################################
# Internal helper functions for angle manipulation.
def _rotateOppositeFriend(atom, axis, partner, friend):
  '''Rotate the atom to point away from the friend.  This means placing it
     within the plane perpendicular to the axis of rotation through the point on that axis
     that it is closest to at the same distance it starts out from that axis and in a
     direction that is the negation of the vector from the partner to the friend projected
     into the plane perpendicular to the axis and then normalized.
     :param atom: iotbx.pdb.hierarchy.atom to be moved.
     :param partner: iotbx.pdb.hierarchy.atom atom that is bonded to the neighbor of
     the atom.
     :param friends: flex iotbx.pdb.hierarchy.atom list of atoms bonded to the partner
     besides the neighbor.
     :param axis: flex array with two scitbx::vec3<double> points, the first
     of which is the origin and the second is a vector pointing in the direction
     of the axis of rotation.  Positive rotations will be right-handed rotations
     around this axis.
     :returns the new location for the atom.
  '''
  normal = rvec3(axis[1])
  friendFromPartner = lvec3(friend.xyz) - lvec3(partner.xyz)
  alongAxisComponent = (friendFromPartner * normal)
  friendFromPartner = rvec3(friend.xyz) - rvec3(partner.xyz)
  inPlane = friendFromPartner - normal*alongAxisComponent
  normalizedOffset = -inPlane.normalize()

  d = -lvec3(atom.xyz)*normal
  t = - (d + (lvec3(axis[0])) * normal)
  nearPoint = rvec3(axis[0]) + normal*t
  distFromNearPoint = (rvec3(atom.xyz)-nearPoint).length()

  return nearPoint + distFromNearPoint * normalizedOffset

from mmtbx_reduce_ext import RotatePointDegreesAroundAxisDir
def _rotateAroundAxis(atom, axis, degrees):
  '''Rotate the atom about the specified axis by the specified number of degrees.
     :param atom: iotbx.pdb.hierarchy.atom or scitbx::vec3<double> or
     scitbx.matrix.rec(xyz, (3,1)) to be moved.
     :param axis: flex array with two scitbx::vec3<double> points, the first
     of which is the origin in space around which to rotate and the second is
     a vector pointing from the origin in the direction of the axis of rotation.
     Positive rotations will be right-handed rotations around this axis.
     :param degrees: How much to rotate the atom around the axis.
     Positive rotation is right-handed around the axis.
     :returns the new location for the atom.
  '''
  # If we have an atom, get its position.  Otherwise, we have a position passed
  # in.
  try:
    pos = atom.xyz
  except Exception:
    pos = rvec3(atom)

  # The axis of rotation for this function is specified as the two ends of the axis.
  # The axis passed in has the point around which to rotate and the direction vector
  # from the origin, so we need to add those together to get the other end of the axis.
  # (This is done in the C++ code by the RotatePointDegreesAroundAxisDir function.)
  return lvec3(RotatePointDegreesAroundAxisDir(axis[0], axis[1], pos, degrees))
  #return lvec3(scitbx.matrix.rotate_point_around_axis(
  #    axis_point_1 = axis[0], axis_point_2 = rvec3(axis[0]) + rvec3(axis[1]),
  #    point = pos, angle = degrees, deg = True))

def _rotateHingeDock(movableAtoms, hingeIndex, firstDockIndex, secondDockIndex, alphaCarbon):
  '''Perform the three-step rotate-hinge-dock calculation described in
     Protein Science Vol 27:293-315 and implemented in
     FlipMemo::RotHingeDock_Flip() in the original Reduce C++ code.
     :param movableAtoms: flex array of iotbx.pdb.hierarchy.atom objects that
     are the original locations of atoms that can be moved, including the Carbon
     atom that is bonded to the alpha carbon but not the alpha carbon itself.
     The order of atoms is as follows: The first ones are in the set that is rotated
     around the vector from the hinge atom to the pivot atom.  Then comes the hinge
     atom, then the pivot atom.  Then all of the atoms between the pivot and the
     Alpha Carbon (if any) including any Hydrogens bound to the pivot atom or the
     linking atoms, excluding the Alpha Carbon itself.
     :param hingeIndex: Index in the movableAtoms array that tells which is
     the atom to hinge around (this will be a Carbon atom).
     :param firstDockIndex: Index in the movableAtoms array that tells which is
     the atom to dock first (this will be the Oxygen atom for Asn and Gln,
     CE1 for His).
     :param secondDockIndex: Index in the movableAtoms array that tells which is
     the atom to dock second (this will be the Nitrogen atom for Asn and Gln,
     NE2 for His).
     :param alphaCarbon: iotbx.pdb.hierarchy.atom that is the alpha carbon.
     The original rotation is around the bond from this atom to the original
     carbon atom.
     :returns A flex array of scitbx.matrix.rec(xyz, (1,3)) entries giving the new locations.
  '''
  #########################
  # A) Rotate the movable atoms that are listed before the hinge atom around the
  #    hinge-pivot vector by 180 degrees.
  # B) Hinge the movable atoms listed before the hings around the hinge to place them back into the
  #    plane that they the two docked atoms originally located in using the axis of least
  #    rotation that passed through the hinge.
  # C) Rotate all of the movable atoms around the alphaCarbon, aligning the docked
  #    atoms with their original locations as much as possible.  This is
  #    done in two steps: 1) Rotating around the shortest axis to make the
  #    first docked atom lie on the original vector from the alphaCarbon to the original second
  #    docked atom.
  #    2) Rotating around the alphaCarbon-to-new-firstDockIndex vector to align the plane
  #    containing the alphaCarbon, new and old secondDockIndex with the plane
  #    containing the alphaCarbon, the original firstDockIndex and the original secondDockIndex
  #    (making the dihedral angle new secondDockIndex, alphaCarbon, old secondDockIndex, old
  #    firstDockIndex be 0).

  # Find the special atoms
  first = movableAtoms[firstDockIndex]
  second = movableAtoms[secondDockIndex]
  hingeAtom = movableAtoms[hingeIndex]
  pivotAtom = movableAtoms[hingeIndex+1]

  # Construct a list of output locations, initializing with the input locations.
  movable = []
  for a in movableAtoms:
    movable.append(a.xyz)

  # A) Rotate the movable atoms that come before the hinge atom by 180 degrees
  # around the pivot-to-hinge vector
  normal = (rvec3(pivotAtom.xyz) - rvec3(hingeAtom.xyz)).normalize()
  axis = flex.vec3_double([hingeAtom.xyz, normal])
  for i in range(hingeIndex):
    movable[i] = _rotateAroundAxis(movable[i], axis, 180)

  # B) Hinge the movable atoms around the hinge.
  # Solve for the planes containing the old and new atoms and then the vector
  # that these planes intersect at (cross product).

  cToO = lvec3(first.xyz) - lvec3(hingeAtom.xyz)
  nToO = rvec3(second.xyz) - rvec3(hingeAtom.xyz)
  oldNormal = (scitbx.matrix.cross_product_matrix(cToO) * nToO).normalize()

  # Flip the order here because we've rotated 180 degrees
  newNToO = lvec3(movable[secondDockIndex]) - lvec3(movable[hingeIndex])
  newCToO = rvec3(movable[firstDockIndex]) - rvec3(movable[hingeIndex])
  newNormal = (scitbx.matrix.cross_product_matrix(newNToO) * newCToO).normalize()

  # If we don't need to rotate, we'll get a zero-length vector
  hinge = scitbx.matrix.cross_product_matrix(lvec3(oldNormal))*rvec3(newNormal)
  if hinge.length() > 0:
    hinge = hinge.normalize()
    axis = flex.vec3_double([hingeAtom.xyz, hinge])
    degrees = 180/math.pi * math.acos((lvec3(oldNormal)*rvec3(newNormal))[0])
    for i in range(hingeIndex):
      # Rotate in the opposite direction, taking the new back to the old.
      movable[i] = _rotateAroundAxis(rvec3(movable[i]), axis, -degrees)

  # C) Rotate the atoms around the alphaCarbon
  #  1) firstDockIndex to alphaCarbon<-->original secondDockIndex line
  aToNewO = lvec3(movable[firstDockIndex]) - lvec3(alphaCarbon.xyz)
  aToOldN = rvec3(second.xyz) - rvec3(alphaCarbon.xyz)
  # If we don't need to rotate, we'll get a zero-length vector
  normal = scitbx.matrix.cross_product_matrix(aToNewO) * aToOldN
  if normal.length() > 0:
    normal = normal.normalize()
    axis = flex.vec3_double([alphaCarbon.xyz, normal])
    degrees = 180/math.pi * math.acos((lvec3(aToOldN.normalize())*rvec3(aToNewO.normalize()))[0])
    for i in range(len(movable)):
      movable[i] = _rotateAroundAxis(rvec3(movable[i]), axis, degrees)

  #  2) firstDockIndex to the proper plane.
  sites = flex.vec3_double([ movable[secondDockIndex], alphaCarbon.xyz, second.xyz, first.xyz ])
  degrees = scitbx.math.dihedral_angle(sites=sites, deg=True)
  hinge = rvec3(alphaCarbon.xyz) - rvec3(second.xyz)
  if hinge.length() > 0:
    hinge = hinge.normalize()
    axis = flex.vec3_double([alphaCarbon.xyz, hinge])
    for i in range(len(movable)):
      # Rotate in the opposite direction, taking the new back to the old.
      movable[i] = _rotateAroundAxis(rvec3(movable[i]), axis, -degrees)

  return movable

##################################################################################
# Test function and its helpers to verify that all Movers behave properly.

def _StableUnderAtomMotion(mover, atom):
  cI = mover.CoarsePositions().positions
  fI = mover.FinePositions(0).positions
  atom.xyz = ( atom.xyz[0]+10, atom.xyz[1], atom.xyz[2] )
  cC = mover.CoarsePositions().positions
  fC = mover.FinePositions(0).positions
  for i,p in enumerate(cI):
    for j, atom in enumerate(p):
      if cI[i][j] != cC[i][j]:
        return False
  for i,p in enumerate(fI):
    for j, atom in enumerate(p):
      if fI[i][j] != fC[i][j]:
        return False
  return True

def Test():
  """Test function for all classes provided above.
  :returns Empty string on success, string describing the problem on failure.
  :returns Empty string on success, string describing the problem on failure.
  """

  # Test the behavior of probe.ExtraAtomInfo to ensure that when we make a copy
  # we can independently modify it.
  info = probe.ExtraAtomInfo()
  info2 = probe.ExtraAtomInfo(info)
  info2.isAcceptor = True
  if info == info2:
    return "Movers.Test() Got unexpected behavior when modifying copy-constructed probe.ExtraAtomInfo() "

  # Test the MoverNull class.
  try:
    atom = pdb.hierarchy.atom()
    atom.name = "C"
    atoms = [atom]
    extras = [probe.ExtraAtomInfo()]
    extrasMap = probe.ExtraAtomInfoMap(atoms, extras)
    m = MoverNull(atom, extrasMap)
    coarse = m.CoarsePositions()
    if len(coarse.atoms) != 1:
      return "Movers.Test() MoverNull: Expected 1 atom for CoarsePositions, got "+str(len(coarse.atoms))
    fine = m.FinePositions(0)
    if len(fine.atoms) != 0:
      return "Movers.Test() MoverNull: Expected 0 atoms for FinePositions, got "+str(len(fine.atoms))
    fixUp = m.FixUp(0)
    if len(fixUp.atoms) != 0:
      return "Movers.Test() MoverNull: Expected 0 atoms for FixUp, got "+str(len(fixUp.atoms))
    if m.PoseDescription(0,0, False) != "Original location . .":
      return "Movers.Test() MoverNull: Unexpected results for PoseDescription, got "+m.PoseDescription(0,0, False)
    if m.PoseDescription(1,0, False) != "Unrecognized state . .":
      return "Movers.Test() MoverNull: Unexpected results for PoseDescription, got "+m.PoseDescription(1,0, False)
    if m.PoseDescription(0,1, False) != "Unrecognized state . .":
      return "Movers.Test() MoverNull: Unexpected results for PoseDescription, got "+m.PoseDescription(0,1, False)

    # Verify that the coarse and fine results don't change when the atom position is moved after
    # the Mover has been constructed.
    if not _StableUnderAtomMotion(m, atom):
      return "Movers.Test() MoverNull: Positions not stable when atom moved"

  except Exception as e:
    return "Movers.Test() MoverNull: Exception during test of MoverNull: "+str(e)+"\n"+traceback.format_exc()

  # Test the _MoverRotator class.
  try:
    # Construct a _MoverRotator with three atoms, each at +1 in Z with one at +1 in X and 0 in Y
    # and the other two at +/-1 in Y and 0 in X.  It will rotate around the Z axis with an offset
    # of -2 for the axis start location by 180 degrees with a coarse step size of 90 and a
    # preference function that always returns 1.
    atoms = []
    coords = [[ 1.0, 0.0, 1.0],
              [ 0.0, 1.0, 1.0],
              [ 0.0,-1.0, 1.0]]
    for i in range(3):
      a = pdb.hierarchy.atom()
      atom.name = "H"
      a.xyz = coords[i]
      atoms.append(a)
    axis = flex.vec3_double([ [ 0.0, 0.0,-2.0], [ 0.0, 0.0, 1.0] ])
    def prefFunc(x):
      return 1.0
    rot = _MoverRotator(atoms,axis, 0, 0, 180, 90.0, True, preferenceFunction = prefFunc)

    # See if the results of each of the functions are what we expect in terms of sizes and locations
    # of atoms and preferences.  We'll use the default fine step size.
    # The first coarse rotation should be by -90 degrees, moving the first atom to (0, -1, 1)
    coarse = rot.CoarsePositions()
    if len(coarse.atoms) != 3:
      return "Movers.Test() _MoverRotator basic: Expected 3 atoms for CoarsePositions, got "+str(len(coarse.atoms))
    atom0pos1 = coarse.positions[1][0]
    if (lvec3(atom0pos1) - lvec3([0,-1,1])).length() > 1e-5:
      return "Movers.Test() _MoverRotator basic: Expected location = (0,-1,1), got "+str(atom0pos1)

    # The first fine rotation (index 0) around the second coarse index (index 1) should be to -91 degrees,
    # moving the first atom to the appropriately rotated location around the Z axis
    rad = -91 / 180 * math.pi
    x = math.cos(rad)
    y = math.sin(rad)
    z = 1
    fine = rot.FinePositions(1)
    atom0pos1 = fine.positions[0][0]
    if (lvec3(atom0pos1) - lvec3([x,y,z])).length() > 1e-5:
      return "Movers.Test() _MoverRotator basic: Expected fine location = "+str([x,y,z])+", got "+str(atom0pos1)

    # The preference function should always return 1.
    for p in fine.preferenceEnergies:
      if p != 1:
        return "Movers.Test() _MoverRotator basic: Expected preference energy = 1, got "+str(p)

    # Test different preference scale value.
    rot = _MoverRotator(atoms,axis, 0, 0, 180, 90.0, True, preferenceFunction = prefFunc, preferredOrientationScale = 2)
    coarse = rot.CoarsePositions()
    for p in coarse.preferenceEnergies:
      if p != 2:
        return "Movers.Test() _MoverRotator Scaled preference: Expected preference energy = 2, got "+str(p)

    # Test None preference function and a sinusoidal one.
    rot = _MoverRotator(atoms,axis, 0, 0, 180, 90.0, True, preferenceFunction = None)
    coarse = rot.CoarsePositions()
    for p in coarse.preferenceEnergies:
      if p != 0:
        return "Movers.Test() _MoverRotator None preference function: Expected preference energy = 0, got "+str(p)
    def prefFunc2(x):
      return math.cos(x * math.pi / 180)
    rot = _MoverRotator(atoms,axis, 0, 0, 180, 180, True, preferenceFunction = prefFunc2)
    coarse = rot.CoarsePositions()
    expected = [1, -1]
    if len(coarse.preferenceEnergies) != len(expected):
      return "Movers.Test() _MoverRotator Sinusoidal preference function: Unexpected preference length:  "+str(len(coarse.preferenceEnergies))
    for i,p  in enumerate(coarse.preferenceEnergies):
      val = expected[i]
      if p != val:
        return "Movers.Test() _MoverRotator Sinusoidal preference function: Expected preference energy = "+str(val)+", got "+str(p)

    # Test coarseStepDegrees default behavior.
    rot = _MoverRotator(atoms,axis, 0, 0, 180)
    coarse = rot.CoarsePositions()
    if len(coarse.positions) != 24:
      return "Movers.Test() _MoverRotator Default coarse step: Expected 24, got "+str(len(coarse.positions))

    # Test doFineRotations = False and 180 degree coarseStepDegrees.
    rot = _MoverRotator(atoms,axis, 0, 0, 180, 180, False)
    coarse = rot.CoarsePositions()
    if len(coarse.positions) != 2:
      return "Movers.Test() _MoverRotator 180 coarse steps: Expected 2, got "+str(len(coarse.positions))
    fine = rot.FinePositions(0)
    if len(fine.positions) != 0:
      return "Movers.Test() _MoverRotator 180 coarse steps: Expected 0, got "+str(len(fine.positions))

    # Test fineStepDegrees setting.
    rot = _MoverRotator(atoms,axis, 0, 0, 180, fineStepDegrees = 2)
    fine = rot.FinePositions(0)
    # +/- 7.5 degrees in 2-degree steps, but we wouldn't do the +7.5 because it will be handled by the next
    # rotation up. So we get +/- 2, 4, and 6
    if len(fine.positions) != 6:
      return "Movers.Test() _MoverRotator setting fine step: Expected 6, got "+str(len(fine.positions))

    # Test the PoseDescription
    if rot.PoseDescription(1,1, False) != "Angle -13.0 deg .":
      return "Movers.Test() _MoverRotator: Unexpected results for PoseDescription, got "+rot.PoseDescription(1,1, False)

    # Test setting an offset and counterbalancing dihedral.
    rot = _MoverRotator(atoms,axis, -10, 10, 180, fineStepDegrees = 2)
    if rot.PoseDescription(1,1, False) != "Angle -3.0 deg .":
      return "Movers.Test() _MoverRotator: Unexpected results for offset, got "+rot.PoseDescription(1,1, False)

    # Verify that the coarse and fine results don't change when the atom position is moved after
    # the Mover has been constructed.
    if not _StableUnderAtomMotion(rot, atoms[0]):
      return "Movers.Test() _MoverRotator: Positions not stable when atom moved"

  except Exception as e:
    return "Movers.Test() _MoverRotator basic: Exception during test of _MoverRotator: "+str(e)+"\n"+traceback.format_exc()

  # Test the MoverSingleHydrogenRotator class.
  try:
    # Construct a MoverSingleHydrogenRotator that has an atom that starts out at 45 degrees around Z
    # that is bonded to a neighbor and partner that are vertical and then partner is bonded to two
    # friends that are in the Y=0 plane.  This should cause us to get the atom rotated to lie in
    # the Y=0 plane at a distance of sqrt(2) and a fitness function that prefers the orientations
    # that are in this plane.
    h = pdb.hierarchy.atom()
    h.element = "H"
    h.name = "H"
    h.xyz = [ 1.0, 1.0, 1.0 ]

    n = pdb.hierarchy.atom()
    n.name = "C"
    n.xyz = [ 0.0, 0.0, 0.0 ]

    p = pdb.hierarchy.atom()
    p.name = "C"
    p.xyz = [ 0.0, 0.0,-1.0 ]

    f1 = pdb.hierarchy.atom()
    f1.name = "C1"
    f1.xyz = [ 1.0, 0.0,-2.0 ]

    f2 = pdb.hierarchy.atom()
    f2.name = "C2"
    f2.xyz = [-1.0, 0.0,-2.0 ]

    # Build the hierarchy so we can reset the i_seq values.
    ag = pdb.hierarchy.atom_group()
    ag.append_atom(h)
    ag.append_atom(n)
    ag.append_atom(p)
    ag.append_atom(f1)
    ag.append_atom(f2)
    rg = pdb.hierarchy.residue_group()
    rg.append_atom_group(ag)
    c = pdb.hierarchy.chain()
    c.append_residue_group(rg)
    m = pdb.hierarchy.model()
    m.append_chain(c)
    m.atoms().reset_i_seq()

    bondedNeighborLists = {}
    bondedNeighborLists[h] = [ n ]
    bondedNeighborLists[n] = [ h, p ]
    bondedNeighborLists[p] = [ n, f1, f2 ]
    bondedNeighborLists[f1] = [ p ]
    bondedNeighborLists[f2] = [ p ]

    # Prepare our extraAtomInfoMap
    atoms = c.atoms()
    extras = []
    for a in atoms:
      extras.append(probe.ExtraAtomInfo())
    extrasMap = probe.ExtraAtomInfoMap(atoms, extras)

    # Add a non-bonded potential acceptor atom at 13 degrees rotation towards the Y axis from
    # the X axis.
    acc = pdb.hierarchy.atom()
    acc.name = "C"
    acc.xyz = [ math.cos(13*math.pi/180), math.sin(13*math.pi/180), 1.0 ]

    # Construct a stand-in riding-coefficients-producing hParams object that will provide an
    # appropriate dihedral atom for the hydrogen to use.
    class Item:
      def __init__(self, paramN, paramA2):
        self.n = paramN
        self.a2 = paramA2
    item = Item(0, f1.i_seq)
    hParams = {}
    hParams[h.i_seq] = item

    mover = MoverSingleHydrogenRotator(h, bondedNeighborLists, extrasMap, hParams, [acc])

    # Check for hydrogen rotated into -X plane at a distance of sqrt(2) from Z axis.
    # It should have been rotated 180 degrees from f1 because f1 is the conventional branch based on its name.
    if h.xyz[2] != 1 or abs(-h.xyz[0]-math.sqrt(2)) > 1e-5:
      return "Movers.Test() MoverSingleHydrogenRotator pair: bad H placement"

    ''' Preference function has been removed from this class
    # Check fitness function preferring 0 and 180 rotations
    zero = mover._preferenceFunction(0)
    ninety = mover._preferenceFunction(90)
    oneEighty = mover._preferenceFunction(180)
    if abs(zero - oneEighty) > 1e-5:
      return "Movers.Test() MoverSingleHydrogenRotator pair: bad preference function"
    if zero - ninety < 1e-5:
      return "Movers.Test() MoverSingleHydrogenRotator pair: bad preference function"
    '''

    # Check that one of the orientations has a dihedral angle of 0 compared to the original
    # 13-degree-off potential acceptor atom.
    found = False
    for pos in mover.CoarsePositions().positions:
      sites = [ pos[0], p.xyz, n.xyz, acc.xyz ]
      dihedral = scitbx.math.dihedral_angle(sites=sites, deg=True)
      if abs(dihedral) < 1e-5:
        found = True
        break
    if not found:
      return "Movers.Test() MoverSingleHydrogenRotator pair: no orientation towards acceptor"

    # Verify that the coarse and fine results don't change when the atom position is moved after
    # the Mover has been constructed.
    if not _StableUnderAtomMotion(mover, h):
      return "Movers.Test() MoverSingleHydrogenRotator: Positions not stable when atom moved"

  except Exception as e:
    return "Movers.Test() MoverSingleHydrogenRotator pair: Exception during test: "+str(e)+"\n"+traceback.format_exc()

  try:
    # Construct a MoverSingleHydrogenRotator that has an atom that starts out at 45 degrees around Z
    # that is bonded to a neighbor and partner that are vertical and then partner is bonded to three
    # friends one of which is on the +X axis and the other two are +/-120 away from it.
    # This should cause us to get the atom rotated to be between two of the friends and a fitness
    # function that prefers its location and +/-120 degrees from it.
    h = pdb.hierarchy.atom()
    h.element = "H"
    h.name = "H"
    h.xyz = [ 1.0, 1.0, 1.0 ]

    n = pdb.hierarchy.atom()
    n.name = "C"
    n.xyz = [ 0.0, 0.0, 0.0 ]

    p = pdb.hierarchy.atom()
    p.name = "C"
    p.xyz = [ 0.0, 0.0,-1.0 ]

    f1 = pdb.hierarchy.atom()
    f1.name = "C1"
    f1.xyz = [ 1.0, 0.0,-2.0 ]

    f2 = pdb.hierarchy.atom()
    f2.name = "C2"
    f2.xyz = _rotateAroundAxis(f1, axis, -120)

    f3 = pdb.hierarchy.atom()
    f3.name = "C3"
    f3.xyz = _rotateAroundAxis(f1, axis, 120)

    # Build the hierarchy so we can reset the i_seq values.
    ag = pdb.hierarchy.atom_group()
    ag.append_atom(h)
    ag.append_atom(n)
    ag.append_atom(p)
    ag.append_atom(f1)
    ag.append_atom(f2)
    ag.append_atom(f3)
    rg = pdb.hierarchy.residue_group()
    rg.append_atom_group(ag)
    c = pdb.hierarchy.chain()
    c.append_residue_group(rg)
    m = pdb.hierarchy.model()
    m.append_chain(c)
    m.atoms().reset_i_seq()

    bondedNeighborLists = {}
    bondedNeighborLists[h] = [ n ]
    bondedNeighborLists[n] = [ h, p ]
    bondedNeighborLists[p] = [ n, f1, f2, f3 ]
    bondedNeighborLists[f1] = [ p ]
    bondedNeighborLists[f2] = [ p ]
    bondedNeighborLists[f3] = [ p ]

    # Prepare our extraAtomInfoMap
    atoms = c.atoms()
    extras = []
    for a in atoms:
      extras.append(probe.ExtraAtomInfo())
    extrasMap = probe.ExtraAtomInfoMap(atoms, extras)

    # Construct a stand-in riding-coefficients-producing hParams object that will provide an
    # appropriate dihedral atom for the hydrogen to use.
    class Item:
      def __init__(self, paramN, paramA2):
        self.n = paramN
        self.a2 = paramA2
    item = Item(0, f1.i_seq)
    hParams = {}
    hParams[h.i_seq] = item

    mover = MoverSingleHydrogenRotator(h, bondedNeighborLists, extrasMap, hParams)

    # Check for a hydrogen on the -X axis at a distance of sqrt(2) from Z axis,
    # it should have picked f1 as the conventional friend to be opposite to based on its name.
    angle = 0
    if not (h.xyz[2] == 1 and h.xyz[0]+math.sqrt(2) < 1e-5):
      return "Movers.Test() MoverSingleHydrogenRotator triple: bad H placement"

    ''' Preference function has been removed from this class
    # Check fitness function preferring 180 and +/- 120 from there rotations away from
    # the angle away from 180 degrees.
    zero = mover._preferenceFunction(angle+0)
    oneEighty = mover._preferenceFunction(angle+180)
    off1 = mover._preferenceFunction(angle+180+120)
    off2 = mover._preferenceFunction(angle+180-120)
    if abs(off1 - oneEighty) > 1e-5:
      return "Movers.Test() MoverSingleHydrogenRotator triple: bad preference function"
    if abs(off2 - oneEighty) > 1e-5:
      return "Movers.Test() MoverSingleHydrogenRotator triple: bad preference function"
    if zero - oneEighty < 1e-5:
      return "Movers.Test() MoverSingleHydrogenRotator triple: bad preference function"
    '''

  except Exception as e:
    return "Movers.Test() MoverSingleHydrogenRotator triple: Exception during test: "+str(e)+"\n"+traceback.format_exc()

  # Test the MoverNH3Rotator class.
  try:
    # Construct a MoverNH3Rotator that has one hydrogen start out at 45 degrees around Z and the
    # other two at +/-120 degrees from that one.
    # They are bonded to a Nitrogen and partner that are vertical and then partner is bonded to three
    # friends with one on the +X axis and the others +/-120.  This should cause us to get the hydrogens at
    # 180 and 120 away from that and a fitness function that prefers the orientations 120 degrees
    # apart.
    axis = flex.vec3_double([ [0,0,0], [0,0,1] ])
    h1 = pdb.hierarchy.atom()
    h1.element = "H"
    h1.name = "H1"
    h1.xyz = [ 1.0, 1.0, 1.0 ]

    h2 = pdb.hierarchy.atom()
    h2.element = "H"
    h2.name = "H2"
    h2.xyz = _rotateAroundAxis(h1, axis, -120)

    h3 = pdb.hierarchy.atom()
    h3.element = "H"
    h3.name = "H3"
    h3.xyz = _rotateAroundAxis(h1, axis, 120)

    n = pdb.hierarchy.atom()
    n.element = "N"
    n.name = "N"
    n.xyz = [ 0.0, 0.0, 0.0 ]

    p = pdb.hierarchy.atom()
    p.name = "C"
    p.xyz = [ 0.0, 0.0,-1.0 ]

    f1 = pdb.hierarchy.atom()
    f1.name = "C1"
    f1.xyz = [ 1.0, 0.0,-2.0 ]

    f2 = pdb.hierarchy.atom()
    f2.name = "C2"
    f2.xyz = _rotateAroundAxis(f1, axis, -120)

    f3 = pdb.hierarchy.atom()
    f3.name = "C3"
    f3.xyz = _rotateAroundAxis(f1, axis, 120)

    # Build the hierarchy so we can reset the i_seq values.
    ag = pdb.hierarchy.atom_group()
    ag.append_atom(h1)
    ag.append_atom(h2)
    ag.append_atom(h3)
    ag.append_atom(n)
    ag.append_atom(p)
    ag.append_atom(f1)
    ag.append_atom(f2)
    ag.append_atom(f3)
    rg = pdb.hierarchy.residue_group()
    rg.append_atom_group(ag)
    c = pdb.hierarchy.chain()
    c.append_residue_group(rg)
    m = pdb.hierarchy.model()
    m.append_chain(c)
    m.atoms().reset_i_seq()

    bondedNeighborLists = {}
    bondedNeighborLists[h1] = [ n ]
    bondedNeighborLists[h2] = [ n ]
    bondedNeighborLists[h3] = [ n ]
    bondedNeighborLists[n] = [ h1, h2, h3, p ]
    bondedNeighborLists[p] = [ n, f1, f2, f3 ]
    bondedNeighborLists[f1] = [ p ]
    bondedNeighborLists[f2] = [ p ]
    bondedNeighborLists[f3] = [ p ]

    # Construct a stand-in riding-coefficients-producing hParams object that will provide an
    # appropriate dihedral atom for the appropriate hydrogen to use.
    class Item:
      def __init__(self, paramN, paramA2):
        self.n = paramN
        self.a2 = paramA2
    item = Item(0, f1.i_seq)
    hParams = {}
    hParams[h3.i_seq] = item

    mover = MoverNH3Rotator(n, bondedNeighborLists, hParams)

    # Check for the third hydrogen on the -X axis at a distance of sqrt(2) from Z the axis.
    if not (h3.xyz[2] == 1 and h3.xyz[0]+math.sqrt(2) < 1e-5):
      return "Movers.Test() MoverNH3Rotator basic: bad H placement"

    # Check fitness function preferring 180 and +/- 120 from there rotations
    zero = mover._preferenceFunction(0)
    oneEighty = mover._preferenceFunction(180)
    off1 = mover._preferenceFunction(180+120)
    off2 = mover._preferenceFunction(180-120)
    if abs(off1 - oneEighty) > 1e-5:
      return "Movers.Test() MoverNH3Rotator basic: bad preference function"
    if abs(off2 - oneEighty) > 1e-5:
      return "Movers.Test() MoverNH3Rotator basic: bad preference function"
    if zero - oneEighty < 1e-5:
      return "Movers.Test() MoverNH3Rotator basic: bad preference function"

    # Verify that the coarse and fine results don't change when the atom position is moved after
    # the Mover has been constructed.
    if not _StableUnderAtomMotion(mover, h1):
      return "Movers.Test() MoverNH3Rotator: Positions not stable when atom moved"

  except Exception as e:
    return "Movers.Test() MoverNH3Rotator basic: Exception during test: "+str(e)+"\n"+traceback.format_exc()

  # Test the MoverAromaticMethylRotator class.
  try:
    # Construct a MoverAromaticMethylRotator that has one hydrogen start out at 45 degrees around Z and the
    # other two at +/-120 degrees from that one.
    # They are bonded to a Carbon and partner that are vertical and then partner is bonded to two
    # friends that are in the Y=0 plane.  This should cause us to get the one of the hydrogens at
    # +90 or -90 and the others 120 away from the first with only two coarse choices and no fine choices.
    axis = flex.vec3_double([ [0,0,0], [0,0,1] ])
    h1 = pdb.hierarchy.atom()
    h1.element = "H"
    h1.name = "H1"
    h1.xyz = [ 1.0, 1.0, 1.0 ]

    h2 = pdb.hierarchy.atom()
    h2.element = "H"
    h2.name = "H2"
    h2.xyz = _rotateAroundAxis(h1, axis, -120)

    h3 = pdb.hierarchy.atom()
    h3.element = "H"
    h3.name = "H3"
    h3.xyz = _rotateAroundAxis(h1, axis, 120)

    n = pdb.hierarchy.atom()
    n.element = "C"
    n.name = "C"
    n.xyz = [ 0.0, 0.0, 0.0 ]

    p = pdb.hierarchy.atom()
    p.name = "C"
    p.xyz = [ 0.0, 0.0,-1.0 ]

    f1 = pdb.hierarchy.atom()
    f1.name = "C1"
    f1.xyz = [ 1.0, 0.0,-2.0 ]

    f2 = pdb.hierarchy.atom()
    f2.name = "C2"
    f1.xyz = [-1.0, 0.0,-2.0 ]

    # Build the hierarchy so we can reset the i_seq values.
    ag = pdb.hierarchy.atom_group()
    ag.append_atom(h1)
    ag.append_atom(h2)
    ag.append_atom(h3)
    ag.append_atom(n)
    ag.append_atom(p)
    ag.append_atom(f1)
    ag.append_atom(f2)
    rg = pdb.hierarchy.residue_group()
    rg.append_atom_group(ag)
    c = pdb.hierarchy.chain()
    c.append_residue_group(rg)
    m = pdb.hierarchy.model()
    m.append_chain(c)
    m.atoms().reset_i_seq()

    bondedNeighborLists = {}
    bondedNeighborLists[h1] = [ n ]
    bondedNeighborLists[h2] = [ n ]
    bondedNeighborLists[h3] = [ n ]
    bondedNeighborLists[n] = [ h1, h2, h3, p ]
    bondedNeighborLists[p] = [ n, f1, f2 ]
    bondedNeighborLists[f1] = [ p ]
    bondedNeighborLists[f2] = [ p ]

    # Construct a stand-in riding-coefficients-producing hParams object that will provide an
    # appropriate dihedral atom for the appropriate hydrogen to use.
    class Item:
      def __init__(self, paramN, paramA2):
        self.n = paramN
        self.a2 = paramA2
    item = Item(0, f1.i_seq)
    hParams = {}
    hParams[h3.i_seq] = item

    mover = MoverAromaticMethylRotator(n, bondedNeighborLists, hParams)

    # Check for the third hydrogen on the +Y axis at a distance of sqrt(2) from Z the axis.
    if not (h3.xyz[2] == 1 and abs(h3.xyz[1]-math.sqrt(2)) < 1e-5):
      return "Movers.Test() MoverAromaticMethylRotator basic: bad H placement"

    # Check that we get two coarse and no fine orientations
    coarse = mover.CoarsePositions().positions
    if len(coarse) != 2:
      return "Movers.Test() MoverAromaticMethylRotator basic: bad coarse count: "+str(len(coarse))
    fine = mover.FinePositions(0).positions
    if len(fine) != 0:
      return "Movers.Test() MoverAromaticMethylRotator basic: bad fine count: "+str(len(fine))

    # Verify that the coarse and fine results don't change when the atom position is moved after
    # the Mover has been constructed.
    if not _StableUnderAtomMotion(mover, h1):
      return "Movers.Test() MoverNH3Rotator: Positions not stable when atom moved"

  except Exception as e:
    return "Movers.Test() MoverAromaticMethylRotator basic: Exception during test: "+str(e)+"\n"+traceback.format_exc()

  # Test the MoverTetrahedralMethylRotator class.
  try:
    # Construct a MoverTetrahedralMethylRotator that has one hydrogen start out at 45 degrees around Z and the
    # other two at +/-120 degrees from that one.
    # They are bonded to a Carbon and partner that are vertical and then partner is bonded to three
    # friends with one in the +X direction.  This should cause us to get the one of the hydrogens at
    # 180 the others 120 away from the first.
    axis = flex.vec3_double([ [0,0,0], [0,0,1] ])
    h1 = pdb.hierarchy.atom()
    h1.element = "H"
    h1.name = "H1"
    h1.xyz = [ 1.0, 1.0, 1.0 ]

    h2 = pdb.hierarchy.atom()
    h2.element = "H"
    h2.name = "H2"
    h2.xyz = _rotateAroundAxis(h1, axis, -120)

    h3 = pdb.hierarchy.atom()
    h3.element = "H"
    h3.name = "H3"
    h3.xyz = _rotateAroundAxis(h1, axis, 120)

    n = pdb.hierarchy.atom()
    n.element = "C"
    n.name = "C"
    n.xyz = [ 0.0, 0.0, 0.0 ]

    p = pdb.hierarchy.atom()
    p.name = "C"
    p.xyz = [ 0.0, 0.0,-1.0 ]

    f1 = pdb.hierarchy.atom()
    f1.name = "C1"
    f1.xyz = [ 1.0, 0.0,-2.0 ]

    f2 = pdb.hierarchy.atom()
    f2.name = "C2"
    f2.xyz = _rotateAroundAxis(f1, axis, -120)

    f3 = pdb.hierarchy.atom()
    f3.name = "C3"
    f3.xyz = _rotateAroundAxis(f1, axis,  120)

    # Build the hierarchy so we can reset the i_seq values.
    ag = pdb.hierarchy.atom_group()
    ag.append_atom(h1)
    ag.append_atom(h2)
    ag.append_atom(h3)
    ag.append_atom(n)
    ag.append_atom(p)
    ag.append_atom(f1)
    ag.append_atom(f2)
    ag.append_atom(f3)
    rg = pdb.hierarchy.residue_group()
    rg.append_atom_group(ag)
    c = pdb.hierarchy.chain()
    c.append_residue_group(rg)
    m = pdb.hierarchy.model()
    m.append_chain(c)
    m.atoms().reset_i_seq()

    bondedNeighborLists = {}
    bondedNeighborLists[h1] = [ n ]
    bondedNeighborLists[h2] = [ n ]
    bondedNeighborLists[h3] = [ n ]
    bondedNeighborLists[n] = [ h1, h2, h3, p ]
    bondedNeighborLists[p] = [ n, f1, f2, f3 ]
    bondedNeighborLists[f1] = [ p ]
    bondedNeighborLists[f2] = [ p ]
    bondedNeighborLists[f3] = [ p ]

    # Construct a stand-in riding-coefficients-producing hParams object that will provide an
    # appropriate dihedral atom for the appropriate hydrogen to use.
    class Item:
      def __init__(self, paramN, paramA2):
        self.n = paramN
        self.a2 = paramA2
    item = Item(0, f1.i_seq)
    hParams = {}
    hParams[h3.i_seq] = item

    mover = MoverTetrahedralMethylRotator(n, bondedNeighborLists, hParams)

    # Check for the third hydrogen on the -X axis at a distance of sqrt(2) from Z the axis.
    if not (h3.xyz[2] == 1 and abs(-h3.xyz[0]-math.sqrt(2)) < 1e-5):
      return "Movers.Test() MoverTetrahedralMethylRotator basic: bad H placement"

    # Check fitness function preferring 180 and +/- 120 from there rotations.
    zero = mover._preferenceFunction(0)
    oneEighty = mover._preferenceFunction(180)
    off1 = mover._preferenceFunction(180+120)
    off2 = mover._preferenceFunction(180-120)
    if abs(off1 - oneEighty) > 1e-5:
      return "Movers.Test() MoverTetrahedralMethylRotator: bad preference function"
    if abs(off2 - oneEighty) > 1e-5:
      return "Movers.Test() MoverTetrahedralMethylRotator: bad preference function"
    if zero - oneEighty < 1e-5:
      return "Movers.Test() MoverTetrahedralMethylRotator: bad preference function"

    # Verify that the coarse and fine results don't change when the atom position is moved after
    # the Mover has been constructed.
    if not _StableUnderAtomMotion(mover, h1):
      return "Movers.Test() MoverTetrahedralMethylRotator: Positions not stable when atom moved"

  except Exception as e:
    return "Movers.Test() MoverTetrahedralMethylRotator basic: Exception during test: "+str(e)+"\n"+traceback.format_exc()

  # Test the MoverAmideFlip class with no linker (similar to Asn).
  try:
    # Test behavior with offsets for each atom so that we test the generic case.
    # Construct a MoverAmideFlip that has the N, H's and Oxygen located (non-physically)
    # slightly in the +Y direction out of the X-Z plane, with the Hydrogens 120 around the
    # same offset axis.
    # They are bonded to a Carbon and friend (pivot) and alpha carbon that are on the Z axis.
    # Non-physically, atoms are 1 unit apart.
    p = pdb.hierarchy.atom()
    p.name = "C"
    p.xyz = [ 0.0, 0.0, 0.0 ]

    f = pdb.hierarchy.atom()
    f.element = "C"
    f.name = "C"
    f.xyz = [ 0.0, 0.0,-1.0 ]

    fh1 = pdb.hierarchy.atom()
    fh1.element = "H"
    fh1.name = "H"
    fh1.xyz = [ 1.0, 0.0,-1.0 ]

    fh2 = pdb.hierarchy.atom()
    fh2.element = "H"
    fh2.name = "H"
    fh2.xyz = [-1.0, 0.0,-1.0 ]

    ca = pdb.hierarchy.atom()
    ca.element = "C"
    ca.name = "CA"
    ca.xyz = [ 0.0, 0.0,-2.0 ]

    # Nitrogen and Oxygen are +/-120 degrees from carbon-carbon bond
    axis = flex.vec3_double([ [0,0,0], [0,1,0] ])
    n = pdb.hierarchy.atom()
    n.element = "N"
    n.name = "N"
    n.xyz = _rotateAroundAxis(f, axis,-120) + lvec3([0,0.01,0]) + lvec3([ 0.002, 0.003,-0.004])

    o = pdb.hierarchy.atom()
    o.element = "O"
    o.name = "O"
    o.xyz = _rotateAroundAxis(f, axis, 120) + lvec3([0,0.01,0]) + lvec3([-0.003, 0.002, 0.003])

    # Hydrogens are +/-120 degrees from nitrogen-carbon bond
    axis = flex.vec3_double([ n.xyz, [0,1,0] ])
    h1 = pdb.hierarchy.atom()
    h1.element = "H"
    h1.name = "H1"
    h1.xyz = _rotateAroundAxis(p, axis,-120) + lvec3([0,0.01,0]) + lvec3([-0.008, 0.001, 0.008])

    h2 = pdb.hierarchy.atom()
    h2.element = "H"
    h2.name = "H2"
    h2.xyz = _rotateAroundAxis(p, axis, 120) + lvec3([0,0.01,0]) + lvec3([ 0.007,-0.001, 0.007])

    # Build the hierarchy so we can reset the i_seq values.
    ag = pdb.hierarchy.atom_group()
    ag.append_atom(h1)
    ag.append_atom(h2)
    ag.append_atom(n)
    ag.append_atom(o)
    ag.append_atom(p)
    ag.append_atom(f)
    ag.append_atom(fh1)
    ag.append_atom(fh2)
    ag.append_atom(ca)
    rg = pdb.hierarchy.residue_group()
    rg.append_atom_group(ag)
    c = pdb.hierarchy.chain()
    c.append_residue_group(rg)
    m = pdb.hierarchy.model()
    m.append_chain(c)
    m.atoms().reset_i_seq()

    bondedNeighborLists = {}
    bondedNeighborLists[h1] = [ n ]
    bondedNeighborLists[h2] = [ n ]
    bondedNeighborLists[n] = [ h1, h2, p ]
    bondedNeighborLists[o] = [ p ]
    bondedNeighborLists[p] = [ n, o, f ]
    bondedNeighborLists[f] = [ p, ca, fh1, fh2 ]
    bondedNeighborLists[fh1] = [ f ]
    bondedNeighborLists[fh2] = [ f ]
    bondedNeighborLists[ca] = [ f ]

    mover = MoverAmideFlip(n, ca.name, bondedNeighborLists, 0.5)

    # Ensure that the hydrogens have been rotated to have a 0 and 180 dihedral with
    # the Oxygen atom.
    sites = [ h1.xyz, n.xyz, p.xyz, o.xyz ]
    degrees = scitbx.math.dihedral_angle(sites=sites, deg=True)
    while degrees > 180:
        degrees -= 360
    while degrees <= -180:
        degrees += 360
    if abs(degrees) > 1e-5 and abs(180 - degrees) > 1e-5:
      return "Movers.Test() MoverAmideFlip: h1 dihedral not 0 or 180: {:.2f}".format(degrees)
    sites = [ h2.xyz, n.xyz, p.xyz, o.xyz ]
    degrees = scitbx.math.dihedral_angle(sites=sites, deg=True)
    while degrees > 180:
        degrees -= 360
    while degrees <= -180:
        degrees += 360
    if abs(degrees) > 1e-5 and abs(180 - degrees) > 1e-5:
      return "Movers.Test() MoverAmideFlip: h2 dihedral not 0 or 180: {:.2f}".format(degrees)

    # Ensure that the coarse-flip results meet the expections:
    # 1) N and O are flipped in position
    # 2) H remain at the same distance from the new N.

    coarse = mover.CoarsePositions()
    if coarse.preferenceEnergies[0] <= coarse.preferenceEnergies[1]:
      return "Movers.Test() MoverAmideFlip: Original orientation not preferred"
    if len(coarse.positions) != 2:
      return "Movers.Test() MoverAmideFlip basic: Did not find two locations: "+str(len(coarse.positions))
    newPos = coarse.positions[1]
    dist = (lvec3(newPos[2]) - lvec3(o.xyz)).length()
    if dist > 0.01:
      return "Movers.Test() MoverAmideFlip basic: Nitrogen moved incorrectly: "+str(dist)
    dist = (lvec3(newPos[3]) - lvec3(n.xyz)).length()
    if dist > 0.01:
      return "Movers.Test() MoverAmideFlip basic: Oxygen moved incorrectly: "+str(dist)

    dHydrogen = (lvec3(newPos[0]) - lvec3(newPos[2])).length()
    oldDHydrogen = (lvec3(h1.xyz)-lvec3(n.xyz)).length()
    if abs(dHydrogen - oldDHydrogen) > 0.0001:
      return "Movers.Test() MoverAmideFlip basic: Bad coarse hydrogen1 motion: "+str(dHydrogen-oldDHydrogen)

    dHydrogen = (lvec3(newPos[1]) - lvec3(newPos[2])).length()
    oldDHydrogen = (lvec3(h2.xyz)-lvec3(n.xyz)).length()
    if abs(dHydrogen - oldDHydrogen) > 0.0001:
      return "Movers.Test() MoverAmideFlip basic: Bad coarse hydrogen2 motion: "+str(dHydrogen-oldDHydrogen)

    # Ensure that the Fixup results meet the specifications:
    # 1) New Oxygen on the line from the alpha carbon to the old Nitrogen
    # 2) New plane of Oxygen, Nitrogen, Alpha Carbon matches old plane, but flipped
    # 3) Carbons and pivot Hydrogens move slightly due to rigid-body motion

    fixedUp = mover.FixUp(1).positions
    newODir = (fixedUp[3] - lvec3(f.xyz)).normalize()
    oldNDir = (rvec3(n.xyz) - rvec3(f.xyz)).normalize()
    if (newODir * oldNDir)[0] < 0.9999:
      return "Movers.Test() MoverAmideFlip basic: Bad oxygen alignment: "+str((newODir * oldNDir)[0])

    newNDir = (fixedUp[2] - lvec3(f.xyz)).normalize()
    oldODir = (rvec3(o.xyz) - rvec3(f.xyz)).normalize()
    newNormal = (scitbx.matrix.cross_product_matrix(lvec3(newNDir)) * rvec3(newODir)).normalize()
    oldNormal = (scitbx.matrix.cross_product_matrix(lvec3(oldNDir)) * rvec3(oldODir)).normalize()
    dot = (lvec3(newNormal) * rvec3(oldNormal))[0]
    if dot > -0.99999:
      return "Movers.Test() MoverAmideFlip basic: Bad plane alignment: "+str(dot)

    dCarbon = (fixedUp[4] - lvec3(p.xyz)).length()
    if dCarbon < 0.001 or dCarbon > 0.1:
      return "Movers.Test() MoverAmideFlip basic: Bad hinge motion: "+str(dCarbon)

    dCarbon = (fixedUp[5] - lvec3(f.xyz)).length()
    if dCarbon < 0.0005 or dCarbon > 0.1:
      return "Movers.Test() MoverAmideFlip basic: Bad pivot motion: "+str(dCarbon)

    dHydrogen = (fixedUp[6] - lvec3(fh1.xyz)).length()
    if dHydrogen < 0.0005 or dHydrogen > 0.1:
      return "Movers.Test() MoverAmideFlip basic: Bad pivot hydrogen motion: "+str(dHydrogen)

    dHydrogen = (fixedUp[7] - lvec3(fh2.xyz)).length()
    if dHydrogen < 0.0005 or dHydrogen > 0.1:
      return "Movers.Test() MoverAmideFlip basic: Bad pivot hydrogen motion: "+str(dHydrogen)

    # Test the PoseDescription
    if mover.PoseDescription(1, 0, True) != "Flipped . . AnglesAdjusted":
      return "Movers.Test() MoverAmideFlip basic: Unexpected results for PoseDescription, got "+mover.PoseDescription(1,1, True)

    # Verify that the coarse and fine results don't change when the atom position is moved after
    # the Mover has been constructed.
    if not _StableUnderAtomMotion(mover, n):
      return "Movers.Test() MoverAmideFlip: Positions not stable when atom moved"

  except Exception as e:
    return "Movers.Test() MoverAmideFlip basic: Exception during test: "+str(e)+"\n"+traceback.format_exc()

  # Test the MoverAmideFlip class with a linker (similar to Gln).
  try:
    # Test behavior with offsets for each atom so that we test the generic case.
    # Construct a MoverAmideFlip that has the N, H's and Oxygen located (non-physically)
    # slightly in the +Y direction out of the X-Z plane, with the Hydrogens 120 around the
    # same offset axis.
    # They are bonded to a Carbon and friend (pivot) and linker and alpha carbon that are
    # on the Z axis.
    # Non-physically, atoms are 1 unit apart.
    p = pdb.hierarchy.atom()
    p.xyz = [ 0.0, 0.0, 0.0 ]

    f = pdb.hierarchy.atom()
    f.element = "C"
    f.xyz = [ 0.0, 0.0,-1.0 ]

    fh1 = pdb.hierarchy.atom()
    fh1.element = "H"
    fh1.xyz = [ 1.0, 0.0,-1.0 ]

    fh2 = pdb.hierarchy.atom()
    fh2.element = "H"
    fh2.xyz = [-1.0, 0.0,-1.0 ]

    ln = pdb.hierarchy.atom()
    ln.element = "C"
    ln.xyz = [ 0.0, 0.0,-2.0 ]

    lnh1 = pdb.hierarchy.atom()
    lnh1.element = "H"
    lnh1.xyz = [ 1.0, 0.0,-2.0 ]

    lnh2 = pdb.hierarchy.atom()
    lnh2.element = "H"
    lnh2.xyz = [-1.0, 0.0,-2.0 ]

    ca = pdb.hierarchy.atom()
    ca.element = "C"
    ca.name = "CA"
    ca.xyz = [ 0.0, 0.0,-3.0 ]

    # Nitrogen and Oxygen are +/-120 degrees from carbon-carbon bond
    axis = flex.vec3_double([ [0,0,0], [0,1,0] ])
    n = pdb.hierarchy.atom()
    n.element = "N"
    n.xyz = _rotateAroundAxis(f, axis,-120) + lvec3([0,0.01,0]) + lvec3([ 0.002, 0.003,-0.004])

    o = pdb.hierarchy.atom()
    o.element = "O"
    o.xyz = _rotateAroundAxis(f, axis, 120) + lvec3([0,0.01,0]) + lvec3([-0.003, 0.002, 0.003])

    # Hydrogens are +/-120 degrees from nitrogen-carbon bond
    axis = flex.vec3_double([ n.xyz, [0,1,0] ])
    h1 = pdb.hierarchy.atom()
    h1.element = "H"
    h1.xyz = _rotateAroundAxis(p, axis,-120) + lvec3([0,0.01,0]) + lvec3([-0.008, 0.001, 0.008])

    h2 = pdb.hierarchy.atom()
    h2.element = "H"
    h2.xyz = _rotateAroundAxis(p, axis, 120) + lvec3([0,0.01,0]) + lvec3([ 0.007,-0.001, 0.007])

    # Build the hierarchy so we can reset the i_seq values.
    ag = pdb.hierarchy.atom_group()
    ag.append_atom(h1)
    ag.append_atom(h2)
    ag.append_atom(n)
    ag.append_atom(o)
    ag.append_atom(p)
    ag.append_atom(f)
    ag.append_atom(fh1)
    ag.append_atom(fh2)
    ag.append_atom(ln)
    ag.append_atom(lnh1)
    ag.append_atom(lnh2)
    ag.append_atom(ca)
    rg = pdb.hierarchy.residue_group()
    rg.append_atom_group(ag)
    c = pdb.hierarchy.chain()
    c.append_residue_group(rg)
    m = pdb.hierarchy.model()
    m.append_chain(c)
    m.atoms().reset_i_seq()

    bondedNeighborLists = {}
    bondedNeighborLists[h1] = [ n ]
    bondedNeighborLists[h2] = [ n ]
    bondedNeighborLists[n] = [ h1, h2, p ]
    bondedNeighborLists[o] = [ p ]
    bondedNeighborLists[p] = [ n, o, f ]
    bondedNeighborLists[f] = [ p, ln, fh1, fh2 ]
    bondedNeighborLists[fh1] = [ f ]
    bondedNeighborLists[fh2] = [ f ]
    bondedNeighborLists[ln] = [ f, ca, lnh1, lnh2 ]
    bondedNeighborLists[lnh1] = [ ln ]
    bondedNeighborLists[lnh2] = [ ln ]
    bondedNeighborLists[ca] = [ ln ]

    mover = MoverAmideFlip(n, ca.name, bondedNeighborLists, 0.5)
    fixedUp = mover.FixUp(1).positions

    # Ensure that the results meet the specifications:
    # 1) New Oxygen on the line from the alpha carbon to the old Nitrogen
    # 2) New plane of Oxygen, Nitrogen, Alpha Carbon matches old plane, but flipped
    # 3) Pivot and linker Carbons and Hydrogens move slightly due to rigid-body motion

    newODir = (fixedUp[3] - lvec3(ca.xyz)).normalize()
    oldNDir = (rvec3(n.xyz) - rvec3(ca.xyz)).normalize()
    if (newODir * oldNDir)[0] < 0.9999:
      return "Movers.Test() MoverAmideFlip linked: Bad oxygen alignment: "+str((newODir * oldNDir)[0])

    newNDir = (fixedUp[2] - lvec3(ca.xyz)).normalize()
    oldODir = (rvec3(o.xyz) - rvec3(ca.xyz)).normalize()
    newNormal = (scitbx.matrix.cross_product_matrix(lvec3(newNDir)) * rvec3(newODir)).normalize()
    oldNormal = (scitbx.matrix.cross_product_matrix(lvec3(oldNDir)) * rvec3(oldODir)).normalize()
    dot = (lvec3(newNormal) * rvec3(oldNormal))[0]
    if dot > -0.99999:
      return "Movers.Test() MoverAmideFlip linked: Bad plane alignment: "+str(dot)

    dCarbon = (fixedUp[4] - lvec3(p.xyz)).length()
    if dCarbon < 0.0006 or dCarbon > 0.1:
      return "Movers.Test() MoverAmideFlip linked: Bad hinge motion: "+str(dCarbon)

    dCarbon = (fixedUp[5] - lvec3(f.xyz)).length()
    if dCarbon < 0.0004 or dCarbon > 0.1:
      return "Movers.Test() MoverAmideFlip linked: Bad pivot motion: "+str(dCarbon)

    dCarbon = (fixedUp[6] - lvec3(ln.xyz)).length()
    if dCarbon < 0.0002 or dCarbon > 0.1:
      return "Movers.Test() MoverAmideFlip linked: Bad linker motion: "+str(dCarbon)

    # Hydrogens come after all linkers
    dHydrogen = (fixedUp[7] - lvec3(fh1.xyz)).length()
    if dHydrogen < 0.0004 or dHydrogen > 0.1:
      return "Movers.Test() MoverAmideFlip linked: Bad pivot hydrogen motion: "+str(dHydrogen)

    dHydrogen = (fixedUp[8] - lvec3(fh2.xyz)).length()
    if dHydrogen < 0.0004 or dHydrogen > 0.1:
      return "Movers.Test() MoverAmideFlip linked: Bad pivot hydrogen motion: "+str(dHydrogen)

    dHydrogen = (fixedUp[9] - lvec3(lnh1.xyz)).length()
    if dHydrogen < 0.0002 or dHydrogen > 0.1:
      return "Movers.Test() MoverAmideFlip linked: Bad linker hydrogen motion: "+str(dHydrogen)

    dHydrogen = (fixedUp[10] - lvec3(lnh2.xyz)).length()
    if dHydrogen < 0.0002 or dHydrogen > 0.1:
      return "Movers.Test() MoverAmideFlip linked: Bad linker hydrogen motion: "+str(dHydrogen)

    # Ensure that the Hydrogens moved along with their parent in the flip.
    dHydrogen = (fixedUp[0] - fixedUp[2]).length()
    oldDHydrogen = (lvec3(h1.xyz)-lvec3(n.xyz)).length()
    if abs(dHydrogen-oldDHydrogen) > 0.0001:
      return "Movers.Test() MoverAmideFlip linked: Bad nitrogen-hydrogen motion: "+str(dHydrogen-oldDHydrogen)

    dHydrogen = (fixedUp[1] - fixedUp[2]).length()
    oldDHydrogen = (lvec3(h2.xyz)-lvec3(n.xyz)).length()
    if abs(dHydrogen-oldDHydrogen) > 0.0001:
      return "Movers.Test() MoverAmideFlip linked: Bad nitrogen-hydrogen motion: "+str(dHydrogen-oldDHydrogen)

    # Test the PoseDescription
    if mover.PoseDescription(0, 0, True) != "Unflipped . . .":
      return "Movers.Test() MoverAmideFlip: Unexpected results for PoseDescription 0T, got "+mover.PoseDescription(0,0, True)
    if mover.PoseDescription(1, 0, False) != "Flipped . . AnglesNotAdjusted":
      return "Movers.Test() MoverAmideFlip: Unexpected results for PoseDescription 1F, got "+mover.PoseDescription(1,0, False)
    if mover.PoseDescription(1, 0, True) != "Flipped . . AnglesAdjusted":
      return "Movers.Test() MoverAmideFlip: Unexpected results for PoseDescription 1T, got "+mover.PoseDescription(1,0, True)

  except Exception as e:
    return "Movers.Test() MoverAmideFlip linked: Exception during test: "+str(e)+"\n"+traceback.format_exc()

  # Test the MoverHisFlip class.
  try:
    # Test behavior with offsets for each atom so that we test the generic case.
    # Construct a MoverHisFlip that has the ring atoms other than CG located (non-physically)
    # slightly in the +Y direction out of the X-Z plane, with ring atoms and Hydrogens
    # not actually in a ring but with the same topology.
    # They are bonded to a partner (hinge/CG) and friend (pivot/CB) and alpha carbon that are on the Z axis.
    # Non-physically, atoms are 1 unit apart.
    p = pdb.hierarchy.atom()
    p.element = "C"
    p.xyz = [ 0.0, 0.0, 0.0 ]

    f = pdb.hierarchy.atom()
    f.element = "C"
    f.xyz = [ 0.0, 0.0,-1.0 ]

    fh1 = pdb.hierarchy.atom()
    fh1.element = "H"
    fh1.xyz = [ 1.0, 0.0,-1.0 ]

    fh2 = pdb.hierarchy.atom()
    fh2.element = "H"
    fh2.xyz = [-1.0, 0.0,-1.0 ]

    ca = pdb.hierarchy.atom()
    ca.element = "C"
    ca.xyz = [ 0.0, 0.0,-2.0 ]

    # Put the four ring atoms and their Hydrogens in a lattice with H stickout out in X.
    nd1 = pdb.hierarchy.atom()
    nd1.element = "N"
    nd1.xyz = lvec3([ 1.0, 0.0, 1.0]) + lvec3([0,0.01,0]) + lvec3([-0.003, 0.002, 0.003])

    nd1h = pdb.hierarchy.atom()
    nd1h.element = "H"
    nd1h.xyz = [ 2.0, 0.01, 1.0 ]

    ce1 = pdb.hierarchy.atom()
    ce1.element = "C"
    ce1.xyz = lvec3([ 1.0, 0.0, 2.1]) + lvec3([0,0.01,0]) + lvec3([-0.008, 0.001, 0.008])

    ce1h = pdb.hierarchy.atom()
    ce1h.element = "H"
    ce1h.xyz = [ 2.0, 0.01, 2.0 ]

    cd2 = pdb.hierarchy.atom()
    cd2.element = "C"
    cd2.xyz = lvec3([-1.0, 0.0, 1.0]) + lvec3([0,0.01,0]) + lvec3([ 0.007,-0.001, 0.007])

    cd2h = pdb.hierarchy.atom()
    cd2h.element = "H"
    cd2h.xyz = [-2.0, 0.01, 1.0 ]

    ne2 = pdb.hierarchy.atom()
    ne2.element = "N"
    ne2.xyz = lvec3([-1.0, 0.0, 2.0]) + lvec3([0,0.01,0]) + lvec3([-0.002, 0.005, 0.004])

    ne2h = pdb.hierarchy.atom()
    ne2h.element = "H"
    ne2h.xyz = [-2.0, 0.01, 2.0 ]

    # Build the hierarchy so we can reset the i_seq values.
    ag = pdb.hierarchy.atom_group()
    ag.append_atom(nd1)
    ag.append_atom(nd1h)
    ag.append_atom(ce1)
    ag.append_atom(ce1h)
    ag.append_atom(cd2)
    ag.append_atom(cd2h)
    ag.append_atom(ne2)
    ag.append_atom(ne2h)
    ag.append_atom(p)
    ag.append_atom(f)
    ag.append_atom(fh1)
    ag.append_atom(fh2)
    ag.append_atom(ca)
    rg = pdb.hierarchy.residue_group()
    rg.append_atom_group(ag)
    c = pdb.hierarchy.chain()
    c.append_residue_group(rg)
    m = pdb.hierarchy.model()
    m.append_chain(c)
    m.atoms().reset_i_seq()

    # Prepare our bonded-neighbor information
    bondedNeighborLists = {}
    bondedNeighborLists[nd1] = [ nd1h, p, ce1 ]
    bondedNeighborLists[nd1h] = [ nd1 ]
    bondedNeighborLists[ce1] = [ ce1h, nd1, ne2 ]
    bondedNeighborLists[ce1h] = [ ce1 ]
    bondedNeighborLists[cd2] = [ cd2h, p, ne2 ]
    bondedNeighborLists[cd2h] = [ cd2 ]
    bondedNeighborLists[ne2] = [ ne2h, cd2, ce1 ]
    bondedNeighborLists[ne2h] = [ ne2 ]
    bondedNeighborLists[p] = [ nd1, cd2, f ]
    bondedNeighborLists[f] = [ p, ca, fh1, fh2 ]
    bondedNeighborLists[fh1] = [ f ]
    bondedNeighborLists[fh2] = [ f ]
    bondedNeighborLists[ca] = [ f ]

    # Prepare our extraAtomInfoMap
    atoms = c.atoms()
    extras = []
    for a in atoms:
      extras.append(probe.ExtraAtomInfo())
    extrasMap = probe.ExtraAtomInfoMap(atoms, extras)

    mover = MoverHisFlip(ne2, bondedNeighborLists, extrasMap, 0.5)

    # Ensure that the coarse-flip results meet the expections (spot check 4th position):
    # 1) N and C atoms are flipped in pairs
    # 2) H remain at the same distance from the new locations.

    coarse = mover.CoarsePositions()
    if len(coarse.positions) != 8:
      return "Movers.Test() MoverHisFlip: Did not find 8 locations: found "+str(len(coarse.positions))
    if coarse.preferenceEnergies[0] <= coarse.preferenceEnergies[4]:
      return "Movers.Test() MoverHisFlip: Original orientation not preferred"
    if coarse.preferenceEnergies[0] >= coarse.preferenceEnergies[1]:
      return "Movers.Test() MoverHisFlip: Hydrogen removal not preferred"
    if coarse.preferenceEnergies[3] >= coarse.preferenceEnergies[0]:
      return "Movers.Test() MoverHisFlip: Both Hydrogen removal preferred"
    newPos = coarse.positions[4]
    dist = (lvec3(newPos[0]) - lvec3(ce1.xyz)).length()
    if dist > 0.01:
      return "Movers.Test() MoverHisFlip: NE2 moved incorrectly: "+str(dist)
    dist = (lvec3(newPos[2]) - lvec3(ne2.xyz)).length()
    if dist > 0.01:
      return "Movers.Test() MoverHisFlip: CE1 moved incorrectly: "+str(dist)
    dist = (lvec3(newPos[4]) - lvec3(cd2.xyz)).length()
    if dist > 0.01:
      return "Movers.Test() MoverHisFlip: ND1 moved incorrectly: "+str(dist)
    dist = (lvec3(newPos[6]) - lvec3(nd1.xyz)).length()
    if dist > 0.01:
      return "Movers.Test() MoverHisFlip: CD2 moved incorrectly: "+str(dist)

    dHydrogen = (lvec3(newPos[0]) - lvec3(newPos[1])).length()
    oldDHydrogen = (lvec3(ne2h.xyz)-lvec3(ne2.xyz)).length()
    if abs(dHydrogen - oldDHydrogen) > 0.0001:
      return "Movers.Test() MoverHisFlip: Bad coarse NE2 hydrogen motion: "+str(dHydrogen-oldDHydrogen)

    dHydrogen = (lvec3(newPos[2]) - lvec3(newPos[3])).length()
    oldDHydrogen = (lvec3(ce1h.xyz)-lvec3(ce1.xyz)).length()
    if abs(dHydrogen - oldDHydrogen) > 0.0001:
      return "Movers.Test() MoverHisFlip: Bad coarse CE1 hydrogen motion: "+str(dHydrogen-oldDHydrogen)

    dHydrogen = (lvec3(newPos[4]) - lvec3(newPos[5])).length()
    oldDHydrogen = (lvec3(nd1h.xyz)-lvec3(nd1.xyz)).length()
    if abs(dHydrogen - oldDHydrogen) > 0.0001:
      return "Movers.Test() MoverHisFlip: Bad coarse ND1 hydrogen motion: "+str(dHydrogen-oldDHydrogen)

    dHydrogen = (lvec3(newPos[6]) - lvec3(newPos[7])).length()
    oldDHydrogen = (lvec3(cd2h.xyz)-lvec3(cd2.xyz)).length()
    if abs(dHydrogen - oldDHydrogen) > 0.0001:
      return "Movers.Test() MoverHisFlip: Bad coarse ND1 hydrogen motion: "+str(dHydrogen-oldDHydrogen)

    # Ensure that the FixUp results meet the specifications (spot check 4th position):
    # 1) New CE1 on the line from the alpha carbon to the old NE2
    # 2) The line from the new NE2 to the alpha carbon lies on the
    #    line from the original CE1 to the alpha carbon
    # 3) New plane of CE1, NE2, Alpha Carbon matches old plane, but flipped
    # 4) Carbons and pivot Hydrogens move slightly due to rigid-body motion

    fixedUp = mover.FixUp(4).positions
    newCE1Dir = (fixedUp[2] - lvec3(ca.xyz)).normalize()
    oldNE2Dir = (rvec3(ne2.xyz) - rvec3(ca.xyz)).normalize()
    if (newCE1Dir * oldNE2Dir)[0] < 0.9999:
      return "Movers.Test() MoverHisFlip: Bad CE1 alignment: "+str((newCE1Dir * oldNE2Dir)[0])

    newNE2Dir = (fixedUp[0] - lvec3(ca.xyz)).normalize()
    oldCE1Dir = (rvec3(ce1.xyz) - rvec3(ca.xyz)).normalize()
    if (newNE2Dir * oldCE1Dir)[0] < 0.9999:
      return "Movers.Test() MoverHisFlip: Bad NE2 alignment: "+str((newNE2Dir * oldCE1Dir)[0])

    newNormal = (scitbx.matrix.cross_product_matrix(lvec3(newNE2Dir)) * rvec3(newCE1Dir)).normalize()
    oldNormal = (scitbx.matrix.cross_product_matrix(lvec3(oldNE2Dir)) * rvec3(oldCE1Dir)).normalize()
    dot = (lvec3(newNormal) * rvec3(oldNormal))[0]
    if dot > -0.99999:
      return "Movers.Test() MoverHisFlip: Bad plane alignment: "+str(dot)

    dCarbon = (fixedUp[8] - lvec3(p.xyz)).length()
    if dCarbon < 0.001 or dCarbon > 0.1:
      return "Movers.Test() MoverHisFlip: Bad hinge motion: "+str(dCarbon)

    dCarbon = (fixedUp[9] - lvec3(f.xyz)).length()
    if dCarbon < 0.0005 or dCarbon > 0.1:
      return "Movers.Test() MoverHisFlip: Bad pivot motion: "+str(dCarbon)

    dHydrogen = (fixedUp[10] - lvec3(fh1.xyz)).length()
    if dHydrogen < 0.0005 or dHydrogen > 0.1:
      return "Movers.Test() MoverHisFlip: Bad pivot hydrogen motion: "+str(dHydrogen)

    dHydrogen = (fixedUp[11] - lvec3(fh2.xyz)).length()
    if dHydrogen < 0.0005 or dHydrogen > 0.1:
      return "Movers.Test() MoverHisFlip: Bad pivot hydrogen motion: "+str(dHydrogen)

    # Ensure that the Hydrogens moved along with their parent in the flip.
    dHydrogen = (fixedUp[0] - fixedUp[1]).length()
    oldDHydrogen = (lvec3(ne2h.xyz)-lvec3(ne2.xyz)).length()
    if abs(dHydrogen-oldDHydrogen) > 0.0001:
      return "Movers.Test() MoverHisFlip: Bad NE2-hydrogen motion: "+str(dHydrogen-oldDHydrogen)

    dHydrogen = (fixedUp[2] - fixedUp[3]).length()
    oldDHydrogen = (lvec3(ce1h.xyz)-lvec3(ce1.xyz)).length()
    if abs(dHydrogen-oldDHydrogen) > 0.0001:
      return "Movers.Test() MoverHisFlip: Bad CE1-hydrogen motion: "+str(dHydrogen-oldDHydrogen)

    dHydrogen = (fixedUp[4] - fixedUp[5]).length()
    oldDHydrogen = (lvec3(nd1h.xyz)-lvec3(nd1.xyz)).length()
    if abs(dHydrogen-oldDHydrogen) > 0.0001:
      return "Movers.Test() MoverHisFlip: Bad ND1-hydrogen motion: "+str(dHydrogen-oldDHydrogen)

    dHydrogen = (fixedUp[6] - fixedUp[7]).length()
    oldDHydrogen = (lvec3(cd2h.xyz)-lvec3(cd2.xyz)).length()
    if abs(dHydrogen-oldDHydrogen) > 0.0001:
      return "Movers.Test() MoverHisFlip: Bad CD2-hydrogen motion: "+str(dHydrogen-oldDHydrogen)

    # Ensure that the extraInfo and deleteMe information matches expectations:
    # 1) First hydrogen removed and first N is an acceptor on % = 1
    # 2) Second hydrogen removed and second N is an acceptor on % = 2
    for i in range(6):
      coarseNE2Accept = coarse.extraInfos[i][0].isAcceptor
      coarseNE2HDelete = coarse.deleteMes[i][1]
      fixedUpNE2Accept = mover.FixUp(i).extraInfos[0].isAcceptor
      fixedUpNE2HDelete = mover.FixUp(i).deleteMes[1]
      coarseND1Accept = coarse.extraInfos[i][4].isAcceptor
      coarseND1HDelete = coarse.deleteMes[i][5]
      fixedUpND1Accept = mover.FixUp(i).extraInfos[4].isAcceptor
      fixedUpND1HDelete = mover.FixUp(i).deleteMes[5]
      if i % 4 == 1 or i % 4 == 3:
        if not coarseNE2Accept:
          return "Movers.Test() MoverHisFlip: No NE2 acceptor, pos "+str(i)
        if not coarseNE2HDelete:
          return "Movers.Test() MoverHisFlip: Missing NE2 hydrygen deletion, pos "+str(i)
        if not fixedUpNE2Accept:
          return "Movers.Test() MoverHisFlip: No fixup NE2 acceptor, pos "+str(i)
        if not fixedUpNE2HDelete:
          return "Movers.Test() MoverHisFlip: Missing fixup NE2 hydrygen deletion, pos "+str(i)
      else:
        if coarseNE2Accept:
          return "Movers.Test() MoverHisFlip: Unexpected NE2 acceptor, pos "+str(i)
        if coarseNE2HDelete:
          return "Movers.Test() MoverHisFlip: Unexpected NE2 hydrygen deletion, pos "+str(i)
        if fixedUpNE2Accept:
          return "Movers.Test() MoverHisFlip: Unexpected fixup NE2 acceptor, pos "+str(i)
        if fixedUpNE2HDelete:
          return "Movers.Test() MoverHisFlip: Unexpected fixup NE2 hydrygen deletion, pos "+str(i)
      if i % 4 == 2 or i % 4 == 3:
        if not coarseND1Accept:
          return "Movers.Test() MoverHisFlip: No ND1 acceptor, pos "+str(i)
        if not coarseND1HDelete:
          return "Movers.Test() MoverHisFlip: Missing ND1 hydrygen deletion, pos "+str(i)
        if not fixedUpND1Accept:
          return "Movers.Test() MoverHisFlip: No fixup ND1 acceptor, pos "+str(i)
        if not fixedUpND1HDelete:
          return "Movers.Test() MoverHisFlip: Missing fixup ND1 hydrygen deletion, pos "+str(i)
      else:
        if coarseND1Accept:
          return "Movers.Test() MoverHisFlip: Unexpected ND1 acceptor, pos "+str(i)
        if coarseND1HDelete:
          return "Movers.Test() MoverHisFlip: Unexpected ND1 hydrygen deletion, pos "+str(i)
        if fixedUpND1Accept:
          return "Movers.Test() MoverHisFlip: fixup Unexpected ND1 acceptor, pos "+str(i)
        if fixedUpND1HDelete:
          return "Movers.Test() MoverHisFlip: fixup Unexpected ND1 hydrygen deletion, pos "+str(i)

    # Test the PoseDescription
    if mover.PoseDescription(1,0, False) != "Unflipped HD1Placed HE2NotPlaced .":
      return "Movers.Test() MoverHisFlip: Unexpected results for PoseDescription 1, got "+mover.PoseDescription(1,0, False)
    if mover.PoseDescription(2,0, False) != "Unflipped HD1NotPlaced HE2Placed .":
      return "Movers.Test() MoverHisFlip: Unexpected results for PoseDescription 2, got "+mover.PoseDescription(2,0, False)
    if mover.PoseDescription(3,0, False) != "Unflipped HD1NotPlaced HE2NotPlaced .":
      return "Movers.Test() MoverHisFlip: Unexpected results for PoseDescription 3, got "+mover.PoseDescription(3,0, False)
    if mover.PoseDescription(4,0, True) != "Flipped HD1Placed HE2Placed AnglesAdjusted":
      return "Movers.Test() MoverHisFlip: Unexpected results for PoseDescription 4, got "+mover.PoseDescription(4,0, True)

    # Verify that the coarse and fine results don't change when the atom position is moved after
    # the Mover has been constructed.
    if not _StableUnderAtomMotion(mover, ne2):
      return "Movers.Test() MoverHisFlip: Positions not stable when atom moved"

    # Try locking down the state to only non-flipped and then only flipped and make sure we get
    # the expected number of states and behavior.
    mover = MoverHisFlip(ne2, bondedNeighborLists, extrasMap, 0.5, 1, True)
    if len(mover.CoarsePositions().positions) != 4:
      return "Movers.Test() MoverHisFlip: Unexpected position count for Unflipped, got "+len(mover.CoarsePositions().positions)
    if 'Unflipped' not in mover.PoseDescription(0, 0, False):
      return "Movers.Test() MoverHisFlip: Unexpected PoseDescription for Unflipped, got "+mover.PoseDescription(0, 0, False)
    if '.' != mover.PoseDescription(0, 0, True).split()[-1]:
      return "Movers.Test() MoverHisFlip: Unexpected angle description Unflipped, got "+mover.PoseDescription(0, 0, False)
    mover = MoverHisFlip(ne2, bondedNeighborLists, extrasMap, 0.5, 2, True)
    if len(mover.CoarsePositions().positions) != 4:
      return "Movers.Test() MoverHisFlip: Unexpected position count for Flipped, got "+len(mover.CoarsePositions().positions)
    if 'Flipped' not in mover.PoseDescription(0, 0, True):
      return "Movers.Test() MoverHisFlip: Unexpected PoseDescription for Flipped, got "+mover.PoseDescription(0, 0, False)
    if 'AnglesAdjusted' != mover.PoseDescription(0, 0, True).split()[-1]:
      return "Movers.Test() MoverHisFlip: Unexpected angle description Flipped, got "+mover.PoseDescription(0, 0, True)
    if 'AnglesNotAdjusted' != mover.PoseDescription(0, 0, False).split()[-1]:
      return "Movers.Test() MoverHisFlip: Unexpected angle description Flipped, got "+mover.PoseDescription(0, 0, False)

  except Exception as e:
    return "Movers.Test() MoverHisFlip: Exception during test: "+str(e)+"\n"+traceback.format_exc()

  return ""

##################################################################################
# If we're run on the command line, test our classes and functions.
if __name__ == '__main__':

  ret = Test()
  if len(ret) == 0:
    print('Success!')
  else:
    print(ret)

  assert (len(ret) == 0)


 *******************************************************************************


 *******************************************************************************
mmtbx/reduce/Optimizers.py
##################################################################################
#                Copyright 2021-2023 Richardson Lab at Duke University
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import print_function, nested_scopes, generators, division
from __future__ import absolute_import

import argparse, re

from boost_adaptbx import graph
from boost_adaptbx.graph import connected_component_algorithm as cca

from iotbx.map_model_manager import map_model_manager
from iotbx.data_manager import DataManager
from iotbx.pdb import common_residue_names_get_class
import mmtbx
from scitbx.array_family import flex

# To enable addition of Hydrogens
# @todo See if we can remove the shift and box once reduce_hydrogen is complete
from cctbx.maptbx.box import shift_and_box_model
from mmtbx.hydrogens import reduce_hydrogen

import boost_adaptbx.boost.python as bp
bp.import_ext("mmtbx_probe_ext")
import mmtbx_probe_ext as probeExt
from mmtbx.probe import Helpers
from mmtbx.reduce import Movers, InteractionGraph

bp.import_ext("mmtbx_reduce_ext")
from mmtbx_reduce_ext import OptimizerC, Optimizers_test

##################################################################################
# This file includes a set of functions and classes that implement placement and optimization of
# Reduce's "Movers".

##################################################################################
# Module variables that affect the way computations are handled

_DoCliqueOptimizationInC = True

##################################################################################
# Helper functions

def _VerboseCheck(verbosity, level, message):
  # Returns "" if the level is less than verbosity level, message if it is at or above
  if verbosity >= level:
    return " "*level + message
  else:
    return ""

_lastTime = None
def _ReportTiming(verbosity, message):
  """Use None message to start the timer without printing.
  """
  import time

  global _lastTime
  if message is None:
    _lastTime = time.time()
    return
  curTime = time.time()
  diff = curTime - _lastTime
  _lastTime = curTime
  return _VerboseCheck(verbosity, 2,"Time to {}: {:0.3f}".format(message,diff)+"\n")

def AlternatesInModel(model):
  """Returns a set of altloc names of all conformers in all chains.
  :param model: pdb.hierarchy.model to search for alternates.
  :return: Set of strings.  The set is will include only the empty string if no
  chains in the model have alternates.  It has an additional entry for every altloc
  found in every chain.
  """
  ret = set(['']) # We always add this so that it will be present even when there are alternates
  for c in model.chains():
    for alt in c.conformers():
      ret.add(alt.altloc)
  return ret

def GetAtomsForConformer(model, conf):
  """Returns a list of atoms in the named conformer.  It also includes atoms from
  the first conformation in chains that do not have this conformation, to provide a
  complete model.  For a model whose chains have only one conformer, it will return
  all of the atoms.
  :param model: pdb.hierarchy.model to search for atoms.
  :param conf: String name of the conformation to find.  Can be "", which finds the
  default conformer; if there is no empty conformation, then it will
  pick the first available conformation for each atom group.
  :return: List of atoms consistent with the specified conformer.
  """
  ret = []
  for ch in model.chains():
    confs = ch.conformers()
    which = 0
    for i in range(1,len(confs)):
      if confs[i].altloc == conf:
        which = i
        break
    ret += confs[which].atoms()
  return ret

def _ResNameAndID(a):
  """Make a string describing the residue and chain for the specfied atom.
  """
  chainID = a.parent().parent().parent().id
  resName = a.parent().resname.strip().upper()
  resID = str(a.parent().parent().resseq_as_int())
  altLoc = a.parent().altloc
  # Don't print the code if it is a space (blank).
  insertionCode = a.parent().parent().icode.strip()
  return "chain "+str(chainID)+" "+altLoc+resName+" "+resID+insertionCode

##################################################################################
# Helper classes

class FlipMoverState(object):
  # Holds information needed to identify a flip Mover within a model file and
  # whether or not it is flipped and has its angles adjusted.
  def __init__(self, moverType, modelId, altId, chain, resName, resIdWithICode, flipped, fixedUp):
    self.moverType = moverType  # String indicating Mover type: AmideFlip or HisFlip
    self.modelId = modelId      # Integer indicating the modelId that the entry corresponds to
    self.altId = altId          # String indicating the altId that the entry corresponds to
    self.chain = chain          # String Chain that the residue is in
    self.resName = resName      # String Name of the residue
    try:                        # String holding the integer ID of the residue and any insertion code
      self.resId = int(resIdWithICode)
      self.iCode = ''
    except Exception:
      self.resId = int(resIdWithICode[:-1])
      self.iCode = resIdWithICode[-1]
    self.flipped = flipped      # Boolean Whether the Mover is flipped in this configuration
    self.fixedUp = fixedUp      # Boolean Whether the fixup has been done on the angles

  def __str__(self):
    return "{} {} '{}' {} {} {}{} {} {}".format(self.moverType, self.modelId, self.altId,
      self.chain, self.resName, self.resId, self.iCode, self.flipped, self.fixedUp)
  def __repr__(self):
      return "Optimizers.FlipMoverState({})".format(str(self))

##################################################################################
# Optimizer, which wraps the OptimizerC class to do the optimization:

class Optimizer(object):

  def __init__(self, probePhil, addFlipMovers, model, modelIndex = 0, altID = None,
                bondedNeighborDepth = 4,
                useNeutronDistances = False,
                minOccupancy = 0.02,
                preferenceMagnitude = 1.0,
                nonFlipPreference = 0.5,
                skipBondFixup = False,
                flipStates = '',
                verbosity = 1,
                cliqueOutlineFileName = None,
                fillAtomDump = True
              ):
    """Constructor.  This is the wrapper class for the C++ OptimizerC and
    it implements the machinery that finds and optimizes Movers.
    :param probePhil: Phil parameters to Probe to be passed on when subroutines are called.
    :param addFlipMovers: Do we add flip Movers along with other types?
    :param model: iotbx model (a group of hierarchy models).  Can be obtained using
    iotbx.map_model_manager.map_model_manager.model().  The model must have Hydrogens,
    which can be added using mmtbx.hydrogens.reduce_hydrogen.place_hydrogens().get_model().
    It must have a valid unit cell, which can be helped by calling
    cctbx.maptbx.box.shift_and_box_model().  It must have had PDB interpretation run on it,
    which can be done using model.process(make_restraints=True) with PDB
    interpretation parameters and hydrogen placement matching the value of the
    useNeutronDistances parameter described below.
    :param modelIndex: Identifies which index from the hierarchy is to be selected.
    If this value is None, optimization will be run sequentially on every model in the
    hierarchy. This is 1-based, the first model is 1.
    :param altID: The conformer alternate location specifier to use.  The value "" will
    cause it to run on the first conformer found in each model.  If this is set to None,
    optimization will be run sequentially for every conformer in the model, starting with
    the last and ending with the first.  This will leave the initial conformer's values as the
    final location for atoms that are not inside a conformer or are in the first conformer.
    :param bondedNeighborDepth: How many hops to ignore bonding when doing Probe calculations.
    A depth of 3 will ignore my bonded neighbors and their bonded
    neighbors and their bonded neighbors.
    :param useNeutronDistances: False will use X-ray/electron cloud distances.  If set to
    True, it will use neutron (nuclear) distances.  This must be set consistently with the
    values used to generate the hydrogens and to run PDB interpretation.
    :param minOccupancy: Minimum occupancy for an atom to be considered in the Probe score.
    :param preferenceMagnitude: Multiplier for the preference energies expressed
    by some Movers for particular orientations.
    :param nonFlipPreference: Preference for not flipping Movers that are flips.  This keeps
    them from being flipped unless their score is significantly better than in the original position.
    :param skipBondFixup: Should we do fixup on Movers or just leave them flipped?  We always do Hydrogen
    removal and fixup for Histidines that are not placed as Movers, but for flips that
    are Movers we don't adjust the bond angles.  This is overridden for Flips that are
    specified in flipStates.
    :param flipStates: String with comma-separated entries. Each entry has the form
    (without the single quotes) '1 . A HIS 11H Flipped AnglesAdjusted'. These are space-separated values.
    The first word is the model number, starting with 1. The second is the lower-case alternate, or
    '.' for all alternates (also use this when there are no alternates in the file).
    The third is the chain ID. The fourth is the residue name. The fifth is the residue id,
    which may include an insertion code as its last character. The sixth is either Flipped or Unflipped.
    If it is Flipped, then another word is added -- AnglesAdjusted or AnglesNotAdjusted,
    specifying whether to do the three-point dock to adjust the bond angles after the flip.
    An example with several entries is (again, no quotes are included:
    '1 a A HIS 11H Unflipped,1 b A ASN 15 Flipped AnglesNotAdjusted,1 . B GLN 27 Flipped AnglesAdjusted'. Any
    Flip Movers that would be placed at the specified location are instead locked in the
    specified configuration.
    :param verbosity: Default value of 1 reports standard information.
    Value of 2 reports timing information.
    Setting it to 0 removes all informational messages.
    Setting it above 1 provides additional debugging information.
    :param cliqueOutlineFileName: Name of file to write Kinemage with outlines of Movers to.
    This file holds spheres showing all possible locations for each atom in each Mover in different
    colors as one master. It shows the outlines expanded by the probe radius, with a single color
    for each clique, as another master. These are useful for determining why the cliques are as
    they are.
    :param fillAtomDump: If true, fill in the atomDump string with the atom information.
    This can take a long time to do, so the caller may want to turn it off if they don't need it.
    """

    ################################################################################
    # Store the parameters that will be accessed by other methods
    self._probePhil = probePhil
    self._bondedNeighborDepth = bondedNeighborDepth
    self._probeRadius = probePhil.probe_radius
    self._useNeutronDistances = useNeutronDistances
    self._probeDensity = probePhil.density
    self._minOccupancy = minOccupancy
    self._preferenceMagnitude = preferenceMagnitude
    self._nonFlipPreference = nonFlipPreference
    self._skipBondFixup = skipBondFixup
    self._flipStates = flipStates
    self._verbosity = verbosity
    self._cliqueOutlineFileName = cliqueOutlineFileName

    ################################################################################
    # Initialize internal variables.
    self._infoString = ""
    self._atomDump = ""
    self._waterOccCutoff = 0.66 # @todo Make this a parameter, -WaterOCCcutoff param in reduce
    self._waterBCutoff = 40.0   # @todo Make this a parameter, -WaterBcutoff param in reduce
    self._numCalculated = 0
    self._numCached = 0

    ################################################################################
    # Get the Cartesian positions of all of the atoms in the entire model and find
    # the bond proxies for all of them.  The proxies will not attempt to bond atoms
    # that are in different model indices.
    _ReportTiming(self._verbosity, None) # Reset timer
    carts = flex.vec3_double()
    for a in model.get_atoms():
      carts.append(a.xyz)
    self._infoString += _ReportTiming(self._verbosity, "get coordinates")
    bondProxies = model.get_restraints_manager().geometry.get_all_bond_proxies(sites_cart = carts)[0]
    self._infoString += _ReportTiming(self._verbosity, "compute bond proxies")

    ################################################################################
    # Get the bonded neighbor lists for all of the atoms in the model, so we don't get
    # failures when we look up an atom from another in Helpers.getExtraAtomInfo().
    # We won't get bonds between atoms in different conformations.
    bondedNeighborLists = Helpers.getBondedNeighborLists(model.get_atoms(), bondProxies)
    self._infoString += _ReportTiming(self._verbosity, "compute bonded neighbor lists")

    ################################################################################
    # Get the probeExt.ExtraAtomInfo needed to determine which atoms are potential acceptors.
    # This is done for all atoms in the model.
    # This must operate on the entire model, not just the current model index.
    ret = Helpers.getExtraAtomInfo(
      model = model, bondedNeighborLists = bondedNeighborLists,
      useNeutronDistances=self._useNeutronDistances, probePhil=self._probePhil)
    self._extraAtomInfo = ret.extraAtomInfo
    self._infoString += ret.warnings
    self._infoString += _ReportTiming(self._verbosity, "get extra atom info")

    ################################################################################
    # Run optimization for every desired conformer and every desired model, calling
    # placement and then a derived-class single optimization routine for each.  When
    # the modelIndex or altID is None, that means to run over all available cases.
    # For alternates, if there is a non-empty (not "" or " ") case, then we run backwards
    # from the last to the first but do not run for the empty case; if there are only
    # empty cases, then we run just once.  We run the models in order, all of them when
    # None is specified and the specified one if it is specified.

    try:
      model.setup_riding_h_manager()
    except Exception:
      # If an optimized has already been run on the model, our riding H manager will
      # have already been set up.  When one has already been set up, this causes
      # an exception and it doesn't make a new one.
      pass
    riding_h_manager = model.get_riding_h_manager()
    h_parameterization = riding_h_manager.h_parameterization

    # Find the single-hydrogen rotators.
    # Dorothee provided this faster approach that uses the riding_h_manager.
    rotatableHydrogens = flex.size_t()
    for p in h_parameterization:
      if p is not None:
        if p.htype  == 'alg1b':
          rotatableHydrogens.append(p.ih)

    self._infoString += _ReportTiming(self._verbosity, "select rotatable hydrogens")

    startModelIndex = 0
    stopModelIndex = len(model.get_hierarchy().models())
    if modelIndex is not None:
      # The command-line parameter matches the name of the model in the model file, which
      # starts with 1. The internal indexing starts with 0. So we subtract one.
      startModelIndex = (modelIndex - 1)
      stopModelIndex = startModelIndex + 1
    for mi in range(startModelIndex, stopModelIndex):
      # Get the specified model from the hierarchy.
      myModel = model.get_hierarchy().models()[mi]

      ################################################################################
      # Store the states (position and extra atom info) of all of the atoms in this model
      # so that we can restore it for atoms in a given alternate configuration before optimizing
      # each new alternate. Looked up by i_seq.
      initialAtomPositions = {}
      initialExtraAtomInfos = {}
      for a in myModel.atoms():
        initialAtomPositions[a.i_seq] = a.xyz;
        initialExtraAtomInfos[a.i_seq] = probeExt.ExtraAtomInfo(self._extraAtomInfo.getMappingFor(a))

      # Get the list of alternate conformation names present in all chains for this model.
      # If there is more than one result, remove the empty results and then sort them
      # in reverse order so we finalize all non-alternate ones to match the first.
      alts = AlternatesInModel(myModel)
      if len(alts) > 1:
        alts.discard("")
        alts.discard(" ")
      alts = sorted(list(alts), reverse=True)
      self._infoString += _ReportTiming(self._verbosity, "compute alternates")

      # If there is a specified alternate, use it.
      if altID is not None:
        alts = [altID]

      # Clear the Movers list for each model.  It will be retained from one alternate to the next.
      self._movers = []
      firstAlt = True
      for alt in alts:
        # If we are doing the second or later alternate, place all atoms that are in a compatible alternate
        # back into their initial configuration so we start from the same state we would have if this were
        # the only alternate being tested.  This will ensure that we get compatible outputs when run either
        # way.
        if firstAlt:
          firstAlt = False
        else:
          for a in myModel.atoms():
            if a.parent().altloc in ['', ' ', alt]:
              a.xyz = initialAtomPositions[a.i_seq]
              self._extraAtomInfo.setMappingFor(a, initialExtraAtomInfos[a.i_seq])

        # Tell about the run we are currently doing.
        self._infoString += _VerboseCheck(self._verbosity, 1,"Running Reduce optimization on model index "+str(mi)+
          ", alternate '"+alt+"'\n")
        self._infoString += _VerboseCheck(self._verbosity, 1,"  bondedNeighborDepth = "+str(self._bondedNeighborDepth)+"\n")
        self._infoString += _VerboseCheck(self._verbosity, 1,"  probeRadius = "+str(self._probeRadius)+"\n")
        self._infoString += _VerboseCheck(self._verbosity, 1,"  useNeutronDistances = "+str(self._useNeutronDistances)+"\n")
        self._infoString += _VerboseCheck(self._verbosity, 1,"  probeDensity = "+str(self._probeDensity)+"\n")
        self._infoString += _VerboseCheck(self._verbosity, 1,"  minOccupancy = "+str(self._minOccupancy)+"\n")
        self._infoString += _VerboseCheck(self._verbosity, 1,"  preferenceMagnitude = "+str(self._preferenceMagnitude)+"\n")

        # Get the atoms from the specified conformer in the model (the empty string is the name
        # of the first conformation in the model; if there is no empty conformation, then it will
        # pick the first available conformation for each atom group.
        self._atoms = GetAtomsForConformer(myModel, alt)

        ################################################################################
        # Reset the timer
        _ReportTiming(self._verbosity, None)

        ################################################################################
        # Construct the spatial-query information needed to quickly determine which atoms are nearby
        self._spatialQuery = Helpers.createSpatialQuery(self._atoms, self._probePhil)
        self._infoString += _ReportTiming(self._verbosity, "construct spatial query")

        ################################################################################
        # Find the radius of the largest atom we'll have to deal with.
        maxVDWRad = 1
        for a in self._atoms:
          maxVDWRad = max(maxVDWRad, self._extraAtomInfo.getMappingFor(a).vdwRadius)
        self._maximumVDWRadius = maxVDWRad

        ################################################################################
        # Make a set of atoms that are to be deleted based on analysis.  It is initially
        # empty, keeping all of the added Hydrogens in the model.
        self._deleteMes = set()

        ################################################################################
        # Placement of water phantom Hydrogens, including adding them to our 'atoms' list
        # and the spatial query but not adding them to the hierarchy.  This must be done after
        # the bond proxies are constructed and the Movers have been placed so that these
        # fake atoms do not confuse placement.
        # These atoms will not be part of any atom group, and we'll fill in their extra atom
        # info directly.

        # @todo Look up the radius of a water Hydrogen.  This may require constructing a model with
        # a single water in it and asking about the hydrogen radius.  This could also become a
        # Phil parameter.  Also look up the OH bond distance rather than hard-coding it here.
        phantomHydrogenRadius = 1.05
        placedHydrogenDistance = 0.84
        if useNeutronDistances:
          phantomHydrogenRadius = 1.0
          placedHydrogenDistance = 0.98

        # Find every Oxygen that is part of a water and get the Phantom Hydrogens for it
        # unless it has out-of-bounds parameter values.  If the water Oxygen has out-of-bounds
        # parameters, then we remove it from the atoms to be considered (but not from the
        # model) by removing them from the atom list and from the spatial query structure.
        phantoms = [] # List of tuples, the Phantom and its parent Oxygen
        watersToDelete = []
        maxISeq = Helpers.getMaxISeq(model)
        for a in self._atoms:
          if a.element == 'O' and common_residue_names_get_class(name=a.parent().resname) == "common_water":
            if a.occ >= self._waterOccCutoff and a.b < self._waterBCutoff:

              # We're an acceptor and not a donor.
              ei = self._extraAtomInfo.getMappingFor(a)
              ei.isDonor = False
              ei.isAcceptor = True
              self._extraAtomInfo.setMappingFor(a, ei)

              newPhantoms = Helpers.getPhantomHydrogensFor(maxISeq, a, self._spatialQuery, self._extraAtomInfo, self._minOccupancy,
                              False, phantomHydrogenRadius, placedHydrogenDistance)
              if len(newPhantoms) > 0:
                resNameAndID = _ResNameAndID(a)
                self._infoString += _VerboseCheck(self._verbosity, 3,"Added {} phantom Hydrogens on {}\n".format(len(newPhantoms), resNameAndID))
                for p in newPhantoms:
                  self._infoString += _VerboseCheck(self._verbosity, 5,"Added phantom Hydrogen at "+str(p.xyz)+"\n")
                  phantoms.append( (p,a) )

            else:
              # Occupancy or B factor are out of bounds, so remove this atom from consideration.
              self._infoString += _VerboseCheck(self._verbosity, 3,"Ignoring "+
                a.name.strip()+" "+a.parent().resname.strip()+" "+str(a.parent().parent().resseq_as_int())+
                " "+str(a.parent().parent().parent().id)+
                " with occupancy "+str(a.occ)+" and B factor "+str(a.b)+"\n")
              watersToDelete.append(a)

        if len(watersToDelete) > 0:
          self._infoString += _VerboseCheck(self._verbosity, 1,"Ignored "+str(len(watersToDelete))+" waters due to occupancy or B factor\n")
          for a in watersToDelete:
            self._atoms.remove(a)
            self._spatialQuery.remove(a)

        if len(phantoms) > 0:

          # Add these atoms to the list of atoms we deal with.
          # Add these atoms to the spatial-query structure.
          # Insert ExtraAtomInfo for each of these atoms, marking each as a dummy and as a donor.
          # Add to the bondedNeighborList with their parent Oxygen as bonded one way so that dots on
          # a Phantom Hydrogen within its Oxygen will be excluded.  Do not mark the Oxygen as being
          # bonded to the Phantom Hydrogen to avoid having it mask collisions between the Oxygen and
          # other atoms.
          origCount = len(self._atoms)
          for p in phantoms:
            self._atoms.append(p[0])
            self._spatialQuery.add(p[0])
            eai = probeExt.ExtraAtomInfo(phantomHydrogenRadius, False, True, True)
            self._extraAtomInfo.setMappingFor(p[0], eai)
            bondedNeighborLists[p[0]] = [p[1]]

          self._infoString += _VerboseCheck(self._verbosity, 1,"Added "+str(len(phantoms))+" phantom Hydrogens on waters")
          self._infoString += _VerboseCheck(self._verbosity, 1," (Old total "+str(origCount)+", new total "+str(len(self._atoms))+")\n")
        self._infoString += _ReportTiming(self._verbosity, "place water phantom Hydrogens")

        ################################################################################
        # Fix up the donor status for all of the atoms now that we've added the final explicit
        # Phantom Hydrogens.
        Helpers.fixupExplicitDonors(self._atoms, bondedNeighborLists, self._extraAtomInfo)
        self._infoString += _ReportTiming(self._verbosity, "fixup explicit doners")

        ################################################################################
        # Get the list of Movers using the _PlaceMovers private function.
        # The list of rotatable hydrogens comes from the global model, not just the current
        # model index.  However, we only place on atoms that are also in self._atoms, which
        # only includes those from the current model index.
        # NOTE: We must do this after fixupExplicitDonors() so that the Hydrogens are properly
        # marked as donors.
        deleteAtoms = self._PlaceMovers(self._atoms, rotatableHydrogens, bondedNeighborLists, h_parameterization,
                           addFlipMovers)
        self._infoString += _VerboseCheck(self._verbosity, 1,"Inserted "+str(len(self._movers))+" Movers\n")
        self._infoString += _VerboseCheck(self._verbosity, 1,'Marked '+str(len(deleteAtoms))+' atoms for deletion\n')
        self._infoString += _ReportTiming(self._verbosity, "place movers")

        ################################################################################
        # Add the atoms that were unconditionally marked for deletion during placement
        # to the set of atoms to delete.
        self._deleteMes = self._deleteMes.union(deleteAtoms)

        ################################################################################
        # Initialize the Movers to their starting coarse positions.
        for m in self._movers:
          pr = m.CoarsePositions()
          self._setMoverState(pr, 0)
        self._infoString += _ReportTiming(self._verbosity, "initialize Movers")

        ################################################################################
        # Compute the interaction graph, of which each connected component is a Clique.
        # Get a list of singleton Cliques and a list of other Cliques.  Keep separate lists
        # of the singletons and the groups.
        self._interactionGraph, self._atomMoverLists = InteractionGraph.InteractionGraphAllPairs(self._movers,
          self._extraAtomInfo, probeRadius=self._probeRadius)
        components = cca.connected_components( graph = self._interactionGraph )
        maxLen = 0
        singletonCliques = []   # Each entry is a list of integer indices into models with one entry
        groupCliques = []       # Each entry is a list of integer indices into models with >1 entry
        for c in components:
          if len(c) == 1:
            singletonCliques.append(c)
          else:
            groupCliques.append(c)
          if len(c) > maxLen:
            maxLen = len(c)
        self._infoString += _VerboseCheck(self._verbosity, 1,"Found "+str(len(components))+" Cliques ("+
            str(len(singletonCliques))+" are singletons); largest Clique size = "+
            str(maxLen)+"\n")
        self._infoString += _ReportTiming(self._verbosity, "compute interaction graph")

        # If we've been asked to write an interaction graph file, do so.
        if self._cliqueOutlineFileName:
          with open(self._cliqueOutlineFileName, 'w') as f:
            f.write(self._InteractionKinemage(groupCliques))

        ################################################################################
        # Determine excluded atoms to a specified hop count for each atom that will
        # be moved.  Make a dictionary of lists that includes all atoms in all Movers.

        # Get the set of all atoms that can be returned from all conformations of all Movers.
        moverAtoms = set()
        for m in self._movers:
          for a in m.CoarsePositions().atoms:
            moverAtoms.add(a)
          for a in m.FixUp(0).atoms:
            moverAtoms.add(a)

        # Get the excluded list for each atom in the set, making a dictionary.
        # We go at most 3 hops unless one end of the chain has a hydrogen.
        # Look up excluded atoms by i_seq.
        self._excludeDict = {}
        for a in moverAtoms:
          self._excludeDict[a.i_seq] = mmtbx.probe.Helpers.getAtomsWithinNBonds(a,
            bondedNeighborLists, self._extraAtomInfo, self._probeRadius, self._bondedNeighborDepth, 3)
        self._infoString += _ReportTiming(self._verbosity, "determine excluded atoms")

        ################################################################################
        # Construct dot-sphere cache.
        # This must be done after the phantom Hydrogens have been added so that they will be included.
        dotSphereCache = Helpers.createDotSphereCache(self._probePhil)

        ################################################################################
        # Contruct the DotScorer object we'll use to score the dots.
        self._dotScorer = Helpers.createDotScorer(self._extraAtomInfo, self._probePhil)
        self._infoString += _ReportTiming(self._verbosity, "construct dot scorer")

        ################################################################################
        # Construct C++ optimizer.
        optC = OptimizerC(self._verbosity, self._preferenceMagnitude,
                          self._maximumVDWRadius, self._minOccupancy, self._probeRadius, self._probeDensity,
                          self._atoms,
                          self._excludeDict, self._dotScorer, dotSphereCache, self._atomMoverLists,
                          self._spatialQuery, self._extraAtomInfo, self._deleteMes)
        self._infoString += _ReportTiming(self._verbosity, "construct OptimizerC")

        ################################################################################
        # Compute and record the initial score for each Mover in its info
        optC.Initialize(self._movers)
        for m in self._movers:
          self._moverInfo[m] += " Initial score: {:.2f}".format(optC.GetHighScore(m))

        ################################################################################
        # Call internal methods to optimize the single-element Cliques and then to optimize
        # the multi-element Cliques and then to do independent fine adjustment of all
        # Cliques.  Subclasses should overload the called routines, but the global approach
        # taken here will be the same for all of them.  If we want to change the recipe
        # so that we can do global fine optimization, we'll do that here rather than in the
        # subclasses.

        # Do coarse optimization on the singleton Movers.  Record the selected coarse
        # index.
        for s in singletonCliques:
          mover = self._interactionGraph.vertex_label(s[0])
          (bestScore, infoString) = optC.OptimizeSingleMoverCoarse(mover)
          self._infoString += infoString
          ret = bestScore
          self._infoString += _VerboseCheck(self._verbosity, 1,"Singleton optimized with score {:.2f}\n".format(ret))
        self._infoString += _ReportTiming(self._verbosity, "optimize singletons (coarse)")

        # Do coarse optimization on the multi-Mover Cliques.
        for g in groupCliques:
          movers = [self._interactionGraph.vertex_label(i) for i in g]
          subset = _subsetGraph(self._interactionGraph, movers)

          # Find all of the Movers in the clique so that we know which ones to capture the state for.
          movers = [self._interactionGraph.vertex_label(v) for v in subset.vertices()]

          # Turn the graph edges into a versa array that holds the edges. The first index is the
          # number of edge and the second is 2D, listing the index of each mover.
          vertexList = list(subset.vertices())
          edges = flex.int(flex.grid(len(list(subset.edges())), 2))
          for i,e in enumerate(subset.edges()):
            edges[(i,0)] = vertexList.index(subset.source(e))
            edges[(i,1)] = vertexList.index(subset.target(e))

          (bestScore, infoString) = optC.OptimizeCliqueCoarse(movers, edges)
          self._infoString += infoString
          ret = bestScore

          self._infoString += _VerboseCheck(self._verbosity, 1,"Clique optimized with score {:.2f}\n".format(ret))
        self._infoString += _ReportTiming(self._verbosity, "optimize cliques (coarse)")

        # Do fine optimization on the Movers.  This is done independently for
        # each of them, whether they are part of a multi-Mover Clique or not.
        self._infoString += _VerboseCheck(self._verbosity, 1,"Fine optimization on all Movers\n")
        for m in self._movers:
          (bestScore, infoString) = optC.OptimizeSingleMoverFine(m)
          self._infoString += infoString
        self._infoString += _ReportTiming(self._verbosity, "optimize all Movers (fine)")

        ################################################################################
        # Print the final state and score for all Movers
        def _scoreMoverReportClash(self, m, index):
          coarse = m.CoarsePositions()
          score = self._preferenceMagnitude * coarse.preferenceEnergies[index]
          clash = False
          # There may not be as many atoms moved as there are atoms, so use the proper length
          for i in range(len(coarse.positions[index])):
            atom = coarse.atoms[i]
            maxRadiusWithoutProbe = self._extraAtomInfo.getMappingFor(atom).vdwRadius + self._maximumVDWRadius
            res = self._dotScorer.score_dots(atom, self._minOccupancy, self._spatialQuery,
              maxRadiusWithoutProbe, self._probeRadius, self._excludeDict[atom.i_seq],
              optC.GetDots(atom.i_seq), self._probeDensity, False, False)
            score += res.totalScore()
            if res.hasBadBump:
              clash = True
          return score, clash

        def _printPose(self, m):
          description = m.PoseDescription(optC.GetCoarseLocation(m), optC.GetFineLocation(m),
                                          not self._skipBondFixup)

          # If the Mover is a flip of some kind, then the substring "lipped " will be present
          # in the description.
          # When that happens, we check the final state and the other flip
          # state (which is half of the coarse states away) to see if both have clashes or
          # if they are close in energy. If so, then we annotate the output.
          # We add the same number of words to the output string in all cases to make things
          # easier for a program to parse.
          if "lipped " in description:
            coarse = m.CoarsePositions()
            numPositions = len(coarse.positions)
            final = optC.GetCoarseLocation(m)
            other = (final + numPositions//2) % numPositions
            self._setMoverState(coarse, other)
            otherScore, otherBump = _scoreMoverReportClash(self, m, other)
            self._setMoverState(coarse, final)
            finalScore, finalBump = _scoreMoverReportClash(self, m, final)
            if otherBump and finalBump:
              description += " BothClash"
            elif "Unflipped" in description and (
                (otherScore > finalScore) and (otherScore - finalScore <= self._nonFlipPreference)):
              description += " Uncertain"
            else:
              description += " ."
          else:
            description += " ."

          self._infoString += _VerboseCheck(self._verbosity, 1,"  {} final score: {:.2f} pose {}\n".format(
            self._moverInfo[m], optC.GetHighScore(m), description))

        self._infoString += _VerboseCheck(self._verbosity, 1,"BEGIN REPORT: Model "+str(mi)+" Alt '"+alt+"':\n")
        sortedGroups = sorted(groupCliques, key=len, reverse=True)
        for g in sortedGroups:
          self._infoString += _VerboseCheck(self._verbosity, 1," Set of "+str(len(g))+" Movers:")
          movers = [self._interactionGraph.vertex_label(i) for i in g]
          # Parse the record for each mover and pull out the initial score.  Sum the initial and
          # final scores across all Movers in the group and report this.
          initial = 0.0
          final = 0.0
          for m in movers:
            initial += float(self._moverInfo[m].split()[9])
            final += optC.GetHighScore(m)
          self._infoString += _VerboseCheck(self._verbosity, 1," Totals: initial score {:.2f}, final score {:.2f}\n".format(initial, final))
          for m in movers:
            _printPose(self, m)
        self._infoString += _VerboseCheck(self._verbosity, 1," Singleton Movers:\n")
        for s in singletonCliques:
          m = self._interactionGraph.vertex_label(s[0])
          _printPose(self, m)
        self._infoString += _VerboseCheck(self._verbosity, 1,"END REPORT\n")

        ################################################################################
        # Do FixUp on the final coarse orientations.  Set the positions, extra atom info
        # and deletion status for all atoms that have entries for each.
        # This must be done after we print the scores because the print methods move the
        # coarse state to see how much it changed.
        if not self._skipBondFixup:
          self._infoString += _VerboseCheck(self._verbosity, 1,"FixUp on all Movers\n")
          for m in self._movers:
            loc = optC.GetCoarseLocation(m)
            self._infoString += _VerboseCheck(self._verbosity, 3,"FixUp on {} coarse location {}\n".format(
            self._moverInfo[m],loc))
            self._doFixup(m.FixUp(loc))
          self._infoString += _ReportTiming(self._verbosity, "fix up Movers")

        #################################################################################
        # Record the fraction of atoms that were calculated and the fraction that were cached.
        self._numCalculated += optC.GetNumCalculatedAtoms()
        self._numCached += optC.GetNumCachedAtoms()

      ################################################################################
      # Deletion of atoms (Hydrogens) that were requested by Histidine FixUp()s,
      # both in the initial setup and determined during optimization.  Phantom Hydrogens
      # on waters do not need to be adjusted because they were never added to the
      # structure.
      # We only do this after the last-checked alternate configuration for a given model.
      self._infoString += _VerboseCheck(self._verbosity, 1,"Deleting Hydrogens tagged by Histidine Movers\n")
      for a in self._deleteMes:
        aName = a.name.strip().upper()
        resNameAndID = _ResNameAndID(a)
        self._infoString += _VerboseCheck(self._verbosity, 5,"Deleting {} {}\n".format(resNameAndID, aName))
        a.parent().remove_atom(a)
      self._infoString += _ReportTiming(self._verbosity, "delete Hydrogens")

      #################################################################################
      # Dump information about all of the atoms in the model into a string.
      if fillAtomDump:
        self._atomDump = Helpers.writeAtomInfoToString(myModel.atoms(), self._extraAtomInfo)
        self._infoString += _ReportTiming(self._verbosity, "dump atom info to string")

      #################################################################################
      # Report the fraction of atoms that were calculated and the fraction that were cached.
      if self._numCalculated > 0:
        self._infoString += _VerboseCheck(self._verbosity, 1,
            'Calculated : cached atom scores: {} : {}; fraction calculated {:.2f}\n'.format(
            self._numCalculated, self._numCached,
            self._numCalculated/(self._numCalculated + self._numCached)))

  def getInfo(self):
    """
      Returns information that the user may care about regarding the processing.  The level of
      detail on this can be set by setting the verbosity parameter during Optimizer construction.
      :return: the information so far collected in the string.  Calling this method also clears
      the information, so that later calls will not repeat it.
      If the object was constructed with fillAtomDump = False, then the atom dump will always be
      empty.
    """
    ret = self._infoString
    self._infoString = ""
    return ret

  def getAtomDump(self):
    """
      Returns information about the final status of each atom in each model, including VdW radius
      and various flags.  Useful for debugging and for regression testing.
      :return: the information so far collected in the string.  Calling this method also clears
      the information, so that later calls will not repeat it.
    """
    ret = self._atomDump
    self._atomDump = ""
    return ret

  def _setMoverState(self, positionReturn, index):
    """
      Move the atoms to their new positions, updating the spatial query structure
      by removing the old and adding the new location.
    """
    # there may be fewer moved atoms than there are total atoms
    numMoved = len(positionReturn.positions[index])
    for i in range(numMoved):
      a = positionReturn.atoms[i]

      self._spatialQuery.remove(a)
      # Make a slice here so that we get a copy of the location rather than a reference to it
      a.xyz = positionReturn.positions[index][i][:]
      self._spatialQuery.add(a)

    # Update the extra atom information associated with each atom.
    # Note that there may be fewer entries than atoms, but they all correspond.
    for i, e in enumerate(positionReturn.extraInfos[index]):
      self._extraAtomInfo.setMappingFor(positionReturn.atoms[i], e)

    # Manage the deletion status of each atom, including ensuring
    # consistency with the spatial-query structure.
    # Note that there may be fewer entries than atoms, but they all correspond.
    for i, doDelete in enumerate(positionReturn.deleteMes[index]):
      if doDelete:
        self._spatialQuery.remove(positionReturn.atoms[i])
        self._deleteMes.add(positionReturn.atoms[i])
        self._infoString += _VerboseCheck(self._verbosity, 10,"Deleting atom\n")
      else:
        self._spatialQuery.add(positionReturn.atoms[i])
        self._deleteMes.discard(positionReturn.atoms[i])
        self._infoString += _VerboseCheck(self._verbosity, 10,"Ensuring deletable atom is present\n")

  def _doFixup(self, fixUp):
    """
      Move the atoms to their fixup positions, updating their extra atom info
      and deletion status
    """
    myAtoms = fixUp.atoms
    for i, p in enumerate(fixUp.positions):
      self._infoString += _VerboseCheck(self._verbosity, 5,"Moving atom to {}\n".format(p))
      myAtoms[i].xyz = p
    for i, e in enumerate(fixUp.extraInfos):
      self._infoString += _VerboseCheck(self._verbosity, 5,"Atom info to {}\n".format(e))
      self._extraAtomInfo.setMappingFor(myAtoms[i], e)
    for i, d in enumerate(fixUp.deleteMes):
      # Either ensure that it is deleted or ensure that it is not depending on the
      # value of the deletion result.
      self._infoString += _VerboseCheck(self._verbosity, 5,"Atom deleted is {}\n".format(d))
      if d:
        self._deleteMes.add(myAtoms[i])
      else:
        self._deleteMes.discard(myAtoms[i])

  ##################################################################################
  # Placement

  def _PlaceMovers(self, atoms, rotatableHydrogenIDs, bondedNeighborLists, hParameters,
                    addFlipMovers):
    """Produce a list of Movers for atoms in a pdb.hierarchy.conformer that has added Hydrogens.
    :param atoms: flex array of atoms to search.  This must have all Hydrogens needed by the
    Movers present in the structure already.
    :param rotatableHydrogenIDs: List of sequence IDs that include those of single hydrogens
    that are rotatable. These are hydrogens that are the only one bound to their neighbor
    and they are rotatable.
    :param bondedNeighborLists: A dictionary that contains an entry for each atom in the
    structure that the atom from the first parameter interacts with that lists all of the
    bonded atoms.  Can be obtained by calling mmtbx.probe.Helpers.getBondedNeighborLists().
    :param hParameters: List indexed by sequence ID that stores the riding
    coefficients for hydrogens that have associated dihedral angles.  This can be
    obtained by calling model.setup_riding_h_manager() and then model.get_riding_h_manager().
    :param addFlipMovers: Do we add flip Movers along with other types?
    :return: List of atoms that should be unconditionally marked for deletion as a result
    of the analysis done during placement.
    """

    # Parse the flipStates parameter to get a list of FlipMoverState objects.
    fs = _ParseFlipStates(self._flipStates)

    # List of Movers
    self._movers = []

    # List of atoms to delete
    deleteAtoms = []

    # Dictionary mapping from Mover to information about the Mover, so that we can keep track of
    # everything from its placement to its final state in the same string.
    self._moverInfo = {}

    # The radius of a Polar Hydrogen (one that forms Hydrogen bonds)
    # @todo Can we look this up from inside CCTBX?
    polarHydrogenRadius = 1.05

    # For each atom, check to see if it is the main atom from a Mover.  If so, attempt to
    # construct the appropriate Mover.  The construction may fail because not all required
    # atoms are present (especially the Hydrogens).  If the construction succeeds, add the
    # Mover to the list of those to return.  When they fail, add the output to the information
    # string. We check single-hydrogen rotators later.

    for a in atoms:
      # Find the stripped upper-case atom and residue names and the residue ID,
      # and an identifier string
      aName = a.name.strip().upper()
      resName = a.parent().resname.strip().upper()
      resNameAndID = _ResNameAndID(a)

      # See if we should construct a MoverNH3Rotator here.
      # Find any Nitrogen that has four total bonded neighbors, three of which are Hydrogens.
      # @todo Is this a valid way to search for them?
      if a.element == 'N' and len(bondedNeighborLists[a]) == 4:
        numH = 0
        for n in bondedNeighborLists[a]:
          if n.element_is_hydrogen():
            numH += 1
        if numH == 3:
          try:
            self._movers.append(Movers.MoverNH3Rotator(a, bondedNeighborLists, hParameters))
            self._infoString += _VerboseCheck(self._verbosity, 1,"Added MoverNH3Rotator "+str(len(self._movers))+" to "+resNameAndID+"\n")
            self._moverInfo[self._movers[-1]] = "NH3Rotator at "+resNameAndID+" "+aName;
          except Exception as e:
            self._infoString += _VerboseCheck(self._verbosity, 0,"Could not add MoverNH3Rotator to "+resNameAndID+": "+str(e)+"\n")

      # See if we should construct a MoverAromaticMethylRotator or MoverTetrahedralMethylRotator here.
      # Find any Carbon that has four total bonded neighbors, three of which are Hydrogens.
      # @todo Is this a valid way to search for them?
      if a.element == 'C' and len(bondedNeighborLists[a]) == 4:
        numH = 0
        neighbor = None
        for n in bondedNeighborLists[a]:
          if n.element_is_hydrogen():
            numH += 1
          else:
            neighbor = n
        if numH == 3:
          # See if the Carbon's other neighbor is attached to two other atoms (3 total).  If so,
          # then insert a MoverAromaticMethylRotator and if not, generate a MoverTetrahedralMethylRotator
          # so that the Hydrogens will be staggered but do not add it to those to be optimized.
          if len(bondedNeighborLists[neighbor]) == 3:
            try:
              self._movers.append(Movers.MoverAromaticMethylRotator(a, bondedNeighborLists, hParameters))
              self._infoString += _VerboseCheck(self._verbosity, 1,"Added MoverAromaticMethylRotator "+str(len(self._movers))+" to "+resNameAndID+" "+aName+"\n")
              self._moverInfo[self._movers[-1]] = "AromaticMethylRotator at "+resNameAndID+" "+aName;
            except Exception as e:
              self._infoString += _VerboseCheck(self._verbosity, 0,"Could not add MoverAromaticMethylRotator to "+resNameAndID+" "+aName+": "+str(e)+"\n")
          else:
            try:
              ignored = Movers.MoverTetrahedralMethylRotator(a, bondedNeighborLists, hParameters)
              self._infoString += _VerboseCheck(self._verbosity, 1,"Used MoverTetrahedralMethylRotator to stagger "+resNameAndID+" "+aName+"\n")
            except Exception as e:
              self._infoString += _VerboseCheck(self._verbosity, 0,"Could not add MoverTetrahedralMethylRotator to "+resNameAndID+" "+aName+": "+str(e)+"\n")

      # See if we should insert a MoverAmideFlip here.
      # @todo Is there a more general way than looking for specific names?
      if addFlipMovers and ((aName == 'XD2' and resName == 'ASX') or (aName == 'XE2' and resName == 'GLX')):
        self._infoString += _VerboseCheck(self._verbosity, 1,"Not attempting to adjust "+resNameAndID+" "+aName+"\n")
      if addFlipMovers and ((aName == 'ND2' and resName == 'ASN') or (aName == 'NE2' and resName == 'GLN')):
        # Find the Oxygen and see if it is within a range of ideal bonding distances to a positive ion.
        # Do this in two steps; find the Carbon bonded to the Nitrogen and then the Oxygen bonded to the
        # Carbon.
        foundIon = False
        oxygen = None
        for b in bondedNeighborLists[a]:
          if b.element.upper() == 'C':
            for b2 in bondedNeighborLists[b]:
              if b2.element.upper() == 'O':
                oxygen = b2
        # If we have a close-enough ion, we skip adding a Mover.
        if oxygen is not None:
          # @todo Check both flips and lock down the appropriate one rather than only checking the first.
          myRad = self._extraAtomInfo.getMappingFor(a).vdwRadius
          minDist = myRad
          maxDist = 0.25 + myRad + self._maximumVDWRadius
          neighbors = self._spatialQuery.neighbors(oxygen.xyz, minDist, maxDist)
          for n in neighbors:
            if n.element_is_positive_ion():
              dist = (Helpers.rvec3(oxygen.xyz) - Helpers.rvec3(n.xyz)).length()
              expected = myRad + self._extraAtomInfo.getMappingFor(n).vdwRadius
              self._infoString += _VerboseCheck(self._verbosity, 5,'Checking AmideFlip against '+n.name.strip()+' at '+str(n.xyz)+' from '+str(oxygen.xyz)+
                ' dist = '+str(dist)+', expected = '+str(expected)+'; N rad = '+str(myRad)+
                ', '+n.name.strip()+' rad = '+str(self._extraAtomInfo.getMappingFor(n).vdwRadius)+'\n')
              # @todo Why are we using -0.65 here and -0.55 for Histidine?
              if dist >= (expected - 0.65) and dist <= (expected + 0.25):
                foundIon = True

        if not foundIon:
          try:
            # Check to see if the state of this Mover has been specified. If so, place it in
            # the requested state and don't insert the Mover. If not, then insert the Mover.
            s = _FindFlipState(a, fs)
            if s is not None:
              self._infoString += _VerboseCheck(self._verbosity, 1,"Setting MoverAmideFlip for "+resNameAndID+": flipped = "+
                str(s.flipped)+", angles adjusted = "+str(s.fixedUp)+"\n")
              flip = Movers.MoverAmideFlip(a, "CA", bondedNeighborLists, self._nonFlipPreference)
              cp = flip.CoarsePositions()
              if s.flipped:
                index = 1
              else:
                index = 0
              self._setMoverState(cp, index)
              if s.fixedUp:
                self._doFixup(flip.FixUp(index))
            else:
              self._movers.append(Movers.MoverAmideFlip(a, "CA", bondedNeighborLists, self._nonFlipPreference))
              self._infoString += _VerboseCheck(self._verbosity, 1,"Added MoverAmideFlip "+str(len(self._movers))+" to "+resNameAndID+"\n")
              self._moverInfo[self._movers[-1]] = "AmideFlip at "+resNameAndID+" "+aName
          except Exception as e:
            self._infoString += _VerboseCheck(self._verbosity, 0,"Could not add MoverAmideFlip to "+resNameAndID+": "+str(e)+"\n")

      # See if we should insert a MoverHisFlip here.
      # @todo Is there a more general way than looking for specific names?
      if aName == 'NE2' and resName == 'HIS':
        try:
          # Get a potential Mover and test both of its Nitrogens in the original and flipped
          # locations.  If one or both of them are near enough to be ionically bound to an
          # ion, then we remove the Hydrogen(s) and lock the Histidine at that orientation
          # rather than inserting the Mover into the list of those to be optimized.
          # @todo Consider checking both configurations to see if either one has two bonds.
          hist = Movers.MoverHisFlip(a, bondedNeighborLists, self._extraAtomInfo, self._nonFlipPreference)

          # Find the four positions to check for Nitrogen ionic bonds
          # The two atoms are NE2 (0th atom with its Hydrogen at atom 1) and
          # ND1 (4th atom with its Hydrogen at atom 5).
          cp = hist.CoarsePositions()
          ne2Orig = cp.positions[0][0]
          nd1Orig = cp.positions[0][4]
          ne2Flip = cp.positions[4][0]
          nd1Flip = cp.positions[4][4]

          # See if any are close enough to a positive ion to be ionically bonded.
          # If any are, record whether it is the original or
          # the flipped configuration.  Check the original configuration first.
          # Check out to the furthest distance of any atom's VdW radius.
          myRad = self._extraAtomInfo.getMappingFor(a).vdwRadius
          minDist = myRad
          maxDist = 0.25 + myRad + self._maximumVDWRadius
          bondedConfig = None
          for i,pos in enumerate([ne2Orig, nd1Orig, ne2Flip, nd1Flip]):
            neighbors = self._spatialQuery.neighbors(pos, minDist, maxDist)
            for n in neighbors:
              if n.element_is_positive_ion():
                dist = (Helpers.rvec3(pos) - Helpers.rvec3(n.xyz)).length()
                expected = myRad + self._extraAtomInfo.getMappingFor(n).vdwRadius
                self._infoString += _VerboseCheck(self._verbosity, 5,'Checking Histidine '+str(i)+' against '+n.name.strip()+' at '+str(n.xyz)+' from '+str(pos)+
                  ' dist = '+str(dist)+', expected = '+str(expected)+'; N rad = '+str(myRad)+
                  ', '+n.name.strip()+' rad = '+str(self._extraAtomInfo.getMappingFor(n).vdwRadius)+'\n')
                if dist >= (expected - 0.55) and dist <= (expected + 0.25):
                  # The first two elements in the enumeration come from Histidine configuration 0
                  # and the second two from configuration 4, so we figure out which one we should
                  # be in.
                  bondedConfig = (i // 2) * 4
                  self._infoString += _VerboseCheck(self._verbosity, 5,'Found ionic bond in coarse configuration '+str(bondedConfig)+'\n')
                  break
            if bondedConfig is not None:
              # We want the first configuration that is found, so we don't flip if we don't need to.
              break

          # If one of the bonded configurations has at least one Ionic bond, then check each of
          # the Nitrogens in that configuration, removing its Hydrogen if it is bonded to an ion.
          # Set the histidine to that flip state; it will not be inserted as a Mover.
          if bondedConfig is not None:
            # Set the histidine in that flip state
            fixUp = hist.FixUp(bondedConfig)
            coarsePositions = hist.CoarsePositions().positions[bondedConfig]
            for i,a in enumerate(fixUp.atoms):
              if i < len(fixUp.positions):
                a.xyz = fixUp.positions[i]
              if i < len(fixUp.extraInfos):
                self._extraAtomInfo.setMappingFor(a, fixUp.extraInfos[i])

            # See if we should remove the Hydrogen from each of the two potentially-bonded
            # Nitrogens and make each an acceptor if we do remove its Hydrogen.  The two atoms
            # are NE2 (0th atom with its Hydrogen at atom 1) and ND1 (4th atom with
            # its Hydrogen at atom 5).
            # NOTE that we must check the position of the atom in its coarse configuration rather
            # than its FixUp configuration because that is the location that we use to determine if
            # we have an ionic bond.
            def _modifyIfNeeded(nitro, coarseNitroPos, hydro):
              # Helper function to check and change things for one of the Nitrogens.
              result = ""
              myRad = self._extraAtomInfo.getMappingFor(nitro).vdwRadius
              minDist = myRad
              maxDist = 0.25 + myRad + self._maximumVDWRadius
              neighbors = self._spatialQuery.neighbors(coarseNitroPos, minDist, maxDist)
              for n in neighbors:
                if n.element_is_positive_ion():
                  dist = (Helpers.rvec3(coarseNitroPos) - Helpers.rvec3(n.xyz)).length()
                  expected = myRad + self._extraAtomInfo.getMappingFor(n).vdwRadius
                  if dist >= (expected - 0.55) and dist <= (expected + 0.25):
                    result += _VerboseCheck(self._verbosity, 1,'Not adding Hydrogen to '+resNameAndID+nitro.name+' and marking as an acceptor '+
                      '(ionic bond to '+n.name.strip()+')\n')
                    extra = self._extraAtomInfo.getMappingFor(nitro)
                    extra.isAcceptor = True
                    self._extraAtomInfo.setMappingFor(nitro, extra)
                    deleteAtoms.append(hydro)
                    break
              return result

            self._infoString += _modifyIfNeeded(fixUp.atoms[0], coarsePositions[0], fixUp.atoms[1])
            self._infoString += _modifyIfNeeded(fixUp.atoms[4], coarsePositions[4], fixUp.atoms[5])

            self._infoString += _VerboseCheck(self._verbosity, 1,"Set MoverHisFlip on "+resNameAndID+" to state "+str(bondedConfig)+"\n")
          elif addFlipMovers: # Add a Histidine flip Mover if we're adding flip Movers
            # Check to see if the state of this Mover has been specified. If so, place it in
            # the requested state and insert the Mover as a non-flipping Histidine.
            # If not, then insert the Histidine flip Mover.
            s = _FindFlipState(a, fs)
            if s is not None:
              if s.flipped:
                enabledFlips = 2
              else:
                enabledFlips = 1
              hist = Movers.MoverHisFlip(a, bondedNeighborLists, self._extraAtomInfo, self._nonFlipPreference,
                enabledFlips, s.fixedUp)
              self._movers.append(hist)
              self._infoString += _VerboseCheck(self._verbosity, 1,"Added MoverHisPlace "+str(len(self._movers))+" to "+resNameAndID+"\n")
              # Name is HisPlace rather than HisFlip, so we don't try and report uncertain or clash for it.
              self._moverInfo[self._movers[-1]] = "HisPlace at "+resNameAndID+" "+aName;
              # Set the position to the first coarse position, which will cause a flip if required
              coarse = hist.CoarsePositions()
              self._setMoverState(coarse, 0)
            else:
              self._movers.append(hist)
              self._infoString += _VerboseCheck(self._verbosity, 1,"Added MoverHisFlip "+str(len(self._movers))+" to "+resNameAndID+"\n")
              self._moverInfo[self._movers[-1]] = "HisFlip at "+resNameAndID+" "+aName;
        except Exception as e:
          self._infoString += _VerboseCheck(self._verbosity, 0,"Could not add MoverHisFlip to "+resNameAndID+": "+str(e)+"\n")

    # Make a dictionary looked up up by i_seq that returns the relevant atom. We use this to
    # look up the single-hydrogen rotators. We only place atoms that are in our current model
    # index and alternate.
    atomDict = {}
    for a in atoms:
      atomDict[a.i_seq] = a

    # Insert all single-hydrogen rotators, which we have a list of. Do this after we've
    # done all of the other Movers so that any lock-down placements will have been done
    # before we check.
    for i in rotatableHydrogenIDs:
      # Find out the associated atom
      try:
        a = atomDict[i]
      except KeyError:
        # This atom is not in our current model index or alternate, so skip it.
        continue

      aName = a.name.strip().upper()
      resName = a.parent().resname.strip().upper()
      resNameAndID = _ResNameAndID(a)
      try:
        # Skip Hydrogens that are not bound to an atom that only has a single other
        # atom bound to it -- we will handle those in other cases.
        neighbor = bondedNeighborLists[a][0]
        if len(bondedNeighborLists[neighbor]) == 2:

          # Get the list of atoms that are bonded in a chain to the hydrogen. They
          # cannot be either hydrogen-bond acceptors nor touches/clashes with this atom.
          bonded = Helpers.getAtomsWithinNBonds(a, bondedNeighborLists, self._extraAtomInfo,
                                                self._probeRadius, self._bondedNeighborDepth, 3)

          # Construct a list of nearby atoms that are potential acceptors and potential touches.
          # The potential acceptors are also potential touches.
          potentialAcceptors = []
          potentialTouches = []

          # Get the list of nearby atoms.  The center of the search is the atom that
          # the Hydrogen is bound to and its radius is 4 (these values are pulled from
          # the Reduce C++ code). We skip ones whose radius is inside the neighbor so
          # that we don't count the hydrogen itself.
          maxDist = 4.0
          nearby = self._spatialQuery.neighbors(neighbor.xyz,
                                                self._extraAtomInfo.getMappingFor(neighbor).vdwRadius,
                                                maxDist)

          # Check each nearby atom to see if its distance from the neighbor is within
          # the sum of the hydrogen-bond length of the neighbor atom, the radius of
          # a polar Hydrogen, and the radius of the nearby atom, indicating potential
          # overlap.
          # O-H & N-H bond len == 1.0, S-H bond len == 1.3
          XHbondlen = 1.0
          if neighbor.element == "S":
            XHbondlen = 1.3
          candidates = []
          for n in nearby:
            # We don't count bonded atoms.
            if not n in bonded:
              # We treat them all as potential touches/clashes.
              potentialTouches.append(n)
              d = (Helpers.rvec3(neighbor.xyz) - Helpers.rvec3(n.xyz)).length()
              if d <= XHbondlen + self._extraAtomInfo.getMappingFor(n).vdwRadius + polarHydrogenRadius:
                candidates.append(n)

          # See if each candidate atom is a potential acceptor or a flip partner from
          # Histidine or NH2 flips (which may be moved into that atom's position during a flip).
          # We check the partner (N's for GLN And ASN, C's for HIS) because if it is the O or
          # N atom, we will already be checking it as an acceptor now.
          # In any case, it is a potential touch.
          for c in candidates:
            cName = c.name.strip().upper()
            resName = c.parent().resname.strip().upper()
            flipPartner = (
              (cName == 'ND2' and resName == 'ASN') or
              (cName == 'NE2' and resName == 'GLN') or
              (cName == 'CE1' and resName == 'HIS') or (cName == 'CD2' and resName == 'HIS') )
            acceptor = self._extraAtomInfo.getMappingFor(c).isAcceptor
            if acceptor or flipPartner:
              potentialAcceptors.append(c)

          self._movers.append(Movers.MoverSingleHydrogenRotator(a, bondedNeighborLists, self._extraAtomInfo,
                                                                hParameters, potentialAcceptors,
                                                                potentialTouches))
          self._infoString += _VerboseCheck(self._verbosity, 1,"Added MoverSingleHydrogenRotator "+str(len(self._movers))+" to "+resNameAndID+" "+aName+
            " with "+str(len(potentialAcceptors))+" potential nearby acceptors\n")
          self._moverInfo[self._movers[-1]] = "SingleHydrogenRotator at "+resNameAndID+" "+aName;
      except Exception as e:
        self._infoString += _VerboseCheck(self._verbosity, 0,"Could not add MoverSingleHydrogenRotator to "+resNameAndID+" "+aName+": "+str(e)+"\n")

    return deleteAtoms


  def _DescribeMover(self, m):
    type_str = str(type(m))
    type_str = type_str.split("'")[1]  # Extract the type name between the quotes
    type_str = type_str.split(".")[-1]  # Extract the class name from the module path
    info = _ResNameAndID(m.CoarsePositions().atoms[0])
    return type_str + ' ' + info

  def _DescribeMoverAtom(self, m, a, rad, loc):
    return ( ' {' + self._DescribeMover(m) + " " + a.name.strip().upper() + '}' +
            ' r= '+str(rad)+' {:0.3f} {:0.3f} {:0.3f}\n'.format(loc[0], loc[1], loc[2]))

  def _MoverSpheres(self, m, extraRadius=0.0):
    """Returns a Kinemage string listing all of the positions of the movable atoms
    in the specified mover over all possible locations. The radius of each is as
    specified in the atom plus the specified extraRadius.
    """
    ret = ''
    for i, cp in enumerate(m.CoarsePositions().positions):
      for j, loc in enumerate(cp):
        a = m.CoarsePositions().atoms[j]
        rad = str(extraRadius + self._extraAtomInfo.getMappingFor(a).vdwRadius)
        ret += self._DescribeMoverAtom(m, a, rad, loc)
      for fp in m.FinePositions(i).positions:
        for j, loc in enumerate(fp):
          a = m.CoarsePositions().atoms[j]
          rad = str(extraRadius + self._extraAtomInfo.getMappingFor(a).vdwRadius)
          ret += self._DescribeMoverAtom(m, a, rad, loc)
    return ret


  def _InteractionKinemage(self, components):
      # Used to round-robin among a set of differentiable colors
      COLORS = ['gray', 'pink', 'sea', 'sky', 'cyan', 'magenta', 'yellow']
      curColor = 0

      # Write all of the Movers in all of the cliques, with a different color per Mover
      # using the actual atom radius.
      ret = '@kinemage 1\n'
      ret += '@master {movers}\n'
      for c in components:
        movers = [self._interactionGraph.vertex_label(i) for i in c]
        for m in movers:
          color = COLORS[curColor]
          curColor = (curColor + 1) % len(COLORS)
          # Radius will be overridden per atom
          ret += '@spherelist color= '+color+' nobutton master= {movers}\n'
          ret += self._MoverSpheres(m)

      # Write all of the cliques, with a different color per clique
      # using the atom radius plus the probe radius.
      for i, c in enumerate(components):
        cliqueName = 'clique '+str(i)+' size '+str(len(c))
        ret += '@master {'+cliqueName+'}\n'
        color = COLORS[curColor]
        curColor = (curColor + 1) % len(COLORS)
        movers = [self._interactionGraph.vertex_label(i) for i in c]
        for m in movers:
          # Radius will be overridden per atom
          ret += '@spherelist color= '+color+' nobutton master= {'+cliqueName+'}\n'
          ret += self._MoverSpheres(m, self._probeRadius)

      return ret


##################################################################################
# Private helper functions.

def _ParseFlipStates(fs):
  """Produce a list of FlipMoverState objects by parsing a comma-separated flipStates
  string.
  """
  ret = []
  if fs is not None:
    for state in fs.split(','):
      words = state.split()
      if len(words) == 6 or len(words) == 7:
        modelId = int(words[0]) + 1
        altId = words[1].lower()
        if altId == '.':
          altId = ''
        chain = words[2].upper()
        resName = words[3].upper()
        if resName == 'HIS':
          t = 'HisFlip'
        else:
          t = 'AmideFlip'
        resIdWithICode = words[4]
        flipped = words[5] == 'Flipped'
        fixedUp = False
        if len(words) == 7:
          fixedUp = words[6] == 'AnglesAdjusted'
        ret.append(FlipMoverState(t, modelId, altId, chain, resName, resIdWithICode, flipped, fixedUp))
  return ret


def _FindFlipState(a, flipStates):
  '''Is an atom in the list of residues that have flip states? If so, return the associated state
  :param a: atom
  :param flipStates: List of FlipMoverState objects
  :return: FlipMoverState if the residue is in the list, None if not
  '''
  ag = a.parent()
  rg = ag.parent()
  chain = rg.parent()
  for fs in flipStates:
    modelId = chain.parent().id
    # We must offset the index of the model by 1 to get to the 1-based model ID
    if ( (modelId == fs.modelId + 1 or modelId == '') and
          (chain.id == fs.chain) and
          (rg.resseq_as_int() == fs.resId) and
          (ag.altloc.strip() == '' or fs.altId == '.' or ag.altloc.strip().lower() == fs.altId.lower()) and
          (rg.icode.strip() == fs.iCode.strip())
        ):
      return fs
  return None


def _subsetGraph(g, keepLabels):
  """
  Return a new graph that is a subset of g that includes only
  the vertices whose labels are listed, and edges between these.
  :param g: Graph to be subsetted.
  :param keepLabels: Labels on the vertices that should end up in the resulting
  graph.  Must be a subset of the vertices in the graph, but it can include all
  of the vertices, in which case it will make a full copy of the graph.
  :return: Boost graph that is a subset of the original graph.
  """

  # We keep a dictionary from labels to the vertex in the new graph that points to
  # that label so that we can construct edges in the new graph.
  vertexForLabel = {}

  # Construct a subgraph that consists only of vertices to be kept and
  # edges both of whose ends are on these vertices.
  ret = graph.adjacency_list(
        vertex_type = "list",   # List so that deletions do not invalidate iterators and descriptors
        )
  for v in g.vertices():
    label = g.vertex_label(v)
    if label in keepLabels:
      vertexForLabel[label] = ret.add_vertex(label)
  for e in g.edges():
    sourceLabel = g.vertex_label( g.source(e) )
    targetLabel = g.vertex_label( g.target(e) )
    if sourceLabel in keepLabels and targetLabel in keepLabels:
      ret.add_edge(vertex1 = vertexForLabel[sourceLabel], vertex2 = vertexForLabel[targetLabel])

  return ret


##################################################################################
# Test function and associated data and helpers to verify that all functions behave properly.

# Class to pass default Probe parameters as if they were in a probePhil structure
class _philLike:
  def __init__(self):
    self.probe_radius = 0.25
    self.density = 16.0
    self.worse_clash_cutoff = 0.5
    self.clash_cutoff = 0.4
    self.contact_cutoff = 0.25
    self.uncharged_hydrogen_cutoff = 0.6
    self.charged_hydrogen_cutoff = 0.8
    self.bump_weight = 10.0
    self.hydrogen_bond_weight = 4.0
    self.gap_weight = 0.25
    self.allow_weak_hydrogen_bonds = False
    self.ignore_ion_interactions = False
    self.set_polar_hydrogen_radius = True
    self.excluded_bond_chain_length = 4

def _optimizeFragment(pdb_raw, bondedNeighborDepth = 4):
  """Returns an optimizer constructed based on the raw PDB data snippet passed in.
  :param pdb_raw: A string that includes a snippet of a PDB file. Should have no alternates.
  :param bondedNeighborDepth: How many levels of bonded neighbors to include in the
  neighbor lists for each atom. Some tests were done with a value of 3, which differs
  from the newer default of 4.
  :return: Optimizer initialized based on the snippet.
  """
  dm = DataManager(['model'])
  dm.process_model_str("my_data.pdb", pdb_raw)
  model = dm.get_model()

  # Add Hydrogens to the model
  reduce_add_h_obj = reduce_hydrogen.place_hydrogens(model = model)
  reduce_add_h_obj.run()
  model = reduce_add_h_obj.get_model()

  # Interpret the model after adding Hydrogens to it so that
  # all of the needed fields are filled in when we use them below.
  # @todo Remove this once place_hydrogens() does all the interpretation we need.
  p = mmtbx.model.manager.get_default_pdb_interpretation_params()
  p.pdb_interpretation.allow_polymer_cross_special_position=True
  p.pdb_interpretation.clash_guard.nonbonded_distance_threshold=None
  p.pdb_interpretation.proceed_with_excessive_length_bonds=True
  p.pdb_interpretation.disable_uc_volume_vs_n_atoms_check=True
  model.process(make_restraints=True,pdb_interpretation_params=p) # make restraints

  # Optimization will place the movers.
  probePhil = _philLike()
  return Optimizer(probePhil, True, model, bondedNeighborDepth=bondedNeighborDepth)

def Test(inFileName = None, dumpAtoms = False):

  """Test function for all functions provided above.
  :param inFileName: Name of a PDB or CIF file to load (default makes a small molecule)
  :return: Empty string on success, string describing the problem on failure.
  """

  #========================================================================
  # Test the imported C++ functions
  ret = Optimizers_test()
  if len(ret) > 0:
    return "Optimizers.Test(): " + ret

  #========================================================================
  # Test model to use for validating the alternate/conformer-selection functions.

  alternates_test = (
"""
ATOM      1  N   HIS A  1       26.965  32.911   7.593  1.00  7.19           N
ATOM      2  N  AHIS A  2       26.965  32.911   7.593  1.00  7.19           N
ATOM      3  N  BHIS A  2       26.965  32.911   7.593  1.00  7.19           N
ATOM      4  N  CHIS A  2       26.965  32.911   7.593  1.00  7.19           N
END
"""
    )

  #========================================================================
  # Test the AlternatesInModel() function.
  # Test the GetAtomsForConformer() function.
  dm = DataManager(['model'])
  dm.process_model_str("alternates_test.pdb",alternates_test)
  model = dm.get_model()
  model.process(make_restraints=False)
  model = dm.get_model().get_hierarchy().models()[0]
  alts = AlternatesInModel(model)
  if alts != set(['','A','B','C']):
    return "Optimizers.Test(): Incorrect set of alternates for AlternatesInModel() test: " + str(alts)

  for a in alts:
    count = len(GetAtomsForConformer(model, a))
    if count != 2:
      return "Optimizers.Test(): Incorrect atom count for GetAtomsForConformer() test: " + str(count)

  #========================================================================
  # Unit tests for each type of Optimizer.

  ################################################################################
  # Test using a snippet from 7c31 to make sure the single-hydrogen rotator sets
  # the orientation of the Hydrogen to make good contact with a nearby Oxygen. The B
  # alternate has been removed and the A moved to the main alternate. This is not
  # close enough for a good Hydrogen bond, so it does not point straight at the Oxygen.

  pdb_7c31_two_residues = """\
CRYST1   27.854   27.854   99.605  90.00  90.00  90.00 P 43          8
ORIGX1      1.000000  0.000000  0.000000        0.00000
ORIGX2      0.000000  1.000000  0.000000        0.00000
ORIGX3      0.000000  0.000000  1.000000        0.00000
SCALE1      0.035901  0.000000  0.000000        0.00000
SCALE2      0.000000  0.035901  0.000000        0.00000
SCALE3      0.000000  0.000000  0.010040        0.00000
ATOM     68  N   SER A   5     -31.155  49.742   0.887  1.00 10.02           N
ATOM     69  CA  SER A   5     -32.274  48.937   0.401  1.00  9.76           C
ATOM     70  C   SER A   5     -33.140  49.851  -0.454  1.00  9.47           C
ATOM     71  O   SER A   5     -33.502  50.939  -0.012  1.00 10.76           O
ATOM     72  CB  SER A   5     -33.086  48.441   1.599  1.00 12.34           C
ATOM     73  OG  SER A   5     -34.118  47.569   1.179  1.00 19.50           O
ATOM    758  N   VAL B   2     -34.430  42.959   3.043  1.00 19.95           N
ATOM    759  CA  VAL B   2     -32.994  42.754   2.904  0.50 18.09           C
ATOM    760  C   VAL B   2     -32.311  44.083   2.629  1.00 17.65           C
ATOM    761  O   VAL B   2     -32.869  44.976   1.975  1.00 18.97           O
ATOM    762  CB  VAL B   2     -32.703  41.738   1.778  0.50 19.70           C
ATOM    763  CG1 VAL B   2     -33.098  42.307   0.419  0.50 19.61           C
ATOM    764  CG2 VAL B   2     -31.224  41.334   1.755  0.50 16.49           C
TER    1447      CYS B  47
END
"""
  opt = _optimizeFragment(pdb_7c31_two_residues)
  movers = opt._movers
  if len(movers) != 3:
    return "Optimizers.Test(): Incorrect number of Movers for single-hydrogen rotator test: " + str(len(movers))

  # See what the pose angle is on the Mover. It should be 62 degrees, and is reported
  # after 'pose Angle '.
  # NOTE: This test was generated when the SingleHydrogenRotator was testing all coarse
  # angles in addition to those towards acceptors. When we switched to the original Reduce
  # behavior of only doing a single non-clashing angle along with the acceptor angles, this
  # test no longer passes. Leaving it in for now in case we want to switch back to the
  # original behavior.
  #angle = int(re.search(r'(?<=pose Angle )[-+]?\d+', opt.getInfo()).group(0))
  #if angle != 62:
  #  return "Optimizers.Test(): Unexpected angle ("+str(angle)+") for single-hydrogen rotator, expected 62"

  ################################################################################
  # Test using a modified snippet from 7c31 to make sure the single-hydrogen rotator sets
  # the orientation of the Hydrogen to make a good hydrogen bond with a nearby Oxygen.
  # The above example has been stripped down and has the Oxygen moved closer.

  pdb_7c31_two_residues_close_O = """\
CRYST1   27.854   27.854   99.605  90.00  90.00  90.00 P 43          8
ORIGX1      1.000000  0.000000  0.000000        0.00000
ORIGX2      0.000000  1.000000  0.000000        0.00000
ORIGX3      0.000000  0.000000  1.000000        0.00000
SCALE1      0.035901  0.000000  0.000000        0.00000
SCALE2      0.000000  0.035901  0.000000        0.00000
SCALE3      0.000000  0.000000  0.010040        0.00000
ATOM     68  N   SER A   5     -31.155  49.742   0.887  1.00 10.02           N
ATOM     69  CA  SER A   5     -32.274  48.937   0.401  1.00  9.76           C
ATOM     70  C   SER A   5     -33.140  49.851  -0.454  1.00  9.47           C
ATOM     71  O   SER A   5     -33.502  50.939  -0.012  1.00 10.76           O
ATOM     72  CB  SER A   5     -33.086  48.441   1.599  1.00 12.34           C
ATOM     73  OG  SER A   5     -34.118  47.569   1.179  1.00 19.50           O
ATOM    761  O   VAL B   2     -33.462  45.185   1.977  1.00 18.97           O
TER    1447      CYS B  47
END
"""
  opt = _optimizeFragment(pdb_7c31_two_residues_close_O)
  movers = opt._movers
  if len(movers) != 2:
    return "Optimizers.Test(): Incorrect number of Movers for single-hydrogen rotator H-bond test: " + str(len(movers))

  # See what the pose angle is on the Mover. It is reported after 'pose Angle '.
  expected = 113
  angle = int(re.findall(r'(?<=pose Angle )[-+]?\d+', opt.getInfo())[1])
  if angle != expected:
    return "Optimizers.Test(): Unexpected angle ("+str(angle)+") for single-hydrogen rotator H-bond, expected "+str(expected)+", found "+str(angle)

  ################################################################################
  # Test using a modified snippet from 7c31 to make sure the single-hydrogen rotator sets
  # the orientation of the Hydrogen touching a nearby Carbon.
  # The above example has the Oxygen replaced by a Carbon.

  pdb_7c31_two_residues_close_C = """\
CRYST1   27.854   27.854   99.605  90.00  90.00  90.00 P 43          8
ORIGX1      1.000000  0.000000  0.000000        0.00000
ORIGX2      0.000000  1.000000  0.000000        0.00000
ORIGX3      0.000000  0.000000  1.000000        0.00000
SCALE1      0.035901  0.000000  0.000000        0.00000
SCALE2      0.000000  0.035901  0.000000        0.00000
SCALE3      0.000000  0.000000  0.010040        0.00000
ATOM     68  N   SER A   5     -31.155  49.742   0.887  1.00 10.02           N
ATOM     69  CA  SER A   5     -32.274  48.937   0.401  1.00  9.76           C
ATOM     70  C   SER A   5     -33.140  49.851  -0.454  1.00  9.47           C
ATOM     71  O   SER A   5     -33.502  50.939  -0.012  1.00 10.76           O
ATOM     72  CB  SER A   5     -33.086  48.441   1.599  1.00 12.34           C
ATOM     73  OG  SER A   5     -34.118  47.569   1.179  1.00 19.50           O
ATOM    761  C   VAL B   2     -33.462  45.185   1.977  1.00 18.97           C
TER    1447      CYS B  47
END
"""
  opt = _optimizeFragment(pdb_7c31_two_residues_close_C)
  movers = opt._movers
  if len(movers) != 2:
    return "Optimizers.Test(): Incorrect number of Movers for single-hydrogen rotator clash test: " + str(len(movers))

  # See what the pose angle is on the Mover. It is reported after 'pose Angle '.
  expected = -64
  angle = int(re.findall(r'(?<=pose Angle )[-+]?\d+', opt.getInfo())[1])
  if angle != expected:
    return "Optimizers.Test(): Unexpected angle ("+str(angle)+") for single-hydrogen rotator clash, expected "+str(expected)+", found "+str(angle)

  ################################################################################
  # Test using a modified snippet from 1ubq to make sure the NH3 rotator sets
  # the orientation as expected to align with a nearby Oxygen and waters.

  pdb_1ubq_two_residues_close_O = """\
CRYST1   50.840   42.770   28.950  90.00  90.00  90.00 P 21 21 21    4
ORIGX1      1.000000  0.000000  0.000000        0.00000
ORIGX2      0.000000  1.000000  0.000000        0.00000
ORIGX3      0.000000  0.000000  1.000000        0.00000
SCALE1      0.019670  0.000000  0.000000        0.00000
SCALE2      0.000000  0.023381  0.000000        0.00000
SCALE3      0.000000  0.000000  0.034542        0.00000
ATOM      1  N   MET A   1      27.340  24.430   2.614  1.00  9.67           N
ATOM      2  CA  MET A   1      26.266  25.413   2.842  1.00 10.38           C
ATOM      3  C   MET A   1      26.913  26.639   3.531  1.00  9.62           C
ATOM      4  O   MET A   1      27.886  26.463   4.263  1.00  9.62           O
ATOM      5  CB  MET A   1      25.112  24.880   3.649  1.00 13.77           C
ATOM      6  CG  MET A   1      25.353  24.860   5.134  1.00 16.29           C
ATOM      7  SD  MET A   1      23.930  23.959   5.904  1.00 17.17           S
ATOM      8  CE  MET A   1      24.447  23.984   7.620  1.00 16.11           C
ATOM    127  N   VAL A  17      30.310  25.458   5.384  1.00  8.99           N
ATOM    128  CA  VAL A  17      30.288  24.245   6.193  1.00  8.85           C
ATOM    129  C   VAL A  17      29.279  23.227   5.641  1.00  8.04           C
ATOM    130  O   VAL A  17      28.478  23.522   4.725  1.00  8.99           O
ATOM    131  CB  VAL A  17      29.903  24.590   7.665  1.00  9.78           C
ATOM    132  CG1 VAL A  17      30.862  25.496   8.389  1.00 12.05           C
ATOM    133  CG2 VAL A  17      28.476  25.135   7.705  1.00 10.54           C
TER     603      GLY A  76
HETATM  625  O   HOH A  98      25.928  21.774   2.325  1.00 13.70           O
HETATM  637  O   HOH A 110      28.824  25.094   0.886  0.77 36.99           O
END
"""
  # This test is done with a bonded-neighbor depth of 3 because that is how we were
  # doing the calculations when we set it up.
  opt = _optimizeFragment(pdb_1ubq_two_residues_close_O, 3)
  movers = opt._movers
  if len(movers) != 2:
    return "Optimizers.Test(): Incorrect number of Movers for NH3 rotator test: " + str(len(movers))

  # See what the pose angle is on the Mover. It should be 163 degrees, and is reported
  # after 'pose Angle '.
  angle = int(re.findall(r'(?<=pose Angle )[-+]?\d+', opt.getInfo())[0])
  if angle != 163:
    return "Optimizers.Test(): Unexpected angle ("+str(angle)+") for NH3 rotator, expected 163"

  ################################################################################
  # Test using snippet from 1dfu to ensure that the Histidine optimzization code will
  # properly skip hydrogens that are going to be deleted when scoring.
  pdb_1dfu_his80 = (
"""
CRYST1   75.600   76.600   95.100  90.00  90.00  90.00 C 2 2 21      8
ORIGX1      1.000000  0.000000  0.000000        0.00000
ORIGX2      0.000000  1.000000  0.000000        0.00000
ORIGX3      0.000000  0.000000  1.000000        0.00000
SCALE1      0.013257  0.000000  0.000000        0.00000
SCALE2      0.000000  0.013063  0.000000        0.00000
SCALE3      0.000000  0.000000  0.010515        0.00000
ATOM   1443  N   HIS P  80      27.889  23.654 -11.281  1.00 41.74           N
ATOM   1444  CA  HIS P  80      28.738  24.315 -10.299  1.00 45.36           C
ATOM   1445  C   HIS P  80      29.467  25.487 -10.941  1.00 46.80           C
ATOM   1446  O   HIS P  80      29.927  25.397 -12.080  1.00 47.32           O
ATOM   1447  CB  HIS P  80      29.765  23.342  -9.714  1.00 47.26           C
ATOM   1448  CG  HIS P  80      30.457  23.865  -8.492  1.00 48.91           C
ATOM   1449  ND1 HIS P  80      29.947  23.705  -7.221  1.00 49.73           N
ATOM   1450  CD2 HIS P  80      31.593  24.589  -8.351  1.00 49.34           C
ATOM   1451  CE1 HIS P  80      30.739  24.306  -6.351  1.00 49.69           C
ATOM   1452  NE2 HIS P  80      31.745  24.850  -7.011  1.00 50.50           N
ATOM   1453  N   PRO P  81      29.581  26.606 -10.211  1.00 48.50           N
ATOM   1454  CA  PRO P  81      30.255  27.810 -10.698  1.00 49.93           C
ATOM   1455  C   PRO P  81      31.662  27.557 -11.236  1.00 51.19           C
ATOM   1456  O   PRO P  81      32.041  28.115 -12.265  1.00 51.83           O
ATOM   1457  CB  PRO P  81      30.264  28.714  -9.468  1.00 50.10           C
ATOM   1458  CG  PRO P  81      29.003  28.336  -8.774  1.00 49.68           C
ATOM   1459  CD  PRO P  81      29.026  26.831  -8.864  1.00 49.20           C
ATOM   1460  N   TYR P  82      32.432  26.716 -10.549  1.00 51.94           N
ATOM   1461  CA  TYR P  82      33.797  26.440 -10.985  1.00 52.99           C
ATOM   1462  C   TYR P  82      34.257  24.985 -10.876  1.00 52.34           C
ATOM   1463  O   TYR P  82      35.456  24.712 -10.890  1.00 52.96           O
ATOM   1464  CB  TYR P  82      34.769  27.349 -10.225  1.00 54.88           C
ATOM   1465  CG  TYR P  82      34.757  27.162  -8.722  1.00 56.85           C
ATOM   1466  CD1 TYR P  82      35.404  26.078  -8.127  1.00 57.60           C
ATOM   1467  CD2 TYR P  82      34.096  28.070  -7.895  1.00 57.47           C
ATOM   1468  CE1 TYR P  82      35.394  25.903  -6.743  1.00 58.41           C
ATOM   1469  CE2 TYR P  82      34.080  27.904  -6.510  1.00 58.47           C
ATOM   1470  CZ  TYR P  82      34.730  26.819  -5.942  1.00 58.59           C
ATOM   1471  OH  TYR P  82      34.718  26.650  -4.577  1.00 59.33           O
HETATM 1782  O   HOH P 134      28.550  22.420  -4.280  1.00 33.59           O
END
"""
    )
  opt = _optimizeFragment(pdb_1dfu_his80)
  movers = opt._movers
  if len(movers) != 3:
    return "Optimizers.Test(): Incorrect number of Movers for His placement test: " + str(len(movers))
  info = opt.getInfo()
  if not 'HD1NotPlaced' in info:
    return "Optimizers.Test(): Unexpected HD1 placement for His."
  if not 'HE2Placed' in info:
    return "Optimizers.Test(): Missing HE2 placement for His."


  ################################################################################
  # Test using snippet from 1xso to ensure that the Histidine placement code will lock down the
  # Histidine, set its Nitrogen states, and mark its Hydrogens for deletion.  To
  # ensure that hydrogen placement puts them there in the first place, we first
  # move the CU and ZN far from the Histidine before adding Hydrogens, then move
  # them back before building the spatial hierarchy and testing.
  pdb_1xso_his_61_and_ions = (
"""
ATOM    442  N   HIS A  61      26.965  32.911   7.593  1.00  7.19           N
ATOM    443  CA  HIS A  61      27.557  32.385   6.403  1.00  7.24           C
ATOM    444  C   HIS A  61      28.929  31.763   6.641  1.00  7.38           C
ATOM    445  O   HIS A  61      29.744  32.217   7.397  1.00  9.97           O
ATOM    446  CB  HIS A  61      27.707  33.547   5.385  1.00  9.38           C
ATOM    447  CG  HIS A  61      26.382  33.956   4.808  1.00  8.78           C
ATOM    448  ND1 HIS A  61      26.168  34.981   3.980  1.00  9.06           N
ATOM    449  CD2 HIS A  61      25.174  33.397   5.004  1.00 11.08           C
ATOM    450  CE1 HIS A  61      24.867  35.060   3.688  1.00 12.84           C
ATOM    451  NE2 HIS A  61      24.251  34.003   4.297  1.00 11.66           N
HETATM 2190 CU    CU A   1      22.291  33.388   3.996  1.00 13.22          CU
HETATM 2191 ZN    ZN A 152      27.539  36.010   2.881  1.00  9.34          ZN
END
"""
    )
  dm = DataManager(['model'])
  dm.process_model_str("1xso_snip.pdb",pdb_1xso_his_61_and_ions)
  model = dm.get_model()

  # Make sure we have a valid unit cell.  Do this before we add hydrogens to the model
  # to make sure we have a valid unit cell.
  model = shift_and_box_model(model = model)

  # Find and move the Copper and Zinc atoms far from the Histidine so that
  # Hydrogen placement and bond proxies won't consider them to be bonded.
  # This tests the algorithm behavior for the case of all Hydrogens present
  # in all cases.
  for a in model.get_hierarchy().models()[0].atoms():
    if a.element.upper() == "CU":
      origPositionCU = a.xyz
      a.xyz = (1000, 1000, 1000)
    if a.element.upper() == "ZN":
      origPositionZN = a.xyz
      a.xyz = (1000, 1000, 1000)

  # Add Hydrogens to the model
  reduce_add_h_obj = reduce_hydrogen.place_hydrogens(model = model)
  reduce_add_h_obj.run()
  model = reduce_add_h_obj.get_model()

  # Interpret the model after adding Hydrogens to it so that
  # all of the needed fields are filled in when we use them below.
  # @todo Remove this once place_hydrogens() does all the interpretation we need.
  p = mmtbx.model.manager.get_default_pdb_interpretation_params()
  p.pdb_interpretation.allow_polymer_cross_special_position=True
  p.pdb_interpretation.clash_guard.nonbonded_distance_threshold=None
  p.pdb_interpretation.proceed_with_excessive_length_bonds=True
  model.process(make_restraints=True,pdb_interpretation_params=p) # make restraints

  # Get the first model in the hierarchy.
  firstModel = model.get_hierarchy().models()[0]

  # Get the list of alternate conformation names present in all chains for this model.
  alts = AlternatesInModel(firstModel)

  # Get the atoms from the first conformer in the first model (the empty string is the name
  # of the first conformation in the model; if there is no empty conformation, then it will
  # pick the first available conformation for each atom group.
  atoms = GetAtomsForConformer(firstModel, "")

  # Get the Cartesian positions of all of the atoms we're considering for this alternate
  # conformation.
  carts = flex.vec3_double()
  for a in atoms:
    carts.append(a.xyz)

  # Get the bond proxies for the atoms in the model and conformation we're using and
  # use them to determine the bonded neighbor lists.
  bondProxies = model.get_restraints_manager().geometry.get_all_bond_proxies(sites_cart = carts)[0]
  bondedNeighborLists = Helpers.getBondedNeighborLists(atoms, bondProxies)

  # Get the probeExt.ExtraAtomInfo needed to determine which atoms are potential acceptors.
  probePhil = _philLike()
  ret = Helpers.getExtraAtomInfo(model = model, bondedNeighborLists = bondedNeighborLists,
      useNeutronDistances=False, probePhil=probePhil)
  extra = ret.extraAtomInfo

  # Also compute the maximum VDW radius among all atoms.
  maxVDWRad = 1
  for a in atoms:
    maxVDWRad = max(maxVDWRad, extra.getMappingFor(a).vdwRadius)

  # Put the Copper and Zinc back in their original positions before we build the
  # spatial-query structure.  This will make them close enough to be bonded to
  # the Nitrogens and should cause Hydrogen removal and marking of the Nitrogens
  # as acceptors.
  for a in model.get_hierarchy().models()[0].atoms():
    if a.element.upper() == "CU":
      a.xyz = origPositionCU
    if a.element.upper() == "ZN":
      a.xyz = origPositionZN

  # Optimization will place the movers, which should be none because the Histidine flip
  # will be constrained by the ionic bonds. There is a rotatable hydrogen placed at the
  # terminus, but no Flip Mover.
  probePhil = _philLike()
  opt = Optimizer(probePhil, True, model)
  movers = opt._movers
  if len(movers) != 1:
    return "Optimizers.Test(): Incorrect number of Movers for 1xso Histidine test: " + str(len(movers))

  # Make sure that the two ring Nitrogens have been marked as acceptors.
  # Make sure that the two hydrogens have been marked for deletion.
  for a in model.get_hierarchy().models()[0].atoms():
    name = a.name.strip()
    if name in ["ND1", "NE2"]:
      if not opt._extraAtomInfo.getMappingFor(a).isAcceptor:
        return 'Optimizers.Test(): '+name+' in 1xso Histidine test was not an acceptor'
    if name in ["HD1", "HE2"]:
      if not a in opt._deleteMes:
        return 'Optimizers.Test(): '+name+' in 1xso Histidine test was not set for deletion'

  #========================================================================
  # Check a clique with multiple elements to be sure that it was properly
  # globally optimized. This is a set of ACT residues that are offset
  # such that they want to line up the same way.  A carbon is placed to
  # force the oriention away from the initial solution.
  pdb_multi_act = (
"""
CRYST1   93.586  127.886  251.681  90.00  90.00  90.00 I 2 2 2
SCALE1      0.010685  0.000000  0.000000        0.00000
SCALE2      0.000000  0.007819  0.000000        0.00000
SCALE3      0.000000  0.000000  0.003973        0.00000
HETATM    1  C   ACT A   1       6.494 -47.273 -37.006  1.00 16.65           C
HETATM    2  O   ACT A   1       5.654 -47.981 -37.645  1.00 15.33           O
HETATM    3  CH3 ACT A   1       6.790 -47.410 -35.548  1.00 17.13           C
HETATM    4  OXT ACT A   1       7.110 -46.425 -37.699  1.00 17.05           O
HETATM  101  C   ACT A 101       8.994 -49.773 -37.606  1.00 16.65           C
HETATM  102  O   ACT A 101       8.154 -50.481 -38.245  1.00 15.33           O
HETATM  103  CH3 ACT A 101       9.290 -49.910 -36.148  1.00 17.13           C
HETATM  104  OXT ACT A 101       9.610 -48.925 -38.299  1.00 17.05           O
HETATM  111  C   ACT A 111      11.494 -52.273 -38.206  1.00 16.65           C
HETATM  112  O   ACT A 111      10.654 -52.981 -38.845  1.00 15.33           O
HETATM  113  CH3 ACT A 111      11.790 -52.410 -36.748  1.00 17.13           C
HETATM  114  OXT ACT A 111      12.110 -51.425 -38.899  1.00 17.05           O
HETATM  121  C   ACT A 121      13.994 -54.773 -38.806  1.00 16.65           C
HETATM  122  O   ACT A 121      13.154 -55.481 -39.445  1.00 15.33           O
HETATM  123  CH3 ACT A 121      14.290 -54.910 -37.348  1.00 17.13           C
HETATM  124  OXT ACT A 121      14.610 -53.925 -39.499  1.00 17.05           O
HETATM  131  C   ACT A 131      16.494 -57.273 -39.406  1.00 16.65           C
HETATM  132  O   ACT A 131      15.654 -57.981 -40.045  1.00 15.33           O
HETATM  133  CH3 ACT A 131      16.790 -57.410 -37.948  1.00 17.13           C
HETATM  134  OXT ACT A 131      17.110 -56.425 -40.099  1.00 17.05           O
HETATM  141  C   ACT A 141      18.994 -59.773 -40.006  1.00 16.65           C
HETATM  142  O   ACT A 141      18.154 -60.481 -40.645  1.00 15.33           O
HETATM  143  CH3 ACT A 141      19.290 -59.910 -38.548  1.00 17.13           C
HETATM  144  OXT ACT A 141      19.610 -58.925 -40.699  1.00 17.05           O
HETATM  200  C   ACT A 200       4.500 -45.500 -35.000  1.00 16.65           C
END
"""
    )
  dm = DataManager(['model'])
  dm.process_model_str("pdb_multi_act.pdb",pdb_multi_act)
  model = dm.get_model()

  # Make sure we have a valid unit cell.  Do this before we add hydrogens to the model
  # to make sure we have a valid unit cell.
  model = shift_and_box_model(model = model)

  # Add Hydrogens to the model
  reduce_add_h_obj = reduce_hydrogen.place_hydrogens(model = model)
  reduce_add_h_obj.run()
  model = reduce_add_h_obj.get_model()

  # Interpret the model after adding Hydrogens to it so that
  # all of the needed fields are filled in when we use them below.
  # @todo Remove this once place_hydrogens() does all the interpretation we need.
  p = mmtbx.model.manager.get_default_pdb_interpretation_params()
  p.pdb_interpretation.allow_polymer_cross_special_position=True
  p.pdb_interpretation.clash_guard.nonbonded_distance_threshold=None
  p.pdb_interpretation.proceed_with_excessive_length_bonds=True
  model.process(make_restraints=True,pdb_interpretation_params=p) # make restraints

  # Get the first model in the hierarchy.
  firstModel = model.get_hierarchy().models()[0]

  # Get the list of alternate conformation names present in all chains for this model.
  alts = AlternatesInModel(firstModel)

  # Get the atoms from the first conformer in the first model (the empty string is the name
  # of the first conformation in the model; if there is no empty conformation, then it will
  # pick the first available conformation for each atom group.
  atoms = GetAtomsForConformer(firstModel, "")

  # Get the Cartesian positions of all of the atoms we're considering for this alternate
  # conformation.
  carts = flex.vec3_double()
  for a in atoms:
    carts.append(a.xyz)

  # Get the bond proxies for the atoms in the model and conformation we're using and
  # use them to determine the bonded neighbor lists.
  bondProxies = model.get_restraints_manager().geometry.get_all_bond_proxies(sites_cart = carts)[0]
  bondedNeighborLists = Helpers.getBondedNeighborLists(atoms, bondProxies)

  # Get the probeExt.ExtraAtomInfo needed to determine which atoms are potential acceptors.
  probePhil = _philLike()
  ret = Helpers.getExtraAtomInfo(model = model, bondedNeighborLists = bondedNeighborLists,
      useNeutronDistances=False,probePhil=probePhil)
  extra = ret.extraAtomInfo

  # Also compute the maximum VDW radius among all atoms.
  maxVDWRad = 1
  for a in atoms:
    maxVDWRad = max(maxVDWRad, extra.getMappingFor(a).vdwRadius)

  # Optimization will place the movers. Make sure we got as many as we expected.
  # Make sure that the orientation for all of the movers is correct.
  # Test with each type of optimizer, from the base to the more derived, so
  # that we find out about failures on the base classes first.
  probePhil = _philLike()

  global _DoCliqueOptimizationInC

  print('Testing Optimizer')
  opt = Optimizer(probePhil, True, model, modelIndex = 0, altID = None,
                bondedNeighborDepth = 4,
                useNeutronDistances = False,
                minOccupancy = 0.02,
                preferenceMagnitude = 1.0,
                nonFlipPreference = 0.5,
                skipBondFixup = False,
                flipStates = '',
                verbosity = 1)
  movers = opt._movers
  if len(movers) != 6:
    return "Optimizers.Test(): Incorrect number of Movers for Optimizer multi-ACT test: " + str(len(movers))
  res = re.findall(r'pose Angle [-+]?\d+', opt.getInfo())
  for r in res:
    if not 'pose Angle 90' in r:
      return "Optimizers.Test(): Unexpected angle ("+str(r)+") for Optimizer multi-ACT test"

  #========================================================================
  # Check a case where an AmideFlip would be locked down and have its Hydrogen removed.
  # @todo

  #========================================================================
  # Check that the occupancy and B-factor cut-offs for water Oxygens are causing them
  # to be ignored in the calculations by putting an atom in the way and making sure it
  # is ignored.
  pdb_b_factor = (
"""
CRYST1   93.586  127.886  251.681  90.00  90.00  90.00 I 2 2 2
SCALE1      0.010685  0.000000  0.000000        0.00000
SCALE2      0.000000  0.007819  0.000000        0.00000
SCALE3      0.000000  0.000000  0.003973        0.00000
HETATM    1  C   ACT A   1       6.494 -47.273 -37.006  1.00 16.65           C
HETATM    2  O   ACT A   1       5.654 -47.981 -37.645  1.00 15.33           O
HETATM    3  CH3 ACT A   1       6.790 -47.410 -35.548  1.00 17.13           C
HETATM    4  OXT ACT A   1       7.110 -46.425 -37.699  1.00 17.05           O
HETATM  200  O   HOH A 200       8.200 -48.610 -35.148  1.00 50.00           O
HETATM  201  O   HOH A 201       5.800 -46.810 -34.548  1.00 20.00           O
END
"""
    )
  dm = DataManager(['model'])
  dm.process_model_str("pdb_b_factor.pdb",pdb_b_factor)
  model = dm.get_model()

  # Make sure we have a valid unit cell.  Do this before we add hydrogens to the model
  # to make sure we have a valid unit cell.
  model = shift_and_box_model(model = model)

  # Add Hydrogens to the model
  reduce_add_h_obj = reduce_hydrogen.place_hydrogens(model = model)
  reduce_add_h_obj.run()
  model = reduce_add_h_obj.get_model()

  # Interpret the model after adding Hydrogens to it so that
  # all of the needed fields are filled in when we use them below.
  # @todo Remove this once place_hydrogens() does all the interpretation we need.
  p = mmtbx.model.manager.get_default_pdb_interpretation_params()
  p.pdb_interpretation.allow_polymer_cross_special_position=True
  p.pdb_interpretation.clash_guard.nonbonded_distance_threshold=None
  p.pdb_interpretation.proceed_with_excessive_length_bonds=True
  model.process(make_restraints=True,pdb_interpretation_params=p) # make restraints

  # Get the first model in the hierarchy.
  firstModel = model.get_hierarchy().models()[0]

  # Get the list of alternate conformation names present in all chains for this model.
  alts = AlternatesInModel(firstModel)

  # Get the atoms from the first conformer in the first model (the empty string is the name
  # of the first conformation in the model; if there is no empty conformation, then it will
  # pick the first available conformation for each atom group.
  atoms = GetAtomsForConformer(firstModel, "")

  # Get the Cartesian positions of all of the atoms we're considering for this alternate
  # conformation.
  carts = flex.vec3_double()
  for a in atoms:
    carts.append(a.xyz)

  # Get the bond proxies for the atoms in the model and conformation we're using and
  # use them to determine the bonded neighbor lists.
  bondProxies = model.get_restraints_manager().geometry.get_all_bond_proxies(sites_cart = carts)[0]
  bondedNeighborLists = Helpers.getBondedNeighborLists(atoms, bondProxies)

  # Get the probeExt.ExtraAtomInfo needed to determine which atoms are potential acceptors.
  probePhil = _philLike()
  ret = Helpers.getExtraAtomInfo(model = model, bondedNeighborLists = bondedNeighborLists,
      useNeutronDistances=False,probePhil=probePhil)
  extra = ret.extraAtomInfo

  # Also compute the maximum VDW radius among all atoms.
  maxVDWRad = 1
  for a in atoms:
    maxVDWRad = max(maxVDWRad, extra.getMappingFor(a).vdwRadius)

  # Optimization will place the movers. Make sure we got as many as we expected.
  # Make sure that the orientation for all of the movers is correct.
  probePhil = _philLike()
  opt = Optimizer(probePhil, True, model, modelIndex = 0, altID = None,
                bondedNeighborDepth = 4,
                useNeutronDistances = False,
                minOccupancy = 0.02,
                preferenceMagnitude = 1.0,
                nonFlipPreference = 0.5,
                skipBondFixup = False,
                flipStates = '',
                verbosity = 1)
  movers = opt._movers
  if len(movers) != 1:
    return "Optimizers.Test(): Incorrect number of Movers for B-factor test: " + str(len(movers))
  res = re.findall(r'pose Angle [-+]?\d+', opt.getInfo())
  for r in res:
    if not 'pose Angle 90' in r:
      return "Optimizers.Test(): Unexpected angle ("+str(r)+") for B-factor test"

  #========================================================================
  # Generate an example data model with a small molecule in it or else read
  # from the specified file.
  infoString = ""
  if inFileName is not None and len(inFileName) > 0:
    # Read a model from a file using the DataManager
    print('Reading model from',inFileName)
    dm = DataManager()
    dm.process_model_file(inFileName)
    model = dm.get_model(inFileName)
  else:
    # Generate a small-molecule model using the map model manager
    print('Generating model')
    mmm=map_model_manager()         #   get an initialized instance of the map_model_manager
    mmm.generate_map()              #   get a model from a generated small library model and calculate a map for it
    model = mmm.model()             #   get the model

  # Add Hydrogens to the model
  reduce_add_h_obj = reduce_hydrogen.place_hydrogens(model = model)
  reduce_add_h_obj.run()
  model = reduce_add_h_obj.get_model()

  # Interpret the model after shifting and adding Hydrogens to it so that
  # all of the needed fields are filled in when we use them below.
  # @todo Remove this once place_hydrogens() does all the interpretation we need.
  p = mmtbx.model.manager.get_default_pdb_interpretation_params()
  p.pdb_interpretation.allow_polymer_cross_special_position=True
  p.pdb_interpretation.clash_guard.nonbonded_distance_threshold=None
  p.pdb_interpretation.proceed_with_excessive_length_bonds=True
  model.process(make_restraints=True, pdb_interpretation_params=p) # make restraints

  # Run the optimizer on the model to make sure it doesn't crash.
  opt = Optimizer(probePhil, True, model)

  # Write debugging output if we've been asked to
  if dumpAtoms:
    fn = "deleteme.pdb"
    fn = model.get_hierarchy().write_pdb_or_mmcif_file(
        target_format = 'pdb',
        target_filename = fn)
    print("Wrote model to '%s'" %fn)
    f = open("atomDump.pdb","w")
    f.write(opt.getAtomDump())

  #========================================================================
  # @todo Unit test a multi-model case, a multi-alternate case, and singles of each.

  return ""

##################################################################################
# If we're run on the command line, test our classes and functions.
if __name__ == '__main__':

  #==============================================================
  # Parse command-line arguments.  The 0th argument is the name
  # of the script. There can be the name of a PDB file to read.
  parser = argparse.ArgumentParser(description='Test mmtbx.reduce.Optimizers.')
  parser.add_argument("--dumpAtoms", help="dump the atoms into PDB files to help debug", action="store_true")
  parser.add_argument('inputFile', nargs='?', default="")
  args = parser.parse_args()

  ret = Test(args.inputFile, args.dumpAtoms)
  if len(ret) == 0:
    print('Success!')
  else:
    print(ret)

  assert (len(ret) == 0)


 *******************************************************************************
