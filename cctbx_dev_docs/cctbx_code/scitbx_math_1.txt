

 *******************************************************************************
scitbx/math/lefebvre.py
#
# lefebvre.py
#
#  Copyright (C) (2016) STFC Rutherford Appleton Laboratory, UK.
#
#  Author: David Waterman.
#
#  This code is distributed under the BSD license, a copy of which is
#  included in the root directory of this package.

from __future__ import absolute_import, division, print_function
from scitbx.array_family import flex
from six.moves import range

def matrix_inverse_error_propagation(mat, cov_mat):
  """Implement analytical formula of Lefebvre et al. (1999)
  http://arxiv.org/abs/hep-ex/9909031 to calculate the covariances of elements
  of mat^-1, given the covariances of mat itself. The input covariance matrix,
  and the return value of the function, have elements ordered by treating mat as
  a 1D vector using row-major ordering."""

  # initialise covariance matrix
  assert mat.is_square()
  assert cov_mat.is_square()
  n = mat.n_rows()
  assert cov_mat.n_rows() == n**2

  # use flex for nice 2D indexing
  inv_mat = flex.double(mat.inverse())
  inv_mat.reshape(flex.grid(n, n))
  cov_mat = cov_mat.as_flex_double_matrix()

  inv_cov_mat = flex.double(flex.grid(n**2,n**2), 0.0)
  for alpha in range(n):
    for beta in range(n):
      for a in range(n):
        for b in range(n):

          # index into inv_cov_mat after flattening inv_mat
          u = alpha * n + beta
          v = a * n + b
          # skip elements in the lower triangle
          if v < u: continue

          # The element u,v of the result is the calculation
          # cov(m^-1[alpha, beta], m^-1[a, b])
          elt = 0.0
          for i in range(n):
            for j in range(n):
              for k in range(n):
                for l in range(n):

                  # index into cov_mat after flattening mat
                  x = i * n + j
                  y = k * n + l
                  elt += inv_mat[alpha, i] * inv_mat[j, beta] * \
                       inv_mat[a, k] * inv_mat[l, b] * \
                       cov_mat[x, y]
          inv_cov_mat[u, v] = elt

  inv_cov_mat.matrix_copy_upper_to_lower_triangle_in_place()
  return inv_cov_mat.as_scitbx_matrix()



 *******************************************************************************


 *******************************************************************************
scitbx/math/minimum_covering_ellipsoid.py
from __future__ import absolute_import, division, print_function
from libtbx import slots_getstate_setstate

class compute(slots_getstate_setstate):

  __slots__ = ["center", "radii", "rotation"]

  def __init__(O, points, epsilon=1e-2):
    """\
Computation of Minimum-Volume Covering Ellipsoid using the Khachiyan Algorithm.
Based on a Python implementation by Raj Rajashankar (ANL, Nov 2011),
which in turn was based on a Matlab script by Nima Moshtagh (2009,
http://stackoverflow.com/questions/1768197/bounding-ellipse/1768440#1768440).

Caveats:
  - center and radii are correct, but rotation may permute axes
  - scales with the square of the number of points
"""
    d = 3 # d is the dimension
    n = points.size()
    assert n > 0
    #
    from scitbx.array_family import flex
    p = points.as_double()
    p.reshape(flex.grid(n, 3))
    p = p.matrix_transpose()
    q = p.deep_copy()
    q.resize(flex.grid(4, n), 1)
    #
    u = flex.double(n, 1/n)
    umx = flex.double(flex.grid(n, n), 0)
    #
    err = epsilon + 1
    while (err > epsilon):
      umx.matrix_diagonal_set_in_place(u)
      x_inv = q.matrix_multiply(umx).matrix_multiply_transpose(
        q).matrix_inversion()
      m = q.matrix_transpose_multiply(
        x_inv).matrix_multiply(q).matrix_diagonal()
      j = flex.max_index(m)
      maximum = m[j]
      ascent_step_size = (maximum-d-1)/((d+1)*(maximum-1))
      new_u = (1 - ascent_step_size) * u
      new_u[j] += ascent_step_size
      err = flex.sum_sq(new_u - u)**0.5
      u = new_u
    #
    center = p.matrix_multiply(u)
    umx.matrix_diagonal_set_in_place(u)
    t1 = p.matrix_multiply(umx).matrix_multiply_transpose(p)
    t2 = center.matrix_outer_product(center)
    a = (t1 - t2).matrix_inversion() / d
    #
    import scitbx.linalg.svd
    svd = scitbx.linalg.svd.real(a, accumulate_u=False, accumulate_v=True)
    size = 1.0/flex.sqrt(svd.sigma)
    from scitbx import matrix
    O.center = matrix.col(center)
    O.radii = matrix.col(size)
    O.rotation = matrix.sqr(svd.v)


 *******************************************************************************


 *******************************************************************************
scitbx/math/multiple_superposition.py
from __future__ import absolute_import, division, print_function

from scitbx.array_family import flex
from scitbx import matrix
from scitbx.linalg import eigensystem

import operator
import math
from functools import reduce
from six.moves import range
from six.moves import zip

# Exceptions
class MultipleSuperpositionError(Exception):
  """
  Module exception
  """


class NoConvergence(MultipleSuperpositionError):
  """
  Refinement starts to diverge
  """


class BadWeights(MultipleSuperpositionError):
  """
  Zero weights
  """


class BadSiteSets(MultipleSuperpositionError):
  """
  Invalid site sets
  """


# Conversion between rotation representations
def quaternion_to_rotmat(q):

  ( l, m, n, s ) = q

  return matrix.sqr( [
    l*l - m*m - n*n + s*s,
    2.0 * ( l*m - n*s ),
    2.0 * ( l*n + m*s ),
    2.0 * ( l*m + n*s ),
    -l*l + m*m -n*n + s*s,
    2.0 * ( m*n - l*s ),
    2.0 * ( l*n - m*s ),
    2.0 * ( m*n + l*s ),
    -l*l - m*m + n*n + s*s,
    ] )


def quaternion_to_quatmat(q):

  ( l, m, n, s ) = q.elems

  return matrix.sqr( [
     s, -n,  m,  l,
     n,  s, -l,  m,
    -m,  l,  s,  n,
    -l, -m, -n,  s,
    ] )


i_bar = matrix.sqr(
  [ -1, 0, 0, 0, 0, -1, 0, 0, 0, 0, -1, 0, 0, 0, 0, 1 ]
  )


# Functions to calculate rotational superposition
def best_rotation(moving, reference, weights):

  return top_quaternion(
    p = p_matrix_from( a_sites = moving, b_sites = reference, weights = weights )
    )


def top_quaternion(p):

  eigen = eigensystem.real_symmetric( p.as_flex_double_matrix() )
  return eigen.vectors()[0:4]


def p_matrix_from(a_sites, b_sites, weights):

  # Diamond, Acta Cryst A44, 211-216 (1988)
  assert len( a_sites ) == len( b_sites ) and len( a_sites ) == len( weights )

  ( xa, ya, za ) = component_arrays( a_sites )
  ( xb, yb, zb ) = component_arrays( b_sites )

  m = matrix.sqr(
    [
      flex.sum( weights * xa * xb ),
      flex.sum( weights * xa * yb ),
      flex.sum( weights * xa * zb ),
      flex.sum( weights * ya * xb ),
      flex.sum( weights * ya * yb ),
      flex.sum( weights * ya * zb ),
      flex.sum( weights * za * xb ),
      flex.sum( weights * za * yb ),
      flex.sum( weights * za * zb ),
      ]
    )

  q = m + m.transpose() - 2 * matrix.identity(3) * m.trace()

  # Application of Sum(j, k)[ epsilon( i, j, k ) * m( j, k ) ]
  # where i,j,k = [ 0, 1, 2 ] and epsilon is the Levi-Civitta symbol
  v = ( m[5] - m[7], m[6] - m[2], m[1] - m[3] )

  return matrix.sqr(
    [
      q[0], q[1], q[2], v[0],
      q[3], q[4], q[5], v[1],
      q[6], q[7], q[8], v[2],
      v[0], v[1], v[2], 0,
      ]
    )


# Various vector operations
def component_arrays(vec3_array):

  x, y, z  = zip( *vec3_array )
  return ( flex.double( x ), flex.double( y ), flex.double( z ) )


# Non-member functions
def iterate(superposition, convergence, tolerance=1.0E-8, iterations = 100):

  assert 0 < convergence
  residual = superposition.residual()
  count = 0
  tolerance *= superposition.set_count * superposition.site_count

  while True:
    superposition.full_iteration()
    new_residual = superposition.residual()
    diff = new_residual - residual

    if tolerance < diff:
      raise NoConvergence( "Divergence in refinement", count, new_residual)

    if abs( diff ) < convergence:
      break

    residual = new_residual
    count += 1

    if iterations < count:
      raise NoConvergence( "Iteration limit exceeded", count, new_residual)

  return ( count, new_residual )


def weighted_error_between(left, right, weights):

  differences = left - right

  return flex.mean_weighted( differences.dot( differences ), weights )


def transform_sites(sites, rotation, translation):

  return rotation.elems * sites + translation


class Matrix(object):
  """
  A matrix
  """

  def __init__(self, n, m):

    self.n = n
    self.m = m
    self.store = [ [ None ] * m for i in range( n ) ]


  def set(self, left, right, value):

    assert left < self.n and right < self.m
    self.store[ left ][ right ] = value


  def get(self, left, right):

    assert left < self.n and right < self.m
    return self.store[ left ][ right ]


  def rows(self):

    return self.store


  def off_diagonal_elements_in_rows(self):

    for ( index, row ) in enumerate( self.rows() ):
      yield row[ : index ] + row[ index + 1 : ]


class SymmetricMatrix(object):
  """
  A matrix that is symmetric and only half has to be calculated / stored
  """

  def __init__(self, dimension):

    assert 0 <= dimension
    self.d = dimension
    self.store = [ None ] * ( ( ( self.d + 1 ) * self.d ) // 2 )


  def set(self, left, right, value):

    self.store[ self.transform( left = left, right = right ) ] = value


  def get(self, left, right):

    return self.store[ self.transform( left = left, right = right ) ]


  def column(self, index):

    start1 = self.transform( left = index, right = 0 )
    slice1 = self.store[ start1 : start1 + index + 1 ]
    slice2 = [ self.get( i, index ) for i in range( index + 1, self.d ) ]
    return slice1 + slice2


  def transform(self, left, right):

    if left < right:
      ( left, right ) = ( right, left )

    return ( ( left + 1 ) * left ) // 2 + right


class ErrorOnRotation(object):
  """
  Superposition of two coordinate sets
  """

  def __init__(self, e, p):

    self.e = e
    self.p = p


  def with_rotated_reference(self, q):

    rho = quaternion_to_quatmat( q = q )
    return self.__class__( e = self.e, p = rho * self.p * rho.transpose() )


  def for_quaternion(self, q):

    square = self.e - 2 * ( q.transpose() * self.p * q )[0]

    return ( square if 0 <= square else 0 )


  def best_rotation(self):

    return matrix.col( top_quaternion( p = self.p ) )


  @classmethod
  def from_sites(cls, left, right, weights):

    assert len( left ) == len( right ) == len( weights )
    diffs = left - right
    e = flex.sum( diffs.dot( diffs ) * weights )
    p = p_matrix_from( a_sites = left, b_sites = right, weights = weights )
    return cls( e = e, p = p )


class PairwiseSuperposition(object):
  """
  Simple pairwise superposition
  """

  def __init__(self, reference_sites, moving_sites, weights = None):

    self.nsites = len( reference_sites )
    assert self.nsites == len( moving_sites )

    self.reference_sites = reference_sites
    self.moving_sites = moving_sites

    if weights is None:
      weights = flex.double( [ 1 ] * self.nsites )

    self.set_new_weights( weights = weights )


  def set_new_weights(self, weights):

    if self.nsites != len( weights ):
      raise BadWeights("Weights not equal to number of sites")

    norm = flex.sum( weights )

    if norm <= 0:
      raise BadWeights("Zero weights")

    refmean = self.reference_sites.mean_weighted( weights )
    movmean = self.moving_sites.mean_weighted( weights )
    eor = ErrorOnRotation.from_sites(
      left = self.moving_sites - movmean,
      right = self.reference_sites - refmean,
      weights = weights,
      )
    q = eor.best_rotation()
    self.rmsd = math.sqrt( eor.for_quaternion( q = q ) / norm )
    self.r = quaternion_to_rotmat( q = q )
    self.t = matrix.col( refmean ) - self.r * matrix.col( movmean )


  @property
  def rt(self):

    return matrix.rt( ( self.r, self.t ) )


  @property
  def positional_error_squares(self):

    transformed = transform_sites(
      sites = self.moving_sites,
      rotation = self.r,
      translation = self.t,
      )

    differences = transformed - self.reference_sites
    return differences.dot( differences )


class MultipleSuperposition(object):
  """
  Base class for multiple superpositions
  """

  def __init__(self, site_sets):

    self.set_count = len( site_sets )
    assert 2 <= self.set_count
    self.site_count = len( site_sets[0] )
    assert all( len( s ) == self.site_count for s in site_sets[1:] )
    self.site_sets = site_sets


  def rotations(self):

    return [ matrix.sqr( quaternion_to_rotmat( q ) ) for q in self.qs ]


  def transformations(self):

    rotations = self.rotations()
    return (
      rotations,
      [ -r * matrix.col( t ) for ( r, t ) in zip( rotations, self.centroids ) ],
      )


  def transformed_sites(self):

    ( rotations, translations ) = self.transformations()

    return [
      transform_sites( sites = sites, rotation = rot, translation = tra )
      for ( sites, rot, tra ) in zip( self.site_sets, rotations, translations )
      ]


  def rmsds(self, weights):

    transformed = self.transformed_sites()

    norm = 1.0 / ( self.set_count - 1 )
    return [
      norm * sum(
        [ weighted_error_between( left = l, right = r, weights = weights )
          for r in transformed ]
        )
      for l in transformed
      ]


  def unweighted_rmsd_between(self, left, right):

    ( rotations, translations ) = self.transformations()

    lsites = transform_sites(
      sites = self.site_sets[ left ],
      rotation = rotations[ left ],
      translation = translations[ left ],
      )
    rsites = transform_sites(
      sites = self.site_sets[ right ],
      rotation = rotations[ right ],
      translation = translations[ right ],
      )

    return math.sqrt(
      weighted_error_between(
        left = lsites,
        right = rsites,
        weights = flex.double( [ 1 ] * self.site_count ),
        )
      )


class DiamondAlgorithm(MultipleSuperposition):
  """
  Multiple superposition using Diamond's algorithm
  """

  def __init__(self, site_sets, weights):

    super( DiamondAlgorithm, self ).__init__( site_sets = site_sets )

    # Calculate initial rotations
    self.prepare_new_weights( weights = weights )
    self.calculate_pairwise_error_matrix()
    column = [ r[0] for r in self.pw_matrix.rows() ]
    self.qs = ( [ matrix.col( [ 0, 0, 0, 1 ] ) ]
      + [ eor.best_rotation() for eor in column[1:] ] )
    self.totals = [ None ] * self.set_count
    self.calculate_total_error_vector()


  # Commands
  def set_new_weights(self):

    self.calculate_pairwise_error_matrix()
    self.calculate_total_error_vector()


  def prepare_new_weights(self, weights):

    assert len( weights ) == self.site_count

    if flex.sum( weights ) <= 0:
      raise BadWeights("Zero weights")

    self.new_weight_data = weights


  def full_iteration(self):

    self.qs = [ matrix.col( top_quaternion( p = t.p ) ) for t in self.totals ]
    self.calculate_total_error_vector()


  # Queries
  def rmsd_between(self, left, right):

    if left == right:
      return 0.0

    eor = ( self.pw_matrix.get( left = left, right = right )
      .with_rotated_reference( q = self.qs[ right ] ) )
    square = eor.for_quaternion( q = self.qs[ left ] ) / self.norm

    return math.sqrt( square if 0 <= square else 0 )


  def weighted_rmsds(self):

    norm = 1.0 / ( self.set_count - 1 )
    return [ math.sqrt( r / self.norm * norm ) for r in self.residuals() ]


  def unweighted_rmsds(self):

    transformed = self.transformed_sites()
    weights = flex.double( [ 1 ] * self.site_count )

    norm = 1.0 / ( self.set_count - 1 )
    return [
      math.sqrt(
        norm * sum(
          [ weighted_error_between( left = l, right = r, weights = weights )
              for r in transformed ]
          )
        )
      for l in transformed
      ]


  def rmsd(self):

    return math.sqrt(
       self.residual() / ( self.set_count * ( self.set_count - 1 ) * self.norm )
      )


  def residual(self):

    return sum( self.residuals() )


  def residuals(self):

    return [ t.for_quaternion( q = q ) for ( q, t ) in zip( self.qs, self.totals ) ]


  def average_structure(self):

    return self.average_structure_from_transformed_sites(
      transformeds = self.transformed_sites(),
      )


  def distance_squares_from_average_structure(self):

    transformed = self.transformed_sites()
    average = self.average_structure_from_transformed_sites(
      transformeds = self.transformed_sites(),
      )
    differences = [ t - average for t in transformed ]
    return 1.0 / ( self.set_count - 1 ) * reduce(
      operator.add,
      [ diff.dot( diff ) for diff in differences ]
      )


  # Internal methods
  def average_structure_from_transformed_sites(self, transformeds):

    return 1.0 / self.set_count * reduce( operator.add, transformeds )


  def calculate_pairwise_error_matrix(self):

    self.norm = flex.sum( self.new_weight_data )
    assert 0 < self.norm

    # Calculate centroids
    self.centroids = flex.vec3_double(
      [ s.mean_weighted( self.new_weight_data ) for s in self.site_sets ]
      )
    origin_sets = [ c - o for ( c, o ) in zip( self.site_sets, self.centroids ) ]

    # Calculate starting pairwise squared error matrix
    self.pw_matrix = Matrix( n = self.set_count, m = self.set_count )

    for i in range( self.set_count ):
      for j in range( i + 1, self.set_count ):
        pw = ErrorOnRotation.from_sites(
          left = origin_sets[ i ],
          right = origin_sets[ j ],
          weights = self.new_weight_data,
          )
        self.pw_matrix.set( left = i, right = j, value = pw )
        self.pw_matrix.set(
          left = j,
          right = i,
          value = ErrorOnRotation( e = pw.e, p = i_bar * pw.p * i_bar ),
          )


  def calculate_total_error_vector(self):

    for ( index, row ) in enumerate( self.pw_matrix.rows() ):
      transformed_off_diagonal = [
        eor.with_rotated_reference( q = q )
        for ( i, ( eor, q ) ) in enumerate( zip( row, self.qs ) )
        if i != index
        ]
      sum_e = sum( [ eor.e for eor in transformed_off_diagonal ] )
      sum_p = reduce(
        operator.add,
        [ eor.p for eor in transformed_off_diagonal ],
        )
      self.totals[ index ] = ErrorOnRotation( e = sum_e, p = sum_p )


class WangSnoeyinkAlgorithm(MultipleSuperposition):
  """
  Multiple structure alignment with gaps using the algorithm from
  Wang & Snoeyink
  """

  def __init__(self, site_sets, selections, weights):

    super( WangSnoeyinkAlgorithm, self ).__init__( site_sets = site_sets )

    assert len( selections ) == self.set_count
    assert all( len( s ) == self.site_count for s in selections )

    self.selections = selections
    self.norms = reduce(
      operator.add,
      [ s.as_double() for s in self.selections ],
      )

    if not all( 2 <= v for v in self.norms ):
      raise BadSiteSets("Single positions in supplied site sets")

    self.qs = [ matrix.col( [ 0, 0, 0, 1 ] ) ] * self.set_count
    self.origins = [ ( 0, 0, 0 ) ] * self.set_count
    self.prepare_new_weights( weights = weights )
    self.set_new_weights()


  def set_new_weights(self):

    ( atomic_weights, sums ) = self.next_weight_data

    self.weights = atomic_weights
    self.sums = sums
    self.centroids = [
      s.mean_weighted( w ) for ( s, w ) in zip( self.site_sets, self.weights )
      ]
    self.calculate_superposition_errors()


  def prepare_new_weights(self, weights):

    assert len( weights ) == self.site_count
    atomic_weights = [
      weights.deep_copy().set_selected( ~s, 0 ) for s in self.selections
      ]
    sums = [ flex.sum( w ) for w in atomic_weights ]

    if not all( 0 < s for s in sums ):
      raise BadWeights("Zero weights")

    self.next_weight_data = ( atomic_weights, sums )


  def calculate_superposition_errors(self):

    average = self.average_structure()
    self.origins = [ average.mean_weighted( w ) for w in self.weights ]
    self.errors = [
      ErrorOnRotation.from_sites(
        left = sites - centroid,
        right = average - origin,
        weights = weights,
        )
      for ( sites, centroid, origin, weights ) in zip(
        self.site_sets,
        self.centroids,
        self.origins,
        self.weights,
        )
      ]


  def full_iteration(self):

    self.qs = [ eor.best_rotation() for eor in self.errors ]
    self.calculate_superposition_errors()


  def rmsd_between(self, left, right):

    ( rotations, translations ) = self.transformations()

    lsites = transform_sites(
      sites = self.site_sets[ left ],
      rotation = rotations[ left ],
      translation = translations[ left ],
      )
    rsites = transform_sites(
      sites = self.site_sets[ right ],
      rotation = rotations[ right ],
      translation = translations[ right ],
      )

    return math.sqrt(
      weighted_error_between(
        left = lsites,
        right = rsites,
        weights = self.weights[ left ] * self.weights[ right ],
        )
      )


  def weighted_rmsds(self):

    return self.rmsds( weights = self.weights )


  def unweighted_rmsds(self):

    return self.rmsds( weights = [ s.as_double() for s in self.selections ] )


  def rmsd(self):

    return math.sqrt( 2.0 / ( self.set_count - 1 ) * self.residual() )


  def residual(self):

    return sum( [ eor.for_quaternion( q = q ) / s for ( q, eor, s )
      in zip( self.qs, self.errors, self.sums ) ] )


  def transformations(self):

    ( rotations, translations ) = super( WangSnoeyinkAlgorithm, self ).transformations()

    return (
      rotations,
      [ t + matrix.col( o ) for ( t, o ) in zip( translations, self.origins ) ],
      )


  def average_structure(self):

    return self.average_structure_from_transformed_sites(
      transformeds = self.transformed_sites(),
      )


  def distance_squares_from_average_structure(self):

    transformeds = self.transformed_sites()
    average = self.average_structure_from_transformed_sites(
      transformeds = transformeds,
      )
    differences = [ s - average for s in transformeds ]

    return (
      reduce(
        operator.add,
        [ s.as_double() * d.dot( d ) for ( d, s )
          in zip( differences, self.selections ) ],
        )
      / ( self.norms - 1.0 )
      )


  def rmsds(self, weights):

    transformed = self.transformed_sites()
    norm = 1.0 / ( self.set_count - 1 )

    return [
      math.sqrt(
        norm * sum(
          [ weighted_error_between( left = l, right = r, weights = wl * wr )
            for ( r, wr ) in zip( transformed, weights ) ]
          )
        )
      for ( l, wl ) in zip( transformed, weights )
      ]


  # Internal methods
  def average_structure_from_transformed_sites(self, transformeds):

    return (
      reduce(
        operator.add,
        [ s.set_selected( ~sel, ( 0, 0, 0 ) ) for ( s, sel )
          in zip( transformeds, self.selections ) ]
        )
      / self.norms
      )

# Weighting
class UnitWeightScheme(object):
  """
  Unit weights
  """

  def for_difference_squares(self, squares):

    return flex.double( [ 1.0 ] * len( squares ) )


  def __str__(self):

    return "Unit weighting scheme"


class RobustResistantWeightScheme(object):
  """
  Robust-resistant weights
  """

  def __init__(self, critical_value_square):

    self.critical_value_square = float( critical_value_square )


  def for_difference_squares(self, squares):

    sqr_w = 1.0 - squares / self.critical_value_square
    sqr_w.set_selected( sqr_w < 0.0, 0.0 )
    return sqr_w * sqr_w


  def __str__(self):

    return "Robust-resistant weighting scheme (critical value: %s)" % (
      self.critical_value_square,
      )


 *******************************************************************************


 *******************************************************************************
scitbx/math/periodogram.py
#
# periodogram.py
#
#  Copyright (C) (2016) STFC Rutherford Appleton Laboratory, UK.
#
#  Author: David Waterman.
#
#  This code is distributed under the BSD license, a copy of which is
#  included in the root directory of this package.
#
"""Calculate the periodogram of real evenly-spaced data"""

from __future__ import absolute_import, division, print_function
from scitbx.array_family import flex
from scitbx import fftpack
from six.moves import range

class Kernel(object):
  """A discrete symmetric normalized smoothing kernel for use with kernapply.
  Currently allowed types are 'daniell' or 'modified.daniell', with 'm' giving
  the kernel dimension. Alternatively, provide the upper half of the smoothing
  kernel coefficients as 'coef' directly"""

  def __init__(self, name='daniell', m=2, coef=None):
    if coef is not None:
      self.m = len(coef) - 1
      self.name = None
      self.coef = flex.double(coef)
      if abs(2.0 * flex.sum(self.coef[1:]) + self.coef[0] - 1) > 1.e-10:
        raise ValueError('Coefficients do not add to 1')
      return

    if not name in ['daniell', 'modified.daniell']:
      raise TypeError('Unknown kernel type "{0}"'.format(name))

    self.m = m
    self.name = name
    if name == 'daniell': self._set_daniell()
    if name == 'modified.daniell': self._set_modified_daniell()
    return

  def _set_daniell(self):
    self.coef = flex.double(self.m + 1, 1./(2. * self.m + 1))

  def _set_modified_daniell(self):
    self.coef = flex.double(self.m + 1, 1./(2. * self.m))
    self.coef[self.m] = self.coef[self.m] * 0.5

def kernapply(x, k, circular=False):
  """Convolve a sequence x with a Kernel k"""

  x = flex.double(x).deep_copy()
  lenx = len(x)
  w = flex.double(lenx, 0.0)
  w.set_selected(flex.size_t_range(k.m + 1), k.coef)
  sel = lenx -1 - flex.size_t_range(k.m)
  w.set_selected(sel, k.coef[1:])

  # do convolution in the Fourier domain
  fft = fftpack.real_to_complex(lenx)
  n = fft.n_real()
  m = fft.m_real()
  x.extend(flex.double(m-n, 0.))
  w.extend(flex.double(m-n, 0.))
  conv = fft.forward(x) * fft.forward(w)

  # extend result by the reverse conjugate, omitting the DC offset and Nyquist
  # frequencies. If fft.n_real() is odd there is no Nyquist term.
  end = fft.n_complex() - (fft.n_real() + 1) % 2
  conv.extend(flex.conj(conv[1:end]).reversed())

  # transform back, take real part and scale
  fft = fftpack.complex_to_complex(len(conv))
  result = fft.backward(conv).parts()[0] / n

  if circular:
    return result
  else:
    return result[(k.m):(lenx-k.m)]

class Periodogram(object):
  """Calculate the periodogram of real evenly-spaced data. This class gives
  the same spectrum as R's spec.pgram function when called using
  spec.pgram(x, detrend=F, taper=0, fast=F)"""

  def __init__(self, x, spans=None, demean=True, detrend=True):

    # Ensure x is copied as it will be changed in-place
    x = flex.double(x).deep_copy()
    n = len(x)

    if detrend:
      t = flex.size_t_range(n).as_double() + 1 - (n + 1)/2
      inv_sumt2 = 1./t.dot(t)
      x = x - flex.mean(x) - x.dot(t) * t * inv_sumt2
    elif demean:
      x -= flex.mean(x)

    # determine frequencies
    stop = ((n - (n % 2)) // 2) + 1
    self.freq = flex.double([i / n for i in range(1, stop)])

    fft = fftpack.real_to_complex(n)
    n = fft.n_real()
    m = fft.m_real()
    x.extend(flex.double(m-n, 0.))
    xf = fft.forward(x)

    # get abs length of complex and normalise by n to get the raw periodogram
    spec = flex.norm(xf) / n

    if spans is None:
      # if not doing smoothing, the spectrum is just the raw periodogram with
      # the uninteresting DC offset removed
      self.spec = spec[1:]
      return

    # for smoothing replace the DC offset term and extend the rest of the
    # sequence by its reverse conjugate, omitting the Nyquist term if it is
    # present
    spec[0] = spec[1]
    end = fft.n_complex() - (fft.n_real() + 1) % 2
    spec.extend(spec[1:end].reversed())

    try:
      # multiple integer spans
      nspans = len(spans)
      m = int(spans[0]) // 2
      multiple = True
    except TypeError:
      # single integer span
      m = int(spans) // 2
      multiple = False

    # construct smoothing kernel
    k = Kernel('modified.daniell', m)

    if multiple:
      for i in range(1, nspans):
        # construct kernel for convolution
        m1 = int(spans[i]) // 2
        k1 = Kernel('modified.daniell', m1)

        # expand coefficients of k to full kernel and zero pad for smoothing
        x1 = flex.double(k1.m, 0.0)
        x1.extend(k.coef.reversed())
        x1.extend(k.coef[1:])
        x1.extend(flex.double(k1.m, 0.0))

        # convolve kernels
        coef = kernapply(x1, k1, circular=True)
        m = len(coef)//2
        coef = coef[m:(len(coef))]
        k = Kernel(coef=coef)

    # apply smoothing kernel
    spec = kernapply(spec, k, circular=True)
    self.spec = spec[1:fft.n_complex()]

    return

  def plot(self, sample_interval=1.0, show=True):

    import matplotlib.pyplot as plt

    # convert frequency to natural units given the sample_interval
    sample_freq = 1./sample_interval
    freq = self.freq * sample_freq

    line, = plt.semilogy(freq, self.spec)
    plt.xlabel('frequency')
    plt.ylabel('spectrum')
    if show: plt.show()
    return plt



 *******************************************************************************


 *******************************************************************************
scitbx/math/scale_curves.py
from __future__ import absolute_import, division, print_function
from scitbx import differential_evolution as de
from scitbx.array_family import flex
import sys
from libtbx.test_utils import approx_equal
from six.moves import range
from six.moves import zip

class curve_interpolator(object):
  def __init__(self, start, stop, n_points=100):
    self.start    = start
    self.stop     = stop
    self.n_points = n_points
    self.target_x = flex.double( range(n_points) )/float(n_points-1)
    self.target_x = self.target_x*(self.stop-self.start)+self.start
    self.delta    = self.target_x[1]-self.target_x[0]

  def interpolate(self, x_array, y_array):
    index_array = []
    result_array = []

    start_index_user = None
    end_index_user = None

    start_index_target = None
    end_index_target = None

    user_min = flex.min( x_array )
    user_max = flex.max( x_array )

    for jj,x in enumerate(self.target_x):
      this_index = None
      break_again = False
      for index,this_x in enumerate(x_array):
        if this_x - x >= 0:
          if x >= user_min:
            if x <= user_max:
              this_index = index
              if start_index_user is None:
                 start_index_user = this_index
              if start_index_target is None:
                start_index_target = jj
              end_index_user = this_index
              end_index_target = jj
              break
      index_array.append( this_index )
      y = None
      if this_index is not None:
        if this_index == 0:
          y = self.two_point_interpolate( x,
                                          x_array[this_index  ], y_array[this_index  ],
                                          x_array[this_index+1], y_array[this_index+1] )
        elif this_index == len(x_array)-1:
          y = self.two_point_interpolate( x,
                                          x_array[this_index-1], y_array[this_index-1],
                                          x_array[this_index], y_array[this_index] )

        else:
          y = self.parabolic_interpolate( x,
                                          x_array[this_index-1], y_array[this_index-1],
                                          x_array[this_index  ], y_array[this_index  ],
                                          x_array[this_index+1], y_array[this_index+1] )

        result_array.append( y )


    n = len(result_array)
    x = flex.double(self.target_x[start_index_target:end_index_target+1])
    y = flex.double(result_array)
    return x,y,(start_index_user,end_index_user),(start_index_target,end_index_target)

  def two_point_interpolate(self,x, xo, fxo, xp, fxp):
    ph = x-xo
    h = xp-xo
    p = ph
    if ph >0:
      p = ph/h
    result = (1-p)*fxo + p*fxp
    return result

  def parabolic_interpolate(self, x, xm, fxm, xo, fxo, xp, fxp):
    result = fxm*( (x-xo)*(x-xp) )/ ( (xm-xo)*(xm-xp) ) + \
             fxo*( (x-xm)*(x-xp) )/ ( (xo-xm)*(xo-xp) ) + \
             fxp*( (x-xm)*(x-xo) )/ ( (xp-xm)*(xp-xo) )
    return result









class linear_scaler(object):
  """This class scales together varios curves. means and varainces should be lists of flex arrays"""
  def __init__(self, means, variances, reference_id=0,init_mean=1.0,spread=0.1, factor=50,f=0.7,eps=1e-12,out=None,show_progress=False,insert_solution_vector=None,add=True):
    self.out = None
    if self.out is None:
      self.out = sys.stdout

    self.add=add

    self.means = means
    self.vars  = variances
    self.ref = reference_id
    self.n_sets = len( self.means)
    self.map = self.setup_coeff_map()

    self.n = (len(self.means)-1)*2
    self.x = None
    self.domain = [ ( -spread+init_mean,spread+init_mean ) ]*self.n
    self.optimizer =  de.differential_evolution_optimizer(self,population_size=self.n*factor,show_progress=show_progress,eps=eps, f=f,n_cross=2,cr=0.8,insert_solution_vector=insert_solution_vector)

  def setup_coeff_map(self):
    """ ii: datset number ; result[ii]=associated scale_factor index """
    result = []
    count = 0
    for ii in range(self.n_sets):
      if ii != self.ref:
        result.append( count )
        count += 1
      else:
        result.append( None )
    return result

  def get_mean(self,scales,offsets):
    if self.n_sets>2:
      result = self.means[self.ref]*0
      weights = self.means[self.ref]*0
      for m,v,s,o in zip(self.means,self.vars,scales,offsets):
        mm = s*(m+o)
        w = 1/(flex.sqrt(v)+1e-8)
        weights += w
        result = result + mm*w
      result = result/weights
      return result
    else:
      return self.means[self.ref]

  def get_scales_offsets(self,vector):
    scales = []
    offsets = []
    for scale in range(self.n_sets):
      tmp_scale = 1.0
      tmp_offset = 0.0
      if scale != self.ref:
        tmp_scale = abs(vector[self.map[scale]])
        tmp_offset= vector[self.map[scale]+self.n_sets-1]
        if not self.add:
          tmp_offset=0.0
      scales.append( tmp_scale )
      offsets.append( tmp_offset )
    return scales , offsets

  def target(self,vector):
    scales, offsets = self.get_scales_offsets(vector)
    dr = self.get_mean(scales,offsets)
    result = 0
    for jj in range(self.n_sets):
      dj =  scales[jj]*(self.means[jj]+offsets[jj])
      vj =  self.vars[jj]*scales[jj]*scales[jj]
      t  =  flex.pow((dj-dr),2)/( 1e-13 + vj )
      if self.n_sets != 2:
        result += flex.sum( t )
      else:
        if jj != self.ref:
          vr = self.vars[self.ref]
          result += flex.sum(flex.pow((dj-dr),2)/( 1e-13 + vj + vr ))
    return result

  def print_status(self, best,mean,vector,count):
    scales,offsets = self.get_scales_offsets(vector)
    print("PROGRESS", file=self.out)
    print(count, best, mean, file=self.out)
    print(scales, file=self.out)
    print(offsets, file=self.out)
    print(file=self.out)


  def retrieve_results(self):
    scales,offsets = self.get_scales_offsets( self.x )
    return scales,offsets,self.map

def scale_it_global(m,v,ref_id=0,factor=10,show_progress=False,add=True):
  scaler_object = linear_scaler( m,v,ref_id,factor=factor,show_progress=show_progress,add=add)
  s,o,m = scaler_object.retrieve_results()
  return s,o

def scale_it_pairwise(m,v,ref_id=0,factor=10,show_progress=False,add=True):
  n = len(m)
  scales = []
  ofsets = []
  for ii in range(n):
    if ii != ref_id:
      ms = [ m[ref_id],m[ii] ]
      vs = [ m[ref_id],m[ii] ]
      scaler_object = linear_scaler( ms,vs,0,factor=factor,show_progress=show_progress,add=add)
      s,o,map = scaler_object.retrieve_results()
      scales.append( s[1] )
      ofsets.append( o[1] )
    else:
      scales.append( 1.0 )
      ofsets.append( 0.0 )
  return scales, ofsets

def test_curve_scaler():
   flex.set_random_seed( 12345 )
   x = flex.double( range(10) )/10.0
   y = flex.exp( -x )
   y0 = y
   y1 = y*100+50
   y2 = y*1000+500
   v0 = y0*0+1
   v1 = y0*0+1.0
   v2 = v1

   scaler_object = linear_scaler( [y0,y1,y2], [v0,v1,v2], 0 , factor=5,show_progress=False)
   s,o,m = scaler_object.retrieve_results()
   assert approx_equal(s[1],0.01,eps=1e-3)
   assert approx_equal(s[2],0.001,eps=1e-3)
   assert approx_equal(o[1],-50,eps=1e-2)
   assert approx_equal(o[2],-500,eps=1e-2)

   s,o = scale_it_pairwise([y0,y1,y2],[v0,v1,v2],0, show_progress=False)
   assert approx_equal(s[1],0.01,eps=1e-3)
   assert approx_equal(s[2],0.001,eps=1e-3)
   assert approx_equal(o[1],-50,eps=1e-2)
   assert approx_equal(o[2],-500,eps=1e-2)



def tst_curve_interpolator():
  x = flex.double( range(25) )/24.0
  y = x*x
  ip = curve_interpolator(0,2.0,200)
  x_target = ip.target_x
  y_ref = x_target*x_target
  nx,ny,a,b = ip.interpolate(x,y)
  count = 0
  for xx in x_target:
    if flex.max(x) >= xx:
      count += 1
  assert count==len(nx)


  for yy,yyy in zip(ny,y_ref):
    assert approx_equal(yy,yyy,eps=1e-3)
  assert a[0]==0
  assert a[1]==24
  assert b[0]==0
  assert b[1] in (99,100)


  x = flex.double( range(5,23) )/24.0
  y = x*x
  ip = curve_interpolator(0,2.0,200)
  nx,ny,a,b = ip.interpolate(x,y)
  assert nx[0] >= flex.min(x)
  assert nx[-1] <= flex.max(x)
  y_ref= nx*nx
  for yy,yyy in zip(ny,y_ref):
    assert approx_equal(yy,yyy,eps=1e-3)


if __name__ == "__main__":
  test_curve_scaler()
  tst_curve_interpolator()
  print("OK")


 *******************************************************************************


 *******************************************************************************
scitbx/math/sieve_of_eratosthenes.py
from __future__ import absolute_import, division, print_function
import math
from six.moves import range

def prime_sieve( n,
           include_unity=False
         ):
  numbers  = []
  marks = []
  primes = []
  for ii in range(n):
    numbers.append( ii+1 )
    marks.append( False )
  marks[0]=True
  k = 1
  if include_unity:
    primes.append( 1 )

  while k <=  math.sqrt(float(n)):
    m=None
    for ii in range(n):
      if m == None:
        if numbers[ii]>k:
          if not marks[ii]:
            m=numbers[ii]
            primes.append( m )

      if m != None:
        if numbers[ii]%m == 0:
          marks[ii]=True
    k = m

  for ii in range(n):
    if not marks[ii]:
      primes.append( numbers[ii] )

  return primes


def tst_prime_sieve():
  known = [2,3,5,7]
  test = prime_sieve( 10 )
  assert ( known ==  test )

if (__name__ == "__main__"):
  tst_prime_sieve()
  print("OK")


 *******************************************************************************


 *******************************************************************************
scitbx/math/so3_lie_algebra.py
from __future__ import absolute_import, division, print_function
import scitbx.matrix

import operator
import math
from functools import reduce
from six.moves import zip

__doc__ = """
Chirikjian, G. Stochastic models, information theory, and Lie groups.
Volume 2, pp 39-40.
Applied and Numerical Harmonic Analysis, Birkhauser
"""

class element(object):
  """
  An element of the Lie algebra so(3)
  """

  BASES = [
      scitbx.matrix.sqr( ( 0, 0, 0, 0, 0, -1, 0, 1, 0 ) ),
      scitbx.matrix.sqr( ( 0, 0, 1, 0, 0, 0, -1, 0, 0 ) ),
      scitbx.matrix.sqr( ( 0, -1, 0, 1, 0, 0, 0, 0, 0 ) ),
      ]

  def __init__(self, vector):

    self.vector = vector

  @property
  def matrix(self):

    return reduce(
      operator.add,
      [ x * e for ( x, e ) in zip( self.vector, self.BASES ) ],
      )

  def exponential(self):

    x2 = self.vector.length_sq()

    if 0 < x2:
      x = math.sqrt( x2 )
      a1 = math.sin( x ) / x
      a2 = ( 1.0 - math.cos( x ) ) / ( x * x )

    else:
      a1 = 1.0
      a2 = 0.5

    matrix = self.matrix

    return (
      scitbx.matrix.identity( 3 )
      + a1 * matrix
      + a2 * matrix * matrix
      )

  def scalar_multiplied(self, value):

    return self.__class__( vector = self.vector * value )

  def norm_sq(self):

    return 2 * self.vector.norm_sq()

  def __add__(self, other):

    return self.__class__( vector = self.vector + other.vector )

  def __sub__(self, other):

    return self.__class__( vector = self.vector - other.vector )

  def __mul__(self, other):

    if isinstance( other, ( float, int ) ):
      return self.scalar_multiplied( value = other )

    return NotImplemented

  def __rmul__(self, other):

    if isinstance( other, ( float, int ) ):
      return self.scalar_multiplied( value = other )

    return NotImplemented

  @classmethod
  def from_rotation_matrix(cls, matrix):

    import scitbx.math
    return cls.from_lie_matrix(
      matrix = scitbx.math.r3_rotation_matrix_logarithm( matrix ),
      )

  @classmethod
  def from_lie_matrix(cls, matrix):

    return cls(
      scitbx.matrix.col(
        (
          ( matrix[7] - matrix[5] ) / 2.0,
          ( matrix[2] - matrix[6] ) / 2.0,
          ( matrix[3] - matrix[1] ) / 2.0,
          )
        )
      )


 *******************************************************************************


 *******************************************************************************
scitbx/math/spe.py
from __future__ import absolute_import, division, print_function
from scitbx.array_family import flex
from scitbx.stdlib import math
from six.moves import range

"""
This is a python implementation of the
Stochastic Proximity Embedding Algorithm
(J.Chem. Information and Modelling, 2011,51,2852-2859.

The algorithm implemented below is the
non-pivotted one. At the moment, we don't have any convergence criteria implemented
and run the routine for a fixed number of cycles only.

The input needed is a similarity maxtrix that looks like this

[ a0,a1,a2,a3,.....,an  ]

ai = [ (1,di1), (4,di4), ..., (j,dij) ]

the object ai is a list of tuples. The tuple has two items
- j
- dij
These two value convey the the message: object i has a distance of dij to object j.

The algorithm takes these distance constraint and embeds them in an object in N-dimensional space.

One could use this for very rough conformation generation from distance constraints from a molecule,
or for more classic multidimensional scaling type problems.

"""

class classic_spe_engine(object):
  def __init__(self, dmat,l=.850,max_cycle=10000):
    self.dmat = dmat
    self.l = l
    self.max_cycle = max_cycle
    self.dl = self.l/max_cycle
    self.eps=1e-12

  def embed(self,n_dimensions,n_points):
    x = []
    for ii in range(n_points):
      x.append( flex.random_double(n_dimensions)*100 )

    l = float(self.l)
    for mm in range(self.max_cycle):
      atom_order = flex.sort_permutation( flex.random_double(len(x))  )
      strain = 0.0
      for ii in atom_order:
        n_contacts = len(self.dmat[ii])
        jj_index = flex.sort_permutation( flex.random_double( n_contacts ) )[0]
        jj_info = self.dmat[ii][jj_index]
        jj = jj_info[0]
        td = jj_info[1]
        xi = x[ii]
        xj = x[jj]
        cd = math.sqrt( flex.sum( (xi-xj)*(xi-xj) ) )
        new_xi = xi + l*0.5*(td-cd)/(cd+self.eps)*(xi-xj)
        new_xj = xj + l*0.5*(td-cd)/(cd+self.eps)*(xj-xi)
        strain += abs(cd-td)
        x[ii] = new_xi
        x[jj] = new_xj
      l = l-self.dl
    return x,strain/len(x)


def tst():
  M=10
  xy = []
  for ii in range(M):
    r=10.0
    phi = ii*(math.pi*2/M)
    x = r*math.cos(phi)
    y = r*math.sin(phi)
    xy.append( flex.double([x,y]) )
  # build distance matrix
  dmat = []
  for ii in range(M):
    tmp = []
    for jj in range(M):

      x1=xy[ii][0]
      x2=xy[jj][0]

      y1=xy[ii][1]
      y2=xy[jj][1]

      dd = math.sqrt( (x1-x2)**2.0 +(y1-y2)**2.0  )
      if jj != ii:
          tmp.append( (jj,dd) )
    dmat.append( tmp )
  spee=classic_spe_engine( dmat, l=1.0,max_cycle=5000 )
  x,s = spee.embed(2,M)
  assert s<1e-4
  print("OK")

if __name__ == "__main__":
  tst()


 *******************************************************************************


 *******************************************************************************
scitbx/math/sphere_sphere_intersection.py
from __future__ import absolute_import, division, print_function
import math
pi = math.pi

def volume(radius_1, radius_2, distance):
  "http://mathworld.wolfram.com/Sphere-SphereIntersection.html"
  assert radius_1 >= 0
  assert radius_2 >= 0
  assert distance >= 0
  rrd = radius_1 + radius_2 - distance
  if (rrd <= 0):
    return 0
  if (distance <= abs(radius_1 - radius_2)):
    return 4/3 * pi * min(radius_1, radius_2)**3
  d = distance
  if (radius_1 == radius_2):
    return (pi * (4*radius_1 + d) * (2*radius_1 - d)**2) / 12
  if (radius_1 > radius_2):
    R, r = radius_1, radius_2
  else:
    R, r = radius_2, radius_1
  return pi * rrd**2 * (d**2 + 2*d*r - 3*r**2 + 2*d*R + 6*r*R - 3*R**2) \
       / (12*d)

def exercise():
  from libtbx.test_utils import approx_equal
  assert volume(0, 0, 0) == 0
  assert volume(1, 2, 4) == 0
  assert approx_equal(volume(4, 2, 1), 33.5103216383)
  assert approx_equal(volume(4, 4, 1), 218.078890037)
  assert approx_equal(volume(4+1.e-6, 4, 1), 218.078978001)
  assert approx_equal(volume(4, 4+1.e-6, 1), 218.078978001)
  assert approx_equal(volume(3, 4, 2), 94.9022780772)
  assert approx_equal(volume(4, 3, 2), 94.9022780772)
  assert approx_equal(volume(2, 2.3, 0), 33.5103216383)
  assert approx_equal(volume(2, 2.3, 0.3), 33.5103216383)
  assert approx_equal(volume(2, 2.3, 0.31), 33.505660942)
  assert approx_equal(volume(2, 2.3, 4.29), 0.000335811722418)
  assert approx_equal(volume(2, 2.3, 4.3), 0)
  print("OK")

if (__name__ == "__main__"):
  exercise()


 *******************************************************************************


 *******************************************************************************
scitbx/math/superpose.py
from __future__ import absolute_import, division, print_function
from scitbx.linalg import eigensystem
from scitbx.math import superpose_kearsley_rotation
from scitbx import matrix
from scitbx.stdlib import math, random
from scitbx.array_family import flex
from scitbx import differential_evolution as de
from scitbx.math import euler_angles as euler
from six.moves import range

def kearsley_rotation(reference_sites, other_sites):
  """
  Kearsley, S.K. (1989). Acta Cryst. A45, 208-210.
  On the orthogonal transformation used for structural comparison

  Added by Peter H. Zwart, Nov 3rd, 2006.
  Converted to C++ by Gabor Bunkoczi, Apr 2008.
  """
  return matrix.sqr(superpose_kearsley_rotation(
    reference_sites=reference_sites,
    other_sites=other_sites))

def kabsch_rotation(reference_sites, other_sites):
  """
Kabsch, W. (1976). Acta Cryst. A32, 922-923.
A solution for the best rotation to relate two sets of vectors

Based on a prototype by Erik McKee and Reetal K. Pai.

This implementation does not handle degenerate situations correctly
(e.g. if all atoms are on a line or plane) and should therefore not
be used in applications. It is retained here for development purposes
only.
  """
  assert reference_sites.size() == other_sites.size()
  sts = matrix.sqr(other_sites.transpose_multiply(reference_sites))
  eigs = eigensystem.real_symmetric((sts * sts.transpose()).as_sym_mat3())
  vals = list(eigs.values())
  vecs = list(eigs.vectors())
  a3 = list(matrix.col(vecs[:3]).cross(matrix.col(vecs[3:6])))
  a = matrix.sqr(list(vecs[:6])+a3)
  b = list(a * sts)
  for i in range(3):
    d = math.sqrt(math.fabs(vals[i]))
    if (d > 0):
      for j in range(3):
        b[i*3+j] /= d
  b3 = list(matrix.col(b[:3]).cross(matrix.col(b[3:6])))
  b = matrix.sqr(b[:6]+b3)
  return b.transpose() * a

class least_squares_fit(object):

  def __init__(self, reference_sites, other_sites, method="kearsley"):
    assert method in [None, "kearsley", "kabsch"]
    if (method is None): method = "kearsley"
    self.reference_sites = reference_sites
    self.other_sites = other_sites
    self.reference_shift = reference_sites.mean()
    self.other_shift = other_sites.mean()
    self.r = None
    if method == "kearsley":
      self.r = kearsley_rotation(
        reference_sites-self.reference_shift,
        other_sites-self.other_shift)
    if method == "kabsch":
      self.r = kabsch_rotation(
        reference_sites-self.reference_shift,
        other_sites-self.other_shift)
    self.t = matrix.col(self.reference_shift) \
           - self.r * matrix.col(self.other_shift)

  def other_sites_best_fit(self, additional_sites=None):
    if additional_sites:
      return self.r.elems * self.other_sites.concatenate(additional_sites) \
             + self.t.elems
    else:
      return self.r.elems * self.other_sites + self.t.elems

  def rt(self):
    return matrix.rt(tuple_r_t=(self.r, self.t))

# TODO test
def sieve_fit(sites_fixed,
               sites_moving,
               selection=None,
               frac_discard=0.5):
  """
  Reference: Chothia & Lesk???
  """
  assert (sites_fixed.size() == sites_moving.size() > 0)
  if (selection is None):
    selection = flex.bool(sites_fixed.size(), True)
  # step 1: superpose using originally selected atoms
  sites_fixed_aln = sites_fixed.select(selection)
  sites_moving_aln = sites_moving.select(selection)
  lsq_fit_obj = least_squares_fit(
    reference_sites=sites_fixed_aln,
    other_sites=sites_moving_aln)
  sites_moving_new = lsq_fit_obj.other_sites_best_fit()
  # step 2: discard 50% of sites that deviate the most, and superpose again
  deltas = (sites_fixed_aln - sites_moving_new).norms()
  deltas_sorted = flex.sorted(deltas)
  cutoff = deltas_sorted[int((1-frac_discard)*deltas.size())]
  selection = (deltas > cutoff)
  if (selection.count(True) == 0):
    return lsq_fit_obj
  sites_fixed_aln = sites_fixed_aln.select(selection)
  sites_moving_aln = sites_moving_aln.select(selection)
  lsq_fit_obj = least_squares_fit(
    reference_sites=sites_fixed_aln,
    other_sites=sites_moving_aln)
  return lsq_fit_obj

"""
The NSD engine is a simple implementation of the normalized spatial discrepancy
as discussed by Kochin & Svergun J. Appl. Cryst 2001, 34, 33-41.

It can be used as a target for structure super positioning when no point-point correspondence is known.
"""

class nsd_engine(object):
  def __init__(self, fixed, d_fixed=None, d_moving=None):
    self.fixed = fixed
    self.d_fixed = d_fixed
    self.d_moving = d_moving
    if self.d_fixed is None:
      self.d_fixed = self.get_mean_distance(self.fixed)


  def get_mean_distance(self,xyz):
    N = xyz.size()
    d = 0
    count=0
    for ii in range(N):
      for jj in range(ii+1,N):
        dd = flex.double(xyz[ii])-flex.double(xyz[jj])
        d += dd.norm()
        count += 1
    d = d / count
    return d*d


  def nsd(self,moving,d_moving=None):
    if self.d_moving is None:
      self.d_moving = self.get_mean_distance(moving)
    if d_moving is not None:
      self.d_moving = d_moving

    # loop over all sites in fixed, find the minimum for each site
    tot_rho_mf = 0
    tot_rho_fm = 0
    for site in moving:
      dd = self.fixed-site
      dd = flex.min( dd.norms() )
      tot_rho_mf+=dd*dd

    for site in self.fixed:
      dd = moving-site
      dd = flex.min( dd.norms() )
      tot_rho_fm+=dd
    tot_rho_fm = tot_rho_fm / (self.fixed.size()*self.d_fixed )
    tot_rho_mf = tot_rho_mf / (moving.size()*self.d_moving )
    result = math.sqrt((tot_rho_fm+tot_rho_mf)/2.0)
    return result


class nsd_rigid_body_fitter(object):
  def __init__(self, fixed, moving):
    self.fixed = fixed
    self.moving = moving

    self.nsde = nsd_engine(self.fixed)

    self.d_fixed  = math.sqrt(self.nsde.d_fixed)
    self.d_moving = math.sqrt(self.nsde.get_mean_distance( self.moving ) )

    self.m_com = self.moving.mean()
    self.f_com = self.fixed.mean()
    self.n_mov = self.moving-self.m_com

    self.d = (self.d_fixed+self.d_moving)/12

    self.n = 6
    pi = math.pi
    self.domain = [ (-pi,pi),(-pi,pi), (-pi,pi), (-self.d,self.d),(-self.d,self.d), (-self.d,self.d) ]
    self.x = None
    self.optimizer = de.differential_evolution_optimizer(self, population_size=12,f=0.85,cr=0.95, n_cross=2,eps=1e-2,
                         show_progress=False,show_progress_nth_cycle=20)




  def move_points(self,vector):
    shift = (vector[0], vector[1], vector[2])
    abg   =  ( vector[3], vector[4], vector[5] )
    matrix = euler.zyz_matrix( vector[3], vector[4], vector[5] )
    new_xyz = matrix*self.n_mov+self.f_com+shift
    return new_xyz


  def target(self,vector):
    nxyz = self.move_points(vector)
    result = self.nsde.nsd(nxyz)
    return result

  def print_status(self, min_target, mean_target, best_vector, txt):
    print(min_target,mean_target,list(best_vector), txt)

  def best_shifted(self):
    nxyz = self.move_points(self.x)
    return nxyz


def tst_nsd():
  moving1 = flex.vec3_double()
  moving2 = flex.vec3_double()
  fixed  = flex.vec3_double()
  max_noise = 0
  for ii in range(10):
    noise = flex.random_double(3)*2-1.0
    if noise.norm() > max_noise:
      max_noise = noise.norm()
    xyz = flex.random_double(3)*5
    fixed.append( list(xyz) )
    moving1.append(  list(xyz + noise/10) )
    moving2.append(  list(xyz + noise/2) )

  ne = nsd_engine(fixed)
  a = ne.nsd(fixed)
  b = ne.nsd(moving1)
  c = ne.nsd(moving2)
  assert abs(a)<1e-6
  assert(b<=c)

  matrix = euler.zyz_matrix(0.7,1.3,2.1)
  fixed_r = matrix*moving1+(8,18,28)
  fitter = nsd_rigid_body_fitter( fixed,fixed_r)
  nxyz = fitter.best_shifted()
  dd = nxyz[0:fixed.size()]-fixed
  dd = dd.norms()
  dd = flex.max(dd)
  assert (dd<2.00*max_noise/10)


if __name__ == "__main__":
  random.seed(0)
  flex.set_random_seed(0)
  for ii in range(10):
    tst_nsd()
  print("OK")


 *******************************************************************************


 *******************************************************************************
scitbx/math/tests/__init__.py
"""
math.tests
"""

from __future__ import division


 *******************************************************************************


 *******************************************************************************
scitbx/math/tests/tst_angle_derivative.py
from __future__ import absolute_import, division, print_function
from scitbx.math import angle_derivative_wrt_vectors
from libtbx.test_utils import approx_equal
from scitbx import matrix
from random import random
from six.moves import range

def finite_difference_approx(u, v):

  delta = 1.e-6
  e1_shift = matrix.col((0.5*delta, 0, 0))
  e2_shift = matrix.col((0, 0.5*delta, 0))
  e3_shift = matrix.col((0, 0, 0.5*delta))

  fd_u1 = ((u + e1_shift).angle(v) - (u - e1_shift).angle(v)) / delta
  fd_u2 = ((u + e2_shift).angle(v) - (u - e2_shift).angle(v)) / delta
  fd_u3 = ((u + e3_shift).angle(v) - (u - e3_shift).angle(v)) / delta

  fd_v1 = ((u).angle(v + e1_shift) - (u).angle(v - e1_shift)) / delta
  fd_v2 = ((u).angle(v + e2_shift) - (u).angle(v - e2_shift)) / delta
  fd_v3 = ((u).angle(v + e3_shift) - (u).angle(v - e3_shift)) / delta

  return ((fd_u1, fd_u2, fd_u3), (fd_v1, fd_v2, fd_v3))

def exercise():

  # find acceptable trial vectors
  while True:
    u = matrix.col.random(3,-1,1)
    v = matrix.col.random(3,-1,1)
    tst = u.accute_angle(v)
    # skip vectors of zero length
    if tst is None: continue
    # skip vectors less than about 1 degrees from collinear
    if tst < 0.017: continue
    # otherwise accept the trial
    break

  dtheta_du, dtheta_dv = angle_derivative_wrt_vectors(u,v)
  fd_dtheta_du, fd_dtheta_dv = finite_difference_approx(u,v)

  try:
    assert approx_equal(dtheta_du, fd_dtheta_du)
    assert approx_equal(dtheta_dv, fd_dtheta_dv)
  except AssertionError:
    print("problem at angle", u.angle(v))

  return


if (__name__ == "__main__"):

  for i in range(10): exercise()
  print("OK")


 *******************************************************************************


 *******************************************************************************
scitbx/math/tests/tst_bessel.py
"""
math.tests.tst_bessel

"""

from __future__ import absolute_import, division, print_function
import scitbx.math
from scitbx.stdlib import math
from scitbx.array_family import flex
from libtbx.test_utils import approx_equal
import sys
from six.moves import range
from six.moves import zip

def exercise_interfaces():
  assert approx_equal(scitbx.math.spherical_bessel(1, 2), 0.43539777498)
  assert approx_equal(scitbx.math.spherical_bessel_array(1, flex.double([2])),
    [0.43539777498])

def j0(x):
  result = math.sin(x)/x
  return result

def j1(x):
  result =  math.sin(x)/(x*x) - math.cos(x)/x
  return result

def j2(x):
  result = (3.0/(x*x) -1.0)*(math.sin(x)/x) - 3.0*math.cos(x)/(x*x)
  return result

def exercise_results():
  x = flex.double( range(1,100) )/99.0
  f0 = scitbx.math.spherical_bessel_array(0,x)
  f1 = scitbx.math.spherical_bessel_array(1,x)
  f2 = scitbx.math.spherical_bessel_array(2,x)
  for xx, ff,fff,ffff in zip(x,f0,f1,f2):
    assert abs(ff-j0(xx))/ff < 1e-5
    assert abs(fff-j1(xx))/fff < 1e-5
    assert abs(ffff-j2(xx))/ffff < 1e-5

def tst_sph_bessel_j1():
  x = flex.double( range(1,200) )/199.0+7.5
  f1 = scitbx.math.spherical_bessel_array(1,x)
  for xx,ff in zip(x,f1):
    assert abs( ff-j1(xx) )/abs(ff) < 1e-5
    #print xx, ff, j1(xx), abs( ff-j1(xx) )/abs(ff)
  print("OK")

def tst_bessel_J():
  x1 = 5.00000000e-02
  f1 = [9.99375098e-01, 2.49921883e-02, 3.12434901e-04]
  g1 = [ scitbx.math.bessel_J(0,x1), scitbx.math.bessel_J(1,x1), scitbx.math.bessel_J(2,x1)]

  x2 = 5.00000000e-01
  f2 = [9.38469807e-01, 2.42268458e-01, 3.06040235e-02]
  g2 = [ scitbx.math.bessel_J(0,x2), scitbx.math.bessel_J(1,x2), scitbx.math.bessel_J(2,x2) ]

  x3 = 5.00000000e+00
  f3 = [-1.77596771e-01, -3.27579138e-01, 4.65651163e-02]
  g3 = [ scitbx.math.bessel_J(0,x3), scitbx.math.bessel_J(1,x3), scitbx.math.bessel_J(2,x3) ]

  for a,b in zip(f1,g1):
    assert (a-b)/abs(a)< 1e-5
  for a,b in zip(f2,g2):
    assert (a-b)/abs(a) < 1e-5
  for a,b in zip(f3,g3):
    assert (a-b)/abs(a) < 1e-5



def exercise():
  if (not hasattr(scitbx.math, "spherical_bessel")):
    print("Skipping tst_bessel.py: functions not available.")
    return
  exercise_interfaces()
  exercise_results()

def run(args):
  assert len(args) == 0
  exercise()
  print("OK")

if (__name__ == "__main__"):
  # XXX Test disabled: "Floating-point error" crash, pending future investigation.
  if 0:
    if 'test_j1' in sys.argv[1:]:
      tst_sph_bessel_j1()
      tst_bessel_J()
      exit()
    run(args=sys.argv[1:])


 *******************************************************************************


 *******************************************************************************
scitbx/math/tests/tst_clustering.py
from __future__ import absolute_import, division, print_function
from scitbx.math import clustering
from scitbx.array_family import flex

def exercise_two_means_clustering():
  data = flex.double((0.21947204867684716, 0.21947204867684716,
                      0.21947204867684716, 0.21947204867684714))
  c = clustering.two_means(data)
  assert c.cut == 4 # precision limit

  data = flex.double((1, 1, 1, 1))
  c = clustering.two_means(data)
  assert c.cut == 4

  data = flex.double((10, 4, 3, 2, 2, 1))
  c = clustering.two_means(data)
  assert c.cut == 1

  data = flex.double((10, 8, 5, 4, 4, 3))
  assert clustering.two_means(data).cut == 2

  data = flex.double((10, 9, 9, 8, 8, 8))
  assert clustering.two_means(data).cut == 3

  data = flex.double((1000, 900, 800, 500, 200, 200, 100))
  assert clustering.two_means(data).cut == 3

  data = flex.double((0.91, 0.29, 0.29, 0.27, 0.27, 0.27, 0.27))
  assert clustering.two_means(data).cut == 1

  data = flex.double((0.998, 0.449, 0.152, 0.152, 0.151))
  clusters = clustering.two_means(data)
  assert clusters.cut == 2

  data = flex.double((0.998, 0.449, 0.152))
  clusters = clustering.two_means(data)
  assert clusters.cut == 1

def exercise_two_medians_clustering():
  data = flex.double((0.998, 0.449, 0.152, 0.152, 0.151))
  clusters = clustering.two_medians(data)
  assert clusters.cut == 2

def run():
  exercise_two_means_clustering()
  exercise_two_medians_clustering()
  print('OK')

if __name__ == '__main__':
  run()


 *******************************************************************************


 *******************************************************************************
scitbx/math/tests/tst_cubic_equation.py
from __future__ import absolute_import, division, print_function
import scitbx.math
from scitbx.array_family import flex
import math, time, random
from libtbx.test_utils import approx_equal
from six.moves import range

random.seed(0)
flex.set_random_seed(0)

def residual(a,b,c,d,x):
  return a*x**3+b*x**2+c*x+d

def abcd(x):
  x1,x2,x3 = x
  a = 1
  b = -x1-x2-x3
  c = x1*x3+x2*x3+x1*x2
  d = -x1*x2*x3
  return a,b,c,d

def sol(x, a,b,c,d, check_roots, eps=1.e-6):
  answer = list(x)
  answer.sort()
  for x in answer:
    assert approx_equal(residual(a=a,b=b,c=c,d=d,x=x), 0.0, eps)
  r = scitbx.math.cubic_equation_real(a=a, b=b, c=c, d=d)
  solution = list(r.x)
  solution.sort()
  for ri in r.residual():
    assert approx_equal(ri, 0.0, eps)
  if(check_roots):
    for i in range(3):
      assert approx_equal(answer[i], solution[i], eps)

def exercise1(n_trials):
  v = 1000
  for i in range(n_trials):
    for scale in [0.0000001, 0.0001, 1.]:
      ri1 = random.randint(-v,v)*scale
      ri2 = random.randint(-v,v)*scale
      ri3 = random.randint(-v,v)*scale
      ri = flex.double([ri1,ri2,ri3])
      x = flex.double(flex.random_double_point_on_sphere())*ri
      a,b,c,d = abcd(x=x)
      #
      sol(x=x, a=a,b=b,c=c,d=d, check_roots=True)
      #
      sol(x=(x[0],x[0],x[0]), a=a,b=b,c=c,d=d, check_roots=False)
      sol(x=(x[1],x[1],x[1]), a=a,b=b,c=c,d=d, check_roots=False)
      sol(x=(x[2],x[2],x[2]), a=a,b=b,c=c,d=d, check_roots=False)
      #
      sol(x=(x[0],x[0],x[2]), a=a,b=b,c=c,d=d, check_roots=False)
      sol(x=(x[0],x[2],x[2]), a=a,b=b,c=c,d=d, check_roots=False)
      sol(x=(x[1],x[0],x[1]), a=a,b=b,c=c,d=d, check_roots=False)
      sol(x=(x[1],x[1],x[2]), a=a,b=b,c=c,d=d, check_roots=False)
      sol(x=(x[2],x[0],x[2]), a=a,b=b,c=c,d=d, check_roots=False)

def exercise2():
  a,b,c,d = 3,-10,14,27
  r = scitbx.math.cubic_equation_real(a=a, b=b, c=c, d=d)
  assert approx_equal(r.x[0],-1)
  assert r.x[1] is None # imaginary roots
  assert r.x[2] is None # imaginary roots
  assert approx_equal(residual(a=a,b=b,c=c,d=d,x=-1), 0)

def exercise3():
  a,b,c,d = 1,-9,27,-27
  r = scitbx.math.cubic_equation_real(a=a, b=b, c=c, d=d)
  assert approx_equal(r.x[0], 3)
  assert approx_equal(r.x[1], 3)
  assert approx_equal(r.x[2], 3)
  assert approx_equal(residual(a=a,b=b,c=c,d=d,x=3), 0)

def exercise4():
  a,b,c,d = 1,-11,39,-45
  r = scitbx.math.cubic_equation_real(a=a, b=b, c=c, d=d)
  assert approx_equal(r.x[0], 5)
  assert approx_equal(r.x[1], 3)
  assert approx_equal(r.x[2], 3)
  assert approx_equal(residual(a=a,b=b,c=c,d=d,x=3), 0)
  assert approx_equal(residual(a=a,b=b,c=c,d=d,x=5), 0)

def exercise5(n_trials):
  def check():
    a,b,c,d = abcd(x = [x1,x2,x3])
    answer = [x1,x2,x3]
    answer.sort()
    answer = flex.double(answer)
    r = scitbx.math.cubic_equation_real(a=a, b=b, c=c, d=d)
    for ri in r.residual():
      assert approx_equal(ri, 0.0)
    solution = list(r.x)
    solution.sort()
    solution = flex.double(solution)
    diff = flex.abs(solution-answer)
    assert approx_equal(diff, [0,0,0])
    for x in [x1,x2,x3, r.x[0],r.x[1],r.x[2]]:
      assert approx_equal(residual(a=a,b=b,c=c,d=d,x=x), 0)
  for x1,x2,x3 in flex.nested_loop([-2]*3, [2]*3, open_range=False):
    check()
  for i in range(n_trials):
    x1 = random.randint(-10,10)
    x2 = random.randint(-10,10)
    x3 = random.randint(-10,10)
    check()

def run(args):
  assert len(args) == 0
  n_trials = 100
  t0 = time.time()
  for i in range(1):
    exercise1(n_trials)
    exercise2()
    exercise3()
    exercise4()
    exercise5(n_trials)
  from libtbx.utils import format_cpu_times
  print(format_cpu_times())

if (__name__ == "__main__"):
  import sys
  run(args=sys.argv[1:])


 *******************************************************************************


 *******************************************************************************
scitbx/math/tests/tst_curve_fitting.py
from __future__ import absolute_import, division, print_function
import random

import libtbx.load_env
from libtbx.test_utils import approx_equal
from libtbx.utils import frange
from scitbx.array_family import flex
from scitbx.math import curve_fitting
import scitbx.lbfgs
from six.moves import range
from six.moves import zip

if (1): # fixed random seed to avoid rare failures
  random.seed(0)
  flex.set_random_seed(0)

def finite_differences(functor, x):
  return [flex.double(g) for g in functor.finite_differences(x)]

def exercise_polynomial_fit():

  def do_polynomial_fit(x, params):
    n_terms = len(params)
    y = flex.double(x.size())
    for i in range(len(params)):
      y += params[i] * flex.pow(x, i)
    fit = curve_fitting.univariate_polynomial_fit(x, y, degree=n_terms-1)
    assert approx_equal(params, fit.params, eps=1e-4)

  x = flex.double(range(-50,50))
  do_polynomial_fit(x, (2,3,5)) # y = 2 + 3x + 5x^2
  do_polynomial_fit(x, (-0.0002, -1000)) # y = -0.0002 -1000x

  for n_terms in range(1, 6):
    params = [100*random.random() for i in range(n_terms)]
    x = flex.double(frange(-random.randint(1,10), random.randint(1,10), 0.1))
    functor = curve_fitting.univariate_polynomial(*params)
    fd_grads = finite_differences(functor, x)
    assert approx_equal(functor.partial_derivatives(x), fd_grads, 1e-4)
    do_polynomial_fit(x, params)

def exercise_gaussian_fit():

  # test fitting of a gaussian
  def do_gaussian_fit(scale, mu, sigma):
    start = mu - 6 * sigma
    stop = mu + 6 * sigma
    step = (stop - start)/1000
    x = flex.double(frange(start, stop, step))
    y = scale * flex.exp(-flex.pow2(x - mu) / (2 * sigma**2))
    fit = curve_fitting.single_gaussian_fit(x, y)
    assert approx_equal(fit.a, scale, 1e-4)
    assert approx_equal(fit.b, mu, eps=1e-4)
    assert approx_equal(fit.c, sigma, eps=1e-4)

  for i in range(10):
    scale = random.random() * 1000
    sigma = (random.random() + 0.0001) * 10
    mu = (-1)**random.randint(0,1) * random.random() * 1000
    functor = curve_fitting.gaussian(scale, mu, sigma)
    start = mu - 6 * sigma
    stop = mu + 6 * sigma
    step = (stop - start)/1000
    x = flex.double(frange(start, stop, step))
    fd_grads = finite_differences(functor, x)
    assert approx_equal(functor.partial_derivatives(x), fd_grads, 1e-4)
    do_gaussian_fit(scale, mu, sigma)

  # if we take the log of a gaussian we can fit a parabola
  scale = 123
  mu = 3.2
  sigma = 0.1
  x = flex.double(frange(2, 4, 0.01))
  y = scale * flex.exp(-flex.pow2(x - mu) / (2 * sigma**2))
  # need to be careful to only use values of y > 0
  eps = 1e-15
  x = flex.double([x[i] for i in range(x.size()) if y[i] > eps])
  y = flex.double([y[i] for i in range(y.size()) if y[i] > eps])
  fit = curve_fitting.univariate_polynomial_fit(x, flex.log(y), degree=2)
  c, b, a = fit.params
  assert approx_equal(mu, -b/(2*a))
  assert approx_equal(sigma*sigma, -1/(2*a))

  # test multiple gaussian fits
  gaussians = [curve_fitting.gaussian(0.3989538, 3.7499764, 0.7500268),
               curve_fitting.gaussian(0.7978957, 6.0000004, 0.5000078)]
  x = flex.double(frange(0, 10, 0.1))
  y = flex.double(x.size())
  for i in range(len(gaussians)):
    g = gaussians[i]
    scale, mu, sigma = g.a, g.b, g.c
    y += g(x)

  starting_gaussians = [
    curve_fitting.gaussian(1, 4, 1),
    curve_fitting.gaussian(1, 5, 1)]
  fit = curve_fitting.gaussian_fit(x, y, starting_gaussians)
  for g1, g2 in zip(gaussians, fit.gaussians):
    assert approx_equal(g1.a, g2.a, eps=1e-4)
    assert approx_equal(g1.b, g2.b, eps=1e-4)
    assert approx_equal(g1.c, g2.c, eps=1e-4)

  # use example of 5-gaussian fit from here:
  # http://research.stowers-institute.org/efg/R/Statistics/MixturesOfDistributions/index.htm
  gaussians = [curve_fitting.gaussian(0.10516252, 23.32727, 2.436638),
               curve_fitting.gaussian(0.46462715, 33.09053, 2.997594),
               curve_fitting.gaussian(0.29827916, 41.27244, 4.274585),
               curve_fitting.gaussian(0.08986616, 51.24468, 5.077521),
               curve_fitting.gaussian(0.04206501, 61.31818, 7.070303)]

  x = flex.double(frange(0, 80, 0.1))
  y = flex.double(x.size())
  for i in range(len(gaussians)):
    g = gaussians[i]
    scale, mu, sigma = g.a, g.b, g.c
    y += g(x)

  termination_params = scitbx.lbfgs.termination_parameters(
    min_iterations=500)
  starting_gaussians = [curve_fitting.gaussian(1, 21, 2.1),
                        curve_fitting.gaussian(1, 30, 2.8),
                        curve_fitting.gaussian(1, 40, 2.2),
                        curve_fitting.gaussian(1, 51, 1.2),
                        curve_fitting.gaussian(1, 60, 2.3)]
  fit = curve_fitting.gaussian_fit(
    x, y, starting_gaussians, termination_params=termination_params)
  y_calc = fit.compute_y_calc()
  assert approx_equal(y, y_calc, eps=1e-2)

  have_cma_es = libtbx.env.has_module("cma_es")
  if have_cma_es:
    fit = curve_fitting.cma_es_minimiser(starting_gaussians, x, y)
    y_calc = fit.compute_y_calc()
    assert approx_equal(y, y_calc, eps=5e-2)


def exercise_skew_normal_fit():
  shape, location, scale = 8.0, 4.0, 2.0
  x_obs = flex.double(frange(0, 10, 0.1))
  f = curve_fitting.skew_normal(shape, location, scale)
  y_obs = f(x_obs)

  if 0:
    from matplotlib import pyplot
    pyplot.plot(x_obs, y_obs)
    pyplot.show()

  fd_grads = finite_differences(f, x_obs)
  ana_grads = f.partial_derivatives(x_obs)
  assert approx_equal(ana_grads, fd_grads, 1e-4)
  shape, location, scale = 1, 0, 8
  starting_f = curve_fitting.skew_normal(shape, location, scale)
  termination_params = scitbx.lbfgs.termination_parameters(
    min_iterations=100)
  fit = curve_fitting.generic_minimiser(
    [starting_f], x_obs, y_obs, termination_params=termination_params)
  assert approx_equal(fit.functions[0].params, f.params)

def exercise_tanh_fit():
  # Curve fitting as used by Aimless for fitting CC1/2 plot:

  #   Curve fitting as suggested by Ed Pozharski to a tanh function
  #   of the form (1/2)(1 - tanh(z)) where z = (s - d0)/r,
  #   s = 1/d^2, d0 is the value of s at the half-falloff value, and r controls
  #   the steepness of falloff

  d = flex.double(
    [2.71, 2.15, 1.88, 1.71, 1.59, 1.49, 1.42, 1.36, 1.31, 1.26])
  x_obs = 1/d**2
  y_obs = flex.double(
    [0.999, 0.996, 0.993, 0.984, 0.972, 0.948, 0.910, 0.833, 0.732, 0.685])
  fit = curve_fitting.tanh_fit(x_obs, y_obs, r=1, s0=1)

  r, s0 = fit.params
  f = curve_fitting.tanh(r, s0)
  y_calc = flex.double(f(x_obs))

  residual = flex.sum(flex.pow2(y_obs-y_calc))
  assert approx_equal(residual, 0.0023272873437026106)
  assert approx_equal(fit.params, (0.17930695756689238, 0.6901032957705017))

def run():
  exercise_tanh_fit()
  exercise_skew_normal_fit()
  exercise_polynomial_fit()
  exercise_gaussian_fit()

if (__name__ == "__main__"):
  run()
  print("OK")


 *******************************************************************************


 *******************************************************************************
scitbx/math/tests/tst_dmatrix.py
from __future__ import absolute_import, division, print_function
from scitbx.math import dmatrix
from scitbx.stdlib import math
from six.moves import range

def tst_dmatrix():
  # expected values are the d_jmn at beta=1.0 and j=2, m=-2, -2<=n<=2
  expect = [0.593133, 0.64806, 0.433605, 0.193411, 0.0528305]
  eps = 1e-4
  d2 = dmatrix( 2, 1.0)  # dmatrix( max_L, beta )
  for n in range(-2, 3):
    assert abs(expect[n+2] - d2.djmn(2, -2, n) ) < eps

  d4 = dmatrix( 4, 1.0)
  for n in range(-2, 3):
    assert abs(expect[n+2] - d4.djmn(2, -2, n) ) < eps

  d7 = dmatrix( 2, 1.0)
  for n in range(-2, 3):
    assert abs(expect[n+2] - d7.djmn(2, -2, n) ) < eps

  # check agains d(2,2,1) = -(1+cos(beta))*sin(beta)/2.0
  for ii in range(10):
    expt = -(1.0+math.cos(ii))*math.sin(ii)/2.0
    assert abs( dmatrix(2,ii).djmn(2,2,1) - expt ) < eps
  # check beta= multiple of pi/2

  assert abs( dmatrix( 20, math.pi ).djmn(2,2,0) )< eps
  assert abs( dmatrix( 2, math.pi*2 ).djmn(2,2,0) )< eps
  assert abs( dmatrix( 20, math.pi*0.5 ).djmn(2,2,0)-math.sqrt(6.0)/4.0 )< eps


if __name__ == "__main__":
  tst_dmatrix()
  print("OK")


 *******************************************************************************


 *******************************************************************************
scitbx/math/tests/tst_error_propagation_matrix_inverse.py
#!/usr/bin/env python
#
#  Copyright (C) (2016) STFC Rutherford Appleton Laboratory, UK.
#
#  Author: David Waterman.
#
#  This code is distributed under the BSD license, a copy of which is
#  included in the root directory of this package.

from __future__ import absolute_import, division, print_function
from scitbx import matrix
from scitbx.array_family import flex
import random
from scitbx.math.lefebvre import matrix_inverse_error_propagation
from six.moves import range
from six.moves import map

"""Implementation of the propagation of errors formula for matrix inversion
given in Lefebvre et al. (1999) http://arxiv.org/abs/hep-ex/9909031. As in
that paper the analytical formula is tested against Monte Carlo simulation."""

def random_vector_close_to(vector):
  vec = matrix.col(vector)
  vec2 = vec.rotate_around_origin(matrix.col(
              (random.random(),
               random.random(),
               random.random())).normalize(),
               random.gauss(0, 5), deg = True)
  length_multiplier = max(0.5, random.gauss(1, 0.1))
  return vec2 * length_multiplier

def create_Bmat():
  """Create a random crystal model, in P1 for maximum generality. Return the
  B matrix of this crystal"""

  from dxtbx.model import Crystal

  vecs = list(map(random_vector_close_to,
             [(20, 0, 0),
              (0, 20, 0),
              (0, 0, 20)]))

  return matrix.sqr(Crystal(*vecs, space_group_symbol = "P 1").get_B())

def create_sig_mat(mat, fraction_sd=0.01):
  """Create a matrix of errors of the elements of mat, where each error is a
  normal deviate with a sigma some fraction of the absolute element value"""

  vals = [random.gauss(0.0, abs(fraction_sd*e)) for e in mat]
  return matrix.sqr(vals)

def perturb_mat(mat, fraction_sd=0.01):
  """Perturb the elements of mat by normal deviates with sigmas of some
  fraction of the absolute element values."""

  return mat + create_sig_mat(mat, fraction_sd)

def cov(a, b):
  """Return the sample covariance of vectors a and b"""
  a = flex.double(a)
  b = flex.double(b)
  n = len(a)
  assert n == len(b)
  resid_a = a - flex.mean(a)
  resid_b = b - flex.mean(b)
  return flex.sum(resid_a*resid_b) / (n - 1)

def calc_monte_carlo_covariances(mats):
  """Given the sequence of matrices mats, calculate the variance-covariance
  matrix of the elements"""

  # check input
  assert all([e.is_square() for e in mats])
  n = mats[0].n_rows()
  assert all([e.n_rows() == n for e in mats])

  # create an empty var-cov matrix
  covmat = flex.double(flex.grid(n**2,n**2), 0.0)

  for i in range(covmat.all()[0]):
    for j in range(covmat.all()[1]):
      a = [m[i] for m in mats]
      b = [m[j] for m in mats]
      covmat[i,j] = cov(a,b)

  return covmat

def calc_monte_carlo_population_covariances(mats, mean_matrix):
  """Given the sequence of matrices mats, calculate the variance-covariance
  matrix of the elements, using the known mean values for each elt in mat
  to avoid the approximation implied in taking the sample covariance"""

  # check input
  assert all([e.is_square() for e in mats])
  n = mats[0].n_rows()
  assert all([e.n_rows() == n for e in mats])

  # create an empty var-cov matrix
  covmat = flex.double(flex.grid(n**2,n**2), 0.0)

  for i in range(covmat.all()[0]):
    for j in range(covmat.all()[1]):
      resid_a = flex.double([m[i] - mean_matrix[i] for m in mats])
      resid_b = flex.double([m[j] - mean_matrix[j] for m in mats])
      covmat[i,j] = flex.mean(resid_a*resid_b)

  return covmat

def test_lefebvre():
  """Run the test presented in part 4 of the paper Lefebvre et al. (1999),
  http://arxiv.org/abs/hep-ex/9909031."""

  # Simple test following the paper. First MC sim
  mat = matrix.sqr((0.7,0.2,0.4,0.6))
  sig_mat = mat*0.01
  p_mats = [perturb_mat(mat) for i in range(10000)]
  inv_p_mats = [m.inverse() for m in p_mats]

  # Here use the more exact formula for population covariance as we know the
  # true means rather than sample covariance where we calculate the means
  # from the data
  cov_inv_mat_MC = calc_monte_carlo_population_covariances(inv_p_mats,
    mean_matrix=mat.inverse())

  # Now analytical formula
  cov_mat = matrix.diag([e**2 for e in sig_mat])

  cov_inv_mat = matrix_inverse_error_propagation(mat, cov_mat)
  cov_inv_mat = cov_inv_mat.as_flex_double_matrix()

  # Get fractional differences
  frac = (cov_inv_mat_MC - cov_inv_mat) / cov_inv_mat_MC

  # assert all fractional errors are within 5%. When the random seed is allowed
  # to vary this fails about 7 times in every 100 runs. This is mainly due to
  # the random variation in the MC method itself, as with just 10000 samples
  # one MC estimate compared to another MC estimate regularly has some
  # fractional errors greater than 5%.
  assert all([abs(e) < 0.05 for e in frac])

  return

def test_B_matrix():
  """Test errors in an inverted B matrix, when the errors in B are known (and
  are independent)"""

  Bmat = create_Bmat()
  inv_Bmat = Bmat.inverse()

  # Note that elements in the strict upper triangle of B are zero
  # so their perturbed values will be zero too and the errors in these elements
  # will also be zero (this is what we want)

  # calculate the covariance of elements of inv_B by Monte Carlo simulation,
  # assuming that each element of B has an independent normal error given by a
  # sigma of 1% of the element value
  perturbed_Bmats = [perturb_mat(Bmat, fraction_sd=0.01) for i in range(10000)]
  invBs = [m.inverse() for m in perturbed_Bmats]
  cov_invB_MC = calc_monte_carlo_population_covariances(invBs, inv_Bmat)

  # Now calculate using the analytical formula. First need the covariance
  # matrix of B itself. This is the diagonal matrix of errors applied in the
  # simulation.
  n = Bmat.n_rows()
  sig_B = Bmat * 0.01
  cov_B = matrix.diag([e**2 for e in sig_B])

  # Now can use the analytical formula
  cov_invB = matrix_inverse_error_propagation(Bmat, cov_B)
  cov_invB = cov_invB.as_flex_double_matrix()

  # Get fractional differences
  frac = flex.double(flex.grid(n**2, n**2), 0.0)
  for i in range(frac.all()[0]):
    for j in range(frac.all()[1]):
      e1 = cov_invB_MC[i,j]
      e2 = cov_invB[i,j]
      if e1 < 1e-10: continue # avoid divide-by-zero errors below
      if e2 < 1e-10: continue # avoid elements that are supposed to be zero
      frac[i,j] = (e1 - e2) / e1

  # assert all fractional errors are within 5%
  assert all([abs(e) < 0.05 for e in frac])

  return

if __name__ == '__main__':

  # set random seet to avoid rare test failures
  random.seed(42)

  # run the Lefebvre paper test
  test_lefebvre()
  print("OK")

  # run a similar test for a B matrix
  try:
    import dxtbx # import dependency
  except ImportError:
    pass
  else:
    test_B_matrix()
    print("OK")


 *******************************************************************************


 *******************************************************************************
scitbx/math/tests/tst_euler_angles.py
from __future__ import absolute_import, division, print_function
from scitbx.math import euler_angles as euler
from libtbx.test_utils import approx_equal
from libtbx.utils import format_cpu_times
import random
from six.moves import range

def exercise_core(angles_in):
  for euler_matrix, euler_angles in [
        (euler.xyz_matrix, euler.xyz_angles),
        (euler.yzx_matrix, euler.yzx_angles),
        (euler.zyz_matrix, euler.zyz_angles)]:
    m = euler_matrix(*angles_in)
    angles_out = euler_angles(m)
    m2 = euler_matrix(*angles_out)
    assert approx_equal(m2, m)

def exercise():
  random.seed(0)
  for a1_in in range(0, 400, 15):
    for a2_in in range(0, 400, 15):
      for a3_in in range(0, 400, 15):
        exercise_core((a1_in, a2_in, a3_in))
  for i_trial in range(1000):
    exercise_core([random.random()*360-180 for i in [0,1,2]])
  print(format_cpu_times())

if (__name__ == "__main__"):
  exercise()


 *******************************************************************************


 *******************************************************************************
scitbx/math/tests/tst_exp_functions.py
from __future__ import absolute_import, division, print_function
import scitbx.math
from scitbx.array_family import flex
from libtbx.test_utils import Exception_expected, approx_equal
from libtbx.utils import format_cpu_times
import time
import sys
from six.moves import range

def exercise_with_random_arguments(n_arguments, n_iterations):
  mt = flex.mersenne_twister(seed=0)
  d = mt.random_double(size=n_arguments)*100-50
  f = d.as_float()
  print("showing wall clock times!")
  t0 = time.time()
  for i_iteration in range(n_iterations):
    jef = scitbx.math.jacks_expf(array_of_float=f)
  print("jacks_expf(): %.2f s" % (time.time()-t0))
  for i_iteration in range(n_iterations):
    sef = flex.exp(f)
  print("std::exp(float): %.2f s" % (time.time()-t0))
  t0 = time.time()
  for i_iteration in range(n_iterations):
    sed = flex.exp(d)
  print("std::exp(double): %.2f s" % (time.time()-t0))
  assert sed.all_gt(0)
  for ef in [jef, sef]:
    max_rel_err = flex.max(flex.abs((ef.as_double() - sed) / sed))
    assert approx_equal(max_rel_err, 0, eps=1e-5)

def run(args):
  assert args in [[], ["--comprehensive"]]
  if (len(args) == 0):
    comprehensive = False
  else:
    comprehensive = True
  if (not comprehensive):
    n_arguments = 100000
    n_iterations = 10
    exponents = [-127, -1, 0, 1, 5, 6]
    mantissa_step_size = 100000
    j_sample = 300000
  else:
    n_arguments = 300000
    n_iterations = 20
    exponents = range(-127, 7)
    mantissa_step_size = 1
    j_sample = 300000
  exercise_with_random_arguments(
    n_arguments=n_arguments,
    n_iterations=n_iterations)
  for negative_sign in [False, True]:
    for exponent in exponents:
      if (comprehensive): print(exponent)
      try:
        r = scitbx.math.exercise_jacks_expf(
          negative_sign=negative_sign,
          exponent=exponent,
          mantissa_step_size=mantissa_step_size,
          j_sample=j_sample)
        if (comprehensive): print(list(r))
      except RuntimeError as e:
        assert str(e) == "jacks_expf(): function argument out of range."
        assert not negative_sign
        break
    else:
      if (not negative_sign):
        raise Exception_expected
  #
  print(format_cpu_times())

if (__name__ == "__main__"):
  run(args=sys.argv[1:])


 *******************************************************************************


 *******************************************************************************
scitbx/math/tests/tst_fit_peak.py
from __future__ import absolute_import, division, print_function
from scitbx.array_family import flex
from scitbx.math import fit_peak
from libtbx.test_utils import approx_equal
from six.moves import range

# =============================================================================
def test_pick_map_neighbors():

  # generate test map
  d = 3
  gridding = flex.grid(d,d,d)
  test_map = flex.double(gridding)
  count = 1
  for i in range(d):
    for j in range(d):
      for k in range(d):
        test_map[(i,j,k)] = count
        count = count + 1

  # order neighbors
  fitted = fit_peak.pick_map_neighbors(site=(1,1,1),map_in=test_map)
  height_list,xyz_list = fitted.get_26_nearest_neighbors()

  # check output
  height_list_correct = [14.0,23.0,5.0,17.0,11.0,15.0,13.0,18.0,4.0,20.0,12.0,
                         22.0,2.0,16.0,6.0,26.0,10.0,24.0,8.0,27.0,9.0,21.0,
                         25.0,3.0,7.0,19.0,1.0]
  xyz_list_correct = [(1.0/3.0,1.0/3.0,1.0/3.0),(2.0/3.0,1.0/3.0,1.0/3.0),
                      (0.0,1.0/3.0,1.0/3.0),(1.0/3.0,2.0/3.0,1.0/3.0),
                      (1.0/3.0,0.0,1.0/3.0),(1.0/3.0,1.0/3.0,2.0/3.0),
                      (1.0/3.0,1.0/3.0,0.0),(1.0/3.0,2.0/3.0,2.0/3.0),
                      (0.0,1.0/3.0,0.0),(2.0/3.0,0.0,1.0/3.0),
                      (1.0/3.0,0.0,2.0/3.0),(2.0/3.0,1.0/3.0,0.0),
                      (0.0,0.0,1.0/3.0),(1.0/3.0,2.0/3.0,0.0),
                      (0.0,1.0/3.0,2.0/3.0),(2.0/3.0,2.0/3.0,1.0/3.0),
                      (1.0/3.0,0.0,0.0),(2.0/3.0,1.0/3.0,2.0/3.0),
                      (0.0,2.0/3.0,1.0/3.0),(2.0/3.0,2.0/3.0,2.0/3.0),
                      (0.0,2.0/3.0,2.0/3.0),(2.0/3.0,0.0,2.0/3.0),
                      (2.0/3.0,2.0/3.0,0.0),(0.0,0.0,2.0/3.0),
                      (0.0,2.0/3.0,0.0),(2.0/3.0,0.0,0.0),(0.0,0.0,0.0)]
  for i in range(27):
    assert(height_list[i] == height_list_correct[i])
    assert(xyz_list[i] == xyz_list_correct[i])

# =============================================================================
def test_fit_3d_parabola():

  # generate test map
  d = 10
  gridding = flex.grid(d,d,d)
  test_map = flex.double(gridding)
  parameters = (1.5,1.5,1.5,-2.0,-2.0,-2.0,24.0)
  p = fit_peak.parabola(parameters=parameters)
  for i in range(d):
    for j in range(d):
      for k in range(d):
        test_map[(i,j,k)] = p.get_height(r=(float(i)/d,float(j)/d,float(k)/d))

  # check fitting
  neighbors = fit_peak.pick_map_neighbors(site=(6,6,6),map_in=test_map)
  height_list,xyz_list = neighbors.get_26_nearest_neighbors()
  fp = fit_peak.fit_peak(height_list=height_list,xyz_list=xyz_list,
                         shape="parabola")
  assert approx_equal(fp.x, parameters)
  assert approx_equal(fp.vertex, p.vertex)

# =============================================================================
def test_fit_3d_quadratic():

  # generate test map
  d = 10
  gridding = flex.grid(d,d,d)
  test_map = flex.double(gridding)
  parameters = (1.5,1.5,1.5,-2.0,-2.0,-2.0,1.25,1.25,1.25,24.0)
  p = fit_peak.quadratic(parameters=parameters)
  for i in range(d):
    for j in range(d):
      for k in range(d):
        test_map[(i,j,k)] = p.get_height(r=(float(i)/d,float(j)/d,float(k)/d))

  # check fitting
  neighbors = fit_peak.pick_map_neighbors(site=(4,4,4),map_in=test_map)
  height_list,xyz_list = neighbors.get_26_nearest_neighbors()
  fp = fit_peak.fit_peak(height_list=height_list,xyz_list=xyz_list,
                         shape="quadratic")
  assert approx_equal(fp.x, parameters)
  assert approx_equal(fp.vertex, p.vertex)

# =============================================================================
def test_fit_3d_gaussian():

  # generate test map
  d = 10
  gridding = flex.grid(d,d,d)
  test_map = flex.double(gridding)
  parameters = (1.5,1.5,1.5,-2.0,-2.0,-2.0,1.25,1.25,1.25,24.0)
  p = fit_peak.gaussian(parameters=parameters)
  for i in range(d):
    for j in range(d):
      for k in range(d):
        test_map[(i,j,k)] = p.get_height(r=(float(i)/d,float(j)/d,float(k)/d))

  # check fitting
  neighbors = fit_peak.pick_map_neighbors(site=(4,4,4),map_in=test_map)
  height_list,xyz_list = neighbors.get_26_nearest_neighbors()
  fp = fit_peak.fit_peak(height_list=height_list,xyz_list=xyz_list,
                         shape="gaussian")
  assert approx_equal(fp.x, parameters)
  assert approx_equal(fp.vertex, p.vertex)

# =============================================================================
if (__name__ == "__main__"):
  test_pick_map_neighbors()
  test_fit_3d_parabola()
  test_fit_3d_quadratic()
  test_fit_3d_gaussian()
  print("OK")


 *******************************************************************************


 *******************************************************************************
scitbx/math/tests/tst_fit_quadratic_function.py
from __future__ import absolute_import, division, print_function
from scitbx.math import fit_quadratic_function as fqf
from libtbx.test_utils import approx_equal
from six.moves import range

def test_fit():
  x1_obs=[]
  x2_obs=[]
  x1m=1.0
  x2m=3.0
  a=1
  b=2
  c=-0.5
  y_obs=[]

  for ii in range(10):
    for jj in range(10):
      x1_obs.append(ii-5)
      x2_obs.append(jj-5)
      y_obs.append(
        a*(( (ii-5.0)-x1m )**2.0) +
        b*(( (jj-5.0)-x2m )**2.0) +
        2.0*c*( (ii-5.0)-x1m )*( (jj-5.0)-x2m )
        )

  fit =fqf.fit_quadratic_function_2d_data( x1_obs, x2_obs, y_obs  )
  assert approx_equal( fit.x1m, x1m, eps=1e-5)
  assert approx_equal( fit.x2m, x2m, eps=1e-5)
  assert approx_equal( fit.a, a, eps=1e-5)
  assert approx_equal( fit.b, b, eps=1e-5)
  assert approx_equal( fit.c, c, eps=1e-5)
  print('OK')

if (__name__ == "__main__"):
  test_fit()


 *******************************************************************************


 *******************************************************************************
scitbx/math/tests/tst_g_function.py
from __future__ import absolute_import, division, print_function
from scitbx import math as m
from libtbx.test_utils import approx_equal
import math

def G(x):
  if(x != 0):
    return 3*(math.sin(x)-x*math.cos(x))/x**3
  else:
    return 1

def exercise():
  x = 0
  while x < 4.45: #undefined for larger arguments
    gf = m.GfuncOfRSsqr_approx((x/(2.*math.pi))**2)
    assert approx_equal(gf, G(x))
    x += 0.01

if (__name__ == "__main__"):
  exercise()


 *******************************************************************************


 *******************************************************************************
scitbx/math/tests/tst_gaussian.py
from __future__ import absolute_import, division, print_function
from scitbx.examples import immoptibox_ports
from scitbx.math import gaussian
from scitbx.array_family import flex
from libtbx.test_utils import approx_equal, eps_eq
from libtbx.utils import format_cpu_times
from six.moves import range
try:
  from six.moves import cPickle as pickle
except ImportError:
  import pickle
from six.moves import cStringIO as StringIO
import math
import sys

def finite_gradient_dx_at_x(gaussian, x, eps=1.e-5):
  if (x == 0): return 0
  assert x >= eps
  tm = gaussian.at_x(x-eps)
  tp = gaussian.at_x(x+eps)
  return (tp-tm)/(2*eps)

def exercise_gradient_dx(gaussian, x_max=1., n_points=50):
  for i in range(n_points+1):
    x = x_max * i / n_points
    grad_finite = finite_gradient_dx_at_x(gaussian, x)
    grad_analytical = gaussian.gradient_dx_at_x(x)
    assert eps_eq(grad_finite, grad_analytical)

def exercise_integral_dx(gaussian, x_max=1., n_points=1000):
  numerical_integral = 0
  x_step = x_max / n_points
  for i in range(n_points+1):
    x = x_max * i / n_points
    new_value = gaussian.at_x(x)
    if (i):
      numerical_integral += (prev_value + new_value) * .5
    prev_value = new_value
    analytical_integral = gaussian.integral_dx_at_x(x, 1.e-3)
    assert eps_eq(analytical_integral, gaussian.integral_dx_at_x(x))
    assert eps_eq(numerical_integral*x_step, analytical_integral, eps=1.e-5)

def term_finite_gradient_d_ab_at_x(term, x, eps=1.e-5):
  tm = gaussian.term(term.a-eps,term.b).at_x(x)
  tp = gaussian.term(term.a+eps,term.b).at_x(x)
  gr_a = (tp-tm)/(2*eps)
  tm = gaussian.term(term.a,term.b-eps).at_x(x)
  tp = gaussian.term(term.a,term.b+eps).at_x(x)
  gr_b = (tp-tm)/(2*eps)
  return gaussian.term(gr_a, gr_b)

def exercise_term_gradients_d_ab(term, x_max=1., n_points=50):
  for i in range(n_points+1):
    x = x_max * i / n_points
    grad_finite = term_finite_gradient_d_ab_at_x(term, x)
    grad_analytical = term.gradients_d_ab_at_x_sq(x*x)
    assert eps_eq(grad_finite.a, grad_analytical.a)
    assert eps_eq(grad_finite.b, grad_analytical.b)

def exercise_term():
  t = gaussian.term(2,3)
  assert approx_equal(t.a, 2)
  assert approx_equal(t.b, 3)
  assert approx_equal(t.at_x_sq(4), 2*math.exp(-3*4))
  assert approx_equal(t.at_x(2), 2*math.exp(-3*4))
  eps = 1.e-5
  for ix in (range(10)):
    x = ix/10.
    assert eps_eq((t.at_x(x+eps)-t.at_x(x-eps))/(2*eps), t.gradient_dx_at_x(x))
  for f in [1,-1]:
    for t in [gaussian.term(f*2,3),
              gaussian.term(f*3,0),
              gaussian.term(f*4,1.e-4),
              gaussian.term(f*5,-1)]:
      exercise_gradient_dx(t)
      exercise_integral_dx(t)
      exercise_term_gradients_d_ab(t)

def exercise_sum():
  g = gaussian.sum(0)
  assert g.n_terms() == 0
  assert g.array_of_a() == ()
  assert g.array_of_b() == ()
  assert approx_equal(g.c(), 0)
  assert g.use_c()
  assert g.n_parameters() == 1
  assert approx_equal(g.parameters(), [0])
  g = gaussian.sum(0, True)
  assert g.use_c()
  g = gaussian.sum(0, False)
  assert not g.use_c()
  g = gaussian.sum(1)
  assert g.n_terms() == 0
  assert g.array_of_a() == ()
  assert g.array_of_b() == ()
  assert approx_equal(g.c(), 1)
  assert g.use_c()
  assert g.n_parameters() == 1
  assert approx_equal(g.parameters(), [1])
  g = gaussian.sum((), ())
  assert g.n_terms() == 0
  assert g.array_of_a() == ()
  assert g.array_of_b() == ()
  assert g.c() == 0
  assert not g.use_c()
  assert g.n_parameters() == 0
  assert g.parameters().size() == 0
  g = gaussian.sum((), (), -2)
  assert g.n_terms() == 0
  assert g.array_of_a() == ()
  assert g.array_of_b() == ()
  assert approx_equal(g.c(), -2)
  g = gaussian.sum(flex.double((1,2,3,4)))
  assert approx_equal(g.array_of_a(), (1,3))
  assert approx_equal(g.array_of_b(), (2,4))
  assert approx_equal(g.c(), 0)
  assert not g.use_c()
  assert approx_equal(g.parameters(), [1,2,3,4])
  g = gaussian.sum(flex.double((1,2,3,4)), 0, True)
  assert approx_equal(g.c(), 0)
  assert g.use_c()
  g = gaussian.sum(flex.double((1,2,3,4)), 5)
  assert approx_equal(g.c(), 5)
  assert g.use_c()
  assert approx_equal(g.parameters(), [1,2,3,4,5])
  g = gaussian.sum(flex.double((1,2,3,4,5)))
  assert approx_equal(g.c(), 5)
  assert g.use_c()
  assert approx_equal(g.parameters(), [1,2,3,4,5])
  g = gaussian.sum((1,-2,3,-4,5), (-.1,.2,-.3,.4,-.5), 6)
  assert g.n_terms() == 5
  assert approx_equal(g.array_of_a(),(1,-2,3,-4,5))
  assert approx_equal(g.array_of_b(),(-.1,.2,-.3,.4,-.5))
  assert approx_equal(g.c(), 6)
  assert approx_equal(g.at_x_sq(3/4.), 13.4251206)
  assert approx_equal(g.at_x_sq(flex.double([2/4.,3/4.])),
    [11.8723031, 13.4251206])
  assert approx_equal(g.at_x(math.sqrt(3/4.)), 13.4251206)
  assert approx_equal(g.at_x(flex.sqrt(flex.double([2/4.,3/4.]))),
    [11.8723031, 13.4251206])
  s = pickle.dumps(g)
  l = pickle.loads(s)
  assert l.n_terms() == g.n_terms()
  assert approx_equal(l.array_of_a(), g.array_of_a())
  assert approx_equal(l.array_of_b(), g.array_of_b())
  assert approx_equal(l.c(), g.c())
  assert l.use_c()
  s = pickle.dumps(gaussian.sum((),()))
  l = pickle.loads(s)
  assert not l.use_c()
  exercise_gradient_dx(gaussian.sum(
    [5.5480], [10.4241], 0))
  exercise_gradient_dx(gaussian.sum(
   [2.657506,1.078079,1.490909,-4.241070,0.713791],
   [14.780758,0.776775,42.086842,-0.000294,0.239535],
   4.297983))
  exercise_integral_dx(gaussian.sum([5.5480], [10.4241]))
  exercise_integral_dx(gaussian.sum([5.5480], [10.4241], 3))
  exercise_integral_dx(gaussian.sum([5.5480], [0], 0))
  exercise_integral_dx(gaussian.sum([5.5480], [-0.01]))
  exercise_integral_dx(gaussian.sum(
    [2.657506,1.078079,1.490909,-4.241070,0.713791],
    [14.780758,0.776775,42.086842,-0.000294,0.239535],
    4.297983))
  g = gaussian.sum((1,-2,3,-4,5), (-.1,.2,-.3,.4,-.5), 6)
  s = StringIO()
  g.show(s)
  assert len(s.getvalue().split()) == 14
  g = gaussian.sum((3,-2,1,-4,5), (-.3,.2,-.1,.4,-.5))
  s = StringIO()
  g.show(s)
  assert len(s.getvalue().split()) == 12
  assert isinstance(g.sort(), gaussian.sum)
  assert approx_equal(g.sort().array_of_a(), (5,-4,3,-2,1))
  assert approx_equal(g.sort().array_of_b(), (-.5,.4,-.3,.2,-.1))
  assert not g.sort().use_c()
  g = gaussian.sum((1,2),(3,4),5)
  assert approx_equal(g.sort().array_of_a(), (2,1))
  assert approx_equal(g.sort().array_of_b(), (4,3))
  assert approx_equal(g.sort().c(), 5)
  assert g.sort().use_c()

def fit_finite_diff_gradients(gfit, x, eps=1.e-2):
  gr = flex.double()
  c = gfit.c()
  use_c = gfit.use_c()
  for i in range(gfit.n_terms()):
    t = []
    for seps in (eps, -eps):
      a = list(gfit.array_of_a())
      a[i] += seps
      t.append(
        gaussian.sum(a, gfit.array_of_b(), c, use_c).at_x(x))
    gr.append((t[0]-t[1])/(2*eps))
    t = []
    for seps in (eps, -eps):
      b = list(gfit.array_of_b())
      b[i] += seps
      t.append(
        gaussian.sum(gfit.array_of_a(), b, c, use_c).at_x(x))
    gr.append((t[0]-t[1])/(2*eps))
  if (use_c):
    t = []
    for seps in (eps, -eps):
      t.append(
        gaussian.sum(
          gfit.array_of_a(), gfit.array_of_b(), c+seps, use_c).at_x(x))
    gr.append((t[0]-t[1])/(2*eps))
  return gr

def fit_finite_diff_target_gradients(gfit, power, use_sigmas, eps=1.e-2):
  assert gfit.table_x().size() == 1
  weight = 1/gfit.table_sigmas()[0]**2
  gr = flex.double()
  c = gfit.c()
  use_c = gfit.use_c()
  for i in range(gfit.n_terms()):
    t = []
    for seps in (eps, -eps):
      a = list(gfit.array_of_a())
      a[i] += seps
      gf = gaussian.fit(
        gfit.table_x(),
        gfit.table_y(),
        gfit.table_sigmas(),
        gaussian.sum(a, gfit.array_of_b(), c, use_c))
      t.append(gf.target_function(power, use_sigmas, gf.differences()))
    gr.append((t[0]-t[1])/(2*eps))
    t = []
    for seps in (eps, -eps):
      b = list(gfit.array_of_b())
      b[i] += seps
      gf = gaussian.fit(
        gfit.table_x(),
        gfit.table_y(),
        gfit.table_sigmas(),
        gaussian.sum(gfit.array_of_a(), b, c, use_c))
      t.append(gf.target_function(power, use_sigmas, gf.differences()))
    gr.append((t[0]-t[1])/(2*eps))
  if (use_c):
    t = []
    for seps in (eps, -eps):
      gf = gaussian.fit(
        gfit.table_x(),
        gfit.table_y(),
        gfit.table_sigmas(),
        gaussian.sum(gfit.array_of_a(), gfit.array_of_b(), c+seps, use_c))
      t.append(gf.target_function(power, use_sigmas, gf.differences()))
    gr.append((t[0]-t[1])/(2*eps))
  return gr

def exercise_fit():
  x = flex.double((0.1, 0.2, 0.5))
  y = flex.double((3,2,1))
  sigmas = flex.double((0.04,0.02,0.01))
  gf = gaussian.fit(
    x, y, sigmas,
    gaussian.sum((1,2), (4,5)))
  assert approx_equal(gf.array_of_a(), (1,2))
  assert approx_equal(gf.array_of_b(), (4,5))
  assert approx_equal(gf.c(), 0)
  assert not gf.use_c()
  assert approx_equal(gf.table_x(), x)
  assert approx_equal(gf.table_y(), y)
  assert approx_equal(gf.table_sigmas(), sigmas)
  assert approx_equal(gf.fitted_values(),
    [2.8632482881537511, 2.4896052951221748, 0.94088903489182252])
  reference_gaussian = gaussian.sum((1,2,3), (4,5,6))
  gf = gaussian.fit(
    x, reference_gaussian, sigmas,
    gaussian.sum((1,2), (4,5)))
  assert approx_equal(gf.array_of_a(), (1,2))
  assert approx_equal(gf.array_of_b(), (4,5))
  assert approx_equal(gf.c(), 0)
  assert approx_equal(gf.table_x(), x)
  assert approx_equal(gf.table_y(), reference_gaussian.at_x(x))
  assert approx_equal(gf.table_sigmas(), sigmas)
  assert isinstance(gf.sort(), gaussian.fit)
  assert gf.sort().table_x() == gf.table_x()
  assert gf.sort().table_y() == gf.table_y()
  assert gf.sort().table_sigmas() == gf.table_sigmas()
  assert approx_equal(gf.differences(), gf.at_x(x)-reference_gaussian.at_x(x))
  c_fit = gaussian.fit(
    flex.double([0.0, 0.066666666666666666, 0.13333333333333333,
                 0.2, 0.26666666666666666]),
    gaussian.sum(
      (2.657506, 1.078079, 1.490909, -4.2410698, 0.71379101),
      (14.780758, 0.776775, 42.086842, -0.000294, 0.239535),
      4.2979832),
    flex.double(5, 0.0005),
    gaussian.sum(
      (1.1423916, 4.1728425, 0.61716694),
      (0.50733125, 14.002512, 41.978928)))
  differences = flex.double([-0.064797341823577881, 0.003608505180995536,
    0.098159179757290715, 0.060724224581695019, -0.10766283796372011])
  assert approx_equal(c_fit.differences(), differences)
  assert approx_equal(c_fit.significant_relative_errors(),
    [0.0107212, 0.0005581, 0.0213236, 0.0169304, 0.0385142])
  gf = gaussian.fit(
    x, reference_gaussian, flex.double(x.size(), 1),
    gaussian.sum((1,2), (4,5)))
  assert list(gf.bound_flags(False, False)) == [False,False,False,False]
  assert list(gf.bound_flags(True, False)) == [True,False,True,False]
  assert list(gf.bound_flags(False, True)) == [False,True,False,True]
  sgf = gf.apply_shifts(flex.double((3,-3,4,6)), True)
  assert approx_equal(sgf.array_of_a(), (1+3,2+4))
  assert approx_equal(sgf.array_of_b(),
    ((math.sqrt(4)-3)**2,(math.sqrt(5)+6)**2))
  assert approx_equal(sgf.c(), 0)
  assert not sgf.use_c()
  sgf = gf.apply_shifts(flex.double((3,-3,4,6)), False)
  assert approx_equal(sgf.array_of_a(), (1+3,2+4))
  assert approx_equal(sgf.array_of_b(), (4-3,5+6))
  assert approx_equal(sgf.c(), 0)
  assert not sgf.use_c()
  differences = sgf.differences()
  for use_sigmas in [False, True]:
    assert approx_equal(sgf.target_function(2, use_sigmas, differences),
      25.0320634)
    assert approx_equal(sgf.target_function(4, use_sigmas, differences),
      256.2682575)
    assert approx_equal(
      sgf.gradients_d_abc(2, use_sigmas, differences),
      [15.6539271, -4.1090114, 10.4562306, -1.6376781])
  gfc = gaussian.fit(
    x, reference_gaussian, flex.double(x.size(), 1),
    gaussian.sum((1,2), (4,5), 6))
  assert list(gfc.bound_flags(False, False)) == [False,False,False,False,False]
  assert list(gfc.bound_flags(True, False)) == [True,False,True,False,True]
  assert list(gfc.bound_flags(False, True)) == [False,True,False,True,False]
  sgfc = gfc.apply_shifts(flex.double((3,-3,4,6,-5)), True)
  assert approx_equal(sgfc.array_of_a(), (1+3,2+4))
  assert approx_equal(sgfc.array_of_b(),
    ((math.sqrt(4)-3)**2,(math.sqrt(5)+6)**2))
  assert approx_equal(sgfc.c(), 6-5)
  assert sgfc.use_c()
  sgfc = gfc.apply_shifts(flex.double((3,-3,4,6,-5)), False)
  assert approx_equal(sgfc.array_of_a(), (1+3,2+4))
  assert approx_equal(sgfc.array_of_b(), (4-3,5+6))
  assert approx_equal(sgfc.c(), 6-5)
  assert sgfc.use_c()
  differences = sgfc.differences()
  for use_sigmas in [False, True]:
    assert approx_equal(sgfc.target_function(2, use_sigmas, differences),
      44.8181444)
    assert approx_equal(sgfc.target_function(4, use_sigmas, differences),
      757.3160329)
    assert approx_equal(
      sgfc.gradients_d_abc(2, use_sigmas, differences),
      [21.1132071, -6.0532695, 13.6638274, -2.2460994, 22.7860809])
  differences = c_fit.differences()
  gabc = c_fit.gradients_d_abc(2, False, differences)
  assert approx_equal(
    gabc,
    [-0.016525391425206391, 0.0074465239375589107, 0.020055876723667564,
     0.00054794635257838251, -0.018754011379726425, -0.0011194004809549143])
  assert approx_equal(
    c_fit.gradients_d_shifts(flex.double((0.1,0.4,0.2,0.5,0.3,0.6)), gabc),
    [-0.0165254, 0.01656512, 0.0200559, 0.0046488, -0.0187540, -0.0158487])
  g5c = gaussian.sum(
    (2.657505989074707, 1.0780789852142334, 1.4909089803695679,
     -4.2410697937011719, 0.71379101276397705),
    (14.780757904052734, 0.77677500247955322, 42.086841583251953,
     -0.00029399999766610563, 0.23953500390052795),
    4.2979831695556641)
  for include_constant_term in (False, True):
    a = flex.double(g5c.array_of_a())
    b = flex.double(g5c.array_of_b())
    permutation = flex.sort_permutation(data=flex.abs(a), reverse=True)[:4]
    gf = gaussian.fit(
      flex.double([0]),
      g5c,
      flex.double(1, 1),
      gaussian.sum(
        iter(a.select(permutation)),
        iter(b.select(permutation)), 0, include_constant_term))
    assert approx_equal(gf.differences(), [-5.01177418232])
    shifts = flex.double(8,-1)
    if (include_constant_term): shifts.append(-.2)
    sgf = gf.apply_shifts(shifts, False)
    assert approx_equal(sgf.array_of_a(),
                        [-5.2410698, 1.657506, 0.49090898, 0.078078985])
    assert approx_equal(sgf.array_of_b(),
                        [-1.0002940, 13.780758, 41.086842, -0.223225])
    if (include_constant_term):
      assert approx_equal(sgf.c(), -.2)
    expected_gradients = [1,0,1,0,1,0,1,0]
    if (include_constant_term): expected_gradients.append(1)
    assert approx_equal(
      fit_finite_diff_gradients(sgf, 0),
      expected_gradients,
      eps=1.e-4)
    for i in range(10):
      gf = gaussian.fit(
        flex.double([i / 10.]),
        g5c,
        flex.double(1, 1),
        sgf)
      differences = flex.double([0.5])
      assert approx_equal(
        gf.gradients_d_abc(2, False, differences),
        fit_finite_diff_gradients(gf, gf.table_x()[0]),
        eps=1.e-3)
      for sigma in [0.04,0.02,0.01]:
        gf = gaussian.fit(
          flex.double([i / 20.]),
          g5c,
          flex.double([sigma]),
          sgf)
        for power in [2,4]:
          for use_sigmas in [False, True]:
            differences = gf.differences()
            an=gf.gradients_d_abc(power, use_sigmas, differences)
            fi=fit_finite_diff_target_gradients(gf, power, use_sigmas)
            assert eps_eq(an, fi, eps=1.e-3)

carbon_s_y_table = [
0.00, 6.000, 0.01, 5.990, 0.02, 5.958, 0.03, 5.907, 0.04, 5.837, 0.05, 5.749,
0.06, 5.645, 0.07, 5.526, 0.08, 5.396, 0.09, 5.255, 0.10, 5.107, 0.11, 4.952,
0.12, 4.794, 0.13, 4.633, 0.14, 4.472, 0.15, 4.311, 0.16, 4.153, 0.17, 3.998,
0.18, 3.847, 0.19, 3.701, 0.20, 3.560, 0.22, 3.297, 0.24, 3.058, 0.25, 2.949,
0.26, 2.846, 0.28, 2.658, 0.30, 2.494, 0.32, 2.351, 0.34, 2.227, 0.35, 2.171,
0.36, 2.120, 0.38, 2.028, 0.40, 1.948, 0.42, 1.880, 0.44, 1.821, 0.45, 1.794,
0.46, 1.770, 0.48, 1.725, 0.50, 1.685, 0.55, 1.603, 0.60, 1.537, 0.65, 1.479,
0.70, 1.426, 0.80, 1.322, 0.90, 1.219, 1.00, 1.114, 1.10, 1.012, 1.20, 0.914,
1.30, 0.822, 1.40, 0.736, 1.50, 0.659, 1.60, 0.588, 1.70, 0.525, 1.80, 0.468,
1.90, 0.418, 2.00, 0.373, 2.50, 0.216, 3.00, 0.130, 3.50, 0.081, 4.00, 0.053,
5.00, 0.025, 6.00, 0.013]

class tabulated_fit:

  def __init__(self, limit, coefficients):
    self.limit = limit
    self.coefficients = coefficients

carbon_fit_6 = tabulated_fit(6.0, [
2.18188567686, 13.4533708328,
1.77612377639, 32.5790123523,
1.08772011297, 0.747293264573,
0.641460989931, 0.251251498175,
0.207885994451, 80.9799313275,
0.105219184507, 0.0587297979816])

carbon_fit_5 = tabulated_fit(6.0, [
2.65463431663, 14.7665037505,
1.49420264709, 42.0409767208,
1.05563210943, 0.780856499884,
0.688021531597, 0.258963998784,
0.104681246572, 0.0579465611728])

carbon_fit_4 = tabulated_fit(3.0, [
2.21557580709, 12.7523000206,
1.98306066831, 36.4905110196,
1.31636728472, 0.632825354093,
0.480812064621, 0.148079120135])

carbon_fit_3 = tabulated_fit(1.4, [
2.51340127252, 31.8053433708,
1.74867019409, 0.445605499982,
1.72398202356, 10.5831679451])

carbon_fit_2 = tabulated_fit(0.5, [
3.54355550695, 25.6239838191,
2.42579673735, 1.50364460774])

carbon_fit_1 = tabulated_fit(0.15, [
5.96792806111, 14.8957682987])

carbon_it1992 = tabulated_fit(2.0, [
2.31000, 20.8439,
1.02000, 10.2075,
1.58860, 0.568700,
0.865000, 51.6512,
0.215600])

carbon_wk1995 = tabulated_fit(6.0, [
2.657506, 14.780758,
1.078079, 0.776775,
1.490909, 42.086842,
-4.241070, -0.000294,
0.713791, 0.239535,
4.297983])

class carbon_fit(immoptibox_ports.test_function):

  def __init__(self, tab_fit, perturb, verbose):
    self.tab_fit = tab_fit
    self.perturb = perturb
    self.verbose = verbose
    carbon_ss = flex.double(carbon_s_y_table)[0::2]
    carbon_ys = flex.double(carbon_s_y_table)[1::2]
    selection = carbon_ss <= tab_fit.limit + 1.e-3
    self.fit = gaussian.fit(
      carbon_ss.select(selection),
      carbon_ys.select(selection),
      flex.double(selection.count(True), 1),
      gaussian.sum(flex.double(tab_fit.coefficients)))
    n = self.fit.n_parameters()
    immoptibox_ports.test_function.__init__(self,
      m=self.fit.table_x().size(),
      n=n,
      check_with_finite_differences=(n <= 6 or n == 9),
      verbose=verbose)

  def initialization(self):
    self.x0 = self.fit.parameters()
    self.capital_f_x_star = 0.5*self.f(x=self.x0).norm()**2
    if (self.perturb):
      mersenne_twister = flex.mersenne_twister(seed=0)
      self.x0 *= 1 + mersenne_twister.random_double(
        size=self.x0.size(), factor=0.01)
    self.tau0 = 1e-8
    self.delta0 = 10
    self.x_star = None

  def label(self):
    return "carbon_fit(n=%d, perturb=%s)" % (
      self.fit.n_parameters(), str(self.perturb))

  def check_minimized_capital_f_x_star(self, f_x_star, tolerance=1.e-3):
    capital_f_x_star = 0.5*f_x_star.norm()**2
    if (capital_f_x_star > self.capital_f_x_star):
      assert capital_f_x_star < tolerance, (
        capital_f_x_star, self.capital_f_x_star)
      if (self.verbose):
        print("  WARNING: minimization converged to larger residual", \
          "than original solution:")
        print("    original:", self.capital_f_x_star)
      assert self.perturb

  def f(self, x):
    fit = gaussian.fit(
      self.fit.table_x(), self.fit.table_y(), self.fit.table_sigmas(),
      gaussian.sum(x))
    return fit.differences()

  def jacobian_analytical(self, x):
    fit = gaussian.fit(
      self.fit.table_x(), self.fit.table_y(), self.fit.table_sigmas(),
      gaussian.sum(x))
    return fit.least_squares_jacobian_abc()

  def hessian_analytical(self, x):
    j = self.jacobian_analytical(x=x)
    fit = gaussian.fit(
      self.fit.table_x(), self.fit.table_y(), self.fit.table_sigmas(),
      gaussian.sum(x))
    return fit.least_squares_hessian_abc_as_packed_u() \
      .matrix_packed_u_as_symmetric()

def exercise_fit_jacobian_and_hessian(verbose):
  for tab_fit in [carbon_fit_1, carbon_fit_2, carbon_fit_3,
                  carbon_fit_4, carbon_fit_5, carbon_fit_6,
                  carbon_it1992, carbon_wk1995]:
    for perturb in [False, True]:
      carbon_fit(tab_fit=tab_fit, perturb=perturb, verbose=verbose)

def run():
  exercise_term()
  exercise_sum()
  exercise_fit()
  exercise_fit_jacobian_and_hessian(verbose="--verbose" in sys.argv[1:])
  print(format_cpu_times())

if (__name__ == "__main__"):
  run()


 *******************************************************************************


 *******************************************************************************
scitbx/math/tests/tst_gaussian_fit_1d_analytical.py
from __future__ import absolute_import, division, print_function
import scitbx.math
from scitbx.array_family import flex
import math
from libtbx.test_utils import approx_equal
from six.moves import range

def exercise_1():
  x = flex.double()
  y = flex.double()
  for x_ in range(0, 10):
    x_ = x_/10.
    x.append(x_)
    y.append( 2.*math.exp(-3.*x_**2) )
  r = scitbx.math.gaussian_fit_1d_analytical(x = x, y = y)
  assert approx_equal(r.a, 2., 1.e-6)
  assert approx_equal(r.b, 3., 1.e-6)

def exercise_2():
  x = flex.double()
  z = flex.double()
  for i in range(1,11):
    x.append(i)
  for i in range(11,21):
    z.append(i)
  y = z * 2 * flex.exp(-5.*x*x)
  r = scitbx.math.gaussian_fit_1d_analytical(x = x, y = y, z = z)
  assert approx_equal(r.a, 2., 1.e-6)
  assert approx_equal(r.b, 5., 1.e-6)

if (__name__ == "__main__"):
  exercise_1()
  exercise_2()
  print("OK")


 *******************************************************************************


 *******************************************************************************
scitbx/math/tests/tst_gcd.py
from __future__ import absolute_import, division, print_function
import scitbx.math
import boost_adaptbx.boost.rational
import time
import sys, os
from six.moves import range
from six.moves import zip

def compare_with_boost_rational_gcd(label):
  other_gcd = getattr(scitbx.math, label, None)
  if (other_gcd is None): return
  print("compare_with_boost_rational_gcd(%s)" % label)
  samples = list(range(-100,101)) \
          + list(range(-100000-10,-100000+11)) \
          + list(range( 100000-10, 100000+11))
  for a in samples:
    for b in samples:
      r = boost_adaptbx.boost.rational.gcd(a, b)
      o = other_gcd(a=a, b=b)
      if (o != r):
        raise RuntimeError(str((a, b, r, o)))

def run(args):
  if (len(args) == 0):
    n = 1000
  else:
    assert len(args) == 1
    n = int(args[0])
  #
  labels = [
    "gcd_int_boost",
    "gcd_int_simple",
    "gcd_int32_asm",
    "gcd_long_boost",
    "gcd_long_simple",
    "gcd_unsigned_long_binary",
    "gcd_long_binary",
    "gcd_int64_asm"]
  #
  for label in labels:
    compare_with_boost_rational_gcd(label=label)
  #
  impls = [getattr(scitbx.math, "time_%s" % label, None)
    for label in labels]
  for label,impl in zip(labels,impls):
    if (impl is None): continue
    w0 = time.time()
    us0 = sum(os.times()[:2])
    result = impl(n)
    print("%-24s %d w=%.2f u+s=%.2f" % (
      label,
      result,
      time.time()-w0,
      sum(os.times()[:2])-us0))
  print("OK")

if (__name__ == "__main__"):
  run(args=sys.argv[1:])


 *******************************************************************************


 *******************************************************************************
scitbx/math/tests/tst_halton.py
from __future__ import absolute_import, division, print_function
import scitbx.math as sm
import math
from libtbx.test_utils import approx_equal
from scitbx.array_family import flex
from six.moves import range

r"""
This routine tests the halton sequence that can be used for
numerical integration (or uniformish samping of a hypercube for that manner).
Specifically:
\int_0^{1} f(y) dy = lim(n->infty) (1/n) Sum f(x_n)
where x_n is the n-th halton sequence number.
If we want to extend that range, take into account jacobians!
i.e.:
\int_{-a}^{a} f(y) dy \approx 2*a/n Sum f( (1-2.0*a)*x_n )

See also

http://en.wikipedia.org/wiki/Quasi-random_sequence

for more information on quasi random sequences.

"""

def test_halton_sequence_1(n_points, high_limit=1.0):
  h_gen = sm.halton(1)
  result = 0.0
  for ii in range(n_points):
    x = h_gen.nth_given_base(5, ii)*high_limit
    y = h_gen.nth_given_base(7, ii)*high_limit
    result += math.exp( float(-x - y) )
    tmp = ( math.exp(-2.0*high_limit) )*( math.exp(high_limit)-1.0 )**2.0
  result /= float(n_points)
  result *= high_limit*high_limit
  tmp = ( math.exp(-2.0*high_limit) )*( math.exp(high_limit)-1.0 )**2.0
  assert approx_equal( result/tmp, 1.0 ,eps=1e-2)


def test_halton_sequence_2(n_points, high_limit=5.0):
  norm = math.pi*2.0
  h_gen = sm.halton(1)
  result = 0.0
  for ii in range(n_points):
    x = (1.0-2.0*h_gen.nth_given_base(5, ii))*high_limit
    y = (1.0-2.0*h_gen.nth_given_base(7, ii))*high_limit
    result += math.exp( -(x*x+y*y)*0.5 )/norm
  tmp = high_limit*high_limit*4.0*result/(float(n_points))
  assert approx_equal(tmp,1.0,eps=1e-2)

def test_cube():
  square = sm.square_halton_sampling(0.1, 0.8,  10.0, 80.0)
  start_values= (0.1, 10.0)
  assert approx_equal( start_values, next(square), eps=1e-4 )
  for ii in range(24):
    next(square)
  assert square.state()==25
  square.set_state(0)
  assert approx_equal( start_values, next(square), eps=1e-4 )

def tst_five_d_cube():
  hcube = sm.halton(5)
  result = flex.double( [0,0,0,0,0] )
  for ii in range(5000):
    vec = flex.double(hcube.nth_all(ii))
    result += vec
  result = result/5000.0
  for ii in result:
    assert approx_equal(ii, 0.5, 0.01)

def run():
  test_halton_sequence_1(1000,2)
  test_halton_sequence_2(1000,10)
  test_cube()
  tst_five_d_cube()

if (__name__ == "__main__"):
  run()
  print("OK")


 *******************************************************************************


 *******************************************************************************
scitbx/math/tests/tst_line_search.py
from __future__ import absolute_import, division, print_function
import scitbx.math
from scitbx.array_family import flex
from libtbx.test_utils import approx_equal
from six.moves import cStringIO as StringIO
import sys

class test_function_5_1:

  def __init__(self, beta=2):
    self.beta = beta

  def functional(self, x):
    assert x.size() == 1
    alpha = x[0]
    return -alpha / (alpha**2 + self.beta)

  def gradients(self, x):
    assert x.size() == 1
    alpha = x[0]
    return flex.double([(alpha**2 - self.beta) / (alpha**2 + self.beta)**2])

def exercise(verbose):
  line_search = scitbx.math.line_search_more_thuente_1994()
  if (verbose):
    out = sys.stdout
  else:
    out = StringIO()
  line_search.show_status(f=out)
  print(file=out)
  assert line_search.maxfev == 20
  line_search.gtol = 0.01
  assert line_search.gtol == 0.01
  x = flex.double([0])
  search_direction = flex.double([1])
  tf = test_function_5_1()
  line_search.start(
    x=x,
    functional=tf.functional(x),
    gradients=tf.gradients(x),
    search_direction=search_direction,
    initial_estimate_of_satisfactory_step_length=1)
  assert line_search.info_code == -1
  line_search.show_status(f=out)
  print("x:", list(x), file=out)
  print(file=out)
  while (line_search.info_code == -1):
    line_search.next(
      x=x,
      functional=tf.functional(x),
      gradients=tf.gradients(x))
    if (verbose):
      line_search.show_status(f=out)
      print("x:", list(x), file=out)
      print("functional:", tf.functional(x), file=out)
      print(file=out)
  assert line_search.info_code == 1
  assert line_search.nfev == 3
  assert approx_equal(line_search.stp, 1.41997705997)
  print("OK")

if (__name__ == "__main__"):
  exercise(verbose="--verbose" in sys.argv[1:])


 *******************************************************************************


 *******************************************************************************
scitbx/math/tests/tst_math.py
from __future__ import absolute_import, division, print_function
import scitbx.math
import boost_adaptbx.boost.rational
from scitbx.math import line_given_points
from scitbx.math import dihedral_angle
from scitbx.math import euler_angles_as_matrix
from scitbx.math import erf_verification, erf, erfc, erfcx
from scitbx.math import bessel_i1_over_i0, bessel_i0, bessel_i1,\
     bessel_ln_of_i0, ei1, ei0, parabolic_cylinder_d
from scitbx.math import bessel_inverse_i1_over_i0
from scitbx.math import gamma_incomplete, gamma_incomplete_complement
from scitbx.math import gamma_complete, exponential_integral_e1z
from scitbx.math import lambertw
from scitbx.math import golay_24_12_generator
from scitbx.math import inertia_tensor
from scitbx.math import principal_axes_of_inertia, \
     principal_axes_of_inertia_2d
from scitbx.math import sphere_3d, minimum_covering_sphere
from scitbx.math import signed_phase_error, phase_error, nearest_phase
from scitbx.math import icosahedron
from scitbx.math import chebyshev_base
from scitbx.math import chebyshev_polynome
from scitbx.math import chebyshev_fitter
from scitbx.math import slatec_dgamma, slatec_dlngam
from scitbx.math import distributions
from scitbx.array_family import flex
from scitbx import matrix
from libtbx.utils import user_plus_sys_time
from libtbx.test_utils import Exception_expected, approx_equal, eps_eq
import libtbx.load_env
from six.moves import cStringIO as StringIO
from itertools import count
import random
import math
import time
import sys
from six.moves import range
from six.moves import zip

if (libtbx.env.has_module("tntbx")):
  import tntbx
else:
  tntbx = None

def exercise_div_mod():
  from scitbx.math import divmod
  q,r = divmod(4.34, 2)
  assert q == 2
  assert approx_equal(r, 0.34)
  q,r = divmod(-3.23, 2)
  assert q == -2
  assert approx_equal(r, 0.77)

  for y,q,r in [(5.23, 2, 1.3), (-5.23, 2, 1.3),
                (5.23, -2, 1.3), (-5.23, -2, 1.3)]:
    x = q*y + r
    q1,r1 = divmod(x,y)
    assert q1 == q
    assert approx_equal(r1,r)

  assert divmod(0, 1) == (0,0)
  assert divmod(1, 1) == (1,0)
  assert divmod(2, 1) == (2,0)
  assert divmod(-0, 1) == (0,-0)
  assert divmod(-1, 1) == (-1,-0)
  assert divmod(-2, 1) == (-2,-0)

  assert divmod(0, -1) == (0,0)
  assert divmod(1, -1) == (-1,0)
  assert divmod(2, -1) == (-2,0)
  assert divmod(-0, -1) == (0,-0)
  assert divmod(-1, -1) == (1,-0)
  assert divmod(-2, -1) == (2,-0)

  assert divmod(1, 2) == (0,1)
  assert divmod(3, 2) == (2,-1)
  assert divmod(5, 2) == (2,1)
  assert divmod(-1, 2) == (0,-1)
  assert divmod(-3, 2) == (-2,1)
  assert divmod(-5, 2) == (-2,-1)

  assert divmod(1, -2) == (0,1)
  assert divmod(3, -2) == (-2,-1)
  assert divmod(5, -2) == (-2,1)
  assert divmod(-1, -2) == (0,-1)
  assert divmod(-3, -2) == (2,1)
  assert divmod(-5, -2) == (2,-1)

def exercise_floating_point_epsilon():
  float_eps = scitbx.math.floating_point_epsilon_float_get()
  double_eps = scitbx.math.floating_point_epsilon_double_get()
  assert 1.+float_eps != 1.
  assert 1.+double_eps != 1.
  assert float_eps >= double_eps
  assert 1.+double_eps/2. == 1.

def exercise_line_given_points():
  lgp = line_given_points(points=[(0,0,0), (0,0,0)])
  assert approx_equal(lgp.distance_sq(point=matrix.col((0,0,0))), 0)
  assert approx_equal(lgp.distance_sq(point=matrix.col((0,0,1))), 1)
  lgp = line_given_points(points=[(0,0,1), (0,0,0)])
  assert approx_equal(lgp.distance_sq(point=matrix.col((0,0,1))), 0)
  assert approx_equal(lgp.distance_sq(point=matrix.col((0,1,0))), 1)
  lgp = line_given_points(points=[(1,2,3), (3,1,4)])
  assert approx_equal(lgp.distance_sq(point=matrix.col((0,0,0))), 12.5)
  assert approx_equal(lgp.distance_sq(point=matrix.col((0,0,1))), 25/3.)

def exercise_dihedral_angle():
  def dihe(sites):
    t = dihedral_angle(sites=sites, deg=True)
    v = dihedral_angle(sites=flex.vec3_double(sites), deg=True)
    if (t is None):
      assert v is None
    else:
      assert v is not None
      assert approx_equal(t, v)
    return t
  d = dihe(sites=[(0,0,0)]*4)
  assert d is None
  d = dihe(sites=[(1,0,0), (0,0,0), (0,1,0), (1,1,0)])
  assert approx_equal(d, 0)
  d = dihe(sites=[(1,0,0), (0,0,0), (0,1,0), (-1,1,0)])
  assert approx_equal(abs(d), 180)
  d = dihe(sites=[(1,0,0), (0,0,0), (0,1,0), (0,1,1)])
  assert approx_equal(d, -90)
  d = dihe(sites=[(1,0,0), (0,0,0), (0,1,0), (0,1,-1)])
  assert approx_equal(d, 90)
  mt = flex.mersenne_twister(seed=0)
  for ad in range(-179, 180):
    ar = math.radians(ad)
    c, s = math.cos(ar), math.sin(ar)
    f = 2 - mt.random_double()
    sites = flex.vec3_double([(f,0,0), (0,0,0), (0,f,0), (f*c,f,-f*s)])
      #                                                         ^
      #                                 conventions are wonderful
    d = dihedral_angle(sites=sites, deg=True)
    assert approx_equal(d, ad)
    r = mt.random_double_r3_rotation_matrix()
    t = mt.random_double_point_on_sphere()
    d = dihedral_angle(sites=r*sites+t, deg=True)
    assert approx_equal(d, ad, eps=2e-6)
    d = matrix._dihedral_angle(sites=matrix.col_list(r*sites+t), deg=True)
    assert approx_equal(d, ad)
  sites = [
    (-3.193, 1.904, 4.589),
    (-1.955, 1.332, 3.895),
    (-1.005, 2.228, 3.598),
    ( 0.384, 1.888, 3.199)]
  d = dihe(sites=sites)
  assert approx_equal(d, 166.212120415)

def exercise_euler_angles():
  assert approx_equal(euler_angles_as_matrix([0,0,0]).elems,
    [1,0,0,0,1,0,0,0,1])
  assert approx_equal(euler_angles_as_matrix([180,0,0], deg=True).elems,
    [-1,0,0,0,-1,0,0,0,1])
  assert approx_equal(euler_angles_as_matrix([0,180,0], deg=True).elems,
    [-1,0,0,0,1,0,0,0,-1])
  assert approx_equal(euler_angles_as_matrix([0,0,180], deg=True).elems,
    [-1,0,0,0,-1,0,0,0,1])
  assert approx_equal(euler_angles_as_matrix([90,0,0], deg=True).elems,
    [0,-1,0,1,0,0,0,0,1])
  assert approx_equal(euler_angles_as_matrix([0,90,0], deg=True).elems,
    [0,0,1,0,1,0,-1,0,0])
  assert approx_equal(euler_angles_as_matrix([0,0,90], deg=True).elems,
    [0,-1,0,1,0,0,0,0,1])

def exercise_erf():
  erf_verify = erf_verification()
  # Expected results obtained by running the original
  # FORTRAN code under Tru64 Unix.
  # See also: scitbx/math/dev/README
  erf_verify(erf, 1.102483591684125E-004, 1.244019511880774E-004)
  erf_verify(erf, 0.117651583521854, 0.132145601355679)
  erf_verify(erf, 0.235069688589948, 0.260442011292979)
  erf_verify(erf, 0.352309859191852, 0.381686081076891)
  erf_verify(erfc, 0.970883582602861, 0.169740928450908)
  erf_verify(erfc, 0.662251325736969, 0.348982462199060)
  erf_verify(erfc, 1.35402517159916, 5.550771183345651E-002)
  erf_verify(erfc, 1.04576304738078, 0.139158413714973)
  erf_verify(erfc, 1.73790185144654, 1.398048693929801E-002)
  erf_verify(erfc, 1.42912826254883, 4.327018321700024E-002)
  erf_verify(erfc, 2.12125887397317, 2.700566694860312E-003)
  erf_verify(erfc, 1.81249050086459, 1.036977546108103E-002)
  erf_verify(erfcx, 0.973392426408860, 0.434963885763398)
  erf_verify(erfcx, 0.665081793626574, 0.539933818979981)
  erf_verify(erfcx, 1.35724600005572, 0.346596780023340)
  erf_verify(erfcx, 1.04836345595439, 0.414722416503421)
  erf_verify(erfcx, 1.74107610470511, 0.286145510591003)
  erf_verify(erfcx, 1.43212197979175, 0.333053266914237)
  erf_verify(erfcx, 2.12428846184817, 0.242739423717836)
  erf_verify(erfcx, 1.81606172854839, 0.276556810628268)
  erf_verify(erfc, 2.62003792003157, 2.111463761469150E-004)
  erf_verify(erfc, 5.12059159283289, 4.433890735237740E-013)
  erf_verify(erfc, 8.63668354446932, 2.613296860860847E-034)
  erf_verify(erfc, 11.1437916191963, 5.891081160010891E-056)
  erf_verify(erfc, 14.6497556694182, 2.389628051234427E-095)
  erf_verify(erfc, 17.1517732073587, 5.677885934529786E-130)
  erf_verify(erfc, 20.6668792553407, 8.706194441633715E-188)
  erf_verify(erfc, 23.1638554546886, 2.287385773272363E-235)
  erf_verify(erfcx, 2.62907657906194, 0.201608800911889)
  erf_verify(erfcx, 4.37646062474290, 0.125783546292562)
  erf_verify(erfcx, 7.13820945795942, 7.828417109269534E-002)
  erf_verify(erfcx, 8.88772516645629, 6.308522532999319E-002)
  erf_verify(erfcx, 11.6501072021873, 4.825137678138556E-002)
  erf_verify(erfcx, 13.4008106775670, 4.198489891639072E-002)
  erf_verify(erfcx, 16.1586604627164, 3.484913452473175E-002)
  erf_verify(erfcx, 17.9110272449630, 3.145069912820161E-002)
  erf_verify(erfcx, 20.4992639479713, 2.748979983772347E-002)
  erf_verify(erfcx, 19.9992639479713, 2.817538309213394E-002)
  erf_verify(erf, 0.000000000000000E+000, 0.000000000000000E+000)
  erf_verify(erf, 0.000000000000000E+000, 0.000000000000000E+000)
  erf_verify(erfc, 0.000000000000000E+000, 1.00000000000000)
  erf_verify(erfcx, 0.000000000000000E+000, 1.00000000000000)
  erf_verify(erf, -0.500000000000000, -0.520499877813047)
  erf_verify(erf, 0.500000000000000, 0.520499877813047)
  erf_verify(erfc, -0.500000000000000, 1.52049987781305)
  erf_verify(erfcx, -0.500000000000000, 1.95236048918256)
  erf_verify(erf, -1.00000000000000, -0.842700792949715)
  erf_verify(erf, 1.00000000000000, 0.842700792949715)
  erf_verify(erfc, -1.00000000000000, 1.84270079294971)
  erf_verify(erfcx, -1.00000000000000, 5.00898008076228)
  erf_verify(erf, -1.50000000000000, -0.966105146475311)
  erf_verify(erf, 1.50000000000000, 0.966105146475311)
  erf_verify(erfc, -1.50000000000000, 1.96610514647531)
  erf_verify(erfcx, -1.50000000000000, 18.6538862562627)
  erf_verify(erf, -2.00000000000000, -0.995322265018953)
  erf_verify(erf, 2.00000000000000, 0.995322265018953)
  erf_verify(erfc, -2.00000000000000, 1.99532226501895)
  erf_verify(erfcx, -2.00000000000000, 108.940904389978)
  erf_verify(erf, -2.50000000000000, -0.999593047982555)
  erf_verify(erf, 2.50000000000000, 0.999593047982555)
  erf_verify(erfc, -2.50000000000000, 1.99959304798255)
  erf_verify(erfcx, -2.50000000000000, 1035.81484297262)
  erf_verify(erf, -3.00000000000000, -0.999977909503001)
  erf_verify(erf, 3.00000000000000, 0.999977909503001)
  erf_verify(erfc, -3.00000000000000, 1.99997790950300)
  erf_verify(erfcx, -3.00000000000000, 16205.9888539996)
  erf_verify(erf, -3.50000000000000, -0.999999256901628)
  erf_verify(erf, 3.50000000000000, 0.999999256901628)
  erf_verify(erfc, -3.50000000000000, 1.99999925690163)
  erf_verify(erfcx, -3.50000000000000, 417962.422445770)
  erf_verify(erf, -4.00000000000000, -0.999999984582742)
  erf_verify(erf, 4.00000000000000, 0.999999984582742)
  erf_verify(erfc, -4.00000000000000, 1.99999998458274)
  erf_verify(erfcx, -4.00000000000000, 17772220.9040163)
  erf_verify(erf, -4.50000000000000, -0.999999999803384)
  erf_verify(erf, 4.50000000000000, 0.999999999803384)
  erf_verify(erfc, -4.50000000000000, 1.99999999980338)
  erf_verify(erfcx, -4.50000000000000, 1245928884.27441)
  erf_verify(erf, 1.797693134862316E+308, 1.00000000000000)
  erf_verify(erf, 0.000000000000000E+000, 0.000000000000000E+000)
  erf_verify(erfc, 0.000000000000000E+000, 1.00000000000000)
  erf_verify(erfc, -1.797693134862316E+308, 2.00000000000000)
  erf_verify(erfc, 19.9074438229742, 2.178791258493533E-174)
  erf_verify(erfc, 26.5432584306324, 0.000000000000000E+000)
  erf_verify(erfcx, 2.377124393213978E+307, 2.373412115741015E-308)
  erf_verify(erfcx, -23.9658621423763, 5.540070644707187E+249)
  erf_verify(erfcx, -26.6287357137515, 1.790000000000000E+308)
  # In Python 3.6, the differences for -3.5, -4.0, and -4.5 are
  # ~3.5e-10, ~1.5e-8, and 4.1e-6. The default tolerance is 1.0e-10
  assert (erf_verify.max_delta < erf_verify.tolerance or
          erf_verify.max_delta < 1.0e-5)

def exercise_exponential_integral_e1z():
  assert approx_equal(exponential_integral_e1z(0.5), 0.559773595)
  assert approx_equal(exponential_integral_e1z(1.0), 0.219383934)
  assert approx_equal(exponential_integral_e1z(1.5), 0.100019582)
  assert approx_equal(exponential_integral_e1z(2.0), 0.048900511)


def exercise_gamma_incomplete():
  assert approx_equal(gamma_incomplete(2.0, 0.1),0.004678840160445)
  assert approx_equal(gamma_incomplete(2.0, 0.5),0.090204010431050)
  assert approx_equal(gamma_incomplete(2.0, 2.5),0.712702504816354)
  assert approx_equal(gamma_incomplete(2.0, 5.0),0.959572318005487)
  assert approx_equal(gamma_incomplete(2.0,15.5),0.999996938604252)
  assert approx_equal(gamma_incomplete(2.0,21.0),0.999999983318367)
  #
  assert approx_equal(gamma_incomplete(20.0, 0.1),0)
  assert approx_equal(gamma_incomplete(20.0, 0.5),0)
  assert eps_eq(gamma_incomplete(20.0, 2.5),
    3.480438159897403e-12,eps=1.e-5)
  assert eps_eq(gamma_incomplete(20.0, 5.0),3.452135821646607e-7)
  assert approx_equal(gamma_incomplete(20.0,15.5),0.154492096867129)
  assert approx_equal(gamma_incomplete(20.0,21.0),0.615737227735658)
  try: gamma_incomplete(a=20.0, x=15.5, max_iterations=5)
  except RuntimeError as e:
    assert str(e) == \
      "scitbx Error: gamma::incomplete_series(" \
      "a=20, x=15.5, max_iterations=5) failed to converge"
  else: raise Exception_expected
  try: gamma_incomplete(a=20.0, x=25.5, max_iterations=5)
  except RuntimeError as e:
    assert str(e) == \
      "scitbx Error: gamma::incomplete_continued_fraction(" \
      "a=20, x=25.5, max_iterations=5) failed to converge"
  else: raise Exception_expected
  #
  assert approx_equal(1-gamma_incomplete_complement(2.0, 2.5),
                                   gamma_incomplete(2.0, 2.5))

def exercise_gamma_complete():
  ## complete gamma with lanczos approx for x<12 and minimax otherwise
  assert approx_equal(gamma_complete(0.1),9.5135076986687)
  assert approx_equal(gamma_complete(0.5),1.7724538509055)
  assert approx_equal(gamma_complete(2.5),1.3293403881791)
  assert approx_equal(gamma_complete(5.0),24.0)
  assert approx_equal(gamma_complete(15.5),3.3483860987356E11)
  assert approx_equal(gamma_complete(21.0),2432902008176640000)
  ## complete gamma with lanczos approx for all values
  assert approx_equal(gamma_complete(0.1,minimax=False),9.5135076986687)
  assert approx_equal(gamma_complete(0.5,minimax=False),1.7724538509055)
  assert approx_equal(gamma_complete(2.5,minimax=False),1.3293403881791)
  assert approx_equal(gamma_complete(5.0,minimax=False),24.)
  assert approx_equal(gamma_complete(15.5,minimax=False),3.3483860987356E11)
  assert approx_equal(gamma_complete(21.0,minimax=False),2432902008176640000)
  assert "%.8g" % gamma_complete(171.624-1.e-6) == "1.7942025e+308"
  #
  try: gamma_complete(171.624)
  except RuntimeError as e:
    assert str(e) \
        == "scitbx Error: gamma::complete_minimax(171.624): domain error"
  else: raise Exception_expected
  assert "%.8g" % gamma_complete(141.691-1.e-6) == "4.1104518e+242"
  try: gamma_complete(141.691, minimax=False)
  except RuntimeError as e:
    assert str(e) \
        == "scitbx Error: gamma::complete_lanczos(141.691): domain error"
  else: raise Exception_expected

def exercise_bessel():
  assert approx_equal(bessel_i1_over_i0(-1e+9), -1.0)
  assert approx_equal(bessel_i1_over_i0(-99.99),-0.994988)
  assert approx_equal(bessel_i1_over_i0(-50.00),-0.98995)
  assert approx_equal(bessel_i1_over_i0( -1.00),-0.44639)
  assert approx_equal(bessel_i1_over_i0(  0.0),  0.0)
  assert approx_equal(bessel_i1_over_i0(  1.00), 0.44639)
  assert approx_equal(bessel_i1_over_i0( 50.0),  0.98995)
  assert approx_equal(bessel_i1_over_i0( 99.99), 0.994988)
  assert approx_equal(bessel_i1_over_i0(1e+9),   1.0)
  x=0.0
  while x <= 100.0:
    assert approx_equal(-bessel_i1_over_i0(-x),bessel_i1_over_i0(x))
    x+=0.01
  x=0.0
  while x <= 10.0:
    assert eps_eq(x,bessel_inverse_i1_over_i0(bessel_i1_over_i0(x)),eps=5.e-2)
    x+=0.01
  assert approx_equal(bessel_i0(0.0), 1.0)
  assert approx_equal(bessel_i1(0.0), 0.0)
  x=-500.0
  while x <= 500.0:
    a = bessel_i1_over_i0(x)
    b = bessel_i1(x) / bessel_i0(x)
    assert approx_equal(a,b,1.e-5)
    x+=0.01
  x=-100.0
  while x <= 100.0:
    assert approx_equal(bessel_ln_of_i0(x),math.log(bessel_i0(x)))
    x+=0.01

def exercise_eix():
  x = flex.double( range(4000) )/20.0
  expx = flex.exp( -x )
  for xx, ex in zip(x,expx):
    tmp_i0  = bessel_i0(xx)
    tmp_i1  = bessel_i1(xx)
    tmp_ei0 = ei0(xx)
    tmp_ei1 = ei1(xx)
    assert approx_equal(  tmp_i0*ex, tmp_ei0, eps=1e-3 )
    assert approx_equal(  tmp_i1*ex, tmp_ei1, eps=1e-3 )

def exercise_random_cheb_polynome(n_terms,
                             low_limit,
                             high_limit,
                             h=0.00001):
  x = flex.double(range(100))/101.0
  x = x*(high_limit-low_limit) + low_limit
  coefs = flex.random_double(n_terms)
  cheb = chebyshev_polynome(n_terms,
                            low_limit,
                            high_limit,
                            coefs)
  y = cheb.f(x)
  y_tmp = cheb.f(x+h)
  dydx = cheb.dfdx(x)
  for ii in range(100):
    assert approx_equal(dydx[ii], (y_tmp[ii]-y[ii])/h,eps=1e-4)


def exercise_cheb_fitter(n_terms,
                    low_limit,
                    high_limit,
                    h=0.0000001):
  x = flex.double(range(100))/101.0
  x = x*(high_limit-low_limit) + low_limit
  coefs = flex.random_double(n_terms)
  cheb_fitter = chebyshev_fitter(n_terms,
                                 low_limit,
                                 high_limit,
                                 coefs)

  finite_diffs = flex.double(n_terms,0)

  for ii in range(100):
    exact = cheb_fitter.dfdcoefs(x[ii])
    f = cheb_fitter.f(x[ii])
    for jj in range(n_terms):
      coefs[jj]+=h
      cheb_fitter.replace(coefs)
      df = cheb_fitter.f(x[ii])
      coefs[jj]-=h
      finite_diffs[jj] = (df-f)/h
      cheb_fitter.replace(coefs)
      assert approx_equal(exact[jj], finite_diffs[jj])


def exercise_cheb_base_and_polynome():
  x = flex.double(100,0)
  y1 = flex.double(100,0)
  y2 = flex.double(100,0)
  y3 = flex.double(100,0)
  dy1 = flex.double(100,0)
  dy2 = flex.double(100,0)
  dy3 = flex.double(100,0)


  cheb_1_coefs = flex.double([0,1])
  cheb_1 = chebyshev_base(2,-1.,1.,cheb_1_coefs )
  cheb_1_d = chebyshev_polynome(2,-1.,1.,cheb_1_coefs )

  cheb_2_coefs = flex.double([0,0,1])
  cheb_2 = chebyshev_base(3,-1.,1.,cheb_2_coefs )
  cheb_2_d = chebyshev_polynome(3,-1.,1.,cheb_2_coefs )

  cheb_3_coefs = flex.double([0,0,0,1])
  cheb_3 = chebyshev_base(4,-1.,1.,cheb_3_coefs )
  cheb_3_d = chebyshev_polynome(4,-1.,1.,cheb_3_coefs )


  for ii in range(100):
    x[ii] = (ii-50)/51.0

    y1[ii] = x[ii]
    dy1[ii]= 1.0

    y2[ii] = 2.0* x[ii]*x[ii] - 1.0
    dy2[ii]=4.0*x[ii]

    y3[ii] = 4.0*x[ii]*x[ii]*x[ii]-3.0*x[ii]
    dy3[ii] = 12.0*x[ii]*x[ii] - 3.0


  cheb_1_y = cheb_1.f(x)
  cheb_2_y = cheb_2.f(x)
  cheb_3_y = cheb_3.f(x)

  cheb_1_d_y = cheb_1_d.f(x)
  cheb_2_d_y = cheb_2_d.f(x)
  cheb_3_d_y = cheb_3_d.f(x)

  cheb_1_d_ydx = cheb_1_d.dfdx(x)
  cheb_2_d_ydx = cheb_2_d.dfdx(x)
  cheb_3_d_ydx = cheb_3_d.dfdx(x)

  for ii in range(100):
    assert approx_equal(y1[ii],cheb_1_y[ii],eps=1e-4)
    assert approx_equal(y1[ii],cheb_1_d_y[ii],eps=1e-4)
    assert approx_equal(dy1[ii],cheb_1_d_ydx[ii],eps=1e-4)

    assert approx_equal(y2[ii],cheb_2_y[ii],eps=1e-4)
    assert approx_equal(y2[ii],cheb_2_d_y[ii],eps=1e-4)
    assert approx_equal(dy2[ii],cheb_2_d_ydx[ii],eps=1e-4)

    assert approx_equal(y2[ii],cheb_2_y[ii],eps=1e-4)
    assert approx_equal(y2[ii],cheb_2_d_y[ii],eps=1e-4)
    assert approx_equal(dy2[ii],cheb_2_d_ydx[ii],eps=1e-4)

def exercise_cheb_family():
  exercise_cheb_base_and_polynome()
  for ii in range(10):
    exercise_cheb_fitter(5,-1,1,0.00000001)
    exercise_cheb_fitter(5,-10,1,0.00000001)
    exercise_cheb_fitter(5,-10,10,0.00000001)
    exercise_cheb_fitter(8,-1,1,0.00000001)
    exercise_cheb_fitter(8,-10,1,0.00000001)
    exercise_cheb_fitter(8,-10,10,0.00000001)
    exercise_random_cheb_polynome(8, -1.0, 1.0,0.000000001)
    exercise_random_cheb_polynome(5, -1.0, 1.0,0.000000001)
    exercise_random_cheb_polynome(8, 1.0, 10.0,0.000000001)
    exercise_random_cheb_polynome(5, -10.0, 1.0,0.000000001)

def check_lambertw(x):
  w = lambertw(x=x)
  assert eps_eq(w*math.exp(w), x)

def exercise_lambertw():
  check_lambertw(-math.exp(-1)+1.e-4)
  check_lambertw(-1.e-5)
  check_lambertw(0)
  check_lambertw(1.e-5)
  check_lambertw(1-1.e-5)
  check_lambertw(1+1.e-5)
  check_lambertw(3-1.e-5)
  check_lambertw(3+1.e-5)
  for i in range(100):
    check_lambertw(x=i/10.-0.35)
  for i in range(20):
    check_lambertw(x=2.**i)
    check_lambertw(x=5.**i)
    check_lambertw(x=10.**i)
  try: lambertw(x=-math.exp(-1)-1.e-4)
  except RuntimeError as e:
    assert str(e) == "lambertw(x) domain error: x < -exp(-1)"
  else: raise Exception_expected
  try: lambertw(x=1, max_iterations=1)
  except RuntimeError as e:
    assert str(e) == "lambertw error: iteration did not converge"
  else: raise Exception_expected

def matrix_mul(a, ar, ac, b, br, bc):
  assert br == ac
  result = []
  for i in range(ar):
    for k in range(bc):
      s = 0
      for j in range(ac):
        s += a[i * ac + j] * b[j * bc + k]
      result.append(s)
  return result

def exercise_golay():
  weights = [0]*25
  gg = golay_24_12_generator()
  while not gg.at_end():
    weights[list(next(gg)).count(1)] += 1
  assert weights == [1,0,0,0,0,0,0,0,759,0,0,0,2576,0,0,0,759,0,0,0,0,0,0,0,1]
  try:
    next(gg)
  except StopIteration as e:
    assert str(e) == "golay_24_12_generator is exhausted."
  else:
    raise Exception_expected
  weights = [0]*25
  for code in golay_24_12_generator():
    weights[list(code).count(1)] += 1
  assert weights == [1,0,0,0,0,0,0,0,759,0,0,0,2576,0,0,0,759,0,0,0,0,0,0,0,1]

def exercise_inertia_tensor():
  t = inertia_tensor(
    points=flex.vec3_double(), pivot=(0,0,0))
  assert t == (0,0,0,0,0,0)
  t = inertia_tensor(
    points=flex.vec3_double(), weights=flex.double(), pivot=(0,0,0))
  assert t == (0,0,0,0,0,0)
  t = inertia_tensor(
    points=flex.vec3_double([(4,6,2),(2,6,4)]), pivot=(-1,8,4))
  assert approx_equal(t, [12, 38, 42, 16, 10, -4])
  t = inertia_tensor(
    points=flex.vec3_double([(4,6,2),(2,6,4)]),
    weights=flex.double([2,3]),
    pivot=(-1,8,4))
  assert approx_equal(t, [28, 85, 97, 38, 20, -8])

def exercise_principal_axes_of_inertia():
  rnd = random.random
  for i_trial in range(10):
    if (i_trial == 0):
      points = flex.vec3_double()
    elif (i_trial == 1):
      points = flex.vec3_double([[0,0,0]])
    else:
      points = flex.vec3_double([[rnd(),rnd(),rnd()]])
    pai = principal_axes_of_inertia(points=points)
    if (i_trial == 0):
      assert approx_equal(pai.center_of_mass(), [0,0,0])
    else:
      assert approx_equal(pai.center_of_mass(), points[0])
    assert approx_equal(pai.inertia_tensor(), [0,0,0,0,0,0])
    es = pai.eigensystem()
    assert approx_equal(es.values(), [0,0,0])
    assert approx_equal(es.vectors(), [1,0,0,0,1,0,0,0,1])
    assert approx_equal(
      pai.change_of_basis_mx_to_principal(), [1,0,0,0,1,0,0,0,1])
    assert pai.distance_to_inertia_ellipsoid_surface(
      unit_direction=(1,0,0)) == 0
  for i_trial in range(10):
    if (i_trial == 0):
      center_of_mass = [0,0,0]
    else:
      center_of_mass = [rnd(),rnd(),rnd()]
    points = flex.vec3_double(flex.nested_loop([-1,-1,-1], [2,2,2]))
    points += center_of_mass
    pai = principal_axes_of_inertia(points=points)
    assert approx_equal(pai.center_of_mass(), center_of_mass)
    assert approx_equal(pai.inertia_tensor(), [36,36,36,0,0,0])
    es = pai.eigensystem()
    assert approx_equal(es.values(), [36,36,36])
    cp = pai.change_of_basis_mx_to_principal()
    assert approx_equal(matrix.sqr(cp).determinant(), 1)
    vectors = [matrix.col(es.vectors()[i:i+3]) for i in range(3)]
    # testing for specific eigenvectors for the case
    # of degenerate eigenvalues is a bit risky
    paip = principal_axes_of_inertia(points=cp*points)
    assert approx_equal(paip.inertia_tensor(), [36,36,36,0,0,0])
    assert approx_equal(pai.distance_to_inertia_ellipsoid_surface(
      unit_direction=(1,0,0)), 36)
    assert pai.distance_to_inertia_ellipsoid_surface(
      unit_direction=(0,0,0)) == 0
  for i_trial in range(10):
    # test for the case of non-degenerate eigenvalues
    # check that the inertia tensor and eigenvectors
    # transform correctly under rotation
    eps = 1e-12
    if (i_trial == 0):
      center_of_mass = [0,0,0]
      rotation = (1,0,0,0,1,0,0,0,1)
    else:
      center_of_mass = [rnd(),rnd(),rnd()]
      rotation = flex.random_double_r3_rotation_matrix()
    # a parallelepiped
    points = flex.vec3_double([
      (-4,-2,-1), (-3,-2,-1), (-2,-2,-1),
      (-3,-1,-1), (-2,-1,-1), (-1,-1,-1),
      (-2, 0,-1), (-1, 0,-1), ( 0, 0,-1),
      (-2,-1, 0), (-1,-1, 0), ( 0,-1, 0),
      (-1, 0, 0), ( 0, 0, 0), ( 1, 0, 0),
      ( 0, 1, 0), ( 1, 1, 0), ( 2, 1, 0),
      ( 0, 0, 1), ( 1, 0, 1), ( 2, 0, 1),
      ( 1, 1, 1), ( 2, 1, 1), ( 3, 1, 1),
      ( 2, 2, 1), ( 3, 2, 1), ( 4, 2, 1),
      ])
    points = rotation * points
    points += center_of_mass
    pai = principal_axes_of_inertia(points=points)
    es = pai.eigensystem()
    assert approx_equal(pai.center_of_mass(), center_of_mass)
    R = matrix.sqr(rotation)
    R_t = R.transpose()
    assert approx_equal(
      (R_t * matrix.sym(sym_mat3=pai.inertia_tensor()) * R).as_sym_mat3(),
      (54,126,144,-54,-36,-18), eps=eps)
    assert approx_equal(es.values(),
      [156.90386550855695, 154.33160314031173, 12.764531351131396], eps=eps)
    expected_vectors = [
      (-0.44909878511104717, 0.29312841385740002, 0.84402962874606857),
      (-0.29312841385727212, 0.84402962874598531, -0.44909878511128715),
      (0.84402962874611298, 0.4490987851112036, 0.29312841385703242)]
    for i in range(3):
      vec = matrix.col(es.vectors()[3*i:3*(i+1)])
      try:
        assert approx_equal(R_t * vec, expected_vectors[i], eps=eps, out=None)
      except AssertionError:
        # we don't know the direction of the eigenvector
        assert approx_equal(- R_t * vec, expected_vectors[i], eps=eps)
  for i_trial in range(10):
    if (i_trial == 0):
      center_of_mass = [0,0,0]
    else:
      center_of_mass = [rnd(),rnd(),rnd()]
    points = flex.vec3_double()
    for point in flex.nested_loop([-1,-1,-1], [2,2,2]):
      points.append((matrix.col([point[0],point[1]*2,point[2]*3])
                   + matrix.col(center_of_mass)).elems)
    pai = principal_axes_of_inertia(points=points)
    assert approx_equal(pai.center_of_mass(), center_of_mass)
    assert approx_equal(pai.inertia_tensor(), [234,180,90,0,0,0])
    es = pai.eigensystem()
    assert approx_equal(es.values(), [234,180,90])
    if (i_trial == 0):
      assert approx_equal(es.vectors(), [1,0,0,0,1,0,0,0,1])
    else:
      cp = pai.change_of_basis_mx_to_principal()
      assert approx_equal(matrix.sqr(cp).determinant(), 1)
      paip = principal_axes_of_inertia(points=cp*points)
      assert approx_equal(paip.inertia_tensor(), [234,180,90,0,0,0])
  for i_trial in range(10):
    if (i_trial == 0):
      center_of_mass = [0,0,0]
    else:
      center_of_mass = [rnd(),rnd(),rnd()]
    if (i_trial < 2):
      rot = matrix.sqr([1,0,0,0,1,0,0,0,1])
    else:
      rot = euler_angles_as_matrix(
        angles=[random.uniform(0,360) for i in range(3)],
        deg=True)
    points = flex.vec3_double()
    for point in [
      [-1,-1, 0],[-1, 1, 0],
      [ 1,-1, 0],[ 1, 1, 0],
      [-1, 0,-1],[-1, 0, 0],[-1, 0, 1],
      [ 1, 0,-1],[ 1, 0, 0],[ 1, 0, 1],
      [ 0, 0,-1],
      [ 0, 0, 1]]:
      points.append((rot*matrix.col(point)+matrix.col(center_of_mass)).elems)
    pai = principal_axes_of_inertia(points=points)
    assert approx_equal(pai.center_of_mass(), center_of_mass)
    if (i_trial < 2):
      assert approx_equal(pai.inertia_tensor(), [10,16,14,0,0,0])
    es = pai.eigensystem()
    assert approx_equal(es.values(), [16,14,10])
    if (i_trial < 2):
      assert approx_equal(es.vectors(), [0,1,0,0,0,1,1,0,0])
    else:
      cp = pai.change_of_basis_mx_to_principal()
      assert approx_equal(matrix.sqr(cp).determinant(), 1)
      paip = principal_axes_of_inertia(points=cp*points)
      assert approx_equal(paip.inertia_tensor(), [16,14,10,0,0,0])
    assert abs(abs(matrix.col(es.vectors()[0:3]).dot(
                   rot*matrix.col([0,1,0])))-1) < 1.e-3
    assert abs(abs(matrix.col(es.vectors()[3:6]).dot(
                   rot*matrix.col([0,0,1])))-1) < 1.e-3
    assert abs(abs(matrix.col(es.vectors()[6:9]).dot(
                   rot*matrix.col([1,0,0])))-1) < 1.e-3
    weights = flex.double(points.size(), 1)
    points_plus = points.deep_copy()
    for i_p in [0,3,5,5,9,10,10,10]:
      points_plus.append(points[i_p])
      weights[i_p] += 1
    paip = principal_axes_of_inertia(points=points_plus)
    paiw = principal_axes_of_inertia(points=points, weights=weights)
    assert approx_equal(paip.center_of_mass(), paiw.center_of_mass())
    assert approx_equal(paip.inertia_tensor(), paiw.inertia_tensor())

def exercise_principal_axes_of_inertia_2d():
  rnd = random.random
  for i_trial in range(10):
    if (i_trial == 0):
      points = flex.vec2_double()
    elif (i_trial == 1):
      points = flex.vec2_double([[0,0]])
    else:
      points = flex.vec2_double([[rnd(),rnd()]])
    pai = principal_axes_of_inertia_2d(points=points)
    if (i_trial == 0):
      assert approx_equal(pai.center_of_mass(), [0,0])
    else:
      assert approx_equal(pai.center_of_mass(), points[0])
    assert approx_equal(pai.inertia_tensor(), [0,0,0])
    es = pai.eigensystem()
    assert approx_equal(es.values(), [0,0])
    assert approx_equal(es.vectors(), [1,0,0,1])
    assert pai.distance_to_inertia_ellipsoid_surface(
      unit_direction=(1,0)) == 0
  for i_trial in range(10):
    if (i_trial == 0):
      center_of_mass = [0,0]
    else:
      center_of_mass = [rnd(),rnd()]
    points = flex.vec2_double()
    for point in flex.nested_loop([-1,-1], [2,2]):
      points.append((matrix.col(point) + matrix.col(center_of_mass)).elems)
    pai = principal_axes_of_inertia_2d(points=points)
    assert approx_equal(pai.center_of_mass(), center_of_mass)
    assert approx_equal(pai.inertia_tensor(), [6,6,0])
    es = pai.eigensystem()
    assert approx_equal(es.values(), [6,6])
    if (i_trial == 0):
      assert approx_equal(es.vectors(), [1,0,0,1])
    assert approx_equal(pai.distance_to_inertia_ellipsoid_surface(
      unit_direction=(1,0)), 6)
    assert pai.distance_to_inertia_ellipsoid_surface(
      unit_direction=(0,0)) == 0
  for i_trial in range(10):
    if (i_trial == 0):
      center_of_mass = [0,0]
    else:
      center_of_mass = [rnd(),rnd()]
    points = flex.vec2_double()
    for point in flex.nested_loop([-1,-1], [2,2]):
      points.append((matrix.col([point[0],point[1]*2])
                   + matrix.col(center_of_mass)).elems)
    pai = principal_axes_of_inertia_2d(points=points)
    assert approx_equal(pai.center_of_mass(), center_of_mass)
    assert approx_equal(pai.inertia_tensor(), [24,6,0])
    es = pai.eigensystem()
    assert approx_equal(es.values(), [24,6])
    if (i_trial == 0):
      assert approx_equal(es.vectors(), [1,0,0,1])
  for i_trial in range(10):
    if (i_trial == 0):
      center_of_mass = [0,0]
    else:
      center_of_mass = [rnd(),rnd()]
    if (i_trial < 2):
      rot = matrix.sqr([1,0,0,1])
    else:
      rot = euler_angles_as_matrix(
        angles=[random.uniform(0,360),0,0],
        deg=True)
      rot = matrix.sqr([rot.elems[k] for k in [0,1,3,4]])
      theta = random.uniform(0,360)
      csth = math.cos(theta); snth = math.sin(theta)
      rot = matrix.sqr([csth,snth, -snth, csth])
    points = flex.vec2_double()
    for point in [
      [-1,-1],[-1, 1],
      [ 1,-1],[ 1, 1],
      [-1, 0],[ 1, 0],
      [ 0,-1],[ 0, 1],[1,0],[-1,0]]:
      points.append((rot*matrix.col(point)+matrix.col(center_of_mass)).elems)
    pai = principal_axes_of_inertia_2d(points=points)
    assert approx_equal(pai.center_of_mass(), center_of_mass)
    if (i_trial < 2):
      assert approx_equal(pai.inertia_tensor(), [6,8,0])
    es = pai.eigensystem()
    assert approx_equal(es.values(), [8,6])
    if (i_trial < 2):
      assert approx_equal(es.vectors(), [0,1,1,0])
    assert abs(abs(matrix.col(es.vectors()[0:2]).dot(
                   rot*matrix.col([0,1])))-1) < 1.e-3
    assert abs(abs(matrix.col(es.vectors()[2:4]).dot(
                   rot*matrix.col([1,0])))-1) < 1.e-3
    weights = flex.double(points.size(), 1)
    points_plus = points.deep_copy()
    for i_p in [0,2,3,4,5,7,7,7]:
      points_plus.append(points[i_p])
      weights[i_p] += 1
    paip = principal_axes_of_inertia_2d(points=points_plus)
    paiw = principal_axes_of_inertia_2d(points=points, weights=weights)
    assert approx_equal(paip.center_of_mass(), paiw.center_of_mass())
    assert approx_equal(paip.inertia_tensor(), paiw.inertia_tensor())

def explore_inertia_tensor_properties(n_trials=10):
  points = flex.vec3_double([
    (-1,0,0),
    (1,0,0),
    (0,-1,0),
    (0,1,0),
    (0,0,-1),
    (0,0,1)])
  weights = flex.double([2,2,3,3,7,7])
  pai = scitbx.math.principal_axes_of_inertia(
    points=points,
    weights=weights)
  es = pai.eigensystem()
  #
  mt = flex.mersenne_twister(seed=0)
  for i_trial in range(n_trials):
    rot_axis = matrix.col(mt.random_double_point_on_sphere())
    rot_angle = 10 + mt.random_double() * 77
    rot_matrix = scitbx.math.r3_rotation_axis_and_angle_as_matrix(
      axis=rot_axis, angle=rot_angle, deg=True)
    #
    rot_points = rot_matrix * points
    rot_pai = scitbx.math.principal_axes_of_inertia(
      points=rot_points,
      weights=weights)
    rot_es = rot_pai.eigensystem()
    #
    c = matrix.sqr(rot_matrix).inverse()
    e = matrix.sym(sym_mat3=rot_pai.inertia_tensor())
    # this proves the transformation law for the inertia tensor
    assert approx_equal(
      (c * e * c.transpose()).as_sym_mat3(),
      pai.inertia_tensor())
    #
    for j_trial in range(n_trials):
      v = matrix.col(mt.random_double_point_on_sphere())
      rot_v = matrix.sqr(rot_matrix) * v
      #
      # most intuitive approach (for rwgk)
      def es_distance_to_ellipsoid_surface(es, v):
        assert min(es.values()) > 0
        a,b,c = es.values()
        x,y,z = matrix.sqr(es.vectors()) * v # transform v to eigenvector basis
        # http://mathworld.wolfram.com/Ellipsoid.html
        f = 1/math.sqrt(x*x/(a*a)+y*y/(b*b)+z*z/(c*c))
        return f
      #
      # alternative approach without involving the eigensystem
      def it_distance_to_ellipsoid_surface(inertia_tensor, v):
        iv = matrix.sym(sym_mat3=inertia_tensor).inverse() * v
        return 1/math.sqrt(iv.dot(iv))
      #
      # proves that the intuitive approach works
      d0 = es_distance_to_ellipsoid_surface(es, v)
      d = es_distance_to_ellipsoid_surface(rot_es, rot_v)
      # proves that the alternative approach yields the same results
      assert approx_equal(d, d0)
      d = it_distance_to_ellipsoid_surface(pai.inertia_tensor(), v)
      assert approx_equal(d, d0)
      d = it_distance_to_ellipsoid_surface(rot_pai.inertia_tensor(), rot_v)
      assert approx_equal(d, d0)
      # exercise C++ implementation
      d = pai.distance_to_inertia_ellipsoid_surface(unit_direction=v)
      assert approx_equal(d, d0)
      d = rot_pai.distance_to_inertia_ellipsoid_surface(unit_direction=rot_v)
      assert approx_equal(d, d0)

def exercise_phase_error():
  for deg in [False, True]:
    if (deg): f = 1
    else: f = math.pi/180
    assert approx_equal(signed_phase_error(phi1=-30*f, phi2=270*f, deg=deg),
      -60*f)
    assert approx_equal(signed_phase_error(phi1=330*f, phi2=630*f, deg=deg),
      -60*f)
    assert approx_equal(phase_error(phi1=330*f, phi2=630*f, deg=deg),
      60*f)
    assert approx_equal(nearest_phase(reference=-30*f, other=335*f, deg=deg),
      -25*f)
    assert approx_equal(signed_phase_error(
      phi1=flex.double([-30*f]),
      phi2=flex.double([270*f]), deg=deg), [-60*f])
    assert approx_equal(phase_error(
      phi1=flex.double([-30*f]),
      phi2=flex.double([270*f]), deg=deg), [60*f])
    assert approx_equal(nearest_phase(
      reference=flex.double([-30*f]),
      other=flex.double([345*f]), deg=deg), [-15*f])

def exercise_row_echelon():
  m = flex.int((1,1,1,1))
  m.reshape(flex.grid(2,2))
  t = flex.int((2,3))
  t.reshape(flex.grid(2,1))
  assert scitbx.math.row_echelon_form_t(m, t) == 1
  assert m.focus() == (1,2)
  assert tuple(m) == (1,1)
  assert tuple(t) == (2,1)
  assert scitbx.math.row_echelon_form(m) == 1
  assert m.focus() == (1,2)
  assert tuple(m) == (1,1)
  m = flex.int((0,-24,0,0,0,-24,24,0,24))
  m.reshape(flex.grid(3,3))
  t = flex.int((-3, -6, 0))
  t.reshape(flex.grid(3,1))
  assert scitbx.math.row_echelon_form_t(m, t) == 3
  assert tuple(m) == (24,0,24,0,24,0,0,0,24)
  assert tuple(t) == (0,3,6)
  t.reshape(flex.grid(3))
  sol = flex.int(3)
  assert scitbx.math.row_echelon_back_substitution_int(m, t, sol) == 8
  assert tuple(sol) == (-2,1,2)
  indep = flex.bool((True,True,True))
  assert scitbx.math.row_echelon_back_substitution_int(
    row_echelon_form=m, independent_flags=indep) == 1
  assert tuple(indep) == (False,False,False)
  #
  for n_cols in range(1,5):
    for n_rows in range(5):
      for i_trial in range(10):
        m = flex.int()
        for i in range(n_rows):
          coeffs = flex.int([random.randrange(-5,5) for j in range(n_cols)])
          m.extend(coeffs)
        m.reshape(flex.grid(n_rows,n_cols))
        rank = scitbx.math.row_echelon_form(m)
        assert m.focus()[0] == rank
        assert m.focus()[1] == n_cols
        indep = flex.bool(n_cols, True)
        scitbx.math.row_echelon_back_substitution_int(
          row_echelon_form=m, independent_flags=indep)
        mm = matrix.rec(m, m.focus())
        s = matrix.col([random.random() for j in range(n_cols)])
        sol = flex.double(n_cols, 0)
        sol.set_selected(indep, flex.double(s).select(indep))
        assert scitbx.math.row_echelon_back_substitution_float(
          row_echelon_form=m, solution=sol, v=flex.double(mm * s))
        assert approx_equal(sol, s)
        sol = flex.double(n_cols, 0)
        sol.set_selected(indep, flex.double(s).select(indep))
        assert scitbx.math.row_echelon_back_substitution_float(
          row_echelon_form=m, solution=sol)
        zeros = mm * matrix.col(sol)
        assert approx_equal(zeros, [0]*rank)

def exercise_row_echelon_full_pivoting():
  refp = scitbx.math.row_echelon_full_pivoting
  #
  m = flex.double([
    [ 1,  2,  3,  4,  5,  6],
    [-1, -3,  1,  2, -1,  3],
    [ 2,  1, -1,  3,  4,  2]])
  m_inp = matrix.rec(m, m.all())
  v = [0]*6
  for j in range(6):
    for i in range(3):
      v[j] += m[i,j]
  e = refp(a_work=m)
  assert list(e.col_perm) == [5, 1, 4, 3, 2, 0]
  assert e.rank == 3
  assert e.nullity == 3
  assert m.all() == (3,6)
  # Is v in the vector space spanned by the rows of m?
  assert e.is_in_row_space(x=flex.double(v), epsilon=1e-15)
  # After that modification, v should not be in that span anymore
  v[2] += 1e-8
  assert not e.is_in_row_space(x=flex.double(v), epsilon=1e-15)
  s = e.back_substitution(free_values=flex.double([1,2,3]))
  assert approx_equal(s, [
    3.0, -0.42857142857142849, 2.0,
    1.0, -1.0816326530612246, -1.1224489795918366])
  assert approx_equal(m_inp * matrix.col(s), [0,0,0])
  #
  # Let's test with a row rank deficient matrix m now
  m = flex.double([
    [ 1,  2,  3,  4,  5,  6],
    [-1, -3,  1,  2, -1,  3],
    [ 2,  1,  7, 10,  9, 15]])
  m_inp = matrix.rec(m, m.all())
  v = [0]*6
  for j in range(6):
    m[2,j] =   m[1,j] + 2*m[0,j]
    v[j]   = 2*m[1,j] +   m[0,j]
  e = refp(a_work=m, min_abs_pivot=1e-15)
  assert list(e.col_perm) == [5, 1, 2, 3, 4, 0]
  assert e.rank == 2
  assert e.nullity == 4
  assert e.is_in_row_space(x=flex.double(v), epsilon=1e-15)
  v[4] += 1e-9
  assert not e.is_in_row_space(x=flex.double(v), epsilon=1e-15)
  s = e.back_substitution(free_values=flex.double([-3,1,4,-2]))
  assert approx_equal(s, [-2.0, -2.3749999999999991, -3.0, 1.0, 4.0, -1.375])
  assert approx_equal(m_inp * matrix.col(s), [0,0,-2])
  #
  try: refp(a_work=flex.double())
  except RuntimeError as e:
    assert str(e) == "a_work matrix must be two-dimensional."
  else: raise Exception_expected
  for v in [0,1,-1]:
    for nr in range(5):
      for nc in range(5):
        a = flex.double(flex.grid(nr, nc), v)
        e = refp(a_work=a)
        assert e.rank == min(abs(v), nr, nc)
        assert e.nullity == nc - e.rank
        a = flex.double(flex.grid(nr, nc), v)
        b = flex.double(nr)
        e = refp(a_work=a, b_work=b)
        assert e.rank == min(abs(v), nr, nc)
        assert e.nullity == nc - e.rank
  #
  mt = flex.mersenne_twister(seed=0)
  for i_trial in range(10):
    for nr in range(1,5):
      for nc in range(1,5):
        a = mt.random_double(size=nr*nc)*2-1
        a.reshape(flex.grid(nr, nc))
        x = mt.random_double(size=nc)*2-1
        b = a.matrix_multiply(x)
        aw = a.deep_copy()
        bw = b.deep_copy()
        e = refp(a_work=aw, b_work=bw)
        assert e.rank == min(nr, nc) # assumes (random) linear indepence
        assert e.nullity == nc - e.rank
        for v in [0,1,-1]:
          ex = e.back_substitution(
            free_values=flex.double(e.nullity, v),
            epsilon=1e-10)
          assert ex is not None
          assert ex.size() == nc
          eb = a.matrix_multiply(ex)
          assert approx_equal(eb, b)
        ex = e.back_substitution(
          free_values=x.select(flex.size_t(iter(e.col_perm[e.rank:]))),
          epsilon=1e-10)
        assert approx_equal(ex, x)
  #
  a = flex.double([
    [1, 2,  ],
    [1, 1.99],
    [1, 1.98 ]])
  aw = a.deep_copy()
  e = refp(a_work=aw)
  assert approx_equal(aw, [2, 1, 0, 0.01, 0, 0])
  assert e.rank == 2
  aw = a.deep_copy()
  e = refp(a_work=aw, min_abs_pivot=0.1)
  assert e.rank == 1
  assert approx_equal(aw, [2, 1, 0, 0.005, 0, 0.01])
  aw_rank_1 = aw
  aw = a.deep_copy()
  e = refp(a_work=aw, max_rank=1)
  assert e.rank == 1
  assert approx_equal(aw, aw_rank_1)
  aw = a.deep_copy()
  e = refp(a_work=aw, max_rank=0)
  assert e.rank == 0
  assert approx_equal(aw, a)
  #
  n_no_solution_with_epsilon_zero = 0
  for singular_a,rank in [
        ((3,0,0,0,-2,0,0,0,0), 2),
        ((0,0,3,0,0,0,0,0,0), 1),
        ((0,0,0,1e-15,0,0,0,0,0), 0)]:
    for i_trial in range(10):
      r = matrix.sqr(mt.random_double_r3_rotation_matrix())
      a = flex.double(r * matrix.sqr(singular_a) * r.transpose())
      a.reshape(flex.grid(3,3))
      assert approx_equal(a.matrix_determinant_via_lu(), 0, eps=1e-12)
      x = flex.double([4.3,-2.1,8.2])
      b = a.matrix_multiply(x)
      aw = a.deep_copy()
      bw = b.deep_copy()
      e = refp(a_work=aw, b_work=bw, min_abs_pivot=1e-12)
      assert e.rank == rank
      ex = e.back_substitution(
        free_values=flex.double(e.nullity, 9.3),
        epsilon=1e-12)
      assert ex is not None
      eb = a.matrix_multiply(ex)
      assert approx_equal(eb, b)
      ex = e.back_substitution(free_values=flex.double(e.nullity, 0))
      if (ex is None): n_no_solution_with_epsilon_zero += 1
  assert n_no_solution_with_epsilon_zero > 20
  #
  # http://www.mathworks.com/access/helpdesk/help/techdoc/ref/pinv.html
  #   2008-12-01
  a = flex.double([float(v) for v in """
    64     2     3    61    60     6
     9    55    54    12    13    51
    17    47    46    20    21    43
    40    26    27    37    36    30
    32    34    35    29    28    38
    41    23    22    44    45    19
    49    15    14    52    53    11
     8    58    59     5     4    62""".split()])
  a.reshape(flex.grid(8,6))
  b = flex.double(8, 260)
  aw = a.deep_copy()
  bw = b.deep_copy()
  e = scitbx.math.row_echelon_full_pivoting(
    a_work=aw, b_work=bw, min_abs_pivot=1e-12)
  assert e.rank == 3
  x = e.back_substitution(free_values=flex.double(e.nullity), epsilon=1e-12)
  assert approx_equal(a.matrix_multiply(x), b)
  assert approx_equal(sorted(x), [-1,0,0,0,4,5])

def exercise_solve_a_x_eq_b_min_norm_given_a_sym_b_col():
  def girs(a, relative_min_abs_pivot=1e-12, absolute_min_abs_pivot=0):
    es = scitbx.linalg.eigensystem.real_symmetric(
      m=a,
      relative_epsilon=relative_min_abs_pivot,
      absolute_epsilon=absolute_min_abs_pivot)
    return es.generalized_inverse_as_packed_u().matrix_packed_u_as_symmetric()
  mt = flex.mersenne_twister(seed=0)
  for bits in range(8):
    d = [1.23, 2.34, 0.58]
    x = [-0.19, -0.44, 0.83]
    if (bits    % 2): d[0] = x[0] = 0
    if (bits//2 % 2): d[1] = x[1] = 0
    if (bits//4 % 2): d[2] = x[2] = 0
    a = matrix.diag(d)
    x = matrix.col(x)
    b = a * x
    xs = scitbx.math.solve_a_x_eq_b_min_norm_given_a_sym_b_col(a=a, b=b)
    assert approx_equal(xs, x)
    for i_trial in range(10):
      if (i_trial == 0):
        r = matrix.identity(n=3)
      else:
        r = matrix.sqr(mt.random_double_r3_rotation_matrix())
      ar = r * a * r.transpose()
      xr = r * x
      br = r * b
      assert approx_equal(ar * xr, br)
      xs = scitbx.math.solve_a_x_eq_b_min_norm_given_a_sym_b_col(a=ar, b=br)
      assert approx_equal(xs, xr)
      #
      ari = matrix.sqr(girs(a=ar.as_flex_double_matrix()))
      assert approx_equal(ari * br, xr)
      #
      if (tntbx is not None):
        arit = tntbx.generalized_inverse(ar.as_flex_double_matrix())
        xs = matrix.sqr(arit) * br
        assert approx_equal(xs, xr)
        assert approx_equal(ari, arit)
  #
  a = flex.double([[1e-15]])
  b = flex.double([1e-14])
  x = scitbx.math.solve_a_x_eq_b_min_norm_given_a_sym_b_col(a=a, b=b)
  assert approx_equal(x, [10])
  ai = matrix.sqr(girs(a=a))
  x = ai * matrix.col(b)
  assert approx_equal(x, [10])
  assert a[0] == 1e-15
  assert b[0] == 1e-14
  x = scitbx.math.solve_a_x_eq_b_min_norm_given_a_sym_b_col(a=a, b=b,
    absolute_min_abs_pivot=1e-12)
  assert x[0] == 0
  ai = matrix.sqr(girs(a=a, absolute_min_abs_pivot=1e-12))
  x = ai * matrix.col(b)
  assert x[0] == 0
  b[0] = 1e-10
  x = scitbx.math.solve_a_x_eq_b_min_norm_given_a_sym_b_col(a=a, b=b,
    absolute_min_abs_pivot=1e-12)
  assert x is None
  #
  def compare(a, n_trials):
    for i_trial in range(n_trials):
      if (i_trial == 0):
        ar = a
      else:
        r = matrix.sqr(mt.random_double_r3_rotation_matrix())
        ar = r * a * r.transpose()
      ari = matrix.sqr(girs(
        a=ar.as_flex_double_matrix(), absolute_min_abs_pivot=1.e-12))
      if (tntbx is not None):
        arit = matrix.sqr(
          tntbx.generalized_inverse(ar.as_flex_double_matrix()))
        mismatch = (ari-arit).norm_sq() / max(1, max([abs(e) for e in ari]))
        if (mismatch > 1e-10):
          print(ar.elems)
          print(ari.elems)
          print(arit.elems)
          raise AssertionError(mismatch)
  for i_trial in range(10):
    x,y,z = flex.random_double(size=3)*2-1
    a = matrix.sqr([
      x,y,x,
      y,z,y,
      x,y,x])
    compare(a, n_trials=10)

def exercise_tensor_rank_2():
  g = (2,3,5,0.2,0.3,0.5)
  assert approx_equal(scitbx.math.tensor_rank_2_gradient_transform(
    a=(1,0,0,0,1,0,0,0,1), g=g), g)
  a = (-0.00266542,0.386546, 0.22833,
        0.263694, -0.660647, 0.896465,
        0.888726, -0.996946,-0.521507)
  assert approx_equal(matrix.sqr(a).determinant(), 0.431857368657)
  ga = scitbx.math.tensor_rank_2_gradient_transform(a=a, g=g)
  assert approx_equal(ga,
    [4.2741119386687805, 6.7403365850628001, 3.6465242980395001,
     -10.209907479357136, -2.8163934767020788, 1.6344744599549008])
  gtmx = scitbx.math.tensor_rank_2_gradient_transform_matrix(a=a)
  assert gtmx.focus() == (6,6)
  assert approx_equal(gtmx.matrix_multiply(flex.double(g)), ga)

def exercise_minimum_covering_sphere(epsilon=1.e-3):
  s3 = sphere_3d(center=[1,2,3], radius=4)
  assert approx_equal(s3.center(), [1,2,3])
  assert approx_equal(s3.radius(), 4)
  s3 = s3.expand(additional_radius=2)
  assert approx_equal(s3.center(), [1,2,3])
  assert approx_equal(s3.radius(), 6)
  assert approx_equal(
    s3.expand_relative(additional_relative_radius=0.1).radius(), 6.6)
  assert s3.is_inside(point=[1,2,3])
  assert s3.is_inside(point=[1,2,3+6-1.e-6])
  assert not s3.is_inside([1,2,3+6+1.e-6])
  assert approx_equal(s3.box_min(), [1-6,2-6,3-6])
  assert approx_equal(s3.box_max(), [1+6,2+6,3+6])
  for i_impl,mcs_impl in enumerate([scitbx.math.minimum_covering_sphere_3d,
                                    scitbx.math.minimum_covering_sphere_nd]):
    def wrap_points(points):
      if (i_impl == 0): return flex.vec3_double(points)
      return [matrix.col(point) for point in points]
    points = wrap_points([])
    mcs = mcs_impl(points=points)
    assert mcs.n_iterations() == 0
    assert approx_equal(mcs.center(), (0,0,0))
    assert approx_equal(mcs.radius(), 1)
    if (i_impl == 0):
      assert mcs.is_inside(mcs.center()) # base class method
    mcs = mcs_impl(
      points=points,
      epsilon=1.e-6,
      radius_if_one_or_no_points=3,
      center_if_no_points=(2,3,5))
    assert mcs.n_iterations() == 0
    assert approx_equal(mcs.center(), (2,3,5))
    assert approx_equal(mcs.radius(), 3)
    points = wrap_points([(3,4,5)])
    mcs = mcs_impl(
      points=points,
      epsilon=1.e-6,
      radius_if_one_or_no_points=5,
      center_if_no_points=(2,3,5))
    assert mcs.n_iterations() == 0
    assert approx_equal(mcs.center(), (3,4,5))
    assert approx_equal(mcs.radius(), 5)
    points = wrap_points([(0,0,0),(1,0,0),(0,1,0),(1,1,1)])
    mcs = mcs_impl(points=points)
    assert mcs.n_iterations() > 0
    assert approx_equal(mcs.center(), (0.5,0.5,0.5), eps=1.e-3)
    assert approx_equal(mcs.radius(), math.sqrt(3)/2, eps=1.e-5)
  eps = epsilon*10
  eps_loose = eps*10
  for i,j,k in flex.nested_loop((1,1,1),(2,3,2),False):
    for shift in [(0,0,0),(2,3,4),(-3,-5,2)]:
      for poly_index in range(1,2):
        if (poly_index == 0):
          # cube
          points = flex.vec3_double(
            [(matrix.col(t)+matrix.col(shift)).elems for t in [
            (0,0,0),
            (0,0,k),
            (0,j,0),
            (0,j,k),
            (i,0,0),
            (i,0,k),
            (i,j,0),
            (i,j,k)]])
          expected_center = (matrix.col(shift) + matrix.col([i,j,k])/2.).elems
          expected_radius = math.sqrt(i**2+j**2+k**2)/2
        else:
          # tetrahedron
          z = 1/math.sqrt(2)*k
          points = flex.vec3_double(
            [(matrix.col(t)/2.+matrix.col(shift)).elems for t in [
            (-i,0,z),
            (i,0,z),
            (0,-j,-z),
            (0,j,-z)]])
          if (i == j and j == k):
            expected_center = shift
            expected_radius = max(
              [abs(matrix.col(points[0])-matrix.col(shift))
                for point in points])
          else:
            expected_center = None
            expected_radius = None
        mcs = minimum_covering_sphere(points, epsilon=epsilon)
        if (expected_center is None):
          expected_center = mcs.center()
          expected_radius = mcs.radius()
        assert approx_equal(mcs.center(), expected_center, eps=eps)
        assert approx_equal(mcs.radius(), expected_radius, eps=eps)
        if (poly_index == 0):
          assert mcs.n_iterations() == 0
        points.append(expected_center)
        mcs = minimum_covering_sphere(points, epsilon=epsilon)
        assert approx_equal(mcs.center(), expected_center, eps=eps)
        assert approx_equal(mcs.radius(), expected_radius, eps=eps)
        if (poly_index == 0):
          assert mcs.n_iterations() <= 1
        r = random.random
        for i_addl in range(3):
          points.append(
            (matrix.col(expected_center)
             + matrix.col([r(),r(),r()]).normalize()*expected_radius).elems)
          mcs = minimum_covering_sphere(points, epsilon=epsilon)
          assert approx_equal(mcs.center(), expected_center, eps=eps_loose)
          assert approx_equal(mcs.radius(), expected_radius, eps=eps)
        # also exercise the Python implementation
        mcs = minimum_covering_sphere(
          points=[matrix.col(point) for point in points],
          epsilon=epsilon)
        assert approx_equal(mcs.center(), expected_center, eps=eps_loose)
        assert approx_equal(mcs.radius(), expected_radius, eps=eps)
  # exercise Python implementation with sets of 2-dimensional points
  for i,j in flex.nested_loop((1,1),(2,3),False):
    for shift in [(0,0),(3,4),(-3,-5)]:
      # square
      points = [matrix.col(t)+matrix.col(shift) for t in [
        (0,0),
        (0,j),
        (i,0),
        (i,j)]]
      expected_center = (matrix.col(shift) + matrix.col([i,j])/2.).elems
      expected_radius = math.sqrt(i**2+j**2)/2
      mcs = minimum_covering_sphere(points, epsilon=epsilon)
      if (expected_center is None):
        expected_center = mcs.center()
        expected_radius = mcs.radius()
      assert approx_equal(mcs.center(), expected_center, eps=eps)
      assert approx_equal(mcs.radius(), expected_radius, eps=eps)
      assert mcs.n_iterations() == 0
      points.append(matrix.col(expected_center))
      mcs = minimum_covering_sphere(points, epsilon=epsilon)
      assert approx_equal(mcs.center(), expected_center, eps=eps)
      assert approx_equal(mcs.radius(), expected_radius, eps=eps)
      assert mcs.n_iterations() <= 1
      r = random.random
      for i_addl in range(3):
        points.append(
          matrix.col(expected_center)
          + matrix.col([r(),r()]).normalize()*expected_radius)
        mcs = minimum_covering_sphere(points, epsilon=epsilon)
        assert approx_equal(mcs.center(), expected_center, eps=eps_loose)
        assert approx_equal(mcs.radius(), expected_radius, eps=eps)

def exercise_icosahedron():
  ico = icosahedron(level=0)
  for level in range(6):
    ico = icosahedron(level=level)
    assert ico.level == level
    if (level == 0):
      assert ico.sites.size() == 12
    else:
      assert ico.sites.size() == 80 * 4**(level-1)
    assert approx_equal(ico.sites.mean(), [0,0,0])
    assert approx_equal(ico.sites.dot(), [1]*ico.sites.size())
    d = ico.next_neighbors_distance()
    m = flex.min((ico.sites[1:] - ico.sites[0]).dot())**0.5
    if (level == 0):
      assert approx_equal(d, m)
    else:
      assert d > m
      assert d/2 < m

def exercise_basic_statistics():
  x = flex.double([])
  s = scitbx.math.basic_statistics(values=x)
  assert s.n == 0
  assert approx_equal(s.min, -1)
  assert approx_equal(s.max, -1)
  assert approx_equal(s.max_absolute, -1)
  assert approx_equal(s.sum, -1)
  assert approx_equal(s.mean, -1)
  assert approx_equal(s.mean_absolute_deviation_from_mean, -1)
  assert approx_equal(s.biased_variance, -1)
  assert approx_equal(s.biased_standard_deviation, -1)
  assert approx_equal(s.bias_corrected_variance, -1)
  assert approx_equal(s.bias_corrected_standard_deviation, -1)
  assert approx_equal(s.skew, -1)
  assert approx_equal(s.kurtosis, -1)
  assert approx_equal(s.kurtosis_excess, -1)
  x = flex.double([-7])
  s = scitbx.math.basic_statistics(values=x)
  assert s.n == 1
  assert approx_equal(s.min, -7)
  assert approx_equal(s.max, -7)
  assert approx_equal(s.max_absolute, 7)
  assert approx_equal(s.sum, -7)
  assert approx_equal(s.mean, -7)
  assert approx_equal(s.mean_absolute_deviation_from_mean, 0)
  assert approx_equal(s.biased_variance, 0)
  assert approx_equal(s.biased_standard_deviation, 0)
  assert approx_equal(s.bias_corrected_variance, -1)
  assert approx_equal(s.bias_corrected_standard_deviation, -1)
  assert approx_equal(s.skew, -1)
  assert approx_equal(s.kurtosis, -1)
  assert approx_equal(s.kurtosis_excess, -1)
  x = flex.double([1,2,3,4,5])
  s = scitbx.math.basic_statistics(values=x)
  assert s.n == 5
  assert approx_equal(s.min, 1)
  assert approx_equal(s.max, 5)
  assert approx_equal(s.max_absolute, 5)
  assert approx_equal(s.sum, 15)
  assert approx_equal(s.mean, 3)
  assert approx_equal(s.mean_absolute_deviation_from_mean, 1.2)
  assert approx_equal(s.biased_variance, 2)
  assert approx_equal(s.biased_standard_deviation, math.sqrt(2))
  assert approx_equal(s.bias_corrected_variance, 2.5)
  assert approx_equal(s.bias_corrected_standard_deviation, math.sqrt(2.5))
  assert approx_equal(s.skew, 0)
  assert approx_equal(s.kurtosis, 1.7)
  assert approx_equal(s.kurtosis_excess, -1.3)
  x = flex.double([1,1,1])
  s = scitbx.math.basic_statistics(values=x)
  assert s.n == 3
  assert approx_equal(s.min, 1)
  assert approx_equal(s.max, 1)
  assert approx_equal(s.max_absolute, 1)
  assert approx_equal(s.sum, 3)
  assert approx_equal(s.mean, 1)
  assert approx_equal(s.mean_absolute_deviation_from_mean, 0)
  assert approx_equal(s.biased_variance, 0)
  assert approx_equal(s.biased_standard_deviation, 0)
  assert approx_equal(s.bias_corrected_variance, 0)
  assert approx_equal(s.bias_corrected_standard_deviation, math.sqrt(0))
  assert approx_equal(s.skew, -1)
  assert approx_equal(s.kurtosis, -1)
  assert approx_equal(s.kurtosis_excess, -1)
  f = StringIO()
  s.show(f=f)
  assert len(f.getvalue().splitlines()) == 14
  for i_trial in range(10):
    x = flex.random_double(size=2+int(random.random()*10))
    s = scitbx.math.basic_statistics(values=x)
    assert s.n == x.size()
    assert approx_equal(s.min, flex.min(x))
    assert approx_equal(s.max, flex.max(x))
    assert approx_equal(s.max_absolute, max(-flex.min(x), flex.max(x)))
    assert approx_equal(s.sum, flex.sum(x))
    assert approx_equal(s.mean, flex.mean(x))
    d = x-flex.mean(x)
    assert approx_equal(s.mean_absolute_deviation_from_mean,
      flex.mean(flex.abs(d)))
    assert approx_equal(s.biased_variance, flex.sum(d*d) / s.n)
    assert approx_equal(s.biased_standard_deviation,
      math.sqrt(s.biased_variance))
    assert approx_equal(s.bias_corrected_variance,
      flex.sum(flex.pow2(d)) / (s.n-1))
    assert approx_equal(s.bias_corrected_standard_deviation,
      math.sqrt(s.bias_corrected_variance))
    assert approx_equal(s.skew,
      (flex.sum(d*d*d)/s.n) / (flex.sum(d*d)/s.n)**(3/2.))
    assert approx_equal(s.kurtosis,
      (flex.sum(d*d*d*d)/s.n) / (flex.sum(d*d)/s.n)**2)
    assert approx_equal(s.kurtosis_excess, s.kurtosis-3)

def exercise_median():
  from scitbx.math import median_statistics

  try:
    median_statistics(flex.double())
  except RuntimeError:
    pass
  else:
    raise Exception_expected

  stats = median_statistics(flex.double((1,)))
  assert stats.median == 1
  assert stats.median_absolute_deviation == 0

  for i in range(5):
    stats = median_statistics(flex.double((5, 1)))
    assert stats.median == 3
    assert stats.median_absolute_deviation == 2

  for i in range(5):
    stats = median_statistics(flex.double((5, 1, 2)))
    assert stats.median == 2
    assert stats.median_absolute_deviation == 1

  data = flex.double((1, 1, 2, 2, 4, 6, 9))
  for i in range(10):
    data_ = data.select(flex.random_permutation(len(data)))
    stats = median_statistics(data_)
    assert stats.median == 2
    assert stats.median_absolute_deviation == 1

  data = flex.double((1, 1, 2, 4, 6, 9))
  for i in range(10):
    data_ = data.select(flex.random_permutation(len(data)))
    stats = median_statistics(data_)
    assert stats.median == 3
    assert stats.median_absolute_deviation == 2

def exercise_slatec_dlngam():
  def cmp(a, b):
    if (abs(a) < 1):
      assert approx_equal(a, b, eps=1.e-10)
    else:
      assert approx_equal((a-b)/(abs(a+b)), 0, eps=1.e-10)
  try: slatec_dlngam(x=0)
  except RuntimeError as e:
    assert str(e)=="slatec: dgamma: x is 0 (nerr=4, level=2)"
  else: raise Exception_expected
  try: slatec_dlngam(x=-1)
  except RuntimeError as e:
    assert str(e)=="slatec: dgamma: x is a negative integer (nerr=4, level=2)"
  else: raise Exception_expected
  for i in range(1,10000):
    x = i/100.
    cmp(slatec_dgamma(x=x), gamma_complete(x))
  try: slatec_dlngam(x=0)
  except RuntimeError as e:
    assert str(e)=="slatec: dgamma: x is 0 (nerr=4, level=2)"
  else: raise Exception_expected
  try: slatec_dlngam(-1)
  except RuntimeError as e:
    assert str(e)=="slatec: dgamma: x is a negative integer (nerr=4, level=2)"
  else: raise Exception_expected
  assert approx_equal(slatec_dlngam(-1+1.e-8), 18.4206807543)
  assert approx_equal(slatec_dlngam(-1-1.e-8), 18.4206807458)
  assert eps_eq(slatec_dlngam( 2.53273727e+305),  1.77853307723e+308)
  try: slatec_dlngam(-2.53273727e+305)
  except RuntimeError as e:
    assert str(e)=="slatec: dlngam: x is a negative integer (nerr=3, level=2)"
  else: raise Exception_expected
  for x in [2.53273728e+305, -2.53273728e+305]:
    try: slatec_dlngam(x=x)
    except RuntimeError as e:
      assert str(e) == \
        "slatec: dlngam: abs(x) so big dlngam overflows (nerr=2, level=2)"
    else: raise Exception_expected
  for x,y in [
        (-0.9, 2.35807316739203), (-0.8, 1.74720737374499),
        (-0.7, 1.45247293875681), (-0.6, 1.30750344146777),
        (-0.5, 1.26551212348465), (-0.4, 1.31452458994339),
        (-0.3, 1.4648400508576), (-0.2, 1.76149759083394),
        (-0.1, 2.36896133272879), (0.1, 2.25271265173421),
        (0.2, 1.52406382243078), (0.3, 1.09579799481808),
        (0.4, 0.796677817701784), (0.5, 0.5723649429247),
        (0.6, 0.398233858069235), (0.7, 0.260867246531667),
        (0.8, 0.152059678399838), (0.9, 0.066376239734743),
        (-95.7, -342.652344377166), (-95.4, -341.444636043021),
        (-94.4, -336.886557464567), (-94.3, -336.269573770848),
        (-89.7, -315.444865680315), (-85.3, -295.745018427395),
        (-81.4, -278.633885462703), (-75.9, -253.468382259545),
        (-70.3, -230.359702035999), (-61.4, -193.193052861824),
        (-61.2, -191.887058269308), (-56.8, -173.90971361753),
        (-54.9, -165.606807044062), (-53.4, -160.729586596082),
        (-52.1, -154.437925415), (-45.4, -129.457867985401),
        (-42.5, -118.504844660495), (-28.9, -68.5996759295182),
        (-28.5, -68.4243510349742), (8.7, 9.96776168512864),
        (14.4, 23.5991967127359), (48.1, 137.188902640497),
        (52.4, 153.98778093456), (57.7, 175.181093095627),
        (58.7, 179.236350269141), (76.1, 252.322882401268),
        (80.1, 269.728736878324), (91.7, 321.309088278786),
        (95.2, 337.171114368332), (97.3, 346.750737141662),
        (99.2, 355.457300594627),
        (-1.25992104989487, 1.33050808569476),
        (3.1748021039364, 0.860352839192692),
        (-12.6992084157456, -20.4177393801341),
        (-20.158736798318, -40.9333927025327),
        (-322.539788773088, -1543.17783526817),
        (-812.749338607718, -4635.79483859481),
        (134217728, 2377663536.65922),
        (-213057362.619982, -3872759028.80297),
        (-426114725.239963, -8040878268.75138),
        (-1352829926.21012, -27091047640.5208),
        (-1704458900.95985, -34526394809.1753),
        (6817835603.83941, 147557106245.627),
        (-10822639409.6809, -239233427036.051),
        (-1385297844439.16, -37343385724961),
        (-3490731829165.78, -97325556732394.7),
        (-22164765511026.5, -658947950486145),
        (-354636248176425, -1.15264276699695e+16),
        (2.90518014506127e+18, 1.20602822017773e+20),
        (4.64828823209803e+19, 2.05852306758472e+21),
        (1.18059162071741e+21, 5.61020711097905e+22),
        (5.94980893708548e+21, 2.92359605678122e+23),
        (1.54742504910673e+26, 9.17681929135993e+27),
        (6.43926366825732e+31, 4.65188840905571e+33),
        (1.72852667909289e+40, 1.58420633670403e+42),
        (3.95432630437266e+57, 5.20476971689902e+59),
        (3.16346104349813e+58, 4.22959809661257e+60),
        (6.37713785476111e+59, 8.71788160127098e+61),
        (1.27542757095222e+60, 1.75241691050233e+62),
        (4.0492301356776e+60, 5.61035543530293e+62),
        (3.36999333339383e+66, 5.12864211104658e+68),
        (2.69599466671506e+67, 4.15897532189841e+69),
        (5.47791970565651e+69, 8.74161479134395e+71),
        (6.90174634679056e+69, 1.10296909057573e+72),
        (2.76069853871623e+70, 4.45014777047268e+72),
        (2.80469488929613e+72, 4.65067274510429e+74),
        (7.29444453207001e+76, 1.28370246361623e+79),
        (1.1671111251312e+78, 2.08628313321737e+80),
        (1.18571099379012e+80, 2.1743230279922e+82),
        (2.08592483976651e+93, 4.46128480838909e+95),
        (5.42506890849806e+97, 1.21544211995612e+100),
        (1.92392608380832e+112, 4.95495423759051e+114),
        (3.10271356343285e+114, 8.14856285749288e+116),
        (1.24108542537314e+115, 3.27663024026578e+117),
        (3.15216049571156e+116, 8.42408458530677e+118),
        (3.20239544759368e+118, 8.70631856055695e+120),
        (2.56191635807495e+119, 7.01832840145846e+121),
        (1.63962646916797e+121, 4.55992032478993e+123),
        (3.33151332094993e+123, 9.44222146520736e+125),
        (4.33229639706377e+127, 1.26890537358424e+130),
        (1.09167028500887e+128, 3.20753035674239e+130),
        (2.53719906956893e+147, 8.58616250449499e+149),
        (4.05951851131028e+148, 1.38504137596138e+151),
        (1.02293456496754e+149, 3.49953949189293e+151),
        (2.61871248631691e+151, 9.10403335337293e+153),
        (6.65111512893076e+152, 2.3337946141639e+155),
        (3.54267261962962e+160, 1.3061072142834e+163),
        (4.02035240429694e+176, 1.63084126214792e+179),
        (2.55276465434554e+177, 1.04023816504482e+180),
        (1.39234637988959e+188, 6.01795758359681e+190),
        (1.13162859936811e+191, 4.96691494590327e+193),
        (3.62121151797796e+192, 1.60196294545853e+195),
        (3.70812059440943e+195, 1.66611278950145e+198),
        (1.97510598530428e+203, 9.22582663285365e+205),
        (5.51565226310199e+216, 2.74715869462202e+219),
        (2.24142136441315e+219, 1.12984054184522e+222),
        (1.85074578797902e+224, 9.53864476740804e+226),
        (4.81341572835509e+228, 2.52974266023021e+231),
        (7.94889263257963e+233, 4.27312881295699e+236),
        (2.56383415069219e+236, 1.39306335150614e+239),
        (1.35485608003746e+243, 7.57136760625491e+245),
        (2.97936002792839e+255, 1.74963187938126e+258),
        (3.09948530198153e+260, 1.8559822138551e+263),
        (3.99882933842564e+263, 2.42315414346892e+266),
        (3.4622310392507e+274, 2.18518791213377e+277),
        (2.97403381695557e+284, 1.94508974776453e+287),
        (3.80676328570312e+286, 2.50818540780841e+289),
        (9.9792015476736e+291, 6.69956455295144e+294),
        (6.96694329442493e+304, 4.88331897497815e+307)]:
    cmp(y, slatec_dlngam(x=x))
  cmath_lgamma = getattr(scitbx.math, "cmath_lgamma", None)
  if (cmath_lgamma is not None):
    print("Testing compatibility of cmath_lgamma and slatec_dlngam...", end=' ')
    for i in range(-1000,1000):
      if (i <= 0 and i % 10 == 0): continue
      x = i/10.
      assert approx_equal(slatec_dlngam(x), cmath_lgamma(x), eps=1.e-10)
    cmath_lgamma_max_x = 5.e15 # larger values lead to floating-point
                               # exceptions on some platforms
    v = 2**(1/3.)
    x = v
    while True:
      try: s = slatec_dlngam(x)
      except RuntimeError as e:
        assert str(e) == \
          "slatec: dlngam: abs(x) so big dlngam overflows (nerr=2, level=2)"
        break
      if (x < cmath_lgamma_max_x):
        m = cmath_lgamma(x)
        cmp(s, m)
      try: s = slatec_dlngam(-x)
      except RuntimeError as e:
        assert str(e) in [
          "slatec: dlngam: x is a negative integer (nerr=3, level=2)",
          "slatec: dgamma: x is a negative integer (nerr=4, level=2)"]
      else:
        if (x < cmath_lgamma_max_x):
          m = cmath_lgamma(-x)
          cmp(s, m)
      x *= v
    print("OK")

def exercise_slatec_dbinom():
  f = scitbx.math.slatec_dlnrel
  try: f(-1)
  except RuntimeError as e:
    assert str(e) == \
      "slatec: dlnrel: x is le -1 (nerr=2, level=2)"
  else: raise Exception_expected
  assert approx_equal(f(-1+1.e-10), -23.0258508472)
  assert approx_equal(f(0.374), 0.3177261938)
  assert approx_equal(f(0.376), 0.319180739511)
  assert eps_eq(f(-0.4), -0.510825623766)
  assert eps_eq(f(0), 0.0)
  assert eps_eq(f(0.3), 0.262364264467)
  assert eps_eq(f(0.4), 0.336472236621)
  f = scitbx.math.slatec_dbinom
  try: f(n=0, m=1)
  except RuntimeError as e:
    assert str(e) == "slatec: dbinom: n lt m (nerr=2, level=2)"
  else: raise Exception_expected
  expected = [
    1, 2, 1, 3, 3, 1, 4, 6, 4, 1, 5, 10, 10, 5, 1, 6, 15, 20, 15, 6,
    1, 7, 21, 35, 35, 21, 7, 1, 8, 28, 56, 70, 56, 28, 8, 1, 9, 36, 84,
    126, 126, 84, 36, 9, 1, 10, 45, 120, 210, 252, 210, 120, 45, 10, 1]
  i = 0
  for n in range(1,11):
    for m in range(1,n+1):
      assert approx_equal(f(n=n, m=m), expected[i])
      i += 1
  assert eps_eq(f(100, 10), 1.73103095E+13)
  assert eps_eq(f(100, 33), 2.94692427E+26)
  assert eps_eq(f(1000, 100), 6.38505119E+139)
  assert eps_eq(f(1000, 333), 5.77613455E+274)
  nms = [
    (5, 2), (9, 6), (8, 3), (9, 1), (8, 2),
    (6, 1), (8, 4), (7, 5), (7, 3), (8, 7),
    (93, 70), (64, 57), (76, 66), (55, 22), (70, 2),
    (90, 85), (78, 4), (82, 19), (99, 6), (71, 5),
    (957, 516), (896, 665), (909, 253), (579, 74), (653, 651),
    (820, 581), (638, 290), (697, 533), (937, 695), (725, 78)]
  expected = [
    10, 84, 56, 9, 28, 6, 70, 21, 35, 8,
    3.73549788E+21, 621216192., 9.54526729E+11, 1.30085363E+15, 2415.,
    43949268., 1426425., 1.97103824E+18, 1.12052926E+09, 13019909.,
    1.66252414E+285, 3.80970836E+220, 8.43685887E+231, 6.3253529E+94, 212878.,
    2.45633786E+213, 2.58081251E+189, 5.06707246E+163, 8.53013061E+230,
    1.53361301E+106]
  for nm,e in zip(nms,expected):
    assert eps_eq(f(*nm), e)
  assert eps_eq(f(n=2**32-1,m=2**5), 6.83193552992e+272)
  try: f(n=2**32-1,m=2**6)
  except RuntimeError as e:
    assert str(e) == \
      "slatec: dbinom: result overflows" \
      " because n and/or m too big (nerr=3, level=2)"
  else: raise Exception_expected

def exercise_unimodular_generator(forever):
  ug = scitbx.math.unimodular_generator
  g = ug(range=0)
  assert g.at_end()
  g = ug(range=1)
  assert not g.at_end()
  n = 0
  while (not g.at_end()):
    assert matrix.rec(next(g), (3,3)).determinant() == 1
    n += 1
  assert n == 3480
  assert ug(range=0).count() == 0
  assert ug(range=1).count() == 3480
  assert ug(range=2).count() == 67704
  assert ug(range=3).count() == 640824
  assert len(list(ug(range=1).all())) == 3480
  for range in count():
    timer = user_plus_sys_time()
    n = ug(range=range).count()
    print("unimodular range %d: count=%d, time=%.2f s" % (
      range, n, timer.elapsed()))
    if (range == 4 and not forever):
      break

def exercise_least_squares_plane():
  points = [ matrix.col(x) for x in [(1, 2, 3), (-1, -2, -3), (1, 1, 1),
                                     (1.2, 2.1, 2.9), (-0.9, -2.1, -3.1),
                                     (1.1, 0.8, 1.2)] ]
  def distance(n,d):
    return sum([ (n.dot(x) - d)**2 for x in points ])
  flex_points = flex.vec3_double(points)
  p = scitbx.math.least_squares_plane(flex_points)
  n = matrix.col(p.normal)
  d = p.distance_to_origin
  assert approx_equal(abs(n), 1)
  dist0 = distance(n,d)
  for i in range(5000):
    d1 = d + random.uniform(-0.1, 0.1)
    n1 = matrix.rec(flex.random_double_r3_rotation_matrix(), (3,3))*n
    dist = distance(n1, d1)
    assert dist >= dist0

def exercise_continued_fraction():
  continued_fraction = scitbx.math.continued_fraction
  frac = boost_adaptbx.boost.rational.int
  cf = continued_fraction(1)
  assert cf.as_rational() == frac(1,1)
  cf.append(1)
  assert cf.as_rational() == frac(2,1)
  cf.append(1)
  assert cf.as_rational() == frac(3,2)
  cf.append(1)
  assert cf.as_rational() == frac(5,3)
  cf = continued_fraction.from_real(math.pi, eps=1e-2)
  assert cf.as_rational() == frac(22, 7)
  cf = continued_fraction.from_real(math.pi, eps=1e-4)
  assert cf.as_rational() == frac(333, 106)
  cf = continued_fraction.from_real(math.pi, eps=1e-5)
  assert cf.as_rational() == frac(355, 113)
  cf = continued_fraction.from_real(-math.pi, eps=1e-2)
  assert cf.as_rational() == frac(-22, 7)
  cf = continued_fraction.from_real(-math.pi, eps=1e-4)
  assert cf.as_rational() == frac(-333, 106)
  cf = continued_fraction.from_real(-math.pi, eps=1e-5)
  assert cf.as_rational() == frac(-355, 113)
  cf = continued_fraction.from_real(0.125)
  assert cf.as_rational() == frac(1,8)

def exercise_numeric_limits():
  l = scitbx.math.double_numeric_limits
  print("Floating point type 'double':")
  print("\tradix: ", l.radix)
  print("\tmantissa digits (base 2):", l.digits)
  print("\tmantissa digits (base 10):", l.digits10)
  print("\tmin exponent (base 2):", l.min_exponent)
  print("\tmin exponent (base 10):", l.min_exponent10)
  print("\tmax exponent (base 2):", l.max_exponent)
  print("\tmax exponent (base 10):", l.max_exponent10)
  print("\tmin:", l.min)
  print("\tmax:", l.max)
  print("\tepsilon:", l.epsilon)
  print("\tsafe min:", l.safe_min)

def exercise_distributions():
  # normal distribution
  norm = distributions.normal_distribution()
  assert norm.mean() == 0
  assert norm.median() == 0
  assert norm.mode() == 0
  assert norm.standard_deviation() == 1
  assert norm.variance() == math.pow(norm.standard_deviation(), 2)
  assert norm.kurtosis() == 3
  assert norm.skewness() == 0
  assert approx_equal(norm.pdf(1.2), 0.19418605498321298)
  assert approx_equal(norm.cdf(norm.quantile(.9)), .9)
  assert approx_equal(norm.quantiles(5),
    (-1.2815515655446006, -0.52440051270804089, 0.0,
     0.52440051270804067, 1.2815515655446006))
  norm = distributions.normal_distribution(1,6)
  assert norm.mean() == 1
  assert norm.standard_deviation() == 6
  # student's t distribution
  try:
    stu = distributions.students_t_distribution(10)
  except RuntimeError as e:
    print("Skipping exercise students_t_distribution:", e)
  else:
    assert stu.degrees_of_freedom() == 10
    assert stu.mean() == 0
    assert stu.median() == 0
    assert stu.mode() == 0
    assert approx_equal(
      math.pow(stu.standard_deviation(),2), 1.25)
    assert approx_equal(stu.variance(), 1.25)
    assert approx_equal(stu.kurtosis(), 4.0)
    assert stu.skewness() == 0
    assert approx_equal(norm.pdf(0.4), 0.066158757912835292)
    assert approx_equal(norm.cdf(norm.quantile(.8)), .8)
    assert approx_equal(stu.quantiles(6),
      (-1.4915762442496054, -0.69981206131243145, -0.21599563333226371,
       0.21599563333226388, 0.69981206131243145, 1.4915762442496057))

def exercise_approx_equal():
  from scitbx.math import double_numeric_limits as limits
  from scitbx.math import approx_equal_relatively

  # This would fail with a naive relative test for such tiny numbers
  assert approx_equal_relatively(-limits.min/2, limits.min/2,
                                 relative_error=1)
  # vanilla relative difference test
  assert approx_equal_relatively(0.9999, 1., 0.0001)
  assert approx_equal_relatively(0.9997 + 0.0004j, 1., 0.0005)

def exercise_weighted_covariance():
  from scitbx.math import weighted_covariance
  stats = weighted_covariance(x=flex.double((1, 2, 1e-4, 3, 4, 5)),
                              y=flex.double((2, 4, 1e-4, 6, 8, 10)),
                              weights=flex.double((2, 1, 3, 2, 1, 2)))
  eps = 1e-18
  # tests generated with Mathematica
  assert approx_equal(stats.mean_x, 2.18184545454545455, eps)
  assert approx_equal(stats.mean_y, 4.36366363636363636, eps)
  assert approx_equal(stats.variance_x, 3.42136859702479339, eps)
  assert approx_equal(stats.variance_y, 13.6857123986776860, eps)
  assert approx_equal(stats.covariance_xy, 6.84279669619834711, eps)
  assert approx_equal(stats.correlation, 0.99999999996534161, eps)
  stats.accumulate(x=-1, y=2, weight=2)
  stats.accumulate(x=2, y=-3, weight=1)
  assert approx_equal(stats.mean_x, 1.71430714285714286, eps)
  assert approx_equal(stats.mean_y, 3.50002142857142857, eps)
  assert approx_equal(stats.variance_x, 3.91829387923469388, eps)
  assert approx_equal(stats.variance_y, 14.6784214302551020, eps)
  assert approx_equal(stats.covariance_xy, 6.14274540984693878, eps)
  assert approx_equal(stats.correlation, 0.809980077408506317, eps)

def exercise_interpolation():
  from scitbx.math import interpolate_catmull_rom_spline
  p0 = (4.6125, 53.1915, -1.0)
  p1 = (4.86, 54.206, 0.603)
  p2 = (6.640, 55.369, 0.651)
  p3 = (7.726, 56.192, -0.941)
  points = interpolate_catmull_rom_spline(p0, p1, p2, p3, 5)
  assert approx_equal(points[2][0], 5.9044, eps=0.0001)
  assert approx_equal(points[4][2], 0.651, eps=0.0001)
  p0 = (0, 1)
  p1 = (0.5, 0.707)
  p2 = (1, 0)
  p3 = (-0.5, -0.707)
  points = interpolate_catmull_rom_spline(p0, p1, p2, p3, 5)
  assert approx_equal(points[1][1], 0.454, eps=0.0001)

  from scitbx.math import linear_interpolation_2d
  r = linear_interpolation_2d(
      1., 1.,
      2., 2.,
      0., 1., 0., 1.,
      1.5, 1.5);
  assert approx_equal(r, 0.5)
  r = linear_interpolation_2d(
      1., 1.,
      2., 2.,
      0., 2., 0., 1.,
      1.5, 1.5);
  assert approx_equal(r, 0.75)
  r = linear_interpolation_2d(
      1., 1.,
      2., 2.,
      0., 2., 0., 1.,
      1., 1.);
  assert approx_equal(r, 0);

def exercise_misc():
  from scitbx.math import distance_difference_matrix
  sites1 = flex.vec3_double([(0.,0.,0.),(0.,1.,2.),(3.,4.,5.)])
  sites2 = flex.vec3_double([(1.,1.,1.),(1.,2.,3.),(6.,7.,8.)])
  ddm = distance_difference_matrix(sites1, sites2)
  for i in range(3):
    assert (ddm[(i,i)] == 0)
  assert approx_equal(ddm[(0,2)], 3.4170207)
  assert approx_equal(ddm[(1,2)], 3.4641016)
  assert approx_equal(ddm[(0,2)], 3.4170207)
  try :
    import numpy # import dependency
  except ImportError :
    pass
  else :
    a = ddm.as_numpy_array()
    assert (a[0][0] == 0) and (approx_equal(a[1][2], 3.4641016))

def exercise_equally_spaced_points_on_vector():
  espov = scitbx.math.equally_spaced_points_on_vector
  start = [1,2,3]
  end   = [1,2,8]
  r = list(espov(start=start, end=end, n=1, step=None))
  assert approx_equal(r, [(1.0, 2.0, 3.0), (1.0, 2.0, 5.5), (1.0, 2.0, 8.0)])
  r = list(espov(start=start, end=end, n=3, step=None))
  assert approx_equal(r, [(1.0, 2.0, 3.0), (1.0, 2.0, 4.25), (1.0, 2.0, 5.5),
    (1.0, 2.0, 6.75), (1.0, 2.0, 8.0)])
  #
  r = list(espov(start=start, end=end, n=None, step=2.5))
  assert approx_equal(r, [(1.0, 2.0, 3.0), (1.0, 2.0, 5.5), (1.0, 2.0, 8.0)])
  r = list(espov(start=start, end=end, n=None, step=1.25))
  assert approx_equal(r, [(1.0, 2.0, 3.0), (1.0, 2.0, 4.25), (1.0, 2.0, 5.5),
    (1.0, 2.0, 6.75), (1.0, 2.0, 8.0)])

def exercise_parabolic_cylinder_d():
  va = flex.random_double(100)
  x  = flex.random_double(100)
  for va_, x_ in zip(va,x):
    scale1 = 1#random.choice([0, 1.e-6, 1.e-3, 0.1, 1, 1.e+3, 1.e+6])
    scale2 = random.choice([0, 1.e-6, 1.e-3, 0.1, 1, 1.e+3, 1.e+6])
    va_ = va_*scale1
    x_  = x_*scale2
    print("Dv(%.6g,%.6g)=%.6g"%(va_, x_, parabolic_cylinder_d(va_, x_)))

def exercise_fast_approx_math(n=1000):
  # SIN, COS tables
  def run(func, func_table):
    step = 2*math.pi/n;
    table = flex.double()
    for i in range(n):
      table.append(func(i*step));
    for interpolate in [True, False]:
      r1 = flex.double()
      r2 = flex.double()
      for a in range(-360, 360):
        arg = a*math.pi/180
        v1 = func(arg)
        v2 = func_table(table=table, arg=arg, step=step, n=n,
          interpolate=interpolate)
        r1.append(v1)
        r2.append(v2)
      print((r1-r2).min_max_mean().as_tuple(), interpolate)
  run(func=math.cos, func_table=scitbx.math.cos_table)
  run(func=math.sin, func_table=scitbx.math.sin_table)
  # SQRT
  args = list(flex.random_double(100)/1000)+ \
         list(flex.random_double(100)/100) + \
         list(flex.random_double(100)/10)  + \
         list(flex.random_double(100))     + \
         list(flex.random_double(100)*10)  + \
         list(flex.random_double(100)*100) + \
         list(flex.random_double(100)*1000)
  diff = flex.double()
  for a in args:
    v1=math.sqrt(a)
    v2 = scitbx.math.approx_sqrt(a)
    diff.append(v1-v2)
    #if(abs(v1-v2)>1.):
    #  print a, v1, v2
  print(diff.min_max_mean().as_tuple())

def exercise_simpson():
  def f(x): return math.sqrt(9-x*x)
  assert approx_equal(scitbx.math.simpson(f,-3,3,20000), math.pi*9./2, 1.e-4)

def run():
  exercise_simpson()
  exercise_fast_approx_math()
  exercise_parabolic_cylinder_d()
  exercise_equally_spaced_points_on_vector()
  exercise_weighted_covariance()
  exercise_distributions()
  exercise_approx_equal()
  exercise_median()
  exercise_numeric_limits()
  exercise_continued_fraction()
  exercise_least_squares_plane()
  exercise_div_mod()
  exercise_row_echelon_full_pivoting()
  exercise_solve_a_x_eq_b_min_norm_given_a_sym_b_col()
  exercise_eix()
  exercise_floating_point_epsilon()
  exercise_line_given_points()
  exercise_dihedral_angle()
  exercise_euler_angles()
  exercise_erf()
  exercise_gamma_incomplete()
  exercise_gamma_complete()
  exercise_exponential_integral_e1z()
  exercise_bessel()
  exercise_lambertw()
  exercise_golay()
  exercise_inertia_tensor()
  exercise_principal_axes_of_inertia()
  exercise_principal_axes_of_inertia_2d()
  explore_inertia_tensor_properties()
  exercise_phase_error()
  exercise_row_echelon()
  exercise_tensor_rank_2()
  exercise_icosahedron()
  exercise_basic_statistics()
  exercise_cheb_family()
  exercise_slatec_dlngam()
  exercise_slatec_dbinom()
  exercise_interpolation()
  exercise_misc()
  forever = "--forever" in sys.argv[1:]
  exercise_unimodular_generator(
    forever=forever and "--unimodular" in sys.argv[1:])
  while 1:
    exercise_minimum_covering_sphere()
    if (not forever): break
  print("OK")

if (__name__ == "__main__"):
  run()


 *******************************************************************************


 *******************************************************************************
scitbx/math/tests/tst_minimum_covering_ellipsoid.py
from __future__ import absolute_import, division, print_function
from six.moves import range
def run(args):
  assert len(args) == 0
  n_trials = 100
  from scitbx.math.minimum_covering_ellipsoid import compute as mce_compute
  from scitbx.array_family import flex
  from libtbx.test_utils import approx_equal, is_below_limit
  # XXX point group 222 should be sufficient, but 432 is currently needed
  point_group_432_rotation_matrices = [
    (1,0,0,0,1,0,0,0,1),
    (1,0,0,0,0,-1,0,1,0),
    (1,0,0,0,0,1,0,-1,0),
    (0,0,1,0,1,0,-1,0,0),
    (0,0,-1,0,1,0,1,0,0),
    (0,-1,0,1,0,0,0,0,1),
    (0,1,0,-1,0,0,0,0,1),
    (0,0,1,1,0,0,0,1,0),
    (0,1,0,0,0,1,1,0,0),
    (0,-1,0,0,0,-1,1,0,0),
    (0,0,1,-1,0,0,0,-1,0),
    (0,-1,0,0,0,1,-1,0,0),
    (0,0,-1,-1,0,0,0,1,0),
    (0,0,-1,1,0,0,0,-1,0),
    (0,1,0,0,0,-1,-1,0,0),
    (1,0,0,0,-1,0,0,0,-1),
    (-1,0,0,0,1,0,0,0,-1),
    (-1,0,0,0,-1,0,0,0,1),
    (0,1,0,1,0,0,0,0,-1),
    (0,-1,0,-1,0,0,0,0,-1),
    (0,0,1,0,-1,0,1,0,0),
    (0,0,-1,0,-1,0,-1,0,0),
    (-1,0,0,0,0,1,0,1,0),
    (-1,0,0,0,0,-1,0,-1,0)]
  def check(center, radii, rotation):
    a,b,c = radii
    points_principal = flex.vec3_double([
      (-a,0,0),
      (a,0,0),
      (0,-b,0),
      (0,b,0),
      (0,0,-c),
      (0,0,c)])
    points = rotation * points_principal + center
    mce = mce_compute(points)
    assert approx_equal(mce.center, center)
    assert approx_equal(sorted(mce.radii), sorted(radii))
    assert approx_equal(mce.rotation.determinant(), 1)
    points_mce = mce.rotation.inverse().elems * (points - mce.center)
    rms = []
    for r in point_group_432_rotation_matrices:
      rp = r * points_mce
      rms.append(rp.rms_difference(points_principal))
    assert is_below_limit(value=min(rms), limit=1e-8, eps=0)
  mt = flex.mersenne_twister(seed=0)
  check((0,0,0), (1,2,3), (1,0,0,0,1,0,0,0,1))
  for i_trial in range(n_trials):
    center = list(mt.random_double(size=3)*8-4)
    radii = list(mt.random_double(size=3)*3+0.1)
    rotation = mt.random_double_r3_rotation_matrix()
    check(center, radii, rotation)
  from libtbx.utils import format_cpu_times
  print(format_cpu_times())

if (__name__ == "__main__"):
  import sys
  run(args=sys.argv[1:])


 *******************************************************************************


 *******************************************************************************
scitbx/math/tests/tst_orthonormal_basis.py
from __future__ import absolute_import, division, print_function
from scitbx.math import orthonormal_basis
from scitbx import matrix
from libtbx.test_utils import approx_equal
from scitbx.array_family import flex
from six.moves import range

def input_pairs():
  yield matrix.col((1, 0, 1)), matrix.col((1, 1, 1))
  for i in range(10):
    yield matrix.col(flex.random_double(3)), matrix.col(flex.random_double(3))

def exercise_orthonormal_basis(eps=1e-12):
  for v0, v1 in input_pairs():
    basis = [ matrix.col(e) for e in orthonormal_basis(v0, v1) ]
    for e in basis:
      assert approx_equal(e.length(), 1, eps)
    e0, e1, e2 = basis
    assert approx_equal(e0.cross(e1), e2, eps)

    basis_perm = orthonormal_basis(v0, 2, v1, 1)
    assert approx_equal(basis_perm[2],  e0, eps)
    assert approx_equal(basis_perm[1],  e1, eps)
    assert approx_equal(basis_perm[0], -e2, eps)

    basis_perm = orthonormal_basis(v0, 2, v1, 0)
    assert approx_equal(basis_perm[2],  e0, eps)
    assert approx_equal(basis_perm[0],  e1, eps)
    assert approx_equal(basis_perm[1],  e2, eps)

    left_handed_basis = orthonormal_basis(v0, v1, right_handed=False)
    assert approx_equal(left_handed_basis, (e0, e1, -e2), eps)

def run():
  exercise_orthonormal_basis()
  print('OK')

if __name__ == '__main__':
  run()


 *******************************************************************************


 *******************************************************************************
scitbx/math/tests/tst_periodogram.py
#!/usr/bin/env cctbx.python
#
#  Copyright (C) (2016) STFC Rutherford Appleton Laboratory, UK.
#
#  Author: David Waterman.
#
#  This code is distributed under the BSD license, a copy of which is
#  included in the root directory of this package.
#

from __future__ import absolute_import, division, print_function
from scitbx.array_family import flex
from scitbx.math.periodogram import Periodogram
from libtbx.test_utils import approx_equal
from six.moves import range

# This is the "discoveries" dataset from R, giving the number of "great"
# inventions and scientific discoveries in each year from 1860 to 1959.
dat = flex.double([5,3,0,2,0,3,2,3,6,1,2,1,2,1,3,3,3,5,2,4,4,0,2,3,7,12,3,10,9,
2,3,7,7,2,3,3,6,2,4,3,5,2,2,4,0,4,2,5,2,3,3,6,5,8,3,6,6,0,5,2,2,2,6,3,4,4,2,2,
4,7,5,3,3,0,2,2,2,1,3,4,2,2,1,1,1,2,1,4,4,3,2,1,4,1,1,1,0,0,2,0])

# The tests here were originally against calls made to R using rpy2. Here the
# values returned by those calls are written out explicitly.

def test_raw_even_and_odd_length():
  """Test raw periodogram of even and odd length sequences versus results
  obtained using R's spec.pgram function."""

  # even-length
  pgram = Periodogram(dat)
  rspec = flex.double([28.95417436723208,
                       8.804110562933733,
                       18.49821426322232,
                       4.094928274829677,
                       10.664583495648557,
                       0.9510798979384458,
                       4.818019271965207,
                       8.7890132834726,
                       0.34895472871642474,
                       4.298708963847126,
                       17.808223044747802,
                       0.43460105379492137,
                       9.846548561891545,
                       0.7189166875859443,
                       1.5700713159868809,
                       7.006058124904175,
                       0.34542255079605266,
                       3.1168239060632974,
                       1.263928801888548,
                       0.01861054239907847,
                       1.6636054250587091,
                       1.882713242160402,
                       1.1719572134942402,
                       1.5202775036250407,
                       9.849072239357147,
                       8.154656878294267,
                       3.5445494165048013,
                       1.0058616277307482,
                       4.232126563022536,
                       5.144050304879019,
                       3.5369877391028433,
                       3.096569282327231,
                       2.8433497727678416,
                       0.5666508873501074,
                       1.9719884560263852,
                       10.127938512870841,
                       1.7824474672209123,
                       4.724527776009507,
                       3.9087766384313976,
                       6.6956845513767265,
                       0.6830967285296601,
                       4.935588195925854,
                       0.5748537866060414,
                       1.6844746497921799,
                       9.263139681830246,
                       7.47129442196606,
                       4.762894221668351,
                       0.3223925047950684,
                       0.5826957996969294,
                       0.10068673474008037])

  rfreq = flex.double(0.01 * e for e in (range(1,51)))
  assert approx_equal(pgram.spec, rspec)
  assert approx_equal(pgram.freq, rfreq)

  # odd-length
  dat2 = dat[0:99]
  pgram = Periodogram(dat2)
  rspec = flex.double([27.378734487215517,
                       8.300597643964354,
                       18.601570728645616,
                       4.401309169508969,
                       9.81615913184789,
                       1.2198000269161602,
                       5.2778352616536175,
                       8.22707610023193,
                       0.8865216983472878,
                       2.8232693965537834,
                       20.1615730381271,
                       0.11712370567046958,
                       8.88090348832551,
                       0.5966571692115259,
                       1.9402032941479643,
                       7.389059053524231,
                       1.8478623100240048,
                       2.087060370495997,
                       1.4918451091166665,
                       0.29469653682276337,
                       3.3114401807871734,
                       0.34065845307496007,
                       1.2416790352786125,
                       2.162525614248078,
                       11.588418669622571,
                       7.736166858429692,
                       1.9797555750271172,
                       2.179422742788905,
                       7.124078571174135,
                       1.7626318917205566,
                       4.097247214701129,
                       3.484527330303516,
                       1.2144485874993167,
                       1.085059335676423,
                       8.41344396898852,
                       3.7261271115507744,
                       0.3362106092460046,
                       5.5128561313938516,
                       3.212041963064243,
                       5.261688734349363,
                       2.32174787318873,
                       4.50066920034715,
                       0.4679419198572981,
                       2.9281768538056987,
                       8.883073168591967,
                       8.952596303235458,
                       1.2239788162354133,
                       0.3633295633047963,
                       0.24463991145416633])
  rfreq = flex.double(1/99 * e for e in (range(1,50)))
  assert approx_equal(pgram.spec, rspec)
  assert approx_equal(pgram.freq, rfreq)

  print("OK")

def test_smoothed_even_and_odd_length():
  """Test smoothed periodogram of even and odd length sequences versus results
  obtained using R's spec.pgram function"""

  # single kernel smoother, even length
  pgram = Periodogram(dat, spans=4)
  rspec = flex.double([22.60966340315627,
                       18.195262628604752,
                       12.801658008106513,
                       9.533830316034159,
                       6.842177109002613,
                       5.718913361175838,
                       5.016220391389688,
                       4.145220428761756,
                       6.187449533598165,
                       6.766923476486281,
                       6.909821176923462,
                       7.649546371537703,
                       5.17230337090994,
                       3.9639665387034815,
                       3.5977579212052033,
                       2.709855572127937,
                       2.971326160175313,
                       2.0596273980998854,
                       1.350969309569581,
                       1.3614783358645521,
                       1.1957180543273982,
                       1.371929975931356,
                       2.582821697871905,
                       4.389998004175942,
                       5.470564984068996,
                       5.702837024958528,
                       4.936416830929916,
                       3.8579727997111832,
                       3.4807017683590322,
                       3.7410950155083493,
                       3.82883637355107,
                       3.0830643475781216,
                       2.3152645100024487,
                       2.998560753435843,
                       3.7448691190604286,
                       4.131990941949487,
                       4.893824075832538,
                       4.706890853446401,
                       4.14044026592323,
                       4.029403976076368,
                       3.639046172087742,
                       2.595904577911505,
                       3.042008709376008,
                       4.431477356793608,
                       5.271945689431424,
                       5.625190475689571,
                       4.369874722298269,
                       2.363493276128358,
                       0.9196425124786836,
                       0.39711770973225585])
  assert approx_equal(pgram.spec, rspec)

  # three kernel smoothers with differing lengths, odd length sequence
  dat2 = dat[0:99]
  pgram = Periodogram(dat2, spans=[4,6,4])
  rspec = flex.double([17.314055274775985,
                       15.746715010053997,
                       13.51918957394817,
                       11.096669833901974,
                       8.94488071864728,
                       7.357033921545414,
                       6.4291723412721415,
                       6.06483632171929,
                       6.0180027558874265,
                       6.0556124717493125,
                       6.000976488762685,
                       5.756178307862047,
                       5.315663331116168,
                       4.716140919888478,
                       4.055823092903159,
                       3.4305933136199633,
                       2.8881959432238777,
                       2.4700815936067313,
                       2.2043629196392005,
                       2.1371110039637147,
                       2.318359384971553,
                       2.737953359136525,
                       3.3119078691830612,
                       3.8971755852383345,
                       4.358224117959523,
                       4.610902643634579,
                       4.617256999182198,
                       4.404925734628821,
                       4.07304004821836,
                       3.742088947852017,
                       3.4988298970826084,
                       3.377951237167512,
                       3.3623755402288427,
                       3.4107737746104503,
                       3.493901696666407,
                       3.5886989978152486,
                       3.6571955223055133,
                       3.6669320372957337,
                       3.6399826234621893,
                       3.6368323534539106,
                       3.701389530366984,
                       3.8389251460239517,
                       3.9895437773918845,
                       4.046699282044061,
                       3.92426466711323,
                       3.5960187967975505,
                       3.122909791584781,
                       2.6492847490141163,
                       2.349620740074152])

  assert approx_equal(pgram.spec, rspec)
  print("OK")

if __name__=="__main__":

  test_raw_even_and_odd_length()
  test_smoothed_even_and_odd_length()

  print("OK")


 *******************************************************************************


 *******************************************************************************
scitbx/math/tests/tst_quadrature.py
from __future__ import absolute_import, division, print_function
from scitbx.array_family import flex
from libtbx.test_utils import approx_equal
import scitbx.math as sm
import math
from six.moves import range
from six.moves import zip


def twod_integrator( cub, n_points ):
  result = 0
  x = flex.double()
  y = flex.double()
  w = flex.double()
  for ii in range(n_points):
    x.append( cub.coord(ii)[0] )
    y.append( cub.coord(ii)[1] )
    w.append( cub.weight(ii) )
  tot = flex.exp( -x -y)*w
  tot = flex.sum( tot )
  return tot


def tst_cubature():
  # cubature integration of exp(-x-y)exp(-x^2-y^2)
  # 4 different cubatures are used.
  fna=sm.five_nine_1001()
  fnb=sm.five_nine_1110()
  ft=sm.seven_twelve_0120()
  nto=sm.nine_twentyone_1012()

  theory=(math.pi)*math.exp(0.5)
  r_fna=twod_integrator(fna,9)
  r_fnb=twod_integrator(fnb,9)
  r_ft=twod_integrator(ft,12)
  r_nto=twod_integrator(nto,21)
  assert approx_equal(r_fna, theory, eps=0.05)
  assert approx_equal(r_fnb, theory, eps=0.05)
  assert approx_equal(r_ft, theory, eps=0.01)
  assert approx_equal(r_nto,theory, eps=0.01)


def tst_gauss_hermite_engine():
  # test with known values
  ghe = sm.gauss_hermite_engine(4)
  x_ams_55    = [0.524647623275290, 1.650680123885785]
  w_ams_55    = [0.8049140900055  , 0.08131283544725]
  wexs_ams_55 = [1.0599644828950  , 1.2402258176958]
  x_this = ghe.x()[0:2]
  w_this = ghe.w()[0:2]
  for x,xx in zip( x_this, x_ams_55):
    assert approx_equal( x, xx, eps=1e-8 )
  for w,ww in zip( w_this, w_ams_55):
    assert approx_equal( w, ww, eps=1e-8 )

  # test a large order set of number
  for n in range(2,29):
    ghe = sm.gauss_hermite_engine(n)
    x_this = ghe.x()
    step = 0.5/math.sqrt(n*1.0)
    for ix in range( x_this.size() ):
      f = ghe.f( x_this[ix] )[0]
      assert approx_equal(f,0,eps=1e-5)
      # check the uniqueness of each point
      for jj in  range( x_this.size() ):
        if jj != ix:
          assert ( math.fabs(x_this[ix]-x_this[jj]) >= step )


def tst_gauss_legendre_engine():

  for n in range(2,95):
    gle = sm.gauss_legendre_engine(n)
    x_this = gle.x()
    step=1e-5 # check AMS pg 919. nodes for n=96 are allways more then stpe away from each other
    for ix in range( x_this.size() ):
      f = gle.f( x_this[ix] )[0]
      assert approx_equal(f,0,eps=1e-5)
      # check the uniqueness of each point
      for jj in  range( x_this.size() ):
        if jj != ix:
          assert ( math.fabs(x_this[ix]-x_this[jj]) >= step )



def examples():
  # an illustration of Hermite Gauss quadrature
  # we will try to integrate
  # Exp[-x^2-x] {x,-inf, inf}
  # The true answer is Exp[0.25] Sqrt[Pi]
  #
  f_theory = math.exp(0.25)*math.sqrt( math.pi )
  for ii in range(6,10):
    ghq = sm.gauss_hermite_engine(ii)
    w = ghq.w()
    x = ghq.x()
    f = flex.sum( (flex.exp( -x ))*w )
    assert approx_equal(f,f_theory, eps=1e-5)

  # an example of Gauss-Legendre integration
  # we integrate exp(-x) between -1 and 1
  f_theory = math.exp(1) - math.exp(-1)
  for ii in range(5,90):
    glq = sm.gauss_legendre_engine(ii)
    w = glq.w()
    x = glq.x()
    f = flex.sum( (flex.exp( -x ))*w )
    #assert approx_equal(f,f_theory, eps=1e-5)






def run():
  tst_gauss_legendre_engine()
  tst_gauss_hermite_engine()
  examples()
  tst_cubature()
  print("OK")

if (__name__ == "__main__"):
  run()


 *******************************************************************************


 *******************************************************************************
scitbx/math/tests/tst_r3_rotation.py
from __future__ import absolute_import, division, print_function
import scitbx.math
from scitbx.math import r3_rotation_vector_to_vector as vector_to_vector
from scitbx.math import r3_rotation_vector_to_001 as vector_to_001
from scitbx.math import r3_rotation_vector_to_010 as vector_to_010
from scitbx.math import r3_rotation_vector_to_100 as vector_to_100
from scitbx import matrix
from scitbx.array_family import flex
from libtbx.utils import format_cpu_times
from libtbx.test_utils import Exception_expected, approx_equal
import math
import time
import sys
from six.moves import range

def exercise_axis_and_angle(
      axis_range=2,
      angle_max_division=12,
      angle_min_power=-30):
  from_matrix = scitbx.math.r3_rotation_axis_and_angle_from_matrix(
    r=[1,0,0,0,1,0,0,0,1])
  assert approx_equal(from_matrix.axis, [1/3**0.5]*3)
  assert approx_equal(from_matrix.angle(deg=True), 0)
  assert approx_equal(from_matrix.angle(deg=False), 0)
  from_matrix = scitbx.math.r3_rotation_axis_and_angle_from_matrix(r=[0]*9)
  assert approx_equal(from_matrix.axis, [0,0,1])
  assert approx_equal(from_matrix.angle(deg=True), 90)
  assert approx_equal(from_matrix.angle(deg=False), math.pi/2)
  #
  angles = []
  for d in range(1,angle_max_division+1):
    angles.append(360/d)
    angles.append(-360/d)
  for p in range(-angle_min_power+1):
    angles.append(10**(-p))
    angles.append(-10**(-p))
  hex_orth = matrix.sqr([
    8.7903631196301042, -4.3951815598150503, 0,
    0, 7.6126777700894994, 0,
    0, 0, 14.943617303371177])
  rot_axes = []
  rot_angles = []
  rot_matrices = []
  for u in range(-axis_range, axis_range+1):
    for v in range(-axis_range, axis_range+1):
      for w in range(axis_range+1):
        for axis in [(u,v,w), (hex_orth*matrix.col((u,v,w))).elems]:
          for angle in angles:
            try:
              r = scitbx.math.r3_rotation_axis_and_angle_as_matrix(
                axis=axis, angle=angle, deg=True)
              rot_axes.append(axis)
              rot_angles.append(angle)
              rot_matrices.append(r)
            except RuntimeError:
              assert axis == (0,0,0)
              try:
                scitbx.math.r3_rotation_axis_and_angle_as_unit_quaternion(
                  axis=axis, angle=angle, deg=True)
              except RuntimeError: pass
              else: raise Exception_expected
            else:
              q = scitbx.math.r3_rotation_axis_and_angle_as_unit_quaternion(
                axis=axis, angle=angle, deg=True)
              assert approx_equal(abs(matrix.col(q)), 1)
              rq = scitbx.math.r3_rotation_unit_quaternion_as_matrix(q=q)
              assert approx_equal(rq, r)
              from_matrix = scitbx.math.r3_rotation_axis_and_angle_from_matrix(
                r=r)
              rr = from_matrix.as_matrix()
              assert approx_equal(rr, r)
              qq = from_matrix.as_unit_quaternion()
              assert approx_equal(abs(matrix.col(qq)), 1)
              rq = scitbx.math.r3_rotation_unit_quaternion_as_matrix(q=qq)
              assert approx_equal(rq, r)
              qq = scitbx.math.r3_rotation_matrix_as_unit_quaternion(r=r)
              assert approx_equal(abs(matrix.col(qq)), 1)
              rq = scitbx.math.r3_rotation_unit_quaternion_as_matrix(q=qq)
              assert approx_equal(rq, r)
              rm = matrix.sqr(r)
              assert rm.is_r3_rotation_matrix()
              qm = rm.r3_rotation_matrix_as_unit_quaternion()
              assert approx_equal(abs(qm), 1)
              assert approx_equal(qm, qq)
              rqmm = qm.unit_quaternion_as_r3_rotation_matrix()
              assert approx_equal(rqmm, r)
              for deg in [False, True]:
                rr = scitbx.math.r3_rotation_axis_and_angle_as_matrix(
                  axis=from_matrix.axis,
                  angle=from_matrix.angle(deg=deg),
                  deg=deg,
                  min_axis_length=1-1.e-5)
                assert approx_equal(rr, r)
                qq = scitbx.math.r3_rotation_axis_and_angle_as_unit_quaternion(
                  axis=from_matrix.axis,
                  angle=from_matrix.angle(deg=deg),
                  deg=deg,
                  min_axis_length=1-1.e-5)
                qq = from_matrix.as_unit_quaternion()
                assert approx_equal(abs(matrix.col(qq)), 1)
                rq = scitbx.math.r3_rotation_unit_quaternion_as_matrix(q=qq)
                assert approx_equal(rq, r)
                for conv in [
                  scitbx.math.r3_rotation_axis_and_angle_as_matrix,
                  scitbx.math.r3_rotation_axis_and_angle_as_unit_quaternion]:
                  try:
                    conv(
                      axis=from_matrix.axis,
                      angle=from_matrix.angle(deg=deg),
                      deg=deg,
                      min_axis_length=1+1.e-5)
                  except RuntimeError: pass
                  else: raise Exception_expected
  rot_matrices_vectorized = scitbx.math.r3_rotation_axis_and_angle_as_matrix(
      rot_axes, rot_angles, deg=True)
  for a,b in zip(rot_matrices, rot_matrices_vectorized):
    assert a==b
  #
  for i_trial in range(100):
    r = flex.random_double_r3_rotation_matrix()
    from_matrix = scitbx.math.r3_rotation_axis_and_angle_from_matrix(r=r)
    rr = from_matrix.as_matrix()
    assert approx_equal(rr, r)
    assert approx_equal(math.cos(from_matrix.angle()), (r[0]+r[4]+r[8]-1)/2)
    q = matrix.col(from_matrix.as_unit_quaternion())
    assert approx_equal(abs(q), 1)
    rq = scitbx.math.r3_rotation_unit_quaternion_as_matrix(q=q)
    assert approx_equal(rq, r)
    rq = matrix.col(q).unit_quaternion_as_r3_rotation_matrix()
    assert approx_equal(rq, r)

def unit_quaternion_matrix_timings(n_trials=50, n_repeats=500):
  cpp_um = scitbx.math.r3_rotation_unit_quaternion_as_matrix
  cpp_mu = scitbx.math.r3_rotation_matrix_as_unit_quaternion
  times = [0,0,0,0]
  for i_trial in range(n_trials):
    qm = matrix.col.random(n=4, a=-1, b=1).normalize()
    rm = qm.unit_quaternion_as_r3_rotation_matrix()
    q = qm.elems
    r = cpp_um(q=q)
    t0 = time.time()
    for i_repeat in range(n_repeats):
      qm.unit_quaternion_as_r3_rotation_matrix()
    times[0] += time.time()-t0
    t0 = time.time()
    for i_repeat in range(n_repeats):
      rm.r3_rotation_matrix_as_unit_quaternion()
    times[1] += time.time()-t0
    t0 = time.time()
    for i_repeat in range(n_repeats):
      cpp_um(q=q)
    times[2] += time.time()-t0
    t0 = time.time()
    for i_repeat in range(n_repeats):
      cpp_mu(r=r)
    times[3] += time.time()-t0
  print("times unit quaternion <-> matrix")
  print("     py: %.2f %.2f s" % (times[0], times[1]))
  print("    c++: %.2f %.2f s" % (times[2], times[3]))
  if (times[2] != 0 and times[3] != 0):
    print("  ratio: %.2f %.2f" % (times[0]/times[2], times[1]/times[3]))
  sys.stdout.flush()

def check_vector_to_vector(g, t):
  assert approx_equal(abs(matrix.col(g)), 1)
  assert approx_equal(abs(matrix.col(t)), 1)
  r = matrix.sqr(vector_to_vector(given_unit_vector=g, target_unit_vector=t))
  assert approx_equal(r * matrix.col(g), t)
  assert approx_equal(r.determinant(), 1)

def check_vector_to_001(g):
  assert approx_equal(abs(matrix.col(g)), 1)
  r = matrix.sqr(vector_to_001(given_unit_vector=g))
  assert approx_equal(r * matrix.col(g), (0,0,1))
  assert approx_equal(r.determinant(), 1)
  p = matrix.col(g).vector_to_001_rotation()
  assert approx_equal(p * matrix.col(g), (0,0,1))
  assert approx_equal(p.determinant(), 1)
  assert approx_equal(p, r)

def check_vector_to_010(g):
  assert approx_equal(abs(matrix.col(g)), 1)
  r = matrix.sqr(vector_to_010(given_unit_vector=g))
  assert approx_equal(r * matrix.col(g), (0,1,0))
  assert approx_equal(r.determinant(), 1)

def check_vector_to_100(g):
  assert approx_equal(abs(matrix.col(g)), 1)
  r = matrix.sqr(vector_to_100(given_unit_vector=g))
  assert approx_equal(r * matrix.col(g), (1,0,0))
  assert approx_equal(r.determinant(), 1)

def exercise_vector_to_vector(angle_exponent_step=10, n_trials=10):
  principal_vectors = [matrix.col(v) for v in ((1,0,0), (0,1,0), (0,0,1))]
  for g0 in principal_vectors:
    for t0 in principal_vectors:
      for g in [g0, -g0]:
        for t in [t0, -t0]:
          check_vector_to_vector(g=g, t=t)
  if (sys.platform.startswith("osf")):
    max_exp = 300
  else:
    max_exp = 340
  for ig,g0 in enumerate(principal_vectors):
    for it,t0 in enumerate(principal_vectors):
      if (ig == it): continue
      axis = g0.cross(t0)
      for e in range(0, max_exp, angle_exponent_step):
        angle = 10**(-e)
        for angle in [angle, -angle]:
          r = matrix.sqr(scitbx.math.r3_rotation_axis_and_angle_as_matrix(
            axis=axis,
            angle=angle))
          for g in [g0, -g0]:
            for t in [t0, -t0]:
              check_vector_to_vector(g, r*t)
              check_vector_to_vector(r*g, t)
              check_vector_to_vector(r*g, r*t)
  for i_trial in range(n_trials):
    g = matrix.col(flex.random_double_point_on_sphere())
    check_vector_to_vector(g, g)
    check_vector_to_vector(g, -g)
    t = matrix.col(flex.random_double_point_on_sphere())
    check_vector_to_vector(g, t)
    for e in range(0, max_exp, angle_exponent_step):
      angle = 10**(-e)
      for angle in [angle, -angle]:
        rt = matrix.sqr(scitbx.math.r3_rotation_axis_and_angle_as_matrix(
          axis=g,
          angle=angle)) * t
        check_vector_to_vector(rt, t)
        check_vector_to_vector(rt, -t)
  #
  check_vector_to_001((0,0,1))
  check_vector_to_001((0,0,-1))
  for e in range(0, max_exp, angle_exponent_step):
    angle = 10**(-e)
    for angle in [angle, -angle]:
      rg = matrix.sqr(scitbx.math.r3_rotation_axis_and_angle_as_matrix(
        axis=(1,1,0),
        angle=angle)) * matrix.col((0,0,1))
      check_vector_to_001(rg)
      check_vector_to_001(-rg)
  for i_trial in range(n_trials):
    g = matrix.col(flex.random_double_point_on_sphere())
    check_vector_to_001(g)
  #
  check_vector_to_010((0,1,0))
  check_vector_to_010((0,-1,0))
  for e in range(0, max_exp, angle_exponent_step):
    angle = 10**(-e)
    for angle in [angle, -angle]:
      rg = matrix.sqr(scitbx.math.r3_rotation_axis_and_angle_as_matrix(
        axis=(1,0,1),
        angle=angle)) * matrix.col((0,1,0))
      check_vector_to_010(rg)
      check_vector_to_010(-rg)
  for i_trial in range(n_trials):
    g = matrix.col(flex.random_double_point_on_sphere())
    check_vector_to_010(g)
  #
  check_vector_to_100((1,0,0))
  check_vector_to_100((-1,0,0))
  for e in range(0, max_exp, angle_exponent_step):
    angle = 10**(-e)
    for angle in [angle, -angle]:
      rg = matrix.sqr(scitbx.math.r3_rotation_axis_and_angle_as_matrix(
        axis=(0,1,1),
        angle=angle)) * matrix.col((1,0,0))
      check_vector_to_100(rg)
      check_vector_to_100(-rg)
  for i_trial in range(n_trials):
    g = matrix.col(flex.random_double_point_on_sphere())
    check_vector_to_100(g)
  #
  rvv = vector_to_vector((0,0,-1), (0,0,1))
  rv1 = vector_to_001((0,0,-1))
  assert approx_equal(rv1, rvv)
  rvv = vector_to_vector((0,-1,0), (0,1,0))
  rv1 = vector_to_010((0,-1,0))
  assert approx_equal(rv1, rvv)
  rvv = vector_to_vector((-1,0,0), (1,0,0))
  rv1 = vector_to_100((-1,0,0))
  assert approx_equal(rv1, rvv)

def exercise():
  exercise_axis_and_angle()
  unit_quaternion_matrix_timings()
  exercise_vector_to_vector()
  print(format_cpu_times())

if (__name__ == "__main__"):
  exercise()


 *******************************************************************************


 *******************************************************************************
scitbx/math/tests/tst_resample.py
from __future__ import absolute_import, division, print_function
import scitbx.math
from scitbx.array_family import flex
import math
from six.moves import range

def test_resample(seed=0):
  obs_ori=flex.double(range(20))

  npb_draw = scitbx.math.non_parametric_bootstrap( obs_ori, -seed-1 )
  obs = npb_draw.draw( 100 )

  npb = scitbx.math.non_parametric_bootstrap( obs, -seed-2)
  sbs = scitbx.math.smooth_bootstrap( obs, -seed-3 )

  mean_t = flex.mean( obs_ori )
  var_t =  flex.mean( obs_ori*obs_ori ) - mean_t*mean_t

  mean_of_mean = 0
  var_of_mean = 0

  mean_sbs = 0
  std_sbs = 0

  n_sample=1e3
  size = 100.0
  for iteration in range(int(n_sample)):
    sample = npb.draw(int(size))
    sample_2 = sbs.draw(int(size))

    single_mean = flex.mean( sample )
    mean_of_mean += single_mean
    var_of_mean += single_mean*single_mean

    tmp = flex.mean( sample_2 )
    mean_sbs += tmp
    std_sbs += tmp*tmp

  mean_of_mean = mean_of_mean/n_sample
  var_of_mean = var_of_mean/(n_sample) - mean_of_mean*mean_of_mean
  var_of_mean  = math.sqrt( var_of_mean )

  mean_sbs /=n_sample
  std_sbs = (std_sbs/(n_sample))-mean_sbs*mean_sbs
  std_sbs = math.sqrt( std_sbs )

  assert math.fabs(9.5-mean_of_mean)/var_of_mean < 4
  assert math.fabs(9.5-mean_sbs)/std_sbs < 4


def run():
  for ii in range(10):
    test_resample(ii)
  print("OK")

if (__name__ == "__main__"):
  run()


 *******************************************************************************


 *******************************************************************************
scitbx/math/tests/tst_similarity_indices.py
from __future__ import absolute_import, division, print_function
import scitbx.math

def exercise():
  x = [0.232, 0.002, 0.45, 1.2, 0.233, 1.2, 0.5, 0.231, 0,0,0,0,0]
  assert scitbx.math.similarity_indices(x=x, eps=0.01) == \
    [0, 1, 2, 3, 0, 3, 4, 0, 1, 1, 1, 1, 1]
  x = [0,2,0,2]
  assert scitbx.math.similarity_indices(x=x, eps=0.01) == [0, 1, 0, 1]
  x = [0,0,0,0]
  assert scitbx.math.similarity_indices(x=x, eps=0.01) == [0, 0, 0, 0]
  x = [1,2,3,4]
  assert scitbx.math.similarity_indices(x=x, eps=0.01) == [0, 1, 2, 3]

if (__name__ == "__main__"):
  exercise()
  print("OK")


 *******************************************************************************


 *******************************************************************************
scitbx/math/tests/tst_superpose.py
from __future__ import absolute_import, division, print_function
from scitbx.math.superpose import kabsch_rotation, kearsley_rotation, least_squares_fit
from scitbx.math import euler_angles_as_matrix
from scitbx.array_family import flex
from libtbx.test_utils import approx_equal
import random
from six.moves import range

if (1): # fixed random seed to avoid rare failures
  random.seed(0)
  flex.set_random_seed(0)

def random_rotation():
  return euler_angles_as_matrix([random.uniform(0,360) for i in range(3)])

def exercise_rotation():
  reference = flex.vec3_double(flex.random_double(10*3)*10-5)
  other = reference.deep_copy()
  assert approx_equal(kabsch_rotation(reference, other), [1,0,0,0,1,0,0,0,1])
  assert approx_equal(kearsley_rotation(reference, other), [1,0,0,0,1,0,0,0,1])
  # pure rotations
  for n_sites in [1,2,3,7,10,30]:
    reference = flex.vec3_double(flex.random_double(n_sites*3)*10-5)
    other = reference.deep_copy()
    for i_trial in range(10):
      c = random_rotation()
      other_c = tuple(c) * other
      kc = kabsch_rotation(reference, other_c)
      assert approx_equal(kc.elems * other_c, reference)
      kc = kearsley_rotation(reference, other_c)
      assert approx_equal(kc.elems * other_c, reference)
  for n_sites in [1,2,3,7,10,30]:
    reference = flex.vec3_double(flex.random_double(n_sites*3)*10-5)
    other = reference.deep_copy()
    for i_trial in range(10):
      other_s = other + flex.vec3_double(flex.random_double(n_sites*3)*0.5)
      ks = kabsch_rotation(reference, other_s)
      other_ks = ks.elems * other_s
      rms_ks = reference.rms_difference(other_ks)
      c = random_rotation()
      other_cs = tuple(c) * other_s
      kcs = kabsch_rotation(reference, other_cs)
      other_kcs = tuple(kcs) * other_cs
      rms_kcs = reference.rms_difference(other_kcs)
      assert approx_equal(rms_kcs, rms_ks)

      other_s = other + flex.vec3_double(flex.random_double(n_sites*3)*0.5)
      ks = kearsley_rotation(reference, other_s)
      other_ks = ks.elems * other_s
      rms_ks = reference.rms_difference(other_ks)
      c = random_rotation()
      other_cs = tuple(c) * other_s
      kcs = kearsley_rotation(reference, other_cs)
      other_kcs = tuple(kcs) * other_cs
      rms_kcs = reference.rms_difference(other_kcs)
      assert approx_equal(rms_kcs, rms_ks)

  #degenerate systems
  reference = flex.vec3_double([])
  kc = kabsch_rotation(reference, reference)
  assert approx_equal(kc.elems * reference, reference)
  reference = flex.vec3_double([(0,0,0)])
  kc = kabsch_rotation(reference, reference)
  assert approx_equal(kc.elems * reference, reference)
  reference = flex.vec3_double([(-1,0,0), (1,0,0)])
  kc = kabsch_rotation(reference, reference)
  assert approx_equal(kc.elems * reference, reference)
  other = flex.vec3_double([(0,-1,0), (0,1,0)])
  kc = kabsch_rotation(reference, other)
  assert approx_equal(kc.elems * other, reference)
  reference = flex.vec3_double([(-2,0,0), (-1,0,0), (1,0,0), (2,0,0)])
  kc = kabsch_rotation(reference, reference)
  assert approx_equal(kc.elems * reference, reference)
  other = flex.vec3_double([(0,-2,0), (0,-1,0), (0,1,0), (0,2,0)])
  kc = kabsch_rotation(reference, other)
  assert approx_equal(kc.elems * other, reference)
  reference = flex.vec3_double([(-1,0,0), (1,0,0), (0,-1,0), (0,1,0)])
  kc = kabsch_rotation(reference, reference)
  assert approx_equal(kc.elems * reference, reference)
  other = flex.vec3_double([(0,0,-1), (0,0,1), (0,-1,0), (0,1,0)])
  kc = kabsch_rotation(reference, other)
  assert approx_equal(kc.elems * other, reference)


  reference = flex.vec3_double([])
  kc = kearsley_rotation(reference, reference)
  assert approx_equal(kc.elems * reference, reference)
  reference = flex.vec3_double([(0,0,0)])
  kc = kearsley_rotation(reference, reference)
  assert approx_equal(kc.elems * reference, reference)
  reference = flex.vec3_double([(-1,0,0), (1,0,0)])
  kc = kearsley_rotation(reference, reference)
  assert approx_equal(kc.elems * reference, reference)
  other = flex.vec3_double([(0,-1,0), (0,1,0)])
  kc = kearsley_rotation(reference, other)
  assert approx_equal(kc.elems * other, reference)
  reference = flex.vec3_double([(-2,0,0), (-1,0,0), (1,0,0), (2,0,0)])
  kc = kearsley_rotation(reference, reference)
  assert approx_equal(kc.elems * reference, reference)
  other = flex.vec3_double([(0,-2,0), (0,-1,0), (0,1,0), (0,2,0)])
  kc = kearsley_rotation(reference, other)
  assert approx_equal(kc.elems * other, reference)
  reference = flex.vec3_double([(-1,0,0), (1,0,0), (0,-1,0), (0,1,0)])
  kc = kearsley_rotation(reference, reference)
  assert approx_equal(kc.elems * reference, reference)
  other = flex.vec3_double([(0,0,-1), (0,0,1), (0,-1,0), (0,1,0)])
  kc = kearsley_rotation(reference, other)
  assert approx_equal(kc.elems * other, reference)

def exercise(method):
  assert method in ["kearsley", "kabsch"]
  # global shifts
  for n_sites in [1,3,7,10,30]:
    reference = flex.vec3_double(flex.random_double(n_sites*3)*10-5)
    other = reference + list(flex.random_double(3)*100-50)
    for i_trial in range(10):
      s = least_squares_fit(reference, other, method)
      assert approx_equal(reference, s.other_sites_best_fit())
      c = random_rotation()
      s = least_squares_fit(reference, tuple(c)*other, method)
      if method == "kearsley": # Kabsch fails in special cases
        assert approx_equal(s.r.determinant(), 1)
      assert approx_equal(reference, s.other_sites_best_fit())
      assert approx_equal(s.rt().r, s.r)
      assert approx_equal(s.rt().t, s.t)
      assert approx_equal(reference, s.rt() * s.other_sites)

if (__name__ == "__main__"):
  exercise_rotation()
  exercise("kabsch")
  exercise("kearsley")
  print("OK")


 *******************************************************************************


 *******************************************************************************
scitbx/math/tests/tst_tetrahedron.py
from __future__ import absolute_import, division, print_function
from scitbx.math import tetrahedron
from libtbx.test_utils import approx_equal
from itertools import permutations
from random import random
from six.moves import range

def exercise_volume():
  for (a,b,c) in ((1,2,3), (2,3,1), (3,1,2)):
    for vertices in permutations(((1,1,1), (1+a,1,1), (1,1+b,1), (1,1,1+c))):
      t = tetrahedron(vertices)
      assert t.vertices == vertices
      vol = a*b*c/6
      assert approx_equal(t.volume(), vol)
  # regular tetrahedron
  for vertices in permutations(((1,1,1), (1,-1,-1), (-1,1,-1), (-1,-1,1))):
    t = tetrahedron(vertices)
    assert approx_equal(t.volume(), 8/3)

def exercise_gradients(n_points):
  eta = 1e-6
  for i in range(n_points):
    v = tuple((random(), random(), random()) for j in range(4))
    t = tetrahedron(v)
    g = t.gradients()
    for j in range(4):
      for k in range(3):
        (tm, tp) = tuple(tetrahedron(
          v[:j] + (v[j][:k] + (v[j][k] + h,) + v[j][k+1:],) + v[j+1:])
          for h in (-eta, eta))
        dv = (tp.volume() - tm.volume())/(2*eta)
        assert approx_equal(dv, g[j][k]), (j,k)

def run():
  exercise_volume()
  exercise_gradients(n_points=100)
  print('OK')

if __name__ == '__main__':
  run()


 *******************************************************************************


 *******************************************************************************
scitbx/math/tests/tst_uniform_rotation_matrix.py
from __future__ import absolute_import, division, print_function
import math, random
from scitbx import matrix
from scitbx.array_family import flex
from six.moves import range

# -----------------------------------------------------------------------------
# simplified form of surface integral for spherical harmonic (l = m)
# http://en.wikipedia.org/wiki/Table_of_spherical_harmonics
def ylm(lm,c,t,p):
  y = c * math.pow(math.sin(t),lm) * complex(math.cos(lm*p),math.sin(lm*p))
  return y * y.conjugate() * math.sin(t)

# -----------------------------------------------------------------------------
def add_point(lm,c,R):

  x = matrix.col( [0,0,1] )
  new_x = R * x

  theta = math.acos(new_x[2])                    # theta = [0, pi]
  phi = math.atan2(new_x[1],new_x[0]) + math.pi  # phi = [0, 2pi)

  return ylm(lm,c,theta,phi)

# -----------------------------------------------------------------------------
def test_uniform_rotation_matrix(N=10000,choice=2,verbose=False):
  r"""
  The surface integral of a spherical harmonic function with its conjugate
  should be 1. (http://mathworld.wolfram.com/SphericalHarmonic.html, Eq 7)

  From Mathematica,

  l = 10;
  m = 10;
  y = SphericalHarmonicY[l, m, \[Theta], \[Phi]];
  Integrate[y*Conjugate[y]*Sin[\[Theta]], {\[Theta], 0, Pi}, {\[Phi], 0, 2*Pi}]

  should yield 1.

  By picking uniformly random points on a sphere, the surface integral can be
  numerically approximated.

  The results in the comments below are for N = 1 000 000.
  """
  if (choice == 0):
    # l=1, m=1
    # result = (0.883199394206+0j) (0.883824001444+0j)
    lm = 1
    c = -0.5 * math.sqrt(1.5/math.pi)
  elif (choice == 1):
    # l = 5, m = 5
    # result = (0.959557841214+0j) (0.959331535539+0j)
    lm = 5
    c = -(3/32) * math.sqrt(77/math.pi)
  else:
    # l = 10, m = 10
    # result = (0.977753926603+0j) (0.97686871766+0j)
    lm = 10
    c = (1/1024) * math.sqrt(969969/math.pi)

  result = [ 0.0, 0.0 ]
  for i in range(N):
    R  = [ matrix.sqr(flex.random_double_r3_rotation_matrix()),
           matrix.sqr(flex.random_double_r3_rotation_matrix_arvo_1992()) ]
    for j in range(len(result)):
      result[j] += add_point(lm,c,R[j])

  # multipy by area at the end, each point has an area of 4pi/N
  point_area = 4.0*math.pi/N  # surface area of unit sphere / number of points
  for i in range(len(result)):
    result[i] = point_area * result[i]
    if (verbose):
      print(result[i], end=' ')
  if (verbose):
    print()

  assert(result[0].real > 0.85)
  assert(result[0].real < 1.15)
  assert(result[1].real > 0.85)
  assert(result[1].real < 1.15)

if (__name__ == '__main__'):
  flex.set_random_seed(0)
  for i in range(3):
    test_uniform_rotation_matrix(N=1000, choice=i, verbose=False)
  print('OK')


 *******************************************************************************


 *******************************************************************************
scitbx/math/tests/tst_weighted_correlation.py
from __future__ import absolute_import, division, print_function
from scitbx.array_family import flex
from libtbx.test_utils import approx_equal
from six.moves import range

class simple_weighted_correlation(object): # used for data merging
  def __init__(self,w, x, y, derivatives_wrt_y_depth=0):
    import math
    assert derivatives_wrt_y_depth==0 # no derivatives implemented presently

    sum_xx = flex.sum(w * x**2)
    sum_yy = flex.sum(w * y**2)
    sum_xy = flex.sum(w * x * y)
    sum_x = flex.sum(w * x)
    sum_y = flex.sum(w * y)
    sum_w = flex.sum(w)
    assert sum_w != 0
      # Linear fit y to x, i.e. find slope and offset such that
      # y = slope * x + offset, optimal in a least-squares sense.
      # see p. 105 in Bevington & Robinson, Data Reduction and Error Analysis for
      #   the Physical Sciences, 3rd edition.  New York: McGraw Hill (2003)
    DELTA = sum_w * sum_xx - sum_x**2
    assert DELTA != 0
    self.slope = (sum_w * sum_xy - sum_x * sum_y) / DELTA
    self.offset = (sum_xx * sum_y - sum_x * sum_xy) / DELTA
    self.corr = (sum_w * sum_xy - sum_x * sum_y) / (math.sqrt(sum_w * sum_xx - sum_x**2) *
                                                    math.sqrt(sum_w * sum_yy - sum_y**2))

def weighted_correlation(w, x, y, derivatives_wrt_y_depth=0):
  "http://en.wikipedia.org/wiki/Pearson_product-moment_correlation_coefficient#Calculating_a_weighted_correlation"
  assert derivatives_wrt_y_depth in [0,1,2]
  sum_w = flex.sum(w)
  assert sum_w != 0
  wxm = flex.sum(w * x) / sum_w
  wym = flex.sum(w * y) / sum_w
  xc = x - wxm
  yc = y - wym
  sum_wxy = flex.sum(w * xc * yc)
  sum_wxx = flex.sum(w * xc * xc)
  sum_wyy = flex.sum(w * yc * yc)
  cc_den_sq = sum_wxx * sum_wyy
  cc_den = cc_den_sq**0.5
  cc = sum_wxy / cc_den
  if (derivatives_wrt_y_depth == 0):
    return cc
  #
  # 1st derivatives w.r.t. y
  d_sum_wxy = w * xc
  d_sum_wyy = 2 * w * yc
  d_cc_den_sq = sum_wxx * d_sum_wyy
  d_cc_den = 1/2 * d_cc_den_sq / cc_den
  d_cc_num = d_sum_wxy * cc_den - sum_wxy * d_cc_den
  d_cc = d_cc_num / cc_den_sq
  if (derivatives_wrt_y_depth == 1):
    return cc, d_cc
  #
  # 2nd derivatives w.r.t. y
  d_yc = 1 - w / sum_w
  d2_sum_wyy = 2 * w * d_yc
  d2_cc_den_sq = sum_wxx * d2_sum_wyy
  d2_cc_den = 1/2 * (d2_cc_den_sq / cc_den - d_cc_den_sq * d_cc_den / cc_den_sq)
  d2_cc_num = -sum_wxy * d2_cc_den
  d2_cc = d2_cc_num / cc_den_sq - d_cc_num * d_cc_den_sq / cc_den_sq**2
  return cc, d_cc, d2_cc

def finite_difference_derivatives(w, x, y, depth, eps=1e-6):
  assert depth in [1,2]
  result = flex.double()
  for i in range(len(y)):
    fs = []
    y_orig = y[i]
    for signed_eps in [eps, -eps]:
      y[i] = y_orig + signed_eps
      if (depth == 1):
        fs.append(weighted_correlation(w, x, y))
      else:
        _, d_cc = weighted_correlation(w, x, y, derivatives_wrt_y_depth=1)
        fs.append(d_cc[i])
    y[i] = y_orig
    result.append((fs[0]-fs[1])/(2*eps))
  return result

def exercise():
  mt = flex.mersenne_twister(seed=0)
  sz = 12
  for i_trial in range(10):
    x = mt.random_double(size=sz)*5-1
    y = mt.random_double(size=sz)*3-1
    for i_w,w in enumerate([flex.double(sz, 1), mt.random_double(size=sz)*7]):
      cc, d_cc, d2_cc = weighted_correlation(
        w, x, y, derivatives_wrt_y_depth=2)
      if (i_w == 0):
        cc_w1 = flex.linear_correlation(x, y).coefficient()
        assert approx_equal(cc, cc_w1)
      simple_cc = simple_weighted_correlation(w, x, y).corr
      assert approx_equal(simple_cc, cc)
      d_cc_fd = finite_difference_derivatives(w, x, y, depth=1)
      assert approx_equal(d_cc, d_cc_fd)
      d2_cc_fd = finite_difference_derivatives(w, x, y, depth=2)
      assert approx_equal(d2_cc, d2_cc_fd)

def run(args):
  assert len(args) == 0
  exercise()
  print("OK")

if (__name__ == "__main__"):
  import sys
  run(args=sys.argv[1:])


 *******************************************************************************


 *******************************************************************************
scitbx/math/tst_2d_zernike.py
from __future__ import absolute_import, division, print_function
import scitbx.math
from scitbx import differential_evolution as de
from scitbx import simplex
from scitbx import lbfgs
from scitbx import direct_search_simulated_annealing as dssa
from scitbx.array_family import flex
from scitbx.stdlib import math
import time, sys
from fractions import Fraction
from six.moves import range
from six.moves import zip

def read_data(filename):
  file=open(filename, 'r')
  data=flex.vec3_double()
  for line in file:
    keys=line.split()
    if(len(keys)==3):
      x=int(keys[0])
      y=int(keys[1])
      z=float(keys[2])
      data.append([x,y,z])
  file.close()
  return data

def generate_image(n,l, N=100):
  nmax = max(20,n)
  lfg =  scitbx.math.log_factorial_generator(nmax)
  #rzfa = scitbx.math.zernike_2d_radial(n,l,lfg)
  #rap = scitbx.math.zernike_2d_polynome(n,l,rzfa)
  rap = scitbx.math.zernike_2d_polynome(n,l)#,rzfa)

  image = flex.vec3_double()

  original=open('original.dat','w')
  count = 0
  for x in range(-N, N+1):
    for y in range(-N, N+1):
      rr = math.sqrt(x*x+y*y)/N
      if rr>1.0:
        value=0.0
      else:
        tt = math.atan2(y,x)
        value = rap.f(rr,tt)
        value = value.real
        count = count + 1
      image.append([x+N,y+N,value])
      print(x+N,y+N, value, file=original)
  original.close()
  return image

def tst_2d_zernike_mom(n,l, N=100, filename=None):
  nmax = max(20,n)
  rebuilt=open('rebuilt.dat','w')
  tt1=time.time()
  if(filename is not None):
    image=read_data(filename)
  else:
    image=generate_image(n,l)

  NP=int(math.sqrt( image.size() ))
  N=NP/2
  grid_2d = scitbx.math.two_d_grid(N, nmax)
  grid_2d.clean_space( image )
  grid_2d.construct_space_sum()
  tt2=time.time()
  print("time used: ", tt2-tt1)
  zernike_2d_mom = scitbx.math.two_d_zernike_moments( grid_2d, nmax )

  moments = zernike_2d_mom.moments()

  tt2=time.time()
  print("time used: ", tt2-tt1)

  coefs = flex.real( moments )
  nl_array = scitbx.math.nl_array( nmax )
  nls = nl_array.nl()
  nl_array.load_coefs( nls, coefs )
  lfg =  scitbx.math.log_factorial_generator(nmax)

  print(nl_array.get_coef(n,l)*2)

  for nl, c in zip( nls, moments):
    if(abs(c)<1e-3):
      c=0
    print(nl, c)

  print()
  reconst=flex.complex_double(NP**2, 0)
  for nl,c in zip( nls, moments):
    n=nl[0]
    l=nl[1]
    if(l>0):
      c=c*2
    #rzfa = scitbx.math.zernike_2d_radial(n,l,lfg)
    rap = scitbx.math.zernike_2d_polynome(n,l) #,rzfa)
    i=0
    for x in range(0,NP):
      x=x-N
      for y in range(0,NP):
        y=y-N
        rr = math.sqrt(x*x+y*y)/N
        if rr>1.0:
          value=0.0
        else:
          tt = math.atan2(y,x)
          value = rap.f(rr,tt)
        reconst[i]=reconst[i]+value*c
        i=i+1

  i = 0
  for x in range(0,NP):
    for y in range(0,NP):
      value=reconst[i].real
      if(value>0):
        print(x,y,image[i][2],value, file=rebuilt)
      i=i+1


  rebuilt.close()


def tst_2d_poly(n,l):
  nmax=max(n,20)
  np=50
  x,y=0.1,0.9
  r,t=math.sqrt(x*x+y*y),math.atan2(y,x)
  lfg =  scitbx.math.log_factorial_generator(nmax)
  #rzfa = scitbx.math.zernike_2d_radial(n,l,lfg)
  #rap = scitbx.math.zernike_2d_polynome(n,l,rzfa)
  rap = scitbx.math.zernike_2d_polynome(n,l)#,rzfa)
  rt_value=rap.f(r,t)
  grid = scitbx.math.two_d_grid(np, nmax)
  zm2d = scitbx.math.two_d_zernike_moments(grid, nmax)
  xy_value=zm2d.zernike_poly(n,l,x,y)

  print(rt_value, xy_value, abs(rt_value), abs(xy_value))

def tst_2d_zm(n,l):
  nmax=max(n,20)
  np=100
  points=flex.double(range(-np,np+1))/np
  grid = scitbx.math.two_d_grid(np, nmax)
  zm2d = scitbx.math.two_d_zernike_moments(grid, nmax)
  image = flex.vec3_double()

  output=file('testmap.dat','w')

  for x in points:
    for y in points:
      r=math.sqrt(x*x+y*y)
      if(r>1.0):
        value=0.0
      else:
        value=zm2d.zernike_poly(n,l,x,y).real
      image.append([x*np+np,y*np+np, value])

  grid.clean_space( image )
  grid.construct_space_sum()
  zernike_2d_mom = scitbx.math.two_d_zernike_moments( grid, nmax )

  moments = zernike_2d_mom.moments()

  coefs = flex.real( moments )
  nl_array = scitbx.math.nl_array( nmax )
  nls = nl_array.nl()

  for nl, c in zip( nls, moments):
    if(abs(c)<1e-3):
      c=0
    print(nl, c)

  NP=np*2+1
  reconst=zernike_2d_mom.zernike_map(nmax, np)
  i = 0
  for x in range(0,NP):
    for y in range(0,NP):
      value=reconst[i].real
      if(value>0):
        print(x,y,image[i][2],value, file=output)
      i=i+1


  output.close()


def integrate_triple_zernike2d(n1,n2,n3,m, Bnmk_obj):
  value=Fraction(0)
  temp = long(0)
  ck = [long(0)]*(n1+n2+n3+1)
  for k1 in range(m,n1+1,2):
    for k2 in range(m,n2+1,2):
      for k3 in range(m,n3+1,2):
       # value = value+Bnmk_obj.get_coef(n1,m,k1)*Bnmk_obj.get_coef(n2,m,k2)*Bnmk_obj.get_coef(n3,m,k3)/(k1+k2+k3+2.0)
        temp = Bnmk_obj.get_coef(n1,m,k1)*Bnmk_obj.get_coef(n2,m,k2)*Bnmk_obj.get_coef(n3,m,k3)
        ck[k1+k2+k3] = ck[k1+k2+k3]+temp

  for kk in range(3*m,n1+n2+n3+1,2):
  #  print "%4d, %30d"%(kk,ck[kk])
    value = value + Fraction( ck[kk],(kk+2))
  return float(value)

class Bnmk(object):
  "Bnmk coefficient object hold 2d zernike expansion coefs"
  def __init__(self, nmax):
    self.nmax=nmax
    self.Bnmk=scitbx.math.nmk_array(nmax)
    self.initialize_bnmk()

  def initialize_bnmk(self):
    for n in range(self.nmax, -1,-1):
      self.Bnmk.set_coef(n,n,n,1.0)
      for m in range(n-2,-1,-2):
        value = self.Bnmk.get_coef(n,m+2,n)*(n+m+2.0)/(n-m)
        self.Bnmk.set_coef(n,m,n,value)
        for k in range(n-2,m-1,-2):
          value = -self.Bnmk.get_coef(n,m,k+2)*(k+m+2.0)*(k+2.0-m)/(k+2.0+n)/(n-k)
          self.Bnmk.set_coef(n,m,k,value)

  def get_coef(self,n,m,k):
    return int(self.Bnmk.get_coef(n,m,k).real)

  def print_bnmk(self):
    for n in range(self.nmax+1):
      for m in range(n,-1,-2):
        for k in range(m,n+1,2):
          print(n,m,k,self.get_coef(n,m,k))


def tst_integral_triple_zernike2d(nmax):
  Bnmk_obj = Bnmk(nmax)
  #Bnmk_obj.print_bnmk()
  coef_table = []

  for m in range(nmax+1):
    C_m_3n = scitbx.math.nmk_array(nmax)
    for n1 in range(m,nmax+1,2):
      for n2 in range(m,n1+1,2):
        for n3 in range(m,n2+1,2):
          value = integrate_triple_zernike2d(n1,n2,n3,m,Bnmk_obj)
          C_m_3n.set_coef(n1,n2,n3,value)
        #  print m,n1,n2,n3,value.real
    coef_table.append( C_m_3n )
  return coef_table

def calc_Cnm_4m_from_Inm(m, nmax, Inm, coef_table_m):
  Cnm_m=flex.double()
  for n in range(m, nmax+1, 2 ):
    temp = 0
    for n1 in range( m,nmax+1,2 ):
      n1_indx = (n1-m)/2
      for n2 in range( m,nmax+1,2 ):
        n2_indx = (n2-m)/2
        i,j,k=sorted([n,n1,n2],reverse=True)
        temp = temp + coef_table_m.get_coef(i,j,k).real*Inm[n1_indx]*Inm[n2_indx]
    Cnm_m.append( temp )
  return Cnm_m


def calc_Cnm_from_Inm( Inm, coef_table, nmax ):
  Cnm=scitbx.math.nl_array(nmax)
  for n in range( 0,nmax+1,2 ): # only even number (n,m)
    for m in range(0,n+1,2 ):
      temp = 0
      for n1 in range( m,nmax+1,2 ):
        for n2 in range( m,n1,2 ):
          i,j,k=sorted([n,n1,n2],reverse=True)
          temp = temp + coef_table[m].get_coef(i,j,k).real*Inm.get_coef(n1,m)*Inm.get_coef(n2,m)

        i,j,k=sorted([n,n1,n1],reverse=True)
        temp = temp + coef_table[m].get_coef(i,j,k).real*Inm.get_coef(n1,m)**2.0/2.0
      Cnm.set_coef(n,m,temp*2.0)
  return Cnm


def comp_Cnm_calculations(nmax):
  Inm=scitbx.math.nl_array(nmax)
  nls = Inm.nl()
  size = nls.size()
  coefs = flex.random_double(size)
  Inm.load_coefs( nls, coefs )
  coef_table = tst_integral_triple_zernike2d(nmax)
  Cnm = calc_Cnm_from_Inm(Inm, coef_table, nmax )

  for mm in range(0,nmax+1,2):
    coef_table_m = coef_table[mm]
    Inm_m=flex.double()
    Cnm_m=flex.double()
    for nn in range(mm,nmax+1,2):
      Inm_m.append( Inm.get_coef(nn,mm) )
      Cnm_m.append( Cnm.get_coef(nn,mm) )
    Cnm_m_new = calc_Cnm_4m_from_Inm(mm,nmax,Inm_m,coef_table_m)

    for ii,jj in zip(Cnm_m, Cnm_m_new):
      assert(abs(ii-jj)<1e-6)




def tst_solving_Inm(nmax):
  Inm=scitbx.math.nl_array(nmax)
  nls = Inm.nl()
  size = nls.size()
  coefs = flex.random_double(size)
  Inm.load_coefs( nls, coefs )

  coef_table = tst_integral_triple_zernike2d(nmax)
  Cnm = calc_Cnm_from_Inm( Inm, coef_table, nmax )

  new_Inm=scitbx.math.nl_array(nmax)

  for n in range( nmax+1 ):
    for m in range(n,-1,-2):
      Cnm_value = Cnm.get_coef( n, m )
      coef = coef_table[m].get_coef(n,n,n).real
#      value = math.sqrt( Cnm_value/coef )
      if(coef != 0):
        value = ( Cnm_value/coef )
        print(n,m,Inm.get_coef(n,m)**2, value)


class inm_refine(object):
  def __init__(self, nmax, Cnm, coef_table,m):
    self.nmax=nmax
    self.Cnm = Cnm
    self.coef_table = coef_table
    self.Inm = scitbx.math.nl_array(nmax)

    self.m=m ## testing the most populated cases
    self.coef_table_m = self.coef_table[self.m]
    self.x = None
    self.ndim = (self.nmax-self.m)/2+1
    self.n = self.ndim
    self.domain =[(-1.0,1.0)]*self.ndim
    self.target_data=flex.double()
    self.n_list=range(self.m,nmax+1,2)
    self.n_indx_list=range(self.ndim)
    for nn in self.n_list:
      self.target_data.append( self.Cnm.get_coef(nn,self.m) )
#    self.solution=flex.random_double(self.n)*2-1
#    self.target_data=self.calc_Cnm_from_Inm(self.solution)
    self.scale = self.target_data.norm()**2
#    self.optimizer = de.differential_evolution_optimizer(self, population_size=self.ndim,eps=1e-8,n_cross=self.n/2)
#    self.run_simplex()
#    self.run_dssa()
    lowest_score=1e8
    for ii in range(10):
      self.run_lbfgs()
      score=self.target(self.x)
      if(score < lowest_score):
        lowest_score=score
        self.best_solution=self.x.deep_copy()
      print(list(self.x), score)
    print(lowest_score)

  def run_lbfgs(self):
    self.h = 0.000001
    self.x = flex.random_double(self.n)*2-1
    lbfgs.run(target_evaluator=self)

  def compute_functional_and_gradients(self):
   # t, dd = self.derivs( self.x , h=self.h)
    t=self.target(self.x)
    dd = self.analytic_f_prime(self.x)
    return t, dd

  def derivs(self,vector,h=0.0001):
    t  = self.target(vector)
    dd = []
    for ii in range(vector.size()):
      vector_1 = vector.deep_copy()
      vector_1[ii]=vector_1[ii]+h
      th = self.target(vector_1)
      delta = (th-t)/h
      dd.append( delta )
    delta = flex.double(dd)
    return t,delta

  def callback_after_step(self, minimizer):
    return

  def run_dssa(self):
    start_matrix=[]
    for ii in range(self.n):
      start_matrix.append( flex.random_double(self.n)*2.0-1.0 )
    start_matrix.append( flex.double(self.n,0) )
    self.optimizer = dssa.dssa( dimension=self.n, matrix=start_matrix, evaluator=self, tolerance=1e-5, further_opt=True )
    self.x = self.optimizer.get_solution()


  def run_simplex(self):
    start_matrix=[]
    for ii in range(self.n):
      start_matrix.append( flex.random_double(self.n)*2.0-1.0 )
    start_matrix.append( flex.double(self.n,0) )
    self.optimizer = simplex.simplex_opt( dimension=self.n, matrix=start_matrix, evaluator=self, tolerance=1e-5 )
    self.x = self.optimizer.get_solution()

  def analytic_f_prime(self,Inm):
    f_prime=flex.double()
    pre_factor=(self.calc_data-self.target_data)*(4.0)/self.scale

    for n in self.n_list:
      temp = 0
      for n1,n1_indx in zip(self.n_list,self.n_indx_list):
        temp1 = 0
        for n2,n2_indx in zip(self.n_list,self.n_indx_list):
          i,j,k=sorted([n,n1,n2],reverse=True)
          temp1 = temp1 + self.coef_table_m.get_coef(i,j,k).real*Inm[n2_indx]
        temp = temp+temp1*pre_factor[n1_indx]
      f_prime.append(temp)
    return f_prime


  def target(self, x):
    self.calc_data=self.calc_Cnm_from_Inm(x)
    score = flex.sum_sq( self.calc_data-self.target_data)
    return score/self.scale

  def calc_Cnm_from_Inm(self, Inm):
    Cnm=flex.double()
    for n in range(self.m,self.nmax+1,2):
      temp = 0
      for n1 in range(self.m,self.nmax+1,2):
        n1_indx = (n1-self.m)/2
        for n2 in range(self.m,self.nmax+1,2):
          n2_indx = (n2-self.m)/2
          i,j,k=sorted([n,n1,n2],reverse=True)
          temp = temp + self.coef_table_m.get_coef(i,j,k).real*Inm[n1_indx]*Inm[n2_indx]
      Cnm.append( temp )
    return Cnm

def test_solving(nmax, m):
  Inm=scitbx.math.nl_array(nmax)
  nls = Inm.nl()
  size = nls.size()
  coefs = flex.random_double(size)
  Inm.load_coefs( nls, coefs )

  coef_table = tst_integral_triple_zernike2d(nmax)
  Cnm = calc_Cnm_from_Inm( Inm, coef_table, nmax )
  t1 = time.time()
  refine_de_obj = inm_refine( nmax, Cnm, coef_table, m )
  solution=flex.double()
  for nn in range(m,nmax+1,2):
    solution.append( Inm.get_coef(nn,m) )
  for ss,xx in zip(solution, refine_de_obj.best_solution):
    print(ss,xx)
  print("score=",refine_de_obj.target(refine_de_obj.x))
  print("score=",refine_de_obj.target(solution))
  t2 = time.time()
  print("nmax=",nmax, "time used:", t2-t1)




if __name__ == "__main__":
  args = sys.argv[1:]
  if(len(args) == 4):
    m=int(args[0])
    n1=int(args[1])
    n2=int(args[2])
    n3=int(args[3])
    Bnmk_obj = Bnmk(max(n1,n2,n3))
    print(integrate_triple_zernike2d(n1,n2,n3,m,Bnmk_obj))
    exit()

  if(len(args) == 1):
    nmax=int(args[0])
  elif(len(args)==0):
    nmax=5
  if(len(args) == 2):
    nmax=int(args[0])
    m=int(args[1])
    assert m<=nmax
    test_solving(nmax,m)
  exit()
  tst_integral_triple_zernike2d(nmax)
  comp_Cnm_calculations(nmax)


  exit()


  t1=time.time()
  tst_2d_zm(41,1)
  t2=time.time()
  print("xy:  ", t2-t1)
  tst_2d_zernike_mom(41,1)
  t3=time.time()
  print("rt:  ", t3-t2)
  exit()

  tst_2d_poly(51,19)
  exit()
  t1 = time.time()
  args = sys.argv[1:]
  filename=None
  if( len(args) > 0 ):
    filename = args[0]
  tst_2d_zernike_mom(30,2, filename=filename)
  exit()

  tst_2d_zernike_mom(17,3)
  tst_2d_zernike_mom(16,2)
  tst_2d_zernike_mom(14,12)
  #tst_2d_random(20)
  t2 = time.time()
  print("time used: ", t2-t1)
  print("OK")


 *******************************************************************************


 *******************************************************************************
scitbx/math/tst_bessel_zeros.py
from __future__ import absolute_import, division, print_function
from scitbx import math
from six.moves import range

def tst_sph_zeroes(l,n):
  z = math.sph_bessel_j_zeroes(l,n)
  fz = math.spherical_bessel_array(l,z)
  for ff in fz:
    assert abs(ff) < 1e-8

def tst_bessel_zeroes(l,n):
  z = math.bessel_J_zeroes(l,n)
  fz = math.bessel_J_array(l,z)
  for ff in fz:
    assert abs(ff) < 1e-8


def tst_all():
  for ii in range(30):
     tst_sph_zeroes(ii,100)
     tst_bessel_zeroes(ii,100)
  print("OK")

if __name__ == "__main__":
  tst_all()


 *******************************************************************************


 *******************************************************************************
scitbx/math/tst_multivariate_moments.py
from __future__ import absolute_import, division, print_function
from scitbx import math
from scitbx.array_family import flex
from six.moves import range

def tst(N=3):
  weights = flex.double(N)*0.0+1.0
  mvo = math.multivariate_moments( weights )
  for ii in range(100000):
    tmp = 0.1*(1.0-2.0*flex.random_double(N))+flex.double(range(N))*0.0+1.0
    mvo.update(tmp)
  vcv = mvo.vcv_upper_triangle_packed()
  mean = mvo.mean()
  var = mvo.variance()
  for m in mean:
    assert abs(m-1.0)<1e-3
  for v in var:
    assert abs(v-0.2*0.2/12)<1e-4
  for c in vcv:
    assert abs(c/0.0033)<1e-3


if __name__ == "__main__":
  tst()
  print("OK")


 *******************************************************************************


 *******************************************************************************
scitbx/math/tst_so3_lie_algebra.py
from __future__ import absolute_import, division, print_function
from scitbx.math import so3_lie_algebra

import scitbx.matrix
import scitbx.math
from scitbx.array_family import flex

import unittest
import math
from six.moves import range

class TestElement(unittest.TestCase):

  IDENTITY = scitbx.matrix.identity( 3 )
  SAMPLE_SIZE = 10
  SINGULARITY_GUARD = 0.001

  def run_tests_with(self, matrix):

    le = so3_lie_algebra.element.from_rotation_matrix( matrix = matrix )
    self.assertAlmostEqual(
      ( self.IDENTITY - matrix.transpose() * le.exponential() ).norm_sq(),
      0,
      7,
      )

  def test_random_matrices(self):

    for i in range( self.SAMPLE_SIZE ):
      axis = flex.random_double_point_on_sphere()
      angle = flex.random_double() * ( math.pi - self.SINGULARITY_GUARD )
      rotmat = scitbx.matrix.sqr(
        scitbx.math.r3_rotation_axis_and_angle_as_matrix( axis, angle )
        )
      self.run_tests_with( matrix = rotmat )

  def test_identity(self):

    self.run_tests_with( matrix = self.IDENTITY )


class TestAveraging(unittest.TestCase):

  MAX_ERROR = 0.1
  SAMPLE_SIZE = 10

  def test_angle(self):

    axis = scitbx.matrix.col( flex.random_double_point_on_sphere() )
    centre = flex.random_double() * math.pi

    errors = [ ( flex.random_double() - 0.5 )* self.MAX_ERROR
      for i in range( self.SAMPLE_SIZE ) ]

    average = scitbx.math.r3_rotation_average_rotation_via_lie_algebra(
      matrices = [
        scitbx.matrix.sqr(
          scitbx.math.r3_rotation_axis_and_angle_as_matrix( axis, centre + e )
          )
        for e in errors
        ]
      )
    angle = centre + sum( errors ) / len( errors )
    aaf = scitbx.math.r3_rotation_axis_and_angle_from_matrix( average )
    alignment = axis.dot( scitbx.matrix.col( aaf.axis ) )
    self.assertAlmostEqual( abs( alignment ), 1.0, 7 )
    self.assertAlmostEqual( aaf.angle() / alignment, angle, 7 )

  def test_axis(self):

    axis = (0.37394394059075464, 0.49642290523592875, 0.7834093619893614)
    angle = flex.random_double() * math.pi
    rotmat = scitbx.matrix.sqr(
      scitbx.math.r3_rotation_axis_and_angle_as_matrix( axis, angle )
      )

    missets = [
      scitbx.matrix.sqr(
        scitbx.math.r3_rotation_axis_and_angle_as_matrix(
          flex.random_double_point_on_sphere(),
          ( flex.random_double() - 0.5 )* self.MAX_ERROR,
          )
        )
      for i in range( self.SAMPLE_SIZE )
      ]
    matrices = [ misset * rotmat for misset in missets ]
    aver_lie = scitbx.math.r3_rotation_average_rotation_via_lie_algebra(
      matrices = matrices,
      )
    aver_quat = scitbx.matrix.sqr(
      scitbx.math.r3_rotation_average_rotation_matrix_from_matrices(
        *matrices
        )
      )
    diff = aver_quat.transpose() * aver_lie
    self.assertAlmostEqual( ( diff - TestElement.IDENTITY ).norm_sq(), 0, 7 )

suite_element = unittest.TestLoader().loadTestsFromTestCase(
  TestElement
  )
suite_averaging = unittest.TestLoader().loadTestsFromTestCase(
  TestAveraging
  )

alltests = unittest.TestSuite(
  [
    suite_element,
    suite_averaging,
    ]
  )

if __name__ == "__main__":
  unittest.TextTestRunner( verbosity = 2 ).run( alltests )



 *******************************************************************************


 *******************************************************************************
scitbx/math/tst_undirected_graph.py
from __future__ import absolute_import, division, print_function

from scitbx.math import undirected_graph

import unittest

class TestGraph(unittest.TestCase):

  def setUp(self):

    self.edges = [
      undirected_graph.Edge( vertex1 = 1, vertex2 = 2 ),
      undirected_graph.Edge( vertex1 = 2, vertex2 = 3 ),
      undirected_graph.Edge( vertex1 = 2, vertex2 = 4 ),
      undirected_graph.Edge( vertex1 = 3, vertex2 = 4 ),
      ]
    self.add_vertices = [ 5, 1, 6 ]

    self.vertices = set( [ 1, 2, 3, 4, 5, 6 ] )

    self.edges_from = {
      1: set( [ self.edges[0] ] ),
      2: set( [ self.edges[0], self.edges[1], self.edges[2] ] ),
      3: set( [ self.edges[1], self.edges[3] ] ),
      4: set( [ self.edges[2], self.edges[3] ] ),
      5: set(),
      6: set(),
      }


  def build_and_test_graph(self, graph):

    self.assertEqual( set( graph.vertices ), set() )
    self.assertEqual( set( graph.edges ), set() )

    for e in self.edges:
      graph.add_edge( edge = e )

    for v in self.vertices:
      graph.add_vertex( vertex = v )

    self.assertEqual( set( graph.edges ), set( self.edges ) )
    self.assertEqual( set( graph.vertices ), self.vertices )

    for ( vertex, edges ) in self.edges_from.items():
      self.assertEqual( set( graph.edges_from( vertex = vertex ) ), edges )


  def test_graph(self):

    self.build_and_test_graph( graph = undirected_graph.Graph() )


  def test_vertex_indexed_graph(self):

    self.build_and_test_graph( graph = undirected_graph.VertexIndexedGraph() )


class TestPreorderDepthFirstIteration(unittest.TestCase):

  def create_graph_from_edges(self, edges):

    graph = undirected_graph.Graph()

    for e in edges:
      graph.add_edge( edge = e )

    return graph


  def test_1(self):

    graph = self.create_graph_from_edges(
      edges = [
        undirected_graph.Edge( vertex1 = 1, vertex2 = 1 ),
        ],
      )
    self.assertEqual(
      list( undirected_graph.preorder_depth_first_iteration(vertex = 1, graph = graph ) ),
      [ 1 ],
      )


  def test_2(self):

    graph = self.create_graph_from_edges(
      edges = [
        undirected_graph.Edge( vertex1 = 1, vertex2 = 2 ),
        ],
        )
    self.assertEqual(
      list( undirected_graph.preorder_depth_first_iteration(vertex = 1, graph = graph ) ),
      [ 1, 2 ],
      )
    self.assertEqual(
      list( undirected_graph.preorder_depth_first_iteration(vertex = 2, graph = graph ) ),
      [ 2, 1 ],
      )


  def test_3(self):

    graph = self.create_graph_from_edges(
      edges = [
        undirected_graph.Edge( vertex1 = 1, vertex2 = 2 ),
        undirected_graph.Edge( vertex1 = 2, vertex2 = 3 ),
        ],
      )
    self.assertEqual(
      list( undirected_graph.preorder_depth_first_iteration(vertex = 1, graph = graph ) ),
      [ 1, 2, 3 ],
      )
    self.assertEqual(
      list( undirected_graph.preorder_depth_first_iteration(vertex = 3, graph = graph ) ),
      [ 3, 2, 1 ],
      )
    middle = list(
      undirected_graph.preorder_depth_first_iteration(vertex = 2, graph = graph )
      )
    self.assertTrue( ( middle == [ 2, 1, 3 ] ) or ( middle == [ 2, 3, 1 ] ) )


  def test_4(self):

    graph = self.create_graph_from_edges(
      edges = [
        undirected_graph.Edge( vertex1 = 1, vertex2 = 2 ),
        undirected_graph.Edge( vertex1 = 2, vertex2 = 3 ),
        undirected_graph.Edge( vertex1 = 2, vertex2 = 4 ),
        undirected_graph.Edge( vertex1 = 3, vertex2 = 4 ),
        ],
      )

    res = list(
      undirected_graph.preorder_depth_first_iteration(vertex = 1, graph = graph )
      )
    self.assertTrue( ( res == [ 1, 2, 3, 4 ] ) or ( res == [ 1, 2, 4, 3 ] ) )

    res = list(
      undirected_graph.preorder_depth_first_iteration(vertex = 2, graph = graph )
      )
    self.assertTrue(
      ( res == [ 2, 1, 3, 4 ] )
      or ( res == [ 2, 1, 4, 3 ] )
      or ( res == [ 2, 3, 4, 1 ] )
      or ( res == [ 2, 4, 3, 1 ] )
      )

    res = list(
      undirected_graph.preorder_depth_first_iteration(vertex = 3, graph = graph )
      )
    self.assertTrue(
      ( res == [ 3, 2, 1, 4 ] )
      or ( res == [ 3, 2, 4, 1 ] )
      or ( res == [ 3, 4, 2, 1 ] )
      )
    res = list(
      undirected_graph.preorder_depth_first_iteration(vertex = 4, graph = graph )
      )
    self.assertTrue(
      ( res == [ 4, 3, 2, 1 ] )
      or ( res == [ 4, 2, 1, 3 ] )
      or ( res == [ 4, 2, 3, 1 ] )
      )


class TestConnectedComponents(unittest.TestCase):

  def test_1(self):

    graph = undirected_graph.Graph()
    graph.add_edge( edge = undirected_graph.Edge( vertex1 = 1, vertex2 = 1 ) )

    self.assertEqual(
      list( undirected_graph.connected_components( graph = graph ) ),
      [ [ 1 ] ],
      )

  def test_2(self):

    graph = undirected_graph.Graph()
    graph.add_edge( edge = undirected_graph.Edge( vertex1 = 1, vertex2 = 2 ) )

    self.assertEqual(
      list(
        sorted( c ) for c in undirected_graph.connected_components( graph = graph )
        ),
      [ [ 1, 2 ] ],
      )

    graph = undirected_graph.Graph()
    graph.add_vertex( 1 )
    graph.add_vertex( 2 )

    self.assertEqual(
      sorted( undirected_graph.connected_components( graph = graph ) ),
      [ [ 1 ], [ 2 ] ],
      )

  def test_3(self):

    graph = undirected_graph.Graph()
    graph.add_edge( undirected_graph.Edge( vertex1 = 1, vertex2 = 2 ) )
    graph.add_edge( undirected_graph.Edge( vertex1 = 2, vertex2 = 3 ) )
    graph.add_edge( undirected_graph.Edge( vertex1 = 4, vertex2 = 5 ) )
    graph.add_edge( undirected_graph.Edge( vertex1 = 5, vertex2 = 6 ) )
    graph.add_edge( undirected_graph.Edge( vertex1 = 5, vertex2 = 7 ) )
    graph.add_edge( undirected_graph.Edge( vertex1 = 6, vertex2 = 7 ) )

    self.assertEqual(
      sorted( sorted( c ) for c in undirected_graph.connected_components( graph = graph ) ),
      [ [ 1, 2, 3 ], [ 4, 5, 6, 7 ] ],
      )


suite_graph = unittest.TestLoader().loadTestsFromTestCase(
  TestGraph
  )
suite_preorder_depth_first = unittest.TestLoader().loadTestsFromTestCase(
  TestPreorderDepthFirstIteration
  )
suite_connected_components = unittest.TestLoader().loadTestsFromTestCase(
  TestConnectedComponents
  )

alltests = unittest.TestSuite(
  [
    suite_graph,
    suite_preorder_depth_first,
    suite_connected_components,
    ]
  )

if __name__ == "__main__":
  unittest.TextTestRunner( verbosity = 2 ).run( alltests )



 *******************************************************************************


 *******************************************************************************
scitbx/math/tst_zernike.py
from __future__ import absolute_import, division, print_function
from scitbx import math
from scitbx.array_family import flex
from scitbx.array_family import shared
from six.moves import range
from six.moves import zip

def tst_nlm():
  nlm_array = math.nlm_array(10)
  nlm_array.set_coef(10,2,2, 3.0)
  a = nlm_array.get_coef(10,2,2)
  assert ( abs(a-3.0) ) <= 1e-5
  nlm_ind = shared.tiny_int_3( [(10,2,2),(8,2,2)]  )
  nlm_coef = flex.complex_double( [15.0+0j,15.0+0j] )
  assert nlm_array.load_coefs( nlm_ind , nlm_coef)
  a = nlm_array.get_coef(10, 2, 2)
  b = nlm_array.get_coef(8, 2, 2)
  assert ( abs(a-15.0) ) <= 1e-5
  assert ( abs(b-15.0) ) <= 1e-5
  nlm = nlm_array.nlm()
  cnlm = nlm_array.coefs()
  sel = nlm_array.select_on_nl(2,2)
  assert len(sel)==5
  assert 5 in sel
  assert 6 in sel
  assert 7 in sel
  assert 8 in sel
  assert 9 in sel


def tst_log_factorial():
  # Log factorial generator
  N=89
  lfg =  math.log_factorial_generator(N)
  ff = 1.0
  for ii in range(1,N):
    tmp = lfg.log_fact(ii)
    tmp2 = lfg.fact(ii)
    ff = ff*ii
    assert 1e10*abs(tmp2-ff)/ff<1


def tst_zernike_radial():
  N=50
  M=8
  lfg =  math.log_factorial_generator(N)
  for n in range(M):
    for l in range(n):
      if (n-l)%2==0:
        rzfa = math.zernike_radial(n,l, lfg)
        r = flex.double( flex.double(range(100000))/99999.0)
        a = rzfa.f( r )
        tmp = a*a*r*r
        tmp = flex.sum( tmp )/100000.0
        assert abs(tmp-1)<2e-2
        for nn in range(M):
          for ll in range(nn):
            if (nn-ll)%2==0:
              if (nn!=n):
                if ll==l:
                  rzfb = math.zernike_radial(nn,ll, lfg)
                  b = rzfb.f( r )
                  tmp = a*b*r*r
                  tmp = flex.sum( tmp )/100000.0
                  assert (tmp<1e-2)
                  #print n,l, nn,ll, tmp



def tst_zernike_grid(skip_iteration_probability=0.95):
  #THIS TEST TAKES A BIT OF TIME
  M=20
  N=4
  ddd = (M*2+1)
  zga = math.zernike_grid(M,N,False)
  zgb = math.zernike_grid(M,N,False)

  xyz = zga.xyz()
  coefs = zga.coefs()
  nlm = zga.nlm()

  import random
  rng = random.Random(x=None)
  for ii in range(nlm.size()):
    for jj in range(ii+1,nlm.size()):
      if (rng.random() < skip_iteration_probability):
        continue
      coefsa = coefs*0.0
      coefsb = coefs*0.0
      coefsa[ii]=1.0+1.0j
      coefsb[jj]=1.0+1.0j
      zga.load_coefs( nlm, coefsa )
      zgb.load_coefs( nlm, coefsb )
      fa = zga.f()
      fb = zgb.f()

      prodsum = flex.sum(fa*flex.conj(fb) )/xyz.size()
      prodsuma= flex.sum(fa*flex.conj(fa) )/xyz.size()
      prodsumb= flex.sum(fb*flex.conj(fb) )/xyz.size()

      t1 = abs(prodsum)
      t2 = abs(prodsuma)
      t3 = abs(prodsumb)
      t1 = 100.0*(t1/t2)
      t2 = 100.0*(abs(t2-t3)/t3)
      # unfortunately, this numerical integration scheme is not optimal. For certain
      # combinations of nlm, we see significant non-orthogonality that reduces when
      # we increase the number of points. A similar behavior is seen in the radial
      # part of the Zernike polynome. If we compile withiout the radial function, similar
      # behavior is seen using only the spherical harmonics functions.
      # For this reason, the liberal limts set below are ok
      assert t1<2.0
      assert t2<5.0


def tst_nl():
  this_nl_array = math.nl_array(5)
  nl = this_nl_array.nl()
  result= """"""
  for tnl in nl:
    result +=str(tnl)+"\n"
    assert (tnl[0]-tnl[1])%2==0
  expected_result = """(0, 0)
(1, 1)
(2, 0)
(2, 2)
(3, 1)
(3, 3)
(4, 0)
(4, 2)
(4, 4)
(5, 1)
(5, 3)
(5, 5)
"""
  assert result == expected_result
  coefs = this_nl_array.coefs()
  assert coefs.size() == nl.size()
  new_coefs = flex.double( range(nl.size() ) )
  assert this_nl_array.load_coefs( nl, new_coefs )
  new_nl = shared.tiny_int_2( [ (10,10) ] )
  new_coef = flex.double( [10.0] )
  assert not this_nl_array.load_coefs( new_nl, new_coef )
  coefs = this_nl_array.coefs()
  for x,y in zip(coefs,new_coefs):
    assert abs(x-y)<1e-5
  for tnl, cc in zip(nl,coefs):
    thc = this_nl_array.get_coef(tnl[0], tnl[1])
    assert abs(thc-cc)<1e-5
    this_nl_array.set_coef(tnl[0], tnl[1], 300 )
    thc = this_nl_array.get_coef(tnl[0], tnl[1])
    assert abs(thc-300)<1e-5


def tst_nss_spherical_harmonics():
  N=50
  M=20
  lfg =  math.log_factorial_generator(N)
  nsssphe = math.nss_spherical_harmonics(M+5,50000,lfg)

  a = nsssphe.legendre_lm(8,2)
  b = nsssphe.legendre_lm_pc(8,2)
  for aa,bb in zip(a,b):
    assert abs(aa-bb)<1e-7

  a = nsssphe.legendre_lm(14,3)
  b = nsssphe.legendre_lm_pc(14,3)
  for aa,bb in zip(a,b):
    assert abs(aa-bb)<1e-7

  lm=[ (0,0), (3,3), (4,1) ]

  theta = flex.double(range(100))*3.14/100.0
  phi = flex.double(range(100))*6.28/100.0
  for tt in theta:
    for pp in phi:
      r  = nsssphe.spherical_harmonic(20,10,tt,pp)
      rr = nsssphe.spherical_harmonic_pc(20,10,tt,pp)
      #print tt,pp, r.real, r.imag, 100.0*abs(r.real-rr.real)/(max(abs(r.real),1e-12)) , 100.0*abs(rr.imag-r.imag)/(max(abs(r.imag),1e-12))
      assert 100.0*abs(r.real-rr.real)/(max(abs(r.real),1e-12))<2.0
      assert 100.0*abs(rr.imag-r.imag)/(max(abs(r.imag),1e-12))<2.0





if __name__ == "__main__":
  tst_nss_spherical_harmonics()
  tst_nl()
  tst_nlm()
  tst_log_factorial()
  tst_zernike_radial()
  tst_zernike_grid()

  print("OK")


 *******************************************************************************
