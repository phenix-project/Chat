

 *******************************************************************************
rstbx/__init__.py
from __future__ import absolute_import, division, print_function
import boost_adaptbx.boost.python as bp
ext = bp.import_ext("omptbx_ext")
from omptbx_ext import *


 *******************************************************************************


 *******************************************************************************
rstbx/apps/__init__.py
from __future__ import absolute_import, division, print_function
from cctbx.array_family import flex # import dependency
from annlib_ext import AnnAdaptor # import dependency
import boost_adaptbx.boost.python as bp
ext = bp.import_ext("rstbx_integration_ext")
from rstbx_integration_ext import *


 *******************************************************************************


 *******************************************************************************
rstbx/apps/dual_resolution_helpers.py
from __future__ import absolute_import, division, print_function
from six.moves import range
import math
from scitbx.array_family import flex
from scitbx.matrix import col

def get_model_ref_limits(self,raw_image,spotfinder,imageindex,inputai,
      spot_prediction_limiting_resolution):
    return 0. # for now, disable the special model refinement limits as they do not help

    body_pixel_reference = flex.double()
    delx=[]
    dely=[]
    tt=flex.double()
    d_ang = flex.double()
    for spot in spotfinder.images[imageindex]["goodspots"]:

      spot_center = col((spot.ctr_mass_x(),spot.ctr_mass_y(),0.0))*raw_image.pixel_size
      offs = self.detector_origin+spot_center
      radius_mm = math.hypot(offs[0],offs[1])
      spot_two_theta_rad = math.atan(radius_mm/inputai.getBase().distance)
      d_ang.append(  inputai.wavelength / (2.*math.sin (spot_two_theta_rad/2.)) )
      tt.append(spot_two_theta_rad)
      for pxl in spot.bodypixels:
        body_pixel_reference.append(pxl.y + 0.5)
        body_pixel_reference.append(pxl.x + 0.5)

    obs_limited_d = max ( d_ang.select(flex.sort_permutation(d_ang))[0],
                          spot_prediction_limiting_resolution )

    # Get optimal mosaicity to match the observations using uniform sampling method
    reference_mosaicity = inputai.getMosaicity()

    corr_best = None
    mos_best = None
    pred_two_theta_rad_best = None
    pred_full_set_best = None
    mos_min,mos_max = (0.001,1.5)
    mos_low = mos_min + 0.
    mos_high = mos_max + 0.
    steps = math.pow(mos_high/mos_low,1./20.)
    from bpcx_regression.use_case_1_2.compare_bpcx_xds import cc,cc_slope
    for i in range(20):
      mos_test = mos_low * math.pow(steps,i)



      #for the moment, assume image center = 0 (always true for xfel stills)
      inputai.setMosaicity(mos_test)
      spots = inputai.predict_all( 0.0,obs_limited_d )
      pred_two_theta_rad = inputai.getOrientation().unit_cell().two_theta(spots.hkl(),
        wavelength=inputai.wavelength)

      obs_tt_sort = tt.select(flex.sort_permutation(tt))
      pred_tt_sort = pred_two_theta_rad.select(flex.sort_permutation(pred_two_theta_rad))
      print("len obs",len(obs_tt_sort))
      print("len pred",len(pred_tt_sort))
      if not len(pred_tt_sort)>len(obs_tt_sort):continue
      conversion = len(pred_tt_sort)/len(obs_tt_sort)
      select_pred_tt_sort = flex.double()
      for x in range(len(obs_tt_sort)):
        select_pred_tt_sort.append(pred_tt_sort[int(x * conversion)])
      print("len select pred",len(select_pred_tt_sort))
      corr_test = cc(obs_tt_sort, select_pred_tt_sort)
      print("test mosaicity",mos_test,"Correlation",corr_test)
      if mos_best==None:
        mos_best=mos_test;corr_best=corr_test;pred_two_theta_rad_best=select_pred_tt_sort
        pred_full_set_best=pred_tt_sort
      if corr_test > corr_best:
        mos_best=mos_test;corr_best=corr_test;pred_two_theta_rad_best=select_pred_tt_sort
        pred_full_set_best=pred_tt_sort
    print("best mosaicity",mos_best)

    # got best model mosaicity, now go back again and match up predictions to observations
    # get get prediction set with same length and two theta values as the observation set
    modified_pred_x=flex.double()
    modified_pred_y=flex.double()
    ipred = 0
    for iobs in range(len(obs_tt_sort)):
      try:
        while pred_full_set_best[ipred]<obs_tt_sort[iobs]: ipred+=1
      except IndexError:
        break
      modified_pred_x.append(ipred)
      modified_pred_y.append(obs_tt_sort[iobs])

    # now do some linear least squares fitting of the modified pred so it fits low-resolution obs
    #  x = low resolution obs_x
    #  y = low resolution modified_pred_x

    #N = int(len(obs_tt_sort)*0.75) # take the first half of obs
    #X = flex.double(range(N)).as_numpy_array()
    #Y = flex.double(modified_pred_x[:N]).as_numpy_array()
    #from labelit.diffraction.limits import linear_fit
    #K,B,corr = linear_fit(X,Y)
    #print K,B,corr

    ccc=[];cccx=[];
    for x in range(int(len(obs_tt_sort)/3),len(obs_tt_sort)):
      cccx.append(x)
      ccc.append(cc(range(x),modified_pred_x[0:x]))
      #print x,cc(range(x),modified_pred_x[0:x])
      corr,slope = cc_slope(range(x),modified_pred_x[0:x])
      scaled_modified_pred_x = modified_pred_x/slope

      second_modified_pred_x=flex.double()
      second_modified_pred_y=flex.double()
      ipred = 0
      for ixx in range(len(obs_tt_sort)):
        try:
          while scaled_modified_pred_x[ipred]<ixx: ipred+=1
        except IndexError:
          break
        second_modified_pred_x.append(ixx)
        second_modified_pred_y.append(modified_pred_y[ipred])

      diff = second_modified_pred_y - obs_tt_sort[0:len(second_modified_pred_y)]
      stats = flex.mean_and_variance( second_modified_pred_y - obs_tt_sort[0:len(second_modified_pred_y)] )

      rmsd = stats.unweighted_sample_standard_deviation()
      mean = stats.mean()
      print(x,mean,rmsd,-diff[x]/rmsd)
      if -diff[x]/rmsd > 0.5:  # ad hoc cutoff seems like reasonable criterion for resolution cutoff
        print("twotheta rad cutoff",obs_tt_sort[x])
        print("angstrom cutoff",inputai.wavelength / (2.*math.sin (  obs_tt_sort[x] /2.)))
        break

    if False:
      from matplotlib import pyplot as plt
      #plt.plot(delx,dely,"r.")
      #plt.show()
      plt.plot(range(len(tt)),obs_tt_sort,"r.")
      plt.plot(flex.double(range(len(pred_two_theta_rad_best))),pred_two_theta_rad_best,"g.")
      #plt.plot(flex.double(range(len(pred_full_set_best))),pred_full_set_best,"b.")
      plt.plot(cccx, ccc,"b.")
      plt.plot(scaled_modified_pred_x, modified_pred_y,"b.")
      #plt.plot(modified_pred_x/B,modified_pred_y,"y.")
      plt.plot(second_modified_pred_x, second_modified_pred_y,"r+")
      plt.show()

    model_refinement_limiting_resolution = inputai.wavelength / (2.*math.sin (  obs_tt_sort[x] /2.))
    return model_refinement_limiting_resolution


 *******************************************************************************


 *******************************************************************************
rstbx/apps/slip_helpers.py
from __future__ import absolute_import, division, print_function
from six.moves import range
import math
from libtbx.test_utils import approx_equal
from scitbx.array_family import flex
from scitbx import lbfgs

class minimizer(object):
  def __init__(self,data,stuff,frame,max_iterations=50):

    self.n = len(data)
    self.values = data
    self.initial = data.deep_copy()


    #mosaicity,hi energy wave, lo energy wave
    #want mosaicity between 0.1 and 1.0 of input value.
    self.lower_bound = flex.double([0.1*data[0],0.98*data[1],(data[1]+data[2])/2.])
    upper_bound = flex.double([10.*data[0],(data[1]+data[2])/2.,1.02*data[2]])
    mean_value = (upper_bound - self.lower_bound)/2.
    self.full_range = upper_bound - self.lower_bound
    starting_params = flex.tan(math.pi*(((data - self.lower_bound)/self.full_range)-0.5))
    self.x = starting_params.deep_copy()
    print("staerting params",list(self.x))


    self.stuff = stuff
    self.frame = frame
    # optimize parameters
    self.minimizer = lbfgs.run(target_evaluator=self,
      termination_params = lbfgs.termination_parameters(max_calls=20))

  def compute_functional_and_gradients(self):
    print("trying",list(self.x))

    # try to constrain rather than restrain.  Use arctan function to get this right
    # minimizer can choose any value from -inf to inf but we'll keep values carefully in range
    # mos

    #if self.x[0]/self.initial[0] >2.: self.x[0]=2.*self.initial[0]
    #assert self.x[1]<self.x[2]
    #if self.x[1]/self.initial[1] <0.99: self.x[1]=0.99*self.initial[1]
    #if self.x[2]/self.initial[2] >1.01: self.x[2]=1.01*self.initial[2]
    #print "adjust",list(self.x)

    def get_score(x):
      unpacked = self.lower_bound + self.full_range*(
        0.5 + (flex.atan(x)/math.pi)
      )
      #print "          trying",list(unpacked)
      return self.stuff.use_case_3_score_only(
      self.frame,unpacked[0],unpacked[1],unpacked[2])

    #f = self.stuff.use_case_3_score_only(
    #  self.frame,self.values[0],self.values[1],self.values[2])
    f = get_score(self.x)

    gradients = flex.double(len(self.x))
    for i in range(self.n):
      #factors = [1.000]*self.n
     # factors[i] *= 1.001
     # D_i = 0.001 * self.x[i]
      #f_i_plus_D_i = self.stuff.use_case_3_score_only(
     #   self.frame,self.x[0]*factors[0],self.x[1]*factors[1],self.x[2]*factors[2])
      trial_x = self.x.deep_copy()
      trial_x[i]+=1.
      f_i_plus_D_i = get_score(trial_x)
      df_di = (f_i_plus_D_i - f)/1.
      gradients[i]=df_di
    return f,gradients

  def unpacked(self,x):
    return self.lower_bound + self.full_range*(
        0.5 + (flex.atan(x)/math.pi)
      )

class wrapper_of_use_case_bp3(object):
  def __init__(self, raw_image, spotfinder, imageindex, inputai, spot_prediction_limiting_resolution,
               phil_params, sub=None):
    """MODEL:  polychromatic beam with top hat bandpass profile.
               isotropic mosaicity with top hat half-width; spots are brought into reflecting condition
               by a finite rotation about the axis that is longitudinal to the projection of the q-vector
               onto the detector plane.
    """
    from rstbx.bandpass import use_case_bp3,parameters_bp3
    from scitbx.matrix import col
    from math import pi
    from cctbx.crystal import symmetry

    self.detector_origin = col((-inputai.getBase().xbeam, -inputai.getBase().ybeam, 0.))
    crystal = symmetry(unit_cell=inputai.getOrientation().unit_cell(),space_group = "P1")
    indices = crystal.build_miller_set(anomalous_flag=True, d_min = spot_prediction_limiting_resolution)
    parameters = parameters_bp3(
       indices=indices.indices(), orientation=inputai.getOrientation(),
       incident_beam=col((0.,0.,-1.)),
       packed_tophat=col((1.,1.,0.)),
       detector_normal=col((0.,0.,-1.)), detector_fast=col((0.,1.,0.)),detector_slow=col((1.,0.,0.)),
       pixel_size=col((raw_image.pixel_size,raw_image.pixel_size,0)),
       pixel_offset=col((0.5,0.5,0.0)), distance=inputai.getBase().distance,
       detector_origin=self.detector_origin
    )

    if phil_params.integration.subpixel_joint_model.translations is not None:
      T = phil_params.integration.subpixel_joint_model.translations
      import copy
      resortedT = copy.copy(T)
      for tt in range(0,len(T),2):
        resortedT[tt] = T[tt+1]
        resortedT[tt+1] = T[tt]

    from rstbx.apps.dual_resolution_helpers import get_model_ref_limits
    model_refinement_limiting_resolution = get_model_ref_limits(self,raw_image,spotfinder,
      imageindex,inputai,spot_prediction_limiting_resolution)
    print("resolution limits: model refinement %7.2f  spot prediction %7.2f"%(
      model_refinement_limiting_resolution,spot_prediction_limiting_resolution))

    self.ucbp3 = use_case_bp3(parameters=parameters)
    the_tiles = raw_image.get_tile_manager(phil_params).effective_tiling_as_flex_int(
      reapply_peripheral_margin=True,encode_inactive_as_zeroes=True)
    self.ucbp3.set_active_areas( the_tiles )

    if phil_params.integration.signal_penetration==0.0:
      self.ucbp3.set_sensor_model( thickness_mm = 0.0, mu_rho = 8.36644, signal_penetration = 0.0 )
    else: self.ucbp3.set_sensor_model( thickness_mm = 0.5, mu_rho = 8.36644, # CS_PAD detector at 1.3 Angstrom
      signal_penetration = phil_params.integration.signal_penetration)
      # XXX still very buggy; how do penetration & thickness relate?

    if sub != None and phil_params.integration.subpixel_joint_model.translations is not None:
      raise Exception("Cannot use both subpixel mechanisms simultaneously")
    elif sub != None:
      print("Subpixel corrections: using translation-pixel mechanism")
      null_rotations_deg = flex.double(len(sub)//2)
      self.ucbp3.set_subpixel(flex.double(sub),rotations_deg=null_rotations_deg)
    elif phil_params.integration.subpixel_joint_model.translations is not None:
      print("Subpixel corrections: using joint-refined translation + rotation")
      self.ucbp3.set_subpixel(
          resortedT, rotations_deg = flex.double(
           phil_params.integration.subpixel_joint_model.rotations)
        )
    else:
      print("Subpixel corrections: none used")

    # Reduce Miller indices to a manageable set.  NOT VALID if the crystal rotates significantly
    self.ucbp3.prescreen_indices(inputai.wavelength)
    # done with Miller set reduction
    from annlib_ext import AnnAdaptorSelfInclude as AnnAdaptor
    body_pixel_reference = flex.double()
    limited_body_pixel_reference = flex.double()
    for spot in spotfinder.images[imageindex]["goodspots"]:
      for pxl in spot.bodypixels:
        body_pixel_reference.append(pxl.y + 0.5)
        body_pixel_reference.append(pxl.x + 0.5)
        pixel_center = col((pxl.x,pxl.y,0.0))*raw_image.pixel_size
        offs = self.detector_origin+pixel_center
        radius_mm = math.hypot(offs[0],offs[1])
        pixel_two_theta_rad = math.atan(radius_mm/inputai.getBase().distance)
        pixel_d_ang = (  inputai.wavelength / (2.*math.sin (pixel_two_theta_rad/2.)) )
        if pixel_d_ang > model_refinement_limiting_resolution:
          limited_body_pixel_reference.append(pxl.y + 0.5)
          limited_body_pixel_reference.append(pxl.x + 0.5)

    self.model_refinement_limiting_resolution = model_refinement_limiting_resolution
    # model refinement resolution limits must be applied in two places: 1) the reference
    #  list of body pixels to the ann adaptor, and 2) the enclosed_pixels_and_margin_pixels() function call
    if self.model_refinement_limiting_resolution > 0.:
      self.ucbp3.set_adaptor(limited_body_pixel_reference)
    else:
      self.ucbp3.set_adaptor(body_pixel_reference)

  def set_variables(self, orientation, wave_HI, wave_LO, half_mosaicity_deg, domain_size=0.):
    half_mosaicity_rad = half_mosaicity_deg * math.pi/180.
    self.ucbp3.set_mosaicity(half_mosaicity_rad)
    self.ucbp3.set_bandpass(wave_HI,wave_LO)
    self.ucbp3.set_orientation(orientation)
    self.ucbp3.set_domain_size(domain_size)

  def score_only(self):
    self.ucbp3.picture_fast_slow()
    # not sure why x and y origin shifts are swapped here, but this seemed to work
    swapped_origin = (-self.detector_origin[1],-self.detector_origin[0],0.)
    self.ucbp3.spot_rectangles(swapped_origin)
    self.ucbp3.spot_rectregions(swapped_origin,1.0)
    if self.model_refinement_limiting_resolution > 0.:
      self.ucbp3.enclosed_pixels_and_margin_pixels(self.model_refinement_limiting_resolution)
    else:
      self.ucbp3.enclosed_pixels_and_margin_pixels()

    return self.ucbp3.score_only_detail(weight=50.)


class slip_callbacks:
  def slip_callback(self,frame):
    #best_params=self.use_case_3_simulated_annealing()
    #best_params = self.use_case_3_grid_refine(frame)
    #self.inputai.setOrientation(best_params[3])
    #self.use_case_3_refactor(frame,best_params[0],best_params[1], best_params[2])
    #self.inputai.set_orientation_reciprocal_matrix( (0.001096321006219932, -0.0007452314870693856, 0.007577824826005684, 0.0009042576974140007, -0.010205656871417366, -0.0009746502046169632, 0.012357726864252296, 0.00701297199602489, -0.0005717102325987258))
    #self.use_case_3_refactor(frame,0.0995603664049, 1.29155605957, 1.30470696644 )
    #self.use_case_3_refactor(frame,0.0995603664049, 1.29155605957, 1.30470696644,domain_size=2000. )

    normal = True
    # BLUE: predictions
    blue_data = []
    for ix,pred in enumerate(self.predicted):
        if self.BSmasks[ix].keys()==[]:continue
        x,y = frame.pyslip.tiles.picture_fast_slow_to_map_relative(
          (pred[1]/self.pixel_size) +0.5,
          (pred[0]/self.pixel_size) +0.5)
        blue_data.append((x,y))
    if normal: self.blue_layer = frame.pyslip.AddPointLayer(
          blue_data, color="blue", name="<blue_layer>",
          radius=2,
          renderer = frame.pyslip.LightweightDrawPointLayer,
          show_levels=[-2, -1, 0, 1, 2, 3, 4, 5])

    yellow_data = []; cyan_data = []
    for imsk in range(len(self.BSmasks)):
      smask_keys = self.get_ISmask(imsk)
      bmask = self.BSmasks[imsk]
      if len(bmask.keys())==0: continue

      # CYAN: integration mask
      for ks in range(0,len(smask_keys),2):
        cyan_data.append(
          frame.pyslip.tiles.picture_fast_slow_to_map_relative(
           smask_keys[ks+1] + 0.5,smask_keys[ks] + 0.5))

      # YELLOW: background mask
      for key in bmask.keys():
        yellow_data.append(
          frame.pyslip.tiles.picture_fast_slow_to_map_relative(
            key[1] + 0.5 ,key[0] + 0.5))
    if normal: self.cyan_layer = frame.pyslip.AddPointLayer(
          cyan_data, color="cyan", name="<cyan_layer>",
          radius=1.5,
          renderer = frame.pyslip.LightweightDrawPointLayer,
          show_levels=[-2, -1, 0, 1, 2, 3, 4, 5])
    if normal: self.yellow_layer = frame.pyslip.AddPointLayer(
          yellow_data, color="yellow", name="<yellow_layer>",
          radius=1.5,
          renderer = frame.pyslip.LightweightDrawPointLayer,
          show_levels=[-2, -1, 0, 1, 2, 3, 4, 5])

    red_data = []; green_data = []

    for spot in self.spotfinder.images[self.frame_numbers[self.image_number]]["goodspots"]:
      # RED: spotfinder spot pixels
      for pxl in spot.bodypixels:
        red_data.append(
          frame.pyslip.tiles.picture_fast_slow_to_map_relative(
            pxl.y + 0.5, pxl.x + 0.5))

      # GREEN: spotfinder centers of mass
      green_data.append(
          frame.pyslip.tiles.picture_fast_slow_to_map_relative(
            spot.ctr_mass_y() + 0.5, spot.ctr_mass_x() + 0.5))

    self.red_layer = frame.pyslip.AddPointLayer(
          red_data, color="red", name="<red_layer>",
          radius=1.5,
          renderer = frame.pyslip.LightweightDrawPointLayer,
          show_levels=[-2, -1, 0, 1, 2, 3, 4, 5])
    if normal: self.green_layer = frame.pyslip.AddPointLayer(
          green_data, color="green", name="<green_layer>",
          radius=1.5,
          renderer = frame.pyslip.LightweightDrawPointLayer,
          show_levels=[-2, -1, 0, 1, 2, 3, 4, 5])

  def use_case_1(self,frame):

    # A rehash of the spot-prediction algorithm for pedagogical use.
    # Use an "ewald proximity" filter as suggested by Ralf.
    # aside from a few extra spots due to ewald proximity, this is exactly the
    # same spot model developed initially for the Sept/Dec 2011 CXI runs.

    orange_data = []
    from scitbx.matrix import col,sqr
    print("wavelength",self.inputai.wavelength)
    print("orientation",self.inputai.getOrientation())
    A = sqr(self.inputai.getOrientation().reciprocal_matrix())
    print("base",self.inputai.getBase())
    print("pixel size",self.pixel_size)
    detector_origin = col((-self.inputai.getBase().xbeam, -self.inputai.getBase().ybeam, 0.))
    detector_fast = col((0.,1.,0.))
    detector_slow = col((1.,0.,0.))
    distance = self.inputai.getBase().distance

    s0 = col((0.,0.,1/self.inputai.wavelength))
    s0_length = s0.length()
    detector_normal = col((0.,0.,-1.))

    from cctbx.crystal import symmetry
    crystal = symmetry(unit_cell=self.inputai.getOrientation().unit_cell(),space_group = "P1")
    indices = crystal.build_miller_set(anomalous_flag=True, d_min = self.limiting_resolution)
    for H in indices.indices():
      s = A * H
      q = (s + s0)
      #print q.length(), s0_length
      if abs(q.length() - s0_length) > 0.001: continue
      q_unit = q.normalize()

      # check if diffracted ray parallel to detector face

      q_dot_n = q_unit.dot(detector_normal)

      if q_dot_n >= 0: continue

      r = (q_unit * distance / q_dot_n) - detector_origin

      x = r.dot(detector_fast)
      y = r.dot(detector_slow)
      print(x,y)

      orange_data.append( frame.pyslip.tiles.picture_fast_slow_to_map_relative(
          (x/self.pixel_size) +0.5,
          (y/self.pixel_size) +0.5))

    self.orange_layer = frame.pyslip.AddPointLayer(
          orange_data, color="orange", name="<orange_layer>",
          radius=3.0,
          renderer = frame.pyslip.LightweightDrawPointLayer,
          show_levels=[-2, -1, 0, 1, 2, 3, 4, 5])


  def use_case_2(self,frame):

    # Extend the model.  Assume monochromatic beam but finite radial mosaicity.  Dispense
    # with the "ewald proximity" mechanism; now spots are brought into reflecting condition
    # by a finite rotation about the axis that is longitudinal to the projection of the q-vector
    # onto the detector plane.

    orange_data = []
    from scitbx.matrix import col,sqr
    from math import pi
    print("Moasicity degrees, half",0.1)
    mosaicity_rad = 0.1 * pi/180.  #half-width top-hat mosaicity
    A = sqr(self.inputai.getOrientation().reciprocal_matrix())
    detector_origin = col((-self.inputai.getBase().xbeam, -self.inputai.getBase().ybeam, 0.))
    detector_fast = col((0.,1.,0.))
    detector_slow = col((1.,0.,0.))
    distance = self.inputai.getBase().distance

    #s0:  parallel to the direction of incident radiation
    s0 = col((0.,0.,1/self.inputai.wavelength))
    s0_length = s0.length()
    s0_unit = s0.normalize()
    detector_normal = col((0.,0.,-1.))
    #  Cn, the circular section through the Ewald sphere.
    Cncenter = -s0
    Cnradius_squared = s0.length_sq()
    #  Taking a page from mathworld.wolfram.com, calculate the distance d
    #  between the centers of Co and Cn,
    d = s0_length

    from cctbx.crystal import symmetry
    crystal = symmetry(unit_cell=self.inputai.getOrientation().unit_cell(),space_group = "P1")
    indices = crystal.build_miller_set(anomalous_flag=True, d_min = self.limiting_resolution)
    for H in indices.indices():
      s = A * H
      rotax = s.normalize().cross(s0_unit) #The axis that most directly brings the Bragg spot onto Ewald sphere
      s_rad = s.length()
      s_rad_sq = s.length_sq()

      # take a page from ewald_sphere.cpp, determine intersection of two coplanar circles
      #  Co, the circle centered on reciprocal origin and containing the point s,
      #  Cn, the circle centered on -s0 (ewald sphere center) of radius (1/lambda) with normal rotax.
      # Consider the intersection of two circles:
      #  Co, the circle of rotation of H.
      # Cocenter = 0; so it falls out of the equations

      #   The chord of intersection between Co and Cn lies a
      #   distance x along the (Cocenter - Cncenter) vector
      chord_direction =      (rotax.cross( - Cncenter)).normalize();

      a = s.length_sq()/(2.*s0_length)
      b = math.sqrt(s.length_sq() - (a*a))      #  Calculate half-length of the chord of intersection
      #  Two intersection points
      intersections_0p = -a * s0_unit+ b*chord_direction
      intersections_1p = -a * s0_unit- b*chord_direction
      iangle_0= math.acos (intersections_0p.dot(s) / (s_rad_sq))
      iangle_1= math.acos (intersections_1p.dot(s) / (s_rad_sq))

      assert approx_equal((intersections_0p+s0).length()-s0_length,0. )

      if iangle_0 < mosaicity_rad:
        intersection = intersections_0p
      elif iangle_1 < mosaicity_rad:
        intersection = intersections_1p
      else: continue

      q = (intersection + s0)
      q_unit = q.normalize()

      # check if diffracted ray parallel to detector face

      q_dot_n = q_unit.dot(detector_normal)

      if q_dot_n >= 0: continue
      print("IANGLES",iangle_0 * 180./pi, iangle_1 * 180./pi)

      r = (q_unit * distance / q_dot_n) - detector_origin

      x = r.dot(detector_fast)
      y = r.dot(detector_slow)

      orange_data.append( frame.pyslip.tiles.picture_fast_slow_to_map_relative(
          (x/self.pixel_size) +0.5,
          (y/self.pixel_size) +0.5))

    self.orange_layer = frame.pyslip.AddPointLayer(
          orange_data, color="orange", name="<orange_layer>",
          radius=3.0,
          renderer = frame.pyslip.LightweightDrawPointLayer,
          show_levels=[-2, -1, 0, 1, 2, 3, 4, 5])

  def use_case_2cpp(self,frame):
    from rstbx.bandpass import use_case_bp2_picture_fast_slow
    # Extend the model.  Assume monochromatic beam but finite radial mosaicity.  Dispense
    # with the "ewald proximity" mechanism; now spots are brought into reflecting condition
    # by a finite rotation about the axis that is longitudinal to the projection of the q-vector
    # onto the detector plane.

    from scitbx.matrix import col
    from math import pi

    detector_origin = col((-self.inputai.getBase().xbeam, -self.inputai.getBase().ybeam, 0.))

    from cctbx.crystal import symmetry
    crystal = symmetry(unit_cell=self.inputai.getOrientation().unit_cell(),space_group = "P1")
    indices = crystal.build_miller_set(anomalous_flag=True, d_min = self.limiting_resolution)

    picture_fast_slow = use_case_bp2_picture_fast_slow(
       indices=indices.indices(), orientation=self.inputai.getOrientation(),
       incident_beam=col((0.,0.,1.)), wavelength=self.inputai.wavelength,
       detector_normal=col((0.,0.,-1.)), detector_fast=col((0.,1.,0.)),detector_slow=col((1.,0.,0.)),
       pixel_size=col((self.pixel_size,self.pixel_size,0)),
       pixel_offset=col((0.5,0.5,0.0)), distance=self.inputai.getBase().distance,
       detector_origin=detector_origin,
       half_mosaicity_rad=0.1 * pi/180.
    )

    map_relative = frame.pyslip.tiles.vec_picture_fast_slow_to_map_relative(picture_fast_slow)

    self.orange_layer = frame.pyslip.AddPointLayer(
          map_relative, color="orange", name="<orange_layer>",
          radius=3.0,
          renderer = frame.pyslip.LightweightDrawPointLayer,
          show_levels=[-2, -1, 0, 1, 2, 3, 4, 5])

  def use_case_3cpp(self,frame):
    from rstbx.bandpass import use_case_bp3_picture_fast_slow
    # Extend the model.  Assume polychromatic beam with top hat profile.  Assume finite radial mosaicity.  Dispense
    # with the "ewald proximity" mechanism; now spots are brought into reflecting condition
    # by a finite rotation about the axis that is longitudinal to the projection of the q-vector
    # onto the detector plane.

    from scitbx.matrix import col
    from math import pi

    detector_origin = col((-self.inputai.getBase().xbeam, -self.inputai.getBase().ybeam, 0.))

    from cctbx.crystal import symmetry
    crystal = symmetry(unit_cell=self.inputai.getOrientation().unit_cell(),space_group = "P1")
    indices = crystal.build_miller_set(anomalous_flag=True, d_min = self.limiting_resolution)

    cpp_results = use_case_bp3_picture_fast_slow(
       indices=indices.indices(), orientation=self.inputai.getOrientation(),
       incident_beam=col((0.,0.,1.)),
       #tophat=col((self.inputai.wavelength,self.inputai.wavelength+0.00001,0.1*pi/180.)),
       tophat=col((self.inputai.wavelength*0.9975,self.inputai.wavelength*1.0025,0.1*pi/180.)),
       detector_normal=col((0.,0.,-1.)), detector_fast=col((0.,1.,0.)),detector_slow=col((1.,0.,0.)),
       pixel_size=col((self.pixel_size,self.pixel_size,0)),
       pixel_offset=col((0.5,0.5,0.0)), distance=self.inputai.getBase().distance,
       detector_origin=detector_origin
    )
    picture_fast_slow = cpp_results[0].select(cpp_results[2])
    map_relative = frame.pyslip.tiles.vec_picture_fast_slow_to_map_relative(picture_fast_slow)

    self.yellow_layer = frame.pyslip.AddPointLayer(
          map_relative, color="yellow", name="<yellow_layer>",
          radius=3.0,
          renderer = frame.pyslip.LightweightDrawPointLayer,
          show_levels=[-2, -1, 0, 1, 2, 3, 4, 5])
    picture_fast_slow = cpp_results[1].select(cpp_results[2])
    map_relative = frame.pyslip.tiles.vec_picture_fast_slow_to_map_relative(picture_fast_slow)

    self.red_layer = frame.pyslip.AddPointLayer(
          map_relative, color="red", name="<red_layer>",
          radius=3.0,
          renderer = frame.pyslip.LightweightDrawPointLayer,
          show_levels=[-2, -1, 0, 1, 2, 3, 4, 5])

  def use_case_3box(self,frame):
    from rstbx.bandpass import use_case_bp3_picture_fast_slow
    # Extend the model.  Assume polychromatic beam with top hat profile.  Assume finite radial mosaicity.  Dispense
    # with the "ewald proximity" mechanism; now spots are brought into reflecting condition
    # by a finite rotation about the axis that is longitudinal to the projection of the q-vector
    # onto the detector plane.

    from scitbx.matrix import col
    from math import pi

    detector_origin = col((-self.inputai.getBase().xbeam, -self.inputai.getBase().ybeam, 0.))

    from cctbx.crystal import symmetry
    crystal = symmetry(unit_cell=self.inputai.getOrientation().unit_cell(),space_group = "P1")
    indices = crystal.build_miller_set(anomalous_flag=True, d_min = self.limiting_resolution)
    half_mosaicity_rad = 0.1*pi/180.
    cpp_results = use_case_bp3_picture_fast_slow(
       indices=indices.indices(), orientation=self.inputai.getOrientation(),
       incident_beam=col((0.,0.,1.)),
       tophat=col((self.inputai.wavelength*0.9975,self.inputai.wavelength*1.0025,half_mosaicity_rad)),
       detector_normal=col((0.,0.,-1.)), detector_fast=col((0.,1.,0.)),detector_slow=col((1.,0.,0.)),
       pixel_size=col((self.pixel_size,self.pixel_size,0)),
       pixel_offset=col((0.5,0.5,0.0)), distance=self.inputai.getBase().distance,
       detector_origin=detector_origin
    )
    picture_fast_slow = cpp_results[0].select(cpp_results[2])
    map_relative_hi = frame.pyslip.tiles.vec_picture_fast_slow_to_map_relative(picture_fast_slow)
    picture_fast_slow = cpp_results[1].select(cpp_results[2])
    map_relative_lo = frame.pyslip.tiles.vec_picture_fast_slow_to_map_relative(picture_fast_slow)

    # not sure if I've swapped x/y correctly
    beam_coor = frame.pyslip.tiles.vec_picture_fast_slow_to_map_relative(
      [(0.5 + self.inputai.getBase().ybeam/self.pixel_size,
        0.5 + self.inputai.getBase().xbeam/self.pixel_size)])

    polydata = []
    beam_pos = col(beam_coor[0])
    for idx in range(len(map_relative_hi)):
      hi_pos = col(map_relative_hi[idx])
      lo_pos = col(map_relative_lo[idx])
      radial_vector = (hi_pos-beam_pos)
      radial_unit_vec = radial_vector.normalize()
      radius = radial_vector.length()
      tangential_unit_vec = col((-radial_unit_vec[1],radial_unit_vec[0])) # 90-degree rotation
      tangential_excursion = tangential_unit_vec * radius * half_mosaicity_rad
      polydata.append( ([(hi_pos + tangential_excursion).elems,
                         (hi_pos - tangential_excursion).elems,
                         (lo_pos - tangential_excursion).elems,
                         (lo_pos + tangential_excursion).elems,
                         (hi_pos + tangential_excursion).elems
                     ],{}) )

    self.red_layer = frame.pyslip.AddPolygonLayer( # needs to be changed for Linux (antialiasing removed)
          polydata, color="red", name="<red_layer>",
          width=1.0,
          show_levels=[-2, -1, 0, 1, 2, 3, 4, 5])

  def use_case_3_refactor(self,frame,half_deg,wave_HI, wave_LO,domain_size=0.):
    from rstbx.bandpass import use_case_bp3,parameters_bp3
    # Extend the model.  Assume polychromatic beam with top hat profile.  Assume finite radial mosaicity.  Dispense
    # with the "ewald proximity" mechanism; now spots are brought into reflecting condition
    # by a finite rotation about the axis that is longitudinal to the projection of the q-vector
    # onto the detector plane.

    from scitbx.matrix import col
    from math import pi

    detector_origin = col((-self.inputai.getBase().xbeam, -self.inputai.getBase().ybeam, 0.))

    from cctbx.crystal import symmetry
    crystal = symmetry(unit_cell=self.inputai.getOrientation().unit_cell(),space_group = "P1")
    indices = crystal.build_miller_set(anomalous_flag=True, d_min = self.limiting_resolution)
    half_mosaicity_rad = half_deg*pi/180.
    parameters = parameters_bp3(
       indices=indices.indices(), orientation=self.inputai.getOrientation(),
       incident_beam=col((0.,0.,1.)),
       packed_tophat=col((wave_HI,wave_LO,half_mosaicity_rad)),
       detector_normal=col((0.,0.,-1.)), detector_fast=col((0.,1.,0.)),detector_slow=col((1.,0.,0.)),
       pixel_size=col((self.pixel_size,self.pixel_size,0)),
       pixel_offset=col((0.5,0.5,0.0)), distance=self.inputai.getBase().distance,
       detector_origin=detector_origin
    )

    cpp_results = use_case_bp3(parameters=parameters)
    cpp_results.set_active_areas(
      frame.pyslip.tiles.raw_image.get_tile_manager(frame.inherited_params).effective_tiling_as_flex_int(
      reapply_peripheral_margin=True))
    cpp_results.prescreen_indices(self.inputai.wavelength)
    cpp_results.set_domain_size(domain_size)
    cpp_results.picture_fast_slow()
    picture_fast_slow = cpp_results.hi_E_limit.select(cpp_results.observed_flag)
    map_relative_hi = frame.pyslip.tiles.vec_picture_fast_slow_to_map_relative(picture_fast_slow)
    picture_fast_slow = cpp_results.lo_E_limit.select(cpp_results.observed_flag)
    map_relative_lo = frame.pyslip.tiles.vec_picture_fast_slow_to_map_relative(picture_fast_slow)

    poly = cpp_results.spot_rectangles((self.inputai.getBase().ybeam,self.inputai.getBase().xbeam,0.))
    map_relative_poly = frame.pyslip.tiles.vec_picture_fast_slow_to_map_relative(poly)
    cpp_polydata = []
    for idx in range(0,len(map_relative_poly),5):
      cpp_polydata.append( ([ map_relative_poly[idx+0],
                              map_relative_poly[idx+1],
                              map_relative_poly[idx+2],
                              map_relative_poly[idx+3],
                              map_relative_poly[idx+4]
                     ],{}) )

    self.red_layer = frame.pyslip.AddPolygonLayer( # needs to be changed for Linx (antialiasing removed)
          cpp_polydata, color="red", name="<red_layer>",
          width=1.0,
          show_levels=[-2, -1, 0, 1, 2, 3, 4, 5])

    poly = cpp_results.spot_rectregions((self.inputai.getBase().ybeam,self.inputai.getBase().xbeam,0.),1.0)
    map_relative_poly = frame.pyslip.tiles.vec_picture_fast_slow_to_map_relative(poly)
    cpp_polydata = []
    for idx in range(0,len(map_relative_poly),5):
      cpp_polydata.append( ([ map_relative_poly[idx+0],
                              map_relative_poly[idx+1],
                              map_relative_poly[idx+2],
                              map_relative_poly[idx+3],
                              map_relative_poly[idx+4]
                     ],{}) )

    self.pink_layer = frame.pyslip.AddPolygonLayer( # needs to be changed for Linx (antialiasing removed)
          cpp_polydata, color="pink", name="<pink_layer>",
          width=1.0,
          show_levels=[-2, -1, 0, 1, 2, 3, 4, 5])
    print("Entering C++ pixels")
    cpp_results.enclosed_pixels_and_margin_pixels()
    print("Done with C++ pixels")
    internal = cpp_results.enclosed_px
    map_relative_pixels = frame.pyslip.tiles.vec_picture_fast_slow_to_map_relative(internal)
    self.yellow_layer = frame.pyslip.AddPointLayer(
          map_relative_pixels, color="yellow", name="<yellow_layer>",
          radius=1.0,
          renderer = frame.pyslip.LightweightDrawPointLayer,
          show_levels=[-2, -1, 0, 1, 2, 3, 4, 5])
    internal = cpp_results.margin_px
    map_relative_pixels = frame.pyslip.tiles.vec_picture_fast_slow_to_map_relative(internal)
    self.green_layer = frame.pyslip.AddPointLayer(
          map_relative_pixels, color="green", name="<green_layer>",
          radius=1.0,
          renderer = frame.pyslip.LightweightDrawPointLayer,
          show_levels=[-2, -1, 0, 1, 2, 3, 4, 5])

    map_relative_pixels = frame.pyslip.tiles.vec_picture_fast_slow_to_map_relative(
                          cpp_results.selected_predictions())

    self.blue_layer = frame.pyslip.AddPointLayer(
          map_relative_pixels, color="blue", name="<blue_layer>",
          radius=2.0,
          renderer = frame.pyslip.LightweightDrawPointLayer,
          show_levels=[-2, -1, 0, 1, 2, 3, 4, 5])

    # Now figure out how to implement the scoring function. Do this in picture fast low coordinates
    # FIRST Set:  spot bodypixels:
    from annlib_ext import AnnAdaptorSelfInclude as AnnAdaptor
    body_pixel_reference = flex.double()
    for spot in self.spotfinder.images[self.frame_numbers[self.image_number]]["goodspots"]:
      for pxl in spot.bodypixels:
        body_pixel_reference.append(pxl.y + 0.5)
        body_pixel_reference.append(pxl.x + 0.5)
    self.adapt = AnnAdaptor(data=body_pixel_reference,dim=2,k=1)

    N_bodypix = body_pixel_reference.size()//2

    # second set:  predict box
    enclosed_pixels = cpp_results.enclosed_px
    N_enclosed = enclosed_pixels.size()
    N_enclosed_body_pixels = 0
    query = flex.double()
    for pixel in enclosed_pixels:
      query.append(pixel[0]); query.append(pixel[1])
    self.adapt.query(query)
    import math
    for p in range(N_enclosed):
      if math.sqrt(self.adapt.distances[p]) < 0.1:
        N_enclosed_body_pixels += 1

    # third set:  marginal
    marginal_pixels = cpp_results.margin_px
    margin_distances = cpp_results.margin_distances

    N_marginal = marginal_pixels.size()
    N_marginal_body_pixels = 0
    marginal_body = 0
    marginal_nonbody = 0
    query = flex.double()
    for pixel in marginal_pixels:
      query.append(pixel[0]); query.append(pixel[1])
    self.adapt.query(query)
    for p in range(N_marginal):
      if math.sqrt(self.adapt.distances[p]) < 0.1:
        N_marginal_body_pixels += 1
        marginal_body += 0.5 + 0.5 * math.cos (-math.pi * margin_distances[p]) #taking MARGIN==1
      else:
        marginal_nonbody += 0.5 + 0.5 * math.cos (math.pi * margin_distances[p])
    print("marginal body/nonbody",marginal_body, marginal_nonbody)

    print("There are %d body pixels of which %d are enclosed and %d are marginal leaving %d remote"%(
      N_bodypix,N_enclosed_body_pixels,N_marginal_body_pixels,
      N_bodypix-N_enclosed_body_pixels-N_marginal_body_pixels))
    print("There are %d enclosed pixels of which %d are body, %d are nonbody"%(
      N_enclosed,N_enclosed_body_pixels,N_enclosed-N_enclosed_body_pixels))
    print("There are %d marginal pixels of which %d are body, %d are nonbody"%(
      N_marginal,N_marginal_body_pixels,N_marginal-N_marginal_body_pixels))
    Score = 0
    # the scoring function to account for these spots:
    #    pink -- spot body pixels inside predict box = 0
    #    red  -- spot body pixels > 2 pxl away from predict box = 1
    Score += N_bodypix-N_enclosed_body_pixels-N_marginal_body_pixels
    #    gradation -- body pixels within the marginal zone
    Score += marginal_body + marginal_nonbody
    #    blank -- nonbody pixels outside of 2 pixel margin = 0
    #    yellow -- nonbody pixels inside predict box = 1
    Score += N_enclosed-N_enclosed_body_pixels
    #    gradation -- in between zone, within margin
    print("The score is",Score)

  def use_case_3_score_only(self,frame,half_deg,wave_HI, wave_LO):
    from rstbx.bandpass import use_case_bp3,parameters_bp3
    # Extend the model.  Assume polychromatic beam with top hat profile.  Assume finite radial mosaicity.  Dispense
    # with the "ewald proximity" mechanism; now spots are brought into reflecting condition
    # by a finite rotation about the axis that is longitudinal to the projection of the q-vector
    # onto the detector plane.

    from scitbx.matrix import col
    from math import pi

    detector_origin = col((-self.inputai.getBase().xbeam, -self.inputai.getBase().ybeam, 0.))

    from cctbx.crystal import symmetry
    crystal = symmetry(unit_cell=self.inputai.getOrientation().unit_cell(),space_group = "P1")
    indices = crystal.build_miller_set(anomalous_flag=True, d_min = self.limiting_resolution)
    half_mosaicity_rad = half_deg*pi/180.
    parameters = parameters_bp3(
       indices=indices.indices(), orientation=self.inputai.getOrientation(),
       incident_beam=col((0.,0.,1.)),
       packed_tophat=col((wave_HI,wave_LO,half_mosaicity_rad)),
       detector_normal=col((0.,0.,-1.)), detector_fast=col((0.,1.,0.)),detector_slow=col((1.,0.,0.)),
       pixel_size=col((self.pixel_size,self.pixel_size,0)),
       pixel_offset=col((0.5,0.5,0.0)), distance=self.inputai.getBase().distance,
       detector_origin=detector_origin
    )

    cpp_results = use_case_bp3(parameters=parameters)
    cpp_results.set_active_areas(
      frame.pyslip.tiles.raw_image.get_tile_manager(frame.inherited_params).effective_tiling_as_flex_int(
      reapply_peripheral_margin=True))
    cpp_results.picture_fast_slow()
    poly = cpp_results.spot_rectangles((self.inputai.getBase().ybeam,self.inputai.getBase().xbeam,0.))

    poly = cpp_results.spot_rectregions((self.inputai.getBase().ybeam,self.inputai.getBase().xbeam,0.),1.0)
    cpp_results.enclosed_pixels_and_margin_pixels()

    # Now figure out how to implement the scoring function. Do this in picture fast low coordinates
    # FIRST Set:  spot bodypixels:
    from annlib_ext import AnnAdaptorSelfInclude as AnnAdaptor
    body_pixel_reference = flex.double()
    for spot in self.spotfinder.images[self.frame_numbers[self.image_number]]["goodspots"]:
      for pxl in spot.bodypixels:
        body_pixel_reference.append(pxl.y + 0.5)
        body_pixel_reference.append(pxl.x + 0.5)
    self.adapt = AnnAdaptor(data=body_pixel_reference,dim=2,k=1)

    N_bodypix = body_pixel_reference.size()//2

    # second set:  predict box
    enclosed_pixels = cpp_results.enclosed_px
    N_enclosed = enclosed_pixels.size()
    N_enclosed_body_pixels = 0
    query = flex.double()
    for pixel in enclosed_pixels:
      query.append(pixel[0]); query.append(pixel[1])
    self.adapt.query(query)
    import math
    for p in range(N_enclosed):
      if math.sqrt(self.adapt.distances[p]) < 0.1:
        N_enclosed_body_pixels += 1

    # third set:  marginal
    marginal_pixels = cpp_results.margin_px
    margin_distances = cpp_results.margin_distances
    WGT = 50.
    N_marginal = marginal_pixels.size()
    N_marginal_body_pixels = 0
    marginal_body = 0
    marginal_nonbody = 0
    query = flex.double()
    for pixel in marginal_pixels:
      query.append(pixel[0]); query.append(pixel[1])
    self.adapt.query(query)
    for p in range(N_marginal):
      if math.sqrt(self.adapt.distances[p]) < 0.1:
        N_marginal_body_pixels += 1
        marginal_body += 0.5 + 0.5 * math.cos (-math.pi * margin_distances[p]) #taking MARGIN==1
      else:
        marginal_nonbody += 0.5 + 0.5 * math.cos (math.pi * margin_distances[p])
    marginal_body *=WGT
    if False:
      print("marginal body/nonbody",marginal_body, marginal_nonbody)
      print("There are %d body pixels of which %d are enclosed and %d are marginal leaving %d remote"%(
        N_bodypix,N_enclosed_body_pixels,N_marginal_body_pixels,
        N_bodypix-N_enclosed_body_pixels-N_marginal_body_pixels))
      print("There are %d enclosed pixels of which %d are body, %d are nonbody"%(
        N_enclosed,N_enclosed_body_pixels,N_enclosed-N_enclosed_body_pixels))
      print("There are %d marginal pixels of which %d are body, %d are nonbody"%(
        N_marginal,N_marginal_body_pixels,N_marginal-N_marginal_body_pixels))
    Score = 0
    # the scoring function to account for these spots:
    #    pink -- spot body pixels inside predict box = 0
    #    red  -- spot body pixels > 2 pxl away from predict box = 1
    Score += WGT*(N_bodypix-N_enclosed_body_pixels-N_marginal_body_pixels)
    #    gradation -- body pixels within the marginal zone
    Score += marginal_body + marginal_nonbody
    #    blank -- nonbody pixels outside of 2 pixel margin = 0
    #    yellow -- nonbody pixels inside predict box = 1
    Score += N_enclosed-N_enclosed_body_pixels
    #    gradation -- in between zone, within margin
    return Score

  def use_case_3_grid_refine(self,frame):
    reserve_orientation = self.inputai.getOrientation()

    wrapbp3 = wrapper_of_use_case_bp3( raw_image = frame.pyslip.tiles.raw_image,
      spotfinder = self.spotfinder, imageindex = self.frame_numbers[self.image_number],
      inputai = self.inputai,
      spot_prediction_limiting_resolution = self.limiting_resolution,
      phil_params = frame.inherited_params)
    wrapbp3.set_variables( orientation = self.inputai.getOrientation(),
                           wave_HI = self.inputai.wavelength*0.9975,
                           wave_LO = self.inputai.wavelength*1.0025,
                           half_mosaicity_deg = 0.1)
    #print "score...",wrapbp3.score_only()

    wave_HI = self.inputai.wavelength*0.9975
    wave_LO = self.inputai.wavelength*1.0025
    low_score = None
    for half_deg in [0.06, 0.08, 0.10, 0.12, 0.14]:
      for bandpass in [0.004, 0.005, 0.006, 0.007, 0.008]:
        for mean_multiplier in [0.9990, 1.0000, 1.0010, 1.0020]:
#               A1=0.;A2=0.;A3=0.
          for A1 in (math.pi/180.)*flex.double([-0.1,0.0,0.1]):
            for A2 in (math.pi/180.)*flex.double([-0.1,0.0,0.1]):
              for A3 in (math.pi/180.)*flex.double([-0.1,0.0,0.1]):
                ori = reserve_orientation.rotate_thru((1,0,0),A1).rotate_thru((0,1,0),A2).rotate_thru((0,0,1),A3)
                self.inputai.setOrientation(ori)
                HI = self.inputai.wavelength*(mean_multiplier-(bandpass/2.))
                LO = self.inputai.wavelength*(mean_multiplier+(bandpass/2.))
                #score = self.use_case_3_score_only(
                #       frame,half_deg,HI,LO)
                wrapbp3.set_variables( orientation = self.inputai.getOrientation(),
                           wave_HI = HI,wave_LO = LO,half_mosaicity_deg = half_deg)

                score = wrapbp3.score_only()
                if low_score == None or score < low_score:
                  low_score = score
                  best_params = (half_deg,HI,LO,ori,A1,A2,A3)
                  print("wave %7.4f - %7.4f bandpass %.2f half %7.4f score %7.1f"%(HI,LO,100.*(LO-HI)/LO,half_deg,score))
    print("Rendering image with wave %7.4f - %7.4f bandpass %.2f half %7.4f score %7.1f"%(
      best_params[1],best_params[2],100.*(best_params[2]-best_params[1])/best_params[1],best_params[0],low_score))
    print("rotation angles",best_params[4],best_params[5],best_params[6])
    return best_params

  def use_case_3_simulated_annealing(self,subpixel=None):
    reserve_orientation = self.inputai.getOrientation()

    wrapbp3 = wrapper_of_use_case_bp3( raw_image = self.imagefiles.images[self.image_number],
      spotfinder = self.spotfinder, imageindex = self.frame_numbers[self.image_number],
      inputai = self.inputai,
      spot_prediction_limiting_resolution = self.limiting_resolution,
      phil_params = self.horizons_phil,
      sub = subpixel)

    from rstbx.bandpass.simulated_annealing import SALight

    SA = SALight()

    # Half mosaicity in degrees
    # Mid-wavelength adjustment factor
    # Bandpass fractional full width
    # adjustment angle in degrees
    # adjustment angle in degrees
    # adjustment angle in degrees

    # starting values; likely expected values
    SA.x = flex.double([0.1,1.00,0.006,0.0,0.0,0.0])
    SA.initial = SA.x.deep_copy()

    # reasonable length scale (expected interval, half width)
    SA.L = flex.double([0.02,0.001,0.001,0.05,0.05,0.05])

    SA.format = "Mosaicity %6.3f Wave mean %7.4f bandpass %7.4f Angles %8.5f %8.5f %8.5f"

    def set_variables_from_sa_x(x):
      ori = reserve_orientation.rotate_thru((1,0,0),(math.pi/180.)*x[3]
                              ).rotate_thru((0,1,0),(math.pi/180.)*x[4]
                              ).rotate_thru((0,0,1),(math.pi/180.)*x[5])
      self.inputai.setOrientation(ori)
      mean_multiplier = x[1]
      bandpass = x[2]
      HI = self.inputai.wavelength*(mean_multiplier-(bandpass/2.))
      LO = self.inputai.wavelength*(mean_multiplier+(bandpass/2.))
      wrapbp3.set_variables( orientation = self.inputai.getOrientation(),
                           wave_HI = HI,wave_LO = LO,half_mosaicity_deg = x[0])
      #pack into format for calling function
      these_params = (x[0],HI,LO,ori,(math.pi/180.)*x[3],(math.pi/180.)*x[4],(math.pi/180.)*x[5])
      return these_params

    set_variables_from_sa_x(SA.x)
    last_score = wrapbp3.score_only()
    low_score = last_score + 0 # makes a copy
    Tstart = 600
    for T in range(Tstart, 1, -1):
      decreasing_increment = (T/Tstart)*SA.random_increment()
      last_x = SA.x.deep_copy()
      test_params = SA.x + decreasing_increment
      if test_params[2]<=0: continue # can't have negative bandpass; unphysical!
      if test_params[0]<=0: continue # can't have negative mosaicity; unphysical!
      SA.x += decreasing_increment
      print(T, SA.format%tuple(SA.x), end=' ')
      set_variables_from_sa_x(SA.x)
      new_score = wrapbp3.score_only()
      print("Score %8.1f"%new_score, end=' ')

      if new_score < low_score:
        low_score = 1.0*new_score
      if new_score < last_score:
        probability_of_acceptance=1.0
      else:
        probability_of_acceptance = math.exp(-(new_score-last_score)/(2.5*T))
      if flex.random_double(1)[0] < probability_of_acceptance:
        #new position accepted
        last_score = 1.0*new_score
        print("accepted")
      else:
        SA.x = last_x.deep_copy()
        print("rejected")

    print("Final")
    print(T, SA.format%tuple(SA.x),"Score %8.1f"%last_score,"final")

    #these three lines set the bp3 wrapper so it can be used from the calling class (simple_integration.py)
    best_params = set_variables_from_sa_x(SA.x)
    wrapbp3.score_only()
    self.bp3_wrapper = wrapbp3

    print("Rendering image with wave %7.4f - %7.4f bandpass %.2f half %7.4f score %7.1f"%(
      best_params[1],best_params[2],100.*(best_params[2]-best_params[1])/best_params[1],best_params[0],last_score))
    print("rotation angles",best_params[4],best_params[5],best_params[6])
    return best_params

  def use_case_3_simulated_annealing_7(self,subpixel=None):
    reserve_orientation = self.inputai.getOrientation()
    lowest_cell = max(reserve_orientation.unit_cell().parameters()[0:3])

    wrapbp3 = wrapper_of_use_case_bp3( raw_image = self.imagefiles.images[self.image_number],
      spotfinder = self.spotfinder, imageindex = self.frame_numbers[self.image_number],
      inputai = self.inputai,
      spot_prediction_limiting_resolution = self.limiting_resolution,
      phil_params = self.horizons_phil,
      sub = subpixel)

    from rstbx.bandpass.simulated_annealing import SALight

    SA = SALight()

    # Half mosaicity in degrees
    # Mid-wavelength adjustment factor
    # Bandpass fractional full width
    # adjustment angle in degrees
    # adjustment angle in degrees
    # adjustment angle in degrees

    # starting values; likely expected values
    SA.x = flex.double([0.1,1.00,0.006,0.0,0.0,0.0,lowest_cell*10.])
    SA.initial = SA.x.deep_copy()

    # reasonable length scale (expected interval, half width)
    SA.L = flex.double([0.02,0.001,0.001,0.05,0.05,0.05,lowest_cell*2.])

    SA.format = "Mosaicity %6.3f Wave mean %7.4f bandpass %7.4f Angles %8.5f %8.5f %8.5f, Domain %6.0f"

    def set_variables_from_sa_x(x):
      ori = reserve_orientation.rotate_thru((1,0,0),(math.pi/180.)*x[3]
                              ).rotate_thru((0,1,0),(math.pi/180.)*x[4]
                              ).rotate_thru((0,0,1),(math.pi/180.)*x[5])
      self.inputai.setOrientation(ori)
      mean_multiplier = x[1]
      bandpass = x[2]
      HI = self.inputai.wavelength*(mean_multiplier-(bandpass/2.))
      LO = self.inputai.wavelength*(mean_multiplier+(bandpass/2.))
      wrapbp3.set_variables( orientation = self.inputai.getOrientation(),
                           wave_HI = HI,wave_LO = LO,half_mosaicity_deg = x[0],
                           domain_size = x[6])
      #pack into format for calling function
      these_params = (x[0],HI,LO,ori,(math.pi/180.)*x[3],(math.pi/180.)*x[4],(math.pi/180.)*x[5],x[6])
      return these_params

    set_variables_from_sa_x(SA.x)
    last_score = wrapbp3.score_only()
    low_score = last_score + 0 # makes a copy
    Tstart = 600
    for T in range(Tstart, 1, -1):
      decreasing_increment = (T/Tstart)*SA.random_increment()
      last_x = SA.x.deep_copy()
      test_params = SA.x + decreasing_increment
      if test_params[2]<=0: continue # can't have negative bandpass; unphysical!
      if test_params[0]<=0: continue # can't have negative mosaicity; unphysical!
      if test_params[6]<lowest_cell: continue # crystal domain can't be lower than 1 unit cell
      SA.x += decreasing_increment
      print(T, SA.format%tuple(SA.x), end=' ')
      set_variables_from_sa_x(SA.x)
      new_score = wrapbp3.score_only()
      print("Score %8.1f"%new_score, end=' ')

      if new_score < low_score:
        low_score = 1.0*new_score
      if new_score < last_score:
        probability_of_acceptance=1.0
      else:
        probability_of_acceptance = math.exp(-(new_score-last_score)/(2.5*T))
      if flex.random_double(1)[0] < probability_of_acceptance:
        #new position accepted
        last_score = 1.0*new_score
        print("accepted")
      else:
        SA.x = last_x.deep_copy()
        print("rejected")

    print("Final")
    print(T, SA.format%tuple(SA.x),"Score %8.1f"%last_score,"final")

    #these three lines set the bp3 wrapper so it can be used from the calling class (simple_integration.py)
    best_params = set_variables_from_sa_x(SA.x)
    wrapbp3.score_only()
    self.bp3_wrapper = wrapbp3

    print("Rendering image with wave %7.4f - %7.4f bandpass %.2f half %7.4f score %7.1f"%(
      best_params[1],best_params[2],100.*(best_params[2]-best_params[1])/best_params[1],best_params[0],last_score))
    print("rotation angles",best_params[4],best_params[5],best_params[6],"Domain",best_params[7])
    return best_params

  def use_case_3_simulated_annealing_9(self,subpixel=None):
    reserve_orientation = self.inputai.getOrientation()
    lowest_cell = max(reserve_orientation.unit_cell().parameters()[0:3])

    wrapbp3 = wrapper_of_use_case_bp3( raw_image = self.imagefiles.images[self.image_number],
      spotfinder = self.spotfinder, imageindex = self.frame_numbers[self.image_number],
      inputai = self.inputai,
      spot_prediction_limiting_resolution = self.limiting_resolution,
      phil_params = self.horizons_phil,
      sub = subpixel)

    from rstbx.bandpass.simulated_annealing import SALight
    from cctbx.uctbx import unit_cell
    from rstbx.symmetry.constraints import AGconvert

    SA = SALight()

    # Half mosaicity in degrees
    # Mid-wavelength adjustment factor
    # Bandpass fractional full width
    # adjustment angle in degrees
    # adjustment angle in degrees
    # adjustment angle in degrees

    # starting values; likely expected values
    SA.x = flex.double([0.1,1.00,0.006,0.0,0.0,0.0,lowest_cell*10.,1.00,1.00])
    SA.initial = SA.x.deep_copy()

    # reasonable length scale (expected interval, half width)
    SA.L = flex.double([0.02,0.001,0.001,0.05,0.05,0.05,lowest_cell*2.,0.0002,0.0002])

    SA.format = "Mosaicity %6.3f Wave mean %7.4f bandpass %7.4f Angles %8.5f %8.5f %8.5f, Domain %6.0f, a,c %6.4f %6.4f"

    def set_variables_from_sa_x(x):
      # ------ Go through hoops just to reset a,c without altering the angles
      converter = AGconvert()
      converter.forward(reserve_orientation)
      model = converter.initial_model()
      old_uc = unit_cell(metrical_matrix=model[3:9])
      params = list(old_uc.parameters())
      params[0] *= x[7] # change a
      params[1] *= x[7] # change b for tetragonal, hexagonal a==b
      params[2] *= x[8] # change c
      new_uc = unit_cell(parameters=params)
      converter.validate_and_setG(new_uc.metrical_matrix())
      newori = converter.back_as_orientation()
      # ------ finished with unit cell lengths
      ori = newori.rotate_thru((1,0,0),(math.pi/180.)*x[3]
                              ).rotate_thru((0,1,0),(math.pi/180.)*x[4]
                              ).rotate_thru((0,0,1),(math.pi/180.)*x[5])
      self.inputai.setOrientation(ori)
      mean_multiplier = x[1]
      bandpass = x[2]
      HI = self.inputai.wavelength*(mean_multiplier-(bandpass/2.))
      LO = self.inputai.wavelength*(mean_multiplier+(bandpass/2.))
      wrapbp3.set_variables( orientation = self.inputai.getOrientation(),
                           wave_HI = HI,wave_LO = LO,half_mosaicity_deg = x[0],
                           domain_size = x[6])
      #pack into format for calling function
      these_params = (x[0],HI,LO,ori,(math.pi/180.)*x[3],(math.pi/180.)*x[4],(math.pi/180.)*x[5],x[6],x[7],x[8])
      return these_params

    set_variables_from_sa_x(SA.x)
    last_score = wrapbp3.score_only()
    low_score = last_score + 0 # makes a copy
    Tstart = 900
    for T in range(Tstart, 1, -1):
      decreasing_increment = (T/Tstart)*SA.random_increment()
      last_x = SA.x.deep_copy()
      test_params = SA.x + decreasing_increment
      if test_params[2]<=0: continue # can't have negative bandpass; unphysical!
      if test_params[0]<=0: continue # can't have negative mosaicity; unphysical!
      if test_params[6]<lowest_cell: continue # crystal domain can't be lower than 1 unit cell
      SA.x += decreasing_increment
      print(T, SA.format%tuple(SA.x), end=' ')
      set_variables_from_sa_x(SA.x)
      new_score = wrapbp3.score_only()
      print("Score %8.1f"%new_score, end=' ')

      if new_score < low_score:
        low_score = 1.0*new_score
      if new_score < last_score:
        probability_of_acceptance=1.0
      else:
        probability_of_acceptance = math.exp(-(new_score-last_score)/(2.5*T))
      if flex.random_double(1)[0] < probability_of_acceptance:
        #new position accepted
        last_score = 1.0*new_score
        print("accepted")
      else:
        SA.x = last_x.deep_copy()
        print("rejected")

    print("Final")
    print(T, SA.format%tuple(SA.x),"Score %8.1f"%last_score,"final")

    #these three lines set the bp3 wrapper so it can be used from the calling class (simple_integration.py)
    best_params = set_variables_from_sa_x(SA.x)
    wrapbp3.score_only()
    self.bp3_wrapper = wrapbp3

    print("Rendering image with wave %7.4f - %7.4f bandpass %.2f half %7.4f score %7.1f"%(
      best_params[1],best_params[2],100.*(best_params[2]-best_params[1])/best_params[1],best_params[0],last_score))
    print("rotation angles",best_params[4],best_params[5],best_params[6],"Domain",best_params[7])
    return best_params

try:
  from cxi_user import user_slip_callback
  slip_callbacks.slip_callback = user_slip_callback
except Exception:
  pass # no user-defined behavior


 *******************************************************************************


 *******************************************************************************
rstbx/apps/spot_markup.py
from __future__ import absolute_import, division, print_function
from six.moves import range
def slip_callback(self,frame):
  #best_params=self.use_case_3_simulated_annealing()
  #best_params = self.use_case_3_grid_refine(frame)
  #self.inputai.setOrientation(best_params[3])
  #self.use_case_3_refactor(frame,best_params[0],best_params[1], best_params[2])
  #self.inputai.set_orientation_reciprocal_matrix( (0.001096321006219932, -0.0007452314870693856, 0.007577824826005684, 0.0009042576974140007, -0.010205656871417366, -0.0009746502046169632, 0.012357726864252296, 0.00701297199602489, -0.0005717102325987258))
  #self.use_case_3_refactor(frame,0.0995603664049, 1.29155605957, 1.30470696644 )
  #self.use_case_3_refactor(frame,0.0995603664049, 1.29155605957, 1.30470696644,domain_size=2000. )

  normal = True
  # BLUE: predictions
  blue_data = []
  for ix,pred in enumerate(self.predicted):
      if self.BSmasks[ix].keys()==[]:continue
      x,y = frame.pyslip.tiles.picture_fast_slow_to_map_relative(
        (pred[1]/self.pixel_size) +0.5,
        (pred[0]/self.pixel_size) +0.5)
      blue_data.append((x,y))
  if False and normal: self.blue_layer = frame.pyslip.AddPointLayer(
        blue_data, color="blue", name="<blue_layer>",
        radius=2,
        renderer = frame.pyslip.LightweightDrawPointLayer,
        show_levels=[-2, -1, 0, 1, 2, 3, 4, 5])

  bmask_data = []; foreground_data = []
  count_integrated = 0
  for imsk in range(len(self.BSmasks)):
    smask_keys = self.get_ISmask(imsk)
    bmask = self.BSmasks[imsk]
    if len(bmask.keys())==0: continue
    count_integrated+=1

    # foreground: integration mask
    for ks in range(0,len(smask_keys),2):
      foreground_data.append(
        frame.pyslip.tiles.picture_fast_slow_to_map_relative(
         smask_keys[ks+1] + 0.5,smask_keys[ks] + 0.5))

    # background mask
    for key in bmask.keys():
      bmask_data.append(
        frame.pyslip.tiles.picture_fast_slow_to_map_relative(
          key[1] + 0.5 ,key[0] + 0.5))
  if normal: self.foreground_layer = frame.pyslip.AddPointLayer(
        foreground_data, color="cyan", name="<foreground_layer>",
        radius=1.5,
        renderer = frame.pyslip.LightweightDrawPointLayer,
        show_levels=[-2, -1, 0, 1, 2, 3, 4, 5])
  if normal:
    print("BLUE: plotting %d integrated spots"%count_integrated)
    self.bmask_layer = frame.pyslip.AddPointLayer(
        bmask_data, color="blue", name="<bmask_layer>",
        radius=1.5,
        renderer = frame.pyslip.LightweightDrawPointLayer,
        show_levels=[-2, -1, 0, 1, 2, 3, 4, 5])

  goodspots_data = []; refinedspots_data = []
  print("RED: plotting %d spotfinder goodspots"%len(self.spotfinder.images[self.frame_numbers[self.image_number]]["goodspots"]))
  for spot in self.spotfinder.images[self.frame_numbers[self.image_number]]["goodspots"]:
    # goodspots: spotfinder spot pixels
    for pxl in spot.bodypixels:
      goodspots_data.append(
        frame.pyslip.tiles.picture_fast_slow_to_map_relative(
          pxl.y + 0.5, pxl.x + 0.5))

    # GREEN: spotfinder centers of mass
    #green_data.append(
    #    frame.pyslip.tiles.picture_fast_slow_to_map_relative(
    #      spot.ctr_mass_y() + 0.5, spot.ctr_mass_x() + 0.5))

  print("YELLOW: plotting %d refinement spots"%len(self.spotfinder.images[self.frame_numbers[self.image_number]]["refinement_spots"]))
  for spot in self.spotfinder.images[self.frame_numbers[self.image_number]]["refinement_spots"]:
    # RED: spotfinder spot pixels
    for pxl in spot.bodypixels:
      refinedspots_data.append(
        frame.pyslip.tiles.picture_fast_slow_to_map_relative(
          pxl.y + 0.5, pxl.x + 0.5))

  self.goodspots_layer = frame.pyslip.AddPointLayer(
        goodspots_data, color="red", name="<goodspots_layer>",
        radius=1.5,
        renderer = frame.pyslip.LightweightDrawPointLayer,
        show_levels=[-2, -1, 0, 1, 2, 3, 4, 5])
  if normal: self.refinedspots_layer = frame.pyslip.AddPointLayer(
        refinedspots_data, color="yellow", name="<refinedspots_layer>",
        radius=2.0,
        renderer = frame.pyslip.LightweightDrawPointLayer,
        show_levels=[-2, -1, 0, 1, 2, 3, 4, 5])

setattr(slip_callback,"requires_refinement_spots",True)


 *******************************************************************************


 *******************************************************************************
rstbx/apps/stills/__init__.py


 *******************************************************************************


 *******************************************************************************
rstbx/apps/stills/deltapsi_refinement_preceding_integration.py
from __future__ import absolute_import, division, print_function
from rstbx.apps.stills.simple_integration import IntegrationMetaProcedure
from rstbx.apps import simple_integration

class integrate_one_frame(IntegrationMetaProcedure):
  def __init__(self):
    simple_integration.__init__(self)
    IntegrationMetaProcedure.__init__(self)


 *******************************************************************************


 *******************************************************************************
rstbx/apps/stills/dials_refinement_preceding_integration.py
from __future__ import absolute_import, division, print_function
from six.moves import range
from rstbx.apps.stills.simple_integration import IntegrationMetaProcedure
from rstbx.apps import simple_integration
from scitbx import matrix
import math,copy
from dials.array_family import flex
from six.moves import zip

class integrate_one_frame(IntegrationMetaProcedure):
  def __init__(self, triclinic):
    simple_integration.__init__(self)
    IntegrationMetaProcedure.__init__(self)
    self.triclinic_pairs = triclinic.triclinic_pairs
    self.triclinic = triclinic

  def integration_concept(self, image_number, cb_op_to_primitive, verbose=False, **kwargs):
    if kwargs.get("user-reentrant") != None:
      return self.integration_concept_detail(experiments=kwargs.get("reentrant_experiments"),
                                    reflections=kwargs.get("reentrant_reflections"),
                                    spots=self.triclinic.get_observations_with_outlier_removal(),
                                    image_number=image_number, cb_op_to_primitive=cb_op_to_primitive, **kwargs)

    experiments = self.prepare_dxtbx_models(setting_specific_ai = self.triclinic.inputai, sg="P1")
    reflections = self.prepare_reflection_list(experiments[0].detector)
    self.refine(experiments=experiments, reflections=reflections)

    if self.horizons_phil.isoforms == []: # normal behavior; no isoform constraints
      setting_experiments = self.prepare_dxtbx_models(setting_specific_ai = self.inputai,
      sg = self.inputpd["symmetry"].space_group_info().type().lookup_symbol())
      setting_reflections = copy.deepcopy(reflections)
      setting_reflections["miller_index"] = cb_op_to_primitive.inverse().apply(reflections["miller_index"])
      R = self.refine(experiments=setting_experiments, reflections=setting_reflections)
    else:
      isoform_refineries = []
      setting_reflections = copy.deepcopy(reflections)
      setting_reflections["miller_index"] = cb_op_to_primitive.inverse().apply(reflections["miller_index"])
      look_symbol = self.inputpd["symmetry"].space_group_info().type().lookup_symbol()

      for isoform in self.horizons_phil.isoforms:
        print("Testing isoform %s"%isoform.name,isoform.cell.parameters())
        print("asserting", look_symbol ,"==", isoform.lookup_symbol)

        assert look_symbol == isoform.lookup_symbol
        setting_experiments = self.prepare_dxtbx_models(setting_specific_ai = self.inputai,
          sg = look_symbol, isoform = isoform.cell )
        P = self.refine(experiments=setting_experiments, reflections=setting_reflections, isoform=True)
        print(P.rmsds())
        isoform_refineries.append(P)
      positional_rmsds = [math.sqrt(P.rmsds()[0]**2 + P.rmsds()[1]**2) for P in isoform_refineries]
      print("Positional rmsds for all isoforms:", positional_rmsds)
      minrmsd_mm = min(positional_rmsds)
      minindex = positional_rmsds.index(minrmsd_mm)
      print("The smallest rmsd is %5.1f um from isoform %s"%(1000.*minrmsd_mm,self.horizons_phil.isoforms[minindex].name))
      if self.horizons_phil.isoforms[minindex].rmsd_target_mm is not None:
        print("asserting",minrmsd_mm ,"<", self.horizons_phil.isoforms[minindex].rmsd_target_mm)
        assert minrmsd_mm < self.horizons_phil.isoforms[minindex].rmsd_target_mm
      print("Acceptable rmsd for isoform %s."%(self.horizons_phil.isoforms[minindex].name), end=' ')
      if len (self.horizons_phil.isoforms)==2:
        print("Rmsd gain over the other isoform %5.1f um."%(1000.*abs(positional_rmsds[0] - positional_rmsds[1])))
      else:
        print()
      R = isoform_refineries[minindex]
      # Now one last check to see if direct beam is out of bounds
      if self.horizons_phil.isoforms[minindex].beam_restraint is not None:
        refined_beam = matrix.col(R.get_experiments()[0].detector[0].get_beam_centre(experiments[0].beam.get_s0()))
        known_beam = matrix.col(self.horizons_phil.isoforms[minindex].beam_restraint)
        print("asserting",(refined_beam-known_beam).length(),"<",self.horizons_phil.isoforms[minindex].rmsd_target_mm)
        assert (refined_beam-known_beam).length() < self.horizons_phil.isoforms[minindex].rmsd_target_mm
        # future--circle of confusion could be given as a separate length in mm instead of reusing rmsd_target
      self.identified_isoform = self.horizons_phil.isoforms[minindex].name

    self.integration_concept_detail(experiments=R.get_experiments(), reflections=setting_reflections,
                                    spots=self.triclinic.get_observations_with_outlier_removal(),
                                    image_number=image_number, cb_op_to_primitive=cb_op_to_primitive, **kwargs)

  def integration_concept_detail(self, experiments, reflections, spots,image_number,cb_op_to_primitive,**kwargs):
    detector = experiments[0].detector
    crystal = experiments[0].crystal
    from cctbx.crystal import symmetry
    c_symmetry = symmetry(space_group = crystal.get_space_group(), unit_cell = crystal.get_unit_cell())

    self.image_number = image_number
    NEAR = 10
    pxlsz = detector[0].get_pixel_size()

    Predicted = self.get_predictions_accounting_for_centering(experiments,reflections,cb_op_to_primitive,**kwargs)

    FWMOSAICITY = self.inputai.getMosaicity()
    self.DOMAIN_SZ_ANG = kwargs.get("domain_size_ang",  self.__dict__.get("actual",0)  )
    refineflag = {True:0,False:1}[kwargs.get("domain_size_ang",0)==0]
    c_symmetry.show_summary(prefix="EXCURSION%1d REPORT FWMOS= %6.4f DOMAIN= %6.1f "%(refineflag,FWMOSAICITY,self.DOMAIN_SZ_ANG))
    from annlib_ext import AnnAdaptor
    self.cell = c_symmetry.unit_cell()

    query = flex.double()
    print(len(self.predicted))

    for pred in self.predicted: # predicted spot coord in pixels
      query.append(pred[0]/pxlsz[0])
      query.append(pred[1]/pxlsz[1])

    self.reserve_hkllist_for_signal_search = self.hkllist

    reference = flex.double()

    assert self.length>NEAR# Can't do spot/pred matching with too few spots
    for spot in spots:
      reference.append(spot.ctr_mass_x())
      reference.append(spot.ctr_mass_y())

    IS_adapt = AnnAdaptor(data=reference,dim=2,k=NEAR)
    IS_adapt.query(query)
    idx_cutoff = float(min(self.mask_focus[image_number]))

    from rstbx.apps.slip_helpers import slip_callbacks
    cache_refinement_spots = getattr(slip_callbacks.slip_callback,"requires_refinement_spots",False)

    indexed_pairs_provisional = []
    correction_vectors_provisional = []
    c_v_p_flex = flex.vec3_double()
    this_setting_matched_indices = reflections["miller_index"]
    for j,item in enumerate(this_setting_matched_indices):
      this_setting_index = self.hkllist.first_index(item)
      if this_setting_index:
        Match = dict(spot=j,pred=this_setting_index)
        indexed_pairs_provisional.append(Match)
        vector = matrix.col(
            [reflections["xyzobs.px.value"][j][0] - self.predicted[Match["pred"]][0]/pxlsz[0],
             reflections["xyzobs.px.value"][j][1] - self.predicted[Match["pred"]][1]/pxlsz[1]])
        correction_vectors_provisional.append(vector)
        c_v_p_flex.append((vector[0],vector[1],0.))
    self.N_correction_vectors = len(correction_vectors_provisional)
    self.rmsd_px = math.sqrt(flex.mean(c_v_p_flex.dot(c_v_p_flex)))
    print("... %d provisional matches"%self.N_correction_vectors, end=' ')
    print("r.m.s.d. in pixels: %6.3f"%(self.rmsd_px))

    if self.horizons_phil.integration.enable_residual_scatter:
      from matplotlib import pyplot as plt
      fig = plt.figure()
      for cv in correction_vectors_provisional:
        plt.plot([cv[1]],[-cv[0]],"r.")
      plt.title(" %d matches, r.m.s.d. %5.2f pixels"%(len(correction_vectors_provisional),math.sqrt(flex.mean(c_v_p_flex.dot(c_v_p_flex)))))
      plt.axes().set_aspect("equal")
      self.show_figure(plt,fig,"res")
      plt.close()

    if self.horizons_phil.integration.enable_residual_map:
      from matplotlib import pyplot as plt
      PX = reflections["xyzobs.px.value"]
      fig = plt.figure()
      for match,cv in zip(indexed_pairs_provisional,correction_vectors_provisional):
        plt.plot([PX[match["spot"]][1]],[-PX[match["spot"]][0]],"r.")
        plt.plot([self.predicted[match["pred"]][1]/pxlsz[1]],[-self.predicted[match["pred"]][0]/pxlsz[0]],"g.")
        plt.plot([PX[match["spot"]][1], PX[match["spot"]][1] + 10.*cv[1]],
                 [-PX[match["spot"]][0], -PX[match["spot"]][0] - 10.*cv[0]],'r-')
      if kwargs.get("user-reentrant") != None and self.horizons_phil.integration.spot_prediction == "dials" \
             and self.horizons_phil.integration.enable_residual_map_deltapsi:
        from rstbx.apps.stills.util import residual_map_special_deltapsi_add_on
        residual_map_special_deltapsi_add_on(
          reflections = self.dials_spot_prediction,
          matches = indexed_pairs_provisional, experiments=experiments,
          hkllist = self.hkllist,
          predicted = self.predicted, plot=plt, eta_deg=FWMOSAICITY, deff=self.DOMAIN_SZ_ANG
          )
      plt.xlim([0,detector[0].get_image_size()[1]])
      plt.ylim([-detector[0].get_image_size()[0],0])
      plt.title(" %d matches, r.m.s.d. %5.2f pixels"%(len(correction_vectors_provisional),math.sqrt(flex.mean(c_v_p_flex.dot(c_v_p_flex)))))
      plt.axes().set_aspect("equal")
      self.show_figure(plt,fig,"map")
      plt.close()

    indexed_pairs = indexed_pairs_provisional
    correction_vectors = correction_vectors_provisional
    ########### skip outlier rejection for this derived class

    ### However must retain the ability to write out correction vectiors.
    if True: # at Aaron's request; test later
      correction_lengths = flex.double([v.length() for v in correction_vectors_provisional])
      clorder = flex.sort_permutation(correction_lengths)
      sorted_cl = correction_lengths.select(clorder)
      indexed_pairs = []
      correction_vectors = []
      self.correction_vectors = []
      for icand in range(len(sorted_cl)):
        # somewhat arbitrary sigma = 1.0 cutoff for outliers
        indexed_pairs.append(indexed_pairs_provisional[clorder[icand]])
        correction_vectors.append(correction_vectors_provisional[clorder[icand]])
        if cache_refinement_spots:
          self.spotfinder.images[self.frame_numbers[self.image_number]]["refinement_spots"].append(
          spots[reflections[indexed_pairs[-1]["spot"]]['spotfinder_lookup']])
        if kwargs.get("verbose_cv")==True:
            print("CV OBSCENTER %7.2f %7.2f REFINEDCENTER %7.2f %7.2f"%(
              float(self.inputpd["size1"])/2.,float(self.inputpd["size2"])/2.,
              self.inputai.xbeam()/pxlsz[0], self.inputai.ybeam()/pxlsz[1]), end=' ')
            print("OBSSPOT %7.2f %7.2f PREDSPOT %7.2f %7.2f"%(
              reflections[indexed_pairs[-1]["spot"]]['xyzobs.px.value'][0],
              reflections[indexed_pairs[-1]["spot"]]['xyzobs.px.value'][1],
              self.predicted[indexed_pairs[-1]["pred"]][0]/pxlsz[0],
              self.predicted[indexed_pairs[-1]["pred"]][1]/pxlsz[1]), end=' ')
            the_hkl = self.hkllist[indexed_pairs[-1]["pred"]]
            print("HKL %4d %4d %4d"%the_hkl,"%2d"%self.setting_id, end=' ')
            radial, azimuthal = spots[indexed_pairs[-1]["spot"]].get_radial_and_azimuthal_size(
              self.inputai.xbeam()/pxlsz[0], self.inputai.ybeam()/pxlsz[1])
            print("RADIALpx %5.3f AZIMUTpx %5.3f"%(radial,azimuthal))

        # Store a list of correction vectors in self.
        radial, azimuthal = spots[indexed_pairs[-1]['spot']].get_radial_and_azimuthal_size(
          self.inputai.xbeam()/pxlsz[0], self.inputai.ybeam()/pxlsz[1])
        self.correction_vectors.append(
          dict(obscenter=(float(self.inputpd['size1']) / 2,
                          float(self.inputpd['size2']) / 2),
               refinedcenter=(self.inputai.xbeam() / pxlsz[0],
                              self.inputai.ybeam() / pxlsz[1]),
               obsspot=(reflections[indexed_pairs[-1]['spot']]['xyzobs.px.value'][0],
                        reflections[indexed_pairs[-1]['spot']]['xyzobs.px.value'][1]),
               predspot=(self.predicted[indexed_pairs[-1]['pred']][0] / pxlsz[0],
                         self.predicted[indexed_pairs[-1]['pred']][1] / pxlsz[1]),
               hkl=(self.hkllist[indexed_pairs[-1]['pred']][0],
                    self.hkllist[indexed_pairs[-1]['pred']][1],
                    self.hkllist[indexed_pairs[-1]['pred']][2]),
               setting_id=self.setting_id,
               radial=radial,
               azimuthal=azimuthal))


    self.inputpd["symmetry"] = c_symmetry
    self.inputpd["symmetry"].show_summary(prefix="SETTING ")


    if self.horizons_phil.integration.model == "user_supplied":
      # Not certain of whether the reentrant_* dictionary keys create a memory leak
      if kwargs.get("user-reentrant",None)==None:
        kwargs["reentrant_experiments"] = experiments
        kwargs["reentrant_reflections"] = reflections
        from cxi_user import post_outlier_rejection
        self.indexed_pairs = indexed_pairs
        self.spots = spots
        post_outlier_rejection(self,image_number,cb_op_to_primitive,self.horizons_phil,kwargs)
        return
    ########### finished with user-supplied code


    correction_lengths=flex.double([v.length() for v in correction_vectors])

    self.r_residual = pxlsz[0]*flex.mean(correction_lengths)

    #assert len(indexed_pairs)>NEAR # must have enough indexed spots
    if (len(indexed_pairs) <= NEAR):
      raise Sorry("Not enough indexed spots, only found %d, need %d" % (len(indexed_pairs), NEAR))

    reference = flex.double()
    for item in indexed_pairs:
      reference.append(spots[item["spot"]].ctr_mass_x())
      reference.append(spots[item["spot"]].ctr_mass_y())

    PS_adapt = AnnAdaptor(data=reference,dim=2,k=NEAR)
    PS_adapt.query(query)

    self.BSmasks = []
    # do not use null: self.null_correction_mapping( predicted=self.predicted,
    self.positional_correction_mapping( predicted=self.predicted,
                                        correction_vectors = correction_vectors,
                                        PS_adapt = PS_adapt,
                                        IS_adapt = IS_adapt,
                                        spots = spots)

    # which spots are close enough to interfere with background?
    MAXOVER=6
    OS_adapt = AnnAdaptor(data=query,dim=2,k=MAXOVER) #six near nbrs
    OS_adapt.query(query)
    if self.mask_focus[image_number] is None:
      raise Sorry("No observed/predicted spot agreement; no Spotfinder masks; skip integration")
    nbr_cutoff = 2.0* max(self.mask_focus[image_number])
    FRAME = int(nbr_cutoff/2)
    #print "The overlap cutoff is %d pixels"%nbr_cutoff
    nbr_cutoff_sq = nbr_cutoff * nbr_cutoff

    #print "Optimized C++ section...",
    self.set_frame(FRAME)
    self.set_background_factor(kwargs["background_factor"])
    self.set_nbr_cutoff_sq(nbr_cutoff_sq)
    self.set_guard_width_sq(self.horizons_phil.integration.guard_width_sq)
    self.set_detector_gain(self.horizons_phil.integration.detector_gain)
    flex_sorted = flex.int()
    for item in self.sorted:
      flex_sorted.append(item[0]);flex_sorted.append(item[1]);

    if self.horizons_phil.integration.mask_pixel_value is not None:
      self.set_mask_pixel_val(self.horizons_phil.integration.mask_pixel_value)

    image_obj = self.imagefiles.imageindex(self.frame_numbers[self.image_number])
    image_obj.read()
    rawdata = image_obj.linearintdata # assume image #1

    if self.inputai.active_areas != None:
      self.detector_xy_draft = self.safe_background( rawdata=rawdata,
                          predicted=self.predicted,
                          OS_adapt=OS_adapt,
                          sorted=flex_sorted,
                          tiles=self.inputai.active_areas.IT,
                          tile_id=self.inputai.active_areas.tile_id);
    else:
      self.detector_xy_draft = self.safe_background( rawdata=rawdata,
                          predicted=self.predicted,
                          OS_adapt=OS_adapt,
                          sorted=flex_sorted);
    for i in range(len(self.predicted)): # loop over predicteds
      B_S_mask = {}
      keys = self.get_bsmask(i)
      for k in range(0,len(keys),2):
        B_S_mask[(keys[k],keys[k+1])]=True
      self.BSmasks.append(B_S_mask)
    #print "Done"
    return

  def get_predictions_accounting_for_centering(self,experiments,reflections,cb_op_to_primitive,**kwargs):
    # interface requires this function to set current_orientation
    # in the actual setting used for Miller index calculation
    detector = experiments[0].detector
    crystal = experiments[0].crystal

    if self.horizons_phil.integration.model == "user_supplied":

      lower_limit_domain_size = math.pow(
       crystal.get_unit_cell().volume(),
       1./3.)*self.horizons_phil.integration.mosaic.domain_size_lower_limit # default 10-unit cell block size minimum reasonable domain
      actual_used_domain_size = kwargs.get("domain_size_ang",lower_limit_domain_size)

      self.block_counter+=1
      rot_mat = matrix.sqr(cb_op_to_primitive.c().r().as_double()).transpose()

      from cctbx.crystal_orientation import crystal_orientation, basis_type
      centered_orientation = crystal_orientation(crystal.get_A(),basis_type.reciprocal)
      self.current_orientation = centered_orientation
      self.current_cb_op_to_primitive = cb_op_to_primitive
      primitive_orientation = centered_orientation.change_basis(rot_mat)

      self.inputai.setOrientation(primitive_orientation)
      from cxi_user import pre_get_predictions
      if self.block_counter < 2:
        KLUDGE = self.horizons_phil.integration.mosaic.kludge1 # bugfix 1 of 2 for protocol 6, equation 2
        self.inputai.setMosaicity(KLUDGE*self.inputai.getMosaicity())

      oldbase = self.inputai.getBase()

      #print oldbase.xbeam, oldbase.ybeam
      newbeam = detector[0].get_beam_centre(experiments[0].beam.get_s0())
      newdistance = -detector[0].get_beam_centre_lab(experiments[0].beam.get_s0())[2]

      from labelit.dptbx import Parameters
      base = Parameters(xbeam = newbeam[0], ybeam = newbeam[1], #oldbase.xbeam, ybeam = oldbase.ybeam,
                        distance = newdistance, twotheta = 0.0)
      self.inputai.setBase(base)
      self.inputai.setWavelength(experiments[0].beam.get_wavelength())

      self.bp3_wrapper = pre_get_predictions(self.inputai, self.horizons_phil,
        raw_image = self.imagefiles.images[self.image_number],
        imageindex = self.frame_numbers[self.image_number],
        spotfinder = self.spotfinder,
        limiting_resolution = self.limiting_resolution,
        domain_size_ang = actual_used_domain_size,
        )

      BPpredicted = self.bp3_wrapper.ucbp3.selected_predictions_labelit_format()
      BPhkllist = self.bp3_wrapper.ucbp3.selected_hkls()

      self.actual = actual_used_domain_size
      primitive_hkllist = BPhkllist
      #not sure if matrix needs to be transposed first for outputting HKL's???:
      self.hkllist = cb_op_to_primitive.inverse().apply(primitive_hkllist)

      if self.horizons_phil.integration.spot_prediction == "dials":
        from dials.algorithms.spot_prediction import StillsReflectionPredictor
        predictor = StillsReflectionPredictor(experiments[0])
        Rcalc = flex.reflection_table.empty_standard(len(self.hkllist))
        Rcalc['miller_index'] = self.hkllist
        predictor.for_reflection_table(Rcalc, crystal.get_A())
        self.predicted = Rcalc['xyzcal.mm']
        self.dials_spot_prediction = Rcalc
        self.dials_model = experiments

      elif self.horizons_phil.integration.spot_prediction == "ucbp3":
        self.predicted = BPpredicted

      self.inputai.setOrientation(centered_orientation)
      if self.inputai.active_areas != None:
        self.predicted,self.hkllist = self.inputai.active_areas(
                                      self.predicted,self.hkllist,self.pixel_size)
      if self.block_counter < 2:
         down = self.inputai.getMosaicity()/KLUDGE
         print("Readjusting mosaicity back down to ",down)
         self.inputai.setMosaicity(down)
      return

  def refine(self, experiments, reflections, isoform=None):
    from dials.algorithms.refinement.refiner import phil_scope
    from libtbx.phil import parse

    params = phil_scope.fetch(source=parse('')).extract()
    params.refinement.reflections.weighting_strategy.delpsi_constant=100000.
    params.refinement.reflections.weighting_strategy.override="stills"
    params.refinement.parameterisation.auto_reduction.action="fix"
    #params.refinement.reflections.do_outlier_rejection=True
    #params.refinement.reflections.iqr_multiplier=0.5
    #params.refinement.reflections.minimum_sample_size=50
    #params.refinement.reflections.maximum_sample_size=50
    #params.refinement.reflections.random_seed=1
    if self.horizons_phil.integration.dials_refinement.strategy=="distance":
      params.refinement.parameterisation.beam.fix="all"
      params.refinement.parameterisation.detector.fix_list=["Tau1"] # fix detector rotz, allow distance to refine
    elif self.horizons_phil.integration.dials_refinement.strategy=="wavelength":
      params.refinement.parameterisation.beam.fix="in_spindle_plane,out_spindle_plane"
      params.refinement.parameterisation.detector.fix_list=["Dist","Tau1"] # fix detector rotz and distance
    elif self.horizons_phil.integration.dials_refinement.strategy=="fix":
      params.refinement.parameterisation.beam.fix="all"
      params.refinement.parameterisation.detector.fix_list=["Dist","Tau1"] # fix detector rotz and distance
    if isoform is not None:
      params.refinement.reflections.outlier.algorithm="null"
      params.refinement.parameterisation.crystal.fix="cell"
    from dials.algorithms.refinement.refiner import RefinerFactory
    refiner = RefinerFactory.from_parameters_data_experiments(params,
      reflections, experiments)

    history = refiner.run()
    print(history.keys())
    for item in history["rmsd"]:
      print("%5.2f %5.2f %8.5f"%(item[0],item[1],180.*item[2]/math.pi))

    #for item in history["parameter_vector"]:
    #  print ["%8.5f"%a for a in item]
    print(refiner.selection_used_for_refinement().count(True),"spots used for refinement")
    print(refiner.get_experiments()[0].beam)
    print(refiner.get_experiments()[0].detector)
    print("Distance:", -refiner.get_experiments()[0].detector[0].get_beam_centre_lab(refiner.get_experiments()[0].beam.get_s0())[2])
    print(refiner.get_experiments()[0].crystal)
    return refiner

  def prepare_reflection_list(self,detector):

    spots = self.triclinic.get_observations_with_outlier_removal()
    ordinary_python_list_of_indexed_observations = [
      {
        "id":0,
        "panel":0,
        "miller_index":item["pred"],
        "xyzobs.px.value":(spots[item["spot"]].ctr_mass_x(),spots[item["spot"]].ctr_mass_y(),0.0),
        "xyzobs.px.variance":(0.25,0.25,0.25),
        "spotfinder_lookup":item["spot"]
      }
      for item in self.triclinic_pairs
    ]

    self.length = len(ordinary_python_list_of_indexed_observations)
    R= flex.reflection_table.empty_standard(self.length)

    R['miller_index'] = flex.miller_index([item["miller_index"] for item in ordinary_python_list_of_indexed_observations])
    R['xyzobs.px.value'] = flex.vec3_double([item["xyzobs.px.value"] for item in ordinary_python_list_of_indexed_observations])
    R['xyzobs.px.variance'] = flex.vec3_double([item["xyzobs.px.variance"] for item in ordinary_python_list_of_indexed_observations])
    R['spotfinder_lookup'] = flex.int([item["spotfinder_lookup"] for item in ordinary_python_list_of_indexed_observations])

    R['xyzobs.mm.value'] = flex.vec3_double(self.length)
    R['xyzobs.mm.variance'] = flex.vec3_double(self.length)

    pxlsz = detector[0].get_pixel_size()

    for idx in range(self.length):
      R['xyzobs.mm.value'][idx] = (R['xyzobs.px.value'][idx][0]*pxlsz[0], R['xyzobs.px.value'][idx][1]*pxlsz[1], R['xyzobs.px.value'][idx][2])
      R['xyzobs.mm.variance'][idx] = (R['xyzobs.px.variance'][idx][0]*pxlsz[0], R['xyzobs.px.variance'][idx][1]*pxlsz[1], R['xyzobs.px.variance'][idx][2])

    return R

  def prepare_dxtbx_models(self,setting_specific_ai,sg,isoform=None):

    from dxtbx.model import BeamFactory
    beam = BeamFactory.simple(wavelength = self.inputai.wavelength)

    from dxtbx.model import DetectorFactory
    detector = DetectorFactory.simple(
      sensor = DetectorFactory.sensor("PAD"),
      distance = setting_specific_ai.distance(),
      beam_centre = [setting_specific_ai.xbeam(), setting_specific_ai.ybeam()],
      fast_direction = "+x",
      slow_direction = "+y",
      pixel_size = [self.pixel_size,self.pixel_size],
      image_size = [self.inputpd['size1'],self.inputpd['size1']],
      )

    direct = matrix.sqr(setting_specific_ai.getOrientation().direct_matrix())
    from dxtbx.model import MosaicCrystalKabsch2010
    crystal = MosaicCrystalKabsch2010(
      real_space_a = matrix.row(direct[0:3]),
      real_space_b = matrix.row(direct[3:6]),
      real_space_c = matrix.row(direct[6:9]),
      space_group_symbol = sg,
    )
    crystal.set_mosaicity(setting_specific_ai.getMosaicity())
    if isoform is not None:
      newB = matrix.sqr(isoform.fractionalization_matrix()).transpose()
      crystal.set_B(newB)

    from dxtbx.model import Experiment, ExperimentList
    experiments = ExperimentList()
    experiments.append(Experiment(beam=beam,
                                  detector=detector,
                                  crystal=crystal))

    print(beam)
    print(detector)
    print(crystal)
    return experiments


 *******************************************************************************


 *******************************************************************************
rstbx/apps/stills/simple_integration.py
from __future__ import absolute_import, division, print_function
from six.moves import range
import math
from cctbx.array_family import flex
from scitbx import matrix
from libtbx.utils import Sorry

#234567890123456789212345678931234567894123456789512345678961234567897123456789812

from labelit.dptbx.profile_support import show_profile
from rstbx.apps.slip_helpers import slip_callbacks
from rstbx.dials_core.integration_core import integration_core
from six.moves import zip

class IntegrationMetaProcedure(integration_core,slip_callbacks):

  def __init__(self):
    self.block_counter = 0

  def set_up_mask_focus(self,verbose=False):
    self.mask_focus = []
    for frame in self.frame_numbers:
      focus = self.spotfinder.pd['masks'][frame][0:2]
      if len(self.spotfinder.pd['masks'][frame]) < 3 or self.spotfinder.pd['masks'][frame][2] is None:
        self.mask_focus.append( None )
        raise Sorry("No average profile available to set up the integration mask")
        continue; #no average profile; no pred/obs agreement; nothing possible
      average_profile = self.inputpd['masks'][frame][2]
      if verbose:
        box = self.inputpd['masks'][frame][3]
        print(average_profile.focus())
        print(box.focus())
        print("Average Profile:")
        show_profile( average_profile )
        print("Box:")
        show_profile( box )
      self.mask_focus.append( average_profile.focus() )

  def get_predictions_accounting_for_centering(self,cb_op_to_primitive=None,**kwargs):
    # interface requires this function to set current_orientation
    # in the actual setting used for Miller index calculation
    if (self.horizons_phil.known_setting is None or self.horizons_phil.known_setting == self.setting_id ) and \
        self.horizons_phil.integration.model in ["use_case_3_simulated_annealing",
                                                "use_case_3_simulated_annealing_7",
                                                "use_case_3_simulated_annealing_9"]:
      if cb_op_to_primitive==None:
        raise Sorry("Can't use model_3 simulated annealing for non-primitive cells, contact authors.")
      if self.horizons_phil.integration.model=="use_case_3_simulated_annealing":
        self.best_params = dict(zip(("half_mosaicity_deg","wave_HE_ang","wave_LE_ang",
         "reserve_orientation","rotation100_rad","rotation010_rad","rotation001_rad"),
         self.use_case_3_simulated_annealing(self.horizons_phil.integration.use_subpixel_translations))
        )
      elif self.horizons_phil.integration.model=="use_case_3_simulated_annealing_7":
        self.best_params = dict(zip(("half_mosaicity_deg","wave_HE_ang","wave_LE_ang",
         "reserve_orientation","rotation100_rad","rotation010_rad","rotation001_rad",
         "domain_size_ang"),
         self.use_case_3_simulated_annealing_7(self.horizons_phil.integration.use_subpixel_translations))
        )
      elif self.horizons_phil.integration.model=="use_case_3_simulated_annealing_9":
        self.best_params = dict(zip(("half_mosaicity_deg","wave_HE_ang","wave_LE_ang",
         "reserve_orientation","rotation100_rad","rotation010_rad","rotation001_rad",
         "domain_size_ang","ab_factor","c_factor"),
         self.use_case_3_simulated_annealing_9(self.horizons_phil.integration.use_subpixel_translations))
        )
      self.current_orientation = self.best_params["reserve_orientation"]
      self.current_cb_op_to_primitive = cb_op_to_primitive

      BPpredicted = self.bp3_wrapper.ucbp3.selected_predictions_labelit_format()
      BPhkllist = self.bp3_wrapper.ucbp3.selected_hkls()
      self.predicted,self.hkllist = BPpredicted, BPhkllist
      self.partialities = dict(indices=BPhkllist.deep_copy(),
                               data=self.bp3_wrapper.ucbp3.selected_partialities())
      #self.hi = self.bp3_wrapper.ucbp3.selected_hi_predictions()
      #self.lo = self.bp3_wrapper.ucbp3.selected_lo_predictions()
      #print list(self.partialities)
      #for x in range(len(self.hi)):
      #  print "%4d %4d %4d  %7.1f %7.1f %7.1f %7.1f PARTIAL %7.2f"%(
      #  self.hkllist[x][0], self.hkllist[x][1],self.hkllist[x][2],
      #  self.hi[x][0], self.hi[x][1],
      #  self.lo[x][0], self.lo[x][1], self.partialities[x])

      if self.inputai.active_areas != None:
        self.predicted,self.hkllist = self.inputai.active_areas(
                                      self.predicted,self.hkllist,self.pixel_size)
      return

    if self.horizons_phil.integration.model == "user_supplied":

     lower_limit_domain_size = math.pow(
       self.inputai.getOrientation().unit_cell().volume(),
       1./3.)*self.horizons_phil.integration.mosaic.domain_size_lower_limit # default 10-unit cell block size minimum reasonable domain
     actual_used_domain_size = kwargs.get("domain_size_ang",lower_limit_domain_size)
     if cb_op_to_primitive==None:

      from cxi_user import pre_get_predictions
      self.bp3_wrapper = pre_get_predictions(self.inputai, self.horizons_phil,
        raw_image = self.imagefiles.images[self.image_number],
        imageindex = self.frame_numbers[self.image_number],
        spotfinder = self.spotfinder,
        limiting_resolution = self.limiting_resolution,
        domain_size_ang = actual_used_domain_size)
      self.current_orientation = self.inputai.getOrientation()
      self.current_cb_op_to_primitive = cb_op_to_primitive

      BPpredicted = self.bp3_wrapper.ucbp3.selected_predictions_labelit_format()
      BPhkllist = self.bp3_wrapper.ucbp3.selected_hkls()

      self.predicted,self.hkllist = BPpredicted, BPhkllist
      if self.inputai.active_areas != None:
        self.predicted,self.hkllist = self.inputai.active_areas(
                                      self.predicted,self.hkllist,self.pixel_size)
      return

     else:
      self.block_counter+=1
      rot_mat = matrix.sqr(cb_op_to_primitive.c().r().as_double()).transpose()
      centered_orientation = self.inputai.getOrientation()
      self.current_orientation = centered_orientation
      self.current_cb_op_to_primitive = cb_op_to_primitive
      primitive_orientation = centered_orientation.change_basis(rot_mat)
      self.inputai.setOrientation(primitive_orientation)
      from cxi_user import pre_get_predictions
      if self.block_counter < 2:
        KLUDGE = self.horizons_phil.integration.mosaic.kludge1 # bugfix 1 of 2 for protocol 6, equation 2
        self.inputai.setMosaicity(KLUDGE*self.inputai.getMosaicity())
      self.bp3_wrapper = pre_get_predictions(self.inputai, self.horizons_phil,
        raw_image = self.imagefiles.images[self.image_number],
        imageindex = self.frame_numbers[self.image_number],
        spotfinder = self.spotfinder,
        limiting_resolution = self.limiting_resolution,
        domain_size_ang = actual_used_domain_size)

      BPpredicted = self.bp3_wrapper.ucbp3.selected_predictions_labelit_format()
      BPhkllist = self.bp3_wrapper.ucbp3.selected_hkls()

      self.actual = actual_used_domain_size
      self.predicted = BPpredicted
      primitive_hkllist = BPhkllist
      #not sure if matrix needs to be transposed first for outputting HKL's???:
      self.hkllist = cb_op_to_primitive.inverse().apply(primitive_hkllist)
      self.inputai.setOrientation(centered_orientation)
      if self.inputai.active_areas != None:
        self.predicted,self.hkllist = self.inputai.active_areas(
                                      self.predicted,self.hkllist,self.pixel_size)
      if self.block_counter < 2:
         down = self.inputai.getMosaicity()/KLUDGE
         print("Readjusting mosaicity back down to ",down)
         self.inputai.setMosaicity(down)
      return

    if cb_op_to_primitive==None:

      predicted = self.inputai.predict_all(
                  self.image_centers[self.image_number],self.limiting_resolution)
      self.predicted = predicted.vec3() #only good for integrating one frame...
      self.hkllist = predicted.hkl()
      self.current_orientation = self.inputai.getOrientation()
      from cctbx import sgtbx
      self.cb_op_to_primitive = sgtbx.change_of_basis_op()

    else:
      rot_mat = matrix.sqr(cb_op_to_primitive.c().r().as_double()).transpose()
      centered_orientation = self.inputai.getOrientation()
      self.current_orientation = centered_orientation
      self.current_cb_op_to_primitive = cb_op_to_primitive
      primitive_orientation = centered_orientation.change_basis(rot_mat)
      self.inputai.setOrientation(primitive_orientation)
      predicted = self.inputai.predict_all(
                  self.image_centers[self.image_number],self.limiting_resolution)
      self.predicted = predicted.vec3() #only good for integrating one frame...
      primitive_hkllist = predicted.hkl()
      #not sure if matrix needs to be transposed first for outputting HKL's???:
      self.hkllist = cb_op_to_primitive.inverse().apply(primitive_hkllist)
      self.inputai.setOrientation(centered_orientation)
    if self.inputai.active_areas != None:
      self.predicted,self.hkllist = self.inputai.active_areas(
                                    self.predicted,self.hkllist,self.pixel_size)

    if False: #development only; compare the two methods:
      from matplotlib import pyplot as plt
      plt.plot([i[0] for i in BPpredicted],[i[1] for i in BPpredicted],"r.")
      plt.plot([i[0] for i in predicted],[i[1] for i in predicted],"b.")
      plt.show()

  def get_observations_with_outlier_removal(self):
    print("Using spotfinder subset",self.horizons_phil.integration.spotfinder_subset)
    spots = self.spotfinder.images[self.frame_numbers[self.image_number]][self.horizons_phil.integration.spotfinder_subset]
    if getattr(slip_callbacks.slip_callback,"requires_refinement_spots",False):
      from spotfinder.array_family import flex
      self.spotfinder.images[self.frame_numbers[self.image_number]]["refinement_spots"]=flex.distl_spot()
    return spots

  def integration_concept(self,image_number=0,cb_op_to_primitive=None,verbose=False,**kwargs):
    self.image_number = image_number
    NEAR = 10
    pxlsz = self.pixel_size
    self.get_predictions_accounting_for_centering(cb_op_to_primitive,**kwargs)
    FWMOSAICITY = self.inputai.getMosaicity()
    DOMAIN_SZ_ANG = kwargs.get("domain_size_ang",  self.__dict__.get("actual",0)  )
    refineflag = {True:0,False:1}[kwargs.get("domain_size_ang",0)==0]
    self.inputpd["symmetry"].show_summary(prefix="EXCURSION%1d REPORT FWMOS= %6.4f DOMAIN= %6.1f "%(refineflag,FWMOSAICITY,DOMAIN_SZ_ANG))
    from annlib_ext import AnnAdaptor
    self.cell = self.inputai.getOrientation().unit_cell()
    query = flex.double()
    for pred in self.predicted: # predicted spot coord in pixels
      query.append(pred[0]/pxlsz)
      query.append(pred[1]/pxlsz)
    self.reserve_hkllist_for_signal_search = self.hkllist

    reference = flex.double()
    spots = self.get_observations_with_outlier_removal()

    assert len(spots)>NEAR# Can't do spot/pred matching with too few spots
    for spot in spots:
      reference.append(spot.ctr_mass_x())
      reference.append(spot.ctr_mass_y())

    IS_adapt = AnnAdaptor(data=reference,dim=2,k=NEAR)
    IS_adapt.query(query)
    print("Calculate correction vectors for %d observations & %d predictions"%(len(spots),len(self.predicted)))
    indexed_pairs_provisional = []
    correction_vectors_provisional = []
    c_v_p_flex = flex.vec3_double()
    idx_cutoff = float(min(self.mask_focus[image_number]))
    if verbose:
      print("idx_cutoff distance in pixels",idx_cutoff)
    if not self.horizons_phil.integration.enable_one_to_one_safeguard:
     # legacy code, no safeguard against many-to-one predicted-to-observation mapping
     for i in range(len(self.predicted)): # loop over predicteds
      #for n in range(NEAR): # loop over near spotfinder spots
      for n in range(1): # only consider the nearest spotfinder spot
        Match = dict(spot=IS_adapt.nn[i*NEAR+n],pred=i)
        if n==0 and math.sqrt(IS_adapt.distances[i*NEAR+n]) < idx_cutoff:
          indexed_pairs_provisional.append(Match)

          vector = matrix.col(
            [spots[Match["spot"]].ctr_mass_x() - self.predicted[Match["pred"]][0]/pxlsz,
             spots[Match["spot"]].ctr_mass_y() - self.predicted[Match["pred"]][1]/pxlsz])
          correction_vectors_provisional.append(vector)
          c_v_p_flex.append((vector[0],vector[1],0.))
    else:
      one_to_one = {}
      for i in range(len(self.predicted)): # loop over predicteds
        annresultidx = i*NEAR
        obsidx = IS_adapt.nn[annresultidx]
        this_distancesq = IS_adapt.distances[annresultidx]
        if obsidx not in one_to_one or \
           this_distancesq < one_to_one[obsidx]["distancesq"]:
           if math.sqrt(this_distancesq) < idx_cutoff:
             one_to_one[obsidx] = dict(spot=obsidx,pred=i,distancesq=this_distancesq)
      for key,value in one_to_one.items():
        indexed_pairs_provisional.append(value)
        vector = matrix.col(
            [spots[value["spot"]].ctr_mass_x() - self.predicted[value["pred"]][0]/pxlsz,
             spots[value["spot"]].ctr_mass_y() - self.predicted[value["pred"]][1]/pxlsz])
        correction_vectors_provisional.append(vector)
        c_v_p_flex.append((vector[0],vector[1],0.))

    print("... %d provisional matches"%len(correction_vectors_provisional), end=' ')
    print("r.m.s.d. in pixels: %5.2f"%(math.sqrt(flex.mean(c_v_p_flex.dot(c_v_p_flex)))))

    if self.horizons_phil.integration.enable_residual_scatter:
      from matplotlib import pyplot as plt
      fig = plt.figure()
      for cv in correction_vectors_provisional:
        plt.plot([cv[1]],[-cv[0]],"b.")
      plt.title(" %d matches, r.m.s.d. %5.2f pixels"%(len(correction_vectors_provisional),math.sqrt(flex.mean(c_v_p_flex.dot(c_v_p_flex)))))
      plt.axes().set_aspect("equal")
      self.show_figure(plt,fig,"res")
      plt.close()

    if self.horizons_phil.integration.enable_residual_map:
      from matplotlib import pyplot as plt
      fig = plt.figure()
      for match,cv in zip(indexed_pairs_provisional,correction_vectors_provisional):
        plt.plot([spots[match["spot"]].ctr_mass_y()],[-spots[match["spot"]].ctr_mass_x()],"r.")
        plt.plot([self.predicted[match["pred"]][1]/pxlsz],[-self.predicted[match["pred"]][0]/pxlsz],"g.")
        plt.plot([spots[match["spot"]].ctr_mass_y(), spots[match["spot"]].ctr_mass_y() + 10.*cv[1]],
                 [-spots[match["spot"]].ctr_mass_x(), -spots[match["spot"]].ctr_mass_x() - 10.*cv[0]],'b-')
      plt.xlim([0,float(self.inputpd["size2"])])
      plt.ylim([-float(self.inputpd["size1"]),0])
      plt.title(" %d matches, r.m.s.d. %5.2f pixels"%(len(correction_vectors_provisional),math.sqrt(flex.mean(c_v_p_flex.dot(c_v_p_flex)))))
      plt.axes().set_aspect("equal")
      self.show_figure(plt,fig,"map")
      plt.close()
    # insert code here to remove correction length outliers...
    # they are causing terrible
    # problems for finding legitimate correction vectors (print out the list)
    # also remove outliers for the purpose of reporting RMS
    outlier_rejection = True
    cache_refinement_spots = getattr(slip_callbacks.slip_callback,"requires_refinement_spots",False)
    if outlier_rejection:
      correction_lengths = flex.double([v.length() for v in correction_vectors_provisional])
      clorder = flex.sort_permutation(correction_lengths)
      sorted_cl = correction_lengths.select(clorder)

      ACCEPTABLE_LIMIT = 2
      limit = int(0.33 * len(sorted_cl)) # best 1/3 of data are assumed to be correctly modeled.
      if (limit <= ACCEPTABLE_LIMIT):
        raise Sorry("Not enough indexed spots to reject outliers; have %d need >%d" % (limit, ACCEPTABLE_LIMIT))

      y_data = flex.double(len(sorted_cl))
      for i in range(len(y_data)):
        y_data[i] = float(i)/float(len(y_data))

      # ideas are explained in Sauter & Poon (2010) J Appl Cryst 43, 611-616.
      from rstbx.outlier_spots.fit_distribution import fit_cdf,rayleigh
      fitted_rayleigh = fit_cdf(x_data = sorted_cl[0:limit],
                                y_data = y_data[0:limit],
                                distribution=rayleigh)

      inv_cdf = [fitted_rayleigh.distribution.inv_cdf(cdf) for cdf in y_data]

      #print "SORTED LIST OF ",len(sorted_cl), "with sigma",fitted_rayleigh.distribution.sigma
      indexed_pairs = []
      correction_vectors = []
      self.correction_vectors = []
      for icand in range(len(sorted_cl)):
        # somewhat arbitrary sigma = 1.0 cutoff for outliers
        if (sorted_cl[icand]-inv_cdf[icand])/fitted_rayleigh.distribution.sigma > 1.0:
          break
        indexed_pairs.append(indexed_pairs_provisional[clorder[icand]])
        correction_vectors.append(correction_vectors_provisional[clorder[icand]])
        if cache_refinement_spots:
          self.spotfinder.images[self.frame_numbers[self.image_number]]["refinement_spots"].append(
          spots[indexed_pairs[-1]["spot"]])
        if kwargs.get("verbose_cv")==True:
            print("CV OBSCENTER %7.2f %7.2f REFINEDCENTER %7.2f %7.2f"%(
              float(self.inputpd["size1"])/2.,float(self.inputpd["size2"])/2.,
              self.inputai.xbeam()/pxlsz, self.inputai.ybeam()/pxlsz), end=' ')
            print("OBSSPOT %7.2f %7.2f PREDSPOT %7.2f %7.2f"%(
              spots[indexed_pairs[-1]["spot"]].ctr_mass_x(),
              spots[indexed_pairs[-1]["spot"]].ctr_mass_y(),
              self.predicted[indexed_pairs[-1]["pred"]][0]/pxlsz,
              self.predicted[indexed_pairs[-1]["pred"]][1]/pxlsz), end=' ')
            the_hkl = self.hkllist[indexed_pairs[-1]["pred"]]
            print("HKL %4d %4d %4d"%the_hkl,"%2d"%self.setting_id, end=' ')
            radial, azimuthal = spots[indexed_pairs[-1]["spot"]].get_radial_and_azimuthal_size(
              self.inputai.xbeam()/pxlsz, self.inputai.ybeam()/pxlsz)
            print("RADIALpx %5.3f AZIMUTpx %5.3f"%(radial,azimuthal))

        # Store a list of correction vectors in self.
        radial, azimuthal = spots[indexed_pairs[-1]['spot']].get_radial_and_azimuthal_size(
          self.inputai.xbeam()/pxlsz, self.inputai.ybeam()/pxlsz)
        self.correction_vectors.append(
          dict(obscenter=(float(self.inputpd['size1']) / 2,
                          float(self.inputpd['size2']) / 2),
               refinedcenter=(self.inputai.xbeam() / pxlsz,
                              self.inputai.ybeam() / pxlsz),
               obsspot=(spots[indexed_pairs[-1]['spot']].ctr_mass_x(),
                        spots[indexed_pairs[-1]['spot']].ctr_mass_y()),
               predspot=(self.predicted[indexed_pairs[-1]['pred']][0] / pxlsz,
                         self.predicted[indexed_pairs[-1]['pred']][1] / pxlsz),
               hkl=(self.hkllist[indexed_pairs[-1]['pred']][0],
                    self.hkllist[indexed_pairs[-1]['pred']][1],
                    self.hkllist[indexed_pairs[-1]['pred']][2]),
               setting_id=self.setting_id,
               radial=radial,
               azimuthal=azimuthal))

      print("After outlier rejection %d indexed spotfinder spots remain."%len(indexed_pairs))
      if False:
        rayleigh_cdf = [
          fitted_rayleigh.distribution.cdf(x=sorted_cl[c]) for c in range(len(sorted_cl))]
        from matplotlib import pyplot as plt
        plt.plot(sorted_cl,y_data,"r+")
        #plt.plot(sorted_cl,rayleigh_cdf,"g.")
        plt.plot(inv_cdf,y_data,"b.")
        plt.show()
    else:
      indexed_pairs = indexed_pairs_provisional
      correction_vectors = correction_vectors_provisional
    ########### finished with outlier rejection

    self.inputpd["symmetry"].show_summary(prefix="SETTING ")

    is_triclinic = (self.setting_id==1)
    if is_triclinic:
      self.triclinic_pairs = [ dict(pred=self.hkllist[a["pred"]],spot=a["spot"])
        for a in indexed_pairs ]

    if self.horizons_phil.integration.model == "user_supplied":
      if kwargs.get("user-reentrant",None)==None:
        from cxi_user import post_outlier_rejection
        self.indexed_pairs = indexed_pairs
        self.spots = spots
        post_outlier_rejection(self,image_number,cb_op_to_primitive,self.horizons_phil,kwargs)
        return

    ########### finished with user-supplied code

    if self.horizons_phil.integration.spot_shape_verbose:
        from rstbx.new_horizons.spot_shape import spot_shape_verbose
        spot_shape_verbose(rawdata = self.imagefiles.images[self.image_number].linearintdata,
           beam_center_pix = matrix.col((self.inputai.xbeam()/pxlsz, self.inputai.ybeam()/pxlsz)),
           indexed_pairs = indexed_pairs,
           spotfinder_observations = spots,
           distance_mm = self.inputai.distance(),
           mm_per_pixel = pxlsz,
           hkllist = self.hkllist,
           unit_cell = self.cell,
           wavelength_ang = self.inputai.wavelength
        )

    #Other checks to be implemented (future):
    # spot is within active area of detector on a circular detector such as the Mar IP
    # integration masks do not overlap; or deconvolute

    correction_lengths=flex.double([v.length() for v in correction_vectors])
    if verbose:
      print("average correction %5.2f over %d vectors"%(flex.mean(correction_lengths),
      len(correction_lengths)), end=' ')
      print("or %5.2f mm."%(pxlsz*flex.mean(correction_lengths)))
    self.r_residual = pxlsz*flex.mean(correction_lengths)

    #assert len(indexed_pairs)>NEAR # must have enough indexed spots
    if (len(indexed_pairs) <= NEAR):
      raise Sorry("Not enough indexed spots, only found %d, need %d" % (len(indexed_pairs), NEAR))

    reference = flex.double()
    for item in indexed_pairs:
      reference.append(spots[item["spot"]].ctr_mass_x())
      reference.append(spots[item["spot"]].ctr_mass_y())

    PS_adapt = AnnAdaptor(data=reference,dim=2,k=NEAR)
    PS_adapt.query(query)

    self.BSmasks = []
    #self.null_correction_mapping( predicted=self.predicted,
    #                                    correction_vectors = correction_vectors,
    #                                    IS_adapt = IS_adapt,
    #                                    spots = spots)
    self.positional_correction_mapping( predicted=self.predicted,
                                        correction_vectors = correction_vectors,
                                        PS_adapt = PS_adapt,
                                        IS_adapt = IS_adapt,
                                        spots = spots)

    # which spots are close enough to interfere with background?
    MAXOVER=6
    OS_adapt = AnnAdaptor(data=query,dim=2,k=MAXOVER) #six near nbrs
    OS_adapt.query(query)
    if self.mask_focus[image_number] is None:
      raise Sorry("No observed/predicted spot agreement; no Spotfinder masks; skip integration")
    nbr_cutoff = 2.0* max(self.mask_focus[image_number])
    FRAME = int(nbr_cutoff/2)
    #print "The overlap cutoff is %d pixels"%nbr_cutoff
    nbr_cutoff_sq = nbr_cutoff * nbr_cutoff

    #print "Optimized C++ section...",
    self.set_frame(FRAME)
    self.set_background_factor(kwargs["background_factor"])
    self.set_nbr_cutoff_sq(nbr_cutoff_sq)
    self.set_guard_width_sq(self.horizons_phil.integration.guard_width_sq)
    self.set_detector_gain(self.horizons_phil.integration.detector_gain)
    flex_sorted = flex.int()
    for item in self.sorted:
      flex_sorted.append(item[0]);flex_sorted.append(item[1]);

    if self.horizons_phil.integration.mask_pixel_value is not None:
      self.set_mask_pixel_val(self.horizons_phil.integration.mask_pixel_value)

    image_obj = self.imagefiles.imageindex(self.frame_numbers[self.image_number])
    image_obj.read()
    rawdata = image_obj.linearintdata # assume image #1

    if self.inputai.active_areas != None:
      self.detector_xy_draft = self.safe_background( rawdata=rawdata,
                          predicted=self.predicted,
                          OS_adapt=OS_adapt,
                          sorted=flex_sorted,
                          tiles=self.inputai.active_areas.IT,
                          tile_id=self.inputai.active_areas.tile_id);
    else:
      self.detector_xy_draft = self.safe_background( rawdata=rawdata,
                          predicted=self.predicted,
                          OS_adapt=OS_adapt,
                          sorted=flex_sorted);
    for i in range(len(self.predicted)): # loop over predicteds
      B_S_mask = {}
      keys = self.get_bsmask(i)
      for k in range(0,len(keys),2):
        B_S_mask[(keys[k],keys[k+1])]=True
      self.BSmasks.append(B_S_mask)
    #print "Done"
    return

  def show_rejected_spots(self):
    miller = self.get_rejected_miller()
    messag = self.get_rejected_reason()
    for i,j in zip(self.get_rejected_miller(),self.get_rejected_reason()):
      print(i,j)

  def integration_proper(self):
    image_obj = self.imagefiles.imageindex(self.frame_numbers[self.image_number])
    #image_obj.read() #assume image already read
    rawdata = image_obj.linearintdata # assume image #1

    self.integration_proper_fast(rawdata,self.predicted,self.hkllist,self.detector_xy_draft)
    self.integrated_data = self.get_integrated_data()
    self.integrated_sigma= self.get_integrated_sigma()
    self.integrated_miller=self.get_integrated_miller()
    self.detector_xy = self.get_detector_xy()
    self.max_signal = self.get_max_signal()

    for correction_type in self.horizons_phil.integration.absorption_correction:
      if correction_type.apply:
        if correction_type.algorithm=="fuller_kapton":
          print("Absorption correction with %d reflections to correct"%(len(self.detector_xy)))
          from cxi_xdr_xes import absorption
          C = absorption.correction()
          if correction_type.fuller_kapton.smart_sigmas:
            self.fuller_kapton_absorption_correction, self.fuller_kapton_absorption_sigmas = C(
              panel_size_px = (self.inputpd['size1'],self.inputpd['size2']),
              pixel_size_mm = self.pixel_size,
              detector_dist_mm = self.inputai.distance(),
              wavelength_ang = self.inputai.wavelength,
              BSmasks = self.BSmasks,
              get_ISmask_function = self.get_ISmask,
              params = correction_type.fuller_kapton,
              i_no_skip = self.get_integrated_flag(),
              calc_sigmas=True
            )
            # apply corrections and propagate error
            # term1 = (sig(C)/C)^2
            # term2 = (sig(Imeas)/Imeas)^2
            # I' = C*I
            # sig^2(I') = (I')^2*(term1 + term2)
            # sig(I') = sqrt(sig^2(I'))
            term1 = flex.pow(self.fuller_kapton_absorption_sigmas/self.fuller_kapton_absorption_correction, 2)
            term2 = flex.pow(self.integrated_sigma/self.integrated_data, 2)
            self.integrated_data *= self.fuller_kapton_absorption_correction
            integrated_sigma_squared = flex.pow(self.integrated_data, 2) * (term1 + term2)
            self.integrated_sigma = flex.sqrt(integrated_sigma_squared)
            # order is purposeful: the two lines above require that self.integrated_data has already been corrected!
          else:
            self.fuller_kapton_absorption_correction = C(
              panel_size_px = (self.inputpd['size1'],self.inputpd['size2']),
              pixel_size_mm = self.pixel_size,
              detector_dist_mm = self.inputai.distance(),
              wavelength_ang = self.inputai.wavelength,
              BSmasks = self.BSmasks,
              get_ISmask_function = self.get_ISmask,
              params = correction_type.fuller_kapton,
              i_no_skip = self.get_integrated_flag()
            )
            # apply these corrections now
            self.integrated_data *= self.fuller_kapton_absorption_correction
            self.integrated_sigma *= self.fuller_kapton_absorption_correction

    #self.show_rejected_spots()
    return # function has been recoded in C++

  def get_obs(self,space_group_symbol):
    from cctbx.crystal import symmetry
    from cctbx import miller

    xsym = symmetry(unit_cell = self.cell,
                    space_group_symbol=space_group_symbol)

    miller_set = miller.set(crystal_symmetry=xsym,
      indices=self.integrated_miller,anomalous_flag=True)
    miller_array = miller.array(miller_set,self.integrated_data,
      self.integrated_sigma)
    miller_array.set_observation_type_xray_intensity()
    miller_array.set_info("Raw partials from rstbx, not in ASU, no polarization correction")
    return miller_array

  def show_figure(self,plt,fig,tag):
    if self.horizons_phil.integration.graphics_backend=="pdf":

      F=self.imagefiles.frames()
      G=self.imagefiles.imagepath(F[0])
      import os
      fname = os.path.splitext(os.path.basename(G))[0]
      sgi = str(self.inputpd["symmetry"].space_group_info())
      sgi = sgi.replace(" ","")
      sgi = sgi.replace("/","")
      outfile = os.path.join(self.horizons_phil.integration.pdf_output_dir,
        "%s_%02d_%s_%s.pdf"%(fname, self.setting_id, sgi, tag)
      )

      from matplotlib.backends.backend_pdf import PdfPages
      with PdfPages(outfile) as pdf:
        pdf.savefig(fig)
        pdf.savefig()
    else:
        plt.show()


 *******************************************************************************


 *******************************************************************************
rstbx/apps/stills/stills_integration.py
"""Specialization code for 2011 JCSG pilot experiment; not general use"""
from __future__ import absolute_import, division, print_function
from six.moves import range
from six.moves import cPickle as pickle

import math
from labelit.preferences import labelit_commands,labelit_phil
from labelit.command_line.default_param import establish_dict_for_refinement
from labelit.dptbx.autoindex import index_and_refine
from labelit.command_line.stats_index import best_character_to_IndexPrinter
from labelit.command_line.stats_index import AutoIndexOrganizer

class Empty:pass

class api:
  def __init__(self,*args):
    #application programmer interface for screen, using identical inputs
    # to the command line interface
    args = list(args)
    labelit_phil.merge_command_line(args)
    E = Empty()
    E.argv=['Empty']
    for x in range(len(args)):
      E.argv.append(args[x])
    E.horizons_phil=labelit_commands

    self.establish_dict_for_refinement = establish_dict_for_refinement
    self.index_and_refine = index_and_refine
    self.best_character_to_IndexPrinter = best_character_to_IndexPrinter

    self.Org = AutoIndexOrganizer(
      verbose=labelit_commands.distl.bins.verbose,argument_module=E)
    self.Org.setIndexingDelegate(self.index_and_integrate)
      # legacy:algorithm control could be excercised here
    self.horizons_phil = labelit_commands

  def __call__(self):
    return self.Org.process()

  def index_and_integrate(self,frames,files,spotfinder_results):
    self.frames = frames
    self.files = files
    self.spotfinder_results = spotfinder_results
    pd = self.establish_dict_for_refinement(frames,spotfinder_results)
    #------------------------------------------------------------
    ai,P = self.index_and_refine(pd,files,spotfinder_results,0)
    self.indexing_ai = ai
    #------------------------------------------------------------
    if labelit_commands.compatibility_allow==False:
      M = self.best_character_to_IndexPrinter(ai,P,pd,horizons_phil=self.horizons_phil)
    else:
      from labelit.diffraction.compatibility import \
        best_compatibility_to_IndexPrinter
      M = best_compatibility_to_IndexPrinter(ai,P,pd,files,spotfinder_results,horizons_phil=self.horizons_phil)
    #------------------------------------------------------------
    if "writer" in labelit_commands.__dict__:
      labelit_commands.writer.make_image_plots_detail(
        ai=ai,pd=pd,inframes=files,spotfinder_results=spotfinder_results)
    if not labelit_commands.index_only:
      IC = IntegrateCharacters(M,pd)
      IC.write_mosflm_matrices()
      IC.find_best()
      IC.show()
    return pd

  def create_case_only(self,frames,file,spotfinder_results):
    self.pd = self.establish_dict_for_refinement(frames)

  def analyze_one(self,solution):
    inputpd = self.Org.process()

    settings = pickle.load(open("LABELIT_possible","rb"))
    setting = [setting for setting in settings if setting["counter"]==solution][0]

    from labelit.preferences import labelit_commands as param

    pixel_size = float(inputpd['pixel_size'])
    self.pixel_size = pixel_size

    from labelit.dptbx import AutoIndexEngine, Parameters
    ai = AutoIndexEngine(inputpd['endstation'])

    P = Parameters(xbeam=setting["refined x beam"],ybeam=setting["refined y beam"],
             distance=setting["refined distance"],twotheta=float(inputpd["twotheta"]))
    ai.setBase(P)
    ai.setWavelength(float(inputpd['wavelength']))
    ai.setMaxcell(float(inputpd['ref_maxcel']))
    print("Deltaphi is",float(inputpd['deltaphi']))
    ai.setDeltaphi(float(inputpd['deltaphi'])*math.pi/180.)
    ai.setMosaicity(setting["mosaicity"])
    ai.setOrientation(setting["orient"])
    #why aren't hexagonal constraints applied here???
    print(inputpd["osc_start"])

    image_centers = [(math.pi/180.)*float(x) for x in inputpd["osc_start"].values()]

    limiting_resolution = param.distl_highres_limit
    print("Limiting resolution",limiting_resolution)

    #predict the spots
    spots = ai.predict_all(image_centers[0],limiting_resolution)
    pre2m = spots.vec3()
    self.pre2m = pre2m

    hkllist = spots.hkl()
    cell = ai.getOrientation().unit_cell()
    print(cell)
    for hkl in hkllist:
      #print "%25s %5.2f"%(str(hkl),cell.d(hkl))
      assert cell.d(hkl)>=limiting_resolution
    print("Number of hkls:",(hkllist).size(), end=' ')
    print("all inside the %4.2f Angstrom limiting sphere."%limiting_resolution)
    print("The unit cell is",cell)
    self.solution_setting_ai = ai
    self.solution_pd = inputpd
    self.image_centers = image_centers
    self.one_setting = setting
    return [ai.getOrientation().unit_cell(),hkllist]

  def parameters(self):
    image_centers = [(math.pi/180.)*float(x) for x in self.solution_pd["osc_start"].values()]
    P = dict( image_center_radians = image_centers,
              wavelength = float(self.solution_pd['wavelength']),
              deltaphi = float(self.solution_pd['deltaphi']),
              mosaicity_degrees = self.solution_setting_ai.getMosaicity(),
              orientation = self.solution_setting_ai.getOrientation(),
              )
    return P

from libtbx.development.timers import Timer
from rstbx.dials_core.integration_core import integration_core
from rstbx.apps.stills.simple_integration import IntegrationMetaProcedure as base_class
class IntegrationMetaProcedure(base_class):
  def __init__(self,inputs,backcompat_horizons_phil): # inputs is an instance of class api
    self.horizons_phil = backcompat_horizons_phil
    integration_core.__init__(self)
    self.inputai = inputs.solution_setting_ai #C++ autoindex engine
    self.indexing_ai = inputs.indexing_ai

    #Note...here we may be working with a non-primitive cell, so
    # must work with systematic absences...not implemented yet.
    if self.indexing_ai.getData().size() < 40: return # initial protection

    self.inputpd = inputs.solution_pd #parameter dictionary
    self.inputpd["symmetry"] = inputs.one_setting["best_subsym"]
    self.inputframes = inputs.frames
    self.imagefiles = inputs.files
    self.spotfinder = inputs.spotfinder_results
    self.frame_numbers = self.spotfinder.pd['osc_start'].keys()
    self.frame_numbers.sort()

    self.image_centers = inputs.image_centers
    print("IMAGE CENTERS",self.image_centers)

    # initial resolution from DISTL
    resolution_est = float(self.inputpd['resolution_inspection'])
    print("initial resolution from DISTL",resolution_est)

    # resolution limit of the strong spots used for indexing
    resolution_str = self.indexing_ai.high().reciprocal_spacing
    resolution = max(resolution_est,resolution_str)
    print("resolution limit of the strong spots used for indexing",resolution)
    self.limiting_resolution = resolution

    #print "resolution: %.2f %.2f"%(resolution_est,resolution_str)
    self.pixel_size = inputs.pixel_size
    self.set_pixel_size(inputs.pixel_size)
    self.set_detector_size(int(self.inputpd["size1"]),int(self.inputpd["size2"]))

    self.pre2m = inputs.pre2m
    self.set_up_mask_focus()
    self.initialize_increments()
    T = Timer("concept")
    from cctbx import sgtbx
    self.integration_concept(image_number = 0,
        cb_op_to_primitive = sgtbx.change_of_basis_op(), #identity; supports only primitive lattices
        verbose_cv = self.horizons_phil.indexing.verbose_cv,
        background_factor = self.horizons_phil.integration.background_factor)
    T = Timer("proper")
    self.integration_proper()


 *******************************************************************************


 *******************************************************************************
rstbx/apps/stills/util.py
from __future__ import absolute_import, division, print_function
from dials.array_family import flex
import math
from six.moves import zip

def residual_map_special_deltapsi_add_on( reflections,experiments,matches,hkllist, predicted,plot,eta_deg,deff ):

        detector = experiments[0].detector
        crystal = experiments[0].crystal
        unit_cell = crystal.get_unit_cell()
        pxlsz = detector[0].get_pixel_size()
        model_millers = reflections["miller_index"]
        dpsi = flex.double()
        for match in matches:

          obs_miller = hkllist[match["pred"]]
          model_index= model_millers.first_index(obs_miller)

          raw_delta_psi = reflections["delpsical.rad"][model_index]
          deltapsi_envelope = (unit_cell.d(obs_miller)/deff) + math.pi*eta_deg/180.
          normalized_delta_psi = raw_delta_psi/deltapsi_envelope

          dpsi.append( normalized_delta_psi )

        from matplotlib.colors import Normalize
        dnorm = Normalize()
        dnorm.autoscale(dpsi.as_numpy_array())

        CMAP = plot.get_cmap("bwr")
        for match,dcolor in zip(matches,dpsi):

          #print dcolor, dnorm(dcolor),  CMAP(dnorm(dcolor))
          #blue represents negative delta psi:  outside Ewald sphere; red, positive, inside Ewald sphere
          plot.plot([predicted[match["pred"]][1]/pxlsz[1]],[-predicted[match["pred"]][0]/pxlsz[0]],color=CMAP(dnorm(dcolor)),
          marker=".", markersize=5)


 *******************************************************************************


 *******************************************************************************
rstbx/array_family/__init__.py


 *******************************************************************************


 *******************************************************************************
rstbx/array_family/flex.py
from __future__ import absolute_import, division, print_function
import scitbx.array_family.flex
import cctbx.array_family.flex

import boost_adaptbx.boost.python as bp
bp.import_ext("cctbx_array_family_flex_ext")
from scitbx_array_family_flex_ext import *
from cctbx_array_family_flex_ext import *
from rstbx_array_family_flex_ext import *
import rstbx_array_family_flex_ext as ext # implicit import

scitbx.array_family.flex.export_to("rstbx.array_family.flex")


 *******************************************************************************


 *******************************************************************************
rstbx/bandpass/__init__.py
from __future__ import absolute_import, division, print_function
import boost_adaptbx.boost.python as bp
ext = bp.import_ext("rstbx_bandpass_ext")
from rstbx_bandpass_ext import *


 *******************************************************************************


 *******************************************************************************
rstbx/bandpass/simulated_annealing.py
from __future__ import absolute_import, division, print_function
import math,copy
from scitbx.array_family import flex
class SALight:
  """Lightweight implementation of a simulated annealing protocol"""

  def random_increment(self):
    random = 2.0*flex.random_double(len(self.x)) - 1.0 # values from -1 to 1
    sum_sq = flex.sum(random*random)
    normalized = random / math.sqrt(sum_sq)
    return normalized * self.L

  def cycles(self,k=600):
    self.ktotal = k
    self.counter = copy.copy(self.ktotal)
    while (self.counter > 0):
      self.counter -=1
      decreasing_increment = (self.counter/self.ktotal)*self.random_increment()
      #print self.format%tuple(decreasing_increment)
      self.x += decreasing_increment
      print(self.format%tuple(self.x))

if __name__=="__main__":
  SA = SALight()
  # Half mosaicity in degrees
  # Mid-wavelength adjustment factor
  # Bandpass fractional full width
  # adjustment angle in degrees
  # adjustment angle in degrees
  # adjustment angle in degrees

  # starting values; likely expected values
  SA.x = flex.double([0.1,1.00,0.006,0.0,0.0,0.0])
  SA.initial = SA.x.deep_copy()

  # reasonable length scale (expected interval, half width)
  SA.L = flex.double([0.04,0.001,0.002,0.1,0.1,0.1])

  SA.format = "Mosaicity %6.3f Wave mean %7.4f bandpass %7.4f Angles %8.5f %8.5f %8.5f"
  #print list(SA.random_increment())
  print(SA.format%tuple(SA.initial))
  SA.cycles()
  print()
  print(SA.format%tuple(SA.initial))


 *******************************************************************************


 *******************************************************************************
rstbx/bpcx/__init__.py
from __future__ import absolute_import, division, print_function
# usage:
#
# from rstbx.bpcx import sensor

from cctbx.array_family import flex # import dependency
import boost_adaptbx.boost.python as bp
ext = bp.import_ext("rstbx_bpcx_detector_model_ext")
from rstbx_bpcx_detector_model_ext import *


 *******************************************************************************


 *******************************************************************************
rstbx/bpcx/compare_mosflm_xds.py
from __future__ import absolute_import, division, print_function
# Compare intensities and positions of measurements from XDS INTEGRATE (which
# are not necessarily correctly LP corrected) and from Mosflm via sortmtz and
# scala to sum partials but not merge or scale e.g.
#
# #!/bin/sh
#
# sortmtz hklin thau_2_001.mtz hklout sorted.mtz << eof
# H K L M/ISYM BATCH
# eof
#
# scala hklin sorted.mtz hklout summed.mtz << eof
# run 1 batch 1 to 1800
# scales constant
# cycles 0
# sdcorrection noadjust norefine both 1.0 0.0 0.0
# output unmerged
# eof
#
# N.B. all comparisons done with data in memory, so careful with the sizes of
# example data sets to use. Also assumes X, Y definitions between Mosflm and
# XDS are inverted, and computes deviations in terms of pixels and images.
# This requires reading of the batch headers. Try also comparing with pixels
# and degrees (perhaps small differences in postrefinement are affecting
# things?)

import sys
import math
from iotbx import mtz
from cctbx.array_family import flex
from annlib_ext import AnnAdaptor as ann_adaptor
from cctbx.sgtbx import space_group, space_group_symbols
from cctbx.miller import map_to_asu
from six.moves import range
from six.moves import zip

def meansd(values):
    assert(len(values) > 3)

    mean = sum(values) / len(values)
    var = sum([(v - mean) * (v - mean) for v in values]) / (len(values) - 1)

    return mean, math.sqrt(var)

def cc(a, b):

    assert(len(a) == len(b))

    ma, sa = meansd(a)
    mb, sb = meansd(b)

    r = (1 / (len(a) - 1)) * sum([((a[j] - ma) / sa) * ((b[j] - mb) / sb)
                                  for j in range(len(a))])

    return r

def get_phi_range(mtz_object):
    bs = mtz_object.batches()

    rs = [(b.phiend() - b.phistt()) for b in bs]

    return meansd(rs)[0]

def get_hkl_xyz_isigi(mtz_file):
    m = mtz.object(mtz_file)

    r = get_phi_range(m)

    sg = m.space_group()

    xdet_col = m.get_column('XDET')
    ydet_col = m.get_column('YDET')
    rot_col = m.get_column('ROT')
    i_col = m.get_column('I')
    sigi_col = m.get_column('SIGI')

    mi_s = m.extract_miller_indices()
    map_to_asu(sg.type(), False, mi_s)

    xdet_s = xdet_col.extract_values(not_a_number_substitute = 0.0)
    ydet_s = ydet_col.extract_values(not_a_number_substitute = 0.0)
    rot_s = rot_col.extract_values(not_a_number_substitute = 0.0)
    i_s = i_col.extract_values(not_a_number_substitute = 0.0)
    sigi_s = sigi_col.extract_values(not_a_number_substitute = 0.0)

    hkl_xyz_isigi = []

    # N.B. swapping X, Y here

    for j in range(mi_s.size()):
        hkl_xyz_isigi.append(((mi_s[j][0], mi_s[j][1], mi_s[j][2]),
                              (ydet_s[j], xdet_s[j], rot_s[j] / r),
                              (i_s[j], sigi_s[j])))

    return hkl_xyz_isigi

def read_xds_integrate(xds_integrate_file):

    # N.B. in here need to reduce indices to asymmetric unit

    sg_num = 0
    r = 0.0

    for record in open(xds_integrate_file):
        if not '!' in record[:1]:
            break
        if 'SPACE_GROUP_NUMBER' in record:
            sg_num = int(record.split()[-1])
        if 'OSCILLATION_RANGE' in record:
            r = float(record.split()[-1])

    if not sg_num:
        raise RuntimeError('spacegroup missing')

    if not r:
        raise RuntimeError('rotation missing')

    sg = space_group(space_group_symbols(sg_num).hall())

    observations = []

    hkls = flex.miller_index()
    xyzs = []
    isigmas = []

    for record in open(xds_integrate_file):
        if '!' in record[:1]:
            continue
        values = record.split()
        hkls.append( [int(h) for h in values[:3]] )
        xyzs.append((float(values[5]), float(values[6]), float(values[7])))
        isigmas.append([float(x) for x in values[3:5]])

    map_to_asu(sg.type(), False, hkls)

    for hkl, xyz, isigma in zip(hkls, xyzs, isigmas):
        observations.append((hkl, xyz, isigma))

    return observations

def main(mtz_file, xds_integrate_file):
    mos_hkl_xyz_isigi = get_hkl_xyz_isigi(mtz_file)

    print('Read %d observations from %s' % (len(mos_hkl_xyz_isigi), mtz_file))

    xds_hkl_xyz_isigi = read_xds_integrate(xds_integrate_file)

    print('Read %d observations from %s' % \
          (len(xds_hkl_xyz_isigi), xds_integrate_file))

    # treat XDS as reference, mosflm as query (arbitrary)

    reference = flex.double()
    query = flex.double()

    for hkl, xyz, isigi in xds_hkl_xyz_isigi:
        reference.append(xyz[0])
        reference.append(xyz[1])
        reference.append(xyz[2])

    for hkl, xyz, isigi in mos_hkl_xyz_isigi:
        query.append(xyz[0])
        query.append(xyz[1])
        query.append(xyz[2])

    ann = ann_adaptor(data = reference, dim = 3, k = 1)
    ann.query(query)

    i_s_mos = []
    i_s_xds = []

    for j in range(len(mos_hkl_xyz_isigi)):
        c = ann.nn[j]
        if xds_hkl_xyz_isigi[c][0] == mos_hkl_xyz_isigi[j][0]:
            i_s_mos.append(mos_hkl_xyz_isigi[j][2][0])
            i_s_xds.append(xds_hkl_xyz_isigi[c][2][0])

    print('Matched %d observations' % len(i_s_mos))

    print(cc(i_s_mos, i_s_xds))

if __name__ == '__main__':
    main(sys.argv[1], sys.argv[2])


 *******************************************************************************


 *******************************************************************************
rstbx/bpcx/detector_model/__init__.py


 *******************************************************************************


 *******************************************************************************
rstbx/bpcx/detector_model/detector.py
from __future__ import absolute_import, division, print_function
#!/usr/bin/env python

from scitbx import matrix
from rstbx.bpcx import sensor
from six.moves import range

class detector:
    '''An abstract class definition for X-ray detectors which are assumed to
    be composed of one or more flat rectangular sensor areas. Will initially
    assume that sensor areas to not shadow one another.'''

    def __init__(self, sensors):
        self._sensors = sensors

        return

    def sensors(self):
        return self._sensors

class reflection_predictor:
    '''A class to convert supplied diffraction vectors and detector surfaces
    to impact positions as sensor number and mm in the coordinate frame
    attached to that sensor. Need to return number of sensor and coordinate.
    The units of mm are not enforced - it is whatever the detector matrix d
    is set up with'''

    def __init__(self, rays, sensors):

        self._rays = rays
        self._sensors = sensors
        return

    def intersections(self):
        '''Calculate intersections for each diffracted ray in the list'''

        intersections = []
        for ray in self._rays:
            x = self.intersect_all_sensors(ray)
            if x:
                intersections.append(x)

        return intersections

    def intersect_all_sensors(self, ray):
        # basic way - we have to check the vector against each sensor in turn.
        # there may be more efficient short cuts

        hit = None
        for j, s in enumerate(self._sensors):
            x = self.intersect(ray, s)
            if x:
                if hit is None:
                    dist = (matrix.col(s.origin) + \
                            x[0] * matrix.col(s.dir1) + \
                            x[1] * matrix.col(s.dir2)).length()
                    hit = (j, x[0], x[1], dist)
                else:
                    dist = (matrix.col(s.origin) + \
                            x[0] * matrix.col(s.dir1) + \
                            x[1] * matrix.col(s.dir2)).length()
                    if dist < hit[3]:
                        hit = (j, x[0], x[1], dist)
        return hit

    def intersect(self, ray, sensor):
        '''Compute intersection of sensor with ray from frame origin, returning
        none if intersection not within limits.'''
        raise RuntimeError('overload me')

class reflection_predictor_thomas(reflection_predictor):
    '''Implementation of reflection_predictor using David Thomas' matrix
    formalism'''

    def intersect(self, ray, sensor):
        v = matrix.sqr(sensor.D) * ray
        x1 = v[0] / v[2]
        x2 = v[1] / v[2]

        if x1 < sensor.lim1[0] or x1 > sensor.lim1[1]:
            return None
        if x2 < sensor.lim2[0] or x2 > sensor.lim2[1]:
            return None

        return (x1, x2)

class reflection_predictor_trivial(reflection_predictor):
    '''Implementation of reflection_predictor using the vectors directly'''

    def intersect(self, ray, sensor):
        scale = ray.dot(matrix.col(sensor.normal))
        r = (ray * sensor.distance / scale) - matrix.col(sensor.origin)
        x1 = r.dot(matrix.col(sensor.dir1))
        x2 = r.dot(matrix.col(sensor.dir2))
        if x1 < sensor.lim1[0] or x1 > sensor.lim1[1]:
            return None
        if x2 < sensor.lim2[0] or x2 > sensor.lim2[1]:
            return None

        return (x1, x2)

def predictor_factory(selection):
    '''Factory function to choose a suitable implementation of the
    reflection_predictor class. This is a basic version to flesh out the API.
    A more realistic version might use e.g. PHIL parameters to make the choice
    and would not hard code the alternatives'''

    class_choice = {
        'matrix': reflection_predictor_thomas,
        'vector': reflection_predictor_trivial
    }.get(selection)

    return class_choice

def test_all():
    '''Test all features of the module using a detector composed of four
    overlapping square sensors.'''

    d1 = matrix.col((1, 0, 0))
    d2 = matrix.col((0, 1, 0))
    lim = (0,50)
    panel0 = sensor(matrix.col((-45, -45, 100)), d1, d2, lim, lim)
    panel1 = sensor(matrix.col((-5, -45, 99)), d1, d2, lim, lim)
    panel2 = sensor(matrix.col((-45, -5, 98)), d1, d2, lim, lim)
    panel3 = sensor(matrix.col((-5, -5, 97)), d1, d2, lim, lim)

    d = detector([panel0, panel1, panel2, panel3])
    rays = [matrix.col((0, 0, 1))]

    for ver in ('matrix', 'vector'):
        rp = predictor_factory(ver)
        rp = rp(rays, d.sensors())

        # only one ray to consider
        rpi = rp.intersections()

        # the closest intersection should be on panel3
        assert rpi[0][0] == 3

    print('OK')

def test_work():
    '''Test all features of the module using a detector composed of four
    overlapping square sensors, with lots of rays.'''

    import random, time

    nrays = 10000

    d1 = matrix.col((1, 0, 0))
    d2 = matrix.col((0, 1, 0))
    lim = (0,50)
    panel0 = sensor(matrix.col((-45, -45, 100)), d1, d2, lim, lim)
    panel1 = sensor(matrix.col((-5, -45, 99)), d1, d2, lim, lim)
    panel2 = sensor(matrix.col((-45, -5, 98)), d1, d2, lim, lim)
    panel3 = sensor(matrix.col((-5, -5, 97)), d1, d2, lim, lim)

    d = detector([panel0, panel1, panel2, panel3])

    rays = [matrix.col((random.random() - 0.5,
                        random.random() - 0.5,
                        random.random() - 0.5)) for j in range(nrays)]

    rpi = { }

    for ver in ('matrix', 'vector'):
        t0 = time.time()
        rp = predictor_factory(ver)(rays, d.sensors())

        rpi[ver] = rp.intersections()

    for j, intersection_matrix in enumerate(rpi['matrix']):
        intersection_vector = rpi['vector'][j]
        assert(intersection_matrix[0] == intersection_vector[0])

    print('OK')

if __name__ == '__main__':
    test_work()


 *******************************************************************************


 *******************************************************************************
rstbx/bpcx/detector_model/instrument_specifics.py
from __future__ import absolute_import, division, print_function
# Hardware specific code that makes use of the abstract definitions in
# module detector

from rstbx.bpcx import sensor
from rstbx.bpcx.detector_model.detector import detector
from rstbx.cftbx.coordinate_frame_converter import coordinate_frame_converter
from libtbx.test_utils import approx_equal

class pilatus(detector):
    '''Trivial implementation of a PILATUS type detector of unspecified
    size. Single sensor surface fixed with pixel fast and slow directions
    parallel to the basis directions on that abstract surface. The origin
    is currently chosen in the corner of the detector frame'''

    # For this trivial example we require that there is only a single
    # sensor surface. The idea is that this class advertises its
    # suitability to a factory function.

    @staticmethod
    def understand(cfc):
        '''Ultimately prefer to understand an image file directly, but
        for the Use Case we use coordinate_frame_converter as an agent
        for obtaining information about the experiment. We will also
        want a more nuanced report of understanding. Here it is just
        boolean'''

        #TODO Implementation
        return True

    def __init__(self, origin, dir1, dir2, pixel_size_fast, pixel_size_slow,
                 npx_fast, npx_slow):
        self._px_size_fast = pixel_size_fast
        self._px_size_slow = pixel_size_slow
        self._npx_fast = int(npx_fast)
        self._npx_slow = int(npx_slow)

        lim1 = (0, self._npx_fast * self._px_size_fast)
        lim2 = (0, self._npx_slow * self._px_size_slow)
        # set up a single sensor
        s = sensor(origin, dir1, dir2, lim1, lim2)

        # set up the abstract detector
        detector.__init__(self, [s])

    def mm_to_px(self, intersection):
        '''Take an intersection in mm in the abstract coordinate frame
        attached to the sensor and convert it to coordinates in units of
        pixels in image space. This basic implementation assumes that the
        two origins coincide, the fast axis is aligned along dir1 and
        the slow axis along dir2. This does no bounds checking, it is
        purely a units conversion function'''

        fast = intersection[0] / self._px_size_fast
        slow = intersection[1] / self._px_size_slow

        return (fast, slow)

    # getters
    def px_size_fast(self):
        return self._px_size_fast

    def px_size_slow(self):
        return self._px_size_slow

    def npx_fast(self):
        return self._npx_fast

    def npx_slow(self):
        return self._npx_slow


class detector_factory_from_cfc:
    '''Identify and return a suitable detector class based on the
    information in a coordinate_frame_converter object'''

    def __init__(self, cfc):

        self._cfc = cfc
        self._known_detectors = [pilatus]

    def choose(self):

        choice = [d for d in self._known_detectors if d.understand(self._cfc)]
        return choice[0]

    def build(self):

        d = self.choose()
        origin = self._cfc.get_c('detector_origin')
        dir1 = self._cfc.get_c('detector_fast')
        dir2 = self._cfc.get_c('detector_slow')
        px_lim = self._cfc.get('detector_size_fast_slow')
        px_size_fast, px_size_slow = self._cfc.get('detector_pixel_size_fast_slow')

        return d(origin, dir1, dir2, px_size_fast, px_size_slow, px_lim[0],
                 px_lim[1])


if __name__ == '__main__':

    import sys

    # require XDS configuration file, e.g. xparm-uc1-2.xds
    if len(sys.argv) != 2:
        raise RuntimeError('%s configuration-file' % sys.argv[0])

    configuration_file = sys.argv[1]

    cfc = coordinate_frame_converter(configuration_file)

    df = detector_factory_from_cfc(cfc)
    d = df.build()

    # A little test. Intersection at centre of the abstract frame should
    # be at the centre of the pixel grid
    s = d.sensors()[0]
    intersection = ((s.lim1[1] - s.lim1[0]) / 2., (s.lim2[1] - s.lim2[0]) / 2.)

    assert approx_equal(d.mm_to_px(intersection), (d.npx_fast() / 2, d.npx_slow() / 2))
    print("OK")


 *******************************************************************************


 *******************************************************************************
rstbx/bpcx/detector_model/tst_detector_model.py
from __future__ import absolute_import, division, print_function
from scitbx import matrix
from rstbx.bpcx import sensor

def work_detector_model():
    # trivial test of instantiation

    i = matrix.col((1, 0, 0))
    j = matrix.col((0, 1, 0))
    k = matrix.col((0, 0, 1))

    d1 = i
    d2 = -j
    lim = (0,50)

    panel0 = sensor(matrix.col((-126, 144, -193)), d1, d2, lim, lim)

    panel0.set_origin(k)
    panel0.set_frame(k, i, j)

    assert(k.dot(matrix.col(panel0.origin)) > 0.999)

    print('OK')
    return

if __name__ == '__main__':
    work_detector_model()


 *******************************************************************************


 *******************************************************************************
rstbx/bpcx/ersatz_misset.py
from __future__ import absolute_import, division, print_function
import sys
import math
from scitbx import matrix
from scitbx.math.euler_angles import xyz_angles
from scitbx.math import r3_rotation_axis_and_angle_as_matrix

from rstbx.cftbx.coordinate_frame_converter import coordinate_frame_converter
from six.moves import range

# ersatz_misset -
#
# Code which will read SPOT.XDS and XPARM.XDS from indexing and "refine" the
# orientation matrix as a function of image number. This works by computing
# the predicted and observed positions in reciprocal space, then computing a
# rotation from one to the other, and decompose this to Euler angles rx, ry,
# rz, which are then averaged. This should probably be a smoothed model which
# is properly refined not averaged. Still useful though to give an idea of
# where the crystal actually is. Initial magnitude of shifts appears to be
# consistent with refined results from XDS INTEGRATE step.

def ersatz_misset(integrate_lp):
    a_s = []
    b_s = []
    c_s = []

    for record in open(integrate_lp):
        if 'COORDINATES OF UNIT CELL A-AXIS' in record:
            a = [float(r) for r in record.split()[-3:]]
            a_s.append(matrix.col(a))
        elif 'COORDINATES OF UNIT CELL B-AXIS' in record:
            b = [float(r) for r in record.split()[-3:]]
            b_s.append(matrix.col(b))
        elif 'COORDINATES OF UNIT CELL C-AXIS' in record:
            c = [float(r) for r in record.split()[-3:]]
            c_s.append(matrix.col(c))

    assert(len(a_s) == len(b_s) == len(c_s))

    ub0 = matrix.sqr(a_s[0].elems + b_s[0].elems + c_s[0].elems).inverse()

    for j in range(len(a_s)):
        ub = matrix.sqr(a_s[j].elems + b_s[j].elems + c_s[j].elems).inverse()
        print('%7.3f %7.3f %7.3f' % tuple(xyz_angles(ub.inverse() * ub0)))

    return

def parse_xds_xparm_scan_info(xparm_file):
    '''Read an XDS XPARM file, get the scan information.'''

    values = [float(x) for x in open(xparm_file).read().split()]

    assert(len(values) == 42)

    img_start = values[0]
    osc_start = values[1]
    osc_range = values[2]

    return img_start, osc_start, osc_range

def nint(a):
    return int(round(a))

def meansd(values):
    mean = sum(values) / len(values)
    var = sum([(v - mean) * (v - mean) for v in values]) / len(values)
    return mean, math.sqrt(var)

def ersatz_misset_predict(xparm_xds, spot_xds):
    '''As well as possible, try to predict the misorientation angles as a
    function of frame # from the indexed spots from the XDS IDXREF step.
    Calculation will be performed in CBF coordinae frame.'''

    cfc = coordinate_frame_converter(xparm_xds)
    axis = cfc.get_c('rotation_axis')
    wavelength = cfc.get('wavelength')
    beam = (1.0 / wavelength) * cfc.get_c('sample_to_source').normalize()
    U, B = cfc.get_u_b()
    UB = U * B

    detector_origin = cfc.get_c('detector_origin')
    detector_fast = cfc.get_c('detector_fast')
    detector_slow = cfc.get_c('detector_slow')
    pixel_size_fast, pixel_size_slow = cfc.get('detector_pixel_size_fast_slow')
    size_fast, size_slow = cfc.get('detector_size_fast_slow')

    img_start, osc_start, osc_range = parse_xds_xparm_scan_info(xparm_xds)

    rx_s = {}
    ry_s = {}
    rz_s = {}

    for record in open(spot_xds):
        values = [float(r) for r in record.split()]
        if len(values) != 7:
            continue
        hkl = tuple([nint(h) for h in values[-3:]])
        if hkl == (0, 0, 0):
            continue

        x, y, f = values[:3]

        phi = ((f - img_start + 1) * osc_range + osc_start) * math.pi / 180.0

        lab_xyz = detector_origin + \
                  detector_fast * x * pixel_size_fast + \
                  detector_slow * y * pixel_size_slow

        rec_xyz = ((1.0 / wavelength) * lab_xyz.normalize() + beam).rotate(
            axis, - phi)

        calc_xyz = UB * hkl

        # now compute vector and angle to overlay calculated position on
        # observed position, then convert this to a matrix

        shift_axis = calc_xyz.cross(rec_xyz)
        shift_angle = calc_xyz.angle(rec_xyz)

        M = matrix.sqr(r3_rotation_axis_and_angle_as_matrix(
            shift_axis, shift_angle))

        rx, ry, rz = xyz_angles(M)

        j = int(f)

        if not j in rx_s:
            rx_s[j] = []
        if not j in ry_s:
            ry_s[j] = []
        if not j in rz_s:
            rz_s[j] = []

        rx_s[j].append(rx)
        ry_s[j].append(ry)
        rz_s[j].append(rz)

    j = min(rx_s)
    ms_x0 = meansd(rx_s[j])[0]
    ms_y0 = meansd(ry_s[j])[0]
    ms_z0 = meansd(rz_s[j])[0]

    for j in sorted(rx_s)[1:]:
        ms_x = meansd(rx_s[j])
        ms_y = meansd(ry_s[j])
        ms_z = meansd(rz_s[j])

        print('%4d %6.3f %6.3f %6.3f' % \
            (j, ms_x[0] - ms_x0, ms_y[0] - ms_y0, ms_z[0] - ms_z0))


if __name__ == '__main__':
    ersatz_misset_predict(sys.argv[1], sys.argv[2])


 *******************************************************************************


 *******************************************************************************
rstbx/bpcx/uc1_2.py
from __future__ import absolute_import, division, print_function
from six.moves import range, zip
#!/usr/bin/env cctbx.python
#
# Biostruct-X Data Reduction Use Case 1.2:
#
# Given UB matrix, centring operation, generate a list of predictions as
# H K L x y phi. Also requires (clearly) a model for the detector positions
# and the crystal lattice type. This is aimed to help with identifying
# locations on the images.
#
# Requires:
#
# Determine maximum resolution limit.
# Generate full list of reflections to given resolution limit.
# Compute intersection angles for all reflections given UB matrix etc.
# Determine which of those will be recorded on the detector.

import sys
import math

from rstbx.cftbx.coordinate_frame_converter import coordinate_frame_converter
from rstbx.diffraction import rotation_angles, reflection_prediction
from rstbx.diffraction import full_sphere_indices
from cctbx.sgtbx import space_group, space_group_symbols
from cctbx.uctbx import unit_cell
from rstbx.bpcx.detector_model.instrument_specifics import detector_factory_from_cfc

def Py_generate_indices(unit_cell_constants, resolution_limit):
    '''Generate all possible reflection indices out to a given resolution
    limit, ignoring symmetry and centring.'''

    uc = unit_cell(unit_cell_constants)

    maxh, maxk, maxl = uc.max_miller_indices(resolution_limit)

    indices = []

    for h in range(-maxh, maxh + 1):
        for k in range(-maxk, maxk + 1):
            for l in range(-maxl, maxl + 1):

                if h == 0 and k == 0 and l == 0:
                    continue

                if uc.d((h, k, l)) < resolution_limit:
                    continue

                indices.append((h, k, l))

    return indices

def Py_remove_absent_indices(indices, space_group_number):
    '''From the given list of indices, remove those reflections which should
    be systematic absences according to the given space group.'''

    sg = space_group(space_group_symbols(space_group_number).hall())

    present = []

    for hkl in indices:
        if not sg.is_sys_absent(hkl):
            present.append(hkl)

    return present

def parse_xds_xparm_scan_info(xparm_file):
    '''Read an XDS XPARM file, get the scan information.'''

    values = [float(x) for x in open(xparm_file).read().split()]

    assert(len(values) == 42)

    img_start = values[0]
    osc_start = values[1]
    osc_range = values[2]

    return img_start, osc_start, osc_range

class python_reflection_prediction:
    def __init__(self, axis, s0, ub, detector_origin,
                 detector_fast, detector_slow,
                 f_min, f_max, s_min, s_max):
        self._axis = axis
        self._s0 = s0
        self._ub = ub
        self._detector_origin = detector_origin
        self._detector_fast = detector_fast
        self._detector_slow = detector_slow
        self._limits = f_min, f_max, s_min, s_max

        return

    def predict(self, indices, angles):

        detector_normal = self._detector_fast.cross(self._detector_slow)
        distance = self._detector_origin.dot(detector_normal)

        observed_reflection_positions = []

        for hkl, angle in zip(indices, angles):
            s = (self._ub * hkl).rotate(self._axis, angle)
            q = (s + self._s0).normalize()

            # check if diffracted ray parallel to detector face

            q_dot_n = q.dot(detector_normal)

            if q_dot_n == 0:
                continue

            r = (q * distance / q_dot_n) - self._detector_origin

            x = r.dot(self._detector_fast)
            y = r.dot(self._detector_slow)

            if x < self._limits[0] or y < self._limits[2]:
                continue
            if x > self._limits[1] or y > self._limits[3]:
                continue

            observed_reflection_positions.append((hkl, x, y, angle))

        return observed_reflection_positions

class make_prediction_list:

  def __init__(self, configuration_file, img_range, dmin = None,
               rocking_curve = "none", mosaicity_deg = 0.0):
      self._configuration_file = configuration_file
      self._img_range = img_range
      self._dmin = dmin
      self._rocking_curve = rocking_curve
      self._mosaicity_deg = mosaicity_deg
      return

  def predict_observations(self):
    '''Actually perform the prediction calculations.'''

    d2r = math.pi / 180.0
    cfc = coordinate_frame_converter(self._configuration_file)

    self.img_start, self.osc_start, self.osc_range = parse_xds_xparm_scan_info(
        self._configuration_file)

    if self._dmin is None:
        self._dmin = cfc.derive_detector_highest_resolution()

    phi_start = ((self._img_range[0] - self.img_start) * self.osc_range + \
                 self.osc_start) * d2r
    phi_end = ((self._img_range[1] - self.img_start + 1) * self.osc_range + \
               self.osc_start) * d2r
    self.phi_start_rad = phi_start
    self.phi_end_rad = phi_end
    # in principle this should come from the crystal model - should that
    # crystal model record the cell parameters or derive them from the
    # axis directions?

    A = cfc.get_c('real_space_a')
    B = cfc.get_c('real_space_b')
    C = cfc.get_c('real_space_c')

    cell = (A.length(), B.length(), C.length(), B.angle(C, deg = True),
            C.angle(A, deg = True), A.angle(B, deg = True))
    self.uc = unit_cell(cell)

    # generate all of the possible indices, then pull out those which should
    # be systematically absent

    sg = cfc.get('space_group_number')

    indices = full_sphere_indices(
      unit_cell = self.uc,
      resolution_limit = self._dmin,
      space_group = space_group(space_group_symbols(sg).hall()))

    # then get the UB matrix according to the Rossmann convention which
    # is used within the Labelit code.

    u, b = cfc.get_u_b(convention = cfc.ROSSMANN)
    axis = cfc.get('rotation_axis', convention = cfc.ROSSMANN)
    ub = u * b

    wavelength = cfc.get('wavelength')
    self.wavelength = wavelength

    # work out which reflections should be observed (i.e. pass through the
    # Ewald sphere)
    ra = rotation_angles(self._dmin, ub, wavelength, axis)

    obs_indices, obs_angles = ra.observed_indices_and_angles_from_angle_range(
        phi_start_rad = phi_start,
        phi_end_rad = phi_end,
        indices = indices)

    # convert all of these to full scattering vectors in a laboratory frame
    # (for which I will use the CBF coordinate frame) and calculate which
    # will intersect with the detector

    u, b = cfc.get_u_b()
    axis = cfc.get_c('rotation_axis')
    # must guarantee that sample_to_source vector is normalized so that
    #  s0 has length of 1/wavelength.
    sample_to_source_vec = cfc.get_c('sample_to_source').normalize()
    s0 = (- 1.0 / wavelength) * sample_to_source_vec
    ub = u * b

    # need some detector properties for this as well... starting to
    # abstract these to a detector model.
    df = detector_factory_from_cfc(cfc)
    d = df.build()

    # the Use Case assumes the detector consists of a single sensor
    sensor = d.sensors()[0]

    self.pixel_size_fast, self.pixel_size_slow = d.px_size_fast(), \
        d.px_size_slow()

    # used for polarization correction
    self.distance = sensor.distance

    rp = reflection_prediction(axis, s0, ub, sensor)
    if self._rocking_curve is not None:
      assert self._rocking_curve != "none"
      rp.set_rocking_curve(self._rocking_curve)
      rp.set_mosaicity(self._mosaicity_deg, degrees = True)
    return rp.predict(obs_indices, obs_angles)

# FIXME this test below should e.g. compare with INTEGRATE.HKL from XDS?

def test(configuration_file, img_range, dmin = None):
    '''Perform the calculations needed for use case 1.1.'''

    mp = make_prediction_list(configuration_file, img_range, dmin, None)
    obs_hkl, obs_fast, obs_slow, obs_angle = mp.predict_observations()

    r2d = 180.0 / math.pi

    for iobs in range(len(obs_hkl)):
      hkl = obs_hkl[iobs]
      f = obs_fast[iobs]
      s = obs_slow[iobs]
      angle = obs_angle[iobs]

      print('%5d %5d %5d' % hkl, '%11.4f %11.4f %9.2f' % (
            f / mp.pixel_size_fast, s / mp.pixel_size_slow,
            (mp.img_start - 1) + ((angle * r2d) - mp.osc_start) / \
             mp.osc_range))

if __name__ == '__main__':
    if len(sys.argv) < 4:
        msg = "Requires 3 arguments: path/to/xparm.xds start_image_no end_image_no"
        sys.exit(msg)
    if len(sys.argv) == 4:
        test(sys.argv[1], (int(sys.argv[2]), int(sys.argv[3])))
    else:
        test(sys.argv[1], (int(sys.argv[2]), int(sys.argv[3])),
            float(sys.argv[4]))


 *******************************************************************************


 *******************************************************************************
rstbx/bpcx/uc1_2_positions.py
from __future__ import absolute_import, division, print_function
#!/usr/bin/env python
#
# Biostruct-X Data Reduction Use Case 1.2:
#
# Validate reflection data from test refinement code against data from XDS,
# by means of computing a correlaton coefficient between the two sets of
# positions.

import math
import sys
import random
from cctbx.array_family import flex
from annlib_ext import AnnAdaptor as ann_adaptor
from scitbx import matrix
from six.moves import range

def meansd(values):

    assert(len(values) > 3)

    mean = sum(values) / len(values)
    var = sum([(v - mean) * (v - mean) for v in values]) / (len(values) - 1)

    return mean, math.sqrt(var)

def cc(a, b):

    assert(len(a) == len(b))

    ma, sa = meansd(a)
    mb, sb = meansd(b)

    r = (1 / (len(a) - 1)) * sum([((a[j] - ma) / sa) * ((b[j] - mb) / sb)
                                  for j in range(len(a))])

    return r

def work_cc():

    a = [random.random() + 0.01 * j for j in range(1000)]
    b = [random.random() + 0.01 * j for j in range(1000)]

    return cc(a, b)

def test_ann():

    reference = flex.double()

    for j in range(3 * 100):
        reference.append(random.random())

    query = flex.double()

    for j in range(3 * 10):
        query.append(random.random())

    ann = ann_adaptor(data = reference, dim = 3, k = 1)
    ann.query(query)

    # workout code - see how far separated on average they are - which should
    # in principle decrease as the number of positions in the reference set
    # increases

    offsets = []

    for j in range(10):
        q = matrix.col([query[3 * j + k] for k in range(3)])
        r = matrix.col([reference[3 * ann.nn[j] + k] for k in range(3)])
        offsets.append((q - r).length())

    return meansd(offsets)

def read_integrate_hkl(integrate_hkl):

    observations = []

    for record in open(integrate_hkl):
        if '!' in record[:1]:
            continue
        values = record.split()
        hkl = [int(h) for h in values[:3]]
        xyz = [float(x) for x in  values[5:8]]
        isigma = [float(x) for x in values[3:5]]

        observations.append((hkl, xyz, isigma))

    return observations

def read_uc1_2(uc1_2):
    predictions = []

    for record in open(uc1_2):
        values = record.split()
        hkl = [int(h) for h in values[:3]]
        xyz = [float(x) for x in values[3:]]

        predictions.append((hkl, xyz))

    return predictions

def validate_predictions(integrate_hkl, uc1_2):

    observations = read_integrate_hkl(integrate_hkl)
    predictions = read_uc1_2(uc1_2)

    reference = flex.double()
    query = flex.double()

    for hkl, xyz, isigma in observations:
        reference.append(xyz[0])
        reference.append(xyz[1])
        reference.append(xyz[2])

    for hkl, xyz in predictions:
        query.append(xyz[0])
        query.append(xyz[1])
        query.append(xyz[2])

    ann = ann_adaptor(data = reference, dim = 3, k = 1)
    ann.query(query)

    dxs = []
    dys = []
    dzs = []

    for j in range(len(predictions)):
        c = ann.nn[j]
        if observations[c][0] == predictions[j][0]:
            xyz = observations[c][1]
            x, y, z = predictions[j][1]
            dx = observations[c][1][0] - predictions[j][1][0]
            dy = observations[c][1][1] - predictions[j][1][1]
            dz = observations[c][1][2] - predictions[j][1][2]

            dxs.append(dx)
            dys.append(dy)
            dzs.append(dz)

            print(x, y, z, dx, dy, dz)

    return meansd(dxs), meansd(dys), meansd(dzs)

if __name__ == '__main__':
    dx, dy, dz = validate_predictions(sys.argv[1], sys.argv[2])


 *******************************************************************************


 *******************************************************************************
rstbx/bpcx/uc1_2_positions_idx.py
from __future__ import absolute_import, division, print_function
#!/usr/bin/env python
#
# Biostruct-X Data Reduction Use Case 1.2:
#
# Validate reflection data from test refinement code against data from XDS,
# by means of computing a correlaton coefficient between the two sets of
# positions.

import math
import sys
import random
from cctbx.array_family import flex
from annlib_ext import AnnAdaptor as ann_adaptor
from scitbx import matrix
from six.moves import range

def meansd(values):

    assert(len(values) > 3)

    mean = sum(values) / len(values)
    var = sum([(v - mean) * (v - mean) for v in values]) / (len(values) - 1)

    return mean, math.sqrt(var)

def cc(a, b):

    assert(len(a) == len(b))

    ma, sa = meansd(a)
    mb, sb = meansd(b)

    r = (1 / (len(a) - 1)) * sum([((a[j] - ma) / sa) * ((b[j] - mb) / sb)
                                  for j in range(len(a))])

    return r

def work_cc():

    a = [random.random() + 0.01 * j for j in range(1000)]
    b = [random.random() + 0.01 * j for j in range(1000)]

    return cc(a, b)

def test_ann():

    reference = flex.double()

    for j in range(3 * 100):
        reference.append(random.random())

    query = flex.double()

    for j in range(3 * 10):
        query.append(random.random())

    ann = ann_adaptor(data = reference, dim = 3, k = 1)
    ann.query(query)

    # workout code - see how far separated on average they are - which should
    # in principle decrease as the number of positions in the reference set
    # increases

    offsets = []

    for j in range(10):
        q = matrix.col([query[3 * j + k] for k in range(3)])
        r = matrix.col([reference[3 * ann.nn[j] + k] for k in range(3)])
        offsets.append((q - r).length())

    return meansd(offsets)

def read_spot_xds(spot_xds):

    observations = []

    for record in open(spot_xds):
        if '!' in record[:1]:
            continue
        values = record.split()
        hkl = [int(x) for x in values[-3:]]
        if hkl == [0, 0, 0]:
            continue
        xyz = [float(x) for x in values[:3]]

        observations.append((hkl, xyz))

    return observations

def read_uc1_2(uc1_2):
    predictions = []

    for record in open(uc1_2):
        values = record.split()
        hkl = [int(h) for h in values[:3]]
        xyz = [float(x) for x in values[3:]]

        predictions.append((hkl, xyz))

    return predictions

def validate_predictions(spot_xds, uc1_2):

    observations = read_spot_xds(spot_xds)
    predictions = read_uc1_2(uc1_2)

    reference = flex.double()
    query = flex.double()

    for hkl, xyz in observations:
        reference.append(xyz[0])
        reference.append(xyz[1])
        reference.append(xyz[2])

    for hkl, xyz in predictions:
        query.append(xyz[0])
        query.append(xyz[1])
        query.append(xyz[2])

    ann = ann_adaptor(data = reference, dim = 3, k = 1)
    ann.query(query)

    dxs = []
    dys = []
    dzs = []

    for j in range(len(predictions)):
        c = ann.nn[j]
        if observations[c][0] == predictions[j][0]:
            xyz = observations[c][1]
            x, y, z = predictions[j][1]
            dx = observations[c][1][0] - predictions[j][1][0]
            dy = observations[c][1][1] - predictions[j][1][1]
            dz = observations[c][1][2] - predictions[j][1][2]

            dxs.append(dx)
            dys.append(dy)
            dzs.append(dz)

            print(x, y, z, dx, dy, dz)

    return meansd(dxs), meansd(dys), meansd(dzs)

if __name__ == '__main__':
    dx, dy, dz = validate_predictions(sys.argv[1], sys.argv[2])


 *******************************************************************************


 *******************************************************************************
rstbx/bpcx/uc1_2_validate.py
from __future__ import absolute_import, division, print_function
#!/usr/bin/env python
#
# Biostruct-X Data Reduction Use Case 1.2:
#
# Validate reflection data from test integration code against data from XDS,
# by means of computing a correlaton coefficient between the two.

import math
import sys
import random
from cctbx.array_family import flex
from annlib_ext import AnnAdaptor as ann_adaptor
from scitbx import matrix
from six.moves import range

def meansd(values):

    assert(len(values) > 3)

    mean = sum(values) / len(values)
    var = sum([(v - mean) * (v - mean) for v in values]) / (len(values) - 1)

    return mean, math.sqrt(var)

def cc(a, b):

    assert(len(a) == len(b))

    ma, sa = meansd(a)
    mb, sb = meansd(b)

    r = (1 / (len(a) - 1)) * sum([((a[j] - ma) / sa) * ((b[j] - mb) / sb)
                                  for j in range(len(a))])

    return r

def work_cc():

    a = [random.random() + 0.01 * j for j in range(1000)]
    b = [random.random() + 0.01 * j for j in range(1000)]

    return cc(a, b)

def test_ann():

    reference = flex.double()

    for j in range(3 * 100):
        reference.append(random.random())

    query = flex.double()

    for j in range(3 * 10):
        query.append(random.random())

    ann = ann_adaptor(data = reference, dim = 3, k = 1)
    ann.query(query)

    # workout code - see how far separated on average they are - which should
    # in principle decrease as the number of positions in the reference set
    # increases

    offsets = []

    for j in range(10):
        q = matrix.col([query[3 * j + k] for k in range(3)])
        r = matrix.col([reference[3 * ann.nn[j] + k] for k in range(3)])
        offsets.append((q - r).length())

    return meansd(offsets)

def read_integrate_hkl(integrate_hkl):

    observations = []

    for record in open(integrate_hkl):
        if '!' in record[:1]:
            continue
        values = record.split()
        hkl = [int(h) for h in values[:3]]
        xyz = [float(x) for x in  values[5:8]]
        isigma = [float(x) for x in values[3:5]]

        observations.append((hkl, xyz, isigma))

    return observations

def read_uc1_2(uc1_2):
    predictions = []

    for record in open(uc1_2):
        values = record.split()
        hkl = [int(h) for h in values[1:4]]
        xyz = float(values[7]), float(values[8]), float(values[5])
        isigma = float(values[10]), float(values[12])

        predictions.append((hkl, xyz, isigma))

    return predictions

def validate_predictions(integrate_hkl, uc1_2):

    observations = read_integrate_hkl(integrate_hkl)
    predictions = read_uc1_2(uc1_2)

    reference = flex.double()
    query = flex.double()

    for hkl, xyz, isigma in observations:
        reference.append(xyz[0])
        reference.append(xyz[1])
        reference.append(xyz[2])

    for hkl, xyz, isigma in predictions:
        query.append(xyz[0])
        query.append(xyz[1])
        query.append(xyz[2])

    ann = ann_adaptor(data = reference, dim = 3, k = 1)
    ann.query(query)

    dxs = []
    dys = []
    dzs = []
    ivalues_o = []
    ivalues_p = []

    for j in range(len(predictions)):
        c = ann.nn[j]
        if observations[c][0] == predictions[j][0]:
            xyz = observations[c][1]
            dx = observations[c][1][0] - predictions[j][1][0]
            dy = observations[c][1][1] - predictions[j][1][1]
            dz = observations[c][1][2] - predictions[j][1][2]

            dxs.append(dx)
            dys.append(dy)
            dzs.append(dz)
            ivalues_o.append(observations[c][2][0])
            ivalues_p.append(predictions[j][2][0])
            print(observations[c][2][0], predictions[j][2][0])

    return meansd(dxs), meansd(dys), meansd(dzs), cc(ivalues_o, ivalues_p)

if __name__ == '__main__':
    dx, dy, dz, cc = validate_predictions(sys.argv[1], sys.argv[2])
    print('X: %.4f %.4f' % dx)
    print('Y: %.4f %.4f' % dy)
    print('Z: %.4f %.4f' % dz)
    print('CC: %.4f' % cc)


 *******************************************************************************


 *******************************************************************************
rstbx/bpcx/uc1_2a.py
from __future__ import absolute_import, division, print_function
from six.moves import zip
from six.moves import map
#!/usr/bin/env cctbx.python
#
# Use case 1.2A - going back to the use case for predictions and making sure that
# the predicted indices are actually identical to those from XDS, from both a
# brute force calculation and the Reeke method. These will start from an
# integrated data set from XDS.

# want methods to: read indices from XDS INTEGRATE.HKL, transform to our "standard
# frame" which is -
#
# h k l xcen ycen phicen
#
# where xcen, ycen are on the camera in mm in direction fast, slow respectively
# with origin outer corner, so range goes from [0, width], [0, height]. N.B.
# that this is identical to XDS frame modulo pixel size. Also phicen in degrees.

# 1 read INTEGRATE.HKL - this frame, create map (x, y, phi) -> HKL. Can then use
# ANN to 'find' a prediction and verify HKL later on.

def import_xds_integrate_hkl(xds_integrate_hkl_file, phi_range):
    from rstbx.cftbx.coordinate_frame_converter import coordinate_frame_converter
    cfc = coordinate_frame_converter(xds_integrate_hkl_file)

    px, py = cfc.get('detector_pixel_size_fast_slow')

    # read header, get out phi0, frame0, dphi, so can transform frame# to
    # phi value

    phi0 = None
    dphi = None
    frame0 = None

    for record in open(xds_integrate_hkl_file):
        if not record.startswith('!'):
            break
        if record.startswith('!STARTING_FRAME'):
            frame0 = int(record.split()[-1])
            continue
        if record.startswith('!STARTING_ANGLE'):
            phi0 = float(record.split()[-1])
            continue
        if record.startswith('!OSCILLATION_RANGE'):
            dphi = float(record.split()[-1])
            continue

    assert(not dphi is None)
    assert(not phi0 is None)
    assert(not frame0 is None)

    xyz_to_hkl = { }

    for record in open(xds_integrate_hkl_file):
        if record.startswith('!'):
            continue

        values = record.split()

        hkl = list(map(int, values[:3]))
        xyz = list(map(float, values[5:8]))

        xyz_mod = (xyz[0] * px, xyz[1] * py,
                   (xyz[2] - frame0) * dphi + phi0)

        if xyz_mod[2] < phi_range[0]:
            continue
        if xyz_mod[2] > phi_range[1]:
            continue

        xyz_to_hkl[xyz_mod] = hkl

    return xyz_to_hkl

# 2 read coordinate frame from same INTEGRATE.HKL, provide number of frames as
# input parameter, predict all reflections given camera position in same frame as
# above, store in same structure. Verify that all reflections in INTEGRATE.HKL
# appear in prediction list. N.B. lists not identical, as some reflections on dead
# regions of camera. Compare HKL, (x, y, phi)

def regenerate_predictions_brute(xds_integrate_hkl_file, phi_range):
    from rstbx.cftbx.coordinate_frame_converter import coordinate_frame_converter
    from rstbx.diffraction import rotation_angles
    from rstbx.diffraction import full_sphere_indices
    from cctbx.sgtbx import space_group, space_group_symbols
    from cctbx.uctbx import unit_cell
    import math

    cfc = coordinate_frame_converter(xds_integrate_hkl_file)

    d2r = math.pi / 180.0

    dmin = cfc.derive_detector_highest_resolution()

    A = cfc.get_c('real_space_a')
    B = cfc.get_c('real_space_b')
    C = cfc.get_c('real_space_c')

    cell = (A.length(), B.length(), C.length(), B.angle(C, deg = True),
            C.angle(A, deg = True), A.angle(B, deg = True))

    uc = unit_cell(cell)
    sg = cfc.get('space_group_number')

    indices = full_sphere_indices(
        unit_cell = uc,
        resolution_limit = dmin,
        space_group = space_group(space_group_symbols(sg).hall()))

    u, b = cfc.get_u_b(convention = cfc.ROSSMANN)
    axis = cfc.get('rotation_axis', convention = cfc.ROSSMANN)
    ub = u * b

    wavelength = cfc.get('wavelength')

    ra = rotation_angles(dmin, ub, wavelength, axis)

    obs_indices, obs_angles = ra.observed_indices_and_angles_from_angle_range(
        phi_start_rad = phi_range[0] * d2r,
        phi_end_rad = phi_range[1] * d2r,
        indices = indices)

    # in here work in internal (i.e. not Rossmann) coordinate frame

    u, b = cfc.get_u_b()
    axis = cfc.get_c('rotation_axis')
    sample_to_source_vec = cfc.get_c('sample_to_source').normalize()
    s0 = (- 1.0 / wavelength) * sample_to_source_vec
    ub = u * b

    detector_origin = cfc.get_c('detector_origin')
    detector_fast = cfc.get_c('detector_fast')
    detector_slow = cfc.get_c('detector_slow')
    detector_normal = detector_fast.cross(detector_slow)
    distance = detector_origin.dot(detector_normal.normalize())
    nx, ny = cfc.get('detector_size_fast_slow')
    px, py = cfc.get('detector_pixel_size_fast_slow')

    limits = [0, nx * px, 0, ny * py]

    xyz_to_hkl = { }

    for hkl, angle in zip(obs_indices, obs_angles):
        s = (ub * hkl).rotate(axis, angle)
        q = (s + s0).normalize()

        # check if diffracted ray parallel to detector face

        q_dot_n = q.dot(detector_normal)

        if q_dot_n == 0:
            continue

        r = (q * distance / q_dot_n) - detector_origin

        x = r.dot(detector_fast)
        y = r.dot(detector_slow)

        if x < limits[0] or y < limits[2]:
            continue
        if x > limits[1] or y > limits[3]:
            continue

        xyz = (x, y, angle / d2r)
        xyz_to_hkl[xyz] = list(map(int, hkl))

    return xyz_to_hkl

# 3 same as #2 verify that the predictions are all correct.

def regenerate_predictions_reeke(xds_integrate_hkl_file, phi_range):
    from rstbx.cftbx.coordinate_frame_converter import coordinate_frame_converter
    from rstbx.diffraction import rotation_angles
    from cctbx.sgtbx import space_group, space_group_symbols
    from cctbx.uctbx import unit_cell
    import math
    from dials.algorithms.refinement.prediction.reeke import reeke_model
    from cctbx.array_family import flex

    cfc = coordinate_frame_converter(xds_integrate_hkl_file)

    d2r = math.pi / 180.0

    dmin = cfc.derive_detector_highest_resolution()

    A = cfc.get_c('real_space_a')
    B = cfc.get_c('real_space_b')
    C = cfc.get_c('real_space_c')

    cell = (A.length(), B.length(), C.length(), B.angle(C, deg = True),
            C.angle(A, deg = True), A.angle(B, deg = True))

    uc = unit_cell(cell)
    sg = cfc.get('space_group_number')

    u, b = cfc.get_u_b()
    axis = cfc.get_c('rotation_axis')
    sample_to_source_vec = cfc.get_c('sample_to_source').normalize()
    wavelength = cfc.get('wavelength')
    s0 = (- 1.0 / wavelength) * sample_to_source_vec
    ub = u * b
    rm = reeke_model(ub, axis, s0, dmin, phi_range[0], phi_range[1], 3)
    reeke_indices = rm.generate_indices()

    # the following are in Rossmann coordinate frame to fit in with
    # Labelit code...
    ur, br = cfc.get_u_b(convention = cfc.ROSSMANN)
    axisr = cfc.get('rotation_axis', convention = cfc.ROSSMANN)
    ubr = ur * br

    ra = rotation_angles(dmin, ubr, wavelength, axisr)

    obs_indices, obs_angles = ra.observed_indices_and_angles_from_angle_range(
            phi_start_rad = phi_range[0] * d2r,
            phi_end_rad = phi_range[1] * d2r,
            indices = reeke_indices)


    detector_origin = cfc.get_c('detector_origin')
    detector_fast = cfc.get_c('detector_fast')
    detector_slow = cfc.get_c('detector_slow')
    detector_normal = detector_fast.cross(detector_slow)
    distance = detector_origin.dot(detector_normal.normalize())
    nx, ny = cfc.get('detector_size_fast_slow')
    px, py = cfc.get('detector_pixel_size_fast_slow')

    limits = [0, nx * px, 0, ny * py]

    xyz_to_hkl = { }

    for hkl, angle in zip(obs_indices, obs_angles):
        s = (ub * hkl).rotate(axis, angle)
        q = (s + s0).normalize()

        # check if diffracted ray parallel to detector face

        q_dot_n = q.dot(detector_normal)

        if q_dot_n == 0:
            continue

        r = (q * distance / q_dot_n) - detector_origin

        x = r.dot(detector_fast)
        y = r.dot(detector_slow)

        if x < limits[0] or y < limits[2]:
            continue
        if x > limits[1] or y > limits[3]:
            continue

        xyz = (x, y, angle / d2r)
        xyz_to_hkl[xyz] = list(map(int, hkl))

    return xyz_to_hkl

def compare(xyz_to_hkl, xyz_to_hkl_ref):
    # construct ann to perform search...

    from cctbx.array_family import flex
    from annlib_ext import AnnAdaptor as ann_adaptor

    reference = flex.double()

    xyzs = [xyz for xyz in xyz_to_hkl]

    for xyz in xyzs:
        reference.append(xyz[0])
        reference.append(xyz[1])
        reference.append(xyz[2])

    ann = ann_adaptor(data = reference, dim = 3, k = 1)

    n_correct = 0
    n_wrong = 0

    for xyz in xyz_to_hkl_ref:
        query = flex.double(xyz)
        ann.query(query)
        nnxyz = xyzs[ann.nn[0]]
        if xyz_to_hkl_ref[xyz] == xyz_to_hkl[nnxyz]:
            n_correct += 1
        else:
            n_wrong += 1

    return n_correct, n_wrong

# 4 define 'matrix' and 'hkl' file formats - or follow d*TREK model:
#
# {
# HEADER_SIZE=NNNN;
# PARAMETER=VALUE;
# ...
# }
# H K L x y phi
# ...
#
# + read / write class.

def ranges(xyz_to_hkl):
    xyzs = list(xyz_to_hkl)
    hmin = hmax = xyz_to_hkl[xyzs[0]][0]
    kmin = kmax = xyz_to_hkl[xyzs[0]][1]
    lmin = lmax = xyz_to_hkl[xyzs[0]][2]

    for xyz in xyzs:
        h, k, l = xyz_to_hkl[xyz]
        if h < hmin:
            hmin = h
        if h > hmax:
            hmax = h
        if k < kmin:
            kmin = k
        if k > kmax:
            kmax = k
        if l < lmin:
            lmin = l
        if l > lmax:
            lmax = l

    return hmin, hmax, kmin, kmax, lmin, lmax

def work():
    import sys
    integrate_hkl = sys.argv[1]

    phi_range = (0.0, 1.0)

    xyz_to_hkl_xds = import_xds_integrate_hkl(integrate_hkl, phi_range)

    print('XDS:', ranges(xyz_to_hkl_xds))

    xyz_to_hkl = regenerate_predictions_brute(integrate_hkl, phi_range)

    print('Brute:', ranges(xyz_to_hkl))

    n_correct, n_wrong = compare(xyz_to_hkl, xyz_to_hkl_xds)
    print(n_correct, n_wrong)
    # assert(float(n_correct) / float(n_correct + n_wrong) > 0.999)
    print('OK')

    try:
        from dials.algorithms.refinement.prediction.reeke import reeke_model
        xyz_to_hkl = regenerate_predictions_reeke(integrate_hkl, phi_range)

        print('Reeke:', ranges(xyz_to_hkl))

        n_correct, n_wrong = compare(xyz_to_hkl, xyz_to_hkl_xds)
        print(n_correct, n_wrong)
        # assert(float(n_correct) / float(n_correct + n_wrong) > 0.999)

        print('OK')
    except ImportError as e:
        print("Test of the Reeke algorithm requires DIALS.")

if __name__ == '__main__':
    work()


 *******************************************************************************


 *******************************************************************************
rstbx/cftbx/__init__.py


 *******************************************************************************


 *******************************************************************************
rstbx/cftbx/coordinate_frame_converter.py
from __future__ import absolute_import, division, print_function
import math
import sys

from scitbx import matrix
from cctbx import uctbx

from .coordinate_frame_helpers import is_xds_xparm, import_xds_xparm
from .coordinate_frame_helpers import is_xds_inp, import_xds_inp
from .coordinate_frame_helpers import is_xds_integrate_hkl, \
    import_xds_integrate_hkl
from .coordinate_frame_helpers import is_xds_ascii_hkl, \
    import_xds_ascii_hkl

class coordinate_frame_converter:
    '''A class which is instantiated from a supported file (initially an
    imgCIF image or an XDS XPARM / INTEGRATE.HKL / XDS_ASCII.HKL file) and
    will make available the rotation axis, beam vector, detector position
    and attitude, detector origin, fast and slow directions and so on in
    a range of different program specific coordinate frames.'''

    CBF = 'CBF'
    ROSSMANN = 'Rossmann'
    MOSFLM = 'Mosflm'

    def __init__(self, configuration_file):
        '''Construct a coordinate frame converter from a configuration file.'''

        if is_xds_xparm(configuration_file):
            self._coordinate_frame_information = import_xds_xparm(
                configuration_file)

        elif is_xds_integrate_hkl(configuration_file):
            self._coordinate_frame_information = import_xds_integrate_hkl(
                configuration_file)

        elif is_xds_ascii_hkl(configuration_file):
            self._coordinate_frame_information = import_xds_ascii_hkl(
                configuration_file)

        elif is_xds_inp(configuration_file):
            self._coordinate_frame_information = import_xds_inp(
                configuration_file)

        else:
            raise RuntimeError(
            'unknown configuration file %s'%configuration_file)

        return

    def get(self, parameter, convention = CBF):
        '''Get a parameter, in a given reference frame if a vector quantity,
        as a Python basic type.'''

        result = self.get_c(parameter, convention)

        if hasattr(result, 'elems'):
            return result.elems

        return result

    def get_c(self, parameter, convention = CBF):
        '''Get the parameter, in the correct coordinate convention if a
        vector, as a cctbx matrix.col or a floating point value.'''

        parameter_value = self._coordinate_frame_information.get(parameter)

        if not hasattr(parameter_value, 'elems'):
            return parameter_value

        if convention == coordinate_frame_converter.CBF:
            R = self._coordinate_frame_information.R_to_CBF()
            return R * parameter_value
        elif convention == coordinate_frame_converter.ROSSMANN:
            R = self._coordinate_frame_information.R_to_Rossmann()
            return R * parameter_value
        elif convention == coordinate_frame_converter.MOSFLM:
            R = self._coordinate_frame_information.R_to_Mosflm()
            return R * parameter_value
        else:
            raise RuntimeError(
            'convention %s not currently supported'%convention)

        return

    def move(self, vector, convention = CBF):
        '''Rotate input vector assumed to be in input coordinate frame into
        standard coordinate frame.'''

        from scitbx import matrix

        return self.move_c(matrix.col(vector), convention).elems

    def move_c(self, vector, convention = CBF):
        '''Rotate input vector assumed to be in input coordinate frame into
        standard coordinate frame, returning cctbx vector.'''

        R0 = self._coordinate_frame_information.get_original_rotation()
        if R0:
            vector = R0 * vector

        if convention == coordinate_frame_converter.CBF:
            R = self._coordinate_frame_information.R_to_CBF()
            return R * vector
        elif convention == coordinate_frame_converter.ROSSMANN:
            R = self._coordinate_frame_information.R_to_Rossmann()
            return R * vector
        elif convention == coordinate_frame_converter.MOSFLM:
            R = self._coordinate_frame_information.R_to_Mosflm()
            return R * vector
        else:
            raise RuntimeError(
            'convention %s not currently supported'%convention)

        return

    def get_u_b(self, convention = CBF):
        '''Get the [U] and [B] matrices in the requested coordinate system.'''

        cfi = self._coordinate_frame_information

        if not cfi.get_real_space_a() or not cfi.get_real_space_b() or \
           not cfi.get_real_space_c():
            raise RuntimeError('orientation matrix information missing')

        axis_a = cfi.get_real_space_a()
        axis_b = cfi.get_real_space_b()
        axis_c = cfi.get_real_space_c()

        A = matrix.sqr(axis_a.elems +  axis_b.elems + axis_c.elems).inverse()

        a = axis_a.length()
        b = axis_b.length()
        c = axis_c.length()

        alpha = axis_b.angle(axis_c, deg = True)
        beta = axis_c.angle(axis_a, deg = True)
        gamma = axis_a.angle(axis_b, deg = True)

        uc = uctbx.unit_cell((a, b, c, alpha, beta, gamma))

        B = matrix.sqr(uc.fractionalization_matrix()).transpose()

        U = A * B.inverse()

        if convention == coordinate_frame_converter.CBF:
            R = cfi.R_to_CBF()
        elif convention == coordinate_frame_converter.ROSSMANN:
            R = cfi.R_to_Rossmann()
        elif convention == coordinate_frame_converter.MOSFLM:
            R = cfi.R_to_Mosflm()
        else:
            raise RuntimeError(
            'convention %s not currently supported'%convention)

        return R * U, B

    def get_unit_cell(self):
        '''Get the unit cell.'''

        cfi = self._coordinate_frame_information

        if not cfi.get_real_space_a() or not cfi.get_real_space_b() or \
           not cfi.get_real_space_c():
            raise RuntimeError('orientation matrix information missing')

        axis_a = cfi.get_real_space_a()
        axis_b = cfi.get_real_space_b()
        axis_c = cfi.get_real_space_c()

        A = matrix.sqr(axis_a.elems +  axis_b.elems + axis_c.elems).inverse()

        a = axis_a.length()
        b = axis_b.length()
        c = axis_c.length()

        alpha = axis_b.angle(axis_c, deg = True)
        beta = axis_c.angle(axis_a, deg = True)
        gamma = axis_a.angle(axis_b, deg = True)

        uc = uctbx.unit_cell((a, b, c, alpha, beta, gamma))

        return uc

    def derive_beam_centre_pixels_fast_slow(self):
        '''Derive the pixel position at which the direct beam would intersect
        with the detector plane, and return this in terms of fast and slow.'''

        cfi = self._coordinate_frame_information

        detector_origin = cfi.get('detector_origin')
        detector_fast = cfi.get('detector_fast')
        detector_slow = cfi.get('detector_slow')
        sample_to_source = cfi.get('sample_to_source')
        pixel_size_fast, pixel_size_slow = cfi.get(
            'detector_pixel_size_fast_slow')

        detector_normal = detector_fast.cross(detector_slow)

        if not sample_to_source.dot(detector_normal):
            raise RuntimeError('beam parallel to detector')

        distance = detector_origin.dot(detector_normal)

        sample_to_detector = sample_to_source * distance / \
                             sample_to_source.dot(detector_normal)

        beam_centre = sample_to_detector - detector_origin

        beam_centre_fast_mm = beam_centre.dot(detector_fast)
        beam_centre_slow_mm = beam_centre.dot(detector_slow)

        return beam_centre_fast_mm / pixel_size_fast, \
               beam_centre_slow_mm / pixel_size_slow

    def derive_detector_highest_resolution(self):
        '''Determine the highest resolution recorded on the detector, which
        should be at one of the corners.'''

        cfi = self._coordinate_frame_information

        detector_origin = cfi.get('detector_origin')
        detector_fast = cfi.get('detector_fast')
        detector_slow = cfi.get('detector_slow')
        sample_to_source = cfi.get('sample_to_source')
        pixel_size_fast, pixel_size_slow = cfi.get(
            'detector_pixel_size_fast_slow')
        size_fast, size_slow = cfi.get(
            'detector_size_fast_slow')

        F = detector_origin + detector_fast * pixel_size_fast * size_fast
        S = detector_origin + detector_slow * pixel_size_slow * size_slow
        FS = F + S - detector_origin

        detector_normal = detector_fast.cross(detector_slow)
        distance = detector_origin.dot(detector_normal)

        sample_to_detector = sample_to_source * distance / \
                             sample_to_source.dot(detector_normal)

        theta = 0.5 * max([sample_to_detector.angle(detector_origin),
                           sample_to_detector.angle(F),
                           sample_to_detector.angle(S),
                           sample_to_detector.angle(FS)])

        return cfi.get_wavelength() / (2.0 * math.sin(theta))

    def __str__(self):

        return '\n'.join([
            'detector origin: %.3f %.3f %.3f' % self.get('detector_origin'),
            'detector fast: %6.3f %6.3f %6.3f' % self.get('detector_fast'),
            'detector slow: %6.3f %6.3f %6.3f' % self.get('detector_slow'),
            'rotation axis: %6.3f %6.3f %6.3f' % self.get('rotation_axis'),
            '- s0 vector:   %6.3f %6.3f %6.3f' % self.get('sample_to_source')
            ])

if __name__ == '__main__':

    if len(sys.argv) < 2:
        raise RuntimeError('%s configuration-file mosflm-matrix' % sys.argv[0])

    configuration_file = sys.argv[1]

    cfc = coordinate_frame_converter(configuration_file)

    print('Maximum resolution: %.2f' % cfc.derive_detector_highest_resolution())

    mosflm_matrix = matrix.sqr(
        [float(_x) for _x in open(sys.argv[2]).read().split()[:9]])

    u, b = cfc.get_u_b(convention = cfc.MOSFLM)

    wavelength = cfc.get('wavelength')

    mosflm_matrix = (1.0 / wavelength) * mosflm_matrix

    matrix_format = '%8.5f %8.5f %8.5f\n%8.5f %8.5f %8.5f\n%8.5f %8.5f %8.5f'

    print(matrix_format % mosflm_matrix.elems)
    print(matrix_format % (u * b).elems)


 *******************************************************************************


 *******************************************************************************
rstbx/cftbx/coordinate_frame_helpers.py
from __future__ import absolute_import, division, print_function

import io
import math
import random

from scitbx import matrix
from cctbx import sgtbx
from six.moves import range, zip

class coordinate_frame_information:
    '''A bucket class to store coordinate frame information.'''

    def __init__(self, detector_origin, detector_fast, detector_slow,
                 detector_size_fast_slow, detector_pixel_size_fast_slow,
                 rotation_axis, sample_to_source, wavelength,
                 real_space_a=None, real_space_b=None,
                 real_space_c=None, space_group_number=None,
                 sigma_divergence=None,
                 mosaicity=None,
                 starting_angle=None, oscillation_range=None,
                 starting_frame=None,
                 original_rotation=None,
                 data_range=None,
                 panel_offset=None,
                 panel_size=None,
                 panel_origin=None,
                 panel_fast=None,
                 panel_slow=None):

        self._detector_origin = detector_origin
        self._detector_fast = detector_fast
        self._detector_slow = detector_slow
        self._detector_size_fast_slow = detector_size_fast_slow
        self._detector_pixel_size_fast_slow = detector_pixel_size_fast_slow
        self._rotation_axis = rotation_axis
        self._sample_to_source = sample_to_source
        self._wavelength = wavelength
        self._real_space_a = real_space_a
        self._real_space_b = real_space_b
        self._real_space_c = real_space_c
        self._space_group_number = space_group_number
        self._sigma_divergence = sigma_divergence
        self._mosaicity = mosaicity
        self._starting_angle = starting_angle
        self._oscillation_range = oscillation_range
        self._starting_frame = starting_frame
        self._data_range = data_range
        self._original_rotation = original_rotation
        self._panel_offset = panel_offset
        self._panel_size = panel_size
        self._panel_origin = panel_origin
        self._panel_fast = panel_fast
        self._panel_slow = panel_slow

        self._R_to_CBF = None
        self._R_to_Rossmann = None
        self._R_to_Mosflm = None

        return

    def get_detector_origin(self):
        return self._detector_origin

    def get_detector_fast(self):
        return self._detector_fast

    def get_detector_slow(self):
        return self._detector_slow

    def get_rotation_axis(self):
        return self._rotation_axis

    def get_sample_to_source(self):
        return self._sample_to_source

    def get_wavelength(self):
        return self._wavelength

    def get_real_space_a(self):
        return self._real_space_a

    def get_real_space_b(self):
        return self._real_space_b

    def get_real_space_c(self):
        return self._real_space_c

    def get_space_group_number(self):
        return self._space_group_number

    def get_original_rotation(self):
        return self._original_rotation

    def get(self, parameter_name):
        if not hasattr(self, '_%s' % parameter_name):
            raise RuntimeError('no parameter %s' % parameter_name)
        return getattr(self, '_%s' % parameter_name)

    def R_to_CBF(self):

        if not self._R_to_CBF:
            self._R_to_CBF = align_reference_frame(
                self._rotation_axis, (1.0, 0.0, 0.0),
                self._sample_to_source, (0.0, 0.0, 1.0))

        return self._R_to_CBF

    def R_to_Rossmann(self):

        if not self._R_to_Rossmann:
            self._R_to_Rossmann = align_reference_frame(
                self._sample_to_source, (0.0, 0.0, - 1.0),
                self._rotation_axis, (0.0, 1.0, 0.0))

        return self._R_to_Rossmann

    def R_to_Mosflm(self):

        if not self._R_to_Mosflm:
            self._R_to_Mosflm = align_reference_frame(
                self._sample_to_source, (- 1.0, 0.0, 0.0),
                self._rotation_axis, (0.0, 0.0, 1.0))

        return self._R_to_Mosflm

def orthogonal_component(reference, changing):
    '''Return unit vector corresponding to component of changing orthogonal to
    reference.'''

    r = reference.normalize()
    c = changing.normalize()

    return (c - c.dot(r) * r).normalize()

def align_reference_frame(primary_axis, primary_target,
                          secondary_axis, secondary_target):
    '''Compute a rotation matrix R: R x primary_axis = primary_target and
    R x secondary_axis places the secondary_axis in the plane perpendicular
    to the primary_target, as close as possible to the secondary_target.
    Require: primary_target orthogonal to secondary_target, primary axis
    not colinear with secondary axis.'''

    if type(primary_axis) == type(()) or type(primary_axis) == type([]):
        primary_axis = matrix.col(primary_axis).normalize()
    else:
        primary_axis = primary_axis.normalize()

    if type(primary_target) == type(()) or type(primary_target) == type([]):
        primary_target = matrix.col(primary_target).normalize()
    else:
        primary_target = primary_target.normalize()

    if type(secondary_axis) == type(()) or type(secondary_axis) == type([]):
        secondary_axis = matrix.col(secondary_axis).normalize()
    else:
        secondary_axis = secondary_axis.normalize()

    if type(secondary_target) == type(()) or \
           type(secondary_target) == type([]):
        secondary_target = matrix.col(secondary_target).normalize()
    else:
        secondary_target = secondary_target.normalize()

    # check properties of input axes

    assert math.fabs(primary_axis.angle(secondary_axis) % math.pi) > 0.001
    p_dot_s = primary_target.dot(secondary_target)
    assert p_dot_s < 0.001, p_dot_s

    if primary_target.angle(primary_axis) % math.pi:
      axis_p = primary_target.cross(primary_axis)
      angle_p = - primary_target.angle(primary_axis)
      Rprimary = axis_p.axis_and_angle_as_r3_rotation_matrix(angle_p)
    elif primary_target.dot(primary_axis) < 0:
      axis_p = primary_axis.ortho().normalize()
      angle_p = math.pi
      Rprimary = axis_p.axis_and_angle_as_r3_rotation_matrix(angle_p)
    else:
      Rprimary = matrix.identity(3)

    if math.fabs(secondary_target.angle(Rprimary * secondary_axis)) < 1.0e-6:
      Rsecondary = matrix.identity(3)
    else:
      axis_r = secondary_target.cross(Rprimary * secondary_axis)
      axis_s = primary_target

      if (axis_r.angle(primary_target, value_if_undefined=0) > 0.5 * math.pi):
        angle_s = orthogonal_component(axis_s, secondary_target).angle(
          orthogonal_component(axis_s, Rprimary * secondary_axis))
      else:
        angle_s = - orthogonal_component(axis_s, secondary_target).angle(
          orthogonal_component(axis_s, Rprimary * secondary_axis))

      Rsecondary = axis_s.axis_and_angle_as_r3_rotation_matrix(angle_s)

    return Rsecondary * Rprimary

def is_xds_inp(putative_xds_inp_file):
    '''See if this file looks like an XDS.INP file.'''
    from iotbx.xds import xds_inp
    return xds_inp.reader.is_xds_inp_file(putative_xds_inp_file)

def is_xds_xparm(putative_xds_xparm_file):
    '''See if this file looks like an XDS XPARM file i.e. it consists of 42
    floating point values and nothing else.'''
    from iotbx.xds import xparm
    return xparm.reader.is_xparm_file(putative_xds_xparm_file)

def is_xds_integrate_hkl(putative_integrate_hkl_file):
    '''See if this looks like an XDS INTEGRATE.HKL file.'''

    with io.open(putative_integrate_hkl_file, encoding="ascii") as fh:
      try:
        first_record = fh.readline()
        return '!OUTPUT_FILE=INTEGRATE.HKL' in first_record
      except UnicodeDecodeError:
        return False

def is_xds_ascii_hkl(putative_xds_ascii_hkl_file):
    '''See if this looks like an XDS INTEGRATE.HKL file.'''

    with io.open(putative_xds_ascii_hkl_file, encoding="ascii") as f:
      try:
        f.readline()
        return "!OUTPUT_FILE=XDS_ASCII.HKL" in f.readline()
      except UnicodeDecodeError:
        return False

def is_recognized_file(filename):
    ''' Check if the file is recognized.'''
    if is_xds_xparm(filename):
        return True
    elif is_xds_integrate_hkl(filename):
        return True
    elif is_xds_ascii_hkl(filename):
        return True
    elif is_xds_inp(filename):
        return True

    # Not recognized
    return False

def import_xds_integrate_hkl(integrate_hkl_file):
    '''Read an XDS INTEGRATE.HKL file, transform the parameters contained
    therein into the standard coordinate frame, record this as a dictionary.'''

    assert(is_xds_integrate_hkl(integrate_hkl_file))

    header = []

    with open(integrate_hkl_file) as fh:
        for record in fh:
            if not record.startswith('!'):
                break

            header.append(record)

    # now need to dig out the values I want, convert and return

    distance = None

    for record in header:
        if record.startswith('!ROTATION_AXIS='):
            axis = [float(r) for r in record.split()[-3:]]
            continue
        if record.startswith('!INCIDENT_BEAM_DIRECTION='):
            beam = [float(r) for r in record.split()[-3:]]
            continue
        if record.startswith('!DIRECTION_OF_DETECTOR_X-AXIS='):
            x = [float(r) for r in record.split()[-3:]]
            continue
        if record.startswith('!DIRECTION_OF_DETECTOR_Y-AXIS='):
            y = [float(r) for r in record.split()[-3:]]
            continue
        if record.startswith('!UNIT_CELL_A-AXIS='):
            a = [float(r) for r in record.split()[-3:]]
            continue
        if record.startswith('!UNIT_CELL_B-AXIS='):
            b = [float(r) for r in record.split()[-3:]]
            continue
        if record.startswith('!UNIT_CELL_C-AXIS='):
            c = [float(r) for r in  record.split()[-3:]]
            continue
        if record.startswith('!X-RAY_WAVELENGTH='):
            wavelength = float(record.split()[-1])
            continue
        if record.startswith('!DETECTOR_DISTANCE='):
            distance = float(record.split()[-1])
            continue
        if record.startswith('!SPACE_GROUP_NUMBER='):
            space_group_number = int(record.split()[-1])
            continue
        if record.startswith('!BEAM_DIVERGENCE_E.S.D.'):
            sigma_divergence = float(record.split()[-1])
            continue
        if record.startswith('!REFLECTING_RANGE_E.S.D.'):
            mosaicity = float(record.split()[-1])
            continue
        if record.startswith('!NX='):
            nx = int(record.split()[1])
            ny = int(record.split()[3])
            px = float(record.split()[5])
            py = float(record.split()[7])
            continue
        if record.startswith('!ORGX='):
            ox = float(record.split()[1])
            oy = float(record.split()[3])
            try:
                distance = float(record.split()[5])
            except IndexError: # Older versions of this file do not contain distance on this line.
                pass
            continue
        if record.startswith('!STARTING_FRAME'):
            starting_frame = int(record.split()[-1])
            continue
        if record.startswith('!STARTING_ANGLE'):
            starting_angle = float(record.split()[-1])
            continue
        if record.startswith('!OSCILLATION_RANGE'):
            oscillation_range = float(record.split()[-1])
            continue

    # check parameters set
    assert not distance is None

    # XDS defines the beam vector as s0 rather than from sample -> source.
    # Keep in mind that any inversion of a vector needs to be made with great
    # care!

    B = - matrix.col(beam).normalize()
    A = matrix.col(axis).normalize()

    X = matrix.col(x).normalize()
    Y = matrix.col(y).normalize()
    N = X.cross(Y)

    _X = matrix.col([1, 0, 0])
    _Y = matrix.col([0, 1, 0])
    _Z = matrix.col([0, 0, 1])

    R = align_reference_frame(A, _X, B, _Z)

    # Need to subtract 0.5 because XDS seems to do centroids in fortran coords
    ox = ox - 0.5
    oy = oy - 0.5

    detector_origin = R * (distance * N - ox * px * X - oy * py * Y)
    detector_fast = R * X
    detector_slow = R * Y
    rotation_axis = R * A
    sample_to_source = R * B
    real_space_a = R * matrix.col(a)
    real_space_b = R * matrix.col(b)
    real_space_c = R * matrix.col(c)

    return coordinate_frame_information(
        detector_origin, detector_fast, detector_slow, (nx, ny), (px, py),
        rotation_axis, sample_to_source, wavelength,
        real_space_a, real_space_b, real_space_c, space_group_number,
        sigma_divergence, mosaicity,
        starting_angle, oscillation_range, starting_frame, original_rotation = R)

def import_xds_ascii_hkl(xds_ascii_hkl_file):
    '''Read an XDS INTEGRATE.HKL file, transform the parameters contained therein
    into the standard coordinate frame, record this as a dictionary.'''

    assert(is_xds_ascii_hkl(xds_ascii_hkl_file))

    header = []

    for record in open(xds_ascii_hkl_file):
        if not record.startswith('!'):
            break

        header.append(record)

    # now need to dig out the values I want, convert and return

    for record in header:
        if record.startswith('!ROTATION_AXIS='):
            axis = [float(r) for r in record.split()[-3:]]
            continue
        if record.startswith('!INCIDENT_BEAM_DIRECTION='):
            beam = [float(r) for r in record.split()[-3:]]
            continue
        if record.startswith('!DIRECTION_OF_DETECTOR_X-AXIS='):
            x = [float(r) for r in record.split()[-3:]]
            continue
        if record.startswith('!DIRECTION_OF_DETECTOR_Y-AXIS='):
            y = [float(r) for r in record.split()[-3:]]
            continue
        if record.startswith('!UNIT_CELL_A-AXIS='):
            a = [float(r) for r in record.split()[-3:]]
            continue
        if record.startswith('!UNIT_CELL_B-AXIS='):
            b = [float(r) for r in record.split()[-3:]]
            continue
        if record.startswith('!UNIT_CELL_C-AXIS='):
            c = [float(r) for r in record.split()[-3:]]
            continue
        if record.startswith('!X-RAY_WAVELENGTH='):
            wavelength = float(record.split()[-1])
            continue
        if record.startswith('!DETECTOR_DISTANCE='):
            distance = float(record.split()[-1])
            continue
        if record.startswith('!SPACE_GROUP_NUMBER='):
            space_group_number = int(record.split()[-1])
            continue
        if record.startswith('!BEAM_DIVERGENCE_E.S.D.'):
            sigma_divergence = float(record.split()[-1])
            continue
        if record.startswith('!REFLECTING_RANGE_E.S.D.'):
            mosaicity = float(record.split()[-1])
            continue
        if record.startswith('!NX='):
            nx = int(record.split()[1])
            ny = int(record.split()[3])
            px = float(record.split()[5])
            py = float(record.split()[7])
            continue
        if record.startswith('!ORGX='):
            ox = float(record.split()[1])
            oy = float(record.split()[3])
            continue
        if record.startswith('!STARTING_FRAME'):
            starting_frame = int(record.split()[-1])
            continue
        if record.startswith('!STARTING_ANGLE'):
            starting_angle = float(record.split()[-1])
            continue
        if record.startswith('!OSCILLATION_RANGE'):
            oscillation_range = float(record.split()[-1])
            continue

    # XDS defines the beam vector as s0 rather than from sample -> source.
    # Keep in mind that any inversion of a vector needs to be made with great
    # care!

    B = - matrix.col(beam).normalize()
    A = matrix.col(axis).normalize()

    X = matrix.col(x).normalize()
    Y = matrix.col(y).normalize()
    N = X.cross(Y)

    _X = matrix.col([1, 0, 0])
    _Y = matrix.col([0, 1, 0])
    _Z = matrix.col([0, 0, 1])

    R = align_reference_frame(A, _X, B, _Z)

    # Need to subtract 0.5 because XDS seems to do centroids in fortran coords
    ox = ox - 0.5
    oy = oy - 0.5


    detector_origin = R * (distance * N - ox * px * X - oy * py * Y)
    detector_fast = R * X
    detector_slow = R * Y
    rotation_axis = R * A
    sample_to_source = R * B
    real_space_a = R * matrix.col(a)
    real_space_b = R * matrix.col(b)
    real_space_c = R * matrix.col(c)

    return coordinate_frame_information(
        detector_origin, detector_fast, detector_slow, (nx, ny), (px, py),
        rotation_axis, sample_to_source, wavelength,
        real_space_a, real_space_b, real_space_c, space_group_number,
        sigma_divergence, mosaicity,
        starting_angle, oscillation_range, starting_frame, original_rotation = R)

def import_xds_inp(xds_inp_file):
    '''Read an XDS XPARM file, transform the parameters contained therein
    into the standard coordinate frame, record this as a dictionary.'''
    from iotbx.xds import xds_inp

    handle = xds_inp.reader()
    handle.read_file(xds_inp_file)

    # first determine the rotation R from the XDS coordinate frame used in
    # the processing to the central (i.e. imgCIF) coordinate frame. N.B.
    # if the scan was e.g. a PHI scan the resulting frame could well come out
    # a little odd...

    axis = handle.rotation_axis
    beam = handle.incident_beam_direction
    x, y = handle.direction_of_detector_x_axis, handle.direction_of_detector_y_axis

    # XDS defines the beam vector as s0 rather than from sample -> source.

    B = - matrix.col(beam).normalize()
    A = matrix.col(axis).normalize()

    X = matrix.col(x).normalize()
    Y = matrix.col(y).normalize()
    N = X.cross(Y)

    _X = matrix.col([1, 0, 0])
    _Y = matrix.col([0, 1, 0])
    _Z = matrix.col([0, 0, 1])

    R = align_reference_frame(A, _X, B, _Z)

    # now transform contents of the XPARM file to the form which we want to
    # return...

    nx, ny = handle.nx, handle.ny
    px, py = handle.px, handle.py

    distance = handle.detector_distance
    ox, oy = handle.orgx, handle.orgy

    # Need to subtract 0.5 because XDS seems to do centroids in fortran coords
    ox = ox - 0.5
    oy = oy - 0.5

    detector_origin = R * (distance * N - ox * px * X - oy * py * Y)
    detector_fast = R * X
    detector_slow = R * Y
    rotation_axis = R * A
    sample_to_source = R * B
    wavelength = handle.xray_wavelength
    real_space_a, real_space_b, real_space_c = None, None, None
    space_group_number = handle.space_group_number
    starting_angle = handle.starting_angle
    oscillation_range = handle.oscillation_range
    starting_frame = handle.starting_frame
    data_range = handle.data_range

    panel_offset = None
    panel_size = None
    panel_origins = None
    panel_fast_axes = None
    panel_slow_axes = None

    if handle.num_segments > 1:
        # Now, for each detector segment the following two lines of information
        # are provided.

        # The 5 numbers of this line, iseg x1 x2 y1 y2, define the pixel numbers
        # IX,IY belonging to segment #iseg as x1<=IX<=x2, y1<=IY<=y2.
        # The 9 numbers of this line, ORGXS ORGYS FS EDS(:,1) EDS(:,2), describe
        # origin and orientation of segment #iseg with respect to the detector
        # coordinate system.

        panel_offset = []
        panel_size = []
        panel_origins = []
        panel_fast_axes = []
        panel_slow_axes = []
        for i in range(handle.num_segments):
            x1, x2, y1, y2 = handle.segment[i]
            # XDS panel limits inclusive range
            panel_offset.append((x1-1, y1-1))
            panel_size.append((x2-x1+1, y2-y1+1))
            panel_fast = matrix.col(handle.direction_of_segment_x_axis[i])
            panel_slow = matrix.col(handle.direction_of_segment_y_axis[i])
            # local basis vectors
            fl = matrix.col(panel_fast)
            sl = matrix.col(panel_slow)
            nl = fl.cross(sl)

            orgxs = handle.segment_orgx[i]
            orgys = handle.segment_orgy[i]
            fs = handle.segment_distance[i]
            panel_origin = R * (- (orgxs - x1 + 1) * px * fl \
                                - (orgys - y1 + 1) * py * sl \
                                + fs * nl ) \
                + detector_origin

            # detector to laboratory transformation
            ED = matrix.sqr(list(X) + list(Y) + list(N))

            panel_normal = (R * panel_fast).cross(R * panel_slow)
            panel_origins.append(panel_origin)
            panel_fast_axes.append(R * ED * panel_fast)
            panel_slow_axes.append(R * ED * panel_slow)

    return coordinate_frame_information(
        detector_origin, detector_fast, detector_slow, (nx, ny), (px, py),
        rotation_axis, sample_to_source, wavelength,
        real_space_a, real_space_b, real_space_c, space_group_number,
        None, None, starting_angle, oscillation_range, starting_frame,
        original_rotation=R,
        data_range=data_range,
        panel_offset=panel_offset,
        panel_size=panel_size,
        panel_origin=panel_origins,
        panel_fast=panel_fast_axes,
        panel_slow=panel_slow_axes)


def import_xds_xparm(xparm_file):
    '''Read an XDS XPARM file, transform the parameters contained therein
    into the standard coordinate frame, record this as a dictionary.'''
    from iotbx.xds import xparm

    handle = xparm.reader()
    handle.read_file(xparm_file)

    # first determine the rotation R from the XDS coordinate frame used in
    # the processing to the central (i.e. imgCIF) coordinate frame. N.B.
    # if the scan was e.g. a PHI scan the resulting frame could well come out
    # a little odd...

    axis = handle.rotation_axis
    beam = handle.beam_vector
    x, y = handle.detector_x_axis, handle.detector_y_axis

    # XDS defines the beam vector as s0 rather than from sample -> source.

    B = - matrix.col(beam).normalize()
    A = matrix.col(axis).normalize()

    X = matrix.col(x).normalize()
    Y = matrix.col(y).normalize()
    N = X.cross(Y)

    _X = matrix.col([1, 0, 0])
    _Y = matrix.col([0, 1, 0])
    _Z = matrix.col([0, 0, 1])

    R = align_reference_frame(A, _X, B, _Z)

    # now transform contents of the XPARM file to the form which we want to
    # return...

    nx, ny = handle.detector_size
    px, py = handle.pixel_size

    distance = handle.detector_distance
    ox, oy = handle.detector_origin

    a = handle.unit_cell_a_axis
    b = handle.unit_cell_b_axis
    c = handle.unit_cell_c_axis

    # Need to subtract 0.5 because XDS seems to do centroids in fortran coords
    ox = ox - 0.5
    oy = oy - 0.5

    detector_origin = R * (distance * N - ox * px * X - oy * py * Y)
    detector_fast = R * X
    detector_slow = R * Y
    rotation_axis = R * A
    sample_to_source = R * B
    wavelength = handle.wavelength
    real_space_a = R * matrix.col(a)
    real_space_b = R * matrix.col(b)
    real_space_c = R * matrix.col(c)
    space_group_number = handle.space_group
    starting_angle = handle.starting_angle
    oscillation_range = handle.oscillation_range
    starting_frame = handle.starting_frame

    panel_offset = None
    panel_size = None
    panel_origins = None
    panel_fast_axes = None
    panel_slow_axes = None

    if handle.num_segments > 1:
        # Now, for each detector segment the following two lines of information
        # are provided.

        # The 5 numbers of this line, iseg x1 x2 y1 y2, define the pixel numbers
        # IX,IY belonging to segment #iseg as x1<=IX<=x2, y1<=IY<=y2.
        # The 9 numbers of this line, ORGXS ORGYS FS EDS(:,1) EDS(:,2), describe
        # origin and orientation of segment #iseg with respect to the detector
        # coordinate system.

        panel_offset = []
        panel_size = []
        panel_origins = []
        panel_fast_axes = []
        panel_slow_axes = []
        for segment, orientation,  in zip(handle.segments, handle.orientation):
            iseg, x1, x2, y1, y2 = segment
            # XDS panel limits inclusive range
            panel_offset.append((x1-1, y1-1))
            panel_size.append((x2-x1+1, y2-y1+1))
            panel_fast = matrix.col(orientation[3:6])
            panel_slow = matrix.col(orientation[6:9])
            # local basis vectors
            fl = matrix.col(panel_fast)
            sl = matrix.col(panel_slow)
            nl = fl.cross(sl)

            orgxs, orgys, fs = orientation[:3]
            panel_origin = R * (- (orgxs - x1 + 1) * px * fl \
                                - (orgys - y1 + 1) * py * sl \
                                + fs * nl ) \
                + detector_origin

            # detector to laboratory transformation
            ED = matrix.sqr(list(X) + list(Y) + list(N))

            panel_normal = (R * panel_fast).cross(R * panel_slow)
            panel_origins.append(panel_origin)
            panel_fast_axes.append(R * ED * panel_fast)
            panel_slow_axes.append(R * ED * panel_slow)

    return coordinate_frame_information(
        detector_origin, detector_fast, detector_slow, (nx, ny), (px, py),
        rotation_axis, sample_to_source, wavelength,
        real_space_a, real_space_b, real_space_c, space_group_number,
        None, None, starting_angle, oscillation_range, starting_frame,
        original_rotation=R,
        panel_offset=panel_offset,
        panel_size=panel_size,
        panel_origin=panel_origins,
        panel_fast=panel_fast_axes,
        panel_slow=panel_slow_axes)

def test_align_reference_frame():

    _i = (1, 0, 0)
    _j = (0, 1, 0)
    _k = (0, 0, 1)

    primary_axis = _i
    primary_target = _i
    secondary_axis = _k
    secondary_target = _k

    m = align_reference_frame(primary_axis, primary_target,
                              secondary_axis, secondary_target)

    i = matrix.identity(3)

    for j in range(9):
        assert(math.fabs(m.elems[j] - i.elems[j]) < 0.001)

    primary_axis = _j
    primary_target = _i
    secondary_axis = _k
    secondary_target = _k

    m = align_reference_frame(primary_axis, primary_target,
                              secondary_axis, secondary_target)

    for j in range(3):
        assert(math.fabs((m * primary_axis).elems[j] -
                         matrix.col(primary_target).elems[j]) < 0.001)

def test_align_reference_frame_dw():

    s = math.sqrt(0.5)

    pa = [s, s, 0]
    pt = [1, 0, 0]
    sa = [- s, s, 0]
    st = [0, 1, 0]

    R = align_reference_frame(pa,pt,sa,st)

    print(R * pa)
    print(pt)
    print(R * sa)
    print(st)

def random_orthogonal_vectors():
    v1 = matrix.col((random.random(), random.random(),
                     random.random())).normalize()
    v2 = v1.ortho().normalize()

    return v1, v2

def test_align_reference_frame_brute():

    for j in range(10000):
        m = random_orthogonal_vectors()
        t = random_orthogonal_vectors()

        assert(math.fabs(m[0].dot(m[1])) < 0.001)
        assert(math.fabs(t[0].dot(t[1])) < 0.001)

        R = align_reference_frame(m[0], t[0],
                                  m[1], t[1])

        r = (R * m[0], R * m[1])

        assert(math.fabs(r[0].dot(t[0])) > 0.999)
        assert(math.fabs(r[1].dot(t[1])) > 0.999)

    return

def find_closest_matrix(moving, target):
    '''Work through lattice permutations to try to align moving with target,
    with the metric of trace(inverse(moving) * target).'''

    trace = 0.0
    reindex = matrix.identity(3)

    for op in sgtbx.space_group_info('P422').type().group().all_ops():
        moved = matrix.sqr(op.r().as_double()) * moving
        if (moved.inverse() * target).trace() > trace:
            trace = (moved.inverse() * target).trace()
            reindex = matrix.sqr(op.r().as_double())

    return reindex

def work():
    import sys
    import_xds_integrate_hkl(sys.argv[1])
    print('OK')

if __name__ == '__main__':
    work()


 *******************************************************************************


 *******************************************************************************
rstbx/cftbx/tst_coordinate_frame_converter.py
from __future__ import absolute_import, division, print_function
def tst_coordinate_frame_converter():
  import libtbx.load_env
  rstbx = libtbx.env.dist_path('rstbx')
  from rstbx.cftbx.coordinate_frame_converter import \
     coordinate_frame_converter
  import os
  cfc = coordinate_frame_converter(os.path.join(rstbx, 'cftbx', 'tests',
                                                'example-xparm.xds'))
  from scitbx import matrix
  x = matrix.col((1, 0, 0))
  assert(cfc.move_c(x, convention = cfc.CBF).angle(
      cfc.get_c('detector_fast')) < 0.1)

  print('OK')

if __name__ == '__main__':
  tst_coordinate_frame_converter()


 *******************************************************************************


 *******************************************************************************
rstbx/command_line/__init__.py


 *******************************************************************************


 *******************************************************************************
rstbx/command_line/example_viewer.py
from __future__ import absolute_import, division, print_function
# LIBTBX_SET_DISPATCHER_NAME phenix.example_viewer
# LIBTBX_PRE_DISPATCHER_INCLUDE_SH export PHENIX_GUI_ENVIRONMENT=1
# LIBTBX_PRE_DISPATCHER_INCLUDE_SH export BOOST_ADAPTBX_FPE_DEFAULT=1

import sys
from rstbx.command_line.viewer import run

def modified_image_factory(filename):
  from iotbx.detectors.generic_detector import GenericDetector
  I = GenericDetector(filename)
  I.readHeader()
  return I

def modify_the_iotbx_detector_list():
  from iotbx import detectors
  detectors.ImageFactory = modified_image_factory

if (__name__ == "__main__"):
  modify_the_iotbx_detector_list()
  file_arguments = sys.argv[1:]
  if len(file_arguments) > 0:
    run(sys.argv[1:])
  else:
    print("Use phenix.example_viewer <data file name[s]>")


 *******************************************************************************


 *******************************************************************************
rstbx/command_line/index.py
from __future__ import absolute_import, division, print_function
# LIBTBX_PRE_DISPATCHER_INCLUDE_SH PHENIX_GUI_ENVIRONMENT=1
# LIBTBX_PRE_DISPATCHER_INCLUDE_SH export PHENIX_GUI_ENVIRONMENT

from labelit import preferences
import os

def run_new_horizons(args):
  import os,copy
  new_horizons_phil = preferences.RunTimePreferences()
  # new_horizons_phil is an instance of a class that has a libtbx.phil.scope
  # print new_horizons_phil.phil_scope
  special_defaults_for_new_horizons( new_horizons_phil )

  args_copy = copy.copy(args)
  for item in args:
    # open any phil files and add them to the scope
    if os.path.isfile(item):
      new_horizons_phil.try_any_preferences_file(item)
      args_copy.remove(item)
  #merge any command line arguments into the scope
  new_horizons_phil.merge_command_line(args_copy)
  #new_horizons_phil.show()
  from rstbx.new_horizons.index import run_index
  return run_index(new_horizons_phil.command_extractor)
  # new_horizons_phil.command_extractor is an instance of a class
  # that behaves like a libtbx.phil.scope_extract but keeps a weak link
  # back to the parent RunTimePreferences instance
  # print new_horizons_phil.command_extractor.persist

def special_defaults_for_new_horizons(phil_scope):
  # for integration, do not want 2x2 binning
  phil_scope.merge_command_line(["distl_permit_binning=False"])

if __name__=='__main__':
  import sys
  #args list can have file names + phil parameters
  args = sys.argv[1:]
  run_new_horizons(args)


 *******************************************************************************


 *******************************************************************************
rstbx/command_line/simage.create.py
from __future__ import absolute_import, division, print_function
from six.moves import zip
def run(args):
  from rstbx.simage import create
  from scitbx.array_family import flex
  work_params = create.process_args(args=args)
  i_calc, image_info = create.compute(
    work_params=work_params,
    store_miller_index_i_seqs=True,
    store_spots=True,
    store_signals=True)
  if (work_params.wavelength_2 is None):
    for i_seq,x,s in zip(
          image_info.miller_index_i_seqs,
          image_info.spots,
          image_info.signals):
      h = i_calc.p1_anom.indices()[i_seq]
      print("%3d %3d %3d" % h, "(%8.2f, %8.2f)" % tuple(x[:2]), "%.6g" % s)
    print()
  else:
    i_calc_2, image_info_2 = create.compute(
      work_params=work_params,
      use_wavelength_2=True,
      store_miller_index_i_seqs=True,
      store_spots=True,
      store_signals=True)
    assert i_calc.p1_anom.indices().all_eq(i_calc_2.p1_anom.indices())
    lookup_dict = {}
    for ii,i_seq in enumerate(image_info_2.miller_index_i_seqs):
      lookup_dict[i_seq] = ii
    d_spacings = i_calc.p1_anom.d_spacings().data()
    d_array = flex.double()
    streak_array = flex.double()
    i_mean_array = flex.double()
    for i_seq,x,s in zip(
          image_info.miller_index_i_seqs,
          image_info.spots,
          image_info.signals):
      ii = lookup_dict.get(i_seq)
      if (ii is not None):
        x = tuple(x[:2])
        x2 = tuple(image_info_2.spots[ii][:2])
        s2 = image_info_2.signals[ii]
        dx = tuple([b-a for a,b in zip(x,x2)])
        streak = (dx[0]**2 + dx[1]**2)**0.5
        h = i_calc.p1_anom.indices()[i_seq]
        print("%3d %3d %3d" % h, " %8.5f" % d_spacings[i_seq], \
          "(%7.1f, %7.1f)" % x, "%.1f" % s)
        print("                     ", \
          "(%7.1f, %7.1f)" % x2, "%.1f" % s2, " %.1f" % (s2-s))
        print("                      (%7.1f, %7.1f)" % dx, " %.1f" % streak)
        d_array.append(d_spacings[i_seq])
        streak_array.append(streak)
        i_mean_array.append((s+s2)*0.5)
    print()
    print("Writing file: d_vs_streak.xy")
    f = open("d_vs_streak.xy", "w")
    for x,y in zip(d_array, streak_array):
      print(x, y, file=f)
    del f
    print("Writing file: i_vs_streak.xy")
    perm = flex.sort_permutation(i_mean_array)
    f = open("i_vs_streak.xy", "w")
    for x,y in zip(i_mean_array.select(perm), streak_array.select(perm)):
      print(x, y, file=f)
    del f
  _ = i_calc.p1_anom
  d = _.d_spacings().data()
  i = _.data()
  print("Writing file: d_vs_i_calc.xy")
  f = open("d_vs_i_calc.xy", "w")
  for x,y in zip(d, i):
    print(x, y, file=f)
  del f
  print("Writing file: i_calc_vs_d.xy")
  perm = flex.sort_permutation(i)
  f = open("i_calc_vs_d.xy", "w")
  for x,y in zip(i.select(perm), d.select(perm)):
    print(x, y, file=f)
  del f
  print()
  _ = i_calc.p1_anom
  for cutoff in [0.1, 0.05, 0.02, 0.01]:
    print("Completeness with i_calc >= %.2f:" % cutoff)
    visible = _.select(_.data() >= cutoff)
    a, b = visible.indices().size(), _.indices().size()
    print("  Overall: %d / %d = %.3f" % (a, b, a/max(1,b)))
    visible.setup_binner(n_bins=10)
    visible.completeness(use_binning=True).show(prefix="  ")
    print()

if (__name__ == "__main__"):
  import sys
  run(args=sys.argv[1:])


 *******************************************************************************


 *******************************************************************************
rstbx/command_line/simage.explore_completeness.py
from __future__ import absolute_import, division, print_function
# LIBTBX_PRE_DISPATCHER_INCLUDE_SH PHENIX_GUI_ENVIRONMENT=1
# LIBTBX_PRE_DISPATCHER_INCLUDE_SH export PHENIX_GUI_ENVIRONMENT

if (__name__ == "__main__"):
  from rstbx.simage.explore_completeness import run
  import sys
  run(args=sys.argv[1:])


 *******************************************************************************


 *******************************************************************************
rstbx/command_line/simage.solver.py
from __future__ import absolute_import, division, print_function
if (__name__ == "__main__"):
  from rstbx.simage.solver import run
  import sys
  run(args=sys.argv[1:])


 *******************************************************************************


 *******************************************************************************
rstbx/command_line/simage.wx_display.py
from __future__ import absolute_import, division, print_function
# LIBTBX_PRE_DISPATCHER_INCLUDE_SH PHENIX_GUI_ENVIRONMENT=1
# LIBTBX_PRE_DISPATCHER_INCLUDE_SH export PHENIX_GUI_ENVIRONMENT

if (__name__ == "__main__"):
  from rstbx.simage.wx_display import run
  import sys
  run(args=sys.argv[1:])


 *******************************************************************************


 *******************************************************************************
rstbx/command_line/slip_viewer.py
from __future__ import absolute_import, division, print_function
# -*- Mode: Python; c-basic-offset: 2; indent-tabs-mode: nil; tab-width: 8 -*-
#
# LIBTBX_SET_DISPATCHER_NAME cctbx.image_viewer
# LIBTBX_PRE_DISPATCHER_INCLUDE_SH export PHENIX_GUI_ENVIRONMENT=1
# LIBTBX_PRE_DISPATCHER_INCLUDE_SH export BOOST_ADAPTBX_FPE_DEFAULT=1
#
# $Id$

import os
import sys
import wx

from rstbx.slip_viewer.frame import XrayFrame
from iotbx import phil
from spotfinder import phil_str
from spotfinder.command_line.signal_strength import additional_spotfinder_phil_defs
from rstbx.phil.phil_preferences import iotbx_defs_viewer_detail

master_str="""
anti_aliasing = False
  .type = bool
  .help = "Enable anti-aliasing"
effective_metrology = None
  .type = path
  .help = "Read effective metrology from PATH"
beam_center = True
  .type = bool
  .help = "Mark beam center"
show_integration_results = False
  .type = bool
  .help = "Show integration results"
show_spotfinder_results = False
  .type = bool
  .help = "Show spotfinder results"
show_effective_tiling = False
  .type = bool
  .help = "Show the effective tiling of the detector"
show_untrusted = False
  .type = bool
  .help = "Always highlyight untrusted pixels, regardless of detector type"
""" + iotbx_defs_viewer_detail

def run(argv=None):
  if (argv is None):
    argv = sys.argv

  # XXX Could/should handle effective metrology the same way, except
  # it does not have a single scope.
  work_phil = phil.process_command_line(
    args=argv[1:],
    master_string=master_str + phil_str + additional_spotfinder_phil_defs)
  work_params = work_phil.work.extract()

  app = wx.App(0)
  wx.SystemOptions.SetOption("osx.openfiledialog.always-show-types", "1")
  frame = XrayFrame(None, -1, "X-ray image display", size=(800,720))
  frame.Show()

  # show settings panel
  frame.OnShowSettings(None)
  frame.settings_frame.panel.center_ctrl.SetValue(
    work_params.beam_center)
  frame.settings_frame.panel.integ_ctrl.SetValue(
    work_params.show_integration_results)
  frame.settings_frame.panel.spots_ctrl.SetValue(
    work_params.show_spotfinder_results)
  frame.settings.show_effective_tiling = work_params.show_effective_tiling
  frame.settings_frame.panel.collect_values()

  if (work_params.effective_metrology is not None):
    from serialtbx.detector.legacy_metrology.metrology import \
      master_phil, metrology_as_transformation_matrices

    stream = open(work_params.effective_metrology)
    metrology_phil = master_phil.fetch(sources=[phil.parse(stream.read())])
    stream.close()
    frame.metrology_matrices = metrology_as_transformation_matrices(
      metrology_phil.extract())

  # Update initial settings with values from the command line.  Needs
  # to be done before image is loaded (but after the frame is
  # instantiated).
  frame.params = work_params
  frame.init_pyslip()
  frame.pyslip.tiles.user_requests_antialiasing = work_params.anti_aliasing
  frame.pyslip.tiles.show_untrusted = frame.params.show_untrusted

  paths = work_phil.remaining_args
  if (len(paths) == 1 and os.path.basename(paths[0]) == "DISTL_pickle"):
    assert os.path.isfile(paths[0])
    frame.load_distl_output(paths[0])
  elif (len(paths) > 0):
    frame.CHOOSER_SIZE = 1500

    # from dxtbx.imageset import ImageSetFactory
    # sets = ImageSetFactory.new(paths)
    from dxtbx.model.experiment_list import ExperimentListFactory
    from rstbx.slip_viewer.frame import chooser_wrapper
    experiments = ExperimentListFactory.from_filenames(paths)
    sets = experiments.imagesets()

    for imgset in sets:
      for idx in imgset.indices():
        frame.add_file_name_or_data(chooser_wrapper(imgset, idx))
    idx = sets[0].indices()[0]
    frame.load_image(chooser_wrapper(sets[0],idx))

  app.MainLoop()

  return 0


if (__name__ == "__main__"):
  sys.exit(run())


 *******************************************************************************


 *******************************************************************************
rstbx/command_line/viewer.py
from __future__ import absolute_import, division, print_function
# LIBTBX_SET_DISPATCHER_NAME phenix.image_viewer
# LIBTBX_PRE_DISPATCHER_INCLUDE_SH export PHENIX_GUI_ENVIRONMENT=1
# LIBTBX_PRE_DISPATCHER_INCLUDE_SH export BOOST_ADAPTBX_FPE_DEFAULT=1

from rstbx.viewer.frame import XrayFrame
import wx
import os
import sys

def run(args):
  app = wx.App(0)
  wx.SystemOptions.SetOption("osx.openfiledialog.always-show-types", "1")
  frame = XrayFrame(None, -1, "X-ray image display", size=(800,720))
  if (len(args) == 1 and os.path.basename(args[0]) == "DISTL_pickle"):
    assert os.path.isfile(args[0])
    frame.load_distl_output(args[0])
  elif (len(args) > 0):
    for file_name in args:
      assert os.path.isfile(file_name)
      frame.add_file_name_or_data(file_name)
    frame.load_image(args[0])
  frame.Show()
  app.MainLoop()

if (__name__ == "__main__"):
  run(sys.argv[1:])


 *******************************************************************************


 *******************************************************************************
rstbx/detectors/__init__.py


 *******************************************************************************


 *******************************************************************************
rstbx/detectors/silicon.py
from __future__ import absolute_import, division, print_function
from six.moves import range
crystalline_density = 2.3290 / 1000.# g/(mm^3) #wikipedia

# Custer JS et al (1994) Density of amorphous Si. Applied Phys. Lett. 64: 437-439.
amorphous_density = crystalline_density / 1.018

class Si_mass_attenuation:
  """Parameterized fit provided by Miroslav Kobas, Dectris Ltd.
  valid range, 2000 - 50000 eV
  Source data for parameter fit were obtained at http://www-cxro.lbl.gov/optical_constants/pert_form.html"""

  # XXX problem with this fit?  I don't get the same fit-to-tabulated that Miro got. 0.1% error
  # XXX Later; try to refit the tabulated data
  def from_energy_eV(self,eV):
    a = 197.625
    b = -1.66146E7
    c = 5.64362E11
    d = -7.64354E15
    e = 1.36449E20
    f = -1.15528E24
    g = 6.54438E27
    h = -2.53016E31
    i = 6.54905E34
    j = -1.08207E38
    k = 1.02849E41
    l = -4.26636E43
    """Returns photoabsorption cross section in (mm^2)/g"""
    if not 2000 <= eV <= 50000: raise Exception("Input energy %7.1feV out of range"%eV)
    xx = 1./eV
    return a + xx*(b + xx*(c + xx*(d + xx*(e + xx*(f + xx*(g + xx*(h + xx*(i + xx*(j + xx*(k + xx*l))))))))))
    #return a + b*xx + c*xx**2 + d*xx**3 + e*xx**4 + f*xx**5 + g*xx**6 + h*xx**7 + i*xx**8 + j*xx**9 + k*xx**10 + l*xx**11

  def from_wavelength_Angstrom(self,Ang):
    return self.from_energy_eV(eV_from_Ang(Ang))

def eV_from_Ang(Ang):
  return 12398.424/Ang

if __name__=="__main__":
  for eV in range(2000, 30500, 500):
    print(eV, "%.2f"%Si_mass_attenuation().from_energy_eV(eV))
  print(Si_mass_attenuation().from_wavelength_Angstrom(1.3))
  print(Si_mass_attenuation().from_wavelength_Angstrom(1.297461)*amorphous_density)


 *******************************************************************************


 *******************************************************************************
rstbx/dials_core/__init__.py


 *******************************************************************************


 *******************************************************************************
rstbx/dials_core/integration_core.py
from __future__ import absolute_import, division, print_function
from six.moves import range
from cctbx.array_family import flex
from scitbx import matrix

def show_observations(obs,out=None, n_bins=12):
  if out==None:
    import sys
    out = sys.stdout
  from libtbx.str_utils import format_value

  if n_bins is not None: # if None, assume binner already set up
    obs.setup_binner(n_bins = n_bins)
  result = []
  counts_given = obs.binner().counts_given()
  counts_complete = obs.binner().counts_complete()
  for i_bin in obs.binner().range_used():
    sel_w = obs.binner().selection(i_bin)
    sel_fo_all = obs.select(sel_w)
    d_max_,d_min_ = sel_fo_all.d_max_min()
    d_range = obs.binner().bin_legend(
      i_bin=i_bin, show_bin_number=False, show_counts=True)
    sel_data = obs.select(sel_w).data()
    sel_sig = obs.select(sel_w).sigmas()

    if(sel_data.size() > 0):
      bin = resolution_bin(
        i_bin        = i_bin,
        d_range      = d_range,
        mean_I       = flex.mean(sel_data),
        n_work       = sel_data.size(),
        mean_I_sigI  = flex.mean(sel_data/sel_sig),
        d_max_min    = (d_max_, d_min_),
        completeness = (counts_given[i_bin], counts_complete[i_bin]))
      result.append(bin)
  print("\n Bin  Resolution Range  Compl.         <I>     <I/sig(I)>", file=out)
  for bin in result:
    fmt = " %s %s    %s  %s"
    print(fmt%(
      format_value("%3d",   bin.i_bin),
      format_value("%-17s", bin.d_range),
      format_value("%8.1f", bin.mean_I),
      format_value("%8.1f", bin.mean_I_sigI),
      ), file=out)
  return result

class resolution_bin(object):
  def __init__(self,
               i_bin         = None,
               d_range       = None,
               completeness  = None,
               alpha_work    = None,
               beta_work     = None,
               mean_I        = None,
               mean_I_sigI   = None,
               target_work   = None,
               target_free   = None,
               n_work        = None,
               n_free        = None,
               mean_f_obs    = None,
               fom_work      = None,
               scale_k1_work = None,
               pher_work     = None,
               pher_free     = None,
               sigmaa        = None,
               d_max_min     = None):
    from libtbx import adopt_init_args
    adopt_init_args(self, locals())

from rstbx.apps import simple_integration
class integration_core(simple_integration):
  def __init__(self): simple_integration.__init__(self)
  """Integration concept.  Focus on each predicted spot position S.
     I(S): the integration mask for S is constructed by superimposing the
           bodypixels of the 10 nearest spotfinder spots; thus getting
           the maximum envelope.
     B(S): the background mask for S is obtained by finding an equal number
           of pixels as are in I(S).  Choose the nearest pixels to I(S)
           that are not within an exclusion distance (guard=3 pixels).
     P(S): A positional correction for I(S)--adjust the position of the mask
           away from the predicted position, before integrating.  This is constructed
           by considering the 10 closest tuples of (spotfinder spot,prediction).
           P(S) is the average positional offset for this set of 10.
     O(S): The set of spots close enough to S that they must be included
           in calculating where B(S) can be sampled.
  """

### NKS TO do list
# 1) account for spots that lie partially on inactive areas yet interfere with
#    the background of good spots
# 2) account for dead pixels (==-2) on the Pilatus

  def integration_masks_as_xy_tuples(self):
    values = []
    for imsk in range(len(self.BSmasks)):
      smask_keys = self.get_ISmask(imsk)
      for ks in range(0,len(smask_keys),2):
        values.append((smask_keys[ks],smask_keys[ks+1]))
    return values

  def background_masks_as_xy_tuples(self):
    values = []
    for imsk in range(len(self.BSmasks)):
      bmask = self.BSmasks[imsk]
      for key in bmask.keys():
        values.append((key[0],key[1]))
    return values

  def user_callback(self,dc,wxpanel,wx):
    # arguments are a wx Device Context, an Xray Frame, and the wx Module itself
    # BLUE: predictions
    for ix,pred in enumerate(self.predicted):
        if self.BSmasks[ix].keys()==[]:continue
        x,y = wxpanel._img.image_coords_as_screen_coords(
          pred[1]/self.pixel_size,
          pred[0]/self.pixel_size)
        dc.SetPen(wx.Pen('blue'))
        dc.SetBrush(wx.BLUE_BRUSH)
        dc.DrawCircle(x,y,1)

    for imsk in range(len(self.BSmasks)):
      smask_keys = self.get_ISmask(imsk)
      bmask = self.BSmasks[imsk]
      if len(bmask.keys())==0: continue

      # CYAN: integration mask
      for ks in range(0,len(smask_keys),2):
        x,y = wxpanel._img.image_coords_as_screen_coords(smask_keys[ks+1],
                                                         smask_keys[ks])
        dc.SetPen(wx.Pen('cyan'))
        dc.SetBrush(wx.CYAN_BRUSH)
        dc.DrawCircle(x,y,2)

      # YELLOW: background mask
      for key in bmask.keys():
        x,y = wxpanel._img.image_coords_as_screen_coords(key[1],key[0])
        dc.SetPen(wx.Pen('yellow'))
        dc.SetBrush(wx.CYAN_BRUSH)
        dc.DrawCircle(x,y,2)

    for spot in self.spotfinder.images[self.frame_numbers[self.image_number]]["inlier_spots"]:
      # RED: spotfinder spot pixels
      for pxl in spot.bodypixels:
        x,y = wxpanel._img.image_coords_as_screen_coords(
          pxl.y,
          pxl.x)
        dc.SetPen(wx.Pen('red'))
        dc.SetBrush(wx.RED_BRUSH)
        dc.DrawCircle(x,y,1)

      # GREEN: spotfinder centers of mass
      x,y = wxpanel._img.image_coords_as_screen_coords(
        spot.ctr_mass_y(),
        spot.ctr_mass_x())
      dc.SetPen(wx.Pen('green'))
      dc.SetBrush(wx.GREEN_BRUSH)
      dc.DrawCircle(x,y,1)

  def user_callback1(self,dc,wxpanel,wx):
    x,y = wxpanel._img.image_coords_as_screen_coords(100,100)
    dc.SetPen(wx.Pen('green'))
    dc.SetBrush(wx.GREEN_BRUSH)
    dc.DrawCircle(x,y,10)

  def initialize_increments(self,image_number=0):
    #initialize a data structure that contains possible vectors
    # background_pixel - spot_center
    # consider a large box 4x as large as the presumptive mask.
    from scitbx.array_family import flex
    Incr = []
    Distsq = flex.double()
    self.sorted = [] # a generic list of points close in distance to a central point
    if self.mask_focus[image_number] == None: return
    for i in range(-self.mask_focus[image_number][0],1+self.mask_focus[image_number][0]):
      for j in range(-self.mask_focus[image_number][1],1+self.mask_focus[image_number][1]):
        Incr.append(matrix.col((i,j)))
        Distsq.append(i*i+j*j)
    order = flex.sort_permutation(Distsq)
    for i in range(len(order)):
      #print i,order[i],Distsq[order[i]],Incr[order[i]]
      self.sorted.append(Incr[order[i]])



 *******************************************************************************


 *******************************************************************************
rstbx/diffraction/__init__.py
from __future__ import absolute_import, division, print_function
from cctbx.array_family import flex # import dependency

import boost_adaptbx.boost.python as bp
ext = bp.import_ext("rstbx_ext")
from rstbx_ext import *


 *******************************************************************************


 *******************************************************************************
rstbx/diffraction/fastbragg/__init__.py
from __future__ import absolute_import, division, print_function
import boost_adaptbx.boost.python as bp
ext = bp.import_ext("rstbx_diffraction_fastbragg_ext")
from rstbx_diffraction_fastbragg_ext import *

@bp.inject_into(ext.detector)
class _():

  def show(self):
    print("Detector with %d x %d square pixels each with %5.3f mm edge"%(
       self.raw.focus()[0],self.raw.focus()[1],self.pixel_sz*1000.))

class standard_camera(camera):

  # Derived class; assumes camera is perpendicular to beam with
  # beam exactly hitting the center.
  def __init__(self,detector,mean_xtd_distance_m,mean_xray_wavelength_m):
    camera.__init__(self)
    self.distance = mean_xtd_distance_m
    self.lambda0 = mean_xray_wavelength_m
    self.Ybeam = detector.raw.focus()[0] * detector.pixel_sz/2.
    self.Zbeam = detector.raw.focus()[1] * detector.pixel_sz/2.

  def corner_resolution(self):
    import math
    corner_distance = self.Ybeam*math.sqrt(2.) # again, assumes a square
    theta = math.atan2(corner_distance,self.distance)/2.0;
    return self.lambda0/(2.0 * math.sin(theta));

  def show(self):
    import math
    print("Camera at sample distance %5.3f mm, wavelength %5.3f Angstroms"%(
    self.distance*1000.,self.lambda0*1.E10))

    assert self.Ybeam==self.Zbeam # everything assumes the detector is square.

    edge_distance = self.Ybeam
    theta = math.atan2(edge_distance,self.distance)/2.0;
    resolution = 1.E10*self.lambda0/(2.0 * math.sin(theta));
    print("The detector edge is at %5.3f Angstroms,"%resolution)

    print("   and the corner is at %5.3f Angstroms."%(self.corner_resolution()*1.E10))

class crystal_structure(crystal):

  def __init__(self,standard_camera,pdb_code=None,pdb_file=None):
    self.limiting_resolution = 1.E10*standard_camera.corner_resolution() # in Angstroms
    self.pdb_code = pdb_code
    from iotbx import pdb
    if pdb_file != None:
      pdb_inp = pdb.input(file_name = pdb_file)
    elif pdb_code != None:
      import iotbx.pdb.fetch
      pdb_url = iotbx.pdb.fetch.fetch(id=pdb_code)
      pdb_inp = pdb.input(source_info=None,lines=pdb_url.readlines())
    self.xray_structure = pdb_inp.xray_structure_simple()
    primitive_xray_structure = self.xray_structure.primitive_setting()
    self.P1_primitive_xray_structure = primitive_xray_structure.expand_to_p1()

  def p1_amplitudes(self,resolution,algorithm="fft"):
    fcalc = self.P1_primitive_xray_structure.structure_factors(
      d_min=resolution, anomalous_flag=True, algorithm=algorithm).f_calc()
    return fcalc.amplitudes()

  def p1_intensities(self):
    return self.p1_amplitudes(resolution=self.limiting_resolution
           ).as_intensity_array()

  def cell(self):
    return self.xray_structure.unit_cell()

  def symmetry(self):
    return self.xray_structure.crystal_symmetry()

  def p1_cell(self):
    return self.P1_primitive_xray_structure.unit_cell()

  def show(self):
    print("Structure with primitive unit cell %s diffracting out to %4.2f Angstrom"%(
      self.p1_cell(),self.limiting_resolution))


 *******************************************************************************


 *******************************************************************************
rstbx/diffraction/fastbragg/tst_bragg_minimal.py
from __future__ import absolute_import, division, print_function
from scitbx.array_family import flex
from scitbx.matrix import sqr
from rstbx.diffraction.fastbragg import foo
from rstbx.diffraction.fastbragg import detector,camera,crystal
from rstbx.diffraction.fastbragg import fast_bragg_simulation
import libtbx.load_env

pdb_lines = """HEADER    ELECTRON TRANSPORT                      17-JAN-08   3BZ1
CRYST1  127.692  225.403  306.106  90.00  90.00  90.00 P 21 21 21    4
ATOM    100  CH2 TRP A  20      56.430  40.246  32.394  1.00 81.85           C
ATOM    200  N   PHE A  33      53.226  47.627  40.654  1.00 70.99           N
ATOM    300  CD1 ILE A  46      45.639  29.364  40.352  1.00 64.65           C
ATOM    400  CB  ILE A  60      31.998  29.624  61.196  1.00 48.31           C
ATOM    500  CZ  TYR A  73      33.394  17.375  51.997  1.00 59.10           C
ATOM    600  N   ILE A  89      40.139  30.719  66.768  1.00 57.41           N
ATOM    700  CB  ALA A 100      48.660  18.955  63.036  1.00 50.19           C
ATOM    800  OH  TYR A 112      35.813  37.284  55.881  1.00 49.58           O
ATOM    900  O   CYS A 125      47.637  48.097  42.161  1.00 69.98           O
ATOM   1000  CB  ARG A 136      53.053  54.518  31.934  1.00 62.41           C
ATOM   1100  O   SER A 148      38.270  53.004  48.759  1.00 59.64           O
ATOM   1200  OH  TYR A 161      29.848  43.600  64.133  1.00 51.65           O
ATOM   1300  CG1 ILE A 176      25.474  34.051  46.196  1.00 49.30           C
ATOM   1400  C   GLU A 189      24.280  45.586  66.763  1.00 54.83           C
ATOM   1500  CB  LEU A 200      25.906  59.092  53.794  1.00 57.65           C
ATOM   1600  CD2 HIS A 215      26.386  60.725  30.820  1.00 66.14           C
ATOM   1700  O   GLU A 229      15.446  53.147  11.386  1.00 94.97           O
ATOM   1800  OE1 GLN A 241      31.691  60.361  15.701  1.00 85.33           O
ATOM   1900  CG  TYR A 254      14.970  67.624  27.886  1.00 80.00           C
ATOM   2000  CE1 PHE A 265      26.289  68.506  37.590  1.00 88.41           C
ATOM   2100  N   TRP A 278      29.660  62.229  43.659  1.00 63.59           N
ATOM   2200  CG1 ILE A 290      29.934  48.592  56.874  1.00 56.42           C
ATOM   2300  C   ASN A 303      13.257  53.636  73.305  1.00 53.67           C
ATOM   2400  CG2 THR A 316       7.855  57.090  68.127  1.00 58.80           C
ATOM   2500  CB  GLU A 329      19.451  40.098  69.217  1.00 49.38           C
ATOM   2600  CA  LEU A 341      25.291  40.222  77.420  1.00 58.62           C
ATOM   2700  CD2 HIS B   9      10.231  39.622  13.536  1.00 61.64           C
ATOM   2800  O   HIS B  23      -1.741  36.161  13.565  1.00 73.51           O
ATOM   2900  C   MET B  37      -3.628  21.765  27.157  1.00 60.16           C
ATOM   3000  N   PRO B  50     -14.550  15.131  42.592  1.00 59.82           N
ATOM   3100  CE2 PHE B  61      -3.211  29.588  31.858  1.00 36.72           C
ATOM   3200  CG  TRP B  75     -15.698  12.830  23.209  1.00 67.94           C
ATOM   3300  CD  PRO B  88     -20.869  13.773  26.882  1.00 88.90           C
ATOM   3400  CG1 ILE B 101      -4.955  20.401  18.664  1.00 55.70           C
ATOM   3500  CD2 HIS B 114      -3.854  35.717   4.227  1.00 76.12           C
ATOM   3600  CD  ARG B 124       1.132  49.272  -3.409  1.00 75.98           C
ATOM   3700  CD  LYS B 137     -13.446  52.508   4.977  1.00 81.73           C
ATOM   3800  CB  CYS B 150     -19.609  42.068  22.286  1.00 71.10           C
ATOM   3900  N   PRO B 164     -25.221  27.178  25.947  1.00 78.19           N
ATOM   4000  CB  SER B 177     -24.093  23.363  37.543  1.00 69.60           C
ATOM   4100  CZ  PHE B 190     -23.890  49.302  34.563  1.00 82.38           C
ATOM   4200  C   ALA B 204     -24.194  46.989  25.481  1.00 68.99           C
ATOM   4300  CD2 LEU B 218     -21.126  54.934   7.329  1.00 70.45           C
ATOM   4400  CG  ARG B 230       2.163  61.215  14.361  1.00 77.19           C
ATOM   4500  CB  ALA B 244      -6.668  48.852  25.158  1.00 60.23           C
ATOM   4600  CZ2 TRP B 257      -3.347  36.591  46.798  1.00 52.77           C
ATOM   4700  C   THR B 271      -8.867  33.510  49.162  1.00 53.31           C
ATOM   4800  CD  GLN B 281     -13.383  29.920  62.401  1.00 67.13           C
ATOM   4900  CA  SER B 294     -33.026  21.366  66.399  1.00 69.25           C
ATOM   5000  OE2 GLU B 307     -14.800  13.540  54.306  1.00 68.45           O
ATOM   5100  CD  PRO B 319      -5.922  31.146  48.057  1.00 47.82           C
ATOM   5200  N   ASP B 334       0.902  19.258  50.198  1.00 44.55           N
ATOM   5300  CA  ARG B 347     -10.219  20.652  76.188  1.00 61.50           C
ATOM   5400  CG  ARG B 358      -7.285  29.120  62.704  1.00 50.92           C
ATOM   5500  CB  LEU B 370      -4.691  26.163  73.320  1.00 50.59           C
ATOM   5600  CE2 PHE B 383      13.890  27.916  70.647  1.00 33.21           C
ATOM   5700  N   GLN B 395      -1.283  20.760  81.492  1.00 56.45           N
ATOM   5800  N   GLN B 409     -14.069   9.629  68.475  1.00 59.62           N
ATOM   5900  O   ALA B 421      -2.576  22.480  66.140  1.00 57.75           O
ATOM   6000  C   ASP B 433      -0.960  11.201  49.784  1.00 55.09           C
ATOM   6100  N   SER B 446      -2.763  27.862  44.195  1.00 50.25           N
ATOM   6200  C   PHE B 458       2.089  42.286  31.803  1.00 53.50           C
ATOM   6300  CA  HIS B 469       5.917  52.473  21.275  1.00 65.93           C
ATOM   6400  C   GLY B 481      18.369  63.066  15.911  1.00 86.80           C
ATOM   6500  C   GLU C  29      42.829  84.391  42.151  1.00 96.99           C
ATOM   6600  N   LEU C  42      49.063  79.537  47.972  1.00 80.65           N
ATOM   6700  C   HIS C  56      47.160  76.079  63.881  1.00 75.29           C
ATOM   6800  CD1 LEU C  69      40.241  76.971  80.264  1.00 73.46           C
ATOM   6900  CB  MET C  81      37.685  59.675  83.702  1.00 66.57           C
ATOM   7000  N   THR C  94      47.149  59.964  83.079  1.00 72.30           N
ATOM   7100  CG2 THR C 108      39.735  68.134  90.385  1.00 84.58           C
ATOM   7200  CA  SER C 121      49.614  80.118  74.233  1.00 71.01           C
ATOM   7300  CB  ARG C 135      50.883  92.723  59.014  1.00 88.70           C
ATOM   7400  CA  GLY C 148      62.945  81.923  53.170  1.00 86.41           C
ATOM   7500  OG1 THR C 159      69.683  71.849  55.898  1.00 76.62           O
ATOM   7600  CG  LEU C 173      64.970  62.992  74.939  1.00 75.86           C
ATOM   7700  CE2 TYR C 186      46.358  53.614  86.921  1.00 54.85           C
ATOM   7800  O   THR C 200      65.438  52.726  87.800  1.00 81.03           O
ATOM   7900  CZ  TYR C 212      57.265  45.691  74.323  1.00 64.32           C
ATOM   8000  CG2 VAL C 225      48.991  48.489  68.817  1.00 54.23           C
ATOM   8100  CG  TRP C 239      66.638  53.123  72.325  1.00 79.64           C
ATOM   8200  CB  ILE C 252      71.570  69.941  60.611  1.00 88.29           C
ATOM   8300  CD1 PHE C 264      60.724  60.118  48.299  1.00 79.04           C
ATOM   8400  CG  LEU C 276      48.684  64.549  53.259  1.00 64.89           C
ATOM   8500  CG2 VAL C 290      41.832  54.897  72.981  1.00 57.48           C
ATOM   8600  CZ  PHE C 301      44.591  57.265  86.195  1.00 70.05           C
ATOM   8700  C   THR C 316      30.583  36.329  87.074  1.00 59.01           C
ATOM   8800  CG2 VAL C 328      35.267  26.607  88.411  1.00 63.86           C
ATOM   8900  CB  ARG C 343      41.831  23.983  76.148  1.00 51.02           C
ATOM   9000  CA  ARG C 357      38.290  34.957  71.104  1.00 61.60           C
ATOM   9100  C   GLU C 367      46.540  37.293  87.483  1.00 64.97           C
ATOM   9200  O   ILE C 380      37.697  30.576  92.067  1.00 67.63           O
ATOM   9300  O   ARG C 391      35.039  45.120  86.966  1.00 60.78           O
ATOM   9400  CD1 LEU C 404      27.268  58.766  66.001  1.00 57.48           C
ATOM   9500  CB  PHE C 419      27.493  55.491  79.223  1.00 67.79           C
ATOM   9600  CD1 PHE C 431      40.201  52.507  60.945  1.00 57.40           C
ATOM   9700  CG  TRP C 443      43.756  64.474  45.968  1.00 75.60           C
ATOM   9800  CA  LYS C 457      46.056  69.932  33.682  1.00 75.97           C
ATOM   9900  CG  PRO C 470      53.283  49.954  20.292  1.00 81.53           C
ATOM  10000  CG  TRP D  21      -0.801  81.734  29.348  1.00 77.02           C
ATOM  10100  CB  TRP D  32      -0.735  70.313  28.373  1.00 71.40           C
ATOM  10200  C   LEU D  45       3.971  67.431  50.438  1.00 56.33           C
ATOM  10300  NE1 TRP D  58      -3.948  56.069  71.824  1.00 63.14           N
ATOM  10400  O   CYS D  71       9.769  64.233  65.991  1.00 66.26           O
ATOM  10500  CG  MET D  85      -9.271  51.951  57.279  1.00 61.82           C
ATOM  10600  CD  GLN D  98     -20.334  58.870  58.371  1.00 79.48           C
ATOM  10700  O   TRP D 111      -1.668  57.883  50.989  1.00 55.61           O
ATOM  10800  N   GLY D 124       1.991  62.768  35.633  1.00 65.92           N
ATOM  10900  CG  LEU D 135       7.056  71.817  23.809  1.00 70.97           C
ATOM  11000  CA  PRO D 149      10.850  54.606  39.091  1.00 55.93           C
ATOM  11100  CB  PRO D 161      -0.735  47.345  49.987  1.00 48.29           C
ATOM  11200  CZ  PHE D 173       3.153  56.984  49.943  1.00 50.71           C
ATOM  11300  CZ  PHE D 185       7.181  43.691  50.494  1.00 37.45           C
ATOM  11400  C   HIS D 197      17.164  41.521  43.801  1.00 50.10           C
ATOM  11500  CA  ILE D 213      33.634  55.063  37.092  1.00 69.26           C
ATOM  11600  N   GLY D 226      43.193  75.028  28.981  1.00 80.84           N
ATOM  11700  CG  GLN D 239      28.634  70.306  20.768  1.00 96.48           C
ATOM  11800  C   PHE D 252      42.989  51.474  30.264  1.00 69.10           C
ATOM  11900  CA  LYS D 264      30.303  56.876  23.582  1.00 65.51           C
ATOM  12000  N   VAL D 274      21.376  49.633  32.352  1.00 59.67           N
ATOM  12100  CA  GLY D 288       5.063  38.350  43.091  1.00 51.26           C
ATOM  12200  CB  SER D 300      17.107  20.052  47.341  1.00 49.18           C
ATOM  12300  OE1 GLU D 312      25.457  24.792  61.967  1.00 56.19           O
ATOM  12400  O   GLY D 324      11.625  37.142  65.784  1.00 50.64           O
ATOM  12500  CE1 HIS D 336      -2.635  43.943  61.172  1.00 62.69           C
ATOM  12600  CG  ARG D 348      13.912  33.212  72.962  1.00 50.25           C
ATOM  12700  CA  ASP E  12      18.164  91.898  42.777  1.00 89.88           C
ATOM  12800  CG  HIS E  23       9.724  89.213  52.411  1.00 85.44           C
ATOM  12900  CB  LEU E  36      -0.117  81.291  67.900  1.00 70.26           C
ATOM  13000  CG2 THR E  49      -1.179  64.296  67.834  1.00 61.18           C
ATOM  13100  CB  ARG E  61      -2.323  49.122  79.882  1.00 88.20           C
ATOM  13200  CD  LYS E  73     -17.743  60.195  61.429  1.00 74.64           C
ATOM  13300  N   VAL F  11      15.993  96.516  32.978  1.00 95.73           N
ATOM  13400  O   ALA F  22       5.710  78.633  45.555  1.00 73.32           O
ATOM  13500  C   GLY F  35       6.641  77.242  64.377  1.00 67.22           C
ATOM  13600  CA  ARG H   4      -6.132  42.027  -7.866  1.00 90.52           C
ATOM  13700  ND2 ASN H  15      -6.361  49.254   1.776  1.00 81.21           N
ATOM  13800  CA  LEU H  30     -18.790  65.525  21.049  1.00 73.95           C
ATOM  13900  CG  LEU H  42     -14.264  53.453  33.427  1.00 79.57           C
ATOM  14000  CD1 ILE H  54     -20.487  50.335  50.523  1.00 68.77           C
ATOM  14100  CA  GLU I   2      58.092  23.554  57.876  1.00 71.08           C
ATOM  14200  CG  PHE I  14      61.361  36.617  43.358  1.00 66.86           C
ATOM  14300  C   GLY I  26      62.908  55.772  38.054  1.00 78.38           C
ATOM  14400  O   PRO J   9      24.648  91.273  51.531  1.00 78.21           O
ATOM  14500  CB  VAL J  23      19.540  80.157  65.363  1.00 69.47           C
ATOM  14600  CD1 LEU J  36       5.079  66.010  73.040  1.00 74.63           C
ATOM  14700  CE2 PHE K  18      34.702  85.604  85.570  1.00 81.28           C
ATOM  14800  CA  PHE K  32      37.105  79.841  61.828  1.00 68.56           C
ATOM  14900  C   PHE K  45      35.499  84.515  44.358  1.00 84.69           C
ATOM  15000  CB  VAL L  10      19.568  40.277  10.480  1.00 81.89           C
ATOM  15100  N   LEU L  23      25.370  37.709  29.295  1.00 48.48           N
ATOM  15200  CG  PHE L  35      15.700  26.715  36.587  1.00 57.45           C
ATOM  15300  CB  ALA M  10      14.779  24.043  33.437  1.00 50.93           C
ATOM  15400  CD1 ILE M  23      27.117  29.969  19.939  1.00 68.61           C
ATOM  15500  OG1 THR O  30      59.852  28.238  88.273  1.00 86.55           O
ATOM  15600  CB  LYS O  44      52.660  18.801  77.543  1.00 63.87           C
ATOM  15700  CG2 ILE O  58      49.231   3.465 101.214  1.00 92.18           C
ATOM  15800  CA  LEU O  71      45.849  12.711  81.045  1.00 67.23           C
ATOM  15900  CE  LYS O  83      29.412  -3.685  52.037  1.00 91.64           C
ATOM  16000  CA  LEU O  96      43.140  15.192  64.970  1.00 64.05           C
ATOM  16100  CD  GLN O 108      40.291  18.746  93.673  1.00 84.07           C
ATOM  16200  C   VAL O 122      38.086  10.051  93.162  1.00 68.13           C
ATOM  16300  CA  GLN O 135      38.800  12.567  60.896  1.00 54.37           C
ATOM  16400  C   VAL O 148      36.165  10.783  83.952  1.00 59.64           C
ATOM  16500  CA  ILE O 162      53.767   2.333  94.433  1.00 84.28           C
ATOM  16600  CG2 VAL O 174      32.148   7.788  78.609  1.00 58.15           C
ATOM  16700  N   GLY O 187      16.598  24.287  64.445  1.00 52.49           N
ATOM  16800  CD  PRO O 201       5.762  22.790  55.974  1.00 49.53           C
ATOM  16900  CG  LYS O 214      16.607  16.684  70.039  1.00 46.98           C
ATOM  17000  CA  VAL O 227      52.726   3.511  85.940  1.00 79.62           C
ATOM  17100  CA  GLU O 242      44.541   3.458  77.560  1.00 70.49           C
ATOM  17200  O   GLU O 255      26.874   6.548  65.762  1.00 58.69           O
ATOM  17300  CA  ALA O 267      49.743  12.180  89.104  1.00 75.32           C
ATOM  17400  CA  PHE T   8      30.107  24.156  33.778  1.00 58.16           C
ATOM  17500  CE2 PHE T  19      37.073  30.806  23.807  1.00 66.58           C
ATOM  17600  O   LYS T  31      38.930  53.026   9.904  1.00104.23           O
ATOM  17700  O   GLY U  48       2.470  14.492  84.844  1.00 53.19           O
ATOM  17800  OD1 ASN U  61      17.430  27.269  88.022  1.00 64.67           O
ATOM  17900  CG  PRO U  73      20.509  34.023  98.785  1.00 68.36           C
ATOM  18000  CG  GLU U  86      13.983   7.114  98.623  1.00 75.48           C
ATOM  18100  N   ARG U 100      16.728  26.887 112.613  1.00 79.81           N
ATOM  18200  CA  HIS U 111       5.985  23.384  97.418  1.00 66.26           C
ATOM  18300  OE1 GLU U 123      25.495  13.972  83.507  1.00 74.96           O
ATOM  18400  O   GLU V  28      -1.415  59.687  86.032  1.00 69.71           O
ATOM  18500  N   GLY V  42       1.728  48.438 106.910  1.00 77.83           N
ATOM  18600  O   GLU V  54      16.395  61.529  91.352  1.00 67.27           O
ATOM  18700  C   HIS V  67      18.618  48.373  86.041  1.00 51.86           C
ATOM  18800  CA  ARG V  81       9.654  43.737  90.640  1.00 59.19           C
ATOM  18900  CA  ASN V  94       8.577  49.578 100.936  1.00 64.63           C
ATOM  19000  OG1 THR V 106      19.762  41.352 102.868  1.00 66.61           O
ATOM  19100  CA  PRO V 119      27.043  49.726  96.368  1.00 53.71           C
ATOM  19200  NE  ARG V 131      34.037  57.790  98.066  1.00 77.69           N
ATOM  19300  N   ILE V 145      11.653  52.943  92.598  1.00 57.53           N
ATOM  19400  CA  GLY V 157      10.349  43.420  85.728  1.00 62.22           C
ATOM  19500  C   ILE y  25      27.680  83.976  70.831  1.00 93.60           C
ATOM  19600  C   LEU y  39      36.215  96.397  55.160  1.00 88.39           C
ATOM  19700  C   LYS X  17     -23.484  62.051  48.307  1.00 73.05           C
ATOM  19800  C   GLY X  31     -12.949  75.783  36.869  1.00 78.68           C
ATOM  19900  N   LYS X  45       0.108  87.147  24.605  1.00 94.37           N
ATOM  20000  CB  UNK Y  15      -2.576  94.042  54.728  1.00100.98           C
ATOM  20100  C   PHE Z   5      40.041  89.364  89.872  1.00 91.94           C
ATOM  20200  O   VAL Z  18      39.978  94.277  69.809  1.00 76.44           O
ATOM  20300  CB  ASP Z  32      47.282 103.853  60.501  1.00100.60           C
ATOM  20400  N   SER Z  44      48.888  94.580  73.401  1.00 86.76           N
ATOM  20500  CD2 LEU Z  57      44.301  89.773  91.041  1.00 78.59           C
HETATM20600  C2  CLA A 362      31.764  47.668  47.431  1.00 60.44           C
HETATM20700  NB  CLA A 363      29.710  41.445  46.930  1.00 45.58           N
HETATM20800  C7  CLA D 364      16.133  64.229  46.053  1.00 76.65           C
HETATM20900  CBB PHO D 355      14.716  56.516  46.747  1.00 56.43           C
HETATM21000  C14 CLA A 366      66.544  40.085  54.813  1.00 90.68           C
HETATM21100  C4C CLA B 511     -26.404  52.016  32.721  1.00 96.16           C
HETATM21200  C19 CLA B 512      -3.098  50.381  41.085  1.00 83.96           C
HETATM21300  C1D CLA B 514      -5.234  38.699  29.202  1.00 71.34           C
HETATM21400  CHC CLA B 516     -20.209  32.957  21.111  1.00 89.96           C
HETATM21500  CAD CLA B 517       2.554  21.339  34.550  1.00 55.30           C
HETATM21600  C3A CLA B 519     -10.472  56.508  18.414  1.00 84.57           C
HETATM21700  O2D CLA B 520     -10.650  46.894  16.518  1.00 72.71           O
HETATM21800  CGA CLA B 522      -3.932  39.345  15.732  1.00 83.81           C
HETATM21900  C4  CLA B 523       8.852  43.002  22.934  1.00 70.48           C
HETATM22000  C2B CLA B 525     -14.006  41.766   8.133  1.00 97.68           C
HETATM22100  C9  CLA B 526     -11.824  25.329  -0.631  1.00106.01           C
HETATM22200  CBB CLA C 475      39.928  67.338  64.645  1.00 59.03           C
HETATM22300  C14 CLA C 476      50.357  62.165  64.457  1.00 87.49           C
HETATM22400  C4C CLA C 478      53.106  55.767  51.571  1.00 72.93           C
HETATM22500  C19 CLA C 479      59.949  48.251  61.645  1.00100.03           C
HETATM22600  C1D CLA C 481      42.030  67.462  48.801  1.00 85.05           C
HETATM22700  CHC CLA C 483      44.314  69.269  63.901  1.00 50.61           C
HETATM22800  CAD CLA C 484      43.342  83.454  49.029  1.00 82.21           C
HETATM22900  C3A CLA C 486      61.049  84.971  60.287  1.00 97.06           C
HETATM23000 FE   HEM V 164      21.702  46.175  93.090  1.00 67.31          FE
HETATM23100  C4  PL9 A 367      23.534  65.392  32.049  1.00 87.59           C
HETATM23200  C14 BCR A 369      49.813  31.115  42.316  1.00 69.53           C
HETATM23300  C38 BCR B 528       4.937  19.657  26.930  1.00 79.68           C
HETATM23400  C14 BCR H 107     -21.140  55.848  30.373  1.00 89.39           C
HETATM23500  C38 BCR K 112      25.295  79.179  53.876  1.00 74.98           C
HETATM23600  C14 BCR Z 116      52.931  81.451  77.107  1.00 77.87           C
HETATM23700  C3D DGD A 370      53.637  32.456  61.804  1.00 85.34           C
HETATM23800  C28 LHG A 371      35.937  62.504  44.119  1.00 65.86           C
HETATM23900  C3G DGD C 490      27.108  67.075  73.164  1.00 77.16           C
HETATM24000  C6  LMG D 359       9.071  67.359  68.690  1.00 71.69           C
HETATM24100  C4  LMG B 531      19.088  52.863  20.315  1.00 79.55           C
HETATM24200  C4  LMG D 360      31.370  49.703  21.577  1.00 74.79           C
HETATM24300  O47 SQD T 213      39.292  32.149  16.094  1.00 89.97           O
HETATM24400  C5  LMG B 534      -5.220   3.042  32.449  1.00 88.99           C
HETATM24500  C16 LMG M 217      31.439  29.591  17.567  1.00 80.15           C
HETATM24600  C32 LMG C 492      29.124  71.911  68.040  1.00 81.16           C
HETATM24700  C1  LHG A 374      26.048  76.110  36.215  1.00 94.79           C
HETATM24800  C13 SQD F 224      -4.639  79.397  39.277  1.00 94.00           C
HETATM24900  C5B LMT M 226      18.726  10.738  43.575  1.00 89.50           C
HETATM25000  C12 LMT B 535     -16.566  32.829  12.754  1.00 71.46           C
HETATM25100  C11 LMT B 536     -11.459  65.368  27.690  1.00 83.60           C
"""

def amplitudes_from_pdb(resolution,algorithm=None,anomalous=False):
  from iotbx import pdb
  pdb_inp = pdb.input(source_info=None,lines = pdb_lines)
  xray_structure = pdb_inp.xray_structure_simple()
  primitive_xray_structure = xray_structure.primitive_setting()
  P1_primitive_xray_structure = primitive_xray_structure.expand_to_p1()
  fcalc = P1_primitive_xray_structure.structure_factors(
    d_min=resolution, anomalous_flag=anomalous, algorithm=algorithm).f_calc()
  return fcalc.amplitudes()

def tst_all():
  F = foo()
  assert F == (1,2,3,4)

  size=1516
  D = detector(slowpixels=1516,fastpixels=1516,pixel_size=0.00011)
  D.set_region_of_interest(0,int(0.6*size),int(0.4*size),int(0.6*size))
  D.set_oversampling(1)

  C = camera()
  C.distance = 0.18166
  C.Ybeam = 0.08338
  C.Zbeam = 0.08338
  C.lambda0 = 6.2E-10
  C.dispersion = 0.002
  C.dispsteps = 4
  C.hdivrange = 0
  C.vdivrange = 0
  C.hdivstep = 1
  C.vdivstep = 1
  C.source_distance = 10.
  C.fluence = 1.E24

  Amat = sqr((127.6895065259495, 0.6512077339887,-0.4403031342553,
               -1.1449112128916,225.3922539826207,1.8393136632579,
               1.0680694468752,-2.4923062985132,306.0953037195841))

  PSII = amplitudes_from_pdb(8.,"fft",True)

  from cctbx import crystal_orientation
  X = crystal()
  X.orientation = crystal_orientation.crystal_orientation(
                  Amat,crystal_orientation.basis_type.direct)
  X.miller = PSII.indices()
  X.amplitudes = PSII.data()
  X.Na = 6; X.Nb = 6; X.Nc = 6

  SIM = fast_bragg_simulation()
  SIM.set_detector(D)
  SIM.set_camera(C)
  SIM.set_crystal(X)
  SIM.sweep_over_detector()
  data = D.raw
  scale_factor = 55000./flex.max(data)
  #print "scale_factor",scale_factor
  fileout="intimage_001.img"
  SIM.to_smv_format(fileout=fileout,
                    intfile_scale = scale_factor, saturation=40000)
  import os
  assert os.path.isfile(fileout)
  os.remove(fileout)

  #simulation is complete, now we'll autoindex the image fragment and verify
  # that the indexed cell is similar to the input cell.

  if (not libtbx.env.has_module("annlib")):
    print("Skipping some tests: annlib not available.")
    return
  # 1. Analysis of the image to identify the Bragg peak centers.
  #    This step uses an inefficient algorithm and implementation and
  #    is most time consuming; but the code is only for testing, not production
  from rstbx.diffraction.fastbragg.tst_utils_clustering import specific_libann_cluster
  M=specific_libann_cluster(scale_factor*data,intensity_cutoff = 25,distance_cutoff=17)
  # M is a dictionary of peak intensities indexed by pixel coordinates

  # 2. Now autoindex the pattern
  from rstbx.diffraction.fastbragg.tst_utils_clustering import index_wrapper
  SIM.C = C
  SIM.D = D
  ai,ref_uc = index_wrapper(M.keys(), SIM, PSII)
  tst_uc = ai.getOrientation().unit_cell()
  #print ref_uc  # (127.692, 225.403, 306.106, 90, 90, 90)
  #print tst_uc  # (106.432, 223.983, 303.102, 90.3185, 91.5998, 90.5231)

  # 3. Final assertion.  In the given orientation,
  #  the unit cell A vector is into the beam and is not well sampled,
  #  so tolerances have to be fairly relaxed, 5%.
  #  Labelit does better with the target_cell restraint, but this improved
  #  algorithm is not used here for the test
  assert ref_uc.is_similar_to(tst_uc, relative_length_tolerance=0.20,
                                     absolute_angle_tolerance= 2.0)


if __name__=="__main__":
  tst_all()
  print("OK")


 *******************************************************************************


 *******************************************************************************
rstbx/diffraction/fastbragg/tst_utils_clustering.py
from __future__ import absolute_import, division, print_function
from six.moves import range
from math import sqrt,pi,sin,atan
from scitbx.array_family import flex
from scitbx.matrix import col,sqr

def specific_libann_cluster(data,intensity_cutoff = 25,distance_cutoff=17):
  from annlib_ext import AnnAdaptor
  #construct a new data structure containing only pixels > intensity_cutoff
  #input data structure is a flex array
  info = {}
  shape = data.accessor().focus()
  for slow in range(shape[0]):
    for fast in range(shape[1]):
      if data[(slow,fast)] > intensity_cutoff:
        info[(slow,fast)] = data[(slow,fast)]

  Ktree = int(distance_cutoff*distance_cutoff*pi)
  Sq_cut = distance_cutoff*distance_cutoff # distance < distance_cutoff => the two points are clustered

  all_pixels = flex.double()
  all_keys = list(info.keys())
  for key in all_keys:
    all_pixels.append(key[0]); all_pixels.append(key[1])

  distance_tree = AnnAdaptor(data=all_pixels,dim=2,k=Ktree)
  distance_tree.query(all_pixels)
  clusters = []
  membership_lookup = {}

  for i_query_pt in range(len(all_keys)):
      query_coords = all_keys[i_query_pt]
      query_ok = True
      for i_target_pt in range(Ktree):
        target_coords = all_keys[distance_tree.nn[Ktree*i_query_pt+i_target_pt]]
        if distance_tree.distances[Ktree*i_query_pt+i_target_pt] < Sq_cut:
          if info[query_coords] < info[target_coords]:
            query_ok = False
            break
      if query_ok:
        membership_lookup[query_coords]=info[query_coords]

  return membership_lookup

def index_wrapper(positions,info,pdb_object):
  from rstbx.dps_core import dps_core
  from rstbx.dps_core.sampling import HemisphereSamplerBase as HemisphereSampler
  from cctbx.uctbx import unit_cell

  uc = pdb_object.unit_cell()

  sampling = get_recommended_sampling(pdb_object, info, positions)

  raw_spot_input = flex.vec3_double()
  pixel_sz = info.D.pixel_sz
  for pos in positions:
    raw_spot_input.append((pos[0]*pixel_sz, pos[1]*pixel_sz, 0.0))

  #convert raw film to camera, using labelit coordinate convention
  camdata = flex.vec3_double()
  auxbeam = col((info.C.Ybeam,info.C.Zbeam,0.0));
  film_2_camera = sqr((-1,0,0,0,-1,0,0,0,1)).inverse();
  for x in range(len(raw_spot_input)):
    camdata.append( auxbeam + film_2_camera * col(raw_spot_input[x]) )

  #convert camera to reciprocal space xyz coordinates
  xyzdata = flex.vec3_double()

  for x in range(len(camdata)):
    cam = col(camdata[x])
    auxpoint = col((cam[0],cam[1],info.C.distance));
    xyz = ( auxpoint / (info.C.lambda0*1E10 * auxpoint.length()) );
    xyz = xyz - col((0.0, 0.0, 1.0/(info.C.lambda0*1E10))); #translate recip. origin

    xyzdata.append( xyz );

  core_ai = dps_core()
  core_ai.setXyzData(xyzdata)
  core_ai.setMaxcell(1.25*max(uc.parameters()[0:3]))

  H = HemisphereSampler(
      characteristic_grid = sampling,
      max_cell=1.25*max(uc.parameters()[0:3]))
  H.hemisphere(core_ai,size=30,cutoff_divisor=4.) # never change these parameters

  from rstbx.dps_core.basis_choice import SelectBasisMetaprocedure as SBM
  M = SBM(core_ai)

  return core_ai,uc

def get_recommended_sampling(pdb_obj,info,spots):
    p1_uc = pdb_obj.unit_cell()
    largest_p1_cell_dimension = max(p1_uc.parameters()[0:3])

    relevant_resolution =  info.C.lambda0*1E10

    pixel_sz = info.D.pixel_sz
    xtd=info.C.distance
    xbeam=info.C.Ybeam
    ybeam=info.C.Zbeam
    resolutions=[]
    for pos in spots:
      x = pos[0]*pixel_sz - xbeam; y = pos[1]*pixel_sz - ybeam
      distance = sqrt(x*x+y*y)
      resolutions.append(
        info.C.lambda0*1E10 /(2.*sin(0.5*atan(distance/xtd)))
        )

    relevant_resolution = min(resolutions)

    recommended_sampling = relevant_resolution / largest_p1_cell_dimension

    recommended_sampling*=0.5  # 1/2 interval makes indexing much more reliable
    return recommended_sampling


 *******************************************************************************


 *******************************************************************************
rstbx/diffraction/tst_ewald_sphere.py
from __future__ import absolute_import, division, print_function
#!/usr/bin/env python
import math

from cctbx.uctbx import unit_cell
from scitbx import matrix
from rstbx.diffraction import rotation_angles, reflection_prediction
from rstbx.bpcx import sensor
from libtbx.test_utils import approx_equal
from six.moves import range

# This script (provided by Graeme Winter) will take the quartz structure and
# simulate a rotation around the 0 0 1 reflection and  1 0 1 reflection.
# If there is a problem then scatter will not be of 1/lambda length. test
# structure will be quartz 5.01, 5.01, 5.47, 90, 90, 120.

def rotation_scattering(reflections, UB_mat, rotation_vector,
                        wavelength, resolution,
                        assert_non_integer_index = False):
    '''Perform some kind of calculation...'''

    ra = rotation_angles(resolution, UB_mat, wavelength, rotation_vector)
    beam_vector = matrix.col([0, 0, 1 / wavelength])

    for hkl in reflections:
        if ra(hkl):
            omegas = ra.get_intersection_angles()
            if assert_non_integer_index:
                assert ra.H[0] != int(ra.H[0]) or \
                       ra.H[1] != int(ra.H[1]) or \
                       ra.H[2] != int(ra.H[2])

            for omegaidx in [0,1]:

                rot_mat = rotation_vector.axis_and_angle_as_r3_rotation_matrix(
                    omegas[omegaidx])
                assert(
                    -0.0001 < math.fabs(rot_mat.determinant() - 1.0) < 0.0001)

                H1 = (rot_mat * UB_mat)*hkl
                H1 =  H1 + beam_vector
                len_H1 = math.sqrt((H1[0] * H1[0]) +
                                   (H1[1] * H1[1]) +
                                   (H1[2] * H1[2]))

                if math.fabs(len_H1 - 1.0 / wavelength) > 0.0001:
                    raise RuntimeError('length error for %d %d %d' % hkl)

def scattering_prediction(reflections, UB_mat, rotation_vector,
                          wavelength, resolution,
                          assert_non_integer_index = False):
    '''Test the reflection_prediction class.'''

    ra = rotation_angles(resolution, UB_mat, wavelength, rotation_vector)
    beam_vector = matrix.col([0, 0, 1 / wavelength])

    detector_size = 100
    detector_distance = 100

    s =  sensor(matrix.col((- 0.5 * detector_size,
                            - 0.5 * detector_size,
                            detector_distance)),
                matrix.col((1, 0, 0)),
                matrix.col((0, 1, 0)),
                (0, detector_size), (0, detector_size))
    rp = reflection_prediction(rotation_vector, beam_vector, UB_mat, s)

    for hkl in reflections:
        if ra(hkl):
            omegas = ra.get_intersection_angles()
            if assert_non_integer_index:
                assert ra.H[0] != int(ra.H[0]) or \
                       ra.H[1] != int(ra.H[1]) or \
                       ra.H[2] != int(ra.H[2])

            for omegaidx in [0,1]:

                rot_mat = rotation_vector.axis_and_angle_as_r3_rotation_matrix(
                    omegas[omegaidx])

                assert(math.fabs(rot_mat.determinant() - 1.0) < 0.0001)

                H1 = (rot_mat * UB_mat)*hkl
                H1 =  H1 + beam_vector
                len_H1 = math.sqrt((H1[0] * H1[0]) +
                                   (H1[1] * H1[1]) +
                                   (H1[2] * H1[2]))

                if math.fabs(len_H1 - 1.0 / wavelength) > 0.0001:
                    raise RuntimeError('length error for %d %d %d' % hkl)

                if rp(hkl, omegas[omegaidx]):
                    x, y = rp.get_prediction()
                    assert(0 < x < detector_size)
                    assert(0 < y < detector_size)

if __name__ == '__main__':

    wavelength = 1.2
    resolution = 1.5

    uc = unit_cell([5.01, 5.01, 5.47, 90.0, 90.0, 120.0])

    bmat = matrix.sqr(uc.orthogonalization_matrix()).inverse().transpose()

    #----------------------------
    # prove that the matrix bmat is consistent with the ewald_sphere class
    # requirements:
    #               / A*x B*x C*x \
    #  Matrix A* =  | A*y B*y C*y |
    #               \ A*z B*z C*z /

    uc_reciprocal = uc.reciprocal()
    astar,bstar,cstar,alphastar,betastar,gammastar = uc_reciprocal.parameters()
    astar_vec = matrix.col([bmat[0],bmat[3],bmat[6]])
    bstar_vec = matrix.col([bmat[1],bmat[4],bmat[7]])
    cstar_vec = matrix.col([bmat[2],bmat[5],bmat[8]])

    assert approx_equal(astar, math.sqrt(astar_vec.dot(astar_vec)))
    assert approx_equal(bstar, math.sqrt(bstar_vec.dot(bstar_vec)))
    assert approx_equal(cstar, math.sqrt(cstar_vec.dot(cstar_vec)))
    assert approx_equal(bstar*cstar*math.cos(math.pi*alphastar/180),
                        bstar_vec.dot(cstar_vec))
    assert approx_equal(cstar*astar*math.cos(math.pi*betastar/180),
                        cstar_vec.dot(astar_vec))
    assert approx_equal(astar*bstar*math.cos(math.pi*gammastar/180),
                        astar_vec.dot(bstar_vec))

    # proof complete, bmat == A*
    #----------------------------

    first_rotation_vector = matrix.col([1, 0, 0])
    second_rotation_vector = matrix.col([1, 0, 1])

    maxh, maxk, maxl = uc.max_miller_indices(resolution)

    indices = []
    for h in range(-maxh, maxh + 1):
        for k in range(-maxk, maxk + 1):
            for l in range(-maxl, maxl + 1):
                indices.append((h, k, l))

    rotation_scattering(indices, bmat, first_rotation_vector,
                        wavelength, resolution)

    rotation_scattering(indices, bmat, second_rotation_vector,
                        wavelength, resolution)

    # Now repeat the entire excercise for some non-integer Miller indices

    float_indices = []
    for h in range(-maxh, maxh + 1):
        for k in range(-maxk, maxk + 1):
            for l in range(-maxl, maxl + 1):
                float_indices.append((h+0.2, k+0.2, l+0.2))

    rotation_scattering(float_indices, bmat, first_rotation_vector,
                        wavelength, resolution,
                        assert_non_integer_index = True)

    rotation_scattering(float_indices, bmat, second_rotation_vector,
                        wavelength, resolution,
                        assert_non_integer_index = True)


    scattering_prediction(indices, bmat, second_rotation_vector,
                          wavelength, resolution)
    print("OK")


 *******************************************************************************


 *******************************************************************************
rstbx/diffraction/tst_partial_derivatives.py
from __future__ import absolute_import, division, print_function
#!/usr/bin/env python
import math

from scitbx import matrix
from rstbx.diffraction import partial_spot_position_partial_H
from libtbx.test_utils import approx_equal
from cctbx.crystal_orientation import crystal_orientation


some_indices = ([-5,29,0],[-5,20,0],[-3,13,0],[7,20,5],[10,10,10],[2,13,-5])

finite_differences = ([0.1,0.,0.],[0.,0.1,0.],[0.,0.,0.1])

# Reproduce the test provided by Graeme Winter)
def rotation_scattering(ra,rotation_vector,Amat,wavelength):
    beam_vector = matrix.col([0, 0, 1 / wavelength])

    for hkl in some_indices:
        if ra(hkl):

            omegas = ra.get_intersection_angles()

            for omegaidx in [0,1]:

                rot_mat = rotation_vector.axis_and_angle_as_r3_rotation_matrix(omegas[omegaidx])
                assert(-0.0001 < math.fabs(rot_mat.determinant() - 1.0) < 0.0001)

                H1 = (rot_mat * matrix.sqr(Amat))*matrix.col(hkl)
                H1 =  H1 + beam_vector
                len_H1 = math.sqrt((H1[0] * H1[0]) +
                                   (H1[1] * H1[1]) +
                                   (H1[2] * H1[2]))

                #print 'H1 wav %.3f %.3f' % (len_H1, 1.0 / wavelength)

                if math.fabs(len_H1 - 1.0 / wavelength) > 0.0001:
                    raise RuntimeError('length error for %d %d %d' % hkl)

def test_finite_differences(ra,rotation_vector,Amat,wavelength):
    beam_vector = matrix.col([0, 0, 1 / wavelength])

    for hkl in [matrix.col(i) for i in some_indices]:
      if ra(hkl):
        omegas = ra.get_intersection_angles()
        dangles = [ra.dangle_(0),ra.dangle_(1)]

        for n,difference in enumerate([matrix.col(d) for d in finite_differences]):
          assert ra(hkl+difference) # not always true, true in these cases
          domegas = ra.get_intersection_angles()

          for omegaidx in [0,1]:
            #print "HKL","%18s"%(str(hkl.elems)),"idx",omegaidx, "%7.2f"%(180.*omegas[omegaidx]/math.pi),

            rot_mat = rotation_vector.axis_and_angle_as_r3_rotation_matrix(omegas[omegaidx])
            H1 = (rot_mat * matrix.sqr(Amat))*matrix.col(hkl) + beam_vector

            #print "%10.7f %10.7f %10.7f"%H1.elems
            #print "HKL","%18s"%str((hkl+difference).elems),"idx",omegaidx, "%7.2f"%(180.*domegas[omegaidx]/math.pi),

            rot_mat = rotation_vector.axis_and_angle_as_r3_rotation_matrix(domegas[omegaidx])
            H1 = (rot_mat * matrix.sqr(Amat))*matrix.col(hkl+difference) + beam_vector

            #print "%10.7f %10.7f %10.7f"%H1.elems

            #print "PRT","%18s"%str((hkl+difference).elems),"idx",omegaidx, "%7.2f"%(
            #  180.*(omegas[omegaidx] + dangles[omegaidx][n]*0.1)/math.pi),

            rot_mat = rotation_vector.axis_and_angle_as_r3_rotation_matrix(
              omegas[omegaidx] + dangles[omegaidx][n]*0.1)
            HP = (rot_mat * matrix.sqr(Amat))*matrix.col(hkl+difference) + beam_vector

            #print "%10.7f %10.7f %10.7f"%HP.elems

            assert approx_equal(H1,HP,eps=1E-5)

            #print


if __name__ == '__main__':

    wavelength = 1.2
    resolution = 3.0
    Amat = (0.0038039968697463817, 0.004498689311366309, 0.0044043429203887785,
      -0.00477859183801569, 0.006594300357213904, -0.002402759536958918,
      -0.01012056453488894, -0.0014226943325514182, 0.002789954423701981)
    orient = crystal_orientation(Amat,True)
    calc = partial_spot_position_partial_H(
      limiting_resolution = resolution,
      orientation = orient.reciprocal_matrix(),
      wavelength = wavelength,
      axial_direction = (0.,1.,0.)
    )
    rotation_scattering(calc,matrix.col((0.,1.,0.)),Amat,wavelength)
    test_finite_differences(calc,matrix.col((0.,1.,0.)),Amat,wavelength)

    print("OK")


 *******************************************************************************


 *******************************************************************************
rstbx/diffraction/tst_predict.py
from __future__ import absolute_import, division, print_function
from six.moves import range
from rstbx.diffraction import rotation_angles
from cctbx.crystal_orientation import crystal_orientation,basis_type
from libtbx.test_utils import approx_equal

test_results=[
((-4, -3, -5),(-2.1644080756068704, 0.82603163906757826)),
((-4, -3, -4),(-2.1563824130204701, 0.83451621989551883)),
((-4, -3, -3),(-2.1476369882498436, 0.84275362492632477)),
((-4, -3, -2),(-2.1381420481925733, 0.85073212909354023)),
((-4, -3, -1),(-2.1278664357865269, 0.85843936020563638)),
((-4, -3, 0),(-2.1167775302687417, 0.86586226386067811)),
((-4, -3, 1),(-2.1048411851088034, 0.87298706505447998)),
((-4, -3, 2),(-2.0920216634827948, 0.87979922593866833)),
((-4, -2, -8),(-2.3517102079316765, 0.63998771713383507)),
((-4, -2, -7),(-2.3478281931611629, 0.64721041614149566)),
((-4, -2, -6),(-2.3433224076234787, 0.65416216116158055)),
((-4, -2, -5),(-2.338163187294632, 0.66082958483881171)),
((-4, -2, -4),(-2.3323190243690588, 0.66719843977099291)),
((-4, -2, -3),(-2.3257564359156206, 0.67325353443169111)),
((-4, -2, -2),(-2.3184398205079146, 0.67897866221111858)),
((-4, -2, -1),(-2.3103313013994797, 0.68435652253111579)),
((-4, -2, 0),(-2.3013905545938611, 0.68936863278894389)),
((-4, -2, 1),(-2.2915746198968177, 0.69399522963913585)),
((-4, -2, 2),(-2.2808376927234328, 0.69821515782199495)),
((-4, -2, 3),(-2.2691308940541397, 0.70200574437742413)),
((-4, -2, 4),(-2.2564020154745883, 0.70534265562555354)),
((-4, -2, 5),(-2.2425952356738228, 0.70819973372741496)),
((-4, -1, -9),(-2.5308098266764345, 0.46028415341980455)),
((-4, -1, -8),(-2.5302848214986784, 0.46514725234493398)),
((-4, -1, -7),(-2.5292342273209871, 0.46966628410773587)),
((-4, -1, -6),(-2.5276312561197014, 0.47382369995636803)),
((-4, -1, -5),(-2.5254472282330442, 0.47760069073118888)),
((-4, -1, -4),(-2.5226514099331481, 0.48097707866688094)),
((-4, -1, -3),(-2.5192108323762348, 0.4839311961914976)),
((-4, -1, -2),(-2.5150900891927819, 0.4864397496659289)),
((-4, -1, -1),(-2.5102511094811852, 0.48847766560364997)),
((-4, -1, 0),(-2.5046529023623023, 0.49001791641395342)),
((-4, -1, 1),(-2.4982512685115954, 0.49103132209800959)),
((-4, -1, 2),(-2.4909984731750785, 0.49148632356375704)),
((-4, -1, 3),(-2.4828428740492936, 0.49134872227079812)),
((-4, -1, 4),(-2.4737284960041088, 0.49058137971448473)),
((-4, -1, 5),(-2.4635945428704575, 0.48914386873456728)),
((-4, -1, 6),(-2.4523748342967511, 0.48699206668781031)),
((-4, 0, -9),(-2.7075479183479456, 0.28262514671259681)),
((-4, 0, -8),(-2.7099907535850076, 0.28453239000476199)),
((-4, 0, -7),(-2.712011168841761, 0.28599904122031838)),
((-4, 0, -6),(-2.7135874843901879, 0.28700247991898331)),
((-4, 0, -5),(-2.7146964449166768, 0.28751844401101351)),
((-4, 0, -4),(-2.7153130789933311, 0.28752088332609876)),
((-4, 0, -3),(-2.7154105413808369, 0.28698179536956087)),
((-4, 0, -2),(-2.7149599354532072, 0.28587104047261436)),
((-4, 0, -1),(-2.7139301125074402, 0.28415613300355697)),
((-4, 0, 0),(-2.7122874440734508, 0.28180200464428157)),
((-4, 0, 1),(-2.7099955625391106, 0.2787707349185628)),
((-4, 0, 2),(-2.7070150644101365, 0.2750212431429222)),
((-4, 0, 3),(-2.7033031692799137, 0.2705089347019079)),
((-4, 0, 4),(-2.6988133260168774, 0.26518529295327825)),
((-4, 0, 5),(-2.6934947556889823, 0.25899740604605698)),
((-4, 0, 6),(-2.6872919182034409, 0.25188741535194725)),
((-4, 1, -8),(-2.8796653646852977, 0.10938810433468421)),
((-4, 1, -7),(-2.8844290526903671, 0.10802314514838145)),
((-4, 1, -6),(-2.8888544340477269, 0.10612014605319227)),
((-4, 1, -5),(-2.8929247721042515, 0.10365257781794722)),
((-4, 1, -4),(-2.8966221726532195, 0.10059211225346927)),
((-4, 1, -3),(-2.8999274875451237, 0.096908473277887167)),
((-4, 1, -2),(-2.90282020686249, 0.09256927138710698)),
((-4, 1, -1),(-2.9052783378602522, 0.087539819143462594)),
((-4, 1, 0),(-2.9072782685237462, 0.081782924869921295)),
((-4, 1, 1),(-2.9087946131676299, 0.075258661221423648)),
((-4, 1, 2),(-2.9098000369706947, 0.067924104676897204)),
((-4, 1, 3),(-2.9102650556866623, 0.059733041226309229)),
((-4, 1, 4),(-2.9101578059546229, 0.050635632579456205)),
((-4, 1, 5),(-2.909443780608759, 0.040578036048329796)),
((-4, 2, -3),(-3.0621609181560006, -0.075176923028023243)),
((-4, 2, -2),(-3.0675200578810209, -0.081831067832066243)),
((-4, 2, -1),(-3.0725497629968923, -0.089189117263163406)),
((-4, 2, 0),(-3.0772340546619521, -0.097283839954712306)),
((-3, -4, -9),(-1.9186807978345002, 1.0678756183194666)),
((-3, -4, -8),(-1.9095408418739945, 1.0821170500791975)),
((-3, -4, -7),(-1.8996857140430228, 1.0962061655013031)),
((-3, -4, -6),(-1.8890926257610019, 1.1101336310873262)),
((-3, -4, -5),(-1.8777383483996397, 1.1238896353781627)),
((-3, -4, -4),(-1.8655992637788497, 1.1374638864261277)),
((-3, -4, -3),(-1.8526514223811588, 1.1508456108700291)),
((-3, -4, -2),(-1.8388706097467478, 1.1640235547087561)),
((-3, -4, -1),(-1.8242324214645822, 1.1769859858454257)),
((-3, -4, 0),(-1.8087123471112596, 1.189720698444829)),
((-3, -4, 1),(-1.7922858634060383, 1.2022150191114247)),
((-3, -4, 2),(-1.7749285367455292, 1.214455814852786)),
((-3, -4, 3),(-1.7566161351529119, 1.2264295027444108)),
((-3, -4, 4),(-1.7373247495219588, 1.2381220611555419)),
((-3, -4, 5),(-1.717030923854153, 1.249519042332484)),
((-3, -4, 6),(-1.6957117939762307, 1.2606055860656162)),
((-3, -3, -12),(-2.1014485380247865, 0.87645308424953716)),
((-3, -3, -11),(-2.0957357801431784, 0.89042140922191038)),
((-3, -3, -10),(-2.089318695933847, 0.90427646297309716)),
((-3, -3, -9),(-2.0821669686519959, 0.91801060121359623)),
((-3, -3, -8),(-2.0742488395849121, 0.93161559528854909)),
((-3, -3, -7),(-2.0655310728826279, 0.94508260617016893)),
((-3, -3, -6),(-2.0559789247649376, 0.9584021579863129)),
((-3, -3, -5),(-2.045556118199046, 0.97156411117071717)),
((-3, -3, -4),(-2.0342248242844101, 0.98455763532001472)),
((-3, -3, -3),(-2.0219456517325916, 0.99737118183784879)),
((-3, -3, -2),(-2.0086776459885258, 1.0099924564358937)),
((-3, -3, -1),(-1.9943782997027253, 1.0224083915437105)),
((-3, -3, 0),(-1.979003576428247, 1.0346051186525971)),
((-3, -3, 1),(-1.962507949576102, 1.0465679405804109)),
((-3, -3, 2),(-1.9448444588120386, 1.0582813035928971)),
((-3, -3, 3),(-1.9259647862068898, 1.0697287692491899)),
((-3, -3, 4),(-1.9058193545508628, 1.0808929857519785)),
((-3, -3, 5),(-1.8843574502948603, 1.0917556584727153)),
((-3, -3, 6),(-1.8615273735714883, 1.1022975191852051)),
((-3, -3, 7),(-1.8372766176529489, 1.1124982933720182)),
((-3, -3, 8),(-1.8115520799964697, 1.1223366647620168)),
((-3, -3, 9),(-1.7843003066790657, 1.1317902360070144)),
((-3, -2, -13),(-2.2900278505333258, 0.68617749256662541)),
((-3, -2, -12),(-2.2875880980790106, 0.69829285391925877)),
((-3, -2, -11),(-2.2844906531541063, 0.71026682526633877)),
((-3, -2, -10),(-2.2807008820870909, 0.72209093411940517)),
((-3, -2, -9),(-2.2761817673439348, 0.73375597668886261)),
((-3, -2, -8),(-2.2708937381379699, 0.74525196591387977)),
((-3, -2, -7),(-2.2647944885152289, 0.75656807511358304)),
((-3, -2, -6),(-2.2578387821488413, 0.7676925768166255)),
((-3, -2, -5),(-2.2499782430721043, 0.77861277625440528)),
((-3, -2, -4),(-2.2411611315891755, 0.78931493891473092)),
((-3, -2, -3),(-2.2313321046291188, 0.79978421144347833)),
((-3, -2, -2),(-2.2204319598581872, 0.81000453504626735)),
((-3, -2, -1),(-2.2083973629420037, 0.81995855037294751)),
((-3, -2, 0),(-2.1951605574608921, 0.8296274926561944)),
((-3, -2, 1),(-2.1806490571347852, 0.83899107560948483)),
((-3, -2, 2),(-2.1647853202173759, 0.84802736225450637)),
((-3, -2, 3),(-2.1474864061802501, 0.85671262042368024)),
((-3, -2, 4),(-2.1286636151339779, 0.86502116014437558)),
((-3, -2, 5),(-2.1082221108293702, 0.87292514942377353)),
((-3, -2, 6),(-2.0860605285475167, 0.88039440407201508)),
((-3, -2, 7),(-2.0620705697121102, 0.88739614606635686)),
((-3, -2, 8),(-2.0361365856149476, 0.89389472348891319)),
((-3, -2, 9),(-2.008135153181632, 0.8998512831539176)),
((-3, -2, 10),(-1.9779346461214229, 0.90522338452333351)),
((-3, -2, 11),(-1.9453948049357528, 0.90996454017632245)),
((-3, -1, -14),(-2.4908850917087864, 0.47810695364223693)),
((-3, -1, -13),(-2.4926358998901077, 0.48715824176293415)),
((-3, -1, -12),(-2.4938666015936364, 0.49597167311988166)),
((-3, -1, -11),(-2.4945471313040022, 0.50453364205691342)),
((-3, -1, -10),(-2.4946449448748949, 0.5128293499299994)),
((-3, -1, -9),(-2.4941247840238758, 0.52084269550513662)),
((-3, -1, -8),(-2.492948412836181, 0.52855615217397856)),
((-3, -1, -7),(-2.4910743222639158, 0.53595063000129917)),
((-3, -1, -6),(-2.4884573979099538, 0.54300532023644543)),
((-3, -1, -5),(-2.4850485455454199, 0.54969751945004997)),
((-3, -1, -4),(-2.4807942677917314, 0.55600242987341009)),
((-3, -1, -3),(-2.4756361841590762, 0.56189293178957433)),
((-3, -1, -2),(-2.46951048511644, 0.56733932291033429)),
((-3, -1, -1),(-2.4623473090015806, 0.5723090185171017)),
((-3, -1, 0),(-2.4540700282669023, 0.57676620467101924)),
((-3, -1, 1),(-2.4445944286747676, 0.58067143490906037)),
((-3, -1, 2),(-2.4338277614360146, 0.58398115840023113)),
((-3, -1, 3),(-2.4216676437051952, 0.58664716435076802)),
((-3, -1, 4),(-2.4080007770002441, 0.58861592325487977)),
((-3, -1, 5),(-2.3927014455838824, 0.58982780001598689)),
((-3, -1, 6),(-2.3756297470418053, 0.59021610647888945)),
((-3, -1, 7),(-2.3566294943870654, 0.58970595074380672)),
((-3, -1, 8),(-2.3355257118081156, 0.58821282663979757)),
((-3, -1, 9),(-2.3121216228927586, 0.58564086721481734)),
((-3, -1, 10),(-2.2861949981468088, 0.58188065845470027)),
((-3, -1, 11),(-2.2574936838111155, 0.57680646963619076)),
((-3, -1, 12),(-2.2257300699530007, 0.57027269833079075)),
((-3, 0, -14),(-2.6946178997817647, 0.27409042376715442)),
((-3, 0, -13),(-2.7002814312865349, 0.27922063173268452)),
((-3, 0, -12),(-2.7055804876639731, 0.28396543283279291)),
((-3, 0, -11),(-2.7104939026322081, 0.28830240392495621)),
((-3, 0, -10),(-2.7149986754165156, 0.29220718470089274)),
((-3, 0, -9),(-2.7190697882855615, 0.29565328452088058)),
((-3, 0, -8),(-2.7226800004707767, 0.29861186426422409)),
((-3, 0, -7),(-2.7257996146682943, 0.30105148918718122)),
((-3, 0, -6),(-2.7283962115666003, 0.30293784798635459)),
((-3, 0, -5),(-2.7304343469077001, 0.30423343228563537)),
((-3, 0, -4),(-2.7318752044252759, 0.30489716954650892)),
((-3, 0, -3),(-2.7326761965451589, 0.30488400087792644)),
((-3, 0, -2),(-2.7327905028944786, 0.30414439330309334)),
((-3, 0, -1),(-2.7321665343305295, 0.30262377360739312)),
((-3, 0, 0),(-2.7307473072116188, 0.30026186778244973)),
((-3, 0, 1),(-2.7284697087762617, 0.29699192607649683)),
((-3, 0, 2),(-2.7252636294791652, 0.29273980845810754)),
((-3, 0, 3),(-2.7210509315406544, 0.28742289847705527)),
((-3, 0, 4),(-2.7157442142198303, 0.28094880446869103)),
((-3, 0, 5),(-2.7092453245888524, 0.27321379494723746)),
((-3, 0, 6),(-2.7014435466590054, 0.2641008986382013)),
((-3, 0, 7),(-2.6922133798079226, 0.25347757709856139)),
((-3, 0, 8),(-2.6814117869099356, 0.24119284655150369)),
((-3, 0, 9),(-2.6688747492937166, 0.2270736812777692)),
((-3, 0, 10),(-2.6544129032694777, 0.2109204672045038)),
((-3, 0, 11),(-2.6378059413036521, 0.19250118092482396)),
((-3, 0, 12),(-2.6187953233011818, 0.17154382943920357)),
((-3, 1, -13),(-2.8959492178816468, 0.079382252936560108)),
((-3, 1, -12),(-2.9047325778546265, 0.080283095570497093)),
((-3, 1, -11),(-2.9132746229649684, 0.080648634296221502)),
((-3, 1, -10),(-2.9215619008626383, 0.080448946442102126)),
((-3, 1, -9),(-2.9295798367305146, 0.079651756780256378)),
((-3, 1, -8),(-2.9373126348700018, 0.07822222455894795)),
((-3, 1, -7),(-2.9447431688812951, 0.076122706402541637)),
((-3, 1, -6),(-2.9518528587543407, 0.073312491763175197)),
((-3, 1, -5),(-2.9586215328659113, 0.069747507052956362)),
((-3, 1, -4),(-2.96502727248384, 0.06537998391962753)),
((-3, 1, -3),(-2.9710462358917846, 0.060158086326600413)),
((-3, 1, -2),(-2.9766524586413388, 0.054025490127486135)),
((-3, 1, -1),(-2.9818176256792897, 0.046920907643934848)),
((-3, 1, 0),(-2.9865108101420965, 0.038777548310174062)),
((-3, 1, 1),(-2.990698172398043, 0.029522504668110922)),
((-3, 1, 2),(-2.9943426113709446, 0.019076050791998238)),
((-3, 1, 3),(-2.9974033581898958, 0.0073508374699347455)),
((-3, 1, 4),(-2.9998354996303429, -0.0057490349911365375)),
((-3, 1, 5),(-3.0015894154387355, -0.020329089859899077)),
((-3, 1, 6),(-3.0026101091808122, -0.036505722117989456)),
((-3, 1, 7),(-3.002836406317571, -0.054407658055330113)),
((-3, 1, 8),(-3.0021999852119077, -0.074177672256026353)),
((-3, 1, 9),(-3.0006241958554454, -0.09597462052503887)),
((-3, 1, 10),(-2.9980226060242305, -0.11997586427498406)),
((-3, 1, 11),(-2.9942971934337583, -0.14638018508015721)),
((-3, 2, -12),(-3.07808083517271, -0.10157678587130563)),
((-3, 2, -11),(-3.088995129959494, -0.10416656658978136)),
((-3, 2, -10),(-3.0997387566944417, -0.10737234131068603)),
((-3, 2, -9),(-3.1103025410616842, -0.11122425520833933)),
((-3, 2, -8),(-3.1206766168492766, -0.11575437696165745)),
((-3, 2, -7),(-3.1308503808521446, -0.12099682538634071)),
((-3, 2, -6),(-3.1408124440644722, -0.12698790509229746)),
((-3, 2, -5),(3.1326347284295228, -0.13376625179038171)),
((-3, 2, -4),(3.123133646273303, -0.14137298791237843)),
((-3, 2, -3),(3.1138836996314532, -0.14985188924979251)),
((-3, 2, -2),(3.1048999990498225, -0.15924956336065643)),
((-3, 2, -1),(3.0961987578933035, -0.16961564053966618)),
((-3, 2, 0),(3.0877973752665762, -0.18100297819589323)),
((-3, 2, 1),(3.0797145277853075, -0.19346787953534081)),
((-3, 2, 2),(3.0719702716401334, -0.20707032750446822)),
((-3, 2, 3),(3.0645861567123447, -0.22187423501832021)),
((-3, 2, 4),(3.0575853548956911, -0.23794771257793224)),
((-3, 2, 5),(3.0509928052745892, -0.25536335448362563)),
((-3, 2, 6),(3.0448353794335929, -0.27419854498545915)),
((-3, 2, 7),(3.0391420709631691, -0.29453578589718205)),
((-3, 2, 8),(3.0339442142326489, -0.31646304746364151)),
((-3, 2, 9),(3.0292757387887681, -0.34007414465511288)),
((-3, 2, 10),(3.0251734673983983, -0.36546914162936717)),
((-3, 3, -9),(3.0266036406275112, -0.2714343471465524)),
((-3, 3, -8),(3.0150146400279647, -0.27770919088120244)),
((-3, 3, -7),(3.0035939871263553, -0.28465701480251288)),
((-3, 3, -6),(2.9923505381928734, -0.29230513049554352)),
((-3, 3, -5),(2.9812936847289455, -0.30068207717481887)),
((-3, 3, -4),(2.9704333750156682, -0.30981765584878845)),
((-3, 3, -3),(2.9597801364827814, -0.31974296179984474)),
((-3, 3, -2),(2.9493450989868197, -0.33049041490526571)),
((-3, 3, -1),(2.9391400191170254, -0.34209378727285161)),
((-3, 3, 0),(2.9291773056849482, -0.35458822761224001)),
((-3, 3, 1),(2.9194700465998551, -0.36801028171004563)),
((-3, 3, 2),(2.9100320373888535, -0.38239790832589482)),
((-3, 3, 3),(2.9008778116898419, -0.39779048977904935)),
((-3, 3, 4),(2.8920226741297621, -0.41422883645512371)),
((-3, 3, 5),(2.8834827361025943, -0.43175518443287592)),
((-3, 3, 6),(2.8752749550850796, -0.4504131854179832)),
((-3, 3, 7),(2.8674171782770053, -0.47024788818041519)),
((-2, -5, -8),(-1.605922572980891, 1.3789676344488606)),
((-2, -5, -7),(-1.59360645649702, 1.3963409915414469)),
((-2, -5, -6),(-1.5806129687441293, 1.4134950104401838)),
((-2, -5, -5),(-1.5669326690749705, 1.4304169158635192)),
((-2, -5, -4),(-1.5525568043973321, 1.4470936674417654)),
((-2, -5, -3),(-1.537477391548643, 1.4635119993729206)),
((-2, -5, -2),(-1.5216872997680631, 1.4796584629433895)),
((-2, -5, -1),(-1.5051803323581259, 1.4955194716213571)),
((-2, -5, 0),(-1.4879513065430903, 1.5110813483659975)),
((-2, -5, 1),(-1.4699961304568954, 1.5263303747329939)),
((-2, -5, 2),(-1.4513118761332438, 1.5412528412978961)),
((-2, -5, 3),(-1.4318968473268818, 1.5558350988652616)),
((-2, -5, 4),(-1.4117506409717981, 1.5700636098854062)),
((-2, -5, 5),(-1.3908742010811483, 1.5839249994632258)),
((-2, -4, -12),(-1.7778803590305985, 1.192944457020763)),
((-2, -4, -11),(-1.7679243070396791, 1.2125324265410495)),
((-2, -4, -10),(-1.7571887591131963, 1.232022644417655)),
((-2, -4, -9),(-1.7456519035003482, 1.251402880352716)),
((-2, -4, -8),(-1.7332920150014441, 1.2706601120462966)),
((-2, -4, -7),(-1.7200875822544963, 1.2897805298834644)),
((-2, -4, -6),(-1.7060174476443417, 1.3087495475655646)),
((-2, -4, -5),(-1.6910609597582038, 1.3275518192052365)),
((-2, -4, -4),(-1.6751981380505165, 1.3461712633473057)),
((-2, -4, -3),(-1.6584098490778507, 1.3645910942997934)),
((-2, -4, -2),(-1.6406779933237261, 1.3827938610602535)),
((-2, -4, -1),(-1.6219857012562289, 1.4007614940020583)),
((-2, -4, 0),(-1.6023175368547904, 1.4184753593439896)),
((-2, -4, 1),(-1.5816597064144342, 1.4359163212660293)),
((-2, -4, 2),(-1.5600002699976907, 1.4530648113576652)),
((-2, -4, 3),(-1.5373293524698313, 1.4699009048958904)),
((-2, -4, 4),(-1.513639350638706, 1.4864044032536328)),
((-2, -4, 5),(-1.4889251326449831, 1.5025549215415581)),
((-2, -4, 6),(-1.4631842254320027, 1.518331980393643)),
((-2, -4, 7),(-1.4364169858880103, 1.5337151006270768)),
((-2, -4, 8),(-1.4086267511177266, 1.5486838993472103)),
((-2, -4, 9),(-1.3798199632841384, 1.5632181859355041)),
((-2, -4, 10),(-1.3500062645811519, 1.5772980562591647)),
((-2, -3, -14),(-1.961145554426309, 0.99639350507505586)),
((-2, -3, -13),(-1.9537070073086735, 1.0165396744612776)),
((-2, -3, -12),(-1.9454072172832793, 1.0367058186598703)),
((-2, -3, -11),(-1.9362085625242742, 1.0568851263535748)),
((-2, -3, -10),(-1.9260719916887274, 1.0770697866469485)),
((-2, -3, -9),(-1.9149570894189225, 1.0972509266959534)),
((-2, -3, -8),(-1.9028221670393766, 1.1174185495764493)),
((-2, -3, -7),(-1.8896243821983425, 1.1375614733545736)),
((-2, -3, -6),(-1.8753198914131723, 1.1576672724768875)),
((-2, -3, -5),(-1.85986403961655, 1.1777222227547364)),
((-2, -3, -4),(-1.8432115908366409, 1.1977112513694244)),
((-2, -3, -3),(-1.8253170040445212, 1.2176178934651263)),
((-2, -3, -2),(-1.8061347579277713, 1.2374242570158311)),
((-2, -3, -1),(-1.7856197278574781, 1.2571109977406938)),
((-2, -3, 0),(-1.7637276175625991, 1.2766573058872754)),
((-2, -3, 1),(-1.7404154469666968, 1.2960409066917946)),
((-2, -3, 2),(-1.7156420962379133, 1.3152380762473281)),
((-2, -3, 3),(-1.6893689043229891, 1.3342236743531339)),
((-2, -3, 4),(-1.6615603180639444, 1.3529711956708281)),
((-2, -3, 5),(-1.6321845854374721, 1.3714528401693209)),
((-2, -3, 6),(-1.6012144835461797, 1.3896396033972531)),
((-2, -3, 7),(-1.5686280687979681, 1.4075013865821169)),
((-2, -3, 8),(-1.5344094333474456, 1.4250071259284192)),
((-2, -3, 9),(-1.4985494484996831, 1.4421249397894331)),
((-2, -3, 10),(-1.4610464725965029, 1.4588222916416103)),
((-2, -3, 11),(-1.4219069981649757, 1.4750661660277178)),
((-2, -3, 12),(-1.3811462110820822, 1.4908232538885866)),
((-2, -2, -16),(-2.1770875262902583, 0.75486276703925259)),
((-2, -2, -15),(-2.1742296001557411, 0.77325027933803869)),
((-2, -2, -14),(-2.1705677731918511, 0.7917022548841296)),
((-2, -2, -13),(-2.1660541532585751, 0.81021939775622709)),
((-2, -2, -12),(-2.1606372119800041, 0.82880191537715076)),
((-2, -2, -11),(-2.1542615359671982, 0.8474494562070447)),
((-2, -2, -10),(-2.1468675696166448, 0.86616104010636807)),
((-2, -2, -9),(-2.138391352275864, 0.88493498079940403)),
((-2, -2, -8),(-2.1287642536550782, 0.90376879987982861)),
((-2, -2, -7),(-2.1179127127242428, 0.92265913183010073)),
((-2, -2, -6),(-2.1057579870203611, 0.94160161958196176)),
((-2, -2, -5),(-2.0922159213561735, 0.96059080023166288)),
((-2, -2, -4),(-2.0771967474267092, 0.97961998064808498)),
((-2, -2, -3),(-2.0606049288098367, 0.99868110288150069)),
((-2, -2, -2),(-2.0423390693976238, 1.0177645995028808)),
((-2, -2, -1),(-2.0222919074039694, 1.036859239285431)),
((-2, -2, 0),(-2.0003504217625907, 1.0559519639869408)),
((-2, -2, 1),(-1.9763960828945939, 1.0750277174073446)),
((-2, -2, 2),(-1.9503052853376268, 1.0940692683799269)),
((-2, -2, 3),(-1.9219500053196745, 1.1130570299018316)),
((-2, -2, 4),(-1.8911987315924774, 1.1319688772061942)),
((-2, -2, 5),(-1.8579177220577598, 1.1507799682021429)),
((-2, -2, 6),(-1.8219726409969379, 1.1694625703248867)),
((-2, -2, 7),(-1.7832306308097254, 1.1879858983978555)),
((-2, -2, 8),(-1.7415628665020486, 1.2063159685480485)),
((-2, -2, 9),(-1.696847628860449, 1.2244154734552524)),
((-2, -2, 10),(-1.6489739112459292, 1.2422436841616578)),
((-2, -2, 11),(-1.5978455432345993, 1.2597563832170331)),
((-2, -2, 12),(-1.5433857703970069, 1.2769058329774596)),
((-2, -2, 13),(-1.4855421728835125, 1.2936407813075186)),
((-2, -2, 14),(-1.4242917375405248, 1.3099065046663554)),
((-2, -1, -16),(-2.4174256118115083, 0.51478521163695512)),
((-2, -1, -15),(-2.4196625400308394, 0.5288349499696221)),
((-2, -1, -14),(-2.4212613302745831, 0.54281705924534585)),
((-2, -1, -13),(-2.422176210022986, 0.55672709723075176)),
((-2, -1, -12),(-2.4223566761828486, 0.57055987098597605)),
((-2, -1, -11),(-2.4217469332903088, 0.58430935035621989)),
((-2, -1, -10),(-2.4202852520641684, 0.59796856888302408)),
((-2, -1, -9),(-2.4179032355630947, 0.61152951012423662)),
((-2, -1, -8),(-2.4145249779502005, 0.62498297698710459)),
((-2, -1, -7),(-2.4100660982033912, 0.63831844120808068)),
((-2, -1, -6),(-2.4044326279555897, 0.65152386953167341)),
((-2, -1, -5),(-2.397519728924125, 0.66458552241840907)),
((-2, -1, -4),(-2.3892102110048161, 0.67748772020697434)),
((-2, -1, -3),(-2.3793728169744091, 0.69021257051251117)),
((-2, -1, -2),(-2.367860233783269, 0.70273964918520349)),
((-2, -1, -1),(-2.3545067835735587, 0.71504562527676285)),
((-2, -1, 0),(-2.3391257398254477, 0.72710381802053026)),
((-2, -1, 1),(-2.3215062055198059, 0.73888367061836779)),
((-2, -1, 2),(-2.3014094811985863, 0.7503501213495517)),
((-2, -1, 3),(-2.2785648419042692, 0.76146284674722053)),
((-2, -1, 4),(-2.2526646342975765, 0.77217534369910701)),
((-2, -1, 5),(-2.2233586007108515, 0.78243380638430515)),
((-2, -1, 6),(-2.1902473386737102, 0.79217573853181422)),
((-2, -1, 7),(-2.1528748176230037, 0.80132821937550969)),
((-2, -1, 8),(-2.1107199068854703, 0.80980570939889818)),
((-2, -1, 9),(-2.0631869321105372, 0.81750723388422575)),
((-2, -1, 10),(-2.0095953871257994, 0.82431270907896581)),
((-2, -1, 11),(-1.9491691048075186, 0.83007806158789776)),
((-2, -1, 12),(-1.8810254543618012, 0.83462860847461118)),
((-2, -1, 13),(-1.8041654910699358, 0.83774986265941742)),
((-2, -1, 14),(-1.7174663988188439, 0.83917440902265061)),
((-2, -1, 15),(-1.6196778674424834, 0.83856256910615612)),
((-2, 0, -16),(-2.6742338248640292, 0.25810775861426655)),
((-2, 0, -15),(-2.6826716275504783, 0.26597666218712451)),
((-2, 0, -14),(-2.6907791179514136, 0.27348678800507398)),
((-2, 0, -13),(-2.698532603680051, 0.28061225252527133)),
((-2, 0, -12),(-2.7059056717757564, 0.28732422083312842)),
((-2, 0, -11),(-2.7128688351186465, 0.29359052184901241)),
((-2, 0, -10),(-2.7193891204144722, 0.29937519990097899)),
((-2, 0, -9),(-2.7254295860923095, 0.30463798996467495)),
((-2, 0, -8),(-2.730948755650382, 0.30933370081920192)),
((-2, 0, -7),(-2.7358999483782425, 0.313411486448609)),
((-2, 0, -6),(-2.7402304847100054, 0.3168139809453247)),
((-2, 0, -5),(-2.7438807373541989, 0.31947626554676273)),
((-2, 0, -4),(-2.7467829912841766, 0.32132462770393111)),
((-2, 0, -3),(-2.748860064926463, 0.3222750604552585)),
((-2, 0, -2),(-2.7500236304006966, 0.32223143473346444)),
((-2, 0, -1),(-2.7501721509129964, 0.32108325593240367)),
((-2, 0, 0),(-2.7491883261213261, 0.31870288669215702)),
((-2, 0, 1),(-2.7469358980764871, 0.31494207680927261)),
((-2, 0, 2),(-2.7432556159949573, 0.30962758293135806)),
((-2, 0, 3),(-2.7379600795264225, 0.30255557667492866)),
((-2, 0, 4),(-2.7308270644045414, 0.29348441638373723)),
((-2, 0, 5),(-2.721590760288104, 0.2821251727381171)),
((-2, 0, 6),(-2.70993008276373, 0.26812901474778272)),
((-2, 0, 7),(-2.6954527985805949, 0.25107011641362947)),
((-2, 0, 8),(-2.6776735154578657, 0.23042202159588754)),
((-2, 0, 9),(-2.6559824308243845, 0.20552419409084915)),
((-2, 0, 10),(-2.6295997090797387, 0.17553337147973194)),
((-2, 0, 11),(-2.5975066445829107, 0.13935049508565997)),
((-2, 0, 12),(-2.5583375697259516, 0.095506570698406804)),
((-2, 0, 13),(-2.510201522861248, 0.041975498267722205)),
((-2, 0, 14),(-2.450368873552089, -0.024152558944191663)),
((-2, 0, 15),(-2.374672514560543, -0.10729046496109691)),
((-2, 1, -16),(-2.9162341100377613, 0.016154217238288721)),
((-2, 1, -15),(-2.9297916190874878, 0.018200179642295464)),
((-2, 1, -14),(-2.9432619291746622, 0.01963693194788935)),
((-2, 1, -13),(-2.9566394893397008, 0.020423525906037802)),
((-2, 1, -12),(-2.969917963597128, 0.020515048732940841)),
((-2, 1, -11),(-2.9830901477844587, 0.019862187173828295)),
((-2, 1, -10),(-2.9961478753186297, 0.018410734449018508)),
((-2, 1, -9),(-3.0090819102230584, 0.016101031680140952)),
((-2, 1, -8),(-3.0218818254948414, 0.012867334033330943)),
((-2, 1, -7),(-3.0345358645247225, 0.008637090224791831)),
((-2, 1, -6),(-3.0470307828456087, 0.0033301221753511069)),
((-2, 1, -5),(-3.0593516669467413, -0.0031423105666652375)),
((-2, 1, -4),(-3.0714817262211529, -0.010878579534785101)),
((-2, 1, -3),(-3.0834020532749151, -0.019987910004500259)),
((-2, 1, -2),(-3.0950913467658867, -0.030591781781268802)),
((-2, 1, -1),(-3.1065255895857997, -0.042825536127287352)),
((-2, 1, 0),(-3.1176776734546721, -0.056840221161992686)),
((-2, 1, 1),(-3.1285169587244193, -0.07280471286596403)),
((-2, 1, 2),(-3.1390087551974237, -0.090908154003143435)),
((-2, 1, 3),(3.1340716013968124, -0.11136275867330883)),
((-2, 1, 4),(3.1243982577353626, -0.13440703548190311)),
((-2, 1, 5),(3.1152075746149586, -0.16030948689721536)),
((-2, 1, 6),(3.1065579794712335, -0.18937284533745402)),
((-2, 1, 7),(3.0985166026602404, -0.22193890648177397)),
((-2, 1, 8),(3.0911609300047442, -0.25839401515909799)),
((-2, 1, 9),(3.0845808838449518, -0.29917524606293044)),
((-2, 1, 10),(3.0788814812320062, -0.3447772967915817)),
((-2, 1, 11),(3.0741862836627254, -0.39576007028831728)),
((-2, 1, 12),(3.0706419542903856, -0.4527568648335677)),
((-2, 1, 13),(3.0684243994264535, -0.51648301489400805)),
((-2, 1, 14),(3.0677472336474154, -0.58774475330329912)),
((-2, 2, -15),(-3.1366085678242674, -0.19162477073908118)),
((-2, 2, -14),(3.1302576234549799, -0.19423785889316278)),
((-2, 2, -13),(3.1139514767008847, -0.19758349688951568)),
((-2, 2, -12),(3.0976612654560811, -0.20170245077352167)),
((-2, 2, -11),(3.081390530463938, -0.20663839908339063)),
((-2, 2, -10),(3.0651434371756374, -0.21243812506317017)),
((-2, 2, -9),(3.0489248304289327, -0.21915171719960067)),
((-2, 2, -8),(3.0327402936907757, -0.22683277694290863)),
((-2, 2, -7),(3.0165962130616295, -0.2355386319715603)),
((-2, 2, -6),(3.0004998462176959, -0.24533055273673721)),
((-2, 2, -5),(2.9844593964385671, -0.25627396925035778)),
((-2, 2, -4),(2.9684840918313489, -0.268438684134019)),
((-2, 2, -3),(2.9525842698178466, -0.28189907679579351)),
((-2, 2, -2),(2.9367714668992146, -0.29673429221627856)),
((-2, 2, -1),(2.9210585136536711, -0.3130284061732892)),
((-2, 2, 0),(2.9054596348591981, -0.33087055678648963)),
((-2, 2, 1),(2.8899905545681417, -0.35035502999580626)),
((-2, 2, 2),(2.8746686058990747, -0.37158128398828194)),
((-2, 2, 3),(2.8595128452607339, -0.3946538946645784)),
((-2, 2, 4),(2.844544170693216, -0.41968240102611987)),
((-2, 2, 5),(2.8297854440166588, -0.44678102594980629)),
((-2, 2, 6),(2.8152616165354836, -0.47606824434671668)),
((-2, 2, 7),(2.8009998581795017, -0.50766616740892268)),
((-2, 2, 8),(2.7870296902019871, -0.54169970888673391)),
((-2, 2, 9),(2.7733831219349367, -0.57829549760454257)),
((-2, 2, 10),(2.7600947926695962, -0.61758050039277579)),
((-2, 2, 11),(2.7472021205419792, -0.65968032216083872)),
((-2, 2, 12),(2.7347454614287283, -0.7047171560425074)),
((-2, 2, 13),(2.7227682823866663, -0.75280736767409706)),
((-2, 3, -12),(2.934579800719082, -0.37543972122466324)),
((-2, 3, -11),(2.9176709072172002, -0.38230464031066574)),
((-2, 3, -10),(2.900819183084721, -0.38995059390871123)),
((-2, 3, -9),(2.884031968930973, -0.39841079755044617)),
((-2, 3, -8),(2.8673173208094047, -0.4077198334169288)),
((-2, 3, -7),(2.8506840436372962, -0.41791363627351397)),
((-2, 3, -6),(2.8341417241691058, -0.42902946607314524)),
((-2, 3, -5),(2.8177007631177018, -0.44110586504466709)),
((-2, 3, -4),(2.8013724059742908, -0.45418259689638435)),
((-2, 3, -3),(2.7851687720375535, -0.46830056559253003)),
((-2, 3, -2),(2.7691028811275413, -0.48350171101177369)),
((-2, 3, -1),(2.7531886774329908, -0.49982887868497888)),
((-2, 3, 0),(2.7374410499246, -0.51732566074911046)),
((-2, 3, 1),(2.7218758487650967, -0.5360362052635973)),
((-2, 3, 2),(2.7065098971629573, -0.55600499113515434)),
((-2, 3, 3),(2.6913609981542232, -0.57727656611036549)),
((-2, 3, 4),(2.6764479358598083, -0.59989524564789465)),
((-2, 3, 5),(2.66179047085748, -0.62390477100097019)),
((-2, 3, 6),(2.6474093294319592, -0.64934792555362075)),
((-2, 3, 7),(2.63332618662553, -0.67626610938689347)),
((-2, 3, 8),(2.619563643207786, -0.70469887322757718)),
((-2, 3, 9),(2.6061451969174061, -0.7346834143685449)),
((-2, 3, 10),(2.5930952086010866, -0.76625403885438459)),
((-2, 3, 11),(2.5804388641843614, -0.79944159619371657)),
((-2, 4, -9),(2.7662716098051656, -0.53371259995208931)),
((-2, 4, -8),(2.7503408231106636, -0.54319868415434458)),
((-2, 4, -7),(2.7345469829879456, -0.55341227700219542)),
((-2, 4, -6),(2.7189000301774371, -0.56437503636985431)),
((-2, 4, -5),(2.7034104344765399, -0.57610884489830316)),
((-2, 4, -4),(2.6880891930469986, -0.58863573511774403)),
((-2, 4, -3),(2.6729478260435631, -0.60197780554814295)),
((-2, 4, -2),(2.65799836938108, -0.616157127472023)),
((-2, 4, -1),(2.6432533644859961, -0.63119564217486768)),
((-2, 4, 0),(2.6287258449151101, -0.64711504857301927)),
((-2, 4, 1),(2.6144293197693553, -0.66393668129806316)),
((-2, 4, 2),(2.6003777538837127, -0.68168137948152818)),
((-2, 4, 3),(2.586585544836034, -0.7003693466849038)),
((-2, 4, 4),(2.5730674968871381, -0.72002000264702659)),
((-2, 4, 5),(2.5598387920414969, -0.74065182777278038)),
((-2, 4, 6),(2.5469149585012882, -0.76228220156158588)),
((-2, 4, 7),(2.534311836875268, -0.78492723646783957)),
((-2, 4, 8),(2.5220455445964012, -0.80860160899362454)),
((-1, -5, -10),(-1.4223017712201291, 1.54833876937515)),
((-1, -5, -9),(-1.4093651956654165, 1.569640722143512)),
((-1, -5, -8),(-1.3957776443574506, 1.5906506421919817)),
((-1, -5, -7),(-1.3815370604073349, 1.6113511236532452)),
((-1, -5, -6),(-1.366642478766529, 1.6317247079678798)),
((-1, -5, -5),(-1.3510940893219072, 1.651753968371021)),
((-1, -5, -4),(-1.3348932933931397, 1.6714215963674204)),
((-1, -5, -3),(-1.3180427524922638, 1.6907104892260136)),
((-1, -5, -2),(-1.3005464282515264, 1.7096038374563505)),
((-1, -5, -1),(-1.2824096125016791, 1.7280852111813452)),
((-1, -5, 0),(-1.2636389465890874, 1.7461386442962714)),
((-1, -5, 1),(-1.2442424291554621, 1.7637487153048497)),
((-1, -5, 2),(-1.2242294117663888, 1.7809006237503524)),
((-1, -5, 3),(-1.2036105819609746, 1.797580261213187)),
((-1, -5, 4),(-1.1823979335001737, 1.8137742759251552)),
((-1, -5, 5),(-1.160604723810287, 1.8294701301526681)),
((-1, -5, 6),(-1.1382454188444615, 1.8446561496236042)),
((-1, -5, 7),(-1.1153356258118525, 1.8593215644114522)),
((-1, -5, 8),(-1.0918920144444579, 1.8734565408415178)),
((-1, -4, -13),(-1.5652384868565226, 1.3853684323814828)),
((-1, -4, -12),(-1.5528057823083659, 1.4108879319517065)),
((-1, -4, -11),(-1.5395349509118541, 1.4362694308357247)),
((-1, -4, -10),(-1.5254128120452619, 1.4614896350362352)),
((-1, -4, -9),(-1.5104275353063623, 1.4865241021494895)),
((-1, -4, -8),(-1.4945688399920847, 1.5113473335573213)),
((-1, -4, -7),(-1.4778281962724591, 1.5359328840963868)),
((-1, -4, -6),(-1.4601990248473624, 1.5602534890082638)),
((-1, -4, -5),(-1.4416768914617875, 1.5842812075314978)),
((-1, -4, -4),(-1.422259692300067, 1.6079875820228333)),
((-1, -4, -3),(-1.4019478260062708, 1.6313438110053389)),
((-1, -4, -2),(-1.3807443479118318, 1.6543209340550278)),
((-1, -4, -1),(-1.3586551020154396, 1.6768900259760504)),
((-1, -4, 0),(-1.3356888263740743, 1.6990223973001879)),
((-1, -4, 1),(-1.3118572278416465, 1.7206897978012687)),
((-1, -4, 2),(-1.2871750225402165, 1.7418646194602267)),
((-1, -4, 3),(-1.2616599390657925, 1.7625200951688091)),
((-1, -4, 4),(-1.2353326822048021, 1.7826304894323812)),
((-1, -4, 5),(-1.2082168558463671, 1.8021712774313761)),
((-1, -4, 6),(-1.1803388447880863, 1.8211193090267861)),
((-1, -4, 7),(-1.1517276562092003, 1.8394529546404133)),
((-1, -4, 8),(-1.1224147226792021, 1.8571522303918424)),
((-1, -4, 9),(-1.0924336696325214, 1.8741989004109447)),
((-1, -4, 10),(-1.0618200512220664, 1.8905765548431175)),
((-1, -4, 11),(-1.0306110593197699, 1.906270662696508)),
((-1, -4, 12),(-0.99884521112173363, 1.92126859931789)),
((-1, -3, -15),(-1.7414478646842444, 1.1795108147937547)),
((-1, -3, -14),(-1.7301641847753189, 1.2083231994237558)),
((-1, -3, -13),(-1.7178062822486646, 1.2372826085315882)),
((-1, -3, -12),(-1.7043362152291894, 1.2663708540301248)),
((-1, -3, -11),(-1.6897164292348839, 1.2955668435644194)),
((-1, -3, -10),(-1.673910173543756, 1.3248464474980153)),
((-1, -3, -9),(-1.6568819730212438, 1.3541823914443791)),
((-1, -3, -8),(-1.63859815510582, 1.3835441814134193)),
((-1, -3, -7),(-1.619027429593245, 1.412898068935192)),
((-1, -3, -6),(-1.5981415163620034, 1.4422070635366011)),
((-1, -3, -5),(-1.5759158132720821, 1.4714309996101935)),
((-1, -3, -4),(-1.5523300932165822, 1.5005266639610397)),
((-1, -3, -3),(-1.5273692158330308, 1.5294479890985819)),
((-1, -3, -2),(-1.5010238358674799, 1.5581463156309199)),
((-1, -3, -1),(-1.4732910868653331, 1.5865707249304133)),
((-1, -3, 0),(-1.444175216023087, 1.6146684406259559)),
((-1, -3, 1),(-1.4136881439921001, 1.6423852945410897)),
((-1, -3, 2),(-1.3818499225033798, 1.6696662495893566)),
((-1, -3, 3),(-1.3486890631762154, 1.6964559690511034)),
((-1, -3, 4),(-1.3142427130093381, 1.7226994188107594)),
((-1, -3, 5),(-1.2785566559461525, 1.7483424867609716)),
((-1, -3, 6),(-1.2416851255229715, 1.7733326018953544)),
((-1, -3, 7),(-1.2036904207489598, 1.7976193347903904)),
((-1, -3, 8),(-1.1646423256526997, 1.821154961330689)),
((-1, -3, 9),(-1.1246173418335996, 1.8438949726908513)),
((-1, -3, 10),(-1.0836977522385727, 1.8657985166935689)),
((-1, -3, 11),(-1.0419705425625261, 1.8868287585740249)),
((-1, -3, 12),(-0.99952621349354609, 1.9069531526813754)),
((-1, -3, 13),(-0.95645752194571765, 1.926143620478352)),
((-1, -3, 14),(-0.91285819207161267, 1.944376634081628)),
((-1, -2, -17),(-1.9783296348340551, 0.89136067959089771)),
((-1, -2, -16),(-1.9713187456923786, 0.92007792748068451)),
((-1, -2, -15),(-1.9631053084908032, 0.94927688748118721)),
((-1, -2, -14),(-1.953611748027819, 0.97897383651766712)),
((-1, -2, -13),(-1.942755293123795, 1.0091835131590017)),
((-1, -2, -12),(-1.9304479625214923, 1.0399186608816493)),
((-1, -2, -11),(-1.9165966601917725, 1.0711894957584118)),
((-1, -2, -10),(-1.9011034136526932, 1.1030030933213535)),
((-1, -2, -9),(-1.8838657949614435, 1.1353626913507802)),
((-1, -2, -8),(-1.8647775700542246, 1.1682669084219002)),
((-1, -2, -7),(-1.8437296274784165, 1.2017088824432269)),
((-1, -2, -6),(-1.8206112413791629, 1.2356753393693272)),
((-1, -2, -5),(-1.7953117246140589, 1.2701456099185175)),
((-1, -2, -4),(-1.7677225244445973, 1.30509062148945)),
((-1, -2, -3),(-1.7377398034198253, 1.3404719033410482)),
((-1, -2, -2),(-1.7052675296506781, 1.3762406549474673)),
((-1, -2, -1),(-1.6702210715807224, 1.4123369393172498)),
((-1, -2, 0),(-1.6325312510620209, 1.4486890735512201)),
((-1, -2, 1),(-1.5921487547591304, 1.4852132961191049)),
((-1, -2, 2),(-1.5490487394215193, 1.5218137920364458)),
((-1, -2, 3),(-1.5032353960825644, 1.5583831510442048)),
((-1, -2, 4),(-1.4547461699235573, 1.594803318153041)),
((-1, -2, 5),(-1.4036552779206741, 1.630947069598687)),
((-1, -2, 6),(-1.3500761392687148, 1.66668001100162)),
((-1, -2, 7),(-1.2941623476347339, 1.7018630509394921)),
((-1, -2, 8),(-1.2361068796471357, 1.7363552568519929)),
((-1, -2, 9),(-1.1761393533277689, 1.7700169573821132)),
((-1, -2, 10),(-1.1145213155561446, 1.8027129226258665)),
((-1, -2, 11),(-1.0515397298530962, 1.8343154371700559)),
((-1, -2, 12),(-0.9874990264815634, 1.8647070838383566)),
((-1, -2, 13),(-0.92271223430650895, 1.8937830790783536)),
((-1, -2, 14),(-0.85749181025866217, 1.9214530407628752)),
((-1, -2, 15),(-0.79214080090168648, 1.9476421198646601)),
((-1, -1, -17),(-2.2758321696961494, 0.57877354735385955)),
((-1, -1, -16),(-2.2759567222043038, 0.60184800051661669)),
((-1, -1, -15),(-2.2750498842731108, 0.6253842492290298)),
((-1, -1, -14),(-2.2730128056647501, 0.64942600074730372)),
((-1, -1, -13),(-2.2697334053690512, 0.67402122731672343)),
((-1, -1, -12),(-2.2650843646281285, 0.69922267525197246)),
((-1, -1, -11),(-2.258920789151007, 0.72508842484521852)),
((-1, -1, -10),(-2.2510774915149838, 0.75168249977020241)),
((-1, -1, -9),(-2.2413658431663008, 0.77907552042286599)),
((-1, -1, -8),(-2.2295701482473498, 0.80734538899634412)),
((-1, -1, -7),(-2.2154435022317776, 0.83657798392405613)),
((-1, -1, -6),(-2.1987031227029585, 0.86686782610010515)),
((-1, -1, -5),(-2.179025186417046, 0.89831865690676926)),
((-1, -1, -4),(-2.1560392895707712, 0.93104383579552175)),
((-1, -1, -3),(-2.1293227869938116, 0.96516641955541216)),
((-1, -1, -2),(-2.098395489347487, 1.0008187225688625)),
((-1, -1, -1),(-2.0627155435389866, 1.0381410736442436)),
((-1, -1, 0),(-2.0216778364458423, 1.0772793786701926)),
((-1, -1, 1),(-1.9746169898275954, 1.1183809728698957)),
((-1, -1, 2),(-1.9208179710306377, 1.1615881166443547)),
((-1, -1, 3),(-1.8595384611758194, 1.2070283905037682)),
((-1, -1, 4),(-1.7900481443860699, 1.2548012464320695)),
((-1, -1, 5),(-1.7116904161688737, 1.3049601890846023)),
((-1, -1, 6),(-1.6239705846419192, 1.357490647222372)),
((-1, -1, 7),(-1.5266699469518212, 1.4122847140776518)),
((-1, -1, 8),(-1.4199758065640098, 1.4691156414051583)),
((-1, -1, 9),(-1.3046038513558524, 1.5276170328468719)),
((-1, -1, 10),(-1.1818754693106903, 1.5872733837389601)),
((-1, -1, 11),(-1.0537074988571615, 1.6474287723598442)),
((-1, -1, 12),(-0.92248587136463078, 1.707317953338086)),
((-1, -1, 13),(-0.7908300738153109, 1.7661186535445859)),
((-1, -1, 14),(-0.66129881728667805, 1.8230171469618368)),
((-1, -1, 15),(-0.53611371336674796, 1.8772742586865989)),
((-1, -1, 16),(-0.41696946697714049, 1.9282785080028921)),
((-1, 0, -17),(-2.6304358112854382, 0.22130560946858746)),
((-1, 0, -16),(-2.6423432938486902, 0.23265031758922181)),
((-1, 0, -15),(-2.6540131022373181, 0.24371713142818605)),
((-1, 0, -14),(-2.6654234505928693, 0.25447979382001967)),
((-1, 0, -13),(-2.6765486973173926, 0.2649075036020595)),
((-1, 0, -12),(-2.6873585926840216, 0.2749640255020615)),
((-1, 0, -11),(-2.6978173384657014, 0.28460657759581076)),
((-1, 0, -10),(-2.7078824028601214, 0.29378442912342151)),
((-1, 0, -9),(-2.717503013440878, 0.30243711708889004)),
((-1, 0, -8),(-2.7266182215184771, 0.31049215526871465)),
((-1, 0, -7),(-2.7351543887372873, 0.31786205879094798)),
((-1, 0, -6),(-2.7430218839781464, 0.32444043303551845)),
((-1, 0, -5),(-2.7501106843817138, 0.33009676386822068)),
((-1, 0, -4),(-2.7562844298510929, 0.33466937501991262)),
((-1, 0, -3),(-2.7613722539703716, 0.33795575020569046)),
((-1, 0, -2),(-2.7651573503749076, 0.33969898679466226)),
((-1, 0, -1),(-2.7673606320414992, 0.3395684363742667)),
((-1, 0, 0),(-2.7676168142294859, 0.33713137480031641)),
((-1, 0, 1),(-2.7654384341381517, 0.33181040107455262)),
((-1, 0, 2),(-2.7601599633411076, 0.32281731532030339)),
((-1, 0, 3),(-2.7508476533478996, 0.30904658533195223)),
((-1, 0, 4),(-2.7361473359800779, 0.28889584211809982)),
((-1, 0, 5),(-2.7140126962581741, 0.25994635865816723)),
((-1, 0, 6),(-2.6811845599992714, 0.21835356097172631)),
((-1, 0, 7),(-2.6320955857387323, 0.15757415324245172)),
((-1, 0, 8),(-2.5562465452264274, 0.065351811919026337)),
((-1, 0, 9),(-2.4305358552392473, -0.084929070414013194)),
((-1, 0, 10),(-2.1867730156425362, -0.36965123645568493)),
((-1, 1, -17),(-2.966308687169966, -0.10175589616337215)),
((-1, 1, -16),(-2.9876665871363186, -0.10105219015998403)),
((-1, 1, -15),(-3.009352180062888, -0.10126790435278231)),
((-1, 1, -14),(-3.031394466493043, -0.10248474449754615)),
((-1, 1, -13),(-3.053824896513158, -0.10479465242523209)),
((-1, 1, -12),(-3.0766776386105983, -0.10830125644616737)),
((-1, 1, -11),(-3.0999898733476168, -0.11312154877399311)),
((-1, 1, -10),(-3.1238021117537138, -0.11938782362337449)),
((-1, 1, -9),(3.1350267702777934, -0.12724991219357915)),
((-1, 1, -8),(3.1100779422522935, -0.13687775175942726)),
((-1, 1, -7),(3.084484088732542, -0.148464324170725)),
((-1, 1, -6),(3.0581878066920658, -0.16222899200950641)),
((-1, 1, -5),(3.0311265571477013, -0.17842124503523407)),
((-1, 1, -4),(3.0032323568430379, -0.19732484009517107)),
((-1, 1, -3),(2.97443155996856, -0.21926226648760105)),
((-1, 1, -2),(2.9446447919629453, -0.24459938426561545)),
((-1, 1, -1),(2.9137871234386941, -0.27374994875575759)),
((-1, 1, 0),(2.8817686065353647, -0.30717952846265645)),
((-1, 1, 1),(2.8484953396280619, -0.34540801771726926)),
((-1, 1, 2),(2.8138712791749101, -0.38900950950781388)),
((-1, 1, 3),(2.7778010766828349, -0.43860770449406811)),
((-1, 1, 4),(2.7401942761660147, -0.4948642948507615)),
((-1, 1, 5),(2.7009712460433133, -0.55845695376649263)),
((-1, 1, 6),(2.6600712088327159, -0.63004290344649527)),
((-1, 1, 7),(2.6174626250012443, -0.7102039838762797)),
((-1, 1, 8),(2.5731559210395369, -0.79937047168651576)),
((-1, 1, 9),(2.5272180613075479, -0.89772462490302196)),
((-1, 1, 10),(2.4797877166559359, -1.0050919184593838)),
((-1, 1, 11),(2.4310888429764046, -1.1208379303870397)),
((-1, 1, 12),(2.3814395783315683, -1.2437991115474563)),
((-1, 1, 13),(2.3312529207266657, -1.3722803418750655)),
((-1, 1, 14),(2.2810261757709052, -1.5041441089625256)),
((-1, 1, 15),(2.2313179935286889, -1.636992359376646)),
((-1, 1, 16),(2.1827147274733227, -1.768409539861133)),
((-1, 2, -16),(3.0324230553743385, -0.35068439154093728)),
((-1, 2, -15),(3.0075710395910829, -0.35634235310704732)),
((-1, 2, -14),(2.982410695160147, -0.36305526979409047)),
((-1, 2, -13),(2.956932187865998, -0.3708894446586114)),
((-1, 2, -12),(2.9311265523231498, -0.37991587982892566)),
((-1, 2, -11),(2.9049859145824963, -0.39021043454637694)),
((-1, 2, -10),(2.8785037499703443, -0.40185393593821334)),
((-1, 2, -9),(2.8516751791934958, -0.41493222422146275)),
((-1, 2, -8),(2.8244973053108176, -0.42953610993753766)),
((-1, 2, -7),(2.7969695934306769, -0.44576121623478604)),
((-1, 2, -6),(2.7690942938596037, -0.46370767427136711)),
((-1, 2, -5),(2.7408769078098767, -0.48347963473292666)),
((-1, 2, -4),(2.712326692581537, -0.50518455362521808)),
((-1, 2, -3),(2.6834572002904347, -0.52893220648285177)),
((-1, 2, -2),(2.6542868406703355, -0.55483338274108074)),
((-1, 2, -1),(2.6248394542386664, -0.58299821232960936)),
((-1, 2, 0),(2.5951448772696071, -0.61353408092751627)),
((-1, 2, 1),(2.5652394747652281, -0.64654310036304341)),
((-1, 2, 2),(2.5351666123009151, -0.6821191180608035)),
((-1, 2, 3),(2.504977032757655, -0.72034427581795246)),
((-1, 2, 4),(2.4747291002223166, -0.76128516461954043)),
((-1, 2, 5),(2.4444888715583328, -0.8049886687601302)),
((-1, 2, 6),(2.4143299572092851, -0.85147764767718603)),
((-1, 2, 7),(2.3843331375224812, -0.90074666384022783)),
((-1, 2, 8),(2.3545857098630156, -0.95275802334622461)),
((-1, 2, 9),(2.3251805551959595, -1.0074384434945709)),
((-1, 2, 10),(2.2962149301972787, -1.0646766876316793)),
((-1, 2, 11),(2.2677890111377432, -1.1243225008186337)),
((-1, 2, 12),(2.240004236878002, -1.1861871315046892)),
((-1, 2, 13),(2.2129615178882207, -1.2500456307000245)),
((-1, 2, 14),(2.1867593936453451, -1.315640985237934)),
((-1, 2, 15),(2.1614922297165249, -1.3826899787342275)),
((-1, 3, -14),(2.8027663497305126, -0.54131648967659929)),
((-1, 3, -13),(2.7786074765857149, -0.55040404133028153)),
((-1, 3, -12),(2.7543626695574099, -0.56044580020656898)),
((-1, 3, -11),(2.7300418761532295, -0.5714801805471833)),
((-1, 3, -10),(2.7056567020969773, -0.58354638340928355)),
((-1, 3, -9),(2.6812205117755799, -0.59668419124187666)),
((-1, 3, -8),(2.6567485234241928, -0.61093372094463883)),
((-1, 3, -7),(2.6322578963014203, -0.62633513174952116)),
((-1, 3, -6),(2.6077678067733063, -0.64292828470931862)),
((-1, 3, -5),(2.5832995099284055, -0.66075235127443166)),
((-1, 3, -4),(2.5588763831116235, -0.67984536943266805)),
((-1, 3, -3),(2.5345239476195696, -0.70024374721558347)),
((-1, 3, -2),(2.5102698647753332, -0.72198171506716524)),
((-1, 3, -1),(2.4861439027263765, -0.74509073063897246)),
((-1, 3, 0),(2.4621778706146928, -0.76959884200953788)),
((-1, 3, 1),(2.4384055172770371, -0.79553001808346901)),
((-1, 3, 2),(2.4148623923602259, -0.82290345792834241)),
((-1, 3, 3),(2.3915856686856052, -0.85173289393374763)),
((-1, 3, 4),(2.3686139258549699, -0.88202590675928982)),
((-1, 3, 5),(2.3459868964278225, -0.91378327286781047)),
((-1, 3, 6),(2.3237451774662414, -0.9469983677705226)),
((-1, 3, 7),(2.301929911771126, -0.98165664967727906)),
((-1, 3, 8),(2.2805824446373935, -1.0177352487828404)),
((-1, 3, 9),(2.2597439633410077, -1.05520268669301)),
((-1, 3, 10),(2.2394551277399719, -1.0940187483277706)),
((-1, 3, 11),(2.2197557012319464, -1.1341345249479071)),
((-1, 3, 12),(2.2006841917870821, -1.1754926417733211)),
((-1, 3, 13),(2.1822775128130698, -1.2180276771669867)),
((-1, 3, 14),(2.1645706731901093, -1.2616667728616324)),
((-1, 4, -11),(2.6191615923930476, -0.69468181307242771)),
((-1, 4, -10),(2.5977227951049127, -0.70578541078379753)),
((-1, 4, -9),(2.5763940175764657, -0.71769468267067793)),
((-1, 4, -8),(2.5551906789328021, -0.73042864209372715)),
((-1, 4, -7),(2.5341291027202608, -0.74400574920869578)),
((-1, 4, -6),(2.5132264910392412, -0.75844374925605007)),
((-1, 4, -5),(2.4925008894384701, -0.77375950035944896)),
((-1, 4, -4),(2.4719711420959114, -0.78996879195283343)),
((-1, 4, -3),(2.4516568369563925, -0.80708615533399874)),
((-1, 4, -2),(2.4315782406700737, -0.82512466824437181)),
((-1, 4, -1),(2.4117562233770364, -0.84409575578985518)),
((-1, 4, 0),(2.3922121736087134, -0.86400899043353507)),
((-1, 4, 1),(2.3729679038212161, -0.88487189419171852)),
((-1, 4, 2),(2.3540455473325639, -0.9066897465325805)),
((-1, 4, 3),(2.3354674476972956, -0.92946540179198445)),
((-1, 4, 4),(2.3172560418084207, -0.95319912016302599)),
((-1, 4, 5),(2.2994337382580743, -0.97788841646432201)),
((-1, 4, 6),(2.2820227927039411, -1.0035279309278713)),
((-1, 4, 7),(2.265045182168004, -1.0301093261542034)),
((-1, 4, 8),(2.2485224803279658, -1.0576212141484611)),
((-1, 4, 9),(2.2324757359418164, -1.0860491169696749)),
((-1, 4, 10),(2.2169253565664655, -1.115375463997003)),
((-1, 4, 11),(2.2018909996891352, -1.1455796281491686)),
((-1, 5, -7),(2.4727046265106227, -0.82711441295408206)),
((-1, 5, -6),(2.4547517210730585, -0.83962092694638513)),
((-1, 5, -5),(2.4370313479601005, -0.85279514124207856)),
((-1, 5, -4),(2.4195568927974311, -0.86664477623877068)),
((-1, 5, -3),(2.4023419634279146, -0.88117677352898638)),
((-1, 5, -2),(2.3854003435152369, -0.89639721750686241)),
((-1, 5, -1),(2.3687459434104947, -0.91231125828609705)),
((-1, 5, 0),(2.3523927486698346, -0.92892303690742406)),
((-1, 5, 1),(2.3363547666773523, -0.94623561387551991)),
((-1, 5, 2),(2.3206459718891441, -0.9642509021116813)),
((-1, 5, 3),(2.3052802502696736, -0.98296960543692447)),
((-1, 5, 4),(2.2902713435385298, -1.002391163707689)),
((-1, 5, 5),(2.2756327938823473, -1.0225137057107787)),
((-1, 5, 6),(2.2613778898118571, -1.0433340108841187)),
((-1, 5, 7),(2.2475196138560105, -1.0648474808639055)),
((0, -5, -9),(-1.1691683245330327, 1.8004341975687961)),
((0, -5, -8),(-1.1549169614189114, 1.8235000712066969)),
((0, -5, -7),(-1.1401143773609781, 1.8460706669918843)),
((0, -5, -6),(-1.1247692066710087, 1.8681286040355805)),
((0, -5, -5),(-1.1088911056387225, 1.8896573981240894)),
((0, -5, -4),(-1.0924907308342064, 1.9106415494455224)),
((0, -5, -3),(-1.0755797076504292, 1.9310666207227569)),
((0, -5, -2),(-1.0581705893174036, 1.9509193048385947)),
((0, -5, -1),(-1.0402768067893853, 1.9701874812280027)),
((0, -5, 0),(-1.0219126100699536, 1.9888602605165069)),
((0, -5, 1),(-1.0030930016921511, 2.0069280170973482)),
((0, -5, 2),(-0.98383366320674392, 2.0243824095556406)),
((0, -5, 3),(-0.96415087564725099, 2.0412163890592843)),
((0, -5, 4),(-0.94406143503205986, 2.0574241960373221)),
((0, -5, 5),(-0.92358256402927252, 2.0730013456512193)),
((0, -5, 6),(-0.90273182094760152, 2.0879446027286477)),
((0, -5, 7),(-0.88152700722620081, 2.1022519469688556)),
((0, -5, 8),(-0.85998607457865794, 2.1159225293413471)),
((0, -4, -13),(-1.2821641053665989, 1.6468666295270351)),
((0, -4, -12),(-1.2674515804837547, 1.6774032903592317)),
((0, -4, -11),(-1.2519796826329199, 1.7075334731669776)),
((0, -4, -10),(-1.2357546712707259, 1.7372196564169433)),
((0, -4, -9),(-1.218784940089592, 1.7664245567195194)),
((0, -4, -8),(-1.2010810697503302, 1.7951114309070269)),
((0, -4, -7),(-1.1826558551441007, 1.8232443777687526)),
((0, -4, -6),(-1.1635243052618105, 1.8507886338218804)),
((0, -4, -5),(-1.1437036143275408, 1.8777108574623904)),
((0, -4, -4),(-1.1232131035191977, 1.9039793960045646)),
((0, -4, -3),(-1.1020741333301984, 1.9295645304811433)),
((0, -4, -2),(-1.0803099873907283, 1.9544386936259808)),
((0, -4, -1),(-1.0579457293325751, 1.9785766571742425)),
((0, -4, 0),(-1.0350080350129789, 2.001955685459532)),
((0, -4, 1),(-1.0115250030759964, 2.0245556532230475)),
((0, -4, 2),(-0.9875259473940089, 2.0463591265332264)),
((0, -4, 3),(-0.9630411753715854, 2.0673514067000434)),
((0, -4, 4),(-0.93810175639059645, 2.0875205380125434)),
((0, -4, 5),(-0.91273928481928956, 2.1068572809926458)),
((0, -4, 6),(-0.88698564199750229, 2.1253550536105155)),
((0, -4, 7),(-0.86087276145232616, 2.1430098435232261)),
((0, -4, 8),(-0.834432401307873, 2.159820094864624)),
((0, -4, 9),(-0.80769592744992735, 2.1757865734249724)),
((0, -4, 10),(-0.78069411051589699, 2.1909122142172603)),
((0, -4, 11),(-0.75345693922993007, 2.2052019554437265)),
((0, -4, 12),(-0.72601345201966361, 2.2186625627671388)),
((0, -3, -15),(-1.4081991224572259, 1.4692300256341491)),
((0, -3, -14),(-1.3916464243668003, 1.5084779065679847)),
((0, -3, -13),(-1.3739743404920211, 1.5476429827501872)),
((0, -3, -12),(-1.355179401621013, 1.5866566754092379)),
((0, -3, -11),(-1.335262853719243, 1.6254464001329243)),
((0, -3, -10),(-1.3142310795663896, 1.6639362288756268)),
((0, -3, -9),(-1.2920959606415969, 1.702047670517074)),
((0, -3, -8),(-1.2688751614402922, 1.739700556440664)),
((0, -3, -7),(-1.2445923192825323, 1.7768140115738287)),
((0, -3, -6),(-1.2192771246644476, 1.8133074858211444)),
((0, -3, -5),(-1.1929652803346111, 1.84910181630134)),
((0, -3, -4),(-1.1656983314659863, 1.8841202877118557)),
((0, -3, -3),(-1.1375233643480813, 1.9182896568334482)),
((0, -3, -2),(-1.1084925766445033, 1.9515411078535916)),
((0, -3, -1),(-1.0786627280649492, 1.9838111078535825)),
((0, -3, 0),(-1.0480944858574381, 2.0150421363039914)),
((0, -3, 1),(-1.0168516844053388, 2.045183268405605)),
((0, -3, 2),(-0.98500052203186761, 2.0741905991207039)),
((0, -3, 3),(-0.95260872058389845, 2.1020275022058454)),
((0, -3, 4),(-0.91974467432513707, 2.1286647259113534)),
((0, -3, 5),(-0.88647661409578993, 2.1540803337328498)),
((0, -3, 6),(-0.85287181071023621, 2.178259504266987)),
((0, -3, 7),(-0.81899583840063184, 2.2011942085529643)),
((0, -3, 8),(-0.78491191509001668, 2.2228827861383538)),
((0, -3, 9),(-0.75068033175099735, 2.2433294424984727)),
((0, -3, 10),(-0.71635797843274385, 2.2625436904880196)),
((0, -3, 11),(-0.68199797004142282, 2.2805397574230346)),
((0, -3, 12),(-0.64764937089684982, 2.2973359774407305)),
((0, -3, 13),(-0.6133570136456582, 2.3129541862408782)),
((0, -3, 14),(-0.57916140539409389, 2.3274191324385294)),
((0, -3, 15),(-0.54509871196423343, 2.3407579167842725)),
((0, -2, -17),(-1.6125342991198492, 1.1595432044852867)),
((0, -2, -16),(-1.5953620460271281, 1.2073962161665062)),
((0, -2, -15),(-1.5763864249853297, 1.2562622727205348)),
((0, -2, -14),(-1.5555395535523542, 1.3060941271975257)),
((0, -2, -13),(-1.5327601770307657, 1.3568246070055858)),
((0, -2, -12),(-1.5079962132395288, 1.4083646837207753)),
((0, -2, -11),(-1.4812075466576062, 1.4606019756145157)),
((0, -2, -10),(-1.4523689831489996, 1.5133998863259228)),
((0, -2, -9),(-1.4214732344968495, 1.5665975874150184)),
((0, -2, -8),(-1.3885337597280616, 1.6200110335162865)),
((0, -2, -7),(-1.353587253989504, 1.6734351510599219)),
((0, -2, -6),(-1.3166955533847777, 1.7266472632602547)),
((0, -2, -5),(-1.2779467238985753, 1.7794117090447927)),
((0, -2, -4),(-1.237455131022652, 1.8314854921793486)),
((0, -2, -3),(-1.1953603469274934, 1.8826246754875633)),
((0, -2, -2),(-1.1518248413017549, 1.9325911337871218)),
((0, -2, -1),(-1.1070305110746603, 1.9811592173099128)),
((0, -2, 0),(-1.0611742182229884, 2.0281218686695417)),
((0, -2, 1),(-1.0144626058542214, 2.073295784993439)),
((0, -2, 2),(-0.96710653390107826, 2.1165253155230253)),
((0, -2, 3),(-0.9193155053632065, 2.15768491697622)),
((0, -2, 4),(-0.87129243839349391, 2.1966801319502447)),
((0, -2, 5),(-0.82322908359075098, 2.2334471872921142)),
((0, -2, 6),(-0.77530230149797086, 2.2679514122454463)),
((0, -2, 7),(-0.72767131797804274, 2.3001847406953138)),
((0, -2, 8),(-0.68047598014044208, 2.3301625866843225)),
((0, -2, 9),(-0.63383595489979072, 2.3579203729680431)),
((0, -2, 10),(-0.58785075328130421, 2.3835099581013433)),
((0, -2, 11),(-0.54260042845898693, 2.4069961589422575)),
((0, -2, 12),(-0.49814678238088095, 2.428453512041906)),
((0, -2, 13),(-0.45453492030963472, 2.4479633663874254)),
((0, -2, 14),(-0.41179500925714668, 2.4656113559520558)),
((0, -2, 15),(-0.36994411983693759, 2.4814852656421977)),
((0, -2, 16),(-0.32898805709982404, 2.4956732788397491)),
((0, -1, -17),(-1.9414620662993445, 0.73682758794254977)),
((0, -1, -16),(-1.9276048463387523, 0.78421629089586042)),
((0, -1, -15),(-1.9108929341266159, 0.83443328491493918)),
((0, -1, -14),(-1.8909831872428327, 0.88779211384403711)),
((0, -1, -13),(-1.8674911486908969, 0.9446265952621572)),
((0, -1, -12),(-1.8399913150490406, 1.0052825878201876)),
((0, -1, -11),(-1.8080211008790705, 1.0701037191824743)),
((0, -1, -10),(-1.7710906349034654, 1.1394087877719323)),
((0, -1, -9),(-1.7287011471175371, 1.2134584358247937)),
((0, -1, -8),(-1.680375102078564, 1.2924092722179419)),
((0, -1, -7),(-1.6257009307343857, 1.3762555043795572)),
((0, -1, -6),(-1.5643934875504253, 1.4647619580316718)),
((0, -1, -5),(-1.4963674138620635, 1.5573983170389869)),
((0, -1, -4),(-1.4218141297263556, 1.6532914035145803)),
((0, -1, -3),(-1.3412654231808641, 1.7512171330563409)),
((0, -1, -2),(-1.2556211348079191, 1.8496514959646158)),
((0, -1, -1),(-1.1661204713174087, 1.9468867638027754)),
((0, -1, 0),(-1.0742494773473581, 2.0411971277939114)),
((0, -1, 1),(-0.98159825624657793, 2.1310170378685247)),
((0, -1, 2),(-0.88970057677141212, 2.2150882703281627)),
((0, -1, 3),(-0.79989446720171675, 2.2925435779491923)),
((0, -1, 4),(-0.71323205128060219, 2.3629186578244825)),
((0, -1, 5),(-0.63044729639749142, 2.4261065012175305)),
((0, -1, 6),(-0.55197256342683443, 2.482279293087859)),
((0, -1, 7),(-0.47798579057401525, 2.5318021372689246)),
((0, -1, 8),(-0.40846998101243476, 2.5751552027523599)),
((0, -1, 9),(-0.34327158781281653, 2.6128721658296201)),
((0, -1, 10),(-0.28215040019872067, 2.6454963185725142)),
((0, -1, 11),(-0.2248183255306041, 2.6735521329330547)),
((0, -1, 12),(-0.17096739972217218, 2.6975287651720636)),
((0, -1, 13),(-0.12028873576760708, 2.7178720082657746)),
((0, -1, 14),(-0.072484490998817208, 2.7349818015063141)),
((0, -1, 15),(-0.027274782537352816, 2.749213141017945)),
((0, -1, 16),(0.015598873801588819, 2.7608788933246076)),
((0, -1, 17),(0.056372409560768548, 2.7702535283459624)),
((0, 0, -17),(-2.5121299174267175, 0.11931118067908661)),
((0, 0, -16),(-2.5274385320248984, 0.13461979527726745)),
((0, 0, -15),(-2.5426900618813693, 0.14987132513373852)),
((0, 0, -14),(-2.5578886507428389, 0.16506991399520829)),
((0, 0, -13),(-2.5730383222090163, 0.18021958546138522)),
((0, 0, -12),(-2.5881429907956646, 0.19532425404803352)),
((0, 0, -11),(-2.6032064722842359, 0.21038773553660475)),
((0, 0, -10),(-2.6182324934400847, 0.22541375669245359)),
((0, 0, -9),(-2.6332247011746261, 0.24040596442699511)),
((0, 0, -8),(-2.6481866712166928, 0.25536793446906181)),
((0, 0, -7),(-2.6631219163563258, 0.2703031796086951)),
((0, 0, -6),(-2.6780338943149964, 0.28521515756736532)),
((0, 0, -5),(-2.6929260152949439, 0.30010727854731295)),
((0, 0, -4),(-2.7078016492541366, 0.31498291250650551)),
((0, 0, -3),(-2.722664132952878, 0.32984539620524705)),
((0, 0, -2),(-2.7375167768128401, 0.34469804006520893)),
((0, 0, -1),(-2.7523628716285096, 0.35954413488087872)),
((0, 0, 1),(0.38922978196128366, -2.7820485187089146)),
((0, 0, 2),(0.40407587677695328, -2.7968946135245845)),
((0, 0, 3),(0.41892852063691527, -2.8117472573845461)),
((0, 0, 4),(0.43379100433565676, -2.8266097410832876)),
((0, 0, 5),(0.44866663829484943, -2.8414853750424802)),
((0, 0, 6),(0.46355875927479706, -2.8563774960224277)),
((0, 0, 7),(0.4784707372334675, -2.8712894739810984)),
((0, 0, 8),(0.49340598237310046, -2.8862247191207313)),
((0, 0, 9),(0.50836795241516719, -2.901186689162798)),
((0, 0, 10),(0.52336016014970865, -2.9161788968973394)),
((0, 0, 11),(0.5383861813055576, -2.9312049180531883)),
((0, 0, 12),(0.55344966279412877, -2.9462683995417596)),
((0, 0, 13),(0.56855433138077704, -2.9613730681284078)),
((0, 0, 14),(0.58370400284695423, -2.9765227395945848)),
((0, 0, 15),(0.59890259170842386, -2.9917213284560549)),
((0, 0, 16),(0.61415412156489491, -3.0069728583125257)),
((0, 0, 17),(0.62946273616307569, -3.0222814729107066)),
((0, 1, -17),(-3.0852202440290246, -0.371339125243831)),
((0, 1, -16),(-3.1259937797882045, -0.38071376026518555)),
((0, 1, -15),(3.1143178710524406, -0.39237951257184811)),
((0, 1, -14),(3.0691081625909762, -0.40661085208347902)),
((0, 1, -13),(3.0213039178221863, -0.42372064532401849)),
((0, 1, -12),(2.9706252538676212, -0.4440638884177297)),
((0, 1, -11),(2.9167743280591893, -0.46804052065673846)),
((0, 1, -10),(2.8594422533910726, -0.49609633501727879)),
((0, 1, -9),(2.7983210657769768, -0.52872048776017333)),
((0, 1, -8),(2.7331226725773585, -0.56643745083743335)),
((0, 1, -7),(2.6636068630157781, -0.60979051632086878)),
((0, 1, -6),(2.5896200901629589, -0.65931336050193401)),
((0, 1, -5),(2.5111453571923019, -0.71548615237226287)),
((0, 1, -4),(2.428360602309191, -0.7786739957653106)),
((0, 1, -3),(2.3416981863880766, -0.84904907564060117)),
((0, 1, -2),(2.2518920768183812, -0.92650438326163043)),
((0, 1, -1),(2.1599943973432154, -1.0105756157212686)),
((0, 1, 0),(2.067343176242435, -1.100395525795882)),
((0, 1, 1),(1.9754721822723846, -1.1947058897870177)),
((0, 1, 2),(1.8859715187818742, -1.2919411576251774)),
((0, 1, 3),(1.8003272304089293, -1.3903755205334523)),
((0, 1, 4),(1.7197785238634378, -1.4883012500752129)),
((0, 1, 5),(1.6452252397277296, -1.5841943365508064)),
((0, 1, 6),(1.5771991660393681, -1.6768306955581214)),
((0, 1, 7),(1.5158917228554074, -1.7653371492102361)),
((0, 1, 8),(1.4612175515112293, -1.8491833813718512)),
((0, 1, 9),(1.412891506472256, -1.9281342177649994)),
((0, 1, 10),(1.3705020186863277, -2.002183865817861)),
((0, 1, 11),(1.3335715527107228, -2.0714889344073191)),
((0, 1, 12),(1.3016013385407526, -2.1363100657696057)),
((0, 1, 13),(1.2741015048988964, -2.1969660583276363)),
((0, 1, 14),(1.2506094663469607, -2.2538005397457561)),
((0, 1, 15),(1.2306997194631772, -2.3071593686748542)),
((0, 1, 16),(1.2139878072510408, -2.357376362693933)),
((0, 1, 17),(1.2001305872904486, -2.4047650656472435)),
((0, 2, -16),(2.8126045964899693, -0.64591937475004424)),
((0, 2, -15),(2.7716485337528556, -0.6601073879475956)),
((0, 2, -14),(2.7297976443326464, -0.67598129763773729)),
((0, 2, -13),(2.6870577332801586, -0.69362928720236794)),
((0, 2, -12),(2.6434458712089124, -0.71313914154788749)),
((0, 2, -11),(2.5989922251308064, -0.73459649464753585)),
((0, 2, -10),(2.5537419003084891, -0.75808269548844998)),
((0, 2, -9),(2.5077566986900024, -0.78367228062175032)),
((0, 2, -8),(2.461116673449351, -0.81143006690547059)),
((0, 2, -7),(2.4139213356117506, -0.84140791289447969)),
((0, 2, -6),(2.3662903520918221, -0.87364124134434706)),
((0, 2, -5),(2.3183635699990424, -0.90814546629767878)),
((0, 2, -4),(2.2703002151962992, -0.94491252163954853)),
((0, 2, -3),(2.2222771482265866, -0.98390773661357334)),
((0, 2, -2),(2.1744861196887149, -1.0250673380667683)),
((0, 2, -1),(2.1271300477355717, -1.0682968685963541)),
((0, 2, 0),(2.0804184353668047, -1.1134707849202516)),
((0, 2, 1),(2.0345621425151328, -1.1604334362798805)),
((0, 2, 2),(1.9897678122880385, -1.2090015198026716)),
((0, 2, 3),(1.9462323066623, -1.2589679781022298)),
((0, 2, 4),(1.9041375225671413, -1.3101071614104445)),
((0, 2, 5),(1.8636459296912178, -1.3621809445450006)),
((0, 2, 6),(1.8248971002050154, -1.4149453903295386)),
((0, 2, 7),(1.7880053996002891, -1.4681575025298712)),
((0, 2, 8),(1.7530588938617315, -1.5215816200735068)),
((0, 2, 9),(1.7201194190929436, -1.5749950661747749)),
((0, 2, 10),(1.6892236704407935, -1.6281927672638703)),
((0, 2, 11),(1.6603851069321869, -1.6809906779752777)),
((0, 2, 12),(1.6335964403502643, -1.7332279698690178)),
((0, 2, 13),(1.6088324765590276, -1.7847680465842073)),
((0, 2, 14),(1.5860531000374389, -1.8354985263922676)),
((0, 2, 15),(1.5652062286044637, -1.8853303808692585)),
((0, 2, 16),(1.5462306075626651, -1.934196437423287)),
((0, 2, 17),(1.5290583544699439, -1.9820494491045064)),
((0, 3, -15),(2.5964939416255599, -0.80083473680552086)),
((0, 3, -14),(2.5624312481956992, -0.81417352115126362)),
((0, 3, -13),(2.528235639944135, -0.82863846734891489)),
((0, 3, -12),(2.4939432826929435, -0.84425667614906252)),
((0, 3, -11),(2.4595946835483704, -0.86105289616675862)),
((0, 3, -10),(2.4252346751570495, -0.87904896310177361)),
((0, 3, -9),(2.3909123218387958, -0.89826321109132057)),
((0, 3, -8),(2.3566807384997763, -0.91870986745143934)),
((0, 3, -7),(2.3225968151891614, -0.94039844503682901)),
((0, 3, -6),(2.2887208428795569, -0.96333314932280611)),
((0, 3, -5),(2.2551160394940033, -0.98751231985694343)),
((0, 3, -4),(2.2218479792646564, -1.0129279276784398)),
((0, 3, -3),(2.1889839330058947, -1.0395651513839479)),
((0, 3, -2),(2.1565921315579257, -1.0674020544690894)),
((0, 3, -1),(2.1247409691844545, -1.0964093851841883)),
((0, 3, 0),(2.093498167732355, -1.1265505172858017)),
((0, 3, 1),(2.0629299255248439, -1.1577815457362106)),
((0, 3, 2),(2.0331000769452898, -1.1900515457362018)),
((0, 3, 3),(2.0040692892417118, -1.2233029967563451)),
((0, 3, 4),(1.975894322123807, -1.2574723658779374)),
((0, 3, 5),(1.948627373255182, -1.2924908372884534)),
((0, 3, 6),(1.9223155289253455, -1.3282851677686487)),
((0, 3, 7),(1.8970003343072608, -1.3647786420159644)),
((0, 3, 8),(1.8727174921495011, -1.4018920971491293)),
((0, 3, 9),(1.8494966929481962, -1.4395449830727194)),
((0, 3, 10),(1.8273615740234037, -1.4776564247141666)),
((0, 3, 11),(1.8063297998705503, -1.516146253456869)),
((0, 3, 12),(1.7864132519687801, -1.5549359781805552)),
((0, 3, 13),(1.7676183130977723, -1.5939496708396061)),
((0, 3, 14),(1.749946229222993, -1.6331147470218084)),
((0, 3, 15),(1.7333935311325674, -1.6723626279556443)),
((0, 4, -12),(2.4155792015701296, -0.9229300908226542)),
((0, 4, -11),(2.3881357143598629, -0.93639069814606657)),
((0, 4, -10),(2.3608985430738962, -0.95068043937253277)),
((0, 4, -9),(2.3338967261398658, -0.96580608016482095)),
((0, 4, -8),(2.3071602522819203, -0.98177255872516944)),
((0, 4, -7),(2.280719892137467, -0.99858281006656724)),
((0, 4, -6),(2.2546070115922907, -1.0162375999792777)),
((0, 4, -5),(2.2288533687705034, -1.0347353725971475)),
((0, 4, -4),(2.2034908971991967, -1.0540721155772499)),
((0, 4, -3),(2.1785514782182078, -1.0742412468897498)),
((0, 4, -2),(2.1540667061957843, -1.0952335270565667)),
((0, 4, -1),(2.130067650513797, -1.1170370003667458)),
((0, 4, 0),(2.1065846185768144, -1.1396369681302612)),
((0, 4, 1),(2.0836469242572182, -1.1630159964155509)),
((0, 4, 2),(2.0612826661990651, -1.1871539599638123)),
((0, 4, 3),(2.0395185202595947, -1.21202812310865)),
((0, 4, 4),(2.0183795500705957, -1.2376132575852286)),
((0, 4, 5),(1.9978890392622524, -1.2638817961274027)),
((0, 4, 6),(1.9780683483279828, -1.2908040197679129)),
((0, 4, 7),(1.9589367984456927, -1.3183482758210407)),
((0, 4, 8),(1.9405115838394631, -1.3464812226827663)),
((0, 4, 9),(1.9228077135002013, -1.3751680968702737)),
((0, 4, 10),(1.9058379823190674, -1.40437299717285)),
((0, 4, 11),(1.8896129709568732, -1.4340591804228155)),
((0, 4, 12),(1.8741410731060384, -1.4641893632305614)),
((0, 4, 13),(1.8594285482231945, -1.494726024062758)),
((0, 5, -8),(2.2816065790111355, -1.0256701242484463)),
((0, 5, -7),(2.2600656463635924, -1.0393407066209377)),
((0, 5, -6),(2.2388608326421919, -1.0536480508611454)),
((0, 5, -5),(2.2180100895605208, -1.0685913079385738)),
((0, 5, -4),(2.1975312185577334, -1.0841684575524713)),
((0, 5, -3),(2.1774417779425423, -1.1003762645305089)),
((0, 5, -2),(2.1577589903830492, -1.1172102440341527)),
((0, 5, -1),(2.138499651897642, -1.1346646364924449)),
((0, 5, 0),(2.1196800435198395, -1.1527323930732862)),
((0, 5, 1),(2.1013158468004081, -1.1714051723617906)),
((0, 5, 2),(2.0834220642723897, -1.1906733487511987)),
((0, 5, 3),(2.0660129459393639, -1.2105260328670362)),
((0, 5, 4),(2.0491019227555869, -1.2309511041442707)),
((0, 5, 5),(2.0327015479510706, -1.2519352554657039)),
((0, 5, 6),(2.0168234469187847, -1.2734640495542129)),
((0, 5, 7),(2.001478276228815, -1.2955219865979088)),
((0, 5, 8),(1.9866756921708819, -1.3180925823830962)),
((0, 5, 9),(1.9724243290567605, -1.3411584560209973)),
((1, -5, -7),(-0.89407303973378249, 2.0767451727258877)),
((1, -5, -6),(-0.88021476377793617, 2.0982586427056744)),
((1, -5, -5),(-0.86595985970744616, 2.1190789478790144)),
((1, -5, -4),(-0.85132131005126332, 2.1392014898821041)),
((1, -5, -3),(-0.83631240332011947, 2.1586230481528688)),
((1, -5, -2),(-0.82094668170064922, 2.1773417514781119)),
((1, -5, -1),(-0.80523788691244103, 2.1953570397142732)),
((1, -5, 0),(-0.78919990491995873, 2.2126696166823692)),
((1, -5, 1),(-0.77284671017929862, 2.2292813953036963)),
((1, -5, 2),(-0.75619231007455623, 2.2451954360829309)),
((1, -5, 3),(-0.73925069016187839, 2.260415880060807)),
((1, -5, 4),(-0.72203576079236209, 2.2749478773510226)),
((1, -5, 5),(-0.70456130562969288, 2.2887975123477147)),
((1, -5, 6),(-0.68684093251673461, 2.3019717266434081)),
((1, -5, 7),(-0.66888802707917072, 2.3144782406357112)),
((1, -4, -11),(-0.9397016539006583, 1.9960130254406245)),
((1, -4, -10),(-0.92466729702332773, 2.0262171895927903)),
((1, -4, -9),(-0.90911691764797675, 2.0555435366201182)),
((1, -4, -8),(-0.89307017326182725, 2.0839714394413322)),
((1, -4, -7),(-0.87654747142178913, 2.11148332743559)),
((1, -4, -6),(-0.85956986088585208, 2.1380647226619218)),
((1, -4, -5),(-0.84215891533171905, 2.1637042371254713)),
((1, -4, -4),(-0.82433661178137252, 2.1883935334267672)),
((1, -4, -3),(-0.80612520589249759, 2.2121272517978086)),
((1, -4, -2),(-0.78754710625722946, 2.2349029070572128)),
((1, -4, -1),(-0.76862474976857698, 2.2567207593980747)),
((1, -4, 0),(-0.74938047998107993, 2.2775836631562583)),
((1, -4, 1),(-0.72983643021275701, 2.2974968977999382)),
((1, -4, 2),(-0.71001441291971956, 2.3164679853454215)),
((1, -4, 3),(-0.68993581663340087, 2.3345064982557946)),
((1, -4, 4),(-0.66962151149388205, 2.35162386163696)),
((1, -4, 5),(-0.64909176415132319, 2.3678331532303445)),
((1, -4, 6),(-0.62836616255055211, 2.3831489043337433)),
((1, -4, 7),(-0.60746355086953252, 2.3975869043810976)),
((1, -4, 8),(-0.58640197465699107, 2.4111640114960662)),
((1, -4, 9),(-0.56519863601332765, 2.4238979709191155)),
((1, -4, 10),(-0.54386985848488067, 2.4358072428059958)),
((1, -4, 11),(-0.52243106119674565, 2.4469108405173654)),
((1, -3, -14),(-0.97702198039968391, 1.8799258807281607)),
((1, -3, -13),(-0.95931514077672331, 1.9235649764228067)),
((1, -3, -12),(-0.94090846180271104, 1.9661000118164722)),
((1, -3, -11),(-0.92183695235784668, 2.0074581286418862)),
((1, -3, -10),(-0.90213752584982132, 2.0475739052620225)),
((1, -3, -9),(-0.88184869024878554, 2.0863899668967831)),
((1, -3, -8),(-0.86101020895239966, 2.123857404806953)),
((1, -3, -7),(-0.83966274181866707, 2.1599360039125144)),
((1, -3, -6),(-0.8178474761235518, 2.1945942858192704)),
((1, -3, -5),(-0.79560575716197046, 2.2278093807219825)),
((1, -3, -4),(-0.77297872773482323, 2.2595667468305036)),
((1, -3, -3),(-0.75000698490418827, 2.2898597596560455)),
((1, -3, -2),(-0.72673026122956719, 2.318689195661451)),
((1, -3, -1),(-0.70318713631275598, 2.3460626355063243)),
((1, -3, 0),(-0.67941478297510038, 2.3719938115802552)),
((1, -3, 1),(-0.6554487508634167, 2.3965019229508209)),
((1, -3, 2),(-0.63132278881446013, 2.4196109385226281)),
((1, -3, 3),(-0.60706870597022367, 2.4413489063742095)),
((1, -3, 4),(-0.58271627047816998, 2.4617472841571253)),
((1, -3, 5),(-0.55829314366138749, 2.4808403023153613)),
((1, -3, 6),(-0.53382484681648712, 2.4986643688804748)),
((1, -3, 7),(-0.50933475728837307, 2.515257521840272)),
((1, -3, 8),(-0.48484413016560046, 2.5306589326451543)),
((1, -3, 9),(-0.46037214181421321, 2.5449084623479163)),
((1, -3, 10),(-0.43593595149281611, 2.5580462701805096)),
((1, -3, 11),(-0.41155077743656382, 2.5701124730426099)),
((1, -3, 12),(-0.38722998403238346, 2.5811468533832245)),
((1, -3, 13),(-0.36298517700407829, 2.5911886122595118)),
((1, -3, 14),(-0.33882630385928064, 2.6002761639131937)),
((1, -2, -15),(-0.98010042387326823, 1.7589026748555658)),
((1, -2, -14),(-0.95483325994444801, 1.8259516683518591)),
((1, -2, -13),(-0.92863113570157263, 1.8915470228897688)),
((1, -2, -12),(-0.90158841671179124, 1.9554055220851041)),
((1, -2, -11),(-0.87380364245204989, 2.0172701527711596)),
((1, -2, -10),(-0.84537772339251449, 2.076915965958114)),
((1, -2, -9),(-0.81641209839383366, 2.1341542100952222)),
((1, -2, -8),(-0.7870069437267776, 2.1888346302435684)),
((1, -2, -7),(-0.75725951606731212, 2.2408459897495652)),
((1, -2, -6),(-0.72726269638050811, 2.290115005912607)),
((1, -2, -5),(-0.69710378203146028, 2.3366039848296629)),
((1, -2, -4),(-0.66686355336747638, 2.3803074889702529)),
((1, -2, -3),(-0.6366156208321383, 2.4212483777718408)),
((1, -2, -2),(-0.60642604128887811, 2.4594735355289896)),
((1, -2, -1),(-0.57635317882456527, 2.49504955322675)),
((1, -2, 0),(-0.54644777632018637, 2.5280585726622768)),
((1, -2, 1),(-0.51675319935112696, 2.5585944412601838)),
((1, -2, 2),(-0.4873058129194579, 2.5867592708487126)),
((1, -2, 3),(-0.45813545329935856, 2.6126604471069412)),
((1, -2, 4),(-0.42926596100825631, 2.6364080999645751)),
((1, -2, 5),(-0.40071574577991653, 2.6581130188568665)),
((1, -2, 6),(-0.37249835973018969, 2.6778849793184261)),
((1, -2, 7),(-0.3446230601591162, 2.6958314373550074)),
((1, -2, 8),(-0.31709534827897584, 2.7120565436522557)),
((1, -2, 9),(-0.28991747439629739, 2.7266604293683305)),
((1, -2, 10),(-0.26308890361944892, 2.7397387176515799)),
((1, -2, 11),(-0.2366067390072969, 2.7513822190434163)),
((1, -2, 12),(-0.2104661012666435, 2.7616767737608674)),
((1, -2, 13),(-0.18466046572379519, 2.7707032089311818)),
((1, -2, 14),(-0.15918195842964611, 2.7785373837957028)),
((1, -2, 15),(-0.13402161399871051, 2.7852503004827458)),
((1, -2, 16),(-0.10916959821545456, 2.7909082620488559)),
((1, -1, -16),(-0.95887792611647071, 1.3731831137286603)),
((1, -1, -15),(-0.91027466006110458, 1.5046002942131473)),
((1, -1, -14),(-0.86056647781888818, 1.6374485446272675)),
((1, -1, -13),(-0.81033973286312777, 1.7693123117147276)),
((1, -1, -12),(-0.76015307525822517, 1.8977935420423371)),
((1, -1, -11),(-0.71050381061338863, 2.0207547232027534)),
((1, -1, -10),(-0.66180493693385722, 2.1365007351304093)),
((1, -1, -9),(-0.61437459228224556, 2.2438680286867712)),
((1, -1, -8),(-0.56843673255025617, 2.3422221819032774)),
((1, -1, -7),(-0.52413002858854896, 2.4313886697135136)),
((1, -1, -6),(-0.4815214447570772, 2.5115497501432982)),
((1, -1, -5),(-0.44062140754648005, 2.5831356998233006)),
((1, -1, -4),(-0.40139837742377854, 2.6467283587390318)),
((1, -1, -3),(-0.36379157690695846, 2.702984949095725)),
((1, -1, -2),(-0.32772137441488314, 2.7525831440819792)),
((1, -1, -1),(-0.29309731396173128, 2.7961846358725242)),
((1, -1, 0),(-0.25982404705442846, 2.8344131251271367)),
((1, -1, 1),(-0.22780553015109939, 2.8678427048340356)),
((1, -1, 2),(-0.19694786162684805, 2.8969932693241778)),
((1, -1, 3),(-0.16716109362123341, 2.9223303871021922)),
((1, -1, 4),(-0.13836029674675512, 2.9442678134946223)),
((1, -1, 5),(-0.11046609644209177, 2.9631714085545591)),
((1, -1, 6),(-0.083404846897727397, 2.9793636615802868)),
((1, -1, 7),(-0.057108564857251125, 2.993128329419068)),
((1, -1, 8),(-0.031514711337499599, 3.0047149018303658)),
((1, -1, 9),(-0.006565883311999793, 3.0143427413962143)),
((1, -1, 10),(0.01779054183607957, 3.0222048299664186)),
((1, -1, 11),(0.041602780242176667, 3.0284711048158002)),
((1, -1, 12),(0.06491501497919476, 3.0332913971436257)),
((1, -1, 13),(0.087767757076635144, 3.036798001164561)),
((1, -1, 14),(0.11019818709675025, 3.0391079090922473)),
((1, -1, 15),(0.13224047352690543, 3.0403247492370111)),
((1, -1, 16),(0.15392606645347479, 3.0405404634298092)),
((1, -1, 17),(0.17528396641982708, 3.0398367574264209)),
((1, 0, -10),(0.95481963794725688, 2.7719414171341081)),
((1, 0, -9),(0.71105679835054592, 3.05666358317578)),
((1, 0, -8),(0.58534610836336609, -3.0762408416707667)),
((1, 0, -7),(0.50949706785106086, -2.9840185003473416)),
((1, 0, -6),(0.46040809359052204, -2.9232390926180671)),
((1, 0, -5),(0.4275799573316193, -2.8816462949316262)),
((1, 0, -4),(0.40544531760971536, -2.8526968114716933)),
((1, 0, -3),(0.39074500024189346, -2.8325460682578409)),
((1, 0, -2),(0.3814326902486857, -2.8187753382694898)),
((1, 0, -1),(0.37615421945164157, -2.8097822525152405)),
((1, 0, 0),(0.37397583936030748, -2.8044612787894767)),
((1, 0, 1),(0.3742320215482941, -2.8020242172155267)),
((1, 0, 2),(0.3764353032148855, -2.8018936667951309)),
((1, 0, 3),(0.38022039961942189, -2.8036369033841027)),
((1, 0, 4),(0.38530822373870033, -2.8069232785698808)),
((1, 0, 5),(0.39148196920807926, -2.8114958897215727)),
((1, 0, 6),(0.39857076961164667, -2.8171522205542749)),
((1, 0, 7),(0.40643826485250595, -2.8237305947988451)),
((1, 0, 8),(0.41497443207131601, -2.8311004983210784)),
((1, 0, 9),(0.42408964014891531, -2.8391555365009031)),
((1, 0, 10),(0.43371025072967179, -2.8478082244663718)),
((1, 0, 11),(0.44377531512409168, -2.8569860759939827)),
((1, 0, 12),(0.45423406090577162, -2.8666286280877316)),
((1, 0, 13),(0.46504395627240053, -2.8766851499877339)),
((1, 0, 14),(0.47616920299692378, -2.8871128597697737)),
((1, 0, 15),(0.48757955135247516, -2.8978755221616073)),
((1, 0, 16),(0.49924935974110324, -2.9089423360005715)),
((1, 0, 17),(0.51115684230435487, -2.9202870441212059)),
((1, 1, -16),(2.7246231866126527, -1.2133141455869012)),
((1, 1, -15),(2.6054789402230454, -1.2643183949031944)),
((1, 1, -14),(2.4802938363031153, -1.3185755066279565)),
((1, 1, -13),(2.3507625797744822, -1.3754740000452073)),
((1, 1, -12),(2.2191067822251624, -1.4342747002517073)),
((1, 1, -11),(2.0878851547326316, -1.4941638812299491)),
((1, 1, -10),(1.9597171842791028, -1.5543192698508332)),
((1, 1, -9),(1.8369888022339407, -1.6139756207429214)),
((1, 1, -8),(1.7216168470257835, -1.6724770121846348)),
((1, 1, -7),(1.6149227066379719, -1.7293079395121413)),
((1, 1, -6),(1.5176220689478739, -1.7841020063674211)),
((1, 1, -5),(1.4299022374209196, -1.836632464505191)),
((1, 1, -4),(1.3515445092037235, -1.8867914071577239)),
((1, 1, -3),(1.2820541924139739, -1.9345642630860251)),
((1, 1, -2),(1.2207746825591554, -1.9800045369454387)),
((1, 1, -1),(1.166975663762198, -2.0232116807198977)),
((1, 1, 0),(1.1199148171439508, -2.0643132749196007)),
((1, 1, 1),(1.0788771100508068, -2.1034515799455495)),
((1, 1, 2),(1.0431971642423064, -2.1407739310209308)),
((1, 1, 3),(1.0122698665959817, -2.176426234034381)),
((1, 1, 4),(0.98555336401902194, -2.2105488177942716)),
((1, 1, 5),(0.96256746717274733, -2.243273996683024)),
((1, 1, 6),(0.94288953088683458, -2.2747248274896879)),
((1, 1, 7),(0.92614915135801568, -2.305014669665737)),
((1, 1, 8),(0.91202250534244345, -2.3342472645934493)),
((1, 1, 9),(0.90022681042349251, -2.3625171331669272)),
((1, 1, 10),(0.89051516207480941, -2.3899101538195908)),
((1, 1, 11),(0.88267186443878642, -2.4165042287445746)),
((1, 1, 12),(0.87650828896166466, -2.4423699783378208)),
((1, 1, 13),(0.87185924822074201, -2.4675714262730697)),
((1, 1, 14),(0.86857984792504295, -2.4921666528424895)),
((1, 1, 15),(0.86654276931668217, -2.5162084043607633)),
((1, 1, 16),(0.86563593138548922, -2.5397446530731767)),
((1, 1, 17),(0.86576048389364357, -2.5628191062359336)),
((1, 2, -15),(2.349451852688107, -1.1939505337251333)),
((1, 2, -14),(2.2841008433311312, -1.2201396128269182)),
((1, 2, -13),(2.2188804192832841, -1.2478095745114395)),
((1, 2, -12),(2.1540936271082298, -1.2768855697514365)),
((1, 2, -11),(2.0900529237366969, -1.3072772164197373)),
((1, 2, -10),(2.0270713380336485, -1.3388797309639269)),
((1, 2, -9),(1.9654533002620245, -1.3715756962076799)),
((1, 2, -8),(1.9054857739426576, -1.4052373967378002)),
((1, 2, -7),(1.8474303059550592, -1.439729602650301)),
((1, 2, -6),(1.7915165143210783, -1.4749126425881733)),
((1, 2, -5),(1.737937375669119, -1.5106455839911062)),
((1, 2, -4),(1.686846483666236, -1.5467893354367523)),
((1, 2, -3),(1.6383572575072287, -1.5832095025455886)),
((1, 2, -2),(1.5925439141682738, -1.6197788615533473)),
((1, 2, -1),(1.5494438988306627, -1.6563793574706882)),
((1, 2, 0),(1.5090614025277724, -1.6929035800385732)),
((1, 2, 1),(1.4713715820090709, -1.7292557142725435)),
((1, 2, 2),(1.4363251239391153, -1.7653519986423261)),
((1, 2, 3),(1.4038528501699679, -1.801120750248745)),
((1, 2, 4),(1.3738701291451958, -1.8365020321003434)),
((1, 2, 5),(1.3462809289757345, -1.8714470436712756)),
((1, 2, 6),(1.3209814122106305, -1.9059173142204662)),
((1, 2, 7),(1.2978630261113768, -1.9398837711465664)),
((1, 2, 8),(1.2768150835355687, -1.9733257451678932)),
((1, 2, 9),(1.2577268586283499, -2.0062299622390132)),
((1, 2, 10),(1.2404892399371001, -2.0385895602684396)),
((1, 2, 11),(1.2249959933980208, -2.0704031578313815)),
((1, 2, 12),(1.211144691068301, -2.101673992708144)),
((1, 2, 13),(1.1988373604659983, -2.1324091404307914)),
((1, 2, 14),(1.1879809055619741, -2.1626188170721261)),
((1, 2, 15),(1.1784873450989899, -2.1923157661086061)),
((1, 2, 16),(1.1702739078974147, -2.2215147261091088)),
((1, 2, 17),(1.1632630187557382, -2.2502319739988956)),
((1, 3, -14),(2.2287344615181803, -1.1972160195081651)),
((1, 3, -13),(2.1851351316440755, -1.2154490331114414)),
((1, 3, -12),(2.1420664400962472, -1.2346395009084177)),
((1, 3, -11),(2.0996221110272675, -1.2547638950157685)),
((1, 3, -10),(2.0578949013512204, -1.2757941368962245)),
((1, 3, -9),(2.0169753117561937, -1.297697680898942)),
((1, 3, -8),(1.9769503279370937, -1.3204376922591041)),
((1, 3, -7),(1.9379022328408335, -1.3439733187994027)),
((1, 3, -6),(1.8999075280668218, -1.3682600516944388)),
((1, 3, -5),(1.8630359976436406, -1.3932501668288215)),
((1, 3, -4),(1.8273499405804552, -1.418893234779034)),
((1, 3, -3),(1.7929035904135779, -1.4451366845386899)),
((1, 3, -2),(1.7597427310864133, -1.4719264040004365)),
((1, 3, -1),(1.7279045095976933, -1.4992073590487036)),
((1, 3, 0),(1.6974174375667062, -1.5269242129638374)),
((1, 3, 1),(1.6683015667244603, -1.55502192865938)),
((1, 3, 2),(1.6405688177223134, -1.5834463379588732)),
((1, 3, 3),(1.6142234377567626, -1.6121446644912112)),
((1, 3, 4),(1.5892625603732111, -1.6410659896287536)),
((1, 3, 5),(1.565676840317711, -1.6701616539795996)),
((1, 3, 6),(1.5434511372277899, -1.699385590053192)),
((1, 3, 7),(1.5225652239965484, -1.7286945846546011)),
((1, 3, 8),(1.5029944984839734, -1.7580484721763741)),
((1, 3, 9),(1.4847106805685495, -1.7874102621454142)),
((1, 3, 10),(1.4676824800460371, -1.8167462060917778)),
((1, 3, 11),(1.4518762243549095, -1.8460258100253739)),
((1, 3, 12),(1.4372564383606037, -1.8752217995596685)),
((1, 3, 13),(1.4237863713411285, -1.9043100450582051)),
((1, 3, 14),(1.4114284688144743, -1.9332694541660373)),
((1, 3, 15),(1.4001447889055489, -1.9620818387960384)),
((1, 4, -12),(2.1427474424680595, -1.2203240542719034)),
((1, 4, -11),(2.1109815942700232, -1.2353219908932851)),
((1, 4, -10),(2.079772602367727, -1.2510160987466759)),
((1, 4, -9),(2.0491589839572719, -1.2673937531788486)),
((1, 4, -8),(2.0191779309105913, -1.2844404231979507)),
((1, 4, -7),(1.9898649973805929, -1.3021396989493801)),
((1, 4, -6),(1.9612538088017069, -1.320473344563007)),
((1, 4, -5),(1.9333757977434263, -1.3394213761584173)),
((1, 4, -4),(1.906259971384991, -1.3589621641574121)),
((1, 4, -3),(1.8799327145240008, -1.3790725584209842)),
((1, 4, -2),(1.8544176310495768, -1.3997280341295666)),
((1, 4, -1),(1.8297354257481466, -1.4209028557885244)),
((1, 4, 0),(1.8059038272157191, -1.4425702562896054)),
((1, 4, 1),(1.7829375515743535, -1.4647026276137429)),
((1, 4, 2),(1.7608483056779614, -1.4872717195347653)),
((1, 4, 3),(1.7396448275835226, -1.5102488425844542)),
((1, 4, 4),(1.7193329612897263, -1.53360507156696)),
((1, 4, 5),(1.6999157621280057, -1.5573114460582953)),
((1, 4, 6),(1.6813936287424309, -1.5813391645815296)),
((1, 4, 7),(1.663764457317334, -1.6056597694934063)),
((1, 4, 8),(1.6470238135977084, -1.630245320032472)),
((1, 4, 9),(1.6311651182834308, -1.6550685514403038)),
((1, 4, 10),(1.6161798415445314, -1.6801030185535581)),
((1, 4, 11),(1.602057702677939, -1.7053232227540684)),
((1, 4, 12),(1.5887868712814273, -1.7307047216380866)),
((1, 4, 13),(1.5763541667332706, -1.7562242212083103)),
((1, 5, -8),(2.0497006391453354, -1.2681361127482753)),
((1, 5, -7),(2.0262570277779406, -1.2822710891783409)),
((1, 5, -6),(2.0033472347453318, -1.2969365039661889)),
((1, 5, -5),(1.9809879297795063, -1.3121225234371252)),
((1, 5, -4),(1.9591947200896194, -1.3278183776646379)),
((1, 5, -3),(1.9379820716288185, -1.3440123923766063)),
((1, 5, -2),(1.9173632418234046, -1.3606920298394409)),
((1, 5, -1),(1.897350224434331, -1.3778439382849437)),
((1, 5, 0),(1.8779537070007057, -1.3954540092935219)),
((1, 5, 1),(1.8591830410881141, -1.4135074424084479)),
((1, 5, 2),(1.8410462253382669, -1.4319888161334426)),
((1, 5, 3),(1.8235499010975293, -1.4508821643637797)),
((1, 5, 4),(1.8066993601966537, -1.470171057222373)),
((1, 5, 5),(1.7904985642678861, -1.4898386852187724)),
((1, 5, 6),(1.7749501748232641, -1.5098679456219133)),
((1, 5, 7),(1.7600555931824582, -1.5302415299365482)),
((1, 5, 8),(1.7458150092323426, -1.5509420113978114)),
((1, 5, 9),(1.7322274579243766, -1.5719519314462813)),
((1, 5, 10),(1.719290882369664, -1.5932538842146433)),
((2, -4, -8),(-0.61954710899339216, 2.3329910445961688)),
((2, -4, -7),(-0.60728081671452516, 2.3566654171219534)),
((2, -4, -6),(-0.59467769508850477, 2.3793104520282076)),
((2, -4, -5),(-0.58175386154829634, 2.4009408258170128)),
((2, -4, -4),(-0.56852515670265502, 2.4215726509427666)),
((2, -4, -3),(-0.55500710875375914, 2.4412233069048894)),
((2, -4, -2),(-0.54121489970608039, 2.4599112741082649)),
((2, -4, -1),(-0.52716333382043812, 2.4776559722917302)),
((2, -4, 0),(-0.51286680867468315, 2.4944776050167738)),
((2, -4, 1),(-0.49833928910379732, 2.5103970114149257)),
((2, -4, 2),(-0.48359428420871325, 2.5254355261177701)),
((2, -4, 3),(-0.46864482754623005, 2.5396148480416505)),
((2, -4, 4),(-0.45350346054279467, 2.5529569184720491)),
((2, -4, 5),(-0.43818221911325317, 2.5654838086914902)),
((2, -4, 6),(-0.42269262341235625, 2.5772176172199388)),
((2, -4, 7),(-0.40704567060184782, 2.5881803765875979)),
((2, -4, 8),(-0.3912518304791297, 2.5983939694354485)),
((2, -4, 9),(-0.37532104378462744, 2.6078800536377038)),
((2, -3, -11),(-0.56115378940543204, 2.3421510573960767)),
((2, -3, -10),(-0.54849744498870678, 2.3753386147354085)),
((2, -3, -9),(-0.53544745667238725, 2.4069092392212483)),
((2, -3, -8),(-0.52202901038200744, 2.4368937803622162)),
((2, -3, -7),(-0.50826646696426347, 2.4653265442028998)),
((2, -3, -6),(-0.49418332415783389, 2.4922447280361726)),
((2, -3, -5),(-0.47980218273231312, 2.5176878825888229)),
((2, -3, -4),(-0.46514471772998506, 2.5416974079418986)),
((2, -3, -3),(-0.45023165543556992, 2.564316087479428)),
((2, -3, -2),(-0.4350827564268358, 2.585587662454639)),
((2, -3, -1),(-0.41971680482469637, 2.6055564483261962)),
((2, -3, 0),(-0.40415160366519337, 2.6242669928406825)),
((2, -3, 1),(-0.38840397615680261, 2.6417637749048142)),
((2, -3, 2),(-0.37248977246225196, 2.6580909425780197)),
((2, -3, 3),(-0.35642388155223975, 2.6732920879972633)),
((2, -3, 4),(-0.34022024761550229, 2.6874100566934089)),
((2, -3, 5),(-0.3238918904720916, 2.7004867885451262)),
((2, -3, 6),(-0.30745092942068752, 2.7125631875166478)),
((2, -3, 7),(-0.29090860995249707, 2.7236790173162793)),
((2, -3, 8),(-0.27427533278038851, 2.7338728201728646)),
((2, -3, 9),(-0.25756068465882037, 2.7431818560393468)),
((2, -3, 10),(-0.24077347050507247, 2.7516420596810822)),
((2, -3, 11),(-0.22392174637259285, 2.7592880132791273)),
((2, -3, 12),(-0.20701285287071128, 2.7661529323651299)),
((2, -2, -13),(-0.41882437120312666, 2.3887852859156964)),
((2, -2, -12),(-0.40684719216106496, 2.4368754975472857)),
((2, -2, -11),(-0.39439053304781396, 2.4819123314289544)),
((2, -2, -10),(-0.381497860920197, 2.5240121531970177)),
((2, -2, -9),(-0.3682095316548567, 2.5632971559852504)),
((2, -2, -8),(-0.35456296338780607, 2.5998929447030594)),
((2, -2, -7),(-0.34059279541029142, 2.6339264861808704)),
((2, -2, -6),(-0.32633103705430982, 2.6655244092430763)),
((2, -2, -5),(-0.31180720957313457, 2.6948116276399872)),
((2, -2, -4),(-0.29704848289657715, 2.7219102525636734)),
((2, -2, -3),(-0.28207980832905938, 2.7469387589252148)),
((2, -2, -2),(-0.26692404769071842, 2.7700113696015114)),
((2, -2, -1),(-0.2516020990216517, 2.7912376235939869)),
((2, -2, 0),(-0.23613301873059528, 2.8107220968033038)),
((2, -2, 1),(-0.22053413993612225, 2.8285642474165043)),
((2, -2, 2),(-0.20482118669057842, 2.8448583613735146)),
((2, -2, 3),(-0.18900838377194662, 2.8596935767939997)),
((2, -2, 4),(-0.17310856175844452, 2.8731539694557742)),
((2, -2, 5),(-0.15713325715122611, 2.8853186843394356)),
((2, -2, 6),(-0.14109280737209723, 2.8962621008530562)),
((2, -2, 7),(-0.12499644052816389, 2.9060540216182331)),
((2, -2, 8),(-0.1088523598990175, 2.9147598766468845)),
((2, -2, 9),(-0.092667823160860557, 2.9224409363901924)),
((2, -2, 10),(-0.076449216414155668, 2.9291545285266229)),
((2, -2, 11),(-0.060202123125855073, 2.9349542545064025)),
((2, -2, 12),(-0.043931388133712175, 2.9398902028162714)),
((2, -2, 13),(-0.02764117688890844, 2.9440091567002775)),
((2, -2, 14),(-0.011335030134813325, 2.9473547946966305)),
((2, -2, 15),(0.0049840857655256057, 2.9499678828507121)),
((2, -1, -14),(-0.073845419942377755, 2.553847900286494)),
((2, -1, -13),(-0.073168254163339941, 2.6251096386957853)),
((2, -1, -12),(-0.070950699299407741, 2.6888357887562258)),
((2, -1, -11),(-0.067406369927067902, 2.7458325833014761)),
((2, -1, -10),(-0.062711172357787184, 2.7968153567982115)),
((2, -1, -9),(-0.057011769744841491, 2.8424174075268627)),
((2, -1, -8),(-0.050431723585048945, 2.8831986384306951)),
((2, -1, -7),(-0.04307605092955262, 2.9196537471080193)),
((2, -1, -6),(-0.035034674118559789, 2.9522198082523392)),
((2, -1, -5),(-0.02638507897483465, 2.9812831666925779)),
((2, -1, -4),(-0.017194395854430757, 3.00718561810789)),
((2, -1, -3),(-0.0075210521929808261, 3.0302298949164843)),
((2, -1, -2),(0.0025838983923695065, 3.0506844995866498)),
((2, -1, -1),(0.01307569486537382, 3.0687879407238294)),
((2, -1, 0),(0.023914980135121326, 3.0847524324278006)),
((2, -1, 1),(0.035067064003993439, 3.098767117462506)),
((2, -1, 2),(0.04650130682390665, 3.1110008718085242)),
((2, -1, 3),(0.058190600314878133, 3.1216047435852929)),
((2, -1, 4),(0.070110927368640219, 3.1307140740550081)),
((2, -1, 5),(0.082240986643051933, 3.1384503430231279)),
((2, -1, 6),(0.094561870744184331, -3.1382625314144423)),
((2, -1, 7),(0.10705678906507073, -3.1329555633650013)),
((2, -1, 8),(0.11971082809495169, -3.1287253195564624)),
((2, -1, 9),(0.13251074336673507, -3.1254916219096525)),
((2, -1, 10),(0.14544477827116342, -3.1231819191407748)),
((2, -1, 11),(0.15850250580533459, -3.1217304664159649)),
((2, -1, 12),(0.1716746899926653, -3.1210776048568523)),
((2, -1, 13),(0.18495316425009234, -3.1211691276837557)),
((2, -1, 14),(0.19833072441513086, -3.1219557216419038)),
((2, -1, 15),(0.21180103450230528, -3.1233924739474976)),
((2, -1, 16),(0.22535854355203175, -3.1254384363515046)),
((2, 0, -15),(0.76692013902925027, 3.0343021886286965)),
((2, 0, -14),(0.69122378003770413, 3.1174400946456018)),
((2, 0, -13),(0.63139113072854547, -3.099617155322071)),
((2, 0, -12),(0.58325508386384151, -3.0460860828913865)),
((2, 0, -11),(0.54408600900688264, -3.0022421585041332)),
((2, 0, -10),(0.51199294451005473, -2.9660592821100611)),
((2, 0, -9),(0.48561022276540866, -2.9360684594989439)),
((2, 0, -8),(0.4639191381319277, -2.9111706319939059)),
((2, 0, -7),(0.44613985500919839, -2.8905225371761638)),
((2, 0, -6),(0.43166257082606302, -2.8734636388420105)),
((2, 0, -5),(0.42000189330168941, -2.8594674808516762)),
((2, 0, -4),(0.4107655891852518, -2.848108237206056)),
((2, 0, -3),(0.40363257406337077, -2.8390370769148645)),
((2, 0, -2),(0.39833703759483602, -2.8319650706584354)),
((2, 0, -1),(0.39465675551330615, -2.8266505767805206)),
((2, 0, 0),(0.39240432746846693, -2.822889766897636)),
((2, 0, 1),(0.39142050267679701, -2.8205093976573896)),
((2, 0, 2),(0.39156902318909637, -2.8193612188563288)),
((2, 0, 3),(0.39273258866333016, -2.8193175931345347)),
((2, 0, 4),(0.39480966230561654, -2.8202680258858623)),
((2, 0, 5),(0.39771191623559415, -2.8221163880430304)),
((2, 0, 6),(0.40136216887978765, -2.8247786726444684)),
((2, 0, 7),(0.4056927052115506, -2.8281811671411843)),
((2, 0, 8),(0.41064389793941108, -2.8322589527705913)),
((2, 0, 9),(0.41616306749748377, -2.8369546636251184)),
((2, 0, 10),(0.422203533175321, -2.8422174536888143)),
((2, 0, 11),(0.42872381847114654, -2.8480021317407807)),
((2, 0, 12),(0.4356869818140367, -2.854268432756665)),
((2, 0, 13),(0.44306004990974235, -2.8609804010645221)),
((2, 0, 14),(0.45081353563837984, -2.8681058655847194)),
((2, 0, 15),(0.45892102603931506, -2.8756159914026687)),
((2, 0, 16),(0.46735882872576412, -2.8834848949755267)),
((2, 1, -15),(1.5219147861473099, -2.3030300844836371)),
((2, 1, -14),(1.4241262547709492, -2.3024182445671428)),
((2, 1, -13),(1.3374271625198573, -2.3038427909303758)),
((2, 1, -12),(1.2605671992279919, -2.306964045115182)),
((2, 1, -11),(1.1924235487822747, -2.3115145920018954)),
((2, 1, -10),(1.1319972664639939, -2.3172799445108274)),
((2, 1, -9),(1.0784057214792562, -2.3240854197055674)),
((2, 1, -8),(1.0308727467043228, -2.3317869441908949)),
((2, 1, -7),(0.9887178359667893, -2.3402644342142835)),
((2, 1, -6),(0.95134531491608321, -2.3494169150579789)),
((2, 1, -5),(0.91823405287894178, -2.3591588472054883)),
((2, 1, -4),(0.88892801929221665, -2.3694173098906863)),
((2, 1, -3),(0.86302781168552412, -2.3801298068425725)),
((2, 1, -2),(0.84018317239120677, -2.3912425322402413)),
((2, 1, -1),(0.82008644806998743, -2.4027089829714252)),
((2, 1, 0),(0.80246691376434565, -2.4144888355692631)),
((2, 1, 1),(0.78708587001623442, -2.4265470283130304)),
((2, 1, 2),(0.77373241980652407, -2.43885300440459)),
((2, 1, 3),(0.76221983661538395, -2.4513800830772823)),
((2, 1, 4),(0.75238244258497722, -2.4641049333828189)),
((2, 1, 5),(0.7440729246656681, -2.4770071311713844)),
((2, 1, 6),(0.73716002563420346, -2.4900687840581197)),
((2, 1, 7),(0.7315265553864021, -2.5032742123817124)),
((2, 1, 8),(0.72706767563959285, -2.5166096766026889)),
((2, 1, 9),(0.72368941802669839, -2.5300631434655565)),
((2, 1, 10),(0.72130740152562467, -2.543624084706769)),
((2, 1, 11),(0.71984572029948457, -2.5572833032335733)),
((2, 1, 12),(0.71923597740694467, -2.5710327826038171)),
((2, 1, 13),(0.71941644356680723, -2.5848655563590417)),
((2, 1, 14),(0.72033132331520999, -2.5987755943444473)),
((2, 1, 15),(0.72193011355895387, -2.6127577036201712)),
((2, 1, 16),(0.72416704177828517, -2.6268074419528382)),
((2, 2, -14),(1.7173009160492683, -1.8316861489234377)),
((2, 2, -13),(1.6560504807062806, -1.8479518722822745)),
((2, 2, -12),(1.5982068831927863, -1.8646868206123335)),
((2, 2, -11),(1.5437471103551941, -1.88183627037276)),
((2, 2, -10),(1.4926187423438639, -1.8993489694281354)),
((2, 2, -9),(1.4447450247293441, -1.9171771801345407)),
((2, 2, -8),(1.4000297870877445, -1.9352766850417449)),
((2, 2, -7),(1.3583620227800679, -1.9536067551919378)),
((2, 2, -6),(1.3196200125928552, -1.9721300832649065)),
((2, 2, -5),(1.2836749315320335, -1.9908126853876502)),
((2, 2, -4),(1.2503939219973159, -2.0096237763835991)),
((2, 2, -3),(1.2196426482701186, -2.0285356236879615)),
((2, 2, -2),(1.1912873682521665, -2.0475233852098662)),
((2, 2, -1),(1.1651965706951994, -2.0665649361824485)),
((2, 2, 0),(1.1412422318272026, -2.0856406896028523)),
((2, 2, 1),(1.119300746185824, -2.1047334143043623)),
((2, 2, 2),(1.0992535841921696, -2.1238280540869123)),
((2, 2, 3),(1.0809877247799564, -2.1429115507082925)),
((2, 2, 4),(1.0643959061630839, -2.1619726729417081)),
((2, 2, 5),(1.0493767322336196, -2.1810018533581301)),
((2, 2, 6),(1.0358346665694322, -2.1999910340078315)),
((2, 2, 7),(1.0236799408655504, -2.2189335217596926)),
((2, 2, 8),(1.0128283999347152, -2.2378238537099646)),
((2, 2, 9),(1.0032013013139292, -2.2566576727903893)),
((2, 2, 10),(0.99472508397314841, -2.2754316134834252)),
((2, 2, 11),(0.98733111762259518, -2.2941431973827484)),
((2, 2, 12),(0.98095544160978909, -2.3127907382126422)),
((2, 2, 13),(0.97553850033121803, -2.331373255833566)),
((2, 2, 14),(0.9710248803979421, -2.3498903987056639)),
((2, 2, 15),(0.96736305343405193, -2.3683423742517546)),
((2, 2, 16),(0.96450512729953497, -2.3867298865505404)),
((2, 3, -12),(1.7604464425077111, -1.6507693997012065)),
((2, 3, -11),(1.7196856554248177, -1.6665264875620756)),
((2, 3, -10),(1.6805461809932902, -1.6827703619481831)),
((2, 3, -9),(1.64304320509011, -1.69946771380036)),
((2, 3, -8),(1.6071832202423475, -1.716585527661374)),
((2, 3, -7),(1.5729645847918252, -1.7340912670076762)),
((2, 3, -6),(1.5403781700436137, -1.75195305019254)),
((2, 3, -5),(1.509408068152321, -1.7701398134204724)),
((2, 3, -4),(1.4800323355258489, -1.788621457918965)),
((2, 3, -3),(1.4522237492668042, -1.8073689792366594)),
((2, 3, -2),(1.42595055735188, -1.826354577342465)),
((2, 3, -1),(1.4011772066230965, -1.8455517468979985)),
((2, 3, 0),(1.3778650360271942, -1.8649353477025177)),
((2, 3, 1),(1.3559729257323152, -1.8844816558490995)),
((2, 3, 2),(1.3354578956620218, -1.9041683965739622)),
((2, 3, 3),(1.3162756495452721, -1.9239747601246668)),
((2, 3, 4),(1.2983810627531525, -1.9438814022203688)),
((2, 3, 5),(1.2817286139732431, -1.963870430835057)),
((2, 3, 6),(1.266272762176621, -1.9839253811129056)),
((2, 3, 7),(1.2519682713914508, -2.0040311802352195)),
((2, 3, 8),(1.2387704865504168, -2.0241741040133441)),
((2, 3, 9),(1.2266355641708708, -2.04434172689384)),
((2, 3, 10),(1.2155206619010659, -2.0645228669428448)),
((2, 3, 11),(1.2053840910655191, -2.0847075272362185)),
((2, 3, 12),(1.1961854363065139, -2.104886834929923)),
((2, 3, 13),(1.1878856462811196, -2.1250529791285158)),
((2, 3, 14),(1.1804470991634843, -2.1451991485147373)),
((2, 4, -10),(1.7915863890086414, -1.5642945973306286)),
((2, 4, -9),(1.7617726903056548, -1.5783744676542892)),
((2, 4, -8),(1.7329659024720667, -1.5929087542425828)),
((2, 4, -7),(1.7051756677017831, -1.6078775529627165)),
((2, 4, -6),(1.6784084281577905, -1.6232606731961503)),
((2, 4, -5),(1.6526675209448101, -1.6390377320482352)),
((2, 4, -4),(1.6279533029510871, -1.6551882503361606)),
((2, 4, -3),(1.6042633011199618, -1.6716917486939027)),
((2, 4, -2),(1.5815923835921026, -1.6885278422321282)),
((2, 4, -1),(1.5599329471753591, -1.705676332323764)),
((2, 4, 0),(1.5392751167350027, -1.7231172942458037)),
((2, 4, 1),(1.5196069523335645, -1.7408311595877348)),
((2, 4, 2),(1.500914660266067, -1.7587987925295396)),
((2, 4, 3),(1.4831828045119426, -1.7770015592899999)),
((2, 4, 4),(1.4663945155392768, -1.7954213902424876)),
((2, 4, 5),(1.4505316938315893, -1.8140408343845569)),
((2, 4, 6),(1.4355752059454514, -1.8328431060242285)),
((2, 4, 7),(1.421505071335297, -1.851812123706329)),
((2, 4, 8),(1.4083006385883492, -1.8709325415434965)),
((2, 4, 9),(1.3959407500894452, -1.8901897732370774)),
((2, 4, 10),(1.3844038944765971, -1.9095700091721381)),
((2, 4, 11),(1.373668346550114, -1.9290602270487438)),
((2, 4, 12),(1.3637122945591946, -1.9486481965690303)),
((2, 5, -5),(1.750718452508645, -1.5576676541265673)),
((2, 5, -4),(1.7298420126179952, -1.571529043704387)),
((2, 5, -3),(1.7096958062629115, -1.5857575547245317)),
((2, 5, -2),(1.6902807774565496, -1.6003398122918973)),
((2, 5, -1),(1.671596523132898, -1.6152622788567994)),
((2, 5, 0),(1.6536413470467028, -1.6305113052237958)),
((2, 5, 1),(1.6364123212316675, -1.646073181968436)),
((2, 5, 2),(1.6199053538217301, -1.6619341906464038)),
((2, 5, 3),(1.6041152620411503, -1.6780806542168727)),
((2, 5, 4),(1.589035849192461, -1.694498986148028)),
((2, 5, 5),(1.5746599845148228, -1.7111757377262742)),
((2, 5, 6),(1.5609796848456641, -1.7280976431496093)),
((2, 5, 7),(1.5479861970927733, -1.7452516620483465)),
((2, 5, 8),(1.5356700806089021, -1.7626250191409327)),
((3, -3, -7),(-0.2741754753127878, 2.671344765409378)),
((3, -3, -6),(-0.26631769850471354, 2.6911794681718102)),
((3, -3, -5),(-0.2581099174871988, 2.7098374691569171)),
((3, -3, -4),(-0.24956997946003118, 2.7273638171346697)),
((3, -3, -3),(-0.24071484189995113, 2.7438021638107437)),
((3, -3, -2),(-0.23156061620093968, 2.7591947452638985)),
((3, -3, -1),(-0.22212260698993833, 2.7735823718797477)),
((3, -3, 0),(-0.21241534790484487, 2.7870044259775533)),
((3, -3, 1),(-0.20245263447276779, 2.7994988663169416)),
((3, -3, 2),(-0.19224755460297335, 2.8111022386845277)),
((3, -3, 3),(-0.18181251710701202, 2.8218496917899483)),
((3, -3, 4),(-0.17115927857412513, 2.8317749977410047)),
((3, -3, 5),(-0.16029896886084771, 2.8409105764149745)),
((3, -3, 6),(-0.14924211539692001, 2.8492875230942496)),
((3, -3, 7),(-0.137998666463438, 2.8569356387872804)),
((3, -3, 8),(-0.12657801356182855, 2.863883462708591)),
((3, -3, 9),(-0.11498901296228205, 2.870158306443241)),
((3, -2, -10),(-0.11641918619139514, 2.7761235119604262)),
((3, -2, -9),(-0.11231691480102528, 2.8015185089346804)),
((3, -2, -8),(-0.1076484393571444, 2.8251296061261519)),
((3, -2, -7),(-0.10245058262662413, 2.8470568676926113)),
((3, -2, -6),(-0.096757274156200168, 2.867394108604334)),
((3, -2, -5),(-0.090599848315203999, 2.8862292991061675)),
((3, -2, -4),(-0.084007298694101992, 2.9036449410118612)),
((3, -2, -3),(-0.07700649687744851, 2.9197184185714731)),
((3, -2, -2),(-0.069622381949659862, 2.9345223260853248)),
((3, -2, -1),(-0.061878125804485914, 2.9481247740544525)),
((3, -2, 0),(-0.05379527832321726, 2.9605896753939001)),
((3, -2, 1),(-0.045393895696489987, 2.9719770130501271)),
((3, -2, 2),(-0.036692654539970893, 2.9823430902291368)),
((3, -2, 3),(-0.027708953958340284, 2.9917407643400007)),
((3, -2, 4),(-0.018459007316490302, 3.0002196656774149)),
((3, -2, 5),(-0.0089579251602703927, 3.0078264017994116)),
((3, -2, 6),(0.00078020952532086452, 3.0146047484974958)),
((3, -2, 7),(0.01074227273764859, 3.0205958282034526)),
((3, -2, 8),(0.020916036740516567, 3.0258382766281358)),
((3, -2, 9),(0.031290112528109024, 3.0303683983814538)),
((3, -2, 10),(0.041853896895351524, 3.0342203122791074)),
((3, -2, 11),(0.05259752363029941, 3.037426087000012)),
((3, -2, 12),(0.063511818417083157, 3.0400158677184876)),
((3, -1, -11),(0.14729546015603492, 2.995212468509636)),
((3, -1, -10),(0.14357004756556263, 3.0216167893148094)),
((3, -1, -9),(0.14096845773434796, 3.0456180330647542)),
((3, -1, -8),(0.13939266837788566, 3.067414981333767)),
((3, -1, -7),(0.13875624727222233, 3.087184995534463)),
((3, -1, -6),(0.1389825444089812, 3.1050869314718037)),
((3, -1, -5),(0.14000323815105772, 3.1212635637298942)),
((3, -1, -4),(0.14175715395945049, 3.1358436185986567)),
((3, -1, -3),(0.14418929539989767, -3.1342418161198586)),
((3, -1, -2),(0.14725004221884844, -3.1225166027977949)),
((3, -1, -1),(0.15089448119175036, -3.1120701489216822)),
((3, -1, 0),(0.15508184344769674, -3.1028151052796193)),
((3, -1, 1),(0.15977502791050344, -3.0946717459458584)),
((3, -1, 2),(0.16494019494845452, -3.0875671634623072)),
((3, -1, 3),(0.17054641769800868, -3.0814345672631926)),
((3, -1, 4),(0.17656538110595318, -3.0762126696701655)),
((3, -1, 5),(0.18297112072388205, -3.071845146536837)),
((3, -1, 6),(0.18973979483545253, -3.068280161826618)),
((3, -1, 7),(0.19684948470849836, -3.0654699471872515)),
((3, -1, 8),(0.20428001871979151, -3.0633704290308454)),
((3, -1, 9),(0.21201281685927884, -3.0619408968095367)),
((3, -1, 10),(0.22003075272715505, -3.061143707147691)),
((3, -1, 11),(0.22831803062482503, -3.0609440192935717)),
((3, -1, 12),(0.23686007573516663, -3.0613095580192962)),
((3, -1, 13),(0.24564343570814631, -3.0622104006532331)),
((3, 0, -12),(0.52279733028861153, -2.9700488241505898)),
((3, 0, -11),(0.50378671228614103, -2.9490914726649691)),
((3, 0, -10),(0.48717975032031569, -2.9306721863852894)),
((3, 0, -9),(0.47271790429607663, -2.9145189723120239)),
((3, 0, -8),(0.4601808666798578, -2.9003998070382897)),
((3, 0, -7),(0.44937927378187081, -2.888115076491232)),
((3, 0, -6),(0.44014910693078774, -2.8774917549515919)),
((3, 0, -5),(0.43234732900094108, -2.8683788586425556)),
((3, 0, -4),(0.42584843936996292, -2.8606438491211024)),
((3, 0, -3),(0.42054172204913881, -2.8541697551127378)),
((3, 0, -2),(0.41632902411062811, -2.8488528451316859)),
((3, 0, -1),(0.41312294481353168, -2.8446007275132965)),
((3, 0, 0),(0.41084534637817421, -2.8413307858073433)),
((3, 0, 1),(0.40942611925926353, -2.8389688799824002)),
((3, 0, 2),(0.40880215069531456, -2.8374482602866999)),
((3, 0, 3),(0.4089164570446342, -2.836708652711867)),
((3, 0, 4),(0.40971744916451736, -2.8366954840432843)),
((3, 0, 5),(0.41115830668209302, -2.8373592213041579)),
((3, 0, 6),(0.41319644202319294, -2.8386548056034386)),
((3, 0, 7),(0.41579303892149883, -2.840541164402612)),
((3, 0, 8),(0.41891265311901671, -2.8429807893255692)),
((3, 0, 9),(0.42252286530423161, -2.8459393690689128)),
((3, 0, 10),(0.42659397817327777, -2.8493854688889004)),
((3, 0, 11),(0.43109875095758526, -2.8532902496648371)),
((3, 0, 12),(0.43601216592582015, -2.8576272207570002)),
((3, 0, 13),(0.44131122230325831, -2.8623720218571087)),
((3, 0, 14),(0.44697475380802854, -2.8675022298226387)),
((3, 1, -12),(0.91586258363679263, -2.5713199552590025)),
((3, 1, -11),(0.88409896977867775, -2.5647861839536024)),
((3, 1, -10),(0.85539765544298452, -2.5597119951350931)),
((3, 1, -9),(0.82947103069703465, -2.5559517863749757)),
((3, 1, -8),(0.80606694178167759, -2.5533798269499957)),
((3, 1, -7),(0.78496315920272786, -2.5518867028459864)),
((3, 1, -6),(0.76596290654798782, -2.5513765471109036)),
((3, 1, -5),(0.74889120800591102, -2.5517648535738062)),
((3, 1, -4),(0.73359187658954905, -2.5529767303349136)),
((3, 1, -3),(0.71992500988459818, -2.5549454892390253)),
((3, 1, -2),(0.70776489215377847, -2.5576114951895619)),
((3, 1, -1),(0.69699822491502572, -2.5609212186807326)),
((3, 1, 0),(0.68752262532289088, -2.5648264489187738)),
((3, 1, 1),(0.67924534458821284, -2.5692836350726918)),
((3, 1, 2),(0.67208216847335345, -2.5742533306794591)),
((3, 1, 3),(0.66595646943071718, -2.5796997218002189)),
((3, 1, 4),(0.66079838579806205, -2.585590223716383)),
((3, 1, 5),(0.65654410804437335, -2.5918951341397434)),
((3, 1, 6),(0.65313525567983921, -2.5985873333533478)),
((3, 1, 7),(0.65051833132587744, -2.6056420235884943)),
((3, 1, 8),(0.64864424075361238, -2.6130365014158148)),
((3, 1, 9),(0.64746786956591751, -2.6207499580846565)),
((3, 1, 10),(0.64694770871489848, -2.6287633036597939)),
((3, 1, 11),(0.64704552228579104, -2.6370590115328798)),
((3, 1, 12),(0.64772605199615707, -2.6456209804699116)),
((3, 1, 13),(0.64895675369968531, -2.654434411826859)),
((3, 1, 14),(0.65070756188100687, -2.6634856999475565)),
((3, 2, -11),(1.1961978486540406, -2.2316281134134708)),
((3, 2, -10),(1.1636580074683704, -2.2363692690664596)),
((3, 2, -9),(1.1334575004081613, -2.2417413704358755)),
((3, 2, -8),(1.1054560679748455, -2.2476979301008799)),
((3, 2, -7),(1.0795220838776829, -2.2541965075234365)),
((3, 2, -6),(1.0555321250422767, -2.2611982495177783)),
((3, 2, -5),(1.0333705427604229, -2.2686675041660198)),
((3, 2, -4),(1.0129290384558152, -2.2765714934454175)),
((3, 2, -3),(0.99410624740954312, -2.2848800331661132)),
((3, 2, -2),(0.97680733337241732, -2.2935652913352871)),
((3, 2, -1),(0.96094359645500826, -2.3026015779803082)),
((3, 2, 0),(0.94643209612890089, -2.3119651609335987)),
((3, 2, 1),(0.93319529064778928, -2.3216341032168457)),
((3, 2, 2),(0.92116069373160625, -2.3315881185435257)),
((3, 2, 3),(0.91026054896067465, -2.341808442146315)),
((3, 2, 4),(0.90043152200061793, -2.3522777146750622)),
((3, 2, 5),(0.89161441051768886, -2.3629798773353881)),
((3, 2, 6),(0.88375387144095185, -2.3739000767731677)),
((3, 2, 7),(0.87679816507456454, -2.3850245784762101)),
((3, 2, 8),(0.87069891545182321, -2.3963406876759135)),
((3, 2, 9),(0.86541088624585827, -2.4078366769009305)),
((3, 2, 10),(0.86089177150270246, -2.4195017194703881)),
((3, 2, 11),(0.85710200043568696, -2.4313258283234545)),
((3, 2, 12),(0.85400455551078269, -2.4432997996705343)),
((3, 2, 13),(0.85156480305646742, -2.4554151610231676)),
((3, 3, -9),(1.3572923469107276, -2.0098024175827787)),
((3, 3, -8),(1.3300405735933236, -2.0192559888277763)),
((3, 3, -7),(1.3043160359368444, -2.0290943602177749)),
((3, 3, -6),(1.2800652800183048, -2.039295134404588)),
((3, 3, -5),(1.2572352032949328, -2.0498369951170781)),
((3, 3, -4),(1.2357732990389303, -2.0606996678378149)),
((3, 3, -3),(1.2156278673829035, -2.0718638843406034)),
((3, 3, -2),(1.1967481947777547, -2.083311349996896)),
((3, 3, -1),(1.1790847040136911, -2.0950247130093822)),
((3, 3, 0),(1.1625890771615464, -2.106987534937196)),
((3, 3, 1),(1.1472143538870681, -2.1191842620460828)),
((3, 3, 2),(1.1329150076012675, -2.1316001971538996)),
((3, 3, 3),(1.1196470018572016, -2.1442214717519446)),
((3, 3, 4),(1.1073678293053832, -2.1570350182697786)),
((3, 3, 5),(1.0960365353907473, -2.1700285424190762)),
((3, 3, 6),(1.0856137288248557, -2.1831904956034802)),
((3, 3, 7),(1.0760615807071654, -2.1965100474196242)),
((3, 3, 8),(1.0673438140048812, -2.2099770583012441)),
((3, 3, 9),(1.0594256849377974, -2.2235820523761971)),
((3, 3, 10),(1.0522739576559463, -2.2373161906166961)),
((3, 3, 11),(1.0458568734466149, -2.2511712443678831)),
((3, 3, 12),(1.0401441155650066, -2.2651395693402563)),
((3, 4, -6),(1.4458808596135624, -1.8809870675241769)),
((3, 4, -5),(1.4245617297356401, -1.8920736112573091)),
((3, 4, -4),(1.4042679040678343, -1.9034705924342512)),
((3, 4, -3),(1.3849765184368814, -1.9151631508453824)),
((3, 4, -2),(1.3666641168442639, -1.9271368387370071)),
((3, 4, -1),(1.3493067901837548, -1.9393776344783686)),
((3, 4, 0),(1.3328803064785337, -1.9518719551449641)),
((3, 4, 1),(1.3173602321252111, -1.9646066677443677)),
((3, 4, 2),(1.3027220438430454, -1.977569098881037)),
((3, 4, 3),(1.2889412312086344, -1.9907470427197642)),
((3, 4, 4),(1.2759933898109437, -2.0041287671636656)),
((3, 4, 5),(1.2638543051901536, -2.0177030182116305)),
((3, 4, 6),(1.2525000278287912, -2.0314590225024669)),
((3, 4, 7),(1.2419069395467706, -2.0453864880884902)),
((3, 4, 8),(1.2320518117157988, -2.0594756035105957)),
((3, 4, 9),(1.2229118557552929, -2.0737170352703265)),
((4, -2, 0),(0.06435859892784096, 3.0443088136350811)),
((4, -2, 1),(0.069042890592901043, 3.0524035363266298)),
((4, -2, 2),(0.074072595708772337, 3.0597615857577272)),
((4, -2, 3),(0.079431735433792561, 3.0664157305617699)),
((4, -1, -5),(0.23214887298103432, -3.1010146175414635)),
((4, -1, -4),(0.23143484763517025, -3.090957021010337)),
((4, -1, -3),(0.23132759790313087, -3.081859612363484)),
((4, -1, -2),(0.23179261661909864, -3.0736685489128961)),
((4, -1, -1),(0.2327980404221634, -3.0663339923683695)),
((4, -1, 0),(0.2343143850660469, -3.059809728719872)),
((4, -1, 1),(0.23631431572954079, -3.0540528344463307)),
((4, -1, 2),(0.23877244672730308, -3.0490233822026864)),
((4, -1, 3),(0.24166516604466937, -3.044684180311906)),
((4, -1, 4),(0.24497048093657392, -3.0410005413363241)),
((4, -1, 5),(0.24866788148554173, -3.037940075771846)),
((4, -1, 6),(0.25273821954206654, -3.0354725075366011)),
((4, -1, 7),(0.25716360089942614, -3.0335695084414116)),
((4, -1, 8),(0.26192728890449551, -3.0322045492551091)),
((4, 0, -6),(0.45430073538635213, -2.8897052382378461)),
((4, 0, -5),(0.44809789790081089, -2.8825952475437364)),
((4, 0, -4),(0.44277932757291577, -2.8764073606365148)),
((4, 0, -3),(0.43828948430987963, -2.8710837188878853)),
((4, 0, -2),(0.4345775891796565, -2.8665714104468711)),
((4, 0, -1),(0.43159709105068261, -2.8628219186712305)),
((4, 0, 0),(0.42930520951634238, -2.8597906489455118)),
((4, 0, 1),(0.42766254108235296, -2.8574365205862362)),
((4, 0, 2),(0.42663271813658615, -2.8557216131171788)),
((4, 0, 3),(0.42618211220895647, -2.8546108582202323)),
((4, 0, 4),(0.42627957459646199, -2.8540717702636944)),
((4, 0, 5),(0.42689620867311634, -2.8540742095787799)),
((4, 0, 6),(0.42800516919960535, -2.8545901736708101)),
((4, 0, 7),(0.42958148474803215, -2.855593612369475)),
((4, 0, 8),(0.4316019000047856, -2.8570602635850313)),
((4, 0, 9),(0.4340447352418475, -2.8589675068771965)),
((4, 1, -6),(0.68921781929304227, -2.6546005869019829)),
((4, 1, -5),(0.6779981107193358, -2.6524487848552258)),
((4, 1, -4),(0.66786415758568451, -2.6510112738753087)),
((4, 1, -3),(0.65874977954049951, -2.6502439313189949)),
((4, 1, -2),(0.65059418041471451, -2.6501063300260363)),
((4, 1, -1),(0.64334138507819771, -2.6505613314917835)),
((4, 1, 0),(0.63693975122749091, -2.65157473717584)),
((4, 1, 1),(0.63134154410860788, -2.6531149879861431)),
((4, 1, 2),(0.62650256439701135, -2.6551529039238644)),
((4, 1, 3),(0.62238182121355845, -2.6576614573982957)),
((4, 1, 4),(0.61894124365664538, -2.6606155749229123)),
((4, 1, 5),(0.61614542535674921, -2.6639919628586042)),
((4, 1, 6),(0.61396139747009182, -2.6677689536334253)),
((4, 1, 7),(0.6123584262688061, -2.6719263694820574)),
((4, 1, 8),(0.61130783209111506, -2.6764454012448593)),
((4, 1, 9),(0.61078282691335861, -2.6813085001699886)),
((4, 2, -5),(0.89899741791597043, -2.4333929198623783)),
((4, 2, -4),(0.88519063811520515, -2.4362499979642398)),
((4, 2, -3),(0.87246175953565352, -2.4395869092123692)),
((4, 2, -2),(0.86075496086636039, -2.4433774957677983)),
((4, 2, -1),(0.85001803369297546, -2.4475974239506573)),
((4, 2, 0),(0.84020209899593201, -2.4522240208008492)),
((4, 2, 1),(0.83126135219031361, -2.4572361310586777)),
((4, 2, 2),(0.82315283308187859, -2.4626139913786744)),
((4, 2, 3),(0.81583621767417269, -2.4683391191581023)),
((4, 2, 4),(0.80927362922073443, -2.4743942138188002)),
((4, 2, 5),(0.80342946629516132, -2.4807630687509814)),
((4, 2, 6),(0.79827024596631457, -2.4874304924282127)),
((4, 2, 7),(0.79376446042863036, -2.4943822374482973)),
((4, 2, 8),(0.78988244565811649, -2.5016049364559581)),
((4, 3, -2),(1.0495709901069983, -2.2617934276511251)),
((4, 3, -1),(1.0367514684809902, -2.2686055885353134)),
((4, 3, 0),(1.0248151233210518, -2.275730389729115)),
((4, 3, 1),(1.0137262178032664, -2.283153293384157)),
((4, 3, 2),(1.0034506053972199, -2.290860524496253)),
((4, 3, 3),(0.99395566533994972, -2.2988390286634686)),
((4, 3, 4),(0.98521024056932294, -2.3070764336942742)),
((4, 3, 5),(0.97718457798292291, -2.3155610145222152)),
]

def test_ewald_sphere_model():
  # direct space orientation matrix
  orientation = (24.67303504408280, -8.27539755075503, 12.97853642392082,
        -13.21765114237159, -0.18925842832666, 35.37258184706041,
         39.24485466996793, 107.21509370974169, 20.28943160079353)
  limiting_resolution = 6.429576016992
  wavelength = 0.979454000
  axial_direction = (0,1,0)

  # rotation_angles object must be instantiated with reciprocal-space orientation matrix
  CO = crystal_orientation(orientation,basis_type.direct)
  MM = CO.unit_cell().max_miller_indices(limiting_resolution)
  RA = rotation_angles(limiting_resolution,CO.reciprocal_matrix(),wavelength,axial_direction)

  maxh = MM[0];
  maxk = MM[1];
  maxl = MM[2];

  ptr=0
  for h in range(-maxh, maxh+1):
    for k in range(-maxk, maxk+1):
      for l in range(-maxl, maxl+1):
        if RA((h,k,l)):
          assert test_results[ptr][0]==(h,k,l)
          assert approx_equal(
            test_results[ptr][1],RA.get_intersection_angles(),eps = 1.E-10, multiplier=1.e-10)
          ptr+=1
          #print "(%s,%s),"%(str((h,k,l)),RA.get_intersection_angles())
  assert(ptr == len(test_results))

if __name__=="__main__":

  test_ewald_sphere_model()
  print("OK")


 *******************************************************************************
