

 *******************************************************************************
mmtbx/validation/regression/tst_symmetry_SS.py
from __future__ import absolute_import, division, print_function
from libtbx import easy_run
import unittest
import os

__author__ = 'bhintze'

test_pdb_str = '''\
CRYST1   89.760   89.760  150.890  90.00  90.00  90.00 P 43 21 2
SCALE1      0.011141  0.000000  0.000000        0.00000
SCALE2     -0.000000  0.011141  0.000000        0.00000
SCALE3      0.000000 -0.000000  0.006627        0.00000
ATOM    376  N   ASP A 532       2.906  76.529 186.658  1.00134.73           N
ATOM    377  CA  ASP A 532       4.198  77.174 186.751  1.00132.33           C
ATOM    378  CB  ASP A 532       4.325  77.971 188.064  1.00131.20           C
ATOM    379  CG  ASP A 532       5.669  78.695 188.203  1.00117.21           C
ATOM    380  OD1 ASP A 532       6.714  78.045 188.046  1.00109.08           O
ATOM    381  OD2 ASP A 532       5.685  79.910 188.487  1.00112.03           O
ATOM    382  C   ASP A 532       5.202  76.022 186.702  1.00132.62           C
ATOM    383  O   ASP A 532       5.352  75.246 187.645  1.00149.81           O
ATOM    384  N   ILE A 533       5.929  75.960 185.604  1.00147.69           N
ATOM    385  CA  ILE A 533       6.846  74.859 185.312  1.00146.43           C
ATOM    386  CB  ILE A 533       7.535  75.096 183.938  1.00154.91           C
ATOM    387  CG1 ILE A 533       6.486  75.039 182.797  1.00159.66           C
ATOM    388  CD1 ILE A 533       5.871  76.379 182.402  1.00149.38           C
ATOM    389  CG2 ILE A 533       8.693  74.126 183.701  1.00154.51           C
ATOM    390  C   ILE A 533       7.882  74.683 186.433  1.00137.78           C
ATOM    391  O   ILE A 533       8.304  73.551 186.741  1.00123.42           O
ATOM    392  N   CYS A 534       8.263  75.797 187.056  1.00131.42           N
ATOM    393  CA  CYS A 534       9.333  75.808 188.057  1.00131.90           C
ATOM    394  CB  CYS A 534       9.810  77.251 188.285  1.00130.90           C
ATOM    395  SG  CYS A 534      10.891  77.555 189.708  1.00138.71           S
ATOM    396  C   CYS A 534       8.938  75.168 189.395  1.00139.83           C
ATOM    397  O   CYS A 534       9.692  74.343 189.945  1.00123.05           O
ATOM    398  N   LYS A 535       7.769  75.567 189.904  1.00132.70           N
ATOM    399  CA  LYS A 535       7.276  75.128 191.195  1.00113.57           C
ATOM    400  CB  LYS A 535       6.321  76.171 191.766  1.00104.76           C
ATOM    401  CG  LYS A 535       7.063  77.459 192.082  1.00103.62           C
ATOM    402  CD  LYS A 535       6.239  78.489 192.831  1.00111.95           C
ATOM    403  CE  LYS A 535       7.178  79.531 193.454  1.00118.75           C
ATOM    404  NZ  LYS A 535       6.522  80.730 194.049  1.00109.53           N
ATOM    405  C   LYS A 535       6.621  73.770 191.083  1.00112.61           C
ATOM    406  O   LYS A 535       6.876  72.888 191.904  1.00127.98           O
ATOM    407  N   GLN A 536       5.823  73.580 190.039  1.00115.26           N
ATOM    408  CA  GLN A 536       5.038  72.353 189.884  1.00113.55           C
ATOM    409  CB  GLN A 536       3.702  72.682 189.204  1.00 93.32           C
ATOM    410  C   GLN A 536       5.808  71.230 189.153  1.00116.48           C
ATOM    411  O   GLN A 536       5.180  70.277 188.684  1.00123.87           O
'''

class TestMPGeo(unittest.TestCase):

  def setUp(self):
    self.file_to_delete = ['try.geo']
    # import files used in tests
    self.file_name = 'symmetry_SS.pdb'
    with open(self.file_name,'w')as f:
      f.write(test_pdb_str)
    self.file_to_delete.append(self.file_name)

  def test_mpgeo(self):
    cmd = "mmtbx.mp_geo pdb=symmetry_SS.pdb "
    cmd+= "out_file=try.geo kinemage=True"
    er = easy_run.call(command=cmd)
    #er.show_stderr()
    assert er == 0, 'command "%s" failed' % cmd

  def tearDown(self):
    """ delete files created in during testing"""
    if self.file_to_delete:
      for fn in self.file_to_delete:
        if os.path.isfile(fn): os.remove(fn)

if __name__ == '__main__' :
    unittest.main()


 *******************************************************************************


 *******************************************************************************
mmtbx/validation/regression/tst_undowser.py
from __future__ import absolute_import, division, print_function
from mmtbx.validation import undowser
from libtbx.easy_pickle import loads
from iotbx.data_manager import DataManager
from libtbx.test_utils import convert_pdb_to_cif_for_pdb_str
import libtbx.load_env
import time
import json
import difflib

pdb_1lpl_str = """MODEL        1
ATOM     85  N   ILE A 146       4.850  13.830  60.452  1.00 31.46           N
ATOM     86  CA  ILE A 146       5.654  15.038  60.565  1.00 28.74           C
ATOM     87  C   ILE A 146       5.963  15.310  62.021  1.00 27.82           C
ATOM     88  O   ILE A 146       5.062  15.510  62.825  1.00 28.89           O
ATOM     89  CB  ILE A 146       4.956  16.280  59.905  1.00 27.45           C
ATOM     90  CG1 ILE A 146       4.674  15.994  58.416  1.00 25.50           C
ATOM     91  CG2 ILE A 146       5.850  17.543  60.072  1.00 23.19           C
ATOM     92  CD1 ILE A 146       3.970  17.121  57.673  1.00 27.89           C
ATOM      0  H   ILE A 146       4.003  13.950  60.365  1.00 31.46           H   new
ATOM      0  HA  ILE A 146       6.481  14.891  60.080  1.00 28.74           H   new
ATOM      0  HB  ILE A 146       4.110  16.447  60.348  1.00 27.45           H   new
ATOM      0 HG12 ILE A 146       5.515  15.805  57.971  1.00 25.50           H   new
ATOM      0 HG13 ILE A 146       4.132  15.192  58.350  1.00 25.50           H   new
ATOM      0 HG21 ILE A 146       5.413  18.306  59.662  1.00 23.19           H   new
ATOM      0 HG22 ILE A 146       5.989  17.719  61.016  1.00 23.19           H   new
ATOM      0 HG23 ILE A 146       6.707  17.393  59.642  1.00 23.19           H   new
ATOM      0 HD11 ILE A 146       3.831  16.862  56.749  1.00 27.89           H   new
ATOM      0 HD12 ILE A 146       3.113  17.299  58.091  1.00 27.89           H   new
ATOM      0 HD13 ILE A 146       4.517  17.921  57.705  1.00 27.89           H   new
ATOM    137  N   GLU A 153      11.342  19.816  53.414  1.00 18.86           N
ATOM    138  CA  GLU A 153      11.328  20.597  52.204  1.00 20.88           C
ATOM    139  C   GLU A 153       9.887  21.060  51.996  1.00 20.14           C
ATOM    140  O   GLU A 153       8.976  20.225  51.945  1.00 18.33           O
ATOM    141  CB  GLU A 153      11.771  19.754  51.024  1.00 20.67           C
ATOM    142  CG  GLU A 153      11.890  20.570  49.780  1.00 28.25           C
ATOM    143  CD  GLU A 153      12.021  19.708  48.543  1.00 35.57           C
ATOM    144  OE1 GLU A 153      11.164  18.803  48.342  1.00 39.43           O
ATOM    145  OE2 GLU A 153      12.981  19.939  47.779  1.00 36.90           O
ATOM      0  H   GLU A 153      10.727  19.216  53.448  1.00 18.86           H   new
ATOM      0  HA  GLU A 153      11.935  21.350  52.274  1.00 20.88           H   new
ATOM      0  HB2 GLU A 153      12.625  19.340  51.224  1.00 20.67           H   new
ATOM      0  HB3 GLU A 153      11.135  19.036  50.881  1.00 20.67           H   new
ATOM      0  HG2 GLU A 153      11.111  21.141  49.694  1.00 28.25           H   new
ATOM      0  HG3 GLU A 153      12.662  21.153  49.850  1.00 28.25           H   new
ATOM    618  N   VAL A 216       4.506  19.838  52.802  1.00 21.99           N
ATOM    619  CA  VAL A 216       5.738  19.509  53.507  1.00 24.27           C
ATOM    620  C   VAL A 216       6.150  18.056  53.346  1.00 26.17           C
ATOM    621  O   VAL A 216       5.340  17.143  53.546  1.00 26.47           O
ATOM    622  CB  VAL A 216       5.593  19.757  55.039  1.00 25.53           C
ATOM    623  CG1 VAL A 216       6.935  19.548  55.734  1.00 23.77           C
ATOM    624  CG2 VAL A 216       5.055  21.160  55.299  1.00 22.33           C
ATOM      0  H   VAL A 216       3.828  19.373  53.053  1.00 21.99           H   new
ATOM      0  HA  VAL A 216       6.410  20.085  53.111  1.00 24.27           H   new
ATOM      0  HB  VAL A 216       4.960  19.119  55.404  1.00 25.53           H   new
ATOM      0 HG11 VAL A 216       6.834  19.705  56.686  1.00 23.77           H   new
ATOM      0 HG12 VAL A 216       7.238  18.638  55.586  1.00 23.77           H   new
ATOM      0 HG13 VAL A 216       7.587  20.168  55.372  1.00 23.77           H   new
ATOM      0 HG21 VAL A 216       4.969  21.302  56.255  1.00 22.33           H   new
ATOM      0 HG22 VAL A 216       5.667  21.815  54.929  1.00 22.33           H   new
ATOM      0 HG23 VAL A 216       4.186  21.256  54.879  1.00 22.33           H   new
ATOM    634  N   VAL A 218       9.047  15.495  54.747  1.00 24.30           N
ATOM    635  CA  VAL A 218       9.980  15.425  55.854  1.00 25.59           C
ATOM    636  C   VAL A 218      11.043  14.371  55.566  1.00 25.70           C
ATOM    637  O   VAL A 218      10.781  13.407  54.869  1.00 25.17           O
ATOM    638  CB  VAL A 218       9.161  15.143  57.136  1.00 26.71           C
ATOM    639  CG1 VAL A 218       9.460  13.782  57.688  1.00 28.12           C
ATOM    640  CG2 VAL A 218       9.374  16.262  58.126  1.00 28.81           C
ATOM      0  H   VAL A 218       8.514  14.824  54.675  1.00 24.30           H   new
ATOM      0  HA  VAL A 218      10.460  16.258  55.979  1.00 25.59           H   new
ATOM      0  HB  VAL A 218       8.215  15.126  56.923  1.00 26.71           H   new
ATOM      0 HG11 VAL A 218       8.933  13.635  58.489  1.00 28.12           H   new
ATOM      0 HG12 VAL A 218       9.237  13.108  57.027  1.00 28.12           H   new
ATOM      0 HG13 VAL A 218      10.403  13.721  57.906  1.00 28.12           H   new
ATOM      0 HG21 VAL A 218       8.861  16.085  58.930  1.00 28.81           H   new
ATOM      0 HG22 VAL A 218      10.316  16.321  58.351  1.00 28.81           H   new
ATOM      0 HG23 VAL A 218       9.083  17.100  57.735  1.00 28.81           H   new
TER     728      ILE A 218
HETATM  731  O   HOH A 503       7.663  18.549  58.083  1.00 71.06           O
HETATM  758  O   HOH A 530      20.116  27.095  51.665  1.00 24.67           O
HETATM  765  O   HOH A 537      14.778  21.226  48.211  1.00 27.98           O
HETATM  772  O   HOH A 544      -5.198  25.804  53.682  1.00 21.10           O
HETATM  800  O   HOH A 572      -6.768  26.204  53.124  1.00 14.71           O
HETATM  805  O   HOH A 577      21.563  28.198  52.938  1.00 31.45           O
HETATM  812  O   HOH A 585      -6.264  27.663  53.754  1.00 21.56           O
ENDMDL
MODEL        2
ATOM     85  N   ILE A 146       4.850  13.830  60.452  1.00 31.46           N
ATOM     86  CA  ILE A 146       5.654  15.038  60.565  1.00 28.74           C
ATOM     87  C   ILE A 146       5.963  15.310  62.021  1.00 27.82           C
ATOM     88  O   ILE A 146       5.062  15.510  62.825  1.00 28.89           O
ATOM     89  CB  ILE A 146       4.956  16.280  59.905  1.00 27.45           C
ATOM     90  CG1 ILE A 146       4.674  15.994  58.416  1.00 25.50           C
ATOM     91  CG2 ILE A 146       5.850  17.543  60.072  1.00 23.19           C
ATOM     92  CD1 ILE A 146       3.970  17.121  57.673  1.00 27.89           C
ATOM      0  H   ILE A 146       4.003  13.950  60.365  1.00 31.46           H   new
ATOM      0  HA  ILE A 146       6.481  14.891  60.080  1.00 28.74           H   new
ATOM      0  HB  ILE A 146       4.110  16.447  60.348  1.00 27.45           H   new
ATOM      0 HG12 ILE A 146       5.515  15.805  57.971  1.00 25.50           H   new
ATOM      0 HG13 ILE A 146       4.132  15.192  58.350  1.00 25.50           H   new
ATOM      0 HG21 ILE A 146       5.413  18.306  59.662  1.00 23.19           H   new
ATOM      0 HG22 ILE A 146       5.989  17.719  61.016  1.00 23.19           H   new
ATOM      0 HG23 ILE A 146       6.707  17.393  59.642  1.00 23.19           H   new
ATOM      0 HD11 ILE A 146       3.831  16.862  56.749  1.00 27.89           H   new
ATOM      0 HD12 ILE A 146       3.113  17.299  58.091  1.00 27.89           H   new
ATOM      0 HD13 ILE A 146       4.517  17.921  57.705  1.00 27.89           H   new
ATOM    137  N   GLU A 153      11.342  19.816  53.414  1.00 18.86           N
ATOM    138  CA  GLU A 153      11.328  20.597  52.204  1.00 20.88           C
ATOM    139  C   GLU A 153       9.887  21.060  51.996  1.00 20.14           C
ATOM    140  O   GLU A 153       8.976  20.225  51.945  1.00 18.33           O
ATOM    141  CB  GLU A 153      11.771  19.754  51.024  1.00 20.67           C
ATOM    142  CG  GLU A 153      11.890  20.570  49.780  1.00 28.25           C
ATOM    143  CD  GLU A 153      12.021  19.708  48.543  1.00 35.57           C
ATOM    144  OE1 GLU A 153      11.164  18.803  48.342  1.00 39.43           O
ATOM    145  OE2 GLU A 153      12.981  19.939  47.779  1.00 36.90           O
ATOM      0  H   GLU A 153      10.727  19.216  53.448  1.00 18.86           H   new
ATOM      0  HA  GLU A 153      11.935  21.350  52.274  1.00 20.88           H   new
ATOM      0  HB2 GLU A 153      12.625  19.340  51.224  1.00 20.67           H   new
ATOM      0  HB3 GLU A 153      11.135  19.036  50.881  1.00 20.67           H   new
ATOM      0  HG2 GLU A 153      11.111  21.141  49.694  1.00 28.25           H   new
ATOM      0  HG3 GLU A 153      12.662  21.153  49.850  1.00 28.25           H   new
ATOM    618  N   VAL A 216       4.506  19.838  52.802  1.00 21.99           N
ATOM    619  CA  VAL A 216       5.738  19.509  53.507  1.00 24.27           C
ATOM    620  C   VAL A 216       6.150  18.056  53.346  1.00 26.17           C
ATOM    621  O   VAL A 216       5.340  17.143  53.546  1.00 26.47           O
ATOM    622  CB  VAL A 216       5.593  19.757  55.039  1.00 25.53           C
ATOM    623  CG1 VAL A 216       6.935  19.548  55.734  1.00 23.77           C
ATOM    624  CG2 VAL A 216       5.055  21.160  55.299  1.00 22.33           C
ATOM      0  H   VAL A 216       3.828  19.373  53.053  1.00 21.99           H   new
ATOM      0  HA  VAL A 216       6.410  20.085  53.111  1.00 24.27           H   new
ATOM      0  HB  VAL A 216       4.960  19.119  55.404  1.00 25.53           H   new
ATOM      0 HG11 VAL A 216       6.834  19.705  56.686  1.00 23.77           H   new
ATOM      0 HG12 VAL A 216       7.238  18.638  55.586  1.00 23.77           H   new
ATOM      0 HG13 VAL A 216       7.587  20.168  55.372  1.00 23.77           H   new
ATOM      0 HG21 VAL A 216       4.969  21.302  56.255  1.00 22.33           H   new
ATOM      0 HG22 VAL A 216       5.667  21.815  54.929  1.00 22.33           H   new
ATOM      0 HG23 VAL A 216       4.186  21.256  54.879  1.00 22.33           H   new
ATOM    634  N   VAL A 218       9.047  15.495  54.747  1.00 24.30           N
ATOM    635  CA  VAL A 218       9.980  15.425  55.854  1.00 25.59           C
ATOM    636  C   VAL A 218      11.043  14.371  55.566  1.00 25.70           C
ATOM    637  O   VAL A 218      10.781  13.407  54.869  1.00 25.17           O
ATOM    638  CB  VAL A 218       9.161  15.143  57.136  1.00 26.71           C
ATOM    639  CG1 VAL A 218       9.460  13.782  57.688  1.00 28.12           C
ATOM    640  CG2 VAL A 218       9.374  16.262  58.126  1.00 28.81           C
ATOM      0  H   VAL A 218       8.514  14.824  54.675  1.00 24.30           H   new
ATOM      0  HA  VAL A 218      10.460  16.258  55.979  1.00 25.59           H   new
ATOM      0  HB  VAL A 218       8.215  15.126  56.923  1.00 26.71           H   new
ATOM      0 HG11 VAL A 218       8.933  13.635  58.489  1.00 28.12           H   new
ATOM      0 HG12 VAL A 218       9.237  13.108  57.027  1.00 28.12           H   new
ATOM      0 HG13 VAL A 218      10.403  13.721  57.906  1.00 28.12           H   new
ATOM      0 HG21 VAL A 218       8.861  16.085  58.930  1.00 28.81           H   new
ATOM      0 HG22 VAL A 218      10.316  16.321  58.351  1.00 28.81           H   new
ATOM      0 HG23 VAL A 218       9.083  17.100  57.735  1.00 28.81           H   new
TER     728      ILE A 218
HETATM  731  O   HOH A 503       7.663  18.549  58.083  1.00 71.06           O
HETATM  758  O   HOH A 530      20.116  27.095  51.665  1.00 24.67           O
HETATM  765  O   HOH A 537      14.778  21.226  48.211  1.00 27.98           O
HETATM  772  O   HOH A 544      -5.198  25.804  53.682  1.00 21.10           O
HETATM  805  O   HOH A 577      21.563  28.198  52.938  1.00 31.45           O
HETATM  812  O   HOH A 585      -6.264  27.663  53.754  1.00 21.56           O
ENDMDL
END
"""

expected_undowser_html = """<html>
<head>
  <title>Summary table of water clashes</title>
</head>

<body>

<hr>
This table lists all HOH "waters" in the structure that have steric clashes. HOH are classified into common categories based on the atom they clash with.
<br><br>
A clashing HOH is very unlikely be be a real water, unless the clashing atom position is incorrect. The following categories provide guidance for correcting false HOH.
<br><br>
<b>Clash with polar</b> - HOH that clashes with polar groups may actually be a coordinated ion.
<br>
<b>Clash with nonpolar</b> - HOH that clashes with nonpolar groups may be a missing or displaced atom&ast;. Or it may be the first atom of an unmodeled alternate.
<br>
<b>Clash with both polar and nonpolar</b> - HOH that clashes with both polar and non-polar groups is unlikely to be an ion. If clashes are severe, a displaced atom is likely. If clashes and map are weak, the HOH may be entirely removable.
<br>
<b>Clash with water</b> - HOH-HOH clashes may be real waters that need to be modeled as alternates of compatible occupancy. Or they may be in the density of a sidechain alternate or a larger ligand.
<br>
<b>Clash with altloc</b> - HOH clashes involving one or more alternate conformations may be resolved by renaming some of the alternates.
<br><br>
<b>High B-factor</b> - HOH with clashes and minimal support in the map should be removed from the model. This table does not report map data directly, but a high B-factor is a likely warning sign that an HOH is a poor fit to the map.
<br>
<b>Severe clash</b> - HOH with severe clash overlap but good map support is likely to be a position where an atom is displaced.
<br><br>
&ast;<i>Displaced atom</i> indicates that a structural atom has been moved from its proper place in the model and replaced by HOH. Displaced sidechains are common. Moved atoms may be restored by local rebuilding.
<br>
<i>Missing atoms</i> have been entirely replaced by HOH. Removed atoms may be restored by modeling alternate conformations (especially sidechains), modeling ligands, or continuing a macromolecular mainchain.
<br><br>
These categories are general suggestions. Check your electron density; trust your intuition and experience. Prisant 2020 Prot Sci 29:315 (<a href="https://doi.org/10.1002/pro.3786">https://doi.org/10.1002/pro.3786</a>) illustrates 10 examples of clashing HOH cases.
<br>
<hr>
<br>
SUMMARY: 6 waters out of 7 have clashes (85.71%)
<br><br>
<hr>
<br>
<table border=1 width='100%'>
<tr bgcolor='#9999cc'><td rowspan='1' align='center'>Water ID</td>
<td align='center'>Clashes with</td>
<td align='center'>Water B</td>
<td align='center'>Contact B</td>
<td align='center'>Clash<br>Severity</td>
<td align='center'>Clash with Polar<br><small>May be ion</small></td>
<td align='center'>Clash with non-polar<br><small>Unmodeled alt or noise</small></td>
<td align='center'>Clash with water<br><small>Occ &lt;1 or ligand</small></td>
<td align='center'>Clash with altloc<br><small>Add or rename alts</small></td></tr>
<tr bgcolor=#eaeaea><td rowspan='2' ><pre><code>A: 572 :HOH: </code></pre></td>
<td><pre><code> O   of A: 585 :HOH: </code></pre></td><td>14.71</td><td>21.56</td><td bgcolor='#ee4d4d'>1.133</td><td></td><td></td><td align='center' bgcolor='#ee4d4d'>&times;</td><td></td></tr>
<tr bgcolor=#eaeaea><td><pre><code> O   of A: 544 :HOH: </code></pre></td><td>14.71</td><td>21.10</td><td bgcolor='#ee4d4d'>1.086</td><td></td><td></td><td align='center' bgcolor='#ee4d4d'>&times;</td><td></td></tr>
<tr bgcolor=#ffffff><td rowspan='2' ><pre><code>A: 585 :HOH: </code></pre></td>
<td><pre><code> O   of A: 572 :HOH: </code></pre></td><td>21.56</td><td>14.71</td><td bgcolor='#ee4d4d'>1.133</td><td></td><td></td><td align='center' bgcolor='#ee4d4d'>&times;</td><td></td></tr>
<tr bgcolor=#ffffff><td><pre><code> O   of A: 544 :HOH: </code></pre></td><td>21.56</td><td>21.10</td><td bgcolor='#ff76a9'>0.656</td><td></td><td></td><td align='center' bgcolor='#ff76a9'>&times;</td><td></td></tr>
<tr bgcolor=#eaeaea><td rowspan='2' ><pre><code>A: 544 :HOH: </code></pre></td>
<td><pre><code> O   of A: 572 :HOH: </code></pre></td><td>21.10</td><td>14.71</td><td bgcolor='#ee4d4d'>1.086</td><td></td><td></td><td align='center' bgcolor='#ee4d4d'>&times;</td><td></td></tr>
<tr bgcolor=#eaeaea><td><pre><code> O   of A: 585 :HOH: </code></pre></td><td>21.10</td><td>21.56</td><td bgcolor='#ff76a9'>0.656</td><td></td><td></td><td align='center' bgcolor='#ff76a9'>&times;</td><td></td></tr>
<tr bgcolor=#ffffff><td rowspan='4' ><pre><code>A: 503 :HOH: </code></pre></td>
<td><pre><code>HG11 of A: 216 :VAL: </code></pre></td><td>71.06</td><td>23.77</td><td bgcolor='#ff76a9'>0.626</td><td></td><td align='center' bgcolor='#ff76a9'>&times;</td><td></td><td></td></tr>
<tr bgcolor=#ffffff><td><pre><code>HG23 of A: 218 :VAL: </code></pre></td><td>71.06</td><td>28.81</td><td bgcolor='#ff76a9'>0.562</td><td></td><td align='center' bgcolor='#ff76a9'>&times;</td><td></td><td></td></tr>
<tr bgcolor=#ffffff><td><pre><code>HG23 of A: 146 :ILE: </code></pre></td><td>71.06</td><td>23.19</td><td bgcolor='#ffb3cc'>0.456</td><td></td><td align='center' bgcolor='#ffb3cc'>&times;</td><td></td><td></td></tr>
<tr bgcolor=#ffffff><td><pre><code> CG1 of A: 216 :VAL: </code></pre></td><td>71.06</td><td>23.77</td><td bgcolor='#ffb3cc'>0.446</td><td></td><td align='center' bgcolor='#ffb3cc'>&times;</td><td></td><td></td></tr>
<tr bgcolor=#eaeaea><td rowspan='1' ><pre><code>A: 530 :HOH: </code></pre></td>
<td><pre><code> O   of A: 577 :HOH: </code></pre></td><td>24.67</td><td>31.45</td><td bgcolor='#ff76a9'>0.579</td><td></td><td></td><td align='center' bgcolor='#ff76a9'>&times;</td><td></td></tr>
<tr bgcolor=#ffffff><td rowspan='1' ><pre><code>A: 537 :HOH: </code></pre></td>
<td><pre><code> OE2 of A: 153 :GLU: </code></pre></td><td>27.98</td><td>36.90</td><td bgcolor='#ff76a9'>0.548</td><td align='center' bgcolor='#ff76a9'>&plus; ion</td><td></td><td></td><td></td></tr>
</table>
"""

def exercise_undowser():
  dm = DataManager()
  #print(help(dm))
  dm.process_model_str("1",pdb_1lpl_str)
  m = dm.get_model("1")
  uz = undowser.undowserlyze(pdb_hierarchy=m.get_hierarchy())
  undowser_html = uz.as_HTML()
  diff = difflib.unified_diff(undowser_html.splitlines(), expected_undowser_html.splitlines(), fromfile="testvalue", tofile="expectedvalue")
  changed_lines = ""
  for line in diff:
    if line.startswith("-") or line.startswith("+"):
      changed_lines = changed_lines+"\n"+line
  assert changed_lines == "", "undowser html output changed, at the following lines: "+changed_lines

def exercise_undowser_json():
  dm = DataManager()
  #print(help(dm))
  dm.process_model_str("1",pdb_1lpl_str)
  m = dm.get_model("1")
  uz = undowser.undowserlyze(pdb_hierarchy=m.get_hierarchy())
  uz_dict = json.loads(uz.as_JSON())
  #import pprint
  #pprint.pprint(uz_dict)
  assert len(uz_dict['flat_results']) == 11, "tst_undowser json output not returning correct number of water clashes, now: "+str(len(uz_dict['flat_results']))
  assert uz_dict['flat_results'][0]["src_atom_id"] == " A 503 HOH  O   ", "tst_undowser json output first src_atom_id value changed, now: "+uz_dict['flat_results'][0]["src_atom_id"]
  from mmtbx.validation import test_utils
  assert test_utils.count_dict_values(uz_dict['hierarchical_results'], "water clash")==10, "tst_undowser json hierarchical output total number of water clashes changed, now: "+str(test_utils.count_dict_values(uz_dict['hierarchical_results'], "water clash"))
  assert test_utils.count_dict_values(uz_dict['hierarchical_results'], "nonpolar clash")==8, "tst_undowser json hierarchical output total number of nonpolar clashes changed, now: "+str(test_utils.count_dict_values(uz_dict['hierarchical_results'], "nonpolar clash"))
  assert test_utils.count_dict_values(uz_dict['hierarchical_results'], "polar clash")==2, "tst_undowser json hierarchical output total number of polar clashes changed, now: "+str(test_utils.count_dict_values(uz_dict['hierarchical_results'], "polar clash"))
  assert uz_dict['summary_results']["   1"]["num_outliers"] == 6, "tst_undowser json summary output total number of water clashes changed"
  assert uz_dict['summary_results']["   1"]["num_waters"] == 7, "tst_undowser json summary output total number of waters changed"

if (__name__ == "__main__"):
  if (not libtbx.env.has_module(name="probe")):
    print("Skipping exercise_undowser(): probe not configured")
    print("OK")
  else:
    t0 = time.time()
    exercise_undowser()
    exercise_undowser_json()
    print("Undowser using PDB OK.")
    convert_pdb_to_cif_for_pdb_str(locals(), chain_addition="LONGCHAIN", hetatm_name_addition = "", key_str="pdb_", print_new_string = False)
    #this won't work until undowser is swapped to use probe2
    #exercise_undowser_json()
    #print("Undowser using mmCIF OK.")
    print("OK. Time: %8.3f"%(time.time()-t0))


 *******************************************************************************


 *******************************************************************************
mmtbx/validation/regression/tst_undowser2.py
from __future__ import absolute_import, division, print_function
from mmtbx.validation import undowser2
from libtbx.easy_pickle import loads
from iotbx.data_manager import DataManager
import libtbx.load_env
from libtbx.utils import null_out
import iotbx
from mmtbx.programs import probe2
import time
import json
import difflib

pdb_1lpl_str = """MODEL        1
ATOM     85  N   ILE A 146       4.850  13.830  60.452  1.00 31.46           N
ATOM     86  CA  ILE A 146       5.654  15.038  60.565  1.00 28.74           C
ATOM     87  C   ILE A 146       5.963  15.310  62.021  1.00 27.82           C
ATOM     88  O   ILE A 146       5.062  15.510  62.825  1.00 28.89           O
ATOM     89  CB  ILE A 146       4.956  16.280  59.905  1.00 27.45           C
ATOM     90  CG1 ILE A 146       4.674  15.994  58.416  1.00 25.50           C
ATOM     91  CG2 ILE A 146       5.850  17.543  60.072  1.00 23.19           C
ATOM     92  CD1 ILE A 146       3.970  17.121  57.673  1.00 27.89           C
ATOM      0  H   ILE A 146       4.003  13.950  60.365  1.00 31.46           H   new
ATOM      0  HA  ILE A 146       6.481  14.891  60.080  1.00 28.74           H   new
ATOM      0  HB  ILE A 146       4.110  16.447  60.348  1.00 27.45           H   new
ATOM      0 HG12 ILE A 146       5.515  15.805  57.971  1.00 25.50           H   new
ATOM      0 HG13 ILE A 146       4.132  15.192  58.350  1.00 25.50           H   new
ATOM      0 HG21 ILE A 146       5.413  18.306  59.662  1.00 23.19           H   new
ATOM      0 HG22 ILE A 146       5.989  17.719  61.016  1.00 23.19           H   new
ATOM      0 HG23 ILE A 146       6.707  17.393  59.642  1.00 23.19           H   new
ATOM      0 HD11 ILE A 146       3.831  16.862  56.749  1.00 27.89           H   new
ATOM      0 HD12 ILE A 146       3.113  17.299  58.091  1.00 27.89           H   new
ATOM      0 HD13 ILE A 146       4.517  17.921  57.705  1.00 27.89           H   new
ATOM    137  N   GLU A 153      11.342  19.816  53.414  1.00 18.86           N
ATOM    138  CA  GLU A 153      11.328  20.597  52.204  1.00 20.88           C
ATOM    139  C   GLU A 153       9.887  21.060  51.996  1.00 20.14           C
ATOM    140  O   GLU A 153       8.976  20.225  51.945  1.00 18.33           O
ATOM    141  CB  GLU A 153      11.771  19.754  51.024  1.00 20.67           C
ATOM    142  CG  GLU A 153      11.890  20.570  49.780  1.00 28.25           C
ATOM    143  CD  GLU A 153      12.021  19.708  48.543  1.00 35.57           C
ATOM    144  OE1 GLU A 153      11.164  18.803  48.342  1.00 39.43           O
ATOM    145  OE2 GLU A 153      12.981  19.939  47.779  1.00 36.90           O
ATOM      0  H   GLU A 153      10.727  19.216  53.448  1.00 18.86           H   new
ATOM      0  HA  GLU A 153      11.935  21.350  52.274  1.00 20.88           H   new
ATOM      0  HB2 GLU A 153      12.625  19.340  51.224  1.00 20.67           H   new
ATOM      0  HB3 GLU A 153      11.135  19.036  50.881  1.00 20.67           H   new
ATOM      0  HG2 GLU A 153      11.111  21.141  49.694  1.00 28.25           H   new
ATOM      0  HG3 GLU A 153      12.662  21.153  49.850  1.00 28.25           H   new
ATOM    618  N   VAL A 216       4.506  19.838  52.802  1.00 21.99           N
ATOM    619  CA  VAL A 216       5.738  19.509  53.507  1.00 24.27           C
ATOM    620  C   VAL A 216       6.150  18.056  53.346  1.00 26.17           C
ATOM    621  O   VAL A 216       5.340  17.143  53.546  1.00 26.47           O
ATOM    622  CB  VAL A 216       5.593  19.757  55.039  1.00 25.53           C
ATOM    623  CG1 VAL A 216       6.935  19.548  55.734  1.00 23.77           C
ATOM    624  CG2 VAL A 216       5.055  21.160  55.299  1.00 22.33           C
ATOM      0  H   VAL A 216       3.828  19.373  53.053  1.00 21.99           H   new
ATOM      0  HA  VAL A 216       6.410  20.085  53.111  1.00 24.27           H   new
ATOM      0  HB  VAL A 216       4.960  19.119  55.404  1.00 25.53           H   new
ATOM      0 HG11 VAL A 216       6.834  19.705  56.686  1.00 23.77           H   new
ATOM      0 HG12 VAL A 216       7.238  18.638  55.586  1.00 23.77           H   new
ATOM      0 HG13 VAL A 216       7.587  20.168  55.372  1.00 23.77           H   new
ATOM      0 HG21 VAL A 216       4.969  21.302  56.255  1.00 22.33           H   new
ATOM      0 HG22 VAL A 216       5.667  21.815  54.929  1.00 22.33           H   new
ATOM      0 HG23 VAL A 216       4.186  21.256  54.879  1.00 22.33           H   new
ATOM    634  N   VAL A 218       9.047  15.495  54.747  1.00 24.30           N
ATOM    635  CA  VAL A 218       9.980  15.425  55.854  1.00 25.59           C
ATOM    636  C   VAL A 218      11.043  14.371  55.566  1.00 25.70           C
ATOM    637  O   VAL A 218      10.781  13.407  54.869  1.00 25.17           O
ATOM    638  CB  VAL A 218       9.161  15.143  57.136  1.00 26.71           C
ATOM    639  CG1 VAL A 218       9.460  13.782  57.688  1.00 28.12           C
ATOM    640  CG2 VAL A 218       9.374  16.262  58.126  1.00 28.81           C
ATOM      0  H   VAL A 218       8.514  14.824  54.675  1.00 24.30           H   new
ATOM      0  HA  VAL A 218      10.460  16.258  55.979  1.00 25.59           H   new
ATOM      0  HB  VAL A 218       8.215  15.126  56.923  1.00 26.71           H   new
ATOM      0 HG11 VAL A 218       8.933  13.635  58.489  1.00 28.12           H   new
ATOM      0 HG12 VAL A 218       9.237  13.108  57.027  1.00 28.12           H   new
ATOM      0 HG13 VAL A 218      10.403  13.721  57.906  1.00 28.12           H   new
ATOM      0 HG21 VAL A 218       8.861  16.085  58.930  1.00 28.81           H   new
ATOM      0 HG22 VAL A 218      10.316  16.321  58.351  1.00 28.81           H   new
ATOM      0 HG23 VAL A 218       9.083  17.100  57.735  1.00 28.81           H   new
TER     728      ILE A 218
HETATM  731  O   HOH A 503       7.663  18.549  58.083  1.00 71.06           O
HETATM  758  O   HOH A 530      20.116  27.095  51.665  1.00 24.67           O
HETATM  765  O   HOH A 537      14.778  21.226  48.211  1.00 27.98           O
HETATM  772  O   HOH A 544      -5.198  25.804  53.682  1.00 21.10           O
HETATM  800  O   HOH A 572      -6.768  26.204  53.124  1.00 14.71           O
HETATM  805  O   HOH A 577      21.563  28.198  52.938  1.00 31.45           O
HETATM  812  O   HOH A 585      -6.264  27.663  53.754  1.00 21.56           O
ENDMDL
MODEL        2
ATOM     85  N   ILE A 146       4.850  13.830  60.452  1.00 31.46           N
ATOM     86  CA  ILE A 146       5.654  15.038  60.565  1.00 28.74           C
ATOM     87  C   ILE A 146       5.963  15.310  62.021  1.00 27.82           C
ATOM     88  O   ILE A 146       5.062  15.510  62.825  1.00 28.89           O
ATOM     89  CB  ILE A 146       4.956  16.280  59.905  1.00 27.45           C
ATOM     90  CG1 ILE A 146       4.674  15.994  58.416  1.00 25.50           C
ATOM     91  CG2 ILE A 146       5.850  17.543  60.072  1.00 23.19           C
ATOM     92  CD1 ILE A 146       3.970  17.121  57.673  1.00 27.89           C
ATOM      0  H   ILE A 146       4.003  13.950  60.365  1.00 31.46           H   new
ATOM      0  HA  ILE A 146       6.481  14.891  60.080  1.00 28.74           H   new
ATOM      0  HB  ILE A 146       4.110  16.447  60.348  1.00 27.45           H   new
ATOM      0 HG12 ILE A 146       5.515  15.805  57.971  1.00 25.50           H   new
ATOM      0 HG13 ILE A 146       4.132  15.192  58.350  1.00 25.50           H   new
ATOM      0 HG21 ILE A 146       5.413  18.306  59.662  1.00 23.19           H   new
ATOM      0 HG22 ILE A 146       5.989  17.719  61.016  1.00 23.19           H   new
ATOM      0 HG23 ILE A 146       6.707  17.393  59.642  1.00 23.19           H   new
ATOM      0 HD11 ILE A 146       3.831  16.862  56.749  1.00 27.89           H   new
ATOM      0 HD12 ILE A 146       3.113  17.299  58.091  1.00 27.89           H   new
ATOM      0 HD13 ILE A 146       4.517  17.921  57.705  1.00 27.89           H   new
ATOM    137  N   GLU A 153      11.342  19.816  53.414  1.00 18.86           N
ATOM    138  CA  GLU A 153      11.328  20.597  52.204  1.00 20.88           C
ATOM    139  C   GLU A 153       9.887  21.060  51.996  1.00 20.14           C
ATOM    140  O   GLU A 153       8.976  20.225  51.945  1.00 18.33           O
ATOM    141  CB  GLU A 153      11.771  19.754  51.024  1.00 20.67           C
ATOM    142  CG  GLU A 153      11.890  20.570  49.780  1.00 28.25           C
ATOM    143  CD  GLU A 153      12.021  19.708  48.543  1.00 35.57           C
ATOM    144  OE1 GLU A 153      11.164  18.803  48.342  1.00 39.43           O
ATOM    145  OE2 GLU A 153      12.981  19.939  47.779  1.00 36.90           O
ATOM      0  H   GLU A 153      10.727  19.216  53.448  1.00 18.86           H   new
ATOM      0  HA  GLU A 153      11.935  21.350  52.274  1.00 20.88           H   new
ATOM      0  HB2 GLU A 153      12.625  19.340  51.224  1.00 20.67           H   new
ATOM      0  HB3 GLU A 153      11.135  19.036  50.881  1.00 20.67           H   new
ATOM      0  HG2 GLU A 153      11.111  21.141  49.694  1.00 28.25           H   new
ATOM      0  HG3 GLU A 153      12.662  21.153  49.850  1.00 28.25           H   new
ATOM    618  N   VAL A 216       4.506  19.838  52.802  1.00 21.99           N
ATOM    619  CA  VAL A 216       5.738  19.509  53.507  1.00 24.27           C
ATOM    620  C   VAL A 216       6.150  18.056  53.346  1.00 26.17           C
ATOM    621  O   VAL A 216       5.340  17.143  53.546  1.00 26.47           O
ATOM    622  CB  VAL A 216       5.593  19.757  55.039  1.00 25.53           C
ATOM    623  CG1 VAL A 216       6.935  19.548  55.734  1.00 23.77           C
ATOM    624  CG2 VAL A 216       5.055  21.160  55.299  1.00 22.33           C
ATOM      0  H   VAL A 216       3.828  19.373  53.053  1.00 21.99           H   new
ATOM      0  HA  VAL A 216       6.410  20.085  53.111  1.00 24.27           H   new
ATOM      0  HB  VAL A 216       4.960  19.119  55.404  1.00 25.53           H   new
ATOM      0 HG11 VAL A 216       6.834  19.705  56.686  1.00 23.77           H   new
ATOM      0 HG12 VAL A 216       7.238  18.638  55.586  1.00 23.77           H   new
ATOM      0 HG13 VAL A 216       7.587  20.168  55.372  1.00 23.77           H   new
ATOM      0 HG21 VAL A 216       4.969  21.302  56.255  1.00 22.33           H   new
ATOM      0 HG22 VAL A 216       5.667  21.815  54.929  1.00 22.33           H   new
ATOM      0 HG23 VAL A 216       4.186  21.256  54.879  1.00 22.33           H   new
ATOM    634  N   VAL A 218       9.047  15.495  54.747  1.00 24.30           N
ATOM    635  CA  VAL A 218       9.980  15.425  55.854  1.00 25.59           C
ATOM    636  C   VAL A 218      11.043  14.371  55.566  1.00 25.70           C
ATOM    637  O   VAL A 218      10.781  13.407  54.869  1.00 25.17           O
ATOM    638  CB  VAL A 218       9.161  15.143  57.136  1.00 26.71           C
ATOM    639  CG1 VAL A 218       9.460  13.782  57.688  1.00 28.12           C
ATOM    640  CG2 VAL A 218       9.374  16.262  58.126  1.00 28.81           C
ATOM      0  H   VAL A 218       8.514  14.824  54.675  1.00 24.30           H   new
ATOM      0  HA  VAL A 218      10.460  16.258  55.979  1.00 25.59           H   new
ATOM      0  HB  VAL A 218       8.215  15.126  56.923  1.00 26.71           H   new
ATOM      0 HG11 VAL A 218       8.933  13.635  58.489  1.00 28.12           H   new
ATOM      0 HG12 VAL A 218       9.237  13.108  57.027  1.00 28.12           H   new
ATOM      0 HG13 VAL A 218      10.403  13.721  57.906  1.00 28.12           H   new
ATOM      0 HG21 VAL A 218       8.861  16.085  58.930  1.00 28.81           H   new
ATOM      0 HG22 VAL A 218      10.316  16.321  58.351  1.00 28.81           H   new
ATOM      0 HG23 VAL A 218       9.083  17.100  57.735  1.00 28.81           H   new
TER     728      ILE A 218
HETATM  731  O   HOH A 503       7.663  18.549  58.083  1.00 71.06           O
HETATM  758  O   HOH A 530      20.116  27.095  51.665  1.00 24.67           O
HETATM  765  O   HOH A 537      14.778  21.226  48.211  1.00 27.98           O
HETATM  772  O   HOH A 544      -5.198  25.804  53.682  1.00 21.10           O
HETATM  805  O   HOH A 577      21.563  28.198  52.938  1.00 31.45           O
HETATM  812  O   HOH A 585      -6.264  27.663  53.754  1.00 21.56           O
ENDMDL
END
"""

expected_undowser_html = """<html>
<head>
  <title>Summary table of water clashes</title>
</head>

<body>

<hr>
This table lists all HOH "waters" in the structure that have steric clashes. HOH are classified into common categories based on the atom they clash with.
<br><br>
A clashing HOH is very unlikely be be a real water, unless the clashing atom position is incorrect. The following categories provide guidance for correcting false HOH.
<br><br>
<b>Clash with polar</b> - HOH that clashes with polar groups may actually be a coordinated ion.
<br>
<b>Clash with nonpolar</b> - HOH that clashes with nonpolar groups may be a missing or displaced atom&ast;. Or it may be the first atom of an unmodeled alternate.
<br>
<b>Clash with both polar and nonpolar</b> - HOH that clashes with both polar and non-polar groups is unlikely to be an ion. If clashes are severe, a displaced atom is likely. If clashes and map are weak, the HOH may be entirely removable.
<br>
<b>Clash with water</b> - HOH-HOH clashes may be real waters that need to be modeled as alternates of compatible occupancy. Or they may be in the density of a sidechain alternate or a larger ligand.
<br>
<b>Clash with altloc</b> - HOH clashes involving one or more alternate conformations may be resolved by renaming some of the alternates.
<br><br>
<b>High B-factor</b> - HOH with clashes and minimal support in the map should be removed from the model. This table does not report map data directly, but a high B-factor is a likely warning sign that an HOH is a poor fit to the map.
<br>
<b>Severe clash</b> - HOH with severe clash overlap but good map support is likely to be a position where an atom is displaced.
<br><br>
&ast;<i>Displaced atom</i> indicates that a structural atom has been moved from its proper place in the model and replaced by HOH. Displaced sidechains are common. Moved atoms may be restored by local rebuilding.
<br>
<i>Missing atoms</i> have been entirely replaced by HOH. Removed atoms may be restored by modeling alternate conformations (especially sidechains), modeling ligands, or continuing a macromolecular mainchain.
<br><br>
These categories are general suggestions. Check your electron density; trust your intuition and experience. Prisant 2020 Prot Sci 29:315 (<a href="https://doi.org/10.1002/pro.3786">https://doi.org/10.1002/pro.3786</a>) illustrates 10 examples of clashing HOH cases.
<br>
<hr>
<br>
SUMMARY: 7 waters out of 7 have clashes (100.00%)
<br><br>
<hr>
<br>
<table border=1 width='100%'>
<tr bgcolor='#9999cc'><td rowspan='1' align='center'>Water ID</td>
<td align='center'>Clashes with</td>
<td align='center'>Water B</td>
<td align='center'>Contact B</td>
<td align='center'>Clash<br>Severity</td>
<td align='center'>Clash with Polar<br><small>May be ion</small></td>
<td align='center'>Clash with non-polar<br><small>Unmodeled alt or noise</small></td>
<td align='center'>Clash with water<br><small>Occ &lt;1 or ligand</small></td>
<td align='center'>Clash with altloc<br><small>Add or rename alts</small></td></tr>
<tr bgcolor=#eaeaea><td rowspan='2' ><pre><code>A: 572 :HOH: </code></pre></td>
<td><pre><code> O   of A: 585 :HOH: </code></pre></td><td>14.71</td><td>21.56</td><td bgcolor='#ee4d4d'>1.133</td><td></td><td></td><td align='center' bgcolor='#ee4d4d'>&times;</td><td></td></tr>
<tr bgcolor=#eaeaea><td><pre><code> O   of A: 544 :HOH: </code></pre></td><td>14.71</td><td>21.10</td><td bgcolor='#ee4d4d'>1.086</td><td></td><td></td><td align='center' bgcolor='#ee4d4d'>&times;</td><td></td></tr>
<tr bgcolor=#ffffff><td rowspan='2' ><pre><code>A: 585 :HOH: </code></pre></td>
<td><pre><code> O   of A: 572 :HOH: </code></pre></td><td>21.56</td><td>14.71</td><td bgcolor='#ee4d4d'>1.133</td><td></td><td></td><td align='center' bgcolor='#ee4d4d'>&times;</td><td></td></tr>
<tr bgcolor=#ffffff><td><pre><code> O   of A: 544 :HOH: </code></pre></td><td>21.56</td><td>21.10</td><td bgcolor='#ff76a9'>0.656</td><td></td><td></td><td align='center' bgcolor='#ff76a9'>&times;</td><td></td></tr>
<tr bgcolor=#eaeaea><td rowspan='2' ><pre><code>A: 544 :HOH: </code></pre></td>
<td><pre><code> O   of A: 572 :HOH: </code></pre></td><td>21.10</td><td>14.71</td><td bgcolor='#ee4d4d'>1.086</td><td></td><td></td><td align='center' bgcolor='#ee4d4d'>&times;</td><td></td></tr>
<tr bgcolor=#eaeaea><td><pre><code> O   of A: 585 :HOH: </code></pre></td><td>21.10</td><td>21.56</td><td bgcolor='#ff76a9'>0.656</td><td></td><td></td><td align='center' bgcolor='#ff76a9'>&times;</td><td></td></tr>
<tr bgcolor=#ffffff><td rowspan='4' ><pre><code>A: 503 :HOH: </code></pre></td>
<td><pre><code>HG11 of A: 216 :VAL: </code></pre></td><td>71.06</td><td>23.77</td><td bgcolor='#ff76a9'>0.626</td><td></td><td align='center' bgcolor='#ff76a9'>&times;</td><td></td><td></td></tr>
<tr bgcolor=#ffffff><td><pre><code>HG23 of A: 218 :VAL: </code></pre></td><td>71.06</td><td>28.81</td><td bgcolor='#ff76a9'>0.562</td><td></td><td align='center' bgcolor='#ff76a9'>&times;</td><td></td><td></td></tr>
<tr bgcolor=#ffffff><td><pre><code>HG23 of A: 146 :ILE: </code></pre></td><td>71.06</td><td>23.19</td><td bgcolor='#ffb3cc'>0.456</td><td></td><td align='center' bgcolor='#ffb3cc'>&times;</td><td></td><td></td></tr>
<tr bgcolor=#ffffff><td><pre><code> CG1 of A: 216 :VAL: </code></pre></td><td>71.06</td><td>23.77</td><td bgcolor='#ffb3cc'>0.446</td><td></td><td align='center' bgcolor='#ffb3cc'>&times;</td><td></td><td></td></tr>
<tr bgcolor=#eaeaea><td rowspan='1' ><pre><code>A: 530 :HOH: </code></pre></td>
<td><pre><code> O   of A: 577 :HOH: </code></pre></td><td>24.67</td><td>31.45</td><td bgcolor='#ff76a9'>0.579</td><td></td><td></td><td align='center' bgcolor='#ff76a9'>&times;</td><td></td></tr>
<tr bgcolor=#ffffff><td rowspan='1' ><pre><code>A: 577 :HOH: </code></pre></td>
<td><pre><code> O   of A: 530 :HOH: </code></pre></td><td>31.45</td><td>24.67</td><td bgcolor='#ff76a9'>0.579</td><td></td><td></td><td align='center' bgcolor='#ff76a9'>&times;</td><td></td></tr>
<tr bgcolor=#eaeaea><td rowspan='1' ><pre><code>A: 537 :HOH: </code></pre></td>
<td><pre><code> OE2 of A: 153 :GLU: </code></pre></td><td>27.98</td><td>36.90</td><td bgcolor='#ff76a9'>0.548</td><td align='center' bgcolor='#ff76a9'>&plus; ion</td><td></td><td></td><td></td></tr>
</table>
"""

def exercise_undowser(probe_params):
  dm = DataManager()
  #print(help(dm))
  dm.process_model_str("1",pdb_1lpl_str)
  m = dm.get_model("1")
  uz = undowser2.undowserlyze(probe_params, dm)
  undowser_html = uz.as_HTML()
  diff = difflib.unified_diff(undowser_html.splitlines(), expected_undowser_html.splitlines(), fromfile="testvalue", tofile="expectedvalue")
  changed_lines = ""
  for line in diff:
    if line.startswith("-") or line.startswith("+"):
      changed_lines = changed_lines+"\n"+line
  assert changed_lines == "", "undowser html output changed, at the following lines: "+changed_lines

def exercise_undowser_json(probe_params):
  dm = DataManager()
  #print(help(dm))
  dm.process_model_str("1",pdb_1lpl_str)
  m = dm.get_model("1")
  uz = undowser2.undowserlyze(probe_params, dm)
  uz_dict = json.loads(uz.as_JSON())
  #import pprint
  #pprint.pprint(csjson_dict)
  assert len(uz_dict['flat_results']) == 13, "tst_undowser2 json output not returning correct number of water clashes, now: "+str(len(uz_dict['flat_results']))
  assert uz_dict['flat_results'][0]["src_atom_id"] == " A 503 HOH  O   ", "tst_undowser2 json output first src_atom_id value changed, now: "+uz_dict['flat_results'][0]["src_atom_id"]
  from mmtbx.validation import test_utils
  assert test_utils.count_dict_values(uz_dict['hierarchical_results'], "water clash")==12, "tst_undowser2 json hierarchical output total number of water clashes changed, now: "+str(test_utils.count_dict_values(uz_dict['hierarchical_results'], "water clash"))
  assert test_utils.count_dict_values(uz_dict['hierarchical_results'], "nonpolar clash")==8, "tst_undowser2 json hierarchical output total number of nonpolar clashes changed, now: "+str(test_utils.count_dict_values(uz_dict['hierarchical_results'], "nonpolar clash"))
  assert test_utils.count_dict_values(uz_dict['hierarchical_results'], "polar clash")==2, "tst_undowser2 json hierarchical output total number of polar clashes changed, now: "+str(test_utils.count_dict_values(uz_dict['hierarchical_results'], "polar clash"))
  assert uz_dict['summary_results']["   1"]["num_outliers"] == 7, "tst_undowser2 json summary output total number of water clashes changed, now: "+str(uz_dict['summary_results']["   1"]["num_outliers"])
  assert uz_dict['summary_results']["   1"]["num_waters"] == 7, "tst_undowser2 json summary output total number of waters changed"

if (__name__ == "__main__"):
  if (not libtbx.env.has_module(name="probe")):
    print("Skipping exercise_undowser(): probe not configured")
    print("OK")
  else:
    parser = iotbx.cli_parser.CCTBXParser(program_class=probe2.Program, logger=null_out())
    args = [ 'approach=once' ]
    parser.parse_args(args)
    probe_params = parser.working_phil.extract()
    t0 = time.time()
    exercise_undowser(probe_params)
    exercise_undowser_json(probe_params)
    print("OK. Time: %8.3f"%(time.time()-t0))


 *******************************************************************************


 *******************************************************************************
mmtbx/validation/regression/tst_waters.py

from __future__ import absolute_import, division, print_function
from six.moves import cStringIO as StringIO
from libtbx.test_utils import show_diff
from libtbx.utils import null_out
from libtbx import easy_pickle
from libtbx import group_args
from iotbx.data_manager import DataManager
from mmtbx.regression import make_fake_anomalous_data
import mmtbx.ions.utils
import iotbx.pdb
import mmtbx.model
from mmtbx.validation import waters

def exercise_heavy():

  file_base = "tst_validate_waters_1"
  pdb_file = make_fake_anomalous_data.write_pdb_input_cd_cl(file_base=file_base)
  mtz_file = make_fake_anomalous_data.generate_mtz_file(
    file_base="tst_validate_waters_1",
    d_min=1.5,
    anomalous_scatterers=[
      group_args(selection="element CD", fp=-0.29, fdp=2.676),
      group_args(selection="element CL", fp=0.256, fdp=0.5),
    ])

  pdb_in = iotbx.pdb.input(pdb_file)
  m1 = mmtbx.model.manager(model_input = pdb_in, log = null_out())
  hierarchy, n = mmtbx.ions.utils.anonymize_ions(m1.get_hierarchy(),
                                                 log=null_out())
  fn_anonymized = file_base + '_start.pdb'
  hierarchy.write_pdb_file(fn_anonymized,crystal_symmetry=m1.crystal_symmetry())
  dm = DataManager()
  m = dm.get_model(fn_anonymized)
  ma = dm.get_miller_arrays(filename = mtz_file)
  fmo = dm.get_fmodel(scattering_table="n_gaussian")
  results = waters.waters(
    pdb_hierarchy=m.get_hierarchy(),
    xray_structure=m.get_xray_structure(),
    fmodel=fmo,
    collect_all=True)
  out = StringIO()
  results.show(out=out)
  s = easy_pickle.dumps(results)
  r2 = easy_pickle.loads(s)
  out2 = StringIO()
  r2.show(out=out2)
  assert not show_diff(out.getvalue(), out2.getvalue())
  assert (results.n_bad >= 1) and (results.n_heavy == 2)
  # XXX statistics are approximate (probably a precision issue), so we can't
  # directly compare outputs

if (__name__ == "__main__"):
  exercise_heavy()
  print("OK")


 *******************************************************************************


 *******************************************************************************
mmtbx/validation/restraints.py

"""
Validation of models of any type against basic covalent geometry restraints.
By default this will flag all restrained atoms deviating by more than 4 sigma
from the target value.
"""

from __future__ import absolute_import, division, print_function
from mmtbx.validation import atoms, validation, get_atoms_info
from libtbx.str_utils import make_sub_header
from libtbx import slots_getstate_setstate
from math import sqrt
import sys
import json
import collections

__restraint_attr__ = [
  "sigma",
  "target",
  "model",
  "delta",
  "residual",
] # XXX others?

class restraint(atoms):
  n_atoms = None
  """
  Base class for covalent sterochemistry restraint outliers (except for
  planarity, which is weird and different).  Unlike most of the other
  outlier implementations elsewhere in the validation module, the restraint
  outliers are printed on multiple lines to facilitate display of the atoms
  involved.
  """
  __slots__ = atoms.__slots__ + __restraint_attr__
  def __init__(self, **kwds):
    atoms.__init__(self, **kwds)
    if (self.n_atoms is not None):
      assert (len(self.atoms_info) == self.n_atoms)
    if (self.score is None):
      self.score = abs(self.delta / self.sigma)

  @staticmethod
  def header():
    return "%-20s  %7s  %7s  %7s  %6s  %6s  %10s" % ("atoms", "ideal", "model",
      "delta", "sigma", "residual", "deviation")

  def as_JSON(self):
    atom_info_list = []
    for atom_inf in self.atoms_info:
      atom_slots_list = [s for s in atom_inf.__slots__]
      atom_slots_as_dict = ({s: getattr(atom_inf, s) for s in atom_slots_list })
      atom_info_list.append(atom_slots_as_dict)

    serializable_slots = [s for s in self.__slots__ if s != 'markup' and s != 'atoms_info' and hasattr(self, s)]
    slots_as_dict = ({s: getattr(self, s) for s in serializable_slots})
    #slots_as_dict["xyz"] = slots_as_dict["xyz"].elems
    if callable(getattr(self, "outlier_type", None)):
      slots_as_dict["outlier_type"] = self.outlier_type()
    slots_as_dict["atoms_info"] = atom_info_list
    #res_type_index = slots_as_dict['res_type']
    #slots_as_dict['res_type'] = res_types[res_type_index]
    #slots_as_dict['res_type_label'] = res_type_labels[res_type_index]
    return json.dumps(slots_as_dict, indent=2)

  def as_hierarchical_JSON(self):
    hierarchical_dict = {}
    hierarchy_nest_list = ['model_id', 'chain_id', 'resid', 'altloc']
    return json.dumps(self.nest_dict(hierarchy_nest_list, hierarchical_dict), indent=2)

  def as_table_row_phenix(self):
    """
    Values for populating ListCtrl in Phenix GUI.
    """
    atoms_str = ", ".join([ a.id_str() for a in self.atoms_info ])
    return [ atoms_str, self.target, self.model, self.score ]

  def id_str(self, ignore_altloc=None):
    return ",".join([ a.id_str() for a in self.atoms_info ])

  def as_string(self, prefix=""):
    id_strs = [ a.id_str() for a in self.atoms_info ]
    id_len = max([ len(s) for s in id_strs ])
    lines = []
    for atom_str in id_strs :
      lines.append("%s%-20s" % (prefix, atom_str))
    lines[-1] += "  " + self.format_values()
    lines = [s.rstrip() for s in lines]
    return "\n".join(lines)

  def format_values(self):
    return "%7.2f  %7.2f  %7.2f  %6.2e  %6.2e  %4.1f*sigma" % (self.target,
      self.model, self.delta, self.sigma, self.residual, self.score)

  def __cmp__(self, other):
    return cmp(other.score, self.score)

  def __eq__(self, other):
    return self.score == other.score

  def __ne__(self, other):
    return self.score != other.score

  def __lt__(self, other):
    return self.score < other.score

  def __le__(self, other):
    return self.score <= other.score

  def __gt__ (self, other):
    return self.score > other.score

  def __ge__(self, other):
    return self.score >= other.score

  def kinemage_key(self):
    atom0 = self.atoms_info[0]
    # bonds are assigned to the following residue
    if len(self.atoms_info)==2:
      atom0 = self.atoms_info[1]
    # angles are assigned to the central atom's residue
    elif len(self.atoms_info)==3:
      atom0 = self.atoms_info[1]
    # dihedrals are assigned to the following residue - this applies to
    # omega dihedral but planes are not a problem
    elif len(self.atoms_info)==4:
      atom0 = self.atoms_info[2]
    atom_names = [ a.name.strip().lower() for a in self.atoms_info ]
    kin_key = "%1s%3s%2s%4s%1s %s" % (self.get_altloc(),
      atom0.resname.lower(), atom0.chain_id, atom0.resseq, atom0.icode,
      "-".join(atom_names))
    return kin_key

class bond(restraint):
  n_atoms = 2
  __bond_attr__ = [
    "slack",
    "symop",
  ]
  __slots__ = restraint.__slots__ + __bond_attr__
  def as_table_row_phenix(self):
    return [ self.atoms_info[0].id_str(), self.atoms_info[1].id_str(),
             self.target, self.model, self.score ]

  @staticmethod
  def header():
    return "%-20s  %5s  %6s  %6s  %6s  %6s  %8s  %10s" % ("atoms", "ideal",
      "model", "delta", "sigma", "slack", "residual", "deviation")

  def formate_values(self):
    return "%5.3f  %6.2f  %6.3f  %6.3f  %6.2e  %8.2e  %4.1f*sigma" % \
      (self.target, self.model, self.delta, self.sigma, self.slack,
       self.residual, abs(self.score))

  def as_kinemage(self):
    from mmtbx.kinemage.validation import bond_outlier_as_kinemage
    return bond_outlier_as_kinemage(self)

class angle(restraint):
  n_atoms = 3
  def as_kinemage(self):
    from mmtbx.kinemage.validation import angle_outlier_as_kinemage
    return angle_outlier_as_kinemage(self)

class dihedral(restraint):
  n_atoms = 4
  def as_kinemage(self):
    return None

class chirality(restraint):
  def as_kinemage(self):
    from mmtbx.kinemage.validation import chiral_outlier_as_kinemage
    return chiral_outlier_as_kinemage(self)

  def as_table_row_phenix(self):
    """
    Values for populating ListCtrl in Phenix GUI.
    """
    atoms_str = ", ".join([ a.id_str() for a in self.atoms_info ])
    return [ atoms_str, self.target, self.model, self.score, self.outlier_type() ]

  def is_pseudochiral(self):
    #Certain atoms are treated like chiral centers because they bond to atoms that have different names without chemical difference.
    #VAL CB bonds to CG1 and CG2, for example.
    #A large chiral volume outlier reflects a failure to follow chemical naming conventions, not necessarily a major geometry error
    #So these pseudochiral centers should be treated differently.
    #
    #backbone phosphate in nucleic acids
    #OP1 and OP2 atoms are chemically identical
    resname = self.atoms_info[0].resname
    atomname = self.atoms_info[0].name.strip()
    if atomname == 'P': return True
    #SF4 and F3S are iron-sulfur clusters with frequent naming problems
    if resname in ['SF4','F3S']: return True
    #Val CG1 and CG2 are chemically identical
    if resname == 'VAL' and atomname == 'CB': return True
    #LEU CD1 and CD2 are chemically identical
    if resname == 'LEU' and atomname == 'CG': return True
    #Otherwise
    return False

  def is_handedness_swap(self):
    resname = self.atoms_info[0].resname
    if resname in ['PRO','DPR']: #proline has slightly different geometry
      if self.score > 22:
        return True
    elif self.score > 20:
      return True
    else:
      return False

  def outlier_type(self):
    if self.score <= 4: return None
    if not self.is_handedness_swap():
      return "Tetrahedral geometry outlier"
    else:
      if self.is_pseudochiral():
        return "Pseudochiral naming error"
      else:
        return "Chiral handedness swap"

class planarity(restraint):
  __slots__ = atoms.__slots__ + [
    "rms_deltas",
    "delta_max",
    "residual",
  ]
  def as_table_row_phenix(self):
    atoms_str = ", ".join([ a.id_str() for a in self.atoms_info ])
    return [ atoms_str, self.delta_max, self.rms_deltas, self.score ]

  @staticmethod
  def header():
    return "%-20s  %10s  %10s  %10s  %10s" % ("atoms", "rms_deltas",
      "delta_max", "residual", "deviation")

  def format_values(self):
    return "%10.3f  %10.3f  %10.2f  %4.1f*sigma" % (self.rms_deltas,
      self.delta_max, self.residual, self.score)

  def as_kinemage(self):
    return None

class restraint_validation(validation):
  """
  Base class for collecting information about all restraints of a certain
  type, including overall statistics and individual outliers.
  """
  restraint_type = None
  kinemage_header = None
  gui_list_headers = ["Atoms","Ideal value","Model value","Deviation (sigmas)"]
  gui_formats = ["%s", "%.3f", "%.3f", "%.1f"]
  wx_column_widths = [500, 100, 100, 180]
  __restraints_attr__ = [
    "min",
    "max",
    "mean",
    "z_min",
    "z_max",
    "z_mean",
    "target",
  ]
  __slots__ = validation.__slots__ + __restraints_attr__
  def __init__(self,
      pdb_atoms,
      sites_cart,
      energies_sites,
      restraint_proxies,
      unit_cell,
      ignore_hd=True,
      sigma_cutoff=4.0,
      outliers_only=True,
      reverse_sort=False,
      use_segids_in_place_of_chainids=False):
    validation.__init__(self)
    self.z_min = self.z_max = self.z_mean = None
    deviations_method = getattr(energies_sites, "%s_deviations" %
      self.restraint_type)
    self.n_total = getattr(energies_sites, "n_%s_proxies" %
      self.restraint_type)
    tmp = deviations_method()
    if len(tmp)==4:
      self.min, self.max, self.mean, self.n_total = tmp
    else:
      self.min, self.max, self.mean = tmp
    target = getattr(energies_sites, "%s_residual_sum" %
      self.restraint_type)
    if (self.n_total > 0):
      self.target = target / self.n_total
    else :
      self.target = 0
    deviations_z_method = getattr(energies_sites, "%s_deviations_z" %
      self.restraint_type, None)
    if (deviations_z_method is not None):
      deviations_z = deviations_z_method()
      self.z_min, self.z_max, self.z_mean, junk = deviations_z_method()
    self.n_outliers_by_model = {}
    self.results = sorted(self.get_outliers(
      proxies=restraint_proxies,
      unit_cell=unit_cell,
      sites_cart=sites_cart,
      pdb_atoms=pdb_atoms,
      sigma_cutoff=sigma_cutoff,
      outliers_only=outliers_only,
      use_segids_in_place_of_chainids=use_segids_in_place_of_chainids), reverse=reverse_sort)
    self.n_outliers = len(self.results) #this appears as if it will give wrong results if outliers_only=True
    self.get_n_total_by_model(energies_sites, sites_cart, pdb_atoms)

  def get_outliers(self, proxies, unit_cell, sites_cart, pdb_atoms,
      sigma_cutoff):
    raise NotImplementedError()

  def show_old_output(self, *args, **kwds):
    raise NotImplementedError()

  def show(self, out=sys.stdout, prefix="  ", verbose=True):
    if (len(self.results) > 0):
      print(prefix + self.get_result_class().header(), file=out)
      for result in self.results :
        print(result.as_string(prefix=prefix), file=out)
    self.show_summary(out=out, prefix=prefix)

  def show_summary(self, out=sys.stdout, prefix=""):
    if (self.n_total == 0):
      print(prefix + "No restraints of this type.", file=out)
      return
    elif (self.n_outliers == 0):
      print(prefix + \
        "All restrained atoms within 4.0 sigma of ideal values.", file=out)
    print("", file=out)
    if (self.z_mean is not None):
      print(prefix + "Min. delta:  %7.3f (Z=%7.3f)" % (self.min,
        self.z_min), file=out)
      print(prefix + "Max. delta:  %7.3f (Z=%7.3f)" % (self.max,
        self.z_max), file=out)
      print(prefix + "Mean delta:  %7.3f (Z=%7.3f)" % (self.mean,
        self.z_mean), file=out)
    else :
      print(prefix + "Min. delta:  %7.3f" % self.min, file=out)
      print(prefix + "Max. delta:  %7.3f" % self.max, file=out)
      print(prefix + "Mean delta:  %7.3f" % self.mean, file=out)

# the subclasses bonds and planarities have different versions of this function
  def get_n_total_by_model(self, energies_sites, sites_cart, pdb_atoms):
    self.n_total_by_model = {}
    proxies = getattr(energies_sites, "%s_proxies" % self.restraint_type)
    sorted_prox, not_shown = proxies.get_sorted("delta", sites_cart)
    if sorted_prox:
      for prox in sorted_prox:
        atom_indexes = prox[0]
        first_atom_index = int(atom_indexes[0])
        model_id = pdb_atoms[first_atom_index].parent().parent().parent().parent().id
        if model_id not in self.n_total_by_model:
          self.n_total_by_model[model_id] = 1
        else:
          self.n_total_by_model[model_id] += 1

  def as_JSON(self, addon_json={}):
    if not addon_json:
      addon_json = {}
    addon_json["validation_type"] = self.restraint_type
    data = addon_json
    flat_results = []
    hierarchical_results = {}
    summary_results = {}
    for result in self.results:
      flat_results.append(json.loads(result.as_JSON()))
      hier_result = json.loads(result.as_hierarchical_JSON())
      hierarchical_results = self.merge_dict(hierarchical_results, hier_result)

    data['flat_results'] = flat_results
    data['hierarchical_results'] = hierarchical_results

    for model_id in self.n_total_by_model.keys():
      summary_results[model_id] = { "num_outliers" : self.n_outliers_by_model[model_id],
        "num_total" : self.n_total_by_model[model_id],
      }
    data['summary_results'] = summary_results
    return json.dumps(data, indent=2)

  def as_kinemage(self, chain_id=None):
    header = self.kinemage_header
    if (header is not None):
      kin_blocks = []
      for result in self.results :
        if (result.is_outlier()) and (result.is_in_chain(chain_id)):
          outlier_kin_txt = result.as_kinemage()
          if (outlier_kin_txt is not None):
            kin_blocks.append(outlier_kin_txt)
      return header + "\n".join(kin_blocks)
    return None

class bonds(restraint_validation):
  restraint_type = "bond"
  restraint_label = "Bond length"
  kinemage_header = "@subgroup {length devs} dominant\n"
  gui_list_headers = ["Atom 1","Atom 2","Ideal value","Model value",
                      "Deviation (sigmas)"]
  gui_formats = ["%s", "%s", "%.3f", "%.3f", "%.1f"]
  wx_column_widths = [150, 150, 100, 100, 180]

  def get_result_class(self) : return bond

  def get_outliers(self, proxies, unit_cell, sites_cart, pdb_atoms,
      sigma_cutoff, outliers_only=True,
      use_segids_in_place_of_chainids=False):
    from scitbx.array_family import flex
    from cctbx.geometry_restraints.linking_class import linking_class
    origin_ids = linking_class()
    site_labels = flex.bool(sites_cart.size(), True).iselection()
    sorted_table, not_shown = proxies.get_sorted(
      by_value="residual",
      sites_cart=sites_cart,
      site_labels=site_labels,
      origin_id=origin_ids.get_origin_id('covalent geometry'))
    # this can happen for C-alpha-only models, etc.
    if (sorted_table is None):
      return []
    outliers = []
    for restraint_info in sorted_table :
      (i_seq, j_seq, i_seqs, ideal, model, slack, delta, sigma, weight, residual, sym_op_j,
       rt_mx) = restraint_info
      bond_atoms = get_atoms_info(pdb_atoms, iselection=i_seqs,
        use_segids_in_place_of_chainids=use_segids_in_place_of_chainids)
      model_id = bond_atoms[0].model_id
      if model_id not in self.n_outliers_by_model:
        # initialize dicts.  covers cases where some structures don't have certain outliers
        self.n_outliers_by_model[model_id] = 0
      if sym_op_j:
        import scitbx
        m3 = rt_mx.r().as_double()
        m3 = scitbx.matrix.sqr(m3)
        t = rt_mx.t().as_double()
        t = scitbx.matrix.col((t[0],t[1],t[2]))
        xyz = unit_cell.fractionalize(flex.vec3_double([bond_atoms[1].xyz]))
        new_xyz = unit_cell.orthogonalize(m3.elems*xyz+t)
        bond_atoms[1].xyz = new_xyz[0]
      outlier = bond(
        atoms_info=bond_atoms,
        target=ideal,
        model=model,
        sigma=sigma,
        slack=slack,
        delta=delta,
        residual=residual,
        symop=sym_op_j,
        outlier=True,
        xyz=get_mean_xyz(bond_atoms))
      if (outlier.score > sigma_cutoff):
        outliers.append(outlier)
        self.n_outliers_by_model[model_id] += 1
      elif (not outliers_only):
        outlier.outlier=False
        outliers.append(outlier)
    return outliers

  def get_n_total_by_model(self, energies_sites, sites_cart, pdb_atoms):
    self.n_total_by_model = {}
    proxies = getattr(energies_sites, "%s_proxies" % self.restraint_type)
    sorted_prox, not_shown = proxies.get_sorted("delta", sites_cart)
    if sorted_prox:
      for prox in sorted_prox:
        first_atom_index = prox[0]
        model_id = pdb_atoms[first_atom_index].parent().parent().parent().parent().id
        if model_id not in self.n_total_by_model:
          self.n_total_by_model[model_id] = 1
        else:
          self.n_total_by_model[model_id] += 1

class angles(restraint_validation):
  restraint_type = "angle"
  restraint_label = "Bond angle"
  kinemage_header = "@subgroup {geom devs} dominant\n"
  def get_result_class(self) : return angle

  def get_outliers(self, proxies, unit_cell, sites_cart, pdb_atoms,
      sigma_cutoff, outliers_only=True,
      use_segids_in_place_of_chainids=False):
    import cctbx.geometry_restraints
    sorted = _get_sorted(proxies,
      unit_cell=unit_cell,
      sites_cart=sites_cart,
      pdb_atoms=pdb_atoms,
      use_segids_in_place_of_chainids=use_segids_in_place_of_chainids)
    outliers = []
    for proxy, proxy_atoms in sorted :
      model_id = proxy_atoms[0].model_id
      if model_id not in self.n_outliers_by_model:
        # initialize dicts.  covers cases where some structures don't have certain outliers
        self.n_outliers_by_model[model_id] = 0
      restraint = cctbx.geometry_restraints.angle(
        unit_cell=unit_cell,
        proxy=proxy,
        sites_cart=sites_cart)
      outlier = angle(
        atoms_info=proxy_atoms,
        target=restraint.angle_ideal,
        delta=restraint.delta,
        model=restraint.angle_model,
        sigma=cctbx.geometry_restraints.weight_as_sigma(restraint.weight),
        residual=restraint.residual(),
        outlier=True,
        xyz=proxy_atoms[1].xyz)
      if (outlier.score > sigma_cutoff):
        outliers.append(outlier)
        self.n_outliers_by_model[model_id] += 1
      elif (not outliers_only):
        outlier.outlier=False
        outliers.append(outlier)
    return outliers

class dihedrals(restraint_validation):
  restraint_type = "dihedral"
  restraint_label = "Dihedral angle"
  def get_result_class(self) : return dihedral

  def get_outliers(self, proxies, unit_cell, sites_cart, pdb_atoms,
      sigma_cutoff, outliers_only=True,
      use_segids_in_place_of_chainids=False):
    import cctbx.geometry_restraints
    sorted = _get_sorted(proxies,
      unit_cell=unit_cell,
      sites_cart=sites_cart,
      pdb_atoms=pdb_atoms)
    outliers = []
    for proxy, proxy_atoms in sorted :
      model_id = proxy_atoms[0].model_id
      if model_id not in self.n_outliers_by_model:
        self.n_outliers_by_model[model_id] = 0
      restraint = cctbx.geometry_restraints.dihedral(
        unit_cell=unit_cell,
        proxy=proxy,
        sites_cart=sites_cart)
      outlier = dihedral(
        atoms_info=proxy_atoms,
        target=restraint.angle_ideal,
        delta=restraint.delta,
        model=restraint.angle_model,
        sigma=cctbx.geometry_restraints.weight_as_sigma(restraint.weight),
        residual=restraint.residual(),
        xyz=get_mean_xyz([proxy_atoms[1], proxy_atoms[2]]),
        outlier=True)
      if (outlier.score > sigma_cutoff):
        outliers.append(outlier)
        self.n_outliers_by_model[model_id] += 1
      elif (not outliers_only):
        outlier.outlier=False
        outliers.append(outlier)
    return outliers

class chiralities(restraint_validation):
  restraint_type = "chirality"
  restraint_label = "Chiral volume"
  kinemage_header = "@subgroup {chiral devs} dominant\n"
  gui_list_headers = ["Atoms","Ideal value","Model value",
                      "Deviation (sigmas)","Probable cause"]
  gui_formats = ["%s", "%.3f", "%.3f", "%.1f", "%s"]
  wx_column_widths = [250, 100, 100, 180, 250]
  __chiralities_slots__ = ["n_handedness_by_model", "n_pseudochiral_by_model", "n_tetrahedral_by_model", "n_chiral_by_model"]
  __slots__ = restraint_validation.__slots__ + __chiralities_slots__
  def get_result_class(self) : return chirality

  def get_outliers(self, proxies, unit_cell, sites_cart, pdb_atoms,
      sigma_cutoff, outliers_only=True,
      use_segids_in_place_of_chainids=False):
    self.n_handedness_by_model = collections.defaultdict(int)
    self.n_pseudochiral_by_model = collections.defaultdict(int)
    self.n_tetrahedral_by_model = collections.defaultdict(int)
    self.n_chiral_by_model = collections.defaultdict(int)
    import cctbx.geometry_restraints
    sorted = _get_sorted(proxies,
      unit_cell=None,
      sites_cart=sites_cart,
      pdb_atoms=pdb_atoms)
    outliers = []
    for proxy, proxy_atoms in sorted :
      restraint = cctbx.geometry_restraints.chirality(
        proxy=proxy,
        sites_cart=sites_cart)
      outlier = chirality(
        atoms_info=proxy_atoms,
        target=restraint.volume_ideal,
        delta=restraint.delta,
        model=restraint.volume_model,
        sigma=cctbx.geometry_restraints.weight_as_sigma(restraint.weight),
        residual=restraint.residual(),
        outlier=True,
        xyz=get_mean_xyz(proxy_atoms))
      model_id = proxy_atoms[0].model_id
      if model_id not in self.n_outliers_by_model:
        # initialize dicts.  covers cases where some structures don't have certain outliers
        self.n_handedness_by_model[model_id] = 0
        self.n_pseudochiral_by_model[model_id] = 0
        self.n_tetrahedral_by_model[model_id] = 0
        self.n_chiral_by_model[model_id] = 0
        self.n_outliers_by_model[model_id] = 0
      if not outlier.is_pseudochiral():
        self.n_chiral_by_model[model_id] += 1
      if (outlier.score > sigma_cutoff):
        outliers.append(outlier)
        if model_id not in self.n_outliers_by_model:
          self.n_outliers_by_model[model_id] = 1
        else:
          self.n_outliers_by_model[model_id] += 1
        self.increment_category_counts(model_id, outlier)
      elif (not outliers_only):
        outlier.outlier=False
        outliers.append(outlier)
    self.n_handedness_by_model.default_factory = None
    self.n_pseudochiral_by_model.default_factory = None
    self.n_tetrahedral_by_model.default_factory = None
    self.n_chiral_by_model.default_factory = None
    return outliers

  def increment_category_counts(self, model_id, outlier):
    if not outlier.is_handedness_swap():
      self.n_tetrahedral_by_model[model_id] += 1
    else:
      if outlier.is_pseudochiral():
        self.n_pseudochiral_by_model[model_id] += 1
      else:
        self.n_handedness_by_model[model_id] += 1

  def as_JSON(self, addon_json={}):
    parent_json = json.loads(restraint_validation.as_JSON(self, addon_json))
    summary_results = parent_json['summary_results']
    for model_id in summary_results:
      summary_results[model_id]["num_handedness_outliers"] = self.n_handedness_by_model[model_id]
      summary_results[model_id]["num_chiral_centers"] = self.n_chiral_by_model[model_id]
      summary_results[model_id]["num_tetrahedral_outliers"] = self.n_tetrahedral_by_model[model_id]
      summary_results[model_id]["num_pseudochiral_outliers"] = self.n_pseudochiral_by_model[model_id]
    return json.dumps(parent_json, indent=2)


class planarities(restraint_validation):
  restraint_type = "planarity"
  restraint_label = "Planar group"
  gui_list_headers = ["Atoms", "Max. delta", "RMS(delta)", "Deviation (sigmas)"]
  gui_formats = ["%s", "%.3f", "%.3f", "%.1f"]
  wx_column_widths = [250, 100, 100, 130]

  def get_result_class(self) : return planarity

  def get_outliers(self, proxies, unit_cell, sites_cart, pdb_atoms,
      sigma_cutoff, outliers_only=True,
      use_segids_in_place_of_chainids=False):
    import cctbx.geometry_restraints
    from scitbx.array_family import flex
    site_labels = flex.bool(sites_cart.size(), True).iselection()
    sorted_table, n_not_shown = proxies.get_sorted(
      by_value="residual",
      sites_cart=sites_cart,
      site_labels=site_labels,
      unit_cell=unit_cell)
    if (sorted_table is None) : return []
    outliers = []
    for restraint_info in sorted_table :
      (plane_atoms, rms_delta, residual) = restraint_info
      i_seqs = [ a[0] for a in plane_atoms ]
      deviation = max([ a[1] / a[2] for a in plane_atoms ])
      plane_atoms_ = get_atoms_info(pdb_atoms, iselection=i_seqs)
      outlier = planarity(
        atoms_info=plane_atoms_,
        rms_deltas=rms_delta,
        residual=residual,
        delta_max=max([ a[1] for a in plane_atoms ]),
        score=deviation,
        outlier=True,
        xyz=get_mean_xyz(plane_atoms_))
      if (outlier.score > sigma_cutoff):
        outliers.append(outlier)
        model_id = plane_atoms_[0].model_id
        if model_id not in self.n_outliers_by_model:
          # initialize dicts.  covers cases where some structures don't have certain outliers
          self.n_outliers_by_model[model_id] = 0
        if model_id not in self.n_outliers_by_model:
          self.n_outliers_by_model[model_id] = 1
        else:
          self.n_outliers_by_model[model_id] += 1
      elif (not outliers_only):
        outlier.outlier=False
        outliers.append(outlier)
    return outliers

  def get_n_total_by_model(self, energies_sites, sites_cart, pdb_atoms):
    self.n_total_by_model = {}
    proxies = getattr(energies_sites, "%s_proxies" % self.restraint_type)
    sorted_prox, not_shown = proxies.get_sorted("residual", sites_cart)
    if sorted_prox:
      for prox in sorted_prox:
        first_plane = prox[0]
        atom_indexes = first_plane[0]
        first_atom_index = int(atom_indexes[0])
        model_id = pdb_atoms[first_atom_index].parent().parent().parent().parent().id
        if model_id not in self.n_total_by_model:
          self.n_total_by_model[model_id] = 1
        else:
          self.n_total_by_model[model_id] += 1

def get_mean_xyz(atoms):
  from scitbx.matrix import col
  sum = col(atoms[0].xyz)
  for atom in atoms[1:] :
    sum += col(atom.xyz)
  mean = sum / len(atoms)
  return mean.elems

def _get_sorted(O,
        unit_cell,
        sites_cart,
        pdb_atoms,
        by_value="residual",
        use_segids_in_place_of_chainids=False):
  assert by_value in ["residual", "delta"]
  if (O.size() == 0): return []
  import cctbx.geometry_restraints
  from scitbx.array_family import flex
  from cctbx.geometry_restraints.linking_class import linking_class
  origin_ids = linking_class()

  deltas = flex.abs(O.deltas(sites_cart=sites_cart))
  residuals = O.residuals(sites_cart=sites_cart)
  if (by_value == "residual"):
    data_to_sort = residuals
  elif (by_value == "delta"):
    data_to_sort = deltas
  i_proxies_sorted = flex.sort_permutation(data=data_to_sort, reverse=True)
  sorted_table = []
  for i_proxy in i_proxies_sorted:
    proxy = O[i_proxy]
    if proxy.origin_id != origin_ids.get_origin_id('covalent geometry'):
      continue
    sigma = cctbx.geometry_restraints.weight_as_sigma(proxy.weight)
    score = sqrt(residuals[i_proxy]) / sigma
    proxy_atoms = get_atoms_info(pdb_atoms, iselection=proxy.i_seqs,
      use_segids_in_place_of_chainids=use_segids_in_place_of_chainids)
    sorted_table.append((proxy, proxy_atoms))
  return sorted_table

class combined(slots_getstate_setstate):
  """
  Container for individual validations of each of the five covalent restraint
  classes.
  """
  __geo_types__ = ["bonds", "angles", "dihedrals", "chiralities", "planarities"]
  __slots__ = __geo_types__ + ["_use_cdl"]
  def __init__(self,
      pdb_hierarchy,
      xray_structure,
      geometry_restraints_manager,
      ignore_hd=True,
      sigma_cutoff=4.0,
      outliers_only=True,
      reverse_sort=False,
      use_segids_in_place_of_chainids=False,
      cdl=None):
    self._use_cdl = cdl
    from mmtbx import restraints
    restraints_manager = restraints.manager(
      geometry=geometry_restraints_manager)
    sites_cart = xray_structure.sites_cart()
    hd_selection = xray_structure.hd_selection()
    pdb_atoms = pdb_hierarchy.atoms()
    if (ignore_hd and hd_selection.count(True) > 0):
      restraints_manager = restraints_manager.select(selection = ~hd_selection)
      sites_cart = sites_cart.select(~hd_selection)
      pdb_atoms = pdb_atoms.select(~hd_selection)
    energies_sites = restraints_manager.energies_sites(
      sites_cart=sites_cart,
      compute_gradients=False).geometry
    for geo_type in self.__geo_types__ :
      restraint_validation_class = globals()[geo_type]
      if (geo_type == "bonds" ):
        restraint_proxies = restraints_manager.geometry.pair_proxies(
          sites_cart=sites_cart).bond_proxies
      else :
        restraint_proxies = getattr(restraints_manager.geometry,
          "%s_proxies" % restraint_validation_class.restraint_type)
      rv = restraint_validation_class(
        pdb_atoms=pdb_atoms,
        sites_cart=sites_cart,
        energies_sites=energies_sites,
        restraint_proxies=restraint_proxies,
        unit_cell=xray_structure.unit_cell(),
        ignore_hd=ignore_hd,
        sigma_cutoff=sigma_cutoff,
        outliers_only=outliers_only,
        reverse_sort=reverse_sort,
        use_segids_in_place_of_chainids=use_segids_in_place_of_chainids)
      setattr(self, geo_type, rv)

  def show(self, out=sys.stdout, prefix="", verbose=True):
    for geo_type in self.__geo_types__ :
      rv = getattr(self, geo_type)
      make_sub_header(rv.restraint_label + "s", out=out)
      if (geo_type == "angles") and getattr(self, "_use_cdl", False):
        print("  Using conformation-dependent library for mainchain "+\
                      "bond angle targets", file=out)
        print("", file=out)
      rv.show(out=out, prefix=prefix)

  def get_bonds_angles_rmsds(self):
    return (self.bonds.mean, self.angles.mean)

  def as_kinemage(self, chain_id=None):
    kin_txt = self.angles.as_kinemage(chain_id=chain_id)
    kin_txt += "\n"
    kin_txt += self.bonds.as_kinemage(chain_id=chain_id)
    return kin_txt


 *******************************************************************************


 *******************************************************************************
mmtbx/validation/rna_validate.py

# TODO reduce to one outlier per residue

from __future__ import absolute_import, division, print_function
from mmtbx.monomer_library import rna_sugar_pucker_analysis
from mmtbx.monomer_library import pdb_interpretation
from mmtbx.validation import utils
from mmtbx import monomer_library
from mmtbx.validation import rna_geometry
from mmtbx.validation import residue
from mmtbx.validation import atoms
from mmtbx.validation import get_atoms_info
from iotbx.pdb import common_residue_names_get_class as get_res_class
from cctbx import geometry_restraints
from scitbx.array_family import flex
from libtbx.str_utils import make_sub_header, format_value
from libtbx import slots_getstate_setstate
from math import sqrt
from mmtbx.suitename import suitealyze
import sys
import json

rna_backbone_atoms = set([
  "P", "OP1", "OP2", "O5'", "C5'", "C4'", "O4'", "C1'",
  "C3'", "O3'", "C2'", "O2'", "N1", "N9" ]) #version 3.x naming

# individual validation results
class rna_bond(atoms):
  __slots__ = atoms.__slots__ + ["sigma", "delta"]

  @staticmethod
  def header():
    return "%-20s  %6s  %6s  %6s" % ("residue", "atom 1", "atom 2", "sigmas")

  def id_str(self, spacer=" "):
    return "%s%s%s" % (self.atoms_info[0].id_str(), spacer,
      self.atoms_info[1].id_str())

  def format_values(self):
    return "%-20s  %6s  %6s  %6.2f" % (self.id_str(), self.atoms_info[0].name,
      self.atoms_info[1].name, self.score)

  def as_string(self, prefix=""):
    return prefix + self.format_values()

  def as_JSON(self):
    atoms_dict = {}
    for s in self.atoms_info[0].__slots__:
      atoms_dict["atoms_"+s] = [getattr(self.atoms_info[0], s), getattr(self.atoms_info[1], s)]
    serializable_slots = [s for s in self.__slots__ if s != 'atoms_info' and hasattr(self, s)]
    slots_as_dict = ({s: getattr(self, s) for s in serializable_slots})
    return json.dumps(self.merge_two_dicts(slots_as_dict, atoms_dict), indent=2)

  def as_hierarchical_JSON(self):
    hierarchical_dict = {}
    hierarchy_nest_list = ['model_id', 'chain_id', 'resid', 'altloc']
    return json.dumps(self.nest_dict(hierarchy_nest_list, hierarchical_dict), indent=2)

  def as_table_row_phenix(self):
    return [ self.id_str(), self.atoms_info[0].name, self.atoms_info[1].name,
             self.score ]

class rna_angle(atoms):
  __slots__ = atoms.__slots__ + ["sigma", "delta"]

  @staticmethod
  def header():
    return "%-20s  %6s  %6s  %6s  %6s" % ("residue", "atom 1", "atom 2",
      "atom 3", "sigmas")

  def id_str(self, spacer=" "):
    return "%s%s%s%s%s" % (self.atoms_info[0].id_str(), spacer,
      self.atoms_info[1].id_str(), spacer,
      self.atoms_info[2].id_str())

  def format_values(self):
    return "%-20s  %6s  %6s  %6s  %6.2f" % (self.id_str(),
      self.atoms_info[0].name, self.atoms_info[1].name,
      self.atoms_info[2].name, self.score)

  def as_string(self, prefix=""):
    return prefix + self.format_values()

  def as_JSON(self):
    atoms_dict = {}
    for s in self.atoms_info[0].__slots__:
      atoms_dict["atoms_"+s] = [getattr(self.atoms_info[0], s), getattr(self.atoms_info[1], s), getattr(self.atoms_info[2], s)]
    serializable_slots = [s for s in self.__slots__ if s != 'atoms_info' and hasattr(self, s)]
    slots_as_dict = ({s: getattr(self, s) for s in serializable_slots})
    return json.dumps(self.merge_two_dicts(slots_as_dict, atoms_dict), indent=2)

  def as_hierarchical_JSON(self):
    hierarchical_dict = {}
    hierarchy_nest_list = ['model_id', 'chain_id', 'resid', 'altloc']
    return json.dumps(self.nest_dict(hierarchy_nest_list, hierarchical_dict), indent=2)

  def as_table_row_phenix(self):
    return [ self.id_str(), self.atoms_info[0].name, self.atoms_info[1].name,
             self.atoms_info[2].name, self.score ]

class rna_pucker(residue):
  """
  Validation using pucker-specific restraints library.
  """
  __slots__ = residue.__slots__ + [
    "delta_angle",
    "is_delta_outlier",
    "epsilon_angle",
    "is_epsilon_outlier",
    "Pperp_distance",
    "probable_pucker",
    "model_id",
  ]

  @staticmethod
  def header():
    return "%-20s  %8s  %8s  %8s  %8s" % ("residue", "delta", "outlier",
      "epsilon", "outlier")

  def format_values(self):
    def format_outlier_flag(flag):
      if (flag) : return "yes"
      else : return "no"
    def format_angle(val):
      return format_value("%8.1f", val, replace_none_with="---")
    return "%-20s  %8s  %8s  %8s  %8s" % (self.id_str(),
      format_angle(self.delta_angle),
      format_outlier_flag(self.is_delta_outlier),
      format_angle(self.epsilon_angle),
      format_outlier_flag(self.is_epsilon_outlier))

  def as_string(self, prefix=""):
    return prefix + self.format_values()

  def as_JSON(self):
    serializable_slots = [s for s in self.__slots__ if hasattr(self, s)]
    slots_as_dict = ({s: getattr(self, s) for s in serializable_slots})
    return json.dumps(slots_as_dict, indent=2)

  def as_hierarchical_JSON(self):
    hierarchical_dict = {}
    hierarchy_nest_list = ['model_id', 'chain_id', 'resid', 'altloc']
    return json.dumps(self.nest_dict(hierarchy_nest_list, hierarchical_dict), indent=2)

  def as_table_row_phenix(self):
    return [ self.id_str(), self.delta_angle, self.epsilon_angle ]

# analysis objects
class rna_bonds(rna_geometry):
  output_header = "#residue:atom_1:atom_2:num_sigmas"
  label = "Backbone bond lenths"
  gui_list_headers = ["Residue", "Atom 1", "Atom 2", "Sigmas"]
  gui_formats = ["%s", "%s", "%s", "%.2f"]
  wx_column_widths = [160] * 4
  def __init__(self, pdb_hierarchy, pdb_atoms, geometry_restraints_manager,
                outliers_only=True):
    self.n_outliers_large_by_model = {}
    self.n_outliers_small_by_model = {}
    rna_geometry.__init__(self)
    cutoff = 4
    sites_cart = pdb_atoms.extract_xyz()
    flags = geometry_restraints.flags.flags(default=True)
    pair_proxies = geometry_restraints_manager.pair_proxies(
      flags=flags,
      sites_cart=sites_cart)
    bond_proxies = pair_proxies.bond_proxies
    for proxy in bond_proxies.simple:
      restraint = geometry_restraints.bond(
        sites_cart=sites_cart,
        proxy=proxy)
      atom1 = pdb_atoms[proxy.i_seqs[0]].name
      atom2 = pdb_atoms[proxy.i_seqs[1]].name
      labels = pdb_atoms[proxy.i_seqs[0]].fetch_labels()
      model_id = labels.model_id
      if model_id not in self.n_total_by_model.keys():
        self.n_total_by_model[model_id] = 0
        self.n_outliers_by_model[model_id] = 0
        self.n_outliers_small_by_model[model_id] = 0
        self.n_outliers_large_by_model[model_id] = 0
      if (atom1.strip() not in rna_backbone_atoms or
          atom2.strip() not in rna_backbone_atoms):
        continue
      self.n_total += 1
      self.n_total_by_model[model_id] += 1
      sigma = sqrt(1 / restraint.weight)
      num_sigmas = - restraint.delta / sigma
      is_outlier = (abs(num_sigmas) >= cutoff)
      if is_outlier:
        self.n_outliers += 1
        self.n_outliers_by_model[model_id] += 1
        if num_sigmas < 0:
          self.n_outliers_small_by_model[model_id] += 1
        else:
          self.n_outliers_large_by_model[model_id] += 1
      if (is_outlier or not outliers_only):
        self.results.append(rna_bond(
          atoms_info=get_atoms_info(pdb_atoms, proxy.i_seqs),
          sigma=sigma,
          score=num_sigmas,
          delta=restraint.delta,
          xyz=flex.vec3_double([pdb_atoms[proxy.i_seqs[0]].xyz, pdb_atoms[proxy.i_seqs[1]].xyz]).mean(),
          outlier=is_outlier))

  def get_result_class(self) : return rna_bond

  def as_JSON(self, addon_json={}):
    if not addon_json:
      addon_json = {}
    addon_json["validation_type"] = "rna_bonds"
    data = addon_json
    flat_results = []
    hierarchical_results = {}
    summary_results = {}
    for result in self.results:
      flat_results.append(json.loads(result.as_JSON()))
      hier_result = json.loads(result.as_hierarchical_JSON())
      hierarchical_results = self.merge_dict(hierarchical_results, hier_result)

    data['flat_results'] = flat_results
    data['hierarchical_results'] = hierarchical_results
    for mod_id in self.n_total_by_model.keys():
      summary_results[mod_id] = {"num_outliers": self.n_outliers_by_model[mod_id],
                                 "num_total": self.n_total_by_model[mod_id],
                                 "num_outliers_too_small": self.n_outliers_small_by_model[mod_id],
                                 "num_outliers_too_large": self.n_outliers_large_by_model[mod_id]}
    data['summary_results'] = summary_results
    return json.dumps(data, indent=2)

  def show_summary(self, out=sys.stdout, prefix=""):
    if (self.n_total == 0):
      print(prefix + "No RNA backbone atoms found.", file=out)
    elif (self.n_outliers == 0):
      print(prefix + "All bonds within 4.0 sigma of ideal values.", file=out)
    else :
      print(prefix + "%d/%d bond outliers present" % (self.n_outliers,
        self.n_total), file=out)

class rna_angles(rna_geometry):
  output_header = "#residue:atom_1:atom_2:atom_3:num_sigmas"
  label = "Backbone bond angles"
  gui_list_headers = ["Residue", "Atom 1", "Atom 2", "Atom 3", "Sigmas"]
  gui_formats = ["%s", "%s", "%s", "%s", "%.2f"]
  wx_column_widths = [160] * 5
  def __init__(self, pdb_hierarchy, pdb_atoms, geometry_restraints_manager,
                outliers_only=True):
    self.n_outliers_large_by_model = {}
    self.n_outliers_small_by_model = {}
    rna_geometry.__init__(self)
    cutoff = 4
    sites_cart = pdb_atoms.extract_xyz()
    flags = geometry_restraints.flags.flags(default=True)
    i_seq_name_hash = utils.build_name_hash(pdb_hierarchy=pdb_hierarchy)
    for proxy in geometry_restraints_manager.angle_proxies:
      restraint = geometry_restraints.angle(
        sites_cart=sites_cart,
        proxy=proxy)
      atom1 = pdb_atoms[proxy.i_seqs[0]].name
      atom2 = pdb_atoms[proxy.i_seqs[1]].name
      atom3 = pdb_atoms[proxy.i_seqs[2]].name
      labels = pdb_atoms[proxy.i_seqs[0]].fetch_labels()
      model_id = labels.model_id
      if model_id not in self.n_total_by_model.keys():
        self.n_total_by_model[model_id] = 0
        self.n_outliers_by_model[model_id] = 0
        self.n_outliers_small_by_model[model_id] = 0
        self.n_outliers_large_by_model[model_id] = 0
      if (atom1.strip() not in rna_backbone_atoms or
          atom2.strip() not in rna_backbone_atoms or
          atom3.strip() not in rna_backbone_atoms):
        continue
      self.n_total += 1
      self.n_total_by_model[model_id] += 1
      sigma = sqrt(1 / restraint.weight)
      num_sigmas = - restraint.delta / sigma
      is_outlier = (abs(num_sigmas) >= cutoff)
      if is_outlier:
        self.n_outliers += 1
        self.n_outliers_by_model[model_id] += 1
        if num_sigmas < 0:
          self.n_outliers_small_by_model[model_id] += 1
        else:
          self.n_outliers_large_by_model[model_id] += 1
      if (is_outlier or not outliers_only):
        self.results.append(rna_angle(
          atoms_info=get_atoms_info(pdb_atoms, proxy.i_seqs),
          sigma=sigma,
          score=num_sigmas,
          delta=restraint.delta,
          xyz=pdb_atoms[proxy.i_seqs[1]].xyz,
          outlier=is_outlier))

  def get_result_class(self) : return rna_angle

  def as_JSON(self, addon_json={}):
    if not addon_json:
      addon_json = {}
    addon_json["validation_type"] = "rna_angles"
    data = addon_json
    flat_results = []
    hierarchical_results = {}
    summary_results = {}
    for result in self.results:
      flat_results.append(json.loads(result.as_JSON()))
      hier_result = json.loads(result.as_hierarchical_JSON())
      hierarchical_results = self.merge_dict(hierarchical_results, hier_result)

    data['flat_results'] = flat_results
    data['hierarchical_results'] = hierarchical_results
    for mod_id in self.n_total_by_model.keys():
      summary_results[mod_id] = {"num_outliers": self.n_outliers_by_model[mod_id],
                                 "num_total": self.n_total_by_model[mod_id],
                                 "num_outliers_too_small": self.n_outliers_small_by_model[mod_id],
                                 "num_outliers_too_large": self.n_outliers_large_by_model[mod_id]}
    data['summary_results'] = summary_results
    return json.dumps(data, indent=2)

  def show_summary(self, out=sys.stdout, prefix=""):
    if (self.n_total == 0):
      print(prefix + "No RNA backbone atoms found.", file=out)
    elif (self.n_outliers == 0):
      print(prefix + "All angles within 4.0 sigma of ideal values.", file=out)
    else :
      print(prefix + "%d/%d angle outliers present" % (self.n_outliers,
        self.n_total), file=out)

class rna_puckers(rna_geometry):
  __slots__ = rna_geometry.__slots__ + [
    "pucker_states",
    "pucker_perp_xyz",
    "pucker_dist",
  ]
  output_header = "#residue:delta_angle:is_delta_outlier:epsilon_angle:is_epsilon_outler"
  label = "Sugar pucker"
  gui_list_headers = ["Residue", "Delta", "Epsilon"]
  gui_formats = ["%s", "%.2f", "%.2f"]
  wx_column_widths = [200]*3
  def __init__(self, pdb_hierarchy, params=None, outliers_only=True):
    if (params is None):
      params = rna_sugar_pucker_analysis.master_phil.extract()
    self.pucker_states = []
    self.pucker_perp_xyz = {}
    self.pucker_dist = {}
    rna_geometry.__init__(self)
    from iotbx.pdb.rna_dna_detection import residue_analysis
    for model in pdb_hierarchy.models():
      self.n_outliers_by_model[model.id] = 0
      self.n_total_by_model[model.id] = 0
      for chain in model.chains():
        first_altloc = [conformer.altloc for conformer in chain.conformers()][0]
        #can skip some calculations on later altlocs
        for conformer in chain.conformers():
          residues = conformer.residues()
          for i_residue,residue in enumerate(residues):
            def _get_next_residue():
              j = i_residue + 1
              if (j == len(residues)): return None
              return residues[j]
            ra1 = residue_analysis(
              residue_atoms=residue.atoms(),
              distance_tolerance=params.bond_detection_distance_tolerance)
            if (ra1.problems is not None): continue
            if (not ra1.is_rna): continue
            residue_2_p_atom = None
            next_pdb_residue = _get_next_residue()
            if (next_pdb_residue is not None):
              residue_2_p_atom = next_pdb_residue.find_atom_by(name=" P  ")
            if (get_res_class(residue.resname) != "common_rna_dna"):
              continue
            if conformer.altloc.strip() == '':
              local_altloc = ''
            else:
              local_altloc = self.local_altloc_from_atoms(ra1.deoxy_ribo_atom_dict, ra1.c1p_outbound_atom, residue_2_p_atom)
            if local_altloc == '' and local_altloc != conformer.altloc and conformer.altloc != first_altloc:
              #if the pucker atoms contain no alternates, then the calculation can be skipped if this isn't the first
              #  conformer to be encountered
              continue
            ana = rna_sugar_pucker_analysis.evaluate(
              params=params,
              residue_1_deoxy_ribo_atom_dict=ra1.deoxy_ribo_atom_dict,
              residue_1_c1p_outbound_atom=ra1.c1p_outbound_atom,
              residue_2_p_atom=residue_2_p_atom)
            self.pucker_states.append(ana)
            self.n_total += 1
            self.n_total_by_model[model.id] += 1
            is_outlier = ana.is_delta_outlier or ana.is_epsilon_outlier
            if (is_outlier):
              self.n_outliers += 1
              self.n_outliers_by_model[model.id] += 1
            if (is_outlier or not outliers_only):
              pucker = rna_pucker(
                model_id=model.id,
                chain_id=chain.id,
                resseq=residue.resseq,
                icode=residue.icode,
                altloc=local_altloc, #'' if none
                resname=residue.resname,
                delta_angle=ana.delta,
                is_delta_outlier=ana.is_delta_outlier,
                epsilon_angle=ana.epsilon,
                is_epsilon_outlier=ana.is_epsilon_outlier,
                xyz=self.get_sugar_xyz_mean(residue),
                outlier=is_outlier)
              self.results.append(pucker)
              key = pucker.id_str() #[8:-1]
              self.pucker_perp_xyz[key] = [ana.p_perp_xyz, ana.o3p_perp_xyz]
              self.pucker_dist[key] = [ana.p_distance_c1p_outbound_line,
                                       ana.o3p_distance_c1p_outbound_line]
              pucker.Pperp_distance=ana.p_distance_c1p_outbound_line
              if not pucker.Pperp_distance:
                pucker.probable_pucker=None
              elif pucker.Pperp_distance and pucker.Pperp_distance < 2.9:
                pucker.probable_pucker="C2'-endo"
              else:
                pucker.probable_pucker="C3'-endo"

  def get_sugar_xyz_mean(self, residue):
    sugar_atoms = [" C1'", " C2'", " C3'", " C4'", " O4'"]
    atom_xyzs = []
    sums = [0]*3
    for at_name in sugar_atoms:
      sug_atom = residue.find_atom_by(name = at_name)
      if sug_atom is not None:
        atom_xyzs.append(sug_atom.xyz)
    assert len(atom_xyzs) > 0, "RNA sugar pucker validation found zero sugar atoms, probably due to non-standard atom names"
    mean = flex.vec3_double(atom_xyzs).mean()
    return mean

  def get_result_class(self) : return rna_pucker

  def as_JSON(self, addon_json={}):
    if not addon_json:
      addon_json = {}
    addon_json["validation_type"] = "rna_puckers"
    data = addon_json
    flat_results = []
    hierarchical_results = {}
    summary_results = {}
    for result in self.results:
      flat_results.append(json.loads(result.as_JSON()))
      hier_result = json.loads(result.as_hierarchical_JSON())
      hierarchical_results = self.merge_dict(hierarchical_results, hier_result)

    data['flat_results'] = flat_results
    data['hierarchical_results'] = hierarchical_results
    for mod_id in self.n_total_by_model.keys():
      summary_results[mod_id] = {"num_outliers": self.n_outliers_by_model[mod_id],
                                 "num_residues": self.n_total_by_model[mod_id]}
    data['summary_results'] = summary_results
    return json.dumps(data, indent=2)

  def show_summary(self, out=sys.stdout, prefix=""):
    if (self.n_total == 0):
      print(prefix + "No RNA sugar groups found.", file=out)
    elif (self.n_outliers == 0):
      print(prefix + "All puckers have reasonable geometry.", file=out)
    else :
      print(prefix + "%d/%d pucker outliers present" % (self.n_outliers,
        self.n_total), file=out)

  def local_altloc_from_atoms(self, residue_1_deoxy_ribo_atom_dict, residue_1_c1p_outbound_atom, residue_2_p_atom):
    #conformer.altloc masks whether a residue has true alternate conformations
    #check atom.parent().altloc for whether any atoms have alt positions
    #only run this if conformer.altloc != ''
    for atom in [residue_1_c1p_outbound_atom, residue_2_p_atom]:
      if atom is None: continue
      altloc = atom.parent().altloc
      if altloc != "":
        return altloc
    for atom in residue_1_deoxy_ribo_atom_dict.values():
      if atom is None: continue
      altloc = atom.parent().altloc
      if altloc != "":
        return altloc
    return ""

class rna_validation(slots_getstate_setstate):
  __slots__ = ["bonds", "angles", "puckers", "suites"]

  def __init__(self,
      pdb_hierarchy,
      geometry_restraints_manager=None,
      params=None,
      outliers_only=True):
    if (geometry_restraints_manager is None):
      mon_lib_srv = monomer_library.server.server()
      ener_lib = monomer_library.server.ener_lib()
      processed_pdb_file = pdb_interpretation.process(
        mon_lib_srv=mon_lib_srv,
        ener_lib=ener_lib,
        pdb_hierarchy=pdb_hierarchy,
        substitute_non_crystallographic_unit_cell_if_necessary=True)
      geometry_restraints_manager = \
        processed_pdb_file.geometry_restraints_manager()
      pdb_hierarchy = \
        processed_pdb_file.all_chain_proxies.pdb_hierarchy
    pdb_atoms = pdb_hierarchy.atoms()
    self.bonds = rna_bonds(
      pdb_hierarchy=pdb_hierarchy,
      pdb_atoms=pdb_atoms,
      geometry_restraints_manager=geometry_restraints_manager,
      outliers_only=outliers_only)
    self.angles = rna_angles(
      pdb_hierarchy=pdb_hierarchy,
      pdb_atoms=pdb_atoms,
      geometry_restraints_manager=geometry_restraints_manager,
      outliers_only=outliers_only)
    self.puckers = rna_puckers(
      pdb_hierarchy=pdb_hierarchy,
      params=getattr(params, "rna_sugar_pucker_analysis", None),
      outliers_only=outliers_only)
    self.suites = suitealyze.suitealyze(
      pdb_hierarchy=pdb_hierarchy,
      outliers_only=outliers_only)
    #self.suites = rna_suites(
    #  pdb_hierarchy=pdb_hierarchy,
    #  geometry_restraints_manager=geometry_restraints_manager,
    #  outliers_only=outliers_only)

  def show_summary(self, out=sys.stdout, prefix=""):
    pass

  def show(self, out=sys.stdout, prefix="", outliers_only=None,
      verbose=True):
    for geo_type in self.__slots__ :
      rv = getattr(self, geo_type)
      if (rv.n_outliers > 0) or (not outliers_only):
        make_sub_header(rv.label, out=out)
        rv.show(out=out)

  def as_JSON(self, addon_json={}):
    if not addon_json:
      addon_json = {}
    rna_json = addon_json
    for slot in self.__slots__:
      slot_json = json.loads(getattr(self, slot).as_JSON())
      rna_json["rna_"+slot] = slot_json
    return json.dumps(rna_json, indent=2)



 *******************************************************************************


 *******************************************************************************
mmtbx/validation/rotalyze.py
from __future__ import absolute_import, division, print_function
from mmtbx.validation import residue, validation
from mmtbx.validation import graphics
from iotbx import data_plots
from iotbx.pdb import aa_utils
from libtbx.str_utils import format_value
from libtbx.utils import Sorry
import operator
import json
import os, sys
from scitbx.array_family import flex

OUTLIER_THRESHOLD = 0.003
ALLOWED_THRESHOLD = 0.02

class rotamer(residue):
  """
  Result class for protein sidechain rotamer analysis (molprobity.rotalyze).
  """
  __rotamer_attr__ = [
    "score",
    "evaluation",
    "rotamer_name",
    "chi_angles",
    "incomplete",
    "model_id"
  ]
  __slots__ = residue.__slots__ + __rotamer_attr__

  def __hash__(self):
    return self.as_string().__hash__()

  @staticmethod
  def header():
    return "%-20s %8s %6s   %-20s" % ("Residue", "Rotamer", "Score",
      "Chi angles")

  def get_chi1_chi2(self):
    if (len(self.chi_angles) < 2):
      raise ValueError("Less than 2 chi angles for this residue (%s)" %
        self.id_str())
    return self.chi_angles[0], self.chi_angles[1]

  def as_string(self):
    return "%-20s %8s %6.2f   %-20s" % (self.id_str(), self.rotamer_name,
      self.score, self.format_chi_angles())

  # Backwards compatibility for scripts that expect old rotalyze output
  def id_str_old(self):
    return "%s%4s%1s %s" % (self.chain_id, self.resseq, self.icode,
      self.altloc + self.resname.strip())

  def format_chi_angles(self, pad=False, sep=","):
    formatted = []
    for chi in self.chi_angles :
      if pad or (chi is not None):
        formatted.append(format_value("%.1f", chi,
          replace_none_with="").strip())
    return sep.join(formatted)

  # Old output
  def format_old(self):
    s_occ = format_value("%.2f", self.occupancy)
    s_score = format_value("%.1f", self.score)
    chis = list(self.chi_angles)
    return "%s:%s:%s:%s:%s:%s" % (self.id_str(), s_occ, s_score,
      self.format_chi_angles(pad=True, sep=":"),
      self.evaluation,self.rotamer_name)

  def as_JSON(self):
    serializable_slots = [s for s in self.__slots__ if hasattr(self, s)]
    slots_as_dict = ({s: getattr(self, s) for s in serializable_slots})
    #slots_as_dict["rama_type"] = rama_types[slots_as_dict["rama_type"]]
    return json.dumps(slots_as_dict, indent=2)

  def as_hierarchical_JSON(self):
    hierarchical_dict = {}
    hierarchy_nest_list = ['model_id', 'chain_id', 'resid', 'altloc']
    return json.dumps(self.nest_dict(hierarchy_nest_list, hierarchical_dict), indent=2)

  # GUI output
  def as_table_row_phenix(self):
    return [ self.chain_id, "%1s%s %s" % (self.altloc,self.resname,self.resid),
             self.score ] + self.format_chi_angles(pad=True).split(",")#list(self.chi_angles)

class rotamer_ensemble(residue):
  """Container for validation results for an ensemble of residues."""
  __slots__ = rotamer.__slots__
  def __init__(self, all_results):
    self._copy_constructor(all_results[0])
    self.score = [ r.score for r in all_results ]
    self.rotamer_name = [ r.rotamer_name for r in all_results ]
    self.chi_angles = [ r.chi_angles for r in all_results ]

  def rotamer_frequencies(self):
    rotamers = []
    for rot_id in set(self.rotamer_name):
      n_rotamer = self.rotamer_name.count(rot_id)
      rotamers.append((rot_id, n_rotamer))
    return sorted(rotamers, key=operator.itemgetter(1), reverse=True)

  def as_string(self):
    rotamers = self.rotamer_frequencies()
    rot_out = [ "%s (%d)" % (rid, n_rot) for (rid, n_rot) in rotamers ]
    return "%-20s %s" % (self.id_str(), ", ".join(rot_out))

class rotalyze(validation):
  __slots__ = validation.__slots__ + ["n_allowed", "n_allowed_by_model",
    "n_favored", "n_favored_by_model", "out_percent",
    "outlier_threshold", "data_version", "percent_favored","percent_allowed",
    "_outlier_i_seqs"]
  program_description = "Analyze protein sidechain rotamers"
  output_header = "residue:occupancy:score%:chi1:chi2:chi3:chi4:"
  output_header+= "evaluation:rotamer"
  gui_list_headers = ["Chain","Residue","Score","Chi1","Chi2","Chi3","Chi4"]
  gui_formats = ["%s", "%s", "%.2f", "%.1f", "%.1f", "%.1f", "%.1f"]
  wx_column_widths = [75, 120, 100, 100, 100, 100, 100]

  def get_result_class(self) : return rotamer

  def __init__(self, pdb_hierarchy,
      data_version="8000",
      outliers_only=False,
      show_errors=False,
      use_parent=False,
      out=sys.stdout,
      quiet=False):
    validation.__init__(self)
    self.n_allowed = 0
    self.n_favored = 0
    self.n_allowed_by_model = {}
    self.n_favored_by_model = {}
    from mmtbx.rotamer.sidechain_angles import SidechainAngles
    from mmtbx.rotamer import rotamer_eval
    from mmtbx.rotamer.rotamer_eval import RotamerID
    from mmtbx.validation import utils
    self.data_version = data_version
    self._outlier_i_seqs = flex.size_t()
#   if self.data_version == "500":    self.outlier_threshold = 0.01
    if self.data_version == "8000": self.outlier_threshold = OUTLIER_THRESHOLD
    else: raise ValueError(
      "data_version given to RotamerEval not recognized (%s)." % data_version)
    sidechain_angles = SidechainAngles(show_errors)
    rotamer_evaluator = rotamer_eval.RotamerEval(
                             data_version=data_version)
    rotamer_id = rotamer_eval.RotamerID() # loads in the rotamer names
    use_segids = utils.use_segids_in_place_of_chainids(
                   hierarchy=pdb_hierarchy)
    current_rotamers = {}
    for model in pdb_hierarchy.models():
      self.n_allowed_by_model[model.id] = 0
      self.n_favored_by_model[model.id] = 0
      self.n_outliers_by_model[model.id] = 0
      self.n_total_by_model[model.id] = 0
      for chain in model.chains():
        if use_segids:
          chain_id = utils.get_segid_as_chainid(chain=chain)
        else:
          chain_id = chain.id
        for rg in chain.residue_groups():
          all_dict = construct_complete_sidechain(rg)
          for atom_group in rg.atom_groups():
            coords = get_center(atom_group)
            resname = atom_group.resname
            occupancy = get_occupancy(atom_group)
            kwargs = {
              "model_id" : model.id,
              "chain_id" : chain_id,
              "resseq" : rg.resseq,
              "icode" : rg.icode,
              "altloc" : atom_group.altloc,
              "resname" : resname,
              "xyz" : coords,
              "occupancy" : occupancy,
            }
            atom_dict = all_dict.get(atom_group.altloc)
            if use_parent:
              parent_name = aa_utils.get_aa_parent(atom_group.resname)
              if parent_name!=atom_group.resname: atom_group.resname=parent_name
            res_key = get_residue_key(atom_group=atom_group)
            try:
              chis = sidechain_angles.measureChiAngles(
                       atom_group,
                       atom_dict)#.get(conformer.altloc))
            except AttributeError:
              if show_errors:
                kwargs['incomplete'] = True
                result = rotamer(**kwargs)
                print('%s is missing some sidechain atoms' % \
                  result.id_str(), file=out)
                self.results.append(result)
              continue
            if (chis is not None):
              if None in chis:
                continue
              cur_res = resname.lower().strip()
              if cur_res == 'mse':
                cur_res = 'met'
              elif use_parent: cur_res=parent_name
              value = rotamer_evaluator.evaluate(cur_res, chis)
              if value is not None:
                self.n_total += 1
                self.n_total_by_model[model.id] += 1
                kwargs['score'] = value * 100
                wrap_chis = rotamer_id.wrap_chis(resname.strip(), chis,
                  symmetry=False)
                sym_chis = wrap_chis[:]
                sym_chis = rotamer_id.wrap_sym(resname.strip(), sym_chis)
                evaluation = self.evaluateScore(value, model.id)
                kwargs['evaluation'] = evaluation
                if evaluation == "OUTLIER":
                  kwargs['outlier'] = True
                  kwargs['rotamer_name'] = evaluation
                  self._outlier_i_seqs.extend(atom_group.atoms().extract_i_seq())
                else:
                  kwargs['outlier'] = False
                  if use_parent: resname=parent_name
                  kwargs['rotamer_name'] = rotamer_id.identify(resname,
                    wrap_chis)
                  #deal with unclassified rotamers
                  if kwargs['rotamer_name'] == '':
                    kwargs['rotamer_name'] = "UNCLASSIFIED"
                while (len(wrap_chis) < 4):
                  wrap_chis.append(None)
                kwargs['chi_angles'] = wrap_chis
                result = rotamer(**kwargs)
                if (result.is_outlier()) or (not outliers_only):
                  self.results.append(result)
    out_count, out_percent = self.get_outliers_count_and_fraction()
    self.out_percent = out_percent * 100.0
    assert abs(self.percent_outliers - self.out_percent) < 1.e-6
    self.percent_favored, self.percent_allowed = 0, 0
    if(self.n_total>0):
      self.percent_favored  = self.n_favored * 100. / self.n_total
      self.percent_allowed  = self.n_allowed * 100. / self.n_total
      # Checksum assert
      assert abs(self.percent_favored+self.percent_allowed+
                 self.percent_outliers-100.) < 1.e-6

  def get_rotamer_count(self):
    rotamer_count = {'total': {}}
    for residue in self.results:
      if residue.is_outlier(): continue
      current = rotamer_count['total'].setdefault(residue.resname, {})
      current.setdefault(residue.rotamer_name, 0)
      current[residue.rotamer_name]+=1
    return rotamer_count

  def evaluateScore(self, value, model_id=""):
    if value >= ALLOWED_THRESHOLD :
      self.n_favored += 1
      if model_id in self.n_favored_by_model:
        self.n_favored_by_model[model_id] += 1
      else:
        raise Sorry("Model ID not found in favored count dictionary, make sure you are calling this function with the correct model ID")
      return "Favored"
    elif value >= self.outlier_threshold:
      self.n_allowed += 1
      if model_id in self.n_allowed_by_model:
        self.n_allowed_by_model[model_id] += 1
      else:
        raise Sorry("Model ID not found in allowed count dictionary, make sure you are calling this function with the correct model ID")
      return "Allowed"
    else:
      self.n_outliers += 1
      if model_id in self.n_outliers_by_model:
        self.n_outliers_by_model[model_id] += 1
      else:
        raise Sorry("Model ID not found in outliers count dictionary, make sure you are calling this function with the correct model ID")
      return "OUTLIER"

  def show_summary(self, out=sys.stdout, prefix=""):
    print(prefix + 'SUMMARY: %.2f%% outliers (Goal: %s)' % \
      (self.out_percent, self.get_outliers_goal()), file=out)

  def get_outliers_goal(self):
#   if self.data_version == '500' : return "< 1%"
    return "< 0.3%"


  def get_favored_goal(self):
    return "> 98%"

  def coot_todo(self):
    return ""

  def get_plot_data(self, residue_name, point_type):
    assert (point_type in ["All", "None", "Outlier"])
    points = []
    coords = []
    for i, residue in enumerate(self.results):
      if (residue.resname == residue_name):
        if ((point_type == "All") or (residue.is_outlier())):
          chi1, chi2 = residue.get_chi1_chi2()
          points.append((chi1, chi2, residue.simple_id(), residue.is_outlier()))
          coords.append(residue.xyz)
    return (points, coords)

  def display_wx_plots(self, parent=None,
      title="MolProbity - Sidechain Chi1/Chi2 plots"):
    import wxtbx.plots.molprobity
    frame = wxtbx.plots.molprobity.rotalyze_frame(
      parent=parent, title=title, validation=self)
    frame.Show()
    return frame

  def as_JSON(self, addon_json={}):
    if not addon_json:
      addon_json = {}
    addon_json["validation_type"] = "rotalyze"
    data = addon_json
    flat_results = []
    hierarchical_results = {}
    summary_results = {}
    for result in self.results:
      flat_results.append(json.loads(result.as_JSON()))
      hier_result = json.loads(result.as_hierarchical_JSON())
      hierarchical_results = self.merge_dict(hierarchical_results, hier_result)

    data['flat_results'] = flat_results
    data['hierarchical_results'] = hierarchical_results
    for model_id in self.n_total_by_model:
      summary_results[model_id] = {
        "num_favored" : self.n_favored_by_model[model_id],
        "num_allowed" : self.n_allowed_by_model[model_id],
        "num_outliers" : self.n_outliers_by_model[model_id],
        "num_residues" : self.n_total_by_model[model_id],
        "outlier_percentage" : self.get_outliers_fraction_for_model(model_id) * 100,
        "outlier_goal" : self.get_outliers_goal()
      }
    data['summary_results'] = summary_results
    return json.dumps(data, indent=2)

  def as_coot_data(self):
    data = []
    for result in self.results :
      if result.is_outlier():
        data.append((result.chain_id, result.resid, result.resname,
          result.score, result.xyz))
    return data

def evaluate_rotamer(
    atom_group,
    sidechain_angles,
    rotamer_evaluator,
    rotamer_id,
    all_dict,
    outlier_threshold=0.003,
    sites_cart=None):
  atom_dict = all_dict.get(atom_group.altloc)
  resname = atom_group.resname
  try:
    chis = sidechain_angles.measureChiAngles(atom_group, atom_dict, sites_cart)
    value = rotamer_evaluator.evaluate(
              atom_group.resname.lower().strip(),
              chis)
  except Exception:
    return None, None, None
  wrap_chis = rotamer_id.wrap_chis(resname.strip(), chis, symmetry=False)
  rotamer_name = rotamer_id.identify(resname.strip(), wrap_chis)
  if (value is None):
    return None, None, None
  elif (value < outlier_threshold):
    return 'OUTLIER', chis, value
  else:
    return rotamer_name, chis, value

def split_rotamer_names(rotamer):
  split_rotamer = []
  multi = ""
  if rotamer in ['UNCLASSIFIED', 'OUTLIER', 'Cg_exo', 'Cg_endo']:
    split_rotamer.append(rotamer)
    return split_rotamer
  for i, c in enumerate(rotamer):
    if c in ['t', 'p', 'm']:
      split_rotamer.append(c)
    elif (c in ['-', '?']) or (c >= '0' and c<='9'):
      multi += c
  if len(multi) > 0:
    split_rotamer.append(multi)
  return split_rotamer

def get_residue_key(atom_group):
  altloc = atom_group.altloc
  if altloc == "":
    altloc = " "
  key = None
  for atom in atom_group.atoms():
    cur_label = atom.pdb_label_columns()+atom.segid
    cur_altloc = cur_label[4:5]
    if key is None:
      if altloc == cur_altloc:
        key = cur_label[4:]
    else:
      if altloc == cur_altloc:
        if (key != cur_label[4:]):
          if os.getenv('CCP4'):
            outl = 'a model editor'
          else:
            outl = 'phenix.pdbtools or phenix.pdb_editor'
          raise Sorry("""\
Incompatible identifiers for one or more atoms in a residue:
%s
This is usually caused by atoms with a different segid from the rest of the
residue.  You can use %s to reset the
segid.""" % (atom.format_atom_record(), outl))
        assert key == cur_label[4:]
  return key

def evaluate_residue(
      residue_group,
      sa,
      r,
      all_dict,
      sites_cart=None):
  is_outlier = False
  data_version = "8000"
  outlier_threshold = OUTLIER_THRESHOLD
  for ag in residue_group.atom_groups():
    atom_dict = all_dict.get(ag.altloc)
    try:
      chis = sa.measureChiAngles(ag, atom_dict)
      value = r.evaluate(ag.resname.lower().strip(), chis, sites_cart)
    except Exception:
      #print ag.resname.lower()+residue_group.resseq+" is missing some sidechain atoms"
      value = None;
      is_outlier = None;
      return is_outlier, value
    if (value is None):
      is_outlier = False
      return is_outlier, value
    elif (value < outlier_threshold):
      is_outlier = True
      return is_outlier, value
    else:
      return is_outlier, value

class residue_evaluator(object):
  def __init__(self):
    from mmtbx.rotamer.sidechain_angles import SidechainAngles
    from mmtbx.rotamer import rotamer_eval
    self.sa = SidechainAngles(False)
    self.data_version = "8000"
    self.r = rotamer_eval.RotamerEval(data_version=self.data_version)

  def evaluate_residue(self, residue_group):
    all_dict = construct_complete_sidechain(residue_group)
    return evaluate_residue(
      residue_group=residue_group,
      sa=self.sa,
      r=self.r,
      all_dict=all_dict,
      data_version=self.data_version)

  def __call__(self, *args, **kwds):
    return self.evaluate_residue(*args, **kwds)

def get_center(residue):
  for atom in residue.atoms():
    if atom.name == " CA ":
      return atom.xyz
  return residue.atoms().extract_xyz().mean()

def has_heavy_atoms(atoms):
  for atom in atoms:
    if not atom.element_is_hydrogen():
      return True
  return False

def construct_complete_sidechain(residue_group):
  if (residue_group is not None):
    complete_dict = {}
    atom_dict = {}
    for ag in residue_group.atom_groups():
      if not has_heavy_atoms(ag.atoms()):
        continue
      for atom in ag.atoms():
        #handle hydrogen/deuterium swaps
        if atom_dict.get(atom.name) == None:
          if atom_dict.get(atom.name.replace("H","D",1)) != None:
            del(atom_dict[atom.name.replace("H","D",1)])
          elif atom_dict.get(atom.name.replace("D","H",1)) != None:
            del(atom_dict[atom.name.replace("D","H",1)])
        atom_dict[atom.name] = atom
      clone_dict = {}
      clone_dict.update(atom_dict)
      complete_dict[ag.altloc] = clone_dict
    if len(complete_dict) > 0:
      return complete_dict
  return {}

# XXX does this need to be smarter?
def get_occupancy(atom_group):
  max_partial_occ = 0.
  for atom in atom_group.atoms():
    if (atom.occ > max_partial_occ) and (atom.occ < 1):
      max_partial_occ = atom.occ
  if (max_partial_occ == 0.):
    return max([ atom.occ for atom in atom_group.atoms() ])
  else :
    return max_partial_occ

#-----------------------------------------------------------------------
# GRAPHICS
class rotamer_plot_mixin(graphics.rotarama_plot_mixin):
  def set_labels(self, y_marks=(60,180,300)):
    self.plot.set_xlabel("Chi1")
    self.plot.set_xticks([60,180,300])
    self.plot.set_ylabel("Chi2")
    self.plot.set_yticks(list(y_marks))
    self.plot.grid(True, color="0.75")

class rotamer_plot(data_plots.simple_matplotlib_plot, rotamer_plot_mixin):
  def __init__(self, *args, **kwds):
    data_plots.simple_matplotlib_plot.__init__(self, *args, **kwds)
    rotamer_plot_mixin.__init__(self, *args, **kwds)

def draw_rotamer_plot(rotalyze_data,
                       rotarama_data,
                       residue_name,
                       file_name,
                       show_labels=True):
  points, coords = get_residue_rotamer_data(
    rotalyze_data=rotalyze_data,
    residue_name=residue_name,
    point_type="All")
  p = rotamer_plot()
  title = "Chi1-Chi2 plot for %s" % residue_name
  p.draw_plot(
    stats=rotarama_data,
    contours=[0.05477, 0.14142],
    title=title,
    points=points,
    xyz=coords,
    colormap="Blues")
  p.save_image(file_name)


 *******************************************************************************


 *******************************************************************************
mmtbx/validation/sequence.py
from __future__ import absolute_import, division, print_function
from libtbx import easy_mp
from libtbx import str_utils
import libtbx.phil
from libtbx.utils import Sorry
from libtbx.test_utils import approx_equal_core
from libtbx import adopt_init_args, Auto
from mmtbx.alignment import align
import sys

import iotbx.cif.model
from iotbx.pdb import modified_aa_names, modified_rna_dna_names
from iotbx.pdb.amino_acid_codes import one_letter_given_three_letter, \
    three_letter_l_given_three_letter_d, three_letter_given_one_letter
from six.moves import zip
from six.moves import range

master_phil = libtbx.phil.parse("""
  similarity_matrix =  blosum50  dayhoff *identity
    .type = choice
  min_allowable_identity = 0.5
    .type = float
""")

PROTEIN = 0
NUCLEIC_ACID = 1
UNK_AA = "U"
UNK_NA = "K"

def get_mean_coordinate(sites):
  if (len(sites) == 0):
    return None
  elif (len(sites) == 1):
    return sites[0]
  else :
    from scitbx.array_family import flex
    v = flex.vec3_double(sites)
    return v.mean()

class chain(object):
  """
  Stores information on a protein or nucleic acid chain, its alignment to
  the target sequence, and the coordinates of each residue.  For command-line
  use, much of this is irrelevant.  In the PHENIX GUI, much of this data is
  fed to the sequence/alignment viewer (wxtbx.sequence_view), which controls
  the graphics window(s).
  """
  def __init__(self, chain_id, sequence, resids, chain_type, sec_str=None,
                resnames=None):
    adopt_init_args(self, locals())
    assert (chain_type in [PROTEIN, NUCLEIC_ACID])
    assert (len(sequence) == len(resids))
    self.alignment = None
    self.sequence_name = None
    self.sequence_id = None
    self.identity = 0.
    self.n_missing = 0
    self.n_missing_start = 0
    self.n_missing_end = 0
    self.n_gaps = 0
    self.extra = []
    self.unknown = []
    self.mismatch = []
    self.actual_code = []
    self._xyz = []
    self._table = None
    self._flag_indices = []

  def set_alignment(self, alignment, sequence_name, sequence_id):
    assert (len(alignment.a) == len(alignment.b)) and (len(alignment.a) > 0)
    self.alignment = alignment
    self.sequence_name = sequence_name
    self.sequence_id = sequence_id
    if (self.sec_str is not None):
      raw_sec_str = list(self.sec_str)
    else :
      raw_sec_str = list("-" * len(self.sequence))
    self.sec_str = ""
    if (self.sequence_name in [None, ""]):
      self.sequence_name = "(unnamed)"
    if (alignment is not None):
      self.identity = alignment.calculate_sequence_identity(skip_chars=['X'])
    i_aln = i_resid = 0
    chain_started = False
    prev_char = None
    alignment_length = len(alignment.a)
    while (i_aln < alignment_length):
      symbol_pdb = alignment.a[i_aln]
      symbol_seq = alignment.b[i_aln]
      resid = None
      if (symbol_pdb != '-'):
        resid = self.resids[i_resid]
        self.sec_str += raw_sec_str[i_resid]
        i_resid += 1
      else :
        self.sec_str += "-"
      j_resid = i_aln - self.n_missing_start
      if (symbol_pdb == 'X'):
        if (not symbol_seq in ["X","-"]):
          self.n_missing += 1
          if (not chain_started and
              (self.resnames is None or self.resnames[j_resid] is None)):
            self.n_missing_start += 1
          elif (prev_char != 'X'):
            self.n_gaps += 1
      elif (symbol_pdb == '-'):
        if chain_started:
          if (j_resid < len(self.resids)):
            self.resids.insert(j_resid, None)
            raw_sec_str.insert(j_resid, "-")
            if self.resnames is not None:
              self.resnames.insert(j_resid, None)
            i_resid += 1
        elif (not symbol_seq in ['-']):
          self.n_missing += 1
          self.n_missing_start += 1
      if (not symbol_pdb in ["X","-"]):
        chain_started = True
        if (symbol_seq == "-"):
          self.extra.append(resid)
          self._flag_indices.append(i_aln)
        elif (not symbol_seq in ["X","-"]) and (symbol_seq != symbol_pdb):
          if (((symbol_pdb == UNK_AA) and (self.chain_type == PROTEIN)) or
              ((symbol_pdb == UNK_NA) and (self.chain_type == NUCLEIC_ACID))):
            self.unknown.append(resid)
          else :
            self.mismatch.append(resid)
            self.actual_code.append(symbol_seq)
          self._flag_indices.append(i_aln)
      prev_char = symbol_pdb
      i_aln += 1
    i_aln = alignment_length - 1
    matches = alignment.matches()
    while (alignment.a[i_aln] in ["X", "-"]):
      i_resid = i_aln - self.n_missing_start
      if (matches[i_aln] == " " and
          (self.resnames is None or
           (i_resid >= len(self.resnames) or
           self.resnames[i_resid] is None))):
        self.n_missing_end += 1
        self.n_missing += 1
      i_aln -= 1
      if i_aln < 0:
        break
    assert (len(self.sec_str) == len(alignment.a))

  def extract_coordinates(self, pdb_chain):
    """
    Collect the coordinate of the central atom (CA or P) in each residue,
    padding the array with None so it matches the sequence and resid arrays.
    """
    assert (self.chain_id == pdb_chain.id)
    self._table = []
    k = 0
    for residue_group in pdb_chain.residue_groups():
      resid = residue_group.resid()
      while (self.resids[k] != resid):
        self._xyz.append(None)
        k += 1
      res_class = None
      if (resid in self.extra):
        res_class = "not in sequence"
      elif (resid in self.mismatch):
        res_class = "mismatch to sequence"
      elif (resid in self.unknown):
        res_class = "special residue"
      xyz = None
      for atom in residue_group.atoms():
        if (atom.name == " CA ") or (atom.name == " P  "):
          xyz = atom.xyz
          break
      else :
        print("WARNING: can't find center of residue %s" % resid)
        xyz = residue_group.atoms()[0].xyz
      self._xyz.append(xyz)
      if (res_class is not None):
        self._table.append([self.chain_id, resid, res_class,
          "chain '%s' and resid %s" % (self.chain_id, resid), xyz])
      k += 1
    while (k < len(self.resids)):
      self._xyz.append(None)
      k += 1
    assert (len(self.resids) == len(self._xyz))

  def iter_residue_groups(self, pdb_chain):
    assert (self.chain_id == pdb_chain.id)
    k = 0
    for residue_group in pdb_chain.residue_groups():
      resid = residue_group.resid()
      while (self.resids[k] != resid):
        k += 1
        yield None
      yield residue_group
      k += 1
    while k < len(self.resids):
      k += 1
      yield None

  def extract_residue_groups(self, pdb_chain):
    self.residue_groups = list(self.iter_residue_groups(pdb_chain))

  def get_outliers_table(self):
    """Used in PHENIX validation GUI"""
    return self._table

  def get_highlighted_residues(self):
    """Used for wxtbx.sequence_view to highlight mismatches, etc."""
    return self._flag_indices

  def get_coordinates_for_alignment_range(self, i1, i2):
    assert (len(self._xyz) > 0)
    k = 0
    sites = []
    for j, a in enumerate(self.alignment.a):
      if (j > i2):
        break
      elif (j >= i1):
        sites.append(self._xyz[k])
      if (a != '-'):
        k += 1
    return sites

  def get_mean_coordinate_for_alignment_range(self, *args, **kwds):
    sites = self.get_coordinates_for_alignment_range(*args, **kwds)
    return get_mean_coordinate(sites)

  def get_coordinates_for_alignment_ranges(self, ranges):
    sites = []
    for i1, i2 in ranges :
      sites.extend(self.get_coordinates_for_alignment_range(i1,i2))
    return sites

  def get_mean_coordinate_for_alignment_ranges(self, *args, **kwds):
    sites = self.get_coordinates_for_alignment_ranges(*args, **kwds)
    return get_mean_coordinate(sites)

  def get_alignment(self, include_sec_str=False):
    if (include_sec_str):
      return [self.alignment.a, self.alignment.b, self.sec_str]
    else :
      return [self.alignment.a, self.alignment.b]

  def show_summary(self, out, verbose=True):
    def print_resids(resids):
      assert (len(resids) > 0)
      w = 0
      line = " ".join([ resid.strip() for resid in resids ])
      lines = str_utils.wordwrap(line, 60).split("\n")
      print("    residue IDs: %s" % lines[0], file=out)
      for line in lines[1:] :
        print("                 %s" % line, file=out)
    print("Chain '%s':" % self.chain_id, file=out)
    if (self.alignment is None):
      print("  No appropriate sequence match found!", file=out)
    else :
      print("  best matching sequence: %s" % self.sequence_name, file=out)
      print("  sequence identity: %.2f%%" % (self.identity*100), file=out)
      if (self.n_missing > 0):
        print("  %d residue(s) missing from PDB chain (%d at start, %d at end)" % (self.n_missing, self.n_missing_start, self.n_missing_end), file=out)
      if (self.n_gaps > 0):
        print("  %d gap(s) in chain" % self.n_gaps, file=out)
      if (len(self.mismatch) > 0):
        print("  %d mismatches to sequence" % len(self.mismatch), file=out)
        print_resids(self.mismatch)
      if (len(self.extra) > 0):
        print("  %d residues not found in sequence" % len(self.extra), file=out)
        print_resids(self.extra)
      if (len(self.unknown) > 0):
        print("  %d residues of unknown type" % len(self.unknown), file=out)
        print_resids(self.unknown)
      if (verbose):
        self.alignment.pretty_print(out=out,
          block_size=60,
          top_name="PDB file",
          bottom_name="sequence",
          show_ruler=False)

class validation(object):
  def __init__(self, pdb_hierarchy, sequences, params=None, log=None,
      nproc=Auto, include_secondary_structure=False,
      extract_coordinates=False, extract_residue_groups=False,
      minimum_identity=0, custom_residues=[], ignore_hetatm=False):
    #
    # XXX This is to stop assertion crash that checks lengths of provided
    # XXX sequence with the length of sequence from model (which can happen to
    # XXX be different due to presence of altlocs!
    # XXX Also this assumes altlocs within residue groups are the same resname's
    # XXX And of course making a copy is a bad idea, obviously!
    # XXX No test.
    #
    pdb_hierarchy = pdb_hierarchy.deep_copy()
    pdb_hierarchy.remove_alt_confs(always_keep_one_conformer=True)
    pdb_hierarchy.atoms().reset_i_seq()
    #
    assert (len(sequences) > 0)
    for seq_object in sequences :
      assert (seq_object.sequence != "")
    if (log is None):
      log = sys.stdout
    if (params is None):
      params = master_phil.extract()
    self.n_protein = 0
    self.n_rna_dna = 0
    self.n_other = 0
    self.chains = []
    self.minimum_identity = minimum_identity
    self.sequences = sequences
    self.custom_residues = custom_residues
    if self.custom_residues is None:
      self.custom_residues = list()
    self.sequence_mappings = [ None ] * len(sequences)
    for i_seq in range(1, len(sequences)):
      seq_obj1 = sequences[i_seq]
      for j_seq in range(0, len(sequences)):
        if (j_seq == i_seq):
          break
        else :
          seq_obj2 = sequences[j_seq]
          if (seq_obj1.sequence == seq_obj2.sequence):
            self.sequence_mappings[i_seq ] = j_seq
            break
    if (len(pdb_hierarchy.models()) > 1):
      raise Sorry("Multi-model PDB files not supported.")
    helix_selection = sheet_selection = None
    if (include_secondary_structure):
      import mmtbx.secondary_structure
      ssm = mmtbx.secondary_structure.manager(
        pdb_hierarchy=pdb_hierarchy,
        sec_str_from_pdb_file=None)
      helix_selection = ssm.helix_selection()
      sheet_selection = ssm.beta_selection()
    pdb_chains = []
    chain_seq = {}
    for pdb_chain in pdb_hierarchy.models()[0].chains():
      unk = UNK_AA
      chain_id = pdb_chain.id
      main_conf = pdb_chain.conformers()[0]
      if (main_conf.is_na()):
        self.n_rna_dna += 1
        unk = UNK_NA
        chain_type = NUCLEIC_ACID
      elif (main_conf.is_protein()):
        self.n_protein += 1
        chain_type = PROTEIN
      else :
        self.n_other += 1
        print("Skipping non-polymer chain '%s'" % chain_id, file=log)
        continue
      pad = True
      pad_at_start = False
      seq = pdb_chain.as_padded_sequence(
        substitute_unknown=unk, pad=pad, pad_at_start=pad_at_start, ignore_hetatm=ignore_hetatm)
      chain_seq[chain_id] = seq
      resids = pdb_chain.get_residue_ids(pad=pad, pad_at_start=pad_at_start,
        ignore_hetatm=ignore_hetatm)
      resnames = pdb_chain.get_residue_names_padded(
        pad=pad, pad_at_start=pad_at_start, ignore_hetatm=ignore_hetatm)
      assert (len(seq) == len(resids) == len(resnames))
      sec_str = None
      if (helix_selection is not None) and (main_conf.is_protein()):
        sec_str = main_conf.as_sec_str_sequence(helix_selection,
          sheet_selection, pad=pad, pad_at_start=pad_at_start)
        assert (len(sec_str) == len(seq))
      c = chain(chain_id=chain_id,
        sequence=seq,
        resids=resids,
        chain_type=chain_type,
        sec_str=sec_str,
        resnames=resnames)
      self.chains.append(c)
      pdb_chains.append(pdb_chain)
    if len(self.chains) == 0:
      raise Sorry("Could not find any polymer chains to align.")
    debug = False
    if debug:
      alignments_and_names = []
      for i in range(len(self.chains)):
        alignments_and_names.append(self.align_chain(i))
    else:
      try:
        alignments_and_names = easy_mp.pool_map(
          fixed_func=self.align_chain,
          args=range(len(self.chains)),
          processes=nproc)
      except Exception as e:
        # retry without mp
        print("Failed to get alignments with multiprocessing, retrying")
        alignments_and_names = []
        for i in range(len(self.chains)):
          alignments_and_names.append(self.align_chain(i))
    assert (len(alignments_and_names) == len(self.chains) == len(pdb_chains))
    for i, c in enumerate(self.chains):
      alignment, seq_name, seq_id = alignments_and_names[i]
      # if no alignment was found, just use the sequence from the model
      if alignment is None:
        alignment = align(chain_seq[c.chain_id], chain_seq[c.chain_id]).extract_alignment()
        seq_name = 'model'
        seq_id = 0
      pdb_chain = pdb_chains[i]
      try :
        c.set_alignment(alignment, seq_name, seq_id)
      except Exception as e :
        print("Error processing chain %s" % c.chain_id)
        raise
        print(e)
      else :
        if (extract_coordinates):
          c.extract_coordinates(pdb_chain)
        if extract_residue_groups:
          c.extract_residue_groups(pdb_chain)
    self.sequences = None

  def align_chain(self, i):
    import mmtbx.alignment
    chain = self.chains[i]
    best_alignment = None
    best_sequence = None
    best_seq_id = None
    best_identity = self.minimum_identity
    best_width = sys.maxsize
    best_length = sys.maxsize
    for i_seq, seq_object in enumerate(self.sequences):
      alignment = mmtbx.alignment.align(
        seq_a=chain.sequence,
        seq_b=seq_object.sequence).extract_alignment()
      identity = alignment.calculate_sequence_identity(skip_chars=['X'])
      # if the identities of two alignments are equal, then we prefer the
      # alignment that has the narrowest range for the match and the
      # shortest sequence
      width = alignment.match_codes.rfind('m') - alignment.match_codes.find('m')
      length = len(seq_object.sequence)
      if ((identity > best_identity) or
          (approx_equal_core(identity, best_identity, 1.e-6, 1.e10, None, "")
           and width <= best_width and length < best_length)):
        best_identity = identity
        best_alignment = alignment
        best_sequence = seq_object.name
        best_seq_id = i_seq
        best_width = width
        best_length = length
    return best_alignment, best_sequence, best_seq_id

  def get_table_data(self):
    table = []
    for c in self.chains :
      outliers = c.get_outliers_table()
      if (outliers is not None):
        table.extend(outliers)
    return table

  def get_missing_chains(self):
    missing = []
    for c in self.chains :
      if (c.alignment is None):
        missing.append((c.chain_id, c.sequence))
    return missing

  def show(self, out=None):
    if (out is None):
      out = sys.stdout
    for chain in self.chains :
      chain.show_summary(out)

  def get_relative_sequence_copy_number(self):
    """
    Count the number of copies of each sequence within the model, used for
    adjusting the input settings for Phaser-MR in Phenix.  This should
    automatically account for redundancy: only the first matching sequence is
    considered, and sequences which are non-unique will have a copy number of
    -1.  Thus if we have 4 copies of a sequence, and the PDB hierarchy has
    2 matching chains, the copy numbers will be [0.5, -1, -1, -1].
    """
    n_seq  = len(self.sequence_mappings)
    counts = [ 0 ] * n_seq
    for c in self.chains :
      if (c.sequence_id is not None):
        counts[c.sequence_id] += 1
    redundancies = [ 1 ] * n_seq
    for i_seq in range(n_seq):
      j_seq = self.sequence_mappings[i_seq]
      if (j_seq is not None):
        redundancies[j_seq] += 1
        redundancies[i_seq] = 0
    counts_relative = [ 0 ] * n_seq
    for i_seq in range(n_seq):
      if (redundancies[i_seq] == 0):
        counts_relative[i_seq] = -1
      else :
        counts_relative[i_seq] = counts[i_seq] / redundancies[i_seq]
    return counts_relative

  def sequence_as_cif_block(self, custom_residues=None):
    """
    Export sequence information as mmCIF block
    Version 5.0 of mmCIF/PDBx dictionary

    Parameters
    ----------
    custom_residues: list of str
      List of custom 3-letter residues to keep in pdbx_one_letter_sequence
      The 3-letter residue must exist in the model. If None, the value
      from self.custom_residues is used.

    Returns
    -------
    cif_block: iotbx.cif.model.block
    """

    if custom_residues is None:
      custom_residues = self.custom_residues

    dna = set(['DA', 'DT', 'DC', 'DG', 'DI'])
    rna = set(['A', 'U', 'C', 'G'])
    rna_to_dna = {'A': 'DA', 'U': 'DT', 'T': 'DT', 'C': 'DC', 'G': 'DG',
                  'I': 'DI'}
    modified_dna = set()
    modified_rna = set()
    for key in modified_rna_dna_names.lookup.keys():
      value = modified_rna_dna_names.lookup[key]
      if value in dna:
        modified_dna.add(key)
      elif value in rna:
        modified_rna.add(key)

    # http://mmcif.wwpdb.org/dictionaries/mmcif_pdbx_v50.dic/Categories/entity.html
    entity_loop = iotbx.cif.model.loop(header=(
      '_entity.id',
      '_entity.pdbx_description'
    ))

    # http://mmcif.wwpdb.org/dictionaries/mmcif_pdbx_v50.dic/Categories/entity_poly.html
    entity_poly_loop = iotbx.cif.model.loop(header=(
      '_entity_poly.entity_id',
      '_entity_poly.nstd_linkage',
      '_entity_poly.nstd_monomer',
      '_entity_poly.pdbx_seq_one_letter_code',
      '_entity_poly.pdbx_seq_one_letter_code_can',
      '_entity_poly.pdbx_strand_id',
      '_entity_poly.pdbx_target_identifier',
      '_entity_poly.type',
    ))

    # http://mmcif.wwpdb.org/dictionaries/mmcif_pdbx_v50.dic/Categories/entity_poly_seq.html
    entity_poly_seq_loop = iotbx.cif.model.loop(header=(
      '_entity_poly_seq.entity_id',
      '_entity_poly_seq.num',
      '_entity_poly_seq.mon_id',
      '_entity_poly_seq.hetero',
    ))

    # http://mmcif.wwpdb.org/dictionaries/mmcif_pdbx_v50.dic/Categories/struct_ref.html
    struct_ref_loop = iotbx.cif.model.loop(header=(
      '_struct_ref.id',
      '_struct_ref.db_code',
      '_struct_ref.db_name',
      '_struct_ref.entity_id',
      '_struct_ref.pdbx_align_begin',
      '_struct_ref.pdbx_db_accession',
      '_struct_ref.pdbx_db_isoform',
      '_struct_ref.pdbx_seq_one_letter_code',
    ))

    # http://mmcif.wwpdb.org/dictionaries/mmcif_pdbx_v50.dic/Categories/struct_ref_seq.html
    struct_ref_seq_loop = iotbx.cif.model.loop(header=(
      '_struct_ref_seq.align_id',
      '_struct_ref_seq.db_align_beg',
      '_struct_ref_seq.db_align_end',
      '_struct_ref_seq.pdbx_PDB_id_code',
      '_struct_ref_seq.pdbx_auth_seq_align_beg',
      '_struct_ref_seq.pdbx_auth_seq_align_end',
      '_struct_ref_seq.pdbx_db_accession',
      '_struct_ref_seq.pdbx_db_align_beg_ins_code',
      '_struct_ref_seq.pdbx_db_align_end_ins_code',
      '_struct_ref_seq.pdbx_seq_align_beg_ins_code',
      '_struct_ref_seq.pdbx_seq_align_end_ins_code',
      '_struct_ref_seq.pdbx_strand_id',
      '_struct_ref_seq.ref_id',
      '_struct_ref_seq.seq_align_beg',
      '_struct_ref_seq.seq_align_end',
    ))

    entity_id = 0
    # entity_poly
    sequence_to_entity_id = dict()
    nstd_linkage = dict()
    nstd_monomer = dict()
    seq_one_letter_code = dict()
    seq_one_letter_code_can = dict()
    strand_id = dict()
    target_identifier = dict()
    sequence_type = dict()
    # entity_poly_seq
    num = dict()
    mon_id = dict()
    hetero = dict()
    # struct_ref (work in progress)
    chain_id = dict()
    db_code = '?'
    db_name = '?'
    align_begin = '?'
    db_accession = '?'
    db_isoform = '?'
    # struct_ref_seq (work in progress)
    db_align_beg = '?'
    db_align_end = '?'
    PDB_id_code = '?'
    align_beg_ins_code = '?'
    align_end_ins_code = '?'

    for i_chain, chain in enumerate(self.chains):
      seq_can = chain.alignment.b
      # entity_id
      if seq_can not in sequence_to_entity_id:
        entity_id += 1
        sequence_to_entity_id[seq_can] = entity_id
      else:
        # subsequent matches just add strand_id
        entity_id = sequence_to_entity_id[seq_can]
        strand_id[entity_id].append(chain.chain_id)
        continue

      # entity_poly items
      # nstd_linkage (work in progress)
      if entity_id not in nstd_linkage:
        nstd_linkage[entity_id] = 'no'
      # nstd_monomer
      if entity_id not in nstd_monomer:
        nstd_monomer[entity_id] = 'no'
      # pdbx_seq_one_letter_code
      if entity_id not in seq_one_letter_code:
        seq_one_letter_code[entity_id] = list()
      # type (work in progress)
      if entity_id not in sequence_type:
        sequence_type[entity_id] = '?'
      has_protein = False
      has_rna = False
      has_dna = False
      has_sugar = False
      is_d = False
      # chain.alignment.a is the model
      # chain.alignment.b is the sequence
      for i_a, i_b in zip(chain.alignment.i_seqs_a, chain.alignment.i_seqs_b):
        # sequence does not have residue in model
        if i_b is None:
          continue
        # model does not have residue in sequence
        if i_a is None or chain.resnames[i_a] is None:
          letter = seq_can[i_b]
        else:
          resname = chain.resnames[i_a].strip()
          # check for modified residues
          if (resname in modified_aa_names.lookup or
              resname in modified_rna_dna_names.lookup or
              resname in custom_residues):
            letter = '({resname})'.format(resname=resname)
            nstd_monomer[entity_id] = 'yes'
          elif resname in three_letter_l_given_three_letter_d:
            letter = '({resname})'.format(resname=resname)
            nstd_monomer[entity_id] = 'yes'
          # check for nucleic acid
          elif resname in dna:
            letter = '({resname})'.format(resname=resname)
          elif resname in rna:
            letter = resname
          # regular protein
          else:
            letter = one_letter_given_three_letter.get(resname)
            if letter is None:
              letter = 'X'

          # check for protein
          if (resname in one_letter_given_three_letter or
              resname in modified_aa_names.lookup):
            has_protein = True
          # check for DNA
          # hybrid protein/DNA/RNA chains are not allowed
          if resname in dna or resname in modified_dna:
            has_dna = True
            has_protein = False
          # check for RNA
          # does not handle hybrid DNA/RNA chains
          if resname in rna or resname in modified_rna:
            has_rna = True
            has_dna = False
            has_protein = False
          # check chirality
          # hybrid D/L handed chains are not allowed
          if resname in three_letter_l_given_three_letter_d:
            is_d = True
        # pdbx_seq_one_letter_code
        seq_one_letter_code[entity_id].append(letter)

      # pdbx_seq_one_letter_code_can
      seq_one_letter_code_can[entity_id] = seq_can.replace('-', '')
      # strand_id
      if entity_id not in strand_id:
        strand_id[entity_id] = list()
      strand_id[entity_id].append(chain.chain_id)
      # target_identifier (work in progress)
      if entity_id not in target_identifier:
        target_identifier[entity_id] = '?'
      # type
      #   polypeptide(L)
      #   polypeptide(D)
      #   polydeoxyribonucleotide,
      #   polyribonucleotide
      # missing
      #   cyclic-psuedo-peptide
      #   other
      #   peptide nucleic acid
      #   polydeoxyribonucleotide/polyribonucleotide
      #   polysaccharide(D)
      #   polysaccahride(L)
      if has_protein:
        choice = 'polypeptide'
        if is_d:
          choice += '(D)'
        else:
          choice += '(L)'
      if has_dna:
        choice = 'polydeoxyribonucleotide'
      if has_rna:
        choice = 'polyribonucleotide'
      sequence_type[entity_id] = choice

      # entity_poly_seq items
      if entity_id not in mon_id:
        mon_id[entity_id] = list()
      if entity_id not in num:
        num[entity_id] = list()
      if entity_id not in hetero:
        hetero[entity_id] = list()

      # struct_ref items
      if entity_id not in chain_id:
        chain_id[entity_id] = i_chain + 1

      for i_a, i_b in zip(chain.alignment.i_seqs_a, chain.alignment.i_seqs_b):
        # sequence does not have residue in model
        if i_b is None:
          continue
        seq_resname = None
        if has_protein:
          seq_resname = three_letter_given_one_letter.get(seq_can[i_b])
        if has_dna:
          seq_resname = rna_to_dna.get(seq_can[i_b])
        if has_rna:
          seq_resname = seq_can[i_b]
        if seq_resname is None:
          seq_resname = 'UNK'
        # model does not have residue in sequence
        if i_a is None or chain.resnames[i_a] is None:
          resname = seq_resname
        else:
          resname = chain.resnames[i_a]
        mon_id[entity_id].append(resname.strip())
        if len(num[entity_id]) == 0:
          num[entity_id].append(1)
        else:
          num[entity_id].append(num[entity_id][-1] + 1)
        hetero[entity_id].append('no')

    # build loops
    ids = list(sequence_to_entity_id.values())
    ids.sort()
    align_id = 1
    for entity_id in ids:
      # construct entity_poly loop
      if len(strand_id[entity_id]) == 1:
        chains = strand_id[entity_id][0]
      else:
        chains = strand_id[entity_id]
        #chains.sort()
        chains = ','.join(chains)
      entity_poly_loop.add_row((
        entity_id,
        nstd_linkage[entity_id],
        nstd_monomer[entity_id],
        ';' + ''.join(seq_one_letter_code[entity_id]) + '\n;',
        ';' + seq_one_letter_code_can[entity_id] + '\n;',
        chains,
        target_identifier[entity_id],
        sequence_type[entity_id]
      ))

      # construct entity loop
      entity_loop.add_row((
        entity_id,
        'Chains: ' + chains
      ))

      # construct entity_poly_seq loop
      chain_length = len(mon_id[entity_id])
      for i in range(chain_length):
        entity_poly_seq_loop.add_row((
          entity_id,
          num[entity_id][i],
          mon_id[entity_id][i],
          hetero[entity_id][i]
        ))

      # construct struct_ref loop
      struct_ref_loop.add_row((
        chain_id[entity_id],
        db_code,
        db_name,
        entity_id,
        align_begin,
        db_accession,
        db_isoform,
        ';' + seq_one_letter_code_can[entity_id] + '\n;'
      ))

      # construct struct_ref_seq loop
      for chain in strand_id[entity_id]:
        struct_ref_seq_loop.add_row((
          align_id,
          db_align_beg,
          db_align_end,
          PDB_id_code,
          '1',
          len(seq_one_letter_code_can[entity_id]) - 1,
          db_accession,
          align_beg_ins_code,
          align_end_ins_code,
          align_beg_ins_code,
          align_end_ins_code,
          chain,
          chain_id[entity_id],
          '1',
          len(seq_one_letter_code_can[entity_id]) - 1
        ))
        align_id += 1

    # construct block
    cif_block = iotbx.cif.model.block()
    cif_block.add_loop(entity_loop)
    cif_block.add_loop(entity_poly_loop)
    cif_block.add_loop(entity_poly_seq_loop)
    cif_block.add_loop(struct_ref_loop)
    cif_block.add_loop(struct_ref_seq_loop)

    return cif_block

# XXX I am not particularly proud of this code
def get_sequence_n_copies(
    sequences,
    pdb_hierarchy,
    force_accept_composition=False,
    copies_from_xtriage=None,
    copies_from_user=Auto,
    minimum_identity=0.3, # okay for MR, may not be suitable in all cases
    assume_xtriage_copies_from_sequence_file=None,
    out=sys.stdout,
    nproc=1):
  """
  Utility function for reconciling the contents of the sequence file, the
  chains in the model, and the ASU.  Returns the number of copies of the
  sequence file to tell Phaser are present, or raises an error if this is
  either ambiguous or in conflict with the search model multiplicity.
  This is intended to allow the user to specify any combination of inputs -
  for instance, given a tetrameric search model, 2 copies in the ASU, and a
  monomer sequence file, the ASU contains 8 copies of the sequence(s).
  """
  print("Guessing the number of copies of the sequence file in the ASU", file=out)
  v = validation(
    pdb_hierarchy=pdb_hierarchy,
    sequences=sequences,
    log=out,
    nproc=1,
    include_secondary_structure=True,
    extract_coordinates=False,
    minimum_identity=0.3)
  missing = v.get_missing_chains()
  def raise_sorry(msg):
    raise Sorry(msg + " (Add the parameter force_accept_composition=True to "+
      "disable this error message and continue assuming 1 copy of sequence "+
      "file.)")
  if (len(missing) > 0):
    error = [
      "%d chain(s) not found in sequence file.  If the sequence does " % \
        len(missing),
      "not accurately represent the contents of the crystal after adjusting ",
      "for copy number, molecular replacement and building may fail.", ]
    if (force_accept_composition):
      print("WARNING: %s" % error, file=out)
    else :
      raise_sorry(error)
  counts = v.get_relative_sequence_copy_number()
  unique_counts = set(counts)
  if (-1 in unique_counts) : unique_counts.remove(-1)
  if (0 in unique_counts):
    unique_counts.remove(0)
    print("WARNING: %d sequence(s) not found in model.  This is not" %\
      counts.count(0), file=out)
    print("usually a problem, but it may indicate an incomplete model.", file=out)
  error = freq = None
  model_copies = copies_from_user
  if (model_copies is Auto):
    model_copies = copies_from_xtriage
  if (model_copies is None):
    model_copies = 1
    print("WARNING: assuming 1 copy of model", file=out)
  if (model_copies < 1):
    raise Sorry("Must have at least one copy of model.")
  if (len(unique_counts) == 0):
    error = "The sequence file provided does not appear to match the " +\
            "search model."
  elif (len(unique_counts) > 1):
    error = "The sequence file provided does not map evenly to the "+\
      "search model; this usually means an error in the sequence file (or "+\
      "model) such as accidental duplication or deletion of a chain. "+\
      "[counts: %s]" % list(unique_counts)
  else :
    # XXX float is_integer introduced in Python 2.6
    def is_integer(x) : return (int(x) == x)
    seq_freq = list(unique_counts)[0]
    assert seq_freq > 0
    # 1-1 mapping between PDB hierarchy and sequence
    if (seq_freq == 1.0):
      print("Assuming %d copies of sequence file (as well as model)" %\
        model_copies, file=out)
      return model_copies
    elif (seq_freq > 1):
      # hierarchy contains N copies of sequence
      if is_integer(seq_freq):
        freq = int(seq_freq) * model_copies
        print("Assuming %d copies of sequence file present" % freq, file=out)
        return freq
      # hierarchy contains X.Y copies of sequence
      else :
        error = "The search model does not appear to contain a round "+\
          "number of copies of the sequence; this usually means "+\
          "that your sequence file has too many or too few sequences.  " +\
          "[freq=%g]" % seq_freq
    # more copies of sequence than in model
    else :
      inverse_freq = 1 / seq_freq
      if is_integer(inverse_freq):
        # too much sequence
        if (inverse_freq > model_copies):
          error = "The number of copies of the model expected is less than "+\
            "the number indicated by the sequence file (%d versus %d).  " % \
            (model_copies, int(inverse_freq)) + \
            "This may mean that either the sequence file or the predicted "+\
            "number of copies is wrong."
          if ((copies_from_user is Auto) and
              (copies_from_xtriage is not None) and
              (assume_xtriage_copies_from_sequence_file)):
            print(error, file=out)
            print("", file=out)
            print("Since the number of copies was guessed by Xtriage", file=out)
            print("based on the sequence file, it will be scaled", file=out)
            print("by %g to be appropriate for the search model." % \
              inverse_freq, file=out)
            return seq_freq
        # too much model
        # XXX is this actually possible the way I've written the function?
        elif (inverse_freq < model_copies):
          error = "The number of copies of the model expected exceeds the "+\
            "number indicated by the sequence file (%d versus %d)." % \
            (model_copies, int(inverse_freq)) + \
            "This may mean that either the sequence file or the predicted "+\
            "number of copies is wrong."
        # model_copies times model contents matches sequence
        else :
          print("Assuming only one copy of sequence file contents.", file=out)
          return 1
      else :
        error = "The sequence file does not appear to contain a round "+\
          "number of copies of the model (%g)." % inverse_freq
  if (error is not None):
    if (force_accept_composition):
      print("WARNING: " + error, file=out)
      print("", file=out)
      print("Ambiguous input, defaulting to 1 copy of sequence file", file=out)
      return 1
    else :
      raise_sorry(error)
  else :
    raise RuntimeError("No error but frequency not determined")

def get_sequence_n_copies_from_files(seq_file, pdb_file, **kwds):
  from iotbx import file_reader
  import iotbx.pdb
  seq_in = file_reader.any_file(seq_file,
    raise_sorry_if_errors=True,
    raise_sorry_if_not_expected_format=True)
  if (seq_in.file_type != "seq"):
    raise Sorry("Can't parse %s as a sequence file.")
  try:
    pdb_in = iotbx.pdb.input(pdb_file)
  except Exception:
    raise Sorry("Can't parse %s as a PDB or mmCIF file.")
  kwds['pdb_hierarchy'] = pdb_in.construct_hierarchy()
  kwds['sequences'] = seq_in.file_object
  return get_sequence_n_copies(**kwds)

# XXX test needed
def group_chains_and_sequences(seq_file, pdb_file, **kwds):
  from iotbx import file_reader
  import iotbx.pdb
  seq_in = file_reader.any_file(seq_file,
    raise_sorry_if_errors=True,
    raise_sorry_if_not_expected_format=True)
  if (seq_in.file_type != "seq"):
    raise Sorry("Can't parse %s as a sequence file.")
  try:
    pdb_in = iotbx.pdb.input(pdb_file)
  except Exception:
    raise Sorry("Can't parse %s as a PDB or mmCIF file.")
  kwds['pdb_hierarchy'] = pdb_in.construct_hierarchy()
  kwds['sequences'] = seq_in.file_object
  v = validation(**kwds)
  chain_to_sequence_mappings = {}
  sequence_to_chain_mappings = {}
  for chain in v.chains :
    seq_id = chain.sequence_id
    chain_id = chain.chain_id
    if (seq_id is None):
      raise Sorry("Can't map chain %s to a sequence in %s." % (chain_id,
        seq_file))
    sequence = seq_in.file_object[seq_id].sequence
    if (chain_id in chain_to_sequence_mappings):
      if (chain_to_sequence_mappings[chain_id] != sequence):
        raise Sorry("Multiple unique chains named '%s'" % chain_id)
    else :
      chain_to_sequence_mappings[chain_id] = sequence
    if (not chain.sequence in sequence_to_chain_mappings):
      sequence_to_chain_mappings[sequence] = []
    sequence_to_chain_mappings[sequence].append(chain_id)
  return sequence_to_chain_mappings


 *******************************************************************************


 *******************************************************************************
mmtbx/validation/undowser.py
from __future__ import absolute_import, division, print_function

import sys
from libtbx import easy_run
from mmtbx.validation import validation, atoms, residue, atom_info
from mmtbx.validation.clashscore import check_and_add_hydrogen, probe_clashscore_manager
import libtbx.load_env
import json

class ud_water(residue):
  __ud_water_attr__ = [
    "contacts",
    "model_id",
    "src_atom_id"
    #"max_b_factor",
  ]
  __slots__ = residue.__slots__ + __ud_water_attr__

  @staticmethod
  def header():
    return "%-20s %-20s %7s %7s %7s  %-20s" % ("Water ID", "Clashes with", "Water B", "Contact B", "Clash severity", "Category")

  def as_JSON(self):
    serializable_slots = [s for s in self.__slots__ if s != "contacts" and hasattr(self, s) ]
    slots_as_dict = ({s: getattr(self, s) for s in serializable_slots})
    wc_list = []
    for wc in self.contacts:
      wc_slots_list = [s for s in wc.__slots__ if s != "atoms_info" and s != "src_atom_id"]
      wc_slots_as_dict = {s: getattr(wc, s) for s in wc_slots_list if s != 'xyz' and s != "atom_selection"}
      wc_list.append(wc_slots_as_dict)
    slots_as_dict["water_contacts"] = wc_list
    #print({**slots_as_dict, **atom0_slots_as_dict})
    return json.dumps(slots_as_dict, indent=2)

  def as_hierarchical_JSON(self):
    hierarchical_dict = {}
    hierarchy_nest_list = ['model_id', 'chain_id', 'resid', 'altloc']
    return json.dumps(self.nest_dict(hierarchy_nest_list, hierarchical_dict), indent=2)

  def as_string(self):
    return "%-20s %-20s  %7.3f" % (self.atoms_info[0].id_str(),
      self.atoms_info[1].id_str(), abs(self.overlap))

  def as_table_row_phenix(self):
    rows = []
    for wc in self.contacts:
      rows.append([self.id_str(), wc.atoms_info[1].id_str(), wc.src_b, wc.trg_b, wc.mingap, wc.get_category()])
    return rows

  def get_contacts(self):
    return self.contacts

#-u -q -mc -het -once -NOVDWOUT %s %s' % (probe_command, condensed_flag, nuclear_flag) "ogt%d not water" "ogt%d" -' % (ogt, ogt)
#       phenix.probe -4H -quiet -noticks -nogroup -dotmaster -mc -het -once -wat2wat 'water' 'water'

class undowserlyze(validation):
  __slots__ = validation.__slots__ + [
    "fast",
    "condensed_probe",
    "probe_file",
    "probe_undowser_manager",
    "water_count",
    "results_by_model"
  ]
  program_description = "Analyze waters for model"
  gui_list_headers = ["Water ID", "Clashes with", "Water B", "Contact B", "Clash severity", "Category"]
  gui_formats = ["%s", "%s", ".2f", ".2f", ".3f", "%s"]
  wx_column_widths = [150, 150, 150, 150, 150, 300] #actually set in GUI's Molprobity/Core.py
  html_header = """<html>
<head>
  <title>Summary table of water clashes</title>
</head>

<body>

<hr>
This table lists all HOH "waters" in the structure that have steric clashes. HOH are classified into common categories based on the atom they clash with.
<br><br>
A clashing HOH is very unlikely be be a real water, unless the clashing atom position is incorrect. The following categories provide guidance for correcting false HOH.
<br><br>
<b>Clash with polar</b> - HOH that clashes with polar groups may actually be a coordinated ion.
<br>
<b>Clash with nonpolar</b> - HOH that clashes with nonpolar groups may be a missing or displaced atom&ast;. Or it may be the first atom of an unmodeled alternate.
<br>
<b>Clash with both polar and nonpolar</b> - HOH that clashes with both polar and non-polar groups is unlikely to be an ion. If clashes are severe, a displaced atom is likely. If clashes and map are weak, the HOH may be entirely removable.
<br>
<b>Clash with water</b> - HOH-HOH clashes may be real waters that need to be modeled as alternates of compatible occupancy. Or they may be in the density of a sidechain alternate or a larger ligand.
<br>
<b>Clash with altloc</b> - HOH clashes involving one or more alternate conformations may be resolved by renaming some of the alternates.
<br><br>
<b>High B-factor</b> - HOH with clashes and minimal support in the map should be removed from the model. This table does not report map data directly, but a high B-factor is a likely warning sign that an HOH is a poor fit to the map.
<br>
<b>Severe clash</b> - HOH with severe clash overlap but good map support is likely to be a position where an atom is displaced.
<br><br>
&ast;<i>Displaced atom</i> indicates that a structural atom has been moved from its proper place in the model and replaced by HOH. Displaced sidechains are common. Moved atoms may be restored by local rebuilding.
<br>
<i>Missing atoms</i> have been entirely replaced by HOH. Removed atoms may be restored by modeling alternate conformations (especially sidechains), modeling ligands, or continuing a macromolecular mainchain.
<br><br>
These categories are general suggestions. Check your electron density; trust your intuition and experience. Prisant 2020 Prot Sci 29:315 (<a href="https://doi.org/10.1002/pro.3786">https://doi.org/10.1002/pro.3786</a>) illustrates 10 examples of clashing HOH cases.
<br>
<hr>
<br>
"""

  html_table = """
<br><br>
<hr>
<br>
<table border=1 width='100%'>
<tr bgcolor='#9999cc'><td rowspan='1' align='center'>Water ID</td>
<td align='center'>Clashes with</td>
<td align='center'>Water B</td>
<td align='center'>Contact B</td>
<td align='center'>Clash<br>Severity</td>
<td align='center'>Clash with Polar<br><small>May be ion</small></td>
<td align='center'>Clash with non-polar<br><small>Unmodeled alt or noise</small></td>
<td align='center'>Clash with water<br><small>Occ &lt;1 or ligand</small></td>
<td align='center'>Clash with altloc<br><small>Add or rename alts</small></td></tr>
"""

  def get_result_class(self):
    return ud_water

  def __init__(self,
      pdb_hierarchy,
      keep_hydrogens=True,
      nuclear=False,
      outliers_only=False,
      force_unique_chain_ids=False,
      time_limit=120,
      b_factor_cutoff=None,
      save_modified_hierarchy=False,
      verbose=False,
      do_flips=False,
      out=sys.stdout):
    validation.__init__(self)
    #self.clashscore = None
    #self.clashscore_b_cutoff = None
    #self.clash_dict = {}
    #self.clash_dict_b_cutoff = {}
    #self.list_dict = {}
    #self.probe_file = None
    if (not libtbx.env.has_module(name="probe")):
      raise RuntimeError(
        "Probe could not be detected on your system.  Please make sure "+
        "Probe is in your path.\nProbe is available at "+
        "http://kinemage.biochem.duke.edu/")
    if verbose:
      if not nuclear:
        print("\nUsing electron cloud x-H distances and vdW radii")
      else:
        print("\nUsing nuclear cloud x-H distances and vdW radii")
    import iotbx.pdb
    from scitbx.array_family import flex
    from mmtbx.validation import utils
    n_models = len(pdb_hierarchy.models())
    use_segids = utils.use_segids_in_place_of_chainids(
                   hierarchy=pdb_hierarchy)

    sel_cache = pdb_hierarchy.atom_selection_cache()
    water_sel= sel_cache.selection("water")
    hierarchy_waters = pdb_hierarchy.select(water_sel)
    #print(dir(hierarchy_waters.residue_groups()))
    #phenix.pdb_atom_selection
    self.water_count = len(list(hierarchy_waters.residue_groups()))
    water_xyzs = {}
    self.results_by_model = {}
    for atom in hierarchy_waters.atoms():
      if atom.name == " O  ":
        water_xyzs[atom.parent().parent().resid()] = atom.xyz
        model_id = atom.parent().parent().parent().parent().id
        if model_id not in self.n_total_by_model:
          self.n_total_by_model[model_id] = 0
        self.n_total_by_model[model_id] += 1
    for i_mod, model in enumerate(pdb_hierarchy.models()):
      if model.id not in self.results_by_model:
        self.results_by_model[model.id] = []
        self.n_outliers_by_model[model.id] = 0
      input_str,_ = check_and_add_hydrogen(
        pdb_hierarchy=pdb_hierarchy,
        model_number=i_mod,
        nuclear=nuclear,
        verbose=verbose,
        time_limit=time_limit,
        keep_hydrogens=keep_hydrogens,
        do_flips = do_flips,
        log=out)
      r = iotbx.pdb.hierarchy.root()
      mdc = model.detached_copy()
      r.append_model(mdc)
      occ_max = flex.max(r.atoms().extract_occ())
      self.probe_undowser_manager = probe_undowser_manager(
        h_pdb_string=input_str,
        nuclear=nuclear,
        verbose=verbose,
        model_id=model.id)
      self.probe_undowser_manager.run_probe_undowser()
      water_contacts = self.probe_undowser_manager.get_water_contacts()
      for src_atom_id, wc_list in water_contacts.items():
        src_chain_id=probe_undowser_manager.get_chain_probe_atom_id(src_atom_id)
        src_resseq=probe_undowser_manager.get_resseq_probe_atom_id(src_atom_id)
        src_icode=probe_undowser_manager.get_icode_probe_atom_id(src_atom_id)
        src_resname=probe_undowser_manager.get_resname_probe_atom_id(src_atom_id)
        src_altloc=probe_undowser_manager.get_altloc_probe_atom_id(src_atom_id)
        #selection_string = "model {} and chain {} and resseq '{}' and altid '{}' and name O".format(model.id, src_chain_id, src_resseq, src_altloc)
        result = ud_water(
          outlier=True,
          src_atom_id=src_atom_id,
          model_id=model.id,
          chain_id=src_chain_id,
          resseq=src_resseq,
          icode=src_icode,
          resname=src_resname,
          altloc=src_altloc,
          segid=None, # XXX ???
          xyz=water_xyzs[src_resseq+src_icode],
          contacts=wc_list,
        )
        #if (not outliers_only or is_outlier):
        self.results.append(result)
        self.results_by_model[model.id].append(result)
        self.n_outliers_by_model[model.id] += 1

      #if (save_modified_hierarchy):
      #  self.pdb_hierarchy = iotbx.pdb.input(
      #    pdb_string=self.probe_clashscore_manager.h_pdb_string).construct_hierarchy()
      #self.clash_dict[model.id] = self.probe_clashscore_manager.clashscore
      #self.clash_dict_b_cutoff[model.id] = self.probe_clashscore_manager.\
      #                                     clashscore_b_cutoff
      #self.list_dict[model.id] = self.probe_clashscore_manager.bad_clashes
      #if (n_models == 1) or (self.clashscore is None):
      #  self.results = self.probe_clashscore_manager.bad_clashes
      #  self.n_outliers = len(self.results)
      #  self.clashscore = self.probe_clashscore_manager.clashscore
      #  self.clashscore_b_cutoff = self.probe_clashscore_manager.\
      #                             clashscore_b_cutoff


#  def show_summary(self, out=sys.stdout, prefix=""):
#    if self.clashscore is None:
#      raise Sorry("PROBE output is empty. Model is not compatible with PROBE.")
#    elif (len(self.clash_dict) == 1):
#      #FIXME indexing keys can break py2/3 compat if more than 1 key
#      k = list(self.clash_dict.keys())[0]
#      #catches case where file has 1 model, but also has model/endmdl cards
#      print(prefix + "clashscore = %.2f" % self.clash_dict[k], file=out)
#      if self.clash_dict_b_cutoff[k] is not None and self.b_factor_cutoff is not None:
#        print("clashscore (B factor cutoff = %d) = %f" % \
#          (self.b_factor_cutoff,
#           self.clash_dict_b_cutoff[k]), file=out)
#    else:
#      for k in sorted(self.clash_dict.keys()):
#        print(prefix + "MODEL %s clashscore = %.2f" % (k,
#          self.clash_dict[k]), file=out)
#        if self.clash_dict_b_cutoff[k] is not None and self.b_factor_cutoff is not None:
#          print("MODEL%s clashscore (B factor cutoff = %d) = %f" % \
#            (k, self.b_factor_cutoff, self.clash_dict_b_cutoff[k]), file=out)

#  def show(self, out=sys.stdout, prefix="", outliers_only=None, verbose=None):
#    if (len(self.clash_dict) == 1):
#      for result in self.list_dict[''] :
#        print(prefix + str(result), file=out)
#    else :
#      for k in self.list_dict.keys():
#        for result in self.list_dict[k] :
#          print(prefix + str(result), file=out)
#    self.show_summary(out=out, prefix=prefix)

  def as_JSON(self, addon_json={}):
    if not addon_json:
      addon_json = {}
    addon_json["validation_type"] = "undowser"
    data = addon_json
    flat_results = []
    hierarchical_results = {}
    summary_results = {}
    for result in self.results:
      flat_results.append(json.loads(result.as_JSON()))
      hier_result = json.loads(result.as_hierarchical_JSON())
      hierarchical_results = self.merge_dict(hierarchical_results, hier_result)

    data['flat_results'] = flat_results
    data['hierarchical_results'] = hierarchical_results

    for model_id in self.n_total_by_model.keys():
      summary_results[model_id] = { "num_outliers" : self.n_outliers_by_model[model_id],
        "num_waters" : self.n_total_by_model[model_id],
      }
    data['summary_results'] = summary_results
    return json.dumps(data, indent=2)

  def as_HTML(self):
    return self.as_html_table()

  #defaults to returning table corresponding to the first model, even if model_id isn't a valid input
  def as_html_table(self, model_id=""):
    if model_id not in self.results_by_model:
      model_id = sorted(self.results_by_model.keys())[0]
    model_results = self.results_by_model[model_id]
    #this could probably be more efficient, this recreates a "water_contacts" object to avoid changing CJW's original HTML code
    water_contacts = {}
    for ud_water in model_results:
      water_contacts[ud_water.src_atom_id]=ud_water.get_contacts()

    #water_contacts = self.probe_undowser_manager.get_water_contacts()
    html_string = self.html_header
    if self.water_count == 0:
      html_string = html_string+"SUMMARY: %i waters out of %i have clashes (%.2f%%)" % (0, 0, 0)
    else:
      html_string = html_string+"SUMMARY: %i waters out of %i have clashes (%.2f%%)" % (len(water_contacts), self.n_total_by_model[model_id], len(water_contacts)/self.n_total_by_model[model_id]*100)
    html_string = html_string + self.html_table

    contact_keys = sorted(water_contacts, key=lambda c: (-1*cumulative_severity(c, water_contacts)))
    #simple reverse sorting may put waters with the same cumulative severity in reverse sequence order

    row_number = 0
    row_color = ['#eaeaea','#ffffff']
    for contact_key in contact_keys:
      water = water_contacts[contact_key]
      water.sort(key=lambda w: (-1*float(w.mingap)))
      bgcolor = row_color[row_number%2]
      html_string = html_string+"<tr bgcolor=%s><td rowspan='%i' ><pre><code>%s</code></pre></td>\n" % (bgcolor,len(water),water[0].format_src_id_str())
      row_number+=1
      clashcount = 0
      for clash in water:
        if clashcount: html_string = html_string+'<tr bgcolor=%s>' % bgcolor
        clashcount+=1
        html_string = html_string+"<td><pre><code>%s</code></pre></td>%s%s<td bgcolor='%s'>%s</td>%s%s%s%s</tr>\n" % (clash.format_trg_id_str(), clash.write_b_cell(clash.src_b), clash.write_b_cell(clash.trg_b), clash.color_clash_severity(), clash.mingap, clash.write_polar_cell(), clash.write_nonpolar_cell(), clash.write_other_water_cell(), clash.write_altloc_cell())
    html_string = html_string+"</table>"
    return html_string
      #out.write("<td>%s</td><td bgcolor='%s'>%s</td><td>%s</td><td>%s</td><td>%s</td><td>%s</td></tr>\n" % (clash.format_trg_id_str(), clash.color_clash_severity(), clash.mingap,  clash.does_it_clash_with_altloc(), clash.does_it_clash_with_polar(), clash.does_it_clash_with_nonpolar(), clash.does_it_clash_with_other_water()))
      #out.write("<td>%s</td><td bgcolor='%s'>%s</td><td %s></td><td %s></td><td %s></td><td %s></td></tr>\n" % (clash.format_trg_id_str(), clash.color_clash_severity(), clash.mingap, color_cell(clash.does_it_clash_with_polar()), color_cell(clash.does_it_clash_with_nonpolar()), color_cell(clash.does_it_clash_with_other_water()), color_cell(clash.does_it_clash_with_altloc()) ))

    #tr-level bgcolors for alternating table stripes
    #bgcolor='#9999cc' (blue for column headers)
    #bgcolor='#ffffff' (white background)
    #bgcolor='#f0f0f0' (original gray for stripes)
    #bgcolor='#eaeaea' (slightly darker gray for stripes)

class water_contact(atoms):
  wc_slots = ["model_id",
    "src_atom_id",
    "src_chain",
    "src_resseq",
    "src_icode",
    "src_resname",
    "src_atom",
    "src_altloc",
    "trg_heavy_atom",
    "trg_chain",
    "trg_resseq",
    "trg_icode",
    "trg_resname",
    "trg_atom",
    "trg_altloc",
    "mingap",
    "src_b",
    "trg_b",
    "category",
    ]

  __slots__ = atoms.__slots__ + wc_slots

  def __init__(self, model_id, src_atom_id, trg_atom_id, trg_heavy_atom, mingap, src_b, trg_b):
    self.model_id = model_id
    self.src_atom_id = src_atom_id
    #self.trg_atom_id = trg_atom_id
    self.trg_heavy_atom = trg_heavy_atom
    # A2778 HOH  O  A
    self.atoms_info = []
    #ccnnnnirrr?aaaal
    self.src_chain = probe_undowser_manager.get_chain_probe_atom_id(src_atom_id)
    self.src_resseq = probe_undowser_manager.get_resseq_probe_atom_id(src_atom_id)
    self.src_icode = probe_undowser_manager.get_icode_probe_atom_id(src_atom_id)
    self.src_resname = probe_undowser_manager.get_resname_probe_atom_id(src_atom_id)
    self.src_atom = probe_undowser_manager.get_atom_probe_atom_id(src_atom_id)
    self.src_altloc = probe_undowser_manager.get_altloc_probe_atom_id(src_atom_id)
    self.atoms_info.append(atom_info(
      model_id=model_id,
      chain_id=self.src_chain,
      resseq=self.src_resseq,
      icode=self.src_icode,
      resname=self.src_resname,
      altloc=self.src_altloc,
      name=self.src_atom)
    )

    self.trg_chain = probe_undowser_manager.get_chain_probe_atom_id(trg_atom_id)
    self.trg_resseq = probe_undowser_manager.get_resseq_probe_atom_id(trg_atom_id)
    self.trg_icode = probe_undowser_manager.get_icode_probe_atom_id(trg_atom_id)
    self.trg_resname = probe_undowser_manager.get_resname_probe_atom_id(trg_atom_id)
    self.trg_atom = probe_undowser_manager.get_atom_probe_atom_id(trg_atom_id)
    self.trg_altloc = probe_undowser_manager.get_altloc_probe_atom_id(trg_atom_id)
    self.atoms_info.append(atom_info(
      model_id=model_id,
      chain_id=self.trg_chain,
      resseq=self.trg_resseq,
      icode=self.trg_icode,
      resname=self.trg_resname,
      altloc=self.trg_altloc,
      name=self.trg_atom)
    )

    self.mingap = mingap.lstrip('-')
    #main table lists all overlaps as positive
    #the simple strip works as long as we only look at clashes

    self.src_b = float(src_b)
    self.trg_b = float(trg_b)
    self.outlier = True
    self.score = 0.0
    self.category = self.get_category()

  def get_category(self):
    category = "uncategorized"
    if self.does_it_clash_with_polar():
      category = "polar clash"
    if self.does_it_clash_with_nonpolar():
      category = "nonpolar clash"
    if self.does_it_clash_with_other_water():
      category = "water clash"
    if self.does_it_clash_with_altloc():
      if category != "uncategorized":
        category = category + ", altloc clash"
      else:
        category = "altloc clash"
    return category

  def trg_is_H(self):
    if self.trg_atom.strip().startswith('H'): return True
    else: return False

  def trg_is_charged_N(self):
  #what N's can be charged in nucleic acids?
  #how to handle the great variety of ligands?
    if self.trg_resname == 'LYS' and self.trg_atom == ' NZ ':
      return True
    elif self.trg_resname == 'ARG' and self.trg_atom in [' NH1',' NH2']:
      return True
    elif self.trg_resname == 'HIS' and self.trg_atom in [' ND1',' NE2']:
      return True
    else:
      return False

  def format_src_id_str(self):
    return ":".join([self.src_chain,self.src_resseq+self.src_icode,self.src_resname,self.src_altloc])

  def format_trg_id_str(self):
    #return self.trg_heavy_atom+" of "+":".join([self.trg_chain,self.trg_resseq+self.trg_icode,self.trg_resname,self.trg_altloc])
    return self.trg_atom+" of "+":".join([self.trg_chain,self.trg_resseq+self.trg_icode,self.trg_resname,self.trg_altloc])

  def color_clash_severity(self):
    mingap = float(self.mingap)
    if mingap < 0.5: return '#ffb3cc'
    elif mingap > 0.9: return '#ee4d4d'
    else: return '#ff76a9'

  def does_it_clash_with_polar(self):
    #Polar atoms in proteins are O, N, and S
    #Nucleic acids also have P, but that appears completely shielded by O's
    #All O are polar.  Are any N sufficiently non-polar that they wouldn't coordinate with metal?
    #Another water does not count as polar for these purposes
    #Not currently considering what polar atoms might be in ligands
    if self.trg_resname == "HOH":
      return ''
    if self.trg_heavy_atom in ['O','S']:
      return True
    if self.trg_heavy_atom == 'N':
      if self.trg_is_H():
        return True #H on N is polar
      elif self.trg_is_charged_N():
        return True
    return ''

  def does_it_clash_with_altloc(self):
    #Goal is to find any clashes that might be resolved by different altloc naming
    #A-A clashes, A-_ clashes, and _-A clashes
    #Probe should automatically ignore any A-B contacts, since those are in fully different alts
    if self.src_altloc.strip() or self.trg_altloc.strip():
      return True
    else:
      return ''

  def does_it_clash_with_other_water(self):
    if self.trg_resname == "HOH":
      return True
    else:
      return ''

  def does_it_clash_with_nonpolar(self):
    #This is the most complex one and will likely receive iterations
    #Start with simple check for non-polars
    if self.trg_heavy_atom in ['C']:
      return True
    elif self.trg_is_H():
      if self.trg_heavy_atom in ['O','N','S']:
        return ''
      else:
        return True
    elif self.trg_heavy_atom in ['N']:
      if not self.trg_is_charged_N():
        return True
    return ''

  def write_polar_cell(self):
    if self.does_it_clash_with_polar():
      trg_element = self.trg_atom.strip()[0:1]
      if trg_element == 'H':
        return "<td align='center' bgcolor='%s'>&minus; ion</td>" % self.color_clash_severity()
      elif trg_element in ['O','S']:
        return "<td align='center' bgcolor='%s'>&plus; ion</td>" % self.color_clash_severity()
      elif trg_element == 'N':
        return "<td align='center' bgcolor='%s'>&minus; ion</td>" % self.color_clash_severity()
      else:
        return "<td align='center' bgcolor='%s'>*</td>" % self.color_clash_severity()
    else:
      return "<td></td>"

  def write_nonpolar_cell(self):
    if self.does_it_clash_with_nonpolar():
      return "<td align='center' bgcolor='%s'>&times;</td>" % self.color_clash_severity()
    else:
      return "<td></td>"

  def write_altloc_cell(self):
    if self.does_it_clash_with_altloc():
      if self.does_it_clash_with_other_water():
        return "<td align='center' bgcolor='%s'>alt water</td>" % self.color_clash_severity()
      elif self.src_altloc.strip() and self.trg_altloc.strip():
        return "<td align='center' bgcolor='%s'>alt both sides</td>" % self.color_clash_severity()
      elif self.src_altloc.strip():
        return "<td align='center' bgcolor='%s'>alt water</td>" % self.color_clash_severity()
      else:
        return "<td align='center' bgcolor='%s'>alt partner atom</td>" % self.color_clash_severity()
      #return "<td align='center' bgcolor='%s'>&times;</td>" % self.color_clash_severity()
    else:
      return "<td></td>"

  def write_other_water_cell(self):
    if self.does_it_clash_with_other_water():
      return "<td align='center' bgcolor='%s'>&times;</td>" % self.color_clash_severity()
    else:
      return "<td></td>"

  def write_b_cell(self, b):
    return "<td>%.2f</td>" % b

def cumulative_severity(contact_key, water_contacts):
  cumulative_severity = 0
  water = water_contacts[contact_key]
  for clash in water:
    weighted_severity = float(clash.mingap) - 0.2
    cumulative_severity += weighted_severity
  return cumulative_severity

def color_cell(clash_check):
  if clash_check: return 'bgcolor=#ff76a9'
  else: return ''

#this subclasses probe_clashscore_manager but doesn't really use most of it. It's mainly to reuse the code for checking for probe existance
class probe_undowser_manager(probe_clashscore_manager):
  def __init__(self,
               h_pdb_string,
               nuclear=False,
               verbose=False,
               model_id=""):
    super().__init__(h_pdb_string,
               fast = False,
               condensed_probe=False,
               nuclear=nuclear,
               largest_occupancy=10,
               b_factor_cutoff=None,
               use_segids=False,
               verbose=verbose,
               model_id=model_id)
    self.water_contacts = {}
    self.probe_command = "%s -u -q -mc -het -con -once -wat2wat -stdbonds -onlybadout 'water' 'all' -" % (self.probe_command)

  def run_probe_undowser(self):
    #print(self.probe_command)
    #print(self.h_pdb_string)
    probe_out = easy_run.fully_buffered(self.probe_command, stdin_lines=self.h_pdb_string)
    if (probe_out.return_code != 0):
      raise RuntimeError("Probe crashed - dumping stderr:\n%s" %
        "\n".join(probe_out.stderr_lines))
    probe_unformatted = probe_out.stdout_lines
    #print("probe unformatted:"+str(probe_unformatted))

    for line in probe_unformatted:
#>>name:pat:type:srcAtom:targAtom:dot-count:min-gap:gap:spX:spY:spZ:spikeLen:score:stype:ttype:x:y:z:sBval:tBval
#SelfIntersect
#:1->2:bo: A2778 HOH  O  A: A 464 ARG  HD3 : 8:-0.581:-0.475: 36.509: 0.601: 18.650:0.238:-0.1485:O:C:36.622:0.786:18.552:30.97:17.73
#:1->2:bo: A2001 HOH  O  A: A2013 HOH  O  A:14:-0.792:-0.442:-12.858:17.914:-23.935:0.221:-0.1381:O:O:-12.726:18.090:-23.907:21.07:14.91
      n = line.split(':')
      contact_type = n[2]
      src_atom_id = n[3]
      trg_atom_id = n[4]
      dotcount = n[5]
      mingap = n[6]
      #src_heavy_atom = n[13] #always the water O
      trg_heavy_atom = n[14] #parent heavy atom of a clashing H
      #gap = n[7] #meaningless in -condensed mode, use mingap instead
      src_b = n[18]
      trg_b = n[19].strip()
      clash = water_contact(self.model_id, src_atom_id, trg_atom_id, trg_heavy_atom, mingap, src_b, trg_b)

      #sys.stdout.write(line)
      #sys.stdout.write('\n')
      polar_clash = clash.does_it_clash_with_polar()
      alt_clash = clash.does_it_clash_with_altloc()
      water_clash = clash.does_it_clash_with_other_water()
      nonpolar_clash = clash.does_it_clash_with_nonpolar()

      if src_atom_id not in self.water_contacts:
        self.water_contacts[src_atom_id] = []
      self.water_contacts[src_atom_id].append(clash)

  @staticmethod
  def get_chain_probe_atom_id(atom_id):
    if len(atom_id) == 16:
      return atom_id[0:2].strip()

  @staticmethod
  def get_resseq_probe_atom_id(atom_id):
    if len(atom_id) == 16:
      return atom_id[2:6]

  @staticmethod
  def get_icode_probe_atom_id(atom_id):
    if len(atom_id) == 16:
      return atom_id[6:7]

  @staticmethod
  def get_resname_probe_atom_id(atom_id):
    if len(atom_id) == 16:
      return atom_id[7:10]

  @staticmethod
  def get_atom_probe_atom_id(atom_id):
    if len(atom_id) == 16:
      return atom_id[11:15]

  @staticmethod
  def get_altloc_probe_atom_id(atom_id):
    if len(atom_id) == 16:
      return atom_id[15:16]

  def get_water_contacts(self):
    return self.water_contacts

    #sys.exit()

    #contact_keys = water_contacts.keys()
    #contact_keys.sort()

#sys.stdout.write("WaterID : clashes_with : clash_severity : polar : nonpolar : alt : water\n")
#for contact_key in contact_keys:
#  current_water = water_contacts[contact_key]
#  sorted(current_water, key=lambda contact:contact.src_atom_id, reverse=True)
#  #current_water.sort()
#  sys.stdout.write(current_water[0].src_atom_id + ":")
#  after_first_contact = False
#  for clash in current_water:
#    if after_first_contact:
#      sys.stdout.write("                :")
#    sys.stdout.write(":".join(
#    [clash.trg_atom_id,
#    clash.mingap,
#    str(clash.does_it_clash_with_polar()),
#    str(clash.does_it_clash_with_nonpolar()),
#    str(clash.does_it_clash_with_altloc()),
#    str(clash.does_it_clash_with_other_water())])+"\n")
#    after_first_contact = True


 *******************************************************************************


 *******************************************************************************
mmtbx/validation/undowser2.py
from __future__ import absolute_import, division, print_function

import sys
from mmtbx.programs import probe2
from cctbx.maptbx.box import shift_and_box_model
from mmtbx.validation import validation, atoms, residue, atom_info
from mmtbx.validation.clashscore2 import check_and_add_hydrogen, probe_clashscore_manager
from mmtbx.validation.clashscore2 import remove_models_except_index
from libtbx.utils import null_out
import json
import iotbx.cli_parser
import mmtbx
import os
import tempfile

class ud_water(residue):
  __ud_water_attr__ = [
    "contacts",
    "model_id",
    "src_atom_id"
    #"max_b_factor",
  ]
  __slots__ = residue.__slots__ + __ud_water_attr__

  @staticmethod
  def header():
    return "%-20s %-20s %7s %7s %7s  %-20s" % ("Water ID", "Clashes with", "Water B", "Contact B", "Clash severity", "Category")

  def as_JSON(self):
    serializable_slots = [s for s in self.__slots__ if s != "contacts" and hasattr(self, s) ]
    slots_as_dict = ({s: getattr(self, s) for s in serializable_slots})
    wc_list = []
    for wc in self.contacts:
      wc_slots_list = [s for s in wc.__slots__ if s != "atoms_info" and s != "src_atom_id"]
      wc_slots_as_dict = {s: getattr(wc, s) for s in wc_slots_list if s != 'xyz' and s != "atom_selection"}
      wc_list.append(wc_slots_as_dict)
    slots_as_dict["water_contacts"] = wc_list
    #print({**slots_as_dict, **atom0_slots_as_dict})
    return json.dumps(slots_as_dict, indent=2)

  def as_hierarchical_JSON(self):
    hierarchical_dict = {}
    hierarchy_nest_list = ['model_id', 'chain_id', 'resid', 'altloc']
    return json.dumps(self.nest_dict(hierarchy_nest_list, hierarchical_dict), indent=2)

  def as_string(self):
    return "%-20s %-20s  %7.3f" % (self.atoms_info[0].id_str(),
      self.atoms_info[1].id_str(), abs(self.overlap))

  def as_table_row_phenix(self):
    rows = []
    for wc in self.contacts:
      rows.append([self.id_str(), wc.atoms_info[1].id_str(), wc.src_b, wc.trg_b, wc.mingap, wc.get_category()])
    return rows

  def get_contacts(self):
    return self.contacts

#-u -q -mc -het -once -NOVDWOUT %s %s' % (probe_command, condensed_flag, nuclear_flag) "ogt%d not water" "ogt%d" -' % (ogt, ogt)
#       phenix.probe -4H -quiet -noticks -nogroup -dotmaster -mc -het -once -wat2wat 'water' 'water'

class undowserlyze(validation):
  __slots__ = validation.__slots__ + [
    "fast",
    "condensed_probe",
    "probe_file",
    "probe_undowser_manager",
    "water_count",
    "results_by_model"
  ]
  program_description = "Analyze waters for model"
  gui_list_headers = ["Water ID", "Clashes with", "Water B", "Contact B", "Clash severity", "Category"]
  gui_formats = ["%s", "%s", ".2f", ".2f", ".3f", "%s"]
  wx_column_widths = [150, 150, 150, 150, 150, 300] #actually set in GUI's Molprobity/Core.py
  html_header = """<html>
<head>
  <title>Summary table of water clashes</title>
</head>

<body>

<hr>
This table lists all HOH "waters" in the structure that have steric clashes. HOH are classified into common categories based on the atom they clash with.
<br><br>
A clashing HOH is very unlikely be be a real water, unless the clashing atom position is incorrect. The following categories provide guidance for correcting false HOH.
<br><br>
<b>Clash with polar</b> - HOH that clashes with polar groups may actually be a coordinated ion.
<br>
<b>Clash with nonpolar</b> - HOH that clashes with nonpolar groups may be a missing or displaced atom&ast;. Or it may be the first atom of an unmodeled alternate.
<br>
<b>Clash with both polar and nonpolar</b> - HOH that clashes with both polar and non-polar groups is unlikely to be an ion. If clashes are severe, a displaced atom is likely. If clashes and map are weak, the HOH may be entirely removable.
<br>
<b>Clash with water</b> - HOH-HOH clashes may be real waters that need to be modeled as alternates of compatible occupancy. Or they may be in the density of a sidechain alternate or a larger ligand.
<br>
<b>Clash with altloc</b> - HOH clashes involving one or more alternate conformations may be resolved by renaming some of the alternates.
<br><br>
<b>High B-factor</b> - HOH with clashes and minimal support in the map should be removed from the model. This table does not report map data directly, but a high B-factor is a likely warning sign that an HOH is a poor fit to the map.
<br>
<b>Severe clash</b> - HOH with severe clash overlap but good map support is likely to be a position where an atom is displaced.
<br><br>
&ast;<i>Displaced atom</i> indicates that a structural atom has been moved from its proper place in the model and replaced by HOH. Displaced sidechains are common. Moved atoms may be restored by local rebuilding.
<br>
<i>Missing atoms</i> have been entirely replaced by HOH. Removed atoms may be restored by modeling alternate conformations (especially sidechains), modeling ligands, or continuing a macromolecular mainchain.
<br><br>
These categories are general suggestions. Check your electron density; trust your intuition and experience. Prisant 2020 Prot Sci 29:315 (<a href="https://doi.org/10.1002/pro.3786">https://doi.org/10.1002/pro.3786</a>) illustrates 10 examples of clashing HOH cases.
<br>
<hr>
<br>
"""

  html_table = """
<br><br>
<hr>
<br>
<table border=1 width='100%'>
<tr bgcolor='#9999cc'><td rowspan='1' align='center'>Water ID</td>
<td align='center'>Clashes with</td>
<td align='center'>Water B</td>
<td align='center'>Contact B</td>
<td align='center'>Clash<br>Severity</td>
<td align='center'>Clash with Polar<br><small>May be ion</small></td>
<td align='center'>Clash with non-polar<br><small>Unmodeled alt or noise</small></td>
<td align='center'>Clash with water<br><small>Occ &lt;1 or ligand</small></td>
<td align='center'>Clash with altloc<br><small>Add or rename alts</small></td></tr>
"""

  def get_result_class(self):
    return ud_water

  def __init__(self,
      probe_parameters,
      data_manager,
      keep_hydrogens=True,
      nuclear=False,
      outliers_only=False,
      force_unique_chain_ids=False,
      b_factor_cutoff=None,
      save_modified_hierarchy=False,
      verbose=False,
      do_flips=False,
      out=sys.stdout):
    validation.__init__(self)
    if verbose:
      if not nuclear:
        print("\nUsing electron cloud x-H distances and vdW radii")
      else:
        print("\nUsing nuclear cloud x-H distances and vdW radii")
    import iotbx.pdb
    from scitbx.array_family import flex
    from mmtbx.validation import utils

    data_manager_model = data_manager.get_model()
    # Fix up bogus unit cell when it occurs by checking crystal symmetry.
    # @todo reduce_hydrogens.py:run() says: TODO temporary fix until the code is moved to model class
    cs = data_manager_model.crystal_symmetry()
    if (cs is None) or (cs.unit_cell() is None):
      data_manager_model = shift_and_box_model(model = data_manager_model)

    # If we've been asked to, add hydrogens to all of the models in the PDB hierarchy
    # associated with our data_manager_model.
    data_manager_model,_ = check_and_add_hydrogen(
      probe_parameters=probe_parameters,
      data_manager_model=data_manager_model,
      nuclear=nuclear,
      verbose=verbose,
      keep_hydrogens=keep_hydrogens,
      do_flips = do_flips,
      log=null_out())

    # First we must rebuild the model from the new hierarchy so that the copy can succeed.
    # Make a copy of the original model to use for submodel processing, we'll trim atoms out
    # of it for each submodel.
    data_manager_model = mmtbx.model.manager(
      model_input       = None,
      pdb_hierarchy     = data_manager_model.get_hierarchy(),
      stop_for_unknowns = False,
      crystal_symmetry  = data_manager_model.crystal_symmetry(),
      restraint_objects = None,
      log               = null_out())
    original_model = data_manager_model.deep_copy()

    pdb_hierarchy = data_manager_model.get_hierarchy()
    n_models = len(pdb_hierarchy.models())
    use_segids = utils.use_segids_in_place_of_chainids(
                   hierarchy=pdb_hierarchy)

    # Get information about the waters in the model
    sel_cache = pdb_hierarchy.atom_selection_cache()
    water_sel= sel_cache.selection("water")
    hierarchy_waters = pdb_hierarchy.select(water_sel)
    self.water_count = len(list(hierarchy_waters.residue_groups()))
    water_xyzs = {}
    self.results_by_model = {}
    for atom in hierarchy_waters.atoms():
      if atom.name == " O  ":
        water_xyzs[atom.parent().parent().resid()] = atom.xyz
        model_id = atom.parent().parent().parent().parent().id
        if model_id not in self.n_total_by_model:
          self.n_total_by_model[model_id] = 0
        self.n_total_by_model[model_id] += 1

    for i_mod, model in enumerate(pdb_hierarchy.models()):
      if model.id not in self.results_by_model:
        self.results_by_model[model.id] = []
        self.n_outliers_by_model[model.id] = 0
      # Select only the current submodel from the hierarchy
      submodel = original_model.deep_copy()
      remove_models_except_index(submodel, i_mod)

      # Construct a hierarchy for the current submodel
      r = iotbx.pdb.hierarchy.root()
      mdc = submodel.get_hierarchy().models()[0].detached_copy()
      r.append_model(mdc)

      occ_max = flex.max(r.atoms().extract_occ())

      # Make yet another model for the new hierarchy
      subset_model_manager = mmtbx.model.manager(
        model_input       = None,
        pdb_hierarchy     = r,
        stop_for_unknowns = False,
        crystal_symmetry  = submodel.crystal_symmetry(),
        restraint_objects = None,
        log               = null_out())

      self.probe_undowser_manager = probe_undowser_manager(
        nuclear=nuclear,
        verbose=verbose,
        model_id=model.id)
      self.probe_undowser_manager.run_probe_undowser(data_manager, subset_model_manager)
      water_contacts = self.probe_undowser_manager.get_water_contacts()
      for src_atom_id, wc_list in water_contacts.items():
        src_chain_id=probe_undowser_manager.get_chain_probe_atom_id(src_atom_id)
        src_resseq=probe_undowser_manager.get_resseq_probe_atom_id(src_atom_id)
        src_icode=probe_undowser_manager.get_icode_probe_atom_id(src_atom_id)
        src_resname=probe_undowser_manager.get_resname_probe_atom_id(src_atom_id)
        src_altloc=probe_undowser_manager.get_altloc_probe_atom_id(src_atom_id)
        #selection_string = "model {} and chain {} and resseq '{}' and altid '{}' and name O".format(model.id, src_chain_id, src_resseq, src_altloc)
        result = ud_water(
          outlier=True,
          src_atom_id=src_atom_id,
          model_id=model.id,
          chain_id=src_chain_id,
          resseq=src_resseq,
          icode=src_icode,
          resname=src_resname,
          altloc=src_altloc,
          segid=None, # XXX ???
          xyz=water_xyzs[src_resseq+src_icode],
          contacts=wc_list,
        )
        #if (not outliers_only or is_outlier):
        self.results.append(result)
        self.results_by_model[model.id].append(result)
        self.n_outliers_by_model[model.id] += 1

  def as_JSON(self, addon_json={}):
    if not addon_json:
      addon_json = {}
    addon_json["validation_type"] = "undowser"
    data = addon_json
    flat_results = []
    hierarchical_results = {}
    summary_results = {}
    for result in self.results:
      flat_results.append(json.loads(result.as_JSON()))
      hier_result = json.loads(result.as_hierarchical_JSON())
      hierarchical_results = self.merge_dict(hierarchical_results, hier_result)

    data['flat_results'] = flat_results
    data['hierarchical_results'] = hierarchical_results

    for model_id in self.n_total_by_model.keys():
      summary_results[model_id] = { "num_outliers" : self.n_outliers_by_model[model_id],
        "num_waters" : self.n_total_by_model[model_id],
      }
    data['summary_results'] = summary_results
    return json.dumps(data, indent=2)

  def as_HTML(self):
    return self.as_html_table()

  #defaults to returning table corresponding to the first model, even if model_id isn't a valid input
  def as_html_table(self, model_id=""):
    if model_id not in self.results_by_model:
      model_id = sorted(self.results_by_model.keys())[0]
    model_results = self.results_by_model[model_id]
    #this could probably be more efficient, this recreates a "water_contacts" object to avoid changing CJW's original HTML code
    water_contacts = {}
    for ud_water in model_results:
      water_contacts[ud_water.src_atom_id]=ud_water.get_contacts()

    #water_contacts = self.probe_undowser_manager.get_water_contacts()
    html_string = self.html_header
    if self.water_count == 0:
      html_string = html_string+"SUMMARY: %i waters out of %i have clashes (%.2f%%)" % (0, 0, 0)
    else:
      html_string = html_string+"SUMMARY: %i waters out of %i have clashes (%.2f%%)" % (len(water_contacts), self.n_total_by_model[model_id], len(water_contacts)/self.n_total_by_model[model_id]*100)
    html_string = html_string + self.html_table

    contact_keys = sorted(water_contacts, key=lambda c: (-1*cumulative_severity(c, water_contacts)))
    #simple reverse sorting may put waters with the same cumulative severity in reverse sequence order

    row_number = 0
    row_color = ['#eaeaea','#ffffff']
    for contact_key in contact_keys:
      water = water_contacts[contact_key]
      water.sort(key=lambda w: (-1*float(w.mingap)))
      bgcolor = row_color[row_number%2]
      html_string = html_string+"<tr bgcolor=%s><td rowspan='%i' ><pre><code>%s</code></pre></td>\n" % (bgcolor,len(water),water[0].format_src_id_str())
      row_number+=1
      clashcount = 0
      for clash in water:
        if clashcount: html_string = html_string+'<tr bgcolor=%s>' % bgcolor
        clashcount+=1
        html_string = html_string+"<td><pre><code>%s</code></pre></td>%s%s<td bgcolor='%s'>%s</td>%s%s%s%s</tr>\n" % (clash.format_trg_id_str(), clash.write_b_cell(clash.src_b), clash.write_b_cell(clash.trg_b), clash.color_clash_severity(), clash.mingap, clash.write_polar_cell(), clash.write_nonpolar_cell(), clash.write_other_water_cell(), clash.write_altloc_cell())
    html_string = html_string+"</table>"
    return html_string
      #out.write("<td>%s</td><td bgcolor='%s'>%s</td><td>%s</td><td>%s</td><td>%s</td><td>%s</td></tr>\n" % (clash.format_trg_id_str(), clash.color_clash_severity(), clash.mingap,  clash.does_it_clash_with_altloc(), clash.does_it_clash_with_polar(), clash.does_it_clash_with_nonpolar(), clash.does_it_clash_with_other_water()))
      #out.write("<td>%s</td><td bgcolor='%s'>%s</td><td %s></td><td %s></td><td %s></td><td %s></td></tr>\n" % (clash.format_trg_id_str(), clash.color_clash_severity(), clash.mingap, color_cell(clash.does_it_clash_with_polar()), color_cell(clash.does_it_clash_with_nonpolar()), color_cell(clash.does_it_clash_with_other_water()), color_cell(clash.does_it_clash_with_altloc()) ))

    #tr-level bgcolors for alternating table stripes
    #bgcolor='#9999cc' (blue for column headers)
    #bgcolor='#ffffff' (white background)
    #bgcolor='#f0f0f0' (original gray for stripes)
    #bgcolor='#eaeaea' (slightly darker gray for stripes)

class water_contact(atoms):
  wc_slots = ["model_id",
    "src_atom_id",
    "src_chain",
    "src_resseq",
    "src_icode",
    "src_resname",
    "src_atom",
    "src_altloc",
    "trg_heavy_atom",
    "trg_chain",
    "trg_resseq",
    "trg_icode",
    "trg_resname",
    "trg_atom",
    "trg_altloc",
    "mingap",
    "src_b",
    "trg_b",
    "category",
    ]

  __slots__ = atoms.__slots__ + wc_slots

  def __init__(self, model_id, src_atom_id, trg_atom_id, trg_heavy_atom, mingap, src_b, trg_b):
    self.model_id = model_id
    self.src_atom_id = src_atom_id
    #self.trg_atom_id = trg_atom_id
    self.trg_heavy_atom = trg_heavy_atom
    # A2778 HOH  O  A
    self.atoms_info = []
    #ccnnnnirrr?aaaal
    self.src_chain = probe_undowser_manager.get_chain_probe_atom_id(src_atom_id)
    self.src_resseq = probe_undowser_manager.get_resseq_probe_atom_id(src_atom_id)
    self.src_icode = probe_undowser_manager.get_icode_probe_atom_id(src_atom_id)
    self.src_resname = probe_undowser_manager.get_resname_probe_atom_id(src_atom_id)
    self.src_atom = probe_undowser_manager.get_atom_probe_atom_id(src_atom_id)
    self.src_altloc = probe_undowser_manager.get_altloc_probe_atom_id(src_atom_id)
    self.atoms_info.append(atom_info(
      model_id=model_id,
      chain_id=self.src_chain,
      resseq=self.src_resseq,
      icode=self.src_icode,
      resname=self.src_resname,
      altloc=self.src_altloc,
      name=self.src_atom)
    )

    self.trg_chain = probe_undowser_manager.get_chain_probe_atom_id(trg_atom_id)
    self.trg_resseq = probe_undowser_manager.get_resseq_probe_atom_id(trg_atom_id)
    self.trg_icode = probe_undowser_manager.get_icode_probe_atom_id(trg_atom_id)
    self.trg_resname = probe_undowser_manager.get_resname_probe_atom_id(trg_atom_id)
    self.trg_atom = probe_undowser_manager.get_atom_probe_atom_id(trg_atom_id)
    self.trg_altloc = probe_undowser_manager.get_altloc_probe_atom_id(trg_atom_id)
    self.atoms_info.append(atom_info(
      model_id=model_id,
      chain_id=self.trg_chain,
      resseq=self.trg_resseq,
      icode=self.trg_icode,
      resname=self.trg_resname,
      altloc=self.trg_altloc,
      name=self.trg_atom)
    )

    self.mingap = mingap.lstrip('-')
    #main table lists all overlaps as positive
    #the simple strip works as long as we only look at clashes

    self.src_b = float(src_b)
    self.trg_b = float(trg_b)
    self.outlier = True
    self.score = 0.0
    self.category = self.get_category()

  def get_category(self):
    category = "uncategorized"
    if self.does_it_clash_with_polar():
      category = "polar clash"
    if self.does_it_clash_with_nonpolar():
      category = "nonpolar clash"
    if self.does_it_clash_with_other_water():
      category = "water clash"
    if self.does_it_clash_with_altloc():
      if category != "uncategorized":
        category = category + ", altloc clash"
      else:
        category = "altloc clash"
    return category

  def trg_is_H(self):
    if self.trg_atom.strip().startswith('H'): return True
    else: return False

  def trg_is_charged_N(self):
  #what N's can be charged in nucleic acids?
  #how to handle the great variety of ligands?
    if self.trg_resname == 'LYS' and self.trg_atom == ' NZ ':
      return True
    elif self.trg_resname == 'ARG' and self.trg_atom in [' NH1',' NH2']:
      return True
    elif self.trg_resname == 'HIS' and self.trg_atom in [' ND1',' NE2']:
      return True
    else:
      return False

  def format_src_id_str(self):
    return ":".join([self.src_chain,self.src_resseq+self.src_icode,self.src_resname,self.src_altloc])

  def format_trg_id_str(self):
    #return self.trg_heavy_atom+" of "+":".join([self.trg_chain,self.trg_resseq+self.trg_icode,self.trg_resname,self.trg_altloc])
    return self.trg_atom+" of "+":".join([self.trg_chain,self.trg_resseq+self.trg_icode,self.trg_resname,self.trg_altloc])

  def color_clash_severity(self):
    mingap = float(self.mingap)
    if mingap < 0.5: return '#ffb3cc'
    elif mingap > 0.9: return '#ee4d4d'
    else: return '#ff76a9'

  def does_it_clash_with_polar(self):
    #Polar atoms in proteins are O, N, and S
    #Nucleic acids also have P, but that appears completely shielded by O's
    #All O are polar.  Are any N sufficiently non-polar that they wouldn't coordinate with metal?
    #Another water does not count as polar for these purposes
    #Not currently considering what polar atoms might be in ligands
    if self.trg_resname == "HOH":
      return ''
    if self.trg_heavy_atom in ['O','S']:
      return True
    if self.trg_heavy_atom == 'N':
      if self.trg_is_H():
        return True #H on N is polar
      elif self.trg_is_charged_N():
        return True
    return ''

  def does_it_clash_with_altloc(self):
    #Goal is to find any clashes that might be resolved by different altloc naming
    #A-A clashes, A-_ clashes, and _-A clashes
    #Probe should automatically ignore any A-B contacts, since those are in fully different alts
    if self.src_altloc.strip() or self.trg_altloc.strip():
      return True
    else:
      return ''

  def does_it_clash_with_other_water(self):
    if self.trg_resname == "HOH":
      return True
    else:
      return ''

  def does_it_clash_with_nonpolar(self):
    #This is the most complex one and will likely receive iterations
    #Start with simple check for non-polars
    if self.trg_heavy_atom in ['C']:
      return True
    elif self.trg_is_H():
      if self.trg_heavy_atom in ['O','N','S']:
        return ''
      else:
        return True
    elif self.trg_heavy_atom in ['N']:
      if not self.trg_is_charged_N():
        return True
    return ''

  def write_polar_cell(self):
    if self.does_it_clash_with_polar():
      trg_element = self.trg_atom.strip()[0:1]
      if trg_element == 'H':
        return "<td align='center' bgcolor='%s'>&minus; ion</td>" % self.color_clash_severity()
      elif trg_element in ['O','S']:
        return "<td align='center' bgcolor='%s'>&plus; ion</td>" % self.color_clash_severity()
      elif trg_element == 'N':
        return "<td align='center' bgcolor='%s'>&minus; ion</td>" % self.color_clash_severity()
      else:
        return "<td align='center' bgcolor='%s'>*</td>" % self.color_clash_severity()
    else:
      return "<td></td>"

  def write_nonpolar_cell(self):
    if self.does_it_clash_with_nonpolar():
      return "<td align='center' bgcolor='%s'>&times;</td>" % self.color_clash_severity()
    else:
      return "<td></td>"

  def write_altloc_cell(self):
    if self.does_it_clash_with_altloc():
      if self.does_it_clash_with_other_water():
        return "<td align='center' bgcolor='%s'>alt water</td>" % self.color_clash_severity()
      elif self.src_altloc.strip() and self.trg_altloc.strip():
        return "<td align='center' bgcolor='%s'>alt both sides</td>" % self.color_clash_severity()
      elif self.src_altloc.strip():
        return "<td align='center' bgcolor='%s'>alt water</td>" % self.color_clash_severity()
      else:
        return "<td align='center' bgcolor='%s'>alt partner atom</td>" % self.color_clash_severity()
      #return "<td align='center' bgcolor='%s'>&times;</td>" % self.color_clash_severity()
    else:
      return "<td></td>"

  def write_other_water_cell(self):
    if self.does_it_clash_with_other_water():
      return "<td align='center' bgcolor='%s'>&times;</td>" % self.color_clash_severity()
    else:
      return "<td></td>"

  def write_b_cell(self, b):
    return "<td>%.2f</td>" % b

def cumulative_severity(contact_key, water_contacts):
  cumulative_severity = 0
  water = water_contacts[contact_key]
  for clash in water:
    weighted_severity = float(clash.mingap) - 0.2
    cumulative_severity += weighted_severity
  return cumulative_severity

def color_cell(clash_check):
  if clash_check: return 'bgcolor=#ff76a9'
  else: return ''

#this subclasses probe_clashscore_manager but doesn't really use most of it. It's mainly to reuse the code for checking for probe existance
class probe_undowser_manager(probe_clashscore_manager):
  def __init__(self,
               nuclear=False,
               verbose=False,
               model_id=""):
    super().__init__(
               fast = False,
               condensed_probe=False,
               nuclear=nuclear,
               largest_occupancy=10,
               b_factor_cutoff=None,
               use_segids=False,
               verbose=verbose,
               model_id=model_id)
    self.water_contacts = {}

  def run_probe_undowser(self, data_manager, hydrogenated_model):

    # Construct override parameters and then run probe2 using them and delete the resulting
    # temporary file.
    tempName = tempfile.mktemp()
    parser = iotbx.cli_parser.CCTBXParser(program_class=probe2.Program, logger=null_out())
    #self.probe_command = "%s -u -q -mc -het -con -once -wat2wat -stdbonds -onlybadout 'water' 'all' -" % (self.probe_command)
    args = [
      "source_selection='water'".format(self.occupancy_frac),
      "target_selection='all'".format(self.occupancy_frac),
      "use_neutron_distances={}".format(self.nuclear),
      "approach=once",
      "include_water_water=True",
      "output.filename='{}'".format(tempName),
      "output.format=raw",
      "output.condensed=True",
      "output.report_vdws=False",
      "output.report_hydrogen_bonds=False",
      "output.only_report_bad_clashes=True",
      "ignore_lack_of_explicit_hydrogens=True",
    ]
    parser.parse_args(args)
    p2 = probe2.Program(data_manager, parser.working_phil.extract(),
                       master_phil=parser.master_phil, logger=null_out())
    p2.overrideModel(hydrogenated_model)
    dots, output = p2.run()
    probe_unformatted = output.splitlines()
    os.unlink(tempName)
    #print("probe unformatted:"+str(probe_unformatted))

    for line in probe_unformatted:
#>>name:pat:type:srcAtom:targAtom:dot-count:min-gap:gap:spX:spY:spZ:spikeLen:score:stype:ttype:x:y:z:sBval:tBval
#SelfIntersect
#:1->2:bo: A2778 HOH  O  A: A 464 ARG  HD3 : 8:-0.581:-0.475: 36.509: 0.601: 18.650:0.238:-0.1485:O:C:36.622:0.786:18.552:30.97:17.73
#:1->2:bo: A2001 HOH  O  A: A2013 HOH  O  A:14:-0.792:-0.442:-12.858:17.914:-23.935:0.221:-0.1381:O:O:-12.726:18.090:-23.907:21.07:14.91
      n = line.split(':')
      contact_type = n[2]
      src_atom_id = n[3]
      trg_atom_id = n[4]
      dotcount = n[5]
      mingap = n[6]
      #src_heavy_atom = n[13] #always the water O
      trg_heavy_atom = n[14] #parent heavy atom of a clashing H
      #gap = n[7] #meaningless in -condensed mode, use mingap instead
      src_b = n[18]
      trg_b = n[19].strip()
      clash = water_contact(self.model_id, src_atom_id, trg_atom_id, trg_heavy_atom, mingap, src_b, trg_b)

      #sys.stdout.write(line)
      #sys.stdout.write('\n')
      polar_clash = clash.does_it_clash_with_polar()
      alt_clash = clash.does_it_clash_with_altloc()
      water_clash = clash.does_it_clash_with_other_water()
      nonpolar_clash = clash.does_it_clash_with_nonpolar()

      if src_atom_id not in self.water_contacts:
        self.water_contacts[src_atom_id] = []
      self.water_contacts[src_atom_id].append(clash)

  @staticmethod
  def get_chain_probe_atom_id(atom_id):
    if len(atom_id) == 16:
      return atom_id[0:2].strip()

  @staticmethod
  def get_resseq_probe_atom_id(atom_id):
    if len(atom_id) == 16:
      return atom_id[2:6]

  @staticmethod
  def get_icode_probe_atom_id(atom_id):
    if len(atom_id) == 16:
      return atom_id[6:7]

  @staticmethod
  def get_resname_probe_atom_id(atom_id):
    if len(atom_id) == 16:
      return atom_id[7:10]

  @staticmethod
  def get_atom_probe_atom_id(atom_id):
    if len(atom_id) == 16:
      return atom_id[11:15]

  @staticmethod
  def get_altloc_probe_atom_id(atom_id):
    if len(atom_id) == 16:
      return atom_id[15:16]

  def get_water_contacts(self):
    return self.water_contacts


 *******************************************************************************


 *******************************************************************************
mmtbx/validation/utils.py

from __future__ import absolute_import, division, print_function
from libtbx import easy_pickle
from libtbx import group_args
from libtbx.utils import Sorry
from collections import defaultdict
from iotbx.pdb import common_residue_names_get_class
import os.path
import math
import sys
from six.moves import range

def export_ramachandran_distribution(n_dim_table, scale_factor=0.25):
  """
  Convert a MolProbity Ramachandran distribution to a format suitable for
  display using matplotlib (see wxtbx.plots).
  """
  import numpy
  z = n_dim_table.lookupTable
  z_grid = [ [ z[i + (j * 180)] for j in range(180) ]
                          for i in range(180) ]
  npz = numpy.array(z_grid)
  return npz ** scale_factor

def export_rotamer_distribution(n_dim_table, scale_factor=0.5):
  """
  Convert a MolProbity rotamer distribution to a format suitable for
  display using matplotlib (see wxtbx.plots).  Will reduce dimensionality to
  2 if necessary.
  """
  import numpy
  z = n_dim_table.lookupTable
  n_dim = n_dim_table.nDim
  assert n_dim >= 2
  x_offset = 1
  for nbins in n_dim_table.nBins[1:] :
    x_offset *= nbins
  y_width = 1
  if n_dim > 2 :
    for nbins in n_dim_table.nBins[2:] :
      y_width *= nbins
  z_grid = [ [] for i in range(n_dim_table.nBins[1]) ]
  for i in range(n_dim_table.nBins[0]):
    for j in range(n_dim_table.nBins[1]):
      z_total = 0
      for k in range(y_width):
        z_total += z[(i * x_offset) + (j * y_width) + k]
      z_grid[j].append(z_total)
  npz = numpy.array(z_grid)
  return npz ** scale_factor

def get_rotarama_data(residue_type=None, pos_type=None, db="rama",
    convert_to_numpy_array=False):
  from mmtbx.rotamer import ramachandran_eval
  from mmtbx.rotamer.rotamer_eval import find_rotarama_data_dir
  # backwards compatibility
  if (pos_type == "proline") : pos_type = "trans-proline"
  if (pos_type == "prepro") : pos_type = "pre-proline"
  assert (pos_type in ["general", "cis-proline", "trans-proline", "glycine",
    "isoleucine or valine", "pre-proline",None])
  assert (db in ["rama", "rota"])
  assert (residue_type is not None) or (pos_type is not None)
  if pos_type is not None :
    residue_type = ramachandran_eval.aminoAcids_8000[pos_type]
  if residue_type.lower() in ["phe", "tyr"] :
    residue_type = "phetyr"
  assert (residue_type is not None)
  rama_data_dir = find_rotarama_data_dir()
  if (db == "rama"):
    pkl_file = "%s8000-%s.pickle" % (db, residue_type)
  else :
    pkl_file = "%s8000-%s.pickle" % (db, residue_type.lower())
  ndt = easy_pickle.load(os.path.join(rama_data_dir, pkl_file))
  if convert_to_numpy_array :
    if (db == "rama"):
      return export_ramachandran_distribution(ndt)
    else :
      return export_rotamer_distribution(ndt)
  else :
    return ndt

def decode_atom_str(atom_id):
  chain_id = atom_id[8:10].strip()
  if (chain_id == ""):
    chain_id = " "
  return group_args(
    name = atom_id[0:4],
    altloc = atom_id[4],
    resname = atom_id[5:8],
    chain_id = chain_id,
    resid = atom_id[10:],
    resseq = atom_id[10:-1].strip())

def find_sequence_mismatches(pdb_hierarchy,
                              sequences,
                              assume_same_order=True,
                              expected_sequence_identity=0.8,
                              log=sys.stdout):
  chains = pdb_hierarchy.models()[0].chains()
  chain_ids = []
  actual_seqs = []
  expected_seqs = []
  if (len(chains) != len(sequences)) or (not assume_same_order):
    print("Can't determine sequence->chain mapping autoamtically", file=log)
    print("Running sequence alignments. . .", file=log)
    from mmtbx.alignment import pairwise_global_wrapper
    for chain in chains :
      chain_seq = chain.as_padded_sequence()
      actual_seqs.append(chain_seq)
      chain_ids.append(chain.id)
      best_identity = 0
      best_sequence = None
      for sequence in sequences :
        pg = pairwise_global_wrapper(chain_seq, sequence)
        identity = pg.calculate_sequence_identity()
        if (identity >= expected_sequence_identity):
          if (identity >= best_identity):
            best_identity = identity
            best_sequence = sequence
      expected_seqs.append(best_sequence)
  mismatches = []

def molprobity_score(clashscore, rota_out, rama_fav):
  """
  Calculate the overall Molprobity score, as described here:
    http://www.ncbi.nlm.nih.gov/pmc/articles/PMC2877634/?tool=pubmed
    http://kinemage.biochem.duke.edu/suppinfo/CASP8/methods.html
  """
  if clashscore is not None and rota_out is not None and rama_fav is not None \
       and (clashscore >= 0) and (rota_out >= 0) and (rama_fav >= 0):
    rama_iffy = 100. - rama_fav
    mpscore = (( 0.426 * math.log(1 + clashscore) ) +
             ( 0.33 * math.log(1 + max(0, rota_out - 1)) ) +
             ( 0.25 * math.log(1 + max(0, rama_iffy - 2)) )) + 0.5
  else :
    return -1 # FIXME prevents crashing on RNA and None in inputs
  return mpscore

def use_segids_in_place_of_chainids(hierarchy, strict=False):
  use_segids = False
  for model in hierarchy.models():
    for chain in model.chains():
      if chain.id in [' ', '  ']:
        cur_segid = None
        for atom in chain.atoms():
          # new as of 20150203
          if atom.segid not in ['    ', '']:
            return True
          # It makes no sense to require indentical segID for
          # Chains with blank chainID. This was commented out by BJH on 20150203
          #if cur_segid is None:
          #  cur_segid = atom.segid
          #if atom.segid not in ['    ', '']:
          #  if atom.segid != cur_segid:
          #    if strict:
          #      raise Sorry("Chains with blank chainID may not have multiple"+
          #                  " segID values")
          #    else:
          #      return False
        #if len(cur_segid.strip()) > 0:
        #  use_segids = True
        #else:
        #  return False
  return use_segids

#this function assumes that use_segids_in_place_of_chainids() is True
def get_segid_as_chainid(chain):
  for atom in chain.atoms():
    return atom.segid

def get_rna_backbone_dihedrals(processed_pdb_file,
      geometry=None, pdb_hierarchy=None):
  # at present, this will only return measurements for angles arising from
  # atoms with altloc ' ' or altloc 'A'
  # TO-DO: extend to more alternates JJH 140108
  from cctbx import geometry_restraints
  bb_dihedrals = defaultdict(dict)
  formatted_out = []
  alt_tracker = {}
  if (processed_pdb_file is not None):
    sites_cart = processed_pdb_file.all_chain_proxies.sites_cart
    geometry = processed_pdb_file.geometry_restraints_manager()
    pdb_hierarchy = processed_pdb_file.all_chain_proxies.pdb_hierarchy
  else :
    assert (not None in [geometry, pdb_hierarchy])
    sites_cart = pdb_hierarchy.atoms().extract_xyz()
  dihedral_proxies = geometry.dihedral_proxies
  i_seq_name_hash = build_name_hash(pdb_hierarchy=pdb_hierarchy)

  def is_blank_or_alt_a(proxy):
    for i in proxy.i_seqs:
       alt = i_seq_name_hash[i][4:5]
       if alt not in [' ', 'A']:
         return False
    return True

  for dp in dihedral_proxies:
    atoms = []
    debug_key = ""
    invert_sign = False
    dp.sort_i_seqs()
    for i in dp.i_seqs:
      atoms.append(i_seq_name_hash[i][0:4].strip())
      debug_key = debug_key+i_seq_name_hash[i]
    if len(atoms) != 4:
      continue
    name = match_dihedral_to_name(atoms=atoms)
    #handle dihedral equivalences
    if name == None:
      inverted_atoms = get_inverted_atoms(atoms=atoms, improper=False)
      name = match_dihedral_to_name(atoms=inverted_atoms)
      if name == None:
        inverted_atoms = get_inverted_atoms(atoms=atoms, improper=True)
        name = match_dihedral_to_name(atoms=inverted_atoms)
        if name is not None:
          invert_sign = True
    if (name is not None) and (is_blank_or_alt_a(dp)):
      restraint = geometry_restraints.dihedral(
                                               sites_cart=sites_cart,
                                               proxy=dp)
      key = i_seq_name_hash[dp.i_seqs[1]][4:]
      if alt_tracker.get(key[1:]) is None:
        alt_tracker[key[1:]] = []
      if key[0:1] not in alt_tracker[key[1:]]:
        alt_tracker[key[1:]].append(key[0:1])
      bb_dihedrals[key][name] = restraint.angle_model
      if invert_sign:
        bb_dihedrals[key][name] = bb_dihedrals[key][name] * -1.0
  for key in list(bb_dihedrals.keys()):
    altloc = key[0:1]
    resname = key[1:4]
    chainID = key[4:6]
    resnum = key[6:10]
    i_code = key[10:]
    if 'A' in alt_tracker[key[1:]]:
      if altloc != 'A':
        continue
    if bb_dihedrals[key].get('alpha') is not None:
      alpha = "%.3f" % bb_dihedrals[key]['alpha']
    # FIXME will the lookup below ever actually work?
    elif altloc == 'A' and \
         bb_dihedrals[' '+key[1:]].get('alpha') is not None:
      alpha = "%.3f" % bb_dihedrals[' '+key[1:]]['alpha']
    else:
      alpha = '__?__'
    if bb_dihedrals[key].get('beta') is not None:
      beta = "%.3f" % bb_dihedrals[key]['beta']
    elif altloc == 'A' and \
         bb_dihedrals[' '+key[1:]].get('beta') is not None:
      beta = "%.3f" % bb_dihedrals[' '+key[1:]]['beta']
    else:
      beta = '__?__'
    if bb_dihedrals[key].get('gamma') is not None:
      gamma = "%.3f" % bb_dihedrals[key]['gamma']
    elif altloc == 'A' and \
         bb_dihedrals[' '+key[1:]].get('gamma') is not None:
      gamma = "%.3f" % bb_dihedrals[' '+key[1:]]['gamma']
    else:
      gamma = '__?__'
    if bb_dihedrals[key].get('delta'):
      delta = "%.3f" % bb_dihedrals[key]['delta']
    elif altloc == 'A' and \
         bb_dihedrals[' '+key[1:]].get('delta') is not None:
      delta = "%.3f" % bb_dihedrals[' '+key[1:]]['delta']
    else:
      delta = '__?__'
    if bb_dihedrals[key].get('epsilon'):
      epsilon = "%.3f" % bb_dihedrals[key]['epsilon']
    elif altloc == 'A' and \
         bb_dihedrals[' '+key[1:]].get('epsilon') is not None:
      epsilon = "%.3f" % bb_dihedrals[' '+key[1:]]['epsilon']
    else:
      epsilon = '__?__'
    if bb_dihedrals[key].get('zeta'):
      zeta = "%.3f" % bb_dihedrals[key]['zeta']
    elif altloc == 'A' and \
         bb_dihedrals[' '+key[1:]].get('zeta') is not None:
      zeta = "%.3f" % bb_dihedrals[' '+key[1:]]['zeta']
    else:
      zeta = '__?__'
    eval = "%s:%s:%s:%s:%s:%s:%s:%s:%s:%s:%s:%s:%s" \
           % (" ",
              "1",
              chainID,
              resnum,
              i_code,
              altloc,
              resname,
              alpha,
              beta,
              gamma,
              delta,
              epsilon,
              zeta)
    formatted_out.append(eval)
  formatted_out.sort()
  backbone_dihedrals = ""
  for line in formatted_out:
    backbone_dihedrals += line+'\n'
  return backbone_dihedrals

def get_inverted_atoms(atoms, improper=False):
  temp = []
  if not improper:
    temp.append(atoms[3])
    temp.append(atoms[2])
    temp.append(atoms[1])
    temp.append(atoms[0])
  else:
    temp.append(atoms[3])
    temp.append(atoms[1])
    temp.append(atoms[2])
    temp.append(atoms[0])
  return temp

def match_dihedral_to_name(atoms):
  name = None
  alpha = ["O3'","P","O5'","C5'"]
  beta = ["P","O5'","C5'","C4'"]
  gamma = ["O5'","C5'","C4'","C3'"]
  delta = ["C5'","C4'","C3'","O3'"]
  epsilon = ["C4'","C3'","O3'","P"]
  zeta = ["C3'","O3'","P","O5'"]
  if atoms == alpha:
    name = "alpha"
  elif atoms == beta:
    name = "beta"
  elif atoms == gamma:
    name = "gamma"
  elif atoms == delta:
    name = "delta"
  elif atoms == epsilon:
    name = "epsilon"
  elif atoms == zeta:
    name = "zeta"
  return name

def build_name_hash(pdb_hierarchy):
  i_seq_name_hash = dict()
  for atom in pdb_hierarchy.atoms():
    i_seq_name_hash[atom.i_seq]=atom.pdb_label_columns()
  return i_seq_name_hash

def get_mmtype_from_resname(resname):
  class_string = common_residue_names_get_class(resname)
  if "amino_acid" in class_string:
    return "PROTEIN"
  elif "rna_dna" in class_string:
    return "NA"
  else:
    return "OTHER"

def exercise():
  from libtbx.test_utils import approx_equal
  try :
    import numpy
  except ImportError :
    test_numpy = False
    print("Numpy not installed, will skip array conversion.")
  else :
    test_numpy = True
  # ramachandran
  z_data = get_rotarama_data(pos_type="general",
    convert_to_numpy_array=test_numpy)
  z_data = get_rotarama_data(pos_type="pre-proline",
    convert_to_numpy_array=test_numpy)
  # rotamer
  z_data = get_rotarama_data(residue_type="arg",
    db="rota",
    convert_to_numpy_array=test_numpy)
  z_data = get_rotarama_data(residue_type="phe",
    db="rota",
    convert_to_numpy_array=test_numpy)
  atom_info = decode_atom_str(" OD2 ASP A  14L")
  assert (atom_info.name == " OD2") and (atom_info.resname == "ASP")
  assert (atom_info.altloc == " ") and (atom_info.chain_id == "A")
  assert (atom_info.resid == "  14L") and (atom_info.resseq == "14")
  mpscore = molprobity_score(48.0, 9.95, 86.44) # 2hr0
  assert approx_equal(mpscore, 3.55, eps=0.01)
  mpscore = molprobity_score(215.8, 17.99, 52.18) # 3mku
  assert approx_equal(mpscore, 4.71, eps=0.01)

if __name__ == "__main__" :
  exercise()
  print("OK")


 *******************************************************************************


 *******************************************************************************
mmtbx/validation/validate_ligands.py
from __future__ import absolute_import, division, print_function

import time
from six.moves import cStringIO as StringIO
import iotbx.pdb
#import mmtbx.model

import libtbx.load_env
import cctbx.geometry_restraints.process_nonbonded_proxies as pnp
from cctbx import adptbx
from iotbx import phil
from cctbx.array_family import flex
from libtbx import group_args
from libtbx.str_utils import make_sub_header
from libtbx.utils import null_out
#from libtbx import easy_run
#from cctbx import miller
#from mmtbx import monomer_library
from mmtbx import real_space_correlation
#from mmtbx import map_tools
from elbow.command_line.ready_set import model_interface as ready_set_model_interface
from six.moves import zip


master_params_str = """
validate_ligands {

place_hydrogens = True
  .type = bool
  .help = Add H atoms with ready_set.

nproc = 1
  .type = int

}
"""


def master_params():
  return phil.parse(master_params_str, process_includes = False)


# =============================================================================


class manager(dict):
  '''
  Manager class for ALL ligands
  '''
  def __init__(self,
               model,
               fmodel,
               params,
               log=None):
    self.model = model
    self.params = params
    self.log   = log
    self.fmodel = fmodel
    #
    self.nproc = params.nproc

    if fmodel is not None:
      self.two_fofc_map = fmodel.map_coefficients(map_type="2mFo-DFc",
        fill_missing=False,
        merge_anomalous=True).fft_map(
          resolution_factor=0.25).apply_sigma_scaling().real_map_unpadded()
      self.fofc_map = fmodel.map_coefficients(map_type="mFo-DFc",
        fill_missing=False,
        merge_anomalous=True).fft_map(
          resolution_factor=0.25).apply_sigma_scaling().real_map_unpadded()
      self.fmodel_map = fmodel.map_coefficients(map_type="Fmodel",
        fill_missing=False,
        merge_anomalous=True).fft_map(
          resolution_factor=0.25).apply_sigma_scaling().real_map_unpadded()
    else:
      self.two_fofc_map = None
      self.fofc_map = None
      self.fmodel_map = None


  def parallel_populate(self, args):
    from libtbx import easy_mp
    def _run(lr, func):
      func = getattr(lr, func)
      rc = func()
      return rc
    funcs = []
    ligand_results = []
    inputs = []
    for id_tuple, rg, altloc, conformer_isel in args:
      id_list = list(id_tuple)
      id_list.append(altloc)
      lr = ligand_result(
        model = self.model,
        fmodel = self.fmodel,
        #readyset_model = self.readyset_model,
        two_fofc_map = self.two_fofc_map,
        fofc_map = self.fofc_map,
        fmodel_map = self.fmodel_map,
        isel = conformer_isel,
        id_list = id_list)
      ligand_results.append(lr)
      for attr, func in lr._result_attrs.items():
        funcs.append([lr, func])
        inputs.append([id_tuple, altloc, func])

    results = []
    t0=time.time()
    for i, (args, res, err_str) in enumerate(easy_mp.multi_core_run(
      _run,
      funcs,
      self.nproc,
      )):
      results.append([args, res, err_str])
      if self.nproc>1:
        print('\n  Returning Selection : %s AltLoc : %s Func : %s' % tuple(inputs[i]))
        print('  Cumulative time: %6.2f (s)' % (time.time()-t0))
      if err_str:
        print('Error output from %s' % args)
        print(err_str)
        print('_'*80)

    i=0
    for lr in ligand_results:
      for attr, func in lr._result_attrs.items():
        setattr(lr, attr, results[i][1])
        i+=1
    return ligand_results


  def run(self):
    #self.get_readyset_model_with_grm()
    args = []
    def _generate_ligand_isel():
      #done = []
      ph = self.model.get_hierarchy()
      ligand_isel_dict = self.get_ligands(ph = ph)
      for id_tuple, isel in ligand_isel_dict.items():
        for rg in ph.select(isel).residue_groups():
          ligand_dict = {}
          for conformer in rg.conformers():
            altloc = conformer.altloc
            #key = (id_tuple, altloc)
            #print (key)
            #if key in done: continue
            #done.append(key)
            conformer_isel = conformer.atoms().extract_i_seq()
            yield id_tuple, rg, altloc, conformer_isel
    for id_tuple, rg, altloc, conformer_isel in _generate_ligand_isel():
      args.append([id_tuple, rg, altloc, conformer_isel])
    results = self.parallel_populate(args)
    for lr, (id_tuple, rg, altloc, conformer_isel) in zip(results,
                                                          _generate_ligand_isel()):
      ligand_dict = self.setdefault(id_tuple, {})
      ligand_dict[altloc] = lr


#  def get_readyset_model_with_grm(self):
#    '''
#    Run ready set by default (to get ligand cif and/or add H atoms)
#    TODO: Once it it refactored, make running it optional
#          Complicated case is when cif is input for one ligand, but missing
#          for another ligand
#    '''
#    self.readyset_model = None
#    #if not self.model.has_hd():
#    if (self.params.place_hydrogens):
#      params=["add_h_to_water=False",
#               "optimise_final_geometry_of_hydrogens=False",
#               "--silent"]
#    else:
#      params=["add_h_to_water=False",
#              "hydrogens=False",
#              "optimise_final_geometry_of_hydrogens=False",
#              "--silent"]
#    assert (libtbx.env.has_module(name="reduce"))
#    assert (libtbx.env.has_module(name="elbow"))
#    # runs reduce internally
#    self.readyset_model = ready_set_model_interface(
#        model  = self.model,
#        params = params)
#    self.readyset_model.set_log(null_out())

  def get_ligands(self, ph):
    '''
    Store ligands as list of iselections --> better way? Careful if H will be
    added at some point!
    '''
    ligand_isel_dict = {}
    get_class = iotbx.pdb.common_residue_names_get_class
    exclude = ["common_amino_acid", "modified_amino_acid", "common_rna_dna",
               "modified_rna_dna", "ccp4_mon_lib_rna_dna", "common_water",
                "common_element"]
    for model in ph.models():
      for chain in model.chains():
        for rg in chain.residue_groups():
          for resname in rg.unique_resnames():
            if (not get_class(name=resname) in exclude):
              iselection = rg.atoms().extract_i_seq()
              id_tuple = (model.id, chain.id, rg.resseq)
              ligand_isel_dict[id_tuple] = iselection
              #print('here', list(iselection))
    return ligand_isel_dict


  def show_ligand_counts(self):
    make_sub_header(' Ligands in input model ', out=self.log)
    for id_tuple, ligand_dict in self.items():
      for altloc, lr in ligand_dict.items():
        print(lr.id_str, file=self.log)


  def show_adps(self):
    '''
    Show results for ADPs of ligand and surrounding atoms
    '''
    make_sub_header(' ADPs ', out=self.log)
    pad1 = ' '*18
    print(pad1, "min   max    mean   n_iso   n_aniso", file=self.log)
    for id_tuple, ligand_dict in self.items():
      for altloc, lr in ligand_dict.items():
        adps = lr.get_adps()
        print(lr.id_str.ljust(14), '%7s%7s%7s%7s%7s' %
          (round(adps.b_min,1), round(adps.b_max,1), round(adps.b_mean,1),
           adps.n_iso, adps.n_aniso), file = self.log)
        if (adps.b_mean_within is not None):
          print('neighbors'.ljust(14), '%7s%7s%7s' %
            (round(adps.b_min_within,1), round(adps.b_max_within,1),
             round(adps.b_mean_within,1) ), file = self.log)


  def show_ligand_occupancies(self):
    '''
    Show results for ligand occupancies
    '''
    make_sub_header(' Occupancies ', out=self.log)
    pad1 = ' '*20
    print('If three values: min, max, mean, otherwise the same occupancy for entire ligand.', \
      file=self.log)
    for id_tuple, ligand_dict in self.items():
      for altloc, lr in ligand_dict.items():
        occs = lr.get_occupancies()
        if (occs.occ_min == occs.occ_max):
          print(lr.id_str.ljust(16), occs.occ_min, file = self.log)
        else:
          print(lr.id_str.ljust(16), '%s   %s   %s' %
            (occs.occ_min, occs.occ_max, occs.occ_mean), file = self.log)


  def show_ccs(self):
    '''
    Show results for correlation coefficients
    '''
    if self.fmodel is None: return
    make_sub_header(' Correlation coefficients ', out=self.log)
    for id_tuple, ligand_dict in self.items():
      for altloc, lr in ligand_dict.items():
        ccs = lr.get_ccs()
        cc_two_fofc = round(ccs.cc_two_fofc, 2)
        cc_fofc = round(ccs.cc_fofc, 2)
        fofc_min  = round(ccs.fofc_min, 2)
        fofc_max  = round(ccs.fofc_max, 2)
        fofc_mean = round(ccs.fofc_mean, 2)
        print(lr.id_str.ljust(16),
          cc_two_fofc, cc_fofc, fofc_min, fofc_max, fofc_mean, file = self.log)


  def show_nonbonded_overlaps(self):
    '''
    Print results for overlaps
    '''
    for id_tuple, ligand_dict in self.items():
      for altloc, lr in ligand_dict.items():
        clashes_result = lr.get_overlaps()
        print(clashes_result.clashes_str, file=self.log)


# =============================================================================


class ligand_result(object):
  '''
  Class storing info per ligand
  '''
  def __init__(self,
               model,
               fmodel,
               #readyset_model,
               two_fofc_map,
               fofc_map,
               fmodel_map,
               isel,
               id_list):
    self.model = model
    self.fmodel = fmodel
    self.isel = isel
    #self.readyset_model = readyset_model
    self.two_fofc_map = two_fofc_map
    self.fofc_map = fofc_map
    self.fmodel_map = fmodel_map

    # results
    self._result_attrs = {'_occupancies' : 'get_occupancies',
                          '_adps'        : 'get_adps',
                          '_overlaps' : 'get_overlaps',
                          '_ccs'         : 'get_ccs'
    }
    for attr, func in self._result_attrs.items():
      setattr(self, attr, None)
      assert hasattr(self, func)
    # to be used internally
    self._ph = self.model.get_hierarchy()
    self._atoms = self._ph.select(self.isel).atoms()
    self._xrs = self.model.get_xray_structure()
    self._xrs_ligand = self.model.select(isel).get_xray_structure()
    self._get_id_str(id_list=id_list)


  def __repr__(self):
    outl = 'ligand %s\n' % self.id_str
    for attr in self._result_attrs:
      outl += '  %s : %s\n' % (attr, getattr(self, attr))
    return outl


  def _get_id_str(self, id_list):
    rg_ligand = self._ph.select(self.isel).only_residue_group()
    resname = ",".join(rg_ligand.unique_resnames())
    self.id_str = " ".join([id_list[0], id_list[1], resname, id_list[2], id_list[3]])
    self.sel_str = " ".join(['chain', id_list[1], 'and resseq', id_list[2]])
    if (id_list[0] != ''):
      self.sel_str = " ".join(['model', id_list[0], 'and', self.sel_str])
    if (id_list[3] != ''):
      self.sel_str = " ".join([self.sel_str, 'and altloc', id_list[3]])
    self.id_str = self.id_str.strip()


  def get_ccs(self):
    # still a stub
    if self.fmodel is None: return
    manager = real_space_correlation.selection_map_statistics_manager(
      atom_selection    = self.isel,
      xray_structure    = self._xrs,
      fft_m_real        = self.two_fofc_map.all(),
      fft_n_real        = self.two_fofc_map.focus(),
      exclude_hydrogens = True)
    stats_two_fofc = manager.analyze_map(
      map       = self.two_fofc_map,
      model_map = self.fmodel_map,
      min       = 1.5)
    stats_fofc = manager.analyze_map(
      map       = self.fofc_map,
      model_map = self.fmodel_map,
      min       = -3.0)

#    params = real_space_correlation.master_params().extract()
#
#    results = real_space_correlation.simple(
#      fmodel        = self.fmodel,
#      pdb_hierarchy = self._ph.select(self.isel),
#      params        = None,
#      show_results  = True,
#      log           = None)
#    params.map_2.type = 'mFobs-DFc'
#    sel_bool = self._ph.atom_selection_cache().selection(
#      string = self.sel_str)
#    self.fmodel.update_xray_structure(
#      xray_structure      = self._xrs.select(~sel_bool),
#      update_f_calc       = True,
#      update_f_mask       = True,
#      force_update_f_mask = True)
#    fmodel = mmtbx.f_model.manager(
#     f_obs          = self.fmodel.f_obs(),
#     r_free_flags   = self.fmodel.r_free_flags(),
#     xray_structure = self._xrs.select(~sel_bool))
#
#    fmodel.update_all_scales()
#    results_fofc = real_space_correlation.simple(
#      fmodel        = fmodel,
#      pdb_hierarchy = self._ph.select(self.isel),
#      params        = params,
#      show_results  = True,
#      log           = None)

#    mc_diff = map_tools.electron_density_map(
#      fmodel = self.fmodel).map_coefficients(
#        map_type         = "mFo-DFc",
#        isotropize       = True,
#        fill_missing     = False)
#    crystal_gridding =
#    fft_map = miller.fft_map(
#      crystal_gridding     = crystal_gridding,
#      fourier_coefficients = mc_diff)
#    fft_map.apply_sigma_scaling()
#    map_data = fft_map.real_map_unpadded()
#    box = mmtbx.utils.extract_box_around_model_and_map(
#      xray_structure = self._xrs.select(self.isel),
#      map_data       = map_data,
#      box_cushion    = 2.1)

    self._ccs = group_args(
      cc_two_fofc = stats_two_fofc.cc,
      cc_fofc = stats_fofc.cc,
      two_fofc_min = stats_two_fofc.min,
      two_fofc_max = stats_two_fofc.max,
      two_fofc_mean = stats_two_fofc.mean,
      fofc_min = stats_fofc.min,
      fofc_max = stats_fofc.max,
      fofc_mean = stats_fofc.mean,
      n_below_two_fofc_cutoff = stats_two_fofc.n_below_min,
      n_below_fofc_cutoff = stats_fofc.n_below_min
      )
    return self._ccs


  def get_adps(self):
    if self._adps is None:
      b_isos  = self._xrs_ligand.extract_u_iso_or_u_equiv() * adptbx.u_as_b(1.)
      n_iso   = self._xrs_ligand.use_u_iso().count(True)
      n_aniso = self._xrs_ligand.use_u_aniso().count(True)
      n_zero  = (b_isos < 0.01).count(True)
      # TODO: what number as cutoff?
      n_above_100 = (b_isos > 100).count(True)
      isel_above_100 = (b_isos > 100).iselection()
      b_min, b_max, b_mean = b_isos.min_max_mean().as_tuple()

      #if this selection is used somewhere else, it might be better to do it outside
      within_radius = 3.0 #TODO should this be a parameter?
      sel_within_str = '(within (%s, %s)) and (protein or water)' % (within_radius, self.sel_str)
      isel_within = self.model.iselection(sel_within_str)
      xrs_within = self._xrs.select(isel_within)
      b_isos_within = xrs_within.extract_u_iso_or_u_equiv() * adptbx.u_as_b(1.)
      b_min_within, b_max_within, b_mean_within = b_isos_within.min_max_mean().as_tuple()

      self._adps = group_args(
        n_iso          = n_iso,
        n_aniso        = n_aniso,
        n_zero         = n_zero,
        n_above_100    = n_above_100,
        isel_above_100 = isel_above_100,
        b_min          = b_min,
        b_max          = b_max,
        b_mean         = b_mean,
        b_min_within   = b_min_within,
        b_max_within   = b_max_within,
        b_mean_within  = b_mean_within
        )
    return self._adps


  def get_occupancies(self):
    if self._occupancies is None:
      eps = 1.e-6
      occ = self._atoms.extract_occ()
      mmm = occ.min_max_mean()
      occ_min = mmm.min
      occ_max = mmm.max
      occ_mean = mmm.mean
      negative_count = (occ<0).count(True)
      negative_isel = (occ<0).iselection()
      zero_count = (flex.abs(occ)<eps).count(True)
      zero_isel = (flex.abs(occ)<eps).iselection()
      less_than_dot9_isel = (occ<0.9).iselection()

      self._occupancies = group_args(
      occ_min             = occ_min,
      occ_max             = occ_max,
      occ_mean            = occ_mean,
      negative_count      = negative_count,
      negative_isel       = negative_isel,
      zero_count          = zero_count,
      zero_isel           = zero_isel,
      less_than_dot9_isel = less_than_dot9_isel
      )

    return self._occupancies


  def get_overlaps(self):
    '''
    Obtain overlaps involving ligands
    '''
    # A model with H atoms is necessary to process overlaps
    #if not self.readyset_model.has_hd():
    if not self.model.has_hd():
      return None
    elif self._overlaps is None:
      # sel_within could be done in __init__?
      within_radius = 3.0
      # TODO clashes with other ligands?
      sel_within_str = '%s or (residues_within (%s, %s)) and (protein or water)' \
        % (self.sel_str, within_radius, self.sel_str)
      sel_within = self.model.selection(sel_within_str)
      isel_ligand_within = self.model.select(sel_within).iselection(self.sel_str)
      #sel = flex.bool([True]*len(sel_within))
      model_within = self.model.select(sel_within)

      processed_nbps = pnp.manager(model = model_within)
      clashes = processed_nbps.get_clashes()
      clashes_dict   = clashes._clashes_dict

      ligand_clashes_dict = dict()
      for iseq_tuple, record in clashes_dict.items():
        if (iseq_tuple[0] in isel_ligand_within or
            iseq_tuple[1] in isel_ligand_within):
          ligand_clashes_dict[iseq_tuple] = record

      ligand_clashes = pnp.clashes(
                      clashes_dict = ligand_clashes_dict,
                      model        = model_within)

      string_io = StringIO()
      ligand_clashes.show(log=string_io, show_clashscore=False)
      results = ligand_clashes.get_results()

      self._overlaps = group_args(
        n_clashes      = results.n_clashes,
        clashscore     = results.clashscore,
        n_clashes_sym  = results.n_clashes_sym,
        clashscore_sym = results.clashscore_sym,
        clashes_str    = string_io.getvalue(),
        clashes_dict   = clashes._clashes_dict)

    return self._overlaps


 *******************************************************************************


 *******************************************************************************
mmtbx/validation/waters.py

from __future__ import absolute_import, division, print_function
from cctbx import maptbx, miller
from cctbx.sgtbx import space_group_info
from iotbx.file_reader import any_file
from mmtbx.validation import atom, atom_info, validation
from mmtbx.validation import experimental
from libtbx.str_utils import format_value
import sys

class water(atom):
  """
  Container for information about a water atom, including electron density
  properties.
  """

  __slots__ = atom.__slots__ + experimental.__real_space_attr__ + [
    "anom",
    "nearest_contact",
    "nearest_atom",
    "n_hbonds",
    "fmodel"
  ]

  @property
  def cc(self):
    return self.score

  @staticmethod
  def header():
    return "%-20s  %6s  %4s  %6s  %6s  %6s  %5s" % ("atom", "b_iso", "occ",
      "2Fo-Fc", "Fo-Fc", "Anom", "CC")

  def id_str(self):
    return "%2s%4s%1s%1s %-4s" % (self.chain_id, self.resseq, self.icode,
      self.altloc, self.name)

  def as_string(self, prefix="", highlight_if_heavy=False):
    flag = ""
    if highlight_if_heavy and self.is_heavy_atom():
      flag = " ***"
    return "%-20s  %6.2f  %4.2f  %6.2f  %6.2f  %s  %5.3f%s" % (
      self.id_str(), self.b_iso, self.occupancy, self.two_fofc, self.fofc,
      format_value("%6.2f", self.anom, replace_none_with="---"), self.cc, flag)

  def is_bad_water(self):
    return ((self.cc < 0.8) or (self.fofc < -3.0) or (self.occupancy < 0.5)
            or (self.two_fofc < 1.0))

  def is_heavy_atom(self):
    return ((self.fofc is not None and self.fofc > 3.0)
            or (self.anom is not None and self.anom > 3.0)
            or (self.b_iso is not None and self.b_iso == 0))

  def as_table_row_phenix(self):
    return [ self.id_str(), self.b_iso, self.occupancy, self.two_fofc,
             self.fmodel, self.score]

class waters(validation):
  """
  Assess the properties of solvent atoms, including local environment and
  electron density.
  """

  __slots__ = validation.__slots__ + ["n_bad", "n_heavy"]

  def get_result_class(self) : return water

  def __init__(self, pdb_hierarchy, xray_structure, fmodel,
                distance_cutoff=4.0, collect_all=True,
                molprobity_map_params=None):
    validation.__init__(self)
    from mmtbx.real_space_correlation import extract_map_stats_for_single_atoms
    from cctbx import adptbx
    from scitbx.matrix import col
    self.n_bad = 0
    self.n_heavy = 0
    pdb_atoms = pdb_hierarchy.atoms()
    if(len(pdb_atoms)>1):
      assert (not pdb_atoms.extract_i_seq().all_eq(0))
    unit_cell = xray_structure.unit_cell()
    pair_asu_table = xray_structure.pair_asu_table(
      distance_cutoff = distance_cutoff)
    asu_mappings = pair_asu_table.asu_mappings()
    asu_table = pair_asu_table.table()
    u_isos = xray_structure.extract_u_iso_or_u_equiv()
    occupancies = xray_structure.scatterers().extract_occupancies()
    sites_frac = xray_structure.sites_frac()
    sel_cache = pdb_hierarchy.atom_selection_cache()
    water_sel = sel_cache.selection("water")

    if (molprobity_map_params is not None):
      # assume parameters have been validated (symmetry of pdb and map matches)
      two_fofc_map = None
      fc_map = None
      d_min = None
      crystal_gridding = None

      # read two_fofc_map
      if (molprobity_map_params.map_file_name is not None):
        f = any_file(molprobity_map_params.map_file_name)
        two_fofc_map = f.file_object.map_data()
        d_min = molprobity_map_params.d_min
        crystal_gridding = maptbx.crystal_gridding(
          f.file_object.unit_cell(),
          space_group_info=space_group_info(f.file_object.space_group_number),
          pre_determined_n_real=f.file_object.unit_cell_grid)

        pdb_atoms = pdb_hierarchy.atoms()
        xray_structure = pdb_hierarchy.extract_xray_structure(
          crystal_symmetry=f.crystal_symmetry())
        unit_cell = xray_structure.unit_cell()
        # check for origin shift
        # ---------------------------------------------------------------------
        soin = maptbx.shift_origin_if_needed(
          map_data         = two_fofc_map,
          sites_cart       = xray_structure.sites_cart(),
          crystal_symmetry = xray_structure.crystal_symmetry())
        two_fofc_map   = soin.map_data
        xray_structure.set_sites_cart(soin.sites_cart)
        # ---------------------------------------------------------------------
        pair_asu_table = xray_structure.pair_asu_table(
          distance_cutoff = distance_cutoff)
        asu_mappings = pair_asu_table.asu_mappings()
        asu_table = pair_asu_table.table()
        u_isos = xray_structure.extract_u_iso_or_u_equiv()
        occupancies = xray_structure.scatterers().extract_occupancies()
        sites_frac = xray_structure.sites_frac()
        sel_cache = pdb_hierarchy.atom_selection_cache()
        water_sel = sel_cache.selection("water")

      elif (molprobity_map_params.map_coefficients_file_name is not None):
        f = any_file(molprobity_map_params.map_coefficients_file_name)
        fourier_coefficients = f.file_server.get_miller_array(
          molprobity_map_params.map_coefficients_label)
        crystal_symmetry = fourier_coefficients.crystal_symmetry()
        d_min = fourier_coefficients.d_min()
        crystal_gridding = maptbx.crystal_gridding(
          crystal_symmetry.unit_cell(), d_min, resolution_factor=0.25,
          space_group_info=crystal_symmetry.space_group_info())
        two_fofc_map = miller.fft_map(
          crystal_gridding=crystal_gridding,
          fourier_coefficients=fourier_coefficients).apply_sigma_scaling().\
          real_map_unpadded()

      # calculate fc_map
      assert( (d_min is not None) and (crystal_gridding is not None) )
      f_calc = xray_structure.structure_factors(d_min=d_min).f_calc()
      fc_map = miller.fft_map(crystal_gridding=crystal_gridding,
                              fourier_coefficients=f_calc)
      fc_map = fc_map.apply_sigma_scaling().real_map_unpadded()

      map_stats = extract_map_stats_for_single_atoms(
        pdb_atoms=pdb_atoms,
        xray_structure=xray_structure,
        fmodel=None,
        selection=water_sel,
        fc_map=fc_map,
        two_fofc_map=two_fofc_map)
    else:
      map_stats = extract_map_stats_for_single_atoms(
        pdb_atoms=pdb_atoms,
        xray_structure=xray_structure,
        fmodel=fmodel,
        selection=water_sel)
    waters = []
    for i_seq, atom in enumerate(pdb_atoms):
      if (water_sel[i_seq]):
        rt_mx_i_inv = asu_mappings.get_rt_mx(i_seq, 0).inverse()
        self.n_total += 1
        asu_dict = asu_table[i_seq]
        nearest_atom = nearest_contact = None
        for j_seq, j_sym_groups in asu_dict.items():
          atom_j = pdb_atoms[j_seq]
          site_j = sites_frac[j_seq]
          # Filter out hydrogens
          if atom_j.element.upper().strip() in ["H", "D"]:
            continue
          for j_sym_group in j_sym_groups:
            rt_mx = rt_mx_i_inv.multiply(asu_mappings.get_rt_mx(j_seq,
              j_sym_group[0]))
            site_ji = rt_mx * site_j
            site_ji_cart = xray_structure.unit_cell().orthogonalize(site_ji)
            vec_i = col(atom.xyz)
            vec_ji = col(site_ji_cart)
            dxyz = abs(vec_i - vec_ji)
            if (nearest_contact is None) or (dxyz < nearest_contact):
              nearest_contact = dxyz
              nearest_atom = atom_info(pdb_atom=atom_j, symop=rt_mx)
        w = water(
          pdb_atom=atom,
          b_iso=adptbx.u_as_b(u_isos[i_seq]),
          occupancy=occupancies[i_seq],
          nearest_contact=nearest_contact,
          nearest_atom=nearest_atom,
          score=map_stats.two_fofc_ccs[i_seq],
          fmodel=map_stats.fmodel_values[i_seq],
          two_fofc=map_stats.two_fofc_values[i_seq],
          fofc=map_stats.fofc_values[i_seq],
          anom=map_stats.anom_values[i_seq],
          n_hbonds=None) # TODO
        if (w.is_bad_water()):
          w.outlier = True
          self.n_bad += 1
        elif (w.is_heavy_atom()):
          w.outlier = True
          self.n_heavy += 1
        if (w.outlier) or (collect_all):
          self.results.append(w)
    self.n_outliers = len(self.results)

  def show_summary(self, out=sys.stdout, prefix="  "):
    if (self.n_bad > 0):
      print("%sPoorly ordered waters:  %4d" % (prefix, self.n_bad), file=out)
    if (self.n_heavy > 0):
      print("%sMislabeled waters:      %4d" % (prefix, self.n_heavy), file=out)
    if (self.n_bad == 0) and (self.n_heavy == 0):
      print("%sAll waters okay." % prefix, file=out)

  def show(self, out=sys.stdout, prefix="  ", verbose=True):
    if (len(self.results) > 0):
      if (self.n_bad > 0):
        print(prefix + "Waters in poor density:", file=out)
        print(prefix + self.get_result_class().header(), file=out)
        for result in self.results :
          if (result.is_bad_water()):
            print(prefix + str(result), file=out)
        print("", file=out)
      if (self.n_heavy > 0):
        print(prefix + "Possibly mislabeled atoms:", file=out)
        print(prefix + self.get_result_class().header(), file=out)
        for result in self.results :
          if (result.is_heavy_atom()):
            print(prefix + str(result), file=out)
        print("", file=out)
    self.show_summary(out=out, prefix=prefix)


 *******************************************************************************
