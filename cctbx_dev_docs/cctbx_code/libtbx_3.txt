

 *******************************************************************************
libtbx/file_clutter.py
from __future__ import absolute_import, division, print_function
from libtbx.command_line import find_unused_imports_crude
from libtbx.utils import to_unicode
import sys, os
import re

class file_clutter(object):

  from_future_pat = re.compile(
    '^ from [ ]+ __future__ ', re.VERBOSE)
  from_future_import_division_pat = re.compile(
    r'^ from [ ]+ __future__ [ ]+ import [ \w,]+ division', re.VERBOSE)
  from_future_import_absolute_import_pat = re.compile(
    r'^ from [ ]+ __future__ [ ]+ import [ \w,]+ absolute_import', re.VERBOSE)
  from_future_import_print_function_pat = re.compile(
    r'^ from [ ]+ __future__ [ ]+ import [ \w,]+ print_function', re.VERBOSE)

  def __init__(self, path, find_unused_imports=False,
      find_bad_indentation=True, flag_absolute_import=False,
      flag_print_function=False):
    self.path = path
    self.is_executable = os.access(path, os.X_OK)
    self.dos_format = False
    self.n_tabs_or_trailing_whitespace = []
    self.n_trailing_empty_lines = 0
    self.missing_eol = False
    self.n_bare_excepts = 0
    self.unused_imports = None
    self.n_from_future_import_division = -1
    self.flag_absolute_import = flag_absolute_import
    self.n_from_future_import_absolute_import = -1
    self.flag_print_function = flag_print_function
    self.n_from_future_import_print_function = -1
    self.bad_indentation = None
    self.file_should_be_empty = False

    if self.ignore_file():
      return

    bytes = to_unicode(open(path, "rb").read())
    if (len(bytes) > 0):
      if (bytes[-1] != "\n"):
        self.missing_eol = True
      else:
        bytes = bytes[:-1]
      text = bytes.split("\n")
      for i, line in enumerate(text):
        if (line.endswith("\r")):
          line = line[:-1]
          self.dos_format = True
        clean_line = line.expandtabs().rstrip()
        if (clean_line != line): self.n_tabs_or_trailing_whitespace.append(i+1)
        if (len(clean_line) == 0): self.n_trailing_empty_lines += 1
        else: self.n_trailing_empty_lines = 0
      if (path.endswith(".py")):
        self.n_from_future_import_division = 0
        self.n_from_future_import_absolute_import = 0
        self.n_from_future_import_print_function = 0
        py_lines = bytes.splitlines()
        self.file_should_be_empty = True
        for line in py_lines:
          if self.file_should_be_empty and line.strip() != '' and not self.from_future_pat.search(line):
            self.file_should_be_empty = False
          if self.from_future_import_division_pat.search(line):
            self.n_from_future_import_division += 1
          if self.from_future_import_absolute_import_pat.search(line):
            self.n_from_future_import_absolute_import += 1
          if self.from_future_import_print_function_pat.search(line):
            self.n_from_future_import_print_function += 1
          ls = line.strip()
          if (    ls.startswith("except")
              and ls[6:].strip().startswith(":")
              and not ls.endswith(" # intentional")):
            self.n_bare_excepts += 1
        if (find_unused_imports and path.endswith(".py")):
          self.unused_imports = find_unused_imports_crude.inspect(
            py_lines=py_lines)
        if (find_bad_indentation):
          self.bad_indentation = detect_indentation_problems(path)

  def ignore_file(self):
    root = os.path.dirname(self.path)
    ignore_path = os.path.join(root, ".clutterignore")
    if not os.path.exists(ignore_path):
      return False
    with open(ignore_path) as f:
      for line in f:
        if len(line) == 0: continue
        if line.startswith('#'): continue
        if os.path.basename(self.path) == line.strip():
          return True
    return False

  def is_cluttered(self, flag_x):
    return ((self.is_executable and flag_x)
            or self.dos_format
            or len(self.n_tabs_or_trailing_whitespace) > 0
            or self.n_trailing_empty_lines > 1
            or self.missing_eol
            or self.bad_indentation)

  def has_unused_imports(self):
    return (self.unused_imports is not None and len(self.unused_imports) != 0)

  def status(self, flag_x, flag_dos_format=True, flag_indentation=False):
    status = []
    sapp = status.append
    if (self.is_executable and flag_x
        and self.path.lower().find("command_line") < 0
        and not self.path.endswith(".csh")
        and not self.path.endswith(".sh")):
      sapp("is executable")
    if (flag_dos_format and self.dos_format):
      sapp("dos format")
    if (len(self.n_tabs_or_trailing_whitespace) > 0):
      line = "tabs or trailing whitespace=%d" % \
        len(self.n_tabs_or_trailing_whitespace)
      for cnt, i in enumerate(self.n_tabs_or_trailing_whitespace):
        line += ", #" + str(i)
        if cnt >= 9:
          break
      sapp(line)
    if (self.n_trailing_empty_lines > 1):
      sapp("trailing empty lines=%d" % self.n_trailing_empty_lines)
    if (self.missing_eol):
      sapp("missing end-of-line")
    if (self.n_bare_excepts > 0):
      sapp("bare excepts=%d" % self.n_bare_excepts)
    if (self.has_unused_imports()):
      sapp("unused imports=%d" % len(self.unused_imports))
    if self.file_should_be_empty:
      if self.n_from_future_import_division == 0 and self.n_from_future_import_absolute_import == 0 and \
         self.n_from_future_import_print_function:
        sapp("file is empty, should be 0 byte file")
      else:
        sapp("file contains only 'from __future__ import' and should be empty instead")
    elif self.n_from_future_import_division == 0:
      sapp("missing 'from __future__ import division'")
    elif self.n_from_future_import_division > 1:
      sapp("more than one appearance of 'from __future__ import division'")
    if self.flag_absolute_import and not self.file_should_be_empty:
      if self.n_from_future_import_absolute_import == 0:
        sapp("missing 'from __future__ import absolute_import'")
      elif self.n_from_future_import_absolute_import > 1:
        sapp("more than one appearance of 'from __future__ import absolute_import'")
    if self.flag_print_function and not self.file_should_be_empty:
      if self.n_from_future_import_print_function == 0:
        sapp("missing 'from __future__ import print_function'")
      elif self.n_from_future_import_print_function > 1:
        sapp("more than one appearance of 'from __future__ import print_function'")
    if (self.bad_indentation is not None) and (flag_indentation):
      n_tab, n_space = self.bad_indentation
      sapp("non-standard indentation: %d space, %d tab" % (n_space, n_tab))
    return ", ".join(status)

  def show(self, flag_x, flag_dos_format=True, append=None, verbose=False,
      flag_indentation=False):
    status = self.status(flag_x, flag_dos_format, flag_indentation)
    if status:
      msg = "%s: %s" % (self.path, status)
      if append:
        append(msg)
      else:
        print(msg)
      if (verbose) and (self.has_unused_imports()):
        msg2 = "  unused imports: %s" % ", ".join(self.unused_imports)
        if append:
          append(msg2)
        else :
          print(msg2)

def is_text_file(file_name):
  name = file_name.lower()
  for extension in (".c", ".cpp", ".h", ".hpp", ".py", ".java", ".params",
                    ".dox", ".txt", ".html", ".csh", ".sh", ".cif", ".cc",
                    '.mol2', '.frcmod',
                    ):
    if (name.endswith(extension)): return True
  return False

def gather(paths, find_unused_imports=False, find_bad_indentation=False, flag_absolute_import=False, flag_print_function=False):
  clutter = []
  def capp():
    clutter.append(file_clutter(path, find_unused_imports,
      find_bad_indentation=find_bad_indentation, flag_absolute_import=flag_absolute_import,
      flag_print_function=flag_print_function))
  for path in paths:
    if (not os.path.exists(path)):
      print("No such file or directory:", path, file=sys.stderr)
    elif (os.path.isfile(path)):
      capp()
    else:
      for root, dirs, files in os.walk(path):
        for f in sorted(files):
          if (is_text_file(f)):
            path = os.path.normpath(os.path.join(root, f))
            capp()
  return clutter

def detect_indentation_problems(file_name):
  try :
    import indent_finder
  except ImportError :
    return None
  fi = indent_finder.IndentFinder()
  fi.clear()
  fi.parse_file(file_name)
  result = fi.results()
  if (result is fi.default_result):
    return None
  itype, ival = result
  n_tab = n_space = 0
  if (itype != "mixed"):
    if (itype == "space"):
      n_space = ival
    else :
      n_tab = ival
    if (n_tab == 0) and (n_space == 2) : # this is our "standard"
      return None
    return (n_tab, n_space)
  else :
    return ival
  return None


 *******************************************************************************


 *******************************************************************************
libtbx/find_reference_cycles.py
from __future__ import absolute_import, division, print_function
from types import FrameType
from six.moves import cStringIO as StringIO
import gc
import sys

# =============================================================================
# This method is written by Michael Droettboom and is found at
#
#   http://code.activestate.com/recipes/523004/
#
# -----------------------------------------------------------------------------
def print_cycles(objects, outstream=sys.stdout, show_progress=False):
    """
    objects:       A list of objects to find cycles in.  It is often useful
                   to pass in gc.garbage to find the cycles that are
                   preventing some objects from being garbage collected.
    outstream:     The stream for output.
    show_progress: If True, print the number of objects reached as they are
                   found.
    """
    def print_path(path):
        for i, step in enumerate(path):
            # next "wraps around"
            next = path[(i + 1) % len(path)]

            outstream.write("   %s -- " % str(type(step)))
            if isinstance(step, dict):
                for key, val in step.items():
                    if val is next:
                        outstream.write("[%s]" % repr(key))
                        break
                    if key is next:
                        outstream.write("[key] = %s" % repr(val))
                        break
            elif isinstance(step, list):
                outstream.write("[%d]" % step.index(next))
            elif isinstance(step, tuple):
                outstream.write("[%d]" % list(step).index(next))
            else:
                outstream.write(repr(step))
            outstream.write(" ->\n")
        outstream.write("\n")

    def recurse(obj, start, all, current_path):
        if show_progress:
            outstream.write("%d\r" % len(all))

        all[id(obj)] = None

        referents = gc.get_referents(obj)
        for referent in referents:
            # If we've found our way back to the start, this is
            # a cycle, so print it out
            if referent is start:
                print_path(current_path)

            # Don't go back through the original list of objects, or
            # through temporary references to the object, since those
            # are just an artifact of the cycle detector itself.
            elif referent is objects or isinstance(referent, FrameType):
                continue

            # We haven't seen this object before, so recurse
            elif id(referent) not in all:
                recurse(referent, start, all, current_path + [obj])

    for obj in objects:
        outstream.write("Examining: %r\n" % obj)
        recurse(obj, obj, { }, [])

# =============================================================================
# test for print_cycles
# -----------------------------------------------------------------------------
def exercise():

  class bad_class(object):

    def __init__(self):
      self.a = self.b

    def b():
      return 1+2

  t = bad_class()
  sio = StringIO()
  print_cycles([t],outstream=sio)
  lines = sio.getvalue().splitlines()

  # 'Examining: <__main__.bad_class object at 0xb7eb5d2c>'
  # "   <class '__main__.bad_class'> -- <__main__.bad_class object at 0xb7eb5d2c> ->"
  # "   <type 'dict'> --  ->"
  # ''
  # For Python 3.11, the <type 'dict'> line is missing
  if sys.version_info.major == 3 and sys.version_info.minor >= 11:
    assert len(lines) == 3
  else:
    assert len(lines) == 4
  assert lines[0].startswith("Examining: <")
  assert lines[0].count("bad_class") == 1
  assert lines[1].count("bad_class") == 2
  if sys.version_info.major == 3 and sys.version_info.minor < 11:
    assert lines[2].count("dict") == 1

  print("OK")

# =============================================================================
if (__name__ == "__main__"):
  exercise()


 *******************************************************************************


 *******************************************************************************
libtbx/forward_compatibility.py
from __future__ import absolute_import, division, print_function
import sys
import os

_vers_info = sys.version_info[:2]

class newobject(object):
  """
  A magical object class that provides Python 2 compatibility methods::
      next
      __unicode__
      __nonzero__

  Subclasses of this class can merely define the Python 3 methods (__next__,
  __str__, and __bool__).
  """
  # verbatim copy of builtin.object from future package + __slots__ fix
  # cf https://github.com/PythonCharmers/python-future
  #    https://github.com/PythonCharmers/python-future/pull/337

  def next(self):
      if hasattr(self, '__next__'):
          return type(self).__next__(self)
      raise TypeError('newobject is not an iterator')

  def __unicode__(self):
      # All subclasses of the builtin object should have __str__ defined.
      # Note that old-style classes do not have __str__ defined.
      if hasattr(self, '__str__'):
          s = type(self).__str__(self)
      else:
          s = str(self)
      if isinstance(s, unicode):
          return s
      else:
          return s.decode('utf-8')

  def __nonzero__(self):
      if hasattr(self, '__bool__'):
          return type(self).__bool__(self)
      if hasattr(self, '__len__'):
          return type(self).__len__(self)
      # object has no __nonzero__ method
      return True

  # Are these ever needed?
  # def __div__(self):
  #     return self.__truediv__()

  # def __idiv__(self, other):
  #     return self.__itruediv__(other)

  def __long__(self):
      if not hasattr(self, '__int__'):
          return NotImplemented
      return self.__int__()  # not type(self).__int__(self)

  # def __new__(cls, *args, **kwargs):
  #     """
  #     dict() -> new empty dictionary
  #     dict(mapping) -> new dictionary initialized from a mapping object's
  #         (key, value) pairs
  #     dict(iterable) -> new dictionary initialized as if via:
  #         d = {}
  #         for k, v in iterable:
  #             d[k] = v
  #     dict(**kwargs) -> new dictionary initialized with the name=value pairs
  #         in the keyword argument list.  For example:  dict(one=1, two=2)
  #     """

  #     if len(args) == 0:
  #         return super(newdict, cls).__new__(cls)
  #     elif type(args[0]) == newdict:
  #         return args[0]
  #     else:
  #         value = args[0]
  #     return super(newdict, cls).__new__(cls, value)

  def __native__(self):
      """
      Hook for the future.utils.native() function
      """
      return object(self)

  __slots__ = []

if _vers_info < (3,0):
  # export newobject as object
  object = newobject
  del newobject
  try:
    # If builtins exists, monkeypatch it.
    import builtins
    builtins.object = object
  except ImportError:
    # builtins may be missing, eg. in case of running an installer script
    pass
else:
  object = object # Statement required to export the name

class _advertise_subprocess(object):

  def __init__(self, function_id, target):
    self.function_id = function_id
    self.target = target

  def __call__(self, *args, **kwargs):
    if ("LIBTBX_BUILD" in os.environ):
      import libtbx.load_env
      if (   libtbx.env.full_testing
          or libtbx.env.is_development_environment()):
        def is_exception():
          from sys import _getframe
          frames_back = 1
          while True:
            try: f = _getframe(frames_back)
            except ValueError: break
            else:
              p = f.f_code.co_filename
              while True:
                d,b = os.path.split(p)
                if (len(d) == 0 or len(b) == 0): break
                b = b.lower()
                if (   b.startswith("python")
                    or b == "lib"):
                  if (not os.path.isdir(p)): # non-existing path names in .pyc
                    return True              # simply give up to avoid noise
                  for n in ["os","StringIO","UserDict","UserList","UserString"]:
                    if (not os.path.isfile(os.path.join(p, n+".py"))):
                      break
                  else:
                    return True
                elif (b == "scons"):
                  if (os.path.isfile(os.path.join(p, "SConsign.py"))):
                    return True
                p = d
              frames_back += 1
          return False
        if (not is_exception()):
          from warnings import warn
          warn(
            message="%s is not safe: please use the subprocess module"
                    " or libtbx.easy_run instead." % self.function_id,
            stacklevel=2)
    return self.target(*args, **kwargs)

def _install_advertise_subprocess():
  for fn in ["system",
             "popen", "popen2", "popen3", "popen4",
             "spawnl", "spawnle", "spawnlp", "spawnlpe",
             "spawnv", "spawnve", "spawnvp", "spawnvpe"]:
    f = getattr(os, fn, None)
    if (f is not None):
      w = _advertise_subprocess(function_id="os."+fn+"()", target=f)
      setattr(os, fn, w)

if _vers_info < (3,0):
  _install_advertise_subprocess()


 *******************************************************************************


 *******************************************************************************
libtbx/introspection.py
from __future__ import absolute_import, division, print_function
from libtbx import Auto
from libtbx import group_args
import os
import sys

def varnames(frames_back=0):
  f_code = sys._getframe(frames_back+1).f_code
  return f_code.co_varnames[:f_code.co_argcount]

class caller_location(object):

  def __init__(self, frames_back=0):
    f = sys._getframe(frames_back+1)
    self.file_name = f.f_code.co_filename
    self.line_number = f.f_lineno

  def __str__(self):
    return "%s(%d)" % (self.file_name, self.line_number)

def check_point(frames_back=0):
  print(caller_location(frames_back=frames_back+1))
  sys.stdout.flush()

def show_stack(
      max_frames_back=None,
      frames_back=0,
      reverse=False,
      out=None,
      prefix=""):
  if (out is None): out = sys.stdout
  lines = []
  try:
    while True:
      if (max_frames_back is not None and frames_back == max_frames_back):
        break
      f = sys._getframe(frames_back+1)
      lines.append(prefix+"show_stack(%d): %s(%d) %s" % (
        frames_back, f.f_code.co_filename, f.f_lineno, f.f_code.co_name))
      frames_back += 1
  except ValueError:
    pass
  if (reverse): lines.reverse()
  if (out == "return_lines"):
    return lines
  for line in lines:
    print(line, file=out)

def show_stack_true_stderr():
  sys.__stdout__.flush()
  show_stack(out=sys.__stderr__, frames_back=1)
  sys.__stderr__.flush()

def print_trace(frame, event, arg):
  if (event == "line"):
    sys.stderr.flush()
    print("%s(%d)" % (frame.f_code.co_filename, frame.f_lineno))
    sys.stdout.flush()
  return print_trace

def start_print_trace():
  if ("pydoc" in sys.modules):
    from six.moves import cStringIO as StringIO
    s = StringIO()
    show_stack(out=s)
    for line in s.getvalue().splitlines():
      if (line.find("pydoc.py") >= 0 and line.endswith(" cli")):
        print("libtbx.introspection.start_print_trace():" \
          " pydoc.cli() detected: no tracing")
        return
  sys.settrace(print_trace)

def stop_print_trace():
  sys.settrace(None)

kb_exponents = {
  "KB": 1,
  "MB": 2,
  "GB": 3,
  "TB": 4,
  "PB": 5}

class proc_file_reader(object):

  def get_bytes(self, vm_key):
    if (self.proc_status is None):
      return None
    try:
      i = self.proc_status.index(vm_key)
    except ValueError:
      return None
    flds = self.proc_status[i:].split(None, 3)
    if (len(flds) < 3):
      return None
    exponent = kb_exponents.get(flds[2].upper())
    try:
      num = int(flds[1])
    except ValueError:
      return None
    return num * 1024**exponent

try:
  _proc_status = "/proc/%d/status" % os.getpid()
except AttributeError:
  _proc_status = None

class virtual_memory_info(proc_file_reader):

  have_vmpeak = False
  max_virtual_memory_size = 0
  max_resident_set_size = 0
  max_stack_size = 0

  def __init__(self):
    try:
      with open(_proc_status) as f:
        self.proc_status = f.read()
    except IOError:
      self.proc_status = None

  def virtual_memory_peak_size(self):
    result = self.get_bytes('VmPeak:')
    if (result is not None):
      virtual_memory_info.have_vmpeak = True
      virtual_memory_info.max_virtual_memory_size = max(
        virtual_memory_info.max_virtual_memory_size, result)
    return result

  def virtual_memory_size(self):
    result = self.get_bytes('VmSize:')
    if (result is not None):
      virtual_memory_info.max_virtual_memory_size = max(
        virtual_memory_info.max_virtual_memory_size, result)
    return result

  def resident_set_size(self):
    result = self.get_bytes('VmRSS:')
    if (result is not None):
      virtual_memory_info.max_resident_set_size = max(
        virtual_memory_info.max_resident_set_size, result)
    return result

  def stack_size(self):
    result = self.get_bytes('VmStk:')
    if (result is not None):
      virtual_memory_info.max_stack_size = max(
        virtual_memory_info.max_stack_size, result)
    return result

  def update_max(self):
    if (self.proc_status is not None):
      self.virtual_memory_peak_size()
      self.virtual_memory_size()
      self.resident_set_size()
      self.stack_size()

  def show(self, out=None, prefix="", show_max=False):
    if (out is None): out = sys.stdout
    from libtbx.str_utils import size_as_string_with_commas
    vms = size_as_string_with_commas(self.virtual_memory_size())
    rss = size_as_string_with_commas(self.resident_set_size())
    sts = size_as_string_with_commas(self.stack_size())
    fmt = "%%%ds" % max(len(vms), len(rss), len(sts))
    lvms = prefix + "Virtual memory size:"
    lrss = prefix + "Resident set size:  "
    lsts = prefix + "Stack size:         "
    if (not show_max):
      print(lvms, fmt % vms, file=out)
      print(lrss, fmt % rss, file=out)
      print(lsts, fmt % sts, file=out)
    else:
      self.virtual_memory_peak_size()
      vmi = virtual_memory_info
      max_vms = size_as_string_with_commas(vmi.max_virtual_memory_size)
      max_rss = size_as_string_with_commas(vmi.max_resident_set_size)
      max_sts = size_as_string_with_commas(vmi.max_stack_size)
      max_fmt = "%%%ds" % max(len(max_vms), len(max_rss), len(max_sts))
      if (vmi.have_vmpeak):
        vms_what_max = "    exact max:"
      else:
        vms_what_max = "  approx. max:"
      print(lvms, fmt % vms, vms_what_max,     max_fmt % max_vms, file=out)
      print(lrss, fmt % rss, "  approx. max:", max_fmt % max_rss, file=out)
      print(lsts, fmt % sts, "  approx. max:", max_fmt % max_sts, file=out)

  def show_if_available(self, out=None, prefix="", show_max=False):
    if (self.proc_status is not None):
      self.show(out=out, prefix=prefix, show_max=show_max)

  def current_max_sizes_legend(self):
    return ("Virtual memory", "Resident set", "Stack")

  def current_max_sizes(self):
    return group_args(
      virtual_memory=self.max_virtual_memory_size,
      resident_set=self.max_resident_set_size,
      stack=self.max_stack_size)

def get_mac_os_x_memory_total():
  cmd = "/usr/sbin/system_profiler"
  if not os.path.isfile(cmd):
    return None
  from libtbx import easy_run
  for line in easy_run.fully_buffered(
                command=cmd+" SPHardwareDataType").stdout_lines:
    line = line.strip()
    if (not line.startswith("Memory:")):
      continue
    flds = line.split()
    if (len(flds) != 3):
      continue
    try:
      num = int(flds[1])
    except ValueError:
      continue
    if (num <= 0):
      continue
    exponent = kb_exponents.get(flds[2].upper())
    if (exponent is None):
      continue
    return num * 1024**exponent
  return None

class machine_memory_info(proc_file_reader):

  def __init__(self):
    self.proc_status = None
    self._memory_total = Auto
    self._memory_free = Auto
    if os.path.isfile("/proc/meminfo"):
      try:
        with open("/proc/meminfo") as fh:
          self.proc_status = fh.read()
      except IOError:
        pass
    else:
      self._memory_total = get_mac_os_x_memory_total()
      self._memory_free = None

  def memory_total(self):
    result = self._memory_total
    if (result is Auto):
      result = self._memory_total = self.get_bytes("MemTotal:")
    return result

  def memory_free(self):
    result = self._memory_free
    if (result is Auto):
      result = self._memory_free = self.get_bytes("MemFree:")
    return result

  def show(self, out=None, prefix=""):
    if (out is None): out = sys.stdout
    from libtbx.str_utils import size_as_string_with_commas
    mt = size_as_string_with_commas(self.memory_total())
    mf = size_as_string_with_commas(self.memory_free())
    fmt = "%%%ds" % max(len(mt), len(mf))
    print(prefix+"Memory total: ", fmt % mt, file=out)
    print(prefix+"Memory free:  ", fmt % mf, file=out)

_number_of_processors = Auto

def number_of_processors(return_value_if_unknown=None):
  global _number_of_processors
  if (_number_of_processors is Auto):
    _number_of_processors = None
    try: import multiprocessing
    except ImportError: pass
    else:
      try: n = multiprocessing.cpu_count()
      except NotImplementedError: pass
      else:
        _number_of_processors = n
    if (_number_of_processors is None):
      try: import boost_adaptbx.boost.python as bp
      except ImportError: pass
      else:
        n = bp.ext.number_of_processors()
        if (n != 0):
          _number_of_processors = n
    if (_number_of_processors is None):
      cpuinfo = "/proc/cpuinfo" # Linux
      if os.path.isfile(cpuinfo):
        n = 0
        with open(cpuinfo) as fh:
          for line in fh.read().splitlines():
            if (not line.startswith("processor")): continue
            line = line[9:].replace(" ", "").replace("\t", "")
            if (not line.startswith(":")): continue
            n += 1
        if (n != 0):
          _number_of_processors = n
    if (_number_of_processors is None):
      cmd = "/usr/sbin/system_profiler" # Mac OS X
      if os.path.isfile(cmd):
        keys = [
          "Total Number Of Cores: ",
          "Number Of CPUs: ",
          "Number Of Processors: "]
        ns = [None] * len(keys)
        from libtbx import easy_run
        for line in easy_run.fully_buffered(
                      command=cmd+" SPHardwareDataType").stdout_lines:
          line = line.strip()
          for i,key in enumerate(keys):
            if (line.startswith(key)):
              try: n = int(line[len(key):])
              except ValueError: continue
              if (n > 0 and ns[i] is None):
                ns[i] = n
        for n in ns:
          if (n is not None):
            _number_of_processors = n
            break
    if (_number_of_processors is None):
      n = os.environ.get("NUMBER_OF_PROCESSORS") # Windows
      if (n is not None):
        try: n = int(n)
        except ValueError: pass
        else: _number_of_processors = n
    if (_number_of_processors is None):
      cmd = "/sbin/hinv" # IRIX
      if os.path.isfile(cmd):
        from libtbx import easy_run
        for line in easy_run.fully_buffered(command=cmd).stdout_lines:
          if (line.endswith(" Processors")):
            try: n = int(line.split(" ", 1)[0])
            except ValueError: continue
            if (n > 0):
              _number_of_processors = n
              break
  if (_number_of_processors is not None):
    return _number_of_processors
  return return_value_if_unknown

class method_debug_log(object):
  """For Python 2.4 or greater.  Use an instance of this class as a
  decorator for class methods, and it will print the call signature and
  call location before the method is executed.

  Example:
  debug = libtbx.introspection.method_debug_log()
  class a(object):
    @debug
    def foo(self, x):
      print x

  def main():
    my_object = a()
    a.foo(1)
  main()

  Running this results in the following output when LIBTBX_DEBUG_LOG is set:
a.foo(1) @ test.py(13) main
1
  """
  def __init__(self):
    self.debug = False
    if os.environ.get("LIBTBX_DEBUG_LOG") is not None :
      self.debug = True

  def __call__(self, f):
    def log_wrapper(O, *args, **kwds):
      if self.debug :
        _args = list(args)
        _kwds = dict(kwds)
        str_args = ", ".join([ str(arg) for arg in _args ])
        str_kwds = ", ".join([ "%s=%s" % (kwd, str(val))
                               for kwd, val in _kwds.items() ])
        call_signature = []
        if str_args != "" : call_signature.append(str_args)
        if str_kwds != "" : call_signature.append(str_kwds)
        caller = sys._getframe(1)
        print("%s.%s(%s) @ %s(%d) %s" % (O.__class__.__name__, f.__name__,
          ", ".join(call_signature), caller.f_code.co_filename,
          caller.f_lineno, caller.f_code.co_name))
        sys.stdout.flush()
      return f(O, *args, **kwds)
    return log_wrapper


class current_process_status(object):
  """
  An interface to the *NIX utility 'ps' to get info on the current process
  (only tested on MacOS X till further notice, so beware dragons)

  SYNOPSIS:
    ps = current_process_status() # <1>
    .....
    print ps['RSS'] # resident size at the time of <1>
    .....
    ps.refresh() # <2>
    .....
    print ps['%CPU'] # % CPU at the time of <2>
  """
  conversions = {
    'RSS': int,
    'VSZ': int,
    '%CPU': float,
    }

  def __init__(self):
    self.id = str(os.getpid())
    self.refresh()

  def refresh(self):
    import subprocess
    ps = subprocess.Popen(
      args=['/bin/ps', 'cux'],
      stderr=subprocess.STDOUT,
      stdout=subprocess.PIPE)
    cols = dict(
      [ (field, i) for i, field in enumerate(ps.stdout.readline().split()) ])
    i_pid = cols['PID']
    for li in ps.stdout:
      field = li.split()
      if field[i_pid] == self.id: break
    else:
      return
    self.field = dict(
      [ (name, field[i_col]) for name, i_col in cols.items() ])
    for name, conv in self.conversions.items():
      self.field[name] = conv(self.field[name])

  def __getitem__(self, field_name):
    return self.field[field_name]

def getfullargspec(function):
  '''
  Wrapper for importing getfullargspec
  '''
  import inspect
  if sys.version_info[0] == 3:
    return inspect.getfullargspec(function)
  else:
    return inspect.getargspec(function)

if (__name__ == "__main__"):
  def exercise_varnames(a, b, c):
    d = 0
    return varnames()
  assert exercise_varnames(1,2,3) == ("a", "b", "c")
  #
  assert _number_of_processors is Auto
  print("number of processors:", number_of_processors(
    return_value_if_unknown="unknown"))
  assert _number_of_processors is not Auto
  assert number_of_processors() is _number_of_processors
  #
  virtual_memory_info().show()
  buffer = [0]*1000000
  virtual_memory_info().update_max()
  del buffer
  virtual_memory_info().show(show_max=True)
  #
  machine_memory_info().show()
  #
  assert str(caller_location()).find("introspection") > 0
  #
  print("OK")


 *******************************************************************************


 *******************************************************************************
libtbx/libtbx_refresh.py
from __future__ import absolute_import, division, print_function

import os
import shutil

import libtbx.load_env
from libtbx.version import create_version_files

# try creating version files again
# this should already be done by bootstrap.py, but try anyway
# this will fail if git is not available
filenames = []
try:
  filenames = create_version_files()
except Exception:
  pass

# copy version file and header to build directory
try:
  shutil.copy(filenames[0], abs(libtbx.env.build_path))
  cctbx_include = libtbx.env.under_build('include/cctbx')
  if not os.path.exists(cctbx_include):
    os.mkdir(cctbx_include)
  shutil.copy(filenames[1], cctbx_include)
except Exception:
  pass


 *******************************************************************************


 *******************************************************************************
libtbx/load_env.py
from __future__ import absolute_import, division, print_function
import libtbx
import libtbx.env_config
import os
libtbx.env = libtbx.env_config.unpickle()
libtbx.env.set_os_environ_all_dist()
libtbx.env.dispatcher_name = os.environ.get("LIBTBX_DISPATCHER_NAME")
if not libtbx.env.dispatcher_name:
  # Attempt to identify dispatcher name if LIBTBX_DISPATCHER_NAME is not set
  try:
    import inspect
    _frame = inspect.stack()[1]
    _module = inspect.getmodule(_frame[0])
    _sourcefile = os.path.realpath(_module.__file__)
    for _dist_path in [os.path.realpath(_d) for _d in libtbx.env.dist_paths()]:
      if _sourcefile.startswith(_dist_path):
        _command = '.'.join([ _dist_path.split(os.path.sep)[-1] ] + list(filter(lambda x: x and x != 'command_line', _sourcefile[len(_dist_path):].split(os.path.sep))))
        for _ext in ('.pyo', '.pyc', '.py'):
          if _command.endswith(_ext):
            _command = _command[:-len(_ext)]
        libtbx.env.dispatcher_name = _command
        break
  except Exception: # intentional
    pass # If anything goes wrong - give up silently

libtbx.env.full_testing = os.environ.get("LIBTBX_FULL_TESTING") is not None


 *******************************************************************************


 *******************************************************************************
libtbx/log.py
"""A simple logging interface."""
from __future__ import absolute_import, division, print_function
import logging
import sys

class manager(object):
  def __init__(self, log=None):
    self.log      = log
    self.messages = []
    self.prefix   = ""

  def set_prefix(self, prefix):
    self.prefix=prefix

  def add(self, msg):
    msg = "%s%s"%(self.prefix, msg)
    self.messages.append(msg)

  def add_and_show(self, msg):
    self.add(msg)
    self.show_last()

  def show(self):
    print(msg, file=self.log)

  def show_last(self):
    if len(self.messages)>0:
      print(self.messages[-1], file=self.log)

  def show_all(self):
    for msg in self.messages:
      print(msg, file=self.log)


class logger(object):
  """A basic wrapper over Python standard library logging module.

  This class is designed to be used as a logging singleton, with a few
  basic convenience methods:
    set_quiet       Suppress output except errors.
    set_logfile     Set an output log file.
    set_stdout      Set log output to stdout.

  It may also be written to as a file-like object.

  Examples:

  # Basic usage
  >>> import libtbx.log
  >>> libtbx.log.info("Helpful message")

  # Write as a file handle
  >>> print >> libtbx.log.logger, "As file handle"

  # Set debug, or quiet states
  >>> libtbx.log.logger.set_debug(True)
  >>> libtbx.log.debug("Debugging output.")
  >>> libtbx.log.logger.set_quiet(True)
  >>> libtbx.log.info("This should be muted.")

  # Output file
  >>> libtbx.log.logger.set_logfile("test.log")
  >>> libtbx.log.info("Redirected to test.log")

  # Experimental sys.stdout redirection
  >>> libtbx.log.logger.set_logfile("test.log")
  >>> sys.stdout = libtbx.log.logger
  >>> print "stdout redirection to test.log"

  """

  def __init__(self):
    # create logger
    self.log = logging.getLogger('phenix')
    self.log.setLevel(logging.INFO)

    # create formatter
    self.formatter = logging.Formatter()

    # Default is to print to stdout
    self.ch = None
    self.set_stdout()

  def write(self, data):
    self.log.info(data)

  def flush(self):
    try:
      self.ch.flush()
    except Exception:
      pass

  def close(self):
    try:
      self.ch.close()
    except Exception:
      pass

  def set_quiet(self, state=True):
    level = logging.INFO
    if state:
      level = logging.ERROR
    self.log.setLevel(level)

  def set_debug(self, state=True):
    level = logging.INFO
    if state:
      level = logging.DEBUG
    self.log.setLevel(level)

  def set_logfile(self, filename, mode='w'):
    ch = logging.FileHandler(filename, mode=mode)
    ch.setFormatter(self.formatter)
    if self.ch:
      self.log.removeHandler(self.ch)
    self.log.addHandler(ch)
    self.ch = ch

  def set_fileobj(self, fileobj):
    pass

  def set_stdout(self):
    ch = logging.StreamHandler()
    ch.setFormatter(self.formatter)
    if self.ch:
      self.log.removeHandler(self.ch)
    self.log.addHandler(ch)
    self.ch = ch

# Singleton
logger = logger()

# Set the module functions.
log = logger.log.info
debug = logger.log.debug
info = logger.log.info
warn = logger.log.warn
error = logger.log.error
critical = logger.log.critical

##### Testing #####

import unittest
class TestLog(unittest.TestCase):
  def test_f(self):
    logger.set_debug(True)
    tests = [debug, info, warn, error, critical]
    for test in tests:
      logger.set_logfile("test.log")
      value = "test %s"%test
      test(value)
      logger.flush()
      logger.close()
      with open("test.log") as f:
        data = f.read()
        assert value in data

  def test_debug(self):
    print("Check set_debug")
    logger.set_logfile("test.log")
    logger.set_debug(False)
    debug("debug: muted")
    logger.set_debug(True)
    debug("debug: ok")
    logger.set_debug(False)
    with open("test.log") as f:
      data = f.read()
      assert "muted" not in data
      assert "ok" in data

  def test_quiet(self):
    print("Check set_quiet")
    logger.set_logfile("test.log")
    logger.set_quiet(False)
    info("quiet: ok")
    logger.set_quiet(True)
    info("quiet: muted")
    logger.set_quiet(False)
    with open("test.log") as f:
      data = f.read()
      assert "muted" not in data
      assert "ok" in data

  def test_logfile(self):
    print("Check output file")
    logger.set_logfile("test.log")
    info("logfile: ok")
    with open("test.log") as f:
      data = f.read()
      assert "ok" in data

  def test_stdout(self):
    oldsys = sys.stdout
    print("Checking sys.stdout redirect")
    sys.stdout = logger
    print("redirect: ok")
    sys.stdout = oldsys
    print("... and back again")

if __name__ == "__main__":
  unittest.main(verbosity=0)


 *******************************************************************************


 *******************************************************************************
libtbx/math_utils.py
from __future__ import absolute_import, division, print_function
from builtins import object
import math
from scitbx import matrix
from six.moves import range

def cmp(x, y):
  """
  cmp(x, y) -> integer

  Return negative if x<y, zero if x==y, positive if x>y.
  """
  return (x > y) - (x < y)

def round2(x, d=0):
  '''
  Python 3 defaults to rounding to the nearest even number (round half to even),
  so this function keeps the Python 2 behavior, which is rounding half away
  from zero.

  References:
  https://docs.python.org/3.7/library/functions.html#round
  https://en.wikipedia.org/wiki/Rounding#Round_half_to_even

  https://docs.python.org/2.7/library/functions.html#round
  https://en.wikipedia.org/wiki/Rounding#Round_half_away_from_zero

  Function from:
  http://python3porting.com/differences.html#rounding-behavior
  '''
  p = 10 ** d
  if x > 0:
    return float(math.floor((x * p) + 0.5))/p
  else:
    return float(math.ceil((x * p) - 0.5))/p

def roundoff(val, precision=3, as_string=False):
  '''
  round off all floats in a list (or tuple) of list (or tuples)
  recursively using round2() defined above as in:
  >>> math_utils.roundoff( [12.3454, 7.4843, ["foo", (35.3581, -0.3856, [4.2769, 3.2147] )] ])
  [12.345, 7.484, ['foo', (35.358, -0.386, [4.277, 3.215])]]
  If value is less than 10**-precision or greater than 10**precision then return with scientific notation
  '''
  if isinstance(val, float):
    if math.isnan(val):
      return float("nan")
    if abs(val) < float("1e-%d" %precision) or abs(val) > float("9e%d" %precision):
      fstr = "%" + "%d" %precision
      fstr += ".%de" %precision
      val2str = fstr %val
      if as_string:
        return val2str
      return float(val2str)
    return round2(val, precision)
  if isinstance(val, list):
    for i,v in enumerate(val):
      val[i] = roundoff(v, precision)
  if isinstance(val, tuple):
    val = list(val)
    for i,v in enumerate(val):
      val[i] = roundoff(v, precision)
    val = tuple(val)
  if isinstance(val,  matrix.sqr):
    val = list(val)
    for i,v in enumerate(val):
      val[i] = roundoff(v, precision)
    val =  matrix.sqr(val)
  if isinstance(val,  matrix.rec):
    valn = val.n
    val = list(val)
    for i,v in enumerate(val):
      val[i] = roundoff(v, precision)
    val =  matrix.rec(elems=val, n=valn)
  return val

def iround(x):
  if (x < 0): return int(x-0.5)
  return int(x+.5)

def iceil(x):
  return iround(math.ceil(x))

def ifloor(x):
  return iround(math.floor(x))

def nearest_integer(x):
  return ifloor(x+0.5)

def does_imply(p,q):
  """ does p => q in the sense of logical implication? """
  return not p or q

def are_equivalent(p,q):
  """ does p <=> q in the sense of logical equivalence? """
  return does_imply(p,q) and does_imply(q,p)

class nested_loop(object):

  def __init__(O, end, begin=None, open_range=True):
    if (begin is None):
      begin = [0] * len(end)
    else:
      assert len(begin) == len(end)
    if (not open_range):
      end = list(end)
      for i in range(len(end)):
        end[i] += 1
    for i in range(len(end)):
      assert end[i] >= begin[i]
    O.begin = begin
    O.end = end
    O.current = list(begin)
    for i in range(len(end)):
      if (end[i] > begin[i]):
        O.current[-1] -= 1
        break

  def __iter__(O):
    return O

  def __next__(O):
    b = O.begin
    e = O.end
    c = O.current
    i = len(c)
    while (i > 0):
      i -= 1
      c[i] += 1
      if (c[i] < e[i]): return c
      c[i] = b[i]
    raise StopIteration

def next_permutation(seq):
  """Emulation of C++ std::next_permutation:
  Treats all permutations of seq as a set of "dictionary" sorted
  sequences. Permutes the current sequence into the next one of this set.
  Returns true if there are more sequences to generate. If the sequence
  is the largest of the set, the smallest is generated and false returned.
  """
  if (len(seq) <= 1): return False
  i = len(seq) - 1
  while True:
    ii = i
    i -= 1
    if (seq[i] < seq[ii]):
      j = len(seq)
      while True:
        j -= 1
        if (seq[i] < seq[j]):
          break
      seq[i], seq[j] = seq[j], seq[i]
      tail = seq[ii:]
      del seq[ii:]
      tail.reverse()
      seq.extend(tail)
      return True
    if (i == 0):
      seq.reverse()
      return False

def random_permutation_in_place(list):
  import random
  n = len(list)
  for i in range(n):
    j = random.randrange(n)
    list[i], list[j] = list[j], list[i]

def prime_factors_of(n):
  "http://butunclebob.com/ArticleS.UncleBob.ThePrimeFactorsKata"
  result = []
  candidate = 2
  while (n > 1):
    while (n % candidate == 0):
      result.append(candidate)
      n //= candidate
    candidate += 1
  return result

def normalize_angle(phi, deg=False, zero_centered=False):
  if (deg): period = 360
  else:     period = 2 * math.pi
  phi = math.fmod(phi, period)
  if (phi < 0): phi += period
  if (zero_centered and phi > period/2):
    phi -= period
  return phi

def median(values, sort = None):
  """ Return median value which is same as percentile_based_spread with
    cutoff of 0.5
  """
  return percentile_based_spread(values, pbs_fraction=0.5, sort = sort)

def percentile_based_spread(values, pbs_fraction=0.608, sort = None):
  """
  See Pozharski (2010) Acta. Cryst. D66, 970-978.  The default value of the
  pbs_fraction parameter is for 3D geometries, and should be adjusted as
  circumstances dictate.
  """
  if sort is None:
    if hasattr(values, 'size'):
      n = values.size()
    else:
      n = len(values)
    if n < 100000:  # sort is slow if more than 100000
      sort = True
    else:
      sort = False

  if sort:
    return percentile_based_spread_with_sort(values, pbs_fraction=pbs_fraction)
  else:
    return percentile_based_spread_with_selection(
        values, pbs_fraction=pbs_fraction)

def percentile_based_spread_with_sort(values, pbs_fraction=0.608):
  """
  See Pozharski (2010) Acta. Cryst. D66, 970-978.  The default value of the
  pbs_fraction parameter is for 3D geometries, and should be adjusted as
  circumstances dictate.
  """
  values = sorted(values)
  n = len(values)
  if (n == 0): return 0
  elif (n == 1) : return values[0]
  i_high = min(iceil(n * pbs_fraction),n-1)
  i_low = ifloor(n * pbs_fraction)
  if (i_high == i_low):
    return values[i_high]
  x_high = values[i_high]
  x_low = values[i_low]
  frac_high = i_high / n
  frac_low = i_low / n
  assert (frac_high > frac_low)
  frac_delta = (pbs_fraction - frac_low) / (frac_high - frac_low)
  x_frac = x_low + (frac_delta * (x_high - x_low))
  return x_frac

def percentile_based_spread_with_selection(values, pbs_fraction=0.608, tolerance = 0.0001):
  """
  See Pozharski (2010) Acta. Cryst. D66, 970-978.  The default value of the
  pbs_fraction parameter is for 3D geometries, and should be adjusted as
  circumstances dictate.
  This version uses selection to get the pbs within tolerance of true value
   if possible
  """
  from scitbx.array_family import flex
  values = flex.double(values)
  mmm = values.min_max_mean()
  low = mmm.min
  high = mmm.max
  max_tries = values.size()  # absolute limit
  last_value = low
  too_low = True
  for i in range(max_tries):
    if high - low < tolerance:
       break
    if too_low:
      working =  0.5 * (last_value + high)
    else:
      working =  0.5 * (last_value + low)
    frac = (values < working).count(True) / values.size()
    too_low = (frac < pbs_fraction)
    last_value = working
    if too_low:
      low = working
    else:
      high = working
  return last_value

def mahalanobis_using_sklearn(x=None, data=None, cov=None, verbose=False):
  if cov is None:
    cov = covariance_using_sklearn(data, verbose=verbose)
  mahal_cov = cov.mahalanobis(x)
  if verbose: print(mahal_cov)
  return mahal_cov

def covariance_using_sklearn(data=None, choice='Empirical', return_numpy=True, verbose=False):
  from sklearn.covariance import EmpiricalCovariance, MinCovDet
  import numpy as np
  # fit a MCD robust estimator to data
  robust_cov = MinCovDet().fit(data)
  # fit a MLE estimator to data
  emp_cov = EmpiricalCovariance().fit(data)
  if verbose:
    print(
        "Estimated covariance matrix:\nMCD (Robust):\n{}\nMLE:\n{}".format(
            robust_cov.covariance_, emp_cov.covariance_
        )
    )
  # choose one
  if choice=='Empirical':
    cov = emp_cov
  elif choice=='Robust':
    cov = robust_cov
  if return_numpy:
    return np.asarray(cov.covariance_)
  return cov

def covariance_using_numpy(data):
  import numpy as np
  return np.cov(np.transpose(data))

def numpy_mean(data, index=0):
  import numpy as np
  return np.mean(data, index)

def mahalanobis_using_numpy(x, data=None, mu=None, cov=None, inv_cov=None, verbose=False):
  """
  Compute the Mahalanobis Distance between each row of x and the data
    x    : vector or matrix of data with, say, p columns.
    data : ndarray of the distribution from which Mahalanobis distance of each
           observation of x is to be computed.
    mu   : mean of data. If None, computer from data.
    cov  : covariance matrix (p x p) of the distribution. If None, computed from data.
    inv_cov : inverse of covariance matrix. If None, computed from cov
  """
  import numpy as np
  def _mahalanobis(x, data=None, mu=None, cov=None, inv_cov=None):
    if verbose:
      print('x',x)
      print('data',data)
    if mu is None:
      mu = np.mean(data, 0)
    else:
      mu = np.asarray(mu)
    if verbose: print('mu',mu)
    if inv_cov is None:
      if cov is None:
        cov = covariance_using_numpy(data)
      else:
        cov=np.asarray(cov)
      inv_cov = np.linalg.inv(cov)
    if verbose:
      print('Covariance')
      print(cov)
    if verbose:
      print('Inverse Covariance')
      print(inv_cov)
    x_minus_mn = x - mu
    if verbose:
      print('x_minus_mn')
      print(x_minus_mn)
    D_square = np.dot(np.dot(x_minus_mn, inv_cov), np.transpose(x_minus_mn))
    if verbose:
      print('D_square')
      print(D_square)
      print(D_square.diagonal())
    return D_square.diagonal()

  if verbose:
    print(x)
    print(data)
    print(mu)
    print(cov)
    print(inv_cov)
  if data is None:
    assert mu and (cov is not None or inv_cov is not None)
  rc = _mahalanobis(x, data=data, mu=mu, cov=cov, inv_cov=inv_cov)
  return rc

def mahalanobis_p_values_outlier_indices(x=None, data=None, mu=None, cov=None, inv_cov=None, verbose=False):
  rc = mahalanobis_p_values(x=x, data=data, mu=mu, cov=cov, inv_cov=inv_cov, verbose=verbose)
  return list(filter(lambda x: rc[x] <0.01, range(len(rc))))

def mahalanobis_p_values(x=None, data=None, mu=None, cov=None, inv_cov=None, verbose=False):
  from scipy.stats import chi2
  df=len(x[0])-1
  if verbose:
    print(chi2.ppf((1-0.01), df=df))
    #> 9.21 for df=2
  mahal_cov = mahalanobis(x=x, data=data, mu=mu, cov=cov, inv_cov=inv_cov, verbose=verbose)
  if verbose: print(mahal_cov)
  return(1 - chi2.cdf(mahal_cov, df))

def mahalanobis(x=None, data=None, mu=None, cov=None, inv_cov=None, verbose=False):
  if 1:
    return mahalanobis_using_numpy(x=x, data=data, mu=mu, cov=cov, inv_cov=inv_cov, verbose=verbose)
  else:
    return mahalanobis_using_sklearn(x=x, data=data, cov=cov, verbose=verbose)


 *******************************************************************************


 *******************************************************************************
libtbx/metric_prefixes.py
"""http://en.wikipedia.org/wiki/SI_prefix

An SI prefix (also known as a metric prefix) is a name or associated
symbol that precedes a basic unit of measure (or its symbol) to form a
decimal multiple or submultiple.
"""
from __future__ import absolute_import, division, print_function

yotta = 1e24
zetta = 1e21
exa = 1e18
peta = 1e15
tera = 1e12
giga = 1e9
mega = 1e6
kilo = 1e3
hecto = 1e2
deca = 1e1
deci = 1e-1
centi = 1e-2
milli = 1e-3
micro = 1e-6
nano = 1e-9
pico = 1e-12
femto = 1e-15
atto = 1e-18
zepto = 1e-21
yocto = 1e-24

if (__name__ == "__main__"):
  p = yotta*zetta*exa*peta*tera*giga*mega*kilo*hecto*deca \
      *deci*centi*milli*micro*nano*pico*femto*atto*zepto*yocto
  assert abs(p-1) < 1.e-15
  print("OK")


 *******************************************************************************


 *******************************************************************************
libtbx/mpi4py.py
from __future__ import absolute_import, division, print_function
import numpy as np
import time
import sys

''' mpi4py wrapper: emulating mpi4py behavior for a single rank when the real mpi4py is not installed '''

class mpiEmulator(object):

  SUM = "SUM"
  MAX = "MAX"
  MIN = "MIN"
  LAND = "LAND"
  LOR = "LOR"
  LXOR = "LXOR"
  # TODO: implement more operations as needed

  def Wtime(self):
    return time.time()
  def Finalize(self):
    pass

class mpiCommEmulator(object):
  def Get_rank(self):
    return 0
  def Get_size(self):
    return 1
  def barrier(self):
    pass
  def Barrier(self):
    pass
  def bcast(self, obj, root=0):
    return obj
  def Bcast(self, buf, root=0):
    pass
  def reduce(self, sendobj, op=mpiEmulator.SUM, root=0):
    if op in {mpiEmulator.SUM, mpiEmulator.MAX, mpiEmulator.MIN,
              mpiEmulator.LAND, mpiEmulator.LOR, mpiEmulator.LXOR}:
      return sendobj
    else:
      assert False, "Unsupported MPI reduce operation %s"%(op)
  def Reduce(self, sendbuf, recvbuf, op=mpiEmulator.SUM, root=0):
    if isinstance(sendbuf, np.ndarray):  # numpy array
      recvbuf[:] = sendbuf[:]
    else:
      # Handle scalar values or other types
      if isinstance(recvbuf, list):
        for i, value in enumerate(sendbuf):
          recvbuf[i] = value
      else:
        assert False, "Unsupported MPI emulator data type."
  def allreduce(self, sendobj, op=mpiEmulator.SUM):
    return self.reduce(sendobj, op, 0)
  def alltoall(self, sendobj):
    return sendobj
  def scatter(self, sendobj, root=0):
    assert root == 0 and len(sendobj) == 1
    return sendobj[0]
  def gather(self, sendobj, root=0):
    items = []
    items.append(sendobj)
    return items
  def Gatherv(self, sendbuf, recvbuf, root=0):
    assert len(recvbuf) == 2, "Other ways of using Gatherv are not implemented"
    rbuff, counts = recvbuf
    if len(counts) == 1:
      sendbuf = (sendbuf,)
    counter = 0
    for item, count in zip(sendbuf, counts):
      rbuff[counter:counter+count] = item
      counter += count
  def allgather(self, sendobj):
    return [sendobj]
  def Allgatherv(self, sendbuf, recvbuf):
    return self.Gatherv(sendbuf, recvbuf)
  def Abort(self,errorcode=0):
    import sys
    sys.exit()
  @property
  def rank(self):
    return self.Get_rank()
  @property
  def size(self):
    return self.Get_size()


mpiEmulator.COMM_WORLD = mpiCommEmulator()

class MpiDisabledError(Exception):
  pass

try:
  import libtbx
  if libtbx.mpi_import_guard.disable_mpi:
    raise MpiDisabledError
  from mpi4py import MPI
  using_mpi = True
except ImportError:
  print ("\nWarning: could not import mpi4py. Running as a single process.\n")
  MPI = mpiEmulator()
  using_mpi = False
except MpiDisabledError:
  MPI = mpiEmulator()
  using_mpi = False


def mpi_abort_on_exception(func):
  """
  A decorator for functions that will be called in an MPI context. This ensures
  the MPI job will abort if a single rank raises an exception (or exits) out of
  the decorated function.
  """
  def wrapped_func(*args, **kwargs):
    try:
      return func(*args, **kwargs)
    except Exception:
      sys.excepthook(*sys.exc_info())
      MPI.COMM_WORLD.Abort(1)
    except SystemExit as e:
      if e.code:
        sys.stderr.write(e.code + '\n')
      MPI.COMM_WORLD.Abort(1)
  if using_mpi and MPI.COMM_WORLD.size > 1:
    return wrapped_func
  else:
    return func


 *******************************************************************************


 *******************************************************************************
libtbx/object_oriented_patterns.py
""" A library of object-oriented patterns """
from __future__ import absolute_import, division, print_function

from builtins import object

import sys
import weakref
from types import MethodType
import six


class meta_injector(type):

  def __init__(cls, name, bases, namespace, **kwds):
    for target_class in bases[1:]:
      for name, attribute in namespace.items():
        if name in ('__module__', '__doc__'):
          continue
        if sys.hexversion >= 0x03000000:
          if name in ('__qualname__',):
            continue
        if sys.version_info.major == 3 and sys.version_info.minor >= 13:
          if name in ('__firstlineno__', '__static_attributes__'):
            continue
        assert not hasattr(target_class, name), (
          "class %s already has attribute '%s'"
          % (target_class.__name__, name))
        setattr(target_class, name, attribute)


class injector(six.with_metaclass(meta_injector)):
  """ Injection of new methods into an existing class

  * synopsis *

  class some_descriptive_text(injector, some_existing_class,
                                        another_existing_class, ...):

    def new_method(self, ...): ...

    def another_new_method(self, ...): ...

  obj = some_existing_class(...)
  obj.new_method(...)
  obj = another_existing_class(...)
  obj.new_method(...)
  # class 'some_descriptive_text' is an empty shell with no use by itself.

  * motivation *

  The traditional way to add methods to an existing class involves typing
  three times the same information:

  def new_method(self, ...): ...
  existing_class.new_method = new_method

  or to defer the naming to after the definition:

  def foo(self, ...): ...
  existing_class.new_method = foo

  A bit of metaclass trickery results in a cleaner syntax.
  """


class memoize(object):
  """ Memoize the result returned by a function """

  def __init__(self, func):
    self.cached = {}
    self.func = func
    self.__doc__ = self.func.__doc__

  def __call__(self, *args):
    try:
      return self.cached[args]
    except KeyError:
      self.cached[args] = result = self.func(*args)
      return result
    except TypeError:
      return self.func(*args)


class memoize_method(object):
  """ Memoize the result returned by a bound method.
      This is to be used with immutable objects only.
  """

  def __init__(self, meth):
    self.cache = '_memoized_%s' % meth.__name__
    self.meth = meth

  def __get__(self, obj, type=None):
    if obj is None:
      return self
    try:
      return getattr(obj, self.cache)
    except AttributeError:
      # We use weakref.proxy to break the following cycle
      # obj._memoized_xxx.func.im_self is obj
      # It's always better to enable reference counting to collect
      # unreachable object as soon as they become so instead of relying
      # on a later gc collection.
      try:
        # Python 2: 3 arguments
        func = MethodType(self.meth, weakref.proxy(obj), type)
      except TypeError:
        # Python 3: 2 arguments
        func = MethodType(self.meth, weakref.proxy(obj))
      memoized = memoize(func)
      setattr(obj, self.cache, memoized)
      return memoized


class null(object):

  def __init__(self, *args, **kwds): pass

  def __getattr__(self, a): return self
  def __setattr__(self, a, v): return self
  def __delattr__(self, a): return self
  def __getnewargs__(self):  return () # allow for pickling during multiprocessing
  def __call__(self, *args, **kwds): return self

  def __getitem__(self, i): return self
  def __setitem__(self, i, v): return self
  def __delitem__(self, i): return self

  def __repr__(self): return 'null()'

  def __bool__(self): return False


class proxy(object):

  def __init__(self, subject):
    self.subject = subject

  def __getattr__(self, attr):
    return getattr(self.subject, attr)


class journal_mixin(object):
  """ An easy way to store the history of an attribute as it changes
      through the course of a routine.
  """

  __journal__ = []
  __journal_suffix__ = "_history"

  def __getattr__(self, name):
    if name in self.__journal__:
      key = name+self.__journal_suffix__
    else:
      key = name
    if key in self.__dict__:
      return self.__dict__[key][-1]
    else: raise AttributeError(name)

  def __setattr__(self, name, value):
    if name in self.__journal__:
      key = name+self.__journal_suffix__
      if key not in self.__dict__:
        self.__dict__[key] = [value]
      else:
        self.__dict__[key].append(value)
    else:
      self.__dict__[name] = value

  def __delattr__(self, name):
    if name in self.__journal__:
      key = name+self.__journal_suffix__
    else:
      key = name
    del self.__dict__[key]


def calculate_state(holder):

  holder.data = holder.calculation()
  holder.state = retrieve_state
  return holder.data


def retrieve_state(holder):

  return holder.data


class lazy_initialization(object):
  """
  Defers initialization until the value is accessed (state pattern)
  """

  def __init__(self, func, *args, **kwargs):

    import functools
    self.calculation = functools.partial( func, *args, **kwargs )
    self.data = None
    self.state = calculate_state


  def __call__(self):

    return self.state( holder = self )


 *******************************************************************************


 *******************************************************************************
libtbx/objgraph.py
"""
Ad-hoc tools for drawing Python object reference graphs with graphviz.

This module is more useful as a repository of sample code and ideas, than
as a finished product.  For documentation and background, read

  http://mg.pov.lt/blog/hunting-python-memleaks.html
  http://mg.pov.lt/blog/python-object-graphs.html
  http://mg.pov.lt/blog/object-graphs-with-graphviz.html

in that order.  Then use pydoc to read the docstrings, as there were
improvements made since those blog posts.

Copyright (c) 2008 Marius Gedminas <marius@pov.lt>

Released under the MIT licence.

See also:
  http://www.lshift.net/blog/2008/11/14/tracing-python-memory-leaks


Changes
=======

1.1dev (2008-09-05)
-------------------

New function: show_refs() for showing forward references.

New functions: typestats() and show_most_common_types().

Object boxes are less crammed with useless information (such as IDs).

Spawns xdot if it is available.
"""
from __future__ import absolute_import, division, print_function
# Permission is hereby granted, free of charge, to any person obtaining a
# copy of this software and associated documentation files (the "Software"),
# to deal in the Software without restriction, including without limitation
# the rights to use, copy, modify, merge, publish, distribute, sublicense,
# and/or sell copies of the Software, and to permit persons to whom the
# Software is furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
# DEALINGS IN THE SOFTWARE.

__author__ = "Marius Gedminas (marius@gedmin.as)"
__copyright__ = "Copyright (c) 2008 Marius Gedminas"
__license__ = "MIT"
__version__ = "1.1dev"
__date__ = "2008-09-05"


import gc
import inspect
import types
import weakref
import operator
import os


def count(typename):
    """Count objects tracked by the garbage collector with a given class name.

    Example:

        >>> count('dict')
        42
        >>> count('MyClass')
        3

    Note that the GC does not track simple objects like int or str.
    """
    return sum(1 for o in gc.get_objects() if type(o).__name__ == typename)


def typestats():
    """Count the number of instances for each type tracked by the GC.

    Note that the GC does not track simple objects like int or str.

    Note that classes with the same name but defined in different modules
    will be lumped together.
    """
    stats = {}
    for o in gc.get_objects():
        stats.setdefault(type(o).__name__, 0)
        stats[type(o).__name__] += 1
    return stats


def show_most_common_types(limit=10, f=None):
    """Count the names of types with the most instances.

    Note that the GC does not track simple objects like int or str.

    Note that classes with the same name but defined in different modules
    will be lumped together.
    """
    stats = sorted(list(typestats().items()), key=operator.itemgetter(1),
                   reverse=True)
    if limit:
        stats = stats[:limit]
    width = max(len(name) for name, count in stats)
    if (f is None): f = sys.stdout
    for name, count in stats[:limit]:
        print(name.ljust(width), count, file=f)


def by_type(typename):
    """Return objects tracked by the garbage collector with a given class name.

    Example:

        >>> by_type('MyClass')
        [<mymodule.MyClass object at 0x...>]

    Note that the GC does not track simple objects like int or str.
    """
    return [o for o in gc.get_objects() if type(o).__name__ == typename]


def at(addr):
    """Return an object at a given memory address.

    The reverse of id(obj):

        >>> at(id(obj)) is obj
        True

    Note that this function does not work on objects that are not tracked by
    the GC (e.g. ints or strings).
    """
    for o in gc.get_objects():
        if id(o) == addr:
            return o
    return None


def find_backref_chain(obj, predicate, max_depth=20, extra_ignore=()):
    """Find a shortest chain of references leading to obj.

    The start of the chain will be some object that matches your predicate.

    ``max_depth`` limits the search depth.

    ``extra_ignore`` can be a list of object IDs to exclude those objects from
    your search.

    Example:

        >>> find_backref_chain(obj, inspect.ismodule)
        [<module ...>, ..., obj]

    Returns None if such a chain could not be found.
    """
    queue = [obj]
    depth = {id(obj): 0}
    parent = {id(obj): None}
    ignore = set(extra_ignore)
    ignore.add(id(extra_ignore))
    ignore.add(id(queue))
    ignore.add(id(depth))
    ignore.add(id(parent))
    ignore.add(id(ignore))
    gc.collect()
    while queue:
        target = queue.pop(0)
        if predicate(target):
            chain = [target]
            while parent[id(target)] is not None:
                target = parent[id(target)]
                chain.append(target)
            return chain
        tdepth = depth[id(target)]
        if tdepth < max_depth:
            referrers = gc.get_referrers(target)
            ignore.add(id(referrers))
            for source in referrers:
                if inspect.isframe(source) or id(source) in ignore:
                    continue
                if id(source) not in depth:
                    depth[id(source)] = tdepth + 1
                    parent[id(source)] = target
                    queue.append(source)
    return None # not found


def show_backrefs(objs, max_depth=3, extra_ignore=(), filter=None, too_many=10,
                  highlight=None):
    """Generate an object reference graph ending at ``objs``

    The graph will show you what objects refer to ``objs``, directly and
    indirectly.

    ``objs`` can be a single object, or it can be a list of objects.

    Produces a Graphviz .dot file and spawns a viewer (xdot) if one is
    installed, otherwise converts the graph to a .png image.

    Use ``max_depth`` and ``too_many`` to limit the depth and breadth of the
    graph.

    Use ``filter`` (a predicate) and ``extra_ignore`` (a list of object IDs) to
    remove undesired objects from the graph.

    Use ``highlight`` (a predicate) to highlight certain graph nodes in blue.

    Examples:

        >>> show_backrefs(obj)
        >>> show_backrefs([obj1, obj2])
        >>> show_backrefs(obj, max_depth=5)
        >>> show_backrefs(obj, filter=lambda x: not inspect.isclass(x))
        >>> show_backrefs(obj, highlight=inspect.isclass)
        >>> show_backrefs(obj, extra_ignore=[id(locals())])

    """
    show_graph(objs, max_depth=max_depth, extra_ignore=extra_ignore,
               filter=filter, too_many=too_many, highlight=highlight,
               edge_func=gc.get_referrers, swap_source_target=False)


def show_refs(objs, max_depth=3, extra_ignore=(), filter=None, too_many=10,
              highlight=None):
    """Generate an object reference graph starting at ``objs``

    The graph will show you what objects are reachable from ``objs``, directly
    and indirectly.

    ``objs`` can be a single object, or it can be a list of objects.

    Produces a Graphviz .dot file and spawns a viewer (xdot) if one is
    installed, otherwise converts the graph to a .png image.

    Use ``max_depth`` and ``too_many`` to limit the depth and breadth of the
    graph.

    Use ``filter`` (a predicate) and ``extra_ignore`` (a list of object IDs) to
    remove undesired objects from the graph.

    Use ``highlight`` (a predicate) to highlight certain graph nodes in blue.

    Examples:

        >>> show_refs(obj)
        >>> show_refs([obj1, obj2])
        >>> show_refs(obj, max_depth=5)
        >>> show_refs(obj, filter=lambda x: not inspect.isclass(x))
        >>> show_refs(obj, highlight=inspect.isclass)
        >>> show_refs(obj, extra_ignore=[id(locals())])

    """
    show_graph(objs, max_depth=max_depth, extra_ignore=extra_ignore,
               filter=filter, too_many=too_many, highlight=highlight,
               edge_func=gc.get_referents, swap_source_target=True)

#
# Internal helpers
#

def show_graph(objs, edge_func, swap_source_target,
               max_depth=3, extra_ignore=(), filter=None, too_many=10,
               highlight=None):
    if not isinstance(objs, (list, tuple)):
        objs = [objs]
    f = file('objects.dot', 'w')
    print('digraph ObjectGraph {', file=f)
    print('  node[shape=box, style=filled, fillcolor=white];', file=f)
    queue = []
    depth = {}
    ignore = set(extra_ignore)
    ignore.add(id(objs))
    ignore.add(id(extra_ignore))
    ignore.add(id(queue))
    ignore.add(id(depth))
    ignore.add(id(ignore))
    for obj in objs:
        print('  %s[fontcolor=red];' % (obj_node_id(obj)), file=f)
        depth[id(obj)] = 0
        queue.append(obj)
    gc.collect()
    nodes = 0
    while queue:
        nodes += 1
        target = queue.pop(0)
        tdepth = depth[id(target)]
        print('  %s[label="%s"];' % (obj_node_id(target), obj_label(target, tdepth)), file=f)
        h, s, v = gradient((0, 0, 1), (0, 0, .3), tdepth, max_depth)
        if inspect.ismodule(target):
            h = .3
            s = 1
        if highlight and highlight(target):
            h = .6
            s = .6
            v = 0.5 + v * 0.5
        print('  %s[fillcolor="%g,%g,%g"];' % (obj_node_id(target), h, s, v), file=f)
        if v < 0.5:
            print('  %s[fontcolor=white];' % (obj_node_id(target)), file=f)
        if inspect.ismodule(target) or tdepth >= max_depth:
            continue
        neighbours = edge_func(target)
        ignore.add(id(neighbours))
        n = 0
        for source in neighbours:
            if inspect.isframe(source) or id(source) in ignore:
                continue
            if filter and not filter(source):
                continue
            if swap_source_target:
                srcnode, tgtnode = target, source
            else:
                srcnode, tgtnode = source, target
            elabel = edge_label(srcnode, tgtnode)
            print('  %s -> %s%s;' % (obj_node_id(srcnode), obj_node_id(tgtnode), elabel), file=f)
            if id(source) not in depth:
                depth[id(source)] = tdepth + 1
                queue.append(source)
            n += 1
            if n >= too_many:
                print('  %s[color=red];' % obj_node_id(target), file=f)
                break
    print("}", file=f)
    f.close()
    print("Graph written to objects.dot (%d nodes)" % nodes)
    if os.system('which xdot >/dev/null') == 0:
        print("Spawning graph viewer (xdot)")
        os.system("xdot objects.dot &")
    else:
        os.system("dot -Tpng objects.dot > objects.png")
        print("Image generated as objects.png")


def obj_node_id(obj):
    if isinstance(obj, weakref.ref):
        return 'all_weakrefs_are_one'
    return ('o%d' % id(obj)).replace('-', '_')


def obj_label(obj, depth):
    return quote(type(obj).__name__ + ':\n' +
                 safe_repr(obj))


def quote(s):
    return s.replace("\\", "\\\\").replace("\"", "\\\"").replace("\n", "\\n")


def safe_repr(obj):
    try:
        return short_repr(obj)
    except Exception:
        return '(unrepresentable)'


def short_repr(obj):
    if isinstance(obj, (type, types.ModuleType, types.BuiltinMethodType,
                        types.BuiltinFunctionType)):
        return obj.__name__
    if isinstance(obj, types.MethodType):
        if obj.__self__ is not None:
            return obj.__func__.__name__ + ' (bound)'
        else:
            return obj.__func__.__name__
    if isinstance(obj, (tuple, list, dict, set)):
        return '%d items' % len(obj)
    if isinstance(obj, weakref.ref):
        return 'all_weakrefs_are_one'
    return repr(obj)[:40]


def gradient(start_color, end_color, depth, max_depth):
    if max_depth == 0:
        # avoid division by zero
        return start_color
    h1, s1, v1 = start_color
    h2, s2, v2 = end_color
    f = float(depth) / max_depth
    h = h1 * (1-f) + h2 * f
    s = s1 * (1-f) + s2 * f
    v = v1 * (1-f) + v2 * f
    return h, s, v


def edge_label(source, target):
    if isinstance(target, dict) and target is getattr(source, '__dict__', None):
        return ' [label="__dict__",weight=10]'
    elif isinstance(source, dict):
        for k, v in source.items():
            if v is target:
                from six import string_types
                if isinstance(k, string_types) and k:
                    return ' [label="%s",weight=2]' % quote(k)
                else:
                    return ' [label="%s"]' % quote(safe_repr(k))
    return ''


 *******************************************************************************


 *******************************************************************************
libtbx/option_parser.py
from __future__ import absolute_import, division, print_function
from libtbx.utils import Sorry
from libtbx.queuing_system_utils import chunk_manager
import copy
import sys

from optparse import *
from six.moves import range

def check_bool(option, opt, value):
  v = value.strip().lower()
  if (v in ["false", "no", "off", "0"]): return False
  if (v in ["true", "yes", "on", "1"]): return True
  raise OptionValueError(
    "option %s: invalid bool value: %r" % (opt, value))

DefaultOption = Option
assert not "bool" in DefaultOption.TYPE_CHECKER

class Option(DefaultOption):
  TYPES = Option.TYPES + ("bool",)
  TYPE_CHECKER = copy.copy(Option.TYPE_CHECKER)
  TYPE_CHECKER["bool"] = check_bool

make_option = Option

def run_multi(cmd):
  from libtbx import easy_run
  import traceback
  print(cmd)
  try:
    easy_run.call(command=cmd)
  except: # intentional
    sys.stdout.flush()
    print("CAUGHT EXCEPTION: run_multi(%s)" % cmd, file=sys.stderr)
    traceback.print_exc()
    sys.stderr.flush()

class processed_options(object):

  def __init__(self, parser, options_and_args, options, args,
        show_defaults_callback,
        chunk_callback):
    self.parser = parser
    self.options_and_args = options_and_args
    self.options = options
    self.args = args
    self.expert_level = show_defaults_callback.expert_level
    self.attributes_level = show_defaults_callback.attributes_level
    self.chunk = chunk_callback.chunk_manager()

  def run_multiprocessing_chunks_if_applicable(self, command_call):
    assert isinstance(command_call, list)
    n = self.options.max_proc
    if (n is not None and n > 1):
      if (self.chunk.n == 1):
        from libtbx.utils import escape_sh_double_quoted
        cmds = []
        for i in range(n):
          cmd = command_call \
              + self.options_and_args \
              + ["--chunk=%d,%d" % (n,i)]
          cmd = " ".join(['"'+escape_sh_double_quoted(s=arg)+'"'
            for arg in cmd])
          cmds.append(cmd)
        from libtbx import easy_mp
        easy_mp.pool_map(processes=n, func=run_multi, args=cmds, chunksize=1)
        return True
      self.chunk.redirect_chunk_stdout_and_stderr(have_array=True)
    return False

class option_parser(OptionParser):

  processed_options_type = processed_options

  def __init__(self, usage=None, description=None, more_help=None):
    OptionParser.__init__(self, usage=usage, description=description)
    self.more_help = more_help
    self.show_defaults_callback = show_defaults_callback()
    self.chunk_callback = chunk_callback()
    self.multiprocessing_is_enabled = False

  def call_with_self_as_first_argument(self, callable, **kw):
    if (callable is not None):
      callable(option_parser=self, **kw)
    return self

  def option(self, *args, **kw):
    self.add_option(make_option(*args, **kw))
    return self

  def format_help(self, formatter=None):
    if formatter is None:
      formatter = self.formatter
    result = []
    if self.usage:
      result.append(self.get_usage() + "\n")
    result.append(self.format_option_help(formatter))
    if self.description:
      result.append("\n")
      result.append(self.format_description(formatter) + "\n")
      result.append("\n")
    if (self.more_help is not None):
      for line in self.more_help:
        result.append(line + "\n")
    return "".join(result)

  def show_help(self, f=None):
    if (f is None): f = sys.stdout
    f.write(self.format_help())

  def enable_show_defaults(self):
    self.add_option(make_option(None, "--show_defaults",
      action="callback",
      type="string",
      callback=self.show_defaults_callback,
      help='Print parameters visible at the given expert level'
           ' (integer value or "all") and exit. Optionally,'
           ' append .help, .more, or .all to the expert level, for example:\n'
           ' --show-defaults=all.help',
      metavar="EXPERT_LEVEL"))
    self.show_defaults_callback.is_enabled = True
    return self

  def enable_chunk(self, easy_all=False):
    self.add_option(make_option(None, "--chunk",
      action="callback",
      type="string",
      callback=self.chunk_callback,
      help="Number of chunks for parallel execution and index for one process",
      metavar="n,i"))
    self.chunk_callback.is_enabled = True
    self.chunk_callback.easy_all = easy_all
    return self

  def enable_multiprocessing(self):
    self.add_option(make_option(None, "--multiprocessing",
      action="store_true",
      default=False,
      help="Use multiple processes on local machine (all CPUs unless"
           " --max-proc is also specified)"))
    self.add_option(make_option(None, "--max_proc",
      action="store",
      help="Maximum number of processes on local machine",
      type="int",
      metavar="INT"))
    self.multiprocessing_is_enabled = True
    return self

  def enable_dry_run(self):
    self.add_option(make_option(None, "--dry_run",
      action="store_true",
      default=False,
      help="Perform program initialization and exit (for debugging purposes)"))
    return self

  def process(self, args=None, nargs=None, min_nargs=None, max_nargs=None):
    if (self.show_defaults_callback.is_enabled
        and args is not None
        and len(args) > 0
        and args[-1] == "--show_defaults"):
      args = args + ["0"]
    assert nargs is None or (min_nargs is None and max_nargs is None)
    options_and_args = args
    (options, args) = self.parse_args(args)
    if (min_nargs is None): min_nargs = nargs
    if (min_nargs is not None):
      if (len(args) < min_nargs):
        if (len(args) == 0):
          self.show_help()
          sys.exit(1)
        self.error("Not enough arguments (at least %d required, %d given)." % (
          min_nargs, len(args)))
    if (max_nargs is None): max_nargs = nargs
    if (max_nargs is not None):
      if (len(args) > max_nargs):
        self.error("Too many arguments (at most %d allowed, %d given)." % (
          max_nargs, len(args)))
    if (self.multiprocessing_is_enabled):
      if (options.multiprocessing and options.max_proc is None):
        import libtbx.introspection
        options.max_proc = libtbx.introspection.number_of_processors()
    return self.processed_options_type(
      self, options_and_args, options, args,
      show_defaults_callback=self.show_defaults_callback,
      chunk_callback=self.chunk_callback)

libtbx_option_parser = option_parser

class show_defaults_callback(object):

  def __init__(self):
    self.is_enabled = False
    self.expert_level = None
    self.attributes_level = 0

  def raise_sorry(self, value):
        raise Sorry("""\
Invalid option value: --show-defaults="%s"
  Please specify an integer value or the word "all"
  Examples:
    --show_defaults=0   # novice
    --show_defaults=1   # slightly advanced
    --show_defaults=2   # more advanced
    etc.
    --show_defaults=all # everything
  Optionally, append
    .help   to display the parameter help, or
    .more   to display all parameter attributes which are not None
    .all    to display all parameter attributes
  Examples:
    --show_defaults=all.help
    --show_defaults=all.all""" % value)

  def __call__(self, option, opt, value, parser):
    flds = value.strip().lower().split(".")
    if (1 > len(flds) > 2): self.raise_sorry(value=value)
    if (flds[0] == "all"):
      self.expert_level = -1
    else:
      try: expert_level = int(flds[0])
      except ValueError: self.raise_sorry(value=value)
      self.expert_level = expert_level
    if (len(flds) > 1):
      if (flds[1] == "help"):
        self.attributes_level = 1
      elif (flds[1] == "more"):
        self.attributes_level = 2
      elif (flds[1] == "all"):
        self.attributes_level = 3
      else:
        self.raise_sorry(value=value)

class chunk_callback(object):

  def __init__(self):
    self.is_enabled = False
    self.easy_all = False
    self.n = 1
    self.i = 0

  def __call__(self, option, opt, value, parser):
    assert opt == "--chunk"
    try:
      self.n, self.i = [int(i) for i in value.split(",")]
    except Exception:
      raise OptionError(
        "Two comma-separated positive integers required.",
        opt)
    if (self.n < 1):
      raise OptionError(
        "First integer (number of chunks) must be greater than 0 (%d given)."
        % self.n, opt)
    if (self.i < 0):
      raise OptionError(
        "Second integer (index of chunks) must be positive (%d given)."
        % self.i, opt)
    if (self.n < self.i):
      raise OptionError(
        ("First integer (number of chunks, %d given) must be greater"
        + " than second integer (index of chunks, %d given).")%(self.n,self.i),
        opt)

  def chunk_manager(self):
    result = chunk_manager(n=self.n, i=self.i)
    if (self.easy_all): result.easy_all()
    return result


 *******************************************************************************


 *******************************************************************************
libtbx/path.py
from __future__ import absolute_import, division, print_function
import locale
import shutil
import os
import sys
from six.moves import range, zip
op = os.path

if sys.hexversion >= 0x03000000:
  unicode = str

def norm_join(*args):
  return op.normpath(op.join(*args))

def abs_real_norm(path):
  return op.normpath(op.realpath(op.abspath(path)))

def abs_norm(path):
  return op.normpath(op.abspath(path))

def posix_relpath(
      path,
      start=".",
      enable_abspath_if_through_root=False):
  # based on relpath() in Python-2.7.2/Lib/posixpath.py
  if not path:
    raise ValueError("no path specified")
  def as_list(ap):
    result = []
    for _ in ap.split("/"):
      if (_): result.append(_)
    return result
  start_list = as_list(op.abspath(start))
  path_abs = op.abspath(path)
  path_list = as_list(path_abs)
  i = len(op.commonprefix([start_list, path_list]))
  if (i == 0 and enable_abspath_if_through_root):
    return path_abs
  rel_list = [".."] * (len(start_list)-i) + path_list[i:]
  if not rel_list:
    return "."
  return op.join(*rel_list)

def nt_is_true_abs(path):
  try: # splitunc is removed in Python 3.7,
    prefix, _ = op.splitunc(path)
    if (bool(prefix)): return True
  except AttributeError:
    pass
  prefix, _ = op.splitdrive(path)
  return bool(prefix)

def nt_relpath(
      path,
      start=".",
      enable_abspath_if_through_root=False):
  # based on relpath() in Python-2.7.2/Lib/ntpath.py
  if not path:
    raise ValueError("no path specified")
  if (enable_abspath_if_through_root
        and not (    nt_is_true_abs(start)
                 and nt_is_true_abs(path))):
    raise RuntimeError(
      "nt_relpath(): both path and start must be absolute paths.")
  start_abs = abs_norm(start)
  path_abs = abs_norm(path)
  def _abspath_split(abs):
    try: # splitunc is removed in Python 3.7
      prefix, rest = op.splitunc(abs)
      is_unc = bool(prefix)
    except AttributeError:
      is_unc = False
    if not is_unc:
      prefix, rest = op.splitdrive(abs)
    rest_list = []
    for _ in rest.split("\\"):
      if _: rest_list.append(_)
    return is_unc, prefix, rest_list
  start_is_unc, start_prefix, start_list = _abspath_split(start_abs)
  path_is_unc, path_prefix, path_list = _abspath_split(path_abs)
  if path_is_unc ^ start_is_unc:
    if (enable_abspath_if_through_root):
      return path_abs
    raise ValueError("Cannot mix UNC and non-UNC paths (%s and %s)"
                              % (path, start))
  if path_prefix.lower() != start_prefix.lower():
    if (enable_abspath_if_through_root):
      return path_abs
    if path_is_unc:
      raise ValueError("path is on UNC root %s, start on UNC root %s"
                        % (path_prefix, start_prefix))
    else:
      raise ValueError("path is on drive %s, start on drive %s"
                        % (path_prefix, start_prefix))
  i = 0
  for e1, e2 in zip(start_list, path_list):
    if e1.lower() != e2.lower():
      break
    i += 1
  if (i == 0 and enable_abspath_if_through_root):
    return path_prefix + "\\" + "\\".join(path_list)
  rel_list = [".."] * (len(start_list)-i) + path_list[i:]
  if not rel_list:
    return "."
  return op.join(*rel_list)

if (os.name == "nt"):
  relpath = nt_relpath
else:
  relpath = posix_relpath

def tail_levels(path, number_of_levels):
  return op.join(*path.split(op.sep)[-number_of_levels:])

def create_target_dir(target_file):
  target_dir = op.split(target_file)[0]
  if (not op.isdir(target_dir)):
    os.makedirs(target_dir)

def move_old(path, serial_sep="_", serial_fmt="%03d"):
  if (not op.exists(path)): return
  bns = op.basename(path) + serial_sep
  dn = op.dirname(op.abspath(path))
  max_i = 0
  for ex in os.listdir(dn):
    if (ex.startswith(bns)):
      s = ex[len(bns):]
      try: i = int(s)
      except ValueError: pass
      else: max_i = max(max_i, i)
  nn = op.join(dn, bns + serial_fmt % (max_i+1))
  os.rename(path, nn)

def move_old_create_new_directory(path, serial_sep="_", serial_fmt="%03d"):
  move_old(path=path, serial_sep=serial_sep, serial_fmt=serial_fmt)
  os.makedirs(path)

def canonical_path(file_name, effective_current_working_directory=None):
  if not isinstance(file_name, (bytes, unicode)):
    file_name = abs(file_name)
  if (not op.isabs(file_name)):
    if (effective_current_working_directory is None):
      effective_current_working_directory = os.getcwd()
    file_name = op.join(effective_current_working_directory, file_name)
  return op.normpath(file_name)

def is_same_canoncial_file(file_names):
  assert len(file_names) == 2
  if (file_names[0] == file_names[1]): return True
  if (hasattr(op, "samefile")):
    return op.samefile(file_names[0], file_names[1])
  return False

def is_same_file(file_names, effective_current_working_directory=None):
  return is_same_canoncial_file(
    [canonical_path(file_name, effective_current_working_directory)
      for file_name in file_names])

def full_command_path(command, search_first=[], search_last=[]):
  dirs = search_first + os.environ["PATH"].split(os.pathsep) + search_last
  for path in dirs:
    path_command = op.join(path, command)
    if (op.exists(path_command)):
      return abs_norm(path=path_command)
  return None

class directory(object):

  def __init__(self, path):
    self.path = path

  def get(self, name, must_exist=True):
    assert name is not None
    result = op.join(self.path, name)
    if (must_exist and not op.exists(result)):
      from libtbx.str_utils import show_string
      raise RuntimeError("No such file or directory: %s" % show_string(result))
    return result

  def sub_directory(self, name, must_exist=True):
    result = directory(self.get(name))
    if (must_exist and not op.isdir(result.path)):
      from libtbx.str_utils import show_string
      raise RuntimeError("Not a directory: %s" % show_string(result.path))
    return result

def walk_source_tree(top, arg=None):
  def visitor(result, dirname, names):
    names_keep = []
    for name in names:
      path = op.join(dirname, name)
      if (not op.isdir(path)):
        if (not name.endswith(".pyc")):
          result.append(path)
        continue
      def is_file_in_subdir(name):
        return op.isfile(op.join(path, name))
      if (   (name == "CVS" and is_file_in_subdir("Entries"))
          or (name == ".svn"
                and (   is_file_in_subdir("README.txt")
                     or is_file_in_subdir("entries")))):
        continue
      names_keep.append(name)
    if (len(names_keep) != len(names)):
      del names[:]
      names.extend(names_keep)
  result = []
  if sys.version_info.major == 3:
    for root, dirs, files in os.walk(top):
      visitor(
          result=result,
          dirname=root,
          names=files)
  else:
    op.walk(top, visitor, result)
  return result

def random_new_directory_name(prefix="tmp_dir_", number_of_hex_code_digits=8):
  from libtbx.utils import random_hex_code
  for i_trial in range(10**6):
    name = prefix + random_hex_code(number_of_digits=number_of_hex_code_digits)
    if (not op.exists(name)):
      return name
  else:
    raise AssertionError

def makedirs(path):
  """
  Wrapper for os.makedirs that catches OSError and re-raises as Sorry.
  """
  try :
    os.makedirs(path)
  except OSError as e :
    from libtbx.utils import Sorry
    raise Sorry(str(e))

def makedirs_race(
      path=None,
      max_trials=10,
      delay_if_exists=0.001,
      delay_after_exception=0.5):
  if (path is None):
    path = random_new_directory_name()
  import time
  for i_trial in range(max_trials):
    if (op.exists(path)):
      if (delay_if_exists is not None):
        # in case the OS needs time to finalize makedirs from another process
        time.sleep(delay_if_exists)
      break
    try:
      os.makedirs(path)
    except Exception:
      if (delay_after_exception is not None):
        time.sleep(delay_after_exception)
  if (not op.isdir(path)):
    raise RuntimeError("makedirs_race(%s) failure." % path)
  return path


class path_mixin(object):

  def __truediv__(self, path):
    return self.__div__(path)

  def isdir(self):
    return op.isdir(abs(self))

  def isfile(self):
    return op.isfile(abs(self))

  def exists(self):
    return op.exists(abs(self))

  def open(self, *args, **kwds):
    return open(abs(self), *args, **kwds)

  def makedirs(self):
    os.makedirs(abs(self))

  def remove(self):
    if self.exists(): os.remove(abs(self))
    assert not self.exists()

  def remove_tree(self):
    from shutil import rmtree
    if self.isdir():
      rmtree(abs(self))
    else:
      self.remove()

  def listdir(self):
    return os.listdir(abs(self))

  def chmod(self, *args, **kwds):
    return os.chmod(abs(self), *args, **kwds)

  def access(self, *args, **kwds):
    return os.access(abs(self), *args, **kwds)

  def basename(self):
    return op.basename(abs(self))

  def ext(self):
    return op.splitext(self.basename())[1]

  def split(self):
    return (self.dirname(), self.basename())

  def samefile(self, other):
    if isinstance(other, (bytes, unicode)):
      return op.samefile(abs(self), other)
    else:
      return op.samefile(abs(self), abs(other))

  def is_relocatable(self):
    return isinstance(self, relocatable_path)

  def sh_value(self, anchor_var="LIBTBX_BUILD"):
    if (self.is_relocatable()):
      return op.join("$%s" % anchor_var, self.relocatable)
    return abs(self)

  def bat_value(self, anchor_var="LIBTBX_BUILD"):
    if (self.is_relocatable()):
      return op.join("%%%s%%" % anchor_var, self.relocatable)
    return abs(self)


class absolute_path(path_mixin):

  def __init__(self, path, case_sensitive=False):
    assert op.isabs(path)
    if not case_sensitive:
      path = op.normcase(path)
    path = op.normpath(path)
    self._path = path

  def reset(self, new_path, case_sensitive=False):
    self._path = absolute_path(new_path, case_sensitive)._path

  def __div__(self, other):
    return absolute_path(op.join(self._path, other))

  def __abs__(self):
    return self._path

  def __add__(self, ext):
    return absolute_path(self._path + ext)

  def __repr__(self):
    return 'absolute_path("%s")' % self._path

  def dirname(self):
    return absolute_path(op.dirname(self._path))


class relocatable_path(path_mixin):
  def __init__(self, anchor, relocatable, resolve_symlinks=True):
    assert isinstance(anchor, absolute_path)
    self._anchor = anchor
    if op.isabs(relocatable):
      path = abs(absolute_path(relocatable))
      start = abs(self._anchor)
      if resolve_symlinks:
        path = op.realpath(path)
        start = op.realpath(start)
      relocatable = relpath(
        path=path,
        start=start,
        enable_abspath_if_through_root=True)
    self.relocatable = relocatable

  def anchor(self):
    return self._anchor
  anchor = property(anchor)

  def __div__(self, path):
    return relocatable_path(self._anchor, op.join(self.relocatable, path))

  def __idiv__(self, path):
    self.relocatable = op.join(self.relocatable, path)
    return self

  def __add__(self, ext):
    return relocatable_path(self._anchor, self.relocatable + ext)

  def self_or_abs_if(self, flag):
    if flag:
      return abs(self)
    else:
      return self

  def __abs__(self):
    return op.abspath(op.join(abs(self.anchor), self.relocatable))

  def __repr__(self):
    return 'relocatable_path(anchor="%s", relocatable="%s")' % (
      abs(self.anchor), self.relocatable)

  def dirname(self):
    assert self.relocatable
    return relocatable_path(self._anchor, op.dirname(self.relocatable))

  def basename(self):
    return op.basename(self.relocatable)

  def normcase(self):
    return relocatable_path(self._anchor, op.normcase(self.relocatable))

  def __eq__(self, other):
    return (    self._anchor == other._anchor
            and self.relocatable == other.relocatable)

  # From the Python 2.7 documentation:
  #   There are no implied relationships among the comparison operators. The
  #   truth of x==y does not imply that x!=y is false. Accordingly, when
  #   defining __eq__(), one should also define __ne__() so that the operators
  #   will behave as expected.
  def __ne__(self, other):
    return not self == other

  def __hash__(self):
    return hash((self._anchor, self.relocatable))

class clean_out_directory(object):
  """
  Utility for cleaning out Phenix (etc.) project folders, which tend to
  accumulate large amounts of temporary files and other large objects (CCP4
  maps, .geo files, etc.) which we may not want to keep around forever.
  """
  def __init__(self,
      path_name,
      delete_kin_files=True,
      delete_geo_files=True,
      delete_map_files=True,
      delete_temp_dirs=True,
      delete_probe_files=True):
    self.path_name = path_name
    self.n_files = self.n_dirs = self.n_bytes = 0
    self.file_paths = []
    self.dir_paths = []
    for dirname, dirnames, filenames in os.walk(path_name):
      base_dir = os.path.basename(dirname)
      base_dir_name = base_dir.split("_")[0]
      # phenix-specific stuff
      if (base_dir_name in ["AutoSol","AutoBuild","AutoMR","LigandFit",
                            "StructureComparison",]):
        if ("TEMP0" in dirnames) and delete_temp_dirs :
          dirnames.remove("TEMP0")
          full_path = os.path.join(dirname, "TEMP0")
          self.delete_directory(full_path)
      elif (base_dir_name in ["Refine"]):
        if (".comm" in dirnames) and delete_temp_dirs and delete_probe_files :
          dirnames.remove(".comm")
          full_path = os.path.join(dirname, ".comm")
          self.delete_directory(full_path)
      elif (base_dir_name in ["FFT", "SuperposeMaps"]):
        continue
      for file_name in filenames :
        full_path = os.path.join(dirname, file_name)
        if ((file_name.endswith(".kin") and delete_kin_files) or
            (file_name.endswith(".geo") and delete_geo_files) or
            (file_name.endswith(".ccp4") and delete_map_files) or
            (file_name.endswith(".xplor") and delete_map_files) or
            (file_name == "probe.txt" and delete_probe_files)):
          self.delete_file(full_path)

  def delete_file(self, file_name):
    if not os.path.isfile(file_name) : return
    self.n_bytes += os.path.getsize(file_name)
    self.file_paths.append(file_name)
    self.n_files += 1

  def delete_directory(self, dir_name):
    self.n_bytes += directory_size(dir_name)
    self.dir_paths.append(dir_name)
    self.n_dirs += 1

  @property
  def n_total(self):
    return self.n_dirs + self.n_files

  def run(self, out=sys.stdout):
    self.show(out=out)
    print("Deleting all selected files and directories...", file=out)
    for file_name in self.file_paths :
      os.remove(file_name)
    for dir_name in self.dir_paths :
      shutil.rmtree(dir_name)

  def get_freed_space(self):
    locale.setlocale(locale.LC_ALL, 'C')
    n_kb = self.n_bytes / 1000
    if (n_kb > 10000):
      return locale.format_string("%.1f", n_kb / 1000, grouping=True) + " MB"
    else :
      return locale.format_string("%.1f", n_kb, grouping=True) + " KB"

  def show(self, out=sys.stdout):
    if (self.n_dirs > 0):
      print("The following %d directories will deleted:" % \
        self.n_dirs, file=out)
      for dir_name in sorted(self.dir_paths):
        print("  %s" % dir_name, file=out)
    if (self.n_files > 0):
      print("The following %d files will be deleted:" % \
        self.n_files, file=out)
      for file_name in sorted(self.file_paths):
        print("  %s" % file_name, file=out)
    if (self.n_bytes > 0):
      print("%s of disk space will be freed." % self.get_freed_space(), file=out)

# http://stackoverflow.com/questions/1392413/calculating-a-directory-size-using-python
def directory_size(path):
  total_size = 0
  seen = set()
  for dirpath, dirnames, filenames in os.walk(path):
    for f in filenames:
      fp = os.path.join(dirpath, f)
      try:
        stat = os.stat(fp)
      except OSError:
        continue
      if stat.st_ino in seen:
        continue
      seen.add(stat.st_ino)
      total_size += stat.st_size
  return total_size  # size in bytes


 *******************************************************************************


 *******************************************************************************
libtbx/phil/__init__.py
"Documentation: https://cci.lbl.gov/docs/cctbx/doc_low_phil/"

# was: https://cctbx.github.io/libtbx/libtbx.phil.html"

from __future__ import absolute_import, division, print_function
from libtbx.phil import tokenizer
from libtbx.str_utils import line_breaker
from libtbx.utils import Sorry, format_exception, import_python_object, to_str
from itertools import count
from libtbx import Auto, slots_getstate_setstate
from six.moves import cStringIO as StringIO
import math
import io
import os
import sys
import tokenize as python_tokenize
import warnings
import weakref

default_print_width = 79

class PhilDeprecationWarning(DeprecationWarning):
  pass
warnings.filterwarnings("always", category=PhilDeprecationWarning)

def is_reserved_identifier(string):
  if (len(string) < 5): return False
  return (string.startswith("__") and string.endswith("__"))

standard_identifier_start_characters = set()
for c in "_ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz":
  standard_identifier_start_characters.add(c)
standard_identifier_continuation_characters = set(
  standard_identifier_start_characters)
for c in ".0123456789":
  standard_identifier_continuation_characters.add(c)

def is_standard_identifier(string):
  if (len(string) == 0): return False
  if (string[0] not in standard_identifier_start_characters): return False
  for c in string[1:]:
    if (c not in standard_identifier_continuation_characters): return False
  sub_strings = string.split(".")
  if (len(sub_strings) > 1):
    for sub in sub_strings:
      if (not is_standard_identifier(sub)): return False
  return True

def is_plain_none(words):
  return (len(words) == 1
          and words[0].quote_token is None
          and words[0].value.lower() == "none")

def is_plain_auto(words):
  return (len(words) == 1
          and words[0].quote_token is None
          and words[0].value.lower() == "auto")

def tokenize_value_literal(input_string, source_info):
  return list(tokenizer.word_iterator(
    input_string=input_string,
    source_info=source_info,
    list_of_settings=[
      tokenizer.settings(contiguous_word_characters="")]))

class words_converters(object):

  phil_type = "words"

  def __str__(self): return self.phil_type

  def from_words(self, words, master):
    if (is_plain_none(words=words)): return None
    if (is_plain_auto(words=words)): return Auto
    return words

  def as_words(self, python_object, master):
    if (python_object is None):
      return [tokenizer.word(value="None")]
    if (python_object is Auto) or (isinstance(python_object, type(Auto))):
      return [tokenizer.word(value="Auto")]
    for word in python_object:
      assert isinstance(word, tokenizer.word)
    return python_object

def strings_from_words(words):
  if (is_plain_none(words=words)): return None
  if (is_plain_auto(words=words)): return Auto
  return [word.value for word in words]

def strings_as_words(python_object):
  if (python_object is None):
    return [tokenizer.word(value="None")]
  if (python_object is Auto) or (isinstance(python_object, type(Auto))):
    return [tokenizer.word(value="Auto")]
  words = []
  for value in python_object:
    if (is_standard_identifier(value)):
      words.append(tokenizer.word(value=value))
    else:
      words.append(tokenizer.word(value=value, quote_token='"'))
  return words

class strings_converters(object):

  phil_type = "strings"

  def __str__(self): return self.phil_type

  def from_words(self, words, master):
    return strings_from_words(words)

  def as_words(self, python_object, master):
    return strings_as_words(python_object)

def str_from_words(words):
  if (is_plain_none(words=words)): return None
  if (is_plain_auto(words=words)): return Auto
  return " ".join([word.value for word in words])

class str_converters(object):

  phil_type = "str"

  def __str__(self): return self.phil_type

  def from_words(self, words, master):
    return str_from_words(words=words)

  def as_words(self, python_object, master):
    if (python_object is None):
      return [tokenizer.word(value="None")]
    if (python_object is Auto) or (isinstance(python_object, type(Auto))):
      return [tokenizer.word(value="Auto")]
    return [tokenizer.word(value=python_object, quote_token='"')]

class qstr_converters(object):

  phil_type = "qstr"

  def __str__(self): return self.phil_type

  def from_words(self, words, master):
    if (is_plain_none(words=words)): return None
    if (is_plain_auto(words=words)): return Auto
    return " ".join([str(word) for word in words])

  def as_words(self, python_object, master):
    if (python_object is None):
      return [tokenizer.word(value="None")]
    if (python_object is Auto) or (isinstance(python_object, type(Auto))):
      return [tokenizer.word(value="Auto")]
    return tokenize_value_literal(
      input_string=python_object,
      source_info="python_object")

class path_converters(str_converters):

  phil_type = "path"

  def __str__(self): return self.phil_type

  def from_words(self, words, master):
    path = str_from_words(words=words)
    if path not in (None, Auto):
      path = os.path.expanduser(path)
    return path

class key_converters(str_converters):

  phil_type = "key"

  def __str__(self): return self.phil_type

def bool_from_words(words, path):
  value_string = str_from_words(words)
  if (value_string is None): return None
  if (value_string is Auto): return Auto
  value_lower = value_string.lower()
  if (value_lower in ["false", "no", "off", "0"]): return False
  if (value_lower in ["true", "yes", "on", "1"]): return True
  assert len(words) > 0
  raise RuntimeError(
    'One True or False value expected, %s="%s" found%s' % (
      path, value_string, words[0].where_str()))

class bool_converters(object):

  phil_type = "bool"

  def __str__(self): return self.phil_type

  def from_words(self, words, master):
    return bool_from_words(words=words, path=master.full_path())

  def as_words(self, python_object, master):
    if (python_object is None):
      return [tokenizer.word(value="None")]
    if (python_object is Auto) or (isinstance(python_object, type(Auto))):
      return [tokenizer.word(value="Auto")]
    if (python_object):
      return [tokenizer.word(value="True")]
    else:
      return [tokenizer.word(value="False")]

def number_from_value_string(value_string, words, path):
  if (value_string is None): return None
  if (value_string is Auto): return Auto
  value_string_lower = value_string.lower()
  # similar to libtbx.utils.number_from_string
  # (please review if making changes here)
  value_string_lower_strip = value_string.lower().strip()
  if (value_string_lower_strip in ["true", "false"]):
    raise RuntimeError(
      'Error interpreting %s="%s" as a numeric expression%s' % (
        path, value_string, words[0].where_str()))
  if (value_string_lower_strip == "none"): return None
  if (value_string_lower_strip == "auto"): return Auto
  try: return int(value_string)
  except KeyboardInterrupt: raise
  except Exception: pass
  try: return eval(value_string, math.__dict__, {})
  except KeyboardInterrupt: raise
  except Exception:
    raise RuntimeError(
      'Error interpreting %s="%s" as a numeric expression: %s%s' % (
        path, value_string, format_exception(), words[0].where_str()))

def number_from_words(words, path):
  return number_from_value_string(
    value_string=str_from_words(words), words=words, path=path)

def numbers_from_words(words, path):
  all_values_string = str_from_words(words)
  if (all_values_string is None or all_values_string is Auto):
    return all_values_string
  while True:
    have_changes = False
    for o,c in ["()", "[]"]:
      while (    all_values_string.startswith(o)
             and all_values_string.endswith(c)):
        all_values_string = all_values_string[1:-1].strip()
        have_changes = True
    if (not have_changes):
      break
  result = []
  for value_string in all_values_string \
                        .replace(",", " ") \
                        .replace(";", " ") \
                        .split():
    result.append(number_from_value_string(
      value_string=value_string, words=words, path=path))
  return result

def int_from_number(number, words, path):
  if (isinstance(number, int)): return number
  if (isinstance(number, float)
      and round(number) == number):
    return int(number)
  raise RuntimeError(
    'Error interpreting %s="%s" as an integer expression%s' % (
      path, str_from_words(words), words[0].where_str()))

def float_from_number(number, words, path):
  if (isinstance(number, float)): return number
  if (isinstance(number, int)): return float(number)
  raise RuntimeError(
    'Error interpreting %s="%s" as a floating-point expression%s' % (
      path, str_from_words(words), words[0].where_str()))

def int_from_words(words, path):
  result = number_from_words(words=words, path=path)
  if (result is None or result is Auto):
    return result
  return int_from_number(number=result, words=words, path=path)

def float_from_words(words, path):
  result = number_from_words(words=words, path=path)
  if (result is None or result is Auto):
    return result
  return float_from_number(number=result, words=words, path=path)

class _check_value_base(object):

  def _check_value(self, value, path_producer, words=None):
    def where_str():
      if (words is None): return ""
      return words[0].where_str()
    if (self.value_min is not None and value < self.value_min):
      raise RuntimeError(
        "%s element is less than the minimum allowed value:"
        " %s < %s%s"
          % (path_producer(), self._value_as_str(value=value),
             self._value_as_str(value=self.value_min), where_str()))
    if (self.value_max is not None and value > self.value_max):
      raise RuntimeError(
        "%s element is greater than the maximum allowed value:"
        " %s > %s%s"
          % (path_producer(), self._value_as_str(value=value),
             self._value_as_str(value=self.value_max), where_str()))

class number_converters_base(_check_value_base):

  def __init__(self,
      value_min=None,
      value_max=None,
      allow_none=True):
    if (value_min is not None and value_max is not None):
      assert value_min <= value_max
    self.value_min = value_min
    self.value_max = value_max
    self.allow_none = allow_none

  def __setstate__(self, state):
    # When unpickling ensure allow_none is set. Entire function is for
    # backwards-compatibility purposes only. 20180308
    self.allow_none = True
    for key, value in state.items():
      setattr(self, key, value)

  def __str__(self):
    kwds = []
    if (self.value_min is not None):
      kwds.append("value_min=" + self._value_as_str(value=self.value_min))
    if (self.value_max is not None):
      kwds.append("value_max=" + self._value_as_str(value=self.value_max))
    if (self.allow_none):
      kwds.append("allow_none=True")
    if (len(kwds) != 0):
      return self.phil_type + "(" + ", ".join(kwds) + ")"
    return self.phil_type

  def from_words(self, words, master):
    path = master.full_path()
    value = self._value_from_words(words=words, path=master.full_path())
    if (value is None):
      if (self.allow_none):
        return value
      else:
        raise RuntimeError(
          "%s cannot be None" % path)
    elif (value is Auto): return value
    self._check_value(
      value=value, path_producer=master.full_path, words=words)
    return value

  def as_words(self, python_object, master):
    if (python_object is None):
      if (self.allow_none):
        return [tokenizer.word(value="None")]
      else:
        raise RuntimeError(
          "%s cannot be None" % master.full_path())
    if (python_object is Auto) or (isinstance(python_object, type(Auto))):
      return [tokenizer.word(value="Auto")]
    return [tokenizer.word(value=self._value_as_str(value=python_object))]

class int_converters(number_converters_base):

  phil_type = "int"

  def _value_from_words(self, words, path):
    return int_from_words(words=words, path=path)

  def _value_as_str(self, value):
    return "%d" % value

class float_converters(number_converters_base):

  phil_type = "float"

  def _value_from_words(self, words, path):
    return float_from_words(words=words, path=path)

  def _value_as_str(self, value):
    return "%.10g" % value

class numbers_converters_base(_check_value_base):

  def __init__(self,
      size=None,
      size_min=None,
      size_max=None,
      value_min=None,
      value_max=None,
      allow_none_elements=False,
      allow_auto_elements=False):
    assert size is None or (size_min is None and size_max is None)
    if (size is not None):
      assert size > 0
      size_min = size
      size_max = size
    else:
      if (size_min is not None):
        assert size_min > 0
      if (size_max is not None):
        assert size_max > 0
        if (size_min is not None):
          assert size_min <= size_max
    if (value_min is not None and value_max is not None):
      assert value_min <= value_max
    self.size_min = size_min
    self.size_max = size_max
    self.value_min = value_min
    self.value_max = value_max
    self.allow_none_elements = allow_none_elements
    self.allow_auto_elements = allow_auto_elements

  def __str__(self):
    kwds = []
    if (self.size_min == self.size_max):
      if (self.size_min is not None):
        kwds.append("size=%d" % self.size_min)
    else:
      if (self.size_min is not None):
        kwds.append("size_min=%d" % self.size_min)
      if (self.size_max is not None):
        kwds.append("size_max=%d" % self.size_max)
    if (self.value_min is not None):
      kwds.append("value_min=" + self._value_as_str(value=self.value_min))
    if (self.value_max is not None):
      kwds.append("value_max=" + self._value_as_str(value=self.value_max))
    if (self.allow_none_elements):
      kwds.append("allow_none_elements=True")
    if (self.allow_auto_elements):
      kwds.append("allow_auto_elements=True")
    if (len(kwds) != 0):
      return self.phil_type + "(" + ", ".join(kwds) + ")"
    return self.phil_type

  def _check_size(self, size, path_producer, words=None):
    def where_str():
      if (words is None): return ""
      return words[0].where_str()
    if (self.size_max is not None and size > self.size_max):
      if (self.size_max == self.size_min):
        precise = "exactly %d required"
      else:
        precise = "%d allowed at most"
      raise RuntimeError(
        "Too many values for %s: %d given, %s%s"
          % (path_producer(), size, (precise%self.size_max), where_str()))
    if (self.size_min is not None and size < self.size_min):
      if (self.size_max == self.size_min):
        precise = "exactly"
      else:
        precise = "at least"
      raise RuntimeError(
        "Not enough values for %s: %d given, %s %d required%s"
          % (path_producer(), size, precise, self.size_min, where_str()))

  def from_words(self, words, master):
    path = master.full_path()
    numbers = numbers_from_words(words=words, path=path)
    if (numbers is None or numbers is Auto): return numbers
    self._check_size(
      size=len(numbers), path_producer=master.full_path, words=words)
    def where_str():
      if (words is None): return ""
      return words[0].where_str()
    result = []
    for number in numbers:
      if   (number is None):
        if (self.allow_none_elements):
          value = number
        else:
          raise RuntimeError(
            "%s element cannot be None%s" % (path, where_str()))
      elif (number is Auto):
        if (self.allow_auto_elements):
          value = number
        else:
          raise RuntimeError(
            "%s element cannot be Auto%s" % (path, where_str()))
      else:
        value = self._value_from_number(number=number, words=words, path=path)
        self._check_value(
          value=value, path_producer=master.full_path, words=words)
      result.append(value)
    return result

  def as_words(self, python_object, master):
    if (python_object is None):
      return [tokenizer.word(value="None")]
    # XXX note that pickling the object will lose the identity of Auto, so
    # we also need to check the type
    if (python_object is Auto) or (isinstance(python_object, type(Auto))):
      return [tokenizer.word(value="Auto")]
    self._check_size(
      size=len(python_object), path_producer=master.full_path)
    result = []
    for value in python_object:
      self._check_value(value=value, path_producer=master.full_path)
      if (value is None):
        if (self.allow_none_elements):
          result.append(tokenizer.word(value="None"))
        else:
          raise RuntimeError(
            "%s element cannot be None" % master.full_path())
      elif (value is Auto):
        if (self.allow_auto_elements):
          result.append(tokenizer.word(value="Auto"))
        else:
          raise RuntimeError(
            "%s element cannot be Auto" % master.full_path())
      else:
        result.append(tokenizer.word(value=self._value_as_str(value=value)))
    return result

class ints_converters(numbers_converters_base):

  phil_type = "ints"

  def _value_from_number(self, number, words, path):
    return int_from_number(number=number, words=words, path=path)

  def _value_as_str(self, value):
    return "%d" % value

class floats_converters(numbers_converters_base):

  phil_type = "floats"

  def _value_from_number(self, number, words, path):
    return float_from_number(number=number, words=words, path=path)

  def _value_as_str(self, value):
    return "%.10g" % value

class choice_converters(object):

  phil_type = "choice"

  def __init__(self, multi=False):
    self.multi = multi

  def __str__(self):
    if (self.multi): return self.phil_type+"(multi=True)"
    return self.phil_type

  def from_words(self, words, master):
    if (is_plain_auto(words=words)):
      result = Auto
    elif (self.multi):
      result = []
      for word in words:
        if (word.value.startswith("*")):
          result.append(word.value[1:])
      if (len(result) == 0
          and master.optional is not None and not master.optional):
        raise RuntimeError(
          "Unspecified choice for %s:"
          " at least one choice must be selected%s" % (
            master.full_path(), words[0].where_str()))
    else:
      result = None
      for word in words:
        if (word.value.startswith("*")):
          if (result is not None):
            raise RuntimeError(
              "Multiple choices for %s;"
              " only one choice can be selected%s" % (
                master.full_path(), words[0].where_str()))
          result = word.value[1:]
      if (result is None
          and (master.optional is not None and not master.optional)):
        raise RuntimeError(
          "Unspecified choice for %s:"
          " exactly one choice must be selected%s" % (
            master.full_path(), words[0].where_str()))
    return result

  def as_words(self, python_object, master):
    if (python_object is Auto) or (isinstance(python_object, type(Auto))):
      return [tokenizer.word(value="Auto")]
    assert not self.multi or python_object is not None
    if (self.multi):
      use_flags = dict([(value, False) for value in python_object])
    n_choices = 0
    def raise_improper_master():
      raise RuntimeError("Improper master choice definition: %s%s" % (
        master.as_str().rstrip(), master.words[0].where_str()))
    words = []
    for word in master.words:
      if (word.value.startswith("*")): value = word.value[1:]
      else: value = word.value
      if (python_object is not None):
        if (not self.multi):
          if (value == python_object):
            value = "*" + value
            n_choices += 1
            if (n_choices > 1): raise_improper_master()
        else:
          if (value in use_flags):
            if (use_flags[value]): raise_improper_master()
            use_flags[value] = True
            value = "*" + value
            n_choices += 1
      words.append(tokenizer.word(
        value=value, quote_token=word.quote_token))
    if (not self.multi):
      if (n_choices == 0
          and ((master.optional is not None and not master.optional)
               or python_object is not None)):
        raise RuntimeError("Invalid choice: %s=%s" % (
          master.full_path(), str(python_object)))
    else:
      unused = []
      for value,use_flag in use_flags.items():
        if (not use_flag): unused.append(value)
      n = len(unused)
      if (n != 0):
        raise RuntimeError("Invalid %s: %s=%s" % (
          str(self), master.full_path(), str(unused)))
      if (n_choices == 0
          and (master.optional is not None and not master.optional)):
        raise RuntimeError(
          "Empty list for mandatory %s: %s" % (
            str(self), master.full_path()))
    return words

  def fetch(self, source_words, master, ignore_errors=False):
    assert not is_plain_none(words=master.words)
    assert not is_plain_auto(words=master.words)
    if (is_plain_auto(words=source_words)):
      return master.customized_copy(words=[tokenizer.word(value="Auto")])
    flags = {}
    for word in master.words:
      if (word.value.startswith("*")): value = word.value[1:]
      else: value = word.value
      flags[value.lower()] = False
    if (   (master.optional is not None and not master.optional)
        or not is_plain_none(words=source_words)):
      have_quote_or_star = False
      have_plus = False
      for word in source_words:
        if (word.quote_token is not None or word.value.startswith("*")):
          have_quote_or_star = True
          break
        if (word.value.find("+") >= 0):
          have_plus = True
      process_plus = False
      if (not have_quote_or_star and have_plus):
        values = "".join([word.value for word in source_words]).split("+")
        for value in values[1:]:
          if (len(value.strip()) == 0):
            break
        else:
          process_plus = True
      def raise_not_a_possible_choice(value):
        raise Sorry(
          "Not a possible choice for %s: %s%s\n" % (
            master.full_path(), value, word.where_str())
          + "  Possible choices are:\n"
          + "    " + "\n    ".join([w.value for w in master.words]))
      if (process_plus):
        for word in source_words:
          for value in word.value.split("+"):
            if (len(value) == 0): continue
            if (value not in flags):
              raise_not_a_possible_choice(value)
            flags[value.lower()] = True
      else:
        for word in source_words:
          if (word.value.startswith("*")):
            value = word.value[1:]
            flag = True
          else:
            value = word.value
            if (len(source_words) == 1):
              flag = True
            else:
              flag = False
          if (flag and value.lower() not in flags):
            if (ignore_errors):
              continue
            else :
              raise_not_a_possible_choice(value)
          flags[value.lower()] = flag
    words = []
    for word in master.words:
      if (word.value.startswith("*")): value = word.value[1:]
      else: value = word.value
      if (flags[value.lower()]): value = "*" + value
      words.append(tokenizer.word(
        value=value,
        quote_token=word.quote_token,
        line_number=word.line_number,
        source_info=word.source_info))
    return master.customized_copy(words=words)

def get_converters_phil_type(converters):
  result = getattr(converters, "phil_type", None)
  if (result is None):
    result = str(converters()) # backward compatibility
  return result

def extended_converter_registry(additional_converters, base_registry=None):
  if (base_registry is None): base_registry = default_converter_registry
  result = dict(base_registry)
  for converters in additional_converters:
    result[get_converters_phil_type(converters)] = converters
  return result

default_converter_registry = extended_converter_registry(
  additional_converters = [
    words_converters,
    strings_converters,
    str_converters,
    qstr_converters,
    path_converters,
    key_converters,
    bool_converters,
    int_converters,
    float_converters,
    ints_converters,
    floats_converters,
    choice_converters],
  base_registry={})

def extract_args(*args, **keyword_args):
  return args, keyword_args

def normalize_call_expression(expression):
  result = []
  p = ""
  for info in python_tokenize.generate_tokens(StringIO(expression).readline):
    t = info[1]
    if (len(t) == 0): continue
    if (    t != "."
        and t[0] in standard_identifier_start_characters
        and len(p) > 0
        and p != "."
        and p[-1] in standard_identifier_continuation_characters):
      result.append(" ")
    result.append(t)
    if (t[0] == ","):
      result.append(" ")
    p = t
  return "".join(result)

def definition_converters_from_words(
      words,
      converter_registry,
      converter_cache):
  if (is_plain_none(words=words)): return None
  if (is_plain_auto(words=words)): return Auto
  call_expression_raw = str_from_words(words).strip()
  try:
    call_expression = normalize_call_expression(expression=call_expression_raw)
  except python_tokenize.TokenError as e:
    raise RuntimeError(
      'Error evaluating definition type "%s": %s%s' % (
        call_expression_raw, str(e), words[0].where_str()))
  converters_weakref = converter_cache.get(call_expression, None)
  if (converters_weakref is not None):
    converters_instance = converters_weakref()
    if (converters_instance is not None):
      return converters_instance
  flds = call_expression.split("(", 1)
  converters = converter_registry.get(flds[0], None)
  if (converters is not None):
    if (len(flds) == 1): parens = "()"
    else:                parens = ""
    try:
      converters_instance = eval(
        call_expression+parens, math.__dict__, {flds[0]: converters})
    except KeyboardInterrupt: raise
    except Exception:
      raise RuntimeError(
        'Error constructing definition type "%s": %s%s' % (
        call_expression, format_exception(), words[0].where_str()))
  else:
    import_path = flds[0] + "_phil_converters"
    if (len(flds) == 1):
      keyword_args = {}
    else:
      extractor = "__extract_args__(" + flds[1]
      try:
        args, keyword_args = eval(
          extractor, math.__dict__, {"__extract_args__": extract_args})
      except KeyboardInterrupt: raise
      except Exception:
        raise RuntimeError(
          'Error evaluating definition type "%s": %s%s' % (
          call_expression, format_exception(), words[0].where_str()))
    try:
      imported = import_python_object(
        import_path=import_path,
        error_prefix='.type=%s: ' % call_expression,
        target_must_be="; target must be a callable Python object",
        where_str=words[0].where_str())
    except (ValueError, ImportError):
      raise RuntimeError(
        'Unexpected definition type: "%s"%s' % (
          call_expression, words[0].where_str()))
    if (not callable(imported.object)):
      raise TypeError(
        '"%s" is not a callable Python object%s' % (
          import_path, words[0].where_str()))
    try:
      converters_instance = imported.object(**keyword_args)
    except KeyboardInterrupt: raise
    except Exception:
      raise RuntimeError(
        'Error constructing definition type "%s": %s%s' % (
        call_expression, format_exception(), words[0].where_str()))
  converter_cache[call_expression] = weakref.ref(converters_instance)
  return converters_instance

def full_path(self):
  result = [self.name]
  pps = self.primary_parent_scope
  while (pps is not None):
    if (pps.name == ""): break
    result.append(pps.name)
    pps = pps.primary_parent_scope
  result.reverse()
  return ".".join(result)

def alias_path(self):
  if (self.alias is not None):
    return self.alias
  have_alias = False
  result = [self.name]
  pps = self.primary_parent_scope
  while (pps is not None):
    if (pps.alias is not None):
      result.append(pps.alias)
      have_alias = True
      break
    elif (pps.name == ""):
      break
    else :
      result.append(pps.name)
    pps = pps.primary_parent_scope
  if (not have_alias) : return None
  result.reverse()
  return ".".join(result)

def show_attributes(self, out, prefix, attributes_level, print_width):
  if (attributes_level <= 0): return
  for name in self.attribute_names:
    value = getattr(self, name)
    if (name == "deprecated") and (not value):
      continue # only show .deprecated if True
    if ((name == "help" and value is not None)
        or (name == "alias" and value is not None)
        or (value is not None and attributes_level > 1)
        or attributes_level > 2):
      if (name == "alias") and (value is None):
        continue
      if (not isinstance(value, str)):
        # Python 2.2 workaround
        if (name in ["optional", "multiple", "disable_add", "disable_delete"]):
          if   (value is False): value = "False"
          elif (value is True):  value = "True"
        print(prefix+"  ."+name, "=", value, file=out)
      else:
        indent = " " * (len(prefix) + 3 + len(name) + 3)
        fits_on_one_line = len(indent+value) < print_width
        if (not is_standard_identifier(value) or not fits_on_one_line):
          value = str(tokenizer.word(value=value, quote_token='"'))
          fits_on_one_line = len(indent+value) < print_width
        if (fits_on_one_line):
          print(prefix+"  ."+name, "=", value, file=out)
        else:
          is_first = True
          for block in line_breaker(value[1:-1], print_width-2-len(indent)):
            if (is_first):
              print(prefix+"  ."+name, "=", '"'+block+'"', file=out)
              is_first = False
            else:
              print(indent+'"'+block+'"', file=out)

class object_locator(object):

  def __init__(self, parent, path, object):
    self.parent = parent
    self.path = path
    self.object = object

  def __str__(self):
    return "%s%s" % (self.path, self.object.where_str)

# is_template (set by .fetch() and .format() methods of definition or scope):
#   0: not a template
#  -1: template but there are other copies
#   1: template and there are no copies

class try_tokenize_proxy(object):

  def __init__(self, error_message, tokenized):
    self.error_message = error_message
    self.tokenized = tokenized

class try_extract_proxy(object):

  def __init__(self, error_message, extracted):
    self.error_message = error_message
    self.extracted = extracted

class try_format_proxy(object):

  def __init__(self, error_message, formatted):
    self.error_message = error_message
    self.formatted = formatted

class definition(slots_getstate_setstate):

  is_definition = True
  is_scope = False

  attribute_names = [
    "help", "caption", "short_caption", "optional", "type", "multiple",
    "input_size", "style", "expert_level", "deprecated", "alias",]

  __slots__ = ["name", "words", "primary_id", "primary_parent_scope",
               "is_disabled", "is_template", "where_str", "merge_names",
               "tmp"] + attribute_names

  def __init__(self,
        name,
        words,
        primary_id=None,
        primary_parent_scope=None,
        is_disabled=False,
        is_template=0,
        where_str="",
        merge_names=False,
        tmp=None,
        help=None,
        caption=None,
        short_caption=None,
        optional=None,
        type=None,
        multiple=None,
        input_size=None,
        style=None,
        expert_level=None,
        deprecated=None,
        alias=None):
    if (is_reserved_identifier(name)):
      raise RuntimeError('Reserved identifier: "%s"%s' % (name, where_str))
    if (name != "include" and "include" in name.split(".")):
      raise RuntimeError('Reserved identifier: "include"%s' % where_str)
    self.name = name
    self.words = words
    self.primary_id = primary_id
    self.primary_parent_scope = primary_parent_scope
    self.is_disabled = is_disabled
    self.is_template = is_template
    self.where_str = where_str
    self.merge_names = merge_names
    self.tmp = tmp
    self.help = help
    self.caption = caption
    self.short_caption = short_caption
    self.optional = optional
    self.type = type
    self.multiple = multiple
    self.input_size = input_size
    self.style = style
    self.expert_level = expert_level
    self.deprecated = deprecated
    self.alias = alias

  def __setstate__(self, *args, **kwds):
    slots_getstate_setstate.__setstate__(self, *args, **kwds)
    # XXX backwards compatibility 2012-03-27
    if (not hasattr(self, "deprecated")) : setattr(self, "deprecated", None)

  def copy(self):
    keyword_args = {}
    for keyword in self.__slots__:
      keyword_args[keyword] = getattr(self, keyword)
    return definition(**keyword_args)

  def customized_copy(self, name=None, words=None):
    result = self.copy()
    if (name is not None): result.name = name
    if (words is not None): result.words = words
    result.is_template = 0
    return result

  def full_path(self):
    return full_path(self)

  def alias_path(self):
    return alias_path(self)

  def assign_tmp(self, value, active_only=False):
    if (not active_only or not self.is_disabled):
      self.tmp = value

  def fetch_value(self, source, diff_mode=False,
      skip_incompatible_objects=False):
    if (source.is_scope):
      if (skip_incompatible_objects):
        return self.copy()
      raise RuntimeError(
        'Incompatible parameter objects: definition "%s"%s vs. scope "%s"%s' %
          (self.name, self.where_str, source.name, source.where_str))
    source.tmp = True
    source = source.resolve_variables(diff_mode=diff_mode)
    type_fetch = getattr(self.type, "fetch", None)
    if (self.deprecated):
      # issue warning if value is not the default, otherwise return None so
      # this parameter stays invisible to users
      result_as_str = strings_from_words(source.words)
      self_as_str = strings_from_words(self.words)
      if (result_as_str != self_as_str):
        warnings.warn("%s is deprecated - not recommended for use." % \
          self.full_path(), PhilDeprecationWarning)
      else :
        return None
    if (type_fetch is None):
      return self.customized_copy(words=source.words)
    if (self.type.phil_type == "choice"):
      return type_fetch(source_words=source.words, master=self,
        ignore_errors=skip_incompatible_objects)
    else :
      return type_fetch(source_words=source.words, master=self)

  def fetch_diff(self, source, skip_incompatible_objects=False):
    result = self.fetch_value(source=source, diff_mode=True,
      skip_incompatible_objects=skip_incompatible_objects)
    result_as_str = self.extract_format(source=result).as_str()
    self_as_str = self.extract_format().as_str()
    if (result_as_str == self_as_str): result = None
    return result

  def fetch(self, source, diff=False, skip_incompatible_objects=False):
    if (diff): return self.fetch_diff(source=source,
      skip_incompatible_objects=skip_incompatible_objects)
    return self.fetch_value(source=source,
      skip_incompatible_objects=skip_incompatible_objects)

  def has_attribute_with_name(self, name):
    return name in self.attribute_names

  def assign_attribute(self, name, words, converter_registry, converter_cache):
    assert self.has_attribute_with_name(name)
    if (name in ["optional", "multiple"]):
      value = bool_from_words(words=words, path="."+name)
    elif (name == "type"):
      value = definition_converters_from_words(
        words=words,
        converter_registry=converter_registry,
        converter_cache=converter_cache)
    elif (name in ["input_size", "expert_level"]):
      value = int_from_words(words=words, path="."+name)
    else:
      value = str_from_words(words)
    setattr(self, name, value)

  def show(self,
        out=None,
        merged_names=[],
        prefix="",
        expert_level=None,
        attributes_level=0,
        print_width=None):
    if (self.is_template < 0 and attributes_level < 2): return
    elif (self.deprecated and attributes_level < 3) : return
    if (self.expert_level is not None
        and expert_level is not None
        and expert_level >= 0
        and self.expert_level > expert_level): return
    if (out is None): out = sys.stdout
    if (print_width is None): print_width = default_print_width
    if (self.is_disabled): hash = "!"
    else:                  hash = ""
    line = prefix + hash + ".".join(merged_names + [self.name])
    if (self.name != "include"): line += " ="
    indent = " " * len(line)
    if (self.deprecated):
      print(prefix + "# WARNING: deprecated parameter", file=out)
    for word in self.words:
      line_plus = line + " " + str(word)
      if (len(line_plus) > print_width-2 and len(line) > len(indent)):
        print(line + " \\", file=out)
        line = indent + " " + str(word)
      else:
        line = line_plus
    print(line, file=out)
    show_attributes(
      self=self,
      out=out,
      prefix=prefix,
      attributes_level=attributes_level,
      print_width=print_width)

  def as_str(self,
        prefix="",
        expert_level=None,
        attributes_level=0,
        print_width=None):
    out = StringIO()
    self.show(
      out=out,
      prefix=prefix,
      expert_level=expert_level,
      attributes_level=attributes_level,
      print_width=print_width)
    return out.getvalue()

  def _all_definitions(self,
        suppress_multiple,
        select_tmp,
        parent,
        parent_path,
        result):
    if (suppress_multiple and self.multiple): return
    if (select_tmp is not None and not (self.tmp == select_tmp)): return
    if (self.name == "include"): return
    result.append(object_locator(
      parent=parent, path=parent_path+self.name, object=self))

  def get_without_substitution(self, path, alias_path=None):
    if (self.is_disabled or (self.name != path and
        ((alias_path is None) or (self.name != alias_path)))) : return []
    return [self]

  def _type_from_words(self):
    try: return self.type.from_words
    except AttributeError:
      raise RuntimeError('.type=%s does not have a from_words method%s: %s' %
        (str(self.type), self.where_str, format_exception()))

  def try_extract(self):
    if (self.type is None):
      return try_extract_proxy(
        error_message=None,
        extracted=strings_from_words(words=self.words))
    type_from_words = self._type_from_words()
    try:
      return try_extract_proxy(
        error_message=None,
        extracted=type_from_words(self.words, master=self))
    except RuntimeError as e:
      return try_extract_proxy(error_message=str(e), extracted=None)

  def extract(self, parent=None):
    if (self.type is None):
      return strings_from_words(words=self.words)
    return self._type_from_words()(self.words, master=self)

  def format(self, python_object):
    if (self.type is None):
      words = strings_as_words(python_object=python_object)
    else:
      try: type_as_words = self.type.as_words
      except AttributeError:
        raise RuntimeError('.type=%s does not have an as_words method%s: %s' %
          (str(self.type), self.where_str, format_exception()))
      words = type_as_words(python_object=python_object, master=self)
    return self.customized_copy(words=words)

  def extract_format(self, source=None):
    if (source is None): source = self
    return self.format(python_object=source.extract())

  def try_extract_format(self):
    proxy = self.try_extract()
    if (proxy.error_message is not None):
      return try_format_proxy(
        error_message=proxy.error_message, formatted=None)
    return try_format_proxy(
      error_message=None,
      formatted=self.format(python_object=proxy.extracted))

  def try_tokenize(self, input_string, source_info=None):
    try:
      words = tokenize_value_literal(
        input_string=input_string,
        source_info=source_info)
    except RuntimeError as e:
      return try_tokenize_proxy(
        error_message=str(e),
        tokenized=None)
    if (len(words) == 0):
      words = [tokenizer.word(value="None")]
    return try_tokenize_proxy(
      error_message=None,
      tokenized=self.customized_copy(words=words))

  def _validate(self, input_string, source_info, call):
    proxy = self.try_tokenize(
      input_string=input_string, source_info=source_info)
    if (proxy.error_message is not None):
      return proxy
    return getattr(proxy.tokenized, call)()

  def validate(self, input_string, source_info=None):
    return self._validate(input_string=input_string, source_info=source_info,
      call="try_extract")

  def validate_and_format(self, input_string, source_info=None):
    return self._validate(input_string=input_string, source_info=source_info,
      call="try_extract_format")

  def unique(self):
    return self

  def resolve_variables(self, diff_mode=False):
    new_words = []
    for word in self.words:
      if (word.quote_token == "'"):
        new_words.append(word)
        continue
      substitution_proxy = variable_substitution_proxy(word)
      for fragment in substitution_proxy.fragments:
        if (not fragment.is_variable):
          fragment.result = tokenizer.word(
            value=fragment.value, quote_token='"')
          continue
        variable_words = None
        if (self.primary_parent_scope is not None):
          substitution_source = self.primary_parent_scope.lexical_get(
            path=fragment.value, stop_id=self.primary_id)
          if (substitution_source is not None):
            if (not substitution_source.is_definition):
              raise RuntimeError("Not a definition: $%s%s" % (
                fragment.value, word.where_str()))
            substitution_source.tmp = True
            variable_words = substitution_source.resolve_variables().words
        if (variable_words is None):
          if (diff_mode):
            env_var = "$"+fragment.value
          else:
            env_var = os.environ.get(fragment.value, None)
          if (env_var is not None):
            variable_words = [tokenizer.word(
              value=env_var,
              quote_token='"',
              source_info='environment: "%s"'%fragment.value)]
        if (variable_words is None):
          raise RuntimeError("Undefined variable: $%s%s" % (
            fragment.value, word.where_str()))
        if (not substitution_proxy.force_string):
          fragment.result = variable_words
        else:
          fragment.result = tokenizer.word(
            value=" ".join([word.value for word in variable_words]),
            quote_token='"')
      new_words.extend(substitution_proxy.get_new_words())
    return self.customized_copy(words=new_words)

class scope_extract_call_proxy_object(object):

  def __init__(self, where_str, expression, callable, keyword_args):
    self.where_str = where_str
    self.expression = expression
    self.callable = callable
    self.keyword_args = keyword_args

  def __str__(self):
    return self.expression

def scope_extract_call_proxy(full_path, words, cache):
  if (is_plain_none(words=words)): return None
  if (is_plain_auto(words=words)): return Auto
  call_expression_raw = str_from_words(words).strip()
  try:
    call_expression = normalize_call_expression(expression=call_expression_raw)
  except python_tokenize.TokenError as e:
    raise RuntimeError('scope "%s" .call=%s: %s%s' % (
      full_path, call_expression_raw, str(e), words[0].where_str()))
  call_proxy = cache.get(call_expression, None)
  if (call_proxy is None):
    where_str = words[0].where_str()
    flds = call_expression.split("(", 1)
    import_path = flds[0]
    if (len(flds) == 1):
      keyword_args = {}
    else:
      extractor = "__extract_args__(" + flds[1]
      try:
        args, keyword_args = eval(
          extractor, math.__dict__, {"__extract_args__": extract_args})
      except KeyboardInterrupt: raise
      except Exception:
        raise RuntimeError('scope "%s" .call=%s: %s%s' % (
          full_path, call_expression, format_exception(), where_str))
    imported = import_python_object(
      import_path=import_path,
      error_prefix='scope "%s" .call: ' % full_path,
      target_must_be="; target must be a callable Python object",
      where_str=where_str)
    if (not callable(imported.object)):
      raise TypeError(
        'scope "%s" .call: "%s" is not a callable Python object%s' % (
          full_path, import_path, where_str))
    call_proxy = scope_extract_call_proxy_object(
      where_str=where_str,
      expression=call_expression,
      callable=imported.object,
      keyword_args=keyword_args)
    cache[call_expression] = call_proxy
  return call_proxy

class scope_extract_attribute_error(object): pass
class scope_extract_is_disabled(object): pass

class scope_extract_list(list):

  def __init__(self, optional):
    self.__phil_optional__ = optional
    list.__init__(self)

class scope_extract(object):

  def __init__(self, name, parent, call):
    object.__setattr__(self, "__phil_name__", name)
    object.__setattr__(self, "__phil_parent__", parent)
    object.__setattr__(self, "__phil_call__", call)

  def __phil_path__(self, object_name=None):
    if (   self.__phil_parent__ is None
        or self.__phil_parent__.__phil_name__ is None
        or self.__phil_parent__.__phil_name__ == ""):
      if (object_name is None):
        return self.__phil_name__
      elif (   self.__phil_name__ is None
            or self.__phil_name__ == ""):
        return object_name
      return self.__phil_name__ + "." + object_name
    result = [
      self.__phil_parent__.__phil_path__(),
      self.__phil_name__]
    if (object_name is not None):
      result.append(object_name)
    return ".".join(result)

  def __phil_path_and_value__(self, object_name):
    return (
      self.__phil_path__(object_name=object_name),
      getattr(self, object_name))

  def __setattr__(self, name, value):
    if (getattr(self, name, scope_extract_attribute_error)
          is scope_extract_attribute_error):
      pp = self.__phil_path__()
      if (pp == ""): pp = name
      else:          pp += "." + name
      raise AttributeError(
        'Assignment to non-existing attribute "%s"\n' % pp
          + '  Please correct the attribute name, or to create\n'
          + '  a new attribute use: obj.__inject__(name, value)')
    object.__setattr__(self, name, value)

  def __inject__(self, name, value):
    if (getattr(self, name, scope_extract_attribute_error)
          is not scope_extract_attribute_error):
      pp = self.__phil_path__()
      if (pp == ""): pp = name
      else:          pp += "." + name
      raise AttributeError(
        'Attribute "%s" exists already.' % pp)
    object.__setattr__(self, name, value)

  def __phil_join__(self, other):
    for key,other_value in other.__dict__.items():
      if (is_reserved_identifier(key)): continue
      self_value = self.__dict__.get(key, None)
      if (self_value is None):
        self.__dict__[key] = other_value
      elif (isinstance(self_value, scope_extract_list)):
        assert isinstance(other_value, scope_extract_list)
        for item in other_value:
          if (item is not None):
            self_value.append(item)
        if (len(self_value) > 1 and self_value[0] is None):
          del self_value[0]
      else:
        self_value_phil_join = getattr(self_value, "__phil_join__", None)
        if (self_value_phil_join is None):
          self.__dict__[key] = other_value
        else:
          self_value_phil_join(other_value)

  def __phil_set__(self, name, optional, multiple, value):
    assert not "." in name
    node = getattr(self, name, scope_extract_attribute_error)
    if (not multiple):
      if (value is scope_extract_is_disabled):
        value = None
      if (node is scope_extract_attribute_error
          or not isinstance(value, scope_extract)
          or not isinstance(node, scope_extract)):
        object.__setattr__(self, name, value)
      else:
        node.__phil_join__(value)
    else:
      if (node is scope_extract_attribute_error):
        node = scope_extract_list(optional=optional)
        object.__setattr__(self, name, node)
      if (not value is scope_extract_is_disabled
          and (value is not None or optional is not True)):
        node.append(value)

  def __phil_get__(self, name):
    assert not "." in name
    return getattr(self, name, scope_extract_attribute_error)

  def __call__(self, **keyword_args):
    call_proxy = self.__phil_call__
    if (call_proxy is None):
      raise RuntimeError('scope "%s" is not callable.' % self.__phil_path__())
    if (len(keyword_args) == 0):
      return call_proxy.callable(self, **call_proxy.keyword_args)
    effective_keyword_args = dict(call_proxy.keyword_args)
    effective_keyword_args.update(keyword_args)
    try:
      return call_proxy.callable(self, **effective_keyword_args)
    except KeyboardInterrupt: raise
    except Exception:
      raise RuntimeError('scope "%s" .call=%s execution: %s%s' % (
        self.__phil_path__(), call_proxy.expression, format_exception(),
        call_proxy.where_str))

class scope(slots_getstate_setstate):

  is_definition = False
  is_scope = True
  deprecated = False

  attribute_names = [
    "style",
    "help",
    "caption",
    "short_caption",
    "optional",
    "call",
    "multiple",
    "sequential_format",
    "disable_add",
    "disable_delete",
    "expert_level",
    "alias"]

  __slots__ = [
    "name",
    "objects",
    "primary_id",
    "primary_parent_scope",
    "is_disabled",
    "is_template",
    "where_str",
    "merge_names"] + attribute_names

  def __init__(self,
        name,
        objects=None,
        primary_id=None,
        primary_parent_scope=None,
        is_disabled=False,
        is_template=0,
        where_str="",
        merge_names=False,
        style=None,
        help=None,
        caption=None,
        short_caption=None,
        optional=None,
        call=None,
        multiple=None,
        sequential_format=None,
        disable_add=None,
        disable_delete=None,
        expert_level=None,
        alias=None):
    self.name = name
    self.objects = objects
    self.primary_id = primary_id
    self.primary_parent_scope = primary_parent_scope
    self.is_disabled = is_disabled
    self.is_template = is_template
    self.where_str = where_str
    self.merge_names = merge_names
    self.style = style
    self.help = help
    self.caption = caption
    self.short_caption = short_caption
    self.optional = optional
    self.call = call
    self.multiple = multiple
    self.sequential_format = sequential_format
    self.disable_add = disable_add
    self.disable_delete = disable_delete
    self.expert_level = expert_level
    self.alias = alias
    if (objects is None):
      self.objects = []
    if (is_reserved_identifier(name)):
      raise RuntimeError('Reserved identifier: "%s"%s' % (name, where_str))
    if ("include" in name.split(".")):
      raise RuntimeError('Reserved identifier: "include"%s' % where_str)
    if (sequential_format is not None):
      assert isinstance(sequential_format % 0, str)

  def copy(self):
    keyword_args = {}
    for keyword in self.__slots__:
      keyword_args[keyword] = getattr(self, keyword)
    return scope(**keyword_args)

  def customized_copy(self, name=None, objects=None):
    result = self.copy()
    if (name is not None): result.name = name
    if (objects is not None): result.objects = objects
    result.is_template = 0
    return result

  def is_empty(self):
    return len(self.objects) == 0

  def full_path(self):
    return full_path(self)

  def alias_path(self):
    return alias_path(self)

  def assign_tmp(self, value, active_only=False):
    if (not active_only):
      for object in self.objects:
        object.assign_tmp(value=value)
    else:
      for object in self.objects:
        if (self.is_disabled): continue
        object.assign_tmp(value=value, active_only=True)

  def adopt(self, object):
    assert len(object.name) > 0
    primary_parent_scope = self
    name_components = object.name.split(".")
    merge_names = False
    for name in name_components[:-1]:
      child_scope = scope(name=name)
      child_scope.merge_names = merge_names
      primary_parent_scope.adopt(child_scope)
      primary_parent_scope = child_scope
      merge_names = True
    if (len(name_components) > 1):
      object.name = name_components[-1]
      object.merge_names = True
    object.primary_parent_scope = primary_parent_scope
    primary_parent_scope.objects.append(object)

  def adopt_scope(self, other):
    assert self is not other, "Cannot adopt own scope"
    for active_object in other.active_objects():
      results = self.get_without_substitution(active_object.full_path())
      if len(results) == 0:
        self.adopt(active_object)
        continue
      for result in results:
        assert result.is_scope == active_object.is_scope
        if result.is_definition:
          # This parameter is defined in both phil scopes: replace definition
          # in self with the definition in other.
          primary_parent_scope = result.primary_parent_scope
          i = primary_parent_scope.objects.index(result)
          primary_parent_scope.objects[i] = active_object
          del result
        else:
          result.adopt_scope(active_object)

  def change_primary_parent_scope(self, new_value):
    objects = []
    for object in self.objects:
      obj = object.copy()
      obj.primary_parent_scope = new_value
      if obj.is_scope:
        obj = obj.change_primary_parent_scope(obj)
      objects.append(obj)
    return self.customized_copy(objects=objects)

  def has_attribute_with_name(self, name):
    return name in self.attribute_names

  def assign_attribute(self, name, words, scope_extract_call_proxy_cache):
    assert self.has_attribute_with_name(name)
    if (name in ["optional", "multiple", "disable_add", "disable_delete"]):
      value = bool_from_words(words, path="."+name)
    elif (name == "expert_level"):
      value = int_from_words(words=words, path="."+name)
    elif (name == "call"):
      value = scope_extract_call_proxy(
        full_path=self.full_path(),
        words=words,
        cache=scope_extract_call_proxy_cache)
    else:
      value = str_from_words(words)
      if (name == "style"):
        style = value
      elif (name == "sequential_format"):
        sequential_format = value
        if (sequential_format is not None):
          assert isinstance(sequential_format % 0, str)
    setattr(self, name, value)

  def active_objects(self):
    for object in self.objects:
      if (object.is_disabled): continue
      yield object

  def master_active_objects(self):
    names_object = {}
    for object in self.objects:
      if (object.is_disabled): continue
      master = names_object.setdefault(object.name, object)
      if (master is not object):
        if (master.multiple): continue
        if (object.is_definition):
          raise RuntimeError(
            "Duplicate definitions in master"
            " (first not marked with .multiple=True):\n"
            "  %s%s\n"
            "  %s%s" % (
              master.full_path(), master.where_str,
              object.full_path(), object.where_str))
      yield object

  def show(self,
        out=None,
        merged_names=[],
        prefix="",
        expert_level=None,
        attributes_level=0,
        print_width=None):
    if (self.is_template < 0 and attributes_level < 2): return
    if (self.expert_level is not None
        and expert_level is not None
        and expert_level >= 0
        and self.expert_level > expert_level): return
    if (out is None): out = sys.stdout
    if (print_width is None): print_width = default_print_width
    is_proper_scope = False
    if (len(self.name) == 0):
      assert len(merged_names) == 0
    elif (len(self.objects) > 0 and self.objects[0].merge_names):
      merged_names = merged_names + [self.name]
    else:
      is_proper_scope = True
      if (self.is_disabled): hash = "!"
      else:                  hash = ""
      out_attributes = StringIO()
      show_attributes(
        self=self,
        out=out_attributes,
        prefix=prefix,
        attributes_level=attributes_level,
        print_width=print_width)
      out_attributes = out_attributes.getvalue()
      merged_name = ".".join(merged_names + [self.name])
      merged_names = []
      if (len(out_attributes) == 0):
        print(prefix + hash + merged_name, "{", file=out)
      else:
        print(prefix + hash + merged_name, file=out)
        out.write(out_attributes)
        print(prefix+"{", file=out)
      prefix += "  "
    for object in self.objects:
      object.show(
        out=out,
        merged_names=merged_names,
        prefix=prefix,
        expert_level=expert_level,
        attributes_level=attributes_level,
        print_width=print_width)
    if (is_proper_scope):
      print(prefix[:-2] + "}", file=out)

  def as_str(self,
        prefix="",
        expert_level=None,
        attributes_level=0,
        print_width=None):
    out = StringIO()
    self.show(
      out=out,
      prefix=prefix,
      expert_level=expert_level,
      attributes_level=attributes_level,
      print_width=print_width)
    return out.getvalue()

  def _all_definitions(self,
        suppress_multiple,
        select_tmp,
        parent,
        parent_path,
        result):
    parent_path += self.name+"."
    for object in self.active_objects():
      if (suppress_multiple and object.multiple): continue
      object._all_definitions(
        suppress_multiple=suppress_multiple,
        select_tmp=select_tmp,
        parent=self,
        parent_path=parent_path,
        result=result)

  def all_definitions(self, suppress_multiple=False, select_tmp=None):
    result = []
    for object in self.active_objects():
      if (suppress_multiple and object.multiple): continue
      object._all_definitions(
        suppress_multiple=suppress_multiple,
        select_tmp=select_tmp,
        parent=self,
        parent_path="",
        result=result)
    return result

  def get_without_substitution(self, path, alias_path=None):
    if (self.is_disabled):
      return []
    if (len(self.name) == 0):
      if (len(path) == 0): return self.objects
    elif (self.name == path) or (self.name == alias_path):
      return [self]
    elif (path.startswith(self.name+".")):
      path = path[len(self.name)+1:]
    elif (alias_path is not None):
      full_path = self.full_path()
      if (full_path.startswith(alias_path)):
        path = path[len(self.name)+1:]
    else:
      return []
    result = []
    for object in self.active_objects():
      result.extend(object.get_without_substitution(path=path,
        alias_path=alias_path))
    return result

  def get(self, path, with_substitution=True, alias_path=None):
    result = scope(name="", objects=self.get_without_substitution(path=path,
      alias_path=alias_path))
    if (not with_substitution): return result
    return result.resolve_variables()

  def resolve_variables(self):
    result = []
    for object in self.active_objects():
      result.append(object.resolve_variables())
    return self.customized_copy(objects=result)

  def lexical_get(self, path, stop_id, search_up=True):
    if (path.startswith(".")):
      while (self.primary_parent_scope is not None):
        self = self.primary_parent_scope
      path = path[1:]
    candidates = []
    for object in self.objects:
      if (object.primary_id is not None and
          object.primary_id >= stop_id): break
      if (object.is_definition):
        if (object.name == path):
          candidates.append(object)
      elif (object.name == path
            or path.startswith(object.name+".")):
        candidates.append(object)
    while (len(candidates) > 0):
      object = candidates.pop()
      if (object.name == path): return object
      object = object.lexical_get(
        path=path[len(object.name)+1:], stop_id=stop_id, search_up=False)
      if (object is not None): return object
    if (not search_up): return None
    if (self.primary_parent_scope is None): return None
    return self.primary_parent_scope.lexical_get(path=path, stop_id=stop_id)

  def extract(self, parent=None):
    result = scope_extract(name=self.name, parent=parent, call=self.call)
    for object in self.objects:
      if (object.is_template < 0): continue
      if (object.is_disabled or object.is_template > 0):
        value = scope_extract_is_disabled
      else:
        value = object.extract(parent=result)
      result.__phil_set__(
        name=object.name,
        optional=object.optional,
        multiple=object.multiple,
        value=value)
    return result

  def format(self, python_object):
    multiple_scopes_done = {}
    result = []
    for object in self.master_active_objects():
      if (object.multiple and object.is_scope):
        if (object.name in multiple_scopes_done): continue
        multiple_scopes_done[object.name] = False
      if (python_object is None):
        result.append(object.format(None))
      elif (python_object is Auto) or (isinstance(python_object, type(Auto))):
        result.append(object.format(Auto))
      else:
        if (isinstance(python_object, scope_extract)):
          python_object = [python_object]
        for python_object_i in python_object:
          sub_python_object = python_object_i.__phil_get__(object.name)
          if (sub_python_object is not scope_extract_attribute_error):
            if (not object.multiple):
              result.append(object.format(sub_python_object))
            else:
              if (len(sub_python_object) == 0):
                obj = object.copy()
                obj.is_template = 1
                result.append(obj)
              else:
                if (not multiple_scopes_done.get(object.name, True)):
                  multiple_scopes_done[object.name] = True
                  obj = object.copy()
                  obj.is_template = -1
                  result.append(obj)
                for sub_python_object_i in sub_python_object:
                  result.append(object.format(sub_python_object_i))
    return self.customized_copy(objects=result)

  def extract_format(self, source=None):
    if (source is None): source = self
    return self.format(source.extract())

  def clone(self, python_object, converter_registry=None):
    return parse(
      input_string=self.format(python_object=python_object)
        .as_str(attributes_level=3),
      converter_registry=converter_registry).extract()

  def fetch(self,
        source=None,
        sources=None,
        track_unused_definitions=False,
        diff=False,
        skip_incompatible_objects=False):
    combined_objects = []
    if (source is not None or sources is not None):
      assert source is None or sources is None
      combined_objects = []
      if (sources is None): sources = [source]
      for source in sources:
        assert source.name == self.name
        if (source.is_definition):
          if (skip_incompatible_objects):
            continue
          raise RuntimeError(
            'Incompatible parameter objects:'
            ' scope "%s"%s vs. definition "%s"%s' %
              (self.name, self.where_str, source.name, source.where_str))
        combined_objects.extend(source.objects)
    source = self.customized_copy(objects=combined_objects)
    del sources
    if (track_unused_definitions):
      source.assign_tmp(value=False, active_only=True)
    result_objects = []
    for master_object in self.master_active_objects():
      if (len(self.name) == 0):
        path = master_object.name
      else:
        path = self.name + "." + master_object.name
      alias_path = master_object.alias_path()
      matching_sources = source.get(path=path, with_substitution=False,
        alias_path=alias_path)
      if (not master_object.multiple):
        if (master_object.is_definition):
          # loop over all matching_sources to support track_unused_definitions
          result_object = None
          for matching_source in matching_sources.active_objects():
            result_object = master_object.fetch(
              source=matching_source,
              diff=diff,
              skip_incompatible_objects=skip_incompatible_objects)
        else:
          result_object = master_object.fetch(
            sources=matching_sources.active_objects(),
            diff=diff,
            skip_incompatible_objects=skip_incompatible_objects)
          if (diff and len(result_object.objects) == 0):
            result_object = None
        if (result_object is not None):
          result_objects.append(result_object)
        elif (not diff) and (not master_object.deprecated):
          result_objects.append(master_object.copy())
      else:
        processed_as_str = {}
        result_objs = []
        master_as_str = master_object.extract_format().as_str()
        for from_master,matching in [
              (True, self.get(path=path, with_substitution=False)),
              (False, matching_sources)]:
          for matching_source in matching.active_objects():
            if (matching_source is master_object): continue
            candidate = master_object.fetch(source=matching_source, diff=diff,
              skip_incompatible_objects=skip_incompatible_objects)
            if (diff):
              if (master_object.is_scope):
                if (len(candidate.objects) == 0): continue
              elif (candidate is None):
                continue
            candidate_as_str = master_object.extract_format(
              source=candidate).as_str()
            if (candidate_as_str == master_as_str): continue
            prev_index = processed_as_str.get(candidate_as_str, None)
            if (prev_index is not None):
              if (prev_index == -1): continue
              result_objs[prev_index] = None
            if (diff and from_master):
              processed_as_str[candidate_as_str] = -1
            else:
              processed_as_str[candidate_as_str] = len(result_objs)
              result_objs.append(candidate)
        if (not diff):
          obj = master_object.copy()
          if (    not master_object.optional is None
              and not master_object.optional):
            obj.is_template = 0
          elif (len(processed_as_str) == 0):
            obj.is_template = 1
          else:
            obj.is_template = -1
          result_objects.append(obj)
        del processed_as_str
        for obj in result_objs:
          if (obj is not None):
            result_objects.append(obj)
        del result_objs
    result = self.customized_copy(objects=result_objects)
    if (track_unused_definitions):
      return result, source.all_definitions(select_tmp=False)
    return result

  def fetch_diff(self,
        source=None,
        sources=None,
        track_unused_definitions=False,
        skip_incompatible_objects=False):
    return self.fetch(
      source=source,
      sources=sources,
      track_unused_definitions=track_unused_definitions,
      diff=True,
      skip_incompatible_objects=skip_incompatible_objects)

  def process_includes(self,
        converter_registry,
        reference_directory,
        include_stack=None):
    if (converter_registry is None):
      converter_registry = default_converter_registry
    if (include_stack is None): include_stack = []
    result = []
    for object in self.objects:
      if (object.is_disabled):
        result.append(object)
      elif (object.is_definition):
        if (object.name != "include"):
          result.append(object)
        else:
          object_sub = object.resolve_variables()
          if (len(object_sub.words) < 2):
            raise RuntimeError(
              '"include" must be followed by at least two arguments%s' % (
                object.where_str))
          include_type = object_sub.words[0].value.lower()
          if (include_type == "file"):
            if (len(object_sub.words) != 2):
              raise RuntimeError(
                '"include file" must be followed exactly one argument%s' % (
                  object.where_str))
            file_name = object_sub.words[1].value
            if (reference_directory is not None
                and not os.path.isabs(file_name)):
              file_name = os.path.join(reference_directory, file_name)
            result.extend(parse(
              file_name=file_name,
              converter_registry=converter_registry,
              process_includes=True,
              include_stack=include_stack).objects)
          elif (include_type == "scope"):
            if (len(object_sub.words) > 3):
              raise RuntimeError(
                '"include scope" must be followed one or two arguments,'
                ' i.e. an import path and optionally a phil path%s' % (
                  object.where_str))
            import_path = object_sub.words[1].value
            if (len(object_sub.words) > 2):
              phil_path = object_sub.words[2].value
            else:
              phil_path = None
            result.extend(process_include_scope(
              converter_registry=converter_registry,
              include_stack=include_stack,
              object=object,
              import_path=import_path,
              phil_path=phil_path).objects)
          else:
            raise RuntimeError("Unknown include type: %s%s" % (
              include_type, object.where_str))
      else:
        result.append(object.process_includes(
          converter_registry=converter_registry,
          reference_directory=reference_directory,
          include_stack=include_stack))
    return self.customized_copy(objects=result)

  def unique(self):
    selection = {}
    result = []
    for i_object,object in enumerate(self.active_objects()):
      selection[object.name] = i_object
    for i_object,object in enumerate(self.active_objects()):
      if (selection[object.name] == i_object):
        result.append(object.unique())
    return self.customized_copy(objects=result)

  def command_line_argument_interpreter(self,
        home_scope=None,
        argument_description=None,
        assume_when_ambiguous=True):
    from libtbx.phil.command_line import argument_interpreter as _
    return _(
      master_phil=self,
      home_scope=home_scope,
      argument_description=argument_description,
      assume_when_ambiguous=assume_when_ambiguous)

def process_include_scope(
      converter_registry,
      include_stack,
      object,
      import_path,
      phil_path):
  imported = import_python_object(
    import_path=import_path,
    error_prefix="include scope: ",
    target_must_be="; target must be a phil scope object or phil string",
    where_str=object.where_str)
  source_scope = imported.object
  if (isinstance(source_scope, str)):
    source_scope = parse(
      input_string=source_scope,
      converter_registry=converter_registry)
  elif hasattr(source_scope, "__call__"):
    source_scope = source_scope()
  elif (source_scope is None or not isinstance(source_scope, scope)):
    raise RuntimeError(
      'include scope: python object "%s" in module "%s" is not a'
      ' libtbx.phil.scope instance%s' % (
        imported.path_elements[-1], imported.module_path, object.where_str))
  source_scope = source_scope.process_includes(
    converter_registry=converter_registry,
    reference_directory=None,
    include_stack=include_stack)
  if (phil_path is None):
    result = source_scope
  else:
    result = source_scope.get(path=phil_path)
    if (len(result.objects) == 0):
      raise RuntimeError(
        'include scope: path "%s" not found in phil scope object "%s"' \
        ' in module "%s"%s' % (
          phil_path, imported.path_elements[-1], imported.module_path,
          object.where_str))
  return result.change_primary_parent_scope(object.primary_parent_scope)

class variable_substitution_fragment(slots_getstate_setstate):

  __slots__ = ["is_variable", "value", "result"]

  def __init__(self, is_variable, value):
    self.is_variable = is_variable
    self.value = value

class variable_substitution_proxy(slots_getstate_setstate):

  __slots__ = ["word", "force_string", "have_variables", "fragments"]

  def __init__(self, word):
    self.word = word
    self.force_string = word.quote_token is not None
    self.have_variables = False
    self.fragments = []
    fragment_value = ""
    char_iter = tokenizer.character_iterator(word.value)
    c = next(char_iter)
    while (c is not None):
      if (c != "$"):
        fragment_value += c
        if (c == "\\" and char_iter.look_ahead_1() == "$"):
          fragment_value += next(char_iter)
        c = next(char_iter)
      else:
        self.have_variables = True
        if (len(fragment_value) > 0):
          self.fragments.append(variable_substitution_fragment(
            is_variable=False,
            value=fragment_value))
          fragment_value = ""
        c = next(char_iter)
        if (c is None):
          word.raise_syntax_error("$ must be followed by an identifier: ")
        if (c == "("):
          while True:
            c = next(char_iter)
            if (c is None):
              word.raise_syntax_error('missing ")": ')
            if (c == ")"):
              c = next(char_iter)
              break
            fragment_value += c
          offs = int(fragment_value.startswith("."))
          if (not is_standard_identifier(fragment_value[offs:])):
            word.raise_syntax_error("improper variable name ")
          self.fragments.append(variable_substitution_fragment(
            is_variable=True,
            value=fragment_value))
        else:
          if (c not in standard_identifier_start_characters):
            word.raise_syntax_error("improper variable name ")
          fragment_value = c
          while True:
            c = next(char_iter)
            if (c is None): break
            if (c == "."): break
            if (c not in standard_identifier_continuation_characters): break
            fragment_value += c
          self.fragments.append(variable_substitution_fragment(
            is_variable=True,
            value=fragment_value))
        fragment_value = ""
    if (len(fragment_value) > 0):
      self.fragments.append(variable_substitution_fragment(
        is_variable=False,
        value=fragment_value))
    if (len(self.fragments) > 1):
      self.force_string = True

  def get_new_words(self):
    if (not self.have_variables):
      return [self.word]
    if (not self.force_string):
      return self.fragments[0].result
    return [tokenizer.word(
      value="".join([fragment.result.value for fragment in self.fragments]),
      quote_token='"')]

def parse(
      input_string=None,
      source_info=None,
      file_name=None,
      converter_registry=None,
      process_includes=False,
      include_stack=None):
  from libtbx.phil import parser
  assert source_info is None or file_name is None
  if (input_string is None):
    assert file_name is not None
    with io.open(file_name, encoding='utf-8', errors='ignore') as f:
      input_string = to_str(f.read())
  if (converter_registry is None):
    converter_registry = default_converter_registry
  result = scope(name="", primary_id=0)
  parser.collect_objects(
    word_iterator=tokenizer.word_iterator(
      input_string=input_string,
      source_info=source_info,
      file_name=file_name,
      list_of_settings=[
        tokenizer.settings(
          unquoted_single_character_words="{}=",
          contiguous_word_characters="",
          comment_characters="#",
          meta_comment="phil"),
        tokenizer.settings(
          unquoted_single_character_words="{};",
          contiguous_word_characters="")]),
    converter_registry=converter_registry,
    primary_id_generator=count(1),
    primary_parent_scope=result)
  if (process_includes):
    if (file_name is None):
      file_name_normalized = None
      reference_directory = None
    else:
      file_name_normalized = os.path.normpath(os.path.abspath(file_name))
      reference_directory = os.path.dirname(file_name_normalized)
      if (include_stack is None):
        include_stack = []
      elif (file_name_normalized in include_stack):
        raise RuntimeError("Include dependency cycle: %s"
          % ", ".join(include_stack+[file_name_normalized]))
      include_stack.append(file_name_normalized)
    result = result.process_includes(
      converter_registry=converter_registry,
      reference_directory=reference_directory,
      include_stack=include_stack)
    if (include_stack is not None):
      include_stack.pop()
  return result

def read_default(
      caller_file_name,
      params_extension=".params",
      converter_registry=None,
      process_includes=True):
  params_file_name = os.path.splitext(caller_file_name)[0] + params_extension
  if (not os.path.isfile(params_file_name)):
    raise RuntimeError("Missing parameter file: %s" % params_file_name)
  return parse(
    file_name=params_file_name,
    converter_registry=converter_registry,
    process_includes=process_includes)

def process_command_line(args, master_string, parse=None):
  from libtbx.phil import command_line
  return command_line.process(
    args=args, master_string=master_string, parse=parse)

def find_scope(current_phil, scope_name):
  i = 0
  while (i < len(current_phil.objects)):
    full_path = current_phil.objects[i].full_path()
    if (full_path == scope_name):
      return current_phil.objects[i]
    elif (scope_name.startswith(full_path + ".")):
      return find_scope(current_phil.objects[i], scope_name)
    i += 1

def change_default_phil_values(master_phil_str, new_default_phil_str,
                               phil_parse=None, expert_level=4,
                               attributes_level=4):
  '''
  Function for updating the default values in a PHIL scope

  Parameters
  ----------
  master_phil_str: str
  new_default_phil_str: str
  phil_parse: function for parsing PHIL (optional, defaults to libtbx.parse)
  expert_level: int (optional, defaults to 4)
  attributes_level: int (optional, defaults to 4)

  Returns
  -------
  str: the master_phil_str with the updated default values

  Raises
  ------
  Sorry: if unrecognized PHIL parameters are encountered
  RuntimeError: if new value cannot be interpreted (e.g str instead of float)
  '''

  if (phil_parse is None):
    phil_parse = parse

  master_phil = phil_parse(master_phil_str, process_includes=True)
  new_phil, unused_phil = master_phil.fetch(
    phil_parse(new_default_phil_str, process_includes=True),
    track_unused_definitions=True)
  if (len(unused_phil) > 0):
    raise Sorry('Unrecognized PHIL parameter(s)\n%s' %
                '\n'.join([p.__str__() for p in unused_phil]))
  new_phil_extract = new_phil.extract()
  modified_phil = master_phil.format(python_object=new_phil_extract)

  return modified_phil.as_str(expert_level=expert_level,
                              attributes_level=attributes_level)


 *******************************************************************************


 *******************************************************************************
libtbx/phil/command_line.py
from __future__ import absolute_import, division, print_function
import libtbx.phil
from libtbx.utils import Sorry, format_exception
import os
from six.moves import zip
op = os.path

class argument_interpreter(object):

  def __init__(self,
        master_phil=None,
        home_scope=None,
        argument_description=None,
        master_params=None,
        assume_when_ambiguous=True):
    if (argument_description is None):
      argument_description = "command line "
    assert [master_params, master_phil].count(None) == 1
    if (master_phil is None):
      import warnings
      warnings.warn(
        message='The "master_params" keyword argument name is deprecated.'
                ' Please use "master_phil" instead.',
        category=DeprecationWarning,
        stacklevel=2)
      master_phil = master_params
    self.master_phil = master_phil
    self.home_scope = home_scope
    self.argument_description = argument_description
    self.target_paths = None
    self.assume_when_ambiguous = assume_when_ambiguous

  def get_path_score(self, source_path, target_path):
    i = target_path.find(source_path)
    if (i < 0): return 0
    if (i == 0 and len(source_path) == len(target_path)): return 8
    target_path_start_with_home_scope = False
    if (self.home_scope is not None):
      if (self.home_scope+"."+source_path == target_path): return 7
      if (target_path.startswith(self.home_scope+".")):
        if (target_path.endswith("."+source_path)): return 6
        if (target_path.endswith(source_path)): return 5
        target_path_start_with_home_scope = True
    if (target_path_start_with_home_scope): return 2
    if (target_path.endswith("."+source_path)): return 4
    if (target_path.endswith(source_path)): return 3
    return 1

  def process_arg(self, arg):
    try:
      params = libtbx.phil.parse(
        input_string=arg,
        source_info=self.argument_description+"argument")
    except RuntimeError:
      raise Sorry((
        'Error interpreting %sargument as parameter definition:\n'
        '  "%s"\n  %s') % (self.argument_description, arg, format_exception()))
    if (self.target_paths is None):
      self.target_paths = [object_locator.path
        for object_locator in self.master_phil.all_definitions()]

    def recursive_expert_level(phil_obj):
      if hasattr(phil_obj.object, 'expert_level') and phil_obj.object.expert_level is not None:
        return phil_obj.object.expert_level
      if not hasattr(phil_obj, 'parent') or not phil_obj.parent:
        return 0
      def parent_expert_level(obj):
        if hasattr(obj, 'expert_level') and obj.expert_level is not None:
          return obj.expert_level
        if hasattr(obj, 'primary_parent_scope') and obj.primary_parent_scope:
          return parent_expert_level(obj.primary_parent_scope)
        return 0
      return parent_expert_level(phil_obj.parent)
    expert_level = [recursive_expert_level(object_locator)
      for object_locator in self.master_phil.all_definitions()]

    source_definitions = params.all_definitions()
    complete_definitions = ""
    for object_locator in source_definitions:
      object = object_locator.object
      scores = [self.get_path_score(object_locator.path, target_path)
        for target_path in self.target_paths]
      max_score = max(scores)
      if (max_score == 0):
        raise Sorry("Unknown %sparameter definition: %s" % (
          self.argument_description, object.as_str().strip()))
      if (scores.count(max_score) > 1):
        error = ["Ambiguous parameter definition: %s" %
          object.as_str().strip()]
        error.append("Best matches:")
        for target_path,score in zip(self.target_paths, scores):
          if (score == max_score):
            error.append("  " + target_path)

        if self.assume_when_ambiguous:
          # Calculate and apply tie-breaker value depending on expert level.
          # Arguments with lower expert level are preferentially
          # chosen if otherwise they would be ambiguous.
          scores = [ score - (exp_lvl / 100) for score, exp_lvl in zip(scores, expert_level) ]
          max_score = max(scores)
        if (scores.count(max_score) > 1):  # if there is still a tie, a Sorry is still raised
          raise Sorry("\n".join(error))
        if self.assume_when_ambiguous:
          print("Warning: " + "\n".join(error) + "\nAssuming %s was intended." % self.target_paths[scores.index(max_score)])

      complete_definitions += object.customized_copy(
        name=self.target_paths[scores.index(max_score)]).as_str()
    if (complete_definitions == ""):
      raise Sorry(('%sparameter definition has no effect: "%s"' % (
        self.argument_description, arg)).capitalize())
    return libtbx.phil.parse(
      input_string=complete_definitions,
      source_info=self.argument_description+"argument")

  def process_args(self, args, custom_processor=None):
    user_phils = []
    for arg in args:
      if (len(arg.strip()) == 0):
        continue
      if (arg.startswith("--")):
        arg_work = arg[2:]
        if (arg_work.find("=") < 0): arg_work += " = True"
        user_phils.append(self.process_arg(arg=arg_work))
        continue
      if (op.isfile(arg) and op.getsize(arg) > 0):
        try: user_phils.append(libtbx.phil.parse(file_name=arg))
        except Exception: pass
        else: continue
      if (arg.find("=") >= 0):
        try: user_phils.append(self.process_arg(arg=arg))
        except Exception: pass
        else: continue
      if (custom_processor is not None):
        result = custom_processor(arg=arg)
        if (isinstance(result, libtbx.phil.scope)):
          user_phils.append(result)
          continue
        elif (result is not None) and (result != False):
          continue
      if (op.isfile(arg)):
        libtbx.phil.parse(file_name=arg) # exception expected
        from libtbx.str_utils import show_string
        raise RuntimeError(
          'Programming error or highly unusual situation'
          ' (while processing %sargument %s).' % (
            self.argument_description, show_string(arg)))
      from libtbx.str_utils import show_string
      raise Sorry(
        "Uninterpretable %sargument: %s" % (
          self.argument_description, show_string(arg)))
    return user_phils

  def process(self, arg=None, args=None, custom_processor=None):
    assert [arg, args].count(None) == 1
    if (arg is not None):
      assert custom_processor is None
      return self.process_arg(arg=arg)
    return self.process_args(args=args, custom_processor=custom_processor)

  def process_and_fetch(self, args, custom_processor=None, extra_sources=()):
    if (isinstance(custom_processor, str)):
      assert custom_processor == "collect_remaining"
      remaining_args = []
      def custom_processor(arg):
        remaining_args.append(arg)
        return True
    else:
      remaining_args = None
    sources = self.process(args=args, custom_processor=custom_processor)
    sources.extend(list(extra_sources))
    result = self.master_phil.fetch(sources=sources)
    if (remaining_args is None):
      return result
    return result, remaining_args

class process(object):

  def __init__(self, args, master_string, parse=None, extra_sources=()):
    if (parse is None): parse = libtbx.phil.parse
    self.parse = parse
    self.master = self.parse(input_string=master_string, process_includes=True)
    self.work, self.remaining_args = argument_interpreter(
      master_phil=self.master) \
        .process_and_fetch(
          args=args,
          custom_processor="collect_remaining",
          extra_sources=extra_sources)

  def show(self, out=None):
    self.work.show(out=out)
    return self


 *******************************************************************************


 *******************************************************************************
libtbx/phil/experimental.py
from __future__ import absolute_import, division, print_function

from libtbx import phil


def _merge_param_into_list(dst_list, src, key):
  """The _merge_param_into_list() helper function returns @c True if
  the phil extract @p src was merged into the extract list @p dst_list
  and @c False otherwise.
  """

  for dst in dst_list:
    if (merge_params_by_key(dst, src, key)):
      return True
  return False


def merge_params_by_key(dst, src, key):
  """The merge_params_by_key() function recursively merges the phil
  extract @p src into @p dst.  Two scopes with attributes named @p key
  are merged only if the values of @p key are equal.  The function
  returns @c True if @p src was merged into @p dst, and @c False
  otherwise.
  """

  # Base case: if dst and src both have keys, they must match.
  if (hasattr(dst, key) and
      hasattr(src, key) and
      getattr(dst, key) != getattr(src, key)):
    return False

  for attr in dir(src):
    # Ignore "private" attributes.
    if (len(attr) <= 0 or attr[0] == "_"):
      continue

    src_val = getattr(src, attr)
    if (src_val is None):
      # Do not merge undefined values.
      continue

    elif (isinstance(src_val, phil.scope_extract)):
      # If dst has a scope with the same name, merge it recursively.
      if (hasattr(dst, attr)):
        dst_val = getattr(dst, attr)
        assert isinstance(dst_val, phil.scope_extract)
        merge_params_by_key(dst_val, src_val, key)
      else:
        setattr(dst, attr, src_val)

    elif (isinstance(src_val, phil.scope_extract_list)):
      # If dst has a list of scopes with the same name, merge them
      # recursively, item by item.
      if (hasattr(dst, attr)):
        dst_list = getattr(dst, attr)
        assert isinstance(dst_list, phil.scope_extract_list)
        for src_item in src_val:
          if (not _merge_param_into_list(dst_list, src_item, key)):
            dst_list.append(src_item)
      else:
        setattr(dst, attr, src_val)

    else:
      # Merge non-scope values.
      setattr(dst, attr, src_val)

  return True


 *******************************************************************************


 *******************************************************************************
libtbx/phil/gui_objects.py
from __future__ import absolute_import, division, print_function

# various containers for gui directives and objects

class menu_hierarchy(object):
  is_menu_item = False
  is_submenu = True

  def __init__(self, menu_name):
    self.menu_name = menu_name
    self.submenus = {}
    self.menu_items = []
    self._used = []
    self.submenu_items = []

  def get_items(self):
    return self.menu_items + self.submenu_items

  def add_menu_item(self, menu_item_name):
    if not menu_item_name in self._used :
      self.menu_items.append( menu_item(menu_item_name) )
      self._used.append(menu_item_name)

  def get_submenu(self, submenu_name):
    return self.submenus[submenu_name]

  # this will simply do nothing if the submenu already exists
  def add_submenu(self, submenu_name):
    if submenu_name in self.submenus :
      pass
    else :
      self.submenus[submenu_name] = menu_hierarchy(submenu_name)
      self.submenu_items.append(self.submenus[submenu_name])

  def __str__(self):
    return self.menu_name

class menu_item(object):
  is_menu_item = True
  is_submenu = False

  def __init__(self, menu_item_name):
    self.menu_item_name = menu_item_name

  def __str__(self):
    return self.menu_item_name

class style(object):
  """
  Container for flags used to alter the appearance of controls in the Phenix
  GUI.  These can either be booleans (style_args) or other values (style_kwds).
  """
  style_args = [
    "auto_align", # left-align controls and labels separately (scope)
    "bold", # bold text label (definition)
    "box",  # display controls in wx.StaticBox (scope)
    "color",
    "date", # control specifies a date (definition)
    "use_list", # use wx.ListCtrl-based widget (atom_selection, multiple=True)
    "menu_item", # add to Settings menu (scope)
    "narrow", # fit controls in 300px (path)
    "noauto", # don't automatically display as part of parent scope (any)
    "noedit", # not editable (definition)
    "none_is_auto", # treat None as Auto
    "scrolled",
    "selection", # tags a str definition as atom_selection
    "spinner", # attach wx.SpinCtrl widget
    "submenu", # add to Settings menu as submenu (scope)
    "tribool", # use wx.Choice with True/False/Auto (bool)
    "hidden",  # never display in GUI (definition)
    "directory", # specifies a directory (path)
    "new_file", # specifies a new file (path)
    "default_cwd", # default to current directory (path)
    "resolution", # treat as resolution limit (float)
    "hide_label", # don't display control label
    "not_none", # don't allow None (definition)
    "fixed",
    "checklist", # display as wx.CheckListBox (definition)
    "set_resolution",
    "force_data",
    "anom",
    "non_anom",
    "no_view",
    "process_hkl", # specifies a reflections file with expected data items,
                   # which will be automatically extracted
    "force_rfree",
    "combo_box", # use a wx.ComboBox control (definition)
    "optional",
    "no_map",
    "file_type_default", # specifies that all files of the stated file_type
                         # should be automatically associated with this path
                         # parameter.  only used in ListCtrl-based file input
                         # fields
    "expand",
    "output_dir", # specifies that the path defines the output directory, which
                  # is determined automatically.  only one of these is allowed
                  # per program, and the GUI will extract this automatically.
    "seq_file",
    "single_input", # disable multiple controls (definition, multiple=True)
  ]
  style_kwds = [
    "auto_launch_dialog", # when clicked, launch a window to edit options in
                          # the named scope.  mostly used in phenix.refine.
                          # (definition, especially bool)
    "columns", # number of columns for controls (scope)
    "dialog_link", # add a button to edit the named scope (definition)
    "extensions",
    "file_type", # specifies the file type filter, as well as the behavior of
                 # the ListCtrl-based file input fields (path)
    "min",
    "max",
    "parent_submenu", # add to the specified submenu (scope)
    "OnUpdate", # specifies event handler in
                # phenix/wxGUI2/Programs/Extensions.py (definition)
    "OnChange", # specifies event handler in
                # phenix/wxGUI2/Programs/Extensions.py (definition)
    "renderer", # specifies custom drawing method in
                # phenix/wxGUI2/Programs/CustomControls.py (definition)
    "caption_img", # image to display next to caption (scope)
    "rlabel",
    "llabel",
    "cols",
    "height",
    "help_page", # file name in Phenix documentation (definition)
    "help_anchor", # anchor on help_page (definition)
    "caption_width",
  ]
  multiple_kwds = ["child", "parent"]
  convert_to_int = ["columns", "min", "max"]
  special_words = []
  #__slots__ = ["_style_words"] + style_args + style_kwds

  def __init__(self, style_string=None):
    self._style_words = []
    self.child = None
    self.parent = None
    for arg in self.style_args :
      setattr(self, arg, False)
    for kwd in self.style_kwds :
      setattr(self, kwd, None)

    if style_string is not None :
      style_words = style_string.split()
      for style_word in style_words :
        if style_word in self.style_args :
          setattr(self, style_word, True)
        elif not style_word in self.special_words :
          try :
            fields = style_word.split(":")
            kwd = fields[0]
            value = ":".join(fields[1:])
            #kwd, value = style_word.split(":")
            if kwd in self.multiple_kwds :
              if getattr(self, kwd, None) is not None :
                getattr(self, kwd).append(value)
              else :
                setattr(self, kwd, [value])
            elif kwd in self.special_words :
              self.process_style_keyword(style_word)
            else :
              value_words = value.split(",")
              if len(value_words) == 1 :
                if kwd in self.convert_to_int :
                  try :
                    int_value = int(value)
                    setattr(self, kwd, int_value)
                  except ValueError :
                    print("Ignoring incorrect .style keyword '%s'"%style_word)
                else :
                  setattr(self, kwd, value)
              else :
                setattr(self, kwd, value_words)
          except Exception as e :
            print(e)
            pass
            #wxGUI2.DEBUG2("Unrecognized style keyword(s): %s" % style_string)
            #wxGUI2.DEBUG2(style_string)
        else :
          self.process_style_keyword(style_word)
      self._style_words = style_words

  def process_style_keyword(self, style_word):
    pass

  def __str__(self):
    return " ".join(self._style_words)

  def get_list(self, kwd):
    val = getattr(self, kwd, None)
    if isinstance(val, list):
      return val
    elif val is not None :
      return [val]
    else :
      return []

  def get_child_params(self):
    params = []
    if self.child is not None :
      assert isinstance(self.child, list)
      for value in self.child :
        child_type, child_name = value.split(":")
        params.append((child_type, child_name))
    return dict(params)

  def get_parent_params(self):
    params = []
    if self.parent is not None :
      assert isinstance(self.parent, list)
      for value in self.parent :
        parent_type, parent_name = value.split(":")
        params.append((parent_type, parent_name))
    return dict(params)

default_style = style(None)

class file_type_map(object):
  def __init__(self, param_info, default_label=None):
    self.param_info = param_info
    self.default_label = default_label
    self._names = {}
    self._labels = {}
    self._counts = {}
    self._max_allowed = None
    for args in param_info :
      name = args[0]
      label = args[1]
      self._names[label] = name
      self._labels[name] = label
      if (len(args) >= 3):
        count = args[2]
      else :
        assert (len(args) == 2)
        count = 1
      self._counts[name] = count
    assert (default_label is None) or (default_label in self._names.keys())

  def get_params_and_labels(self):
    return [ (args[0], args[1]) for args in self.param_info ]

  def get_overall_max_count(self):
    n = 0
    for name, count in self._counts.items():
      if (count is None):
        return None
      n += count
    return n

  def get_max_count(self, param_name):
    return self._counts[param_name]

  def get_default_label(self):
    if (len(self._names) == 1):
      return list(self._names.keys())[0]
    return self.default_label

  def get_default_param(self):
    if (len(self._labels) == 1):
      return list(self._labels.keys())[0]
    if (self.default_label is not None):
      return self._names[self.default_label]
    return None

  def get_param_names(self):
    return [ args[0] for args in self.param_info ]

  def get_multiple_params(self):
    names = []
    for name, count in self._counts.items():
      if count is None :
        names.append(name)
    return names

  def disable_param(self, param_name):
    if (param_name in self._labels):
      label = self._labels[param_name]
      self._names.pop(label)
      self._labels.pop(param_name)
      self._counts.pop(param_name)


 *******************************************************************************


 *******************************************************************************
libtbx/phil/interface.py

# XXX: this module is used exclusively by the Phenix GUI, which needs an
# index of all current phil parameters, and an easy way to change them.

from __future__ import absolute_import, division, print_function
from libtbx import easy_pickle, str_utils, smart_open
from libtbx import adopt_init_args, Auto
from libtbx.phil import gui_objects
from libtbx.utils import Sorry
import libtbx.phil
import re
import os
import sys

tracking_params = libtbx.phil.parse("""
  job_title = None
    .type = str
    .input_size = 400
    .help = Job title in PHENIX GUI, not used on command line
    .style = noauto bold
""")

class index(object):
  def __init__(self, master_phil, working_phil=None, parse=None,
      fetch_new=False):
    adopt_init_args(self, locals())
    self._states = []
    self._full_path_index = {}
    self._full_text_index = {}
    self._template_index = {}
    self._multiple_scopes = {}
    self._multiple_defs = {}
    self._expert_levels = {}
    self._input_files = []
    self._hidden = [] # XXX: not implemented here (for phenix GUI)
    self._phil_has_changed = False
    self._output_dir_path = None
    self._log = str_utils.StringIO()
    self._prefix = None
    if parse is None :
      self.parse = libtbx.phil.parse
    self.setup_phil(working_phil, fetch_new)
    self.parse_styles()

  def setup_phil(self, working_phil, fetch_new=False):
    if working_phil is None :
      self.working_phil = self.master_phil.fetch()
    elif fetch_new :
      self.working_phil = self.master_phil.fetch(source=working_phil)
    else :
      self.working_phil = working_phil
    self.build_index(collect_multiple=True)
    self.params = self.working_phil.extract()

  def set_prefix(self, prefix):
    assert (prefix is None) or (isinstance(prefix, str))
    self._prefix = prefix

  def get_full_path(self, phil_path):
    if (self._prefix is None):
      return phil_path
    elif (phil_path.startswith(".")):
      return self._prefix + phil_path
    else :
      return phil_path

  def clear_index(self, clear_multiple=True):
    self._full_path_index = {}
    self._full_text_index = {}
    self._template_index = {}
    if clear_multiple :
      self._multiple_scopes = {}
      self._multiple_defs = {}

  def clear_state_stack(self):
    while len(self._states) > 0 :
      saved_phil = self._states.pop()
      del saved_phil

  def push_state(self):
    self._states.append(self.working_phil.fetch())
    return len(self._states) - 1

  def pop_state(self):
    if len(self._states) > 0 :
      self.working_phil = self._states.pop()
      self.rebuild_index()
      return True
    return False

  def set_state(self, index):
    assert (index >= 0)
    if (len(self._states) == 0):
      pass
    else :
      self.working_phil = self._states[index].fetch()
      self.rebuild_index()
      return True
    return False

  def build_index(self, collect_multiple=False):
    self.clear_index(clear_multiple=collect_multiple)
    index_phil_objects(phil_object=self.working_phil,
                       path_index=self._full_path_index,
                       text_index=self._full_text_index,
                       template_index=self._template_index,
                       multiple_scopes=self._multiple_scopes,
                       multiple_defs=self._multiple_defs,
                       collect_multiple=collect_multiple,
                       expert_levels=self._expert_levels,
                       input_files=self._input_files)

  def rebuild_index(self, only_scope=None):
    self._full_path_index = {}
    reindex_phil_objects(phil_object=self.working_phil,
                         path_index=self._full_path_index,
                         only_scope=only_scope)

  def save_param_file(self,
                       file_name,
                       sources=None,
                       extra_phil="",
                       diff_only=False,
                       save_state=False,
                       replace_path=None):
    if sources is None :
      sources = []
    if extra_phil != "" :
      self.merge_phil(phil_string=extra_phil, rebuild_index=False)
    final_phil = self.master_phil.fetch(sources=[self.working_phil] +
      list(sources))
    if diff_only :
      output_phil = self.master_phil.fetch_diff(source=final_phil)
    else :
      output_phil = final_phil
    if (replace_path is not None):
      substitute_directory_name(
        phil_object=output_phil,
        path_name=replace_path,
        sub_name="LIBTBX_BASE_DIR")
    try :
      f = smart_open.for_writing(file_name, "w")
    except IOError as e :
      raise Sorry(str(e))
    else :
      if (replace_path is not None):
        f.write("LIBTBX_BASE_DIR = \"%s\"\n" % replace_path)
      output_phil.show(out=f)
      f.close()
    if save_state :
      cache_file = "%s_cache.pkl" % file_name
      easy_pickle.dump(cache_file, self)

  def get_combined_phil(self, sources=None):
    if sources is None :
      sources = []
    new_phil = self.master_phil.fetch(sources=[self.working_phil]+sources)
    return new_phil

  def save_diff(self, file_name, replace_path=None):
    self.save_param_file(file_name=file_name,
      diff_only=True,
      replace_path=replace_path)

  def get_diff(self):
    return self.master_phil.fetch_diff(source=self.working_phil)

  def copy(self, preserve_changes=True):
    if preserve_changes :
      return easy_pickle.loads(easy_pickle.dumps(self))
    else :
      return self.copy_master()

  def copy_master(self):
    return index(master_phil=self.master_phil, parse=self.parse)

  #---------------------------------------------------------------------
  # Conversion to/from extracted objects
  def update_from_python(self, python_object=None):
    if python_object is None :
      if self.params is not None :
        python_object = self.params
      else :
        return False
    else :
      self.params = python_object
    self.push_state()
    self.working_phil = self.master_phil.format(python_object=python_object)
    self.rebuild_index()

  def get_python_object(self, make_copy=False):
    assert self.working_phil is not None
    if make_copy :
      return self.working_phil.extract()
    elif self._phil_has_changed or self.params is None :
      self.params = self.working_phil.extract()
      self._phil_has_changed = False
    return self.params

  def get_python_from_other(self, phil_object=None, file_name=None,
      phil_string=None):
    assert [phil_object, file_name, phil_string].count(None) < 3
    try :
      if phil_object is None :
        if file_name is not None :
          phil_object = self.parse(file_name=file_name)
        elif phil_string is not None :
          phil_object = self.parse(phil_string)
      new_phil = self.master_phil.fetch(source=phil_object)
    except KeyboardInterrupt :
      raise
    except Exception as e :
      return None
    else :
      return new_phil.extract()

  def get_python_from_params(self, phil_object):
    return self.get_python_from_params(phil_object=phil_object)

  def get_python_from_file(self, file_name):
    return self.get_python_from_other(file_name=file_name)

  def get_python_from_string(self, phil_string):
    return self.get_python_from_other(phil_string=phil_string)

  #---------------------------------------------------------------------
  # Retrieval methods
  # FIXME: not working properly for ncs restraint group phil
  def get_scope_by_name(self, scope_name, phil_parent=None):
    scope_name = self.get_full_path(scope_name)
    if scope_name in self._full_path_index :
      indexed_phil_objects = self._full_path_index[scope_name]
      if isinstance(indexed_phil_objects, list) and phil_parent is not None :
        child_objects = []
        for object1 in indexed_phil_objects :
          for object2 in phil_parent.objects :
            if object1 is object2 :
              child_objects.append(object1)
        return child_objects
      else :
        return indexed_phil_objects
    else :
      return None

  def get_root_scope_names(self):
    paths = []
    for phil_object in self.working_phil.objects :
      paths.append(phil_object.full_path())
    return paths

  def get_template_copy(self, phil_name):
    phil_name = self.get_full_path(phil_name)
    template = self._template_index.get(phil_name)
    new_copy = None
    if template is not None :
      new_copy = template.customized_copy()
    return new_copy

  def get_validated_param(self, def_name):
    phil_name = self.get_full_path(def_name)
    phil_objects = self.get_scope_by_name(def_name)
    if isinstance(phil_objects, list):
      vals = []
      for obj in phil_objects :
        python_value = obj.extract()
        phil_value = python_value.format()
        vals.append(phil_value)
      return vals
    elif phil_objects is not None :
      #phil_objects.show()
      python_value = phil_objects.extract()
      return python_value

  # TODO: test this
  def validate_format(self, def_name, str_value):
    if str_value is None :
      return None
    indexed_def = self.get_scope_by_name(def_name)
    d = indexed_def
    if isinstance(indexed_def, list):
      d = indexed_def[0]
    elif indexed_def is None :
      return None
    proxy = d.validate_and_format(input_string=str_value, source_info="GUI")
    if proxy.error_message is not None :
      raise Exception(proxy.error_message)
    else :
      return str(proxy.formatted.extract())

  def get_label(self, def_name):
    phil_text = self._full_text_index.get(def_name, None)
    if (phil_text is not None):
      label = phil_text[0]
      if (label is not None):
        return label
    scope = self.get_scope_by_name(def_name)
    if isinstance(scope, list):
      scope = scope[0]
    return get_standard_phil_label(scope)

  def search_phil_text(self, search_text,
      match_all=False,
      labels_only=True,
      phil_name_only=False):
    fields = search_text.split()
    for word in fields :
      # this allows matching of phil param paths
      if re.search(r"[^a-zA-Z\.\_]", word) is not None :
        raise Sorry("Invalid search string '%s'." % word)
    regex_list = [ re.compile(word, re.I) for word in fields ]
    matching_defs = []
    n_words = len(regex_list)
    for phil_name, phil_text in self._full_text_index.items():
      (label, caption, help, is_def) = phil_text
      if (phil_name in self._hidden) or (not is_def):
        continue
      n_found = 0
      if phil_name_only :
        phil_name_tmp = phil_name.split(".")[-1]
        for regex in regex_list :
          if (regex.search(phil_name_tmp) is None):
            if match_all : break
            else :         continue
          n_found += 1
      elif labels_only :
        for regex in regex_list :
          if (regex.search(label) is None):
            if match_all : break
            else :         continue
          n_found += 1
      else :
        for regex in regex_list :
          if ((regex.search(label) is None) and
              (regex.search(phil_name) is None) and
              (regex.search(caption) is None) and
              (regex.search(help) is None)):
            if match_all : break
            else :         continue
          n_found += 1
      if (match_all and (n_found == n_words)) or (n_found > 0):
        matching_defs.append(phil_name)
    return matching_defs

  def get_scope_phil(self, scope_name):
    scope_name = self.get_full_path(scope_name)
    _phil_string = str_utils.StringIO()
    scope_objects = self.get_scope_by_name(scope_name)
    if isinstance(scope_objects, list):
      for phil_object in scope_objects :
        phil_object.show(out=_phil_string)
    else :
      scope_objects.show(out=_phil_string)
    return _phil_string.getvalue()

  def get_phil_help_string(self, phil_name):
    phil_name = self.get_full_path(phil_name)
    if phil_name in self._full_text_index :
      (label, caption, help, is_def) = self._full_text_index[phil_name]
      return str(help)
    else :
      return None

  def get_expert_level(self, phil_name):
    phil_name = self.get_full_path(phil_name)
    return self._expert_levels.get(phil_name, 0)

  def get_input_files(self):
    files = []
    for def_name in self._input_files :
      phil_object = self.get_scope_by_name(def_name)
      label = self.get_label(def_name)
      #phil_text = self._full_text_index[def_name] #.get(def_name, [None]*4)
      #(label, caption, help, is_def) = phil_text
      if isinstance(phil_object, list):
        for def_copy in phil_object :
          assert (def_copy.is_definition)
          file_name = def_copy.extract()
          if (file_name is not None) and (file_name is not Auto):
            if isinstance(file_name, list):
              for fn in file_name :
                files.append((fn, label, def_name))
            else :
              files.append((file_name, label, def_name))
      else :
        assert phil_object.is_definition
        file_name = phil_object.extract()
        if (file_name is not None) and (file_name is not Auto):
          if isinstance(file_name, list):
            for fn in file_name :
              files.append((fn, label, def_name))
          else :
            files.append((file_name, label, def_name))
    return files

  def get_job_title(self):
    for def_name in list(self._full_path_index.keys()):
      if ((def_name in ["title", "job_title"]) or
          (def_name.endswith(".title") or def_name.endswith(".job_title"))):
        phil_def = self._full_path_index[def_name]
        assert phil_def.is_definition
        title = phil_def.extract()
        if title is not None:
          return title
    return None

  def get_output_dir(self):
    return self.get_scope_by_name(self._output_dir_path).extract()

  def is_list_type(self, phil_scope_name):
    phil_object = self.get_scope_by_name(phil_scope_name)
    if isinstance(phil_object, list):
      return False
    elif phil_object.type.phil_type in ["strings", "ints", "floats"] :
      return True
    return False

  #---------------------------------------------------------------------
  # EDITING METHODS
  def substitute_directory(self, path_name, sub_name):
    substitute_directory_name(
      phil_object=self.working_phil,
      path_name=path_name,
      sub_name=sub_name)

  def reset_scope(self, phil_scope_name):
    old_phil = self.working_phil
    delete_phil_objects(old_phil, [phil_scope_name])
    self.working_phil = self.master_phil.fetch(sources=[old_phil])

  def merge_phil(self,
                  phil_object=None,
                  phil_string=None,
                  phil_file=None,
                  overwrite_params=True,
                  rebuild_index=True,
                  only_scope=None):
    assert ([phil_object, phil_string, phil_file].count(None) == 2)
    if (phil_string is not None):
      phil_object = self.parse(phil_string)
    elif (phil_file is not None):
      phil_object = self.parse(file_name=phil_file)
    if (phil_object is not None):
      old_phil = self.working_phil
      if overwrite_params :
        new_paths = []
        get_all_path_names(phil_object, new_paths)
        redundant_paths = []
        for path in new_paths :
          if path in self._multiple_scopes or path in self._multiple_defs :
            redundant_paths.append(path)
        if len(redundant_paths) > 0 :
          delete_phil_objects(old_phil, redundant_paths, only_scope=only_scope)
      self.log2("Fetching new working phil")
      new_phil = None
      if False : # XXX this was causing too many problems
      # if (only_scope is not None):
        new_scope = phil_object.get(only_scope)
        scope_master = self.master_phil.get(only_scope)
        fetched_scope = scope_master.fetch(source=new_scope)
        #fetched_scope.show()
        find_and_replace_scope(
          current_phil=self.working_phil,
          new_scope=fetched_scope,
          scope_name=only_scope)
        new_phil = self.working_phil
      else :
        new_phil = self.master_phil.fetch(sources=[old_phil, phil_object])
      if (new_phil is not None):
        self.working_phil = new_phil
        if rebuild_index :
          self.log2("rebuilding index")
          self.rebuild_index(only_scope=only_scope)
      else :
        self.log("*** ERROR: new phil object is empty")
      self._phil_has_changed = True
      self.params = None

  def erase_scope(self, phil_scope):
    delete_phil_objects(self.working_phil, [phil_scope])

  # Safe wrapper of merge_phil for loading parameter files from GUI
  def merge_param_file(self, file_name):
    if not os.path.isfile(file_name):
      raise Sorry("The path %s does not exist or is not a file." % file_name)
    try :
      phil_object = self.parse(file_name=file_name)
    except KeyboardInterrupt :
      raise
    except Exception as e :
      self.log(e)
      raise Sorry("This parameter file could not be parsed correctly.")
    try :
      new_phil = self.master_phil.fetch(source=phil_object)
    except KeyboardInterrupt :
      raise
    except Exception as e :
      self.log(e)
      self.log(open(file_name).read())
      raise Sorry("This file contains invalid parameters for this program. "+
                  "Check the manual for a list of allowed parameters "+
                  "for each module.")
    self.merge_phil(phil_object=phil_object)

  # Safe wrapper of merge_phil for phil strings
  def update(self, phil_string, only_scope=None, raise_sorry=True):
    try :
      phil_object = self.parse(phil_string)
      new_phil = self.master_phil.fetch(source=phil_object)
    except KeyboardInterrupt :
      raise
    except Exception as e :
      print(str(e))
      print("bad string:")
      print(str(phil_string))
      if (raise_sorry):
        raise Sorry("An unknown error occurred parsing internal parameters. "+
          "This is probably a bug; if the program was launched with "+
          "the argument --debug, further information will be printed "+
          "to the console.")
      else :
        raise
    self.merge_phil(phil_object=phil_object, only_scope=only_scope)

  def adopt_phil(self, phil_object=None, phil_string=None, phil_file=None):
    assert [phil_object, phil_string, phil_file].count(None) == 2
    if phil_string:
      phil_object = self.parse(phil_string)
    elif phil_file:
      phil_object = libtbx.phil.parse(file_name=phil_file)
    self.master_phil.adopt_scope(phil_object)
    self.working_phil = self.master_phil.fetch(sources=[self.working_phil])
    self.rebuild_index()
    self.params = self.working_phil.extract()

  #---------------------------------------------------------------------
  # DEBUG/TEST METHODS
  def check_scopes(self, phil_names):
    missing_scopes = []
    for phil_name in phil_names :
      if self.get_scope_by_name(phil_name) is None :
        missing_scopes.append(phil_name)
    return missing_scopes

  def log(self, message):
    self._log.write(message + "\n")

  def log2(self, message):
    f = sys._getframe(1)
    filename = os.path.basename(f.f_code.co_filename)
    self._log.write("%s (%s:%d): %s\n" %
      (f.f_code.co_name, filename, f.f_lineno, str(message).strip()))

  #---------------------------------------------------------------------
  # GUI style handling
  def parse_styles(self):
    self.style = {}
    self._event_handlers = {}
    self._update_handlers = {}
    self._renderers = {}
    self._file_type_mappings = {}
    self._menu_tree = gui_objects.menu_hierarchy("settings")
    self.generate_gui_components(self.working_phil)

  def create_style(self, style_string):
    return gui_objects.style(style_string)

  def generate_gui_components(self, phil_scope, in_submenu=False,
      current_menu=None):
    use_submenu = in_submenu
    if not current_menu :
      current_menu = self._menu_tree
    if phil_scope.is_template < 0 :
      return
    for object in phil_scope.objects :
      next_menu = None
      full_object_path = object.full_path()
      if object.style is not None and phil_scope.is_template != -1 :
        style = self.create_style(object.style)
        if (style.selection) and (object.type.phil_type == "str"):
          print("WARNING: deprecated 'str' type with 'selection' style")
          print("   name: %s" % full_object_path)
        self.style[full_object_path] = style
        if style.hidden :
          self._hidden.append(full_object_path)
        if (style.output_dir):
          self._output_dir_path = full_object_path
        if style.OnUpdate is not None :
          print("OnUpdate is deprecated (%s)" % full_object_path)
          self._update_handlers[full_object_path] = style.OnUpdate
        elif style.process_hkl :
          self._event_handlers[full_object_path] = "auto_extract_hkl_params"
        if style.OnChange is not None :
          self._event_handlers[full_object_path] = style.OnChange
        if style.renderer is not None :
          self._renderers[full_object_path] = style.renderer
        if style.menu_item :
          if phil_scope.multiple and phil_scope.is_template == 0 :
            pass
          elif style.parent_submenu :
            current_menu.add_submenu(style.parent_submenu)
            current_menu.get_submenu(style.parent_submenu).add_menu_item(
              full_object_path)
          else :
            current_menu.add_menu_item(full_object_path)
        elif style.submenu :
          if phil_scope.multiple and phil_scope.is_template == 0 :
            pass
          elif style.parent_submenu :
            current_menu.add_submenu(style.parent_submenu)
            parent_submenu = current_menu.get_submenu(style.parent_submenu)
            parent_submenu.add_submenu(full_object_path)
            next_menu = parent_submenu.get_submenu(full_object_path)
          else :
            current_menu.add_submenu(full_object_path)
            next_menu = current_menu.get_submenu(full_object_path)
      else :
        self.style[full_object_path] = gui_objects.style()
      if not object.is_definition :
        self.generate_gui_components(object, use_submenu, next_menu)
      use_submenu = False

  def get_scope_style(self, scope_name=None):
    if scope_name in self.style :
      return self.style[scope_name]
    else :
      return gui_objects.style()

  def get_menu_db(self):
    return self._menu_tree

  def get_file_type_map(self, file_type, default_label=None,
      exclude_params=()):
    if (file_type in self._file_type_mappings):
      return self._file_type_mappings[file_type]
    param_info = []
    for path_name, def_style in self.style.items():
      def_types = []
      if (def_style.file_type is not None):
        def_types = def_style.get_list("file_type")
        if (file_type in def_types):
          if ((def_style.no_map) or (def_style.new_file) or
              (path_name in exclude_params)):
            continue
          phil_object = self.get_scope_by_name(path_name)
          if isinstance(phil_object, list):
            phil_object = phil_object[0]
          label = get_standard_phil_label(phil_object)
          parent_scope = phil_object.primary_parent_scope
          if ((phil_object.multiple) or (parent_scope.multiple) or
              (phil_object.type.phil_type=="strings")):
            count = None
          else :
            count = 1
          if def_style.file_type_default :
            default_label = label
          param_info.append((phil_object.full_path(), label, count))
    type_map = gui_objects.file_type_map(param_info, default_label)
    self._file_type_mappings[file_type] = type_map
    return type_map

  def get_seq_file_def_name(self):
    paths = []
    for path_name, def_style in self.style.items():
      if (def_style.seq_file):
        paths.append(path_name)
    if (len(paths) == 0):
      return None
    elif (len(paths) > 1):
      raise RuntimeError("Multiple seq_file definitions: %s" % " ".join(paths))
    else :
      return paths[0]

########################################################################
#--- STANDALONE FUNCTIONS
def delete_phil_objects(current_phil, phil_path_list, only_scope=None):
  assert isinstance(phil_path_list, list)
  i = 0
  while i < len(current_phil.objects):
    full_path = current_phil.objects[i].full_path()
    if (only_scope is not None):
      if not ((only_scope == full_path) or
              (only_scope.startswith(full_path + ".")) or
              (full_path.startswith(only_scope + "."))):
        i += 1
        continue
    if current_phil.objects[i].is_template != 0 :
      i += 1
    elif full_path in phil_path_list :
      del current_phil.objects[i]
    else :
      # XXX: is this always true?
      if hasattr(current_phil.objects[i], "objects"):
        for path_name in phil_path_list :
          if path_name.startswith(full_path):
            delete_phil_objects(current_phil=current_phil.objects[i],
              phil_path_list=phil_path_list,
              only_scope=only_scope)
      i += 1

def find_and_replace_scope(current_phil, new_scope, scope_name):
  i = 0
  while (i < len(current_phil.objects)):
    full_path = current_phil.objects[i].full_path()
    if (full_path == scope_name):
      #assert (not current_phil.objects[i].multiple)
      new_scope.change_primary_parent_scope(current_phil)
      j = i
      while (j < len(current_phil.objects)):
        if (current_phil.objects[j].full_path() == scope_name):
          del current_phil.objects[j]
        else :
          j += 1
      current_phil.objects[i:i] = new_scope.objects
      break
    elif (scope_name.startswith(full_path + ".")):
      find_and_replace_scope(
        current_phil=current_phil.objects[i],
        new_scope=new_scope,
        scope_name=scope_name)
    i += 1

def collect_redundant_paths(master_phil, new_phil, multiple_only=True):
  phil_diff = master_phil.fetch_diff(source=new_phil)
  return _collect_unique_paths(phil_diff, multiple_only)

def _collect_unique_paths(phil_object, multiple_only=True):
  paths = []
  if phil_object.multiple :
    paths.append(phil_object.full_path())
  elif phil_object.is_scope :
    for object in phil_object.objects :
      if not object.full_path() in paths :
        paths.extend(_collect_unique_paths(object, multiple_only))
  elif not multiple_only and phil_object.is_definition :
    paths.append(phil_object.full_path())
  return paths

def get_all_path_names(phil_object, paths=None):
  if paths is None :
    paths = []
  full_path = phil_object.full_path()
  if not full_path in paths :
    paths.append(full_path)
  if phil_object.is_scope :
    for object in phil_object.objects :
      get_all_path_names(object, paths)

def index_phil_objects(phil_object,
                        path_index,
                        text_index,
                        template_index,
                        multiple_scopes=None,
                        multiple_defs=None,
                        collect_multiple=True,
                        in_template=False,
                        expert_levels=None,
                        input_files=None):
  full_path = phil_object.full_path()
  if expert_levels is not None :
    if phil_object.expert_level is not None :
      expert_levels[full_path] = phil_object.expert_level
    else :
      parent_scope = ".".join(full_path.split(".")[:-1])
      expert_levels[full_path] = expert_levels.get(parent_scope, 0)
  if phil_object.is_template != 0 :
    template_index[full_path] = phil_object
    if phil_object.is_template == -1 :
      return
    else :
      in_template = True
  elif in_template :
    template_index[full_path] = phil_object
  if (phil_object.multiple == True):
    if collect_multiple :
      if (phil_object.is_scope) and (multiple_scopes is not None):
        multiple_scopes[full_path] = True
      elif multiple_defs is not None :
        multiple_defs[full_path] = True
    if full_path in path_index :
      path_index[full_path].append(phil_object)
    else :
      path_index[full_path] = [phil_object]
  else :
    path_index[full_path] = phil_object
  if phil_object.is_definition and phil_object.type is None :
    raise RuntimeError("Type required for parameter '%s'." % full_path)
  text_index_for_child_objects = None
  if ((text_index is not None) and
      ((phil_object.expert_level is None) or (phil_object.expert_level <=3 ))):
    label = get_standard_phil_label(phil_object)
    text_fields = (label, str(phil_object.caption), str(phil_object.help),
      phil_object.is_definition)
    text_index[full_path] = text_fields
    text_index_for_child_objects = text_index
  if phil_object.is_scope :
    for object in phil_object.objects :
      index_phil_objects(phil_object=object,
                         path_index=path_index,
                         text_index=text_index_for_child_objects,
                         template_index=template_index,
                         multiple_scopes=multiple_scopes,
                         multiple_defs=multiple_defs,
                         collect_multiple=collect_multiple,
                         in_template=in_template,
                         expert_levels=expert_levels,
                         input_files=input_files)
  elif (input_files is not None):
    if (phil_object.type.phil_type in ["path", "strings"]):
      style = phil_object.style
      if (style is not None):
        style_words = style.split()
        if ("input_file" in style_words):
          input_files.append(full_path)

def reindex_phil_objects(phil_object, path_index, only_scope=None):
  if phil_object.is_template < 0 :
    return
  full_path = phil_object.full_path()
  if phil_object.multiple == True :
    if full_path in path_index :
      path_index[full_path].append(phil_object)
    else :
      path_index[full_path] = [phil_object]
  else :
    path_index[full_path] = phil_object
  if phil_object.is_scope :
    for object in phil_object.objects :
      reindex_phil_objects(object, path_index)

non_alnum = re.compile("[^A-Za-z0-9_]")
def substitute_directory_name(phil_object, path_name, sub_name,
    treat_name_as_var_name=True):
  assert (not non_alnum.search(sub_name))
  if (treat_name_as_var_name):
    sub_var = "$(" + sub_name + ")"
  else :
    sub_var = sub_name
  if path_name.endswith("/") or path_name.endswith("\\"):
    path_name = path_name[:-1]
  for object in phil_object.objects :
    if object.is_definition :
      if (object.type is None):
        raise RuntimeError("Missing type for PHIL parameter %s" %
          object.full_path())
      if (object.type.phil_type == "path"):
        py_object = object.extract()
        if (py_object is None) or (py_object is Auto) : continue
        if (not isinstance(py_object, str)):
          if isinstance(py_object, unicode) : # FIXME need to prevent this!
            py_object = str(py_object)
          else :
            raise RuntimeError("Disallowed type '%s' for path parameter '%s'." %
              (type(py_object), object.full_path()))
        py_object = py_object.replace(path_name, sub_var)
        new_object = object.format(python_object=py_object)
        object.words = new_object.words
    else :
      substitute_directory_name(object, path_name, sub_name)

def update_phil_file_paths(master_phil, file_name, old_path, new_path,
    use_iotbx_parser=False):
  if (use_iotbx_parser):
    import iotbx.phil
    parse = iotbx.phil.parse
  else :
    parse = libtbx.phil.parse
  phil_in = open(file_name).read()
  new_format = False
  out_lines = []
  for line in phil_in.splitlines():
    if line.startswith("LIBTBX_BASE_DIR"):
      line = line.replace(old_path, new_path)
      new_format = True
      out_lines.append(line)
    else :
      out_lines.append(line)
  if (new_format):
    open(file_name, "w").write("\n".join(out_lines))
  else :
    file_phil = parse(file_name=file_name)
    working_phil = master_phil.fetch(source=file_phil,
      skip_incompatible_objects=True)
    substitute_directory_name(
      phil_object=working_phil,
      path_name=old_path,
      sub_name="LIBTBX_BASE_DIR")
    f = open(file_name, "w")
    f.write("LIBTBX_BASE_DIR = \"%s\"\n" % new_path)
    working_phil.show(out=f)
    f.close()

def get_standard_phil_label(phil_object=None, phil_name=None, append=""):
  if phil_object is None and phil_name is None :
    raise Exception("No phil object or path name supplied.")
  if phil_object is not None :
    if phil_object.short_caption is None :
      if phil_name is not None :
        phil_object.short_caption = reformat_phil_name(phil_name)
      else :
        phil_object.short_caption = reformat_phil_name(phil_object.name)
    return phil_object.short_caption + append
  else :
    return reformat_phil_name(phil_name)

def reformat_phil_full_name(phil_full_name):
  phil_name = phil_full_name.split(".")[-1]
  return reformat_phil_name(phil_name)

def reformat_phil_name(phil_name):
  if phil_name == "" :
    return phil_name
  _name = " ".join(str(phil_name).split("_"))
  name = _name[0].upper() + _name[1:]
  return name

def join_scope_paths(scope1, scope2):
  if scope1 == "" :
    return scope2
  else :
    return "%s.%s" % (scope1, scope2)

def get_adjoining_phil_path(def_path, def_name):
  return ".".join(def_path.split(".")[:-1]) + "." + def_name

def validate_choice_captions(phil_scope):
  if (phil_scope.is_definition):
    if (phil_scope.type.phil_type == "choice"):
      words = phil_scope.words
      if (phil_scope.caption is not None):
        labels = phil_scope.caption.split()
        assert (len(labels) == len(words)), ("%s" % phil_scope.full_path())
  else :
    for phil_object in phil_scope.objects :
      validate_choice_captions(phil_object)

#---end


 *******************************************************************************


 *******************************************************************************
libtbx/phil/parser.py
from __future__ import absolute_import, division, print_function
import libtbx.phil

def collect_assigned_words(word_iterator, lead_word):
  have_comment = False
  last_word = lead_word
  result = []
  while True:
    word = word_iterator.try_pop(settings_index=1)
    if (word is None): break
    if (not have_comment
        and word.quote_token is None
        and word.value in ["{", "}", ";", "#"]):
      if (word.value == ";"):
        break
      if (word.value != "#"):
        word_iterator.backup()
        break
      have_comment = True
    elif (word.quote_token is not None
        or (last_word.quote_token is None and last_word.value == "\\")):
      if (not have_comment): result.append(word)
    elif (word.line_number != last_word.line_number):
      word_iterator.backup()
      break
    elif (word.value != "\\" or word.quote_token is not None):
      if (not have_comment): result.append(word)
    last_word = word
  if (len(result) == 0):
    raise RuntimeError("Missing value for %s%s" % (
      str(lead_word), lead_word.where_str()))
  return result

def collect_objects(
      word_iterator,
      converter_registry,
      primary_id_generator,
      primary_parent_scope,
      stop_token=None,
      start_word=None,
      definition_converter_cache=None,
      scope_extract_call_proxy_cache=None):
  if (definition_converter_cache is None):
    definition_converter_cache = {}
  if (scope_extract_call_proxy_cache is None):
    scope_extract_call_proxy_cache = {}
  prev_line_number = 0
  active_definition = None
  while True:
    lead_word = word_iterator.try_pop_unquoted()
    if (lead_word is None): break
    if (lead_word.value == "#phil"
        and lead_word.line_number != prev_line_number):
      word = word_iterator.pop_unquoted()
      if (word.value == "__END__"): break
      if (word.value == "__ON__"): continue
      if (word.value != "__OFF__"):
        raise RuntimeError("Unknown: %s %s%s" % (
          lead_word.value, word.value, word.where_str()))
      if (word_iterator.scan_for_start(
            intro=lead_word.value, followups=["__END__", "__ON__"]) == 0):
        break
      continue
    if (stop_token is not None and lead_word.value == stop_token):
      return
    if (lead_word.value == "{"):
      raise RuntimeError(
        'Syntax error: unexpected "{"%s' % lead_word.where_str())
    if (lead_word.value[:1] == "!"):
      lead_word.value = lead_word.value[1:]
      is_disabled = True
    else:
      is_disabled = False
    prev_line_number = lead_word.line_number
    word = word_iterator.pop()
    if (word.quote_token is None
        and (   word.value == "{"
             or word.value[:1] == "."
             or word.value[:2] == "!.")):
      if (not libtbx.phil.is_standard_identifier(lead_word.value)):
        if (lead_word.value == ";"):
          lead_word.raise_syntax_error("unexpected ")
        else:
          lead_word.raise_syntax_error("improper scope name ")
      active_definition = None
      scope = libtbx.phil.scope(
        name=lead_word.value,
        primary_id=next(primary_id_generator),
        is_disabled=is_disabled,
        where_str=lead_word.where_str())
      while True:
        if (word.value == "{"):
          break
        if (word.value[:1] == "!"):
          word.value = word.value[1:]
          is_disabled = True
        else:
          is_disabled = False
        if (word.value[:1] != "."
            or not scope.has_attribute_with_name(word.value[1:])):
          raise RuntimeError(
            "Unexpected scope attribute: %s%s" % (
              word.value, word.where_str()))
        word_iterator.pop_unquoted().assert_expected("=")
        assigned_words = collect_assigned_words(word_iterator, word)
        if (not is_disabled):
          scope.assign_attribute(
            name=word.value[1:],
            words=assigned_words,
            scope_extract_call_proxy_cache=scope_extract_call_proxy_cache)
        word = word_iterator.pop_unquoted()
      collect_objects(
        word_iterator=word_iterator,
        converter_registry=converter_registry,
        primary_id_generator=primary_id_generator,
        primary_parent_scope=scope,
        stop_token="}",
        start_word=word,
        definition_converter_cache=definition_converter_cache,
        scope_extract_call_proxy_cache=scope_extract_call_proxy_cache)
      primary_parent_scope.adopt(scope)
    else:
      word_iterator.backup()
      if (lead_word.value[:1] != "."):
        if (not libtbx.phil.is_standard_identifier(lead_word.value)):
          if (lead_word.value == ";"):
            lead_word.raise_syntax_error("unexpected ")
          else:
            lead_word.raise_syntax_error("improper definition name ")
        if (lead_word.value != "include"):
          word_iterator.pop_unquoted().assert_expected("=")
        active_definition = libtbx.phil.definition(
          name=lead_word.value,
          words=collect_assigned_words(word_iterator, lead_word),
          primary_id=next(primary_id_generator),
          is_disabled=is_disabled,
          where_str=lead_word.where_str())
        primary_parent_scope.adopt(active_definition)
      else:
        if (active_definition is None
            or not active_definition.has_attribute_with_name(
                     lead_word.value[1:])):
          raise RuntimeError("Unexpected definition attribute: %s%s" % (
            lead_word.value, lead_word.where_str()))
        word = word_iterator.pop_unquoted()
        word.assert_expected("=")
        assigned_words = collect_assigned_words(word_iterator, lead_word)
        if (not is_disabled):
          active_definition.assign_attribute(
            name=lead_word.value[1:],
            words=assigned_words,
            converter_registry=converter_registry,
            converter_cache=definition_converter_cache)
  if (stop_token is not None):
    if (start_word is None):
      where = ""
    else:
      where = start_word.where()
    if (where == ""):
      raise RuntimeError('Syntax error: missing "%s"' % stop_token)
    raise RuntimeError('Syntax error: no matching "%s" for "%s" at %s' %
      (stop_token, str(start_word), where))


 *******************************************************************************


 *******************************************************************************
libtbx/phil/tokenizer.py
from __future__ import absolute_import, division, print_function
from libtbx import slots_getstate_setstate

def escape_python_str(quote_char, string):
  return string.replace("\\", "\\\\").replace(quote_char, "\\"+quote_char)

def quote_python_str(quote_token, string):
  return quote_token \
       + escape_python_str(quote_char=quote_token[0], string=string) \
       + quote_token

class character_iterator(slots_getstate_setstate):

  __slots__ = [
    "input_string",
    "i_char",
    "line_number",
    "backup_i_char",
    "backup_line_number"]

  def __init__(O, input_string):
    O.input_string = input_string
    O.i_char = 0
    O.line_number = 1
    O.backup_i_char = None
    O.backup_line_number = None

  def mark_for_backup(O):
    O.backup_i_char = O.i_char
    O.backup_line_number = O.line_number

  def restore_backup(O):
    O.i_char = O.backup_i_char
    O.line_number = O.backup_line_number

  def look_ahead(O, n):
    end = O.i_char + n
    if (end > len(O.input_string)): return None
    return O.input_string[O.i_char:end]

  def look_ahead_1(O):
    if (O.i_char == len(O.input_string)): return None
    return O.input_string[O.i_char]

  def skip_ahead_1(O):
    if (O.input_string[O.i_char] == "\n"): O.line_number += 1
    O.i_char += 1

  def __next__(O):
    result = O.look_ahead_1()
    if (result is not None):
      O.i_char += 1
      if (result == "\n"): O.line_number += 1
    return result

  def scan_for_start(O, intro, followups):
    while True:
      if (O.i_char == len(O.input_string)): return 0
      if (O.input_string[O.i_char] != "\n"):
        O.i_char += 1
      else:
        while True:
          O.line_number += 1
          O.i_char += 1
          if (O.i_char == len(O.input_string)): return 0
          if (O.input_string[O.i_char] != "\n"): break
        if (O.input_string.find(
              intro, O.i_char, O.i_char+len(intro)) != O.i_char):
          O.i_char += 1
        else:
          O.i_char += len(intro)
          while True:
            if (O.i_char == len(O.input_string)): return 0
            if (O.input_string[O.i_char].isspace()): break
            O.i_char += 1
          while True:
            if (O.i_char == len(O.input_string)): return 0
            if (not O.input_string[O.i_char].isspace()): break
            O.i_char += 1
          for i_followup,followup in enumerate(followups):
            if (O.input_string.find(
                  followup,
                  O.i_char,
                  O.i_char+len(followup)) == O.i_char):
              O.i_char += len(followup)
              while True:
                if (O.i_char == len(O.input_string)): return i_followup
                c = O.input_string[O.i_char]
                O.i_char += 1
                if (c == "\n"):
                  O.line_number += 1
                  return i_followup
                if (not c.isspace()): break
              break
    return 0

def where(source_info, line_number):
  result = []
  if (source_info is not None):
    result.append(source_info)
    if (line_number is not None):
      result.append("line %d" % line_number)
  elif (line_number is not None):
    result.append("input line %d" % line_number)
  if (len(result) == 0): return None
  return ", ".join(result)

def where_str(source_info, line_number):
  s = where(source_info, line_number)
  if (s is None): return ""
  return " (%s)" % s

class word(slots_getstate_setstate):

  __slots__ = ["value", "quote_token", "line_number", "source_info"]

  def __init__(O,
        value,
        quote_token=None,
        line_number=None,
        source_info=None):
    O.value = value
    O.quote_token = quote_token
    O.line_number = line_number
    O.source_info = source_info

  def __str__(O):
    if (O.quote_token is None):
      return O.value
    return quote_python_str(quote_token=O.quote_token, string=O.value)

  def where(O):
    return where(O.source_info, O.line_number)

  def where_str(O):
    return where_str(O.source_info, O.line_number)

  def raise_syntax_error(O, message):
    raise RuntimeError(
      'Syntax error: %s"%s"%s' % (message, O.value, O.where_str()))

  def assert_expected(O, value):
    if (O.value != value):
      O.raise_syntax_error('expected "%s", found ' % value)

  def raise_unquoted_word_expected(O):
    raise RuntimeError('Unquoted word expected, found %s%s' % (
      str(O), O.where_str()))

default_contiguous_word_characters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ" \
                                   + "abcdefghijklmnopqrstuvwxyz" \
                                   + "0123456789" \
                                   + "_"
class settings(slots_getstate_setstate):

  __slots__ = [
    "unquoted_single_character_words",
    "contiguous_word_characters",
    "enable_unquoted_embedded_quotes",
    "comment_characters",
    "meta_comment"]

  def __init__(O,
        unquoted_single_character_words="",
        contiguous_word_characters=None,
        enable_unquoted_embedded_quotes=True,
        comment_characters="",
        meta_comment=None):
    O.unquoted_single_character_words = unquoted_single_character_words
    if (contiguous_word_characters is None):
      O.contiguous_word_characters = default_contiguous_word_characters
    else:
      O.contiguous_word_characters = contiguous_word_characters
    O.enable_unquoted_embedded_quotes = enable_unquoted_embedded_quotes
    O.comment_characters = comment_characters
    O.meta_comment = meta_comment

class word_iterator(slots_getstate_setstate):

  __slots__ = [
    "char_iter",
    "source_info",
    "list_of_settings"]

  def __init__(O,
        input_string,
        source_info=None,
        file_name=None,
        list_of_settings=None):
    assert source_info is None or file_name is None
    O.char_iter = character_iterator(input_string)
    if (source_info is None and file_name is not None):
      O.source_info = 'file "%s"' % file_name
    else:
      O.source_info = source_info
    if (list_of_settings is None):
      O.list_of_settings = [settings()]
    else:
      O.list_of_settings = list_of_settings

  def __iter__(O):
    return O

  def __next__(O, settings_index=0):
    settings = O.list_of_settings[settings_index]
    char_iter = O.char_iter
    char_iter.mark_for_backup()
    while True:
      c = next(char_iter)
      if (c is None): break
      if (c.isspace()): continue
      if (c in settings.comment_characters
          and (settings.meta_comment is None
               or char_iter.look_ahead(n=len(settings.meta_comment))
                  != settings.meta_comment)):
        while True:
          c = next(char_iter)
          if (c is None or c == "\n"): break
      elif (c in ['"', "'"]):
        quote_char = c
        word_value = []
        word_line_number = char_iter.line_number
        if (char_iter.look_ahead(n=2) == quote_char+quote_char):
          char_iter.skip_ahead_1()
          char_iter.skip_ahead_1()
          quote_token = quote_char+quote_char+quote_char
        else:
          quote_token = quote_char
        while True:
          c = next(char_iter)
          if (c == quote_char):
            if (quote_token is quote_char): break
            if (char_iter.look_ahead(n=2) == quote_char+quote_char):
              char_iter.skip_ahead_1()
              char_iter.skip_ahead_1()
              break
          if (c == "\\"):
            _ = char_iter.look_ahead_1()
            if (_ == "\\"):
              char_iter.skip_ahead_1()
            elif (_ == quote_char):
              c = next(char_iter)
            elif (_ == "\n"):
              char_iter.skip_ahead_1()
              continue
          if (c is None):
            raise RuntimeError(
              "Syntax error: missing closing quote%s" % (
                where_str(O.source_info, char_iter.line_number)))
          word_value.append(c)
        return word(
          value="".join(word_value),
          quote_token=quote_token,
          line_number=word_line_number,
          source_info=O.source_info)
      else:
        word_value = [c]
        word_line_number = char_iter.line_number
        if (c not in settings.unquoted_single_character_words
            and (settings.contiguous_word_characters == ""
                 or c in settings.contiguous_word_characters)):
          while True:
            c = char_iter.look_ahead_1()
            if (c is None): break
            if (c.isspace()): break
            if (c in settings.unquoted_single_character_words): break
            if (settings.contiguous_word_characters != ""
                and c not in settings.contiguous_word_characters
                and (not settings.enable_unquoted_embedded_quotes
                     or c not in ['"', "'"])):
              break
            word_value.append(c)
            char_iter.skip_ahead_1()
        return word(
          value="".join(word_value),
          line_number=word_line_number,
          source_info=O.source_info)
    raise StopIteration

  def try_pop(O, settings_index=0):
    try: return O.__next__(settings_index)
    except StopIteration: return None

  def pop(O, settings_index=0):
    try: return O.__next__(settings_index)
    except StopIteration: raise RuntimeError("Unexpected end of input.")

  def try_pop_unquoted(O, settings_index=0):
    word = O.try_pop(settings_index)
    if (word is not None):
      if (word.quote_token is not None): word.raise_unquoted_word_expected()
    return word

  def pop_unquoted(O, settings_index=0):
    word = O.pop(settings_index)
    if (word.quote_token is not None): word.raise_unquoted_word_expected()
    return word

  def backup(O):
    O.char_iter.restore_backup()

  def scan_for_start(O, intro, followups):
    O.char_iter.scan_for_start(intro, followups)


 *******************************************************************************


 *******************************************************************************
libtbx/phil/tst.py
from __future__ import absolute_import, division, print_function
from libtbx import phil
import libtbx.phil
from libtbx.utils import Sorry
from libtbx.test_utils import \
  Exception_expected, show_diff, anchored_block_show_diff
from libtbx import easy_pickle
from libtbx import Auto
import warnings
from six.moves import cStringIO as StringIO
import copy
import sys, os
from six.moves import range

def exercise_string_quote_and_tokenize():
  n_ok = [0]
  for quote_token in ["'", '"', "'''", '"""']:
    def check(string):
      input_string = phil.tokenizer.quote_python_str(
        quote_token=quote_token, string=string)
      words = phil.tokenize_value_literal(
        input_string=input_string, source_info="test_string")
      assert len(words) == 1
      word = words[0]
      assert word.quote_token == quote_token
      assert word.value == string
      assert str(word) == input_string
      n_ok[0] += 1
    ch_set = ["", "'", '"', "\n", "x"]
    for c0 in ch_set:
      check(string=c0)
      for c1 in ch_set:
        c01 = c0 + c1
        check(string=c01)
        for c2 in ch_set:
          c012 = c01 + c2
          check(string=c012)
          for c3 in ch_set:
            c0123 = c012 + c3
            check(string=c0123)
  assert n_ok[0] == 3120
  #
  def tvl(input_string):
    return phil.tokenize_value_literal(
      input_string=input_string, source_info=None)
  words = tvl(input_string='"\t\n\r\x7a\x8F"')
  assert len(words) == 1
  assert words[0].value == "\t\n\rz\x8f"
  assert str(words[0]) == '"\t\n\rz\x8f"'
  value = "".join([chr(_) for _ in range(256)])
  words = tvl(input_string=phil.tokenizer.quote_python_str(
    quote_token='"', string=value))
  assert len(words) == 1
  assert words[0].value == value
  words = tvl(input_string=str(words[0]))
  assert len(words) == 1
  assert words[0].value == value
  word = phil.tokenizer.word(value=value, quote_token='"')
  words = tvl(input_string=str(word))
  assert len(words) == 1
  assert words[0].value == value

class recycle(object):

  def __init__(self,
        input_string,
        prefix="",
        attributes_level=0,
        print_width=None,
        expected_out=None):
    self.parameters = phil.parse(input_string=input_string)
    self.out = StringIO()
    self.parameters.show(
      out=self.out,
      prefix=prefix,
      attributes_level=attributes_level,
      print_width=print_width)
    self.out = self.out.getvalue()
    if (expected_out is not None):
      assert not show_diff(self.out, expected_out)
    if (prefix == ""):
      out_parameters = phil.parse(input_string=self.out)
      out_out = StringIO()
      out_parameters.show(
        out=out_out,
        prefix=prefix,
        attributes_level=attributes_level,
        print_width=print_width)
      out_out = out_out.getvalue()
      if (out_out != self.out):
        print("self.out:")
        sys.stdout.write(self.out)
        print("out_out:")
        sys.stdout.write(out_out)
        raise RuntimeError("out_out != self.out")

def exercise_parse_and_show():
  for input_string in ["", "\n", "   \n", "   \t \n \t ", "#", "\t#"]:
    recycle(input_string=input_string, expected_out="")
  recycle(
    input_string="   name\t=value\n\n",
    expected_out="name = value\n")
  recycle(
    input_string='name="value\\\\"',
    expected_out='name = "value\\\\"\n')
  recycle(
    input_string='name="value\\\\\\""',
    expected_out='name = "value\\\\\\""\n')
  r = recycle(
    input_string="   name\t=\tvalue\n\n",
    attributes_level=3,
    expected_out="""\
name = value
  .help = None
  .caption = None
  .short_caption = None
  .optional = None
  .type = None
  .multiple = None
  .input_size = None
  .style = None
  .expert_level = None
""")
  input_string = """\
name=value
.help=help message with detailed information
.optional=True
.type=path
"""
  recycle(input_string=input_string, attributes_level=3, expected_out="""\
name = value
  .help = "help message with detailed information"
  .caption = None
  .short_caption = None
  .optional = True
  .type = path
  .multiple = None
  .input_size = None
  .style = None
  .expert_level = None
""")
  recycle(input_string=input_string, attributes_level=2, expected_out="""\
name = value
  .help = "help message with detailed information"
  .optional = True
  .type = path
""")
  recycle(input_string=input_string, attributes_level=1, expected_out="""\
name = value
  .help = "help message with detailed information"
""")
  recycle(input_string=input_string, attributes_level=0, expected_out="""\
name = value
""")
  recycle(input_string=input_string, attributes_level=1, print_width=25,
    expected_out="""\
name = value
  .help = "help message"
          "with detailed"
          "information"
""")
  recycle(
    input_string="name { }", expected_out="""\
name {
}
""")
  recycle(
    input_string="name\n.help=message\n.expert_level=3\n{ }",
    attributes_level=3,
    expected_out="""\
name
  .style = None
  .help = message
  .caption = None
  .short_caption = None
  .optional = None
  .call = None
  .multiple = None
  .sequential_format = None
  .disable_add = None
  .disable_delete = None
  .expert_level = 3
{
}
""")
  recycle(
    input_string="name{a=b\nc=d\n}", expected_out="""\
name {
  a = b
  c = d
}
""")
  recycle(
    input_string=\
      "a=b\nc=d\n e {} name { var1=None\nvar2=None\n} f=g",
    prefix=" prefix ",
    expected_out="""\
 prefix a = b
 prefix c = d
 prefix e {
 prefix }
 prefix name {
 prefix   var1 = None
 prefix   var2 = None
 prefix }
 prefix f = g
""")
  recycle(
    input_string="""\
!name # 1 2 3
  !.help="a"
        "b"
        "c"
      # 1 2 3
  .expert_level=1 # x
        # 1 2 3
{
  !a=b
    .type="int" # y
  c=d # e
    !.help="d"
          "e"
          "f"
    .expert_level=2
}
d=a b c # 1 {2} 3 \\
4 {5 6}}
""",
    attributes_level=2,
    expected_out="""\
!name
  .expert_level = 1
{
  !a = b
    .type = int(allow_none=True)
  c = d
    .expert_level = 2
}
d = a b c
""")
  #
  params = phil.parse(input_string="""\
x=1
y=2
  .expert_level=1
z=3
  .expert_level=2
s {
  a=x
}
t
  .expert_level=1
{
  a=y
}
u
  .expert_level=2
{
  a=z
}
""")
  assert not show_diff(params.as_str(expert_level=0), """\
x = 1
s {
  a = x
}
""")
  assert not show_diff(params.as_str(expert_level=1), """\
x = 1
y = 2
s {
  a = x
}
t {
  a = y
}
""")
  for expert_level in [-1,2,3,None]:
    assert not show_diff(params.as_str(expert_level=expert_level), """\
x = 1
y = 2
z = 3
s {
  a = x
}
t {
  a = y
}
u {
  a = z
}
""")
  #
  recycle(
    input_string="s{a=1}t{b=2}", expected_out="""\
s {
  a = 1
}
t {
  b = 2
}
""")
  recycle(
    input_string="s{a=1;b=2  b ;c=3}t{x=4;y=5;}", expected_out="""\
s {
  a = 1
  b = 2 b
  c = 3
}
t {
  x = 4
  y = 5
}
""")
  recycle(
    input_string=
      "a=None;.type=int;s .multiple=True;.optional=False{c=None}"
      "t .style=column;{d=None;.type=float;.optional=True;e=x;.type=str;}",
    attributes_level=2,
    expected_out="""\
a = None
  .type = int(allow_none=True)
s
  .optional = False
  .multiple = True
{
  c = None
}
t
  .style = column
{
  d = None
    .optional = True
    .type = float(allow_none=True)
  e = x
    .type = str
}
""")

improper_phil_converters = None

class int_phil_converters(object):

  def __init__(self, factor=1):
    assert int(factor) == factor
    self.factor = factor

  def __str__(self):
    if (self.factor == 1): return "libtbx.phil.tst.int"
    return "libtbx.phil.tst.int(factor=%d)" % self.factor

  def from_words(self, words, master):
    value = phil.int_from_words(words=words, path=master.full_path())
    if (value is None): return value
    return value * self.factor

  def as_words(self, python_object, master):
    if (python_object is None):
      return [phil.tokenizer.word(value="None")]
    return [phil.tokenizer.word(value=str(python_object/self.factor))]

class converter_implementation(int_phil_converters):

  def __str__(self):
    if (self.factor == 1): return "libtbx.phil.tst.converter_factory"
    return "libtbx.phil.tst.converter_factory(factor=%d)" % self.factor

def converter_factory_phil_converters(**args):
  return converter_implementation(**args)

def exercise_import_converters():
  input_string = """\
x1=None
  .type=libtbx.phil.tst.int
y1=3
  .type=libtbx.phil.tst.int
x2=None
  .type=libtbx.phil.tst.int(factor=2)
y2=3
  .type=libtbx.phil.tst.int( factor = 2 )
z3=4
  .type=libtbx.phil.tst.converter_factory( factor= 3 )
"""
  r = recycle(input_string=input_string, expected_out="""\
x1 = None
  .type = libtbx.phil.tst.int
y1 = 3
  .type = libtbx.phil.tst.int
x2 = None
  .type = libtbx.phil.tst.int(factor=2)
y2 = 3
  .type = libtbx.phil.tst.int(factor=2)
z3 = 4
  .type = libtbx.phil.tst.converter_factory(factor=3)
""",
    attributes_level=2)
  params = r.parameters.extract()
  assert params.x1 is None
  assert params.y1 == 3
  assert params.x2 is None
  assert params.y2 == 6
  assert params.z3 == 12
  #
  try: phil.parse("""\
x=None
  .type=foo.int
""")
  except RuntimeError as e:
    assert str(e) == 'Unexpected definition type: "foo.int" (input line 2)'
  else: raise Exception_expected
  #
  try: phil.parse("""\
x=None
  .type=libtbx.phil.tst.none
""")
  except AttributeError as e:
    assert str(e) == '.type=libtbx.phil.tst.none: object' \
      ' "none_phil_converters" not found in module "libtbx.phil.tst"' \
      ' (input line 2)'
  else: raise Exception_expected
  #
  try: phil.parse("""\
x=None
  .type=libtbx.phil.tst.improper
""")
  except TypeError as e:
    assert str(e) == '"libtbx.phil.tst.improper_phil_converters" is not' \
      ' a callable Python object (input line 2)'
  else: raise Exception_expected
  #
  try: phil.parse("""\
x=None
  .type=libtbx.phil.tst.int(factor=1.5)
""")
  except RuntimeError as e:
    e = str(e)
    assert e.startswith(
      'Error constructing definition type "libtbx.phil.tst.int(factor=1.5)":'
      ' AssertionError: ')
    assert e.endswith(' (input line 2)')
  else: raise Exception_expected
  #
  try: phil.parse("""\
x=None
  .type=libtbx.phil.tst.int(a=1=2)
""")
  except RuntimeError as e:
    assert str(e) == 'Error evaluating definition type "libtbx.phil.tst.int' \
      '(a=1=2)": SyntaxError: invalid syntax (line 1) (input line 2)'
  else: raise Exception_expected

def test_exception(input_string, exception_string=None):
  try: phil.parse(input_string=input_string)
  except KeyboardInterrupt: raise
  except Exception as e:
    if (exception_string is None or str(e) != exception_string):
      print(str(e))
      if (exception_string is not None):
        print(exception_string)
    if (exception_string is not None):
      assert str(e) == exception_string
  else: raise Exception_expected

def exercise_syntax_errors():
  test_exception("'a'",
    """Unquoted word expected, found 'a' (input line 1)""")
  test_exception("a",
    'Unexpected end of input.')
  test_exception("a=\nb",
    'Missing value for a (input line 1)')
  test_exception("x=;",
    'Missing value for x (input line 1)')
  test_exception("s{z=}",
    'Missing value for z (input line 1)')
  test_exception("s{y={",
    'Missing value for y (input line 1)')
  test_exception("s{y=1{",
    'Syntax error: unexpected "{" (input line 1)')
  test_exception("s{y=#",
    'Missing value for y (input line 1)')
  test_exception("a b",
    'Syntax error: expected "=", found "b" (input line 1)')
  test_exception("{}",
    'Syntax error: unexpected "{" (input line 1)')
  test_exception("a {",
    'Syntax error: no matching "}" for "{" at input line 1')
  test_exception(";{}",
    'Syntax error: unexpected ";" (input line 1)')
  test_exception("s{;}",
    'Syntax error: unexpected ";" (input line 1)')
  test_exception("a=b\n.foo none",
    'Unexpected definition attribute: .foo (input line 2)')
  test_exception('a=b\nc "abc',
    'Syntax error: missing closing quote (input line 2)')
  test_exception('1 {',
    'Syntax error: improper scope name "1" (input line 1)')
  test_exception('scope\n.foo',
    'Unexpected scope attribute: .foo (input line 2)')
  test_exception('a. 2',
    'Syntax error: improper definition name "a." (input line 1)')
  test_exception('a.include=None',
    'Reserved identifier: "include" (input line 1)')
  test_exception('include {}',
    'Reserved identifier: "include" (input line 1)')
  test_exception('a.include.b.c {}',
    'Reserved identifier: "include" (input line 1)')
  test_exception('__foo__=None',
    'Reserved identifier: "__foo__" (input line 1)')
  test_exception('__foo__ {}',
    'Reserved identifier: "__foo__" (input line 1)')
  test_exception('a=None\n.type=foo',
    'Unexpected definition type: "foo" (input line 2)')
  test_exception('s .multiple=True .optional=False {}',
    'One True or False value expected, .multiple="True .optional=False" found'
    ' (input line 1)')

def exercise_phil_on_off_end():
  assert phil.parse(input_string="#phil __ON__\na=1").as_str() == "a = 1\n"
  assert phil.parse(input_string="#phil __OFF__\na=1").as_str() == ""
  assert phil.parse(input_string="#phil __END__\na=1").as_str() == ""
  assert phil.parse(input_string="#phil __OFF__\n#phil __ON__ \na=1").as_str()\
    == "a = 1\n"
  assert phil.parse(input_string="#phil __END__\n#phil __ON__ \na=1").as_str()\
    == ""
  params = phil.parse(input_string="""\

#phil __OFF__
a b c
#phil __ON__
a=1
#phil __OFF__
c a b
 #phil __ON__
b=2

#phil __ON__
c=3
# phil __OFF__
d=4
#phil __OFF__ b
e=5
#phil __OFF__
f=6
""")
  assert not show_diff(params.as_str(), """\
a = 1
c = 3
d = 4
""")
  assert params.get(path="a").objects[0].words[0].line_number == 5
  assert params.get(path="c").objects[0].words[0].line_number == 12
  assert params.get(path="d").objects[0].words[0].line_number == 14
  try: phil.parse(input_string="#phil __Off__\n")
  except RuntimeError as e:
    assert str(e) == "Unknown: #phil __Off__ (input line 1)"
  else: raise Exception_expected

def exercise_deepcopy():
  parameters = phil.parse(input_string="""\
  a=1
  b {
    a=1
  }
""")
  copy.deepcopy(parameters)

def check_get(parameters, path, expected_out=None, with_substitution=False):
  out = StringIO()
  parameters.get(
    path=path,
    with_substitution=with_substitution).show(out=out)
  out = out.getvalue()
  if (expected_out is None or out != expected_out):
    sys.stdout.write(out)
  if (expected_out is not None and out != expected_out):
    raise RuntimeError("out != expected_out")

def check_get_sub(parameters, path, expected_out=None):
  check_get(parameters, path, expected_out, with_substitution=True)

def exercise_get_without_substitution():
  parameters = phil.parse(input_string="""\
a=b
c=d
e {
  a=1
  b=x
}
e=g""")
  check_get(parameters, path="", expected_out="""\
a = b
c = d
e {
  a = 1
  b = x
}
e = g
""")
  check_get(parameters, path="a", expected_out="""\
a = b
""")
  check_get(parameters, path="e", expected_out="""\
e {
  a = 1
  b = x
}
e = g
""")
  check_get(parameters, path="e.a", expected_out="""\
a = 1
""")
  check_get(parameters, path="e.b", expected_out="""\
b = x
""")
  check_get(parameters, path="e.c", expected_out="")

def exercise_nested():
  parameters = recycle(
    input_string="""\
d0=0
a0 {
  d1=a b c
  include file name
  a1 {
    t0 {
      c=yes
      t1 {
        x=0
        y=1.
          .multiple=True
      }
    }
  }
  d2=e f 0g
  !d3=x
}
""",
    expected_out="""\
d0 = 0
a0 {
  d1 = a b c
  include file name
  a1 {
    t0 {
      c = yes
      t1 {
        x = 0
        y = 1.
      }
    }
  }
  d2 = e f 0g
  !d3 = x
}
""").parameters
  check_get(parameters, path="a0.d1", expected_out="d1 = a b c\n")
  check_get(parameters, path="a0.a1.t0.c", expected_out="c = yes\n")
  check_get(parameters, path="a0.a1.t0.t1.x", expected_out="x = 0\n")
  check_get(parameters, path="a0.a1.t0.t1.y", expected_out="y = 1.\n")
  assert [item.path for item in parameters.all_definitions()] == [
    "d0", "a0.d1", "a0.a1.t0.c", "a0.a1.t0.t1.x", "a0.a1.t0.t1.y", "a0.d2"]
  assert [item.path for item in parameters.all_definitions(
    suppress_multiple=True)] == [
    "d0", "a0.d1", "a0.a1.t0.c", "a0.a1.t0.t1.x", "a0.d2"]
  parameters = phil.parse(input_string="""\
s {
  a=0
}
t.a=0
""")
  check_get(parameters, path="s", expected_out="""\
s {
  a = 0
}
""")
  check_get(parameters, path="s.a", expected_out="""\
a = 0
""")
  check_get(parameters, path="t", expected_out="""\
t.a = 0
""")
  check_get(parameters, path="t.a", expected_out="""\
a = 0
""")
  parameters = phil.parse(input_string="""\
s {
  a {
    b=0
    c.d=1
  }
}
t.a.b=0
t.a.c.d=1
""")
  out = StringIO()
  parameters.show(out=out)
  assert not show_diff(out.getvalue(), """\
s {
  a {
    b = 0
    c.d = 1
  }
}
t.a.b = 0
t.a.c.d = 1
""")
  check_get(parameters, path="s", expected_out="""\
s {
  a {
    b = 0
    c.d = 1
  }
}
""")
  check_get(parameters, path="s.a", expected_out="""\
a {
  b = 0
  c.d = 1
}
""")
  check_get(parameters, path="s.a.b", expected_out="""\
b = 0
""")
  check_get(parameters, path="s.a.c", expected_out="""\
c.d = 1
""")
  check_get(parameters, path="t", expected_out="""\
t.a.b = 0
t.a.c.d = 1
""")
  check_get(parameters, path="t.a", expected_out="""\
a.b = 0
a.c.d = 1
""")
  check_get(parameters, path="t.a.b", expected_out="""\
b = 0
""")
  check_get(parameters, path="t.a.c", expected_out="""\
c.d = 1
""")
  parameters = phil.parse(input_string="""\
a { b { } c { } }
x.y { }
x.z { }
""")
  check_get(parameters, path="a", expected_out="""\
a {
  b {
  }
  c {
  }
}
""")
  check_get(parameters, path="a.b", expected_out="""\
b {
}
""")
  check_get(parameters, path="a.c", expected_out="""\
c {
}
""")
  check_get(parameters, path="x", expected_out="""\
x.y {
}
x.z {
}
""")
  check_get(parameters, path="x.y", expected_out="""\
y {
}
""")
  check_get(parameters, path="x.z", expected_out="""\
z {
}
""")
  parameters = phil.parse(input_string="""\
x.y { a.b { d.e=0
} }
""")
  check_get(parameters, path="x", expected_out="""\
x.y {
  a.b {
    d.e = 0
  }
}
""")
  check_get(parameters, path="x.y", expected_out="""\
y {
  a.b {
    d.e = 0
  }
}
""")
  check_get(parameters, path="x.y.a", expected_out="""\
a.b {
  d.e = 0
}
""")
  check_get(parameters, path="x.y.a.b", expected_out="""\
b {
  d.e = 0
}
""")
  check_get(parameters, path="x.y.a.b.d", expected_out="""\
d.e = 0
""")
  check_get(parameters, path="x.y.a.b.d.e", expected_out="""\
e = 0
""")

def check_resolve_variables(parameters, path, expected_out=None, n_matches=1):
  matches = parameters.get(path=path, with_substitution=False)
  assert len(matches.objects) == n_matches
  result = matches.objects[0].resolve_variables().as_str()
  if (expected_out is None):
    print('  check_resolve_variables(parameters, "%s", "%s")' % (
      path, result.replace("\n", "\\n")))
  elif (result != expected_out):
    raise AssertionError('"%s" != "%s"' % (result, expected_out))

def exercise_get_with_substitution():
  parameters = phil.parse(input_string="""\
a=b
c = d   e   2
""")
  check_get_sub(parameters, path="a", expected_out="a = b\n")
  check_get_sub(parameters, path="c", expected_out="c = d e 2\n")
  check_resolve_variables(parameters, "a", "a = b\n")
  check_resolve_variables(parameters, "c", "c = d e 2\n")
  parameters = phil.parse(input_string="""\
a=1
b=$a
c=$b
d=2
e=$(.d) $c
s {
  i=10
  j=$i
  k=$j
  l=20
  m=$l $k
  n=$a
  t {
    x=$l
    y=$k
    z=$n
    n=$a $j $y
  }
  d=9
  e=$(d)
  f=$(.d)
  g=$(.s.t.x)
}
d=x
f=$(s.i)
g=$(s.a)
s {
  t {
    x=30
    a=40
  }
}
h=$(s.t.x)
i=$(s.t.a)
j=$(s.t.n)
k=$(.s.t.x)
l=$s
""")
  check_resolve_variables(parameters, "a", "a = 1\n")
  check_resolve_variables(parameters, "b", "b = 1\n")
  check_resolve_variables(parameters, "c", "c = 1\n")
  check_resolve_variables(parameters, "d", "d = 2\n", n_matches=2)
  check_resolve_variables(parameters, "e", "e = 2 1\n")
  check_resolve_variables(parameters, "s.i", "i = 10\n")
  check_resolve_variables(parameters, "s.j", "j = 10\n")
  check_resolve_variables(parameters, "s.k", "k = 10\n")
  check_resolve_variables(parameters, "s.m", "m = 20 10\n")
  check_resolve_variables(parameters, "s.n", "n = 1\n")
  check_resolve_variables(parameters, "s.t.x", "x = 20\n", n_matches=2)
  check_resolve_variables(parameters, "s.t.y", "y = 10\n")
  check_resolve_variables(parameters, "s.t.z", "z = 1\n")
  check_resolve_variables(parameters, "s.t.n", "n = 1 10 10\n")
  check_resolve_variables(parameters, "f", "f = 10\n")
  try: check_resolve_variables(parameters, "g")
  except RuntimeError as e:
    assert str(e) == 'Undefined variable: $s.a (input line 26)'
  else: raise Exception_expected
  check_resolve_variables(parameters, "h", "h = 30\n")
  check_resolve_variables(parameters, "i", "i = 40\n")
  check_resolve_variables(parameters, "j", "j = 1 10 10\n")
  check_resolve_variables(parameters, "k", "k = 30\n")
  check_resolve_variables(parameters, "s.e", "e = 9\n")
  check_resolve_variables(parameters, "s.f", "f = 2\n")
  check_resolve_variables(parameters, "s.g", "g = 20\n")
  try: check_resolve_variables(parameters, "l")
  except RuntimeError as e:
    assert str(e) == 'Not a definition: $s (input line 37)'
  else: raise Exception_expected
  check_resolve_variables(parameters, "h", "h = 30\n")
  #
  parameters = phil.parse(input_string="""\
a=$a
b=$c
c=$b
d=$e
e=$f
f=$d
g=$d
h=$_X_Y_Z_
o=$_X_Y_Z_/abc.ext
p="$_X_Y_Z_/abc.ext"
q=$o$_X_Y_Z_/abc.ext$p
r="$o$_X_Y_Z_ abc.ext$p"
i=0
i=1
j=$i
k=x
k=y
l=$k
k=z
m=$k
""")
  assert len(parameters.get(path="a", with_substitution=False).objects) == 1
  diags = {
    "a": "Undefined variable: $a (input line 1)",
    "b": "Undefined variable: $c (input line 2)",
    "c": "Undefined variable: $c (input line 2)",
    "d": "Undefined variable: $e (input line 4)",
    "e": "Undefined variable: $f (input line 5)",
    "f": "Undefined variable: $e (input line 4)",
    "g": "Undefined variable: $e (input line 4)"}
  for path in "abcdefg":
    try: parameters.get(path=path)
    except RuntimeError as e:
      if (str(e) != diags[path]):
        raise AssertionError("%s != %s" % (repr(str(e)), repr(diags[path])))
    else: raise Exception_expected
  try: parameters.get(path="h")
  except RuntimeError as e:
    assert str(e) == "Undefined variable: $_X_Y_Z_ (input line 8)"
  else: raise Exception_expected
  os.environ["_X_Y_Z_"] = "xyz"
  check_get_sub(parameters, path="h", expected_out='h = "xyz"\n')
  assert parameters.get(path="h").objects[0].words[0].where_str() \
      == ' (environment: "_X_Y_Z_")'
  check_get_sub(parameters, path="o", expected_out='o = "xyz/abc.ext"\n')
  check_get_sub(parameters, path="p", expected_out='p = "xyz/abc.ext"\n')
  check_get_sub(parameters, path="q",
    expected_out='q = "xyz/abc.extxyz/abc.extxyz/abc.ext"\n')
  check_get_sub(parameters, path="r",
    expected_out='r = "xyz/abc.extxyz abc.extxyz/abc.ext"\n')
  check_get_sub(parameters, path="j", expected_out='j = 1\n')
  check_get_sub(parameters, path="l", expected_out='l = y\n')
  check_get_sub(parameters, path="m", expected_out='m = z\n')
  parameters = phil.parse(input_string="""\
a=x
b=$a
c=$a $b.d
d=$a \\$b
answer=yes no
e="$a"
f=$(a)
g=abc$(answer)bc
h=abc$(answer)bc 12$answer$(a)56
i=$
j=$(abc
k=$(1bc)
l=$()
m=$@
n='$a'
""")
  check_get_sub(parameters, path="a", expected_out="a = x\n")
  check_get_sub(parameters, path="b", expected_out="b = x\n")
  check_get_sub(parameters, path="c", expected_out='c = x "x.d"\n')
  check_get_sub(parameters, path="d", expected_out="d = x \\$b\n")
  check_get_sub(parameters, path="answer", expected_out="answer = yes no\n")
  check_get_sub(parameters, path="e", expected_out='e = "x"\n')
  check_get_sub(parameters, path="f", expected_out='f = x\n')
  check_get_sub(parameters, path="g", expected_out='g = "abcyes nobc"\n')
  check_get_sub(parameters, path="h",
    expected_out='h = "abcyes nobc" "12yes nox56"\n')
  try: parameters.get(path="i")
  except RuntimeError as e:
    assert str(e) == 'Syntax error: $ must be followed by an identifier:' \
                   + ' "$" (input line 10)'
  else: raise Exception_expected
  try: parameters.get(path="j")
  except RuntimeError as e:
    assert str(e) == 'Syntax error: missing ")": "$(abc" (input line 11)'
  else: raise Exception_expected
  try: parameters.get(path="k")
  except RuntimeError as e:
    assert str(e) == 'Syntax error: improper variable name "$(1bc)"' \
                   + ' (input line 12)'
  else: raise Exception_expected
  try: parameters.get(path="l")
  except RuntimeError as e:
    assert str(e)=='Syntax error: improper variable name "$()" (input line 13)'
  else: raise Exception_expected
  try: parameters.get(path="m")
  except RuntimeError as e:
    assert str(e)=='Syntax error: improper variable name "$@" (input line 14)'
  else: raise Exception_expected
  check_get_sub(parameters, path="n", expected_out="n = '$a'\n")
  #
  parameters = phil.parse(input_string="""\
v=x
w=y
s {
  a=$v
  s {
    a=$w
    b=$(s.a)
    c=$(s.s.a)
    d=$(.s.a)
  }
}
""")
  check_get_sub(parameters, path="s", expected_out="""\
s {
  a = x
  s {
    a = y
    b = y
    c = y
    d = x
  }
}
""")
  #
  parameters = phil.parse(input_string="""\
a=$b
!b=y
""")
  try: parameters.get(path="a")
  except RuntimeError as e:
    assert str(e) == 'Undefined variable: $b (input line 1)'
  else: raise Exception_expected

def exercise_full_path():
  params = phil.parse(input_string="""\
d0=0
a0 {
  d1=a
  a1 {
    t0 {
      c=yes
      t1 {
        x=0
      }
    }
  }
  d2=e
}
""")
  for path in ["d0", "a0", "a0.d1", "a0.a1", "a0.a1.t0", "a0.a1.t0.c",
               "a0.a1.t0.t1", "a0.a1.t0.t1.x", "a0.d2"]:
    assert params.get(path).objects[0].full_path() == path

def exercise_include():
  with open("tmp1.params", "w") as f:
    print("""\
!include none
a=x
""", file=f)
  with open("tmp2.params", "w") as f:
    print("""\
b=y
""", file=f)
  with open("tmp3.params", "w") as f:
    print("""\
c=z
include file tmp2.params
d=$z
""", file=f)
  parameters = phil.parse(
    input_string="""\
tmp2=tmp2.params
include file tmp1.params
include file $tmp2
r=0
include file tmp3.params
s=1
""",
    process_includes=True)
  out = StringIO()
  parameters.show(out=out)
  assert not show_diff(out.getvalue(), """\
tmp2 = tmp2.params
!include none
a = x
b = y
r = 0
c = z
b = y
d = $z
s = 1
""")
  out = StringIO()
  parameters.unique().show(out=out)
  assert not show_diff(out.getvalue(), """\
tmp2 = tmp2.params
a = x
r = 0
c = z
b = y
d = $z
s = 1
""")
  try: parameters.get(path="d")
  except RuntimeError as e:
    assert str(e) == 'Undefined variable: $z (file "tmp3.params", line 3)'
  else: raise Exception_expected
  try: os.makedirs("tmp")
  except OSError: pass
  #
  with open("tmp1.params", "w") as f:
    print("""\
include file tmp3.params
""", file=f)
  with open("tmp2.params", "w") as f:
    print("""\
include file tmp1.params
""", file=f)
  with open("tmp3.params", "w") as f:
    print("""\
include file tmp2.params
""", file=f)
  try: parameters = phil.parse(
    file_name="tmp1.params",
    process_includes=True)
  except RuntimeError as e:
    assert str(e).startswith("Include dependency cycle: ")
    assert len(str(e).split(",")) == 4
  else: raise Exception_expected
  #
  with open("tmp1.params", "w") as f:
    print("""\
a=0
include file tmp/tmp1.params
x=1
""", file=f)
  with open("tmp/tmp1.params", "w") as f:
    print("""\
b=1
include file tmp2.params
y=2
""", file=f)
  with open("tmp/tmp2.params", "w") as f:
    print("""\
c=2
z=3
""", file=f)
  parameters = phil.parse(
    file_name="tmp1.params",
    process_includes=True)
  out = StringIO()
  parameters.show(out=out)
  assert not show_diff(out.getvalue(), """\
a = 0
b = 1
c = 2
z = 3
y = 2
x = 1
""")
  with open("tmp4.params", "w") as f:
    print("""\
a=1
include file tmp1.params
s {
  a=2
  include file tmp1.params
  z=2
}
s {
  a=3
  include file tmp1.params
  z=3
}
z=1
""", file=f)
  parameters = phil.parse(
    file_name="tmp4.params",
    process_includes=True)
  out = StringIO()
  parameters.show(out=out)
  assert not show_diff(out.getvalue(), """\
a = 1
a = 0
b = 1
c = 2
z = 3
y = 2
x = 1
s {
  a = 2
  a = 0
  b = 1
  c = 2
  z = 3
  y = 2
  x = 1
  z = 2
}
s {
  a = 3
  a = 0
  b = 1
  c = 2
  z = 3
  y = 2
  x = 1
  z = 3
}
z = 1
""")
  out = StringIO()
  parameters.unique().show(out=out)
  assert not show_diff(out.getvalue(), """\
a = 0
b = 1
c = 2
y = 2
x = 1
s {
  a = 0
  b = 1
  c = 2
  y = 2
  x = 1
  z = 3
}
z = 1
""")
  #
  try: phil.parse(input_string="""\
include foo
""", process_includes=True)
  except RuntimeError as e:
    assert str(e) \
      == '"include" must be followed by at least two arguments (input line 1)'
  else: raise Exception_expected
  try: phil.parse(input_string="""\
include foo bar
""", process_includes=True)
  except RuntimeError as e:
    assert str(e) == "Unknown include type: foo (input line 1)"
  else: raise Exception_expected
  try: phil.parse(input_string="""\
include file foo foo
""", process_includes=True)
  except RuntimeError as e:
    assert str(e) \
      == '"include file" must be followed exactly one argument (input line 1)'
  else: raise Exception_expected
  #
  params = phil.parse(input_string="""\
include scope libtbx.phil.tst.include_scope_target_1
""", process_includes=True)
  assert not show_diff(params.as_str(attributes_level=1), """\
x = 1
  .help = u
s
  .help = v
{
  y = 2
    .help = w
}
""")
  params = phil.parse(input_string="""\
o {
  include scope libtbx.phil.tst.include_scope_target_1
}
""", process_includes=True)
  assert not show_diff(params.as_str(attributes_level=1), """\
o {
  x = 1
    .help = u
  s
    .help = v
  {
    y = 2
      .help = w
  }
}
""")
  assert not show_diff(params.get('o.s.y').objects[0].full_path(), 'o.s.y')
  params = phil.parse(input_string="""\
include scope libtbx.phil.tst.include_scope_target_1 x
""", process_includes=True)
  assert not show_diff(params.as_str(attributes_level=1), """\
x = 1
  .help = u
""")
  params = phil.parse(input_string="""\
include scope libtbx.phil.tst.include_scope_target_1 s
""", process_includes=True)
  assert not show_diff(params.as_str(attributes_level=1), """\
s
  .help = v
{
  y = 2
    .help = w
}
""")
  params = phil.parse(input_string="""\
a = None
c {
  include scope libtbx.phil.tst.include_scope_target_1 s.y
}
b = None
""", process_includes=True)
  assert not show_diff(params.as_str(attributes_level=1), """\
a = None
c {
  y = 2
    .help = w
}
b = None
""")
  for incl_postfix in ["", "s"]:
    params = phil.parse(input_string="""\
a = None
c {
  include scope libtbx.phil.tst.include_scope_target_2%s
}
b = None
""" % incl_postfix, process_includes=True)
    assert not show_diff(params.as_str(attributes_level=1), """\
a = None
c {
  p = 1
  x = 1
    .help = u
  s
    .help = v
  {
    y = 2
      .help = w
  }
  q = 2
  r {
    y = 2
      .help = w
  }
  x = 3
}
b = None
""")
    extracted = params.extract()
    assert extracted.c.s.__phil_path__() == "c.s"
    try: phil.parse(input_string="""\
include scope foo foo foo
""", process_includes=True)
    except RuntimeError as e:
      assert str(e) \
        == '"include scope" must be followed one or two arguments,' \
           ' i.e. an import path and optionally a phil path (input line 1)'
    else: raise Exception_expected
    try: phil.parse(input_string="""\
include scope libtbx
""", process_includes=True)
    except ValueError as e:
      assert str(e) == 'include scope: import path "libtbx" is too short;' \
        ' target must be a phil scope object or phil string (input line 1)'
    else: raise Exception_expected
    try: phil.parse(input_string="""\
include scope libtbx.phil.t_s_t.include_scope_target_1
""", process_includes=True)
    except ImportError as e:
      assert str(e) \
        == "include scope: no module libtbx.phil.t_s_t (input line 1)" \
           " or possibly import errors in module libtbx.phil.t_s_t", \
        "Incorrect exception: %s" % str(e)
    else: raise Exception_expected
    try: phil.parse(input_string="""\
include scope libtbx.phil.tst.include_scope_target_none
""", process_includes=True)
    except AttributeError as e:
      assert str(e) == 'include scope: object' \
        ' "include_scope_target_none" not found in module "libtbx.phil.tst"' \
        ' (input line 1)'
    else: raise Exception_expected
    try: phil.parse(input_string="""\
include scope libtbx.phil.tst.include_scope_target_0n
""", process_includes=True)
    except RuntimeError as e:
      assert str(e) == 'include scope: python object' \
        ' "include_scope_target_0n" in module "libtbx.phil.tst"' \
        ' is not a libtbx.phil.scope instance (input line 1)'
    else: raise Exception_expected
    try: phil.parse(input_string="""\
include scope libtbx.phil.tst.include_scope_target_0f
""", process_includes=True)
    except RuntimeError as e:
      assert str(e) == 'include scope: python object' \
        ' "include_scope_target_0f" in module "libtbx.phil.tst"' \
        ' is not a libtbx.phil.scope instance (input line 1)'
    else: raise Exception_expected
    try: phil.parse(input_string="""\
include scope libtbx.phil.tst.include_scope_target_1 t
""", process_includes=True)
    except RuntimeError as e:
      assert str(e) == \
        'include scope: path "t" not found in phil scope object' \
        ' "include_scope_target_1" in module "libtbx.phil.tst" (input line 1)'
    else: raise Exception_expected

include_scope_target_0n = None

include_scope_target_0f = 1.0

include_scope_target_1 = phil.parse("""\
x=1
  .help=u
s
  .help=v
{
  y=2
    .help=w
}
""")

include_scope_target_2s = """\
p=1
include scope libtbx.phil.tst.include_scope_target_1
q=2
r {
  include scope libtbx.phil.tst.include_scope_target_1 s.y
}
x=3
"""

include_scope_target_2 = phil.parse(include_scope_target_2s)

def exercise_fetch():
  master = phil.parse(input_string="""\
a=None
  .expert_level=1
""")
  source = phil.parse(input_string="")
  for f in [master.fetch(source), master.fetch(sources=[]), master.fetch()]:
    assert not show_diff(f.as_str(), """\
a = None
""")
  source = phil.parse(input_string="""\
a=1
a=2
""")
  out = StringIO()
  master.fetch(source).show(out=out, attributes_level=2)
  assert not show_diff(out.getvalue(), """\
a = 2
  .expert_level = 1
""")
  source = phil.parse(input_string="""\
a=1
!a=2
""")
  out = StringIO()
  master.fetch(source).show(out=out, attributes_level=2)
  assert not show_diff(out.getvalue(), """\
a = 1
  .expert_level = 1
""")
  #
  master = phil.parse(input_string="""\
s {
  t {
    v=1
      .type=int
  }
}
s {
  u {
    a=3
      .type=int
  }
}
""")
  source = phil.parse("")
  assert not show_diff(master.fetch(source=source).as_str(), """\
s {
  t {
    v = 1
  }
}
s {
  u {
    a = 3
  }
}
""")
  source = phil.parse("s.t.v=2\ns.u.a=4")
  assert not show_diff(master.fetch(source=source).as_str(), """\
s {
  t {
    v = 2
  }
}
s {
  u {
    a = 4
  }
}
""")
  #
  master_plain = phil.parse(input_string="""\
s
  .expert_level=1
{
  a=None
    .expert_level=2
}
""")
  master_optional = phil.parse(input_string="""\
s
  .optional=yes
  .expert_level=1
{
  a=None
    .expert_level=2
}
""")
  master_multiple = phil.parse(input_string="""\
s
  .multiple=1
  .expert_level=1
{
  a=None
    .expert_level=2
}
""")
  master_optional_multiple = phil.parse(input_string="""\
s
  .multiple=1
  .optional=yes
  .expert_level=1
{
  a=None
    .expert_level=2
}
""")
  source = phil.parse(input_string="""\
s {
  a=1
  a=2
}
""")
  out = StringIO()
  master_plain.fetch(source).show(out=out, attributes_level=2)
  assert not show_diff(out.getvalue(), """\
s
  .expert_level = 1
{
  a = 2
    .expert_level = 2
}
""")
  source = phil.parse(input_string="""\
s {
  a=1
  !a=2
}
""")
  out = StringIO()
  master_plain.fetch(source).show(out=out, attributes_level=2)
  assert not show_diff(out.getvalue(), """\
s
  .expert_level = 1
{
  a = 1
    .expert_level = 2
}
""")
  source = phil.parse(input_string="""\
s {
  a=1
}
s {
  a=2
}
""")
  out = StringIO()
  master_plain.fetch(source).show(out=out, attributes_level=2)
  assert not show_diff(out.getvalue(), """\
s
  .expert_level = 1
{
  a = 2
    .expert_level = 2
}
""")
  out = StringIO()
  master_multiple.fetch(source).show(out=out)
  assert not show_diff(out.getvalue(), """\
s {
  a = 1
}
s {
  a = 2
}
""")
  source = phil.parse(input_string="""\
s {
  a=1
}
s {
  !a=2
}
""")
  for master in [master_plain, master_optional]:
    out = StringIO()
    master.fetch(source).show(out=out)
    assert not show_diff(out.getvalue(), """\
s {
  a = 1
}
""")
  for master in [master_multiple, master_optional_multiple]:
    out = StringIO()
    master.fetch(source).show(out=out)
    assert not show_diff(out.getvalue(), """\
s {
  a = 1
}
""")
  source = phil.parse(input_string="""\
!s {
  a=1
}
s {
  !a=2
}
""")
  for master in [master_plain, master_optional,
                 master_multiple, master_optional_multiple]:
    out = StringIO()
    master.fetch(source).show(out=out)
    assert not show_diff(out.getvalue(), """\
s {
  a = None
}
""")
  source = phil.parse(input_string="")
  out = StringIO()
  master_optional_multiple.fetch(source).show(out=out)
  assert not show_diff(out.getvalue(), """\
s {
  a = None
}
""")
  #
  master = phil.parse(input_string="""\
a=None
b {}
c { a=None
}
d { a {} }
""", source_info="master")
  source = phil.parse(input_string="a { }", source_info="source")
  try: master.fetch(source=source)
  except RuntimeError as e:
    assert str(e) == 'Incompatible parameter objects: definition "a" ' \
      '(master, line 1) vs. scope "a" (source, line 1)'
  else: raise Exception_expected
  master.fetch(source=source, skip_incompatible_objects=True)
  source = phil.parse(input_string="b=None")
  try: master.fetch(source=source)
  except RuntimeError as e:
    assert str(e) == 'Incompatible parameter objects: scope "b" ' \
      '(master, line 2) vs. definition "b" (input line 1)'
  else: raise Exception_expected
  master.fetch(source=source, skip_incompatible_objects=True)
  source = phil.parse(input_string="c { a { } }")
  try: master.fetch(source=source)
  except RuntimeError as e:
    assert str(e) == 'Incompatible parameter objects: definition "a" ' \
      '(master, line 3) vs. scope "a" (input line 1)'
  else: raise Exception_expected
  master.fetch(source=source, skip_incompatible_objects=True)
  source = phil.parse(input_string="d { a=None\n}")
  try: master.fetch(source=source)
  except RuntimeError as e:
    assert str(e) == 'Incompatible parameter objects: scope "a" ' \
      '(master, line 5) vs. definition "a" (input line 1)'
  else: raise Exception_expected
  master.fetch(source=source, skip_incompatible_objects=True)
  #
  master = phil.parse(input_string="""\
a=None
  .expert_level=1
b=None
  .expert_level=2
c
{
  a=None
    .expert_level=3
  b=None
    .expert_level=4
  c
    .expert_level=5
  {
    x=1
      .expert_level=6
    y=2
      .type="int"
      .expert_level=7
    t
      .expert_level=8
    {
      r=3
        .help="help"
    }
  }
}
t
  .expert_level=9
{
  a=4
    .expert_level=10
  b=5
    .expert_level=11
}

u=a *b c
  .type=choice
""")
  source = phil.parse(input_string="""\
a=7
v
{
  x=y
  y=3
}
c
{
  a=$(v.x)
  b=1
  c
  {
    y=$(v.y)
    t
    {
      r=x
    }
  }
}
t
{
  a=1
    .expert_level=-1
  b=2
}
a=9
t
{
  b=3
    .expert_level=-2
}
u=e b f *c a g
""")
  fetched = master.fetch(source=source)
  out = StringIO()
  fetched.show(out=out, attributes_level=2)
  assert not show_diff(out.getvalue(), """\
a = 9
  .expert_level = 1
b = None
  .expert_level = 2
c {
  a = y
    .expert_level = 3
  b = 1
    .expert_level = 4
  c
    .expert_level = 5
  {
    x = 1
      .expert_level = 6
    y = 3
      .type = int(allow_none=True)
      .expert_level = 7
    t
      .expert_level = 8
    {
      r = x
        .help = help
    }
  }
}
t
  .expert_level = 9
{
  a = 1
    .expert_level = 10
  b = 3
    .expert_level = 11
}
u = a b *c
  .type = choice
""")
  master = phil.parse(input_string="""\
c=a *b c
  .type=choice
""")
  for choice in ["a", "b", "c"]:
    for stat in ["", "*"]:
      source = phil.parse(input_string="c="+choice)
      out = StringIO()
      master.fetch(source=source).show(out=out)
      if (choice == "a"):
        assert out.getvalue() == "c = *a b c\n"
      elif (choice == "b"):
        assert out.getvalue() == "c = a *b c\n"
      else:
        assert out.getvalue() == "c = a b *c\n"
  source = phil.parse(input_string="""\
c=a *d c
""")
  try: fetched = master.fetch(source=source)
  except Sorry as e:
    assert not show_diff(str(e), """\
Not a possible choice for c: d (input line 1)
  Possible choices are:
    a
    *b
    c""")
  else: raise Exception_expected
  #
  master = phil.parse(input_string="""\
v
  .multiple=true
{
  x=None
}
c
  .multiple=true
{
  a=None
}
""")
  source = phil.parse(input_string="""\
v {
  x=y
}
c {
  a=$(v.x)
}
v {
  x=z
}
c {
  a=$(v.x)
}
""")
  out = StringIO()
  master.fetch(source=source).show(out=out)
  assert not show_diff(out.getvalue(), """\
v {
  x = y
}
v {
  x = z
}
c {
  a = y
}
c {
  a = z
}
""")
  parameters = phil.parse(input_string="""\
c {
  a=$(v.x)
}
v {
  x=y
}
""")
  try: parameters.fetch(source=parameters)
  except RuntimeError as e:
    assert str(e) == 'Undefined variable: $v.x (input line 2)'
  else: raise Exception_expected
  #
  master = phil.parse(input_string="""\
s {
  a=None
}
""")
  source = phil.parse(input_string="s.a=x")
  out = StringIO()
  master.fetch(source=source).show(out=out)
  assert not show_diff(out.getvalue(), """\
s {
  a = x
}
""")
  master = phil.parse(input_string="""\
s {
  t {
    a=None
  }
}
""")
  source = phil.parse(input_string="s.t.a=x")
  out = StringIO()
  master.fetch(source=source).show(out=out)
  assert not show_diff(out.getvalue(), """\
s {
  t {
    a = x
  }
}
""")
  master = phil.parse(input_string="""\
s.t {
  a=None
}
""")
  source = phil.parse(input_string="s.t.a=x")
  out = StringIO()
  master.fetch(source=source).show(out=out)
  assert not show_diff(out.getvalue(), """\
s.t {
  a = x
}
""")
  master = phil.parse(input_string="""\
s.t {
  a.b=None
}
""")
  source = phil.parse(input_string="s.t.a.b=x")
  out = StringIO()
  master.fetch(source=source).show(out=out)
  assert not show_diff(out.getvalue(), """\
s.t {
  a.b = x
}
""")
  master = phil.parse(input_string="""\
s.t.u {
  a.b.c=None
}
""")
  source = phil.parse(input_string="""\
v.w {
  p.q=z
}
s.t.u.a.b.c=$(v.w.p.q)
""")
  out = StringIO()
  master.fetch(source=source).show(out=out)
  assert not show_diff(out.getvalue(), """\
s.t.u {
  a.b.c = z
}
""")
  for input_string in ["s{t.u.a.b.c=x\n}",
                       "s.t{u.a.b.c=x\n}",
                       "s.t.u{a.b.c=x\n}",
                       "s.t.u.a{b.c=x\n}",
                       "s.t.u.a.b{c=x\n}",
                       "s{t{u.a.b.c=x\n}}",
                       "s{t.u{a.b.c=x\n}}",
                       "s{t.u.a{b.c=x\n}}"]:
    source = phil.parse(input_string=input_string)
    out = StringIO()
    master.fetch(source=source).show(out=out)
    assert not show_diff(out.getvalue(), """\
s.t.u {
  a.b.c = x
}
""")
  #
  master = phil.parse(input_string="""\
s.t
  .multiple=true
{
  a.b=None
}
""")
  source = phil.parse(input_string="""\
s.t.a.b=x
s.t.a.b=y
s{t.a.b=z
  t.a.b=q
}
s.t{a.b=r
    a.b=w
}
s.t.a{b=e
      b=f
}
s.t.a{b=e
      !b=f
}
""")
  out = StringIO()
  master.fetch(source=source).show(out=out)
  assert not show_diff(out.getvalue(), """\
s.t {
  a.b = x
}
s.t {
  a.b = y
}
s.t {
  a.b = z
}
s.t {
  a.b = q
}
s.t {
  a.b = w
}
s.t {
  a.b = f
}
s.t {
  a.b = e
}
""")
  master = phil.parse(input_string="""\
s {
  a {
    f=None
  }
  b {
    f=None
    g=None
  }
}
""")
  source_af = phil.parse(input_string="s.a.f=1")
  source_bf = phil.parse(input_string="s.b.f=2")
  source_bg = phil.parse(input_string="s.b.g=3")
  assert not show_diff(master.fetch(sources=[source_af, source_bf]).as_str(),
    """\
s {
  a {
    f = 1
  }
  b {
    f = 2
    g = None
  }
}
""")
  assert not show_diff(master.fetch(sources=[source_bg, source_af]).as_str(),
    """\
s {
  a {
    f = 1
  }
  b {
    f = None
    g = 3
  }
}
""")
  assert master.fetch(sources=[source_bg, source_af, source_bf]).as_str()=="""\
s {
  a {
    f = 1
  }
  b {
    f = 2
    g = 3
  }
}
"""
  #
  master = phil.parse("""\
s
  .multiple=True
{
  a=None
    .multiple=True
  b=None
    .multiple=False
}
""")
  custom = phil.parse("""\
s {
  a = 1
  a = 2
  b = 3
  b = 4
}
s {
  a = 2
  a = 3
  b = 4
  b = 5
}
s {
  a = 1
  a = 2
  b = 4
}
""")
  assert not show_diff(master.fetch(sources=[custom, custom]).as_str(), """\
s {
  a = 2
  a = 3
  b = 5
}
s {
  a = 1
  a = 2
  b = 4
}
""")
  #
  master = phil.parse("""\
a=None
  .multiple=True
b=None
  .multiple=False
""")
  custom = phil.parse("""\
a=1
a=2
b=3
b=4
""")
  fetched = master.fetch(sources=[custom, custom])
  assert not show_diff(fetched.as_str(), """\
a = 1
a = 2
b = 4
""")
  master = phil.parse("""\
s
{
  l
    .multiple=False
  {
    a=None
      .multiple=True
    b=None
      .multiple=False
  }
}
""")
  custom = phil.parse("""\
s {
  l {
    a = 1
    a = 2
    b = 3
    b = 4
  }
}
""")
  fetched = master.fetch(sources=[custom, custom])
  assert not show_diff(fetched.as_str(), """\
s {
  l {
    a = 1
    a = 2
    b = 4
  }
}
""")
  #
  master = phil.parse("""\
a=None
  .type=str
  .multiple=True
""")
  custom = phil.parse("""\
a=x
a="x"
""")
  assert not show_diff(master.fetch(source=custom).as_str(), """\
a = "x"
""")
  custom = phil.parse("""\
a="x"
a=x
""")
  assert not show_diff(master.fetch(source=custom).as_str(), """\
a = x
""")
  custom = phil.parse("""\
a="x "
a=x
""")
  assert not show_diff(master.fetch(source=custom).as_str(), """\
a = "x "
a = x
""")
  #
  master = phil.parse("""\
a=None
  .type=str
  .multiple=True
a=x
a=y
""")
  custom = phil.parse("""\
a=z
""")
  assert not show_diff(master.fetch(source=custom).as_str(), """\
a = x
a = y
a = z
""")
  custom = phil.parse("""\
a=y
a=y
a=z
a=x
""")
  assert not show_diff(master.fetch(source=custom).as_str(), """\
a = y
a = z
a = x
""")
  master = phil.parse("""\
a=None
  .type=str
  .multiple=True
a=d
a=x
a=y
""")
  custom = phil.parse("""\
a=z
""")
  assert not show_diff(master.fetch(source=custom).as_str(), """\
a = d
a = x
a = y
a = z
""")
  assert not show_diff(master.fetch(sources=[custom, master]).as_str(), """\
a = z
a = d
a = x
a = y
""")
  master = phil.parse("""\
a
  .multiple=True
{
  x=None
  y=None
}
a {
  x=1
}
a {
  y=2
}
""")
  custom = phil.parse("")
  assert not show_diff(master.fetch(sources=[custom]*3).as_str(), """\
a {
  x = 1
  y = None
}
a {
  x = None
  y = 2
}
""")
  custom = phil.parse("a.x=3\na.y=4")
  assert not show_diff(master.fetch(sources=[custom]*3).as_str(), """\
a {
  x = 1
  y = None
}
a {
  x = None
  y = 2
}
a {
  x = 3
  y = None
}
a {
  x = None
  y = 4
}
""")
  custom = phil.parse("a {\nx=3\ny=4\n}")
  assert not show_diff(master.fetch(sources=[custom]*3).as_str(), """\
a {
  x = 1
  y = None
}
a {
  x = None
  y = 2
}
a {
  x = 3
  y = 4
}
""")
  assert not show_diff(master.fetch(
    sources=[custom, master, master, custom]).as_str(), """\
a {
  x = 1
  y = None
}
a {
  x = None
  y = 2
}
a {
  x = 3
  y = 4
}
""")
  assert not show_diff(master.fetch(
    sources=[custom, master, master, custom, master]).as_str(), """\
a {
  x = 3
  y = 4
}
a {
  x = 1
  y = None
}
a {
  x = None
  y = 2
}
""")
  #
  master = phil.parse(input_string="""\
s {
  t
    .multiple=true
  {
    a=None
    b=None
  }
}
""")
  source = phil.parse(input_string="""\
s.t.a=x
s.t.b=y
""")
  assert not show_diff(master.fetch(source=source).as_str(), """\
s {
  t {
    a = x
    b = None
  }
  t {
    a = None
    b = y
  }
}
""")
  master = phil.parse(input_string="""\
s.t
  .multiple=true
{
  a=None
  b=None
}
""")
  source = phil.parse(input_string="""\
s.t.a=x
s.t.b=y
""")
  assert not show_diff(master.fetch(source=source).as_str(), """\
s.t {
  a = x
  b = None
}
s.t {
  a = None
  b = y
}
""")
  master = phil.parse(input_string="""\
s
  .multiple=True
{
  t.u
    .multiple=True
  {
    a = None
  }
}
""")
  for input_string in ["", "s {}", "s { t { } }", "s.t { u { a = None } }"]:
    source = phil.parse(input_string=input_string)
    assert not show_diff(master.fetch(source=source).as_str(), """\
s {
  t.u {
    a = None
  }
}
""")
  for input_string in ["""\
s.t { u { a = 3 } }
""", """\
s.t { u { a = 3 } }
s.t { u { a = None } }
""", """\
s.t { u { a = None } }
s.t { u { a = 3 } }
s.t { u { a = None } }
"""]:
    source = phil.parse(input_string=input_string)
    assert not show_diff(master.fetch(source=source).as_str(), """\
s {
  t.u {
    a = 3
  }
}
""")
  master = phil.parse(input_string="""\
s {
  p = None
  q = None
  t
    .multiple=True
  {
    a = None
    b = None
    c.x
      .multiple=True
    {
      f = None
    }
  }
}
q
  .multiple=True
{
  r
    .multiple=True
  {
    s = None
      .multiple=True
    p = None
  }
}
""")
  source = phil.parse(input_string="""\
s.q = 1
s.p = 2
s.t.c { x { f = 3 } }
q.r.s = 4
s.t.a = 5
q.r.s = 6
s.t.b = 7
s.p = 8
s.t {
  a = 9
  b = 10
  c.x.f = 11
  c.x.f = 12
}
q { r { s=13; s=14; p=15; s=16; p=17 } r.s = 18; r.s = 19 }
s.t.a = 20
q.r.s = 21
""")
  assert not show_diff(master.fetch(source=source).as_str(), """\
s {
  p = 8
  q = 1
  t {
    a = None
    b = None
    c.x {
      f = 3
    }
  }
  t {
    a = 5
    b = None
    c.x {
      f = None
    }
  }
  t {
    a = None
    b = 7
    c.x {
      f = None
    }
  }
  t {
    a = 9
    b = 10
    c.x {
      f = 11
    }
    c.x {
      f = 12
    }
  }
  t {
    a = 20
    b = None
    c.x {
      f = None
    }
  }
}
q {
  r {
    s = 4
    p = None
  }
}
q {
  r {
    s = 6
    p = None
  }
}
q {
  r {
    s = 13
    s = 14
    s = 16
    p = 17
  }
  r {
    s = 18
    p = None
  }
  r {
    s = 19
    p = None
  }
}
q {
  r {
    s = 21
    p = None
  }
}
""")
  #
  master = phil.parse("""\
s
{
  a=None
    .multiple=True
    .optional=True
}
""")
  prev = phil.parse(master.as_str())
  custom = phil.parse("""\
s {
  a=x
}
""")
  eff_phil = master.fetch(sources=[prev, custom])
  assert not show_diff(eff_phil.as_str(), """\
s {
  a = x
}
""")
  assert master.extract().s.a == []
  assert custom.extract().s.a == ["x"]
  eff = eff_phil.extract()
  assert eff.s.a == [["x"]]
  assert not show_diff(master.format(eff).as_str(), """\
s {
  a = x
}
""")
  dft = master.clone(eff)
  assert not show_diff(master.format(dft).as_str(), """\
s {
  a = x
}
""")
  #
  master = phil.parse(input_string="""\
a = None
""")
  source = phil.parse(input_string="""\
a = 1
a = 2
""")
  working, unused = master.fetch(source=source, track_unused_definitions=True)
  assert not show_diff(working.as_str(), """\
a = 2
""")
  assert len(unused) == 0
  master = phil.parse(input_string="""\
a = 1
s {
  b = None
    .multiple = True
  b = 2
  t
    .multiple = True
  {
    c = None
    x = None
  }
}
""")
  custom = phil.parse(input_string="""\
a = 10
s.b = 20
c = 30
d = 40
s {
  t {
    c = 300
    x = 0
  }
  t.c = $c
  e = 5
}
s.t.y = 1
""")
  working, unused = master.fetch(source=custom, track_unused_definitions=True)
  assert not show_diff(working.as_str(), """\
a = 10
s {
  b = 2
  b = 20
  t {
    c = 300
    x = 0
  }
  t {
    c = 30
    x = None
  }
}
""")
  assert not show_diff(
    "\n".join([str(obj_loc) for obj_loc in unused]), """\
d (input line 4)
s.e (input line 11)
s.t.y (input line 13)""")
  #
  master = phil.parse(input_string="""\
a = *x y
  .optional = True
  .type = choice
b = *p *q
  .optional = True
  .type = choice(multi=True)
""")
  custom = phil.parse(input_string="""\
a = none
b = NoNe
""")
  working = master.fetch(source=custom)
  assert not show_diff(working.as_str(), """\
a = x y
b = p q
""")
  #
  master = phil.parse(input_string="""\
a = None
a = None
""")
  try: master.fetch()
  except RuntimeError as e:
    assert not show_diff(str(e), """\
Duplicate definitions in master (first not marked with .multiple=True):
  a (input line 1)
  a (input line 2)""")
  else: raise Exception_expected

def exercise_fetch_diff():
  source = phil.parse(input_string="""\
a = "a" "b"
""")
  master = phil.parse(input_string="""\
a = "a b"
  .type = str
""")
  assert master.objects[0].fetch_diff(source=source.objects[0]) is None
  master = phil.parse(input_string="""\
a = None
  .type = str
""")
  assert not show_diff(
    master.objects[0].fetch(source=source.objects[0], diff=True).as_str(),
    """\
a = "a" "b"
""")
  #
  master = phil.parse(input_string="""\
v = 33/111
  .type = float
""")
  f = master.fetch()
  assert not show_diff(f.objects[0].as_str(), """\
v = 33/111
""")
  assert master.objects[0].fetch_diff(source=f.objects[0]) is None
  f = master.format(master.extract(master.fetch()))
  assert not show_diff(f.objects[0].as_str(), """\
v = 0.2972972973
""")
  assert master.objects[0].fetch_diff(source=f.objects[0]) is None
  source = phil.parse(input_string="""\
v = 0.2972972972
""")
  assert not show_diff(
    master.objects[0].fetch_diff(source=source.objects[0]).as_str(),
    """\
v = 0.2972972972
""")
  #
  master = phil.parse(input_string="""\
s {
  a = None
}
""")
  source = phil.parse(input_string="s.a = x")
  d = master.fetch(source=source, diff=True)
  assert not show_diff(d.as_str(), """\
s {
  a = x
}
""")
  for input_string in ["", "s.a = None"]:
    source = phil.parse(input_string=input_string)
    d = master.fetch_diff(source=source)
    assert d.is_empty()
  #
  master = phil.parse(input_string="""\
s {
  a = None
  b = y
}
""")
  source = phil.parse(input_string="s.a = x")
  d = master.fetch_diff(source=source)
  assert not show_diff(d.as_str(), """\
s {
  a = x
}
""")
  source = phil.parse(input_string="s.b = z")
  d = master.fetch_diff(source=source)
  assert not show_diff(d.as_str(), """\
s {
  b = z
}
""")
  source = phil.parse(input_string="s.a = x; s.b = z")
  d = master.fetch_diff(source=source)
  assert not show_diff(d.as_str(), """\
s {
  a = x
  b = z
}
""")
  for input_string in ["", "s.a = None", "s.b = y"]:
    source = phil.parse(input_string=input_string)
    d = master.fetch_diff(source=source)
    assert d.is_empty()
  #
  master = phil.parse(input_string="""\
s {
  a = None
  t {
    b = y
  }
}
""")
  source = phil.parse(input_string="s.a = x")
  d = master.fetch_diff(source=source)
  assert not show_diff(d.as_str(), """\
s {
  a = x
}
""")
  source = phil.parse(input_string="s.t.b = z")
  d = master.fetch_diff(source=source)
  assert not show_diff(d.as_str(), """\
s {
  t {
    b = z
  }
}
""")
  source = phil.parse(input_string="s.a = x; s.t.b = z")
  d = master.fetch_diff(source=source)
  assert not show_diff(d.as_str(), """\
s {
  a = x
  t {
    b = z
  }
}
""")
  for input_string in ["", "s.a = None", "s.t.b = y"]:
    source = phil.parse(input_string=input_string)
    d = master.fetch_diff(source=source)
    assert d.is_empty()
  #
  master = phil.parse(input_string="""\
s {
  a = None
  t.u {
    b = y
  }
}
""")
  source = phil.parse(input_string="s.a = x")
  d = master.fetch_diff(source=source)
  assert not show_diff(d.as_str(), """\
s {
  a = x
}
""")
  source = phil.parse(input_string="s.t.u.b = z")
  d = master.fetch_diff(source=source)
  assert not show_diff(d.as_str(), """\
s {
  t.u {
    b = z
  }
}
""")
  source = phil.parse(input_string="s.a = x; s.t.u.b = z")
  d = master.fetch_diff(source=source)
  assert not show_diff(d.as_str(), """\
s {
  a = x
  t.u {
    b = z
  }
}
""")
  for input_string in ["", "s.a = None", "s.t.u.b = y"]:
    source = phil.parse(input_string=input_string)
    d = master.fetch_diff(source=source)
    assert d.is_empty()
  #
  master = phil.parse(input_string="""\
a = None
  .type = str
  .multiple = True
""")
  source = phil.parse(input_string="a = x")
  d = master.fetch_diff(source=source)
  assert not show_diff(d.as_str(), """\
a = x
""")
  source = phil.parse(input_string="a = x; a = None; a = y")
  d = master.fetch_diff(source=source)
  assert not show_diff(d.as_str(), """\
a = x
a = y
""")
  for input_string in ["", "a = None"]:
    source = phil.parse(input_string=input_string)
    d = master.fetch_diff(source=source)
    assert d.is_empty()
  #
  master = phil.parse(input_string="""\
s
  .multiple = True
{
  a = None
}
""")
  source = phil.parse(input_string="s.a = x")
  d = master.fetch_diff(source=source)
  assert not show_diff(d.as_str(), """\
s {
  a = x
}
""")
  for input_string in ["", "s.a = None"]:
    source = phil.parse(input_string=input_string)
    d = master.fetch_diff(source=source)
    assert d.is_empty()
  #
  master = phil.parse(input_string="""\
s
  .multiple = True
{
  a = None
  b = y
}
""")
  source = phil.parse(input_string="s.a = x")
  d = master.fetch_diff(source=source)
  assert not show_diff(d.as_str(), """\
s {
  a = x
}
""")
  source = phil.parse(input_string="s.b = z")
  d = master.fetch_diff(source=source)
  assert not show_diff(d.as_str(), """\
s {
  b = z
}
""")
  source = phil.parse(input_string="s.a = x; s.b = z")
  d = master.fetch_diff(source=source)
  assert not show_diff(d.as_str(), """\
s {
  a = x
}
s {
  b = z
}
""")
  for input_string in ["", "s.a = None", "s.b = y"]:
    source = phil.parse(input_string=input_string)
    d = master.fetch_diff(source=source)
    assert d.is_empty()
  #
  master = phil.parse(input_string="""\
s
  .multiple = True
{
  a = None
    .type = str
    .multiple = True
  b = y
}
""")
  source = phil.parse(input_string="s.a = x")
  d = master.fetch_diff(source=source)
  assert not show_diff(d.as_str(), """\
s {
  a = x
}
""")
  source = phil.parse(input_string="s.a = x; s { a = None; b = z } s.a = p")
  d = master.fetch_diff(source=source)
  assert not show_diff(d.as_str(), """\
s {
  a = x
}
s {
  b = z
}
s {
  a = p
}
""")
  for input_string in ["", "s.a = None", "s.b = y", "s { a = None; b = y }"]:
    source = phil.parse(input_string=input_string)
    d = master.fetch_diff(source=source)
    assert d.is_empty()
  #
  master = phil.parse(input_string="""\
s
  .multiple = True
{
  t
    .multiple = True
  {
    a = x
  }
  b = None
}
""")
  source = phil.parse(input_string="s.t.a = None")
  d = master.fetch_diff(source=source)
  assert not show_diff(d.as_str(), """\
s {
  t {
    a = None
  }
}
""")
  source = phil.parse(input_string="""\
s.t.a = y
s { t.a = x; b = z }
s.t.a = p
s { t.a = None; b = None }
s { t.a = r; b = q }
""")
  d = master.fetch_diff(source=source)
  assert not show_diff(d.as_str(), """\
s {
  t {
    a = y
  }
}
s {
  b = z
}
s {
  t {
    a = p
  }
}
s {
  t {
    a = None
  }
}
s {
  t {
    a = r
  }
  b = q
}
""")
  for input_string in [
        "", "s.t.a = x", "s.b = None", "s { t.a = x; b = None }"]:
    source = phil.parse(input_string=input_string)
    d = master.fetch_diff(source=source)
    assert d.is_empty()
  #
  master = phil.parse(input_string="""\
s
  .multiple = True
{
  d = None
  t.u
    .multiple = True
  {
    a = x
      .multiple = True
    b = None
    c = v *w
      .type=choice
  }
  e = None
    .multiple = True
  r {
    i = 0
      .multiple = True
    j = 1
  }
}
""")
  source = phil.parse(input_string="")
  d = master.fetch_diff(source=source)
  assert d.is_empty()
  source = phil.parse(input_string="""\
s.t.u.c=v
s {
  t.u {
    a = z
    b = y
    a = x
    c = w
    a = p
  }
  r.i = 0
  t.u {
    a = x
    b = None
    c = w
  }
  r {
    i = 1
    j = 1
  }
}
s {
  d = 2
  e = 1
  t.u {
    c = v
  }
  d = 3
  e = None
  r {
    i = 1
    j = 2
  }
  d = 4
  e = 5
}
""")
  d = master.fetch_diff(source=source)
  assert not show_diff(d.as_str(), """\
s {
  t.u {
    c = *v w
  }
}
s {
  t.u {
    a = z
    a = p
    b = y
  }
  r {
    i = 1
  }
}
s {
  d = 4
  t.u {
    c = *v w
  }
  e = 1
  e = 5
  r {
    i = 1
    j = 2
  }
}
""")
  #
  master = phil.parse(input_string="""\
a = None
  .type = str
""")
  os.environ["_X_Y_Z_"] = "xyz"
  source = phil.parse(input_string="a = $_X_Y_Z_")
  f = master.fetch(source=source)
  assert not show_diff(f.as_str(), """\
a = "xyz"
""")
  d = master.fetch_diff(source=source)
  assert not show_diff(d.as_str(), """\
a = "$_X_Y_Z_"
""")
  #
  master = phil.parse(input_string="""\
s {
  p = None
    .multiple = True
  p = q1
  p = q2
  t {
    u
      .multiple = True
    {
      a = None
      b = None
        .multiple = True
      b = c1
      b = c2
    }
    u {
      a = x1
      b = y1
    }
    u {
      a = x2
      b = y2
    }
  }
}
""")
  d = master.fetch_diff()
  assert d.is_empty()
  source = phil.parse(input_string="s.t.u.b=c2")
  d = master.fetch_diff(source=source)
  assert d.is_empty()
  source = phil.parse(input_string="s.t.u { b=c3; b=c4; b=c3 }")
  d = master.fetch_diff(source=source)
  assert not show_diff(d.as_str(), """\
s {
  t {
    u {
      b = c4
      b = c3
    }
  }
}
""")

def exercise_extract():
  parameters = phil.parse(input_string="""\
group {
  a=yes
    .type=bool
  a=yes "n o"
  b=13
    .type=int
  c=1.3
    .type=float
  d=abc def ghi
    .type=str
  e=a *b c
    .type=choice
  e=a *b *c
    .type=choice
  e=a b c
    .type=choice
    .optional=no
  f=a *b c
    .type=choice(multi = True)
  f=a *b *c
    .type=choice(multi = True)
  f=a b c
    .type=choice(multi =True)
  f=a b c
    .type=choice(multi =True)
    .optional=0
  g="/var/tmp/foo"
    .type=path
  h="var.tmp.foo"
    .type=key
  i=ceil(4/3)
    .type=int
  i=1/2
    .type=int
  j=1/(5-3)
    .type=float
  j="'a'"
    .type=float
  j=a
    .type=float
  n=none
    .type=None
  m=Plain "%^ &*"
    .type=None
  s0=none
    .type=strings
  s1=" a " b
    .type=strings
  v=none
    .type=words
  w=plain "% ^&*"
    .type=words
  int_true = True
    .type=int
  int_false = False
    .type=int
  float_true = True
    .type=float
  float_false = False
    .type=float
}
""")
  assert parameters.get(path="group.a",
    with_substitution=False).objects[0].extract() is True
  assert parameters.get(path="group.a",
    with_substitution=False).objects[1].extract() == ["yes", "n o"]
  assert parameters.get(path="group.b",
    with_substitution=False).objects[0].extract() == 13
  assert parameters.get(path="group.c",
    with_substitution=False).objects[0].extract() == 1.3
  assert parameters.get(path="group.d",
    with_substitution=False).objects[0].extract() == "abc def ghi"
  assert parameters.get(path="group.e",
    with_substitution=False).objects[0].extract() == "b"
  try: parameters.get(path="group.e",
    with_substitution=False).objects[1].extract()
  except RuntimeError as e:
    assert str(e) == 'Multiple choices for group.e;' \
      ' only one choice can be selected (input line 13)'
  else: raise Exception_expected
  try: parameters.get(path="group.e",
    with_substitution=False).objects[2].extract()
  except RuntimeError as e:
    assert str(e) == 'Unspecified choice for group.e:' \
      ' exactly one choice must be selected (input line 15)'
  else: raise Exception_expected
  try: parameters.get(path="group.f",
    with_substitution=False).objects[3].extract()
  except RuntimeError as e:
    assert str(e) == 'Unspecified choice for group.f:' \
      ' at least one choice must be selected (input line 24)'
  else: raise Exception_expected
  assert parameters.get(path="group.e").objects[0].type \
      is parameters.get(path="group.e").objects[1].type
  assert parameters.get(path="group.e").objects[0].type \
      is parameters.get(path="group.e").objects[2].type
  assert parameters.get(path="group.f",
    with_substitution=False).objects[0].extract() == ["b"]
  assert parameters.get(path="group.f",
    with_substitution=False).objects[1].extract() == ["b", "c"]
  assert parameters.get(path="group.f",
    with_substitution=False).objects[2].extract() == []
  assert parameters.get(path="group.f").objects[0].type \
      is parameters.get(path="group.f").objects[1].type
  assert parameters.get(path="group.f").objects[0].type \
      is parameters.get(path="group.f").objects[2].type
  assert parameters.get(path="group.g",
    with_substitution=False).objects[0].extract() == "/var/tmp/foo"
  assert parameters.get(path="group.h",
    with_substitution=False).objects[0].extract() == "var.tmp.foo"
  assert parameters.get(path="group.i",
    with_substitution=False).objects[0].extract() == 2
  try: parameters.get(path="group.i",
    with_substitution=False).objects[1].extract()
  except RuntimeError as e:
    assert str(e) == 'Error interpreting group.i="1/2" as' \
      ' an integer expression (input line 33)'
  else: raise Exception_expected
  assert parameters.get(path="group.j",
    with_substitution=False).objects[0].extract() == 0.5
  try: parameters.get(path="group.j",
    with_substitution=False).objects[1].extract()
  except RuntimeError as e:
    assert str(e) == """Error interpreting group.j="'a'" as""" \
      " a floating-point expression (input line 37)"
  else: raise Exception_expected
  try: parameters.get(path="group.j",
    with_substitution=False).objects[2].extract()
  except RuntimeError as e:
    assert str(e) == 'Error interpreting group.j="a" as a numeric expression:'\
                   + " NameError: name 'a' is not defined (input line 39)"
  else: raise Exception_expected
  assert parameters.get(path="group.n",
    with_substitution=False).objects[0].extract() is None
  assert parameters.get(path="group.m",
    with_substitution=False).objects[0].extract() == ["Plain", "%^ &*"]
  assert parameters.get(path="group.s0",
    with_substitution=False).objects[0].extract() is None
  assert parameters.get(path="group.s1",
    with_substitution=False).objects[0].extract() == [" a ", "b"]
  assert parameters.get(path="group.v",
    with_substitution=False).objects[0].extract() is None
  assert [word.value for word in parameters.get(path="group.w",
    with_substitution=False).objects[0].extract()] == ["plain", "% ^&*"]
  definition = parameters.get(path="group.a",
    with_substitution=False).objects[0]
  try: parameters.get(path="group.int_true",
    with_substitution=False).objects[0].extract()
  except RuntimeError as e:
    assert not show_diff(str(e),
      'Error interpreting group.int_true="True" as a numeric expression'
      ' (input line 53)')
  else: raise Exception_expected
  try: parameters.get(path="group.int_false",
    with_substitution=False).objects[0].extract()
  except RuntimeError as e:
    assert not show_diff(str(e),
      'Error interpreting group.int_false="False" as a numeric expression'
      ' (input line 55)')
  else: raise Exception_expected
  try: parameters.get(path="group.float_true",
    with_substitution=False).objects[0].extract()
  except RuntimeError as e:
    assert not show_diff(str(e),
      'Error interpreting group.float_true="True" as a numeric expression'
      ' (input line 57)')
  else: raise Exception_expected
  try: parameters.get(path="group.float_false",
    with_substitution=False).objects[0].extract()
  except RuntimeError as e:
    assert not show_diff(str(e),
      'Error interpreting group.float_false="False" as a numeric expression'
      ' (input line 59)')
  else: raise Exception_expected
  parameters = phil.parse(input_string="""\
group {
  a=yes
    .type=bool
  b=13
    .type=int
}
""")
  group = parameters.get(path="group",
    with_substitution=False).objects[0].extract()
  assert group.a is True
  assert group.b == 13
  #
  parameters = phil.parse(input_string="""\
c.d=5
  .type=int
c.e=6
  .type=int
c {
  f=7
    .type=int
}
""")
  extracted = parameters.extract()
  assert extracted.c.d == 5
  assert extracted.c.e == 6
  assert extracted.c.f == 7
  parameters = phil.parse(input_string="""\
c.d=5
  .type=int
c.e=6
  .type=int
c {
  d=7
    .type=int
  f=8
    .type=int
}
""")
  extracted = parameters.extract()
  assert extracted.c.d == 7
  assert extracted.c.e == 6
  assert extracted.c.f == 8
  #
  parameters = phil.parse(input_string="""\
a=1
  .type=int
b {
  a=2
    .type=int
  b {
    a=3
      .type=int
  }
}
c.a {
  b=4
    .type=int
  c.d=5
    .type=int
  c.e=6
    .type=int
}
""")
  extracted = parameters.extract()
  assert extracted.a == 1
  assert extracted.b.a == 2
  assert extracted.b.b.a == 3
  assert extracted.c.a.b == 4
  assert extracted.c.a.c.d == 5
  assert extracted.c.a.c.e == 6
  #
  parameters = phil.parse(input_string="""\
a=1
 .type=int
a=2
 .type=int
b {
  a=3
    .type=int
  a=4
    .type=int
}
b {
  b=5
    .type=int
  b=6
    .type=int
}
""")
  extracted = parameters.extract()
  assert extracted.a == 2
  assert extracted.b.b == 6
  #
  parameters = phil.parse(input_string="""\
s {
  a=None
   .optional=True
   .type=int
   .multiple=True
}
""")
  extracted = parameters.extract()
  assert extracted.s.a == []
  #
  parameters = phil.parse(input_string="""\
s {
  t {
    u {
    }
  }
}
t {
  b.c=None
  c.d.e=f
    .type = str
}
""")
  extracted = parameters.extract()
  assert extracted.__phil_path__() == ""
  assert extracted.__phil_path__(object_name="o1") == "o1"
  assert extracted.s.__phil_path__() == "s"
  assert extracted.s.__phil_path__(object_name="o2") == "s.o2"
  assert extracted.s.t.__phil_path__() == "s.t"
  assert extracted.s.t.__phil_path__(object_name="o3") == "s.t.o3"
  assert extracted.s.t.u.__phil_path__() == "s.t.u"
  assert extracted.t.__phil_path__() == "t"
  assert extracted.t.__phil_path__(object_name="o4") == "t.o4"
  assert extracted.t.b.__phil_path__() == "t.b"
  assert extracted.t.c.__phil_path__() == "t.c"
  assert extracted.t.c.d.__phil_path__() == "t.c.d"
  assert extracted.t.c.d.__phil_path_and_value__(object_name="e") == (
    "t.c.d.e", "f")
  #
  try: extracted.z = 12
  except AttributeError as e:
    assert not show_diff(str(e), """Assignment to non-existing attribute "z"
  Please correct the attribute name, or to create
  a new attribute use: obj.__inject__(name, value)""")
  else: raise Exception_expected
  try: extracted.t.c.z = 13
  except AttributeError as e:
    assert not show_diff(str(e),"""Assignment to non-existing attribute "t.c.z"
  Please correct the attribute name, or to create
  a new attribute use: obj.__inject__(name, value)""")
  else: raise Exception_expected
  extracted.__inject__("z", 14)
  assert extracted.z == 14
  del extracted.z
  extracted.__inject__("z", 15)
  assert extracted.z == 15
  try: extracted.__inject__("z", 16)
  except AttributeError as e:
    assert str(e) == 'Attribute "z" exists already.'
  else: raise Exception_expected
  extracted.t.c.__inject__("z", 17)
  assert extracted.t.c.z == 17
  del extracted.t.c.z
  extracted.t.c.__inject__("z", 18)
  assert extracted.t.c.z == 18
  try: extracted.t.c.__inject__("z", 19)
  except AttributeError as e:
    assert str(e) == 'Attribute "t.c.z" exists already.'
  else: raise Exception_expected
  #
  parameters = phil.parse(input_string="""\
s.t.x {
  a=13
    .type=int
}
s.t.y {
  b=45
    .type=int
}
""")
  extracted = parameters.extract()
  assert extracted.s.t.x.a == 13
  assert extracted.s.t.y.b == 45
  parameters = phil.parse(input_string="""\
s.t.x {
  a=13
    .type=int
    .multiple=True
}
s.t.x {
  a=None
    .type=int
    .multiple=True
}
s.t.x {
  a=45
    .type=int
    .multiple=True
}
""")
  extracted = parameters.extract()
  assert extracted.s.t.x.a == [13, 45]
  parameters = phil.parse(input_string="""\
s.t.x {
  a=None
    .type=int
    .multiple=True
}
s.t.x {
  a=45
    .type=int
    .multiple=True
}
s.t.x {
  a=13
    .type=int
    .multiple=True
}
""")
  extracted = parameters.extract()
  assert extracted.s.t.x.a == [45, 13]
  #
  parameters = phil.parse(input_string="""\
s.t {
}
s.u
  .multiple=True
  .optional=True
{
}
""")
  for object in parameters.get(path="s").objects:
    assert object.optional is None
    assert object.multiple is None
  for object in parameters.get(path="s.u").objects:
    assert object.optional
    assert object.multiple
  extracted = parameters.extract()
  assert len(extracted.s.u) == 1
  #
  parameters = phil.parse(input_string="""\
a=008 # eval fails since this is an invalid octal literal
  .type=int
b=008.34 # just to be sure (eval works for this)
  .type=float
""")
  extracted = parameters.extract()
  assert extracted.a == 8
  assert extracted.b == 8.34
  #
  master = phil.parse(input_string="""\
a=None
  .type=qstr
b=Auto
  .type=qstr
c= 1  2
  .type=qstr
ds="1"'2'
  .type=str
dq="1"'2'
  .type=qstr
es="1\\""'2\\"\\''
  .type=str
eq="1\\""'2\\"\\''
  .type=qstr
""")
  work = master
  for i_cycle in range(2):
    ex = work.extract()
    assert ex.a is None
    assert ex.b is Auto
    assert ex.c == "1 2"
    assert ex.ds == "1 2"
    assert ex.dq == """ "1" '2' """[1:-1]
    assert ex.es == """ 1" 2\\"' """[1:-1]
    assert ex.eq == """ "1\\"" '2\\\\"\\'' """[1:-1]
    work = master.format(ex)
    assert not show_diff(work.as_str(), """\
a = None
b = Auto
c = 1 2
ds = "1 2"
dq = "1" '2'
es = "1\\" 2\\\\\\"'"
eq = "1\\"" '2\\\\"\\''
""")

def exercise_format():
  parameters = phil.parse(input_string="""\
group {
  n=ab "c d" 'ef '
    .type=None
  a=yes
    .type=bool
  b=13
    .type=int
  c=1.3
    .type=float
  d=abc def ghi
    .type=str
  e=a *b c
    .type=choice
  f=a *b *c
    .type=choice(multi=True)
  g="/var/tmp/foo"
    .type=path
  h="var.tmp.foo"
    .type=key
  m=plain "% ^&*"
    .type=None
  s0=none
    .type=strings
  s1=' a ' b
    .type=strings
  w=plain "% ^&*"
    .type=words
}
""")
  out = StringIO()
  extracted = parameters.fetch(source=parameters).extract()
  parameters.format(extracted).show(out=out)
  assert not show_diff(out.getvalue(), """\
group {
  n = ab "c d" "ef "
  a = True
  b = 13
  c = 1.3
  d = "abc def ghi"
  e = a *b c
  f = a *b *c
  g = "/var/tmp/foo"
  h = "var.tmp.foo"
  m = plain "% ^&*"
  s0 = None
  s1 = " a " b
  w = plain "% ^&*"
}
""")
  #
  master = phil.parse(input_string="""\
a=None
 .type=int
 .multiple=False
""")
  custom = phil.parse(input_string="""\
a=1
a=2
""")
  extracted = master.fetch(custom).extract()
  assert extracted.a == 2
  out = StringIO()
  master.format(extracted).show(out=out)
  assert out.getvalue() == "a = 2\n"
  custom = phil.parse(input_string="""\
a=1
!a=2
""")
  extracted = master.fetch(custom).extract()
  assert extracted.a == 1
  out = StringIO()
  master.format(extracted).show(out=out)
  assert out.getvalue() == "a = 1\n"
  custom = phil.parse(input_string="""\
""")
  extracted = master.fetch(custom).extract()
  assert extracted.a == None
  out = StringIO()
  master.format(extracted).show(out=out)
  assert out.getvalue() == "a = None\n"
  #
  master = phil.parse(input_string="""\
a=None
 .type=int
 .multiple=True
""")
  custom = phil.parse(input_string="""\
a=1
a=2
""")
  extracted = master.fetch(custom).extract()
  assert extracted.a == [1,2]
  out = StringIO()
  master.format(extracted).show(out=out)
  assert not show_diff(out.getvalue(), """\
a = 1
a = 2
""")
  custom = phil.parse(input_string="""\
a=1
!a=2
""")
  extracted = master.fetch(custom).extract()
  assert extracted.a == [1]
  out = StringIO()
  master.format(extracted).show(out=out)
  assert not show_diff(out.getvalue(), """\
a = 1
""")
  custom = phil.parse(input_string="""\
""")
  extracted = master.fetch(custom).extract()
  assert extracted.a == []
  out = StringIO()
  master.format(extracted).show(out=out)
  assert not show_diff(out.getvalue(), """\
a = None
""")
  #
  master = phil.parse(input_string="""\
a=None
 .type=int
 .multiple=True
 .optional=True
""")
  custom = phil.parse(input_string="""\
a=1
a=2
""")
  extracted = master.fetch(custom).extract()
  assert extracted.a == [1,2]
  out = StringIO()
  master.format(extracted).show(out=out)
  assert not show_diff(out.getvalue(), """\
a = 1
a = 2
""")
  custom = phil.parse(input_string="""\
a=1
!a=2
""")
  extracted = master.fetch(custom).extract()
  assert extracted.a == [1]
  out = StringIO()
  master.format(extracted).show(out=out)
  assert not show_diff(out.getvalue(), """\
a = 1
""")
  custom = phil.parse(input_string="""\
""")
  extracted = master.fetch(custom).extract()
  assert extracted.a == []
  out = StringIO()
  master.format(extracted).show(out=out)
  assert not show_diff(out.getvalue(), """\
a = None
""")
  custom = phil.parse(input_string="""\
a=None
""")
  extracted = master.fetch(custom).extract()
  assert extracted.a == []
  out = StringIO()
  master.format(extracted).show(out=out)
  assert not show_diff(out.getvalue(), """\
a = None
""")
  #
  master = phil.parse(input_string="""\
s
  .multiple=False
{
  a=None
   .type=int
   .multiple=False
}
""")
  custom = phil.parse(input_string="""\
""")
  extracted = master.fetch(custom).extract()
  assert extracted.s.a is None
  out = StringIO()
  master.format(extracted).show(out=out)
  assert not show_diff(out.getvalue(), """\
s {
  a = None
}
""")
  custom = phil.parse(input_string="""\
s {
  a=1
}
s {
  a=2
}
""")
  extracted = master.fetch(custom).extract()
  assert extracted.s.a == 2
  out = StringIO()
  master.format(extracted).show(out=out)
  assert not show_diff(out.getvalue(), """\
s {
  a = 2
}
""")
  custom = phil.parse(input_string="""\
s {
  a=1
}
s {
  a=2
  a=3
}
""")
  extracted = master.fetch(custom).extract()
  assert extracted.s.a == 3
  out = StringIO()
  master.format(extracted).show(out=out)
  assert not show_diff(out.getvalue(), """\
s {
  a = 3
}
""")
  #
  master = phil.parse(input_string="""\
s
  .multiple=True
{
  a=None
   .type=int
   .multiple=False
}
""")
  custom = phil.parse(input_string="""\
""")
  extracted = master.fetch(custom).extract()
  assert len(extracted.s) == 0
  out = StringIO()
  master.format(extracted).show(out=out)
  assert not show_diff(out.getvalue(), """\
s {
  a = None
}
""")
  custom = phil.parse(input_string="""\
s {
  a=None
}
""")
  extracted = master.fetch(custom).extract()
  assert len(extracted.s) == 0
  out = StringIO()
  master.format(extracted).show(out=out)
  assert not show_diff(out.getvalue(), """\
s {
  a = None
}
""")
  custom = phil.parse(input_string="""\
s {
  a=1
}
s {
  a=2
}
""")
  extracted = master.fetch(custom).extract()
  assert extracted.s[0].a == 1
  assert extracted.s[1].a == 2
  out = StringIO()
  master.format(extracted).show(out=out)
  assert not show_diff(out.getvalue(), """\
s {
  a = 1
}
s {
  a = 2
}
""")
  custom = phil.parse(input_string="""\
s {
  a=1
}
s {
  a=2
  a=3
}
""")
  extracted = master.fetch(custom).extract()
  assert extracted.s[0].a == 1
  assert extracted.s[1].a == 3
  out = StringIO()
  master.format(extracted).show(out=out)
  assert not show_diff(out.getvalue(), """\
s {
  a = 1
}
s {
  a = 3
}
""")
  master = phil.parse(input_string="""\
s
  .multiple=True
  .optional=True
{
  a=None
   .type=int
   .multiple=False
}
""")
  custom = phil.parse(input_string="""\
""")
  extracted = master.fetch(custom).extract()
  assert extracted.s == []
  out = StringIO()
  master.format(extracted).show(out=out)
  assert not show_diff(out.getvalue(), """\
s {
  a = None
}
""")
  custom = phil.parse(input_string="""\
s {
  a=None
}
""")
  extracted = master.fetch(custom).extract()
  assert extracted.s == []
  out = StringIO()
  master.format(extracted).show(out=out)
  assert not show_diff(out.getvalue(), """\
s {
  a = None
}
""")
  custom = phil.parse(input_string="""\
s {
  a=1
}
s {
  a=2
}
""")
  extracted = master.fetch(custom).extract()
  assert extracted.s[0].a == 1
  assert extracted.s[1].a == 2
  out = StringIO()
  master.format(extracted).show(out=out)
  assert not show_diff(out.getvalue(), """\
s {
  a = 1
}
s {
  a = 2
}
""")
  custom = phil.parse(input_string="""\
s {
  a=1
}
s {
  a=2
  a=3
}
""")
  extracted = master.fetch(custom).extract()
  assert extracted.s[0].a == 1
  assert extracted.s[1].a == 3
  out = StringIO()
  master.format(extracted).show(out=out)
  assert not show_diff(out.getvalue(), """\
s {
  a = 1
}
s {
  a = 3
}
""")
  #
  master = phil.parse(input_string="""\
a=None
 .type=int
 .multiple=True
b
  .multiple=True
{
  a=None
    .type=int
    .multiple=True
  b=None
    .type=int
    .multiple=True
    .optional=True
  c=None
    .type=int
}
c
  .multiple=True
  .optional=True
{
  a=None
}
d
  .multiple=True
  .optional=False
{
  a=None
    .type=int
}
""")
  custom = phil.parse(input_string="""\
a=1
a=2
b {
  a=3
  a=4
  c=10
  c=20
}
b {
  b=5
  b=6
}
c {
  a=None
}
""")
  fetched = master.fetch(custom)
  extracted = fetched.extract()
  assert extracted.a == [1,2]
  assert extracted.b[0].a == [3,4]
  assert extracted.b[0].b == []
  assert extracted.b[0].c == 20
  assert extracted.b[1].a == []
  assert extracted.b[1].b == [5,6]
  assert extracted.b[1].c is None
  assert extracted.c == []
  assert extracted.d[0].a is None
  out = StringIO()
  master.format(extracted).show(out=out)
  assert not show_diff(out.getvalue(), """\
a = 1
a = 2
b {
  a = 3
  a = 4
  b = None
  c = 20
}
b {
  a = None
  b = 5
  b = 6
  c = None
}
c {
  a = None
}
d {
  a = None
}
""")
  #
  params = phil.parse(input_string="""\
a=1
  .type=int
s {
  b=2
    .type=int
}
""")
  orig = params.extract()
  assert orig.a == 1
  assert orig.s.b == 2
  clone = params.clone(python_object=orig)
  assert clone.a == 1
  assert clone.s.b == 2
  clone.a = 10
  clone.s.b = 20
  assert orig.a == 1
  assert orig.s.b == 2
  #
  master = phil.parse(input_string="""\
a = x y
  .optional = True
  .type = choice
b = *p q
  .optional = True
  .type = choice
c = *r s
  .optional = True
  .type = choice
d = g h
  .optional = True
  .type = choice(multi=True)
e = *j *k
  .optional = True
  .type = choice(multi=True)
f = *l *m
  .optional = True
  .type = choice(multi=True)
""")
  extracted = master.extract()
  assert extracted.a is None
  assert extracted.b == "p"
  assert extracted.c == "r"
  assert extracted.d == []
  assert extracted.e == ["j", "k"]
  assert extracted.f == ["l", "m"]
  extracted.c = None
  del extracted.f[:]
  out = StringIO()
  master.format(extracted).show(out=out)
  assert not show_diff(out.getvalue(), """\
a = x y
b = *p q
c = r s
d = g h
e = *j *k
f = l m
""")
  #
  for input_string in ["""
a = None
  .type = str
  .multiple = True
""", """\
a = None
  .optional = True
  .type = str
  .multiple = True
""", """\
a = None
  .optional = False
  .type = str
  .multiple = True
"""]:
    master = phil.parse(input_string=input_string)
    source = phil.parse(input_string="")
    w = master.fetch(source=source)
    e = w.extract()
    opt = master.objects[0].optional
    if (opt is None or opt):
      assert len(e.a) == 0
    else:
      assert len(e.a) == 1
      e.a[0] is None
    source = phil.parse(input_string="a=None")
    w = master.fetch(source=source)
    e = w.extract()
    if (opt is None or opt):
      assert len(e.a) == 0
    else:
      assert len(e.a) == 1
      e.a[0] is None
    source = phil.parse(input_string="a=x")
    w = master.fetch(source=source)
    e = w.extract()
    if (opt is None or opt):
      assert e.a == ["x"]
    else:
      assert len(e.a) == 2
      e.a[0] is None
      e.a[1] == "x"
  #
  for input_string in ["""\
s
  .multiple = True
{
  a = None
    .type = str
}
""", """
s
  .optional = True
  .multiple = True
{
  a = None
    .type = str
}
""", """
s
  .optional = False
  .multiple = True
{
  a = None
    .type = str
}
"""]:
    master = phil.parse(input_string=input_string)
    source = phil.parse(input_string="")
    w = master.fetch(source=source)
    e = w.extract()
    opt = master.objects[0].optional
    if (opt is None or opt):
      assert len(e.s) == 0
    else:
      assert len(e.s) == 1
      assert e.s[0].a is None
    source = phil.parse(input_string="s {}")
    w = master.fetch(source=source)
    e = w.extract()
    if (opt is None or opt):
      assert len(e.s) == 0
    else:
      assert len(e.s) == 1
      assert e.s[0].a is None
    source = phil.parse(input_string="s { a=x }")
    w = master.fetch(source=source)
    e = w.extract()
    if (opt is None or opt):
      assert len(e.s) == 1
      assert e.s[0].a == "x"
    else:
      assert len(e.s) == 2
      assert e.s[0].a is None
      assert e.s[1].a == "x"
  #
  master = phil.parse(input_string="""\
s
  .optional = True
  .multiple = True
{
  a = None
    .type = str
  b = 0
    .type = float
  c = *x *y
    .optional = True
    .type = choice(multi=True)
}
""")
  for input_string in ["", "s {}"]:
    source = phil.parse(input_string=input_string)
    w = master.fetch(source=source)
    e = w.extract()
    assert len(e.s) == 0
    f = master.format(python_object=e)
    assert f.objects[0].is_template == 1
    assert not show_diff(f.as_str(), """\
s {
  a = None
  b = 0
  c = *x *y
}
""")
    assert not show_diff(f.as_str(attributes_level=2), """\
s
  .optional = True
  .multiple = True
{
  a = None
    .type = str
  b = 0
    .type = float(allow_none=True)
  c = *x *y
    .optional = True
    .type = choice(multi=True)
}
""")
  source = phil.parse(input_string="""\
s.b=1
""")
  w = master.fetch(source=source)
  e = w.extract()
  assert len(e.s) == 1
  assert e.s[0].b == 1
  f = master.format(python_object=e)
  assert f.objects[0].is_template == -1
  assert f.objects[1].is_template == 0
  assert not show_diff(f.as_str(), """\
s {
  a = None
  b = 1
  c = *x *y
}
""")
  assert not show_diff(f.as_str(attributes_level=2), """\
s
  .optional = True
  .multiple = True
{
  a = None
    .type = str
  b = 0
    .type = float(allow_none=True)
  c = *x *y
    .optional = True
    .type = choice(multi=True)
}
s
  .optional = True
  .multiple = True
{
  a = None
    .type = str
  b = 1
    .type = float(allow_none=True)
  c = *x *y
    .optional = True
    .type = choice(multi=True)
}
""")
  source = phil.parse(input_string="""\
s.c=*x
s.c=*y
""")
  w = master.fetch(source=source)
  e = w.extract()
  assert len(e.s) == 2
  assert e.s[0].c == ["x"]
  assert e.s[1].c == ["y"]
  f = master.format(python_object=e)
  assert f.objects[0].is_template == -1
  assert f.objects[1].is_template == 0
  assert f.objects[2].is_template == 0
  assert not show_diff(f.as_str(), """\
s {
  a = None
  b = 0
  c = *x y
}
s {
  a = None
  b = 0
  c = x *y
}
""")
  #
  master = phil.parse(input_string="""\
s
  .multiple = True
{
  a = x
    .type = str
  b = 2
    .type = int
  c = x *y
    .optional = True
    .type = choice(multi=True)
  d = None
    .type = float
}
s {
}
""")
  source = phil.parse(input_string="""\
""")
  w = master.fetch(source=source)
  e = w.extract()
  assert len(e.s) == 0
  f = master.format(python_object=e)
  assert not show_diff(f.as_str(), """\
s {
  a = x
  b = 2
  c = x *y
  d = None
}
""")
  assert not show_diff(f.as_str(attributes_level=2), """\
s
  .multiple = True
{
  a = x
    .type = str
  b = 2
    .type = int(allow_none=True)
  c = x *y
    .optional = True
    .type = choice(multi=True)
  d = None
    .type = float(allow_none=True)
}
""")
  #
  master = phil.parse(input_string="""\
a = None
  .optional = True
  .multiple = True
""")
  source = phil.parse(input_string="""\
""")
  w = master.fetch(source=source)
  e = w.extract()
  assert len(e.a) == 0
  f = master.format(python_object=e)
  assert not show_diff(f.as_str(), """\
a = None
""")
  assert not show_diff(f.as_str(attributes_level=2), """\
a = None
  .optional = True
  .multiple = True
""")
  source = phil.parse(input_string="""\
a=x
""")
  w = master.fetch(source=source)
  e = w.extract()
  assert e.a == [["x"]]
  f = master.format(python_object=e)
  assert not show_diff(f.as_str(), """\
a = x
""")
  assert not show_diff(f.as_str(attributes_level=2), """\
a = x
  .optional = True
  .multiple = True
""")
  source = phil.parse(input_string="""\
a=x
a=y
""")
  w = master.fetch(source=source)
  e = w.extract()
  assert len(e.a) == 2
  assert e.a == [["x"], ["y"]]
  f = master.format(python_object=e)
  assert not show_diff(f.as_str(), """\
a = x
a = y
""")
  assert not show_diff(f.as_str(attributes_level=2), """\
a = x
  .optional = True
  .multiple = True
a = y
  .optional = True
  .multiple = True
""")

class foo1_converters(object):

  phil_type = "foo1"

  def __str__(self): return "foo1"

  def __init__(self, bar=None):
    if (bar is None):
      raise RuntimeError("foo1 problem")

class foo2_converters(object):

  def __str__(self): return "foo2"

  def __init__(self, bar=None):
    if (bar is not None):
      raise RuntimeError("foo2 problem")

foo_converter_registry = phil.extended_converter_registry(
  additional_converters=[foo1_converters, foo2_converters])

def exercise_choice():
  master = phil.parse(input_string="""\
x=*a b
  .type=choice
y=*a b
  .type=choice
  .optional=True
""")
  py_params = master.extract()
  py_params.x = "c"
  try: master.format(py_params)
  except RuntimeError as e:
    assert str(e) == "Invalid choice: x=c"
  else: raise Exception_expected
  py_params.x = "b"
  py_params.y = "c"
  try: master.format(py_params)
  except RuntimeError as e:
    assert str(e) == "Invalid choice: y=c"
  else: raise Exception_expected
  master = phil.parse(input_string="""\
x=*a a
  .type=choice
""")
  py_params = master.extract()
  try: master.format(py_params)
  except RuntimeError as e:
    assert str(e) \
        == "Improper master choice definition: x = *a a (input line 1)"
  else: raise Exception_expected
  #
  master = phil.parse(input_string="""\
x=*a b
  .type=choice(multi=True)
  .optional=False
y=a b
  .type=choice(multi=True)
  .optional=True
""")
  py_params = master.extract()
  py_params.x = ["a", "c", "d"]
  try: master.format(py_params)
  except RuntimeError as e:
    assert str(e) == "Invalid choice(multi=True): x=['c', 'd']"
  else: raise Exception_expected
  py_params.x = []
  try: master.format(py_params)
  except RuntimeError as e:
    assert str(e) == "Empty list for mandatory choice(multi=True): x"
  else: raise Exception_expected
  master = phil.parse(input_string="""\
x=*a b
  .type=choice(multi=True)
""")
  py_params = master.extract()
  py_params.x = []
  assert not show_diff(master.format(py_params).as_str(), """\
x = a b
""")
  #
  master = phil.parse(input_string="""\
x=*a b
  .type=choice
""")
  py_params = master.extract()
  py_params.x = None
  assert not show_diff(master.format(py_params).as_str(), """\
x = a b
""")
  master = phil.parse(input_string="""\
x=*a b
  .type=choice
  .optional=False
""")
  py_params = master.extract()
  py_params.x = None
  try: master.format(py_params)
  except RuntimeError as e:
    assert str(e) == "Invalid choice: x=None"
  else: raise Exception_expected
  master_phil = phil.parse("""\
multiwordchoice = 'a b' 'b c'
  .type = choice
""")
  other = phil.parse("""
multiwordchoice = 'a b'
""")
  s = StringIO()
  master_phil.fetch_diff(source=other).show(out=s)
  diff_phil = phil.parse(input_string=s.getvalue())
  working_phil = master_phil.fetch(source=diff_phil)
  assert not show_diff(working_phil.as_str(),"multiwordchoice = '*a b' 'b c'\n")
  master_phil = phil.parse("""\
x = a b
  .type = choice
y = *a B
  .type = choice
""")
  other = phil.parse("""\
x = A
y = b
""")
  params = master_phil.extract()
  assert params.x is None
  assert params.y == 'a'
  params = master_phil.fetch(source=other).extract()
  assert params.x == 'a'
  assert params.y == 'B'

def exercise_type_constructors():
  params = phil.parse(
    input_string="""\
a=None
  .type=foo2
b=None
  .type=foo2(bar=None)
c=None
  .type=foo1(bar=0)
""",
    converter_registry=foo_converter_registry)
  try: params.get(path="a").objects[0].extract()
  except RuntimeError as e:
    assert str(e) == \
      '.type=foo2 does not have a from_words method (input line 1):' \
      " AttributeError: 'foo2_converters' object has no attribute 'from_words'"
  else: raise Exception_expected
  try: params.get(path="a").objects[0].format(python_object=0)
  except RuntimeError as e:
    assert str(e) == \
      '.type=foo2 does not have an as_words method (input line 1):' \
      " AttributeError: 'foo2_converters' object has no attribute 'as_words'"
  else: raise Exception_expected
  try: phil.parse(
    input_string="""\
a=None
  .type=foo1
""",
    converter_registry=foo_converter_registry)
  except RuntimeError as e:
    assert str(e) == \
      'Error constructing definition type "foo1": RuntimeError:' \
      ' foo1 problem (input line 2)'
  else: raise Exception_expected
  try: phil.parse(
    input_string="""\
a=None
  .type=foo2(bar=1)
""",
    converter_registry=foo_converter_registry)
  except RuntimeError as e:
    e = str(e)
    assert e.startswith(
      'Error constructing definition type "foo2(bar=1)": RuntimeError: ')
    assert e.endswith(' foo2 problem (input line 2)')
  else: raise Exception_expected
  try: phil.parse(
    input_string="""\
a=None
  .type=foo2(foo=1)
""",
    converter_registry=foo_converter_registry)
  except RuntimeError as e:
    expected_message = \
      'Error constructing definition type "foo2(foo=1)": TypeError:' \
      " __init__() got an unexpected keyword argument 'foo' (input line 2)"
    if sys.version_info.major == 3 and sys.version_info.minor >= 10:
      expected_message = \
        'Error constructing definition type "foo2(foo=1)": TypeError:' \
        " foo2_converters.__init__() got an unexpected keyword argument 'foo' (input line 2)"
    assert str(e) == expected_message
  else: raise Exception_expected
  try: phil.parse("""\
a=None
  .type=foo2(foo=1
""",
    converter_registry=foo_converter_registry)
  except RuntimeError as e:
    assert str(e).startswith('Error evaluating definition type "foo2(foo=1": ')
    assert str(e).endswith(' (input line 2)')
  else: raise Exception_expected
  try: phil.parse("""\
a=None
  .type=foo2(foo=1=2)
""",
    converter_registry=foo_converter_registry)
  except RuntimeError as e:
    assert str(e) == 'Error constructing definition type "foo2(foo=1=2)":' \
      ' SyntaxError: invalid syntax (line 1) (input line 2)'
  else: raise Exception_expected

def exercise_auto():
  for nao in [None, Auto]:
    na = str(nao)
    master = phil.parse(input_string="""\
abool=%(na)s
  .type=bool
aint=%(na)s
  .type=int
afloat=%(na)s
  .type=float
astr=%(na)s
  .type=str
achoice=a b
  .type=choice
achoicemand=*a b
  .type=choice
  .optional=False
achoicemult=a b
  .type=choice(multi=True)
achoicemultmand=*a b
  .type=choice(multi=True)
  .optional=False
apath=%(na)s
  .type=path
akey=%(na)s
  .type=key
anone=%(na)s
  .type=None
astrings=%(na)s
  .type=strings
awords=%(na)s
  .type=words
""" % vars())
    for i in range(3):
      params = master.extract()
      assert params.abool is nao
      assert params.aint is nao
      assert params.afloat is nao
      assert params.astr is nao
      assert params.achoice is None
      assert params.achoicemand == "a"
      assert params.achoicemult == []
      assert params.achoicemultmand == ["a"]
      assert params.apath is nao
      assert params.akey is nao
      assert params.anone is nao
      assert params.astrings is nao
      assert params.awords is nao
      master = master.fetch()
    assert not show_diff(master.format(params).as_str(), """\
abool = %(na)s
aint = %(na)s
afloat = %(na)s
astr = %(na)s
achoice = a b
achoicemand = *a b
achoicemult = a b
achoicemultmand = *a b
apath = %(na)s
akey = %(na)s
anone = %(na)s
astrings = %(na)s
awords = %(na)s
""" % vars())
    custom = phil.parse(input_string="""\
abool=Auto
aint=Auto
afloat=Auto
astr=Auto
achoice=Auto
achoicemand=Auto
achoicemult=Auto
achoicemultmand=Auto
apath=Auto
akey=Auto
anone=Auto
astrings=Auto
awords=Auto
""")
    params = master.fetch(source=custom).extract()
    assert params.abool is Auto
    assert params.aint is Auto
    assert params.afloat is Auto
    assert params.astr is Auto
    assert params.achoice is Auto
    assert params.achoicemand is Auto
    assert params.achoicemult is Auto
    assert params.achoicemultmand is Auto
    assert params.apath is Auto
    assert params.akey is Auto
    assert params.anone is Auto
    assert params.astrings is Auto
    assert params.awords is Auto
    assert not show_diff(master.format(params).as_str(), """\
abool = Auto
aint = Auto
afloat = Auto
astr = Auto
achoice = Auto
achoicemand = Auto
achoicemult = Auto
achoicemultmand = Auto
apath = Auto
akey = Auto
anone = Auto
astrings = Auto
awords = Auto
""")
    params_pkl = easy_pickle.dumps(params)
    params2 = easy_pickle.loads(params_pkl)
    assert not show_diff(master.format(params2).as_str(), """\
abool = Auto
aint = Auto
afloat = Auto
astr = Auto
achoice = Auto
achoicemand = Auto
achoicemult = Auto
achoicemultmand = Auto
apath = Auto
akey = Auto
anone = Auto
astrings = Auto
awords = Auto
""")

def exercise_int_and_float():
  master_phil = phil.parse(input_string="""\
a=None
  .type=float
b=1.0
  .type=int
c=1.5
  .type=float(value_min=1.0)
d=4.5
  .type=float(value_max=5.0)
e=6.2
  .type=float(value_min=3.2, value_max=7.6)
f = 5
  .type = int(value_min=0)
g = 3
  .type = int(value_max=4)
h = 10
  .type = int(value_min=4, value_max=12)
""")
  work_params = master_phil.extract()
  work_phil = master_phil.format(python_object=work_params)
  assert not show_diff(work_phil.as_str(attributes_level=2),"""\
a = None
  .type = float(allow_none=True)
b = 1
  .type = int(allow_none=True)
c = 1.5
  .type = float(value_min=1, allow_none=True)
d = 4.5
  .type = float(value_max=5, allow_none=True)
e = 6.2
  .type = float(value_min=3.2, value_max=7.6, allow_none=True)
f = 5
  .type = int(value_min=0, allow_none=True)
g = 3
  .type = int(value_max=4, allow_none=True)
h = 10
  .type = int(value_min=4, value_max=12, allow_none=True)
""")
  #
  master_phil = phil.parse(input_string="""\
a=-1.5
  .type=float(value_min=1.0, allow_none=True)
""")
  try: master_phil.extract()
  except RuntimeError as e:
    assert not show_diff(str(e),
      "a element is less than the minimum allowed value:"
      " -1.5 < 1 (input line 1)")
  else: raise Exception_expected
  #
  master_phil = phil.parse(input_string="""\
b=5.1
  .type=float(value_min=0.0, value_max=5.0)
""")
  try: master_phil.extract()
  except RuntimeError as e:
    assert not show_diff(str(e),
      "b element is greater than the maximum allowed value:"
      " 5.1 > 5 (input line 1)")
  else: raise Exception_expected
  #
  master_phil = phil.parse(input_string="""\
c=7
  .type=int(value_max=6)
""")
  try: master_phil.extract()
  except RuntimeError as e:
    assert not show_diff(str(e),
      "c element is greater than the maximum allowed value:"
      " 7 > 6 (input line 1)")
  else: raise Exception_expected
  #
  master_phil = phil.parse(input_string="""\
d=-6
  .type=int(value_min=3, value_max=25)
""")
  try: master_phil.extract()
  except RuntimeError as e:
    assert not show_diff(str(e),
      "d element is less than the minimum allowed value:"
      " -6 < 3 (input line 1)")
  else: raise Exception_expected
  #
  master_phil = phil.parse(input_string="""\
d=None
  .type=int(allow_none=False)
""")
  try: master_phil.extract()
  except RuntimeError as e:
    assert not show_diff(str(e),
      "d cannot be None")
  else: raise Exception_expected

def exercise_ints_and_floats():
  master_phil = phil.parse(input_string="""\
a=None
  .type=floats
b=Auto
  .type=ints
c=1
  .type=floats
d=1 1/2
  .type=floats
e=2,3/4,4/5
  .type=floats
f="1;1/2"
  .type=floats
g=None
  .type=floats
""")
  work_params = master_phil.extract()
  work_params.g = [1/4]
  work_phil = master_phil.format(python_object=work_params)
  assert not show_diff(work_phil.as_str(attributes_level=2), """\
a = None
  .type = floats
b = Auto
  .type = ints
c = 1
  .type = floats
d = 1 0.5
  .type = floats
e = 2 0.75 0.8
  .type = floats
f = 1 0.5
  .type = floats
g = 0.25
  .type = floats
""")
  #
  master_phil = phil.parse(input_string="""\
a=1 v
  .type=floats
""")
  try: master_phil.extract()
  except RuntimeError as e:
    assert str(e) == """\
Error interpreting a="v" as a numeric expression:\
 NameError: name 'v' is not defined (input line 1)"""
  else: raise Exception_expected
  #
  master_phil = phil.parse(input_string="""\
a=1 2
  .type=ints(2)
b=3
  .type=floats(size=1)
c=4 5
  .type=ints(size_min=2)
d=6
  .type=floats(size_max=2)
e=7 8 9
  .type=floats(size_max=4, size_min=2)
f=10 20
  .type=floats(value_max=20, value_min=10)
g=nOnE aUtO
  .type=floats(allow_none_elements=True, allow_auto_elements=True)
""")
  work_params = master_phil.extract()
  work_phil = master_phil.format(python_object=work_params)
  assert not show_diff(work_phil.as_str(attributes_level=2), """\
a = 1 2
  .type = ints(size=2)
b = 3
  .type = floats(size=1)
c = 4 5
  .type = ints(size_min=2)
d = 6
  .type = floats(size_max=2)
e = 7 8 9
  .type = floats(size_min=2, size_max=4)
f = 10 20
  .type = floats(value_min=10, value_max=20)
g = None Auto
  .type = floats(allow_none_elements=True, allow_auto_elements=True)
""")
  #
  user_phil = phil.parse(input_string="""\
f=9
""")
  work_phil = master_phil.fetch(source=user_phil)
  try: work_phil.extract()
  except RuntimeError as e:
    assert not show_diff(str(e),
      "f element is less than the minimum allowed value:"
      " 9 < 10 (input line 1)")
  else: raise Exception_expected
  user_phil = phil.parse(input_string="""\
f=10
""")
  work_phil = master_phil.fetch(source=user_phil)
  work_params = work_phil.extract()
  work_params.f[0] = 9
  try: master_phil.format(python_object=work_params)
  except RuntimeError as e:
    assert not show_diff(str(e),
      "f element is less than the minimum allowed value: 9 < 10")
  else: raise Exception_expected
  #
  user_phil = phil.parse(input_string="""\
f=21
""")
  work_phil = master_phil.fetch(source=user_phil)
  try: work_phil.extract()
  except RuntimeError as e:
    assert not show_diff(str(e),
      "f element is greater than the maximum allowed value:"
      " 21 > 20 (input line 1)")
  else: raise Exception_expected
  user_phil = phil.parse(input_string="""\
f=20
""")
  work_phil = master_phil.fetch(source=user_phil)
  work_params = work_phil.extract()
  work_params.f[0] = 21
  try: master_phil.format(python_object=work_params)
  except RuntimeError as e:
    assert not show_diff(str(e),
      "f element is greater than the maximum allowed value: 21 > 20")
  else: raise Exception_expected
  #
  user_phil = phil.parse(input_string="""\
e=1
""")
  work_phil = master_phil.fetch(source=user_phil)
  try: work_phil.extract()
  except RuntimeError as e:
    assert not show_diff(str(e),
      "Not enough values for e: 1 given, at least 2 required (input line 1)")
  else: raise Exception_expected
  work_params = master_phil.extract()
  work_params.e = [1]
  try: master_phil.format(python_object=work_params)
  except RuntimeError as e:
    assert not show_diff(str(e),
      "Not enough values for e: 1 given, at least 2 required")
  else: raise Exception_expected
  #
  user_phil = phil.parse(input_string="""\
a=1
""")
  work_phil = master_phil.fetch(source=user_phil)
  try: work_phil.extract()
  except RuntimeError as e:
    assert not show_diff(str(e),
      "Not enough values for a: 1 given, exactly 2 required (input line 1)")
  else: raise Exception_expected
  work_params = master_phil.extract()
  work_params.a = [1]
  try: master_phil.format(python_object=work_params)
  except RuntimeError as e:
    assert not show_diff(str(e),
      "Not enough values for a: 1 given, exactly 2 required")
  else: raise Exception_expected
  #
  user_phil = phil.parse(input_string="""\
e=1 2 3 4 5
""")
  work_phil = master_phil.fetch(source=user_phil)
  try: work_phil.extract()
  except RuntimeError as e:
    assert not show_diff(str(e),
      "Too many values for e: 5 given, 4 allowed at most (input line 1)")
  else: raise Exception_expected
  work_params = master_phil.extract()
  work_params.e = [1,2,3,4,5]
  try: master_phil.format(python_object=work_params)
  except RuntimeError as e:
    assert not show_diff(str(e),
      "Too many values for e: 5 given, 4 allowed at most")
  else: raise Exception_expected
  #
  user_phil = phil.parse(input_string="""\
a=1 2 3
""")
  work_phil = master_phil.fetch(source=user_phil)
  try: work_phil.extract()
  except RuntimeError as e:
    assert not show_diff(str(e),
      "Too many values for a: 3 given, exactly 2 required (input line 1)")
  else: raise Exception_expected
  work_params = master_phil.extract()
  work_params.a = [1,2,3]
  try: master_phil.format(python_object=work_params)
  except RuntimeError as e:
    assert not show_diff(str(e),
      "Too many values for a: 3 given, exactly 2 required")
  else: raise Exception_expected
  #
  for value in ["None", "Auto"]:
    user_phil = phil.parse(input_string="""\
a=1 %s
""" % value.lower())
    work_phil = master_phil.fetch(source=user_phil)
    try: work_phil.extract()
    except RuntimeError as e:
      assert not show_diff(str(e),
        "a element cannot be %s (input line 1)" % value)
    else: raise Exception_expected
    work_params = master_phil.extract()
    work_params.a = [1, eval(value)]
    try: master_phil.format(python_object=work_params)
    except RuntimeError as e:
      assert not show_diff(str(e),
        "a element cannot be %s" % value)
    else: raise Exception_expected
  #
  master_phil = phil.parse(input_string="""\
a = None
  .type = floats
b = None
  .type = ints
""")
  user_phil = phil.parse(input_string="""\
a = ([12.34, 45.67])
b = [(3,4)]
""")
  work_phil = master_phil.fetch(user_phil)
  assert not show_diff(work_phil.extract_format().as_str(), """\
a = 12.34 45.67
b = 3 4
""")

def exercise_definition_validate_etc():
  working_phil = phil.parse(input_string="""\
a=None
  .type=ints
""")
  a = working_phil.objects[0]
  proxy = a.try_tokenize(input_string=" 3 ")
  assert proxy.error_message is None
  assert not show_diff(proxy.tokenized.as_str(), "a = 3\n")
  proxy = a.try_tokenize(input_string="'", source_info="src")
  assert not show_diff(
    proxy.error_message, 'Syntax error: missing closing quote (src, line 1)')
  assert proxy.tokenized is None
  proxy = a.try_tokenize(input_string=" 3,  2")
  assert proxy.error_message is None
  assert not show_diff(proxy.tokenized.as_str(), "a = 3, 2\n")
  proxy2 = proxy.tokenized.try_extract()
  assert proxy2.error_message is None
  assert proxy2.extracted == [3, 2]
  proxy2 = proxy.tokenized.try_extract_format()
  assert proxy2.error_message is None
  assert not show_diff(proxy2.formatted.as_str(), "a = 3 2\n")
  proxy = a.try_tokenize(input_string="'x y'", source_info="Src")
  assert proxy.error_message is None
  assert not show_diff(proxy.tokenized.as_str(), "a = 'x y'\n")
  proxy2 = proxy.tokenized.try_extract()
  assert not show_diff(proxy2.error_message, """\
Error interpreting a="x" as a numeric expression:\
 NameError: name 'x' is not defined (Src, line 1)""")
  assert proxy2.extracted == None
  proxy2f = proxy.tokenized.try_extract_format()
  assert not show_diff(proxy2f.error_message, proxy2.error_message)
  assert proxy2f.formatted is None
  proxy = a.validate(input_string="1;2,3")
  assert proxy.error_message is None
  assert proxy.extracted == [1,2,3]
  proxy = a.validate_and_format(input_string="1;2,3\n4")
  assert proxy.error_message is None
  assert not show_diff(proxy.formatted.as_str(), "a = 1 2 3 4\n")
  for v,m in [(a.validate, "extracted"), (a.validate_and_format, "formatted")]:
    proxy = v(input_string="*", source_info="si")
    expected_message = """\
Error interpreting a="*" as a numeric expression:\
 SyntaxError: unexpected EOF while parsing (line 1) (si, line 1)"""
    if sys.version_info.major == 3 and sys.version_info.minor >= 10:
      expected_message = """\
Error interpreting a="*" as a numeric expression:\
 SyntaxError: invalid syntax (line 1) (si, line 1)"""
    assert not show_diff(proxy.error_message, expected_message)
    assert getattr(proxy, m) is None
  proxy = a.validate(input_string="1;2,3")
  #
  proxy = a.validate_and_format(input_string=" 5*2 3 7 ")
  a.words = proxy.formatted.words
  assert not show_diff(working_phil.as_str(), "a = 10 3 7\n")
  #
  working_phil = phil.parse(input_string="""\
a=None
  .type=None
""")
  a = working_phil.objects[0]
  proxy = a.try_tokenize(input_string="")
  assert proxy.error_message is None
  proxy2 = proxy.tokenized.try_extract()
  assert proxy2.error_message is None
  assert proxy2.extracted is None

def exercise_command_line():
  master_string = """\
foo {
  min=0
  max=10
  index=3
  limit=6
}
bar {
  max=5
  sub {
    limit=8
  }
  flag=None
}
"""
  master_phil = phil.parse(input_string=master_string)
  itpr_bar = master_phil.command_line_argument_interpreter(
    home_scope="bar")
  itpr_neutral = master_phil.command_line_argument_interpreter()
  for itpr in [itpr_bar, itpr_neutral]:
    itpr.process(arg="foo.limit=4\nbar.max=2").as_str() == """\
foo.limit = 4
bar.max = 2
"""
  assert itpr_bar.process(arg="max=6").as_str() == "bar.max = 6\n"
  assert itpr_bar.process(arg="ax=7").as_str() == "bar.max = 7\n"
  try: assert itpr_neutral.process(arg="max=5")
  except Sorry as e:
    assert not show_diff(str(e), """\
Ambiguous parameter definition: max = 5
Best matches:
  foo.max
  bar.max""")
  else: raise Exception_expected
  assert itpr_bar.process(arg="limit=0").as_str() == "bar.sub.limit = 0\n"
  assert itpr_bar.process(arg="imit=0").as_str() == "bar.sub.limit = 0\n"
  for itpr in [itpr_bar, itpr_neutral]:
    assert itpr.process(arg="index=0").as_str() == "foo.index = 0\n"
    assert itpr.process(arg="ndex=0").as_str() == "foo.index = 0\n"
  try: itpr_bar.process(arg="xyz=")
  except Sorry as e:
    assert not show_diff(str(e), """\
Error interpreting command line argument as parameter definition:
  "xyz="
  RuntimeError: Missing value for xyz (command line argument, line 1)""")
  else: raise Exception_expected
  try: itpr_bar.process(arg="xyz=8")
  except Sorry as e:
    assert str(e) == "Unknown command line parameter definition: xyz = 8"
  else: raise Exception_expected
  try: itpr_bar.process(arg="  ")
  except Sorry as e:
    assert str(e) == 'Command line parameter definition has no effect: "  "'
  else: raise Exception_expected
  itpr = master_phil.command_line_argument_interpreter(
    argument_description="")
  try: itpr.process(arg="bar {}")
  except Sorry as e:
    assert str(e) == 'Parameter definition has no effect: "bar {}"'
  else: raise Exception_expected
  #
  with open("tmp0d5f6e10.phil", "w") as f:
    print("foo.limit=-3", file=f)
  user_phils = itpr_bar.process(args=[
    "",
    "--flag",
    "--flag=no",
    "tmp0d5f6e10.phil",
    "max=8",
    "limit=9"])
  assert len(user_phils) == 5
  for i,expected in enumerate([
        "bar.flag = True\n",
        "bar.flag = no\n",
        "foo.limit = -3\n",
        "bar.max = 8\n",
        "bar.sub.limit = 9\n"]):
    assert not show_diff(user_phils[i].as_str(), expected)
  os.remove("tmp0d5f6e10.phil")
  assert not os.path.exists("tmp0d5f6e10.phil")
  for arg in ["tmp0d5f6e10.phil", "lmit=3"]:
    try: itpr_bar.process(args=[arg])
    except Sorry as e:
      assert not show_diff(str(e),
        'Uninterpretable command line argument: "%s"' % arg)
    else: raise Exception_expected
  with open("tmp0d5f6e10.phil", "w") as f:
    print("foo$limit=0", file=f)
  try: itpr_bar.process(args=["tmp0d5f6e10.phil"])
  except RuntimeError as e:
    assert not show_diff(str(e),
      'Syntax error: improper definition name "foo$limit"'
      ' (file "tmp0d5f6e10.phil", line 1)')
  else: raise Exception_expected
  intercepted = []
  def custom_processor(arg):
    intercepted.append(arg)
    return True
  args = ["tmp0d5f6e10.phil", "lmit=3"]
  user_phils = itpr_bar.process(args=args, custom_processor=custom_processor)
  assert len(user_phils) == 0
  assert intercepted == args
  intercepted = []
  def custom_processor(arg):
    if (not os.path.isfile(arg)):
      return False
    intercepted.append(arg)
    return True
  try: itpr_bar.process(args=args, custom_processor=custom_processor)
  except Sorry as e:
    assert not show_diff(str(e),
      'Uninterpretable command line argument: "lmit=3"')
  else: raise Exception_expected
  assert intercepted == args[:1]
  user_phil = itpr_bar.process_and_fetch(args=["limit=12"])
  assert not anchored_block_show_diff(user_phil.as_str(), 9, """\
    limit = 12
""")
  #
  pcl = phil.process_command_line(
    args=["bar.max=4943"], master_string=master_string)
  assert pcl.parse is phil.parse
  assert not show_diff(pcl.master.as_str(), master_phil.as_str())
  s = StringIO()
  pcl.show(out=s)
  assert not anchored_block_show_diff(s.getvalue(), 7, """\
  max = 4943
""")
  assert pcl.remaining_args == []
  pcl = phil.process_command_line(
    args=["892c8632"], master_string=master_string)
  assert pcl.remaining_args == ["892c8632"]
  master_phil = phil.parse("""
sites = None
  .type = int
""")
  def custom_processor(arg):
    try :
      val = int(arg)
    except ValueError :
      return None
    else :
      return phil.parse("sites=%d" % val)
  pcl = master_phil.command_line_argument_interpreter()
  args = ["2"]
  user_phil = pcl.process_args(args=["2"],
    custom_processor=custom_processor)
  params = master_phil.fetch(sources=user_phil).extract()
  assert (params.sites == 2)

def exercise_command_line_assume():
  master_string = """\
foo {
  min=0
  max=10
    .expert_level = 0
  index=3
  limit=6
}
bar {
  max=5
    .expert_level = 1
  sub {
    limit=8
  }
  flag=None
}
"""
  master_phil = phil.parse(input_string=master_string)
  # do not assume
  itpr_neutral = master_phil.command_line_argument_interpreter(assume_when_ambiguous=False)
  try: assert itpr_neutral.process(arg="max=5")
  except Sorry as e:
    assert not show_diff(str(e), """\
Ambiguous parameter definition: max = 5
Best matches:
  foo.max
  bar.max""")
  else: raise Exception_expected
  # assume with different expert levels
  itpr_neutral = master_phil.command_line_argument_interpreter(assume_when_ambiguous=True)
  old_stdout = sys.stdout
  output = StringIO()
  sys.stdout = output
  itpr_neutral.process(arg="max=5")
  sys.stdout = old_stdout
  output = output.getvalue()
  assert '''\
Best matches:
  foo.max
  bar.max
Assuming foo.max was intended.''' in output
  # assume with the same expert levels (same as do not assume)
  master_string = """\
foo {
  min=0
  max=10
    .expert_level = 2
  index=3
  limit=6
}
bar {
  max=5
    .expert_level = 2
  sub {
    limit=8
  }
  flag=None
}
"""
  master_phil = phil.parse(input_string=master_string)
  itpr_neutral = master_phil.command_line_argument_interpreter(assume_when_ambiguous=True)
  try: assert itpr_neutral.process(arg="max=5")
  except Sorry as e:
    assert not show_diff(str(e), """\
Ambiguous parameter definition: max = 5
Best matches:
  foo.max
  bar.max""")
  else: raise Exception_expected

def exercise_choice_multi_plus_support():
  master_phil = libtbx.phil.parse("""\
  u = a b c
    .type = choice(multi=True)
    .optional = False
  """)
  # argument_interpreter used only for convenience
  # (i.e. it is not exercised here)
  cai = master_phil.command_line_argument_interpreter()
  for arg,expected_result in [
        ("u=a", "u = *a b c"),
        ("u=b", "u = a *b c"),
        ("u=c", "u = a b *c"),
        ("u=a+b", "u = *a *b c"),
        ("u=b +c", "u = a *b *c"),
        ("u=a+ c", "u = *a b *c"),
        ("u=a + b +c", "u = *a *b *c"),
        ("u=+a + b +c", "u = *a *b *c"),
        ("u=+a ++ b +c", "u = a b c"),
        ("u=a + b + *c", "u = a b *c"),
        ("u=a + b + *C", "u = a b *c"),
        ("u=a + b + 'c'", "u = a b c")]:
    work_params = master_phil.fetch(source=cai.process(arg=arg))
    assert not show_diff(work_params.as_str(), expected_result+"\n")
  for arg,err in [("u=a+d", "d"), ("u=e + b", "e")]:
    try: master_phil.fetch(source=cai.process(arg=arg))
    except Sorry as e:
      assert not show_diff(str(e), """\
Not a possible choice for u: %s (command line argument, line 1)
  Possible choices are:
    a
    b
    c""" % err)
    else: raise Exception_expected
  for val in ["++a", "a++", "a++b", "a+b+"]:
    try: master_phil.fetch(source=cai.process(arg="u="+val))
    except Sorry as e:
      assert not show_diff(str(e), """\
Not a possible choice for u: %s (command line argument, line 1)
  Possible choices are:
    a
    b
    c""" % val)
    else: raise Exception_expected

def exercise_scope_call():
  try: phil.parse("""\
s
  .call=libtbx.phil.tst.scope_call_none
{
}
""")
  except AttributeError as e:
    assert str(e) == 'scope "s" .call: object "scope_call_none" not found in' \
      ' module "libtbx.phil.tst" (input line 2)'
  else: raise Exception_expected
  #
  try: phil.parse("""\
s
  .call=libtbx.phil.tst.scope_call_not_callable
{
}
""")
  except TypeError as e:
    assert str(e) \
      == 'scope "s" .call: "libtbx.phil.tst.scope_call_not_callable"' \
        ' is not a callable Python object (input line 2)'
  else: raise Exception_expected
  #
  try: phil.parse("""\
s
  .call=libtbx.phil.tst.scope_call_func(
{
}
""")
  except RuntimeError as e:
    assert str(e).startswith(
      'scope "s" .call=libtbx.phil.tst.scope_call_func(: ')
    assert str(e).endswith(' (input line 2)')
  else: raise Exception_expected
  #
  try: phil.parse("""\
s
  .call=libtbx.phil.tst.scope_call_func(a=b=c)
{
}
""")
  except RuntimeError as e:
    assert str(e) == 'scope "s" .call=libtbx.phil.tst.scope_call_func(a=b=c):'\
      ' SyntaxError: invalid syntax (line 1) (input line 2)'
  else: raise Exception_expected
  #
  master = phil.parse("""\
s
  .call=libtbx.phil.tst.scope_call_func
{
}
t
  .call=libtbx.phil.tst.scope_call_func(a =1)
{
}
u
  .call=libtbx.phil.tst.scope_call_func (a= 1 , b=2)
{
}
v
{
}
""")
  assert not show_diff(master.as_str(attributes_level=2), """\
s
  .call = libtbx.phil.tst.scope_call_func
{
}
t
  .call = libtbx.phil.tst.scope_call_func(a=1)
{
}
u
  .call = libtbx.phil.tst.scope_call_func(a=1, b=2)
{
}
v {
}
""")
  params = master.extract()
  c = params.s()
  assert c[0] is params.s
  assert c[1] == {}
  c = params.t()
  assert c[0] is params.t
  assert c[1] == {"a": 1}
  c = params.t(x=3)
  assert c[0] is params.t
  assert c[1] == {"a": 1, "x": 3}
  c = params.t(a=3)
  assert c[0] is params.t
  assert c[1] == {"a": 3}
  c = params.u()
  assert c[0] is params.u
  assert c[1] == {"a": 1, "b": 2}
  c = params.u(x=3)
  assert c[0] is params.u
  assert c[1] == {"a": 1, "b": 2, "x": 3}
  c = params.u(a=3)
  assert c[0] is params.u
  assert c[1] == {"a": 3, "b": 2}
  try: params.u(action="raise")
  except RuntimeError as e:
    assert str(e) \
      == 'scope "u" .call=libtbx.phil.tst.scope_call_func(a=1, b=2)' \
        ' execution: ValueError: action==raise (input line 10)'
  else: raise Exception_expected
  try: params.v()
  except RuntimeError as e:
    assert str(e) == 'scope "v" is not callable.'
  else: raise Exception_expected
  #
  master = phil.parse("""\
s
  .call=libtbx.phil.tst.scope_call_class
{
}
u
  .call = libtbx . phil .tst. scope_call_class ( a = 1 , b = 2 )
{
}
""")
  assert not show_diff(master.as_str(attributes_level=2), """\
s
  .call = libtbx.phil.tst.scope_call_class
{
}
u
  .call = libtbx.phil.tst.scope_call_class(a=1, b=2)
{
}
""")
  params = master.extract()
  c = params.s()
  assert c.scope_extract is params.s
  assert c.keyword_args == {}
  c = params.u(b=3, x=4)
  assert c.scope_extract is params.u
  assert c.keyword_args == {"a": 1, "b": 3, "x": 4}
  #
  master = phil.parse("""\
s
  .call=libtbx.phil.tst.scope_call_class_object
{
}
u
  .call=libtbx.phil.tst.scope_call_class_object(a=1, b=2)
{
}
""")
  assert not show_diff(master.as_str(attributes_level=2), """\
s
  .call = libtbx.phil.tst.scope_call_class_object
{
}
u
  .call = libtbx.phil.tst.scope_call_class_object(a=1, b=2)
{
}
""")
  params = master.extract()
  c = params.s()
  assert c.scope_extract is params.s
  assert c.keyword_args == {}
  c = params.u(a=3, b=4)
  assert c.scope_extract is params.u
  assert c.keyword_args == {"a": 3, "b": 4}

def exercise_deprecation():
  master = phil.parse("""
foo {
  bar = None
    .type = str
}
fubar = None
  .type = str
  .deprecated = True
strategy = *xyz *adp tls
  .type = choice(multi=True)
  .deprecated = True
""")
  class _showwarning(object):
    def __init__(self):
      self.n = 0
      self.message = None

    def __call__(self, message, category, *args, **kwds):
      if (category is phil.PhilDeprecationWarning):
        self.n += 1
        self.message = str(message)
  warn = _showwarning()
  warnings.showwarning = warn.__call__
  w0 = master.fetch()
  out = StringIO()
  w0.show(out=out, attributes_level=2)
  assert (not "fubar" in out.getvalue())
  user1 = phil.parse("""fubar=None""")
  w1 = master.fetch(source=user1)
  out = StringIO()
  w1.show(out=out, attributes_level=3)
  assert (not "fubar" in out.getvalue())
  user2 = phil.parse("""fubar=abcedf""")
  w2 = master.fetch(source=user2)
  assert (warn.n == 1)
  assert (warn.message == 'fubar is deprecated - not recommended for use.')
  out = StringIO()
  w2.show(out=out, attributes_level=3)
  assert ("fubar" in out.getvalue())
  user3 = phil.parse("""strategy=xyz+tls""")
  w2 = master.fetch(source=user3)
  assert (warn.n == 2)
  assert (warn.message == 'strategy is deprecated - not recommended for use.')

scope_call_not_callable = None

def scope_call_func(scope_extract, **keyword_args):
  if (keyword_args.get("action") == "raise"):
    raise ValueError("action==raise")
  return scope_extract, keyword_args

class scope_call_class:
  def __init__(self, scope_extract, **keyword_args):
    self.scope_extract = scope_extract
    self.keyword_args = keyword_args

class scope_call_class_object(object):
  def __init__(self, scope_extract, **keyword_args):
    self.scope_extract = scope_extract
    self.keyword_args = keyword_args

def exercise_find_scope():
  phil_scope = phil.parse("""\
scope1 {
  a = 1
  b = 2
}
scope2 {
  c = 3
  d = 4
}
""")
  scope2 = phil.find_scope(current_phil=phil_scope, scope_name="scope2")
  s = StringIO()
  scope2.show(out=s)
  assert not show_diff(s.getvalue(), """\
scope2 {
  c = 3
  d = 4
}
""")

def exercise_path():
  master = phil.parse("""\
a = None
  .type = path
b = None
  .type = path
c = None
  .type = path
""")
  tilde_path = "~/tmp"
  user = phil.parse("""\
a = %s
b = None
c = Auto
""" %tilde_path)
  phil_scope = master.fetch(source=user)
  params = phil_scope.extract()
  assert not show_diff(params.a, os.path.expanduser(tilde_path))
  assert params.b is None
  assert params.c is Auto

def exercise_adopt_scope():
  master_phil = phil.parse("""\
scope1 {
  a = 1
    .type = int
  b = 2
    .type = int
}
""")
  phil2 = phil.parse("""\
scope1 {
  c = 3
    .type = int
}
""")
  master_phil.adopt_scope(phil2)
  s = StringIO()
  master_phil.show(out=s)
  assert not show_diff(s.getvalue(), """\
scope1 {
  a = 1
  b = 2
  c = 3
}
""")
  phil3 = phil.parse("""
scope2 {
  subscope2 {
    d = 4
      .type = int
  }
}
""")
  master_phil.adopt_scope(phil3)
  s = StringIO()
  master_phil.show(out=s)
  assert not show_diff(s.getvalue(), """\
scope1 {
  a = 1
  b = 2
  c = 3
}
scope2 {
  subscope2 {
    d = 4
  }
}
""")
  phil4 = phil.parse("""\
scope2.subscope2 {
  e = 5
    .type = int
}
""")
  master_phil.adopt_scope(phil4)
  s = StringIO()
  master_phil.show(out=s)
  assert not show_diff(s.getvalue(), """\
scope1 {
  a = 1
  b = 2
  c = 3
}
scope2 {
  subscope2 {
    d = 4
    e = 5
  }
}
""")
  phil5 = phil.parse("""\
scope1 {
  a = 4.123
    .type = float
  f = 6
    .type = int
}
""")
  master_phil.adopt_scope(phil5)
  s = StringIO()
  master_phil.show(out=s)
  assert not show_diff(s.getvalue(), """\
scope1 {
  a = 4.123
  b = 2
  c = 3
  f = 6
}
scope2 {
  subscope2 {
    d = 4
    e = 5
  }
}
""")


def exercise_alias():
  master_phil = phil.parse("""
pdb_interpretation
  .alias = refinement.pdb_interpretation
{
  auto_link = False
    .type = bool
}
geometry_restraints
  .alias = refinement.geometry_restraints
{
 edits {
  excessive_bond_distance_limit = 10
    .type = float
  bond
    .multiple = True
    .optional = True
  {
    distance = None
      .type = float
  }
 }
}
""", process_includes=True)
  geo_phil_new = phil.parse("""
pdb_interpretation {
  auto_link = True
}
geometry_restraints.edits {
  excessive_bond_distance_limit = 5
  bond {
    distance = 1.5
  }
  bond {
    distance = 2.5
  }
}
""")
  geo_phil_old = phil.parse("""
refinement {
  pdb_interpretation {
    auto_link = True
  }
  geometry_restraints.edits {
    excessive_bond_distance_limit = 5
    bond {
      distance = 1.5
    }
    bond {
      distance = 2.5
    }
  }
}
""")

  work_old = master_phil.fetch(source=geo_phil_old)
  work_new = master_phil.fetch(source=geo_phil_new)
  p1 = work_old.extract()
  p2 = work_new.extract()
  assert p2.pdb_interpretation.auto_link == p2.pdb_interpretation.auto_link
  s1 = StringIO()
  s2 = StringIO()
  work_old.show(out=s1)
  work_new.show(out=s2)
  assert (s1.getvalue() == s2.getvalue())
  s = StringIO()
  master_phil.show(attributes_level=1, out=s)
  assert s.getvalue() == """\
pdb_interpretation
  .alias = refinement.pdb_interpretation
{
  auto_link = False
}
geometry_restraints
  .alias = refinement.geometry_restraints
{
  edits {
    excessive_bond_distance_limit = 10
    bond {
      distance = None
    }
  }
}
"""

def exercise_alias_bug():
  # phil scope with .alias attribute
  buggy_phil_str = '''
a
  .alias = prefix.a
{
  enabled = False
  b
  {
    enabled = True
  }
}
'''
  # same phil scope without .alias attribute
  correct_phil_str = '''
a
{
  enabled = False
  b
  {
    enabled = True
  }
}

'''

  for phil_str, result in [(buggy_phil_str, 'a {\n  enabled = True\n}\n'),
                           (correct_phil_str, '')]:
    parsed_phil = phil.parse(phil_str)
    diff = parsed_phil.fetch_diff(parsed_phil).as_str()
    assert (diff == result)

def exercise_change_default():
  # master phil
  master_phil_str = '''
scope {
  name = 'original'
    .type = str
  number = 1234
    .type = int
}
'''
  master_phil_extract = libtbx.phil.parse(master_phil_str).extract()
  assert(master_phil_extract.scope.name == 'original')

  # change to a new valid name
  new_default_str = 'scope.name = "new"'
  new_phil_str = libtbx.phil.change_default_phil_values(
    master_phil_str, new_default_str)
  new_phil_extract = libtbx.phil.parse(new_phil_str).extract()
  assert(new_phil_extract.scope.name == 'new')

  # invalid name
  new_default_str = 'unknown.name = "what"'
  try:
    new_phil_str = libtbx.phil.change_default_phil_values(
      master_phil_str, new_default_str)
  except Sorry as e:
    assert(str(e) ==
           'Unrecognized PHIL parameter(s)\nunknown.name (input line 1)')
  else:
    raise Exception_expected

  # valid name, invalid value
  new_default_str = 'scope.number = "what"'
  try:
    new_phil_str = libtbx.phil.change_default_phil_values(
      master_phil_str, new_default_str)
  except RuntimeError as e:
    assert('Error interpreting scope.number="what"' in str(e))
  else:
    raise Exception_expected

def exercise():
  exercise_alias()
  exercise_alias_bug()
  exercise_adopt_scope()
  exercise_path()
  exercise_find_scope()
  exercise_string_quote_and_tokenize()
  exercise_parse_and_show()
  exercise_import_converters()
  exercise_syntax_errors()
  exercise_phil_on_off_end()
  exercise_deepcopy()
  exercise_get_without_substitution()
  exercise_nested()
  exercise_get_with_substitution()
  exercise_include()
  exercise_full_path()
  exercise_fetch()
  exercise_fetch_diff()
  exercise_extract()
  exercise_format()
  exercise_type_constructors()
  exercise_choice()
  exercise_scope_call()
  exercise_auto()
  exercise_int_and_float()
  exercise_ints_and_floats()
  exercise_definition_validate_etc()
  exercise_command_line()
  exercise_command_line_assume()
  exercise_choice_multi_plus_support()
  exercise_deprecation()
  exercise_change_default()
  print("OK")

if (__name__ == "__main__"):
  exercise()


 *******************************************************************************
