

 *******************************************************************************
mmtbx/refinement/real_space/utils.py
from __future__ import absolute_import, division, print_function
from cctbx import miller
from cctbx import maptbx
import mmtbx.masks

class target_map(object):
  """
  Data structure for real-space refinement. Holds map and its reciprocal-space
  equivalent, and its masked version that can be updated as model changes.
  """
  def __init__(self, map_data, xray_structure, d_min, atom_radius,
         map_manager=None):
    self.d_min = d_min
    self.map_data = map_data
    self.map_manager = map_manager  # XXX switching to map_manager from map_data
    self.atom_radius = atom_radius
    self.f_map_diff = None # XXX rudimentary left-over, remove later
    self.crystal_gridding = maptbx.crystal_gridding( #XXX Likewise, remove later
      unit_cell             = xray_structure.unit_cell(),
      pre_determined_n_real = map_data.all(),
        space_group_info    = xray_structure.space_group_info())
    self.miller_array = None
    while d_min<d_min+10.:
      try:
        self.complete_set = miller.build_set(
          crystal_symmetry = xray_structure.crystal_symmetry(),
          anomalous_flag   = False,
          d_min            = d_min)
        self.miller_array = self.map_to_sf(map_data = self.map_data)
      except: # intentional
        d_min += 0.1
      if(self.miller_array is not None): break
    self.miller_array_masked = self.update_miller_array_masked(
      xray_structure = xray_structure)

  def update_miller_array_masked(self, xray_structure):
    if(xray_structure.crystal_symmetry().space_group().type().number()!=1):
      return None
    mask_params = mmtbx.masks.mask_master_params.extract()
    mask_params.solvent_radius = 0
    mask_params.shrink_truncation_radius = 0
    mask_params.ignore_zero_occupancy_atoms = False
    mask_params.ignore_hydrogens = False
    mmtbx_masks_asu_mask_obj = mmtbx.masks.asu_mask(
      xray_structure = xray_structure,
      n_real         = self.map_data.all(),
      mask_params    = mask_params,
      atom_radius    = self.atom_radius)
    mask = mmtbx_masks_asu_mask_obj.mask_data_whole_uc()
    self.miller_array_masked = self.map_to_sf(map_data = self.map_data*mask)

  def map_to_sf(self, map_data):
    return self.complete_set.structure_factors_from_map(
      map            = map_data,
      use_scale      = True,
      anomalous_flag = False,
      use_sg         = True)


#
# PVA: OSOLETE CODE THAT CONTAINS HISTORORICAL VALUE. NEEDS REVISION BEFORE
# COMPLETE REMOVAL.
#
#
#from __future__ import absolute_import, division, print_function
#import mmtbx.monomer_library.pdb_interpretation
#import iotbx.mtz
#import iotbx.phil, libtbx.phil
#from cctbx import maptbx
#from cctbx import miller
#import cctbx.maptbx.real_space_refinement_simple
#import cctbx.geometry_restraints.flags
#from cctbx.array_family import flex
#import scitbx.rigid_body
#import scitbx.graph.tardy_tree
#import scitbx.lbfgs
#import scitbx.math.superpose
#from scitbx import matrix
#from libtbx.str_utils import show_string
#from libtbx.utils import Sorry, null_out
#from libtbx import Auto, group_args
#import libtbx
#import sys, os
#import mmtbx.rotamer
#op = os.path
#
#def real_space_rigid_body_gradients_simple(
#      unit_cell,
#      density_map,
#      sites_cart_0,
#      center_of_mass,
#      q,
#      unit_quaternion_delta=0.01,
#      translation_delta=0.3):
#  result = flex.double()
#  q_delta = q.deep_copy()
#  def get(i, delta):
#    fs = []
#    for signed_delta in [delta, -delta]:
#      q_delta[i] = q[i] + signed_delta
#      aja = matrix.rt(scitbx.rigid_body.joint_lib_six_dof_aja_simplified(
#        center_of_mass=center_of_mass,
#        q=q_delta))
#      sites_cart_delta = aja * sites_cart_0
#      rs_f = maptbx.real_space_target_simple(
#        unit_cell=unit_cell,
#        density_map=density_map,
#        sites_cart=sites_cart_delta,
#        selection=flex.bool(sites_cart_delta.size(),True))
#      fs.append(rs_f)
#    result.append((fs[0]-fs[1])/(2*delta))
#  for i in range(4): get(i=i, delta=unit_quaternion_delta)
#  for i in range(3): get(i=i+4, delta=translation_delta)
#  return result
#
#class residue_refine_constrained(object):
#
#  def __init__(O,
#        pdb_hierarchy,
#        residue,
#        density_map,
#        geometry_restraints_manager,
#        real_space_target_weight,
#        real_space_gradients_delta,
#        lbfgs_termination_params):
#    O.pdb_hierarchy = pdb_hierarchy
#    O.residue = residue
#    O.density_map = density_map
#    O.geometry_restraints_manager = geometry_restraints_manager
#    O.real_space_gradients_delta = real_space_gradients_delta
#    O.real_space_target_weight = real_space_target_weight
#    #
#    O.unit_cell = geometry_restraints_manager.crystal_symmetry.unit_cell()
#    O.sites_cart_all = pdb_hierarchy.atoms().extract_xyz()
#    O.residue_i_seqs = residue.atoms().extract_i_seq()
#    O.sites_cart_residue_0 = O.sites_cart_all.select(indices=O.residue_i_seqs)
#    O.residue_center_of_mass = O.sites_cart_residue_0.mean()
#    residue_tardy_tree = scitbx.graph.tardy_tree.construct(
#      n_vertices=O.sites_cart_residue_0.size(),
#      edge_list="all_in_one_rigid_body") \
#        .build_tree() \
#        .fix_near_singular_hinges(sites=None)
#    O.residue_tardy_model = scitbx.rigid_body.tardy_model(
#      labels=None,
#      sites=O.sites_cart_residue_0,
#      masses=flex.double(O.sites_cart_residue_0.size(), 1),
#      tardy_tree=residue_tardy_tree,
#      potential_obj=O)
#    O.x = O.residue_tardy_model.pack_q()
#    assert O.x.size() == 7 # other cases not implemented
#    #
#    O.number_of_function_evaluations = -1
#    O.f_start, O.g_start = O.compute_functional_and_gradients()
#    O.rs_f_start = O.rs_f
#    O.minimizer = scitbx.lbfgs.run(
#      target_evaluator=O,
#      termination_params=lbfgs_termination_params)
#    O.f_final, O.g_final = O.compute_functional_and_gradients()
#    O.rs_f_final = O.rs_f
#    del O.rs_f
#    del O.x
#    del O.residue_center_of_mass
#    del O.sites_cart_residue_0
#    del O.residue_i_seqs
#    del O.sites_cart_all
#    del O.unit_cell
#
#  def compute_functional_and_gradients(O):
#    if (O.number_of_function_evaluations == 0):
#      O.number_of_function_evaluations += 1
#      return O.f_start, O.g_start
#    O.number_of_function_evaluations += 1
#    O.residue_tardy_model.unpack_q(q_packed=O.x)
#    O.sites_cart_residue = O.residue_tardy_model.sites_moved()
#    rs_f = maptbx.real_space_target_simple(
#      unit_cell=O.unit_cell,
#      density_map=O.density_map,
#      sites_cart=O.sites_cart_residue,
#      selection=flex.bool(O.sites_cart_residue.size(),True))
#    rs_g = real_space_rigid_body_gradients_simple(
#      unit_cell=O.unit_cell,
#      density_map=O.density_map,
#      sites_cart_0=O.sites_cart_residue_0,
#      center_of_mass=O.residue_center_of_mass,
#      q=O.x)
#    O.rs_f = rs_f
#    rs_f *= -O.real_space_target_weight
#    rs_g *= -O.real_space_target_weight
#    if (O.geometry_restraints_manager is None):
#      f = rs_f
#      g = rs_g
#    else:
#      O.sites_cart_all.set_selected(O.residue_i_seqs, O.sites_cart_residue)
#      gr_e = O.geometry_restraints_manager.energies_sites(
#        sites_cart=O.sites_cart_all, compute_gradients=True)
#      O.__d_e_pot_d_sites = gr_e.gradients.select(indices=O.residue_i_seqs)
#      f = rs_f + gr_e.target
#      g = rs_g + O.residue_tardy_model.d_e_pot_d_q_packed()
#    return f, g.as_double()
#
#  def d_e_pot_d_sites(O, sites_moved):
#    result = O.__d_e_pot_d_sites
#    del O.__d_e_pot_d_sites
#    return result
#
#class residue_refine_restrained(object):
#
#  def __init__(O,
#        pdb_hierarchy,
#        residue,
#        density_map,
#        geometry_restraints_manager,
#        real_space_target_weight,
#        real_space_gradients_delta,
#        lbfgs_termination_params):
#    O.pdb_hierarchy = pdb_hierarchy
#    O.residue = residue
#    O.density_map = density_map
#    O.geometry_restraints_manager = geometry_restraints_manager
#    O.real_space_gradients_delta = real_space_gradients_delta
#    O.real_space_target_weight = real_space_target_weight
#    #
#    O.unit_cell = geometry_restraints_manager.crystal_symmetry.unit_cell()
#    O.sites_cart_all = pdb_hierarchy.atoms().extract_xyz()
#    O.residue_i_seqs = residue.atoms().extract_i_seq()
#    O.x = O.sites_cart_all.select(indices=O.residue_i_seqs).as_double()
#    #
#    O.real_space_target = None
#    O.number_of_function_evaluations = -1
#    O.f_start, O.g_start = O.compute_functional_and_gradients()
#    O.rs_f_start = O.rs_f
#    O.minimizer = scitbx.lbfgs.run(
#      target_evaluator=O,
#      termination_params=lbfgs_termination_params)
#    O.f_final, O.g_final = O.compute_functional_and_gradients()
#    O.rs_f_final = O.rs_f
#    del O.rs_f
#    del O.x
#    del O.residue_i_seqs
#    del O.sites_cart_all
#    del O.unit_cell
#
#  def compute_functional_and_gradients(O):
#    if (O.number_of_function_evaluations == 0):
#      O.number_of_function_evaluations += 1
#      return O.f_start, O.g_start
#    O.number_of_function_evaluations += 1
#    O.sites_cart_residue = flex.vec3_double(O.x)
#    rs_f = maptbx.real_space_target_simple(
#      unit_cell=O.unit_cell,
#      density_map=O.density_map,
#      sites_cart=O.sites_cart_residue,
#      selection=flex.bool(O.sites_cart_residue.size(),True))
#    O.real_space_target = rs_f
#    rs_g = maptbx.real_space_gradients_simple(
#      unit_cell=O.unit_cell,
#      density_map=O.density_map,
#      sites_cart=O.sites_cart_residue,
#      delta=O.real_space_gradients_delta,
#      selection=flex.bool(O.sites_cart_residue.size(),True))
#    O.rs_f = rs_f
#    rs_f *= -O.real_space_target_weight
#    rs_g *= -O.real_space_target_weight
#    if (O.geometry_restraints_manager is None):
#      f = rs_f
#      g = rs_g
#    else:
#      O.sites_cart_all.set_selected(O.residue_i_seqs, O.sites_cart_residue)
#      gr_e = O.geometry_restraints_manager.energies_sites(
#        sites_cart=O.sites_cart_all, compute_gradients=True)
#      f = rs_f + gr_e.target
#      g = rs_g + gr_e.gradients.select(indices=O.residue_i_seqs)
#    return f, g.as_double()
#
#def compute_functional_lite(pdb_hierarchy,
#                            residue,
#                            density_map,
#                            geometry_restraints_manager,
#                            real_space_target_weight):
#  unit_cell = geometry_restraints_manager.crystal_symmetry.unit_cell()
#  sites_cart_all = pdb_hierarchy.atoms().extract_xyz()
#  residue_i_seqs = residue.atoms().extract_i_seq()
#  x = sites_cart_all.select(indices=residue_i_seqs).as_double()
#  sites_cart_residue = flex.vec3_double(x)
#  rs_f = maptbx.real_space_target_simple(
#    unit_cell=unit_cell,
#    density_map=density_map,
#    sites_cart=sites_cart_residue,
#    selection=flex.bool(sites_cart_residue.size(),True))
#  return rs_f
#
#def rotamer_score_and_choose_best(
#      mon_lib_srv,
#      density_map,
#      pdb_hierarchy,
#      geometry_restraints_manager,
#      atom_selection_bool,
#      real_space_target_weight,
#      real_space_gradients_delta,
#      lbfgs_termination_params,
#      force_rotamer=False):
#  n_other_residues = 0
#  n_amino_acids_ignored = 0
#  n_amino_acids_scored = 0
#  get_class = iotbx.pdb.common_residue_names_get_class
#  def refine_constrained():
#    refined = residue_refine_constrained(
#      pdb_hierarchy=pdb_hierarchy,
#      residue=residue,
#      density_map=density_map,
#      geometry_restraints_manager=geometry_restraints_manager,
#      real_space_target_weight=real_space_target_weight,
#      real_space_gradients_delta=real_space_gradients_delta,
#      lbfgs_termination_params=lbfgs_termination_params)
#    print residue.id_str(), "constr. refined(%s): %.6g -> %.6g" % (
#      rotamer_id, refined.rs_f_start, refined.rs_f_final)
#    return refined
#  def refine_restrained():
#    refined = residue_refine_restrained(
#      pdb_hierarchy=pdb_hierarchy,
#      residue=residue,
#      density_map=density_map,
#      geometry_restraints_manager=geometry_restraints_manager,
#      real_space_target_weight=real_space_target_weight,
#      real_space_gradients_delta=real_space_gradients_delta,
#      lbfgs_termination_params=lbfgs_termination_params)
#    print residue.id_str(), "restr. refined(%s): %.6g -> %.6g" % (
#      rotamer_id, refined.rs_f_start, refined.rs_f_final)
#    return refined
#  def refine():
#    residue.atoms().set_xyz(new_xyz=refine_constrained().sites_cart_residue)
#    return refine_restrained()
#  for model in pdb_hierarchy.models():
#    for chain in model.chains():
#      for residue in chain.only_conformer().residues():
#        if (get_class(residue.resname) != "common_amino_acid"):
#          n_other_residues += 1
#        else:
#          rotamer_iterator = mmtbx.rotamer.iterator(
#            mon_lib_srv=mon_lib_srv,
#            residue=residue,
#            atom_selection_bool=atom_selection_bool)
#          if (rotamer_iterator is None):
#            n_amino_acids_ignored += 1
#          else:
#            best = None
#            rotamer_id = "as_given"
#            if not force_rotamer:
#              best = group_args(rotamer_id=rotamer_id, refined=refine())
#            n_amino_acids_scored += 1
#            for rotamer,rotamer_sites_cart in rotamer_iterator:
#              residue.atoms().set_xyz(new_xyz=rotamer_sites_cart)
#              rotamer_id=rotamer.id
#              trial = group_args(rotamer_id=rotamer.id, refined=refine())
#              if best is None:
#                best = trial
#              if (trial.refined.rs_f_final > best.refined.rs_f_final):
#                best = trial
#            print residue.id_str(), "best rotamer:", best.rotamer_id
#            residue.atoms().set_xyz(new_xyz=best.refined.sites_cart_residue)
#            print
#
#  print "number of amino acid residues scored:", n_amino_acids_scored
#  print "number of amino acid residues ignored:", n_amino_acids_ignored
#  print "number of other residues:", n_other_residues
#  print
#  sys.stdout.flush()
#
#def get_best_rotamer(processed_pdb_file,
#                     fft_map,
#                     d_max,
#                     d_min):
#  master_phil = get_master_phil()
#  work_params = master_phil.extract()
#  get_class = iotbx.pdb.common_residue_names_get_class
#  mon_lib_srv = mmtbx.monomer_library.server.server()
#  grm = processed_pdb_file.geometry_restraints_manager(
#    params_edits=work_params.geometry_restraints.edits,
#    params_remove=work_params.geometry_restraints.remove)
#  density_map = fft_map.real_map()
#  atom_selection_bool=get_atom_selection_bool(
#        scope_extract=work_params.rotamer_score_and_choose_best,
#        attr="atom_selection",
#        processed_pdb_file=processed_pdb_file,
#        work_params=work_params)
#  n_other_residues = 0
#  n_amino_acids_ignored = 0
#  n_amino_acids_scored = 0
#  pdb_hierarchy = processed_pdb_file.all_chain_proxies.pdb_hierarchy
#  for model in pdb_hierarchy.models():
#    for chain in model.chains():
#      for residue in chain.only_conformer().residues():
#        if (get_class(residue.resname) != "common_amino_acid"):
#          n_other_residues += 1
#        else:
#          rotamer_iterator = mmtbx.rotamer.iterator(
#            mon_lib_srv=mon_lib_srv,
#            residue=residue,
#            atom_selection_bool=atom_selection_bool)
#          if (rotamer_iterator is None):
#            n_amino_acids_ignored += 1
#          else:
#            best = None
#            best_sites_cart = None
#            n_amino_acids_scored += 1
#            for rotamer,rotamer_sites_cart in rotamer_iterator:
#              residue.atoms().set_xyz(new_xyz=rotamer_sites_cart)
#              trial = group_args(rotamer_id=rotamer.id,
#                                 rs_f=compute_functional_lite(
#                pdb_hierarchy=pdb_hierarchy,
#                residue=residue,
#                density_map=density_map,
#                geometry_restraints_manager=grm,
#                real_space_target_weight=work_params.real_space_target_weight))
#              #print residue.id_str(),trial.rotamer_id, trial.rs_f
#              if best is None:
#                best = trial
#                best_sites_cart = rotamer_sites_cart
#              if (trial.rs_f > best.rs_f):
#                best = trial
#                best_sites_cart = rotamer_sites_cart
#            print residue.id_str(), "best rotamer:", best.rotamer_id
#            residue.atoms().set_xyz(new_xyz=best_sites_cart)
#            #print
#
#real_space_params_phil_str = """\
#real_space_target_weight = 10
#  .type = float
#real_space_gradients_delta_resolution_factor = 1/3
#  .type = float
#"""
#
#coordinate_refinement_export_phil_str = """\
#finishing_geometry_minimization
#{
#  cycles_max = 100
#    .type = int
#  first_weight_scale = 0.1
#    .type = float
#  cycle_weight_multiplier = 1.0
#    .type = float
#  superpose_cycle_end_with_cycle_start = False
#    .type = bool
#  dihedral_restraints = False
#    .type = bool
#  output_file = Auto
#    .type = str
#}
#real_space_target_weights {
#  first_sample = 10
#    .type = float
#  sampling_step = 30
#    .type = float
#  number_of_samples = 10
#    .type = int
#  bond_rmsd_target = 0.03
#    .type = float
#  worst_acceptable_bond_rmsd {
#    pool_size = 10
#      .type = int
#    max_pool_average = 0.1
#      .type = float
#  }
#}
#lbfgs_max_iterations = 500
#  .type = int
#"""
#
#coordinate_refinement_params_phil_str = """\
#coordinate_refinement {
#  run = False
#    .type = bool
#  atom_selection = Auto
#    .type = str
#  compute_final_correlation = True
#    .type = bool
#  home_restraints
#    .multiple = True
#  {
#    selection = None
#      .type = str
#    sigma = 0.05
#      .type = float
#    slack = 0
#      .type = float
#  }
#  %(coordinate_refinement_export_phil_str)s
#}
#""" % vars()
#
#def get_master_phil():
#  return iotbx.phil.parse(
#    input_string="""\
#atom_selection = None
#  .type = str
#strict_processing = True
#  .type = bool
#
#map {
#  coeff_labels {
#    f = 2FOFCWT,PH2FOFCWT
#      .type = str
#    phases = None
#      .type = str
#    weights = None
#      .type = str
#  }
#  std_dev_weight_coeff_labels {
#    f = None
#      .type = str
#    phases = None
#      .type = str
#    weights = None
#      .type = str
#  }
#  low_resolution = None
#    .type = float
#  high_resolution = None
#    .type = float
#  grid_resolution_factor = 1/3
#    .type = float
#}
#
#output_file = Auto
#  .type = str
#final_geo_file = Auto
#  .type = str
#
#%s
#local_standard_deviations_radius = None
#  .type = float
#weight_map_normalization = *fourier sigma
#  .type = choice
#weight_map_scale_factor = None
#  .type = float
#
#%s
#
#rotamer_score_and_choose_best {
#  run = False
#    .type = bool
#  atom_selection = Auto
#    .type = str
#  lbfgs_max_iterations = 50
#    .type = int
#  output_file = Auto
#    .type = str
#}
#
#include scope mmtbx.monomer_library.pdb_interpretation.grand_master_phil_str
#""" % (real_space_params_phil_str, coordinate_refinement_params_phil_str),
#    process_includes=True)
#
#def extract_map_coeffs(params, optional, miller_arrays):
#  def find(labels):
#    for miller_array in miller_arrays:
#      if (",".join(miller_array.info().labels) == labels):
#        return miller_array
#    matching_array = None
#    for miller_array in miller_arrays:
#      if (",".join(miller_array.info().labels).lower() == labels.lower()):
#        if (matching_array is not None):
#          return None
#        matching_array = miller_array
#    return matching_array
#  def raise_sorry(msg_intro, name):
#    msg = [
#      msg_intro,
#      "  %s = %s" % params.__phil_path_and_value__(object_name=name),
#      "  List of available labels:"]
#    for miller_array in miller_arrays:
#      msg.append("    %s" % ",".join(miller_array.info().labels))
#    raise Sorry("\n".join(msg))
#  if (params.f is None):
#    if (not optional):
#      raise_sorry(msg_intro="Missing assignment:", name="f")
#    return None
#  f = find(labels=params.f)
#  if (f is None):
#    raise_sorry(msg_intro="Cannot find map coefficients:", name="f")
#  if (not f.is_complex_array() or params.phases is not None):
#    if (params.phases is None):
#      raise_sorry(msg_intro="Missing assignment:", name="phases")
#    phases = find(labels=params.phases)
#    if (phases is None):
#      raise_sorry(
#        msg_intro="Cannot find map coefficient phases:", name="phases")
#    if (phases.is_hendrickson_lattman_array()
#          and phases.data().all_eq((0,0,0,0))):
#      raise Sorry(
#        "All Hendrickson-Lattman coefficient zero:\n"
#        "  %s = %s" % params.__phil_path_and_value__(object_name="phases"))
#    cf, cp = f.common_sets(other=phases)
#    if (cf.indices().size() != f.indices().size()):
#      raise Sorry(
#        "Number of missing map coefficient phases: %d" % (
#          f.indices().size() - cf.indices().size()))
#    f = cf.phase_transfer(phase_source=cp, deg=True)
#  if (params.weights is not None):
#    weights = find(labels=params.weights)
#    if (weights is None):
#      raise_sorry(
#        msg_intro="Cannot find map coefficient weights:",
#        name="weights")
#    cf, cw = f.common_sets(other=weights)
#    if (cf.indices().size() != f.indices().size()):
#      raise Sorry(
#        "Number of missing map coefficient weights: %d" % (
#          f.indices().size() - cf.indices().size()))
#    f = cf.customized_copy(data=cw.data()*cf.data())
#  return f
#
#class home_restraints(object):
#
#  __slots__ = ["iselection", "weight", "slack"]
#
#  def __init__(O, iselection, weight, slack):
#    O.iselection = iselection
#    O.weight = weight
#    O.slack = slack
#
#def process_home_restraints_params(work_params, processed_pdb_file):
#  result = []
#  for params in work_params:
#    sigma = params.sigma
#    if (sigma is None or sigma <= 0):
#      continue
#    bsel = processed_pdb_file.all_chain_proxies.phil_atom_selection(
#      cache=None,
#      scope_extract=params,
#      attr="selection",
#      allow_none=True,
#      allow_auto=False)
#    if (bsel is not None):
#      slack = params.slack
#      if (slack is None or slack <= 0):
#        slack = 0
#      result.append(home_restraints(
#        iselection=bsel.iselection(), weight=1/sigma**2, slack=slack))
#  return result
#
#class geometry_restraints_manager_plus(object):
#
#  __slots__ = [
#    "manager",
#    "home_sites_cart",
#    "home_restraints_list",
#    "home_dihedral_proxies",
#    "crystal_symmetry",
#    "pair_proxies",
#    "angle_proxies",
#    "dihedral_proxies",
#    "site_symmetry_table",
#    "plain_pair_sym_table",
#    "plain_pairs_radius"]
#
#  def __init__(O,
#               manager,
#               home_sites_cart=None,
#               home_restraints_list=None,
#               home_dihedral_proxies=None):
#    O.manager = manager
#    #O.sites_cart = sites_cart
#    O.home_sites_cart = home_sites_cart
#    O.home_restraints_list = home_restraints_list
#    O.home_dihedral_proxies = home_dihedral_proxies
#    O.crystal_symmetry = manager.crystal_symmetry
#    O.pair_proxies = manager.pair_proxies
#    O.angle_proxies = manager.angle_proxies
#    O.dihedral_proxies = manager.dihedral_proxies
#    O.site_symmetry_table = manager.site_symmetry_table
#    O.plain_pair_sym_table = manager.plain_pair_sym_table
#    O.plain_pairs_radius = manager.plain_pairs_radius
#
#  def energies_add(O, energies_obj):
#    if (O.manager.site_symmetry_table is not None):
#      site_symmetry_table_indices = O.manager.site_symmetry_table.indices()
#    else:
#      site_symmetry_table_indices = None
#    from cctbx.geometry_restraints import bond
#    n_restraints = 0
#    r_sum = 0
#    hr_summation = cctbx.geometry_restraints \
#      .home_restraints_summation_skip_special_positions
#    for hr in O.home_restraints_list:
#      r_sum += hr_summation(
#        sites_cart=energies_obj.sites_cart,
#        gradients=energies_obj.gradients,
#        site_symmetry_table_indices=site_symmetry_table_indices,
#        home_sites_cart=O.home_sites_cart,
#        iselection=hr.iselection,
#        weight=hr.weight,
#        slack=hr.slack)
#      n_restraints += hr.iselection.size()
#    energies_obj.n_home_restraints = n_restraints
#    energies_obj.home_restraints_residual_sum = r_sum
#    energies_obj.number_of_restraints += n_restraints
#    energies_obj.residual_sum += r_sum
#    r_sum=cctbx.geometry_restraints.dihedral_residual_sum(
#      sites_cart=energies_obj.sites_cart,
#      proxies=O.home_dihedral_proxies,
#      gradient_array=energies_obj.gradients)
#    if O.home_dihedral_proxies is not None:
#      n_restraints = len(O.home_dihedral_proxies)
#    else:
#      n_restraints = 0
#    energies_obj.n_dihedral_restraints = n_restraints
#    energies_obj.dihedral_restraints_residual_sum = r_sum
#    energies_obj.residual_sum += r_sum
#    energies_obj.number_of_restraints += n_restraints
#
#  def energies_show(O, energies_obj, f, prefix):
#    print >> f, prefix+"  home_restraints_residual_sum (n=%d): %.6g" % (
#      energies_obj.n_home_restraints,
#      energies_obj.home_restraints_residual_sum)
#
#  def dihedral_energies_show(O, energies_obj, f, prefix):
#    print >> f, prefix+"  dihedral_restraints_residual_sum (n=%d): %.6g" % (
#      energies_obj.n_dihedral_restraints,
#      energies_obj.dihedral_restraints_residual_sum)
#
#  def energies_sites(O,
#        sites_cart,
#        flags=None,
#        custom_nonbonded_function=None,
#        compute_gradients=False,
#        gradients=None,
#        disable_asu_cache=False,
#        normalization=False):
#    return O.manager.energies_sites(
#      sites_cart=sites_cart,
#      flags=flags,
#      custom_nonbonded_function=custom_nonbonded_function,
#      compute_gradients=compute_gradients,
#      gradients=gradients,
#      disable_asu_cache=disable_asu_cache,
#      normalization=normalization,
#      extension_objects=[O])
#
#  def show_sorted(O,
#        flags=None,
#        sites_cart=None,
#        site_labels=None,
#        f=None):
#    return O.manager.show_sorted(
#      flags=flags,
#      sites_cart=sites_cart,
#      site_labels=site_labels,
#      f=f)
#
#  def select(O, selection=None, iselection=None):
#    return O.manager.select(selection=selection, iselection=iselection)
#
#def fit_rotamers_simple(processed_pdb_file,
#                        fft_map,
#                        d_max,
#                        d_min):
#  master_phil = get_master_phil()
#  work_params = master_phil.extract()
#  mon_lib_srv = mmtbx.monomer_library.server.server()
#  #ener_lib = mmtbx.monomer_library.server.ener_lib()
#  grm = processed_pdb_file.geometry_restraints_manager(
#    params_edits=work_params.geometry_restraints.edits,
#    params_remove=work_params.geometry_restraints.remove)
#  density_map = fft_map.real_map()
#  real_space_gradients_delta = \
#    d_min * work_params.real_space_gradients_delta_resolution_factor
#  rotamer_score_and_choose_best(
#      mon_lib_srv=mon_lib_srv,
#      density_map=density_map,
#      pdb_hierarchy=processed_pdb_file.all_chain_proxies.pdb_hierarchy,
#      geometry_restraints_manager=grm,
#      atom_selection_bool=get_atom_selection_bool(
#        scope_extract=work_params.rotamer_score_and_choose_best,
#        attr="atom_selection",
#        processed_pdb_file=processed_pdb_file,
#        work_params=work_params),
#      real_space_target_weight=work_params.real_space_target_weight,
#      real_space_gradients_delta=real_space_gradients_delta,
#      lbfgs_termination_params=scitbx.lbfgs.termination_parameters(
#        max_iterations=work_params
#          .rotamer_score_and_choose_best.lbfgs_max_iterations),
#      force_rotamer=True)
#
#def get_atom_selection_bool(scope_extract,
#                            attr,
#                            processed_pdb_file,
#                            work_params):
#  common_atom_selection_bool_cache=[]
#  result = processed_pdb_file.all_chain_proxies \
#    .phil_atom_selection(
#      cache=None,
#      scope_extract=scope_extract,
#      attr="atom_selection",
#      allow_none=True,
#      allow_auto=True)
#  if (result is None or result is not Auto):
#    return result
#  if (len(common_atom_selection_bool_cache) == 0):
#    common_atom_selection_bool_cache.append(
#      processed_pdb_file.all_chain_proxies
#        .phil_atom_selection(
#          cache=None,
#          scope_extract=work_params,
#          attr="atom_selection",
#          allow_none=True))
#  return common_atom_selection_bool_cache[0]
#
#def compose_output_file_name(input_pdb_file_name, new_suffix):
#  result = op.basename(input_pdb_file_name)
#  if (   result.endswith(".pdb")
#      or result.endswith(".ent")):
#    result = result[:-4]
#  result += new_suffix
#  return result
#
#def write_pdb(
#      file_name,
#      input_pdb_file_name,
#      processed_pdb_file,
#      grm,
#      new_suffix):
#  if (file_name is not None):
#    if (file_name is Auto):
#      file_name = compose_output_file_name(
#        input_pdb_file_name=input_pdb_file_name,
#        new_suffix=new_suffix)
#    pdb_hierarchy = processed_pdb_file.all_chain_proxies.pdb_hierarchy
#    print "Writing file: %s" % show_string(file_name)
#    sys.stdout.flush()
#    pdb_hierarchy.write_pdb_file(
#      file_name=file_name,
#      crystal_symmetry=grm.crystal_symmetry)
#    print
#
#def run_coordinate_refinement_driver(
#      processed_pdb_file,
#      geometry_restraints_manager,
#      fft_map,
#      real_space_gradients_delta,
#      work_params,
#      std_dev_weight_fft_map=None,
#      write_pdb_callback=None,
#      log=None):
#  if (log is None): log = null_out()
#  atom_selection_bool = get_atom_selection_bool(
#    scope_extract=work_params.coordinate_refinement,
#    attr="atom_selection",
#    processed_pdb_file=processed_pdb_file,
#    work_params=work_params)
#  home_restraints_list = process_home_restraints_params(
#    work_params=work_params.coordinate_refinement.home_restraints,
#    processed_pdb_file=processed_pdb_file)
#  if (not work_params.coordinate_refinement.compute_final_correlation):
#    work_scatterers = None
#  else:
#    work_scatterers = processed_pdb_file.xray_structure(
#      show_summary=False).scatterers()
#    if (atom_selection_bool is None):
#      work_scatterers = work_scatterers.deep_copy()
#    else:
#      work_scatterers = work_scatterers.select(atom_selection_bool)
#  if (std_dev_weight_fft_map is None):
#    weight_map = None
#  else:
#    assert std_dev_weight_fft_map.n_real() == fft_map.n_real()
#    weight_map = std_dev_weight_fft_map.real_map()
#  return run_coordinate_refinement(
#    pdb_atoms=processed_pdb_file.all_chain_proxies.pdb_atoms,
#    geometry_restraints_manager=geometry_restraints_manager,
#    selection_variable=atom_selection_bool,
#    density_map=fft_map.real_map(),
#    real_space_gradients_delta=real_space_gradients_delta,
#    work_params=work_params,
#    home_restraints_list=home_restraints_list,
#    work_scatterers=work_scatterers,
#    unit_cell=fft_map.unit_cell(),
#    d_min=fft_map.d_min(),
#    weight_map=weight_map,
#    write_pdb_callback=write_pdb_callback,
#    log=log)
#
#def run_coordinate_refinement(
#      geometry_restraints_manager,
#      selection_variable,
#      density_map,
#      real_space_gradients_delta,
#      work_params,
#      pdb_atoms=None,
#      sites_cart=None,
#      home_restraints_list=[],
#      work_scatterers=None,
#      unit_cell=None,
#      d_min=None,
#      weight_map=None,
#      write_pdb_callback=None,
#      log=None):
#  assert [pdb_atoms, sites_cart].count(None)==1
#  if (log is None): log = null_out()
#  if (work_scatterers is not None):
#    assert unit_cell is not None
#    assert d_min is not None
#  best_info = None
#  if (pdb_atoms is not None):
#    sites_cart_start = pdb_atoms.extract_xyz()
#    site_labels = [atom.id_str() for atom in pdb_atoms]
#  else:
#    sites_cart_start = sites_cart
#    site_labels = None
#  grmp = geometry_restraints_manager_plus(
#    manager=geometry_restraints_manager,
#    home_sites_cart=sites_cart_start,
#    home_restraints_list=home_restraints_list)
#  print >> log, "Before coordinate refinement:"
#  grmp.energies_sites(sites_cart=sites_cart_start).show(f=log)
#  print >> log
#  log.flush()
#  rstw_params = work_params.coordinate_refinement.real_space_target_weights
#  if (rstw_params.number_of_samples is None):
#    rstw_list = [work_params.real_space_target_weight]
#  else:
#    rstw_list = [rstw_params.first_sample + i * rstw_params.sampling_step
#      for i in range(rstw_params.number_of_samples)]
#  lbfgs_termination_params = scitbx.lbfgs.termination_parameters(
#    max_iterations=work_params.coordinate_refinement
#      .lbfgs_max_iterations)
#  lbfgs_exception_handling_params = \
#    scitbx.lbfgs.exception_handling_parameters(
#      ignore_line_search_failed_step_at_lower_bound=True)
#  bond_rmsd_list = []
#  for rstw in rstw_list:
#    refined = maptbx.real_space_refinement_simple.lbfgs(
#      sites_cart=sites_cart_start,
#      density_map=density_map,
#      weight_map=weight_map,
#      selection_variable=selection_variable,
#      geometry_restraints_manager=grmp,
#      real_space_target_weight=rstw,
#      real_space_gradients_delta=real_space_gradients_delta,
#      local_standard_deviations_radius=
#        work_params.local_standard_deviations_radius,
#      weight_map_scale_factor=work_params.weight_map_scale_factor,
#      lbfgs_termination_params=lbfgs_termination_params,
#      lbfgs_exception_handling_params=lbfgs_exception_handling_params)
#    print >> log, "After coordinate refinement" \
#      " with real-space target weight %.1f:" % rstw
#    grmp.energies_sites(sites_cart=refined.sites_cart).show(f=log)
#    bond_proxies = grmp.pair_proxies().bond_proxies
#    bond_proxies.show_sorted(
#      by_value="residual",
#      sites_cart=refined.sites_cart,
#      site_labels=site_labels,
#      f=log,
#      prefix="  ",
#      max_items=3)
#    print >> log
#    print >> log, "  number_of_function_evaluations:", \
#      refined.number_of_function_evaluations
#    print >> log, "  real+geo target start: %.6g" % refined.f_start
#    print >> log, "  real+geo target final: %.6g" % refined.f_final
#    deltas = bond_proxies.deltas(sites_cart=refined.sites_cart)
#    deltas_abs = flex.abs(deltas)
#    deltas_abs_sorted = deltas_abs.select(
#      flex.sort_permutation(deltas_abs), reverse=True)
#    wabr_params = rstw_params.worst_acceptable_bond_rmsd
#    acceptable = (
#      flex.mean_default(deltas_abs_sorted[:wabr_params.pool_size],0)
#        < wabr_params.max_pool_average)
#    if(deltas.size()>0):
#      bond_rmsd = flex.mean_sq(deltas)**0.5
#    else: bond_rmsd=0
#    bond_rmsd_list.append(bond_rmsd)
#    print >> log, "  Bond RMSD: %.3f" % bond_rmsd
#    #
#    if (work_scatterers is None):
#      region_cc = None
#    else:
#      region_cc = maptbx.region_density_correlation(
#        large_unit_cell=unit_cell,
#        large_d_min=d_min,
#        large_density_map=density_map,
#        sites_cart=refined.sites_cart_variable,
#        site_radii=flex.double(refined.sites_cart_variable.size(), 1),
#        work_scatterers=work_scatterers)
#    #
#    rmsd_diff = abs(rstw_params.bond_rmsd_target - bond_rmsd)
#    if (   best_info is None
#        or best_info.rmsd_diff > rmsd_diff
#          and (acceptable or not best_info.acceptable)):
#      best_info = group_args(
#        rstw=rstw,
#        refined=refined,
#        acceptable=acceptable,
#        rmsd_diff=rmsd_diff,
#        region_cc=region_cc,
#        sites_cart=refined.sites_cart)
#    print >> log
#  if (best_info is not None):
#    print >> log, "Table of real-space target weights vs. bond RMSD:"
#    print >> log, "  weight   RMSD"
#    for w,d in zip(rstw_list, bond_rmsd_list):
#      print >> log, "  %6.1f  %5.3f" % (w,d)
#    print >> log, "Best real-space target weight: %.1f" % best_info.rstw
#    print >> log, \
#      "Associated refined final value: %.6g" % best_info.refined.f_final
#    if (best_info.region_cc is not None):
#      print >> log, "Associated region correlation: %.4f" % best_info.region_cc
#    print >> log
#    if (pdb_atoms is not None):
#      pdb_atoms.set_xyz(new_xyz=refined.sites_cart)
#    if (write_pdb_callback is not None):
#      write_pdb_callback(situation="after_best_weight_determination")
#    #
#    fgm_params = work_params.coordinate_refinement \
#      .finishing_geometry_minimization
#    if (fgm_params.cycles_max is not None and fgm_params.cycles_max > 0):
#      print >> log, "As previously obtained with target weight %.1f:" \
#        % best_info.rstw
#      grmp.energies_sites(sites_cart=refined.sites_cart).show(
#        f=log, prefix="  ")
#      print >> log, "Finishing refinement to idealize geometry:"
#      print >> log, "            number of function"
#      print >> log, "    weight     evaluations      cycle RMSD"
#      number_of_fgm_cycles = 0
#      rstw = best_info.rstw * fgm_params.first_weight_scale
#      sites_cart_start = best_info.refined.sites_cart.deep_copy()
#      for i_cycle in range(fgm_params.cycles_max):
#        fgm_refined = maptbx.real_space_refinement_simple.lbfgs(
#          sites_cart=sites_cart_start,
#          density_map=density_map,
#          selection_variable=selection_variable,
#          geometry_restraints_manager=grmp,
#          energies_sites_flags=cctbx.geometry_restraints.flags.flags(
#            default=True, dihedral=fgm_params.dihedral_restraints),
#          real_space_target_weight=rstw,
#          real_space_gradients_delta=real_space_gradients_delta,
#          local_standard_deviations_radius=
#            work_params.local_standard_deviations_radius,
#          weight_map_scale_factor=work_params.weight_map_scale_factor,
#          lbfgs_termination_params=lbfgs_termination_params,
#          lbfgs_exception_handling_params=lbfgs_exception_handling_params)
#        cycle_rmsd = sites_cart_start.rms_difference(fgm_refined.sites_cart)
#        print >> log, "   %6.1f     %10d          %6.3f" % (
#          rstw, fgm_refined.number_of_function_evaluations, cycle_rmsd)
#        number_of_fgm_cycles += 1
#        rstw *= fgm_params.cycle_weight_multiplier
#        if (cycle_rmsd < 1.e-4):
#          break
#        if (fgm_params.superpose_cycle_end_with_cycle_start):
#          fit = scitbx.math.superpose.least_squares_fit(
#            reference_sites=best_info.refined.sites_cart,
#            other_sites=fgm_refined.sites_cart)
#          fgm_refined.sites_cart = fit.other_sites_best_fit()
#        sites_cart_start = fgm_refined.sites_cart.deep_copy()
#      print >> log, "After %d refinements to idealize geometry:" % (
#        number_of_fgm_cycles)
#      grmp.energies_sites(sites_cart=fgm_refined.sites_cart).show(
#        f=log, prefix="  ")
#      if (work_scatterers is None):
#        fgm_region_cc = None
#      else:
#        fgm_region_cc = maptbx.region_density_correlation(
#          large_unit_cell=unit_cell,
#          large_d_min=d_min,
#          large_density_map=density_map,
#          sites_cart=fgm_refined.sites_cart_variable,
#          site_radii=flex.double(fgm_refined.sites_cart_variable.size(), 1),
#          work_scatterers=work_scatterers)
#        print >> log, "  Associated region correlation: %.4f" % fgm_region_cc
#      print >> log
#      best_info.fgm_refined = fgm_refined
#      best_info.fgm_region_cc = fgm_region_cc
#      if (pdb_atoms is not None):
#        pdb_atoms.set_xyz(new_xyz=fgm_refined.sites_cart)
#      best_info.sites_cart = fgm_refined.sites_cart
#      if (write_pdb_callback is not None):
#        write_pdb_callback(situation="after_finishing_geo_min")
#    else:
#      best_info.fgm_refined = None
#      best_info.fgm_region_cc = None
#  return best_info
#
#def run(args,log=None):
#  if log is None:
#    log = sys.stdout
#
#  show_times = libtbx.utils.show_times(time_start="now")
#  master_phil = get_master_phil()
#  import iotbx.utils
#  input_objects = iotbx.utils.process_command_line_inputs(
#    args=args,
#    master_phil=master_phil,
#    input_types=("mtz", "pdb", "cif"))
#  work_phil = master_phil.fetch(sources=input_objects["phil"])
#  work_phil.show()
#  print >> log
#  print >> log, "#phil __OFF__"
#  print >> log
#  work_params = work_phil.extract()
#  #
#  assert len(input_objects["mtz"]) == 1
#  miller_arrays = input_objects["mtz"][0].file_content.as_miller_arrays()
#  map_coeffs = extract_map_coeffs(
#    miller_arrays=miller_arrays,
#    params=work_params.map.coeff_labels,
#    optional=False)
#  std_dev_weight_coeffs = extract_map_coeffs(
#    miller_arrays=miller_arrays,
#    params=work_params.map.std_dev_weight_coeff_labels,
#    optional=True)
#  del miller_arrays
#  #
#  mon_lib_srv = mmtbx.monomer_library.server.server()
#  ener_lib = mmtbx.monomer_library.server.ener_lib()
#  for file_obj in input_objects["cif"]:
#    print >> log, "Processing CIF file: %s" % show_string(file_obj.file_name)
#    for srv in [mon_lib_srv, ener_lib]:
#      srv.process_cif_object(
#        cif_object=file_obj.file_content,
#        file_name=file_obj.file_name)
#  if (len(input_objects["cif"]) != 0):
#    print >> log
#  #
#  assert len(input_objects["pdb"]) == 1 # TODO not implemented
#  file_obj = input_objects["pdb"][0]
#  input_pdb_file_name = file_obj.file_name
#  print >> log, "Crystal symmetry (from map file):"
#  map_coeffs.crystal_symmetry().show_summary(prefix="  ")
#  pdb_crystal_symmetry = file_obj.file_content.crystal_symmetry()
#  if (    pdb_crystal_symmetry is not None
#      and not pdb_crystal_symmetry.is_similar_symmetry(
#            map_coeffs.crystal_symmetry())):
#    print >>log, "  NOTE: Crystal symmetry from PDB file is different:"
#    pdb_crystal_symmetry.show_summary(prefix="    Ignored: ")
#  print >> log
#  processed_pdb_file = mmtbx.monomer_library.pdb_interpretation.process(
#    mon_lib_srv=mon_lib_srv,
#    ener_lib=ener_lib,
#    params=work_params.pdb_interpretation,
#    file_name=file_obj.file_name,
#    pdb_inp=file_obj.file_content,
#    strict_conflict_handling=work_params.strict_processing,
#    substitute_non_crystallographic_unit_cell_if_necessary=True,
#    crystal_symmetry=map_coeffs.crystal_symmetry(),
#    force_symmetry=True,
#    log=sys.stdout)
#  if (work_params.strict_processing):
#    msg = processed_pdb_file.all_chain_proxies.fatal_problems_message()
#    if (msg is not None):
#      raise Sorry(msg)
#  #
#  grm = processed_pdb_file.geometry_restraints_manager(
#    params_edits=work_params.geometry_restraints.edits,
#    params_remove=work_params.geometry_restraints.remove)
#  print >> log
#  sys.stdout.flush()
#  #
#  def show_completeness(annotation):
#    print >>log, "Completeness of %s map coefficients:" % annotation
#    map_coeffs.setup_binner(auto_binning=True)
#    if (map_coeffs.binner().n_bins_used() > 12):
#      map_coeffs.setup_binner(n_bins=12)
#    map_coeffs.completeness(use_binning=True).show(prefix="  ")
#    print >> log
#    sys.stdout.flush()
#  show_completeness("input")
#  map_coeffs_input = map_coeffs
#  #
#  low_res = work_params.map.low_resolution
#  high_res = work_params.map.high_resolution
#  d_max, d_min = map_coeffs.d_max_min()
#  d_max_apply, d_min_apply = None, None
#  if (low_res is not None and low_res < d_max):
#    d_max_apply = low_res
#    print >> log , "Applying low resolution cutoff to map coefficients:" \
#      " d_max=%.6g" % d_max_apply
#  if (high_res is not None and high_res > d_min):
#    d_min_apply = high_res
#    print >> log, "Applying high resolution cutoff to map coefficients:" \
#      " d_min=%.6g" % d_min_apply
#  if (d_max_apply is not None or d_min_apply is not None):
#    map_coeffs = map_coeffs.resolution_filter(
#      d_max=d_max_apply, d_min=d_min_apply)
#    if (std_dev_weight_coeffs is not None):
#      std_dev_weight_coeffs = std_dev_weight_coeffs.resolution_filter(
#        d_max=d_max_apply, d_min=d_min_apply)
#    if (d_min_apply is not None):
#      d_min = d_min_apply
#    print >> log
#    sys.stdout.flush()
#  #
#  if (map_coeffs is not map_coeffs_input):
#    show_completeness("final")
#  #
#  fft_map = map_coeffs.fft_map(
#    d_min=d_min,
#    resolution_factor=work_params.map.grid_resolution_factor)
#  fft_map.apply_sigma_scaling()
#  std_dev_weight_fft_map = None
#  if (std_dev_weight_coeffs is not None):
#    std_dev_weight_fft_map = miller.fft_map(
#      crystal_gridding=fft_map,
#      fourier_coefficients=std_dev_weight_coeffs)
#    if (work_params.weight_map_normalization == "fourier"):
#      std_dev_weight_fft_map.apply_fourier_scaling()
#    elif (work_params.weight_map_normalization == "sigma"):
#      std_dev_weight_fft_map.apply_sigma_scaling()
#    else:
#      assert work_params.weight_map_normalization is None
#  #
#  real_space_gradients_delta = \
#    d_min * work_params.real_space_gradients_delta_resolution_factor
#  print >> log, "real_space_gradients_delta: %.6g" % real_space_gradients_delta
#  print >> log
#  sys.stdout.flush()
#  #
#  if (work_params.rotamer_score_and_choose_best.run):
#    rotamer_score_and_choose_best(
#      mon_lib_srv=mon_lib_srv,
#      density_map=fft_map.real_map(),
#      pdb_hierarchy=processed_pdb_file.all_chain_proxies.pdb_hierarchy,
#      geometry_restraints_manager=grm,
#      atom_selection_bool=get_atom_selection_bool(
#        scope_extract=work_params.rotamer_score_and_choose_best,
#        attr="atom_selection",
#        processed_pdb_file=processed_pdb_file,
#        work_params=work_params),
#      real_space_target_weight=work_params.real_space_target_weight,
#      real_space_gradients_delta=real_space_gradients_delta,
#      lbfgs_termination_params=scitbx.lbfgs.termination_parameters(
#        max_iterations=work_params
#          .rotamer_score_and_choose_best.lbfgs_max_iterations))
#    write_pdb(
#      file_name=work_params.rotamer_score_and_choose_best.output_file,
#      input_pdb_file_name=input_pdb_file_name,
#      processed_pdb_file=processed_pdb_file,
#      grm=grm,
#      new_suffix="_lockit_rotamer_score_and_choose_best.pdb")
#  #
#  best_info = None
#  if (work_params.coordinate_refinement.run):
#    def write_pdb_callback(situation):
#      if (situation == "after_best_weight_determination"):
#        write_pdb(
#          file_name=work_params.output_file,
#          input_pdb_file_name=input_pdb_file_name,
#          processed_pdb_file=processed_pdb_file,
#          grm=grm,
#          new_suffix="_lockit_best_weight.pdb")
#      elif (situation == "after_finishing_geo_min"):
#        write_pdb(
#          file_name=work_params.coordinate_refinement \
#            .finishing_geometry_minimization.output_file,
#          input_pdb_file_name=input_pdb_file_name,
#          processed_pdb_file=processed_pdb_file,
#          grm=grm,
#          new_suffix="_lockit_finishing_geo_min.pdb")
#      else:
#        raise AssertionError
#    best_info = run_coordinate_refinement_driver(
#      processed_pdb_file=processed_pdb_file,
#      geometry_restraints_manager=grm,
#      fft_map=fft_map,
#      std_dev_weight_fft_map=std_dev_weight_fft_map,
#      real_space_gradients_delta=real_space_gradients_delta,
#      work_params=work_params,
#      write_pdb_callback=write_pdb_callback,
#      log=sys.stdout)
#  else:
#    write_pdb(
#      file_name=work_params.output_file,
#      input_pdb_file_name=input_pdb_file_name,
#      processed_pdb_file=processed_pdb_file,
#      grm=grm,
#      new_suffix="_lockit_best_weight.pdb")
#  #
#  file_name = work_params.final_geo_file
#  if (file_name is not None):
#    if (file_name is Auto):
#      file_name = compose_output_file_name(
#        input_pdb_file_name=input_pdb_file_name,
#        new_suffix="_lockit_final.geo")
#    pdb_atoms = processed_pdb_file.all_chain_proxies.pdb_atoms
#    sites_cart = pdb_atoms.extract_xyz()
#    site_labels = [atom.id_str() for atom in pdb_atoms]
#    print >> log, "Writing file: %s" % show_string(file_name)
#    sys.stdout.flush()
#    f = open(file_name, "w")
#    grm.show_sorted(sites_cart=sites_cart, site_labels=site_labels, f=f)
#    del f
#    print >> log
#  #
#  show_times()
#  sys.stdout.flush()
#  return best_info
#
#if (__name__ == "__main__"):
#  run(args=sys.argv[1:],log=None)
#


 *******************************************************************************


 *******************************************************************************
mmtbx/refinement/real_space/weight.py
from __future__ import absolute_import, division, print_function
from cctbx.array_family import flex
import mmtbx.refinement.real_space.individual_sites
import random
from six.moves import range

class run(object):
  def __init__(
      self,
      map_data,
      xray_structure,
      pdb_hierarchy,
      geometry_restraints_manager,
      gradients_method="fd",
      ncs_groups=None,
      rms_bonds_limit=0.015,
      rms_angles_limit=2.0,
      real_space_gradients_delta=1./4,
      max_iterations = 100,
      range_size=10,
      n_ranges=10,
      default_weight=50):
    """
Fast determination of optimal data/restraints weight for real-space refinement
of individual sites.
    """
    self.msg_strings = []
    # split chains into chunks
    result = []
    for model in pdb_hierarchy.models():
      for chain in model.chains():
        if(chain.is_protein() or chain.is_na()):
          residue_range_sel = flex.size_t()
          cntr = 0
          for rg in chain.residue_groups():
            i_seqs = rg.atoms().extract_i_seq()
            cntr += 1
            if(cntr<10):
              residue_range_sel.extend(i_seqs)
            else:
              result.append(residue_range_sel)
              residue_range_sel = flex.size_t()
              residue_range_sel.extend(i_seqs)
              cntr = 0
          if(len(result)==0):
            assert residue_range_sel.size()>0
            result.append(residue_range_sel)
    self.msg_strings.append("number of chunks: %d"%len(result))
    # randomly pick chunks
    random_chunks = []
    if(len(result)>0):
      if len(result) <= n_ranges:
        # just try them all, no need to randomize
        random_chunks = list(range(len(result)))
      else:
        while len(random_chunks) <= n_ranges:
          # Put only unique choices until got enough lenght.
          # Could be slightly slow when len(random_chunks) slightly > n_ranges
          rc = random.choice(range(len(result)))
          if rc not in random_chunks:
            random_chunks.append(rc)
    self.msg_strings.append("random chunks:"%random_chunks)
    # setup refinery
    xrs_dc = xray_structure.deep_copy_scatterers()
    sel_all = flex.bool(xrs_dc.scatterers().size(), True)
    grm_dc = geometry_restraints_manager.select(sel_all)
    ro = mmtbx.refinement.real_space.individual_sites.box_refinement_manager(
      xray_structure              = xrs_dc,
      target_map                  = map_data,
      geometry_restraints_manager = grm_dc.geometry,
      real_space_gradients_delta  = real_space_gradients_delta,
      max_iterations              = max_iterations,
      ncs_groups                  = ncs_groups,
      gradients_method            = gradients_method)
    optimal_weights = flex.double()
    # loop over chunks: determine best weight for each chunk
    if(len(result)==0):
      random_chunks = [None]
    for chunk in random_chunks:
      if(chunk is None): sel = flex.bool(xrs_dc.scatterers().size(), True)
      else:
        sel = result[chunk]
        sel = flex.bool(xrs_dc.scatterers().size(), sel)
      ro.refine(
        selection        = sel,
        rms_bonds_limit  = rms_bonds_limit,
        rms_angles_limit = rms_angles_limit)
      self.msg_strings.append("chunk %s optimal weight: %9.4f"%(
          str(chunk), ro.weight_optimal))
      if(ro.weight_optimal is not None):
        optimal_weights.append(ro.weight_optimal)
    # select overall best weight
    sel = flex.sort_permutation(optimal_weights)
    optimal_weights = optimal_weights.select(sel)
    self.weight = flex.mean_default(
      optimal_weights[:optimal_weights.size()//2], default_weight)
    #mean = flex.mean(optimal_weights)
    #sel  = optimal_weights < mean*3
    #sel &= optimal_weights > mean/3
    #if(sel.count(True)>0):
    #  optimal_weights = optimal_weights.select(sel)
    #self.weight = flex.mean_default(optimal_weights, default_weight)
    self.msg_strings.append("overall best weight: %9.4f"%self.weight)

  def show(self, log, prefix=""):
    for m in self.msg_strings:
      print("%s %s"%(prefix, m), file=log)


 *******************************************************************************


 *******************************************************************************
mmtbx/refinement/refinement_flags.py
from __future__ import absolute_import, division, print_function
from cctbx.array_family import flex
import sys
from libtbx import adopt_init_args
from libtbx.utils import Sorry

class manager(object):
  def __init__(self, individual_sites       = False,
                     torsion_angles         = False,
                     rigid_body             = False,
                     individual_adp         = False,
                     group_adp              = False,
                     tls                    = False,
                     occupancies            = False,
                     group_anomalous        = False,
                     sites_individual       = None,
                     sites_torsion_angles   = None,
                     sites_rigid_body       = None,
                     adp_individual_iso     = None,
                     adp_individual_aniso   = None,
                     adp_group              = None,
                     group_h                = None,
                     adp_tls                = None,
                     s_occupancies          = None):
                     # XXX group_anomalous should be here
    adopt_init_args(self, locals())
    self.sites_individual       = self._deep_copy(self.sites_individual)
    self.sites_torsion_angles   = self._deep_copy(self.sites_torsion_angles)
    self.sites_rigid_body       = self._deep_copy(self.sites_rigid_body)
    self.adp_individual_iso     = self._deep_copy(self.adp_individual_iso)
    self.adp_individual_aniso   = self._deep_copy(self.adp_individual_aniso)
    self.adp_group              = self._deep_copy(self.adp_group)
    self.group_h                = self._deep_copy(self.group_h)
    self.adp_tls                = self._deep_copy(self.adp_tls)
    self.s_occupancies          = self._deep_copy(self.s_occupancies)
    self.check_all()

  def _deep_copy(self, x):
    result = []
    if(x is None): result = x
    elif(self.is_bool(x) or self.is_size_t(x)):
      result = x.deep_copy()
    elif(len(x)==0): result = x
    elif(self.is_size_t(x[0])):
      for item in x:
        if(self.is_size_t(item)):
          result.append(item.deep_copy())
        else: raise RuntimeError("Bad selection array type.")
    elif(self.is_size_t(x[0][0])):
      for item1 in x:
        tmp = []
        for item2 in item1:
          if(self.is_size_t(item2)):
            tmp.append(item2.deep_copy())
          else: raise RuntimeError("Bad selection array type.")
        result.append(tmp)
    else: raise RuntimeError("Bad selection array type.")
    return result

  def deep_copy(self):
    return manager(
      individual_sites       = self.individual_sites,
      torsion_angles         = self.torsion_angles,
      rigid_body             = self.rigid_body,
      individual_adp         = self.individual_adp,
      group_adp              = self.group_adp,
      tls                    = self.tls,
      occupancies            = self.occupancies,
      group_anomalous        = self.group_anomalous,
      sites_individual       = self._deep_copy(self.sites_individual),
      sites_torsion_angles   = self._deep_copy(self.sites_torsion_angles),
      sites_rigid_body       = self._deep_copy(self.sites_rigid_body),
      adp_individual_iso     = self._deep_copy(self.adp_individual_iso),
      adp_individual_aniso   = self._deep_copy(self.adp_individual_aniso),
      adp_group              = self._deep_copy(self.adp_group),
      group_h                = self._deep_copy(self.group_h),
      adp_tls                = self._deep_copy(self.adp_tls),
      s_occupancies          = self._deep_copy(self.s_occupancies))
      # XXX group_anomalous should be here

  def is_size_t(self, x):
    return ("%s"%x.__class__).count("array_family_flex_ext.size_t") > 0

  def is_bool(self, x):
    return ("%s"%x.__class__).count("array_family_flex_ext.bool") > 0

  def _count_selected(self, selections):
    assert selections is not None
    selections = self._deep_copy(selections)
    result = True
    try: lx = len(selections)
    except Exception: lx = selections.size()
    if(lx == 0): return result
    if(self.is_bool(selections)):
      if(selections.count(True) == 0): result = False
    elif(self.is_size_t(selections)):
      if(selections.size() == 0): result = False
    elif(self.is_size_t(selections[0]) or self.is_bool(selections[0])):
      as_1d = []
      for sel in selections:
        if(self.is_size_t(sel)):
          as_1d.extend(list(sel))
        elif(self.is_bool(sel)):
          as_1d.extend(list(sel.iselection()))
        else:
          result = False
          break
      if(len(as_1d) == 0 or len(as_1d) != len(set(as_1d))):
        result = False
    else:
      as_1d = []
      for i in selections:
        for j in i:
          for k in j:
            as_1d.append(k)
      if(len(as_1d) == 0 or len(as_1d) != len(set(as_1d))):
        result = False
    return result

  def check_all(self):
    prefix = "\nBad (empty or mixed) selection in %s"
    if(self.individual_sites):
      if(not self._count_selected(self.sites_individual)):
        raise Sorry(prefix%"sites_individual.")
    if(self.torsion_angles):
      if(not self._count_selected(self.sites_torsion_angles)):
        raise Sorry(prefix%"sites_torsion_angles.")
    if(self.rigid_body):
      if(not self._count_selected(self.sites_rigid_body)):
        raise Sorry(prefix%"sites_rigid_body.")
    if(self.individual_adp):
      if(not self.tls and [self.adp_individual_iso,
         self.adp_individual_aniso].count(None)==0):
        if(not (self.adp_individual_aniso &
           self.adp_individual_iso).all_eq(False)):
          raise Sorry("Same atoms selected for iso and aniso ADP refinement.")
      elif(self.adp_individual_iso is not None):
        if(not self._count_selected(self.adp_individual_iso)):
          if(not self._count_selected(self.adp_individual_aniso)):
            raise Sorry(prefix%"adp_individual_iso.")
      elif(self.adp_individual_aniso is not None):
        if(not self._count_selected(self.adp_individual_aniso)):
          raise Sorry(prefix%"adp_individual_aniso.")
      else: raise Sorry("No selection for individual_adp.")
    if(self.group_adp):
      if(not self._count_selected(self.adp_group)):
        raise Sorry(prefix%"adp_group.")
    if(self.tls):
      if(not self._count_selected(self.adp_tls)):
        raise Sorry(prefix%"adp_tls.")
    if(self.occupancies and self.s_occupancies is not None):
      if(not self._count_selected(self.s_occupancies)):
        raise Sorry(prefix%"occupancies.")
    if(self.group_anomalous):
      pass # XXX selections not used in common framework

  def szs(self, x):
    if(x is not None): return str(len(x))
    else: return str(0)

  def ca(self, x):
    if(x is None):           return str(0)
    elif(self.is_bool(x)):   return str(x.count(True))
    elif(self.is_size_t(x)): return str(x.size())
    elif(len(x)==0):         return str(0)
    elif(self.is_size_t(x[0])):
      return str(flex.sum(flex.size_t([i.size() for i in x])))
    else: raise RuntimeError("Bad selection array type.")

  def count_occupancies(self, x):
    result = flex.size_t()
    if(x is not None):
      for i in x:
        for j in i:
          for k in j:
            result.append(k)
    return str(result.size())

  def show(self, log = None):
    if(log is None): log = sys.stdout
    print("Refinement flags and selection counts:", file=log)
    print("  individual_sites       = %5s (%s atoms)"%(
      str(self.individual_sites), self.ca(self.sites_individual)), file=log)
    print("  torsion_angles         = %5s (%s atoms)"%(
      str(self.torsion_angles), self.ca(self.sites_torsion_angles)), file=log)
    print("  rigid_body             = %5s (%s atoms in %s groups)"%(
      str(self.rigid_body), self.ca(self.sites_rigid_body),
      self.szs(self.sites_rigid_body)), file=log)
    print("  individual_adp         = %5s (iso = %s aniso = %s)"%(
      str(self.individual_adp), self.ca(self.adp_individual_iso),
      self.ca(self.adp_individual_aniso)), file=log)
    print("  group_adp              = %5s (%s atoms in %s groups)"%(
      str(self.group_adp), self.ca(self.adp_group), self.szs(self.adp_group)), file=log)
    print("  tls                    = %5s (%s atoms in %s groups)" % (
      str(self.tls), self.ca(self.adp_tls), self.szs(self.adp_tls)), file=log)
    co_res = self.count_occupancies(self.s_occupancies)
    print("  occupancies            = %5s (%s atoms)"%(
      str(self.occupancies), co_res), file=log)
    print("  group_anomalous        = %5s"%self.group_anomalous, file=log) # XXX selections not available
    log.flush()

  def _select(self, x, selection):
    try: lx = len(x)
    except Exception: lx = x.size()
    if(lx == 0): return x
    if(self.is_bool(x)):
      x = x.select(selection)
    elif(self.is_size_t(x[0])):
      x_new = []
      for i_seq, item in enumerate(x):
        val = flex.bool(selection.size(), item).select(selection).iselection()
        if(val.size() > 0): x_new.append(val)
      x = x_new
    elif(self.is_size_t(x[0][0])):
      x_new = []
      for item1 in x:
        tmp = []
        for item2 in item1:
          if(self.is_size_t(item2)):
            v=flex.bool(selection.size(),item2).select(selection).iselection()
            if(v.size() > 0): tmp.append(v)
          else: raise RuntimeError("Bad selection array type.")
        if(len(tmp) > 0): x_new.append(tmp)
      x = x_new
    else: raise RuntimeError("Bad selection array type.")
    return x

  def select_detached(self, selection):
    new_sites_individual     = None
    new_sites_torsion_angles = None
    new_sites_rigid_body     = None
    new_adp_individual_iso   = None
    new_adp_individual_aniso = None
    new_adp_group            = None
    new_group_h              = None
    new_adp_tls              = None
    new_s_occupancies        = None
    if(self.sites_individual is not None):
      new_sites_individual = self._select(self.sites_individual, selection)
    if(self.sites_torsion_angles is not None):
      new_sites_torsion_angles = self._select(
        self.sites_torsion_angles, selection)
    if(self.adp_individual_iso is not None):
      new_adp_individual_iso= self._select(self.adp_individual_iso, selection)
    if(self.adp_individual_aniso is not None):
      new_adp_individual_aniso= self._select(self.adp_individual_aniso,
        selection)
    if(self.sites_rigid_body is not None):
      new_sites_rigid_body = self._select(self.sites_rigid_body, selection)
    if(self.adp_group is not None):
      new_adp_group = self._select(self.adp_group, selection)
    if(self.group_h is not None):
      new_group_h = self._select(self.group_h, selection)
    if(self.adp_tls is not None):
      new_adp_tls = self._select(self.adp_tls, selection)
    if(self.s_occupancies is not None):
      new_s_occupancies = self._select(self.s_occupancies, selection)
    return manager(
      individual_sites       = self.individual_sites,
      torsion_angles         = self.torsion_angles  ,
      rigid_body             = self.rigid_body      ,
      individual_adp         = self.individual_adp  ,
      group_adp              = self.group_adp       ,
      tls                    = self.tls             ,
      occupancies            = self.occupancies     ,
      group_anomalous        = self.group_anomalous ,
      sites_individual       = new_sites_individual    ,
      sites_torsion_angles   = new_sites_torsion_angles,
      sites_rigid_body       = new_sites_rigid_body    ,
      adp_individual_iso     = new_adp_individual_iso  ,
      adp_individual_aniso   = new_adp_individual_aniso,
      adp_group              = new_adp_group           ,
      group_h                = new_group_h             ,
      adp_tls                = new_adp_tls             ,
      s_occupancies          = new_s_occupancies       )

  def select(self, selection):
    assert self.is_bool(selection)
    if(self.sites_individual is not None):
      self.sites_individual = self._select(self.sites_individual, selection)
    if(self.sites_torsion_angles is not None):
      self.sites_torsion_angles = self._select(
        self.sites_torsion_angles, selection)
    if(self.adp_individual_iso is not None):
      self.adp_individual_iso= self._select(self.adp_individual_iso, selection)
    if(self.adp_individual_aniso is not None):
      self.adp_individual_aniso= self._select(self.adp_individual_aniso,
        selection)
    if(self.sites_rigid_body is not None):
      self.sites_rigid_body = self._select(self.sites_rigid_body, selection)
    if(self.adp_group is not None):
      self.adp_group = self._select(self.adp_group, selection)
    if(self.group_h is not None):
      self.group_h = self._select(self.group_h, selection)
    if(self.adp_tls is not None):
      self.adp_tls = self._select(self.adp_tls, selection)
    if(self.s_occupancies is not None):
      self.s_occupancies = self._select(self.s_occupancies, selection)
    return self

  def inflate(self, sites_individual       = None,
                    sites_torsion_angles   = None,
                    sites_rigid_body       = None,
                    adp_individual_iso     = None,
                    adp_individual_aniso   = None,
                    adp_group              = None,
                    group_h                = None,
                    adp_tls                = None,
                    s_occupancies          = None,
                    occupancies_group      = None,
                    size_all               = None):
                    # XXX group_anomalous selection should be added
    if(sites_individual is not None and self.sites_individual is not None):
      assert self.is_bool(sites_individual)
      self.sites_individual.extend(sites_individual)
    if(    sites_torsion_angles is not None
       and self.sites_torsion_angles is not None):
      assert self.is_bool(sites_torsion_angles)
      self.sites_torsion_angles.extend(sites_torsion_angles)
    if(adp_individual_iso is not None):
      assert self.is_bool(adp_individual_iso)
      if(self.adp_individual_iso is None):
        assert size_all is not None
        self.adp_individual_iso = flex.bool(size_all, False)
      # inflate existing iso flags if present
      elif (size_all and self.adp_individual_iso.size() < size_all):
        n_new = size_all - self.adp_individual_iso.size()
        self.adp_individual_iso.extend(flex.bool(n_new, False))
      self.adp_individual_iso.extend(adp_individual_iso)
    if(adp_individual_aniso is not None):
      assert self.is_bool(adp_individual_aniso)
      if(self.adp_individual_aniso is None):
        assert size_all is not None
        self.adp_individual_aniso = flex.bool(size_all, False)
      # inflate existing aniso flags if present
      elif (size_all and self.adp_individual_aniso.size() < size_all):
        n_new = size_all - self.adp_individual_aniso.size()
        self.adp_individual_aniso.extend(flex.bool(n_new, False))
      self.adp_individual_aniso.extend(adp_individual_aniso)
    if(sites_rigid_body is not None):
      assert hasattr(sites_rigid_body, 'count')
      self.sites_rigid_body.extend(sites_rigid_body)
    if(adp_group is not None):
      assert hasattr(adp_group, 'count')
      self.adp_group.extend(adp_group)
    if(group_h is not None):
      assert hasattr(group_h, 'count')
      self.group_h.extend(group_h)
    if(adp_tls is not None):
      assert hasattr(adp_tls, 'count')
      self.adp_tls.extend(adp_tls)
    if(s_occupancies is not None):
      assert hasattr(s_occupancies, 'count')
      if(self.s_occupancies is not None):
        self.s_occupancies.extend(s_occupancies)
    self.check_all()
    return self

  def _add_to_single_size_t(self, x, next_to_i_seq, squeeze_in, mode=1):
    tmp_x = []
    new_independent_element = None
    added = 0
    for sel in x:
      if(sel < next_to_i_seq):
        tmp_x.append(sel)
      elif(sel == next_to_i_seq):
        tmp_x.append(sel)
        if(squeeze_in):
          if(mode == 1):
            if(x.size() > 1):
              tmp_x.append(next_to_i_seq+1)
              added = 1
            elif(x.size() == 1):
              new_independent_element = [next_to_i_seq+1]
              added = 1
            else: raise RuntimeError
          elif(mode == 2):
            new_independent_element = [next_to_i_seq+1]
            added = 1
          else: raise RuntimeError
      else:
        tmp_x.append(sel+1)
    if(new_independent_element is not None):
      new_independent_element = flex.size_t(new_independent_element)
    return flex.size_t(tmp_x), new_independent_element, added

  def _add(self, x, next_to_i_seq, squeeze_in):
    if(x is None): return x
    elif(self.is_bool(x)):
      x_new = []
      result = self._add_to_single_size_t(x.iselection(),
        next_to_i_seq, squeeze_in)
      if(result[1] is None): x_new.extend([result[0]])
      else: x_new.extend([result[0], result[1]])
      if(result[2] == 0 and squeeze_in):
        x_new.extend([flex.size_t([next_to_i_seq+1])])
      x_new_new = flex.size_t()
      for i_x_new in x_new: x_new_new.extend(i_x_new)
      return flex.bool(x.size()+1, x_new_new)
    #elif(self.is_size_t(x)): # XXX not testes so disabled
    #  return self._add_to_single_size_t(x, next_to_i_seq, squeeze_in)
    elif(len(x)==0): raise RuntimeError
    elif(self.is_size_t(x[0])):
      x_new = []
      added = 0
      for x_ in x:
        result = self._add_to_single_size_t(x_, next_to_i_seq, squeeze_in)
        added += result[2]
        if(result[1] is None): x_new.extend([result[0]])
        else: x_new.extend([result[0], result[1]])
      if(added == 0 and squeeze_in):
        x_new.extend([flex.size_t([next_to_i_seq+1])])
      return x_new
    elif(self.is_size_t(x[0][0])):
      xx_new = []
      added = 0
      result_1 = None
      for xx in x:
        x_new = []
        for x_ in xx:
          result = self._add_to_single_size_t(x_, next_to_i_seq, squeeze_in, 2)
          added += result[2]
          if(result[1] is None):
            x_new.extend([result[0]])
          else:
            x_new.extend([result[0]])
          if(result[1] is not None):
            xx_new.append([result[1]])
        if(len(x_new) > 0): xx_new.append(x_new)
      if(added == 0 and squeeze_in):
        xx_new.append([flex.size_t([next_to_i_seq+1])])
      return xx_new
    else: raise RuntimeError("Bad selection array type.")

  def add(self, next_to_i_seqs,
                sites_individual     = False,
                sites_torsion_angles = False,
                sites_rigid_body     = False,
                adp_individual_iso   = False,
                adp_individual_aniso = False,
                adp_group            = False,
                group_h              = False,
                adp_tls              = False,
                s_occupancies        = False):
                # XXX group_anomalous selection should be added
    next_to_i_seqs = flex.size_t(next_to_i_seqs)
    perm = flex.sort_permutation(next_to_i_seqs, reverse = True)
    next_to_i_seqs = next_to_i_seqs.select(perm)
    for next_to_i_seq in next_to_i_seqs:
      if(self.sites_individual is not None):
        self.sites_individual = self._add(
          x             = self.sites_individual,
          next_to_i_seq = next_to_i_seq,
          squeeze_in    = sites_individual)
      if(self.sites_torsion_angles is not None):
        self.sites_torsion_angles = self._add(
          x             = self.sites_torsion_angles,
          next_to_i_seq = next_to_i_seq,
          squeeze_in    = sites_torsion_angles)
      if(self.sites_rigid_body is not None):
        self.sites_rigid_body = self._add(
          x             = self.sites_rigid_body,
          next_to_i_seq = next_to_i_seq,
          squeeze_in    = sites_rigid_body)
      if(self.adp_individual_iso is not None):
        self.adp_individual_iso = self._add(
          x             = self.adp_individual_iso,
          next_to_i_seq = next_to_i_seq,
          squeeze_in    = adp_individual_iso)
      if(self.adp_individual_aniso is not None):
        self.adp_individual_aniso = self._add(
          x             = self.adp_individual_aniso,
          next_to_i_seq = next_to_i_seq,
          squeeze_in    = adp_individual_aniso)
      if(self.adp_group is not None):
        self.adp_group = self._add(
          x             = self.adp_group,
          next_to_i_seq = next_to_i_seq,
          squeeze_in    = adp_group)
      if(self.group_h is not None):
        self.group_h = self._add(
          x             = self.group_h,
          next_to_i_seq = next_to_i_seq,
          squeeze_in    = group_h)
      if(self.adp_tls is not None):
        self.adp_tls = self._add(
          x             = self.adp_tls,
          next_to_i_seq = next_to_i_seq,
          squeeze_in    = adp_tls)
      if(self.s_occupancies is not None):
        self.s_occupancies = self._add(
          x             = self.s_occupancies,
          next_to_i_seq = next_to_i_seq,
          squeeze_in    = s_occupancies)
    return self


 *******************************************************************************


 *******************************************************************************
mmtbx/refinement/restraints.py
from __future__ import absolute_import, division
from cctbx.array_family import flex
from libtbx import adopt_init_args
from cctbx import adptbx

class manager(object):
  """
  Refinement restraints: restraints manager + refinable parameter limits

  XXX LIMITED. Restraint targets not used. Selection is not used or used
      incorrectly.

  """
  def __init__(self,
               model,
               use_target=False):
    adopt_init_args(self, locals())
    self._restraints = None
    self._lower_bound = None
    self._upper_bound = None
    self._bound_flags = None
    self._use_xyz     = None
    self._use_adp     = None
    self._use_occ     = None

  def set_flags(self, use_xyz=False, use_adp=False, use_occ=False):
    self._use_xyz = use_xyz
    self._use_adp = use_adp
    self._use_occ = use_occ

  def check_flags(self):
    assert [self._use_xyz, self._use_adp, self._use_occ].count(True) == 1

  def check_selection(self, selection):
    if selection is not None:
      assert isinstance(selection, flex.bool)
      assert self.model.size() == selection.size()

  def set_use_xyz(self, selection = None, max_shift = 3.0):
    self.set_flags(use_xyz=True)
    self.check_selection(selection)
    x = flex.vec3_double( self.get_x() )
    max_shift = flex.vec3_double(x.size(), [max_shift, max_shift, max_shift])
    self._lower_bound = x.deep_copy()
    self._upper_bound = x.deep_copy()
    if selection is not None:
      self._lower_bound.set_selected(selection, x-max_shift)
      self._upper_bound.set_selected(selection, x+max_shift)
    else:
      self._lower_bound = x-max_shift
      self._upper_bound = x+max_shift
    self.x            = x.as_double()
    self._lower_bound = self._lower_bound.as_double()
    self._upper_bound = self._upper_bound.as_double()
    self._bound_flags = flex.int(x.size()*3, 2)
    if self.use_target:
      self._restraints = self.model.restraints_manager_energies_sites(
        compute_gradients=True)

  def get_x(self):
    self.check_flags()
    xrs = self.model.get_xray_structure()
    if   self._use_xyz: return xrs.sites_cart().as_double()
    elif self._use_adp: return xrs.extract_u_iso_or_u_equiv()
    elif self._use_occ: return xrs.scatterers().extract_occupancies()
    else: assert 0

  def set_use_adp(self, selection=None, b_min=1, b_max=200):
    self.set_flags(use_adp=True)
    self.check_selection(selection)
    x = self.get_x()
    u_min, u_max = adptbx.b_as_u(b_min), adptbx.b_as_u(b_max)
    self._lower_bound = x.deep_copy()
    self._upper_bound = x.deep_copy()
    if selection is not None:
      self._lower_bound.set_selected(selection, u_min)
      self._upper_bound.set_selected(selection, u_max)
    else:
      self._lower_bound = flex.double(x.size(), u_min)
      self._upper_bound = flex.double(x.size(), u_max)
    self._bound_flags = flex.int(x.size(), 2)
    if self.use_target:
      self._restraints = self.model.energies_adp(
        iso_restraints    = None,
        use_hd            = self.model.is_neutron(),
        compute_gradients = True)

  def set_use_occ(self, selection=None, q_min=0.004, q_max=1.0):
    self.set_flags(use_occ=True)
    self.check_selection(selection)
    x = self.get_x()
    self._lower_bound = x.deep_copy()
    self._upper_bound = x.deep_copy()
    if selection is not None:
      self._lower_bound.set_selected(selection, q_min)
      self._upper_bound.set_selected(selection, q_max)
    else:
      self._lower_bound = flex.double(x.size(), q_min)
      self._upper_bound = flex.double(x.size(), q_max)
    self._bound_flags = flex.int(x.size(), 2)
    self._restraints = None

  def lower_bound(self):
    return self._lower_bound

  def upper_bound(self):
    return self._upper_bound

  def bound_flags(self):
    return self._bound_flags

  def update(self, x):
    if not self.use_target: return
    if self._use_xyz:
      self.model.set_sites_cart(flex.vec3_double(x))
      self._restraints = self.model.restraints_manager_energies_sites(
        compute_gradients=True)
    elif self._use_adp:
      b_iso = x*adptbx.u_as_b(1.)
      self.model.set_b_iso(values = b_iso)
      self._restraints = self.model.energies_adp(
        iso_restraints    = None,
        use_hd            = self.model.is_neutron(),
        compute_gradients = True)


  def target(self):
    if self._restraints is None: return None
    if   self._use_xyz: return self._restraints.target
    elif self._use_adp: return self._restraints.target
    elif self._use_occ: return None
    else: assert 0

  def gradients(self):
    if self._restraints is None: return None
    if   self._use_xyz: return self._restraints.gradients.as_double()
    elif self._use_adp: return self._restraints.u_iso_gradients
    elif self._use_occ: return None
    else: assert 0


 *******************************************************************************


 *******************************************************************************
mmtbx/refinement/rigid_body.py
from __future__ import absolute_import, division, print_function
from cctbx.array_family import flex
from libtbx import adopt_init_args
import sys
from libtbx.test_utils import approx_equal
from scitbx import matrix
from scitbx import lbfgs
from mmtbx.refinement import print_statistics
import iotbx.phil
import copy
from libtbx.utils import null_out
from libtbx.utils import user_plus_sys_time
from libtbx.math_utils import iround
import scitbx.rigid_body
from six.moves import zip
from six.moves import range

time_rigid_body_total = 0.0

class rigid_body_shift_accumulator(object):

   def __init__(self, euler_angle_convention):
     self.euler_angle_convention = euler_angle_convention
     self.rotations = []
     self.translations = []

   def add(self, rotations, translations):
     assert len(rotations) == len(translations)
     new_rotations = []
     new_translations = []
     if(len(self.rotations) > 0):
        for rn, tn, r, t in zip(rotations, translations, self.rotations,
                                                            self.translations):
            new_rotations.append(rn + r)
            new_translations.append(tn + t)
     else:
        for rn, tn in zip(rotations, translations):
            new_rotations.append(rn)
            new_translations.append(tn)
     self.rotations = new_rotations
     self.translations = new_translations

   def show(self, out = None):
     if (out is None): out = sys.stdout
     print("|-rigid body shift (total)------------------------------"\
                   "----------------------|", file=out)
     print_statistics.show_rigid_body_rotations_and_translations(
       out=out,
       prefix="",
       frame="|",
       euler_angle_convention=self.euler_angle_convention,
       rotations=self.rotations,
       translations=self.translations)
     print("|"+"-"*77+"|", file=out)
     print(file=out)

multiple_zones_params_str = """\
  min_number_of_reflections = 200
    .type = int
    .help = Number of reflections that defines the first lowest resolution \
            zone for the multiple_zones protocol. If very large \
            displacements are expected, decreasing this parameter to 100 \
            may lead to a larger convergence radius.
  multi_body_factor = 1
    .type = float
  zone_exponent = 3.0
    .type = float
  high_resolution = 3.0
    .type = float
    .help = High resolution cutoff (used for rigid body refinement only)
  max_low_high_res_limit = None
    .type = float
    .expert_level=2
    .help = Maximum value for high resolution cutoff for the first lowest \
            resolution zone
  number_of_zones = 5
    .type = int
    .help = Number of resolution zones for MZ protocol
"""

master_params = iotbx.phil.parse("""\
    mode = *first_macro_cycle_only every_macro_cycle
      .type = choice
      .help = Defines how many times the rigid body refinement is performed \
              during refinement run. first_macro_cycle_only to run only once \
              at first macrocycle, every_macro_cycle to do rigid body \
              refinement main.number_of_macro_cycles times
    target = ls_wunit_k1 ml *auto
      .type = choice
      .help = Rigid body refinement target function: least-squares or \
              maximum-likelihood
    target_auto_switch_resolution = 6.0
      .type = float
      .help = Used if target=auto, use optimal target for given working \
              resolution.
    disable_final_r_factor_check = False
      .type = bool
      .expert_level = 2
      .help = If True, the R-factor check after refinement will not revert to \
        the previous model, even if the R-factors have increased.
      .short_caption = Disable R-factor check
    refine_rotation = True
      .type = bool
      .help = Only rotation is refined (translation is fixed).
    refine_translation = True
      .type = bool
      .help = Only translation is refined (rotation is fixed).
    max_iterations = 25
      .type = int
      .help = Number of LBFGS minimization iterations
    bulk_solvent_and_scale = True
      .type = bool
      .help = Bulk-solvent and scaling within rigid body refinement (needed \
              since large rigid body shifts invalidate the mask).
    euler_angle_convention = *xyz zyz
      .type = choice
      .expert_level=2
      .help = Euler angles convention
    lbfgs_line_search_max_function_evaluations = 10
      .type = int
      .expert_level=2
    %s
""" % multiple_zones_params_str)

def split_resolution_range(
      d_spacings,
      n_bodies,
      target,
      target_auto_switch_resolution,
      n_ref_first,
      multi_body_factor_n_ref_first,
      d_low,
      d_high,
      number_of_zones,
      zone_exponent,
      log = None):
  assert n_bodies > 0
  assert target_auto_switch_resolution > 0
  assert multi_body_factor_n_ref_first is None or multi_body_factor_n_ref_first > 0
  assert n_ref_first is None or n_ref_first > 0
  assert d_low is None or d_low > 0
  assert d_high is None or d_high > 0
  assert n_ref_first is not None or d_low is not None
  if (d_low is not None and d_high is not None): assert d_low > d_high
  assert number_of_zones is None or number_of_zones > 0
  assert zone_exponent > 0
  if (log is None): log = sys.stdout
  n_refl_data = d_spacings.size()
  d_spacings = d_spacings.select(
    flex.sort_permutation(d_spacings, reverse = True))
  d_max, d_min = d_spacings[0], d_spacings[-1]
  if (d_high is not None and d_min < d_high):
    d_spacings = d_spacings.select(d_spacings >= d_high)
  d_high = d_spacings[-1]
  m_ref_first = n_ref_first
  if (n_ref_first is None):
    final_n_ref_first = (d_spacings >= d_low).count(True)
  else:
    if (multi_body_factor_n_ref_first is not None):
      m_ref_first += iround(
        m_ref_first * (n_bodies-1) * multi_body_factor_n_ref_first)
    assert m_ref_first > 0
    if (    d_low is not None
        and m_ref_first <= d_spacings.size()
        and d_spacings[m_ref_first-1] > d_low):
      final_n_ref_first = (d_spacings >= d_low).count(True)
    else:
      final_n_ref_first = m_ref_first
  d_mins = []
  if (number_of_zones is not None and number_of_zones > 1):
    degenerate = final_n_ref_first > d_spacings.size()
    if (degenerate):
      d_mins.append(d_high)
    else:
      zone_factor = (d_spacings.size() - final_n_ref_first) \
                  / ((number_of_zones-1)**zone_exponent)
      d_mins.append(d_spacings[final_n_ref_first-1])
      for i_zone in range(1, number_of_zones):
        n = iround(final_n_ref_first + zone_factor * i_zone**zone_exponent)
        if (i_zone == number_of_zones - 1):
          assert n == d_spacings.size() # sanity check
        d_mins.append(d_spacings[n-1])
  else:
    final_n_ref_first = min(final_n_ref_first, d_spacings.size())
    degenerate = False
    d_mins.append(d_high)
  print("Rigid body refinement:", file=log)
  print("  Requested number of resolution zones: %d" % number_of_zones, file=log)
  if (len(d_mins) != 1 or degenerate):
    print("  Calculation for first resolution zone:", file=log)
    print("    Requested number of reflections per body:", n_ref_first, file=log)
    print("    Requested factor per body:", \
      multi_body_factor_n_ref_first, file=log)
    print("    Number of bodies:", n_bodies, file=log)
    print("    Resulting number of reflections:", m_ref_first, file=log)
    print("    Requested low-resolution limit:", d_low, end=' ', file=log)
    if (final_n_ref_first != m_ref_first):
      print("(determines final number)", end=' ', file=log)
    print(file=log)
    print("    Final number of reflections:", final_n_ref_first, file=log)
  print("  Data resolution:                      %6.2f - %6.2f" \
    " (%d reflections)" % (d_max, d_min, n_refl_data), file=log)
  print("  Resolution for rigid body refinement: %6.2f - %6.2f" \
    " (%d reflections)" % (d_max, d_high, d_spacings.size()), file=log)
  if (degenerate):
    print("""\
  WARNING: Final number of reflections for first resolution zone is greater
           than the number of available reflections (%d > %d).
  INFO: Number of resolution zones reset to 1.""" % (
    final_n_ref_first, d_spacings.size()), file=log)
  target_names = []
  for d_min in d_mins:
    if (target == "auto"):
      if (d_min > target_auto_switch_resolution):
        target_names.append("ls_wunit_k1")
      else:
        target_names.append("ml")
    else:
      target_names.append(target)
  if (len(d_mins) > 1):
    print("  Resolution cutoffs for multiple zones: ", file=log)
    print("                          number of", file=log)
    print("    zone     resolution  reflections  target", file=log)
    for i, d_i in enumerate(d_mins):
      n_ref = (d_spacings >= d_i).count(True)
      print("    %3d  %6.2f -%6.2f %11d    %s" % (
        i+1, d_max, d_i, n_ref, target_names[i]), file=log)
    print("    zone number of reflections =" \
      " %d + %.6g * (zone-1)**%.6g" % (
        final_n_ref_first, zone_factor, zone_exponent), file=log)
  return d_mins, target_names

class manager(object):
  def __init__(self, fmodel,
                     selections = None,
                     params     = None,
                     r_initial  = None,
                     t_initial  = None,
                     bss        = None,
                     log        = None,
                     monitors   = None):
    global time_rigid_body_total
    self.params = params
    save_original_target_name = fmodel.target_name
    save_bss_anisotropic_scaling = None
    if(bss is not None):
      save_bss_anisotropic_scaling = bss.anisotropic_scaling
    timer_rigid_body_total = user_plus_sys_time()
    save_r_work = fmodel.r_work()
    save_r_free = fmodel.r_free()
    save_xray_structure = fmodel.xray_structure.deep_copy_scatterers()
    if(log is None): log = sys.stdout
    if(selections is None):
      selections = []
      selections.append(flex.bool(
        fmodel.xray_structure.scatterers().size(), True).iselection())
    else: assert len(selections) > 0
    fmodel.xray_structure.scatterers().flags_set_grads(state=False)
    fmodel.xray_structure.scatterers().flags_set_grad_site(
      iselection = flex.bool(fmodel.xray_structure.scatterers().size(), True
      ).iselection())
    self.total_rotation = []
    self.total_translation = []
    for item in selections:
        self.total_rotation.append(flex.double(3,0))
        self.total_translation.append(flex.double(3,0))
    if(r_initial is None):
       r_initial = []
       for item in selections:
           r_initial.append(flex.double(3,0))
    if(t_initial is None):
       t_initial = []
       for item in selections:
           t_initial.append(flex.double(3,0))
    fmodel_copy = fmodel.deep_copy()
    if(fmodel_copy.mask_params is not None):
       fmodel_copy.mask_params.verbose = -1
    d_mins, target_names = split_resolution_range(
      d_spacings                    = fmodel_copy.f_obs_work().d_spacings().data(),
      n_bodies                      = len(selections),
      target                        = params.target,
      target_auto_switch_resolution = params.target_auto_switch_resolution,
      n_ref_first                   = params.min_number_of_reflections,
      multi_body_factor_n_ref_first = params.multi_body_factor,
      d_low                         = params.max_low_high_res_limit,
      d_high                        = params.high_resolution,
      number_of_zones               = params.number_of_zones,
      zone_exponent                 = params.zone_exponent,
      log                           = log)
    print(file=log)
    if (fmodel.target_name != target_names[0]):
      fmodel.update(target_name=target_names[0])
    self.show(fmodel = fmodel,
              r_mat  = self.total_rotation,
              t_vec  = self.total_translation,
              header = "Start",
              out    = log)
    if (params.number_of_zones == 1 or monitors is None):
      monitors_call_back_handler = None
    else:
      monitors_call_back_handler = monitors.call_back_handler
      if (monitors_call_back_handler is not None):
        monitors_call_back_handler(
          monitor=None, model=None, fmodel=fmodel, method="rigid_body")
    for res,target_name in zip(d_mins, target_names):
        xrs = fmodel_copy.xray_structure.deep_copy_scatterers()
        fmodel_copy = fmodel.resolution_filter(d_min = res)
        if (fmodel_copy.target_name != target_name):
          fmodel_copy.update(target_name=target_name)
        d_max_min = fmodel_copy.f_obs_work().d_max_min()
        line = "Refinement at resolution: "+\
                 str("%7.2f"%d_max_min[0]).strip() + " - " \
               + str("%6.2f"%d_max_min[1]).strip() \
               + " target=" + fmodel_copy.target_name
        print_statistics.make_sub_header(line, out = log)
        fmodel_copy.update_xray_structure(xray_structure = xrs,
                                          update_f_calc  = True)
        rworks = flex.double()
        if(len(d_mins) == 1):
           n_rigid_body_minimizer_cycles = 1
        else:
           n_rigid_body_minimizer_cycles = min(int(res),4)
        for i_macro_cycle in range(n_rigid_body_minimizer_cycles):
            if(bss is not None and params.bulk_solvent_and_scale):
               if(fmodel_copy.f_obs().d_min() > 3.0):
                  bss.anisotropic_scaling=False
               fast=True
               if(bss.mode=="slow"): fast=False
               fmodel_copy.update_all_scales(
                 update_f_part1       = False,
                 params               = bss,
                 fast                 = fast,
                 log                  = log,
                 remove_outliers      = False,
                 optimize_mask        = False,
                 refine_hd_scattering = False)
               if(fmodel_copy.f_obs().d_min() > 3.0):
                  assert save_bss_anisotropic_scaling is not None
                  bss.anisotropic_scaling = save_bss_anisotropic_scaling
                  bss.minimization_b_cart = save_bss_anisotropic_scaling
            minimized = rigid_body_minimizer(
              fmodel                 = fmodel_copy,
              selections             = selections,
              r_initial              = r_initial,
              t_initial              = t_initial,
              refine_r               = params.refine_rotation,
              refine_t               = params.refine_translation,
              max_iterations         = params.max_iterations,
              euler_angle_convention = params.euler_angle_convention,
              lbfgs_maxfev = params.lbfgs_line_search_max_function_evaluations)
            rotation_matrices = []
            translation_vectors = []
            for i in range(len(selections)):
                self.total_rotation[i] += flex.double(minimized.r_min[i])
                self.total_translation[i] += flex.double(minimized.t_min[i])
                rot_obj = scitbx.rigid_body.euler(
                  phi        = minimized.r_min[i][0],
                  psi        = minimized.r_min[i][1],
                  the        = minimized.r_min[i][2],
                  convention = params.euler_angle_convention)
                rotation_matrices.append(rot_obj.rot_mat())
                translation_vectors.append(minimized.t_min[i])
            new_xrs = apply_transformation(
                         xray_structure      = minimized.fmodel.xray_structure,
                         rotation_matrices   = rotation_matrices,
                         translation_vectors = translation_vectors,
                         selections          = selections)
            fmodel_copy.update_xray_structure(xray_structure = new_xrs,
                                              update_f_calc  = True,
                                              update_f_mask  = True)
            rwork = minimized.fmodel.r_work()
            rfree = minimized.fmodel.r_free()
            assert approx_equal(rwork, fmodel_copy.r_work())
        fmodel.update_xray_structure(
          xray_structure = fmodel_copy.xray_structure,
          update_f_calc  = True,
          update_f_mask  = True)
        if(bss is not None and params.bulk_solvent_and_scale):
          fast=True
          if(bss.mode=="slow"): fast=False
          fmodel_copy.update_all_scales(
            update_f_part1       = False,
            params               = bss,
            fast                 = fast,
            log                  = log,
            remove_outliers      = False,
            optimize_mask        = False,
            refine_hd_scattering = False)
        self.show(fmodel = fmodel,
                  r_mat  = self.total_rotation,
                  t_vec  = self.total_translation,
                  header = "Rigid body refinement",
                  out    = log)
        if (monitors_call_back_handler is not None):
          monitors_call_back_handler(
            monitor=None, model=None, fmodel=fmodel, method="rigid_body")
    if(bss is not None and params.bulk_solvent_and_scale):
      fast=True
      if(bss.mode=="slow"): fast=False
      fmodel_copy.update_all_scales(
        update_f_part1       = False,
        params               = bss,
        fast                 = fast,
        log                  = log,
        remove_outliers      = False,
        optimize_mask        = False,
        refine_hd_scattering = False)
    print(file=log)
    self.show(fmodel = fmodel,
              r_mat  = self.total_rotation,
              t_vec  = self.total_translation,
              header = "Rigid body end",
              out    = log)
    print(file=log)
    self.evaluate_after_end(fmodel, save_r_work, save_r_free,
      save_xray_structure, log)
    self.fmodel = fmodel
    self.fmodel.update(target_name = save_original_target_name)
    time_rigid_body_total += timer_rigid_body_total.elapsed()

  def evaluate_after_end(self, fmodel, save_r_work, save_r_free,
                         save_xray_structure, log):
    r_work = fmodel.r_work()
    r_free = fmodel.r_free()
    if((r_work > save_r_work and abs(r_work-save_r_work) > 0.01)):
      print(file=log)
      if (self.params.disable_final_r_factor_check):
        print("Warning: R-factors increased during refinement.", file=log)
      else :
        print("The model after this rigid-body refinement step is not accepted.", file=log)
        print("Reason: increase in R-factors after refinement.", file=log)
      print("Start/final R-work: %6.4f/%-6.4f"%(save_r_work, r_work), file=log)
      print("Start/final R-free: %6.4f/%-6.4f"%(save_r_free, r_free), file=log)
      if (self.params.disable_final_r_factor_check):
        print("(Revert to previous model is disabled, so accepting result.)", file=log)
      else :
        print("Return back to the previous model.", file=log)
        print(file=log)
        fmodel.update_xray_structure(xray_structure = save_xray_structure,
                                     update_f_calc  = True,
                                     update_f_mask  = True)
        fmodel.info().show_rfactors_targets_scales_overall(
          header = "rigid body after step back", out = log)
      print(file=log)

  def rotation(self):
    return self.total_rotation

  def translation(self):
    return self.total_translation

  def show(self, fmodel, r_mat, t_vec, header = "", out=None):
    if(out is None): out = sys.stdout
    fmodel_info = fmodel.info()
    fmodel_info._header_resolutions_nreflections(header=header, out=out)
    print("| "+"  "*38+"|", file=out)
    fmodel_info._rfactors_and_bulk_solvent_and_scale_params(out=out)
    print("| "+"  "*38+"|", file=out)
    print("| Rigid body shift (Euler angles %s):"% \
      self.params.euler_angle_convention+" "*40 +"|", file=out)
    print_statistics.show_rigid_body_rotations_and_translations(
      out=out,
      prefix="",
      frame="|",
      euler_angle_convention= self.params.euler_angle_convention,
      rotations=r_mat,
      translations=t_vec)
    print("|" +"-"*77+"|", file=out)

class rigid_body_minimizer(object):
  def __init__(self,
               fmodel,
               selections,
               r_initial,
               t_initial,
               refine_r,
               refine_t,
               max_iterations,
               euler_angle_convention,
               lbfgs_maxfev):
    adopt_init_args(self, locals())
    self.fmodel_copy = self.fmodel.deep_copy()
    self.target_functor = self.fmodel_copy.target_functor()
    self.target_functor.prepare_for_minimization()
    self.atomic_weights = self.fmodel.xray_structure.atomic_weights()
    self.sites_cart = self.fmodel.xray_structure.sites_cart()
    self.sites_frac = self.fmodel.xray_structure.sites_frac()
    self.n_groups = len(self.selections)
    assert self.n_groups > 0
    self.counter=0
    assert len(self.r_initial)  == len(self.t_initial)
    assert len(self.selections) == len(self.t_initial)
    self.dim_r = 3
    self.dim_t = 3
    self.r_min = copy.deepcopy(self.r_initial)
    self.t_min = copy.deepcopy(self.t_initial)
    for i in range(len(self.r_min)):
        self.r_min[i] = tuple(self.r_min[i])
        self.t_min[i] = tuple(self.t_min[i])
    self.x = self.pack(self.r_min, self.t_min)
    self.n = self.x.size()
    self.minimizer = lbfgs.run(
      target_evaluator = self,
      core_params = lbfgs.core_parameters(
           maxfev = lbfgs_maxfev),
      termination_params = lbfgs.termination_parameters(
           max_iterations = max_iterations),
      exception_handling_params = lbfgs.exception_handling_parameters(
           ignore_line_search_failed_step_at_lower_bound = True,
           ignore_line_search_failed_step_at_upper_bound = True)
                     )
    self.compute_functional_and_gradients(suppress_gradients=True)
    del self.x

  def pack(self, r, t):
    v = []
    for ri,ti in zip(r,t):
        if(self.refine_r): v += list(ri)
        if(self.refine_t): v += list(ti)
    return flex.double(tuple(v))

  def unpack_x(self):
    i = 0
    for j in range(self.n_groups):
        if(self.refine_r):
           self.r_min[j] = tuple(self.x)[i:i+self.dim_r]
           i += self.dim_r
        if(self.refine_t):
           self.t_min[j] = tuple(self.x)[i:i+self.dim_t]
           i += self.dim_t

  def compute_functional_and_gradients(self, suppress_gradients=False):
    self.unpack_x()
    self.counter += 1
    rotation_matrices   = []
    translation_vectors = []
    rot_objs = []
    for i in range(self.n_groups):
        rot_obj = scitbx.rigid_body.euler(
          phi        = self.r_min[i][0],
          psi        = self.r_min[i][1],
          the        = self.r_min[i][2],
          convention = self.euler_angle_convention)
        rotation_matrices.append(rot_obj.rot_mat())
        translation_vectors.append(self.t_min[i])
        rot_objs.append(rot_obj)
    new_sites_frac, new_sites_cart, centers_of_mass = apply_transformation_(
                              xray_structure      = self.fmodel.xray_structure,
                              sites_cart          = self.sites_cart,
                              sites_frac          = self.sites_frac,
                              rotation_matrices   = rotation_matrices,
                              translation_vectors = translation_vectors,
                              selections          = self.selections,
                              atomic_weights      = self.atomic_weights)
    self.fmodel_copy.xray_structure.set_sites_frac(new_sites_frac)
    new_xrs = self.fmodel_copy.xray_structure
    self.fmodel_copy.update_xray_structure(xray_structure = new_xrs,
                                           update_f_calc  = True)
    tg_obj = target_and_grads(
                   centers_of_mass = centers_of_mass,
                   sites_cart      = new_sites_cart,
                   target_functor  = self.target_functor,
                   rot_objs        = rot_objs,
                   selections      = self.selections,
                   suppress_gradients = suppress_gradients)
    self.f = tg_obj.target()
    if (suppress_gradients):
      self.g = None
    else:
      self.g = self.pack( tg_obj.gradients_wrt_r(), tg_obj.gradients_wrt_t() )
    return self.f, self.g

def apply_transformation_(xray_structure,
                          sites_cart,
                          sites_frac,
                          rotation_matrices,
                          translation_vectors,
                          selections,
                          atomic_weights):
  assert len(selections) == len(rotation_matrices)
  assert len(selections) == len(translation_vectors)
  centers_of_mass = []
  sites_cart = sites_cart.deep_copy()
  sites_frac = sites_frac.deep_copy()
  for sel,rot,trans in zip(selections,rotation_matrices,translation_vectors):
      apply_rigid_body_shift_obj = xray_structure.apply_rigid_body_shift_obj(
                                   sites_cart     = sites_cart,
                                   sites_frac     = sites_frac,
                                   rot            = rot.as_mat3(),
                                   trans          = trans,
                                   atomic_weights = atomic_weights,
                                   unit_cell      = xray_structure.unit_cell(),
                                   selection      = sel)
      sites_cart = apply_rigid_body_shift_obj.sites_cart
      sites_frac = apply_rigid_body_shift_obj.sites_frac
      centers_of_mass.append(apply_rigid_body_shift_obj.center_of_mass)
  return sites_frac, sites_cart, centers_of_mass

def apply_transformation(xray_structure,
                         rotation_matrices,
                         translation_vectors,
                         selections):
   assert len(selections) == len(rotation_matrices)
   assert len(selections) == len(translation_vectors)
   new_sites = xray_structure.sites_cart()
   for sel,rot,trans in zip(selections,rotation_matrices,translation_vectors):
       xrs = xray_structure.select(sel)
       cm_cart = xrs.center_of_mass()
       sites_cart = xrs.sites_cart()
       sites_cart_cm = sites_cart - cm_cart
       tmp = list(rot) * sites_cart_cm + trans + cm_cart
       new_sites.set_selected(sel, tmp)
   new_xrs = xray_structure.replace_sites_cart(new_sites = new_sites)
   return new_xrs

class target_and_grads(object):
  def __init__(self, centers_of_mass,
                     sites_cart,
                     target_functor,
                     rot_objs,
                     selections,
                     suppress_gradients):
    t_r = target_functor(compute_gradients=not suppress_gradients)
    self.f = t_r.target_work()
    if (suppress_gradients):
      self.grads_wrt_r = None
      self.grads_wrt_t = None
      return
    target_grads_wrt_xyz = t_r.gradients_wrt_atomic_parameters(site=True)
    self.grads_wrt_r = []
    self.grads_wrt_t = []
    target_grads_wrt_xyz = flex.vec3_double(target_grads_wrt_xyz.packed())
    for sel,rot_obj, cm in zip(selections, rot_objs, centers_of_mass):
        sites_cart_cm = sites_cart.select(sel) - cm
        target_grads_wrt_xyz_sel = target_grads_wrt_xyz.select(sel)
        target_grads_wrt_r = matrix.sqr(
                    sites_cart_cm.transpose_multiply(target_grads_wrt_xyz_sel))
        self.grads_wrt_t.append(flex.double(target_grads_wrt_xyz_sel.sum()))
        g_phi = (rot_obj.r_phi() * target_grads_wrt_r).trace()
        g_psi = (rot_obj.r_psi() * target_grads_wrt_r).trace()
        g_the = (rot_obj.r_the() * target_grads_wrt_r).trace()
        self.grads_wrt_r.append(flex.double([g_phi, g_psi, g_the]))

  def target(self):
    return self.f

  def gradients_wrt_r(self):
    return self.grads_wrt_r

  def gradients_wrt_t(self):
    return self.grads_wrt_t

def rigid_groups_from_pdb_chains(
    pdb_hierarchy,
    min_chain_size=2,
    xray_structure=None,
    check_for_atoms_on_special_positions=None,
    group_all_by_chain=False,
    log=None):
  assert (not pdb_hierarchy.atoms().extract_i_seq().all_eq(0))
  if (log is None) : log = null_out()
  sel_string = "not (resname HOH or resname WAT)"
  if (not group_all_by_chain):
    sel_string = "not (not pepnames and single_atom_residue)"
  selection = pdb_hierarchy.atom_selection_cache().selection(string=sel_string)
  pdb_hierarchy = pdb_hierarchy.select(selection)
  models = pdb_hierarchy.models()
  assert len(models) == 1
  atom_labels = list(pdb_hierarchy.atoms_with_labels())
  selections = []
  for chain in models[0].chains():
    if (not (chain.is_protein() or chain.is_na())):
      continue
    chain_atoms = chain.atoms()
    if(chain_atoms.size() >= min_chain_size):
      rgs = chain.residue_groups()
      chain_sele = "(chain '%s'" % chain.id
      if (not group_all_by_chain):
        resid_first = rgs[0].resid().strip()
        resid_last  = rgs[-1].resid().strip()
        chain_sele += " and resid %s through %s"%(resid_first, resid_last)
      else :
        chain_sele += " and " + sel_string
      chain_sele += ")"
      if (not chain_sele in selections):
        selections.append(chain_sele)
  if (check_for_atoms_on_special_positions):
    assert (xray_structure is not None)
    sel_cache = pdb_hierarchy.atom_selection_cache()
    site_symmetry_table = xray_structure.site_symmetry_table()
    disallowed_i_seqs = site_symmetry_table.special_position_indices()
    for sele_str in selections :
      isel = sel_cache.selection(sele_str).iselection()
      isel_special = isel.intersection(disallowed_i_seqs)
      if (len(isel_special) != 0):
        print("  WARNING: selection includes atoms on special positions", file=log)
        print("    selection: %s" % sele_str, file=log)
        print("    bad atoms:", file=log)
        for i_seq in isel_special :
          print("    %s" % atom_labels[i_seq].id_str(), file=log)
        return None
  return selections


 *******************************************************************************


 *******************************************************************************
mmtbx/refinement/select_best_starting_model.py

"""
This module provides a way to identify a suitably isomorphous initial model
for directly refining against experimental data.  This is commonly done when
solving a series of ligand-bound structures, partly to save time, and partly
to avoid changing the frame of reference when running molecular replacement.
"""

from __future__ import absolute_import, division, print_function
from libtbx.str_utils import make_sub_header
from libtbx import slots_getstate_setstate
from libtbx.utils import null_out, Sorry
from libtbx import easy_mp
import libtbx.phil
import os.path
import sys
from six.moves import zip

master_phil = libtbx.phil.parse("""
d_min = None
  .type = float
rigid_body_refine = True
  .type = bool
optimize_b_factors = False
  .type = bool
max_cell_angle_rmsd=1.0
  .type = float
max_cell_edge_rmsd=1.0
  .type = float
max_r_free = 0.4
  .type = float
""")

class evaluate_model(slots_getstate_setstate):
  """
  Create an fmodel object (including bulk solvent correction) and calculate
  R-factors, with or without optional rigid-body refinement.
  """
  __slots__ = [ "r_work", "r_free", "r_work_start", "r_free_start",
    "xray_structure" ]
  def __init__(self,
      xray_structure,
      pdb_hierarchy,
      f_obs,
      r_free_flags,
      rigid_body_refine=False,
      optimize_b_factors=False,
      skip_twin_detection=False,
      scattering_table="n_gaussian"):
    self.r_work = None
    self.r_free = None
    self.xray_structure = None
    from mmtbx.utils import fmodel_simple
    from cctbx import crystal
    combined_symmetry = crystal.symmetry(
      unit_cell=f_obs.unit_cell(),
      space_group=xray_structure.space_group())
    xray_structure = xray_structure.customized_copy(
      crystal_symmetry=combined_symmetry)
    f_obs = f_obs.customized_copy(
      crystal_symmetry=combined_symmetry).eliminate_sys_absent()
    r_free_flags = r_free_flags.customized_copy(
      crystal_symmetry=combined_symmetry).eliminate_sys_absent()
    fmodel = fmodel_simple(
      f_obs=f_obs,
      r_free_flags=r_free_flags,
      xray_structures=[xray_structure],
      skip_twin_detection=skip_twin_detection,
      scattering_table=scattering_table)
    self.r_work_start = fmodel.r_work()
    self.r_free_start = fmodel.r_free()
    if (not rigid_body_refine):
      self.r_work = self.r_work_start
      self.r_free = self.r_free_start
      self.xray_structure = xray_structure
    else :
      from mmtbx.refinement import rigid_body
      selection_strings = rigid_body.rigid_groups_from_pdb_chains(
        pdb_hierarchy=pdb_hierarchy,
        xray_structure=xray_structure,
        group_all_by_chain=True,
        check_for_atoms_on_special_positions=True,
        log=null_out())
      selections = []
      for sele_str in selection_strings :
        sele = pdb_hierarchy.atom_selection_cache().selection(sele_str)
        selections.append(sele.iselection())
      refined = rigid_body.manager(
        fmodel=fmodel,
        selections=selections,
        params=rigid_body.master_params.extract(),
        log=null_out())
      self.xray_structure = refined.fmodel.xray_structure
      self.r_work = refined.fmodel.r_work()
      self.r_free = refined.fmodel.r_free()

  def show(self, out=sys.stdout, prefix=""):
    print(prefix + "r_work = %6.4f" % self.r_work, file=out)
    print(prefix + "r_free = %6.4f" % self.r_free, file=out)

def ucf(unit_cell):
  return "%g %g %g %g %g %g" % unit_cell.parameters()

class select_model(object):
  def __init__(self,
      model_names,
      model_data,
      f_obs,
      r_free_flags,
      params=None,
      skip_twin_detection=False,
      nproc=1,
      log=sys.stdout):
    if (params is None):
      params = master_phil.extract()
    self.model_names = model_names
    if (model_data is None):
      import iotbx.pdb
      model_data = []
      for file_name in model_names :
        if (not os.path.isfile(file_name)):
          raise RuntimeError("model_data is None, but %s is not a file." %
            file_name)
        model_in = iotbx.pdb.input(file_name)
        pdb_hierarchy = model_in.construct_hierarchy()
        xray_structure = model_in.xray_structure_simple()
        model_data.append((pdb_hierarchy, xray_structure))
    self.model_symmetries = []
    self.models_accepted = []
    self.model_r_frees = []
    self.f_obs = f_obs.resolution_filter(d_min=params.d_min)
    self.r_free_flags = r_free_flags.common_set(other=self.f_obs)
    self.skip_twin_detection = skip_twin_detection
    self.params = params
    self.evaluations = None
    self.best_xray_structure = None
    self.best_pdb_hierarchy = None
    self.best_result = None
    self.best_model_name = None
    from mmtbx.pdb_symmetry import rms_difference
    data_symmetry = f_obs.crystal_symmetry()
    data_space_group = data_symmetry.space_group()
    data_point_group = data_space_group.build_derived_point_group()
    data_unit_cell = data_symmetry.unit_cell()
    data_cell_edges = data_unit_cell.parameters()[0:3]
    data_cell_angles = data_unit_cell.parameters()[3:6]
    make_sub_header("Evaluating models", out=log)
    print("Experimental data:", file=log)
    print("  space group:  %s" % data_space_group.info(), file=log)
    print("  unit cell:    %s" % ucf(data_unit_cell), file=log)
    pdb_hierarchies = []
    xray_structures = []
    for k, file_name in enumerate(model_names):
      pdb_hierarchy, xray_structure = model_data[k]
      pdb_hierarchy.atoms().reset_i_seq()
      pdb_hierarchies.append(pdb_hierarchy)
      model_symmetry = xray_structure.crystal_symmetry()
      self.model_symmetries.append(model_symmetry)
      if (model_symmetry is None):
        print("Model %d is missing symmetry records:" % (k+1), file=log)
        print("  source:  %s" % file_name, file=log)
        xray_structures.append(None)
        continue
      model_unit_cell = model_symmetry.unit_cell()
      model_space_group = model_symmetry.space_group()
      is_compatible_sg = False
      if (model_space_group == data_space_group):
        is_compatible_sg = True
      else :
        model_point_group = model_space_group.build_derived_point_group()
        if (data_point_group == model_point_group):
          is_compatible_sg = True
      if (not is_compatible_sg):
        print("Model %d has incompatible space group:" % (k+1), file=log)
        print("  source:  %s" % file_name, file=log)
        print("  space group: %s" % model_space_group.info(), file=log)
        xray_structures.append(None)
        continue
      is_similar_cell = False
      if (model_unit_cell.is_similar_to(data_unit_cell)):
        is_similar_cell = True
      else :
        model_cell_edges = model_unit_cell.parameters()[0:3]
        model_cell_angles = model_unit_cell.parameters()[3:6]
        cell_edge_rmsd = rms_difference(model_cell_edges, data_cell_edges)
        cell_angle_rmsd = rms_difference(model_cell_angles, data_cell_angles)
        if ((cell_edge_rmsd <= params.max_cell_edge_rmsd) and
            (cell_angle_rmsd <= params.max_cell_angle_rmsd)):
          is_similar_cell = True
      if (not is_similar_cell):
        print("Model %d has incompatible space group:" % (k+1), file=log)
        print("  source: %s" % file_name, file=log)
        print("  model:  %s" % ucf(model_unit_cell), file=log)
        xray_structures.append(None)
        continue
      else :
        xray_structures.append(xray_structure)
    if (xray_structures.count(None) != len(xray_structures)):
      print("", file=log)
      print("Calculating R-factors - will use %s processors." % nproc, file=log)
      evaluations = easy_mp.parallel_map(
        func=self.evaluate_model,
        iterable=list(zip(xray_structures, pdb_hierarchies)),
        processes=nproc)
      passed = []
      for k, result in enumerate(evaluations):
        if (result is not None):
          if (result.r_free <= params.max_r_free):
            passed.append((k, result))
      if (len(passed) > 0):
        passed.sort(key=lambda element: element[1].r_free)
        i_result, result = passed[0]
        self.evaluations = passed
        self.best_xray_structure = result.xray_structure
        self.best_pdb_hierarchy = pdb_hierarchies[i_result]
        self.best_result = result
        self.best_model_name = self.model_names[i_result]
    self.show(out=log, verbose=True)

  def show(self, out=sys.stdout, verbose=False):
    if (self.best_result is None):
      print("No models accepted - will need to run MR.", file=out)
    else :
      print("", file=out)
      print("Best starting model:", file=out)
      print("  source: %s" % self.best_model_name, file=out)
      self.best_result.show(out=out, prefix="    ")
      print("", file=out)
      if (verbose) and (len(self.evaluations) > 1):
        print("Other suitable models:", file=out)
        for i_other, other in self.evaluations[1:] :
          print("  source: %s" % self.model_names[i_other], file=out)
          other.show(out=out, prefix="    ")
        print("", file=out)

  def success(self):
    return self.best_pdb_hierarchy is not None

  def r_free(self):
    return getattr(self.best_result, "r_free", None)

  def r_work(self):
    return getattr(self.best_result, "r_work", None)

  def get_best_model(self, update_structure=True):
    if (self.best_result is None):
      return None
    xray_structure = self.best_xray_structure
    pdb_hierarchy = self.best_pdb_hierarchy
    if (update_structure):
      pdb_hierarchy.adopt_xray_structure(xray_structure)
    return xray_structure, pdb_hierarchy

  def save_best_model(self, file_name="best_model.pdb"):
    assert self.success()
    xray_structure, pdb_hierarchy = self.get_best_model()
    f = open(file_name, "w")
    f.write("REMARK original PDB file:\n")
    f.write("REMARK   %s\n" % self.best_model_name)
    f.write(pdb_hierarchy.as_pdb_string(crystal_symmetry=xray_structure))
    f.close()

  def save_updated_data(self, file_name="best_model_data.mtz"):
    assert self.success()
    xray_structure, pdb_hierarchy = self.get_best_model()
    f_obs = self.f_obs.customized_copy(
      crystal_symmetry=xray_structure).eliminate_sys_absent()
    r_free_flags = self.r_free_flags.customized_copy(
      crystal_symmetry=xray_structure).eliminate_sys_absent()
    mtz_data = f_obs.as_mtz_dataset(column_root_label="F")
    mtz_data.add_miller_array(r_free_flags, column_root_label="FreeR_flag")
    mtz_data.mtz_object().write(file_name)

  def evaluate_model(self, args):
    xray_structure, pdb_hierarchy = args
    if (xray_structure is None):
      return None
    return evaluate_model(
      xray_structure=xray_structure,
      pdb_hierarchy=pdb_hierarchy,
      f_obs=self.f_obs,
      r_free_flags=self.r_free_flags,
      rigid_body_refine=self.params.rigid_body_refine,
      skip_twin_detection=self.skip_twin_detection)

  def space_group_info(self):
    xray_structure, pdb_hierarchy = self.get_best_model()
    return xray_structure.space_group_info()

strip_model_params = """
  remove_waters = True
    .type = bool
    .help = Remove all water molecules (HOH)
  remove_hydrogens = True
    .type = bool
    .help = Remove explicit hydrogen atoms
  remove_alt_confs = True
    .type = bool
    .help = Remove alternate conformations
  convert_semet_to_met = True
    .type = bool
    .help = Change MSE residues to MET
  convert_to_isotropic = True
    .type = bool
    .help = Convert atoms to anisotropic
  reset_occupancies = True
    .type = bool
    .help = Set occupancies to 1.0
  remove_ligands = False
    .type = bool
    .help = Remove all ligands
  reset_hetatm_flag = False
    .type = bool
    .help = Change HETATM records to ATOM
"""

def strip_model(
    pdb_hierarchy=None,
    xray_structure=None,
    file_name=None,
    params=None,
    remove_waters=True,
    remove_hydrogens=True,
    remove_alt_confs=True,
    convert_semet_to_met=True,
    convert_to_isotropic=True,
    reset_occupancies=True,
    remove_ligands=False,
    reset_hetatm_flag=False,
    preserve_remarks=False,
    preserve_symmetry=True,
    add_remarks=None,
    output_file=None,
    log=None):
  """
  Utility for removing extraneous records from a model intended for use in
  molecular replacement, etc., including waters, alternate conformations,
  and other features specific to a particular dataset.
  """
  if (params is not None):
    remove_waters = params.remove_waters
    remove_hydrogens = params.remove_hydrogens
    remove_alt_confs = params.remove_alt_confs
    convert_semet_to_met = params.convert_semet_to_met
    convert_to_isotropic = params.convert_to_isotropic
    reset_occupancies = params.reset_occupancies
    remove_ligands = params.remove_ligands
    reset_hetatm_flag = params.reset_hetatm_flag
  if (log is None):
    log = null_out()
  make_sub_header("Processing input model", out=log)
  remarks = None
  if (file_name is not None):
    print("Reading model from %s" % file_name, file=log)
    assert ([pdb_hierarchy, xray_structure] == [None, None])
    import iotbx.pdb
    pdb_in = iotbx.pdb.input(file_name)
    remarks = pdb_in.remark_section()
    pdb_hierarchy = pdb_in.construct_hierarchy()
    xray_structure = pdb_in.xray_structure_simple()
  else :
    # XXX work with copies, not the original structure
    pdb_hierarchy = pdb_hierarchy.deep_copy()
    xray_structure = xray_structure.deep_copy_scatterers()
  pdb_hierarchy.atoms().reset_i_seq()
  if (len(pdb_hierarchy.models()) > 1):
    raise Sorry("Multiple models not supported.")
  if (remove_hydrogens):
    sele = ~(xray_structure.hd_selection())
    n_hd = sele.count(False)
    if (n_hd > 0):
      pdb_hierarchy = pdb_hierarchy.select(sele)
      xray_structure = xray_structure.select(sele)
      print("  removed %d hydrogens" % n_hd, file=log)
      pdb_hierarchy.atoms().reset_i_seq()
  if (remove_waters):
    sele = pdb_hierarchy.atom_selection_cache().selection("not (resname HOH)")
    n_wat = sele.count(False)
    if (n_wat > 0):
      pdb_hierarchy = pdb_hierarchy.select(sele)
      xray_structure = xray_structure.select(sele)
      print("  removed %d waters" % n_wat, file=log)
      pdb_hierarchy.atoms().reset_i_seq()
  if (remove_alt_confs):
    n_atoms_start = xray_structure.scatterers().size()
    pdb_hierarchy.remove_alt_confs(always_keep_one_conformer=False)
    i_seqs = pdb_hierarchy.atoms().extract_i_seq()
    n_atoms_end = i_seqs.size()
    if (n_atoms_end != n_atoms_start):
      print("  removed %d atoms in alternate conformations" % \
        (n_atoms_end - n_atoms_start), file=log)
    xray_structure = xray_structure.select(i_seqs)
    pdb_hierarchy.atoms().reset_i_seq()
  if (convert_semet_to_met):
    # XXX need to start from a copy here because the atom-parent relationship
    # seems to be messed up otherwise.  this is probably a bug.
    pdb_hierarchy = pdb_hierarchy.deep_copy()
    pdb_hierarchy.convert_semet_to_met()
  if (convert_to_isotropic):
    xray_structure.convert_to_isotropic()
    pdb_hierarchy.adopt_xray_structure(xray_structure)
    print("  converted all atoms to isotropic B-factors", file=log)
  if (reset_occupancies):
    assert (remove_alt_confs)
    xray_structure.adjust_occupancy(occ_max=1.0, occ_min=1.0)
    pdb_hierarchy.adopt_xray_structure(xray_structure)
    print("  reset occupancy to 1.0 for all atoms", file=log)
  if (reset_hetatm_flag):
    for atom in pdb_hierarchy.atoms():
      atom.hetero = False
  if (remove_ligands):
    pdb_hierarchy.atoms().reset_i_seq()
    model = pdb_hierarchy.only_model()
    for chain in model.chains():
      if (not chain.is_protein()) and (not chain.is_na()):
        print("  removing %d ligand atoms in chain '%s'" % \
          (len(chain.atoms()), chain.id), file=log)
        model.remove_chain(chain)
    i_seqs = pdb_hierarchy.atoms().extract_i_seq()
    xray_structure = xray_structure.select(i_seqs)
    pdb_hierarchy.atoms().reset_i_seq()
  assert xray_structure.scatterers().size() == pdb_hierarchy.atoms_size()
  if (output_file is not None):
    f = open(output_file, "w")
    if (add_remarks is not None):
      f.write("\n".join(add_remarks))
      f.write("\n")
    if (preserve_remarks) and (remarks is not None):
      f.write("\n".join(remarks))
      f.write("\n")
    symm = None
    if (preserve_symmetry):
      symm = xray_structure
    f.write(pdb_hierarchy.as_pdb_string(crystal_symmetry=symm))
    f.close()
    print("  wrote model to %s" % output_file, file=log)
  return pdb_hierarchy, xray_structure


 *******************************************************************************


 *******************************************************************************
mmtbx/refinement/tardy.py
from __future__ import absolute_import, division, print_function
from mmtbx.dynamics import \
  kinetic_energy_as_temperature, \
  temperature_as_kinetic_energy
from mmtbx.dynamics.constants import akma_time_as_pico_seconds
from cctbx import xray
import cctbx.geometry_restraints
from cctbx.array_family import flex
import scitbx.rigid_body
from scitbx.graph import tardy_tree
from scitbx import matrix
from libtbx.utils import Sorry
from libtbx.str_utils import format_value, show_string
from libtbx import group_args
import os
from six.moves import range
op = os.path

master_phil_str = """\
  xray_weight_factor = 10
    .type = float
  start_temperature_kelvin = 2500
    .type = float
  final_temperature_kelvin = 300
    .type = float
  velocity_scaling = True
    .type = bool
  temperature_cap_factor = 1.5
    .type = float
  excessive_temperature_factor = 5
    .type = float
  number_of_cooling_steps = 500
    .type = int
  number_of_time_steps = 1
    .type = int
  time_step_pico_seconds = 0.001
    .type = float
  temperature_degrees_of_freedom = *cartesian constrained
    .type = choice
    .optional = False
  minimization_max_iterations = 0
    .type = int
  prolsq_repulsion_function_changes
    .help = "energy(delta) = "
            "c_rep*(max(0,(k_rep*vdw_distance)**irexp-delta**irexp))**rexp"
  {
    c_rep = None
      .type = float
      .help = "Usual value: 16"
    k_rep = 0.75
      .type = float
      .help = "Usual value: 1."
              "Smaller values reduce the distance threshold at which"
              "the repulsive force becomes active."
    irexp = None
      .type = float
      .help = "Usual value: 1"
    rexp = None
      .type = float
      .help = "Usual value: 4"
  }
  omit_bonds_with_slack_greater_than = 0
    .type = float
  constrain_dihedrals_with_sigma_less_than = 10
    .type = float
  near_singular_hinges_angular_tolerance_deg = 5
    .type = float
  emulate_cartesian = False
    .type = bool
  trajectory_directory = None
    .type = path
    .expert_level = 3
"""

class potential_object(object):

  def __init__(O,
        xray_weight_factor,
        prolsq_repulsion_function_changes,
        fmodels,
        model,
        target_weights,
        reduced_geo_manager):
    O.xray_weight_factor = xray_weight_factor
    O.fmodels = fmodels
    O.model = model
    O.weights = target_weights.xyz_weights_result
    O.reduced_geo_manager = reduced_geo_manager
    c = prolsq_repulsion_function_changes
    if (    c.c_rep is None
        and c.k_rep is None
        and c.irexp is None
        and c.rexp is None):
      O.custom_nonbonded_function = None
    else:
      nonbonded_function = model.restraints_manager.geometry.nonbonded_function
      assert isinstance(
        nonbonded_function,
        cctbx.geometry_restraints.prolsq_repulsion_function)
      O.custom_nonbonded_function = nonbonded_function.customized_copy(
        c_rep=c.c_rep,
        k_rep=c.k_rep,
        irexp=c.irexp,
        rexp=c.rexp)
    O.fmodels.create_target_functors()
    O.fmodels.prepare_target_functors_for_minimization()
    O.allowed_origin_shifts_need_to_be_suppressed = \
      O.fmodels.target_functions_are_invariant_under_allowed_origin_shifts()
    O.last_sites_moved = None
    O.f = None
    O.g = None
    O.last_grms = None

  def crystal_symmetry(O):
    return O.model.restraints_manager.geometry.crystal_symmetry

  def e_pot(O, sites_moved):
    if (   O.last_sites_moved is None
        or O.last_sites_moved.id() != sites_moved.id()):
      O.last_sites_moved = sites_moved
      xs = O.fmodels.fmodel_xray().xray_structure
      assert len(sites_moved) == xs.scatterers().size()
      sites_cart = sites_moved
      xs.set_sites_cart(sites_cart=sites_cart)
      O.fmodels.update_xray_structure(update_f_calc=True)
      xs.scatterers().flags_set_grads(state=False)
      xs.scatterers().flags_set_grad_site(
        iselection=flex.size_t_range(xs.scatterers().size()))
      expected_g_size = len(sites_moved) * 3
      if (O.xray_weight_factor is not None):
        tg = O.fmodels.target_and_gradients(
          weights=O.weights,
          compute_gradients=True)
        O.f = tg.target() * O.xray_weight_factor
        O.g = tg.gradients() * O.xray_weight_factor
        assert O.g.size() == expected_g_size
      else:
        O.f = 0.
        O.g = flex.double(expected_g_size, 0)
      if (O.reduced_geo_manager is None):
        reduced_geo_energies = None
      else:
        reduced_geo_energies = O.reduced_geo_manager.energies_sites(
          sites_cart=sites_cart,
          compute_gradients=True)
      other_energies = O.model.restraints_manager.energies_sites(
        sites_cart=sites_cart,
        geometry_flags=cctbx.geometry_restraints.flags.flags(nonbonded=True),
        custom_nonbonded_function=O.custom_nonbonded_function,
        compute_gradients=True)
      nfw = other_energies.normalization_factor * O.weights.w
      O.f += other_energies.target * O.weights.w
      gg = other_energies.gradients * O.weights.w
      if (reduced_geo_energies is not None):
        O.f += reduced_geo_energies.target * nfw
        gg += reduced_geo_energies.gradients * nfw
      assert nfw != 0
      scale = 1 / nfw
      O.last_grms = group_args(
        geo=scale*flex.mean_sq(gg.as_double())**0.5,
        xray=scale*flex.mean_sq(O.g)**0.5,
        real_or_xray="xray")
      xray.minimization.add_gradients(
        scatterers=xs.scatterers(),
        xray_gradients=O.g,
        site_gradients=gg)
      O.f *= scale
      O.g *= scale
      O.last_grms.total = flex.mean_sq(O.g)**0.5
      O.g = flex.vec3_double(O.g)
    return O.f

  def d_e_pot_d_sites(O, sites_moved):
    O.e_pot(sites_moved=sites_moved)
    return O.g

def run(fmodels, model, target_weights, params, log,
        format_for_phenix_refine=False, monitor=None,
        call_back_after_step=True):
  assert fmodels.fmodel_neutron() is None # not implemented
  assert model.ias_manager is None # tardy+ias is not a useful combination
  xs = fmodels.fmodel_xray().xray_structure
  sites_cart_start = xs.sites_cart()
  sites = sites_cart_start
  labels = [sc.label for sc in xs.scatterers()]
  if (params.emulate_cartesian):
    tt = scitbx.graph.tardy_tree.construct(
      n_vertices=len(sites), edge_list=[])
    tt.build_tree()
  else:
    tt = model.restraints_manager.geometry.construct_tardy_tree(
      sites=sites,
      selection=model.refinement_flags.sites_torsion_angles,
      omit_bonds_with_slack_greater_than
        =params.omit_bonds_with_slack_greater_than,
      constrain_dihedrals_with_sigma_less_than
        =params.constrain_dihedrals_with_sigma_less_than,
      near_singular_hinges_angular_tolerance_deg
        =params.near_singular_hinges_angular_tolerance_deg)
  print("tardy_tree summary:", file=log)
  tt.show_summary(vertex_labels=labels, out=log, prefix="  ")
  print(file=log)
  log.flush()
  if (params.emulate_cartesian):
    reduced_geo_manager = None
  else:
    include_den_restraints = False
    if model.restraints_manager.geometry.den_manager is not None:
      if "torsion" in model.restraints_manager.geometry. \
         den_manager.params.annealing_type:
        include_den_restraints = True
    reduced_geo_manager = model.restraints_manager.geometry \
      .reduce_for_tardy(
        tardy_tree=tt,
        omit_bonds_with_slack_greater_than
          =params.omit_bonds_with_slack_greater_than,
        include_den_restraints=include_den_restraints)
  potential_obj = potential_object(
    xray_weight_factor=params.xray_weight_factor,
    prolsq_repulsion_function_changes=params.prolsq_repulsion_function_changes,
    fmodels=fmodels,
    model=model,
    target_weights=target_weights,
    reduced_geo_manager=reduced_geo_manager)
  tardy_model = scitbx.rigid_body.tardy_model(
    labels=labels,
    sites=sites,
    masses=xs.atomic_weights(),
    tardy_tree=tt,
    potential_obj=potential_obj,
    near_singular_hinges_angular_tolerance_deg=
      params.near_singular_hinges_angular_tolerance_deg)
  def refinement_callback(fmodel):
    if (monitor is not None) and (call_back_after_step):
      monitor.call_back(model, fmodel, "torsion_dynamics")
  action( # XXX neutron
    tardy_model=tardy_model,
    params=params,
    rmsd_calculator=tt.rmsd_calculator(),
    callback=None,
    log=log,
    fmodel=fmodels.fmodel_xray(),
    format_for_phenix_refine=format_for_phenix_refine,
    refinement_callback=refinement_callback)

def action(
      tardy_model,
      params,
      rmsd_calculator,
      callback,
      log,
      fmodel=None,
      format_for_phenix_refine=False,
      refinement_callback=None):
  sites_cart_start = tardy_model.sites_moved()
  qd_e_kin_scales = tardy_model.assign_random_velocities()
  traj_dir = params.trajectory_directory
  if (traj_dir is not None):
    print("Creating trajectory directory: %s" % show_string(traj_dir), file=log)
    from libtbx.path import move_old_create_new_directory
    move_old_create_new_directory(path=traj_dir)
    from libtbx import easy_pickle
    easy_pickle.dump(
      file_name=op.join(traj_dir, "labels"),
      obj=tardy_model.labels)
    traj_serial_fmt = "sites_%%0%dd" % len(
      "%d" % (params.number_of_cooling_steps * params.number_of_time_steps))
    easy_pickle.dump(
      file_name=op.join(traj_dir, traj_serial_fmt % 0),
      obj=sites_cart_start)
    if (fmodel is not None):
      easy_pickle.dump(
        file_name=op.join(traj_dir, "xray_structure"),
        obj=fmodel.xray_structure)
    print(file=log)
  cartesian_dof = sites_cart_start.size() * 3
  if   (params.temperature_degrees_of_freedom == "cartesian"):
    temperature_dof = cartesian_dof
  elif (params.temperature_degrees_of_freedom == "constrained"):
    temperature_dof = tardy_model.degrees_of_freedom
  else:
    raise RuntimeError(
      "Unknown temperature_degrees_of_freedom: %s"
        % params.temperature_degrees_of_freedom)
  def e_as_t(e):
    return kinetic_energy_as_temperature(dof=temperature_dof, e=e)
  def t_as_e(t):
    return temperature_as_kinetic_energy(dof=temperature_dof, t=t)
  time_step_akma = params.time_step_pico_seconds / akma_time_as_pico_seconds
  print("tardy dynamics:", file=log)
  print("  number of bodies:", tardy_model.bodies_size(), file=log)
  fmt = "%%%dd" % len(str(cartesian_dof))
  print("  number of degrees of freedom:", \
    fmt % tardy_model.degrees_of_freedom, file=log)
  print("           number of atoms * 3:", fmt % cartesian_dof, file=log)
  print("                         ratio: %.3f = 1/%.2f" % (
    tardy_model.degrees_of_freedom / max(1, cartesian_dof),
    cartesian_dof / max(1, tardy_model.degrees_of_freedom)), file=log)
  print("  temperature degrees of freedom: %s (%d)" % (
    params.temperature_degrees_of_freedom, temperature_dof), file=log)
  print("  kinetic energy sensitivity to generalized velocities:", file=log)
  qd_e_kin_scales.min_max_mean().show(out=log, prefix="    ")
  print("  time step: %7.5f pico seconds" % (
    params.time_step_pico_seconds), file=log)
  print("  velocity scaling:", params.velocity_scaling, file=log)
  allowed_origin_shifts_need_to_be_suppressed = tardy_model.potential_obj \
    .allowed_origin_shifts_need_to_be_suppressed
  print("  suppressing allowed origin shifts:", \
    allowed_origin_shifts_need_to_be_suppressed, file=log)
  log.flush()
  if (callback is not None):
    if (callback(
          tardy_model=tardy_model,
          rmsd_calculator=rmsd_calculator) == False):
      return
  if (allowed_origin_shifts_need_to_be_suppressed):
    number_of_sites_in_each_tree = tardy_model.number_of_sites_in_each_tree()
    crystal_symmetry = tardy_model.potential_obj.crystal_symmetry()
    assert crystal_symmetry is not None
    allowed_origin_shift_velocity_corrections = flex.double()
    sum_of_allowed_origin_shift_velocity_corrections = [matrix.col((0,0,0))]
  def suppress_allowed_origin_shifts(collect_stats):
    if (not allowed_origin_shifts_need_to_be_suppressed):
      return
    mlv = tardy_model.mean_linear_velocity(
      number_of_sites_in_each_tree=number_of_sites_in_each_tree)
    if (mlv is not None):
      mlv = matrix.col(mlv)
      mlv_perp = matrix.col(
        crystal_symmetry.subtract_continuous_allowed_origin_shifts(
          translation_cart=mlv))
      correction = mlv - mlv_perp
      tardy_model.subtract_from_linear_velocities(
        number_of_sites_in_each_tree=number_of_sites_in_each_tree,
        value=correction)
      if (collect_stats):
        allowed_origin_shift_velocity_corrections.append(abs(correction))
        sum_of_allowed_origin_shift_velocity_corrections[0] += correction
  suppress_allowed_origin_shifts(collect_stats=False)
  n_time_steps = 0
  den_update_interval = None
  if (tardy_model.potential_obj.reduced_geo_manager is not None):
    den_update_interval = (50 *params.number_of_cooling_steps /
        (params.start_temperature_kelvin - params.final_temperature_kelvin))
    den_update_interval = int(round(den_update_interval))
  for i_cool_step in range(params.number_of_cooling_steps+1):
    if (params.number_of_cooling_steps == 0):
      if (   params.start_temperature_kelvin
          != params.final_temperature_kelvin):
        break
      t_target = params.start_temperature_kelvin
    else:
      t_target = params.start_temperature_kelvin \
               - i_cool_step * (  params.start_temperature_kelvin
                                - params.final_temperature_kelvin) \
                             / params.number_of_cooling_steps
    if (tardy_model.potential_obj.reduced_geo_manager is not None):
      if (tardy_model.potential_obj.reduced_geo_manager. \
          den_manager is not None) and \
         i_cool_step > 0 and not (i_cool_step)%den_update_interval:
        print("   update DEN eq distances at step %d, temp=%.1f" % \
          ( (n_time_steps), t_target), file=log)
        tardy_model.potential_obj.reduced_geo_manager. \
          den_manager.update_eq_distances(
            sites_cart=tardy_model.sites_moved())
    e_kin_target = t_as_e(t=t_target)
    def reset_e_kin(msg):
      tardy_model.reset_e_kin(e_kin_target=e_kin_target)
      print("  %s temperature: %8.2f K" % (
        msg, e_as_t(e=tardy_model.e_kin())), file=log)
      log.flush()
      return True
    if (   n_time_steps == 0
        or params.number_of_time_steps > 1):
      show_column_headings = reset_e_kin("new target")
    for i_time_step in range(params.number_of_time_steps):
      assert params.temperature_cap_factor > 1.0
      assert params.excessive_temperature_factor > params.temperature_cap_factor
      if (tardy_model.e_kin() > e_kin_target * params.temperature_cap_factor):
        print("  system temperature is too high:", file=log)
        if (tardy_model.e_kin()
              > e_kin_target * params.excessive_temperature_factor):
          print("    excessive_temperature_factor: %.6g" % \
            params.excessive_temperature_factor, file=log)
          print("    excessive temperature limit: %.2f K" % (
            t_target * params.excessive_temperature_factor), file=log)
          print("    time_step_pico_seconds: %.6g" % (
            params.time_step_pico_seconds), file=log)
          log.flush()
          raise Sorry(
            "Excessive system temperature in torsion angle dynamics:\n"
            "  Please try again with a smaller time_step_pico_seconds.")
        print("     temperature_cap_factor: %.6g" % \
          params.temperature_cap_factor, file=log)
        print("     temperature cap: %.2f K" % (
          t_target * params.temperature_cap_factor), file=log)
        show_column_headings = reset_e_kin("resetting")
      e_kin_before, e_tot_before = tardy_model.e_kin(), tardy_model.e_tot()
      tardy_model.dynamics_step(delta_t=time_step_akma)
      suppress_allowed_origin_shifts(collect_stats=True)
      e_kin_after, e_tot_after = tardy_model.e_kin(), tardy_model.e_tot()
      if (e_tot_before > e_tot_after):
        fluct_e_tot = -e_tot_after / e_tot_before
      elif (e_tot_after > e_tot_before):
        fluct_e_tot = e_tot_before / e_tot_after
      else:
        fluct_e_tot = None
      if (params.velocity_scaling):
        tardy_model.reset_e_kin(e_kin_target=e_kin_target)
      n_time_steps += 1
      if (traj_dir is not None):
        easy_pickle.dump(
          file_name=op.join(traj_dir, traj_serial_fmt % n_time_steps),
          obj=tardy_model.sites_moved())
      grms = tardy_model.potential_obj.last_grms
      if(format_for_phenix_refine):
        if(n_time_steps==1 or not n_time_steps%25):
          fmtr = "   step=%s temperature=%s rmsd=%s r_work=%s r_free=%s"
          rmsd = rmsd_calculator(tardy_model.sites_moved(), sites_cart_start)
          print(fmtr%(
            format_value("%5d", n_time_steps),
            format_value("%7.1f", e_as_t(e=tardy_model.e_kin())),
            format_value("%6.4f", rmsd),
            format_value("%6.4f", fmodel.r_work()),
            format_value("%6.4f", fmodel.r_free())), file=log)
          if hasattr(refinement_callback, "__call__"):
            refinement_callback(fmodel) # for phenix.refine GUI
      else:
        if (show_column_headings):
          show_column_headings = False
          log.write("""\
            coordinate                   fluctuations        gradient rms
    step      rmsd        temp        temp   e_total     geo %    7s   total
""" % grms.real_or_xray)
        print("    %4d  %8.4f A  %8.2f K  %8.2f K  %s" \
          "  %6.2f  %6.2f  %6.2f" % (
            n_time_steps,
            rmsd_calculator(tardy_model.sites_moved(), sites_cart_start),
            e_as_t(e=tardy_model.e_kin()),
            e_as_t(e=e_kin_after-e_kin_before),
            format_value(format="%6.3f", value=fluct_e_tot),
            grms.geo,
            getattr(grms, grms.real_or_xray),
            grms.total), file=log)
      log.flush()
      if (callback is not None):
        if (callback() == False): return
  if (allowed_origin_shifts_need_to_be_suppressed):
    print("  allowed origin shift velocity corrections applied (magnitudes):", file=log)
    allowed_origin_shift_velocity_corrections.min_max_mean().show(
      out=log, prefix="    ")
    print("  sum of allowed origin shift velocity corrections (vectors):", file=log)
    print("   ", numstr(
      values=sum_of_allowed_origin_shift_velocity_corrections[0].elems,
      fmt="%.5f",
      brackets=("(",")")), file=log)
  if (   params.minimization_max_iterations is None
      or params.minimization_max_iterations > 0):
    print("tardy gradient-driven minimization:", file=log)
    log.flush()
    def show_rms(minimizer=None):
      print("  coor. rmsd: %8.4f" % (
        rmsd_calculator(tardy_model.sites_moved(), sites_cart_start)), file=log)
      log.flush()
      if (callback is not None):
        if (callback() == False): raise StopIteration
    try:
      refinery = tardy_model.minimization(
        max_iterations=params.minimization_max_iterations,
        callback_after_step=show_rms)
    except StopIteration:
      return
    print("After tardy minimization:", file=log)
    show_rms()
    print("  number of function evaluations:", \
      refinery.function_evaluations_total, file=log)
    print("  number of lbfgs steps:", refinery.lbfgs_steps_total, file=log)
    print("  number of lbfgs restarts:", refinery.lbfgs_restarts, file=log)
    print(file=log)


 *******************************************************************************


 *******************************************************************************
mmtbx/refinement/targets.py
from __future__ import absolute_import, division, print_function
import libtbx.load_env
if(not libtbx.env.has_module(name="phaser")):
  phaser = None
else:
  import phaser.phenix_adaptors.sad_target
from cctbx.array_family import flex
from cctbx import xray
import boost_adaptbx.boost.python as bp
from libtbx.utils import Sorry, user_plus_sys_time
from cctbx.eltbx.xray_scattering import wk1995
from cctbx import adptbx
from libtbx import adopt_init_args


ext = bp.import_ext("mmtbx_f_model_ext")

time_bulk_solvent_and_scale         = 0.0
time_mask                           = 0.0
time_f_calc                         = 0.0
time_alpha_beta                     = 0.0
time_target                         = 0.0
time_gradients_wrt_atomic_parameters = 0.0
time_fmodel_core_data               = 0.0
time_r_factors                      = 0.0
time_phase_errors                   = 0.0
time_foms                           = 0.0
time_show                           = 0.0

class target_attributes(object):

  def __init__(self, family, specialization=None):
    adopt_init_args(self, locals())
    assert self.validate()

  def validate(self):
    if (self.family == "lsm"):
      self.family = "ls"
      self.pseudo_ml = True
    else:
      self.pseudo_ml = False
    if (self.family == "ls"):
      return self.specialization is None
    elif (self.family == "ml"):
      return self.specialization in [None, "hl", "sad", "i", "f"]
    return False

  def requires_experimental_phases(self):
    return (self.family == "ml" and self.specialization == "hl")

target_names = {
  "ls_wunit_k1": target_attributes("ls"),
  "ls_wunit_kunit": target_attributes("ls"),
  "ls_wunit_k1_fixed": target_attributes("ls"),
  "ls_wunit_k1ask3_fixed": target_attributes("ls"),
  "ls_wexp_k1": target_attributes("ls"),
  "ls_wexp_kunit": target_attributes("ls"),
  "ls_wff_k1": target_attributes("ls"),
  "ls_wff_kunit": target_attributes("ls"),
  "ls_wff_k1_fixed": target_attributes("ls"),
  "ls_wff_k1ask3_fixed": target_attributes("ls"),
  "lsm_k1": target_attributes("lsm"),
  "lsm_kunit": target_attributes("lsm"),
  "lsm_k1_fixed": target_attributes("lsm"),
  "lsm_k1ask3_fixed": target_attributes("lsm"),
  "ml": target_attributes("ml", "f"),
  "mli": target_attributes("ml","i"),
  "mlhl": target_attributes("ml", "hl"),
  "ml_sad": target_attributes("ml", "sad")}

class phaser_sad_target_functor(object):

  def __init__(self,
        f_obs,
        r_free_flags,
        xray_structure,
        f_calc,
        target_memory):
    self.f_obs = f_obs
    self.r_free_flags = r_free_flags
    self.xray_structure = xray_structure
    self.f_calc = f_calc
    if (target_memory is None): # XXX could be more elegant!
      den = self.f_obs.data()
      num = flex.abs(self.f_calc.data())
      denom = flex.sum(num*den)
      numerator = flex.sum(den*den)
      if (denom == 0):
        raise RuntimeError("Zero denominator in scale calculation.")
      previous_overall_scaleK = numerator/denom
      previous_overall_scaleU = 0.
      previous_variances = None
      adaptor = phaser.phenix_adaptors.sad_target.data_adaptor(
        f_obs=f_obs,
        r_free_flags=r_free_flags,
        verbose=True)
      self.refine_sad_object = adaptor.target(
        xray_structure=xray_structure,
        previous_overall_scaleK=previous_overall_scaleK,
        previous_overall_scaleU=previous_overall_scaleU,
        previous_variances=previous_variances)
      self.refine_sad_object.set_f_calc(f_calc=f_calc)
      target_memory = self.target_memory()

    assert len(target_memory) == 4
    assert target_memory[0] == "ml_sad"
    previous_overall_scaleK = target_memory[1]
    previous_overall_scaleU = target_memory[2]
    previous_variances = target_memory[3]
    adaptor = phaser.phenix_adaptors.sad_target.data_adaptor(
      f_obs=f_obs,
      r_free_flags=r_free_flags,
      verbose=True)
    self.refine_sad_object = adaptor.target(
      xray_structure=xray_structure,
      previous_overall_scaleK=previous_overall_scaleK,
      previous_overall_scaleU=previous_overall_scaleU,
      previous_variances=previous_variances)
    self.refine_sad_object.set_f_calc(f_calc=f_calc)
    self.refine_sad_object.reject_outliers()

  def prepare_for_minimization(self):
    rso = self.refine_sad_object
    rso.refine_variance_terms()
    self.refined_overall_b_iso = adptbx.u_as_b(
          rso.refine_sad_instance.get_refined_scaleU())
    rso.refine_sad_instance.set_scaleU(0.)

  def target_memory(self):
    rsi = self.refine_sad_object.refine_sad_instance
    return ("ml_sad", rsi.get_refined_scaleK(),
                      rsi.get_refined_scaleU(),rsi.get_variance_array())

  def __call__(self, f_calc, compute_gradients):
    self.refine_sad_object.set_f_calc(f_calc=f_calc)
    rso = self.refine_sad_object
    target_work = rso.functional(use_working_set=True)
    da_db, daa_dbb_dab = rso.derivatives(curvs=True)
    target_test = rso.functional(use_working_set=False)
    return xray.targets_common_results(
      target_per_reflection=flex.double(),
      target_work=target_work,
      target_test=target_test,
      gradients_work=da_db.data(),
      hessians_work=daa_dbb_dab.data())

class target_functor(object):

  def __init__(self, manager, alpha_beta=None):
    self.manager = manager
    target_name = manager.target_name
    assert target_name is not None
    attr = manager.target_attributes()
    if (target_name == "ml_sad"):
      if (phaser is None):
        raise Sorry(
          "ml_sad target requires phaser extension, which is not available"
          " in this installation.")
      self.core = phaser_sad_target_functor(
        f_obs=manager.f_obs(),
        r_free_flags=manager.r_free_flags(),
        xray_structure=manager.xray_structure,
        f_calc=manager.f_model(),
        target_memory=manager._target_memory)
      manager._target_memory = self.core.target_memory()
    elif (attr.family == "ml"):
      if (attr.requires_experimental_phases()):
        experimental_phases = manager.hl_coeffs()
      else:
        experimental_phases = None
      if(alpha_beta is None): alpha_beta = manager.alpha_beta()
      self.core = xray.target_functors.max_like(
        f_obs                 = manager.f_obs(),
        r_free_flags          = manager.r_free_flags(),
        experimental_phases   = experimental_phases,
        alpha_beta            = alpha_beta,
        scale_factor          = manager.scale_ml_wrapper(),
        epsilons              = manager.epsilons,
        spacialization        = attr.specialization,
        integration_step_size = 5.0)
    else:
      if (attr.pseudo_ml):
        f_obs, weights = manager.f_star_w_star()
        weights = weights.data()
        if   (target_name == "lsm_k1"):
          scale_factor = 0
        elif (target_name == "lsm_k1ask3_fixed"):
          scale_factor = manager.scale_k3_w()
        elif (target_name == "lsm_k1_fixed"):
          scale_factor = manager.scale_k1_w()
        elif (target_name == "lsm_kunit"):
          scale_factor = 1.0
        else:
          raise RuntimeError
      else:
        f_obs = manager.f_obs()
        if (target_name.startswith("ls_wunit_")):
          weights = flex.double(f_obs.data().size(), 1.0)
          if   (target_name == "ls_wunit_k1"):
            scale_factor = 0
          elif (target_name == "ls_wunit_k1_fixed"):
            scale_factor = manager.scale_k1_w()
          elif (target_name == "ls_wunit_kunit"):
            scale_factor = 1.0
          elif (target_name == "ls_wunit_k1ask3_fixed"):
            scale_factor = manager.scale_k3_w()
          else:
            raise RuntimeError
        elif (target_name.startswith("ls_wexp_")):
          weights = ls_sigma_weights(f_obs)
          if   (target_name == "ls_wexp_k1"):
            scale_factor = 0
          elif (target_name == "ls_wexp_kunit"):
            scale_factor = 1.0
          else:
            raise RuntimeError
        elif (target_name.startswith("ls_wff_")):
          weights = ls_ff_weights(f_obs, "N", 25.0)
          if   (target_name == "ls_wff_k1"):
            scale_factor = 0
          elif (target_name == "ls_wff_k1_fixed"):
            scale_factor = manager.scale_k1_w()
          elif (target_name == "ls_wff_k1ask3_fixed"):
            scale_factor = manager.scale_k3_w()
          elif (target_name == "ls_wff_kunit"):
            scale_factor = 1.0
          else:
            raise RuntimeError
        else:
          raise RuntimeError
      self.core = xray.target_functors.least_squares(
        compute_scale_using_all_data=False,
        f_obs=f_obs,
        r_free_flags=manager.r_free_flags(),
        weights=weights,
        scale_factor=scale_factor)

  def prepare_for_minimization(self):
    if (self.manager.target_name == "ml_sad"):
      self.core.prepare_for_minimization()

  def target_function_is_invariant_under_allowed_origin_shifts(self):
    return (self.manager.target_name != "mlhl")

  def __call__(self, compute_gradients=False):
    try:
      result = target_result(
        manager=self.manager,
        core_result=self.core(
          f_calc=self.manager.f_model(),
          compute_gradients=compute_gradients))
    except RuntimeError as e:
      if str(e) == "mli target is not implemented (yet)!":
        raise Sorry("mli target is not implemented (yet). Pick another target.")
      else:
        raise e
    target_memory = getattr(self.core, "target_memory", None)
    if (target_memory is not None):
      self.manager._target_memory = target_memory()
    return result

class target_result_mixin(object):

  def gradients_wrt_atomic_parameters(self,
        selection=None,
        site=False,
        u_iso=False,
        u_aniso=False,
        occupancy=False,
        tan_b_iso_max=None,
        u_iso_refinable_params=None):
    if (tan_b_iso_max is not None and tan_b_iso_max != 0):
      raise RuntimeError("Not implemented:\n"
        "  See CVS revision 1.87, 2007/03/03 01:53:05\n"
        "  method: manager.gradient_wrt_atomic_parameters()")
    global time_gradients_wrt_atomic_parameters
    timer = user_plus_sys_time()
    manager = self.manager
    xray_structure = manager.xray_structure
    if (selection is not None):
      xray_structure = xray_structure.select(selection)
    d_target_d_f_calc = self.d_target_d_f_calc_work()
    result = None
    if (u_aniso):
      result = manager.structure_factor_gradients_w(
        u_iso_refinable_params=None,
        d_target_d_f_calc=d_target_d_f_calc.data(),
        xray_structure=xray_structure,
        n_parameters=0,
        miller_set=d_target_d_f_calc,
        algorithm=manager.sfg_params.algorithm).d_target_d_u_cart()
    elif(u_iso):
      result = manager.structure_factor_gradients_w(
        u_iso_refinable_params=None,
        d_target_d_f_calc=d_target_d_f_calc.data(),
        xray_structure=xray_structure,
        n_parameters=0,
        miller_set=d_target_d_f_calc,
        algorithm=manager.sfg_params.algorithm).d_target_d_u_iso()
    elif(occupancy):
      result = manager.structure_factor_gradients_w(
        u_iso_refinable_params=None,
        d_target_d_f_calc=d_target_d_f_calc.data(),
        xray_structure=xray_structure,
        n_parameters=0,
        miller_set=d_target_d_f_calc,
        algorithm=manager.sfg_params.algorithm).d_target_d_occupancy()
    else:
      # XXX discamb
      if manager.is_taam(): # XXX discamb
        #manager.discamb_wrapper.set_indices(d_target_d_f_calc.indices())
        #result = manager.discamb_wrapper.d_target_d_params(
        #  list(d_target_d_f_calc.data()))
         result = manager.discamb_wrapper.d_target_d_params(d_target_d_f_calc)
      # XXX discamb
      else:
        result = manager.structure_factor_gradients_w(
          u_iso_refinable_params=u_iso_refinable_params,
          d_target_d_f_calc=d_target_d_f_calc.data(),
          xray_structure=xray_structure,
          n_parameters=xray_structure.n_parameters(),
          miller_set=d_target_d_f_calc,
          algorithm=manager.sfg_params.algorithm)
    time_gradients_wrt_atomic_parameters += timer.elapsed()
    return result

  def d_target_d_site_cart(self):
    manager = self.manager
    xray.set_scatterer_grad_flags(
      scatterers=manager.xray_structure.scatterers(),
      site=True)
    return flex.vec3_double(
      self.gradients_wrt_atomic_parameters().packed())

class target_result(target_result_mixin):

  def __init__(self, manager, core_result):
    self.manager = manager
    self.core_result = core_result

  def target_per_reflection(self):
    return self.core_result.target_per_reflection()

  def target_work(self):
    return self.core_result.target_work()

  def target_test(self):
    return self.core_result.target_test()

  def d_target_d_f_model_work(self):
    return self.manager.f_obs_work().array(
      data=self.core_result.gradients_work())

  def d_target_d_f_calc_work(self):
    return self.manager.f_obs_work().array(
      data=self.core_result.gradients_work()
          *self.manager.k_anisotropic_work()*self.manager.k_isotropic_work())

def ls_ff_weights(f_obs, atom, B):
  d_star_sq_data = f_obs.d_star_sq().data()
  table = wk1995(atom).fetch()
  ff = table.at_d_star_sq(d_star_sq_data) * flex.exp(-B/4.0*d_star_sq_data)
  weights = 1.0/flex.pow2(ff)
  return weights

def ls_sigma_weights(f_obs):
  if(f_obs.sigmas() is not None):
     sigmas_squared = flex.pow2(f_obs.sigmas())
  else:
     sigmas_squared = flex.double(f_obs.data().size(), 1.0)
  assert sigmas_squared.all_gt(0)
  weights = 1 / sigmas_squared
  return weights


 *******************************************************************************


 *******************************************************************************
mmtbx/refinement/tst_anomalous_scatterer_groups.py
from __future__ import absolute_import, division, print_function
import mmtbx.refinement.anomalous_scatterer_groups
import mmtbx.f_model
from cctbx.development import random_structure
from cctbx.development import debug_utils
from cctbx import xray
from cctbx.array_family import flex
from libtbx.test_utils import approx_equal
import random
import sys
from six.moves import zip

if (1):
  random.seed(0)
  flex.set_random_seed(0)

def run_call_back(flags, space_group_info):
  d_min = 2.0
  structure = random_structure.xray_structure(
    space_group_info=space_group_info,
    elements=["N", "C", "O", "S"]*3 + ["Fe"]*2,
    volume_per_atom=100)
  if (not space_group_info.group().is_centric()):
    fp_fdp_targets = [(-1,2), (-2,6)]
  else:
    fp_fdp_targets = [(-1,0), (-2,0)]
  anomalous_scatterer_groups = [
    xray.anomalous_scatterer_group(
      iselection=flex.size_t(),
      f_prime=fp,
      f_double_prime=fdp,
      refine=["f_prime", "f_double_prime"]) for fp,fdp in fp_fdp_targets]
  for i_seq,scatterer in enumerate(structure.scatterers()):
    if (scatterer.scattering_type == "S"):
      anomalous_scatterer_groups[0].iselection.append(i_seq)
    if (scatterer.scattering_type == "Fe"):
      anomalous_scatterer_groups[1].iselection.append(i_seq)
  for group in anomalous_scatterer_groups:
    group.copy_to_scatterers_in_place(scatterers=structure.scatterers())
  if (flags.Verbose):
    structure.show_summary().show_scatterers()
  f_obs = abs(structure.structure_factors(
    d_min=2.0, anomalous_flag=True).f_calc())
  if (flags.Verbose):
    f_obs.show_comprehensive_summary()
  #
  for group in anomalous_scatterer_groups:
    group.f_prime = 0
    group.f_double_prime = 0
    group.copy_to_scatterers_in_place(scatterers=structure.scatterers())
  sfg_params = mmtbx.f_model.sf_and_grads_accuracy_master_params.extract()
  sfg_params.algorithm = "direct"
  fmodel = mmtbx.f_model.manager(
    xray_structure=structure,
    f_obs=f_obs,
    r_free_flags=f_obs.generate_r_free_flags(),
    sf_and_grads_accuracy_params = sfg_params,
    target_name="ls")
  #
  n_cycles = [0]
  def call_back(minimizer):
    n_cycles[0] += 1
    return True
  minimized = mmtbx.refinement.anomalous_scatterer_groups.minimizer(
    fmodel=fmodel,
    groups=anomalous_scatterer_groups,
    call_back_after_minimizer_cycle=call_back,
    number_of_finite_difference_tests=3)
  assert n_cycles == [3]
  #
  for group,(fp,fdp) in zip(anomalous_scatterer_groups, fp_fdp_targets):
    # Large eps because the minimization doesn't reliably converge.
    # We don't want to exercise the minimizer here, the important
    # test is the finite difference test embedded in the minimizer.
    assert approx_equal(group.f_prime, fp, eps=1)
    assert approx_equal(group.f_double_prime, fdp, eps=1)

def exercise():
  debug_utils.parse_options_loop_space_groups(sys.argv[1:], run_call_back)

if (__name__ == "__main__"):
  exercise()


 *******************************************************************************


 *******************************************************************************
mmtbx/refinement/tst_fit_rotamers.py
from __future__ import absolute_import, division, print_function
from six.moves import range
def exercise_rotate_point_around_axis():
  from scitbx.matrix import col, rotate_point_around_axis
  cb = col([7.767, 5.853, 7.671])
  cg = col([6.935, 5.032, 8.622])
  ca = col([7.000, 7.000, 7.000])
  count_unchanged = 0
  for angle_i in range(-360,361,15):
    cg_r = col(rotate_point_around_axis(
      axis_point_1=ca, axis_point_2=cb, point=cg, angle=angle_i, deg=True))
    assert abs(abs(cb-cg)-abs(cb-cg_r)) < 1.e-6
    assert abs(abs(ca-cg)-abs(ca-cg_r)) < 1.e-6
    if (angle_i in [-360,0,360]):
      assert abs(cg_r-cg) < 1.e-6
      count_unchanged += 1
    cg_r_alt = ca.rt_for_rotation_around_axis_through(
      point=cb, angle=angle_i, deg=True) * cg
    assert abs(cg_r_alt - cg_r) < 1.e-6
  assert count_unchanged == 3

def run(args):
  assert len(args) == 0
  exercise_rotate_point_around_axis()
  print("OK")

if (__name__ == "__main__"):
  import sys
  run(args=sys.argv[1:])


 *******************************************************************************


 *******************************************************************************
mmtbx/refinement/tst_group.py
from __future__ import absolute_import, division, print_function
import iotbx.pdb
import mmtbx.utils
import mmtbx.refinement.group

pdb_answer_str = """\n
CRYST1   21.937    4.866   23.477  90.00 107.08  90.00 P 1 21 1      2
ATOM      1  N   GLY A   1      -9.009   4.612   6.102  1.00 15.00           N
ATOM      2  CA  GLY A   1      -9.052   4.207   4.651  1.00 15.00           C
ATOM      3  C   GLY A   1      -8.015   3.140   4.419  1.00 15.00           C
ATOM      4  O   GLY A   1      -7.523   2.521   5.381  1.00 15.00           O
ATOM      5  N   ASN A   2      -7.656   2.923   3.155  1.00 15.00           N
ATOM      6  CA  ASN A   2      -6.522   2.038   2.831  1.00 15.00           C
ATOM      7  C   ASN A   2      -5.241   2.537   3.427  1.00 15.00           C
ATOM      8  O   ASN A   2      -4.978   3.742   3.426  1.00 15.00           O
ATOM      9  CB  ASN A   2      -6.346   1.881   1.341  1.00 15.00           C
ATOM     10  CG  ASN A   2      -7.584   1.342   0.692  1.00 15.00           C
ATOM     11  OD1 ASN A   2      -8.025   0.227   1.016  1.00 15.00           O
ATOM     12  ND2 ASN A   2      -8.204   2.155  -0.169  1.00 15.00           N
ATOM     13  N   ASN A   3      -4.438   1.590   3.905  1.00 15.00           N
ATOM     14  CA  ASN A   3      -3.193   1.904   4.589  1.00 15.00           C
ATOM     15  C   ASN A   3      -1.955   1.332   3.895  1.00 15.00           C
ATOM     16  O   ASN A   3      -1.872   0.119   3.648  1.00 15.00           O
ATOM     17  CB  ASN A   3      -3.259   1.378   6.042  1.00 15.00           C
ATOM     18  CG  ASN A   3      -2.006   1.739   6.861  1.00 15.00           C
ATOM     19  OD1 ASN A   3      -1.702   2.925   7.072  1.00 15.00           O
ATOM     20  ND2 ASN A   3      -1.271   0.715   7.306  1.00 15.00           N
ATOM     21  N   GLN A   4      -1.005   2.228   3.598  1.00 15.00           N
ATOM     22  CA  GLN A   4       0.384   1.888   3.199  1.00 15.00           C
ATOM     23  C   GLN A   4       1.435   2.606   4.088  1.00 15.00           C
ATOM     24  O   GLN A   4       1.547   3.843   4.115  1.00 15.00           O
ATOM     25  CB  GLN A   4       0.656   2.148   1.711  1.00 15.00           C
ATOM     26  CG  GLN A   4       1.944   1.458   1.213  1.00 15.00           C
ATOM     27  CD  GLN A   4       2.504   2.044  -0.089  1.00 15.00           C
ATOM     28  OE1 GLN A   4       2.744   3.268  -0.190  1.00 15.00           O
ATOM     29  NE2 GLN A   4       2.750   1.161  -1.091  1.00 15.00           N
ATOM     30  N   GLN A   5       2.154   1.821   4.871  1.00 15.00           N
ATOM     31  CA  GLN A   5       3.270   2.361   5.640  1.00 15.00           C
ATOM     32  C   GLN A   5       4.594   1.768   5.172  1.00 15.00           C
ATOM     33  O   GLN A   5       4.768   0.546   5.054  1.00 15.00           O
ATOM     34  CB  GLN A   5       3.056   2.183   7.147  1.00 15.00           C
ATOM     35  CG  GLN A   5       1.829   2.950   7.647  1.00 15.00           C
ATOM     36  CD  GLN A   5       1.344   2.414   8.954  1.00 15.00           C
ATOM     37  OE1 GLN A   5       0.774   1.325   9.002  1.00 15.00           O
ATOM     38  NE2 GLN A   5       1.549   3.187  10.039  1.00 15.00           N
ATOM     39  N   ASN A   6       5.514   2.664   4.856  1.00 15.00           N
ATOM     40  CA  ASN A   6       6.831   2.310   4.318  1.00 15.00           C
ATOM     41  C   ASN A   6       7.854   2.761   5.324  1.00 15.00           C
ATOM     42  O   ASN A   6       8.219   3.943   5.374  1.00 15.00           O
ATOM     43  CB  ASN A   6       7.065   3.016   2.993  1.00 15.00           C
ATOM     44  CG  ASN A   6       5.961   2.735   2.003  1.00 15.00           C
ATOM     45  OD1 ASN A   6       5.798   1.604   1.551  1.00 15.00           O
ATOM     46  ND2 ASN A   6       5.195   3.747   1.679  1.00 15.00           N
ATOM     47  N   TYR A   7       8.292   1.817   6.147  1.00 15.00           N
ATOM     48  CA  TYR A   7       9.159   2.144   7.299  1.00 15.00           C
ATOM     49  C   TYR A   7      10.603   2.331   6.885  1.00 15.00           C
ATOM     50  O   TYR A   7      11.041   1.811   5.855  1.00 15.00           O
ATOM     51  CB  TYR A   7       9.061   1.065   8.369  1.00 15.00           C
ATOM     52  CG  TYR A   7       7.665   0.929   8.902  1.00 15.00           C
ATOM     53  CD1 TYR A   7       6.771   0.021   8.327  1.00 15.00           C
ATOM     54  CD2 TYR A   7       7.210   1.756   9.920  1.00 15.00           C
ATOM     55  CE1 TYR A   7       5.480  -0.094   8.796  1.00 15.00           C
ATOM     56  CE2 TYR A   7       5.904   1.649  10.416  1.00 15.00           C
ATOM     57  CZ  TYR A   7       5.047   0.729   9.831  1.00 15.00           C
ATOM     58  OH  TYR A   7       3.766   0.589  10.291  1.00 15.00           O
ATOM     59  OXT TYR A   7      11.358   2.999   7.612  1.00 15.00           O
END
"""

pdb_poor_adp_str = """\n
CRYST1   21.937    4.866   23.477  90.00 107.08  90.00 P 1 21 1      2
ATOM      1  N   GLY A   1      -9.009   4.612   6.102  1.00  0.01           N
ATOM      2  CA  GLY A   1      -9.052   4.207   4.651  1.00  0.01           C
ATOM      3  C   GLY A   1      -8.015   3.140   4.419  1.00  0.01           C
ATOM      4  O   GLY A   1      -7.523   2.521   5.381  1.00  0.01           O
ATOM      5  N   ASN A   2      -7.656   2.923   3.155  1.00495.00           N
ATOM      6  CA  ASN A   2      -6.522   2.038   2.831  1.00495.00           C
ATOM      7  C   ASN A   2      -5.241   2.537   3.427  1.00495.00           C
ATOM      8  O   ASN A   2      -4.978   3.742   3.426  1.00495.00           O
ATOM      9  CB  ASN A   2      -6.346   1.881   1.341  1.00495.00           C
ATOM     10  CG  ASN A   2      -7.584   1.342   0.692  1.00495.00           C
ATOM     11  OD1 ASN A   2      -8.025   0.227   1.016  1.00495.00           O
ATOM     12  ND2 ASN A   2      -8.204   2.155  -0.169  1.00495.00           N
ATOM     13  N   ASN A   3      -4.438   1.590   3.905  1.00  2.00           N
ATOM     14  CA  ASN A   3      -3.193   1.904   4.589  1.00  2.00           C
ATOM     15  C   ASN A   3      -1.955   1.332   3.895  1.00  2.00           C
ATOM     16  O   ASN A   3      -1.872   0.119   3.648  1.00  2.00           O
ATOM     17  CB  ASN A   3      -3.259   1.378   6.042  1.00  2.00           C
ATOM     18  CG  ASN A   3      -2.006   1.739   6.861  1.00  2.00           C
ATOM     19  OD1 ASN A   3      -1.702   2.925   7.072  1.00  2.00           O
ATOM     20  ND2 ASN A   3      -1.271   0.715   7.306  1.00  2.00           N
ATOM     21  N   GLN A   4      -1.005   2.228   3.598  1.00385.00           N
ATOM     22  CA  GLN A   4       0.384   1.888   3.199  1.00385.00           C
ATOM     23  C   GLN A   4       1.435   2.606   4.088  1.00385.00           C
ATOM     24  O   GLN A   4       1.547   3.843   4.115  1.00385.00           O
ATOM     25  CB  GLN A   4       0.656   2.148   1.711  1.00385.00           C
ATOM     26  CG  GLN A   4       1.944   1.458   1.213  1.00385.00           C
ATOM     27  CD  GLN A   4       2.504   2.044  -0.089  1.00385.00           C
ATOM     28  OE1 GLN A   4       2.744   3.268  -0.190  1.00385.00           O
ATOM     29  NE2 GLN A   4       2.750   1.161  -1.091  1.00385.00           N
ATOM     30  N   GLN A   5       2.154   1.821   4.871  1.00  0.03           N
ATOM     31  CA  GLN A   5       3.270   2.361   5.640  1.00  0.03           C
ATOM     32  C   GLN A   5       4.594   1.768   5.172  1.00  0.03           C
ATOM     33  O   GLN A   5       4.768   0.546   5.054  1.00  0.03           O
ATOM     34  CB  GLN A   5       3.056   2.183   7.147  1.00  0.03           C
ATOM     35  CG  GLN A   5       1.829   2.950   7.647  1.00  0.03           C
ATOM     36  CD  GLN A   5       1.344   2.414   8.954  1.00  0.03           C
ATOM     37  OE1 GLN A   5       0.774   1.325   9.002  1.00  0.03           O
ATOM     38  NE2 GLN A   5       1.549   3.187  10.039  1.00  0.03           N
ATOM     39  N   ASN A   6       5.514   2.664   4.856  1.00290.00           N
ATOM     40  CA  ASN A   6       6.831   2.310   4.318  1.00290.00           C
ATOM     41  C   ASN A   6       7.854   2.761   5.324  1.00290.00           C
ATOM     42  O   ASN A   6       8.219   3.943   5.374  1.00290.00           O
ATOM     43  CB  ASN A   6       7.065   3.016   2.993  1.00290.00           C
ATOM     44  CG  ASN A   6       5.961   2.735   2.003  1.00290.00           C
ATOM     45  OD1 ASN A   6       5.798   1.604   1.551  1.00290.00           O
ATOM     46  ND2 ASN A   6       5.195   3.747   1.679  1.00290.00           N
ATOM     47  N   TYR A   7       8.292   1.817   6.147  1.00  0.00           N
ATOM     48  CA  TYR A   7       9.159   2.144   7.299  1.00  0.00           C
ATOM     49  C   TYR A   7      10.603   2.331   6.885  1.00  0.00           C
ATOM     50  O   TYR A   7      11.041   1.811   5.855  1.00  0.00           O
ATOM     51  CB  TYR A   7       9.061   1.065   8.369  1.00  0.00           C
ATOM     52  CG  TYR A   7       7.665   0.929   8.902  1.00  0.00           C
ATOM     53  CD1 TYR A   7       6.771   0.021   8.327  1.00  0.00           C
ATOM     54  CD2 TYR A   7       7.210   1.756   9.920  1.00  0.00           C
ATOM     55  CE1 TYR A   7       5.480  -0.094   8.796  1.00  0.00           C
ATOM     56  CE2 TYR A   7       5.904   1.649  10.416  1.00  0.00           C
ATOM     57  CZ  TYR A   7       5.047   0.729   9.831  1.00  0.00           C
ATOM     58  OH  TYR A   7       3.766   0.589  10.291  1.00  0.00           O
ATOM     59  OXT TYR A   7      11.358   2.999   7.612  1.00  0.00           O
END
"""

pdb_poor_occ_str = """\n
CRYST1   21.937    4.866   23.477  90.00 107.08  90.00 P 1 21 1      2
ATOM      1  N   GLY A   1      -9.009   4.612   6.102  0.01 15.00           N
ATOM      2  CA  GLY A   1      -9.052   4.207   4.651  0.01 15.00           C
ATOM      3  C   GLY A   1      -8.015   3.140   4.419  0.01 15.00           C
ATOM      4  O   GLY A   1      -7.523   2.521   5.381  0.01 15.00           O
ATOM      5  N   ASN A   2      -7.656   2.923   3.155  0.91 15.00           N
ATOM      6  CA  ASN A   2      -6.522   2.038   2.831  0.91 15.00           C
ATOM      7  C   ASN A   2      -5.241   2.537   3.427  0.91 15.00           C
ATOM      8  O   ASN A   2      -4.978   3.742   3.426  0.91 15.00           O
ATOM      9  CB  ASN A   2      -6.346   1.881   1.341  0.91 15.00           C
ATOM     10  CG  ASN A   2      -7.584   1.342   0.692  0.91 15.00           C
ATOM     11  OD1 ASN A   2      -8.025   0.227   1.016  0.91 15.00           O
ATOM     12  ND2 ASN A   2      -8.204   2.155  -0.169  0.91 15.00           N
ATOM     13  N   ASN A   3      -4.438   1.590   3.905  0.00 15.00           N
ATOM     14  CA  ASN A   3      -3.193   1.904   4.589  0.00 15.00           C
ATOM     15  C   ASN A   3      -1.955   1.332   3.895  0.00 15.00           C
ATOM     16  O   ASN A   3      -1.872   0.119   3.648  0.00 15.00           O
ATOM     17  CB  ASN A   3      -3.259   1.378   6.042  0.00 15.00           C
ATOM     18  CG  ASN A   3      -2.006   1.739   6.861  0.00 15.00           C
ATOM     19  OD1 ASN A   3      -1.702   2.925   7.072  0.00 15.00           O
ATOM     20  ND2 ASN A   3      -1.271   0.715   7.306  0.00 15.00           N
ATOM     21  N   GLN A   4      -1.005   2.228   3.598  7.00 15.00           N
ATOM     22  CA  GLN A   4       0.384   1.888   3.199  7.00 15.00           C
ATOM     23  C   GLN A   4       1.435   2.606   4.088  7.00 15.00           C
ATOM     24  O   GLN A   4       1.547   3.843   4.115  7.00 15.00           O
ATOM     25  CB  GLN A   4       0.656   2.148   1.711  7.00 15.00           C
ATOM     26  CG  GLN A   4       1.944   1.458   1.213  7.00 15.00           C
ATOM     27  CD  GLN A   4       2.504   2.044  -0.089  7.00 15.00           C
ATOM     28  OE1 GLN A   4       2.744   3.268  -0.190  7.00 15.00           O
ATOM     29  NE2 GLN A   4       2.750   1.161  -1.091  7.00 15.00           N
ATOM     30  N   GLN A   5       2.154   1.821   4.871  0.01 15.00           N
ATOM     31  CA  GLN A   5       3.270   2.361   5.640  0.01 15.00           C
ATOM     32  C   GLN A   5       4.594   1.768   5.172  0.01 15.00           C
ATOM     33  O   GLN A   5       4.768   0.546   5.054  0.01 15.00           O
ATOM     34  CB  GLN A   5       3.056   2.183   7.147  0.01 15.00           C
ATOM     35  CG  GLN A   5       1.829   2.950   7.647  0.01 15.00           C
ATOM     36  CD  GLN A   5       1.344   2.414   8.954  0.01 15.00           C
ATOM     37  OE1 GLN A   5       0.774   1.325   9.002  0.01 15.00           O
ATOM     38  NE2 GLN A   5       1.549   3.187  10.039  0.01 15.00           N
ATOM     39  N   ASN A   6       5.514   2.664   4.856 -1.00 15.00           N
ATOM     40  CA  ASN A   6       6.831   2.310   4.318 -1.00 15.00           C
ATOM     41  C   ASN A   6       7.854   2.761   5.324 -1.00 15.00           C
ATOM     42  O   ASN A   6       8.219   3.943   5.374 -1.00 15.00           O
ATOM     43  CB  ASN A   6       7.065   3.016   2.993 -1.00 15.00           C
ATOM     44  CG  ASN A   6       5.961   2.735   2.003 -1.00 15.00           C
ATOM     45  OD1 ASN A   6       5.798   1.604   1.551 -1.00 15.00           O
ATOM     46  ND2 ASN A   6       5.195   3.747   1.679 -1.00 15.00           N
ATOM     47  N   TYR A   7       8.292   1.817   6.147  5.00 15.00           N
ATOM     48  CA  TYR A   7       9.159   2.144   7.299  5.00 15.00           C
ATOM     49  C   TYR A   7      10.603   2.331   6.885  5.00 15.00           C
ATOM     50  O   TYR A   7      11.041   1.811   5.855  5.00 15.00           O
ATOM     51  CB  TYR A   7       9.061   1.065   8.369  5.00 15.00           C
ATOM     52  CG  TYR A   7       7.665   0.929   8.902  5.00 15.00           C
ATOM     53  CD1 TYR A   7       6.771   0.021   8.327  5.00 15.00           C
ATOM     54  CD2 TYR A   7       7.210   1.756   9.920  5.00 15.00           C
ATOM     55  CE1 TYR A   7       5.480  -0.094   8.796  5.00 15.00           C
ATOM     56  CE2 TYR A   7       5.904   1.649  10.416  5.00 15.00           C
ATOM     57  CZ  TYR A   7       5.047   0.729   9.831  5.00 15.00           C
ATOM     58  OH  TYR A   7       3.766   0.589  10.291  5.00 15.00           O
ATOM     59  OXT TYR A   7      11.358   2.999   7.612  5.00 15.00           O
END
"""

def run(refine, target, residues_per_window = 1):
  if(refine == "refine_adp"):
    refine_adp=True
    refine_occ=False
    pdb_poor_str = pdb_poor_adp_str
  else:
    refine_adp=False
    refine_occ=True
    pdb_poor_str = pdb_poor_occ_str
  pdb_inp_poor = iotbx.pdb.input(source_info=None, lines=pdb_poor_str)
  ph = pdb_inp_poor.construct_hierarchy()
  ph.atoms().reset_i_seq()
  xrs_poor = pdb_inp_poor.xray_structure_simple()
  xrs_answer = iotbx.pdb.input(source_info=None,
    lines=pdb_answer_str).xray_structure_simple()
  f_obs = abs(xrs_answer.structure_factors(d_min=7,algorithm="direct").f_calc())
  sfp=mmtbx.f_model.sf_and_grads_accuracy_master_params.extract()
  sfp.algorithm="direct"
  fmodel = mmtbx.f_model.manager(
    sf_and_grads_accuracy_params = sfp,
    xray_structure               = xrs_poor,
    f_obs                        = f_obs)
  fmodel.show()
  fmodel.update(target_name=target)
  print("Initial r_work=%6.4f r_free=%6.4f"%(fmodel.r_work(), fmodel.r_free()))
  tg = mmtbx.utils.experimental_data_target_and_gradients(fmodel = fmodel)
  # get group gradients using internal splitting into groups
  result = tg.group_occupancy_grads(
    pdb_hierarchy       = ph,
    residues_per_window = residues_per_window)
  for r in result:
    print("chainID_resseqs: %s occupancy_grad: %-15.6f"%tuple(r))
  print()
  # group occupancy selections
  selections = ph.chunk_selections(residues_per_chunk=residues_per_window)
  # refine occupancies
  if refine_occ:
    print("refine occupancies:")
    rr = mmtbx.refinement.group.manager(
      fmodel                      = fmodel,
      selections                  = selections,
      max_number_of_iterations    = 50,
      number_of_macro_cycles      = 25,
      refine_occ                  = True,
      convergence_test            = False,
      use_restraints              = True,
      run_finite_differences_test = True,
      occupancy_max               = 999,
      occupancy_min               = -999)
  # refine group B-factors
  if refine_adp:
    print("refine b-factors")
    rr = mmtbx.refinement.group.manager(
      fmodel                      = fmodel,
      selections                  = selections,
      max_number_of_iterations    = 50,
      number_of_macro_cycles      = 25,
      convergence_test            = False,
      run_finite_differences_test = True,
      refine_adp                  = True,
      use_restraints              = True)
  print("After refinement r_work=%6.4f r_free=%6.4f"%(
    fmodel.r_work(), fmodel.r_free()))
  ph.adopt_xray_structure(fmodel.xray_structure)
  ph.write_pdb_file(file_name="refined_occupancies.pdb",
    crystal_symmetry = f_obs.crystal_symmetry())
  assert rr.tested > 0, [target, refine]
  r_work = fmodel.r_work()*100
  assert r_work < 0.1, [r_work, target]

if (__name__ == "__main__"):
  for target in ["ml", "ls_wunit_kunit"]:
    for refine in ["refine_adp", "refine_occ"]:
      run(refine=refine, target=target)


 *******************************************************************************


 *******************************************************************************
mmtbx/refinement/tst_group_2.py
from __future__ import absolute_import, division, print_function
import iotbx.pdb
import mmtbx.refinement.group
import mmtbx.f_model
from cctbx import miller

pdb_answer_str = """\n
CRYST1   21.937    4.866   23.477  90.00 107.08  90.00 P 1 21 1      2
ATOM      1  N   GLY A   1      -9.009   4.612   6.102  1.00 15.00           N
ATOM      2  CA  GLY A   1      -9.052   4.207   4.651  1.00 15.00           C
ATOM      3  C   GLY A   1      -8.015   3.140   4.419  1.00 15.00           C
ATOM      4  O   GLY A   1      -7.523   2.521   5.381  1.00 15.00           O
ATOM      5  N   ASN A   2      -7.656   2.923   3.155  1.00 15.00           N
ATOM      6  CA  ASN A   2      -6.522   2.038   2.831  1.00 15.00           C
ATOM      7  C   ASN A   2      -5.241   2.537   3.427  1.00 15.00           C
ATOM      8  O   ASN A   2      -4.978   3.742   3.426  1.00 15.00           O
ATOM      9  CB  ASN A   2      -6.346   1.881   1.341  1.00 15.00           C
ATOM     10  CG  ASN A   2      -7.584   1.342   0.692  1.00 15.00           C
ATOM     11  OD1 ASN A   2      -8.025   0.227   1.016  1.00 15.00           O
ATOM     12  ND2 ASN A   2      -8.204   2.155  -0.169  1.00 15.00           N
ATOM     13  N   ASN A   3      -4.438   1.590   3.905  1.00 15.00           N
ATOM     14  CA  ASN A   3      -3.193   1.904   4.589  1.00 15.00           C
ATOM     15  C   ASN A   3      -1.955   1.332   3.895  1.00 15.00           C
ATOM     16  O   ASN A   3      -1.872   0.119   3.648  1.00 15.00           O
ATOM     17  CB  ASN A   3      -3.259   1.378   6.042  1.00 15.00           C
ATOM     18  CG  ASN A   3      -2.006   1.739   6.861  1.00 15.00           C
ATOM     19  OD1 ASN A   3      -1.702   2.925   7.072  1.00 15.00           O
ATOM     20  ND2 ASN A   3      -1.271   0.715   7.306  1.00 15.00           N
ATOM     21  N   GLN A   4      -1.005   2.228   3.598  1.00 15.00           N
ATOM     22  CA  GLN A   4       0.384   1.888   3.199  1.00 15.00           C
ATOM     23  C   GLN A   4       1.435   2.606   4.088  1.00 15.00           C
ATOM     24  O   GLN A   4       1.547   3.843   4.115  1.00 15.00           O
ATOM     25  CB  GLN A   4       0.656   2.148   1.711  1.00 15.00           C
ATOM     26  CG  GLN A   4       1.944   1.458   1.213  1.00 15.00           C
ATOM     27  CD  GLN A   4       2.504   2.044  -0.089  1.00 15.00           C
ATOM     28  OE1 GLN A   4       2.744   3.268  -0.190  1.00 15.00           O
ATOM     29  NE2 GLN A   4       2.750   1.161  -1.091  1.00 15.00           N
ATOM     30  N   GLN A   5       2.154   1.821   4.871  1.00 15.00           N
ATOM     31  CA  GLN A   5       3.270   2.361   5.640  1.00 15.00           C
ATOM     32  C   GLN A   5       4.594   1.768   5.172  1.00 15.00           C
ATOM     33  O   GLN A   5       4.768   0.546   5.054  1.00 15.00           O
ATOM     34  CB  GLN A   5       3.056   2.183   7.147  1.00 15.00           C
ATOM     35  CG  GLN A   5       1.829   2.950   7.647  1.00 15.00           C
ATOM     36  CD  GLN A   5       1.344   2.414   8.954  1.00 15.00           C
ATOM     37  OE1 GLN A   5       0.774   1.325   9.002  1.00 15.00           O
ATOM     38  NE2 GLN A   5       1.549   3.187  10.039  1.00 15.00           N
ATOM     39  N   ASN A   6       5.514   2.664   4.856  1.00 15.00           N
ATOM     40  CA  ASN A   6       6.831   2.310   4.318  1.00 15.00           C
ATOM     41  C   ASN A   6       7.854   2.761   5.324  1.00 15.00           C
ATOM     42  O   ASN A   6       8.219   3.943   5.374  1.00 15.00           O
ATOM     43  CB  ASN A   6       7.065   3.016   2.993  1.00 15.00           C
ATOM     44  CG  ASN A   6       5.961   2.735   2.003  1.00 15.00           C
ATOM     45  OD1 ASN A   6       5.798   1.604   1.551  1.00 15.00           O
ATOM     46  ND2 ASN A   6       5.195   3.747   1.679  1.00 15.00           N
ATOM     47  N   TYR A   7       8.292   1.817   6.147  1.00 15.00           N
ATOM     48  CA  TYR A   7       9.159   2.144   7.299  1.00 15.00           C
ATOM     49  C   TYR A   7      10.603   2.331   6.885  1.00 15.00           C
ATOM     50  O   TYR A   7      11.041   1.811   5.855  1.00 15.00           O
ATOM     51  CB  TYR A   7       9.061   1.065   8.369  1.00 15.00           C
ATOM     52  CG  TYR A   7       7.665   0.929   8.902  1.00 15.00           C
ATOM     53  CD1 TYR A   7       6.771   0.021   8.327  1.00 15.00           C
ATOM     54  CD2 TYR A   7       7.210   1.756   9.920  1.00 15.00           C
ATOM     55  CE1 TYR A   7       5.480  -0.094   8.796  1.00 15.00           C
ATOM     56  CE2 TYR A   7       5.904   1.649  10.416  1.00 15.00           C
ATOM     57  CZ  TYR A   7       5.047   0.729   9.831  1.00 15.00           C
ATOM     58  OH  TYR A   7       3.766   0.589  10.291  1.00 15.00           O
ATOM     59  OXT TYR A   7      11.358   2.999   7.612  1.00 15.00           O
END
"""

pdb_poor_adp_str = """\n
CRYST1   21.937    4.866   23.477  90.00 107.08  90.00 P 1 21 1      2
ATOM      1  N   GLY A   1      -9.009   4.612   6.102  1.00  0.01           N
ATOM      2  CA  GLY A   1      -9.052   4.207   4.651  1.00  0.01           C
ATOM      3  C   GLY A   1      -8.015   3.140   4.419  1.00  0.01           C
ATOM      4  O   GLY A   1      -7.523   2.521   5.381  1.00  0.01           O
ATOM      5  N   ASN A   2      -7.656   2.923   3.155  1.00495.00           N
ATOM      6  CA  ASN A   2      -6.522   2.038   2.831  1.00495.00           C
ATOM      7  C   ASN A   2      -5.241   2.537   3.427  1.00495.00           C
ATOM      8  O   ASN A   2      -4.978   3.742   3.426  1.00495.00           O
ATOM      9  CB  ASN A   2      -6.346   1.881   1.341  1.00495.00           C
ATOM     10  CG  ASN A   2      -7.584   1.342   0.692  1.00495.00           C
ATOM     11  OD1 ASN A   2      -8.025   0.227   1.016  1.00495.00           O
ATOM     12  ND2 ASN A   2      -8.204   2.155  -0.169  1.00495.00           N
ATOM     13  N   ASN A   3      -4.438   1.590   3.905  1.00  2.00           N
ATOM     14  CA  ASN A   3      -3.193   1.904   4.589  1.00  2.00           C
ATOM     15  C   ASN A   3      -1.955   1.332   3.895  1.00  2.00           C
ATOM     16  O   ASN A   3      -1.872   0.119   3.648  1.00  2.00           O
ATOM     17  CB  ASN A   3      -3.259   1.378   6.042  1.00  2.00           C
ATOM     18  CG  ASN A   3      -2.006   1.739   6.861  1.00  2.00           C
ATOM     19  OD1 ASN A   3      -1.702   2.925   7.072  1.00  2.00           O
ATOM     20  ND2 ASN A   3      -1.271   0.715   7.306  1.00  2.00           N
ATOM     21  N   GLN A   4      -1.005   2.228   3.598  1.00385.00           N
ATOM     22  CA  GLN A   4       0.384   1.888   3.199  1.00385.00           C
ATOM     23  C   GLN A   4       1.435   2.606   4.088  1.00385.00           C
ATOM     24  O   GLN A   4       1.547   3.843   4.115  1.00385.00           O
ATOM     25  CB  GLN A   4       0.656   2.148   1.711  1.00385.00           C
ATOM     26  CG  GLN A   4       1.944   1.458   1.213  1.00385.00           C
ATOM     27  CD  GLN A   4       2.504   2.044  -0.089  1.00385.00           C
ATOM     28  OE1 GLN A   4       2.744   3.268  -0.190  1.00385.00           O
ATOM     29  NE2 GLN A   4       2.750   1.161  -1.091  1.00385.00           N
ATOM     30  N   GLN A   5       2.154   1.821   4.871  1.00  0.03           N
ATOM     31  CA  GLN A   5       3.270   2.361   5.640  1.00  0.03           C
ATOM     32  C   GLN A   5       4.594   1.768   5.172  1.00  0.03           C
ATOM     33  O   GLN A   5       4.768   0.546   5.054  1.00  0.03           O
ATOM     34  CB  GLN A   5       3.056   2.183   7.147  1.00  0.03           C
ATOM     35  CG  GLN A   5       1.829   2.950   7.647  1.00  0.03           C
ATOM     36  CD  GLN A   5       1.344   2.414   8.954  1.00  0.03           C
ATOM     37  OE1 GLN A   5       0.774   1.325   9.002  1.00  0.03           O
ATOM     38  NE2 GLN A   5       1.549   3.187  10.039  1.00  0.03           N
ATOM     39  N   ASN A   6       5.514   2.664   4.856  1.00290.00           N
ATOM     40  CA  ASN A   6       6.831   2.310   4.318  1.00290.00           C
ATOM     41  C   ASN A   6       7.854   2.761   5.324  1.00290.00           C
ATOM     42  O   ASN A   6       8.219   3.943   5.374  1.00290.00           O
ATOM     43  CB  ASN A   6       7.065   3.016   2.993  1.00290.00           C
ATOM     44  CG  ASN A   6       5.961   2.735   2.003  1.00290.00           C
ATOM     45  OD1 ASN A   6       5.798   1.604   1.551  1.00290.00           O
ATOM     46  ND2 ASN A   6       5.195   3.747   1.679  1.00290.00           N
ATOM     47  N   TYR A   7       8.292   1.817   6.147  1.00  0.00           N
ATOM     48  CA  TYR A   7       9.159   2.144   7.299  1.00  0.00           C
ATOM     49  C   TYR A   7      10.603   2.331   6.885  1.00  0.00           C
ATOM     50  O   TYR A   7      11.041   1.811   5.855  1.00  0.00           O
ATOM     51  CB  TYR A   7       9.061   1.065   8.369  1.00  0.00           C
ATOM     52  CG  TYR A   7       7.665   0.929   8.902  1.00  0.00           C
ATOM     53  CD1 TYR A   7       6.771   0.021   8.327  1.00  0.00           C
ATOM     54  CD2 TYR A   7       7.210   1.756   9.920  1.00  0.00           C
ATOM     55  CE1 TYR A   7       5.480  -0.094   8.796  1.00  0.00           C
ATOM     56  CE2 TYR A   7       5.904   1.649  10.416  1.00  0.00           C
ATOM     57  CZ  TYR A   7       5.047   0.729   9.831  1.00  0.00           C
ATOM     58  OH  TYR A   7       3.766   0.589  10.291  1.00  0.00           O
ATOM     59  OXT TYR A   7      11.358   2.999   7.612  1.00  0.00           O
END
"""


def run(refine, target, residues_per_window = 1, d_min=2):
  """
  Makes sure this actually work:
  'real-space' ADP refinement by converting the map into 'Fobs' and
  then actually doing usual reciprocal-space refinement. Surprisingly this
  converges to R=0 exactly regardless the resolution. ML does not work perhaps
  becase starting point is too far.
  """
  pdb_inp_poor = iotbx.pdb.input(source_info=None, lines=pdb_poor_adp_str)
  pdb_inp_poor.write_pdb_file(file_name="poor.pdb")
  ph = pdb_inp_poor.construct_hierarchy()
  ph.atoms().reset_i_seq()
  xrs_poor = pdb_inp_poor.xray_structure_simple()
  xrs_answer = iotbx.pdb.input(source_info=None,
    lines=pdb_answer_str).xray_structure_simple()
  ####
  f_obs = xrs_answer.structure_factors(d_min=d_min,algorithm="direct").f_calc()
  mtz_dataset = f_obs.as_mtz_dataset(column_root_label="F-calc")
  fc = abs(f_obs)
  fft_map = f_obs.fft_map(resolution_factor=0.25)
  fft_map.apply_volume_scaling()
  map_data = fft_map.real_map_unpadded()
  complete_set = miller.build_set(
    crystal_symmetry = xrs_answer.crystal_symmetry(),
    anomalous_flag   = False,
    d_min            = d_min)
  f_obs = complete_set.structure_factors_from_map(
    map            = map_data,
    use_scale      = True,
    anomalous_flag = False,
    use_sg         = True)
  f_obs = abs(f_obs)
  ###
  mtz_dataset.add_miller_array(
    miller_array=f_obs,
    column_root_label="F-obs")
  mtz_dataset.add_miller_array(
    miller_array=f_obs.generate_r_free_flags(),
    column_root_label="R-free-flags")
  mtz_object = mtz_dataset.mtz_object()
  mtz_object.write(file_name = "data.mtz")
  ###
  sfp=mmtbx.f_model.sf_and_grads_accuracy_master_params.extract()
  sfp.algorithm="direct"
  fmodel = mmtbx.f_model.manager(
    sf_and_grads_accuracy_params = sfp,
    xray_structure               = xrs_poor,
    f_obs                        = f_obs)
  fmodel.show()
  fmodel.update(target_name=target)
  print("Initial r_work=%6.4f r_free=%6.4f"%(fmodel.r_work(), fmodel.r_free()))
  selections = ph.chunk_selections(residues_per_chunk=residues_per_window)
  rr = mmtbx.refinement.group.manager(
    fmodel                      = fmodel,
    selections                  = selections,
    max_number_of_iterations    = 50,
    number_of_macro_cycles      = 25,
    convergence_test            = True,
    run_finite_differences_test = False,
    refine_adp                  = True,
    use_restraints              = True)
  print("After refinement r_work=%6.4f r_free=%6.4f"%(
    fmodel.r_work(), fmodel.r_free()))
  ph.adopt_xray_structure(fmodel.xray_structure)
  ph.write_pdb_file(file_name="reciprocal_space_refined_group_adp.pdb",
    crystal_symmetry = f_obs.crystal_symmetry())
  r_work = fmodel.r_work()*100
  assert r_work < 0.1, [r_work, target]

if (__name__ == "__main__"):
  run(refine="refine_adp", target="ls_wunit_k1")


 *******************************************************************************


 *******************************************************************************
mmtbx/refinement/tst_misc.py
from __future__ import absolute_import, division, print_function


def exercise():
  from mmtbx.refinement.print_statistics import coordinate_shifts
  import iotbx.pdb
  hierarchy_start = iotbx.pdb.input(source_info=None, lines="""\
ATOM      1  N   GLY A   1      -9.009  14.612   6.102  1.00 16.77           N
ATOM      2  CA  GLY A   1      -9.052  14.207   4.651  1.00 16.57           C
ATOM      3  C   GLY A   1      -8.015  13.140   4.419  1.00 16.16           C
ATOM      4  O   GLY A   1      -7.523  12.521   5.381  1.00 16.78           O
ATOM      5  N   ASN A   2      -7.656  12.923   3.155  1.00 15.02           N
ATOM      6  CA  ASN A   2      -6.522  12.038   2.831  1.00 14.10           C
ATOM      7  C   ASN A   2      -5.241  12.537   3.427  1.00 13.13           C
ATOM      8  O   ASN A   2      -4.978  13.742   3.426  1.00 11.91           O
ATOM      9  CB  ASN A   2      -6.346  11.881   1.341  1.00 15.38           C
ATOM     10  CG  ASN A   2      -7.584  11.342   0.692  1.00 14.08           C
ATOM     11  OD1 ASN A   2      -8.025  10.227   1.016  1.00 17.46           O
ATOM     12  ND2 ASN A   2      -8.204  12.155  -0.169  1.00 11.72           N
ATOM     13  N   ASN A   3      -4.438  11.590   3.905  1.00 12.26           N
ATOM     14  CA  ASN A   3      -3.193  11.904   4.589  1.00 11.74           C
ATOM     15  C   ASN A   3      -1.955  11.332   3.895  1.00 11.10           C
ATOM     16  O   ASN A   3      -1.872  10.119   3.648  1.00 10.42           O
ATOM     17  CB  ASN A   3      -3.259  11.378   6.042  1.00 12.15           C
ATOM     18  CG  ASN A   3      -2.006  11.739   6.861  1.00 12.82           C
ATOM     19  OD1 ASN A   3      -1.702  12.925   7.072  1.00 15.05           O
ATOM     20  ND2 ASN A   3      -1.271  10.715   7.306  1.00 13.48           N
END""").construct_hierarchy()
  hierarchy_end = iotbx.pdb.input(source_info=None, lines="""\
ATOM      1  N   GLY A   1      -9.009   4.612   6.102  1.00 16.77           N
ATOM      2  CA  GLY A   1      -9.052   4.207   4.651  1.00 16.57           C
ATOM      3  C   GLY A   1      -8.015   3.140   4.419  1.00 16.16           C
ATOM      4  O   GLY A   1      -7.523   2.521   5.381  1.00 16.78           O
ATOM      5  N   ASN A   2      -7.656   2.923   3.155  1.00 15.02           N
ATOM      6  CA  ASN A   2      -6.522   2.038   2.831  1.00 14.10           C
ATOM      7  C   ASN A   2      -5.241   2.537   3.427  1.00 13.13           C
ATOM      8  O   ASN A   2      -4.978   3.742   3.426  1.00 11.91           O
ATOM      9  CB  ASN A   2      -6.346   1.881   1.341  1.00 15.38           C
ATOM     10  CG  ASN A   2      -7.584   1.342   0.692  1.00 14.08           C
ATOM     11  OD1 ASN A   2      -8.025   0.227   1.016  1.00 17.46           O
ATOM     12  ND2 ASN A   2      -8.204   2.155  -0.169  1.00 11.72           N
ATOM     13  N   ASN A   3      -4.438   1.590   3.905  1.00 12.26           N
ATOM     14  CA  ASN A   3      -3.193   1.904   4.589  1.00 11.74           C
ATOM     15  C   ASN A   3      -1.955   1.332   3.895  1.00 11.10           C
ATOM     16  O   ASN A   3      -1.872   0.119   3.648  1.00 10.42           O
ATOM     17  CB  ASN A   3      -3.259   1.378   6.042  1.00 12.15           C
ATOM     18  CG  ASN A   3      -2.006   1.739   6.861  1.00 12.82           C
ATOM     19  OD1 ASN A   3      -1.702   2.925   7.072  1.00 15.05           O
ATOM     20  ND2 ASN A   3      -1.271   0.715   7.306  1.00 13.48           N
TER
HETATM   60  O   HOH     8      -6.471   5.227   7.124  1.00 20.00           O
HETATM   61  O   HOH     9      10.431   1.858   3.216  1.00 20.00           O
HETATM   62  O   HOH    10     -11.286   1.756  -1.468  1.00 20.00           O
END""").construct_hierarchy()
  cs = coordinate_shifts(hierarchy_start, hierarchy_end)
  #hierarchy_shifted = cs.get_shifts()
  mmm = cs.min_max_mean()
  assert (mmm.min==10) and (mmm.max==10) and (mmm.mean==10)
  cs.save_pdb_file("shifted.pdb")
  with open("shifted.pdb") as f:
    lines = f.readlines()
  h3 = iotbx.pdb.input(source_info=None, lines=lines).construct_hierarchy()
  a3 = h3.atoms()
  shifts = a3.extract_b()
  assert (shifts[-1] == -1.0)

if (__name__ == "__main__"):
  exercise()
  print("OK")


 *******************************************************************************


 *******************************************************************************
mmtbx/refinement/tst_occupancy_selections.py
from __future__ import absolute_import, division, print_function
from mmtbx.monomer_library import pdb_interpretation
from mmtbx.refinement.occupancies import occupancy_selections
from iotbx.cli_parser import run_program
from mmtbx.programs import fmodel
import mmtbx.model
import iotbx.pdb
import iotbx.phil
from libtbx.test_utils import approx_equal
from libtbx.utils import format_cpu_times, null_out, Sorry
import libtbx.load_env
from six.moves import cStringIO as StringIO
import os
import sys
from six.moves import zip

def extract_serials(atoms, occ_groups):
  r = []
  # for atom in atoms:
  #   assert atom.serial == atom.i_seq, "%s %d" % (atom.serial, atom.i_seq)
  for i in occ_groups:
    ri = []
    for j in i:
      ri.append([int(atoms[k].serial) for k in j])
    r.append(ri)
  return r

def make_up_other_constrained_groups_obj(selections):
  result = []
  class foo:
    def __init__(self, selection):
      self.selection=selection
  for sel in selections:
    result.append( foo(selection = sel) )
  return result

def get_model(file_name, log):
  pdb_interpretation_params = iotbx.phil.parse(
          input_string=pdb_interpretation.grand_master_phil_str, process_includes=True).extract()
  pdb_interpretation_params.pdb_interpretation.sort_atoms=False
  pdb_inp = iotbx.pdb.input(file_name=file_name)
  model = mmtbx.model.manager(
      model_input = pdb_inp,
      stop_for_unknowns = False,
      log=log)
  model.process(pdb_interpretation_params=pdb_interpretation_params)
  return model

def get_model_str(strings, log):
  pdb_interpretation_params = iotbx.phil.parse(
          input_string=pdb_interpretation.grand_master_phil_str, process_includes=True).extract()
  pdb_interpretation_params.pdb_interpretation.sort_atoms=False
  pdb_inp = iotbx.pdb.input(lines=strings, source_info=None)
  model = mmtbx.model.manager(
      model_input = pdb_inp,
      stop_for_unknowns = False,
      log=log)
  model.process(pdb_interpretation_params=pdb_interpretation_params)
  return model

def exercise_00(verbose):
  pdb_file = libtbx.env.find_in_repositories(
    relative_path="phenix_regression/pdb/gocr.pdb",
    test=os.path.isfile)
  if (verbose): log = sys.stdout
  else: log = StringIO()
  model = get_model(pdb_file, log)
  base = [ [[2],[3]], [[6,7,8,9,10],[11,12,13,14,15]], [[16],[17]], [[24,25,26,27],[28,29,30,31]] ]
  # default
  res = occupancy_selections(
    model = model,
    as_flex_arrays    = False)
  res = extract_serials(model.get_atoms(), res)
  target = base[:]
  target.insert(3, [[21]])
  target.insert(4, [[23]])
  assert approx_equal(res, target)
  # default + add water
  res = occupancy_selections(
    model = model,
    add_water         = True,
    as_flex_arrays    = False)
  res = extract_serials(model.get_atoms(), res)
  base_21_23 = target[:]
  target.extend([[[18]], [[19]], [[20]]])
  assert approx_equal(res, target)
  # 1
  res = occupancy_selections(
    model = model,
    as_flex_arrays    = False,
    other_individual_selection_strings = ['resseq 0 and not (altloc A or altloc B)'])
  res = extract_serials(model.get_atoms(), res)
  target = base_21_23[:]
  target.extend([[[0]], [[1]], [[4]], [[5]]])
  assert approx_equal(res, target)
  res = occupancy_selections(
    model = model,
    add_water         = True,
    as_flex_arrays    = False,
    other_individual_selection_strings = ['resseq 0 and not (altloc A or altloc B)'])
  res = extract_serials(model.get_atoms(), res)
  target.extend([[[18]], [[19]], [[20]]])
  assert approx_equal(res, target)
  # 2
  other_constrained_groups = make_up_other_constrained_groups_obj(
    selections = [ ['resseq 0 and (name S or name O1)'], ['resseq 0 and (name O3 or name O4)'] ])
  res = occupancy_selections(
    model = model,
    as_flex_arrays    = False,
    other_constrained_groups = other_constrained_groups)
  res = extract_serials(model.get_atoms(), res)
  target = base_21_23[:]
  target.extend([[[0, 1]], [[4, 5]]])
  assert approx_equal(res, target)
  other_constrained_groups = make_up_other_constrained_groups_obj(
    selections = [ ['resseq 0 and (name S or name O1)'], ['resseq 0 and (name O3 or name O4)'] ])
  res = occupancy_selections(
    model = model,
    add_water         = True,
    as_flex_arrays    = False,
    other_constrained_groups = other_constrained_groups)
  res = extract_serials(model.get_atoms(), res)
  target.extend([[[18]], [[19]], [[20]]])
  assert approx_equal(res, target)
  # 3
  other_constrained_groups = make_up_other_constrained_groups_obj(
    selections = [ ['resseq 0 and (name O3 or name O4)'] ])
  res = occupancy_selections(
    model = model,
    as_flex_arrays    = False,
    other_individual_selection_strings = ['resseq 0 and (name S or name O1)'],
    other_constrained_groups = other_constrained_groups)
  res = extract_serials(model.get_atoms(), res)
  target = base_21_23[:]
  target.extend([[[0]], [[1]], [[4, 5]]])
  assert approx_equal(res, target)

def exercise_01(verbose):
  pdb_file = libtbx.env.find_in_repositories(
    relative_path="phenix_regression/pdb/ala_h.pdb",
    test=os.path.isfile)
  if (verbose): log = sys.stdout
  else: log = StringIO()
  model = get_model(pdb_file, log)
  #
  base = [ [[0,1,2,3,4,10,12,14,16,18,20,22], [5,6,7,8,9,11,13,15,17,19,21,23]] ]
  res = occupancy_selections(
    model = model,
    as_flex_arrays    = False)
  res = extract_serials(model.get_atoms(), res)
  assert approx_equal(res, base)

def exercise_02(verbose):
  pdb_file = libtbx.env.find_in_repositories(
    relative_path="phenix_regression/pdb/occ_mix1.pdb",
    test=os.path.isfile)
  if (verbose): log = sys.stdout
  else: log = StringIO()
  model = get_model(pdb_file, log)
  #
  base = [ [[0,1,2,3,4,5,6,7,8,9,10,11,12,13], [14,15,16,17,18,19,20,21,22,23,24,25,26,27]] ]
  res = occupancy_selections(
    model = model,
    as_flex_arrays    = False)
  res = extract_serials(model.get_atoms(), res)
  assert approx_equal(res, base)

def exercise_03(verbose):
  pdb_file = libtbx.env.find_in_repositories(
    relative_path="phenix_regression/pdb/ala_hd.pdb",
    test=os.path.isfile)
  if (verbose): log = sys.stdout
  else: log = StringIO()
  model = get_model(pdb_file, log)
  #
  base = [ [[7]], [[8]], [[9],[12]], [[10],[13]], [[11],[14]] ]
  res = occupancy_selections(
    model = model,
    as_flex_arrays    = False)
  res = extract_serials(model.get_atoms(), res)
  assert approx_equal(res, base)

def exercise_05(verbose):
  pdb_file = libtbx.env.find_in_repositories(
    relative_path="phenix_regression/pdb/ala_lys_arg_ser_tyr_neutron_hd.pdb",
    test=os.path.isfile)
  if (verbose): log = sys.stdout
  else: log = StringIO()
  model = get_model(pdb_file, log)
  #
  base = [ [[9],[12]],  [[10],[13]], [[11],[14]], [[33],[37]], [[34],[38]],
           [[35],[39]], [[36],[40]], [[59],[65]], [[60],[66]], [[61],[67]],
           [[62],[68]], [[63],[69]], [[64],[70]], [[80],[82]], [[81],[83]],
           [[103],[105]], [[104],[106]]]
  res = occupancy_selections(
    model = model,
    as_flex_arrays      = False)
  res = extract_serials(model.get_atoms(), res)
  assert approx_equal(res, base)

def exercise_06(verbose):
  pdb_file = libtbx.env.find_in_repositories(
    relative_path="phenix_regression/pdb/NAD_594_HD.pdb",
    test=os.path.isfile)
  if (verbose): log = sys.stdout
  else: log = StringIO()
  model = get_model(pdb_file, log)
  #
  base = [ [[62]], [[113]], [[65],[77]],  [[66],[78]],  [[67],[79]], [[68],[80]],
                            [[69],[81]],  [[70],[82]],  [[71],[83]], [[72],[84]],
                            [[73],[85]],  [[74],[86]],  [[75],[87]], [[76],[88]],
                            [[124],[127]],[[125],[128]],[[126],[129]]]
  res = occupancy_selections(
    model = model,
    as_flex_arrays      = False)
  assert approx_equal(res, base)

def exercise_07(verbose):
  pdb_file = libtbx.env.find_in_repositories(
    relative_path="phenix_regression/pdb/gocr_1.pdb",
    test=os.path.isfile)
  if (verbose): log = sys.stdout
  else: log = StringIO()
  model = get_model(pdb_file, log)
  answer = [ [[0, 1, 2, 3, 4]] ]
  other_constrained_groups = make_up_other_constrained_groups_obj(
    selections = [ ['resseq 0'] ])
  result = occupancy_selections(
    model = model,
    other_constrained_groups = other_constrained_groups,
    as_flex_arrays    = False)
  assert approx_equal(result, answer)

def exercise_08(verbose):
  pdb_file = libtbx.env.find_in_repositories(
    relative_path="phenix_regression/pdb/gocr_2.pdb",
    test=os.path.isfile)
  if (verbose): log = sys.stdout
  else: log = StringIO()
  model = get_model(pdb_file, log)
  answers = [
    [ [[6,7,8,9,10],[11,12,13,14,15]], [[16],[17]], [[21]], [[23]], [[24,25,26,27],[28,29,30,31]], [[0,1,2,3,4,5]] ],
    [ [[4],[5]], [[16],[17]], [[21]], [[23]], [[24,25,26,27],[28,29,30,31]], [[6,7,8,9,10,11,12,13,14,15]] ],
    [ [[4],[5]], [[6,7,8,9,10],[11,12,13,14,15]], [[21]], [[23]], [[24,25,26,27],[28,29,30,31]], [[16,17]] ],
    [ [[4],[5]], [[6,7,8,9,10],[11,12,13,14,15]], [[16],[17]], [[21]], [[23]], [[24,25,26,27],[28,29,30,31]], [[18,19,20]] ],
    [ [[4],[5]], [[6,7,8,9,10],[11,12,13,14,15]], [[16],[17]], [[23]], [[24,25,26,27],[28,29,30,31]], [[21]] ],
    [ [[4],[5]], [[6,7,8,9,10],[11,12,13,14,15]], [[16],[17]], [[21]], [[23]], [[24,25,26,27],[28,29,30,31]], [[22]] ],
    [ [[4],[5]], [[6,7,8,9,10],[11,12,13,14,15]], [[16],[17]], [[21]], [[23,24,25,26,27,28,29,30,31]] ],
    [ [[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31]] ]
  ]
  group_selections = ['resseq 0',
                      'resseq 1',
                      'resseq 2',
                      'resseq 3',
                      'resseq 4',
                      'resseq 5',
                      'resseq 6',
                      'resseq 0:6']
  for group_selection, answer in zip(group_selections, answers):
    other_constrained_groups = make_up_other_constrained_groups_obj(
      selections = [ [group_selection] ])
    result = occupancy_selections(
      model = model,
      other_constrained_groups = other_constrained_groups,
      as_flex_arrays    = False)
    assert approx_equal(result, answer)

def exercise_09(verbose):
  pdb_file = libtbx.env.find_in_repositories(
    relative_path="phenix_regression/pdb/gocr_2.pdb",
    test=os.path.isfile)
  if (verbose): log = sys.stdout
  else: log = StringIO()
  model = get_model(pdb_file, log)
  answers = [
    [ [[6,7,8,9,10],[11,12,13,14,15]], [[16],[17]], [[21]], [[23]], [[24,25,26,27],[28,29,30,31]], [[0]], [[1]], [[2]], [[3]], [[4]], [[5]] ],
    [ [[4],[5]], [[16],[17]], [[21]], [[23]], [[24,25,26,27],[28,29,30,31]], [[6]], [[7]], [[8]], [[9]], [[10]], [[11]], [[12]], [[13]], [[14]], [[15]] ],
    [ [[4],[5]], [[6,7,8,9,10],[11,12,13,14,15]], [[21]], [[23]], [[24,25,26,27],[28,29,30,31]], [[16]], [[17]] ],
    [ [[4],[5]], [[6,7,8,9,10],[11,12,13,14,15]], [[16],[17]], [[21]], [[23]], [[24,25,26,27],[28,29,30,31]], [[18]], [[19]], [[20]] ],
    [ [[4],[5]], [[6,7,8,9,10],[11,12,13,14,15]], [[16],[17]], [[23]], [[24,25,26,27],[28,29,30,31]], [[21]] ],
    [ [[4],[5]], [[6,7,8,9,10],[11,12,13,14,15]], [[16],[17]], [[21]], [[23]], [[24,25,26,27],[28,29,30,31]], [[22]] ],
    [ [[4],[5]], [[6,7,8,9,10],[11,12,13,14,15]], [[16],[17]], [[21]], [[23]], [[24]], [[25]], [[26]], [[27]], [[28]], [[29]], [[30]], [[31]] ]
  ]
  individual_selections = ['resseq 0',
                           'resseq 1',
                           'resseq 2',
                           'resseq 3',
                           'resseq 4',
                           'resseq 5',
                           'resseq 6',
                           'resseq 0:6']
  for individual_selection, answer in zip(individual_selections, answers):
    result = occupancy_selections(
      model = model,
      other_individual_selection_strings = [individual_selection],
      as_flex_arrays    = False)
    assert approx_equal(result, answer)

def exercise_10(verbose):
  pdb_file = libtbx.env.find_in_repositories(
    relative_path="phenix_regression/pdb/gocr.pdb",
    test=os.path.isfile)
  if (verbose): log = sys.stdout
  else: log = StringIO()
  model = get_model(pdb_file, log)
  e = None
  try:
    other_constrained_groups = make_up_other_constrained_groups_obj(
      selections = [ ['resseq 0'] ])
    result = occupancy_selections(
      model = model,
      other_constrained_groups = other_constrained_groups,
      other_individual_selection_strings = ['resseq 0'],
      as_flex_arrays    = False)
  except Exception as e:
    assert str(e) == "Duplicate selection: same atoms selected for individual and group occupancy refinement."

def exercise_11(verbose):
  pdb_file = libtbx.env.find_in_repositories(
    relative_path="phenix_regression/pdb/gocr.pdb",
    test=os.path.isfile)
  if (verbose): log = sys.stdout
  else: log = StringIO()
  model = get_model(pdb_file, log)
  e = None
  try:
    result = occupancy_selections(
      model = model,
      remove_selection = ['resseq 0'],
      other_individual_selection_strings = ['resseq 0'],
      as_flex_arrays    = False)
  except Exception as e:
    assert str(e) == "Duplicate selection: occupancies of same atoms selected to be fixed and to be refined."
  e = None
  try:
    other_constrained_groups = make_up_other_constrained_groups_obj(
      selections = [ ['resseq 0'] ])
    result = occupancy_selections(
      model = model,
      other_constrained_groups = other_constrained_groups,
      remove_selection = ['resseq 0'],
      as_flex_arrays    = False)
  except Exception as e:
    assert str(e) == "Duplicate selection: occupancies of same atoms selected to be fixed and to be refined."

def exercise_12(verbose):
  pdb_file = libtbx.env.find_in_repositories(
    relative_path="phenix_regression/pdb/gocr_2.pdb",
    test=os.path.isfile)
  if (verbose): log = sys.stdout
  else: log = StringIO()
  model = get_model(pdb_file, log)
  answer = [ [[4],[5]], [[16],[17]], [[21]], [[23,24,25,26,27,28,29,30,31]] ]
  other_constrained_groups = make_up_other_constrained_groups_obj(
    selections = [ ['resseq 6'] ])
  result = occupancy_selections(
    model = model,
    remove_selection = ['resseq 1'],
    other_constrained_groups = other_constrained_groups,
    as_flex_arrays    = False)
  assert approx_equal(result, answer)
  #
  answer = [ [[4],[5]], [[16],[17]], [[21]], [[23]], [[24]], [[25]], [[26]], [[27]], [[28]], [[29]], [[30]], [[31]] ]
  result = occupancy_selections(
    model = model,
    remove_selection = ['resseq 1'],
    other_individual_selection_strings = ['resseq 6'],
    as_flex_arrays    = False)
  assert approx_equal(result, answer)

def exercise_13(verbose):
  pdb_file = libtbx.env.find_in_repositories(
    relative_path="phenix_regression/pdb/lys_1.pdb",
    test=os.path.isfile)
  if (verbose): log = sys.stdout
  else: log = StringIO()
  model = get_model(pdb_file, log)
  answer = [ [[8],[9]], [[10]], [[0],[1]], [[2],[3]] ]
  other_constrained_groups = make_up_other_constrained_groups_obj(
    selections = [ ['chain A and resseq 1 and name N','chain A and resseq 1 and name CA'],
                   ['chain A and resseq 1 and name C','chain A and resseq 1 and name O'] ]
    )
  result = occupancy_selections(
    model = model,
    other_constrained_groups = other_constrained_groups,
    as_flex_arrays    = False)
  assert approx_equal(result, answer)

def exercise_14(verbose):
  pdb_file = libtbx.env.find_in_repositories(
    relative_path="phenix_regression/pdb/lys_1.pdb",
    test=os.path.isfile)
  if (verbose): log = sys.stdout
  else: log = StringIO()
  model = get_model(pdb_file, log)
  answer = [ [[8],[9]], [[10]], [[0,1,2],[3,4]], [[5],[6]], [[7]] ]

  other_constrained_groups = make_up_other_constrained_groups_obj(
    selections = [ ['chain A and resseq 1 and (name N or name CA or name C)', 'chain A and resseq 1 and (name O or name CB)'],
                   ['chain A and resseq 1 and name CG','chain A and resseq 1 and name CD'],
                   ['chain A and resseq 1 and name CE'] ]
    )
  result = occupancy_selections(
    model = model,
    other_constrained_groups = other_constrained_groups,
    as_flex_arrays    = False)
  assert approx_equal(result, answer)

def exercise_15(verbose):
  pdb_file = libtbx.env.find_in_repositories(
    relative_path="phenix_regression/pdb/lys_1.pdb",
    test=os.path.isfile)
  if (verbose): log = sys.stdout
  else: log = StringIO()
  model = get_model(pdb_file, log)
  answer = [ [[8],[9]], [[0,1,2],[10]], [[5,7]] ]

  other_constrained_groups = make_up_other_constrained_groups_obj(
    selections = [ ['chain A and resseq 1 and (name N or name CA or name C)', 'chain S and resseq 1'],
                   ['chain A and resseq 1 and name CG or chain A and resseq 1 and name CE'] ]
    )
  result = occupancy_selections(
    model = model,
    other_constrained_groups = other_constrained_groups,
    as_flex_arrays    = False)
  assert approx_equal(result, answer)

def exercise_16(verbose):
  pdb_file = libtbx.env.find_in_repositories(
    relative_path="phenix_regression/pdb/lys_1.pdb",
    test=os.path.isfile)
  if (verbose): log = sys.stdout
  else: log = StringIO()
  model = get_model(pdb_file, log)
  answer = [ [[8],[9],[10]] ]
  other_constrained_groups = make_up_other_constrained_groups_obj(
    selections = [
      ['chain A and resseq 1 and name NZ and altloc A', 'chain A and resseq 1 and name NZ and altloc B', 'chain S and resseq 1'] ]
    )
  result = occupancy_selections(
    model = model,
    other_constrained_groups = other_constrained_groups,
    as_flex_arrays    = False)
  assert approx_equal(result, answer)

def exercise_17(verbose):
  pdb_file = libtbx.env.find_in_repositories(
    relative_path="phenix_regression/pdb/lys_1.pdb",
    test=os.path.isfile)
  if (verbose): log = sys.stdout
  else: log = StringIO()
  model = get_model(pdb_file, log)
  answer = [ [[8,9,10]] ]
  other_constrained_groups = make_up_other_constrained_groups_obj(
    selections = [
      ['chain A and resseq 1 and name NZ and altloc A or chain A and resseq 1 and name NZ and altloc B or chain S and resseq 1'] ]
    )
  result = occupancy_selections(
    model = model,
    other_constrained_groups = other_constrained_groups,
    as_flex_arrays    = False)
  assert approx_equal(result, answer)

def exercise_18(verbose):
  pdb_file = libtbx.env.find_in_repositories(
    relative_path="phenix_regression/pdb/lys_2.pdb",
    test=os.path.isfile)
  if (verbose): log = sys.stdout
  else: log = StringIO()
  model = get_model(pdb_file, log)
  answer = [ [[8],[9],[10]] ]
  other_constrained_groups = make_up_other_constrained_groups_obj(
   selections = [
    ['chain A and resseq 1 and name NZ and altloc A','chain A and resseq 1 and name NZ and altloc B','chain S and resseq 1 and altloc C']]
  )
  result = occupancy_selections(
    model = model,
    other_constrained_groups = other_constrained_groups,
    as_flex_arrays    = False)
  assert approx_equal(result, answer)

def exercise_19(verbose):
  pdb_file = libtbx.env.find_in_repositories(
    relative_path="phenix_regression/pdb/lys_1.pdb",
    test=os.path.isfile)
  if (verbose): log = sys.stdout
  else: log = StringIO()
  model = get_model(pdb_file, log)
  answer = [ [[8],[9],[10]] ]
  tmp = "chain A and resseq 1 and name XX and altloc A"
  other_constrained_groups = make_up_other_constrained_groups_obj(
    selections = [[
      tmp,
      'chain A and resseq 1 and name NZ and altloc B',
      'chain S and resseq 1']])
  try:
    result = occupancy_selections(
      model = model,
      other_constrained_groups = other_constrained_groups,
      as_flex_arrays    = False)
  except Exception as e:
    assert str(e) == \
      'Selection string results in empty selection (selects no atoms): "%s"' \
      % tmp

def exercise_20(verbose):
  pdb_file = libtbx.env.find_in_repositories(
    relative_path="phenix_regression/pdb/ile_2conf_h.pdb",
    test=os.path.isfile)
  if (verbose): log = sys.stdout
  else: log = StringIO()
  model = get_model(pdb_file, log)
  answer = [ [[4,5,6,7,8,9,10,11,12,13,14,15,16,17,18], [19,20,21,22,23,24,25,26,27,28,29,30,31,32,33]] ]
  result = occupancy_selections(
    model = model,
    as_flex_arrays    = False)
  assert approx_equal(result, answer)

def exercise_21(verbose):
  pdb_file = libtbx.env.find_in_repositories(
    relative_path="phenix_regression/pdb/gocr_3.pdb",
    test=os.path.isfile)
  if (verbose): log = sys.stdout
  else: log = StringIO()
  model = get_model(pdb_file, log)
  #
  base = [[[2], [3]],
         [[6, 7, 8, 9, 10], [11, 12, 13, 14, 15]],
         [[16], [17]],
         [[21]],
         [[23]],
         [[24, 25, 26, 27], [28, 29, 30, 31]],
         [[36]],
         [[47]],
         [[48]],
         [[49]],
         [[50]],
         [[51]],
         [[53]],
         [[56, 57, 58, 59]],
         [[60, 61, 62, 63]],
         [[64, 65, 66, 67, 68]],
         [[37], [40]],
         [[38], [41]],
         [[39], [42]],
         [[43, 44, 45, 46]]]
  res = occupancy_selections(
    model = model,
    as_flex_arrays    = False)
  res = extract_serials(model.get_atoms(), res)
  assert approx_equal(res, base)

def exercise_22(verbose):
  pdb_file = libtbx.env.find_in_repositories(
    relative_path="phenix_regression/pdb/gocr_4.pdb",
    test=os.path.isfile)
  if (verbose): log = sys.stdout
  else: log = StringIO()
  model = get_model(pdb_file, log)
  #
  base = [[[0, 1, 2, 3, 8, 9, 10, 11, 12], [4, 5, 6, 7, 13, 14, 15, 16, 17]]]
  res = occupancy_selections(
    model = model,
    as_flex_arrays    = False)
  res = extract_serials(model.get_atoms(), res)
  assert approx_equal(res, base)

def exercise_23(verbose):
  pdb_file = libtbx.env.find_in_repositories(
    relative_path="phenix_regression/pdb/gocr_5.pdb",
    test=os.path.isfile)
  if (verbose): log = sys.stdout
  else: log = StringIO()
  model = get_model(pdb_file, log)
  #
  base = [[[1, 2, 3, 4, 5, 6]], [[7, 8, 9, 10, 11], [12, 13, 14, 15, 16]]]
  res = occupancy_selections(
    model = model,
    as_flex_arrays    = False)
  res = extract_serials(model.get_atoms(), res)
  assert approx_equal(res, base)

def exercise_24(verbose):
  pdb_str1="""\
CRYST1   10.707   11.101   13.552  90.00  90.00  90.00 P 1
ATOM      0  N  AALA A   9       3.452   6.807   3.508  0.19  9.33      A    N
ATOM      1  CA AALA A   9       4.572   6.204   4.211  0.19  9.82      A    C
ATOM      2  C  AALA A   9       4.165   5.990   5.664  0.19 10.34      A    C
ATOM      3  O  AALA A   9       3.000   6.165   6.021  0.19 10.96      A    O
ATOM      4  CB AALA A   9       5.792   7.098   4.116  0.19 10.31      A    C
ATOM      5  H  AALA A   9       3.466   7.667   3.487  0.19  8.78      A    H
ATOM      6  HA AALA A   9       4.802   5.351   3.810  0.19  9.23      A    H
ATOM      7  HB1AALA A   9       6.533   6.686   4.588  0.19  9.91      A    H
ATOM      8  HB2AALA A   9       6.031   7.221   3.184  0.19  9.91      A    H
ATOM      9  HB3AALA A   9       5.594   7.960   4.515  0.19  9.91      A    H
ATOM     10  N  BALA A   9       3.348   6.697   3.518  0.28  8.28      A    N
ATOM     11  CA BALA A   9       4.461   6.052   4.195  0.28  9.14      A    C
ATOM     12  C  BALA A   9       4.138   5.964   5.683  0.28  9.84      A    C
ATOM     13  O  BALA A   9       3.003   6.215   6.089  0.28 10.68      A    O
ATOM     14  CB BALA A   9       5.726   6.829   3.952  0.28  9.20      A    C
ATOM     15  H  BALA A   9       3.422   7.551   3.454  0.28  8.78      A    H
ATOM     16  HA BALA A   9       4.597   5.156   3.849  0.28  9.23      A    H
ATOM     17  HB1BALA A   9       6.465   6.395   4.406  0.28  9.91      A    H
ATOM     18  HB2BALA A   9       5.907   6.863   3.000  0.28  9.91      A    H
ATOM     19  HB3BALA A   9       5.623   7.731   4.294  0.28  9.91      A    H
ATOM     20  N  CALA A   9       3.608   6.763   3.402  0.28  8.32      A    N
ATOM     21  CA CALA A   9       4.617   6.060   4.177  0.28  9.56      A    C
ATOM     22  C  CALA A   9       4.219   6.081   5.651  0.28 10.15      A    C
ATOM     23  O  CALA A   9       3.126   6.528   6.006  0.28 10.64      A    O
ATOM     24  CB CALA A   9       5.981   6.684   3.973  0.28 10.39      A    C
ATOM     25  H  CALA A   9       3.801   7.579   3.210  0.28  8.78      A    H
ATOM     26  HA CALA A   9       4.671   5.139   3.876  0.28  9.23      A    H
ATOM     27  HB1CALA A   9       6.639   6.202   4.497  0.28  9.91      A    H
ATOM     28  HB2CALA A   9       6.220   6.639   3.034  0.28  9.91      A    H
ATOM     29  HB3CALA A   9       5.959   7.611   4.257  0.28  9.91      A    H
ATOM     30  N  DALA A   9       3.518   6.930   3.530  0.25  8.78      A    N
ATOM     31  CA DALA A   9       4.639   6.333   4.232  0.25  9.23      A    C
ATOM     32  C  DALA A   9       4.203   6.093   5.674  0.25 10.10      A    C
ATOM     33  O  DALA A   9       3.051   6.346   6.031  0.25 10.72      A    O
ATOM     34  CB DALA A   9       5.837   7.255   4.177  0.25  9.91      A    C
ATOM     35  H  DALA A   9       3.490   7.789   3.568  0.25  8.78      A    H
ATOM     36  HA DALA A   9       4.898   5.494   3.819  0.25  9.23      A    H
ATOM     37  HB1DALA A   9       6.581   6.848   4.648  0.25  9.91      A    H
ATOM     38  HB2DALA A   9       6.086   7.408   3.252  0.25  9.91      A    H
ATOM     39  HB3DALA A   9       5.614   8.101   4.595  0.25  9.91      A    H
ATOM     40  N   VAL A  10       5.119   5.606   6.502  1.00 11.13      A    N
ATOM     41  CA  VAL A  10       4.846   5.470   7.925  1.00 12.50      A    C
ATOM     42  C   VAL A  10       4.347   6.801   8.520  1.00 11.26      A    C
ATOM     43  O   VAL A  10       4.763   7.871   8.095  1.00 11.53      A    O
ATOM     44  HA  VAL A  10       4.118   4.835   8.017  1.00 12.50      A    H
ATOM     45  CB AVAL A  10       5.994   4.806   8.722  0.21 14.17      A    C
ATOM     46  CG1AVAL A  10       6.640   3.699   7.889  0.21 14.17      A    C
ATOM     47  CG2AVAL A  10       7.005   5.815   9.197  0.21 15.20      A    C
ATOM     48  H  AVAL A  10       5.926   5.421   6.269  0.19 11.13      A    H
ATOM     49  HB AVAL A  10       5.616   4.404   9.520  0.21 14.91      A    H
ATOM     50 HG11AVAL A  10       7.358   3.289   8.396  0.21 16.29      A    H
ATOM     51 HG12AVAL A  10       5.975   3.028   7.671  0.21 16.29      A    H
ATOM     52 HG13AVAL A  10       6.998   4.077   7.070  0.21 16.29      A    H
ATOM     53 HG21AVAL A  10       7.707   5.363   9.691  0.21 15.63      A    H
ATOM     54 HG22AVAL A  10       7.391   6.271   8.433  0.21 15.63      A    H
ATOM     55 HG23AVAL A  10       6.570   6.462   9.774  0.21 15.63      A    H
ATOM     56  CB BVAL A  10       6.135   4.987   8.645  0.79 14.91      A    C
ATOM     57  CG1BVAL A  10       6.081   5.228  10.144  0.79 16.28      A    C
ATOM     58  CG2BVAL A  10       6.351   3.507   8.360  0.79 15.63      A    C
ATOM     59  H  BVAL A  10       5.928   5.441   6.263  0.28 11.13      A    H
ATOM     60  HB BVAL A  10       6.879   5.504   8.299  0.79 14.91      A    H
ATOM     61 HG11BVAL A  10       6.902   4.913  10.552  0.79 16.29      A    H
ATOM     62 HG12BVAL A  10       5.978   6.177  10.316  0.79 16.29      A    H
ATOM     63 HG13BVAL A  10       5.328   4.748  10.522  0.79 16.29      A    H
ATOM     64 HG21BVAL A  10       7.156   3.205   8.809  0.79 15.63      A    H
ATOM     65 HG22BVAL A  10       5.590   3.000   8.685  0.79 15.63      A    H
ATOM     66 HG23BVAL A  10       6.445   3.372   7.404  0.79 15.63      A    H
ATOM     67  H  CVAL A  10       5.907   5.353   6.270  0.28 11.13      A    H
ATOM     68  H  DVAL A  10       5.903   5.349   6.260  0.25 11.13      A    H
TER
END
"""
  pdb_str2="""\
CRYST1   10.707   11.101   13.552  90.00  90.00  90.00 P 1
ATOM      0  N  AALA A   9       3.452   6.807   3.508  0.19  9.33      A    N
ATOM      1  CA AALA A   9       4.572   6.204   4.211  0.19  9.82      A    C
ATOM      2  C  AALA A   9       4.165   5.990   5.664  0.19 10.34      A    C
ATOM      3  O  AALA A   9       3.000   6.165   6.021  0.19 10.96      A    O
ATOM      4  CB AALA A   9       5.792   7.098   4.116  0.19 10.31      A    C
ATOM      5  D  AALA A   9       3.466   7.667   3.487  0.19  8.78      A    D
ATOM      6  DA AALA A   9       4.802   5.351   3.810  0.19  9.23      A    D
ATOM      7  DB1AALA A   9       6.533   6.686   4.588  0.19  9.91      A    D
ATOM      8  DB2AALA A   9       6.031   7.221   3.184  0.19  9.91      A    D
ATOM      9  DB3AALA A   9       5.594   7.960   4.515  0.19  9.91      A    D
ATOM     10  N  BALA A   9       3.348   6.697   3.518  0.28  8.28      A    N
ATOM     11  CA BALA A   9       4.461   6.052   4.195  0.28  9.14      A    C
ATOM     12  C  BALA A   9       4.138   5.964   5.683  0.28  9.84      A    C
ATOM     13  O  BALA A   9       3.003   6.215   6.089  0.28 10.68      A    O
ATOM     14  CB BALA A   9       5.726   6.829   3.952  0.28  9.20      A    C
ATOM     15  D  BALA A   9       3.422   7.551   3.454  0.28  8.78      A    D
ATOM     16  DA BALA A   9       4.597   5.156   3.849  0.28  9.23      A    D
ATOM     17  DB1BALA A   9       6.465   6.395   4.406  0.28  9.91      A    D
ATOM     18  DB2BALA A   9       5.907   6.863   3.000  0.28  9.91      A    D
ATOM     19  DB3BALA A   9       5.623   7.731   4.294  0.28  9.91      A    D
ATOM     20  N  CALA A   9       3.608   6.763   3.402  0.28  8.32      A    N
ATOM     21  CA CALA A   9       4.617   6.060   4.177  0.28  9.56      A    C
ATOM     22  C  CALA A   9       4.219   6.081   5.651  0.28 10.15      A    C
ATOM     23  O  CALA A   9       3.126   6.528   6.006  0.28 10.64      A    O
ATOM     24  CB CALA A   9       5.981   6.684   3.973  0.28 10.39      A    C
ATOM     25  D  CALA A   9       3.801   7.579   3.210  0.28  8.78      A    D
ATOM     26  DA CALA A   9       4.671   5.139   3.876  0.28  9.23      A    D
ATOM     27  DB1CALA A   9       6.639   6.202   4.497  0.28  9.91      A    D
ATOM     28  DB2CALA A   9       6.220   6.639   3.034  0.28  9.91      A    D
ATOM     29  DB3CALA A   9       5.959   7.611   4.257  0.28  9.91      A    D
ATOM     30  N  DALA A   9       3.518   6.930   3.530  0.25  8.78      A    N
ATOM     31  CA DALA A   9       4.639   6.333   4.232  0.25  9.23      A    C
ATOM     32  C  DALA A   9       4.203   6.093   5.674  0.25 10.10      A    C
ATOM     33  O  DALA A   9       3.051   6.346   6.031  0.25 10.72      A    O
ATOM     34  CB DALA A   9       5.837   7.255   4.177  0.25  9.91      A    C
ATOM     35  D  DALA A   9       3.490   7.789   3.568  0.25  8.78      A    D
ATOM     36  DA DALA A   9       4.898   5.494   3.819  0.25  9.23      A    D
ATOM     37  DB1DALA A   9       6.581   6.848   4.648  0.25  9.91      A    D
ATOM     38  DB2DALA A   9       6.086   7.408   3.252  0.25  9.91      A    D
ATOM     39  DB3DALA A   9       5.614   8.101   4.595  0.25  9.91      A    D
ATOM     40  N   VAL A  10       5.119   5.606   6.502  1.00 11.13      A    N
ATOM     41  CA  VAL A  10       4.846   5.470   7.925  1.00 12.50      A    C
ATOM     42  C   VAL A  10       4.347   6.801   8.520  1.00 11.26      A    C
ATOM     43  O   VAL A  10       4.763   7.871   8.095  1.00 11.53      A    O
ATOM     44  HA  VAL A  10       4.118   4.835   8.017  1.00 12.50      A    D
ATOM     45  CB AVAL A  10       5.994   4.806   8.722  0.21 14.17      A    C
ATOM     46  CG1AVAL A  10       6.640   3.699   7.889  0.21 14.17      A    C
ATOM     47  CG2AVAL A  10       7.005   5.815   9.197  0.21 15.20      A    C
ATOM     48  D  AVAL A  10       5.926   5.421   6.269  0.19 11.13      A    D
ATOM     49  DB AVAL A  10       5.616   4.404   9.520  0.21 14.91      A    D
ATOM     50 DG11AVAL A  10       7.358   3.289   8.396  0.21 16.29      A    D
ATOM     51 DG12AVAL A  10       5.975   3.028   7.671  0.21 16.29      A    D
ATOM     52 DG13AVAL A  10       6.998   4.077   7.070  0.21 16.29      A    D
ATOM     53 DG21AVAL A  10       7.707   5.363   9.691  0.21 15.63      A    D
ATOM     54 DG22AVAL A  10       7.391   6.271   8.433  0.21 15.63      A    D
ATOM     55 DG23AVAL A  10       6.570   6.462   9.774  0.21 15.63      A    D
ATOM     56  CB BVAL A  10       6.135   4.987   8.645  0.79 14.91      A    C
ATOM     57  CG1BVAL A  10       6.081   5.228  10.144  0.79 16.28      A    C
ATOM     58  CG2BVAL A  10       6.351   3.507   8.360  0.79 15.63      A    C
ATOM     59  D  BVAL A  10       5.928   5.441   6.263  0.28 11.13      A    D
ATOM     60  DB BVAL A  10       6.879   5.504   8.299  0.79 14.91      A    D
ATOM     61 DG11BVAL A  10       6.902   4.913  10.552  0.79 16.29      A    D
ATOM     62 DG12BVAL A  10       5.978   6.177  10.316  0.79 16.29      A    D
ATOM     63 DG13BVAL A  10       5.328   4.748  10.522  0.79 16.29      A    D
ATOM     64 DG21BVAL A  10       7.156   3.205   8.809  0.79 15.63      A    D
ATOM     65 DG22BVAL A  10       5.590   3.000   8.685  0.79 15.63      A    D
ATOM     66 DG23BVAL A  10       6.445   3.372   7.404  0.79 15.63      A    D
ATOM     67  D  CVAL A  10       5.907   5.353   6.270  0.28 11.13      A    D
ATOM     68  D  DVAL A  10       5.903   5.349   6.260  0.25 11.13      A    D
TER
END
"""
  if (verbose): log = sys.stdout
  else: log = StringIO()
  for pdb_str in [pdb_str1, pdb_str2]:
    model = get_model_str(pdb_str, log)
    res = occupancy_selections(
      model = model,
      as_flex_arrays    = False)
    answer = \
      [[[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 48],
        [10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 59],
        [20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 67],
        [30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 68]],
       [[45, 46, 47, 49, 50, 51, 52, 53, 54, 55],
       [56, 57, 58, 60, 61, 62, 63, 64, 65, 66]]]
    assert approx_equal(res, answer)

def exercise_25(verbose):
  pdb_str="""\
CRYST1   10.707   11.101   13.552  90.00  90.00  90.00 P 1
ATOM      0  N   ALA A   9       3.452   6.807   3.508  1.00  9.33      A    N
ATOM      1  CA  ALA A   9       4.572   6.204   4.211  1.00  9.82      A    C
ATOM      2  C   ALA A   9       4.165   5.990   5.664  1.00 10.34      A    C
ATOM      3  O   ALA A   9       3.000   6.165   6.021  1.00 10.96      A    O
ATOM      4  CB  ALA A   9       5.792   7.098   4.116  1.00 10.31      A    C
ATOM      5  HA  ALA A   9       4.802   5.351   3.810  1.00  9.23      A    H
ATOM      6  HB1 ALA A   9       6.533   6.686   4.588  1.00  9.91      A    H
ATOM      7  HB2 ALA A   9       6.031   7.221   3.184  1.00  9.91      A    H
ATOM      8  HB3 ALA A   9       5.594   7.960   4.515  1.00  9.91      A    H
ATOM      9  H  AALA A   9       3.466   7.667   3.487  0.40  8.78      A    H
ATOM     10  D  BALA A   9       3.466   7.667   3.487  0.60  8.78      A    D
ATOM     11  N   VAL A  10       5.119   5.606   6.502  1.00 11.13      A    N
ATOM     12  CA  VAL A  10       4.846   5.470   7.925  1.00 12.50      A    C
ATOM     13  C   VAL A  10       4.347   6.801   8.520  1.00 11.26      A    C
ATOM     14  O   VAL A  10       4.763   7.871   8.095  1.00 11.53      A    O
ATOM     15  HA  VAL A  10       4.118   4.835   8.017  1.00 12.50      A    H
ATOM     16  CB  VAL A  10       5.994   4.806   8.722  1.00 14.17      A    C
ATOM     17  CG1 VAL A  10       6.640   3.699   7.889  1.00 14.17      A    C
ATOM     18  CG2 VAL A  10       7.005   5.815   9.197  1.00 15.20      A    C
ATOM     19  HB  VAL A  10       5.616   4.404   9.520  1.00 14.91      A    H
ATOM     20 HG11 VAL A  10       7.358   3.289   8.396  1.00 16.29      A    H
ATOM     21 HG12 VAL A  10       5.975   3.028   7.671  1.00 16.29      A    H
ATOM     22 HG13 VAL A  10       6.998   4.077   7.070  1.00 16.29      A    H
ATOM     23 HG21 VAL A  10       7.707   5.363   9.691  1.00 15.63      A    H
ATOM     24 HG22 VAL A  10       7.391   6.271   8.433  1.00 15.63      A    H
ATOM     25 HG23 VAL A  10       6.570   6.462   9.774  1.00 15.63      A    H
ATOM     26  H  AVAL A  10       5.926   5.421   6.269  0.30 11.13      A    H
ATOM     27  D  BVAL A  10       5.926   5.421   6.269  0.70 11.13      A    D
TER
END
"""
  if (verbose): log = sys.stdout
  else: log = StringIO()
  model = get_model_str(pdb_str, log)
  res = occupancy_selections(
    model = model,
    as_flex_arrays    = False)
  answer = [ [[9],[10]], [[26],[27]] ]
  assert approx_equal(res, answer)

def exercise_26(verbose):
  pdb_str="""\
CRYST1   71.040   72.017   72.362  90.00 100.48  90.00 C 1 2 1
ATOM     96  N   PRO L   5       2.689  13.877  15.387  1.00 13.65           N
ATOM     97  CA  PRO L   5       1.824  14.762  14.572  1.00 17.31           C
ATOM     98  C   PRO L   5       0.338  14.432  14.641  1.00 20.79           C
ATOM     99  O   PRO L   5      -0.466  15.376  14.642  1.00 20.37           O
ATOM    100  CB  PRO L   5       2.330  14.534  13.143  1.00 20.71           C
ATOM    101  CG  PRO L   5       3.772  14.184  13.326  1.00 20.25           C
ATOM    102  CD  PRO L   5       3.871  13.403  14.633  1.00 16.57           C
ATOM    103  HA  PRO L   5       1.981  15.805  14.846  1.00 17.31           H
ATOM    104  HB2 PRO L   5       1.780  13.709  12.691  1.00 20.71           H
ATOM    105  HB3 PRO L   5       2.220  15.447  12.558  1.00 20.71           H
ATOM    106  HG2 PRO L   5       4.103  13.567  12.492  1.00 20.25           H
ATOM    107  HG3 PRO L   5       4.363  15.098  13.382  1.00 20.25           H
ATOM    108  HD2 PRO L   5       3.805  12.331  14.446  1.00 16.57           H
ATOM    109  HD3 PRO L   5       4.791  13.666  15.154  1.00 16.57           H
ATOM    110  N   LEU L   6      -0.052  13.175  14.677  1.00 13.93           N
ATOM    111  CA  LEU L   6      -1.446  12.769  14.667  1.00 15.53           C
ATOM    112  C   LEU L   6      -2.079  12.634  16.029  1.00 17.57           C
ATOM    113  O   LEU L   6      -3.268  12.311  16.111  1.00 18.17           O
ATOM    114  CB  LEU L   6      -1.648  11.435  13.889  1.00 17.76           C
ATOM    115  CG  LEU L   6      -1.291  11.544  12.396  1.00 18.22           C
ATOM    116  CD1 LEU L   6      -1.474  10.257  11.651  1.00 18.93           C
ATOM    117  CD2 LEU L   6      -2.125  12.629  11.689  1.00 22.55           C
ATOM    118  HA  LEU L   6      -2.017  13.534  14.144  1.00 15.53           H
ATOM    119  HB2 LEU L   6      -1.011  10.669  14.331  1.00 17.76           H
ATOM    120  HB3 LEU L   6      -2.693  11.135  13.959  1.00 17.76           H
ATOM    121  HG  LEU L   6      -0.242  11.827  12.310  1.00 18.22           H
ATOM    122 HD11 LEU L   6      -0.750  10.210  10.838  1.00 18.93           H
ATOM    123 HD12 LEU L   6      -1.319   9.426  12.338  1.00 18.93           H
ATOM    124 HD13 LEU L   6      -2.488  10.221  11.252  1.00 18.93           H
ATOM    125 HD21 LEU L   6      -2.084  12.462  10.613  1.00 22.55           H
ATOM    126 HD22 LEU L   6      -3.156  12.565  12.037  1.00 22.55           H
ATOM    127 HD23 LEU L   6      -1.712  13.609  11.929  1.00 22.55           H
ATOM    128  H  ALEU L   6       0.595  12.387  14.715  0.50 13.93           H
ATOM    129  D  BLEU L   6       0.595  12.387  14.715  0.50 13.93           D
"""
  if (verbose): log = sys.stdout
  else: log = StringIO()
  model = get_model_str(pdb_str, log)
  res = occupancy_selections(
    model = model,
    as_flex_arrays    = False)
  answer = [ [[32], [33]] ]
  assert approx_equal(res, answer)

def exercise_27(verbose):
  pdb_str="""\
CRYST1   64.714   39.225   38.645  90.00 117.38  90.00 C 1 2 1
ATOM      0  N   SER A  -1      20.605   9.913  24.660  1.00 32.98           N
ATOM      1  CA  SER A  -1      21.415  10.057  23.431  1.00 25.22           C
ATOM      2  C   SER A  -1      20.514  10.247  22.233  1.00 25.05           C
ATOM      3  O   SER A  -1      19.332   9.926  22.266  1.00 28.08           O
ATOM      4  CB  SER A  -1      22.253   8.810  23.194  1.00 28.97           C
ATOM      5  OG  SER A  -1      21.417   7.708  22.900  1.00 37.21           O
ATOM      6  H1  SER A  -1      19.896  10.449  24.612  1.00 38.17           H
ATOM      7  H2  SER A  -1      20.335   9.069  24.737  1.00 27.38           H
ATOM      8  H3  SER A  -1      21.098  10.134  25.368  1.00 38.75           H
ATOM      9  HA  SER A  -1      21.997  10.829  23.514  1.00 12.22           H
ATOM     10  HB2 SER A  -1      22.844   8.970  22.440  1.00 22.78           H
ATOM     11  HB3 SER A  -1      22.771   8.614  23.990  1.00 30.47           H
ATOM     12  HG  SER A  -1      21.872   7.007  22.826  1.00 42.35           H
ATOM     13  N  AMET A   0      21.097  10.723  21.147  0.49 20.67           N
ATOM     14  CA AMET A   0      20.340  10.870  19.929  0.49 21.49           C
ATOM     15  C  AMET A   0      21.236  10.795  18.720  0.49 18.70           C
ATOM     16  O  AMET A   0      22.394  11.216  18.750  0.49 19.47           O
ATOM     17  CB AMET A   0      19.569  12.183  19.945  0.49 22.62           C
ATOM     18  CG AMET A   0      20.423  13.414  20.138  0.49 24.87           C
ATOM     19  SD AMET A   0      19.580  14.932  19.650  0.49 29.00           S
ATOM     20  CE AMET A   0      17.946  14.760  20.377  0.49 36.23           C
ATOM     21  H  AMET A   0      21.920  10.964  21.095  0.49 28.25           H
ATOM     22  HA AMET A   0      19.697  10.146  19.870  0.49  7.25           H
ATOM     23  HB2AMET A   0      19.093  12.280  19.105  0.49 13.51           H
ATOM     24  HB3AMET A   0      18.941  12.141  20.681  0.49  7.62           H
ATOM     25  HG2AMET A   0      20.671  13.490  21.072  0.49 26.02           H
ATOM     26  HG3AMET A   0      21.219  13.333  19.589  0.49 30.87           H
ATOM     27  HE1AMET A   0      17.284  14.819  19.669  0.49 20.79           H
ATOM     28  HE2AMET A   0      17.863  13.908  20.829  0.49  8.45           H
ATOM     29  HE3AMET A   0      17.812  15.481  21.012  0.49 30.25           H
ATOM     30  N  BMET A   0      21.082  10.809  21.171  0.51 21.19           N
ATOM     31  CA BMET A   0      20.368  11.023  19.923  0.51 23.13           C
ATOM     32  C  BMET A   0      21.273  10.654  18.766  0.51 21.10           C
ATOM     33  O  BMET A   0      22.496  10.703  18.893  0.51 19.93           O
ATOM     34  CB BMET A   0      19.961  12.488  19.782  0.51 27.15           C
ATOM     35  CG BMET A   0      19.070  12.993  20.889  0.51 29.67           C
ATOM     36  SD BMET A   0      18.685  14.739  20.684  0.51 41.63           S
ATOM     37  CE BMET A   0      17.734  15.043  22.171  0.51 35.23           C
ATOM     38  HA BMET A   0      19.568  10.476  19.897  0.51 36.28           H
ATOM     39  HB2BMET A   0      20.762  13.035  19.778  0.51  8.59           H
ATOM     40  HB3BMET A   0      19.485  12.602  18.945  0.51 27.25           H
ATOM     41  HG2BMET A   0      18.236  12.497  20.877  0.51 21.33           H
ATOM     42  HG3BMET A   0      19.519  12.877  21.741  0.51 34.36           H
ATOM     43  HE1BMET A   0      17.141  15.795  22.018  0.51 42.08           H
ATOM     44  HE2BMET A   0      17.217  14.249  22.380  0.51 22.21           H
ATOM     45  HE3BMET A   0      18.343  15.241  22.899  0.51 40.99           H
"""
  if (verbose): log = sys.stdout
  else: log = StringIO()
  model = get_model_str(pdb_str, log)
  res = occupancy_selections(
    model = model,
    as_flex_arrays    = False)
  answer = [[[13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29],
             [30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45]]]
  assert approx_equal(res, answer)

def exercise_28(verbose):
  pdb_str="""\
CRYST1   64.360   64.360   46.038  90.00  90.00 120.00 P 63
ATOM      0  N   ASP A  48       8.896  25.394  -7.791  1.00  8.05           N
ATOM      1  CA  ASP A  48       8.495  26.452  -6.936  1.00  8.42           C
ATOM      2  C   ASP A  48       8.287  26.047  -5.477  1.00  8.20           C
ATOM      3  O   ASP A  48       8.309  26.881  -4.579  1.00 10.68           O
ATOM      4  CB  ASP A  48       7.216  27.151  -7.426  1.00  9.40           C
ATOM      5  CG  ASP A  48       7.457  27.744  -8.791  1.00 10.91           C
ATOM      6  OD1 ASP A  48       8.234  28.729  -8.836  1.00 16.64           O
ATOM      7  OD2 ASP A  48       6.845  27.293  -9.764  1.00 12.53           O
ATOM      8  HA  ASP A  48       9.193  27.122  -6.935  1.00  8.42           H
ATOM      9  HB2 ASP A  48       6.494  26.507  -7.490  1.00  9.40           H
ATOM     10  HB3 ASP A  48       6.981  27.867  -6.815  1.00  9.40           H
ATOM     11  H  AASP A  48       8.303  25.156  -8.367  0.50  8.04           H
ATOM     12  H  BASP A  48       8.242  25.041  -8.223  0.50  8.04           H
ATOM     13  N  ALEU A  49       8.083  24.740  -5.245  0.79  7.34           N
ATOM     14  CA ALEU A  49       7.817  24.239  -3.906  0.79  6.67           C
ATOM     15  C  ALEU A  49       8.124  22.738  -3.941  0.79  5.81           C
ATOM     16  O  ALEU A  49       7.880  22.074  -4.958  0.79  6.71           O
ATOM     17  CB ALEU A  49       6.385  24.559  -3.494  0.79  7.19           C
ATOM     18  CG ALEU A  49       5.914  24.092  -2.111  0.79  7.07           C
ATOM     19  CD1ALEU A  49       4.885  25.059  -1.536  0.79  8.84           C
ATOM     20  CD2ALEU A  49       5.323  22.713  -2.192  0.79  7.46           C
ATOM     21  H  ALEU A  49       8.095  24.131  -5.852  0.79  7.25           H
ATOM     22  HA ALEU A  49       8.421  24.661  -3.275  0.79  7.14           H
ATOM     23  HB2ALEU A  49       6.277  25.523  -3.518  0.79  9.16           H
ATOM     24  HB3ALEU A  49       5.791  24.158  -4.147  0.79  9.16           H
ATOM     25  HG ALEU A  49       6.673  24.062  -1.508  0.79  6.91           H
ATOM     26 HD11ALEU A  49       4.592  24.730  -0.672  0.79  9.95           H
ATOM     27 HD12ALEU A  49       5.294  25.933  -1.437  0.79  9.95           H
ATOM     28 HD13ALEU A  49       4.130  25.113  -2.143  0.79  9.95           H
ATOM     29 HD21ALEU A  49       4.960  22.476  -1.324  0.79  8.29           H
ATOM     30 HD22ALEU A  49       4.616  22.710  -2.856  0.79  8.29           H
ATOM     31 HD23ALEU A  49       6.015  22.082  -2.442  0.79  8.29           H
ATOM     32  N  BLEU A  49       7.975  24.768  -5.242  0.21  7.25           N
ATOM     33  CA BLEU A  49       7.654  24.205  -3.941  0.21  7.15           C
ATOM     34  C  BLEU A  49       8.003  22.716  -3.887  0.21  7.83           C
ATOM     35  O  BLEU A  49       7.689  22.025  -4.858  0.21  5.06           O
ATOM     36  CB BLEU A  49       6.162  24.365  -3.605  0.21  9.16           C
ATOM     37  CG BLEU A  49       5.681  23.652  -2.331  0.21  6.91           C
ATOM     38  CD1BLEU A  49       6.301  24.276  -1.095  0.21  9.95           C
ATOM     39  CD2BLEU A  49       4.156  23.640  -2.248  0.21  8.29           C
ATOM     40  H  BLEU A  49       7.943  24.178  -5.867  0.21  7.25           H
ATOM     41  HA BLEU A  49       8.173  24.662  -3.262  0.21  7.14           H
ATOM     42  HB2BLEU A  49       5.975  25.310  -3.494  0.21  9.16           H
ATOM     43  HB3BLEU A  49       5.645  24.021  -4.346  0.21  9.16           H
ATOM     44  HG BLEU A  49       5.963  22.725  -2.358  0.21  6.91           H
ATOM     45 HD11BLEU A  49       6.470  23.579  -0.443  0.21  9.95           H
ATOM     46 HD12BLEU A  49       7.132  24.697  -1.346  0.21  9.95           H
ATOM     47 HD13BLEU A  49       5.691  24.937  -0.731  0.21  9.95           H
ATOM     48 HD21BLEU A  49       3.888  23.174  -1.441  0.21  8.29           H
ATOM     49 HD22BLEU A  49       3.834  24.555  -2.225  0.21  8.29           H
ATOM     50 HD23BLEU A  49       3.802  23.184  -3.027  0.21  8.29           H
ATOM     51  N   VAL A  50       8.616  22.239  -2.807  1.00  5.93           N
ATOM     52  CA  VAL A  50       8.845  20.793  -2.609  1.00  5.53           C
ATOM     53  C   VAL A  50       7.981  20.307  -1.457  1.00  5.75           C
ATOM     54  O   VAL A  50       7.971  20.912  -0.389  1.00  6.63           O
ATOM     55  CB  VAL A  50      10.325  20.527  -2.343  1.00  6.31           C
ATOM     56  CG1 VAL A  50      10.556  19.043  -2.072  1.00  7.62           C
ATOM     57  CG2 VAL A  50      11.170  20.998  -3.512  1.00  7.52           C
ATOM     58  HA  VAL A  50       8.593  20.305  -3.404  1.00  5.53           H
ATOM     59  HB  VAL A  50      10.599  21.022  -1.555  1.00  6.31           H
ATOM     60 HG11 VAL A  50      11.507  18.860  -2.118  1.00  7.62           H
ATOM     61 HG12 VAL A  50      10.221  18.824  -1.188  1.00  7.62           H
ATOM     62 HG13 VAL A  50      10.087  18.523  -2.744  1.00  7.62           H
ATOM     63 HG21 VAL A  50      12.097  20.765  -3.345  1.00  7.52           H
ATOM     64 HG22 VAL A  50      10.860  20.562  -4.321  1.00  7.52           H
ATOM     65 HG23 VAL A  50      11.081  21.960  -3.600  1.00  7.52           H
ATOM     66  H  AVAL A  50       8.830  22.718  -2.125  0.79  5.93           H
ATOM     67  H  BVAL A  50       8.914  22.729  -2.166  0.21  5.93           H
TER
END
"""
  if (verbose): log = sys.stdout
  else: log = StringIO()
  model = get_model_str(pdb_str, log)
  res = occupancy_selections(
    model = model,
    as_flex_arrays    = False)
  answer = [ [[11],[12]],
             [[13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,66],
              [32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,67]]]
  assert approx_equal(res, answer)

def exercise_29(verbose):
  pdb_str="""\
CRYST1  148.270   44.010   47.390  90.00 101.57  90.00 C 1 2 1
ATOM      0  N   GLY A 285     -41.269  16.430  -4.458  1.00 18.77           N
ATOM      1  CA  GLY A 285     -41.021  16.772  -5.854  1.00 20.45           C
ATOM      2  H   GLY A 285     -42.080  16.182  -4.313  1.00 22.53           H
ATOM      3  C  AGLY A 285     -41.133  18.291  -6.119  0.85 20.52           C
ATOM      4  O  AGLY A 285     -41.030  18.770  -7.258  0.85 22.89           O
ATOM      5  HA2AGLY A 285     -40.130  16.482  -6.104  0.85 24.54           H
ATOM      6  HA3AGLY A 285     -41.663  16.314  -6.418  0.85 24.54           H
ATOM      7  C  BGLY A 285     -40.556  18.155  -6.113  0.15 20.45           C
ATOM      8  O  BGLY A 285     -39.925  18.445  -7.127  0.15 21.06           O
ATOM      9  HA2BGLY A 285     -40.352  16.166  -6.208  0.15 24.54           H
ATOM     10  HA3BGLY A 285     -41.839  16.638  -6.357  0.15 24.54           H
ATOM     11  N  AASN A 286     -41.375  19.070  -5.066  0.75 20.63           N
ATOM     12  CA AASN A 286     -41.558  20.524  -5.179  0.75 21.34           C
ATOM     13  C  AASN A 286     -40.921  21.176  -3.941  0.75 19.76           C
ATOM     14  O  AASN A 286     -41.136  20.695  -2.825  0.75 18.94           O
ATOM     15  CB AASN A 286     -43.061  20.822  -5.246  0.75 23.19           C
ATOM     16  CG AASN A 286     -43.390  22.293  -5.087  0.75 24.76           C
ATOM     17  OD1AASN A 286     -43.580  22.784  -3.975  0.75 25.15           O
ATOM     18  ND2AASN A 286     -43.491  22.996  -6.206  0.75 26.38           N
ATOM     19  H  AASN A 286     -41.441  18.778  -4.260  0.75 24.76           H
ATOM     20  HA AASN A 286     -41.121  20.863  -5.988  0.75 25.61           H
ATOM     21  HB2AASN A 286     -43.400  20.532  -6.107  0.75 27.82           H
ATOM     22  HB3AASN A 286     -43.509  20.338  -4.535  0.75 27.82           H
ATOM     23 HD21AASN A 286     -43.371  22.614  -6.967  0.75 31.65           H
ATOM     24 HD22AASN A 286     -43.677  23.835  -6.171  0.75 31.65           H
ATOM     25  N  BASN A 286     -40.878  19.026  -5.184  0.25 20.30           N
ATOM     26  CA BASN A 286     -40.589  20.401  -5.396  0.25 20.20           C
ATOM     27  C  BASN A 286     -40.224  21.016  -4.085  0.25 18.88           C
ATOM     28  O  BASN A 286     -40.136  20.364  -3.047  0.25 18.65           O
ATOM     29  CB BASN A 286     -41.798  21.088  -6.023  0.25 22.27           C
ATOM     30  CG BASN A 286     -42.950  21.238  -5.058  0.25 23.28           C
ATOM     31  OD1BASN A 286     -42.781  21.720  -3.938  0.25 23.18           O
ATOM     32  ND2BASN A 286     -44.137  20.828  -5.491  0.25 24.35           N
ATOM     33  H  BASN A 286     -41.259  18.841  -4.435  0.25 24.36           H
ATOM     34  HA BASN A 286     -39.828  20.488  -6.007  0.25 24.24           H
ATOM     35  HB2BASN A 286     -41.538  21.974  -6.321  0.25 26.72           H
ATOM     36  HB3BASN A 286     -42.105  20.561  -6.777  0.25 26.72           H
ATOM     37 HD21BASN A 286     -44.216  20.499  -6.282  0.25 29.22           H
ATOM     38 HD22BASN A 286     -44.826  20.891  -4.981  0.25 29.22           H
ATOM     39  CA  GLU A 287     -39.388  22.905  -3.000  1.00 16.67           C
ATOM     40  C   GLU A 287     -40.376  23.372  -1.952  1.00 15.65           C
ATOM     41  O   GLU A 287     -40.132  23.201  -0.755  1.00 14.31           O
ATOM     42  CB  GLU A 287     -38.514  24.074  -3.481  1.00 17.80           C
ATOM     43  CG  GLU A 287     -37.273  23.645  -4.302  1.00 19.41           C
ATOM     44  CD  GLU A 287     -36.290  24.789  -4.558  1.00 20.84           C
ATOM     45  OE1 GLU A 287     -36.554  25.925  -4.128  1.00 21.26           O
ATOM     46  OE2 GLU A 287     -35.220  24.552  -5.185  1.00 22.93           O
ATOM     47  HB2 GLU A 287     -39.052  24.654  -4.041  1.00 21.36           H
ATOM     48  HB3 GLU A 287     -38.200  24.566  -2.707  1.00 21.36           H
ATOM     49  HG2 GLU A 287     -36.801  22.949  -3.818  1.00 23.29           H
ATOM     50  HG3 GLU A 287     -37.568  23.308  -5.163  1.00 23.29           H
ATOM     51  N  AGLU A 287     -40.109  22.235  -4.122  0.02 18.26           N
ATOM     52  H  AGLU A 287     -39.954  22.592  -4.889  0.02 21.91           H
ATOM     53  HA AGLU A 287     -38.796  22.250  -2.576  0.02 20.01           H
ATOM     54  N  BGLU A 287     -40.017  22.305  -4.119  0.98 18.44           N
ATOM     55  H  BGLU A 287     -40.228  22.836  -4.762  0.98 22.13           H
ATOM     56  HA BGLU A 287     -38.799  22.245  -2.580  0.98 20.01           H
TER
END
"""
  if (verbose): log = sys.stdout
  else: log = StringIO()
  model = get_model_str(pdb_str, log)
  res = occupancy_selections(
    model = model,
    as_flex_arrays    = False)
  answer = [ [[3,4,5,6,19],
              [7,8,9,10,33]],
             [[11,12,13,14,15,16,17,18,20,21,22,23,24,52],
              [25,26,27,28,29,30,31,32,34,35,36,37,38,55]],
             [[51,53],
              [54,56]]]
  assert approx_equal(res, answer)

def exercise_30(verbose):
  pdb_str="""\
CRYST1   42.198  121.958   37.277  90.00  90.00  90.00 P 21 21 2
ATOM      0  CG  GLU A 115      30.700  22.521   0.401  0.55 25.56           C
ATOM      1  CD  GLU A 115      31.809  23.320  -0.265  1.00 25.96           C
ATOM      2  OE1 GLU A 115      32.842  22.797  -0.723  1.00 24.92           O
ATOM      3  OE2 GLU A 115      31.621  24.544  -0.376  1.00 27.30           O
ATOM      4  N  AGLU A 115      27.819  20.841  -1.012  0.44 19.61           N
ATOM      5  CA AGLU A 115      28.757  21.222  -0.004  0.44 20.79           C
ATOM      6  C  AGLU A 115      28.192  21.930   1.203  0.44 19.50           C
ATOM      7  O  AGLU A 115      27.475  22.922   1.098  0.44 20.38           O
ATOM      8  CB AGLU A 115      29.799  22.079  -0.601  0.44 23.59           C
ATOM      9  N  BGLU A 115      27.018  20.969  -0.446  0.56 27.49           N
ATOM     10  CA BGLU A 115      28.194  21.387   0.311  0.56 26.06           C
ATOM     11  C  BGLU A 115      27.541  21.859   1.611  0.56 25.00           C
ATOM     12  O  BGLU A 115      26.660  22.715   1.640  0.56 26.43           O
ATOM     13  CB BGLU A 115      29.189  22.459  -0.356  0.56 26.03           C
ATOM     14  N  AVAL A 116      28.585  21.407   2.363  0.53 19.29           N
ATOM     15  CA AVAL A 116      28.181  21.931   3.670  0.53 18.27           C
ATOM     16  C  AVAL A 116      29.427  21.990   4.589  0.53 17.81           C
ATOM     17  O  AVAL A 116      30.464  21.420   4.280  0.53 17.67           O
ATOM     18  CB AVAL A 116      27.090  21.046   4.342  0.53 20.31           C
ATOM     19  CG1AVAL A 116      25.743  21.168   3.633  0.53 22.78           C
ATOM     20  CG2AVAL A 116      27.498  19.598   4.395  0.53 20.85           C
ATOM     21  H  AVAL A 116      29.104  20.724   2.421  0.53 23.15           H
ATOM     22  HA AVAL A 116      27.827  22.838   3.564  0.53 21.92           H
ATOM     23  HB AVAL A 116      26.967  21.353   5.264  0.53 24.37           H
ATOM     24  N  BVAL A 116      27.987  21.231   2.690  0.47 21.87           N
ATOM     25  CA BVAL A 116      27.614  21.560   4.041  0.47 19.86           C
ATOM     26  C  BVAL A 116      28.915  21.857   4.746  0.47 19.34           C
ATOM     27  O  BVAL A 116      29.983  21.603   4.213  0.47 18.81           O
ATOM     28  CB BVAL A 116      26.938  20.336   4.707  0.47 19.81           C
ATOM     29  CG1BVAL A 116      25.591  20.061   4.058  0.47 21.33           C
ATOM     30  CG2BVAL A 116      27.825  19.086   4.627  0.47 19.25           C
ATOM     31  H  BVAL A 116      28.539  20.573   2.651  0.47 26.24           H
ATOM     32  HA BVAL A 116      27.021  22.340   4.070  0.47 23.83           H
ATOM     33  HB BVAL A 116      26.782  20.535   5.654  0.47 23.76           H
TER
END
"""
  if (verbose): log = sys.stdout
  else: log = StringIO()
  model = get_model_str(pdb_str, log)
  res = occupancy_selections(
    model = model,
    as_flex_arrays    = False)
  answer = [ [[0]],
             [[4, 5, 6, 7, 8, 21],
              [9, 10, 11, 12, 13, 31]],
             [[14, 15, 16, 17, 18, 19, 20, 22, 23],
              [24, 25, 26, 27, 28, 29, 30, 32, 33]] ]
  assert approx_equal(res, answer)

def prepare_correlated_occupancy_inputs(
    prefix="tst_group_correlated_occupancy",
    create_mtz=False,
    d_min=1.0):
  pdb_raw = """\
CRYST1   21.937    4.866   23.477  90.00 107.08  90.00 P 1 21 1
SCALE1      0.045585  0.000000  0.014006        0.00000
SCALE2      0.000000  0.205508  0.000000        0.00000
SCALE3      0.000000  0.000000  0.044560        0.00000
ATOM      1  N   GLY A   1      -9.056   4.638   6.050  1.00 16.77           N
ATOM      2  CA  GLY A   1      -9.058   4.194   4.668  1.00 16.57           C
ATOM      3  C   GLY A   1      -7.993   3.144   4.430  1.00 16.16           C
ATOM      4  O   GLY A   1      -7.521   2.511   5.374  1.00 16.78           O
ATOM      5  N   ASN A   2      -7.616   2.953   3.169  1.00 15.02           N
ATOM      6  CA  ASN A   2      -6.526   2.044   2.840  1.00 14.10           C
ATOM      7  C   ASN A   2      -5.216   2.527   3.434  1.00 13.13           C
ATOM      8  O   ASN A   2      -4.943   3.727   3.466  1.00 11.91           O
ATOM      9  CB  ASN A   2      -6.382   1.888   1.330  1.00 15.38           C
ATOM     10  CG  ASN A   2      -7.632   1.344   0.685  1.00 14.08           C
ATOM     11  OD1 ASN A   2      -8.042   0.216   0.957  1.00 17.46           O
ATOM     12  ND2 ASN A   2      -8.247   2.142  -0.178  1.00 11.72           N
ATOM     13  N   ASN A   3      -4.405   1.583   3.898  1.00 12.26           N
ATOM     14  CA  ASN A   3      -3.172   1.915   4.595  1.00 11.74           C
ATOM     15  C   ASN A   3      -1.922   1.362   3.915  1.00 11.10           C
ATOM     16  O   ASN A   3      -1.816   0.158   3.672  1.00 10.42           O
ATOM     17  CB  ASN A   3      -3.243   1.409   6.039  1.00 12.15           C
ATOM     18  CG  ASN A   3      -2.000   1.749   6.841  1.00 12.82           C
ATOM     19  OD1 ASN A   3      -1.705   2.920   7.082  1.00 15.05           O
ATOM     20  ND2 ASN A   3      -1.272   0.724   7.270  1.00 13.48           N
ATOM     21  N   GLN A   4      -0.987   2.256   3.598  1.00 10.29           N
ATOM     22  CA  GLN A   4       0.361   1.860   3.201  1.00 10.53           C
ATOM     23  C   GLN A   4       1.398   2.605   4.031  1.00 10.24           C
ATOM     24  O   GLN A   4       1.454   3.834   4.025  1.00  8.86           O
ATOM     25  CB  GLN A   4       0.626   2.117   1.712  1.00  9.80           C
ATOM     26  CG  GLN A   4       1.924   1.459   1.221  1.00 10.25           C
ATOM     27  CD  GLN A   4       2.465   2.050  -0.073  1.00 12.43           C
ATOM     28  OE1 GLN A   4       2.674   3.260  -0.178  1.00 14.62           O
ATOM     29  NE2 GLN A   4       2.708   1.192  -1.059  1.00  9.05           N
ATOM     30  N  AGLN A   5       2.202   1.848   4.775  0.62 10.38           N
ATOM     31  CA AGLN A   5       3.288   2.419   5.569  0.62 11.39           C
ATOM     32  C  AGLN A   5       4.638   1.844   5.123  0.62 11.52           C
ATOM     33  O  AGLN A   5       4.824   0.625   5.095  0.62 12.05           O
ATOM     34  CB AGLN A   5       3.046   2.170   7.063  0.62 11.96           C
ATOM     35  CG AGLN A   5       1.854   2.946   7.622  0.62 10.81           C
ATOM     36  CD AGLN A   5       1.361   2.406   8.951  0.62 13.10           C
ATOM     37  OE1AGLN A   5       0.800   1.312   9.019  0.62 10.65           O
ATOM     38  NE2AGLN A   5       1.562   3.175  10.016  0.62 12.30           N
ATOM     39  N  BGLN A   5       2.239   1.858   4.725  0.38 10.38           N
ATOM     40  CA BGLN A   5       3.326   2.476   5.450  0.38 11.39           C
ATOM     41  C  BGLN A   5       4.639   1.850   5.057  0.38 11.52           C
ATOM     42  O  BGLN A   5       4.814   0.627   5.020  0.38 12.05           O
ATOM     43  CB BGLN A   5       3.110   2.331   6.919  0.38 11.96           C
ATOM     44  CG BGLN A   5       2.695   0.980   7.141  0.38 10.81           C
ATOM     45  CD BGLN A   5       2.882   0.618   8.479  0.38 13.10           C
ATOM     46  OE1BGLN A   5       2.538   1.369   9.406  0.38 10.65           O
ATOM     47  NE2BGLN A   5       3.380  -0.597   8.664  0.38 12.30           N
ATOM     48  N   ASN A   6       5.565   2.732   4.753  1.00 11.99           N
ATOM     49  CA  ASN A   6       6.868   2.339   4.280  1.00 12.30           C
ATOM     50  C   ASN A   6       7.881   2.785   5.302  1.00 13.40           C
ATOM     51  O   ASN A   6       8.262   3.954   5.351  1.00 13.92           O
ATOM     52  CB  ASN A   6       7.133   2.954   2.915  1.00 12.13           C
ATOM     53  CG  ASN A   6       5.988   2.721   1.955  1.00 12.77           C
ATOM     54  OD1 ASN A   6       5.795   1.608   1.466  1.00 14.27           O
ATOM     55  ND2 ASN A   6       5.211   3.764   1.690  1.00 10.07           N
ATOM     56  N  ATYR A   7       8.304   1.849   6.146  0.59 14.70           N
ATOM     57  CA ATYR A   7       9.167   2.166   7.280  0.59 15.18           C
ATOM     58  C  ATYR A   7      10.622   2.326   6.868  0.59 15.91           C
ATOM     59  O  ATYR A   7      11.054   1.799   5.844  0.59 15.76           O
ATOM     60  CB ATYR A   7       9.044   1.086   8.356  0.59 15.35           C
ATOM     61  CG ATYR A   7       7.640   0.946   8.887  0.59 14.45           C
ATOM     62  CD1ATYR A   7       6.759   0.027   8.335  0.59 15.68           C
ATOM     63  CD2ATYR A   7       7.187   1.750   9.924  0.59 14.80           C
ATOM     64  CE1ATYR A   7       5.469  -0.098   8.810  0.59 13.46           C
ATOM     65  CE2ATYR A   7       5.899   1.633  10.407  0.59 14.33           C
ATOM     66  CZ ATYR A   7       5.044   0.707   9.845  0.59 15.09           C
ATOM     67  OH ATYR A   7       3.759   0.583  10.319  0.59 14.39           O
ATOM     68  OXTATYR A   7      11.394   2.990   7.558  0.59 17.49           O
ATOM     70  N  BTYR A   7       8.323   1.843   6.116  0.41 14.70           N
ATOM     71  CA BTYR A   7       9.149   2.183   7.247  0.41 15.18           C
ATOM     72  C  BTYR A   7      10.629   2.316   6.861  0.41 15.91           C
ATOM     73  O  BTYR A   7      11.084   1.756   5.864  0.41 15.76           O
ATOM     74  CB BTYR A   7       8.954   1.147   8.348  0.41 15.35           C
ATOM     75  CG BTYR A   7       9.942   1.356   9.417  0.41 14.45           C
ATOM     76  CD1BTYR A   7       9.807   2.381  10.320  0.41 15.68           C
ATOM     77  CD2BTYR A   7      11.054   0.580   9.473  0.41 14.80           C
ATOM     78  CE1BTYR A   7      10.746   2.569  11.248  0.41 13.46           C
ATOM     79  CE2BTYR A   7      11.968   0.749  10.405  0.41 14.33           C
ATOM     80  CZ BTYR A   7      11.858   1.724  11.252  0.41 15.09           C
ATOM     81  OH BTYR A   7      12.921   1.747  12.113  0.41 14.39           O
ATOM     82  OXTBTYR A   7      11.408   3.001   7.529  0.41 17.49           O
TER
HETATM   83  O   HOH A   8      -6.471   5.227   7.124  1.00 22.62           O
HETATM   84  O   HOH A   9      10.431   1.858   3.216  1.00 19.71           O
HETATM   85  O   HOH A  10     -11.286   1.756  -1.468  1.00 17.08           O
HETATM   86  O  AHOH A  11      11.808   4.179   9.970  0.60 23.99           O
HETATM   87  O  AHOH A  12      13.605   1.327   9.198  0.60 26.17           O
HETATM   88  O   HOH A  13      -2.749   3.429  10.024  1.00 39.15           O
HETATM   89  O   HOH A  14      -1.500   0.682  10.967  1.00 43.49           O
TER
"""
  pdb_in = "%s_in.pdb" % prefix
  with open(pdb_in, "w") as f:
    f.write(pdb_raw)
  if (create_mtz):
    args = [
      pdb_in,
      "high_resolution=%g" % d_min,
      "type=real",
      "label=F",
      "add_sigmas=True",
      "r_free_flags_fraction=0.1",
      "random_seed=12345",
      "output.file_name=%s.mtz" % prefix,
    ]
    run_program(program_class=fmodel.Program, args=args, logger=null_out())
  pdb_file = iotbx.pdb.input(pdb_in)
  hierarchy = pdb_file.construct_hierarchy()
  xrs = pdb_file.xray_structure_simple()
  for atom in hierarchy.atoms():
    atom.b = 5
    if (atom.occ < 1.0):
      atom.occ = 0.5
  with open("%s_start.pdb" % prefix, "w") as f:
    f.write(hierarchy.as_pdb_string(crystal_symmetry=xrs))

def exercise_regroup_3d(verbose):
  if (verbose): log = sys.stdout
  else: log = StringIO()
  prepare_correlated_occupancy_inputs()
  # File #1 (with homogenized occupancies) should work
  # File #2 should fail due to inconsistent occupancies
  pdb_files = [
    "tst_group_correlated_occupancy_start.pdb",
    "tst_group_correlated_occupancy_in.pdb",
  ]
  #
  constraint_groups = occupancy_selections(
        model = get_model("tst_group_correlated_occupancy_start.pdb", log),
        constrain_correlated_3d_groups=True,
        log=null_out())
  for g in constraint_groups:
     assert [ [ggg for ggg in gg] for gg in g ] == \
       [[29, 30, 31, 32, 33, 34, 35, 36, 37, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 84, 85],
        [38, 39, 40, 41, 42, 43, 44, 45, 46, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80]]
  #
  sorry_found = False
  try:
    constraint_groups = occupancy_selections(
      model = get_model("tst_group_correlated_occupancy_in.pdb", log),
      constrain_correlated_3d_groups=True,
      log=null_out())
  except Sorry as s:
    assert ("Inconsistent occupancies" in str(s)), str(s)
    sorry_found = True
  assert sorry_found

def run():
  verbose = "--verbose" in sys.argv[1:]
  exercise_00(verbose=verbose)
  exercise_01(verbose=verbose)
  exercise_02(verbose=verbose)
  exercise_03(verbose=verbose)
  exercise_05(verbose=verbose)
  exercise_06(verbose=verbose)
  exercise_07(verbose=verbose)
  exercise_08(verbose=verbose)
  exercise_09(verbose=verbose)
  exercise_10(verbose=verbose)
  exercise_11(verbose=verbose)
  exercise_12(verbose=verbose)
  exercise_13(verbose=verbose)
  exercise_14(verbose=verbose)
  exercise_15(verbose=verbose)
  exercise_16(verbose=verbose)
  exercise_17(verbose=verbose)
  exercise_18(verbose=verbose)
  exercise_19(verbose=verbose)
  exercise_20(verbose=verbose)
  exercise_21(verbose=verbose)
  exercise_22(verbose=verbose)
  exercise_23(verbose=verbose)
  exercise_24(verbose=verbose)
  exercise_25(verbose=verbose)
  exercise_26(verbose=verbose)
  exercise_27(verbose=verbose)
  exercise_28(verbose=verbose)
  exercise_29(verbose=verbose)
  exercise_30(verbose=verbose)
  exercise_regroup_3d(verbose=verbose)
  print(format_cpu_times())

if (__name__ == "__main__"):
  run()


 *******************************************************************************
