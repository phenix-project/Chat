

 *******************************************************************************
scitbx/rigid_body/__init__.py
from __future__ import absolute_import, division, print_function
import scitbx.array_family.flex # import dependency

import boost_adaptbx.boost.python as bp
ext = bp.import_ext("scitbx_rigid_body_ext")
from scitbx_rigid_body_ext import *
import math
from scitbx import matrix

class pickle_import_trigger(object): pass

@bp.inject_into(ext.tardy_model)
class _():

  def __getinitargs__(O):
    return (
      O.labels,
      O.sites,
      O.masses,
      O.tardy_tree,
      O.potential_obj,
      O.near_singular_hinges_angular_tolerance_deg)

  def __getstate__(O):
    version = 2
    return (version, pickle_import_trigger(), O.pack_q(), O.pack_qd())

  def __setstate__(O, state):
    assert len(state) >= 3
    version = state[0]
    if   (version == 1): assert len(state) == 3
    elif (version == 2): assert len(state) == 4
    else: raise RuntimeError("Unknown version of pickled state.")
    O.unpack_q(q_packed=state[-2])
    O.unpack_qd(qd_packed=state[-1])

  def minimization(O, max_iterations=None, callback_after_step=None):
    from scitbx.rigid_body.essence.tardy import refinery
    return refinery(
      tardy_model=O,
      max_iterations=max_iterations,
      callback_after_step=callback_after_step)

def euler(phi, psi, the, convention):
  if(convention == "zyz"):
     result = rb_mat_zyz(the=the, psi=psi, phi=phi)
  elif(convention == "xyz"):
     result = rb_mat_xyz(the=the, psi=psi, phi=phi)
  else:
     raise RuntimeError("\nWrong rotation convention\n")
  return result

class rb_mat_zyz(object):

   def __init__(self, the, psi, phi):
     the = the * math.pi/180
     psi = psi * math.pi/180
     phi = phi * math.pi/180
     self.c_psi = math.cos(psi)
     self.c_the = math.cos(the)
     self.c_phi = math.cos(phi)
     self.s_psi = math.sin(psi)
     self.s_the = math.sin(the)
     self.s_phi = math.sin(phi)

   def rot_mat(self):
     c_psi = self.c_psi
     c_the = self.c_the
     c_phi = self.c_phi
     s_psi = self.s_psi
     s_the = self.s_the
     s_phi = self.s_phi
     r11 =  c_the*c_psi*c_phi - s_the*s_phi
     r12 = -c_the*c_psi*s_phi - s_the*c_phi
     r13 =  c_the*s_psi
     r21 =  s_the*c_psi*c_phi + c_the*s_phi
     r22 = -s_the*c_psi*s_phi + c_the*c_phi
     r23 =  s_the*s_psi
     r31 = -s_psi*c_phi
     r32 =  s_psi*s_phi
     r33 =  c_psi
     rm = matrix.sqr((r11,r12,r13, r21,r22,r23, r31,r32,r33))
     return rm

   def r_the(self):
     c_psi = self.c_psi
     c_the = self.c_the
     c_phi = self.c_phi
     s_psi = self.s_psi
     s_the = self.s_the
     s_phi = self.s_phi
     r11 = -s_the*c_psi*c_phi - c_the*s_phi
     r12 =  s_the*c_psi*s_phi - c_the*c_phi
     r13 = -s_the*s_psi
     r21 =  c_the*c_psi*c_phi - s_the*s_phi
     r22 = -c_the*c_psi*s_phi - s_the*c_phi
     r23 =  c_the*s_psi
     r31 = 0.0
     r32 = 0.0
     r33 = 0.0
     rm = matrix.sqr((r11,r12,r13, r21,r22,r23, r31,r32,r33))
     return rm

   def r_psi(self):
     c_psi = self.c_psi
     c_the = self.c_the
     c_phi = self.c_phi
     s_psi = self.s_psi
     s_the = self.s_the
     s_phi = self.s_phi
     r11 = -c_the*s_psi*c_phi
     r12 =  c_the*s_psi*s_phi
     r13 =  c_the*c_psi
     r21 = -s_the*s_psi*c_phi
     r22 =  s_the*s_psi*s_phi
     r23 =  s_the*c_psi
     r31 = -c_psi*c_phi
     r32 =  c_psi*s_phi
     r33 = -s_psi
     rm = matrix.sqr((r11,r12,r13, r21,r22,r23, r31,r32,r33))
     return rm

   def r_phi(self):
     c_psi = self.c_psi
     c_the = self.c_the
     c_phi = self.c_phi
     s_psi = self.s_psi
     s_the = self.s_the
     s_phi = self.s_phi
     r11 = -c_the*c_psi*s_phi - s_the*c_phi
     r12 = -c_the*c_psi*c_phi + s_the*s_phi
     r13 =  0.0
     r21 = -s_the*c_psi*s_phi + c_the*c_phi
     r22 = -s_the*c_psi*c_phi - c_the*s_phi
     r23 =  0.0
     r31 =  s_psi*s_phi
     r32 =  s_psi*c_phi
     r33 =  0.0
     rm = matrix.sqr((r11,r12,r13, r21,r22,r23, r31,r32,r33))
     return rm

class rb_mat_xyz(object):
   """ R = Rx(the)Ry(psi)Rz(phi) """

   def __init__(self, phi, psi, the, deg=True):
     if deg:
       phi = phi * math.pi/180
       psi = psi * math.pi/180
       the = the * math.pi/180
     self.c_psi = math.cos(psi)
     self.c_phi = math.cos(phi)
     self.c_the = math.cos(the)
     self.s_psi = math.sin(psi)
     self.s_phi = math.sin(phi)
     self.s_the = math.sin(the)

   def rot_mat(self):
     c_psi = self.c_psi
     c_the = self.c_the
     c_phi = self.c_phi
     s_psi = self.s_psi
     s_the = self.s_the
     s_phi = self.s_phi
     r11 =  c_psi*c_phi
     r12 = -c_psi*s_phi
     r13 =  s_psi
     r21 =  c_the*s_phi + s_the*s_psi*c_phi
     r22 =  c_the*c_phi - s_the*s_psi*s_phi
     r23 = -s_the*c_psi
     r31 =  s_the*s_phi - c_the*s_psi*c_phi
     r32 =  s_the*c_phi + c_the*s_psi*s_phi
     r33 =  c_the*c_psi
     rm = matrix.sqr((r11,r12,r13, r21,r22,r23, r31,r32,r33))
     return rm

   def r_the(self):
     c_psi = self.c_psi
     c_the = self.c_the
     c_phi = self.c_phi
     s_psi = self.s_psi
     s_the = self.s_the
     s_phi = self.s_phi
     r11 =  0.0
     r12 =  0.0
     r13 =  0.0
     r21 = -s_the*s_phi+c_the*s_psi*c_phi
     r22 = -s_the*c_phi-c_the*s_psi*s_phi
     r23 = -c_the*c_psi
     r31 =  c_the*s_phi+s_the*s_psi*c_phi
     r32 =  c_the*c_phi-s_the*s_psi*s_phi
     r33 = -s_the*c_psi
     rm = matrix.sqr((r11,r12,r13, r21,r22,r23, r31,r32,r33))
     return rm

   def r_psi(self):
     c_psi = self.c_psi
     c_the = self.c_the
     c_phi = self.c_phi
     s_psi = self.s_psi
     s_the = self.s_the
     s_phi = self.s_phi
     r11 = -s_psi*c_phi
     r12 =  s_psi*s_phi
     r13 =  c_psi
     r21 =  s_the*c_psi*c_phi
     r22 = -s_the*c_psi*s_phi
     r23 =  s_the*s_psi
     r31 = -c_the*c_psi*c_phi
     r32 =  c_the*c_psi*s_phi
     r33 = -c_the*s_psi
     rm = matrix.sqr((r11,r12,r13, r21,r22,r23, r31,r32,r33))
     return rm

   def r_phi(self):
     c_psi = self.c_psi
     c_the = self.c_the
     c_phi = self.c_phi
     s_psi = self.s_psi
     s_the = self.s_the
     s_phi = self.s_phi
     r11 = -c_psi*s_phi
     r12 = -c_psi*c_phi
     r13 =  0.0
     r21 =  c_the*c_phi - s_the*s_psi*s_phi
     r22 = -c_the*s_phi - s_the*s_psi*c_phi
     r23 =  0.0
     r31 =  s_the*c_phi + c_the*s_psi*s_phi
     r32 = -s_the*s_phi + c_the*s_psi*c_phi
     r33 =  0.0
     rm = matrix.sqr((r11,r12,r13, r21,r22,r23, r31,r32,r33))
     return rm


 *******************************************************************************


 *******************************************************************************
scitbx/rigid_body/essence/__init__.py
"""
rigid_body.essence
"""

from __future__ import division


 *******************************************************************************


 *******************************************************************************
scitbx/rigid_body/essence/body_lib.py
from __future__ import absolute_import, division, print_function
from scitbx.rigid_body.essence import joint_lib, spatial_lib
from six.moves import zip

matrix = spatial_lib.matrix

class mass_points(object):

  def __init__(O, sites, masses):
    assert len(masses) == len(sites)
    O.sites = sites
    O.masses = masses
    O._sum_of_masses = None
    O._center_of_mass = None

  def sum_of_masses(O):
    if (O._sum_of_masses is None):
      sm = 0
      for mass in O.masses:
        sm += mass
      O._sum_of_masses = sm
    return O._sum_of_masses

  def center_of_mass(O):
    if (O._center_of_mass is None):
      assert len(O.masses) != 0
      assert O.sum_of_masses() != 0
      sms = matrix.col((0,0,0))
      for mass,site in zip(O.masses, O.sites):
        sms += mass * site
      O._center_of_mass = sms / O.sum_of_masses()
    return O._center_of_mass

  def inertia(O, pivot):
    m = [0] * 9
    for mass,site in zip(O.masses, O.sites):
      x,y,z = site - pivot
      m[0] += mass * (y*y+z*z)
      m[4] += mass * (x*x+z*z)
      m[8] += mass * (x*x+y*y)
      m[1] -= mass * x*y
      m[2] -= mass * x*z
      m[5] -= mass * y*z
    m[3] = m[1]
    m[6] = m[2]
    m[7] = m[5]
    return matrix.sqr(m)

  def spatial_inertia(O, alignment_cb_0b=None):
    center_of_mass = O.center_of_mass()
    inertia = O.inertia(pivot=center_of_mass)
    if (alignment_cb_0b is not None):
      center_of_mass = alignment_cb_0b * center_of_mass
      inertia = alignment_cb_0b.r * inertia * alignment_cb_0b.r.transpose()
    return spatial_lib.mci(m=O._sum_of_masses, c=center_of_mass, i=inertia)

def set_cb_tree(bodies):
  "Computes Xtree (RBDA Fig. 4.7, p. 74) for all bodies."
  for body in bodies:
    if (body.parent == -1):
      body.cb_tree = body.alignment.cb_0b
    else:
      body.cb_tree = body.alignment.cb_0b * bodies[body.parent].alignment.cb_b0

class zero_dof(object):

  def __init__(O, sites, masses):
    O.number_of_sites = len(sites)
    O.sum_of_masses = sum(masses)
    O.alignment = joint_lib.zero_dof_alignment()
    O.i_spatial = matrix.sqr([0]*36)
    O.joint = joint_lib.zero_dof()
    O.qd = O.joint.qd_zero

class six_dof(object):

  def __init__(O, sites, masses):
    O.number_of_sites = len(sites)
    mp = mass_points(sites=sites, masses=masses)
    O.sum_of_masses = mp.sum_of_masses()
    O.alignment = joint_lib.six_dof_alignment(
      center_of_mass=mp.center_of_mass())
    O.i_spatial = mp.spatial_inertia(alignment_cb_0b=O.alignment.cb_0b)
    #
    qe = matrix.col((1,0,0,0))
    qr = matrix.col((0,0,0))
    O.joint = joint_lib.six_dof(qe=qe, qr=qr)
    O.qd = O.joint.qd_zero

class spherical(object):

  def __init__(O, sites, masses, pivot):
    O.number_of_sites = len(sites)
    mp = mass_points(sites=sites, masses=masses)
    O.sum_of_masses = mp.sum_of_masses()
    O.alignment = joint_lib.spherical_alignment(pivot=pivot)
    O.i_spatial = mp.spatial_inertia(alignment_cb_0b=O.alignment.cb_0b)
    #
    qe = matrix.col((1,0,0,0))
    O.joint = joint_lib.spherical(qe=qe)
    O.qd = O.joint.qd_zero

class revolute(object):

  def __init__(O, sites, masses, pivot, normal):
    O.number_of_sites = len(sites)
    mp = mass_points(sites=sites, masses=masses)
    O.sum_of_masses = mp.sum_of_masses()
    O.alignment = joint_lib.revolute_alignment(pivot=pivot, normal=normal)
    O.i_spatial = mp.spatial_inertia(alignment_cb_0b=O.alignment.cb_0b)
    #
    O.joint = joint_lib.revolute(qe=matrix.col([0]))
    O.qd = O.joint.qd_zero

class translational(object):

  def __init__(O, sites, masses):
    O.number_of_sites = len(sites)
    mp = mass_points(sites=sites, masses=masses)
    O.sum_of_masses = mp.sum_of_masses()
    O.alignment = joint_lib.translational_alignment(
      center_of_mass=mp.center_of_mass())
    O.i_spatial = mp.spatial_inertia(alignment_cb_0b=O.alignment.cb_0b)
    #
    qr = matrix.col((0,0,0))
    O.joint = joint_lib.translational(qr=qr)
    O.qd = O.joint.qd_zero


 *******************************************************************************


 *******************************************************************************
scitbx/rigid_body/essence/featherstone.py
"""\
Based in part on Roy Featherstone's spatial_v1 matlab code:

  http://axiom.anu.edu.au/~roy/spatial/

  Version 1: January 2008 (latest bug fix: 7 October 2008)

See also: RBDA:
  Rigid Body Dynamics Algorithms.
  Roy Featherstone,
  Springer, New York, 2007.
  ISBN-10: 0387743146
"""

from __future__ import absolute_import, division, print_function
from scitbx.rigid_body.essence.spatial_lib import \
  matrix, cb_as_spatial_transform, crm, crf, kinetic_energy
from six.moves import range
from six.moves import zip

try:
  import scitbx
except ImportError:
  scitbx = None
  def generalized_inverse(m):
    return m.inverse()
else:
  import scitbx.linalg.eigensystem
  def generalized_inverse(m):
    # assumption to achieve stability: order of magnitude of masses is around 1
    return matrix.sqr(
      scitbx.linalg.eigensystem.real_symmetric(
        m=m.as_flex_double_matrix(),
        relative_epsilon=1e-6,
        absolute_epsilon=1e-6)
          .generalized_inverse_as_packed_u()
          .matrix_packed_u_as_symmetric())

class system_model(object):
  "RBDA Tab. 4.3, p. 87"

  def __init__(O, bodies):
    O.bodies = bodies
    O.number_of_trees = 0
    O.degrees_of_freedom = 0
    O.q_packed_size = 0
    for body in O.bodies:
      if (body.parent == -1): O.number_of_trees += 1
      O.degrees_of_freedom += body.joint.degrees_of_freedom
      O.q_packed_size += body.joint.q_size
    O.flag_positions_as_changed()

  def flag_positions_as_changed(O):
    O.__aja_array = None
    O.__jar_array = None
    O.__cb_up_array = None
    O.__xup_array = None
    O.flag_velocities_as_changed()

  def flag_velocities_as_changed(O):
    O.__spatial_velocities = None
    O.__e_kin = None

  def root_indices(O):
    result = []
    for ib,body in enumerate(O.bodies):
      if (body.parent == -1):
        result.append(ib)
    return result

  def pack_q(O):
    from scitbx.array_family import flex
    result = flex.double()
    result.reserve(O.q_packed_size)
    for body in O.bodies:
      result.extend(flex.double(body.joint.get_q()))
    assert result.size() == O.q_packed_size
    return result

  def unpack_q(O, q_packed):
    assert q_packed.size() == O.q_packed_size
    i = 0
    for body in O.bodies:
      n = body.joint.q_size
      body.joint = body.joint.new_q(q=q_packed[i:i+n])
      i += n
    assert i == O.q_packed_size
    O.flag_positions_as_changed()

  def pack_qd(O):
    from scitbx.array_family import flex
    result = flex.double()
    result.reserve(O.degrees_of_freedom)
    for body in O.bodies:
      result.extend(flex.double(body.qd))
    assert result.size() == O.degrees_of_freedom
    return result

  def unpack_qd(O, qd_packed):
    assert qd_packed.size() == O.degrees_of_freedom
    i = 0
    for body in O.bodies:
      n = body.joint.degrees_of_freedom
      body.qd = matrix.col(qd_packed[i:i+n])
      i += n
    assert i == O.degrees_of_freedom
    O.flag_velocities_as_changed()

  def _accumulate_in_each_tree(O, attr):
    result = []
    accu = [0] * len(O.bodies)
    for ib in range(len(O.bodies)-1,-1,-1):
      body = O.bodies[ib]
      accu[ib] += getattr(body, attr)
      if (body.parent == -1):
        result.append((ib, accu[ib]))
      else:
        accu[body.parent] += accu[ib]
    return result

  def number_of_sites_in_each_tree(O):
    return O._accumulate_in_each_tree(attr="number_of_sites")

  def sum_of_masses_in_each_tree(O):
    return O._accumulate_in_each_tree(attr="sum_of_masses")

  def mean_linear_velocity(O, number_of_sites_in_each_tree):
    if (number_of_sites_in_each_tree is None):
      number_of_sites_in_each_tree = O.number_of_sites_in_each_tree()
    sum_v = matrix.col((0,0,0))
    sum_n = 0
    for ib,n in number_of_sites_in_each_tree:
      body = O.bodies[ib]
      v = body.joint.get_linear_velocity(qd=body.qd)
      if (v is None): continue
      sum_v += v * n
      sum_n += n
    if (sum_n == 0):
      return None
    return sum_v / sum_n

  def subtract_from_linear_velocities(O, number_of_sites_in_each_tree, value):
    if (number_of_sites_in_each_tree is None):
      number_of_sites_in_each_tree = O.number_of_sites_in_each_tree()
    for ib,n in number_of_sites_in_each_tree:
      body = O.bodies[ib]
      v = body.joint.get_linear_velocity(qd=body.qd)
      if (v is None): continue
      body.qd = body.joint.new_linear_velocity(qd=body.qd, value=v-value)

  def aja_array(O):
    if (O.__aja_array is None):
      O.__aja_array = []
      for body in O.bodies:
        aja = body.alignment.cb_b0 * body.joint.cb_sp * body.alignment.cb_0b
        if (body.parent != -1):
          aja = O.__aja_array[body.parent] * aja
        O.__aja_array.append(aja)
    return O.__aja_array

  def jar_array(O):
    if (O.__jar_array is None):
      O_aja = O.aja_array()
      O.__jar_array = []
      for body in O.bodies:
        jar = body.joint.cb_ps.r * body.alignment.cb_0b.r
        if (body.parent != -1):
          jar *= O_aja[body.parent].r.transpose()
        O.__jar_array.append(jar)
    return O.__jar_array

  def cb_up_array(O):
    "RBDA Example 4.4, p. 80"
    if (O.__cb_up_array is None):
      O.__cb_up_array = [body.joint.cb_ps * body.cb_tree for body in O.bodies]
    return O.__cb_up_array

  def xup_array(O):
    if (O.__xup_array is None):
      O.__xup_array = [cb_as_spatial_transform(cb) for cb in O.cb_up_array()]
    return O.__xup_array

  def spatial_velocities(O):
    "RBDA Example 4.4, p. 80"
    if (O.__spatial_velocities is None):
      O.__spatial_velocities = []
      cb_up_array = O.cb_up_array()
      for ib in range(len(O.bodies)):
        body = O.bodies[ib]
        s = body.joint.motion_subspace
        if (s is None): vj = body.qd
        else:           vj = s * body.qd
        if (body.parent == -1):
          O.__spatial_velocities.append(vj)
        else:
          cb_up = cb_up_array[ib]
          vp = O.__spatial_velocities[body.parent].elems
          r_va = cb_up.r * matrix.col(vp[:3])
          vp = matrix.col((
            r_va,
            cb_up.r * matrix.col(vp[3:]) + cb_up.t.cross(r_va))) \
              .resolve_partitions()
          O.__spatial_velocities.append(vp + vj)
    return O.__spatial_velocities

  def e_kin(O):
    "RBDA Eq. 2.67, p. 35"
    if (O.__e_kin is None):
      result = 0
      for body,v in zip(O.bodies, O.spatial_velocities()):
        result += kinetic_energy(i_spatial=body.i_spatial, v_spatial=v)
      O.__e_kin = result
    return O.__e_kin

  def reset_e_kin(O, e_kin_target, e_kin_epsilon=1e-12):
    assert e_kin_target >= 0
    assert e_kin_epsilon > 0
    O_e_kin = O.e_kin()
    if (O_e_kin >= e_kin_epsilon):
      factor = (e_kin_target / O_e_kin)**0.5
      for body in O.bodies:
        body.qd *= factor
    O.flag_velocities_as_changed()

  def assign_zero_velocities(O):
    for body in O.bodies:
      body.qd = body.joint.qd_zero
    O.flag_velocities_as_changed()

  def accumulated_spatial_inertia(O):
    result = [body.i_spatial for body in O.bodies]
    xup_array = O.xup_array()
    for i in range(len(result)-1,-1,-1):
      body = O.bodies[i]
      if (body.parent != -1):
        result[body.parent] \
          += xup_array[i].transpose() * result[i] * xup_array[i]
    return result

  def qd_e_kin_scales(O, e_kin_epsilon=1.e-12):
    result = []
    rap = result.append
    for body,asi in zip(O.bodies, O.accumulated_spatial_inertia()):
      s = body.joint.motion_subspace
      j_dof = body.joint.degrees_of_freedom
      qd = [0] * j_dof
      for i in range(j_dof):
        qd[i] = 1
        vj = matrix.col(qd)
        qd[i] = 0
        if (s is not None): vj = s * vj
        e_kin = kinetic_energy(i_spatial=asi, v_spatial=vj)
        if (e_kin < e_kin_epsilon):
          rap(1)
        else:
          rap(1 / e_kin**0.5)
    return result

  def assign_random_velocities(O,
        e_kin_target=None,
        e_kin_epsilon=1e-12,
        random_gauss=None):
    if (e_kin_target is None):
      work_e_kin_target = 1
    elif (e_kin_target == 0):
      O.assign_zero_velocities()
      return
    else:
      assert e_kin_target >= 0
      work_e_kin_target = e_kin_target
    from scitbx.array_family import flex
    qd_e_kin_scales = flex.double(
      O.qd_e_kin_scales(e_kin_epsilon=e_kin_epsilon))
    if (O.degrees_of_freedom != 0):
      qd_e_kin_scales *= (work_e_kin_target / O.degrees_of_freedom)**0.5
    if (random_gauss is None):
      import random
      random_gauss = random.gauss
    i_qd = 0
    for body in O.bodies:
      qd_new = []
      for qd in body.joint.qd_zero:
        qd_new.append(qd + random_gauss(mu=0, sigma=qd_e_kin_scales[i_qd]))
        i_qd += 1
      body.qd = matrix.col(qd_new)
    assert i_qd == O.degrees_of_freedom
    O.flag_velocities_as_changed()
    if (e_kin_target is not None):
      O.reset_e_kin(e_kin_target=e_kin_target, e_kin_epsilon=e_kin_epsilon)
    return qd_e_kin_scales

  def inverse_dynamics(O, qdd_array=None, f_ext_array=None, grav_accn=None):
    """RBDA Tab. 5.1, p. 96:
Inverse Dynamics of a kinematic tree via Recursive Newton-Euler Algorithm.
qdd_array is a vector of joint acceleration variables.
The return value (tau) is a vector of joint force variables.
f_ext_array specifies external forces acting on the bodies. If f_ext_array
is None then there are no external forces; otherwise, f_ext[i] is a spatial
force vector giving the force acting on body i, expressed in body i
coordinates.
grav_accn is a 6D vector expressing the linear acceleration due to gravity.
    """
    assert qdd_array is None or len(qdd_array) == len(O.bodies)
    assert f_ext_array is None or len(f_ext_array) == len(O.bodies)
    nb = len(O.bodies)
    xup_array = O.xup_array()
    v = O.spatial_velocities()
    a = [None] * nb
    f = [None] * nb
    for ib in range(nb):
      body = O.bodies[ib]
      s = body.joint.motion_subspace
      if (s is None):
        vj = body.qd
        if (qdd_array is None or qdd_array[ib] is None):
          aj = matrix.zeros(n=6)
        else:
          aj = qdd_array[ib]
      else:
        vj = s * body.qd
        if (qdd_array is None or qdd_array[ib] is None):
          aj = matrix.zeros(n=6)
        else:
          aj = s * qdd_array[ib]
      if (body.parent == -1):
        a[ib] = aj
        if (grav_accn is not None):
          a[ib] += xup_array[ib] * (-grav_accn)
      else:
        a[ib] = xup_array[ib] * a[body.parent] + aj + crm(v[ib]) * vj
      f[ib] = body.i_spatial * a[ib] + crf(v[ib]) * (body.i_spatial * v[ib])
      if (f_ext_array is not None and f_ext_array[ib] is not None):
        f[ib] -= f_ext_array[ib]
    #
    tau_array = [None] * nb
    for ib in range(nb-1,-1,-1):
      body = O.bodies[ib]
      s = body.joint.motion_subspace
      if (s is None):
        tau_array[ib] = f[ib]
      else:
        tau_array[ib] = s.transpose() * f[ib]
      if (body.parent != -1):
        f[body.parent] += xup_array[ib].transpose() * f[ib]
    #
    return tau_array

  def f_ext_as_tau(O, f_ext_array):
    """
Simplified version of Inverse Dynamics via Recursive Newton-Euler Algorithm,
with all qd, qdd zero, but non-zero external forces.
    """
    assert len(f_ext_array) == len(O.bodies)
    nb = len(O.bodies)
    xup_array = O.xup_array()
    f = [-e for e in f_ext_array]
    tau_array = [None] * nb
    for ib in range(nb-1,-1,-1):
      body = O.bodies[ib]
      s = body.joint.motion_subspace
      if (s is None): tau_array[ib] = f[ib]
      else:           tau_array[ib] = s.transpose() * f[ib]
      if (body.parent != -1):
        f[body.parent] += xup_array[ib].transpose() * f[ib]
    return tau_array

  def forward_dynamics_ab(O, tau_array=None, f_ext_array=None, grav_accn=None):
    """RBDA Tab. 7.1, p. 132:
Forward Dynamics of a kinematic tree via the Articulated-Body Algorithm.
tau_array is a vector of force variables.
The return value (qdd_array) is a vector of joint acceleration variables.
f_ext_array specifies external forces acting on the bodies. If f_ext_array
is None then there are no external forces; otherwise, f_ext_array[i] is a
spatial force vector giving the force acting on body i, expressed in body i
coordinates.
grav_accn is a 6D vector expressing the linear acceleration due to gravity.
    """
    assert tau_array is None or len(tau_array) == len(O.bodies)
    assert f_ext_array is None or len(f_ext_array) == len(O.bodies)
    nb = len(O.bodies)
    xup_array = O.xup_array()
    v = O.spatial_velocities()
    c = [None] * nb
    ia = [None] * nb
    pa = [None] * nb
    for ib in range(nb):
      body = O.bodies[ib]
      s = body.joint.motion_subspace
      if (s is None): vj = body.qd
      else:           vj = s * body.qd
      if (body.parent == -1): c[ib] = matrix.col([0,0,0,0,0,0])
      else:                   c[ib] = crm(v[ib]) * vj
      ia[ib] = body.i_spatial
      pa[ib] = crf(v[ib]) * (body.i_spatial * v[ib])
      if (f_ext_array is not None and f_ext_array[ib] is not None):
        pa[ib] -= f_ext_array[ib]
    #
    u = [None] * nb
    d_inv = [None] * nb
    u_ = [None] * nb
    for ib in range(nb-1,-1,-1):
      body = O.bodies[ib]
      s = body.joint.motion_subspace
      if (s is None):
        u[ib] = ia[ib]
        d = u[ib]
        u_[ib] = -pa[ib]
      else:
        u[ib] = ia[ib] * s
        d = s.transpose() * u[ib]
        u_[ib] = -s.transpose() * pa[ib]
      if (tau_array is not None and tau_array[ib] is not None):
        u_[ib] += tau_array[ib]
      d_inv[ib] = generalized_inverse(d)
      if (body.parent != -1):
        u_d_inv = u[ib] * d_inv[ib];
        ia_ = ia[ib] - u_d_inv * u[ib].transpose()
        pa_ = pa[ib] + ia_*c[ib] + u_d_inv * u_[ib]
        ia[body.parent] += xup_array[ib].transpose() * ia_ * xup_array[ib]
        pa[body.parent] += xup_array[ib].transpose() * pa_
    #
    a = [None] * nb
    qdd_array = [None] * nb
    for ib in range(nb):
      body = O.bodies[ib]
      s = body.joint.motion_subspace
      if (body.parent == -1):
        a[ib] = c[ib]
        if (grav_accn is not None):
          a[ib] += xup_array[ib] * (-grav_accn)
      else:
        a[ib] = xup_array[ib] * a[body.parent] + c[ib]
      qdd_array[ib] = d_inv[ib] * (u_[ib] - u[ib].transpose()*a[ib])
      if (s is None):
        a[ib] += qdd_array[ib]
      else:
        a[ib] += s * qdd_array[ib]
    #
    return qdd_array


 *******************************************************************************


 *******************************************************************************
scitbx/rigid_body/essence/joint_lib.py
from __future__ import absolute_import, division, print_function
try: import scitbx
except ImportError: import scitbx_matrix as matrix
else: from scitbx import matrix
import math

class zero_dof_alignment(object):

  def __init__(O):
    O.cb_0b = matrix.rt(((1,0,0,0,1,0,0,0,1), (0,0,0)))
    O.cb_b0 = O.cb_0b

class zero_dof(object):

  degrees_of_freedom = 0
  qd_zero = matrix.zeros(n=degrees_of_freedom)
  qdd_zero = qd_zero

  def __init__(O):
    O.q_size = 0
    O.cb_ps = matrix.rt(((1,0,0,0,1,0,0,0,1), (0,0,0)))
    O.cb_sp = O.cb_ps
    O.motion_subspace = matrix.rec(elems=(), n=(6,0))

  def get_linear_velocity(O, qd):
    return None

  def new_linear_velocity(O, qd, value):
    return None

  def time_step_position(O, qd, delta_t):
    return zero_dof()

  def time_step_velocity(O, qd, qdd, delta_t):
    return zero_dof.qd_zero

  def tau_as_d_e_pot_d_q(O, tau):
    return zero_dof.qd_zero

  def get_q(O):
    return ()

  def new_q(O, q):
    return zero_dof()

class six_dof_alignment(object):

  def __init__(O, center_of_mass):
    O.cb_0b = matrix.rt(((1,0,0,0,1,0,0,0,1), -center_of_mass))
    O.cb_b0 = matrix.rt(((1,0,0,0,1,0,0,0,1), center_of_mass))

class six_dof(object):

  degrees_of_freedom = 6
  qd_zero = matrix.zeros(n=degrees_of_freedom)
  qdd_zero = qd_zero

  def __init__(O, qe, qr):
    O.qe = qe
    O.qr = qr
    O.q_size = 7
    O.unit_quaternion = qe.normalize() # RBDA, bottom of p. 86
    O.e = rbda_eq_4_12(q=O.unit_quaternion)
    O.r = qr
    O.cb_ps = matrix.rt((O.e, -O.e * O.r)) # RBDA Eq. 2.28
    O.cb_sp = matrix.rt((O.e.transpose(), O.r))
    O.motion_subspace = None

  def get_linear_velocity(O, qd):
    return matrix.col(qd.elems[3:])

  def new_linear_velocity(O, qd, value):
    return matrix.col((matrix.col(qd.elems[:3]), value)).resolve_partitions()

  def time_step_position(O, qd, delta_t):
    w_body_frame, v_body_frame = matrix.col_list([qd.elems[:3], qd.elems[3:]])
    qed = rbda_eq_4_13(q=O.unit_quaternion) * w_body_frame
    new_qe = (O.qe + qed * delta_t).normalize()
    qrd = O.e.transpose() * v_body_frame
    new_qr = O.qr + qrd * delta_t
    return six_dof(qe=new_qe, qr=new_qr)

  def time_step_velocity(O, qd, qdd, delta_t):
    return qd + qdd * delta_t

  def tau_as_d_e_pot_d_q(O, tau):
    d = d_unit_quaternion_d_qe_matrix(q=O.qe)
    c = d * 4 * rbda_eq_4_13(q=O.unit_quaternion)
    n, f = matrix.col_list([tau.elems[:3], tau.elems[3:]])
    return matrix.col((c * n, O.e.transpose() * f)).resolve_partitions()

  def get_q(O):
    return O.qe.elems + O.qr.elems

  def new_q(O, q):
    new_qe, new_qr = matrix.col_list((q[:4], q[4:]))
    return six_dof(qe=new_qe, qr=new_qr)

class spherical_alignment(object):

  def __init__(O, pivot):
    O.cb_0b = matrix.rt(((1,0,0,0,1,0,0,0,1), -pivot))
    O.cb_b0 = matrix.rt(((1,0,0,0,1,0,0,0,1), pivot))

class spherical(object):

  degrees_of_freedom = 3
  qd_zero = matrix.zeros(n=degrees_of_freedom)
  qdd_zero = qd_zero

  def __init__(O, qe):
    O.qe = qe
    O.q_size = 4
    O.unit_quaternion = qe.normalize() # RBDA, bottom of p. 86
    e = rbda_eq_4_12(q=O.unit_quaternion)
    O.cb_ps = matrix.rt((e, (0,0,0)))
    O.cb_sp = matrix.rt((e.transpose(), (0,0,0)))
    O.motion_subspace = matrix.rec((
      1,0,0,
      0,1,0,
      0,0,1,
      0,0,0,
      0,0,0,
      0,0,0), n=(6,3))

  def get_linear_velocity(O, qd):
    return None

  def new_linear_velocity(O, qd, value):
    return None

  def time_step_position(O, qd, delta_t):
    w_body_frame = qd
    qed = rbda_eq_4_13(q=O.unit_quaternion) * w_body_frame
    new_qe = (O.qe + qed * delta_t).normalize()
    return spherical(qe=new_qe)

  def time_step_velocity(O, qd, qdd, delta_t):
    return qd + qdd * delta_t

  def tau_as_d_e_pot_d_q(O, tau):
    d = d_unit_quaternion_d_qe_matrix(q=O.qe)
    c = d * 4 * rbda_eq_4_13(q=O.unit_quaternion)
    n = tau
    return c * n

  def get_q(O):
    return O.qe.elems

  def new_q(O, q):
    return spherical(qe=matrix.col(q))

class revolute_alignment(object):

  def __init__(O, pivot, normal):
    r = normal.vector_to_001_rotation()
    O.cb_0b = matrix.rt((r, -r * pivot))
    O.cb_b0 = matrix.rt((r.transpose(), pivot))

class revolute(object):

  degrees_of_freedom = 1
  qd_zero = matrix.zeros(n=degrees_of_freedom)
  qdd_zero = qd_zero

  def __init__(O, qe):
    O.qe = qe
    O.q_size = len(qe)
    #
    c, s = math.cos(qe[0]), math.sin(qe[0])
    e = matrix.sqr((c, s, 0, -s, c, 0, 0, 0, 1)) # RBDA Tab. 2.2
    #
    O.cb_ps = matrix.rt((e, (0,0,0)))
    O.cb_sp = matrix.rt((e.transpose(), (0,0,0)))
    O.motion_subspace = matrix.col((0,0,1,0,0,0))

  def get_linear_velocity(O, qd):
    return None

  def new_linear_velocity(O, qd, value):
    return None

  def time_step_position(O, qd, delta_t):
    new_qe = O.qe + qd * delta_t
    return revolute(qe=new_qe)

  def time_step_velocity(O, qd, qdd, delta_t):
    return qd + qdd * delta_t

  def tau_as_d_e_pot_d_q(O, tau):
    return tau

  def get_q(O):
    return O.qe.elems

  def new_q(O, q):
    return revolute(qe=matrix.col(q))

class translational_alignment(six_dof_alignment): pass

class translational(object):

  degrees_of_freedom = 3
  qd_zero = matrix.zeros(n=degrees_of_freedom)
  qdd_zero = qd_zero

  def __init__(O, qr):
    O.qr = qr
    O.q_size = 3
    O.cb_ps = matrix.rt(((1,0,0,0,1,0,0,0,1), -qr))
    O.cb_sp = matrix.rt(((1,0,0,0,1,0,0,0,1), qr))
    O.motion_subspace = matrix.rec((
      0,0,0,
      0,0,0,
      0,0,0,
      1,0,0,
      0,1,0,
      0,0,1), n=(6,3))

  def get_linear_velocity(O, qd):
    return qd

  def new_linear_velocity(O, qd, value):
    return value

  def time_step_position(O, qd, delta_t):
    new_qr = O.qr + qd * delta_t
    return translational(qr=new_qr)

  def time_step_velocity(O, qd, qdd, delta_t):
    return qd + qdd * delta_t

  def tau_as_d_e_pot_d_q(O, tau):
    return tau

  def get_q(O):
    return O.qr.elems

  def new_q(O, q):
    return translational(qr=matrix.col(q))

def rbda_eq_4_12(q):
  p0, p1, p2, p3 = q
  return matrix.sqr((
    p0**2+p1**2-0.5,   p1*p2+p0*p3,     p1*p3-p0*p2,
      p1*p2-p0*p3,   p0**2+p2**2-0.5,   p2*p3+p0*p1,
      p1*p3+p0*p2,     p2*p3-p0*p1,   p0**2+p3**2-0.5)) * 2

def rbda_eq_4_13(q):
  p0, p1, p2, p3 = q
  return matrix.rec((
    -p1, -p2, -p3,
    p0, -p3, p2,
    p3, p0, -p1,
    -p2, p1, p0), n=(4,3)) * 0.5

def d_unit_quaternion_d_qe_matrix(q):
  """
  Coefficent matrix for converting gradients w.r.t. normalized Euler
  parameters to gradients w.r.t. non-normalized parameters, as produced
  e.g. by a minimizer in the line search.
  Mathematica code:
    nsq = p0^2+p1^2+p2^2+p3^2
    p0p = p0 / Sqrt[nsq]
    p1p = p1 / Sqrt[nsq]
    p2p = p2 / Sqrt[nsq]
    p3p = p3 / Sqrt[nsq]
    n3 = (p0^2+p1^2+p2^2+p3^2)^(3/2)
    FortranForm[FullSimplify[D[p0p,p0]*n3]]
    FortranForm[FullSimplify[D[p1p,p0]*n3]]
    FortranForm[FullSimplify[D[p2p,p0]*n3]]
    FortranForm[FullSimplify[D[p3p,p0]*n3]]
    FortranForm[FullSimplify[D[p0p,p1]*n3]]
    FortranForm[FullSimplify[D[p1p,p1]*n3]]
    FortranForm[FullSimplify[D[p2p,p1]*n3]]
    FortranForm[FullSimplify[D[p3p,p1]*n3]]
    FortranForm[FullSimplify[D[p0p,p2]*n3]]
    FortranForm[FullSimplify[D[p1p,p2]*n3]]
    FortranForm[FullSimplify[D[p2p,p2]*n3]]
    FortranForm[FullSimplify[D[p3p,p2]*n3]]
    FortranForm[FullSimplify[D[p0p,p3]*n3]]
    FortranForm[FullSimplify[D[p1p,p3]*n3]]
    FortranForm[FullSimplify[D[p2p,p3]*n3]]
    FortranForm[FullSimplify[D[p3p,p3]*n3]]
  """
  p0,p1,p2,p3 = q
  p0s,p1s,p2s,p3s = p0**2, p1**2, p2**2, p3**2
  n3 = (p0s+p1s+p2s+p3s)**(3/2.)
  c00 = p1s+p2s+p3s
  c11 = p0s+p2s+p3s
  c22 = p0s+p1s+p3s
  c33 = p0s+p1s+p2s
  c01 = -p0*p1
  c02 = -p0*p2
  c03 = -p0*p3
  c12 = -p1*p2
  c13 = -p1*p3
  c23 = -p2*p3
  return matrix.sqr((
    c00, c01, c02, c03,
    c01, c11, c12, c13,
    c02, c12, c22, c23,
    c03, c13, c23, c33)) / n3


 *******************************************************************************


 *******************************************************************************
scitbx/rigid_body/essence/make_bundles.py
"""\
scitbx_rigid_body_essence
=========================

- A subset of ``scitbx/rigid_body/essence`` that can be used in isolation.

- Plain Python code for rigid body dynamics and gradient-driven minimization.

- Main reference::

    Rigid Body Dynamics Algorithms.
    Roy Featherstone,
    Springer, New York, 2007.
    ISBN-10: 0387743146

- `Open Source License <http://cctbx.svn.sourceforge.net/viewvc/cctbx/trunk/cctbx/LICENSE_2_0.txt?view=markup>`_

Context
-------

``scitbx/rigid_body/essence`` grew out of the development of the
dynamics engine for the ``phenix.refine`` **torsion angle dynamics**
module, which is used as a complementary method to gradient-driven
minimization, as a way to escape from local minima. See also:

  - Rice & Brunger (1994). Proteins: Structure, Function, and Genetics 19, 277-290.

  - http://phenix-online.org/

Nomenclature
------------

The variable names in the ``scitbx/rigid_body/essence`` source code
follow the nomenclature used in Featherstone's *Rigid Body Dynamics
Algorithms* as much as possible. Numerous ``RBDA`` comments point to
equations, tables, and figures in the book. **When using the source
code, it will be essential to have the book available as an introduction
and reference.**

Details
-------

Files::

  featherstone.py:   dynamics algorithms, based on Roy Featherstone's Matlab library
  spatial_lib.py:    spatial algebra, also based on Roy Featherstone's library
  joint_lib.py:      some joint models
  body_lib.py:       corresponding body objects
  scitbx_matrix.py:  general matrix algorithm (copy of scitbx/matrix/__init__.py)
  tst_basic.py:      unit tests compatible with Python 2.2 or higher

Download all files at once:

  - http://cctbx.sourceforge.net/scitbx_rigid_body_essence.tgz
  - http://cctbx.sourceforge.net/scitbx_rigid_body_essence.zip

To run the unit tests::

  cd scitbx_rigid_body_essence
  python tst_basic.py

The full scitbx/rigid_body functionality requires compiled modules,
written in C++. Download the entire scitbx from here:

  - http://cci.lbl.gov/scitbx_bundles/current/

or the entire cctbx (of which scitbx is a subset) from here:

  - http://cci.lbl.gov/cctbx_build/

Follow the instructions on the latter page to install the cctbx or
scitbx bundles (e.g. ``perl scitbx_bundle.selfx``).

The cctbx source tree is hosted at SourceForge. The latest versions
of the files in scitbx_rigid_body_essence can be found here:

  - http://cctbx.svn.sourceforge.net/viewvc/cctbx/trunk/scitbx/rigid_body/essence/

A version of featherstone.py that's closer to Roy Featherstone's original
Matlab code can be found here:

  - http://cctbx.svn.sourceforge.net/viewvc/cctbx/trunk/scitbx/rigid_body/proto/

The file ``wx_tardy.py`` is a simple 3D graphical viewer displaying
trajectories. It requires ``wxPython`` and the ``gltbx`` module of
the cctbx project. An easy way to get everything in one file and
install with a single command, is to download the phenix package from:

  - http://phenix-online.org/

Send questions to: cctbx@cci.lbl.gov or cctbxbb@phenix-online.org
"""
from __future__ import absolute_import, division, print_function

from libtbx.utils import copy_file, remove_files
from libtbx import easy_run
import libtbx.load_env
import sys, os

def run(args):
  assert len(args) == 0
  tmpdir = "scitbx_rigid_body_essence"
  if (not os.path.isdir(tmpdir)):
    os.mkdir(tmpdir)
  os.chdir(tmpdir)
  scitbx_dist = libtbx.env.dist_path(module_name="scitbx")
  def cp(file_name, target="."):
    copy_file(os.path.join(scitbx_dist, file_name), target)
  cp("matrix/__init__.py", "scitbx_matrix.py")
  cp("rigid_body/essence/featherstone.py")
  cp("rigid_body/essence/spatial_lib.py")
  cp("rigid_body/essence/joint_lib.py")
  cp("rigid_body/essence/body_lib.py")
  cp("rigid_body/essence/tst_basic.py")
  open("README.txt", "w").write(__doc__)
  os.chdir("..")
  if (   os.name == "nt"
      or not libtbx.env.has_module(name="docutils")):
    return
  remove_files("scitbx_rigid_body_essence.tgz")
  remove_files("scitbx_rigid_body_essence.zip")
  easy_run.fully_buffered(
    command="tar zcf scitbx_rigid_body_essence.tgz scitbx_rigid_body_essence")\
      .raise_if_errors_or_output()
  assert os.path.isfile("scitbx_rigid_body_essence.tgz")
  easy_run.fully_buffered(
    command="zip -r scitbx_rigid_body_essence.zip scitbx_rigid_body_essence")\
      .raise_if_errors()
  assert os.path.isfile("scitbx_rigid_body_essence.zip")
  os.chdir("scitbx_rigid_body_essence")
  easy_run.fully_buffered(
    command="docutils.rst2html README.txt > README.html")\
      .raise_if_errors()
  remove_files("README.txt")
  print(file=open(".htaccess", "w").write("""\
Options Indexes
"""))

if (__name__ == "__main__"):
  run(sys.argv[1:])


 *******************************************************************************


 *******************************************************************************
scitbx/rigid_body/essence/spatial_lib.py
"""\
Based in part on Roy Featherstone's spatial_v1 matlab code:

  http://axiom.anu.edu.au/~roy/spatial/

  Version 1: January 2008 (latest bug fix: 7 October 2008)

See also: RBDA:
  Rigid Body Dynamics Algorithms.
  Roy Featherstone,
  Springer, New York, 2007.
  ISBN-10: 0387743146
"""
from __future__ import absolute_import, division, print_function

try: import scitbx
except ImportError: import scitbx_matrix as matrix
else: from scitbx import matrix

def xrot(e):
  """RBDA Tab. 2.2, p. 23:
Spatial coordinate transform (rotation around origin).
Calculates the coordinate transform matrix from A to B coordinates
for spatial motion vectors, in which frame B is rotated relative to
frame A.
  """
  a,b,c,d,e,f,g,h,i = e
  return matrix.sqr((
     a,  b,  c,  0,  0,  0,
     d,  e,  f,  0,  0,  0,
     g,  h,  i,  0,  0,  0,
     0,  0,  0,  a,  b,  c,
     0,  0,  0,  d,  e,  f,
     0,  0,  0,  g,  h,  i))

def xtrans(r):
  """RBDA Tab. 2.2, p. 23:
Spatial coordinate transform (translation of origin).
Calculates the coordinate transform matrix from A to B coordinates
for spatial motion vectors, in which frame B is translated by an
amount r (3D vector) relative to frame A.
  """
  r1,r2,r3 = r
  return matrix.sqr((
      1,   0,   0, 0, 0, 0,
      0,   1,   0, 0, 0, 0,
      0,   0,   1, 0, 0, 0,
      0,  r3, -r2, 1, 0, 0,
    -r3,   0,  r1, 0, 1, 0,
     r2, -r1,   0, 0, 0, 1))

def cb_as_spatial_transform(cb):
  """RBDA Eq. 2.28, p. 22:
Conversion of matrix.rt object cb to spatial transform.
"""
  return xrot(cb.r) * xtrans(-cb.r.transpose() * cb.t)

def crm(v):
  """RBDA Eq. 2.31, p. 25:
Spatial cross-product operator (motion).
Calculates the 6x6 matrix such that the expression crm(v)*m is the
cross product of the spatial motion vectors v and m.
  """
  v1,v2,v3,v4,v5,v6 = v
  return matrix.sqr((
      0, -v3,  v2,   0,   0,   0,
     v3,   0, -v1,   0,   0,   0,
    -v2,  v1,   0,   0,   0,   0,
      0, -v6,  v5,   0, -v3,  v2,
     v6,   0, -v4,  v3,   0, -v1,
    -v5,  v4,   0, -v2,  v1,   0))

def crf(v):
  """RBDA Eq. 2.32, p. 25:
Spatial cross-product operator (force).
Calculates the 6x6 matrix such that the expression crf(v)*f is the
cross product of the spatial motion vector v with the spatial force
vector f.
  """
  return -crm(v).transpose()

def mci(m, c, i):
  """RBDA Eq. 2.63, p. 33:
Spatial rigid-body inertia from mass, CoM and rotational inertia.
Calculates the spatial inertia matrix of a rigid body from its
mass, centre of mass (3D vector) and rotational inertia (3x3 matrix)
about its centre of mass.
  """
  cx = matrix.cross_product_matrix(c)
  return matrix.sqr((
    i + m*cx*cx.transpose(), m*cx,
    m*cx.transpose(), m*matrix.identity(3))).resolve_partitions()

def kinetic_energy(i_spatial, v_spatial):
  "RBDA Eq. 2.67, p. 35"
  return 0.5 * v_spatial.dot(i_spatial * v_spatial)


 *******************************************************************************


 *******************************************************************************
scitbx/rigid_body/essence/tardy.py
from __future__ import absolute_import, division, print_function
from scitbx.rigid_body.essence import featherstone
from scitbx.rigid_body.essence import body_lib
import scitbx.lbfgs
from scitbx.array_family import flex
from scitbx import matrix
import math
from six.moves import range
from six.moves import zip

def construct_bodies(
      sites,
      masses,
      cluster_manager,
      near_singular_hinges_angular_tolerance_deg=5):
  assert len(masses) == len(sites)
  result = []
  abs_cos_limit = abs(math.cos(math.radians(
    near_singular_hinges_angular_tolerance_deg)))
  fvgci = cluster_manager.fixed_vertices_given_cluster_index_dict()
  for ic,cluster in enumerate(cluster_manager.clusters):
    body_sites = [matrix.col(sites[i]) for i in cluster]
    body_masses = [masses[i] for i in cluster]
    he = cluster_manager.hinge_edges[ic]
    fixed_vertices = fvgci.get(ic)
    if (fixed_vertices is not None):
      if (   len(fixed_vertices) > 2
          or len(fixed_vertices) == len(cluster)):
        body = body_lib.zero_dof(sites=body_sites, masses=body_masses)
      elif (len(fixed_vertices) == 1):
        body = body_lib.spherical(
          sites=body_sites,
          masses=body_masses,
          pivot=sites[fixed_vertices[0]])
      elif (len(fixed_vertices) == 2):
        normal_sites = [matrix.col(sites[i]) for i in fixed_vertices]
        pivot = normal_sites[1]
        axis = pivot - normal_sites[0]
        for site in body_sites:
          abs_cos = abs(axis.cos_angle(site - pivot, value_if_undefined=1))
          if (abs_cos < abs_cos_limit):
            body = body_lib.revolute(
              sites=body_sites,
              masses=body_masses,
              pivot=pivot,
              normal=axis.normalize())
            break
        else:
          body = body_lib.zero_dof(sites=body_sites, masses=body_masses)
      else:
        raise AssertionError
      body.parent = -1
    elif (he[0] == -1):
      if (len(body_sites) == 1):
        body = body_lib.translational(
          sites=body_sites, masses=body_masses)
      else:
        body = body_lib.six_dof(sites=body_sites, masses=body_masses)
      body.parent = -1
    else:
      normal_sites = [matrix.col(sites[i]) for i in he]
      body = body_lib.revolute(
        sites=body_sites,
        masses=body_masses,
        pivot=normal_sites[1],
        normal=(normal_sites[1]-normal_sites[0]).normalize())
      body.parent = cluster_manager.cluster_indices[he[1]]
    body.i_seqs = cluster
    result.append(body)
  body_lib.set_cb_tree(bodies=result)
  return result

class model(featherstone.system_model):

  def __init__(O,
        labels,
        sites,
        masses,
        tardy_tree,
        potential_obj,
        near_singular_hinges_angular_tolerance_deg=5):
    super(model, O).__init__(bodies=construct_bodies(
      sites=sites,
      masses=masses,
      cluster_manager=tardy_tree.cluster_manager,
      near_singular_hinges_angular_tolerance_deg=
        near_singular_hinges_angular_tolerance_deg))
    O.labels = labels
    O.sites = sites
    O.masses = masses
    O.tardy_tree = tardy_tree
    O.potential_obj = potential_obj
    O.near_singular_hinges_angular_tolerance_deg = \
      near_singular_hinges_angular_tolerance_deg
    O.flag_positions_as_changed()

  def flag_positions_as_changed(O):
    O.__sites_moved = None
    O.__e_pot = None
    O.__d_e_pot_d_sites = None
    O.__f_ext_array = None
    super(model, O).flag_positions_as_changed()

  def flag_velocities_as_changed(O):
    O.__qdd_array = None
    super(model, O).flag_velocities_as_changed()

  def sites_moved(O):
    if (O.__sites_moved is None):
      O_aja = O.aja_array()
      O.__sites_moved = [None] * len(O.sites)
      n_done = 0
      clusters = O.tardy_tree.cluster_manager.clusters
      for ib in range(len(O.bodies)):
        aja = O_aja[ib]
        for i_seq in clusters[ib]:
          assert O.__sites_moved[i_seq] is None
          O.__sites_moved[i_seq] = aja * O.sites[i_seq]
          n_done += 1
      assert n_done == len(O.sites)
    return O.__sites_moved

  def e_pot(O):
    if (O.__e_pot is None):
      if (O.potential_obj is None):
        O.__e_pot = 0
      else:
        O.__e_pot = O.potential_obj.e_pot(
          sites_moved=O.sites_moved())
    return O.__e_pot

  def d_e_pot_d_sites(O):
    if (O.__d_e_pot_d_sites is None):
      if (O.potential_obj is None):
        O.__d_e_pot_d_sites = [matrix.col((0,0,0))] * len(O.sites)
      else:
        O.__d_e_pot_d_sites = O.potential_obj.d_e_pot_d_sites(
          sites_moved=O.sites_moved())
    return O.__d_e_pot_d_sites

  def f_ext_array(O):
    if (O.__f_ext_array is None):
      O_jar_array = O.jar_array()
      O_d_e_pot_d_sites = O.d_e_pot_d_sites()
      O.__f_ext_array = []
      clusters = O.tardy_tree.cluster_manager.clusters
      for ib,body in enumerate(O.bodies):
        cb_0b = body.alignment.cb_0b
        jar = O_jar_array[ib]
        f = matrix.col((0,0,0))
        nc = matrix.col((0,0,0))
        for i_seq in clusters[ib]:
          s = O.sites[i_seq]
          force_bf = -(jar * O_d_e_pot_d_sites[i_seq])
          f += force_bf
          nc += (cb_0b * s).cross(force_bf)
        O.__f_ext_array.append(matrix.col((nc, f)).resolve_partitions())
    return O.__f_ext_array

  def d_e_pot_d_q(O):
    """
Gradients of potential energy (defined via f_ext_array) w.r.t. positional
coordinates q.
    """
    return [body.joint.tau_as_d_e_pot_d_q(tau=tau)
      for body,tau in zip(O.bodies,
                          O.f_ext_as_tau(f_ext_array=O.f_ext_array()))]

  def d_e_pot_d_q_packed(O):
    result = flex.double()
    result.reserve(O.q_packed_size)
    for v in O.d_e_pot_d_q():
      result.extend(flex.double(v))
    assert result.size() == O.q_packed_size
    return result

  def qdd_array(O):
    if (O.__qdd_array is None):
      O.__qdd_array = O.forward_dynamics_ab(
        tau_array=None, f_ext_array=O.f_ext_array(), grav_accn=None)
    return O.__qdd_array

  def e_tot(O):
    return O.e_kin() + O.e_pot()

  def dynamics_step(O, delta_t):
    O_qdd_array = O.qdd_array()
    for body in O.bodies:
      body.joint = body.joint.time_step_position(
        qd=body.qd, delta_t=delta_t)
    for body,qdd in zip(O.bodies, O_qdd_array):
      body.qd = body.joint.time_step_velocity(
        qd=body.qd, qdd=qdd, delta_t=delta_t)
    O.flag_positions_as_changed()

  def minimization(O, max_iterations=None, callback_after_step=None):
    return refinery(
      tardy_model=O,
      max_iterations=max_iterations,
      callback_after_step=callback_after_step)

class refinery(object):

  def __init__(O, tardy_model, max_iterations=None, callback_after_step=None):
    O.tardy_model = tardy_model
    O.__callback_after_step = callback_after_step
    O.x = tardy_model.pack_q()
    O.function_evaluations_total = 0
    O.lbfgs_steps_total = 0
    O.lbfgs_restarts = 0
    while True:
      lbfgs_steps_prev = O.lbfgs_steps_total
      scitbx.lbfgs.run(
        target_evaluator=O,
        termination_params=scitbx.lbfgs.termination_parameters(
          max_iterations=max_iterations),
        exception_handling_params=scitbx.lbfgs.exception_handling_parameters(
          ignore_line_search_failed_step_at_lower_bound=True))
      if (O.lbfgs_steps_total == lbfgs_steps_prev):
        break
      if (max_iterations is not None):
        if (O.lbfgs_steps_total >= max_iterations):
          break
        max_iterations -= O.lbfgs_steps_total
      O.lbfgs_restarts += 1
    del O.x

  def callback_after_step(O, minimizer):
    O.lbfgs_steps_total += 1
    if (O.__callback_after_step is not None):
      O.__callback_after_step(minimizer=minimizer)

  def compute_functional_and_gradients(O):
    O.function_evaluations_total += 1
    O.tardy_model.unpack_q(q_packed=O.x)
    f = O.tardy_model.e_pot()
    g = O.tardy_model.d_e_pot_d_q_packed()
    return f, g


 *******************************************************************************


 *******************************************************************************
scitbx/rigid_body/essence/tst_basic.py
from __future__ import absolute_import, division, print_function
from scitbx.rigid_body.essence import featherstone, body_lib, joint_lib, spatial_lib
from six.moves import zip

matrix = featherstone.matrix
if (featherstone.scitbx is not None):
  from libtbx.test_utils import approx_equal
else:
  def approx_equal(a1, a2): return True
  print("libtbx.test_utils not available: approx_equal() disabled")
  def sum(l):
    result = 0
    for e in l: result += e
    return result

import sys

def exercise_basic():
  assert approx_equal(sum(spatial_lib.xrot((1,2,3,4,5,6,7,8,9))), 90)
  assert approx_equal(sum(spatial_lib.xtrans((1,2,3))), 6)
  assert approx_equal(
    sum(spatial_lib.cb_as_spatial_transform(
      cb=matrix.rt(((1,2,3,4,5,6,7,8,9), (1,2,3))))), 90)
  assert approx_equal(sum(spatial_lib.crm((1,2,3,4,5,6))), 0)
  assert approx_equal(sum(spatial_lib.crf((1,2,3,4,5,6))), 0)
  i_spatial = spatial_lib.mci(
    m=1.234,
    c=matrix.col((1,2,3)),
    i=matrix.sym(sym_mat3=(2,3,4,0.1,0.2,0.3)))
  assert approx_equal(sum(i_spatial), 21.306)
  assert approx_equal(spatial_lib.kinetic_energy(
    i_spatial=i_spatial, v_spatial=matrix.col((1,2,3,4,5,6))), 75.109)
  #
  mass_points = body_lib.mass_points(
    sites=matrix.col_list([
      (0.949, 2.815, 5.189),
      (0.405, 3.954, 5.917),
      (0.779, 5.262, 5.227)]),
    masses=[2.34, 3.56, 1.58])
  assert approx_equal(mass_points.sum_of_masses(), 7.48)
  assert approx_equal(mass_points.center_of_mass(),
    [0.654181818182, 3.87397058824, 5.54350802139])
  assert approx_equal(mass_points._sum_of_masses, 7.48)
  assert approx_equal(
    mass_points.inertia(pivot=matrix.col((0.9,-1.3,0.4))),
    [404.7677928, 10.04129606, 10.09577652,
     10.04129606, 199.7384559, -199.3511949,
     10.09577652, -199.3511949, 206.8314171])

class zero_dof_body(object):

  def __init__(O):
    O.alignment = joint_lib.zero_dof_alignment()
    O.i_spatial = matrix.sqr([0]*36)
    O.joint = joint_lib.zero_dof()
    O.qd = O.joint.qd_zero
    assert O.joint.get_linear_velocity(qd=O.qd) is None
    assert O.joint.new_linear_velocity(qd=None, value=None) is None
    O.parent = -1

class six_dof_body(object):

  def __init__(O):
    sites = matrix.col_list([
      (0.949, 2.815, 5.189),
      (0.405, 3.954, 5.917),
      (0.779, 5.262, 5.227)])
    mass_points = body_lib.mass_points(sites=sites, masses=[1.0, 1.0, 1.0])
    O.alignment = joint_lib.six_dof_alignment(
      center_of_mass=mass_points.center_of_mass())
    O.i_spatial = mass_points.spatial_inertia(
      alignment_cb_0b=O.alignment.cb_0b)
    qe = matrix.col((0.18, 0.36, 0.54, -0.73)).normalize()
    qr = matrix.col((-0.1,0.3,0.2))
    O.joint = joint_lib.six_dof(qe=qe, qr=qr)
    O.qd = matrix.col((0.18,-0.02,-0.16,0.05,0.19,-0.29))
    assert O.joint.get_linear_velocity(qd=O.qd).elems == (0.05,0.19,-0.29)
    O.qd = O.joint.new_linear_velocity(
      qd=O.qd, value=matrix.col((-0.05,-0.19,0.29)))
    assert O.joint.get_linear_velocity(qd=O.qd).elems == (-0.05,-0.19,0.29)
    O.parent = -1

class spherical_body(object):

  def __init__(O):
    sites = matrix.col_list([
      (0.04, -0.16, 0.19),
      (0.10, -0.15, 0.18)])
    mass_points = body_lib.mass_points(sites=sites, masses=[1.0, 1.0])
    O.alignment = joint_lib.spherical_alignment(
      pivot=mass_points.center_of_mass())
    O.i_spatial = mass_points.spatial_inertia(
      alignment_cb_0b=O.alignment.cb_0b)
    qe = matrix.col((-0.50, -0.33, 0.67, -0.42)).normalize()
    O.joint = joint_lib.spherical(qe=qe)
    O.qd = matrix.col((0.12, -0.08, 0.11))
    assert O.joint.get_linear_velocity(qd=O.qd) is None
    assert O.joint.new_linear_velocity(qd=None, value=None) is None
    O.parent = 0

class revolute_body(object):

  def __init__(O, parent):
    pivot = matrix.col((0.779, 5.262, 5.227))
    normal = matrix.col((0.25, 0.86, -0.45)).normalize()
    sites = matrix.col_list([(-0.084, 6.09, 4.936)])
    mass_points = body_lib.mass_points(sites=sites, masses=[1.0])
    O.alignment = joint_lib.revolute_alignment(pivot=pivot, normal=normal)
    O.i_spatial = mass_points.spatial_inertia(
      alignment_cb_0b=O.alignment.cb_0b)
    O.joint = joint_lib.revolute(qe=matrix.col([0.26]))
    O.qd = matrix.col([-0.19])
    assert O.joint.get_linear_velocity(qd=O.qd) is None
    assert O.joint.new_linear_velocity(qd=None, value=None) is None
    O.parent = parent

class translational_body(object):

  def __init__(O):
    sites = [matrix.col((0.949, 2.815, 5.189))]
    mass_points = body_lib.mass_points(sites=sites, masses=[1.0])
    O.alignment = joint_lib.translational_alignment(
      center_of_mass=mass_points.center_of_mass())
    O.i_spatial = mass_points.spatial_inertia(
      alignment_cb_0b=O.alignment.cb_0b)
    qr = matrix.col((-0.1,0.3,0.2))
    O.joint = joint_lib.translational(qr=qr)
    O.qd = matrix.col((0.05,0.19,-0.29))
    assert O.joint.get_linear_velocity(qd=O.qd).elems == O.qd.elems
    O.qd = O.joint.new_linear_velocity(qd=O.qd, value=-O.qd)
    assert O.joint.get_linear_velocity(qd=O.qd).elems == O.qd.elems
    O.parent = -1

def exercise_system_model():
  bodies = [
    six_dof_body(),
    spherical_body(),
    revolute_body(parent=1),
    translational_body()]
  body_lib.set_cb_tree(bodies=bodies)
  model = featherstone.system_model(bodies=bodies)
  assert approx_equal(model.e_kin(), 5.10688665235)
  assert approx_equal(model.qd_e_kin_scales(), [
    0.1036643, 0.1054236, 0.1187526, 0.5773503, 0.5773503, 0.5773503,
    0.1749883, 0.2830828, 0.2225619,
    1.334309,
    1.414214, 1.414214, 1.414214])
  #
  qdd = matrix.col_list([
    (-0.04,0.05,0.23,-0.01,-0.08,0.04),
    (0.08,-0.08,-0.01),
    (0.14,),
    (-0.01, -0.34, 0.28)])
  f_ext = matrix.col_list([
    (-0.10, 0.30, -0.01, -0.01, 0.01, 0.06),
    (0.28, 0.09, 0.14, 0.23, 0.00, 0.07),
    (-0.11, 0.03, -0.07, -0.11, 0.06, 0.08),
    (-0.16, 0.14, -0.33, 0.35, -0.02, -0.20)])
  grav_accn = matrix.col((0.02, -0.13, 0.15, 0.26, -0.16, 0.14))
  #
  qdd0 = [
    (0,0,0,0,0,0),
    (0,0,0),
    (0,),
    (0,0,0)]
  for qdd_array in [None, qdd0]:
    tau = model.inverse_dynamics(qdd_array=qdd_array)
    assert approx_equal(tau, [
      (3.0067673409496019, -1.9747070164103167, -0.96510418705493095,
       0.62119145987365987, 0.79528549692226591, 0.50582706679253908),
      (-3.5089966946778439, 0.85280077414986188, -1.1466929846982585),
      (-0.68035016279655447,),
      (0.0, 0.0, 0.0)])
  qdd2 = model.forward_dynamics_ab(tau_array=tau)
  assert approx_equal(qdd2, qdd0)
  #
  tau = model.inverse_dynamics(qdd_array=qdd)
  assert approx_equal(tau, [
    (-28.4935967396, -13.9449610757, 37.119813341,
     3.09036984758, -3.29209848977, 1.51871803584),
    (22.0723956539, 1.85204188959, -1.96550741514),
    (0.526685445884,),
    (-0.01,-0.34,0.28)])
  qdd2 = model.forward_dynamics_ab(tau_array=tau)
  assert approx_equal(qdd2, qdd)
  #
  tau = model.inverse_dynamics(qdd_array=qdd, f_ext_array=f_ext)
  assert approx_equal(tau, [
    (-28.2069898504, -14.1650076325, 38.2656278316,
     3.24402886492, -3.30833610224, 1.36344785723),
    (22.6135703212, 2.25806832722, -2.77922603881),
    (0.596685445884,),
    (-0.36,-0.32,0.48)])
  qdd2 = model.forward_dynamics_ab(tau_array=tau, f_ext_array=f_ext)
  assert approx_equal(qdd2, qdd)
  #
  tau = model.inverse_dynamics(
    qdd_array=qdd, f_ext_array=f_ext, grav_accn=grav_accn)
  assert approx_equal(tau, [
    (29.0716177639, 1.548329665, -9.90799285557,
     -2.51132634591, 5.78686348626, -3.77518591503),
    (-4.70390288163, -1.2432778965, 1.1909533225),
    (-0.354638347024,),
    (0.54782, -0.17957, 0.16733)])
  qdd2 = model.forward_dynamics_ab(
    tau_array=tau, f_ext_array=f_ext, grav_accn=grav_accn)
  assert approx_equal(qdd2, qdd)
  #
  new_q = [
    body.joint.time_step_position(qd=body.qd, delta_t=0.01).get_q()
      for body in model.bodies]
  assert approx_equal(new_q, [
    (0.18036749, 0.36210928, 0.54329229, -0.7356480,
     -0.10189282, 0.29788946, 0.2020574),
    (-0.50329486, -0.33273860, 0.67548709, -0.4239072),
    (0.2581,),
    (-0.1005, 0.2981, 0.2029)])
  new_qd = [
    body.joint.time_step_velocity(qd=body.qd, qdd=qdd_i, delta_t=0.01)
      for body,qdd_i in zip(model.bodies, qdd)]
  assert approx_equal(new_qd, [
    (0.1796, -0.0195, -0.1577, -0.0501, -0.1908, 0.2904),
    (0.1208, -0.0808, 0.1099),
    (-0.1886,),
    (-0.0501, -0.1934, 0.2928)])
  for body,q in zip(model.bodies, [(1,2,3,4,5,6,7),(8,9,10,11),(12,)]):
    assert approx_equal(body.joint.new_q(q=q).get_q(), q)
  #
  qdd = []
  for body in model.bodies:
    body.qd = body.joint.qd_zero
    qdd.append(body.joint.qdd_zero)
  model.flag_velocities_as_changed()
  tau = model.inverse_dynamics(qdd_array=qdd, f_ext_array=f_ext)
  assert approx_equal(tau, [
    (0.286606889188, -0.220046556736, 1.14581449056,
     0.153659017347, -0.0162376124727, -0.155270178613),
    (0.541174667239, 0.406026437633, -0.813718623664),
    (0.07,),
    (-0.35,0.02,0.2)])
  tau0 = model.f_ext_as_tau(f_ext_array=f_ext)
  assert approx_equal(tau0, tau)

def exercise_system_model_with_zero_dof_body():
  bodies = [
    zero_dof_body(),
    revolute_body(parent=0)]
  body_lib.set_cb_tree(bodies=bodies)
  model = featherstone.system_model(bodies=bodies)
  assert approx_equal(model.e_kin(), 0.0202765671829)
  assert approx_equal(model.qd_e_kin_scales(), [1.334309])
  #
  qdd = matrix.col_list([
    (),
    (0.14,)])
  f_ext = matrix.col_list([
    (-0.10, 0.30, -0.01, -0.01, 0.01, 0.06),
    (-0.11, 0.03, -0.07, -0.11, 0.06, 0.08)])
  grav_accn = matrix.col((0.02, -0.13, 0.15, 0.26, -0.16, 0.14))
  #
  tau = model.inverse_dynamics(qdd_array=qdd)
  assert approx_equal(tau, [
    (),
    (0.15726977316344815,)])
  qdd2 = model.forward_dynamics_ab(tau_array=tau)
  assert approx_equal(qdd2, qdd)
  #
  tau = model.inverse_dynamics(qdd_array=qdd, f_ext_array=f_ext)
  assert approx_equal(tau, [
    (),
    (0.22726977316344815,)])
  qdd2 = model.forward_dynamics_ab(tau_array=tau, f_ext_array=f_ext)
  assert approx_equal(qdd2, qdd)
  #
  tau = model.inverse_dynamics(
    qdd_array=qdd, f_ext_array=f_ext, grav_accn=grav_accn)
  assert approx_equal(tau, [
    (),
    (0.59601742875022201,)])
  qdd2 = model.forward_dynamics_ab(
    tau_array=tau, f_ext_array=f_ext, grav_accn=grav_accn)
  assert approx_equal(qdd2, qdd)
  #
  new_q = [
    body.joint.time_step_position(qd=body.qd, delta_t=0.01).get_q()
      for body in model.bodies]
  assert approx_equal(new_q, [
    (), (0.2581,)])
  new_qd = [
    body.joint.time_step_velocity(qd=body.qd, qdd=qdd_i, delta_t=0.01)
      for body,qdd_i in zip(model.bodies, qdd)]
  assert approx_equal(new_qd, [
    (),
    (-0.1886,)])
  for body,q in zip(model.bodies, [(),(13,)]):
    assert approx_equal(body.joint.new_q(q=q).get_q(), q)
  #
  qdd = []
  for body in model.bodies:
    body.qd = body.joint.qd_zero
    qdd.append(body.joint.qdd_zero)
  model.flag_velocities_as_changed()
  tau = model.inverse_dynamics(qdd_array=qdd, f_ext_array=f_ext)
  assert approx_equal(tau, [
    (),
    (0.07,)])
  tau0 = model.f_ext_as_tau(f_ext_array=f_ext)
  assert approx_equal(tau0, tau)

def run(args):
  assert len(args) == 0
  exercise_basic()
  exercise_system_model()
  exercise_system_model_with_zero_dof_body()
  print("OK")

if (__name__ == "__main__"):
  run(sys.argv[1:])


 *******************************************************************************


 *******************************************************************************
scitbx/rigid_body/essence/tst_energy_plots.py
from __future__ import absolute_import, division, print_function
from scitbx.rigid_body.essence import tst_tardy
from scitbx.array_family import flex
import sys
from six.moves import range

def run(args):
  if (len(args) == 0):
    model_index = 1
    n_dynamics_steps = 100
    delta_t = 0.01
  else:
    assert len(args) == 3, "model_index, n_dynamics_steps, delta_t"
    model_index = int(eval(args[0]))
    n_dynamics_steps = int(eval(args[1]))
    delta_t = float(eval(args[2]))
  tardy_model = tst_tardy.get_test_model_by_index(i=model_index)
  tardy_model.assign_random_velocities(e_kin_target=1)
  e_pots = flex.double([tardy_model.e_pot()])
  e_kins = flex.double([tardy_model.e_kin()])
  def show_e_tot():
    print("e_tot: %.6g" % (e_pots[-1]+e_kins[-1]))
    sys.stdout.flush()
  for i_step in range(n_dynamics_steps):
    tardy_model.dynamics_step(delta_t=delta_t)
    e_pots.append(tardy_model.e_pot())
    e_kins.append(tardy_model.e_kin())
    if (i_step % 1000 == 0):
      print("i_step:", i_step, end=' ')
      show_e_tot()
  print("i_step:", n_dynamics_steps, end=' ')
  show_e_tot()
  e_tots = e_pots + e_kins
  f = open("e_pot_kin_tot_i=%02d_n=%d_d=%.5f.xy" % (
    model_index, n_dynamics_steps, delta_t), "w")
  for es in [e_pots, e_kins, e_tots]:
    for e in es:
      print(e, file=f)
    print("&", file=f)
  f.close()
  print("OK")

if (__name__ == "__main__"):
  run(sys.argv[1:])


 *******************************************************************************


 *******************************************************************************
scitbx/rigid_body/essence/tst_tardy.py
from __future__ import absolute_import, division, print_function
from scitbx.rigid_body.essence import tardy
from scitbx.graph import tardy_tree
from scitbx.graph import test_cases_tardy_pdb
from scitbx.array_family import flex
from scitbx import matrix
from libtbx.utils import null_out, show_times_at_exit
from libtbx.test_utils import approx_equal, is_above_limit
import random
import sys
from six.moves import range
from six.moves import zip

if (1):
  random.seed(0)
  flex.set_random_seed(0)

class tardy_model(tardy.model):

  def d_e_pot_d_q_via_finite_differences(O, eps=1.e-6):
    result = []
    for body in O.bodies:
      gs = []
      j_orig = body.joint
      q_orig = list(j_orig.get_q())
      for iq in range(j_orig.q_size):
        fs = []
        for signed_eps in [eps, -eps]:
          q_eps = list(q_orig)
          q_eps[iq] += signed_eps
          body.joint = j_orig.new_q(q=q_eps)
          O.flag_positions_as_changed()
          fs.append(O.e_pot())
        gs.append((fs[0]-fs[1])/(2*eps))
      body.joint = j_orig
      O.flag_positions_as_changed()
      result.append(matrix.col(gs))
    return result

  def check_d_e_pot_d_q(O, verbose=0):
    qdd_orig = O.qdd_array()
    ana = O.d_e_pot_d_q()
    fin = O.d_e_pot_d_q_via_finite_differences()
    if (verbose):
      for a,f in zip(ana, fin):
        print("fin:", f.elems)
        print("ana:", a.elems)
      print()
    assert approx_equal(ana, fin)
    assert approx_equal(O.qdd_array(), qdd_orig)

class potential_object(object):

  def __init__(O,
        sites,
        wells,
        restraint_edges,
        restraint_edge_weight=1/0.1**2,
        epsilon=1.e-100):
    if (isinstance(wells, flex.vec3_double)):
      wells = [matrix.col(w) for w in wells]
    O.wells = wells
    O.restraints = []
    for edge in restraint_edges:
      s = [matrix.col(sites[i]) for i in edge]
      O.restraints.append((edge, abs(s[0]-s[1]), restraint_edge_weight))
    O.epsilon = epsilon

  def e_pot(O, sites_moved):
    if (isinstance(sites_moved, flex.vec3_double)):
      sites_moved = [matrix.col(s) for s in sites_moved]
    result = 0
    for s, w in zip(sites_moved, O.wells):
      result += (s - w).dot()
    for edge,d_ideal,w in O.restraints:
      s = [sites_moved[i] for i in edge]
      d_model = abs(s[0]-s[1])
      if (d_model < O.epsilon): continue
      delta = d_ideal - d_model
      result += w * delta**2
    return result

  def d_e_pot_d_sites(O, sites_moved):
    if (isinstance(sites_moved, flex.vec3_double)):
      sites_moved = [matrix.col(s) for s in sites_moved]
    result = []
    for s, w in zip(sites_moved, O.wells):
      result.append(2 * (s - w))
    for edge,d_ideal,w in O.restraints:
      s = [sites_moved[i] for i in edge]
      d_model = abs(s[0]-s[1])
      if (d_model < O.epsilon): continue
      delta = d_ideal - d_model
      g0 = -w * 2 * delta / d_model * (s[0] - s[1])
      result[edge[0]] += g0
      result[edge[1]] -= g0
    return result

def exercise_qd_e_kin_scales(tardy_model):
  def slow():
    result = flex.double()
    for body in tardy_model.bodies:
      bj0 = body.joint
      qd0 = body.joint.qd_zero
      qd = list(qd0)
      for iqd in range(len(qd)):
        qd[iqd] = qd0[iqd] + 1
        body.qd = matrix.col(qd)
        qd[iqd] = qd0[iqd]
        tardy_model.flag_velocities_as_changed()
        body.joint = bj0.time_step_position(qd=body.qd, delta_t=1)
        e_kin = tardy_model.e_kin()
        if (e_kin < 1.e-12):
          result.append(1)
        else:
          result.append(1 / e_kin**0.5)
      body.joint = bj0
      body.qd = body.joint.qd_zero
      tardy_model.flag_positions_as_changed()
    assert tardy_model.e_kin() == 0
    assert len(result) == tardy_model.degrees_of_freedom
    return result
  scales_slow = slow()
  scales_fast = tardy_model.qd_e_kin_scales()
  assert approx_equal(scales_fast, scales_slow)

def exercise_random_velocities(tardy_model):
  prev_qd = tardy_model.pack_qd()
  for e_kin_target in [1, 1.3, 0, 13]:
    tardy_model.assign_random_velocities(e_kin_target=e_kin_target)
    assert approx_equal(tardy_model.e_kin(), e_kin_target)
  assert not approx_equal(tardy_model.pack_qd(), prev_qd, out=None)
  tardy_model.unpack_qd(qd_packed=prev_qd)
  assert approx_equal(tardy_model.pack_qd(), prev_qd)

def exercise_accumulate_in_each_tree():
  def check(n_vertices, edge_list, clusters, nosiet, somiet):
    sites = matrix.col_list([(i,i%2,0) for i in range(n_vertices)])
    labels = [str(i) for i in range(n_vertices)]
    masses = [13, 7, 23, 19, 29, 11, 17][:n_vertices]
    assert len(masses) == n_vertices
    tt = tardy_tree.construct(sites=sites, edge_list=edge_list)
    assert len(tt.cluster_manager.fixed_hinges) == 0
    assert tt.cluster_manager.clusters == clusters
    tm = construct_tardy_model(
      labels=labels, sites=sites, masses=masses, tardy_tree=tt)
    assert tm.root_indices() == list(reversed([i for i,n in nosiet]))
    assert tm.number_of_sites_in_each_tree() == nosiet
    assert tm.sum_of_masses_in_each_tree() == somiet
  #
  check(
    n_vertices=5,
    edge_list=[],
    clusters=[[0],[1],[2],[3],[4]],
    nosiet=[(4, 1), (3, 1), (2, 1), (1, 1), (0, 1)],
    somiet=[(4, 29), (3, 19), (2, 23), (1, 7), (0, 13)])
  check(
    n_vertices=5,
    edge_list=[(0,1), (1,2), (3,4)],
    clusters=[[0,1,2], [3,4]],
    nosiet=[(1, 2), (0, 3)],
    somiet=[(1, 48), (0, 43)])
  check(
    n_vertices=5,
    edge_list=[(0,1), (1,2), (2,3), (3,4)],
    clusters=[[0,1,2], [3], [4]],
    nosiet=[(0, 5)],
    somiet=[(0, 91)])
  check(
    n_vertices=7,
    edge_list=[(0,1), (1,2), (2,3), (2,5), (3,4), (5,6)],
    clusters=[[1,2,3,5], [0], [4], [6]],
    nosiet=[(0, 7)],
    somiet=[(0, 119)])

def exercise_near_singular_hinges():
  # similar to scitbx/graph/test_cases_tardy_pdb.py, "collinear" test case
  r"""
    0                6
    | \             /
    |  2---3---4---5
    | /
    1
  """
  x = -0.5*3**0.5
  y = 0.5
  def build_sites(eps):
    return matrix.col_list([
      (x,-y,0),
      (x,y,0),
      (0,0,0),
      (1,0,0),
      (2,0,eps)])
  edge_list = [(0,1),(0,2),(1,2),(2,3),(3,4)]
  sites = build_sites(eps=0)
  for i,j in edge_list:
    assert approx_equal(abs(sites[i]-sites[j]), 1)
  sites = build_sites(eps=1e-5)
  labels = [str(i) for i in range(len(sites))]
  masses = [1] * len(sites)
  tt = tardy_tree.construct(n_vertices=len(sites), edge_list=edge_list)
  tt.build_tree()
  assert tt.cluster_manager.clusters == [[0,1,2,3], [4]]
  def e_kin_1():
    tm = construct_tardy_model(
      labels=labels,
      sites=sites,
      masses=masses,
      tardy_tree=tt)
    rnd = random.Random(0)
    tm.assign_random_velocities(e_kin_target=1, random_gauss=rnd.gauss)
    assert approx_equal(tm.e_kin(), 1, eps=1e-10)
    tm.dynamics_step(delta_t=0.01)
    return tm.e_kin()
  assert approx_equal(e_kin_1(), 60.9875715394)
  tt.fix_near_singular_hinges(sites=sites)
  assert tt.cluster_manager.fixed_hinges == [(2,3)]
  assert tt.cluster_manager.clusters == [[0,1,2,3,4]]
  assert approx_equal(e_kin_1(), 1.00004830172, eps=1e-10)
  #
  sites.append(matrix.col((3,0,0)))
  labels.append("5")
  masses.append(1)
  edge_list.append((4,5))
  tt = tardy_tree.construct(n_vertices=len(sites), edge_list=edge_list)
  tt.build_tree()
  assert tt.cluster_manager.clusters == [[0,1,2,3], [4], [5]]
  assert approx_equal(e_kin_1(), 9.55508653428)
  tt.fix_near_singular_hinges(sites=sites)
  assert tt.cluster_manager.fixed_hinges == [(2,3), (3,4)]
  assert tt.cluster_manager.clusters == [[0,1,2,3,4,5]]
  assert approx_equal(e_kin_1(), 1.00005333167, eps=1e-10)
  #
  sites.append(matrix.col((3-x,-y,0)))
  assert approx_equal(abs(sites[5] - sites[6]), 1)
  labels.append("6")
  masses.append(1)
  edge_list.append((5,6))
  tt = tardy_tree.construct(n_vertices=len(sites), edge_list=edge_list)
  tt.build_tree()
  assert tt.cluster_manager.clusters == [[0,1,2,3], [4], [5], [6]]
  assert approx_equal(e_kin_1(), 0.99994375467)
  tt.fix_near_singular_hinges(sites=sites)
  assert tt.cluster_manager.fixed_hinges == [(2,3), (3,4)]
  assert tt.cluster_manager.clusters == [[0,1,2,3,4,5], [6]]
  assert approx_equal(e_kin_1(), 1.0000438095, eps=1e-10)

def exercise_linear_velocity_manipulations(tardy_model):
  for nosiet in [None, tardy_model.number_of_sites_in_each_tree()]:
    tardy_model.assign_random_velocities(e_kin_target=17)
    if (tardy_model.degrees_of_freedom == 0):
      assert approx_equal(tardy_model.e_kin(), 0)
      assert tardy_model.mean_linear_velocity(
        number_of_sites_in_each_tree=None) is None
    else:
      assert approx_equal(tardy_model.e_kin(), 17)
      mlv = tardy_model.mean_linear_velocity(
        number_of_sites_in_each_tree=nosiet)
      if (mlv is not None):
        assert is_above_limit(value=abs(mlv), limit=1e-3)
        tardy_model.subtract_from_linear_velocities(
          number_of_sites_in_each_tree=nosiet, value=mlv)
        mlv = tardy_model.mean_linear_velocity(
          number_of_sites_in_each_tree=nosiet)
        assert approx_equal(mlv, (0,0,0))

def exercise_fixed_vertices_special_cases():
  tardy_models = []
  """
          2
         /
    0---1
  """
  x = 0.5*3**0.5
  y = 0.5
  sites = matrix.col_list([
    (0,0,0),
    (1,0,0),
    (1+x,y,0)])
  edge_list = [(0,1),(1,2)]
  for i,j in edge_list:
    assert approx_equal(abs(sites[i]-sites[j]), 1)
  labels = [str(i) for i in range(len(sites))]
  masses = [1] * len(sites)
  #
  tt = tardy_tree.construct(
    sites=sites,
    edge_list=edge_list,
    fixed_vertex_lists=[])
  assert tt.cluster_manager.clusters == [[0,1,2]]
  tm = construct_tardy_model(
    labels=labels, sites=sites, masses=masses, tardy_tree=tt)
  tardy_models.append(tm)
  assert len(tm.bodies) == 1
  assert tm.bodies[0].joint.degrees_of_freedom == 6
  exercise_linear_velocity_manipulations(tardy_model=tm)
  #
  expected_e_kin_1 = [
    1.00009768395,
    1.00002522865,
    1.00000107257,
    1.0,
    1.0,
    1.0,
    0.0]
  rnd = random.Random(0)
  for i_fv,fixed_vertices in enumerate([[0], [1], [2],
                                        [0,1], [0,2], [1,2],
                                        [0,1,2]]):
    tt = tardy_tree.construct(
      sites=sites,
      edge_list=edge_list,
      fixed_vertex_lists=[fixed_vertices])
    assert tt.cluster_manager.clusters == [[0,1,2]]
    tm = construct_tardy_model(
      labels=labels, sites=sites, masses=masses, tardy_tree=tt)
    tardy_models.append(tm)
    assert len(tm.bodies) == 1
    assert tm.bodies[0].joint.degrees_of_freedom \
        == [3,1,0][len(fixed_vertices)-1]
    tm.assign_random_velocities(e_kin_target=1, random_gauss=rnd.gauss)
    if (len(fixed_vertices) != 3):
      assert approx_equal(tm.e_kin(), 1, eps=1e-10)
    else:
      assert approx_equal(tm.e_kin(), 0, eps=1e-10)
    tm.dynamics_step(delta_t=0.01)
    assert approx_equal(tm.e_kin(), expected_e_kin_1[i_fv], eps=1e-10)
    exercise_linear_velocity_manipulations(tardy_model=tm)
  #
  sites[2] = matrix.col([2,0,0])
  assert approx_equal((sites[0]-sites[1]).cos_angle(sites[2]-sites[1]), -1)
  for fixed_vertices in [[0,1], [0,2], [1,2]]:
    tt = tardy_tree.construct(
      sites=sites,
      edge_list=edge_list,
      fixed_vertex_lists=[fixed_vertices])
    assert tt.cluster_manager.clusters == [[0,1,2]]
    tm = construct_tardy_model(
      labels=labels, sites=sites, masses=masses, tardy_tree=tt)
    tardy_models.append(tm)
    assert len(tm.bodies) == 1
    assert tm.bodies[0].joint.degrees_of_freedom == 0
    exercise_linear_velocity_manipulations(tardy_model=tm)
  return tardy_models

def exercise_tardy_model(out, n_dynamics_steps, delta_t, tardy_model):
  tardy_model.check_d_e_pot_d_q()
  e_pots = flex.double([tardy_model.e_pot()])
  e_kins = flex.double([tardy_model.e_kin()])
  for i_step in range(n_dynamics_steps):
    tardy_model.dynamics_step(delta_t=delta_t)
    e_pots.append(tardy_model.e_pot())
    e_kins.append(tardy_model.e_kin())
  e_tots = e_pots + e_kins
  tardy_model.check_d_e_pot_d_q()
  print("degrees of freedom:", tardy_model.degrees_of_freedom, file=out)
  print("energy samples:", e_tots.size(), file=out)
  print("e_pot min, max:", min(e_pots), max(e_pots), file=out)
  print("e_kin min, max:", min(e_kins), max(e_kins), file=out)
  print("e_tot min, max:", min(e_tots), max(e_tots), file=out)
  print("start e_tot:", e_tots[0], file=out)
  print("final e_tot:", e_tots[-1], file=out)
  ave = flex.sum(e_tots) / e_tots.size()
  range_ = flex.max(e_tots) - flex.min(e_tots)
  if (ave == 0): relative_range = 0
  else:          relative_range = range_ / ave
  print("ave:", ave, file=out)
  print("range:", range_, file=out)
  print("relative range:", relative_range, file=out)
  print(file=out)
  out.flush()
  return relative_range

def exercise_dynamics_quick(
      out, tardy_model, n_dynamics_steps, delta_t=0.0001):
  relative_range = exercise_tardy_model(
    out=out,
    n_dynamics_steps=n_dynamics_steps,
    delta_t=delta_t,
    tardy_model=tardy_model)
  if (out is not sys.stdout):
    if (len(tardy_model.tardy_tree.cluster_manager.loop_edges) == 0):
      assert relative_range < 1.e-5
    else:
      assert relative_range < 2.e-4
  print(file=out)

def exercise_minimization_quick(out, tardy_model, max_iterations=5):
  print("Minimization:", file=out)
  print("  start e_pot:", tardy_model.e_pot(), file=out)
  e_pot_start = tardy_model.e_pot()
  tardy_model.minimization(max_iterations=max_iterations)
  print("  final e_pot:", tardy_model.e_pot(), file=out)
  e_pot_final = tardy_model.e_pot()
  if (out is not sys.stdout):
    assert e_pot_final < e_pot_start * 0.7
  print(file=out)

def construct_tardy_model(
      labels,
      sites,
      masses,
      tardy_tree):
  cm = tardy_tree.cluster_manager
  return tardy_model(
    labels=labels,
    sites=sites,
    masses=masses,
    tardy_tree=tardy_tree,
    potential_obj=potential_object(
      sites=sites,
      wells=sites,
      restraint_edges=cm.loop_edges+cm.loop_edge_bendings))

def exercise_with_tardy_model(out, tardy_model, n_dynamics_steps):
  tardy_model.tardy_tree.show_summary(out=out, vertex_labels=None)
  #
  ri = tardy_model.root_indices()
  assert len(ri) == 1
  nosiet = tardy_model.number_of_sites_in_each_tree()
  assert len(nosiet) == 1
  assert nosiet[0][0] == ri[0]
  assert nosiet[0][1] == len(tardy_model.sites)
  somiet = tardy_model.number_of_sites_in_each_tree()
  assert len(somiet) == 1
  assert somiet[0][0] == ri[0]
  assert somiet[0][1] == len(tardy_model.sites)
  #
  exercise_qd_e_kin_scales(tardy_model=tardy_model)
  exercise_random_velocities(tardy_model=tardy_model)
  exercise_linear_velocity_manipulations(tardy_model=tardy_model)
  tardy_model.assign_random_velocities(e_kin_target=1)
  assert approx_equal(tardy_model.e_kin(), 1)
  exercise_dynamics_quick(
    out=out, tardy_model=tardy_model, n_dynamics_steps=n_dynamics_steps)
  exercise_minimization_quick(out=out, tardy_model=tardy_model)

n_test_models = len(test_cases_tardy_pdb.test_cases)

def get_test_model_by_index(i, fixed_vertex_lists=[]):
  tc = test_cases_tardy_pdb.test_cases[i]
  tt = tc.tardy_tree_construct(fixed_vertex_lists=fixed_vertex_lists)
  return construct_tardy_model(
    labels=tc.labels,
    sites=tc.sites,
    masses=[1.0]*len(tc.sites),
    tardy_tree=tt)

test_case_5_fixed_vertices_expected_dof = [
  ([0,16,17], 2),
  ([16,17], 5),
  ([12], 8)]

def run(args):
  assert len(args) in [0,1]
  if (len(args) == 0):
    n_dynamics_steps = 100
    out = null_out()
  else:
    n_dynamics_steps = max(1, int(args[0]))
    out = sys.stdout
  show_times_at_exit()
  #
  exercise_accumulate_in_each_tree()
  exercise_near_singular_hinges()
  exercise_fixed_vertices_special_cases()
  #
  if (1):
    for i in range(n_test_models):
      print("test model index:", i, file=out)
      tardy_model = get_test_model_by_index(i=i)
      exercise_with_tardy_model(
        out=out, tardy_model=tardy_model, n_dynamics_steps=n_dynamics_steps)
      if (i == 0):
        assert tardy_model.degrees_of_freedom == 3
        fixed_vertices = [0]
        print("test model index:", i, \
          "fixed_vertices:", fixed_vertices, file=out)
        tardy_model = get_test_model_by_index(
          i=i, fixed_vertex_lists=[fixed_vertices])
        assert tardy_model.degrees_of_freedom == 0
      elif (i == 5):
        assert tardy_model.degrees_of_freedom == 11
        for fixed_vertices,expected_dof in \
              test_case_5_fixed_vertices_expected_dof:
          print("test model index:", i, \
            "fixed_vertices:", fixed_vertices, file=out)
          tardy_model = get_test_model_by_index(
            i=i, fixed_vertex_lists=[fixed_vertices])
          assert tardy_model.degrees_of_freedom == expected_dof
          exercise_with_tardy_model(
            out=out,
            tardy_model=tardy_model,
            n_dynamics_steps=n_dynamics_steps)
  #
  print("OK")

if (__name__ == "__main__"):
  run(sys.argv[1:])


 *******************************************************************************


 *******************************************************************************
scitbx/rigid_body/essence/wx_tardy.py
from __future__ import absolute_import, division, print_function
from scitbx.rigid_body.essence import tst_tardy
from scitbx.math import minimum_covering_sphere, sphere_3d
from scitbx.array_family import flex
from gltbx import wx_viewer
from libtbx.option_parser import libtbx_option_parser
import wx
import sys
from six.moves import range

class viewer(wx_viewer.show_points_and_lines_mixin):

  def __init__(self, *args, **kwds):
    super(viewer, self).__init__(*args, **kwds)

  def set_points(self):
    self.points = flex.vec3_double(self.tardy_model.sites_moved())
    self.labels_display_list = None
    self.lines_display_list = None
    self.points_display_list = None

  def set_points_and_lines(self,
        tardy_model,
        velocity_scaling=False,
        e_kin_per_dof=1,
        minimum_covering_sphere_view_scale=1.3,
        show_loop_edge_bendings=True,
        long_labels=None):
    self.tardy_model = tardy_model
    temperature_dof = len(tardy_model.sites) * 3
    if (e_kin_per_dof is None):
      self.e_kin_target = tardy_model.e_kin() / max(1, temperature_dof)
    else:
      self.e_kin_target = e_kin_per_dof * temperature_dof
      tardy_model.assign_random_velocities(e_kin_target=self.e_kin_target)
    self.velocity_scaling = velocity_scaling
    self.long_labels = long_labels
    self.labels = self.tardy_model.labels
    self.set_points()
    for line,color in tardy_model.tardy_tree.viewer_lines_with_colors(
          include_loop_edge_bendings=show_loop_edge_bendings):
      self.line_i_seqs.append(line)
      self.line_colors[line] = color
    print("\n".join(tardy_model.tardy_tree.viewer_lines_with_colors_legend(
      include_loop_edge_bendings=show_loop_edge_bendings)))
    mcs = minimum_covering_sphere(self.points, epsilon=1.e-2)
    self.minimum_covering_sphere = sphere_3d(
      center=mcs.center(),
      radius=mcs.radius()*minimum_covering_sphere_view_scale)
    self.flag_show_minimum_covering_sphere = False
    self.flag_show_rotation_center = False
    self.steps_per_tab = 1
    self.show_key_stroke_help()

  def show_key_stroke_help(self):
    print("Press and hold Tab key to run the dynamics.")
    print("Press Shift-Tab to increase speed.")
    print("Press Ctrl-Tab  to decrease speed.")
    print("Press M for minimization.")

  def process_key_stroke(self, key):
    if (key == ord("M")):
      return self.minimization()
    print("No action for this key stroke.")
    self.show_key_stroke_help()

  def tab_callback(self, shift_down=False, control_down=False):
    if (shift_down or control_down):
      if (shift_down):
        self.steps_per_tab = min(256, self.steps_per_tab * 2)
      else:
        self.steps_per_tab = max(1, self.steps_per_tab // 2)
      print("Steps per Tab:", self.steps_per_tab)
      return
    tm = self.tardy_model
    tm.dynamics_step(delta_t=0.05)
    if (self.velocity_scaling):
      tm.reset_e_kin(e_kin_target=self.e_kin_target)
    print("e_kin+e_pot: %12.6g + %12.6g = %12.6g" % (
      tm.e_kin(), tm.e_pot(), tm.e_tot()))
    self.set_points()
    self.OnRedraw()

  def minimization(self):
    print("Minimization:")
    print("  start e_pot:", self.tardy_model.e_pot())
    self.tardy_model.minimization(
      max_iterations=10,
      callback_after_step=self.minimization_callback)
    print("  final e_pot:", self.tardy_model.e_pot())

  def minimization_callback(self, minimizer):
    print("        e_pot:", self.tardy_model.e_pot())
    self.set_points()
    self.OnRedraw()

class App(wx_viewer.App):

  def __init__(self, args):
    n = tst_tardy.n_test_models
    command_line = (libtbx_option_parser(
      usage="""\
scitbx.python wx_tardy.py [options] model_index
  model_index range: 0 ... %d\
""" % (n-1))
      .option(None, "--fixed_vertices",
        type="str",
        action="append",
        default=None,
        metavar="COMMA-SEPARATED-INTEGERS")
      .option(None, "--i_seq_labels",
        action="store_true",
        default=False)
      .option(None, "--velocity_scaling",
        action="store_true",
        default=False)
      .option(None, "--e_kin_per_dof",
        type="float",
        default=1.0,
        metavar="FLOAT")
      .option(None, "--view_scale",
        type="float",
        default=1.3,
        metavar="FLOAT")
    ).process(args=args, nargs=1)
    co = command_line.options
    self.fixed_vertex_lists = []
    if (co.fixed_vertices is not None):
      for s in co.fixed_vertices:
        self.fixed_vertex_lists.append(tuple(eval("["+s+"]")))
    self.i_seq_labels = co.i_seq_labels
    self.velocity_scaling = co.velocity_scaling
    self.e_kin_per_dof = co.e_kin_per_dof
    self.view_scale = co.view_scale
    self.model_index = int(command_line.args[0])
    assert 0 <= self.model_index < n
    super(App, self).__init__(title="wx_tardy")

  def init_view_objects(self):
    box = wx.BoxSizer(wx.VERTICAL)
    self.view_objects = viewer(self.frame, size=(600,600))
    tardy_model = tst_tardy.get_test_model_by_index(
      i=self.model_index, fixed_vertex_lists=self.fixed_vertex_lists)
    if (self.i_seq_labels):
      tardy_model.labels = [str(i) for i in range(len(tardy_model.labels))]
    self.view_objects.set_points_and_lines(
      tardy_model=tardy_model,
      velocity_scaling=self.velocity_scaling,
      e_kin_per_dof=self.e_kin_per_dof,
      minimum_covering_sphere_view_scale=self.view_scale)
    box.Add(self.view_objects, wx.EXPAND, wx.EXPAND)
    self.frame.SetSizer(box)
    box.SetSizeHints(self.frame)

def run(args):
  App(args).MainLoop()

if (__name__ == "__main__"):
  run(sys.argv[1:])


 *******************************************************************************


 *******************************************************************************
scitbx/rigid_body/proto/__init__.py
"""
rigid_body.proto
"""

from __future__ import division


 *******************************************************************************


 *******************************************************************************
scitbx/rigid_body/proto/featherstone.py
"""\
Python version of a subset of Roy Featherstone's spatial_v1 matlab code:

  http://axiom.anu.edu.au/~roy/spatial/

  Version 1: January 2008 (latest bug fix: 7 October 2008)

The subset of converted files covers all dependencies of:
  ID.m
  FDab.m

The original matlab comments are preserved as Python docstrings.

See also:
  Rigid Body Dynamics Algorithms.
  Roy Featherstone,
  Springer, New York, 2007.
  ISBN-10: 0387743146
"""
from __future__ import absolute_import, division, print_function
from six.moves import range

try:
  import scitbx
except ImportError:
  scitbx = None

if (scitbx is not None):
  import scitbx.math
  from scitbx import matrix
  from libtbx.math_utils import ifloor

  def generalized_inverse(m):
    # assumption to achieve stability: order of magnitude of masses is around 1
    return matrix.sqr(
      scitbx.linalg.eigensystem.real_symmetric(
        m=m.as_flex_double_matrix(),
        relative_epsilon=1e-12,
        absolute_epsilon=1e-12)
          .generalized_inverse_as_packed_u()
          .matrix_packed_u_as_symmetric())

else:
  import scitbx_matrix as matrix

  def ifloor(x):
    def iround(x):
      if (x < 0): return int(x-0.5)
      return int(x+.5)
    return iround(math.floor(x))

  def generalized_inverse(m):
    return m.inverse()

import math

class InfType(object): pass
Inf = InfType()

def Xrotx(theta):
  """
% Xrotx  spatial coordinate transform (X-axis rotation).
% Xrotx(theta) calculates the coordinate transform matrix from A to B
% coordinates for spatial motion vectors, where coordinate frame B is
% rotated by an angle theta (radians) relative to frame A about their
% common X axis.
  """
  c = math.cos(theta)
  s = math.sin(theta)
  return matrix.sqr((
     1,  0,  0,  0,  0,  0,
     0,  c,  s,  0,  0,  0,
     0, -s,  c,  0,  0,  0,
     0,  0,  0,  1,  0,  0,
     0,  0,  0,  0,  c,  s,
     0,  0,  0,  0, -s,  c))

def Xroty(theta):
  """
% Xroty  spatial coordinate transform (Y-axis rotation).
% Xroty(theta) calculates the coordinate transform matrix from A to B
% coordinates for spatial motion vectors, where coordinate frame B is
% rotated by an angle theta (radians) relative to frame A about their
% common Y axis.
  """
  c = math.cos(theta)
  s = math.sin(theta)
  return matrix.sqr((
     c,  0, -s,  0,  0,  0,
     0,  1,  0,  0,  0,  0,
     s,  0,  c,  0,  0,  0,
     0,  0,  0,  c,  0, -s,
     0,  0,  0,  0,  1,  0,
     0,  0,  0,  s,  0,  c))

def Xrotz(theta):
  """
% Xrotz  spatial coordinate transform (Z-axis rotation).
% Xrotz(theta) calculates the coordinate transform matrix from A to B
% coordinates for spatial motion vectors, where coordinate frame B is
% rotated by an angle theta (radians) relative to frame A about their
% common Z axis.
  """
  c = math.cos(theta)
  s = math.sin(theta)
  return matrix.sqr((
     c,  s,  0,  0,  0,  0,
    -s,  c,  0,  0,  0,  0,
     0,  0,  1,  0,  0,  0,
     0,  0,  0,  c,  s,  0,
     0,  0,  0, -s,  c,  0,
     0,  0,  0,  0,  0,  1))

def Xrot(E):
  """
  Featherstone (2007) Tab. 2.2
  Added in Python version.
  """
  a,b,c,d,e,f,g,h,i = E
  return matrix.sqr((
     a,  b,  c,  0,  0,  0,
     d,  e,  f,  0,  0,  0,
     g,  h,  i,  0,  0,  0,
     0,  0,  0,  a,  b,  c,
     0,  0,  0,  d,  e,  f,
     0,  0,  0,  g,  h,  i))

def Xtrans(r):
  """
% Xtrans  spatial coordinate transform (translation of origin).
% Xtrans(r) calculates the coordinate transform matrix from A to B
% coordinates for spatial motion vectors, in which frame B is translated by
% an amount r (3D vector) relative to frame A.
  """
  r1,r2,r3 = r
  return matrix.sqr((
      1,   0,   0, 0, 0, 0,
      0,   1,   0, 0, 0, 0,
      0,   0,   1, 0, 0, 0,
      0,  r3, -r2, 1, 0, 0,
    -r3,   0,  r1, 0, 1, 0,
     r2, -r1,   0, 0, 0, 1))

def crm(v):
  """
% crm  spatial cross-product operator (motion).
% crm(v) calculates the 6x6 matrix such that the expression crm(v)*m is the
% cross product of the spatial motion vectors v and m.
  """
  v1,v2,v3,v4,v5,v6 = v
  return matrix.sqr((
      0, -v3,  v2,   0,   0,   0,
     v3,   0, -v1,   0,   0,   0,
    -v2,  v1,   0,   0,   0,   0,
      0, -v6,  v5,   0, -v3,  v2,
     v6,   0, -v4,  v3,   0, -v1,
    -v5,  v4,   0, -v2,  v1,   0))

def crf(v):
  """
% crf  spatial cross-product operator (force).
% crf(v) calculates the 6x6 matrix such that the expression crf(v)*f is the
% cross product of the spatial motion vector v with the spatial force
% vector f.
  """
  return -crm(v).transpose()

def mcI(m, c, I):
  """
% mcI  spatial rigid-body inertia from mass, CoM and rotational inertia.
% mcI(m,c,I) calculates the spatial inertia matrix of a rigid body from its
% mass, centre of mass (3D vector) and rotational inertia (3x3 matrix)
% about its centre of mass.
  """
  c1,c2,c3 = c
  C = matrix.sqr((
      0, -c3,  c2,
     c3,   0, -c1,
    -c2,  c1,  0))
  return matrix.sqr((
    I + m*C*C.transpose(), m*C,
    m*C.transpose(), m*matrix.identity(3))).resolve_partitions()

class autoTree(object):

  def __init__(self, nb, bf=1, skew=0, taper=1):
    """
% autoTree  Create System Models of Kinematic Trees
% autoTree(nb,bf,skew,taper) creates system models of kinematic trees
% having revolute joints.  nb and bf specify the number of bodies in the
% tree, and the branching factor, respectively.  The latter is the average
% number of children of a nonterminal node, and must be >=1.  bf=1 produces
% an unbranched tree; bf=2 produces a binary tree; and non-integer values
% produce trees in which the number of children alternates between
% floor(bf) and ceil(bf) in such a way that the average is bf.  Trees are
% constructed (and numbered) breadth-first.  Link i is a thin-walled
% cylindrical tube of length l(i), radius l(i)/20, and mass m(i), lying
% between 0 and l(i) on the x axis of its local coordinate system.  The
% values of l(i) and m(i) are determined by the tapering coefficient:
% l(i)=taper^(i-1) and m(i)=taper^(3*(i-1)).  Thus, if taper=1 then
% m(i)=l(i)=1 for all i.  The inboard joint axis of link i lies on the
% local z axis, and its outboard axis passes through the point (l(i),0,0)
% and is rotated about the x axis by an angle of skew radians relative to
% the inboard axis.  If the link has more than one outboard joint then they
% all have the same axis.  If skew=0 then the mechanism is planar.  The
% final one, two or three arguments can be omitted, in which case they
% assume default values of taper=1, skew=0 and bf=1.
    """
    self.NB = nb
    self.pitch = [0] * nb
    self.parent = [None] * nb
    self.Xtree = []
    self.I = []
    len_ = []
    for i in range(nb):
      self.parent[i] = ifloor((i-1+math.ceil(bf))/bf)-1
      if (self.parent[i] == -1):
        self.Xtree.append(Xtrans([0,0,0]))
      else:
        self.Xtree.append(Xrotx(skew) * Xtrans([len_[self.parent[i]],0,0]))
      len_.append(taper**i)
      mass = taper**(3*i)
      CoM = len_[i] * matrix.col([0.5,0,0])
      Icm = mass * len_[i]**2 * matrix.diag([0.0025,1.015/12,1.015/12])
      self.I.append(mcI(mass, CoM, Icm))

def jcalc(pitch, q):
  """
% jcalc  Calculate joint transform and motion subspace.
% [Xj,S]=jcalc(pitch,q) calculates the joint transform and motion subspace
% matrices for a revolute (pitch==0), prismatic (pitch==inf) or helical
% (pitch==any other value) joint.  For revolute and helical joints, q is
% the joint angle.  For prismatic joints, q is the linear displacement.
  """
  if (not isinstance(pitch, (int, float, InfType))):
    return pitch.Xj_S(q=q)
  if pitch == 0:                          # revolute joint
    Xj = Xrotz(q)
    S = matrix.col([0,0,1,0,0,0])
  elif pitch == Inf:                      # prismatic joint
    Xj = Xtrans([0,0,q])
    S = matrix.col([0,0,0,0,0,1])
  else:                                   # helical joint
    Xj = Xrotz(q) * Xtrans([0,0,q*pitch])
    S = matrix.col([0,0,1,0,0,pitch])
  return Xj, S

def grav_accn_as_a_grav(grav_accn):
  if grav_accn is None:
    return matrix.col([0,0,0,0,0,-9.81])
  grav_accn = list(grav_accn)
  assert len(grav_accn) == 3
  return matrix.col([0,0,0]+grav_accn)

def ID(model, q, qd, qdd, f_ext=None, grav_accn=None):
  """
% ID  Inverse Dynamics via Recursive Newton-Euler Algorithm
% ID(model,q,qd,qdd,f_ext,grav_accn) calculates the inverse dynamics of a
% kinematic tree via the recursive Newton-Euler algorithm.  q, qd and qdd
% are vectors of joint position, velocity and acceleration variables; and
% the return value is a vector of joint force variables.  f_ext is a cell
% array specifying external forces acting on the bodies.  If f_ext == {}
% then there are no external forces; otherwise, f_ext{i} is a spatial force
% vector giving the force acting on body i, expressed in body i
% coordinates.  Empty cells in f_ext are interpreted as zero forces.
% grav_accn is a 3D vector expressing the linear acceleration due to
% gravity.  The arguments f_ext and grav_accn are optional, and default to
% the values {} and [0,0,-9.81], respectively, if omitted.
  """

  a_grav = grav_accn_as_a_grav(grav_accn)

  S = [None] * model.NB
  Xup = [None] * model.NB
  v = [None] * model.NB
  a = [None] * model.NB
  f = [None] * model.NB
  for i in range(model.NB):
    XJ, S[i] = jcalc( model.pitch[i], q[i] )
    if (S[i] is None):
      vJ = qd[i]
      aJ = qdd[i]
    else:
      vJ = S[i]*qd[i]
      aJ = S[i]*qdd[i]
    Xup[i] = XJ * model.Xtree[i]
    if model.parent[i] == -1:
      v[i] = vJ
      a[i] = Xup[i] * -a_grav + aJ
    else:
      v[i] = Xup[i]*v[model.parent[i]] + vJ
      a[i] = Xup[i]*a[model.parent[i]] + aJ + crm(v[i])*vJ
    f[i] = model.I[i]*a[i] + crf(v[i])*model.I[i]*v[i]
    if (f_ext is not None and f_ext[i] is not None):
      f[i] = f[i] - f_ext[i]

  tau = [None] * model.NB
  for i in range(model.NB-1,-1,-1):
    if (S[i] is None):
      tau[i] = f[i]
    else:
      tau[i] = S[i].transpose() * f[i]
    if model.parent[i] != -1:
      f[model.parent[i]] = f[model.parent[i]] + Xup[i].transpose()*f[i]

  return tau

def FDab(model, q, qd, tau=None, f_ext=None, grav_accn=None, f_ext_in_ff=False):
  """
% FDab  Forward Dynamics via Articulated-Body Algorithm
% FDab(model,q,qd,tau,f_ext,grav_accn) calculates the forward dynamics of a
% kinematic tree via the articulated-body algorithm.  q, qd and tau are
% vectors of joint position, velocity and force variables; and the return
% value is a vector of joint acceleration variables.  f_ext is a cell array
% specifying external forces acting on the bodies.  If f_ext == {} then
% there are no external forces; otherwise, f_ext{i} is a spatial force
% vector giving the force acting on body i, expressed in body i
% coordinates.  Empty cells in f_ext are interpreted as zero forces.
% grav_accn is a 3D vector expressing the linear acceleration due to
% gravity.  The arguments f_ext and grav_accn are optional, and default to
% the values {} and [0,0,-9.81], respectively, if omitted.
  """

  a_grav = grav_accn_as_a_grav(grav_accn)

  S = [None] * model.NB
  Xup = [None] * model.NB
  X0 = [None] * model.NB
  v = [None] * model.NB
  c = [None] * model.NB
  IA = [None] * model.NB
  pA = [None] * model.NB
  for i in range(model.NB):
    XJ, S[i] = jcalc( model.pitch[i], q[i] )
    if (S[i] is None):
      vJ = qd[i]
    else:
      vJ = S[i]*qd[i]
    Xup[i] = XJ * model.Xtree[i]
    if model.parent[i] == -1:
      X0[i] = Xup[i]
      v[i] = vJ
      c[i] = matrix.col([0,0,0,0,0,0])
    else:
      X0[i] = Xup[i] * X0[model.parent[i]]
      v[i] = Xup[i]*v[model.parent[i]] + vJ
      c[i] = crm(v[i]) * vJ
    IA[i] = model.I[i]
    pA[i] = crf(v[i]) * model.I[i] * v[i]
    if (f_ext is not None and f_ext[i] is not None):
      if (not f_ext_in_ff):
        pA[i] = pA[i] - f_ext[i]
      else:
        pA[i] = pA[i] - X0[i].inverse().transpose() * f_ext[i]

  U = [None] * model.NB
  d_inv = [None] * model.NB
  u = [None] * model.NB
  for i in range(model.NB-1,-1,-1):
    if (S[i] is None):
      U[i] = IA[i]
      d = U[i]
      if (tau is None or tau[i] is None):
        u[i] =        - pA[i]
      else:
        u[i] = tau[i] - pA[i]
    else:
      U[i] = IA[i] * S[i]
      d = S[i].transpose() * U[i]
      if (tau is None or tau[i] is None):
        u[i] =        - S[i].transpose()*pA[i]
      else:
        u[i] = tau[i] - S[i].transpose()*pA[i]
    d_inv[i] = generalized_inverse(d)
    if model.parent[i] != -1:
      Ia = IA[i] - U[i] * d_inv[i] * U[i].transpose()
      pa = pA[i] + Ia*c[i] + U[i] * d_inv[i] * u[i]
      IA[model.parent[i]] = IA[model.parent[i]] \
                          + Xup[i].transpose() * Ia * Xup[i]
      pA[model.parent[i]] = pA[model.parent[i]] \
                          + Xup[i].transpose() * pa

  a = [None] * model.NB
  qdd = [None] * model.NB
  for i in range(model.NB):
    if model.parent[i] == -1:
      a[i] = Xup[i] * -a_grav + c[i]
    else:
      a[i] = Xup[i] * a[model.parent[i]] + c[i]
    qdd[i] = d_inv[i] * (u[i] - U[i].transpose()*a[i])
    if (S[i] is None):
      a[i] = a[i] + qdd[i]
    else:
      a[i] = a[i] + S[i]*qdd[i]

  return qdd


 *******************************************************************************


 *******************************************************************************
scitbx/rigid_body/proto/free_motion_reference_impl.py
"""\
6-DoF joint (free motion) reference implementation using the notation of
Featherstone (2007).

Dynamics simulation of the motion of a rigid triangle attached with
springs to an arbitrary position in space.

RBDA:
  Rigid Body Dynamics Algorithms.
  Roy Featherstone,
  Springer, New York, 2007.
  ISBN-10: 0387743146

Shabana (2005):
  Dynamics of Multibody Systems
  Ahmed A. Shabana
  Cambridge University Press, 3 edition, 2005
  ISBN-10: 0521850118
"""
from __future__ import absolute_import, division, print_function
from six.moves import range
from six.moves import zip

try:
  from scitbx import matrix
except ImportError:
  import scitbx_matrix as matrix

class simulation(object):

  def __init__(O):

    sites_cart_F0 = create_triangle_with_center_of_mass_at_origin()
    O.sites_cart_F1 = sites_cart_F0 # Xtree1, XJ1 = identity
    # F0, F01, Xtree1, J1: see RBDA Fig. 4.7

    # body inertia in F01, assuming unit masses, and total mass
    #
    O.I_F1 = body_inertia(O.sites_cart_F1)
    O.m = len(O.sites_cart_F1)

    # Euler parameters for some arbitrary rotation and translation
    #
    qE_J1 = matrix.col((0.9, -0.14, 0.1, 0.06)).normalize() # RBDA Eq. 4.11
    qr_J1 = matrix.col((-0.15, 0.1, 0.05))
    O.J1 = six_dof_joint_euler_params(qE_J1, qr_J1)

    # arbitrary spatial velocity in F01
    #
    w_F1 = matrix.col((0.04, -0.15, 0.10))
    v_F1 = matrix.col((0.1, 0.08, -0.05))
    O.qd = matrix.col((w_F1, v_F1)).resolve_partitions() # RBDA Eq. 2.4

    # arbitrary rotation and translation of potential wells
    #
    qE_Jp = matrix.col((0.99, -0.05, 0.04, -0.11)).normalize()
    qr_Jp = matrix.col((-0.15, 0.14, -0.37))
    Jp = six_dof_joint_euler_params(qE_Jp, qr_Jp)
    O.sites_cart_wells_F01 = [Jp.Tsp * xyz for xyz in O.sites_cart_F1]

    O.energies_and_accelerations_update()

  def energies_and_accelerations_update(O):

    # positional coordinates of moved triangle in F01 (not actually used here)
    #
    O.sites_cart_moved_F01 = [O.J1.Tsp * xyz for xyz in O.sites_cart_F1]

    # potential pulling triangle to wells (spring-like forces)
    #
    sites_cart_wells_moved_F1 = [O.J1.Tps * xyz
      for xyz in O.sites_cart_wells_F01]
    O.e_pot = 0
    for xyz, xyz_wells_moved in zip(O.sites_cart_F1,
                                    sites_cart_wells_moved_F1):
      O.e_pot += (xyz - xyz_wells_moved).dot()

    # corresponding forces
    #
    f_cart_F1 = [-2 * (xyz - xyz_wells_moved)
      for xyz, xyz_wells_moved in zip(O.sites_cart_F1,
                                      sites_cart_wells_moved_F1)]

    # f and nc in 3D, for RBDA Eq. 1.4
    #
    O.f_F1 = matrix.col((0,0,0))
    O.nc_F1 = matrix.col((0,0,0))
    for xyz,force in zip(O.sites_cart_F1, f_cart_F1):
      O.f_F1 += force
      O.nc_F1 += xyz.cross(force)

    # solution of RBDA Eq. 1.4 for ac and wd
    #
    O.ac_F1 = O.f_F1 / O.m
    w_F1, v_F1 = matrix.col(O.qd.elems[:3]), matrix.col(O.qd.elems[3:])
    O.wd_F1 = O.I_F1.inverse() * (O.nc_F1 - w_F1.cross(O.I_F1 * w_F1))

    # spatial acceleration
    O.as_F1 = O.ac_F1 - w_F1.cross(v_F1) # RBDA Eq. 2.47

    # Kinetic energy, angular velocity (Shabana (2005) p. 148 eq. 3.126)
    #
    O.e_kin_ang = 0.5 * w_F1.dot(O.I_F1 * w_F1)

    # Kinetic energy, linear velocity (Shabana (2005) p. 148 eq. 3.125)
    #
    O.e_kin_lin = 0.5 * O.m * v_F1.dot()

    O.e_kin = O.e_kin_ang + O.e_kin_lin
    O.e_tot = O.e_pot + O.e_kin

  def dynamics_step(O, delta_t, use_classical_accel=False):
    if (use_classical_accel):
      qdd = matrix.col((O.wd_F1, O.ac_F1)).resolve_partitions()
    else:
      qdd = matrix.col((O.wd_F1, O.as_F1)).resolve_partitions()
    O.qd = O.J1.time_step_velocity(O.qd, qdd, delta_t)
    O.J1 = O.J1.time_step_position(O.qd, delta_t)
    O.energies_and_accelerations_update()

class six_dof_joint_euler_params(object):

  def __init__(O, qE, qr):
    O.qE = qE
    O.qr = qr
    #
    O.E = RBDA_Eq_4_12(qE)
    O.r = O.E.transpose() * qr # RBDA Tab. 4.1
    #
    O.Tps = matrix.rt((O.E, -O.E * O.r)) # RBDA Eq. 2.28
    O.Tsp = matrix.rt((O.E.transpose(), O.r))
    # RBDA p. 69, Sec. 4.1.3:
    #   s = frame fixed in successor
    #   p = frame fixed in predecessor

  def time_step_position(O, qd, delta_t):
    w_F1, v_F1 = matrix.col_list([qd.elems[:3], qd.elems[3:]])
    qEd = RBDA_Eq_4_13(O.qE.elems) * w_F1
    qrd = v_F1 - w_F1.cross(O.qr) # RBDA Eq. 2.38 p. 27
    new_qE = (O.qE + qEd * delta_t).normalize() # RBDA, bottom of p. 86
    new_qr = O.qr + qrd * delta_t
    return six_dof_joint_euler_params(new_qE, new_qr)

  def time_step_velocity(O, qd, qdd, delta_t):
    return qd + qdd * delta_t

def RBDA_Eq_4_12(q):
  p0, p1, p2, p3 = q
  return matrix.sqr((
    p0**2+p1**2-0.5,   p1*p2+p0*p3,     p1*p3-p0*p2,
      p1*p2-p0*p3,   p0**2+p2**2-0.5,   p2*p3+p0*p1,
      p1*p3+p0*p2,     p2*p3-p0*p1,   p0**2+p3**2-0.5)) * 2

def RBDA_Eq_4_13(q):
  p0, p1, p2, p3 = q
  return matrix.rec((
    -p1, -p2, -p3,
    p0, -p3, p2,
    p3, p0, -p1,
    -p2, p1, p0), n=(4,3)) * 0.5

def body_inertia(sites_cart):
  m = [0] * 9
  for x,y,z in sites_cart:
    m[0] += y*y+z*z
    m[4] += x*x+z*z
    m[8] += x*x+y*y
    m[1] -= x*y
    m[2] -= x*z
    m[5] -= y*z
  m[3] = m[1]
  m[6] = m[2]
  m[7] = m[5]
  return matrix.sqr(m)

def create_triangle_with_center_of_mass_at_origin():
  sites_cart = matrix.col_list([
    (0,0,0),
    (1,0,0),
    (0.5,0.5*3**0.5,0)])
  com = matrix.col((0,0,0))
  for xyz in sites_cart:
    com += xyz
  com /= len(sites_cart)
  sites_cart = [xyz-com for xyz in sites_cart]
  E = RBDA_Eq_4_12(matrix.col((0.81, -0.32, -0.42, -0.26)).normalize())
  sites_cart = [E*xyz for xyz in sites_cart]
  return sites_cart

def run():
  O = simulation()
  for i_time_step in range(10):
    print("e_kin tot ang lin:", O.e_kin, O.e_kin_ang, O.e_kin_lin)
    print("            e_pot:", O.e_pot)
    print("            e_tot:", O.e_tot)
    print("ang acc 3D:", O.wd_F1.elems)
    print("lin acc 3D:", O.as_F1.elems)
    print()
    O.dynamics_step(delta_t=0.01)
  print("OK")

if (__name__ == "__main__"):
  run()


 *******************************************************************************


 *******************************************************************************
scitbx/rigid_body/proto/joint_lib.py
from __future__ import absolute_import, division, print_function
from scitbx.rigid_body.proto.utils import \
  center_of_mass_from_sites, \
  T_as_X
from scitbx import matrix
import math

class six_dof_alignment(object):

  def __init__(O, sites):
    O.pivot = center_of_mass_from_sites(sites=sites)
    O.normal = None
    O.T0b = matrix.rt(((1,0,0,0,1,0,0,0,1), -O.pivot))
    O.Tb0 = matrix.rt(((1,0,0,0,1,0,0,0,1), O.pivot))

class six_dof(object):

  qd_zero = matrix.zeros(n=6)
  qdd_zero = matrix.zeros(n=6)

  def __init__(O, type, qE, qr, r_is_qr=False):
    assert type in ["euler_params", "euler_angles_xyz"]
    if (type == "euler_params"):
      if (len(qE.elems) == 3):
        qE = euler_angles_xyz_qE_as_euler_params_qE(qE=qE)
    else:
      if (len(qE.elems) == 4):
        qE = euler_params_qE_as_euler_angles_xyz_qE(qE=qE)
    O.type = type
    O.qE = qE
    O.qr = qr
    O.r_is_qr = r_is_qr
    O.q_size = len(qE) + len(qr)
    #
    if (type == "euler_params"):
      O.unit_quaternion = qE.normalize() # RBDA, bottom of p. 86
      O.E = RBDA_Eq_4_12(q=O.unit_quaternion)
    else:
      O.E = RBDA_Eq_4_7(q=qE)
    if (r_is_qr):
      O.r = qr
    else:
      O.r = O.E.transpose() * qr # RBDA Tab. 4.1
    #
    O.Tps = matrix.rt((O.E, -O.E * O.r)) # RBDA Eq. 2.28
    O.Tsp = matrix.rt((O.E.transpose(), O.r))
    O.Xj = T_as_X(O.Tps)
    O.S = None

  def Xj_S(O, q):
    return O.Xj, O.S

  def time_step_position(O, qd, delta_t):
    w_body_frame, v_body_frame = matrix.col_list([qd.elems[:3], qd.elems[3:]])
    if (O.type == "euler_params"):
      qEd = RBDA_Eq_4_13(q=O.unit_quaternion) * w_body_frame
      new_qE = (O.qE + qEd * delta_t).normalize()
    else:
      qEd = RBDA_Eq_4_8_inv(q=O.qE) * w_body_frame
      new_qE = O.qE + qEd * delta_t
    if (O.r_is_qr):
      qrd = O.E.transpose() * v_body_frame
    else:
      qrd = v_body_frame - w_body_frame.cross(O.qr) # RBDA Eq. 2.38 p. 27
    new_qr = O.qr + qrd * delta_t
    return six_dof(type=O.type, qE=new_qE, qr=new_qr, r_is_qr=O.r_is_qr)

  def time_step_velocity(O, qd, qdd, delta_t):
    return qd + qdd * delta_t

  def tau_as_d_pot_d_q(O, tau):
    if (O.type == "euler_params"):
      d = d_unit_quaternion_d_qE_matrix(q=O.qE)
      c = d * 4 * RBDA_Eq_4_13(q=O.unit_quaternion)
    else:
      c = RBDA_Eq_4_8(q=O.qE).transpose()
    n, f = matrix.col_list([tau.elems[:3], tau.elems[3:]])
    if (O.r_is_qr): result = (c * n, O.E.transpose() * f)
    else:           result = (c * (n + O.qr.cross(f)), f)
    return matrix.col(result).resolve_partitions()

  def get_q(O):
    return O.qE.elems + O.qr.elems

  def new_q(O, q):
    i = len(O.qE.elems)
    new_qE, new_qr = matrix.col_list((q[:i], q[i:]))
    return six_dof(type=O.type, qE=new_qE, qr=new_qr, r_is_qr=O.r_is_qr)

class spherical_alignment(object):

  def __init__(O, sites):
    O.pivot = center_of_mass_from_sites(sites=sites)
    O.normal = None
    O.T0b = matrix.rt(((1,0,0,0,1,0,0,0,1), -O.pivot))
    O.Tb0 = matrix.rt(((1,0,0,0,1,0,0,0,1), O.pivot))

class spherical(object):

  qd_zero = matrix.zeros(n=3)
  qdd_zero = matrix.zeros(n=3)

  def __init__(O, type, qE):
    assert type in ["euler_params", "euler_angles_xyz"]
    if (type == "euler_params"):
      if (len(qE.elems) == 3):
        qE = euler_angles_xyz_qE_as_euler_params_qE(qE=qE)
    else:
      if (len(qE.elems) == 4):
        qE = euler_params_qE_as_euler_angles_xyz_qE(qE=qE)
    O.type = type
    O.qE = qE
    O.q_size = len(qE)
    #
    if (type == "euler_params"):
      O.unit_quaternion = qE.normalize() # RBDA, bottom of p. 86
      O.E = RBDA_Eq_4_12(q=O.unit_quaternion)
    else:
      O.E = RBDA_Eq_4_7(q=qE)
    #
    O.Tps = matrix.rt((O.E, (0,0,0)))
    O.Tsp = matrix.rt((O.E.transpose(), (0,0,0)))
    O.Xj = T_as_X(O.Tps)
    O.S = matrix.rec((
      1,0,0,
      0,1,0,
      0,0,1,
      0,0,0,
      0,0,0,
      0,0,0), n=(6,3))

  def Xj_S(O, q):
    return O.Xj, O.S

  def time_step_position(O, qd, delta_t):
    w_body_frame = qd
    if (O.type == "euler_params"):
      qEd = RBDA_Eq_4_13(q=O.unit_quaternion) * w_body_frame
      new_qE = (O.qE + qEd * delta_t).normalize()
    else:
      qEd = RBDA_Eq_4_8_inv(q=O.qE.elems) * w_body_frame
      new_qE = O.qE + qEd * delta_t
    return spherical(type=O.type, qE=new_qE)

  def time_step_velocity(O, qd, qdd, delta_t):
    return qd + qdd * delta_t

  def tau_as_d_pot_d_q(O, tau):
    if (O.type == "euler_params"):
      d = d_unit_quaternion_d_qE_matrix(q=O.qE)
      c = d * 4 * RBDA_Eq_4_13(q=O.unit_quaternion)
    else:
      c = RBDA_Eq_4_8(q=O.qE).transpose()
    n = tau
    return c * n

  def get_q(O):
    return O.qE.elems

  def new_q(O, q):
    return spherical(type=O.type, qE=matrix.col(q))

class revolute_alignment(object):

  def __init__(O, pivot, normal):
    O.pivot = pivot
    O.normal = normal
    r = normal.vector_to_001_rotation()
    O.T0b = matrix.rt((r, -r * pivot))
    O.Tb0 = matrix.rt((r.transpose(), pivot))

class revolute(object):

  qd_zero = matrix.zeros(n=1)
  qdd_zero = matrix.zeros(n=1)

  def __init__(O, qE):
    O.qE = qE
    O.q_size = len(qE)
    #
    c, s = math.cos(qE[0]), math.sin(qE[0])
    O.E = matrix.sqr((c, s, 0, -s, c, 0, 0, 0, 1)) # RBDA Tab. 2.2
    O.r = matrix.col((0,0,0))
    #
    O.Tps = matrix.rt((O.E, (0,0,0)))
    O.Tsp = matrix.rt((O.E.transpose(), (0,0,0)))
    O.Xj = T_as_X(O.Tps)
    O.S = matrix.col((0,0,1,0,0,0))

  def Xj_S(O, q):
    return O.Xj, O.S

  def time_step_position(O, qd, delta_t):
    new_qE = O.qE + qd * delta_t
    return revolute(qE=new_qE)

  def time_step_velocity(O, qd, qdd, delta_t):
    return qd + qdd * delta_t

  def get_q(O):
    return O.qE.elems

  def new_q(O, q):
    return revolute(qE=matrix.col(q))

def RBDA_Eq_4_7(q):
  q1,q2,q3 = q
  def cs(a): return math.cos(a), math.sin(a)
  c1,s1 = cs(q1)
  c2,s2 = cs(q2)
  c3,s3 = cs(q3)
  return matrix.sqr((
              c1*c2,          s1*c2,   -s2,
     c1*s2*s3-s1*c3, s1*s2*s3+c1*c3, c2*s3,
     c1*s2*c3+s1*s3, s1*s2*c3-c1*s3, c2*c3))

def RBDA_Eq_4_8(q):
  q1,q2,q3 = q
  def cs(a): return math.cos(a), math.sin(a)
  c2,s2 = cs(q2)
  c3,s3 = cs(q3)
  return matrix.sqr((
      -s2,   0, 1,
    c2*s3,  c3, 0,
    c2*c3, -s3, 0))

def RBDA_Eq_4_8_inv(q):
  """
  Inverse of RBDA Eq. 4.8 (corresponding to Shabana G^-1)
  Mathematica code:
    ew = {{-s2, 0, 1}, {c2*s3, c3, 0}, {c2*c3, -s3, 0}}
    -Det[ew]
    Simplify[Inverse[ew] * (-Det[ew])]
  """
  q1,q2,q3 = q
  def cs(a): return math.cos(a), math.sin(a)
  c2,s2 = cs(q2)
  c3,s3 = cs(q3)
  if (abs(c2) < 1.e-6):
    raise RuntimeError("Euler angle near singular position.")
  return matrix.sqr((
    0,    s3/c2,    c3/c2,
    0,       c3,      -s3,
    1, s2*s3/c2, c3*s2/c2))

def RBDA_Eq_4_12(q):
  p0, p1, p2, p3 = q
  return matrix.sqr((
    p0**2+p1**2-0.5,   p1*p2+p0*p3,     p1*p3-p0*p2,
      p1*p2-p0*p3,   p0**2+p2**2-0.5,   p2*p3+p0*p1,
      p1*p3+p0*p2,     p2*p3-p0*p1,   p0**2+p3**2-0.5)) * 2

def RBDA_Eq_4_13(q):
  p0, p1, p2, p3 = q
  return matrix.rec((
    -p1, -p2, -p3,
    p0, -p3, p2,
    p3, p0, -p1,
    -p2, p1, p0), n=(4,3)) * 0.5

def d_unit_quaternion_d_qE_matrix(q):
  """
  Coefficent matrix for converting gradients w.r.t. normalized Euler
  parameters to gradients w.r.t. non-normalized parameters, as produced
  e.g. by a minimizer in the line search.
  Mathematica code:
    nsq = p0^2+p1^2+p2^2+p3^2
    p0p = p0 / Sqrt[nsq]
    p1p = p1 / Sqrt[nsq]
    p2p = p2 / Sqrt[nsq]
    p3p = p3 / Sqrt[nsq]
    n3 = (p0^2+p1^2+p2^2+p3^2)^(3/2)
    FortranForm[FullSimplify[D[p0p,p0]*n3]]
    FortranForm[FullSimplify[D[p1p,p0]*n3]]
    FortranForm[FullSimplify[D[p2p,p0]*n3]]
    FortranForm[FullSimplify[D[p3p,p0]*n3]]
    FortranForm[FullSimplify[D[p0p,p1]*n3]]
    FortranForm[FullSimplify[D[p1p,p1]*n3]]
    FortranForm[FullSimplify[D[p2p,p1]*n3]]
    FortranForm[FullSimplify[D[p3p,p1]*n3]]
    FortranForm[FullSimplify[D[p0p,p2]*n3]]
    FortranForm[FullSimplify[D[p1p,p2]*n3]]
    FortranForm[FullSimplify[D[p2p,p2]*n3]]
    FortranForm[FullSimplify[D[p3p,p2]*n3]]
    FortranForm[FullSimplify[D[p0p,p3]*n3]]
    FortranForm[FullSimplify[D[p1p,p3]*n3]]
    FortranForm[FullSimplify[D[p2p,p3]*n3]]
    FortranForm[FullSimplify[D[p3p,p3]*n3]]
  """
  p0,p1,p2,p3 = q
  p0s,p1s,p2s,p3s = p0**2, p1**2, p2**2, p3**2
  n3 = (p0s+p1s+p2s+p3s)**(3/2.)
  c00 = p1s+p2s+p3s
  c11 = p0s+p2s+p3s
  c22 = p0s+p1s+p3s
  c33 = p0s+p1s+p2s
  c01 = -p0*p1
  c02 = -p0*p2
  c03 = -p0*p3
  c12 = -p1*p2
  c13 = -p1*p3
  c23 = -p2*p3
  return matrix.sqr((
    c00, c01, c02, c03,
    c01, c11, c12, c13,
    c02, c12, c22, c23,
    c03, c13, c23, c33)) / n3

def safe_acos(a):
  return math.acos(max(-1, min(1, a)))

def safe_asin(a):
  return math.asin(max(-1, min(1, a)))

def safe_atan2(y, x):
  if (y == 0. and x == 0.): return 0.
  return math.atan2(y, x)

def euler_params_qE_as_euler_angles_xyz_qE(qE):
  p0, p1, p2, p3 = qE
  q2 = safe_asin(-2*(p1*p3-p0*p2))
  c1c2 = p0*p0+p1*p1-0.5
  s1c2 = p1*p2+p0*p3
  q1 = safe_atan2(s1c2, c1c2)
  c2c3 = p0*p0+p3*p3-0.5
  c2s3 = p2*p3+p0*p1
  q3 = safe_atan2(c2s3, c2c3)
  return matrix.col((q1,q2,q3))

def euler_angles_xyz_qE_as_euler_params_qE(qE):
  s1,s2,s3 = [math.sin(q/2.) for q in qE]
  c1,c2,c3 = [math.cos(q/2.) for q in qE]
  return matrix.col((
    c1*c2*c3+s1*s2*s3,
    c1*c2*s3-s1*s2*c3,
    c1*s2*c3+s1*c2*s3,
    s1*c2*c3-c1*s2*s3))


 *******************************************************************************


 *******************************************************************************
scitbx/rigid_body/proto/test_simulation.py
from __future__ import absolute_import, division, print_function
from scitbx.rigid_body.proto import featherstone
from scitbx.rigid_body.proto import test_utils
from scitbx.rigid_body.proto.utils import \
  e_kin_from_model, \
  featherstone_system_model
import scitbx.lbfgs
from scitbx.array_family import flex
from scitbx import matrix
from libtbx.test_utils import approx_equal
from six.moves import range
from six.moves import zip

class simulation(object):

  def __init__(O, bodies):
    O.bodies = bodies
    O.energies_and_accelerations_update()

  def energies_and_accelerations_update(O):
    model = featherstone_system_model(bodies=O.bodies)
    q = [None]*len(O.bodies)
    qd = [B.qd for B in O.bodies]
    #
    O.e_kin = e_kin_from_model(model, q, qd)
    O.e_pot_and_f_ext_update()
    #
    tau = None
    grav_accn = [0,0,0]
    O.qdd = featherstone.FDab(model, q, qd, tau, O.f_ext_bf, grav_accn)

  def e_pot_and_f_ext_update(O):
    O.AJA_accu = []
    O.e_pot = 0
    O.f_ext_bf = []
    for B in O.bodies:
      AJA = B.A.Tb0 * B.J.Tsp * B.A.T0b
      if (B.parent == -1):
        AJA_tree = None
      else:
        AJA_tree = O.AJA_accu[B.parent]
        AJA = AJA_tree * AJA
      O.AJA_accu.append(AJA)
      e_pot_bf = test_utils.potential_energy_bf(
        sites=B.sites, wells=B.wells, A=B.A, J=B.J, AJA_tree=AJA_tree)
      f_ext_using_bf = test_utils.potential_f_ext_bf(
        sites=B.sites, wells=B.wells, A=B.A, J=B.J, AJA_tree=AJA_tree)
      O.f_ext_bf.append(f_ext_using_bf)
      O.e_pot += e_pot_bf
    O.e_tot = O.e_kin + O.e_pot

  def dynamics_step(O, delta_t):
    for B,qdd in zip(O.bodies, O.qdd):
      B.qd = B.J.time_step_velocity(qd=B.qd, qdd=qdd, delta_t=delta_t)
      B.J = B.J.time_step_position(qd=B.qd, delta_t=delta_t)
    O.energies_and_accelerations_update()

  def sensitivity_test(O, n_significant_digits):
    "RBDA section 10.2, p. 199-201"
    model = featherstone_system_model(bodies=O.bodies)
    q = [None]*len(O.bodies)
    qd = [B.qd for B in O.bodies]
    qdd = [matrix.col([1]*len(B.qd)) for B in O.bodies]
    grav_accn = [0,0,0]
    tau = featherstone.ID(model, q, qd, qdd, O.f_ext_bf, grav_accn)
    if (n_significant_digits is not None):
      assert n_significant_digits > 0
      fmt = "%%.%dg" % n_significant_digits
      tau_trunc = []
      for v in tau:
        tau_trunc.append(matrix.col([float(fmt%e) for e in v]))
      tau = tau_trunc
    qdd = featherstone.FDab(model, q, qd, tau, O.f_ext_bf, grav_accn)
    result = []
    for v in qdd: result.extend(v.elems)
    return result

  def d_pot_d_q(O):
    model = featherstone_system_model(bodies=O.bodies)
    q = [None]*len(O.bodies)
    qd = [B.J.qd_zero for B in O.bodies]
    qdd = [B.J.qdd_zero for B in O.bodies]
    grav_accn = [0,0,0]
    taus = featherstone.ID(model, q, qd, qdd, O.f_ext_bf, grav_accn)
    result = []
    for B,tau in zip(O.bodies, taus):
      tau_as_d_pot_d_q = getattr(B.J, "tau_as_d_pot_d_q", None)
      if (tau_as_d_pot_d_q is None):
        result.append(tau)
      else:
        result.append(tau_as_d_pot_d_q(tau=tau))
    return result

  def d_pot_d_q_via_finite_differences(O, eps=1.e-6):
    result = []
    for B in O.bodies:
      gs = []
      J_orig = B.J
      q_orig = list(J_orig.get_q())
      for iq in range(J_orig.q_size):
        fs = []
        for signed_eps in [eps, -eps]:
          q_eps = list(q_orig)
          q_eps[iq] += signed_eps
          B.J = J_orig.new_q(q=q_eps)
          O.e_pot_and_f_ext_update()
          fs.append(O.e_pot)
        gs.append((fs[0]-fs[1])/(2*eps))
      B.J = J_orig
      result.append(matrix.col(gs))
    O.energies_and_accelerations_update()
    return result

  def check_d_pot_d_q(O, verbose=0):
    qdd_orig = O.qdd
    ana = O.d_pot_d_q()
    fin = O.d_pot_d_q_via_finite_differences()
    if (verbose):
      for a,f in zip(ana, fin):
        print("fin:", f.elems)
        print("ana:", a.elems)
      print()
    assert approx_equal(ana, fin)
    assert approx_equal(O.qdd, qdd_orig)

  def minimization(O, max_iterations=None, callback_after_step=None):
    refinery(
      sim=O,
      max_iterations=max_iterations,
      callback_after_step=callback_after_step)

class refinery(object):

  def __init__(O, sim, max_iterations=None, callback_after_step=None):
    O.sim = sim
    O.callback_after_step = callback_after_step
    O.x = flex.double()
    for B in sim.bodies:
      O.x.extend(flex.double(B.J.get_q()))
    scitbx.lbfgs.run(
      target_evaluator=O,
      termination_params=scitbx.lbfgs.termination_parameters(
       max_iterations=max_iterations))
    O.sim.energies_and_accelerations_update()

  def unpack_x(O):
    x = O.x
    i = 0
    for B in O.sim.bodies:
      n = B.J.q_size
      B.J = B.J.new_q(q=x[i:i+n])
      i += n
    assert i == x.size()
    O.sim.e_pot_and_f_ext_update()

  def compute_functional_and_gradients(O):
    O.unpack_x()
    f = O.sim.e_pot
    g = flex.double()
    for d in O.sim.d_pot_d_q():
      g.extend(flex.double(d))
    return f, g


 *******************************************************************************


 *******************************************************************************
scitbx/rigid_body/proto/test_utils.py
from __future__ import absolute_import, division, print_function
from scitbx import matrix
from six.moves import zip

def potential_energy(sites, wells, A, J, AJA_tree=None):
  result = 0
  AJA = A.Tb0 * J.Tsp * A.T0b
  if (AJA_tree is not None): AJA = AJA_tree * AJA
  for s, w in zip(sites, wells):
    result += (AJA * s - w).dot()
  return result

def potential_f_ext_ff(sites, wells, A, J, AJA_tree=None):
  AJA = A.Tb0 * J.Tsp * A.T0b
  if (AJA_tree is not None): AJA = AJA_tree * AJA
  f_cart_ff = [-2 * (AJA * s - w) for s, w in zip(sites, wells)]
  f = matrix.col((0,0,0))
  nc = matrix.col((0,0,0))
  for s,force_ff in zip(sites, f_cart_ff):
    f += force_ff
    nc += (AJA * s).cross(force_ff)
  return matrix.col((nc, f)).resolve_partitions()

def potential_energy_bf(sites, wells, A, J, AJA_tree=None):
  result = 0
  JA = J.Tps * A.T0b
  if (AJA_tree is not None): JA *= AJA_tree.inverse_assuming_orthogonal_r()
  for s, w in zip(sites, wells):
    result += (A.T0b * s - JA * w).dot()
  return result

def potential_f_ext_bf(sites, wells, A, J, AJA_tree=None):
  AJA = A.Tb0 * J.Tsp * A.T0b
  if (AJA_tree is not None): AJA = AJA_tree * AJA
  f_cart_ff = [-2 * (AJA * s - w) for s, w in zip(sites, wells)]
  JAr = J.Tps.r * A.T0b.r
  if (AJA_tree is not None): JAr *= AJA_tree.r.transpose()
  f = matrix.col((0,0,0))
  nc = matrix.col((0,0,0))
  for s,force_ff in zip(sites, f_cart_ff):
    force_bf = JAr * force_ff
    f += force_bf
    nc += (A.T0b * s).cross(force_bf)
  return matrix.col((nc, f)).resolve_partitions()

def create_wells(sites, mersenne_twister, r=None):
  "overall random rotation and translation + noise"
  if (r is None):
    r = matrix.sqr(mersenne_twister.random_double_r3_rotation_matrix())
  t = matrix.col(mersenne_twister.random_double(size=3)-0.5)
  wells = []
  for site in sites:
    t_noise = t + matrix.col(mersenne_twister.random_double(size=3)-0.5)*0.2
    wells.append(r * site + t_noise)
  return wells


 *******************************************************************************


 *******************************************************************************
scitbx/rigid_body/proto/tst_featherstone.py
from __future__ import absolute_import, division, print_function
from six.moves import zip
try:
  import scitbx
except ImportError:
  scitbx = None

if (scitbx is not None):
  from scitbx.rigid_body.proto import featherstone as fs
  from scitbx import matrix
  from libtbx.test_utils import approx_equal
else:
  from scitbx.rigid_body.proto import featherstone as fs
  import scitbx_matrix as matrix
  def approx_equal(a1, a2): return True
  print("libtbx.test_utils not available: approx_equal() disabled")
  def sum(l):
    result = 0
    for e in l: result += e
    return result

import sys

def exercise_basic():
  assert approx_equal(sum(fs.Xrotx(0.1)), 5.98001666111)
  assert approx_equal(sum(fs.Xroty(0.2)), 5.92026631136)
  assert approx_equal(sum(fs.Xrotz(0.3)), 5.8213459565)
  assert approx_equal(sum(fs.Xrot((1,2,3,4,5,6,7,8,9))), 90)
  assert approx_equal(sum(fs.Xtrans((1,2,3))), 6)
  assert approx_equal(sum(fs.crm((1,2,3,4,5,6))), 0)
  assert approx_equal(sum(fs.crf((1,2,3,4,5,6))), 0)
  assert approx_equal(sum(fs.mcI(
    m=1.234,
    c=matrix.col((1,2,3)),
    I=matrix.sym(sym_mat3=(2,3,4,0.1,0.2,0.3)))), 21.306)

def write_matlab_script(label, precision, code):
  with open("tst_featherstone_exercise_%s.m" % label, "w") as f:
    f.write("""\
split_long_rows(0);
output_precision(%d);

%s""" % (precision, code))

def extract_sqr_matrices(s):
  result = []
  elems = []
  for line in s.splitlines():
    if (len(s) == 0): continue
    elems.extend([float(v) for v in line.split()])
    if (len(elems) == 36):
      result.append(matrix.sqr(elems=elems))
      elems = []
  assert len(elems) == 0
  return result

expected_autoTree_I = extract_sqr_matrices("""
       0.0025000   0.0000000   0.0000000   0.0000000  -0.0000000   0.0000000
       0.0000000   0.3345833   0.0000000   0.0000000   0.0000000  -0.5000000
       0.0000000   0.0000000   0.3345833  -0.0000000   0.5000000   0.0000000
       0.0000000   0.0000000  -0.0000000   1.0000000   0.0000000   0.0000000
      -0.0000000   0.0000000   0.5000000   0.0000000   1.0000000   0.0000000
       0.0000000  -0.5000000   0.0000000   0.0000000   0.0000000   1.0000000

       0.0025000   0.0000000   0.0000000   0.0000000  -0.0000000   0.0000000
       0.0000000   0.3345833   0.0000000   0.0000000   0.0000000  -0.5000000
       0.0000000   0.0000000   0.3345833  -0.0000000   0.5000000   0.0000000
       0.0000000   0.0000000  -0.0000000   1.0000000   0.0000000   0.0000000
      -0.0000000   0.0000000   0.5000000   0.0000000   1.0000000   0.0000000
       0.0000000  -0.5000000   0.0000000   0.0000000   0.0000000   1.0000000
""")

def exercise_autoTree():
  write_matlab_script(label="autoTree", precision=7, code="""\
autoTree(2)
""")
  tree = fs.autoTree(nb=2)
  assert tree.NB == 2
  assert tree.pitch == [0, 0]
  assert tree.parent == [-1, 0]
  assert len(tree.Xtree) == 2
  assert len(tree.I) == 2
  expected = extract_sqr_matrices("""
       1   0   0   0   0   0
       0   1   0   0   0   0
       0   0   1   0   0   0
       0   0  -0   1   0   0
      -0   0   0   0   1   0
       0  -0   0   0   0   1

       1   0   0   0   0   0
       0   1   0   0   0   0
       0   0   1   0   0   0
       0   0   0   1   0   0
       0   0   1   0   1   0
       0  -1   0   0   0   1
""")
  assert approx_equal(tree.Xtree, expected)
  assert approx_equal(tree.I, expected_autoTree_I)

def exercise_ID_FDab():
  write_matlab_script(label="ID_FDab", precision=12, code="""\
% modified version of test_FD.m

% test the correctness of FDab, and ID by checking that FDab
% is the inverse of ID.

% step 1: create a complicated kinematic tree, and adjust some of the
% pitches so that it contains helical and prismatic as well as revolute
% joints.

tree = autoTree( 12, 1.5, 1, 0.95 );
tree.pitch(3) = 0.1;
tree.pitch(5) = inf;
tree.pitch(7) = -0.1;
tree.pitch(9) = inf;

% step 2: choose random initial conditions

rand("state", [0]);
q   = pi * (2*rand(12,1) - 1);
qd  = 2*rand(12,1) - 1;
qdd = 2*rand(12,1) - 1;
q
qd
qdd

for i = 1:tree.NB
  f_ext{i} = 2*rand(6,1) - 1;
end
f_ext

grav_accn = 2*rand(3,1) - 1;
grav_accn

% step 3: use ID to calculate the force required to produce qdd; then use
% FDab to calculate the acceleration that this force
% produces.

tau = ID( tree, q, qd, qdd );
qdd_ab = FDab( tree, q, qd, tau );

% step 4: compare results.  In theory, we should have qdd_ab==qdd and
% qdd_crb==qdd.  However, rounding errors will make them slightly
% different.  Expect rounding errors in the vicinity of 1e-14 on this
% test.

tau
qdd_ab

tau = ID( tree, q, qd, qdd, f_ext );
qdd_ab = FDab( tree, q, qd, tau, f_ext );

tau
qdd_ab

tau = ID( tree, q, qd, qdd, f_ext, grav_accn );
qdd_ab = FDab( tree, q, qd, tau, f_ext, grav_accn );

tau
qdd_ab
""")
  tree = fs.autoTree(nb=12, bf=1.5, skew=1, taper=0.95)
  tree.pitch[2] = 0.1
  tree.pitch[4] = fs.Inf
  tree.pitch[6] = -0.1
  tree.pitch[8] = fs.Inf
  q = [
     2.16406631697e+00,
     1.62077531448e+00,
    -4.99063476296e-01,
    -1.51477073237e+00,
     7.08411636458e-02,
    -5.97316430786e-01,
     1.78315912482e+00,
    -1.23582258961e+00,
    -1.47045673813e-01,
     5.23904805187e-01,
     2.56424888393e+00,
     2.94483836087e-02]
  qd = [
    -4.36324311201e-01,
     5.11608408314e-01,
     2.36737993351e-01,
    -4.98987317275e-01,
     8.19492511936e-01,
     9.65570952075e-01,
     6.20434471993e-01,
     8.04331900879e-01,
    -3.79704861361e-01,
     4.59663496520e-01,
     7.97676575936e-01,
     3.67967863831e-01]
  qdd = [
    -5.57145690946e-02,
    -7.98597583863e-01,
    -1.31656329092e-01,
     2.21773946888e-01,
     8.26022106476e-01,
     9.33212735542e-01,
    -4.59804468946e-02,
     7.30619855543e-01,
    -4.79015379216e-01,
     6.10055654026e-01,
     9.73986076712e-02,
    -9.71916599672e-01]
  f_ext_given = [matrix.col(f) for f in [
    [ 4.39409372808e-01,
     -2.02352915551e-01,
      6.49689954296e-01,
      3.36306402464e-01,
     -9.97714361371e-01,
     -1.28442670694e-02],
    [ 7.35205550986e-01,
     -5.12178246226e-01,
     -3.49591274505e-01,
      7.40942464217e-01,
     -6.17865816995e-01,
      1.35021481241e-01],
    [-5.22768142770e-01,
      9.35080500580e-01,
      6.06358938560e-01,
     -1.04060857129e-01,
     -8.39108362895e-01,
     -3.59890790655e-01],
    [ 1.58812850411e-02,
      8.65667648454e-01,
     -7.81884308138e-01,
      1.02534492181e-01,
      4.13122819734e-01,
      9.48818226568e-02],
    [ 6.28933726583e-01,
      8.05672139406e-02,
      9.27677091948e-01,
      2.06371255923e-01,
      1.75234128351e-01,
     -1.10021947449e-01],
    [ 1.92573723166e-01,
     -2.30197708055e-01,
      1.51302028330e-01,
     -4.19340995194e-01,
     -6.21217342891e-01,
     -6.26540943489e-01],
    [ 2.25546359737e-01,
      3.13318777979e-01,
     -4.69380159812e-02,
     -8.20351277609e-01,
      5.15207843933e-01,
      7.53540741646e-01],
    [ 8.46762031893e-01,
      6.84920446280e-01,
      7.96346242716e-01,
      8.46164879640e-01,
      8.11998498961e-02,
     -2.17407899531e-01],
    [ 4.10566799709e-01,
     -4.48731757376e-01,
      6.23257417016e-01,
      6.98971930373e-01,
      7.90077934853e-01,
      1.79602367062e-01],
    [ 8.99529746464e-01,
      1.59390021491e-01,
     -9.88737867377e-02,
      3.20490757245e-01,
      9.92515678707e-01,
      8.33882435895e-01],
    [ 5.86650168260e-01,
     -8.35254023607e-01,
      2.25566210081e-01,
     -2.71115960617e-02,
      2.60294680823e-01,
      6.90155151343e-01],
    [-5.13928755876e-01,
      4.62978441582e-01,
     -7.65731413583e-01,
     -5.59078926264e-01,
      5.89165943421e-01,
     -3.34927701561e-01]]]
  grav_accn_given = [
     6.31826193067e-01,
    -7.98784959568e-01,
    -7.07283022175e-01]
  expected_taus = [
    [-1.07802735301e+01,
     -2.49508384454e+00,
      1.26947454308e+01,
      1.91173545407e+01,
     -2.15095801697e+00,
      4.51666158929e+00,
      4.74401858265e-01,
      2.18443796607e+00,
     -2.16077117905e+00,
      2.83314247697e-01,
     -1.05175849728e-01,
     -1.50102709018e-01],
    [-9.58228539302e+00,
      1.26086473525e+00,
      1.17897084957e+01,
      2.39352891888e+01,
     -2.05738994237e+00,
      3.95457944509e+00,
      1.53558904623e-01,
      1.01233113762e+00,
     -2.34037354611e+00,
      3.82188034435e-01,
     -3.30742059809e-01,
      6.15628704565e-01],
    [-1.50057630860e+01,
     -1.28108933617e+01,
     -3.95574970014e+00,
      6.23340162074e+00,
      3.55385144046e+00,
      1.48006620138e+00,
     -7.33767304124e-01,
     -1.54512467666e-01,
     -8.05660270955e-01,
      3.27795875394e-01,
     -2.60889565195e-01,
      8.55164362101e-01]]
  for f_ext,grav_accn,expected_tau in zip(
       [None, f_ext_given, f_ext_given],
       [None, None, grav_accn_given],
       expected_taus):
    tau = fs.ID(
      model=tree, q=q, qd=qd, qdd=qdd, f_ext=f_ext, grav_accn=grav_accn)
    assert len(tau) == len(expected_tau)
    assert approx_equal([m.elems[0] for m in tau], expected_tau)
    qdd_ab = fs.FDab(
      model=tree, q=q, qd=qd, tau=tau, f_ext=f_ext, grav_accn=grav_accn)
    assert len(qdd_ab) == len(qdd)
    assert approx_equal([m.elems[0] for m in qdd_ab], qdd)

def exercise_standalone(tmpdir="tst_featherstone_tmpdir"):
  from libtbx.utils import copy_file
  import libtbx.load_env
  import os
  if (not os.path.isdir(tmpdir)):
    os.mkdir(tmpdir)
  os.chdir(tmpdir)
  scitbx_dist = libtbx.env.dist_path(module_name="scitbx")
  def cp(file_name, target="."):
    copy_file(os.path.join(scitbx_dist, file_name), target)
  cp("matrix/__init__.py", "scitbx_matrix.py")
  cp("rigid_body/proto/featherstone.py")
  cp("rigid_body/proto/tst_featherstone.py")

def run(args):
  assert len(args) == 0
  exercise_basic()
  exercise_autoTree()
  exercise_ID_FDab()
  if (scitbx is not None):
    exercise_standalone()
  print("OK")

if (__name__ == "__main__"):
  run(sys.argv[1:])


 *******************************************************************************


 *******************************************************************************
scitbx/rigid_body/proto/tst_free_motion.py
from __future__ import absolute_import, division, print_function
from scitbx.rigid_body.proto import free_motion_reference_impl as fmri
from scitbx.rigid_body.proto import featherstone
import scitbx.math
from scitbx.array_family import flex
from scitbx import matrix
from libtbx.test_utils import approx_equal
from libtbx.utils import format_cpu_times, null_out
import sys
from six.moves import range

def exercise_reference_impl_quick():
  sites_cart = fmri.create_triangle_with_center_of_mass_at_origin()
  assert approx_equal(flex.vec3_double(sites_cart).mean(), (0,0,0))
  inertia1 = fmri.body_inertia(sites_cart=sites_cart)
  inertia2 = matrix.sym(sym_mat3=scitbx.math.inertia_tensor(
    points=flex.vec3_double(sites_cart), pivot=(0,0,0)))
  assert approx_equal(inertia1, inertia2)
  #
  for use_classical_accel in [False, True]:
    sim = fmri.simulation()
    assert approx_equal(
      [sim.e_pot, sim.e_kin_ang, sim.e_kin_lin, sim.e_kin, sim.e_tot],
      [0.64030878777041611,
       0.012310594130384761, 0.02835, 0.04066059413038476,
       0.68096938190080092])
    for i in range(100):
      sim.dynamics_step(delta_t=0.01, use_classical_accel=use_classical_accel)
    expected = [
      [0.028505221929112364,
       0.091503230553568404, 0.56329655444242244, 0.65479978499599079,
       0.6833050069251031],
      [0.053276067541032097,
       0.091503230553568404, 0.53805622991666513, 0.62955946047023348,
       0.68283552801126557]][int(use_classical_accel)]
    assert approx_equal(
      [sim.e_pot, sim.e_kin_ang, sim.e_kin_lin, sim.e_kin, sim.e_tot],
      expected)

def exercise_reference_impl_long(n_dynamics_steps, out):
  sim = fmri.simulation()
  e_tots = flex.double([sim.e_tot])
  print("i_step, [e_pot, e_kin_ang, e_kin_lin, e_kin, e_tot]", file=out)
  def show(i_step):
    print(i_step, [sim.e_pot, sim.e_kin_ang, sim.e_kin_lin, sim.e_kin, sim.e_tot], file=out)
    out.flush()
  n_show = max(1, n_dynamics_steps // 10)
  for i_step in range(n_dynamics_steps):
    sim.dynamics_step(delta_t=0.001)
    e_tots.append(sim.e_tot)
    if (i_step % n_show == 0):
      show(i_step)
  show(n_dynamics_steps)
  print(file=out)
  print("number of dynamics steps:", n_dynamics_steps, file=out)
  print("e_tot start:", e_tots[0], file=out)
  print("      final:", e_tots[-1], file=out)
  print("        min:", flex.min(e_tots), file=out)
  print("        max:", flex.max(e_tots), file=out)
  print("    max-min:", flex.max(e_tots) - flex.min(e_tots), file=out)
  print(file=out)
  out.flush()

class featherstone_system_model(object):

  def __init__(model, m, I, J):
    model.NB = 1
    model.pitch = [J]
    model.parent =[-1]
    model.Xtree = [matrix.identity(n=6)]
    model.I = [featherstone.mcI(m, (0,0,0), I)]

class six_dof_joint_euler_params_featherstone(fmri.six_dof_joint_euler_params):

  def Xj_S(O, q):
    assert q is None
    Xj = featherstone.Xrot(O.E) \
       * featherstone.Xtrans(O.r) # RBDA Tab. 4.1 footnote
    S = None
    return Xj, S

def exercise_featherstone_FDab(out):
  def check():
    model = featherstone_system_model(
      m=sim.m,
      I=sim.I_F1,
      J=six_dof_joint_euler_params_featherstone(qE=sim.J1.qE, qr=sim.J1.qr))
    q = [None] # already stored in J1 as qE and qr
    qd = [sim.qd]
    tau = None
    f_ext = [matrix.col((sim.nc_F1, sim.f_F1)).resolve_partitions()]
    grav_accn = [0,0,0]
    qdd = featherstone.FDab(model, q, qd, tau, f_ext, grav_accn)
    if (i_step % 10 == 0):
      print("ang acc 3D:", sim.wd_F1.elems, file=out)
      print("        6D:", qdd[0].elems[:3], file=out)
      print(file=out)
      print("lin acc 3D:", sim.as_F1.elems, file=out)
      print("        6D:", qdd[0].elems[3:], file=out)
      print(file=out)
    assert approx_equal(qdd[0].elems[:3], sim.wd_F1)
    assert approx_equal(qdd[0].elems[3:], sim.as_F1)
  sim = fmri.simulation()
  for i_step in range(100):
    check()
    sim.dynamics_step(delta_t=0.1) # large time step to sample
  check()                          # diverse configurations

def run(args):
  assert len(args) in [0,1]
  if (len(args) == 0):
    n_dynamics_steps = 1
    out = null_out()
  else:
    n_dynamics_steps = max(1, int(args[0]))
    out = sys.stdout
  #
  exercise_reference_impl_quick()
  exercise_featherstone_FDab(out=out)
  exercise_reference_impl_long(n_dynamics_steps=n_dynamics_steps, out=out)
  #
  print(format_cpu_times())

if (__name__ == "__main__"):
  run(sys.argv[1:])


 *******************************************************************************


 *******************************************************************************
scitbx/rigid_body/proto/tst_free_motion_hard.py
from __future__ import absolute_import, division, print_function
from scitbx.rigid_body.proto import featherstone
from scitbx.rigid_body.proto import joint_lib
from scitbx.rigid_body.proto.utils import \
  spatial_inertia_from_sites, \
  kinetic_energy, \
  T_as_X
from scitbx.rigid_body.proto import test_utils
from scitbx.rigid_body.proto.free_motion_reference_impl import \
  create_triangle_with_center_of_mass_at_origin
from scitbx.array_family import flex
from scitbx import matrix
from libtbx.test_utils import approx_equal
from libtbx.utils import null_out, show_times_at_exit
import sys
from six.moves import range
from six.moves import zip

def exercise_euler_params_qE_as_euler_angles_xyz_qE(mersenne_twister):
  for i_trial in range(30):
    qE = matrix.col(mersenne_twister.random_double(size=4)).normalize()
    qr = matrix.col(mersenne_twister.random_double(size=3)-0.5)
    J = joint_lib.six_dof(type="euler_params", qE=qE, qr=qr)
    Jea = joint_lib.six_dof(type="euler_angles_xyz", qE=qE, qr=qr)
    assert approx_equal(Jea.E, J.E)
    assert approx_equal(Jea.r, J.r)
    Jep = joint_lib.six_dof(type="euler_params", qE=Jea.qE, qr=qr)
    assert approx_equal(Jep.E, J.E)
    assert approx_equal(Jep.r, J.r)

def exercise_T_as_X(mersenne_twister):
  for i_trial in range(10):
    T1 = matrix.rt((
      mersenne_twister.random_double_r3_rotation_matrix(),
      mersenne_twister.random_double(size=3)-0.5))
    T2 = matrix.rt((
      mersenne_twister.random_double_r3_rotation_matrix(),
      mersenne_twister.random_double(size=3)-0.5))
    T12 = T1 * T2
    T21 = T2 * T1
    T1i = T1.inverse_assuming_orthogonal_r()
    T2i = T2.inverse_assuming_orthogonal_r()
    X1 = T_as_X(T1)
    X2 = T_as_X(T2)
    X12 = T_as_X(T12)
    X21 = T_as_X(T21)
    X1i = T_as_X(T1i)
    X2i = T_as_X(T2i)
    assert approx_equal(X1*X2, X12)
    assert approx_equal(X2*X1, X21)
    assert approx_equal(X1.inverse(), X1i)
    assert approx_equal(X2.inverse(), X2i)

def create_triangle_with_random_center_of_mass(mersenne_twister):
  sites = create_triangle_with_center_of_mass_at_origin()
  t = matrix.col(mersenne_twister.random_double(size=3)*2-1)
  return [site+t for site in sites]

class featherstone_system_model(object):

  def __init__(model, I, A, J):
    model.NB = 1
    model.pitch = [J]
    model.parent =[-1]
    model.Xtree = [T_as_X(A.T0b)]
    model.I = [I]

class simulation_mixin(object):

  def sites_moved(O):
    AJA = O.A.Tb0 * O.J.Tsp * O.A.T0b
    return [AJA * site for site in O.sites_F0]

  def energies_and_accelerations_update(O):
    if (O.J.S is None):
      v_spatial = O.qd
    else:
      v_spatial = O.J.S * O.qd
    O.e_kin = kinetic_energy(I_spatial=O.I_spatial, v_spatial=v_spatial)
    O.e_pot = test_utils.potential_energy(
      sites=O.sites_F0, wells=O.wells, A=O.A, J=O.J)
    f_ext_ff = test_utils.potential_f_ext_ff(
      sites=O.sites_F0, wells=O.wells, A=O.A, J=O.J)
    O.e_tot = O.e_kin + O.e_pot
    #
    e_pot_bf = test_utils.potential_energy_bf(
      sites=O.sites_F0, wells=O.wells, A=O.A, J=O.J)
    assert approx_equal(e_pot_bf, O.e_pot)
    f_ext_bf = test_utils.potential_f_ext_bf(
      sites=O.sites_F0, wells=O.wells, A=O.A, J=O.J)
    #
    model = featherstone_system_model(I=O.I_spatial, A=O.A, J=O.J)
    #
    q = [None] # already stored in joint as qE and qr
    qd = [O.qd]
    tau = None
    grav_accn = [0,0,0]
    qdd_using_f_ext_ff = featherstone.FDab(
      model, q, qd, tau, [f_ext_ff], grav_accn, f_ext_in_ff=True)
    qdd_using_f_ext_bf = featherstone.FDab(
      model, q, qd, tau, [f_ext_bf], grav_accn, f_ext_in_ff=False)
    assert approx_equal(qdd_using_f_ext_bf, qdd_using_f_ext_ff)
    O.f_ext_bf = f_ext_bf
    O.qdd = qdd_using_f_ext_bf[0]

  def dynamics_step(O, delta_t):
    O.qd = O.J.time_step_velocity(qd=O.qd, qdd=O.qdd, delta_t=delta_t)
    O.J = O.J.time_step_position(qd=O.qd, delta_t=delta_t)
    O.energies_and_accelerations_update()

  def d_pot_d_q(O):
    model = featherstone_system_model(I=O.I_spatial, A=O.A, J=O.J)
    q = [None] # already stored in joint as qE and qr
    qd = [matrix.zeros(n=6)]
    qdd = [matrix.zeros(n=6)]
    grav_accn = [0,0,0]
    tau = featherstone.ID(model, q, qd, qdd, [O.f_ext_bf], grav_accn)[0]
    assert approx_equal(tau, -O.f_ext_bf)
    return O.J.tau_as_d_pot_d_q(tau=tau)

  def d_pot_d_q_via_finite_differences(O, eps=1.e-6):
    result = []
    for q in [O.J.qE, O.J.qr]:
      for i in range(len(q)):
        fs = []
        for signed_eps in [eps, -eps]:
          q_eps = list(q)
          q_eps[i] += signed_eps
          q_eps = matrix.col(q_eps)
          if (q is O.J.qE): qE = q_eps; qr=O.J.qr
          else:             qE = O.J.qE; qr=q_eps
          J = joint_lib.six_dof(
            type=O.J.type, qE=qE, qr=qr, r_is_qr=O.J.r_is_qr)
          e_pot = test_utils.potential_energy(
            sites=O.sites_F0, wells=O.wells, A=O.A, J=J)
          fs.append(e_pot)
        result.append((fs[0]-fs[1])/(2*eps))
    return matrix.col(result)

  def check_d_pot_d_q(O):
    ana = O.d_pot_d_q()
    fin = O.d_pot_d_q_via_finite_differences()
    assert approx_equal(ana, fin)

class six_dof_simulation(simulation_mixin):

  def __init__(O, six_dof_type, r_is_qr, mersenne_twister):
    O.sites_F0 = create_triangle_with_random_center_of_mass(
      mersenne_twister=mersenne_twister)
    O.A = joint_lib.six_dof_alignment(sites=O.sites_F0)
    O.I_spatial = spatial_inertia_from_sites(
      sites=O.sites_F0, alignment_T=O.A.T0b)
    #
    O.wells = test_utils.create_wells(
      sites=O.sites_F0, mersenne_twister=mersenne_twister)
    #
    qE = matrix.col(mersenne_twister.random_double(size=4)).normalize()
    qr = matrix.col(mersenne_twister.random_double(size=3)-0.5)
    if (r_is_qr):
      qr = joint_lib.RBDA_Eq_4_12(qE).transpose() * qr
    O.J = joint_lib.six_dof(type=six_dof_type, qE=qE, qr=qr, r_is_qr=r_is_qr)
    O.qd = matrix.col(mersenne_twister.random_double(size=6)*2-1)
    #
    O.energies_and_accelerations_update()

plot_prefix = 0
plot_number = [0]

def run_simulation(
      out,
      six_dof_type,
      r_is_qr,
      mersenne_twister,
      n_dynamics_steps,
      delta_t):
  sim = six_dof_simulation(
    six_dof_type=six_dof_type,
    r_is_qr=r_is_qr,
    mersenne_twister=mersenne_twister)
  sim_label = 'six_dof(type="%s", r_is_qr=%s)' % (
    six_dof_type, str(sim.J.r_is_qr))
  sim.check_d_pot_d_q()
  sites_moved = [sim.sites_moved()]
  e_pots = flex.double([sim.e_pot])
  e_kins = flex.double([sim.e_kin])
  for i_step in range(n_dynamics_steps):
    sim.dynamics_step(delta_t=delta_t)
    sites_moved.append(sim.sites_moved())
    e_pots.append(sim.e_pot)
    e_kins.append(sim.e_kin)
  e_tots = e_pots + e_kins
  sim.check_d_pot_d_q()
  print(sim_label, file=out)
  print("e_pot min, max:", min(e_pots), max(e_pots), file=out)
  print("e_kin min, max:", min(e_kins), max(e_kins), file=out)
  print("e_tot min, max:", min(e_tots), max(e_tots), file=out)
  print("start e_tot:", e_tots[0], file=out)
  print("final e_tot:", e_tots[-1], file=out)
  ave = flex.sum(e_tots) / e_tots.size()
  range_ = flex.max(e_tots) - flex.min(e_tots)
  relative_range = range_ / ave
  print("ave:", ave, file=out)
  print("range:", range_, file=out)
  print("relative range:", relative_range, file=out)
  print(file=out)
  out.flush()
  if (out is sys.stdout):
    l = sim_label \
      .replace(' ', "") \
      .replace('"', "") \
      .replace("(", "_") \
      .replace(")", "_") \
      .replace(",", "_")
    f = open("tmp_%02d_%02d_%s.xy" % (plot_prefix, plot_number[0], l), "w")
    for es in [e_pots, e_kins, e_tots]:
      for e in es:
        print(e, file=f)
      print("&", file=f)
    f.close()
    plot_number[0] += 1
  return sim, sim_label, sites_moved, e_tots, relative_range

def run_simulations(
      out,
      mersenne_twister,
      n_dynamics_steps,
      delta_t):
  mt_state = mersenne_twister.getstate()
  sim_labels = []
  sites_moved_accu = []
  e_tots_list = []
  relative_ranges = []
  for r_is_qr in [True, False]:
    for six_dof_type in ["euler_params", "euler_angles_xyz"]:
      mersenne_twister.setstate(mt_state)
      sim, sim_label, sites_moved, e_tots, relative_range = run_simulation(
        out=out,
        six_dof_type=six_dof_type,
        r_is_qr=r_is_qr,
        mersenne_twister=mersenne_twister,
        n_dynamics_steps=n_dynamics_steps,
        delta_t=delta_t)
      sim_labels.append(sim_label)
      e_tots_list.append(e_tots)
      sites_moved_accu.append(sites_moved)
      relative_ranges.append(relative_range)
  rms_max_list = flex.double()
  for sim_label,other in zip(sim_labels[1:], sites_moved_accu[1:]):
    print("rms joints %s" % sim_labels[0], file=out)
    print("       vs. %s:" % sim_label, file=out)
    rms = flex.double()
    for sites_ref,sites_other in zip(sites_moved_accu[0], other):
      sites_ref = flex.vec3_double(sites_ref)
      rms.append(sites_ref.rms_difference(flex.vec3_double(sites_other)))
    rms.min_max_mean().show(out=out, prefix="  ")
    rms_max_list.append(flex.max(rms))
    print(file=out)
  out.flush()
  return sim_labels, e_tots_list, relative_ranges, rms_max_list

def exercise_simulation(
      out, n_trials, n_dynamics_steps, delta_t=0.0001, random_seed=0):
  mersenne_twister = flex.mersenne_twister(seed=random_seed)
  sim_labels = None
  relative_ranges_accu = None
  rms_max_list_accu = None
  for i_trial in range(n_trials):
    sim_labels_new, e_tots_list, \
    relative_ranges, rms_max_list = run_simulations(
      out=out,
      mersenne_twister=mersenne_twister,
      n_dynamics_steps=n_dynamics_steps,
      delta_t=delta_t)
    if (sim_labels is None):
      sim_labels = sim_labels_new
    else:
      assert sim_labels == sim_labels_new
    if (relative_ranges_accu is None):
      relative_ranges_accu=[flex.double() for i in range(len(relative_ranges))]
    else:
      assert len(relative_ranges) == len(relative_ranges_accu)
    for r,a in zip(relative_ranges, relative_ranges_accu):
      a.append(r)
    if (rms_max_list_accu is None):
      rms_max_list_accu = [flex.double() for i in range(len(rms_max_list))]
    else:
      assert len(rms_max_list) == len(rms_max_list_accu)
    for r,a in zip(rms_max_list, rms_max_list_accu):
      a.append(r)
    if (out is sys.stdout):
      f = open("tmp_e_tots_%02d_%02d.xy" % (plot_prefix, i_trial), "w")
      print("@with g0", file=f)
      for i,l in enumerate(sim_labels):
        l = l[l.find('"')+1:].replace('"','')[:-1]
        print('@ s%d legend "%s"' % (i, l), file=f)
      for es in e_tots_list:
        for e in es:
          print(e, file=f)
        print("&", file=f)
      f.close()
  print("Accumulated results:", file=out)
  print(file=out)
  for sim_label,accu in zip(sim_labels, relative_ranges_accu):
    print("relative ranges %s:" % sim_label, file=out)
    accu.min_max_mean().show(out=out, prefix="  ")
    print(file=out)
  for sim_label,accu in zip(sim_labels[1:], rms_max_list_accu):
    print("rms max %s" % sim_labels[0], file=out)
    print("    vs. %s:" % sim_label, file=out)
    accu.min_max_mean().show(out=out, prefix="  ")
    print(file=out)
  if (out is not sys.stdout):
    for accu in relative_ranges_accu:
      assert flex.max(accu) < 1.e-4
    for i,accu in enumerate(rms_max_list_accu):
      assert flex.max(accu) < 1.e-4

def run(args):
  assert len(args) in [0,3]
  if (len(args) == 0):
    n_trials = 3
    n_dynamics_steps = 30
    random_seed = 0
    out = null_out()
  else:
    n_trials = max(1, int(args[0]))
    n_dynamics_steps = max(1, int(args[1]))
    random_seed = int(args[2])
    out = sys.stdout
  show_times_at_exit()
  mersenne_twister = flex.mersenne_twister(seed=0)
  exercise_euler_params_qE_as_euler_angles_xyz_qE(
    mersenne_twister=mersenne_twister)
  exercise_T_as_X(mersenne_twister=mersenne_twister)
  global plot_prefix
  plot_prefix = random_seed
  exercise_simulation(
    out=out, n_trials=n_trials, n_dynamics_steps=n_dynamics_steps,
    random_seed=random_seed)
  print("OK")

if (__name__ == "__main__"):
  run(sys.argv[1:])


 *******************************************************************************


 *******************************************************************************
scitbx/rigid_body/proto/tst_joint_lib.py
from __future__ import absolute_import, division, print_function
from scitbx.rigid_body.proto import featherstone
from scitbx.rigid_body.proto import joint_lib
from scitbx.rigid_body.proto.utils import \
  spatial_inertia_from_sites, \
  T_as_X, \
  featherstone_system_model, \
  e_kin_from_model
from scitbx.rigid_body.proto import test_utils
from scitbx.array_family import flex
from scitbx import matrix
from libtbx.test_utils import approx_equal
from libtbx.utils import null_out, show_times_at_exit
import math
import sys
from six.moves import range
from six.moves import zip

class random_revolute(object):

  def __init__(O, mersenne_twister):
    def random_vector():
      return matrix.col(mersenne_twister.random_double(size=3)*2-1)
    def random_angle():
      return (mersenne_twister.random_double()*2-1)*math.pi
    #
    O.sites = [random_vector()]
    for i_trial in range(100): # guard against unlikely singularity
      O.A = joint_lib.revolute_alignment(
        pivot=random_vector(),
        normal=random_vector().normalize())
      if (abs(O.A.normal.cos_angle(O.sites[0] - O.A.pivot)) > 1.e-3):
        break
    else:
      raise RuntimeError
    O.I = spatial_inertia_from_sites(sites=O.sites, alignment_T=O.A.T0b)
    #
    O.wells = [random_vector()]
    #
    O.J = joint_lib.revolute(qE=matrix.col([random_angle()]))
    O.qd = matrix.col([random_angle()])

class revolute_z(object):

  def __init__(O, pivot, x=1/3.):
    O.sites = [matrix.col((x,0,2/3.))+pivot]
    O.A = joint_lib.revolute_alignment(
      pivot=pivot,
      normal=matrix.col((0,0,1)))
    O.I = spatial_inertia_from_sites(sites=O.sites, alignment_T=O.A.T0b)
    O.wells = O.sites
    O.J = joint_lib.revolute(qE=matrix.col([math.pi/8.]))
    O.qd = matrix.col([0])

class revolute_x(object):

  def __init__(O, pivot):
    O.sites = [matrix.col((2/3.,0,1/3.))+pivot]
    O.A = joint_lib.revolute_alignment(
      pivot=pivot,
      normal=matrix.col((1,0,0)))
    O.I = spatial_inertia_from_sites(sites=O.sites, alignment_T=O.A.T0b)
    O.wells = O.sites
    O.J = joint_lib.revolute(qE=matrix.col([math.pi/6.]))
    O.qd = matrix.col([0])

class revolute_simulation(object):

  def __init__(O, mersenne_twister, NB, config):
    O.bodies = []
    if (config == "random"):
      for ib in range(NB):
        B = random_revolute(mersenne_twister=mersenne_twister)
        B.parent = -1+ib
        O.bodies.append(B)
    elif (config == "zigzag"):
      assert NB <= 3
      B = revolute_z(pivot=matrix.col((0,0,0)))
      B.parent = -1
      O.bodies.append(B)
      if (NB > 1):
        B = revolute_x(pivot=matrix.col((0,0,1)))
        B.parent = 0
        O.bodies.append(B)
      if (NB > 2):
        B = revolute_z(pivot=matrix.col((1,0,1)))
        B.parent = 1
        O.bodies.append(B)
    elif (config == "singular"):
      assert NB == 1
      B = revolute_z(pivot=matrix.col((0,0,0)), x=0)
      B.parent = -1
      O.bodies.append(B)
    else:
      raise RuntimeError
    O.energies_and_accelerations_update()

  def energies_and_accelerations_update(O):
    model = featherstone_system_model(bodies=O.bodies)
    q = [None]*len(O.bodies)
    qd = [B.qd for B in O.bodies]
    #
    O.e_kin = e_kin_from_model(model, q, qd)
    O.e_pot_and_f_ext_update()
    #
    tau = None
    grav_accn = [0,0,0]
    qdd_using_f_ext_ff = featherstone.FDab(
      model, q, qd, tau, O.f_ext_ff, grav_accn, f_ext_in_ff=True)
    qdd_using_f_ext_bf = featherstone.FDab(
      model, q, qd, tau, O.f_ext_bf, grav_accn, f_ext_in_ff=False)
    assert approx_equal(qdd_using_f_ext_bf, qdd_using_f_ext_ff)
    O.qdd = qdd_using_f_ext_ff
    #
    X0s = FDab_X0(model, q, qd)
    e_pot_vfy = check_transformations(O.bodies, model.Ttree, X0s)
    assert approx_equal(e_pot_vfy, O.e_pot)

  def e_pot_and_f_ext_update(O):
    O.AJA_accu = []
    O.e_pot = 0
    O.f_ext_ff = []
    O.f_ext_bf = []
    for B in O.bodies:
      AJA = B.A.Tb0 * B.J.Tsp * B.A.T0b
      if (B.parent == -1):
        AJA_tree = None
      else:
        AJA_tree = O.AJA_accu[B.parent]
        AJA = AJA_tree * AJA
      O.AJA_accu.append(AJA)
      e_pot_ff = test_utils.potential_energy(
        sites=B.sites, wells=B.wells, A=B.A, J=B.J, AJA_tree=AJA_tree)
      e_pot_bf = test_utils.potential_energy_bf(
        sites=B.sites, wells=B.wells, A=B.A, J=B.J, AJA_tree=AJA_tree)
      assert approx_equal(e_pot_bf, e_pot_ff)
      f_ext_using_ff = test_utils.potential_f_ext_ff(
        sites=B.sites, wells=B.wells, A=B.A, J=B.J, AJA_tree=AJA_tree)
      f_ext_using_bf = test_utils.potential_f_ext_bf(
        sites=B.sites, wells=B.wells, A=B.A, J=B.J, AJA_tree=AJA_tree)
      O.f_ext_ff.append(f_ext_using_ff)
      O.f_ext_bf.append(f_ext_using_bf)
      O.e_pot += e_pot_ff
    O.e_tot = O.e_kin + O.e_pot

  def dynamics_step(O, delta_t):
    for B,qdd in zip(O.bodies, O.qdd):
      B.qd = B.J.time_step_velocity(qd=B.qd, qdd=qdd, delta_t=delta_t)
      B.J = B.J.time_step_position(qd=B.qd, delta_t=delta_t)
    O.energies_and_accelerations_update()

  def d_pot_d_q(O):
    model = featherstone_system_model(bodies=O.bodies)
    q = [None]*len(O.bodies)
    qd = [matrix.col((0,)) for B in O.bodies]
    qdd = [matrix.col((0,)) for B in O.bodies]
    grav_accn = [0,0,0]
    return featherstone.ID(model, q, qd, qdd, O.f_ext_bf, grav_accn)

  def d_pot_d_q_via_finite_differences(O, eps=1.e-6):
    result = []
    for B in O.bodies:
      fs = []
      J_orig = B.J
      for signed_eps in [eps, -eps]:
        B.J = joint_lib.revolute(qE=matrix.col((J_orig.qE[0]+signed_eps,)))
        O.e_pot_and_f_ext_update()
        fs.append(O.e_pot)
      B.J = J_orig
      result.append(matrix.col(((fs[0]-fs[1])/(2*eps),)))
    O.energies_and_accelerations_update()
    return result

  def check_d_pot_d_q(O):
    qdd_orig = O.qdd
    ana = O.d_pot_d_q()
    fin = O.d_pot_d_q_via_finite_differences()
    assert approx_equal(ana, fin)
    assert approx_equal(O.qdd, qdd_orig)

def FDab_X0(model, q, qd):
  Xup = [None] * model.NB
  X0 = [None] * model.NB
  for i in range(model.NB):
    XJ, S = featherstone.jcalc( model.pitch[i], q[i] )
    Xup[i] = XJ * model.Xtree[i]
    if model.parent[i] == -1:
      X0[i] = Xup[i]
    else:
      X0[i] = Xup[i] * X0[model.parent[i]]
  return X0

def check_transformations(bodies, Ttree, X0s):
  T0s = []
  for B,Tt,X0 in zip(bodies, Ttree, X0s):
    Tj = B.J.Tps
    Tup = Tj * Tt
    if (B.parent == -1):
      T0s.append(Tup)
    else:
      T0s.append(Tup * T0s[B.parent])
    X0_from_T0 = T_as_X(T0s[-1])
    assert approx_equal(X0_from_T0, X0)
  e_pot = 0
  AJA_accu = []
  for B,T0 in zip(bodies, T0s):
    AJA = B.A.Tb0 * B.J.Tsp * B.A.T0b
    if (B.parent == -1):
      AJA_tree = None
      AJA_accu.append(AJA)
    else:
      AJA_tree = AJA_accu[B.parent]
      AJA = AJA_tree * AJA
      AJA_accu.append(AJA)
    for s,w in zip(B.sites, B.wells):
      s_bf = B.A.T0b * s
      s_mv1 = T0.inverse_assuming_orthogonal_r() * s_bf
      s_mv2 = AJA * s
      assert approx_equal(s_mv1, s_mv2)
      e_pot += (s_mv1 - w).dot()
  return e_pot

plot_number = [0]

def exercise_sim(out, n_dynamics_steps, delta_t, sim):
  sim.check_d_pot_d_q()
  e_pots = flex.double([sim.e_pot])
  e_kins = flex.double([sim.e_kin])
  for i_step in range(n_dynamics_steps):
    sim.dynamics_step(delta_t=delta_t)
    e_pots.append(sim.e_pot)
    e_kins.append(sim.e_kin)
  e_tots = e_pots + e_kins
  sim.check_d_pot_d_q()
  print("energy samples:", e_tots.size(), file=out)
  print("e_pot min, max:", min(e_pots), max(e_pots), file=out)
  print("e_kin min, max:", min(e_kins), max(e_kins), file=out)
  print("e_tot min, max:", min(e_tots), max(e_tots), file=out)
  print("start e_tot:", e_tots[0], file=out)
  print("final e_tot:", e_tots[-1], file=out)
  ave = flex.sum(e_tots) / e_tots.size()
  range_ = flex.max(e_tots) - flex.min(e_tots)
  if (ave == 0): relative_range = 0
  else:          relative_range = range_ / ave
  print("ave:", ave, file=out)
  print("range:", range_, file=out)
  print("relative range:", relative_range, file=out)
  print(file=out)
  out.flush()
  if (out is sys.stdout):
    f = open("tmp%02d.xy" % plot_number[0], "w")
    for es in [e_pots, e_kins, e_tots]:
      for e in es:
        print(e, file=f)
      print("&", file=f)
    f.close()
    plot_number[0] += 1
  return relative_range

def exercise_revolute_sim(
      out,
      mersenne_twister,
      n_dynamics_steps,
      delta_t,
      NB,
      config):
  print("config:", config, file=out)
  sim = revolute_simulation(
    mersenne_twister=mersenne_twister,
    NB=NB,
    config=config)
  return exercise_sim(
    out=out, n_dynamics_steps=n_dynamics_steps, delta_t=delta_t, sim=sim)

def exercise_revolute(out, n_trials, n_dynamics_steps, delta_t=0.001, NB=3):
  mersenne_twister = flex.mersenne_twister(seed=0)
  relative_ranges = flex.double()
  for i_trial in range(n_trials):
    relative_ranges.append(exercise_revolute_sim(
      out=out,
      mersenne_twister=mersenne_twister,
      n_dynamics_steps=n_dynamics_steps,
      delta_t=delta_t,
      NB=[1, NB][min(i_trial, 1)],
      config=["singular", "zigzag", "random"][min(i_trial, 2)]))
  print("relative ranges:", file=out)
  relative_ranges.min_max_mean().show(out=out, prefix="  ")
  if (out is not sys.stdout):
    assert flex.max(relative_ranges) < 0.0006
  print(file=out)

def run(args):
  assert len(args) in [0,2]
  if (len(args) == 0):
    n_trials = 3
    n_dynamics_steps = 30
    out = null_out()
  else:
    n_trials = max(1, int(args[0]))
    n_dynamics_steps = max(1, int(args[1]))
    out = sys.stdout
  show_times_at_exit()
  exercise_revolute(
    out=out, n_trials=n_trials, n_dynamics_steps=n_dynamics_steps)
  print("OK")

if (__name__ == "__main__"):
  run(sys.argv[1:])


 *******************************************************************************


 *******************************************************************************
scitbx/rigid_body/proto/tst_molecules.py
from __future__ import absolute_import, division, print_function
from scitbx.rigid_body.proto.tst_joint_lib import exercise_sim
from scitbx.rigid_body.proto import joint_lib
from scitbx.rigid_body.proto.test_simulation import simulation
from scitbx.rigid_body.proto.test_utils import create_wells
from scitbx.rigid_body.proto.utils import spatial_inertia_from_sites
import scitbx.math
from scitbx.array_family import flex
from scitbx import matrix
from libtbx.utils import null_out, show_times_at_exit
import sys
from six.moves import range

def shift_gently(sites, mersenne_twister, angle=5):
  axis = mersenne_twister.random_double_point_on_sphere()
  r = matrix.sqr(scitbx.math.r3_rotation_axis_and_angle_as_matrix(
    axis=axis, angle=angle, deg=True))
  return create_wells(sites=sites, mersenne_twister=mersenne_twister, r=r)

class six_dof_body(object):

  def __init__(O, labels, sites, bonds, mersenne_twister):
    O.labels = labels
    O.sites = sites
    O.bonds = bonds
    O.A = joint_lib.six_dof_alignment(sites=O.sites)
    O.I = spatial_inertia_from_sites(sites=O.sites, alignment_T=O.A.T0b)
    #
    O.wells = shift_gently(sites=O.sites, mersenne_twister=mersenne_twister)
    #
    qE = matrix.col((0,0,0))
    qr = matrix.col((0,0,0))
    O.J = joint_lib.six_dof(type="euler_params", qE=qE, qr=qr, r_is_qr=True)
    O.qd = O.J.qd_zero

class revolute_body(object):

  def __init__(O, labels, sites, bonds, pivot, normal, mersenne_twister):
    O.labels = labels
    O.sites = sites
    O.bonds = bonds
    O.A = joint_lib.revolute_alignment(pivot=pivot, normal=normal)
    O.I = spatial_inertia_from_sites(sites=O.sites, alignment_T=O.A.T0b)
    #
    O.wells = shift_gently(sites=O.sites, mersenne_twister=mersenne_twister)
    #
    O.J = joint_lib.revolute(qE=matrix.col([0]))
    O.qd = O.J.qd_zero

def simulation_zigzag(NB=5):
  mersenne_twister = flex.mersenne_twister(seed=0)
  body = six_dof_body(
    labels=["00", "01", "02"],
    sites=matrix.col_list([
      (0.3,-0.5,0),
      (0.4,0.5,0),
      (0,0,0)]),
    bonds=[(0,2),(1,2)],
    mersenne_twister=mersenne_twister)
  body.parent = -1
  bodies = [body]
  vu = matrix.col((0,1,0)).rotate_around_origin(
    axis=matrix.col((1,0,0)), angle=75, deg=True)
  vr = matrix.col((0,1,0))
  v = vu
  pivot = matrix.col((0,0,0))
  for ib in range(1,NB):
    body = revolute_body(
      labels=[str(ib)],
      sites=[pivot + v*0.5],
      bonds=[(-1,0)],
      pivot=pivot,
      normal=matrix.col((1,0,0)),
      mersenne_twister=mersenne_twister)
    body.parent = ib-1
    bodies.append(body)
    pivot += v
    if (v is vu): v = vr
    else:         v = vu
  return simulation(bodies=bodies)

def pdb_extract(pdb):
  labels, sites = [], []
  for line in pdb.splitlines():
    labels.append(line[22:26].strip()+"."+line[12:16].strip())
    sites.append(matrix.col([float(line[30+i*8:38+i*8]) for i in [0,1,2]]))
  return labels, sites

def simulation_gly_no_h():
  pdb = """\
ATOM      0  N   GLY A   1      10.949  12.815  15.189  0.00  0.00           N
ATOM      1  CA  GLY A   1      10.405  13.954  15.917  0.00  0.00           C
ATOM      2  C   GLY A   1      10.779  15.262  15.227  0.00  0.00           C
ATOM      3  O   GLY A   1       9.916  16.090  14.936  0.00  0.00           O
"""
  labels, sites = pdb_extract(pdb=pdb)
  mersenne_twister = flex.mersenne_twister(seed=0)
  body0 = six_dof_body(
    labels=labels[:3],
    sites=sites[:3],
    bonds=[(0,1),(1,2)],
    mersenne_twister=mersenne_twister)
  body0.parent = -1
  body1 = revolute_body(
    labels=labels[3:],
    sites=sites[3:],
    bonds=[(-1,0)],
    pivot=sites[2],
    normal=(sites[2]-sites[1]).normalize(),
    mersenne_twister=mersenne_twister)
  body1.parent = 0
  return simulation(bodies=[body0, body1])

def simulation_gly_with_nh():
  pdb = """\
ATOM      0  N   GLY A   1      10.949  12.815  15.189  0.00  0.00           N
ATOM      1  CA  GLY A   1      10.405  13.954  15.917  0.00  0.00           C
ATOM      2  C   GLY A   1      10.779  15.262  15.227  0.00  0.00           C
ATOM      3  O   GLY A   1       9.916  16.090  14.936  0.00  0.00           O
ATOM      4  H   GLY A   1      11.792  12.691  15.311  0.00  0.00           H
"""
  labels, sites = pdb_extract(pdb=pdb)
  mersenne_twister = flex.mersenne_twister(seed=0)
  body0 = six_dof_body(
    labels=labels[:3],
    sites=sites[:3],
    bonds=[(0,1),(1,2)],
    mersenne_twister=mersenne_twister)
  body0.parent = -1
  body1 = revolute_body(
    labels=labels[3:4],
    sites=sites[3:4],
    bonds=[(-1,0)],
    pivot=sites[2],
    normal=(sites[2]-sites[1]).normalize(),
    mersenne_twister=mersenne_twister)
  body1.parent = 0
  body2 = revolute_body(
    labels=labels[4:],
    sites=sites[4:],
    bonds=[(-3,0)],
    pivot=sites[0],
    normal=(sites[0]-sites[1]).normalize(),
    mersenne_twister=mersenne_twister)
  body2.parent = 0
  return simulation(bodies=[body0, body1, body2])

def simulation_ala_no_h():
  pdb = """\
ATOM      0  N   ALA A   1      10.949  12.815  15.189  0.00  0.00           N
ATOM      1  CA  ALA A   1      10.405  13.954  15.917  0.00  0.00           C
ATOM      2  C   ALA A   1      10.779  15.262  15.227  0.00  0.00           C
ATOM      3  CB  ALA A   1      10.908  13.950  17.351  0.00  0.00           C
ATOM      4  O   ALA A   1       9.916  16.090  14.936  0.00  0.00           O
"""
  labels, sites = pdb_extract(pdb=pdb)
  mersenne_twister = flex.mersenne_twister(seed=0)
  body0 = six_dof_body(
    labels=labels[:4],
    sites=sites[:4],
    bonds=[(0,1),(1,2),(1,3)],
    mersenne_twister=mersenne_twister)
  body0.parent = -1
  body1 = revolute_body(
    labels=labels[4:],
    sites=sites[4:],
    bonds=[(-2,0)],
    pivot=sites[2],
    normal=(sites[2]-sites[1]).normalize(),
    mersenne_twister=mersenne_twister)
  body1.parent = 0
  return simulation(bodies=[body0, body1])

def simulation_ala_with_h():
  pdb = """\
ATOM      0  N   ALA A   1      10.949  12.815  15.189  0.00  0.00           N
ATOM      1  CA  ALA A   1      10.405  13.954  15.917  0.00  0.00           C
ATOM      2  C   ALA A   1      10.779  15.262  15.227  0.00  0.00           C
ATOM      3  HA  ALA A   1       9.428  13.887  15.936  0.00  0.00           H
ATOM      4  O   ALA A   1       9.916  16.090  14.936  0.00  0.00           O
ATOM      5  H   ALA A   1      11.792  12.691  15.311  0.00  0.00           H
ATOM      6  CB  ALA A   1      10.908  13.950  17.351  0.00  0.00           C
ATOM      7  HB1 ALA A   1      10.627  13.138  17.778  0.00  0.00           H
ATOM      8  HB2 ALA A   1      10.540  14.707  17.813  0.00  0.00           H
ATOM      9  HB3 ALA A   1      11.867  14.004  17.346  0.00  0.00           H
"""
  labels, sites = pdb_extract(pdb=pdb)
  mersenne_twister = flex.mersenne_twister(seed=0)
  body0 = six_dof_body(
    labels=labels[:4],
    sites=sites[:4],
    bonds=[(0,1),(1,2),(1,3)],
    mersenne_twister=mersenne_twister)
  body0.parent = -1
  body1 = revolute_body(
    labels=labels[4:5],
    sites=sites[4:5],
    bonds=[(-2,0)],
    pivot=sites[2],
    normal=(sites[2]-sites[1]).normalize(),
    mersenne_twister=mersenne_twister)
  body1.parent = 0
  body2 = revolute_body(
    labels=labels[5:6],
    sites=sites[5:6],
    bonds=[(-4,0)],
    pivot=sites[0],
    normal=(sites[0]-sites[1]).normalize(),
    mersenne_twister=mersenne_twister)
  body2.parent = 0
  body3 = revolute_body(
    labels=labels[6:],
    sites=sites[6:],
    bonds=[(-3,0),(0,1),(0,2),(0,3)],
    pivot=sites[6],
    normal=(sites[6]-sites[1]).normalize(),
    mersenne_twister=mersenne_twister)
  body3.parent = 0
  return simulation(bodies=[body0, body1, body2, body3])

def simulation_tyr_with_h():
  pdb = """\
ATOM      0  CG  TYR A   1      11.007   9.417   9.446  1.00  0.79           C
ATOM      1  CD1 TYR A   1       9.923  10.155   8.940  1.00  1.42           C
ATOM      2  CD2 TYR A   1      10.765   8.288  10.238  1.00  1.41           C
ATOM      3  CE1 TYR A   1       8.612   9.760   9.229  1.00  1.61           C
ATOM      4  CE2 TYR A   1       9.453   7.895  10.525  1.00  1.42           C
ATOM      5  CZ  TYR A   1       8.377   8.631  10.021  1.00  1.11           C
ATOM      6  HD1 TYR A   1      10.092  11.024   8.328  1.00  2.14           H
ATOM      7  HD2 TYR A   1      11.596   7.718  10.630  1.00  2.21           H
ATOM      8  HE1 TYR A   1       7.780  10.329   8.841  1.00  2.44           H
ATOM      9  HE2 TYR A   1       9.270   7.023  11.135  1.00  2.13           H
ATOM     10  OH  TYR A   1       7.083   8.244  10.304  1.00  1.32           O
ATOM     11  HH  TYR A   1       6.494   8.723   9.717  1.00  2.00           H
ATOM     12  CB  TYR A   1      12.440   9.818   9.148  1.00  0.74           C
ATOM     13  HB2 TYR A   1      12.827   9.193   8.358  1.00  0.78           H
ATOM     14  HB3 TYR A   1      13.036   9.677  10.037  1.00  0.78           H
ATOM     15  N   TYR A   1      11.593  12.101   9.550  1.00  0.82           N
ATOM     16  CA  TYR A   1      12.527  11.286   8.721  1.00  0.75           C
ATOM     17  C   TYR A   1      12.160  11.413   7.239  1.00  0.76           C
ATOM     18  HA  TYR A   1      13.536  11.638   8.870  1.00  0.85           H
ATOM     19  O   TYR A   1      12.298  12.462   6.643  1.00  0.83           O
ATOM     20  H   TYR A   1      10.948  12.701   9.122  1.00  0.88           H
"""
  labels, sites = pdb_extract(pdb=pdb)
  mersenne_twister = flex.mersenne_twister(seed=0)
  body0 = six_dof_body(
    labels=labels[:11],
    sites=sites[:11],
    bonds=[(0,1),(0,2),(1,3),(2,4),(3,5),(4,5),(5,10),(1,6),(2,7),(3,8),(4,9)],
    mersenne_twister=mersenne_twister)
  body0.parent = -1
  body1 = revolute_body(
    labels=labels[11:12],
    sites=sites[11:12],
    bonds=[(-1,0)],
    pivot=sites[10],
    normal=(sites[10]-sites[5]).normalize(),
    mersenne_twister=mersenne_twister)
  body1.parent = 0
  body2 = revolute_body(
    labels=labels[12:15],
    sites=sites[12:15],
    bonds=[(-11,0),(0,1),(0,2)],
    pivot=sites[12],
    normal=(sites[12]-sites[0]).normalize(),
    mersenne_twister=mersenne_twister)
  body2.parent = 0
  body3 = revolute_body(
    labels=labels[15:19],
    sites=sites[15:19],
    bonds=[(-3,1),(0,1),(1,2),(1,3)],
    pivot=sites[16],
    normal=(sites[16]-sites[12]).normalize(),
    mersenne_twister=mersenne_twister)
  body3.parent = 2
  body4 = revolute_body(
    labels=labels[19:20],
    sites=sites[19:20],
    bonds=[(-2,0)],
    pivot=sites[17],
    normal=(sites[17]-sites[16]).normalize(),
    mersenne_twister=mersenne_twister)
  body4.parent = 3
  body5 = revolute_body(
    labels=labels[20:21],
    sites=sites[20:21],
    bonds=[(-4,0)],
    pivot=sites[15],
    normal=(sites[15]-sites[16]).normalize(),
    mersenne_twister=mersenne_twister)
  body5.parent = 3
  return simulation(bodies=[body0, body1, body2, body3, body4, body5])

simulation_factories = [
  simulation_zigzag,
  simulation_gly_no_h,
  simulation_gly_with_nh,
  simulation_ala_no_h,
  simulation_ala_with_h,
  simulation_tyr_with_h]

def exercise_dynamics_quick(
      out,
      sim,
      n_dynamics_steps,
      delta_t=0.001,
      sensitivity_n_significant_digits=3):
  relative_range = exercise_sim(
    out=out, n_dynamics_steps=n_dynamics_steps, delta_t=delta_t, sim=sim)
  if (out is not sys.stdout):
    assert relative_range < 1.e-4
  print("Sensitivity test (%d significant digits):" \
    % sensitivity_n_significant_digits, file=out)
  qdd = sim.sensitivity_test(
    n_significant_digits=sensitivity_n_significant_digits)
  flex.double(qdd).min_max_mean().show(out=out, prefix=" ")
  print(file=out)

def exercise_minimization_quick(out, sim, max_iterations=3):
  print("Minimization:", file=out)
  print("  start e_pot:", sim.e_pot, file=out)
  e_pot_start = sim.e_pot
  sim.minimization(max_iterations=max_iterations)
  print("  final e_pot:", sim.e_pot, file=out)
  e_pot_final = sim.e_pot
  if (out is not sys.stdout):
    assert e_pot_final < e_pot_start * 0.9
  print(file=out)

def run(args):
  assert len(args) in [0,1]
  if (len(args) == 0):
    n_dynamics_steps = 30
    out = null_out()
  else:
    n_dynamics_steps = max(1, int(args[0]))
    out = sys.stdout
  show_times_at_exit()
  for sim_factory in simulation_factories:
    sim = sim_factory()
    exercise_dynamics_quick(
      out=out, sim=sim, n_dynamics_steps=n_dynamics_steps)
    exercise_minimization_quick(out=out, sim=sim)
  print("OK")

if (__name__ == "__main__"):
  run(sys.argv[1:])


 *******************************************************************************


 *******************************************************************************
scitbx/rigid_body/proto/tst_singular.py
from __future__ import absolute_import, division, print_function
from scitbx.rigid_body.proto.tst_joint_lib import exercise_sim
from scitbx.rigid_body.proto import joint_lib
from scitbx.rigid_body.proto.test_simulation import simulation
from scitbx.rigid_body.proto.test_utils import create_wells
from scitbx.rigid_body.proto.utils import spatial_inertia_from_sites
from scitbx.array_family import flex
from scitbx import matrix
from libtbx.utils import null_out, show_times_at_exit
import math
import sys
from six.moves import range

class six_dof_body(object):

  def __init__(O, mersenne_twister, n_sites):
    if (n_sites > 0):
      O.sites = [matrix.col(mersenne_twister.random_double_point_on_sphere())]
    while (len(O.sites) != n_sites):
      O.sites.append(O.sites[0]
        + matrix.col(mersenne_twister.random_double_point_on_sphere()))
    O.A = joint_lib.six_dof_alignment(sites=O.sites)
    O.I = spatial_inertia_from_sites(sites=O.sites, alignment_T=O.A.T0b)
    #
    O.wells = create_wells(sites=O.sites, mersenne_twister=mersenne_twister)
    #
    qE = matrix.col(mersenne_twister.random_double(size=4)).normalize()
    qr = matrix.col(mersenne_twister.random_double(size=3)-0.5)
    O.J = joint_lib.six_dof(type="euler_params", qE=qE, qr=qr, r_is_qr=True)
    O.qd = matrix.col(mersenne_twister.random_double(size=6)*2-1)

class spherical_body(object):

  def __init__(O, mersenne_twister, n_sites):
    if (n_sites > 0):
      O.sites = [matrix.col(mersenne_twister.random_double_point_on_sphere())]
    while (len(O.sites) != n_sites):
      O.sites.append(O.sites[0]
        + matrix.col(mersenne_twister.random_double_point_on_sphere()))
    O.A = joint_lib.spherical_alignment(sites=O.sites)
    O.I = spatial_inertia_from_sites(sites=O.sites, alignment_T=O.A.T0b)
    #
    O.wells = create_wells(sites=O.sites, mersenne_twister=mersenne_twister)
    #
    qE = matrix.col(mersenne_twister.random_double(size=4)).normalize()
    O.J = joint_lib.spherical(type="euler_params", qE=qE)
    O.qd = matrix.col(mersenne_twister.random_double(size=3)*2-1)

class revolute_body(object):

  def __init__(O, mersenne_twister, prev=None):
    if (prev is None):
      normal = matrix.col(mersenne_twister.random_double_point_on_sphere())
      pivot = matrix.col(mersenne_twister.random_double_point_on_sphere()) * 0.6
    else:
      normal = prev.A.normal
      pivot = prev.A.pivot + normal * 0.3
    O.sites = [pivot + normal * (-0.8)]
    O.A = joint_lib.revolute_alignment(pivot=pivot, normal=normal)
    O.I = spatial_inertia_from_sites(sites=O.sites, alignment_T=O.A.T0b)
    #
    O.wells = create_wells(sites=O.sites, mersenne_twister=mersenne_twister)
    #
    O.J = joint_lib.revolute(qE=matrix.col([math.pi/8]))
    O.qd = matrix.col([math.pi/12])

def exercise_six_dof(out, n_trials, n_dynamics_steps, delta_t=0.001):
  mersenne_twister = flex.mersenne_twister(seed=0)
  for n_sites in range(1,4):
    for i_trial in range(n_trials):
      body = six_dof_body(mersenne_twister=mersenne_twister, n_sites=n_sites)
      body.parent = -1
      sim = simulation(bodies=[body])
      print("six_dof number of sites:", n_sites, file=out)
      relative_range = exercise_sim(
        out=out, n_dynamics_steps=n_dynamics_steps, delta_t=delta_t, sim=sim)
      if (out is not sys.stdout):
        assert relative_range < 1.e-4

def exercise_six_dof2(out, n_trials, n_dynamics_steps, delta_t=0.001):
  mersenne_twister = flex.mersenne_twister(seed=1)
  for n_sites in range(1,4):
    for i_trial in range(n_trials):
      body1 = six_dof_body(mersenne_twister=mersenne_twister, n_sites=n_sites)
      body1.parent = -1
      body2 = six_dof_body(mersenne_twister=mersenne_twister, n_sites=n_sites)
      body2.parent = 0
      sim = simulation(bodies=[body1, body2])
      print("six_dof2 number of sites:", n_sites, file=out)
      relative_range = exercise_sim(
        out=out, n_dynamics_steps=n_dynamics_steps, delta_t=delta_t, sim=sim)
      if (out is not sys.stdout):
        assert relative_range < 1.e-4

def exercise_revolute(out, n_trials, n_dynamics_steps, delta_t=0.001):
  mersenne_twister = flex.mersenne_twister(seed=0)
  for i_trial in range(n_trials):
    body = revolute_body(mersenne_twister=mersenne_twister)
    body.parent = -1
    sim = simulation(bodies=[body])
    print("revolute:", file=out)
    relative_range = exercise_sim(
      out=out, n_dynamics_steps=n_dynamics_steps, delta_t=delta_t, sim=sim)
    if (out is not sys.stdout):
      assert relative_range < 1.e-4

def exercise_revolute2(out, n_trials, n_dynamics_steps, delta_t=0.001):
  mersenne_twister = flex.mersenne_twister(seed=0)
  for i_trial in range(n_trials):
    body1 = revolute_body(mersenne_twister=mersenne_twister)
    body1.parent = -1
    body2 = revolute_body(mersenne_twister=mersenne_twister, prev=body1)
    body2.parent = 0
    sim = simulation(bodies=[body1, body2])
    print("revolute2:", file=out)
    relative_range = exercise_sim(
      out=out, n_dynamics_steps=n_dynamics_steps, delta_t=delta_t, sim=sim)
    if (out is not sys.stdout):
      assert relative_range < 1.e-4

def exercise_spherical(out, n_trials, n_dynamics_steps, delta_t=0.001):
  mersenne_twister = flex.mersenne_twister(seed=0)
  for n_sites in range(1,3):
    for i_trial in range(n_trials):
      body = spherical_body(mersenne_twister=mersenne_twister, n_sites=n_sites)
      body.parent = -1
      sim = simulation(bodies=[body])
      print("spherical number of sites:", n_sites, file=out)
      relative_range = exercise_sim(
        out=out, n_dynamics_steps=n_dynamics_steps, delta_t=delta_t, sim=sim)
      if (out is not sys.stdout):
        assert relative_range < 1.e-4

def run(args):
  assert len(args) in [0,2]
  if (len(args) == 0):
    n_trials = 3
    n_dynamics_steps = 30
    out = null_out()
  else:
    n_trials = max(1, int(args[0]))
    n_dynamics_steps = max(1, int(args[1]))
    out = sys.stdout
  show_times_at_exit()
  if (1):
    exercise_six_dof(
      out=out, n_trials=n_trials, n_dynamics_steps=n_dynamics_steps)
  if (1):
    exercise_six_dof2(
      out=out, n_trials=n_trials, n_dynamics_steps=n_dynamics_steps)
  if (1):
    exercise_spherical(
      out=out, n_trials=n_trials, n_dynamics_steps=n_dynamics_steps)
  if (1):
    exercise_revolute(
      out=out, n_trials=n_trials, n_dynamics_steps=n_dynamics_steps)
  if (1):
    exercise_revolute2(
      out=out, n_trials=n_trials, n_dynamics_steps=n_dynamics_steps)
  print("OK")

if (__name__ == "__main__"):
  run(sys.argv[1:])


 *******************************************************************************


 *******************************************************************************
scitbx/rigid_body/proto/tst_spherical_refinement.py
from __future__ import absolute_import, division, print_function
from scitbx.rigid_body.proto import joint_lib
from scitbx.rigid_body.proto import test_utils
from scitbx.rigid_body.proto.utils import center_of_mass_from_sites
import scitbx.lbfgs
import scitbx.math
from scitbx.array_family import flex
from scitbx import matrix
from libtbx.test_utils import approx_equal
from libtbx.utils import null_out, show_times_at_exit
from libtbx.str_utils import show_sorted_by_counts
import math
import sys
from six.moves import range

class setT_mixin(object):

  def setT(O):
    O.Tps = matrix.rt((O.E, (0,0,0)))
    O.Tsp = matrix.rt((O.E.transpose(), (0,0,0)))

class euler_params(setT_mixin):

  def __init__(O, qE):
    if (qE is None): qE = matrix.col((1,0,0,0))
    O.qE = qE
    O.unit_quaternion = qE.normalize()
    O.E = joint_lib.RBDA_Eq_4_12(q=O.unit_quaternion)
    O.setT()

  def tau_as_d_pot_d_q(O, tau):
    d = joint_lib.d_unit_quaternion_d_qE_matrix(q=O.qE)
    c = d * 4 * joint_lib.RBDA_Eq_4_13(q=O.unit_quaternion)
    n = tau
    return c * n

class euler_angles_xyz(setT_mixin):

  def __init__(O, qE):
    if (qE is None): qE = matrix.col((0,0,0))
    O.qE = qE
    O.E = joint_lib.RBDA_Eq_4_7(q=qE)
    O.setT()

  def tau_as_d_pot_d_q(O, tau):
    c = joint_lib.RBDA_Eq_4_8(q=O.qE).transpose()
    n = tau
    return c * n

class euler_angles_zxz(setT_mixin):

  def __init__(O, qE):
    if (qE is None): qE = matrix.col((0,0,0))
    O.qE = qE
    O.E = euler_angles_zxz_matrix(q=qE)
    O.setT()

  def tau_as_d_pot_d_q(O, tau):
    c = euler_angles_zxz_S(q=O.qE).transpose()
    n = tau
    return c * n

class euler_angles_yxyz(setT_mixin):

  def __init__(O, qE):
    if (qE is None): qE = matrix.col((0,0,0,0))
    O.qE = qE
    O.E = euler_angles_yxyz_matrix(q=qE)
    O.setT()

class euler_angles_xyzy(setT_mixin):

  def __init__(O, qE):
    if (qE is None): qE = matrix.col((0,0,0,0))
    O.qE = qE
    O.E = euler_angles_xyzy_matrix(q=qE)
    O.setT()

class inf_euler_params(setT_mixin):

  def __init__(O, qE):
    if (qE is None): qE = matrix.col((0,0,0))
    O.qE = qE
    th = abs(qE)
    if (th == 0):
      p = matrix.col((1,0,0,0))
    else:
      p0 = math.cos(th)
      p1, p2, p3 = math.sin(th) / th * qE
      p = matrix.col((p0,p1,p2,p3))
      assert abs(abs(p)-1) < 1.e-12
    O.E = joint_lib.RBDA_Eq_4_12(q=p)
    O.setT()

class inf_axis_angle(setT_mixin):

  def __init__(O, qE):
    if (qE is None): qE = matrix.col((0,0,0))
    O.qE = qE
    angle = abs(qE)
    if (angle == 0):
      O.E = matrix.sqr((1,0,0,0,1,0,0,0,1))
    else:
      axis = qE / angle
      O.E = matrix.sqr(scitbx.math.r3_rotation_axis_and_angle_as_matrix(
        axis=axis, angle=angle, deg=False))
    O.setT()

def euler_angles_zxz_matrix(q):
  q1,q2,q3 = q
  def cs(a): return math.cos(a), math.sin(a)
  c1,s1 = cs(q1)
  c2,s2 = cs(q2)
  c3,s3 = cs(q3)
  """
  Mathematica code:
    rz1 = {{c1, s1, 0}, {-s1, c1, 0}, {0, 0, 1}}
    rx2 = {{1, 0, 0}, {0, c2, s2}, {0, -s2, c2}}
    rz3 = {{c3, s3, 0}, {-s3, c3, 0}, {0, 0, 1}}
    rz3.rx2.rz1
    Same as Goldstein Eq. 4.46
  """
  return matrix.sqr((
    c1*c3-c2*s1*s3, c3*s1+c1*c2*s3, s2*s3,
    -c2*c3*s1-c1*s3, c1*c2*c3-s1*s3, c3*s2,
    s1*s2, -c1*s2, c2))

def euler_angles_zxz_S(q):
  q1,q2,q3 = q
  def cs(a): return math.cos(a), math.sin(a)
  c2,s2 = cs(q2)
  c3,s3 = cs(q3)
  # see RBDA p. 85, text after Eq. 4.8
  return matrix.sqr((
    s2*s3,  c3, 0,
    c3*s2, -s3, 0,
       c2,   0, 1))

def euler_angles_yxyz_matrix(q):
  q1,q2,q3,q4 = q
  def cs(a): return math.cos(a), math.sin(a)
  c1,s1 = cs(q1)
  c2,s2 = cs(q2)
  c3,s3 = cs(q3)
  c4,s4 = cs(q4)
  """
  Mathematica code:
    rz1 = {{c1, s1, 0}, {-s1, c1, 0}, {0, 0, 1}}
    ry2 = {{c2, 0, -s2}, {0, 1, 0}, {s2, 0, c2}}
    rx3 = {{1, 0, 0}, {0, c3, s3}, {0, -s3, c3}}
    ry4 = {{c4, 0, -s4}, {0, 1, 0}, {s4, 0, c4}}
    ry4.rx3.ry2.rz1
  """
  return matrix.sqr((
    -(s1*s3*s4)+c1*(c2*c4-c3*s2*s4),
    c1*s3*s4+s1*(c2*c4-c3*s2*s4),
    -(c4*s2)-c2*c3*s4,
    -(c3*s1)+c1*s2*s3,
    c1*c3+s1*s2*s3,
    c2*s3,
    c4*s1*s3+c1*(c3*c4*s2+c2*s4),
    -(c1*c4*s3)+s1*(c3*c4*s2+c2*s4),
    c2*c3*c4-s2*s4))

def euler_angles_xyzy_matrix(q):
  q1,q2,q3,q4 = q
  def cs(a): return math.cos(a), math.sin(a)
  c1,s1 = cs(q1)
  c2,s2 = cs(q2)
  c3,s3 = cs(q3)
  c4,s4 = cs(q4)
  """
  Mathematica code:
    ry1 = {{c1, 0, -s1}, {0, 1, 0}, {s1, 0, c1}}
    rz2 = {{c2, s2, 0}, {-s2, c2, 0}, {0, 0, 1}}
    ry3 = {{c3, 0, -s3}, {0, 1, 0}, {s3, 0, c3}}
    rx4 = {{1, 0, 0}, {0, c4, s4}, {0, -s4, c4}}
    rx4.ry3.rz2.ry1
  """
  return matrix.sqr((
    c1*c2*c3-s1*s3,
    c3*s2,
    -(c2*c3*s1)-c1*s3,
    c3*s1*s4+c1*(-(c4*s2)+c2*s3*s4),
    c2*c4+s2*s3*s4,
    c1*c3*s4-s1*(-(c4*s2)+c2*s3*s4),
    c3*c4*s1+c1*(c2*c4*s3+s2*s4),
    c4*s2*s3-c2*s4,
    c1*c3*c4-s1*(c2*c4*s3+s2*s4)))

class body_with_spherical_joint(object):

  def __init__(O, sites, wells, spherical_type):
    O.sites = sites
    O.A = joint_lib.spherical_alignment(sites=O.sites)
    O.wells = wells
    O.spherical_type = spherical_type
    O.J = spherical_type(qE=None)

  def d_pot_d_q_via_finite_differences(O, J=None, eps=1.e-6):
    if (J is None): J = O.J
    result = []
    q = J.qE
    for i in range(len(q)):
      fs = []
      for signed_eps in [eps, -eps]:
        q_eps = list(q)
        q_eps[i] += signed_eps
        q_eps = matrix.col(q_eps)
        J = O.spherical_type(qE=q_eps)
        e_pot = test_utils.potential_energy(
          sites=O.sites, wells=O.wells, A=O.A, J=J)
        fs.append(e_pot)
      result.append((fs[0]-fs[1])/(2*eps))
    return matrix.col(result)

  def d_pot_d_q(O, J=None):
    if (J is None): J = O.J
    f_ext_bf = test_utils.potential_f_ext_bf(
      sites=O.sites, wells=O.wells, A=O.A, J=J)
    tau = matrix.col((-f_ext_bf).elems[:3])
    return J.tau_as_d_pot_d_q(tau=tau)

  def compute_functional_and_gradients(O, qE, use_analytical_gradients):
    J = O.spherical_type(qE=qE)
    f = test_utils.potential_energy(
      sites=O.sites, wells=O.wells, A=O.A, J=J)
    fin = O.d_pot_d_q_via_finite_differences(J=J)
    if (use_analytical_gradients):
      ana = O.d_pot_d_q(J=J)
      assert approx_equal(ana, fin, eps=1.e-4)
      g = ana
    else:
      g = fin
    return f, g

class refinery(object):

  def __init__(O, spherical_type_info, sites, wells, out):
    O.spherical_type_info = spherical_type_info
    O.body = body_with_spherical_joint(
      spherical_type=spherical_type_info.type, sites=sites, wells=wells)
    O.x = flex.double(O.body.J.qE)
    minimizer = scitbx.lbfgs.run(target_evaluator=O)
    f, g = O.compute_functional_and_gradients()
    label = str(O.spherical_type_info)
    print(label, \
      "functional: %12.6g" % f, \
      "gradient norm: %12.6g" % g.norm(), \
      "iter: %3d" % minimizer.iter(), \
      "nfun: %3d" % minimizer.nfun(), file=out)
    O.failed = (f > 1.e-3)
    if (O.failed): print("               FAILED", label, f, file=out)
    sys.stdout.flush()
    O.nfun = minimizer.nfun()

  def compute_functional_and_gradients(O):
    f, g = O.body.compute_functional_and_gradients(
      qE=matrix.col(O.x),
      use_analytical_gradients=O.spherical_type_info.use_analytical_gradients)
    return f, flex.double(g)

def run(args):
  assert len(args) in [0,2], "n_sites, n_trials"
  if (len(args) == 0):
    n_sites, n_trials = 3, 2
    out = null_out()
  else:
    n_sites, n_trials = [int(arg) for arg in args]
    out = sys.stdout
  #
  show_times_at_exit()
  class type_info(object):
    def __init__(O, type, use_analytical_gradients):
      O.type = type
      O.use_analytical_gradients = use_analytical_gradients
    def __str__(O):
      return "%s(use_analytical_gradients=%s)" % (
        O.type.__name__, str(O.use_analytical_gradients))
  spherical_types = [
    type_info(euler_params, False),
    type_info(euler_params, True),
    type_info(euler_angles_xyz, False),
    type_info(euler_angles_xyz, True),
    type_info(euler_angles_zxz, False),
    type_info(euler_angles_zxz, True),
    type_info(euler_angles_yxyz, False),
    type_info(euler_angles_xyzy, False),
    type_info(inf_euler_params, False),
    type_info(inf_axis_angle, False)]
  nfun_accu = {}
  n_failed = {}
  for ti in spherical_types:
    nfun_accu[str(ti)] = flex.size_t()
    n_failed[str(ti)] = 0
  mersenne_twister = flex.mersenne_twister(seed=0)
  for i_trial in range(n_trials):
    sites = [matrix.col(s) for s in flex.vec3_double(
      mersenne_twister.random_double(size=n_sites*3)*2-1)]
    c = center_of_mass_from_sites(sites)
    r = matrix.sqr(mersenne_twister.random_double_r3_rotation_matrix())
    wells = [r*(s-c)+c for s in sites]
    for ti in spherical_types:
      r = refinery(spherical_type_info=ti, sites=sites, wells=wells, out=out)
      nfun_accu[str(ti)].append(r.nfun)
      if (r.failed):
        n_failed[str(ti)] += 1
  nfun_sums = []
  annotations = []
  for ti in spherical_types:
    print(ti, file=out)
    nfuns = nfun_accu[str(ti)]
    stats = nfuns.as_double().min_max_mean()
    stats.show(out=out, prefix="  ")
    nfun_sums.append((str(ti), flex.sum(nfuns)))
    if (n_failed[str(ti)] == 0):
      annotations.append(None)
    else:
      annotations.append("failed: %d" % n_failed[str(ti)])
  print(file=out)
  show_sorted_by_counts(
    label_count_pairs=nfun_sums,
    reverse=False,
    out=out,
    annotations=annotations)
  print(file=out)
  print("OK")

if (__name__ == "__main__"):
  run(sys.argv[1:])


 *******************************************************************************


 *******************************************************************************
scitbx/rigid_body/proto/utils.py
from __future__ import absolute_import, division, print_function
from scitbx.rigid_body.proto import featherstone
from scitbx import matrix
from six.moves import range
from six.moves import zip

def center_of_mass_from_sites(sites):
  assert len(sites) != 0
  result = matrix.col((0,0,0))
  for site in sites:
    result += site
  result /= len(sites)
  return result

def inertia_from_sites(sites, pivot):
  m = [0] * 9
  for site in sites:
    x,y,z = site - pivot
    m[0] += y*y+z*z
    m[4] += x*x+z*z
    m[8] += x*x+y*y
    m[1] -= x*y
    m[2] -= x*z
    m[5] -= y*z
  m[3] = m[1]
  m[6] = m[2]
  m[7] = m[5]
  return matrix.sqr(m)

def spatial_inertia_from_sites(
      sites,
      mass=None,
      center_of_mass=None,
      alignment_T=None):
  if (mass is None):
    mass = len(sites)
  if (center_of_mass is None):
    center_of_mass = center_of_mass_from_sites(sites=sites)
  inertia = inertia_from_sites(sites=sites, pivot=center_of_mass)
  if (alignment_T is not None):
    center_of_mass = alignment_T * center_of_mass
    inertia = alignment_T.r * inertia * alignment_T.r.transpose()
  return featherstone.mcI(m=mass, c=center_of_mass, I=inertia)

def kinetic_energy(I_spatial, v_spatial):
  "RBDA Eq. 2.67"
  return 0.5 * v_spatial.dot(I_spatial * v_spatial)

def T_as_X(Tps):
  return featherstone.Xrot(Tps.r) \
       * featherstone.Xtrans(-Tps.r.transpose() * Tps.t)

class featherstone_system_model(object):

  def __init__(model, bodies):
    model.NB = len(bodies)
    model.pitch = []
    model.parent =[]
    model.Ttree = []
    model.Xtree = []
    model.I = []
    for B in bodies:
      model.pitch.append(B.J)
      model.parent.append(B.parent)
      if (B.parent == -1):
        Ttree = B.A.T0b
      else:
        Ttree = B.A.T0b * bodies[B.parent].A.Tb0
      model.Ttree.append(Ttree)
      model.Xtree.append(T_as_X(Ttree))
      model.I.append(B.I)

def spatial_velocities_from_model(model, q, qd):
  result = [None] * model.NB
  Xup = [None] * model.NB
  for i in range(model.NB):
    XJ, S = featherstone.jcalc( model.pitch[i], q[i] )
    if (S is None):
      vJ = qd[i]
    else:
      vJ = S*qd[i]
    Xup[i] = XJ * model.Xtree[i]
    if model.parent[i] == -1:
      result[i] = vJ
    else:
      result[i] = Xup[i]*result[model.parent[i]] + vJ
  return result

def e_kin_from_model(model, q, qd):
  result = 0
  for I_spatial,v_spatial in zip(
        model.I, spatial_velocities_from_model(model, q, qd)):
    result += kinetic_energy(I_spatial=I_spatial, v_spatial=v_spatial)
  return result


 *******************************************************************************


 *******************************************************************************
scitbx/rigid_body/proto/wx_free_motion.py
from __future__ import absolute_import, division, print_function
from scitbx.rigid_body.proto.free_motion_reference_impl import simulation
from gltbx import wx_viewer
from scitbx.math import minimum_covering_sphere, sphere_3d
from scitbx.array_family import flex
import wx
import sys
from six.moves import range

class viewer(wx_viewer.show_points_and_lines_mixin):

  def __init__(self, *args, **kwds):
    super(viewer, self).__init__(*args, **kwds)

  def set_points_and_lines(self):
    self.sim_as = simulation()
    self.sim_ac = simulation()
    self.points = flex.vec3_double(self.sim_as.sites_cart_moved_F01)
    self.points.extend(flex.vec3_double(self.sim_ac.sites_cart_moved_F01))
    self.points.extend(flex.vec3_double(self.sim_as.sites_cart_wells_F01))
    def add_line(i, j, color):
      line = (i,j)
      self.line_i_seqs.append(line)
      self.line_colors[line] = color
    self.labels = []
    n = len(self.sim_as.sites_cart_F1)
    offs = 0
    for prefix,color in [("S",(1,0,0)),("C",(0,0,1)),("W",(0,1,0))]:
      for i in range(n):
        add_line(offs+i, offs+(i+1)%n, color)
        self.labels.append(prefix+str(i))
      offs += n
    mcs = minimum_covering_sphere(self.points, epsilon=1.e-2)
    self.minimum_covering_sphere = sphere_3d(
      center=mcs.center(), radius=mcs.radius()*1.3)
    self.flag_show_minimum_covering_sphere = False
    self.flag_show_rotation_center = False
    self.steps_per_tab = 8
    print("Press and hold Tab key to run the simulation.")
    print("Press Shift-Tab to increase speed.")
    print("Press Ctrl-Tab  to decrease speed.")

  def tab_callback(self, shift_down=False, control_down=False):
    if (shift_down or control_down):
      if (shift_down):
        self.steps_per_tab = min(256, self.steps_per_tab * 2)
      else:
        self.steps_per_tab = max(1, self.steps_per_tab // 2)
      print("Steps per Tab:", self.steps_per_tab)
      return
    ip = 0
    for sim in [self.sim_as, self.sim_ac]:
      use_classical_accel = (sim is self.sim_ac)
      for ids in range(self.steps_per_tab):
        sim.dynamics_step(
          delta_t=0.01,
          use_classical_accel=use_classical_accel)
      for site in sim.sites_cart_moved_F01:
        self.points[ip] = site
        ip += 1
    self.labels_display_list = None
    self.lines_display_list = None
    self.points_display_list = None
    self.OnRedraw()

class App(wx_viewer.App):

  def __init__(self, args):
    assert len(args) == 0
    super(App, self).__init__(title="Free Motion Viewer")

  def init_view_objects(self):
    box = wx.BoxSizer(wx.VERTICAL)
    self.view_objects = viewer(self.frame, size=(600,600))
    self.view_objects.set_points_and_lines()
    box.Add(self.view_objects, wx.EXPAND, wx.EXPAND)
    self.frame.SetSizer(box)
    box.SetSizeHints(self.frame)

def run(args):
  App(args).MainLoop()

if (__name__ == "__main__"):
  run(sys.argv[1:])


 *******************************************************************************


 *******************************************************************************
scitbx/rigid_body/proto/wx_joint_lib.py
from __future__ import absolute_import, division, print_function
from scitbx.rigid_body.proto.tst_joint_lib import revolute_simulation
from scitbx.math import minimum_covering_sphere, sphere_3d
from scitbx.array_family import flex
from gltbx import wx_viewer
import wx
import sys
from six.moves import range
from six.moves import zip

class viewer(wx_viewer.show_points_and_lines_mixin):

  def __init__(self, *args, **kwds):
    super(viewer, self).__init__(*args, **kwds)

  def set_points(self):
    self.points.clear()
    for B,AJA in zip(self.sim.bodies, self.sim.AJA_accu):
      self.points.append(AJA * B.A.pivot)
      self.points.append(AJA * B.A.pivot + AJA.r * B.A.normal)
      for s in B.sites:
        self.points.append(AJA * s)

  def set_points_and_lines(self):
    NB = 3
    self.sim = revolute_simulation(
      mersenne_twister=None,
      NB=NB,
      config="zigzag")
    self.points = flex.vec3_double()
    self.set_points()
    assert self.points.size() == NB*3
    def add_line(i, j, color):
      line = (i,j)
      self.line_i_seqs.append(line)
      self.line_colors[line] = color
    self.labels = []
    p,n,s = 0,1,2
    for ib in range(NB):
      self.labels.extend(["p%d"%ib, "n%d"%ib, "s%d"%ib])
      add_line(p, n, (1,0,0))
      add_line(p, s, (0,1,0))
      add_line(n, s, (0,0,1))
      p,n,s = p+3,n+3,s+3
    mcs = minimum_covering_sphere(self.points, epsilon=1.e-2)
    self.minimum_covering_sphere = sphere_3d(
      center=mcs.center(), radius=mcs.radius()*1.3)
    self.flag_show_minimum_covering_sphere = False
    self.flag_show_rotation_center = False
    self.steps_per_tab = 8
    print("Press and hold Tab key to run the simulation.")
    print("Press Shift-Tab to increase speed.")
    print("Press Ctrl-Tab  to decrease speed.")

  def tab_callback(self, shift_down=False, control_down=False):
    if (shift_down or control_down):
      if (shift_down):
        self.steps_per_tab = min(256, self.steps_per_tab * 2)
      else:
        self.steps_per_tab = max(1, self.steps_per_tab // 2)
      print("Steps per Tab:", self.steps_per_tab)
      return
    self.sim.dynamics_step(delta_t=0.1)
    self.set_points()
    self.labels_display_list = None
    self.lines_display_list = None
    self.points_display_list = None
    self.OnRedraw()

class App(wx_viewer.App):

  def __init__(self, args):
    assert len(args) == 0
    super(App, self).__init__(title="joint_lib")

  def init_view_objects(self):
    box = wx.BoxSizer(wx.VERTICAL)
    self.view_objects = viewer(self.frame, size=(600,600))
    self.view_objects.set_points_and_lines()
    box.Add(self.view_objects, wx.EXPAND, wx.EXPAND)
    self.frame.SetSizer(box)
    box.SetSizeHints(self.frame)

def run(args):
  App(args).MainLoop()

if (__name__ == "__main__"):
  run(sys.argv[1:])


 *******************************************************************************


 *******************************************************************************
scitbx/rigid_body/proto/wx_molecules.py
from __future__ import absolute_import, division, print_function
from scitbx.rigid_body.proto import tst_molecules
from scitbx.math import minimum_covering_sphere, sphere_3d
from scitbx.array_family import flex
from gltbx import wx_viewer
from libtbx.utils import Usage
import wx
import sys
from six.moves import zip

class viewer(wx_viewer.show_points_and_lines_mixin):

  def __init__(self, *args, **kwds):
    super(viewer, self).__init__(*args, **kwds)

  def set_points(self):
    self.points.clear()
    for B,AJA in zip(self.sim.bodies, self.sim.AJA_accu):
      for s in B.sites:
        self.points.append(AJA * s)
    self.labels_display_list = None
    self.lines_display_list = None
    self.points_display_list = None

  def set_points_and_lines(self, simulation_factory_index, n_zigzag):
    if (simulation_factory_index == 0):
      self.sim = tst_molecules.simulation_zigzag(NB=n_zigzag)
    else:
      self.sim = tst_molecules.simulation_factories[simulation_factory_index]()
    self.points = flex.vec3_double()
    self.set_points()
    def add_line(i, j, color):
      line = (i,j)
      self.line_i_seqs.append(line)
      self.line_colors[line] = color
    self.labels = []
    B_off = []
    for B in self.sim.bodies:
      B_off.append(len(self.labels))
      self.labels.extend(B.labels)
      def add_off(i):
        if (i < 0): return B_off[B.parent+1] + i
        else:       return B_off[-1] + i
      for bond in B.bonds:
        i,j = [add_off(b) for b in bond]
        add_line(i, j, (1,0,0))
    mcs = minimum_covering_sphere(self.points, epsilon=1.e-2)
    self.minimum_covering_sphere = sphere_3d(
      center=mcs.center(), radius=mcs.radius()*1.3)
    self.flag_show_minimum_covering_sphere = False
    self.flag_show_rotation_center = False
    self.steps_per_tab = 1
    self.show_key_stroke_help()

  def show_key_stroke_help(self):
    print("Press and hold Tab key to run the simulation.")
    print("Press Shift-Tab to increase speed.")
    print("Press Ctrl-Tab  to decrease speed.")
    print("Press [0-9A-F] for sensitivity test with this many significant" \
          " digits.")
    print("Press M for minimization.")

  def process_key_stroke(self, key):
    if (key == ord("M")):
      return self.minimization()
    for n,digit in enumerate("0123456789ABCDEF"):
      if (key == ord(digit)):
        return self.sensitivity_test(n_significant_digits=n)
    print("No action for this key stroke.")
    self.show_key_stroke_help()

  def tab_callback(self, shift_down=False, control_down=False):
    if (shift_down or control_down):
      if (shift_down):
        self.steps_per_tab = min(256, self.steps_per_tab * 2)
      else:
        self.steps_per_tab = max(1, self.steps_per_tab // 2)
      print("Steps per Tab:", self.steps_per_tab)
      return
    self.sim.dynamics_step(delta_t=0.05)
    self.set_points()
    self.OnRedraw()

  def sensitivity_test(self, n_significant_digits):
    if (n_significant_digits == 0):
      print("Sensitivity test (full precision):")
      n_significant_digits = None
    else:
      print("Sensitivity test (%d significant digits):" % n_significant_digits)
    qdd = self.sim.sensitivity_test(n_significant_digits=n_significant_digits)
    flex.double(qdd).min_max_mean().show(prefix=" ")

  def minimization(self):
    print("Minimization:")
    print("  start e_pot:", self.sim.e_pot)
    self.sim.minimization(
      max_iterations=10,
      callback_after_step=self.minimization_callback)
    print("  final e_pot:", self.sim.e_pot)

  def minimization_callback(self, minimizer):
    print("        e_pot:", self.sim.e_pot)
    self.set_points()
    self.OnRedraw()

class App(wx_viewer.App):

  def __init__(self, args):
    n = len(tst_molecules.simulation_factories)
    if (len(args) not in [1,2]):
      raise Usage("scitbx.python wx_molecules.py sim_index [n_zigzag]")
    self.simulation_factory_index = int(args[0])
    if (len(args) > 1):
      self.n_zigzag = int(args[1])
    else:
      self.n_zigzag = 10
    assert 0 <= self.simulation_factory_index < n
    super(App, self).__init__(title="wx_molecules")

  def init_view_objects(self):
    box = wx.BoxSizer(wx.VERTICAL)
    self.view_objects = viewer(self.frame, size=(600,600))
    self.view_objects.set_points_and_lines(
      simulation_factory_index=self.simulation_factory_index,
      n_zigzag=self.n_zigzag)
    box.Add(self.view_objects, wx.EXPAND, wx.EXPAND)
    self.frame.SetSizer(box)
    box.SetSizeHints(self.frame)

def run(args):
  App(args).MainLoop()

if (__name__ == "__main__"):
  run(sys.argv[1:])


 *******************************************************************************


 *******************************************************************************
scitbx/rigid_body/tst.py
from __future__ import absolute_import, division, print_function
import scitbx.rigid_body.essence
from scitbx.rigid_body.essence import tst_tardy
from scitbx.graph import test_cases_tardy_pdb
from scitbx.array_family import flex
from scitbx import matrix
from libtbx.test_utils import \
  approx_equal, is_above_limit, is_below_limit, Exception_expected
from libtbx.utils import format_cpu_times
from six.moves import range
try:
  from six.moves import cPickle as pickle
except ImportError:
  import pickle
import random
import sys

def exercise_joint_lib_six_dof_aja_simplified():
  tc = test_cases_tardy_pdb.test_cases[9]
  tt = tc.tardy_tree_construct()
  masses = [1.0]*len(tc.sites)
  # arbitrary transformation so that the center of mass is not at the origin
  rt_arbitrary = matrix.col((-0.21,-0.51,0.64)) \
    .rt_for_rotation_around_axis_through(
      point=matrix.col((-0.80, 0.28, -0.89)), angle=-37, deg=True)
  sites = [rt_arbitrary * site for site in tc.sites]
  tm = scitbx.rigid_body.essence.tardy.model(
    labels=tc.labels,
    sites=sites,
    masses=masses,
    tardy_tree=tt,
    potential_obj=None)
  assert len(tm.bodies) == 1
  assert tm.q_packed_size == 7
  mt = flex.mersenne_twister(seed=0)
  for i_trial in range(3):
    q = mt.random_double(size=tm.q_packed_size)*2-1
    tm.unpack_q(q_packed=q)
    sm = tm.sites_moved()
    aja = matrix.rt(scitbx.rigid_body.joint_lib_six_dof_aja_simplified(
      center_of_mass=tuple(flex.vec3_double(sites).mean()),
      q=q))
    sm2 = [aja * site for site in sites]
    assert approx_equal(sm2, sm)

def etm_as_ftm(etm):
  ftm = scitbx.rigid_body.tardy_model(
    labels=etm.labels,
    sites=flex.vec3_double(etm.sites),
    masses=flex.double(etm.masses),
    tardy_tree=etm.tardy_tree,
    potential_obj=etm.potential_obj,
    near_singular_hinges_angular_tolerance_deg=
      etm.near_singular_hinges_angular_tolerance_deg)
  assert ftm.bodies_size() == len(etm.bodies)
  assert ftm.number_of_trees == etm.number_of_trees
  assert ftm.degrees_of_freedom == etm.degrees_of_freedom
  assert ftm.q_packed_size == etm.q_packed_size
  assert list(ftm.degrees_of_freedom_each_joint()) \
      == [body.joint.degrees_of_freedom for body in etm.bodies]
  assert list(ftm.q_size_each_joint()) \
      == [body.joint.q_size for body in etm.bodies]
  ftm.flag_positions_as_changed()
  ftm.flag_velocities_as_changed()
  assert ftm.labels is etm.labels
  assert ftm.sites.size() == len(etm.sites)
  assert ftm.masses.size() == len(etm.masses)
  assert ftm.tardy_tree is etm.tardy_tree
  assert ftm.potential_obj is etm.potential_obj
  assert approx_equal(
    ftm.near_singular_hinges_angular_tolerance_deg,
    etm.near_singular_hinges_angular_tolerance_deg)
  return ftm

def compare_essence_and_fast_tardy_models(
      etm,
      have_singularity=False,
      run_minimization=False):
  etm = scitbx.rigid_body.essence.tardy.model( # new instance to reset q, qd
    labels=etm.labels,
    sites=etm.sites,
    masses=etm.masses,
    tardy_tree=etm.tardy_tree,
    potential_obj=etm.potential_obj,
    near_singular_hinges_angular_tolerance_deg=
      etm.near_singular_hinges_angular_tolerance_deg)
  ftm = etm_as_ftm(etm=etm)
  #
  assert list(ftm.root_indices()) == etm.root_indices()
  #
  q_packed_zero = etm.pack_q()
  qd_packed_zero = etm.pack_qd()
  #
  def check_packed():
    e = etm.pack_q()
    f = ftm.pack_q()
    assert approx_equal(e, f)
    e = etm.pack_qd()
    f = ftm.pack_qd()
    assert approx_equal(e, f)
  check_packed()
  mt = flex.mersenne_twister(seed=0)
  q_packed_rand = mt.random_double(size=q_packed_zero.size())*2-1
  qd_packed_rand = mt.random_double(size=qd_packed_zero.size())*2-1
  for tm in [etm, ftm]: tm.unpack_q(q_packed=q_packed_rand)
  check_packed()
  for tm in [etm, ftm]: tm.unpack_q(q_packed=q_packed_zero)
  check_packed()
  for tm in [etm, ftm]: tm.unpack_qd(qd_packed=qd_packed_rand)
  check_packed()
  for tm in [etm, ftm]: tm.unpack_qd(qd_packed=qd_packed_zero)
  check_packed()
  for tm in [etm, ftm]: tm.unpack_q(q_packed=q_packed_rand)
  check_packed()
  for tm in [etm, ftm]: tm.unpack_qd(qd_packed=qd_packed_rand)
  check_packed()
  #
  fnosiet = ftm.number_of_sites_in_each_tree()
  assert list(fnosiet) == etm.number_of_sites_in_each_tree()
  e = etm.sum_of_masses_in_each_tree()
  f = ftm.sum_of_masses_in_each_tree()
  assert approx_equal(e, f)
  #
  def check_mean_linear_velocity():
    e = etm.mean_linear_velocity(number_of_sites_in_each_tree=None)
    for f in [ftm.mean_linear_velocity(number_of_sites_in_each_tree=None),
              ftm.mean_linear_velocity(number_of_sites_in_each_tree=fnosiet)]:
      if (e is None): assert f is None
      else:           assert approx_equal(e, f)
  check_mean_linear_velocity()
  value = matrix.col(mt.random_double(size=3)*2-1)
  for tm in [etm, ftm]:
    tm.subtract_from_linear_velocities(
      number_of_sites_in_each_tree=None,
      value=value)
  check_mean_linear_velocity()
  for tm in [etm, ftm]:
    tm.subtract_from_linear_velocities(
      number_of_sites_in_each_tree=fnosiet,
      value=value)
  check_mean_linear_velocity()
  #
  e = etm.sites_moved()
  f = ftm.sites_moved()
  assert approx_equal(e, f)
  e = etm.e_pot()
  f = ftm.e_pot()
  assert approx_equal(e, f)
  e = etm.d_e_pot_d_sites()
  f = ftm.d_e_pot_d_sites()
  assert approx_equal(e, f)
  e = etm.d_e_pot_d_q_packed()
  f = ftm.d_e_pot_d_q_packed()
  if (e.size() == 0):
    assert f.size() == 0
  else:
    e_max_abs = flex.max(flex.abs(e))
    if (etm.potential_obj is None):
      assert is_below_limit(value=e_max_abs, limit=1e-10)
    else:
      # note: e_max_abs is random generator dependent
      # by change much smaller e_max_abs are possible
      assert is_above_limit(value=e_max_abs, limit=0.1)
    assert approx_equal(e, f)
  #
  e = etm.e_kin()
  f = ftm.e_kin()
  assert approx_equal(e, f)
  e = etm.e_tot()
  f = ftm.e_tot()
  assert approx_equal(e, f)
  etm.reset_e_kin(e_kin_target=1.234)
  ftm.reset_e_kin(e_kin_target=1.234)
  e = etm.e_kin()
  if (etm.degrees_of_freedom == 0):
    assert approx_equal(e, 0)
  else:
    assert approx_equal(e, 1.234)
  f = ftm.e_kin()
  assert approx_equal(e, f)
  try:
    ftm.reset_e_kin(e_kin_target=1, e_kin_epsilon=0)
  except RuntimeError as e:
    assert str(e).find("e_kin_epsilon > 0") > 0
  else: raise Exception_expected
  etm.assign_zero_velocities()
  ftm.assign_zero_velocities()
  assert etm.e_kin() == 0
  assert ftm.e_kin() == 0
  random.seed(0)
  etm.assign_random_velocities()
  random.seed(0)
  ftm.assign_random_velocities()
  e = etm.e_kin()
  f = ftm.e_kin()
  assert approx_equal(e, f)
  #
  mt = flex.mersenne_twister(seed=0)
  qdd_rand_array = []
  for body in etm.bodies:
    qdd_rand_array.append(matrix.col(
      mt.random_double(size=body.joint.degrees_of_freedom)*2-1))
  tau_rand_array = []
  for body in etm.bodies:
    tau_rand_array.append(matrix.col(
      mt.random_double(size=body.joint.degrees_of_freedom)*2-1))
  f_ext_rand_array = []
  for ib in range(len(etm.bodies)):
    f_ext_rand_array.append(matrix.col(
      mt.random_double(size=6)*2-1))
  grav_accn_rand = matrix.col(mt.random_double(size=6)*2-1)
  def pack_array(array, packed_size=None):
    result = flex.double()
    if (packed_size is not None):
      result.reserve(packed_size)
    for sub in array:
      result.extend(flex.double(sub))
    if (packed_size is not None):
      assert result.size() == packed_size
    return result
  qdd_rand_packed = pack_array(
    array=qdd_rand_array, packed_size=etm.degrees_of_freedom)
  tau_rand_packed = pack_array(
    array=tau_rand_array, packed_size=etm.degrees_of_freedom)
  f_ext_rand_packed = pack_array(
    array=f_ext_rand_array, packed_size=len(etm.bodies)*6)
  def etm_inverse_dynamics_packed(
        qdd_array=None, f_ext_array=None, grav_accn=None):
    return pack_array(
      array=etm.inverse_dynamics(
        qdd_array=qdd_array,
        f_ext_array=f_ext_array,
        grav_accn=grav_accn),
      packed_size=etm.degrees_of_freedom)
  def etm_forward_dynamics_ab_packed(
        tau_array=None, f_ext_array=None, grav_accn=None):
    return pack_array(
      array=etm.forward_dynamics_ab(
        tau_array=tau_array,
        f_ext_array=f_ext_array,
        grav_accn=grav_accn),
      packed_size=etm.degrees_of_freedom)
  #
  e = etm_inverse_dynamics_packed(
    qdd_array=qdd_rand_array)
  f = ftm.inverse_dynamics_packed(
    qdd_packed=qdd_rand_packed)
  assert approx_equal(e, f)
  e = etm_inverse_dynamics_packed(
    f_ext_array=f_ext_rand_array)
  f = ftm.inverse_dynamics_packed(
    f_ext_packed=f_ext_rand_packed)
  assert approx_equal(e, f)
  e = etm_inverse_dynamics_packed(
    grav_accn=grav_accn_rand)
  f = ftm.inverse_dynamics_packed(
    grav_accn=flex.double(grav_accn_rand))
  assert approx_equal(e, f)
  for qdd_array,qdd_packed in [(None,None),
                               (qdd_rand_array,qdd_rand_packed)]:
    for f_ext_array,f_ext_packed in [(None,None),
                                     (f_ext_rand_array,f_ext_rand_packed)]:
      for grav_accn in [None, grav_accn_rand]:
        if ([qdd_array,f_ext_array,grav_accn].count(None) >= 2):
          continue # exercised above already
        e = etm_inverse_dynamics_packed(
          qdd_array=qdd_rand_array,
          f_ext_array=f_ext_rand_array,
          grav_accn=grav_accn_rand)
        f = ftm.inverse_dynamics_packed(
          qdd_packed=qdd_rand_packed,
          f_ext_packed=f_ext_rand_packed,
          grav_accn=flex.double(grav_accn_rand))
        assert approx_equal(e, f)
  #
  e = etm_forward_dynamics_ab_packed()
  f = ftm.forward_dynamics_ab_packed()
  assert approx_equal(e, f)
  e = etm_forward_dynamics_ab_packed(
    tau_array=tau_rand_array)
  f = ftm.forward_dynamics_ab_packed(
    tau_packed=tau_rand_packed)
  assert approx_equal(e, f)
  e = etm_forward_dynamics_ab_packed(
    f_ext_array=f_ext_rand_array)
  f = ftm.forward_dynamics_ab_packed(
    f_ext_packed=f_ext_rand_packed)
  assert approx_equal(e, f)
  e = etm_forward_dynamics_ab_packed(
    grav_accn=grav_accn_rand)
  f = ftm.forward_dynamics_ab_packed(
    grav_accn=flex.double(grav_accn_rand))
  assert approx_equal(e, f)
  for tau_array,tau_packed in [(None,None),
                               (tau_rand_array,tau_rand_packed)]:
    for f_ext_array,f_ext_packed in [(None,None),
                                     (f_ext_rand_array,f_ext_rand_packed)]:
      for grav_accn in [None, grav_accn_rand]:
        if (grav_accn is None):
          grav_accn_f = None
        else:
          grav_accn_f = flex.double(grav_accn)
        qdd_array_e = etm.forward_dynamics_ab(
          tau_array=tau_array,
          f_ext_array=f_ext_array,
          grav_accn=grav_accn)
        qdd_packed_e = pack_array(
          array=qdd_array_e,
          packed_size=etm.degrees_of_freedom)
        qdd_packed_f = ftm.forward_dynamics_ab_packed(
          tau_packed=tau_packed,
          f_ext_packed=f_ext_packed,
          grav_accn=grav_accn_f)
        assert approx_equal(qdd_packed_e, qdd_packed_f)
        tau2_array_e = etm.inverse_dynamics(
          qdd_array=qdd_array_e,
          f_ext_array=f_ext_array,
          grav_accn=grav_accn)
        tau2_packed_e = pack_array(
          array=tau2_array_e,
          packed_size=etm.degrees_of_freedom)
        tau2_packed_f = ftm.inverse_dynamics_packed(
          qdd_packed=qdd_packed_f,
          f_ext_packed=f_ext_packed,
          grav_accn=grav_accn_f)
        assert approx_equal(tau2_packed_e, tau2_packed_f)
        if (etm.degrees_of_freedom == 0):
          assert tau2_packed_e.size() == 0
        elif (not have_singularity):
          if (tau_packed is None):
            assert is_below_limit(
              flex.max(flex.abs(tau2_packed_e)), 0, eps=1e-5)
          else:
            assert approx_equal(tau2_packed_e, tau_packed, eps=1e-5)
        qdd2_array_e = etm.forward_dynamics_ab(
          tau_array=tau2_array_e,
          f_ext_array=f_ext_array,
          grav_accn=grav_accn)
        qdd2_packed_e = pack_array(
          array=qdd2_array_e,
          packed_size=etm.degrees_of_freedom)
        qdd2_packed_f = ftm.forward_dynamics_ab_packed(
          tau_packed=tau2_packed_f,
          f_ext_packed=f_ext_packed,
          grav_accn=grav_accn_f)
        assert approx_equal(qdd2_packed_e, qdd2_packed_f)
        assert approx_equal(qdd2_packed_e, qdd_packed_e, eps=1e-4)
  #
  def check_qdd():
    e = pack_array(array=etm.qdd_array(), packed_size=etm.degrees_of_freedom)
    f = ftm.qdd_packed()
    assert approx_equal(e, f)
  check_qdd()
  ftm.flag_positions_as_changed()
  assert not ftm.sites_moved_is_cached()
  assert not ftm.qdd_array_is_cached()
  ftm.sites_moved()
  assert ftm.sites_moved_is_cached()
  assert not ftm.qdd_array_is_cached()
  check_qdd()
  assert ftm.sites_moved_is_cached()
  assert ftm.qdd_array_is_cached()
  ftm.unpack_q(q_packed=ftm.pack_q())
  assert not ftm.sites_moved_is_cached()
  assert not ftm.qdd_array_is_cached()
  ftm.qdd_packed()
  if (ftm.potential_obj is None):
    assert not ftm.sites_moved_is_cached()
    ftm.sites_moved()
  assert ftm.sites_moved_is_cached()
  assert ftm.qdd_array_is_cached()
  ftm.unpack_qd(qd_packed=ftm.pack_qd())
  assert ftm.sites_moved_is_cached()
  assert not ftm.qdd_array_is_cached()
  check_qdd()
  #
  delta_t = 0.1234
  etm.dynamics_step(delta_t=delta_t)
  ftm.dynamics_step(delta_t=delta_t)
  assert not ftm.sites_moved_is_cached()
  assert not ftm.qdd_array_is_cached()
  check_packed()
  check_qdd()
  #
  etm.assign_zero_velocities()
  ftm.assign_zero_velocities()
  e = etm_inverse_dynamics_packed(
    f_ext_array=f_ext_rand_array)
  f = ftm.inverse_dynamics_packed(
    f_ext_packed=f_ext_rand_packed)
  assert approx_equal(e, f)
  e_ref = e
  e = pack_array(
    array=etm.f_ext_as_tau(
      f_ext_array=f_ext_array),
    packed_size=etm.degrees_of_freedom)
  assert approx_equal(e_ref, e)
  f = ftm.f_ext_as_tau_packed(
    f_ext_packed=f_ext_packed)
  assert approx_equal(e_ref, f)
  #
  if (run_minimization):
    check_packed()
    etm.minimization(max_iterations=3)
    ftm.minimization(max_iterations=3)
    check_packed()

def exercise_with_test_cases_tardy_pdb():
  n_tested = 0
  for tc in test_cases_tardy_pdb.test_cases:
    tt = tc.tardy_tree_construct()
    masses = [1.0]*len(tc.sites)
    if (n_tested < 2):
      etm = scitbx.rigid_body.essence.tardy.model(
        labels=tc.labels,
        sites=tc.sites,
        masses=masses,
        tardy_tree=tt,
        potential_obj=None)
      compare_essence_and_fast_tardy_models(etm=etm)
    etm = tst_tardy.construct_tardy_model(
      labels=tc.labels,
      sites=tc.sites,
      masses=masses,
      tardy_tree=tt)
    assert etm.potential_obj is not None
    compare_essence_and_fast_tardy_models(
      etm=etm,
      run_minimization=(tc.tag == "tyr_with_h"))
    n_tested += 1

def exercise_fixed_vertices():
  etm = tst_tardy.get_test_model_by_index(
    i=0, fixed_vertex_lists=[[0]])
  assert etm.degrees_of_freedom == 0
  compare_essence_and_fast_tardy_models(etm=etm)
  #
  for i_case,etm in enumerate(
                      tst_tardy.exercise_fixed_vertices_special_cases()):
    assert etm.potential_obj is not None
    compare_essence_and_fast_tardy_models(
      etm=etm,
      have_singularity=(i_case < 4))
  #
  for fixed_vertices,expected_dof in \
        tst_tardy.test_case_5_fixed_vertices_expected_dof:
    etm = tst_tardy.get_test_model_by_index(
      i=5, fixed_vertex_lists=[fixed_vertices])
    assert etm.degrees_of_freedom == expected_dof
    compare_essence_and_fast_tardy_models(etm=etm)

def exercise_pickle():
  etm = tst_tardy.get_test_model_by_index(i=5)
  assert [body.joint.degrees_of_freedom for body in etm.bodies] \
      == [6, 1, 1, 1, 1, 1]
  assert etm.potential_obj is not None
  etm.assign_random_velocities(e_kin_target=2.34)
  etm.dynamics_step(delta_t=0.937)
  def etm_as_ftm_with_q_qd():
    result = etm_as_ftm(etm=etm)
    result.unpack_q(etm.pack_q())
    result.unpack_qd(etm.pack_qd())
    return result
  for protocol in range(pickle.HIGHEST_PROTOCOL):
    ftm1 = etm_as_ftm_with_q_qd()
    s = pickle.dumps(etm_as_ftm_with_q_qd(), protocol)
    ftm2 = pickle.loads(s)
    assert approx_equal(ftm2.pack_q(), ftm1.pack_q())
    assert approx_equal(ftm2.pack_qd(), ftm1.pack_qd())
    for delta_t in [0.538, 0.393]:
      ftm1.dynamics_step(delta_t=delta_t)
      ftm2.dynamics_step(delta_t=delta_t)
      assert approx_equal(ftm2.pack_q(), ftm1.pack_q())
      assert approx_equal(ftm2.pack_qd(), ftm1.pack_qd())

def run(args):
  assert len(args) == 0
  exercise_joint_lib_six_dof_aja_simplified()
  exercise_with_test_cases_tardy_pdb()
  exercise_fixed_vertices()
  exercise_pickle()
  print(format_cpu_times())

if (__name__ == "__main__"):
  run(args=sys.argv[1:])


 *******************************************************************************
