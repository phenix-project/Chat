

 *******************************************************************************
cctbx/eltbx/__init__.py


 *******************************************************************************


 *******************************************************************************
cctbx/eltbx/attenuation_coefficient.py
from __future__ import absolute_import, division, print_function
from scitbx.array_family import flex # import dependency
import boost_adaptbx.boost.python as bp
from six.moves import range
ext = bp.import_ext("cctbx_eltbx_attenuation_coefficient_ext")
from cctbx_eltbx_attenuation_coefficient_ext import *


class nist_elements(object):
  ''' A table of nist elements and composite materials.
      Note that elements are only defined up to uranium. '''

  def __init__(self):
    ''' Initialise the table. '''
    self._elements = [
        '',  'H', 'He', 'Li', 'Be',  'B',  'C',  'N',  'O',  'F', 'Ne',
      'Na', 'Mg', 'Al', 'Si',  'P',  'S', 'Cl', 'Ar',  'K', 'Ca', 'Sc',
      'Ti',  'V', 'Cr', 'Mn', 'Fe', 'Co', 'Ni', 'Cu', 'Zn', 'Ga', 'Ge',
      'As', 'Se', 'Br', 'Kr', 'Rb', 'Sr',  'Y', 'Zr', 'Nb', 'Mo', 'Tc',
      'Ru', 'Rh', 'Pd', 'Ag', 'Cd', 'In', 'Sn', 'Sb', 'Te',  'I', 'Xe',
      'Cs', 'Ba', 'La', 'Ce', 'Pr', 'Nd', 'Pm', 'Sm', 'Eu', 'Gd', 'Tb',
      'Dy', 'Ho', 'Er', 'Tm', 'Yb', 'Lu', 'Hf', 'Ta',  'W', 'Re', 'Os',
      'Ir', 'Pt', 'Au', 'Hg', 'Tl', 'Pb', 'Bi', 'Po', 'At', 'Rn', 'Fr',
      'Ra', 'Ac', 'Th', 'Pa', 'U',
      'CdTe', 'GaAs']

  def __len__(self):
    ''' Return the number of elemets '''
    return len(self._elements) - 1

  def symbol_list(self):
    ''' Return the list of elements. '''
    return list(self._elements[1:])

  def atomic_number_list(self):
    ''' Return a list of atomic numbers. '''
    return list(range(1, len(self._elements)))

  def atomic_number(self, symbol):
    ''' Get the atomic number from the symbol.

    Params:
        symbol The element symbol

    Return:
        The atomic number

    '''
    return self._elements.index(symbol)

  def symbol(self, number):
    ''' Get the symbol from the atomic number

    Params:
        number The atomic number

    Return:
        The symbol

    '''
    assert(number > 0 and number < len(self._elements))
    return self._elements[number]


def chemlex(formula):
  ''' Function taking a chemical formula and getting the component
  elements and number.

  Parsing is simply done by regex and no checking for whether the
  symbol corresponds to anything real is done. Proper capitalisation
  must be used.

  Params:
      formula A chemical formula string

  Returns:
      A list of (symbol, number) tuples

  '''
  import re

  # Check that the formula is valid
  if re.match('^([A-Z][a-z]{0,2}[1-9]?)*$', formula):

    # Split the components by capital letter
    comp = re.findall('[A-Z][^A-Z]*', formula)

    # For each component split into element and number
    el_num = []
    for c in comp:

      r = re.compile('([A-Z][a-z]{0,2})([1-9]+)')
      m = r.match(c)
      if m:
        el = m.group(1)
        num = int(m.group(2))
      else:
        el = c
        num = 1

      # Append the element with number
      el_num.append((el, num))

    # Return the list of components
    return el_num

  else:
    raise ValueError('Unidentified formula')


def get_table(index):
    ''' Get the table for a given element or composite

    Params:
        index Either an atomic number of symbol

    Returns:
        The table for the requested element

    '''
    # Get the index as atomic number
    if isinstance(index, str):
      atomic_number = nist_elements().atomic_number(index)
    else:
      atomic_number = index

    # return the nist element table
    return table(atomic_number)


 *******************************************************************************


 *******************************************************************************
cctbx/eltbx/chemical_elements.py
"""
This module can be used to retrieve a list or set of all chemical symbols on the
periodic table, from hydrogen up to roentgenium.
"""
from __future__ import absolute_import, division, print_function
import scitbx.stl.set # import dependency

import boost_adaptbx.boost.python as bp
ext = bp.import_ext("cctbx_eltbx_chemical_elements_ext")
from cctbx_eltbx_chemical_elements_ext import *

proper_caps_set.__doc__ = """
Retrieves element symbols with only their first letter capitalized.

Returns
-------
scitbx.stl.set.stl_string
"""

proper_caps_list.__doc__ = """
Retrieves element symbols with only their first letter capitalized, sorted by
atomic number.

Returns
-------
list of str

Examples
--------
>>> from cctbx.eltbx.chemical_elements import proper_caps_list
>>> proper_caps_list()[:5]
['H', 'He', 'Li', 'Be', 'B']
"""

proper_upper_set.__doc__ = """
Retrieves element symbols with all letters capitalized.

Returns
-------
scitbx.stl.set.stl_string

Examples
--------
>>> from cctbx.eltbx.chemical_elements import proper_upper_set
>>> list(proper_upper_set())[:5]
['AC', 'AG', 'AL', 'AM', 'AR']
"""

proper_upper_list.__doc__ = """
Retrieves element symbols with all letters capitalized, sorted by atomic
number.

Returns
-------
list of str

Examples
--------
>>> from cctbx.eltbx.chemical_elements import proper_upper_list
>>> proper_upper_list()[:5]
['H', 'HE', 'LI', 'BE', 'B']
"""

proper_and_isotopes_upper_set.__doc__ = """
Like proper_upper_set, but also includes symbols for deuterium and tritium.

Returns
-------
scitbx.stl.set.stl_string
"""


 *******************************************************************************


 *******************************************************************************
cctbx/eltbx/covalent_radii.py
from __future__ import absolute_import, division, print_function
import boost_adaptbx.boost.python as bp
ext = bp.import_ext("cctbx_eltbx_covalent_radii_ext")
from cctbx_eltbx_covalent_radii_ext import *

bp.inject(ext.table_iterator, bp.py3_make_iterator)


 *******************************************************************************


 *******************************************************************************
cctbx/eltbx/development/__init__.py


 *******************************************************************************


 *******************************************************************************
cctbx/eltbx/development/combine_fits.py
from __future__ import absolute_import, division, print_function
from cctbx.eltbx.development import itvc_section61_io
from cctbx.eltbx.development.format_gaussian_fits import expected_labels
from cctbx.eltbx.gaussian_fit import international_tables_stols
import scitbx.math.gaussian
from cctbx.array_family import flex
from libtbx.option_parser import OptionParser
from libtbx import easy_pickle
from six.moves import zip

def pick_nicest_fit(fit_0, fit_1):
  if (fit_0.max_error < fit_1.max_error): return fit_0
  if (fit_0.max_error > fit_1.max_error): return fit_1
  a0 = flex.double(fit_0.array_of_a())
  a1 = flex.double(fit_1.array_of_a())
  l0 = (flex.min(a0) > 0)
  l1 = (flex.min(a0) > 0)
  if (l0 and not l1): return fit_0
  if (l1 and not l0): return fit_1
  b0 = flex.double(fit_0.array_of_b())
  b1 = flex.double(fit_1.array_of_b())
  if (flex.min(b0) > flex.min(b1)): return fit_0
  if (flex.min(b0) < flex.min(b1)): return fit_1
  return fit_0

def reset_max_error(itvc_entry, fit):
  sel = international_tables_stols <= fit.stol + 1.e-6
  gaussian_fit = scitbx.math.gaussian.fit(
    international_tables_stols.select(sel),
    itvc_entry.table_y.select(sel),
    itvc_entry.table_sigmas.select(sel),
    fit)
  fit.max_error = flex.max(gaussian_fit.significant_relative_errors())

def main():
  parser = OptionParser(
    usage="usage: python %prog [options]"
         +" itvc_table all_fits_six_terms.pickle"
         +" all_fits_decremental.pickle all_fits_incremental.pickle")
  (options, args) = parser.parse_args()
  if (len(args) != 4):
    parser.print_help()
    return
  itvc_tab = itvc_section61_io.read_table6111(args[0])
  six_term_fits = easy_pickle.load(args[1])
  fits = []
  for file_name in args[2:]:
    fits.append(easy_pickle.load(file_name))
    for label,fit_group in fits[-1].all.items():
      for fit in fit_group:
        reset_max_error(itvc_tab.entries[label], fit)
  best_fits = {}
  n_less = 0
  n_greater = 0
  n_equal = 0
  n_less_list = [0] * 10
  n_greater_list = [0] * 10
  n_equal_list = [0] * 10
  for label in expected_labels(kissel_dir=None):
    fit_group_0 = fits[0].all.get(label, None)
    fit_group_1 = fits[1].all.get(label, None)
    if (fit_group_0 is None and fit_group_1 is None):
      best_fits[label] = None
      continue
    if (fit_group_0 is None):
      best_fits[label] = fit_group_0
      continue
    if (fit_group_1 is None):
      best_fits[label] = fit_group_1
      continue
    best_group = []
    all_n_terms = {}
    n_terms_dicts = []
    for fit_group in [fit_group_0, fit_group_1]:
      n_terms_dict = {}
      for fit in fit_group:
        n_terms_dict[fit.n_terms()] = fit
      n_terms_dicts.append(n_terms_dict)
      all_n_terms.update(n_terms_dicts[-1])
    all_n_terms = list(all_n_terms.keys())
    all_n_terms.sort()
    for n_terms in all_n_terms:
      fit_0 = n_terms_dicts[0].get(n_terms, None)
      fit_1 = n_terms_dicts[1].get(n_terms, None)
      if (fit_0 is None):
        best_group.append(fit_1)
        continue
      if (fit_1 is None):
        best_group.append(fit_0)
        continue
      if   (fit_0.stol < fit_1.stol):
        best_group.append(fit_1)
        status = "less"
        n_less += 1
        n_less_list[n_terms] += 1
      elif (fit_0.stol > fit_1.stol):
        best_group.append(fit_0)
        status = "greater"
        n_greater += 1
        n_greater_list[n_terms] += 1
      else:
        best_group.append(pick_nicest_fit(fit_0, fit_1))
        status = "equal"
        n_equal += 1
        n_equal_list[n_terms] += 1
      print("%-4s n_terms=%d %4.2f %4.2f %s" % (
        label, n_terms, fit_0.stol, fit_1.stol, status))
    best_fits[label] = best_group
  print("n_less:", n_less)
  print("n_greater:", n_greater)
  print("n_equal:", n_equal)
  print("total:", n_less + n_greater + n_equal)
  n_terms = -1
  for n_less,n_greater,n_equal in zip(n_less_list,n_greater_list,n_equal_list):
    n_terms += 1
    if (n_less == 0 and n_greater == 0 and n_equal == 0): continue
    print("n_terms:", n_terms)
    print("  n_less:", n_less)
    print("  n_greater:", n_greater)
    print("  n_equal:", n_equal)
    print("  total:", n_less + n_greater + n_equal)
  print()
  for label in expected_labels(kissel_dir=None):
    if (best_fits[label] is None):
      print("# Warning: Missing scattering_type:", label)
  print()
  print("Best fits:")
  print()
  for label in expected_labels(kissel_dir=None):
    fit_group = best_fits[label]
    if (fit_group is None): continue
    print("scattering_type:", label)
    assert len(six_term_fits.all[label]) == 1
    assert six_term_fits.all[label][0].n_terms() == 6
    fit_group.append(six_term_fits.all[label][0])
    reset_max_error(itvc_tab.entries[label], fit_group[-1])
    trimmed_fit_group =[]
    prev_fit = None
    for fit in fit_group:
      if (prev_fit is None
          or fit.stol > prev_fit.stol
          or (fit.stol == prev_fit.stol
              and fit.max_error < prev_fit.max_error)):
        trimmed_fit_group.append(fit)
        fit.show()
        prev_fit = fit
      else:
        print("# skipped: %s, n_terms: %d, stol: %.2f, max_error: %.4f" % (
          label, fit.n_terms(), fit.stol, fit.max_error))
    best_fits[label] = trimmed_fit_group
  print()
  easy_pickle.dump("best_fits.pickle", best_fits)

if (__name__ == "__main__"):
  main()


 *******************************************************************************


 *******************************************************************************
cctbx/eltbx/development/create_n_gaussian_raw_cpp.py
from __future__ import absolute_import, division, print_function
from cctbx.eltbx.development.format_gaussian_fits import read_pickled_fits
from cctbx.eltbx import xray_scattering
import cctbx.eltbx.gaussian_fit
import scitbx.math.gaussian_fit
import hashlib
import time
import sys
from six.moves import zip

def write_module_info(f, module_object):
  file_name = module_object.__file__
  if (file_name.endswith(".pyc")):
    file_name = file_name[:-1]
  assert file_name.endswith(".py")
  file_content = open(file_name, "rb").read()
  m = hashlib.md5()
  m.update(file_content)
  print("// Module:", module_object.__name__, file=f)
  print("//   size:", len(file_content), file=f)
  print("//   MD5 hexdigest:", m.hexdigest(), file=f)
  print(file=f)

def write_header(f):
  print("""\
#include <cctbx/eltbx/xray_scattering/n_gaussian_raw.h>
#include <cstring>

namespace {

#undef D
#define D static const double
""", file=f)

def identifier(label):
  return (label.lower()
    .replace("'", "prime")
    .replace("+", "plus")
    .replace("-", "minus"))

def write_fit_group(f, label, group):
  if (label == "h_sds"): # retro-fitted
    group = list(reversed(group))
  id = identifier(label)
  s = "D %s_s[] = {" % id
  for fit in group:
    s += " " + str(fit.stol) + ","
  s = s[:-1] + " };"
  print(s, file=f)
  print("D %s_e[] = {" % id, file=f)
  if (label == "h_sds"): # retro-fitted
    from cctbx.eltbx.development.hydrogen_plots import fit_input
    from scitbx.array_family import flex
    fi = fit_input()
  for fit in group:
    sel = fi.stols <= fit.stol + 1.e-6
    if (label == "h_sds"): # retro-fitted
      gaussian_fit = scitbx.math.gaussian.fit(
        fi.stols.select(sel),
        fi.data.select(sel),
        fi.sigmas.select(sel),
        fit)
      s = str(flex.max(gaussian_fit.significant_relative_errors()))
    else:
      s = str(fit.max_error)
    if (fit is not group[-1]): s += ","
    print(s, file=f)
  print("};", file=f)
  labels = []
  for fit_unsorted in group:
    fit = fit_unsorted.sort()
    lbl = "%s_%d" % (id, fit.n_terms())
    if (fit.use_c()): lbl += "c"
    print("D %s[] = {" % lbl, file=f)
    labels.append(lbl)
    buf = []
    for a,b in zip(fit.array_of_a(), fit.array_of_b()):
      buf.append("%s, %s," % (str(a), str(b)))
    if (fit.use_c()):
      buf.append(str(fit.c()))
    else:
      buf[-1] = buf[-1][:-1]
    for s in buf: print(s, file=f)
    print("};", file=f)
  print("D* %s_c[] = { %s };" % (id, ", ".join(labels)), file=f)
  print(file=f)
  return
  print("""\
""", file=f)

def write_labels(f, labels):
  print("""\
static const char*
labels[] = {""", file=f)
  last_label = labels[-1]
  for label in labels:
    assert not '"' in label
    c = ","
    if (label == last_label): c = ""
    print('"%s"%s' % (label, c), file=f)
  print("};", file=f)

def write_table(f, labels):
  print("""\
static const cctbx::eltbx::xray_scattering::n_gaussian::raw::entry
table[] = {""", file=f)
  last_label = labels[-1]
  for label in labels:
    id = identifier(label)
    c = ","
    if (label == last_label): c = ""
    print('%s_s, %s_e, %s_c%s' % (id, id, id, c), file=f)
  print("};", file=f)

def write_tail(f, localtime, table_size):
  print("""\
} // namespace <anonymous>

namespace cctbx { namespace eltbx { namespace xray_scattering {
namespace n_gaussian { namespace raw {

  const char*
  get_tag() { return "%s"; }

  const char**
  get_labels() { return labels; }

  unsigned int
  get_table_size() { return %dU; }

  const entry*
  get_table() { return table; }

}}}}} // namespace cctbx::eltbx::xray_scattering::n_gaussian::raw""" % (
  "%04d_%02d_%02d_%02d%02d" % localtime[:5], table_size), file=f)

def run(gaussian_fit_pickle_file_names):
  localtime = time.localtime()
  fits = read_pickled_fits(gaussian_fit_pickle_file_names)
  f = sys.stdout
  if (gaussian_fit_pickle_file_names[0].find("sds") >= 0): # retro-fitted
    write_fit_group(f, "h_sds", fits.all["SDS"])
    return
  print("// This is an automatically generated file. DO NOT EDIT!", file=f)
  print(file=f)
  print("// Time %04d/%02d/%02d %02d:%02d:%02d" % localtime[:6], file=f)
  print("// Time zone:", time.tzname, file=f)
  print(file=f)
  write_module_info(f, cctbx.eltbx.gaussian_fit)
  write_module_info(f, scitbx.math.gaussian_fit)
  print("// Parameters:", file=f)
  for k,v in fits.parameters.items():
    print("//   %s:" % k, v, file=f)
  print(file=f)
  present = []
  missing = []
  for wk in xray_scattering.wk1995_iterator():
    try:
      fit_group = fits.all[wk.label()]
    except Exception:
      missing.append(wk.label())
    else:
      present.append(wk.label())
  if (len(missing) > 0):
    print("// Warning: Missing scattering labels:", file=f)
    for label in missing:
      print("// ", label, file=f)
    print(file=f)
  write_header(f)
  for label in present:
    write_fit_group(f, label, fits.all[label])
  write_labels(f, present)
  write_table(f, present)
  write_tail(f, localtime, len(present))

if (__name__ == "__main__"):
  run(sys.argv[1:])


 *******************************************************************************


 *******************************************************************************
cctbx/eltbx/development/e_scattering_plots.py
from __future__ import absolute_import, division, print_function
from cctbx.eltbx import e_scattering
import sys
from six.moves import range

def run(args):
  assert len(args) == 0
  n_samples = 1000
  from matplotlib.backends.backend_pdf import PdfPages
  all_pdf = PdfPages("all.pdf")
  from libtbx import pyplot
  from scitbx.array_family import flex
  for element in e_scattering.ito_vol_c_2011_table_4_3_2_2_elements():
    fig = pyplot.figure()
    fig.set_size_inches(11, 8.5)
    ax = fig.add_subplot(1, 1, 1)
    ax.set_title(element, fontsize=12)
    def one_curv(g, code):
      x = flex.double()
      y = flex.double()
      for i_stol in range(n_samples+1):
        stol = 6 * i_stol / n_samples
        x.append(stol)
        y.append(g.at_stol(stol))
      ax.plot(x.as_numpy_array(), y.as_numpy_array(), code)
    g = e_scattering.ito_vol_c_2011_table_4_3_2_2_entry_as_gaussian(
      label=element, exact=True)
    one_curv(g, "b-")
    one_curv(e_scattering.gaussian(
      g.array_of_a()[:4],
      g.array_of_b()[:4]), "r-")
    all_pdf.savefig(fig, bbox_inches="tight")
  all_pdf.close()
  print("plots written to file: all.pdf")

if (__name__ == "__main__"):
  run(args=sys.argv[1:])


 *******************************************************************************


 *******************************************************************************
cctbx/eltbx/development/format_gaussian_fits.py
from __future__ import absolute_import, division, print_function
from cctbx.eltbx import xray_scattering
from cctbx.eltbx.development import itvc_section61_io
from cctbx.eltbx.development import kissel_io
from cctbx.eltbx.gaussian_fit import international_tables_stols
from cctbx.eltbx import tiny_pse
from cctbx.array_family import flex
import scitbx.math.gaussian
from libtbx.option_parser import OptionParser
from libtbx import adopt_init_args
from libtbx import easy_pickle
import os
from six.moves import range
from six.moves import zip

class labeled_fit(object):

  def __init__(self, label, gaussian_fit):
    adopt_init_args(self, locals())

class read_pickled_fits(object):

  def __init__(self, gaussian_fit_pickle_file_names):
    self.parameters = None
    self.all = {}
    for file_name in gaussian_fit_pickle_file_names:
      fits = easy_pickle.load(file_name)
      fp = fits["fit_parameters"].__dict__
      if (self.parameters is None):
        self.parameters = fp
      else:
        for k,v in fp.items():
          assert str(self.parameters[k]) == str(v)
      del fits["fit_parameters"]
      size_before = len(self.all)
      self.all.update(fits)
      assert len(self.all) == size_before + len(fits)

def expected_labels(kissel_dir):
  result = []
  if (kissel_dir is None):
    for wk in xray_scattering.wk1995_iterator():
      result.append(wk.label())
  else:
    for atomic_number in range(1,100):
      result.append(tiny_pse.table(atomic_number).symbol())
  return result

def run(gaussian_fit_pickle_file_names, itvc_file_name, kissel_dir):
  itvc_tab = None
  if (itvc_file_name is not None):
    itvc_tab = itvc_section61_io.read_table6111(itvc_file_name)
  fits = read_pickled_fits(gaussian_fit_pickle_file_names)
  #easy_pickle.dump("all_fits.pickle", fits)
  for k,v in fits.parameters.items():
    print("# %s:" % k, v)
  print()
  max_errors = flex.double()
  labeled_fits = []
  n_processed = 0
  for label in expected_labels(kissel_dir):
    try:
      fit_group = fits.all[label]
    except Exception:
      print("# Warning: Missing scattering_type:", label)
    else:
      print("scattering_type:", label)
      prev_fit = None
      for fit in fit_group:
        if (prev_fit is not None):
          if (fit.stol > prev_fit.stol):
            print("# Warning: decreasing stol")
          elif (fit.stol == prev_fit.stol):
            if (fit.max_error < prev_fit.max_error):
              print("# Warning: same stol but previous has larger error")
        prev_fit = fit
        fit.sort().show()
        gaussian_fit = None
        if (itvc_tab is not None and label != "O2-"):
          entry = itvc_tab.entries[label]
          sel = international_tables_stols <= fit.stol + 1.e-6
          gaussian_fit = scitbx.math.gaussian.fit(
            international_tables_stols.select(sel),
            entry.table_y.select(sel),
            entry.table_sigmas.select(sel),
            fit)
        elif (kissel_dir is not None):
          file_name = os.path.join(kissel_dir, "%02d_%s_rf" % (
            tiny_pse.table(label).atomic_number(), label))
          tab = kissel_io.read_table(file_name)
          sel = tab.itvc_sampling_selection() & (tab.x <= fit.stol + 1.e-6)
          gaussian_fit = scitbx.math.gaussian.fit(
            tab.x.select(sel),
            tab.y.select(sel),
            tab.sigmas.select(sel),
            fit)
        if (gaussian_fit is not None):
          max_errors.append(
            flex.max(gaussian_fit.significant_relative_errors()))
          labeled_fits.append(labeled_fit(label, gaussian_fit))
      n_processed += 1
  print()
  if (n_processed != len(fits.all)):
    print("# Warning: %d fits were not processed." % (
      len(fits.all) - n_processed))
    print()
  if (max_errors.size() > 0):
    print("Summary:")
    perm = flex.sort_permutation(data=max_errors, reverse=True)
    max_errors = max_errors.select(perm)
    labeled_fits = flex.select(labeled_fits, perm)
    quick_summary = {}
    for me,lf in zip(max_errors, labeled_fits):
      print(lf.label, "n_terms=%d max_error: %.4f" % (
        lf.gaussian_fit.n_terms(), me))
      quick_summary[lf.label + "_" + str(lf.gaussian_fit.n_terms())] = me
      if (me > 0.01):
        fit = lf.gaussian_fit
        re = fit.significant_relative_errors()
        for s,y,a,r in zip(fit.table_x(),fit.table_y(),fit.fitted_values(),re):
          comment = ""
          if (r > 0.01): comment = " large error"
          print("%4.2f %7.4f %7.4f %7.4f %7.4f%s" % (s,y,a,a-y,r,comment))
        print()
    print()
    #easy_pickle.dump("quick_summary.pickle", quick_summary)

def cross_check(args):
  quick_summaries = []
  for file_name in args:
    quick_summaries.append(easy_pickle.load(file_name))
  assert len(quick_summaries) == 2
  lines = []
  max_of_errors = flex.double()
  atomic_numbers = flex.double()
  n_less = 0
  n_greater = 0
  n_equal = 0
  for label_1,error_1 in quick_summaries[0].items():
    error_2 = quick_summaries[1].get(label_1, None)
    if (error_2 is not None):
      line = "%-10s %7.4f %7.4f" % (label_1, error_1, error_2)
      if   (error_1 < error_2):
        line += " less    %7.4f" % (error_2/error_1)
        n_less += 1
      elif (error_1 > error_2):
        line += " greater %7.4f" % (error_1/error_2)
        n_greater += 1
      else:
        line += " equal"
        n_equal += 1
      lines.append(line)
      max_of_errors.append(max(error_1, error_2))
      atomic_numbers.append(
        tiny_pse.table(label_1.split("_")[0]).atomic_number())
  for sort_key,reverse in [(max_of_errors,True), (atomic_numbers,False)]:
    perm = flex.sort_permutation(data=sort_key, reverse=reverse)
    perm_lines = flex.select(lines, perm)
    for line in perm_lines:
      print(line)
    print()
  print("n_less:", n_less)
  print("n_greater:", n_greater)
  print("n_equal:", n_equal)
  print("total:", n_less + n_greater + n_equal)

def main():
  parser = OptionParser(
    usage="usage: python %prog [options] file_name ...")
  parser.add_option("-t", "--itvc",
    action="store", metavar="FILE",
    help="file name for international tables data")
  parser.add_option("-k", "--kissel",
    action="store", metavar="DIRECTORY",
    help="directory name for Kissel data")
  parser.add_option("-c", "--cross_check",
    action="store_true", default=0,
    help="compare two quick_summary.pickle files")
  (options, args) = parser.parse_args()
  if (len(args) < 1):
    parser.print_help()
    return
  assert not (options.itvc and options.kissel)
  if (options.cross): assert len(args) == 2
  if (not options.cross):
    run(
      gaussian_fit_pickle_file_names=args,
      itvc_file_name=options.itvc,
      kissel_dir=options.kissel)
  else:
    cross_check(args)

def run():
  from cctbx.eltbx.development import format_gaussian_fits
  format_gaussian_fits.main()

if (__name__ == "__main__"):
  run()


 *******************************************************************************


 *******************************************************************************
cctbx/eltbx/development/hydrogen_plots.py
from __future__ import absolute_import, division, print_function
from cctbx.eltbx import xray_scattering
import sys
from six.moves import range
from six.moves import zip

# ITC 2006 Table 6.1.1.2. Spherical bonded hydrogen-atom scattering
# factors from Stewart, Davidson & Simpson (1965)
itc_tab_6112 = [
  (0.0000, 1.0000),
  (0.0215, 0.9924),
  (0.0429, 0.9704),
  (0.0644, 0.9352),
  (0.0859, 0.8892),
  (0.1073, 0.8350),
  (0.1288, 0.7752),
  (0.1503, 0.7125),
  (0.1718, 0.6492),
  (0.1932, 0.5871),
  (0.2147, 0.5277),
  (0.2576, 0.4201),
  (0.3006, 0.3301),
  (0.3435, 0.2573),
  (0.3864, 0.1998),
  (0.4294, 0.1552),
  (0.4723, 0.1208),
  (0.5153, 0.0945),
  (0.5582, 0.0744),
  (0.6011, 0.0592),
  (0.6441, 0.0474),
  (0.6870, 0.0383),
  (0.7300, 0.0311),
  (0.7729, 0.0254),
  (0.8158, 0.0208),
  (0.8588, 0.0171),
  (0.9017, 0.0140),
  (0.9447, 0.0116),
  (0.9876, 0.0096),
  (1.0305, 0.0080),
  (1.0735, 0.0066),
  (1.1164, 0.0056),
  (1.1593, 0.0047),
  (1.2023, 0.0040),
  (1.2452, 0.0035),
  (1.2882, 0.0031),
  (1.3311, 0.0027),
  (1.3740, 0.0025),
  (1.4170, 0.0022),
  (1.4599, 0.0020),
  (1.5029, 0.0018),
  (1.5458, 0.0016),
  (1.5887, 0.0015),
  (1.6317, 0.0013),
  (1.6746, 0.0011),
  (1.7176, 0.0010)]

class fit_input(object):
  def __init__(O):
    from scitbx.array_family import flex
    O.stols, O.data = [flex.double(vals) for vals in zip(*itc_tab_6112)]
    O.stols.append(6)
    O.data.append(0)
    O.sigmas = flex.double(O.data.size(), 0.00005)
    assert sorted(O.stols) == list(O.stols)

def run(args):
  assert len(args) == 0
  sds_it = xray_scattering.it1992("H").fetch()
  sds_wk = xray_scattering.wk1995("H").fetch()
  sds_ng = xray_scattering.n_gaussian_table_entry("H", 6).gaussian()
  iso_it = xray_scattering.it1992("Hiso").fetch()
  iso_wk = xray_scattering.wk1995("Hiso").fetch()
  iso_ng = xray_scattering.n_gaussian_table_entry("Hiso", 6).gaussian()
  print("@with g0")
  print('@ s0 legend "SDS ITC Tab 6.1.1.2"')
  for i,lbl in enumerate(["SDS IT", "SDS WK", "SDS NG",
                          "ISO IT", "ISO WK", "ISO NG"]):
    print('@ s%d legend "%s"' % (i+1, lbl))
  print("@ s0 symbol 1")
  print("@ s0 line linestyle 0")
  for x,y in itc_tab_6112:
    print(x, y)
  print("&")
  n_samples = 1000
  for g in [sds_it, sds_wk, sds_ng, iso_it, iso_wk, iso_ng]:
    for i_stol in range(n_samples+1):
      stol = 6 * i_stol / n_samples
      print(stol, g.at_stol(stol))
    print("&")

if (__name__ == "__main__"):
  run(args=sys.argv[1:])


 *******************************************************************************


 *******************************************************************************
cctbx/eltbx/development/itvc_approx.py
from __future__ import absolute_import, division, print_function
from cctbx.eltbx.development import itvc_section61_io
from cctbx.eltbx import xray_scattering
import scitbx.math.gaussian_fit
import cctbx.eltbx.gaussian_fit
from cctbx.array_family import flex
from libtbx.option_parser import OptionParser
import sys, os
from six.moves import range
from six.moves import zip

def run(file_name, table_of_gaussians, cutoff,
        low_resolution_only=False,
        high_resolution_only=False,
        significant_errors_only=False,
        plots_dir=None,
        quiet=0,
        verbose=0):
  assert not (low_resolution_only and high_resolution_only)
  tab = itvc_section61_io.read_table6111(file_name)
  for wk in xray_scattering.wk1995_iterator():
    label = wk.label()
    if (not label in tab.entries):
      print("Warning: missing scatterer:", label)
  stols = cctbx.eltbx.gaussian_fit.international_tables_stols
  sel = stols <= cutoff + 1.e-6
  stols = stols.select(sel)
  if (low_resolution_only):
    sel = stols <= 2
    stols = stols.select(sel)
    assert stols.size() == 56
  elif (high_resolution_only):
    sel = stols > 2
    stols = stols.select(sel)
    assert stols.size() == 6
  range_62 = flex.size_t(range(62))
  labels = flex.std_string()
  errors = []
  correlations = flex.double()
  max_errors = flex.double()
  cmp_plots = flex.std_string()
  for element in tab.elements:
    entry = tab.entries[element]
    wk = table_of_gaussians(element, 1)
    assert entry.table_y.size() == 62
    if (not flex.sort_permutation(data=entry.table_y, reverse=True)
            .all_eq(range_62)):
      print("Increasing: %s (%d)" % (element, entry.atomic_number))
      prev_y = entry.table_y[0]
      for y in entry.table_y:
        if (y > prev_y):
          print("higher:", y, "before:", prev_y)
        prev_y = y
      raise RuntimeError("Data values are not increasing.")
    if (low_resolution_only):
      gaussian_fit = scitbx.math.gaussian.fit(
        stols,
        entry.table_y[:-6],
        entry.table_sigmas[:-6],
        wk.fetch())
    elif (high_resolution_only):
      gaussian_fit = scitbx.math.gaussian.fit(
        stols,
        entry.table_y[-6:],
        entry.table_sigmas[-6:],
        wk.fetch())
    elif (    entry.element != entry.atomic_symbol
          and entry.table_y[-6:].all_eq(0)):
      atom_entry = tab.entries[entry.atomic_symbol]
      patched_table_y = entry.table_y[:-6]
      patched_table_y.append(atom_entry.table_y[-6:])
      patched_table_sigmas = entry.table_sigmas[:-6]
      patched_table_sigmas.append(atom_entry.table_sigmas[-6:])
      gaussian_fit = scitbx.math.gaussian.fit(
        stols,
        patched_table_y,
        patched_table_sigmas,
        wk.fetch())
    else:
      gaussian_fit = scitbx.math.gaussian.fit(
        stols,
        entry.table_y[:stols.size()],
        entry.table_sigmas[:stols.size()],
        wk.fetch())
    labels.append(element)
    errors.append(gaussian_fit.significant_relative_errors())
    max_errors.append(flex.max(errors[-1]))
    correlations.append(flex.linear_correlation(
      gaussian_fit.table_y(), gaussian_fit.fitted_values()).coefficient())
    if (plots_dir is not None):
      if (not os.path.isdir(plots_dir)):
        print("No plots because the directory %s does not exist." % plots_dir)
        plots_dir = None
      else:
        cmp_plots.append(cctbx.eltbx.gaussian_fit.write_plots(
          plots_dir=plots_dir,
          label=element,
          gaussian_fit=gaussian_fit))
  perm = flex.sort_permutation(data=max_errors, reverse=True)
  labels = labels.select(perm)
  errors = flex.select(errors, perm)
  correlations = correlations.select(perm)
  if (plots_dir is None):
    cmp_plots = [None] * len(labels)
  else:
    cmp_plots = cmp_plots.select(perm)
  for l,e,cc,p in zip(labels, errors, correlations, cmp_plots):
    entry = tab.entries[l]
    y = entry.table_y
    perm = flex.sort_permutation(data=e, reverse=True)[:3]
    high = []
    for i in perm:
      if (significant_errors_only and e[i] < 0.01): break
      s = stols[i]
      a = ""
      if (not quiet and s < 2.1): a = "@%.3f" % y[i]
      high.append("%7.4f %4.2f%s" % (e[i],s,a))
      if (high_resolution_only): break
    if (verbose or len(high) > 0):
      print("Element %-5s(%2d) cc=%.4f:" % (
        l, entry.atomic_number, cc), ", ".join(high))
    if (verbose and p is not None):
      print(p)
      sys.stdout.write(open(p).read())
      print()

def main():
  parser = OptionParser(
    usage="usage: python %prog [options] file_name")
  parser.add_option("-t", "--table", default="wk1995",
    action="store", dest="table_of_gaussians",
    help="wk1995 or it1992")
  parser.add_option("-q", "--quiet",
    action="store_true", default=0,
    help="do not show values for large errors, only stol")
  parser.add_option("-v", "--verbose",
    action="store_true", default=0,
    help="show comparison table for each element")
  parser.add_option("-l", "--low_resolution_only",
    action="store_true", default=0,
    help="analyze points up to sin(theta)/lambda=2A-1 only")
  parser.add_option("-g", "--high_resolution_only",
    action="store_true", default=0,
    help="analyze points beyond sin(theta)/lambda=2A-1 only")
  parser.add_option("-s", "--significant_errors_only",
    action="store_true", default=0,
    help="show errors greater than 1% only")
  (options, args) = parser.parse_args()
  if (len(args) != 1):
    parser.print_help()
    return
  assert options.table_of_gaussians in ["wk1995", "it1992"]
  if (options.table_of_gaussians == "wk1995"):
    table_of_gaussians = xray_scattering.wk1995
    plots_dir = "itvc_wk1995_plots"
    cutoff = 6
  else:
    table_of_gaussians = xray_scattering.it1992
    plots_dir = "itvc_it1992_plots"
    cutoff = 2
    assert not options.low_resolution_only
    assert not options.high_resolution_only
  print("table_of_gaussians:", options.table_of_gaussians)
  run(
    file_name=args[0],
    table_of_gaussians=table_of_gaussians,
    cutoff=cutoff,
    low_resolution_only=options.low_resolution_only,
    high_resolution_only=options.high_resolution_only,
    significant_errors_only=options.significant_errors_only,
    plots_dir=plots_dir,
    quiet=options.quiet,
    verbose=options.verbose)

if (__name__ == "__main__"):
  main()


 *******************************************************************************


 *******************************************************************************
cctbx/eltbx/development/itvc_cross_validation.py
from __future__ import absolute_import, division, print_function
from cctbx.eltbx.development import itvc_section61_io
from cctbx.eltbx.gaussian_fit import international_tables_stols
from libtbx.option_parser import OptionParser
from six.moves import zip

def show_differences_if_any(label, stols, y0, y1):
  if (not y0.all_eq(y1)):
    print("Different:", label)
    for stol,y0i,y1i in zip(stols,y0,y1):
      if (y0i != y1i):
        print(stol, y0i, y1i)

def run(file_names):
  assert len(file_names) == 2
  tabs = []
  for file_name in file_names:
    tabs.append(itvc_section61_io.read_table6111(file_name))
  all_labels = {}
  for tab in tabs:
    for label in tab.elements: all_labels[label] = 1
  for label in all_labels:
    e0 = tabs[0].entries.get(label, None)
    e1 = tabs[1].entries.get(label, None)
    if ([e0,e1].count(None) == 0):
      assert e0.atomic_number == e1.atomic_number, \
        (label, e0.atomic_number, e1.atomic_number)
      assert e0.method == e1.method, \
        (label, e0.method, e1.method)
      min_size = min(e0.table_y.size(), e1.table_y.size())
      show_differences_if_any(
        label=label,
        y0=e0.table_y[:min_size],
        y1=e1.table_y[:min_size],
        stols=international_tables_stols[:min_size])
    for tab in tabs:
      ei = tab.entries.get(label, None)
      if (ei is not None and ei.element != ei.atomic_symbol):
        ee = tab.entries.get(ei.atomic_symbol, None)
        if ([ee,ei].count(None) == 0):
          assert ee.table_y.size() == 62
          assert ei.table_y.size() == 62
          show_differences_if_any(
            label=label,
            y0=ee.table_y[-6:],
            y1=ei.table_y[-6:],
            stols=international_tables_stols[-6:])

def main():
  parser = OptionParser(
    usage="usage: python %prog [options] file_name_1 file_name_2")
  (options, args) = parser.parse_args()
  if (len(args) != 2):
    parser.print_help()
    return
  run(file_names=args)

if (__name__ == "__main__"):
  main()


 *******************************************************************************


 *******************************************************************************
cctbx/eltbx/development/itvc_fits.py
from __future__ import absolute_import, division, print_function
from cctbx.eltbx.development import itvc_section61_io
from cctbx.eltbx.development import rez_rez_grant
from cctbx.eltbx.development.create_n_gaussian_raw_cpp import identifier
from cctbx.eltbx import xray_scattering
import scitbx.math.gaussian_fit
import cctbx.eltbx.gaussian_fit
from libtbx.option_parser import OptionParser
from libtbx.utils import user_plus_sys_time
from libtbx import easy_pickle
import sys, os

def run(file_name, args, cutoff, params,
        zig_zag=False, six_term=False, full_fits=None,
        plots_dir="itvc_fits_plots", verbose=0):
  tab = itvc_section61_io.read_table6111(file_name)
  chunk_n = 1
  chunk_i = 0
  if (len(args) > 0 and len(args[0].split(",")) == 2):
    chunk_n, chunk_i = [int(i) for i in args[0].split(",")]
    args = args[1:]
  if (not six_term and not zig_zag):
    if (not os.path.isdir(plots_dir)):
      print("No plots because target directory does not exist (mkdir %s)." % \
        plots_dir)
      plots_dir = None
    if (chunk_n > 1):
      assert plots_dir is not None
  stols_more = cctbx.eltbx.gaussian_fit.international_tables_stols
  sel = stols_more <= cutoff + 1.e-6
  stols = stols_more.select(sel)
  i_chunk = 0
  for element in tab.elements + ["O2-", "SDS"]:
    if (len(args) > 0 and element not in args): continue
    flag = i_chunk % chunk_n == chunk_i
    i_chunk += 1
    if (not flag):
      continue
    results = {}
    results["fit_parameters"] = params
    if (element == "SDS"):
      wrk_lbl = element
      from cctbx.eltbx.development.hydrogen_plots import fit_input
      fi = fit_input()
      sel = fi.stols <= cutoff + 1.e-6
      null_fit = scitbx.math.gaussian.fit(
        fi.stols.select(sel),
        fi.data.select(sel),
        fi.sigmas.select(sel),
        xray_scattering.gaussian(0, False))
      null_fit_more = scitbx.math.gaussian.fit(
        fi.stols,
        fi.data,
        fi.sigmas,
        xray_scattering.gaussian(0, False))
    else:
      wrk_lbl = xray_scattering.wk1995(element, True)
      if (element != "O2-"):
        entry = tab.entries[element]
        null_fit = scitbx.math.gaussian.fit(
          stols,
          entry.table_y[:stols.size()],
          entry.table_sigmas[:stols.size()],
          xray_scattering.gaussian(0, False))
        null_fit_more = scitbx.math.gaussian.fit(
          stols_more,
          entry.table_y[:stols_more.size()],
          entry.table_sigmas[:stols_more.size()],
          xray_scattering.gaussian(0, False))
      else:
        rrg_stols_more = rez_rez_grant.table_2_stol
        sel = rrg_stols_more <= cutoff + 1.e-6
        rrg_stols = rrg_stols_more.select(sel)
        null_fit = scitbx.math.gaussian.fit(
          rrg_stols,
          rez_rez_grant.table_2_o2minus[:rrg_stols.size()],
          rez_rez_grant.table_2_sigmas[:rrg_stols.size()],
          xray_scattering.gaussian(0, False))
        null_fit_more = scitbx.math.gaussian.fit(
          rrg_stols_more,
          rez_rez_grant.table_2_o2minus[:rrg_stols_more.size()],
          rez_rez_grant.table_2_sigmas[:rrg_stols_more.size()],
          xray_scattering.gaussian(0, False))
    if (zig_zag):
      results[wrk_lbl] = cctbx.eltbx.gaussian_fit.zig_zag_fits(
        label=wrk_lbl,
        null_fit=null_fit,
        null_fit_more=null_fit_more,
        params=params)
    elif (full_fits is not None):
      assert len(full_fits.all[wrk_lbl]) == 1
      results[wrk_lbl] = cctbx.eltbx.gaussian_fit.decremental_fits(
        label=wrk_lbl,
        null_fit=null_fit,
        full_fit=full_fits.all[wrk_lbl][0],
        params=params,
        plots_dir=plots_dir,
        verbose=verbose)
    elif (not six_term):
      results[wrk_lbl] = cctbx.eltbx.gaussian_fit.incremental_fits(
        label=wrk_lbl,
        null_fit=null_fit,
        params=params,
        plots_dir=plots_dir,
        verbose=verbose)
    else:
      best_min = scitbx.math.gaussian_fit.fit_with_golay_starts(
        label=wrk_lbl,
        null_fit=null_fit,
        null_fit_more=null_fit_more,
        params=params)
      g = best_min.final_gaussian_fit
      results[wrk_lbl] = [xray_scattering.fitted_gaussian(
        stol=g.table_x()[-1], gaussian_sum=g)]
    sys.stdout.flush()
    pickle_file_name = "%s_fits.pickle" % identifier(wrk_lbl)
    easy_pickle.dump(pickle_file_name, results)

def run_and_time(*args, **kw):
  timer = user_plus_sys_time()
  try:
    run(*args, **kw)
  finally:
    print("CPU time: %.2f seconds" % timer.elapsed())

def main():
  parser = OptionParser(
    usage="usage: python %prog file_name [n_chunks,i_chunk] [scatterer...]")
  parser.add_option("-v", "--verbose",
    action="store_true", default=0,
    help="show comparison table for each element")
  parser.add_option("-c", "--cutoff",
    type="float", default=6, metavar="FLOAT",
    help="maximum sin(theta)/lambda")
  parser.add_option("-q", "--quick",
    action="store_true", default=0,
    help="quick mode for debugging")
  parser.add_option("-n", "--max_n_terms",
    type="int", default=5, metavar="INT",
    help="maximum number of Gaussian terms")
  parser.add_option("-e", "--max_max_error",
    type="float", default=0.01, metavar="FLOAT",
    help="max acceptable max_error")
  parser.add_option("-s", "--six_term",
    action="store_true", default=0,
    help="fit six-term Gaussians using Golay based starts")
  parser.add_option("-z", "--zig_zag",
    action="store_true", default=0,
    help="zig-zag fits starting from six-term Gaussians")
  parser.add_option("-r", "--full_fits",
    action="store",
    help="pickled six-term Gaussian fits")
  (options, args) = parser.parse_args()
  if (len(args) < 1):
    parser.print_help()
    return
  assert [options.six_term, options.zig_zag, options.full_fits].count(True) < 2
  if (options.full_fits is not None):
    full_fits = easy_pickle.load(options.full_fits)
  else:
    full_fits = None
  params = cctbx.eltbx.gaussian_fit.fit_parameters(
    max_n_terms=options.max_n_terms,
    max_max_error=options.max_max_error)
  if (options.quick):
    params = params.quick()
  run_and_time(
    file_name=args[0],
    args=args[1:],
    cutoff=options.cutoff,
    params=params,
    zig_zag=options.zig_zag,
    six_term=options.six_term,
    full_fits=full_fits,
    verbose=options.verbose)

if (__name__ == "__main__"):
  main()


 *******************************************************************************


 *******************************************************************************
cctbx/eltbx/development/itvc_kissel.py
from __future__ import absolute_import, division, print_function
from cctbx.eltbx.development import itvc_section61_io
from cctbx.eltbx.development import kissel_io
import cctbx.eltbx.gaussian_fit
from cctbx.array_family import flex
from libtbx.option_parser import OptionParser
import cStringIO as StringIO
import sys, os
from six.moves import zip

def run(args, cutoff, high_resolution_only,
        plots_dir="itvc_kissel_plots", verbose=0):
  itab = itvc_section61_io.read_table6111(args[0])
  itab_x = cctbx.eltbx.gaussian_fit.international_tables_stols
  isel = itab_x <= cutoff + 1.e-6
  if (high_resolution_only):
    isel &= itab_x > 2 + 1.e-6
  itab_x = itab_x.select(isel)
  for file_name in args[1:]:
    ktab = kissel_io.read_table(file_name)
    if (ktab.element == "Es"): continue
    sel = ktab.x <= cutoff + 1
    ktab_x = ktab.x.select(sel)
    ktab_y = ktab.y.select(sel)
    ktabs_sigmas = ktab.sigmas.select(sel)
    itab_entry = itab.entries[ktab.element]
    itab_y = itab_entry.table_y.select(isel)
    itab_sigmas = itab_entry.table_sigmas.select(isel)
    f = open(os.path.join(plots_dir, ktab.element + ".xy"), "w")
    cctbx.eltbx.gaussian_fit.write_plot(f, ktab_x, ktab_y)
    cctbx.eltbx.gaussian_fit.write_plot(f, itab_x, itab_y)
    f.close()
    ktab_y_i = flex.linear_interpolation(ktab.x, ktab.y, itab_x)
    ktab_sigmas_i = flex.linear_interpolation(ktab.x, ktab.sigmas, itab_x)
    assert ktab_y_i.all_gt(0)
    s = StringIO.StringIO()
    print("stol  kissel    itvc   delta sig_itvc rel_sig rel_del tol_del", file=s)
    max_delta = 0
    max_tol_del = 0
    for x,ky,ksig,iy,isig in zip(itab_x, ktab_y_i, ktab_sigmas_i,
                                         itab_y, itab_sigmas):
      if (iy > 0): ie = "%7.4f" % abs(isig/iy)
      else: ie = " ******"
      delta = iy - ky
      rel_del = abs(delta) / ky
      tol_del = max(0, abs(delta)-ksig-isig) / ky
      print("%4.2f %7.4f %7.4f %7.4f %8.5f %-s %7.4f %7.4f" % (
        x,ky,iy,delta,isig,ie,rel_del,tol_del), file=s)
      max_delta = max(max_delta, abs(delta))
      max_tol_del = max(max_tol_del, tol_del)
    print("Element:", ktab.element, "max_delta=%.4f, max_tol_del=%.4f" % (
      max_delta, max_tol_del))
    sys.stdout.write(s.getvalue())
    print()

def main():
  parser = OptionParser(
    usage="usage: python %prog [options] itvc_table kissel_files ...")
  parser.add_option("-c", "--cutoff",
    type="float", default=6, metavar="FLOAT",
    help="maximum sin(theta)/lambda")
  parser.add_option("-g", "--high_resolution_only",
    action="store_true", default=0,
    help="analyze points beyond sin(theta)/lambda=2A-1 only")
  (options, args) = parser.parse_args()
  if (len(args) < 2):
    parser.print_help()
    return
  run(
    args=args,
    cutoff=options.cutoff,
    high_resolution_only=options.high_resolution_only)

if (__name__ == "__main__"):
  main()


 *******************************************************************************


 *******************************************************************************
cctbx/eltbx/development/itvc_section61_io.py
from __future__ import absolute_import, division, print_function
from cctbx.eltbx.gaussian_fit import international_tables_stols
from cctbx.array_family import flex
from libtbx.str_utils import line_feeder
from libtbx import adopt_init_args
from six.moves import zip

class table6111_entry(object):

  def __init__(self, element, atomic_number, method, table_y, table_sigmas):
    assert table_y.size() == table_sigmas.size()
    adopt_init_args(self, locals())
    self.atomic_symbol = element
    if (element == "Cval"):
      self.atomic_symbol = "C"
    elif (element == "Sival"):
      self.atomic_symbol = "Si"
    else:
      for sign in ["+", "-"]:
        i = element.find(sign)
        if (i > 0):
          self.element = element.replace(sign,"") + sign
          self.atomic_symbol = element[:i]
          break

class table6111(object):

  def __init__(self, file_name):
    self.file_name = file_name
    self.entries = {}
    self.elements = []

  def enter_entry(self, entry):
    self.entries[entry.element] = entry
    self.elements.append(entry.element)

  def enter_block(self,elements,atomic_numbers,methods,value_rows,sigma_rows):
    i_column = -1
    for element,atomic_number,method in zip(elements,atomic_numbers,methods):
      i_column += 1
      table_y = flex.double()
      table_sigmas = flex.double()
      for value_row,sigma_row in zip(value_rows,sigma_rows):
        table_y.append(value_row[i_column])
        table_sigmas.append(sigma_row[i_column])
      self.enter_entry(table6111_entry(
        element, atomic_number, method, table_y, table_sigmas))

def read_table6111(file_name):
  tab = table6111(file_name)
  lf = line_feeder(open(file_name))
  while 1:
    line = next(lf)
    if (lf.eof): break
    if (line.startswith("Element")):
      elements = line.split()[1:]
      line = next(lf)
      assert line.lstrip().startswith("Z"), line
      atomic_numbers = [int(z) for z in line.split()[1:]]
      assert len(atomic_numbers) == len(elements), line
      line = next(lf)
      assert line.startswith("Method"), line
      methods = line.split()[1:]
      assert len(methods) == len(elements), line
      line = next(lf)
      assert line.find("sin") > 0, line
      stols = flex.double()
      value_rows = []
      sigma_rows = []
      while 1:
        line = next(lf)
        assert not lf.eof
        if (len(line.strip()) == 0): continue
        raw_value_row = line.rstrip().split("\t")
        assert len(raw_value_row) == len(elements) + 1, line
        stols.append(float(raw_value_row[0]))
        assert stols[-1] == international_tables_stols[stols.size()-1], line
        value_row = flex.double()
        sigma_row = flex.double()
        for value in raw_value_row[1:]:
          if (len(value.strip()) == 0):
            value_row.append(-1)
            sigma_row.append(-1)
          else:
            try: value_row.append(float(value))
            except ValueError as e: raise ValueError(line)
            assert value.count(".") == 1
            sigma = ""
            for c in value.strip():
              if (c == "."):
                sigma += "."
              else:
                assert c in "0123456789"
                sigma += "0"
            sigma += "5"
            sigma_row.append(float(sigma))
        value_rows.append(value_row)
        sigma_rows.append(sigma_row)
        if (stols.size() == 62):
          assert stols[-1] == 6, line
          break
      tab.enter_block(elements,atomic_numbers,methods,value_rows,sigma_rows)
  return tab


 *******************************************************************************


 *******************************************************************************
cctbx/eltbx/development/kissel_fits.py
from __future__ import absolute_import, division, print_function
from cctbx.eltbx.development import kissel_io
from cctbx.eltbx.development.create_n_gaussian_raw_cpp import identifier
from cctbx.eltbx import xray_scattering
import scitbx.math.gaussian_fit
import cctbx.eltbx.gaussian_fit
from libtbx.utils import user_plus_sys_time
from libtbx.option_parser import OptionParser
from libtbx import easy_pickle
import sys, os

def run(args, cutoff, max_n_terms, six_term=False, params=None,
        plots_dir="kissel_fits_plots", verbose=0):
  if (params is None):
    params = cctbx.eltbx.gaussian_fit.fit_parameters(
      max_n_terms=max_n_terms)
  chunk_n = 1
  chunk_i = 0
  if (len(args) > 0 and len(args[0].split(",")) == 2):
    chunk_n, chunk_i = [int(i) for i in args[0].split(",")]
    args = args[1:]
  if (not six_term):
    if (not os.path.isdir(plots_dir)):
      print("No plots because target directory does not exist (mkdir %s)." % \
        plots_dir)
      plots_dir = None
    if (chunk_n > 1):
      assert plots_dir is not None
  i_chunk = 0
  for file_name in args:
    flag = i_chunk % chunk_n == chunk_i
    i_chunk += 1
    if (not flag):
      continue
    results = {}
    results["fit_parameters"] = params
    tab = kissel_io.read_table(file_name)
    more_selection = tab.itvc_sampling_selection()
    fit_selection = more_selection & (tab.x <= cutoff + 1.e-6)
    null_fit = scitbx.math.gaussian.fit(
      tab.x.select(fit_selection),
      tab.y.select(fit_selection),
      tab.sigmas.select(fit_selection),
      xray_scattering.gaussian(0, False))
    null_fit_more = scitbx.math.gaussian.fit(
      tab.x.select(more_selection),
      tab.y.select(more_selection),
      tab.sigmas.select(more_selection),
      xray_scattering.gaussian(0, False))
    if (not six_term):
      results[tab.element] = cctbx.eltbx.gaussian_fit.incremental_fits(
        label=tab.element,
        null_fit=null_fit,
        params=params,
        plots_dir=plots_dir,
        verbose=verbose)
    else:
      best_min = scitbx.math.gaussian_fit.fit_with_golay_starts(
        label=tab.element,
        null_fit=null_fit,
        null_fit_more=null_fit_more,
        params=params)
      g = best_min.final_gaussian_fit
      results[tab.element] = [xray_scattering.fitted_gaussian(
        stol=g.table_x()[-1], gaussian_sum=g)]
    sys.stdout.flush()
    pickle_file_name = "%s_fits.pickle" % identifier(tab.element)
    easy_pickle.dump(pickle_file_name, results)

def run_and_time(*args, **kw):
  timer = user_plus_sys_time()
  try:
    run(*args, **kw)
  finally:
    print("CPU time: %.2f seconds" % timer.elapsed())

def main():
  parser = OptionParser(
    usage="usage: python %prog file_name [n_chunks,i_chunk] [scatterer...]")
  parser.add_option("-v", "--verbose",
    action="store_true", default=0,
    help="show comparison table for each element")
  parser.add_option("-c", "--cutoff",
    type="float", default=6, metavar="FLOAT",
    help="maximum sin(theta)/lambda")
  parser.add_option("-n", "--max_n_terms",
    type="int", default=5, metavar="INT",
    help="maximum number of Gaussian terms")
  parser.add_option("-s", "--six_term",
    action="store_true", default=0,
    help="fit six-term Gaussians using Golay based starts")
  (options, args) = parser.parse_args()
  if (len(args) < 1):
    parser.print_help()
    return
  run_and_time(
    args=args,
    cutoff=options.cutoff,
    max_n_terms=options.max_n_terms,
    six_term=options.six_term,
    verbose=options.verbose)

if (__name__ == "__main__"):
  main()


 *******************************************************************************


 *******************************************************************************
cctbx/eltbx/development/kissel_io.py
from __future__ import absolute_import, division, print_function
from cctbx.eltbx import xray_scattering
from cctbx.eltbx import tiny_pse
from cctbx.array_family import flex
import cctbx.eltbx.gaussian_fit
import scitbx.math.gaussian
from libtbx.str_utils import line_feeder
from libtbx.option_parser import OptionParser
from libtbx import adopt_init_args
from six.moves import range
from six.moves import zip

class table(object):

  def __init__(self, atomic_number, x, y, sigmas):
    adopt_init_args(self, locals())
    self.element = tiny_pse.table(atomic_number).symbol()

  def itvc_sampling_selection(self):
    xi = cctbx.eltbx.gaussian_fit.international_tables_stols
    xk = self.x
    selection = flex.bool(xk.size(), False)
    i_kissel = 0
    for i_itvc in range(xi.size()):
      while (xk[i_kissel] < xi[i_itvc]):
        i_kissel += 1
      if (xk[i_kissel] == xi[i_itvc]):
        selection[i_kissel] = True
      elif (i_kissel > 0 and xk[i_kissel-1] < xi[i_itvc] < xk[i_kissel]):
        if (xi[i_itvc] - xk[i_kissel-1] < xk[i_kissel] - xi[i_itvc]):
          selection[i_kissel-1] = True
        else:
          selection[i_kissel] = True
    return selection

def read_table(file_name):
  atomic_number = None
  number_of_electrons = None
  x = flex.double()
  y = flex.double()
  sigmas = flex.double()
  lf = line_feeder(open(file_name))
  while 1:
    line = next(lf)
    if (lf.eof): break
    if (line.startswith("   FORM: ATOMIC NUMBER=")):
      atomic_number = float(line.split("=")[1])
      assert int(atomic_number) == atomic_number
    elif (line.startswith("   FORM: # ELECTRONS=")):
      number_of_electrons = float(line.split("=")[1])
      assert int(number_of_electrons) == number_of_electrons
    elif (line.startswith("        X (1/A)")):
      assert atomic_number == number_of_electrons
      while 1:
        line = next(lf)
        assert not lf.eof
        if (line == " *** END OF DATA ***"):
          lf.eof = True
          break
        vals_str = line.split()
        for val_str in vals_str: assert len(val_str) == 13
        x.append(float(vals_str[0]))
        y.append(float(vals_str[1]))
        assert vals_str[1][-4] == "E"
        sigmas.append(float("0.00000005"+vals_str[1][-4:]))
  return table(int(atomic_number), x, y*atomic_number, sigmas)

def main():
  parser = OptionParser(
    usage="usage: python %prog [options] file_name ...")
  parser.add_option("-c", "--cutoff",
    type="float", default=6.05, metavar="FLOAT",
    help="maximum sin(theta)/lambda")
  (options, args) = parser.parse_args()
  if (len(args) < 1):
    parser.print_help()
    return
  cutoff = options.cutoff
  for file_name in args:
    tab = read_table(file_name)
    if (tab.element == "Es"): continue
    wk = xray_scattering.wk1995(tab.element, True).fetch()
    sel = tab.x <= cutoff
    tab_x = tab.x.select(sel)
    tab_y = tab.y.select(sel)
    sigmas = flex.double(tab_x.size(), 0.0005)
    wky = wk.at_x(tab_x)
    errors_abs = flex.abs(wky-tab_y)
    fit = scitbx.math.gaussian.fit(tab_x, tab_y, sigmas, wk)
    errors_rel = fit.significant_relative_errors(1.e-6)
    print(tab.element, tab.atomic_number, end=' ')
    print("max error < %.1fA-1 abs, rel: %7.4f %7.4f" % (
      cutoff, flex.max(errors_abs), flex.max(errors_rel)))
    for x,y,f,ea,er in zip(tab_x,tab_y,wky,errors_abs,errors_rel):
      print("%7.4f %7.4f %7.4f %7.4f %7.4f" % (x, y, f, ea, er))
    print()

if (__name__ == "__main__"):
  main()


 *******************************************************************************


 *******************************************************************************
cctbx/eltbx/development/rez_rez_grant.py
from __future__ import absolute_import, division, print_function
from cctbx.eltbx import xray_scattering
import scitbx.math.gaussian_fit
import cctbx.eltbx.gaussian_fit
from cctbx.array_family import flex

# D. Rez, P. Rez & I. Grant
# Acta Cryst. (1994). A50, 481-497
table_2_stol = flex.double([
0.00,
0.05,
0.10,
0.15,
0.20,
0.25,
0.30,
0.35,
0.40,
0.45,
0.50,
0.60,
0.70,
0.80,
0.90,
1.00,
1.20,
1.40,
1.60,
1.80,
2.00,
2.50,
3.00,
3.50,
4.00,
5.00,
6.00])

table_2_o2minus = flex.double([
10.0000,
9.5884,
8.5345,
7.2188,
5.9558,
4.8934,
4.0574,
3.4190,
2.9364,
2.5720,
2.2963,
1.9275,
1.7085,
1.5678,
1.4644,
1.3774,
1.2191,
1.0668,
0.9215,
0.7881,
0.6696,
0.4404,
0.2907,
0.1951,
0.1332,
0.0686,
0.0351])

table_2_sigmas = flex.double(table_2_stol.size(), 0.00005)

def run():
  wk = xray_scattering.wk1995("O2-")
  gaussian_fit = scitbx.math.gaussian.fit(
    table_2_stol,
    table_2_o2minus,
    table_2_sigmas,
    wk.fetch())
  print("max error:", flex.max(gaussian_fit.significant_relative_errors()))
  cctbx.eltbx.gaussian_fit.write_plots(
    plots_dir="rez_plots",
    label=wk.label(),
    gaussian_fit=gaussian_fit)

if (__name__ == "__main__"):
  run()


 *******************************************************************************


 *******************************************************************************
cctbx/eltbx/distance_based_connectivity.py
from __future__ import absolute_import, division, print_function
import math
from six.moves import range

expected_bond_lengths_by_element_pair = {
  # based on elbow/chemistry/BondLengths.py rev. 42
  # max of averages, rounded to one decimal
('H', 'H'): 0.0,
('AL', 'F'): 1.8,
('AS', 'C'): 2.0,
('AS', 'O'): 1.7,
('B', 'C'): 1.6,
('B', 'O'): 1.5,
('BR', 'C'): 2.0,
('C', 'C'): 1.5,
('C', 'CL'): 1.8,
('C', 'F'): 1.3,
('C', 'H'): 1.1,
('C', 'HG'): 2.3,
('C', 'N'): 1.4,
('C', 'O'): 1.4,
('C', 'P'): 1.7,
('C', 'S'): 1.7,
('C', 'SE'): 1.9,
('CO', 'N'): 2.0,
('CU', 'N'): 2.1,
('CU', 'O'): 1.8,
('F', 'O'): 1.8,
('FE', 'FE'): 2.2,
('FE', 'N'): 2.0,
('FE', 'O'): 2.0,
('FE', 'S'): 2.2,
('H', 'N'): 1.0,
('H', 'O'): 1.0,
('H', 'S'): 1.0,
('HG', 'O'): 2.3,
('MG', 'N'): 2.0,
('MG', 'O'): 2.2,
('N', 'N'): 1.3,
('N', 'NI'): 2.1,
('N', 'O'): 1.4,
('N', 'P'): 1.6,
('N', 'RU'): 1.8,
('N', 'S'): 1.6,
('O', 'O'): 1.4,
('O', 'P'): 1.6,
('O', 'S'): 1.5,
('O', 'U'): 1.8,
('O', 'V'): 2.0,
('O', 'W'): 2.0,
('P', 'S'): 1.7,
('S', 'S'): 2.0}

# XXX cctbx.crystal.distance_based_connectivity.build_simple_two_way_bond_sets
# XXX should be used instead
def build_edge_list(sites_cart, elements,slop=0.2):
  result = []
  for ii in range(len(sites_cart)):
    x1,y1,z1 = sites_cart[ii]
    for jj in range(ii+1,len(sites_cart)):
      x2,y2,z2 = sites_cart[jj]
      x2 = x2-x1
      y2 = y2-y1
      z2 = z2-z1
      dd = math.sqrt( x2*x2+y2*y2+z2*z2 )
      expected_dist =  expected_bond_lengths_by_element_pair.get(
        (elements[ii], elements[jj]), False )
      if not expected_dist:
        expected_dist = expected_bond_lengths_by_element_pair.get(
          (elements[jj], elements[ii]), False )
      if not expected_dist:
        expected_dist = 1.7

      if dd <= expected_dist+slop:
        result.append( (ii,jj) )

  return result

def tst_build_edge_list():
  sites_cart = [ (0,0,0), (0,0,1.53), (0,0,3.06) ]
  elements  =  [ 'C', 'O', 'N' ]
  tmp = build_edge_list(sites_cart, elements)
  assert (0,1) in tmp
  assert (1,2) in tmp
  assert (0,2) not in tmp

if __name__ == "__main__":
  tst_build_edge_list()


 *******************************************************************************


 *******************************************************************************
cctbx/eltbx/e_scattering.py
from __future__ import absolute_import, division, print_function
from cctbx.eltbx.xray_scattering import gaussian

# http://it.iucr.org/Cb/ch4o3v0001/sec4o3o2/ 2011-04-25
# Elastic atomic scattering factors of electrons for neutral atoms
#   and s up to 2.0 A^-1
ito_vol_c_2011_table_4_3_2_2 = """\
H 1 0.0349 0.1201 0.1970 0.0573 0.1195 0.5347 3.5867 12.3471 18.9525 38.6269
He 2 0.0317 0.0838 0.1526 0.1334 0.0164 0.2507 1.4751 4.4938 12.6646 31.1653
Li 3 0.0750 0.2249 0.5548 1.4954 0.9354 0.3864 2.9383 15.3829 53.5545 138.7337
Be 4 0.0780 0.2210 0.6740 1.3867 0.6925 0.3131 2.2381 10.1517 30.9061 78.3273
B 5 0.0909 0.2551 0.7738 1.2136 0.4606 0.2995 2.1155 8.3816 24.1292 63.1314
C 6 0.0893 0.2563 0.7570 1.0487 0.3575 0.2465 1.7100 6.4094 18.6113 50.2523
N 7 0.1022 0.3219 0.7982 0.8197 0.1715 0.2451 1.7481 6.1925 17.3894 48.1431
O 8 0.0974 0.2921 0.6910 0.6990 0.2039 0.2067 1.3815 4.6943 12.7105 32.4726
F 9 0.1083 0.3175 0.6487 0.5846 0.1421 0.2057 1.3439 4.2788 11.3932 28.7881
Ne 10 0.1269 0.3535 0.5582 0.4674 0.1460 0.2200 1.3779 4.0203 9.4934 23.1278
Na 11 0.2142 0.6853 0.7692 1.6589 1.4482 0.3334 2.3446 10.0830 48.3037 138.2700
Mg 12 0.2314 0.6866 0.9677 2.1882 1.1339 0.3278 2.2720 10.9241 39.2898 101.9748
Al 13 0.2390 0.6573 1.2011 2.5586 1.2312 0.3138 2.1063 10.4163 34.4552 98.5344
Si 14 0.2519 0.6372 1.3795 2.5082 1.0500 0.3075 2.0174 9.6746 29.3744 80.4732
P 15 0.2548 0.6106 1.4541 2.3204 0.8477 0.2908 1.8740 8.5176 24.3434 63.2996
S 16 0.2497 0.5628 1.3899 2.1865 0.7715 0.2681 1.6711 7.0267 19.5377 50.3888
Cl 17 0.2443 0.5397 1.3919 2.0197 0.6621 0.2468 1.5242 6.1537 16.6687 42.3086
Ar 18 0.2385 0.5017 1.3428 1.8899 0.6079 0.2289 1.3694 5.2561 14.0928 35.5361
K 19 0.4115 1.4031 2.2784 2.6742 2.2162 0.3703 3.3874 13.1029 68.9592 194.4329
Ca 20 0.4054 1.3880 2.1602 3.7532 2.2063 0.3499 3.0991 11.9608 53.9353 142.3892
Sc 21 0.3787 1.2181 2.0594 3.2618 2.3870 0.3133 2.5856 9.5813 41.7688 116.7282
Ti 22 0.3825 1.2598 2.0008 3.0617 2.0694 0.3040 2.4863 9.2783 39.0751 109.4583
V 23 0.3876 1.2750 1.9109 2.8314 1.8979 0.2967 2.3780 8.7981 35.9528 101.7201
Cr 24 0.4046 1.3696 1.8941 2.0800 1.2196 0.2986 2.3958 9.1406 37.4701 113.7121
Mn 25 0.3796 1.2094 1.7815 2.5420 1.5937 0.2699 2.0455 7.4726 31.0604 91.5622
Fe 26 0.3946 1.2725 1.7031 2.3140 1.4795 0.2717 2.0443 7.6007 29.9714 86.2265
Co 27 0.4118 1.3161 1.6493 2.1930 1.2830 0.2742 2.0372 7.7205 29.9680 84.9383
Ni 28 0.3860 1.1765 1.5451 2.0730 1.3814 0.2478 1.7660 6.3107 25.2204 74.3146
Cu 29 0.4314 1.3208 1.5236 1.4671 0.8562 0.2694 1.9223 7.3474 28.9892 90.6246
Zn 30 0.4288 1.2646 1.4472 1.8294 1.0934 0.2593 1.7998 6.7500 25.5860 73.5284
Ga 31 0.4818 1.4032 1.6561 2.4605 1.1054 0.2825 1.9785 8.7546 32.5238 98.5523
Ge 32 0.4655 1.3014 1.6088 2.6998 1.3003 0.2647 1.7926 7.6071 26.5541 77.5238
As 33 0.4517 1.2229 1.5852 2.7958 1.2638 0.2493 1.6436 6.8154 22.3681 62.0390
Se 34 0.4477 1.1678 1.5843 2.8087 1.1956 0.2405 1.5442 6.3231 19.4610 52.0233
Br 35 0.4798 1.1948 1.8695 2.6953 0.8203 0.2504 1.5963 6.9653 19.8492 50.3233
Kr 36 0.4546 1.0993 1.7696 2.7068 0.8672 0.2309 1.4279 5.9449 16.6752 42.2243
Rb 37 1.0160 2.8528 3.5466 -7.7804 12.1148 0.4853 5.0925 25.7851 130.4515 138.6775
Sr 38 0.6703 1.4926 3.3368 4.4600 3.1501 0.3190 2.2287 10.3504 52.3291 151.2216
Y 39 0.6894 1.5474 3.2450 4.2126 2.9764 0.3189 2.2904 10.0062 44.0771 125.0120
Zr 40 0.6719 1.4684 3.1668 3.9557 2.8920 0.3036 2.1249 8.9236 36.8458 108.2049
Nb 41 0.6123 1.2677 3.0348 3.3841 2.3683 0.2709 1.7683 7.2489 27.9465 98.5624
Mo 42 0.6773 1.4798 3.1788 3.0824 1.8384 0.2920 2.0606 8.1129 30.5336 100.0658
Tc 43 0.7082 1.6392 3.1993 3.4327 1.8711 0.2976 2.2106 8.5246 33.1456 96.6377
Ru 44 0.6735 1.4934 3.0966 2.7254 1.5597 0.2773 1.9716 7.3249 26.6891 90.5581
Rh 45 0.6413 1.3690 2.9854 2.6952 1.5433 0.2580 1.7721 6.3854 23.2549 85.1517
Pd 46 0.5904 1.1775 2.6519 2.2875 0.8689 0.2324 1.5019 5.1591 15.5428 46.8213
Ag 47 0.6377 1.3790 2.8294 2.3631 1.4553 0.2466 1.6974 5.7656 20.0943 76.7372
Cd 48 0.6364 1.4247 2.7802 2.5973 1.7886 0.2407 1.6823 5.6588 20.7219 69.1109
In 49 0.6768 1.6589 2.7740 3.1835 2.1326 0.2522 1.8545 6.2936 25.1457 84.5448
Sn 50 0.7224 1.9610 2.7161 3.5603 1.8972 0.2651 2.0604 7.3011 27.5493 81.3349
Sb 51 0.7106 1.9247 2.6149 3.8322 1.8899 0.2562 1.9646 6.8852 24.7648 68.9168
Te 52 0.6947 1.8690 2.5356 4.0013 1.8955 0.2459 1.8542 6.4411 22.1730 59.2206
I 53 0.7047 1.9484 2.5940 4.1526 1.5057 0.2455 1.8638 6.7639 21.8007 56.4395
Xe 54 0.6737 1.7908 2.4129 4.2100 1.7058 0.2305 1.6890 5.8218 18.3928 47.2496
Cs 55 1.2704 3.8018 5.6618 0.9205 4.8105 0.4356 4.2058 23.4342 136.7783 171.7561
Ba 56 0.9049 2.6076 4.8498 5.1603 4.7388 0.3066 2.4363 12.1821 54.6135 161.9978
La 57 0.8405 2.3863 4.6139 5.1514 4.7949 0.2791 2.1410 10.3400 41.9148 132.0204
Ce 58 0.8551 2.3915 4.5772 5.0278 4.5118 0.2805 2.1200 10.1808 42.0633 130.9893
Pr 59 0.9096 2.5313 4.5266 4.6376 4.3690 0.2939 2.2471 10.8266 48.8842 147.6020
Nd 60 0.8807 2.4183 4.4448 4.6858 4.1725 0.2802 2.0836 10.0357 47.4506 146.9976
Pm 61 0.9471 2.5463 4.3523 4.4789 3.9080 0.2977 2.2276 10.5762 49.3619 145.3580
Sm 62 0.9699 2.5837 4.2778 4.4575 3.5985 0.3003 2.2447 10.6487 50.7994 146.4179
Eu 63 0.8694 2.2413 3.9196 3.9694 4.5498 0.2653 1.8590 8.3998 36.7397 125.7089
Gd 64 0.9673 2.4702 4.1148 4.4972 3.2099 0.2909 2.1014 9.7067 43.4270 125.9474
Tb 65 0.9325 2.3673 3.8791 3.9674 3.7996 0.2761 1.9511 8.9296 41.5937 131.0122
Dy 66 0.9505 2.3705 3.8218 4.0471 3.4451 0.2773 1.9469 8.8862 43.0938 133.1396
Ho 67 0.9248 2.2428 3.6182 3.7910 3.7912 0.2660 1.8183 7.9655 33.1129 101.8139
Er 68 1.0373 2.4824 3.6558 3.8925 3.0056 0.2944 2.0797 9.4156 45.8056 132.7720
Tm 69 1.0075 2.3787 3.5440 3.6932 3.1759 0.2816 1.9486 8.7162 41.8420 125.0320
Yb 70 1.0347 2.3911 3.4619 3.6556 3.0052 0.2855 1.9679 8.7619 42.3304 125.6499
Lu 71 0.9927 2.2436 3.3554 3.7813 3.0994 0.2701 1.8073 7.8112 34.4849 103.3526
Hf 72 1.0295 2.2911 3.4110 3.9497 2.4925 0.2761 1.8625 8.0961 34.2712 98.5295
Ta 73 1.0190 2.2291 3.4097 3.9252 2.2679 0.2694 1.7962 7.6944 31.0942 91.1089
W 74 0.9853 2.1167 3.3570 3.7981 2.2798 0.2569 1.6745 7.0098 26.9234 81.3910
Re 75 0.9914 2.0858 3.4531 3.8812 1.8526 0.2548 1.6518 6.8845 26.7234 81.7215
Os 76 0.9813 2.0322 3.3665 3.6235 1.9741 0.2487 1.5973 6.4737 23.2817 70.9254
Ir 77 1.0194 2.0645 3.4425 3.4914 1.6976 0.2554 1.6475 6.5966 23.2269 70.0272
Pt 78 0.9148 1.8096 3.2134 3.2953 1.5754 0.2263 1.3813 5.3243 17.5987 60.0171
Au 79 0.9674 1.8916 3.3993 3.0524 1.2607 0.2358 1.4712 5.6758 18.7119 61.5286
Hg 80 1.0033 1.9469 3.4396 3.1548 1.4180 0.2413 1.5298 5.8009 19.4520 60.5753
Tl 81 1.0689 2.1038 3.6039 3.4927 1.8283 0.2540 1.6715 6.3509 23.1531 78.7099
Pb 82 1.0891 2.1867 3.6160 3.8031 1.8994 0.2552 1.7174 6.5131 23.9170 74.7039
Bi 83 1.1007 2.2306 3.5689 4.1549 2.0382 0.2546 1.7351 6.4948 23.6464 70.3780
Po 84 1.1568 2.4353 3.6459 4.4064 1.7179 0.2648 1.8786 7.1749 25.1766 69.2821
At 85 1.0909 2.1976 3.3831 4.6700 2.1277 0.2466 1.6707 6.0197 20.7657 57.2663
Rn 86 1.0756 2.1630 3.3178 4.8852 2.0489 0.2402 1.6169 5.7644 19.4568 52.5009
Fr 87 1.4282 3.5081 5.6767 4.1964 3.8946 0.3183 2.6889 13.4816 54.3866 200.8321
Ra 88 1.3127 3.1243 5.2988 5.3891 5.4133 0.2887 2.2897 10.8276 43.5389 145.6109
Ac 89 1.3128 3.1021 5.3385 5.9611 4.7562 0.2861 2.2509 10.5287 41.7796 128.2973
Th 90 1.2553 2.9178 5.0862 6.1206 4.7122 0.2701 2.0636 9.3051 34.5977 107.9200
Pa 91 1.3218 3.1444 5.4371 5.6444 4.0107 0.2827 2.2250 10.2454 41.1162 124.4449
U 92 1.3382 3.2043 5.4558 5.4839 3.6342 0.2838 2.2452 10.2519 41.7251 124.9023
Np 93 1.5193 4.0053 6.5327 -.1402 6.7489 0.3213 2.8206 14.8878 68.9103 81.7257
Pu 94 1.3517 3.2937 5.3213 4.6466 3.5714 0.2813 2.2418 9.9952 42.7939 132.1739
Am 95 1.2135 2.7962 4.7545 4.5731 4.4786 0.2483 1.8437 7.5421 29.3841 112.4579
Cm 96 1.2937 3.1100 5.0393 4.7546 3.5031 0.2638 2.0341 8.7101 35.2992 109.4972
Bk 97 1.2915 3.1023 4.9309 4.6009 3.4661 0.2611 2.0023 8.4377 34.1559 105.8911
Cf 98 1.2089 2.7391 4.3482 4.0047 4.6497 0.2421 1.7487 6.7262 23.2153 80.3108
""".splitlines()

__cache = None
def __get_cache():
  global __cache
  if (__cache is None):
    from cctbx.eltbx.xray_scattering import get_standard_label
    from libtbx.containers import OrderedDict
    __cache = OrderedDict()
    assert len(ito_vol_c_2011_table_4_3_2_2) == 98
    for line in ito_vol_c_2011_table_4_3_2_2:
      flds = line.split()
      assert len(flds) == 12
      std_lbl = get_standard_label(flds[0], exact=True)
      assert flds[0] == std_lbl
      assert std_lbl not in __cache
      assert flds[1] == str(len(__cache)+1)
      def vals(i,j): return [float(s) for s in flds[i:j]]
      array_of_a = vals(2,7)
      array_of_b = vals(7,12)
      __cache[std_lbl] = gaussian(array_of_a, array_of_b)
  return __cache

def ito_vol_c_2011_table_4_3_2_2_elements():
  return list(__get_cache().keys())

def ito_vol_c_2011_table_4_3_2_2_entry_as_gaussian(label, exact=False):
  from cctbx.eltbx import xray_scattering
  std_lbl = xray_scattering.get_standard_label(label=label, exact=exact)
  return __get_cache().get(std_lbl)


 *******************************************************************************


 *******************************************************************************
cctbx/eltbx/formula.py
from __future__ import absolute_import, division, print_function
from cctbx.eltbx import tiny_pse
from scitbx.math import continued_fraction
import six

class formula(object):

  def __init__(self, count_of_element):
    self.count_of_element = count_of_element

  def sorted_as_c_h_then_by_increasing_atomic_number(self):
    head = []
    for elt in ('C', 'H'):
      n = self.count_of_element.get(elt)
      if n: head.append((elt, n))
    tail = [ (tiny_pse.table(elt).atomic_number(), (elt, n))
             for elt, n in six.iteritems(self.count_of_element)
             if elt not in ('C', 'H') ]
    tail.sort()
    self.element_count_pairs = head + [ item[-1] for item in tail ]
    return self

  def __str__(self):
    result = []
    for elt, n in self.element_count_pairs:
      r = continued_fraction.from_real(n, eps=1e-5).as_rational()
      if r.denominator() == 1:
        if r.numerator() > 1: m = "%i" % r.numerator()
        else: m = ""
      elif r.denominator() < 10: m = "%i/%i" % (r.numerator(), r.denominator())
      else: m = "%.5f" % n
      result.append("%s%s" % (elt, m))
    return ' '.join(result)


 *******************************************************************************


 *******************************************************************************
cctbx/eltbx/fp_fdp.py
from __future__ import absolute_import, division, print_function
import boost_adaptbx.boost.python as bp
ext = bp.import_ext("cctbx_eltbx_fp_fdp_ext")
from cctbx_eltbx_fp_fdp_ext import *


 *******************************************************************************


 *******************************************************************************
cctbx/eltbx/gaussian_fit.py
from __future__ import absolute_import, division, print_function
from cctbx.eltbx import xray_scattering
from cctbx.array_family import flex
import scitbx.math.gaussian
from scitbx.math.gaussian_fit import find_max_x_multi
from scitbx.math.gaussian_fit import show_minimize_multi_histogram
from libtbx import adopt_init_args
import sys, os
from six.moves import zip

# d = 1/(2*stol)
# stol = 1/(2*d)
international_tables_stols = flex.double(
  [0.00, 0.01, 0.02, 0.03, 0.04, 0.05,
   0.06, 0.07, 0.08, 0.09, 0.10,
   0.11, 0.12, 0.13, 0.14, 0.15,
   0.16, 0.17, 0.18, 0.19, 0.20,
   0.22, 0.24, 0.25, 0.26, 0.28, 0.30,
   0.32, 0.34, 0.35, 0.36, 0.38, 0.40,
   0.42, 0.44, 0.45, 0.46, 0.48, 0.50,
   0.55, 0.60, 0.65, 0.70, 0.80, 0.90, 1.00,
   1.10, 1.20, 1.30, 1.40, 1.50,
   1.60, 1.70, 1.80, 1.90, 2.00,
   2.50, 3.00, 3.50, 4.00, 5.00, 6.00])

def show_fit_summary(source, label, gaussian_fit, e,
                     e_other=None, n_terms_other=None):
  n_terms = str(gaussian_fit.n_terms())
  if (gaussian_fit.c() != 0): n_terms += "+c"
  n_terms += ","
  stol = gaussian_fit.table_x()[-1]
  d_min = 1/(2*stol)
  print("%24s: %s n_terms=%-4s stol=%.2f, d_min=%.2f, e=%.4f" % (
    source, label, n_terms, stol, d_min, e), end=' ')
  if (e_other is not None and e_other > e and n_terms_other == n_terms):
    print("Better", end=' ')
  print()

def show_literature_fits(label, n_terms, null_fit, n_points, e_other=None):
  for lib in [xray_scattering.wk1995,
              xray_scattering.it1992,
              xray_scattering.two_gaussian_agarwal_isaacs,
              xray_scattering.two_gaussian_agarwal_1978,
              xray_scattering.one_gaussian_agarwal_1978]:
    if (lib == xray_scattering.wk1995):
      try:
        lib_gaussian = xray_scattering.wk1995(label, True).fetch()
        lib_source = "WK1995"
      except Exception:
        lib_gaussian = None
    elif (lib == xray_scattering.it1992):
      try:
        lib_gaussian = xray_scattering.it1992(label, True).fetch()
        lib_source = "IT1992"
      except Exception:
        lib_gaussian = None
    elif (label in lib.table):
      lib_gaussian = lib.table[label]
      lib_source = lib.source_short
    else:
      lib_gaussian = None
    if (lib_gaussian is not None):
      gaussian_fit = scitbx.math.gaussian.fit(
        null_fit.table_x()[:n_points],
        null_fit.table_y()[:n_points],
        null_fit.table_sigmas()[:n_points],
        lib_gaussian)
      e = flex.max(gaussian_fit.significant_relative_errors())
      show_fit_summary(lib_source, label, gaussian_fit, e,
                       e_other, lib_gaussian.n_terms())

def write_plot(f, xs, ys):
  for x,y in zip(xs,ys):
    print(x, y, file=f)
  print("&", file=f)

def write_plots(plots_dir, label, gaussian_fit):
  label = label.replace("'", "prime")
  file_name = os.path.join(plots_dir, label+".xy")
  f = open(file_name, "w")
  write_plot(f, gaussian_fit.table_x(), gaussian_fit.table_y())
  write_plot(f, gaussian_fit.table_x(), gaussian_fit.fitted_values())
  f.close()
  file_name = os.path.join(plots_dir, label+".cmp")
  f = open(file_name, "w")
  for x,y,a,e in zip(gaussian_fit.table_x(),
                     gaussian_fit.table_y(),
                     gaussian_fit.fitted_values(),
                     gaussian_fit.significant_relative_errors()):
    print("%4.2f %7.4f %7.4f %8.5f %7.4f" % (x, y, a, a-y, e), file=f)
  f.close()
  return file_name

class fit_parameters(object):

  def __init__(self, max_n_terms=5,
                     target_powers=[2,4],
                     minimize_using_sigmas=False,
                     n_repeats_minimization=5,
                     shift_sqrt_b_mod_n=[0,1,2],
                     b_min=1.e-6,
                     max_max_error=0.01,
                     n_start_fractions=5,
                     negligible_max_error=0.001):
    adopt_init_args(self, locals())

  def quick(self):
    return fit_parameters(
      max_n_terms=2,
      target_powers=[2],
      minimize_using_sigmas=self.minimize_using_sigmas,
      n_repeats_minimization=1,
      shift_sqrt_b_mod_n=[1],
      b_min=self.b_min,
      max_max_error=0.02,
      n_start_fractions=2,
      negligible_max_error=0.02)

def incremental_fits(label, null_fit, params=None, plots_dir=None, verbose=0):
  if (params is None): params = fit_parameters()
  f0 = null_fit.table_y()[0]
  results = []
  previous_n_points = 0
  existing_gaussian = xray_scattering.gaussian([],[])
  while (existing_gaussian.n_terms() < params.max_n_terms):
    if (previous_n_points == null_fit.table_x().size()):
      print("%s: Full fit with %d terms. Search stopped." % (
        label, existing_gaussian.n_terms()))
      print()
      break
    n_terms = existing_gaussian.n_terms() + 1
    best_min = find_max_x_multi(
      null_fit=null_fit,
      existing_gaussian=existing_gaussian,
      target_powers=params.target_powers,
      minimize_using_sigmas=params.minimize_using_sigmas,
      n_repeats_minimization=params.n_repeats_minimization,
      shift_sqrt_b_mod_n=params.shift_sqrt_b_mod_n,
      b_min=params.b_min,
      max_max_error=params.max_max_error,
      n_start_fractions=params.n_start_fractions)
    if (best_min is None):
      print("Warning: No fit: %s n_terms=%d" % (label, n_terms))
      print()
      break
    if (previous_n_points > best_min.final_gaussian_fit.table_x().size()):
      print("Warning: previous fit included more sampling points.")
    previous_n_points = best_min.final_gaussian_fit.table_x().size()
    show_fit_summary(
      "Best fit", label, best_min.final_gaussian_fit, best_min.max_error)
    show_literature_fits(
      label=label,
      n_terms=n_terms,
      null_fit=null_fit,
      n_points=best_min.final_gaussian_fit.table_x().size(),
      e_other=best_min.max_error)
    best_min.final_gaussian_fit.show()
    best_min.show_minimization_parameters()
    existing_gaussian = best_min.final_gaussian_fit
    print()
    show_minimize_multi_histogram()
    sys.stdout.flush()
    if (plots_dir):
      write_plots(
        plots_dir=plots_dir,
        label=label+"_%d"%n_terms,
        gaussian_fit=best_min.final_gaussian_fit)
    g = best_min.final_gaussian_fit
    results.append(xray_scattering.fitted_gaussian(
      stol=g.table_x()[-1], gaussian_sum=g))
  return results

def decremental_fits(label, null_fit, full_fit=None, params=None,
                     plots_dir=None, verbose=0):
  if (params is None): params = fit_parameters()
  results = []
  last_fit = scitbx.math.gaussian.fit(
    null_fit.table_x(),
    null_fit.table_y(),
    null_fit.table_sigmas(),
    full_fit)
  while (last_fit.n_terms() > 1):
    good_min = scitbx.math.gaussian_fit.decremental_fit(
      existing_gaussian=last_fit,
      params=params)
    if (good_min is None):
      print("%s n_terms=%d: No successful minimization. Aborting." % (
        label, last_fit.n_terms()-1))
      break
    show_fit_summary(
      "Best fit", label, good_min.final_gaussian_fit, good_min.max_error)
    show_literature_fits(
      label=label,
      n_terms=good_min.final_gaussian_fit.n_terms(),
      null_fit=null_fit,
      n_points=good_min.final_gaussian_fit.table_x().size(),
      e_other=good_min.max_error)
    good_min.final_gaussian_fit.show()
    good_min.show_minimization_parameters()
    last_fit = good_min.final_gaussian_fit
    print()
    show_minimize_multi_histogram()
    sys.stdout.flush()
    if (plots_dir):
      write_plots(
        plots_dir=plots_dir,
        label=label+"_%d"%good_min.final_gaussian_fit.n_terms(),
        gaussian_fit=good_min.final_gaussian_fit)
    g = good_min.final_gaussian_fit
    results.append(xray_scattering.fitted_gaussian(
      stol=g.table_x()[-1], gaussian_sum=g))
  return results

def zig_zag_fits(label, null_fit, null_fit_more, params):
  six_term_best_min = scitbx.math.gaussian_fit.fit_with_golay_starts(
    label=label,
    null_fit=null_fit,
    null_fit_more=null_fit_more,
    params=params)
  results = []
  n_term_best_min = six_term_best_min
  have_all_points_in_previous = True
  while 1:
    while 1:
      if (n_term_best_min.final_gaussian_fit.n_terms() == 1):
        existing_gaussian = null_fit
      else:
        decr_best_min = scitbx.math.gaussian_fit.decremental_fit(
          existing_gaussian=n_term_best_min.final_gaussian_fit,
          params=params)
        assert decr_best_min is not None
        print("Decremental:", end=' ')
        decr_best_min.show_summary()
        existing_gaussian = decr_best_min.final_gaussian_fit
        if (n_term_best_min.max_error <= params.negligible_max_error
            and have_all_points_in_previous):
          break
      incr_best_min = find_max_x_multi(
        null_fit=null_fit,
        existing_gaussian=existing_gaussian,
        target_powers=params.target_powers,
        minimize_using_sigmas=params.minimize_using_sigmas,
        n_repeats_minimization=params.n_repeats_minimization,
        shift_sqrt_b_mod_n=params.shift_sqrt_b_mod_n,
        b_min=params.b_min,
        max_max_error=params.max_max_error,
        n_start_fractions=params.n_start_fractions)
      assert incr_best_min is not None
      print("Incremental:", end=' ')
      incr_best_min.show_summary()
      if (existing_gaussian is null_fit):
        break
      if (not incr_best_min.is_better_than(n_term_best_min)):
        break
      n_term_best_min = incr_best_min
    print(" Settled on:", end=' ')
    n_term_best_min.show_summary()
    results.append(xray_scattering.fitted_gaussian(
      stol=n_term_best_min.final_gaussian_fit.table_x()[-1],
      gaussian_sum=n_term_best_min.final_gaussian_fit,
      max_error=n_term_best_min.max_error))
    if (existing_gaussian is null_fit):
      break
    have_all_points_in_previous = (
         n_term_best_min.final_gaussian_fit.table_x().size()
      == decr_best_min.final_gaussian_fit.table_x().size())
    n_term_best_min = decr_best_min
  print()
  return results


 *******************************************************************************


 *******************************************************************************
cctbx/eltbx/henke.py
from __future__ import absolute_import, division, print_function
import cctbx.eltbx.fp_fdp # import dependency

import boost_adaptbx.boost.python as bp
ext = bp.import_ext("cctbx_eltbx_henke_ext")
from cctbx_eltbx_henke_ext import *

bp.inject(ext.table_iterator, bp.py3_make_iterator)


 *******************************************************************************


 *******************************************************************************
cctbx/eltbx/icsd_radii.py
from __future__ import absolute_import, division, print_function
import boost_adaptbx.boost.python as bp
ext = bp.import_ext("cctbx_eltbx_icsd_radii_ext")
from cctbx_eltbx_icsd_radii_ext import *

bp.inject(ext.table_iterator, bp.py3_make_iterator)


 *******************************************************************************


 *******************************************************************************
cctbx/eltbx/neutron.py
from __future__ import absolute_import, division, print_function
import boost_adaptbx.boost.python as bp
ext = bp.import_ext("cctbx_eltbx_neutron_ext")
from cctbx_eltbx_neutron_ext import *

bp.inject(ext.neutron_news_1992_table_iterator, bp.py3_make_iterator)


 *******************************************************************************


 *******************************************************************************
cctbx/eltbx/read_custom_scattering_dict.py
from __future__ import absolute_import, division, print_function
import sys
from libtbx.utils import Sorry
import cctbx.eltbx

def isfloat(value):
  try:
    float(value)
    return True
  except ValueError:
    return False

def run(filename, log = None):
  '''
    Read custom scattering factors from external file
  '''
  if log is None:
    log = sys.stdout
  print('Opening file with custom scattering factors: ', filename, file=log)
  with open(filename,'r') as f:
     all_lines = f.readlines()

  new_scattering_dictionary = dict()

  for l in all_lines:
    fields = l.split()
    el = fields[0]
    parameters = fields[1:]
    # Make sure the first field is a string
    # assert(isinstance(el, basestring))
    # Python 3
    assert (isinstance(el, str))

    # How many gaussians?
    n_gauss = (len(parameters))//2

#    # double check what cctbx allows
#    if n_gauss < 4 and n_gauss > 5:
#      raise Sorry('Only 4 or 5 gaussians are supported')

    # Make sure values are floats
    for value in parameters:
      if not isfloat(value):
        raise Sorry('Values in %s are not floats.' % filename)

    # Is there a constant?
    has_constant = False
    if (len(parameters))%2 == 1:
      has_constant = True

    # Get arrays of a and b
    def vals(i,j): return [float(s) for s in parameters[i:j]]
    array_of_a = vals(0,n_gauss)
    array_of_b = vals(n_gauss,2*n_gauss)

    if has_constant:
      constant = float(parameters[-1])

    if has_constant:
      new_scattering_dictionary[el] = cctbx.eltbx.xray_scattering.gaussian(
        tuple(array_of_a),
        tuple(array_of_b),
        constant)
    else:
      new_scattering_dictionary[el] = cctbx.eltbx.xray_scattering.gaussian(
        tuple(array_of_a),
        tuple(array_of_b))

  return new_scattering_dictionary



 *******************************************************************************


 *******************************************************************************
cctbx/eltbx/sasaki.py
from __future__ import absolute_import, division, print_function
import cctbx.eltbx.fp_fdp # import dependency

import boost_adaptbx.boost.python as bp
ext = bp.import_ext("cctbx_eltbx_sasaki_ext")
from cctbx_eltbx_sasaki_ext import *

bp.inject(ext.table_iterator, bp.py3_make_iterator)


 *******************************************************************************


 *******************************************************************************
cctbx/eltbx/tests/tst_attenuation_coefficient.py
from __future__ import absolute_import, division, print_function
from six.moves import range

def tst_for_z(z):
  from cctbx.eltbx import attenuation_coefficient

  eps = 1e-7

  # Get the table
  table = attenuation_coefficient.get_table(z)

  # Get list of energies and coefficients
  energy = table.energy()[1:-1]
  mu_rho = table.mu_rho()[1:-1]
  mu_en_rho = table.mu_en_rho()[1:-1]

  # Check values at measured energies match
  for i in range(len(energy)):
    e = energy[i] + 1e-16 # move beyond edges
    mr = mu_rho[i]
    mer = mu_en_rho[i]

    if i < len(energy) - 1:
      if abs(e - energy[i+1]) < eps:
        continue

    mr2 = table.mu_rho_at_ev(e * 1000000.0)
    mer2 = table.mu_en_rho_at_ev(e * 1000000.0)
#   print "%3d, %3d, %15f MeV -- %15f %15f %15f %15f -- %15.9f %15.9f" % (z, i, e, mr, mr2, mer, mer2, abs(mr - mr2), abs(mer - mer2))
    assert(abs(mr - mr2) <= eps)
    assert(abs(mer - mer2) <= eps)

  print('OK')

def run():
  from cctbx.eltbx import attenuation_coefficient

  for z in attenuation_coefficient.nist_elements().atomic_number_list():
    tst_for_z(z)

if __name__ == '__main__':
  run()


 *******************************************************************************


 *******************************************************************************
cctbx/eltbx/tests/tst_chemical_elements.py
from __future__ import absolute_import, division, print_function
from cctbx.eltbx import chemical_elements
from scitbx import stl
import scitbx.stl.set
from six.moves import zip

def exercise():
  lc = chemical_elements.proper_caps_list()
  assert len(lc) == 111
  assert lc[:3] == ["H", "He", "Li"]
  lu = chemical_elements.proper_upper_list()
  assert len(lu) == len(lc)
  assert lu[:3] == ["H", "HE", "LI"]
  for c,u in zip(lc,lu): assert c.upper() == u
  sc = chemical_elements.proper_caps_set()
  assert len(sc) == len(lc)
  assert list(sc) == list(stl.set.stl_string(lc))
  su = chemical_elements.proper_upper_set()
  assert len(su) == len(lc)
  assert list(su) == list(stl.set.stl_string(lu))
  su = chemical_elements.proper_and_isotopes_upper_set()
  assert len(su) == len(lc) + 2
  assert list(su) == list(stl.set.stl_string(lu+["D", "T"]))
  print("OK")

if (__name__ == "__main__"):
  exercise()


 *******************************************************************************


 *******************************************************************************
cctbx/eltbx/tests/tst_covalent_radii.py
from __future__ import absolute_import, division, print_function
from cctbx.eltbx import covalent_radii
from libtbx.test_utils import approx_equal

def exercise():
  t = covalent_radii.table("sI")
  assert t.label() == "Si"
  assert approx_equal(t.radius(), 1.11)
  assert approx_equal(t.esd(), 0.02)
  n = 0
  for t in covalent_radii.table_iterator():
    n += 1
    if (n == 1):
      assert t.label() == "H"
    elif (n == 97):
      assert t.label() == "Cm"
    u = covalent_radii.table(t.label())
    assert u.label() == t.label()
  assert n == 97

def run():
  exercise()
  print("OK")

if (__name__ == "__main__"):
  run()


 *******************************************************************************


 *******************************************************************************
cctbx/eltbx/tests/tst_formula.py
from __future__ import absolute_import, division, print_function
from cctbx.eltbx.formula import formula

def exercise():
  f = formula({'C': 10, 'H': 30, 'N': 2, 'O': 1, 'B': 3, 'Cl': 2, 'Rh': 1}
              ).sorted_as_c_h_then_by_increasing_atomic_number()
  assert str(f) == 'C10 H30 B3 N2 O Cl2 Rh'

  f = formula({'Li': 1, 'Br': 2, 'O': 3}
              ).sorted_as_c_h_then_by_increasing_atomic_number()
  assert str(f) == 'Li O3 Br2'

  f = formula({'Li': 1, 'Br': 2, 'C': 3}
              ).sorted_as_c_h_then_by_increasing_atomic_number()
  assert str(f) == 'C3 Li Br2'

  f = formula({'C': 4.33333, 'B': 2.66666, 'O': 0.123454, 'Li': 3}
              ).sorted_as_c_h_then_by_increasing_atomic_number()
  assert str(f) == 'C13/3 Li3 B8/3 O0.12345'

def run():
  exercise()
  print('OK')

if __name__ == '__main__':
  run()


 *******************************************************************************


 *******************************************************************************
cctbx/eltbx/tests/tst_henke.py
from __future__ import absolute_import, division, print_function
from cctbx.eltbx import henke
from libtbx.test_utils import approx_equal

def verify(table, energy, fp, fdp):
  fp_fdp = table.at_ev(energy)
  assert approx_equal(fp_fdp.fp(), fp)
  assert approx_equal(fp_fdp.fdp(), fdp)

def exercise():
  t = henke.table("SI")
  assert t.label() == "Si"
  assert t.atomic_number() == 14
  f = t.at_angstrom(2)
  assert f.is_valid_fp()
  assert f.is_valid_fdp()
  assert f.is_valid()
  from cctbx import factor_kev_angstrom
  assert approx_equal(f.fp(), t.at_kev(factor_kev_angstrom / 2).fp())
  assert approx_equal(f.fdp(), t.at_kev(factor_kev_angstrom / 2).fdp())
  assert approx_equal(f.fp(), t.at_ev(1000 * factor_kev_angstrom / 2).fp())
  assert approx_equal(f.fdp(), t.at_ev(1000 * factor_kev_angstrom / 2).fdp())
  c = f.as_complex()
  assert c.real == f.fp()
  assert c.imag == f.fdp()
  verify(t, 10.0, -9999.00, 4.00688)
  verify(t, 29.3, 4.04139-14, 0.371742)
  verify(t, 30000.0, 14.0266-14, 0.0228459)
  n = 0
  for t in henke.table_iterator():
    n += 1
    if (n == 1):
      assert t.label() == "H"
    elif (n == 92):
      assert t.label() == "U"
    u = henke.table(t.label())
    assert u.label() == t.label()
  assert n == 92

def run():
  exercise()
  print("OK")

if (__name__ == "__main__"):
  run()


 *******************************************************************************


 *******************************************************************************
cctbx/eltbx/tests/tst_icsd_radii.py
from __future__ import absolute_import, division, print_function
from cctbx.eltbx import icsd_radii
from libtbx.test_utils import approx_equal

def exercise():
  t = icsd_radii.table("sI4+")
  assert t.label() == "Si4+"
  assert approx_equal(t.radius(), 0.26)
  n = 0
  for t in icsd_radii.table_iterator():
    n += 1
    if (n == 1):
      assert t.label() == "H"
    elif (n == 442):
      assert t.label() == "Lr"
    u = icsd_radii.table(t.label())
    assert u.label() == t.label()
  assert n == 442

def run():
  exercise()
  print("OK")

if (__name__ == "__main__"):
  run()


 *******************************************************************************


 *******************************************************************************
cctbx/eltbx/tests/tst_neutron.py
from __future__ import absolute_import, division, print_function
from cctbx.eltbx import neutron
from libtbx.test_utils import approx_equal, Exception_expected

def exercise_00():
  t = neutron.neutron_news_1992_table("eu")
  assert t.label() == "Eu"
  l = t.bound_coh_scatt_length()
  assert approx_equal(l.real, 7.22)
  assert approx_equal(l.imag, -1.26)
  assert approx_equal(t.abs_cross_sect(), 4530.)
  n = 0
  for t in neutron.neutron_news_1992_table_iterator():
    n += 1
    if (n == 1):
      assert t.label() == "H"
    elif (n == 189):
      assert t.label() == "U6+"
    u = neutron.neutron_news_1992_table(t.label())
    assert u.label() == t.label()
  assert n == 189, n
  try:
    t = neutron.neutron_news_1992_table("XX")
  except ValueError as e:
    pass
  else:
    raise Exception_expected

def exercise_01():
  def strip_num_and_sign(x):
    r = ""
    for i in x:
      if(i.isalpha()): r+=i
    return r
  for t1 in neutron.neutron_news_1992_table_iterator():
    l1 = t1.label()
    l2 = strip_num_and_sign(x=l1)
    t1 = neutron.neutron_news_1992_table(l1)
    t2 = neutron.neutron_news_1992_table(l1)
    assert approx_equal(t1.abs_cross_sect(), t2.abs_cross_sect())
    assert approx_equal(t1.bound_coh_scatt_length(),t2.bound_coh_scatt_length())

def run():
  exercise_00()
  exercise_01()
  print("OK")

if (__name__ == "__main__"):
  run()


 *******************************************************************************


 *******************************************************************************
cctbx/eltbx/tests/tst_sasaki.py
from __future__ import absolute_import, division, print_function
from cctbx.eltbx import sasaki
from libtbx.test_utils import approx_equal

def verify(table, wave_length, fp, fdp):
  fp_fdp = table.at_angstrom(wave_length)
  assert approx_equal(fp_fdp.fp(), fp)
  assert approx_equal(fp_fdp.fdp(), fdp)

def exercise():
  t = sasaki.table("SI")
  assert t.label() == "Si"
  assert t.atomic_number() == 14
  f = t.at_angstrom(2)
  assert f.is_valid_fp()
  assert f.is_valid_fdp()
  assert f.is_valid()
  from cctbx import factor_kev_angstrom
  assert approx_equal(f.fp(), t.at_kev(factor_kev_angstrom / 2).fp())
  assert approx_equal(f.fdp(), t.at_kev(factor_kev_angstrom / 2).fdp())
  assert approx_equal(f.fp(), t.at_ev(1000 * factor_kev_angstrom / 2).fp())
  assert approx_equal(f.fdp(), t.at_ev(1000 * factor_kev_angstrom / 2).fdp())
  c = f.as_complex()
  assert c.real == f.fp()
  assert c.imag == f.fdp()
  verify(t, 0.1, -0.0226, 0.0010) # wide first
  verify(t, 2.89, 0.3824, 1.0517) # wide last
  verify(t, 6.7289, -6.9495, 4.1042) # K edge
  t = sasaki.table("ag")
  assert t.label() == "Ag"
  assert t.atomic_number() == 47
  verify(t, 3.2426, -8.6870, 14.1062) # L1 edge
  verify(t, 3.5169, -16.5123, 13.7723) # L2 edge
  verify(t, 3.6995, -29.9836, 10.5137) # L3 edge, right before edge
  verify(t, 3.6996, -32.2967, 3.1759) # L3 edge, right after edge
  n = 0
  for t in sasaki.table_iterator():
    n += 1
    if (n == 1):
      assert t.label() == "Li"
    elif (n == 82):
      assert t.label() == "U"
    u = sasaki.table(t.label())
    assert u.label() == t.label()
  assert n == 82

def run():
  exercise()
  print("OK")

if (__name__ == "__main__"):
  run()


 *******************************************************************************


 *******************************************************************************
cctbx/eltbx/tests/tst_tiny_pse.py
from __future__ import absolute_import, division, print_function
from cctbx.eltbx import tiny_pse
from libtbx.test_utils import approx_equal

def exercise():
  t = tiny_pse.table("SI")
  assert t.atomic_number() == 14
  assert t.symbol() == "Si"
  assert t.name() == "silicon"
  assert approx_equal(t.weight(), 28.086)
  n = 0
  for t in tiny_pse.table_iterator():
    n += 1
    if (n == 1):
      assert t.symbol() == "H"
    elif (n == 104):
      assert t.atomic_number() == 103
      assert t.symbol() == "Lr"
    u = tiny_pse.table(t.symbol())
    assert u.symbol() == t.symbol()
  assert n == 104

def run():
  exercise()
  print("OK")

if (__name__ == "__main__"):
  run()


 *******************************************************************************


 *******************************************************************************
cctbx/eltbx/tests/tst_wavelengths.py
from __future__ import absolute_import, division, print_function
from cctbx.eltbx import wavelengths
from libtbx.test_utils import approx_equal

def exercise():
  from cctbx import factor_kev_angstrom
  w = wavelengths.characteristic("CU")
  assert w.label() == "Cu"
  assert approx_equal(w.as_angstrom(), 1.5418)
  assert approx_equal(w.as_kev(), factor_kev_angstrom / 1.5418)
  assert approx_equal(w.as_ev() / 1000, factor_kev_angstrom / 1.5418)
  n = 0
  for w in wavelengths.characteristic_iterator():
    n += 1
    uu = wavelengths.characteristic(w.label())
    assert uu.label() == w.label()
    assert uu.as_ev() == w.as_ev()
  assert n == 15

def run():
  exercise()
  print("OK")

if (__name__ == "__main__"):
  run()


 *******************************************************************************


 *******************************************************************************
cctbx/eltbx/tests/tst_xray_scattering.py
from __future__ import absolute_import, division, print_function
from cctbx.eltbx import xray_scattering
from cctbx.array_family import flex
from libtbx.test_utils import Exception_expected, approx_equal
from six.moves import range
from six.moves import zip
try:
  from six.moves import cPickle as pickle
except ImportError:
  import pickle
import math

def exercise_basic():
  std_labels = xray_scattering.standard_labels_list()
  assert len(std_labels) == 217
  assert std_labels[:5] == ["H", "D", "T", "Hiso", "He"]
  assert std_labels[-1] == "Pu6+"
  for l in std_labels:
    assert xray_scattering.get_standard_label(
      label=l, exact=True, optional=False) == l
  assert xray_scattering.get_standard_label(label="na+") == "Na1+"
  assert xray_scattering.get_standard_label(label="na+") == "Na1+"
  assert xray_scattering.get_standard_label(label="o-") == "O1-"
  assert xray_scattering.get_standard_label(label="SI4+A") == "Si4+"
  assert xray_scattering.get_standard_label(label="SI1+") == "Si"
  assert xray_scattering.get_standard_label(label="SI1+",
    exact=True, optional=True) is None
  try:
    xray_scattering.get_standard_label(label="SI1+",
      exact=True, optional=False)
  except ValueError as e:
    assert str(e) == 'Unknown scattering type label: "SI1+"'
  else: raise Exception_expected
  #
  from cctbx.eltbx import tiny_pse
  for sl in std_labels:
    e, c = xray_scattering.get_element_and_charge_symbols(scattering_type=sl)
    assert e == "T" or tiny_pse.table(e, True).symbol() == e
    if (c != ""):
      assert len(c) == 2
      assert "123456789".find(c[0]) >= 0
      assert c[1] in ["+", "-"]

def exercise_gaussian():
  g = xray_scattering.gaussian(0)
  assert g.n_terms() == 0
  assert approx_equal(g.c(), 0)
  assert g.use_c()
  assert g.n_parameters() == 1
  g = xray_scattering.gaussian(0, False)
  assert g.n_terms() == 0
  assert approx_equal(g.c(), 0)
  assert not g.use_c()
  assert g.n_parameters() == 0
  g = xray_scattering.gaussian(1)
  assert g.n_terms() == 0
  assert g.array_of_a() == ()
  assert g.array_of_b() == ()
  assert approx_equal(g.c(), 1)
  assert g.n_parameters() == 1
  g = xray_scattering.gaussian((), ())
  assert g.n_terms() == 0
  assert g.array_of_a() == ()
  assert g.array_of_b() == ()
  assert g.c() == 0
  g = xray_scattering.gaussian((), (), -2)
  assert g.n_terms() == 0
  assert g.array_of_a() == ()
  assert g.array_of_b() == ()
  assert approx_equal(g.c(), -2)
  g = xray_scattering.gaussian(flex.double((1,2,3,4)))
  assert approx_equal(g.array_of_a(), (1,3))
  assert approx_equal(g.array_of_b(), (2,4))
  assert approx_equal(g.c(), 0)
  assert not g.use_c()
  g = xray_scattering.gaussian(flex.double((1,2,3,4)), 0, True)
  assert approx_equal(g.c(), 0)
  assert g.use_c()
  g = xray_scattering.gaussian(flex.double((1,2,3,4)), 5)
  assert approx_equal(g.c(), 5)
  assert g.use_c()
  g = xray_scattering.gaussian((1,-2,3,-4,5), (-.1,.2,-.3,.4,-.5), 6)
  assert g.n_terms() == 5
  assert approx_equal(g.array_of_a(),(1,-2,3,-4,5))
  assert approx_equal(g.array_of_b(),(-.1,.2,-.3,.4,-.5))
  assert approx_equal(g.c(), 6)
  assert approx_equal(g.at_stol_sq(3/4.), 13.4251206)
  assert approx_equal(g.at_stol(math.sqrt(3/4.)), 13.4251206)
  assert approx_equal(g.at_d_star_sq(3), 13.4251206)
  assert approx_equal(g.at_d_star_sq(flex.double([3,4])),
    [13.4251206, 15.079612])
  assert approx_equal(g.at_d_star(math.sqrt(3)), 13.4251206)
  s = pickle.dumps(g)
  l = pickle.loads(s)
  assert l.n_terms() == g.n_terms()
  assert approx_equal(l.array_of_a(), g.array_of_a())
  assert approx_equal(l.array_of_b(), g.array_of_b())
  assert approx_equal(l.c(), g.c())
  assert l.use_c()
  g = xray_scattering.gaussian((1,-2,3,-4,5), (-.1,.2,-.3,.4,-.5))
  s = pickle.dumps(g)
  l = pickle.loads(s)
  assert l.n_terms() == g.n_terms()
  assert approx_equal(l.array_of_a(), g.array_of_a())
  assert approx_equal(l.array_of_b(), g.array_of_b())
  assert approx_equal(l.c(), g.c())
  assert not l.use_c()
  #
  g = xray_scattering.gaussian(*list(zip(*[
    (2.51340127252, 31.8053433708),
    (1.74867019409, 0.445605499982),
    (1.72398202356, 10.5831679451)]))) # C 3-gaussian
  assert not g.use_c()
  e = g.electron_density
  assert approx_equal(e(r=0, b_iso=0), 264.731533932)
  assert approx_equal(e(r=0, b_iso=1), 47.3615000971)
  assert approx_equal(e(r=1, b_iso=0), 0.233911429529)
  assert approx_equal(e(r=1, b_iso=1), 0.243343387016)
  g = xray_scattering.gaussian(
    (2.31000, 1.02000, 1.58860, 0.865000),
    (20.8439, 10.2075, 0.568700, 51.6512),
    0.215600) # C it1992
  assert g.use_c()
  e = g.electron_density
  assert approx_equal(e(r=0, b_iso=0.1), 435.677592698)
  assert approx_equal(e(r=0, b_iso=1), 47.9420591405)
  assert approx_equal(e(r=1, b_iso=0.1), 0.241082494004)
  assert approx_equal(e(r=1, b_iso=1), 0.248806720643)

def exercise_n_gaussian():
  assert xray_scattering.n_gaussian_table_size() == 213
  assert xray_scattering.n_gaussian_table_index("H") == 0
  assert xray_scattering.n_gaussian_table_index("Pu6+") == 212
  for n_terms in [6,5,4,3,2,1]:
    e = xray_scattering.n_gaussian_table_entry(0, n_terms)
    assert e.label() == "H"
    g = e.gaussian()
    assert g.n_terms() == n_terms
    assert approx_equal(g.at_x(0), 1, eps=0.01+1.e-6)
    assert e.max_stol() > 0
    assert e.d_min() > 0
    assert e.max_relative_error() > 0
  for i_entry in range(xray_scattering.n_gaussian_table_size()):
    for n_terms in [6,5,4,3,2,1]:
      e = xray_scattering.n_gaussian_table_entry(i_entry, n_terms)
      assert e.gaussian().n_terms() == n_terms
      f = xray_scattering.n_gaussian_table_entry(e.label(), n_terms)
      assert f.label() == e.label()
      assert f.gaussian().n_terms() == n_terms
    for d_min in [0,10]:
      for max_relative_error in [0,0.5]:
        e = xray_scattering.n_gaussian_table_entry(
          i_entry, d_min, max_relative_error)
        f = xray_scattering.n_gaussian_table_entry(
          e.label(), d_min, max_relative_error)
        assert f.label() == e.label()
        if (d_min == 0):
          n_terms = 6
        else:
          n_terms = 1
        assert e.gaussian().n_terms() == n_terms
        assert f.gaussian().n_terms() == n_terms
  label = "Be"
  be_max_stols = []
  be_max_relative_errors = []
  for n_terms in [6,5,4,3,2,1]:
    e = xray_scattering.n_gaussian_table_entry(label, n_terms)
    be_max_stols.append(e.max_stol())
    be_max_relative_errors.append(e.max_relative_error())
  for n_terms,stol,max_relative_error in zip([6,5,4,3,2,1],
                                             be_max_stols,
                                             be_max_relative_errors):
    e = xray_scattering.n_gaussian_table_entry(
      "Be", 1/(2*stol)+1.e-6, max_relative_error+1.e-6)
    assert e.gaussian().n_terms() == n_terms
    assert approx_equal(e.max_stol(), stol)
    if (n_terms < 6):
      e = xray_scattering.n_gaussian_table_entry(
        "Be", 1/(2*stol)-1.e-6, max(be_max_relative_errors)+1.e-6)
      assert e.gaussian().n_terms() == min(n_terms+1, 6)
  assert be_max_relative_errors[1] > be_max_relative_errors[2]

def exercise_it1992():
  e = xray_scattering.it1992("c1")
  assert e.table() == "IT1992"
  assert e.label() == "C"
  g = e.fetch()
  assert g.n_terms() == 4
  assert g.n_parameters() == 9
  assert approx_equal(g.array_of_a(), (2.31000, 1.02000, 1.58860, 0.865000))
  assert approx_equal(g.array_of_b(), (20.8439, 10.2075, 0.568700, 51.6512))
  assert approx_equal(g.c(), 0.215600)
  assert approx_equal(g.at_stol_sq(0), 5.99919997156)
  assert approx_equal(g.at_stol_sq(1./9), 2.26575563201)
  assert approx_equal(g.at_stol(1./9), 4.93537567523)
  assert approx_equal(g.at_d_star_sq(1./9), 4.04815863088)
  e = xray_scattering.it1992("yb2+", True)
  assert e.label() == "Yb2+"
  g = e.fetch()
  assert approx_equal(g.array_of_a()[0], 28.1209)
  assert approx_equal(g.array_of_b()[3], 20.3900)
  assert approx_equal(g.c(), 3.70983)
  e = xray_scattering.it1992("  yB3+")
  assert e.label() == "Yb3+"
  g = e.fetch()
  assert approx_equal(g.array_of_a()[0], 27.8917)
  n = 0
  for e in xray_scattering.it1992_iterator():
    n += 1
    if (n == 213):
      assert e.label() == "Cf"
    else:
      assert e.label() != "Cf"
    d = xray_scattering.it1992(e.label(), True)
    assert d.label() == e.label()
  assert n == 213
  i = xray_scattering.it1992_iterator()
  j = iter(i)
  assert i is j

def exercise_wk1995():
  e = xray_scattering.wk1995("c1")
  assert e.table() == "WK1995"
  assert e.label() == "C"
  g = e.fetch()
  assert approx_equal(g.array_of_a(),
    (2.657506,1.078079,1.490909,-4.241070,0.713791))
  assert approx_equal(g.array_of_b(),
    (14.780758,0.776775,42.086842,-0.000294,0.239535))
  assert approx_equal(g.c(), 4.297983)
  assert approx_equal(g.at_stol_sq(0), 5.99719834328)
  assert approx_equal(g.at_stol_sq(1./9), 2.26895371584)
  assert approx_equal(g.at_stol(1./9), 4.93735084739)
  assert approx_equal(g.at_d_star_sq(1./9), 4.04679561237)
  e = xray_scattering.wk1995("yb2+", True)
  assert e.label() == "Yb2+"
  g = e.fetch()
  assert approx_equal(g.array_of_a()[0], 28.443794)
  assert approx_equal(g.array_of_b()[4], 0.001463)
  assert approx_equal(g.c(), -23.214935)
  e = xray_scattering.wk1995("  yB3+")
  assert e.label() == "Yb3+"
  g = e.fetch()
  assert approx_equal(g.array_of_a()[0], 28.191629)
  n = 0
  for e in xray_scattering.wk1995_iterator():
    n += 1
    if (n == 213):
      assert e.label() == "Pu6+"
    else:
      assert e.label() != "Pu6+"
    d = xray_scattering.wk1995(e.label(), True)
    assert d.label() == e.label()
  assert n == 213
  i = xray_scattering.wk1995_iterator()
  j = iter(i)
  assert i is j

def ensure_common_symbols():
  lbl_it = []
  for e in xray_scattering.it1992_iterator(): lbl_it.append(e.label())
  lbl_it.sort()
  lbl_wk = []
  for e in xray_scattering.wk1995_iterator(): lbl_wk.append(e.label())
  lbl_wk.sort()
  assert lbl_wk == lbl_it
  lbl_ng = []
  for i_entry in range(xray_scattering.n_gaussian_table_size()):
    lbl_ng.append(xray_scattering.n_gaussian_table_entry(i_entry, 6).label())
  lbl_ng.sort()
  assert lbl_ng == lbl_it
  #
  for label in xray_scattering.standard_labels_list():
    it = xray_scattering.it1992(label, True).fetch()
    wk = xray_scattering.wk1995(label, True).fetch()
    ng = xray_scattering.n_gaussian_table_entry(label, 0, 0).gaussian()
    assert approx_equal(wk.at_stol(0)/it.at_stol(0), 1, 5.e-3)

def ensure_correct_element_symbol():
  from cctbx.eltbx import tiny_pse
  for e in xray_scattering.it1992_iterator():
    l = e.label()
    e, c = xray_scattering.get_element_and_charge_symbols(
      scattering_type=l, exact=False)
    assert tiny_pse.table(l).symbol() == e
    assert tiny_pse.table(l.lower()).symbol() == e
    assert tiny_pse.table(l.upper()).symbol() == e

def run():
  exercise_basic()
  exercise_gaussian()
  exercise_n_gaussian()
  exercise_it1992()
  exercise_wk1995()
  ensure_common_symbols()
  ensure_correct_element_symbol()
  print("OK")

if (__name__ == "__main__"):
  run()


 *******************************************************************************


 *******************************************************************************
cctbx/eltbx/tiny_pse.py
from __future__ import absolute_import, division, print_function
import boost_adaptbx.boost.python as bp
ext = bp.import_ext("cctbx_eltbx_tiny_pse_ext")
from cctbx_eltbx_tiny_pse_ext import *

bp.inject(ext.table_iterator, bp.py3_make_iterator)


 *******************************************************************************


 *******************************************************************************
cctbx/eltbx/van_der_waals_radii.py
from __future__ import absolute_import, division, print_function
# Van-der-Waals radii for known elements.
#
# ******************               NOTE                *********************
# vdW radii vary for the same element depending on chemical context
# The list below may be therefore too simplistic
# A complete list of vdW radii is in chem_data/mon_lib/ener_lib.cif
# See method get_vdw_radii() of model class (mmtbx/model/model.py)
# how to get the vdw radii from ener_lib
# ****************** ******************* ******************* *******************
#
# Created: Pavel Afonine.
#
# Sources:
# 1) Bondi, J.Phys.Chem., 68, 441, 1964  for atoms:
#      Ag,Ar,As,Au,Br,Cd,Cl,Cu,F,Ga,H,He,Hg,I,In,K,Kr,
#      Li,Mg,Na,Ne,Ni,Pb,Pd,Pt,Se,Si,Sn,Te,Tl,Xe,Zn
# 2) Fokine et al, J. Appl. Cryst. (2003). 36, 352-355 for "protein" atoms:
#    C, O, N, S, P
#

class vdw(object):
  table = {
     "H":  1.20 , #wiki 1.2
     "D":  1.20 ,
     "He": 1.40 ,
     "Li": 1.82 ,
     "Be": 0.63 ,
     "B":  1.75 ,
     "C":  1.775, #wiki 1.7  #was 1.775 # CNS 2.3
     "N":  1.50 , #wiki 1.55 #was 1.5 # CNS 1.6
     "O":  1.45 , #wiki 1.52 #was 1.45 # CNS 1.6
     "F":  1.47 ,
     "Ne": 1.54 ,
     "Na": 2.27 ,
     "Mg": 1.73 ,
     "Al": 1.50 ,
     "Si": 2.10 ,
     "P":  1.90 ,
     "S":  1.80 , #wiki 1.8 # CNS 1.9
     "Cl": 1.75 ,
     "Ar": 1.88 ,
     "K":  2.75 ,
     "Ca": 1.95 ,
     "Sc": 1.32 ,
     "Ti": 1.95 ,
     "V":  1.06 ,
     "Cr": 1.13 ,
     "Mn": 1.19 ,
     "Fe": 1.26 ,
     "Co": 1.13 ,
     "Ni": 1.63 ,
     "Cu": 1.40 ,
     "Zn": 1.39 ,
     "Ga": 1.87 ,
     "Ge": 1.48 ,
     "As": 0.83 ,
     "Se": 1.90 ,
     "Br": 1.85 ,
     "Kr": 2.02 ,
     "Rb": 2.65 ,
     "Sr": 2.02 ,
     "Y":  1.61 ,
     "Zr": 1.42 ,
     "Nb": 1.33 ,
     "Mo": 1.75 ,
     "Tc": 2.00 ,
     "Ru": 1.20 ,
     "Rh": 1.22 ,
     "Pd": 1.63 ,
     "Ag": 1.72 ,
     "Cd": 1.58 ,
     "In": 1.93 ,
     "Sn": 2.17 ,
     "Sb": 1.12 ,
     "Te": 1.26 ,
     "I":  1.98 ,
     "Xe": 2.16 ,
     "Cs": 3.01 ,
     "Ba": 2.41 ,
     "La": 1.83 ,
     "Ce": 1.86 ,
     "Pr": 1.62 ,
     "Nd": 1.79 ,
     "Pm": 1.76 ,
     "Sm": 1.74 ,
     "Eu": 1.96 ,
     "Gd": 1.69 ,
     "Tb": 1.66 ,
     "Dy": 1.63 ,
     "Ho": 1.61 ,
     "Er": 1.59 ,
     "Tm": 1.57 ,
     "Yb": 1.54 ,
     "Lu": 1.53 ,
     "Hf": 1.40 ,
     "Ta": 1.22 ,
     "W":  1.26 ,
     "Re": 1.30 ,
     "Os": 1.58 ,
     "Ir": 1.22 ,
     "Pt": 1.72 ,
     "Au": 1.66 ,
     "Hg": 1.55 ,
     "Tl": 1.96 ,
     "Pb": 2.02 ,
     "Bi": 1.73 ,
     "Po": 1.21 ,
     "At": 1.12 ,
     "Rn": 2.30 ,
     "Fr": 3.24 ,
     "Ra": 2.57 ,
     "Ac": 2.12 ,
     "Th": 1.84 ,
     "Pa": 1.60 ,
     "U":  1.75 ,
     "Np": 1.71 ,
     "Pu": 1.67 ,
     "Am": 1.66 ,
     "Cm": 1.65 ,
     "Bk": 1.64 ,
     "Cf": 1.63 ,
     "Es": 1.62 ,
     "Fm": 1.61 ,
     "Md": 1.60 ,
     "No": 1.59 ,
     "Lr": 1.58 ,
      }


 *******************************************************************************


 *******************************************************************************
cctbx/eltbx/wavelengths.py
from __future__ import absolute_import, division, print_function
import boost_adaptbx.boost.python as bp
ext = bp.import_ext("cctbx_eltbx_wavelengths_ext")
from cctbx_eltbx_wavelengths_ext import *

bp.inject(ext.characteristic_iterator, bp.py3_make_iterator)


 *******************************************************************************


 *******************************************************************************
cctbx/eltbx/xray_scattering/__init__.py
from __future__ import absolute_import, division, print_function
import scitbx.math.gaussian # base class for gaussian

import boost_adaptbx.boost.python as bp
from six.moves import zip
ext = bp.import_ext("cctbx_eltbx_xray_scattering_ext")
from cctbx_eltbx_xray_scattering_ext import *

import sys

# grep 'DATA KQ' shelxl.f | cut -d"'" -f2 | grep -v NCSY
shelxl_97_2_980324_tabulated_chemical_elements = """\
H HE LI BE B C N O F NE NA MG AL SI P S CL AR K CA SC TI V CR MN FE
CO NI CU ZN GA GE AS SE BR KR RB SR Y ZR NB MO TC RU RH PD AG CD IN
SN SB TE I XE CS BA LA CE PR ND PM SM EU GD TB DY HO ER TM YB LU HF
TA W RE OS IR PT AU HG TL PB BI PO AT RN FR RA AC TH PA U NP PU""".split()

def get_element_and_charge_symbols(scattering_type, exact=True):
  sl = get_standard_label(label=scattering_type, exact=exact, optional=True)
  if (sl is None): return "", ""
  if (sl == "Hiso"): return "H", ""
  if (sl == "Cval"): return "C", ""
  if (sl == "Sival"): return "Si", ""
  if (sl[-1] in ["+", "-"]):
    return sl[:-2], sl[-2:]
  return sl, ""

bp.inject(ext.it1992_iterator, bp.py3_make_iterator)
bp.inject(ext.wk1995_iterator, bp.py3_make_iterator)

@bp.inject_into(ext.gaussian)
class _():

  def show(self, f=None, format=None):
    if (f is None): f = sys.stdout
    if (format is None): format = "%.8g"
    for l,v in (("a:", self.array_of_a()), ("b:", self.array_of_b())):
      print(l, " ".join([format % x for x in v]), file=f)
    print("c:", format % self.c(), file=f)
    return self

  def electron_density(self, r, b_iso):
    from math import pi, exp
    result = 0
    def ft(b):
      # Agarwal (1978). Acta Cryst. A34, 791-809.
      # Page 796 before equation (42).
      return (4*pi/(b+b_iso))**(3/2) * exp(-4*pi**2*r**2/(b+b_iso))
    for a,b in zip(self.array_of_a(), self.array_of_b()):
      result += a * ft(b)
    if (self.use_c()):
      result += self.c() * ft(0)
    return result

  def gradient(self, r, t, t0, b_iso):
    from math import pi, exp
    result = 0
    def ft(b):
      return -2*(t-t0)*(4*pi/(b+b_iso))**(5/2) * exp(-4*pi**2*r**2/(b+b_iso))
    for a,b in zip(self.array_of_a(), self.array_of_b()):
      result += a * ft(b)
    if (self.use_c()):
      result += self.c() * ft(0)
    return result

def best_approximation(scattering_type):
  if (scattering_type == "const"):
    return gaussian(1)
  if scattering_type in ["TX","XX","AX"]:
    return gaussian(1)
  return wk1995(scattering_type, True).fetch()

class two_gaussian_agarwal_isaacs(object):
  source="ccp4/lib/data/atomsf.lib Revision 1.4, Thu Feb 13 14:10:58 1997 UTC"
  source_short = "CCP4 atomsf.lib Rev. 1.4"
  table = {
    "H": gaussian([0.7932, 0.1949], [24.2157, 2.1089]),
    "C": gaussian([2.9972, 2.9791], [30.016701, 2.8886]),
    "N": gaussian([2.9924, 3.9986], [25.3766, 3.5004]),
    "O": gaussian([2.4485, 5.5589], [24.756199, 4.1372]),
    "S": gaussian([5.5480, 10.4241], [33.7108, 1.9034]),
  }

class two_gaussian_agarwal_1978(object):
  source = "Agarwal, R.C. (1978). Acta Cryst. A34, 791-809, Table 1."
  source_short = "Agarwal (1978)"
  table = {
    "H": gaussian([0.4866, 0.5098], [34.1284, 8.8996]),
    "C": gaussian([3.0102, 2.9705], [29.9132, 2.8724]),
    "N": gaussian([3.0492, 3.9432], [25.0383, 3.4059]),
    "O": gaussian([3.2942, 4.6968], [20.0401, 3.1184]),
    "S": gaussian([5.6604, 10.3140], [33.0400, 1.8160]),
    "Fe3+": gaussian([10.3568, 12.6329], [8.1324, 0.8137]),
    "Fe2+": gaussian([11.6635, 12.3057], [9.0361, 0.5749]),
    "Zn2+": gaussian([5.7826, 22.2163], [11.7082, 1.8234]),
    "Ba2+": gaussian([12.1432, 41.8442], [21.7090, 1.4090]),
  }

class one_gaussian_agarwal_1978(object):
  source = "Agarwal, R.C. (1978). Acta Cryst. A34, 791-809, Table 3."
  source_short = "Agarwal (1978)"
  table = {
    "C": gaussian([5.9074], [1.2913]),
    "N": gaussian([7.0411], [0.2065]),
    "O": gaussian([8.1561], [-0.8941]),
    "S": gaussian([15.8448], [-2.1392]),
  }

class fitted_gaussian(gaussian):

  def __init__(self, stol, gaussian_sum, max_error=None):
    gaussian.__init__(self, gaussian_sum)
    self.stol = stol
    self.max_error = max_error

  def __getinitargs__(self):
    return (self.stol, gaussian(self), self.max_error)

  def sort(self):
    return fitted_gaussian(self.stol, gaussian.sort(self), self.max_error)

  def show(self, f=None, format=None):
    if (f is None): f = sys.stdout
    if (self.max_error is None):
      e = ""
    else:
      e = ", max_error: %.4f" % self.max_error
    print("stol: %.2f # d_min: %.2f%s" % (self.stol, 1/(2*self.stol), e), file=f)
    return gaussian.show(self, f, format)


 *******************************************************************************
