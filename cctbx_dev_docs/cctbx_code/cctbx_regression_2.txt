

 *******************************************************************************
cctbx/regression/tst_miller_fft_map.py
from __future__ import absolute_import, division, print_function
from cctbx import miller
from cctbx import maptbx
from cctbx import sgtbx
from cctbx import xray
from cctbx import euclidean_model_matching as emma
from cctbx.development import random_structure
from cctbx.development import debug_utils
from cctbx.development import structure_factor_utils
from cctbx.array_family import flex
from libtbx.test_utils import approx_equal, show_diff
try:
  from six.moves import cPickle as pickle
except ImportError:
  import pickle
from six.moves import cStringIO as StringIO
import random
import sys

def check_peaks(structure, peak_sites, max_min_dist):
  for scatterer in structure.scatterers():
    site_symmetry = structure.site_symmetry(scatterer.site)
    equiv_sites = sgtbx.sym_equiv_sites(site_symmetry)
    min_dist = None
    for peak_site in peak_sites:
      dist_info = sgtbx.min_sym_equiv_distance_info(equiv_sites, peak_site)
      if (min_dist is None):
        min_dist = dist_info.dist()
      else:
        min_dist = min(min_dist, dist_info.dist())
    assert min_dist <= max_min_dist, (min_dist, max_min_dist)

def run_test(space_group_info, n_elements=5, d_min=1.5,
             grid_resolution_factor=1./3, max_prime=5, verbose=0):
  structure = random_structure.xray_structure(
    space_group_info,
    elements=["Si"]*n_elements,
    volume_per_atom=200,
    min_distance=3.,
    general_positions_only=False)
  miller_set_f_obs = miller.build_set(
    crystal_symmetry=structure,
    anomalous_flag=(random.random()>0.5),
    d_min=d_min)
  f_obs = miller_set_f_obs.structure_factors_from_scatterers(
    xray_structure=structure,
    algorithm="direct").f_calc()
  structure_factor_utils.check_phase_restrictions(f_obs, verbose=verbose)
  if (0 or verbose):
    f_obs.show_summary()
  if (0 or verbose):
    f_obs.show_array()
  fft_map = f_obs.fft_map(
    resolution_factor=grid_resolution_factor,
    symmetry_flags=maptbx.use_space_group_symmetry)
  p = pickle.dumps(fft_map)
  l = pickle.loads(p)
  s1 = StringIO()
  fft_map.statistics().show_summary(f=s1)
  s2 = StringIO()
  l.statistics().show_summary(f=s2)
  assert not show_diff(s2.getvalue(), s1.getvalue())
  #
  if (not f_obs.anomalous_flag()):
    maptbx_fft_map = maptbx.fft_to_real_map_unpadded(
      space_group=fft_map.space_group(),
      n_real=fft_map.n_real(),
      miller_indices=f_obs.indices(),
      data=f_obs.data())
    fft_map_unpadded = fft_map.real_map_unpadded(in_place=False)
    assert approx_equal(
      flex.linear_correlation(
        fft_map_unpadded.as_1d(), maptbx_fft_map.as_1d()).coefficient(), 1)
    assert approx_equal(
      flex.max(flex.abs(maptbx_fft_map - fft_map_unpadded)), 0)
  #
  fft_map.apply_sigma_scaling()
  real_map = maptbx.copy(
    fft_map.real_map(),
    flex.grid(fft_map.real_map().focus()))
  grid_tags = maptbx.grid_tags(real_map.focus())
  grid_tags.build(
    fft_map.space_group_info().type(),
    fft_map.symmetry_flags())
  assert grid_tags.n_grid_misses() == 0
  assert grid_tags.verify(real_map)
  rms = []
  for interpolate in (False,True):
    peak_list = maptbx.peak_list(
      data=real_map,
      tags=grid_tags.tag_array(),
      peak_search_level=1,
      max_peaks=2*n_elements,
      interpolate=interpolate)
    assert peak_list.gridding() == real_map.focus()
    check_peaks(structure, peak_list.sites(), d_min * grid_resolution_factor)
    crystal_gridding_tags = fft_map.tags()
    cluster_analysis = maptbx.peak_cluster_analysis(
      peak_list=peak_list,
      special_position_settings=structure,
      general_positions_only=False,
      effective_resolution=d_min,
      min_cross_distance=2,
      max_clusters=n_elements).all()
    check_peaks(
      structure,
      cluster_analysis.sites(),
      cluster_analysis.min_cross_distance() + d_min * grid_resolution_factor)
    structure_from_peaks = xray.structure(structure)
    for site in cluster_analysis.sites():
      structure_from_peaks.add_scatterer(
        xray.scatterer(label="site", scattering_type="", site=site))
    emma_matches = emma.model_matches(
      structure.as_emma_model(),
      structure_from_peaks.as_emma_model(),
      tolerance=d_min*2)
    rms.append(emma_matches.refined_matches[0].rms)
    assert len(emma_matches.refined_matches[0].pairs) == n_elements
  # exercise interpolation vs. summation
  map_coeffs = f_obs.expand_to_p1()
  fft_map = f_obs.fft_map(
    resolution_factor=grid_resolution_factor,
    symmetry_flags=maptbx.use_space_group_symmetry)
  fft_map.apply_volume_scaling()
  real_map = fft_map.real_map_unpadded()
  sum1 = sum2 = 0
  for scatterer in structure.scatterers():
    v1 = real_map.eight_point_interpolation(scatterer.site)
    v2 = real_map.tricubic_interpolation(scatterer.site)
    v3 = map_coeffs.direct_summation_at_point(scatterer.site)
    sum1 += abs(v1 - v3.real)
    sum2 += abs(v2 - v3.real)
  mean_delta_linear = sum1 / n_elements
  mean_delta_cubic = sum2 / n_elements
  assert (mean_delta_cubic < mean_delta_linear)
  if (0 or verbose):
    print("emma rms grid, interpolated: %.2f %.2f" % tuple(rms))
  assert rms[0] >= rms[1]
  map_1 = fft_map.real_map_unpadded(in_place=False)
  map_2 = fft_map.real_map_unpadded(in_place=True)
  assert (map_1.all_eq(map_2))

def exercise_average_bijvoet_mates(
      space_group_info,
      n_elements=6,
      d_min=5,
      verbose=0):
  structure = random_structure.xray_structure(
    space_group_info,
    elements=(("O","N","C")*(n_elements//3+1))[:n_elements],
    volume_per_atom=1000,
    min_distance=5,
    general_positions_only=True,
    random_f_double_prime=True)
  if (0 or verbose):
    structure.show_summary().show_scatterers()
  f_calc = structure.structure_factors(
    d_min=d_min, algorithm="direct").f_calc()
  if (0 or verbose):
    f_calc.show_summary()
  assert f_calc.anomalous_flag()
  assert abs(f_calc).anomalous_signal() > 0
  #
  fc_merged = f_calc.average_bijvoet_mates()
  fc_merged_naive = f_calc \
    .as_non_anomalous_array() \
    .merge_equivalents().array().common_set(fc_merged)
  assert fc_merged_naive.indices().all_eq(fc_merged.indices())
  assert flex.max(flex.abs(fc_merged_naive.select_acentric().data()
                          -fc_merged.select_acentric().data())) < 1.e-6
  #
  map_c = f_calc.fft_map().real_map_unpadded()
  map_r = fc_merged.fft_map().real_map_unpadded()
  assert map_c.focus() == map_r.focus()
  lc = flex.linear_correlation(map_c.as_1d(), map_r.as_1d())
  if (0 or verbose):
    print(lc.coefficient())
  assert lc.coefficient() > 1-1.e-6
  assert flex.max(flex.abs(map_c.as_1d() - map_r.as_1d())) < 1.e-6
  #
  fc_ma = fc_merged.generate_bijvoet_mates().adopt_set(f_calc)
  fc_mam = fc_ma.average_bijvoet_mates().adopt_set(fc_merged)
  assert flex.max(flex.abs(fc_mam.data()-fc_merged.data())) < 1.e-6

def run_call_back(flags, space_group_info):
  run_test(space_group_info, verbose=flags.Verbose)
  if (not space_group_info.group().is_centric()):
    exercise_average_bijvoet_mates(space_group_info, verbose=flags.Verbose)

def run():
  debug_utils.parse_options_loop_space_groups(sys.argv[1:], run_call_back)

if (__name__ == "__main__"):
  run()


 *******************************************************************************


 *******************************************************************************
cctbx/regression/tst_miller_lookup_utils.py
from __future__ import absolute_import, division, print_function
from cctbx.array_family import flex
from cctbx import crystal
from cctbx import miller
from cctbx import uctbx
from cctbx import miller
from six.moves import range


class miller_lookup_utils_tester(object):
  def __init__(self):
    ## define a unit cell
    self.unit_cell = uctbx.unit_cell('20, 30, 40, 90.0, 90.0, 90.0')
    ## space group P1
    self.mi = flex.miller_index( (
      ( -3 , -3 , -3 ),
      ( -3 , -3 , -2 ),
      ( -3 , -3 , -1 ),
      ( -3 , -3 , 0 ),
      ( -3 , -3 , 1 ),
      ( -3 , -3 , 2 ),
      ( -3 , -3 , 3 ),
      ( -3 , -2 , -3 ),
      ( -3 , -2 , -2 ),
      ( -3 , -2 , -1 ),
      ( -3 , -2 , 0 ),
      ( -3 , -2 , 1 ),
      ( -3 , -2 , 2 ),
      ( -3 , -2 , 3 ),
      ( -3 , -1 , -3 ),
      ( -3 , -1 , -2 ),
      ( -3 , -1 , -1 ),
      ( -3 , -1 , 0 ),
      ( -3 , -1 , 1 ),
      ( -3 , -1 , 2 ),
      ( -3 , -1 , 3 ),
      ( -3 , 0 , -3 ),
      ( -3 , 0 , -2 ),
      ( -3 , 0 , -1 ),
      ( -3 , 0 , 0 ),
      ( -3 , 0 , 1 ),
      ( -3 , 0 , 2 ),
      ( -3 , 0 , 3 ),
      ( -3 , 1 , -3 ),
      ( -3 , 1 , -2 ),
      ( -3 , 1 , -1 ),
      ( -3 , 1 , 0 ),
      ( -3 , 1 , 1 ),
      ( -3 , 1 , 2 ),
      ( -3 , 1 , 3 ),
      ( -3 , 2 , -3 ),
      ( -3 , 2 , -2 ),
      ( -3 , 2 , -1 ),
      ( -3 , 2 , 0 ),
      ( -3 , 2 , 1 ),
      ( -3 , 2 , 2 ),
      ( -3 , 2 , 3 ),
      ( -3 , 3 , -3 ),
      ( -3 , 3 , -2 ),
      ( -3 , 3 , -1 ),
      ( -3 , 3 , 0 ),
      ( -3 , 3 , 1 ),
      ( -3 , 3 , 2 ),
      ( -3 , 3 , 3 ),
      ( -2 , -3 , -3 ),
      ( -2 , -3 , -2 ),
      ( -2 , -3 , -1 ),
      ( -2 , -3 , 0 ),
      ( -2 , -3 , 1 ),
      ( -2 , -3 , 2 ),
      ( -2 , -3 , 3 ),
      ( -2 , -2 , -3 ),
      ( -2 , -2 , -2 ),
      ( -2 , -2 , -1 ),
      ( -2 , -2 , 0 ),
      ( -2 , -2 , 1 ),
      ( -2 , -2 , 2 ),
      ( -2 , -2 , 3 ),
      ( -2 , -1 , -3 ),
      ( -2 , -1 , -2 ),
      ( -2 , -1 , -1 ),
      ( -2 , -1 , 0 ),
      ( -2 , -1 , 1 ),
      ( -2 , -1 , 2 ),
      ( -2 , -1 , 3 ),
      ( -2 , 0 , -3 ),
      ( -2 , 0 , -2 ),
      ( -2 , 0 , -1 ),
      ( -2 , 0 , 0 ),
      ( -2 , 0 , 1 ),
      ( -2 , 0 , 2 ),
      ( -2 , 0 , 3 ),
      ( -2 , 1 , -3 ),
      ( -2 , 1 , -2 ),
      ( -2 , 1 , -1 ),
      ( -2 , 1 , 0 ),
      ( -2 , 1 , 1 ),
      ( -2 , 1 , 2 ),
      ( -2 , 1 , 3 ),
      ( -2 , 2 , -3 ),
      ( -2 , 2 , -2 ),
      ( -2 , 2 , -1 ),
      ( -2 , 2 , 0 ),
      ( -2 , 2 , 1 ),
      ( -2 , 2 , 2 ),
      ( -2 , 2 , 3 ),
      ( -2 , 3 , -3 ),
      ( -2 , 3 , -2 ),
      ( -2 , 3 , -1 ),
      ( -2 , 3 , 0 ),
      ( -2 , 3 , 1 ),
      ( -2 , 3 , 2 ),
      ( -2 , 3 , 3 ),
      ( -1 , -3 , -3 ),
      ( -1 , -3 , -2 ),
      ( -1 , -3 , -1 ),
      ( -1 , -3 , 0 ),
      ( -1 , -3 , 1 ),
      ( -1 , -3 , 2 ),
      ( -1 , -3 , 3 ),
      ( -1 , -2 , -3 ),
      ( -1 , -2 , -2 ),
      ( -1 , -2 , -1 ),
      ( -1 , -2 , 0 ),
      ( -1 , -2 , 1 ),
      ( -1 , -2 , 2 ),
      ( -1 , -2 , 3 ),
      ( -1 , -1 , -3 ),
      ( -1 , -1 , -2 ),
      ( -1 , -1 , -1 ),
      ( -1 , -1 , 0 ),
      ( -1 , -1 , 1 ),
      ( -1 , -1 , 2 ),
      ( -1 , -1 , 3 ),
      ( -1 , 0 , -3 ),
      ( -1 , 0 , -2 ),
      ( -1 , 0 , -1 ),
      ( -1 , 0 , 0 ),
      ( -1 , 0 , 1 ),
      ( -1 , 0 , 2 ),
      ( -1 , 0 , 3 ),
      ( -1 , 1 , -3 ),
      ( -1 , 1 , -2 ),
      ( -1 , 1 , -1 ),
      ( -1 , 1 , 0 ),
      ( -1 , 1 , 1 ),
      ( -1 , 1 , 2 ),
      ( -1 , 1 , 3 ),
      ( -1 , 2 , -3 ),
      ( -1 , 2 , -2 ),
      ( -1 , 2 , -1 ),
      ( -1 , 2 , 0 ),
      ( -1 , 2 , 1 ),
      ( -1 , 2 , 2 ),
      ( -1 , 2 , 3 ),
      ( -1 , 3 , -3 ),
      ( -1 , 3 , -2 ),
      ( -1 , 3 , -1 ),
      ( -1 , 3 , 0 ),
      ( -1 , 3 , 1 ),
      ( -1 , 3 , 2 ),
      ( -1 , 3 , 3 ),
      ( 0 , -3 , -3 ),
      ( 0 , -3 , -2 ),
      ( 0 , -3 , -1 ),
      ( 0 , -3 , 0 ),
      ( 0 , -3 , 1 ),
      ( 0 , -3 , 2 ),
      ( 0 , -3 , 3 ),
      ( 0 , -2 , -3 ),
      ( 0 , -2 , -2 ),
      ( 0 , -2 , -1 ),
      ( 0 , -2 , 0 ),
      ( 0 , -2 , 1 ),
      ( 0 , -2 , 2 ),
      ( 0 , -2 , 3 ),
      ( 0 , -1 , -3 ),
      ( 0 , -1 , -2 ),
      ( 0 , -1 , -1 ),
      ( 0 , -1 , 0 ),
      ( 0 , -1 , 1 ),
      ( 0 , -1 , 2 ),
      ( 0 , -1 , 3 ),
      ( 0 , 0 , -3 ),
      ( 0 , 0 , -2 ),
      ( 0 , 0 , -1 ),
      ( 0 , 0 , 0 ),
      ( 0 , 0 , 1 ),
      ( 0 , 0 , 2 ),
      ( 0 , 0 , 3 ),
      ( 0 , 1 , -3 ),
      ( 0 , 1 , -2 ),
      ( 0 , 1 , -1 ),
      ( 0 , 1 , 0 ),
      ( 0 , 1 , 1 ),
      ( 0 , 1 , 2 ),
      ( 0 , 1 , 3 ),
      ( 0 , 2 , -3 ),
      ( 0 , 2 , -2 ),
      ( 0 , 2 , -1 ),
      ( 0 , 2 , 0 ),
      ( 0 , 2 , 1 ),
      ( 0 , 2 , 2 ),
      ( 0 , 2 , 3 ),
      ( 0 , 3 , -3 ),
      ( 0 , 3 , -2 ),
      ( 0 , 3 , -1 ),
      ( 0 , 3 , 0 ),
      ( 0 , 3 , 1 ),
      ( 0 , 3 , 2 ),
      ( 0 , 3 , 3 ),
      ( 1 , -3 , -3 ),
      ( 1 , -3 , -2 ),
      ( 1 , -3 , -1 ),
      ( 1 , -3 , 0 ),
      ( 1 , -3 , 1 ),
      ( 1 , -3 , 2 ),
      ( 1 , -3 , 3 ),
      ( 1 , -2 , -3 ),
      ( 1 , -2 , -2 ),
      ( 1 , -2 , -1 ),
      ( 1 , -2 , 0 ),
      ( 1 , -2 , 1 ),
      ( 1 , -2 , 2 ),
      ( 1 , -2 , 3 ),
      ( 1 , -1 , -3 ),
      ( 1 , -1 , -2 ),
      ( 1 , -1 , -1 ),
      ( 1 , -1 , 0 ),
      ( 1 , -1 , 1 ),
      ( 1 , -1 , 2 ),
      ( 1 , -1 , 3 ),
      ( 1 , 0 , -3 ),
      ( 1 , 0 , -2 ),
      ( 1 , 0 , -1 ),
      ( 1 , 0 , 0 ),
      ( 1 , 0 , 1 ),
      ( 1 , 0 , 2 ),
      ( 1 , 0 , 3 ),
      ( 1 , 1 , -3 ),
      ( 1 , 1 , -2 ),
      ( 1 , 1 , -1 ),
      ( 1 , 1 , 0 ),
      ( 1 , 1 , 1 ),
      ( 1 , 1 , 2 ),
      ( 1 , 1 , 3 ),
      ( 1 , 2 , -3 ),
      ( 1 , 2 , -2 ),
      ( 1 , 2 , -1 ),
      ( 1 , 2 , 0 ),
      ( 1 , 2 , 1 ),
      ( 1 , 2 , 2 ),
      ( 1 , 2 , 3 ),
      ( 1 , 3 , -3 ),
      ( 1 , 3 , -2 ),
      ( 1 , 3 , -1 ),
      ( 1 , 3 , 0 ),
      ( 1 , 3 , 1 ),
      ( 1 , 3 , 2 ),
      ( 1 , 3 , 3 ),
      ( 2 , -3 , -3 ),
      ( 2 , -3 , -2 ),
      ( 2 , -3 , -1 ),
      ( 2 , -3 , 0 ),
      ( 2 , -3 , 1 ),
      ( 2 , -3 , 2 ),
      ( 2 , -3 , 3 ),
      ( 2 , -2 , -3 ),
      ( 2 , -2 , -2 ),
      ( 2 , -2 , -1 ),
      ( 2 , -2 , 0 ),
      ( 2 , -2 , 1 ),
      ( 2 , -2 , 2 ),
      ( 2 , -2 , 3 ),
      ( 2 , -1 , -3 ),
      ( 2 , -1 , -2 ),
      ( 2 , -1 , -1 ),
      ( 2 , -1 , 0 ),
      ( 2 , -1 , 1 ),
      ( 2 , -1 , 2 ),
      ( 2 , -1 , 3 ),
      ( 2 , 0 , -3 ),
      ( 2 , 0 , -2 ),
      ( 2 , 0 , -1 ),
      ( 2 , 0 , 0 ),
      ( 2 , 0 , 1 ),
      ( 2 , 0 , 2 ),
      ( 2 , 0 , 3 ),
      ( 2 , 1 , -3 ),
      ( 2 , 1 , -2 ),
      ( 2 , 1 , -1 ),
      ( 2 , 1 , 0 ),
      ( 2 , 1 , 1 ),
      ( 2 , 1 , 2 ),
      ( 2 , 1 , 3 ),
      ( 2 , 2 , -3 ),
      ( 2 , 2 , -2 ),
      ( 2 , 2 , -1 ),
      ( 2 , 2 , 0 ),
      ( 2 , 2 , 1 ),
      ( 2 , 2 , 2 ),
      ( 2 , 2 , 3 ),
      ( 2 , 3 , -3 ),
      ( 2 , 3 , -2 ),
      ( 2 , 3 , -1 ),
      ( 2 , 3 , 0 ),
      ( 2 , 3 , 1 ),
      ( 2 , 3 , 2 ),
      ( 2 , 3 , 3 ),
      ( 3 , -3 , -3 ),
      ( 3 , -3 , -2 ),
      ( 3 , -3 , -1 ),
      ( 3 , -3 , 0 ),
      ( 3 , -3 , 1 ),
      ( 3 , -3 , 2 ),
      ( 3 , -3 , 3 ),
      ( 3 , -2 , -3 ),
      ( 3 , -2 , -2 ),
      ( 3 , -2 , -1 ),
      ( 3 , -2 , 0 ),
      ( 3 , -2 , 1 ),
      ( 3 , -2 , 2 ),
      ( 3 , -2 , 3 ),
      ( 3 , -1 , -3 ),
      ( 3 , -1 , -2 ),
      ( 3 , -1 , -1 ),
      ( 3 , -1 , 0 ),
      ( 3 , -1 , 1 ),
      ( 3 , -1 , 2 ),
      ( 3 , -1 , 3 ),
      ( 3 , 0 , -3 ),
      ( 3 , 0 , -2 ),
      ( 3 , 0 , -1 ),
      ( 3 , 0 , 0 ),
      ( 3 , 0 , 1 ),
      ( 3 , 0 , 2 ),
      ( 3 , 0 , 3 ),
      ( 3 , 1 , -3 ),
      ( 3 , 1 , -2 ),
      ( 3 , 1 , -1 ),
      ( 3 , 1 , 0 ),
      ( 3 , 1 , 1 ),
      ( 3 , 1 , 2 ),
      ( 3 , 1 , 3 ),
      ( 3 , 2 , -3 ),
      ( 3 , 2 , -2 ),
      ( 3 , 2 , -1 ),
      ( 3 , 2 , 0 ),
      ( 3 , 2 , 1 ),
      ( 3 , 2 , 2 ),
      ( 3 , 2 , 3 ),
      ( 3 , 3 , -3 ),
      ( 3 , 3 , -2 ),
      ( 3 , 3 , -1 ),
      ( 3 , 3 , 0 ),
      ( 3 , 3 , 1 ),
      ( 3 , 3 , 2 ),
      ( 3 , 3 , 3 ) ) )

    ##
    self.xs = crystal.symmetry(self.unit_cell, "P 1")
    self.ms = miller.set(self.xs, self.mi)

    self.tst_all()

  def tst_find_miller(self):
    lookup_function = miller.lookup_tensor(
      self.ms.indices(),
      self.ms.space_group(),True)
    for ii in range(self.ms.indices().size()):
      assert (  ii ==  lookup_function.find_hkl( self.ms.indices()[ii] ) )

  def tst_local_neighbourhood(self):
    local_neighbourhood_size_1_generator = miller.local_neighbourhood(
      self.ms.indices(),
      self.ms.space_group(),
      True,
      1)
    size_1 = local_neighbourhood_size_1_generator.construct_neighbourhood()
    ##-------------
    ## 171 (0, 0, 0)
    ##[122, 164, 170, 172, 178, 220]
    ##---> (-1, 0, 0)
    ##---> (0, -1, 0)
    ##---> (0, 0, -1)
    ##---> (0, 0, 1)
    ##---> (0, 1, 0)
    ##---> (1, 0, 0)
    ##-------------
    ##
    assert (size_1[171].size()==6)
    assert (size_1[171][0]==122)
    assert (size_1[171][1]==164)
    assert (size_1[171][2]==170)
    assert (size_1[171][3]==172)
    assert (size_1[171][4]==178)
    assert (size_1[171][5]==220)

  def tst_local_area(self):
    property = flex.bool(self.ms.indices().size(), True)
    area = miller.local_area(
      self.ms.indices(),
      property,
      self.ms.space_group(),
      True,
      1,
      1,
      1000)
    assert (area.area()[171].size()==7)
    assert (area.area()[171][1]==122)
    assert (area.area()[171][2]==164)
    assert (area.area()[171][3]==170)
    assert (area.area()[171][4]==172)
    assert (area.area()[171][5]==178)
    assert (area.area()[171][6]==220)

    area = miller.local_area(
      self.ms.indices(),
      property,
      self.ms.space_group(),
      True,
      1,
      2,
      1000)
    assert (area.area()[171].size()==25)

    assert (area.area()[171][1]==122)
    assert (area.area()[171][2]==164)
    assert (area.area()[171][3]==170)
    assert (area.area()[171][4]==172)
    assert (area.area()[171][5]==178)
    assert (area.area()[171][6]==220)

    assert (area.area()[171][7]==73)
    assert (area.area()[171][8]==115)
    assert (area.area()[171][9]==121)
    assert (area.area()[171][10]==123)
    assert (area.area()[171][11]==129)
    assert (area.area()[171][12]==157)

    assert (area.area()[171][13]==163)
    assert (area.area()[171][14]==165)
    assert (area.area()[171][15]==213)
    assert (area.area()[171][16]==169)
    assert (area.area()[171][17]==177)
    assert (area.area()[171][18]==219)

    assert (area.area()[171][19]==173)
    assert (area.area()[171][20]==179)
    assert (area.area()[171][21]==221)
    assert (area.area()[171][22]==185)
    assert (area.area()[171][23]==227)
    assert (area.area()[171][24]==269)


  def tst_all(self):
    self.tst_find_miller()
    self.tst_local_neighbourhood()
    self.tst_local_area()
    print("OK")


def run():
  test_miller =  miller_lookup_utils_tester()

run()


 *******************************************************************************


 *******************************************************************************
cctbx/regression/tst_miller_merge_equivalents.py
from __future__ import absolute_import, division, print_function
from cctbx import miller
from cctbx.development import random_structure
from cctbx.development import debug_utils
from cctbx.array_family import flex
from libtbx.test_utils import approx_equal, Exception_expected
from libtbx.utils import Sorry
from six.moves import cStringIO as StringIO
import random
import sys
from six.moves import range

def exercise(space_group_info, anomalous_flag,
             n_scatterers=8, d_min=2, verbose=0):
  structure = random_structure.xray_structure(
    space_group_info,
    elements=["const"]*n_scatterers)
  f_calc = structure.structure_factors(
    d_min=d_min, anomalous_flag=anomalous_flag).f_calc()
  f = abs(f_calc)
  fs = miller.array(miller_set=f, data=f.data(), sigmas=flex.sqrt(f.data()))
  assert fs.is_unique_set_under_symmetry()
  for a in (f, fs):
    for algorithm in ["gaussian", "shelx"]:
      m = a.merge_equivalents(algorithm=algorithm)
      m.show_summary(out=StringIO())
      j = m.array().adopt_set(a)
      assert flex.linear_correlation(
        j.data(), a.data()).coefficient() > 1-1.e-6
      if (a.sigmas() is not None):
        assert flex.linear_correlation(
          j.sigmas(), a.sigmas()).coefficient() > 1-1.e-6
  redundancies = flex.size_t()
  for i in range(fs.indices().size()):
    redundancies.append(random.randrange(5)+1)
  space_group = space_group_info.group()
  r_indices = flex.miller_index()
  r_data = flex.double()
  r_sigmas = flex.double()
  for i,n in enumerate(redundancies):
    h = fs.indices()[i]
    h_eq = miller.sym_equiv_indices(space_group, h).indices()
    for j in range(n):
      r_indices.append(h_eq[random.randrange(len(h_eq))].h())
      r_data.append(fs.data()[i])
      r_sigmas.append(fs.sigmas()[i])
  r = miller.array(
    miller_set=miller.set(
      crystal_symmetry=fs,
      indices=r_indices,
      anomalous_flag=fs.anomalous_flag()),
    data=r_data,
    sigmas=r_sigmas)
  assert not r.is_unique_set_under_symmetry()
  noise = flex.random_double(size=r.indices().size())
  r = r.sort(by_value=noise)
  for algorithm in ["gaussian", "shelx"]:
    m = r.merge_equivalents(algorithm=algorithm)
    m.show_summary(out=StringIO())
    j = m.array().adopt_set(fs)
    assert j.is_unique_set_under_symmetry()
    assert flex.linear_correlation(
      j.data(), fs.data()).coefficient() > 1-1.e-6
    fssr = fs.sigmas() / flex.sqrt(redundancies.as_double())
    assert flex.linear_correlation(j.sigmas(), fssr).coefficient() > 1-1.e-6
  #
  if (anomalous_flag):
    f_calc_ave = f_calc.average_bijvoet_mates() # uses merge_equivalents
    f_calc_com = f_calc.as_non_anomalous_array().common_set(f_calc_ave)
    assert f_calc_com.indices().all_eq(f_calc_ave.indices())
    for part in [flex.real, flex.imag]:
      assert flex.linear_correlation(
        part(f_calc_com.data()),
        part(f_calc_ave.data())).coefficient() > 1-1.e-6
  # test use_internal_variance=False
  m = r.merge_equivalents(algorithm="gaussian", use_internal_variance=False)
  j = m.array().adopt_set(fs)
  fssr = fs.sigmas() / flex.sqrt(redundancies.as_double())
  assert flex.linear_correlation(j.sigmas(), fssr).coefficient() > 1-1.e-6

def exercise_incompatible_flags_replacement():
  i = flex.miller_index(((1,2,3), (1,2,3), (3,0,3), (3,0,3), (3,0,3), (1,1,2)))
  d = flex.int((1,1,0,1,0,1))
  from cctbx import crystal
  cs = crystal.symmetry(unit_cell=(10,10,10,90,90,90), space_group_symbol="P1")
  ms = miller.set(cs, i)
  ma = miller.array(ms, data=d)
  try: ma.merge_equivalents()
  except Sorry as e: assert "merge_equivalents_exact: incompatible flags" in str(e)
  else: raise Exception_expected
  merging = ma.merge_equivalents(incompatible_flags_replacement=0)
  me = merging.array()
  assert approx_equal(me.data(), (1,1,0))
  merging = ma.merge_equivalents(incompatible_flags_replacement=2)
  me = merging.array()
  assert approx_equal(me.data(), (1,1,2))

def exercise_split_unmerged():
  import random
  random.seed(42)
  flex.set_random_seed(42)

  from cctbx import crystal
  base_set = miller.build_set(
    crystal_symmetry=crystal.symmetry(
      unit_cell=(10,10,10,90,90,90), space_group_symbol="P1"),
    d_min=1.6,
    anomalous_flag=False)
  indices = base_set.indices()
  assert (len(indices) == 510)
  unmerged_hkl = flex.miller_index()
  unmerged_data = flex.double()
  unmerged_sigmas = flex.double()
  redundancies = flex.size_t()
  # XXX grossly overengineered, but I wanted to get a realistic CC to make sure
  # the reflections are being split properly
  for i, hkl in enumerate(indices):
    n_obs = min(8, 1 + i % 12)
    redundancies.append(n_obs)
    intensity_merged = (510 - i) + (510 % 27)
    for j in range(n_obs):
      unmerged_hkl.append(hkl)
      intensity = intensity_merged + 20 * (510 % (7 * (j+1)))
      sigma = max(0.5, i % 10)
      unmerged_data.append(intensity)
      unmerged_sigmas.append(sigma)
  assert (unmerged_hkl.size() == 2877)
  unmerged_array = miller.set(
    crystal_symmetry=base_set,
    indices=unmerged_hkl,
    anomalous_flag=False).array(data=unmerged_data, sigmas=unmerged_sigmas)
  split = miller.split_unmerged(
    unmerged_indices=unmerged_hkl,
    unmerged_data=unmerged_data,
    unmerged_sigmas=unmerged_sigmas)
  assert (split.data_1.size() == split.data_2.size() == 467)
  cc = miller.compute_cc_one_half(unmerged_array)
  assert approx_equal(cc, 0.861, eps=0.001)
  unmerged_array.setup_binner(n_bins=10)
  unmerged_array.set_observation_type_xray_intensity()
  result = unmerged_array.cc_one_half(use_binning=True)
  assert approx_equal(
    result.data[1:-1],
    [0.549, 0.789, 0.843, 0.835, 0.863, 0.860, 0.893, 0.847, 0.875, 0.859],
    eps=0.05)

def run_call_back(flags, space_group_info):
  for anomalous_flag in (False, True):
    exercise(space_group_info, anomalous_flag)

def run():
  exercise_incompatible_flags_replacement()
  exercise_split_unmerged()
  debug_utils.parse_options_loop_space_groups(sys.argv[1:], run_call_back)
  print("OK")

if (__name__ == "__main__"):
  run()


 *******************************************************************************


 *******************************************************************************
cctbx/regression/tst_miller_statistics.py

from __future__ import absolute_import, division, print_function
from iotbx import file_reader
from cctbx.array_family import flex
from cctbx import crystal
from cctbx import xray
import libtbx.load_env
from libtbx.test_utils import approx_equal
from six.moves import cStringIO as StringIO
import os.path

def exercise():
  hkl_file = libtbx.env.find_in_repositories(
    relative_path="phenix_examples/p9-sad/p9.sca",
    test=os.path.isfile)
  if (hkl_file is None):
    print("phenix_examples/p9-sad/p9.sca not available, skipping test")
    return
  # XXX very hard to avoid cross-imports here if we want to test on actual
  # real data...
  hkl_in = file_reader.any_file(hkl_file)
  i_obs = hkl_in.file_server.miller_arrays[0]
  i_obs.setup_binner(n_bins=50)
  meas = i_obs.measurability()
  assert approx_equal(meas, 0.091044)
  meas_binned = i_obs.measurability(use_binning=True)
  bijvoet_ratios = i_obs.bijvoet_ratios(measurable_only=True)
  assert (bijvoet_ratios.size() == 1713)
  assert approx_equal(flex.mean(bijvoet_ratios), 0.476718)
  bijvoet_ratios = i_obs.bijvoet_ratios(measurable_only=False)
  assert (bijvoet_ratios.size() == 18815)
  assert approx_equal(flex.mean(bijvoet_ratios), 0.2727699)
  wilson_mean = i_obs.wilson_plot()
  assert approx_equal(wilson_mean, 18481.1252)
  i_obs.setup_binner(n_bins=10)
  wilson_binned = i_obs.wilson_plot(use_binning=True)
  out = StringIO()
  wilson_binned.show(f=out)
  assert (out.getvalue() == """\
unused:         - 28.4910 [   0/7   ]
bin  1: 28.4910 -  3.7555 [4161/4167] 79994.6693
bin  2:  3.7555 -  2.9819 [4160/4164] 47274.9530
bin  3:  2.9819 -  2.6052 [4175/4177] 17682.1962
bin  4:  2.6052 -  2.3672 [4133/4139] 10444.3793
bin  5:  2.3672 -  2.1976 [4115/4133] 9079.7295
bin  6:  2.1976 -  2.0680 [4180/4210] 6529.7430
bin  7:  2.0680 -  1.9645 [4076/4123] 5050.6608
bin  8:  1.9645 -  1.8790 [4109/4156] 3617.7585
bin  9:  1.8790 -  1.8067 [4115/4157] 2096.0724
bin 10:  1.8067 -  1.7443 [3957/4151] 1472.1231
unused:  1.7443 -         [   0/0   ]
""")
  # TODO lots more stuff - eventually most of the functions used in Xtriage
  # should be tested here

def exercise_unmerged():
  quartz_structure = xray.structure(
    special_position_settings=crystal.special_position_settings(
      crystal_symmetry=crystal.symmetry(
        unit_cell=(5.01,5.01,5.47,90,90,120),
        space_group_symbol="P6222")),
    scatterers=flex.xray_scatterer([
      xray.scatterer(
        label="Si",
        site=(1/2.,1/2.,1/3.),
        u=0.2),
      xray.scatterer(
        label="O",
        site=(0.197,-0.197,0.83333),
        u=0.1)]))
  quartz_structure.set_inelastic_form_factors(
    photon=1.54,
    table="sasaki")
  fc = abs(quartz_structure.structure_factors(d_min=1.0).f_calc())
  symm = fc.crystal_symmetry()
  icalc = fc.expand_to_p1().f_as_f_sq().set_observation_type_xray_intensity()
  # generate 'unmerged' data
  i_obs = icalc.customized_copy(crystal_symmetry=symm)
  # now make up sigmas and some (hopefully realistic) error
  flex.set_random_seed(12345)
  n_refl = i_obs.size()
  sigmas = flex.random_double(n_refl) * flex.mean(fc.data())
  sigmas = icalc.customized_copy(data=sigmas).apply_debye_waller_factors(
    u_iso=0.15)
  err = (flex.double(n_refl, 0.5) - flex.random_double(n_refl)) * 2
  i_obs = i_obs.customized_copy(
    sigmas=sigmas.data(),
    data=i_obs.data() + err)
  # check for unmerged acentrics
  assert i_obs.is_unmerged_intensity_array()
  i_obs_centric = i_obs.select(i_obs.centric_flags().data())
  i_obs_acentric = i_obs.select(~(i_obs.centric_flags().data()))
  i_mrg_acentric = i_obs_acentric.merge_equivalents().array()
  i_mixed = i_mrg_acentric.concatenate(i_obs_centric)
  assert not i_mixed.is_unmerged_intensity_array()
  # XXX These results of these functions are heavily dependent on the
  # behavior of the random number generator, which is not consistent across
  # platforms - therefore we can only check for very approximate values.
  # Exact numerical results are tested with real data (stored elsewhere).
  # CC1/2, etc.
  assert approx_equal(i_obs.cc_one_half(), 0.9999, eps=0.001)
  assert approx_equal(i_obs.cc_one_half_sigma_tau(), 0.9999, eps=0.001)
  assert i_obs.resolution_filter(d_max=1.2).cc_one_half() > 0
  assert i_obs.cc_anom() > 0.1
  r_ano = i_obs.r_anom()
  assert approx_equal(r_ano, 0.080756, eps=0.0001)
  # merging stats
  i_mrg = i_obs.merge_equivalents()
  assert i_mrg.r_merge() < 0.1
  assert i_mrg.r_meas() < 0.1
  assert i_mrg.r_pim() < 0.05

if (__name__ == "__main__"):
  exercise()
  exercise_unmerged()
  print("OK")


 *******************************************************************************


 *******************************************************************************
cctbx/regression/tst_pair_asu_table.py
from __future__ import absolute_import, division, print_function
from iotbx.kriber import strudat
from cctbx import geometry_restraints
from cctbx import crystal
from cctbx.array_family import flex
import scitbx.math
from scitbx import matrix
from libtbx.test_utils import approx_equal, show_diff
from libtbx.utils import format_cpu_times
import libtbx.load_env
from libtbx import dict_with_default_0
from six.moves import cStringIO as StringIO
import math
import sys, os
from six.moves import range
from six.moves import zip

def exercise_icosahedron(max_level=2, verbose=0):
  for level in range(0,max_level+1):
    if (0 or verbose):
      print("level:", level)
    icosahedron = scitbx.math.icosahedron(level=level)
    try:
      distance_cutoff = icosahedron.next_neighbors_distance()*(1+1.e-3)
      estimated_distance_cutoff = False
    except RuntimeError as e:
      assert str(e) == "next_neighbors_distance not known."
      distance_cutoff = 0.4/(2**(level-1))
      estimated_distance_cutoff = True
    asu_mappings = crystal.direct_space_asu.non_crystallographic_asu_mappings(
      sites_cart=icosahedron.sites)
    pair_asu_table = crystal.pair_asu_table(asu_mappings=asu_mappings)
    pair_asu_table.add_all_pairs(distance_cutoff=distance_cutoff)
    if (0 or verbose):
      ps = pair_asu_table.show_distances(sites_cart=icosahedron.sites) \
        .distances_info
      print("level", level, "min", flex.min(ps.distances))
      print("     ", " ",   "max", flex.max(ps.distances))
      assert ps.pair_counts.all_eq(pair_asu_table.pair_counts())
      if (level == 0):
        for d in ps.distances:
          assert approx_equal(d, 1.0514622242382672)
    elif (level < 2):
      s = StringIO()
      ps = pair_asu_table.show_distances(sites_cart=icosahedron.sites, out=s) \
        .distances_info
      assert ps.pair_counts.all_eq(pair_asu_table.pair_counts())
      assert len(s.getvalue().splitlines()) == [72,320][level]
      del s
    if (level == 0):
      assert pair_asu_table.pair_counts().all_eq(5)
    else:
      assert pair_asu_table.pair_counts().all_eq(3)
    del pair_asu_table
    max_distance = crystal.neighbors_fast_pair_generator(
      asu_mappings=asu_mappings,
      distance_cutoff=distance_cutoff).max_distance_sq()**.5
    if (0 or verbose):
      print("max_distance:", max_distance)
    if (not estimated_distance_cutoff):
      assert approx_equal(max_distance, icosahedron.next_neighbors_distance())
      assert approx_equal(max_distance/icosahedron.next_neighbors_distance(),1)

def is_sym_equiv_interaction_simple(unit_cell,
                                    i_seq,
                                    site_frac_i,
                                    j_seq,
                                    site_frac_j,
                                    special_op_j,
                                    rt_mx_ji_1,
                                    rt_mx_ji_2):
  f = unit_cell.shortest_vector_sq()**.5*.1
  trial_shifts = [f*x for x in [math.sqrt(2),math.sqrt(3),math.sqrt(5)]]
  frac = unit_cell.fractionalize
  orth = unit_cell.orthogonalize
  dist = unit_cell.distance
  for shifts in [[0,0,0], trial_shifts]:
    site_j_mod = special_op_j * frac([x+s
      for x,s in zip(orth(site_frac_j),shifts)])
    if (shifts == [0,0,0] or j_seq != i_seq):
      site_i_mod = site_frac_i
    else:
      site_i_mod = site_j_mod
    d1 = dist(rt_mx_ji_1 * site_j_mod, site_i_mod)
    d2 = dist(rt_mx_ji_2 * site_j_mod, site_i_mod)
    if (shifts == [0,0,0]):
      if (abs(d1-d2) >= 1.e-3):
        return False
  return abs(d1-d2) < 1.e-3

def check_sym_equiv(structure, bond_asu_table, weak=False):
  unit_cell = structure.unit_cell()
  asu_mappings = bond_asu_table.asu_mappings()
  sites_frac = structure.scatterers().extract_sites()
  for i_seq,records in enumerate(bond_asu_table.table()):
    rt_mx_i_inv = asu_mappings.get_rt_mx(i_seq, 0).inverse()
    for j_seq,j_sym_groups in records.items():
      i_group_rt_mx_jis = []
      for i_group,j_sym_group in enumerate(j_sym_groups):
        for j_sym in j_sym_group:
          rt_mx_ji = rt_mx_i_inv.multiply(asu_mappings.get_rt_mx(j_seq, j_sym))
          i_group_rt_mx_jis.append((i_group,rt_mx_ji))
      for gi,ri in i_group_rt_mx_jis:
        for gj,rj in i_group_rt_mx_jis:
          is_sym_equiv = is_sym_equiv_interaction_simple(
            unit_cell=unit_cell,
            i_seq=i_seq,
            site_frac_i=sites_frac[i_seq],
            j_seq=j_seq,
            site_frac_j=sites_frac[j_seq],
            special_op_j=asu_mappings.special_op(j_seq),
            rt_mx_ji_1=ri,
            rt_mx_ji_2=rj)
          if (is_sym_equiv):
            if (not weak): assert gi == gj
          else:
            assert gi != gj

def check_connectivities(bond_asu_table, connectivities, verbose=0):
  n_mismatches = 0
  for records,connectivity in zip(bond_asu_table.table(), connectivities):
    n = 0
    for j_seq,j_sym_groups in records.items():
      for j_sym_group in j_sym_groups:
        n += len(j_sym_group)
    if (0 or verbose):
      print("n, connectivity:", n, connectivity)
    assert n == connectivity

def exercise_incremental_pairs(
      structure,
      distance_cutoff,
      reference_pair_asu_table):
  ip = structure.incremental_pairs(distance_cutoff=distance_cutoff)
  for site_frac in structure.sites_frac():
    ip.process_site_frac(original_site=site_frac)
  assert ip.pair_asu_table().pair_counts().all_eq(
    reference_pair_asu_table.pair_counts())
  assert ip.pair_asu_table() == reference_pair_asu_table

def exercise_site_cluster_analysis(
      structure,
      distance_cutoff,
      reference_pair_asu_table):
  pat_selection = flex.size_t()
  pat_keep = []
  for i_seq,pair_asu_dict in enumerate(reference_pair_asu_table.table()):
    for j_seq,pair_asu_j_sym_groups in pair_asu_dict.items():
      if (j_seq == i_seq):
        for j_sym_group in pair_asu_j_sym_groups:
          assert 0 not in j_sym_group
        pat_keep.append(False)
        break
      if (j_seq < i_seq and pat_keep[j_seq]):
        pat_keep.append(False)
        break
    else:
      pat_keep.append(True)
      pat_selection.append(i_seq)
  assert reference_pair_asu_table.cluster_pivot_selection().all_eq(
    pat_selection)
  assert reference_pair_asu_table.cluster_pivot_selection(
    max_clusters=3).all_eq(pat_selection[:3])
  #
  sca = structure.site_cluster_analysis(min_distance=distance_cutoff)
  sca_selection = flex.size_t()
  for i_seq,site_frac in enumerate(structure.sites_frac()):
    if (sca.process_site_frac(original_site=site_frac)):
      sca_selection.append(i_seq)
  assert sca_selection.all_eq(pat_selection)
  #
  sca = structure.site_cluster_analysis(min_distance=distance_cutoff)
  sca_selection = sca.process_sites_frac(
    original_sites=structure.sites_frac(),
    site_symmetry_table=structure.site_symmetry_table())
  assert sca_selection.all_eq(pat_selection)
  #
  sca = structure.site_cluster_analysis(min_distance=distance_cutoff)
  sca_selection = sca.process_sites_frac(
    original_sites=structure.sites_frac(),
    site_symmetry_table=structure.site_symmetry_table(),
    max_clusters=3)
  assert sca_selection.all_eq(pat_selection[:3])
  #
  sca = structure.site_cluster_analysis(min_distance=distance_cutoff)
  sca_selection = sca.process_sites_frac(
    original_sites=structure.sites_frac())
  assert sca_selection.all_eq(pat_selection)
  #
  sca = structure.site_cluster_analysis(min_distance=distance_cutoff)
  sca_selection = sca.process_sites_frac(
    original_sites=structure.sites_frac(),
    max_clusters=3)
  assert sca_selection.all_eq(pat_selection[:3])
  #
  sca = structure.site_cluster_analysis(min_distance=distance_cutoff)
  sca_selection = sca.process_sites_cart(
    original_sites=structure.sites_cart(),
    site_symmetry_table=structure.site_symmetry_table())
  assert sca_selection.all_eq(pat_selection)
  #
  sca = structure.site_cluster_analysis(min_distance=distance_cutoff)
  sca_selection = sca.process_sites_cart(
    original_sites=structure.sites_cart(),
    site_symmetry_table=structure.site_symmetry_table(),
    max_clusters=3)
  assert sca_selection.all_eq(pat_selection[:3])
  #
  sca = structure.site_cluster_analysis(min_distance=distance_cutoff)
  sca_selection = sca.process_sites_cart(
    original_sites=structure.sites_cart())
  assert sca_selection.all_eq(pat_selection)
  #
  sca = structure.site_cluster_analysis(min_distance=distance_cutoff)
  sca_selection = sca.process_sites_cart(
    original_sites=structure.sites_cart(),
    max_clusters=3)
  assert sca_selection.all_eq(pat_selection[:3])
  #
  sca = structure.site_cluster_analysis(
    min_distance=distance_cutoff,
    general_positions_only=True)
  sca_selection = sca.process_sites_frac(
    original_sites=structure.sites_frac(),
    site_symmetry_table=structure.site_symmetry_table())
  pat_selection = reference_pair_asu_table.cluster_pivot_selection(
    general_positions_only=True)
  assert sca_selection.all_eq(pat_selection)

def exercise(
      structure,
      distance_cutoff,
      connectivities=None,
      weak_check_sym_equiv=False,
      verbose=0):
  if (0 or verbose):
    print("distance_cutoff:", distance_cutoff)
  asu_mappings = structure.asu_mappings(buffer_thickness=distance_cutoff)
  for i_pass in range(2):
    if (i_pass == 0):
      bond_asu_table = crystal.pair_asu_table(asu_mappings=asu_mappings)
      bond_asu_table.add_all_pairs(
        distance_cutoff=distance_cutoff)
      exercise_incremental_pairs(
        structure=structure,
        distance_cutoff=distance_cutoff,
        reference_pair_asu_table=bond_asu_table)
      exercise_site_cluster_analysis(
        structure=structure,
        distance_cutoff=distance_cutoff,
        reference_pair_asu_table=bond_asu_table)
    else:
      bond_sym_table = bond_asu_table.extract_pair_sym_table()
      bond_asu_table = crystal.pair_asu_table(asu_mappings=asu_mappings)
      bond_asu_table.add_pair_sym_table(
        sym_table=bond_sym_table)
      def exercise_symmetry_equivalent_pair_interactions():
        asu_mappings = bond_asu_table.asu_mappings()
        for i_seq, j_seq_dict in enumerate(bond_asu_table.table()):
          rt_mx_i = asu_mappings.get_rt_mx(i_seq, 0)
          rt_mx_i_inv = rt_mx_i.inverse()
          for j_seq,j_sym_group in j_seq_dict.items():
            scs = structure.scatterers()
            def get_coords(symops):
              result = []
              for s in symops:
                result.append(numstr(s * scs[j_seq].site))
              result.sort()
              return result
            prev_equiv_rt_mx_ji = None
            for j_syms in j_sym_group:
              equiv_rt_mx_ji = []
              for j_sym in j_syms:
                rt_mx_ji = rt_mx_i_inv.multiply(
                  asu_mappings.get_rt_mx(j_seq, j_sym))
                equiv_rt_mx_ji.append(rt_mx_ji)
              old_coords = get_coords(equiv_rt_mx_ji)
              all_sepi = set()
              for rt_mx_ji in equiv_rt_mx_ji:
                _ = asu_mappings.site_symmetry_table()
                sepi_obj = _.symmetry_equivalent_pair_interactions(
                  i_seq=i_seq, j_seq=j_seq, rt_mx_ji=rt_mx_ji)
                sepi = sepi_obj.get()
                new_coords = get_coords(sepi)
                assert new_coords == old_coords
                all_sepi.add(";".join([str(_) for _ in sepi]))
                for _ in equiv_rt_mx_ji:
                  assert sepi_obj.is_equivalent(rt_mx_ji=_)
                if (prev_equiv_rt_mx_ji is not None):
                  for _ in prev_equiv_rt_mx_ji:
                    assert not sepi_obj.is_equivalent(rt_mx_ji=_)
              assert len(all_sepi) == 1
              prev_equiv_rt_mx_ji = equiv_rt_mx_ji
      exercise_symmetry_equivalent_pair_interactions()
      def exercise_pair_sym_table_tidy_and_full_connectivity():
        def check_one_way(pst):
          for sym_pair in pst.iterator():
            i_seq, j_seq = sym_pair.i_seqs()
            assert i_seq <= j_seq
            assert len(pst[i_seq][j_seq]) > 0
            if (i_seq != j_seq):
              assert i_seq not in pst[j_seq]
        def check_two_way(pst):
          for sym_pair in pst.iterator():
            i_seq, j_seq = sym_pair.i_seqs()
            assert len(pst[i_seq][j_seq]) > 0
            assert len(pst[j_seq][i_seq]) > 0
        pst_extracted = bond_sym_table.tidy(
          site_symmetry_table=structure.site_symmetry_table())
        check_one_way(pst_extracted)
        sio_extracted = StringIO()
        structure.pair_sym_table_show(pst_extracted, out=sio_extracted)
        pst = pst_extracted.tidy(
          site_symmetry_table=structure.site_symmetry_table())
        check_one_way(pst)
        sio = StringIO()
        structure.pair_sym_table_show(pst, out=sio)
        assert not show_diff(sio.getvalue(), sio_extracted.getvalue())
        pst = pst_extracted.full_connectivity()
        check_two_way(pst)
        pst_full = pst_extracted.full_connectivity(
          site_symmetry_table=structure.site_symmetry_table())
        check_two_way(pst_full)
        sio = StringIO()
        structure.pair_sym_table_show(
          pst_full, is_full_connectivity=True, out=sio)
        assert sio.getvalue().find("sym. equiv.") < 0
        pst = pst_full.tidy(
          site_symmetry_table=structure.site_symmetry_table())
        check_one_way(pst)
        sio = StringIO()
        structure.pair_sym_table_show(pst, out=sio)
        assert not show_diff(sio.getvalue(), sio_extracted.getvalue())
        pst_full2 = pst_full.full_connectivity(
          site_symmetry_table=structure.site_symmetry_table())
        check_two_way(pst_full2)
        pst = pst_full2.tidy(
          site_symmetry_table=structure.site_symmetry_table())
        check_one_way(pst)
        sio = StringIO()
        structure.pair_sym_table_show(pst, out=sio)
        assert not show_diff(sio.getvalue(), sio_extracted.getvalue())
      exercise_pair_sym_table_tidy_and_full_connectivity()
    if (connectivities is not None):
      check_connectivities(bond_asu_table, connectivities, verbose)
    check_sym_equiv(
      structure=structure,
      bond_asu_table=bond_asu_table,
      weak=weak_check_sym_equiv)

def exercise_bond_sorted_asu_proxies(
      structure,
      distance_cutoff):
  asu_mappings = structure.asu_mappings(buffer_thickness=distance_cutoff)
  bond_asu_table = crystal.pair_asu_table(asu_mappings=asu_mappings)
  bond_asu_table.add_all_pairs(distance_cutoff=distance_cutoff)
  bond_sym_table = bond_asu_table.extract_pair_sym_table()
  el = bond_sym_table.simple_edge_list()
  es = bond_sym_table.full_simple_connectivity()
  assert es.size() == bond_sym_table.size()
  for i,j in el:
    assert j in es[i]
    assert i in es[j]
  npis = bond_sym_table.number_of_pairs_involving_symmetry()
  assert len(list(bond_sym_table.iterator())) == len(el) + npis
  bond_params_table = geometry_restraints.bond_params_table(
    structure.scatterers().size())
  for i_seq,bond_sym_dict in enumerate(bond_sym_table):
    for j_seq in bond_sym_dict.keys():
      if (i_seq > j_seq):
        j_seq,i_seq = i_seq,j_seq
      bond_params_table[i_seq][j_seq] = geometry_restraints.bond_params(
        distance_ideal=3.1, weight=1)
  proxies_fast = geometry_restraints.bond_sorted_asu_proxies(
    bond_params_table=bond_params_table,
    bond_asu_table=bond_asu_table)
  proxies_conservative = geometry_restraints.bond_sorted_asu_proxies(
    pair_asu_table=bond_asu_table)
  pair_generator = crystal.neighbors_simple_pair_generator(
    asu_mappings=asu_mappings,
    distance_cutoff=distance_cutoff,
    minimal=False)
  proxies_slow = geometry_restraints.bond_sorted_asu_proxies(
    asu_mappings=asu_mappings)
  for pair in pair_generator:
    proxies_slow.process(geometry_restraints.bond_asu_proxy(
      pair=pair,
      distance_ideal=3.1,
      weight=1))
  def compare_proxies(proxies_1, proxies_2):
    assert proxies_1.simple.size() == proxies_2.simple.size()
    assert proxies_1.asu.size() == proxies_2.asu.size()
    ctrl = {}
    for proxy in proxies_1.simple:
      assert proxy.i_seqs not in ctrl
      ctrl[proxy.i_seqs] = 0
    for proxy in proxies_2.simple:
      assert proxy.i_seqs in ctrl
      ctrl[proxy.i_seqs] += 1
    assert list(ctrl.values()) == [1]*len(ctrl)
    ctrl = {}
    for proxy in proxies_1.asu:
      key = proxy.i_seq,proxy.j_seq,proxy.j_sym
      assert key not in ctrl
      ctrl[key] = 0
    for proxy in proxies_2.asu:
      key = proxy.i_seq,proxy.j_seq,proxy.j_sym
      assert key in ctrl
      ctrl[key] += 1
    assert list(ctrl.values()) == [1]*len(ctrl)
  compare_proxies(proxies_1=proxies_fast, proxies_2=proxies_conservative)
  compare_proxies(proxies_1=proxies_fast, proxies_2=proxies_slow)
  sites_cart = structure.sites_cart()
  for proxy in proxies_conservative.simple:
    i,j = proxy.i_seqs
    assert approx_equal(
      abs(matrix.col(sites_cart[i]) - matrix.col(sites_cart[j])),
      proxy.distance_ideal)
    assert proxy.weight == 1
  distance = proxies_conservative.asu_mappings().unit_cell().distance
  get_rt_mx_ji = proxies_conservative.asu_mappings().get_rt_mx_ji
  sites_frac = structure.sites_frac()
  for proxy in proxies_conservative.asu:
    assert approx_equal(
      distance(
        sites_frac[proxy.i_seq],
        get_rt_mx_ji(pair=proxy) * sites_frac[proxy.j_seq]),
      proxy.distance_ideal)
    assert proxy.weight == 1

def py_pair_asu_table_angle_pair_asu_table(self):
  asu_mappings = self.asu_mappings()
  result = crystal.pair_asu_table(asu_mappings=asu_mappings)
  for i_seq,asu_dict in enumerate(self.table()):
    pair_list = []
    for j_seq,j_sym_groups in asu_dict.items():
      for i_group,j_sym_group in enumerate(j_sym_groups):
        for j_sym in j_sym_group:
          pair_list.append((j_seq,j_sym))
    for i_jj1 in range(0,len(pair_list)-1):
      jj1 = pair_list[i_jj1]
      rt_mx_jj1_inv = asu_mappings.get_rt_mx(*jj1).inverse()
      for i_jj2 in range(i_jj1+1,len(pair_list)):
        jj2 = pair_list[i_jj2]
        result.add_pair(
          i_seq=jj1[0],
          j_seq=jj2[0],
          rt_mx_ji=rt_mx_jj1_inv.multiply(asu_mappings.get_rt_mx(*jj2)))
  return result

def exercise_angle_pair_asu_table(
      structure,
      distance_cutoff,
      connectivities,
      reference_apatanl,
      reference_cppc):
  sg_asu_mappings = structure.asu_mappings(
    buffer_thickness=2*distance_cutoff)
  sg_pat = crystal.pair_asu_table(asu_mappings=sg_asu_mappings)
  sg_pat.add_all_pairs(
    distance_cutoff=distance_cutoff,
    min_cubicle_edge=0)
  # compare connectivities with reference
  assert list(sg_pat.pair_counts()) == connectivities
  #
  p1_structure = structure.expand_to_p1()
  p1_asu_mappings = p1_structure.asu_mappings(
    buffer_thickness=2*distance_cutoff)
  p1_pat = crystal.pair_asu_table(asu_mappings=p1_asu_mappings)
  p1_pat.add_all_pairs(
    distance_cutoff=distance_cutoff,
    min_cubicle_edge=0)
  sg_labels = structure.scatterers().extract_labels()
  p1_labels = p1_structure.scatterers().extract_labels()
  label_connect = dict(zip(sg_labels, sg_pat.pair_counts()))
  for l,c in zip(p1_labels, p1_pat.pair_counts()):
    # compare connectivities in original space group and in P1
    assert label_connect[l] == c
  #
  sg_apat_py = py_pair_asu_table_angle_pair_asu_table(self=sg_pat)
  sg_apat = sg_pat.angle_pair_asu_table()
  assert sg_apat.as_nested_lists() == sg_apat_py.as_nested_lists()
  sg_counts = {}
  for i_seq,pair_asu_dict in enumerate(sg_apat.table()):
    lbl_i = sg_labels[i_seq]
    for j_seq,pair_asu_j_sym_groups in pair_asu_dict.items():
      lbl_j = sg_labels[j_seq]
      for j_sym_group in pair_asu_j_sym_groups:
        sg_counts.setdefault(lbl_i, dict_with_default_0())[
                             lbl_j] += len(j_sym_group)
  p1_apat = p1_pat.angle_pair_asu_table()
  p1_counts = {}
  for i_seq,pair_asu_dict in enumerate(p1_apat.table()):
    lbl_i = p1_labels[i_seq]
    for j_seq,pair_asu_j_sym_groups in pair_asu_dict.items():
      lbl_j = p1_labels[j_seq]
      for j_sym_group in pair_asu_j_sym_groups:
        p1_counts.setdefault(lbl_i, dict_with_default_0())[
                             lbl_j] += len(j_sym_group)
  # self-consistency check
  multiplicities = {}
  for sc in structure.scatterers():
    multiplicities[sc.label] = sc.multiplicity()
  assert sorted(p1_counts.keys()) == sorted(sg_counts.keys())
  for lbl_i,sg_lc in sg_counts.items():
    p1_lc = p1_counts[lbl_i]
    assert sorted(p1_lc.keys()) == sorted(sg_lc.keys())
    for lbl_j,sg_c in sg_lc.items():
      p1_c = p1_lc[lbl_j]
      assert p1_c == sg_c * multiplicities[lbl_i]
  # compare with reference
  apatanl = str(sg_apat.as_nested_lists()).replace(" ","")
  if (reference_apatanl is not None):
    assert apatanl == reference_apatanl
  #
  counts = []
  for conserve_angles in [False, True]:
    proxies = structure.conservative_pair_proxies(
      bond_sym_table=sg_pat.extract_pair_sym_table(),
      conserve_angles=conserve_angles)
    counts.extend([proxies.bond.simple.size(), proxies.bond.asu.size()])
    if (not conserve_angles):
      assert proxies.angle is None
    else:
      counts.extend([proxies.angle.simple.size(), proxies.angle.asu.size()])
  cppc = ",".join([str(c) for c in counts])
  if (reference_cppc is not None):
    assert cppc == reference_cppc

def exercise_all():
  verbose = "--verbose" in sys.argv[1:]
  exercise_icosahedron(verbose=verbose)
  default_distance_cutoff = 3.5
  regression_misc = libtbx.env.find_in_repositories("phenix_regression/misc")
  if (regression_misc is None):
    print("Skipping exercise_all(): phenix_regression/misc not available")
    return
  def get_reference_dict(file_name):
    path = os.path.join(regression_misc, file_name)
    if (not os.path.isfile(path)):
      print("Skipping some tests: reference file not available:", path)
      return None
    result = {}
    with open(path) as f:
      lines = f.read().splitlines()
    for line in lines:
      tag, data = line.split()
      assert not tag in result
      result[tag] = data
    return result
  reference_apatanl_dict = get_reference_dict(
    "angle_pair_asu_tables_as_nested_lists")
  reference_cppc_dict = get_reference_dict(
    "conservative_pair_proxies_counts")
  file_names = []
  for file_name in ["strudat_zeolite_atlas", "strudat_special_bonds"]:
    path = os.path.join(regression_misc, file_name)
    if (not os.path.isfile(path)):
      print("Skipping %s test: input file not available" % file_name)
    else:
      file_names.append(path)
  for file_name in file_names:
    with open(file_name) as f:
      strudat_entries = strudat.read_all_entries(f)
    for i_entry,entry in enumerate(strudat_entries.entries):
      if (    file_name.endswith("strudat_zeolite_atlas")
          and not ("--full" in sys.argv[1:] or i_entry % 20 == 0)):
        continue
      if (0 or verbose):
        print("strudat tag:", entry.tag)
      structure = entry.as_xray_structure()
      if (0 or verbose):
        structure.show_summary().show_scatterers()
      if (entry.title.startswith("cutoff")):
        distance_cutoff = float(entry.title.split()[1])
      else:
        distance_cutoff = default_distance_cutoff
      weak_check_sym_equiv = (
        entry.reference.find("weak_check_sym_equiv") >= 0)
      connectivities = entry.connectivities(all_or_nothing=True)
      if (1):
        exercise(
          structure=structure,
          distance_cutoff=distance_cutoff,
          connectivities=connectivities,
          weak_check_sym_equiv=weak_check_sym_equiv,
          verbose=verbose)
      if (0 or verbose):
        print()
      if (file_name.endswith("strudat_zeolite_atlas")):
        exercise_bond_sorted_asu_proxies(
          structure=structure,
          distance_cutoff=distance_cutoff)
      if (reference_apatanl_dict is None):
        reference_apatanl = None
      else:
        assert entry.tag in reference_apatanl_dict
        reference_apatanl = reference_apatanl_dict[entry.tag]
      if (reference_cppc_dict is None):
        reference_cppc = None
      else:
        assert entry.tag in reference_cppc_dict
        reference_cppc = reference_cppc_dict[entry.tag]
      exercise_angle_pair_asu_table(
        structure=structure,
        distance_cutoff=distance_cutoff,
        connectivities=connectivities,
        reference_apatanl=reference_apatanl,
        reference_cppc=reference_cppc)

def run():
  exercise_all()
  print(format_cpu_times())

if (__name__ == "__main__"):
  run()


 *******************************************************************************


 *******************************************************************************
cctbx/regression/tst_pointgroup_tools.py
from __future__ import absolute_import, division, print_function
import sys
from cctbx import uctbx
from cctbx import sgtbx
from cctbx.array_family import flex
from cctbx import crystal
from cctbx.crystal.find_best_cell import alternative_find_best_cell as fbc
from cctbx import miller
from cctbx.sgtbx import pointgroup_tools as pt
from libtbx.test_utils import approx_equal
from six.moves import cStringIO as StringIO
from six.moves import range

def tst_pgtools():
  unit_cell = uctbx.unit_cell('40, 40, 60, 90.0, 90.0, 90.0')
  mi = flex.miller_index(((2,4,6), (2,4,8)))
  xs = crystal.symmetry(unit_cell, "P 1 2 1")
  ms = miller.set(xs, mi)

  # Go to the minimum cell, for safety
  cob_min_cell = ms.change_of_basis_op_to_minimum_cell()

  ms_new = ms.change_basis( cob_min_cell )

  lattice_group = sgtbx.lattice_symmetry.group(
    ms_new.unit_cell(),
    max_delta=5.0)

  point_group_low = ms_new.space_group().build_derived_point_group()
  point_group_high = lattice_group.build_derived_point_group()

  pgtree = pt.point_group_graph(point_group_low,point_group_high)

  # find the possible routes from 'P 2' to 'P 4 2 2'
  atlas = pgtree.graph.find_all_paths( 'P 1 2 1', 'P 4 2 2')
  route_1 = ['P 1 2 1', 'P 4 2 2']
  route_2 = ['P 1 2 1', 'P 2 2 2', 'P 4 2 2']
  assert route_1 in atlas
  assert route_2 in atlas
  assert len(atlas)==2

  # Now lets 'disqualify' point group 'P 2 2 2'
  pgtree.remove_point_group_and_its_super_groups_from_graph(
    str(sgtbx.space_group_info(16)))
  assert len(pgtree.graph.node_objects)==1
  assert 'P 1 2 1' in pgtree.graph.node_objects


def tst_sg_tools():
  unit_cell = uctbx.unit_cell('40, 50, 60, 90.0, 90.0, 90.0')
  mi = flex.miller_index(((2,4,6), (2,4,8)))
  xs = crystal.symmetry(unit_cell, "P 1 1 21")
  ms = miller.set(xs, mi)

  tmp_choice = pt.space_group_graph_from_cell_and_sg(unit_cell,
                                                     xs.space_group())

  xs1=crystal.symmetry(uctbx.unit_cell('40.00 60.00 50.00 90.00 90.00 90.00'),
                       'P 1 21 1')

  xs2=crystal.symmetry(uctbx.unit_cell('40.00 50.00 60.00 90.00 90.00 90.00'),
                       'P 2 2 21')

  xs3=crystal.symmetry(uctbx.unit_cell('40.00 60.00 50.00 90.00 90.00 90.00'),
                       'P 21 21 2')

  xs4=crystal.symmetry(uctbx.unit_cell('50.00 60.00 40.00 90.00 90.00 90.00'),
                       'P 21 21 2')

  xs5=crystal.symmetry(uctbx.unit_cell('40.00 50.00 60.00 90.00 90.00 90.00'),
                       'P 21 21 21')

  p222_dict = { str( xs2.unit_cell().parameters())
                + " " + str( xs2.space_group_info() ): None,
                str( xs3.unit_cell().parameters())
                + " " + str( xs3.space_group_info() ):None,
                str( xs4.unit_cell().parameters())
                + " " + str( xs4.space_group_info() ):None,
                str( xs5.unit_cell().parameters())
                + " " + str( xs5.space_group_info() ):None
                }


  p112 = tmp_choice.pg_graph.graph.node_objects['P 1 1 2'].allowed_xtal_syms
  # check the cell parameters
  assert approx_equal(p112[0][0].unit_cell().parameters(),
                      xs1.unit_cell().parameters())
  # check the sg
  assert p112[0][0].space_group() == xs1.space_group()
  # check the change of basis operator
  assert approx_equal(xs.change_basis(p112[0][1]).unit_cell().parameters(),
                      xs1.unit_cell().parameters())

  p222 = tmp_choice.pg_graph.graph.node_objects['P 2 2 2'].allowed_xtal_syms

  for xs in p222:
    comp_string = (str(xs[0].unit_cell().parameters())
                   + " " + str(xs[0].space_group_info()))
    assert comp_string in p222_dict



def test_extensively( this_chunk ):
  n_chunks = 1
  i_chunk = int(this_chunk)

  assert i_chunk <= n_chunks
  for i_sg, sg in enumerate(sgtbx.space_group_symbol_iterator()):
    if i_sg % n_chunks != i_chunk:
      continue

    buffer = StringIO()

    group = sgtbx.space_group(sg.hall())

    #if group != sgtbx.space_group_info( symbol = 'I 21 21 21' ).group():
    #  continue

    unit_cell =sgtbx.space_group_info(group=group).any_compatible_unit_cell(
      volume=57*57*76)

    xs_in = crystal.symmetry(unit_cell=unit_cell, space_group=group)
    xs_in = xs_in.best_cell()

    # Just make sure we have the 'best cell' to start out with

    xs_minimum = xs_in.change_basis(xs_in.change_of_basis_op_to_niggli_cell())

    sg_min = xs_minimum.space_group()
    sg_min_info = sgtbx.space_group_info(group = sg_min)
    sg_min_to_ref = sg_min_info.change_of_basis_op_to_reference_setting()
    sg_in_to_min = xs_in.change_of_basis_op_to_niggli_cell()

    xs_ref = xs_minimum.change_basis(sg_min_to_ref)
    best_cell_finder = fbc(xs_ref.unit_cell(),
                           xs_ref.space_group())
    xs_ref = best_cell_finder.return_best_xs()

    xs_lattice_pg = sgtbx.lattice_symmetry.group(
      xs_minimum.unit_cell(),
      max_delta=5.0)
    sg_in_ref_setting = sg_min.change_basis(sg_min_to_ref)

    # -----------
    queue = []
    if sg_in_ref_setting.is_chiral():
      print("Testing : ",\
            sgtbx.space_group_info(group=group),\
            "( or ", sgtbx.space_group_info(group=sg_in_ref_setting),\
            " in reference setting)")
      for s in sg_min:
        new_sg = sgtbx.space_group()
        new_sg.expand_smx(s)
        if new_sg in queue:
          continue
        else:
          queue.append(new_sg)
        xs_cheat = crystal.symmetry(xs_minimum.unit_cell(),
                                    space_group=new_sg)
        #print
        #print "Using symop", s

        xs_cheat_min = xs_cheat.change_basis(
          xs_cheat.change_of_basis_op_to_niggli_cell() )

        #print "This results in space group: ", xs_cheat.space_group_info()

        sg_clues = pt.space_group_graph_from_cell_and_sg(
          xs_cheat_min.unit_cell(),
          xs_cheat_min.space_group() )

        #sg_clues.show()

        found_it = False
        #print
        #print " --- Spacegroups consistent with input parameters ---"
        for sg_and_uc in sg_clues.return_likely_sg_and_cell():
          check_sg = False
          check_uc = False
          xs = crystal.symmetry(sg_and_uc[1], space_group=sg_and_uc[0])
          if approx_equal(
            sg_and_uc[1].parameters(),
            xs_ref.unit_cell().parameters(),
            eps=0.001,
            out=buffer):
            if sg_and_uc[0] == sg_in_ref_setting:
              found_it = True

          #print sgtbx.space_group_info( group=sg_and_uc[0] ), \
          #      sg_and_uc[1].parameters()
        if not found_it:
          print("FAILURE: ", sg.hall())
          assert found_it



def test_reference_setting_choices():
  buffer = StringIO()

  for space_group_info in sgtbx.reference_space_group_infos():
    space_group = space_group_info.group()

    uc = space_group_info.any_compatible_unit_cell(volume=57*57*76)
    xs = crystal.symmetry(uc, space_group=space_group)

    cobs = pt.reference_setting_choices(space_group)

    if len(cobs)>1:
      tmp_array = []
      for cob in cobs:
        xs_new =crystal.symmetry(xs.change_basis( cob ).unit_cell(),
                                 space_group=xs.space_group() )
        best_cell_finder = fbc(xs_new.unit_cell(),
                               xs_new.space_group() )

        xs_new = best_cell_finder.return_best_xs()
        tmp_array.append(xs_new)
      count = 0
      for tmp_xs1 in range(len(tmp_array)):
        for tmp_xs2 in range(len(tmp_array)):

          if (tmp_xs1 != tmp_xs2):
            assert (tmp_array[tmp_xs1].space_group()
                    == tmp_array[tmp_xs2].space_group())
            assert not approx_equal(
              tmp_array[tmp_xs1].unit_cell().parameters(),
              tmp_array[tmp_xs2].unit_cell().parameters(),
              eps=0.001,
              out=buffer)

def exercise_compatible_symmetries():
  pg = sgtbx.space_group('P 2x')
  ops = [ op.as_xyz() for op in pt.compatible_symmetries(pg) ]
  assert ops == [ 'x,-y,-z', 'x+1/2,-y,-z' ]

  pg = sgtbx.space_group('P 2x 2y')
  ops = [ op.as_xyz() for op in pt.compatible_symmetries(pg) ]
  assert ops == [ 'x,-y,-z', 'x+1/2,-y,-z',
                  '-x,y,-z', '-x,y+1/2,-z',
                  '-x,-y,z', '-x,-y,z+1/2' ]

  pg = sgtbx.space_group('P 2x 3*')
  ops = [ op.as_xyz() for op in pt.compatible_symmetries(pg) ]
  assert 'x,-y,-z' in ops
  assert 'x+1/2,-y,-z' in ops

  assert '-x,y,-z' in ops
  assert '-x,y+1/2,-z' in ops

  assert '-x,-y,z' in ops
  assert '-x,-y,z+1/2' in ops

  assert 'z,x,y' in ops
  assert 'z+1/3,x+1/3,y+1/3' in ops

  assert 'y,z,x' in ops
  assert 'y+1/3,z+1/3,x+1/3' in ops

  assert 'z,-x,-y' in ops
  assert 'z+1/3,-x-1/3,-y+1/3' in ops

  assert '-y,z,-x' in ops
  assert '-y-1/3,z+1/3,-x+1/3' in ops

  assert '-y,-z,x' in ops
  assert '-y+1/3,-z-1/3,x+1/3' in ops

  assert 'y,-z,-x' in ops
  assert 'y-1/3,-z-1/3,-x+1/3' in ops

  assert '-z,-x,y' in ops
  assert '-z-1/3,-x+1/3,y+1/3' in ops

  assert '-z,x,-y' in ops
  assert '-z-1/3,x-1/3,-y+1/3' in ops

  pg = sgtbx.space_group('-P -2y')
  ops = [ op.as_xyz() for op in pt.compatible_symmetries(pg) ]
  assert ops == ['x,-y,z', 'x+1/2,-y,z', 'x,-y,z+1/2', 'x+1/2,-y,z+1/2',
                 '-x,-y,-z', '-x,y,-z', '-x,y+1/2,-z']

def run():
  exercise_compatible_symmetries()
  tst_pgtools()
  tst_sg_tools()
  test_reference_setting_choices()
  print("OK")


if (__name__ == "__main__"):
  if len(sys.argv)>1:
    if sys.argv[1]=='insane':
      run()
      test_extensively(0) # Should take not more then 45 minutes
                          #on a reasonable machine
      print("OK")
  else:
    run()


 *******************************************************************************


 *******************************************************************************
cctbx/regression/tst_prepare_map_for_docking.py
from __future__ import print_function
from __future__ import division
import math
from iotbx.data_manager import DataManager
from iotbx.map_model_manager import map_model_manager
from cctbx.maptbx.prepare_map_for_docking import add_ordered_volume_mask
from cctbx.maptbx.prepare_map_for_docking import assess_cryoem_errors
#from cctbx.maptbx.prepare_map_for_docking import write_mtz
from cctbx import adptbx
from scitbx.array_family import flex
from libtbx.utils import format_cpu_times
from libtbx.test_utils import approx_equal
import os
import random

def get_power_spectrum(mc):

  power_spectrum = flex.double(mc.size(),1.)
  mc_copy = mc.deep_copy()
  nref = mc_copy.size()
  num_per_bin = 1000
  max_bins = 100
  min_bins = 6
  n_bins = int(round(max(min(nref / num_per_bin, max_bins), min_bins)))
  mc_copy.setup_binner(n_bins=n_bins)
  for i_bin in mc_copy.binner().range_used():
    sel = mc_copy.binner().selection(i_bin)
    mcsel = mc_copy.select(sel)
    fsq = flex.pow2(flex.abs(mcsel.data()))
    meanfsq = flex.mean_default(fsq, 0)
    power_spectrum.set_selected(sel,meanfsq)

  return power_spectrum

def exercise():
  """Test prepare_map_for_docking using data with known errors."""

  # Generate two half-maps with same anisotropic signal, independent anisotropic
  # noise. Test to see how well optimal map coefficients are estimated.

  # Use reasonably spherical model placed in the centre of a cubic unit cell
  # twice the maximum extent of the model, to simulate the situation with a
  # typical cryo-EM map.

  # Set flag for whether to print out debugging information instead of carrying
  # out regression tests with assert statements.
  # Should be set as False for released version!
  debug = False

  import libtbx.load_env
  iotbx_regression = os.path.join(libtbx.env.find_in_repositories("iotbx"),
      'regression')
  file_name=os.path.join(iotbx_regression,'data', 'big_cube_model.pdb')
  model_radius = 30. # Applies to this chosen model
  protein_mw = 19440.
  nucleic_mw = None

  d_min = 3.
  dm = DataManager()
  start_model = dm.get_model(file_name)

  # Reset B-values from zero to chosen constant
  b_iso = 30.
  b_values=flex.double(start_model.get_sites_cart().size(), b_iso)
  ph = start_model.get_hierarchy()
  ph.atoms().set_b(b_values)

  mmm = map_model_manager()
  mmm.generate_map(
      model=start_model,
      d_min=d_min, k_sol=0.1, b_sol=50.)

  if debug:
    mmm.write_model("fake_map.pdb")

  # Turn starting map into map coeffs for the signal
  start_unit_cell = mmm.map_manager().unit_cell()
  ucpars = start_unit_cell.parameters()
  d_max=max(ucpars[0], ucpars[1], ucpars[2])
  start_vol = ucpars[0] * ucpars[1] * ucpars[2]
  start_map_coeffs = mmm.map_as_fourier_coefficients(d_min=d_min, d_max=d_max)

  # Keep copy of perfect map (map for B=0 model) for tests of success
  # Add it to mmm so that it has the same masking applied as test map.
  mc_perfect_ori = start_map_coeffs.deep_copy()
  mc_perfect_ori = mc_perfect_ori.apply_debye_waller_factors(b_iso = -b_iso)
  mmm.add_map_from_fourier_coefficients(mc_perfect_ori, map_id='perfect_map')

  # Apply anisotropic scaling to map coeffs
  b_target = (50.,100.,150.,-25.,25.,50.)
  u_star_s = adptbx.u_cart_as_u_star(
      start_unit_cell, adptbx.b_as_u(b_target))
  b_model = (b_iso,b_iso,b_iso,0.,0.,0.)  # All atoms in model have B=b_iso
  b_expected = list((flex.double(b_target) + flex.double(b_model)))
  scaled_map_coeffs = start_map_coeffs.apply_debye_waller_factors(u_star=u_star_s)

  # Generate map coefficient errors for first half-map from complex normal
  # distribution
  b_target_e = (0.,0.,0.,-50.,-50.,50.) # Anisotropy for error terms
  u_star_e = adptbx.u_cart_as_u_star(
      start_unit_cell, adptbx.b_as_u(b_target_e))
  se_target = 10000. # Target for SigmaE variance term
  rsigma = math.sqrt(se_target / 2.)
  jj = 0.+1.j  # Define I for generating complex numbers
  random_complexes1 = flex.complex_double()
  ncoeffs=start_map_coeffs.size()
  random.seed(123457) # Make runs reproducible
  for i in range(ncoeffs):
    random_complexes1.append(random.gauss(0.,rsigma) + random.gauss(0.,rsigma)*jj)
  rc1_miller = start_map_coeffs.customized_copy(data=random_complexes1)
  mc1_delta = rc1_miller.apply_debye_waller_factors(u_star=u_star_e)
  map1_coeffs = scaled_map_coeffs.customized_copy(
    data=scaled_map_coeffs.data() + mc1_delta.data())

  # Repeat for second half map with independent errors from same distribution
  random_complexes2 = flex.complex_double()
  for i in range(ncoeffs):
    random_complexes2.append(random.gauss(0.,rsigma) + random.gauss(0.,rsigma)*jj)
  rc2_miller = start_map_coeffs.customized_copy(data=random_complexes2)
  mc2_delta = rc2_miller.apply_debye_waller_factors(u_star=u_star_e)
  map2_coeffs = scaled_map_coeffs.customized_copy(
    data=scaled_map_coeffs.data() + mc2_delta.data())

  mmm.add_map_from_fourier_coefficients(
      map1_coeffs, map_id = 'map_manager_1')
  mmm.add_map_from_fourier_coefficients(
      map2_coeffs, map_id = 'map_manager_2')
  # Replace original map_manager with mean of half-maps
  mm_mean_data = (mmm.map_manager_1().map_data() + mmm.map_manager_2().map_data()) / 2
  mmm.map_manager().set_map_data(map_data = mm_mean_data)

  # Add mask map for ordered component of map
  ordered_mask_id = 'ordered_volume_mask'
  add_ordered_volume_mask(mmm, d_min,
      protein_mw=protein_mw, nucleic_mw=nucleic_mw,
      ordered_mask_id=ordered_mask_id)
  box_centre = tuple(flex.double((ucpars[0],ucpars[1],ucpars[2]))/2)

  # Now refine to assess parameters describing map errors
  if debug:
    verbosity = 1
  else:
    verbosity = 0
  results = assess_cryoem_errors(
                  mmm=mmm,
                  d_min=d_min,
                  half_maps_provided=True,
                  ordered_mask_id=ordered_mask_id,
                  sphere_cent=box_centre,
                  radius=model_radius+d_min,
                  verbosity=verbosity)

  if debug:
    resultsdict = results.resultsdict
    b_refined_a = resultsdict["a_baniso"]
    print("\nIdeal   A tensor as Baniso: ", b_expected)
    print(  "Refined A tensor as Baniso: ", b_refined_a)

  # Note that all maps have been cut out with a spherical mask, so compare using these
  new_mmm = results.new_mmm
  perfect_mapCC = new_mmm.map_model_cc(map_id = 'perfect_map')
  achieved_mapCC = new_mmm.map_model_cc(map_id = 'map_manager_wtd') # Achieved map
  start_mapCC = new_mmm.map_model_cc() # Starting map with noise and anisotropy
  new_unit_cell = new_mmm.map_manager().crystal_symmetry().unit_cell()
  ucpars = new_unit_cell.parameters()
  d_max = max(ucpars[0], ucpars[1], ucpars[2])
  end_vol = 4./3. * math.pi * model_radius**3 # Random error left only in cut-out sphere
  volume_ratio = end_vol/start_vol
  mc_perfect = new_mmm.map_as_fourier_coefficients(d_min=d_min, d_max=d_max, map_id='perfect_map')
  mc_achieved = new_mmm.map_as_fourier_coefficients(d_min=d_min, d_max=d_max, map_id='map_manager_wtd')

  # Use theoretically perfect error parameters to compute ideal map coefficients.
  # First put back overall b_iso, then model the application of anisotropy and
  # addition of errors to the starting power spectrum
  mc_perfect_unsharp = mc_perfect.apply_debye_waller_factors(b_iso = b_iso)
  sigmaS_terms = get_power_spectrum(mc_perfect_unsharp) # Actual signal power before anisotropy
  ones_array = flex.double(mc_perfect.size(), 1)
  all_ones = mc_perfect.customized_copy(data = ones_array)
  # Recalculate u_star_s and u_star_e appropriate for new cut-out cell
  u_star_s = adptbx.u_cart_as_u_star(new_unit_cell, adptbx.b_as_u(b_target))
  u_star_s2 = tuple(flex.double(u_star_s)*2.) # Anisotropy of signal power
  u_star_e = adptbx.u_cart_as_u_star(new_unit_cell, adptbx.b_as_u(b_target_e))
  u_star_e2 = tuple(flex.double(u_star_e)*2.) # Anisotropy of error power
  sigmaS_terms = sigmaS_terms * all_ones.apply_debye_waller_factors(
      u_star=u_star_s2).data() # Corrected for anisotropy
  sigmaE_terms = all_ones.apply_debye_waller_factors(u_star=u_star_e2).data() * se_target * volume_ratio
  scale_terms = 1./flex.sqrt(sigmaS_terms + sigmaE_terms/2.)
  dobs_terms = flex.sqrt(sigmaS_terms / (sigmaS_terms + sigmaE_terms/2.))

  # Now take starting map, with anisotropy and average errors, and apply ideal
  # correction factors to get E and Dobs
  eE_ideal = new_mmm.map_as_fourier_coefficients(d_min=d_min, d_max=d_max)
  eE_ideal = eE_ideal.customized_copy(data = eE_ideal.data()*scale_terms)
  mean_Esqr_ideal = flex.mean_default(flex.pow2(flex.abs(eE_ideal.data())),0)
  mc_ideal_wtd = eE_ideal.customized_copy(data = eE_ideal.data()*dobs_terms)

  # Now get results from assessment of signal and errors
  expectE = results.expectE
  mean_Esqr = flex.mean_default(flex.pow2(flex.abs(expectE.data())),0)
  eps_mean_Esqr = 0.15
  if debug:
    print("\n\nRegression tests:")
    print("\nMean value of ideal E**2: ", mean_Esqr_ideal)
    print("Mean value of E**2 for docking map: ", mean_Esqr)
    print("   Target for each is 1 with an allowed deviation of ",eps_mean_Esqr)
  else:
    assert approx_equal(mean_Esqr_ideal, 1.0, eps=eps_mean_Esqr)
    assert approx_equal(mean_Esqr, 1.0, eps=eps_mean_Esqr)

  target_ideal_achieved = 0.95
  mapCC_ideal_achieved = mc_ideal_wtd.map_correlation(other=mc_achieved)
  if debug:
    print("\nCC between ideal and achieved maps:",mapCC_ideal_achieved)
    print("   Target is >= ", target_ideal_achieved)
  new_mmm.add_map_from_fourier_coefficients(
      mc_ideal_wtd, map_id = 'ideal_map')
  ideal_mapCC = new_mmm.map_model_cc(map_id = 'ideal_map')
  target_achieved = 0.95*ideal_mapCC
  if debug:
    print("\nPerfect, starting and ideal mapCC: ", perfect_mapCC, start_mapCC, ideal_mapCC)
    print("Achieved mapCC: ", achieved_mapCC)
    print("   Target is >= ", target_achieved)
  else:
    assert(mapCC_ideal_achieved > target_ideal_achieved)
    assert(achieved_mapCC > target_achieved)

if(__name__ == "__main__"):
  exercise()
  print(format_cpu_times())
  print("OK")


 *******************************************************************************


 *******************************************************************************
cctbx/regression/tst_r_free_utils.py

from __future__ import absolute_import, division, print_function
from cctbx.r_free_utils import *
from cctbx import miller
from cctbx import crystal
from cctbx import sgtbx
from cctbx import uctbx
from scitbx.array_family import flex
from libtbx.test_utils import Exception_expected, approx_equal
from libtbx.utils import Sorry
from six.moves import cStringIO as StringIO
from itertools import count
import random

def exercise():
  random.seed(12345)
  flex.set_random_seed(12345)
  flags_1 = assign_random_r_free_flags(n_refl=100000, fraction_free=0.05)
  assert (flags_1.count(True) == 5000)
  flags_1_ccp4 = assign_random_r_free_flags(n_refl=100000, fraction_free=0.05,
    format="ccp4")
  # XXX this is the best we can do with the current method
  assert (flags_1_ccp4.count(0) > 4000) and (flags_1_ccp4.count(0) < 6000)
  flags_1_shelx = assign_random_r_free_flags(n_refl=100000, fraction_free=0.05,
    format="shelx")
  assert (flags_1_shelx.count(-1) == 5000)
  flags_2 = assign_r_free_flags_by_shells(n_refl=100000,
    fraction_free=0.05,
    n_bins=50)
  assert (flags_2.count(True) == 5000)
  ccp4_flags = export_r_free_flags_for_ccp4(flags_1, True)
  assert (ccp4_flags.count(0) == flags_1.count(True))
  assert (flex.max(ccp4_flags) == 19)
  shelx_flags = export_r_free_flags_for_shelx(flags_1, True)
  assert ((shelx_flags==-1).all_eq((ccp4_flags==0)))
  flags_3 = assign_random_r_free_flags(n_refl=100000, fraction_free=0.025)
  assert (flags_3.count(True) == 2500)
  ccp4_flags = export_r_free_flags_for_ccp4(flags_3, True)
  assert (ccp4_flags.count(0) == flags_3.count(True))
  assert (flex.max(ccp4_flags) == 39)
  # now with an actual Miller array
  symm = crystal.symmetry(
    space_group_info=sgtbx.space_group_info("P212121"),
    unit_cell=uctbx.unit_cell((6,7,8,90,90,90)))
  set1 = miller.build_set(
    crystal_symmetry=symm,
    anomalous_flag=True,
    d_min=1.0)
  flags_4 = set1.generate_r_free_flags()
  stats = get_r_free_stats(flags_4, True)
  assert (19 <= stats[0] <= 25) # XXX is this even necessary?
  # much larger for the last few tests
  symm = crystal.symmetry(
    space_group_info=sgtbx.space_group_info("P212121"),
    unit_cell=uctbx.unit_cell((60,70,80,90,90,90)))
  set1 = miller.build_set(
    crystal_symmetry=symm,
    anomalous_flag=True,
    d_min=1.0)
  #print set1.indices().size()
  flags_5 = set1.generate_r_free_flags(fraction=0.1, max_free=None)
  flags_6 = adjust_fraction(flags_5, 0.15, log=null_out())
  frac_6 = flags_6.data().count(True) / flags_6.data().size()
  assert approx_equal(frac_6, 0.15, eps=0.001)
  flags_7 = adjust_fraction(flags_5, 0.05, log=null_out())
  frac_7 = flags_7.data().count(True) / flags_7.data().size()
  assert approx_equal(frac_7, 0.05, eps=0.001)
  n_flipped = 0
  for i_hkl, (h,k,l) in enumerate(flags_5.indices()):
    if (i_hkl % 100 == 0) and (h > 0) and (k > 0) and (l > 0):
      flag = flags_5.data()[i_hkl]
      if (not flag):
        n_flipped += 1
        flags_5.data()[i_hkl] = True
  # XXX check this for reproducibility on other systems
  #assert (n_flipped == 1559) # setting the random seed should ensure this
  try :
    flags_8 = flags_5.average_bijvoet_mates()
  except Sorry :
    pass
  else :
    raise Exception_expected
  out = StringIO()
  flags_9 = remediate_mismatches(flags_5, log=out)
  # XXX check this for reproducibility on other systems
  #assert (out.getvalue() == "  1559 reflections moved to test set\n")
  flags_10 = flags_9.average_bijvoet_mates()

if (__name__ == "__main__"):
  exercise()
  print("OK")


 *******************************************************************************


 *******************************************************************************
cctbx/regression/tst_reciprocal_space_asu.py
from __future__ import absolute_import, division, print_function
from cctbx.array_family import flex
from cctbx import miller
from cctbx.development import debug_utils
import sys
from six.moves import range

def get_all_incides(space_group, abs_range):
  result = {}
  for h0 in range(-abs_range,abs_range+1):
    for h1 in range(-abs_range,abs_range+1):
      for h2 in range(-abs_range,abs_range+1):
        h = (h0, h1, h2)
        if (h == (0,0,0)): continue
        equiv = miller.sym_equiv_indices(space_group, h).indices()
        for h_e in equiv:
          h_s = h_e.h()
          assert h_s == h_e.hr()
          result[h_s] = 0
  return flex.miller_index(list(result.keys()))

cond_dict = {}

def filter_asu(space_group_info, indices, verbose):
  asu = space_group_info.reciprocal_space_asu()
  assert asu.is_reference()
  cond = asu.reference_as_string()
  if (verbose): print(cond)
  cond_dict[cond] = 0
  is_centric = space_group_info.group().is_centric
  result = flex.miller_index()
  for hkl in indices:
    h,k,l = hkl
    vfy = eval(cond)
    assert vfy == asu.is_inside(hkl)
    if (asu.is_inside(hkl)):
      result.append(hkl)
      if (not is_centric(hkl)):
        result.append([-e for e in hkl])
  return result

def expand_indices(space_group, asu_indices):
  result = {}
  for hkl in asu_indices:
    equiv = miller.sym_equiv_indices(space_group, hkl).indices()
    for h_e in equiv:
      h_s = h_e.h()
      assert h_s == h_e.hr()
      assert h_s not in result
      result[h_s] = 0
  return flex.miller_index(list(result.keys()))

def exercise(space_group_info, verbose=0):
  if (not space_group_info.reciprocal_space_asu().is_reference()): return
  all_indices = get_all_incides(space_group_info.group(), abs_range=4)
  if (verbose): print("all_indices.size():", all_indices.size())
  asu_indices = filter_asu(space_group_info, all_indices, verbose)
  if (verbose): print("asu_indices.size():", asu_indices.size())
  exp_indices = expand_indices(space_group_info.group(), asu_indices)
  if (verbose): print("exp_indices.size():", exp_indices.size())
  assert all_indices.size() == exp_indices.size()

def run_call_back(flags, space_group_info):
  exercise(space_group_info, verbose=flags.Verbose)

def run():
  debug_utils.parse_options_loop_space_groups(sys.argv[1:], run_call_back)
  if (0):
    print("len(cond_dict):", len(cond_dict))
    for k in cond_dict.keys():
      print(k)

if (__name__ == "__main__"):
  run()


 *******************************************************************************


 *******************************************************************************
cctbx/regression/tst_refine_xray_curvs.py
from __future__ import absolute_import, division, print_function
from cctbx import xray
from cctbx.development import random_structure
from cctbx.development import debug_utils
from cctbx.adptbx import b_as_u
from cctbx.array_family import flex
import scitbx.lbfgs
import scitbx.lbfgsb
from scitbx import matrix
import libtbx.phil
from libtbx import easy_pickle
import random
import sys

if (1):
  random.seed(0)
  flex.set_random_seed(0)

class curv_filter(object):

  def __init__(O, curvs, lim_eps):
    c_pos = curvs.select(curvs > 0)
    O.c_lim = flex.max_default(c_pos, default=0) * lim_eps
    if (O.c_lim == 0):
      O.c_lim = 1
      O.c_rms = 1
    else:
      O.c_rms = flex.mean_sq(c_pos)**0.5
    O.n_below_limit = 0
    O.n_above_limit = 0

  def apply(O, some_curvs):
    result = flex.double()
    for c in some_curvs:
      if (c < O.c_lim):
        c = O.c_rms
        O.n_below_limit += 1
      else:
        O.n_above_limit += 1
      result.append(c)
    return result

def get_curvs_work(f_obs, weights, xray_structure, lim_eps):
  f_calc = f_obs.structure_factors_from_scatterers(
    xray_structure=xray_structure,
    algorithm="direct",
    cos_sin_table=False).f_calc()
  ls = xray.targets_least_squares(
    compute_scale_using_all_data=False,
    obs_type="F",
    obs=abs(f_calc).data(),
    weights=weights,
    r_free_flags=None,
    f_calc=f_calc.data(),
    derivatives_depth=2,
    scale_factor=1)
  gact = xray_structure.grads_and_curvs_target_simple(
    miller_indices=f_obs.indices(),
    da_db=ls.gradients_work(),
    daa_dbb_dab=ls.hessians_work())
  c_all = gact.curvs
  c_active_site = flex.double()
  c_active_u_iso = flex.double()
  i_all = 0
  sstab = xray_structure.site_symmetry_table()
  for i_sc,sc in enumerate(xray_structure.scatterers()):
    assert sc.flags.use_u_iso()
    assert not sc.flags.use_u_aniso()
    site_symmetry = sstab.get(i_sc)
    if (site_symmetry.is_point_group_1()):
      np = 3
    else:
      np = site_symmetry.site_constraints().n_independent_params()
    c_active_site.extend(c_all[i_all:i_all+np])
    c_active_u_iso.append(c_all[i_all+np])
    np += 4 # u_iso, occ, fp, fdp
    i_all += np
  assert i_all == c_all.size()
  #
  cf_site = curv_filter(curvs=c_active_site, lim_eps=lim_eps)
  cf_u_iso = curv_filter(curvs=c_active_u_iso, lim_eps=lim_eps)
  #
  result = flex.double()
  i_all = 0
  sstab = xray_structure.site_symmetry_table()
  for i_sc,sc in enumerate(xray_structure.scatterers()):
    assert sc.flags.use_u_iso()
    assert not sc.flags.use_u_aniso()
    site_symmetry = sstab.get(i_sc)
    if (site_symmetry.is_point_group_1()):
      np = 3
    else:
      np = site_symmetry.site_constraints().n_independent_params()
    result.extend(cf_site.apply(c_all[i_all:i_all+np]))
    result.extend(cf_u_iso.apply(c_all[i_all+np:i_all+np+1]))
    np += 4 # u_iso, occ, fp, fdp
    i_all += np
  assert i_all == c_all.size()
  print("curv site below limit: %d of %d" % (
    cf_site.n_below_limit,
    cf_site.n_below_limit + cf_site.n_above_limit))
  print("curv u_iso below limit: %d of %d" % (
    cf_u_iso.n_below_limit,
    cf_u_iso.n_below_limit + cf_u_iso.n_above_limit))
  sys.stdout.flush()
  return result

class refinement_stats(libtbx.slots_getstate_setstate):

  __slots__ = ["iter", "nfun", "f", "gnorm", "crmsd", "armsd", "urmsd"]

  def __init__(O, **kw):
    for slot in O.__slots__:
      setattr(O, slot, kw[slot])

class ls_refinement(object):

  def __init__(O,
        f_obs,
        xray_structure,
        params,
        lbfgs_termination_params=None,
        lbfgs_exception_handling_params=None,
        reference_structure=None):
    O.f_obs = f_obs
    O.weights = flex.double(f_obs.data().size(), 1)
    O.xray_structure = xray_structure
    O.params = params
    O.reference_structure = reference_structure
    O.curvs_work = get_curvs_work(
      f_obs=O.f_obs,
      weights=O.weights,
      xray_structure=O.xray_structure,
      lim_eps=O.params.curv_filter_lim_eps)
    if (O.params.curvature_rescaling):
      O.p_as_x = flex.sqrt(O.curvs_work)
    else:
      O.p_as_x = flex.double(O.curvs_work.size(), 1)
    O.pack_parameters()
    O.number_of_function_evaluations = -1
    O.number_of_lbfgs_iterations = -1
    O.f_start, O.g_start = O.compute_functional_and_gradients()
    O.history = []
    O.callback_after_step(minimizer=None)
    if (params.minimizer == "lbfgs"):
      O.minimizer = scitbx.lbfgs.run(
        target_evaluator=O,
        termination_params=lbfgs_termination_params,
        exception_handling_params=lbfgs_exception_handling_params)
    elif (params.minimizer == "lbfgs_raw"):
      O.run_lbfgs_raw()
    elif (params.minimizer == "lbfgsb"):
      O.run_lbfgsb()
    O.f_final, O.g_final = O.compute_functional_and_gradients()

  def pack_parameters(O):
    O.x = flex.double()
    O.l = flex.double()
    O.u = flex.double()
    O.nbd = flex.int()
    sstab = O.xray_structure.site_symmetry_table()
    for i_sc,sc in enumerate(O.xray_structure.scatterers()):
      assert sc.flags.use_u_iso()
      assert not sc.flags.use_u_aniso()
      #
      site_symmetry = sstab.get(i_sc)
      if (site_symmetry.is_point_group_1()):
        p = sc.site
      else:
        p = site_symmetry.site_constraints().independent_params(
          all_params=sc.site)
      O.x.extend(flex.double(p))
      O.l.resize(O.x.size(), 0)
      O.u.resize(O.x.size(), 0)
      O.nbd.resize(O.x.size(), 0)
      #
      O.x.append(sc.u_iso)
      O.l.append(0)
      O.u.append(0)
      O.nbd.append(1)
    O.x *= O.p_as_x

  def unpack_parameters(O):
    p = O.x / O.p_as_x
    ix = 0
    sstab = O.xray_structure.site_symmetry_table()
    for i_sc,sc in enumerate(O.xray_structure.scatterers()):
      site_symmetry = sstab.get(i_sc)
      if (site_symmetry.is_point_group_1()):
        sc.site = tuple(p[ix:ix+3])
        ix += 3
      else:
        constr = site_symmetry.site_constraints()
        np = constr.n_independent_params()
        sc.site = constr.all_params(independent_params=tuple(p[ix:ix+np]))
        ix += np
      sc.u_iso = p[ix]
      ix += 1
    assert ix == O.x.size()

  def adjust_stp(O, stp, csd,
        large_shift_site=0.1,
        large_shift_u_iso_factor=0.5,
        min_large_shift_u_iso=b_as_u(1)):
    print("adjust_stp", stp)
    assert csd.size() == O.x.size()
    max_stp = 100
    ix = 0
    uc = O.xray_structure.unit_cell()
    sstab = O.xray_structure.site_symmetry_table()
    for i_sc,sc in enumerate(O.xray_structure.scatterers()):
      site_symmetry = sstab.get(i_sc)
      if (site_symmetry.is_point_group_1()):
        np = 3
        for i,ucp in enumerate(uc.parameters()[:3]):
          lsx = large_shift_site / ucp \
              * O.p_as_x[ix+i]
          if (abs(stp*csd[ix+i]) > lsx):
            max_stp = min(max_stp, abs(lsx/csd[ix]))
      else:
        constr = site_symmetry.site_constraints()
        np = constr.n_independent_params()
        raise RuntimeError("SPECIAL POSITION LARGE SHIFT NOT IMPLEMENTED.")
      ix += np
      u_iso = O.x[ix]/O.p_as_x[ix]
      lux = max(min_large_shift_u_iso, abs(u_iso) * large_shift_u_iso_factor) \
          * O.p_as_x[ix]
      if (abs(stp*csd[ix]) > lux):
        max_stp = min(max_stp, abs(lux/csd[ix]))
      ix += 1
    assert ix == O.x.size()
    print("max_stp:", max_stp)
    sys.stdout.flush()
    if (O.params.use_max_stp):
      return min(max_stp, stp)
    return stp

  def compute_functional_and_gradients(O):
    O.number_of_function_evaluations += 1
    O.unpack_parameters()
    try:
      f_calc = O.f_obs.structure_factors_from_scatterers(
        xray_structure=O.xray_structure,
        algorithm="direct",
        cos_sin_table=False).f_calc()
    except RuntimeError as e:
      print("RuntimeError f_calc:", e)
      sys.stdout.flush()
      raise RuntimeError("f_calc")
    ls = xray.targets_least_squares(
      compute_scale_using_all_data=False,
      obs_type="F",
      obs=O.f_obs.data(),
      weights=O.weights,
      r_free_flags=None,
      f_calc=f_calc.data(),
      derivatives_depth=2,
      scale_factor=1)
    gact = O.xray_structure.grads_and_curvs_target_simple(
      miller_indices=O.f_obs.indices(),
      da_db=ls.gradients_work(),
      daa_dbb_dab=ls.hessians_work())
    g_all = gact.grads
    g_active = flex.double()
    i_all = 0
    sstab = O.xray_structure.site_symmetry_table()
    for i_sc,sc in enumerate(O.xray_structure.scatterers()):
      assert sc.flags.use_u_iso()
      assert not sc.flags.use_u_aniso()
      site_symmetry = sstab.get(i_sc)
      if (site_symmetry.is_point_group_1()):
        np = 3
      else:
        np = site_symmetry.site_constraints().n_independent_params()
      g_active.extend(g_all[i_all:i_all+np+1])
      np += 4 # u_iso, occ, fp, fdp
      i_all += np
    assert i_all == g_all.size()
    assert g_active.size() == O.x.size()
    O.f_last = ls.target_work()
    O.g_last = g_active / O.p_as_x
    return O.f_last, O.g_last

  def callback_after_step(O, minimizer, suffix=""):
    O.number_of_lbfgs_iterations += 1
    O.callback_after_step_no_counting(suffix=suffix)

  def callback_after_step_no_counting(O, suffix=""):
    if (O.number_of_lbfgs_iterations % 10 == 0):
      s = "step  fun    f        |g|"
      if (O.reference_structure is not None):
        s += "     cRMSD aRMSD uRMSD"
      print(s)
    s = "%4d %4d %9.2e %9.2e" % (
      O.number_of_lbfgs_iterations,
      O.number_of_function_evaluations,
      O.f_last, O.g_last.norm())
    s += O.format_rms_info()
    print(s+suffix)
    O.history.append(refinement_stats(
      iter=O.number_of_lbfgs_iterations,
      nfun=O.number_of_function_evaluations,
      f=O.f_last,
      gnorm=O.g_last.norm(),
      crmsd=O.crmsd,
      armsd=O.armsd,
      urmsd=O.urmsd))
    sys.stdout.flush()

  def get_rms_info(O):
    if (O.reference_structure is None):
      return None
    xs = O.xray_structure
    rs = O.reference_structure
    xf = xs.sites_frac()
    rf = rs.sites_frac()
    # TODO: use scattering power as weights, move to method of xray.structure
    ave_csh = matrix.col((xf-rf).mean())
    ave_csh_perp = matrix.col(xs.space_group_info()
      .subtract_continuous_allowed_origin_shifts(translation_frac=ave_csh))
    caosh_corr = ave_csh - ave_csh_perp
    omx = xs.unit_cell().orthogonalization_matrix()
    O.crmsd = (omx * (rf - xf)).rms_length()
    O.armsd = (omx * (rf - xf + caosh_corr)).rms_length()
    O.urmsd = flex.mean_sq(
        xs.scatterers().extract_u_iso()
      - rs.scatterers().extract_u_iso())**0.5
    return (O.crmsd, O.armsd, O.urmsd)

  def format_rms_info(O):
    s = ""
    info = O.get_rms_info()
    if (info is not None):
      for r in info:
        s += " %5.3f" % r
    return s

  def show_rms_info(O):
    s = O.format_rms_info()
    if (len(s) != 0):
       print(" cRMSD aRMSD uRMSD")
       print(s)
       sys.stdout.flush()

  def run_lbfgs_raw(O):
    lbfgs_impl = [
      scitbx.lbfgs.raw_reference,
      scitbx.lbfgs.raw][O.params.lbfgs_impl_switch]
    diagco = O.params.diagco
    assert diagco in [0,1,2]
    n = O.x.size()
    m = 5
    iprint = O.params.iprint
    eps = 1.0e-5
    xtol = 1.0e-16
    size_w = n*(2*m+1)+2*m
    w = flex.double(size_w)
    diag = None
    diag0 = None
    iflag = 0
    while True:
      if (iflag in [0,1]):
        f, g = O.compute_functional_and_gradients()
        if (iflag == 0):
          if (diagco == 0):
            diag = flex.double(n, -1e20)
          else:
            assert O.curvs_work.size() == O.x.size()
            assert O.curvs_work.all_gt(0)
            if (O.params.curvature_rescaling):
              diag0 = flex.double(n, 1)
            else:
              diag0 = 1 / O.curvs_work
            diag = diag0.deep_copy()
      elif (iflag == 2):
        diag.clear()
        diag.extend(diag0)
      elif (iflag == 100):
        new_stp = O.adjust_stp(
          stp=lbfgs_impl.stp(),
          csd=lbfgs_impl.current_search_direction())
        lbfgs_impl.set_stp(value=new_stp)
      else:
        raise RuntimeError("invalid iflag value: %d" % iflag)
      if (iflag in [0,1]):
        O.show_rms_info()
      iflag = lbfgs_impl(
        n=n, m=m, x=O.x, f=f, g=g, diagco=diagco, diag=diag,
        iprint=iprint, eps=eps, xtol=xtol, w=w, iflag=iflag)
      if (iflag <= 0): break
    if (O.params.lbfgs_impl_switch == 1):
      print("iter, nfun:", lbfgs_impl.iter(), lbfgs_impl.nfun())
      assert O.number_of_function_evaluations == lbfgs_impl.nfun()
      O.number_of_lbfgs_iterations = lbfgs_impl.iter()
    O.callback_after_step_no_counting(suffix=" FINAL")

  def run_lbfgsb(O, iprint=1):
    n = O.x.size()
    minimizer = scitbx.lbfgsb.minimizer(
      n=n,
      m=5,
      l=O.l,
      u=O.u,
      nbd=O.nbd,
      enable_stp_init=True,
      factr=1.0e+7,
      pgtol=1.0e-5,
      iprint=iprint)
    f, g = -1e20, flex.double(n, -1e20)
    while True:
      if (minimizer.process(O.x, f, g)):
        f, g = O.compute_functional_and_gradients()
      elif (minimizer.requests_stp_init()):
        new_stp = O.adjust_stp(
          stp=minimizer.relative_step_length_line_search(),
          csd=minimizer.current_search_direction())
        minimizer.set_relative_step_length_line_search(value=new_stp)
      elif (minimizer.is_terminated()):
        O.callback_after_step_no_counting(suffix=" FINAL")
        break
      else:
        O.callback_after_step(minimizer=None)

def run_refinement(structure_ideal, structure_shake, params, run_id):
  print("Ideal structure:")
  structure_ideal.show_summary().show_scatterers()
  print()
  print("Modified structure:")
  structure_shake.show_summary().show_scatterers()
  print()
  print("rms difference:", \
    structure_ideal.rms_difference(other=structure_shake))
  print()
  print("structure_shake inter-atomic distances:")
  structure_shake.show_distances(distance_cutoff=4)
  print()
  f_obs = abs(structure_ideal.structure_factors(
    anomalous_flag=False,
    d_min=1,
    algorithm="direct",
    cos_sin_table=False).f_calc())
  try:
    return ls_refinement(
      f_obs=f_obs,
      xray_structure=structure_shake,
      params=params,
      reference_structure=structure_ideal)
  except RuntimeError as e:
    print("RuntimeError run_id:", run_id)
    sys.stdout.flush()
    if (str(e) != "f_calc"):
      raise

def run_call_back(flags, space_group_info, params):
  structure_shake = random_structure.xray_structure(
    space_group_info,
    elements=("N", "C", "O", "S", "Yb"),
    volume_per_atom=200,
    min_distance=2.0,
    general_positions_only=params.general_positions_only,
    random_u_iso=True)
  structure_ideal = structure_shake.deep_copy_scatterers()
  structure_shake.shake_sites_in_place(rms_difference=params.shake_sites_rmsd)
  structure_shake.shake_adp(spread=params.shake_adp_spread)
  #
  run_id = ""
  if (params.pickle_root_name is not None):
    run_id += params.pickle_root_name + "_"
  run_id += str(space_group_info).replace(" ","").replace("/","_").lower()
  if (params.pickle_root_name is not None):
    pickle_file_name = run_id + "_ideal_shake.pickle"
    print("writing file:", pickle_file_name)
    easy_pickle.dump(
      file_name=pickle_file_name,
      obj=(structure_ideal, structure_shake))
    print()
    sys.stdout.flush()
  #
  ls_result = run_refinement(
    structure_ideal=structure_ideal,
    structure_shake=structure_shake,
    params=params,
    run_id=run_id)
  if (ls_result is not None and params.pickle_root_name is not None):
    pickle_file_name = run_id + "_ls_history.pickle"
    print("writing file:", pickle_file_name)
    easy_pickle.dump(
      file_name=pickle_file_name,
      obj=ls_result.history)
    print()
    sys.stdout.flush()

def run(args):
  master_phil = libtbx.phil.parse("""
    general_positions_only = True
      .type = bool
    curvature_rescaling = True
      .type = bool
    minimizer = *lbfgs lbfgs_raw lbfgsb
      .type = choice
      .optional = False
    diagco = 0
      .type = int
    lbfgs_impl_switch = 1
      .type = int
    iprint = 1, 0
      .type = ints(size=2)
    curv_filter_lim_eps = 1e-3
      .type = float
    use_max_stp = True
      .type = bool
    shake_sites_rmsd = 0.5
      .type = float
    shake_adp_spread = 20
      .type = float
    pickle_root_name = None
      .type = str
    unpickle = None
      .type = path
""")
  argument_interpreter = master_phil.command_line_argument_interpreter()
  phil_objects = []
  remaining_args = []
  for arg in args:
    if (arg.find("=") >= 0):
      phil_objects.append(argument_interpreter.process(arg=arg))
    else:
      remaining_args.append(arg)
  work_phil = master_phil.fetch(sources=phil_objects)
  work_phil.show()
  print()
  params = work_phil.extract()
  if (params.unpickle is None):
    debug_utils.parse_options_loop_space_groups(
      argv=remaining_args, call_back=run_call_back, params=params)
  else:
    structure_ideal, structure_shake = easy_pickle.load(
      file_name=params.unpickle)
    run_refinement(
      structure_ideal=structure_ideal,
      structure_shake=structure_shake,
      params=params,
      run_id=params.unpickle)

if (__name__ == "__main__"):
  from cctbx.regression.tst_refine_xray_curvs import run # for pickle
  run(args=sys.argv[1:])


 *******************************************************************************


 *******************************************************************************
cctbx/regression/tst_reflection_statistics.py
from __future__ import absolute_import, division, print_function
from cctbx import miller
from cctbx import crystal
from cctbx import sgtbx
import cctbx.sgtbx.lattice_symmetry
import cctbx.sgtbx.bravais_types
import cctbx.sgtbx.subgroups
import cctbx.sgtbx.cosets
from cctbx.array_family import flex
from libtbx.test_utils import approx_equal
import random
import sys
from six.moves import range

if (1): # fixed random seed to avoid rare failures
  random.seed(0)
  flex.set_random_seed(0)

def exercise(space_group_info, anomalous_flag, verbose):
  crystal_symmetry_ri = crystal.symmetry(
    unit_cell=space_group_info.any_compatible_unit_cell(volume=1000),
    space_group_info=space_group_info) \
      .minimum_cell() \
      .reflection_intensity_symmetry(anomalous_flag=anomalous_flag)
  #
  crystal_symmetry_p1 = crystal_symmetry_ri.cell_equivalent_p1()
  miller_set = miller.build_set(
    crystal_symmetry=crystal_symmetry_p1,
    anomalous_flag=anomalous_flag,
    d_min=1)
  miller_array_p1 = miller.array(
    miller_set=miller_set,
    data=flex.random_double(size=miller_set.indices().size()))
  assert miller_array_p1.map_to_asu().indices() \
         .all_eq(miller_array_p1.indices())
  #
  lattice_group = sgtbx.lattice_symmetry.group(
    crystal_symmetry_ri.unit_cell(),
    max_delta=0.1)
  miller_array_subs = []
  miller_array_sub_as = []
  miller_array_sub_bs = []
  coset_decompositions = []
  subgroups = sgtbx.subgroups.anomalous_reflection_intensity_primitive_cell(
    space_group=lattice_group)
  for subgroup in subgroups:
    subgroup_info = sgtbx.space_group_info(group=subgroup)
    miller_array_sub = miller_array_p1.customized_copy(
      space_group_info=subgroup_info) \
        .merge_equivalents().array()
    miller_array_sub_a = miller_array_sub.customized_copy(
      data=flex.random_double(size=miller_array_sub.indices().size())) \
        .expand_to_p1() \
        .map_to_asu()
    miller_array_sub_b = miller_array_sub.customized_copy(
      data=flex.random_double(size=miller_array_sub.indices().size())) \
        .expand_to_p1() \
        .map_to_asu()
    miller_array_subs.append(miller_array_sub)
    miller_array_sub_as.append(miller_array_sub_a)
    miller_array_sub_bs.append(miller_array_sub_b)
    #
    for s in subgroup_info.group():
      cb_op = sgtbx.change_of_basis_op(s)
      cb = miller_array_sub_a.change_basis(cb_op).map_to_asu()
      assert approx_equal(
        miller_array_sub_a.correlation(other=cb).coefficient(), 1)
    #
    coset_decomposition = sgtbx.cosets.left_decomposition_point_groups_only(
      g=lattice_group,
      h=subgroup_info.group())
    coset_decompositions.append(coset_decomposition)
    #
    for partition in coset_decomposition.partitions:
      s = partition[0]
      expected_match = s.is_unit_mx()
      cb_op = sgtbx.change_of_basis_op(s)
      cb = miller_array_sub_a.change_basis(cb_op).map_to_asu()
      is_match = abs(
        miller_array_sub_a.correlation(other=cb).coefficient() - 1) < 1.e-6
      assert is_match == expected_match
      for s in partition[1:]:
        cb_op = sgtbx.change_of_basis_op(s)
        cb = miller_array_sub_a.change_basis(cb_op).map_to_asu()
        assert approx_equal(cb.correlation(other=cb).coefficient(), 1)
    #
    blur_scale = 3
    blurred_data = miller_array_sub_a.data() * blur_scale
    # set to False to compare data with itself (will lead to failures below)
    if (True):
      blurred_data += flex.random_double(size=blurred_data.size())
    blurred_data /= blur_scale
    blurred_array = miller_array_sub_a.customized_copy(
      data=blurred_data)
    expected_correlation = "%.6f" % miller_array_sub_a.correlation(
      other=blurred_array).coefficient()
    if (verbose):
      print("blurred_array expected_correlation:", expected_correlation)
    blurred_array_cb = blurred_array.change_basis(
        random.choice(list(subgroup_info.group())).as_xyz()).map_to_asu()
    self_ccs = {}
    for partition in coset_decomposition.partitions:
      cb_op = sgtbx.change_of_basis_op(partition[0])
      cb = miller_array_sub_a.change_basis(cb_op).map_to_asu()
      cc = blurred_array_cb.correlation(other=cb).coefficient()
      key = "%.6f" % cc
      self_ccs.setdefault(key, []).append(str(partition[0]))
    assert expected_correlation in self_ccs
    repetitions = [len(v) for v in self_ccs.values()]
    failure = (max(repetitions) > 1)
    if (failure or verbose):
      print(subgroup_info)
      print("self_ccs ops:", list(self_ccs.values()))
    if (failure):
      for cc,ops in self_ccs.items():
        if (len(ops) > 1):
          print(cc, ops)
          for op in ops:
            ri = sgtbx.rt_mx(op).r().info()
            print("   ", ri.type(), ri.sense(), ri.ev())
      raise RuntimeError("max(repetitions) > 1")
  #
  for i in range(len(coset_decompositions)):
    for j in range(len(coset_decompositions)):
      exercise_double_coset_decomposition(
        crystal_symmetry_ri,
        lattice_group,
        miller_array_subs,
        miller_array_sub_as,
        miller_array_sub_bs,
        coset_decompositions,
        i, j,
        verbose)

def exercise_double_coset_decomposition(
      crystal_symmetry_ri,
      lattice_group,
      miller_array_subs,
      miller_array_sub_as,
      miller_array_sub_bs,
      coset_decompositions,
      i, j,
      verbose):
  group_a = miller_array_subs[i].space_group_info().group()
  group_b = miller_array_subs[j].space_group_info().group()
  miller_array_sub_a = miller_array_sub_as[i]
  miller_array_sub_b = miller_array_sub_bs[j]
  single_coset_ccs = {}
  for partition in coset_decompositions[i].partitions:
    cb_op = sgtbx.change_of_basis_op(partition[0])
    cb = miller_array_sub_a.change_basis(cb_op).map_to_asu()
    cc = cb.correlation(other=miller_array_sub_b).coefficient()
    key = "%.6f" % cc
    single_coset_ccs.setdefault(key, []).append(str(partition[0]))
  double_coset_ccs = {}
  for c in sgtbx.cosets.double_unique(lattice_group, group_a, group_b):
    cb_op = sgtbx.change_of_basis_op(c)
    cb = miller_array_sub_b.change_basis(cb_op).map_to_asu()
    cc = cb.correlation(other=miller_array_sub_a).coefficient()
    key = "%.6f" % cc
    double_coset_ccs.setdefault(key, []).append(str(c))
  double_coset_repetitions = [len(v) for v in double_coset_ccs.values()]
  failure = (max(double_coset_repetitions) > 1)
  if (failure or verbose):
    print([str(sgtbx.space_group_info(group=g)) for g in (group_a, group_b)])
    print("single_coset ops:", list(single_coset_ccs.values()))
    print("double_coset ops:", list(double_coset_ccs.values()))
  if (failure):
    for cc,ops in double_coset_ccs.items():
      if (len(ops) > 1):
        print(cc, ops)
        for op in ops:
          ri = sgtbx.rt_mx(op).r().info()
          print("   ", ri.type(), ri.sense(), ri.ev())
    raise RuntimeError("max(double_coset_repetitions) > 1")
  single_coset_ccs = list(single_coset_ccs.keys())
  double_coset_ccs = list(double_coset_ccs.keys())
  single_coset_ccs.sort()
  double_coset_ccs.sort()
  failure = (double_coset_ccs != single_coset_ccs)
  if (failure or verbose):
    print("single_coset_ccs:", single_coset_ccs)
    print("double_coset_ccs:", double_coset_ccs)
  if (failure):
    raise RuntimeError("double_coset_ccs != single_coset_ccs")

def run():
  verbose = "--verbose" in sys.argv[1:]
  quick = "--quick" in sys.argv[1:]
  harder = "--harder" in sys.argv[1:]
  hardest = "--hardest" in sys.argv[1:]
  for symbol in sgtbx.bravais_types.acentric:
    if (quick):
      if (symbol != "P 1 2 1"): continue
    elif (harder):
      if (symbol != "F 4 3 2"): continue
    elif (not hardest):
      if (symbol != "P 4 2 2"): continue
    space_group_info = sgtbx.space_group_info(symbol=symbol)
    for anomalous_flag in [False, True]:
      if (verbose):
        print(symbol, "anomalous_flag =", anomalous_flag)
      run_away_counter = 0
      while True:
        try:
          exercise(
            space_group_info=space_group_info,
            anomalous_flag=anomalous_flag,
            verbose=verbose)
        except RuntimeError as e:
          if (str(e) != "max(double_coset_repetitions) > 1"): raise
          print(e, "(ignored since it may happen by chance)")
          run_away_counter += 1
          assert run_away_counter < 10
        else:
          break
  print("OK")

if (__name__ == "__main__"):
  run()


 *******************************************************************************


 *******************************************************************************
cctbx/regression/tst_sampled_model_density.py
from __future__ import absolute_import, division, print_function
from cctbx import xray
from cctbx import maptbx
from cctbx import crystal
from cctbx import adptbx
import cctbx.eltbx.xray_scattering
from cctbx import eltbx
from cctbx.development import random_structure
from cctbx.development import structure_factor_utils
from cctbx.development import debug_utils
from cctbx.array_family import flex
from scitbx import fftpack
import omptbx
from libtbx.test_utils import approx_equal
import libtbx.utils
import libtbx.introspection
import random
import sys
from six.moves import range

if (1):
  random.seed(0)
  flex.set_random_seed(0)

def assign_custom_gaussians(structure, negative_a=False):
  if (negative_a):
    f = -1
  else:
    f = 1
  custom_gaussians = {
    "N": eltbx.xray_scattering.gaussian(
      (f*11.893779754638672, f*3.2774789333343506),
      (0.00015799999528098851, 10.232723236083984), 0),
    "C": eltbx.xray_scattering.gaussian(
      (f*2.657505989074707, f*1.0780789852142334, f*1.4909089803695679),
      (14.780757904052734, 0.77677500247955322, 42.086841583251953), 0),
  }
  reg = structure.scattering_type_registry(
    custom_dict=custom_gaussians,
    table="wk1995")
  assert reg.gaussian("N").n_terms() == 2
  assert reg.gaussian("N").c() == 0
  assert reg.gaussian("C").n_terms() == 3
  assert reg.gaussian("C").c() == 0
  assert reg.gaussian("O").n_terms() == 5
  assert reg.gaussian("O").c() != 0
  reg = structure.scattering_type_registry()
  assert reg.gaussian("N").n_terms() == 2

def exercise(space_group_info, const_gaussian, negative_gaussian,
             anomalous_flag,
             allow_mix,
             use_u_iso,
             use_u_aniso,
             d_min=1., resolution_factor=1./3, max_prime=5,
             quality_factor=100, wing_cutoff=1.e-6,
             exp_table_one_over_step_size=-100,
             force_complex=False,
             verbose=0):
  if (const_gaussian):
    elements=["const"]*8
  elif (negative_gaussian):
    elements=["H"]*8
  else:
    elements=["N", "C", "C", "O", "N", "C", "C", "O"]
  if (random.random() < 0.5):
    random_f_prime_scale=0.6
  else:
    random_f_prime_scale=0
  structure = random_structure.xray_structure(
    space_group_info,
    elements=elements,
    random_f_prime_d_min=1,
    random_f_prime_scale=random_f_prime_scale,
    random_f_double_prime=anomalous_flag,
    use_u_aniso= True,
    use_u_iso= False,
    random_u_cart_scale=0.3,
    random_u_iso=True,
    random_occupancy=True)
  random_structure.random_modify_adp_and_adp_flags_2(
                                 scatterers         = structure.scatterers(),
                                 use_u_iso          = use_u_iso,
                                 use_u_aniso        = use_u_aniso,
                                 allow_mix          = allow_mix,
                                 random_u_iso_scale = 0.3,
                                 random_u_iso_min   = 0.0)
  sampled_density_must_be_positive = True
  if (negative_gaussian):
    reg = structure.scattering_type_registry(
      custom_dict={"H": eltbx.xray_scattering.gaussian(-1)})
    assert reg.gaussian("H").n_terms() == 0
    assert reg.gaussian("H").c() == -1
    sampled_density_must_be_positive = False
  elif (not const_gaussian and random.random() < 0.5):
    if (random.random() < 0.5):
      sampled_density_must_be_positive = False
    assign_custom_gaussians(
      structure,
      negative_a=not sampled_density_must_be_positive)
  f_direct = structure.structure_factors(
    anomalous_flag=anomalous_flag,
    d_min=d_min,
    algorithm="direct").f_calc()
  crystal_gridding = f_direct.crystal_gridding(
    resolution_factor=resolution_factor,
    d_min=d_min,
    max_prime=max_prime)
  assert crystal_gridding.symmetry_flags() is None
  rfft = fftpack.real_to_complex_3d(crystal_gridding.n_real())
  u_base = xray.calc_u_base(d_min, resolution_factor, quality_factor)
  omptbx.env.num_threads = libtbx.introspection.number_of_processors()
  sampled_density = xray.sampled_model_density(
    unit_cell=structure.unit_cell(),
    scatterers=structure.scatterers(),
    scattering_type_registry=structure.scattering_type_registry(),
    fft_n_real=rfft.n_real(),
    fft_m_real=rfft.m_real(),
    u_base=u_base,
    wing_cutoff=wing_cutoff,
    exp_table_one_over_step_size=exp_table_one_over_step_size,
    force_complex=force_complex,
    sampled_density_must_be_positive=sampled_density_must_be_positive,
    tolerance_positive_definite=1.e-5,
    use_u_base_as_u_extra=False)
  focus = sampled_density.real_map_unpadded().focus()
  all   = sampled_density.real_map_unpadded().all()
  last  = sampled_density.real_map_unpadded().last()
  assert approx_equal(focus, last)
  assert approx_equal(all, last)
  assert sampled_density.anomalous_flag() == (anomalous_flag or force_complex)
  if (0 or verbose):
    print("const_gaussian:", const_gaussian)
    print("negative_gaussian:", negative_gaussian)
    print("number of scatterers passed:", \
      sampled_density.n_scatterers_passed())
    print("number of contributing scatterers:", \
      sampled_density.n_contributing_scatterers())
    print("number of anomalous scatterers:", \
      sampled_density.n_anomalous_scatterers())
    print("wing_cutoff:", sampled_density.wing_cutoff())
    print("exp_table_one_over_step_size:", \
      sampled_density.exp_table_one_over_step_size())
    print("exp_table_size:", sampled_density.exp_table_size())
    print("max_sampling_box_edges:", sampled_density.max_sampling_box_edges(), end=' ')
    print("(%.4f, %.4f, %.4f)" % sampled_density.max_sampling_box_edges_frac())
    if (not sampled_density.anomalous_flag()):
      print("map min:", flex.min(sampled_density.real_map()))
      print("map max:", flex.max(sampled_density.real_map()))
    else:
      print("map min:", flex.min(flex.real(sampled_density.complex_map())), end=' ')
      print(flex.min(flex.imag(sampled_density.complex_map())))
      print("map max:", flex.max(flex.real(sampled_density.complex_map())), end=' ')
      print(flex.max(flex.imag(sampled_density.complex_map())))
  if (not sampled_density.anomalous_flag() and negative_gaussian):
    assert flex.min(sampled_density.real_map()) < 0
    assert flex.max(sampled_density.real_map()) == 0
  if (not sampled_density.anomalous_flag()):
    map = sampled_density.real_map()
    assert map.all() == rfft.m_real()
    assert map.focus() == rfft.n_real()
    sf_map = rfft.forward(map)
    assert sf_map.all() == rfft.n_complex()
    assert sf_map.focus() == rfft.n_complex()
    collect_conj = True
  else:
    cfft = fftpack.complex_to_complex_3d(rfft.n_real())
    map = sampled_density.complex_map()
    assert map.all() == cfft.n()
    assert map.focus() == cfft.n()
    sf_map = cfft.backward(map)
    assert sf_map.all() == cfft.n()
    assert sf_map.focus() == cfft.n()
    collect_conj = False
  f_fft_data = maptbx.structure_factors.from_map(
    space_group=f_direct.space_group(),
    anomalous_flag=sampled_density.anomalous_flag(),
    miller_indices=f_direct.indices(),
    complex_map=sf_map,
    conjugate_flag=collect_conj).data()
  sampled_density.eliminate_u_extra_and_normalize(
    f_direct.indices(),
    f_fft_data)
  structure_factor_utils.check_correlation(
    "direct/fft_regression", f_direct.indices(), 0,
    f_direct.data(), f_fft_data,
    min_corr_ampl=1*0.99, max_mean_w_phase_error=1*3.,
    verbose=verbose)
  f_fft = xray.structure_factors.from_scatterers(
    miller_set=f_direct,
    grid_resolution_factor=resolution_factor,
    quality_factor=quality_factor,
    wing_cutoff=wing_cutoff,
    exp_table_one_over_step_size=exp_table_one_over_step_size,
    sampled_density_must_be_positive=sampled_density_must_be_positive,
    max_prime=max_prime)(
      xray_structure=structure,
      miller_set=f_direct,
      algorithm="fft").f_calc()
  structure_factor_utils.check_correlation(
    "direct/fft_xray", f_direct.indices(), 0,
    f_direct.data(), f_fft.data(),
    min_corr_ampl=1*0.99, max_mean_w_phase_error=1*3.,
    verbose=verbose)

def exercise_negative_parameters(verbose=0):
  structure_default = xray.structure(
    crystal_symmetry = crystal.symmetry(
      unit_cell=((10,13,17,75,80,85)),
      space_group_symbol="P 1"),
    scatterers=flex.xray_scatterer([
      xray.scatterer(label="C", site=(0,0,0), u=0.25)]))
  negative_gaussian = eltbx.xray_scattering.gaussian((1,2), (2,3), -4)
  for i_trial in range(7):
    structure = structure_default.deep_copy_scatterers()
    scatterer = structure.scatterers()[0]
    if (i_trial == 1):
      scatterer.occupancy *= -1
    elif (i_trial == 2):
      structure.scattering_type_registry(custom_dict={"C": negative_gaussian})
    elif (i_trial == 3):
      scatterer.u_iso *= -1
    elif (i_trial == 4):
      u_cart = adptbx.random_u_cart(u_scale=1, u_min=-1.1)
      assert max(adptbx.eigenvalues(u_cart)) < 0
      u_star = adptbx.u_cart_as_u_star(structure.unit_cell(), u_cart)
      scatterer.u_star = u_star
      scatterer.flags.set_use_u_aniso_only()
    elif (i_trial == 5):
      scatterer.fp = -10
    elif (i_trial == 6):
      scatterer.fp = -3
    f_direct = structure.structure_factors(
      d_min=1, algorithm="direct", cos_sin_table=False).f_calc()
    f_fft = structure.structure_factors(
      d_min=1, algorithm="fft",
      quality_factor=1.e8, wing_cutoff=1.e-10).f_calc()
    if (i_trial == 2):
      assert negative_gaussian.at_d_star_sq(f_fft.d_star_sq().data()).all_lt(0)
    if (i_trial in [5,6]):
      f = structure.scattering_type_registry().gaussian_not_optional(
        scattering_type="C").at_d_star_sq(f_fft.d_star_sq().data())
      if (i_trial == 5):
        assert flex.max(f) + scatterer.fp < 0
      else:
        assert flex.max(f) + scatterer.fp > 0
        assert flex.min(f) + scatterer.fp < 0
    cc = flex.linear_correlation(
      abs(f_direct).data(),
      abs(f_fft).data()).coefficient()
    if (cc < 0.999):
      raise AssertionError("i_trial=%d, correlation=%.6g" % (i_trial, cc))
    elif (0 or verbose):
      print("correlation=%.6g" % cc)
    #
    # very simple test of gradient calculations with negative parameters
    structure_factor_gradients = \
      cctbx.xray.structure_factors.gradients(
        miller_set=f_direct,
        cos_sin_table=False)
    target_functor = xray.target_functors.intensity_correlation(
      f_obs=abs(f_direct))
    target_result = target_functor(f_fft, True)
    xray.set_scatterer_grad_flags(scatterers = structure.scatterers(),
                                  site       = True,
                                  u_iso      = True,
                                  u_aniso    = True,
                                  occupancy  = True,
                                  fp         = True,
                                  fdp        = True)
    for algorithm in ["direct", "fft"]:
      grads = structure_factor_gradients(
        xray_structure=structure,
        u_iso_refinable_params=None,
        miller_set=f_direct,
        d_target_d_f_calc=target_result.derivatives(),
        n_parameters = structure.n_parameters(),
        algorithm=algorithm).packed()

def run_call_back(flags, space_group_info):
  for anomalous_flag in (False, True)[:]: #SWITCH
    for (use_u_iso,use_u_aniso) in [(True,True),
                                    (False,True),
                                    (True,False),
                                    (False,False)]:
      for allow_mix in [False, True]:
        r = random.random()
        exercise(
          space_group_info,
          const_gaussian=r<1/3.,
          negative_gaussian=r>2/3.,
          anomalous_flag=anomalous_flag,
          use_u_iso = use_u_iso,
          use_u_aniso = use_u_aniso,
          verbose=flags.Verbose,
          allow_mix=allow_mix)

def run():
  show_times = libtbx.utils.show_times()
  debug_utils.parse_options_loop_space_groups(
    argv=sys.argv[1:],
    call_back=run_call_back,
    show_cpu_times=False)
  exercise_negative_parameters()
  show_times()

if (__name__ == "__main__"):
  run()


 *******************************************************************************


 *******************************************************************************
cctbx/regression/tst_sf_low_res_accuracy.py
from __future__ import absolute_import, division, print_function
import iotbx.pdb
from scitbx.array_family import flex
import time

pdb_str="""
CRYST1  454.007  426.033  459.047  90.00  90.00  90.00 P 1
SCALE1      0.002203  0.000000  0.000000        0.00000
SCALE2      0.000000  0.002347  0.000000        0.00000
SCALE3      0.000000  0.000000  0.002178        0.00000
ATOM      1  CA  VAL A1358     148.938 119.717 100.000  1.00 33.88           C
ATOM      2  CA  PRO A1359     149.108 116.282 101.953  1.00 31.91           C
ATOM      3  CA  PRO A1360     146.078 114.542 103.797  1.00 26.33           C
ATOM      4  CA  PRO A1361     145.621 112.862 107.337  1.00 18.42           C
ATOM      5  CA  THR A1362     145.081 109.243 108.683  1.00 21.37           C
ATOM      6  CA  ASP A1363     143.651 106.972 111.575  1.00 20.53           C
ATOM      7  CA  LEU A1364     140.301 108.604 112.732  1.00 13.10           C
ATOM      8  CA  ARG A1365     138.856 107.558 116.217  1.00 13.90           C
ATOM      9  CA  PHE A1366     136.295 108.604 118.951  1.00 12.59           C
ATOM     10  CA  THR A1367     136.338 108.844 122.851  1.00 18.27           C
ATOM     11  CA  ASN A1368     134.748 110.767 125.861  1.00 35.66           C
ATOM     12  CA  ILE A1369     131.093 110.630 124.665  1.00 20.50           C
ATOM     13  CA  GLY A1370     128.787 112.946 126.681  1.00 31.22           C
ATOM     14  CA  PRO A1371     125.231 114.133 125.725  1.00 30.22           C
ATOM     15  CA  ASP A1372     126.459 117.360 124.041  1.00 23.75           C
ATOM     16  CA  THR A1373     130.112 116.268 123.662  1.00 17.75           C
ATOM     17  CA  MET A1374     132.554 113.816 121.995  1.00 13.70           C
ATOM     18  CA  ARG A1375     136.395 113.642 121.605  1.00 12.83           C
ATOM     19  CA  VAL A1376     137.530 112.924 118.003  1.00 11.64           C
ATOM     20  CA  THR A1377     141.175 111.755 117.305  1.00 13.55           C
ATOM     21  CA  TRP A1378     143.436 111.275 114.163  1.00 10.25           C
ATOM     22  CA  ALA A1379     147.077 110.870 112.883  1.00 20.66           C
ATOM     23  CA  PRO A1380     148.832 113.776 110.968  1.00 25.69           C
ATOM     24  CA  PRO A1381     150.776 113.842 107.607  1.00 34.10           C
ATOM     25  CA  ASP A1385     154.007 122.439 109.035  1.00 55.68           C
ATOM     26  CA  LEU A1386     150.309 122.713 108.083  1.00 39.19           C
ATOM     27  CA  THR A1387     148.167 125.829 108.846  1.00 33.58           C
ATOM     28  CA  ASN A1388     144.910 123.873 109.428  1.00 18.33           C
ATOM     29  CA  PHE A1389     142.989 120.679 110.062  1.00 13.50           C
ATOM     30  CA  LEU A1390     139.443 121.388 108.928  1.00 14.05           C
ATOM     31  CA  VAL A1391     137.092 119.270 111.076  1.00 11.67           C
ATOM     32  CA  ARG A1392     133.729 119.258 109.231  1.00 12.02           C
ATOM     33  CA  TYR A1393     130.897 117.502 111.152  1.00 10.39           C
ATOM     34  CA  SER A1394     127.111 117.090 110.574  1.00 16.06           C
ATOM     35  CA  PRO A1395     124.173 114.979 111.936  1.00 17.95           C
ATOM     36  CA  VAL A1396     123.808 111.698 109.904  1.00 24.54           C
ATOM     37  CA  LYS A1397     120.134 112.689 109.250  1.00 44.54           C
ATOM     38  CA  ASN A1398     121.139 116.103 107.784  1.00 43.24           C
ATOM     39  CA  GLU A1399     124.609 115.685 106.151  1.00 54.32           C
ATOM     40  CA  GLU A1400     124.190 119.276 104.701  1.00 42.39           C
ATOM     41  CA  VAL A1402     128.032 120.991 108.262  1.00 34.73           C
ATOM     42  CA  ALA A1403     129.573 122.671 111.271  1.00 31.08           C
ATOM     43  CA  GLU A1404     133.269 123.451 110.546  1.00 18.73           C
ATOM     44  CA  LEU A1405     136.125 123.710 113.086  1.00 23.21           C
ATOM     45  CA  SER A1406     139.558 125.155 112.173  1.00 19.59           C
ATOM     46  CA  ILE A1407     141.752 123.692 114.833  1.00 22.08           C
ATOM     47  CA  SER A1408     145.018 126.033 115.249  1.00 33.50           C
ATOM     48  CA  PRO A1409     148.634 124.336 115.685  1.00 35.29           C
ATOM     49  CA  SER A1410     148.476 120.979 118.025  1.00 37.93           C
ATOM     50  CA  ASP A1411     145.131 118.710 118.597  1.00 27.98           C
ATOM     51  CA  ASN A1412     145.573 115.280 117.118  1.00 21.72           C
ATOM     52  CA  ALA A1413     142.225 115.275 119.063  1.00 16.22           C
ATOM     53  CA  VAL A1414     139.281 117.816 119.201  1.00 15.68           C
ATOM     54  CA  VAL A1415     136.371 117.803 121.698  1.00 15.31           C
ATOM     55  CA  LEU A1416     133.225 118.528 119.662  1.00 16.01           C
ATOM     56  CA  THR A1417     130.718 120.452 121.897  1.00 20.05           C
ATOM     57  CA  ASN A1418     127.070 121.739 121.572  1.00 32.11           C
ATOM     58  CA  LEU A1419     125.988 118.404 119.986  1.00 15.97           C
ATOM     59  CA  LEU A1420     122.395 117.086 119.982  1.00 22.66           C
ATOM     60  CA  PRO A1421     121.812 114.423 122.733  1.00 20.32           C
ATOM     61  CA  GLY A1422     121.263 110.823 121.509  1.00 23.77           C
ATOM     62  CA  THR A1423     122.224 111.850 117.885  1.00 18.46           C
ATOM     63  CA  GLU A1424     124.604 110.218 115.318  1.00 14.18           C
ATOM     64  CA  TYR A1425     127.176 112.502 113.569  1.00 13.02           C
ATOM     65  CA  VAL A1426     129.513 112.297 110.551  1.00 12.30           C
ATOM     66  CA  VAL A1427     132.997 113.789 111.143  1.00 12.16           C
ATOM     67  CA  SER A1428     135.627 114.576 108.470  1.00 11.24           C
ATOM     68  CA  VAL A1429     139.197 116.027 108.576  1.00 11.54           C
ATOM     69  CA  SER A1430     141.130 117.805 105.734  1.00 13.82           C
ATOM     70  CA  SER A1431     144.703 119.108 106.173  1.00 18.85           C
ATOM     71  CA  VAL A1432     145.115 122.769 105.027  1.00 24.56           C
ATOM     72  CA  TYR A1433     148.261 124.777 104.098  1.00 45.81           C
ATOM     73  CA  HIS A1436     144.719 125.120 100.347  1.00 55.81           C
ATOM     74  CA  GLU A1437     142.703 122.002 101.363  1.00 29.48           C
ATOM     75  CA  SER A1438     143.992 118.417 101.042  1.00 22.89           C
ATOM     76  CA  THR A1439     141.620 115.400 100.644  1.00 28.41           C
ATOM     77  CA  PRO A1440     139.399 114.638 103.739  1.00 17.14           C
ATOM     78  CA  LEU A1441     139.506 111.600 106.101  1.00 14.44           C
ATOM     79  CA  ARG A1442     135.936 110.522 107.346  1.00 14.35           C
ATOM     80  CA  GLY A1443     134.058 108.636 110.191  1.00 15.43           C
ATOM     81  CA  ARG A1444     130.819 108.445 112.368  1.00 11.66           C
ATOM     82  CA  GLN A1445     129.772 108.415 116.114  1.00 11.50           C
ATOM     83  CA  LYS A1446     126.623 108.803 118.415  1.00 16.19           C
ATOM     84  CA  THR A1447     126.219 111.062 121.551  1.00 17.99           C
ATOM     85  CA  GLY A1448     124.870 110.091 125.040  1.00 29.95           C
ATOM     86  CA  LEU A1449     121.592 110.926 126.887  1.00 22.66           C
ATOM     87  CA  ASP A1450     121.190 114.131 128.936  1.00 29.34           C
ATOM     88  CA  SER A1451     119.589 114.286 132.415  1.00 22.82           C
ATOM     89  CA  PRO A1452     116.259 115.773 133.432  1.00 20.71           C
ATOM     90  CA  THR A1453     116.918 119.260 134.966  1.00 21.30           C
ATOM     91  CA  GLY A1454     115.025 121.690 137.311  1.00 40.30           C
ATOM     92  CA  ILE A1455     113.515 119.461 140.065  1.00 15.59           C
ATOM     93  CA  ASP A1456     110.666 121.305 141.864  1.00 20.21           C
ATOM     94  CA  PHE A1457     108.039 120.443 144.565  1.00 13.19           C
ATOM     95  CA  SER A1458     104.364 121.636 144.401  1.00 31.40           C
ATOM     96  CA  ASP A1459     100.972 120.385 145.865  1.00 30.41           C
ATOM     97  CA  ILE A1460     102.658 120.059 149.305  1.00 24.94           C
ATOM     98  CA  THR A1461     100.000 118.617 151.677  1.00 48.83           C
ATOM     99  CA  ASN A1463     100.070 113.301 152.758  1.00 22.51           C
ATOM    100  CA  SER A1464     101.256 114.201 149.190  1.00 18.68           C
ATOM    101  CA  PHE A1465     103.502 116.463 147.133  1.00 13.23           C
ATOM    102  CA  THR A1466     103.878 116.832 143.319  1.00 15.46           C
ATOM    103  CA  VAL A1467     107.394 116.566 141.859  1.00 13.69           C
ATOM    104  CA  HIS A1468     108.182 118.418 138.594  1.00 14.58           C
ATOM    105  CA  TRP A1469     111.247 118.176 136.299  1.00 10.82           C
ATOM    106  CA  ILE A1470     112.365 119.716 132.973  1.00 19.51           C
ATOM    107  CA  ALA A1471     112.613 117.148 130.133  1.00 23.06           C
ATOM    108  CA  PRO A1472     116.007 116.133 128.576  1.00 26.02           C
ATOM    109  CA  ARG A1473     116.707 117.205 124.930  1.00 24.80           C
ATOM    110  CA  ALA A1474     117.405 113.548 123.992  1.00 30.93           C
ATOM    111  CA  THR A1475     114.556 111.456 122.577  1.00 27.61           C
ATOM    112  CA  ILE A1476     113.479 109.292 125.565  1.00 20.47           C
ATOM    113  CA  THR A1477     111.104 106.367 126.245  1.00 20.70           C
ATOM    114  CA  GLY A1478     110.236 107.515 129.830  1.00 17.71           C
ATOM    115  CA  TYR A1479     111.339 108.336 133.412  1.00 11.13           C
ATOM    116  CA  ARG A1480     112.030 106.377 136.642  1.00 11.29           C
ATOM    117  CA  ILE A1481     111.354 108.176 139.957  1.00 11.59           C
ATOM    118  CA  ARG A1482     112.549 106.852 143.378  1.00 11.91           C
ATOM    119  CA  HIS A1483     111.280 108.193 146.740  1.00 12.39           C
ATOM    120  CA  HIS A1484     111.933 107.485 150.478  1.00 13.07           C
ATOM    121  CA  PRO A1485     111.962 109.317 153.882  1.00 16.85           C
ATOM    122  CA  GLU A1486     115.450 110.852 154.527  1.00 35.55           C
ATOM    123  CA  HIS A1487     116.161 108.541 157.533  1.00 37.44           C
ATOM    124  CA  PHE A1488     114.775 105.425 155.653  1.00 55.77           C
ATOM    125  CA  GLY A1490     114.925 100.391 153.173  1.00 51.28           C
ATOM    126  CA  ARG A1491     114.526 100.000 149.373  1.00 35.07           C
ATOM    127  CA  PRO A1492     113.029 103.299 147.995  1.00 34.67           C
ATOM    128  CA  ARG A1493     109.580 103.211 146.323  1.00 19.34           C
ATOM    129  CA  GLU A1494     110.097 103.197 142.505  1.00 17.33           C
ATOM    130  CA  ASP A1495     107.545 104.782 140.129  1.00 18.92           C
ATOM    131  CA  ARG A1496     107.622 104.735 136.272  1.00 14.77           C
ATOM    132  CA  VAL A1497     106.408 107.703 134.219  1.00 18.52           C
ATOM    133  CA  PRO A1498     105.929 107.937 130.379  1.00 22.40           C
ATOM    134  CA  HIS A1499     108.129 110.340 128.324  1.00 27.21           C
ATOM    135  CA  SER A1500     104.897 112.436 127.939  1.00 31.96           C
ATOM    136  CA  ARG A1501     104.944 113.394 131.694  1.00 25.65           C
ATOM    137  CA  ASN A1502     107.309 115.925 133.305  1.00 18.08           C
ATOM    138  CA  SER A1503     105.596 115.470 136.749  1.00 13.26           C
ATOM    139  CA  ILE A1504     104.291 113.003 139.407  1.00 11.86           C
ATOM    140  CA  THR A1505     102.098 113.449 142.526  1.00 12.54           C
ATOM    141  CA  LEU A1506     103.719 111.288 145.225  1.00 13.17           C
ATOM    142  CA  THR A1507     100.924 110.090 147.581  1.00 17.45           C
ATOM    143  CA  ASN A1508     100.502 108.068 150.815  1.00 21.22           C
ATOM    144  CA  LEU A1509     103.276 110.082 152.508  1.00 15.59           C
ATOM    145  CA  THR A1510     103.316 110.677 156.334  1.00 27.65           C
ATOM    146  CA  PRO A1511     102.558 114.210 157.787  1.00 40.50           C
ATOM    147  CA  GLY A1512     105.530 116.313 159.047  1.00 44.65           C
ATOM    148  CA  THR A1513     108.047 113.929 157.313  1.00 22.55           C
ATOM    149  CA  GLU A1514     110.992 114.686 154.966  1.00 21.10           C
ATOM    150  CA  TYR A1515     111.497 112.635 151.738  1.00 12.67           C
ATOM    151  CA  VAL A1516     114.448 112.279 149.296  1.00 13.40           C
ATOM    152  CA  VAL A1517     113.412 111.940 145.595  1.00 11.78           C
ATOM    153  CA  SER A1518     115.583 110.904 142.590  1.00 12.34           C
ATOM    154  CA  ILE A1519     114.725 110.895 138.832  1.00 11.14           C
ATOM    155  CA  VAL A1520     116.321 109.121 135.793  1.00 12.44           C
ATOM    156  CA  ALA A1521     115.462 109.388 132.060  1.00 14.96           C
ATOM    157  CA  LEU A1522     115.507 106.239 129.850  1.00 16.54           C
ATOM    158  CA  ASN A1523     116.032 105.607 126.094  1.00 25.63           C
ATOM    159  CA  GLY A1524     115.153 101.870 125.768  1.00 29.20           C
ATOM    160  CA  ARG A1525     118.103 100.567 127.906  1.00 25.61           C
ATOM    161  CA  GLU A1526     120.342 103.685 128.085  1.00 26.12           C
ATOM    162  CA  GLU A1527     119.837 105.577 131.422  1.00 19.28           C
ATOM    163  CA  SER A1528     120.671 109.264 132.149  1.00 21.68           C
ATOM    164  CA  PRO A1529     122.567 110.558 135.203  1.00 26.78           C
ATOM    165  CA  LEU A1530     120.377 111.168 138.317  1.00 17.50           C
ATOM    166  CA  LEU A1531     118.417 114.337 139.198  1.00 14.81           C
ATOM    167  CA  ILE A1532     117.866 114.501 143.053  1.00 15.20           C
ATOM    168  CA  GLY A1533     115.890 116.681 145.574  1.00 19.48           C
ATOM    169  CA  GLN A1534     114.319 116.753 149.115  1.00 13.66           C
ATOM    170  CA  GLN A1535     110.796 117.747 150.352  1.00 14.79           C
ATOM    171  CA  SER A1536     108.762 117.751 153.634  1.00 21.12           C
ATOM    172  CA  THR A1537     104.992 117.146 154.169  1.00 27.76           C
TER
END
"""

def rf(a,b):
  a=abs(a).data()
  b=abs(b).data()
  sc = flex.sum(a*b)/flex.sum(b*b)
  b = b*sc
  return flex.sum(flex.abs(a-b))/flex.sum(a+b)*2*100.

def run():
  p = iotbx.pdb.input(source_info=None, lines=pdb_str)
  h = p.construct_hierarchy()
  x = h.extract_xray_structure(crystal_symmetry=p.crystal_symmetry())
  for d_min in [8,9,10,15,20,25,30,35,40,45,
                50,55,60,65,70,75,80,85,90,95,100,200]:
    t0=time.time()
    fc_f = x.structure_factors(d_min=d_min, algorithm="fft").f_calc()
    t = time.time()-t0
    fc_d = x.structure_factors(d_min=d_min, algorithm="direct").f_calc()
    r = rf(fc_f, fc_d)
    assert r<0.6, r

if (__name__ == "__main__"):
  run()


 *******************************************************************************


 *******************************************************************************
cctbx/regression/tst_sgtbx.py
from __future__ import absolute_import, division, print_function

from cctbx import sgtbx
import cctbx.sgtbx.bravais_types
from cctbx.array_family import flex
import scitbx.math
from libtbx.test_utils import approx_equal
from libtbx.utils import format_cpu_times
from six.moves import range
from six.moves import map
try:
  from six.moves import cPickle as pickle
except ImportError:
  import pickle
import random
import sys

def exercise_sys_abs_equiv():
  from cctbx.sgtbx import sys_abs_equiv
  assert sys_abs_equiv.space_group_numbers[0] is None
  assert sys_abs_equiv.space_group_numbers[1] == (2,)
  assert sys_abs_equiv.space_group_numbers[2] == (1,)
  assert sys_abs_equiv.space_group_numbers[75] == (81,83,89,99,111,115,123)
  assert sys_abs_equiv.space_group_numbers[230] is None

def exercise_space_group_info():
  i = sgtbx.space_group_info("P 1")
  assert i.type().number() == 1
  i = sgtbx.space_group_info("P -1")
  assert i.type().number() == 2
  i = sgtbx.space_group_info("P 2", "I", space_group_t_den=24)
  assert str(i) == "P 1 1 2"
  assert i.group().t_den() == 24
  i = sgtbx.space_group_info("P32 (a,b,3c)", space_group_t_den=36)
  assert str(i) == "P 32 (a,b,3*c)"
  assert i.group().t_den() == 36
  i = sgtbx.space_group_info("P 2", "I")
  assert str(i) == "P 1 1 2"
  i = sgtbx.space_group_info("P 2", "a")
  assert str(i) == "P 1 2 1"
  assert i.group() == i.type().group()
  assert i.reciprocal_space_asu().reference_as_string() \
      == "k>=0 and (l>0 or (l==0 and h>=0))"
  assert str(i.brick()) == "0<=x<=1/2; 0<=y<1; 0<=z<1"
  assert i.wyckoff_table().space_group_type().group() == i.type().group()
  assert len(i.structure_seminvariants().vectors_and_moduli()) == 3
  assert i.number_of_continuous_allowed_origin_shifts() == 1
  for sg_number in (1,3,15,75,143,195):
    assert approx_equal(
      sgtbx.space_group_info(sg_number).any_compatible_unit_cell(100).volume(),
      100)
  s = pickle.dumps(i)
  j = pickle.loads(s)
  assert str(i) == str(j)
  i = sgtbx.space_group_info("B 2", "i")
  assert not i.is_reference_setting()
  assert str(i.change_of_basis_op_to_reference_setting().c()) == "-x,z,y"
  assert str(i.reference_setting()) == "C 1 2 1"
  assert str(i.as_reference_setting()) == "C 1 2 1"
  assert str(i.primitive_setting()) == "C 1 2 1 (-x+y,z,x+y)"
  asu = i.direct_space_asu()
  assert len(asu.cuts) == 6
  assert sgtbx.space_group(asu.hall_symbol) == i.group()
  j = i.primitive_setting()
  asu = j.direct_space_asu()
  assert len(asu.cuts) == 6
  assert sgtbx.space_group(asu.hall_symbol) == j.group()
  i = sgtbx.space_group_info(number=19)
  assert [str(sgtbx.space_group_info(group=group))
    for group in i.reflection_intensity_equivalent_groups()] == [
      "P 2 2 2",
      "P 2 2 21",
      "P 21 2 2",
      "P 2 21 2",
      "P 21 21 2",
      "P 2 21 21",
      "P 21 2 21",
      "P 21 21 21"]
  assert len(i.reflection_intensity_equivalent_groups(anomalous_flag=False)) \
      == 127
  #
  i = sgtbx.space_group_info(symbol="C 1 2 1")
  assert str(i.change_of_basis_op_to_reference_setting().c()) == "x,y,z"
  assert approx_equal(
    i.subtract_continuous_allowed_origin_shifts(translation_frac=[1,2,3]),
    [1,0,3])
  i = sgtbx.space_group_info(symbol="B 2 1 1")
  assert str(i.change_of_basis_op_to_reference_setting().c()) == "z,x,y"
  assert approx_equal(
    i.subtract_continuous_allowed_origin_shifts(translation_frac=[1,2,3]),
    [0,2,3])
  #
  for space_group_symbol, addl_smx, uhm in [
        ("P 21 21 21", "x+1/2,y+1/2,z", "C 2 2 21 (a-1/4,b,c)"),
        ("C 1 2 1", "x,y+1/2,z", "P 1 2 1 (2*a,2*b,c)")]:
    for f in range(1,12+1):
      sg_t_den = sgtbx.sg_t_den * f
      cb_r_den = sgtbx.cb_r_den * f
      cb_t_den = sgtbx.cb_t_den * f
      #
      sg_i = sgtbx.space_group_info(symbol=space_group_symbol)
      t = sg_i.type()
      assert sg_i.type(tidy_cb_op=True) is t
      assert sg_i.type(tidy_cb_op=False) is not t
      if (f != 1):
        t = sg_i.type()
        c = t.cb_op().c()
        assert c.r().den() == sgtbx.cb_r_den
        assert c.t().den() == sgtbx.cb_t_den
        for t_den in [cb_t_den, None]:
          if (t_den is not None):
            tt = sg_i.type(t_den=t_den)
            assert tt is not t
          else:
            assert sg_i.type(t_den=t_den) is tt
          c = tt.cb_op().c()
          assert c.r().den() == sgtbx.cb_r_den
          assert c.t().den() == cb_t_den
        for r_den in [cb_r_den, None]:
          if (r_den is not None):
            tr = sg_i.type(r_den=r_den)
            assert tr is not tt
          else:
            sg_i.type(r_den=r_den) is tr
          c = tr.cb_op().c()
          assert c.r().den() == cb_r_den
          assert c.t().den() == cb_t_den
      #
      sg_i = sgtbx.space_group_info(
        symbol=space_group_symbol,
        space_group_t_den=sg_t_den)
      sgx = sgtbx.space_group(sg_i.group())
      rt_mx = sgtbx.rt_mx(addl_smx)
      rt_mx = rt_mx.new_denominators(sgx.r_den(), sgx.t_den())
      sgx.expand_smx(rt_mx)
      sgx_i = sgx.info()
      assert str(sgx_i) == uhm
      t = sgx_i.type()
      c = t.cb_op().c()
      assert c.r().den() == cb_r_den
      assert c.t().den() == cb_t_den
      for r_den,t_den in [(None, None),
                          (cb_r_den, None),
                          (None, cb_t_den),
                          (cb_r_den, cb_t_den)]:
        assert sgx_i.type(r_den=r_den, t_den=t_den) is t
      assert sgx_i.type(tidy_cb_op=False, r_den=r_den, t_den=t_den) is not t
      for i, op in enumerate(sgx_i.group()):
        assert sgx_i.cif_symmetry_code(op) == "%i" %(i+1)
        assert sgx_i.cif_symmetry_code(
          op, full_code=True, sep=" ") == "%i 555" %(i+1)
        tr = [random.randint(-4, 4) for j in range(3)]
        rt_mx = sgtbx.rt_mx(op.r(), op.t().plus(
          sgtbx.tr_vec(tr, tr_den=1).new_denominator(op.t().den())))
        assert sgx_i.cif_symmetry_code(rt_mx, full_code=True) \
               == "%i_%i%i%i" %(i+1, 5+tr[0], 5+tr[1], 5+tr[2])

def test_enantiomorphic_pairs():
  pairs = []
  done = [False for i in range(231)]
  for i in range(1, 231):
    a = sgtbx.space_group_info(i)
    b = a.change_hand()
    assert a.type().is_enantiomorphic() == b.type().is_enantiomorphic()
    assert (a.group() == b.group()) == (not a.type().is_enantiomorphic())
    done[i] = True
    if (a.type().is_enantiomorphic()):
      j = b.type().number()
      if (not done[j]):
        assert j > i
        pairs.append((i,j))
        done[i] = True
      else:
        assert j < i
        assert (j,i) in pairs
  assert pairs == [(76, 78), (91, 95), (92, 96),
                   (144, 145), (151, 153), (152, 154),
                   (169, 170), (171, 172), (178, 179), (180, 181),
                   (212, 213)]

def exercise_ss_continuous_shifts_are_principal():
  for i in range(1, 231):
    sgi = sgtbx.space_group_info(number=i)
    ss = sgi.structure_seminvariants()
    assert ss.continuous_shifts_are_principal()
  for symbols in sgtbx.space_group_symbol_iterator():
    sgi = sgtbx.space_group_info(group=sgtbx.space_group(
      space_group_symbols=symbols))
    ss = sgi.structure_seminvariants()
    if (not ss.continuous_shifts_are_principal()):
      assert symbols.universal_hermann_mauguin() in [
        "R 3 :R",
        "R 3 m :R",
        "R 3 c :R"]

def exercise_generator_set():
  sgi = sgtbx.space_group_info('P1')
  sg_generator_set = sgtbx.any_generator_set(sgi.group())
  assert sg_generator_set.non_primitive_generators == ()

  sgi = sgtbx.space_group_info('P21')
  sg_generator_set = sgtbx.any_generator_set(sgi.group())
  assert (list(map(str, sg_generator_set.non_primitive_generators))
          == ['-x,y+1/2,-z'])

  sgi = sgtbx.space_group_info('Pmmm')
  sg_generator_set = sgtbx.any_generator_set(sgi.group())
  assert (list(map(str, sg_generator_set.non_primitive_generators))
          == ['-x,-y,-z', 'x,-y,-z', '-x,y,-z'])

  for i in range(1, 231):
    sgi = sgtbx.space_group_info(number=i)
    sg = sgi.group()
    sg_gen = sgtbx.any_generator_set(sg)
    if sg.z2p_op().is_identity_op():
      assert sg_gen.non_primitive_generators == sg_gen.primitive_generators

  for i in range(1, 231):
    sgi = sgtbx.space_group_info(number=i)
    sg = sgi.group()
    sg_gen = sgtbx.any_generator_set(sg)
    sg1 = sgtbx.space_group("P1")
    for op in sg_gen.non_primitive_generators:
      sg1.expand_smx(op)
    for t in sg.ltr():
        sg1.expand_ltr(t)
    assert sg1.type().number() == sg.type().number()

def exercise_allowed_origin_shift():
  sgi = sgtbx.space_group_info("F222")
  assert sgi.is_allowed_origin_shift((1/2, 1/2, 1/2), tolerance=1e-15)
  assert not sgi.is_allowed_origin_shift((0.1, 0.1, 0.1), tolerance=1e-15)

  sgi = sgtbx.space_group_info("P2")
  assert sgi.is_allowed_origin_shift((0, 1.23407, 0), tolerance=1e-15)
  assert sgi.is_allowed_origin_shift((0.5, 0, 0), tolerance=1e-15)
  assert sgi.is_allowed_origin_shift((0, 0, 0.5), tolerance=1e-15)
  assert sgi.is_allowed_origin_shift((0.001, -0.0008, 0.499),
                                     tolerance=0.005)
  assert not sgi.is_allowed_origin_shift((0.001, -0.0008, 0.45),
                                         tolerance=0.005)
  assert sgi.is_allowed_origin_shift((0.5, 0.12345, 0.5), tolerance=1e-15)

  sgi = sgtbx.space_group_info("Cmmm")
  assert sgi.is_allowed_origin_shift((0.5, 0, 0), tolerance=1e-15)
  assert sgi.is_allowed_origin_shift((0, 0, 0.5), tolerance=1e-15)
  assert sgi.is_allowed_origin_shift((0.5, 0, 0.5), tolerance=1e-15)
  assert not sgi.is_allowed_origin_shift((0.5, 0.1, 0.5), tolerance=1e-15)
  assert sgi.is_allowed_origin_shift((0.49, 0, 0.51), tolerance=0.05)

  sgi = sgtbx.space_group_info("R 3 :R")
  assert sgi.is_allowed_origin_shift((1.222, 1.221, 1.223),
                                     tolerance=0.005)
  assert not sgi.is_allowed_origin_shift((1.222, 1.221, 1.),
                                         tolerance=0.005)

  sgi = sgtbx.space_group_info("R -3 c :H")
  assert sgi.is_allowed_origin_shift((1/3, 2/3, 1+1/6), tolerance=1e-15)

  for i in range(1,231):
    sgi = sgtbx.space_group_info(number=i)
    for t in sgi.group().ltr():
      assert sgi.is_allowed_origin_shift(t.as_double(), tolerance=1e-15)

def exercise_monoclinic_cell_choices_core(space_group_number, verbose):
  # transformation matrices for cell choices
  # columns are basis vectors "new in terms of old"
  # see Int. Tab. Vol. A, p. 22, Fig. 2.2.6.4.
  b1 = (1, 0, 0,
        0, 1, 0,
        0, 0, 1)
  b2 = (-1, 0, 1,
         0, 1, 0,
        -1, 0, 0)
  b3 = (0, 0, -1,
        0, 1,  0,
        1, 0, -1)
  flip = (0,  0, 1,
          0, -1, 0,
          1,  0, 0)
  p3s = sgtbx.space_group("P 3*")
  done = {}
  ref = sgtbx.space_group_info(number=space_group_number)
  ref_uhm = ref.type().universal_hermann_mauguin_symbol()
  for i_fl,fl in enumerate([b1, flip]):
    rfl = sgtbx.rot_mx(fl)
    cfl = sgtbx.change_of_basis_op(sgtbx.rt_mx(rfl))
    for i_rt,rt in enumerate(p3s):
      rp3 = rt.r()
      cp3 = sgtbx.change_of_basis_op(sgtbx.rt_mx(rp3))
      for i_cs,cs in enumerate([b1,b2,b3]):
        rcs = sgtbx.rot_mx(cs).inverse()
        ccs = sgtbx.change_of_basis_op(sgtbx.rt_mx(rcs))
        cb_all = cp3 * cfl * ccs
        refcb = ref.change_basis(cb_all)
        refcb2 = sgtbx.space_group_info(symbol=ref_uhm+"("+str(cb_all.c())+")")
        assert refcb2.group() == refcb.group()
        s = sgtbx.space_group_symbols(str(refcb))
        q = s.qualifier()
        hm = str(refcb)
        if (0 or verbose): print(hm, q, cb_all.c())
        if (i_fl == 0):
          assert q[0] == "bca"[i_rt]
          if (len(q) == 2): assert q[1] == "123"[i_cs]
        elif (q[0] == "-"):
          assert q[1] == "bca"[i_rt]
          if (len(q) == 3): assert q[2] == "123"[i_cs]
        else:
          assert q[0] == "bca"[i_rt]
          if (len(q) == 2 and q[1] != "123"[i_cs]):
            assert done[hm] == 1
        done.setdefault(hm, 0)
        done[hm] += 1
  assert len(done) in [3, 9, 18]
  assert list(done.values()) == [18/len(done)]*len(done)
  if (0 or verbose): print()
  return done

def exercise_monoclinic_cell_choices(verbose=0):
  done = {}
  for space_group_number in range(3,16):
    done.update(exercise_monoclinic_cell_choices_core(
      space_group_number=space_group_number, verbose=verbose))
  assert len(done) == 105
  assert list(done.values()).count(0) == 0
  n = 0
  for s in sgtbx.space_group_symbol_iterator():
    if (s.number() < 3): continue
    if (s.number() > 15): break
    done[s.universal_hermann_mauguin()] = 0
    n += 1
  assert n == 105
  assert list(done.values()).count(0) == 105

def exercise_orthorhombic_hm_qualifier_as_cb_symbol():
  cb_symbols = {
    "cab": ["c,a,b", "z,x,y"],
    "a-cb": ["a,-c,b", "x,-z,y"],
    "-cba": ["-c,b,a", "-z,y,x"],
    "bca": ["b,c,a", "y,z,x"],
    "ba-c": ["b,a,-c", "y,x,-z"]}
  for sgsyms1 in sgtbx.space_group_symbol_iterator():
    n = sgsyms1.number()
    if (n < 16 or n > 74): continue
    q = sgsyms1.qualifier()
    if (len(q) == 0): continue
    e = sgsyms1.extension()
    if (e == "\0"): e = ""
    ehm = sgtbx.space_group_symbols(
      space_group_number=n, extension=e).universal_hermann_mauguin()
    cabc, cxyz = cb_symbols[q]
    assert sgtbx.change_of_basis_op(cxyz).as_abc() == cabc
    assert sgtbx.change_of_basis_op(cabc).as_xyz() == cxyz
    uhm_xyz = ehm + " ("+cxyz+")"
    sgsyms2 = sgtbx.space_group_symbols(symbol=uhm_xyz)
    assert sgsyms2.change_of_basis_symbol() == cxyz
    assert sgsyms2.extension() == sgsyms1.extension()
    assert sgsyms2.universal_hermann_mauguin() == uhm_xyz
    g1 = sgtbx.space_group(space_group_symbols=sgsyms1)
    g2 = sgtbx.space_group(space_group_symbols=sgsyms2)
    assert g2 == g1
    g2 = sgtbx.space_group(
      sgtbx.space_group_symbols(symbol=ehm)).change_basis(
        sgtbx.change_of_basis_op(sgtbx.rt_mx(cxyz)))
    assert g2 == g1
    for c in [cxyz, cabc]:
      g2 = sgtbx.space_group_info(
        group=sgtbx.space_group(
          sgtbx.space_group_symbols(symbol=ehm))).change_basis(c).group()
      assert g2 == g1
    cit = sgtbx.rt_mx(cxyz).r().inverse().transpose()
    cit_xyz = cit.as_xyz()
    g2 = sgtbx.space_group_info(
      group=sgtbx.space_group(
        sgtbx.space_group_symbols(symbol=ehm))).change_basis(cit_xyz).group()
    assert g2 == g1
    assert cit.as_xyz(False, "abc") == cabc
    uhm_abc = ehm + " ("+cabc+")"
    sgsyms2 = sgtbx.space_group_symbols(symbol=uhm_abc)
    assert sgsyms2.change_of_basis_symbol() == cxyz
    assert sgsyms2.extension() == sgsyms1.extension()
    assert sgsyms2.universal_hermann_mauguin() == uhm_xyz
    g2 = sgtbx.space_group(space_group_symbols=sgsyms2)
    assert g2 == g1

def python_tensor_constraints(self, reciprocal_space):
  """row-reduced echelon form of coefficients
       r.transpose() * t * r - t = 0
     Mathematica code:
       r={{r0,r1,r2},{r3,r4,r5},{r6,r7,r8}}
       t={{t0,t3,t4},{t3,t1,t5},{t4,t5,t2}}
       FortranForm[Expand[Transpose[r].t.r - t]]
  """
  result = flex.int()
  for s in self.smx():
    r = s.r()
    if (reciprocal_space):
      r = r.transpose()
    r0,r1,r2,r3,r4,r5,r6,r7,r8 = r.num()
    result.extend(flex.int((
      r0*r0-1, r3*r3,   r6*r6,   2*r0*r3, 2*r0*r6, 2*r3*r6,
      r1*r1,   r4*r4-1, r7*r7,   2*r1*r4, 2*r1*r7, 2*r4*r7,
      r2*r2,   r5*r5,   r8*r8-1, 2*r2*r5, 2*r2*r8, 2*r5*r8,
      r0*r1, r3*r4, r6*r7, r1*r3+r0*r4-1, r1*r6+r0*r7,   r4*r6+r3*r7,
      r0*r2, r3*r5, r6*r8, r2*r3+r0*r5,   r2*r6+r0*r8-1, r5*r6+r3*r8,
      r1*r2, r4*r5, r7*r8, r2*r4+r1*r5,   r2*r7+r1*r8,   r5*r7+r4*r8-1)))
  result.resize(flex.grid(result.size()//6,6))
  scitbx.math.row_echelon_form(result)
  return result

def exercise_tensor_constraints_core(crystal_symmetry):
  from cctbx import crystal
  from cctbx import adptbx
  from scitbx import matrix
  site_symmetry = crystal.special_position_settings(
    crystal_symmetry).site_symmetry(site=(0,0,0))
  unit_cell = crystal_symmetry.unit_cell()
  group = crystal_symmetry.space_group()
  assert site_symmetry.n_matrices() == group.order_p()
  for reciprocal_space in [False, True]:
    c_tensor_constraints = sgtbx.tensor_rank_2_constraints(
      space_group=group,
      reciprocal_space=reciprocal_space).row_echelon_form()
    p_tensor_constraints = python_tensor_constraints(
      self=group, reciprocal_space=reciprocal_space)
    assert c_tensor_constraints.all_eq(p_tensor_constraints)
  adp_constraints = group.adp_constraints()
  u_cart_p1 = adptbx.random_u_cart()
  u_star_p1 = adptbx.u_cart_as_u_star(unit_cell, u_cart_p1)
  u_star = site_symmetry.average_u_star(u_star_p1)
  f = unit_cell.volume()**(2/3.)
  assert approx_equal(
    list(matrix.col(group.average_u_star(u_star=u_star_p1))*f),
    list(matrix.col(u_star)*f))
  independent_params = adp_constraints.independent_params(u_star)
  assert adp_constraints.n_independent_params() == len(independent_params)
  assert adp_constraints.n_independent_params() \
       + adp_constraints.n_dependent_params() == 6
  u_star_vfy = adp_constraints.all_params(independent_params)
  u_cart = adptbx.u_star_as_u_cart(unit_cell, u_star)
  u_cart_vfy = adptbx.u_star_as_u_cart(unit_cell, list(u_star_vfy))
  assert approx_equal(u_cart_vfy, u_cart)

def exercise_tensor_constraints():
  from cctbx import crystal
  for symbol in sgtbx.bravais_types.acentric + sgtbx.bravais_types.centric:
    space_group_info = sgtbx.space_group_info(symbol=symbol)
    crystal_symmetry = crystal.symmetry(
      unit_cell=space_group_info.any_compatible_unit_cell(volume=1000),
      space_group_info=space_group_info)
    exercise_tensor_constraints_core(crystal_symmetry)
    exercise_tensor_constraints_core(crystal_symmetry.minimum_cell())

def exercise_space_group_contains():
  g = sgtbx.space_group("P 2")
  for s in ["x,y,z", "-x,-y,z", "-x+1,-y-2,z+3"]:
    assert g.contains(sgtbx.rt_mx(s))
  for s in ["x,y,-z", "x+1/2,y,z"]:
    assert not g.contains(sgtbx.rt_mx(s))
  for symbols in sgtbx.space_group_symbol_iterator():
    g = sgtbx.space_group(symbols.hall())
    for s in g:
      assert g.contains(s)
  rnd = flex.mersenne_twister(seed=0)
  n_c = 0
  n_nc = 0
  for symbol in sgtbx.bravais_types.centric:
    g = sgtbx.space_group_info(symbol=symbol, space_group_t_den=144).group()
    for s in g.change_basis(sgtbx.change_of_basis_op("x+1/12,y-1/12,z+1/12")):
      if (rnd.random_double() < 0.9): continue # avoid long runtime
      gc = sgtbx.space_group(g)
      gc.expand_smx(s)
      if (gc.order_z() == g.order_z()):
        assert g.contains(s)
        n_c += 1
      else:
        assert not g.contains(s)
        n_nc += 1
  assert n_c == 11, n_c
  assert n_nc == 53, n_nc

def exercise_inversion_centring():
  cb = sgtbx.change_of_basis_op("x+1/12,y+1/12,z-1/12")
  for symb in sgtbx.space_group_symbol_iterator():
    sg = sgtbx.space_group(space_group_symbols=symb)
    sg1 = sg.change_basis(cb)
    icb = sg1.change_of_origin_realising_origin_centricity()
    if sg1.is_centric():
      assert not sg1.is_origin_centric()
      sg2 = sg1.change_basis(icb)
      assert sg2.is_origin_centric()
    else:
      assert str(icb) == "a,b,c"

def exercise_change_of_basis_between_arbitrary_space_groups():
  from random import randint
  from scitbx import matrix as mat

  g = sgtbx.space_group_info('hall: P 2')
  h = sgtbx.space_group_info('hall: P 2c')
  assert g.change_of_basis_op_to(h) is None

  g = sgtbx.space_group_info('hall: C 2c 2 (x+y,x-y,z)')
  h = g.change_basis(sgtbx.change_of_basis_op(sgtbx.rt_mx('-y,x,z')))
  cb_op = g.change_of_basis_op_to(h)
  assert cb_op.as_xyz() == 'x,y,z+1/4'
  assert g.change_basis(cb_op).group() == h.group()

  g = sgtbx.space_group_info('hall: I 4 2 3')
  z2p_op = g.change_of_basis_op_to_primitive_setting()
  h = g.change_basis(z2p_op)
  cb_op = g.change_of_basis_op_to(h)
  assert cb_op.c() == z2p_op.c(), (cb_op.as_xyz(), z2p_op.as_xyz())

  for i in range(1, 231):
    s = sgtbx.space_group_symbols(space_group_number=i)
    g = sgtbx.space_group_info(group=sgtbx.space_group(s, t_den=24))

    o = tuple([ randint(0, 23) for j in range(3) ])
    cb_op = sgtbx.change_of_basis_op(sgtbx.rt_mx(sgtbx.tr_vec(o, 24)))
    h = g.change_basis(cb_op)
    cb_op_1 = g.change_of_basis_op_to(h)
    assert cb_op_1.c().r().is_unit_mx()
    delta = (mat.col(cb_op_1.c().t().as_double())
             - mat.col(cb_op.c().t().as_double()))
    assert h.is_allowed_origin_shift(delta, tolerance=1e-12)

    z2p_op = g.change_of_basis_op_to_primitive_setting()
    h = g.change_basis(z2p_op)
    cb_op = g.change_of_basis_op_to(h)
    h1 = g.change_basis(cb_op)
    assert (h.as_reference_setting().group()
            == h1.as_reference_setting().group())

def exercise_compare_cb_op_as_hkl():
  from functools import cmp_to_key
  l = ["k,h,l", "h,k,l"]
  l.sort(key=cmp_to_key(sgtbx.compare_cb_op_as_hkl))
  assert l == ["h,k,l", "k,h,l"]
  l.sort(key=cmp_to_key(sgtbx.compare_cb_op_as_hkl))
  assert l == ["h,k,l", "k,h,l"]

def run(args):
  exercise_change_of_basis_between_arbitrary_space_groups()
  exercise_sys_abs_equiv()
  exercise_allowed_origin_shift()
  exercise_generator_set()
  exercise_space_group_info()
  test_enantiomorphic_pairs()
  exercise_ss_continuous_shifts_are_principal()
  exercise_monoclinic_cell_choices(verbose="--verbose" in args)
  exercise_orthorhombic_hm_qualifier_as_cb_symbol()
  exercise_tensor_constraints()
  exercise_space_group_contains()
  exercise_inversion_centring()
  exercise_compare_cb_op_as_hkl()
  print(format_cpu_times())

if (__name__ == "__main__"):
  run(sys.argv[1:])


 *******************************************************************************


 *******************************************************************************
cctbx/regression/tst_sgtbx_denominators.py
from __future__ import absolute_import, division, print_function
from cctbx import sgtbx
from cctbx.development import debug_utils
import sys

def run_call_back(flags, space_group_info):
  t_den = sgtbx.sg_t_den * 2
  g = sgtbx.space_group()
  g.reset(t_den)
  for s in space_group_info.group():
    g.expand_smx(s.new_denominators(1,t_den))
  info = sgtbx.space_group_info(group=g)
  for fr in (1,2):
    for ft in (1,2):
      r = sgtbx.cb_r_den * fr
      t = sgtbx.cb_t_den * ft
      type = info.type(r_den=r, t_den=t)
      assert type.number() == space_group_info.type().number()
      assert type.lookup_symbol() == space_group_info.type().lookup_symbol()
      assert type.cb_op().c().r().den() == r
      assert type.cb_op().c().t().den() == t

def run():
  debug_utils.parse_options_loop_space_groups(sys.argv[1:], run_call_back)
  print("OK")

if (__name__ == "__main__"):
  run()


 *******************************************************************************


 *******************************************************************************
cctbx/regression/tst_sgtbx_harker.py
from __future__ import absolute_import, division, print_function
from cctbx.sgtbx import harker
from cctbx import crystal
from cctbx import sgtbx
from libtbx.test_utils import approx_equal as ae

def run():
  uc = (10,12,14,90,90,90)
  cs = crystal.symmetry(unit_cell=uc, space_group_symbol="P 1")
  assert harker.planes_cartesian(cs).count() == 0
  assert harker.planes_cartesian(cs).min_distance((0,0,0)) is None
  cs = crystal.symmetry(unit_cell=uc, space_group_symbol="P 2 2 2")
  assert harker.planes_cartesian(cs).count() == 3
  assert ae(harker.planes_cartesian(cs).min_distance((0.123,0.234,0)), 0)
  assert ae(harker.planes_cartesian(cs).min_distance((0.123,0,0.234)), 0)
  assert ae(harker.planes_cartesian(cs).min_distance((0,0.123,0.234)), 0)
  assert ae(harker.planes_cartesian(cs).min_distance((0.1,0.234,0.345)), 1)
  assert ae(harker.planes_cartesian(cs).min_distance((0.234,0.1,0.345)), 1.2)
  assert ae(harker.planes_cartesian(cs).min_distance((0.234,0.345,0.1)), 1.4)
  assert ae(harker.planes_cartesian(cs).min_distance((0.2,0.2,0.1)), 1.4)
  assert ae(harker.planes_cartesian(cs).min_distance((0.2,0.1,0.1)), 1.2)
  assert ae(harker.planes_cartesian(cs).min_distance((0.1,0.2,0.2)), 1)
  assert ae(harker.planes_cartesian(cs).min_distance((-0.2,0.1,0.1)), 1.2)
  assert ae(harker.planes_cartesian(cs).min_distance((0.2,-0.1,0.1)), 1.2)
  assert ae(harker.planes_cartesian(cs).min_distance((0.2,0.1,-0.1)), 1.2)
  assert ae(harker.planes_cartesian(cs).min_distance((-0.2,-0.1,-0.1)), 1.2)
  uc = (10,10,12,90,90,120)
  cs = crystal.symmetry(unit_cell=uc, space_group_symbol="P 3")
  assert harker.planes_cartesian(cs).count() == 1
  assert ae(harker.planes_cartesian(cs).min_distance((0,0,0)), 0)
  assert ae(harker.planes_cartesian(cs).min_distance((0.1,0.2,1/3.)), 4)
  assert ae(harker.planes_cartesian(cs).min_distance((0.1,0.2,1/2.)), 6)
  cs = crystal.symmetry(unit_cell=uc, space_group_symbol="P 31")
  assert harker.planes_cartesian(cs).count() == 1
  assert ae(harker.planes_cartesian(cs).min_distance((0,0,0)), 4)
  assert ae(harker.planes_cartesian(cs).min_distance((0.1,0.2,1/3.)), 0)
  assert ae(harker.planes_cartesian(cs).min_distance((0.1,0.2,1/2.)), 2)
  uc = (10,10,12,90,90,90)
  cs = crystal.symmetry(unit_cell=uc, space_group_symbol="P 4 2 2")
  assert harker.planes_cartesian(cs).count() == 5
  cs = crystal.symmetry(unit_cell=uc, space_group_symbol="P 41 2 2")
  assert harker.planes_cartesian(cs).count() == 6
  ps = crystal.symmetry(unit_cell=uc, space_group_symbol="P 4/m m m")
  for x,d,t in (((0.1,0.2,0.3),0.6,"1"),
                ((0.1,0.2,0.75),0,"1"),
                ((0.1,0.0,0.3),0,"m")):
    ss = crystal.special_position_settings(ps).site_symmetry(x)
    assert ss.point_group_type() == t
    eq = sgtbx.sym_equiv_sites(ss)
    for x in eq.coordinates():
      assert ae(harker.planes_cartesian(cs).min_distance(x), d)
  print("OK")

if (__name__ == "__main__"):
  run()


 *******************************************************************************


 *******************************************************************************
cctbx/regression/tst_sgtbx_lattice_symmetry.py
from __future__ import absolute_import, division, print_function
from cctbx import crystal
from cctbx import sgtbx
from cctbx.sgtbx import subgroups
from cctbx.sgtbx import lattice_symmetry
from cctbx.sgtbx import bravais_types
from cctbx.array_family import flex
from libtbx.utils import format_cpu_times
from six.moves import cStringIO as StringIO
import sys
from six.moves import range
from six.moves import zip

def exercise_quick():
  for space_group_symbol in ("P-1",
                             "P2/m",
                             "C2/m",
                             "Pmmm",
                             "Cmmm",
                             "Fmmm",
                             "Immm",
                             "P4/mmm",
                             "I4/mmm",
                             "R-3m",
                             "P6/mmm",
                             "Pm-3m",
                             "Im-3m",
                             "Fm-3m"):
    parent_group_info = sgtbx.space_group_info(space_group_symbol)
    non_centric = sgtbx.space_group()
    for i_ltr in range(parent_group_info.group().n_ltr()):
      for i_smx in range(parent_group_info.group().n_smx()):
        s = parent_group_info.group()(i_ltr,0,i_smx)
        non_centric.expand_smx(s)
    assert non_centric.f_inv() == 1
    assert non_centric.order_z() * 2 == parent_group_info.group().order_z()
    non_centric_info = sgtbx.space_group_info(group=non_centric)
    unit_cell = non_centric_info.any_compatible_unit_cell(volume=1000)
    crystal_symmetry = crystal.symmetry(
      unit_cell=unit_cell,
      space_group_info=non_centric_info)
    minimum_symmetry = crystal_symmetry.minimum_cell()
    lattice_group = lattice_symmetry.group(
      minimum_symmetry.unit_cell(), max_delta=0.5)
    lattice_group_info = sgtbx.space_group_info(group=lattice_group)
    assert lattice_group_info.group() == minimum_symmetry.space_group()
    subgrs = subgroups.subgroups(lattice_group_info).groups_parent_setting()
    for group in subgrs:
      subsym = crystal.symmetry(
        unit_cell=minimum_symmetry.unit_cell(),
        space_group=group,
        assert_is_compatible_unit_cell=False)
      assert subsym.unit_cell().is_similar_to(minimum_symmetry.unit_cell())
      assert lattice_symmetry.find_max_delta(
        reduced_cell=minimum_symmetry.unit_cell(),
        space_group=group) < 0.6
  minimum_symmetry = crystal.symmetry(
    unit_cell="106.04, 181.78, 110.12, 90, 90, 90",
    space_group_symbol="P 1").minimum_cell()
  for max_delta in range(10,100,10):
    lattice_group = lattice_symmetry.group(
      minimum_symmetry.unit_cell(), max_delta=max_delta)
    lattice_group_info = sgtbx.space_group_info(group=lattice_group)
    assert str(lattice_group_info) == "P 4 2 2"

def exercise_comprehensive(args):
  if ("--verbose" in args):
    out = sys.stdout
  else:
    out = StringIO()
  if ("--paranoid" in args):
    cb_range = 2
  else:
    cb_range = 1
  for symbol in bravais_types.acentric:
    print("bravais type:", symbol)
    sym = sgtbx.space_group_info(symbol=symbol) \
      .any_compatible_crystal_symmetry(volume=1000) \
      .niggli_cell()
    abc = list(sym.unit_cell().parameters()[:3])
    abc.sort()
    for cb_elements in flex.nested_loop([-cb_range]*9,[cb_range+1]*9):
      r = sgtbx.rot_mx(cb_elements)
      if (r.determinant() != 1): continue
      cb_op = sgtbx.change_of_basis_op(sgtbx.rt_mx(r))
      sym_cb = sym.change_basis(cb_op)
      abc_cb = list(sym_cb.unit_cell().parameters()[:3])
      abc_cb.sort()
      for x,y in zip(abc, abc_cb):
        assert y-x > -1.e-6
        if (y-x > 1.e-4): break
      else:
        print("cb_ob:", cb_op.c(), cb_elements, file=out)
        assert min(cb_elements) >= -1
        assert max(cb_elements) <= 1
        for s in sym_cb.space_group():
          assert s.r().den() == 1
          r_num = s.r().num()
          print("r:", r_num, file=out)
          assert min(r_num) >= -1
          assert max(r_num) <= 1
        for enforce in [False, True]:
          lattice_group = sgtbx.lattice_symmetry.group(
            reduced_cell=sym_cb.unit_cell(),
            max_delta=1.4,
            enforce_max_delta_for_generated_two_folds=enforce)
        assert lattice_group == sym_cb.space_group()
        sys.stdout.flush()
    print(file=out)

def run(args):
  exercise_quick()
  exercise_comprehensive(args)
  print(format_cpu_times())

if (__name__ == "__main__"):
  run(sys.argv[1:])


 *******************************************************************************


 *******************************************************************************
cctbx/regression/tst_sgtbx_site_constraints.py
from __future__ import absolute_import, division, print_function
from iotbx.kriber import strudat
from iotbx.option_parser import iotbx_option_parser
from cctbx.array_family import flex
from scitbx import matrix
from libtbx.utils import format_cpu_times
from libtbx.test_utils import approx_equal
import libtbx.load_env
from six.moves import cStringIO as StringIO
import math
import sys, os
from six.moves import range

flex.set_random_seed(0)

class cos_alpha:

  def __init__(self, h, site_constraints, independent_params):
    self.h = matrix.row(h)
    self.site_constraints = site_constraints
    self.independent_params = independent_params
    self.site = matrix.col(self.site_constraints.all_params(
      independent_params=self.independent_params))

  def f(self):
    return math.cos(self.h.dot(self.site))

  def df_d_site(self):
    all_gradients = -math.sin(self.h.dot(self.site)) * self.h
    return flex.double(self.site_constraints.independent_gradients(
      all_gradients=flex.double(all_gradients)))

  def d2f_d_site(self):
    all_curvatures = -math.cos(self.h.dot(self.site)) * self.h.outer_product()
    return self.site_constraints.independent_curvatures(
      all_curvatures=flex.double(
        all_curvatures.as_list_of_lists()).matrix_symmetric_as_packed_u())

def df_d_site_finite(h, site_constraints, independent_params, eps=1.e-8):
  result = flex.double()
  independent_params_eps = list(independent_params)
  for ip in range(len(independent_params)):
    vs = []
    for signed_eps in [eps, -eps]:
      independent_params_eps[ip] = independent_params[ip] + signed_eps
      ca = cos_alpha(
        h=h,
        site_constraints=site_constraints,
        independent_params=independent_params_eps)
      vs.append(ca.f())
    result.append((vs[0]-vs[1])/(2*eps))
    independent_params_eps[ip] = independent_params[ip]
  return result

def d2f_d_site_finite(h, site_constraints, independent_params, eps=1.e-8):
  result = flex.double()
  independent_params_eps = list(independent_params)
  for ip in range(len(independent_params)):
    vs = []
    for signed_eps in [eps, -eps]:
      independent_params_eps[ip] = independent_params[ip] + signed_eps
      ca = cos_alpha(
        h=h,
        site_constraints=site_constraints,
        independent_params=independent_params_eps)
      vs.append(ca.df_d_site())
    result.extend((vs[0]-vs[1])/(2*eps))
    independent_params_eps[ip] = independent_params[ip]
  np = len(independent_params)
  result.reshape(flex.grid(np,np))
  return result.matrix_symmetric_as_packed_u(relative_epsilon=1.e-5)

def exercise(structure, out):
  structure.show_summary(f=out)
  unit_cell = structure.unit_cell()
  for i_scatterer,scatterer in enumerate(structure.scatterers()):
    site = scatterer.site
    site_symmetry_ops = structure.site_symmetry_table().get(i_scatterer)
    assert approx_equal(site_symmetry_ops.special_op()*site, site)
    site_constraints = site_symmetry_ops.site_constraints()
    assert site_constraints.row_echelon_form().focus()[0] \
        == site_constraints.n_dependent_params()
    nip = site_constraints.n_independent_params()
    if (site_symmetry_ops.n_matrices() == 1):
      assert nip == 3
      assert site_constraints.n_dependent_params() == 0
    else:
      assert nip < 3
      assert site_constraints.n_dependent_params() > 0
    independent_params = site_constraints.independent_params(all_params=site)
    all_params = site_constraints.all_params(
      independent_params=independent_params)
    assert approx_equal(all_params, site)
    for i_trial in range(10):
      shifted_params = flex.double(independent_params) \
                     + (flex.random_double(size=nip)-0.5)
      shifted_site = site_constraints.all_params(
        independent_params=list(shifted_params))
      assert approx_equal(
        site_symmetry_ops.special_op()*shifted_site, shifted_site)
      if (nip == 0 or unit_cell.distance(shifted_site, site) > 0.1):
        break
    else:
      raise AssertionError
    independent_gradients = site_constraints.independent_gradients(
      all_gradients=flex.double(3, 0))
    assert len(independent_gradients) == nip
    assert approx_equal(independent_gradients, [0]*nip)
    independent_curvatures = site_constraints.independent_curvatures(
      all_curvatures=flex.double(6, 0))
    assert len(independent_curvatures) == nip*(nip+1)//2
    assert approx_equal(independent_curvatures, [0]*(nip*(nip+1)//2))
    #
    h = math.pi * flex.random_double(size=3)*2-1
    grads_fin = df_d_site_finite(
      h=h,
      site_constraints=site_constraints,
      independent_params=independent_params)
    print("grads_fin:", list(grads_fin), file=out)
    ca = cos_alpha(
      h=h,
      site_constraints=site_constraints,
      independent_params=independent_params)
    grads_ana = ca.df_d_site()
    print("grads_ana:", list(grads_ana), file=out)
    assert approx_equal(grads_ana, grads_fin)
    curvs_fin = d2f_d_site_finite(
      h=h,
      site_constraints=site_constraints,
      independent_params=independent_params)
    print("curvs_fin:", list(curvs_fin), file=out)
    curvs_ana = ca.d2f_d_site()
    print("curvs_ana:", list(curvs_ana), file=out)
    assert approx_equal(curvs_ana, curvs_fin)
  print(file=out)

def exercise_shake_sites_in_place(structure):
  for target_difference in [0, 0.7, 1.0, 1.3]:
    for selection in [None,
                      flex.random_bool(
                        size=structure.scatterers().size(), threshold=0.5)]:
      if (target_difference == 0): # the structure is not changed in this case
        n_variable = 1 # any value except 0 (the flex.sum() below must be 0)
      else:
        if (selection is None):
          n_variable = structure.scatterers().size()
        else:
          n_variable = selection.count(True)
        n_variable -= structure.coordinate_degrees_of_freedom_counts(
          selection=selection)[0]
      shaken = structure.deep_copy_scatterers()
      try:
        shaken.shake_sites_in_place(
          rms_difference=target_difference,
          selection=selection)
      except RuntimeError as e:
        if (selection is not None):
          if (selection.count(True) == 0):
            assert str(e) == "No scatterers selected."
          else:
            assert str(e) \
                == "All selected scatterers are fixed on special positions."
        else:
          assert str(e) \
              == "All scatterers are fixed on special positions."
      else:
        assert approx_equal(
          (flex.sum((  structure.sites_cart()
                     - shaken.sites_cart()).dot()) / n_variable) ** 0.5,
          target_difference)
        #
        shaken = structure.deep_copy_scatterers()
        shaken.shake_sites_in_place(
          mean_distance=target_difference,
          selection=selection)
        assert approx_equal(
          flex.sum(flex.sqrt((  structure.sites_cart()
                              - shaken.sites_cart()).dot())) / n_variable,
          target_difference)

def process_zeolite_atlas(args):
  command_line = (iotbx_option_parser()
    .option(None, "--tag",
      action="store",
      type="string")
    .option(None, "--verbose",
      action="store_true")
  ).process(args=args)
  atlas_file = libtbx.env.find_in_repositories(
    relative_path="phenix_regression/misc/strudat_zeolite_atlas",
    test=os.path.isfile)
  if (atlas_file is None):
    print("Skipping process_zeolite_atlas(): input file not available")
    return
  if (command_line.options.verbose):
    out = sys.stdout
  else:
    out = StringIO()
  with open(atlas_file) as f:
    all_entries = strudat.read_all_entries(f)
  for i,entry in enumerate(all_entries.entries):
    structure = entry.as_xray_structure()
    if (command_line.options.tag is not None):
      if (command_line.options.tag != entry.tag):
        continue
    print("strudat tag:", entry.tag, file=out)
    exercise(structure=structure, out=out)
    exercise_shake_sites_in_place(structure=structure)

def run():
  process_zeolite_atlas(sys.argv[1:])
  print(format_cpu_times())

if (__name__ == "__main__"):
  run()


 *******************************************************************************


 *******************************************************************************
cctbx/regression/tst_sgtbx_special_op_simplifier.py
from __future__ import absolute_import, division, print_function
from six.moves import range
from six.moves import zip

test_cases = """\
P 1
-0.13463, 0.5133, 0.41428
x,y,z

P -1
-1, -0.5, 0.5
-1,-1/2,1/2

F d d 2 (-x-y+z,2*x,2*y)
0.51827, 0, 0
x,0,0

C 1 2/c 1 (-x+y,z,2*x-z)
-0.36537, 0.75, 0.25
x,3/4,1/4

C m c a (z,x+y,2*y)
0, -0.20681, 0
0,y,0

C 1 2/c 1
0.5, -0.13463, 0.25
1/2,y,1/4

F d d 2
0, 0, 0.51827
0,0,z

F d d 2
-0.25, 0.25, 0.5133
-1/4,1/4,z

C m c 21
0, 0.41428, 0.8342
0,y,z

P m c n
0.25, 0.209, 0.2009
1/4,y,z

C 1 m 1
0.2479, 0, 0.8201
x,0,z

P 1 21/m 1
0.65486, 0.75, 0.46088
x,3/4,z

C 1 m 1 (z,x-y,2*y)
0.8201, -0.2479, 0
x,y,0

P 1 1 21/m
-0.65486, -0.46088, -0.75
x,y,-3/4

A b a 2 (y+z,2*z,x)
0.21585, 0.4317, 0
x,2*x,0

R -3 m :H
0.38797, 0.193985, -0.00711
x,1/2*x,z

F d d 2 (x+y+z,x+y-z,2*y)
-0.0133, 1.0133, 0.5
x,-x+1,1/2

I 4/m c m
0.85106, 0.35106, 0
x,x-1/2,0

C 1 2/c 1 (x+y,z,-2*y)
-0.29421, -0.25, 0.58842
x,-1/4,-2*x

C 1 2/m 1 (z,x-y,2*y)
0, -0.3019, -0.3962
0,y,-2*y-1

C 1 2/m 1 (z,x-y,x+y)
-0.5, 1.38934, 0.61066
-1/2,y,-y+2

F -4 3 m
0.10515, 0.05925, 0.10515
x,y,x

C m c 21 (-x+y,z,2*y)
0.148327, 0.5362, -0.703346
x,y,2*x-1

R -3 m :R
0.38086, -0.201095, -0.201095
x,y,y

C 1 2/m 1 (-z,x+y,2*x)
0.74518, 1.4919, 1.9838
x,y,2*y-1

C m c m (x+y,-x+y,z)
0.4689, 0.4689, 0.10868
x,x,z

C m c a (x+y,2*y,z)
-0.347957, 0.304086, -0.1964
x,2*x+1,z

P -4 b 2
0.88761, 0.61239, 0.5
x,-x+3/2,1/2

R -3 m :H (x+z,-y+z,-3*z)
0.3102, -0.1548, -0.0006
x,y,-x-2*y NO_FVAR

C 1 2/m 1 (-x+y,z,2*x-z)
-0.17213, -0.09996, 0.44422
x,y,-2*x-y NO_FVAR

C 1 2/m 1 (x+y,-x+y+z,z)
-0.06876, -0.216, -0.28476
x,y,x+y NO_FVAR

C 1 2/m 1 (-x+y,z,2*x-z)
-1.34469, 0.83463, 0.85475
x,y,-2*x-y-1 NO_FVAR

C 1 2/m 1 (-x+y,z,2*x-z)
-1.70949, 0.67904, 0.73994
x,y,-2*x-y-2 NO_FVAR

F -4 3 m (-x+y+z,x-y+z,x+y-z)
-0.151837, -0.001949, 0.576893
x,y,-1/2*x-1/2*y+1/2 NO_FVAR

C 1 2/m 1 (x+y,-x+y+z,z)
-0.3761, -0.8643, -0.2404
x,y,x+y+1 NO_FVAR

F -4 3 m (-x+y+z,x-y+z,x+y-z)
0.324012, 0.226578, 0.125398
x,y,-2*x-y+1 NO_FVAR

F -4 3 m (-x+y+z,x-y+z,x+y-z)
-0.384945, -0.110849, 0.247897
x,y,-1/2*x-1/2*y NO_FVAR

R -3 c :R
0.0639, 0.0639, 0.0639
x,x,x

F -4 3 m
0.208141, 0.208141, 0.291859
x,x,-x+1/2

F -4 3 m
0.1718, 0.3282, -0.1718
x,-x+1/2,-x

R -3 :H (x+z,-y+z,-3*z)
0.206827, -0.793173, 1.37952
x,x-1,-3*x+2 NO_FVAR

P 21 3
0.25347, 0.24653, 0.75347
x,-x+1/2,x+1/2 NO_FVAR

"""

def test_case_generator():
  from cctbx.sgtbx import space_group_info
  lines = test_cases.splitlines()
  assert len(lines) % 4 == 0
  for i in range(0, len(lines), 4):
    assert len(lines[i+3]) == 0
    expr = lines[i+2]
    j = expr.find(" NO_FVAR")
    no_fvar = (j >= 0)
    if (no_fvar):
      expr = expr[:j]
    yield \
      space_group_info(symbol=lines[i]), \
      eval(lines[i+1]), \
      expr, \
      no_fvar

def exercise():
  from scitbx.array_family import flex
  from scitbx import matrix
  from libtbx.test_utils import approx_equal, show_diff
  import libtbx.load_env
  if (libtbx.env.has_module(name="iotbx")):
    from iotbx.shelx.parsers import decode_variables
    import iotbx.shelx.errors
  else:
    decode_variables = None
  mt = flex.mersenne_twister(seed=0)
  for sgi,site,expected_expr,no_fvar in test_case_generator():
    sps = sgi.any_compatible_crystal_symmetry(volume=1000) \
      .special_position_settings()
    ss = sps.site_symmetry(site)
    assert approx_equal(ss.exact_site(), site)
    sos = ss.special_op_simplified()
    expr = str(sos)
    assert not show_diff(expr, expected_expr)
    def check(site):
      ns = dict(zip("xyz", site))
      expr_site = eval(expr, ns, {})
      assert approx_equal(expr_site, site, 1e-4)
      #
      shifted_site = (
        matrix.col(site) + matrix.col(mt.random_double_point_on_sphere()))
      ns = dict(zip("xyz", shifted_site))
      expr_shifted_site = eval(expr, ns, {})
      expr_shifted_site_exact = ss.special_op() * expr_shifted_site
      assert approx_equal(expr_shifted_site, expr_shifted_site_exact)
    check(site)
    for i_trial in range(3):
      shifted_site = ss.special_op() * (
        matrix.col(site) + matrix.col(mt.random_double_point_on_sphere()))
      check(shifted_site)
    fvars = [None] # placeholder for scale factor
    if (decode_variables is not None):
      try:
        coded_variables = ss.shelx_fvar_encoding(site=site, fvars=fvars)
      except iotbx.shelx.errors.error:
        if (not no_fvar): raise
      else:
        assert not no_fvar
      if (not no_fvar):
        values, behaviors = decode_variables(
          free_variable=fvars, coded_variables=coded_variables)
        mismatch = sps.unit_cell().mod_short_distance(site, values)
        assert mismatch < 1e-10

def run(args):
  assert len(args) == 0
  exercise()
  print("OK")

if (__name__ == "__main__"):
  import sys
  run(args=sys.argv[1:])


 *******************************************************************************


 *******************************************************************************
cctbx/regression/tst_sgtbx_subgroups.py
from __future__ import absolute_import, division, print_function
from cctbx.sgtbx import subgroups
from cctbx import sgtbx
from six.moves import range

class subgroup_stats(object):

  def __init__(self, parent_group_info):
    self.subgroups = subgroups.subgroups(
      parent_group_info).groups_parent_setting()
    self.n_non_centric = 0
    self.n_chiral = 0
    for subgroup in self.subgroups:
      if (not subgroup.is_centric()): self.n_non_centric += 1
      if (subgroup.is_chiral()): self.n_chiral += 1

def run():
  for space_group_symbol in ("P-1",
                             "P2/m",
                             "C2/m",
                             "Pmmm",
                             "Cmmm",
                             "Fmmm",
                             "Immm",
                             "P4/mmm",
                             "I4/mmm",
                             "R-3m",
                             "P6/mmm",
                             "Pm-3m",
                             "Im-3m",
                             "Fm-3m"):
    centric_info = sgtbx.space_group_info(space_group_symbol)
    non_centric = sgtbx.space_group()
    for i_ltr in range(centric_info.group().n_ltr()):
      for i_smx in range(centric_info.group().n_smx()):
        s = centric_info.group()(i_ltr,0,i_smx)
        non_centric.expand_smx(s)
    assert non_centric.f_inv() == 1
    assert non_centric.order_z() * 2 == centric_info.group().order_z()
    non_centric_info = sgtbx.space_group_info(group=non_centric)
    centric_stats = subgroup_stats(centric_info)
    non_centric_stats = subgroup_stats(non_centric_info)
    assert len(centric_stats.subgroups) >= 2*len(non_centric_stats.subgroups)
    assert centric_stats.n_non_centric >= non_centric_stats.n_non_centric
    assert centric_stats.n_chiral == non_centric_stats.n_chiral
    assert non_centric_stats.n_non_centric == len(non_centric_stats.subgroups)
    assert non_centric_stats.n_non_centric == non_centric_stats.n_chiral
  print("OK")

if (__name__ == "__main__"):
  run()


 *******************************************************************************


 *******************************************************************************
cctbx/regression/tst_sgtbx_tidy_pickling.py
from __future__ import absolute_import, division, print_function

from cctbx import xray
from cctbx import crystal
from cctbx.array_family import flex
try:
  from six.moves import cPickle as pickle
except ImportError:
  import pickle

"""
Test that the spacegroup class retains order of symmetry operations when restored
from pickling. This is done in cctbx_project/cctbx/sgtbx/boost_python/space_group.cpp
by calling make_tidy() in the space_group_wrappers::setstate() function.
"""

def test_spacegroup_tidy_pickling():
  quartz_structure = xray.structure(
    crystal_symmetry=crystal.symmetry(
    unit_cell=(5.01,5.01,5.47,90,90,120),
    space_group_symbol="P6222"),
    scatterers=flex.xray_scatterer(
    [
      xray.scatterer(label="Si", site=(1/2.,1/2.,1/3.), u=0.2),
      xray.scatterer(label="O",  site=(0.197,-0.197,0.83333), u=0)
    ])
  )

  asu_mappings = quartz_structure.asu_mappings(buffer_thickness=2)
  pair_asu_table = crystal.pair_asu_table(asu_mappings=asu_mappings)
  pair_asu_table.add_all_pairs(distance_cutoff=1.7)
  pair_sym_table = pair_asu_table.extract_pair_sym_table()
  new_asu_mappings = quartz_structure.asu_mappings(buffer_thickness=5)
  new_pair_asu_table = crystal.pair_asu_table(asu_mappings=new_asu_mappings)
  new_pair_asu_table.add_pair_sym_table(sym_table=pair_sym_table)
  spg = new_pair_asu_table.asu_mappings().space_group()
  pspg = pickle.loads(pickle.dumps(spg))
  mstr = ""
  pmstr = ""
  for rt in spg.all_ops():
    mstr += rt.r().as_xyz() + "\n"
  for rt in pspg.all_ops():
    pmstr += rt.r().as_xyz() + "\n"
  assert mstr == pmstr


if (__name__ == "__main__"):
  test_spacegroup_tidy_pickling()
  print("OK")


 *******************************************************************************


 *******************************************************************************
cctbx/regression/tst_show_cosets.py
from __future__ import absolute_import, division, print_function
expected_output_test1  = """Left cosets of :
  subgroup  H: P 3
  and group G: P 6 2 2

  Coset number :     0   (all operators from H)

               x,y,z                 h,k,l   Rotation:    1 ; direction:  (0, 0, 0) ; screw/glide:    (0,0,0)
            -y,x-y,z              k,-h-k,l   Rotation:    3 ; direction:  (0, 0, 1) ; screw/glide:    (0,0,0)
           -x+y,-x,z              -h-k,h,l   Rotation:    3 ; direction:  (0, 0, 1) ; screw/glide:    (0,0,0)

  Coset number :     1   (H+coset[1] = P 6)

             -x,-y,z               -h,-k,l   Rotation:    2 ; direction:  (0, 0, 1) ; screw/glide:    (0,0,0)
             x-y,x,z              h+k,-h,l   Rotation:    6 ; direction:  (0, 0, 1) ; screw/glide:    (0,0,0)
            y,-x+y,z              -k,h+k,l   Rotation:    6 ; direction:  (0, 0, 1) ; screw/glide:    (0,0,0)

  Coset number :     2   (H+coset[2] = P 3 2 1)

           x-y,-y,-z             h,-h-k,-l   Rotation:    2 ; direction:  (1, 0, 0) ; screw/glide:    (0,0,0)
          -x,-x+y,-z             -h-k,k,-l   Rotation:    2 ; direction:  (0, 1, 0) ; screw/glide:    (0,0,0)
              y,x,-z                k,h,-l   Rotation:    2 ; direction:  (1, 1, 0) ; screw/glide:    (0,0,0)

  Coset number :     3   (H+coset[3] = P 3 1 2)

            -y,-x,-z              -k,-h,-l   Rotation:    2 ; direction: (-1, 1, 0) ; screw/glide:    (0,0,0)
           -x+y,y,-z             -h,h+k,-l   Rotation:    2 ; direction:  (1, 2, 0) ; screw/glide:    (0,0,0)
            x,x-y,-z             h+k,-k,-l   Rotation:    2 ; direction:  (2, 1, 0) ; screw/glide:    (0,0,0)
"""

expected_output_test2 ="""Coset decomposition not successfull.
Group P 1 2 1 might not be a subgroup of P 3
Sorry.....
"""

class tmp_out:
  def __init__(self):
    self.store = """"""
  def write(self, txt):
    self.store+=txt



from cctbx.sgtbx import show_cosets

def test():
  test1 = tmp_out()
  show_cosets.run( "P3", "P622", out=test1 )
  assert test1.store == expected_output_test1

  test2 = tmp_out()
  show_cosets.run( "P2" , "P3", out=test2)
  assert test2.store == expected_output_test2
  print("OK")

if __name__ == "__main__":
  test()


 *******************************************************************************


 *******************************************************************************
cctbx/regression/tst_space_group_type_tidy_cb_op_t.py
from __future__ import absolute_import, division, print_function
from cctbx import sgtbx
import scitbx.math
from libtbx.utils import format_cpu_times
import sys
from six.moves import range

special = {
  9: 8, 15: 8, 17: 4, 19: 12, 20: 4, 24: 12, 43: 4, 67: 4, 68: 4, 70: 18,
  73: 12, 74: 4, 80: 4, 85: 4, 86: 4, 88: 6, 91: 4, 92: 4, 95: 4, 96: 4,
  98: 4, 109: 4, 110: 4, 122: 4, 125: 4, 126: 4, 129: 4, 130: 4, 133: 4,
  134: 4, 137: 4, 138: 4, 141: 6, 142: 6, 151: 8, 152: 8, 153: 8, 154: 8,
  178: 8, 179: 8, 180: 8, 181: 8, 198: 21, 199: 21, 201: 18, 203: 18,
  205: 9, 206: 21, 210: 12, 212: 21, 213: 21, 214: 21, 220: 21, 222: 18,
  224: 18, 227: 18, 228: 18, 230: 21}

def run(args):
  if ("--full" in args):
    to_do = range(1,230+1)
  elif ("--special" in args):
    to_do = sorted(special.keys())
  else:
    to_do = [75, 151]
  for space_group_number in to_do:
    sgi = sgtbx.space_group_info(number=space_group_number)
    sgi.show_summary(prefix="")
    sys.stdout.flush()
    n_special = 0
    for m in scitbx.math.unimodular_generator(range=1).all():
      cb_op = sgtbx.change_of_basis_op(sgtbx.rt_mx(sgtbx.rot_mx(m,1), 1)) \
        .new_denominators(12, 144)
      cb_sgi = sgi.change_basis(cb_op=cb_op)
      cb_op_ref = cb_sgi.change_of_basis_op_to_reference_setting()
      ref_sgi = cb_sgi.change_basis(cb_op=cb_op_ref)
      assert ref_sgi.group() == sgi.group()
      c = cb_op_ref.c()
      if (c.r().is_unit_mx() and c.t().num() != (0,0,0)):
        n_special += 1
        cb_ref_sgi = sgi.change_basis(cb_op=cb_op_ref)
        print("  cb_op=%s -> %s" % (
          str(cb_op.c()), cb_ref_sgi.type().universal_hermann_mauguin_symbol()))
        sys.stdout.flush()
        # verify that c.t() is not an allowed origin shift
        assert cb_ref_sgi.group() != sgi.group()
    assert special.get(space_group_number, 0) == n_special
  print(format_cpu_times())

if (__name__ == "__main__"):
  run(sys.argv[1:])


 *******************************************************************************


 *******************************************************************************
cctbx/regression/tst_sphericity.py
from __future__ import absolute_import, division, print_function
from scitbx.array_family import flex
import iotbx.pdb
from cctbx import maptbx
from cctbx import adptbx, sgtbx
from libtbx.test_utils import approx_equal
import time

def ru(crystal_symmetry, u_scale=1, u_min=0.1):
  from cctbx import sgtbx
  symbol = crystal_symmetry.space_group().type().lookup_symbol()
  point_group = sgtbx.space_group_info(
    symbol=symbol).group().build_derived_point_group()
  adp_constraints = sgtbx.tensor_rank_2_constraints(
    space_group=point_group,
    reciprocal_space=True)
  u_star = adptbx.u_cart_as_u_star(crystal_symmetry.unit_cell(),
    adptbx.random_u_cart(u_scale=u_scale,u_min=u_min))
  u_indep = adp_constraints.independent_params(all_params=u_star)
  u_star = adp_constraints.all_params(independent_params=u_indep)
  r = flex.sym_mat3_double()
  r.append(adptbx.u_star_as_u_cart(crystal_symmetry.unit_cell(), u_star))
  return r

def run():
  pdb_str1="""
CRYST1   10.000   10.000   10.000  90.00  90.00  90.00 P 1
HETATM    1  C    C      1       5.000   5.000   5.000  1.00  0.00           C
ANISOU    1  C    C      1     1000  10000   5000      0      0      0       C
END
"""
  pdb_str2="""
CRYST1   10.000   15.000   17.000  70.00 110.00 120.00 P 1
HETATM    1  C    C      1       5.000   7.000  -9.000  1.00  0.00           C
ANISOU    1  C    C      1    10000  10000   5000      0      0      0       C
END
"""
  pdb_str3="""
CRYST1   10.000   15.000   17.000  70.00 110.00 120.00 P 1
HETATM    1  C    C      1       5.000   7.000  -9.000  1.00  0.00           C
ANISOU    1  C    C      1    10000  10000  10000      0      0      0       C
END
"""
  pdb_str4="""
CRYST1   10.000   15.000   17.000  70.00 110.00 120.00 P 1
HETATM    1  C    C      1       5.000   7.000  -9.000  1.00  0.00           C
ANISOU    1  C    C      1        0      0      0      0      0      0       C
END
"""
  pdb_str5="""
CRYST1   10.000   15.000   17.000  70.00 110.00 120.00 P 1
HETATM    1  C    C      1       5.000   7.000  -9.000  1.00 20.00           C
END
"""

  pdb_str6="""
CRYST1   10.000   15.000   17.000  70.00 110.00 120.00 P 1
HETATM    1  C    C      1       5.000   7.000   8.000  1.00  0.00           C
ANISOU    1  C    C      1    10000  10000   5000      0      0      0       C
END
"""
  pdb_str7="""
CRYST1   10.000   15.000   17.000  70.00 110.00 120.00 P 1
HETATM    1  C    C      1       0.000   0.000   0.000  1.00  0.00           C
ANISOU    1  C    C      1    10000  10000   5000      0      0      0       C
END
"""
  pdb_str8="""
CRYST1   10.000   10.000   10.000  90.00  90.00  90.00 P 1
HETATM    1  C    C      1       0.000   0.000   0.000  1.00  0.00           C
ANISOU    1  C    C      1     1000  10000   5000      0      0      0       C
END
"""
  pdb_str9="""
CRYST1   10.000   10.000   10.000  90.00  90.00  90.00 P 1
HETATM    1  C    C      1      -9.000   0.000  50.000  1.00  0.00           C
ANISOU    1  C    C      1     1000  10000   5000      0      0      0       C
END
"""
  pdb_str10="""
CRYST1   10.000   15.000   17.000  70.00 110.00 120.00 P 1
HETATM    1  C    C      1      -9.197  10.398  53.561  0.13  0.00           C
ANISOU    1  C    C      1     1000  10000   5000      0      0      0       C
END
"""
  pdb_str11="""
CRYST1   10.000   10.000   10.000  90.00  90.00  90.00 P 1
HETATM    1  C    C      1       0.000   0.000   0.000  0.10  0.00           C
ANISOU    1  C    C      1     1000  10000   5000      0      0      0       C
HETATM    2  C    C      2       5.000   5.000   5.000  1.00  9.00           C
END
"""
  pdb_str12="""
CRYST1   10.000   10.000   10.000  90.00  90.00  90.00 P 1
HETATM    1  C    C      1       5.000   5.000   5.000  1.00 20.00           C
END
"""

  found_two = 0
  for i, pdb_str in enumerate([pdb_str1, pdb_str2, pdb_str3, pdb_str4,
                               pdb_str5, pdb_str6, pdb_str7, pdb_str8,
                               pdb_str9, pdb_str10, pdb_str11, pdb_str12]):
    pdb_inp = iotbx.pdb.input(source_info=None, lines=pdb_str)
    ph = pdb_inp.construct_hierarchy()
    xrs = pdb_inp.xray_structure_simple()
    ph.write_pdb_file(file_name = "m%d.pdb"%i,
      crystal_symmetry=xrs.crystal_symmetry())
    # To try more random adp values:
    #u_cart = ru(crystal_symmetry=xrs.crystal_symmetry(), u_scale=1, u_min=0.01)
    #xrs.set_u_cart(u_cart = u_cart)
    #
    fc = xrs.structure_factors(d_min = 0.5, algorithm = "direct").f_calc()
    fft_map = fc.fft_map(resolution_factor = 0.2)
    fft_map.apply_sigma_scaling()
    map_data = fft_map.real_map_unpadded()
    map_data = map_data.set_selected(map_data<4.0, 0)
    # Calculated anisotropy from ADP: this is exact answer
    a = list(xrs.scatterers().anisotropy(xrs.unit_cell()))[0]
    # Sphericity: main working implementation
    t0=time.time()
    s = maptbx.sphericity(map_data = map_data, unit_cell = xrs.unit_cell(),
      radius = 2.5, sites_frac = xrs.sites_frac())
    if(s.size()==2):
      assert approx_equal(s[1], 1.0, 0.001)
      found_two += 1
    assert approx_equal(a, s[0], 0.1)
    t1=time.time()
    print("#%2d: answer: %5.3f sphericity: %5.3f" % (i+1, a, s[0]))
  #
  assert found_two == 1

if __name__ == "__main__" :
  run()


 *******************************************************************************


 *******************************************************************************
cctbx/regression/tst_statistics_graphs.py
from __future__ import absolute_import, division, print_function
from cctbx import statistics
from cctbx import miller
from cctbx import crystal
from cctbx.array_family import flex
from libtbx.test_utils import approx_equal
from cctbx import adptbx
from cctbx.development import debug_utils
from cctbx.development import random_structure
import sys
from six.moves import range
from six.moves import zip

def exercise_sys_absent_intensity_distribution():
  xs = crystal.symmetry((3,4,5), "F222")
  mi = flex.miller_index(((1,2,3), (1,1,1), (1,2,2), (0,0,4)))
  ms = miller.set(xs, mi)
  data = flex.double((-1,-2,3,4))
  sigmas = flex.double((2,3,4,5))
  f_obs = miller.array(ms, data=data, sigmas=sigmas).set_observation_type_xray_intensity()
  dist = statistics.sys_absent_intensity_distribution(f_obs)
  assert approx_equal(dist.x,(-0.5,0.75))
  assert approx_equal(dist.y,(-1,3))
  assert approx_equal(dist.indices,((1,2,3), (1,2,2)))

def exercise_cumulative_intensity_distribution(space_group_info, anomalous_flag,
             d_min=1.0, reflections_per_bin=200, n_bins=10, verbose=0):
  elements = ("N", "C", "C", "O") * 5
  structure_factors = random_structure.xray_structure(
    space_group_info,
    elements=elements,
    volume_per_atom=50.,
    min_distance=1.5,
    general_positions_only=True,
    use_u_aniso=False,
    u_iso=adptbx.b_as_u(10)
    ).structure_factors(
        anomalous_flag=anomalous_flag, d_min=d_min, algorithm="direct")
  if (0 or verbose):
    structure_factors.xray_structure().show_summary()
  for n_bins in [10,20]:
    f_calc = abs(structure_factors.f_calc())
    f_calc.setup_binner(
      auto_binning=True,
      reflections_per_bin=reflections_per_bin,
      n_bins=n_bins)
    f_obs = miller.array(
      miller_set=f_calc,
      data=f_calc.data()).set_observation_type_xray_amplitude()
    f_obs.use_binner_of(f_calc)
    f_obs_sq = f_obs.f_as_f_sq()
    f_obs_sq.use_binner_of(f_obs)
    for ma in (f_obs,f_obs_sq):
      if ma.is_xray_amplitude_array():
        dist = statistics.cumulative_intensity_distribution(f_obs=ma)
      else:
        dist = statistics.cumulative_intensity_distribution(f_obs_sq=ma)
      n_bins_used = f_obs.binner().n_bins_used()
      x_index = {}
      x_index[0.1] = n_bins_used//10
      x_index[0.5] = n_bins_used//2
      x_index[0.9] = 9*n_bins_used//10
      if space_group_info.group().is_centric():
        assert 0.23 < dist.y[x_index[0.1]] < 0.32
        assert 0.49 < dist.y[x_index[0.5]] < 0.57
        assert 0.65 < dist.y[x_index[0.9]] < 0.70
      else:
        assert 0.08 < dist.y[x_index[0.1]] < 0.21
        assert 0.37 < dist.y[x_index[0.5]] < 0.49
        assert 0.57 < dist.y[x_index[0.9]] < 0.65

class cumulative_intensity_distribution_python(object):
  # Prototype python version, superseded by faster C++ implementation
  # As described by  Howells, Phillips and Rogers, Acta Cryst. (1950). 3, 210

  def __init__(self, f_obs):
    self.info = f_obs.info()
    n_bins_used = f_obs.binner().n_bins_used()
    data = dict(zip(["%.2f" %(i/float(n_bins_used))
                     for i in range(0,n_bins_used)], [0]*n_bins_used))
    f_obs_sq = f_obs.f_as_f_sq()
    f_obs_sq.use_binner_of(f_obs)
    n_reflections = 0
    self.n_bins = f_obs_sq.binner().n_bins_all()
    self.mean_f_obs_sq = f_obs_sq.mean(use_binning=True)
    for intensity, d_spacing, indices in zip(
      f_obs_sq.data(), f_obs_sq.d_spacings().data(), f_obs_sq.indices()):
      n_reflections += 1
      i_over_mean_i = intensity/self._get_mean_f_obs_sq(d_spacing)
      rounded_i_over_mean_i = round(i_over_mean_i, 2)
      if i_over_mean_i > rounded_i_over_mean_i:
        rounded_i_over_mean_i += 0.01
      for i in range(n_bins_used,int(rounded_i_over_mean_i*n_bins_used)-1,-1):
        key = "%.2f" %(i/n_bins_used)
        if key in data:
          data[key] += 1
        else:
          continue

    xy_data = list(data.items())
    xy_data.sort()
    self.x = [float(x) for x, y in xy_data]
    self.y = [y/n_reflections for x, y in xy_data]

  def _get_mean_f_obs_sq(self, d_spacing):
    for n_bin in range(0,self.n_bins):
      if d_spacing >= self.mean_f_obs_sq.binner.bin_d_range(n_bin)[1]:
        break
    return self.mean_f_obs_sq.data[n_bin]

  def xy_plot_info(self):
    r = empty()
    r.title = "Cumulative Intensity Distribution"
    if (self.info != 0):
      r.title += ": " + str(self.info)
    r.x = self.x
    r.y = self.y
    r.xLegend = "z(%)"
    r.yLegend = "N(z)(%)"
    return r

def run_call_back(flags, space_group_info):
  for anomalous_flag in (False, True):
    exercise_cumulative_intensity_distribution(space_group_info, anomalous_flag, verbose=flags.Verbose)

def run():
  exercise_sys_absent_intensity_distribution()
  debug_utils.parse_options_loop_space_groups(sys.argv[1:], run_call_back)
  print("OK")

if __name__ == '__main__':
  run()


 *******************************************************************************


 *******************************************************************************
cctbx/regression/tst_triplet_generator.py
from __future__ import absolute_import, division, print_function
from libtbx.test_utils import approx_equal
from cctbx import dmtbx
from cctbx import maptbx
from cctbx import miller
from scitbx import fftpack
from libtbx import complex_math
import scitbx.math
from cctbx.array_family import flex
from cctbx.development import random_structure
from cctbx.development import debug_utils
import random
import math
import sys
from six.moves import range

def direct_space_squaring(start, selection_fixed):
  map_gridding = miller.index_span(
    miller.set.expand_to_p1(start).indices()).map_grid()
  if (selection_fixed is None):
    fixed = start
    var = start
  else:
    fixed = start.select(selection_fixed)
    var = start.select(~selection_fixed)
  rfft = fftpack.real_to_complex_3d([n*3//2 for n in map_gridding])
  conjugate_flag = True
  structure_factor_map = maptbx.structure_factors.to_map(
    space_group=fixed.space_group(),
    anomalous_flag=fixed.anomalous_flag(),
    miller_indices=fixed.indices(),
    structure_factors=fixed.data(),
    n_real=rfft.n_real(),
    map_grid=flex.grid(rfft.n_complex()),
    conjugate_flag=conjugate_flag)
  real_map = rfft.backward(structure_factor_map.complex_map())
  squared_map = flex.pow2(real_map)
  squared_sf_map = rfft.forward(squared_map)
  allow_miller_indices_outside_map = False
  from_map = maptbx.structure_factors.from_map(
    anomalous_flag=var.anomalous_flag(),
    miller_indices=var.indices(),
    complex_map=squared_sf_map,
    conjugate_flag=conjugate_flag,
    allow_miller_indices_outside_map=allow_miller_indices_outside_map)
  if (selection_fixed is None):
    return from_map.data()
  result = start.data().deep_copy()
  result.set_selected(~selection_fixed, from_map.data())
  assert result.select(selection_fixed).all_eq(fixed.data())
  return result

def reciprocal_space_squaring(start, selection_fixed, verbose):
  tprs = dmtbx.triplet_generator(miller_set=start)
  if (0 or verbose):
    for ih in range(start.indices()[:1].size()):
      for relation in tprs.relations_for(ih):
        print(relation.format(start.indices(), ih), end=' ')
        if (not relation.is_sigma_2(ih)):
          print("not sigma-2", end=' ')
        print()
  amplitudes = abs(start).data()
  if (selection_fixed is not None):
    amplitudes.set_selected(~selection_fixed, 0)
  input_phases = flex.arg(start.data())
  result = tprs.apply_tangent_formula(
    amplitudes=amplitudes,
    phases_rad=input_phases,
    selection_fixed=selection_fixed,
    use_fixed_only=selection_fixed is not None)
  if (selection_fixed is not None):
    assert result.select(selection_fixed).all_eq(
      input_phases.select(selection_fixed))
  return result

def exercise_truncate(q_large):
  tprs_full = dmtbx.triplet_generator(
    miller_set=q_large,
    discard_weights=True)
  tprs = dmtbx.triplet_generator(
    miller_set=q_large,
    amplitudes=q_large.data(),
    max_relations_per_reflection=0,
    discard_weights=True)
  assert tprs.n_relations().all_eq(tprs_full.n_relations())
  for n in (1,10,100,1000):
    tprs = dmtbx.triplet_generator(
      miller_set=q_large,
      amplitudes=q_large.data(),
      max_relations_per_reflection=n,
      discard_weights=True)
    assert (tprs.n_relations() >= n).all_eq(tprs.n_relations() == n)
  n = 3
  tprs = dmtbx.triplet_generator(
    miller_set=q_large,
    amplitudes=q_large.data(),
    max_relations_per_reflection=n,
    discard_weights=True)
  n_rel_full = tprs_full.n_relations()
  n_rel = tprs.n_relations()
  amp = q_large.data()
  for ih in range(q_large.indices().size()):
    if (n_rel[ih] == n_rel_full[ih]): continue
    aa_full = flex.double()
    for relation in tprs_full.relations_for(ih):
      aa_full.append(amp[relation.ik()] * amp[relation.ihmk()])
    aa = flex.double()
    for relation in tprs.relations_for(ih):
      aa.append(amp[relation.ik()] * amp[relation.ihmk()])
    aa_full = aa_full.select(flex.sort_permutation(data=aa_full, reverse=True))
    assert approx_equal(aa_full[:n], aa)

def exercise(space_group_info, n_scatterers=8, d_min=2, verbose=0,
             e_min=1.5):
  structure = random_structure.xray_structure(
    space_group_info,
    elements=["const"]*n_scatterers,
    volume_per_atom=200,
    min_distance=3.,
    general_positions_only=True,
    u_iso=0.0)
  if (0 or verbose):
    structure.show_summary().show_scatterers()
  f_calc = structure.structure_factors(
    d_min=d_min, anomalous_flag=False).f_calc()
  f_obs = abs(f_calc)
  q_obs = miller.array(
    miller_set=f_obs,
    data=f_obs.data()
        / math.sqrt(f_obs.space_group().order_p() * n_scatterers)
        / f_obs.space_group().n_ltr())
  q_obs = q_obs.sort(by_value="abs")
  q_obs.setup_binner(auto_binning=True)
  n_obs = q_obs.quasi_normalize_structure_factors()
  r = flex.linear_regression(q_obs.data(), n_obs.data())
  if (0 or verbose):
    r.show_summary()
  assert r.is_well_defined()
  assert abs(r.y_intercept()) < 0.1
  assert abs(r.slope() - 1) < 0.2
  q_large = q_obs.select(
    q_obs.quasi_normalized_as_normalized().data() > e_min)
  if (0 or verbose):
    print("Number of e-values > %.6g: %d" % (e_min, q_large.size()))
  other_structure = random_structure.xray_structure(
    space_group_info,
    elements=["const"]*n_scatterers,
    volume_per_atom=200,
    min_distance=3.,
    general_positions_only=True,
    u_iso=0.0)
  assert other_structure.unit_cell().is_similar_to(structure.unit_cell())
  q_calc = q_large.structure_factors_from_scatterers(
    other_structure, algorithm="direct").f_calc()
  start = q_large.phase_transfer(q_calc.data())
  for selection_fixed in (
        None,
        flex.double([random.random() for i in range(start.size())]) < 0.4):
    from_map_data = direct_space_squaring(start, selection_fixed)
    direct_space_result = start.phase_transfer(phase_source=from_map_data)
    new_phases = reciprocal_space_squaring(start, selection_fixed, verbose)
    reciprocal_space_result = start.phase_transfer(
      phase_source=flex.polar(1,new_phases))
    mwpe = direct_space_result.mean_weighted_phase_error(
      reciprocal_space_result)
    if (0 or verbose):
      print("mwpe: %.2f" % mwpe, start.space_group_info())
    for i,h in enumerate(direct_space_result.indices()):
      amp_d,phi_d = complex_math.abs_arg(
        direct_space_result.data()[i], deg=True)
      amp_r,phi_r = complex_math.abs_arg(
        reciprocal_space_result.data()[i],deg=True)
      phase_err = scitbx.math.phase_error(phi_d, phi_r, deg=True)
      assert phase_err < 1.0 or abs(from_map_data[i]) < 1.e-6
  exercise_truncate(q_large)

def run_call_back(flags, space_group_info):
  exercise(space_group_info, verbose=flags.Verbose)

def run():
  debug_utils.parse_options_loop_space_groups(sys.argv[1:], run_call_back)

if (__name__ == "__main__"):
  run()


 *******************************************************************************


 *******************************************************************************
cctbx/regression/tst_twin_target.py
from __future__ import absolute_import, division, print_function
from cctbx.array_family import flex
from cctbx import crystal
from cctbx import miller
from cctbx import xray
from cctbx import sgtbx
from cctbx import uctbx
from cctbx.development import random_structure as rs
from scitbx import differential_evolution as de
import scitbx.lbfgs
from libtbx.test_utils import approx_equal
from libtbx.utils import format_cpu_times
import random
import math
from six.moves import range
from six.moves import zip

random.seed(0)
flex.set_random_seed(0)

def tst_ls_on_i():
  tmp = rs.xray_structure(sgtbx.space_group_info( 'P4' ),
                          elements=['C']*310,
                          n_scatterers=310)

  sfs = tmp.structure_factors( False, 3.5  ).f_calc()
  f_mod = xray.f_model_core_data( hkl = sfs.indices(),
                        f_atoms= sfs.data(),
                        f_mask = sfs.data(),
                        unit_cell = sfs.unit_cell(),
                        k_overall=1.0,
                        u_star=(0,0,0,0,0,0),
                        k_sol=0.0,
                        u_sol=0.0,
                        f_part=sfs.data(),
                        k_part=0.0,
                        u_part=0.0 )

  target_evaluator = xray.least_squares_hemihedral_twinning_on_i(
    hkl_obs=sfs.indices(),
    i_obs=( flex.abs(sfs.data())*flex.abs(sfs.data()))*1.0,
    w_obs=None,
    hkl_calc=sfs.indices(),
    space_group=sfs.space_group(),
    anomalous_flag=False,
    alpha=0.0,
    twin_law=[-1,0,0, 0,1,0, 0,0,-1]
    )

  target = target_evaluator.target( sfs.data() )
  # The target vaslue should be zero
  assert approx_equal( target, 0, eps=1e-6)

  # the derivatives as well
  derivs_complex = target_evaluator.d_target_d_fmodel( sfs.data()  )
  derivs_ab = target_evaluator.d_target_d_ab( sfs.data()  )
  for cmplx,da,db in zip(derivs_complex,
                         derivs_ab[0],
                         derivs_ab[1]):
    assert approx_equal( cmplx.real, da, eps=1e-5)
    assert approx_equal( cmplx.imag, db, eps=1e-5)

  for alpha in flex.double(range(50))/100.0:
    #----------------------------------------------------------------
    # use fin diffs to check the derivatives to a and b
    old_target_evaluator = xray.least_squares_hemihedral_twinning_on_i(
      hkl_obs=sfs.indices(),
      i_obs=( flex.abs(sfs.data())*flex.abs(sfs.data()))*1.1,
      w_obs=None,
      hkl_calc=sfs.indices(),
      space_group=sfs.space_group(),
      anomalous_flag=False,
      alpha=alpha,
      twin_law=[-1,0,0, 0,1,0, 0,0,-1]
      )
    old_target_value = old_target_evaluator.target( sfs.data() )
    old_derivs = old_target_evaluator.d_target_d_ab( sfs.data() )

    new_data =  sfs.data()
    h=0.0001

    for N_test in range(sfs.data().size() ):
      ori = complex( sfs.data()[N_test] )
      #print "----------------"
      #print alpha
      #print sfs.indices()[N_test]
      #print sfs.data()[N_test]
      new_data[N_test] = ori+complex(h,0)
      new_target_value = old_target_evaluator.target( new_data )
      fdif_real = float((new_target_value-old_target_value)/h)
      new_data[N_test] = ori+complex(0,h)
      new_target_value = old_target_evaluator.target( new_data )
      fdif_imag = float( (new_target_value-old_target_value)/h )
      # only use 'large' first derivatives.
      if old_derivs[0][N_test]>0:
        #print "real", N_test, fdif_real,old_derivs[0][N_test], (fdif_real-old_derivs[0][N_test])/old_derivs[0][N_test]
        if old_derivs[0][N_test]>2500:
          assert approx_equal( (fdif_real-old_derivs[0][N_test])/fdif_real,0, eps=1e-2)
      if old_derivs[1][N_test]>0:
        #print  "Imag", N_test, fdif_imag,old_derivs[1][N_test], (fdif_imag-old_derivs[1][N_test])/old_derivs[1][N_test]
        if old_derivs[1][N_test]>2500:
          assert approx_equal( (fdif_imag-old_derivs[1][N_test])/fdif_imag,0, eps=1e-2)
      new_data[N_test] = ori

  #-------------------------------------
  # use fin diffs to test derivatives wrst alpha, the twin fraction
  h=0.0000000001

  target_evaluator = xray.least_squares_hemihedral_twinning_on_i(
    hkl_obs=sfs.indices(),
    i_obs=( flex.abs(sfs.data())*flex.abs(sfs.data()))*1.0,
    w_obs=None,
    hkl_calc=sfs.indices(),
    space_group=sfs.space_group(),
    anomalous_flag=False,
    alpha=0,
    twin_law=[-1,0,0, 0,1,0, 0,0,-1]
    )

  tst_alpha = [0.1, 0.2, 0.3, 0.4, 0.5]

  for ii in tst_alpha:
    target_evaluator.alpha(ii)
    old_target = target_evaluator.target( sfs.data()*1.0 )
    target_evaluator.alpha( ii + h )
    new_target = target_evaluator.target( sfs.data()*1.0 )
    fd = (new_target-old_target)/h
    target_evaluator.alpha(ii)
    an = target_evaluator.d_target_d_alpha(sfs.data()*1.0)
    assert approx_equal( fd/an , 1.0, eps=1e-2 )






def tst_ls_on_f():
  tmp = rs.xray_structure(sgtbx.space_group_info( 'P4' ),
                          elements=['C']*310,
                          n_scatterers=310)

  sfs = tmp.structure_factors( False, 3.5  ).f_calc()
  f_mod = xray.f_model_core_data( hkl = sfs.indices(),
                        f_atoms= sfs.data(),
                        f_mask = sfs.data(),
                        unit_cell = sfs.unit_cell(),
                        k_overall=1.0,
                        u_star=(0,0,0,0,0,0),
                        k_sol=0.0,
                        u_sol=0.0,
                        f_part=sfs.data(),
                        k_part=0.0,
                        u_part=0.0 )

  target_evaluator = xray.least_squares_hemihedral_twinning_on_f(
    hkl_obs=sfs.indices(),
    f_obs=flex.sqrt( flex.abs(sfs.data())*flex.abs(sfs.data()))*1.0,
    w_obs=None,
    hkl_calc=sfs.indices(),
    space_group=sfs.space_group(),
    anomalous_flag=False,
    alpha=0.0,
    twin_law=[-1,0,0, 0,1,0, 0,0,-1]
    )

  target = target_evaluator.target( sfs.data() )
  # The target vaslue should be zero
  assert approx_equal( target, 0, eps=1e-6)

  # the derivatives as well
  derivs_complex = target_evaluator.d_target_d_fmodel( sfs.data()  )
  derivs_ab = target_evaluator.d_target_d_ab( sfs.data()  )
  for cmplx,da,db in zip(derivs_complex,
                         derivs_ab[0],
                         derivs_ab[1]):
    assert approx_equal( cmplx.real, da, eps=1e-5)
    assert approx_equal( cmplx.imag, -db, eps=1e-5)

  for alpha in flex.double(range(50))/100.0:
    #----------------------------------------------------------------
    # use fin diffs to check the derivatives to a and b
    old_target_evaluator = xray.least_squares_hemihedral_twinning_on_f(
      hkl_obs=sfs.indices(),
      f_obs=flex.sqrt( flex.abs(sfs.data())*flex.abs(sfs.data()))*1.1,
      w_obs=None,
      hkl_calc=sfs.indices(),
      space_group=sfs.space_group(),
      anomalous_flag=False,
      alpha=alpha,
      twin_law=[-1,0,0, 0,1,0, 0,0,-1]
      )
    old_target_value = old_target_evaluator.target( sfs.data() )
    old_derivs = old_target_evaluator.d_target_d_ab( sfs.data() )

    new_data =  sfs.data()
    h=0.0001
    checked=0
    for N_test in range(sfs.data().size() ):
      ori = complex( sfs.data()[N_test] )
      #print "----------------"
      #print alpha
      #print sfs.indices()[N_test]
      #print sfs.data()[N_test]
      new_data[N_test] = ori+complex(h,0)
      new_target_value = old_target_evaluator.target( new_data )
      fdif_real = float((new_target_value-old_target_value)/h)
      new_data[N_test] = ori+complex(0,h)
      new_target_value = old_target_evaluator.target( new_data )
      fdif_imag = float( (new_target_value-old_target_value)/h )
      # only use 'large' first derivative
      if 1: #old_derivs[0][N_test]>0:
        #print "real", N_test, fdif_real,old_derivs[0][N_test], (fdif_real-old_derivs[0][N_test])/old_derivs[0][N_test]
        if old_derivs[0][N_test]>1:
          checked+=1
          assert approx_equal( (fdif_real-old_derivs[0][N_test])/fdif_real,0, eps=1e-3)
      if abs(old_derivs[1][N_test])>0:
        #print  "Imag", N_test, fdif_imag,old_derivs[1][N_test], (fdif_imag-old_derivs[1][N_test])/old_derivs[1][N_test]
        if old_derivs[1][N_test]>1:
          checked+=1
          assert approx_equal( (fdif_imag-old_derivs[1][N_test])/fdif_imag,0, eps=1e-3)
      new_data[N_test] = ori
    assert checked>0
  #-------------------------------------
  # use fin diffs to test derivatives wrst alpha, the twin fraction
  h=0.00001

  target_evaluator = xray.least_squares_hemihedral_twinning_on_f(
    hkl_obs=sfs.indices(),
    f_obs=flex.sqrt( flex.abs(sfs.data())*flex.abs(sfs.data()))*1.0,
    w_obs=None,
    hkl_calc=sfs.indices(),
    space_group=sfs.space_group(),
    anomalous_flag=False,
    alpha=0,
    twin_law=[-1,0,0, 0,1,0, 0,0,-1]
    )

  tst_alpha = [0.1, 0.2, 0.3, 0.4, 0.5]

  for ii in tst_alpha:
    target_evaluator.alpha(ii)
    old_target = target_evaluator.target( sfs.data()*1.0 )
    target_evaluator.alpha( ii + h )
    new_target = target_evaluator.target( sfs.data()*1.0 )
    fd = (new_target-old_target)/h
    target_evaluator.alpha(ii)
    an = target_evaluator.d_target_d_alpha(sfs.data()*1.0)
    assert approx_equal( fd/an , 1.0, eps=1e-2 )


class find_max(object):
  def __init__(self,
               tot):
    self.to=tot
    self.n=2
    self.x=[]
    self.domain= [ (0,5), (0,5) ]
    self.eps=1e-16
    self.optim =  de.differential_evolution_optimizer(
      self,
      population_size=100,
      f=0.3,
      cr=0.9,
      n_cross=1,
      show_progress=True,
      show_progress_nth_cycle=1,eps=1e-12)


  def print_status(self, mean, min, best,count):
    None
    #print count, " \t:::  ", mean, min, list(best), list(
    #  self.to.d_log_p_d_f( best[0],best[1] ) )


  def target(self, vector):
    f1=vector[0]
    if f1<self.eps:
      f1=self.eps

    f2=vector[1]
    if f2<self.eps:
      f2=self.eps

    return -self.to.log_p(f1,f2)


class minim(object):
  def __init__(self,
               tot, fm1, fm2):
    self.tot=tot
    self.x = flex.double([fm1,fm2])
    scitbx.lbfgs.run(target_evaluator=self)

  def g(self,f1,f2,h=0.00001):
    fo = self.tot.log_p( f1, f2 )
    fp1= self.tot.log_p( f1+h, f2 )
    fp2= self.tot.log_p( f1, f2+h )
    tmp = [fp1-fo, fp2-fo]
    tmp = flex.double( tmp )/h
    return tmp

  def compute_functional_and_gradients(self):
    f = self.tot.log_p( self.x[0], self.x[1] )
    g = self.tot.d_log_p_d_f( self.x[0], self.x[1] )
    g1= self.g(self.x[0], self.x[1] )
    # test gradients wrst fin diffs
    div = int(math.log(abs(g[0])))
    if div<0:
      div=0
    div = math.exp(div)
    if div<1e5: # if this divisor is very large, we have numerical issues .....
      assert approx_equal( g[0]/div, g1[0]/div, eps=5e-1)

    div = int(math.log(abs(g[1])))
    if div<0:
      div=0
    div = math.exp(div)
    if div<1e5:
      assert approx_equal( g[1]/div, g1[1]/div, eps=5e-1)
    #print list(g), list(g1)
    return -f,-flex.double(g)



def tst_snd_der(tot, f1, f2 , h=0.01):
  # see AMS55, 25.3.22 and 25.3.26
  #
  snd_der = tot.dd_log_p_dd_f(f1,f2)
  tmp0 = tot.log_p( f1,   f2   )
  tmp1 = tot.log_p( f1-h, f2   )
  tmp2 = tot.log_p( f1+h, f2   )

  ddf1 = (tmp1-2.0*tmp0 + tmp2)/(h*h)

  tmp0 = tot.log_p( f1,   f2   )
  tmp1 = tot.log_p( f1, f2-h   )
  tmp2 = tot.log_p( f1, f2+h   )

  ddf2 = (tmp1-2.0*tmp0+tmp2)/(h*h)

  div = int(math.log(abs( snd_der[0] )))
  if div<0:
    div=0
  div = math.exp(div)
  assert approx_equal( ddf1/div, snd_der[0]/div, eps=5e-2 )

  div = int(math.log(abs( snd_der[1] )))
  if div<0:
    div=0
  div = math.exp(div)
  assert approx_equal( ddf2/div, snd_der[1]/div, eps=5e-2 )

  tmp0 = tot.log_p( f1-h,   f2-h )
  tmp1 = tot.log_p( f1-h,   f2+h )
  tmp2 = tot.log_p( f1+h,   f2-h )
  tmp3 = tot.log_p( f1+h,   f2+h )

  tmp = (tmp3-tmp2-tmp1+tmp0)
  tmp = tmp/(h*h*4.0)

  div = int(math.log(abs( snd_der[2] )))
  if div<0:
    div=0
  div = math.exp(div)
  assert approx_equal( tmp/div, snd_der[2]/div, eps=5e-2 )


def tst_integration(twin_lik, range_value=7 ):
  #first find the maximum
  tmp_1_lbfgs = minim( twin_lik, 1, 1 )
  fm1=tmp_1_lbfgs.x[0]
  fm2=tmp_1_lbfgs.x[1]
  snd_der = twin_lik.dd_log_p_dd_f(fm1, fm2)
  is11 = snd_der[0]
  is22 = snd_der[1]
  is12 = snd_der[2]
  det = is11*is22-is12*is12
  s11= is22/det
  s22= is11/det
  s12= -is12/det
  s1= math.sqrt( abs(s11)*2.0 )
  s2= math.sqrt( abs(s22)*2.0 )
  quad_value = twin_lik.num_integrate(fm1, s1, fm2, s2, range_value)
  laplace_value= twin_lik.laplace_integrate(fm1,fm2)
  assert approx_equal(quad_value, laplace_value,eps=5e-2)
  #print "--->", quad_value, laplace_value, 100*(quad_value-laplace_value)/laplace_value


def plot_function(twin_lik, range_value=7):
  tmp_1_lbfgs = minim( twin_lik, 1, 1 )
  fm1=tmp_1_lbfgs.x[0]
  fm2=tmp_1_lbfgs.x[1]
  snd_der = twin_lik.dd_log_p_dd_f(fm1, fm2)
  is11 = snd_der[0]
  is22 = snd_der[1]
  is12 = snd_der[2]
  det = is11*is22-is12*is12
  s11= is22/det
  s22= is11/det
  s12= -is12/det
  s1= math.sqrt( abs(s11)*2.0 )
  s2= math.sqrt( abs(s22)*2.0 )
  for ii in range(-25,26):
    for jj in range(-25,26):
      x=range_value*ii/25.0 + fm1
      y=range_value*jj/25.0 + fm2
      print(x,y, twin_lik.log_p(x,y)-twin_lik.log_p(fm1,fm2))

def tst_single_likelihood(centric=False,
                          twin_fraction=0.1,
                          sigmaa=0.7,
                          plot=False):
  io1=0.6
  io2=0.6
  so1=1.0/100.0
  so2=1.0/100.0
  fc1=0.3
  fc2=0.3
  a  =sigmaa
  b  =1.0-a*a
  centric=centric
  tf=twin_fraction
  tmp_1 = xray.single_twin_likelihood(io1,so1,io2,so2,
                                      fc1,fc2,1.0,1.0,
                                      centric,centric,
                                      a,b,
                                      tf, 90)
  tmp_1_de = find_max( tmp_1 )

  tmp_1_lbfgs = minim( tmp_1 ,tmp_1_de.x[0], tmp_1_de.x[1] )
  #Check if similar optimia are found
  #assert approx_equal( tmp_1_de.x[0], tmp_1_lbfgs.x[0], eps=5e-1 )
  #assert approx_equal( tmp_1_de.x[1], tmp_1_lbfgs.x[1], eps=5e-1 )

  #test second derivatives
  tst_snd_der(tmp_1, 3.0, 2.0 )
  tst_snd_der(tmp_1, 2.0, 3.0 )

  #test the integration
  tst_integration( tmp_1 )
  if plot:
    plot_function( tmp_1 )


def tst_twin_completion():
  uc = uctbx.unit_cell( "40,40,70,90,90,90" )
  xs = crystal.symmetry( unit_cell=uc, space_group="P1" )
  miller_set = miller.build_set( crystal_symmetry=xs,
                                 anomalous_flag=False,
                                 d_min=3.0 ).map_to_asu()
  select = flex.bool( miller_set.indices().size(), True )
  select[300]=False
  miller_set_mod = miller_set.select( select )
  # make sure we threw away a reflection
  assert not miller_set_mod.indices().all_eq(  miller_set.indices() )
  checker = xray.twin_completion(
    miller_set_mod.indices(),
    xs.space_group(),
    False,
    [0,1,0,1,0,0,0,0,-1]
    )
  new_hkl = checker.twin_complete()
  miller_set_mod = miller_set_mod.customized_copy(
    indices=new_hkl)
  miller_set_mod = miller_set_mod.map_to_asu()
  a,b = miller_set_mod.common_sets(  miller_set )
  assert  a.indices().size() == miller_set_mod.indices().size()
  assert  a.indices().size() == miller_set.indices().size()
  assert  miller_set_mod.is_unique_set_under_symmetry()

  checker = xray.twin_completion(
    miller_set.indices(),
    xs.space_group(),
    False,
    [0,1,0,1,0,0,0,0,-1]
    )

  basic_flags = miller_set.generate_r_free_flags_basic()
  lattice_flags = miller_set.generate_r_free_flags_on_lattice_symmetry()

  assert not checker.check_free_flags( basic_flags.data() ) # this should give False
  assert checker.check_free_flags( lattice_flags.data() )   # this should give True

  selection_array = checker.get_free_model_selection( lattice_flags.indices(), lattice_flags.data() )
  assert selection_array.all_eq( lattice_flags.data()  )


def tst_detwin():
  tmp = rs.xray_structure(sgtbx.space_group_info( 'P4' ),
                          elements=['C']*310,
                          n_scatterers=310)

  sfs = abs( tmp.structure_factors( False, 2.5  ).f_calc() )
  tmp_detwin = xray.hemihedral_detwinner(
     hkl_obs = sfs.indices() ,
     hkl_calc= sfs.indices(),
     space_group = sfs.space_group(),
     anomalous_flag = False,
     twin_law = [-1,0,0,  0,1,0,  0,0,-1] )#"-h,k,-l" )

  sfs = sfs.f_as_f_sq()

  tf = [0.1,0.2,0.3,0.4,0.49]
  for t in tf:
    i,s = tmp_detwin.twin_with_twin_fraction( i_obs = sfs.data(),
                                              sigma_obs = sfs.sigmas(),
                                              twin_fraction = t )
    diff = sfs.data() - i
    diff = flex.sum( flex.abs(diff) )
    assert diff>1e-3
    #check what happen when no sigmas ae passed in
    dti,dts = tmp_detwin.detwin_with_twin_fraction( i_obs = i,
                                                    sigma_obs = None,
                                                    twin_fraction= t )


    dti,dts = tmp_detwin.detwin_with_twin_fraction( i_obs = i,
                                                    sigma_obs = s,
                                                    twin_fraction= t )
    diff = sfs.data() - dti
    diff = flex.sum( flex.abs(diff) ) # / flex.sum( sfs.data() )
    assert approx_equal( diff, 0, eps=1e-5 )
    permut = tmp_detwin.obs_to_twin_obs()
    ind = range( permut.size() )
    for ii, jj, kk, pp, mm  in zip( sfs.data(), i, dti, ind, permut ):
      no = (1-t)*sfs.data()[pp] + t*sfs.data()[mm]
      assert approx_equal( jj-no, 0, eps=1e-5)
      assert approx_equal( ii-kk, 0, eps=1e-5)
      #print sfs.indices()[pp], sfs.indices()[ mm ] , ii, jj, kk, pp,mm, jj-no


def run():
  tst_detwin()
  tst_twin_completion()

  tst_ls_on_i()
  tst_ls_on_f()

  tst_single_likelihood(True,0.15,0.0)
  tst_single_likelihood(True,0.15,0.1)
  tst_single_likelihood(True,0.15,0.4)
  tst_single_likelihood(True,0.15,0.6)
  tst_single_likelihood(True,0.15,0.8)

  tst_single_likelihood(True,0.25,0.0)
  tst_single_likelihood(True,0.25,0.1)
  tst_single_likelihood(True,0.25,0.4)
  tst_single_likelihood(True,0.25,0.6)
  tst_single_likelihood(True,0.25,0.8)

  tst_single_likelihood(True,0.40,0.0)
  tst_single_likelihood(True,0.40,0.1)
  tst_single_likelihood(True,0.40,0.4)
  tst_single_likelihood(True,0.40,0.6)
  tst_single_likelihood(True,0.40,0.8)

  tst_single_likelihood(True,0.44,0.0)
  tst_single_likelihood(True,0.44,0.1)
  tst_single_likelihood(True,0.44,0.4)
  tst_single_likelihood(True,0.44,0.6)
  tst_single_likelihood(True,0.44,0.8)

  tst_single_likelihood(False,0.15,0.0)
  tst_single_likelihood(False,0.15,0.1)
  tst_single_likelihood(False,0.15,0.4)
  tst_single_likelihood(False,0.15,0.6)
  tst_single_likelihood(False,0.15,0.8)

  tst_single_likelihood(False,0.25,0.0)
  tst_single_likelihood(False,0.25,0.1)
  tst_single_likelihood(False,0.25,0.4)
  tst_single_likelihood(False,0.25,0.6)
  tst_single_likelihood(False,0.25,0.8)

  tst_single_likelihood(False,0.40,0.0)
  tst_single_likelihood(False,0.40,0.1)
  tst_single_likelihood(False,0.40,0.4)
  tst_single_likelihood(False,0.40,0.6)
  tst_single_likelihood(False,0.40,0.8)

  tst_single_likelihood(False,0.44,0.0)
  tst_single_likelihood(False,0.44,0.1)
  tst_single_likelihood(False,0.44,0.4)
  tst_single_likelihood(False,0.44,0.6)
  tst_single_likelihood(False,0.44,0.8)

if (__name__ == "__main__"):
  run()
  print(format_cpu_times())


 *******************************************************************************


 *******************************************************************************
cctbx/regression/tst_wavelength_units.py
from __future__ import absolute_import, division, print_function
from libtbx import easy_run
from libtbx.test_utils import assert_lines_in_text

def exercise_1():
  fb = easy_run.fully_buffered("cctbx.wavelength_units")
  assert_lines_in_text('\n'.join(fb.stderr_lines), "Usage: cctbx.wavelength_units 1A|1keV [...]")

  fb = easy_run.fully_buffered("cctbx.wavelength_units 2.3a")
  assert_lines_in_text('\n'.join(fb.stdout_lines), "2.30000 A = 5.39062 keV")

  fb = easy_run.fully_buffered("cctbx.wavelength_units 9.8kev")
  assert_lines_in_text('\n'.join(fb.stdout_lines), "1.26514 A = 9.80000 keV")

if (__name__ == "__main__"):
  exercise_1()
  print("OK")


 *******************************************************************************


 *******************************************************************************
cctbx/regression/tst_web_change_basis.py
from __future__ import absolute_import, division, print_function
def exercise():
  from cctbx.web import change_basis
  from libtbx.utils import Sorry
  from libtbx.test_utils import Exception_expected
  def check(string, expected):
    rt = change_basis.p_from_string(string)
    ex = change_basis.p_from_string(expected)
    assert rt.r == ex.r
    assert rt.t == ex.t
  check("", "a,b,c")
  check("a,b,c", "a,b,c")
  check("{{1, 0, 0}, {0, 1, 0}, {0, 0, 1}}", "a,b,c")
  check("2, 0, 0, 0, 2, 0, 0, 0, 2", "2a,2b,2c")
  check("{{1/2, 0, 0}, {0, 1/2, 0}, {0, 0, 1/2}}", "1/2a,1/2b,1/2c")
  check("{{1, 0, 0}, {0, 1, 0}, {0, 0, 1}}, 1/2, 1/3, 1/4",
    "a+1/2,b+1/3,c+1/4")
  check("(1 0 0 | 1/2) (0 1 0 | 1/3) (0 0 1 | 1/4)",
    "a+1/2,b+1/3,c+1/4")
  check("1/2,1/3,1/4", "a+1/2,b+1/3,c+1/4")
  try:
    change_basis.p_from_string("0")
  except Sorry as e:
    assert str(e) == \
      'Uninterpretable expression for change-of-basis matrix'
  else: raise Exception_expected
  #
  rt = change_basis.w_from_string("1/2,1/3,1/4")
  assert rt.r.elems == (0,)*9
  assert str(rt.t.elems) == "(1/2, 1/3, 1/4)"
  try:
    change_basis.w_from_string("0")
  except Sorry as e:
    assert str(e) == \
      'Uninterpretable expression for symmetry matrix'
  else: raise Exception_expected
  #
  xyz = change_basis.xyz_from_string("0.5,1/3,4")
  assert str(xyz) == "(0.5, 1/3, 4)"
  try:
    change_basis.xyz_from_string("0")
  except Sorry as e:
    assert str(e) == \
      'Uninterpretable expression for coordinates'
  else: raise Exception_expected

def run(args):
  assert len(args) == 0
  exercise()
  print("OK")

if (__name__ == "__main__"):
  import sys
  run(args=sys.argv[1:])


 *******************************************************************************


 *******************************************************************************
cctbx/regression/tst_weighting_schemes.py
from __future__ import absolute_import, division, print_function
from cctbx import xray
from cctbx import crystal
from cctbx import miller
from cctbx.array_family import flex
from libtbx.test_utils import approx_equal

def run():
  crystal_symmetry = crystal.symmetry(
    unit_cell=(10,11,12,85,95,100),
    space_group_symbol="P 1")
  miller_set = miller.build_set(
    crystal_symmetry=crystal_symmetry,
    anomalous_flag=False,
    d_min=3)
  f_calc = miller_set.array(
    data=flex.polar(
      flex.random_double(miller_set.size())*10-5,
      flex.random_double(miller_set.size())*10-5))
  scale_factor = flex.random_double()
  obs = miller_set.array(
    data=scale_factor * flex.norm(f_calc.data()) + (flex.random_double(miller_set.size())*2-1),
    sigmas=flex.random_double(miller_set.size()))
  obs.set_observation_type_xray_intensity()

  exercise_shelx_weighting(f_calc, obs, scale_factor)
  exercise_quasi_unit_weighting(obs)

  print('OK')


def exercise_shelx_weighting(f_calc, obs, scale_factor):
  a,b = 0, 0
  weighting = xray.weighting_schemes.simple_shelx_weighting(a,b)
  weighting_ref = xray.weighting_schemes.pure_statistical_weighting()
  weighting_ref.observed = obs
  weighting_ref.compute()
  weighting.observed = obs
  weighting.compute(f_calc, scale_factor)
  assert approx_equal(weighting.weights, weighting_ref.weights)

  for k in (scale_factor, None):
    a,b = 10, 100
    weighting = xray.weighting_schemes.shelx_weighting(a,b)
    weighting_ref = xray.weighting_schemes.simple_shelx_weighting(a,b)
    for w in (weighting, weighting_ref):
      w.observed = obs
      w.compute(f_calc, k)
    assert approx_equal(weighting.weights, weighting_ref.weights)
    assert weighting.derivatives_wrt_f_c is None
    for w in (weighting, weighting_ref):
      w.computing_derivatives_wrt_f_c = True
      w.compute(f_calc, k)
    assert approx_equal(weighting.derivatives_wrt_f_c,
                        weighting_ref.derivatives_wrt_f_c)

    weighting.observed = weighting.observed.discard_sigmas()
    weighting.compute(f_calc, k)

def exercise_quasi_unit_weighting(obs):
  w = xray.weighting_schemes.intensity_quasi_unit_weighting()
  w.observed = obs.discard_sigmas()
  w.compute()
  assert approx_equal(list(w.weights), list(1/(4.*obs.data())))

if __name__ == '__main__':
  run()


 *******************************************************************************


 *******************************************************************************
cctbx/regression/tst_wilson_plot.py
from __future__ import absolute_import, division, print_function
from cctbx import statistics
from cctbx import miller
from cctbx import adptbx
from cctbx.development import random_structure
from cctbx.development import debug_utils
from cctbx.array_family import flex
from scitbx.python_utils import dicts
from libtbx.test_utils import show_diff
import sys
from cctbx.sgtbx import space_group_info
from libtbx.test_utils import approx_equal

def exercise(space_group_info, anomalous_flag,
             d_min=1.0, reflections_per_bin=200, n_bins=10, verbose=0):
  elements = ("N", "C", "C", "O") * 5
  structure_factors = random_structure.xray_structure(
    space_group_info,
    elements=elements,
    volume_per_atom=50.,
    min_distance=1.5,
    general_positions_only=True,
    use_u_aniso=False,
    u_iso=adptbx.b_as_u(10)
    ).structure_factors(
        anomalous_flag=anomalous_flag, d_min=d_min, algorithm="direct")
  if (0 or verbose):
    structure_factors.xray_structure().show_summary()
  asu_contents = dicts.with_default_value(0)
  for elem in elements: asu_contents[elem] += 1
  f_calc = abs(structure_factors.f_calc())
  f_calc.setup_binner(
    auto_binning=True,
    reflections_per_bin=reflections_per_bin,
    n_bins=n_bins)
  if (0 or verbose):
    f_calc.binner().show_summary()
  for k_given in [1,0.1,0.01,10,100]:
    f_obs = miller.array(
      miller_set=f_calc,
      data=f_calc.data()*k_given).set_observation_type_xray_amplitude()
    f_obs.use_binner_of(f_calc)
    wp = statistics.wilson_plot(f_obs, asu_contents, scattering_table="wk1995",
      e_statistics=True)
    if (0 or verbose):
      print("wilson_k, wilson_b:", wp.wilson_k, wp.wilson_b)
      print("space group:", space_group_info.group().type().hall_symbol())
      print("<E^2-1>:", wp.mean_e_sq_minus_1)

    assert 0.8 < wp.wilson_k/k_given < 1.2
    assert 0.64 < wp.wilson_intensity_scale_factor/(k_given*k_given) < 1.44
    assert 9 < wp.wilson_b < 11
    assert wp.xy_plot_info().fit_correlation == wp.fit_correlation
    if space_group_info.group().is_centric():
      assert 0.90 < wp.mean_e_sq_minus_1 < 1.16
      assert 3.15 < wp.percent_e_sq_gt_2 < 6.5
    else:
      assert 0.65 < wp.mean_e_sq_minus_1 < 0.90
      assert 1.0 < wp.percent_e_sq_gt_2 < 3.15
    assert wp.normalised_f_obs.size() == f_obs.size()
  f_obs = f_calc.array(data=flex.double(f_calc.indices().size(), 0))
  f_obs.use_binner_of(f_calc)
  n_bins = f_obs.binner().n_bins_used()
  try:
    statistics.wilson_plot(f_obs, asu_contents, scattering_table="wk1995")
  except RuntimeError as e:
    assert not show_diff(str(e), """\
wilson_plot error: %d empty bins:
  Number of bins: %d
  Number of f_obs > 0: 0
  Number of f_obs <= 0: %d""" % (n_bins, n_bins, f_obs.indices().size()))

def run_call_back(flags, space_group_info):
  for anomalous_flag in (False, True):
    exercise(space_group_info, anomalous_flag, verbose=flags.Verbose)

def run():
  debug_utils.parse_options_loop_space_groups(sys.argv[1:], run_call_back)

def run2(n = 100, d_min = 1.0):
  for b in range(10, 110, 10):
    res = []
    for st in ["it1992", "neutron", "electron"]:
      elements = ('C', 'N', 'O', 'H')*n
      group = space_group_info("P1")
      xrs = random_structure.xray_structure(
        space_group_info = group,
        volume_per_atom = 25.,
        general_positions_only = True,
        elements = elements,
        u_iso = adptbx.b_as_u(b),
        min_distance = 1.5)
      xrs.scattering_type_registry(
        table = st,
        d_min = d_min,
        types_without_a_scattering_contribution=["?"])
      fo = abs(xrs.structure_factors(d_min=d_min).f_calc())
      fo.setup_binner(reflections_per_bin=100)
      asu_contents = {}
      for e in elements:
        asu_contents[e] = n
      result = statistics.wilson_plot(f_obs = fo, asu_contents = asu_contents,
        scattering_table = st)
      res.append([st,round(result.wilson_b, 0)])
      assert approx_equal(result.wilson_b, b, 1)
    print(b, res)

if (__name__ == "__main__"):
  run()
  run2()


 *******************************************************************************


 *******************************************************************************
cctbx/regression/tst_xray.py
from __future__ import absolute_import, division, print_function
from cctbx.development import random_structure
from cctbx.development import debug_utils
from cctbx import xray
from cctbx import crystal
from cctbx import sgtbx
from cctbx import adptbx
import cctbx.eltbx.xray_scattering
from cctbx import eltbx
from cctbx.array_family import flex
from libtbx.test_utils import Exception_expected, approx_equal, \
  is_above_limit, show_diff
from libtbx.test_utils import not_approx_equal
import random
from six.moves import range
from six.moves import zip
try:
  from six.moves import cPickle as pickle
except ImportError:
  import pickle
from six.moves import cStringIO as StringIO
import sys, random, math
from itertools import count

if (1):
  random.seed(0)
  flex.set_random_seed(0)

def exercise_scatterer():
  assert xray.scatterer(scattering_type="si4+").element_and_charge_symbols() \
      == ("Si", "4+")
  assert xray.scatterer(scattering_type="si+4").element_and_charge_symbols() \
      == ("Si", "")
  assert xray.scatterer(scattering_type="x").element_and_charge_symbols() \
      == ("", "")
  assert xray.scatterer(scattering_type="Cval").element_symbol() == "C"
  assert xray.scatterer(scattering_type="si+4").element_symbol() == "Si"
  assert xray.scatterer(scattering_type="x").element_symbol() is None

def exercise_anomalous_scatterer_group():
  scatterers = flex.xray_scatterer(
    [xray.scatterer(scattering_type=scattering_type)
     for scattering_type in ["S", "AU", "C", "S"]])
  groups = [
    xray.anomalous_scatterer_group(
      iselection=flex.size_t([1]),
      f_prime=-3,
      f_double_prime=4,
      refine=["f_double_prime", "f_prime"]),
    xray.anomalous_scatterer_group(
      iselection=flex.size_t([0,3]),
      f_prime=-1,
      f_double_prime=2,
      refine=[],
      selection_string="name S")
  ]
  assert groups[0].labels_refine() == ["f_prime", "f_double_prime"]
  assert groups[1].labels_refine() == []
  for i_pass in [0,1]:
    s = StringIO()
    for group in groups:
      group.show_summary(out=s, prefix="{.")
    assert not show_diff(s.getvalue(), """\
{.Anomalous scatterer group:
{.  Number of selected scatterers: 1
{.  f_prime:        -3
{.  f_double_prime: 4
{.  refine: f_prime f_double_prime
{.Anomalous scatterer group:
{.  Selection: "name S"
{.  Number of selected scatterers: 2
{.  f_prime:        -1
{.  f_double_prime: 2
{.  refine: None
""")
    for group in groups:
      group.copy_to_scatterers_in_place(scatterers=scatterers)
      group.extract_from_scatterers_in_place(scatterers=scatterers)
  scatterers[1].fp = -4
  scatterers[1].fdp = 5
  group = groups[0]
  group.extract_from_scatterers_in_place(scatterers=scatterers)
  assert approx_equal(group.f_prime, -4)
  assert approx_equal(group.f_double_prime, 5)
  scatterers[0].fdp = 3
  try: groups[1].extract_from_scatterers_in_place(scatterers=scatterers)
  except RuntimeError as e:
    assert str(e) == """\
Anomalous scatterer group with significantly different f_double_prime:
  Selection: "name S"
  Number of selected scatterers: 2
  f_double_prime min:  2
  f_double_prime max:  3
  f_double_prime mean: 2.5
  tolerance: 0.0001"""
  else: raise Exception_expected

def exercise_structure():
  cs1 = crystal.symmetry((10, 20, 30, 90, 90, 90), "P 1")
  sp1 = crystal.special_position_settings(cs1)
  scatterers1 = flex.xray_scatterer((
    xray.scatterer("o", (0.5, 0, 0)),
    xray.scatterer("c", (0, 0, 0))))
  xs1 = xray.structure(sp1, scatterers1)
  cs2 = crystal.symmetry((10, 20, 30, 90, 90, 90), "P 1")
  sp2 = crystal.special_position_settings(cs2)
  scatterers1 = flex.xray_scatterer((
    xray.scatterer("o", (0, 0, 0)),
    xray.scatterer("c", (0,   0, .5))))
  xs2 = xray.structure(sp1, scatterers1)
  assert approx_equal(list(xs1.distances(other = xs2)), [5,15])
  cs = crystal.symmetry((5.01, 5.01, 5.47, 90, 90, 120), "P 62 2 2")
  sp = crystal.special_position_settings(cs)
  scatterers = flex.xray_scatterer((
    xray.scatterer("Si1", (1./2, 1./2, 0.3)),
    xray.scatterer("O1", (0.18700, -0.20700, 0.83333))))
  xs = xray.structure(sp, scatterers)
  assert xs.scatterers().size() == 2
  # test selections
  assert list(xs.by_index_selection([0,])) == [True, False]
  assert list(xs.by_index_selection([1,])) == [False, True]
  assert list(xs.by_index_selection([0,1])) == [True, True]
  try: sel = xs.by_index_selection([2,])
  except IndexError as e:
    assert str(e) == """\
Tried to select a scatterer by index with index \
=> of scatterers for this structuture."""
  else: raise Exception_expected
  assert not xs.non_unit_occupancy_implies_min_distance_sym_equiv_zero()
  assert xs.n_undefined_multiplicities() == 0
  assert tuple(xs.special_position_indices()) == (0, 1)
  s = StringIO()
  xs.show_special_position_shifts(
    sites_cart_original=cs.unit_cell().orthogonalize(
      sites_frac=scatterers.extract_sites()),
    out=s,
    prefix="%^")
  assert s.getvalue() == """\
%^Number of sites at special positions: 2
%^  Minimum distance between symmetrically equivalent sites: 0.5
%^  Label   Mult   Shift    Fractional coordinates
%^  Si1       3    0.182 (  0.5000   0.5000   0.3000) original
%^        site sym 222   (  0.5000   0.5000   0.3333) exact
%^                               1/2,1/2,1/3
%^  O1        6    0.050 (  0.1870  -0.2070   0.8333) original
%^        site sym 2     (  0.1970  -0.1970   0.8333) exact
%^                        1/2*x-1/2*y,-1/2*x+1/2*y,5/6
"""
  ys = xs.deep_copy_scatterers()
  ys.add_scatterers(ys.scatterers())
  assert ys.scatterers().size() == 4
  assert xs.scatterers().size() == 2
  assert tuple(ys.special_position_indices()) == (0, 1, 2, 3)
  ys.add_scatterer(ys.scatterers()[0])
  assert ys.scatterers().size() == 5
  assert tuple(ys.special_position_indices()) == (0, 1, 2, 3, 4)
  sx = xs.primitive_setting()
  assert sx.unit_cell().is_similar_to(xs.unit_cell())
  assert str(sx.space_group_info()) == "P 62 2 2"
  sx = xs.change_hand()
  assert sx.unit_cell().is_similar_to(xs.unit_cell())
  assert str(sx.space_group_info()) == "P 64 2 2"
  assert approx_equal(sx.scatterers()[0].site, (-1./2, -1./2, -1./3))
  assert approx_equal(sx.scatterers()[1].site, (-0.19700, 0.19700, -0.833333))
  p1 = xs.asymmetric_unit_in_p1()
  assert p1.scatterers().size() == 2
  for i in range(2):
    assert p1.scatterers()[i].weight() == xs.scatterers()[i].weight()
  assert str(p1.space_group_info()) == "P 1"
  p1 = xs.expand_to_p1()
  assert p1.scatterers().size() == 9
  for i in range(2):
    assert p1.scatterers()[i].weight() != xs.scatterers()[i].weight()
  p1mp = xs.expand_to_p1(sites_mod_positive=True)
  def count_outside_unit_cell(xs):
    result = 0
    for sc in xs.scatterers():
      for v in sc.site:
        if (v < 0 or v >= 1): result += 1
    return result
  assert count_outside_unit_cell(p1) != 0
  assert count_outside_unit_cell(p1mp) == 0
  sh = p1.apply_shift((0.2,0.3,-1/6.))
  assert approx_equal(sh.scatterers()[0].site, (0.7,0.8,1/6.))
  assert approx_equal(sh.scatterers()[3].site, (0.3970,0.1030,2/3.))
  sl = sh[:1]
  assert sl.scatterers().size() == 1
  assert sl.scatterers()[0].label == sh.scatterers()[0].label
  sl = sh[1:4]
  assert sl.scatterers().size() == 3
  for i in range(3):
    assert sl.scatterers()[i].label == sh.scatterers()[i+1].label
  xs.scatterers().set_occupancies(flex.double((0.5,0.2)))
  s = xs.sort(by_value="occupancy")
  assert approx_equal(s.scatterers().extract_occupancies(), (0.2,0.5))
  assert s.scatterers()[0].label == "O1"
  assert s.scatterers()[1].label == "Si1"
  aw = xs.atomic_weights()
  assert approx_equal(aw, (28.086, 15.999))
  center_of_mass = xs.center_of_mass(atomic_weights=aw)
  assert approx_equal(center_of_mass, (1.335228, 1.071897, 2.815899))
  center_of_mass = xs.center_of_mass()
  assert approx_equal(center_of_mass, (1.335228, 1.071897, 2.815899))
  ys = xs.apply_shift(
    shift=xs.unit_cell().fractionalize([-e for e in center_of_mass]),
    recompute_site_symmetries=True)
  assert approx_equal(ys.center_of_mass(), (0,0,0))
  ys = xray.structure(xs)
  assert ys.atomic_weights().size() == 0
  pa1 = xs.principal_axes_of_inertia()
  pa2 = xs.principal_axes_of_inertia(atomic_weights=aw)
  assert approx_equal(pa1.center_of_mass(), pa2.center_of_mass())
  assert approx_equal(pa1.inertia_tensor(), pa2.inertia_tensor())
  assert approx_equal(pa1.center_of_mass(), (1.335228, 1.071897, 2.815899))
  assert approx_equal(pa1.inertia_tensor(),
                      (169.46094427548525, 76.773803949363497, 93.746443127965918,
                       7.0265499590972862, -6.3547480051846588, 84.304420337921911))
  ys = xray.structure(sp, scatterers)
  ys.scatterers()[1].occupancy = 0.5
  assert approx_equal(ys.scatterers()[1].weight(),0.25)
  ys.scatterers()[1].occupancy -= 0.1
  assert approx_equal(ys.scatterers()[1].weight(),0.2)
  gradient_flags = xray.structure_factors.gradient_flags(default=True)
  xray.set_scatterer_grad_flags(scatterers = xs.scatterers(),
                                site       = gradient_flags.site,
                                u_iso      = gradient_flags.u_iso,
                                u_aniso    = gradient_flags.u_aniso,
                                occupancy  = gradient_flags.occupancy,
                                fp         = gradient_flags.fp,
                                fdp        = gradient_flags.fdp)
  assert xs.n_parameters() == 14
  assert xs.n_parameters(considering_site_symmetry_constraints=True) == 9
  g = flex.vec3_double(((0.1,0.2,0.3),(0.2,0.3,0.4)))
  xs.apply_special_position_ops_d_target_d_site(g)
  assert approx_equal(g[0], (0,0,0))
  assert approx_equal(g[1], (-0.05,0.05,0))
  xs.replace_scatterers(xs.scatterers()[:1], None)
  assert xs.scatterers().size() == 1
  assert tuple(xs.special_position_indices()) == (0,)
  reg = ys.scattering_type_registry(table="electron")
  assert reg.gaussian("Si").n_terms() == 5
  s = StringIO()
  reg.show(out=s)
  assert not show_diff(s.getvalue(), """\
Number of scattering types: 2
  Type Number    sf(0)   Gaussians
   Si      1      5.83       5
   O       1      1.98       5
  sf(0) = scattering factor at diffraction angle 0.
""")
  reg = ys.scattering_type_registry(table="wk1995")
  assert reg.gaussian("Si").n_terms() == 5
  reg = ys.scattering_type_registry(table="it1992")
  assert reg.gaussian("Si").n_terms() == 4
  reg = ys.scattering_type_registry(explicitly_allow_mixing=True,
    custom_dict={"Si":eltbx.xray_scattering.gaussian(1)})
  assert reg.gaussian("Si").n_terms() == 0
  s = StringIO()
  reg.show_summary(out=s)
  assert s.getvalue().strip() == "O:4+c*1 Si:0+c*1"
  s = StringIO()
  reg.show(out=s)
  assert not show_diff(s.getvalue(), """\
Number of scattering types: 2
  Type Number    sf(0)   Gaussians
   O       1      8.00       4+c
   Si      1      1.00       0+c
  sf(0) = scattering factor at diffraction angle 0.
""")
  s = StringIO()
  reg.show(out=s, show_sf0=False)
  assert s.getvalue() == """\
Number of scattering types: 2
  Type Number   Gaussians
   O       1        4+c
   Si      1        0+c
"""
  s = StringIO()
  reg.show(out=s, show_gaussians=False)
  assert s.getvalue() == """\
Number of scattering types: 2
  Type Number    sf(0)
   O       1      8.00
   Si      1      1.00
  sf(0) = scattering factor at diffraction angle 0.
"""
  s = StringIO()
  reg.show(out=s, show_sf0=False, show_gaussians=False)
  assert s.getvalue() == """\
Number of scattering types: 2
  Type Number
   O       1
   Si      1
"""
  wd = reg.wilson_dict()
  assert len(wd) == 2
  assert wd["O"] == 1
  assert wd["Si"] == 1
  tgd = reg.as_type_gaussian_dict()
  assert len(tgd) == 2
  assert tgd["O"].n_terms() == 4
  assert tgd["Si"].n_terms() == 0
  #
  reg = ys.scattering_type_registry(explicitly_allow_mixing=True)
  assert reg.type_index_pairs_as_dict() == {"Si": 0, "O": 1}
  assert list(reg.unique_indices(scatterers=ys.scatterers())) == [0,1]
  assert reg.type_count_dict() == {"Si": 1, "O": 1}
  #
  am = xs.asu_mappings(buffer_thickness=1)
  assert am.mappings().size() == xs.scatterers().size()
  rs = p1.random_shift_sites(max_shift_cart=0.2)
  assert flex.max(flex.abs(p1.difference_vectors_cart(rs).as_double())) <= 0.2
  assert approx_equal(p1.rms_difference(p1), 0)
  assert approx_equal(rs.rms_difference(rs), 0)
  assert p1.rms_difference(rs) > 0
  for s in [xs, ys, p1, rs]:
    p = pickle.dumps(s)
    l = pickle.loads(p)
    assert l.scatterers().size() == s.scatterers().size()
    assert l.special_position_indices().all_eq(s.special_position_indices())
  xs0 = xray.structure(
    crystal_symmetry=crystal.symmetry(
      unit_cell=(10,10,10,90,90,90),
      space_group_symbol="P 2 2 2"))
  xs0.add_scatterer(xray.scatterer(label="C", site=(0.1,0.1,0.1)))
  assert xs0.site_symmetry_table().get(0).is_point_group_1()
  xs1 = xs0.apply_shift(shift=(-0.08,-0.1,0), recompute_site_symmetries=False)
  assert xs1.site_symmetry_table().get(0).is_point_group_1()
  xs2 = xs0.apply_shift(shift=(-0.08,-0.1,0), recompute_site_symmetries=True)
  assert str(xs2.site_symmetry_table().get(0).special_op()) == "0,0,z"
  assert approx_equal(xs1.scatterers()[0].site, (0.02, 0, 0.1))
  assert approx_equal(xs2.scatterers()[0].site, (0, 0, 0.1))
  assert list(xs1.deep_copy_scatterers().special_position_indices()) == []
  assert list(xs2.deep_copy_scatterers().special_position_indices()) == [0]
  assert list(xs1[:].special_position_indices()) == []
  assert list(xs2[:].special_position_indices()) == [0]
  xs1.add_scatterer(xs1.scatterers()[0])
  assert list(xs1[:].special_position_indices()) == [1]
  xs1.add_scatterer(xs1.scatterers()[0], xs1.site_symmetry_table().get(0))
  assert list(xs1[:].special_position_indices()) == [1]
  xs1.add_scatterers(xs1.scatterers())
  assert list(xs1[:].special_position_indices()) == [1,3,4,5]
  xs1.add_scatterers(xs1.scatterers(), xs1.site_symmetry_table())
  assert list(xs1[:].special_position_indices()) == [1,3,4,5,7,9,10,11]
  for selection in [flex.size_t([1,4,6]),
                    flex.bool([False,True,False,False,True,False,
                               True,False,False,False,False,False])]:
    xs2 = xs1.select(selection=selection)
    assert xs2.scatterers().size() == 3
    assert list(xs2.special_position_indices()) == [0,1]
    if (isinstance(selection, flex.bool)):
      xs2 = xs1.select(selection=selection, negate=True)
      assert xs2.scatterers().size() == 9
  xs2 = xs1[2::2]
  assert xs2.scatterers().size() == 5
  assert list(xs2[:].special_position_indices()) == [1,4]
  xs1.replace_scatterers(xs2.scatterers(), None)
  assert list(xs1[:].special_position_indices()) == [0,1,2,3,4]
  xs1.replace_scatterers(xs2.scatterers(), xs2.site_symmetry_table())
  assert list(xs1[:].special_position_indices()) == [1,4]
  xs2 = xs1.asymmetric_unit_in_p1()
  assert xs2.unit_cell().is_similar_to(xs1.unit_cell())
  assert xs2.space_group().order_z() == 1
  assert list(xs2[:].special_position_indices()) == [1,4]
  for append_number_to_labels in [False, True]:
    xs2 = xs1.expand_to_p1(append_number_to_labels=append_number_to_labels)
    assert xs2.scatterers().size() == 16
    xs2 = xray.structure(xs1, xs1.scatterers())
    xs2 = xs2.expand_to_p1(append_number_to_labels=append_number_to_labels)
    assert xs2.scatterers().size() == 10
  xs2 = xs1.change_basis("z,x,y")
  for i,sc in enumerate(xs2.scatterers()):
    assert sc.multiplicity() > 0
    ss = xs2.site_symmetry_table().get(i)
    assert ss.multiplicity() == sc.multiplicity()
    assert ss.multiplicity() * ss.n_matrices() == xs2.space_group().order_z()
  xs2 = xs2.expand_to_p1()
  for sc in xs2.scatterers():
    assert sc.multiplicity() == 1
  assert xs2.scatterers().size() == 16
  assert approx_equal(xs2.scatterers()[0].site, (0.1, 0.02, 0))
  assert approx_equal(xs2.scatterers()[4].site, (0.1, 0, 0))
  sx = ys.sites_mod_positive()
  assert approx_equal(sx.scatterers()[1].site, (0.197,0.803,0.8333333))
  sx = ys.sites_mod_short()
  assert approx_equal(sx.scatterers()[1].site, (0.197,-0.197,-0.1666667))
  xs1.scatterers().set_occupancies(flex.random_double(size=5))
  xs2 = xs1.sort(by_value="occupancy")
  assert xs2.special_position_indices().size() == 2
  xs2.set_sites_frac(xs2.sites_frac()+(0.1,0.2,0.3))
  xs2.set_sites_cart(xs2.sites_cart()+(1,2,3))
  assert approx_equal(xs2.extract_u_iso_or_u_equiv(), [0,0,0,0,0])
  i = xs2.special_position_indices()[0]
  assert approx_equal(xs2.scatterers()[i].site, (0.2, 0.4, 0.7))
  assert list(xs2.is_positive_definite_u()) == [False]*5
  assert list(xs2.is_positive_definite_u(u_cart_tolerance=0)) == [True]*5
  xs2.tidy_us(u_min=1,u_max=888)
  assert approx_equal(xs2.scatterers().extract_u_iso(), [1]*5)
  xs2.shift_us(u_shift=2)
  assert approx_equal(xs2.scatterers().extract_u_iso(), [3]*5)
  xs2.shift_us(b_shift=-adptbx.u_as_b(2))
  assert approx_equal(xs2.scatterers().extract_u_iso(), [1]*5)
  xs2.scatterers().set_occupancies(flex.double(xs2.scatterers().size(), 1.0))
  xs2.shift_occupancies(q_shift = 1.0)
  assert approx_equal(xs2.scatterers().extract_occupancies(),
                      [2.0, 2.0, 2.0, 2.0, 2.0])
  xs2.shift_occupancies(q_shift = -1.0, selection = flex.size_t([0,3]))
  assert approx_equal(xs2.scatterers().extract_occupancies(),
                      [1.0, 2.0, 2.0, 1.0, 2.0])
  xs2.apply_symmetry_sites()
  assert approx_equal(xs2.scatterers()[i].site, (0, 0, 0.7))
  xs2.apply_symmetry_u_stars()
  s = StringIO()
  xs1.show_distances(distance_cutoff=0.1, out=s)
  assert s.getvalue() == """\
C  pair count:   2       <<  0.0200,  0.0000,  0.1000>>
  C:   0.0000             (  0.0200,  0.0000,  0.1000)
  C:   0.0000             (  0.0200,  0.0000,  0.1000)
C  pair count:   1       <<  0.0000,  0.0000,  0.1000>>
  C:   0.0000             (  0.0000,  0.0000,  0.1000)
C  pair count:   2       <<  0.0200,  0.0000,  0.1000>>
  C:   0.0000             (  0.0200,  0.0000,  0.1000)
  C:   0.0000             (  0.0200,  0.0000,  0.1000)
C  pair count:   2       <<  0.0200,  0.0000,  0.1000>>
  C:   0.0000             (  0.0200,  0.0000,  0.1000)
  C:   0.0000             (  0.0200,  0.0000,  0.1000)
C  pair count:   1       <<  0.0000,  0.0000,  0.1000>>
  C:   0.0000             (  0.0000,  0.0000,  0.1000)
"""
  quartz = xray.structure(
    crystal_symmetry=crystal.symmetry(
      (5.01,5.01,5.47,90,90,120), "P6222"),
    scatterers=flex.xray_scatterer([
      xray.scatterer("Si", (1/2.,1/2.,1/3.)),
      xray.scatterer("O", (0.197,-0.197,0.83333))]))
  assert approx_equal(quartz.mean_scattering_density(), 0.184934969936)
  s = StringIO()
  quartz.show_angles(distance_cutoff=2, out=s)
  assert not show_diff(s.getvalue(), """\
O*1   Si    O*2    101.31
O*3   Si    O*2    111.31
O*3   Si    O*1    116.13
O*4   Si    O*2    116.13
O*4   Si    O*1    111.31
O*4   Si    O*3    101.31
Si*5  O     Si*6   146.93
*1 x-y,x,z-2/3
*2 -y,x-y,z-1/3
*3 y+1,-x+y+1,z-1/3
*4 -x+y+1,-x+1,z-2/3
*5 y,-x+y,z+2/3
*6 -x+y,-x,z+1/3
""")
  s = StringIO()
  quartz.show_dihedral_angles(distance_cutoff=2, max_d=1.62, out=s)
  assert not show_diff(s.getvalue(), """\
Si    O     *1Si    *2O     *3 -157.64
Si    O     *1Si    *2O     *4 -36.91
Si    O     *1Si    *2O     *5  78.30
Si    O     *6Si    *7O     *8 -157.64
Si    O     *6Si    *7O     *9  78.30
Si    O     *6Si    *7O     *10 -36.91
Si    O     *11Si    *12O     *13 -157.64
Si    O     *11Si    *12O     *14 -36.91
Si    O     *11Si    *12O     *15  78.30
Si    O     *16Si    *17O     *18 -157.64
Si    O     *16Si    *17O     *19  78.30
Si    O     *16Si    *17O     *20 -36.91
*1 -y,x-y,z-1/3
*2 x-y,x,z+1/3
*3 -x,-y,z
*4 x,y+1,z
*5 y,-x+y+1,z-1/3
*6 x-y,x,z-2/3
*7 y,-x+y,z-1/3
*8 x,y,z-1
*9 -x+y+1,-x,z-2/3
*10 -x+1,-y,z-1
*11 y+1,-x+y+1,z-1/3
*12 -x+y+1,-x+1,z+1/3
*13 x+1,y+1,z
*14 -x+1,-y,z
*15 -y+1,x-y,z-1/3
*16 -x+y+1,-x+1,z-2/3
*17 -y+1,x-y+1,z-1/3
*18 -x+1,-y+1,z-1
*19 x-y,x+1,z-2/3
*20 x,y+1,z-1
""")
### shake_adp()
  cs = crystal.symmetry((5.01, 6.01, 5.47, 60, 80, 120), "P1")
  sp = crystal.special_position_settings(cs)
  scatterers = flex.xray_scatterer([xray.scatterer("o")]*100)
  selection = flex.bool()
  rd = flex.mersenne_twister(seed=0).random_double
  for i_sc, sc in enumerate(scatterers):
    scale = scatterers.size()/(1.+i_sc)
    sc.u_iso = 1.0 * scale
    sc.u_star = (1.0 * scale, 2.0 * scale, 3.0 * scale,
                 4.0 * scale, 5.0 * scale, 6.0 * scale)
    sc.flags.set_use_u_iso(rd() > 0.5)
    sc.flags.set_use_u_aniso(rd() > 0.5)
    selection.append(rd() > 0.5)
  xs = xray.structure(sp, scatterers)
  for sel in [None, selection]:
    for b_min, b_max, spread in zip([None,10.0], [None,20.0], [10.0,0.0]):
      for keep_anisotropic in [True, False]:
        xs_mod = xs.deep_copy_scatterers()
        xs_mod.shake_adp(keep_anisotropic = keep_anisotropic,
                         b_max = b_max, b_min = b_min, selection=sel, spread = spread)
        if(sel is None): sel = flex.bool(xs.scatterers().size(), True)
        for sc,sc_mod,s in zip(xs.scatterers(),xs_mod.scatterers(),sel):
          assert sc.flags.use_u_iso()   == sc_mod.flags.use_u_iso()
          assert sc.flags.use_u_aniso() == sc_mod.flags.use_u_aniso()
          if(sc.flags.use_u_iso() and s):
            assert not_approx_equal(abs(sc.u_iso - sc_mod.u_iso), 0)
          else:
            assert approx_equal(sc.u_iso, sc_mod.u_iso)
          if(keep_anisotropic):
            assert approx_equal(sc.u_star, sc_mod.u_star)
          else:
            if(sc.flags.use_u_aniso() and s):
              a = flex.double(sc.u_star)
              b = flex.double(sc_mod.u_star)
              # quick-and-dirty test, likely to fail if random seed
              # is changed
              assert is_above_limit(
                value=flex.max(flex.abs((a-b))), limit=0.1)
              assert is_above_limit(
                value=flex.min(flex.abs((a-b))), limit=0.001)
            else:
              assert approx_equal(sc.u_star, sc_mod.u_star)
### shake_occupancies()
  cs = crystal.symmetry((5.01, 6.01, 5.47, 60, 80, 120), "P1")
  sp = crystal.special_position_settings(cs)
  scatterers = flex.xray_scatterer([xray.scatterer("o")]*100)
  selection = flex.bool()
  for sc in scatterers:
    sc.occupancy = random.random()
    selection.append(random.choice((False,True)))
  xs = xray.structure(sp, scatterers)
  for sel in [None, selection]:
    xs_mod = xs.deep_copy_scatterers()
    xs_mod.shake_occupancies(selection = sel)
    if(sel is None): sel = flex.bool(xs.scatterers().size(), True)
    for sc, sc_mod, s in zip(xs.scatterers(),xs_mod.scatterers(), sel):
      if(s):
        assert abs(sc.occupancy - sc_mod.occupancy) > 1.e-4
      else:
        assert approx_equal(sc.occupancy, sc_mod.occupancy)
### shake_fps()
  cs = crystal.symmetry((5.01, 6.01, 5.47, 60, 80, 120), "P1")
  sp = crystal.special_position_settings(cs)
  scatterers = flex.xray_scatterer([xray.scatterer("o")]*100)
  selection = flex.bool()
  for sc in scatterers:
    sc.fp = random.random()
    selection.append(random.choice((False,True)))
  xs = xray.structure(sp, scatterers)
  for sel in [None, selection]:
    xs_mod = xs.deep_copy_scatterers()
    xs_mod.shake_fps(selection = sel)
    if(sel is None): sel = flex.bool(xs.scatterers().size(), True)
    for sc, sc_mod, s in zip(xs.scatterers(),xs_mod.scatterers(), sel):
      if(s):
        assert abs(sc.fp - sc_mod.fp) > 1.e-4
      else:
        assert approx_equal(sc.fp, sc_mod.fp)
### shake_fdps()
  cs = crystal.symmetry((5.01, 6.01, 5.47, 60, 80, 120), "P1")
  sp = crystal.special_position_settings(cs)
  scatterers = flex.xray_scatterer([xray.scatterer("o")]*100)
  selection = flex.bool()
  for sc in scatterers:
    sc.fdp = random.random()
    selection.append(random.choice((False,True)))
  xs = xray.structure(sp, scatterers)
  for sel in [None, selection]:
    xs_mod = xs.deep_copy_scatterers()
    xs_mod.shake_fdps(selection = sel)
    if(sel is None): sel = flex.bool(xs.scatterers().size(), True)
    for sc, sc_mod, s in zip(xs.scatterers(),xs_mod.scatterers(), sel):
      if(s):
        assert abs(sc.fdp - sc_mod.fdp) > 1.e-4
      else:
        assert approx_equal(sc.fdp, sc_mod.fdp)
### shake_adp_if_all_equal()
  cs = crystal.symmetry((5.01, 6.01, 5.47, 60, 80, 120), "P1")
  sp = crystal.special_position_settings(cs)
  scatterers = flex.xray_scatterer([xray.scatterer("o", u=0.5)]*100)
  xs = xray.structure(sp, scatterers)
  xs_mod = xs.deep_copy_scatterers()
  assert xs_mod.shake_adp_if_all_equal()
  assert not xs.scatterers().extract_u_iso().all_eq(
    xs_mod.scatterers().extract_u_iso())
  xs.scatterers()[3].u_iso = 0.1
  xs_mod = xs.deep_copy_scatterers()
  assert not xs_mod.shake_adp_if_all_equal()
  assert xs.scatterers().extract_u_iso().all_eq(
    xs_mod.scatterers().extract_u_iso())
# exercise set_b_iso()
  cs = crystal.symmetry((5.01, 6.01, 5.47, 60, 80, 120), "P1")
  sp = crystal.special_position_settings(cs)
  scatterers = flex.xray_scatterer((
    xray.scatterer("C", (1./2, 1./2, 0.3)),
    xray.scatterer("C", (0.18700, -0.20700, 0.83333))))
  xs = xray.structure(sp, scatterers)
  uc = xs.unit_cell()
  b_iso_value = 25.0
  xs.set_b_iso(value = b_iso_value)
  result = flex.double([25,25])
  assert approx_equal(xs.scatterers().extract_u_iso()/adptbx.b_as_u(1), result)
  b_iso_values = flex.double([7,9])
  xs.set_b_iso(values = b_iso_values)
  assert approx_equal(xs.scatterers().extract_u_iso()/adptbx.b_as_u(1), b_iso_values)
  #
  xs.scatterers().set_u_iso(flex.double([0.1,0.2]),
                            flex.bool(xs.scatterers().size(), True), uc)
  assert xs.scatterers().count_anisotropic() == 0
  xs.convert_to_anisotropic()
  assert xs.scatterers().count_anisotropic() == 2
  assert approx_equal(xs.scatterers().extract_u_cart(unit_cell=xs.unit_cell()),
                      [[0.1]*3+[0]*3, [0.2]*3+[0]*3])
  xs.convert_to_isotropic()
  assert xs.scatterers().count_anisotropic() == 0
  assert approx_equal(xs.scatterers().extract_u_iso(), [0.1,0.2])
  #
  cs = crystal.symmetry((10, 20, 30, 90, 90, 90), "P 1")
  sp = crystal.special_position_settings(cs)
  uc = cs.unit_cell()
  scatterers = flex.xray_scatterer((
    xray.scatterer("o", site=(0.5, 0, 0),u=1.0),
    xray.scatterer("o", site=(0.5, 1.0, 0),u=0.1),
    xray.scatterer("o", site=(0.5, 1.0, 10),u=0.7),
    xray.scatterer("n", site=(0.5,-1.0, 0),u=adptbx.u_cart_as_u_star(uc,(1,2,3,-.3,-2,1))),
    xray.scatterer("c", site=(0, 0, 0),u=adptbx.u_cart_as_u_star(uc,(6,7,9,2,3,-.7)))))
  xs = xray.structure(sp, scatterers)
  b_isos = [adptbx.u_as_b(i) for i in xs.extract_u_iso_or_u_equiv()]
  assert not_approx_equal(b_isos, [20.0, 20.0, 20.0, 20.0, 20.0])
  xs.set_b_iso(value=20)
  b_isos = [adptbx.u_as_b(i) for i in xs.extract_u_iso_or_u_equiv()]
  assert approx_equal(b_isos, [20.0, 20.0, 20.0, 20.0, 20.0])
### scale_adp:
  cs = crystal.symmetry((5.01, 6.01, 5.47, 60, 80, 120), "P1")
  sp = crystal.special_position_settings(cs)
  scatterers = flex.xray_scatterer([xray.scatterer("o")]*100)
  selection = flex.bool()
  rd = flex.mersenne_twister(seed=0).random_double
  for sc in scatterers:
    sc.u_iso = 1.0 * rd()
    sc.u_star = (1.0 * rd(), 2.0 * rd(), 3.0 * rd(),
                 4.0 * rd(), 5.0 * rd(), 6.0 * rd())
    sc.flags.set_use_u_iso(rd() > 0.5)
    sc.flags.set_use_u_aniso(rd() > 0.5)
    selection.append(rd() > 0.5)
  xs = xray.structure(sp, scatterers)
  xs_dc = xs.deep_copy_scatterers()
  xs_dc.scale_adp(factor=2, selection=selection)
  for i_seq,sc,sc_dc,sel in zip(count(), xs.scatterers(), xs_dc.scatterers(),
                                selection):
    if(sel and sc.flags.use()):
      if(sc.flags.use_u_iso()):
        if(sc.u_iso != 0.0):
          assert approx_equal(sc_dc.u_iso / sc.u_iso, 2.0)
      if(sc.flags.use_u_aniso()):
        for i in range(6):
          if(sc.u_star[i] != 0.0):
            assert approx_equal(sc_dc.u_star[i] / sc.u_star[i], 2.0)

### shake_sites
  selection_ = flex.bool([random.choice((False,True)) for i in range(500)])
  xs = random_structure.xray_structure(
    space_group_info = sgtbx.space_group_info("P1"),
    elements         = ["N"]*500,
    unit_cell        = (10, 20, 30, 70, 80, 120))
  mt = flex.mersenne_twister(seed=0)
  errors = [0.0, 0.01, 0.1, 0.5, 1.5, 3.0, 10.0]
  for selection in [None, selection_]:
    for error in errors:
      xs_shaked = xs.deep_copy_scatterers()
      xs_shaked.shake_sites_in_place(
        mean_distance=error,
        selection=selection,
        random_double=[None, mt.random_double][int(error<0.2)])
      sites_cart_xs        = xs.sites_cart()
      sites_cart_xs_shaked = xs_shaked.sites_cart()
      if(selection is None): selection=flex.bool(xs.scatterers().size(),True)
      mean_err = flex.mean(
        flex.sqrt((sites_cart_xs.select(selection) -
                   sites_cart_xs_shaked.select(selection)).dot()))
      assert approx_equal(error, mean_err, 0.001)
      dummy = ~selection
      if(dummy.count(True) > 0):
        mean_err_fixed = flex.mean(
          flex.sqrt((sites_cart_xs.select(~selection) -
                     sites_cart_xs_shaked.select(~selection)).dot()))
        assert approx_equal(mean_err_fixed, 0.0)
  ### random remove sites
  for fraction in range(1, 99+1, 10):
    fraction /= 100.
    selection = xs.random_remove_sites_selection(fraction = fraction)
    deleted = selection.count(False) / float(selection.size())
    retained= selection.count(True)  / float(selection.size())
    assert approx_equal(fraction, deleted)
    assert approx_equal(1-deleted, retained)
  #
  xs.scatterers()[0] = xs.scatterers()[0].customized_copy()
  assert approx_equal(xs.scatterers()[0].weight(), 1.0)
  xs.re_apply_symmetry(i_scatterer=0)
  assert approx_equal(xs.scatterers()[0].weight(), 1.0)
# apply_rigid_body_shift
  selection_=flex.bool([random.choice((False,True))
    for i in range(100)]).iselection()
  xs = random_structure.xray_structure(
    space_group_info = sgtbx.space_group_info("P1"),
    elements         = ["N"]*100,
    unit_cell        = (10, 20, 30, 70, 80, 120))
  for selection in [None, selection_]:
    for r in [[1.,2.,3.], [0.,0.,0.]]:
      xs_mod = xs.deep_copy_scatterers()
      xs_mod.apply_rigid_body_shift(
        rot       = (1,0,0,0,1,0,0,0,1),
        trans     = [r[0],r[1],r[2]],
        selection = selection)
      d = math.sqrt(r[0]**2+r[1]**2+r[2]**2)
      assert approx_equal(
        d, xs.mean_distance(other = xs_mod, selection = selection))
  selection_=flex.bool([random.choice((False,True)) for i in range(100)])
  xs_mod = xs.deep_copy_scatterers()
  xs_mod.apply_rigid_body_shift(
    rot=(0.999,-0.017,0.035,0.019,0.998,-0.052,-0.033,0.052,0.998),
    trans=[1., 2., 3.],
    selection=selection_.iselection())
  assert xs.mean_distance(other = xs_mod, selection = selection_) > 1.0
  assert approx_equal(
    xs.mean_distance(other = xs_mod, selection = ~selection_), 0.0)
  #
  assert xs.scatterers().size() == xs.all_selection().size() == \
    xs.all_selection().count(True)
  #
  xs = xray.structure(
    crystal_symmetry=crystal.symmetry(
      unit_cell=(20,30,40,90,90,90),
      space_group_symbol="P222"))
  bs = xs.orthorhombic_unit_cell_around_centered_scatterers(buffer_size=3.5)
  assert str(bs.unit_cell()) == "(7, 7, 7, 90, 90, 90)"
  bs = xs.cubic_unit_cell_around_centered_scatterers(buffer_size=3.5)
  assert str(bs.unit_cell()) == "(7, 7, 7, 90, 90, 90)"
  xs.add_scatterer(xray.scatterer(label="S1", site=[0.1,0.2,-0.3]))
  bs = xs.orthorhombic_unit_cell_around_centered_scatterers(buffer_size=3.5)
  assert str(bs.unit_cell()) == "(7, 7, 7, 90, 90, 90)"
  bs = xs.cubic_unit_cell_around_centered_scatterers(buffer_size=3.5)
  assert str(bs.unit_cell()) == "(7, 7, 7, 90, 90, 90)"
  xs.add_scatterer(xray.scatterer(label="S1", site=[-0.1,-0.2,0.3]))
  bs = xs.orthorhombic_unit_cell_around_centered_scatterers(buffer_size=3.5)
  assert str(bs.unit_cell()) == "(11, 19, 31, 90, 90, 90)"
  bs = xs.cubic_unit_cell_around_centered_scatterers(buffer_size=3.5)
  assert str(bs.unit_cell()) == "(31, 31, 31, 90, 90, 90)"
  #
  xs = xray.structure(
    crystal_symmetry=crystal.symmetry(
      unit_cell=(3,4,5,90,90,90),
      space_group_symbol="Pmmm"))
  xs.add_scatterer(xray.scatterer("C1", site=(0.5, 0.5, 0.5)))
  xs.add_scatterer(xray.scatterer("C2", site=(0.7, 0.7, 0.7)))
  xs.add_scatterer(xray.scatterer("C3", site=(0.3, 0.3, 0.3)))
  c1, c2, c3 = xs.scatterers()
  c1.flags.set_grad_site(True)
  c2.flags.set_use_u_iso(True)
  c3.flags.set_grad_u_aniso(True)
  grad_flags = xs.scatterer_flags()
  assert ([ f.bits for f in grad_flags ]
          ==
          [ sc.flags.bits for sc in xs.scatterers() ])
  #
  from cctbx.eltbx import henke, sasaki, wavelengths
  xs = xray.structure(
    crystal_symmetry=crystal.symmetry(
      unit_cell=(3,4,5,90,90,90),
      space_group_symbol="Pmmm"))
  xs.add_scatterer(xray.scatterer("C1", site=(0.5, 0.5, 0.5)))
  xs.add_scatterer(xray.scatterer("C2", site=(0.7, 0.7, 0.7)))
  xs.add_scatterer(xray.scatterer("S3", site=(0.3, 0.3, 0.3)))
  xs1 = xs.deep_copy_scatterers()
  xs1.set_inelastic_form_factors(wavelengths.characteristic("Mo"), "sasaki")
  assert xs1.inelastic_form_factors_source == "sasaki"
  for sc in xs1.scatterers():
    assert sc.flags.use_fp_fdp() == True
    assert sc.fp != 0
    assert sc.fdp != 0
    sc_sasaki = sasaki.table(sc.element_symbol())
    sc_fp_fdp_sasaki = sc_sasaki.at_angstrom(
      wavelengths.characteristic('Mo').as_angstrom())
    assert approx_equal(sc.fp, sc_fp_fdp_sasaki.fp())
    assert approx_equal(sc.fdp, sc_fp_fdp_sasaki.fdp())
  xs2 = xs.deep_copy_scatterers()
  xs2.set_inelastic_form_factors(0.71073, "henke") # angstrom
  assert xs2.inelastic_form_factors_source == "henke"
  for sc in xs2.scatterers():
    assert sc.flags.use_fp_fdp() == True
    assert sc.fp != 0
    assert sc.fdp != 0
    sc_henke = henke.table(sc.element_symbol())
    sc_fp_fdp_henke = sc_henke.at_angstrom(0.71073)
    assert approx_equal(sc.fp, sc_fp_fdp_henke.fp())
    assert approx_equal(sc.fdp, sc_fp_fdp_henke.fdp())

  # Exercise structure.wavelength
  from cctbx.eltbx import sasaki, wavelengths
  test_wvl=1.1
  xs = xray.structure(
    crystal_symmetry=crystal.symmetry(
      unit_cell=(3,4,5,90,90,90),
      space_group_symbol="Pmmm"),
      wavelength=test_wvl)
  xs.add_scatterer(xray.scatterer("Mo1", site=(0.5, 0.5, 0.5)))
  xs.add_scatterer(xray.scatterer("C2", site=(0.7, 0.7, 0.7)))
  xs1 = xs.deep_copy_scatterers()
  assert approx_equal(xs1.wavelength, test_wvl)
  xs1.set_inelastic_form_factors(xs1.wavelength, "sasaki")
  for sc in xs1.scatterers():
    assert sc.flags.use_fp_fdp() == True
    assert sc.fp != 0
    assert sc.fdp != 0
    sc_sasaki = sasaki.table(sc.element_symbol())
    sc_fp_fdp_sasaki = sc_sasaki.at_angstrom(test_wvl)
    assert approx_equal(sc.fp, sc_fp_fdp_sasaki.fp())
    assert approx_equal(sc.fdp, sc_fp_fdp_sasaki.fdp())

  #
  xs = xray.structure(
    crystal_symmetry=crystal.symmetry(
      (5.01,5.01,5.47,90,90,120), "P6222"),
    scatterers=flex.xray_scatterer([
      xray.scatterer("Si", (1/2.,1/2.,1/3.)),
      xray.scatterer("C", (0.1234, 0.5432, 0.4321)),
      xray.scatterer("O", (0.197,-0.197,0.83333))]))
  s = StringIO()
  xs.show_scatterers(f=s)
  assert not show_diff(s.getvalue(), """\
Label, Scattering, Multiplicity, Coordinates, Occupancy, Uiso, Ustar as Uiso
Si   Si     3 ( 0.5000  0.5000  0.3333) 1.00 0.0000 [ - ]
C    C     12 ( 0.1234  0.5432  0.4321) 1.00 0.0000 [ - ]
O    O      6 ( 0.1970 -0.1970  0.8333) 1.00 0.0000 [ - ]
""")
  s = StringIO()
  xs.show_scatterers(f=s, special_positions_only=True)
  assert not show_diff(s.getvalue(), """\
Label, Scattering, Multiplicity, Coordinates, Occupancy, Uiso, Ustar as Uiso
Si   Si     3 ( 0.5000  0.5000  0.3333) 1.00 0.0000 [ - ]
O    O      6 ( 0.1970 -0.1970  0.8333) 1.00 0.0000 [ - ]
""")
  #
  xs.set_custom_inelastic_form_factors({'Si' : (-1,1), 'C' : (-2,2)},
                                       source="my source")
  xs_p1 = xs.customized_copy(
    space_group_info=sgtbx.space_group_info(symbol="P1"),
    non_unit_occupancy_implies_min_distance_sym_equiv_zero=True)
  assert xs_p1.space_group_info().type().number() == 1
  assert xs_p1.non_unit_occupancy_implies_min_distance_sym_equiv_zero()
  assert xs.scatterers()[0].fp == -1 or xs.scatterers()[0].fdp == 1
  assert xs.scatterers()[1].fp == -2 or xs.scatterers()[1].fdp == 2
  assert xs.scatterers()[2].fp == 0 or xs.scatterers()[2].fdp == 0
  assert xs.scatterers()[0].flags.use_fp_fdp() and\
         xs.scatterers()[1].flags.use_fp_fdp() and\
         not xs.scatterers()[2].flags.use_fp_fdp()
  assert xs_p1.inelastic_form_factors_source == xs.inelastic_form_factors_source
  assert xs_p1.inelastic_form_factors_source == "my source"
  xs_p1.erase_scatterers()
  assert not xs_p1.inelastic_form_factors_source


def exercise_closest_distances():
  xs = random_structure.xray_structure(
    space_group_info = sgtbx.space_group_info("P1"),
    elements         = ["N"]*3,
    unit_cell        = (10, 20, 30, 70, 80, 120))
  xs_other = xs.deep_copy_scatterers()
  result = xs.closest_distances(sites_frac = xs_other.sites_frac(),
    distance_cutoff = 6)
  assert approx_equal(result.smallest_distances, [0.0, 0.0, 0.0])
  xs_other = xs_other.translate(x=1,y=2,z=3)
  result = xs.closest_distances(sites_frac = xs_other.sites_frac(),
    distance_cutoff = 6)
  assert not_approx_equal(result.smallest_distances, [0.0, 0.0, 0.0])

def exercise_set_occupancies():
  xs = random_structure.xray_structure(
    space_group_info = sgtbx.space_group_info("P1"),
    elements         = ["N"]*5,
    unit_cell        = (10, 20, 30, 70, 80, 120))
  occ = xs.scatterers().extract_occupancies()
  assert occ.all_eq(1.0)
  xs.set_occupancies(value = 2)
  occ = xs.scatterers().extract_occupancies()
  assert occ.all_eq(2.0)
  xs.set_occupancies(
    value = -1, selection = flex.bool([True,True,False,True,False]))
  occ = xs.scatterers().extract_occupancies()
  assert approx_equal(occ, [-1.0, -1.0, 2.0, -1.0, 2.0])

def exercise_set_fps():
  xs = random_structure.xray_structure(
    space_group_info = sgtbx.space_group_info("P1"),
    elements         = ["N"]*5,
    unit_cell        = (10, 20, 30, 70, 80, 120))
  xs.set_inelastic_form_factors(1.54184, 'sasaki')
  fp = xs.scatterers().extract_fps()
  assert fp.all_approx_equal(0.029155200347304344)
  xs.set_fps(value = 2)
  fp = xs.scatterers().extract_fps()
  assert fp.all_eq(2.0)
  xs.set_fps(
    value = -1, selection = flex.bool([True,True,False,True,False]))
  fp = xs.scatterers().extract_fps()
  assert approx_equal(fp, [-1.0, -1.0, 2.0, -1.0, 2.0])

def exercise_set_fdps():
  xs = random_structure.xray_structure(
    space_group_info = sgtbx.space_group_info("P1"),
    elements         = ["N"]*5,
    unit_cell        = (10, 20, 30, 70, 80, 120))
  xs.set_inelastic_form_factors(1.54184, 'sasaki')
  fdp = xs.scatterers().extract_fdps()
  assert fdp.all_approx_equal(0.018055198714137077)
  xs.set_fdps(value = 2)
  fdp = xs.scatterers().extract_fdps()
  assert fdp.all_eq(2.0)
  xs.set_fdps(
    value = -1, selection = flex.bool([True,True,False,True,False]))
  fdp = xs.scatterers().extract_fdps()
  assert approx_equal(fdp, [-1.0, -1.0, 2.0, -1.0, 2.0])


def exercise_u_base():
  d_min = 9
  grid_resolution_factor = 1/3.
  for quality_factor in (1,2,4,8,10,100,200,1000):
    u_base = xray.calc_u_base(d_min, grid_resolution_factor, quality_factor)
    assert approx_equal(
      quality_factor,
      xray.structure_factors.quality_factor_from_any(
        d_min=d_min,
        grid_resolution_factor=grid_resolution_factor,
        u_base=u_base))
    assert approx_equal(
      quality_factor,
      xray.structure_factors.quality_factor_from_any(
        d_min=d_min,
        grid_resolution_factor=grid_resolution_factor,
        b_base=adptbx.u_as_b(u_base)))
    assert approx_equal(
      quality_factor,
      xray.structure_factors.quality_factor_from_any(
        quality_factor=quality_factor))
  #
  cs = crystal.symmetry((10, 20, 30, 90, 90, 90), "P 1")
  sp = crystal.special_position_settings(cs)
  uc = cs.unit_cell()
  scatterers = flex.xray_scatterer((
    xray.scatterer("o", site=(0.5, 0, 0),u=1.0),
    xray.scatterer("o", site=(0.5, 1.0, 0),u=0.1),
    xray.scatterer("o", site=(0.5, 1.0, 10),u=0.7),
    xray.scatterer("n", site=(0.5,-1.0, 0),u=adptbx.u_cart_as_u_star(uc,(1,2,3,0,0,0))),
    xray.scatterer("c", site=(0, 0, 0),u=adptbx.u_cart_as_u_star(uc,(6,7,9,0,0,0)))))
  xs = xray.structure(sp, scatterers)
  assert xs.n_grad_u_iso()==0
  assert xs.n_grad_u_aniso()==0
  xray.set_scatterer_grad_flags(scatterers = xs.scatterers(),
                                u_iso      = True,
                                u_aniso    = True)
  assert xs.n_grad_u_iso()==3
  assert xs.n_grad_u_aniso()==2
  assert xs.use_u_iso().count(True) == 3
  assert xs.use_u_aniso().count(True) == 2
  answer = [(1.0, 1.0, 1.0), (0.1, 0.1, 0.1), (0.7, 0.7, 0.7), (3., 2., 1.),
            (9., 7., 6.)]
  assert approx_equal(answer, list(xs.scatterers().u_cart_eigenvalues(uc)))
  assert approx_equal(list(xs.scatterers().anisotropy(uc)),
                      [1.0, 1.0, 1.0, 1./3, 6./9])

def exercise_from_scatterers_direct(space_group_info,
                                    element_type,
                                    allow_mix,
                                    n_elements=5,
                                    volume_per_atom=1000,
                                    d_min=3,
                                    anomalous_flag=0,
                                    use_u_iso =0,
                                    use_u_aniso =0,
                                    verbose=0):
  structure = random_structure.xray_structure(
    space_group_info,
    elements=[element_type]*n_elements,
    volume_per_atom=volume_per_atom,
    min_distance=5,
    general_positions_only=True,
    random_f_prime_d_min=d_min-1,
    random_f_prime_scale=0.6,
    random_f_double_prime=anomalous_flag,
    use_u_iso = True,
    use_u_aniso = True,
    random_u_iso = True,
    random_u_iso_scale=.3,
    random_u_cart_scale=.3,
    random_u_iso_min = 0.0,
    random_occupancy=True)
  random_structure.random_modify_adp_and_adp_flags_2(
    scatterers         = structure.scatterers(),
    use_u_iso          = use_u_iso,
    use_u_aniso        = use_u_aniso,
    allow_mix          = allow_mix)
  if (0 or verbose):
    structure.show_summary().show_scatterers()
  f_obs_exact = structure.structure_factors(
    d_min=d_min, algorithm="direct",
    cos_sin_table=False).f_calc()
  assert f_obs_exact.anomalous_flag() == anomalous_flag
  f_obs_simple = xray.ext.structure_factors_simple(
    f_obs_exact.unit_cell(),
    f_obs_exact.space_group(),
    f_obs_exact.indices(),
    structure.scatterers(),
    structure.scattering_type_registry()).f_calc()
  if (0 or verbose):
    for i,h in enumerate(f_obs_exact.indices()):
      print(h)
      print(f_obs_simple[i])
      print(f_obs_exact.data()[i])
      if (abs(f_obs_simple[i]-f_obs_exact.data()[i]) >= 1.e-10):
        print("MISMATCH")
      print()
  mismatch = flex.max(flex.abs(f_obs_exact.data() - f_obs_simple))
  assert mismatch < 1.e-10, mismatch
  f_obs_table = f_obs_exact.structure_factors_from_scatterers(
    xray_structure=structure,
    algorithm="direct",
    cos_sin_table=True).f_calc()
  ls = xray.targets_least_squares_residual(
    abs(f_obs_exact).data(), f_obs_table.data(), False, 1)
  if (0 or verbose):
    print("r-factor:", ls.target())
  assert ls.target() < 1.e-4

def exercise_f_obs_minus_xray_structure_f_calc(
  space_group_info,
  d_min=3,
  verbose=0):
  structure = random_structure.xray_structure(
    space_group_info,
    elements=["C"]*3,
    volume_per_atom=1000,
    min_distance=5,
    general_positions_only=True,
    random_u_iso=False)
  if (0 or verbose):
    structure.show_summary().show_scatterers()
  f_obs_exact = structure.structure_factors(
    d_min=d_min, algorithm="direct",
    cos_sin_table=False).f_calc()
  two_f_obs_minus_f_calc=abs(f_obs_exact).f_obs_minus_xray_structure_f_calc(
    f_obs_factor=2,
    xray_structure=structure,
    structure_factor_algorithm="direct",
    cos_sin_table=False)
  phase_error = two_f_obs_minus_f_calc.mean_weighted_phase_error(
    phase_source=f_obs_exact)
  if (0 or verbose):
    print("%.2f" % phase_error)
  assert approx_equal(phase_error, 0)
  two_f_obs_minus_f_calc=abs(f_obs_exact).f_obs_minus_xray_structure_f_calc(
    f_obs_factor=2,
    xray_structure=structure[:-1],
    structure_factor_algorithm="direct",
    cos_sin_table=False)
  fft_map = two_f_obs_minus_f_calc.fft_map()
  fft_map.apply_sigma_scaling()
  real_map = fft_map.real_map_unpadded()
  density_at_sites = [real_map.eight_point_interpolation(scatterer.site)
                      for scatterer in structure.scatterers()]
  try:
    assert min(density_at_sites[:-1]) > 6.9
    assert density_at_sites[-1] > 2.5
  except AssertionError:
    print("density_at_sites:", density_at_sites)
    raise
  sites_cart = structure.sites_cart()
  sites_frac = structure.sites_frac()
  density_at_sites_tricubic = [real_map.tricubic_interpolation(scatterer.site)
                      for scatterer in structure.scatterers()]
  try:
    assert min(density_at_sites_tricubic[:-1]) > 6.9
    assert density_at_sites_tricubic[-1] > 2.5
  except AssertionError:
    print("density_at_sites_tricubic:", density_at_sites_tricubic)
    raise

def exercise_n_gaussian(space_group_info, verbose=0):
  structure_5g = random_structure.xray_structure(
    space_group_info,
    elements=["H", "C", "N", "O", "S"]*3)
  if (0 or verbose):
    structure_5g.show_summary().show_scatterers()
  structure_4g = structure_5g.deep_copy_scatterers()
  structure_2g = structure_5g.deep_copy_scatterers()
  structure_5g.scattering_type_registry(table="wk1995")
  structure_4g.scattering_type_registry(table="it1992")
  structure_2g.scattering_type_registry(
    custom_dict=eltbx.xray_scattering.two_gaussian_agarwal_isaacs.table)
  for gaussian in \
      structure_5g.scattering_type_registry().unique_gaussians_as_list():
    assert gaussian.n_terms() == 5
  for gaussian in \
      structure_4g.scattering_type_registry().unique_gaussians_as_list():
    assert gaussian.n_terms() == 4
  for gaussian in \
      structure_2g.scattering_type_registry().unique_gaussians_as_list():
    assert gaussian.n_terms() == 2
  d_min = 1
  f_calc_5g = structure_5g.structure_factors(
    d_min=d_min,
    algorithm="direct",
    cos_sin_table=False).f_calc()
  f_calc_4g = f_calc_5g.structure_factors_from_scatterers(
    xray_structure=structure_4g,
    algorithm="direct",
    cos_sin_table=False).f_calc()
  f_calc_2g = f_calc_5g.structure_factors_from_scatterers(
    xray_structure=structure_2g,
    algorithm="direct",
    cos_sin_table=False).f_calc()
  for n,f_calc_ng in ((4,f_calc_4g), (2,f_calc_2g)):
    ls = xray.targets_least_squares_residual(
      abs(f_calc_5g).data(), f_calc_ng.data(), False, 1)
    if (0 or verbose):
      print("%d-gaussian r-factor:" % n, ls.target())
    if (n == 2):
      assert ls.target() < 0.002
    else:
      assert ls.target() < 0.0002
  #
  for element in ["H", "D", "T"]:
    structure = random_structure.xray_structure(
      space_group_info, elements=[element])
    ugs = structure.scattering_type_registry(table="n_gaussian") \
        .unique_gaussians_as_list()
    assert len(ugs) == 1
    assert ugs[0].n_terms() == 6
    s = StringIO()
    ugs[0].show(f=s)
    assert not show_diff(s.getvalue(), """\
a: -1.0938988 0.76752101 0.44291771 0.42681501 0.35006501 0.10647464
b: 1.7298482 2.0196679 1.4769121 9.3088777 20.966682 44.631255
c: 0
""")
    ugs = structure.scattering_type_registry(table="it1992") \
        .unique_gaussians_as_list()
    assert len(ugs) == 1
    assert ugs[0].n_terms() == 4
    s = StringIO()
    ugs[0].show(f=s)
    assert not show_diff(s.getvalue(), """\
a: 0.493002 0.32291201 0.140191 0.04081
b: 10.5109 26.1257 3.14236 57.799702
c: 0.0030380001
""")
    ugs = structure.scattering_type_registry(table="wk1995") \
        .unique_gaussians_as_list()
    assert len(ugs) == 1
    assert ugs[0].n_terms() == 5
    s = StringIO()
    ugs[0].show(f=s)
    assert not show_diff(s.getvalue().replace("e-005","e-05"), """\
a: -0.11710366 0.0093485946 0.27006859 0.28434139 0.5528717
b: 3.0598466 0.74655777 3.2917862 32.645653 11.546356
c: 0
""")

def run_call_back(flags, space_group_info):
  if (1):
    for element_type in ("Se", "const"):
      for anomalous_flag in [0,1]:
        for (use_u_iso,use_u_aniso) in [(True,True),(False,True),
                                        (True,False),(False,False)]:
          for with_shift in [0,1]:
            if (with_shift):
              sgi = debug_utils.random_origin_shift(space_group_info)
            else:
              sgi = space_group_info
            for allow_mix in [False, True]:
              exercise_from_scatterers_direct(
                space_group_info=sgi,
                element_type=element_type,
                anomalous_flag=anomalous_flag,
                use_u_iso = use_u_iso,
                use_u_aniso = use_u_aniso,
                verbose=flags.Verbose,
                allow_mix = allow_mix)
  if (1):
    exercise_n_gaussian(
      space_group_info=space_group_info)
  if (1):
    exercise_f_obs_minus_xray_structure_f_calc(
      space_group_info=space_group_info)

def exercise_concatenate_inplace():
  cs = crystal.symmetry((10, 20, 30, 90, 90, 90), "P 1")
  sp = crystal.special_position_settings(cs)
  scatterers = flex.xray_scatterer((
    xray.scatterer("o", (0.5, 0, 0)),
    xray.scatterer("c", (0, 0, 0))))
  xs = xray.structure(sp, scatterers)
  #
  custom_gaussians = {
    "X1": eltbx.xray_scattering.gaussian(
      [1], [2], 0),
    "Z1": eltbx.xray_scattering.gaussian(
      (1,2), (3,5), 0),
  }
  new_scatterers = flex.xray_scatterer()
  new_scatterers.append(xray.scatterer(
    label = "X1", scattering_type = "X1", site=(1,2,3), u=1.1, occupancy=0.5))
  new_scatterers.append(xray.scatterer(
    label = "Z1", scattering_type = "Z1", site=(4,5,6), u=9.1, occupancy=1.5))
  xs1 = xray.structure(sp, new_scatterers)
  xs1.scattering_type_registry(custom_dict=custom_gaussians)
  ##
  out = StringIO()
  xs.concatenate_inplace(other = xs1)
  xs.scattering_type_registry().show(out=out)
  expected_result = """\
Number of scattering types: 4
  Type Number    sf(0)   Gaussians
   O       1      8.00       6
   C       1      6.00       6
   Z1      1      3.00       2
   X1      1      1.00       1
  sf(0) = scattering factor at diffraction angle 0.
"""
  assert out.getvalue() == expected_result
  #
  out = sys.stdout
  sys.stdout = StringIO()
  try:
    custom_gaussians = {"C": eltbx.xray_scattering.gaussian([1],[2], 0)}
    new_scatterers = flex.xray_scatterer()
    new_scatterers.append(xray.scatterer(
      label = "C", scattering_type = "C", site=(7,8,9), u=0.1, occupancy=1.1))
    xs1 = xray.structure(sp, new_scatterers)
    xs1.scattering_type_registry(custom_dict = custom_gaussians)
    xs.concatenate_inplace(other = xs1)
    xs.scattering_type_registry().show()
  except Exception as e:
    assert str(e) == "Cannot concatenate: conflicting scatterers"
  sys.stdout = out
  #
  assert set([(r.scattering_type, r.count, "%.1f" % r.occupancy_sum)
    for r in xs.scattering_types_counts_and_occupancy_sums()])\
      == set([('C', 1, "1.0"), ('X1', 1, "0.5"), ('Z1', 1, "1.5"), ('O', 1, "1.0")])

def exercise_min_u_cart_eigenvalue():
  cs = crystal.symmetry((1, 1, 1, 90, 90, 90), "P 1")
  sp = crystal.special_position_settings(cs)
  a = flex.xray_scatterer()
  assert a.size() == 0
  s1 = xray.scatterer(label = "C", u = -0.0278)
  s2 = xray.scatterer(label = "C", u = -10.0)
  s2.flags.set_use_u_iso(False)
  s3 = xray.scatterer(label = "C", u = (1,1,1,1,1,1))
  s4 = xray.scatterer(label = "C", u = (-91,1,1,1,1,1))
  s4.flags.set_use_u_aniso(False)
  s5 = xray.scatterer(label = "C", u = 0.1)
  s5.u_star=(1,1,1,1,1,1)
  s5.flags.set_use_u_aniso(True)
  s6 = xray.scatterer(label = "C", u = 0.1)
  s6.u_star=(1,1,1,1,1,1)
  s7 = xray.scatterer(label = "C", u = (1,1,1,1,1,1))
  s7.u_iso=0.1
  s8 = xray.scatterer(label = "C", u = (1,1,1,1,1,1))
  s8.u_iso=0.1
  s8.flags.set_use_u_iso(True)
  s9 = xray.scatterer(label = "C")
  s10 = xray.scatterer(label = "C")
  s10.flags.set_use_u_iso(False)
  scatterers = flex.xray_scatterer((s1,s2,s3,s4,s5,s6,s7,s8,s9,s10))
  xs = xray.structure(sp, scatterers)
  assert approx_equal(xs.min_u_cart_eigenvalue(), -0.0278)

def exercise_replace_sites():
  cs = crystal.symmetry((10, 10, 10, 90, 90, 90), "P 1")
  sp = crystal.special_position_settings(cs)
  scatterers = flex.xray_scatterer(
    [xray.scatterer("c", (-1, -1, -1))])
  xrs = xray.structure(sp, scatterers)
  #
  sites_cart = flex.vec3_double([(1,2,3)])
  xrs_ = xrs.replace_sites_cart(sites_cart)
  assert approx_equal(flex.mean(
    xrs_.sites_cart().as_double()-sites_cart.as_double()), 0)
  assert approx_equal(flex.mean(
    xrs_.sites_frac().as_double()-flex.double([0.1,0.2,0.3])), 0)
  #
  sites_frac = flex.vec3_double([(0.1,0.2,0.3)])
  xrs_ = xrs.replace_sites_frac(sites_frac)
  assert approx_equal(flex.mean(
    xrs_.sites_frac().as_double()-sites_frac.as_double()), 0)
  assert approx_equal(flex.mean(
    xrs_.sites_cart().as_double()-flex.double([1,2,3])), 0)

def exercise_add_scatterer_insert():
  cs = crystal.symmetry((10, 20, 30, 90, 90, 90), "P 2")
  sp = crystal.special_position_settings(cs)
  xs = xray.structure(sp, scatterers=flex.xray_scatterer((
    xray.scatterer("c", site=(0.5,0,0.1)),
    xray.scatterer("o", site=(0.5,0,0.2)),
    xray.scatterer("n", site=(0.0,2,1.0)),
    xray.scatterer("p", site=(0.5,0,0.3)),
    xray.scatterer("s", site=(0.5,0,0.5)))))
  n_sites = xs.scatterers().size()
  scatterer = xray.scatterer("zn", site=(0,0,0))
  ls = [sc.label for sc in xs.scatterers()]
  ss = [str(xs.site_symmetry_table().get(i_seq).special_op())
    for i_seq in range(n_sites)]
  for i_seq in range(n_sites+1):
    xsw = xs.deep_copy_scatterers()
    xsw.add_scatterer(scatterer=scatterer, insert_at_index=i_seq)
    lsw = list(ls)
    lsw.insert(i_seq, "zn")
    assert lsw == [sc.label for sc in xsw.scatterers()]
    ssw = list(ss)
    ssw.insert(i_seq, "0,y,0")
    assert ssw == [str(xsw.site_symmetry_table().get(i_seq).special_op())
      for i_seq in range(n_sites+1)]

def exercise_select_on_name_or_chemical_element():
  cs = crystal.symmetry((5,7,9, 90, 120, 90), 'P2')
  xs = xray.structure(crystal.special_position_settings(cs),
                      scatterers=flex.xray_scatterer((
    xray.scatterer("C1", site=(0,0,0)),
    xray.scatterer("C2", site=(0.5,0,0)),
    xray.scatterer("C3", site=(0,0.5,0)),
    xray.scatterer("O1", site=(0,0,0.5)),
    xray.scatterer("C4", site=(0.2,0,0)),
    xray.scatterer("N1", site=(0,0.2,0)),
    )))
  sel = xs.element_selection('O', 'N')
  assert tuple(sel) == (0, 0, 0, 1, 0, 1)

def exercise_chemical_formula():
  cs = crystal.symmetry((10,10,10, 90,90,90), 'hall: P 2 2 3')
  xs = xray.structure(crystal.special_position_settings(cs),
                      scatterers=flex.xray_scatterer((
    xray.scatterer('C1', site=(0,0,0)),
    xray.scatterer("C2", site=(0.5,0,0), occupancy=0.2),
    xray.scatterer("C2'", site=(0.5,0,0), occupancy=0.8),
    xray.scatterer("C3", site=(0,0.5,0)),
    xray.scatterer("O1", site=(0,0,0.5)),
    xray.scatterer("C4", site=(0.2,0,0)),
    xray.scatterer("N1", site=(0,0.2,0)),
    )))
  unit_cell_content = {'C':13, 'O':3, 'N':6}
  assert xs.unit_cell_content() == unit_cell_content
  assert approx_equal(xs.f_000(), 144, eps=1e-2)
  xs.set_inelastic_form_factors(0.71073, "henke")
  assert approx_equal(xs.f_000(), 144, eps=1e-2)
  assert approx_equal(xs.f_000(include_inelastic_part=True), 144.116285145)
  del unit_cell_content['C']
  assert xs.unit_cell_content(omit=set('C')) == unit_cell_content
  assert approx_equal(xs.crystal_density(), 0.47850314720502857)

def exercise_parameter_map():
  cs = crystal.symmetry((8,9,10, 85, 95, 105), "P1")
  xs = xray.structure(cs.special_position_settings())
  for i in range(5): xs.add_scatterer(xray.scatterer("C%i" % i))
  grad_site      = (True , False, False, True , False)
  grad_u_iso     = (False, True , True , False, True )
  grad_u_aniso   = (True , False, False, True , True )
  grad_occupancy = (False, True , True , False, False)
  grad_fp        = (True , True , False, False, False)
  grad_fdp       = (True , False, True , False, False)
  for sc, site, u_iso, u_aniso, occ, fp, fdp in zip(xs.scatterers(),
    grad_site, grad_u_iso, grad_u_aniso, grad_occupancy, grad_fp, grad_fdp):
    f = sc.flags
    f.set_grad_site(site)
    f.set_use_u_iso(u_iso)
    f.set_grad_u_iso(u_iso)
    f.set_use_u_aniso(u_aniso)
    f.set_grad_u_aniso(u_aniso)
    f.set_grad_occupancy(occ)
    f.set_grad_fp(fp)
    f.set_grad_fdp(fdp)
  m1 = xs.parameter_map()
  twins = (xray.twin_component(sgtbx.rot_mx((1,0,0,0,1,0,0,0,-1)),0.5, True),
           xray.twin_component(sgtbx.rot_mx((-1,0,0,0,-1,0,0,0,-1)), 0.2, False))
  m2 = xray.parameter_map(xs.scatterers())
  for t in twins:
    if t.grad:
      m2.add_independent_scalar()
  assert m1.n_parameters == xs.n_parameters()
  assert m2.n_parameters == xs.n_parameters()+1

  for m in (m1, m2):
    indices = m[0]
    assert indices.site == 0
    assert indices.u_iso == xray.parameter_indices.invariable
    assert indices.u_aniso == 3
    assert indices.occupancy == xray.parameter_indices.invariable
    assert indices.fp == 9
    assert indices.fdp == 10

    indices = m[1]
    assert indices.site == xray.parameter_indices.invariable
    assert indices.u_iso == 11
    assert indices.u_aniso == xray.parameter_indices.invariable
    assert indices.occupancy == 12
    assert indices.fp == 13
    assert indices.fdp == xray.parameter_indices.invariable

    for i, indices in enumerate(m):
      assert indices.site == m[i].site
      assert indices.u_iso == m[i].u_iso
      assert indices.u_aniso == m[i].u_aniso
      assert indices.occupancy == m[i].occupancy
      assert indices.fp == m[i].fp
      assert indices.fdp == m[i].fdp


def exercise_xray_structure_as_py_code():
  xs = xray.structure(
    crystal_symmetry=crystal.symmetry((2, 2, 3, 90, 90, 80), "hall: P 2z"),
    scatterers=flex.xray_scatterer((
      xray.scatterer('C1', site=(0.5, 0.5, 0.5), u=0.1),
      xray.scatterer('O1', site=(0.1, 0.2, 0.3), u=(0.1, 0.2, 0.3,
                                                    0.4, 0.5, 0.6)),
      xray.scatterer('Fe', site=(-0.8, 0.2, 0), u=0.2,
                     scattering_type="Fe3+")
      )))
  pc = xs.as_py_code(indent="V")
  assert not show_diff(pc, """\
Vxray.structure(
V  crystal_symmetry=crystal.symmetry(
V    unit_cell=(2, 2, 3, 90, 90, 80),
V    space_group_symbol="P 1 1 2"
V  ),
V  scatterers=flex.xray_scatterer([
V    xray.scatterer( #0
V      label="C1",
V      site=(0.500000, 0.500000, 0.500000),
V      u=0.100000),
V    xray.scatterer( #1
V      label="O1",
V      site=(0.100000, 0.200000, 0.300000),
V      u=(0.100000, 0.200000, 0.300000,
V         0.400000, 0.500000, 0.600000)),
V    xray.scatterer( #2
V      label="Fe",
V      scattering_type="Fe3+",
V      site=(-0.800000, 0.200000, 0.000000),
V      u=0.200000)]))""")
  pc = xs.as_py_code()
  xs1 = eval(pc)
  assert xs.crystal_symmetry().is_similar_symmetry(
    xs1.crystal_symmetry(),
    relative_length_tolerance=0,
    absolute_angle_tolerance=0)
  for sc, sc1 in zip(xs.scatterers(), xs1.scatterers()):
    assert sc.flags.bits == sc1.flags.bits
    assert sc.site  == sc1.site
    if sc.flags.use_u_iso():
      assert sc.u_iso == sc1.u_iso
    if sc.flags.use_u_aniso():
      assert sc.u_star == sc1.u_star
    assert sc.occupancy == sc1.occupancy
    assert sc.fp  == sc1.fp
    assert sc.fdp == sc1.fdp

def exercise_delta_sites_cart_measure():
  rnd_delta = 1e-3
  for hall_symbol, continuously_shift in [
    ('P 2yb', lambda x,y,z: (x    , y+0.7, z)    ),
    ('P -2x', lambda x,y,z: (x    , y+0.9, z-0.7)),
    ('P 1'  , lambda x,y,z: (x+0.1, y+0.2, z+0.9)),
    ]:
    xs0 = random_structure.xray_structure(
      sgtbx.space_group_info('hall: %s' % hall_symbol),
      use_u_iso=False,
      use_u_aniso=True,
      n_scatterers=5,
      elements="random")
    xs1 = xs0.deep_copy_scatterers()
    delta = flex.vec3_double()
    for sc in xs1.scatterers():
      x, y, z = continuously_shift(*sc.site)
      dx, dy, dz = [ random.uniform(-rnd_delta, rnd_delta)
                     for i in range(3) ]
      delta.append((dx, dy, dz))
      sc.site = (x + dx, y + dy, z + dz)
    delta = flex.vec3_double([ xs0.unit_cell().orthogonalize(d)
                               for d in delta ])
    diff_ref = flex.max_absolute(delta.as_double())
    mscd = xray.meaningful_site_cart_differences(xs1=xs1, xs2=xs0)
    assert approx_equal(mscd.max_absolute(), diff_ref, eps=rnd_delta)

def exercise_discard_scattering_type_registry():
  cs = crystal.symmetry((5,7,9, 90, 120, 90), 'P2')
  xs_os = xray.structure(crystal.special_position_settings(cs),
    scatterers=flex.xray_scatterer((
      xray.scatterer(scattering_type="O", site=(0.0,0.0,0.0)),)))
  fc_os = xs_os.structure_factors(d_min=1, algorithm="direct").f_calc()
  xs_ss = xray.structure(crystal.special_position_settings(cs),
    scatterers=flex.xray_scatterer((
      xray.scatterer(scattering_type="S", site=(0.0,0.0,0.0)),)))
  fc_ss = xs_ss.structure_factors(d_min=1, algorithm="direct").f_calc()
  xs_os.scatterers()[0].scattering_type="S"
  failed = False
  try:
    fc_oss = xs_os.structure_factors(d_min=1, algorithm="direct").f_calc()
  except RuntimeError as e:
    assert str(e) == """scattering_type "S" not in scattering_type_registry."""
    failed = True
  assert failed
  xs_os.discard_scattering_type_registry()
  fc_oss = xs_os.structure_factors(d_min=1, algorithm="direct").f_calc()
  assert fc_ss.data().all_eq(fc_oss.data())

def exercise_select_within():
  xs = random_structure.xray_structure(
    space_group_info = sgtbx.space_group_info("P1"),
    elements         = ["N"]*100,
    unit_cell        = (10, 20, 30, 70, 80, 120))
  sw = xs.selection_within(radius=3,
    selection=flex.random_bool(xs.scatterers().size(), 0.3))
  assert sw.count(True) > 0
  assert sw.count(True) < 100

def exercise_guess_scattering_type_neutron():
  xs = random_structure.xray_structure(
    space_group_info = sgtbx.space_group_info("P1"),
    elements         = ["N","H","Mn","D","Mg","Au","K"]*5,
    unit_cell        = (10, 20, 30, 70, 80, 120))
  assert not xs.guess_scattering_type_neutron()
  xs.switch_to_neutron_scattering_dictionary()
  assert xs.guess_scattering_type_neutron()

def exercise_truncate_at_pdb_format_precision(d_min=2, n_repeats=1,
      algorithm = "direct"):
  for i in range(n_repeats):
    xrs = random_structure.xray_structure(
      space_group_info = sgtbx.space_group_info("P1"),
      elements=["H", "C", "O", "U", "Ca", "N", "Mg"]*50,
      volume_per_atom=50,
      min_distance=1.5,
      general_positions_only=True,
      use_u_iso = True,
      use_u_aniso = True,
      random_u_iso = True,
      random_occupancy=True)
    fc1 = xrs.structure_factors(d_min=d_min, algorithm=algorithm).f_calc()
    xrs.truncate_at_pdb_format_precision()
    fc2 = fc1.structure_factors_from_scatterers(xray_structure=xrs,
      algorithm=algorithm).f_calc()
    fc1 = abs(fc1).data()
    fc2 = abs(fc2).data()
    r = flex.sum(flex.abs(fc1-fc2))/flex.sum(flex.abs(fc1+fc2))*2*100
    assert r > 0.1

def run():
  exercise_truncate_at_pdb_format_precision()
  exercise_discard_scattering_type_registry()
  exercise_delta_sites_cart_measure()
  exercise_xray_structure_as_py_code()
  exercise_parameter_map()
  exercise_chemical_formula()
  exercise_select_on_name_or_chemical_element()
  exercise_add_scatterer_insert()
  exercise_replace_sites()
  exercise_min_u_cart_eigenvalue()
  exercise_set_occupancies()
  exercise_set_fps()
  exercise_set_fdps()
  exercise_closest_distances()
  exercise_concatenate_inplace()
  exercise_scatterer()
  exercise_anomalous_scatterer_group()
  exercise_structure()
  exercise_u_base()
  exercise_select_within()
  exercise_guess_scattering_type_neutron()
  debug_utils.parse_options_loop_space_groups(sys.argv[1:], run_call_back)

if (__name__ == "__main__"):
  run()


 *******************************************************************************
