

 *******************************************************************************
cctbx/xray/__init__.py
from __future__ import absolute_import, division, print_function
from cctbx.xray.ext import *
from cctbx.xray.observation_types import *
from cctbx.xray.scatterer import *
from cctbx.xray.structure import *
from cctbx.xray import structure_factors # implicit import
from cctbx.xray.target_functors import *
from cctbx.xray.minimization import *
from cctbx.xray import ext # implicit import


 *******************************************************************************


 *******************************************************************************
cctbx/xray/boost_python/tst_f_model.py
from __future__ import absolute_import, division, print_function
from cctbx.array_family import flex
from cctbx import xray
from cctbx import sgtbx
from libtbx.test_utils import approx_equal

import random
import math
from cctbx.development import random_structure as rs

random.seed(0)
flex.set_random_seed(0)

def compare_all(tmp1,tmp2):
  assert approx_equal( tmp1.ksol(),tmp2.ksol() )
  assert approx_equal( tmp1.usol(),tmp2.usol() )
  assert approx_equal( tmp1.kpart(),tmp2.kpart() )
  assert approx_equal( tmp1.upart(),tmp2.upart() )
  assert approx_equal( tmp1.koverall(),tmp2.koverall() )
  assert approx_equal( tmp1.ustar(), tmp2.ustar() )

def tst_f_model_derivative_holder():
  dinfo = xray.f_model_core_data_derivative_holder()

  dinfo.ksol(1)
  dinfo.usol(1)
  dinfo.kpart(1)
  dinfo.upart(1)
  dinfo.koverall(1)
  dinfo.ustar( [1,1,1,1,1,1] )

  dinfo.accumulate( dinfo )
  assert( dinfo.ksol()==2 )
  assert( dinfo.usol()==2 )
  assert( dinfo.kpart()==2 )
  assert( dinfo.upart()==2 )
  assert( dinfo.koverall()==2 )
  assert( dinfo.ustar()==(2,2,2,2,2,2) )


def tst_f_model(this_hkl=123):
  tmp = rs.xray_structure(sgtbx.space_group_info( 'P1' ),
                          elements=['C']*310,
                          n_scatterers=310)

  sfs = tmp.structure_factors( False, 3.5,  ).f_calc()
  f_mod = xray.f_model_core_data( hkl = sfs.indices(),
                        f_atoms= sfs.data(),
                        f_mask = sfs.data(),
                        unit_cell = sfs.unit_cell(),
                        k_overall=1.0,
                        u_star=(0,0,0,0,0,0),
                        k_sol=1.0,
                        u_sol=1.0,
                        f_part=sfs.data(),
                        k_part=1.0,
                        u_part=1.0 )

  data1 = sfs.data()[this_hkl]
  hkl1 =  sfs.indices()[this_hkl]

  fbulk = f_mod.f_bulk()[this_hkl]
  fatoms = f_mod.f_atoms()[this_hkl]
  fpart = f_mod.f_part()[this_hkl]
  fmod = f_mod.f_model()[this_hkl]
  # we have unit scale now
  assert approx_equal( fmod, fbulk+fatoms+fpart )
  # get derivatives please
  #
  # make a mock target function: T=A^2 + B^2
  # dT/dF=2F
  # dT/dA=2A
  # dT/dB=2B
  f_model_data_complex = f_mod.f_model()
  fm = flex.double()
  a = flex.double()
  b = flex.double()

  for cmplx in f_model_data_complex:
    tmp_a=cmplx.real
    tmp_b=cmplx.imag
    fm.append( math.sqrt(tmp_a*tmp_a + tmp_b*tmp_b) )
    a.append( tmp_a )
    b.append( tmp_b )

  dtdf = 2.0*fm
  dtda = 2.0*a
  dtdb = 2.0*b

  gradient_flags=flex.bool([True,True,
                            True,True,
                            True,True])

  grads_f = f_mod.d_target_d_all(dtdf,gradient_flags)
  grads_ab = f_mod.d_target_d_all(dtda, dtdb,gradient_flags)
  compare_all(grads_ab,grads_f)

  f_mod = xray.f_model_core_data( hkl = sfs.indices(),
                        f_atoms= sfs.data(),
                        f_mask = sfs.data()*0.0,
                        unit_cell = sfs.unit_cell(),
                        k_overall=1.0,
                        u_star=(0,0,0,0,0,0),
                        k_sol=0.0,
                        u_sol=0.0,
                        f_part=sfs.data()*0.0,
                        k_part=0.0,
                        u_part=0.0 )
  f_mod.refresh()
  grad_123 = f_mod.d_target_d_all(0,1,this_hkl, gradient_flags)
  assert approx_equal( grad_123.koverall(),
                       f_mod.f_model()[this_hkl].imag/f_mod.koverall() )
  tps=19.7392088 # 2 pi^2
  h=hkl1[0]
  k=hkl1[1]
  l=hkl1[2]
  assert approx_equal( -2*tps*h*h*f_mod.f_model()[this_hkl].imag,
                       grad_123.ustar()[0] )
  assert approx_equal( -2*tps*k*k*f_mod.f_model()[this_hkl].imag,
                       grad_123.ustar()[1] )
  assert approx_equal( -2*tps*l*l*f_mod.f_model()[this_hkl].imag,
                       grad_123.ustar()[2] )
  assert approx_equal( -4*tps*h*k*f_mod.f_model()[this_hkl].imag,
                       grad_123.ustar()[3] )
  assert approx_equal( -4*tps*h*l*f_mod.f_model()[this_hkl].imag,
                       grad_123.ustar()[4] )
  assert approx_equal( -4*tps*k*l*f_mod.f_model()[this_hkl].imag,
                       grad_123.ustar()[5] )





  grad_123 = f_mod.d_target_d_all(1,0,this_hkl, gradient_flags)
  assert approx_equal( grad_123.koverall(),
                       f_mod.f_model()[this_hkl].real/f_mod.koverall() )
  tps=19.7392088
  h=hkl1[0]
  k=hkl1[1]
  l=hkl1[2]
  assert approx_equal( -2*tps*h*h*f_mod.f_model()[this_hkl].real,
                       grad_123.ustar()[0] )
  assert approx_equal( -2*tps*k*k*f_mod.f_model()[this_hkl].real,
                       grad_123.ustar()[1] )
  assert approx_equal( -2*tps*l*l*f_mod.f_model()[this_hkl].real,
                       grad_123.ustar()[2] )
  assert approx_equal( -4*tps*h*k*f_mod.f_model()[this_hkl].real,
                       grad_123.ustar()[3] )
  assert approx_equal( -4*tps*h*l*f_mod.f_model()[this_hkl].real,
                       grad_123.ustar()[4] )
  assert approx_equal( -4*tps*k*l*f_mod.f_model()[this_hkl].real,
                       grad_123.ustar()[5] )


  oldfm = xray.f_model_core_data( hkl = sfs.indices(),
                        f_atoms= sfs.data(),
                        f_mask = sfs.data()*1.0,
                        unit_cell = sfs.unit_cell(),
                        k_overall=1.0,
                        u_star=(0,0,0,0,0,0),
                        k_sol=1.0,
                        u_sol=1.0,
                        f_part=sfs.data()*1.0,
                        k_part=1.0,
                        u_part=1.0 )
  h=0.0001


  newfm = xray.f_model_core_data( hkl = sfs.indices(),
                        f_atoms= sfs.data(),
                        f_mask = sfs.data()*1.0,
                        unit_cell = sfs.unit_cell(),
                        k_overall=1.0,
                        u_star=(0,0,0,0,0,0),
                        k_sol=1.0,
                        u_sol=1.0,
                        f_part=sfs.data()*1.0,
                        k_part=1.0,
                        u_part=1.0 )


  newfm.renew_overall_scale_parameters(1.0+h, (0,0,0,0,0,0))
  newfm.refresh()

  tmp = oldfm.d_target_d_all(1,0,this_hkl,gradient_flags).koverall()
  tmp_d = ((oldfm.f_model()[this_hkl]-newfm.f_model()[this_hkl])/(-h)).real
  assert approx_equal( tmp,tmp_d,eps=1e-2 )
  newfm.renew_overall_scale_parameters(1, (0,0,0,0,0,0))

  newfm.renew_bulk_solvent_scale_parameters(1+h,1.0)
  tmp = oldfm.d_target_d_all(1,0,this_hkl,gradient_flags).ksol()
  tmp_d = ((oldfm.f_model()[this_hkl]-newfm.f_model()[this_hkl])/(-h)).real
  assert approx_equal( tmp,tmp_d,eps=1e-2 )
  newfm.renew_bulk_solvent_scale_parameters(1,1.0)

  newfm.renew_bulk_solvent_scale_parameters(1.0,1.0+h)
  tmp = oldfm.d_target_d_all(1,0,this_hkl,gradient_flags).usol()
  tmp_d = ((oldfm.f_model()[this_hkl]-newfm.f_model()[this_hkl])/(-h)).real
  assert approx_equal( tmp,tmp_d,eps=1e-2 )
  newfm.renew_bulk_solvent_scale_parameters(1.0,1.0)

  newfm.renew_bulk_solvent_scale_parameters(1+h,1.0)
  tmp = oldfm.d_target_d_all(0,1,this_hkl,gradient_flags).ksol()
  tmp_d = ((oldfm.f_model()[this_hkl]-newfm.f_model()[this_hkl])/(-h)).imag
  assert approx_equal( tmp,tmp_d,eps=1e-2 )
  newfm.renew_bulk_solvent_scale_parameters(1,1.0)

  newfm.renew_bulk_solvent_scale_parameters(1.0,1.0+h)
  tmp = oldfm.d_target_d_all(0,1,this_hkl,gradient_flags).usol()
  tmp_d = ((oldfm.f_model()[this_hkl]-newfm.f_model()[this_hkl])/(-h)).imag
  assert approx_equal( tmp,tmp_d,eps=1e-2 )
  newfm.renew_bulk_solvent_scale_parameters(1.0,1.0)


  newfm.renew_partial_structure_scale_parameters(1+h,1.0)
  tmp = oldfm.d_target_d_all(1,0,this_hkl,gradient_flags).kpart()
  tmp_d = ((oldfm.f_model()[this_hkl]-newfm.f_model()[this_hkl])/(-h)).real
  assert approx_equal( tmp,tmp_d,eps=1e-2 )
  newfm.renew_bulk_solvent_scale_parameters(1,1.0)

  newfm.renew_partial_structure_scale_parameters(1.0,1.0+h)
  tmp = oldfm.d_target_d_all(1,0,this_hkl,gradient_flags).upart()
  tmp_d = ((oldfm.f_model()[this_hkl]-newfm.f_model()[this_hkl])/(-h)).real
  assert approx_equal( tmp,tmp_d,eps=1e-2 )
  newfm.renew_bulk_solvent_scale_parameters(1.0,1.0)

  newfm.renew_partial_structure_scale_parameters(1+h,1.0)
  tmp = oldfm.d_target_d_all(0,1,this_hkl,gradient_flags).kpart()
  tmp_d = ((oldfm.f_model()[this_hkl]-newfm.f_model()[this_hkl])/(-h)).imag
  assert approx_equal( tmp,tmp_d,eps=1e-2 )
  newfm.renew_bulk_solvent_scale_parameters(1,1.0)

  newfm.renew_partial_structure_scale_parameters(1.0,1.0+h)
  tmp = oldfm.d_target_d_all(0,1,this_hkl,gradient_flags).upart()
  tmp_d = ((oldfm.f_model()[this_hkl]-newfm.f_model()[this_hkl])/(-h)).imag
  assert approx_equal( tmp,tmp_d,eps=1e-2 )
  newfm.renew_bulk_solvent_scale_parameters(1.0,1.0)


def run():
  tst_f_model(123)
  tst_f_model(44)
  tst_f_model(50)
  tst_f_model(150)
  tst_f_model(153)
  tst_f_model_derivative_holder()


if (__name__ == "__main__"):
  run()
  print("OK")


 *******************************************************************************


 *******************************************************************************
cctbx/xray/boost_python/tst_targets_fd.py
from __future__ import absolute_import, division, print_function
from cctbx.xray import ext
from cctbx.array_family import flex
from libtbx.test_utils import approx_equal
from libtbx.math_utils import iceil
from itertools import count
import sys
from six.moves import range
from six.moves import zip

class random_inputs(object):

  def __init__(O, mt, n_refl, target_type, obs_type):
    O.target_type = target_type
    O.obs_type = obs_type
    O.obs = mt.random_double(size=n_refl)
    O.weights = mt.random_double(size=n_refl)
    rff = flex.bool(max(1,iceil(n_refl*0.6)), False)
    rff.resize(n_refl, True)
    O.r_free_flags = rff.select(mt.random_permutation(size=n_refl))
    O.scale_factor = 1 + mt.random_double()
    O.a = mt.random_double(size=n_refl)
    O.b = mt.random_double(size=n_refl)

  def get(O, derivatives_depth=0):
    if (O.target_type == "ls"):
      return ext.targets_least_squares(
        compute_scale_using_all_data=False,
        obs_type=O.obs_type,
        obs=O.obs,
        weights=O.weights,
        r_free_flags=O.r_free_flags,
        f_calc=flex.complex_double(O.a, O.b),
        derivatives_depth=derivatives_depth,
        scale_factor=O.scale_factor)
    if (O.target_type == "cc"):
      return ext.targets_correlation(
        obs_type=O.obs_type,
        obs=O.obs,
        weights=O.weights,
        r_free_flags=O.r_free_flags,
        f_calc=flex.complex_double(O.a, O.b),
        derivatives_depth=derivatives_depth)
    raise RuntimeError("Unknown target_type.")

  def gradients_work_fd(O, eps=1.e-6):
    result = flex.complex_double()
    for ih,a,b,f in zip(count(), O.a, O.b, O.r_free_flags):
      if (f): continue
      def fd(x, Ox):
        fs = []
        for signed_eps in [eps, -eps]:
          Ox[ih] = x + signed_eps
          fs.append(O.get(derivatives_depth=0).target_work())
        Ox[ih] = x
        return (fs[0]-fs[1])/(2*eps)
      result.append(complex(fd(a, O.a), fd(b, O.b)))
    return result

  def hessians_work_fd(O, eps=1.e-6):
    result = flex.vec3_double()
    for ih,a,b,f in zip(count(), O.a, O.b, O.r_free_flags):
      if (f): continue
      def fd(x, Ox, ri):
        fs = []
        for signed_eps in [eps, -eps]:
          Ox[ih] = x + signed_eps
          ga = O.get(derivatives_depth=1).gradients_work()
          fs.append(getattr(ga[len(result)], ri))
        Ox[ih] = x
        return (fs[0]-fs[1])/(2*eps)
      daa = fd(a, O.a, "real")
      dbb = fd(b, O.b, "imag")
      dab = fd(a, O.a, "imag")
      dba = fd(b, O.b, "real")
      assert approx_equal(dab, dba)
      result.append((daa, dbb, dab))
    return result

def exercise_random(n_trials=10, n_refl=30):
  mt = flex.mersenne_twister(seed=0)
  for target_type in ["ls", "cc"]:
    for i_trial in range(n_trials):
      for obs_type in ["F", "I"]:
        ri = random_inputs(
          mt=mt, n_refl=n_refl, target_type=target_type, obs_type=obs_type)
        tg = ri.get(derivatives_depth=2)
        ga = tg.gradients_work()
        gf = ri.gradients_work_fd()
        assert approx_equal(ga, gf)
        ca = tg.hessians_work()
        cf = ri.hessians_work_fd()
        assert approx_equal(ca, cf)

def exercise_singular_least_squares():
  obs = flex.double([1.234])
  weights_2345 = flex.double([2.345])
  weights_zero = flex.double([0])
  r_free_flags = flex.bool([False])
  a = flex.double([0])
  b = flex.double([0])
  for obs_type in ["F", "I"]:
    for weights,scale_factor in [
          (weights_2345, 3.456),
          (weights_zero, 0)]:
      tg = ext.targets_least_squares(
        compute_scale_using_all_data=False,
        obs_type=obs_type,
        obs=obs,
        weights=weights,
        r_free_flags=r_free_flags,
        f_calc=flex.complex_double(a, b),
        derivatives_depth=2,
        scale_factor=scale_factor)
      if (weights is weights_2345):
        assert approx_equal(tg.scale_factor(), scale_factor)
        assert list(tg.gradients_work()) == [0j]
        assert list(tg.hessians_work()) == [(1,1,1)]
      else:
        assert tg.scale_factor() is None
        assert tg.target_work() is None
        assert tg.target_test() is None
        assert tg.gradients_work().size() == 0
        assert tg.hessians_work().size() == 0

def exercise_singular_correlation():
  def check():
    for obs_type in ["F", "I"]:
      tg = ext.targets_correlation(
        obs_type=obs_type,
        obs=obs,
        weights=weights,
        r_free_flags=None,
        f_calc=flex.complex_double(a, b),
        derivatives_depth=2)
      assert tg.cc() is None
      assert tg.target_work() is None
      assert tg.target_test() is None
      assert tg.gradients_work().size() == 0
      assert tg.hessians_work().size() == 0
  obs = flex.double([1.234])
  weights = None
  a = flex.double([0])
  b = flex.double([0])
  check()
  obs = flex.double([1.234, 2.345])
  a = flex.double([1, 1])
  b = flex.double([2, 2])
  check()
  weights = flex.double([0,0])
  a = flex.double([1, 2])
  b = flex.double([3, 4])
  check()

def run(args):
  assert len(args) == 0
  exercise_random()
  exercise_singular_least_squares()
  exercise_singular_correlation()
  print("OK")

if (__name__ == "__main__"):
  run(args=sys.argv[1:])


 *******************************************************************************


 *******************************************************************************
cctbx/xray/boost_python/tst_xray.py
from __future__ import absolute_import, division, print_function
from cctbx import uctbx
from cctbx import sgtbx
from cctbx import adptbx
from cctbx import eltbx
from cctbx import crystal
import cctbx.crystal.direct_space_asu
from cctbx import xray
from cctbx import math_module
from cctbx.array_family import flex
from scitbx.array_family import shared
from libtbx.test_utils import Exception_expected, approx_equal, \
  not_approx_equal, show_diff
from six.moves import cStringIO as StringIO
from six.moves import range
from six.moves import zip
from six.moves import cPickle as pickle

def exercise_scatterer_flags():
  f = xray.scatterer_flags()
  assert f.use()                      == True
  assert f.use_u_iso()                == False
  assert f.use_u_aniso()              == False
  assert f.grad_site()                == False
  assert f.grad_u_iso()               == False
  assert f.grad_u_aniso()             == False
  assert f.grad_occupancy()           == False
  assert f.grad_fp()                  == False
  assert f.grad_fdp()                 == False
  assert f.curv_site_site()           == False
  assert f.curv_site_u_iso()          == False
  assert f.curv_site_u_aniso()        == False
  assert f.curv_site_occupancy()      == False
  assert f.curv_site_fp()             == False
  assert f.curv_site_fdp()            == False
  assert f.curv_u_iso_u_iso()         == False
  assert f.curv_u_iso_u_aniso()       == False
  assert f.curv_u_iso_occupancy()     == False
  assert f.curv_u_iso_fp()            == False
  assert f.curv_u_iso_fdp()           == False
  assert f.curv_u_aniso_u_aniso()     == False
  assert f.curv_u_aniso_occupancy()   == False
  assert f.curv_u_aniso_fp()          == False
  assert f.curv_u_aniso_fdp()         == False
  assert f.curv_occupancy_occupancy() == False
  assert f.curv_occupancy_fp()        == False
  assert f.curv_occupancy_fdp()       == False
  assert f.curv_fp_fp()               == False
  assert f.curv_fp_fdp()              == False
  assert f.curv_fdp_fdp()             == False
  assert f.tan_u_iso()                == False
  assert f.param                      == 0
  for state in [True, False]:
    f.set_use(state)
    f.set_use_u_iso(state)
    f.set_use_u_aniso(state)
    f.set_grad_site(state)
    f.set_grad_u_iso(state)
    f.set_grad_u_aniso(state)
    f.set_grad_occupancy(state)
    f.set_grad_fp(state)
    f.set_grad_fdp(state)
    f.set_curv_site_site(state)
    f.set_curv_site_u_iso(state)
    f.set_curv_site_u_aniso(state)
    f.set_curv_site_occupancy(state)
    f.set_curv_site_fp(state)
    f.set_curv_site_fdp(state)
    f.set_curv_u_iso_u_iso(state)
    f.set_curv_u_iso_u_aniso(state)
    f.set_curv_u_iso_occupancy(state)
    f.set_curv_u_iso_fp(state)
    f.set_curv_u_iso_fdp(state)
    f.set_curv_u_aniso_u_aniso(state)
    f.set_curv_u_aniso_occupancy(state)
    f.set_curv_u_aniso_fp(state)
    f.set_curv_u_aniso_fdp(state)
    f.set_curv_occupancy_occupancy(state)
    f.set_curv_occupancy_fp(state)
    f.set_curv_occupancy_fdp(state)
    f.set_curv_fp_fp(state)
    f.set_curv_fp_fdp(state)
    f.set_curv_fdp_fdp(state)
    f.set_tan_u_iso(state)
    f.param = 42
    assert f.use()                      == state
    assert f.use_u_iso()                == state
    assert f.use_u_aniso()              == state
    assert f.grad_site()                == state
    assert f.grad_u_iso()               == state
    assert f.grad_u_aniso()             == state
    assert f.grad_occupancy()           == state
    assert f.grad_fp()                  == state
    assert f.grad_fdp()                 == state
    assert f.curv_site_site()           == state
    assert f.curv_site_u_iso()          == state
    assert f.curv_site_u_aniso()        == state
    assert f.curv_site_occupancy()      == state
    assert f.curv_site_fp()             == state
    assert f.curv_site_fdp()            == state
    assert f.curv_u_iso_u_iso()         == state
    assert f.curv_u_iso_u_aniso()       == state
    assert f.curv_u_iso_occupancy()     == state
    assert f.curv_u_iso_fp()            == state
    assert f.curv_u_iso_fdp()           == state
    assert f.curv_u_aniso_u_aniso()     == state
    assert f.curv_u_aniso_occupancy()   == state
    assert f.curv_u_aniso_fp()          == state
    assert f.curv_u_aniso_fdp()         == state
    assert f.curv_occupancy_occupancy() == state
    assert f.curv_occupancy_fp()        == state
    assert f.curv_occupancy_fdp()       == state
    assert f.curv_fp_fp()               == state
    assert f.curv_fp_fdp()              == state
    assert f.curv_fdp_fdp()             == state
    assert f.tan_u_iso()                == state
    assert f.param                      == 42

  f.set_use_u_iso(state=False)
  f.set_use_u_aniso(state=True)
  f.set_use_u_iso_only()
  assert f.use_u_iso()
  assert not f.use_u_aniso()
  assert f.use_u_iso_only()
  assert not f.use_u_aniso_only()
  f.set_use_u_aniso_only()
  assert not f.use_u_iso()
  assert f.use_u_aniso()
  assert not f.use_u_iso_only()
  assert f.use_u_aniso_only()
  f.set_use_u(iso=True, aniso=True)
  try: f.use_u_iso_only()
  except RuntimeError as e:
    assert not show_diff(str(e),
      "scatterer.flags.u_iso_only(): u_iso and u_aniso both true.")
  else: raise Exception_expected
  try: f.use_u_aniso_only()
  except RuntimeError as e:
    assert not show_diff(str(e),
      "scatterer.flags.u_aniso_only(): u_iso and u_aniso both true.")
  else: raise Exception_expected
  f.set_use_u(iso=False, aniso=False)
  try: f.use_u_iso_only()
  except RuntimeError as e:
    assert not show_diff(str(e),
      "scatterer.flags.u_iso_only(): u_iso and u_aniso both false.")
  else: raise Exception_expected
  try: f.use_u_aniso_only()
  except RuntimeError as e:
    assert not show_diff(str(e),
      "scatterer.flags.u_aniso_only(): u_iso and u_aniso both false.")
  else: raise Exception_expected

  f1 = xray.scatterer_flags()
  f1.set_grad_site(True)
  f1.set_grad_u_aniso(True)
  f1.set_grad_fp(True)
  f2 = xray.scatterer_flags()
  assert f2.implies(f1)
  f2.set_grad_site(True)
  f2.set_grad_u_aniso(True)
  f2.set_grad_fp(True)
  assert f2.implies(f1)
  f2.set_grad_u_iso(True)
  assert not f2.implies(f1)

  flags = xray.shared_scatterer_flags()
  f1 = xray.scatterer_flags()
  f1.set_use_u_iso(True)
  f1.set_grad_u_iso(True)
  f1.set_grad_fp(True)
  flags.append(f1)
  f2 = xray.scatterer_flags()
  f2.set_grad_site(True)
  f2.set_grad_u_aniso(True)
  flags.append(f2)
  assert flags[0].bits == f1.bits
  assert flags[1].bits == f2.bits
  for f in flags:
    f.set_grad_occupancy(True)
  assert flags[0].grad_occupancy()
  assert flags[1].grad_occupancy()
  assert flags.n_parameters() == 7

  x = xray.scatterer("C", site=(0.4, 0.5, 0.6))
  scatterers = flex.xray_scatterer(10, x)
  for sc in scatterers:
    sc.flags.set_grad_site(True)
    sc.flags.set_use_u_aniso(True)
    sc.flags.set_grad_u_aniso(True)
  grad_flags = xray.shared_scatterer_flags(scatterers)
  assert [ f.bits for f in grad_flags ] \
      == [ sc.flags.bits for sc in scatterers ]

def exercise_set_scatterer_grad_flags():
  x = xray.scatterer("c", site=(0.1,0.2,0.3), occupancy=0.0, u=(0,0,0,0,0,0))
  y = xray.scatterer("c", site=(0.1,0.2,0.3), occupancy=0.0, u=1.0)
  scatterers = flex.xray_scatterer(10, x)
  scatterers.extend(flex.xray_scatterer(10, y))
  for scatterer in scatterers:
      assert scatterer.flags.grad_site()      == False
      assert scatterer.flags.grad_u_iso()     == False
      assert scatterer.flags.grad_u_aniso()   == False
      assert scatterer.flags.grad_occupancy() == False
      assert scatterer.flags.grad_fp()        == False
      assert scatterer.flags.grad_fdp()       == False
      assert scatterer.flags.tan_u_iso()      == False
      assert scatterer.flags.param            == 0
  xray.set_scatterer_grad_flags(scatterers = scatterers)
  for scatterer in scatterers:
      assert scatterer.flags.grad_site()      == False
      assert scatterer.flags.grad_u_iso()     == False
      assert scatterer.flags.grad_u_aniso()   == False
      assert scatterer.flags.grad_occupancy() == False
      assert scatterer.flags.grad_fp()        == False
      assert scatterer.flags.grad_fdp()       == False
      assert scatterer.flags.tan_u_iso()      == False
      assert scatterer.flags.param            == 0
  cn1 = 0
  cn2 = 0
  for site in [True, False]:
    for u_iso in [True, False]:
      for u_aniso in [True, False]:
        for occupancy in [True, False]:
          for fp in [True, False]:
            for fdp in [True, False]:
              for tan_u_iso in [True, False]:
                for param in [0, 1, 2]:
                    xray.set_scatterer_grad_flags(scatterers = scatterers,
                                                  site       = site,
                                                  u_iso      = u_iso,
                                                  u_aniso    = u_aniso,
                                                  occupancy  = occupancy,
                                                  fp         = fp,
                                                  fdp        = fdp,
                                                  tan_u_iso  = tan_u_iso,
                                                  param      = param)
                    for scatterer in scatterers:
                        assert scatterer.flags.grad_site()      == site
                        if(scatterer.flags.use_u_iso()):
                           assert scatterer.flags.grad_u_iso()     == u_iso
                           assert scatterer.flags.grad_u_aniso()   == False
                           cn1+=1
                        if(scatterer.flags.use_u_aniso()):
                           assert scatterer.flags.grad_u_iso()     == False
                           assert scatterer.flags.grad_u_aniso()   == u_aniso
                           cn2+=1
                        assert scatterer.flags.grad_occupancy() == occupancy
                        assert scatterer.flags.grad_fp()        == fp
                        assert scatterer.flags.grad_fdp()       == fdp
                        assert scatterer.flags.param            == param
  assert cn1 != 0
  assert cn2 != 0
  xray.set_scatterer_grad_flags(scatterers = scatterers)
  for scatterer in scatterers:
      assert scatterer.flags.grad_site()      == False
      assert scatterer.flags.grad_u_iso()     == False
      assert scatterer.flags.grad_u_aniso()   == False
      assert scatterer.flags.grad_occupancy() == False
      assert scatterer.flags.grad_fp()        == False
      assert scatterer.flags.grad_fdp()       == False
      assert scatterer.flags.tan_u_iso()      == False
      assert scatterer.flags.param            == 0
  xray.set_scatterer_grad_flags(scatterers = scatterers,
                                fp         = True,
                                param      = -1)
  for scatterer in scatterers:
      assert scatterer.flags.grad_site()      == False
      assert scatterer.flags.grad_u_iso()     == False
      assert scatterer.flags.grad_u_aniso()   == False
      assert scatterer.flags.grad_occupancy() == False
      assert scatterer.flags.grad_fp()        == True
      assert scatterer.flags.grad_fdp()       == False
      assert scatterer.flags.tan_u_iso()      == False
      assert scatterer.flags.param            == -1
  sc0 = scatterers[0]
  for iso in [False, True]:
      for aniso in [True, False]:
          sc0.flags.set_use_u_iso(iso)
          sc0.flags.set_use_u_aniso(aniso)
          assert sc0.flags.use_u_iso() == iso
          assert sc0.flags.use_u_aniso() == aniso
          sc0.flags.set_use_u(iso = aniso, aniso = iso)
          assert sc0.flags.use_u_iso() == aniso
          assert sc0.flags.use_u_aniso() == iso
          if (iso): sc0.flags.set_use_u_iso_only()
          else:     sc0.flags.set_use_u_aniso_only()
          assert sc0.flags.use_u_iso() == iso
          assert sc0.flags.use_u_aniso() != iso
  for iso in [False, True]:
      for aniso in [True, False]:
          sc0.flags.set_use_u_iso(iso)
          sc0.flags.set_use_u_aniso(aniso)
          assert sc0.flags.use_u_iso() == iso
          assert sc0.flags.use_u_aniso() == aniso
          sc0.u_iso = 0.5
          sc0.u_star = [0.5,0.5,0.5,0.5,0.5,0.5]
          sc0.set_use_u(iso = aniso, aniso = iso)
          assert sc0.flags.use_u_iso() == aniso
          assert sc0.flags.use_u_aniso() == iso
          if(aniso == False): assert sc0.u_iso == -1.0
          if(iso == False): assert sc0.u_star == (-1.0,-1.0,-1.0,-1.0,-1.0,-1.0)
          if(aniso): assert sc0.u_iso == 0.5
          if(iso): assert sc0.u_star == (0.5,0.5,0.5,0.5,0.5,0.5)
          sc0.u_iso = 0.5
          sc0.u_star = [0.5,0.5,0.5,0.5,0.5,0.5]
          if (iso): sc0.set_use_u_iso_only()
          else:     sc0.set_use_u_aniso_only()
          assert sc0.flags.use_u_iso() == iso
          assert sc0.flags.use_u_aniso() != iso
          if(iso):
             assert sc0.u_iso == 0.5
             assert sc0.u_star == (-1.0,-1.0,-1.0,-1.0,-1.0,-1.0)
          else:
             assert sc0.u_iso == -1.0
             assert sc0.u_star == (0.5,0.5,0.5,0.5,0.5,0.5)

def exercise_set_selected_scatterer_grad_flags():
  x = xray.scatterer("c", site=(0.1,0.2,0.3), occupancy=0.0, u=(0,0,0,0,0,0))
  y = xray.scatterer("c", site=(0.1,0.2,0.3), occupancy=0.0, u=1.0)
  scatterers = flex.xray_scatterer(50, x)
  scatterers.extend(flex.xray_scatterer(50, y))
  mt = flex.mersenne_twister(seed=0)
  scatterers = scatterers.select(mt.random_permutation(size=100))
  def all_clear():
    for scatterer in scatterers:
      f = scatterer.flags
      if (f.grad_site()): return False
      if (f.grad_u_iso()): return False
      if (f.grad_u_aniso()): return False
      if (f.grad_occupancy()): return False
      if (f.grad_fp()): return False
      if (f.grad_fdp()): return False
    return True
  assert all_clear()
  xray.set_scatterer_grad_flags(scatterers=scatterers)
  assert all_clear()
  sels = {}
  for attr in "site u_iso u_aniso occupancy fp fdp".split():
    sels[attr] = mt.random_bool(size=100, threshold=0.5)
  for i_seq, scatterer in enumerate(scatterers):
    if (not scatterer.flags.use_u_iso()): sels["u_iso"][i_seq] = False
    if (not scatterer.flags.use_u_aniso()): sels["u_aniso"][i_seq] = False
  scatterers.flags_set_grads(state=False)
  assert all_clear()
  scatterers.flags_set_grads(state=True)
  assert not all_clear()
  for attr,sel in sels.items():
    scatterers.flags_set_grads(state=False)
    assert all_clear()
    getattr(scatterers, "flags_set_grad_"+attr)(iselection=sel.iselection())
    assert not all_clear()
    for scatterer,flag in zip(scatterers, sel):
      assert getattr(scatterer.flags, "grad_"+attr)() == flag

def exercise_scatterer_flags_counts():
  x = xray.scatterer("c", site=(0.1,0.2,0.3), occupancy=0.0, u=(0,0,0,0,0,0))
  scatterers = flex.xray_scatterer(10, x)
  manager = xray.scatterer_grad_flags_counts(scatterers)
  assert manager.site      == 0
  assert manager.u_iso     == 0
  assert manager.u_aniso   == 0
  assert manager.occupancy == 0
  assert manager.fp        == 0
  assert manager.fdp       == 0
  scatterers[1].flags.set_grad_site      (True)
  scatterers[1].flags.set_grad_u_iso     (True)
  scatterers[1].flags.set_grad_u_aniso   (True)
  scatterers[1].flags.set_grad_occupancy (True)
  scatterers[1].flags.set_grad_fp        (True)
  scatterers[1].flags.set_grad_fdp       (True)
  manager = xray.scatterer_grad_flags_counts(scatterers)
  #assert manager.site      == 1     #XXX
  #assert manager.u_iso     == 1     #XXX
  #assert manager.u_aniso   == 1     #XXX
  assert manager.occupancy == 1
  assert manager.fp        == 1
  assert manager.fdp       == 1

def exercise_conversions():
  d = flex.double((10,-1))
  s = flex.double((1,2))
  r = xray.array_f_sq_as_f_xtal_3_7(d, s)
  r = xray.array_f_sq_as_f_xtal_3_7(d, s, 1.e-6)
  assert approx_equal(r.f, (3.1622777, 0))
  assert approx_equal(r.sigma_f, (0.1543471, 1.4142136))
  r = xray.array_f_sq_as_f_xtal_3_7(d)
  assert approx_equal(r.f, (3.1622777, 0))
  assert r.sigma_f.size() == 0
  r = xray.array_f_sq_as_f_crystals(d, s)
  r = xray.array_f_sq_as_f_crystals(d, s, 1.e-6)
  assert approx_equal(r.f, (3.1622777, -1))
  assert approx_equal(r.sigma_f, (0.1581139, 2))
  r = xray.array_f_sq_as_f_crystals(d)
  assert approx_equal(r.f, (3.1622777, -1))
  assert r.sigma_f.size() == 0
  r = xray.array_f_as_f_sq(d, s)
  assert approx_equal(r.f_sq, (100, 1))
  assert approx_equal(r.sigma_f_sq, (20, -4))
  r = xray.array_f_as_f_sq(d)
  assert approx_equal(r.f_sq, (100, 1))
  assert r.sigma_f_sq.size() == 0

def exercise_gradient_flags():
  f = xray.ext.gradient_flags(
    False, True, False, True, False, True, False, True)
  assert not f.site
  assert f.u_iso
  assert not f.u_aniso
  assert f.occupancy
  assert not f.fp
  assert f.fdp
  assert not f.sqrt_u_iso
  f.site = True
  f.u_iso = False
  f.u_aniso = True
  f.occupancy = False
  f.fp = True
  f.fdp = False
  f.sqrt_u_iso = True
  assert f.site
  assert not f.u_iso
  assert f.u_aniso
  assert not f.occupancy
  assert f.fp
  assert not f.fdp
  assert f.sqrt_u_iso
  c = xray.ext.gradient_flags(f)
  assert c.site
  assert not c.u_iso
  assert c.u_aniso
  assert not c.occupancy
  assert c.fp
  assert not c.fdp
  assert not f.all_false()
  assert xray.ext.gradient_flags(
    False, False, False, False, False, False, False, False).all_false()
  f.u_iso = True
  assert f.adjust(False).u_iso == True
  assert f.adjust(True).u_iso == False
  assert f.adjust(False).u_aniso == False
  assert f.adjust(True).u_aniso == True

def exercise_xray_scatterer():
  x = xray.scatterer("a", (0.1,0.2,0.3), 0.25, 0.9, "const", 0, 0)
  assert x.label == "a"
  x.label = "b"
  assert x.label == "b"
  assert x.scattering_type == "const"
  x.scattering_type = "Si"
  assert x.scattering_type == "Si"
  assert x.fp == 0
  assert x.fdp == 0
  x.fp = 1
  assert x.fp == 1
  x.fdp = 2
  assert x.fdp == 2
  assert approx_equal(x.site, (0.1,0.2,0.3))
  x.site = (0.3,-0.4,0.5)
  assert approx_equal(x.site, (0.3,-0.4,0.5))
  assert approx_equal(x.occupancy, 0.9)
  x.occupancy = 0.3
  assert approx_equal(x.occupancy, 0.3)
  c = xray.ext.scatterer(other=x)
  assert c.fp == 1
  c.fp = 3
  assert x.fp == 1
  assert c.fp == 3
  f = xray.scatterer_flags()
  f.set_use_u_iso_only()
  c.flags = f
  assert c.flags.use_u_iso_only()
  c.flags.set_use_u_aniso_only()
  assert f.use_u_iso_only()
  assert c.flags.use_u_aniso_only()
  for flag0 in [True, False]:
    x.flags.set_use(flag0)
    for flag1 in [True, False]:
      x.flags.set_use_u_iso(flag1)
      for flag2 in [True, False]:
        x.flags.set_use_u_aniso(flag2)
        for flag3 in [True, False]:
          x.flags.set_grad_u_iso(flag3)
          for flag4 in [True, False]:
            x.flags.set_grad_u_aniso(flag4)
            assert x.flags.use()          == flag0
            assert x.flags.use_u_iso()    == flag1
            assert x.flags.use_u_aniso()  == flag2
            assert x.flags.grad_u_iso()   == flag3
            assert x.flags.grad_u_aniso() == flag4
  assert approx_equal(x.u_iso, 0.25)
  x.u_iso = 0.52
  assert approx_equal(x.u_iso, 0.52)
  x = xray.scatterer("a", (0.1,0.2,0.3), (1,2,3,4,5,6), 0.9, "const", 0, 0)
  assert x.flags.use_u_aniso()
  assert approx_equal(x.u_star, (1,2,3,4,5,6))
  x.u_star = (3,2,1,6,5,4)
  assert approx_equal(x.u_star, (3,2,1,6,5,4))
  assert x.flags.use() == True
  x.flags.set_grad_site(state=True)
  assert x.flags.grad_site()
  #
  x.u_iso = 4
  x.set_use_u(iso=True, aniso=True)
  assert approx_equal(x.u_iso, 4)
  assert approx_equal(x.u_star, (3,2,1,6,5,4))
  x.set_use_u_iso_only()
  assert approx_equal(x.u_iso, 4)
  assert approx_equal(x.u_star, (-1,-1,-1,-1,-1,-1))
  x.u_star = (9,3,6,0,1,5)
  x.set_use_u_aniso_only()
  assert approx_equal(x.u_iso, -1)
  assert approx_equal(x.u_star, (9,3,6,0,1,5))
  #
  x = xray.scatterer(
    "si1", site=(0.01,0.02,0.3), occupancy=0.9, u=(0.3, 0.3, 0.2, 0,0,0))
  assert x.scattering_type == "Si"
  uc = uctbx.unit_cell((10, 10, 13))
  sg = sgtbx.space_group_info("P 4")
  ss = x.apply_symmetry(unit_cell=uc, space_group=sg.group())
  assert x.multiplicity() == 1
  assert approx_equal(x.weight_without_occupancy(), 1/4.)
  assert approx_equal(x.weight(), 0.9/4.)
  assert approx_equal(x.site, (0,0,0.3))
  assert ss.multiplicity() == x.multiplicity()
  x.occupancy = 0.8
  assert approx_equal(x.weight(), 0.8/4.)
  u_cart = (0.3354, 0.3771, 0.4874, -0.05161, 0.026763, -0.02116)
  x.u_star = adptbx.u_cart_as_u_star(uc, u_cart)
  x.flags.set_use_u_aniso(True)
  try:
    x.apply_symmetry(uc, sg.group(), u_star_tolerance=0.1)
  except RuntimeError as e:
    assert str(e).find("is_compatible_u_star") > 0
  else:
    raise Exception_expected
  x.apply_symmetry(site_symmetry_ops=ss)
  x.apply_symmetry(site_symmetry_ops=ss, u_star_tolerance=0.5)
  ss = x.apply_symmetry(uc, sg.group(), 0.5, 0)
  ss = x.apply_symmetry(uc, sg.group(), 0.5, 0, False)
  ss = x.apply_symmetry(
    unit_cell=uc,
    space_group=sg.group(),
    min_distance_sym_equiv=0.5,
    u_star_tolerance=0,
    assert_min_distance_sym_equiv=False)
  assert ss.is_compatible_u_star(x.u_star)
  assert approx_equal(x.u_star, (0.0035625, 0.0035625, 0.002884, 0, 0, 0))
  site = (0.2,0.5,0.4)
  x.apply_symmetry_site(ss)
  assert approx_equal(x.site, (0,0,0.3))
  x.u_star = (1,2,3,4,5,6)
  x.apply_symmetry_u_star(
    site_symmetry_ops=ss,
    u_star_tolerance=0)
  assert approx_equal(x.u_star, (1.5,1.5,3.0,0,0,0))
  x.site = (0.2,0.5,0.4)
  ss = x.apply_symmetry(uc, sg.group(), 1.e-10, 0)
  assert ss.is_point_group_1()
  assert x.flags.use_u_aniso_only()
  x.convert_to_isotropic(unit_cell=uc)
  assert not x.flags.use_u_aniso()
  assert approx_equal(x.u_iso, 269)
  assert approx_equal(x.u_star, (-1,-1,-1,-1,-1,-1))
  x.convert_to_anisotropic(unit_cell=uc)
  assert x.flags.use_u_aniso()
  assert approx_equal(x.u_iso, -1)
  assert approx_equal(x.u_star, (2.69, 2.69, 1.59171598, 0, 0, 0))
  x.u_star = (1,2,3,4,5,6)
  assert not x.is_positive_definite_u(unit_cell=uc)
  assert not x.is_positive_definite_u(unit_cell=uc, u_cart_tolerance=1.e2)
  assert x.is_positive_definite_u(unit_cell=uc, u_cart_tolerance=1.e3)
  x.tidy_u(unit_cell=uc, site_symmetry_ops=ss, u_min=0, u_max=9999,
    anisotropy_min=0)
  assert approx_equal(x.u_star,
    (3.3379643647809192, 4.5640522609325131, 4.4690204772593507,
     3.9031581835726965, 3.8623090371651934, 4.5162864184404032))
  x.tidy_u(unit_cell=uc, site_symmetry_ops=ss, u_min=1, u_max=9999,
    anisotropy_min=0)
  assert approx_equal(x.u_star,
    (3.3458045216665266, 4.5710990727698393, 4.4720459395534728,
     3.9006326295505751, 3.8598099147456764, 4.5133641373560351))
  assert x.is_positive_definite_u(unit_cell=uc)
  f = xray.scatterer_flags()
  f.set_use_u_iso_only()
  y = x.customized_copy(u=-1, flags=f)
  assert not y.flags.use_u_aniso()
  assert approx_equal(y.u_iso, -1)
  assert not y.is_positive_definite_u(unit_cell=uc)
  assert not y.is_positive_definite_u(unit_cell=uc, u_cart_tolerance=0.5)
  assert y.is_positive_definite_u(unit_cell=uc, u_cart_tolerance=2)
  a = flex.xray_scatterer([x,y])
  assert list(xray.is_positive_definite_u(
    scatterers=a, unit_cell=uc)) == [True, False]
  a = flex.xray_scatterer([y,x])
  assert list(xray.is_positive_definite_u(
    scatterers=a, unit_cell=uc)) == [False, True]
  assert list(xray.is_positive_definite_u(
    scatterers=a, unit_cell=uc, u_cart_tolerance=2)) == [True, True]
  y.tidy_u(unit_cell=uc, site_symmetry_ops=ss, u_min=1, u_max=1.0,
    anisotropy_min=0)
  assert approx_equal(y.u_iso, 1.0)
  yy = xray.scatterer("si1", site=(0.01,0.02,0.3), occupancy=0.8, u=158.0)
  assert approx_equal(yy.u_iso, 158.0)
  yy.tidy_u(unit_cell=uc, site_symmetry_ops=ss, u_min=1, u_max=0.9,
    anisotropy_min=0)
  assert approx_equal(yy.u_iso, 0.9)
  assert y.is_positive_definite_u(unit_cell=uc)
  x_u_star_orig = x.u_star
  x.shift_u(unit_cell=uc, u_shift=10)
  assert approx_equal(x.u_star,
    (3.4458045216665267, 4.6710990727698389, 4.5312175371866088,
     3.9006326295505751, 3.8598099147456764, 4.5133641373560351))
  y.shift_u(unit_cell=uc, u_shift=10)
  assert approx_equal(y.u_iso, 11)
  a = flex.xray_scatterer([x,y])
  xray.shift_us(scatterers=a, unit_cell=uc, u_shift=-10)
  assert approx_equal(a[0].u_star, x_u_star_orig)
  assert approx_equal(a[1].u_iso, 1)
  #
  f = xray.scatterer_flags()
  f.set_use_u(iso=True, aniso=True)
  y = x.customized_copy(u_iso=0.3, u_star=(1,3,5,-2,6,4), flags=f)
  assert y.flags.use_u_iso()
  assert y.flags.use_u_aniso()
  assert approx_equal(y.u_iso, 0.3)
  assert approx_equal(y.u_star, (1,3,5,-2,6,4))

  scs = flex.xray_scatterer((
    xray.scatterer("o", site=(0.01,0.02,0.1), u=0.1),
    xray.scatterer("o", site=(0.02,0.02,0.2), u=0.2),
    xray.scatterer("o", site=(0.03,0.02,0.3), u=0.3),
    xray.scatterer("o", site=(0.04,0.02,0.4), u=0.4),
    xray.scatterer("o", site=(0.05,0.02,0.4), u=0.5),
    xray.scatterer("o", site=(0.1,0.2,0.3),   u=(0.1,0.2,0.3,-.04,0.5,-0.06)),
    xray.scatterer("o", site=(0.3,0.4,0.5),   u=(0.4,0.5,0.6,-.05,0.2,-0.02))))
  uisos = scs.extract_u_iso()
  xray.shift_us(scatterers=scs, unit_cell=uc, u_shift=1,
                selection = flex.size_t([1,3,5]))
  xray.shift_occupancies(scatterers=scs, q_shift=2.5,
                         selection = flex.size_t([1,3,5]))
  assert approx_equal(scs.extract_occupancies(), [1.0, 3.5, 1.0, 3.5, 1.0, 3.5, 1.0])
  xray.shift_occupancies(scatterers=scs, q_shift=1.0)
  assert approx_equal(scs.extract_occupancies(), [2.0, 4.5, 2.0, 4.5, 2.0, 4.5, 2.0])
  assert approx_equal(scs[0].u_iso,  0.1) and approx_equal(scs[0].u_star, (-1.0, -1.0, -1.0, -1.0, -1.0, -1.0))
  assert approx_equal(scs[1].u_iso,  1.2) and approx_equal(scs[1].u_star, (-1.0, -1.0, -1.0, -1.0, -1.0, -1.0))
  assert approx_equal(scs[2].u_iso,  0.3) and approx_equal(scs[2].u_star, (-1.0, -1.0, -1.0, -1.0, -1.0, -1.0))
  assert approx_equal(scs[3].u_iso,  1.4) and approx_equal(scs[3].u_star, (-1.0, -1.0, -1.0, -1.0, -1.0, -1.0))
  assert approx_equal(scs[4].u_iso,  0.5) and approx_equal(scs[4].u_star, (-1.0, -1.0, -1.0, -1.0, -1.0, -1.0))
  assert approx_equal(scs[5].u_iso, -1.0)
  assert approx_equal(scs[6].u_iso, -1.0) and approx_equal(scs[6].u_star, (0.40, 0.50, 0.59999999999999998, -0.05, 0.2, -0.02))
  a[0].fp = 3;
  a[1].fdp = 4;
  assert not show_diff(a[0].report_details(unit_cell=uc, prefix="&%"), """\
&%scatterer label: si1
&%scattering type: Si
&%fractional coordinates: 0.200000 0.500000 0.400000
&%cartesian coordinates: 2.000000 5.000000 5.200000
&%u_star: 3.3458 4.5711 4.47205 3.90063 3.85981 4.51336
&%u_cart: 334.58 457.11 755.776 390.063 501.775 586.737
&%occupancy: 0.8
&%f-prime: 3
&%f-double-prime: 0""")
  assert not show_diff(a[1].report_details(unit_cell=uc, prefix="=#"), """\
=#scatterer label: si1
=#scattering type: Si
=#fractional coordinates: 0.200000 0.500000 0.400000
=#cartesian coordinates: 2.000000 5.000000 5.200000
=#u_iso: 1
=#b_iso: 78.9568
=#occupancy: 0.8
=#f-prime: 0
=#f-double-prime: 4""")
  #
  pc = a[0].as_py_code(indent="%&")
  assert not show_diff(pc, """\
xray.scatterer(
%&  label="si1",
%&  site=(0.200000, 0.500000, 0.400000),
%&  u=(3.345805, 4.571099, 4.472046,
%&     3.900633, 3.859810, 4.513364),
%&  occupancy=0.800000,
%&  fp=3.000000,
%&  fdp=0.000000)""")
  pc = a[1].as_py_code(indent="Q")
  assert not show_diff(pc, """\
xray.scatterer(
Q  label="si1",
Q  site=(0.200000, 0.500000, 0.400000),
Q  u=1.000000,
Q  occupancy=0.800000,
Q  fp=0.000000,
Q  fdp=4.000000)""")
  for xs in a:
    xs2 = eval(xs.as_py_code())
    assert approx_equal(xs2.site, xs.site)
    assert approx_equal(xs2.fp, xs.fp)
    assert approx_equal(xs2.fdp, xs.fdp)
  #
  uc = uctbx.unit_cell((1,2,3, 89, 96, 107))
  results_u_cart_plus_u_iso = []
  for u_iso, u_aniso in [(0, 0), (0.04, 0), (0, 0.04), (0.04, 0.04)]:
    xs = xray.scatterer(label="C")
    xs.flags.set_use_u_iso(False)
    xs.flags.set_use_u_aniso(False)
    if (u_iso != 0):
      xs.u_iso = u_iso
      xs.flags.set_use_u_iso(True)
    if (u_aniso != 0):
      xs.u_star = adptbx.u_cart_as_u_star(
        uc, (u_aniso/2, u_aniso, 2*u_aniso, 0, 0, 0))
      xs.flags.set_use_u_aniso(True)
    expected = u_iso + 3.5*u_aniso/3
    assert approx_equal(xs.u_iso_or_equiv(unit_cell=uc), expected)
    if (not xs.flags.use_u_aniso()):
      assert approx_equal(xs.u_iso_or_equiv(unit_cell=None), expected)
    else:
      try: xs.u_iso_or_equiv(unit_cell=None)
      except RuntimeError as e:
        assert str(e).startswith("cctbx Internal Error: ")
      else: raise Exception_expected
    results_u_cart_plus_u_iso.append(xs.u_cart_plus_u_iso(unit_cell=uc))
    if (not xs.flags.use_u_aniso()):
      assert approx_equal(
        xs.u_cart_plus_u_iso(unit_cell=None), (u_iso,u_iso,u_iso,0,0,0))
    else:
      try: xs.u_cart_plus_u_iso(unit_cell=None)
      except RuntimeError as e:
        assert str(e).startswith("cctbx Internal Error: ")
      else: raise Exception_expected
  assert approx_equal(results_u_cart_plus_u_iso, [
    (0,0,0,0,0,0),
    (0.04,0.04,0.04,0,0,0),
    (0.02,0.04,0.08,0,0,0),
    (0.06,0.08,0.12,0,0,0)])

def exercise_rotate():
  uc = uctbx.unit_cell((10, 10, 13))
  s = flex.xray_scatterer((xray.scatterer("Si1", site=(0.01,0.02,0.3)),))
  r = xray.rotate(
    unit_cell=uc,
    rotation_matrix=((1,0,0, 0,1,0, 0,0,1)),
    scatterers=s)
  assert r.size() == 1
  assert approx_equal(s[0].site, r[0].site)
  r = xray.rotate(
    unit_cell=uc,
    rotation_matrix=((0,-1,0, -1,0,0, 0,0,-1)),
    scatterers=s)
  assert approx_equal(r[0].site, (-0.02,-0.01,-0.3))

def exercise_scattering_type_registry_1():
  reg = xray.scattering_type_registry()
  scatterers = flex.xray_scatterer((
    xray.scatterer("O"),
    xray.scatterer("O1-")))
  reg.process(scatterers)
  reg.assign_from_table(table="PENG1996")
  d = reg.as_type_gaussian_dict()
  # Values from peng1996.cpp:
  O_minus = d["O1-"]
  assert approx_equal(O_minus.array_of_a()[2], 1.17, 0.01)
  assert approx_equal(O_minus.array_of_b()[1], 2.64, 0.01)
  assert approx_equal(O_minus.c(), 0, 0.001)
  O = d["O"]
  assert approx_equal(O.array_of_a()[3], 0.8814, 0.0001)
  assert approx_equal(O.array_of_b()[4], 28.2194, 0.00001)
  assert approx_equal(O.c(), 0, 0.001)

def exercise_scattering_type_registry():
  reg = xray.scattering_type_registry()
  assert len(reg.type_index_pairs_as_dict()) == 0
  assert len(reg.unique_gaussians_as_list()) == 0
  assert reg.unique_counts.size() == 0
  assert reg.size() == 0
  assert not reg.has_key("const")
  assert not reg.has_key("unknown")
  assert reg.process(scattering_type="const") == 0
  assert reg.size() == 1
  assert reg.has_key("const")
  assert not reg.has_key("unknown")
  assert reg.type_index_pairs_as_dict() == {"const": 0}
  assert list(reg.unique_counts) == [1]
  scatterers = flex.xray_scatterer((
    xray.scatterer("Si1"),
    xray.scatterer("Si2"),
    xray.scatterer("O1"),
    xray.scatterer("O2"),
    xray.scatterer("Al1"),
    xray.scatterer("O3"),
    xray.scatterer("Al2"),
    xray.scatterer("const", scattering_type="const"),
    xray.scatterer("custom", scattering_type="custom")))
  unique_indices = reg.process(scatterers=scatterers)
  assert list(unique_indices) == [1,1,2,2,3,2,3,0,4]
  assert reg.unique_indices(scatterers=scatterers).all_eq(unique_indices)
  assert approx_equal(reg.occupancy_sums(scatterers=scatterers), [1,2,3,2,1])
  assert reg.type_index_pairs_as_dict() \
      == {"const": 0, "Al": 3, "O": 2, "custom": 4, "Si": 1}
  assert reg.unique_gaussians_as_list().count(None) == 5
  assert list(reg.unique_counts) == [2,2,3,2,1]
  for t,i in reg.type_index_pairs_as_dict().items():
    assert reg.unique_index(scattering_type=t) == i
    assert reg.gaussian(scattering_type=t) is None
  assert list(reg.unassigned_types()) == ['Al', 'O', 'Si', 'const', 'custom']
  assert reg.assign(
    scattering_type="const",
    gaussian=eltbx.xray_scattering.gaussian(10))
  assert reg.unique_gaussians_as_list().count(None) == 4
  assert reg.unique_gaussians_as_list()[0].n_parameters() == 1
  assert not reg.assign("const", eltbx.xray_scattering.gaussian(10))
  assert reg.gaussian(scattering_type="const").n_parameters() == 1
  assert reg.gaussian_not_optional(scattering_type="const").n_parameters() == 1
  assert reg.assign("custom", eltbx.xray_scattering.gaussian((1,2),(3,4),5))
  assert reg.unique_gaussians_as_list().count(None) == 3
  assert reg.unique_gaussians_as_list()[4].n_parameters() == 5
  assert list(reg.unassigned_types()) == ['Al', 'O', 'Si']
  for table,n_terms in (("IT1992",4), ("WK1995",5)):
    reg = xray.scattering_type_registry()
    reg.process(scatterers=scatterers)
    reg.assign("const", eltbx.xray_scattering.gaussian(10))
    reg.assign("custom", eltbx.xray_scattering.gaussian((1,2),(3,4),5))
    reg.assign_from_table(table=table)
    ugs = reg.unique_gaussians_as_list()
    for t,i in reg.type_index_pairs_as_dict().items():
      if (t in ["Al", "O", "Si"]):
        assert ugs[i].n_terms() == n_terms
      elif (t == "const"):
        assert ugs[i].n_terms() == 0
        assert approx_equal(ugs[i].c(), 10)
      else:
        assert ugs[i].n_terms() == 2
        assert approx_equal(ugs[i].c(), 5)
    reg.assign("Al", eltbx.xray_scattering.gaussian(20))
    ugs = reg.unique_gaussians_as_list()
    assert approx_equal(ugs[reg.unique_index("Al")].c(), 20)
    assert reg.unassigned_types().size() == 0
    ff = reg.unique_form_factors_at_d_star_sq(d_star_sq=0)
    if (n_terms == 4):
      assert approx_equal(ff, [13.9976, 7.9994, 20.0, 10.0, 8.0])
    else:
      assert approx_equal(ff, [13.998917, 7.999706, 20.0, 10.0, 8.0])
    ff = reg.unique_form_factors_at_d_star_sq(d_star_sq=0.123)
    if (n_terms == 4):
      assert approx_equal(ff, [10.173729, 6.042655, 20.0, 10.0, 7.680404])
    else:
      assert approx_equal(ff, [10.174771, 6.042745, 20.0, 10.0, 7.680404])
    all_dilated_ffs = reg.dilated_form_factors_at_d_star_sq(
      d_star_sq=0.1,
      dilation_coeffs=flex.double_range(1,scatterers.size()+1),
      unique_indices=unique_indices)
    for i, dilated_ff in enumerate(all_dilated_ffs):
      j = unique_indices[i]
      ref_ff = reg.unique_gaussians_as_list()[j].at_d_star_sq(0.1/(i+1))
      assert approx_equal(dilated_ff, ref_ff)
    reg.assign(scattering_type="custom", gaussian=None)
    assert reg.gaussian(scattering_type="custom") is None
    s = StringIO()
    reg.show_summary(out=s, prefix="=-")
    if (n_terms == 4):
      assert not show_diff(s.getvalue(),
        "=-Al:0+c*2 Si:4+c*2 const:0+c*1 O:4+c*3 custom:None*1\n")
    else:
      assert not show_diff(s.getvalue(),
        "=-Al:0+c*2 Si:5+c*2 const:0+c*1 O:5+c*3 custom:None*1\n")
    s = StringIO()
    for show_sf0 in [False, True]:
      for show_gaussians in [False, True]:
        reg.show(
          show_sf0=show_sf0,
          show_gaussians=show_gaussians,
          out=s,
          prefix=":#")
    assert not show_diff(s.getvalue(), """\
:#Number of scattering types: 5
:#  Type    Number
:#   Al         2
:#   Si         2
:#   const      1
:#   O          3
:#   custom     1
:#Number of scattering types: 5
:#  Type    Number   Gaussians
:#   Al         2        0+c
:#   Si         2        %(n_terms)d+c
:#   const      1        0+c
:#   O          3        %(n_terms)d+c
:#   custom     1       None
:#Number of scattering types: 5
:#  Type    Number    sf(0)
:#   Al         2     20.00
:#   Si         2     14.00
:#   const      1     10.00
:#   O          3      8.00
:#   custom     1      None
:#  sf(0) = scattering factor at diffraction angle 0.
:#Number of scattering types: 5
:#  Type    Number    sf(0)   Gaussians
:#   Al         2     20.00       0+c
:#   Si         2     14.00       %(n_terms)d+c
:#   const      1     10.00       0+c
:#   O          3      8.00       %(n_terms)d+c
:#   custom     1      None      None
:#  sf(0) = scattering factor at diffraction angle 0.
""" % vars())
    assert reg.wilson_dict() \
        == {'Si': 2, 'const': 1, 'Al': 2, 'O': 3, 'custom': 1}
    type_index_pairs = reg.type_index_pairs_as_dict()
    unique_gaussians = reg.unique_gaussians_as_list()
    unique_counts = reg.unique_counts
    reg = xray.scattering_type_registry(
      type_index_pairs, unique_gaussians, unique_counts)
    assert reg.type_index_pairs_as_dict() == type_index_pairs
    for orig,restored in zip(unique_gaussians, reg.unique_gaussians_as_list()):
      if (restored is None):
        assert orig is None
        continue
      assert restored is not orig
      assert restored.n_parameters() == orig.n_parameters()
      for d_star_sq in [0, 0.1, 0.234]:
        assert approx_equal(
          restored.at_d_star_sq(d_star_sq), orig.at_d_star_sq(d_star_sq))
    assert reg.unique_counts.all_eq(unique_counts)
    s = pickle.dumps(reg)
    l = pickle.loads(s)
    orig = StringIO()
    restored = StringIO()
    reg.show(out=orig)
    l.show(out=restored)
    assert not show_diff(restored.getvalue(), orig.getvalue())
  try: reg.unique_index("foo")
  except RuntimeError as e:
    assert str(e) == 'scattering_type "foo" not in scattering_type_registry.'
  else: raise Exception_expected
  try: reg.gaussian_not_optional(scattering_type="custom")
  except RuntimeError as e:
    assert str(e) == 'gaussian not defined for scattering_type "custom".'
  else: raise Exception_expected
  try: reg.unique_form_factors_at_d_star_sq(d_star_sq=0)
  except RuntimeError as e:
    assert str(e) == 'gaussian not defined for scattering_type "custom".'
  else: raise Exception_expected

def exercise_structure_factors():
  uc = uctbx.unit_cell((10, 10, 13))
  sg = sgtbx.space_group_info("P 4")
  scatterers = flex.xray_scatterer((
    xray.scatterer("Si1", site=(0.01,0.02,0.3)),
    xray.scatterer("O1", site=(0.3,0.4,0.5), u=(0.4,0.5,0.6,-.05,0.2,-0.02))))
  for s in scatterers:
    assert s.multiplicity() == 0
  assert xray.n_undefined_multiplicities(scatterers) == 2
  site_symmetry_table = sgtbx.site_symmetry_table()
  xray.add_scatterers_ext(
    unit_cell=uc,
    space_group=sg.group(),
    scatterers=scatterers,
    site_symmetry_table=site_symmetry_table,
    site_symmetry_table_for_new=sgtbx.site_symmetry_table(),
    min_distance_sym_equiv=0.5,
    u_star_tolerance=0,
    assert_min_distance_sym_equiv=True,
    non_unit_occupancy_implies_min_distance_sym_equiv_zero=False)
  assert list(site_symmetry_table.special_position_indices()) == [0]
  xray.tidy_us(
    scatterers=scatterers,
    unit_cell=uc,
    site_symmetry_table=site_symmetry_table,
    u_min=0,
    u_max = 99999,
    anisotropy_min=0)
  assert approx_equal(scatterers[0].u_iso, 0)
  assert approx_equal(scatterers[1].u_star, (0.4,0.5,0.6,-.05,0.2,-0.02))
  for s in scatterers:
    assert s.multiplicity() != 0
  assert xray.n_undefined_multiplicities(scatterers) == 0
  mi = flex.miller_index(((1,2,3), (2,3,4)))
  scattering_type_registry = xray.scattering_type_registry()
  scattering_type_registry.process(scatterers=scatterers)
  scattering_type_registry.assign_from_table("WK1995")
  fc = xray.ext.structure_factors_simple(
    uc, sg.group(), mi, scatterers, scattering_type_registry).f_calc()
  assert approx_equal(flex.abs(fc), (10.50871, 9.049631))
  assert approx_equal(flex.arg(fc, True), (-36, 72))
  assert approx_equal(flex.abs(fc), (10.50871, 9.049631))
  assert approx_equal(flex.arg(fc, True), (-36, 72))
  fc = xray.ext.structure_factors_direct(
    uc, sg.group(), mi, scatterers, scattering_type_registry).f_calc()
  assert approx_equal(flex.abs(fc), (10.50871, 9.049631))
  assert approx_equal(flex.arg(fc, True), (-36, 72))
  xray.tidy_us(
    scatterers=scatterers,
    unit_cell=uc,
    site_symmetry_table=site_symmetry_table,
    u_min=100,
    u_max = 99999,
    anisotropy_min=0)
  assert approx_equal(scatterers[0].u_iso, 100)
  assert approx_equal(scatterers[1].u_star,
    (1.0134539945616343, 1.0005190241807682, 0.64980451464405997,
     -0.0026425269166861672, 0.027955730692513142, -0.0054908429234285239))
  xray.ext.structure_factors_direct(
    math_module.cos_sin_table(12),
    uc, sg.group(), mi, scatterers, scattering_type_registry).f_calc()
  gradient_flags = xray.ext.gradient_flags(
                              True, True, True, True, True, True, False, False)
  xray.set_scatterer_grad_flags(scatterers = scatterers,
                                site       = gradient_flags.site,
                                u_iso      = gradient_flags.u_iso,
                                u_aniso    = gradient_flags.u_aniso,
                                occupancy  = gradient_flags.occupancy,
                                fp         = gradient_flags.fp,
                                fdp        = gradient_flags.fdp)
  xray.ext.structure_factors_gradients_direct(
    uc, sg.group(), mi, scatterers, None,
    scattering_type_registry, site_symmetry_table,
    flex.complex_double(mi.size()),
    0)
  gradient_flags = xray.ext.gradient_flags(
                              True, True, True, True, True, True, False, False)
  xray.set_scatterer_grad_flags(scatterers = scatterers,
                                site       = gradient_flags.site,
                                u_iso      = gradient_flags.u_iso,
                                u_aniso    = gradient_flags.u_aniso,
                                occupancy  = gradient_flags.occupancy,
                                fp         = gradient_flags.fp,
                                fdp        = gradient_flags.fdp)
  xray.ext.structure_factors_gradients_direct(
    math_module.cos_sin_table(12),
    uc, sg.group(), mi, scatterers, None,
    scattering_type_registry, site_symmetry_table,
    flex.complex_double(mi.size()),
    0)

def exercise_targets():
  f_obs = flex.double((1,2,3,4,5))
  w = flex.double((1,1,1,1,1))
  f_calc = flex.complex_double((1,2,3,4,5))
  ls = xray.targets_least_squares_residual(f_obs, w, f_calc)
  assert approx_equal(ls.scale_factor(), 1)
  assert approx_equal(ls.target(), 0)
  assert ls.derivatives().size() == 0
  ls = xray.targets_least_squares_residual(f_obs, w, f_calc, True)
  assert approx_equal(ls.scale_factor(), 1)
  assert approx_equal(ls.target(), 0)
  assert approx_equal(tuple(ls.derivatives()), (0j,0j,0j,0j,0j))
  ls = xray.targets_least_squares_residual(f_obs, w, f_calc, False, 3)
  assert approx_equal(ls.scale_factor(), 3)
  assert approx_equal(ls.target(), 4)
  assert ls.derivatives().size() == 0
  ls = xray.targets_least_squares_residual(f_obs, f_calc)
  assert approx_equal(ls.scale_factor(), 1)
  assert approx_equal(ls.target(), 0)
  assert ls.derivatives().size() == 0
  f_calc = flex.complex_double((10,20,30,40,50))
  ls = xray.targets_least_squares_residual(f_obs, f_calc, True)
  assert approx_equal(ls.scale_factor(), 1/10.)
  assert approx_equal(ls.target(), 0)
  assert approx_equal(tuple(ls.derivatives()), (0j,0j,0j,0j,0j))
  ls = xray.targets_least_squares_residual(f_obs, f_calc, False, 3/10.)
  assert approx_equal(ls.scale_factor(), 3/10.)
  assert approx_equal(ls.target(), 4)
  assert ls.derivatives().size() == 0
  f_calc = flex.complex_double((1+2j,3+4j,-1-2j,5-4j,-5+6j))
  w = flex.double((1,2,3,2,4))
  ls = xray.targets_least_squares_residual(f_obs, w, f_calc, True)
  assert approx_equal(ls.scale_factor(), 0.6307845)
  assert approx_equal(ls.target(), 0.06211855)
  assert approx_equal(tuple(ls.derivatives()), (
    (0.0013784963+0.002756992j), (0.0103982354+0.013864313j),
    (0.0160141831+0.032028366j), (0.0004572786-0.000365822j),
    (0.0014117387-0.001694086j)))

  import cmath
  f_obs_sqr = flex.double((1,2,3,4,5))
  w = flex.double((1,1,1,1,1))
  f_calc = flex.complex_double([ cmath.sqrt(x) for x in f_obs_sqr ])
  ls = xray.targets_least_squares_residual_for_intensity(f_obs_sqr, w, f_calc)
  assert approx_equal(ls.scale_factor(), 1)
  assert approx_equal(ls.target(), 0)
  assert ls.derivatives().size() == 0
  ls = xray.targets_least_squares_residual_for_intensity(
    f_obs_sqr, w, f_calc, True)
  assert approx_equal(ls.scale_factor(), 1)
  assert approx_equal(ls.target(), 0)
  assert approx_equal(tuple(ls.derivatives()), (0j,0j,0j,0j,0j))
  ls = xray.targets_least_squares_residual_for_intensity(
    f_obs_sqr, w, f_calc, False, 3)
  assert approx_equal(ls.scale_factor(), 3)
  assert approx_equal(ls.target(), 4)
  assert ls.derivatives().size() == 0
  ls = xray.targets_least_squares_residual_for_intensity(
    f_obs_sqr, f_calc)
  assert approx_equal(ls.scale_factor(), 1)
  assert approx_equal(ls.target(), 0)
  assert ls.derivatives().size() == 0
  f_calc = flex.complex_double([ cmath.sqrt(x) for x in (10,20,30,40,50) ])
  ls = xray.targets_least_squares_residual_for_intensity(
    f_obs_sqr, f_calc, True)
  assert approx_equal(ls.scale_factor(), 1/10.)
  assert approx_equal(ls.target(), 0)
  assert approx_equal(tuple(ls.derivatives()), (0j,0j,0j,0j,0j))
  ls = xray.targets_least_squares_residual_for_intensity(
    f_obs_sqr, f_calc, False, 3/10.)
  assert approx_equal(ls.scale_factor(), 3/10.)
  assert approx_equal(ls.target(), 4)
  assert ls.derivatives().size() == 0
  f_calc = flex.complex_double([ cmath.sqrt(x)
                                 for x in (1+2j,3+4j,-1-2j,5-4j,-5+6j) ])
  w = flex.double((1,2,3,2,4))
  ls = xray.targets_least_squares_residual_for_intensity(
    f_obs_sqr, w, f_calc, True)
  assert approx_equal(ls.scale_factor(), 0.6307845)
  assert approx_equal(ls.target(), 0.06211855)
  assert approx_equal(tuple(ls.derivatives()), (
    (0.00784178+0.00484648j), (0.0693216+0.0346608j),
    (-0.0563023+0.091099j), (0.0027966-0.000980993j),
    (-0.00522801-0.011162j)))

def exercise_sampled_model_density():
  assert approx_equal(xray.calc_u_base(2, 1./3), 0.1350949)
  uc = uctbx.unit_cell((20, 20, 23))
  sg = sgtbx.space_group_info("P 4")
  scatterers = flex.xray_scatterer((
    xray.scatterer("Si1", site=(0.01,0.02,0.3), fp=-1, fdp=2),
    xray.scatterer("O1", site=(0.3,0.4,0.5),
                   u=adptbx.u_cart_as_u_star(uc,
                     (0.04,0.05,0.06,-.005,0.02,-0.002)))))
  for scatterer in scatterers:
    scatterer.apply_symmetry(uc, sg.group())
  scattering_type_registry = xray.ext.scattering_type_registry()
  scattering_type_registry.process(scatterers)
  scattering_type_registry.assign_from_table("WK1995")
  d = xray.sampled_model_density(
    unit_cell=uc,
    scatterers=scatterers,
    scattering_type_registry=scattering_type_registry,
    fft_n_real=(20,20,22),
    fft_m_real=(20,20,23))
  assert d.unit_cell().is_similar_to(uc)
  assert approx_equal(d.u_base(), 0.25)
  assert approx_equal(d.u_extra(), 0.25)
  assert approx_equal(d.u_min(), 0)
  assert approx_equal(d.wing_cutoff(), 1.e-3)
  assert approx_equal(d.exp_table_one_over_step_size(), -100)
  assert approx_equal(d.tolerance_positive_definite(), 1.e-5)
  assert d.n_scatterers_passed() == 2
  assert d.n_contributing_scatterers() == 2
  assert d.n_anomalous_scatterers() == 1
  assert d.anomalous_flag()
  assert d.real_map().size() == 0
  assert d.complex_map().size() == (20*20*22)
  assert d.exp_table_size() == 2889
  assert d.max_sampling_box_n_points() == 216
  assert d.sum_sampling_box_n_points() == 341
  assert approx_equal(d.ave_sampling_box_n_points(), 341/2.)
  assert d.max_sampling_box_edges() == (6,6,6)
  assert approx_equal(d.max_sampling_box_edges_frac(), (6/20.,6/20.,6/22.))
  assert d.excessive_sampling_radius_i_seqs().size() == 0
  assert d.grid_indices_for_each_scatterer().size() == 0
  i = flex.miller_index(((1,2,3), (2,3,4)))
  f = flex.complex_double((1+2j, 2+3j))
  d.eliminate_u_extra_and_normalize(i, f)
  f_orig = f.deep_copy()
  xray.apply_u_extra(d.unit_cell(), 0.2, i, f)
  f_elim = f.deep_copy()
  xray.apply_u_extra(d.unit_cell(), -0.2, i, f, 1)
  assert approx_equal(f, f_orig)
  #
  scatterers[0].fdp = 0
  for sgifes in [1, -1]:
    d = xray.sampled_model_density(
      unit_cell=uc,
      scatterers=scatterers,
      scattering_type_registry=scattering_type_registry,
      fft_n_real=(20,20,22),
      fft_m_real=(20,20,23),
      store_grid_indices_for_each_scatterer=sgifes)
    if (sgifes > 0):
      assert d.real_map().size() == 20*20*23
      assert d.real_map().focus() == (20,20,22)
      assert d.real_map().all() == (20,20,23)
    else:
      assert d.real_map().size() == 0
    assert d.complex_map().size() == 0
    assert d.grid_indices_for_each_scatterer().size() == scatterers.size()
    map = d.real_map()
    n_non_zero = 0
    for gi,expected_sizes in zip(d.grid_indices_for_each_scatterer(),
                                 [[88], [33,31]]):
      assert gi.size() in expected_sizes
      if (sgifes < 0): continue
      for i_map in gi:
        assert map[i_map] > 0
      n_non_zero += gi.size()
    if (sgifes > 0):
      assert map.count(0) + n_non_zero == 20*20*23
    comb_sel = shared.stl_set_unsigned()
    comb_sel.append_union_of_selected_arrays(
      arrays=d.grid_indices_for_each_scatterer(),
      selection=flex.size_t([0,1]))
    assert comb_sel[0].size() in [121,119]
    if (sgifes > 0):
      assert map.select(comb_sel[0]).all_gt(0)
      assert comb_sel[0].size() == n_non_zero

def exercise_minimization_apply_shifts():
  uc = uctbx.unit_cell((20, 20, 23))
  scatterers = flex.xray_scatterer((
    xray.scatterer("Si1", site=(0.01,0.02,0.3), fp=-1, fdp=2),
    xray.scatterer("O1", site=(0.3,0.4,0.5),
                   u=adptbx.u_cart_as_u_star(uc,
                     (0.04,0.05,0.06,-.005,0.02,-0.002)))))
  f = xray.ext.gradient_flags(
    True, True, True, True, True, True, False, False)
  xray.set_scatterer_grad_flags(scatterers = scatterers,
                                site       = f.site,
                                u_iso      = f.u_iso,
                                u_aniso    = f.u_aniso,
                                occupancy  = f.occupancy,
                                fp         = f.fp,
                                fdp        = f.fdp)
  s = xray.ext.minimization_shift_scales(
    scatterers=scatterers,
    n_parameters=19,
    site_cart=1,
    u_iso=2,
    u_cart=3,
    occupancy=4,
    fp=5,
    fdp=6)
  assert [int(x) for x in s] \
      == [1, 1, 1, 2, 4, 5, 6, 1, 1, 1, 3, 3, 3, 3, 3, 3, 4, 5, 6]
  shifts = flex.double(19, 0.001)
  shifted_scatterers = xray.ext.minimization_apply_shifts(
    uc, scatterers, shifts).shifted_scatterers
  for a,b in zip(scatterers, shifted_scatterers):
    assert a.scattering_type == b.scattering_type
    assert a.site != b.site
    if (not a.flags.use_u_aniso()):
      assert a.u_iso != b.u_iso
      assert approx_equal(a.u_star, b.u_star)
    else:
      assert a.u_iso == b.u_iso
      assert not_approx_equal(a.u_star, b.u_star)
    assert a.occupancy != b.occupancy
    assert a.fp != b.fp
    assert a.fdp != b.fdp
  shifts = flex.double(19, -0.001)
  shifted_scatterers = xray.ext.minimization_apply_shifts(
    unit_cell=uc,
    scatterers=shifted_scatterers,
    shifts=shifts).shifted_scatterers
  for a,b in zip(scatterers, shifted_scatterers):
    assert a.scattering_type == b.scattering_type
    assert approx_equal(a.site, b.site)
    assert approx_equal(a.u_iso, b.u_iso)
    assert approx_equal(a.u_star, b.u_star)
    assert approx_equal(a.occupancy, b.occupancy)
    assert approx_equal(a.fp, b.fp)
    assert approx_equal(a.fdp, b.fdp)
  f = xray.ext.gradient_flags(
    True, False, False, False, False, False, False, False)
  xray.set_scatterer_grad_flags(scatterers = scatterers,
                                site       = f.site,
                                u_iso      = f.u_iso,
                                u_aniso    = f.u_aniso,
                                occupancy  = f.occupancy,
                                fp         = f.fp,
                                fdp        = f.fdp)
  s = xray.ext.minimization_shift_scales(scatterers, 6, 1,2,3,4,5,6)
  assert [int(x) for x in s] == [1]*6
  shifts = flex.double((-1,2,-3,4,-5,-6))
  shifted_scatterers = xray.ext.minimization_apply_shifts(
    uc, scatterers, shifts).shifted_scatterers
  assert approx_equal(
    shifted_scatterers[0].site,
    (0.01-1/20.,0.02+2/20.,0.3-3/23.))
  assert approx_equal(
    shifted_scatterers[1].site,
    (0.3+4/20.,0.4-5/20.,0.5-6/23.))
  f = xray.ext.gradient_flags(
    False, True, False, False, False, False, False, False)
  xray.set_scatterer_grad_flags(scatterers = scatterers,
                                site       = f.site,
                                u_iso      = f.u_iso,
                                u_aniso    = f.u_aniso,
                                occupancy  = f.occupancy,
                                fp         = f.fp,
                                fdp        = f.fdp)
  s = xray.ext.minimization_shift_scales(scatterers, 1, 1,2,3,4,5,6)
  assert [int(x) for x in s] == [2]
  shifts = flex.double(1, -10)
  shifted_scatterers = xray.ext.minimization_apply_shifts(
    uc, scatterers, shifts).shifted_scatterers
  assert approx_equal(shifted_scatterers[0].u_iso, -10)
  f = xray.ext.gradient_flags(
    False, False, True, False, False, False, False, False)
  xray.set_scatterer_grad_flags(scatterers = scatterers,
                                site       = f.site,
                                u_iso      = f.u_iso,
                                u_aniso    = f.u_aniso,
                                occupancy  = f.occupancy,
                                fp         = f.fp,
                                fdp        = f.fdp)
  s = xray.ext.minimization_shift_scales(scatterers, 6, 1,2,3,4,5,6)
  assert [int(x) for x in s] == [3]*6
  shifts = flex.double(6, -100)
  shifted_scatterers = xray.ext.minimization_apply_shifts(
    uc, scatterers, shifts).shifted_scatterers
  assert not_approx_equal(shifted_scatterers[1].u_star,
    [u_ij-100 for u_ij in scatterers[1].u_star])
  f = xray.ext.gradient_flags(
    False, False, False, True, False, False, False, False)
  xray.set_scatterer_grad_flags(scatterers = scatterers,
                                site       = f.site,
                                u_iso      = f.u_iso,
                                u_aniso    = f.u_aniso,
                                occupancy  = f.occupancy,
                                fp         = f.fp,
                                fdp        = f.fdp)
  s = xray.ext.minimization_shift_scales(scatterers, 2, 1,2,3,4,5,6)
  assert [int(x) for x in s] == [4]*2
  shifts = flex.double(2, -10)
  shifted_scatterers = xray.ext.minimization_apply_shifts(
    uc, scatterers, shifts).shifted_scatterers
  for i in range(2):
    assert approx_equal(shifted_scatterers[i].occupancy, -9)
  f = xray.ext.gradient_flags(
    False, False, False, False, True, False, False, False)
  xray.set_scatterer_grad_flags(scatterers = scatterers,
                                site       = f.site,
                                u_iso      = f.u_iso,
                                u_aniso    = f.u_aniso,
                                occupancy  = f.occupancy,
                                fp         = f.fp,
                                fdp        = f.fdp)
  s = xray.ext.minimization_shift_scales(scatterers, 2, 1,2,3,4,5,6)
  assert [int(x) for x in s] == [5]*2
  shifts = flex.double(2, -10)
  shifted_scatterers = xray.ext.minimization_apply_shifts(
    uc, scatterers, shifts).shifted_scatterers
  assert approx_equal(shifted_scatterers[0].fp, -11)
  assert shifted_scatterers[1].fp == -10
  for i in range(2):
    assert shifted_scatterers[i].fdp == scatterers[i].fdp
  f = xray.ext.gradient_flags(
    False, False, False, False, False, True, False, False)
  xray.set_scatterer_grad_flags(scatterers = scatterers,
                                site       = f.site,
                                u_iso      = f.u_iso,
                                u_aniso    = f.u_aniso,
                                occupancy  = f.occupancy,
                                fp         = f.fp,
                                fdp        = f.fdp)
  s = xray.ext.minimization_shift_scales(scatterers, 2, 1,2,3,4,5,6)
  assert [int(x) for x in s] == [6]*2
  shifts = flex.double((2,3))
  shifted_scatterers = xray.ext.minimization_apply_shifts(
    uc, scatterers, shifts).shifted_scatterers
  assert shifted_scatterers[0].fp == -1
  assert approx_equal(shifted_scatterers[0].fdp, 4)
  assert shifted_scatterers[1].fp == 0
  assert shifted_scatterers[1].fdp == 3
  shifts = flex.double(1)
  try:
    xray.ext.minimization_apply_shifts(uc, scatterers, shifts)
  except Exception as e:
    assert str(e) == "scitbx Error: Array of shifts is too small."
  else:
    raise Exception_expected
  shifts = flex.double(3)
  try:
    xray.ext.minimization_apply_shifts(uc, scatterers, shifts)
  except Exception as e:
    assert str(e) == "cctbx Error: Array of shifts is too large."
  else:
    raise Exception_expected

def exercise_minimization_add_gradients():
  uc = uctbx.unit_cell((20, 20, 23))
  scatterers = flex.xray_scatterer((
    xray.scatterer("Si1", site=(0.01,0.02,0.3), fp=-1, fdp=2),
    xray.scatterer("O1", site=(0.3,0.4,0.5),
                   u=adptbx.u_cart_as_u_star(uc,
                     (0.04,0.05,0.06,-.005,0.02,-0.002)))))
  gradient_flags = xray.ext.gradient_flags(
    True, False, False, False, False, False, False, False)
  xray.set_scatterer_grad_flags(scatterers = scatterers,
                                site       = gradient_flags.site,
                                u_iso      = gradient_flags.u_iso,
                                u_aniso    = gradient_flags.u_aniso,
                                occupancy  = gradient_flags.occupancy,
                                fp         = gradient_flags.fp,
                                fdp        = gradient_flags.fdp)
  xray_gradients = flex.double(range(6))
  geometry_restraints_site_gradients = flex.vec3_double([(1,-2,3),(-4,-5,6)])
  xray.ext.minimization_add_gradients(
    scatterers=scatterers,
    xray_gradients=xray_gradients,
    site_gradients=geometry_restraints_site_gradients,
    u_iso_gradients=None,
    u_aniso_gradients=None,
    occupancy_gradients=None)
  assert approx_equal(xray_gradients,
    [1,-1,5,-1,-1,11])
  gradient_flags = xray.ext.gradient_flags(
    True, True, True, True, True, True, False, False)
  xray.set_scatterer_grad_flags(scatterers = scatterers,
                                site       = gradient_flags.site,
                                u_iso      = gradient_flags.u_iso,
                                u_aniso    = gradient_flags.u_aniso,
                                occupancy  = gradient_flags.occupancy,
                                fp         = gradient_flags.fp,
                                fdp        = gradient_flags.fdp)
  xray_gradients = flex.double(range(19))
  xray.ext.minimization_add_gradients(
    scatterers=scatterers,
    xray_gradients=xray_gradients,
    site_gradients=geometry_restraints_site_gradients,
    u_iso_gradients=None,
    u_aniso_gradients=None,
    occupancy_gradients=None)
  assert approx_equal(xray_gradients,
    [1,-1,5,3,4,5,6,3,3,15,10,11,12,13,14,15,16,17,18])
  gradient_flags = xray.ext.gradient_flags(
    True, True, False, True, True, True, False, False)
  xray.set_scatterer_grad_flags(scatterers = scatterers,
                                site       = gradient_flags.site,
                                u_iso      = gradient_flags.u_iso,
                                u_aniso    = gradient_flags.u_aniso,
                                occupancy  = gradient_flags.occupancy,
                                fp         = gradient_flags.fp,
                                fdp        = gradient_flags.fdp)
  xray_gradients = flex.double(range(13))
  xray.ext.minimization_add_gradients(
    scatterers=scatterers,
    xray_gradients=xray_gradients,
    site_gradients=geometry_restraints_site_gradients,
    u_iso_gradients=None,
    u_aniso_gradients=None,
    occupancy_gradients=None)
  assert approx_equal(xray_gradients,
    [1,-1,5,3,4,5,6,3,3,15,10,11,12])
  gradient_flags = xray.ext.gradient_flags(
    True, False, True, True, False, True, False, False)
  xray.set_scatterer_grad_flags(scatterers = scatterers,
                                site       = gradient_flags.site,
                                u_iso      = gradient_flags.u_iso,
                                u_aniso    = gradient_flags.u_aniso,
                                occupancy  = gradient_flags.occupancy,
                                fp         = gradient_flags.fp,
                                fdp        = gradient_flags.fdp)
  xray_gradients = flex.double(range(16))
  xray.ext.minimization_add_gradients(
    scatterers=scatterers,
    xray_gradients=xray_gradients,
    site_gradients=geometry_restraints_site_gradients,
    u_iso_gradients=None,
    u_aniso_gradients=None,
    occupancy_gradients=None)
  assert approx_equal(xray_gradients,
    [1,-1,5,3,4,1,1,13,8,9,10,11,12,13,14,15])
  site_gradients = xray.ext.minimization_extract_site_gradients(
    scatterers=scatterers,
    xray_gradients=xray_gradients)
  assert approx_equal(site_gradients, [(1,-1,5), (1,1,13)])
  #
  gradient_flags = xray.ext.gradient_flags(
    False, True, False, False, False, False, False, False)
  xray.set_scatterer_grad_flags(scatterers = scatterers,
                                site       = gradient_flags.site,
                                u_iso      = gradient_flags.u_iso,
                                u_aniso    = gradient_flags.u_aniso,
                                occupancy  = gradient_flags.occupancy,
                                fp         = gradient_flags.fp,
                                fdp        = gradient_flags.fdp)
  xray_gradients = flex.double([1])
  u_iso_gradients = flex.double([3,0])
  xray.ext.minimization_add_gradients(
    scatterers=scatterers,
    xray_gradients=xray_gradients,
    site_gradients=None,
    u_iso_gradients=u_iso_gradients,
    u_aniso_gradients=None,
    occupancy_gradients=None)
  assert approx_equal(xray_gradients, [4])
  gradient_flags = xray.ext.gradient_flags(
    True, True, True, True, True, True, False, False)
  xray.set_scatterer_grad_flags(scatterers = scatterers,
                                site       = gradient_flags.site,
                                u_iso      = gradient_flags.u_iso,
                                u_aniso    = gradient_flags.u_aniso,
                                occupancy  = gradient_flags.occupancy,
                                fp         = gradient_flags.fp,
                                fdp        = gradient_flags.fdp)
  xray_gradients = flex.double(range(19))
  xray.ext.minimization_add_gradients(
    scatterers=scatterers,
    xray_gradients=xray_gradients,
    site_gradients=None,
    u_iso_gradients=u_iso_gradients,
    u_aniso_gradients=None,
    occupancy_gradients=None)
  assert approx_equal(xray_gradients,
    [0,1,2,6,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18])
  gradient_flags = xray.ext.gradient_flags(
    True, True, False, True, True, True, False, False)
  xray.set_scatterer_grad_flags(scatterers = scatterers,
                                site       = gradient_flags.site,
                                u_iso      = gradient_flags.u_iso,
                                u_aniso    = gradient_flags.u_aniso,
                                occupancy  = gradient_flags.occupancy,
                                fp         = gradient_flags.fp,
                                fdp        = gradient_flags.fdp)
  xray_gradients = flex.double(range(13))
  xray.ext.minimization_add_gradients(
    scatterers=scatterers,
    xray_gradients=xray_gradients,
    site_gradients=None,
    u_iso_gradients=u_iso_gradients,
    u_aniso_gradients=None,
    occupancy_gradients=None)
  assert approx_equal(xray_gradients,
    [0,1,2,6,4,5,6,7,8,9,10,11,12])
  gradient_flags = xray.ext.gradient_flags(
    False, True, True, True, False, True, False, False)
  xray.set_scatterer_grad_flags(scatterers = scatterers,
                                site       = gradient_flags.site,
                                u_iso      = gradient_flags.u_iso,
                                u_aniso    = gradient_flags.u_aniso,
                                occupancy  = gradient_flags.occupancy,
                                fp         = gradient_flags.fp,
                                fdp        = gradient_flags.fdp)
  xray_gradients = flex.double(range(11))
  xray.ext.minimization_add_gradients(
    scatterers=scatterers,
    xray_gradients=xray_gradients,
    site_gradients=None,
    u_iso_gradients=u_iso_gradients,
    u_aniso_gradients=None,
    occupancy_gradients=None)
  assert approx_equal(xray_gradients,
    [3,1,2,3,4,5,6,7,8,9,10])
  #
  gradient_flags = xray.ext.gradient_flags(
    False, False, False, True, False, False, False, False)
  xray.set_scatterer_grad_flags(scatterers = scatterers,
                                site       = gradient_flags.site,
                                u_iso      = gradient_flags.u_iso,
                                u_aniso    = gradient_flags.u_aniso,
                                occupancy  = gradient_flags.occupancy,
                                fp         = gradient_flags.fp,
                                fdp        = gradient_flags.fdp)
  xray_gradients = flex.double([1,2])
  occupancy_gradients = flex.double([3,4])
  xray.ext.minimization_add_gradients(
    scatterers=scatterers,
    xray_gradients=xray_gradients,
    site_gradients=None,
    u_iso_gradients=None,
    u_aniso_gradients=None,
    occupancy_gradients=occupancy_gradients)
  assert approx_equal(xray_gradients, [4,6])
  xray_gradients = flex.double([2,1])
  xray.ext.minimization_add_gradients(
    scatterers=scatterers,
    xray_gradients=xray_gradients,
    site_gradients=None,
    u_iso_gradients=None,
    u_aniso_gradients=None,
    occupancy_gradients=None)
  assert approx_equal(xray_gradients, [2,1])
  #
  gradient_flags = xray.ext.gradient_flags(
    False, False, True, False, False, False, False, False)
  xray.set_scatterer_grad_flags(scatterers = scatterers,
                                site       = gradient_flags.site,
                                u_iso      = gradient_flags.u_iso,
                                u_aniso    = gradient_flags.u_aniso,
                                occupancy  = gradient_flags.occupancy,
                                fp         = gradient_flags.fp,
                                fdp        = gradient_flags.fdp)
  xray_gradients = flex.double(range(6))
  xray.ext.minimization_add_gradients(
    scatterers=scatterers,
    xray_gradients=xray_gradients,
    site_gradients=None,
    u_iso_gradients=None,
    u_aniso_gradients=flex.sym_mat3_double([(0,0,0,0,0,0),(1,-1,-4,-7,12,-3)]),
    occupancy_gradients=None)
  assert approx_equal(xray_gradients,
    [1, 0, -2, -4, 16, 2])
  #
  gradient_flags = xray.ext.gradient_flags(
    True, False, True, False, False, False, False, False)
  xray.set_scatterer_grad_flags(scatterers = scatterers,
                                site       = gradient_flags.site,
                                u_iso      = gradient_flags.u_iso,
                                u_aniso    = gradient_flags.u_aniso,
                                occupancy  = gradient_flags.occupancy,
                                fp         = gradient_flags.fp,
                                fdp        = gradient_flags.fdp)
  xray_gradients = flex.double(range(12))
  xray.ext.minimization_add_gradients(
    scatterers=scatterers,
    xray_gradients=xray_gradients,
    site_gradients=flex.vec3_double([(1,-2,3),(-4,-5,6)]),
    u_iso_gradients=None,
    u_aniso_gradients=flex.sym_mat3_double([(0,0,0,0,0,0),(1,-1,-4,-7,12,-3)]),
    occupancy_gradients=None)
  assert approx_equal(xray_gradients,
    [1,-1,5,-1,-1,11,7, 6, 4, 2, 22, 8])

def exercise_asu_mappings():
  from cctbx.development import random_structure
  structure = random_structure.xray_structure(
    space_group_info=sgtbx.space_group_info("P 31"),
    elements=["O"]*10)
  asu_mappings = crystal.direct_space_asu.asu_mappings(
    space_group=structure.space_group(),
    asu=structure.direct_space_asu().as_float_asu(),
    buffer_thickness=3)
  xray.asu_mappings_process(
    asu_mappings=asu_mappings,
    scatterers=structure.scatterers(),
    site_symmetry_table=structure.site_symmetry_table())
  assert asu_mappings.mappings().size() == structure.scatterers().size()

def exercise_targets_common_results():
  r = xray.targets_common_results(
    target_per_reflection=flex.double([1,2,3]),
    target_work=13,
    target_test=None,
    gradients_work=flex.complex_double([1+2j,2+3j,3-4j]))
  assert approx_equal(r.target_per_reflection(), [1,2,3])
  assert approx_equal(r.target_work(), 13)
  assert r.target_test() is None
  assert approx_equal(r.gradients_work(), [1+2j,2+3j,3-4j])
  r = xray.targets_common_results(
    target_per_reflection=flex.double(),
    target_work=42,
    target_test=53,
    gradients_work=flex.complex_double())
  assert r.target_per_reflection().size() == 0
  assert approx_equal(r.target_work(), 42)
  assert approx_equal(r.target_test(), 53)
  assert r.gradients_work().size() == 0

def exercise_targets_least_squares():
  f_obs = flex.double((1,2,3,4,5))
  w = flex.double((1,1,1,1,1))
  f_calc = flex.complex_double((1,2,3,4,5))
  #
  ls = xray.targets_least_squares(
    compute_scale_using_all_data=True,
    obs_type="F",
    obs=f_obs,
    weights=w,
    r_free_flags=None,
    f_calc=f_calc,
    derivatives_depth=0,
    scale_factor=0)
  assert approx_equal(ls.scale_factor(), 1)
  assert approx_equal(ls.target_per_reflection(), [0]*5)
  assert approx_equal(ls.target_work(), 0)
  assert ls.target_test() is None
  assert ls.gradients_work().size() == 0
  #
  ls = xray.targets_least_squares(
    compute_scale_using_all_data=True,
    obs_type="F",
    obs=f_obs,
    weights=w,
    r_free_flags=None,
    f_calc=f_calc,
    derivatives_depth=0,
    scale_factor=2.0)
  assert approx_equal(ls.scale_factor(), 2.0)
  assert approx_equal(ls.target_per_reflection(), [1,4,9,16,25])
  assert approx_equal(ls.target_work(),1.0)
  assert ls.gradients_work().size() == 0
  #
  f_obs = flex.double((1,2,3))
  w = flex.double((3,2,1))
  f_calc = flex.complex_double((4,5,6))
  #
  ls = xray.targets_least_squares(
    compute_scale_using_all_data=True,
    obs_type="F",
    obs=f_obs,
    weights=w,
    r_free_flags=None,
    f_calc=f_calc,
    derivatives_depth=1,
    scale_factor=0)
  assert approx_equal(ls.scale_factor(), 50./134.)
  assert approx_equal(ls.target_work(), 0.0671641791)
  assert approx_equal(ls.gradients_work(),
                     ((0.0551347738+0j),(-0.0100245043+0j),(-0.0284027623+0j)) )
  #
  ls = xray.targets_least_squares(
    compute_scale_using_all_data=True,
    obs_type="F",
    obs=f_obs,
    weights=w,
    r_free_flags=None,
    f_calc=f_calc,
    derivatives_depth=1,
    scale_factor=2.0)
  assert approx_equal(ls.scale_factor(), 2.0)
  assert approx_equal(ls.target_work(),17.8)
  assert approx_equal(ls.gradients_work(), ((4.2+0j),(3.2+0j),(1.8+0j)) )
  #
  f_obs = flex.double((1,2,3))
  w = flex.double((3,2,1))
  f_calc = flex.complex_double((1+2j,3+4j,-1-2j))
  #
  ls = xray.targets_least_squares(
    compute_scale_using_all_data=True,
    obs_type="F",
    obs=f_obs,
    weights=w,
    r_free_flags=None,
    f_calc=f_calc,
    derivatives_depth=1,
    scale_factor=0)
  assert approx_equal(ls.scale_factor(), 0.4773772552)
  assert approx_equal(ls.target_work(), 0.2023883467)
  assert approx_equal(ls.gradients_work(),
                       ((0.0043198335244903152+0.0086396670489806305j),
                        (0.022162885026120613+0.029550513368160818j),
                        (0.041257975234691303+0.082515950469382607j)) )
  #
  f_obs = flex.double((1,2,3,4,5))
  w = flex.double((1,1,1,1,1))
  f_calc = flex.complex_double((1,2,3,4,5))
  #
  f_obs = flex.double((1,2,3))
  w = flex.double((3,2,1))
  f_calc = flex.complex_double((4,5,6))
  #
  f_obs = flex.double((1,2,3))
  w = flex.double((3,2,1))
  f_calc = flex.complex_double((1+2j,3+4j,-1-2j))
  #
  f_obs = flex.double((1,2,3,4,5))
  w = flex.double((1,1,1,1,1))
  r_free_flags = flex.bool([False,True,False,True,False])
  f_calc = flex.complex_double((2,3,4,5,6))
  ls = xray.targets_least_squares(
    compute_scale_using_all_data=False,
    obs_type="F",
    obs=f_obs,
    weights=w,
    r_free_flags=r_free_flags,
    f_calc=f_calc,
    derivatives_depth=1,
    scale_factor=0)
  assert not ls.compute_scale_using_all_data()
  assert approx_equal(ls.scale_factor(), 0.785714285714)
  assert approx_equal(ls.target_work(), 0.0122448979592)
  assert approx_equal(ls.target_test(), 0.00663265306122)
  assert approx_equal(ls.gradients_work(), [
    0.025655976676384838+0j,
    0.0064139941690962068+0j,
    -0.012827988338192414-0j])
  #
  ls = xray.targets_least_squares(
    compute_scale_using_all_data=False,
    obs_type="F",
    obs=f_obs,
    weights=w,
    r_free_flags=r_free_flags,
    f_calc=flex.complex_double(5), # all f_calc 0
    derivatives_depth=1,
    scale_factor=1)
  assert approx_equal(ls.scale_factor(), 1)
  assert approx_equal(ls.target_work(), 1)
  assert approx_equal(ls.target_test(), 1)
  assert approx_equal(ls.gradients_work(), [0j,0j,0j])

def exercise_maximum_likelihood_targets():
  f_obs = flex.double([
    35.6965, 308.042, 128.949, 35.4385, 29.259, 108.11, 35.3133, 67.2968,
    109.585, 130.959, 78.7692, 138.602])
  r_free_flags = flex.bool([
    False, False, True, True, False, False, False, False, False, False,
    False, False])
  experimental_phases = flex.hendrickson_lattman([
    [0.457488,0,0,0], [-0.769364,0,0,0], [1.19222,0,0,0], [-0.0931637,0,0,0],
    [0.890576,0,0,0], [-1.66137,1.69479,-0.107808,1.41357],
    [-0.00674594,0.847689,-1.4854,0.547142],
    [-0.0295139,-0.00293545,0.130557,0.0780442], [-0.409673,0,0,0],
    [-0.416943,0,0,0], [0.101886,2.88433,2.87327,2.71556], [0.901622,0,0,0]])
  f_calc = flex.complex_double([
    -19.5412, -171.232, 69.435, -32.7787, -41.0725, 32.8168+39.3201j,
    36.8631-10.3995j, -7.23216-79.5072j, 71.4597, 69.1851,
    41.9767-14.4786j, 73.0327])
  alpha = flex.double([
    0.211893, 0.368057, 0.71595, 0.6732, 0.858985, 0.987573, 0.973331,
    0.161511, 0.439952, 0.530318, 0.272504, 0.95601])
  beta = flex.double([
    0.963688, 0.243077, 0.755248, 0.98828, 0.668677, 0.0767036, 0.745345,
    0.55896, 0.415472, 0.0690112, 0.563668, 0.329134])
  epsilons = flex.int([2, 4, 1, 8, 1, 1, 2, 1, 4, 1, 8, 1])
  centric_flags = flex.bool([
    True, True, True, True, True, False, False, False, True, True,
    False, True])
  for rff in [None, r_free_flags]:
    for compute_gradients in [False, True]:
      ml = xray.mlf_target_and_gradients(
        f_obs=f_obs,
        r_free_flags=rff,
        f_calc=f_calc,
        alpha=alpha,
        beta=beta,
        scale_factor=1,
        epsilons=epsilons.as_double(),
        centric_flags=centric_flags,
        compute_gradients=compute_gradients)
      tpr = ml.target_per_reflection()
      tw = ml.target_work()
      tt = ml.target_test()
      gw = ml.gradients_work()
      assert approx_equal(tpr, [
        259.57027227308151, 30872.934956654299, 4157.3629318162803,
        13.260741195206734, 27.831255194364076, 43149.780572387972,
        3.3949285154155859, 5294.345206664615, 1838.4876581905569,
        64384.962967657091, 986.06706016214844, 7187.3520116172294])
      if (not compute_gradients):
        assert gw.size() == 0
      if (rff is None):
        assert approx_equal(tw, 13181.2792135)
        assert tt is None
        if (compute_gradients):
          assert approx_equal(gw, [
            (0.28910053111650247+0j), (7.7291101812048604+0j),
            (-6.2595044456051188+0j), (0.094882323440219324+0j),
            (-0.64462074968137506+0j), (-79.103928224377-94.779941011168859j),
            (0.20707720782494976-0.058418836798195622j),
            (0.23728742278013587+2.6086340153515435j),
            (-1.7239709842603137+0j), (-60.367607555268741+0j),
            (-0.63389304157017523+0.21864233709838887j),
            (-16.648813735508114+0j)])
      else:
        assert approx_equal(tw, 15400.4726889)
        assert approx_equal(tt, 2085.31183651)
        if (compute_gradients):
          assert approx_equal(gw, [
            (0.34692063733980305+0j), (9.2749322174458335+0j),
            (-0.77354489961765016+0j),
            (-94.924713869252415-113.73592921340264j),
            (0.24849264938993973-0.070102604157834744j),
            (0.28474490733616309+3.1303608184218525j),
            (-2.0687651811123766+0j), (-72.441129066322489+0j),
            (-0.76067164988421032+0.26237080451806666j),
            (-19.978576482609739+0j)])
        mlw = xray.mlf_target_and_gradients(
          f_obs=f_obs.select(~rff),
          r_free_flags=None,
          f_calc=f_calc.select(~rff),
          alpha=alpha.select(~rff),
          beta=beta.select(~rff),
          scale_factor=1,
          epsilons=epsilons.select(~rff).as_double(),
          centric_flags=centric_flags.select(~rff),
          compute_gradients=compute_gradients)
        assert approx_equal(mlw.target_per_reflection(), tpr.select(~rff))
        assert approx_equal(mlw.target_work(), tw)
        assert mlw.target_test() is None
        assert approx_equal(mlw.gradients_work(), gw)
      ml = xray.mlhl_target_and_gradients(
        f_obs=f_obs,
        r_free_flags=rff,
        experimental_phases=experimental_phases,
        f_calc=f_calc,
        alpha=alpha,
        beta=beta,
        epsilons=epsilons.as_double(),
        centric_flags=centric_flags,
        integration_step_size=5,
        compute_gradients=compute_gradients)
      tpr = ml.target_per_reflection()
      tw = ml.target_work()
      tt = ml.target_test()
      gw = ml.gradients_work()
      assert approx_equal(tpr, [
        259.4738891742619, 30871.95384262779, 4156.0852750170579,
        11.907959982009571, 28.697266914523933, 43148.119151934428,
        2.9161647472283221, 5293.4083862783209, 1838.4175626851754,
        64386.490862538834, 983.86578354410517, 7186.7802434227397])
      if (not compute_gradients):
        assert gw.size() == 0
      if (rff is None):
        assert approx_equal(tw, 13180.6763657)
        assert tt is None
        if (compute_gradients):
          assert approx_equal(gw, [
            (0.28910053111650247-4.778461360683447e-19j),
            (7.7291101812048604+9.1707854448857317e-20j),
            (-6.2595044456051188+0j),
            (0.094882323440219324+5.8011567980489493e-20j),
            (-0.64462074968137495-4.4256743068048503e-19j),
            (-79.574611695327491-94.387109668225506j),
            (0.19351597841962068-0.10406336738042934j),
            (0.22621461424524394+2.6101454947879947j),
            (-1.7239709842603133+0j), (-60.367607555268734+0j),
            (-0.64001526423037869+0.20000512034506801j),
            (-16.648813735508117+0j)])
      else:
        assert approx_equal(tw, 15400.0123154)
        assert approx_equal(tt, 2083.9966175)
        if (compute_gradients):
          assert approx_equal(gw, [
            (0.34692063733980305-5.7341536328201376e-19j),
            (9.2749322174458335+1.100494253386288e-19j),
            (-0.77354489961765005-5.3108091681658213e-19j),
            (-95.489534034392989-113.26453160187062j),
            (0.23221917410354484-0.12487604085651523j),
            (0.27145753709429277+3.132174593745594j),
            (-2.0687651811123762+0j), (-72.441129066322489+0j),
            (-0.76801831707645452+0.24000614441408163j),
            (-19.978576482609743+0j)])
        mlw = xray.mlhl_target_and_gradients(
          f_obs=f_obs.select(~rff),
          r_free_flags=None,
          experimental_phases=experimental_phases.select(~rff),
          f_calc=f_calc.select(~rff),
          alpha=alpha.select(~rff),
          beta=beta.select(~rff),
          epsilons=epsilons.select(~rff).as_double(),
          centric_flags=centric_flags.select(~rff),
          integration_step_size=5,
          compute_gradients=compute_gradients)
        assert approx_equal(mlw.target_per_reflection(), tpr.select(~rff))
        assert approx_equal(mlw.target_work(), tw)
        assert mlw.target_test() is None
        assert approx_equal(mlw.gradients_work(), gw)

def exercise_twin_components():
  twin_a = xray.twin_component(sgtbx.rot_mx((0,1,0,1,0,0,0,0,-1)),
                               value=0.5,
                               grad=True)
  assert twin_a.value == 0.5
  assert twin_a.twin_law == sgtbx.rot_mx((0,1,0,1,0,0,0,0,-1))
  assert twin_a.grad == True
  twin_a.grad = False
  assert twin_a.grad == False
  pickled_twin_a = pickle.dumps(twin_a, pickle.HIGHEST_PROTOCOL)
  unpickled_twin_a = pickle.loads(pickled_twin_a)
  assert twin_a.value == unpickled_twin_a.value
  assert twin_a.twin_law == unpickled_twin_a.twin_law
  assert twin_a.grad == unpickled_twin_a.grad

  twin_b = xray.twin_component(sgtbx.rot_mx((-1,0,0,0,-1,0,0,0,-1)),
                               value=0.2,
                               grad = False)
  assert twin_b.grad == False
  twins = (twin_a, twin_b)
  xray.set_grad_twin_fraction(twins, True)
  assert twin_a.grad == True
  assert twin_b.grad == True
  assert xray.sum_twin_fractions(twins) == 0.7

def exercise_extinction_correction():
  uc = uctbx.unit_cell((13,15,17,85,95,105))
  wavelength = 1.3
  extinction_val = 0.134
  h = (1,2,3)
  fc_sq = 3.456
  ec = xray.shelx_extinction_correction(uc, wavelength, value=extinction_val)
  ec.grad = True
  c = ec.compute(h, fc_sq, True)
  # just check that the formulae are the same one...
  p = 0.001*pow(wavelength,3)*fc_sq/uc.sin_two_theta(h, wavelength)
  c_v = pow(1+extinction_val*p,-0.5)
  c_g = -0.5*fc_sq*p*pow(1+p*extinction_val,-1.5)
  assert approx_equal(c[0], c_v)
  assert approx_equal(c[1], c_g)
  #now try numerical differentiation and compare
  step = 1e-8
  c_g_n = -ec.compute(h, fc_sq, False)[0]
  ec.value += step
  c_g_n += ec.compute(h, fc_sq, False)[0]
  c_g_n = c_g_n*fc_sq/step
  assert approx_equal(c[1], c_g_n)

def exercise_r_factor():
  f_obs  = flex.double([1,2,3,4,5,6,7,8,9])
  f_calc = flex.complex_double([1,2,3,4,5,6,7,8,9])
  r = xray.r_factor(fo=f_obs, fc=f_calc)
  assert approx_equal(r.value(), 0)
  assert approx_equal(r.scale_ls(), 1)
  assert approx_equal(r.scale_ls(), 1)
  f_obs  = flex.double([1,2,3,4,5,6,7,8,9])
  f_calc = flex.complex_double([10,20,30,40,50,60,70,80,90])
  r = xray.r_factor(fo=f_obs, fc=f_calc)
  assert approx_equal(r.value(), 0)
  assert approx_equal(r.scale_ls(), 0.1)
  assert approx_equal(r.scale_ls(), 0.1)

def run():
  exercise_scattering_type_registry_1()
  exercise_r_factor()
  exercise_extinction_correction()
  exercise_twin_components()
  exercise_scatterer_flags()
  exercise_set_selected_scatterer_grad_flags()
  exercise_set_scatterer_grad_flags()
  exercise_scatterer_flags_counts()
  exercise_xray_scatterer()
  exercise_conversions()
  exercise_gradient_flags()
  exercise_scattering_type_registry()
  exercise_rotate()
  exercise_structure_factors()
  exercise_targets()
  exercise_sampled_model_density()
  exercise_minimization_apply_shifts()
  exercise_minimization_add_gradients()
  exercise_asu_mappings()
  exercise_targets_common_results()
  exercise_targets_least_squares()
  exercise_maximum_likelihood_targets()
  print("OK")

if (__name__ == "__main__"):
  run()


 *******************************************************************************


 *******************************************************************************
cctbx/xray/ext.py
from __future__ import absolute_import, division, print_function
import boost_adaptbx.boost.python as bp
from six.moves import zip
ext = bp.import_ext("cctbx_xray_ext")
from cctbx_xray_ext import *

from cctbx.array_family import flex
import sys

@bp.inject_into(scattering_type_registry)
class _():

  def type_count_dict(self):
    result = {}
    unique_counts = list(self.unique_counts)
    for t,i in self.type_index_pairs_as_dict().items():
      result[t] = unique_counts[i]
    return result

  def sorted_type_index_pairs(self, heaviest_first=True):
    ugs = self.unique_gaussians_as_list()
    pairs = []
    sf0s = flex.double()
    for t,i in self.type_index_pairs_as_dict().items():
      pairs.append((t,i))
      gaussian = ugs[i]
      if (gaussian is None):
        sf0s.append(0)
      else:
        sf0s.append(gaussian.at_stol(0))
    perm = flex.sort_permutation(sf0s, reverse=heaviest_first)
    return flex.select(pairs, permutation=perm)

  def show_summary(self, out=None, prefix=""):
    if (out is None): out = sys.stdout
    unique_gaussians = self.unique_gaussians_as_list()
    unique_counts = list(self.unique_counts)
    parts = []
    for t,i in self.sorted_type_index_pairs():
      gaussian = unique_gaussians[i]
      if (gaussian is None):
        gn = "None"
      else:
        gn = str(gaussian.n_terms())
        if (gaussian.c() != 0):
          gn += "+c"
      parts.append("%s%s:%s*%d" % (prefix, t, gn, unique_counts[i]))
      prefix = ""
    print(" ".join(parts), file=out)

  def warning_if_any(self,std_lbl):
    if( self.last_table()=="neutron" ):
      from cctbx.eltbx.neutron import neutron_news_1992_table
      scattering_info = neutron_news_1992_table(std_lbl, True)
      b = scattering_info.bound_coh_scatt_length()
      if(b.imag != 0.0):
        return " WARNING! anomalous neutron scattering ("+str(b.imag) \
            +") is ignored!"
    return ""

  def show(self,
        header="Number of scattering types:",
        show_sf0=True,
        show_gaussians=True,
        out=None,
        prefix=""):
    if (out is None): out = sys.stdout
    unique_gaussians = self.unique_gaussians_as_list()
    unique_counts = list(self.unique_counts)
    tips = self.sorted_type_index_pairs()
    if (header is not None):
      print(prefix + header, len(tips), file=out)
    if (len(tips) == 0):
      print(prefix + "  Empty scattering-type registry.", file=out)
    else:
      nt = max(3,max([len(t) for t,i in tips]))
      nt_fmt = "%%-%ds " % nt
      nc = max(5,len(str(max(unique_counts))))
      nc_fmt = "%%%dd" % nc
      line = prefix + "  Type%s %sNumber" % (" "*(nt-3), " "*(nc-5))
      if (show_sf0): line += "    sf(0)"
      if (show_gaussians): line += "   Gaussians"
      print(line, file=out)
      for t,i in tips:
        line = prefix + "   " \
             + nt_fmt%t \
             + nc_fmt%unique_counts[i] + " "
        gaussian = unique_gaussians[i]
        if (show_sf0):
          if (gaussian is None):
            line += "     None"
          else:
            line += " %8.2f" % gaussian.at_stol(0)
        if (show_gaussians):
          if (gaussian is None):
            line += "      None"
          else:
            line += " %7s" % str(gaussian.n_terms())
            if (gaussian.c() != 0): line += "+c"
        print("%s%s" % (line.rstrip(), self.warning_if_any(t)), file=out)
      if (show_sf0):
        print(prefix \
          + "  sf(0) = scattering factor at diffraction angle 0.", file=out)

  def sum_of_scattering_factors_at_diffraction_angle_0(self):
    result = 0
    for g,c in zip(self.unique_gaussians_as_list(), self.unique_counts):
      result += g.at_stol(0) * c
    return result

  def wilson_dict(self):
    result = {}
    unique_counts = list(self.unique_counts)
    for t,i in self.sorted_type_index_pairs():
      result[t] = unique_counts[i]
    return result

  def as_type_gaussian_dict(self):
    result = {}
    ugs = self.unique_gaussians_as_list()
    for t,i in self.type_index_pairs_as_dict().items():
      result[t] = ugs[i]
    return result

@bp.inject_into(sampled_model_density)
class _():

  def real_map_unpadded(self):
    from cctbx import maptbx
    result = self.real_map()
    if (not result.is_padded()): return result
    return maptbx.copy(result, flex.grid(result.focus()))


 *******************************************************************************


 *******************************************************************************
cctbx/xray/minimization.py
from __future__ import absolute_import, division, print_function
import cctbx.xray.structure_factors
from cctbx.xray import ext
from cctbx import crystal
from cctbx.array_family import flex
import scitbx.lbfgs
import scitbx.math
from libtbx import adopt_init_args
import math

def add_gradients(
      scatterers,
      xray_gradients,
      site_gradients      = None,
      u_iso_gradients     = None,
      u_aniso_gradients   = None,
      occupancy_gradients = None):
  ext.minimization_add_gradients(scatterers          = scatterers,
                                 xray_gradients      = xray_gradients,
                                 site_gradients      = site_gradients,
                                 u_iso_gradients     = u_iso_gradients,
                                 u_aniso_gradients   = u_aniso_gradients,
                                 occupancy_gradients = occupancy_gradients)

class occupancy_penalty_exp(object):

  def __init__(self,
        penalty_factor=1,
        penalty_scale=100,
        min_functional=1.e-10):
    adopt_init_args(self, locals())
    self.occupancy_max = -math.log(min_functional) \
                       / (penalty_factor * penalty_scale)

  def functional(self, occupancy):
    if (occupancy > self.occupancy_max): return 0
    if (occupancy < -1): occupancy = -1 - math.log(-occupancy)
    s = self.penalty_scale
    return math.exp(-s*occupancy*self.penalty_factor)

  def gradient(self, occupancy):
    if (occupancy > self.occupancy_max): return 0
    if (occupancy < -1): occupancy = -1 - math.log(-occupancy)
    s = self.penalty_scale
    return -s*self.penalty_factor*math.exp(-s*occupancy*self.penalty_factor)

class lbfgs(object):
  """
  A minimisation of a function of the free parameters of a X-ray structure,
  relying on the LBFGS algorithm.

  That function is represented by a functor object f which should abide to the
  following interface
    - B{f.f_obs()}
    - B{f(f_calc, compute_derivatives)}
  in the manner of `cctbx.xray.target_functors.least_squares_residual`
  or `cctbx.xray.target_functors.intensity_correlation`
  """

  def __init__(self, target_functor, xray_structure,
                     occupancy_penalty=None,
                     lbfgs_termination_params=None,
                     lbfgs_core_params=None,
                     correct_special_position_tolerance=1.e-2,
                     cos_sin_table=True,
                     structure_factor_algorithm=None,
                     verbose=0):
    """
    :Parameters:

      target_functor : any object like f
        the numerical function of the structure to minimise
      xray_structure : `cctbx.xray.structure`
        the structure the target_functor is calculated for
      occupancy_penalty
        TODO
      lbfgs_termination_params : like `scitbx.lbfgs.termination_parameters`
        the bunch of parameters used to decide where to stop the minimisation
      lbfgs_core_params : like `scitbx.lbfgs.core_parameters`
        the bunch of parameters for the numerical core of the lbfgs algorithm
      correct_special_position_tolerance : number
        the threshold for the distance to a special position below which
        an atom is snapped onto it
      cos_sin_table : bool
        whether to use tabulated cosines and sines in structure factor
        computations
      structure_factor_algorithm : string
        the name of the method to be used to compute structure factors;
        it must be one of those provided by the factory
        `cctbx.xray.structure_factors.from_scatterers`
      verbose : int
        a flag specifying the verbosity of the log printed out during the
        minimisation process; 0 means silent whereas positive numbers
        print an increasing amount of information
    """
    adopt_init_args(self, locals())
    self.scatterer_grad_flags_counts = ext.scatterer_grad_flags_counts(
                                              self.xray_structure.scatterers())
    self.grad_flags_counts = \
              ext.scatterer_grad_flags_counts(self.xray_structure.scatterers())
    self.structure_factors_from_scatterers = \
      cctbx.xray.structure_factors.from_scatterers(
        miller_set=self.target_functor.f_obs(),
        cos_sin_table=cos_sin_table)
    self.structure_factor_gradients = \
      cctbx.xray.structure_factors.gradients(
        miller_set=self.target_functor.f_obs(),
        cos_sin_table=cos_sin_table)
    self.x = flex.double(xray_structure.n_parameters(), 0)
    xray_structure.tidy_us(u_min=1.e-6)
    self._scatterers_start = xray_structure.scatterers()
    self._d_min = self.target_functor.f_obs().d_min()
    self.first_target_value = None
    self.minimizer = scitbx.lbfgs.run(
      target_evaluator=self,
      termination_params=lbfgs_termination_params,
      core_params=lbfgs_core_params)
    self.apply_shifts()
    del self._scatterers_start
    del self._d_min
    self.compute_target(compute_gradients=False)
    self.final_target_value = self.target_result.target()

  def apply_shifts(self):
    apply_shifts_result = ext.minimization_apply_shifts(
      unit_cell=self.xray_structure.unit_cell(),
      scatterers=self._scatterers_start,
      shifts=self.x)
    shifted_scatterers = apply_shifts_result.shifted_scatterers
    site_symmetry_table = self.xray_structure.site_symmetry_table()
    for i_seq in site_symmetry_table.special_position_indices():
      shifted_scatterers[i_seq].site = crystal.correct_special_position(
        crystal_symmetry=self.xray_structure,
        special_op=site_symmetry_table.get(i_seq).special_op(),
        site_frac=shifted_scatterers[i_seq].site,
        tolerance=self.correct_special_position_tolerance)
    self.xray_structure.replace_scatterers(scatterers=shifted_scatterers)
    return apply_shifts_result.u_iso_refinable_params

  def compute_target(self, compute_gradients):
    self.f_calc = self.structure_factors_from_scatterers(
      xray_structure=self.xray_structure,
      miller_set=self.target_functor.f_obs(),
      algorithm=self.structure_factor_algorithm).f_calc()
    self.target_result = self.target_functor(
      self.f_calc,
      compute_gradients)
    assert self.target_result.target() is not None

  def compute_functional_and_gradients(self):
    u_iso_refinable_params = self.apply_shifts()
    self.compute_target(compute_gradients=True)
    self.f = self.target_result.target()
    if (self.first_target_value is None):
      self.first_target_value = self.f
    if (self.occupancy_penalty is not None
        and self.grad_flags_counts != 0):
      occupancies = self.xray_structure.scatterers().extract_occupancies()
      for occupancy in occupancies:
        self.f += self.occupancy_penalty.functional(occupancy=occupancy)
    self.g = self.structure_factor_gradients(
      xray_structure=self.xray_structure,
      u_iso_refinable_params=u_iso_refinable_params,
      miller_set=self.target_functor.f_obs(),
      d_target_d_f_calc=self.target_result.derivatives(),
      n_parameters=self.x.size(),
      algorithm=self.structure_factor_algorithm).packed()
    if (self.occupancy_penalty is not None
        and self.grad_flags_counts != 0):
      g = flex.double()
      for occupancy in occupancies:
        g.append(self.occupancy_penalty.gradient(occupancy=occupancy))
      del occupancies
      add_gradients(
        scatterers=self.xray_structure.scatterers(),
        xray_gradients=self.g,
        occupancy_gradients=g)
      del g
    if (self.verbose > 1):
      print("xray.minimization line search: f,rms(g):", end=' ')
      print(self.f, math.sqrt(flex.mean_sq(self.g)))
    return self.f, self.g

  def callback_after_step(self, minimizer):
    if (self.verbose > 0):
      print("xray.minimization step: f,iter,nfun:", end=' ')
      print(self.f,minimizer.iter(),minimizer.nfun())


 *******************************************************************************


 *******************************************************************************
cctbx/xray/observation_types.py
from __future__ import absolute_import, division, print_function
class any(object):

  def __repr__(self):
    return "xray." + self.__class__.__name__

class amplitude(any): pass
class intensity(any): pass
class reconstructed_amplitude(amplitude): pass


 *******************************************************************************


 *******************************************************************************
cctbx/xray/observations/__init__.py
from __future__ import absolute_import, division, print_function
from cctbx_xray_observations_ext import *

def customized_copy(obs, twin_fractions=None, twin_components=None):
  """ Creates a copy of the observation object and with new twin fractions
  and twin components
  """
  twf = ()
  if twin_fractions is not None:
    twf = twin_fractions
  twc = ()
  if twin_components is not None:
    twc = twin_components
  result = observations(obs, twf, twc)
  result.fo_sq = obs.fo_sq
  result.ref_twin_fractions = twin_fractions
  result.ref_twin_components = twin_components
  return result


 *******************************************************************************


 *******************************************************************************
cctbx/xray/observations/tst_observations.py
from __future__ import absolute_import, division, print_function
from cctbx import sgtbx, uctbx, crystal, xray
from cctbx.xray import observations
from iotbx.shelx import hklf
from six.moves import cStringIO as StringIO

def excersise():
  s = """\
  -1  -6   9624.8650 54.9190   1
  -1   6   9749.5660 52.1870  -2
   1   6  -9749.5660 52.1870   1
   1  -6  -8695.6020 53.8100  -2
  -1  -6   8695.6020 53.8100   1
  -1   6   8746.7970 51.3980  -2
   1   6  -8746.7970 51.3980   1
  -1  -6 -12281.3590 49.5060   1
   1   6  12185.9370 47.3950   1
  -1  -6 -1316.0700044.01400   1
   1   6  13 4.7500043.54900   1
  -1  -6 -1479.6380048.66400   2
   1   6  1432.7830051.51700   2
  """
  sg = sgtbx.space_group("P 1")
  uc = uctbx.unit_cell((11,11,13,90,90,120))
  cs = crystal.symmetry(unit_cell=uc, space_group=sg)
  ma = hklf.reader(file_object=StringIO(s))\
         .as_miller_arrays(crystal_symmetry=cs, merge_equivalents=False)
  fo_sq = ma[0]
  batch_numbers = ma[1]
  obs = fo_sq.as_xray_observations(
          scale_indices=batch_numbers.data(),
          twin_fractions=(xray.twin_fraction(0.4,True),))
  measured_cnt = 0
  measured_scale_indices = obs.measured_scale_indices
  for bn in batch_numbers.data():
    if bn > 0:
      assert(measured_scale_indices[measured_cnt]==bn)
      measured_cnt = measured_cnt+1
  assert(measured_cnt == obs.indices.size())

  itr = obs.iterator(0)
  assert(not itr.has_next())
  itr = obs.iterator(1)
  assert(itr.next().h==(-1,6,9))
  itr = obs.iterator(2)
  assert(itr.next().h==(1,-6,-8))

  # this is supposed to fail for now until somebody re-implements
  # mixed HKLF 5 + merohedral twinning in a meaningful way...
  try:
    obs = observations.customized_copy(obs,
            twin_fractions=(xray.twin_fraction(0.7,True),),
            twin_components=(xray.twin_component(
                sgtbx.rot_mx((-1,0,0,0,-1,0,0,0,-1)), 0.25, True),))

    itr = obs.iterator(0)
    assert(itr.has_next())
    assert(itr.next().h==(1,6,-9))
    assert(not itr.has_next())
    itr = obs.iterator(1)
    assert(itr.next().h==(-1,-6,9))
    assert(itr.next().h==(-1,6,9))
    assert(itr.next().h==(1,-6,-9))
    assert(not itr.has_next())

    ts = 1-obs.ref_twin_components[0].value
    ps = 1-obs.ref_twin_fractions[0].value
    itr = obs.iterator(0)
    assert obs.scale(0) == ts*ps
    nv = next(itr)
    assert nv.scale == obs.ref_twin_components[0].value*ps
  except RuntimeError as e:
    pass


def run():
  excersise()
  print("OK")

if (__name__ == "__main__"):
  run()


 *******************************************************************************


 *******************************************************************************
cctbx/xray/scatterer.py
from __future__ import absolute_import, division, print_function
from cctbx.xray import ext
import cctbx.eltbx.xray_scattering
from cctbx import eltbx
from cctbx import adptbx
from cctbx.array_family import flex
from libtbx.str_utils import show_string
import boost_adaptbx.boost.python as bp
from six.moves import cStringIO as StringIO
import sys

class scatterer(ext.scatterer):

  def __init__(self, label="",
                     site=(0,0,0),
                     u=None,
                     occupancy=1,
                     scattering_type=None,
                     fp=0,
                     fdp=0,
                     b=None):
    assert u is None or b is None
    if   (b is not None): u = adptbx.b_as_u(b)
    elif (u is None): u = 0
    if (scattering_type is None):
      scattering_type = eltbx.xray_scattering.get_standard_label(
        label=label, exact=False)
    ext.scatterer.__init__(
      self, label, site, u, occupancy, scattering_type, fp, fdp)

@bp.inject_into(ext.scatterer)
class _():

  def customized_copy(self,
        label=None,
        site=None,
        u=None,
        b=None,
        occupancy=None,
        scattering_type=None,
        fp=None,
        fdp=None,
        flags=None,
        u_iso=None,
        u_star=None):
    assert u is None or b is None
    if (b is not None): u = adptbx.b_as_u(b)
    del b
    if (u is not None):
      assert u_iso is None and u_star is None
      if (flags is None):
        assert self.flags.use_u_iso() ^ self.flags.use_u_aniso()
      else:
        assert flags.use_u_iso() ^ flags.use_u_aniso()
    result = ext.scatterer(other=self)
    if (label is not None): result.label = label
    if (site is not None): result.site = site
    if (flags is not None): result.flags = flags
    if (u is not None):
      if (result.flags.use_u_iso()):
        result.u_iso = u
      else:
        result.u_star = u
    if (u_iso is not None): result.u_iso = u_iso
    if (u_star is not None): result.u_star = u_star
    if (occupancy is not None): result.occupancy = occupancy
    if (scattering_type is not None): result.scattering_type = scattering_type
    if (fp is not None): result.fp = fp
    if (fdp is not None): result.fdp = fdp
    return result

  def element_and_charge_symbols(self, exact=False):
    return eltbx.xray_scattering.get_element_and_charge_symbols(
      scattering_type=self.scattering_type, exact=exact)

  def element_symbol(self, exact=False):
    e, c = self.element_and_charge_symbols(exact=exact)
    if (len(e) == 0): return None
    return e

  def electron_count(self):
    """This method returns the number of electrons a scatterer effectively has.

    :returns: number of electrons (= Z - charge)
    :rtype: int
    """
    import cctbx.eltbx.tiny_pse
    symbol, charge = self.element_and_charge_symbols(exact=True)
    electrons = eltbx.tiny_pse.table(symbol).atomic_number()
    # check the most common charges first for slightly better performance
    if charge == "":
      pass
    elif charge == "1+":
      electrons -= 1
    elif charge == "2+":
      electrons -= 2
    elif charge == "2-":
      electrons += 2
    elif charge == "1-":
      electrons += 1
    elif charge == "3+":
      electrons -= 3
    elif charge == "4+":
      electrons -= 4
    elif charge == "5+":
      electrons -= 5
    elif charge == "6+":
      electrons -= 6
    elif charge == "7+":
      electrons -= 7
    elif charge == "8+":
      electrons -= 8
    elif charge == "9+":
      electrons -= 9
    elif charge == "3-":
      electrons += 3
    elif charge == "4-":
      electrons += 4
    elif charge == "5-":
      electrons += 5
    elif charge == "6-":
      electrons += 6
    elif charge == "7-":
      electrons += 7
    elif charge == "8-":
      electrons += 8
    elif charge == "9-":
      electrons += 9
    return electrons

  def as_py_code(self, indent="", comment=""):
    """ The returned string does usually eval to self, except if the both of
    self.flags.use_u_iso() and self.flags.use_u_aniso() are True.
    """
    r = []
    r.append('%s  label=%s' % (indent, show_string(self.label)))
    if (eltbx.xray_scattering.get_standard_label(label=self.label,
                                                 exact=False)
        != self.scattering_type):
      r.append("%s  scattering_type=%s"
        % (indent, show_string(self.scattering_type)))
    r.append("%s  site=(%.6f, %.6f, %.6f)"  % ((indent,)+self.site))
    if self.flags.use_u_iso():
      r.append("%s  u=%.6f" % (indent, self.u_iso))
    if self.flags.use_u_aniso():
      r.append("%s  u=(%.6f, %.6f, %.6f,\n"
               "%s     %.6f, %.6f, %.6f)" % (
        (indent,)+self.u_star[:3]+
        (indent,)+self.u_star[3:]))
    if self.occupancy != 1:
      r.append("%s  occupancy=%.6f" % (indent, self.occupancy))
    if self.fp != 0 or self.fdp != 0:
      r.append("%s  fp=%.6f" % (indent, self.fp))
      r.append("%s  fdp=%.6f" % (indent, self.fdp))
    return "xray.scatterer(%s\n%s)" % (comment, ",\n".join(r))

  def show(self, f=None, unit_cell=None):
    if (f is None): f = sys.stdout
    print("%-4s" % self.label, end=' ', file=f)
    print("%-4s" % self.scattering_type, end=' ', file=f)
    print("%3d" % self.multiplicity(), end=' ', file=f)
    print("(%7.4f %7.4f %7.4f)" % self.site, end=' ', file=f)
    print("%4.2f" % self.occupancy, end='', file=f)
    if self.flags.use_u_iso():
      print(" %6.4f" % self.u_iso, end='', file=f)
    else:
      print(' [ - ]', end='', file=f)
    if self.flags.use_u_aniso():
      assert unit_cell is not None
      u_cart = adptbx.u_star_as_u_cart(unit_cell, self.u_star)
      print(" %6.4f" % adptbx.u_cart_as_u_iso(u_cart), file=f)
      print("     u_cart =", ("%6.3f " * 5 + "%6.3f") % u_cart, end='', file=f)
    else:
      print(' [ - ]', end='', file=f)
    if (self.fp != 0 or self.fdp != 0):
      print("\n     fp,fdp = %6.4f,%6.4f" % (
        self.fp,
        self.fdp), end='', file=f)
    print(file=f)

class anomalous_scatterer_group:

  def __init__(self,
        iselection,
        f_prime,
        f_double_prime,
        refine,
        selection_string=None,
        update_from_selection=False):
    self.iselection = iselection
    self.f_prime = f_prime
    self.f_double_prime = f_double_prime
    self.refine_f_prime = False
    self.refine_f_double_prime = False
    self.update_from_selection = update_from_selection
    for refine_item in refine:
      assert refine_item in ["f_prime", "f_double_prime"]
      if (refine_item == "f_prime"):
        self.refine_f_prime = True
      else:
        self.refine_f_double_prime = True
    self.selection_string = selection_string

  def labels_refine(self):
    result = []
    if (self.refine_f_prime): result.append("f_prime")
    if (self.refine_f_double_prime): result.append("f_double_prime")
    return result

  def show_summary(self, out=None, prefix=""):
    if (out is None): out = sys.stdout
    print(prefix+"Anomalous scatterer group:", file=out)
    if (self.selection_string is not None):
      print(prefix+"  Selection:", show_string(self.selection_string), file=out)
    print(prefix+"  Number of selected scatterers:", \
      self.iselection.size(), file=out)
    print(prefix+"  f_prime:        %.6g" % self.f_prime, file=out)
    print(prefix+"  f_double_prime: %.6g" % self.f_double_prime, file=out)
    labels_refine = self.labels_refine()
    print(prefix+"  refine:", end=' ', file=out)
    if (len(labels_refine) == 0): print("None", file=out)
    else: print(" ".join(labels_refine), file=out)

  def copy_to_scatterers_in_place(self, scatterers):
    for i_seq in self.iselection:
      scatterers[i_seq].fp = self.f_prime
      scatterers[i_seq].fdp = self.f_double_prime

  def extract_from_scatterers_in_place(self, scatterers, tolerance=1.e-4):
    fps = flex.double()
    fdps = flex.double()
    fps.reserve(self.iselection.size())
    fdps.reserve(fps.size())
    for i_seq in self.iselection:
      fps.append(scatterers[i_seq].fp)
      fdps.append(scatterers[i_seq].fdp)
      for values,label in [(fps, "f_prime"), (fdps, "f_double_prime")]:
        stats = flex.min_max_mean_double(values)
        if (stats.max - stats.min <= tolerance):
          setattr(self, label, stats.mean)
        else:
          msg = ["Anomalous scatterer group with significantly different %s:"
            % label]
          if (self.selection_string is not None):
            msg.append("  Selection: %s" % show_string(self.selection_string))
          msg.append("  Number of selected scatterers: %d" % stats.n)
          s = StringIO()
          stats.show(out=s, prefix="  %s " % label, show_n=False)
          msg.extend(s.getvalue().splitlines())
          msg.append("  tolerance: %.6g" % tolerance)
          raise RuntimeError("\n".join(msg))

  def select(self, bselection):
    # otherwise we will need total number of atoms
    assert isinstance(bselection, flex.bool)
    new_iselection = flex.bool(bselection.size(), self.iselection)
    new_iselection = new_iselection.select(bselection).iselection()
    new_refine = []
    if self.refine_f_prime:
      new_refine.append("f_prime")
    if self.refine_f_double_prime:
      new_refine.append("f_double_prime")
    result = anomalous_scatterer_group(
        iselection=new_iselection,
        f_prime=self.f_prime,
        f_double_prime=self.f_double_prime,
        selection_string=self.selection_string,
        refine = new_refine,
        update_from_selection=self.update_from_selection)
    return result


 *******************************************************************************


 *******************************************************************************
cctbx/xray/structure.py
# -*- coding: utf-8 -*-
from __future__ import absolute_import, division, print_function
from cctbx.xray import ext
from cctbx.xray import structure_factors
from cctbx import miller
from cctbx import crystal
from cctbx import sgtbx
import cctbx.eltbx.xray_scattering
from cctbx import adptbx
from cctbx import eltbx
from cctbx.array_family import flex
import scitbx.math
from scitbx import matrix
import math
from itertools import count
import sys
import random
import six
from libtbx.utils import count_max, Sorry, Keep
from libtbx.test_utils import approx_equal
from libtbx import group_args
from cctbx.eltbx.neutron import neutron_news_1992_table
from cctbx import eltbx
from libtbx.utils import format_float_with_standard_uncertainty \
     as format_float_with_su
from cctbx import covariance
from six.moves import range
from six.moves import zip

class scattering_type_registry_params(object):
  def __init__(self,
               custom_dict = None,
               d_min       = None,
               table       = None,
               types_without_a_scattering_contribution = None):
    self.custom_dict = custom_dict
    self.d_min       = d_min
    self.table       = table
    self.types_without_a_scattering_contribution = \
                                        types_without_a_scattering_contribution

class structure(crystal.special_position_settings):
  """A class to describe and handle information related to a crystal structure.

  It offers various methods to modify the crystallographic information contained.

  Important members are:

  - .special_position_settings (base class)
  - .scatterers
  - .site_symmetry
  - .crystal_symmetry

  """
  def __init__(self,
        special_position_settings=None,
        scatterers=None,
        site_symmetry_table=None,
        non_unit_occupancy_implies_min_distance_sym_equiv_zero=False,
        scattering_type_registry=None,
        crystal_symmetry=None,
        wavelength=None):
    assert [special_position_settings, crystal_symmetry].count(None) == 1
    assert scatterers is not None or site_symmetry_table is None
    if (special_position_settings is None):
      special_position_settings = crystal.special_position_settings(
        crystal_symmetry=crystal_symmetry)
    crystal.special_position_settings._copy_constructor(
      self, special_position_settings)
    self.erase_scatterers()
    self._non_unit_occupancy_implies_min_distance_sym_equiv_zero \
      = non_unit_occupancy_implies_min_distance_sym_equiv_zero
    self._scattering_type_registry = scattering_type_registry
    if (scatterers is not None):
      self.add_scatterers(
        scatterers=scatterers,
        site_symmetry_table=site_symmetry_table,
        non_unit_occupancy_implies_min_distance_sym_equiv_zero=
          self._non_unit_occupancy_implies_min_distance_sym_equiv_zero)
    self.scattering_type_registry_params = None
    self.inelastic_form_factors_source = None
    self.wavelength = wavelength

  def _copy_constructor(self, other):
    crystal.special_position_settings._copy_constructor(
      self, special_position_settings)
    self._scatterers = other._scatterers
    self._site_symmetry_table = other._site_symmetry_table
    self._non_unit_occupancy_implies_min_distance_sym_equiv_zero \
      = other._non_unit_occupancy_implies_min_distance_sym_equiv_zero
    self._scattering_type_registry = other._scattering_type_registry
    self._scattering_type_registry_is_out_of_date \
      = other._scattering_type_registry_is_out_of_date
    self.inelastic_form_factors_source = other.inelastic_form_factors_source

  def crystal_symmetry(self):
    """Get crystal symmetry of the structure

    :returns: a new crystal symmetry object
    :rtype: cctbx.crystal.symmetry
    """
    return crystal.symmetry(
      unit_cell = self.unit_cell(),
      space_group_info = self.space_group_info())

  def set_non_unit_occupancy_implies_min_distance_sym_equiv_zero(self, value):
    self._non_unit_occupancy_implies_min_distance_sym_equiv_zero = value

  def erase_scatterers(self):
    """Remove all scatterers from structure

    :returns: none
    """
    self._scatterers = flex.xray_scatterer()
    self._site_symmetry_table = sgtbx.site_symmetry_table()
    self._scattering_type_registry_is_out_of_date = True
    self.inelastic_form_factors_source = None

  def deep_copy_scatterers(self):
    """Create a deep copy of the structure with all scatterers

    :returns: a new cctbx.xray.structure object
    :rtype: cctbx.xray.structure
    """
    cp = structure(self,
      scattering_type_registry=self._scattering_type_registry,
      non_unit_occupancy_implies_min_distance_sym_equiv_zero
        =self._non_unit_occupancy_implies_min_distance_sym_equiv_zero,
      wavelength=self.wavelength)
    cp._scatterers = self._scatterers.deep_copy()
    cp._site_symmetry_table = self._site_symmetry_table.deep_copy()
    return cp

  def customized_copy(self,
        crystal_symmetry=Keep,
        unit_cell=Keep,
        space_group_info=Keep,
        non_unit_occupancy_implies_min_distance_sym_equiv_zero=Keep,
        wavelength=Keep):
    if (crystal_symmetry is Keep):
      crystal_symmetry = self
    crystal_symmetry = crystal.symmetry.customized_copy(
      crystal_symmetry,
      unit_cell=unit_cell,
      space_group_info=space_group_info)
    if (non_unit_occupancy_implies_min_distance_sym_equiv_zero is Keep):
      non_unit_occupancy_implies_min_distance_sym_equiv_zero \
        = self._non_unit_occupancy_implies_min_distance_sym_equiv_zero
    if (wavelength is Keep):
      wavelength = self.wavelength
    str = structure(
      special_position_settings=crystal.special_position_settings(
        crystal_symmetry=crystal_symmetry,
        min_distance_sym_equiv=self._min_distance_sym_equiv,
        u_star_tolerance=self._u_star_tolerance,
        assert_min_distance_sym_equiv=self._assert_min_distance_sym_equiv),
      scatterers=self._scatterers,
      non_unit_occupancy_implies_min_distance_sym_equiv_zero
        =non_unit_occupancy_implies_min_distance_sym_equiv_zero,
      scattering_type_registry=self._scattering_type_registry,
      wavelength=wavelength)
    str.inelastic_form_factors_source = self.inelastic_form_factors_source
    return str

  def scatterers(self):
    """Get all scatterers of the structure

    :returns: a reference to an array of cctbx.xray.scatterer
    :rtype: cctbx.xray.scatterer[]
    """
    return self._scatterers

  def non_unit_occupancy_implies_min_distance_sym_equiv_zero(self):
    return self._non_unit_occupancy_implies_min_distance_sym_equiv_zero

  def set_u_iso(self, value = None, values = None, selection = None):
    """Set isotropic mean thermic displacements of scatterers

    :param value: a single double value to set all u_iso of selected \
    scatterers to
    :type value: double
    :param values: an array of double values to set all u_iso of selected \
    scatterers to
    :type values: double[]
    :param selection: an array of bools to select scatterers to be updated \
    with new u_iso values
    :type selection: boolean[]

    :returns: the modified base object
    :rtype: cctbx.xray.structure
    """
    assert [value, values].count(None) == 1
    s = self._scatterers
    if(selection is None): selection = flex.bool(s.size(), True)
    else:                  assert selection.size() == s.size()
    if(value is not None):
      s.set_u_iso(flex.double(s.size(), value), selection, self.unit_cell())
    else:
      assert values.size() == s.size()
      s.set_u_iso(values, selection, self.unit_cell())
    return self

  def set_b_iso(self, value = None, values = None, selection = None):
    """Set isotropic Debye-Waller/temperature/B factors with automatic conversion
    to u_iso

    :param value: a single double value to set all b_iso of selected \
    scatterers to
    :type value: double
    :param values: an array of double values to set all b_iso of selected \
    scatterers to
    :type values: double[]
    :param selection: an array of bools to select scatterers to be updated with \
    new b_iso values
    :type selection: boolean[]

    :returns: the modified base object
    :rtype: cctbx.xray.structure
    """
    assert [value, values].count(None) == 1
    s = self._scatterers
    if(value is not None):
      self.set_u_iso(value = adptbx.b_as_u(value), selection = selection)
    else:
      assert values.size() == s.size()
      b_iso = values
      u_iso_values = b_iso*adptbx.b_as_u(1)
      self.set_u_iso(values = u_iso_values, selection = selection)
    return self

  def random_remove_sites_selection(self, fraction):
    scatterers_size = self._scatterers.size()
    if(abs(fraction-0.0) < 1.e-3):
      return flex.bool(scatterers_size, True)
    if(fraction < 0.01 or fraction > 0.99):
      raise RuntimeError("fraction must be between 0.01 and 0.99.")
    tol = 999.
    selection = None
    l = max(fraction - 0.05, 0.0)
    r = min(fraction + 0.05, 1.0)
    for i in range(5):
      while l <= r:
        arr = flex.random_double(scatterers_size)-l
        sel = arr > 0.0
        deleted = float((scatterers_size - sel.count(True))) / scatterers_size
        if abs(fraction - deleted) < tol:
          tol = abs(fraction - deleted)
          selection = sel
        l += 0.0001
    return selection

  def replace_sites_frac(self, new_sites, selection=None):
    if(selection is not None):
      new_sites = self.sites_frac().set_selected(selection, new_sites)
    cp = structure(self,
      non_unit_occupancy_implies_min_distance_sym_equiv_zero
        =self._non_unit_occupancy_implies_min_distance_sym_equiv_zero,
      scattering_type_registry=self._scattering_type_registry,
      wavelength=self.wavelength)
    new_scatterers = self._scatterers.deep_copy()
    new_scatterers.set_sites(new_sites)
    cp._scatterers = new_scatterers
    cp._site_symmetry_table = self._site_symmetry_table.deep_copy()
    return cp

  def replace_sites_cart(self, new_sites, selection=None):
    return self.replace_sites_frac(
      new_sites=self.unit_cell().fractionalize(sites_cart=new_sites),
      selection=selection)

  def adjust_u_iso(self):
    self._scatterers.adjust_u_iso()

  def adjust_occupancy(self, occ_max, occ_min, selection = None):
    """Adjust site occupancy factor for selected sites to be between occ_min and
    occ_max.

    :param occ_max: maximal site occupancy factor
    :type occ_max: float
    :param occ_min: minimal site occupancy factor
    :type occ_min: float
    :param selection: an array of bools to select scatterers to be adjusted
    :type selection: boolean[]

    :returns: none
    """
    if(selection is not None):
      if(("%s"%selection.__class__).count("array_family_flex_ext.size_t") > 0):
        selection = flex.bool(self._scatterers.size(), selection)
    occ = self._scatterers.extract_occupancies()
    sel = (occ >= occ_max)
    occ = occ.set_selected(sel, occ_max)
    sel = (occ <= occ_min)
    occ = occ.set_selected(sel, occ_min)
    if(selection is None):
      self._scatterers.set_occupancies(occ)
    else:
      self._scatterers.set_occupancies(occ, selection)

  def all_selection(self):
    """Get a selector array for all scatterers of the structure.

    :returns: an array to select all scatterers of the structure
    :rtype: boolean[]
    """
    return flex.bool(self._scatterers.size(), True)

  def translate(self, x=0, y=0, z=0):
    """Translates all scatterers of this structure by x,y,z.

    :param x: x component of the translation vector
    :type x: float
    :param y: y component of the translation vector
    :type y: float
    :param z: z component of the translation vector
    :type z: float

    :returns: a new translated copy of the structure
    :rtype: cctbx.xray.structure
    """
    sites_cart = self.sites_cart()
    cp = structure(self,
      non_unit_occupancy_implies_min_distance_sym_equiv_zero
        =self._non_unit_occupancy_implies_min_distance_sym_equiv_zero,
      scattering_type_registry=self._scattering_type_registry,
      wavelength=self.wavelength)
    new_scatterers = self._scatterers.deep_copy()
    new_scatterers.set_sites(
      self.unit_cell().fractionalize(
        sites_cart=sites_cart+flex.vec3_double(sites_cart.size(),[x,y,z])))
    cp._scatterers = new_scatterers
    cp._site_symmetry_table = self._site_symmetry_table.deep_copy()
    return cp

  def distances(self, other, selection = None):
    """Calculates pairwise distances between the atoms of this structure and
    another structure with the same number of scatterers.

    :param other: the other structure
    :type other: cctbx.xray.structure
    :param selection: an array of bools to select scatterers to be taken into \
    calculation
    :type selection: boolean[]

    :returns: an array of distances for the selected scatterers
    :rtype: float[]
    """
    if(selection is None): selection = flex.bool(self._scatterers.size(), True)
    s1 = self.sites_cart().select(selection)
    s2 = other.sites_cart().select(selection)
    if(s1.size() != s2.size()):
      raise RuntimeError("Models must be of equal size.")
    return flex.sqrt((s1 - s2).dot())

  def max_distance(self, other, selection = None):
    """Calculates the maximum pairwise distance between the atoms of this
    structure and another structure with the same number of scatterers.

    :param other: the other structure
    :type other: cctbx.xray.structure
    :param selection: an array of bools to select scatterers to be taken into \
    calculation
    :type selection: boolean[]

    :returns: the maximum distance of two corresponding scatterers out of the \
    selected scatterers
    :rtype: float
    """
    return flex.max( self.distances(other = other, selection = selection) )

  def min_distance(self, other, selection = None):
    """Calculates the minimum pairwise distance between the atoms of this
    structure and another structure with the same number of scatterers.

    :param other: the other structure
    :type other: cctbx.xray.structure
    :param selection: an array of bools to select scatterers to be taken into \
    calculation
    :type selection: boolean[]

    :returns: the minimum distance of two corresponding scatterers out of the \
    selected scatterers
    :rtype: float
    """
    return flex.min( self.distances(other = other, selection = selection) )

  def mean_distance(self, other, selection = None):
    """Calculates the arithmetic mean pairwise distance between the atoms
    of this structure and another structure with the same number of scatterers.

    :param other: the other structure
    :type other: cctbx.xray.structure
    :param selection: an array of bools to select scatterers to be taken into \
    calculation
    :type selection: boolean[]

    :returns: the mean pairwise distance of the selected scatterers
    :rtype: float
    """
    return flex.mean( self.distances(other = other, selection = selection) )

  def scale_adp(self, factor, selection=None):
    """Scale the atomic displacement parameters of the selected scatterers
    of the structure with the specified factor.
    If no selection is given, all scatterers will be handled as if selected.

    :param factor: scale factor to apply to the adps of the selected scatterers
    :type factor: float
    :param selection: an array of bools to select the scatterers to have their \
    adps scaled
    :type selection: boolean[]

    :returns: none
    """
    if(selection is not None):
      assert selection.size() == self._scatterers.size()
    else:
      selection = flex.bool(self._scatterers.size(), True)
    for sc,sel in zip(self._scatterers, selection):
      if(sel and sc.flags.use()):
        if(sc.flags.use_u_iso()):
          sc.u_iso = sc.u_iso * factor
        if(sc.flags.use_u_aniso()):
          result = []
          for i in range(6): result.append(sc.u_star[i] * factor)
          sc.u_star = result

  def shake_adp(self, b_max=None, b_min=None, spread=10.0, aniso_spread=0.1,
             keep_anisotropic=False, random_u_cart_scale=1.0, selection=None):
    assert [b_max, b_min].count(None) in [0,2]
    if([b_max, b_min].count(None) == 0): assert spread == 0.0
    if([b_max, b_min].count(None) == 2):
      u_isos = self.extract_u_iso_or_u_equiv().select(self.use_u_iso())
      if(u_isos.size() > 0):
        b_mean = adptbx.u_as_b(flex.mean(u_isos))
        b_max = int(b_mean + spread)
        b_min = int(max(0.0, b_mean - spread))
    if b_min is not None and b_max is not None:
      assert b_min <= b_max, [b_min,b_max,spread,b_mean]
      b_min = int(b_min)
      b_max = int(b_max)
    if(selection is not None):
      assert selection.size() == self._scatterers.size()
    else:
      selection = flex.bool(self._scatterers.size(), True)
    is_special_position = self.site_symmetry_table().is_special_position
    for i_seq,sc,sel in zip(count(), self._scatterers, selection):
      if(sel and sc.flags.use()):
        if(sc.flags.use_u_iso() and b_min != b_max):
          r = max(0, random.randrange(b_min, b_max, 1) + random.random())
          sc.u_iso=adptbx.b_as_u(r)
        if(sc.flags.use_u_aniso() and not keep_anisotropic):
          result = []
          for i in range(6):
            result.append(sc.u_star[i]+sc.u_star[i]*random.choice(
                                             (-aniso_spread,aniso_spread)))
          if(is_special_position(i_seq=i_seq)):
            result = self.space_group().average_u_star(result)
          sc.u_star = result

  def shake_adp_if_all_equal(self, b_iso_tolerance = 0.1):
    performed = False
    if(self.use_u_aniso().count(True) == 0):
      u_isos = self.extract_u_iso_or_u_equiv()
      b_max  = adptbx.u_as_b(flex.max(u_isos))
      b_min  = adptbx.u_as_b(flex.min(u_isos))
      b_mean = adptbx.u_as_b(flex.mean(u_isos))
      if(abs(b_max - b_mean) <= b_iso_tolerance and
                                      abs(b_min - b_mean) <= b_iso_tolerance):
          self.shake_adp()
          performed = True
    return performed

  def min_u_cart_eigenvalue(self):
    u_carts = self._scatterers.extract_u_cart_plus_u_iso(
      unit_cell=self.unit_cell())
    result = flex.double()
    for i_seq, sc in enumerate(self._scatterers):
      if(sc.flags.use_u_iso() or sc.flags.use_u_aniso()):
        result.append(min(adptbx.eigenvalues(u_carts[i_seq])))
    return flex.min(result)

  def shake_occupancies(self, selection = None):
    s = self._scatterers
    q_new = flex.random_double(s.size())
    if(selection is None):
      s.set_occupancies(q_new)
    else:
      assert selection.size() == s.size()
      s.set_occupancies(q_new, selection)

  def shake_fps(self, selection = None):
    s = self._scatterers
    q_deltas = flex.double([random.gauss(0,1) for _ in range(s.size())])
    q_new = q_deltas + flex.double([sc.fp for sc in s])
    if(selection is None):
      s.set_fps(q_new)
    else:
      assert selection.size() == s.size()
      s.set_fps(q_new, selection)

  def shake_fdps(self, selection = None):
    s = self._scatterers
    q_deltas = flex.double([random.gauss(0,1) for _ in range(s.size())])
    q_new = q_deltas + flex.double([sc.fdp for sc in s])
    if(selection is None):
      s.set_fdps(q_new)
    else:
      assert selection.size() == s.size()
      s.set_fdps(q_new, selection)

  def set_occupancies(self, value, selection = None):
    if(selection is not None and isinstance(selection, flex.size_t)):
      selection = flex.bool(self._scatterers.size(), selection)
    s = self._scatterers
    if(hasattr(value, 'size')):
      values = value
      if(selection is not None):
        assert values.size() == selection.size()
    else:
      values = flex.double(s.size(), value)
    if(selection is None):
      s.set_occupancies(values)
    else:
      assert selection.size() == s.size()
      s.set_occupancies(values, selection)
    return self

  def set_fps(self, value, selection = None):
    if(selection is not None and isinstance(selection, flex.size_t)):
      selection = flex.bool(self._scatterers.size(), selection)
    s = self._scatterers
    if(hasattr(value, 'size')):
      values = value
      if(selection is not None):
        assert values.size() == selection.size()
    else:
      values = flex.double(s.size(), value)
    if(selection is None):
      s.set_fps(values)
    else:
      assert selection.size() == s.size()
      s.set_fps(values, selection)
    return self

  def set_fdps(self, value, selection = None):
    if(selection is not None and isinstance(selection, flex.size_t)):
      selection = flex.bool(self._scatterers.size(), selection)
    s = self._scatterers
    if(hasattr(value, 'size')):
      values = value
      if(selection is not None):
        assert values.size() == selection.size()
    else:
      values = flex.double(s.size(), value)
    if(selection is None):
      s.set_fdps(values)
    else:
      assert selection.size() == s.size()
      s.set_fdps(values, selection)
    return self

  def coordinate_degrees_of_freedom_counts(self, selection=None):
    assert selection is None or selection.size() == self._scatterers.size()
    site_symmetry_table = self._site_symmetry_table
    assert site_symmetry_table.indices().size() == self._scatterers.size()
    result = {
      0: 0,
      1: 0,
      2: 0,
      3: -site_symmetry_table.special_position_indices().size()}
    if (selection is None):
      result[3] += self._scatterers.size()
    else:
      result[3] += selection.count(True)
    for i in site_symmetry_table.special_position_indices():
      if (selection is None or selection[i]):
        result[site_symmetry_table
                 .get(i).site_constraints()
                   .n_independent_params()] += 1
    return result

  def get_scattering_table(self):
    if not self._scattering_type_registry:
      return None
    return self._scattering_type_registry.last_table()

  def guess_scattering_type_neutron(self):
    ac,bc,cc = 0,0,0
    result = False
    for ugl in self.scattering_type_registry().unique_gaussians_as_list():
      ac += len(ugl.array_of_a())
      bc += len(ugl.array_of_b())
      cc += ugl.c()
    if(ac+bc == 0 and cc != 0): result = True
    return result

  def guess_scattering_type_is_a_mixture_of_xray_and_neutron(self):
    has_xray = False
    has_neutron = False
    for ugl in self._scattering_type_registry.unique_gaussians_as_list():
      if ugl is None:
        continue
      if len(ugl.array_of_a())!=0 or len(ugl.array_of_b())!=0:
        has_xray = True
      elif ugl.c() != 0:
        has_neutron = True
    return has_neutron and has_xray

  def scattering_dictionary_as_string(self):
    result = ""
    if self._scattering_type_registry is None:
      return result
    for tg in self._scattering_type_registry.as_type_gaussian_dict().items():
      stype = tg[0]
      gaussian = tg[1]
      aa = "None"
      ab = "None"
      c = "None"
      if gaussian is not None:
        aa = gaussian.array_of_a()
        ab = gaussian.array_of_b()
        c = gaussian.c()
      result += "\n  Element: "+stype +"  a: "+ str(aa)+ "  b: "+ str(ab)+ "  c: "+str(c)
    return result

  def scattering_types_counts_and_occupancy_sums(self):
    result = []
    reg = self.scattering_type_registry()
    unique_counts = reg.unique_counts
    if (flex.sum(unique_counts) != self._scatterers.size()):
      raise RuntimeError("scattering_type_registry out of date.")
    occupancy_sums = reg.occupancy_sums(self._scatterers)
    unit_cell_occupancy_sums = reg.unit_cell_occupancy_sums(self._scatterers)
    for scattering_type,unique_index in reg.type_index_pairs_as_dict().items():
      result.append(group_args(
        scattering_type=scattering_type,
        count=unique_counts[unique_index],
        occupancy_sum=occupancy_sums[unique_index],
        unit_cell_occupancy_sum=unit_cell_occupancy_sums[unique_index]))
    return result

  def crystal_density(self):
    """Get the value of the diffraction-determined density for the crystal,
    suitable for the CIF item _exptl_crystal_density_diffrn

    Density values are calculated from the crystal cell and contents. The
    units are megagrams per cubic metre (=grams per cubic centimetre).

    Equivalent to:
      1.66042 * _chemical_formula_weight * _cell_formula_units_Z / _cell_volume

    :returns: chemical density in megagrams per cubic metre (=grams per cm^3)
    :rtype: float
    """
    from cctbx.eltbx import tiny_pse
    numerator = sum([
      tiny_pse.table(elt.scattering_type).weight() * elt.unit_cell_occupancy_sum
      for elt in self.scattering_types_counts_and_occupancy_sums()])
    denominator = self.unit_cell().volume()
    return 1.66042 * numerator/denominator

  def f_000(self, include_inelastic_part=False):
    """Get the effective number of electrons in the crystal unit cell
    contributing to F(000), suitable for the CIF item _exptl_crystal_F_000.

    According to the CIF definition, this item **may** contain dispersion
    contributions.

    :param include_inelastic_part: If 'True' contributions due to dispersion \
    are included in F(000).
    :type include_inelastic_part: boolean

    :returns: F(000)
    :rtype: float
    """
    elastic_part = 0
    reg = self.scattering_type_registry()
    unique_counts = reg.unique_counts
    if (flex.sum(unique_counts) != self._scatterers.size()):
      raise RuntimeError("scattering_type_registry out of date.")
    unit_cell_occupancy_sums = reg.unit_cell_occupancy_sums(self._scatterers)
    unique_form_factors_at_origin = reg.unique_form_factors_at_d_star_sq(0)
    for scattering_type,unique_index in reg.type_index_pairs_as_dict().items():
      elastic_part +=   unit_cell_occupancy_sums[unique_index] \
                      * unique_form_factors_at_origin[unique_index]
    if not include_inelastic_part:
      return elastic_part
    inelastic_part_real = 0
    inelastic_part_imag = 0
    for sc in self.scatterers():
      if sc.fp:
        inelastic_part_real += sc.fp * sc.occupancy * sc.multiplicity()
      if sc.fdp:
        inelastic_part_imag += sc.fdp * sc.occupancy * sc.multiplicity()
    return abs(complex(elastic_part+inelastic_part_real, inelastic_part_imag))

  def shake_sites_in_place(self,
        rms_difference=None,
        mean_distance=None,
        selection=None,
        allow_all_fixed=False,
        random_double=None):
    """Shake the coordinates of the selected scatterers in this structure.

    :param rms_difference: radial mean square displacement (>=0) to apply to \
    selected scatterers
    :type rms_difference: float
    :param mean_distance: a mean distance shift (>=0) to apply to selected \
    scatterers
    :type mean_distance: float
    :param selection: an array of bools to select scatterers to be shaken
    :type selection: boolean[]
    :param allow_all_fixed: if set to 'True' shaking a structure with all \
    scatterers on fixed special positions will not cause an error
    :type allow_all_fixed: boolean
    :param random_double: "random" numbers to use for displacements
    :type random_double: float[]

    :returns: 'True' if at least one scatterer was moved, 'False' otherwise
    :rtype: boolean
    """
    assert [rms_difference, mean_distance].count(None) == 1
    if (rms_difference is not None):
      assert rms_difference >= 0
      target_difference = rms_difference
    else:
      assert mean_distance >= 0
      target_difference = mean_distance
    if (target_difference == 0): return
    assert self._scatterers.size() > 0
    site_symmetry_table = self._site_symmetry_table
    assert site_symmetry_table.indices().size() == self._scatterers.size()
    if (selection is not None):
      assert selection.size() == self._scatterers.size()
      n_variable = selection.count(True)
      if (n_variable == 0):
        raise RuntimeError("No scatterers selected.")
      all = " selected"
    else:
      n_variable = self._scatterers.size()
      all = ""
    selection_fixed = flex.size_t()
    for i in site_symmetry_table.special_position_indices():
      if (site_symmetry_table.get(i)
            .site_constraints()
               .n_independent_params() == 0):
        if (selection is None or selection[i]):
          selection_fixed.append(i)
    n_variable -= selection_fixed.size()
    if (n_variable == 0):
      if (allow_all_fixed):
        return False
      raise RuntimeError(
        "All%s scatterers are fixed on special positions." % all)
    if (n_variable == self._scatterers.size()):
      selection = None
    scatterers = self._scatterers
    frac = self.unit_cell().fractionalize
    orth = self.unit_cell().orthogonalize
    if (random_double is None):
      random_double = flex.random_double
    for i in count_max(assert_less_than=10):
      shifts_cart = flex.vec3_double(random_double(
        size=self._scatterers.size()*3, factor=2) - 1)
      if (selection is not None):
        shifts_cart.set_selected(~selection, (0,0,0))
      shifts_cart.set_selected(selection_fixed, (0,0,0))
      for i in site_symmetry_table.special_position_indices():
        site_frac_orig = matrix.col(scatterers[i].site)
        site_frac = site_symmetry_table.get(i).special_op() \
                  * (site_frac_orig + matrix.col(frac(shifts_cart[i])))
        shifts_cart[i] = orth(matrix.col(site_frac) - site_frac_orig)
      if (rms_difference is not None):
        difference = (flex.sum(shifts_cart.dot()) / n_variable) ** 0.5
      else:
        difference = flex.sum(flex.sqrt(shifts_cart.dot())) / n_variable
      if (difference > 1.e-6): break # to avoid numerical problems
    shifts_cart *= (target_difference / difference)
    self.set_sites_frac(
      self.sites_frac() + self.unit_cell().fractionalize(shifts_cart))
    return True

  def shift_sites_in_place(self, shift_length, mersenne_twister=None):
    """Shifts the coordinates of all scatterers in this structure.

    :param shift_length: the distance to shift each scatterer with
    :type shift_length: float
    :param mersenne_twister: a mersenne twister to use as entropy source
    :type mersenne_twister: flex.mersenne_twister

    :returns: none
    """
    if (shift_length == 0): return
    sst = self._site_symmetry_table
    assert sst.indices().size() == self._scatterers.size()
    frac = self.unit_cell().fractionalize
    orth = self.unit_cell().orthogonalize
    if (mersenne_twister is None):
      mersenne_twister = flex.mersenne_twister(seed=0)
    col = matrix.col
    for i_sc,sc in enumerate(self._scatterers):
      site_frac = col(sc.site)
      ss = sst.get(i_sc)
      constr = ss.site_constraints()
      np = constr.n_independent_params()
      if (np == 0):
        continue
      if (np == 3):
        def find_3():
          sl = shift_length
          while (sl != 0):
            for i_trial in range(10):
              shift_frac = col(frac(
                col(mersenne_twister.random_double_point_on_sphere()) * sl))
              site_mod = site_frac + shift_frac
              ss_mod = self.site_symmetry(site=site_mod)
              if (ss_mod.is_point_group_1()):
                sc.site = site_mod
                return
            sl *= 0.5
        find_3()
      elif (np == 2):
        plane_vectors = []
        for s0 in [-1,0,1]:
          for s1 in [-1,0,1]:
            indep = list(constr.independent_params(site_frac))
            indep[0] += s0
            indep[1] += s1
            plane_vectors.append(col(orth(
              col(constr.all_params(indep)) - site_frac)))
        assert len(plane_vectors) == 9
        axis = None
        axis_length = None
        for i in range(8):
          vi = plane_vectors[i]
          for j in range(i+1,9):
            vj = plane_vectors[j]
            cross = vi.cross(vj)
            length = cross.length()
            if (axis is None or length > axis_length):
              axis = cross
              axis_length = length
        assert axis is not None
        assert axis_length != 0
        v_max = None
        l_max = None
        for v in plane_vectors:
          l = v.length()
          if (l_max is None or l > l_max):
            v_max = v
            l_max = l
        assert v_max is not None
        def find_2():
          sl = shift_length
          while (sl != 0):
            for i_trial in count_max(assert_less_than=10):
              r = axis.axis_and_angle_as_r3_rotation_matrix(
                angle = mersenne_twister.random_double() * 2 * math.pi)
              shift_frac = col(frac((r * v).normalize() * sl))
              site_mod = site_frac + shift_frac
              ss_mod = self.site_symmetry(site=site_mod)
              if (ss_mod.special_op() == ss.special_op()):
                sc.site = site_mod
                return
            sl *= 0.5
        find_2()
      else:
        def find_1():
          sl = shift_length
          while (sl != 0):
            if (mersenne_twister.random_double() < 0.5):
              us = [1, -1]
            else:
              us = [-1, 1]
            for u in us:
              indep = list(constr.independent_params(site_frac))
              indep[0] += u
              v = col(orth(col(constr.all_params(indep)) - site_frac))
              assert v.length() != 0
              shift_frac = col(frac(v.normalize() * shift_length))
              site_mod = site_frac + shift_frac
              ss_mod = self.site_symmetry(site=site_mod)
              if (ss_mod.special_op() == ss.special_op()):
                sc.site = site_mod
                return
            sl *= 0.5
        find_1()

  def b_iso_min_max_mean(self):
    """Get the minimal, maximal and mean isotropic Debye-Waller/temperature/B \
    factors of all scatterers in this structure.

    :returns: minimal b_iso, maximal b_iso, mean b_iso
    :rtype: float, float, float
    """
    b_isos = self._scatterers.extract_u_iso()/adptbx.b_as_u(1)
    b_min  = flex.min(b_isos)
    b_max  = flex.max(b_isos)
    b_mean = flex.mean(b_isos)
    return b_min, b_max, b_mean

  def discard_scattering_type_registry(self):
    self._scattering_type_registry_is_out_of_date = True

  def n_undefined_multiplicities(self):
    return ext.n_undefined_multiplicities(self._scatterers)

  def sites_frac(self):
    return self._scatterers.extract_sites()

  def use_u_iso(self):
    return self._scatterers.extract_use_u_iso()

  def use_u_aniso(self):
    return self._scatterers.extract_use_u_aniso()

  def set_sites_frac(self, sites_frac):
    """Set the the fractional coordinates of all sites of the structure to \
    'sites_frac'.

    :param sites_frac: a list of the fractional coordinates for all scatterers
    :type sites_frac: scitbx.array_family.flex.vec3_double

    :returns: none
    """
    assert sites_frac.size() == self._scatterers.size()
    self._scatterers.set_sites(sites_frac)

  def sites_cart(self):
    """Get the the cartesian coordinates of all sites of the structure.

    :returns: a list of the sites of the structure in cartesian coordinates
    :rtype: scitbx.array_family.flex.vec3_double
    """
    return self.unit_cell().orthogonalize(sites_frac=self.sites_frac())

  def set_sites_cart(self, sites_cart):
    """Set the the cartesian coordinates of all sites of the structure to \
    'sites_cart'.

    :param sites_cart: a list of the cartesian coordinates for all scatterers
    :type sites_cart: scitbx.array_family.flex.vec3_double

    :returns: none
    """
    self.set_sites_frac(self.unit_cell().fractionalize(sites_cart=sites_cart))

  def scattering_types(self):
    result = flex.std_string()
    for sct in self._scatterers.extract_scattering_types():
      result.append(sct.strip().upper())
    return result

  def extract_u_cart_plus_u_iso(self):
    return self._scatterers.extract_u_cart_plus_u_iso(
      unit_cell=self.unit_cell())

  def extract_u_iso_or_u_equiv(self):
    return self._scatterers.extract_u_iso_or_u_equiv(
      unit_cell=self.unit_cell())

  def b_iso_or_b_equiv(self):
    return self.extract_u_iso_or_u_equiv()*adptbx.u_as_b(1.)

  def scale_adps(self, scale_factor):
    return self._scatterers.scale_adps(scale_factor)

  def switch_to_neutron_scattering_dictionary(self):
    # XXX First step. In future: better to do bookkeeping and be able to swith
    # XXX back and forth between original scat_dict and neutron.
    # XXX Add regression test.
    return self.scattering_type_registry(table="neutron").as_type_gaussian_dict()

  def hd_selection(self):
    """Get a selector array for all hydrogen and deuterium scatterers of the structure.

    :returns: an array to select all H and D scatterers of the structure
    :rtype: boolean[]
    """
    scattering_types = self._scatterers.extract_scattering_types()
    result = flex.bool()
    for sct in scattering_types:
      if(sct.strip() in ['H','D']): result.append(True)
      else: result.append(False)
    return result

  def element_selection(self, *elements):
    """Get a selector array for scatterers of specified element type(s) of the structure.

    :param elements: tuple of element symbols to select
    :type elements: list(string) or set(string) or tuple(string)

    :returns: an array to select the desired scatterers of the structure
    :rtype: boolean[]
    """
    return flex.bool([ sc.element_symbol().strip() in elements
                       for sc in self.scatterers() ])

  def by_index_selection(self, selected_scatterers):
    """Get a selector array for scatterers with specified index from the
    structure. For example you can select scatterers 1,4 and 5 by passing
    (1,4,5) as argument.

    :param selected_scatterers: list of scatterers to select
    :type selected_scatterers: list(int)

    :returns: an array to select the desired scatterers of the structure
    :rtype: flex.bool[]
    """
    result = flex.bool(self._scatterers.size(), False)
    try:
      result.set_selected(flex.size_t(selected_scatterers), True)
    except(RuntimeError):
      raise IndexError("Tried to select a scatterer by index with index => "+\
            "of scatterers for this structuture.")
    return result

  def apply_rigid_body_shift(self, rot, trans, selection = None,
        recompute_site_symmetries=True):
    if(selection is None):
      selection = flex.bool(self._scatterers.size(), True).iselection()
    rbs_obj = self.apply_rigid_body_shift_obj(
                                        sites_cart     = self.sites_cart(),
                                        sites_frac     = self.sites_frac(),
                                        rot            = rot,
                                        trans          = trans,
                                        selection      = selection,
                                        unit_cell      = self.unit_cell(),
                                        atomic_weights = self.atomic_weights())
    self.set_sites_frac(sites_frac = rbs_obj.sites_frac)
    if(recompute_site_symmetries):
      scatterers = self.scatterers()
      self.erase_scatterers()
      self.add_scatterers(scatterers = scatterers)

  def apply_rigid_body_shift_obj(self,
                                 sites_cart,
                                 sites_frac,
                                 rot,
                                 trans,
                                 selection,
                                 unit_cell,
                                 atomic_weights):
    return ext.apply_rigid_body_shift(sites_cart     = sites_cart,
                                      sites_frac     = sites_frac,
                                      rot            = rot,
                                      trans          = trans,
                                      atomic_weights = atomic_weights,
                                      unit_cell      = unit_cell,
                                      selection      = selection)

  def convert_to_isotropic(self, selection=None):
    # FIXME selection must be size_t!
    if(selection is None):
      self._scatterers.convert_to_isotropic(unit_cell=self.unit_cell())
    else:
      self._scatterers.convert_to_isotropic(unit_cell=self.unit_cell(),
                                            selection=selection)

  def convert_to_anisotropic(self, selection=None):
    if(selection is None):
      self._scatterers.convert_to_anisotropic(unit_cell=self.unit_cell())
    else:
      self._scatterers.convert_to_anisotropic(unit_cell=self.unit_cell(),
                                              selection=selection)

  def show_u_statistics(self, text="", out=None, use_hydrogens=False):
    if(out is None): out = sys.stdout
    size = self._scatterers.size()
    if(use_hydrogens):
      hd_selection = flex.bool(size, True)
    else:
      hd_selection = self.hd_selection()
    epis = 8*math.pi**2
    use_u_aniso = self.use_u_aniso().select(~hd_selection)
    use_u_iso   = self.use_u_iso().select(~hd_selection)
    sel_used = use_u_aniso | use_u_iso
    n_anisotropic = use_u_aniso.count(True)
    n_isotropic   = use_u_iso.count(True)
    ipd = self.is_positive_definite_u().select(~hd_selection)
    npd = ipd.count(True)
    nnpd = ipd.count(False)
    beq = (self.extract_u_iso_or_u_equiv() * epis).select(~hd_selection).select(sel_used)
    bisos = (self.scatterers().extract_u_iso() * epis).select(~hd_selection).select(use_u_iso)
    if(bisos.size() == 0): bisos = beq
    part1 = "|-"+text
    part2 = "-|"
    n = 79 - len(part1+part2)
    print(part1 + "-"*n + part2, file=out)
    n = 79 - len(part1 + "|")
    print("| iso = %-5d   aniso = %-5d   pos. def. = %-5d   "\
          "non-pos. def. = %-5d     |"%(n_isotropic,n_anisotropic,npd,nnpd), file=out)
    print("| Total B(isotropic equivalent): min = %-6.2f   "\
                  "max = %-6.2f   mean = %-6.2f"%(flex.min(beq),flex.max(beq),
                  flex.mean(beq))+" "*2+"|", file=out)
    print("| Isotropic B only:              min = %-6.2f   "\
                  "max = %-6.2f   mean = %-6.2f"%(flex.min(bisos),
                  flex.max(bisos),flex.mean(bisos))+" "*2+"|", file=out)
    print("| "+"- "*38+"|", file=out)
    print("|                     Distribution of isotropic B-factors:"\
                  "                    |", file=out)
    print("|            Isotropic                |             Total "\
                  "                    |", file=out)
    histogram_1 = flex.histogram(data = bisos, n_slots = 10)
    low_cutoff_1 = histogram_1.data_min()
    histogram_2 = flex.histogram(data = beq, n_slots = 10)
    low_cutoff_2 = histogram_2.data_min()
    for (i_1,n_1),(i_2,n_2) in zip(enumerate(histogram_1.slots()),
                                   enumerate(histogram_2.slots())):
      high_cutoff_1 = histogram_1.data_min() + histogram_1.slot_width()*(i_1+1)
      high_cutoff_2 = histogram_2.data_min() + histogram_2.slot_width()*(i_2+1)
      print("|  %9.3f -%9.3f:%8d      |    %9.3f -%9.3f:%8d      |" % \
             (low_cutoff_1,high_cutoff_1,n_1,low_cutoff_2,high_cutoff_2,n_2), file=out)
      low_cutoff_1 = high_cutoff_1
      low_cutoff_2 = high_cutoff_2
    print("|" +"-"*77+"|", file=out)

  def site_symmetry_table(self):
    return self._site_symmetry_table

  def special_position_indices(self):
    return self._site_symmetry_table.special_position_indices()

  def scattering_type_registry(self,
        custom_dict=None,
        d_min=None,
        table=None,
        types_without_a_scattering_contribution=None,
        explicitly_allow_mixing=False):
    assert table in [None, "n_gaussian", "it1992", "wk1995", "xray", "electron",
        "neutron"]
    if (table == "it1992"): assert d_min in [0,None] or d_min >= 1/4.
    if (table == "wk1995"): assert d_min in [0,None] or d_min >= 1/12.
    if (table == "electron"): assert d_min in [0,None] or d_min >= 1/4.
    if (   self._scattering_type_registry_is_out_of_date
        or custom_dict is not None
        or d_min is not None
        or table is not None
        or types_without_a_scattering_contribution is not None):
      self.scattering_type_registry_params = \
          scattering_type_registry_params(
             custom_dict = custom_dict,
             d_min       = d_min,
             table       = table,
             types_without_a_scattering_contribution = \
               types_without_a_scattering_contribution)
      new_dict = {"const": eltbx.xray_scattering.gaussian(1)}
      old_dict = {}
      last_used_scattering_table = None
      if (self._scattering_type_registry is not None):
        last_used_scattering_table = self._scattering_type_registry.last_table()
        ugs = self._scattering_type_registry.unique_gaussians_as_list()
        tip = self._scattering_type_registry.type_index_pairs_as_dict()
        for t,i in tip.items():
          if (ugs[i] is not None): old_dict[t] = ugs[i]
        if (d_min is None and table is None):
          new_dict.update(old_dict)
      if (types_without_a_scattering_contribution is not None):
        for t in types_without_a_scattering_contribution:
          new_dict[t] = eltbx.xray_scattering.gaussian(0)
      if (custom_dict is not None):
        new_dict.update(custom_dict)
      if (d_min is None): d_min = 0
      self._scattering_type_registry = ext.scattering_type_registry()
      self._scattering_type_registry.process(self._scatterers)
      for t_undef in self._scattering_type_registry.unassigned_types():
        val = new_dict.get(t_undef, None)
        if (val is None):
          std_lbl = eltbx.xray_scattering.get_standard_label(
            label=t_undef, exact=True, optional=True)
          if (std_lbl is not None):
            if table is None:
              table = last_used_scattering_table
            else:
              last_used_scattering_table = table
            if (table == "it1992"):
              val = eltbx.xray_scattering.it1992(std_lbl, True).fetch()
            elif (table == "wk1995"):
              val = eltbx.xray_scattering.wk1995(std_lbl, True).fetch()
            elif (table == "electron"):
              from cctbx.eltbx.e_scattering import \
                ito_vol_c_2011_table_4_3_2_2_entry_as_gaussian as _
              val = _(label=std_lbl, exact=True)
            elif (table == "neutron"):
              scattering_info = neutron_news_1992_table(std_lbl, True)
              b = scattering_info.bound_coh_scatt_length()
              # TODO:
              # b.imag is ignored here. It depends on wavelength, so values
              # from neutron_news_1992 table are not very useful.
              # Warning is printed by scattering_registry::show.
              val = eltbx.xray_scattering.gaussian(b.real)
            else:
              # TODO mrt: this may lead to a mix of xray/neutron dictionary
              val = eltbx.xray_scattering.n_gaussian_table_entry(
                std_lbl, d_min, 0).gaussian()
              last_used_scattering_table = "n_gaussian"
        if (val is not None):
          self._scattering_type_registry.assign(t_undef, val)
          if last_used_scattering_table is not None:
            self._scattering_type_registry.set_last_table(last_used_scattering_table)
      self._scattering_type_registry_is_out_of_date = False
    if not explicitly_allow_mixing:
      if self.guess_scattering_type_is_a_mixture_of_xray_and_neutron():
        errmsg = "Mixed xray and neutron scattering table! "
        errmsg += self.scattering_dictionary_as_string()
        raise RuntimeError(errmsg)
    return self._scattering_type_registry

  def set_inelastic_form_factors(self, photon, table, set_use_fp_fdp=True):
    if table == "sasaki":
      set_inelastic_ff = ext.set_inelastic_form_factors_from_sasaki
    elif table == "henke":
      set_inelastic_ff = ext.set_inelastic_form_factors_from_henke
    else:
      raise RuntimeError("Unknown inelastic form factors table: %s" % table)
    self.inelastic_form_factors_source = table
    set_inelastic_ff(self.scatterers(), photon, set_use_fp_fdp)

  def set_custom_inelastic_form_factors(self, table, set_use_fp_fdp=True,
                                        source="custom"):
    """ Expects a dictionary of tuples like 'C' : (fp, fdp). If an element is
    not in the dictionary, the fp and fdp are reset to 0 and the use_fp_fdp is
    set to false.
    """
    for sc in self.scatterers():
      fp_fdp = table.get(sc.scattering_type, None)
      if fp_fdp is None:
        sc.fp = 0
        sc.fdp = 0
        sc.use_fp_fdp = False
      else:
        sc.fp = fp_fdp[0]
        sc.fdp = fp_fdp[1]
        if set_use_fp_fdp:
          sc.flags.set_use_fp_fdp(True)
    self.inelastic_form_factors_source = source

  def mean_scattering_density(self):
    r = self.scattering_type_registry()
    return r.sum_of_scattering_factors_at_diffraction_angle_0() \
         / self.unit_cell().volume()

  def __getitem__(self, slice_object):
    assert type(slice_object) == slice
    assert self.scatterers() is not None
    sel = flex.slice_indices(
      array_size=self._scatterers.size(),
      python_slice=slice_object)
    return structure(
      special_position_settings=self,
      scatterers=self._scatterers.select(sel),
      site_symmetry_table=self._site_symmetry_table.select(sel),
      scattering_type_registry=self._scattering_type_registry,
      wavelength=self.wavelength)

  def select(self, selection, negate=False):
    assert self.scatterers() is not None
    if (negate): selection = ~selection
    return structure(
      special_position_settings=self,
      scatterers=self._scatterers.select(selection),
      site_symmetry_table=self._site_symmetry_table.select(selection),
      scattering_type_registry=self._scattering_type_registry,
      wavelength=self.wavelength)

  def select_inplace(self, selection):
    assert self.scatterers() is not None
    self._scatterers          = self._scatterers.select(selection)
    self._site_symmetry_table = self._site_symmetry_table.select(selection)
    self._scattering_type_registry_is_out_of_date = True

  def add_scatterer(self,
        scatterer,
        site_symmetry_ops=None,
        insert_at_index=None):
    if (insert_at_index is None):
      insert_at_index = self._scatterers.size()
    self._scatterers.insert(insert_at_index, scatterer)
    if (site_symmetry_ops is None):
      site_symmetry_ops = self._scatterers[insert_at_index].apply_symmetry(
        unit_cell=self.unit_cell(),
        space_group=self.space_group(),
        min_distance_sym_equiv=self.min_distance_sym_equiv(),
        u_star_tolerance=self.u_star_tolerance(),
        assert_min_distance_sym_equiv=self.assert_min_distance_sym_equiv())
    else:
      self._scatterers[insert_at_index].apply_symmetry(
        site_symmetry_ops=site_symmetry_ops,
        u_star_tolerance=self.u_star_tolerance())
    self._site_symmetry_table.process(
      insert_at_index=insert_at_index, site_symmetry_ops=site_symmetry_ops)
    self._scattering_type_registry_is_out_of_date = True

  def add_scatterers(self,
        scatterers,
        site_symmetry_table=None,
        non_unit_occupancy_implies_min_distance_sym_equiv_zero=False):
    if (site_symmetry_table is None):
      site_symmetry_table = sgtbx.site_symmetry_table()
    else:
      assert site_symmetry_table.indices().size() == scatterers.size()
      assert not non_unit_occupancy_implies_min_distance_sym_equiv_zero
    self._scatterers.extend(scatterers)
    ext.add_scatterers_ext(
      unit_cell=self.unit_cell(),
      space_group=self.space_group(),
      scatterers=self._scatterers,
      site_symmetry_table=self._site_symmetry_table,
      site_symmetry_table_for_new=site_symmetry_table,
      min_distance_sym_equiv=self.min_distance_sym_equiv(),
      u_star_tolerance=self.u_star_tolerance(),
      assert_min_distance_sym_equiv=self.assert_min_distance_sym_equiv(),
      non_unit_occupancy_implies_min_distance_sym_equiv_zero=
        non_unit_occupancy_implies_min_distance_sym_equiv_zero)
    self._scattering_type_registry_is_out_of_date = True

  def concatenate(self, other):
    result = self.deep_copy_scatterers()
    result.add_scatterers(
      scatterers=other._scatterers,
      site_symmetry_table=other._site_symmetry_table)
    return result

  def concatenate_inplace(self, other):
    d1 = self.scattering_type_registry().as_type_gaussian_dict()
    d2 = other.scattering_type_registry().as_type_gaussian_dict()
    for key1, item1 in six.moves.zip(d1.keys(), six.iteritems(d1)):
      for key2, item2 in six.moves.zip(d2.keys(), six.iteritems(d2)):
        if(key1 == key2):
          i1 = item1[1]
          i2 = item2[1]
          problem_flag = False
          for a1, a2 in zip(i1.array_of_a(), i2.array_of_a()):
            if(not approx_equal(a1, a2)): problem_flag = True
          for b1, b2 in zip(i1.array_of_b(), i2.array_of_b()):
            if(not approx_equal(b1, b2)): problem_flag = True
          if(not approx_equal(i1.c(), i2.c())): problem_flag = True
          if(problem_flag):
            raise RuntimeError("Cannot concatenate: conflicting scatterers")
    self.add_scatterers(scatterers          = other._scatterers,
                        site_symmetry_table = other._site_symmetry_table)
    strp1 = self.scattering_type_registry_params
    strp2 = other.scattering_type_registry_params
    self.scattering_type_registry(
      custom_dict = strp1.custom_dict,
      d_min       = strp1.d_min,
      table       = strp1.table,
      types_without_a_scattering_contribution =
                                strp1.types_without_a_scattering_contribution)
    self.scattering_type_registry(
      custom_dict = strp2.custom_dict,
      d_min       = strp2.d_min,
      table       = strp2.table,
      types_without_a_scattering_contribution =
                                strp2.types_without_a_scattering_contribution)

  def selection_within(self, radius, selection):
    assert radius > 0
    assert self.special_position_settings() is not None
    return crystal.neighbors_fast_pair_generator(
      asu_mappings=self.special_position_settings().asu_mappings(
        buffer_thickness=radius,
        sites_cart=self.sites_cart()),
      distance_cutoff=radius).neighbors_of(
        primary_selection=selection)

  def replace_scatterers(self, scatterers, site_symmetry_table="existing"):
    if (site_symmetry_table == "existing"):
      site_symmetry_table = self._site_symmetry_table
    if (site_symmetry_table is not None):
      assert site_symmetry_table.indices().size() == self.scatterers().size()
    self.erase_scatterers()
    self.add_scatterers(
      scatterers=scatterers,
      site_symmetry_table=site_symmetry_table)

  def structure_factors(self, anomalous_flag=None, d_min=None,
                              algorithm=None,
                              cos_sin_table=False,
                              quality_factor=None,
                              u_base=None,
                              b_base=None,
                              wing_cutoff=None):
    """
    Calculate structure factors for the current scatterers using either direct
    summation or FFT method; by default the appropriate method will be guessed
    automatically.

    :param anomalous_flag: toggles whether the returned structure factors are
      anomalous or not
    :type anomalous_flag: bool
    :param d_min: resolution cutoff (required)
    :type d_min: float
    :param algorithm: specifies 'direct' or 'fft', or if None (default), the
      algorithm will be chosen automatically
    :type algorithm: str or None
    :param cos_sin_table: if True, uses interpolation of values from a
      pre-calculated lookup table for trigonometric function calls in the
      structure factor calculations in preference to calling the system
      libraries
    :type cos_sin_table: bool
    :param quality_factor: determines accuracy of sampled density in fft method
    :type quality_factor: float
    :param u_base: additional smearing B-factor for scatterers which have too
      small Bs so they fall between the grid nodes
    :type u_base: float
    :param b_base: same as u_base (but 8*pi^2 larger)
    :type b_base: float
    :param wing_cutoff: is how far away from atomic center you sample density
      around atom
    :type wing_cutoff: float

    :returns: a custom Python object (exact type depends on method used), from
      which f_calc() may be called
    :rtype: derived from cctbx.xray.structure_factors.manager.managed_calculation_base
    """
    if (anomalous_flag is None):
      if (self.scatterers().count_anomalous() != 0):
        anomalous_flag = True
      else:
        anomalous_flag = False
    elif (not anomalous_flag):
      if (self.scatterers().count_anomalous() != 0):
        raise RuntimeError(
            "xray.structure with anomalous scatterers"
          + " but miller.array is non-anomalous.")
    miller_set = miller.build_set(self, anomalous_flag, d_min)
    return structure_factors.from_scatterers(
      crystal_symmetry=self,
      d_min=d_min,
      cos_sin_table=cos_sin_table,
      quality_factor=quality_factor,
      u_base=u_base,
      b_base=b_base,
      wing_cutoff=wing_cutoff)(
        xray_structure=self,
        miller_set=miller_set,
        algorithm=algorithm)

  def as_py_code(self, indent=""):
    """eval(self.as_py_code()) is similar (but sometimes not identical)
    to self and meant to enable quick formatting of self as Python code
    for unit tests.
    """
    r0 = (
      "%sxray.structure(\n"
      "%s  crystal_symmetry=%s,\n"
      "%s  scatterers=flex.xray_scatterer([\n"
        % (indent,
           indent, self.crystal_symmetry().as_py_code(indent=indent+"  "),
           indent))
    r1 = []
    for i,sc in enumerate(self.scatterers()):
      r1.append(
          indent+"    "
        + sc.as_py_code(indent=indent+"    ", comment=" #%d" % i))
    return r0 + ",\n".join(r1) + "]))"

  def show_summary(self, f=None, prefix=""):
    if (f is None): f = sys.stdout
    print(prefix + "Number of scatterers:", \
      self.scatterers().size(), file=f)
    print(prefix + "At special positions:", \
      self.special_position_indices().size(), file=f)
    crystal.symmetry.show_summary(self, f=f, prefix=prefix)
    return self

  def show_scatterers(self, f=None, special_positions_only=False):
    if (f is None): f = sys.stdout
    print(("Label, Scattering, Multiplicity, Coordinates, Occupancy, "
                 "Uiso, Ustar as Uiso"), file=f)
    scatterers = self.scatterers()
    if (special_positions_only):
      scatterers = scatterers.select(self.special_position_indices())
    for sc in scatterers:
      sc.show(f=f, unit_cell=self.unit_cell())
    return self

  def show_special_position_shifts(self,
        sites_frac_original=None,
        sites_cart_original=None,
        out=None,
        prefix=""):
    self._site_symmetry_table.show_special_position_shifts(
      special_position_settings=self,
      site_labels=self.scatterers().extract_labels(),
      sites_frac_original=sites_frac_original,
      sites_cart_original=sites_cart_original,
      sites_frac_exact=self.scatterers().extract_sites(),
      out=out,
      prefix=prefix)

  def is_similar(self, other, eps = 1.e-6):
    """
    Check if similar. Can be endlessly fortified as needed.
    """
    if(self.scatterers().size() != other.scatterers().size()): return False
    f1 = self.crystal_symmetry().is_similar_symmetry(other.crystal_symmetry())
    f2 = approx_equal(self.sites_frac(), other.sites_frac(), eps)
    f3 = approx_equal(self.extract_u_iso_or_u_equiv(),
                      other.extract_u_iso_or_u_equiv(), eps)
    f4 = approx_equal(self.scatterers().extract_occupancies(),
                      other.scatterers().extract_occupancies(), eps)
    f5 = approx_equal(self.scatterers().extract_scattering_types(),
                      other.scatterers().extract_scattering_types())
    sr1 = self.scattering_type_registry().unique_gaussians_as_list()
    sr2 = other.scattering_type_registry().unique_gaussians_as_list()
    f6 = True
    for s1, s2 in zip(sr1, sr2):
      f6 &= approx_equal(s1.parameters(), s2.parameters(), eps)
    f = list(set([f1,f2,f3,f4,f5,f6]))
    return len(f)==1 and f[0]

  def is_positive_definite_u(self, u_cart_tolerance=None):
    if (u_cart_tolerance is None):
      return ext.is_positive_definite_u(
        scatterers=self._scatterers,
        unit_cell=self.unit_cell())
    else:
      return ext.is_positive_definite_u(
        scatterers=self._scatterers,
        unit_cell=self.unit_cell(),
        u_cart_tolerance=u_cart_tolerance)

  def tidy_us(self, u_min = 1.e-6, u_max = adptbx.b_as_u(999.99),
                    anisotropy_min=0.25):
    """
    Clean up atomic displacements so they fall within a sensible range (this
    is especially important when writing out PDB format).
    """
    assert u_min < u_max
    ext.tidy_us(
      scatterers=self._scatterers,
      unit_cell=self.unit_cell(),
      site_symmetry_table=self._site_symmetry_table,
      u_min=u_min,
      u_max=u_max,
      anisotropy_min=anisotropy_min)

  def shift_us(self, u_shift=None, b_shift=None, selection=None):
    assert [u_shift, b_shift].count(None) == 1
    if (u_shift is None):
      u_shift = adptbx.b_as_u(b_shift)
    if(selection is None):
      ext.shift_us(
        scatterers=self._scatterers,
        unit_cell=self.unit_cell(),
        u_shift=u_shift)
    else:
      ext.shift_us(scatterers = self._scatterers,
                   unit_cell  = self.unit_cell(),
                   u_shift    = u_shift,
                   selection  = selection)

  def shift_occupancies(self, q_shift, selection=None):
    if(selection is not None):
      ext.shift_occupancies(scatterers = self._scatterers,
                            q_shift    = q_shift,
                            selection  = selection)
    else:
      ext.shift_occupancies(scatterers = self._scatterers,
                            q_shift    = q_shift)

  def apply_symmetry_sites(self):
    ext.apply_symmetry_sites(
      site_symmetry_table=self._site_symmetry_table,
      scatterers=self._scatterers)

  def apply_symmetry_u_stars(self):
    ext.apply_symmetry_u_stars(
      site_symmetry_table=self._site_symmetry_table,
      scatterers=self._scatterers,
      u_star_tolerance=self.u_star_tolerance())

  def re_apply_symmetry(self, i_scatterer):
    self._scatterers[i_scatterer].apply_symmetry(
      site_symmetry_ops=self._site_symmetry_table.get(i_scatterer),
      u_star_tolerance=self.u_star_tolerance())

  def apply_special_position_ops_d_target_d_site(self, d_target_d_site):
    for i in self.special_position_indices():
      special_op = self._site_symmetry_table.get(i).special_op()
      r = matrix.sqr(special_op.r().as_double())
      d_target_d_site[i] = (matrix.row(d_target_d_site[i]) * r).elems

  def asymmetric_unit_in_p1(self):
    new_structure = structure(
      crystal.special_position_settings(
        crystal.symmetry.cell_equivalent_p1(self)),
      scattering_type_registry=self._scattering_type_registry,
      wavelength=self.wavelength)
    new_structure._scatterers = self.scatterers().deep_copy()
    new_structure._site_symmetry_table = self.site_symmetry_table().deep_copy()
    return new_structure

  def change_basis(self, cb_op):
    if (isinstance(cb_op, str)):
      cb_op = sgtbx.change_of_basis_op(cb_op)
    return structure(
      special_position_settings
        =crystal.special_position_settings.change_basis(self, cb_op),
      scatterers=ext.change_basis(scatterers=self._scatterers, cb_op=cb_op),
      site_symmetry_table=self._site_symmetry_table.change_basis(cb_op=cb_op),
      scattering_type_registry=self._scattering_type_registry,
      wavelength=self.wavelength)

  def change_hand(self):
    ch_op = self.space_group_info().type().change_of_hand_op()
    return self.change_basis(ch_op)

  def expand_to_p1(self,
      append_number_to_labels=False,
      sites_mod_positive=False):
    """Get the current structure expanded into spacegroup P1.
    This turns all symmetry induced scatterers into independent
    individual scatterers. The expanded structure may have sites
    with negative or > 1.0 coordinates. Use '.sites_mod_positive()'
    or '.sites_mod_short()' on the result, or alternatively
    set sites_mod_positive to 'True' in case you want to change this behaviour.

    :param append_number_to_labels: If set to 'True' scatterers generated from \
    symmetry will be labelled with a numerical suffix
    :type append_number_to_labels: boolean
    :param sites_mod_positive: If set to 'True' xyz coordinates of the \
    scatterers will be kept inside [0,1[
    :type sites_mod_positive: boolean

    :returns: a new instance of the structure expanded into P1
    :rtype: cctbx.xray.structure
    """
    result = structure(
      special_position_settings
        =crystal.special_position_settings(
          crystal.symmetry.cell_equivalent_p1(self)),
      scatterers=ext.expand_to_p1(
        unit_cell=self.unit_cell(),
        space_group=self.space_group(),
        scatterers=self._scatterers,
        site_symmetry_table=self._site_symmetry_table,
        append_number_to_labels=append_number_to_labels),
      scattering_type_registry=self._scattering_type_registry,
      wavelength=self.wavelength)
    if (sites_mod_positive):
      result = result.sites_mod_positive()
    return result

  def sites_mod_positive(self):
    """Get the current structure converted into a structure with x,y,z of all
    scatterers in the interval [0,1[

    :returns: the same instance of the structure with only posive coordinates \
    of its scatterers
    :rtype: cctbx.xray.structure
    """
    return structure(
      special_position_settings=self,
      scatterers=self.scatterers().sites_mod_positive(),
      scattering_type_registry=self._scattering_type_registry,
      wavelength=self.wavelength)

  def sites_mod_short(self):
    """Get the current structure converted into a structure with short
    coordinates vectors of all scatterers

    :returns: the same instance of the structure with only short coordinates \
    vectors of its scatterers
    :rtype: cctbx.xray.structure
    """
    return structure(
      special_position_settings=self,
      scatterers=self.scatterers().sites_mod_short(),
      scattering_type_registry=self._scattering_type_registry,
      wavelength=self.wavelength)

  def apply_shift(self, shift, recompute_site_symmetries=False):
    shifted_scatterers = self.scatterers().deep_copy()
    shifted_scatterers.set_sites(shifted_scatterers.extract_sites() + shift)
    if (recompute_site_symmetries):
      site_symmetry_table = None
    else:
      site_symmetry_table = self._site_symmetry_table
    return structure(
      special_position_settings=self,
      scatterers=shifted_scatterers,
      site_symmetry_table=site_symmetry_table,
      scattering_type_registry=self._scattering_type_registry,
      wavelength=self.wavelength)

  def random_shift_sites(self, max_shift_cart=0.2):
    shifts = flex.vec3_double(
      (flex.random_double(self.scatterers().size()*3)*2-1) * max_shift_cart)
    return self.apply_shift(self.unit_cell().fractionalize(sites_cart=shifts))

  def sort(self, by_value="occupancy", reverse=False):
    assert by_value in ("occupancy",)
    assert reverse in (False, True)
    p = flex.sort_permutation(
      data=self.scatterers().extract_occupancies(),
      reverse=reverse)
    return structure(
      special_position_settings=self,
      scatterers=self._scatterers.select(p),
      site_symmetry_table=self._site_symmetry_table.select(p),
      scattering_type_registry=self._scattering_type_registry,
      wavelength=self.wavelength)

  def as_emma_model(self):
    from cctbx import euclidean_model_matching as emma
    positions = []
    for scatterer in self.scatterers():
      positions.append(emma.position(scatterer.label, scatterer.site))
    return emma.model(self, positions)

  def atomic_weights(self):
    from cctbx.eltbx import tiny_pse
    result = flex.double()
    for scatterer in self.scatterers():
      std_lbl = eltbx.xray_scattering.get_standard_label(
        label=scatterer.scattering_type, exact=True, optional=True)
      if (std_lbl is None):
        raise RuntimeError(
          "Unknown atomic weight: " + scatterer.scattering_type)
      result.append(tiny_pse.table(std_lbl).weight())
    return result

  def center_of_mass(self, atomic_weights=None):
    if (atomic_weights is None):
      atomic_weights = self.atomic_weights()
    return self.sites_cart().mean_weighted(weights=atomic_weights)

  def principal_axes_of_inertia(self, atomic_weights=None):
    if (atomic_weights is None):
      atomic_weights = self.atomic_weights()
    return scitbx.math.principal_axes_of_inertia(
      points=self.sites_cart(),
      weights=atomic_weights)

  def set_u_cart(self, u_cart, selection = None):
    assert self._scatterers.size() == u_cart.size()
    if(selection is not None):
      self._scatterers.set_u_cart(unit_cell = self.unit_cell(),
                                  u_cart    = u_cart,
                                  selection = selection)
    else:
      self._scatterers.set_u_cart(unit_cell = self.unit_cell(),
                                  u_cart    = u_cart)

  def show_scatterer_flags_summary(self, out=None):
    # XXX move to C++
    if (out is None): out = sys.stdout
    n_use = 0
    n_use_u_both = 0
    n_use_u_iso = 0
    n_use_u_aniso = 0
    n_use_u_none = 0
    n_grad_site = 0
    n_grad_u_iso = 0
    n_grad_u_aniso = 0
    n_grad_occupancy = 0
    n_grad_fp = 0
    n_grad_fdp = 0
    for scatterer in self.scatterers():
      flags = scatterer.flags
      if (flags.use()): n_use += 1
      i, a = flags.use_u_iso(), flags.use_u_aniso()
      if (i and a): n_use_u_both += 1
      elif (i):     n_use_u_iso += 1
      elif (a):     n_use_u_aniso += 1
      else:         n_use_u_none += 1
      if (flags.grad_site()):      n_grad_site += 1
      if (flags.grad_u_iso()):     n_grad_u_iso += 1
      if (flags.grad_u_aniso()):   n_grad_u_aniso += 1
      if (flags.grad_occupancy()): n_grad_occupancy += 1
      if (flags.grad_fp()):        n_grad_fp += 1
      if (flags.grad_fdp()):       n_grad_fdp += 1
    print("n_use            = ", n_use, file=out)
    if (n_use_u_none != 0):
      print("n_use_u_none     = ", n_use_u_none, file=out)
    if (n_use_u_both != 0):
      print("n_use_u_both     = ", n_use_u_both, file=out)
    print("n_use_u_iso      = ", n_use_u_iso, file=out)
    print("n_use_u_aniso    = ", n_use_u_aniso, file=out)
    print("n_grad_site      = ", n_grad_site, file=out)
    print("n_grad_u_iso     = ", n_grad_u_iso, file=out)
    print("n_grad_u_aniso   = ", n_grad_u_aniso, file=out)
    print("n_grad_occupancy = ", n_grad_occupancy, file=out)
    print("n_grad_fp        = ", n_grad_fp, file=out)
    print("n_grad_fdp       = ", n_grad_fdp, file=out)
    print("total number of scatterers = ", self.scatterers().size(), file=out)

  def scatterer_flags(self):
    return ext.shared_scatterer_flags(self.scatterers())

  def set_scatterer_flags(self, scatterer_flags):
    scatterer_flags.assign_to(self.scatterers())

  def n_parameters(self, considering_site_symmetry_constraints=False):
    # XXX move to C++
    result = 0
    if (considering_site_symmetry_constraints):
      sstab = self.site_symmetry_table()
    else:
      sstab = None
    for i_sc,sc in enumerate(self.scatterers()):
      flags = sc.flags
      if (sstab is None):
        site_symmetry = None
      else:
        site_symmetry = sstab.get(i_sc)
        if (site_symmetry.is_point_group_1()):
          site_symmetry = None
      if (flags.grad_site()):
        if (site_symmetry is None):
          result += 3
        else:
          result += site_symmetry.site_constraints().n_independent_params()
      if (    flags.grad_u_iso()
          and flags.use_u_iso()): result += 1
      if (    flags.grad_u_aniso()
          and flags.use_u_aniso()):
        if (site_symmetry is None):
          result += 6
        else:
          result += site_symmetry.adp_constraints().n_independent_params()
      if (flags.grad_occupancy()): result += 1
      if (flags.grad_fp()): result += 1
      if (flags.grad_fdp()): result += 1
    return result

  def n_grad_u_iso(self):
    return self.scatterers().n_grad_u_iso()

  def n_grad_u_aniso(self):
    return self.scatterers().n_grad_u_aniso()

  def parameter_map(self):
    return cctbx.xray.parameter_map(self.scatterers())

  def truncate_at_pdb_format_precision(self):
    uc = self.unit_cell()
    fra = uc.fractionalize
    ort = uc.orthogonalize
    for sc in self.scatterers():
      sc.site = fra([float("%8.3f"%i) for i in ort(sc.site)])
      if(sc.u_iso != -1.0):
        sc.u_iso = adptbx.b_as_u(float("%6.2f"%adptbx.u_as_b(sc.u_iso)))
      sc.occupancy = float("%5.2f"%sc.occupancy)
      if(sc.u_star != (-1,-1,-1,-1,-1,-1)):
        u_pdb = [int(i*10000) for i in adptbx.u_star_as_u_cart(uc, sc.u_star)]
        sc.u_star = adptbx.u_cart_as_u_star(uc, [float(i)/10000 for i in u_pdb])

  def grads_and_curvs_target_simple(self, miller_indices, da_db, daa_dbb_dab):
    return ext.structure_factors_curvatures_simple_grads_and_curvs_target(
      unit_cell=self.unit_cell(),
      space_group=self.space_group(),
      scatterers=self.scatterers(),
      scattering_type_registry=self.scattering_type_registry(),
      site_symmetry_table=self.site_symmetry_table(),
      miller_indices=miller_indices,
      da_db=da_db,
      daa_dbb_dab=daa_dbb_dab)

  def pair_sym_table_show(self,
        pair_sym_table,
        is_full_connectivity=False,
        out=None):
    if (is_full_connectivity):
      site_symmetry_table = None
    else:
      site_symmetry_table = self.site_symmetry_table()
    return pair_sym_table.show(
      f=out,
      site_labels=self.scatterers().extract_labels(),
      site_symmetry_table=site_symmetry_table,
      sites_frac=self.sites_frac(),
      unit_cell=self.unit_cell())

  def pair_sym_table_show_distances(self,
        pair_sym_table,
        show_cartesian=False,
        skip_j_seq_less_than_i_seq=False,
        skip_sym_equiv=False,
        out=None):
    return pair_sym_table.show_distances(
      unit_cell=self.unit_cell(),
      site_symmetry_table=self.site_symmetry_table(),
      site_labels=self.scatterers().extract_labels(),
      sites_frac=self.sites_frac(),
      show_cartesian=show_cartesian,
      skip_j_seq_less_than_i_seq=skip_j_seq_less_than_i_seq,
      skip_sym_equiv=skip_sym_equiv,
      out=out)

  def asu_mappings(self, buffer_thickness, asu_is_inside_epsilon=None):
    result = crystal.symmetry.asu_mappings(self,
      buffer_thickness=buffer_thickness,
      asu_is_inside_epsilon=asu_is_inside_epsilon)
    ext.asu_mappings_process(
      asu_mappings=result,
      scatterers=self._scatterers,
      site_symmetry_table=self._site_symmetry_table)
    return result

  def pair_asu_table(self,
        distance_cutoff=None,
        asu_mappings_buffer_thickness=None,
        asu_is_inside_epsilon=None,
        min_cubicle_edge=5):
    assert (distance_cutoff is not None
            or asu_mappings_buffer_thickness is not None)
    if (asu_mappings_buffer_thickness is None):
      asu_mappings_buffer_thickness = distance_cutoff
    asu_mappings = self.asu_mappings(
      buffer_thickness=asu_mappings_buffer_thickness,
      asu_is_inside_epsilon=asu_is_inside_epsilon)
    pair_asu_table = crystal.pair_asu_table(asu_mappings=asu_mappings)
    if (distance_cutoff is not None):
      pair_asu_table.add_all_pairs(
        distance_cutoff=distance_cutoff,
        min_cubicle_edge=min_cubicle_edge)
    return pair_asu_table

  def show_distances(self,
        distance_cutoff=None,
        asu_mappings_buffer_thickness=None,
        asu_is_inside_epsilon=None,
        min_cubicle_edge=5,
        pair_asu_table=None,
        show_cartesian=False,
        keep_pair_asu_table=False,
        out=None):
    assert [distance_cutoff, pair_asu_table].count(None) == 1
    if (pair_asu_table is None):
      pair_asu_table = self.pair_asu_table(
        distance_cutoff=distance_cutoff,
        asu_mappings_buffer_thickness=asu_mappings_buffer_thickness,
        asu_is_inside_epsilon=asu_is_inside_epsilon,
        min_cubicle_edge=min_cubicle_edge)
    return pair_asu_table.show_distances(
      site_labels=self.scatterers().extract_labels(),
      sites_frac=self.sites_frac(),
      show_cartesian=show_cartesian,
      keep_pair_asu_table=keep_pair_asu_table,
      out=out)

  def show_angles(self,
        distance_cutoff=None,
        asu_mappings_buffer_thickness=None,
        asu_is_inside_epsilon=None,
        pair_asu_table=None,
        keep_pair_asu_table=False,
        out=None):
    assert [distance_cutoff, pair_asu_table].count(None) == 1
    if (pair_asu_table is None):
      pair_asu_table = self.pair_asu_table(
        distance_cutoff=distance_cutoff,
        asu_mappings_buffer_thickness=asu_mappings_buffer_thickness,
        asu_is_inside_epsilon=asu_is_inside_epsilon)
    return pair_asu_table.show_angles(
      site_labels=self.scatterers().extract_labels(),
      sites_frac=self.sites_frac(),
      keep_pair_asu_table=keep_pair_asu_table,
      out=out)

  def show_dihedral_angles(self,
        distance_cutoff=None,
        max_d=1.7,
        max_angle=170,
        asu_mappings_buffer_thickness=None,
        asu_is_inside_epsilon=None,
        pair_asu_table=None,
        keep_pair_asu_table=False,
        out=None):
    if (pair_asu_table is None):
      pair_asu_table = self.pair_asu_table(
        distance_cutoff=distance_cutoff,
        asu_mappings_buffer_thickness=asu_mappings_buffer_thickness,
        asu_is_inside_epsilon=asu_is_inside_epsilon)
    return pair_asu_table.show_dihedral_angles(
      site_labels=self.scatterers().extract_labels(),
      sites_frac=self.sites_frac(),
      max_d=max_d,
      max_angle=max_angle,
      out=out)

  def conservative_pair_proxies(self, bond_sym_table, conserve_angles):
    return conservative_pair_proxies(
      structure=self,
      bond_sym_table=bond_sym_table,
      conserve_angles=conserve_angles)

  def difference_vectors_cart(self, other):
    return other.sites_cart() - self.sites_cart()

  def rms_difference(self, other):
    return self.sites_cart().rms_difference(other.sites_cart())

  def closest_distances(self, sites_frac, distance_cutoff, use_selection=None):
    class map_next_to_model_and_find_closest_distances(object):
      def __init__(self, xray_structure, sites_frac, use_selection):
        asu_mappings = xray_structure.asu_mappings(buffer_thickness =
          distance_cutoff)
        asu_mappings.process_sites_frac(sites_frac, min_distance_sym_equiv =
          xray_structure.min_distance_sym_equiv())
        pair_generator = crystal.neighbors_fast_pair_generator(asu_mappings =
          asu_mappings, distance_cutoff = distance_cutoff)
        n_xray = xray_structure.scatterers().size()
        new_sites_frac = sites_frac.deep_copy()
        smallest_distances_sq = flex.double(sites_frac.size(),
          distance_cutoff**2+1)
        i_seqs = flex.int(sites_frac.size(), -1)
        for pair in pair_generator:
          if(pair.i_seq < n_xray):
            if (pair.j_seq < n_xray): continue
            # i_seq = molecule
            # j_seq = site
            rt_mx_i = asu_mappings.get_rt_mx_i(pair)
            rt_mx_j = asu_mappings.get_rt_mx_j(pair)
            rt_mx_ji = rt_mx_i.inverse().multiply(rt_mx_j)
            i_seq_new_site_frac = pair.j_seq - n_xray
            new_site_frac = rt_mx_ji * sites_frac[i_seq_new_site_frac]
            jn = pair.i_seq
          else:
            if(pair.j_seq >= n_xray): continue
            # i_seq = site
            # j_seq = molecule
            rt_mx_i = asu_mappings.get_rt_mx_i(pair)
            rt_mx_j = asu_mappings.get_rt_mx_j(pair)
            rt_mx_ij = rt_mx_j.inverse().multiply(rt_mx_i)
            i_seq_new_site_frac = pair.i_seq - n_xray
            new_site_frac = rt_mx_ij * sites_frac[i_seq_new_site_frac]
            jn = pair.j_seq
          if(use_selection[jn]):
            if(smallest_distances_sq[i_seq_new_site_frac] >= pair.dist_sq):
              smallest_distances_sq[i_seq_new_site_frac] = pair.dist_sq
              new_sites_frac[i_seq_new_site_frac] = new_site_frac
              i_seqs[i_seq_new_site_frac] = jn
        self.remove_selection = smallest_distances_sq > distance_cutoff**2
        self.sites_frac = new_sites_frac
        self.smallest_distances = flex.sqrt(
          smallest_distances_sq).set_selected(self.remove_selection, -1)
        self.smallest_distances_sq = smallest_distances_sq.set_selected(
          self.remove_selection, -1)
        self.i_seqs = i_seqs
    if(use_selection is not None):
      assert use_selection.size() == self._scatterers.size()
    else:
      use_selection = flex.bool(self._scatterers.size(), True)
    result = map_next_to_model_and_find_closest_distances(
      xray_structure = self, sites_frac = sites_frac, use_selection =
      use_selection)
    return result

  def orthorhombic_unit_cell_around_centered_scatterers(self, buffer_size):
    sites_cart = self.sites_cart()
    sites_cart_min = sites_cart.min()
    abc = [2*buffer_size+a-i for i,a in zip(sites_cart_min,sites_cart.max())]
    sites_cart += [buffer_size-i for i in sites_cart_min]
    result = structure(
      crystal_symmetry=crystal.symmetry(
        unit_cell=abc,
        space_group_symbol="P1"),
      scatterers=self.scatterers(),
      wavelength=self.wavelength)
    result.set_sites_cart(sites_cart)
    return result

  def cubic_unit_cell_around_centered_scatterers(self, buffer_size):
    sites_cart = self.sites_cart()
    sites_cart_min = sites_cart.min()
    span = [a-i for i,a in zip(sites_cart_min, sites_cart.max())]
    a = max(span) + 2 * buffer_size
    sites_cart += [(a-s)/2-i for i,s in zip(sites_cart_min, span)]
    result = structure(
      crystal_symmetry=crystal.symmetry(
        unit_cell=[a,a,a],
        space_group_symbol="P1"),
      scatterers=self.scatterers(),
      wavelength=self.wavelength)
    result.set_sites_cart(sites_cart)
    return result

  def as_cif_simple(self, out=None, data_name="global", format="mmCIF"):
    if out is None: out = sys.stdout
    import iotbx.cif
    cif = iotbx.cif.model.cif()
    cif[data_name] = self.as_cif_block(format=format)
    print(cif, file=out)

  def as_cif_block(self, covariance_matrix=None,
    cell_covariance_matrix=None, format="mmCIF"):

    from iotbx.cif import atom_type_cif_loop, model
    cs_cif_block = self.crystal_symmetry().as_cif_block(
        format=format,
        cell_covariance_matrix=cell_covariance_matrix)
    # crystal_symmetry_as_cif_block.__init__(
    #   self, xray_structure.crystal_symmetry(),
    #   cell_covariance_matrix=cell_covariance_matrix)
    scatterers = self.scatterers()
    uc = self.unit_cell()
    if covariance_matrix is not None:
      param_map = self.parameter_map()
      covariance_diagonal = covariance_matrix.matrix_packed_u_diagonal()
      u_star_to_u_cif_linear_map_pow2 = flex.pow2(flex.double(
        uc.u_star_to_u_cif_linear_map()))
      u_star_to_u_iso_linear_form = matrix.row(
        uc.u_star_to_u_iso_linear_form())
    fmt = "%.6f"

    # _atom_site_* loop
    atom_site_loop = model.loop(header=(
      '_atom_site_label', '_atom_site_type_symbol',
      '_atom_site_fract_x', '_atom_site_fract_y', '_atom_site_fract_z',
      '_atom_site_U_iso_or_equiv', '_atom_site_adp_type',
      '_atom_site_occupancy'))
    for i_seq, sc in enumerate(scatterers):
      site = occu = u_iso_or_equiv = None
      # site
      if covariance_matrix is not None:
        params = param_map[i_seq]
        if sc.flags.grad_site() and params.site >= 0:
          site = []
          for i in range(3):
            site.append(format_float_with_su(sc.site[i],
              math.sqrt(covariance_diagonal[params.site+i])))
        #occupancy
        if sc.flags.grad_occupancy() and params.occupancy >= 0:
          occu = format_float_with_su(sc.occupancy,
            math.sqrt(covariance_diagonal[params.occupancy]))
        #Uiso/eq
        if sc.flags.grad_u_iso() or sc.flags.grad_u_aniso():
          if sc.flags.grad_u_iso():
            u_iso_or_equiv = format_float_with_su(
              sc.u_iso, math.sqrt(covariance.variance_for_u_iso(
                i_seq, covariance_matrix, param_map)))
          else:
            cov = covariance.extract_covariance_matrix_for_u_aniso(
              i_seq, covariance_matrix, param_map).matrix_packed_u_as_symmetric()
            var = (u_star_to_u_iso_linear_form * matrix.sqr(cov)
                   ).dot(u_star_to_u_iso_linear_form)
            u_iso_or_equiv = format_float_with_su(
              sc.u_iso_or_equiv(uc), math.sqrt(var))

      if site is None:
        site = [fmt % sc.site[i] for i in range(3)]
      if occu is None:
        occu = fmt % sc.occupancy
      if u_iso_or_equiv is None:
        u_iso_or_equiv = fmt % sc.u_iso_or_equiv(uc)

      if sc.flags.use_u_aniso():
        adp_type = 'Uani'
      else:
        adp_type = 'Uiso'
      atom_site_loop.add_row((
        sc.label, sc.scattering_type, site[0], site[1], site[2], u_iso_or_equiv,
        adp_type, occu))
    cs_cif_block.add_loop(atom_site_loop)

    # _atom_site_aniso_* loop
    aniso_scatterers = scatterers.select(scatterers.extract_use_u_aniso())
    if aniso_scatterers.size():
      labels = list(scatterers.extract_labels())
      aniso_loop = model.loop(header=('_atom_site_aniso_label',
                                      '_atom_site_aniso_U_11',
                                      '_atom_site_aniso_U_22',
                                      '_atom_site_aniso_U_33',
                                      '_atom_site_aniso_U_12',
                                      '_atom_site_aniso_U_13',
                                      '_atom_site_aniso_U_23'))
      anharmonic_scatterers = []
      for sc in aniso_scatterers:
        if sc.anharmonic_adp:
          anharmonic_scatterers.append(sc)
        u_cif = adptbx.u_star_as_u_cif(uc, sc.u_star)
        if covariance_matrix is not None:
          row = [sc.label]
          idx = param_map[labels.index(sc.label)].u_aniso
          if idx > -1:
            var = covariance_diagonal[idx:idx+6] * u_star_to_u_cif_linear_map_pow2
            for i in range(6):
              if var[i] > 0:
                row.append(
                  format_float_with_su(u_cif[i], math.sqrt(var[i])))
              else:
                row.append(fmt%u_cif[i])
          else:
            row = [sc.label] + [fmt%u_cif[i] for i in range(6)]
        else:
          row = [sc.label] + [fmt%u_cif[i] for i in range(6)]
        aniso_loop.add_row(row)
      cs_cif_block.add_loop(aniso_loop)
      if anharmonic_scatterers:
        from cctbx.sgtbx import rank_3_tensor_constraints as t3c
        from cctbx.sgtbx import rank_4_tensor_constraints as t4c
        C_header= ['_atom_site_anharm_GC_C_label']
        D_header= ['_atom_site_anharm_GC_D_label']
        for idx in flex.rows(t3c.indices()):
          C_header.append("_atom_site_anharm_GC_C_%s%s%s" %(idx[0]+1,idx[1]+1,idx[2]+1))
        for idx in flex.rows(t4c.indices()):
          D_header.append("_atom_site_anharm_GC_D_%s%s%s%s" %(idx[0]+1,idx[1]+1,idx[2]+1,idx[3]+1))
        C_loop = model.loop(header=(C_header))
        D_loop = model.loop(header=(D_header))
        for sc in anharmonic_scatterers:
          C_row = [sc.label]
          D_row = [sc.label]
          for i, d in enumerate(sc.anharmonic_adp.data()):
            if covariance_matrix is not None:
              idx = param_map[labels.index(sc.label)].u_aniso
              if idx > -1:
                var = covariance_diagonal[idx+6:idx+6+25]
                d = format_float_with_su(d, math.sqrt(var[i]))
            if i < 10:
              C_row.append(d)
            else:
              D_row.append(d)
          C_loop.add_row(C_row)
          D_loop.add_row(D_row)
        cs_cif_block.add_loop(C_loop)
        cs_cif_block.add_loop(D_loop)
      cs_cif_block.add_loop(atom_type_cif_loop(self, format=format))
    return cs_cif_block

  def as_pdb_file(self,
        remark=None,
        remarks=[],
        fractional_coordinates=False,
        resname=None,
        connect=None):
    import iotbx.pdb.xray_structure
    return iotbx.pdb.xray_structure.as_pdb_file(
      self=self,
      remark=remark,
      remarks=remarks,
      fractional_coordinates=fractional_coordinates,
      resname=resname,
      connect=connect)

  @classmethod
  def from_shelx(cls, *args, **kwds):
    import iotbx.shelx
    return iotbx.shelx._cctbx_xray_structure_from(*args, **kwds)

  @classmethod
  def from_cif(cls, file_object=None, file_path=None, data_block_name=None):
    import iotbx.cif
    from iotbx.cif import builders
    result = iotbx.cif.cctbx_data_structures_from_cif(
      file_object=file_object, file_path=file_path,
      data_block_name=data_block_name,
      data_structure_builder=builders.crystal_structure_builder)
    if len(result.xray_structures):
      if data_block_name is not None:
        return result.xray_structures[data_block_name]
      else:
        return result.xray_structures
    else:
      raise Sorry("Could not extract an xray.structure from the given input")

  def unit_cell_content(self, omit=None):
    """ The content of the unit cell as a chemical formula """
    return dict([ (r.scattering_type, r.unit_cell_occupancy_sum)
                  for r in self.scattering_types_counts_and_occupancy_sums()
                  if not omit or r.scattering_type not in omit ])

  def make_scatterer_labels_shelx_compatible_in_place(self):
    result = []
    upper = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    digits = "0123456789"
    def is_useful_label(lbl):
      if (len(lbl) == 0): return False
      if (len(lbl) > 4): return False
      if (lbl[0] not in upper): return False
      for c in lbl[1:]:
        if (    c not in upper
            and c not in digits):
          return False
      return True
    lbl_set = set()
    def reset(label):
      if (sc.label != label):
        result.append((sc.label, label))
        sc.label = label
      lbl_set.add(label)
    for sc in self.scatterers():
      lbl = sc.label.strip().replace(" ", "").upper()
      lbl_is_useful = is_useful_label(lbl)
      if (lbl not in lbl_set and lbl_is_useful):
        reset(label=lbl)
      else:
        def find_tail_replacement(fmt, n):
          for i in range(1,n):
            s = fmt % i
            trial = lbl[:4-len(s)]+s
            if (trial not in lbl_set):
              reset(label=trial)
              return True
          return False
        def find_replacement_using_scattering_type():
          from cctbx.eltbx.xray_scattering import get_element_and_charge_symbols
          e, _ = get_element_and_charge_symbols(
            scattering_type=sc.scattering_type,
            exact=False)
          if (len(e) == 0): return False
          assert len(e) <= 2
          if (len(e) == 1): fmt, n = "%03d", 1000
          else:             fmt, n = "%02d", 100
          e = e.upper()
          for i in range(1,n):
            trial = e + fmt % i
            if (trial not in lbl_set):
              reset(label=trial)
              return True
          return False
        def find_complete_replacement():
          for c in upper:
            for i in range(1,1000):
              trial = c + "%03d" % i
              if (trial not in lbl_set):
                reset(label=trial)
                return True
          return False
        if (lbl_is_useful):
          if (find_tail_replacement("%d", 10)): continue
          if (find_tail_replacement("%02d", 100)): continue
          if (find_tail_replacement("%03d", 1000)): continue
        if (find_replacement_using_scattering_type()): continue
        if (find_complete_replacement()): continue
        raise RuntimeError(
          "Unable to find unused SHELX-compatible scatterer label.")
    return result

  def intersection_of_scatterers(self, i_seq, j_seq):
    """
    For a pair of scatterers, calculates their overlap given the coordinates
    and displacement parameters (using adptbx.intersection).
    """
    sc1 = self.scatterers()[i_seq]
    sc2 = self.scatterers()[j_seq]
    if (sc1.flags.use_u_aniso()):
      u1 = sc1.u_star
    else :
      u1 = sc1.u_iso
    if (sc2.flags.use_u_aniso()):
      u2 = sc2.u_star
    else :
      u2 = sc2.u_iso
    return adptbx.intersection(
      u_1=u1,
      u_2=u2,
      site_1=sc1.site,
      site_2=sc2.site,
      unit_cell=self.unit_cell())

class conservative_pair_proxies(object):

  def __init__(self, structure, bond_sym_table, conserve_angles):
    from cctbx import geometry_restraints
    buffer_thickness = flex.max_default(
      values=crystal.get_distances(
        pair_sym_table=bond_sym_table,
        orthogonalization_matrix
          =structure.unit_cell().orthogonalization_matrix(),
        sites_frac=structure.sites_frac()),
      default=1)
    if (conserve_angles): buffer_thickness *= 2
    asu_mappings = structure.asu_mappings(buffer_thickness=buffer_thickness)
    bond_pair_asu_table = crystal.pair_asu_table(asu_mappings=asu_mappings)
    bond_pair_asu_table.add_pair_sym_table(sym_table=bond_sym_table)
    self.bond = geometry_restraints.bond_sorted_asu_proxies(
      pair_asu_table=bond_pair_asu_table)
    if (not conserve_angles):
      self.angle = None
    else:
      angle_pair_asu_table = bond_pair_asu_table.angle_pair_asu_table()
      self.angle = geometry_restraints.bond_sorted_asu_proxies(
        pair_asu_table=angle_pair_asu_table)


class meaningful_site_cart_differences(object):
  """ Differences between the Cartesian coordinates of corresponding sites
  in two structures, cancelling continuous origin shifts if any.

  This is especially useful to compare a refined
  structure to a reference structure as the former may have drifted along
  a continuous shift direction during refinement, therefore spoiling
  a naive comparison of corresponding sites.
  """

  def __init__(self, xs1, xs2):
    self.labels = [ sc.label for sc in xs1.scatterers() ]
    self.delta = canonical_delta = xs1.sites_cart() - xs2.sites_cart()
    if xs1.space_group() == xs2.space_group():
      ssi = sgtbx.structure_seminvariants(xs1.space_group())\
                 .select(discrete=False)
      if ssi.size():
        shifts = [ matrix.col(xs1.unit_cell().orthogonalize(vm.v))
                   for vm in ssi.vectors_and_moduli() ]
        if len(shifts) == 1:
          e0 = shifts[0].normalize()
          e1 = e0.ortho()
          e2 = e0.cross(e1)
        elif len(shifts) == 2:
          e0 = shifts[0].normalize()
          v = shifts[1]
          e1 = (e0 - 1/e0.dot(v)*v).normalize()
          e2 = e0.cross(e1)
        elif len(shifts) == 3:
          e0, e1, e2 = [ (1,0,0), (0,1,0), (0,0,1) ]
        deltas = [ canonical_delta.dot(e) for e in (e0, e1, e2) ]
        means = [ flex.mean(d) for d in deltas ]
        if len(shifts) == 1:
          means_correction = (means[0], 0, 0)
        elif len(shifts) == 2:
          means_correction = (means[0], means[1], 0)
        elif len(shifts) == 3:
          means_correction = tuple(means)
        self.delta = flex.vec3_double(deltas[0], deltas[1], deltas[2])
        self.delta -= means_correction

  def max_absolute(self):
    return flex.max_absolute(self.delta.as_double())

  def show(self):
    for lbl, diff in six.moves.zip(self.labels, self.delta):
      print("%6s: (%.6f, %.6f, %.6f)" % ((lbl,) + diff))


 *******************************************************************************


 *******************************************************************************
cctbx/xray/structure_factors/__init__.py
from __future__ import absolute_import, division, print_function
from cctbx.xray.structure_factors.misc import *
from cctbx.xray.structure_factors.gradient_flags import *
from cctbx.xray.structure_factors.from_scatterers import *
from cctbx.xray.structure_factors.gradients import *


 *******************************************************************************


 *******************************************************************************
cctbx/xray/structure_factors/from_scatterers.py
from __future__ import absolute_import, division, print_function
# -*- coding: utf-8 -*-
from cctbx.xray.structure_factors.manager import manager
from cctbx.xray.structure_factors.from_scatterers_direct \
  import from_scatterers_direct
from cctbx.xray.structure_factors.from_scatterers_fft \
  import from_scatterers_fft

class from_scatterers(manager):
  """ Factory class for structure factor evaluations """

  def __call__(self, xray_structure,
                     miller_set,
                     algorithm=None):
    """Evaluate structure factors and return the result

    :type xray_structure: cctbx.xray.structure
    :param xray_structure: the X-ray structure to evaluate the structure factors of
    :type miller_set: cctbx.miller.set
    :param miller_set: the set of miller indices to evaluate the structure factors at
    :type algorithm: string
    :param algorithm: the name of the evaluation method, either "direct", "fft", or None

    :rtype: an instance of
      `cctbx.xray.structure_factors.from_scatterers_direct` or
      `cctbx.xray.structure_factors.from_scatterers_fft`
    :retruns: an instance e of
      `cctbx.xray.structure_factors.from_scatterers_direct` or
      `cctbx.xray.structure_factors.from_scatterers_fft`
      when C{algorithm} is respectively equal to "direct" or "fft",
      or the best suited of the two of them when C{algorithm} is None
      providing the evaluated structure factors as C{e.f_calc()}
    """
    assert algorithm in ("direct", "fft", None)
    if (algorithm is None):
      n_scatterers = xray_structure.scatterers().size()
      n_miller_indices = miller_set.indices().size()
      if (not self.have_good_timing_estimates()):
        # rough estimate
        if (  4*n_scatterers*self.space_group().order_p()*n_miller_indices
            < self.crystal_gridding().n_grid_points()):
          algorithm = "direct"
      else:
        if (   self.estimate_time_direct(n_scatterers * n_miller_indices)
            <= self.estimate_time_fft(n_scatterers, n_miller_indices)):
          algorithm = "direct"
    if (algorithm == "direct"): f = from_scatterers_direct
    else:                       f = from_scatterers_fft
    return f(
      manager=self,
      xray_structure=xray_structure,
      miller_set=miller_set,
      algorithm=algorithm) # passing algorithm allows f to decide on CPU/GPU implementation


 *******************************************************************************


 *******************************************************************************
cctbx/xray/structure_factors/from_scatterers_direct.py
from __future__ import absolute_import, division, print_function
# -*- coding: utf-8 -*-
from cctbx.xray.structure_factors.manager import managed_calculation_base
from cctbx.xray.structure_factors.manager import default_cos_sin_table
from cctbx.xray.structure_factors import global_counters
from cctbx.xray import ext
from cctbx import miller
from libtbx.utils import user_plus_sys_time

class from_scatterers_direct(managed_calculation_base):

  def __init__(self, xray_structure,
                     miller_set,
                     manager=None,
                     cos_sin_table=False,
                     algorithm="direct"):
    """Evaluate structure factors via direct calculations

    :type xray_structure: cctbx.xray.structure
    :param xray_structure: the X-ray structure to evaluate the structure factors of
    :type miller_set: cctbx.miller.set
    :param miller_set: the set of miller indices to evaluate the structure factors at
    :type manager: cctbx.xray.structure_factors.manager
    :param manager: ? (TODO: doc)
    :type algorithm: string
    :param algorithm: the name of the evaluation method, either \
    "direct", "use_alt_parallel"
    :type cos_sin_table: boolean
    :param cos_sin_table: If set to 'True' a precalculated cos_sin_table is used \
    instead of actual trigonometric functions. Using a manager overrides this \
    setting with the one specified in the manager.

    :rtype: cctbx.xray.structure_factors.from_scatterers_direct
    :retruns: an instance `e` of `cctbx.xray.structure_factors.from_scatterers_direct` \
    providing the evaluated structure factors as `e.f_calc()`
    """
    time_all = user_plus_sys_time()
    managed_calculation_base.__init__(self,
      manager, xray_structure, miller_set, algorithm="direct")
    if hasattr(algorithm,"use_alt_parallel"):
        #enumeration of indices() is fast compared to direct summation
        from cctbx.xray.structure_factors.from_scatterers_direct_parallel import pprocess
        pprocess(self,algorithm)
        return
    timer = user_plus_sys_time()
    if (manager is not None):
      cos_sin_table = manager.cos_sin_table()
    if (cos_sin_table == True):
      cos_sin_table = default_cos_sin_table
    elif (cos_sin_table == False):
      cos_sin_table = None
    if (cos_sin_table is None):
      self._results = ext.structure_factors_direct(
        self._miller_set.unit_cell(),
        self._miller_set.space_group(),
        self._miller_set.indices(),
        self._xray_structure.scatterers(),
        self._xray_structure.scattering_type_registry())
    else:
      self._results = ext.structure_factors_direct(
        cos_sin_table,
        self._miller_set.unit_cell(),
        self._miller_set.space_group(),
        self._miller_set.indices(),
        self._xray_structure.scatterers(),
        self._xray_structure.scattering_type_registry())
    if (manager is not None):
      manager.estimate_time_direct.register(
        xray_structure.scatterers().size() * miller_set.indices().size(),
        timer.elapsed())
    global_counters.from_scatterers_direct.process(time_all.elapsed())

  def f_calc(self):
    return miller.array(self._miller_set, self._results.f_calc())


 *******************************************************************************


 *******************************************************************************
cctbx/xray/structure_factors/from_scatterers_direct_parallel.py
from __future__ import absolute_import, division, print_function
# -*- coding: utf-8 -*-
import copy,math
from scitbx.array_family import flex
from cctbx.xray import ext
from libtbx.utils import Sorry
from six.moves import range

# alternative implementations of direct summation using parallel architecture
# example usage is given in cctbx/regression/tst_direct_scaling

class pprocess:
  """Class to represent a worker process

  Software requirements for running direct summation using Cuda parallel processing units:

    1. numpy package (http://numpy.scipy.org) version 1.5.1 OK
    2. pycuda package, version 2011.1 OK

       * more information
          - http://wiki.tiker.net/PyCuda/Installation/Linux
          - http://documen.tician.de/pycuda/tutorial.html
       * suggested install scheme for Linux (not necessarily exact)::

          ../base/bin/python configure.py --cuda-root=/usr/common/usg/cuda/3.2 \\
          --cudadrv-lib-dir=/usr/common/usg/nvidia-driver-util/3.2/lib64 \\
          --boost-inc-dir=$HOME/boostbuild/include \\
          --boost-lib-dir=$HOME/boostbuild/lib \\
          --boost-python-libname=boost_python \\
          --boost-thread-libname=boost_thread
          make install

    3. gcc 4.4.2 or higher is required for Linux build of pycuda 2011.1
    4. boost_adaptbx.boost.python is required for pycuda; cctbx-installed version is probably OK, not tested.
       tests were performed with separately-installed boost::

          cd boost_1_45_0
          ./bootstrap.sh --prefix=$HOME/boostbuild --libdir=$HOME/boostbuild/lib \\
          --with-python=$HOME/build/base/bin/python \\
          --with-libraries=signals,thread,python
          ./bjam variant=release link=shared install

    5. cuda 3.2 separately installed is required for pycuda 2011.1
       (http://developer.nvidia.com/object/cuda_3_2_downloads.html)

  Suggested hardware as tested:
    * Nvidia Tesla C2050 (Fermi, compute capability 2.0): 225-fold performance improvement over CPU.
    * Nvidia Tesla C1060 (compute capability 1.3): 24-fold performance improvement.
  """

  def print_diagnostics(self):
    for scatterer in self.scatterers:
      print(scatterer)
      print(scatterer.fp)
      print(scatterer.fdp)
    self.registry.show()
    d_star_sq = 1.
    uniqueff = self.registry.unique_form_factors_at_d_star_sq(d_star_sq)
    uniqueix = self.registry.unique_indices(self.scatterers)
    for x in range(len(self.scatterers)):
      print(self.scatterers[x])
      print(self.scatterers[x].scattering_type)
      print(uniqueff[uniqueix[x]])
      constant_term = self.registry.gaussian(self.scatterers[x].scattering_type).c()
      print("constant",constant_term)
      parameters = self.registry.gaussian(self.scatterers[x].scattering_type).parameters()
      x_sq = d_star_sq / 4.;
      unique_form_factor_at_x_sq = copy.copy(constant_term)
      for x in range(0,len(parameters),2):
        unique_form_factor_at_x_sq += parameters[x] * math.exp(-parameters[x+1]*x_sq)
      print(unique_form_factor_at_x_sq)

  def prepare_miller_arrays_for_cuda(self,algorithm,verbose=False):

    """ The number of miller indices and atoms each must be an exact
        multiple of the BLOCKSIZE (32), so zero-padding is employed"""

    # Transfer data from flex arrays to numpy & zero-pad
    # Marshal the miller indices into numpy arrays for use in CUDA

    # Miller indices
    if hasattr(self.miller_indices,"as_vec3_double"):
      flat_mix = self.miller_indices.as_vec3_double().as_double().as_numpy_array().astype(algorithm.numpy_t)
    else: #it's already a vec3 double array (e.g., single particle diffraction)
      flat_mix = self.miller_indices.as_double().as_numpy_array().astype(algorithm.numpy_t)
    if self.miller_indices.size()%FHKL_BLOCKSIZE > 0:
      newsize = 3*FHKL_BLOCKSIZE* (1+(self.miller_indices.size()//FHKL_BLOCKSIZE))
      if verbose: print("Miller indices: resetting %s array from size %d to %d"%(
                        flat_mix.dtype,flat_mix.shape[0],newsize))
      flat_mix.resize(( newsize,))

    self.n_flat_hkl = flat_mix.shape[0]//3
    self.flat_mix = flat_mix

  def prepare_scattering_sites_for_cuda(self,algorithm,verbose=False):

    # Transfer data from flex arrays to numpy & zero-pad
    # Marshal the fractional coordinates, and weights
    # into numpy arrays for use in CUDA

    # inspect the unique scatterers in the registry, determine number of electrons
    n_electrons = self.registry.unique_form_factors_at_d_star_sq(0.)

    # scatterer id, listed in increasing order of electron content
    self.scatterers.increasing_order = flex.sort_permutation(n_electrons)
    self.scatterers.number_of_types = len(self.scatterers.increasing_order)
    self.scatterers.unsorted_counts = []
    self.scatterers.sorted_ranges = []

    # Unique type labels for the scatterers
    uniqueix = self.registry.unique_indices(self.scatterers)
    for s in range(self.scatterers.number_of_types):
      self.scatterers.unsorted_counts.append( uniqueix.count(s) )
      self.scatterers.sorted_ranges.append([0,0])
    for s in range(self.scatterers.number_of_types):
      self.scatterers.sorted_ranges[self.scatterers.increasing_order[s]][1]=\
        self.scatterers.sorted_ranges[self.scatterers.increasing_order[s]][0]+\
        self.scatterers.unsorted_counts[s]
      if s+1 < self.scatterers.number_of_types:
        self.scatterers.sorted_ranges[self.scatterers.increasing_order[s+1]][0]=\
        self.scatterers.sorted_ranges[self.scatterers.increasing_order[s]][1]

    if verbose:
      print(list(self.scatterers.increasing_order))
      print(self.scatterers.number_of_types)
      print(self.scatterers.unsorted_counts)
      print(self.scatterers.sorted_ranges)

    uniqueix_sort_order = flex.sort_permutation(uniqueix)
    sorted_uniqueix = uniqueix.select(uniqueix_sort_order
      ).as_numpy_array().astype(algorithm.numpy.uint32)

    # Scattering sites
    sites = self.scatterers.extract_sites()
    n_sites = sites.size()
    sorted_flat_sites = sites.select(uniqueix_sort_order).as_double().as_numpy_array().astype(algorithm.numpy_t)
    #print sorted_flat_sites.dtype,sorted_flat_sites.shape

    # weights: weight = site_multiplicity * occupancy
    # for example, an atom on a three-fold has site_multiplicity 1/3
    sorted_weights = flex.double([S.weight() for S in self.scatterers]).select(
      uniqueix_sort_order).as_numpy_array().astype(algorithm.numpy_t)

    sorted_u_iso = self.scatterers.extract_u_iso().select(
      uniqueix_sort_order).as_numpy_array().astype(algorithm.numpy_t)

    if n_sites%FHKL_BLOCKSIZE > 0:
      newsize = FHKL_BLOCKSIZE* (1+(n_sites//FHKL_BLOCKSIZE))
      if verbose:
        print("Scatterer xyzs: resetting %s array from size %d to %d"%(
              sorted_flat_sites.dtype,sorted_flat_sites.shape[0],3*newsize))
        print("weights   : resetting %s array from size %d to %d"%(
              sorted_weights.dtype,sorted_weights.shape[0],newsize))
        print()
      sorted_flat_sites.resize(( 3*newsize,))
      # zero-padding for weights guarantees no effect from padded sites
      sorted_weights.resize(( newsize,))
      sorted_u_iso.resize(( newsize,))
      sorted_uniqueix.resize((newsize,))

    self.n_sites = n_sites
    self.flat_sites = sorted_flat_sites
    self.weights = sorted_weights
    self.u_iso = sorted_u_iso
    self.uniqueix = sorted_uniqueix

  def prepare_gaussians_symmetries_cell(self,algorithm):
    # Marshal the scattering types, form factors, symmetry elements,
    # and metrical matrix into numpy arrays for use in CUDA.

    # Gaussian expansion for the unique scattering types
    gaussians = flex.double()

    self.n_gaussians = 0
    self.n_terms_in_sum = 0
    for gaussian in self.registry.unique_gaussians_as_list():
      self.n_gaussians += 1
      #constant_term
      gaussians.append(gaussian.c())
      #non-constant terms in sum
      terms = gaussian.parameters()
      if self.n_terms_in_sum != 0:
        assert len(terms) == 2 * self.n_terms_in_sum
        assert len(terms) % 2 == 0
      self.n_terms_in_sum = len(terms)//2
      for item in terms:
        gaussians.append(item)

    self.gaussians = gaussians.as_numpy_array().astype(algorithm.numpy_t)
    self.g_stride = 1 + 2 *self.n_terms_in_sum
    assert self.gaussians.shape[0] == self.n_gaussians * self.g_stride

    # Space group symmetry
    self.order_z = self.space_group.order_z() # Total No. Symmetry Operators
    self.order_p = self.space_group.order_p() # No. Symops / No. Centring Vectors

    self.sym_stride = 12 # numbers to uniquely specify the symop
    symmetry = flex.double()

    for symop in self.space_group:
      for item in symop.r().as_double():  symmetry.append(item)
      for item in symop.t().as_double():  symmetry.append(item)
    self.symmetry = symmetry.as_numpy_array().astype(algorithm.numpy_t)
    assert self.symmetry.shape[0] == self.order_z * self.sym_stride

    # Unit cell dimensions --> metrical matrix --> establishes dstar for given hkl
    self.reciprocal_metrical_matrix = algorithm.numpy.array(
      self.unit_cell.reciprocal_metrical_matrix() ).astype(algorithm.numpy_t)

  def validate_the_inputs(self,manager,cuda,algorithm):

    # Assess limits due to the current implementation:
    # no support for ADP's, f' or f"

    PyNX_implementation = "Fhkl = Sum(atoms) (weight * exp(2*pi*i(H*X)))"
    # reference http://pynx.sourceforge.net (http://arxiv.org/abs/1010.2641v1)

    Present_implementation = """Fhkl = Sum(atoms(X)) (f0(d*) * weight *
        Sum(symops(SR,ST)) exp(2*pi*i(H*SR*X+H*ST) + DW-factor)
      )"""

    Future_implementation = """Fhkl = Sum(atoms(X)) ((f0(d*)+f'+i*f") * weight *
        Sum(symops(SR,ST)) exp(2*pi*i(H*SR*X+H*ST) + DW-factor)
      )"""
    try:
      assert len(self.miller_indices) > 0
    except Exception:
      raise Sorry("There must be at least one Miller index")

    self.use_debye_waller = (
      self.scatterers.extract_u_iso().count(0.0)<len(self.scatterers) )

    try:
      assert self.scatterers.extract_use_u_aniso().count(True)==0
    except Exception:
      raise Sorry("As presently implemented parallel processor direct summation doesn't support anisotropic displacement factors")

    try:
      assert [S.fp for S in self.scatterers].count(0.0)==len(self.scatterers)
      assert [S.fdp for S in self.scatterers].count(0.0)==len(self.scatterers)
    except Exception:
      raise Sorry("As presently implemented parallel processor direct summation doesn't support anomalous scatterers")

    # Assess limits based on CUDA compute capability: require double precision
    try:
      cc = cuda.Device(0).compute_capability() ; assert cc >= (1,3)
    except Exception:
      raise Sorry("Implementation assumes CUDA compute capability >= 1.3; found %d.%d"%cc)

    # float precision failed on Tesla C1060 test with compute capability 1.3.
    # Alignment problem copying from global to __shared__?
    try:
      if algorithm.float_t=="float":
        assert cc >= (2,0)
    except Exception:
      raise Sorry("Float32 kernel tests correctly only with CUDA compute capability >= 2.0; found %d.%d"%cc)

    # Assess limits based on global memory size of parallel unit
    n_atoms = len(self.scatterers)
    if n_atoms%FHKL_BLOCKSIZE > 0:
       n_atoms = FHKL_BLOCKSIZE* (1+(n_atoms//FHKL_BLOCKSIZE))
    n_hkl = len(self.miller_indices)
    if n_hkl%FHKL_BLOCKSIZE > 0:
       n_hkl = FHKL_BLOCKSIZE* (1+(n_hkl//FHKL_BLOCKSIZE))
    global_memory_atoms = 36 * n_atoms # refers to mod_fhkl_str CUDA code
    global_memory_hkl = 40 * n_hkl # refers to mod_fhkl_str CUDA code

    totalmem = cuda.Device(0).total_memory()
    if 1.2*(global_memory_atoms + global_memory_hkl) > totalmem:
      raise Sorry("Atoms use %d bytes; hkl indices use %d bytes, exceeding total GPU memory %d."%(
        global_memory_atoms,global_memory_hkl,totalmem))

    # Assess limit based on total available threads
    totalthreads = cuda.Device(0).get_attribute(
                     cuda.device_attribute.MAX_BLOCK_DIM_X) * \
                   cuda.Device(0).get_attribute(
                     cuda.device_attribute.MAX_GRID_DIM_X)
    if n_hkl > totalthreads:
      raise Sorry("""%d reflection values will exceed the maximum number of
        threads for a single kernel invocation, %d"""%(
         n_hkl,totalthreads))

  def __init__(self,instance,algorithm,verbose=False):
    """Initializes a direct parallel worker

    :param instance: an instance of class from_scatterers_direct(\
cctbx.xray.structure_factors.manager.managed_calculation_base)
    :type instance: cctbx.xray.structure_factors.from_scatterers_direct
    :param algorithm: an instance of class direct_summation_cuda_platform(\
direct_summation_simple) with algorithm set to "simple" or "pycuda"
    :type algorithm: cctbx.xray.structure_factors.direct_summation_cuda_platform
    """
    self.scatterers = instance._xray_structure.scatterers()
    self.registry = instance._xray_structure.scattering_type_registry()
    self.miller_indices = instance._miller_set.indices()
    self.unit_cell = instance._miller_set.unit_cell()
    self.space_group = instance._miller_set.space_group().make_tidy()

    if verbose: self.print_diagnostics() # some diagnostics used for development

    if hasattr(algorithm,"simple"):
      instance._results = ext.structure_factors_simple(
      self.unit_cell,
      instance._miller_set.space_group(),
      self.miller_indices,
      self.scatterers,
      self.registry); return

    if hasattr(algorithm,"pycuda"):
      import pycuda.driver as cuda
      from pycuda.compiler import SourceModule

      self.validate_the_inputs(instance,cuda,algorithm)

      self.prepare_miller_arrays_for_cuda(algorithm)

      self.prepare_scattering_sites_for_cuda(algorithm)

      self.prepare_gaussians_symmetries_cell(algorithm)

      assert cuda.Device.count() >= 1

      device = cuda.Device(0)
      WARPSIZE=device.get_attribute(cuda.device_attribute.WARP_SIZE) # 32
      MULTIPROCESSOR_COUNT=device.get_attribute(cuda.device_attribute.MULTIPROCESSOR_COUNT)

      sort_mod = SourceModule((mod_fhkl_sorted%(self.gaussians.shape[0],
                         self.symmetry.shape[0],
                         self.sym_stride,
                         self.g_stride,
                         int(self.use_debye_waller),
                         self.order_z,self.order_p)).replace("floating_point_t",algorithm.float_t)
                         )

      r_m_m_address = sort_mod.get_global("reciprocal_metrical_matrix")[0]
      cuda.memcpy_htod(r_m_m_address, self.reciprocal_metrical_matrix)

      gaussian_address = sort_mod.get_global("gaussians")[0]
      cuda.memcpy_htod(gaussian_address, self.gaussians)

      symmetry_address = sort_mod.get_global("symmetry")[0]
      cuda.memcpy_htod(symmetry_address, self.symmetry)

      CUDA_fhkl = sort_mod.get_function("CUDA_fhkl")

      intermediate_real = algorithm.numpy.zeros((self.n_flat_hkl,),algorithm.numpy_t)
      intermediate_imag = algorithm.numpy.zeros((self.n_flat_hkl,),algorithm.numpy_t)
      for x in range(self.scatterers.number_of_types):
        fhkl_real = algorithm.numpy.zeros((self.n_flat_hkl,),algorithm.numpy_t)
        fhkl_imag = algorithm.numpy.zeros((self.n_flat_hkl,),algorithm.numpy_t)

        CUDA_fhkl(cuda.InOut(fhkl_real),
                 cuda.InOut(fhkl_imag),
                 cuda.In(self.flat_sites),
                 cuda.In(self.weights),
                 cuda.In(self.u_iso),
                 algorithm.numpy.uint32(self.scatterers.increasing_order[x]),
                 algorithm.numpy.uint32(self.scatterers.sorted_ranges[x][0]),
                 algorithm.numpy.uint32(self.scatterers.sorted_ranges[x][1]),
                 cuda.In(self.flat_mix),
                 block=(FHKL_BLOCKSIZE,1,1),
                 grid=((self.n_flat_hkl//FHKL_BLOCKSIZE,1)))

        intermediate_real += fhkl_real
        intermediate_imag += fhkl_imag

      flex_fhkl_real = flex.double(intermediate_real[0:len(self.miller_indices)].astype(algorithm.numpy.float64))
      flex_fhkl_imag = flex.double(intermediate_imag[0:len(self.miller_indices)].astype(algorithm.numpy.float64))

      instance._results = fcalc_container(flex.complex_double(flex_fhkl_real,flex_fhkl_imag))

      return

FHKL_BLOCKSIZE=32
mod_fhkl_sorted ="""
__device__ __constant__ floating_point_t reciprocal_metrical_matrix[6];
__device__ __constant__ floating_point_t gaussians[%%d];
__device__ __constant__ floating_point_t symmetry[%%d];

__device__ floating_point_t get_d_star_sq(floating_point_t const& H,floating_point_t const& K,floating_point_t const& L){
   return
            (H * H) * reciprocal_metrical_matrix[0]
          + (K * K) * reciprocal_metrical_matrix[1]
          + (L * L) * reciprocal_metrical_matrix[2]
          + (2 * H * K) * reciprocal_metrical_matrix[3]
          + (2 * H * L) * reciprocal_metrical_matrix[4]
          + (2 * K * L) * reciprocal_metrical_matrix[5];
}

# define SYM_STRIDE %%d

__device__ floating_point_t get_H_dot_translation(
                              floating_point_t const& H,floating_point_t const& K,floating_point_t const& L,
                              unsigned int const & isym){
  // case for primitive cells: return 0
  // but in general,
     return H * (symmetry[SYM_STRIDE*isym+9])
          + K * (symmetry[SYM_STRIDE*isym+10])
          + L * (symmetry[SYM_STRIDE*isym+11])
    ;
}

__device__ floating_point_t get_H_dot_X(floating_point_t* const& site, unsigned int const& i,
                              floating_point_t const& H,floating_point_t const& K,floating_point_t const& L,
                              unsigned int const & isym){
  // case for space group P1
  // return H * site[0] + K * site[1] + L * site[2];

  // but in general,
     return site[3*i+0] * (H * symmetry[SYM_STRIDE*isym]+
                       K * symmetry[SYM_STRIDE*isym+3]+
                       L * symmetry[SYM_STRIDE*isym+6])
          + site[3*i+1] * (H * symmetry[SYM_STRIDE*isym+1]+
                       K * symmetry[SYM_STRIDE*isym+4]+
                       L * symmetry[SYM_STRIDE*isym+7])
          + site[3*i+2] * (H * symmetry[SYM_STRIDE*isym+2]+
                       K * symmetry[SYM_STRIDE*isym+5]+
                       L * symmetry[SYM_STRIDE*isym+8])
          + H * symmetry[SYM_STRIDE*isym+9]
          + K * symmetry[SYM_STRIDE*isym+10]
          + L * symmetry[SYM_STRIDE*isym+11]
    ;
}

__global__ void CUDA_fhkl(floating_point_t *fhkl_real,floating_point_t *fhkl_imag,
                        const floating_point_t *xyzsites, const floating_point_t *weight,
                        const floating_point_t *u_iso,
                        const unsigned int scattering_type,
                        const unsigned int index_begin,
                        const unsigned int index_end,
                        const floating_point_t *hkl)
{
   #define BLOCKSIZE %d
   #define G_STRIDE %%d
   #define USE_DEBYE_WALLER %%d
   #define ORDER_Z %%d
   #define ORDER_P %%d
   #define ORDER_T ORDER_Z/ORDER_P

   const unsigned long ix=threadIdx.x+blockDim.x*blockIdx.x;

   /*later figure out how to make this shared*/
   const floating_point_t twopi= 8.* atan(1.);
   #if USE_DEBYE_WALLER
     const floating_point_t eight_pi_sq = 2.* twopi * twopi;
     __shared__ floating_point_t b_iso[BLOCKSIZE];
   #endif
   /* can the threads coalesce with a stride of 3? Make into __shared__ and See Programming Guide Fig. G-2 */
   const floating_point_t h = hkl[3*ix];
   const floating_point_t k = hkl[3*ix+1];
   const floating_point_t l = hkl[3*ix+2];
   floating_point_t fr=0,fi=0;

   __shared__ floating_point_t xyz[3*BLOCKSIZE];
   __shared__ floating_point_t wght[BLOCKSIZE];

   long atom_p = BLOCKSIZE*index_begin/BLOCKSIZE;
   floating_point_t x_sq = get_d_star_sq(h,k,l) / 4.;

   /* get unique form factors at d_star_sq.
      all scatterers are the same for any particular kernel invocation; hence only one form factor
    */
   floating_point_t form_factor = gaussians[G_STRIDE*scattering_type];// constant term
   for (unsigned int term=1; term < G_STRIDE; term+=2){
     form_factor += gaussians[G_STRIDE*scattering_type + term] *
                    exp(-gaussians[G_STRIDE*scattering_type + term + 1] * x_sq);
   }

   for ( ;atom_p<index_end; atom_p+=BLOCKSIZE ) {
      xyz[threadIdx.x]=xyzsites[3*atom_p+threadIdx.x];
      xyz[BLOCKSIZE+threadIdx.x]=xyzsites[3*atom_p+threadIdx.x+BLOCKSIZE];
      xyz[2*BLOCKSIZE+threadIdx.x]=xyzsites[3*atom_p+threadIdx.x+2*BLOCKSIZE];
      wght[threadIdx.x]=weight[atom_p+threadIdx.x];
      #if USE_DEBYE_WALLER
        b_iso[threadIdx.x] = eight_pi_sq * u_iso[atom_p+threadIdx.x];
      #endif
      __syncthreads();

      for(unsigned int i=0;i<BLOCKSIZE;i++) {
        floating_point_t form_factor_mask = form_factor;
        floating_point_t debye_waller_factor = 1.;
        #if USE_DEBYE_WALLER
          debye_waller_factor *= exp( -b_iso[i] * x_sq );
        #endif

        floating_point_t s,c,s_imag=0.,c_real=0.;
        for(unsigned int isym=0; isym < ORDER_P; isym++){
          /*do not use the faster, but less accurate intrinsic function.*/
          sincos(twopi* get_H_dot_X( xyz, i, h, k, l, isym), &s,&c);
          c_real += c;
          s_imag += s;
        }
        if (atom_p+i >= index_begin && atom_p+i < index_end) {
          fr += form_factor_mask * wght[i] * c_real * debye_waller_factor;
          fi += form_factor_mask * wght[i] * s_imag * debye_waller_factor;
        }
      }
   }

   //multiply factor from centring translations
   floating_point_t s,c,s_imag_trans=0.,c_real_trans=0.;
   for(unsigned int isym=0; isym < ORDER_Z; isym+=ORDER_P){
     sincos(twopi* get_H_dot_translation( h, k, l, isym), &s,&c);
     c_real_trans += c;
     s_imag_trans += s;
   }

   fhkl_real[ix] += (c_real_trans * fr - s_imag_trans * fi);
   fhkl_imag[ix] += (s_imag_trans * fr + c_real_trans * fi);
}
"""%(FHKL_BLOCKSIZE)

class fcalc_container:
  def __init__(self,fcalc):
    self.fcalc = fcalc
  def f_calc(self): return self.fcalc

class direct_summation_simple:
  use_alt_parallel=True
  def __init__(self):
    self.simple=True
  def __eq__(self,other):
    return other=="direct"

class direct_summation_cuda_platform(direct_summation_simple):
  def __init__(self,float_t="double"):
    self.pycuda=True
    self.float_t = float_t
    self.validate_platform_resources()

  def validate_platform_resources(self):
    try:
      import numpy
      self.numpy = numpy
    except Exception:
      raise Sorry("""Module numpy must be installed for parallel processor direct summation.""")

    assert self.float_t in ["double","float"]
    self.numpy_t = {"double":numpy.float64,"float":numpy.float32}[self.float_t]

    try:
      import pycuda.autoinit # import dependency
    except Exception:
      raise Sorry("""Module pycuda must be installed for parallel processor direct summation.""")


 *******************************************************************************


 *******************************************************************************
cctbx/xray/structure_factors/from_scatterers_fft.py
from __future__ import absolute_import, division, print_function
from cctbx.xray.structure_factors.manager import managed_calculation_base
from cctbx.xray.structure_factors import global_counters
from cctbx.xray import ext
from cctbx import miller
from cctbx import maptbx
from libtbx.utils import user_plus_sys_time
from libtbx import introspection
from libtbx.utils import Sorry

class from_scatterers_fft(managed_calculation_base):

  def __init__(self, manager,
                     xray_structure,
                     miller_set,
                     algorithm="fft"):
    scattering_type_registry = xray_structure.scattering_type_registry()
    if (len(scattering_type_registry.unassigned_types()) > 0):
      self.show_unknown_scatterers(registry = scattering_type_registry)
    time_all = user_plus_sys_time()
    managed_calculation_base.__init__(self,
      manager, xray_structure, miller_set, algorithm="fft")
    assert miller_set.d_min() > manager.d_min() * (1-1e-6)
    manager.setup_fft() # before timing
    time_sampling = user_plus_sys_time()
    sampled_density = ext.sampled_model_density(
      unit_cell=xray_structure.unit_cell(),
      scatterers=xray_structure.scatterers(),
      scattering_type_registry=scattering_type_registry,
      fft_n_real=manager.rfft().n_real(),
      fft_m_real=manager.rfft().m_real(),
      u_base=manager.u_base(),
      wing_cutoff=manager.wing_cutoff(),
      exp_table_one_over_step_size=manager.exp_table_one_over_step_size(),
      force_complex=manager.force_complex(),
      sampled_density_must_be_positive=
        manager.sampled_density_must_be_positive(),
      tolerance_positive_definite=manager.tolerance_positive_definite())
    time_sampling = time_sampling.elapsed()
    time_fft = user_plus_sys_time()
    if (not sampled_density.anomalous_flag()):
      sf_map = manager.rfft().forward(sampled_density.real_map())
      collect_conj = True
    else:
      sf_map = manager.cfft().backward(sampled_density.complex_map())
      collect_conj = False
    time_fft = time_fft.elapsed()
    time_from_map = user_plus_sys_time()
    self._f_calc_data = maptbx.structure_factors.from_map(
      space_group=miller_set.space_group(),
      anomalous_flag=sampled_density.anomalous_flag(),
      miller_indices=miller_set.indices(),
      complex_map=sf_map,
      conjugate_flag=collect_conj).data()
    time_from_map = time_from_map.elapsed()
    time_apply_u_extra = user_plus_sys_time()
    sampled_density.eliminate_u_extra_and_normalize(
      miller_set.indices(),
      self._f_calc_data)
    time_apply_u_extra = time_apply_u_extra.elapsed()
    introspection.virtual_memory_info().update_max()
    manager.estimate_time_fft.register(
      n_scatterers=xray_structure.scatterers().size(),
      n_miller_indices=miller_set.indices().size(),
      time_sampling=time_sampling,
      time_fft=time_fft,
      time_from_or_to_map=time_from_map,
      time_apply_u_extra=time_apply_u_extra)
    global_counters.from_scatterers_fft.process(time_all.elapsed())

  def f_calc(self):
    return miller.array(self.miller_set(), self._f_calc_data)

  def show_unknown_scatterers(self, registry):
    msg = """The model contains atoms which are not in the scattering table "%s".
    Unknown atom types:
    %s \n
    To overcome this problem:
    - Double-check the scattering table
    - Double-check the atom type (typo, charge, etc.)
    - Let us know if none of the above applies (help@phenix-online.org).
    """ % (registry.last_table(), ' '.join(str(x) for x in list(registry.unassigned_types())))
    raise Sorry(msg)



 *******************************************************************************


 *******************************************************************************
cctbx/xray/structure_factors/global_counters.py
from __future__ import absolute_import, division, print_function
import sys
from six.moves import zip

items = [
  "from_scatterers_direct",
  "from_scatterers_fft",
  "gradients_direct",
  "gradients_fft"]

class calls_and_accumulated_time(object):

  def __init__(self):
    self.calls = 0
    self.time = 0

  def process(self, time):
    self.calls += 1
    self.time += time

for item in items:
  exec("%s = calls_and_accumulated_time()" % item)
del item

def show(out=None, prefix="", show_zero_calls=False):
  if (out is None): out = sys.stdout
  g = globals()
  calls = ["%d" % c for c in [g[item].calls for item in items]]
  times = ["%.2f" % t for t in [g[item].time for item in items]]
  fmt = "%%-23s %%%ds calls, %%%ds s" % (
    max([len(s) for s in calls]),
    max([len(s) for s in times]))
  for i,c,t in zip(items, calls, times):
    if (not show_zero_calls and c == "0"): continue
    print(prefix + (fmt % (i+":", c, t)).replace(
      " 1 calls,", " 1 call, "), file=out)


 *******************************************************************************


 *******************************************************************************
cctbx/xray/structure_factors/gradient_flags.py
from __future__ import absolute_import, division, print_function
from cctbx.xray import ext
import boost_adaptbx.boost.python as bp
import sys

class gradient_flags(ext.gradient_flags):

  def __init__(self, site=None,
                     u_iso=None,
                     u_aniso=None,
                     occupancy=None,
                     fp=None,
                     fdp=None,
                     u=None,
                     sqrt_u_iso=False,
                     tan_b_iso_max=False,
                     default=False):
    if (u is not None): assert u_iso is None and u_aniso is None
    if (u is None): u = default
    if (site is None): site = default
    if (u_iso is None): u_iso = u
    if (u_aniso is None): u_aniso = u
    if (occupancy is None): occupancy = default
    if (fp is None): fp = default
    if (fdp is None): fdp = default
    ext.gradient_flags.__init__(self,
      site, u_iso, u_aniso, occupancy, fp, fdp, sqrt_u_iso, tan_b_iso_max)

@bp.inject_into(ext.gradient_flags)
class _():

  def copy(self):
    return ext.gradient_flags(self)

  def show_summary(self, f=None):
    if (f is None): f = sys.stdout
    print("gradient_flags:", file=f)
    print("  site:", self.site, file=f)
    print("  u_iso:", self.u_iso, file=f)
    print("  u_aniso:", self.u_aniso, file=f)
    print("  occupancy:", self.occupancy, file=f)
    print("  fp:", self.fp, file=f)
    print("  fdp:", self.fdp, file=f)
    print("  sqrt_u_iso:", self.sqrt_u_iso, file=f)
    print("  tan_b_iso_max:", self.tan_b_iso_max, file=f)

  def string_of_true(self):
    result = []
    if (self.site): result.append("site")
    if (self.u_iso): result.append("u_iso")
    if (self.u_aniso): result.append("u_aniso")
    if (self.occupancy): result.append("occupancy")
    if (self.fp): result.append("fp")
    if (self.fdp): result.append("fdp")
    if (self.sqrt_u_iso): result.append("sqrt_u_iso")
    if (self.tan_b_iso_max): result.append("tan_b_iso_max")
    return ",".join(result)


 *******************************************************************************


 *******************************************************************************
cctbx/xray/structure_factors/gradients.py
from __future__ import absolute_import, division, print_function
from cctbx.xray.structure_factors.manager import manager
from cctbx.xray.structure_factors.gradients_direct \
  import gradients_direct
from cctbx.xray.structure_factors.gradients_fft \
  import gradients_fft

class gradients(manager):
  """ Factory class for structure factor derivatives evaluation """

  def __call__(self, xray_structure,
                     u_iso_refinable_params,
                     miller_set,
                     d_target_d_f_calc,
                     n_parameters,
                     algorithm=None):
    """
    Evaluate structure factors derivatives and return the result

    :Parameters:

      xray_structure : `cctbx.xray.structure`
        the structure to differentiate the structure factors of
      u_iso_refinable_params
        TODO
      miller_set : `cctbx.miller.set`
        the set of miller indices to evaluate the structure factors at
      d_target_d_f_calc : `scitbx.array_family.flex.complex_double`
        the derivative of the target wrt f_calc for each miller index
      n_parameters
        TODO
      algorithm : string
        the name of the evaluation method, either "direct", "fft", or None

      :return:
        an instance of
        `cctbx.xray.structure_factors.gradients_direct` or
        `cctbx.xray.structure_factors.gradients_fft`
        when C{algorithm} is respectively equal to "direct" or "fft",
        or the best suited of the two of them when C{algorithm} is None
      :rtype:
        a type s.t. an instance e provides the evaluated structure factors
        gradients as C{e.packed()}

    """
    assert algorithm in ("direct", "fft", None)
    if (algorithm is None):
      n_scatterers = xray_structure.scatterers().size()
      n_miller_indices = miller_set.indices().size()
      if (not self.have_good_timing_estimates()):
        if (  4*n_scatterers*self.space_group().order_p()*n_miller_indices
            < self.crystal_gridding().n_grid_points()):
          algorithm = "direct"
      else:
        if (   self.estimate_time_direct(n_scatterers * n_miller_indices)
            <= self.estimate_time_fft(n_scatterers, n_miller_indices)):
          algorithm = "direct"
    if (algorithm == "direct"): f = gradients_direct
    else:                       f = gradients_fft
    return f(
      manager=self,
      xray_structure=xray_structure,
      u_iso_refinable_params=u_iso_refinable_params,
      miller_set=miller_set,
      d_target_d_f_calc=d_target_d_f_calc,
      n_parameters=n_parameters)


 *******************************************************************************


 *******************************************************************************
cctbx/xray/structure_factors/gradients_base.py
from __future__ import absolute_import, division, print_function
from cctbx.xray.structure_factors.manager import managed_calculation_base

class gradients_base(managed_calculation_base):

  def d_target_d_f_calc(self):
    return self._d_target_d_f_calc

  def packed(self):
    return self._results.packed()

  def check_size(self, array):
    assert self.packed().size() == 0
    assert array.size() == self.xray_structure().scatterers().size()
    return array

  def d_target_d_u_iso(self):
    return self.check_size(self._results.d_target_d_u_iso())

  def d_target_d_occupancy(self):
    return self.check_size(self._results.d_target_d_occupancy())

  def d_target_d_fp(self):
    return self.check_size(self._results.d_target_d_fp())

  def d_target_d_fdp(self):
    return self.check_size(self._results.d_target_d_fdp())


 *******************************************************************************


 *******************************************************************************
cctbx/xray/structure_factors/gradients_direct.py
from __future__ import absolute_import, division, print_function
from cctbx.xray.structure_factors.gradients_base import gradients_base
from cctbx.xray.structure_factors.manager import default_cos_sin_table
from cctbx.xray.structure_factors.misc import expensive_function_call_message
from cctbx.xray.structure_factors import global_counters
from cctbx.xray import ext
from cctbx import adptbx
from libtbx.utils import user_plus_sys_time

class gradients_direct(gradients_base):

  def __init__(self, xray_structure,
                     u_iso_refinable_params,
                     miller_set,
                     d_target_d_f_calc,
                     n_parameters,
                     manager=None,
                     cos_sin_table=False):
    time_all = user_plus_sys_time()
    gradients_base.__init__(self,
      manager, xray_structure, miller_set, algorithm="direct")
    self._d_target_d_f_calc = d_target_d_f_calc
    timer = user_plus_sys_time()
    if (manager is not None):
      cos_sin_table = manager.cos_sin_table()
    if (cos_sin_table == True):
      cos_sin_table = default_cos_sin_table
    elif (cos_sin_table == False):
      cos_sin_table = None
    if (cos_sin_table is None):
      self._results = ext.structure_factors_gradients_direct(
        self._miller_set.unit_cell(),
        self._miller_set.space_group(),
        self._miller_set.indices(),
        self._xray_structure.scatterers(),
        u_iso_refinable_params,
        self._xray_structure.scattering_type_registry(),
        self._xray_structure.site_symmetry_table(),
        d_target_d_f_calc,
        n_parameters)
    else:
      self._results = ext.structure_factors_gradients_direct(
        cos_sin_table,
        self._miller_set.unit_cell(),
        self._miller_set.space_group(),
        self._miller_set.indices(),
        self._xray_structure.scatterers(),
        u_iso_refinable_params,
        self._xray_structure.scattering_type_registry(),
        self._xray_structure.site_symmetry_table(),
        d_target_d_f_calc,
        n_parameters)
    if (manager is not None):
      manager.estimate_time_direct.register(
        xray_structure.scatterers().size() * miller_set.indices().size(),
        timer.elapsed())
    self.d_target_d_site_cart_was_used = False
    self.d_target_d_u_cart_was_used = False
    global_counters.gradients_direct.process(time_all.elapsed())

  def d_target_d_site_frac(self):
    return self.check_size(self._results.d_target_d_site_frac())

  def d_target_d_site_cart(self):
    if (self.d_target_d_site_cart_was_used):
      raise RuntimeError(expensive_function_call_message)
    self.d_target_d_site_cart_was_used = True
    return self.d_target_d_site_frac() \
         * self.xray_structure().unit_cell().fractionalization_matrix()

  def d_target_d_u_star(self):
    return self.check_size(self._results.d_target_d_u_star())

  def d_target_d_u_cart(self):
    if (self.d_target_d_u_cart_was_used):
      raise RuntimeError(expensive_function_call_message)
    self.d_target_d_u_cart_was_used = True
    return adptbx.grad_u_star_as_u_cart(
      self.xray_structure().unit_cell(), self.d_target_d_u_star())


 *******************************************************************************


 *******************************************************************************
cctbx/xray/structure_factors/gradients_fft.py
from __future__ import absolute_import, division, print_function
from cctbx.xray.structure_factors.gradients_base import gradients_base
from cctbx.xray.structure_factors.misc import expensive_function_call_message
from cctbx.xray.structure_factors import global_counters
from cctbx.xray import ext
from cctbx import maptbx
from cctbx import adptbx
from cctbx.array_family import flex
from scitbx import matrix
from libtbx.utils import user_plus_sys_time
from libtbx import introspection

class gradients_fft(gradients_base):

  def __init__(self, manager,
                     xray_structure,
                     u_iso_refinable_params,
                     miller_set,
                     d_target_d_f_calc,
                     n_parameters):
    time_all = time_apply_u_extra = user_plus_sys_time()
    gradients_base.__init__(self,
      manager, xray_structure, miller_set, algorithm="fft")
    self._d_target_d_f_calc = d_target_d_f_calc
    manager.setup_fft() # before timing
    time_apply_u_extra = user_plus_sys_time()
    self._results = ext.fast_gradients(
      unit_cell=xray_structure.unit_cell(),
      scatterers=xray_structure.scatterers(),
      scattering_type_registry=xray_structure.scattering_type_registry(),
      u_base=manager.u_base(),
      wing_cutoff=manager.wing_cutoff(),
      exp_table_one_over_step_size=manager.exp_table_one_over_step_size(),
      tolerance_positive_definite=manager.tolerance_positive_definite())
    coeff = self._gradient_map_coeff()
    time_apply_u_extra = time_apply_u_extra.elapsed()
    time_from_or_to_map = user_plus_sys_time()
    coeff_map = self._gradient_map_coeff_to_map(coeff)
    time_from_or_to_map = time_from_or_to_map.elapsed()
    time_fft = user_plus_sys_time()
    if (not coeff.anomalous_flag()):
      gradient_map = manager.rfft().backward(coeff_map.complex_map())
    else:
      gradient_map = manager.cfft().backward(coeff_map.complex_map())
    time_fft = time_fft.elapsed()
    time_sampling = user_plus_sys_time()
    self._results.sampling(
      scatterers=xray_structure.scatterers(),
      u_iso_refinable_params=u_iso_refinable_params,
      scattering_type_registry=xray_structure.scattering_type_registry(),
      site_symmetry_table=xray_structure.site_symmetry_table(),
      ft_d_target_d_f_calc=gradient_map,
      n_parameters=n_parameters,
      sampled_density_must_be_positive=
        manager.sampled_density_must_be_positive())
    time_sampling = time_sampling.elapsed()
    introspection.virtual_memory_info().update_max()
    manager.estimate_time_fft.register(
      n_scatterers=xray_structure.scatterers().size(),
      n_miller_indices=miller_set.indices().size(),
      time_sampling=time_sampling,
      time_fft=time_fft,
      time_from_or_to_map=time_from_or_to_map,
      time_apply_u_extra=time_apply_u_extra)
    self.d_target_d_site_frac_was_used = False
    self.d_target_d_u_star_was_used = False
    global_counters.gradients_fft.process(time_all.elapsed())

  def _gradient_map_coeff(self):
    coeff = self.miller_set().array(data=self.d_target_d_f_calc().deep_copy())
    multiplier = (  self.manager().unit_cell().volume()
                  / matrix.row(self.manager().rfft().n_real()).product()
                  * self.manager().space_group().n_ltr())
    if (    not coeff.anomalous_flag()
        and not coeff.space_group().is_centric()):
      multiplier /= 2
    ext.apply_u_extra(
      self.manager().unit_cell(),
      self._results.u_extra(),
      coeff.indices(),
      coeff.data(),
      multiplier)
    return coeff

  def _gradient_map_coeff_to_map(self, coeff):
    if (not coeff.anomalous_flag()):
      n_complex = self.manager().rfft().n_complex()
    else:
      n_complex = self.manager().rfft().n_real()
    return maptbx.structure_factors.to_map(
      space_group=coeff.space_group(),
      anomalous_flag=coeff.anomalous_flag(),
      miller_indices=coeff.indices(),
      structure_factors=coeff.data(),
      n_real=self.manager().rfft().n_real(),
      map_grid=flex.grid(n_complex),
      conjugate_flag=True,
      treat_restricted=False)

  def d_target_d_site_cart(self):
    return self.check_size(self._results.d_target_d_site_cart())

  def d_target_d_site_frac(self):
    if (self.d_target_d_site_frac_was_used):
      raise RuntimeError(expensive_function_call_message)
    self.d_target_d_site_frac_was_used = True
    return self.d_target_d_site_cart() \
         * self.xray_structure().unit_cell().orthogonalization_matrix()

  def d_target_d_u_cart(self):
    return self.check_size(self._results.d_target_d_u_cart())

  def d_target_d_u_star(self):
    if (self.d_target_d_u_star_was_used):
      raise RuntimeError(expensive_function_call_message)
    self.d_target_d_u_star_was_used = True
    return adptbx.grad_u_cart_as_u_star(
      self.xray_structure().unit_cell(), self.d_target_d_u_cart())


 *******************************************************************************


 *******************************************************************************
cctbx/xray/structure_factors/manager.py
from __future__ import absolute_import, division, print_function
from cctbx.xray.structure_factors.misc import quality_factor_from_any
from cctbx.xray import ext
from cctbx import maptbx
from cctbx import crystal
from cctbx import math_module
from scitbx import fftpack
from libtbx import adopt_init_args

default_cos_sin_table = math_module.cos_sin_table(2**10)

class manager(crystal.symmetry):

  def __init__(self, miller_set=None,
                     crystal_symmetry=None,
                     d_min=None,
                     cos_sin_table=False,
                     grid_resolution_factor=1/3.,
                     symmetry_flags=None,
                     mandatory_grid_factors=None,
                     quality_factor=None, u_base=None, b_base=None,
                     wing_cutoff=None,
                     exp_table_one_over_step_size=None,
                     max_prime=5,
                     force_complex=False,
                     sampled_density_must_be_positive=False,
                     tolerance_positive_definite=1.e-5):
    assert miller_set is None or crystal_symmetry is None
    if (miller_set is None):
      assert crystal_symmetry is not None and d_min is not None
    else:
      crystal_symmetry = miller_set
      if (d_min is None):
        d_min = miller_set.d_min()
      else:
        assert d_min < miller_set.d_min() * (1+1e-6)
    #
    # Defaults above don't work for ultra-low resolutions (~10-50A and lower).
    # Customization below makes it work for d_min>10.
    # For details, see cctbx/regression/tst_sf_low_res_accuracy.py
    #
    sc=None
    if(d_min>=5 and d_min<10): sc=2
    elif(d_min>=10):           sc=3
    if(sc is not None and
       abs(grid_resolution_factor-1/3.)<1.e-3 and
       wing_cutoff is None and
       quality_factor is None):
     quality_factor = 1000
     wing_cutoff = 1.e-4
     grid_resolution_factor = sc/d_min
    #
    crystal.symmetry._copy_constructor(self, crystal_symmetry)
    quality_factor = quality_factor_from_any(
      d_min, grid_resolution_factor, quality_factor, u_base, b_base)
    if (wing_cutoff is None):
      wing_cutoff = 1.e-3
    if (exp_table_one_over_step_size is None):
      exp_table_one_over_step_size = -100
    del miller_set
    adopt_init_args(self, locals(), hide=True)
    self._crystal_gridding = None
    self._rfft = None
    self._cfft = None
    self._u_base = None
    self.estimate_time_direct = _estimate_time_direct(
      self.space_group().order_z())
    self.estimate_time_fft = _estimate_time_fft()

  def d_min(self):
    return self._d_min

  def cos_sin_table(self):
    return self._cos_sin_table

  def grid_resolution_factor(self):
    return self._grid_resolution_factor

  def symmetry_flags(self):
    return self._symmetry_flags

  def mandatory_grid_factors(self):
    return self._mandatory_grid_factors

  def quality_factor(self):
    return self._quality_factor

  def wing_cutoff(self):
    return self._wing_cutoff

  def exp_table_one_over_step_size(self):
    return self._exp_table_one_over_step_size

  def max_prime(self):
    return self._max_prime

  def force_complex(self):
    return self._force_complex

  def sampled_density_must_be_positive(self):
    return self._sampled_density_must_be_positive

  def tolerance_positive_definite(self):
    return self._tolerance_positive_definite

  def crystal_gridding(self, assert_shannon_sampling=True):
    if (self._crystal_gridding is None):
      self._crystal_gridding = maptbx.crystal_gridding(
        unit_cell=self.unit_cell(),
        d_min=self.d_min(),
        resolution_factor=self.grid_resolution_factor(),
        symmetry_flags=self.symmetry_flags(),
        space_group_info=self.space_group_info(),
        mandatory_factors=self.mandatory_grid_factors(),
        max_prime=self.max_prime(),
        assert_shannon_sampling=assert_shannon_sampling)
    return self._crystal_gridding

  def rfft(self):
    if (self._rfft is None):
      self._rfft = fftpack.real_to_complex_3d(
        self.crystal_gridding().n_real())
    return self._rfft

  def cfft(self):
    if (self._cfft is None):
      self._cfft = fftpack.complex_to_complex_3d(
        self.crystal_gridding().n_real())
    return self._cfft

  def u_base(self):
    if (self._u_base is None):
      self._u_base = ext.calc_u_base(
        self.d_min(),
        self.grid_resolution_factor(),
        self.quality_factor())
    return self._u_base

  def setup_fft(self):
    self.rfft()
    self.cfft()
    self.u_base()
    return self

  def have_good_timing_estimates(self):
    return self.estimate_time_direct.have_good_estimate() \
       and self.estimate_time_fft.have_good_estimate()

class _estimate_time_direct(object):

  def __init__(self, order_z, min_product=100000):
    self.order_z = order_z
    self.min_product = min_product
    self.product = 1
    self.time = 0

  def have_good_estimate(self):
    return self.product > self.min_product / float(self.order_z)

  def register(self, product, time):
    if (product >= self.product):
      self.product = product
      self.time = time

  def __call__(self, product):
    return self.time * product / self.product

def _linear_estimate(x1, x2, y1, y2, x):
  if (y1 == y2): return y1
  if (x1 == x2): return max(y1,y2) * x1 / x
  slope = (y2 - y1) / (x2 - x1)
  if   (x1 == 0): y_intercept = y1
  elif (x2 == 0): y_intercept = y2
  else: y_intercept = y1 - (slope * x1)
  return slope * x + y_intercept

class _estimate_time_fft(object):

  def __init__(self):
    self.min_n_scatterers = 0
    self.max_n_scatterers = 0
    self.min_n_miller_indices = 0
    self.max_n_miller_indices = 0
    self.min_time_sampling = 0
    self.max_time_sampling = 0
    self.min_time_from_or_to_map = 0
    self.max_time_from_or_to_map = 0
    self.min_time_apply_u_extra = 0
    self.max_time_apply_u_extra = 0
    self.time_sampling = 0
    self.time_fft = 0
    self.time_from_or_to_map = 0
    self.time_apply_u_extra = 0

  def have_good_estimate(self):
    return self.time_fft > 0

  def register(self, n_scatterers,
                     n_miller_indices,
                     time_sampling,
                     time_fft,
                     time_from_or_to_map,
                     time_apply_u_extra):
    if (   self.min_n_scatterers == 0
        or self.min_n_scatterers >= n_scatterers):
      self.min_n_scatterers = n_scatterers
      self.min_time_sampling = time_sampling
    if (self.max_n_scatterers <= n_scatterers):
      self.max_n_scatterers = n_scatterers
      self.max_time_sampling = time_sampling
    if (   self.min_n_miller_indices == 0
        or self.min_n_miller_indices >= n_miller_indices):
      self.min_n_miller_indices = n_miller_indices
      self.min_time_from_or_to_map = time_from_or_to_map
      self.min_time_apply_u_extra = time_apply_u_extra
    if (self.max_n_miller_indices <= n_miller_indices):
      self.max_n_miller_indices = n_miller_indices
      self.max_time_from_or_to_map = time_from_or_to_map
      self.max_time_apply_u_extra = time_apply_u_extra
    self.time_sampling = time_sampling
    self.time_fft = time_fft
    self.time_from_or_to_map = time_from_or_to_map
    self.time_apply_u_extra = time_apply_u_extra

  def __call__(self, n_scatterers, n_miller_indices):
    return _linear_estimate(
             self.min_n_scatterers, self.max_n_scatterers,
             self.min_time_sampling, self.max_time_sampling,
             n_scatterers) \
         + self.time_fft \
         + _linear_estimate(
             self.min_n_miller_indices,
             self.max_n_miller_indices,
             self.min_time_from_or_to_map,
             self.max_time_from_or_to_map,
             n_miller_indices) \
         + _linear_estimate(
             self.min_n_miller_indices,
             self.max_n_miller_indices,
             self.min_time_apply_u_extra,
             self.max_time_apply_u_extra,
             n_miller_indices)

class managed_calculation_base(object):

  def __init__(self, manager, xray_structure, miller_set, algorithm):
    adopt_init_args(self, locals(), hide=True)
    assert xray_structure is not None and miller_set is not None
    assert xray_structure.unit_cell().is_similar_to(miller_set.unit_cell())
    assert xray_structure.space_group() == miller_set.space_group()
    if (manager is not None):
      assert xray_structure.unit_cell().is_similar_to(manager.unit_cell())
      assert xray_structure.space_group() == manager.space_group()
    assert algorithm in ["direct", "fft"]

  def manager(self):
    return self._manager

  def xray_structure(self):
    return self._xray_structure

  def miller_set(self):
    return self._miller_set

  def algorithm(self, verbose=False):
    if (not verbose):
      return self._algorithm
    if (self._algorithm == "direct"):
      return "Direct Summation"
    return "FFT Approximation"


 *******************************************************************************


 *******************************************************************************
cctbx/xray/structure_factors/misc.py
from __future__ import absolute_import, division, print_function
from cctbx import adptbx

def quality_factor_from_any(d_min=None,
                            grid_resolution_factor=None,
                            quality_factor=None,
                            u_base=None,
                            b_base=None):
  assert [quality_factor, u_base, b_base].count(None) >= 2
  if (u_base is not None):
    b_base = adptbx.u_as_b(u_base)
  if (b_base is not None):
    assert [d_min, grid_resolution_factor].count(None) == 0
    assert d_min > 0
    sigma = 1 / (2. * grid_resolution_factor)
    log_quality_factor = b_base * sigma * (sigma - 1) / (d_min * d_min)
    quality_factor = 10**log_quality_factor
  elif (quality_factor is None):
    quality_factor = 100
  return quality_factor

expensive_function_call_message = (
    "Programming problem: Calling this function is expensive."
  + " Please assign the result to an intermediate variable.")



 *******************************************************************************


 *******************************************************************************
cctbx/xray/target_functors.py
from __future__ import absolute_import, division, print_function
from cctbx.xray import ext
from cctbx.xray import weighting_schemes
from cctbx import miller
from cctbx.array_family import flex
from libtbx import adopt_init_args

class least_squares(object):

  def __init__(self,
        compute_scale_using_all_data,
        f_obs,
        weights,
        r_free_flags,
        scale_factor):
    assert scale_factor >= 0
    adopt_init_args(self, locals())

  def __call__(self, f_calc, compute_gradients):
    assert f_calc.unit_cell().is_similar_to(self.f_obs.unit_cell())
    assert f_calc.space_group() == self.f_obs.space_group()
    return ext.targets_least_squares(
      compute_scale_using_all_data=self.compute_scale_using_all_data,
      obs_type="F",
      obs=self.f_obs.data(),
      weights=self.weights,
      r_free_flags=self.r_free_flags.data(),
      f_calc=f_calc.data(),
      derivatives_depth=int(compute_gradients),
      scale_factor=self.scale_factor)

class max_like(object):

  def __init__(self,
        f_obs,
        r_free_flags,
        experimental_phases,
        alpha_beta,
        scale_factor,
        epsilons,
        spacialization,
        integration_step_size=5.0):
    adopt_init_args(self, locals())
    self.centric_flags = f_obs.centric_flags().data()

  def __call__(self, f_calc, compute_gradients):
    assert f_calc.unit_cell().is_similar_to(self.f_obs.unit_cell())
    assert f_calc.space_group() == self.f_obs.space_group()
    if (self.experimental_phases is None):
      if(self.spacialization=="f"):
        return ext.mlf_target_and_gradients(
          f_obs=self.f_obs.data(),
          r_free_flags=self.r_free_flags.data(),
          f_calc=f_calc.data(),
          alpha=self.alpha_beta[0].data(),
          beta=self.alpha_beta[1].data(),
          scale_factor=self.scale_factor,
          epsilons=self.epsilons,
          centric_flags=self.centric_flags,
          compute_gradients=compute_gradients)
      elif(self.spacialization=="i"):
        return ext.mli_target_and_gradients(
          f_obs=self.f_obs.data(),
          r_free_flags=self.r_free_flags.data(),
          f_calc=f_calc.data(),
          alpha=self.alpha_beta[0].data(),
          beta=self.alpha_beta[1].data(),
          scale_factor=self.scale_factor,
          epsilons=self.epsilons,
          centric_flags=self.centric_flags,
          compute_gradients=compute_gradients)
      else: assert 0 # should never get here!
    return ext.mlhl_target_and_gradients(
      f_obs=self.f_obs.data(),
      r_free_flags=self.r_free_flags.data(),
      experimental_phases=self.experimental_phases.data(),
      f_calc=f_calc.data(),
      alpha=self.alpha_beta[0].data(),
      beta=self.alpha_beta[1].data(),
      epsilons=self.epsilons,
      centric_flags=self.centric_flags,
      integration_step_size=self.integration_step_size,
      compute_gradients=compute_gradients)

class unified_least_squares_residual(object):
  """ A least-square residual functor for refinement against F or F^2. """

  def __init__(self, obs,
               is_amplitude=True,
               weighting=None
               ):
    """
    Construct a least-square residuals

    .. |Sigma|  unicode:: U+003A3 .. GREEK CAPITAL LETTER SIGMA

    |Sigma|:sub:`i`  w[i] ( f_obs.data[i] - k abs(f_calc.data[i]) )^2
    /  |Sigma|:sub:`i` w[i] f_obs.data[i]^2

    or

    |Sigma|:sub:`i` w[i] ( f_obs_square.data[i] - k abs(f_calc.data[i])^2 )^2
    /  |Sigma|:sub:`i` w[i] f_obs_square.data[i]^2

    depending on which of f_obs and f_obs_square is not None.

    Note that
      - the sums are over the indices i of the reflections,
      - f_calc is to be passed to the __call__ method,
      - the weights w and the scale factor k are discussed below.

    :Parameters:

      obs : real miller.array
        the observed reflections, with F and sigma(F) (or F^2 and sigma(F^2))
        respectively in obs.data() and obs.sigmas()

      is_amplitude : bool
        a flag to discriminate the type of data in obs if the latter does not
        spell out whether it contains amplitudes or intensities;
        the default means that amplitudes is the default when data type is
        unknown.

      weighting
        a weighting scheme for the data (c.f. cctbx.xray.weighting for common
        ones) or None, which means no weights
    """
    if not(obs.is_xray_amplitude_array() or obs.is_xray_intensity_array()):
      self._obs = miller.array(obs, data=obs.data(), sigmas=obs.sigmas())
      if is_amplitude:
        self._obs.set_observation_type_xray_amplitude()
      else:
        self._obs.set_observation_type_xray_intensity()
    else:
      self._obs = obs
    assert(self._obs.is_xray_amplitude_array()
           or self._obs.is_xray_intensity_array())
    if self.obs().is_xray_amplitude_array():
      self._ext_ls_residual = ext.targets_least_squares_residual
      default_weighting = weighting_schemes.amplitude_unit_weighting()
    elif self.obs().is_xray_intensity_array():
      self._ext_ls_residual = ext.targets_least_squares_residual_for_intensity
      default_weighting = weighting_schemes.intensity_quasi_unit_weighting()
    if weighting is None: weighting = default_weighting
    self._weighting = weighting
    self._weighting.observed = self._obs
    self._scale_factor = None

  def obs(self):
    """ The obs passed to the constructor """
    return self._obs

  f_obs = obs
  """ For compatibility with the optimiser's interface
  (as minimization.lbfgs) """

  def weighting(self):
    """ The weighting scheme """
    return self._weighting

  def __call__(self, f_calc, compute_derivatives, scale_factor=0):
    """
    Compute the least-squares residual value and perhaps its derivatives
    wrt to the calculated structure factor F_c of the i-th reflection

    :Parameters:

      f_calc : complex `cctbx.miller.array`
        f_calc.data()[i] constains F_c for the i-th reflection in f_obs()
      compute_derivatives : bool
        whether to compute the derivatives of the least square residual or not
      scale_factor : number
        the scale factor k if not null,
        otherwise k will be computed as a by-product of calling this method

    :return:
       An object holding the residual value, derivatives and scale factor
    :rtype:
       Boost.Python binding of
       :doxyclass:`cctbx::xray::targets::least_squares_residual`
    """
    assert f_calc.unit_cell().is_similar_to(self.obs().unit_cell())
    assert f_calc.space_group() == self.obs().space_group()
    if self._scale_factor is None:
      self._scale_factor = 0
    else:
      self._scale_factor = scale_factor
    self.weighting().calculated = f_calc
    if scale_factor == 0: scale_factor = None
    if (isinstance(self.weighting(), weighting_schemes.shelx_weighting) or
        isinstance(self.weighting(), weighting_schemes.simple_shelx_weighting)):
      self.weighting().compute(f_calc, scale_factor)
      self._scale_factor = self.weighting().scale_factor
    else:
      self.weighting().compute()
    if (self.weighting().weights is not None):
      result = self._ext_ls_residual(
        self.obs().data(),
        self.weighting().weights,
        f_calc.data(),
        compute_derivatives,
        self._scale_factor)
    else:
      result = self._ext_ls_residual(
        self.obs().data(),
        f_calc.data(),
        compute_derivatives,
        self._scale_factor)
    self._scale_factor = result.scale_factor()
    return result


class least_squares_residual_for_amplitude(unified_least_squares_residual):
  """ A least-square residual functor for F refinement. """

  statistical_weighting = weighting_schemes.pure_statistical_weighting()

  def __init__(self, f_obs, use_sigmas_as_weights = False):
    if use_sigmas_as_weights:
      weighting = self.statistical_weighting
    else:
      weighting = None
    super(least_squares_residual, self).__init__(f_obs, True, weighting)

  def use_sigmas_as_weights(self):
    return isinstance(self._weighting, statistical_weighting)

least_squares_residual = least_squares_residual_for_amplitude


class intensity_correlation(object):

  def __init__(self, f_obs, weights=None,
               use_multiplicities_as_weights=False):
    adopt_init_args(self, locals(), hide=True)
    assert self._weights is None or not self._use_multiplicities_as_weights
    if (self._use_multiplicities_as_weights):
      self._weights = self._f_obs.multiplicities().data().as_double()

  def f_obs(self):
    return self._f_obs

  def weights(self):
    return self._weights

  def use_multiplicities_as_weights(self):
    return self._use_multiplicities_as_weights

  def __call__(self, f_calc, compute_derivatives):
    assert f_calc.is_similar_symmetry(self.f_obs())
    return ext.targets_correlation(
      obs_type="I",
      obs=flex.pow2(self.f_obs().data()),
      weights=self.weights(),
      r_free_flags=None,
      f_calc=f_calc.data(),
      derivatives_depth=int(compute_derivatives))

def registry():
  return {
    "least_squares_residual": least_squares_residual,
    "unified_least_squares_residual": unified_least_squares_residual,
    "intensity_correlation": intensity_correlation,
  }


 *******************************************************************************


 *******************************************************************************
cctbx/xray/targets/__init__.py
from __future__ import absolute_import, division, print_function
class shelxl_wght_ls(object):

  def __init__(O, f_obs, i_obs, i_sig, i_calc=None, f_calc=None, wa=0.1, wb=0):
    assert [i_calc, f_calc].count(None) == 1
    if (i_calc is None):
      from cctbx.array_family import flex
      i_calc = flex.norm(f_calc)
    from cctbx import xray
    raw = xray.targets_shelxl_wght_ls_kwt_b_dv(
      f_obs=f_obs,
      i_obs=i_obs,
      i_sig=i_sig,
      ic=i_calc,
      wa=wa,
      wb=wb)
    assert len(raw) == 5
    O.scale_factor, \
    O.weights, \
    O.target, \
    O.i_gradients, \
    O.i_curvatures = raw
    if (f_calc is None):
      O.f_gradients = None
      O.f_hessians = None
    else:
      g = O.i_gradients
      c = O.i_curvatures
      O.f_gradients = 2 * g * f_calc
      a = flex.real(f_calc)
      b = flex.imag(f_calc)
      aa = 2 * g + 4 * a * a * c
      bb = 2 * g + 4 * b * b * c
      ab =         4 * a * b * c
      O.f_hessians = flex.vec3_double(aa, bb, ab)

  def target_work(O):
    return O.target

  def gradients_work(O):
    return O.f_gradients

  def hessians_work(O):
    return O.f_hessians


 *******************************************************************************


 *******************************************************************************
cctbx/xray/targets/r1.py
from __future__ import absolute_import, division, print_function
def calc_k(fo, fc):
  "scale factor for (fo-k*fc)**2, only similar to factor for abs(fo-k*fc)"
  from scitbx.array_family import flex
  k_num = flex.sum(fo * fc)
  k_den = flex.sum(fc * fc)
  assert k_den != 0
  assert k_den**2 != 0
  k = k_num / k_den
  k_d_num = fo * k_den - k_num * 2 * fc
  k_d = k_d_num / k_den**2
  k_d2 = -2 * (k_num * k_den + 2 * k_d_num * fc) / k_den**3
  return k, k_d, k_d2

def calc_t(fo, fc, k, k_d, k_d2):
  from scitbx.array_family import flex
  deltas = fo - k * fc
  signs = flex.double(fo.size(), 1)
  signs.set_selected(deltas < 0, -1)
  deltas *= signs
  t_num = flex.sum(deltas)
  t_den = flex.sum(fo)
  assert t_den != 0
  t = t_num / t_den
  if (k_d is None):
    return t
  t_d = -(k_d * flex.sum(signs * fc) + signs * k) / t_den
  if (k_d2 is None):
    return t, t_d
  t_d2 = -(k_d2 * flex.sum(signs * fc) + 2 * signs * k_d) / t_den
  return t, t_d, t_d2

class target(object):

  def __init__(O, f_obs, f_calc=None, f_calc_abs=None, fca_sq_eps=1e-100):
    assert [f_calc, f_calc_abs].count(None) == 1
    if (f_calc is not None):
      from scitbx.array_family import flex
      f_calc_abs = flex.abs(f_calc)
    O.k, O.k_d, O.k_d2 = calc_k(f_obs, f_calc_abs)
    O.t, O.g, O.c = calc_t(f_obs, f_calc_abs, O.k, O.k_d, O.k_d2)
    O.f_calc_gradients = None
    O.f_calc_hessians = None
    if (f_calc is not None):
      fca_sq = f_calc_abs**2
      isel_zero = (fca_sq <= fca_sq_eps).iselection()
      f_calc_abs.set_selected(isel_zero, 1)
      fca_sq.set_selected(isel_zero, 1)
      O.f_calc_gradients = O.g / f_calc_abs * f_calc
      O.f_calc_gradients.set_selected(isel_zero, 0j)
      a = flex.real(f_calc)
      b = flex.imag(f_calc)
      aa, bb, ab = a*a, b*b, a*b
      haa = O.c * aa + O.g * bb / f_calc_abs
      hbb = O.c * bb + O.g * aa / f_calc_abs
      hab = (O.c - O.g / f_calc_abs) * a * b
      O.f_calc_hessians = flex.vec3_double(haa, hbb, hab) / fca_sq
      O.f_calc_hessians.set_selected(isel_zero, (0,0,0))

  def target_work(O):
    return O.t

  def gradients_work(O):
    return O.f_calc_gradients

  def hessians_work(O):
    return O.f_calc_hessians


 *******************************************************************************


 *******************************************************************************
cctbx/xray/targets/tst_r1.py
from __future__ import absolute_import, division, print_function
from cctbx.xray.targets import r1
from scitbx.array_family import flex
from libtbx.test_utils import approx_equal
from six.moves import range
from six.moves import zip

def exercise(mt, n_refl, log):
  f_obs = mt.random_double(size=n_refl)
  f_calc = flex.complex_double(
    mt.random_double(size=f_obs.size()),
    mt.random_double(size=f_obs.size()))
  f_calc_abs = flex.abs(f_calc)
  trg = r1.target(f_obs=f_obs, f_calc=f_calc)
  def check_f_calc_abs_derivs():
    eps = 1e-6
    g_fin = flex.double()
    c_fin = flex.double()
    for ih in range(f_calc_abs.size()):
      fs = []
      gs = []
      c_orig = f_calc_abs[ih]
      for signed_eps in [eps, -eps]:
        f_calc_abs[ih] = c_orig + signed_eps
        trg_eps = r1.target(f_obs=f_obs, f_calc_abs=f_calc_abs)
        fs.append(trg_eps.t)
        gs.append(trg_eps.g[ih])
      g_fin.append((fs[0]-fs[1])/(2*eps))
      c_fin.append((gs[0]-gs[1])/(2*eps))
      f_calc_abs[ih] = c_orig
    print("g fin:", numstr(g_fin), file=log)
    print("  ana:", numstr(trg.g), file=log)
    assert approx_equal(trg.g, g_fin)
    print("c fin:", numstr(c_fin), file=log)
    print("  ana:", numstr(trg.c), file=log)
    assert approx_equal(trg.c, c_fin)
  def check_f_calc_derivs():
    eps = 1e-6
    g_fin = flex.complex_double()
    c_fin = flex.vec3_double()
    for ih in range(f_calc.size()):
      c_orig = f_calc[ih]
      g_fin_ab = []
      c_fin_ab = []
      for iab in [0,1]:
        fs = []
        gs = []
        for signed_eps in [eps, -eps]:
          if (iab == 0):
            f_calc[ih] = complex(c_orig.real + signed_eps, c_orig.imag)
          else:
            f_calc[ih] = complex(c_orig.real, c_orig.imag + signed_eps)
          trg_eps = r1.target(f_obs=f_obs, f_calc=f_calc)
          fs.append(trg_eps.t)
          gs.append(trg_eps.f_calc_gradients[ih])
        g_fin_ab.append((fs[0]-fs[1])/(2*eps))
        c_fin_ab.append((gs[0]-gs[1])/(2*eps))
      g_fin.append(complex(*g_fin_ab))
      assert approx_equal(c_fin_ab[0].imag, c_fin_ab[1].real)
      c_fin.append((c_fin_ab[0].real, c_fin_ab[1].imag, c_fin_ab[0].imag))
      f_calc[ih] = c_orig
    for pn,f,a in zip(
          g_fin.part_names(), g_fin.parts(), trg.f_calc_gradients.parts()):
      print("g fin %s:" % pn, numstr(f), file=log)
      print("  ana %s:" % pn, numstr(a), file=log)
    assert approx_equal(trg.f_calc_gradients, g_fin)
    for pn,f,a in zip(
          ["aa", "bb", "ab"], c_fin.parts(), trg.f_calc_hessians.parts()):
      print("c fin %s:" % pn, numstr(f), file=log)
      print("  ana %s:" % pn, numstr(a), file=log)
    assert approx_equal(trg.f_calc_hessians, c_fin)
  check_f_calc_abs_derivs()
  check_f_calc_derivs()
  #
  f_calc[0] = 0j
  f_calc_abs = flex.abs(f_calc)
  trg = r1.target(f_obs=f_obs, f_calc=f_calc)
  assert trg.gradients_work()[0] == 0j
  assert trg.hessians_work()[0] == (0,0,0)

def run(args):
  assert len(args) < 3
  arg_vals = [int(arg) for arg in args]
  arg_vals = arg_vals + [3, 2][len(arg_vals):]
  n_refl, n_trials = arg_vals
  assert n_refl > 0
  assert n_trials > 0
  if (len(args) == 0):
    from libtbx.utils import null_out
    log = null_out()
  else:
    import sys
    log = sys.stdout
  mt = flex.mersenne_twister(seed=0)
  for i_trial in range(n_trials):
    exercise(mt, n_refl, log)
  print("OK")

if (__name__ == "__main__"):
  import sys
  run(args=sys.argv[1:])


 *******************************************************************************


 *******************************************************************************
cctbx/xray/targets/tst_shelxl_wght_ls.py
from __future__ import absolute_import, division, print_function
import cctbx.xray.targets
from cctbx.array_family import flex
from libtbx.test_utils import approx_equal
from six.moves import range

def calc_k(f_obs, i_calc):
  fc = flex.sqrt(i_calc)
  num = flex.sum(f_obs * fc)
  den = flex.sum(fc * fc)
  assert den != 0
  k = num / den
  return k

def calc_w(wa, wb, i_obs, i_sig, i_calc, k):
  assert i_sig.size() == i_obs.size()
  assert i_calc.size() == i_obs.size()
  ik = i_obs / k**2
  sk = i_sig / k**2
  ik.set_selected(ik < 0, 0)
  p = (ik + 2 * i_calc) / 3
  den = flex.pow2(sk) + flex.pow2(wa*p) + wb*p
  assert den.all_gt(1e-8)
  weights = 1 / den
  return weights

def calc_t(i_obs, i_calc, k, weights):
  delta = i_obs - k**2 * i_calc
  t_num = flex.sum(weights * flex.pow2(delta))
  t_den = flex.sum(weights * flex.pow2(i_obs))
  assert t_den != 0
  return t_num / t_den

def kwt(f_obs, i_obs, i_sig, f_calc, i_calc, wa, wb):
  if (f_calc is not None):
    i_calc = flex.norm(f_calc)
  k = calc_k(f_obs, i_calc)
  weights = calc_w(
    wa=wa,
    wb=wb,
    i_obs=i_obs,
    i_sig=i_sig,
    i_calc=i_calc,
    k=k)
  t = calc_t(
    i_obs=i_obs,
    i_calc=i_calc,
    k=k,
    weights=weights)
  return k, weights, t

def kwt2(f_obs, i_obs, i_sig, f_calc, i_calc, wa, wb):
  k, weights, t = kwt(f_obs, i_obs, i_sig, f_calc, i_calc, wa, wb)
  trg = cctbx.xray.targets.shelxl_wght_ls(
    f_obs=f_obs,
    i_obs=i_obs,
    i_sig=i_sig,
    f_calc=f_calc,
    i_calc=i_calc,
    wa=wa,
    wb=wb)
  assert approx_equal(trg.scale_factor, k)
  assert approx_equal(trg.weights, weights)
  assert approx_equal(trg.target, t)
  return trg

def exercise(mt, n_refl):
  f_obs = mt.random_double(size=n_refl)
  i_obs = flex.pow2(f_obs)
  i_sig = mt.random_double(size=i_obs.size())
  f_calc = flex.complex_double(
    mt.random_double(size=f_obs.size()),
    mt.random_double(size=f_obs.size()))
  i_calc = flex.norm(f_calc)
  wa = 1.23
  wb = 2.34
  trg = kwt2(
    f_obs=f_obs, i_obs=i_obs, i_sig=i_sig,
    f_calc=f_calc, i_calc=None, wa=wa, wb=wb)
  def check_i_derivs():
    g_ana = trg.i_gradients
    c_ana = trg.i_curvatures
    eps = 1e-6
    g_fin = flex.double()
    c_fin = flex.double()
    for ih in range(i_calc.size()):
      fs = []
      gs = []
      c_orig = i_calc[ih]
      for signed_eps in [eps, -eps]:
        i_calc[ih] = c_orig + signed_eps
        trg_eps = kwt2(
          f_obs=f_obs, i_obs=i_obs, i_sig=i_sig,
          f_calc=None, i_calc=i_calc, wa=wa, wb=wb)
        fs.append(trg_eps.target)
        gs.append(trg_eps.i_gradients[ih])
      g_fin.append((fs[0]-fs[1])/(2*eps))
      c_fin.append((gs[0]-gs[1])/(2*eps))
      i_calc[ih] = c_orig
    assert approx_equal(g_ana, g_fin)
    assert approx_equal(c_ana, c_fin)
  def check_f_derivs():
    g_ana = trg.f_gradients
    c_ana = trg.f_hessians
    eps = 1e-6
    g_fin = flex.complex_double()
    c_fin = flex.vec3_double()
    for ih in range(i_calc.size()):
      c_orig = f_calc[ih]
      g_fin_ab = []
      c_fin_ab = []
      for iab in [0,1]:
        fs = []
        gs = []
        for signed_eps in [eps, -eps]:
          if (iab == 0):
            f_calc[ih] = complex(c_orig.real + signed_eps, c_orig.imag)
          else:
            f_calc[ih] = complex(c_orig.real, c_orig.imag + signed_eps)
          trg_eps = kwt2(
            f_obs=f_obs, i_obs=i_obs, i_sig=i_sig,
            f_calc=f_calc, i_calc=None, wa=wa, wb=wb)
          fs.append(trg_eps.target)
          gs.append(trg_eps.f_gradients[ih])
        g_fin_ab.append((fs[0]-fs[1])/(2*eps))
        c_fin_ab.append((gs[0]-gs[1])/(2*eps))
      g_fin.append(complex(*g_fin_ab))
      assert approx_equal(c_fin_ab[0].imag, c_fin_ab[1].real)
      c_fin.append((c_fin_ab[0].real, c_fin_ab[1].imag, c_fin_ab[0].imag))
      f_calc[ih] = c_orig
    assert approx_equal(g_ana, g_fin)
    assert approx_equal(c_ana, c_fin)
  check_i_derivs()
  check_f_derivs()

def run(args):
  assert len(args) < 3
  arg_vals = [int(arg) for arg in args]
  arg_vals = arg_vals + [3, 2][len(arg_vals):]
  n_refl, n_trials = arg_vals
  assert n_refl > 0
  assert n_trials > 0
  mt = flex.mersenne_twister(seed=0)
  for i_trial in range(n_trials):
    exercise(mt, n_refl)
  print("OK")

if (__name__ == "__main__"):
  import sys
  run(args=sys.argv[1:])


 *******************************************************************************


 *******************************************************************************
cctbx/xray/weighting_schemes.py
from __future__ import absolute_import, division, print_function
from cctbx.array_family import flex
import math


class amplitude_unit_weighting(object):
  """ Mere unit weights for F """

  def compute(self):
    assert(self.observed.is_xray_amplitude_array())
    self.weights = None
    self.derivatives_wrt_f_c = None


class intensity_quasi_unit_weighting(object):
  """ Quasi-unit  weights 1/(4 Fo^2) for F^2.

      The weights are replaced by 1/(4 sigma(Fo^2)^2)
      for weak Fo^2, which are defined as Fo^2 < n_sigma * sigma(Fo^2)
  """

  def __init__(self, n_sigma=1.0):
    self.n_sigma = n_sigma

  def compute(self):
    assert(self.observed.is_xray_intensity_array())
    f_sqr = self.observed.data()
    sig_f_sqr = self.observed.sigmas()
    w = flex.double(f_sqr.size())
    if sig_f_sqr is None:
      strongs = flex.bool(f_sqr.size(), True)
    else:
      if self.n_sigma == 1:
        strongs = f_sqr > sig_f_sqr
      else:
        strongs = f_sqr > self.n_sigma * sig_f_sqr
    weaks = ~strongs
    w.set_selected(strongs, 0.25/f_sqr.select(strongs))
    if sig_f_sqr is not None:
      w.set_selected(weaks,   0.25/flex.pow2( sig_f_sqr.select(weaks) ))
    self.weights = w
    self.derivatives_wrt_f_c = None


class pure_statistical_weighting(object):
  """ 1/sigma^2 weights """

  def compute(self):
    assert(self.observed is not None)
    sigmas_squared = flex.pow2(self.observed.sigmas())
    assert sigmas_squared.all_gt(0)
    self.weights = 1 / sigmas_squared
    self.derivatives_wrt_f_c = None


class simple_shelx_weighting(object):
  """ As the WGHT instruction in ShelXL with only a and b terms.
      The implementation is straightforward without any attempt to save
      space or time: mostly a reference for tests.
  """

  def __init__(self, a=0.1, b=0):
    self._params = a,b

  def compute(self, f_calc, scale_factor=None):
    self.calculated = f_calc
    assert(self.observed.is_xray_intensity_array())
    assert(self.calculated.is_complex_array())
    a,b = self._params
    f_c = self.calculated.data()
    if scale_factor is None:
      scale_factor = self.observed.scale_factor(
        self.calculated, cutoff_factor=0.99)
    self.scale_factor = scale_factor
    f_c = f_c * math.sqrt(scale_factor) # don't modify f_c in place
    sigmas_square = flex.pow2(self.observed.sigmas())
    f_obs_square_plus = self.observed.data().deep_copy()
    negatives = self.observed.data() < 0
    f_obs_square_plus.set_selected(negatives, 0)
    p = (f_obs_square_plus + 2*flex.norm(f_c))/3
    w = 1/(sigmas_square + flex.pow2(a*p) + b*p)
    dw_dfc = -(2*a*a*p + b) * flex.pow2(w) * (4./3*f_c)
    self.weights, self.derivatives_wrt_f_c = w, dw_dfc


class shelx_weighting(object):
  """ As the WGHT instruction in ShelXL """

  def __init__(self, a=0.1, b=0, c=0, d=0, e=0, f=1./3, wavelength=None):
    assert(e == 0 or wavelength is not None)
    self._params = a,b,c,d,e,f
    self._wavelength = wavelength
    self._obs_part_dirty = True
    self.computing_derivatives_wrt_f_c = False

  def _propdef():
    def fget(self):
      try: return self._observed
      except Exception: return None
    def fset(self, obs):
      assert(obs.is_xray_intensity_array())
      self._observed = obs
      self._obs_part_dirty = True
    return locals()
  observed = property(**_propdef())

  def _propdef():
    def fget(self):
      try: return self._calculated
      except Exception: return None
    def fset(self, f_calc):
      assert(f_calc.is_complex_array())
      self._calculated = f_calc
    return locals()
  calculated = property(**_propdef())

  def compute(self, f_calc, scale_factor=None):
    self.calculated = f_calc
    a,b,c,d,e,f = self._params
    if self._obs_part_dirty:
      # The part depending only on |F_o|^2
      if c == 0:
        q = None
      else:
        exp_args = self.observed.sin_theta_over_lambda_sq().data()
        if e != 0: k_sqr = exp_args.deep_copy()
        exp_args *= c
        exp_vals = flex.exp(exp_args)
        if c > 0:
          q = exp_vals
        else:
          q = 1 - exp_vals
      self._q = q
      if self.observed.sigmas() is not None:
        self._den_obs = flex.pow2(self.observed.sigmas())
        if d != 0:
          self._den_obs += d
        if e != 0:
          e_times_sin_theta_sq = k_sqr
          e_times_sin_theta_sq *= e * self._wavelength
          self._den_obs += e_times_sin_theta_sq
      else:
        self._den_obs = None
      negatives = self.observed.data() < 0
      self._p_obs = self.observed.data().deep_copy()
      self._p_obs.set_selected(negatives, 0)
      self._p_obs *= f
      #
      self._obs_part_dirty = False
    # The part depending on |F_c|^2 as well
    q = self._q
    f_c = self.calculated.data()
    p = flex.norm(f_c)
    if scale_factor is None:
      scale_factor = self.observed.scale_factor(
        self.calculated, cutoff_factor=0.99)
    self.scale_factor = scale_factor
    p *= scale_factor
    p *= 1 - f
    p += self._p_obs
    den = p.deep_copy()
    den *= a * a
    der = None
    if self.computing_derivatives_wrt_f_c: der = 2*den
    den += b
    if self.computing_derivatives_wrt_f_c: der += b
    den *= p
    if self._den_obs is not None: den += self._den_obs
    if q is None:
      w = 1 / den
    else:
      w =  q / den
    if self.computing_derivatives_wrt_f_c:
      if scale_factor is not None:
        # don't modify f_c in place
        f_c = f_c * math.sqrt(scale_factor)
      der *= -flex.pow2(w)
      der *= 4./3
      der = der * f_c
    self.weights = w
    self.derivatives_wrt_f_c = der


 *******************************************************************************
