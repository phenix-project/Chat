

 *******************************************************************************
fable/tst_cout_compile.py
from __future__ import absolute_import, division, print_function
import fable.cout
from six.moves import zip

file_names_disable_warnings = set("""\
add_reals.f
add_real_integer.f
logical_a_or_b.f
add_dp_integer.f
real_array_sum.f
""".splitlines())

file_names_join_stdout_stderr = set("""\
stop_bare.f
stop_integer.f
stop_string.f
""".splitlines())

top_procedures_by_file_name = {}
for line in """\
const_analysis_1.f prog
const_analysis_2.f prog
""".splitlines():
  file_name, top_procedure = line.split()
  top_procedures_by_file_name[file_name] = [top_procedure]

dynamic_parameters_by_file_name = {
  "dynamic_parameters_1.f": [fable.cout.dynamic_parameter_props(
    name="root_size", ctype="int", default="3")],
  "dynamic_parameters_2.f": [fable.cout.dynamic_parameter_props(
    name="nums_size", ctype="int", default="2")],
  "dynamic_parameters_3.f": [fable.cout.dynamic_parameter_props(
    name="base_size", ctype="int", default="3")],
  "dynamic_parameters_4.f": [fable.cout.dynamic_parameter_props(
    name="base_size", ctype="int", default="3")],
  "dynamic_parameters_5.f": [fable.cout.dynamic_parameter_props(
    name="base_size", ctype="int", default="3")]}

common_equivalence_simple_by_file_name = {
  "common_equivalence_simple_1.f": ["info"],
  "common_equivalence_simple_2.f": ["info"],
  "common_equivalence_simple_3.f": ["tab"],
  "common_equivalence_simple_4.f": ["first"],
  "common_equivalence_simple_5.f": ["all"],
  "common_equivalence_simple_6.f": ["com"]}

def check_intrinsics_extra(text):
  import re
  lines = text.splitlines()
  def check():
    if (len(lines) != 6): return False
    if (re.match(r'\d\d-[A-Z][a-z][a-z]-\d\d', lines[0]) is None): return False
    if (re.match(r'\d\d:\d\d:\d\d', lines[1]) is None): return False
    if (len(lines[2]) != 70): return False
    if (len(lines[3]) != 6): return False
    if (lines[4] != "YkD"): return False
    if (lines[5] != "           0"): return False
    return True
  if (not check()):
    print("Unexpected output:")
    print(text)
    raise AssertionError

class file_name_and_expected_cout_info(object):

  __slots__ = [
    "inp_lines",
    "out_lines",
    "skip_run",
    "ifort_diff_behavior",
    "ifort_diff_floating_point_format"]

  def __init__(O):
    O.inp_lines = []
    O.out_lines = []
    O.skip_run = False
    O.ifort_diff_behavior = False
    O.ifort_diff_floating_point_format = False

def read_file_names_and_expected_cout(test_valid):
  from fable.utils import keyed_lists
  import os.path as op
  with open(op.join(test_valid, "file_names_and_expected_cout")) as f:
    text = f.read()
  result = keyed_lists()
  file_name, info = None, None
  for line in text.splitlines():
    if (line.startswith("<")):
      assert file_name is not None
      assert line.endswith("<")
      info.inp_lines.append(line[1:-1])
    elif (line.startswith("|")):
      assert file_name is not None
      assert line.endswith("|")
      info.out_lines.append(line[1:-1])
    else:
      if (file_name is not None):
        result.get(file_name).append(info)
      info = file_name_and_expected_cout_info()
      if (line.startswith("!@")):
        file_name = line[2:]
        info.skip_run = True
      elif (line.startswith("!=")):
        file_name = line[2:]
        info.ifort_diff_behavior = True
      elif (line.startswith("!%")):
        file_name = line[2:]
        info.ifort_diff_floating_point_format = True
      else:
        file_name = line
  if (file_name is not None):
    result.get(file_name).append(info)
  return result

def regex_select(keyed_lists, regex_patterns):
  result = []
  for key,list in keyed_lists.items():
    def key_matches_regex():
      if (len(regex_patterns) == 0):
        return True
      from re import search
      for pattern in regex_patterns:
        if (search(pattern, key) is not None):
          return True
      return False
    if (key_matches_regex()):
      result.append((key,list))
  return result

class process_file_info(object):

  __slots__ = ["opts", "comp_env", "test_valid"]

  def __init__(O, opts, comp_env, test_valid):
    O.opts = opts
    O.comp_env = comp_env
    O.test_valid = test_valid

  def __call__(O, file_info):
    from libtbx import easy_run
    from libtbx.str_utils import show_string
    from libtbx.test_utils import show_diff
    from six.moves import StringIO
    import os.path as op
    import sys
    opts = O.opts
    file_name, io_infos = file_info
    if (opts.verbose):
      print(file_name)
    file_path = op.join(O.test_valid, file_name)
    top_procedures = top_procedures_by_file_name.get(file_name)
    common_equivalence_simple_list = [set(
      common_equivalence_simple_by_file_name.get(file_name, []))]
    if (len(common_equivalence_simple_list[0]) != 0):
      common_equivalence_simple_list.append([])
    for i_ces,common_equivalence_simple in \
          enumerate(common_equivalence_simple_list):
      common_report_stringio = StringIO()
      try:
        lines = fable.cout.process(
          file_names=[file_path],
          top_procedures=top_procedures,
          dynamic_parameters=dynamic_parameters_by_file_name.get(file_name),
          common_equivalence_simple=common_equivalence_simple,
          common_report_stringio=common_report_stringio)
      except Exception:
        if (not opts.keep_going): raise
        print("\nEXCEPTION: fable.cout.process([%s])\n" % file_name)
        return 1
      have_simple_equivalence = (
        "\n".join(lines).find(" // SIMPLE EQUIVALENCE") >= 0)
      if (len(common_equivalence_simple) != 0):
        assert have_simple_equivalence
      else:
        assert not have_simple_equivalence
      assert file_name.endswith(".f")
      base_name = file_name[:-2]
      if (len(common_equivalence_simple_list) != 1):
        base_name += "_alt%d" % i_ces
      fem_cpp = base_name + "_fem.cpp"
      fem_exe_name = fem_cpp[:-4] + O.comp_env.exe_suffix
      with open(fem_cpp, "w") as f:
        print("\n".join(lines), file=f)
      if (opts.ifort):
        ifort_exe_name = base_name + "_ifort"
        ifort_cmd = "ifort -diag-disable 7000 -o %s %s" % (
          ifort_exe_name, show_string(file_path))
      else:
        ifort_exe_name = None
        ifort_cmd = None
      if (opts.dry_run):
        return 0
      #
      n_failures = [0]
      def handle_exception(e):
        n_failures[0] += 1
        if (not opts.keep_going): raise
        print()
        print(str(e))
        print()
        sys.stdout.flush()
      #
      class BuildError(RuntimeError): pass
      try:
        O.comp_env.build(
          link=True,
          file_name_cpp=fem_cpp,
          exe_name=fem_exe_name,
          disable_warnings=(file_name in file_names_disable_warnings),
          show_command=opts.verbose,
          Error=BuildError)
      except BuildError as e:
        handle_exception(e)
        fem_exe_name = None
      #
      if (ifort_cmd is not None):
        if (opts.verbose):
          print(ifort_cmd)
        buffers = easy_run.fully_buffered(command=ifort_cmd)
        try:
          buffers.raise_if_errors_or_output(Error=BuildError)
        except BuildError as e:
          handle_exception(e)
          ifort_exe_name = None
      #
      for info in io_infos:
        if (info.skip_run):
          if (opts.verbose):
            print("Skipping run:", file_name)
          continue
        if (len(info.inp_lines) != 0 and opts.verbose):
          print("  number of input lines:", len(info.inp_lines))
        sys.stdout.flush()
        for exe_name in [fem_exe_name, ifort_exe_name]:
          if (exe_name is None): continue
          cmd = cmd0 = op.join(".", exe_name)
          if (opts.valgrind):
            cmd = "valgrind " + cmd
          if (opts.verbose):
            print(cmd)
            sys.stdout.flush()
          join_stdout_stderr = (
               opts.valgrind
            or (file_name in file_names_join_stdout_stderr))
          buffers = easy_run.fully_buffered(
            command=cmd,
            stdin_lines=info.inp_lines,
            join_stdout_stderr=join_stdout_stderr)
          if (not join_stdout_stderr):
            class ExeError(RuntimeError): pass
            try:
              buffers.raise_if_errors(Error=ExeError)
            except ExeError as e:
              handle_exception(e)
              buffers = None
          if (buffers is not None):
            text = "\n".join(buffers.stdout_lines)
            if (opts.valgrind):
              print(text)
            else:
              def check(text):
                if (file_name == "intrinsics_extra.f"):
                  check_intrinsics_extra(text)
                  return
                if (file_name == "sf.f"):
                  text = text.replace(" -0.620088", " -0.620087")
                elif (file_name == "unformatted_experiments.f"):
                  if (sys.byteorder == "big"):
                    text = text \
                      .replace(
                        "        1234        5678",
                        "        5678        1234") \
                      .replace(
                        "        18558553691448",
                        "        23330262356193")
                have_diffs = show_diff(text, "\n".join(info.out_lines))
                def assert_not_have_diffs():
                  if (opts.keep_going):
                    print("WARNING: --keep-going after show_diff:", exe_name)
                  else:
                    assert not have_diffs
                if (have_diffs):
                  if (exe_name is fem_exe_name):
                    assert_not_have_diffs()
                  elif (exe_name is ifort_exe_name):
                    if (    not info.ifort_diff_behavior
                        and not info.ifort_diff_floating_point_format):
                      assert_not_have_diffs()
                  else:
                    raise AssertionError
              check(text)
          def run_with_args(args):
            cmda = cmd0 + " " + args
            if (opts.verbose):
              print(cmda)
              sys.stdout.flush()
            result = easy_run.fully_buffered(
              command=cmda, join_stdout_stderr=True)
            if (opts.valgrind):
              cmda = "valgrind " + cmda
              if (opts.verbose):
                print(cmda)
                sys.stdout.flush()
              buffers = easy_run.fully_buffered(
                command=cmda, join_stdout_stderr=True)
              print("\n".join(buffers.stdout_lines))
            return result
          if (file_name == "read_lines.f"):
            exercise_end_of_line(exe_name=exe_name, verbose=opts.verbose)
          elif (file_name == "dynamic_parameters_1.f"):
            buffers = run_with_args("--fem-dynamic-parameters=5")
            assert not show_diff(buffers.stdout_lines, """\
          14          15          16          17          18          19
          20          21          22          23
""")
            buffers = run_with_args("--fem-dynamic-parameters=5,6")
            assert buffers.stdout_lines[0].endswith(
              "Too many --fem-dynamic-parameters fields"
              " (given: 2, max. expected: 1)")
            buffers = run_with_args("--fem-dynamic-parameters=x")
            assert buffers.stdout_lines[0].endswith(
              'Invalid --fem-dynamic-parameters field (field 1): "x"')
          elif (file_name == "intrinsics_iargc_getarg.f"):
            buffers = run_with_args("D rP uWq")
            assert not show_diff(buffers.stdout_lines, "\n".join([
              "A", "D   ", "rP  ", "uWq ",
              "B", "uWq ", "rP  ", "D   ",
              "C", "rP  ", "uWq ", "D   "]) + "\n")
    #
    return n_failures[0]

def exercise_end_of_line(exe_name, verbose):
  lines = b"""\
a
bc
def
ghij
klmno
""".splitlines()
  with open("unix.txt", "wb") as f:
    f.write(b"\n".join(lines)+b"\n")
  with open("dos.txt", "wb") as f:
    f.write(b"\r\n".join(lines)+b"\r\n")
  with open("dos2.txt", "wb") as f:
    f.write(b"\r\r\n".join(lines)+b"\r\n")
  with open("mac.txt", "wb") as f:
    f.write(b"\r".join(lines)+b"\r")
  from libtbx import easy_run
  from libtbx.utils import remove_files
  import os
  op = os.path
  expected_outputs = [
    b"a   \nbc  \ndef \nghij\nklmn\n",
    b"a   \nbc  \ndef \nghij\nklmn\n",
    b"a\r  \nbc\r \ndef\r\nghij\nklmn\n",
    b"a\rbc\n"]
  for vers,expected in zip(["unix", "dos", "dos2", "mac"], expected_outputs):
    remove_files(paths=["read_lines_out"])
    cmd = "%s < %s.txt > read_lines_out" % (op.join(".", exe_name), vers)
    if (verbose): print(cmd)
    easy_run.fully_buffered(command=cmd).raise_if_errors_or_output()
    assert op.isfile("read_lines_out")
    with open("read_lines_out", "rb") as f:
      result = f.read()
    assert result == expected.replace(b"\n", os.linesep.encode('utf8')), result

def exercise_compile_valid(regex_patterns, opts):
  from fable import simple_compilation
  comp_env = simple_compilation.environment()
  if (comp_env.compiler_path is None):
    print("Skipping exercise_compile_valid(): %s not available." %
      comp_env.compiler)
    return
  import libtbx.load_env
  import os.path as op
  fable_dist = libtbx.env.dist_path(module_name="fable")
  test_valid = op.join(fable_dist, "test/valid")
  selected_file_names_and_expected_cout = regex_select(
    keyed_lists=read_file_names_and_expected_cout(test_valid=test_valid),
    regex_patterns=regex_patterns)
  assert len(selected_file_names_and_expected_cout) != 0
  #
  if (opts.pch):
    comp_env.build(
      link=False,
      file_name_cpp=op.join(fable_dist, "fem.hpp"),
      pch_name="fem.hpp",
      show_command=True)
    comp_env.set_have_pch()
    print()
  #
  processor = process_file_info(
    opts=opts, comp_env=comp_env, test_valid=test_valid)
  #
  if (not opts.multiprocessing):
    n_failures = 0
    for file_info in selected_file_names_and_expected_cout:
      n_failures += processor(file_info=file_info)
    return n_failures
  #
  n_proc = min(
    len(selected_file_names_and_expected_cout),
    opts.max_proc)
  print("Number of processors:", n_proc)
  import multiprocessing
  mp_pool = multiprocessing.Pool(processes=n_proc)
  return sum(mp_pool.map(processor, selected_file_names_and_expected_cout))

def run(args):
  from libtbx.option_parser import option_parser
  command_line = (option_parser(
    usage="fable.python %s [options] regex_pattern ..." % __file__)
    .enable_multiprocessing()
    .option(None, "--dry_run",
      action="store_true",
      default=False)
    .option(None, "--valgrind",
      action="store_true",
      default=False)
    .option(None, "--ifort",
      action="store_true",
      default=False)
    .option(None, "--keep_going",
      action="store_true",
      default=False)
    .option(None, "--pch",
      action="store_true",
      default=False)
    .option(None, "--verbose",
      action="store_true",
      default=False)
  ).process(args=args)
  from libtbx.utils import show_times_at_exit
  show_times_at_exit()
  n_failures = exercise_compile_valid(
    regex_patterns=command_line.args,
    opts=command_line.options)
  if (n_failures != 0):
    print("Done.")
  else:
    print("OK")

if (__name__ == "__main__"):
  import sys
  run(args=sys.argv[1:])


 *******************************************************************************


 *******************************************************************************
fable/tst_equivalence.py
from __future__ import absolute_import, division, print_function
from six.moves import range
import fable.equivalence

def fem_array_alignment(members_size, i_mbr_byte_offset_pairs):
  fueaa = fable.fem_utils_equivalence_array_alignment(
    members_size=members_size)
  for p0,p1 in i_mbr_byte_offset_pairs:
    i0, a0 = p0
    i1, a1 = p1
    fueaa.add_anchor(i0=i0, a0=a0, i1=i1, a1=a1)
  return fueaa.infer_diffs0_from_diff_matrix()

def check_array_alignment(array_alignment, n, pairs):
  diffs0 = array_alignment(
    members_size=n,
    i_mbr_byte_offset_pairs=pairs)
  for p0,p1 in pairs:
    i0, a0 = p0
    i1, a1 = p1
    assert diffs0[i1] - diffs0[i0] == a0 - a1
  return diffs0

def exercise_given_members_size(array_alignment, n, n_trials=10):
  from libtbx.math_utils import random_permutation_in_place
  import random
  random.seed(0)
  i_mbrs = list(range(n))
  for i_trial in range(n_trials):
    random_permutation_in_place(list=i_mbrs)
    #
    pair0 = i_mbrs[0], random.randrange(n+5)
    pairs = []
    for i in range(1,n):
      pair1 = i_mbrs[i], random.randrange(n+5)
      if (random.random() < 0.5):
        pairs.append((pair0, pair1))
      else:
        pairs.append((pair1, pair0))
    diffs0 = check_array_alignment(array_alignment, n, pairs)
    for i_redundant in range(3):
      i = random.randrange(n)
      j = random.randrange(n)
      d = random.randrange(n+5)
      pairs.append(((i,diffs0[j]-diffs0[i]+d), (j,d)))
    diffs0_r = check_array_alignment(array_alignment, n, pairs)
    assert diffs0 == diffs0_r
    #
    diffs_in = [0]
    for i in range(n-1):
      diffs_in.append(random.randrange(n+5))
    random_permutation_in_place(list=diffs_in)
    all_pairs = []
    for i in range(n):
      for j in range(3):
        sh = random.randrange(n+5)
        all_pairs.append(((i,sh), (i,sh)))
    for i in range(n-1):
      for j in range(i+1,n):
        sh = random.randrange(n+5)
        i0 = i_mbrs[i]
        a0 = diffs_in[i0] + sh
        i1 = i_mbrs[j]
        a1 = diffs_in[i1] + sh
        all_pairs.append(((i0,a0), (i1,a1)))
        all_pairs.append(((i1,a1), (i0,a0)))
    random_permutation_in_place(list=all_pairs)
    check_array_alignment(array_alignment, n, all_pairs)
  #
  # non-sensical inputs to exercise stability (e.g. asserts)
  for i_trial in range(n_trials):
    pairs = []
    for i_pair in range(n+2):
      i0 = random.randrange(n)
      o0 = random.randrange(n+5)
      i1 = random.randrange(n)
      o1 = random.randrange(n+5)
      pairs.append(((i0,o0), (i1,o1)))
      try:
        check_array_alignment(array_alignment, n, pairs)
      except RuntimeError as e:
        pass

def exercise_exceptions(array_alignment):
  from libtbx.test_utils import Exception_expected
  for n,pairs in [
        (2, [((0,0),(0,1))]),
        (2, [((0,0),(1,0)), ((0,0),(1,1))])]:
    try:
      array_alignment(n, pairs)
    except RuntimeError as e:
      assert str(e).endswith("directly conflicting input")
    else: raise Exception_expected
  #
  for n,pairs in [
        (3, [((0,0),(1,0)), ((2,0),(1,1)), ((2,0),(0,0))]),
        (4, [((1,4),(2,8)), ((3,3),(1,4)), ((3,6),(2,6)), ((0,0),(2,4))])]:
    try:
      array_alignment(n, pairs)
    except RuntimeError as e:
      assert str(e).endswith("indirectly conflicting input")
    else: raise Exception_expected
  #
  try:
    array_alignment(3, [((0,0),(1,0))])
  except RuntimeError as e:
    assert str(e).endswith("insufficient input")
  else: raise Exception_expected

def exercise_cluster_unions():
  cu = fable.equivalence.cluster_unions()
  cu.add(("a", "b"))
  assert cu.unions == [["a", "b"]]
  cu.add(("a", "b"))
  assert cu.unions == [["a", "b"]]
  cu.add(("c", "d"))
  assert cu.unions == [["a", "b"], ["c", "d"]]
  cu.add(("b", "c"))
  assert cu.unions == [["a", "b", "c", "d"], None]
  cu.add(("e", "f"))
  assert cu.unions == [["a", "b", "c", "d"], None, ["e", "f"]]
  cu.add(("g", "e"))
  assert cu.unions == [["a", "b", "c", "d"], None, ["e", "f", "g"], None]
  cu.add(("a", "g"))
  assert cu.unions == [["a", "b", "c", "d", "e", "f", "g"], None, None, None]
  cu.add(("h", "i"))
  assert cu.unions == [["a", "b", "c", "d", "e", "f", "g"], None, None, None,
    ["h", "i"]]
  assert cu.indices == {
    "a": 0, "c": 0, "b": 0, "e": 0, "d": 0, "g": 0, "f": 0, "i": 4, "h": 4}
  cu.tidy()
  assert cu.unions == [["a", "b", "c", "d", "e", "f", "g"], ["h", "i"]]
  assert cu.indices == {
    "a": 0, "c": 0, "b": 0, "e": 0, "d": 0, "g": 0, "f": 0, "i": 1, "h": 1}
  cu.add(("h", "j"))
  assert cu.unions == [["a", "b", "c", "d", "e", "f", "g"], ["h", "i", "j"]]

def run(args):
  assert len(args) in [0,1]
  if (len(args) == 0):
    n_trials = 10
  else:
    n_trials = int(args[0])
    print("n_trials:", n_trials)
    assert n_trials >= 0
  def exercise_array_alignment(f):
    for n in range(2,6):
      exercise_given_members_size(array_alignment=f, n=n, n_trials=n_trials)
    exercise_exceptions(array_alignment=f)
  exercise_array_alignment(fable.equivalence.array_alignment)
  if (fable.ext is not None):
    exercise_array_alignment(fem_array_alignment)
  exercise_cluster_unions()
  print("OK")

if (__name__ == "__main__"):
  import sys
  run(args=sys.argv[1:])


 *******************************************************************************


 *******************************************************************************
fable/tst_ext.py
from __future__ import absolute_import, division, print_function
import fable
from libtbx.test_utils import Exception_expected

def try_code_none(f):
  try: f(code=None)
  except TypeError as e: pass
  else: raise Exception_expected

def exercise_unsigned_integer_scan(f):
  try_code_none(f=f)
  assert f(code="") == -1
  assert f(code="0") == 1
  assert f(code="12") == 2
  assert f(code="1a") == 1
  assert f(code="a1") == -1
  assert f(code="a1", start=1) == 2
  assert f(code="a12", start=1) == 3
  assert f(code="a1b", start=1) == 2
  assert f(code="0123456789*2", start=1) == 10
  assert f(code="3456", start=1, stop=-1) == 4
  assert f(code="3456", start=1, stop=3) == 3

def exercise_floating_point_scan_after_exponent_char(f):
  try_code_none(f=f)
  assert f(code="") == -1
  assert f(code="e") == -1
  assert f(code="+") == -1
  assert f(code="-") == -1
  assert f(code="0") == 1
  assert f(code="123456789") == 9
  assert f(code="+0") == 2
  assert f(code="-12") == 3
  assert f(code="-+0") == -1
  assert f(code="-+0", start=1) == 3
  assert f(code="-+34", start=1, stop=-1) == 4
  assert f(code="-+34", start=1, stop=3) == 3

def exercise_floating_point_scan_after_dot(f):
  try_code_none(f=f)
  assert f(code="") == 0
  assert f(code="0") == 1
  assert f(code="123456789") == 9
  assert f(code="e1") == 2
  assert f(code="e+1") == 3
  assert f(code="d-12") == 4
  assert f(code="0e+1") == 4
  assert f(code="0e") == -1
  assert f(code="456d003") == 7
  assert f(code="456d-0123456789") == 15
  assert f(code="xe+1", start=1) == 4
  assert f(code="xe+1") == 0
  assert f(code="xe+56", start=1, stop=-1) == 5
  assert f(code="xe+56", start=1, stop=4) == 4

def exercise_identifier_scan(f):
  try_code_none(f=f)
  assert f(code="") == -1
  assert f(code=")") == -1
  assert f(code="0") == -1
  assert f(code="a") == 1
  assert f(code="a(") == 1
  assert f(code="a_") == 2
  assert f(code="a_(") == 2
  assert f(code="a0_") == 3
  assert f(code="a0_=") == 3
  assert f(code="a0", start=1) == -1
  assert f(code="x*y*z_(i)", start=4) == 6
  assert f(code="_abcdefghijklmnopqrstuvwxyz0123456789=0") == 37
  assert f(code="*abc", start=1, stop=-1) == 4
  assert f(code="*abc", start=1, stop=3) == 3

def exercise_find_closing_parenthesis(f):
  try_code_none(f=f)
  assert f(code="") == -1
  assert f(code=")") == 0
  assert f(code="x)") == 1
  assert f(code="x)", start=1) == 1
  assert f(code="x)", start=2) == -1
  assert f(code="x)", start=2000) == -1
  assert f(code="()") == -1
  assert f(code="())") == 2
  assert f(code="(())") == -1
  assert f(code="(()))") == 4
  assert f(code="a(b(c(d(e),f(g),h(0:3)),g(4),h,j))") == -1
  assert f(code="a(b(c(d(e),f(g),h(0:3)),g(4),h,j)))") == 34
  assert f(code="x)", start=1, stop=-1) == 1
  assert f(code="x)", start=1, stop=1) == -1

def exercise_fem_utils_split_comma_separated():
  scs = fable.exercise_fem_utils_split_comma_separated
  assert scs("") == []
  assert scs(" , ") == []
  assert scs("b") == ["b"]
  assert scs(" c ") == ["c"]
  assert scs("d,e") == ["d", "e"]
  assert scs(" f , g ") == ["f", "g"]
  assert scs(" abc,,def,g ,hi, jkl ") == ["abc", "def", "g", "hi", "jkl"]

def exercise_fem_utils_int_types():
  int_sizes = fable.exercise_fem_utils_int_types()
  expected = [1, 2, 4, 8]
  if (int_sizes != expected):
    hpp = "fem/utils/int_sizes.hpp"
    print("FATAL: %s: sizes are" % hpp, int_sizes, "but should be", expected)
    raise RuntimeError(
      "%s needs to be adjusted for this platform." % hpp)

def exercise_fem_real_types():
  real_sizes = fable.exercise_fem_real_types()
  expected = [4, 8]
  if (real_sizes[:2] != expected):
    hpp = "fem/data_types_star.hpp"
    print("FATAL: %s: sizes are" % hpp, real_sizes[:2], \
      "but should be", expected)
    raise RuntimeError(
      "%s needs to be adjusted for this platform." % hpp)
  assert real_sizes[2] >= real_sizes[1]

def exercise_fem_format_tokenizer():
  f = fable.exercise_fem_format_tokenizer
  try: f("")
  except RuntimeError as e:
    assert str(e) == "Invalid FORMAT specification: empty string"
  else: raise Exception_expected
  try: f("(")
  except RuntimeError as e:
    assert str(e) == "Invalid FORMAT specification: ("
  else: raise Exception_expected
  try: f("x")
  except RuntimeError as e:
    assert str(e) == "Invalid FORMAT specification: x"
  else: raise Exception_expected
  try: f("  x  ")
  except RuntimeError as e:
    assert str(e) == "Invalid FORMAT specification: x"
  else: raise Exception_expected
  try: f("'")
  except RuntimeError as e:
    assert str(e) == "Invalid FORMAT specification: '"
  else: raise Exception_expected
  try: f("''")
  except RuntimeError as e:
    assert str(e) == "Invalid FORMAT specification: ''"
  else: raise Exception_expected
  try: f("'''")
  except RuntimeError as e:
    assert str(e) == "Invalid FORMAT specification: '''"
  else: raise Exception_expected
  try: f("''''")
  except RuntimeError as e:
    assert str(e) == "Invalid FORMAT specification: ''''"
  else: raise Exception_expected
  try: f("' '")
  except RuntimeError as e:
    assert str(e) == "Invalid FORMAT specification: ' '"
  else: raise Exception_expected
  try: f('" "')
  except RuntimeError as e:
    assert str(e) == 'Invalid FORMAT specification: " "'
  else: raise Exception_expected
  assert f("()") == []
  assert f(" (\t ) \t") == []
  assert f("(x)") == [("format", "x")]
  assert f(" ( X ) ") == [("format", "x")]
  assert f(" ( X , X ) ") == [("format", "x")]*2
  assert f("((:,/,$))") == [
    ("op", "("),
    ("op", ":"),
    ("op", "/"),
    ("op", "$"),
    ("op", ")")]
  assert f(" ( '' ) ") == [("string", "")]
  assert f(" ( '''' ) ") == [("string", "'")]
  assert f(" ( ''' ' ) ") == [("string", "' ")]
  assert f(" ( ' ''' ) ") == [("string", " '")]
  assert f(" ( ' '' ' ) ") == [("string", " ' ")]
  assert f(' ( """""" ) ') == [("string", '""')]
  assert f(' ( " X "" \'\t" ) ') == [("string", ' X " \'\t')]
  assert f(" ( + 1 P ) ") == [("format", "+1p")]
  assert f(" ( - 2 3 p ) ") == [("format", "-23p")]
  try: f(" ( + 1 X ) ")
  except RuntimeError as e:
    assert str(e) == "Invalid FORMAT specification: (+1x)"
  else: raise Exception_expected
  try: f(" ( 8 H ) ")
  except RuntimeError as e:
    assert str(e) == \
      "FATAL: Not supported: FORMAT Hollerith edit descriptor: (8h)"
  else: raise Exception_expected
  assert f(" ( 3 4 x ) ") == [("format", "34x")]
  assert f(" ( 5 6 7 p ) ") == [("format", "567p")]
  assert f(" ( 2 3 4 5 ) ") == [("integer", "2345")]
  assert f("(D)") == [("format", "d")]
  assert f("(E)") == [("format", "e")]
  assert f("(F)") == [("format", "f")]
  assert f("(G)") == [("format", "g")]
  assert f("(I)") == [("format", "i")]
  assert f("(Z)") == [("format", "z")]
  assert f("(D20)") == [("format", "d20")]
  assert f("(D30.10)") == [("format", "d30.10")]
  try: f("(D30.)")
  except RuntimeError as e:
    assert str(e) == "Invalid FORMAT specification: (d30.)"
  else: raise Exception_expected
  assert f("(A)") == [("format", "a")]
  assert f("(A37)") == [("format", "a37")]
  assert f("(L)") == [("format", "l")]
  assert f("(L46)") == [("format", "l46")]
  assert f("( B n )") == [("format", "bn")]
  assert f("( b z )") == [("format", "bz")]
  assert f("(S)") == [("format", "s")]
  assert f("( S P )") == [("format", "sp")]
  assert f("( s S )") == [("format", "ss")]
  try: f("(T)")
  except RuntimeError as e:
    assert str(e) == "Invalid FORMAT specification: (t)"
  else: raise Exception_expected
  try: f("(TL)")
  except RuntimeError as e:
    assert str(e) == "Invalid FORMAT specification: (tl)"
  else: raise Exception_expected
  assert f("(T12)") == [("format", "t12")]
  assert f("(TL23)") == [("format", "tl23")]
  assert f("(TR34)") == [("format", "tr34")]
  assert f("(21A83)") == [("integer", "21"), ("format", "a83")]
  assert f("(32('Uq'))") == [
    ("integer", "32"), ("op", "("), ("string", "Uq"), ("op", ")")]
  assert f("""\
(/1X,'Xk aqkIe',/1X,'UxKw',3(/,1X,3F12.6),/,' RxpO',/,\
        3F8.2,3F7.2,\
     /1X,'McR',3(/,1X,3F12.6),/1X,'HPi',\
     'EBx,Qyn ',2F6.1,' Qs>:-I ',3F6.2,/1X,'We,JkC,HIoR,Nb,JRG',\
     'RgMhBn JHyUK<>:lK',6F9.6,/1X,'K^dT ',3(/,1X,3F12.6))""") == [
    ("op", "/"),
    ("format", "1x"),
    ("string", "Xk aqkIe"),
    ("op", "/"),
    ("format", "1x"),
    ("string", "UxKw"),
    ("integer", "3"),
    ("op", "("),
    ("op", "/"),
    ("format", "1x"),
    ("integer", "3"),
    ("format", "f12.6"),
    ("op", ")"),
    ("op", "/"),
    ("string", " RxpO"),
    ("op", "/"),
    ("integer", "3"),
    ("format", "f8.2"),
    ("integer", "3"),
    ("format", "f7.2"),
    ("op", "/"),
    ("format", "1x"),
    ("string", "McR"),
    ("integer", "3"),
    ("op", "("),
    ("op", "/"),
    ("format", "1x"),
    ("integer", "3"),
    ("format", "f12.6"),
    ("op", ")"),
    ("op", "/"),
    ("format", "1x"),
    ("string", "HPi"),
    ("string", "EBx,Qyn "),
    ("integer", "2"),
    ("format", "f6.1"),
    ("string", " Qs>:-I "),
    ("integer", "3"),
    ("format", "f6.2"),
    ("op", "/"),
    ("format", "1x"),
    ("string", "We,JkC,HIoR,Nb,JRG"),
    ("string", "RgMhBn JHyUK<>:lK"),
    ("integer", "6"),
    ("format", "f9.6"),
    ("op", "/"),
    ("format", "1x"),
    ("string", "K^dT "),
    ("integer", "3"),
    ("op", "("),
    ("op", "/"),
    ("format", "1x"),
    ("integer", "3"),
    ("format", "f12.6"),
    ("op", ")")]

def compare_floats(v, val):
  from math import frexp
  vm, ve = frexp(val)
  scale = 2.0**(-ve)
  delta = abs(v*scale - val*scale)
  return delta < 1.e-14

def exercise_fem_utils_string_to_double():
  stream_end = 256
  err_eoi = "End of input while reading floating-point value."
  err_inv = "Invalid character while reading floating-point value: "
  err_oor = "Out-of-range error while reading floating-point value."
  f = fable.exercise_fem_utils_string_to_double
  def check(str, err=None):
    v,e,n = f(str=str)
    if (err is not None):
      assert e == err
      assert v == 0
    else:
      assert e is None
      val = float(str)
      assert compare_floats(v, val)
      assert n == stream_end
      vx,e,n = f(str=str+"x")
      assert e is None
      assert n == ord("x")
    return v,e,n
  for str in ["", " ", "\t", " \t"]:
    check(str, err=err_eoi)
  check("0")
  check("1")
  check("12")
  check(".1")
  check("1.")
  check("-1")
  check("-.1")
  check("-1.")
  check("+1.")
  check("0.1")
  check(".01")
  check("0.01")
  check("0.012")
  check("0.0012")
  check("00.0012")
  check("1234567890")
  check("12345678901234567890")
  check("123456789012345678901234567890")
  check(".12")
  check("1.2")
  check("12.")
  check("012.")
  check("12.34")
  check("123.4")
  check("1234.")
  check("2.3e0")
  check("2.345e1")
  check("2.345e2")
  check("2.345e3")
  check("2.345e4")
  check("2.345e5")
  check("2.345e+305")
  check("2.345e-1")
  check("2.345e-2")
  check("2.345e-3")
  check("2.345e-4")
  check("2.345e-5")
  check("2.345e-305")
  v,e,n = check("000.0000000000000000000002345e-5")
  assert "%.3f" % (v * 1e27) == "2.345"
  v,e,n = f("2.345e45")
  assert v == f("2.345E45")[0]
  assert v == f("2.345d45")[0]
  assert v == f("2.345D45")[0]
  v,e,n = f("1e305.")
  def chk():
    assert v != 0
    assert e is None
    assert n == ord(".")
  chk()
  v,e,n = f(".0001e309.")
  chk()
  v,e,n = f("1e-305.")
  chk()
  v,e,n = f("10000e-309.")
  chk()
  v,e,n = f("1e3091")
  def chk():
    assert v == 0
    assert e == err_oor
    assert n == ord("1")
  chk()
  v,e,n = f("1e-3091")
  chk()
  v,e,n = f("xy")
  assert v == 0
  assert e == err_inv + '"x" (ordinal=120)'
  assert n == ord("y")
  v,e,n = f("3e")
  assert v == 0
  assert e == err_eoi
  assert n == stream_end
  v,e,n = f("3eyz")
  assert v == 0
  assert e == err_inv + '"y" (ordinal=121)'
  assert n == ord("z")
  v,e,n = f("eq")
  assert v == 0
  assert e == err_inv + '"e" (ordinal=101)'
  assert n == ord("q")
  v,e,n = f('"\'')
  assert v == 0
  assert e == err_inv + "'\"' (double quote, ordinal=34)"
  assert n == ord("'")
  v,e,n = f("'\"")
  assert v == 0
  assert e == err_inv + '"\'" (single quote, ordinal=39)'
  assert n == ord('"')
  from libtbx.utils import to_bytes
  v,e,n = f(to_bytes(chr(134)+'x', codec='latin-1'))
  assert v == 0
  assert e == err_inv + 'ordinal=134'
  assert n == ord("x")

def exercise_fem_utils_string_to_double_fmt():
  f = fable.exercise_fem_utils_string_to_double_fmt
  def check(str, w, d, blanks_zero, exp_scale, val):
    v,e,n = f(str=str, w=w, d=d, blanks_zero=blanks_zero, exp_scale=exp_scale)
    assert e is None
    assert n == ord("4")
    assert compare_floats(v, val)
  check("   4", 3, 0, False, 0, 0.)
  check("   4", 3, 0, True, 0, 0.)
  #
  # compare with test/valid/read_fmt_double.f
  check("1234", 3, 0, False, 0, 123.)
  check("1234", 3, 1, False, 0, 12.3)
  check("1234", 3, 2, False, 0, 1.23)
  check(".234", 3, 2, False, 0, 0.23)
  check("1.34", 3, 2, False, 0, 1.3)
  check("12.4", 3, 2, False, 0, 12.)
  check("1 34", 3, 0, False, 0, 13.)
  check("1 34", 3, 0, True, 0, 103.)
  check("1234", 3, 0, False, 1, 12.3)
  check("1234", 3, 0, False, 2, 1.23)
  check("1234", 3, 0, False, -1, 1230.)
  check("1234", 3, 0, False, -2, 12300.)
  check("1e34", 3, 0, False, 1, 1000.)
  check("3 5 e 1 24", 9, 0, False, 0, 35000000000000.)
  check("3 5 e 1 24", 9, 0, True, 0, 3.05e105)
  check("3 5 e 1 24", 9, 1, False, 0, 3500000000000.)
  check("3 5 e 1 24", 9, 1, True, 0, 3.05e104)

def run(args):
  assert len(args) == 0
  for f in [fable.py_unsigned_integer_scan,
               fable.unsigned_integer_scan]:
    exercise_unsigned_integer_scan(f)
  for f in [fable.py_floating_point_scan_after_exponent_char,
               fable.floating_point_scan_after_exponent_char]:
    exercise_floating_point_scan_after_exponent_char(f)
  for f in [fable.py_floating_point_scan_after_dot,
               fable.floating_point_scan_after_dot]:
    exercise_floating_point_scan_after_dot(f)
  for f in [fable.py_identifier_scan,
               fable.identifier_scan]:
    exercise_identifier_scan(f)
  for f in [fable.py_find_closing_parenthesis,
               fable.find_closing_parenthesis]:
    exercise_find_closing_parenthesis(f)
  if (fable.ext is not None):
    exercise_fem_utils_split_comma_separated()
    exercise_fem_utils_int_types()
    exercise_fem_real_types()
    exercise_fem_format_tokenizer()
    exercise_fem_utils_string_to_double()
    exercise_fem_utils_string_to_double_fmt()
  print ("OK")

if (__name__ == "__main__"):
  import sys
  run(args=sys.argv[1:])


 *******************************************************************************


 *******************************************************************************
fable/tst_read.py
from __future__ import absolute_import, division, print_function
from fable import read
from libtbx.test_utils import Exception_expected, approx_equal, show_diff
import libtbx.load_env
import os
op = os.path

def exercise_strip_spaces_separate_strings():
  from fable.read import Error, source_line, strip_spaces_separate_strings
  import itertools
  global_line_index_generator = itertools.count()
  def slc(cmbnd):
    return [
      source_line(
        global_line_index_generator=global_line_index_generator,
        file_name="str",
        line_number=i+1,
        text="      "+line)
          for i,line in enumerate(cmbnd.splitlines())]
  def check(cmbnd, expected_code, expected_strings):
    for cmbnd_work,expected_strings_work in [
          (cmbnd, expected_strings),
          (cmbnd.replace("'", '"'), [s.replace("'", '"')
            for s in expected_strings])]:
      ssl = strip_spaces_separate_strings(source_line_cluster=slc(cmbnd_work))
      assert not show_diff(ssl.code, expected_code)
      assert len(ssl.strings) == len(ssl.string_indices)
      assert ssl.strings == expected_strings_work
      expected_string_indices = []
      for i,c in enumerate(expected_code):
        if (c == "'" or c == '"'):
          expected_string_indices.append(i)
      assert ssl.string_indices == expected_string_indices
      if (cmbnd.find('"') > 0):
        break
  check("a = 0", "a=0", [])
  check("a = ''", "a='", [""])
  check("a = '\"'", "a='", ["\""])
  check("a = \"'\"", "a='", ["'"])
  check("a = 'x'", "a='", ["x"])
  check("a = ' x ' ", "a='", [" x "])
  check("a = ''''", "a='", ["'"])
  check("call foo('')", "callfoo(')", [""])
  check("call foo('''')", "callfoo(')", ["'"])
  check("c a l l f o   o ( ''''  )  ", "callfoo(')", ["'"])
  check("   c   a   l   l   f   o   o ( ''''  )  ", "callfoo(')", ["'"])
  check("   C  A   L  LF   O O ( ' abc '''' def '''  , ' g''h''i''' , X )  ",
    "callfoo(',',x)", [" abc '' def '", " g'h'i'"])
  check("a = '\n'", "a='", [""])
  check("a = 'x\n'", "a='", ["x"])
  check("a = '\ny'", "a='", ["y"])
  check("a = 'x\ny'", "a='", ["xy"])
  check("a = '''\n'", "a='", ["'"])
  check("a = '\n'''", "a='", ["'"])
  check("a = '''\n'''", "a='", ["''"])
  #
  for cmbnd,q,nd in [("'abc", "'", 9), ('x="', '"', 11)]:
    try:
      strip_spaces_separate_strings(source_line_cluster=slc(cmbnd))
    except Error as e:
      assert not show_diff(str(e), """\
Missing terminating %s character:
  at str(1):
  |      %s|
%s^""" % (q, cmbnd, "-"*nd))
    else: raise Exception_expected

def exercise_valid(verbose):
  t_dir = libtbx.env.under_dist(
    module_name="fable", path="test/valid", test=op.isdir)
  #
  read_already = set()
  def get_fprocs(file_name):
    if (verbose):
      print("exercise_valid:", file_name)
    read_already.add(file_name)
    return read.process(file_names=[op.join(t_dir, file_name)])
  #
  def get_program(file_name):
    fprocs = get_fprocs(file_name)
    assert len(fprocs.program) == 1
    assert len(fprocs.subroutine) == 0
    assert len(fprocs.function) == 0
    assert len(fprocs.blockdata) == 0
    return fprocs.program[0]
  #
  prog = get_program("goto_forms.f")
  keys = [ei.key for ei in prog.executable]
  assert not show_diff("\n".join(keys), """\
goto_computed
goto_computed
goto_computed
goto_computed
continue
continue""")
  #
  get_program("string_spanning_continuation_lines.f")
  #
  fprocs = get_fprocs("sf.f")
  assert len(fprocs.program) == 1
  assert len(fprocs.subroutine) == 1
  #
  for file_name in sorted(os.listdir(t_dir)):
    if (file_name.endswith(".f") and not file_name in read_already):
      get_fprocs(file_name)

def exercise_lenient(verbose):
  t_dir = libtbx.env.under_dist(
    module_name="fable", path="test/lenient", test=op.isdir)
  #
  def get(file_name):
    if (verbose):
      print("exercise_lenient:", file_name)
    return read.process(file_names=[op.join(t_dir, file_name)])
  #
  get("str_blank_str.f")
  get("str_cont_line_str.f")

def exercise_syntax_error(verbose):
  t_dir = libtbx.env.under_dist(
    module_name="fable", path="test/syntax_error", test=op.isdir)
  def fail(file_name):
    if (verbose):
      print("exercise_syntax_error:", file_name)
    read.process(file_names=[op.join(t_dir, file_name)])
  from fable.read import Error
  try:
    fail("label_cont_char.f")
  except Error as e:
    assert str(e).startswith(
      "A continuation character is illegal on a line with a statement label:")
    assert str(e).endswith("""\
  |    3xk=6|
--------^""")
  else: raise Exception_expected
  try:
    fail("label_empty.f")
  except Error as e:
    assert str(e).startswith("Labelled statement is empty:")
    assert str(e).endswith("""\
  |    1  |
---------^""")
  else: raise Exception_expected
  try:
    fail("not_an_identifier.f")
  except Error as e:
    assert str(e).startswith("Syntax error:")
    assert str(e).endswith("""\
  |      external a, x%z|
----------------------^""")
  else: raise Exception_expected
  try:
    fail("bare_integer_i.f")
  except Error as e:
    assert str(e).startswith("Missing END for PROGRAM:")
    assert str(e).endswith("  |      integer i|")
  else: raise Exception_expected
  try:
    fail("closing_parenthesis_without_matching.f")
  except Error as e:
    assert str(e).startswith(
      'Closing ")" without a matching opening parenthesis:')
    assert str(e).endswith("""\
  |      a = 0)|
--------------^""")
  else: raise Exception_expected
  try:
    fail("opening_parenthesis_without_matching.f")
  except Error as e:
    assert str(e).startswith(
      'Missing a closing ")":')
    assert str(e).endswith("""\
  |      a = (0|
-------------^""")
  else: raise Exception_expected
  try:
    fail("dot_e.f")
  except Error as e:
    assert str(e).startswith("Syntax error:")
    assert str(e).endswith("""\
  |        x       =       .e0|
----------------------------^""")
  else: raise Exception_expected
  try:
    fail("x_assign_dot.f")
  except Error as e:
    assert str(e).startswith("Expression unexpectedly ends with a dot:")
    assert str(e).endswith("""\
  |      x = .|
-------------^""")
  try:
    fail("x_assign_dot_2.f")
  except Error as e:
    assert str(e).startswith("Expression unexpectedly ends with a dot:")
    assert str(e).endswith("""\
  |        x = .|
---------------^""")
  else: raise Exception_expected
  try:
    fail("x_assign_1ex.f")
  except Error as e:
    assert str(e).startswith("Invalid floating-point literal:")
    assert str(e).endswith("""\
  |      x = 1ex|
---------------^""")
  else: raise Exception_expected
  try:
    fail("x_assign_1dotd.f")
  except Error as e:
    assert str(e).startswith("Syntax error:")
    assert str(e).endswith("""\
  |      x = 1.d|
---------------^""")
  else: raise Exception_expected
  try:
    fail("bad_false.f")
  except Error as e:
    assert str(e).startswith("Syntax error:")
    assert str(e).endswith("""\
  |      a = .fals.|
--------------^""")
  else: raise Exception_expected
  try:
    fail("bad_true.f")
  except Error as e:
    assert str(e).startswith("Syntax error:")
    assert str(e).endswith("""\
  |      a = .true|
--------------^""")
  else: raise Exception_expected
  try:
    fail("bad_not.f")
  except Error as e:
    assert str(e).startswith("Syntax error:")
    assert str(e).endswith("""\
  |      a = .not b|
--------------^""")
  else: raise Exception_expected
  try:
    fail("bad_not_2.f")
  except Error as e:
    assert str(e).startswith("Syntax error:")
    assert str(e).endswith("""\
  |      a = 1 .not. b|
----------------^""")
  else: raise Exception_expected
  try:
    fail("bad_gt.f")
  except Error as e:
    assert str(e).startswith("Syntax error:")
    assert str(e).endswith("""\
  |      a = 1 .gt 2|
----------------^""")
  else: raise Exception_expected
  try:
    fail("bad_after_dot.f")
  except Error as e:
    assert str(e).startswith("Syntax error:")
    assert str(e).endswith("""\
  |      a = 1 .2et. 2|
----------------^""")
  else: raise Exception_expected
  try:
    fail("j_assign_i_percent_5.f")
  except Error as e:
    assert str(e).startswith("Syntax error:")
    assert str(e).endswith("""\
  |      j = i % 5|
---------------^""")
  else: raise Exception_expected
  try:
    fail("bad_and.f")
  except Error as e:
    assert str(e).startswith("Syntax error:")
    assert str(e).endswith("""\
  |      a = b .ad. c|
-----------------^""")
  else: raise Exception_expected
  try:
    fail("bad_or.f")
  except Error as e:
    assert str(e).startswith("Syntax error:")
    assert str(e).endswith("""\
  |      a = b .or c|
-----------------^""")
  else: raise Exception_expected
  try:
    fail("exclamation_mark_syndrome.f")
  except Error as e:
    assert str(e).startswith("Missing terminating ' character:")
    assert str(e).endswith("""\
  |     !ef'|
-----------^""")
  else: raise Exception_expected
  try:
    fail("common_with_data_size.f")
  except Error as e:
    assert str(e).startswith("Syntax error:")
    assert str(e).endswith("""\
  |      common /com/ vals(2), nums*4(2)|
-----------------------------------^""")
  else: raise Exception_expected
  try:
    fail("dimension_with_data_size.f")
  except Error as e:
    assert str(e).startswith("Syntax error:")
    assert str(e).endswith("  |      dimension strings*4(2)|")
  else: raise Exception_expected
  try:
    fail("save_with_dims.f")
  except Error as e:
    assert str(e).startswith("Syntax error:")
    assert str(e).endswith("  |      save nums(2)|")
  else: raise Exception_expected
  try:
    fail("sub_no_name.f")
  except Error as e:
    assert str(e).startswith("Syntax error:")
    assert str(e).endswith("""\
  |      subroutine|
------------------^""")
  else: raise Exception_expected
  try:
    fail("sub_percent_3.f")
  except Error as e:
    assert str(e).startswith("Syntax error:")
    assert str(e).endswith("""\
  |      subroutine sub % 3|
------------------------^""")
  else: raise Exception_expected
  try:
    fail("sub_open_parenthesis.f")
  except Error as e:
    assert str(e).startswith('Missing a closing ")":')
    assert str(e).endswith("""\
  |      subroutine sub(|
-----------------------^""")
  else: raise Exception_expected
  try:
    fail("sub_bad_comma.f")
  except Error as e:
    assert str(e).startswith("Syntax error:")
    assert str(e).endswith("""\
  |      subroutine sub(a,)|
--------------------------^""")
  else: raise Exception_expected
  try:
    fail("fun_star.f")
  except Error as e:
    assert str(e).startswith("Syntax error:")
    assert str(e).endswith("""\
  |      function fun(a,*)|
------------------------^""")
  else: raise Exception_expected
  try:
    fail("sub_bad_trailing.f")
  except Error as e:
    assert str(e).startswith("Syntax error:")
    assert str(e).endswith("""\
  |      subroutine sub(a,b) x|
-----------------------------^""")
  else: raise Exception_expected
  try:
    fail("save_bad_comma.f")
  except Error as e:
    assert str(e).startswith("Syntax error:")
    assert str(e).endswith("""\
  |      save num,|
-----------------^""")
  else: raise Exception_expected
  try:
    fail("save_num_comma_colon.f")
  except Error as e:
    assert str(e).startswith("Syntax error:")
    assert str(e).endswith("""\
  |      save num, :|
-------------------^""")
  else: raise Exception_expected
  try:
    fail("save_num_val_colon.f")
  except Error as e:
    assert str(e).startswith("Syntax error:")
    assert str(e).endswith("""\
  |      save num, val :|
-----------------------^""")
  else: raise Exception_expected
  try:
    fail("bare_external.f")
  except Error as e:
    assert str(e).startswith("Syntax error:")
    assert str(e).endswith("""\
  |      external|
----------------^""")
  else: raise Exception_expected
  try:
    fail("save_slash_slash.f")
  except Error as e:
    assert str(e).startswith("Syntax error:")
    assert str(e).endswith("""\
  |      save //|
--------------^""")
  else: raise Exception_expected
  try:
    fail("bare_data.f")
  except Error as e:
    assert str(e).startswith("Syntax error:")
    assert str(e).endswith("""\
  |      data|""")
  else: raise Exception_expected
  try:
    fail("data_plus_repetition.f")
  except Error as e:
    assert str(e).startswith("Syntax error:")
    assert str(e).endswith("""\
  |      data nums /+2*3/|
----------------------^""")
  else: raise Exception_expected
  try:
    fail("bad_format_1.f")
  except Error as e:
    assert str(e).startswith('Format string must start with "("')
    assert str(e).endswith("""\
  |      write(6, '') num|
------------------^""")
  else: raise Exception_expected
  try:
    fail("bad_format_2.f")
  except Error as e:
    assert str(e).startswith('Format string must end with ")"')
    assert str(e).endswith("""\
  |      write(6, '(') num|
------------------^""")
  else: raise Exception_expected
  try:
    fail("bad_format_3.f")
  except Error as e:
    assert str(e).startswith("""\
Missing terminating ' within character format specifier "(')":""")
    assert str(e).endswith("""\
  |      write(6, '('')')|
--------------------^""")
  else: raise Exception_expected
  try:
    fail("bad_format_4.f")
  except Error as e:
    assert str(e).startswith("Invalid FORMAT specification:")
    assert str(e).endswith("""\
  |      write(6, '(+2x)')|
--------------------^""")
  else: raise Exception_expected
  try:
    fail("bad_format_5.f")
  except Error as e:
    assert str(e).startswith("Invalid FORMAT specification:")
    assert str(e).endswith("""\
  |      write(6, '(i2.)')|
----------------------^""")
  else: raise Exception_expected
  try:
    fail("bad_format_6.f")
  except Error as e:
    assert str(e).startswith("Invalid FORMAT specification:")
    assert str(e).endswith("""\
  |      write(6, '(tx)')|
---------------------^""")
  else: raise Exception_expected
  try:
    fail("bad_format_7.f")
  except Error as e:
    assert str(e).startswith("Invalid FORMAT specification:")
    assert str(e).endswith("""\
  |      write(6, '(tl)')|
---------------------^""")
  else: raise Exception_expected
  try:
    fail("format_without_label.f")
  except Error as e:
    assert str(e).startswith(
      "FORMAT without a statement label in columns 1-5:")
    assert str(e).endswith("""\
  |        format(1x)|
-----------^""")
  try:
    fail("duplicate_format_label.f")
  except Error as e:
    assert str(e).startswith(
      "Duplicate statement label in columns 1-5:")
    assert str(e).endswith("""\
  |   10 format(i2)|
---^""")
  else: raise Exception_expected
  try:
    fail("bad_implied_do_1.f")
  except Error as e:
    assert str(e).startswith("Syntax error:")
    assert str(e).endswith("""\
  |      write(6, *) (i,i=1)|
---------------------------^""")
  else: raise Exception_expected
  try:
    fail("bad_implied_do_2.f")
  except Error as e:
    assert str(e).startswith("Syntax error:")
    assert str(e).endswith("""\
  |      write(6, *) (i=1,2)|
-----------------------^""")
  else: raise Exception_expected
  try:
    fail("bad_implied_do_3.f")
  except Error as e:
    assert str(e).startswith("Syntax error:")
    assert str(e).endswith("""\
  |      write(6, *) i,i=1,2|
------------------------^""")
  else: raise Exception_expected
  try:
    fail("bad_implied_do_4.f")
  except Error as e:
    assert str(e).startswith("Syntax error:")
    assert str(e).endswith("""\
  |      write(6, *) (i,i=1,j=2)|
-----------------------------^""")
  else: raise Exception_expected
  try:
    fail("bad_implied_do_5.f")
  except Error as e:
    assert str(e).startswith("Syntax error:")
    assert str(e).endswith("""\
  |      write(6, *) (i,0=1,2)|
-------------------------^""")
  else: raise Exception_expected
  try:
    fail("bad_implied_do_6.f")
  except Error as e:
    assert str(e).startswith("Syntax error:")
    assert str(e).endswith("""\
  |      write(6, *) (i,i+j=1,2)|
---------------------------^""")
  else: raise Exception_expected
  try:
    fail("bad_data.f")
  except Error as e:
    assert str(e).startswith("Syntax error:")
    assert str(e).endswith("""\
  |      data (nums(i),i) /1,2/|
------------------------^""")
  else: raise Exception_expected
  try:
    fail("read_star_comma_empty.f")
  except Error as e:
    assert str(e).startswith("Syntax error:")
    assert str(e).endswith("""\
  |      read *,|
---------------^""")
  else: raise Exception_expected
  try:
    fail("read_star_name.f")
  except Error as e:
    assert str(e).startswith("Syntax error:")
    assert str(e).endswith("""\
  |      read * name|
----------------^""")
  else: raise Exception_expected
  try:
    fail("read_plus_name.f")
  except Error as e:
    assert str(e).startswith("Syntax error:")
    assert str(e).endswith("""\
  |      read + name|
--------------^""")
  else: raise Exception_expected
  try:
    fail("bare_print.f")
  except Error as e:
    assert str(e).startswith("Syntax error:")
    assert str(e).endswith("""\
  |      print|
-------------^""")
  else: raise Exception_expected

def exercise_semantic_error(verbose):
  t_dir = libtbx.env.under_dist(
    module_name="fable", path="test/semantic_error", test=op.isdir)
  from fable import SemanticError
  def fail(file_name):
    if (verbose):
      print("exercise_semantic_error:", file_name)
    read.process(file_names=[op.join(t_dir, file_name)])
  try:
    fail("missing_include.f")
  except SemanticError as e:
    assert str(e).startswith("Missing include file:")
    assert str(e).endswith("""\
  |      include '/bin/sh/should/never/exist'|
-----------------^""")
  else: raise Exception_expected
  try:
    fail("real_declared_twice.f")
  except SemanticError as e:
    assert str(e).startswith("Conflicting or repeated declaration: val:")
    assert str(e).endswith("""\
  |      real val|
--------------^""")
  else: raise Exception_expected
  try:
    fail("external_array.f")
  except SemanticError as e:
    assert str(e).startswith("Conflicting or repeated declaration: f2:")
    assert str(e).endswith("""\
  |      external f2|
------------------^""")
  else: raise Exception_expected
  try:
    fail("dimension_unknown_data_type.f")
  except SemanticError as e:
    assert str(e).startswith("Unknown data type: nums:")
    assert str(e).endswith("""\
  |      write(6, *) nums(1)|
---------------------^""")
  else: raise Exception_expected
  try:
    fail("dims_repeated_in_dimension.f")
  except SemanticError as e:
    assert str(e).startswith("Conflicting or repeated dimension: num:")
    assert str(e).endswith("""\
  |      dimension num(2)|
-------------------^""")
  else: raise Exception_expected
  try:
    fail("dims_repeated_in_common.f")
  except SemanticError as e:
    assert str(e).startswith("Conflicting or repeated dimension: num:")
    assert str(e).endswith("""\
  |      common /com/ num(2)|
----------------------^""")
  else: raise Exception_expected
  try:
    fail("parameter_array.f")
  except SemanticError as e:
    assert str(e).startswith("Conflicting or repeated declaration: nums:")
    assert str(e).endswith("""\
  |      integer nums(2)|
-----------------^""")
  else: raise Exception_expected
  try:
    fail("parameter_in_common.f")
  except SemanticError as e:
    assert str(e).startswith("Conflicting or repeated declaration: num:")
    assert str(e).endswith("""\
  |      common /com/ num|
----------------------^""")
  else: raise Exception_expected
  try:
    fail("parameter_save.f")
  except SemanticError as e:
    assert str(e).startswith("Conflicting or repeated declaration: num:")
    assert str(e).endswith("""\
  |      save num|
--------------^""")
  else: raise Exception_expected
  try:
    fail("parameter_in_sub_args.f")
  except SemanticError as e:
    assert str(e).startswith("Conflicting or repeated declaration: num:")
    assert str(e).endswith("""\
  |      parameter(num=0)|
-------------------^""")
  else: raise Exception_expected
  try:
    fail("twice_in_sub_args.f")
  except SemanticError as e:
    assert str(e).startswith("Conflicting or repeated declaration: val:")
    assert str(e).endswith("""\
  |      subroutine sub(val, val)|
-----------------------------^""")
  else: raise Exception_expected
  try:
    fail("subroutine_name_is_also_arg.f")
  except SemanticError as e:
    assert str(e).startswith("Conflicting or repeated declaration: sub:")
    assert str(e).endswith("""\
  |      subroutine sub(sub)|
------------------------^""")
  else: raise Exception_expected
  try:
    fail("function_name_is_also_arg.f")
  except SemanticError as e:
    assert str(e).startswith("Conflicting or repeated declaration: fun:")
    assert str(e).endswith("""\
  |      function fun(fun)|
----------------------^""")
  else: raise Exception_expected
  try:
    fail("unknown_intrinsic.f")
  except SemanticError as e:
    assert str(e).startswith("Unknown intrinsic: unk:")
    assert str(e).endswith("""\
  |      write(6, *) unk(0)|
---------------------^""")
  else: raise Exception_expected
  try:
    fail("intrinsic_common.f")
  except SemanticError as e:
    assert str(e).startswith("Conflicting or repeated declaration: abs:")
    assert str(e).endswith("""\
  |      intrinsic abs|
-------------------^""")
  else: raise Exception_expected
  try:
    fail("external_common.f")
  except SemanticError as e:
    assert str(e).startswith("Conflicting or repeated declaration: nums:")
    assert str(e).endswith("""\
  |      external nums|
------------------^""")
  else: raise Exception_expected
  try:
    fail("calling_array.f")
  except SemanticError as e:
    assert str(e).startswith("Conflicting declaration: nums:")
    assert str(e).endswith("""\
  |      call nums(3)|
--------------^""")
  else: raise Exception_expected
  try:
    fail("calling_dimension.f")
  except SemanticError as e:
    assert str(e).startswith("Conflicting declaration: nums:")
    assert str(e).endswith("""\
  |      call nums(2)|
--------------^""")
  else: raise Exception_expected
  try:
    fail("function_data_type_decl_twice.f")
  except SemanticError as e:
    assert str(e).startswith("Conflicting or repeated declaration: fun:")
    assert str(e).endswith("""\
  |      integer fun|
-----------------^""")
  else: raise Exception_expected
  try:
    fail("intrinsic_dimension.f")
  except SemanticError as e:
    assert str(e).startswith("Conflicting or repeated declaration: nint:")
    assert str(e).endswith("""\
  |      intrinsic nint|
-------------------^""")
  else: raise Exception_expected
  try:
    fail("sub_fun_2.f")
  except SemanticError as e:
    assert str(e).startswith("Conflicting declaration: fun:")
    assert str(e).endswith("""\
  |      y = fun(x)|
-------------^""")
  else: raise Exception_expected
  try:
    fail("write_without_unit.f")
  except SemanticError as e:
    assert str(e).startswith("Required UNIT information is not defined:")
    assert str(e).endswith("""\
  |      write(fmt='(i3)') num|
--------------^""")
  else: raise Exception_expected
  try:
    fail("write_end.f")
  except SemanticError as e:
    assert str(e).startswith("END is invalid for WRITE statements:")
    assert str(e).endswith("""\
  |      write(10, end=20) num|
-----------------------^""")
  else: raise Exception_expected
  try:
    fail("equivalence_external.f")
  except SemanticError as e:
    assert str(e).startswith("Invalid EQUIVALENCE:")
    assert str(e).endswith("""\
  |      equivalence (ne, nl)|
----------------------^""")
  else: raise Exception_expected

def exercise_unsupported(verbose):
  t_dir = libtbx.env.under_dist(
    module_name="fable", path="test/unsupported", test=op.isdir)
  def fail(file_name):
    if (verbose):
      print("exercise_unsupported:", file_name)
    read.process(file_names=[op.join(t_dir, file_name)])
  try:
    fail("hollerith_cont_lines.f")
  except RuntimeError as e:
    assert str(e).startswith(
      "FATAL: Not supported:"
      " FORMAT Hollerith edit descriptor spanning continuation lines:")
    assert str(e).endswith("""\
  |      write(6, '(4h|
--------------------^""")
  else: raise Exception_expected
  try:
    fail("hollerith_with_quotes.f")
  except RuntimeError as e:
    assert str(e).startswith(
      "FATAL: Not supported:"
      " FORMAT Hollerith edit descriptor with quotes:")
    assert str(e).endswith("""\
  |      write(6, '(2h'''')')|
--------------------^""")
  else: raise Exception_expected

def exercise_tokens_as_string(verbose):
  t_dir = libtbx.env.under_dist(
    module_name="fable", path="test/valid", test=op.isdir)
  from fable.tokenization import tokens_as_string
  for file_name in sorted(os.listdir(t_dir)):
    if (not file_name.endswith(".f")): continue
    if (verbose):
      print("exercise_tokens_as_string:", file_name)
    all_fprocs = read.process(file_names=[op.join(t_dir, file_name)])
    for fproc in all_fprocs.all_in_input_order:
      for ei in fproc.executable:
        if (ei.key == "write"):
          s = tokens_as_string(tokens=ei.iolist)
          if (verbose):
            print(s)
      for tokens in fproc.format.values():
        s = tokens_as_string(tokens=tokens)
        if (verbose):
          print(s)
      if (verbose):
        print()

def exercise_show():
  t_dir = libtbx.env.under_dist(
    module_name="fable", path="test/valid", test=op.isdir)
  all_fprocs = read.process(file_names=[op.join(t_dir, "subroutine_3.f")])
  from six.moves import StringIO
  cio = StringIO()
  all_fprocs.show_counts_by_type(out=cio, prefix="$ ")
  assert not show_diff(cio.getvalue(), """\
$ Counts by Fortran procedure type:
$   program: 1
$   subroutine: 3
$   function: 0
$   blockdata: 0
""")

def exercise_build_fprocs_by_name():
  t_dir = libtbx.env.under_dist(
    module_name="fable", path="test/valid", test=op.isdir)
  for pair in [
        ("subroutine_3.f", "subroutine_4.f"),
        ("implied_program.f", "implied_program.f")]:
    file_names = [op.join(t_dir, file_name) for file_name in pair]
    all_fprocs = read.process(file_names=file_names)
    from libtbx.utils import Sorry
    try:
      all_fprocs.fprocs_by_name()
    except Sorry as e:
      if (pair[0] == "subroutine_3.f"):
        assert str(e).startswith("Fortran procedure name conflict:")
        assert str(e).endswith("  -----------------^")
      else:
        assert str(e).startswith("""\
Fortran procedure name conflict:
  1. definition: program_unnamed (implied)
    before """)
        assert str(e).endswith("implied_program.f(2)")
    else: raise Exception_expected

def exercise_eval_const_expression_simple(verbose):
  t_dir = libtbx.env.under_dist(
    module_name="fable", path="test/valid", test=op.isdir)
  file_name = "const_expressions.f"
  all_fprocs = read.process(file_names=[op.join(t_dir, file_name)])
  assert len(all_fprocs.all_in_input_order) == 2
  fproc = all_fprocs.all_in_input_order[0]
  val = fproc.eval_const_expression_simple(identifier="n5")
  assert val == 296356
  for identifier,expected_vals in [
        ("nums1", [3,2]),
        ("nums2", [1,3]),
        ("nums3", [4])]:
    vals = fproc.eval_dimensions_simple(
      dim_tokens=fproc.fdecl_by_identifier[identifier].dim_tokens)
    assert vals == expected_vals
  vals = fproc.eval_dimensions_simple(
    dim_tokens=fproc.fdecl_by_identifier["nums3"].dim_tokens,
    allow_power=False)
  assert vals == [None]
  fproc = all_fprocs.all_in_input_order[1]
  vals = fproc.eval_dimensions_simple(
    dim_tokens=fproc.fdecl_by_identifier["nums"].dim_tokens)
  assert vals == [None, None]
  #
  file_name = "const_expressions_2.f"
  all_fprocs = read.process(file_names=[op.join(t_dir, file_name)])
  assert len(all_fprocs.all_in_input_order) == 1
  fproc = all_fprocs.all_in_input_order[0]
  val = fproc.eval_const_expression_simple(identifier="n5f")
  assert approx_equal(val, 297845.226131)

def run(args):
  assert args in [[], ["--verbose"]]
  verbose = (len(args) != 0)
  exercise_strip_spaces_separate_strings()
  exercise_valid(verbose=verbose)
  exercise_lenient(verbose=verbose)
  exercise_syntax_error(verbose=verbose)
  exercise_semantic_error(verbose=verbose)
  exercise_unsupported(verbose=verbose)
  exercise_tokens_as_string(verbose=verbose)
  exercise_show()
  exercise_build_fprocs_by_name()
  exercise_eval_const_expression_simple(verbose=verbose)
  print("OK")

if (__name__ == "__main__"):
  import sys
  run(args=sys.argv[1:])


 *******************************************************************************


 *******************************************************************************
fable/utils.py
from __future__ import absolute_import, division, print_function
from six.moves import zip
class unique_list(object):

  __slots__ = ["value_list", "value_set"]

  def __init__(O):
    O.value_list = []
    O.value_set = set()

  def __contains__(O, value):
    return value in O.value_set

  def append(O, value):
    if (value not in O.value_set):
      O.value_list.append(value)
      O.value_set.add(value)

class keyed_lists(object):

  __slots__ = ["indices_by_key", "keys", "lists"]

  def __init__(O):
    O.indices_by_key = {}
    O.keys = []
    O.lists = []

  def get(O, key):
    class undef(object): pass
    i = O.indices_by_key.get(key, undef)
    if (i is undef):
      O.indices_by_key[key] = len(O.keys)
      O.keys.append(key)
      result = []
      O.lists.append(result)
      return result
    return O.lists[i]

  def items(O):
    return list(zip(O.keys, O.lists))


 *******************************************************************************
