

 *******************************************************************************
scitbx/graph/__init__.py
"""
graph
"""

from __future__ import division


 *******************************************************************************


 *******************************************************************************
scitbx/graph/rigidity.py
from __future__ import absolute_import, division, print_function
import random
from six.moves import range
from six.moves import zip

def gcd(a, b):
  ri = a
  if (ri < 0): ri = -ri
  rj = b
  if (rj != 0):
    while True:
      rk = ri % rj
      if (rk == 0):
        ri = rj
        break
      ri = rj % rk
      if (ri == 0):
        ri = rk
        break
      rj = rk % ri
      if (rj == 0):
        break
    if (ri < 0): ri = -ri
  return ri

def integer_row_echelon_form(m):
  free_vars = []
  n_rows = len(m)
  n_cols = len(m[0])
  piv_r = 0
  piv_c = 0
  while (piv_c < n_cols):
    best_r = None
    min_v = 0
    for i_row in range(piv_r, n_rows):
      v = abs(m[i_row][piv_c])
      if (v != 0 and (min_v == 0 or v < min_v)):
        min_v = v
        best_r = i_row
    if (best_r is not None):
      if (best_r != piv_r):
        m[piv_r], m[best_r] = m[best_r], m[piv_r]
      fp = m[piv_r][piv_c]
      for r in range(piv_r+1, n_rows):
        fr = m[r][piv_c]
        if (fr == 0): continue
        g = 0
        for c in range(piv_c, n_cols):
          m[r][c] = m[r][c] * fp - m[piv_r][c] * fr
          g = gcd(m[r][c], g)
        if (g > 1):
          for c in range(piv_c, n_cols):
            m[r][c] //= g
      piv_r += 1
    else:
      free_vars.append(piv_c)
    piv_c += 1
  return free_vars

def float_row_echelon_form(
      m,
      zero_pivot_tolerance=1.e-8,
      min_non_zero_pivot=1.e-2):
  free_vars = []
  n_rows = len(m)
  n_cols = len(m[0])
  piv_r = 0
  piv_c = 0
  while (piv_c < n_cols):
    # search for best pivot
    best_r = None
    max_v = zero_pivot_tolerance
    for i_row in range(piv_r, n_rows):
      v = abs(m[i_row][piv_c])
      if (v > max_v):
        max_v = v
        best_r = i_row
    if (best_r is not None):
      if (max_v < min_non_zero_pivot):
        return None
      if (best_r != piv_r):
        m[piv_r], m[best_r] = m[best_r], m[piv_r]
      fp = m[piv_r][piv_c]
      for r in range(piv_r+1, n_rows):
        fr = m[r][piv_c]
        if (fr == 0): continue
        for c in range(piv_c, n_cols):
          m[r][c] -= m[piv_r][c] * fr / fp
      piv_r += 1
    else:
      free_vars.append(piv_c)
    piv_c += 1
  return free_vars

def float_row_echelon_form_is_redundant(
      m,
      free_vars,
      addl_row,
      zero_pivot_tolerance=1.e-6,
      min_non_zero_pivot=1.e-3):
  n_rows = len(m)
  n_cols = len(m[0])
  assert len(addl_row) == n_cols
  free_flags = [False] * n_cols
  for c in free_vars:
    free_flags[c] = True
  def approx_zero(c):
    v = abs(addl_row[c])
    if (v < zero_pivot_tolerance):
      return True
    if (v < min_non_zero_pivot):
      return None
    return False
  piv_c = 0
  for piv_r in range(n_cols-len(free_vars)):
    while (free_flags[piv_c]):
      az = approx_zero(c=piv_c)
      if (not az): return az
      piv_c += 1
    fp = m[piv_r][piv_c]
    fr = addl_row[piv_c]
    if (fr != 0):
      for c in range(piv_c, n_cols):
        addl_row[c] -= m[piv_r][c] * fr / fp
    piv_c += 1
  for c in range(piv_c, n_cols):
    az = approx_zero(c=c)
    if (not az): return az
  return True

def float_row_echelon_form_back_substitution(m, free_vars, sol):
  n_rows = len(m)
  n_cols = len(m[0])
  assert len(sol) == n_cols
  free_flags = [False] * n_cols
  for c in free_vars:
    free_flags[c] = True
  piv_cols = []
  for c,f in enumerate(free_flags):
    if (not f): piv_cols.append(c)
  for r in range(len(piv_cols)-1,-1,-1):
    piv_c = piv_cols[r]
    s = 0
    for c in range(piv_c+1, n_cols):
      s += m[r][c] * sol[c]
    sol[piv_c] = -s / m[r][piv_c]

def create_fake_integer_vertices(n_dim, n_vertices):
  # Idea due to Neil Sloane
  assert n_vertices != 0
  v0 = list(range(2,2+n_dim))
  result = [v0]
  while (len(result) != n_vertices):
    vertex = []
    for i in range(n_dim):
      vertex.append(v0[i] * result[-1][i])
    result.append(vertex)
  # Shuffle coordinates. Required to obtain correct result for
  # "K6,6 minus six parallel edges" (Figure 3.23 of J.E. Graver,
  # Counting on Frameworks, 2001).
  for i in range(len(result)):
    vertex = result[i]
    j = i % n_dim
    result[i] = vertex[j:] + vertex[:j]
  return result

def create_fake_float_vertices(n_dim, n_vertices, max_coordinate=1.e4):
  assert n_vertices != 0
  result = []
  while (len(result) != n_vertices):
    vertex = []
    for i in range(n_dim):
      vertex.append(random.random()*max_coordinate)
    result.append(vertex)
  return result

def construct_numeric_rigidity_matrix(n_dim, vertices, edge_list):
  if (len(edge_list) == 0): return None
  n_columns = len(vertices) * n_dim
  result = []
  for i,j in edge_list:
    assert i != j
    row = [0] * n_columns
    dij = [vi-vj for vi,vj in zip(vertices[i], vertices[j])]
    def copy_to_row(c, sign):
      c *= n_dim
      for d in range(n_dim):
        row[c+d] = sign * dij[d]
    copy_to_row(c=i, sign= 1)
    copy_to_row(c=j, sign=-1)
    result.append(row)
  return result

def construct_integer_rigidity_matrix(n_dim, n_vertices, edge_list):
  vertices = create_fake_integer_vertices(
    n_vertices=n_vertices, n_dim=n_dim)
  return construct_numeric_rigidity_matrix(
    n_dim=n_dim, vertices=vertices, edge_list=edge_list)

def construct_float_rigidity_matrix(n_dim, n_vertices, edge_list):
  vertices = create_fake_float_vertices(
    n_vertices=n_vertices, n_dim=n_dim)
  return construct_numeric_rigidity_matrix(
    n_dim=n_dim, vertices=vertices, edge_list=edge_list)

def determine_degrees_of_freedom_integer(
      n_dim,
      n_vertices,
      edge_list,
      also_return_repeats=False):
  if (n_vertices == 0):
    if (also_return_repeats): return 0, 0
    return 0
  m = construct_integer_rigidity_matrix(
    n_dim=n_dim, n_vertices=n_vertices, edge_list=edge_list)
  if (m is None):
    if (also_return_repeats): return n_dim * n_vertices, 0
    return n_dim * n_vertices
  free_vars = integer_row_echelon_form(m=m)
  if (also_return_repeats): return len(free_vars), 0
  return len(free_vars)

class row_reduced_float_rigidity_matrix(object):

  def __init__(self, n_dim, n_vertices, edge_list):
    self.n_dim = n_dim
    self.n_vertices = n_vertices
    self.edge_list = edge_list
    self.m = None
    self.vertices = None
    self.free_vars = None
    self.repeats = -1
    if (n_vertices == 0): return
    self.construct_m()

  def construct_m(self):
    while True:
      self.repeats += 1
      self.vertices = create_fake_float_vertices(
        n_vertices=self.n_vertices, n_dim=self.n_dim)
      self.m = construct_numeric_rigidity_matrix(
        n_dim=self.n_dim, vertices=self.vertices, edge_list=self.edge_list)
      if (self.m is None): return
      self.free_vars = float_row_echelon_form(m=self.m)
      if (self.free_vars is not None):
        break

  def dof(self):
    if (self.free_vars is None):
      return self.n_dim * self.n_vertices
    return len(self.free_vars)

  def is_redundant(self, edge):
    assert self.m is not None
    while True:
      addl_row = construct_numeric_rigidity_matrix(
        n_dim=self.n_dim, vertices=self.vertices, edge_list=[edge])[0]
      result = float_row_echelon_form_is_redundant(
        m=self.m, free_vars=self.free_vars, addl_row=addl_row)
      if (result is not None):
        break
      self.construct_m()
    return result

def determine_degrees_of_freedom_float(
      n_dim,
      n_vertices,
      edge_list,
      also_return_repeats=False):
  if (also_return_repeats): return_zero = 0, 0
  else:                     return_zero = 0
  if (n_vertices == 0): return return_zero
  r = row_reduced_float_rigidity_matrix(
    n_dim=n_dim, n_vertices=n_vertices, edge_list=edge_list)
  if (also_return_repeats): return r.dof(), r.repeats
  return r.dof()

def determine_degrees_of_freedom(
      n_dim,
      n_vertices,
      edge_list,
      method="integer",
      also_return_repeats=False):
  assert method in ["integer", "float"]
  if (method == "integer"):
    return determine_degrees_of_freedom_integer(
      n_dim=n_dim, n_vertices=n_vertices, edge_list=edge_list,
      also_return_repeats=also_return_repeats)
  return determine_degrees_of_freedom_float(
    n_dim=n_dim, n_vertices=n_vertices, edge_list=edge_list,
    also_return_repeats=also_return_repeats)

# Donald Jacobs
# Generic rigidity in three-dimensional bond-bending networks
# Math. Gen. 31 (1998) 6653-6668)
# Figure 1(d)
double_banana_edge_list = [
  (0,1), (0,2), (1,2),
  (0,3), (1,3), (2,3),
  (0,4), (1,4), (2,4),
  (5,6), (5,7), (6,7),
  (5,3), (6,3), (7,3),
  (5,4), (6,4), (7,4)]

def example():
  n_vertices = 8
  edge_list = double_banana_edge_list
  for method in ["integer", "float"]:
    print("double banana 3D dof (method=%s):" % method, \
      determine_degrees_of_freedom(
        n_dim=3, n_vertices=n_vertices, edge_list=edge_list, method=method))

if (__name__ == "__main__"):
  example()


 *******************************************************************************


 *******************************************************************************
scitbx/graph/rigidity_matrix_symbolic.py
from __future__ import absolute_import, division, print_function

class dict_with_default_0(dict):
  def __missing__(self, key):
    return 0

def iiexps_mul(a, b):
  result = dict_with_default_0(a)
  for ii,exp in b.items():
    result[ii] += exp
  return result

def iiexps_as_tuples(iiexps):
  return tuple(sorted(iiexps.items()))

class term(object):

  def __init__(self, f, iiexps):
    self.f, self.iiexps = f, iiexps

  def __neg__(self):
    return term(-self.f, self.iiexps)

  def __mul__(a, b):
    return term(a.f * b.f, iiexps_mul(a.iiexps, b.iiexps))

  def __str__(self):
    result = []
    if (self.f != 1 and self.f != -1):
      result.append("%d" % self.f)
    for ii,exp in iiexps_as_tuples(self.iiexps):
      s = "v%d%s" % (ii//3, "xyz"[ii%3])
      if (exp != 1): s += "**%d" % exp
      result.append(s)
    result = "*".join(result)
    if (self.f == -1):
      result = "-" + result
    return result

elem_common_factor_check = True

class elem(object):

  def __init__(self, terms):
    n = dict_with_default_0()
    for t in terms:
      n[iiexps_as_tuples(t.iiexps)] += t.f
    terms = []
    for ies,f in n.items():
      if (f != 0):
        terms.append(term(f=f, iiexps=dict_with_default_0(ies)))
    if (elem_common_factor_check):
      # assert that there are no common factors
      count_i = {}
      min_e = {}
      for it in range(len(terms)):
        t = terms[it]
        for i,e in t.iiexps.items():
          ci = count_i.get(i, 0)
          if (ci == it):
            if (ci == 0):
              count_i[i] = 1
              min_e[i] = e
            else:
              count_i[i] += 1
              min_e[i] = min(min_e[i], e)
          elif (ci != 0):
            del count_i[i]
            del min_e[i]
      for i,c in count_i.items():
        assert c != len(terms)
    self.terms = terms

  def __eq__(a, b):
    assert b == 0
    return len(a.terms) == 0

  def __ne__(a, b):
    assert b == 0
    return len(a.terms) != 0

  def __mul__(a, b):
    terms = []
    for ta in a.terms:
      for tb in b.terms:
        terms.append(ta * tb)
    return elem(terms=terms)

  def __sub__(a, b):
    return elem(terms=a.terms + [-tb for tb in b.terms])

  def __str__(self):
    result = "+".join([str(t) for t in self.terms]).replace("+-","-")
    if (len(result) != 0): return result
    return "0"

def symbolic_row_echelon_form(m):
  free_vars = []
  n_rows = len(m)
  n_cols = len(m[0])
  piv_r = 0
  piv_c = 0
  while (piv_c < n_cols):
    best_r = None
    for i_row in range(piv_r, n_rows):
      if (m[i_row][piv_c] != 0):
        best_r = i_row
        break
    if (best_r is not None):
      if (best_r != piv_r):
        m[piv_r], m[best_r] = m[best_r], m[piv_r]
      fp = m[piv_r][piv_c]
      for r in range(piv_r+1, n_rows):
        fr = m[r][piv_c]
        if (fr == 0): continue
        for c in range(piv_c, n_cols):
          m[r][c] = m[r][c] * fp - m[piv_r][c] * fr
      piv_r += 1
    else:
      free_vars.append(piv_c)
    piv_c += 1
  return free_vars

def construct_symbolic_rigidity_matrix(n_dim, n_vertices, edge_list):
  n_edges = len(edge_list)
  if (n_edges == 0): return None
  n_columns = n_vertices * n_dim
  result = []
  for i,j in edge_list:
    assert i != j
    row = []
    for ic in range(n_columns):
      row.append(elem([]))
    ci = i * n_dim
    cj = j * n_dim
    for d in range(n_dim):
      ei = {ci+d: 1}
      ej = {cj+d: 1}
      row[ci+d] = elem(terms=[term(1, ei), term(-1, ej)])
      row[cj+d] = elem(terms=[term(1, ej), term(-1, ei)])
    result.append(row)
  return result

def determine_degrees_of_freedom(n_dim, n_vertices, edge_list):
  if (n_vertices == 0): return None
  m = construct_symbolic_rigidity_matrix(
    n_dim=n_dim, n_vertices=n_vertices, edge_list=edge_list)
  if (m is None): return None
  free_vars = symbolic_row_echelon_form(m=m)
  return len(free_vars)

def compare_int_symb(n_vertices, edge_list):
  from scitbx.graph.rigidity import determine_degrees_of_freedom as dof_int
  di = dof_int(
    n_dim=3, n_vertices=n_vertices, edge_list=edge_list)
  ds = determine_degrees_of_freedom(
    n_dim=3, n_vertices=n_vertices, edge_list=edge_list)
  if (0):
    print("dof_int:", di, "dof_symb:", ds)
  assert ds == di
  if (len(edge_list) > 1):
    for i_delete in range(len(edge_list)):
      el = list(edge_list)
      del el[i_delete]
      compare_int_symb(n_vertices, el)

def exercise():
  if (elem_common_factor_check):
    try: elem([term(1,{0:2}), term(1,{0:1})])
    except AssertionError: pass
    else: raise RuntimeError("Exception expected.")
  n_vertices = 2
  edge_list = [(0,1)]
  compare_int_symb(n_vertices, edge_list)
  n_vertices = 3
  edge_list.extend([(0,2),(1,2)])
  compare_int_symb(n_vertices=n_vertices, edge_list=edge_list)
  n_vertices = 4
  edge_list.extend([(0,3), (1,3), (2,3)])
  compare_int_symb(n_vertices=n_vertices, edge_list=edge_list)
  if (0):
    n_vertices = 5
    edge_list.extend([(0,4), (1,4), (2,4), (3,4)])
    compare_int_symb(n_vertices=n_vertices, edge_list=edge_list)

if (__name__ == "__main__"):
  import os
  try:
    exercise()
  finally:
    t = os.times()
    print("u+s,u,s: %.2f %.2f %.2f" % (t[0] + t[1], t[0], t[1]))


 *******************************************************************************


 *******************************************************************************
scitbx/graph/tardy_tree.py
from __future__ import absolute_import, division, print_function
from scitbx.graph.utils import \
  construct_edge_sets, extract_edge_list, sub_edge_list, tree_marking
from libtbx import slots_getstate_setstate
import math
from six.moves import range
from libtbx.math_utils import cmp
from functools import cmp_to_key

class cluster_manager(slots_getstate_setstate):

  __slots__ = [
    "fixed_vertex_lists",
    "cluster_indices",
    "clusters",
    "merge_clusters_with_multiple_connections_passes",
    "hinge_edges",
    "loop_edges",
    "loop_edge_bendings",
    "fixed_hinges"]

  def __init__(O,
        n_vertices,
        all_in_one_rigid_body=False,
        fixed_vertex_lists=()):
    O.fixed_vertex_lists = fixed_vertex_lists
    if (len(O.fixed_vertex_lists) == 0):
      if (all_in_one_rigid_body):
        O.cluster_indices = [0] * n_vertices
        O.clusters = [list(range(n_vertices))]
      else:
        O.cluster_indices = list(range(n_vertices))
        O.clusters = []
        for i in range(n_vertices):
          O.clusters.append([i])
    else:
      assert not all_in_one_rigid_body # not implemented
      O.cluster_indices = [-1] * n_vertices
      O.clusters = []
      for fixed_vertices in O.fixed_vertex_lists:
        assert len(fixed_vertices) != 0
        for i in fixed_vertices:
          assert O.cluster_indices[i] == -1
          O.cluster_indices[i] = len(O.clusters)
        O.clusters.append(list(fixed_vertices))
      for i in range(n_vertices):
        if (O.cluster_indices[i] != -1): continue
        O.cluster_indices[i] = len(O.clusters)
        O.clusters.append([i])
    O.merge_clusters_with_multiple_connections_passes = 0
    O.hinge_edges = None
    O.loop_edges = None
    O.loop_edge_bendings = None
    O.fixed_hinges = None

  def all_in_one_rigid_body(O):
    return len(O.clusters) == 1

  def show_summary(O, out=None, prefix=""):
    from libtbx.utils import xlen, plural_s
    import sys
    if (out is None): out = sys.stdout
    print(prefix+"number of fixed vertex lists:", \
      len(O.fixed_vertex_lists), file=out)
    print(prefix+"number of fixed vertices:", \
      sum([len(fixed_vertices) for fixed_vertices in O.fixed_vertex_lists]), file=out)
    print(prefix+"number of clusters:", len(O.clusters), file=out)
    print(prefix+"merge clusters with multiple connections: %d pass%s"\
      % plural_s(O.merge_clusters_with_multiple_connections_passes, "es"), file=out)
    print(prefix+"number of hinge edges:", xlen(O.hinge_edges), file=out)
    print(prefix+"number of loop edges:", xlen(O.loop_edges), file=out)
    print(prefix+"number of loop edge bendings:", \
      xlen(O.loop_edge_bendings), file=out)
    print(prefix+"number of fixed hinges:", xlen(O.fixed_hinges), file=out)
    return O

  def show_tree(O, out=None, prefix="", header=True):
    import sys
    if (out is None): out = sys.stdout
    if (header):
      for line in [
            "# clusters are in square brackets []",
            "# hinge edges are in parentheses ()",
            "# (0, 1) -> [2, 3] means that the cluster with vertices [2, 3]",
            "#   rotates around the axis through vertices (0, 1)",
            "# integers are vertex indices (counting from 0)"]:
        print(prefix + line, file=out)
    for line in O.hinge_edges_and_clusters_as_indented_strings():
      print(prefix + line, file=out)
    return O

  def fixed_vertices_given_cluster_index_dict(O):
    result = {}
    ci = O.cluster_indices
    for fixed_vertices in O.fixed_vertex_lists:
      i = ci[fixed_vertices[0]]
      assert i not in result
      result[i] = fixed_vertices
    return result

  def connect_clusters(O, cii, cij, optimize):
    assert O.hinge_edges is None
    if (cii == cij): return None
    lfvl = len(O.fixed_vertex_lists)
    if (cii < lfvl and cij < lfvl):
      raise RuntimeError(
        "connect_clusters():"
        " fixed vertex lists in same connected tree.")
    ci = O.cluster_indices
    ccij = O.clusters[cij]
    ccii = O.clusters[cii]
    if ((not optimize
         or len(ccij) <= len(ccii)
         or cii < lfvl)
        and (cij >= lfvl or lfvl == 0)):
      for k in ccij: ci[k] = cii
      ccii.extend(ccij)
      del ccij[:]
      return cii
    for k in ccii: ci[k] = cij
    ccij.extend(ccii)
    del ccii[:]
    return cij

  def connect_vertices(O, i, j, optimize):
    assert O.hinge_edges is None
    ci = O.cluster_indices
    return O.connect_clusters(cii=ci[i], cij=ci[j], optimize=optimize)

  def refresh_indices(O):
    ci = O.cluster_indices
    for ic,c in enumerate(O.clusters):
      for i in c:
        ci[i] = ic

  def tidy(O):
    assert O.hinge_edges is None
    for c in O.clusters: c.sort()
    def cmp_clusters(a, b):
      if (len(a) != 0 and len(b) != 0):
        fa = O.cluster_indices[a[0]] < len(O.fixed_vertex_lists)
        fb = O.cluster_indices[b[0]] < len(O.fixed_vertex_lists)
        if (fa):
          if (not fb): return -1
        else:
          if (fb): return 1
      if (len(a) > len(b)): return -1
      if (len(a) < len(b)): return 1
      if len(a): return cmp(a[0], b[0])
      return 0
    O.clusters.sort(key=cmp_to_key(cmp_clusters))
    for ic in range(len(O.clusters)-1,-1,-1):
      if (len(O.clusters[ic]) != 0):
        del O.clusters[ic+1:]
        break
    O.refresh_indices()

  def merge_clusters_with_multiple_connections(O, edge_sets):
    while True:
      O.merge_clusters_with_multiple_connections_passes += 1
      repeat = False
      for cii in range(len(O.clusters)):
        while True:
          connected = set()
          multiple = set()
          for i in O.clusters[cii]:
            for j in edge_sets[i]:
              cij = O.cluster_indices[j]
              if (cij == cii): continue
              if (cij in connected): multiple.add(cij)
              else:                  connected.add(cij)
          if (len(multiple) == 0):
            break
          for cij in multiple:
            assert O.connect_clusters(cii=cii, cij=cij, optimize=False) == cii
            repeat = True
      if (not repeat):
        break
    O.tidy()

  def cluster_edge_sets(O, edge_list):
    result = []
    for i in range(len(O.clusters)):
      result.append(set())
    ci = O.cluster_indices
    for i,j in edge_list:
      cii = ci[i]
      cij = ci[j]
      if (cii == cij): continue
      result[cii].add(cij)
      result[cij].add(cii)
    return result

  def overlapping_rigid_clusters(O, edge_sets):
    assert O.hinge_edges is None
    result = []
    for cluster in O.clusters:
      def add_cluster_and_connected_vertices():
        c = set(cluster)
        for i in cluster:
          c.update(edge_sets[i])
        result.append(tuple(sorted(c)))
      if (len(cluster) != 1):
        add_cluster_and_connected_vertices()
      else:
        i = cluster[0]
        esi = edge_sets[i]
        if (len(esi) != 1):
          add_cluster_and_connected_vertices()
        else:
          j = list(esi)[0]
          if (len(edge_sets[j]) == 1 and j > i):
            result.append((i,j))
    return result

  def determine_weighted_order_for_construct_spanning_tree(O, edge_sets):
    fixed_vertex_info = [0] * len(O.clusters)
    for fixed_vertices in O.fixed_vertex_lists:
      lvf = len(fixed_vertices)
      assert lvf != 0
      i = fixed_vertices[0]
      cii = O.cluster_indices[i]
      fixed_vertex_info[cii] = lvf
      if (lvf == 1):
        for j in edge_sets[i]:
          cij = O.cluster_indices[j]
          if (cij == cii): continue
          if (fixed_vertex_info[cij] != 0):
            raise RuntimeError(
              "determine_weighted_order_for_construct_spanning_tree():"
              " fixed vertex lists in same connected tree.")
          fixed_vertex_info[cij] = -1
    cii_orcs = []
    for cii,cluster in enumerate(O.clusters):
      c = set(cluster)
      for i in cluster:
        c.update(edge_sets[i])
      cii_orcs.append((cii, len(c)))
    def cmp_elems(a, b):
      fa = abs(fixed_vertex_info[a[0]])
      fb = abs(fixed_vertex_info[b[0]])
      if (fa > fb): return -1
      if (fa < fb): return 1
      if (a[1] > b[1]): return -1
      if (a[1] < b[1]): return 1
      return cmp(a[0], b[0])
    cii_orcs.sort(key=cmp_to_key(cmp_elems))
    return cii_orcs, fixed_vertex_info

  def construct_spanning_trees(O, edge_sets):
    assert O.hinge_edges is None
    if (edge_sets is None):
      assert O.all_in_one_rigid_body()
      O.hinge_edges = [(-1,0)]
      O.loop_edges = []
      return
    cii_orcs, fixed_vertex_info = \
      O.determine_weighted_order_for_construct_spanning_tree(
        edge_sets=edge_sets)
    n_clusters = len(O.clusters)
    hinge_edges = [(-1,c[0]) for c in O.clusters]
    O.loop_edges = []
    if (n_clusters == 0): w_max = -1
    else:                 w_max = max([orcs for cii,orcs in cii_orcs])
    candi = []
    for i in range(w_max+1):
      candi.append([])
    cii_wo_given_cii = [n_clusters] * n_clusters
    for ip_wo in range(n_clusters):
      ip = cii_orcs[ip_wo][0]
      cii_wo_given_cii[ip] = ip_wo
    done = [0] * n_clusters
    cluster_perm = []
    for ip_wo in range(n_clusters):
      ip = cii_orcs[ip_wo][0]
      he = hinge_edges[ip]
      if (he[0] != -1): continue
      have_fixed = [(fixed_vertex_info[ip] > 0)]
      done[ip] = 1
      cluster_perm.append(ip)
      def set_loop_or_hinge_edge(w_max):
        if (fixed_vertex_info[cij] > 0):
          if (have_fixed[0]):
            raise RuntimeError(
              "construct_spanning_trees():"
              " fixed vertex lists in same connected tree.")
          have_fixed[0] = True
        if (done[cij] != 0):
          O.loop_edges.append((i,j))
        else:
          done[cij] = -1
          cij_wo = cii_wo_given_cii[cij]
          w = cii_orcs[cij_wo][1]
          candi[w].append(cij_wo)
          hinge_edges[cij] = (i,j)
          if (w_max < w): w_max = w
        return w_max
      w_max = 0
      for i in O.clusters[ip]:
        for j in edge_sets[i]:
          cij = O.cluster_indices[j]
          if (cij == ip): continue
          w_max = set_loop_or_hinge_edge(w_max=w_max)
      while True:
        kp = None
        ip_wo = n_clusters
        cw = candi[w_max]
        for k in range(len(cw)):
          if (ip_wo > cw[k]):
            kp = k
            ip_wo = cw[k]
        if (kp is None):
          break
        del cw[kp]
        ip = cii_orcs[ip_wo][0]
        for i in O.clusters[ip]:
          for j in edge_sets[i]:
            cij = O.cluster_indices[j]
            if (cij == ip): continue
            if (done[cij] == 1): continue
            w_max = set_loop_or_hinge_edge(w_max=w_max)
        assert done[ip] == -1
        done[ip] = 1
        cluster_perm.append(ip)
        he = hinge_edges[ip]
        if (he[0] != -1):
          O.clusters[O.cluster_indices[he[0]]].append(he[1])
          O.clusters[ip].remove(he[1])
        for w_max in range(w_max,-1,-1):
          if (len(candi[w_max]) != 0):
            break
        else:
          break
    assert len(cluster_perm) == n_clusters
    assert done.count(1) == len(done)
    new_clusters = []
    O.hinge_edges = []
    for cii in cluster_perm:
      c = O.clusters[cii]
      if (len(c) != 0):
        new_clusters.append(sorted(c))
        O.hinge_edges.append(hinge_edges[cii])
    del O.clusters[:]
    O.clusters.extend(new_clusters)
    O.refresh_indices()
    O.loop_edges.sort()

  def roots(O):
    assert O.hinge_edges is not None
    result = []
    for i,he in enumerate(O.hinge_edges):
      if (he[0] == -1):
        result.append(i)
    return result

  def tree_ids(O):
    assert O.hinge_edges is not None
    result = []
    tid = 0
    for he in O.hinge_edges:
      if (he[0] == -1):
        result.append(tid)
        tid += 1
      else:
        result.append(result[O.cluster_indices[he[0]]])
    return result

  def find_loop_edge_bendings(O, edge_sets):
    assert O.loop_edges is not None
    assert O.loop_edge_bendings is None
    if (edge_sets is None):
      assert O.all_in_one_rigid_body()
      O.loop_edge_bendings = []
      return
    leb = set()
    for i,j in O.loop_edges:
      for k in edge_sets[i]:
        if (k == j): continue
        assert k not in edge_sets[j]
        leb.add(tuple(sorted((j,k))))
      for k in edge_sets[j]:
        if (k == i): continue
        assert k not in edge_sets[i]
        leb.add(tuple(sorted((i,k))))
    O.loop_edge_bendings = sorted(leb)

  def fix_near_singular_hinges(O, sites, angular_tolerance_deg):
    assert O.loop_edge_bendings is not None
    assert O.fixed_hinges is None
    O.fixed_hinges = []
    if (O.all_in_one_rigid_body()): return
    if (sites is None): return
    if (hasattr(sites, "accessor")):
      from scitbx import matrix
      sites = matrix.col_list(sites)
    abs_cos_limit = abs(math.cos(math.radians(angular_tolerance_deg)))
    for jc in range(len(O.clusters)-1,-1,-1):
      hi,hj = O.hinge_edges[jc]
      if (hi == -1):
        continue
      pivot = sites[hi]
      axis = sites[hj] - pivot
      for i in O.clusters[jc]:
        abs_cos = abs(axis.cos_angle(sites[i] - pivot, value_if_undefined=1))
        if (abs_cos < abs_cos_limit):
          break
      else:
        O.fixed_hinges.append(O.hinge_edges[jc])
        del O.hinge_edges[jc]
        ic = O.cluster_indices[hj]
        O.clusters[ic].extend(O.clusters[jc])
        O.clusters[ic].sort()
        ci = O.cluster_indices
        for i in O.clusters[jc]:
          ci[i] = ic
        del O.clusters[jc]
        for ic in range(jc,len(O.clusters)):
          for i in O.clusters[ic]:
            ci[i] = ic
    O.fixed_hinges.sort()

  def root_distances(O):
    assert O.hinge_edges is not None
    assert len(O.hinge_edges) == len(O.clusters)
    result = [None] * len(O.clusters)
    for ic,cl in enumerate(O.clusters):
      hi,hj = O.hinge_edges[ic]
      if (hi == -1):
        result[ic] = 0
      else:
        jc = O.cluster_indices[hj]
        assert result[jc] is not None
        result[ic] = result[jc] + 1
    return result

  def hinge_edges_and_clusters_as_indented_strings(O):
    result = []
    root_dists = O.root_distances()
    for ic,cl in enumerate(O.clusters):
      he = O.hinge_edges[ic]
      root_dist = root_dists[ic]
      if (root_dist == 0):
        result.append(str(cl))
      else:
        result.append("%s%s -> %s" % ("  "*root_dist, str(he), str(cl)))
    return result

  def edge_classifier(O):
    return edge_classifier(cluster_manager=O)

class edge_classifier(object):

  def __init__(O, cluster_manager):
    O.cluster_manager = cluster_manager
    O.hinge_edge_set = set()
    for e in cluster_manager.hinge_edges:
      if (e[0] == -1): continue
      O.hinge_edge_set.add(tuple(sorted(e)))
    O.loop_edge_set = set([tuple(sorted(e))
      for e in cluster_manager.loop_edges])
    assert len(O.hinge_edge_set.intersection(O.loop_edge_set)) == 0
    O.fixed_hinge_set = set(cluster_manager.fixed_hinges)
    assert len(O.hinge_edge_set.intersection(O.fixed_hinge_set)) == 0
    assert len(O.loop_edge_set.intersection(O.fixed_hinge_set)) == 0

  def __call__(O, edge):
    edge = tuple(sorted(edge))
    if (edge in O.fixed_hinge_set): return "fixed"
    if (edge in O.hinge_edge_set): return "hinge"
    if (edge in O.loop_edge_set): return "loop"
    cm = O.cluster_manager
    cii, cij = [cm.cluster_indices[i] for i in edge]
    if (cii == cij and cm.hinge_edges[cii][0] == -1): return "base"
    return "intra"

class find_paths(object):

  def __init__(O, edge_sets):
    O.edge_sets = edge_sets
    O.in_path = [False] * len(O.edge_sets)

  def search_from(O, iv):
    edge_sets = O.edge_sets
    in_path = O.in_path
    loops = {}
    dendrites = {}
    path = []
    def depth_first_search(jv, kv):
      path.append(kv)
      in_path[kv] = True
      closing = False
      for lv in edge_sets[kv]:
        if (lv == jv): continue
        if (lv == iv):
          loops.setdefault(path[0], []).append(path[1:])
          closing = True
        elif (in_path[lv]):
          closing = True
      if (not closing and len(path) != 6):
        for lv in edge_sets[kv]:
          if (lv == jv): continue
          dendrites.setdefault(lv, []).append(set(path))
          depth_first_search(jv=kv, kv=lv)
      path.pop()
      in_path[kv] = False
    for jv in edge_sets[iv]:
      depth_first_search(jv=iv, kv=jv)
    return loops, dendrites

class construct(slots_getstate_setstate):

  __slots__ = [
    "n_vertices",
    "edge_list",
    "edge_sets",
    "cluster_manager",
    "external_clusters_connect_count",
    "find_cluster_loop_repeats"]

  def __init__(O,
        n_vertices=None,
        sites=None,
        edge_list=None,
        external_clusters=None,
        fixed_vertices=None,
        fixed_vertex_lists=None,
        near_singular_hinges_angular_tolerance_deg=5):
    assert [n_vertices, sites].count(None) == 1
    assert edge_list is not None
    assert [fixed_vertices, fixed_vertex_lists].count(None) != 0
    if (sites is not None):
      n_vertices = len(sites)
    O.n_vertices = n_vertices
    all_in_one_rigid_body = (edge_list == "all_in_one_rigid_body")
    if (all_in_one_rigid_body):
      assert external_clusters is None
      O.edge_list = None
      O.edge_sets = None
    else:
      O.edge_list = edge_list
      O.edge_sets = construct_edge_sets(
        n_vertices=n_vertices, edge_list=edge_list)
    if (fixed_vertex_lists is None):
      if (fixed_vertices is None or len(fixed_vertices) == 0):
        fixed_vertex_lists = ()
      else:
        assert O.edge_sets is not None # not implemented
        fixed_vertex_lists = tree_marking(edge_sets=O.edge_sets) \
          .partitions_of(vertex_indices=fixed_vertices)
    O.cluster_manager = cluster_manager(
      n_vertices=n_vertices,
      all_in_one_rigid_body=all_in_one_rigid_body,
      fixed_vertex_lists=fixed_vertex_lists)
    if (not all_in_one_rigid_body):
      O._find_paths()
      O._process_external_clusters(clusters=external_clusters)
    O.cluster_manager.tidy()
    O.find_cluster_loop_repeats = None
    if (sites is not None):
      O.build_tree()
      O.fix_near_singular_hinges(
        sites=sites,
        angular_tolerance_deg=near_singular_hinges_angular_tolerance_deg)

  def show_summary(O, vertex_labels, out=None, prefix=""):
    from libtbx.utils import xlen, plural_s
    import sys
    if (out is None): out = sys.stdout
    if (vertex_labels is None):
      fmt = "%%0%dd" % len(str(max(0, O.n_vertices-1)))
      vertex_labels = [fmt % i for i in range(O.n_vertices)]
    else:
      assert len(vertex_labels) == O.n_vertices
    print(prefix+"number of vertices:", O.n_vertices, file=out)
    print(prefix+"number of edges:", xlen(O.edge_list), file=out)
    if (O.find_cluster_loop_repeats is None):
      print(prefix+"find cluster loops: None", file=out)
    else:
      print(prefix+"find cluster loops: %d repeat%s" % \
        plural_s(O.find_cluster_loop_repeats), file=out)
    cm = O.cluster_manager
    cm.show_summary(out=out, prefix=prefix)
    if (cm.fixed_hinges is not None):
      for i,j in cm.fixed_hinges:
        print(prefix+"tardy fixed hinge:", vertex_labels[i], file=out)
        print(prefix+"                  ", vertex_labels[j], file=out)
    return O

  def show_tree(O, out=None, prefix="", header=True):
    O.cluster_manager.show_tree(out=out, prefix=prefix, header=header)
    return O

  def extract_edge_list(O):
    return extract_edge_list(edge_sets=O.edge_sets)

  def _find_paths(O):
    fp = find_paths(edge_sets=O.edge_sets)
    for iv in range(O.n_vertices):
      loops, dendrites = fp.search_from(iv=iv)
      #
      for jv,loops_through_jv in loops.items():
        have_small = False
        l5s = []
        for loop_through_jv in loops_through_jv:
          if (len(loop_through_jv) < 5):
            for kv in loop_through_jv:
              O.cluster_manager.connect_vertices(i=iv, j=kv, optimize=True)
            have_small = True
          else:
            l5s.append(loop_through_jv)
        if (have_small):
          for loop_through_jv in l5s:
            for kv in loop_through_jv:
              O.cluster_manager.connect_vertices(i=iv, j=kv, optimize=True)
      #
      for jv,sps_to_jv in dendrites.items():
        if (len(sps_to_jv) < 3): continue
        sps_by_length = [None, [], [], [], [], []]
        for sp_to_jv in sps_to_jv:
          sps_by_length[len(sp_to_jv)].append(sp_to_jv)
        n_l1_l2_l3_lt_10 = 0
        for l1 in range(1,6):
          for l2 in range(1,min(6,10-l1)):
            for l3 in range(1,min(6,10-l1-l2)):
              n_l1_l2_l3_lt_10 += 1
              for sp1 in sps_by_length[l1]:
                for sp2 in sps_by_length[l2]:
                  sp12 = sp1.union(sp2)
                  if (len(sp12) != len(sp1) + len(sp2)): continue
                  for sp3 in sps_by_length[l3]:
                    sp123 = sp12.union(sp3)
                    if (len(sp123) != len(sp12) + len(sp3)): continue
                    O.cluster_manager.connect_vertices(
                      i=iv, j=jv, optimize=True)
                    for kv in sp123:
                      O.cluster_manager.connect_vertices(
                        i=iv, j=kv, optimize=True)
        assert n_l1_l2_l3_lt_10 == 72

  def _process_external_clusters(O, clusters):
    O.external_clusters_connect_count = 0
    if (clusters is None): return
    cv = O.cluster_manager.connect_vertices
    for cluster in clusters:
      sub = sub_edge_list(edge_sets=O.edge_sets, vertex_indices=cluster)
      sub_edge_sets = sub.edge_sets()
      for i_sub,j_sub in sub.edge_list:
        if (len(sub_edge_sets[i_sub]) == 1): continue
        if (len(sub_edge_sets[j_sub]) == 1): continue
        if (cv(i=cluster[i_sub], j=cluster[j_sub], optimize=True) is not None):
          O.external_clusters_connect_count += 1

  def find_cluster_loops(O):
    assert O.find_cluster_loop_repeats is None
    if (O.edge_sets is None):
      O.find_cluster_loop_repeats = 0
      return
    O.find_cluster_loop_repeats = -1
    cm = O.cluster_manager
    while True:
      O.find_cluster_loop_repeats += 1
      cm.merge_clusters_with_multiple_connections(edge_sets=O.edge_sets)
      ces = cm.cluster_edge_sets(edge_list=O.edge_list)
      cel = extract_edge_list(edge_sets=ces)
      ctt = construct(n_vertices=len(cm.clusters), edge_list=cel)
      ccm = ctt.cluster_manager
      ccm.merge_clusters_with_multiple_connections(edge_sets=ctt.edge_sets)
      if (len(ccm.clusters) == len(cm.clusters)):
        break
      for cc in ccm.clusters:
        cii = cc[0]
        for cij in cc[1:]:
          cii = cm.connect_clusters(cii=cii, cij=cij, optimize=True)
      cm.tidy()
    return O

  def build_tree(O):
    O.find_cluster_loops()
    cm = O.cluster_manager
    cm.construct_spanning_trees(edge_sets=O.edge_sets)
    cm.find_loop_edge_bendings(edge_sets=O.edge_sets)
    return O

  def fix_near_singular_hinges(O, sites, angular_tolerance_deg=5):
    O.cluster_manager.fix_near_singular_hinges(
      sites=sites, angular_tolerance_deg=angular_tolerance_deg)
    return O

  def rmsd_calculator(O):
    return O.rmsd_calculation

  def rmsd_calculation(O, sites_cart_1, sites_cart_2):
    return sites_cart_1.rms_difference(sites_cart_2.select(
      O.rmsd_permutation(
        sites_cart_1=sites_cart_1,
        sites_cart_2=sites_cart_2)))

  def rmsd_permutation(O, sites_cart_1, sites_cart_2):
    "simple, limited handling of flipped sites"
    assert sites_cart_1.size() == len(O.edge_sets)
    assert sites_cart_2.size() == len(O.edge_sets)
    from scitbx.array_family import flex
    result = flex.size_t_range(len(O.edge_sets))
    for i,esi in enumerate(O.edge_sets):
      if (len(esi) not in[2, 3]): continue
      n1 = flex.size_t()
      for j in esi:
        if (len(O.edge_sets[j]) == 1):
          n1.append(j)
      if (len(n1) != 2): continue
      n1_rev = flex.size_t(reversed(n1))
      pair_1 = sites_cart_1.select(n1)
      rmsd_1 = pair_1.rms_difference(sites_cart_2.select(n1))
      rmsd_2 = pair_1.rms_difference(sites_cart_2.select(n1_rev))
      if (rmsd_2 < rmsd_1*(1-1e-6)):
        result.set_selected(n1, n1_rev)
    return result

  def viewer_lines_with_colors_legend(O, include_loop_edge_bendings):
    result = [
      "Edge colors:",
      "  turquoise: intra-base-cluster, six degrees of freedom",
      "  green:     rotatable bond, one degree of freedom",
      "  blue:      intra-cluster",
      "  red:       loop edge (restrained only)",
      "  pink:      near singular rotatable bond (fixed)"]
    if (include_loop_edge_bendings): result.append(
      "  purple:    loop bending edge (restrained only)")
    return result

  def viewer_lines_with_colors(O, include_loop_edge_bendings):
    result = []
    colors = {
      "base":  (0,1,1),
      "hinge": (0,1,0),
      "intra": (0,0,1),
      "loop":  (1,0,0),
      "fixed": (1,182/255,193/255)}
    ec = O.cluster_manager.edge_classifier()
    for line in O.edge_list:
      result.append((line, colors[ec(edge=line)]))
    if (include_loop_edge_bendings):
      for line in O.cluster_manager.loop_edge_bendings:
        result.append((line, (0.5,0,0.5)))
    return result


 *******************************************************************************


 *******************************************************************************
scitbx/graph/test_cases_tardy_pdb.py
from __future__ import absolute_import, division, print_function
import scitbx.graph.utils as graph_utils
from scitbx import matrix
from libtbx.utils import Sorry

class pdb_extract(object):

  def __init__(O,
        tag,
        pdb,
        bonds,
        clusters=None,
        hinge_edges=None,
        loop_edges=None,
        loop_edge_bendings=None,
        find_cluster_loop_repeats=0,
        merge_clusters_with_multiple_connections_passes=1):
    O.index = None
    O.tag = tag
    O.labels, O.sites = [], []
    for line in pdb.splitlines():
      O.labels.append(line[22:26].strip()+"."+line[12:16].strip())
      O.sites.append(matrix.col([float(line[30+i*8:38+i*8]) for i in [0,1,2]]))
    O.bonds = bonds
    O.clusters = clusters
    O.hinge_edges = hinge_edges
    O.loop_edges = loop_edges
    O.loop_edge_bendings = loop_edge_bendings
    O.find_cluster_loop_repeats = find_cluster_loop_repeats
    O.merge_clusters_with_multiple_connections_passes = \
      merge_clusters_with_multiple_connections_passes

  def angles(O):
    return graph_utils.extract_edge_list(
      graph_utils.bond_bending_edge_sets(
        edge_sets=graph_utils.construct_edge_sets(
          n_vertices=len(O.sites),
          edge_list=O.bonds),
        omit_bonds=True))

  def tardy_tree_construct(O, fixed_vertex_lists=[]):
    from scitbx.graph import tardy_tree
    tt = tardy_tree.construct(
      sites=O.sites,
      edge_list=O.bonds,
      fixed_vertex_lists=fixed_vertex_lists)
    if (len(fixed_vertex_lists) != 0):
      return tt
    cm = tt.cluster_manager
    if (O.clusters is None):
      print("tag:", O.tag)
    if (O.clusters is None):
      print("clusters:", cm.clusters)
    else:
      assert cm.clusters == O.clusters
    if (O.hinge_edges is None):
      print("hinge_edges:", cm.hinge_edges)
    else:
      assert cm.hinge_edges == O.hinge_edges
    if (O.loop_edges is None):
      print("loop_edges:", cm.loop_edges)
    else:
      assert cm.loop_edges == O.loop_edges
    if (O.loop_edge_bendings is None):
      print("loop_edge_bendings:", cm.loop_edge_bendings)
    else:
      assert cm.loop_edge_bendings == O.loop_edge_bendings
    assert tt.find_cluster_loop_repeats == O.find_cluster_loop_repeats
    assert cm.merge_clusters_with_multiple_connections_passes \
        ==  O.merge_clusters_with_multiple_connections_passes
    if (O.clusters is None):
      print()
    return tt

test_cases = [

pdb_extract(
  tag="point",
  pdb="""\
ATOM      0  FE  FE  A   1      10.949  12.815  15.189  0.00  0.00          FE
""",
  bonds=[],
  clusters=[[0]],
  hinge_edges=[(-1, 0)],
  loop_edges=[],
  loop_edge_bendings=[]),

pdb_extract(
  tag="gly_no_h",
  pdb="""\
ATOM      0  N   GLY A   1      10.949  12.815  15.189  0.00  0.00           N
ATOM      1  CA  GLY A   1      10.405  13.954  15.917  0.00  0.00           C
ATOM      2  C   GLY A   1      10.779  15.262  15.227  0.00  0.00           C
ATOM      3  O   GLY A   1       9.916  16.090  14.936  0.00  0.00           O
""",
  bonds=[(0,1),(1,2),(2,3)],
  clusters=[[0, 1, 2], [3]],
  hinge_edges=[(-1, 1), (1, 2)],
  loop_edges=[],
  loop_edge_bendings=[]),

pdb_extract(
  tag="gly_with_nh",
  pdb="""\
ATOM      0  N   GLY A   1      10.949  12.815  15.189  0.00  0.00           N
ATOM      1  CA  GLY A   1      10.405  13.954  15.917  0.00  0.00           C
ATOM      2  C   GLY A   1      10.779  15.262  15.227  0.00  0.00           C
ATOM      3  O   GLY A   1       9.916  16.090  14.936  0.00  0.00           O
ATOM      4  H   GLY A   1      11.792  12.691  15.311  0.00  0.00           H
""",
  bonds=[(0,1),(0,4),(1,2),(2,3)],
  clusters=[[0, 1, 4], [2], [3]],
  hinge_edges=[(-1, 0), (0, 1), (1, 2)],
  loop_edges=[],
  loop_edge_bendings=[]),

pdb_extract(
  tag="ala_no_h",
  pdb="""\
ATOM      0  N   ALA A   1      10.949  12.815  15.189  0.00  0.00           N
ATOM      1  CA  ALA A   1      10.405  13.954  15.917  0.00  0.00           C
ATOM      2  C   ALA A   1      10.779  15.262  15.227  0.00  0.00           C
ATOM      3  CB  ALA A   1      10.908  13.950  17.351  0.00  0.00           C
ATOM      4  O   ALA A   1       9.916  16.090  14.936  0.00  0.00           O
""",
  bonds=[(0,1),(1,2),(1,3),(2,4)],
  clusters=[[0, 1, 2, 3], [4]],
  hinge_edges=[(-1, 1), (1, 2)],
  loop_edges=[],
  loop_edge_bendings=[]),

pdb_extract(
  tag="ala_with_h",
  pdb="""\
ATOM      0  N   ALA A   1      10.949  12.815  15.189  0.00  0.00           N
ATOM      1  CA  ALA A   1      10.405  13.954  15.917  0.00  0.00           C
ATOM      2  C   ALA A   1      10.779  15.262  15.227  0.00  0.00           C
ATOM      3  HA  ALA A   1       9.428  13.887  15.936  0.00  0.00           H
ATOM      4  O   ALA A   1       9.916  16.090  14.936  0.00  0.00           O
ATOM      5  H   ALA A   1      11.792  12.691  15.311  0.00  0.00           H
ATOM      6  CB  ALA A   1      10.908  13.950  17.351  0.00  0.00           C
ATOM      7  HB1 ALA A   1      10.627  13.138  17.778  0.00  0.00           H
ATOM      8  HB2 ALA A   1      10.540  14.707  17.813  0.00  0.00           H
ATOM      9  HB3 ALA A   1      11.867  14.004  17.346  0.00  0.00           H
""",
  bonds=[(0,1),(0,5),(1,2),(1,3),(1,6),(2,4),(6,7),(6,8),(6,9)],
  clusters=[[0, 1, 2, 3, 6], [7, 8, 9], [5], [4]],
  hinge_edges=[(-1, 1), (1, 6), (1, 0), (1, 2)],
  loop_edges=[],
  loop_edge_bendings=[]),

pdb_extract(
  tag="tyr_with_h",
  pdb="""\
ATOM      0  CG  TYR A   1      11.007   9.417   9.446  1.00  0.79           C
ATOM      1  CD1 TYR A   1       9.923  10.155   8.940  1.00  1.42           C
ATOM      2  CD2 TYR A   1      10.765   8.288  10.238  1.00  1.41           C
ATOM      3  CE1 TYR A   1       8.612   9.760   9.229  1.00  1.61           C
ATOM      4  CE2 TYR A   1       9.453   7.895  10.525  1.00  1.42           C
ATOM      5  CZ  TYR A   1       8.377   8.631  10.021  1.00  1.11           C
ATOM      6  HD1 TYR A   1      10.092  11.024   8.328  1.00  2.14           H
ATOM      7  HD2 TYR A   1      11.596   7.718  10.630  1.00  2.21           H
ATOM      8  HE1 TYR A   1       7.780  10.329   8.841  1.00  2.44           H
ATOM      9  HE2 TYR A   1       9.270   7.023  11.135  1.00  2.13           H
ATOM     10  OH  TYR A   1       7.083   8.244  10.304  1.00  1.32           O
ATOM     11  HH  TYR A   1       6.494   8.723   9.717  1.00  2.00           H
ATOM     12  CB  TYR A   1      12.440   9.818   9.148  1.00  0.74           C
ATOM     13  HB2 TYR A   1      12.827   9.193   8.358  1.00  0.78           H
ATOM     14  HB3 TYR A   1      13.036   9.677  10.037  1.00  0.78           H
ATOM     15  N   TYR A   1      11.593  12.101   9.550  1.00  0.82           N
ATOM     16  CA  TYR A   1      12.527  11.286   8.721  1.00  0.75           C
ATOM     17  C   TYR A   1      12.160  11.413   7.239  1.00  0.76           C
ATOM     18  HA  TYR A   1      13.536  11.638   8.870  1.00  0.85           H
ATOM     19  O   TYR A   1      12.298  12.462   6.643  1.00  0.83           O
ATOM     20  H   TYR A   1      10.948  12.701   9.122  1.00  0.88           H
""",
  bonds=[
    (0, 1), (0, 2), (0, 12), (1, 3), (1, 6), (2, 4), (2, 7), (3, 5),
    (3, 8), (4, 5), (4, 9), (5, 10), (10, 11), (12, 13), (12, 14),
    (12, 16), (15, 16), (15, 20), (16, 17), (16, 18), (17, 19)],
  clusters=[
    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12],
    [13, 14, 16], [15, 17, 18], [11], [20], [19]],
  hinge_edges=[
    (-1, 0), (0, 12), (12, 16), (5, 10), (16, 15), (16, 17)],
  loop_edges=[],
  loop_edge_bendings=[]),

pdb_extract(
  tag="van_fragment", # PDB code 1qd8
  pdb="""\
HETATM   47  C44 VAN     1       0.718   5.411   2.269  1.00  3.66           C
HETATM   48  C47 VAN     1       0.913   3.899   2.010  1.00  3.90           C
HETATM   49  C48 VAN     1       1.937   3.222   2.700  1.00  3.87           C
HETATM   50  C50 VAN     1       2.013   1.800   2.726  1.00  4.31           C
HETATM   51  C52 VAN     1       1.044   1.071   2.004  1.00  4.71           C
HETATM   52  O53 VAN     1       1.077  -0.297   2.083  1.00  6.04           O
HETATM   53  C51 VAN     1       0.066   1.767   1.246  1.00  5.04           C
HETATM   54  C49 VAN     1       0.006   3.153   1.237  1.00  4.22           C
HETATM   55  C45 VAN     1      -0.704   5.507   2.917  1.00  3.80           C
HETATM   56  O46 VAN     1      -1.666   5.899   2.216  1.00  4.55           O
HETATM   57  N54 VAN     1      -0.869   5.098   4.194  1.00  4.02           N
HETATM   58  C55 VAN     1       0.141   4.679   5.156  1.00  4.23           C
HETATM   69  C56 VAN     1       0.045   3.151   5.360  1.00  4.51           C
HETATM   70  O57 VAN     1      -1.022   2.542   5.259  1.00  5.51           O
HETATM   71  N68 VAN     1       1.226   2.525   5.641  1.00  4.67           N
HETATM   72  C69 VAN     1       1.340   1.069   5.484  1.00  5.14           C
HETATM   73  C72 VAN     1       2.754   0.737   4.924  1.00  4.58           C
HETATM   74  C73 VAN     1       3.049   1.131   3.577  1.00  4.34           C
HETATM   75  C75 VAN     1       4.354   0.899   3.099  1.00  4.29           C
HETATM   76  O79 VAN     1       4.736   1.286   1.834  1.00  4.73           O
HETATM   77  C76 VAN     1       5.342   0.269   3.883  1.00  4.57           C
HETATM   78  C77 VAN     1       5.023  -0.107   5.195  1.00  4.56           C
HETATM   79  O78 VAN     1       5.912  -0.707   6.053  1.00  5.51           O
HETATM   80  C74 VAN     1       3.724   0.123   5.713  1.00  4.95           C
HETATM   81  C70 VAN     1       1.069   0.287   6.838  1.00  5.82           C
HETATM   82  O71 VAN     1       1.149   0.912   7.924  1.00  7.21           O
HETATM   83  O80 VAN     1       0.816  -0.957   6.693  1.00  8.10           O
""",
  bonds=[
    (0, 1), (0, 8), (1, 2), (1, 7), (2, 3), (3, 4), (3, 17), (4, 5), (4, 6),
    (6, 7), (8, 9), (8, 10), (10, 11), (11, 12), (12, 13), (12, 14), (14, 15),
    (15, 16), (15, 24), (16, 17), (16, 23), (17, 18), (18, 19), (18, 20),
    (20, 21), (21, 22), (21, 23), (24, 25), (24, 26)],
  clusters=[
    [3, 15, 16, 17, 18, 19, 20, 21, 22, 23],
    [0, 1, 2, 4, 5, 6, 7],
    [14, 24], [25, 26], [8], [9, 10], [11], [12], [13]],
  hinge_edges=[
    (-1, 16), (17, 3), (16, 15), (15, 24), (1, 0), (0, 8), (8, 10),
    (10, 11), (11, 12)],
  loop_edges=[(12, 14)],
  loop_edge_bendings=[(11, 14), (12, 15), (13, 14)]),

pdb_extract(
  tag="ZINC00000015", # C[C@@H](C(=O)[O-])[NH+](CCCl)CCCl
  pdb="""\
ATOM      1  C00 LIG A   1       2.209   1.054   0.461  1.00 20.00      A    C
ATOM      2  C01 LIG A   1       0.708   1.054   0.461  1.00 20.00      A    C
ATOM      3  C02 LIG A   1       0.094   1.054   1.832  1.00 20.00      A    C
ATOM      4  O03 LIG A   1      -0.670   1.994   2.178  1.00 20.00      A    O
ATOM      5  O04 LIG A   1       0.433   0.179   2.672  1.00 20.00      A    O-1
ATOM      6  N05 LIG A   1       0.121   0.117  -0.463  1.00 20.00      A    N+1
ATOM      7  C06 LIG A   1       0.808  -1.157  -0.363  1.00 20.00      A    C
ATOM      8  C07 LIG A   1       1.154  -1.925  -1.637  1.00 20.00      A    C
ATOM      9 CL08 LIG A   1       1.969  -3.508  -1.515  1.00 20.00      A   CL
ATOM     10  C09 LIG A   1      -1.281  -0.063  -0.144  1.00 20.00      A    C
ATOM     11  C10 LIG A   1      -2.233  -0.595  -1.214  1.00 20.00      A    C
ATOM     12 CL11 LIG A   1      -3.974  -0.726  -0.854  1.00 20.00      A   CL
ATOM     13  H12 LIG A   1       0.449   2.022   0.057  1.00 20.00      A    H
ATOM     14  H13 LIG A   1       0.214   0.498  -1.470  1.00 20.00      A    H
""",
  bonds=[
    (0, 1), (1, 2), (1, 5), (1, 12), (2, 3), (2, 4), (5, 6), (5, 9), (5, 13),
    (6, 7), (7, 8), (9, 10), (10, 11)],
  clusters=[[0, 1, 2, 5, 12], [6, 9, 13], [3, 4], [7], [8], [10], [11]],
  hinge_edges=[(-1, 1), (1, 5), (1, 2), (5, 6), (6, 7), (5, 9), (9, 10)],
  loop_edges=[],
  loop_edge_bendings=[]),

pdb_extract(
  tag="C1CCCCCCC1",
  pdb="""\
ATOM      1  C01 LIG A   1      -0.602   0.044  -1.758  1.00 20.00      A    C
ATOM      2  C02 LIG A   1       0.946   0.044  -1.758  1.00 20.00      A    C
ATOM      3  C03 LIG A   1       1.549   0.044  -0.333  1.00 20.00      A    C
ATOM      4  C04 LIG A   1       0.985   1.155   0.557  1.00 20.00      A    C
ATOM      5  C05 LIG A   1       0.430   0.619   1.870  1.00 20.00      A    C
ATOM      6  C06 LIG A   1      -0.536  -0.585   1.672  1.00 20.00      A    C
ATOM      7  C07 LIG A   1      -1.590  -0.345   0.547  1.00 20.00      A    C
ATOM      8  C08 LIG A   1      -1.184  -0.969  -0.799  1.00 20.00      A    C
ATOM      9 H011 LIG A   1      -0.949  -0.183  -2.755  1.00 20.00      A    H
ATOM     10 H012 LIG A   1      -0.952   1.028  -1.483  1.00 20.00      A    H
ATOM     11 H021 LIG A   1       1.293  -0.834  -2.283  1.00 20.00      A    H
ATOM     12 H022 LIG A   1       1.293   0.921  -2.283  1.00 20.00      A    H
ATOM     13 H031 LIG A   1       2.618   0.172  -0.411  1.00 20.00      A    H
ATOM     14 H032 LIG A   1       1.349  -0.911   0.130  1.00 20.00      A    H
ATOM     15 H041 LIG A   1       1.773   1.861   0.775  1.00 20.00      A    H
ATOM     16 H042 LIG A   1       0.196   1.666   0.025  1.00 20.00      A    H
ATOM     17 H051 LIG A   1       1.254   0.304   2.494  1.00 20.00      A    H
ATOM     18 H052 LIG A   1      -0.102   1.413   2.373  1.00 20.00      A    H
ATOM     19 H061 LIG A   1      -1.057  -0.766   2.600  1.00 20.00      A    H
ATOM     20 H062 LIG A   1       0.045  -1.461   1.425  1.00 20.00      A    H
ATOM     21 H071 LIG A   1      -2.531  -0.775   0.857  1.00 20.00      A    H
ATOM     22 H072 LIG A   1      -1.722   0.718   0.413  1.00 20.00      A    H
ATOM     23 H081 LIG A   1      -0.452  -1.743  -0.620  1.00 20.00      A    H
ATOM     24 H082 LIG A   1      -2.056  -1.415  -1.253  1.00 20.00      A    H
""",
  bonds=[
    (0, 1), (0, 7), (0, 8), (0, 9), (1, 2), (1, 10), (1, 11),
    (2, 3), (2, 12), (2, 13), (3, 4), (3, 14), (3, 15),
    (4, 5), (4, 16), (4, 17), (5, 6), (5, 18), (5, 19),
    (6, 7), (6, 20), (6, 21), (7, 22), (7, 23)],
  clusters=[
    [0, 1, 7, 8, 9],
    [2, 10, 11], [3, 12, 13], [4, 14, 15], [5, 16, 17], [6, 18, 19],
    [20, 21], [22, 23]],
  hinge_edges=[
    (-1, 0), (0, 1), (1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (0, 7)],
  loop_edges=[(6, 7)],
  loop_edge_bendings=[(0, 6), (5, 7), (6, 22), (6, 23), (7, 20), (7, 21)]),

pdb_extract(
  tag="c1cc2ccc1CCc3ccc(cc3)CC2",
  pdb="""\
ATOM      1  C00 LIG A   1      -0.703  -1.478  -1.316  1.00 20.00      A    C
ATOM      2  C01 LIG A   1       0.705  -1.478  -1.316  1.00 20.00      A    C
ATOM      3  C02 LIG A   1       1.403  -1.478  -0.101  1.00 20.00      A    C
ATOM      4  C03 LIG A   1       0.695  -1.478   1.107  1.00 20.00      A    C
ATOM      5  C04 LIG A   1      -0.713  -1.478   1.095  1.00 20.00      A    C
ATOM      6  C05 LIG A   1      -1.400  -1.478  -0.101  1.00 20.00      A    C
ATOM      7  C06 LIG A   1      -2.732  -0.755  -0.050  1.00 20.00      A    C
ATOM      8  C07 LIG A   1      -2.724   0.768   0.057  1.00 20.00      A    C
ATOM      9  C08 LIG A   1      -1.389   1.474   0.106  1.00 20.00      A    C
ATOM     10  C09 LIG A   1      -0.698   1.663  -1.087  1.00 20.00      A    C
ATOM     11  C10 LIG A   1       0.700   1.663  -1.087  1.00 20.00      A    C
ATOM     12  C11 LIG A   1       1.392   1.474   0.106  1.00 20.00      A    C
ATOM     13  C12 LIG A   1       0.685   1.286   1.290  1.00 20.00      A    C
ATOM     14  C13 LIG A   1      -0.682   1.286   1.290  1.00 20.00      A    C
ATOM     15  C14 LIG A   1       2.727   0.768   0.057  1.00 20.00      A    C
ATOM     16  C15 LIG A   1       2.734  -0.755  -0.050  1.00 20.00      A    C
""",
  bonds=[
    (0, 1), (0, 5), (1, 2), (2, 3), (2, 15), (3, 4), (4, 5), (5, 6),
    (6, 7), (7, 8), (8, 9), (8, 13), (9, 10), (10, 11),
    (11, 12), (11, 14), (12, 13), (14, 15)],
  clusters=[[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]],
  hinge_edges=[(-1, 0)],
  loop_edges=[],
  loop_edge_bendings=[],
  find_cluster_loop_repeats=1,
  merge_clusters_with_multiple_connections_passes=2),

pdb_extract(
  tag="ZINC04656480", # C[NH+]1CC2C[NH+](CC(C1)NC2=O)C
  pdb="""\
ATOM      1  C01 LIG A   1       3.508  -0.708  -0.412  1.00 20.00      A    C
ATOM      2  N02 LIG A   1       2.081  -0.708  -0.412  1.00 20.00      A    N+1
ATOM      3  C03 LIG A   1       1.365  -0.708   0.929  1.00 20.00      A    C
ATOM      4  C04 LIG A   1       0.082   0.043   1.236  1.00 20.00      A    C
ATOM      5  C05 LIG A   1      -1.306  -0.550   0.994  1.00 20.00      A    C
ATOM      6  N06 LIG A   1      -2.192  -0.518  -0.222  1.00 20.00      A    N+1
ATOM      7  C07 LIG A   1      -1.365   0.265  -1.189  1.00 20.00      A    C
ATOM      8  C08 LIG A   1       0.016   0.896  -1.052  1.00 20.00      A    C
ATOM      9  C09 LIG A   1       1.306   0.176  -1.376  1.00 20.00      A    C
ATOM     10  N10 LIG A   1       0.128   1.826  -0.060  1.00 20.00      A    N
ATOM     11  C11 LIG A   1       0.183   1.401   1.073  1.00 20.00      A    C
ATOM     12  O12 LIG A   1       0.029   2.140   1.997  1.00 20.00      A    O
ATOM     13  C13 LIG A   1      -3.570  -0.330  -0.116  1.00 20.00      A    C
ATOM     14 H021 LIG A   1       1.870  -1.698  -0.789  1.00 20.00      A    H
ATOM     15 H061 LIG A   1      -2.133  -1.527  -0.603  1.00 20.00      A    H
""",
  bonds=[
    (0, 1), (1, 2), (1, 8), (1, 13), (2, 3), (3, 4), (3, 10), (4, 5),
    (5, 6), (5, 12), (5, 14), (6, 7), (7, 8), (7, 9), (9, 10), (10, 11)],
  clusters=[[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]],
  hinge_edges=[(-1, 1)],
  loop_edges=[],
  loop_edge_bendings=[]),

pdb_extract(
  tag="ZINC00196949", # C1C[NH+]2C[NH+]3CC[NH+](C2)C[NH+]1C3
  pdb="""\
ATOM      1  C01 LIG A   1      -0.794  -0.210  -2.068  1.00 20.00      A    C
ATOM      2  C02 LIG A   1       0.777  -0.210  -2.068  1.00 20.00      A    C
ATOM      3  N03 LIG A   1       1.469  -0.210  -0.777  1.00 20.00      A    N+1
ATOM      4  C04 LIG A   1       1.272   1.121   0.048  1.00 20.00      A    C
ATOM      5  N05 LIG A   1      -0.055   1.295   0.938  1.00 20.00      A    N+1
ATOM      6  C06 LIG A   1      -0.049   0.433   2.224  1.00 20.00      A    C
ATOM      7  C07 LIG A   1      -0.000  -0.931   1.970  1.00 20.00      A    C
ATOM      8  N08 LIG A   1       0.028  -1.145   0.699  1.00 20.00      A    N+1
ATOM      9  C09 LIG A   1       1.169  -1.328   0.066  1.00 20.00      A    C
ATOM     10  C10 LIG A   1      -1.086  -1.335   0.014  1.00 20.00      A    C
ATOM     11  N11 LIG A   1      -1.435  -0.222  -0.800  1.00 20.00      A    N+1
ATOM     12  C12 LIG A   1      -1.284   1.103   0.012  1.00 20.00      A    C
ATOM     13 H031 LIG A   1       2.523  -0.274  -1.003  1.00 20.00      A    H
ATOM     14 H051 LIG A   1      -0.075   2.324   1.264  1.00 20.00      A    H
ATOM     15 H081 LIG A   1       0.030  -0.086   0.488  1.00 20.00      A    H
ATOM     16 H111 LIG A   1      -2.490  -0.325  -1.006  1.00 20.00      A    H
""",
  bonds=[
    (0, 1), (0, 10), (1, 2), (2, 3), (2, 8), (2, 12), (3, 4),
    (4, 5), (4, 11), (4, 13), (5, 6), (6, 7), (7, 8), (7, 9), (7, 14),
    (9, 10), (10, 11), (10, 15)],
  clusters=[[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]],
  hinge_edges=[(-1, 0)],
  loop_edges=[],
  loop_edge_bendings=[]),

pdb_extract(
  tag="ZINC03847120", # c1ccc2ccccc(c1)C2(C#N)Br
  pdb="""\
ATOM      1  C01 LIG A   1      -0.432   0.012  -2.178  1.00 20.00      A    C
ATOM      2  C02 LIG A   1       0.935   0.041  -2.063  1.00 20.00      A    C
ATOM      3  C03 LIG A   1       1.687   0.100  -0.911  1.00 20.00      A    C
ATOM      4  C04 LIG A   1       1.243   0.139   0.405  1.00 20.00      A    C
ATOM      5  C05 LIG A   1       1.591  -1.206   0.440  1.00 20.00      A    C
ATOM      6  C06 LIG A   1       0.763  -2.304   0.362  1.00 20.00      A    C
ATOM      7  C07 LIG A   1      -0.604  -2.323   0.236  1.00 20.00      A    C
ATOM      8  C08 LIG A   1      -1.462  -1.249   0.162  1.00 20.00      A    C
ATOM      9  C09 LIG A   1      -1.152   0.105   0.202  1.00 20.00      A    C
ATOM     10  C10 LIG A   1      -1.368   0.038  -1.168  1.00 20.00      A    C
ATOM     11  C11 LIG A   1       0.001   0.809   0.965  1.00 20.00      A    C
ATOM     12  C12 LIG A   1      -0.253   2.219   0.533  1.00 20.00      A    C
ATOM     13  N13 LIG A   1      -0.445   3.287   0.205  1.00 20.00      A    N
ATOM     14 BR14 LIG A   1      -0.504   0.332   2.810  1.00 20.00      A   BR
""",
  bonds=[
    (0, 1), (0, 9), (1, 2), (2, 3), (3, 4), (3, 10), (4, 5), (5, 6),
    (6, 7), (7, 8), (8, 9), (8, 10), (10, 11), (10, 13), (11, 12)],
  clusters=[[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]],
  hinge_edges=[(-1, 0)],
  loop_edges=[],
  loop_edge_bendings=[]),

pdb_extract(
  tag="-ZINC12362269", # C/C(=N\NC(=O)[C@H]1CC1(C2CC2)C3CC3)/c4cccc(c4)Br
                       # atoms 16-23 removed
  pdb="""\
ATOM      1  C01 LIG A   1      -1.077  -0.498  -3.089  1.00 20.00      A    C
ATOM      2  C02 LIG A   1      -1.796  -0.766  -1.768  1.00 20.00      A    C
ATOM      3  N03 LIG A   1      -1.180  -0.649  -0.687  1.00 20.00      A    N
ATOM      4  N04 LIG A   1       0.179  -0.269  -0.687  1.00 20.00      A    N
ATOM      5  C05 LIG A   1       0.896  -0.141   0.569  1.00 20.00      A    C
ATOM      6  O06 LIG A   1       0.341  -0.355   1.593  1.00 20.00      A    O
ATOM      7  C07 LIG A   1       2.307   0.249   0.569  1.00 20.00      A    C
ATOM      8  C08 LIG A   1       2.760  -0.479   1.787  1.00 20.00      A    C
ATOM      9  C09 LIG A   1       3.212   0.911   1.550  1.00 20.00      A    C
ATOM     10  C10 LIG A   1       3.211   2.174   2.408  1.00 20.00      A    C
ATOM     11  C11 LIG A   1       3.039   3.693   2.491  1.00 20.00      A    C
ATOM     12  C12 LIG A   1       2.935   2.841   3.758  1.00 20.00      A    C
ATOM     13  C13 LIG A   1       4.738   0.961   1.496  1.00 20.00      A    C
ATOM     14  C14 LIG A   1       6.113   0.494   1.979  1.00 20.00      A    C
ATOM     15  C15 LIG A   1       6.006   1.517   0.846  1.00 20.00      A    C
""",
  bonds=[
    (0, 1), (1, 2), (2, 3), (3, 4), (4, 5), (4, 6), (6, 7), (6, 8),
    (7, 8), (8, 9), (8, 12), (9, 10), (9, 11), (10, 11),
    (12, 13), (12, 14), (13, 14)],
  clusters=[[4, 6, 7, 8, 9, 12], [10, 11], [13, 14], [3, 5], [2], [1], [0]],
  hinge_edges=[(-1, 6), (8, 9), (8, 12), (6, 4), (4, 3), (3, 2), (2, 1)],
  loop_edges=[],
  loop_edge_bendings=[]),

pdb_extract(
  tag="ZINC01638508", # C1CC1C(C2CC2)(C3CC3)O
  pdb="""\
ATOM      1  C01 LIG A   1      -0.942   1.244  -2.155  1.00 20.00      A    C
ATOM      2  C02 LIG A   1       0.586   1.277  -2.221  1.00 20.00      A    C
ATOM      3  C03 LIG A   1      -0.120   1.216  -0.865  1.00 20.00      A    C
ATOM      4  C04 LIG A   1      -0.056  -0.069  -0.042  1.00 20.00      A    C
ATOM      5  C05 LIG A   1      -0.281   0.259   1.432  1.00 20.00      A    C
ATOM      6  C06 LIG A   1      -1.658   0.020   2.055  1.00 20.00      A    C
ATOM      7  C07 LIG A   1      -1.166   1.448   1.812  1.00 20.00      A    C
ATOM      8  C08 LIG A   1       1.316  -0.717  -0.216  1.00 20.00      A    C
ATOM      9  C09 LIG A   1       1.940  -1.483   0.953  1.00 20.00      A    C
ATOM     10  C10 LIG A   1       1.427  -2.242  -0.273  1.00 20.00      A    C
ATOM     11  O11 LIG A   1      -1.048  -0.953  -0.480  1.00 20.00      A    O
""",
  bonds=[
    (0, 1), (0, 2), (1, 2), (2, 3), (3, 4), (3, 7), (3, 10),
    (4, 5), (4, 6), (5, 6), (7, 8), (7, 9), (8, 9)],
  clusters=[[2, 3, 4, 7, 10], [0, 1], [5, 6], [8, 9]],
  hinge_edges=[(-1, 3), (3, 2), (3, 4), (3, 7)],
  loop_edges=[],
  loop_edge_bendings=[]),

pdb_extract(
  tag="ZINC01638509", # C1CC(OC1)(C2CC2)C3CC3
  pdb="""\
ATOM      1  C01 LIG A   1      -1.976   0.015  -1.638  1.00 20.00      A    C
ATOM      2  C02 LIG A   1      -0.474   0.091  -1.532  1.00 20.00      A    C
ATOM      3  C03 LIG A   1      -0.172   0.077  -0.038  1.00 20.00      A    C
ATOM      4  O04 LIG A   1      -1.402   0.464   0.622  1.00 20.00      A    O
ATOM      5  C05 LIG A   1      -2.482  -0.041  -0.201  1.00 20.00      A    C
ATOM      6  C06 LIG A   1       0.849   1.194   0.167  1.00 20.00      A    C
ATOM      7  C07 LIG A   1       2.063   2.028  -0.248  1.00 20.00      A    C
ATOM      8  C08 LIG A   1       1.374   2.295   1.091  1.00 20.00      A    C
ATOM      9  C09 LIG A   1       0.546  -1.212   0.356  1.00 20.00      A    C
ATOM     10  C10 LIG A   1       1.137  -2.583   0.018  1.00 20.00      A    C
ATOM     11  C11 LIG A   1       0.535  -2.329   1.402  1.00 20.00      A    C
""",
  bonds=[
    (0, 1), (0, 4), (1, 2), (2, 3), (2, 5), (2, 8), (3, 4),
    (5, 6), (5, 7), (6, 7), (8, 9), (8, 10), (9, 10)],
  clusters=[[0, 1, 2, 3, 4, 5, 8], [6, 7], [9, 10]],
  hinge_edges=[(-1, 0), (2, 5), (2, 8)],
  loop_edges=[],
  loop_edge_bendings=[]),

pdb_extract(
  tag="ZINC00057527", # COc1cc2c(c(c1OC)OC)-c3ccc(c(=O)cc3[C@H](CC2)[NH3+])O
  pdb="""\
ATOM      1  C01 LIG A   1      -3.707  -1.073  -3.995  1.00 20.00      A    C
ATOM      2  O02 LIG A   1      -2.733  -0.091  -3.791  1.00 20.00      A    O
ATOM      3  C03 LIG A   1      -1.979  -0.103  -2.612  1.00 20.00      A    C
ATOM      4  C04 LIG A   1      -2.587  -0.442  -1.394  1.00 20.00      A    C
ATOM      5  C05 LIG A   1      -1.817  -0.515  -0.228  1.00 20.00      A    C
ATOM      6  C06 LIG A   1      -0.427  -0.384  -0.301  1.00 20.00      A    C
ATOM      7  C07 LIG A   1       0.172   0.035  -1.496  1.00 20.00      A    C
ATOM      8  C08 LIG A   1      -0.601   0.164  -2.656  1.00 20.00      A    C
ATOM      9  O09 LIG A   1      -0.012   0.608  -3.845  1.00 20.00      A    O
ATOM     10  C10 LIG A   1      -0.529   1.736  -4.489  1.00 20.00      A    C
ATOM     11  O11 LIG A   1       1.495   0.490  -1.488  1.00 20.00      A    O
ATOM     12  C12 LIG A   1       2.426  -0.085  -2.359  1.00 20.00      A    C
ATOM     13  C13 LIG A   1       0.459   0.004   0.693  1.00 20.00      A    C
ATOM     14  C14 LIG A   1       1.662  -0.498   0.151  1.00 20.00      A    C
ATOM     15  C15 LIG A   1       2.869  -0.758   0.803  1.00 20.00      A    C
ATOM     16  C16 LIG A   1       3.180  -0.590   2.138  1.00 20.00      A    C
ATOM     17  C17 LIG A   1       2.375  -0.122   3.157  1.00 20.00      A    C
ATOM     18  O18 LIG A   1       2.907   0.021   4.205  1.00 20.00      A    O
ATOM     19  C19 LIG A   1       1.045   0.298   3.092  1.00 20.00      A    C
ATOM     20  C20 LIG A   1       0.191   0.348   1.967  1.00 20.00      A    C
ATOM     21  C21 LIG A   1      -1.251   0.702   2.179  1.00 20.00      A    C
ATOM     22  C22 LIG A   1      -2.144  -0.498   2.330  1.00 20.00      A    C
ATOM     23  C23 LIG A   1      -2.468  -1.194   0.991  1.00 20.00      A    C
ATOM     24  N24 LIG A   1      -1.457   1.705   3.192  1.00 20.00      A    N+1
ATOM     25  O25 LIG A   1       4.488  -0.926   2.503  1.00 20.00      A    O
ATOM     26 H211 LIG A   1      -1.563   1.168   1.254  1.00 20.00      A    H
""",
  bonds=[
    (0, 1), (1, 2), (2, 3), (2, 7), (3, 4), (4, 5), (4, 22), (5, 6), (5, 12),
    (6, 7), (6, 10), (7, 8), (8, 9), (10, 11), (12, 13), (12, 19), (13, 14),
    (14, 15), (15, 16), (15, 24), (16, 17), (16, 18), (18, 19), (19, 20),
    (20, 21), (20, 23), (20, 25), (21, 22)],
  clusters=[
    [1, 2, 3, 4, 5, 6, 7, 8, 10, 12, 13, 14, 15, 16, 17, 18, 19,
     20, 21, 22, 23, 24, 25], [0], [9], [11]],
  hinge_edges=[(-1, 2), (2, 1), (7, 8), (6, 10)],
  loop_edges=[],
  loop_edge_bendings=[],
  find_cluster_loop_repeats=1,
  merge_clusters_with_multiple_connections_passes=2),

pdb_extract(
  # scitbx/rigid_body/essence/tst_tardy.py, exercise_near_singular_hinges()
  tag="collinear",
  pdb="""\
ATOM      1  C1  COL     1      -1.334  -0.770   0.000  1.00  0.00
ATOM      2  C2  COL     1      -1.334   0.770   0.000  1.00  0.00
ATOM      3  C3  COL     1       0.000   0.000   0.000  1.00  0.00
ATOM      4  C4  COL     1       1.540   0.000   0.000  1.00  0.00
ATOM      5  C5  COL     1       3.080   0.000   0.000  1.00  0.00
ATOM      6  C6  COL     1       4.620   0.000   0.000  1.00  0.00
ATOM      7  C7  COL     1       5.954  -0.770   0.000  1.00  0.00
""",
  bonds=[(0, 1), (0, 2), (1, 2), (2, 3), (3, 4), (4, 5), (5, 6)],
  clusters=[[0, 1, 2, 3, 4, 5], [6]],
  hinge_edges=[(-1, 0), (4, 5)],
  loop_edges=[],
  loop_edge_bendings=[]),

]

def _set_test_case_indices():
  for i,test_case in enumerate(test_cases):
    test_case.index = i
_set_test_case_indices()

def select_test_cases(tags_or_indices):
  result = []
  test_case_dict = dict([(test_case.tag,i)
    for i,test_case in enumerate(test_cases)])
  for tag_or_index in tags_or_indices:
    i = test_case_dict.get(tag_or_index)
    if (i is None):
      try: i = int(tag_or_index)
      except ValueError: i = -1
      if (i < 0 or i >= len(test_cases)):
        msg = "No such test case: %s" % tag_or_index
        print(msg)
        print("List of available test cases:")
        for i,test_case in enumerate(test_cases):
          print("  %2d: %s" % (i, test_case.tag))
        raise Sorry(msg)
    result.append(test_cases[i])
  if (len(result) == 0):
    result = test_cases
  return result


 *******************************************************************************


 *******************************************************************************
scitbx/graph/tst_rigidity.py
from __future__ import absolute_import, division, print_function
from scitbx.graph.rigidity import \
  gcd, \
  float_row_echelon_form_back_substitution, \
  row_reduced_float_rigidity_matrix, \
  determine_degrees_of_freedom, random, double_banana_edge_list
import sys, os
from six.moves import range

try:
  from libtbx.math_utils import next_permutation
except ImportError:
  def next_permutation(seq): return False

option_float_only = "--float-only" in sys.argv[1:]
if ("--repeats" in sys.argv[1:]):
  option_repeats = int(sys.argv[-1])
else:
  option_repeats = 1
option_all = "--all" in sys.argv[1:]

def int_or_none(v):
  if (v is None or v == "undefined"): return None
  return int(v)

sge_task_id = int_or_none(os.environ.get("SGE_TASK_ID"))
if (sge_task_id is not None):
  print("sge_task_id:", sge_task_id)
  sys.stdout.flush()
  random.seed(sge_task_id)

def exercise_gcd():
  assert gcd(8,0) == 8
  assert gcd(-4,0) == 4
  assert gcd(1,1) == 1
  assert gcd(10,15) == 5
  assert gcd(-18,42) == 6

def exercise_float_row_echelon_form_back_substitution():
  m = [[1,2,3,4],
       [0,0,1,4],
       [0,0,0,0]]
  free_vars = [1,3]
  sol = [3,4,5,6]
  float_row_echelon_form_back_substitution(m=m, free_vars=free_vars, sol=sol)
  assert abs(sol[0]-40) < 1.e-8
  assert sol[1] == 4
  assert abs(sol[2]+24) < 1.e-8
  assert sol[3] == 6

repeat_log = {}

def update_repeat_log(nr):
  try: repeat_log[nr] += 1
  except KeyError: repeat_log[nr] = 1

def exercise_minimal():
  for method in ["integer", "float"]:
    for n_dim in range(1,10):
      for n_vertices in range(5):
        assert determine_degrees_of_freedom(
          n_dim=n_dim, n_vertices=n_vertices, edge_list=[], method=method) \
            == n_dim * n_vertices
        assert determine_degrees_of_freedom(
          n_dim=n_dim, n_vertices=n_vertices, edge_list=[], method=method,
          also_return_repeats=True) \
            == (n_dim * n_vertices, 0)
      assert determine_degrees_of_freedom(
        n_dim=n_dim, n_vertices=2, edge_list=[(0,1)], method=method) \
          == 2 * n_dim - 1
      dof, nr = determine_degrees_of_freedom(
        n_dim=n_dim, n_vertices=2, edge_list=[(0,1)], method=method,
        also_return_repeats=True)
      assert dof == 2 * n_dim - 1
      assert isinstance(nr, int)
      update_repeat_log(nr=nr)

def exercise_is_redundant():
  edge_list = double_banana_edge_list
  for n in [2,3]:
    perm = [0,1,2]
    while True:
      el = [edge_list[i] for i in perm]
      rrfrm = row_reduced_float_rigidity_matrix(
        n_dim=3, n_vertices=3, edge_list=el[:n])
      if (n == 2):
        assert rrfrm.dof() == 7
      else:
        assert rrfrm.dof() == 6
      for edge in el[:n]:
        assert rrfrm.is_redundant(edge=edge)
      if (n == 2):
        assert not rrfrm.is_redundant(el[2])
      update_repeat_log(nr=rrfrm.repeats)
      if (not next_permutation(perm)):
        break
  #
  rrfrm = row_reduced_float_rigidity_matrix(
    n_dim=3, n_vertices=5, edge_list=edge_list[:9])
  assert rrfrm.dof() == 6
  for edge in edge_list[:9]:
    assert rrfrm.is_redundant(edge=edge)
  update_repeat_log(nr=rrfrm.repeats)
  #
  rrfrm = row_reduced_float_rigidity_matrix(
    n_dim=3, n_vertices=8, edge_list=edge_list)
  assert rrfrm.dof() == 7
  for edge in edge_list:
    assert rrfrm.is_redundant(edge=edge)
  assert rrfrm.is_redundant(edge=(3,4))
  for i in [0,1,2]:
    for j in [5,6,7]:
      assert not rrfrm.is_redundant(edge=(i,j))
  update_repeat_log(nr=rrfrm.repeats)
  #
  edge_list = [ # octahedron
    (0,1),(0,2),(0,3),(0,4),
    (1,2),(2,3),(3,4),(4,1),
    (5,1),(5,2),(5,3),(5,4)]
  rrfrm = row_reduced_float_rigidity_matrix(
    n_dim=3, n_vertices=6, edge_list=edge_list)
  assert rrfrm.dof() == 6
  assert rrfrm.is_redundant(edge=(0,5))
  assert rrfrm.is_redundant(edge=(1,3))
  assert rrfrm.is_redundant(edge=(1,3))
  update_repeat_log(nr=rrfrm.repeats)
  #
  del edge_list[3]
  rrfrm = row_reduced_float_rigidity_matrix(
    n_dim=3, n_vertices=6, edge_list=edge_list)
  assert rrfrm.dof() == 7
  assert not rrfrm.is_redundant(edge=(0,5))
  assert not rrfrm.is_redundant(edge=(1,3))
  assert not rrfrm.is_redundant(edge=(1,3))
  update_repeat_log(nr=rrfrm.repeats)

def ddof(n_dim, n_vertices, edge_list):
  n = 2 - int(option_float_only)
  results = [determine_degrees_of_freedom(
    n_dim=n_dim, n_vertices=n_vertices, edge_list=edge_list, method=method,
    also_return_repeats=True)
      for method in ["float", "integer"][:n]]
  nr = results[0][1]
  if (results[0][1] != 0):
    print("INFO: float repeats:", results[0][1])
    sys.stdout.flush()
  update_repeat_log(nr=nr)
  if (len(results) > 1):
    assert results[0][0] == results[1][0]
  return results[0][0]

def exercise_double_banana():
  n_vertices = 8
  edge_list = double_banana_edge_list
  assert len(edge_list) == 18
  assert ddof(
    n_dim=2, n_vertices=n_vertices, edge_list=edge_list) == 3
  assert ddof(
    n_dim=3, n_vertices=n_vertices, edge_list=edge_list) == 7
  assert ddof(
    n_dim=4, n_vertices=n_vertices, edge_list=edge_list) == 14
  # remove each edge in turn
  for remove in range(len(edge_list)):
    assert ddof(
      n_dim=3,
      n_vertices=n_vertices,
      edge_list=edge_list[:remove]+edge_list[remove+1:]) == 7
  # add all possible edges
  dofs = []
  for i in range(n_vertices-1):
    for j in range(i+1,n_vertices):
      dofs.append(ddof(
        n_dim=3, n_vertices=n_vertices, edge_list=edge_list+[(i,j)]))
  assert dofs == [
    7, 7, 7, 7, 6, 6, 6, 7, 7, 7, 6, 6, 6, 7,
    7, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7]

def exercise_mt1996():
  # H. Maehara and N. Tokushige
  # A Spatial Unit-Bar-Framework Which Is Rigid and Triangle-Free
  # Graphs and Combinatorics (1996) 12:341-344
  n_vertices = 26
  edge_list = [
    (0,8), (0,9), (0,12), (0,13), (0,16), (0,17), (0,20), (0,21),
    (0,22), (0,23), (1,8), (1,9), (1,12), (1,13), (1,18), (1,19),
    (1,20), (1,21), (1,24), (1,25), (2,8 ), (2,9), (2,14), (2,15),
    (2,18), (2,19), (2,22), (2,23), (2,24), (2,25), (3,8), (3,9),
    (3,14), (3,15), (3,16), (3,17), (4,10), (4,11), (4,12), (4,13),
    (4,16), (4,17), (4,22), (4,23), (4,24), (4,25), (5,10), (5,11),
    (5,12), (5,13), (5,18), (5,19), (6,10), (6,11), (6,14), (6,15),
    (6,18), (6,19), (6,20), (6,21), (6,22), (6,23), (7,10), (7,11),
    (7,14), (7,15), (7,16), (7,17), (7,20), (7,21), (7,24), (7,25),
    (8,11), (9,10), (12,15), (13,14), (16,19), (17,18)]
  assert len(edge_list) == 78
  assert ddof(
    n_dim=3, n_vertices=n_vertices, edge_list=edge_list) == 6

def exercise_k6_6_minus_six_parallel_edges():
  # "K6,6 minus six parallel edges" (Figure 3.23 of J.E. Graver,
  # Counting on Frameworks, 2001).
  n_vertices = 12
  edge_list = [
    (0,7), (0,8), (0,9), (0,10), (0,11), (1,6), (1,8), (1,9), (1,10),
    (1,11), (2,6), (2,7), (2,9), (2,10), (2,11), (3,6), (3,7), (3,8),
    (3,10), (3,11), (4,6), (4,7), (4,8), (4,9), (4,11), (5,6), (5,7),
    (5,8), (5,9), (5,10)]
  assert len(edge_list) == 30
  assert ddof(
    n_dim=3, n_vertices=n_vertices, edge_list=edge_list) == 6

def exercise_p120():
  # http://www.rwgrayprojects.com/Lynn/Coordinates/coord01.html
  n_vertices = 62
  edge_list = [
    (0,1),(0,3),(0,5),(0,7),(1,2),(1,3),(1,7),(1,8),
    (1,9),(1,10),(1,17),(1,18),(1,19),(2,3),(2,10),
    (2,11),(3,4),(3,5),(3,11),(4,5),(4,11),(4,12),(5,6),
    (5,7),(5,12),(5,13),(5,14),(5,15),(5,22),(6,7),
    (6,15),(6,16),(7,8),(7,16),(8,16),(8,17),(9,10),(9,19),
    (9,26),(10,11),(10,20),(10,26),(11,12),(11,20),
    (11,27),(11,28),(11,21),(11,29),(12,13),(12,21),(12,30),
    (13,22),(13,30),(14,15),(14,22),(14,32),(15,16),
    (15,23),(15,32),(16,17),(16,23),(16,24),(16,33),(16,34),
    (16,35),(17,18),(17,24),(17,36),(18,19),(18,36),
    (19,25),(19,26),(19,36),(20,26),(20,27),(21,29),(21,30),
    (22,30),(22,31),(22,32),(23,32),(23,33),(24,35),
    (24,36),(25,26),(25,36),(25,37),(26,27),(26,37),(26,38),
    (26,43),(26,44),(27,28),(27,38),(27,45),(28,29),
    (28,45),(29,30),(29,39),(29,45),(30,31),(30,39),(30,40),
    (30,46),(30,47),(31,32),(31,40),(32,33),(32,40),
    (32,41),(32,48),(32,49),(33,34),(33,41),(33,50),(34,35),
    (34,50),(35,36),(35,42),(35,50),(36,37),(36,42),
    (36,51),(36,52),(37,43),(37,52),(37,53),(38,44),(38,45),
    (39,45),(39,46),(40,47),(40,48),(40,57),(41,49),
    (41,50),(42,50),(42,51),(43,44),(43,53),(44,54),(44,45),
    (45,46),(45,54),(45,55),(45,56),(46,47),(46,56),
    (46,57),(47,57),(48,49),(48,57),(49,50),(49,57),(49,58),
    (50,51),(50,58),(50,59),(50,60),(51,52),(51,60),
    (51,53),(52,53),(53,54),(53,55),(53,59),(53,60),(53,61),
    (54,55),(55,56),(55,57),(55,61),(56,57),(57,58),
    (57,59),(57,61),(58,59),(59,60),(59,61)]
  assert len(edge_list) == 179
  assert ddof(
    n_dim=3, n_vertices=n_vertices, edge_list=edge_list) == 7
  assert ddof(
    n_dim=3, n_vertices=n_vertices, edge_list=edge_list+[(28,24)]) == 6

def exercise():
  exercise_gcd()
  exercise_float_row_echelon_form_back_substitution()
  exercise_minimal()
  for i_repeat in range(option_repeats):
    exercise_is_redundant()
    exercise_double_banana()
    exercise_mt1996()
    exercise_k6_6_minus_six_parallel_edges()
    if (option_all):
      exercise_p120()
  print("repeat_log =", repeat_log)
  # inline format_cpu_times (to minimize dependencies)
  t = os.times()
  print("u+s,u,s: %.2f %.2f %.2f" % (t[0] + t[1], t[0], t[1]))
  sys.stdout.flush()

if (__name__ == "__main__"):
  exercise()


 *******************************************************************************


 *******************************************************************************
scitbx/graph/tst_tardy_tree.py
from __future__ import absolute_import, division, print_function
from scitbx.graph.tardy_tree import cluster_manager, find_paths, construct
from scitbx.graph.utils import construct_edge_sets
from scitbx import matrix
from libtbx.test_utils import Exception_expected, show_diff
from six.moves import range
from six.moves import cPickle as pickle
from six.moves import cStringIO as StringIO
import sys

def random_permutation(s):
  from scitbx.array_family import flex
  return flex.select(s, flex.random_permutation(size=len(s)))

def exercise_cluster_manager():
  cm = cluster_manager(n_vertices=0)
  assert cm.cluster_indices == []
  assert cm.clusters == []
  cm = cluster_manager(n_vertices=5)
  for p in range(2):
    assert cm.cluster_indices == [0,1,2,3,4]
    assert cm.clusters == [[0],[1],[2],[3],[4]]
    cm.connect_vertices(i=0, j=0, optimize=True)
  for p in range(2):
    cm.connect_vertices(i=1, j=3, optimize=True)
    assert cm.cluster_indices == [0,1,2,1,4]
    assert cm.clusters == [[0],[1,3],[2],[],[4]]
  for p in range(2):
    cm.connect_vertices(i=0, j=3, optimize=True)
    assert cm.cluster_indices == [1,1,2,1,4]
    for q in range(2):
      assert cm.clusters == [[],[1,3,0],[2],[],[4]]
      cm.refresh_indices()
  cm.connect_vertices(i=2, j=4, optimize=True)
  assert cm.clusters == [[],[1,3,0],[2,4],[],[]]
  assert cm.cluster_indices == [1,1,2,1,2]
  cm.connect_vertices(i=2, j=3, optimize=True)
  assert cm.clusters == [[],[1,3,0,2,4],[],[],[]]
  assert cm.cluster_indices == [1,1,1,1,1]
  cm.tidy()
  assert cm.clusters == [[0,1,2,3,4]]
  assert cm.cluster_indices == [0,0,0,0,0]
  #
  cm = cluster_manager(n_vertices=6)
  cm.connect_vertices(i=3, j=0, optimize=True)
  cm.connect_vertices(i=2, j=4, optimize=True)
  cm.connect_vertices(i=1, j=2, optimize=True)
  cm.tidy()
  assert cm.clusters == [[1,2,4],[0,3],[5]]
  assert cm.cluster_indices == [1,0,0,1,0,2]
  edges = [(0,1), (0,2), (3,4), (4,5)]
  cm.connect_vertices(i=4, j=5, optimize=True)
  cm.tidy()
  assert cm.clusters == [[1,2,4,5],[0,3]]
  assert cm.cluster_indices == [1,0,0,1,0,0]
  es = construct_edge_sets(n_vertices=6, edge_list=edges)
  cm.construct_spanning_trees(edge_sets=es)
  assert cm.clusters == [[0,1,2,4,5],[3]]
  assert cm.cluster_indices == [0,0,0,1,0,0]
  assert cm.hinge_edges == [(-1,1), (1,0)]
  assert cm.loop_edges == [(2,0), (4,3)]
  assert cm.roots() == [0]
  assert cm.tree_ids() == [0,0]
  cm.find_loop_edge_bendings(edge_sets=es)
  assert cm.loop_edge_bendings == [(1,2), (3,5)]
  #
  cm.cluster_indices = [1,0,0,1,0,0]
  cm.clusters = [[1,2,4,5],[0,3]]
  cm.hinge_edges = None
  cm.loop_edges = None
  cm.loop_edge_bendings = None
  cm.merge_clusters_with_multiple_connections(edge_sets=es)
  assert cm.clusters == [[0,1,2,3,4,5]]
  assert cm.cluster_indices == [0,0,0,0,0,0]
  #
  sio = StringIO()
  assert cm.show_summary(out=sio, prefix=">") is cm
  assert not show_diff(sio.getvalue(), """\
>number of fixed vertex lists: 0
>number of fixed vertices: 0
>number of clusters: 1
>merge clusters with multiple connections: 2 passes
>number of hinge edges: None
>number of loop edges: None
>number of loop edge bendings: None
>number of fixed hinges: None
""")
  #
  cm = cluster_manager(n_vertices=3, all_in_one_rigid_body=True)
  assert cm.clusters == [[0,1,2]]
  assert cm.cluster_indices == [0,0,0]
  cm.tidy()
  cm.construct_spanning_trees(edge_sets=None)
  assert cm.clusters == [[0,1,2]]
  assert cm.cluster_indices == [0,0,0]
  assert cm.hinge_edges == [(-1,0)]
  assert cm.loop_edges == []
  assert cm.roots() == [0]
  assert cm.tree_ids() == [0]
  cm.find_loop_edge_bendings(edge_sets=None)
  assert cm.loop_edge_bendings == []

class test_case_data(object):

  def __init__(O,
        art,
        n_vertices,
        edge_list,
        clusters1,
        hinge_edges1,
        roots1,
        tree_ids1,
        loop_edges1=[],
        loop_edge_bendings1=[]):
    assert art[0] == "\n"
    O.art = art[1:]
    O.n_vertices = n_vertices
    O.edge_list = edge_list
    O.clusters1 = clusters1
    O.hinge_edges1 = hinge_edges1
    O.roots1 = roots1
    O.tree_ids1 = tree_ids1
    O.loop_edges1 = loop_edges1
    O.loop_edge_bendings1 = loop_edge_bendings1

test_cases = [
  test_case_data(
    art=r"""
0
""",
    n_vertices=1,
    edge_list=[],
    clusters1=[[0]],
    hinge_edges1=[(-1,0)],
    roots1=[0],
    tree_ids1=[0]),
  test_case_data(
    art=r"""
0 - 1
""",
    n_vertices=2,
    edge_list=[(0,1)],
    clusters1=[[0], [1]],
    hinge_edges1=[(-1,0)],
    roots1=[0],
    tree_ids1=[0]),
  test_case_data(
    art=r"""
6-membered loop
""",
    n_vertices=6,
    edge_list=[(0,1), (0,5), (1,2), (2,3), (3,4), (4,5)],
    clusters1=[[0, 1, 2, 3, 4, 5]],
    hinge_edges1=[(-1,0)],
    roots1=[0],
    tree_ids1=[0]),
  test_case_data(
    art=r"""
7-membered loop
""",
    n_vertices=7,
    edge_list=[(0,1), (0,6), (1,2), (2,3), (3,4), (4,5), (5,6)],
    clusters1=[[0], [1], [2], [3], [4], [5], [6]],
    hinge_edges1=[(-1,0), (0,1), (1,2), (2,3), (3,4)],
    roots1=[0],
    tree_ids1=[0, 0, 0, 0, 0],
    loop_edges1=[(5,6)],
    loop_edge_bendings1=[(0,5), (4,6)]),
  test_case_data(
    art=r"""
8-membered loop
""",
    n_vertices=8,
    edge_list=[(0,1), (0,7), (1,2), (2,3), (3,4), (4,5), (5,6), (6,7)],
    clusters1=[[0], [1], [2], [3], [4], [5], [6], [7]],
    hinge_edges1=[(-1,0), (0,1), (1,2), (2,3), (3,4), (4,5)],
    roots1=[0],
    tree_ids1=[0, 0, 0, 0, 0, 0],
    loop_edges1=[(6,7)],
    loop_edge_bendings1=[(0,6), (5,7)]),
  test_case_data(
    art=r"""
           7
           |
  5        1
   \     /   \
    4 - 0     2 - 8
   /         /
  6        3
           |
           9
""",
    n_vertices=10,
    edge_list=[
      (0,1), (0,4),
      (1,2), (1,7),
      (2,3), (2,8),
      (3,9),
      (4,5), (4,6)],
    clusters1=[[0], [1], [2], [3], [4], [5], [6], [7], [8], [9]],
    hinge_edges1=[(-1,1), (1,2), (1,0), (0,4), (2,3)],
    roots1=[0],
    tree_ids1=[0] * 5),
  test_case_data(
    art=r"""
           7
           |
  5        1
   \     /   \
    4 - 0     2 - 8
   /         //
  6        3 /
           |/
           9
""",
    n_vertices=10,
    edge_list=[
      (0,1), (0,4),
      (1,2), (1,7),
      (2,3), (2,8), (2,9),
      (3,9),
      (4,5), (4,6)],
    clusters1=[[2,3,9], [0], [1], [4], [5], [6], [7], [8]],
    hinge_edges1=[(-1,2), (2,1), (1,0), (0,4)],
    roots1=[0],
    tree_ids1=[0] * 4),
  test_case_data(
    art=r"""
           7
           |
  5        1
   \     /   \
    4 - 0     2 - 8
   /     \   /
  6        3
           |
           9
""",
    n_vertices=10,
    edge_list=[
      (0,1), (0,3), (0,4),
      (1,2), (1,7),
      (2,3), (2,8),
      (3,9),
      (4,5), (4,6)],
    clusters1=[[0,1,2,3], [4], [5], [6], [7], [8], [9]],
    hinge_edges1=[(-1,0), (0,4)],
    roots1=[0],
    tree_ids1=[0] * 2),
  test_case_data(
    art=r"""
           7
           |
  5        1--\
   \     /   \ \-\
    4 - 0     2 - 8
   /     \   /
  6        3
           |
           9
""",
    n_vertices=10,
    edge_list=[
      (0,1), (0,3), (0,4),
      (1,7), (1,8),
      (2,3), (2,8),
      (3,9),
      (4,5), (4,6)],
    clusters1=[[0, 1, 2, 3, 8], [4], [5], [6], [7], [9]],
    hinge_edges1=[(-1,0), (0,4)],
    roots1=[0],
    tree_ids1=[0] * 2),
  test_case_data(
    art=r"""
           7
           | \
  5        1   \
   \     /       \
    4 - 0     2 - 8
   /     \   /
  6        3
           |
           9
""",
    n_vertices=10,
    edge_list=[
      (0,1), (0,3), (0,4),
      (1,7),
      (2,3), (2,8),
      (3,9),
      (4,5), (4,6),
      (7,8)],
    clusters1=[[0, 1, 2, 3, 7, 8], [4], [5], [6], [9]],
    hinge_edges1=[(-1,0), (0,4)],
    roots1=[0],
    tree_ids1=[0] * 2),
  test_case_data(
    art=r"""
           7
           | \
  5        1   \
   \     /   \   \
    4 - 0     2 - 8
   /     \   /
  6        3
           |
           9
""",
    n_vertices=10,
    edge_list=[
      (0,1), (0,3), (0,4),
      (1,2), (1,7),
      (2,3), (2,8),
      (3,9),
      (4,5), (4,6),
      (7,8)],
    clusters1=[[0, 1, 2, 3, 7, 8], [4], [5], [6], [9]],
    hinge_edges1=[(-1,0), (0,4)],
    roots1=[0],
    tree_ids1=[0] * 2),
  test_case_data(
    art=r"""
           7
           |
  5        1
   \     /   \
    4 - 0     2 - 8
   /     \   /   /
  6        3   /
           | /
           9
""",
    n_vertices=10,
    edge_list=[
      (0,1), (0,3), (0,4),
      (1,2), (1,7),
      (2,3), (2,8),
      (3,9),
      (4,5), (4,6),
      (8,9)],
    clusters1=[[0, 1, 2, 3, 8, 9], [4], [5], [6], [7]],
    hinge_edges1=[(-1,0), (0,4)],
    roots1=[0],
    tree_ids1=[0] * 2),
  test_case_data(
    art=r"""
           7
           | \
  5        1   \
   \     /   \   \
    4 - 0     2 - 8
   /     \   /   /
  6        3   /
           | /
           9
""",
    n_vertices=10,
    edge_list=[
      (0,1), (0,3), (0,4),
      (1,2), (1,7),
      (2,3), (2,8),
      (3,9),
      (4,5), (4,6),
      (7,8),
      (8,9)],
    clusters1=[[0, 1, 2, 3, 7, 8, 9], [4], [5], [6]],
    hinge_edges1=[(-1,0), (0,4)],
    roots1=[0],
    tree_ids1=[0] * 2),
  test_case_data(
    art=r"""
           7
           |
  5        1
  |\     /   \
  | 4 - 0     2 - 8
  |/     \   /
  6        3
           |
           9
""",
    n_vertices=10,
    edge_list=[
      (0,1), (0,3), (0,4),
      (1,2), (1,7),
      (2,3), (2,8),
      (3,9),
      (4,5), (4,6),
      (5,6)],
    clusters1=[[0, 1, 2, 3], [4, 5, 6], [7], [8], [9]],
    hinge_edges1=[(-1,0), (0,4)],
    roots1=[0],
    tree_ids1=[0] * 2),
  test_case_data(
    art=r"""
0   1
""",
    n_vertices=2,
    edge_list=[],
    clusters1=[[0], [1]],
    hinge_edges1=[(-1,0), (-1,1)],
    roots1=[0, 1],
    tree_ids1=[0, 1]),
  test_case_data(
    art=r"""
0 - 2   1
""",
    n_vertices=3,
    edge_list=[(0,2)],
    clusters1=[[0], [1], [2]],
    hinge_edges1=[(-1,0), (-1,1)],
    roots1=[0, 1],
    tree_ids1=[0, 1]),
  test_case_data(
    art=r"""
           7
           | \
  5        1   \
  |\         \   \
  | 4 - 0     2 - 8
  |/         /
  6        3
           |
           9
""",
    n_vertices=10,
    edge_list=[
      (0,4),
      (1,2), (1,7),
      (2,3), (2,8),
      (3,9),
      (4,5), (4,6),
      (5,6),
      (7,8)],
    clusters1=[[1, 2, 7, 8], [4, 5, 6], [0], [3], [9]],
    hinge_edges1=[(-1,1), (2,3), (-1,4)],
    roots1=[0, 2],
    tree_ids1=[0, 0, 1]),
  test_case_data(
    art=r"""
           7
           | \
  5        1   \
             \   \
    4 - 0     2 - 8
   /     \   /
  6 ------ 3
           |
           9
""",
    n_vertices=10,
    edge_list=[
      (0,3), (0,4),
      (1,2), (1,7),
      (2,3), (2,8),
      (3,6), (3,9),
      (4,6),
      (7,8)],
    clusters1=[[0, 3, 4, 6], [1, 2, 7, 8], [5], [9]],
    hinge_edges1=[(-1,0), (3,2), (-1,5)],
    roots1=[0, 2],
    tree_ids1=[0, 0, 1]),
  test_case_data(
    art=r"""
    3 - 6 ----- 4 - 0
   /     \     /     \
  8       1   5       9
    \   /       \   /
      2 --------  7
""",
    n_vertices=10,
    edge_list=[
      (0,4), (0,9),
      (1,2), (1,6),
      (2,7), (2,8),
      (3,6), (3,8),
      (4,5), (4,6),
      (5,7),
      (7,9)],
    clusters1=[[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]],
    hinge_edges1=[(-1,0)],
    roots1=[0],
    tree_ids1=[0]),
  test_case_data(
    art=r"""
  1        5
  |\     / |
  | 0 - 3  |
  |/     \ |
  2        4
""",
    n_vertices=6,
    edge_list=[
      (0,1), (0,2), (0,3),
      (1,2),
      (3,4), (3,5),
      (4,5)],
    clusters1=[[0, 1, 2], [3, 4, 5]],
    hinge_edges1=[(-1, 0), (0, 3)],
    roots1=[0],
    tree_ids1=[0] * 2),

  ]

def exercise_test_cases(out):
  for i_tc,tc in enumerate(test_cases):
    print("test_case index:", i_tc, file=out)
    print(tc.art, file=out)
    tc_c1, tc_he1, tc_r1, tc_tid1, tc_le1, tc_leb1, \
    tc_c2, tc_he2, tc_le2, tc_leb2 = \
      tc.clusters1, tc.hinge_edges1, \
      tc.roots1, tc.tree_ids1, tc.loop_edges1, tc.loop_edge_bendings1, \
      tc.clusters1, tc.hinge_edges1, tc.loop_edges1, tc.loop_edge_bendings1
    def assert_same(label, have, expected):
      print(label, have, file=out)
      if (expected is not None):
        if (have != expected):
          print("expected:", expected, file=out)
        assert have == expected, "Note: --verbose for details"
    #
    tt = construct(n_vertices=tc.n_vertices, edge_list=tc.edge_list)
    cm = tt.cluster_manager
    assert_same("c1:", cm.clusters, tc_c1)
    cm.construct_spanning_trees(edge_sets=tt.edge_sets)
    print("c1t:", cm.clusters, file=out)
    assert_same("he1:", cm.hinge_edges, tc_he1)
    assert_same("le1:", cm.loop_edges, tc_le1)
    r = cm.roots()
    assert_same("r1:", r, tc_r1)
    tid = cm.tree_ids()
    assert_same("tid1:", tid, tc_tid1)
    cm.find_loop_edge_bendings(edge_sets=tt.edge_sets)
    assert_same("leb1:", cm.loop_edge_bendings, tc_leb1)
    #
    tt = construct(n_vertices=tc.n_vertices, edge_list=tc.edge_list)
    cm = tt.cluster_manager
    cm.merge_clusters_with_multiple_connections(edge_sets=tt.edge_sets)
    assert_same("c2:", cm.clusters, tc_c2)
    cm.construct_spanning_trees(edge_sets=tt.edge_sets)
    print("c2t:", cm.clusters, file=out)
    assert_same("he2:", cm.hinge_edges, tc_he2)
    assert_same("le2:", cm.loop_edges, tc_le2)
    cm.find_loop_edge_bendings(edge_sets=tt.edge_sets)
    assert_same("leb2:", cm.loop_edge_bendings, tc_leb2)
    #
    fp = find_paths(edge_sets=tt.edge_sets)
    for iv in range(len(tt.edge_sets)):
      fp.search_from(iv=iv)
    #
    print(file=out)

def exercise_pdb_test_cases(out):
  from scitbx.graph import test_cases_tardy_pdb
  for i_tc,tc in enumerate(test_cases_tardy_pdb.test_cases):
    print("test_cases_tardy_pdb index:", i_tc, file=out)
    tc.tardy_tree_construct()

def exercise_special_case_ZINC03847121():
  # Only case out of 69587 cases with a RIGID_MINUS_TARDY_6 cluster of
  # size different from 3:
  # RIGID_MINUS_TARDY_6: 3 NILE=0 LE=2 NV=13 ZINC03847121
  #   [(0, 10, 11), (3, 10, 12), (9, 10, 11, 12)]
  # ZINC03847121 c1ccc2ccc(=O)ccc(c1)C2
  # simplified (oxygen removed): c1ccc2cccccc(c1)C2
  n_vertices = 12
  edge_list = [
    (0, 1), (1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 7), (7, 8), (8, 9),
    (9, 10), (9, 11), (0, 10), (3, 11)]
  tt = construct(n_vertices=n_vertices, edge_list=edge_list)
  cm = tt.cluster_manager
  assert sorted(cm.overlapping_rigid_clusters(edge_sets=tt.edge_sets)) == [
    (0, 1, 2), (0, 1, 10), (0, 9, 10), (1, 2, 3), (2, 3, 4, 11),
    (3, 4, 5), (3, 9, 11), (4, 5, 6), (5, 6, 7), (6, 7, 8), (7, 8, 9),
    (8, 9, 10, 11)]
  cii_orcs, fixed_vertex_info = \
    cm.determine_weighted_order_for_construct_spanning_tree(
      edge_sets=tt.edge_sets)
  assert cii_orcs == [
    (3, 4), (9, 4), (0, 3), (1, 3), (2, 3), (4, 3),
    (5, 3), (6, 3), (7, 3), (8, 3), (10, 3), (11, 3)]
  assert fixed_vertex_info == [0] * len(cii_orcs)
  #
  tt = construct(n_vertices=n_vertices, edge_list=edge_list)
  sio = StringIO()
  assert tt.show_summary(vertex_labels=None, out=sio, prefix="$") is tt
  assert not show_diff(sio.getvalue(), """\
$number of vertices: 12
$number of edges: 13
$find cluster loops: None
$number of fixed vertex lists: 0
$number of fixed vertices: 0
$number of clusters: 12
$merge clusters with multiple connections: 0 passes
$number of hinge edges: None
$number of loop edges: None
$number of loop edge bendings: None
$number of fixed hinges: None
""")
  tt.build_tree()
  sio = StringIO()
  assert tt.show_summary(vertex_labels=None, out=sio, prefix=">") is tt
  assert not show_diff(sio.getvalue(), """\
>number of vertices: 12
>number of edges: 13
>find cluster loops: 0 repeats
>number of fixed vertex lists: 0
>number of fixed vertices: 0
>number of clusters: 9
>merge clusters with multiple connections: 1 pass
>number of hinge edges: 9
>number of loop edges: 2
>number of loop edge bendings: 5
>number of fixed hinges: None
""")
  #
  sio = StringIO()
  assert tt.cluster_manager.show_tree(out=sio) is tt.cluster_manager
  assert not show_diff(sio.getvalue(), """\
# clusters are in square brackets []
# hinge edges are in parentheses ()
# (0, 1) -> [2, 3] means that the cluster with vertices [2, 3]
#   rotates around the axis through vertices (0, 1)
# integers are vertex indices (counting from 0)
[2, 3, 4, 11]
  (3, 2) -> [1]
    (2, 1) -> [0]
      (1, 0) -> [10]
  (3, 4) -> [5]
    (4, 5) -> [6]
      (5, 6) -> [7]
        (6, 7) -> [8]
          (7, 8) -> [9]
""")
  sio = StringIO()
  assert tt.show_tree(out=sio, prefix="=-", header=False) is tt
  assert not show_diff(sio.getvalue(), """\
=-[2, 3, 4, 11]
=-  (3, 2) -> [1]
=-    (2, 1) -> [0]
=-      (1, 0) -> [10]
=-  (3, 4) -> [5]
=-    (4, 5) -> [6]
=-      (5, 6) -> [7]
=-        (6, 7) -> [8]
=-          (7, 8) -> [9]
""")

def exercise_external_clusters(n_trials=10):
  # copy of phenix_regression/tardy_action/gly_gly_box.pdb:
  """
CRYST1   12.661   12.601   14.403  90.00  90.00  90.00 P 1
ATOM      0  C   GLY A 138       5.965   6.290   5.906  1.00 35.93           C
ATOM      1  O   GLY A 138       5.429   5.188   5.784  1.00 40.71           O
ATOM      2  N   GLY A 138       7.860   7.800   5.206  1.00 34.54           N
ATOM      3  CA  GLY A 138       6.857   6.828   4.801  1.00 33.64           C
ATOM      4  N   GLY A 139       5.798   7.062   6.977  1.00 33.49           N
ATOM      5  CA  GLY A 139       4.960   6.636   8.087  1.00 33.25           C
ATOM      6  C   GLY A 139       5.536   5.495   8.904  1.00 32.97           C
ATOM      7  O   GLY A 139       4.801   4.801   9.602  1.00 35.18           O
ATOM      8  OXT GLY A 139       6.772   5.318   8.862  1.00 34.96           O
END
  """
  edge_list = [(0,1), (0,3), (0,4), (2,3), (4,5), (5,6), (6,7), (6,8)]
  expected = [
    (None,
     [[0], [1], [2], [3], [4], [5], [6], [7], [8]],
     0),
    ([[3,0,4,5], [0,1,3,4], [5,6,7,8]], # actual
     [[0,4], [1], [2], [3], [5], [6], [7], [8]],
     1),
    ([[3,0,4,5], [0,1,2,3], [5,6,7,8]], # artificial
     [[0,3,4], [1], [2], [5], [6], [7], [8]],
     2),
    ([[3,0,4,5], [0,1,2,3], [0,4,5,6]], # artificial
     [[0,3,4,5], [1], [2], [6], [7], [8]],
     3),
    ([[3,0,4,5], [0,1,2,3], [0,4,5,6], [4,5,6,8]], # artificial
     [[0,3,4,5,6], [1], [2], [7], [8]],
     4),
    ([[3,0,4,5], [0,1,2,3], [4,5,6,8]], # artificial
     [[0,3,4], [5,6], [1], [2], [7], [8]],
     3),
    ([[0,1,2,3], [4,5,6,8]], # artificial
     [[0,3], [5,6], [1], [2], [4], [7], [8]],
     2)]
  for external_clusters,expected_clusters,expected_count in expected:
    tt = construct(
      n_vertices=9, edge_list=edge_list, external_clusters=external_clusters)
    assert tt.cluster_manager.clusters == expected_clusters
    assert tt.external_clusters_connect_count == expected_count
  for external_clusters,expected_clusters,expected_count in expected:
    if (external_clusters is None): external_clusters = []
    for i_trial in range(n_trials):
      tt = construct(
        n_vertices=9,
        edge_list=random_permutation(edge_list),
        external_clusters=[random_permutation(c) for c in external_clusters])
      assert tt.cluster_manager.clusters == expected_clusters
      assert tt.external_clusters_connect_count == expected_count

def exercise_fixed_vertices(n_trials=10):
  cm = cluster_manager(n_vertices=2, fixed_vertex_lists=[[0]])
  assert cm.clusters == [[0], [1]]
  cm = cluster_manager(n_vertices=2, fixed_vertex_lists=[[1]])
  assert cm.clusters == [[1], [0]]
  edge_list = [(0,1),(1,2),(2,3),(1,3)]
  edge_sets = construct_edge_sets(n_vertices=4, edge_list=edge_list)
  for fixed_vertex in [0,1]:
    for optimize in [False, True]:
      for connects in [[(1,2),(2,3)], [(2,3),(1,2)], [(2,1),(3,2)]]:
        cm = cluster_manager(n_vertices=4, fixed_vertex_lists=[[fixed_vertex]])
        for i,j in connects:
          cm.connect_vertices(i=i, j=j, optimize=optimize)
        if (fixed_vertex == 0):
          if (connects[0] == (2,1)):
            if (not optimize):
              assert cm.clusters == [[0], [], [], [3, 2, 1]]
            else:
              assert cm.clusters == [[0], [], [2, 1, 3], []]
          else:
            if (not optimize or connects[0][0] == 1):
              assert cm.clusters == [[0], [1,2,3], [], []]
            else:
              assert cm.clusters == [[0], [], [2,3,1], []]
          cm.tidy()
          assert cm.clusters == [[0], [1,2,3]]
        else:
          assert cm.clusters == [[1,2,3], [0], [], []]
          cm.tidy()
          assert cm.clusters == [[1,2,3], [0]]
        cm.construct_spanning_trees(edge_sets=edge_sets)
        assert cm.clusters == [[0,1,2,3]]
        assert cm.hinge_edges == [(-1,1)]
        assert cm.loop_edges == []
  #
  from scitbx.graph import test_cases_tardy_pdb
  tc = test_cases_tardy_pdb.test_cases[5]
  assert tc.tag == "tyr_with_h"
  tt = tc.tardy_tree_construct(fixed_vertex_lists=[[0,16,17]])
  assert tt.cluster_manager.clusters == [
    [0,1,2,3,4,5,6,7,8,9,10,12,13,14,15,16,17,18,19],
    [11], [20]]
  try:
    tc.tardy_tree_construct(fixed_vertex_lists=[[0],[1]])
  except RuntimeError as e:
    assert str(e) == \
      "connect_clusters(): fixed vertex lists in same connected tree."
  else: raise Exception_expected
  try:
    tc.tardy_tree_construct(fixed_vertex_lists=[[0],[10]])
  except RuntimeError as e:
    assert str(e) == \
      "determine_weighted_order_for_construct_spanning_tree():" \
      " fixed vertex lists in same connected tree."
  else: raise Exception_expected
  try:
    tc.tardy_tree_construct(fixed_vertex_lists=[[0],[11]])
  except RuntimeError as e:
    assert str(e) == \
      "construct_spanning_trees():" \
      " fixed vertex lists in same connected tree."
  else: raise Exception_expected
  #
  for tc in test_cases:
    if (max(tc.tree_ids1) == 0): continue
    tt = construct(n_vertices=tc.n_vertices, edge_list=tc.edge_list)
    tt.build_tree()
    cm = tt.cluster_manager
    cl = cm.clusters
    ti = cm.tree_ids()
    assert ti[0] != ti[-1]
    for lfvl0 in range(1,len(cl[0])+1):
      for lfvl1 in range(1,len(cl[-1])+1):
        for i_trial in range(n_trials):
          fvl0 = random_permutation(cl[0])[:lfvl0]
          fvl1 = random_permutation(cl[-1])[:lfvl1]
          ttf = construct(
            n_vertices=tc.n_vertices,
            edge_list=tc.edge_list,
            fixed_vertex_lists=[fvl0, fvl1]).build_tree()
          cmf = ttf.cluster_manager
          cif = cmf.cluster_indices
          fvgci = cmf.fixed_vertices_given_cluster_index_dict()
          assert len(fvgci) == len(cmf.fixed_vertex_lists)
          for fixed_vertices in cmf.fixed_vertex_lists:
            assert len(set([cif[i] for i in fixed_vertices])) == 1
            assert fvgci[cif[fixed_vertices[0]]] is fixed_vertices
  #
  for fixed_vertex in [0,1]:
    tt = construct(
      n_vertices=2,
      edge_list=[(0,1)],
      fixed_vertex_lists=[[fixed_vertex]]).build_tree()
    assert tt.cluster_manager.clusters == [[0,1]]
  #
  for fixed_vertex in [0,1,2]:
    tt = construct(
      n_vertices=3,
      edge_list=[(0,1),(1,2)],
      fixed_vertex_lists=[[fixed_vertex]]).build_tree()
    assert tt.cluster_manager.clusters == [[0,1,2]]
  #
  el = [
    (8,9),(7,9),(3,7),(8,11),(8,12),(12,14),(13,15),(7,13),
    (1,6),(4,6),
    (0,5)]
  tt = construct(n_vertices=16, edge_list=el, fixed_vertices=())
  assert tt.cluster_manager.fixed_vertex_lists == ()
  tt = construct(n_vertices=16, edge_list=el, fixed_vertices=(12,6,4,7,9,5))
  assert tt.cluster_manager.fixed_vertex_lists == [[12,7,9], [6,4], [5]]

def exercise_fixed_hinges():
  # disulfide bond: CA - CB - SG - SG - CB - CA
  edge_list = [(0,1), (1,2), (2,5), (3,4), (4,5)]
  sites = matrix.col_list([
    ( 2.031, 74.980, 4.910),
    ( 0.672, 75.625, 4.635),
    (-0.061, 75.171, 3.047),
    (-2.009, 74.382, 0.323),
    (-0.709, 75.082, 0.718),
    (-0.355, 75.059, 2.491)])
  tt = construct(
    sites=sites,
    edge_list=edge_list,
    near_singular_hinges_angular_tolerance_deg=0)
  assert tt.cluster_manager.cluster_indices == [0,0,0,3,2,1]
  tt = construct(
    sites=sites,
    edge_list=edge_list,
    near_singular_hinges_angular_tolerance_deg=5)
  assert tt.cluster_manager.cluster_indices == [0,0,0,2,1,0]

def exercise_show_summary():
  from scitbx.graph import test_cases_tardy_pdb
  tcs = test_cases_tardy_pdb.select_test_cases(
    tags_or_indices=["ZINC03847120"])
  assert len(tcs) == 1
  tt = tcs[0].tardy_tree_construct()
  for vl,cb in [(None, ("10", "11")),
                (list("ABCDEFGHIKLMNO"), ("L", "M"))]:
    sio = StringIO()
    assert tt.show_summary(vertex_labels=vl, out=sio, prefix="&") is tt
    assert not show_diff(sio.getvalue(), """\
&number of vertices: 14
&number of edges: 15
&find cluster loops: 0 repeats
&number of fixed vertex lists: 0
&number of fixed vertices: 0
&number of clusters: 1
&merge clusters with multiple connections: 1 pass
&number of hinge edges: 1
&number of loop edges: 0
&number of loop edge bendings: 0
&number of fixed hinges: 1
&tardy fixed hinge: %s
&                   %s
""" % cb)

def exercise_edge_classifier():
  def get(tag):
    from scitbx.graph import test_cases_tardy_pdb
    tcs = test_cases_tardy_pdb.select_test_cases(tags_or_indices=[tag])
    assert len(tcs) == 1
    tt = tcs[0].tardy_tree_construct()
    ec = tt.cluster_manager.edge_classifier()
    edge_classes = {
      "base":  [],
      "hinge": [],
      "intra": [],
      "loop":  [],
      "fixed": []}
    for e in tt.edge_list:
      edge_classes[ec(edge=e)].append(e)
    return tt, edge_classes
  #
  tt, edge_classes = get(tag="van_fragment")
  assert edge_classes == {
    "base": [
      (16,17), (16,23), (17,18), (18,19), (18,20), (20,21), (21,22), (21,23)],
    "hinge": [
      (0,1), (0,8), (3,17), (8,10), (10,11), (11,12), (15,16), (15,24)],
    "intra": [
      (1,2), (1,7), (2,3), (3,4), (4,5), (4,6), (6,7), (8,9), (12,13),
      (14,15), (24,25), (24,26)],
    "loop": [(12, 14)],
    "fixed": []}
  #
  for f,i,j in [(False,6,29), (True,7,32)]:
    vlcl = tt.viewer_lines_with_colors_legend(include_loop_edge_bendings=f)
    assert len(vlcl) == i
    vlc = tt.viewer_lines_with_colors(include_loop_edge_bendings=f)
    assert len(vlc) == j
  #
  tt, edge_classes = get(tag="collinear")
  assert edge_classes == {
    "base": [(0,1), (0,2), (1,2)],
    "hinge": [(4,5)],
    "intra": [(5,6)],
    "loop": [],
    "fixed": [(2,3), (3,4)]}

def exercise_all_in_one_rigid_body():
  tt = construct(
    sites=matrix.col_list([(0,0,0), (0,0,1), (0,0,2)]),
    edge_list="all_in_one_rigid_body")
  sio = StringIO()
  tt.show_summary(vertex_labels=None, out=sio)
  assert not show_diff(sio.getvalue(), """\
number of vertices: 3
number of edges: None
find cluster loops: 0 repeats
number of fixed vertex lists: 0
number of fixed vertices: 0
number of clusters: 1
merge clusters with multiple connections: 0 passes
number of hinge edges: 1
number of loop edges: 0
number of loop edge bendings: 0
number of fixed hinges: 0
""")

def exercise_pickle():
  from scitbx.graph import test_cases_tardy_pdb
  tcs = test_cases_tardy_pdb.select_test_cases(
    tags_or_indices=["ZINC03847120"])
  assert len(tcs) == 1
  tt = tcs[0].tardy_tree_construct()
  try:
    tt.arbitrary = 0
  except AttributeError: pass # make sure __slots__ work
  else: raise Exception_expected
  ts = StringIO()
  tt.show_summary(vertex_labels=None, out=ts)
  for protocol in range(pickle.HIGHEST_PROTOCOL):
    s = pickle.dumps(tt, protocol)
    l = pickle.loads(s)
    ls = StringIO()
    l.show_summary(vertex_labels=None, out=ls)
    assert not show_diff(ls.getvalue(), ts.getvalue())

def exercise_rmsd_calculation():
  from scitbx.array_family import flex
  from libtbx.test_utils import approx_equal
  sites_1 = flex.vec3_double([(0,0,0),(0,-1,1),(0,1,1)])
  sites_2 = sites_1.select(flex.size_t([0,2,1]))
  tt = construct(sites=sites_1, edge_list=[(0,1),(0,2)])
  rmsd_calculator = tt.rmsd_calculator()
  assert approx_equal(rmsd_calculator(
    sites_cart_1=sites_1, sites_cart_2=sites_1), 0)
  assert approx_equal(rmsd_calculator(
    sites_cart_1=sites_1, sites_cart_2=sites_2), 0)
  #
  sites_1 = flex.vec3_double([
    (0,0,0),(0,-1,1),(0,1,1),(0,-1,2),(0,-2,1),(0,2,1),(0,1,2)])
  sites_2 = sites_1.select(flex.size_t([0,1,2,4,3,6,5]))
  tt = construct(
    sites=sites_1,
    edge_list=[(0,1),(0,2),(1,3),(1,4),(2,5),(2,6)])
  assert list(tt.rmsd_permutation(
    sites_cart_1=sites_1, sites_cart_2=sites_1)) == [0,1,2,3,4,5,6]
  assert list(tt.rmsd_permutation(
    sites_cart_1=sites_1, sites_cart_2=sites_2)) == [0,1,2,4,3,6,5]
  assert list(tt.rmsd_permutation(
    sites_cart_1=sites_2, sites_cart_2=sites_1)) == [0,1,2,4,3,6,5]
  #
  sites_1.append((0,2,3))
  sites_2.append((0,3,2))
  tt = construct(
    sites=sites_1,
    edge_list=[(0,1),(0,2),(1,3),(1,4),(2,5),(2,6),(6,7)])
  assert list(tt.rmsd_permutation(
    sites_cart_1=sites_1, sites_cart_2=sites_1)) == [0,1,2,3,4,5,6,7]
  assert list(tt.rmsd_permutation(
    sites_cart_1=sites_1, sites_cart_2=sites_2)) == [0,1,2,4,3,5,6,7]
  assert list(tt.rmsd_permutation(
    sites_cart_1=sites_2, sites_cart_2=sites_1)) == [0,1,2,4,3,5,6,7]

def run(args):
  assert args in [[], ["--verbose"]]
  verbose = "--verbose" in args
  if (verbose):
    out = sys.stdout
  else:
    out = StringIO()
  exercise_cluster_manager()
  exercise_test_cases(out=out)
  exercise_pdb_test_cases(out=out)
  exercise_special_case_ZINC03847121()
  exercise_external_clusters()
  exercise_fixed_vertices()
  exercise_fixed_hinges()
  exercise_show_summary()
  exercise_edge_classifier()
  exercise_all_in_one_rigid_body()
  exercise_pickle()
  exercise_rmsd_calculation()
  #
  print("OK")

if (__name__ == "__main__"):
  run(sys.argv[1:])


 *******************************************************************************


 *******************************************************************************
scitbx/graph/tst_tardy_tree_find_paths.py
from __future__ import absolute_import, division, print_function
from scitbx.graph.tardy_tree import find_paths, construct
from scitbx.graph import rigidity
from scitbx.graph import utils
import sys
from six.moves import range

def exercise_minimal():
  edge_sets = utils.construct_edge_sets(n_vertices=1, edge_list=[])
  assert find_paths(edge_sets=edge_sets).search_from(iv=0) == ({}, {})
  edge_sets = utils.construct_edge_sets(n_vertices=2, edge_list=[(0,1)])
  for iv in [0,1]:
    assert find_paths(edge_sets=edge_sets).search_from(iv=iv) == ({}, {})

def exercise_simple_loops(loop_size_max=10):
  for n_vertices in range(3, loop_size_max+1):
    edge_list = [tuple(sorted((i,(i+1)%n_vertices)))
      for i in range(n_vertices)]
    edge_sets = utils.construct_edge_sets(
      n_vertices=n_vertices, edge_list=edge_list)
    loops, dendrites = find_paths(edge_sets=edge_sets).search_from(iv=0)
    if (n_vertices <= 7):
      assert len(loops) == 2
      assert sorted(dendrites.keys()) == list(range(1,n_vertices))
    else:
      assert len(loops) == 0
      assert sorted(dendrites.keys()) == list(range(2,n_vertices-1))
    if (n_vertices == 3):
      assert loops == {1: [[2]], 2: [[1]]}
      assert dendrites == {1: [set([2])], 2: [set([1])]}
    elif (n_vertices == 4):
      assert loops == {1: [[2, 3]], 3: [[2, 1]]}
      assert dendrites == {
        1: [set([2, 3])], 2: [set([1]), set([3])], 3: [set([1, 2])]}

def exercise_knot():
  edge_sets = utils.construct_edge_sets(
    n_vertices=4,
    edge_list=[(0,1), (1,2), (2,3), (1,3)])
  expected_loops_dendrites = [
    ({}, {2: [set([1]), set([1, 3])], 3: [set([1, 2]), set([1])]}),
    ({2: [[3]], 3: [[2]]}, {2: [set([3])], 3: [set([2])]}),
    ({1: [[3]], 3: [[1]]}, {0: [set([1])], 1: [set([3])], 3: [set([1])]}),
    ({1: [[2]], 2: [[1]]}, {0: [set([1])], 1: [set([2])], 2: [set([1])]})]
  for iv in range(4):
    loop_dendrites = find_paths(edge_sets=edge_sets).search_from(iv=iv)
    assert loop_dendrites == expected_loops_dendrites[iv]

def archs_grow_edge_list(edge_list, offs, size, av=0, bv=1):
  result = list(edge_list)
  i = av
  for j in range(offs, offs+size):
    result.append((i,j))
    i = j
  result.append((bv,i))
  return result

def arch_dof(n_vertices, edge_list):
  es = utils.construct_edge_sets(n_vertices=n_vertices, edge_list=edge_list)
  bbes = utils.bond_bending_edge_sets(edge_sets=es)
  bbel = utils.extract_edge_list(edge_sets=bbes)
  dofs = [rigidity.determine_degrees_of_freedom(
    n_dim=3, n_vertices=n_vertices, edge_list=bbel, method=method)
      for method in ["float", "integer"]]
  assert dofs[0] == dofs[1]
  return es, dofs[0]

def exercise_fused_loops(arch_size_max=8):
  for arch_size_1 in range(1, arch_size_max+1):
    edge_list_1 = archs_grow_edge_list(
      [(0,1)], 2, arch_size_1)
    for arch_size_2 in range(1, arch_size_max+1):
      n_vertices = 2 + arch_size_1 + arch_size_2
      edge_list_12 = archs_grow_edge_list(
        edge_list_1, 2+arch_size_1, arch_size_2)
      es, dof = arch_dof(n_vertices=n_vertices, edge_list=edge_list_12)
      is_rigid = (dof == 6)
      inferred_is_rigid = (
            arch_size_1 < 6
        and arch_size_2 < 6
        and arch_size_1 + arch_size_2 < 10)
      assert inferred_is_rigid == is_rigid
      #
      tt = construct(
        n_vertices=n_vertices, edge_list=edge_list_12).build_tree()
      inferred_is_rigid = (len(tt.cluster_manager.clusters) == 1)
      assert inferred_is_rigid == is_rigid

def exercise_three_archs(arch_size_max=8):
  for arch_size_1 in range(1, arch_size_max+1):
    edge_list_1 = archs_grow_edge_list(
      [], 2, arch_size_1)
    for arch_size_2 in range(1, arch_size_max+1):
      edge_list_12 = archs_grow_edge_list(
        edge_list_1, 2+arch_size_1, arch_size_2)
      for arch_size_3 in range(1, arch_size_max+1):
        n_vertices = 2 + arch_size_1 + arch_size_2 + arch_size_3
        edge_list_123 = archs_grow_edge_list(
          edge_list_12, 2+arch_size_1+arch_size_2, arch_size_3)
        es, dof = arch_dof(n_vertices=n_vertices, edge_list=edge_list_123)
        expected = max(
          6,
          max(arch_size_1, arch_size_2, arch_size_3) + 1,
          arch_size_1 + arch_size_2 + arch_size_3 - 3)
        assert expected == dof
        is_rigid = (dof == 6)
        inferred_is_rigid = (
              arch_size_1 < 6
          and arch_size_2 < 6
          and arch_size_3 < 6
          and arch_size_1 + arch_size_2 + arch_size_3 < 10)
        assert inferred_is_rigid == is_rigid
        #
        tt = construct(
          n_vertices=n_vertices, edge_list=edge_list_123).build_tree()
        inferred_is_rigid = (len(tt.cluster_manager.clusters) == 1)

def run(args):
  assert len(args) == 0
  exercise_minimal()
  exercise_simple_loops()
  exercise_knot()
  exercise_fused_loops()
  exercise_three_archs()
  print("OK")

if (__name__ == "__main__"):
  run(sys.argv[1:])


 *******************************************************************************


 *******************************************************************************
scitbx/graph/tst_utils.py
from __future__ import absolute_import, division, print_function
from scitbx.graph import utils
import sys
from six.moves import range

def exercise_tree_marking():
  tree_marking = utils.tree_marking
  el = []
  for n_vertices in range(5):
    es = utils.construct_edge_sets(n_vertices=n_vertices, edge_list=el)
    ti = tree_marking(edge_sets=es).indices
    assert ti == list(range(n_vertices))
  el = [(0,1)]
  for n_vertices in range(2,5):
    es = utils.construct_edge_sets(n_vertices=n_vertices, edge_list=el)
    ti = tree_marking(edge_sets=es).indices
    assert ti == [0] + list(range(n_vertices-1))
  el = [(2,5)]
  es = utils.construct_edge_sets(n_vertices=7, edge_list=el)
  ti = tree_marking(edge_sets=es).indices
  assert ti == [0,1,2,3,4,2,5]
  for n_vertices in range(7):
    el = [(i,i+1) for i in range(n_vertices-1)]
    es = utils.construct_edge_sets(n_vertices=n_vertices, edge_list=el)
    ti = tree_marking(edge_sets=es).indices
    assert ti == [0] * n_vertices
  el = [(0,1),(2,3)]
  es = utils.construct_edge_sets(n_vertices=4, edge_list=el)
  ti = tree_marking(edge_sets=es).indices
  assert ti == [0,0,1,1]
  el = [(1,2),(0,3)]
  es = utils.construct_edge_sets(n_vertices=4, edge_list=el)
  ti = tree_marking(edge_sets=es).indices
  assert ti == [0,1,1,0]
  el = [
    (8,9),(7,9),(3,7),(8,11),(8,12),(12,14),(13,15),(7,13),
    (1,6),(4,6),
    (0,5)]
  es = utils.construct_edge_sets(n_vertices=16, edge_list=el)
  tm = tree_marking(edge_sets=es)
  assert tm.indices == [0,1,2,3,1,0,1,3,3,3,4,3,3,3,3,3]
  assert tm.partitions_of(vertex_indices=()) == []
  for i in range(16):
    assert tm.partitions_of(vertex_indices=[i]) == [[i]]
  assert tm.partitions_of(vertex_indices=[14,3]) == [[14,3]]
  assert tm.partitions_of(vertex_indices=[5,10]) == [[5],[10]]
  assert tm.partitions_of(vertex_indices=list(range(16))) == [
    [0,5], [1,4,6], [2], [3,7,8,9,11,12,13,14,15], [10]]

def run(args):
  assert len(args) == 0
  #
  el = []
  n_vertices = 0
  es = utils.construct_edge_sets(n_vertices=n_vertices, edge_list=el)
  assert len(es) == 0
  bbes = utils.bond_bending_edge_sets(edge_sets=es)
  assert len(bbes) == 0
  bbel = utils.extract_edge_list(edge_sets=bbes)
  assert len(bbel) == 0
  piel = utils.potential_implied_edge_list(
    edge_sets=es, bond_bending_edge_sets=bbes)
  assert len(piel) == 0
  bbesob = utils.bond_bending_edge_sets(edge_sets=es, omit_bonds=True)
  assert len(bbesob) == 0
  #
  el = [(0,1), (1,2), (2,3)]
  n_vertices = 4
  es = utils.construct_edge_sets(n_vertices=n_vertices, edge_list=el)
  assert len(es) == n_vertices
  bbes = utils.bond_bending_edge_sets(edge_sets=es)
  assert len(bbes) == n_vertices
  bbel = utils.extract_edge_list(edge_sets=bbes)
  assert bbel == [(0,1), (0,2), (1,2), (1,3), (2,3)]
  assert set(el).issubset(set(bbel))
  piel = utils.potential_implied_edge_list(
    edge_sets=es, bond_bending_edge_sets=bbes)
  assert piel == [(0,3)]
  assert set(bbel).isdisjoint(set(piel))
  bbesob = utils.bond_bending_edge_sets(edge_sets=es, omit_bonds=True)
  assert len(bbesob) == n_vertices
  bbelob = utils.extract_edge_list(edge_sets=bbesob)
  assert bbelob == [(0,2), (1,3)]
  #
  el = [(0,1), (1,2), (2,3), (3,4), (4,5), (5,6), (6,7)]
  n_vertices = 8
  es = utils.construct_edge_sets(n_vertices=n_vertices, edge_list=el)
  bbes = utils.bond_bending_edge_sets(edge_sets=es)
  bbel = utils.extract_edge_list(edge_sets=bbes)
  assert bbel == [
    (0, 1), (0, 2),
    (1, 2), (1, 3),
    (2, 3), (2, 4),
    (3, 4), (3, 5),
    (4, 5), (4, 6),
    (5, 6), (5, 7),
    (6, 7)]
  assert set(el).issubset(set(bbel))
  piel = utils.potential_implied_edge_list(
    edge_sets=es, bond_bending_edge_sets=bbes)
  assert piel == [(0,3), (1,4), (2,5), (3,6), (4,7)]
  assert set(bbel).isdisjoint(set(piel))
  bbesob = utils.bond_bending_edge_sets(edge_sets=es, omit_bonds=True)
  bbelob = utils.extract_edge_list(edge_sets=bbesob)
  assert bbelob == [
    (0, 2),
    (1, 3),
    (2, 4),
    (3, 5),
    (4, 6),
    (5, 7)]
  #
  el = [(0,1), (1,2), (2,3), (0,3)]
  n_vertices = 4
  es = utils.construct_edge_sets(n_vertices=n_vertices, edge_list=el)
  bbes = utils.bond_bending_edge_sets(edge_sets=es)
  bbel = utils.extract_edge_list(edge_sets=bbes)
  assert bbel == [(0,1), (0,2), (0,3), (1,2), (1,3), (2,3)]
  assert set(el).issubset(set(bbel))
  piel = utils.potential_implied_edge_list(
    edge_sets=es, bond_bending_edge_sets=bbes)
  assert piel == []
  bbesob = utils.bond_bending_edge_sets(edge_sets=es, omit_bonds=True)
  bbelob = utils.extract_edge_list(edge_sets=bbesob)
  assert bbelob == [(0, 2), (1, 3)]
  #
  el = [(0,1), (1,2), (2,3), (3,4), (4,5), (0,5)]
  n_vertices = 6
  es = utils.construct_edge_sets(n_vertices=n_vertices, edge_list=el)
  bbes = utils.bond_bending_edge_sets(edge_sets=es)
  bbel = utils.extract_edge_list(edge_sets=bbes)
  assert bbel == [
    (0,1), (0,2), (0,4), (0,5),
    (1,2), (1,3), (1,5),
    (2,3), (2,4),
    (3,4), (3,5),
    (4,5)]
  assert set(el).issubset(set(bbel))
  piel = utils.potential_implied_edge_list(
    edge_sets=es, bond_bending_edge_sets=bbes)
  assert piel == [(0,3), (1,4), (2,5)]
  assert set(bbel).isdisjoint(set(piel))
  bbesob = utils.bond_bending_edge_sets(edge_sets=es, omit_bonds=True)
  bbelob = utils.extract_edge_list(edge_sets=bbesob)
  assert bbelob == [
    (0,2), (0,4),
    (1,3), (1,5),
    (2,4),
    (3,5)]
  #
  el = [(0,1), (1,2), (2,3), (2,6), (3,4), (3,7), (4,5), (0,5)]
  n_vertices = 8
  es = utils.construct_edge_sets(n_vertices=n_vertices, edge_list=el)
  bbes = utils.bond_bending_edge_sets(edge_sets=es)
  bbel = utils.extract_edge_list(edge_sets=bbes)
  assert bbel == [
    (0,1), (0,2), (0,4), (0,5),
    (1,2), (1,3), (1,5), (1,6),
    (2,3), (2,4), (2,6), (2,7),
    (3,4), (3,5), (3,6), (3,7),
    (4,5), (4,7)]
  assert set(el).issubset(set(bbel))
  piel = utils.potential_implied_edge_list(
    edge_sets=es, bond_bending_edge_sets=bbes)
  assert piel == [(0,3), (0,6), (1,4), (1,7), (2,5), (4,6), (5,7), (6,7)]
  assert set(bbel).isdisjoint(set(piel))
  bbesob = utils.bond_bending_edge_sets(edge_sets=es, omit_bonds=True)
  bbelob = utils.extract_edge_list(edge_sets=bbesob)
  assert bbelob == [
    (0,2), (0,4),
    (1,3), (1,5), (1,6),
    (2,4), (2,7),
    (3,5), (3,6),
    (4,7)]
  #
  el = [(0,1), (1,2), (2,3), (2,6), (3,4), (3,7), (4,5), (0,5)]
  n_vertices = 8
  es = utils.construct_edge_sets(n_vertices=n_vertices, edge_list=el)
  sub = utils.sub_edge_list(edge_sets=es, vertex_indices=[])
  assert len(sub.edge_list) == 0
  assert len(sub.edge_sets()) == 0
  sub = utils.sub_edge_list(edge_sets=es, vertex_indices=[1])
  assert len(sub.edge_list) == 0
  assert len(sub.edge_sets()) == 1
  sub = utils.sub_edge_list(edge_sets=es, vertex_indices=[1,3])
  assert len(sub.edge_list) == 0
  assert len(sub.edge_sets()) == 2
  sub = utils.sub_edge_list(edge_sets=es, vertex_indices=[1,0])
  assert sub.edge_list == [(0,1)]
  assert len(sub.edge_sets()) == 2
  assert sub.reindexing_dict == {0: 1, 1: 0}
  sub = utils.sub_edge_list(edge_sets=es, vertex_indices=[6,7,3,2])
  assert sub.edge_list == [(1,2), (2,3), (0,3)]
  assert len(sub.edge_sets()) == 4
  assert sub.reindexing_dict == {2: 3, 3: 2, 6: 0, 7: 1}
  #
  exercise_tree_marking()
  #
  print("OK")

if (__name__ == "__main__"):
  run(sys.argv[1:])


 *******************************************************************************


 *******************************************************************************
scitbx/graph/utils.py
from __future__ import absolute_import, division, print_function
from libtbx import slots_getstate_setstate
from six.moves import range

def construct_edge_sets(n_vertices, edge_list, assert_i_lt_j=True):
  result = [set() for i in range(n_vertices)]
  for i,j in edge_list:
    if (assert_i_lt_j):
      assert i < j
    else:
      assert i != j
    result[i].add(j)
    result[j].add(i)
  return result

def extract_edge_list(edge_sets):
  result = []
  for i,edge_set in enumerate(edge_sets):
    for j in sorted(edge_set):
      if (j < i): continue
      result.append((i,j))
  return result

def bond_bending_edge_sets(edge_sets, omit_bonds=False):
  if (omit_bonds):
    result = [set() for i in range(len(edge_sets))]
  else:
    result = [set(edge_set) for edge_set in edge_sets]
  for i,edge_set in enumerate(edge_sets):
    for j in edge_set:
      if (j < i): continue
      for k in edge_sets[j]:
        if (k == i): continue
        if (omit_bonds and k in edge_sets[i]): continue
        result[i].add(k)
      for k in edge_sets[i]:
        if (k == j): continue
        if (omit_bonds and k in edge_sets[j]): continue
        result[j].add(k)
  return result

def potential_implied_one_way_edge_sets(edge_sets, bond_bending_edge_sets):
  result = [set() for i in range(len(edge_sets))]
  for i,edge_set in enumerate(edge_sets):
    for j in edge_set:
      if (j == i): continue
      for k in edge_sets[j]:
        if (k == j): continue
        if (k == i): continue
        for l in edge_sets[k]:
          if (l == i): continue
          if (l in bond_bending_edge_sets[i]): continue
          if (i < l): result[i].add(l)
          else:       result[l].add(i)
  return result

def potential_implied_edge_list(edge_sets, bond_bending_edge_sets):
  return extract_edge_list(
    edge_sets=potential_implied_one_way_edge_sets(
      edge_sets=edge_sets, bond_bending_edge_sets=bond_bending_edge_sets))

class sub_edge_list(object):

  def __init__(O, edge_sets, vertex_indices):
    O.vertex_indices = vertex_indices
    O.reindexing_dict = {}
    for i_sub,i in enumerate(vertex_indices):
      O.reindexing_dict[i] = i_sub
    assert len(O.reindexing_dict) == len(vertex_indices)
    O.edge_list = []
    ea = O.edge_list.append
    for i_sub,i in enumerate(vertex_indices):
      for j in edge_sets[i]:
        if (i > j): continue
        assert i != j
        j_sub = O.reindexing_dict.get(j)
        if (j_sub is None): continue
        if (i_sub < j_sub): ea((i_sub, j_sub))
        else:               ea((j_sub, i_sub))

  def edge_sets(O):
    return construct_edge_sets(
      n_vertices=len(O.vertex_indices),
      edge_list=O.edge_list)

class tree_marking(slots_getstate_setstate):

  __slots__ = ["edge_sets", "n_trees", "indices"]

  def __init__(O, edge_sets):
    n_vertices = len(edge_sets)
    indices = [n_vertices] * n_vertices
    i_tree = 0
    for i_root in range(n_vertices):
      if (indices[i_root] == n_vertices):
        follow = [i_root]
        while (len(follow) != 0):
          i = follow.pop()
          if (indices[i] == n_vertices):
            indices[i] = i_tree
            follow.extend(edge_sets[i])
        i_tree += 1
    O.edge_sets = edge_sets
    O.n_trees = i_tree
    O.indices = indices

  def partitions_of(O, vertex_indices):
    result = []
    ti = O.indices
    nt = O.n_trees
    ri = [nt] * nt
    for i in vertex_indices:
      tii = ti[i]
      rii = ri[tii]
      if (rii == nt):
        ri[tii] = len(result)
        result.append([i])
      else:
        result[rii].append(i)
    return result


 *******************************************************************************
