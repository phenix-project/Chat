

 *******************************************************************************
smtbx/__init__.py


 *******************************************************************************


 *******************************************************************************
smtbx/ab_initio/__init__.py
from __future__ import absolute_import, division, print_function
import boost_adaptbx.boost.python as bp
ext = bp.import_ext("smtbx_ab_initio_ext")
import smtbx_ab_initio_ext as ext


 *******************************************************************************


 *******************************************************************************
smtbx/ab_initio/charge_flipping.py
r""" Charge flipping algorithm(s) and related data structures

References.

[1] G. Oszl{\'a}nyi and A. S{\"u}t{\H o}.
Ab initio structure solution by charge flipping.
Acta Cryst. A, 60:134--141, 2003.

[2] G. Oszl{\'a}nyi and A. S{\"u}t{\H o}.
Ab initio structure solution by charge flipping.
II. use of weak reflections. Acta Cryst. A, 61:147, 2004.

[3] L. Palatinus and G. Chapuis
SUPERFLIP -- a computer program for the solution of crystal structures
by charge flipping in arbitry dimensions
J. Appl. Cryst., 40:786--790, 2007

[4] M. Shiono and M.M. Woolfson.
Direct-space methods in phase extension and phase determination.
I. low-density elimination. Acta Cryst. A, 48:451-456, 1992.
--> This is a protein paper

[5] H. Takakura, M. Shiono, T.J. Sato, A. Yamamoto, and A.P. Tsai.
Ab initio structure determination of icosahedral zn-mg-ho quasicrystals
by density modification method.
Phys. Rev. Lett., 86:236, 2001
--> This is an elaboration on the method in [4] as well as an application in a
different compartment of crystallography. This is also the method used
in SUPERFLIP circa Sept 2007 to polish the electron density after the charge
flipping method has converged.

[6] G. Oszl{\'a}nyi and A. S{\"u}t{\H o}. The charge flipping algorithm. Acta
Cryst. A64:123-134, 2008
"""

from __future__ import absolute_import, division, print_function

from libtbx import object_oriented_patterns as oop
from libtbx import adopt_optional_init_args

from cctbx.array_family import flex
from cctbx import crystal
from cctbx import sgtbx
from cctbx import miller
from cctbx import maptbx
from cctbx import translation_search
from cctbx import symmetry_search

from smtbx import ab_initio

import scitbx.math

import itertools
import sys
import math
from six.moves import range

class _array_extension(oop.injector, miller.array):

  def oszlanyi_suto_phase_transfer(self,
                                   source,
                                   delta_varphi=math.pi/2,
                                   weak_reflection_fraction=0.2,
                                   need_sorting=True):
    """ As per ref. [2] """
    cut = int(weak_reflection_fraction * source.size())
    if need_sorting:
      p = self.sort_permutation(by_value="data", reverse=True)
      target = self.select(p)
      source = source.select(p)
    else:
      target = self
    source_phases = flex.arg(source.data())
    # weak reflections
    phases = source_phases[:cut] + delta_varphi
    moduli = flex.abs(source.data()[:cut])
    # strong ones
    phases.extend(source_phases[cut:])
    moduli.extend(self.data()[cut:])
    return miller.array(self, moduli).phase_transfer(phases)


class _fft_extension(oop.injector, miller.fft_map):
  """ We add those methods to fft_map so that they can be easily reused and
  tested independently of the charge flipping iterators. """

  def flipped_fraction_as_delta(self, fraction):
    rho = self.real_map_unpadded(in_place=False).as_1d()
    p = flex.sort_permutation(rho)
    sorted_rho = rho.select(p)
    return sorted_rho[int(fraction * sorted_rho.size())]
  flipped_fraction_as_delta = oop.memoize_method(flipped_fraction_as_delta)

  def c_flip(self, delta):
    rho = self.real_map_unpadded(in_place=False).as_1d()
    return flex.sum(flex.abs(rho.select(rho < delta)))
  c_flip = oop.memoize_method(c_flip)

  def c_tot(self):
    return flex.sum(self.real_map())
  c_tot = oop.memoize_method(c_tot)

  def skewness(self):
    return maptbx.more_statistics(self.real_map()).skewness()
  skewness = oop.memoize_method(skewness)

  def sigma(self):
    return maptbx.statistics(self.real_map()).sigma()
  sigma = oop.memoize_method(sigma)


class density_modification_iterator(object):
  """ Skeleton for any method which, like charge flipping, does cycles like

      rho --|1|--> rho' --|Fourier analysis|--> g --|2|--> f
       ^                                                   |
       |----------------|Fourier synthesis|----------------|

    where the transformation (1) and (2) are specific to each method.

    Synopsis:
      flipping = heir_of_density_modification_iterator(...)
      flipping.start(f_obs, initial_phases)
      flipping.next() # 1st cycle
      flipping.next() # 2nd cycle
      ....
  """

  def __init__(self, **kwds):
    adopt_optional_init_args(self, kwds)

  def start(self, f_obs, phases, f_000=0):
    self.f_obs = f_obs
    self.crystal_gridding = maptbx.crystal_gridding(
      unit_cell=self.f_obs.unit_cell(),
      space_group_info=sgtbx.space_group_info('P1'),
      d_min=self.f_obs.d_min(),
      resolution_factor=1/2,
      symmetry_flags=maptbx.use_space_group_symmetry)

    self.fft_scale = (self.f_obs.crystal_symmetry().unit_cell().volume()
                      / self.crystal_gridding.n_grid_points())
    self.f_calc = self.f_obs.phase_transfer(phases)
    self.f_000 = f_000
    self.compute_electron_density_map()

  def normalise(self, normalisations, divide=True):
    m = self.f_obs.match_indices(normalisations)
    assert not m.singles(0) and not m.singles(1)
    normalisations = normalisations.select(m.permutation())
    assert self.f_obs.indices() == normalisations.indices()
    if divide:
      self.f_obs /= normalisations.data()
      self.f_calc /= normalisations.data()
    else:
      self.f_obs *= normalisations.data()
      self.f_calc *= normalisations.data()
    self.f_000 = 0
    self.compute_electron_density_map()

  def denormalise(self, normalisations):
    self.normalise(normalisations, divide=False)

  def __iter__(self):
    return self

  def __next__(self):
    """ perform one cycle and return itself """
    self.modify_electron_density()
    self.compute_structure_factors()
    self.transfer_phase_to_f_obs()
    self.f_000 = self._g_000
    self.compute_electron_density_map()
    return self # iterator-is-its-own-state trick

  ## Python 2 compatibility ##
  if sys.hexversion < 0x03000000:
    next = __next__
    del __next__

  def compute_electron_density_map(self):
    """ Compute the electron density from the structure factors self.f_calc
    and the 000 component self.f_000, scaling by the unit cell volume """
    self.rho_map = miller.fft_map(self.crystal_gridding,
                                  self.f_calc,
                                  self.f_000)
    self.rho_map.apply_volume_scaling()

  def compute_structure_factors(self):
    """ Compute the structure factors self._g of self.rho_map,
    as well as the 000 component self._g_000, scaling them by the number of
    grid points """
    rho = self.rho_map.real_map()
    self._g_000 = flex.sum(rho) * self.fft_scale
    self._g = self.f_obs.structure_factors_from_map(rho, in_place_fft=True)
    self._g *= self.fft_scale

  def transfer_phase_to_f_obs(self):
    self.f_calc = self.f_obs.phase_transfer(self._g)

  def r1_factor(self):
    return self.f_obs.r1_factor(self._g, assume_index_matching=True)


class basic_iterator(density_modification_iterator):
  """ An iterator over the sequence of electron densities and structure
  factors obtained by repeateadly applying the basic charge flipping
  described in ref. [1].
  """

  def __init__(self, delta=None, **kwds):
    super(basic_iterator, self).__init__(**kwds)
    self.delta = delta

  def normalise(self, normalisations, divide=True):
    old_sigma = self.rho_map.sigma()
    super(basic_iterator, self).normalise(normalisations, divide)
    self.delta *= self.rho_map.sigma() / old_sigma

  def c_tot_over_c_flip(self):
    return self.rho_map.c_tot()/self.rho_map.c_flip(self.delta)

  def modify_electron_density(self):
    """ This shall modify rho in place """
    ab_initio.ext.flip_charges_in_place(self.rho_map.real_map(), self.delta)


class weak_reflection_improved_iterator(basic_iterator):
  """ The variation described in ref. [2] """

  def __init__(self, delta=None,
               delta_varphi=math.pi/2,
               weak_reflection_fraction=0.2,
               **kwds):
    super(weak_reflection_improved_iterator,
          self).__init__(delta, **kwds)
    self.delta_varphi = delta_varphi
    self.weak_reflection_fraction = weak_reflection_fraction

  def start(self, f_obs, phases, f_000=0):
    """ sort f_obs by increasing amplitudes once and for all """
    super(weak_reflection_improved_iterator, self).start(f_obs, phases, f_000)
    p = self.f_obs.sort_permutation(by_value="data", reverse=True)
    self.f_obs = self.f_obs.select(p)

  def transfer_phase_to_f_obs(self):
    self.f_calc = self.f_obs.oszlanyi_suto_phase_transfer(
      self._g,
      self.delta_varphi,
      self.weak_reflection_fraction,
      need_sorting=False)


class low_density_elimination_iterator(density_modification_iterator):
  """ A method related to charge flipping.
  C.f. Ref [4].
  """

  def __init__(self, constant_rho_c=None, **kwds):
    super(low_density_elimination_iterator, self).__init__(**kwds)
    self.constant_rho_c = constant_rho_c

  def normalise(self, normalisations, divide=True):
    raise NotImplementedError

  def modify_electron_density(self):
    ab_initio.ext.low_density_elimination_in_place_tanaka_et_al_2001(
      self.rho_map.real_map(), self.rho_c())

  def rho_c(self):
    if self.constant_rho_c is not None:
      return self.constant_rho_c
    else:
      return self.shiono_woolfson_rho_c()

  def shiono_woolfson_rho_c(self):
    """ The rho_c suggested in Ref [4] """
    rho = self.rho_map.real_map_unpadded(in_place=False).as_1d()
    return 0.2*flex.mean(rho.select(rho >0))


def f_calc_symmetrisations(f_obs, f_calc_in_p1, min_cc_peak_height):
  # The fast correlation map as per cctbx.translation_search.fast_nv1995
  # is computed and its peaks studied.
  # Inspiration from phenix.substructure.hyss for the parameters tuning.
  if 0: # Display f_calc_in_p1
    from crys3d.qttbx import map_viewer
    map_viewer.display(window_title="f_calc in P1 before fast CC",
                       fft_map=f_calc_in_p1.fft_map(),
                       iso_level_positive_range_fraction=0.8)

  crystal_gridding = f_obs.crystal_gridding(
    symmetry_flags=translation_search.symmetry_flags(
      is_isotropic_search_model=False,
      have_f_part=False),
    resolution_factor=1/3
  )
  correlation_map = translation_search.fast_nv1995(
    gridding=crystal_gridding.n_real(),
    space_group=f_obs.space_group(),
    anomalous_flag=f_obs.anomalous_flag(),
    miller_indices_f_obs=f_obs.indices(),
    f_obs=f_obs.data(),
    f_part=flex.complex_double(), ## no sub-structure is already fixed
    miller_indices_p1_f_calc=f_calc_in_p1.indices(),
    p1_f_calc=f_calc_in_p1.data()).target_map()

  if 0: # Display correlation_map
    from crys3d.qttbx import map_viewer
    map_viewer.display(window_title="Fast CC map",
                       raw_map=correlation_map,
                       unit_cell=f_calc_in_p1.unit_cell(),
                       positive_iso_level=0.8)

  search_parameters = maptbx.peak_search_parameters(
    peak_search_level=1,
    peak_cutoff=0.5,
    interpolate=True,
    min_distance_sym_equiv=1e-6,
    general_positions_only=False,
    min_cross_distance=f_obs.d_min()/2)
  ## The correlation map is not a miller.fft_map, just a 3D flex.double
  correlation_map_peaks = crystal_gridding.tags().peak_search(
    map=correlation_map,
    parameters=search_parameters)
  # iterate over the strong peak; for each, shift and symmetrised f_calc
  for peak in correlation_map_peaks:
    if peak.height < min_cc_peak_height: break
    sr = symmetry_search.shift_refinement(
      f_obs, f_calc_in_p1, peak.site)
    yield sr.symmetrised_shifted_sf.f_x, sr.shift, sr.goos.correlation


def amplitude_quasi_normalisations(f_obs):
  f_obs.setup_binner_counting_sorted(reflections_per_bin=200)
  return f_obs.amplitude_quasi_normalisations()


class solving_iterator(object):

  normalisations_for = None
  initial_phases_for = staticmethod(
    lambda f_obs: (2*math.pi)*flex.random_double(f_obs.size()))

  delta_guessing_method = "sigma"
  delta_over_sigma = 1.1
  min_delta_guessing_iterations = 4
  max_delta_guessing_iterations = 10
  map_sigma_stability_threshold = 0.01
  initial_flipped_fraction=0.8
  yield_during_delta_guessing = False
  max_solving_iterations = 500
  max_attempts_to_get_phase_transition = 5
  max_attempts_to_get_sharp_correlation_map = 5
  yield_solving_interval = 10
  extra_iterations_on_f_after_phase_transition = 10
  map_skewness_stability_threshold = 0.01
  polishing_iterations = 5
  min_cc_peak_height = 0.9

  def __init__(self, flipping_iterator, f_obs, **kwds):
    self.flipping_iterator = flipping_iterator
    adopt_optional_init_args(self, kwds)
    assert (self.min_delta_guessing_iterations
            < self.max_delta_guessing_iterations)
    self.attempts = []
    self.normalisations = None
    self.f_calc_solutions = []
    self.had_phase_transition = False
    self.max_attempts_exceeded = False

    # prepare f_obs
    f_obs = f_obs.eliminate_sys_absent()\
                 .as_non_anomalous_array() \
                 .merge_equivalents().array()

    # setup state machine
    self.state = self.starting = self._starting(f_obs)
    self.guessing_delta = {
      "sigma": self._guessing_delta_with_map_sigma,
      "c_tot_over_c_flip": self._guessing_delta_with_c_tot_over_c_flip,
      }[self.delta_guessing_method]()
    self.solving = self._solving()
    self.polishing = self._polishing()
    self.evaluating = self._evaluating(f_obs)
    self.finished = self._finished()

  def __iter__(self):
    """ Note: a loop for flipping in solving_iterator_obj: that is
    interrupted by break will reliably result in a call
    solving_iterator_obj.clean_up() in Python 2.5+ while the code should
    still run on earlier versions of Python but without the clean-up. """
    while True:
      try: state = next(self.state)
      except StopIteration: break
      try: yield self.flipping_iterator
      except GeneratorExit: break
      self.state = state
    self.clean_up()

  def clean_up(self):
    """ The generator-based state machine pattern used to implement this
    class creates cycles for each generator:
       self.polishing.gi_frame.f_locals['self'] is self == True
    for example.
    Thus reference counting does not have it collected,
    and self.flipping_iterator is not collected either.
    The latter holds large objects (a fft_map and a miller.array), which
    results in the memory being used to creep up each time a charge
    flipping run is done.
    Note: using a weak reference for solving.flipping_iterator would not work
    because that object is also owned by several of the generators' frame
    mentionned above.

    Thus we delete the generators after the run has finished, therefore
    breaking the cycle.
    """
    del self.state
    del self.starting
    del self.guessing_delta
    del self.solving
    del self.polishing
    del self.evaluating
    del self.finished

  def _starting(self, f_obs):
    f_obs = f_obs.expand_to_p1() \
                 .merge_equivalents().array() \
                 .discard_sigmas()
    if self.normalisations_for is not None:
      self.normalisations = self.normalisations_for(f_obs)
      f_obs /= self.normalisations.data()
    while True:
      self.flipping_iterator.start(f_obs, self.initial_phases_for(f_obs))
      yield self.guessing_delta

  def _finished(self):
    if not self.max_attempts_exceeded:
      self.had_phase_transition = True
    yield self.finished

  def _guessing_delta_with_c_tot_over_c_flip(self):
    flipping = self.flipping_iterator
    delta_needs_initialisation = True
    while True:
      self.f_calc_solutions = []
      if delta_needs_initialisation:
        flipping.delta = flipping.rho_map.flipped_fraction_as_delta(
                                                self.initial_flipped_fraction)
        delta_needs_initialisation = False
      for foo in itertools.islice(flipping,
                                  self.max_delta_guessing_iterations):
        pass
      r = flipping.c_tot_over_c_flip()
      # magic numbers from SUPERFLIP
      low, high = 0.8, 1.
      if low <= r <= high:
        yield self.solving
        flipping.restart()
        delta_needs_initialisation = True
      else:
        if self.yield_during_delta_guessing:
          yield self.guessing_delta
        if r < low:
          flipping.delta *= 0.9
        elif r > high:
          flipping.delta *= 1.07

  def _guessing_delta_with_map_sigma(self):
    while True:
      self.f_calc_solutions = []
      sigmas = flex.double()
      for i in range(self.max_delta_guessing_iterations):
        sigma = self.flipping_iterator.rho_map.sigma()
        sigmas.append(sigma)
        self.flipping_iterator.delta = self.delta_over_sigma * sigma
        if len(sigmas) < self.min_delta_guessing_iterations:
          next(self.flipping_iterator)
          continue
        sigma_tail_stats = scitbx.math.basic_statistics(sigmas[-5:])
        if (abs(sigma_tail_stats.bias_corrected_standard_deviation
                /sigma_tail_stats.mean) < self.map_sigma_stability_threshold):
          break
        if self.yield_during_delta_guessing: yield self.guessing_delta
        next(self.flipping_iterator)
      yield self.solving

  def _solving(self):
    while True:
      i_attempt = 0
      while i_attempt < self.max_attempts_to_get_phase_transition:
        i_attempt += 1
        if i_attempt > 2:
          self.max_solving_iterations *= 1.5
        self.skewness_evolution = observable_evolution()
        for n, flipping in enumerate(
          itertools.islice(self.flipping_iterator,
                           0, self.max_solving_iterations)):
          self.iteration_index = n
          if n % self.yield_solving_interval == 0:
            yield self.solving
          self.skewness_evolution.append(flipping.rho_map.skewness())
          #if flipping.rho_map.skewness() < 3: continue
          if self.skewness_evolution.had_phase_transition():
            self.attempts.append(n)
            yield self.polishing
            break
        else:
          if i_attempt != self.max_attempts_to_get_phase_transition:
            yield self.starting
      self.max_attempts_exceeded = True
      yield self.finished

  def _polishing(self):
    while True:
      if 0: # Display map
        from crys3d.qttbx import map_viewer
        map_viewer.display(fft_map=self.flipping_iterator.f_calc.fft_map(),
                           iso_level_positive_range_fraction=0.4)
      if self.normalisations:
        # if we have been working on normalised amplitudes
        # (i.e. in practice E's or quasi-E's, it is better to go back to
        # F's before polishing.
        # According to [6], a few cycles of charge flipping on those F's
        # before polishing improves map quality.
        self.flipping_iterator.denormalise(self.normalisations)
        skewness = flex.double()
        for i in range(self.extra_iterations_on_f_after_phase_transition):
          next(self.flipping_iterator)
          skewness.append(self.flipping_iterator.rho_map.skewness())
          if i < 3: continue
          stats = scitbx.math.median_statistics(skewness[-3:])
          if (stats.median_absolute_deviation
              < self.map_skewness_stability_threshold): break
      low_density_elimination = low_density_elimination_iterator(
        constant_rho_c=self.flipping_iterator.delta)
      low_density_elimination.start(f_obs=self.flipping_iterator.f_obs,
                                    phases=self.flipping_iterator.f_calc,
                                    f_000=0)
      for i in range(self.polishing_iterations):
        next(low_density_elimination)
      yield self.evaluating

  def _evaluating(self, original_f_obs):
    while True:
      attempts = 0
      while attempts < self.max_attempts_to_get_sharp_correlation_map:
        attempts += 1
        self.f_calc_solutions = []
        for f_calc, shift, cc_peak_height\
            in f_calc_symmetrisations(original_f_obs,
                                      self.flipping_iterator.f_calc,
                                      self.min_cc_peak_height):
          if cc_peak_height < self.min_cc_peak_height: break
          self.f_calc_solutions.append((f_calc, shift, cc_peak_height))
        if self.f_calc_solutions: yield self.finished
        else: yield self.starting
      self.max_attempts_exceeded = True

def loop(solving, verbose=True, out=sys.stdout):
  previous_state = None
  for flipping in solving:
    if solving.state is solving.guessing_delta:
      # Guessing a value of delta leading to subsequent good convergence
      if verbose:
        if previous_state is solving.solving:
          print("** Restarting (no phase transition) **", file=out)
        elif previous_state is solving.evaluating:
          print("** Restarting (no sharp correlation map) **", file=out)
      if verbose == "highly":
        if previous_state is not solving.guessing_delta:
          print("Guessing delta...", file=out)
          print(("%10s | %10s | %10s | %10s | %10s | %10s | %10s"
                            % ('delta', 'delta/sig', 'R', 'F000',
                               'c_tot', 'c_flip', 'c_tot/c_flip')), file=out)
          print("-"*90, file=out)
        rho = flipping.rho_map
        c_tot = rho.c_tot()
        c_flip = rho.c_flip(flipping.delta)
        # to compare with superflip output
        c_tot *= flipping.fft_scale; c_flip *= flipping.fft_scale
        print("%10.4f | %10.4f | %10.3f | %10.3f | %10.1f | %10.1f | %10.2f"\
              % (flipping.delta, flipping.delta/rho.sigma(),
                 flipping.r1_factor(), flipping.f_000,
                 c_tot, c_flip, c_tot/c_flip), file=out)

    elif solving.state is solving.solving:
      # main charge flipping loop to solve the structure
      if verbose=="highly":
        if previous_state is not solving.solving:
          print(file=out)
          print("Solving...", file=out)
          print("with delta=%.4f" % flipping.delta, file=out)
          print(file=out)
          print("%5s | %10s | %10s" % ('#', 'F000', 'skewness'), file=out)
          print('-'*33, file=out)
        print("%5i | %10.1f | %10.3f" % (
          solving.iteration_index,
          flipping.f_000,
          flipping.rho_map.skewness()), file=out)

    elif solving.state is solving.polishing:
      if verbose == 'highly':
        print(file=out)
        print("Polishing", file=out)
    elif solving.state is solving.finished:
      if solving.max_attempts_exceeded:
        print(file=out)
        print("** Maximum number of attempts exceeded: it won't solve!", file=out)
      break
    previous_state = solving.state


class observable_evolution(object):

  smoothing_coefficient = 0.25
  increasing = True
  noise_level_before = 0.3
  noise_level_after = 0.2

  def __init__(self, **kwds):
    adopt_optional_init_args(self, kwds)
    self.values = flex.double()
    self.raw_values = flex.double()
    self.differences = flex.double()

  def append(self, x):
    self.raw_values.append(x)
    if len(self.values) > 1:
      a = self.smoothing_coefficient
      y0 = self.values[-1]
      y1 = y0 + a*(x - y0)
      self.values.append(y1)
      delta = y1 - y0
      if not self.increasing: delta = -delta
      self.differences.append(delta)
    else:
      self.values.append(x)

  def had_phase_transition(self):
    if len(self.differences) < 5: return False
    i_max = flex.max_index(self.differences)
    noise_before = (self.differences
                    < self.noise_level_before*self.differences[i_max])
    before = flex.last_index(noise_before[:i_max], True)
    if before is None: before = -1
    before += 1
    if i_max - before < 4: return False
    negative_after = self.differences < 0
    after = flex.first_index(negative_after[i_max:], True)
    if after is None: return False
    after += i_max
    if after - before < 10: return False
    if len(self.values) - after < 10: return False
    tail_stats = scitbx.math.basic_statistics(self.differences[-5:])
    if (tail_stats.max_absolute
        > self.noise_level_after*self.differences[i_max]): return False
    return True


 *******************************************************************************


 *******************************************************************************
smtbx/ab_initio/development/electron_density_distribution.py
from __future__ import absolute_import, division, print_function
from scitbx.array_family import flex

def find_delta(rho_map, tol):
  """ Find delta as hinted on fig. 1 of ref. [1] in module charge_flipping """
  rho = rho_map.real_map_unpadded().as_1d()
  max_rho = flex.max(rho)
  rho /= max_rho
  sorting = flex.sort_permutation(rho)
  sorted_rho = rho.select(sorting)
  n = len(sorted_rho)
  p,q = n//4, 3*n//4
  indexes = flex.double_range(p,q)
  values = sorted_rho[p:q]
  c = flex.linear_correlation(indexes, values)
  assert c.is_well_defined() and c.coefficient() > 0.99
  r = flex.linear_regression(indexes, values)
  a,b = r.y_intercept(), r.slope()
  deviation = flex.abs(a + b*flex.double_range(n) - sorted_rho)
  non_linear_sel = deviation > tol
  low = flex.first_index(non_linear_sel, False)
  high = flex.last_index(non_linear_sel, False)
  assert non_linear_sel[low:high].count(False)/(high-low+1) > 0.99
  assert sorted_rho[low] < 0 and sorted_rho[high] > 0
  return min(sorted_rho[high], -sorted_rho[low]), max_rho

def write_sorted_moduli_as_mathematica_plot(f, filename):
  """ To obtain fig. 1 in ref [2] in module charge_flipping """
  abs_f = flex.abs(f.data())
  sorted = abs_f.select(flex.sort_permutation(abs_f))
  sorted /= flex.max(sorted)
  mf = open(os.path.expanduser(filename), 'w')
  print('fp1 = {', file=mf)
  for f in sorted:
    print("%f, " % f, file=mf)
  print("1 };", file=mf)
  print("ListPlot[fp1]", file=mf)
  mf.close()


 *******************************************************************************


 *******************************************************************************
smtbx/ab_initio/tests/__init__.py


 *******************************************************************************


 *******************************************************************************
smtbx/ab_initio/tests/tst_ab_initio_ext.py
from __future__ import absolute_import, division, print_function
from cctbx import maptbx
from cctbx.development import random_structure
from cctbx import miller
from cctbx import sgtbx

from scitbx.array_family import flex

from  libtbx.test_utils import approx_equal
from libtbx.utils import format_cpu_times

from smtbx import ab_initio

def run():
  structure = random_structure.xray_structure(
    sgtbx.space_group_info("P21/c"),
    elements=["Si"]*10,
    volume_per_atom=18.6,
    min_distance=1.2,
    general_positions_only=False)
  miller_set_f_obs = miller.build_set(
    crystal_symmetry=structure,
    anomalous_flag=True,
    d_min=0.8)
  f_obs = miller_set_f_obs.structure_factors_from_scatterers(
    xray_structure=structure,
    algorithm="direct").f_calc()
  fft_map = f_obs.fft_map(symmetry_flags=maptbx.use_space_group_symmetry)

  padded = fft_map.real_map()
  unpadded = fft_map.real_map_unpadded() # copy
  unpadded_1d = unpadded.as_1d() # 1D view => in-place
  mmm = flex.min_max_mean_double(unpadded_1d)

  for delta in ((mmm.min + mmm.mean)/2, mmm.mean, (mmm.mean + mmm.max)/2):
    # in-place charge flipping
    ab_initio.ext.flip_charges_in_place(padded, delta)

    # same but on an unpadded copy using the flex tools
    flipped_selection = unpadded_1d < delta
    flipped = unpadded_1d.select(flipped_selection)
    flipped *= -1
    unpadded_1d.set_selected(flipped_selection, flipped)

    assert approx_equal(padded, unpadded, 1e-15)

  print(format_cpu_times())


if __name__ == '__main__':
  run()


 *******************************************************************************


 *******************************************************************************
smtbx/ab_initio/tests/tst_charge_flipping.py
from __future__ import absolute_import, division, print_function

import sys
import random

from cctbx import miller
from cctbx import maptbx
from cctbx.development import random_structure
from cctbx.development import debug_utils
from cctbx.array_family import flex
from cctbx import euclidean_model_matching as emma

from libtbx import group_args

import scitbx.matrix as mat
from six.moves import cStringIO as StringIO

from smtbx.ab_initio import charge_flipping
from six.moves import range

def randomly_exercise(flipping_type,
                      space_group_info, elements,
                      anomalous_flag,
                      d_min, grid_resolution_factor=1./2,
                      verbose=False,
                      amplitude_type="F",
                      ):

  # Generate a random structure in real space, that we will try to recover
  target_structure = random_structure.xray_structure(
    space_group_info=space_group_info,
    elements=elements,
    use_u_iso=True,
    random_u_iso=True,
    random_u_iso_scale=0.04,
    use_u_aniso=False,
  )
  exercise_one_structure(target_structure,
                         flipping_type,
                         anomalous_flag,
                         d_min,
                         grid_resolution_factor=grid_resolution_factor,
                         verbose=verbose,
                         amplitude_type=amplitude_type,
                         )

def exercise_one_structure(target_structure,
                           flipping_type,
                           anomalous_flag,
                           d_min, grid_resolution_factor=1./2,
                           verbose=False,
                           amplitude_type="F",
                           ):
  assert amplitude_type in ('F', 'E', 'quasi-E')

  # Generate its structure factors
  f_target = miller.build_set(
    crystal_symmetry=target_structure,
    anomalous_flag=target_structure.scatterers().count_anomalous() != 0,
    d_min=d_min
    ).structure_factors_from_scatterers(
      xray_structure=target_structure,
      algorithm="direct").f_calc()

  f_target_in_p1 = f_target.expand_to_p1()\
                           .as_non_anomalous_array()\
                           .merge_equivalents().array()
  f_obs = f_target.as_amplitude_array()

  # Unleash charge flipping on the amplitudes
  flipping = flipping_type(delta=None)
  extra = group_args()
  if amplitude_type == 'E':
    extra.normalisations_for = lambda f: f.amplitude_normalisations(
      target_structure.unit_cell_content(omit=('H','D')))
  elif amplitude_type == 'quasi-E':
    extra.normalisations_for = charge_flipping.amplitude_quasi_normalisations
  solving = charge_flipping.solving_iterator(
    flipping,
    f_obs,
    yield_during_delta_guessing=True,
    yield_solving_interval=1,
    **extra.__dict__
  )
  s = StringIO()
  charge_flipping.loop(solving, verbose="highly", out=s)
  if verbose:
    print(s.getvalue())

  # check whether a phase transition has occured
  assert solving.had_phase_transition

  flipping = solving.flipping_iterator
  f_result_in_p1 = solving.flipping_iterator.f_calc

  # Euclidean matching of the peaks from the obtained map
  # against those of the correct structure (in P1)
  target_structure = target_structure.select(
    target_structure.scattering_types() == "H", negate=True)
  target_structure_in_p1 = target_structure.expand_to_p1()
  search_parameters = maptbx.peak_search_parameters(
    interpolate=True,
    min_distance_sym_equiv=1.,
    max_clusters=int(target_structure_in_p1.scatterers().size()*1.2))
  peak_search_outcome = flipping.rho_map.peak_search(search_parameters)
  peak_structure = emma.model(
    target_structure_in_p1.crystal_symmetry().special_position_settings(),
    positions=[ emma.position('Q%i' % i, x)
                for i,x in enumerate(peak_search_outcome.all().sites()) ])
  refined_matches = emma.model_matches(
    target_structure_in_p1.as_emma_model(),
    peak_structure,
    tolerance=0.5,
    break_if_match_with_no_singles=False
    ).refined_matches
  m = refined_matches[0]
  assert m.rms < 0.2, m.rms # no farther than that
  assert m.rt.r in (mat.identity(3), mat.inversion(3))

  reference_shift = -refined_matches[0].rt.t

  # Find the translation to bring back the structure to the same space-group
  # setting as the starting f_obs from correlation map analysis
  is_allowed= lambda x: f_target.space_group_info().is_allowed_origin_shift(
    x, tolerance=0.1)
  first_correct_correlation_peak = None
  for i, (f_calc, shift, cc_peak_height) in enumerate(
                                                    solving.f_calc_solutions):
    if (   is_allowed(shift - reference_shift)
        or is_allowed(shift + reference_shift)):
      first_correct_correlation_peak = i
      break
    else:
      if verbose == "more":
        print("++ Incorrect peak: shift=(%.3f, %.3f, %.3f), height=%.2f"\
              % (tuple(shift)+(cc_peak_height,)))
        print("   Reference shift=(%.3f, %.3f, %.3f)" % tuple(reference_shift))
  assert first_correct_correlation_peak is not None
  if verbose and first_correct_correlation_peak != 0:
      print("** First correct correlation peak: #%i (%.3f) **"\
            % (first_correct_correlation_peak, cc_peak_height))

  # check Euclidean matching in the original space-group
  search_parameters = maptbx.peak_search_parameters(
    interpolate=True,
    min_distance_sym_equiv=1.,
    max_clusters=int(1.5*target_structure.scatterers().size()))
  solution_fft_map = f_calc.fft_map(
    symmetry_flags=maptbx.use_space_group_symmetry)
  solution_peaks = solution_fft_map.peak_search(search_parameters,
                                                verify_symmetry=False)
  solution_peak_structure = emma.model(
    target_structure.crystal_symmetry().special_position_settings(),
    positions=[ emma.position('Q%i' % i, x)
                for i,x in enumerate(solution_peaks.all().sites()) ])
  refined_matches = emma.model_matches(
    target_structure.as_emma_model(),
    solution_peak_structure,
    break_if_match_with_no_singles=False
    ).refined_matches
  assert refined_matches
  m = refined_matches[0]
  assert not m.singles1, m.show() # all sites match a peak
  assert m.rms < 0.15, m.rms  # no farther than that
  assert m.rt.r in (mat.identity(3), mat.inversion(3))

  # success!
  if verbose:
    print("@@ Success @@")

def exercise_sucrose(flipping_type,
                     anomalous_flag,
                     d_min,
                     verbose=False,
                     amplitude_type='quasi-E'):
  from smtbx import development
  target_structure = development.sucrose()

  print("Sucrose")
  exercise_one_structure(target_structure,
                         flipping_type,
                         anomalous_flag,
                         d_min,
                         grid_resolution_factor=1/2,
                         verbose=verbose,
                         amplitude_type=amplitude_type,
                         )

def exercise(flags, space_group_info):
  if not flags.repeats: flags.repeats = 1
  if not flags.algo: flags.algo = "weak_reflection_improved"
  if not flags.on: flags.on = "E"
  if flags.fix_seed:
    random.seed(1)
    flex.set_random_seed(1)

  n = len(space_group_info.group())
  print(space_group_info.type().hall_symbol(), end=' ')
  if not flags.high_symmetry and n > 24:
    print('  [ skipped ]')
    if flags.Verbose: print()
    return
  else:
    print()
  n_C = 12//n or 1
  n_O = 6//n
  n_N = 3//n
  if flags.Verbose:
    print("unit cell content: C%i O%i N%i" % (n_C*n, n_O*n, n_N*n))
    print("asu content: C%i O%i N%i" % (n_C, n_O, n_N))
    print("on %s's with %s" % (flags.on, flags.algo))
  flipping_type = eval("charge_flipping.%s_iterator" % flags.algo)
  for i in range(int(flags.repeats)):
    randomly_exercise(
      flipping_type=flipping_type,
      space_group_info=space_group_info,
      elements=["C"]*n_C + ["O"]*n_O + ["N"]*n_N,
      anomalous_flag=False,
      d_min=0.8,
      verbose=flags.Verbose,
      amplitude_type=flags.on
    )
  if flags.Verbose: print()

def exercise_charge_flipping():
  #exercise_sucrose(flipping_type=charge_flipping.weak_reflection_improved_iterator,
                   #anomalous_flag=False,
                   #d_min=0.7)
  import sys
  debug_utils.parse_options_loop_space_groups(
    sys.argv[1:],
    exercise,
    keywords=("repeats", 'on', 'algo', 'fix_seed', 'high_symmetry'),
    symbols_to_stderr=False,
  )

def run():
  exercise_charge_flipping()

if __name__ == '__main__':
  run()


 *******************************************************************************


 *******************************************************************************
smtbx/absolute_structure/__init__.py
from __future__ import absolute_import, division, print_function

import math
import sys

from cctbx.array_family import flex
from cctbx import sgtbx, xray

from libtbx import adopt_init_args
from libtbx.utils import xfrange
from libtbx.utils\
     import format_float_with_standard_uncertainty as format_float_with_su
from libtbx.utils import Sorry

from scitbx.math import distributions
from scitbx.lstbx import normal_eqns_solving

import smtbx.utils
from smtbx.refinement import constraints
from smtbx.refinement import least_squares
from cctbx.xray import observations


class hooft_analysis(object):
  """
  Determination of absolute structure using Bayesian statistics
  on Bijvoet differences.

  See:
    Hooft, R.W.W., Straver, L.H., Spek, A.L. (2008). J. Appl. Cryst., 41, 96-103.

    Hooft, R.W.W., Straver, L.H., Spek, A.L. (2009). Acta Crystallogr. A65, 319-321.

    Hooft, R.W.W., Straver, L.H., Spek, A.L. (2010). J. Appl. Cryst., 43, 665-668.

  and for more information:
    http://www.absolutestructure.com/bibliography.html

  """

  distribution = "Gaussian"

  def __init__(self, fo2, fc,
               scale_factor=None,
               outlier_cutoff_factor=None,
               probability_plot_slope=None):
    self.probability_plot_slope = probability_plot_slope
    assert fo2.is_xray_intensity_array()
    assert fc.is_complex_array()
    assert not fo2.space_group().is_centric()
    if scale_factor is None:
      scale_factor = fo2.scale_factor(fc)
    fc2 = fc.as_intensity_array()
    self.delta_fc2 = fc2.anomalous_differences()
    self.delta_fo2 = fo2.anomalous_differences()
    self.n_bijvoet_pairs = self.delta_fo2.size()
    if outlier_cutoff_factor is not None:
      cutoff_sel = flex.abs(self.delta_fo2.data()) > (
        outlier_cutoff_factor * scale_factor) * flex.max(
          flex.abs(self.delta_fc2.data()))
      self.delta_fo2 = self.delta_fo2.select(~cutoff_sel)
      self.delta_fc2 = self.delta_fc2.select(~cutoff_sel)
    self.delta_fc2 = self.delta_fc2.customized_copy(
      data=self.delta_fc2.data() * scale_factor)
    if not self.delta_fo2.size():
      raise Sorry("Absolute structure could not be determined")
    min_gamma = -10
    max_gamma = 10

    # quick and dirty to find better min, max gammas
    max_log_p_obs = -1e100
    while True:
      # search for the maximum
      width = max_gamma - min_gamma
      if width < 0.0001:
        break
      middle = (min_gamma + max_gamma)/2
      a = middle - width/4
      b = middle + width/4
      value_a = self.log_p_obs_given_gamma(a)
      value_b = self.log_p_obs_given_gamma(b)
      if value_a > value_b:
        max_gamma = middle
      elif value_a == value_b:
        min_gamma = a
        max_gamma = b
      else:
        min_gamma = middle
      max_log_p_obs = max([max_log_p_obs, value_a, value_b])
    while True:
      # search for where the curve becomes close to zero on the left
      min_gamma = middle - width/2
      if (width > 100 or
          self.log_p_obs_given_gamma(min_gamma) - max_log_p_obs < -10):
        break
      width *= 2
    width = max_gamma - min_gamma
    while True:
      # search for where the curve becomes close to zero on the right
      max_gamma = middle + width/2
      if (width > 100 or
          self.log_p_obs_given_gamma(max_gamma) - max_log_p_obs < -10):
        break
      width *= 2

    n_steps = 500
    d_gamma = (max_gamma - min_gamma)/n_steps
    # now do it properly
    log_p_obs_given_gammas = flex.double()
    for gamma in xfrange(min_gamma, max_gamma, d_gamma):
      log_p_obs_given_gammas.append(self.log_p_obs_given_gamma(gamma))
    max_log_p_obs = flex.max(log_p_obs_given_gammas)
    G_numerator = 0
    G_denominator = 0
    p_u_gammas = flex.double()
    # Numerical integration using trapezoidal rule
    for i, gamma in enumerate(xfrange(min_gamma, max_gamma, d_gamma)):
      p_u_gamma = math.exp(log_p_obs_given_gammas[i] - max_log_p_obs)
      p_u_gammas.append(p_u_gamma)
      if i == 0: continue
      G_numerator += 0.5 * d_gamma * (
        (gamma-d_gamma) * p_u_gammas[-2] + gamma * p_u_gammas[-1])
      G_denominator += 0.5 * (p_u_gammas[-2] + p_u_gammas[-1]) * d_gamma
    self.G = G_numerator/G_denominator
    sigma_squared_G_numerator = 0
    # Numerical integration using trapezoidal rule
    next_ = None
    for i, gamma in enumerate(xfrange(min_gamma, max_gamma, d_gamma)):
      previous = next_
      next_ = math.pow((gamma - self.G), 2) * p_u_gammas[i] * d_gamma
      if i == 0: continue
      sigma_squared_G_numerator += 0.5 * (previous + next_)
    self.hooft_y = (1-self.G)/2
    self.sigma_G = math.sqrt(sigma_squared_G_numerator/G_denominator)
    self.sigma_y = self.sigma_G/2

    # Now calculate P2, P3 values
    log_p_obs_given_gamma_is_minus_1 = self.log_p_obs_given_gamma(-1)
    log_p_obs_given_gamma_is_0 = self.log_p_obs_given_gamma(0)
    log_p_obs_given_gamma_is_1 = self.log_p_obs_given_gamma(1)
    max_log_p_obs = max([log_p_obs_given_gamma_is_minus_1,
                         log_p_obs_given_gamma_is_0,
                         log_p_obs_given_gamma_is_1])
    # all values normalised by max_log_p_obs for numerical stability
    log_p_obs_given_gamma_is_minus_1 -= max_log_p_obs
    log_p_obs_given_gamma_is_0 -= max_log_p_obs
    log_p_obs_given_gamma_is_1 -= max_log_p_obs
    p2_denominator = math.exp(log_p_obs_given_gamma_is_1) \
                   + math.exp(log_p_obs_given_gamma_is_minus_1)
    p3_denominator = math.exp(log_p_obs_given_gamma_is_1) \
                   + math.exp(log_p_obs_given_gamma_is_minus_1) \
                   + math.exp(log_p_obs_given_gamma_is_0)
    #
    if p2_denominator == 0: self.p2_true = self.p2_false = None
    else:
      self.p2_true = (
        math.exp(log_p_obs_given_gamma_is_1)) / p2_denominator
      self.p2_false = (
        math.exp(log_p_obs_given_gamma_is_minus_1)) / p2_denominator
    self.p3_true = (
      math.exp(log_p_obs_given_gamma_is_1)) / p3_denominator
    self.p3_false = (
      math.exp(log_p_obs_given_gamma_is_minus_1)) / p3_denominator
    self.p3_racemic_twin = (
      math.exp(log_p_obs_given_gamma_is_0)) / p3_denominator

  def log_p_obs_given_gamma(self, gamma):
    x_gamma = (gamma * self.delta_fc2.data() - self.delta_fo2.data()) \
            / self.delta_fo2.sigmas()
    if self.probability_plot_slope is not None:
      x_gamma /= self.probability_plot_slope
    return -0.5 * flex.sum_sq(x_gamma)

  def show(self, out=None):

    def format_p(p_value):
      if p_value is None: return "n/a"
      elif p_value >= 1e-2: return "%.3f" %p_value
      else: return "%.3e" %p_value

    if out is None: out=sys.stdout
    print("Bijvoet pair analysis using %s distribution" %self.distribution, file=out)
    print("Bijvoet pairs (all): %i" %self.n_bijvoet_pairs, file=out)
    print("Bijvoet pairs (used): %i" %self.delta_fo2.size(), file=out)
    print("Bijvoet pairs coverage: %.2f" %(
      self.n_bijvoet_pairs/self.delta_fo2.customized_copy(
        anomalous_flag=True).complete_set().n_bijvoet_pairs()), file=out)
    print("G: %s" %format_float_with_su(self.G, self.sigma_G), file=out)
    print("P2(true): %s" %format_p(self.p2_true), file=out)
    print("P2(false): %s" %format_p(self.p2_false), file=out)
    print("P3(true): %s" %format_p(self.p3_true), file=out)
    print("P3(false): %s" %format_p(self.p3_false), file=out)
    print("P3(racemic twin): %s" %format_p(self.p3_racemic_twin), file=out)
    print("Hooft y: %s" %format_float_with_su(
      self.hooft_y, self.sigma_y), file=out)


class bijvoet_differences_probability_plot(object):
  """
  Hooft, R.W.W., Straver, L.H., Spek, A.L. (2010). J. Appl. Cryst., 43, 665-668.
  """

  def __init__(self,
               hooft_analysis,
               use_students_t_distribution=False,
               students_t_nu=None,
               probability_plot_slope=None):
    self.delta_fo2, minus_fo2 =\
        hooft_analysis.delta_fo2.generate_bijvoet_mates().hemispheres_acentrics()
    self.delta_fc2, minus_fc2 =\
        hooft_analysis.delta_fc2.generate_bijvoet_mates().hemispheres_acentrics()
    # we want to plot both hemispheres
    self.delta_fo2.indices().extend(minus_fo2.indices())
    self.delta_fo2.data().extend(minus_fo2.data() * -1)
    self.delta_fo2.sigmas().extend(minus_fo2.sigmas())
    self.delta_fc2.indices().extend(minus_fc2.indices())
    self.delta_fc2.data().extend(minus_fc2.data() * -1)
    self.indices = self.delta_fo2.indices()
    observed_deviations = (hooft_analysis.G * self.delta_fc2.data()
                           - self.delta_fo2.data())/self.delta_fo2.sigmas()

    if probability_plot_slope is not None:
      observed_deviations /= probability_plot_slope
    selection = flex.sort_permutation(observed_deviations)
    observed_deviations = observed_deviations.select(selection)
    if use_students_t_distribution:
      if students_t_nu is None:
        students_t_nu = maximise_students_t_correlation_coefficient(
          observed_deviations, 1, 200)
      self.distribution = distributions.students_t_distribution(students_t_nu)
    else:
      self.distribution = distributions.normal_distribution()
    self.x = self.distribution.quantiles(observed_deviations.size())
    self.y = observed_deviations
    self.fit = flex.linear_regression(self.x[5:-5], self.y[5:-5])
    self.correlation = flex.linear_correlation(self.x[5:-5], self.y[5:-5])
    assert self.fit.is_well_defined()

  def show(self, out=None):
    if out is None: out=sys.stdout
    print("y_intercept: %.3f" %self.fit.y_intercept(), file=out)
    print("slope: %.3f" %self.fit.slope(), file=out)
    print("correlation coefficient: %.4f" %self.correlation.coefficient(), file=out)


def maximise_students_t_correlation_coefficient(observed_deviations,
                                                min_nu, max_nu):
  def compute_corr_coeff(i):
    distribution = distributions.students_t_distribution(i)
    expected_deviations = distribution.quantiles(observed_deviations.size())
    return flex.linear_correlation(
      observed_deviations[5:-5], expected_deviations[5:-5])
  assert max_nu > min_nu
  assert min_nu > 0
  while True:
    width = max_nu - min_nu
    if width < 0.01: break
    middle = (min_nu + max_nu)/2
    a = middle - width/4
    b = middle + width/4
    value_a = compute_corr_coeff(a).coefficient()
    value_b = compute_corr_coeff(b).coefficient()
    if value_a > value_b:
      max_nu = middle
    elif value_a == value_b:
      min_nu = a
      max_nu = b
    else:
      min_nu = middle
  return middle

class students_t_hooft_analysis(hooft_analysis):
  """
  Hooft, R.W.W., Straver, L.H., Spek, A.L. (2010). J. Appl. Cryst., 43, 665-668.
  """

  distribution = "Student's t"

  def __init__(self, fo2, fc,
               degrees_of_freedom,
               scale_factor=None,
               outlier_cutoff_factor=None,
               probability_plot_slope=None):
    self.degrees_of_freedom = degrees_of_freedom
    hooft_analysis.__init__(self, fo2, fc,
                            scale_factor=scale_factor,
                            outlier_cutoff_factor=outlier_cutoff_factor,
                            probability_plot_slope=probability_plot_slope)

  def log_p_obs_given_gamma(self, gamma):
    dof = self.degrees_of_freedom
    x_gamma = (gamma * self.delta_fc2.data() - self.delta_fo2.data()) \
            / self.delta_fo2.sigmas()
    if self.probability_plot_slope is not None:
      x_gamma /= self.probability_plot_slope
    return -(1+dof)/2 * flex.sum(flex.log(flex.pow2(x_gamma) + dof))

class flack_analysis(object):

  def __init__(self, xray_structure, obs_, exti=None, connectivity_table=None):
    if exti is None:
      exti = xray.dummy_extinction_correction()
    adopt_init_args(self, locals())
    assert obs_.fo_sq.anomalous_flag()
    assert not(obs_.twin_fractions and obs_.merohedral_components)

    xray_structure = xray_structure.deep_copy_scatterers()
    for sc in xray_structure.scatterers():
      f = xray.scatterer_flags()
      f.set_use_u_aniso(sc.flags.use_u_aniso())
      f.set_use_u_iso(sc.flags.use_u_iso())
      f.set_use_fp_fdp(True)
      sc.flags = f

    twin_fractions = ()
    it = xray.twin_component(sgtbx.rot_mx((-1,0,0,0,-1,0,0,0,-1)), 0.2, True)
    twin_components = (it,)
    obs = observations.customized_copy(obs_, twin_fractions, twin_components)
    # reparameterisation needs all fractions
    twin_fractions += twin_components
    if connectivity_table is None:
      connectivity_table = smtbx.utils.connectivity_table(xray_structure)
    reparametrisation = constraints.reparametrisation(
      xray_structure, [], connectivity_table,
      twin_fractions=twin_fractions,
      extinction=exti
    )
    normal_eqns = least_squares.crystallographic_ls(obs,
      reparametrisation)
    cycles = normal_eqns_solving.naive_iterations(
      normal_eqns, n_max_iterations=10,
      gradient_threshold=1e-7,
      step_threshold=1e-4)
    self.flack_x = it.value
    self.sigma_x = math.sqrt(normal_eqns.covariance_matrix(
      jacobian_transpose=reparametrisation.jacobian_transpose_matching(
        reparametrisation.mapping_to_grad_fc_independent_scalars))[0])


  def show(self, out=None):
    if out is None: out = sys.stdout
    print("Flack x: %s" %format_float_with_su(self.flack_x, self.sigma_x), file=out)


 *******************************************************************************


 *******************************************************************************
smtbx/absolute_structure/tests/tst_absolute_structure.py
from __future__ import absolute_import, division, print_function

import sys
import random

from cctbx.development import random_structure
from cctbx.development import debug_utils
from cctbx import adptbx
from cctbx.array_family import flex

from iotbx import csv_utils

import libtbx
import libtbx.utils
from libtbx.test_utils import approx_equal

import scitbx.random
from scitbx.random import variate, normal_distribution, gamma_distribution
from scitbx.math import distributions

from smtbx import absolute_structure

try:
  distributions.students_t_distribution(1)
except RuntimeError as e:
  # XXX Student's t distribution is not supported with GCC 3.2 builds
  if str(e).startswith("Implementation not available in this build."):
    students_t_available = False
    print("Skipping exercise_hooft_analysis() with Student's t distribution.")
  else:
    raise RuntimeError(e)
else:
  students_t_available = True

class test_case(object):

  d_min=1
  use_students_t_errors=False
  elements = ("N", "C", "C", "S") * 5

  def __init__(self, space_group_info, **kwds):
    libtbx.adopt_optional_init_args(self, kwds)
    self.space_group_info = space_group_info
    self.structure = random_structure.xray_structure(
      space_group_info,
      elements=self.elements,
      volume_per_atom=20.,
      min_distance=1.5,
      general_positions_only=True,
      use_u_aniso=False,
      u_iso=adptbx.b_as_u(10),
    )
    self.structure.set_inelastic_form_factors(1.54, "sasaki")
    self.scale_factor = 0.05 + 10 * flex.random_double()
    fc = self.structure.structure_factors(
          anomalous_flag=True, d_min=self.d_min, algorithm="direct").f_calc()
    fo = fc.as_amplitude_array()
    fo.set_observation_type_xray_amplitude()
    if self.use_students_t_errors:
      nu = random.uniform(1, 10)
      normal_g = variate(normal_distribution())
      gamma_g = variate(gamma_distribution(0.5*nu, 2))
      errors = normal_g(fc.size())/flex.sqrt(2*gamma_g(fc.size()))
    else:
      # use gaussian errors
      g = variate(normal_distribution())
      errors = g(fc.size())
    fo2 = fo.as_intensity_array()
    self.fo2 = fo2.customized_copy(
      data=(fo2.data()+errors)*self.scale_factor,
      sigmas=flex.double(fc.size(), 1),
    )
    self.fc = fc
    xs_i = self.structure.inverse_hand()
    self.fc_i = xs_i.structure_factors(
      anomalous_flag=True, d_min=self.d_min, algorithm="direct").f_calc()
    fo2_twin = self.fc.customized_copy(
      data=self.fc.data()+self.fc_i.data()).as_intensity_array()
    self.fo2_twin = fo2_twin.customized_copy(
      data=(errors + fo2_twin.data()) * self.scale_factor,
      sigmas=self.fo2.sigmas())

class hooft_analysis_test_case(test_case):

  def exercise(self, debug=False):
    if debug:
      distribution = distributions.normal_distribution()
      observed_deviations = (
        self.fo2.data() - self.scale_factor*self.fc.as_intensity_array().data())
      observed_deviations = observed_deviations.select(
        flex.sort_permutation(observed_deviations))
      expected_deviations = distribution.quantiles(observed_deviations.size())
      csv_utils.writer(
        open('delta_F_npp.csv', 'wb'), (expected_deviations, observed_deviations))
    # first with the correct absolute structure
    gaussian = absolute_structure.hooft_analysis(self.fo2, self.fc)
    analyses = [gaussian]
    NPP = absolute_structure.bijvoet_differences_probability_plot(gaussian)
    if self.use_students_t_errors:
      nu_calc = absolute_structure.maximise_students_t_correlation_coefficient(
        NPP.y, min_nu=1, max_nu=200)
      t_analysis = absolute_structure.students_t_hooft_analysis(
        self.fo2, self.fc, nu_calc, probability_plot_slope=NPP.fit.slope())
      analyses.append(gaussian)
      tPP = absolute_structure.bijvoet_differences_probability_plot(
        t_analysis, use_students_t_distribution=True, students_t_nu=nu_calc)
      if tPP.distribution.degrees_of_freedom() < 100:
        assert tPP.correlation.coefficient() > NPP.correlation.coefficient()
    else:
      assert approx_equal(NPP.correlation.coefficient(), 1, 0.005)
    for analysis in analyses:
      assert approx_equal(analysis.hooft_y, 0, 1e-2)
      assert approx_equal(analysis.p2_true, 1)
      assert approx_equal(analysis.p2_false, 0)
      assert approx_equal(analysis.p3_true, 1)
      assert approx_equal(analysis.p3_false, 0)
      assert approx_equal(analysis.p3_racemic_twin, 0)
    if debug:
      csv_utils.writer(open('npp.csv', 'wb'), (NPP.x,NPP.y))
      if self.use_students_t_errors:
        csv_utils.writer(open('tpp.csv', 'wb'), (tPP.x,tPP.y))
    assert approx_equal(NPP.fit.y_intercept(), 0)
    # and now with the wrong absolute structure
    gaussian = absolute_structure.hooft_analysis(self.fo2, self.fc_i)
    analyses = [gaussian]
    NPP = absolute_structure.bijvoet_differences_probability_plot(gaussian)
    if self.use_students_t_errors:
      nu_calc = absolute_structure.maximise_students_t_correlation_coefficient(
        NPP.y, min_nu=1, max_nu=200)
      t_analysis = absolute_structure.students_t_hooft_analysis(
        self.fo2, self.fc_i, nu_calc, probability_plot_slope=NPP.fit.slope())
      analyses.append(gaussian)
      tPP = absolute_structure.bijvoet_differences_probability_plot(
        t_analysis, use_students_t_distribution=True)
      if tPP.distribution.degrees_of_freedom() < 100:
        assert tPP.correlation.coefficient() > NPP.correlation.coefficient()
    else:
      assert approx_equal(NPP.correlation.coefficient(), 1, 0.002)
      assert approx_equal(NPP.fit.y_intercept(), 0)
    for analysis in analyses:
      assert approx_equal(analysis.hooft_y, 1, 1e-2)
      assert approx_equal(analysis.p2_true, 0)
      assert approx_equal(analysis.p2_false, 1)
      assert approx_equal(analysis.p3_true, 0)
      assert approx_equal(analysis.p3_false, 1)
      assert approx_equal(analysis.p3_racemic_twin, 0)
    # test for the case of a racemic twin
    gaussian = absolute_structure.hooft_analysis(self.fo2_twin, self.fc)
    analyses = [gaussian]
    NPP = absolute_structure.bijvoet_differences_probability_plot(gaussian)
    if self.use_students_t_errors:
      nu_calc = absolute_structure.maximise_students_t_correlation_coefficient(
        NPP.y, min_nu=1, max_nu=200)
      t_analysis = absolute_structure.students_t_hooft_analysis(
        self.fo2_twin, self.fc, nu_calc, probability_plot_slope=NPP.fit.slope())
      tPP = absolute_structure.bijvoet_differences_probability_plot(
        t_analysis, use_students_t_distribution=True)
      if tPP.distribution.degrees_of_freedom() < 100:
        assert tPP.correlation.coefficient() > NPP.correlation.coefficient()
    else:
      assert approx_equal(NPP.correlation.coefficient(), 1, 0.002)
      assert approx_equal(NPP.fit.y_intercept(), 0)
    for analysis in analyses:
      assert approx_equal(analysis.hooft_y, 0.5, 1e-2)
      assert approx_equal(analysis.p3_true, 0)
      assert approx_equal(analysis.p3_false, 0)
      assert approx_equal(analysis.p3_racemic_twin, 1)


def run_call_back(flags, space_group_info):
  if not space_group_info.group().is_centric():
    if flags.fix_random_seeds:
      random.seed(1)
      flex.set_random_seed(1)
      scitbx.random.set_random_seed(1)
    hooft_analysis_test_case(
      space_group_info,use_students_t_errors=False).exercise(debug=flags.Debug)
    if students_t_available:
      hooft_analysis_test_case(
        space_group_info,use_students_t_errors=True).exercise(debug=flags.Debug)

def run():
  debug_utils.parse_options_loop_space_groups(
    sys.argv[1:],
    run_call_back,
    keywords=("fix_random_seeds",),
  )

if __name__ == '__main__':
  libtbx.utils.show_times_at_exit()
  run()


 *******************************************************************************


 *******************************************************************************
smtbx/array_family/__init__.py
from __future__ import absolute_import, division, print_function
import boost_adaptbx.boost.python as bp
ext = bp.import_ext("smtbx_array_family_ext")
from smtbx_array_family_ext import *


 *******************************************************************************


 *******************************************************************************
smtbx/command_line/__init__.py


 *******************************************************************************


 *******************************************************************************
smtbx/command_line/absolute_structure.py
from __future__ import absolute_import, division, print_function
# LIBTBX_SET_DISPATCHER_NAME smtbx.absolute_structure

from cctbx.array_family import flex
import iotbx.builders
import iotbx.cif
import iotbx.cif.builders
from iotbx import shelx
from iotbx.shelx import hklf
from iotbx.option_parser import option_parser

from scitbx.math import distributions
from smtbx import absolute_structure

import glob, os, sys

def crawl(directory, ext='cif', log=None, atomic_form_factors=None,
          inelastic_form_factors="henke", chiral_space_groups_only=False,
          outlier_cutoff_factor=2):
  assert ext in ('res', 'ins', 'fcf', 'hkl', 'cif')
  for root, dirs, files in os.walk(directory):
    if '.olex' in root: continue # ignore Olex2 strdir subdirectories
    g = glob.glob(os.path.join(root, "*.%s" %ext))
    for path in g:
      try:
        run_once(path, log=log, atomic_form_factors=atomic_form_factors,
                 inelastic_form_factors=inelastic_form_factors,
                 chiral_space_groups_only=chiral_space_groups_only,
                 outlier_cutoff_factor=outlier_cutoff_factor)
      except Exception as e:
        continue

def run_once(file_path, nu=None, log=None, atomic_form_factors=None,
             inelastic_form_factors="henke", chiral_space_groups_only=False,
             outlier_cutoff_factor=2):
  if log is None:
    log = sys.stdout
  file_root, file_ext = os.path.splitext(file_path)
  hkl_path = file_root + '.hkl'
  fcf_path = file_root + '.fcf'
  if file_ext in ('.fcf', '.hkl'):
    xs, fo2, fc, scale = structure_factors_from_fcf(file_path)
  elif file_ext == '.cif':
    cif = iotbx.cif.reader(file_path=file_path).model()
    cif_block = cif.values()[0]
    wavelength = float(cif_block['_diffrn_radiation_wavelength'])
    xs = iotbx.cif.builders.crystal_structure_builder(cif_block).structure
    xs.set_inelastic_form_factors(
      photon=wavelength, table=inelastic_form_factors)
    if os.path.exists(fcf_path):
      xs, fo2, fc, scale = structure_factors_from_fcf(fcf_path, xs)
    elif os.path.exists(hkl_path):
      try:
        xs, fo2, fc, scale = structure_factors_from_hkl(hkl_path, xs)
      except RuntimeError:
        xs, fo2, fc, scale = structure_factors_from_fcf(hkl_path, xs)
    else: return
  else:
    if not os.path.exists(hkl_path): return
    xs, fo2, fc, scale = structure_factors_from_ins_res(file_path)
  if fc.space_group().is_centric() or (chiral_space_groups_only and
                                       not fc.space_group().is_chiral()):
    return
  print(file_path, file=log)
  fc.space_group_info().show_summary(f=log)
  print("space_group.is_chiral(): " + str(fc.space_group().is_chiral()), file=log)
  absolute_structure_analysis(xs, fo2, fc, scale, nu=nu, log=log,
                              outlier_cutoff_factor=outlier_cutoff_factor)
  log.flush()

def structure_factors_from_fcf(file_path, xs=None):
  cif = iotbx.cif.reader(file_path=file_path).model()
  cif_block = cif.values()[0]
  if '_shelx_refln_list_code' in cif_block:
    assert cif_block['_shelx_refln_list_code'] == '4'
  arrays = iotbx.cif.builders.miller_array_builder(cif_block).arrays()
  fo2 = arrays['_refln_F_squared_meas']
  fc2 = arrays['_refln_F_squared_calc']
  if xs is None:
    fc = fc2.f_sq_as_f().phase_transfer(flex.double(fc2.size(), 0))
    scale = 1
  else:
    fc = fo2.structure_factors_from_scatterers(xs, algorithm="direct").f_calc()
    scale = fo2.scale_factor(fc)
  return xs, fo2, fc, scale

def structure_factors_from_hkl(hkl_path, xs, weighting_scheme=None):
  fo2 = hklf.reader(file_name=hkl_path).as_miller_arrays(
    crystal_symmetry=xs)[0]
  fo2.set_observation_type_xray_intensity()
  merging = fo2.merge_equivalents(algorithm="shelx")
  fo2 = merging.array()
  xs.scattering_type_registry(table="it1992", d_min=fo2.d_min())
  fc = fo2.structure_factors_from_scatterers(xs, algorithm="direct").f_calc()
  scale = fo2.scale_factor(fc)
  if weighting_scheme is not None:
    weights = weighting_scheme(
      fo2.data(), fo2.sigmas(), fc.as_intensity_array().data(), scale)
    scale = fo2.scale_factor(fc, weights=weights)
  return xs, fo2, fc, scale

def structure_factors_from_ins_res(file_path):
  from iotbx.builders \
       import weighted_constrained_restrained_crystal_structure_builder
  hkl_path = os.path.splitext(file_path)[0] + ".hkl"
  if not os.path.exists(hkl_path): return [None]*3
  builder = iotbx.builders.mixin_builder_class(
    "builder",
    iotbx.builders.twinning_builder,
    iotbx.builders.reflection_data_source_builder,
    iotbx.builders.weighted_constrained_restrained_crystal_structure_builder)()
  stream = iotbx.shelx.command_stream(filename=file_path)
  stream = iotbx.shelx.instruction_parser(stream, builder)
  stream = iotbx.shelx.crystal_symmetry_parser(stream.filtered_commands(),
                                               builder)
  stream = iotbx.shelx.wavelength_parser(stream.filtered_commands(), builder)
  stream = iotbx.shelx.afix_parser(stream.filtered_commands(), builder)
  stream = iotbx.shelx.atom_parser(stream.filtered_commands(), builder,
                                   strictly_shelxl=False)
  stream = iotbx.shelx.restraint_parser(stream.filtered_commands(), builder)
  stream.parse()
  xs = builder.structure
  twin_components = builder.twin_components
  if twin_components and not xs.space_group().is_centric():
    print(file_path)
    print('twin: ', twin_components[0].twin_law.as_hkl())

  xs.set_inelastic_form_factors(
    photon=builder.wavelength_in_angstrom, table="sasaki")
  return structure_factors_from_hkl(
    hkl_path, xs, weighting_scheme=builder.weighting_scheme)

def absolute_structure_analysis(xs, fo2, fc, scale, nu=None, log=None,
                                outlier_cutoff_factor=None):
  if log is None:
    log = sys.stdout
  hooft_analysis = absolute_structure.hooft_analysis(
    fo2, fc, scale_factor=scale, outlier_cutoff_factor=outlier_cutoff_factor)
  print("Gaussian analysis:", file=log)
  hooft_analysis.show(out=log)
  NPP = absolute_structure.bijvoet_differences_probability_plot(
    hooft_analysis)
  print("Probability plot:", file=log)
  NPP.show(out=log)
  print(file=log)
  if nu is None:
    nu = absolute_structure.maximise_students_t_correlation_coefficient(
      NPP.y, min_nu=1, max_nu=200)
  distribution = distributions.students_t_distribution(nu)
  observed_deviations = NPP.y
  expected_deviations = distribution.quantiles(observed_deviations.size())
  fit = flex.linear_regression(
    expected_deviations[5:-5], observed_deviations[5:-5])
  t_analysis = absolute_structure.students_t_hooft_analysis(
    fo2, fc, nu, scale_factor=scale, probability_plot_slope=fit.slope(),
    outlier_cutoff_factor=outlier_cutoff_factor)
  tPP = absolute_structure.bijvoet_differences_probability_plot(
    t_analysis, use_students_t_distribution=True, students_t_nu=nu)
  print("Student's t analysis:", file=log)
  print("nu: %.2f" %nu, file=log)
  t_analysis.show(out=log)
  print("Probability plot:", file=log)
  tPP.show(out=log)
  print(file=log)
  if xs is not None:
    flack = absolute_structure.flack_analysis(xs, fo2.as_xray_observations())
    flack.show(out=log)

def run(args):
  command_line = (option_parser(
    usage="smtbx.absolute_structure directory|cif|fcf|hkl|ins/res [options]")
                  .enable_symmetry_comprehensive()
                  .option(None, "--ext",
                          action="store",
                          default="cif")
                  .option(None, "--nu",
                          action="store",
                          type="float")
                  .option(None, "--atomic_form_factors",
                          action="store",
                          default="it1992")
                  .option(None, "--inelastic_form_factors",
                          action="store",
                          default="henke")
                  .option(None, "--debug",
                          action="store_true")
                  .option(None, "--verbose",
                          action="store_true")
                  .option(None, "--log",
                          action="store")
                  .option(None, "--chiral_space_groups_only",
                          action="store_true")
                  .option(None, "--outlier_cutoff_factor",
                          action="store",
                          type="float")
                  ).process(args=args)
  if len(command_line.args) != 1:
    command_line.parser.show_help()
    return
  if command_line.options.log is not None:
    log = open(command_line.options.log, 'wb')
  else:
    log = None
  if os.path.isdir(command_line.args[0]):
    crawl(command_line.args[0], ext=command_line.options.ext, log=log,
          atomic_form_factors=command_line.options.atomic_form_factors,
          inelastic_form_factors=command_line.options.inelastic_form_factors,
          chiral_space_groups_only=command_line.options.chiral_space_groups_only,
          outlier_cutoff_factor=command_line.options.outlier_cutoff_factor)
  elif os.path.isfile(command_line.args[0]):
    run_once(command_line.args[0], nu=command_line.options.nu, log=log,
             atomic_form_factors=command_line.options.atomic_form_factors,
             inelastic_form_factors=command_line.options.inelastic_form_factors,
             outlier_cutoff_factor=command_line.options.outlier_cutoff_factor)
  else:
    print("Please provide a valid file or directory")


if __name__ == '__main__':
  run(sys.argv[1:])


 *******************************************************************************


 *******************************************************************************
smtbx/command_line/anom_refine.py
from __future__ import absolute_import, division, print_function
# LIBTBX_SET_DISPATCHER_NAME smtbx.anom_refine

import os, sys, argparse
from scitbx import lstbx
import scitbx.lstbx.normal_eqns_solving
from smtbx import refinement
from timeit import default_timer as current_time
from math import sqrt


allowed_input_file_extensions = ('.ins', '.res', '.cif')

class command_line_error(RuntimeError): pass

class number_of_arguments_error(command_line_error): pass

class energy_missing_error(RuntimeError): pass

def make_parser():
  parser = argparse.ArgumentParser(
      description='''Refinement of inelastic scattering factors. Contact: Daniel
Paley (dwp2111@columbia.edu)''')
  parser.add_argument(
      'ref_structure',
      type=str,
      help='''A structure in .cif or .ins format determined far from any
absorption edge. Coordinates, displacements, and occupancies will be fixed
at their values in this file.'''
      )
  parser.add_argument(
      'reflections',
      type=str,
      help='''A .hkl file containing intensities (ShelX HKLF 4 format).'''
      )
  parser.add_argument(
      'anom_atom',
      type=str,
      help='''The atom type for which f' and f" will be refined. All atoms of
this type will be refined independently.'''
      )
  group = parser.add_mutually_exclusive_group()
  group.add_argument(
    '-e', '--energy',
    type=float,
    default=None,
    help='''Beam energy in eV.'''
    )
  group.add_argument(
    '-E', '--energy-in-fname',
    type=str,
    default=None,
    help='''First digit and length of energy if given in hkl filename. Format
start,length.'''
    )
  parser.add_argument(
    '-t', '--table',
    action='store_true',
    help='Output in condensed format suitable for further processing')
  parser.add_argument(
    '-T', '--table-with-su',
    action='store_true',
    help='Output in condensed format with SUs under the values')
  parser.add_argument(
    '-c', '--max-cycles',
    type=int,
    default=100,
    help='Stop refinement as soon as the given number of cycles have been '
         'performed')
  parser.add_argument(
    '-o', '--outfile',
    type=str,
    default=None,
    help='Write output to filename OUTFILE (default: print to stdout)')
  parser.add_argument(
    '-O', '--overwrite',
    action='store_true',
    help='No error if OUTFILE exists')
  parser.add_argument(
    '-d', '--stop-deriv',
    type=float,
    default=1e-7,
    help='Stop refinement as soon as the largest absolute value of objective '
         'derivatives is below the given threshold.')
  parser.add_argument(
    '-s', '--stop-shift',
    type=float,
    default=1e-7,
    help='Stop refinement as soon as the Euclidean norm of the vector '
         'of parameter shifts is below the given threshold.')
  parser.add_argument(
    '-A', '--adp_global',
    action='store_true',
    help='Refine a global ADP scaling parameter (an extremely simple model for'
         'beam damage)')
  return parser

def run(args):

  # adjust file names
  in_root, in_ext = os.path.splitext(args.ref_structure)

  # Check that input files exist
  for filename in (args.ref_structure, args.reflections):
    if not os.path.isfile(filename):
      raise command_line_error("No such file %s" % filename)

  # Check output file
  if args.outfile and os.path.isfile(args.outfile) and not args.overwrite:
    raise command_line_error("Output file {} exists.".format(args.outfile))

  # Load input model and reflections
  if in_ext == '.cif':
    xm = refinement.model.from_cif(model=args.ref_structure,
                                   reflections=args.reflections + '=hklf4')
  else:
    xm = refinement.model.from_shelx(ins_or_res=args.ref_structure,
                                     hkl=args.reflections,
                                     strictly_shelxl=False)

  # Look for beam energy
  if args.energy:
    energy = args.energy
    wvl = 12398 / energy
  elif args.energy_in_fname:
    estart,elength = args.energy_in_fname.split(',')
    estart = int(estart)
    elength = int(elength)
    energy = float(args.reflections[estart:estart+elength])
    wvl = 12398 / energy
  else:
    energy = None
    sys.stderr.write('''WARNING: Using beam energy from reference model. \
Inelastic form factors for \n non-refined atoms may be inaccurate.\n''')
    wvl = xm.wavelength




  # Load default anomalous scattering factors if wavelength is available
  if wvl:
    xm.xray_structure.set_inelastic_form_factors(wvl, 'sasaki')
  else:
    raise energy_missing_error()

  # At last...
  anom_sc_list=[]
  for i, sc in enumerate(xm.xray_structure.scatterers()):
    sc.flags.set_grad_site(False)
    sc.flags.set_grad_u_iso(False)
    sc.flags.set_grad_u_aniso(False)
    sc.flags.set_grad_occupancy(False)
    if sc.element_symbol().lower() == args.anom_atom.lower():
      sc.flags.set_use_fp_fdp(True)
      sc.flags.set_grad_fp(True)
      sc.flags.set_grad_fdp(True)
      anom_sc_list.append((i, sc))

  if args.adp_global:
    from smtbx.refinement.constraints.adp import scalar_scaled_u
    for sc in xm.xray_structure.scatterers():
      if sc.flags.use_u_aniso():
        sc.flags.set_grad_u_aniso(True)
      else:
        sc.flags.set_grad_u_iso(True)
    adp_scale = scalar_scaled_u(range(len(xm.xray_structure.scatterers())))
    xm.constraints.append(adp_scale)


  ls = xm.least_squares()
  steps = lstbx.normal_eqns_solving.levenberg_marquardt_iterations(
    non_linear_ls=ls,
    n_max_iterations=args.max_cycles,
    gradient_threshold=args.stop_deriv,
    step_threshold=args.stop_shift)
  cov_an = ls.covariance_matrix_and_annotations()

  # Prepare output
  result = ''

  if args.table or args.table_with_su:
    if energy: label = "{:.1f} ".format(energy)
    else: label = "{} ".format(args.reflections)
    result += label
    for i, sc in anom_sc_list:
      result += "{:6.3f} ".format(sc.fp)
    for i, sc in anom_sc_list:
      result += "{:6.3f} ".format(sc.fdp)
    result += '\n'

  if args.table_with_su:
    result += ' ' * len(label)
    for i, sc in anom_sc_list:
      label_fp = '{}.fp'.format(sc.label)
      sigma_fp = sqrt(cov_an.variance_of(label_fp))
      result += "{:6.3f} ".format(sigma_fp)
    for i, sc in anom_sc_list:
      label_fdp = '{}.fdp'.format(sc.label)
      sigma_fdp = sqrt(cov_an.variance_of(label_fdp))
      result += "{:6.3f} ".format(sigma_fdp)
    result += '\n'

  if not (args.table or args.table_with_su):
    from libtbx.utils import format_float_with_standard_uncertainty \
        as format_float_with_su
    result += "\n### REFINE ANOMALOUS SCATTERING FACTORS ###\n"
    result += "Reflections: {}\n\n".format(args.reflections)

    if args.adp_global:
      sigma_adp_global = adp_scale.esd(ls)
      result += "ADP scale: {}\n\n".format(
          format_float_with_su(adp_scale.scalar.value, sigma_adp_global))

    for i, sc in anom_sc_list:
      label_fp = '{}.fp'.format(sc.label)
      label_fdp = '{}.fdp'.format(sc.label)
      sigma_fp = sqrt(cov_an.variance_of(label_fp))
      sigma_fdp = sqrt(cov_an.variance_of(label_fdp))
      result += "{}:\n\tfp: {}\n\tfdp: {}\n".format(
          sc.label,
          format_float_with_su(sc.fp, sigma_fp),
          format_float_with_su(sc.fdp, sigma_fdp))

  # Write to file or stdout
  if args.outfile:
    with open(args.outfile, 'w') as f:
      f.write(result)
  else:
    print(result)



if __name__ == '__main__':
  from timeit import default_timer as current_time
  t0 = current_time()
  parser = make_parser()
  args = parser.parse_args()
  try:
    run(args)
  except number_of_arguments_error:
    parser.print_usage()
    sys.exit(1)
  except command_line_error as err:
    print("\nERROR: %s\n" % err, file=sys.stderr)
    parser.print_help()
    sys.exit(1)
  except energy_missing_error as err:
    print('Must provide beam energy on the command line or in the reference '
        'structure.')
    sys.exit(1)
  t1 = current_time()
  if not (args.table or args.table_with_su):
    print("Total time: %.3f s" % (t1 - t0))


 *******************************************************************************


 *******************************************************************************
smtbx/command_line/benchmark_refinement.py
from __future__ import absolute_import, division, print_function
import itertools
from smtbx.development import random_xray_structure
import smtbx.utils
from smtbx.refinement import constraints, least_squares
from scitbx.array_family import flex
import timeit
import pprint
from six.moves import range

def run(sizes, d_mins):
  timing = {
    'Serial': {
      'BLAS 2': [],
      'BLAS 3': []
    },
    'Parallel': {
      'BLAS 2': [],
      'BLAS 3': []
    },
  }
  print("%16s%11s%7s%9s%8s" % ('Algorithms', 'resolution', '#atoms',
                               'building', 'solving'))
  for observations, model in test_structures(sizes, d_mins):
    for blas in ('BLAS 2', 'BLAS 3'):
      for may_parallelise in (False, True):
        concurrency = ('Serial', 'Parallel')[may_parallelise]
        result = benchmark(observations, model, may_parallelise, blas)
        print("%9s%7s%11.2f%7i%9.3f%8.3f" % ((concurrency, blas) + result))
        timing[concurrency][blas].append(result)
  with open('smtbx_refinement.m', 'w') as f:
    pprint.pprint(timing, stream=f)

non_linear_ls_engine = {
  'BLAS 2':
  least_squares.normal_eqns.non_linear_ls_with_separable_scale_factor_BLAS_2,
  'BLAS 3':
  least_squares.normal_eqns.non_linear_ls_with_separable_scale_factor_BLAS_3,
}
def benchmark(observations, model, may_parallelise, blas):
  time = timeit.default_timer
  ls = least_squares.crystallographic_ls(
    observations, model, non_linear_ls_engine[blas], may_parallelise,
    weighting_scheme=least_squares.mainstream_shelx_weighting(a=0))
  m = ls.observations.fo_sq.size()
  n = ls.reparametrisation.n_independents
  # let's do worth of 5 Gflops at least
  n_trials = max(int(5e9/(0.5*m*n**2)), 1)
  building = 0
  solving = 0
  for i in range(n_trials):
    t0 = time()
    ls.build_up()
    t1 = time()
    rls = ls.reduced_problem()
    neqns = rls.step_equations()
    neqns.solve()
    t2 = time()
    building += t1 - t0
    solving += t2 - t1
  return (ls.observations.fo_sq.d_min(), len(ls.xray_structure.scatterers()),
         building/n_trials, solving/n_trials)

def test_structures(sizes, d_mins):
  for na in sizes:
    xs = random_xray_structure(
      space_group_symbol='hall: -P 2ybc',
      n_scatterers=na,
      proportion_of_elements={'C':5, 'O':2, 'N':1},
      use_u_iso=False,
      use_u_aniso=True,
    )
    for d_min in d_mins:
      mi = xs.build_miller_set(anomalous_flag=False, d_min=d_min)
      ma = mi.structure_factors_from_scatterers(xs, algorithm='direct').f_calc()
      fo_sq = ma.norm().customized_copy(sigmas=flex.double(ma.size(), 1.))
      xs.shake_sites_in_place(rms_difference=0.1)
      xs.shake_adp()
      for sc in xs.scatterers():
        sc.flags.set_use_u_iso(False).set_use_u_aniso(True)
        sc.flags.set_grad_site(True).set_grad_u_aniso(True)
      connectivity_table = smtbx.utils.connectivity_table(xs)
      reparametrisation = constraints.reparametrisation(
        structure=xs,
        constraints=[],
        connectivity_table=connectivity_table)
      yield (fo_sq.as_xray_observations(), reparametrisation)

if __name__ == '__main__':
  import argparse
  def arange(s, atype):
    parsed = tuple(atype(x) for x in s.split(':'))
    start, stop = parsed[:2] if len(parsed) >= 2 else parsed*2
    step = parsed[2] if len(parsed) == 3 else 1
    if atype == int:
      for i in range(start, stop, step):
        yield i
      yield stop
    elif atype == float:
      i = start
      yield i
      i += step
      while i < stop:
        yield i
        i += step
      yield stop
  def sizerange(s):
    for i in arange(s, int):
      yield i
  def floatrange(s):
    for i in  arange(s, float):
      yield i
  p = argparse.ArgumentParser(description='Benchmark smtbx refinement')
  p.add_argument('--atoms', metavar='FIRST:LAST:STEP',
                 type=sizerange, action='append',
                 help='A range of number of atoms in the ASU (Python style)')
  p.add_argument('--dmin', metavar='FIRST:LAST:STEP',
                 type=floatrange, action='append',
                 help='A range of d_min')
  cmd = p.parse_args()
  sizes, d_mins = (
    sorted(set(itertools.chain.from_iterable(opt)))
    for opt in (cmd.atoms, cmd.dmin))
  run(sizes, d_mins)


 *******************************************************************************


 *******************************************************************************
smtbx/command_line/masks.py
# LIBTBX_SET_DISPATCHER_NAME smtbx.masks

from __future__ import absolute_import, division, print_function

from cctbx import miller, sgtbx, uctbx, xray
from iotbx import reflection_file_utils, reflection_file_reader
from iotbx import shelx
from smtbx import masks
from libtbx.utils import time_log
from iotbx.option_parser import option_parser

from six.moves import cStringIO as StringIO
import os
from six.moves import range

def exercise_masks(xs, fo_sq,
                   solvent_radius,
                   shrink_truncation_radius,
                   resolution_factor=None,
                   grid_step=None,
                   resolution_cutoff=None,
                   atom_radii_table=None,
                   use_space_group_symmetry=False,
                   debug=False,
                   verbose=False):
  assert resolution_factor is None or grid_step is None
  xs_ref = xs.deep_copy_scatterers()
  time_total = time_log("masks total").start()
  fo_sq = fo_sq.customized_copy(anomalous_flag=True)
  fo_sq = fo_sq.eliminate_sys_absent()
  merging = fo_sq.merge_equivalents()
  fo_sq_merged = merging.array()
  if resolution_cutoff is not None:
    fo_sq_merged = fo_sq_merged.resolution_filter(d_min=resolution_cutoff)
  if verbose:
    print("Merging summary:")
    print("R-int, R-sigma: %.4f, %.4f" %(merging.r_int(), merging.r_sigma()))
    merging.show_summary()
    print()
    fo_sq_merged.show_comprehensive_summary()
    print()
  mask = masks.mask(xs, fo_sq_merged)
  time_compute_mask = time_log("compute mask").start()
  mask.compute(solvent_radius=solvent_radius,
               shrink_truncation_radius=shrink_truncation_radius,
               resolution_factor=resolution_factor,
               grid_step=grid_step,
               atom_radii_table=atom_radii_table,
               use_space_group_symmetry=use_space_group_symmetry)
  time_compute_mask.stop()
  time_structure_factors = time_log("structure factors").start()
  f_mask = mask.structure_factors()
  time_structure_factors.stop()
  mask.show_summary()
  f_model = mask.f_model()
  # write modified intensities as shelxl hkl
  out = StringIO()
  modified_fo_sq = mask.modified_intensities()
  modified_fo_sq.export_as_shelx_hklf(out)
  out_file = open('modified.hkl', 'w')
  out_file.write(out.getvalue())
  out_file.close()

  if verbose:
    print()
    print(time_log.legend)
    print(time_compute_mask.report())
    print(time_structure_factors.report())
    print(time_total.log())

  if debug:
    f_obs = fo_sq_merged.as_amplitude_array()
    sf = xray.structure_factors.from_scatterers(
      miller_set=f_obs,
      cos_sin_table=True)
    f_calc = sf(xs, f_obs).f_calc()
    f_model = mask.f_model()
    scale_factor = f_obs.scale_factor(f_model)
    # f_obs - f_calc
    k = f_obs.scale_factor(f_calc)
    f_obs_minus_f_calc = f_obs.f_obs_minus_f_calc(1/k, f_calc)
    diff_map_calc = miller.fft_map(mask.crystal_gridding, f_obs_minus_f_calc)
    diff_map_calc.apply_volume_scaling()
    # f_mask
    mask_map = miller.fft_map(mask.crystal_gridding, f_mask)
    mask_map.apply_volume_scaling()
    # f_model
    model_map = miller.fft_map(mask.crystal_gridding, f_model)
    model_map.apply_volume_scaling()
    # f_obs - f_model
    f_obs_minus_f_model = f_obs.f_obs_minus_f_calc(1/scale_factor, f_model)
    diff_map_model = miller.fft_map(mask.crystal_gridding, f_obs_minus_f_model)
    diff_map_model.apply_volume_scaling()
    # modified f_obs
    modified_fo_sq_map = miller.fft_map(
      mask.crystal_gridding, modified_fo_sq.as_amplitude_array().phase_transfer(f_calc))
    modified_fo_sq_map.apply_volume_scaling()
    # view the maps
    from crys3d import wx_map_viewer
    wx_map_viewer.display(
      title="Mask",
      raw_map=mask.mask.data.as_double(),
      unit_cell=f_obs.unit_cell())
    wx_map_viewer.display(
      title="f_obs - f_calc",
      raw_map=diff_map_calc.real_map(),
      unit_cell=f_obs.unit_cell())
    wx_map_viewer.display(
      title="f_mask",
      raw_map=mask_map.real_map(),
      unit_cell=f_obs.unit_cell())
    wx_map_viewer.display(
      title="f_model",
      raw_map=model_map.real_map(),
      unit_cell=f_obs.unit_cell())
    wx_map_viewer.display(
      title="f_obs - f_model",
      raw_map=diff_map_model.real_map(),
      unit_cell=f_obs.unit_cell())
    wx_map_viewer.display(
      title="modified_fo_sq",
      raw_map=modified_fo_sq_map.real_map(),
      unit_cell=f_obs.unit_cell())
  return mask

def run(args):
  def vdw_radii_callback(option, opt_str, value, parser):
    # create a dict from space separated string of element types and radii
    radii = {}
    items = value.split()
    assert len(items) % 2 == 0
    for i in range(int(len(items) / 2)):
      radii.setdefault(items[i*2], float(items[i*2+1]))
    setattr(parser.values, option.dest, radii)
  command_line = (option_parser(
    usage="smtbx.masks structure reflections [options]")
                  .enable_symmetry_comprehensive()
                  .option(None, "--solvent_radius",
                          action="store",
                          type="float",
                          default=1.3)
                  .option(None, "--shrink_truncation_radius",
                          action="store",
                          type="float",
                          default=1.3)
                  .option(None, "--debug",
                          action="store_true")
                  .option(None, "--verbose",
                          action="store_true")
                  .option(None, "--resolution_factor",
                          action="store",
                          type="float",
                          default=1/4)
                  .option(None, "--grid_step",
                          action="store",
                          type="float")
                  .option(None, "--d_min",
                          action="store",
                          type="float")
                  .option(None, "--two_theta_max",
                          action="store",
                          type="float")
                  .option(None, "--cb_op",
                          action="store",
                          type="string")
                  .option(None, "--vdw_radii",
                          action="callback",
                          callback=vdw_radii_callback,
                          type="string",
                          nargs=1)
                  .option(None, "--use_space_group_symmetry",
                          action="store_true")).process(args=args)
  structure_file = command_line.args[0]
  ext = os.path.splitext(structure_file)[-1].lower()
  if ext in ('.res', '.ins'):
    xs = xray.structure.from_shelx(filename=structure_file)
  elif ext == '.cif':
    xs = xray.structure.from_cif(filename=structure_file)
  else:
    print("%s: unsupported structure file format {shelx|cif}" %ext)
    return
  reflections_server = reflection_file_utils.reflection_file_server(
    crystal_symmetry = xs.crystal_symmetry(),
    reflection_files = [
      reflection_file_reader.any_reflection_file(command_line.args[1])
    ]
  )
  fo_sq = reflections_server.get_miller_arrays(None)[0]

  if command_line.options.cb_op is not None:
    cb_op = sgtbx.change_of_basis_op(sgtbx.rt_mx(command_line.options.cb_op))
    fo_sq = fo_sq.change_basis(cb_op).customized_copy(
      crystal_symmetry=xs)

  print("structure file: %s" %command_line.args[0])
  print("reflection file: %s" %command_line.args[1])
  if command_line.options.debug:
    print("debug: %s" %command_line.options.debug)
  print()

  xs.show_summary()
  print()

  d_min = command_line.options.d_min
  two_theta_max = command_line.options.two_theta_max
  assert [d_min, two_theta_max].count(None) > 0
  if two_theta_max is not None:
    d_min = uctbx.two_theta_as_d(two_theta_max, wavelength=0.71073, deg=True)
  exercise_masks(
    xs, fo_sq,
    solvent_radius=command_line.options.solvent_radius,
    shrink_truncation_radius=command_line.options.shrink_truncation_radius,
    resolution_factor=command_line.options.resolution_factor,
    grid_step=command_line.options.grid_step,
    resolution_cutoff=d_min,
    atom_radii_table=command_line.options.vdw_radii,
    use_space_group_symmetry=command_line.options.use_space_group_symmetry,
    debug=command_line.options.debug,
    verbose=command_line.options.verbose)
  print("OK")

if __name__ == '__main__':
  import sys
  run(sys.argv[1:])


 *******************************************************************************


 *******************************************************************************
smtbx/command_line/refine.py
from __future__ import absolute_import, division, print_function
# LIBTBX_SET_DISPATCHER_NAME smtbx.refine

import os
from scitbx import lstbx
import scitbx.lstbx.normal_eqns_solving
from smtbx import refinement
from timeit import default_timer as current_time


allowed_input_file_extensions = ('.ins', '.res', '.cif')

class command_line_error(RuntimeError): pass

class number_of_arguments_error(command_line_error): pass

def run(filenames, options):
  #interpret file names
  if not 1 <= len(filenames) <= 3:
    raise number_of_arguments_error()
  input_filename = filenames[0]
  output_filename = None
  reflections_filename = None
  if len(filenames) == 3:
    reflections_filename, output_filename = filenames[1:]
  elif len(filenames) == 2:
    _, ext = os.path.splitext(filenames[1])
    if ext in allowed_input_file_extensions:
      output_filename = filenames[1]
    else:
      reflections_filename = filenames[1]

  # adjust file names
  in_root, in_ext = os.path.splitext(input_filename)
  if not in_ext: in_ext = '.ins'
  if reflections_filename is None:
    reflections_filename = in_root + '.hkl'
  if output_filename is None:
    if in_ext == '.ins':
      out_root, out_ext = in_root, '.res'
    else:
      out_root, out_ext = in_root + '-out', in_ext
    output_filename = out_root + out_ext
  else:
    out_root, out_ext = os.path.splitext(output_filename)

  # ...and handle the hkl format specifiers requested by
  # iotbx.reflection_file_reader
  if "=amplitudes" in reflections_filename:
    reflections_realfilename = \
        reflections_filename[:reflections_filename.find("=amplitudes")]
  elif "=hklf3" in reflections_filename:
    reflections_realfilename = \
        reflections_filename[:reflections_filename.find("=hklf3")]
  elif "=intensities" in reflections_filename:
    reflections_realfilename = \
        reflections_filename[:reflections_filename.find("=intensities")]
  elif "=hklf4" in reflections_filename:
    reflections_realfilename = \
        reflections_filename[:reflections_filename.find("=hklf4")]
  else:
    reflections_realfilename = reflections_filename

  # check extensions are supported
  for ext in (in_ext, out_ext):
    if ext not in allowed_input_file_extensions:
      raise command_line_error("unsupported extension: %s" % ext)

  # Investigate whether input and ouput files do exist, are the same, etc
  for filename in (input_filename, reflections_realfilename):
    if not os.path.isfile(filename):
      raise command_line_error("No such file %s" % filename)
  if os.path.isfile(output_filename):
    if not options.overwrite:
      raise command_line_error(
        "refuse to overwrite file %s (use option 'overwrite' to force it)"
        % output_filename)

  # Load input model and reflections
  if in_ext == '.cif':
    xm = refinement.model.from_cif(model=input_filename,
                                   reflections=reflections_filename)
  else:
    xm = refinement.model.from_shelx(ins_or_res=input_filename,
                                     hkl=reflections_filename,
                                     strictly_shelxl=False)

  # Load default anomalous scattering factors if wavelength is available
  wvl=xm.wavelength
  if wvl:
    xm.xray_structure.set_inelastic_form_factors(wvl, 'sasaki')

  sgi = xm.xray_structure.space_group_info()
  sg = sgi.group()
  print("Space group: %s" % sgi.type().hall_symbol())
  print("\t* %scentric" % ('non-','')[sg.is_centric()])
  print("\t* %schiral" % ('a','')[sg.is_chiral()])
  print("%i reflections" % len(xm.fo_sq.indices))

  # At last...
  for sc in xm.xray_structure.scatterers():
    sc.flags.set_grad_site(True)
    if sc.flags.use_u_iso(): sc.flags.set_grad_u_iso(True)
    if sc.flags.use_u_aniso(): sc.flags.set_grad_u_aniso(True)
  ls = xm.least_squares()
  print("%i atoms" % len(ls.reparametrisation.structure.scatterers()))
  print("%i refined parameters" % ls.reparametrisation.n_independents)
  steps = lstbx.normal_eqns_solving.levenberg_marquardt_iterations(
    non_linear_ls=ls,
    n_max_iterations=options.max_cycles,
    gradient_threshold=options.stop_if_max_derivative_below,
    step_threshold=options.stop_if_shift_norm_below)
  print("Normal equations building time: %.3f s" % \
        steps.non_linear_ls.normal_equations_building_time)
  print("Normal equations solving time: %.3f s" % \
        steps.non_linear_ls.normal_equations_solving_time)
  t0 = current_time()
  cov = ls.covariance_matrix_and_annotations()
  print("Covariance matrix building: %.3f" % (current_time() - t0))

  # Write result to disk
  if out_ext != '.cif':
    raise NotImplementedError("Write refined structure to %s file" % out_ext)
  with open(output_filename, 'w') as out:
    xm.xray_structure.as_cif_simple(out, format="corecif")

here_usage="""\
refine [options] INPUT
refine [options] INPUT REFLECTIONS
refine [options] INPUT OUTPUT
refine [options] INPUT REFLECTIONS OUTPUT
"""

here_description = """\
Supported formats for the INPUT and OUTPUT files are CIF and ShelX
whereas REFLECTIONS file format may be any of those supported
by iotbx.reflection_file_reader.

A certain amount of guessing is done by the program:
- if INPUT lacks any extension, a .ins extension is appended;
- if OUTPUT is not specified,
  o if INPUT is a .ins file, then OUTPUT is a .res file with the same root;
  o otherwise OUTPUT has the same extension as INPUT but with "-out"
    appended to INPUT root.
- if REFLECTIONS is not specified, it is INPUT root with a .hkl extension
"""

if __name__ == '__main__':
  from timeit import default_timer as current_time
  t0 = current_time()
  import sys, optparse
  parser = optparse.OptionParser(
    usage=here_usage,
    description=here_description)
  parser.add_option(
    '--overwrite',
    action='store_true',
    help='allows OUTPUT to be overwritten')
  parser.add_option(
    '--stop-if-max-derivative-below',
    type='float',
    default=1e-7,
    help='Stop refinement as soon as the largest absolute value of objective '
         'derivatives is below the given threshold.')
  parser.add_option(
    '--stop-if-shift-norm-below',
    type='float',
    default=1e-7,
    help='Stop refinement as soon as the Euclidean norm of the vector '
         'of parameter shifts is below the given threshold.')
  parser.add_option(
    '--max-cycles',
    type='int',
    default=8,
    help='Stop refinement as soon as the given number of cycles have been '
         'performed')
  parser.add_option(
    '--profile',
    action='store_true',
    help='Run with a profiler to find hotspots (for the author-eyes mostly!)')
  options, args = parser.parse_args()
  try:
    if not options.profile:
      run(args, options)
    else:
      import cProfile, pstats
      prof = cProfile.Profile()
      prof.runcall(run, args, options)
      stats = pstats.Stats(prof)
      stats.strip_dirs().sort_stats('time').print_stats(6)
  except number_of_arguments_error:
    parser.print_usage()
    sys.exit(1)
  except command_line_error as err:
    print("\nERROR: %s\n" % err, file=sys.stderr)
    parser.print_help()
    sys.exit(1)
  t1 = current_time()
  print("Total time: %.3f s" % (t1 - t0))


 *******************************************************************************


 *******************************************************************************
smtbx/development.py
from __future__ import absolute_import, division, print_function
from cctbx.development import random_structure
from cctbx import crystal, xray
from cctbx.array_family import flex
from smtbx.refinement import constraints
import smtbx.refinement.constraints.adp as adp_constraints
import smtbx.refinement.constraints.geometrical.hydrogens \
       as geometrical_hydrogens

class random_xray_structure(random_structure.xray_structure):
  """ Various tweaks to suit our needs in testing smtbx """

  def __init__(self, space_group_info=None, u_iso_xor_u_aniso=True,
               proportion_of_elements={}, **kwds):
    """ 1. In the superclass, if use_u_iso=True (resp. use_u_aniso=True)
        then only U_iso (resp. only U_aniso) will be used to compute
        structure factors. By passing u_iso_xor_u_aniso=False, one ensures that
        both U_iso and U_aniso are used.
        2. proportion_of_elements gives the desired elements and their relative
        proportions. E.g. {'C':5, 'O':2, 'N':1} requests elements C, O and N
        with the ratios 5 : 2 : 1. Depending on the value of n_scatterers,
        they may be only approximately achieved.
    """
    n_scatterers = kwds.pop('n_scatterers', None)
    elements = kwds.pop('elements', None)
    assert not proportion_of_elements or elements is None
    if proportion_of_elements:
      assert n_scatterers is not None
      normalisation = sum(proportion_of_elements.values())
      from_smallest = sorted(
        (p, elt) for elt, p in proportion_of_elements.items())
      populations = {}
      p0, elt0 = from_smallest[0]
      populations[elt0] = max(n_scatterers*p0//normalisation, 1)
      r0 = populations[elt0]/proportion_of_elements[elt0]
      total = populations[elt0]
      for p, elt in from_smallest[1:]:
        if total >= n_scatterers:
          break
        populations[elt] = min(int(round(proportion_of_elements[elt]*r0)),
                               n_scatterers - total)
        total += populations[elt]
      else:
        _, elt = from_smallest[-1]
        populations[elt] += n_scatterers - total
      elements = []
      for elt, p in populations.items():
        elements.extend([elt]*p)
    super(random_xray_structure, self).__init__(
      space_group_info=space_group_info,
      elements=elements,
      n_scatterers=n_scatterers,
      **kwds)
    if u_iso_xor_u_aniso: return
    if kwds['use_u_iso'] and kwds['use_u_aniso']:
      for sc in self.scatterers():
        sc.flags.set_use_u_iso(True).set_use_u_aniso(True)


class test_case(object):

  class __metaclass__(type):
    def __init__(cls, classname, bases, classdict):
      exercises = []
      for base in bases:
        try:
          exercises.extend(base.exercises)
        except AttributeError:
          pass
      for name, attr in classdict.items():
        if callable(attr) and name.startswith('exercise'):
          exercises.append(attr)
      dsu = sorted((ex.__name__, ex) for ex in exercises)
      cls.exercises = [ ex for foo, ex in dsu ]

  def run(cls, verbose=False, *args, **kwds):
    if verbose: print(cls.__name__)
    for exercise in cls.exercises:
      if verbose: print("\t%s ... " % exercise.__name__, end=' ')
      o = cls(*args, **kwds)
      exercise(o)
      if verbose: print("OK")
  run = classmethod(run)

def generate_hydrogen_constraints(structure, connectivity_table):
  # This is purely for testing purposes and is not in any way intended
  # to be a complete or comprehensive generation of constraints

  sc = structure.scatterers()
  conformer_indices = connectivity_table.conformer_indices
  sym_excl_indices = connectivity_table.sym_excl_indices
  sc_types = sc.extract_scattering_types()
  pair_sym_table = connectivity_table.pair_asu_table.extract_pair_sym_table(
    skip_j_seq_less_than_i_seq=False,
    all_interactions_from_inside_asu=True)
  h_constraints = []
  for i_seq, j_seq_dict in enumerate(pair_sym_table):
    conformer_i = conformer_indices[i_seq]
    if sc_types[i_seq] in ('H', 'D'): continue
    h_count = 0
    constrained_site_indices = []
    pivot_neighbour_count = 0
    for j_seq, sym_ops in j_seq_dict.items():
      if not (   conformer_i == 0
              or conformer_indices[j_seq] == 0
              or conformer_i == conformer_indices[j_seq]):
        continue
      if sc_types[j_seq] in ('H', 'D'):
        h_count += sym_ops.size()
        constrained_site_indices.append(j_seq)
      else: pivot_neighbour_count += sym_ops.size()
    rotating = False
    stretching = False
    constraint_type = None
    u_eq_multiplier = 1.2
    if h_count == 0: continue
    elif h_count == 1:
      if pivot_neighbour_count == 1:
        if sc_types[i_seq] == 'C':
          constraint_type = geometrical_hydrogens.terminal_linear_ch_site
        else:
          constraint_type = geometrical_hydrogens.terminal_tetrahedral_xh_site
          if sc_types[i_seq] == 'O':
            u_eq_multiplier  = 1.5
      elif pivot_neighbour_count == 2 and sc_types[i_seq] in ('C', 'N'):
        constraint_type = geometrical_hydrogens.secondary_planar_xh_site
        stretching = True
      elif pivot_neighbour_count == 3 and sc_types[i_seq] == 'C':
        constraint_type = geometrical_hydrogens.tertiary_xh_site
    elif h_count == 2:
      if pivot_neighbour_count == 1 and sc_types[i_seq] in ('C', 'N'):
        constraint_type = geometrical_hydrogens.terminal_planar_xh2_sites
      elif pivot_neighbour_count == 2 and sc_types[i_seq] == 'C':
        constraint_type = geometrical_hydrogens.secondary_xh2_sites
      elif pivot_neighbour_count == 0 and sc_types[i_seq] == 'O': # water
        u_eq_multiplier = 1.5
        for idx in constrained_site_indices:
          h_constraints.append(
            adp_constraints.u_iso_proportional_to_pivot_u_eq(
              u_eq_scatterer_idx=i_seq,
              u_iso_scatterer_idx=idx,
              multiplier=u_eq_multiplier))
    elif h_count == 3:
      if pivot_neighbour_count == 1:
        constraint_type = geometrical_hydrogens.terminal_tetrahedral_xh3_sites
        u_eq_multiplier = 1.5
    if constraint_type is not None:
      current = constraint_type(
        rotating=rotating,
        stretching=stretching,
        pivot=i_seq,
        constrained_site_indices=constrained_site_indices)
      h_constraints.append(current)
      if sc[i_seq].flags.use_u_iso(): continue # XXX u_iso can't yet ride on u_iso
      for idx in constrained_site_indices:
        h_constraints.append(
          adp_constraints.u_iso_proportional_to_pivot_u_eq(
            u_eq_scatterer_idx=i_seq,
            u_iso_scatterer_idx=idx,
            multiplier=u_eq_multiplier))
  return h_constraints

def sucrose():
  return xray.structure(
    crystal_symmetry=crystal.symmetry(
      unit_cell=(7.783, 8.7364, 10.9002, 90, 102.984, 90),
      space_group_symbol='hall:  P 2yb'),
    scatterers=flex.xray_scatterer((
      xray.scatterer( #0
                      label='O1',
                      site=(-0.131694, 0.935444, 0.877178),
                      u=(0.000411, 0.000231, 0.000177,
                         -0.000017, 0.000112, -0.000003)),
      xray.scatterer( #1
                      label='O2',
                      site=(-0.214093, 0.788106, 1.081133),
                      u=(0.000809, 0.000424, 0.000219,
                       0.000105, 0.000177, 0.000051)),
      xray.scatterer( #2
                      label='H2',
                      site=(-0.227111, 0.876745, 1.102068),
                      u=0.050326),
      xray.scatterer( #3
                      label='O3',
                      site=(-0.145099, 0.520224, 0.848374),
                      u=(0.000860, 0.000240, 0.000587,
                         -0.000149, 0.000303, -0.000093)),
      xray.scatterer( #4
                      label='H3',
                      site=(-0.073357, 0.454114, 0.840907),
                      u=0.064297),
      xray.scatterer( #5
                      label='O4',
                      site=(0.202446, 0.586695, 0.808946),
                      u=(0.000848, 0.000352, 0.000315,
                         0.000294, 0.000256, 0.000111)),
      xray.scatterer( #6
                      label='H4',
                      site=(0.234537, 0.569702, 0.743559),
                      u=0.052973),
      xray.scatterer( #7
                      label='O5',
                      site=(0.247688, 0.897720, 0.729153),
                      u=(0.000379, 0.000386, 0.000270,
                         -0.000019, 0.000106, 0.000001)),
      xray.scatterer( #8
                      label='H5',
                      site=(0.323942, 0.957695, 0.764491),
                      u=0.040241),
      xray.scatterer( #9
                      label='O6',
                      site=(-0.183682, 1.239489, 0.712253),
                      u=(0.000240, 0.000270, 0.000208,
                         0.000035, 0.000002, -0.000057)),
      xray.scatterer( #10
                      label='O7',
                      site=(-0.460944, 1.095427, 0.826725),
                      u=(0.000454, 0.000438, 0.000330,
                         0.000029, 0.000103, 0.000091)),
      xray.scatterer( #11
                      label='H7',
                      site=(-0.360598, 1.061356, 0.849066),
                      u=0.048134),
      xray.scatterer( #12
                      label='O8',
                      site=(-0.590098, 1.234857, 0.477504),
                      u=(0.000341, 0.000376, 0.000283,
                         0.000054, -0.000022, 0.000051)),
      xray.scatterer( #13
                      label='H8',
                      site=(-0.596179, 1.326096, 0.493669),
                      u=0.041878),
      xray.scatterer( #14
                      label='O9',
                      site=(-0.294970, 1.016028, 0.425505),
                      u=(0.000509, 0.000266, 0.000191,
                         -0.000031, 0.000056, -0.000050)),
      xray.scatterer( #15
                      label='H9',
                      site=(-0.305666, 0.937198, 0.463939),
                      u=0.035859),
      xray.scatterer( #16
                      label='O10',
                      site=(0.121231, 1.098881, 0.529558),
                      u=(0.000428, 0.000442, 0.000264,
                         0.000037, 0.000149, 0.000061)),
      xray.scatterer( #17
                      label='H10',
                      site=(0.164296, 1.026179, 0.573427),
                      u=0.042667),
      xray.scatterer( #18
                      label='O11',
                      site=(-0.108540, 0.986958, 0.671415),
                      u=(0.000301, 0.000160, 0.000170,
                         -0.000018, 0.000028, 0.000003)),
      xray.scatterer( #19
                      label='C1',
                      site=(-0.205698, 0.782086, 0.859435),
                      u=(0.000378, 0.000249, 0.000211,
                         -0.000046, 0.000020, 0.000007)),
      xray.scatterer( #20
                      label='H1',
                      site=(-0.282033, 0.773748, 0.774955),
                      u=0.033128),
      xray.scatterer( #21
                      label='C2',
                      site=(-0.315620, 0.763019, 0.956870),
                      u=(0.000478, 0.000387, 0.000268,
                         0.000006, 0.000115, 0.000085)),
      xray.scatterer( #22
                      label='H2B',
                      site=(-0.413052, 0.834909, 0.939327),
                      u=0.042991),
      xray.scatterer( #23
                      label='C3',
                      site=(-0.057676, 0.663433, 0.874279),
                      u=(0.000481, 0.000203, 0.000211,
                         -0.000039, 0.000097, -0.000026)),
      xray.scatterer( #24
                      label='H3B',
                      site=(0.010861, 0.664198, 0.961490),
                      u=0.033010),
      xray.scatterer( #25
                      label='C4',
                      site=(0.064486, 0.697929, 0.785789),
                      u=(0.000516, 0.000251, 0.000171,
                         0.000108, 0.000066, 0.000006)),
      xray.scatterer( #26
                      label='H2A',
                      site=(-0.364431, 0.660423, 0.951038),
                      u=0.042991),
      xray.scatterer( #27
                      label='H4B',
                    site=(-0.001643, 0.690588, 0.698163),
                    u=0.034151),
      xray.scatterer( #28
                      label='C5',
                      site=(0.134552, 0.859023, 0.812706),
                      u=(0.000346, 0.000319, 0.000114,
                         0.000016, 0.000027, 0.000034)),
      xray.scatterer( #29
                      label='H5B',
                      site=(0.204847, 0.862433, 0.899373),
                      u=0.028874),
      xray.scatterer( #30
                      label='C6',
                      site=(-0.013996, 0.975525, 0.800238),
                      u=(0.000321, 0.000194, 0.000125,
                         -0.000031, 0.000037, -0.000006)),
      xray.scatterer( #31
                      label='H6',
                      site=(0.037624, 1.075652, 0.827312),
                      u=0.023850),
      xray.scatterer( #32
                      label='C7',
                      site=(-0.130206, 1.141642, 0.624140),
                      u=(0.000313, 0.000143, 0.000184,
                         -0.000000, 0.000045, -0.000001)),
      xray.scatterer( #33
                      label='C8',
                      site=(0.043311, 1.203061, 0.603290),
                      u=(0.000354, 0.000269, 0.000247,
                         -0.000020, 0.000085, 0.000024)),
      xray.scatterer( #34
                      label='H8A',
                      site=(0.023319, 1.300964, 0.560480),
                      u=0.034035),
      xray.scatterer( #35
                      label='H8B',
                      site=(0.123967, 1.219261, 0.684061),
                      u=0.034035),
      xray.scatterer( #36
                      label='C9',
                      site=(-0.285452, 1.143037, 0.507357),
                      u=(0.000294, 0.000203, 0.000181,
                         0.000009, 0.000062, 0.000042)),
      xray.scatterer( #37
                      label='H9B',
                      site=(-0.273079, 1.235040, 0.458631),
                      u=0.026214),
      xray.scatterer( #38
                      label='C10',
                      site=(-0.444628, 1.167026, 0.565148),
                      u=(0.000289, 0.000234, 0.000210,
                         0.000018, 0.000036, 0.000040)),
      xray.scatterer( #39
                      label='H10B',
                      site=(-0.480820, 1.069195, 0.595409),
                      u=0.029493),
      xray.scatterer( #40
                      label='C11',
                      site=(-0.371995, 1.272625, 0.676806),
                      u=(0.000324, 0.000199, 0.000264,
                         0.000054, 0.000089, 0.000009)),
      xray.scatterer( #41
                      label='H11',
                      site=(-0.388144, 1.379127, 0.648319),
                      u=0.031434),
      xray.scatterer( #42
                      label='C12',
                      site=(-0.453277, 1.252159, 0.788677),
                      u=(0.000396, 0.000422, 0.000263,
                         0.000043, 0.000125, -0.000061)),
      xray.scatterer( #43
                      label='H12B',
                      site=(-0.571879, 1.293694, 0.768457),
                      u=0.041343),
      xray.scatterer( #44
                      label='H12A',
                      site=(-0.385488, 1.310416, 0.858834),
                      u=0.041343)
    )))


 *******************************************************************************


 *******************************************************************************
smtbx/libtbx_refresh.py
from __future__ import absolute_import, division, print_function
import os

if self.env.is_ready_for_build():
  message_template = '  Generating C++ files in:\n    "%s"'
  #flex_fwd.h
  from smtbx.source_generators import flex_fwd_h
  target_dir = self.env.under_build("include/smtbx/boost_python")
  print(message_template % target_dir)
  if not os.path.isdir(target_dir):
    os.makedirs(target_dir)
  flex_fwd_h.run(target_dir)


 *******************************************************************************


 *******************************************************************************
smtbx/masks/__init__.py
from __future__ import absolute_import, division, print_function

import sys

import cctbx.masks
from cctbx import maptbx, miller, sgtbx, xray
from cctbx.array_family import flex
from scitbx.math import approx_equal_relatively
from libtbx.utils import xfrange
from six.moves import range


class solvent_accessible_volume(object):
  def __init__(self, xray_structure,
               solvent_radius,
               shrink_truncation_radius,
               ignore_hydrogen_atoms=False,
               crystal_gridding=None,
               grid_step=None,
               d_min=None,
               resolution_factor=1/4,
               atom_radii_table=None,
               use_space_group_symmetry=False):
    self.xray_structure = xray_structure
    if crystal_gridding is None:
      self.crystal_gridding = maptbx.crystal_gridding(
        unit_cell=xray_structure.unit_cell(),
        space_group_info=xray_structure.space_group_info(),
        step=grid_step,
        d_min=d_min,
        resolution_factor=resolution_factor,
        symmetry_flags=sgtbx.search_symmetry_flags(
          use_space_group_symmetry=use_space_group_symmetry))
    else:
      self.crystal_gridding = crystal_gridding
    if use_space_group_symmetry:
      atom_radii = cctbx.masks.vdw_radii(
        xray_structure, table=atom_radii_table).atom_radii
      asu_mappings = xray_structure.asu_mappings(
        buffer_thickness=flex.max(atom_radii)+solvent_radius)
      scatterers_asu_plus_buffer = flex.xray_scatterer()
      frac = xray_structure.unit_cell().fractionalize
      for sc, mappings in zip(
        xray_structure.scatterers(), asu_mappings.mappings()):
        for mapping in mappings:
          scatterers_asu_plus_buffer.append(
            sc.customized_copy(site=frac(mapping.mapped_site())))
      xs = xray.structure(crystal_symmetry=xray_structure,
                          scatterers=scatterers_asu_plus_buffer)
    else:
      xs = xray_structure.expand_to_p1()
    self.vdw_radii = cctbx.masks.vdw_radii(xs, table=atom_radii_table)
    self.mask = cctbx.masks.around_atoms(
      unit_cell=xs.unit_cell(),
      space_group_order_z=xs.space_group().order_z(),
      sites_frac=xs.sites_frac(),
      atom_radii=self.vdw_radii.atom_radii,
      gridding_n_real=self.crystal_gridding.n_real(),
      solvent_radius=solvent_radius,
      shrink_truncation_radius=shrink_truncation_radius)
    if use_space_group_symmetry:
      tags = self.crystal_gridding.tags()
      tags.tags().apply_symmetry_to_mask(self.mask.data)
    self.flood_fill = cctbx.masks.flood_fill(
      self.mask.data, xray_structure.unit_cell())
    self.exclude_void_flags = [False] * self.flood_fill.n_voids()
    self.solvent_accessible_volume = self.n_solvent_grid_points() \
        / self.mask.data.size() * xray_structure.unit_cell().volume()

  def n_voids(self):
    return self.flood_fill.n_voids()

  def n_solvent_grid_points(self):
    return sum([self.mask.data.count(i+2) for i in range(self.n_voids())
                if not self.exclude_void_flags[i]])

  def show_summary(self, log=None):
    if log is None: log = sys.stdout
    print("solvent_radius: %.2f" %(self.mask.solvent_radius), file=log)
    print("shrink_truncation_radius: %.2f" %(
      self.mask.shrink_truncation_radius), file=log)
    print("van der Waals radii:", file=log)
    self.vdw_radii.show(log=log)
    print(file=log)
    print("Total solvent accessible volume / cell = %.1f Ang^3 [%.1f%%]" %(
      self.solvent_accessible_volume,
      100 * self.solvent_accessible_volume /
      self.xray_structure.unit_cell().volume()), file=log)
    n_voids = self.n_voids()
    print(file=log)
    self.flood_fill.show_summary(log=log)




class mask(object):
  def __init__(self, xray_structure, observations, use_set_completion=False):
    self.xray_structure = xray_structure
    self.fo2 = observations.as_intensity_array().average_bijvoet_mates()
    self.use_set_completion = use_set_completion
    if use_set_completion:
      self.complete_set = self.fo2.complete_set()
    else:
      self.complete_set = None
    self.mask = None
    self._f_mask = None
    self.f_000 = None
    self.f_000_s = None
    self.f_000_cell = None
    self._electron_counts_per_void = None

  def compute(self,
              solvent_radius,
              shrink_truncation_radius,
              ignore_hydrogen_atoms=False,
              crystal_gridding=None,
              grid_step=None,
              resolution_factor=1/4,
              atom_radii_table=None,
              use_space_group_symmetry=False):
    if grid_step is not None: d_min = None
    else: d_min = self.fo2.d_min()
    result = solvent_accessible_volume(
      self.xray_structure,
      solvent_radius,
      shrink_truncation_radius,
      ignore_hydrogen_atoms=ignore_hydrogen_atoms,
      crystal_gridding=crystal_gridding,
      grid_step=grid_step,
      d_min=d_min,
      resolution_factor=resolution_factor,
      atom_radii_table=atom_radii_table,
      use_space_group_symmetry=use_space_group_symmetry)
    self.crystal_gridding = result.crystal_gridding
    self.vdw_radii = result.vdw_radii
    self.mask = result.mask
    self.flood_fill = result.flood_fill
    self.exclude_void_flags = [False] * self.flood_fill.n_voids()
    self.solvent_accessible_volume = self.n_solvent_grid_points() \
        / self.mask.data.size() * self.xray_structure.unit_cell().volume()

  def structure_factors(self, max_cycles=10):
    """P. van der Sluis and A. L. Spek, Acta Cryst. (1990). A46, 194-201."""
    assert self.mask is not None
    if self.n_voids() == 0: return
    if self.use_set_completion:
      f_calc_set = self.complete_set
    else:
      f_calc_set = self.fo2.set()
    self.f_calc = f_calc_set.structure_factors_from_scatterers(
      self.xray_structure, algorithm="direct").f_calc()
    f_obs = self.f_obs()
    self.scale_factor = flex.sum(f_obs.data())/flex.sum(
      flex.abs(self.f_calc.data()))
    f_obs_minus_f_calc = f_obs.f_obs_minus_f_calc(
      1/self.scale_factor, self.f_calc)
    self.fft_scale = self.xray_structure.unit_cell().volume()\
        / self.crystal_gridding.n_grid_points()
    epsilon_for_min_residual = 2
    for i in range(max_cycles):
      self.diff_map = miller.fft_map(self.crystal_gridding, f_obs_minus_f_calc)
      self.diff_map.apply_volume_scaling()
      stats = self.diff_map.statistics()
      masked_diff_map = self.diff_map.real_map_unpadded().set_selected(
        self.mask.data.as_double() == 0, 0)
      n_solvent_grid_points = self.n_solvent_grid_points()
      for j in range(self.n_voids()):
        # exclude voids with negative electron counts from the masked map
        # set the electron density in those areas to be zero
        selection = self.mask.data == j+2
        if self.exclude_void_flags[j]:
          masked_diff_map.set_selected(selection, 0)
          continue
        diff_map_ = masked_diff_map.deep_copy().set_selected(~selection, 0)
        f_000 = flex.sum(diff_map_) * self.fft_scale
        f_000_s = f_000 * (
          self.crystal_gridding.n_grid_points() /
          (self.crystal_gridding.n_grid_points() - n_solvent_grid_points))
        if f_000_s < 0:
          masked_diff_map.set_selected(selection, 0)
          f_000_s = 0
          self.exclude_void_flags[j] = True
      self.f_000 = flex.sum(masked_diff_map) * self.fft_scale
      f_000_s = self.f_000 * (masked_diff_map.size() /
        (masked_diff_map.size() - self.n_solvent_grid_points()))
      if (self.f_000_s is not None and
          approx_equal_relatively(self.f_000_s, f_000_s, 0.0001)):
        break # we have reached convergence
      else:
        self.f_000_s = f_000_s
      masked_diff_map.add_selected(
        self.mask.data.as_double() > 0,
        self.f_000_s/self.xray_structure.unit_cell().volume())
      if 0:
        from crys3d import wx_map_viewer
        wx_map_viewer.display(
          title="masked diff_map",
          raw_map=masked_diff_map.as_double(),
          unit_cell=f_obs.unit_cell())
      self._f_mask = f_obs.structure_factors_from_map(map=masked_diff_map)
      self._f_mask *= self.fft_scale
      scales = []
      residuals = []
      min_residual = 1000
      for epsilon in xfrange(epsilon_for_min_residual, 0.9, -0.2):
        f_model_ = self.f_model(epsilon=epsilon)
        scale = flex.sum(f_obs.data())/flex.sum(flex.abs(f_model_.data()))
        residual = flex.sum(flex.abs(
          1/scale * flex.abs(f_obs.data())- flex.abs(f_model_.data()))) \
                 / flex.sum(1/scale * flex.abs(f_obs.data()))
        scales.append(scale)
        residuals.append(residual)
        min_residual = min(min_residual, residual)
        if min_residual == residual:
          scale_for_min_residual = scale
          epsilon_for_min_residual = epsilon
      self.scale_factor = scale_for_min_residual
      f_model = self.f_model(epsilon=epsilon_for_min_residual)
      f_obs = self.f_obs()
      f_obs_minus_f_calc = f_obs.phase_transfer(f_model).f_obs_minus_f_calc(
        1/self.scale_factor, self.f_calc)
    return self._f_mask

  def f_obs(self):
    fo2 = self.fo2.as_intensity_array()
    f_obs = fo2.as_amplitude_array()
    if self.use_set_completion:
      if self._f_mask is not None:
        f_model = self.f_model()
      else:
        f_model = self.f_calc
      data_substitute = flex.abs(f_model.data())
      scale_factor = flex.sum(f_obs.data())/flex.sum(
        f_model.common_set(f_obs).as_amplitude_array().data())
      f_obs = f_obs.matching_set(
        other=self.complete_set,
        data_substitute=scale_factor*flex.abs(f_model.data()),
        sigmas_substitute=0)
    return f_obs

  def f_mask(self):
    return self._f_mask

  def f_model(self, f_calc=None, epsilon=None):
    if self._f_mask is None: return None
    f_mask = self.f_mask()
    if f_calc is None:
      f_calc = self.f_calc
    if epsilon is None:
      data = f_calc.data() + f_mask.data()
    else:
      data = f_calc.data() + epsilon * f_mask.data()
    return miller.array(miller_set=f_calc, data=data)

  def modified_intensities(self):
    """Intensities with the solvent contribution removed."""
    if self._f_mask is None: return None
    f_mask = self.f_mask().common_set(self.fo2)
    f_model = self.f_model().common_set(self.fo2)
    return modified_intensities(
      self.fo2, f_model, f_mask)

  def n_voids(self):
    return self.flood_fill.n_voids()

  def n_solvent_grid_points(self):
    return sum([self.mask.data.count(i+2) for i in range(self.n_voids())
                if not self.exclude_void_flags[i]])

  def electron_counts_per_void(self):
    if self._electron_counts_per_void is not None:
      return self._electron_counts_per_void
    self._electron_counts_per_void = []
    masked_diff_map = self.diff_map.real_map_unpadded().set_selected(
      self.mask.data.as_double() == 0, 0)
    for i in range(self.n_voids()):
      if self.exclude_void_flags[i]:
        f_000_s = 0
      else:
        diff_map = masked_diff_map.deep_copy().set_selected(
          self.mask.data != i+2, 0)
        f_000 = flex.sum(diff_map) * self.fft_scale
        f_000_s = f_000 * (
          self.crystal_gridding.n_grid_points() /
          (self.crystal_gridding.n_grid_points() - self.n_solvent_grid_points()))
      self._electron_counts_per_void.append(f_000_s)
    return self._electron_counts_per_void

  def show_summary(self, log=None):
    if log is None: log = sys.stdout
    print("use_set_completion: %s" %self.use_set_completion, file=log)
    print("solvent_radius: %.2f" %(self.mask.solvent_radius), file=log)
    print("shrink_truncation_radius: %.2f" %(
      self.mask.shrink_truncation_radius), file=log)
    print("van der Waals radii:", file=log)
    self.vdw_radii.show(log=log)
    print(file=log)
    print("Total solvent accessible volume / cell = %.1f Ang^3 [%.1f%%]" %(
      self.solvent_accessible_volume,
      100 * self.solvent_accessible_volume /
      self.xray_structure.unit_cell().volume()), file=log)
    n_voids = self.n_voids()
    if n_voids > 0:
      print("Total electron count / cell = %.1f" %(self.f_000_s), file=log)
    print(file=log)
    self.flood_fill.show_summary(log=log)
    if n_voids == 0: return
    print(file=log)
    print("Void  Vol/Ang^3  #Electrons", file=log)
    grid_points_per_void = self.flood_fill.grid_points_per_void()
    com = self.flood_fill.centres_of_mass_frac()
    electron_counts = self.electron_counts_per_void()
    for i in range(self.n_voids()):
      void_vol = (
        self.xray_structure.unit_cell().volume() * grid_points_per_void[i]) \
               / self.crystal_gridding.n_grid_points()
      formatted_site = ["%6.3f" % x for x in com[i]]
      print("%4i" %(i+1), end=' ', file=log)
      print("%10.1f     " %void_vol, end=' ', file=log)
      print("%7.1f" %electron_counts[i], file=log)

  def as_cif_block(self):
    from iotbx import cif
    cif_block = cif.model.block()
    mask_loop = cif.model.loop(header=(
      "_smtbx_masks_void_nr",
      "_smtbx_masks_void_average_x",
      "_smtbx_masks_void_average_y",
      "_smtbx_masks_void_average_z",
      "_smtbx_masks_void_volume",
      "_smtbx_masks_void_count_electrons",
      "_smtbx_masks_void_content",
    ))
    n_voids = self.n_voids()
    if n_voids == 0: return cif_block
    grid_points_per_void = self.flood_fill.grid_points_per_void()
    com = self.flood_fill.centres_of_mass_frac()
    electron_counts = self.electron_counts_per_void()
    for i in range(self.n_voids()):
      void_vol = (
        self.xray_structure.unit_cell().volume() * grid_points_per_void[i]) \
               / self.crystal_gridding.n_grid_points()
      xyz = list(com[i])
      for j in range(3):
        if round(xyz[j],6) == 0: xyz[j] = 0
      site_fmt = "%.3f"
      mask_loop.add_row(
        [i+1, site_fmt % xyz[0], site_fmt % xyz[1],
         site_fmt % xyz[2], "%.1f" % void_vol,
         "%.1f" %electron_counts[i], '?'])
    cif_block.add_loop(mask_loop)
    cif_block['_smtbx_masks_special_details'] = '?'
    return cif_block


def modified_intensities(observations, f_model, f_mask):
  """Subtracts the solvent contribution from the observed structure
  factors to obtain modified structure factors, suitable for refinement
  with other refinement programs such as ShelXL"""
  f_obs = observations.as_amplitude_array()
  if f_obs.sigmas() is not None:
    weights = weights=1/flex.pow2(f_obs.sigmas())
  else:
    weights = None
  scale_factor = f_obs.scale_factor(f_model, weights=weights)
  f_obs = f_obs.phase_transfer(phase_source=f_model)
  modified_f_obs = miller.array(
    miller_set=f_obs,
    data=(f_obs.data() - f_mask.data()*scale_factor))
  if observations.is_xray_intensity_array():
    # it is better to use the original sigmas for intensity if possible
    return modified_f_obs.as_intensity_array().customized_copy(
      sigmas=observations.sigmas())
  else:
    return modified_f_obs.customized_copy(
      sigmas=f_obs.sigmas()).as_intensity_array()


 *******************************************************************************


 *******************************************************************************
smtbx/masks/tests/tst_masks.py
from __future__ import absolute_import, division, print_function

from scitbx.lstbx import normal_eqns_solving
from cctbx import miller
from cctbx import euclidean_model_matching as emma
from cctbx.array_family import flex
from cctbx.xray import structure
from libtbx.test_utils import approx_equal, show_diff
import libtbx.utils
from smtbx import masks
from smtbx.refinement import constraints
import smtbx.utils
from six.moves import cStringIO as StringIO
from six.moves import range

def exercise_masks():
  mt = flex.mersenne_twister(seed=0)
  xs_ref = structure.from_shelx(
    file=StringIO(YAKRUY_ins))
  mi = xs_ref.crystal_symmetry().build_miller_set(
    d_min=0.5, anomalous_flag=False)
  fo = mi.structure_factors_from_scatterers(
    xs_ref, algorithm="direct").f_calc().as_amplitude_array()
  k = 0.05 + 10 * mt.random_double()
  fo = fo.customized_copy(data=fo.data()*k)
  fo2 = fo.f_as_f_sq()
  labels = ['N4', 'C20', 'C21', 'H211', 'H212', 'H213']
  acetonitrile_sel = flex.bool([sc.label in labels for sc in xs_ref.scatterers()])
  xs_no_sol = xs_ref.deep_copy_scatterers().select(
    acetonitrile_sel, negate=True)
  # check what happens when no voids are found
  mask = masks.mask(xs_ref, fo2)
  mask.compute(solvent_radius=1.2,
               shrink_truncation_radius=1.2,
               resolution_factor=1/2,
               atom_radii_table={'C':1.70, 'B':1.63, 'N':1.55, 'O':1.52})
  assert mask.structure_factors() is None
  assert mask.n_voids() == 0
  assert mask.n_solvent_grid_points() == 0
  assert mask.f_mask() is None
  assert mask.f_model() is None
  assert mask.modified_intensities() is None
  assert mask.f_000 is None
  s = StringIO()
  mask.show_summary(log=s)
  assert not show_diff(s.getvalue(), """\
use_set_completion: False
solvent_radius: 1.20
shrink_truncation_radius: 1.20
van der Waals radii:
    B     C     H     N     O
 1.63  1.70  1.20  1.55  1.52

Total solvent accessible volume / cell = 0.0 Ang^3 [0.0%]

gridding: (30,45,54)
""")
  # and now with some voids
  fo2_complete = fo2.sort()
  fo2_missing_1 = fo2.select_indices(flex.miller_index([(0,0,1),
                                                        ]), negate=True)
  mt = flex.mersenne_twister(seed=0)
  fo2_incomplete = fo2.select(mt.random_bool(fo2.size(), 0.95))

  for fo2, use_space_group_symmetry in zip(
    (fo2_complete, fo2_complete, fo2_missing_1, fo2_incomplete),
    (True, False, True, True)):
    if fo2 is fo2_complete: use_set_completion=False
    else: use_set_completion=True
    mask = masks.mask(xs_no_sol, fo2, use_set_completion=use_set_completion)
    mask.compute(solvent_radius=1.2,
                 shrink_truncation_radius=1.2,
                 resolution_factor=1/3,
                 #atom_radii_table={'C':1.70, 'B':1.63, 'N':1.55, 'O':1.52},
                 use_space_group_symmetry=use_space_group_symmetry)
    n_voids = flex.max(mask.mask.data) - 1
    f_mask = mask.structure_factors()
    f_model = mask.f_model()
    modified_fo = mask.modified_intensities().as_amplitude_array()
    f_obs_minus_f_model = fo.common_set(f_model).f_obs_minus_f_calc(f_obs_factor=1/k, f_calc=f_model)
    diff_map = miller.fft_map(mask.crystal_gridding, f_obs_minus_f_model)
    diff_map.apply_volume_scaling()
    stats = diff_map.statistics()
    assert n_voids == 2
    assert approx_equal(n_voids, mask.n_voids())
    assert mask.n_solvent_grid_points() == 42148
    if fo2 is fo2_complete:
      # check the difference map has no large peaks/holes
      assert max(stats.max(), abs(stats.min())) < 0.11
    # expected electron count: 44
    assert approx_equal(mask.f_000_s, 44, eps=1)
    assert modified_fo.r1_factor(mask.f_calc.common_set(modified_fo), k) < 0.006
    assert fo.common_set(fo2).r1_factor(f_model.common_set(fo2), k) < 0.006

  s = StringIO()
  mask.show_summary(log=s)
  assert not show_diff(s.getvalue(), """\
use_set_completion: True
solvent_radius: 1.20
shrink_truncation_radius: 1.20
van der Waals radii:
    C     H     N     O
 1.77  1.20  1.50  1.45

Total solvent accessible volume / cell = 146.5 Ang^3 [16.3%]
Total electron count / cell = 43.2

gridding: (45,72,80)
Void #Grid points Vol/A^3 Vol/%  Centre of mass (frac)   Eigenvectors (frac)
   1        21074    73.3   8.1  ( 0.267, 0.461, 0.672)  1  ( 0.982, 0.126, 0.142)
                                                         2  (-0.166, 0.206, 0.964)
                                                         3  (-0.092, 0.970,-0.223)
   2        21074    73.3   8.1  (-0.267, 0.539, 0.328)  1  ( 0.982, 0.126, 0.142)
                                                         2  (-0.166, 0.206, 0.964)
                                                         3  (-0.092, 0.970,-0.223)

Void  Vol/Ang^3  #Electrons
   1       73.3         21.6
   2       73.3         21.6
""")
  cif_block = mask.as_cif_block()

  fo2 = fo.f_as_f_sq()
  # this bit is necessary until we have constraints, as
  # otherwise the hydrogens just disappear into the ether.
  xs = xs_no_sol.deep_copy_scatterers()
  h_selection = xs.element_selection('H')
  orig_flags = xs.scatterer_flags()
  flags = orig_flags.deep_copy()
  for flag, is_h in zip(flags, h_selection):
    if is_h:
      flag.set_grads(False)
  xs.set_scatterer_flags(flags)

  # first refine with no mask
  xs = exercise_least_squares(xs, fo2, mask=None)
  xs.set_scatterer_flags(orig_flags)
  for i in range(1):
    # compute improved mask/f_mask
    mask = masks.mask(xs, fo2)
    mask.compute(solvent_radius=1.2,
                 shrink_truncation_radius=1.2,
                 atom_radii_table={'C':1.70, 'B':1.63, 'N':1.55, 'O':1.52},
                 resolution_factor=1/3)
    mask.structure_factors()
    xs = exercise_least_squares(xs, fo2, mask)
  # again exclude hydrogens from tests because of lack of constraints
  emma_ref = xs_no_sol.select(h_selection, negate=True).as_emma_model()
  match = emma.model_matches(emma_ref, xs.select(
    h_selection, negate=True).as_emma_model()).refined_matches[0]
  assert approx_equal(match.rms, 0, eps=1e-3)

def exercise_least_squares(xray_structure, fo_sq, mask=None):
  from smtbx.refinement import least_squares
  fo_sq = fo_sq.customized_copy(sigmas=flex.double(fo_sq.size(),1.))
  xs = xray_structure.deep_copy_scatterers()
  if mask is not None:
    f_mask = mask.f_mask()
  else:
    f_mask = None
  connectivity_table = smtbx.utils.connectivity_table(xs)
  reparametrisation = constraints.reparametrisation(
    structure=xs,
    constraints=[],
    connectivity_table=connectivity_table)
  obs = fo_sq.as_xray_observations()
  ls = least_squares.crystallographic_ls(
    obs,
    reparametrisation,
    f_mask=f_mask,
    weighting_scheme="default")
  cycles = normal_eqns_solving.naive_iterations(ls,
                                                n_max_iterations=3)
  return xs

# durham structure 99srv215, CSD code YAKRUY
YAKRUY_ins = """
CELL 0.71073   7.086  10.791  12.850 104.16 105.87  95.86
ZERR    2.00   0.001   0.003   0.002   0.02   0.02   0.01
LATT  1
SFAC C H N O
UNIT 42 40 8 4
O1    4    0.263832    0.309851    0.916785    11.00000    0.03486    0.02047 =
         0.02294    0.00910    0.01221    0.00848
O2    4    0.259857    0.121826    0.750368    11.00000    0.03493    0.02585 =
         0.01911    0.00907    0.01212    0.00849
N1    3    0.244867   -0.219643    1.065706    11.00000    0.02111    0.01983 =
         0.02052    0.00529    0.00767    0.00528
N2    3    0.238512   -0.124207    1.256893    11.00000    0.02403    0.01605 =
         0.01797    0.00354    0.00780    0.00428
N3    3    0.236863   -0.003326    1.323510    11.00000    0.02340    0.01743 =
         0.02104    0.00455    0.00803    0.00515
N4    3    0.313652    0.621206    0.720884    11.00000    0.05212    0.03488 =
         0.03702    0.00851    0.01917    0.00007
C1    1    0.258790    0.192265    0.938230    11.00000    0.01801    0.02150 =
         0.02273    0.00950    0.00637    0.00518
C2    1    0.258684    0.087261    0.845526    11.00000    0.01829    0.02676 =
         0.01813    0.00919    0.00712    0.00512
C3    1    0.258107   -0.035539    0.857494    11.00000    0.01763    0.02320 =
         0.01795    0.00465    0.00660    0.00526
H3    2    0.265419   -0.106192    0.797272    11.00000    0.02235
C4    1    0.252521   -0.058937    0.960660    11.00000    0.01442    0.02188 =
         0.01933    0.00569    0.00576    0.00362
C5    1    0.249654    0.044792    1.051770    11.00000    0.01428    0.02074 =
         0.01927    0.00546    0.00489    0.00333
C6    1    0.254907    0.171444    1.038876    11.00000    0.01823    0.01960 =
         0.01938    0.00441    0.00607    0.00410
H6    2    0.260661    0.244361    1.101313    11.00000    0.02028
C7    1    0.244340    0.011338    1.151454    11.00000    0.01528    0.01760 =
         0.02039    0.00560    0.00559    0.00358
C8    1    0.242078   -0.118214    1.151436    11.00000    0.01632    0.02066 =
         0.01923    0.00609    0.00594    0.00402
C9    1    0.250274   -0.186707    0.973843    11.00000    0.01810    0.02164 =
         0.01942    0.00361    0.00684    0.00426
H9    2    0.252942   -0.255996    0.908935    11.00000    0.01373
C10   1    0.238915    0.077502    1.260637    11.00000    0.01646    0.02046 =
         0.02005    0.00660    0.00460    0.00293
C11   1    0.241179   -0.230214    1.303905    11.00000    0.01923    0.01988 =
         0.02379    0.01016    0.00832    0.00634
C12   1    0.301101   -0.204248    1.421081    11.00000    0.02960    0.02212 =
         0.02187    0.00694    0.00858    0.00529
H12   2    0.347647   -0.113158    1.469110    11.00000    0.03067
C13   1    0.297066   -0.306624    1.468541    11.00000    0.03346    0.03026 =
         0.02258    0.01182    0.00920    0.00828
H13   2    0.338439   -0.286559    1.549032    11.00000    0.03493
C14   1    0.238170   -0.433815    1.401003    11.00000    0.03483    0.02587 =
         0.03168    0.01598    0.01317    0.01089
H14   2    0.239203   -0.504609    1.435015    11.00000    0.03255
C15   1    0.182288   -0.458453    1.284537    11.00000    0.03573    0.01878 =
         0.02946    0.00736    0.01196    0.00646
H15   2    0.141861   -0.547777    1.233813    11.00000    0.03479
C16   1    0.182000   -0.357827    1.235343    11.00000    0.02803    0.02211 =
         0.02063    0.00598    0.00799    0.00558
H16   2    0.140443   -0.375280    1.154110    11.00000    0.02660
C17   1    0.228172    0.216669    1.308393    11.00000    0.02843    0.01824 =
         0.02238    0.00458    0.00869    0.00462
H171  2    0.343696    0.277860    1.305773    11.00000    0.03122
H172  2    0.233564    0.235853    1.390463    11.00000    0.03214
H173  2    0.103775    0.237732    1.266193    11.00000    0.03633
C18   1    0.262699    0.418567    1.006264    11.00000    0.03735    0.01968 =
         0.02610    0.00669    0.01069    0.00556
H181  2    0.384186    0.436044    1.074408    11.00000    0.02881
H182  2    0.136744    0.404648    1.027622    11.00000    0.02787
H183  2    0.269188    0.493767    0.976527    11.00000    0.02735
C19   1    0.246327    0.019380    0.652743    11.00000    0.03131    0.03014 =
         0.01841    0.00608    0.01024    0.00667
H191  2    0.369862   -0.025013    0.666318    11.00000    0.03203
H192  2    0.122807   -0.042860    0.628185    11.00000    0.03308
H193  2    0.249416    0.060472    0.594291    11.00000    0.03051
C20   1    0.295027    0.510549    0.696308    11.00000    0.03015    0.03545 =
         0.02324    0.01128    0.01118    0.00361
C21   1    0.271551    0.369674    0.665707    11.00000    0.03896    0.03186 =
         0.04785    0.01623    0.01900    0.00949
H211  2    0.372427    0.342541    0.630638    11.00000    0.06494
H212  2    0.140789    0.331654    0.610485    11.00000    0.06386
H213  2    0.292381    0.339113    0.730897    11.00000    0.08983
HKLF 4
END
"""

def run():
  libtbx.utils.show_times_at_exit()
  exercise_masks()

if __name__ == '__main__':
  run()


 *******************************************************************************


 *******************************************************************************
smtbx/refinement/__init__.py
from __future__ import absolute_import, division, print_function
from cctbx import xray
from smtbx.refinement import constraints, least_squares, restraints
import smtbx.utils

class model(object):

  @classmethod
  def from_shelx(cls, *args, **kwds):
    from iotbx.shelx import _smtbx_refinement_model_from as _
    return _(cls, *args, **kwds)

  @classmethod
  def from_cif(cls, model, reflections):
    """
    We could try to read in the weighting scheme.
    As for constraints and restraints, the CIF format does not support them
    yet
    """
    from iotbx.reflection_file_reader import any_reflection_file
    xs_dict = xray.structure.from_cif(file_path=model)
    assert len(xs_dict) == 1, "CIF should contain only one xray structure"
    xs = list(xs_dict.values())[0]
    mas = any_reflection_file(reflections).as_miller_arrays(crystal_symmetry=xs)
    fo_sq = None
    for ma in mas:
      if ma.is_xray_intensity_array() and ma.sigmas() is not None:
        fo_sq = ma.as_xray_observations()
        break
    assert fo_sq is not None
    return cls(fo_sq=fo_sq, xray_structure=xs,
               constraints=[],
               restraints_manager=restraints.manager(),
               weighting_scheme=least_squares.sigma_weighting(),
               wavelength=xs.wavelength)

  def __init__(self, fo_sq, xray_structure,
               constraints, restraints_manager, weighting_scheme,
               temperature_in_celsius=20,
               conformer_indices=None,
               wavelength=None):
    self.fo_sq = fo_sq
    self.xray_structure = xray_structure
    self.constraints = constraints
    self.restraints_manager = restraints_manager
    self.weighting_scheme = weighting_scheme
    self.connectivity_table = smtbx.utils.connectivity_table(
      self.xray_structure,
      conformer_indices=conformer_indices
    )
    self.temperature_in_celsius = temperature_in_celsius
    self.wavelength = wavelength

  def make_anisotropic(self):
    self.xray_structure.convert_to_anisotropic()
    for sc in self.xray_structure.scatterers():
      sc.flags.set_grad_u_aniso(True)
      sc.flags.set_grad_u_iso(False)

  def least_squares(self):
    reparametrisation = constraints.reparametrisation(
      self.xray_structure,
      self.constraints,
      self.connectivity_table)
    return least_squares.crystallographic_ls(
      self.fo_sq,
      reparametrisation,
      restraints_manager=self.restraints_manager,
      weighting_scheme=self.weighting_scheme)


 *******************************************************************************


 *******************************************************************************
smtbx/refinement/constraints/__init__.py
from __future__ import absolute_import, division, print_function

import warnings

import boost_adaptbx.boost.python as bp
from six.moves import range
ext = bp.import_ext("smtbx_refinement_constraints_ext")
from smtbx_refinement_constraints_ext import *

import scitbx.sparse # import dependency
from scitbx.array_family import flex # import dependency
import libtbx.utils
from cctbx import xray

class InvalidConstraint(libtbx.utils.Sorry):
  __module__ = Exception.__module__


class ConflictingConstraintWarning(UserWarning):
  """ Attempt to constrain some scatterer parameters that have already been
 constrained: this attempt will be ignored.
  """

  def __init__(self, conflicts, constraint_type, scatterers):
    self.conflicts = conflicts
    self.constraint_type = constraint_type
    self.scatterers = scatterers

  def __str__(self):
    conflicts_printout = "\n".join([
      "\t* %s of scatterer %s (#%i)"
      % (param_tag, self.scatterers[scatt_idx].label, scatt_idx)
      for scatt_idx, param_tag in self.conflicts])
    return (
      "%s The attempted constraint is of type '%s'"
      " and the list of already constrained scatterer parameters is\n%s"
      % (self.__class__.__doc__, self.constraint_type, conflicts_printout))


bad_connectivity_msg = "Invalid %s constraint involving %s: bad connectivity"


@bp.inject_into(ext.parameter)
class _():

  def arguments(self):
    """ An iterator over its arguments """
    for i in range(self.n_arguments):
      yield self.argument(i)

  def __str__(self):
    """ String representation using the graphviz DOT language """
    try:
      scatt = ', '.join([ sc.label for sc in self.scatterers ])
      scatt = " (%s)" % scatt
    except AttributeError:
      scatt = ""
    info = []
    if not self.is_variable: info.append('cst')
    if info: info = ' [%s]' % ', '.join(info)
    else: info = ''
    lbl = '%i [label="%s%s%s #%s"]' % (
      self.index,
      self.__class__.__name__,
      info,
      scatt, self.index)
    return lbl

@bp.inject_into(ext.reparametrisation)
class _():

  def __str__(self):
    """ String representation using the graphviz DOT language """
    self.finalise()
    bits = []
    for p in self.parameters():
      for q in p.arguments():
        bits.append("%i -> %i" % (p.index, q.index))
    dsu_bits = []
    for p in self.parameters():
      dsu_bits.append((p.index, str(p)))
    dsu_bits.sort()
    bits.extend([ p for i,p in dsu_bits ])
    return "digraph dependencies {\n%s\n}" % ';\n'.join(bits)


# The order in which constraints are added MAKES a difference, shared site, U
#and/or occupancy constraints must be added first for proper bookkeeping
#
#Directions are defined as follows:
# static id x y z
# vector id [scatterer indices] - at least 2
# normal id [scatterer indices] - at least 3
#There are convinience functions for creating static directions:
#  constraints.static_direction.calc_best_plane_normal
#  constraints.static_direction.calc_best_line
#  both functions taking either a set of coordinates or unit cell and a set of
#sites
#Directions are passed as a list of tuples:
#  (name={one of: static,vector,normal}, id, params...)

class reparametrisation(ext.reparametrisation):
  """ Enhance the C++ level reparametrisation class for ease of use """

  temperature = 20 # Celsius
  twin_fractions = None
  extinction = None
  directions = None

  def __init__(self,
               structure,
               constraints,
               connectivity_table,
               **kwds):
    """ Construct for the given instance of xray.structure subject to the
    given sequence of constraints. Each constraint instance shall understand:
    constraint.add_to(self). That method shall perform 2 tasks:

      - add to self the parameters relevant to the reparametrisation
        associated with that constraint;

      - update self.asu_scatterer_parameters.

    The latter is an array containing one instance of scatterer_parameters
    for each scatterer in the a.s.u.
    C.f. module geometrical_hydrogens in this package for a typical example
    """
    super(reparametrisation, self).__init__(structure.unit_cell())
    # association of scatterer_idx:parameter, bookkeeping
    self.shared_Us = {}
    self.shared_sites = {}
    self.shared_occupancies = {}
    self.shared_fps = {}
    self.shared_fdps = {}

    # bookkeeping of fixed angles and distances - mainly for CIF output
    self.fixed_distances = {}
    self.fixed_angles = {}
    self.fixed_dihedral_angles = {}

    self.structure = xs = structure
    self.connectivity_table = connectivity_table
    self.pair_sym_table = \
        connectivity_table.pair_asu_table.extract_pair_sym_table(
          skip_j_seq_less_than_i_seq=False,
          all_interactions_from_inside_asu=True)
    scatterers = xs.scatterers()
    self.site_symmetry_table_ = self.structure.site_symmetry_table()
    libtbx.adopt_optional_init_args(self, kwds)
    self.asu_scatterer_parameters = shared_scatterer_parameters(xs.scatterers())
    self.independent_scalar_parameters = shared_independent_shared_parameters()

    #create referrable parameters
    if self.directions is not None:
      directions = {}
      for d in self.directions:
        if d[0] == 'static':
          directions[d[1]] = ext.static_direction(d[2])
        elif d[0] == 'vector':
          sites = [self.add_new_site_parameter(i[0]) for i in d[2:]]
          directions[d[1]] = ext.vector_direction(sites)
        elif d[0] == 'normal':
          sites = [self.add_new_site_parameter(i[0]) for i in d[2:]]
          directions[d[1]] = ext.normal_direction(sites)
      self.directions = directions

    self.constrained_parameters = set()
    for constraint in constraints:
      c_params = constraint.constrained_parameters
      warned_about = set()
      uniques = set()
      for p in c_params:
        if p in uniques:
          warned_about.add(p) # duplicates
        else:
          uniques.add(p)
      # conflicts with already added constraints
      warned_about |= uniques & self.constrained_parameters
      if warned_about:
        warnings.warn(ConflictingConstraintWarning(warned_about,
                                                   constraint.__class__,
                                                   structure.scatterers()))
      else:
        self.constrained_parameters |= uniques
        constraint.add_to(self)

    for i_sc in range(len(self.asu_scatterer_parameters)):
      self.add_new_site_parameter(i_sc)
      self.add_new_thermal_displacement_parameter(i_sc)
      self.add_new_occupancy_parameter(i_sc)
      self.add_new_fp_parameter(i_sc)
      self.add_new_fdp_parameter(i_sc)

    if self.twin_fractions is not None:
      for fraction in self.twin_fractions:
        if fraction.grad:
          self.add_new_twin_fraction_parameter(fraction)
    if self.extinction is not None and self.extinction.grad:
      p = self.add(extinction_parameter, self.extinction)
      self.independent_scalar_parameters.append(p)
    self.finalise()

  def finalise(self):
    super(reparametrisation, self).finalise()
    self.mapping_to_grad_fc = \
        self.asu_scatterer_parameters.mapping_to_grad_fc()
    self.mapping_to_grad_fc_independent_scalars = \
        self.independent_scalar_parameters.mapping_to_grad_fc()
    self.mapping_to_grad_fc_all = self.mapping_to_grad_fc.deep_copy()
    self.mapping_to_grad_fc_all.extend(self.mapping_to_grad_fc_independent_scalars)
    # set the grad indices for independent parameters: BASF, EXTI
    # count the number of refined independent params
    independent_grad_cnt = 0
    if self.twin_fractions is not None:
      for fraction in self.twin_fractions:
        if fraction.grad:
          independent_grad_cnt += 1
    if self.extinction is not None and self.extinction.grad:
      independent_grad_cnt += 1
    # update the grad indices
    independent_grad_i = self.jacobian_transpose.n_rows-independent_grad_cnt
    if self.twin_fractions is not None:
      for fraction in self.twin_fractions:
        if fraction.grad:
          fraction.grad_index = independent_grad_i
          independent_grad_i += 1
    if self.extinction is not None and self.extinction.grad:
      self.extinction.grad_index = independent_grad_i
      independent_grad_i += 1

  def apply_shifts(self, shifts):
    ext.reparametrisation.apply_shifts(self, shifts)

  @property
  def component_annotations(self):
    return self.__dict__.setdefault(
      "_component_annotations",
      self.asu_scatterer_parameters.component_annotations().split(',')[:-1])

  def jacobian_transpose_matching_grad_fc(self):
    """ The columns of self.jacobian_transpose corresponding to crystallographic
    parameters for the scatterers, in the same order as the derivatives in
    grad Fc. In this class, the latter is assumed to follow the convention of
    smtbx.structure_factors
    """
    return self.jacobian_transpose_matching(self.mapping_to_grad_fc)

  def add_new_occupancy_parameter(self, i_sc):
    if i_sc in self.shared_occupancies:
      return self.shared_occupancies[i_sc]
    occ = self.asu_scatterer_parameters[i_sc].occupancy
    if occ is None:
      sc = self.structure.scatterers()[i_sc]
      occ = self.add(independent_occupancy_parameter, sc)
      self.asu_scatterer_parameters[i_sc].occupancy = occ
    return occ

  def add_new_site_parameter(self, i_scatterer, symm_op=None):
    if i_scatterer in self.shared_sites:
      return self.shared_sites[i_scatterer]
    s = self.asu_scatterer_parameters[i_scatterer].site
    if s is None:
      site_symm = self.site_symmetry_table_.get(i_scatterer)
      sc = self.structure.scatterers()[i_scatterer]
      if site_symm.is_point_group_1():
        s = self.add(independent_site_parameter, sc)
      else:
        s = self.add(special_position_site_parameter, site_symm, sc)
      self.asu_scatterer_parameters[i_scatterer].site = s
    if symm_op is not None and not symm_op.is_unit_mx():
      s = self.add(symmetry_equivalent_site_parameter, s, symm_op)
    return s

  def add_new_site_proxy_parameter(self, param, i, i_sc):
    if i_sc in self.shared_sites:
      return self.shared_sites[i_sc]
    self.shared_sites[i_sc] = self.add(rigid_site_proxy, param, i)

  def add_new_same_group_site_proxy_parameter(self, param, i, i_sc):
    if i_sc in self.shared_sites:
      return self.shared_sites[i_sc]
    self.shared_sites[i_sc] = self.add(same_group_site_proxy, param, i)

  def add_new_thermal_displacement_parameter(self, i_scatterer):
    if i_scatterer in self.shared_Us:
      return self.shared_Us[i_scatterer]
    u = self.asu_scatterer_parameters[i_scatterer].u
    if u is None:
      sc = self.structure.scatterers()[i_scatterer]
      assert not (sc.flags.use_u_iso() and sc.flags.use_u_aniso())
      if sc.flags.use_u_iso():
        u = self.add(independent_u_iso_parameter, sc)
      else:
        site_symm = self.site_symmetry_table_.get(i_scatterer)
        if site_symm.is_point_group_1():
          u = self.add(independent_u_star_parameter, sc)
          if sc.is_anharmonic_adp():
            anh = self.add(independent_anharmonic_adp_parameter, sc)
            self.asu_scatterer_parameters[i_scatterer].anharmonic_adp = anh
        else:
          u = self.add(special_position_u_star_parameter,
                       site_symm,
                       sc)
          if sc.is_anharmonic_adp():
            anh = self.add(special_position_anharmonic_adp_parameter,
                         site_symm,
                         sc)
            self.asu_scatterer_parameters[i_scatterer].anharmonic_adp = anh
      self.asu_scatterer_parameters[i_scatterer].u = u
    return u

  def add_new_fp_parameter(self, i_sc):
    if i_sc in self.shared_fps:
      return self.shared_fps[i_sc]
    fp = self.asu_scatterer_parameters[i_sc].fp
    if fp is None:
      sc = self.structure.scatterers()[i_sc]
      fp = self.add(independent_fp_parameter, sc)
      self.asu_scatterer_parameters[i_sc].fp = fp
    return fp

  def add_new_fdp_parameter(self, i_sc):
    if i_sc in self.shared_fdps:
      return self.shared_fdps[i_sc]
    fdp = self.asu_scatterer_parameters[i_sc].fdp
    if fdp is None:
      sc = self.structure.scatterers()[i_sc]
      fdp = self.add(independent_fdp_parameter, sc)
      self.asu_scatterer_parameters[i_sc].fdp = fdp
    return fdp

  def add_new_twin_fraction_parameter(self, twin_fraction):
    p = self.add(twin_fraction_parameter, twin_fraction)
    self.independent_scalar_parameters.append(p)
    return p

  def add_new_independent_scalar_parameter(self, value, variable=True):
    p = self.add(independent_scalar_parameter, value=value, variable=variable)
    self.independent_scalar_parameters.append(p)
    return p

  def find_direction(self, id_):
    res = None
    if self.directions is not None:
      res = self.directions.get(id_, None)
    if res is None:
      raise "Undefined direction: '" + id_ + "'"
    return res

  def format_scatter_list(self, sl):
    scatterers = self.structure.scatterers()
    rv = []
    for i in sl:
      rv.append("%s" %scatterers[i].label)
    return " ".join(rv)

  def parameter_map(self):
    rv = xray.parameter_map(self.structure.scatterers())
    if self.twin_fractions is not None:
      for fraction in self.twin_fractions:
        if fraction.grad:
          rv.add_independent_scalar()
    if self.extinction is not None and self.extinction.grad:
      rv.add_independent_scalar()
    return rv


 *******************************************************************************


 *******************************************************************************
smtbx/refinement/constraints/adp.py
from __future__ import absolute_import, division, print_function
import smtbx.refinement.constraints as _
from smtbx.refinement.constraints import InvalidConstraint
from math import pi
from six.moves import range

class u_iso_proportional_to_pivot_u_eq(object):
  """ u_iso of some scatterer constrained to be proportional to
      equivalent u_iso associated with adp of another scatterer
  """

  __slots__ = ('u_iso_scatterer_idx', 'u_eq_scatterer_idx', 'multiplier')

  def __init__(self, u_iso_scatterer_idx, u_eq_scatterer_idx, multiplier):
    self.u_iso_scatterer_idx = u_iso_scatterer_idx
    self.u_eq_scatterer_idx = u_eq_scatterer_idx
    self.multiplier = multiplier

  def __eq__(self, other):
    """ For debugging purposes mostly as it is not needed by the
        constraint framework.
    """
    return (self.u_iso_scatterer_idx == other.u_iso_scatterer_idx
            and self.u_eq_scatterer_idx == other.u_eq_scatterer_idx
            and self.multiplier == other.multiplier)

  @property
  def constrained_parameters(self):
    return tuple(((self.u_iso_scatterer_idx, 'U'),))

  def add_to(self, reparametrisation):
    scatterers = reparametrisation.structure.scatterers()
    if scatterers[self.u_eq_scatterer_idx].flags.use_u_aniso():
      param = reparametrisation.add(
        _.u_iso_proportional_to_pivot_u_eq,
        pivot_u=reparametrisation.add_new_thermal_displacement_parameter(
          self.u_eq_scatterer_idx),
        scatterer = reparametrisation.structure.scatterers()[
          self.u_iso_scatterer_idx],
        multiplier=self.multiplier)
    else:
      param = reparametrisation.add(
        _.u_iso_proportional_to_pivot_u_iso,
        pivot_u_iso=reparametrisation.add_new_thermal_displacement_parameter(
          self.u_eq_scatterer_idx),
        scatterer = scatterers[self.u_iso_scatterer_idx],
        multiplier=self.multiplier)
    reparametrisation.asu_scatterer_parameters[
      self.u_iso_scatterer_idx].u = param

class shared_u(object):
  """ u_iso or u_star of some scatterer constrained to be equal to
      u_iso or u_star of another scatterer
  """

  def __init__(self, ind_sequence):
    if len(ind_sequence) < 2:
      raise InvalidConstraint("at least two atoms are expected")
    self.indices = ind_sequence

  @property
  def constrained_parameters(self):
    return tuple((idx, "U") for idx in self.indices[1:])

  def add_to(self, reparametrisation):
    scatterers = reparametrisation.structure.scatterers()
    src_uses_u = scatterers[self.indices[0]].flags.use_u_aniso()
    for i in range(1, len(self.indices)):
      if scatterers[self.indices[i]].flags.use_u_aniso() != src_uses_u:
        raise InvalidConstraint(
          "mixing isotropic and anisotropic atoms is not allowed for shared ADP")

    u_c = reparametrisation.add_new_thermal_displacement_parameter(
      self.indices[0])
    for i in range(1, len(self.indices)):
      if src_uses_u:
        param = reparametrisation.add(
          _.shared_u_star,
          reference=u_c,
          scatterer = scatterers[self.indices[i]])
      else:
        param = reparametrisation.add(
          _.shared_u_iso,
          reference=u_c,
          scatterer = scatterers[self.indices[i]])
      reparametrisation.shared_Us[self.indices[i]] = u_c
      reparametrisation.asu_scatterer_parameters[self.indices[i]].u = param
    self.value = u_c

class shared_rotated_u(object):
  """ u_eq or u_star of some scatterer constrained to be equal to
      u_iso or u_start of another scatterer
  """

  def __init__(self, ind_ref, ind_atom, direction,
               angle_value, refine_angle=False):
    self.ind_ref = ind_ref
    self.ind_atom = ind_atom
    self.direction = direction
    self.angle_value = angle_value
    self.refine_angle = bool(refine_angle)

  @property
  def constrained_parameters(self):
    return tuple(((self.ind_atom, 'U'),))

  def add_to(self, reparametrisation):
    scatterers = reparametrisation.structure.scatterers()
    if not scatterers[self.ind_ref].flags.use_u_aniso() or\
       not scatterers[self.ind_atom].flags.use_u_aniso():
      raise InvalidConstraint(
        "only anisotropic atoms are allowed for shared rotated ADP")

    u_c = reparametrisation.add_new_thermal_displacement_parameter(self.ind_ref)
    angle = reparametrisation.add(_.independent_scalar_parameter,
      value=self.angle_value*pi/180, variable=self.refine_angle)
    param = reparametrisation.add(
      _.shared_rotated_u_star,
      scatterer=scatterers[self.ind_atom],
      reference=u_c,
      direction=reparametrisation.find_direction(self.direction),
      angle=angle
    )
    reparametrisation.shared_Us[self.ind_atom] = u_c
    reparametrisation.asu_scatterer_parameters[self.ind_atom].u = param
    self.value = u_c
    self.angle = angle

class scalar_scaled_u(object):
  """ u_iso or u_star of a group of atoms all equal to their starting values
      times a scalar constant
  """

  def __init__(self, ind_sequence):
    self.indices = ind_sequence

  @property
  def constrained_parameters(self):
    return tuple((idx, "U") for idx in self.indices)

  def add_to(self, reparametrisation):
    scatterers = reparametrisation.structure.scatterers()
    scalar = reparametrisation.add(_.independent_scalar_parameter,
      value=1., variable=True)
    for idx in self.indices:
      use_u_aniso = scatterers[idx].flags.use_u_aniso()
      if use_u_aniso:
        param = reparametrisation.add(
          _.scalar_scaled_u_star,
          scalar=scalar,
          scatterer=scatterers[idx])
      else:
        param = reparametrisation.add(
          _.scalar_scaled_u_iso,
          scalar=scalar,
          scatterer=scatterers[idx])
      # reparametrisation.shared_Us[idx] = param # not sure what to do with this
      reparametrisation.asu_scatterer_parameters[idx].u = param
    self.scalar = scalar

  def esd(self, ls):
    from math import sqrt
    cov_diag = ls.covariance_matrix().matrix_packed_u_diagonal()
    return sqrt(cov_diag[self.scalar.index])


 *******************************************************************************


 *******************************************************************************
smtbx/refinement/constraints/all.py
""" All user-level (as opposed to the C++ core) constraints, for those
occasions when it is convenient to have easy access to all of them """
from __future__ import absolute_import, division, print_function

from smtbx.refinement.constraints.adp import *
from smtbx.refinement.constraints.site import *
from smtbx.refinement.constraints.geometrical.hydrogens import *


 *******************************************************************************


 *******************************************************************************
smtbx/refinement/constraints/fpfdp.py
from __future__ import absolute_import, division, print_function
import smtbx.refinement.constraints as _
from smtbx.refinement.constraints import InvalidConstraint
from six.moves import range

class shared_fp(object):
  def __init__(self, ind_sequence):
    if len(ind_sequence) < 2:
      raise InvalidConstraint("at least two atoms are expected")
    self.indices = ind_sequence

  @property
  def constrained_parameters(self):
    return tuple((idx, "fp") for idx in self.indices[1:])

  def add_to(self, reparametrisation):
    scatterers = reparametrisation.structure.scatterers()
    ref = reparametrisation.add_new_fp_parameter(self.indices[0])
    for i in range(1, len(self.indices)):
      param = reparametrisation.add(
        _.shared_fp,
        reference=ref,
        scatterer = scatterers[self.indices[i]])
      reparametrisation.shared_fps[self.indices[i]] = ref
      reparametrisation.asu_scatterer_parameters[self.indices[i]].fp = param
    self.value = ref

class shared_fdp(object):
  def __init__(self, ind_sequence):
    if len(ind_sequence) < 2:
      raise InvalidConstraint("at least two atoms are expected")
    self.indices = ind_sequence

  @property
  def constrained_parameters(self):
    return tuple((idx, "fdp") for idx in self.indices[1:])

  def add_to(self, reparametrisation):
    scatterers = reparametrisation.structure.scatterers()
    ref = reparametrisation.add_new_fdp_parameter(self.indices[0])
    for i in range(1, len(self.indices)):
      param = reparametrisation.add(
        _.shared_fdp,
        reference=ref,
        scatterer = scatterers[self.indices[i]])
      reparametrisation.shared_fps[self.indices[i]] = ref
      reparametrisation.asu_scatterer_parameters[self.indices[i]].fdp = param
    self.value = ref


 *******************************************************************************


 *******************************************************************************
smtbx/refinement/constraints/geometrical/__init__.py
""" Constraints on scatterer sites """
from __future__ import absolute_import, division, print_function
import six

class any(object):
  """ Base class for any constraints of scatterer sites """

  # default value of the attributes of an instance of this class
  staggered = False
  pivot = None
  bond_length = None
  rotating = False
  stretching = False
  flapping = False
  angle = None
  constrained_site_indices = ()
  need_pivot_neighbour_substituent = False

  def __init__(self, **kwds):
    cls = self.__class__
    for k,v in six.iteritems(kwds):
      if k == 'rotating':
        if v and not self.staggered: self.rotating = True
      elif v != getattr(cls, k): setattr(self, k, v)

  def finalise(self, first, last):
    """ finalise the construction with the scatterer index range [first, last)
    """

  @property
  def constrained_parameters(self):
    return tuple((idx, 'site') for idx in self.constrained_site_indices)

  def __repr__(self):
    return "%s(\n%s)" % (self.__class__.__name__,
                       '\n'.join(["  %s=%r" % (a,v)
                                 for (a,v) in six.iteritems(self.__dict__)]))

  def __eq__(self, other):
    """ For debugging purposes mostly as it is not needed by the
        constraint framework.
    """
    if type(self) != type(other): return False
    for attr, val in six.iteritems(self.__dict__):
      if getattr(other, attr) != val: return False
    return True


 *******************************************************************************


 *******************************************************************************
smtbx/refinement/constraints/geometrical/all.py
from __future__ import absolute_import, division, print_function
from smtbx.refinement.constraints.geometrical.hydrogens import *


 *******************************************************************************


 *******************************************************************************
smtbx/refinement/constraints/geometrical/hydrogens.py
""" All X-H bond lengths are in Angstrom and their values are taken from
ShelXL documentation (p. 4-3) """
from __future__ import absolute_import, division, print_function

import smtbx.refinement.constraints as _
from smtbx.refinement.constraints import InvalidConstraint, geometrical
from scitbx.matrix import col

import math
tetrahedral_angle = math.degrees(math.acos(-1./3))

class hydrogens(geometrical.any):

  need_pivot_neighbour_substituents = False

  def add_to(self, reparametrisation):
    i_pivot = self.pivot
    scatterers = reparametrisation.structure.scatterers()
    conformer_indices = reparametrisation.connectivity_table.conformer_indices
    if conformer_indices is not None:
      constrained_site_conformer = conformer_indices[
        self.constrained_site_indices[0]]
      for i in self.constrained_site_indices:
        assert conformer_indices[i] == constrained_site_conformer
    else: constrained_site_conformer = 0
    pivot_site = scatterers[i_pivot].site
    pivot_site_param = reparametrisation.add_new_site_parameter(i_pivot)
    pivot_neighbour_sites = ()
    pivot_neighbour_site_params = ()
    pivot_neighbour_substituent_site_params = ()
    for j, ops in reparametrisation.pair_sym_table[i_pivot].items():
      if j in self.constrained_site_indices: continue
      for op in ops:
        if (conformer_indices is None or
            conformer_indices[j] == 0 or
            constrained_site_conformer == 0 or
            (conformer_indices[j] == constrained_site_conformer)):
          s = reparametrisation.add_new_site_parameter(j, op)
          pivot_neighbour_site_params += (s,)
          pivot_neighbour_sites += (op*scatterers[j].site,)
          if (self.need_pivot_neighbour_substituents):
            for k, ops_k in reparametrisation.pair_sym_table[j].items():
              if k != i_pivot and scatterers[k].scattering_type != 'H':
                s = reparametrisation.add_new_site_parameter(k, ops_k[0])
                pivot_neighbour_substituent_site_params += (s,)

    length_value = self.bond_length
    if length_value is None:
      length_value = self.ideal_bond_length(scatterers[i_pivot],
                                            reparametrisation.temperature)
    if self.stretching:
      uc = reparametrisation.structure.unit_cell()
      _length_value = uc.distance(
        col(scatterers[i_pivot].site),
        col(scatterers[self.constrained_site_indices[0]].site))
      if _length_value > 0.5: #check for dummy values
        length_value = _length_value

    bond_length = reparametrisation.add(
      _.independent_scalar_parameter,
      value=length_value,
      variable=self.stretching)

    if not self.stretching:
      for i in self.constrained_site_indices:
        reparametrisation.fixed_distances.setdefault(
          (self.pivot, i), bond_length.value)

    hydrogens = tuple(
      [ scatterers[i_sc] for i_sc in self.constrained_site_indices ])

    param = self.add_hydrogen_to(
      reparametrisation=reparametrisation,
      bond_length=bond_length,
      pivot_site=pivot_site,
      pivot_neighbour_sites=pivot_neighbour_sites,
      pivot_site_param=pivot_site_param,
      pivot_neighbour_site_params=pivot_neighbour_site_params,
      pivot_neighbour_substituent_site_params=
        pivot_neighbour_substituent_site_params,
      hydrogens=hydrogens)
    for i_sc in self.constrained_site_indices:
      reparametrisation.asu_scatterer_parameters[i_sc].site = param

  def ideal_bond_length(self, pivot, temperature):
    pivot_element = pivot.scattering_type
    d = self.room_temperature_bond_length.get(pivot_element)
    if d is None:
      raise InvalidConstraint(
        "Invalid %s constraint involving %s:"
        " ideal bond length not defined to atom type %s" %(
          self.__class__.__name__, pivot.label, pivot_element))
    if temperature is not None:
      if   temperature < -70: d += 0.02
      elif temperature < -20: d += 0.01
    return d


class terminal_tetrahedral_xhn_site(hydrogens):

  def add_hydrogen_to(self, reparametrisation, bond_length,
                      pivot_site      , pivot_neighbour_sites,
                      pivot_site_param, pivot_neighbour_site_params,
                      hydrogens, **kwds):
    if len(pivot_neighbour_site_params) != 1:
      raise InvalidConstraint(_.bad_connectivity_msg %(
        self.__class__.__name__, pivot_site_param.scatterers[0].label))
    azimuth = reparametrisation.add(_.independent_scalar_parameter,
                                    value=0, variable=self.rotating)
    uc = reparametrisation.structure.unit_cell()
    for j, ops in reparametrisation.pair_sym_table[self.pivot].items():
      for k, ops in reparametrisation.pair_sym_table[self.pivot].items():
        if j == k: continue
        reparametrisation.fixed_angles.setdefault(
          (j, self.pivot, k), tetrahedral_angle)
    return reparametrisation.add(
      getattr(_, self.__class__.__name__),
      pivot=pivot_site_param,
      pivot_neighbour=pivot_neighbour_site_params[0],
      length=bond_length,
      azimuth=azimuth,
      e_zero_azimuth=uc.orthogonalize(
        col(hydrogens[0].site) - col(pivot_site)),
      hydrogen=hydrogens)


class terminal_tetrahedral_xh_site(terminal_tetrahedral_xhn_site):
  n_constrained_sites = 1
  room_temperature_bond_length = { 'O' : 0.82,
                                   'S' : 1.20,
                                   }

class terminal_tetrahedral_xh3_sites(terminal_tetrahedral_xhn_site):
  n_constrained_sites = 3
  room_temperature_bond_length = { 'C' : 0.96,
                                   'N' : 0.89,
                                   }


class tertiary_xh_site(hydrogens):

  n_constrained_sites = 1
  room_temperature_bond_length = { 'C' : 0.98,
                                   'N' : 0.91,
                                   'B' : 0.98,
                                   }

  def add_hydrogen_to(self, reparametrisation, bond_length,
                      pivot_site      , pivot_neighbour_sites,
                      pivot_site_param, pivot_neighbour_site_params,
                      hydrogens, **kwds):
    if len(pivot_neighbour_site_params) != 3:
      raise InvalidConstraint(_.bad_connectivity_msg %(
        self.__class__.__name__, pivot_site_param.scatterers[0].label))
    return reparametrisation.add(
      _.tertiary_xh_site,
      pivot=pivot_site_param,
      pivot_neighbour_0=pivot_neighbour_site_params[0],
      pivot_neighbour_1=pivot_neighbour_site_params[1],
      pivot_neighbour_2=pivot_neighbour_site_params[2],
      length=bond_length,
      hydrogen=hydrogens[0])


class secondary_xh2_sites(hydrogens):

  n_constrained_sites = 2
  room_temperature_bond_length = { 'C' : 0.97,
                                   'N' : 0.90,
                                   }

  def add_hydrogen_to(self, reparametrisation, bond_length,
                      pivot_site      , pivot_neighbour_sites,
                      pivot_site_param, pivot_neighbour_site_params,
                      hydrogens, **kwds):
    if len(pivot_neighbour_site_params) != 2:
      raise InvalidConstraint(_.bad_connectivity_msg %(
        self.__class__.__name__, pivot_site_param.scatterers[0].label))
    x_h = [ col(h.site) for h in hydrogens ]
    x_p = col(pivot_site)
    uc = reparametrisation.structure.unit_cell()
    theta = col(uc.orthogonalize(x_h[0] - x_p)).angle(
      col(uc.orthogonalize(x_h[1] - x_p)))
    angle_param = None
    if self.flapping:
      angle_param = reparametrisation.add(_.independent_scalar_parameter,
                                     value=theta,
                                     variable=True)
    else:
      if self.angle is not None:
        angle_param = reparametrisation.add(_.independent_scalar_parameter,
                                            value=self.angle,
                                            variable=False)
      else:
        angle_param = reparametrisation.add(_.angle_parameter,
                                            left=pivot_neighbour_site_params[0],
                                            center=pivot_site_param,
                                            right=pivot_neighbour_site_params[1],
                                            value=theta)
    return reparametrisation.add(
      _.secondary_xh2_sites,
      pivot=pivot_site_param,
      pivot_neighbour_0=pivot_neighbour_site_params[0],
      pivot_neighbour_1=pivot_neighbour_site_params[1],
      length=bond_length,
      h_c_h_angle=angle_param,
      hydrogen_0=hydrogens[0],
      hydrogen_1=hydrogens[1])


class secondary_planar_xh_site(hydrogens):

  n_constrained_sites = 1
  room_temperature_bond_length = { 'C' : 0.93,
                                   'N' : 0.86,
                                   }

  def add_hydrogen_to(self, reparametrisation, bond_length,
                      pivot_site      , pivot_neighbour_sites,
                      pivot_site_param, pivot_neighbour_site_params,
                      hydrogens, **kwds):
    # e.g. Carbon atoms in Cyclopentadienyl complexes will have
    #      3 pivot neighbours
    if len(pivot_neighbour_site_params) not in (2, 3):
      raise InvalidConstraint(_.bad_connectivity_msg %(
        self.__class__.__name__, pivot_site_param.scatterers[0].label))
    uc = reparametrisation.structure.unit_cell()
    x_s = col(pivot_site)
    d_s = sorted(
        (uc.distance(s, x_s), i)
        for i, s in enumerate(pivot_neighbour_sites)
    )
    return reparametrisation.add(
      _.secondary_planar_xh_site,
      pivot=pivot_site_param,
      pivot_neighbour_0=pivot_neighbour_site_params[d_s[0][1]],
      pivot_neighbour_1=pivot_neighbour_site_params[d_s[1][1]],
      length=bond_length,
      hydrogen=hydrogens[0])


class terminal_planar_xh2_sites(hydrogens):

  n_constrained_sites = 2
  need_pivot_neighbour_substituents = True

  room_temperature_bond_length = \
    secondary_planar_xh_site.room_temperature_bond_length

  def add_hydrogen_to(self, reparametrisation, bond_length,
                      pivot_site      , pivot_neighbour_sites,
                      pivot_site_param, pivot_neighbour_site_params,
                      pivot_neighbour_substituent_site_params,
                      hydrogens, **kwds):
    if len(pivot_neighbour_site_params) != 1:
      raise InvalidConstraint(_.bad_connectivity_msg %(
        self.__class__.__name__, pivot_site_param.scatterers[0].label))
    for j, ops in reparametrisation.pair_sym_table[self.pivot].items():
      for k, ops in reparametrisation.pair_sym_table[self.pivot].items():
        if j == k: continue
        reparametrisation.fixed_angles.setdefault(
          (j, self.pivot, k), 120.0)
    return reparametrisation.add(
      _.terminal_planar_xh2_sites,
      pivot=pivot_site_param,
      pivot_neighbour=pivot_neighbour_site_params[0],
      pivot_neighbour_substituent=pivot_neighbour_substituent_site_params[0],
      length=bond_length,
      hydrogen_0=hydrogens[0],
      hydrogen_1=hydrogens[1])


class terminal_linear_ch_site(hydrogens):

  n_constrained_sites = 1
  room_temperature_bond_length = { 'C' : 0.93,
                                   }

  def add_hydrogen_to(self, reparametrisation, bond_length,
                      pivot_site      , pivot_neighbour_sites,
                      pivot_site_param, pivot_neighbour_site_params,
                      hydrogens, **kwds):
    if len(pivot_neighbour_site_params) != 1:
      raise InvalidConstraint(_.bad_connectivity_msg %(
        self.__class__.__name__, pivot_site_param.scatterers[0].label))
    for j, ops in reparametrisation.pair_sym_table[self.pivot].items():
      for k, ops in reparametrisation.pair_sym_table[self.pivot].items():
        if j == k: continue
        reparametrisation.fixed_angles.setdefault(
          (j, self.pivot, k), 180.0)
    return reparametrisation.add(
      _.terminal_linear_ch_site,
      pivot=pivot_site_param,
      pivot_neighbour=pivot_neighbour_site_params[0],
      length=bond_length,
      hydrogen=hydrogens[0])


need_at_least_one_substituent_msg = (
  "Invalid %s constraint involving %s: "
  "pivot neighbour must have at least one non-H substituent")

class staggered_terminal_tetrahedral_xhn_sites(hydrogens):

  staggered = True
  need_pivot_neighbour_substituents = True
  stagger_on = None

  def add_hydrogen_to(self, reparametrisation, bond_length,
                      pivot_site      , pivot_neighbour_sites,
                      pivot_site_param, pivot_neighbour_site_params,
                      pivot_neighbour_substituent_site_params,
                      hydrogens, **kwds):
    if len(pivot_neighbour_site_params) != 1:
      raise InvalidConstraint(_.bad_connectivity_msg %(
        self.__class__.__name__, pivot_site_param.scatterers[0].label))
    if not len(pivot_neighbour_substituent_site_params):
      raise InvalidConstraint(need_at_least_one_substituent_msg %(
        self.__class__.__name__, pivot_site_param.scatterers[0].label))
    if self.stagger_on is None:
      if len(pivot_neighbour_substituent_site_params) == 1:
        stagger_on = pivot_neighbour_substituent_site_params[0]
      else:
        # staggered with respect to the shortest
        # pivot_neighbour - pivot_neighbour_substituent bond
        #
        # If the two bond lengths are similar, then the hydrogen could have a
        # tendancy to flip between the positions. If this is the case, a
        # staggered hydrogen constraint is probably unsuitable, and a freely
        # rotatable constraint could be used.
        #
        uc = reparametrisation.structure.unit_cell()
        x_s = col(pivot_neighbour_sites[0])
        d_s = sorted((uc.distance(s.value, x_s), i)
            for i, s in enumerate(pivot_neighbour_substituent_site_params))
        stagger_on = pivot_neighbour_substituent_site_params[d_s[0][1]]
    else:
      for p in pivot_neighbour_substituent_site_params:
        if p.index == self.stagger_on:
          stagger_on = p
          break
      # The stagger_on atom must be one of the pivot_neighbour_substituents.
      # If we reach here, this is not the case so an error is raised.
      raise InvalidConstraint(_.bad_connectivity_msg %(
        self.__class__.__name__, pivot_site_param.scatterers[0].label))
    for j, ops in reparametrisation.pair_sym_table[self.pivot].items():
      for k, ops in reparametrisation.pair_sym_table[self.pivot].items():
        if j == k: continue
        reparametrisation.fixed_angles.setdefault(
          (j, self.pivot, k), tetrahedral_angle)
    return reparametrisation.add(
      getattr(_, self.__class__.__name__),
      pivot=pivot_site_param,
      pivot_neighbour=pivot_neighbour_site_params[0],
      length=bond_length,
      stagger_on=stagger_on,
      hydrogen=hydrogens)

class staggered_terminal_tetrahedral_xh3_sites(
  staggered_terminal_tetrahedral_xhn_sites):

  n_constrained_sites = 3
  room_temperature_bond_length = \
    terminal_tetrahedral_xh3_sites.room_temperature_bond_length

class staggered_terminal_tetrahedral_xh_site(
  staggered_terminal_tetrahedral_xhn_sites):

  n_constrained_sites = 1
  room_temperature_bond_length = \
    terminal_tetrahedral_xh_site.room_temperature_bond_length

class polyhedral_bh_site(hydrogens):

  n_constrained_sites = 5
  room_temperature_bond_length = { 'B': 1.10,
                                   'C': 1.10, }

  def add_hydrogen_to(self, reparametrisation, bond_length,
                      pivot_site, pivot_neighbour_sites,
                      pivot_site_param, pivot_neighbour_site_params,
                      hydrogens, **kwds):
    if len(pivot_neighbour_site_params) != 4 and\
       len(pivot_neighbour_site_params) != 5:
      raise InvalidConstraint(_.bad_connectivity_msg %(
        self.__class__.__name__, pivot_site_param.scatterers[0].label))
    return reparametrisation.add(
      _.polyhedral_bh_site,
      pivot=pivot_site_param,
      pivot_neighbours=pivot_neighbour_site_params,
      length=bond_length,
      hydrogen=hydrogens[0])


 *******************************************************************************


 *******************************************************************************
smtbx/refinement/constraints/occupancy.py
from __future__ import absolute_import, division, print_function
import smtbx.refinement.constraints as _
from smtbx.refinement.constraints import InvalidConstraint
from scitbx.array_family import flex
import itertools
from six.moves import range

class occupancy_affine_constraint(object):
  """ Constraint a0 occ0 + a1 occ1 +... == b """

  def __init__(self, scatterer_indices, a, b):
    self.a = []
    self.scatterer_indices = []
    for i in range(len(a)):
      if(a[i]!=0.0):
        self.a += [a[i]]
        self.scatterer_indices += [scatterer_indices[i]]
    self.a = flex.double(self.a)
    self.b = b

  @property
  def constrained_parameters(self):
    return ((self.scatterer_indices[0], 'occupancy'),)

  def add_to(self, reparametrisation):
    sc = reparametrisation.structure.scatterers()
    dependees = [reparametrisation.add_new_occupancy_parameter(i)\
      for i in self.scatterer_indices[1:]]
    sidx = self.scatterer_indices[0]
    param = reparametrisation.add(_.affine_asu_occupancy_parameter,
                                  dependees=dependees, a=-1.0*self.a[1:]/(self.a[0]), b=self.b/(self.a[0]),
                                  scatterer=sc[sidx])
    reparametrisation.asu_scatterer_parameters[sidx].occupancy = param
    for idx,i in enumerate(self.scatterer_indices[1:]):
      reparametrisation.shared_occupancies[i] = dependees[idx]
    self.value = param

class occupancy_pair_affine_constraint(object):
  """ Constraint a0 occ0 + a1 occ1 == b """

  def __init__(self, scatterer_indices, linear_form):
    self.scatterer_indices = scatterer_indices
    self.linear_form = linear_form

  @property
  def constrained_parameters(self):
    return ((self.scatterer_indices[1], 'occupancy'),)

  def add_to(self, reparametrisation):
    sc = reparametrisation.structure.scatterers()
    (a0, a1), b = self.linear_form
    i0, i1 = self.scatterer_indices
    occ0 = reparametrisation.add_new_occupancy_parameter(i0)
    param = reparametrisation.add(_.affine_asu_occupancy_parameter,
                                  dependee=occ0, a=-a0/a1, b=b/a1,
                                  scatterer=sc[i1])
    reparametrisation.asu_scatterer_parameters[i1].occupancy = param
    reparametrisation.shared_occupancies[i1] = occ0


class dependent_occupancy(object):
  """ occupancy of a site depend on the occupancy of the other site
  """

  def __init__(self, var_refs, var_minus_one_refs):
    if (len(var_refs) + len(var_minus_one_refs)) == 0:
      raise InvalidConstraint("at least one atom is expected")
    self.as_var = var_refs
    self.as_one_minus_var = var_minus_one_refs

  @property
  def constrained_parameters(self):
    return tuple((sc[0], 'occupancy')
               for sc in itertools.chain(self.as_var, self.as_one_minus_var))

  def add_to(self, reparametrisation):
    scatterers = reparametrisation.structure.scatterers()
    if len(self.as_var) != 0:
      sc_idx = self.as_var[0][0]
      original_mult = self.as_var[0][1]
    else:
      sc_idx = self.as_one_minus_var[0][0]
      original_mult = self.as_one_minus_var[0][1]
    occupancy = reparametrisation.add_new_occupancy_parameter(sc_idx)
    for sc in self.as_var:
      if sc[0] == sc_idx:  continue
      param = reparametrisation.add(
        _.dependent_occupancy,
        occupancy = occupancy,
        original_multiplier = original_mult,
        multiplier = sc[1],
        as_one = True,
        scatterer = reparametrisation.structure.scatterers()[sc[0]])
      reparametrisation.asu_scatterer_parameters[sc[0]].occupancy = param
      reparametrisation.shared_occupancies[sc[0]] = occupancy
    as_one = len(self.as_var) == 0  # only if both lists are not empty
    for sc in self.as_one_minus_var:
      if sc[0] == sc_idx:  continue
      param = reparametrisation.add(
        _.dependent_occupancy,
        occupancy = occupancy,
        original_multiplier = original_mult,
        multiplier = sc[1],
        as_one = as_one,
        scatterer = reparametrisation.structure.scatterers()[sc[0]])
      reparametrisation.asu_scatterer_parameters[sc[0]].occupancy = param
      reparametrisation.shared_occupancies[sc[0]] = occupancy
    self.value = occupancy


 *******************************************************************************


 *******************************************************************************
smtbx/refinement/constraints/rigid.py
from __future__ import absolute_import, division, print_function
import smtbx.refinement.constraints as _
from smtbx.refinement.constraints import InvalidConstraint
import math
from scitbx.math import superpose
from scitbx import matrix
from scitbx.array_family import flex
import itertools
from six.moves import range

class rigid_pivoted_rotatable_group(object):
  """ a set of atoms (rigid body) rides on a pivot atom and rotates around
  the pivot-pivot_neighbour bond, the original geometry is not altered
  """

  def __init__(self, pivot, pivot_neighbour, ind_sequence, sizeable, rotatable):
    if len(ind_sequence) == 0:
      raise InvalidConstraint("at least one atom is expected")
    self.pivot = pivot
    self.pivot_neighbour = pivot_neighbour
    self.indices = ind_sequence
    self.sizeable = sizeable
    self.rotatable = rotatable

  @property
  def constrained_parameters(self):
    return tuple((idx, 'site') for idx in self.indices)

  def add_to(self, reparametrisation):
    scatterers = reparametrisation.structure.scatterers()
    pivot_sp = reparametrisation.add_new_site_parameter(self.pivot)
    pivot_n_sp = reparametrisation.add_new_site_parameter(self.pivot_neighbour)
    azimuth = reparametrisation.add(_.independent_scalar_parameter,
                                    value=0, variable=self.rotatable)
    size = reparametrisation.add(_.independent_scalar_parameter,
                                    value=1, variable=self.sizeable)
    scatterers = tuple([scatterers[i] for i in self.indices])
    param = reparametrisation.add(
      _.rigid_pivoted_rotatable_group,
      pivot=pivot_sp,
      pivot_neighbour=pivot_n_sp,
      azimuth=azimuth,
      size=size,
      scatterers=scatterers)
    for i, j in enumerate(self.indices):
      reparametrisation.add_new_site_proxy_parameter(param, i, j)
      reparametrisation.asu_scatterer_parameters[j].site = param

class rigid_rotatable_expandable_group(object):
  """ a set of atoms rides on a pivot atom, rotates and uniformly
  expands or contracts
  """

  def __init__(self, center, ind_sequence, sizeable, rotatable):
    if len(ind_sequence) == 0:
      raise InvalidConstraint("at least one atom is expected")
    self.pivot = center
    self.indices = ind_sequence
    self.sizeable = sizeable
    self.rotatable = rotatable

  @property
  def constrained_parameters(self):
    return tuple((idx, 'site') for idx in self.indices)

  def add_to(self, reparametrisation):
    scatterers = reparametrisation.structure.scatterers()
    pivot_sp = reparametrisation.add_new_site_parameter(self.pivot)
    size = reparametrisation.add(_.independent_scalar_parameter,
                                    value=1, variable=self.sizeable)
    alpha = reparametrisation.add(_.independent_scalar_parameter,
                                    value=0, variable=self.rotatable)
    beta = reparametrisation.add(_.independent_scalar_parameter,
                                    value=0, variable=self.rotatable)
    gamma = reparametrisation.add(_.independent_scalar_parameter,
                                    value=0, variable=self.rotatable)
    scatterers = tuple([scatterers[i] for i in self.indices])
    param = reparametrisation.add(
      _.rigid_rotatable_expandable_group,
      pivot=pivot_sp,
      size=size,
      alpha=alpha,
      beta=beta,
      gamma=gamma,
      scatterers = scatterers)
    for i, j in enumerate(self.indices):
      reparametrisation.add_new_site_proxy_parameter(param, i, j)
      reparametrisation.asu_scatterer_parameters[j].site = param


class rigid_riding_expandable_group(object):
  """ a set of atoms rides on a pivot atom, rotates and uniformly
  expands or shrinks
  """

  def __init__(self, center, ind_sequence, sizeable):
    if len(ind_sequence) == 0:
      raise InvalidConstraint("at least one atom is expected")
    self.pivot = center
    self.indices = ind_sequence
    self.sizeable = sizeable

  @property
  def constrained_parameters(self):
    return tuple((idx, 'site') for idx in self.indices)

  def add_to(self, reparametrisation):
    scatterers = reparametrisation.structure.scatterers()
    pivot_sp = reparametrisation.add_new_site_parameter(self.pivot)
    size = reparametrisation.add(_.independent_scalar_parameter,
                                    value=1, variable=self.sizeable)
    scatterers = tuple([scatterers[i] for i in self.indices])
    param = reparametrisation.add(
      _.rigid_riding_expandable_group,
      pivot=pivot_sp,
      size=size,
      scatterers = scatterers)
    for i, j in enumerate(self.indices):
      reparametrisation.add_new_site_proxy_parameter(param, i, j)
      reparametrisation.asu_scatterer_parameters[j].site = param

class idealised_fragment(object):
  """ ported from olex2 xlib/fragment.h
  generates parameterised coordinates for four framents:
  Cp, Ph, Cp* and naphthalene
  """
  def __init__(self):
    self.default_lengths = {
      "Cp"  : (1.42,),
      "Cp*" : (1.42, 1.063),
      "Ph"  : (1.39,),
      "Naphthalene" : (1.39,)
      }
  class point:  #helper class
    def __init__(self, x, y):
      self.x = x
      self.y = y
    def __mul__(self, k):
      return idealised_fragment.point(self.x*k, self.y*k)
    def __add__(self, p):
      return idealised_fragment.point(self.x+p.x, self.y+p.y)
    def length(self):
      return math.sqrt(self.x*self.x+self.y*self.y)
    def __repr__(self):
      return "(" + str(self.x) + "," + str(self.y) + ")"

  def generate_ring(self, edges, r):
    """ generates coordinates of a ring with given radius
    """
    angle = math.pi*2/edges
    ca = math.cos(angle)
    sa = math.sin(angle)
    result = []
    p = idealised_fragment.point(ca, -sa)
    for i in range(0, edges):
      result.append(p*r)
      x = p.x
      p.x = ca*x + sa*p.y
      p.y = ca*p.y - sa*x
    return result

  def generate_fragment(self, fragment, lengths=None):
    """ generates given fragment with given/default bond lengths
    returns a list of idealised_fragment.point, having x and y
    attributes
    """
    if lengths == None:
      lengths = self.default_lengths[fragment]
    if fragment == "Cp":
      return self.generate_ring(5, 0.5*lengths[0]/math.cos(54*math.pi/180))
    if fragment == "Ph":
      return self.generate_ring(6, lengths[0])
    if fragment == "Cp*":
      r = 0.5*lengths[0]/math.cos(54*math.pi/180)
      res = self.generate_ring(5, r)
      for i in self.generate_ring(5, r+lengths[1]):
        res.append(i)
      return res
    if fragment == "Naphthalene":
      res = self.generate_ring(6, lengths[0])
      res.append(res[0])
      for i in range(3,6):  res.append(res[i]);
      p = res[4]+res[5]
      p = p * (lengths[0]*2*math.cos(math.pi/6)/p.length())
      for i in range(6, len(res)):
        res[i] = res[i] + p
      p = res[7]
      res[7] = res[9]
      res[9] = p
      return res

  def fit(self, fragment, reference_sites, control_point_indices=None):
    """ fits given fragment to given sites, if control_points indices
    are not given - all points are fit, otherwise only control points
    are fit and the result is propagated to the rest of the fragment
    coordinates. returns coordinates of the trasformed fragment
    """
    if not control_point_indices:
      control_point_indices = range(0, len(fragment))
    to_fit = [
      (fragment[i].x, fragment[i].y, 0) for i in control_point_indices]
    lsf = superpose.least_squares_fit(
      flex.vec3_double(reference_sites), flex.vec3_double(to_fit))
    to_fit = flex.vec3_double([(i.x, i.y, 0) for i in fragment])
    return lsf.r.elems * to_fit + lsf.t.elems


class same_group(object):
  """ non-crystallographic symmetry constraint
  """

  def __init__(self, groups, angles=(0,0,0), fix_xyz=True, fix_u=True):
    """ fix_xyz and fix_u are to be used for debugging purposes only:
    if the coordinates are not fixed, then the refined angles should
    be stored externally and passed to this object
    """
    if len(groups) < 2:
      raise InvalidConstraint("at least two atom sets are expected")
    l = len(groups[0])
    for g in groups[1:]:
      if len(g) != l:
        raise InvalidConstraint("atoms sets differ in size")
    self.groups = groups
    self.fix_xyz = fix_xyz
    self.fix_u = fix_u
    self.angles = angles

  @property
  def constrained_parameters(self):
    result = ()
    for g in itertools.islice(self.groups, 1):
      for i in g:
        if self.fix_xyz:
          result += ((i, 'site'),)
        if self.fix_u:
          result += ((i, 'U'),)
    return result

  def add_to(self, reparametrisation):
    if not self.fix_u and not self.fix_xyz:
      return
    scatterers = reparametrisation.structure.scatterers()
    ref_sites = []
    ref_u_isos = []
    ref_u_stars = []
    ref_adps = []
    src_crds = []
    inv_src_crds = []
    uc = reparametrisation.structure.unit_cell()
    for i in self.groups[0]:
      src_crds.append(uc.orthogonalize(scatterers[i].site))
      if self.fix_xyz:
        ref_sites.append(reparametrisation.add_new_site_parameter(i))
      if self.fix_u:
        if scatterers[i].flags.use_u_iso():
          ref_u_isos.append(
            reparametrisation.add_new_thermal_displacement_parameter(i))
        else:
          ref_u_stars.append(
            reparametrisation.add_new_thermal_displacement_parameter(i))
    for g in self.groups[1:]:
      if len(g) != len(self.groups[0]):
        raise InvalidConstraint("Group size mismatch")
      g_scatterers = []
      g_u_iso_scatterers  =[]
      g_u_star_scatterers = []
      crds = []
      for idx, i in enumerate(g):
        if scatterers[i].flags.use_u_iso() !=\
           scatterers[self.groups[0][idx]].flags.use_u_iso():
          raise InvalidConstraint("Mixing isotropic and anisotropic parameters")
        g_scatterers.append(scatterers[i])
        crds.append(uc.orthogonalize(scatterers[i].site))
        if scatterers[i].flags.use_u_iso():
          g_u_iso_scatterers.append(scatterers[i])
        else:
          g_u_star_scatterers.append(scatterers[i])
      #need to map reference to target
      lsf = superpose.least_squares_fit(
        flex.vec3_double(crds), flex.vec3_double(src_crds))
      #create a list of inverted coordinates if needed
      if len(inv_src_crds) == 0:
        for i in range(0, len(g)):
          inv_src_crds.append(
            2*matrix.col(lsf.other_shift)-matrix.col(src_crds[i]))
      rm = lsf.r
      t = matrix.col(lsf.reference_shift)-matrix.col(lsf.other_shift)
      new_crd = lsf.other_sites_best_fit()
      d = 0
      for i, c in enumerate(new_crd):
        d += matrix.col(matrix.col(c)-matrix.col(crds[i])).length_sq()
      lsf = superpose.least_squares_fit(
        flex.vec3_double(crds), flex.vec3_double(inv_src_crds))
      new_crd = lsf.other_sites_best_fit()
      d_inv = 0
      for i, c in enumerate(new_crd):
        d_inv += matrix.col(matrix.col(c)-matrix.col(crds[i])).length_sq()
      if d_inv < d:
        rm = -lsf.r
      if self.fix_xyz:
        shifts_and_angles =\
          reparametrisation.add(_.independent_small_6_vector_parameter,
                                value=(t[0],t[1],t[2],0,0,0), variable=True)
        if len(ref_u_stars) > 0:
          u_star_param = reparametrisation.add(
            _.same_group_u_star,
            scatterers=g_u_star_scatterers,
            u_stars=ref_u_stars,
            alignment_matrix=rm,
            shifts_and_angles=shifts_and_angles
          )
      elif len(ref_u_stars) > 0:
        angles =\
          reparametrisation.add(_.independent_small_3_vector_parameter,
                                value=self.angles, variable=True)
        u_star_param = reparametrisation.add(
          _.same_group_u_star,
          scatterers=g_u_star_scatterers,
          u_stars=ref_u_stars,
          alignment_matrix=rm,
          angles=angles
        )
      if self.fix_xyz:
        site_param = reparametrisation.add(
          _.same_group_xyz,
          scatterers=g_scatterers,
          sites=ref_sites,
          alignment_matrix=rm,
          shifts_and_angles=shifts_and_angles
        )
      if len(ref_u_isos) > 0:
        u_iso_param = reparametrisation.add(
          _.same_group_u_iso,
          scatterers=g_u_iso_scatterers,
          u_isos=ref_u_isos
        )
      site_proxy_index = 0
      u_star_proxy_index = 0
      u_iso_proxy_index = 0
      for i in g:
        if self.fix_xyz:
          reparametrisation.asu_scatterer_parameters[i].site = site_param
          reparametrisation.add_new_same_group_site_proxy_parameter(
            site_param, site_proxy_index, i)
          site_proxy_index += 1
        if self.fix_u:
          if scatterers[i].flags.use_u_iso():
            reparametrisation.asu_scatterer_parameters[i].u = u_iso_param
            reparametrisation.shared_Us[i] = reparametrisation.add(
              _.same_group_u_iso_proxy,
              parent=u_iso_param,
              index=u_iso_proxy_index
              )
            u_iso_proxy_index += 1
          else:
            reparametrisation.asu_scatterer_parameters[i].u = u_star_param
            reparametrisation.shared_Us[i] = reparametrisation.add(
              _.same_group_u_star_proxy,
              parent=u_star_param,
              index=u_star_proxy_index
              )
            u_star_proxy_index += 1


 *******************************************************************************


 *******************************************************************************
smtbx/refinement/constraints/site.py
from __future__ import absolute_import, division, print_function
import smtbx.refinement.constraints as _
from six.moves import range

class shared_site(object):
  """ a site shared by two or more scatterers
  """

  def __init__(self, ind_sequence):
    if len(ind_sequence) < 2:
      raise InvalidConstraint("at least two atoms are expected")
    self.indices = ind_sequence

  @property
  def constrained_parameters(self):
    return tuple((idx, 'site') for idx in self.indices[1:])

  def add_to(self, reparametrisation):
    scatterers = reparametrisation.structure.scatterers()
    site = reparametrisation.add_new_site_parameter(self.indices[0])
    for i in range(1, len(self.indices)):
      param = reparametrisation.add(
        _.shared_site,
        reference=site,
        scatterer = reparametrisation.structure.scatterers()[
          self.indices[i]])
      reparametrisation.asu_scatterer_parameters[self.indices[i]].site = param
      reparametrisation.shared_sites[self.indices[i]] = site



 *******************************************************************************


 *******************************************************************************
smtbx/refinement/constraints/tests/__init__.py


 *******************************************************************************


 *******************************************************************************
smtbx/refinement/constraints/tests/tst_constrained_structure.py
from __future__ import absolute_import, division, print_function
from operator import itemgetter
from cctbx import crystal, xray
from cctbx.array_family import flex
from smtbx.refinement import constraints
import smtbx.refinement.constraints.all as _
import smtbx.refinement.constraints as core
import smtbx.utils
from smtbx.refinement import least_squares
from smtbx import development
from scitbx.lstbx import normal_eqns_solving
from scitbx import matrix
from six.moves import zip
from smtbx.refinement.constraints import fpfdp
from libtbx.test_utils import approx_equal


class test_case(object):

  expected_reparametrisation_for_hydrogen_named = None
  expected_mapping_to_grad_fc = None
  refinement_config = "default"

  def __init__(self, normal_eqns_solving_method):
    self.normal_eqns_solving_method = normal_eqns_solving_method

  def check_reparametrisation_construction(self):
    warned_once = False
    for sc, params in zip(
      self.reparametrisation.structure.scatterers(),
      self.reparametrisation.asu_scatterer_parameters
      ):
      if sc.scattering_type != 'H':
        assert (
          (isinstance(params.site, core.independent_site_parameter)
           and
           isinstance(params.u, core.independent_u_star_parameter)
           )
          or
          (isinstance(params.site, core.special_position_site_parameter)
           and
           isinstance(params.u, core.special_position_u_star_parameter))
          )
        assert params.site.scatterers[0].label == sc.label
        assert params.u.scatterers[0].label == sc.label
        assert isinstance(params.occupancy,
                          core.independent_occupancy_parameter)
        assert params.occupancy.scatterers[0].label == sc.label
      else:
        try:
          (expected_type, expected_pivot) = \
           self.expected_reparametrisation_for_hydrogen_named[sc.label]
          assert isinstance(params.site, expected_type), \
                 (sc.label, params.site, expected_type)
          assert ([ sc1.label for sc1 in params.site.argument(0).scatterers ]
                  == [expected_pivot]), sc.label
        except KeyError:
          if not warned_once:
            print("Warning: incomplete test coverage for H constraint types")
            warned_once = True
            continue
    self.check_reparametrisation_construction_more()

  def check_reparametrisation_construction_more(self):
    """ To be overriden by heirs that needs to perform extra tests """

  def check_mapping_to_grad_fc(self):
    if self.expected_mapping_to_grad_fc is not None:
      assert (tuple(self.reparametrisation.mapping_to_grad_fc)
              == self.expected_mapping_to_grad_fc)
    else:
      print("No mapping to grad Fc test")


  def check_refinement_stability(self):
    if not self.shall_refine_thermal_displacements:
      for sc in self.xray_structure.scatterers():
        sc.flags.set_grad_site(True)
        if sc.flags.use_u_aniso(): sc.flags.set_grad_u_aniso(False)
        if sc.flags.use_u_iso(): sc.flags.set_grad_u_iso(False)

    xs = self.xray_structure
    xs0 = self.reference_xray_structure = xs.deep_copy_scatterers()
    mi = xs0.build_miller_set(anomalous_flag=False, d_min=0.5)
    fo_sq = mi.structure_factors_from_scatterers(
      xs0, algorithm="direct").f_calc().norm()
    fo_sq = fo_sq.customized_copy(sigmas=flex.double(fo_sq.size(), 1))

    xs.shake_sites_in_place(rms_difference=0.1)
    if self.shall_refine_thermal_displacements:
      # a spread of 10 for u_iso's would be enormous for our low temperature
      # test structures if those u_iso's were not constrained
      xs.shake_adp(spread=10, # absolute
                   aniso_spread=0.2) # relative

    self.reparametrisation = constraints.reparametrisation(
      xs, self.constraints, self.connectivity_table,
      temperature=self.t_celsius)
    obs = fo_sq.as_xray_observations()
    ls = least_squares.crystallographic_ls(
      obs,
      self.reparametrisation,
      weighting_scheme=least_squares.mainstream_shelx_weighting())
    self.cycles = self.normal_eqns_solving_method(ls)
    print ("%i %s iterations to recover from shaking"
           % (self.cycles.n_iterations,
              self.cycles))
    if 0:
      from crys3d.qttbx.xray_structure_viewer import display
      display(xray_structure=xs)

    diff = xray.meaningful_site_cart_differences(xs0, xs)
    assert diff.max_absolute() < self.site_refinement_tolerance,\
           self.__class__.__name__

    if self.shall_refine_thermal_displacements:
      delta_u = []
      for sc, sc0 in zip(xs.scatterers(), xs0.scatterers()):
        if not sc.flags.use_u_aniso() or not sc0.flags.use_u_aniso(): continue
        delta_u.extend(matrix.col(sc.u_star) - matrix.col(sc0.u_star))
      delta_u = flex.double(delta_u)

      assert flex.max_absolute(delta_u) < self.u_star_refinement_tolerance,\
             self.__class__.__name__


  def display_structure(self):
    from crys3d.qttbx.xray_structure_viewer import display
    display(xray_structure=self.xray_structure)

  def run(self):
    print("[ %s ]" % self.__class__.__name__)
    self.connectivity_table = smtbx.utils.connectivity_table(
      self.xray_structure)
    if self.refinement_config == "default":
      for sc in self.xray_structure.scatterers():
        sc.flags.set_grad_site(True)
        if sc.flags.use_u_aniso(): sc.flags.set_grad_u_aniso(True)
        if sc.flags.use_u_iso(): sc.flags.set_grad_u_iso(True)
    elif self.refinement_config == "fpfdp":
      self.xray_structure.set_inelastic_form_factors(1.54184, 'sasaki')
      for sc in self.xray_structure.scatterers():
        sc.flags.set_grad_site(False)
        sc.flags.set_grad_u_iso(False)
        sc.flags.set_grad_u_aniso(False)
        sc.flags.set_grad_occupancy(False)
        if sc.element_symbol()=='O':
          sc.flags.set_use_fp_fdp(True)
          sc.flags.set_grad_fp(True)
          sc.flags.set_grad_fdp(True)
    elif self.refinement_config == "adp":
      for sc in self.xray_structure.scatterers():
        sc.flags.set_grad_site(False)
        if sc.flags.use_u_aniso(): sc.flags.set_grad_u_aniso(True)
        if sc.flags.use_u_iso(): sc.flags.set_grad_u_iso(True)


    self.reparametrisation = constraints.reparametrisation(
      self.xray_structure,
      self.constraints,
      self.connectivity_table,
      temperature=self.t_celsius,
    )

    self.check_reparametrisation_construction()
    self.check_mapping_to_grad_fc()

    # above settings are customised in the following tests
    # n.b. the fp,fdp tests override the default check_refinement_stability
    self.check_refinement_stability()

class scalar_scaled_adp_test_case(test_case):

  refinement_config = "adp"

  def __init__(self, m):
    test_case.__init__(self, m)
    self.xray_structure = development.sucrose()
    self.t_celsius = 20
    self.shall_refine_thermal_displacements = True
    self.constraints = [
        _.scalar_scaled_u(range(len(self.xray_structure.scatterers())))
        ]
    self.expected_reparametrisation_for_hydrogen_named = {}
    xs = self.xray_structure

    # Make one O atom isotropic to exercise scalar_scaled_u_iso on a non-H atom
    sc1 = xs.scatterers()[1]
    sc1.u_iso = sc1.u_iso_or_equiv(xs.unit_cell())
    sc1.set_use_u_iso_only()
    self.expected_mapping_to_grad_fc = tuple(range(271, 271+155)) # There are
    # 155 adp params: 12 aniso C, 22 isot H, 10 aniso O, 1 isot O

  def check_reparametrisation_construction(self):
    for sc, params in zip(
      self.reparametrisation.structure.scatterers(),
      self.reparametrisation.asu_scatterer_parameters
      ):
      if sc.scattering_type != 'H':
        assert (
            isinstance(params.site, core.independent_site_parameter)
            or
            isinstance(params.site, core.special_position_u_star_parameter)
            )
        if sc.flags.use_u_iso():
          assert isinstance(params.u, core.scalar_scaled_u_iso)
        else:
          assert sc.flags.use_u_aniso()
          assert isinstance(params.u, core.scalar_scaled_u_star)
        assert params.site.scatterers[0].label == sc.label
        assert params.u.scatterers[0].label == sc.label
        assert isinstance(params.occupancy,
                          core.independent_occupancy_parameter)
        assert params.occupancy.scatterers[0].label == sc.label
      else:
        assert isinstance(params.u, core.scalar_scaled_u_iso)
    self.check_reparametrisation_construction_more()

  def check_refinement_stability(self):
    xs = self.xray_structure
    xs0 = self.reference_xray_structure = xs.deep_copy_scatterers()

    # First we construct the Fo array
    mi = xs0.build_miller_set(anomalous_flag=True, d_min=0.5)
    fo_sq = mi.structure_factors_from_scatterers(
        xs0, algorithm="direct").f_calc().norm()
    fo_sq = fo_sq.customized_copy(sigmas=flex.double(fo_sq.size(), 1))

    # Then shake adps and store the shaken adp components
    self.shake_selection = flex.bool([
        sc.element_symbol() in ['C', 'O']
        for sc in xs.scatterers()
        ])
    xs.shake_adp(selection=self.shake_selection)
    adp_ref = []
    for sc in xs.scatterers():
      if sc.flags.use_u_aniso():
        adp_ref.extend(sc.u_star)
      else:
        adp_ref.append(sc.u_iso)

    # Then do the refinement
    self.reparametrisation = constraints.reparametrisation(
      xs, self.constraints, self.connectivity_table,
      temperature=self.t_celsius)
    self.obs = fo_sq.as_xray_observations()
    ls = least_squares.crystallographic_ls(
      self.obs,
      self.reparametrisation,
      weighting_scheme=least_squares.mainstream_shelx_weighting())
    self.cycles = self.normal_eqns_solving_method(ls)
    print ("%i %s iterations to recover from shaking"
           % (self.cycles.n_iterations,
              self.cycles))

    # Then verify the final ADPs have all changed by the same amount
    adp_final = []
    for sc in xs.scatterers():
      if sc.flags.use_u_aniso():
        adp_final.extend(sc.u_star)
      else:
        adp_final.append(sc.u_iso)
    adp_ratios = [x/y for x,y in zip(adp_ref, adp_final) if x>1e-6 and y>1e-6]
    assert all(
        [approx_equal(x, adp_ratios[0], eps=1e-9) for x in adp_ratios[1:]]
    )

    #Make sure the ADPs have changed by some non-zero amount
    assert adp_ratios[0] > 1.01 or adp_ratios[0] < 0.99


class fpfdp_test_case(test_case):

  refinement_config = "fpfdp"

  def __init__(self, m):
    test_case.__init__(self, m)
    self.xray_structure = development.sucrose()

    self.t_celsius = 20
    self.shall_refine_thermal_displacements = False
    self.constraints = []

    self.expected_mapping_to_grad_fc = (
        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,
        20, 21 # that was easy
        )
    self.expected_reparametrisation_for_hydrogen_named = {}

    self.fp_refinement_tolerance = 1e-6
    self.fdp_refinement_tolerance = 1e-6


  def check_refinement_stability(self):
    xs = self.xray_structure
    xs0 = self.reference_xray_structure = xs.deep_copy_scatterers()
    mi = xs0.build_miller_set(anomalous_flag=True, d_min=0.5)
    fo_sq = mi.structure_factors_from_scatterers(
      xs0, algorithm="direct").f_calc().norm()
    fo_sq = fo_sq.customized_copy(sigmas=flex.double(fo_sq.size(), 1))

    self.shake_selection = flex.bool([
        True if sc.element_symbol()=='O' else False
        for sc
        in self.xray_structure.scatterers()
        ])
    xs.shake_fps(selection=self.shake_selection)
    xs.shake_fdps(selection=self.shake_selection)

    self.reparametrisation = constraints.reparametrisation(
      xs, self.constraints, self.connectivity_table,
      temperature=self.t_celsius)
    self.obs = fo_sq.as_xray_observations()
    ls = least_squares.crystallographic_ls(
      self.obs,
      self.reparametrisation,
      weighting_scheme=least_squares.mainstream_shelx_weighting())
    self.cycles = self.normal_eqns_solving_method(ls)
    print ("%i %s iterations to recover from shaking"
           % (self.cycles.n_iterations,
              self.cycles))

    delta_fp = flex.double([
      sc.fp - sc0.fp
      for sc, sc0
      in zip(xs.scatterers(), xs0.scatterers())
      ])

    delta_fdp = flex.double([
      sc.fdp - sc0.fdp
      for sc, sc0
      in zip(xs.scatterers(), xs0.scatterers())
      ])

    assert flex.max_absolute(delta_fp) < self.fp_refinement_tolerance,\
           self.__class__.__name__

    assert flex.max_absolute(delta_fdp) < self.fdp_refinement_tolerance,\
           self.__class__.__name__


class constrained_fpfdp_test_case(fpfdp_test_case):

  def __init__(self, m):
    fpfdp_test_case.__init__(self, m)
    self.constraints = [
        fpfdp.shared_fp([0,1,3,5,7,9,10,12,14,16,18]),
        fpfdp.shared_fdp([0,1,3,5,7,9,10,12,14,16,18]),
        ]
    self.expected_mapping_to_grad_fc = (
        0, 1, 410, 420, 411, 421, 412, 422, 413, 423, 414, 424, 415, 425, 416,
        426, 417, 427, 418, 428, 419, 429
        )

  def check_reparametrisation_construction_more(self):
    assert self.reparametrisation.n_independents==2

  def check_refinement_stability(self):
    """Shake the fps and fdps, then refine, then make sure they are all equal
    within a very small tolerance.
    """
    fpfdp_test_case.check_refinement_stability(self)
    oxygen_fps = [
        sc.fp for sc in self.xray_structure.scatterers()
        if sc.element_symbol()=='O'
        ]
    oxygen_fdps = [
        sc.fdp for sc in self.xray_structure.scatterers()
        if sc.element_symbol()=='O'
        ]
    assert len([
      x for x in oxygen_fps
      if approx_equal(x, oxygen_fps[0], eps=1e-9, multiplier=None)
      ]) == len(oxygen_fps)
    assert len([
      x for x in oxygen_fdps
      if approx_equal(x, oxygen_fdps[0], eps=1e-9, multiplier=None)
      ]) == len(oxygen_fdps)


class sucrose_test_case(test_case):
  """
  sucrose from Olex 2 samples

  Notes:
  - atom H2A has been moved down the list to test non-contiguous indices
    in argument 'constrained_site_indices'

  - the sites of H12A and H12B have been swapped (this is purely conventional:
    it turns out that the smtbx code does not follow that of ShelXL which
    was used to produce this structure in the first place)
  """

  def __init__(self, m):
    test_case.__init__(self, m)
    self.xray_structure = development.sucrose()

    self.t_celsius = 20
    self.shall_refine_thermal_displacements = False

    self.constraints = [
      _.terminal_tetrahedral_xh_site(
        rotating=True,
        pivot=1,
        constrained_site_indices=(2,)),
      _.terminal_tetrahedral_xh_site(
        rotating=True,
        pivot=3,
        constrained_site_indices=(4,)),
      _.terminal_tetrahedral_xh_site(
        rotating=True,
        pivot=5,
        constrained_site_indices=(6,)),
      _.terminal_tetrahedral_xh_site(
        rotating=True,
        pivot=7,
        constrained_site_indices=(8,)),
      _.terminal_tetrahedral_xh_site(
        rotating=True,
        pivot=10,
        constrained_site_indices=(11,)),
      _.terminal_tetrahedral_xh_site(
        rotating=True,
        pivot=12,
        constrained_site_indices=(13,)),
      _.terminal_tetrahedral_xh_site(
        rotating=True,
        pivot=14,
        constrained_site_indices=(15,)),
      _.terminal_tetrahedral_xh_site(
        rotating=True,
        pivot=16,
        constrained_site_indices=(17,)),
      _.tertiary_xh_site(
        pivot=19,
        constrained_site_indices=(20,)),
      _.secondary_xh2_sites(
        pivot=21,
        flapping = True,
        constrained_site_indices=(26, 22)),
      _.tertiary_xh_site(
        pivot=23,
        constrained_site_indices=(24,)),
      _.tertiary_xh_site(
        pivot=25,
        constrained_site_indices=(27,)),
      _.tertiary_xh_site(
        pivot=28,
        constrained_site_indices=(29,)),
      _.tertiary_xh_site(
        pivot=30,
        constrained_site_indices=(31,)),
      _.secondary_xh2_sites(
        pivot=33,
        flapping = True,
        constrained_site_indices=(35, 34)),
      _.tertiary_xh_site(
        pivot=36,
        constrained_site_indices=(37,)),
      _.tertiary_xh_site(
        pivot=38,
        constrained_site_indices=(39,)),
      _.tertiary_xh_site(
        pivot=40,
        constrained_site_indices=(41,)),
      _.secondary_xh2_sites(
        pivot=42,
        flapping = True,
        constrained_site_indices=(43, 44)),
      ]

    self.expected_reparametrisation_for_hydrogen_named = {
      "H2": (core.terminal_tetrahedral_xh_site, 'O2'),
      "H3": (core.terminal_tetrahedral_xh_site, 'O3'),
      "H4": (core.terminal_tetrahedral_xh_site, 'O4'),
      "H5": (core.terminal_tetrahedral_xh_site, 'O5'),
      "H7": (core.terminal_tetrahedral_xh_site, 'O7'),
      "H8": (core.terminal_tetrahedral_xh_site, 'O8'),
      "H9": (core.terminal_tetrahedral_xh_site, 'O9'),
      "H10": (core.terminal_tetrahedral_xh_site, 'O10'),
      "H1": (core.tertiary_xh_site, 'C1'),
      "H2A": (core.secondary_xh2_sites, 'C2'),
      "H2B": (core.secondary_xh2_sites, 'C2'),
      "H3B": (core.tertiary_xh_site, 'C3'),
      "H4B": (core.tertiary_xh_site, 'C4'),
      "H5B": (core.tertiary_xh_site, 'C5'),
      "H6": (core.tertiary_xh_site, 'C6'),
      "H8A": (core.secondary_xh2_sites, 'C8'),
      "H8B": (core.secondary_xh2_sites, 'C8'),
      "H9B": (core.tertiary_xh_site, 'C9'),
      "H10B": (core.tertiary_xh_site, 'C10'),
      "H11": (core.tertiary_xh_site, 'C11'),
      "H12A": (core.secondary_xh2_sites, 'C12'),
      "H12B": (core.secondary_xh2_sites, 'C12'),
    }

    self.expected_mapping_to_grad_fc = (
            59, 60, 61, # O1.site
            80, 81, 82, 83, 84, 85, # O1.u
            0, 1, 2, # O2.site
            86, 87, 88, 89, 90, 91,# O2.u
            394, 395, 396, # H2.site
            92, # H2.u
            7, 8, 9, # O3.site
            93, 94, 95, 96, 97, 98, # O3.u
            397, 398, 399, # H3.site
            99, # H3.u
            14, 15, 16, # O4.site
            100, 101, 102, 103, 104, 105, # O4.u
            400, 401, 402, # H4.site
            106, # H4.u
            21, 22, 23, # O5.site
            107, 108, 109, 110, 111, 112, # O5.u
            403, 404, 405, # H5.site
            113, # H5.u
            76, 77, 78, # O6.site
            114, 115, 116, 117, 118, 119, # O6.u
            28, 29, 30, # O7.site
            120, 121, 122, 123, 124, 125, # O7.u
            406, 407, 408, # H7.site
            126, # H7.u
            35, 36, 37, # O8.site
            127, 128, 129, 130, 131, 132, # O8.u
            409, 410, 411, # H8.site
            133, # H8.u
            42, 43, 44, # O9.site
            134, 135, 136, 137, 138, 139, # O9.u
            412, 413, 414, # H9.site
            140, # H9.u
            49, 50, 51, # O10.site
            141, 142, 143, 144, 145, 146, # O10.u
            415, 416, 417, # H10.site
            147, # H10.u
            66, 67, 68, # O11.site
            148, 149, 150, 151, 152, 153, # O11.u
            56, 57, 58, # C1.site
            154, 155, 156, 157, 158, 159, # C1.u
            418, 419, 420, # H1.site
            160, # H1.u
            3, 4, 5, # C2.site
            161, 162, 163, 164, 165, 166, # C2.u
            424, 425, 426, # H2B.site
            167, # H2B.u
            10, 11, 12, # C3.site
            168, 169, 170, 171, 172, 173, # C3.u
            427, 428, 429, # H3B.site
            174, # H3B.u
            17, 18, 19, # C4.site
            175, 176, 177, 178, 179, 180, # C4.u
            421, 422, 423, # H2A.site
            181, # H2A.u
            430, 431, 432, # H4B.site
            182, # H4B.u
            24, 25, 26, # C5.site
            183, 184, 185, 186, 187, 188, # C5.u
            433, 434, 435, # H5B.site
            189, # H5B.u
            63, 64, 65, # C6.site
            190, 191, 192, 193, 194, 195, # C6.u
            436, 437, 438, # H6.site
            196, # H6.u
            69, 70, 71, # C7.site
            197, 198, 199, 200, 201, 202, # C7.u
            52, 53, 54, # C8.site
            203, 204, 205, 206, 207, 208, # C8.u
            442, 443, 444, # H8A.site
            209, # H8A.u
            439, 440, 441, # H8B.site
            210, # H8B.u
            45, 46, 47, # C9.site
            211, 212, 213, 214, 215, 216, # C9.u
            445, 446, 447, # H9B.site
            217, # H9B.u
            38, 39, 40, # C10.site
            218, 219, 220, 221, 222, 223, # C10.u
            448, 449, 450, # H10B.site
            224, # H10B.u
            73, 74, 75, # C11.site
            225, 226, 227, 228, 229, 230, # C11.u
            451, 452, 453, # H11.site
            231, # H11.u
            31, 32, 33, # C12.site
            232, 233, 234, 235, 236, 237, # C12.u
            454, 455, 456, # H12B.site
            238, # H12B.u
            457, 458, 459, # H12A.site
            239 # H12A.u
            )

    self.site_refinement_tolerance = 1e-4


class saturated_test_case(test_case):
  """ Durham database: 03srv020

  H1N and H2N sites and u's have been swapped.
  """

  def __init__(self, m):
    test_case.__init__(self, m)
    self.xray_structure = xray.structure(
      crystal_symmetry=crystal.symmetry(
        unit_cell=(3.753, 14.54, 15.868, 90, 92.58, 90),
        space_group_symbol='hall: -P 2ybc (x-z,y,z)'),
      scatterers=flex.xray_scatterer((
        xray.scatterer( #0
                        label='O1',
                        site=(0.299733, 0.262703, 0.397094),
                        u=(0.003622, 0.000123, 0.000108,
                           0.000154, -0.000304, -0.000017)),
        xray.scatterer( #1
                        label='O2',
                        site=(0.606432, 0.145132, 0.437285),
                        u=(0.004117, 0.000149, 0.000118,
                           0.000405, -0.000117, -0.000042)),
        xray.scatterer( #2
                        label='N1',
                        site=(0.481175, 0.221358, 0.451529),
                        u=(0.001750, 0.000091, 0.000090,
                           0.000016, -0.000027, -0.000000)),
        xray.scatterer( #3
                        label='N2',
                        site=(0.669716, 0.393801, 0.763893),
                        u=(0.002874, 0.000122, 0.000071,
                           0.000168, -0.000071, -0.000000)),
        xray.scatterer( #4
                        label='H1N',
                        site=(0.777763, 0.365311, 0.806784),
                        u=0.042273),
        xray.scatterer( #5
                        label='H2N',
                        site=(0.589373, 0.450143, 0.770096),
                        u=0.042273),
        xray.scatterer( #6
                        label='C1',
                        site=(0.542801, 0.263225, 0.532794),
                        u=(0.001423, 0.000084, 0.000076,
                           -0.000009, 0.000000, -0.000003)),
        xray.scatterer( #7
                        label='C2',
                        site=(0.718203, 0.216166, 0.600719),
                        u=(0.001241, 0.000081, 0.000088,
                           -0.000011, 0.000023, 0.000009)),
        xray.scatterer( #8
                        label='C3',
                        site=(0.754550, 0.260840, 0.677732),
                        u=(0.001553, 0.000097, 0.000079,
                           0.000044, -0.000014, 0.000019)),
        xray.scatterer( #9
                        label='H3',
                        site=(0.868083, 0.229804, 0.724284),
                        u=0.031215),
        xray.scatterer( #10
                        label='C4',
                        site=(0.627437, 0.351296, 0.688971),
                        u=(0.001601, 0.000093, 0.000075,
                           0.000015, 0.000027, 0.000004)),
        xray.scatterer( #11
                        label='C5',
                        site=(0.454744, 0.396843, 0.619275),
                        u=(0.001302, 0.000082, 0.000083,
                           -0.000002, -0.000011, 0.000007)),
        xray.scatterer( #12
                        label='C6',
                        site=(0.414545, 0.352153, 0.542558),
                        u=(0.001310, 0.000086, 0.000080,
                           0.000014, -0.000038, 0.000012)),
        xray.scatterer( #13
                        label='H6',
                        site=(0.298067, 0.382503, 0.496003),
                        u=0.028457),
        xray.scatterer( #14
                        label='C7',
                        site=(0.870740, 0.125780, 0.594964),
                        u=(0.001485, 0.000100, 0.000087,
                           0.000015, 0.000006, 0.000009)),
        xray.scatterer( #15
                        label='C8',
                        site=(1.017756, 0.053520, 0.594148),
                        u=(0.002161, 0.000095, 0.000112,
                           0.000070, 0.000030, 0.000015)),
        xray.scatterer( #16
                        label='H8',
                        site=(1.135411, -0.004309, 0.593494),
                        u=0.039284),
        xray.scatterer( #17
                        label='C9',
                        site=(0.317957, 0.487839, 0.631013),
                        u=(0.001562, 0.000101, 0.000080,
                           0.000008, -0.000022, 0.000009)),
        xray.scatterer( #18
                        label='C10',
                        site=(0.204108, 0.561746, 0.646136),
                        u=(0.001931, 0.000100, 0.000123,
                           0.000052, -0.000025, -0.000002)),
        xray.scatterer( #19
                        label='H10',
                        site=(0.112835, 0.620998, 0.658260),
                        u=0.039775)
      )))


    self.t_celsius = -153
    self.shall_refine_thermal_displacements = True

    k=1.5 # that is the multiplier used to refine the structure with ShelXL
    self.constraints = [
      _.terminal_planar_xh2_sites(
        pivot=3,
        constrained_site_indices=(4, 5)),

      _.u_iso_proportional_to_pivot_u_eq(
        u_eq_scatterer_idx=3,
        u_iso_scatterer_idx=4,
        multiplier=k),

      _.u_iso_proportional_to_pivot_u_eq(
        u_eq_scatterer_idx=3,
        u_iso_scatterer_idx=5,
        multiplier=k),

      _.terminal_linear_ch_site(
        pivot=15,
        constrained_site_indices=(16,)),

      _.u_iso_proportional_to_pivot_u_eq(
        u_eq_scatterer_idx=15,
        u_iso_scatterer_idx=16,
        multiplier=k),

      _.terminal_linear_ch_site(
        pivot=18,
        constrained_site_indices=(19,)),

      _.u_iso_proportional_to_pivot_u_eq(
        u_eq_scatterer_idx=18,
        u_iso_scatterer_idx=19,
        multiplier=k),

      _.secondary_planar_xh_site(
        pivot=12,
        constrained_site_indices=(13,)),

      _.u_iso_proportional_to_pivot_u_eq(
        u_eq_scatterer_idx=12,
        u_iso_scatterer_idx=13,
        multiplier=k),

      _.secondary_planar_xh_site(
        pivot=8,
        constrained_site_indices=(9,)),

      _.u_iso_proportional_to_pivot_u_eq(
        u_eq_scatterer_idx=8,
        u_iso_scatterer_idx=9,
        multiplier=k),
      ]

    self.expected_reparametrisation_for_hydrogen_named = {
      'H1N': (core.terminal_planar_xh2_sites, 'N2'),
      'H2N': (core.terminal_planar_xh2_sites, 'N2'),
      'H10': (core.terminal_linear_ch_site, 'C10'),
      'H6' : (core.secondary_planar_xh_site, 'C6'),
      'H3' : (core.secondary_planar_xh_site, 'C3'),
      'H8': (core.terminal_linear_ch_site, 'C8'),
    }

    self.site_refinement_tolerance = 1e-2
    self.u_star_refinement_tolerance = 1e-5


class symmetry_equivalent_test_case(test_case):
  """ 09srv172 from Durham database """

  def __init__(self, m):
    test_case.__init__(self, m)
    self.xray_structure = xray.structure(
      crystal_symmetry=crystal.symmetry(
        unit_cell=(17.0216, 8.4362, 10.2248, 90, 102.79, 90),
        space_group_symbol='hall: -C 2yc'),
      scatterers=flex.xray_scatterer((
        xray.scatterer( #0
                        label='S1',
                        site=(0.525736, 0.737492, 0.619814),
                        u=(0.000084, 0.000243, 0.000191,
                           0.000021, 0.000026, -0.000035)),
        xray.scatterer( #1
                        label='C1',
                        site=(0.500000, 0.868009, 0.750000),
                        u=(0.000061, 0.000181, 0.000164,
                           0.000000, 0.000025, 0.000000)),
        xray.scatterer( #2
                        label='C2',
                        site=(0.533017, 0.552825, 0.710913),
                        u=(0.000161, 0.000241, 0.000348,
                           0.000041, 0.000039, -0.000020)),
        xray.scatterer( #3
                        label='H2A',
                        site=(0.525986, 0.462184, 0.647894),
                        u=0.041420),
        xray.scatterer( #4
                        label='H2B',
                        site=(0.586473, 0.543642, 0.772877),
                        u=0.038360),
        xray.scatterer( #5
                        label='C3',
                        site=(0.425914, 0.971290, 0.682589),
                        u=(0.000058, 0.000199, 0.000164,
                           -0.000003, 0.000017, -0.000007)),
        xray.scatterer( #6
                        label='H3',
                        site=(0.441258, 1.029902, 0.606966),
                        u=0.023950),
        xray.scatterer( #7
                        label='C4',
                        site=(0.349971, 0.874741, 0.622481),
                        u=(0.000064, 0.000236, 0.000219,
                           -0.000015, 0.000011, -0.000014)),
        xray.scatterer( #8
                        label='H4B',
                        site=(0.362228, 0.799281, 0.555566),
                        u=0.026970),
        xray.scatterer( #9
                        label='H4A',
                        site=(0.333906, 0.812566, 0.694426),
                        u=0.025070),
        xray.scatterer( #10
                        label='C5',
                        site=(0.279832, 0.981636, 0.555089),
                        u=(0.000064, 0.000307, 0.000222,
                           -0.000007, 0.000003, -0.000021)),
        xray.scatterer( #11
                        label='H5B',
                        site=(0.294150, 1.037327, 0.478372),
                        u=0.026970),
        xray.scatterer( #12
                        label='H5A',
                        site=(0.231706, 0.915594, 0.519984),
                        u=0.034720),
        xray.scatterer( #13
                        label='C6',
                        site=(0.259978, 1.103478, 0.653453),
                        u=(0.000061, 0.000335, 0.000246,
                           0.000016, 0.000021, -0.000001)),
        xray.scatterer( #14
                        label='H6B',
                        site=(0.216403, 1.174193, 0.606307),
                        u=0.037560),
        xray.scatterer( #15
                        label='H6A',
                        site=(0.240791, 1.048477, 0.726038),
                        u=0.024860),
        xray.scatterer( #16
                        label='C7',
                        site=(0.334517, 1.201490, 0.713404),
                        u=(0.000071, 0.000265, 0.000251,
                           0.000019, 0.000019, -0.000029)),
        xray.scatterer( #17
                        label='H7B',
                        site=(0.349843, 1.265431, 0.641770),
                        u=0.031500),
        xray.scatterer( #18
                        label='H7A',
                        site=(0.321733, 1.275376, 0.780996),
                        u=0.030620),
        xray.scatterer( #19
                        label='C8',
                        site=(0.405687, 1.096392, 0.779637),
                        u=(0.000064, 0.000247, 0.000187,
                           0.000009, 0.000015, -0.000033)),
        xray.scatterer( #20
                        label='H8A',
                        site=(0.392638, 1.042204, 0.858057),
                        u=0.026000),
        xray.scatterer( #21
                        label='H8B',
                        site=(0.453574, 1.163891, 0.812432),
                        u=0.027360)
      )))

    self.t_celsius = -153
    self.shall_refine_thermal_displacements = True

    self.constraints = [
      _.secondary_xh2_sites(
        pivot=2,
        constrained_site_indices=(3,4)),

      _.u_iso_proportional_to_pivot_u_eq(
        u_eq_scatterer_idx=2,
        u_iso_scatterer_idx=3,
        multiplier=1.5),

      _.u_iso_proportional_to_pivot_u_eq(
        u_eq_scatterer_idx=2,
        u_iso_scatterer_idx=4,
        multiplier=1.5),

      _.tertiary_xh_site(
        pivot=5,
        constrained_site_indices=(6,)),

      _.u_iso_proportional_to_pivot_u_eq(
        u_eq_scatterer_idx=5,
        u_iso_scatterer_idx=6,
        multiplier=1.5),

      _.secondary_xh2_sites(
        pivot=7,
        constrained_site_indices=(8, 9)),

      _.u_iso_proportional_to_pivot_u_eq(
        u_eq_scatterer_idx=7,
        u_iso_scatterer_idx=8,
        multiplier=1.5),

      _.u_iso_proportional_to_pivot_u_eq(
        u_eq_scatterer_idx=7,
        u_iso_scatterer_idx=9,
        multiplier=1.5),

      _.secondary_xh2_sites(
        pivot=10,
        constrained_site_indices=(11, 12)),

      _.u_iso_proportional_to_pivot_u_eq(
        u_eq_scatterer_idx=10,
        u_iso_scatterer_idx=11,
        multiplier=1.5),

      _.u_iso_proportional_to_pivot_u_eq(
        u_eq_scatterer_idx=10,
        u_iso_scatterer_idx=12,
        multiplier=1.5),

      _.secondary_xh2_sites(
        pivot=13,
        constrained_site_indices=(14, 15)),

      _.u_iso_proportional_to_pivot_u_eq(
        u_eq_scatterer_idx=13,
        u_iso_scatterer_idx=14,
        multiplier=1.5),

      _.u_iso_proportional_to_pivot_u_eq(
        u_eq_scatterer_idx=13,
        u_iso_scatterer_idx=15,
        multiplier=1.5),

      _.secondary_xh2_sites(
        pivot=16,
          constrained_site_indices=(17, 18)),

      _.u_iso_proportional_to_pivot_u_eq(
        u_eq_scatterer_idx=16,
        u_iso_scatterer_idx=17,
        multiplier=1.5),

      _.u_iso_proportional_to_pivot_u_eq(
        u_eq_scatterer_idx=16,
        u_iso_scatterer_idx=18,
        multiplier=1.5),

      _.secondary_xh2_sites(
        pivot=19,
        constrained_site_indices=(20, 21)),

      _.u_iso_proportional_to_pivot_u_eq(
        u_eq_scatterer_idx=19,
        u_iso_scatterer_idx=20,
        multiplier=1.5),

      _.u_iso_proportional_to_pivot_u_eq(
        u_eq_scatterer_idx=19,
        u_iso_scatterer_idx=21,
        multiplier=1.5),
    ]

    self.expected_reparametrisation_for_hydrogen_named = {
      "H2A": (core.secondary_xh2_sites, 'C2'),
      "H2B": (core.secondary_xh2_sites, 'C2'),
      "H3" : (core.tertiary_xh_site   , 'C3'),
      "H4A": (core.secondary_xh2_sites, 'C4'),
      "H4B": (core.secondary_xh2_sites, 'C4'),
      "H5A": (core.secondary_xh2_sites, 'C5'),
      "H5B": (core.secondary_xh2_sites, 'C5'),
      "H6A": (core.secondary_xh2_sites, 'C6'),
      "H6B": (core.secondary_xh2_sites, 'C6'),
      "H7A": (core.secondary_xh2_sites, 'C7'),
      "H7B": (core.secondary_xh2_sites, 'C7'),
      "H8A": (core.secondary_xh2_sites, 'C8'),
      "H8B": (core.secondary_xh2_sites, 'C8'),
    }

    self.site_refinement_tolerance = 0.01
    self.u_star_refinement_tolerance = 5e-7

  def check_reparametrisation_construction_more(self):
    for params in self.reparametrisation.asu_scatterer_parameters:
      if params.site.scatterers[0].label == 'H2A':
        h2a = params.site
        (pivot, pivot_neighbour_0, pivot_neighbour_1,
         bond_length, h_c_h_angle) = h2a.arguments()
        expected = sorted([ (core.independent_site_parameter, 'S1'),
                            (core.symmetry_equivalent_site_parameter, 'C2',
                                '-x+1,y,-z+3/2') ], key=itemgetter(1))
        actual = []
        for n in (pivot_neighbour_0, pivot_neighbour_1):
          if type(n) == core.independent_site_parameter:
            actual.append((type(n), n.scatterers[0].label))
          elif type(n) == core.symmetry_equivalent_site_parameter:
            actual.append((type(n),
                           n.original.scatterers[0].label,
                           str(n.motion)))
        actual.sort(key=itemgetter(1))
        assert actual == expected

def run():
  import libtbx.utils
  libtbx.utils.show_times_at_exit()
  import sys
  from libtbx.option_parser import option_parser
  command_line = (option_parser()
    .option(None, "--normal_eqns_solving_method",
            default='naive')
    .option(None, "--fix_random_seeds",
            action='store_true',
            default='naive')
  ).process(args=sys.argv[1:])
  opts = command_line.options
  if opts.fix_random_seeds:
    import random
    random.seed(1)
    flex.set_random_seed(1)
  gradient_threshold=1e-8
  step_threshold=1e-8
  if opts.normal_eqns_solving_method == 'naive':
    m = lambda eqns: normal_eqns_solving.naive_iterations(
      eqns,
      gradient_threshold=gradient_threshold,
      step_threshold=step_threshold)
  elif opts.normal_eqns_solving_method == 'levenberg-marquardt':
    m = lambda eqns: normal_eqns_solving.levenberg_marquardt_iterations(
      eqns,
      gradient_threshold=gradient_threshold,
      step_threshold=gradient_threshold,
      tau=1e-7)
  else:
    raise RuntimeError("Unknown method %s" % opts.normal_eqns_solving_method)
  for t in [
    saturated_test_case(m),
    sucrose_test_case(m),
    symmetry_equivalent_test_case(m),
    fpfdp_test_case(m),
    constrained_fpfdp_test_case(m),
    scalar_scaled_adp_test_case(m),
    ]:
    t.run()

if __name__ == '__main__':
  run()


 *******************************************************************************


 *******************************************************************************
smtbx/refinement/constraints/tests/tst_direction.py
from __future__ import absolute_import, division, print_function

def exercise_direction():
  from cctbx.array_family import flex
  from cctbx import uctbx, xray, crystal
  from smtbx.refinement import constraints
  from scitbx.matrix import col, row
  from libtbx.test_utils import approx_equal

  uc = uctbx.unit_cell((1, 2, 3))
  xs = xray.structure(
    crystal_symmetry=crystal.symmetry(
      unit_cell=uc,
      space_group_symbol='hall: P 2x 2y'),
    scatterers=flex.xray_scatterer((
      xray.scatterer('C0', site=(0,0,0)),
      xray.scatterer('C1', site=(0,2,0)),
      xray.scatterer('C2', site=(1,1,0)),
      xray.scatterer('C3', site=(3,1,0)),
      )))
  r = constraints.ext.reparametrisation(xs.unit_cell())
  sc = xs.scatterers()
  site_0 = r.add(constraints.independent_site_parameter, sc[0])
  site_1 = r.add(constraints.independent_site_parameter, sc[1])
  site_2 = r.add(constraints.independent_site_parameter, sc[2])
  site_3 = r.add(constraints.independent_site_parameter, sc[3])
  d = constraints.vector_direction((site_0, site_1, site_2)).direction(uc)
  sd = constraints.static_direction.calc_best_line(uc, (site_0, site_1, site_2))
  assert approx_equal(d, sd, eps=1e-15)

  d = constraints.vector_direction((site_0, site_1)).direction(uc)
  assert approx_equal(d,
    row(uc.orthogonalize(col(sc[1].site)-col(sc[0].site))).normalize(),
    eps=1e-15)

  n = constraints.static_direction.calc_best_plane_normal(
    uc, (site_0, site_1, site_2))

  n1 = constraints.static_direction.calc_best_plane_normal(
    uc, (site_0, site_1, site_2, site_3))

  v01 = uc.orthogonalize(col(sc[0].site)-col(sc[1].site))
  v21 = uc.orthogonalize(col(sc[2].site)-col(sc[1].site))
  nc = row(v01).cross(row(v21)).normalize()
  assert approx_equal(n, n1, eps=1e-15)
  assert approx_equal(n, nc, eps=1e-15)

if __name__ == '__main__':
  exercise_direction()
  print('OK')


 *******************************************************************************


 *******************************************************************************
smtbx/refinement/constraints/tests/tst_disorder.py
from __future__ import absolute_import, division, print_function

from six.moves import zip
from six.moves import cStringIO as StringIO

disordered = """
TITL 00asb006 in Pca2(1)
CELL 0.71073 25.392 25.853 24.736 90 90 90
ZERR 4 0.008 0.008 0.008 0 0 0
LATT -1
SYMM -X,-Y,0.5+Z
SYMM 0.5+X,-Y,+Z
SYMM 0.5-X,+Y,0.5+Z
SFAC C H N O Co
UNIT 540 920 24 184 24

TEMP -153

WGHT    0.100000    5.070000
FVAR       0.07939

C11   1    0.483531    0.459094    0.598199    11.00000    0.03813    0.02398 =
         0.01913   -0.00385    0.00456   -0.01024
C12   1    0.470584    0.441994    0.539618    11.00000    0.05678    0.04644 =
         0.02077   -0.00864   -0.00707    0.01456
PART 1
C13A  1    0.467614    0.382305    0.543321    10.50000    0.08323
AFIX 137
H13A  2    0.500814    0.368863    0.557836    10.50000   -1.50000
H13B  2    0.461581    0.367872    0.507215    10.50000   -1.50000
H13C  2    0.438564    0.372387    0.567257    10.50000   -1.50000
AFIX   0
C14A  1    0.512981    0.456421    0.502662    10.50000    0.13294
AFIX 137
H14A  2    0.523457    0.492309    0.509528    10.50000   -1.50000
H14B  2    0.500683    0.453086    0.465271    10.50000   -1.50000
H14C  2    0.543247    0.433548    0.508394    10.50000   -1.50000
AFIX   0
C15A  1    0.415133    0.458461    0.522044    10.50000    0.03863
AFIX 137
H15A  2    0.388967    0.441779    0.545370    10.50000   -1.50000
H15B  2    0.409209    0.448013    0.484449    10.50000   -1.50000
H15C  2    0.411795    0.496114    0.525084    10.50000   -1.50000
AFIX   0
PART 0
PART 2
C13B  1    0.499998    0.393168    0.524392    10.50000    0.03074
AFIX 137
H13D  2    0.537495    0.397446    0.532638    10.50000   -1.50000
H13E  2    0.495628    0.386533    0.485644    10.50000   -1.50000
H13F  2    0.485905    0.363926    0.545039    10.50000   -1.50000
AFIX   0
C14B  1    0.496158    0.488076    0.502627    10.50000    0.05672
AFIX 137
H14D  2    0.486815    0.521767    0.518047    10.50000   -1.50000
H14E  2    0.482406    0.485655    0.465695    10.50000   -1.50000
H14F  2    0.534566    0.484402    0.501987    10.50000   -1.50000
AFIX   0
C15B  1    0.416045    0.429952    0.540272    10.50000    0.07696
AFIX 137
H15D  2    0.408861    0.405168    0.569328    10.50000   -1.50000
H15E  2    0.405938    0.414768    0.505484    10.50000   -1.50000
H15F  2    0.395683    0.461606    0.546453    10.50000   -1.50000
AFIX   0
PART 0
HKLF 4
"""

def exercise_with_disorder():
  from iotbx import shelx
  from smtbx import refinement
  import smtbx.refinement.constraints as core

  p = shelx.parse_smtbx_refinement_model(file=StringIO(disordered))
  xs = p.structure
  mi = xs.build_miller_set(d_min=0.6, anomalous_flag=True)
  fcalc = mi.structure_factors_from_scatterers(xs, algorithm="direct").f_calc()
  xm = refinement.model(fo_sq=fcalc.norm(),
                        xray_structure=xs,
                        constraints=p.constraints,
                        restraints_manager=p.restraints_manager,
                        weighting_scheme=p.weighting_scheme,
                        temperature_in_celsius=p.temperature_in_celsius,
                        conformer_indices=p.conformer_indices)
  assert xm.temperature_in_celsius == -153
  ls = xm.least_squares()
  expected_reparametrisation_for = {}
  for i in (13, 14, 15):
    for s in 'ABCDEF':
      pivot_letter = 'A' if s < 'D' else 'B'
      expected_reparametrisation_for["H%i%s" % (i,s)] = (
        core.terminal_tetrahedral_xh3_sites, "C%i%s" % (i,pivot_letter))
  for sc, params in zip(
    ls.reparametrisation.structure.scatterers(),
    ls.reparametrisation.asu_scatterer_parameters):
    if sc.scattering_type != 'H':
      continue
    (expected_type, expected_pivot) = expected_reparametrisation_for[sc.label]
    assert isinstance(params.site, expected_type)
    assert ([sc1.label for sc1 in params.site.argument(0).scatterers] ==
            [expected_pivot])

if __name__ == '__main__':
  exercise_with_disorder()
  print('OK')


 *******************************************************************************


 *******************************************************************************
smtbx/refinement/constraints/tests/tst_lbfgs.py
from __future__ import absolute_import, division, print_function
import math
import os

from cctbx.array_family import flex
from cctbx import xray
from libtbx import adopt_init_args
import libtbx.phil
import libtbx.utils
import scitbx
import scitbx.lbfgs
import scitbx.lstbx
import scitbx.lstbx.normal_eqns_solving
from smtbx.refinement import least_squares
from smtbx.refinement import constraints
import smtbx.utils
from smtbx.refinement.constraints.tests import tst_constrained_structure
from six.moves import range


class lbfgs(object):

  def __init__(self, target_functor,
                     xray_structure,
                     reparametrisation,
                     lbfgs_termination_params=None,
                     lbfgs_core_params=None,
                     cos_sin_table=True,
                     structure_factor_algorithm=None,
                     verbose=0,
                     reference_structure=None):
    adopt_init_args(self, locals())
    self.scatterer_grad_flags_counts = xray.minimization.ext.scatterer_grad_flags_counts(
                                              self.xray_structure.scatterers())
    self.grad_flags_counts = \
      xray.minimization.ext.scatterer_grad_flags_counts(self.xray_structure.scatterers())
    self.structure_factors_from_scatterers = \
      xray.structure_factors.from_scatterers(
        miller_set=self.target_functor.f_obs(),
        cos_sin_table=cos_sin_table)
    self.structure_factor_gradients = \
      xray.structure_factors.gradients(
        miller_set=self.target_functor.f_obs(),
        cos_sin_table=cos_sin_table)
    self.x = flex.double(reparametrisation.n_independents, 0)
    xray_structure.tidy_us(u_min=1.e-6)
    self.last_shift = None
    import sys
    self.minimizer = scitbx.lbfgs.run(
      target_evaluator=self,
      termination_params=lbfgs_termination_params,
      core_params=lbfgs_core_params,
      #log=sys.stdout
    )
    self.apply_shifts()
    self.compute_target(compute_gradients=False)
    self.final_target_value = self.target_result.target()

  def apply_shifts(self):
    shifts = self.x.deep_copy()
    if self.last_shift is not None:
      # beware: self.x are the shifts from the starting parameters, not from the
      # current parameters!
      shifts -= self.last_shift
      self.reparametrisation.apply_shifts(shifts)
    self.reparametrisation.linearise()
    self.reparametrisation.store()
    self.last_shift = self.x.deep_copy()
    return flex.double() # XXX

  def compute_target(self, compute_gradients):
    self.f_calc = self.structure_factors_from_scatterers(
      xray_structure=self.xray_structure,
      miller_set=self.target_functor.f_obs(),
      algorithm=self.structure_factor_algorithm).f_calc()
    self.target_result = self.target_functor(
      self.f_calc,
      compute_gradients)
    assert self.target_result.target() is not None

  def compute_functional_and_gradients(self):
    u_iso_refinable_params = self.apply_shifts()
    self.compute_target(compute_gradients=True)
    self.f = self.target_result.target()
    gradients = self.structure_factor_gradients(
      xray_structure=self.xray_structure,
      u_iso_refinable_params=u_iso_refinable_params,
      miller_set=self.target_functor.f_obs(),
      d_target_d_f_calc=self.target_result.derivatives(),
      n_parameters=0, # so the gradients aren't packed
      algorithm=self.structure_factor_algorithm)
    if self.scatterer_grad_flags_counts.site:
      d_target_d_site_frac = gradients.d_target_d_site_frac()
    if self.scatterer_grad_flags_counts.u_iso:
      d_target_d_u_iso = gradients.d_target_d_u_iso()
    if self.scatterer_grad_flags_counts.u_aniso:
      d_target_d_u_star = gradients.d_target_d_u_star()
    if self.scatterer_grad_flags_counts.fp:
      d_target_d_fp = gradients.d_target_d_fp()
    if self.scatterer_grad_flags_counts.fdp:
      d_target_d_fdp = gradients.d_target_d_fdp()
    if self.scatterer_grad_flags_counts.occupancy:
      d_target_d_occupancy = gradients.d_target_d_occupancy()
    # pack the gradients ourselves - currently the constraints system assumes
    # we are refining fractional coordinates and u_star
    self.g = flex.double()
    for i, sc in enumerate(self.xray_structure.scatterers()):
      if sc.flags.grad_site():
        for j in range(3):
          self.g.append(d_target_d_site_frac[i][j])
      if sc.flags.use_u_iso() and sc.flags.grad_u_iso():
        self.g.append(d_target_d_u_iso[i])
      if sc.flags.use_u_aniso() and sc.flags.grad_u_aniso():
        for j in range(6):
          self.g.append(d_target_d_u_star[i][j])
      if sc.flags.grad_occupancy():
        self.g.append(d_target_d_occupancy[i])
      if sc.flags.grad_fp():
        self.g.append(d_target_d_fp[i])
      if sc.flags.grad_fdp():
        self.g.append(d_target_d_fdp[i])
    if self.verbose > 0:
      print("xray.minimization line search: f,rms(g):", end=' ')
      print(self.f, math.sqrt(flex.mean_sq(self.g)))
    jacobian = self.reparametrisation.jacobian_transpose_matching_grad_fc()
    self.g = jacobian * self.g
    return self.f, self.g

  def callback_after_step(self, minimizer):
    if self.verbose > 0:
      print("xray.minimization step: f,iter,nfun:", end=' ')
      print(self.f,minimizer.iter(),minimizer.nfun())
    if self.verbose > 1 and self.reference_structure is not None:
      xray.meaningful_site_cart_differences(self.xray_structure, self.reference_structure).show()


def run(args):
  master_phil = libtbx.phil.parse("""
    d_min = 0.5
      .type = float
    constrained_refinement = True
      .type = bool
    random_seed = 1
      .type = int
    shake_sites_rmsd = 0.5
      .type = float
    shake_adp_spread = 20
      .type = float
    grad_site=True
      .type = bool
    grad_u_iso=False
      .type = bool
    grad_u_aniso=False
      .type = bool
    grad_occupancy=False
      .type = bool
    grad_fp_fdp=False
      .type = bool
    lbfgs_m = 5
      .type = int
    lbfgs_max_iterations = 1000
      .type = int
    verbose = 0
      .type = int
""")

  argument_interpreter = master_phil.command_line_argument_interpreter()
  phil_objects = []
  remaining_args = []
  for arg in args:
    if (arg.find("=") >= 0):
      phil_objects.append(argument_interpreter.process(arg=arg))
    else:
      remaining_args.append(arg)
  work_phil = master_phil.fetch(sources=phil_objects)
  work_phil.show()
  params = work_phil.extract()

  if params.random_seed is not None:
    import scitbx.random
    import random
    scitbx.random.set_random_seed(params.random_seed)
    flex.set_random_seed(params.random_seed)
    random.seed(params.random_seed)

  if len(remaining_args):
    assert len(remaining_args) == 1
    file_path = remaining_args[0]
    root, ext = os.path.splitext(file_path)

    if ext == ".cif":
      xs_dict = xray.structure.from_cif(file_path=file_path)
      assert len(xs_dict) == 1, "CIF should contain only one xray structure"
      xs = list(xs_dict.values())[0]
      xs.show_summary().show_scatterers()
      print()
      constraints_list = None
      t_celsius = 20
    else:
      raise RuntimeError("Only CIF format currently supported!")

  else:
    test_case = tst_constrained_structure.sucrose_test_case(None)
    t_celsius = test_case.t_celsius
    xs = test_case.xray_structure
    constraints_list = test_case.constraints

  #from cctbx import adptbx
  #for sc in xs.scatterers():
    #if sc.flags.use_u_aniso():
      #sc.u_iso = adptbx.u_star_as_u_iso(xs.unit_cell(), sc.u_star)
      #sc.set_use_u_iso_only()

  if not params.constrained_refinement:
    constraints_list = []

  exercise_constrained_lbfgs(xray_structure=xs,
                             constraints_list=constraints_list,
                             t_celsius=t_celsius,
                             d_min=params.d_min,
                             shake_sites_rmsd=params.shake_sites_rmsd,
                             shake_u_iso_spread=params.shake_adp_spread,
                             grad_site=params.grad_site,
                             grad_u_iso=params.grad_u_iso,
                             grad_u_aniso=params.grad_u_aniso,
                             grad_occupancy=params.grad_occupancy,
                             grad_fp_fdp=params.grad_fp_fdp,
                             lbfgs_m=params.lbfgs_m,
                             lbfgs_max_iterations=params.lbfgs_max_iterations,
                             verbose=params.verbose)

def exercise_constrained_lbfgs(xray_structure,
                               constraints_list,
                               t_celsius,
                               d_min=0.5,
                               shake_sites_rmsd=0.5,
                               shake_u_iso_spread=0,
                               shake_u_aniso_spread=0,
                               grad_site=True,
                               grad_u_iso=True,
                               grad_u_aniso=False,
                               grad_occupancy=False,
                               grad_fp_fdp=False,
                               lbfgs_m=5,
                               lbfgs_max_iterations=1000,
                               verbose=0):

  xs = xray_structure
  xray.set_scatterer_grad_flags(scatterers=xs.scatterers(),
                                site=grad_site,
                                u_iso=grad_u_iso,
                                u_aniso=grad_u_aniso,
                                occupancy=grad_occupancy,
                                fp=grad_fp_fdp,
                                fdp=grad_fp_fdp,
                                tan_u_iso=False,
                                param=0)

  xs0 = xs.deep_copy_scatterers()
  mi = xs0.build_miller_set(anomalous_flag=False, d_min=d_min)
  fo_sq = mi.structure_factors_from_scatterers(
    xs0, algorithm="direct").f_calc().norm()
  fo_sq = fo_sq.customized_copy(sigmas=flex.double(fo_sq.size(), 1))
  fo_sq.set_observation_type_xray_intensity()
  y_obs = fo_sq
  #y_obs = fo_sq.f_sq_as_f()
  if grad_site:
    xs.shake_sites_in_place(rms_difference=shake_sites_rmsd)
  if not grad_u_aniso: shake_u_aniso_spread = 0
  if not grad_u_iso: shake_u_iso_spread = 0
  if grad_u_aniso or grad_u_iso:
    xs.shake_adp(spread=shake_u_iso_spread, aniso_spread=shake_u_aniso_spread)
  xs1 = xs.deep_copy_scatterers()

  core_params = scitbx.lbfgs.core_parameters(m=lbfgs_m, maxfev=100, xtol=1e-5)

  connectivity_table = smtbx.utils.connectivity_table(xs0)

  if constraints_list is None:
    from smtbx.development import generate_hydrogen_constraints
    constraints_list = generate_hydrogen_constraints(
      structure=xs0, connectivity_table=connectivity_table)

  reparametrisation = constraints.reparametrisation(
    xs,
    constraints_list,
    connectivity_table,
    temperature=t_celsius)

  lbfgs_termination_params=scitbx.lbfgs.termination_parameters(
    traditional_convergence_test=False,
    drop_convergence_test_max_drop_eps=1.e-20,
    drop_convergence_test_iteration_coefficient=1,
    min_iterations=500,
    max_iterations=lbfgs_max_iterations)

  minimizer = lbfgs(
    target_functor=xray.target_functors.unified_least_squares_residual(y_obs),
    xray_structure=xs,
    reparametrisation=reparametrisation,
    structure_factor_algorithm="direct",
    lbfgs_termination_params=lbfgs_termination_params,
    lbfgs_core_params=core_params,
    reference_structure=xs0,
    verbose=verbose)

  if verbose > 0:
    print("Total parameters: ", xs.n_parameters())
    print("Independent parameters: ", reparametrisation.n_independents)

    print("Reference model: ")
    xs0.show_angles(distance_cutoff=1.5)
    print()
    print("Starting model: ")
    xs1.show_angles(distance_cutoff=1.5)
    print()
    print("Refined model: ")
    xs.show_angles(distance_cutoff=1.5)
    print()

    print("n_iter, n_fun: ", minimizer.minimizer.iter(), minimizer.minimizer.nfun())

  h_selection = xs.element_selection('H')

  diff = xray.meaningful_site_cart_differences(
    xs0.select(h_selection, negate=True),
    xs.select(h_selection, negate=True))
  #diff = xray.meaningful_site_cart_differences(xs0, xs)
  #assert diff.max_absolute() < 1e-3
  if verbose > 0:
    diff.show()
    print()
  assert diff.max_absolute() < 2e-2, diff.max_absolute()

  diff = xray.meaningful_site_cart_differences(xs0, xs)
  if verbose > 0:
    diff.show()
    print()
  # XXX why does this tolerance have to be so high?
  assert diff.max_absolute() < 0.5, diff.max_absolute()

  #ls = least_squares.crystallographic_ls(
    #fo_sq.as_xray_observations(),
    #reparametrisation,
    #restraints_manager=None,
    #weighting_scheme=least_squares.sigma_weighting())

  #steps = scitbx.lstbx.normal_eqns_solving.naive_iterations(
    #non_linear_ls=ls,
    #n_max_iterations=100,
  #)
  #steps.do()

  #diff = xray.meaningful_site_cart_differences(xs0, xs)
  #assert diff.max_absolute() < 1e-4


if __name__ == '__main__':
  import sys
  libtbx.utils.show_times_at_exit()
  run(sys.argv[1:])


 *******************************************************************************


 *******************************************************************************
smtbx/refinement/constraints/tests/tst_occupancies.py
from __future__ import absolute_import, division, print_function

import smtbx.refinement
from libtbx.test_utils import approx_equal
from smtbx.regression.test_data import fnames

expected_str_reparametrisation = """\
digraph dependencies {
204 -> 0;
205 -> 1;
0 [label="independent_occupancy_parameter (N3) #0"];
1 [label="independent_occupancy_parameter (C7A) #1"];
2 [label="independent_site_parameter (F1) #2"];
5 [label="independent_u_star_parameter (F1) #5"];
11 [label="independent_site_parameter (F2) #11"];
14 [label="independent_u_star_parameter (F2) #14"];
20 [label="independent_site_parameter (N8) #20"];
23 [label="independent_u_star_parameter (N8) #23"];
29 [label="independent_site_parameter (N3) #29"];
32 [label="independent_u_iso_parameter (N3) #32"];
33 [label="independent_site_parameter (C9) #33"];
36 [label="independent_u_star_parameter (C9) #36"];
42 [label="independent_site_parameter (C4) #42"];
45 [label="independent_u_star_parameter (C4) #45"];
51 [label="independent_site_parameter (N5) #51"];
54 [label="independent_u_star_parameter (N5) #54"];
60 [label="independent_site_parameter (C2) #60"];
63 [label="independent_u_star_parameter (C2) #63"];
69 [label="independent_site_parameter (C10) #69"];
72 [label="independent_u_star_parameter (C10) #72"];
78 [label="independent_site_parameter (C1) #78"];
81 [label="independent_u_star_parameter (C1) #81"];
87 [label="independent_site_parameter (C11) #87"];
90 [label="independent_u_star_parameter (C11) #90"];
96 [label="independent_site_parameter (C13) #96"];
99 [label="independent_u_star_parameter (C13) #99"];
105 [label="independent_site_parameter (C6) #105"];
108 [label="independent_u_star_parameter (C6) #108"];
114 [label="independent_site_parameter (N12) #114"];
117 [label="independent_u_star_parameter (N12) #117"];
123 [label="independent_site_parameter (C7A) #123"];
126 [label="independent_u_star_parameter (C7A) #126"];
132 [label="independent_site_parameter (C14) #132"];
135 [label="independent_u_star_parameter (C14) #135"];
141 [label="independent_site_parameter (C7B) #141"];
144 [label="independent_u_star_parameter (C7B) #144"];
150 [label="independent_site_parameter (C3) #150"];
153 [label="independent_u_iso_parameter (C3) #153"];
154 [label="independent_occupancy_parameter [cst] (F1) #154"];
155 [label="independent_fp_parameter [cst] (F1) #155"];
156 [label="independent_fdp_parameter [cst] (F1) #156"];
157 [label="independent_occupancy_parameter [cst] (F2) #157"];
158 [label="independent_fp_parameter [cst] (F2) #158"];
159 [label="independent_fdp_parameter [cst] (F2) #159"];
160 [label="independent_occupancy_parameter [cst] (N8) #160"];
161 [label="independent_fp_parameter [cst] (N8) #161"];
162 [label="independent_fdp_parameter [cst] (N8) #162"];
163 [label="independent_fp_parameter [cst] (N3) #163"];
164 [label="independent_fdp_parameter [cst] (N3) #164"];
165 [label="independent_occupancy_parameter [cst] (C9) #165"];
166 [label="independent_fp_parameter [cst] (C9) #166"];
167 [label="independent_fdp_parameter [cst] (C9) #167"];
168 [label="independent_occupancy_parameter [cst] (C4) #168"];
169 [label="independent_fp_parameter [cst] (C4) #169"];
170 [label="independent_fdp_parameter [cst] (C4) #170"];
171 [label="independent_occupancy_parameter [cst] (N5) #171"];
172 [label="independent_fp_parameter [cst] (N5) #172"];
173 [label="independent_fdp_parameter [cst] (N5) #173"];
174 [label="independent_occupancy_parameter [cst] (C2) #174"];
175 [label="independent_fp_parameter [cst] (C2) #175"];
176 [label="independent_fdp_parameter [cst] (C2) #176"];
177 [label="independent_occupancy_parameter [cst] (C10) #177"];
178 [label="independent_fp_parameter [cst] (C10) #178"];
179 [label="independent_fdp_parameter [cst] (C10) #179"];
180 [label="independent_occupancy_parameter [cst] (C1) #180"];
181 [label="independent_fp_parameter [cst] (C1) #181"];
182 [label="independent_fdp_parameter [cst] (C1) #182"];
183 [label="independent_occupancy_parameter [cst] (C11) #183"];
184 [label="independent_fp_parameter [cst] (C11) #184"];
185 [label="independent_fdp_parameter [cst] (C11) #185"];
186 [label="independent_occupancy_parameter [cst] (C13) #186"];
187 [label="independent_fp_parameter [cst] (C13) #187"];
188 [label="independent_fdp_parameter [cst] (C13) #188"];
189 [label="independent_occupancy_parameter [cst] (C6) #189"];
190 [label="independent_fp_parameter [cst] (C6) #190"];
191 [label="independent_fdp_parameter [cst] (C6) #191"];
192 [label="independent_occupancy_parameter [cst] (N12) #192"];
193 [label="independent_fp_parameter [cst] (N12) #193"];
194 [label="independent_fdp_parameter [cst] (N12) #194"];
195 [label="independent_fp_parameter [cst] (C7A) #195"];
196 [label="independent_fdp_parameter [cst] (C7A) #196"];
197 [label="independent_occupancy_parameter [cst] (C14) #197"];
198 [label="independent_fp_parameter [cst] (C14) #198"];
199 [label="independent_fdp_parameter [cst] (C14) #199"];
200 [label="independent_fp_parameter [cst] (C7B) #200"];
201 [label="independent_fdp_parameter [cst] (C7B) #201"];
202 [label="independent_fp_parameter [cst] (C3) #202"];
203 [label="independent_fdp_parameter [cst] (C3) #203"];
204 [label="affine_asu_occupancy_parameter (C3) #204"];
205 [label="affine_asu_occupancy_parameter (C7B) #205"]
}
"""

def exercise_simple_disorder():
  ins = fnames.thpp_ins
  model = smtbx.refinement.model.from_shelx(ins)
  ls = model.least_squares()
  assert str(ls.reparametrisation).strip() == \
          expected_str_reparametrisation.strip()
  ls.build_up()
  covann = ls.covariance_matrix_and_annotations()
  assert approx_equal(covann.variance_of('C7B.occ'),
                      covann.variance_of('C7A.occ'))
  assert approx_equal(covann.variance_of('C3.occ'),
                      covann.variance_of('N3.occ'))

if __name__ == '__main__':
  exercise_simple_disorder()
  print('OK')


 *******************************************************************************


 *******************************************************************************
smtbx/refinement/constraints/tests/tst_reparametrisation.py
from __future__ import absolute_import, division, print_function

import warnings

from cctbx import uctbx, xray, sgtbx, crystal
from smtbx.refinement import constraints
import smtbx.refinement.constraints.adp
from scitbx import sparse
from scitbx import matrix as mat
from cctbx.array_family import flex
from libtbx.test_utils import approx_equal
import libtbx.utils
import smtbx.utils
from six.moves import range

class terminal_linear_ch_site_test_case(object):

  eps = 1.e-15
  bond_length = 0.9

  def __init__(self, with_special_position_pivot):
    self.with_special_position_pivot = with_special_position_pivot
    self.uc = uctbx.unit_cell((1, 2, 3))
    self.sg = sgtbx.space_group("P 6")
    self.c0 = xray.scatterer("C0", site=(1e-5, 0., 0.1))
    self.site_symm = sgtbx.site_symmetry(self.uc, self.sg, self.c0.site)
    self.c0.flags.set_grad_site(True)
    self.c1 = xray.scatterer("C1", site=(0.09, 0.11, 0.))
    self.c1.flags.set_grad_site(True)
    self.h = xray.scatterer("H")
    self.reparam = constraints.ext.reparametrisation(self.uc)
    if with_special_position_pivot:
      x0 = self.reparam.add(constraints.special_position_site_parameter,
                            self.site_symm, self.c0)
    else:
      x0 = self.reparam.add(constraints.independent_site_parameter, self.c0)
    x1 = self.reparam.add(constraints.independent_site_parameter, self.c1)
    l = self.reparam.add(constraints.independent_scalar_parameter,
                         self.bond_length, variable=False)
    x_h = self.reparam.add(constraints.terminal_linear_ch_site,
                           pivot=x0,
                           pivot_neighbour=x1,
                           length=l,
                           hydrogen=self.h)
    self.reparam.finalise()
    self.x0, self.x1, self.x_h, self.l = [ x.index for x in (x0, x1, x_h, l) ]
    if self.with_special_position_pivot:
      self.y0 = x0.independent_params.index

  def run(self):
    self.reparam.linearise()
    self.reparam.store()
    x_c0, x_c1, x_h = [ mat.col(sc.site)
                        for sc in (self.c0, self.c1, self.h) ]
    if self.with_special_position_pivot:
      assert approx_equal(x_c0, self.site_symm.exact_site(), self.eps)
    assert approx_equal(self.uc.angle(x_c1, x_c0, x_h), 180, self.eps)
    assert approx_equal(
      self.uc.distance(x_c0, x_h), self.bond_length, self.eps)

    if self.with_special_position_pivot:
      jt0 = sparse.matrix(1 + 3, # y0, x1
                          1 + 3 + 3 + 1 + 3) # y0, x0, x1, l, x_h
    else:
      jt0 = sparse.matrix(3 + 3, # x0, x1
                          3 + 3 + + 1 + 3) # x0, x1, l, x_h

    # Identity for independent parameters
    if self.with_special_position_pivot:
      jt0[self.y0, self.y0] = 1.
    for i in range(3): jt0[self.x0 + i, self.x0 + i] = 1.
    for i in range(3): jt0[self.x1 + i, self.x1 + i] = 1.

    # special position x0
    if self.with_special_position_pivot:
      jt0[self.y0, self.x0    ] = 0
      jt0[self.y0, self.x0 + 1] = 0
      jt0[self.y0, self.x0 + 2] = 1.

    # riding
    if self.with_special_position_pivot:
      jt0[self.y0, self.x_h + 2] = 1.
    else:
      for i in range(3): jt0[self.x0 + i, self.x_h + i] = 1.

    jt = self.reparam.jacobian_transpose
    assert sparse.approx_equal(self.eps)(jt, jt0)


class special_position_adp_test_case(object):

  eps = 1.e-15

  def __init__(self):
    cs = crystal.symmetry(uctbx.unit_cell((1, 1, 2, 90, 90, 120)), 'R3')
    sgi = sgtbx.space_group_info('R3(y+z, x+z, x+y+z)')
    op = sgi.change_of_basis_op_to_reference_setting()
    self.cs = cs.change_basis(op.inverse())
    self.sc = xray.scatterer('C',
                             site=(3/8,)*3,
                             u=(1/2, 1/4, 3/4, -3/2, -3/4, -1/4))
    self.sc.flags.set_grad_u_aniso(True)
    self.site_symm = sgtbx.site_symmetry(self.cs.unit_cell(),
                                         self.cs.space_group(),
                                         self.sc.site)
    self.reparam = constraints.ext.reparametrisation(self.cs.unit_cell())
    u = self.reparam.add(constraints.special_position_u_star_parameter,
                         self.site_symm, self.sc)
    self.reparam.finalise()
    self.u, self.v = u.index, u.independent_params.index

  def run(self):
    self.reparam.linearise()
    self.reparam.store()
    assert approx_equal(self.sc.u_star, (19/6, 19/6, 17/2,
                                         11/6, 9/2, 9/2), self.eps)
    jt0 = sparse.matrix(2, 8)
    jt0[0, 0] = 1
    jt0[1, 1] = 1
    jac_u_star_trans = self.site_symm.adp_constraints().gradient_sum_matrix()
    jac_u_star_trans.reshape(flex.grid(
      self.site_symm.adp_constraints().n_independent_params(), 6))
    (m,n) = jac_u_star_trans.focus()
    for i in range(m):
      for j in range(n):
        jt0[i, j + 2] = jac_u_star_trans[i, j]
    jt = self.reparam.jacobian_transpose
    assert sparse.approx_equal(self.eps)(jt, jt0)


class c_oh_test_case(object):

  eps = 1.e-15
  bond_length = 0.9

  def __init__(self, staggered, verbose=False):
    self.staggered = staggered
    self.verbose = verbose
    self.cs = crystal.symmetry(uctbx.unit_cell((1, 1, 2, 90, 90, 80)),
                               "hall: P 2z")
    self.o = xray.scatterer('O', site=(0,0,0))
    self.o.flags.set_grad_site(True)
    self.c1 = xray.scatterer('C1', site=(1.5, 0, 0))
    self.c2 = xray.scatterer('C2', site=(2.5, 1, 0))
    self.h = xray.scatterer('H')
    self.reparam = constraints.ext.reparametrisation(self.cs.unit_cell())
    xo = self.reparam.add(constraints.independent_site_parameter, self.o)
    x1 = self.reparam.add(constraints.independent_site_parameter, self.c1)
    x2 = self.reparam.add(constraints.independent_site_parameter, self.c2)
    l = self.reparam.add(constraints.independent_scalar_parameter,
                         value=self.bond_length, variable=False)
    phi = self.reparam.add(constraints.independent_scalar_parameter,
                           value=0, variable=False)
    uc = self.cs.unit_cell()
    _ = mat.col
    if staggered:
      xh = self.reparam.add(
        constraints.staggered_terminal_tetrahedral_xh_site,
        pivot=xo,
        pivot_neighbour=x1,
        stagger_on=x2,
        length=l,
        hydrogen=(self.h,))
    else:
      xh = self.reparam.add(
        constraints.terminal_tetrahedral_xh_site,
        pivot=xo,
        pivot_neighbour=x1,
        azimuth=phi,
        length=l,
        e_zero_azimuth=uc.orthogonalize(_(self.c2.site) - _(self.c1.site)),
        hydrogen=(self.h,))
    self.reparam.finalise()
    self.xh, self.xo, self.x1, self.x2 = [ x.index for x in (xh, xo, x1, x2) ]
    self.l, self.phi = l.index, phi.index

  def run(self):
    self.reparam.linearise()
    self.reparam.store()
    uc = self.cs.unit_cell()
    _ = mat.col
    xh, xo, x1, x2 = [ uc.orthogonalize(sc.site)
                       for sc in (self.h, self.o, self.c1, self.c2) ]
    u_12 = _(x2) - _(x1)
    u_o1 = _(x1) - _(xo)
    u_oh = _(xh) - _(xo)
    assert approx_equal(u_12.cross(u_o1).dot(u_oh), 0, self.eps)
    assert approx_equal(u_12.cross(u_o1).angle(u_oh, deg=True), 90, self.eps)
    assert approx_equal(abs(u_oh), self.bond_length, self.eps)
    assert approx_equal(u_o1.angle(u_oh, deg=True), 109.47, 0.01)

    jt0 = sparse.matrix(3, 14)
    for i in range(3):
      jt0[self.xo + i, self.xo + i] = 1.
      jt0[self.xo + i, self.xh + i] = 1.
    jt = self.reparam.jacobian_transpose
    assert sparse.approx_equal(self.eps)(jt, jt0)

    if self.verbose:
      # finite difference derivatives to compare with
      # the crude riding approximation used for analytical ones
      def differentiate(sc):
        eta = 1.e-4
        jac = []
        for i in range(3):
          x0 = tuple(sc.site)
          x = list(x0)
          x[i] += eta
          sc.site = tuple(x)
          self.reparam.linearise()
          self.reparam.store()
          xp = _(self.h.site)
          x[i] -= 2*eta
          sc.site = tuple(x)
          self.reparam.linearise()
          self.reparam.store()
          xm = _(self.h.site)
          sc.site = tuple(x0)
          jac.extend( (xp - xm)/(2*eta) )
        return mat.sqr(jac)

      jac_o = differentiate(self.o)
      jac_1 = differentiate(self.c1)
      jac_2 = differentiate(self.c2)
      print("staggered: %s" % self.staggered)
      print("J_o:")
      print(jac_o.mathematica_form())
      print("J_1:")
      print(jac_1.mathematica_form())
      print("J_2:")
      print(jac_2.mathematica_form())

def exercise_symmetry_equivalent():
  xs = xray.structure(
    crystal_symmetry=crystal.symmetry(
      unit_cell=(1, 2, 3),
      space_group_symbol='hall: P 2x'),
    scatterers=flex.xray_scatterer((
      xray.scatterer("C", site=(0.1, 0.2, 0.3)),
    )))
  xs.scatterers()[0].flags.set_grad_site(True)
  connectivity_table = smtbx.utils.connectivity_table(xs)
  reparametrisation = constraints.reparametrisation(
    xs, [], connectivity_table)
  site_0 = reparametrisation.add(constraints.independent_site_parameter,
                                 scatterer=xs.scatterers()[0])
  g = sgtbx.rt_mx('x,-y,-z')
  symm_eq = reparametrisation.add(
    constraints.symmetry_equivalent_site_parameter,
    site=site_0, motion=g)
  reparametrisation.finalise()

  assert approx_equal(symm_eq.original.scatterers[0].site, (0.1, 0.2, 0.3),
                      eps=1e-15)
  assert str(symm_eq.motion) == 'x,-y,-z'
  assert symm_eq.is_variable
  reparametrisation.linearise()
  assert approx_equal(symm_eq.value, g*site_0.value, eps=1e-15)

  reparametrisation.store()
  assert approx_equal(symm_eq.value, (0.1, -0.2, -0.3), eps=1e-15)
  assert approx_equal(site_0.value, (0.1, 0.2, 0.3), eps=1e-15)

def exercise_u_iso_proportional_to_pivot_u_eq():
  xs = xray.structure(
    crystal_symmetry=crystal.symmetry(
      unit_cell=(),
      space_group_symbol='hall: P 2x 2y'),
    scatterers=flex.xray_scatterer((
      xray.scatterer('C0', u=(1, 1, 1, 0, 0, 0)),
      xray.scatterer('C1'),
      xray.scatterer('C2', site=(0.1, 0.2, 0.3), u=(1, 2, 3, 0, 0, 0)),
      xray.scatterer('C3'),
      )))
  r = constraints.ext.reparametrisation(xs.unit_cell())
  sc = xs.scatterers()
  sc[0].flags.set_grad_u_aniso(True)
  sc[2].flags.set_grad_u_aniso(True)

  u_0 = r.add(constraints.special_position_u_star_parameter,
              site_symmetry=xs.site_symmetry_table().get(0),
              scatterer=sc[0])
  u_iso_1 = r.add(constraints.u_iso_proportional_to_pivot_u_eq,
                pivot_u=u_0,
                multiplier=3,
                scatterer=sc[1])
  u_2 = r.add(constraints.independent_u_star_parameter, sc[2])
  u_iso_3 = r.add(constraints.u_iso_proportional_to_pivot_u_eq,
                pivot_u=u_2,
                multiplier=2,
                scatterer=sc[3])
  r.finalise()
  m = 3 + 6
  n = m + 6 + 1 + 1
  r.linearise()
  assert approx_equal(u_iso_1.value, 3, eps=1e-15)
  assert approx_equal(u_iso_3.value, 4, eps=1e-15)
  jt0 = sparse.matrix(m, n)
  for i in range(m): jt0[i, i] = 1
  p, q = u_0.argument(0).index, u_0.index
  jt0[p, q] = jt0[p+1, q+1] = jt0[p+2, q+2] = 1
  q = u_iso_1.index
  jt0[p, q] = jt0[p+1, q] = jt0[p+2, q] = 1
  p, q = u_2.index, u_iso_3.index
  jt0[p, q] = jt0[p+1, q] = jt0[p+2, q] = 2/3
  assert sparse.approx_equal(tolerance=1e-15)(r.jacobian_transpose, jt0)

def exercise_u_iso_proportional_to_pivot_u_iso():
  # Test working constraint
  xs = xray.structure(
    crystal_symmetry=crystal.symmetry(
      unit_cell=(),
      space_group_symbol='hall: P 2x 2y'),
    scatterers=flex.xray_scatterer((
      xray.scatterer('C0', u=0.12),
      xray.scatterer('C1'),
      )))
  r = constraints.ext.reparametrisation(xs.unit_cell())
  sc = xs.scatterers()

  u_iso = r.add(constraints.independent_u_iso_parameter, sc[0])
  u_iso_1 = r.add(constraints.u_iso_proportional_to_pivot_u_iso,
                pivot_u_iso=u_iso,
                multiplier=2,
                scatterer=sc[1])
  r.finalise()
  r.linearise()
  assert approx_equal(u_iso_1.value, 0.24, eps=1e-15)

  # Test conflicting constraints
  xs = xray.structure(
    crystal_symmetry=crystal.symmetry(
      unit_cell=(),
      space_group_symbol='hall: P 2x 2y'),
    scatterers=flex.xray_scatterer((
      xray.scatterer('C0', u=0.12),
      xray.scatterer('C1', u=0.21),
      xray.scatterer('C2')
    )))
  with warnings.catch_warnings(record=True) as w:
    warnings.simplefilter("always")
    r = constraints.reparametrisation(
      structure=xs,
      constraints=[constraints.adp.shared_u((0, 2)),
                   constraints.adp.shared_u((1, 2))],
      connectivity_table=smtbx.utils.connectivity_table(xs))
    assert len(w) == 1
    assert w[-1].category == constraints.ConflictingConstraintWarning
    assert w[-1].message.conflicts == set(((2, 'U'),))


def exercise_affine_occupancy_parameter():
  xs = xray.structure(
    crystal_symmetry=crystal.symmetry(unit_cell=(), space_group_symbol='hall: P 1'),
    scatterers=flex.xray_scatterer((
      xray.scatterer('C0', occupancy=1),
      xray.scatterer('C1', occupancy=1),
      xray.scatterer('C2', occupancy=1),
      xray.scatterer('C3', occupancy=1),
    )))
  sc = xs.scatterers()
  sc.flags_set_grad_occupancy(flex.size_t_range(4))

  # Two occupancies adding up to 1 (most common case of disorder)
  r = constraints.ext.reparametrisation(xs.unit_cell())
  occ_1 = r.add(constraints.independent_occupancy_parameter, sc[1])
  occ_3 = r.add(constraints.affine_asu_occupancy_parameter,
                dependee=occ_1, a=-1, b=1, scatterer=sc[3])
  r.finalise()
  r.linearise()
  assert approx_equal(occ_1.value, 1)
  assert approx_equal(occ_3.value, 0)
  jt0 = sparse.matrix(1, 2,
                     [ {0:1},   # 1st col = derivatives of occ_1
                       {0:-1},   # 2nd col = derivatives of occ_3
                     ])
  assert sparse.approx_equal(tolerance=1e-15)(r.jacobian_transpose, jt0)

  # Example illustrating the instruction SUMP in SHELX 97 manual (p. 7-26)
  # We disregard the issue of the special position which is orthogonal to the
  # point we want to test here.
  xs = xray.structure(
    crystal_symmetry=crystal.symmetry(unit_cell=(), space_group_symbol='hall: P 1'),
    scatterers=flex.xray_scatterer((
      xray.scatterer('Na+', occupancy=1),
      xray.scatterer('Ca2+', occupancy=1),
      xray.scatterer('Al3+', occupancy=0.35),
      xray.scatterer('K+', occupancy=0.15),
    )))
  sc = xs.scatterers()
  sc.flags_set_grad_occupancy(flex.size_t_range(4))

  # The constraints are:
  # fully occupied: occ(Na+) + occ(Ca2+) + occ(Al3+) + occ(K+) = 1
  # average charge +2: occ(Na+) + 2 occ(Ca2+) + 3 occ(Al3+) + occ(K+) = +2
  # This can be solved as:
  # occ(Na+)  = occ(Al3+) - occ(K+)
  # occ(Ca2+) = 1 - 2 occ(Al3+)
  r = constraints.ext.reparametrisation(xs.unit_cell())
  occ_Al = r.add(constraints.independent_occupancy_parameter, sc[2])
  occ_K  = r.add(constraints.independent_occupancy_parameter, sc[3])
  occ_Na = r.add(constraints.affine_asu_occupancy_parameter,
                 occ_Al, 1, occ_K, -1, 0, scatterer=sc[0])
  occ_Ca = r.add(constraints.affine_asu_occupancy_parameter,
                 occ_Al, -2, 1, scatterer=sc[1])
  r.finalise()
  r.linearise()
  assert approx_equal(occ_Na.value, 0.2)
  assert approx_equal(occ_Ca.value, 0.3)
  assert approx_equal(occ_Al.value, 0.35)
  assert approx_equal(occ_K.value, 0.15)
  jt0 = sparse.matrix(2, 4,
                     [
                       {0:1},         # diff occ(Al3+)
                       {1:1} ,        # diff occ(K+)
                       {0:1, 1:-1},   # diff occ(Na+)
                       {0:-2},        # diff occ(Ca2+)
                     ])
  assert sparse.approx_equal(tolerance=1e-15)(r.jacobian_transpose, jt0)

def exercise(verbose):
  exercise_affine_occupancy_parameter()
  exercise_u_iso_proportional_to_pivot_u_eq()
  exercise_u_iso_proportional_to_pivot_u_iso()
  terminal_linear_ch_site_test_case(with_special_position_pivot=False).run()
  terminal_linear_ch_site_test_case(with_special_position_pivot=True).run()
  special_position_adp_test_case().run()
  c_oh_test_case(staggered=False, verbose=verbose).run()
  c_oh_test_case(staggered=True, verbose=verbose).run()
  exercise_symmetry_equivalent()

def run():
  libtbx.utils.show_times_at_exit()
  import sys
  exercise('--verbose' in sys.argv)

if __name__ == '__main__':
  run()


 *******************************************************************************


 *******************************************************************************
smtbx/refinement/constraints/tests/tst_rigid.py
from __future__ import absolute_import, division, print_function

from cctbx.array_family import flex
from scitbx import sparse
from cctbx import uctbx, xray, crystal
from smtbx.refinement import constraints
from math import pi
import math
from scitbx.matrix import col
from scitbx import matrix as mat
from libtbx.test_utils import approx_equal
from smtbx.refinement.constraints import rigid
from six.moves import range

def exercise_rigid_site_proxy(n=5):
  uc = uctbx.unit_cell((1, 2, 3))
  reparam = constraints.ext.reparametrisation(uc)
  independents = [ ]
  for name in ('C#', 'C##'):
    sc = xray.scatterer(name, site=tuple(flex.random_double(3)))
    sc.flags.set_grad_site(True)
    p = reparam.add(constraints.independent_site_parameter, sc)
    independents.append(p)
  pivot, pivot_neighbour = independents
  rigid_group_scatterers = [ ]
  for i in range(n):
    sc = xray.scatterer('C%i' %i,
                        site=tuple(flex.random_double(3)))
    sc.flags.set_grad_site(True)
    rigid_group_scatterers.append(sc)
  phi = reparam.add(constraints.independent_scalar_parameter,
                    value=0.1, variable=True)
  size = reparam.add(constraints.independent_scalar_parameter,
                    value=1, variable=True)
  rigid_group = reparam.add(constraints.rigid_pivoted_rotatable_group,
                            pivot, pivot_neighbour,
                            azimuth=phi,
                            size=size,
                            scatterers=rigid_group_scatterers)
  proxies = [ ]
  for i in range(n):
    proxies.append(reparam.add(constraints.rigid_site_proxy,
                               parent=rigid_group,
                               index=i))
  reparam.finalise()

  assert str(reparam) == """\
digraph dependencies {
8 -> 0;
8 -> 3;
8 -> 6;
8 -> 7;
23 -> 8;
26 -> 8;
29 -> 8;
32 -> 8;
35 -> 8;
0 [label="independent_site_parameter (C#) #0"];
3 [label="independent_site_parameter (C##) #3"];
6 [label="independent_scalar_parameter #6"];
7 [label="independent_scalar_parameter #7"];
8 [label="rigid_pivoted_rotatable_group (C0, C1, C2, C3, C4) #8"];
23 [label="rigid_site_proxy #23"];
26 [label="rigid_site_proxy #26"];
29 [label="rigid_site_proxy #29"];
32 [label="rigid_site_proxy #32"];
35 [label="rigid_site_proxy #35"]
}"""

  reparam.linearise()
  jt = reparam.jacobian_transpose

  q = 2*3 + 1 + 1 # pivot, its neighbour, azimuthal angle, size
  jt0 = sparse.matrix(q, q + 2*3*n) # + rigid_group + constrained site proxies
  assert jt.n_rows == jt0.n_rows
  assert jt.n_cols == jt0.n_cols
  for i,j in zip(range(q, q+3*n), range(q+3*n, jt0.n_cols)):
    assert jt.col(i) == jt.col(j)

def exercise_rigid_pivoted_rotatable():
  uc = uctbx.unit_cell((1, 1, 1))
  xs = xray.structure(
    crystal_symmetry=crystal.symmetry(
      unit_cell=uc,
      space_group_symbol='hall: P 2x 2y'),
    scatterers=flex.xray_scatterer(( #triangle
      xray.scatterer('C0', site=(0,0,0)),
      xray.scatterer('C1', site=(0,2,0)),
      xray.scatterer('C2', site=(1,1,0)),
      )))
  r = constraints.ext.reparametrisation(xs.unit_cell())
  sc = xs.scatterers()
  pivot = r.add(constraints.independent_site_parameter, sc[0])
  pivot_neighbour = r.add(constraints.independent_site_parameter, sc[1])
  azimuth = r.add(constraints.independent_scalar_parameter,
                  value=pi/2, variable=True)
  size = r.add(constraints.independent_scalar_parameter,
                  value=1, variable=False)
  rg = r.add(constraints.rigid_pivoted_rotatable_group,
                pivot=pivot,
                pivot_neighbour=pivot_neighbour,
                azimuth=azimuth,
                size=size,
                scatterers=(sc[1], sc[2]))
  site_proxy = r.add(constraints.rigid_site_proxy, rg, 1)
  r.finalise()
  r.linearise()
  r.store()
  #check that proxy and the final results are the same...
  assert approx_equal(
    uc.distance(col(site_proxy.value), col(sc[2].site)), 0, eps=1e-15)
  #rotation happens around the center of gravity
  assert approx_equal(
    uc.distance(col((0,1,1)), col(sc[2].site)), 0, eps=1e-15)

class rigid_rotatable(object):
  def __init__(self):
    self.size_value = 9
    self.rx = pi
    self.ry = pi/2
    self.rz = pi/3
    self.sites = ((0,0,0), (1,0,0), (0,1,0), (0,0,1))
    self.uc = uctbx.unit_cell((1, 1, 1))
    self.xs = xray.structure(
      crystal_symmetry=crystal.symmetry(
        unit_cell=self.uc,
        space_group_symbol='hall: P 2x 2y'),
      scatterers=flex.xray_scatterer(( #triangle
        xray.scatterer('C0'),
        xray.scatterer('C1'),
        xray.scatterer('C2'),
        xray.scatterer('C3'),
        )))
    self.center = col((0,0,0))
    for s in self.sites:
      self.center = self.center + col(s)
    self.center = self.center / len(self.sites)
    self.reset_sites()
  def reset_sites(self):
    sc = self.xs.scatterers()
    for i, s in enumerate(self.sites):
      sc[i].site = s
  def exercise_expansion(self):
    self.reset_sites()
    r = constraints.ext.reparametrisation(self.uc)
    sc = self.xs.scatterers()
    pivot = r.add(constraints.independent_site_parameter, sc[0])
    size = r.add(constraints.independent_scalar_parameter,
                    value=self.size_value, variable=True)
    r_x = r.add(constraints.independent_scalar_parameter,
                    value=0, variable=False)
    r_y = r.add(constraints.independent_scalar_parameter,
                    value=0, variable=False)
    r_z = r.add(constraints.independent_scalar_parameter,
                    value=0, variable=False)
    rg = r.add(constraints.rigid_rotatable_expandable_group,
                  pivot=pivot,
                  size = size,
                  alpha = r_x,
                  beta = r_y,
                  gamma = r_z,
                  scatterers=(sc[1], sc[2], sc[3]))
    r.finalise()
    r.linearise()
    r.store()
    shift = col(self.sites[0]) - (col(self.sites[0])-self.center)*self.size_value
    for i in range(1,4):
      calc_site = (col(self.sites[i])-self.center)*self.size_value + shift
      assert approx_equal(
        self.uc.distance(
          calc_site, col(sc[i].site)), 0, eps=1e-14)
  def exercise_rotation(self):
    self.reset_sites()
    r = constraints.ext.reparametrisation(self.uc)
    sc = self.xs.scatterers()
    pivot = r.add(constraints.independent_site_parameter, sc[0])
    size = r.add(constraints.independent_scalar_parameter,
                    value=1, variable=False)
    r_x = r.add(constraints.independent_scalar_parameter,
                    value=pi, variable=True)
    r_y = r.add(constraints.independent_scalar_parameter,
                    value=pi/2, variable=True)
    r_z = r.add(constraints.independent_scalar_parameter,
                    value=pi/3, variable=True)
    rg = r.add(constraints.rigid_rotatable_expandable_group,
                  pivot=pivot,
                  size = size,
                  alpha = r_x,
                  beta = r_y,
                  gamma = r_z,
                  scatterers=(sc[1], sc[2], sc[3]))
    r.finalise()
    r.linearise()
    r.store()
    rx_m = mat.sqr((1, 0, 0,
                0, math.cos(self.rx), -math.sin(self.rx),
                0, math.sin(self.rx), math.cos(self.rx)))
    ry_m = mat.sqr((math.cos(self.ry), 0, math.sin(self.ry),
                    0, 1, 0,
                    -math.sin(self.ry), 0, math.cos(self.ry)))
    rz_m = mat.sqr((math.cos(self.rz), -math.sin(self.rz), 0,
                    math.sin(self.rz), math.cos(self.rz), 0,
                    0, 0, 1))
    R = rx_m*ry_m*rz_m #comulative rotation matrix
    shift = col(self.sites[0])-col(mat.row(col(self.sites[0])-self.center)*R)
    for i in range(1,4):
      calc_site = col(mat.row(col(self.sites[i])-self.center)*R) + shift
      assert approx_equal(
        self.uc.distance(
          calc_site, col(sc[i].site)), 0, eps=1e-14)
  def excercise(self):
    self.exercise_expansion()
    self.exercise_rotation()

class idealised(object):
  def __init__(self):
    self.def_len_ref = {
      "Naphthalene" : ((0.695,-1.203775),
                       (-0.695,-1.203775),
                       (-1.39,-0),
                       (-0.695,1.203775),
                       (0.695,1.203775),
                       (1.39,0),
                       (2.78,0),
                       (3.475,1.203775),
                       (2.78,2.407551),
                       (1.39,2.407551)),
      "Cp*" :         ((0.373269,-1.148804),
                       (-0.977231,-0.71),
                       (-0.977231,0.71),
                       (0.373269,1.148804),
                       (1.207924,0),
                       (0.701754,-2.159777),
                       (-1.837216,-1.334816),
                       (-1.837216,1.334816),
                       (0.701754,2.159777),
                       (2.270924,0)),
      "Cp" :          ((0.373269,-1.148804),
                       (-0.977231,-0.71),
                       (-0.977231,0.71),
                       (0.373269,1.148804),
                       (1.207924,0)),
      "Ph" :          ((0.695,-1.203775),
                       (-0.695,-1.203775),
                       (-1.39,-0),
                       (-0.695,1.203775),
                       (0.695,1.203775),
                       (1.39,0))
    }
    self.tested = rigid.idealised_fragment()

  def compare_results(self, _a , _b):
    for i, a in enumerate(_a):
      assert approx_equal(a.x, _b[i][0], 1e-6)
      assert approx_equal(a.y, _b[i][1], 1e-6)

  def exercise_generation(self):
    frags = ("Cp", "Ph", "Cp*", "Naphthalene")
    for i in frags:
      self.compare_results(
        self.tested.generate_fragment(i), self.def_len_ref[i])

  def exercise_fitting(self):
    source_pts_indices = [1, 2, 5]
    ref_sites = ((-0.695,-1.203775,0), (-1.39,-0,0), (1.39,0,0))
    control_pts_indices = [0, 1, 4]
    fragment = self.tested.generate_fragment("Ph")
    crds = self.tested.fit(fragment, ref_sites, control_pts_indices)
    uc = uctbx.unit_cell((1, 1, 1))
    for i, p in enumerate(source_pts_indices):
      approx_equal(
        uc.distance(
          col((fragment[p].x,fragment[p].y,0)),
          crds[control_pts_indices[i]]), 1e-14)

  def exercise(self):
    self.exercise_generation()
    self.exercise_fitting()

def run():
  exercise_rigid_site_proxy()
  exercise_rigid_pivoted_rotatable()
  rigid_rotatable().excercise()
  idealised().exercise()
  print('OK')

if __name__ == '__main__':
  run()


 *******************************************************************************


 *******************************************************************************
smtbx/refinement/constraints/tests/tst_same_group.py
from __future__ import absolute_import, division, print_function

from cctbx import crystal, xray
from cctbx.array_family import flex
from smtbx.refinement import constraints, model
from scitbx import matrix
import math
from libtbx.test_utils import approx_equal
import os
from smtbx.regression.test_data import fnames

def exercise_basics():
  # construct a simple structure whose sites and u_iso's are to be refined
  xs = xray.structure(
    crystal_symmetry=crystal.symmetry(
      unit_cell=(10, 10, 10, 90, 90, 90),
      space_group_symbol='hall: P 1'),
    scatterers=flex.xray_scatterer((
      xray.scatterer('C0', site=(0, -1/2, 0), u=0.1),
      xray.scatterer('C1', site=(0,  1/2, 0), u=0.2),
      xray.scatterer('C0a', site=( 1/2, 0, 0), u=0.1),
      xray.scatterer('C1a', site=(-1/2, 0, 0), u=0.2),
    )))
  for sc in xs.scatterers():
    sc.flags.set_grad_site(True)
    sc.flags.set_grad_u_iso(True)

  # copy the original structure as a reference to test against later
  xs_ref = xs.deep_copy_scatterers()

  # mess up the symmetries that the forthcoming constraints shall impose
  c0, c1, c0a, c1a = xs.scatterers()
  c0a.site = (0, 0, 0)
  c1a.site = (1/2, 1/2, 1/2)
  c0a.u_iso = 0.5
  c1a.u_iso = 0.6

  # construct a reparametrisation for the following constraints:
  # (C0a, C1a) is the image of (C0, C1) through a rotation of 90 degrees
  # about the z-axis
  r = constraints.ext.reparametrisation(xs.unit_cell())
  sc_params = constraints.shared_scatterer_parameters(xs.scatterers())
  c0_site_param  = r.add(constraints.independent_site_parameter, c0)
  sc_params[0].site = c0_site_param
  c1_site_param = r.add(constraints.independent_site_parameter, c1)
  sc_params[1].site = c1_site_param
  move_param = r.add(
    constraints.independent_small_6_vector_parameter,
    (0,0,0, 0, 0, math.pi/2))
  c0a_c1a_site_param = r.add(
    constraints.same_group_xyz,
    scatterers=(c0a, c1a),
    sites=(c0_site_param, c1_site_param),
    alignment_matrix=matrix.identity(3),
    shifts_and_angles=move_param)
  sc_params[2].site = sc_params[3].site = c0a_c1a_site_param
  c0_u_iso_param = r.add(constraints.independent_u_iso_parameter, c0)
  sc_params[0].u = c0_u_iso_param
  c1_u_iso_param = r.add(constraints.independent_u_iso_parameter, c1)
  sc_params[1].u = c1_u_iso_param
  c0a_c1a_u_iso_param = r.add(
    constraints.same_group_u_iso,
    scatterers=(c0a, c1a),
    u_isos=(c0_u_iso_param, c1_u_iso_param))
  sc_params[2].u = sc_params[3].u = c0a_c1a_u_iso_param
  r.finalise()

  # put the reparametrisation to work
  r.linearise()
  r.store()
  c0_ref, c1_ref, c0a_ref, c1a_ref = xs_ref.scatterers()
  assert approx_equal(c0a.site, c0a_ref.site, eps=1e-12)
  assert approx_equal(c1a.site, c1a_ref.site, eps=1e-12)
  assert approx_equal(c0a.u_iso, c0a_ref.u_iso, eps=1e-12)
  assert approx_equal(c1a.u_iso, c1a_ref.u_iso, eps=1e-12)

  # check that origin fixing restraints work in the presence of
  # that reparametrisation
  # this is a regression test as they used not to (bug reported by Oleg)
  from smtbx.refinement.restraints import origin_fixing_restraints
  from scitbx import lstbx
  orig_fixing = origin_fixing_restraints.homogeneous_weighting(xs.space_group())
  normal_eqn = lstbx.normal_eqns.ext.linear_ls(n_parameters=(3 + 1)*2 + 6)
  jacobian_transpose_matching_grad_fc = r.jacobian_transpose_matching(
    sc_params.mapping_to_grad_fc())
  orig_fixing.add_to(normal_eqn,
                     jacobian_transpose_matching_grad_fc,
                     sc_params)

def exercise_real_life_structure():
  working_dir = os.path.dirname(__file__)
  res = fnames.sucrose_p1_res
  xs = xray.structure.from_shelx(filename=res)
  fo_sq = xs.structure_factors(
    d_min=0.5, algorithm='direct').f_calc().intensities()
  fo_sq.set_sigmas(fo_sq.data()*0.05)
  m = model.from_shelx(res, fo_sq=fo_sq)
  ls = m.least_squares()
  ls.build_up()
  # wip

if __name__ == '__main__':
  exercise_basics()
  exercise_real_life_structure()
  print('OK')


 *******************************************************************************


 *******************************************************************************
smtbx/refinement/least_squares.py
from __future__ import absolute_import, division, print_function
import boost_adaptbx.boost.python as bp
ext = bp.import_ext("smtbx_refinement_least_squares_ext")
from smtbx_refinement_least_squares_ext import *


import smtbx.refinement.weighting_schemes # import dependency
from cctbx import xray
import libtbx.load_env
from libtbx import adopt_optional_init_args
from scitbx import linalg
from scitbx.lstbx import normal_eqns
from scitbx.array_family import flex
from smtbx.structure_factors import direct
from smtbx.refinement.restraints import origin_fixing_restraints
import math

def crystallographic_ls_class(non_linear_ls_with_separable_scale_factor=None):
  """ Construct a class for crystallographic L.S. based on the given engine
  """
  def get_base_class(non_linear_ls_with_separable_scale_factor):
    base_class = non_linear_ls_with_separable_scale_factor
    if not base_class:
      try:
        from fast_linalg import env
        if env.initialised:
          base_class = normal_eqns.non_linear_ls_with_separable_scale_factor_BLAS_3
        else:
          base_class = normal_eqns.non_linear_ls_with_separable_scale_factor_BLAS_2
      except Exception:
        base_class = normal_eqns.non_linear_ls_with_separable_scale_factor_BLAS_2
    #print("Chosen: " + str(base_class))
    return base_class

  class klass(get_base_class(non_linear_ls_with_separable_scale_factor)):

    non_linear_ls_engine = get_base_class(non_linear_ls_with_separable_scale_factor)

    default_weighting_scheme = mainstream_shelx_weighting
    weighting_scheme = "default"
    origin_fixing_restraints_type = (
      origin_fixing_restraints.atomic_number_weighting)
    f_mask = None
    restraints_manager=None
    n_restraints = None
    initial_scale_factor = None
    may_parallelise = False

    def __init__(self, observations, reparametrisation,
                 one_h_linearisation=None, **kwds):
      super(klass, self).__init__(reparametrisation.n_independents)
      self.observations = observations
      self.reparametrisation = reparametrisation
      adopt_optional_init_args(self, kwds)
      if self.f_mask is not None:
        assert self.f_mask.size() == observations.fo_sq.size()
      self.one_h_linearisation = one_h_linearisation
      if not self.one_h_linearisation:
        self.one_h_linearisation = direct.f_calc_modulus_squared(
          self.xray_structure)
      if self.weighting_scheme == "default":
        self.weighting_scheme = self.default_weighting_scheme()
      self.origin_fixing_restraint = self.origin_fixing_restraints_type(
        self.xray_structure.space_group())
      self.taken_step = None
      self.restraints_normalisation_factor = None

    @property
    def xray_structure(self):
      return self.reparametrisation.structure

    @property
    def twin_fractions(self):
      return self.reparametrisation.twin_fractions

    def build_up(self, objective_only=False):
      if self.f_mask is not None:
        f_mask = self.f_mask.data()
      else:
        f_mask = flex.complex_double()

      extinction_correction = self.reparametrisation.extinction
      if extinction_correction is None:
        extinction_correction = xray.dummy_extinction_correction()

      def build_normal_eqns(scale_factor, weighting_scheme, objective_only):
        return ext.build_normal_equations(
          self,
          self.observations,
          f_mask,
          weighting_scheme,
          scale_factor,
          self.one_h_linearisation,
          self.reparametrisation.jacobian_transpose_matching_grad_fc(),
          extinction_correction,
          objective_only,
          self.may_parallelise)

      if not self.finalised: #i.e. never been called
        self.reparametrisation.linearise()
        self.reparametrisation.store()
        scale_factor = self.initial_scale_factor
        if scale_factor is None: # we haven't got one from previous refinement
          result = build_normal_eqns(scale_factor=None,
                                     weighting_scheme=sigma_weighting(),
                                     objective_only=True)
          scale_factor = self.scale_factor()
      else: # use scale factor from the previous step
        scale_factor = self.scale_factor()

      self.reset()
      result = build_normal_eqns(scale_factor,
                                 self.weighting_scheme,
                                 objective_only)
      self.f_calc = self.observations.fo_sq.array(
        data=result.f_calc(), sigmas=None)
      self.fc_sq = self.observations.fo_sq.array(
        data=result.observables(), sigmas=None)\
          .set_observation_type_xray_intensity()
      self.weights = result.weights()
      self.objective_data_only = self.objective()
      self.chi_sq_data_only = self.chi_sq()
      if self.restraints_manager is not None:
        # Here we determine a normalisation factor to place the restraints on the
        # same scale as the average residual. This is the normalisation
        # factor suggested in Giacovazzo and similar to that used by shelxl.
        # (shelx manual, page 5-1).
        # The factor 2 comes from the fact that we minimize 1/2 sum w delta^2
        if self.restraints_normalisation_factor is None:
          self.restraints_normalisation_factor \
              = 2 * self.objective_data_only/(self.n_equations-self.n_parameters)
        linearised_eqns = self.restraints_manager.build_linearised_eqns(
          self.xray_structure, self.reparametrisation.parameter_map())
        jacobian = \
          self.reparametrisation.jacobian_transpose_matching(
            self.reparametrisation.mapping_to_grad_fc_all).transpose()
        self.reduced_problem().add_equations(
          linearised_eqns.deltas,
          linearised_eqns.design_matrix * jacobian,
          linearised_eqns.weights * self.restraints_normalisation_factor,
          optimise_for_tall_matrix=False)
        self.n_restraints = linearised_eqns.n_restraints()
        self.chi_sq_data_and_restraints = self.chi_sq()
      if not objective_only:
        self.origin_fixing_restraint.add_to(
          self.step_equations(),
          self.reparametrisation.jacobian_transpose_matching_grad_fc(),
          self.reparametrisation.asu_scatterer_parameters)

    def parameter_vector_norm(self):
      return self.reparametrisation.norm_of_independent_parameter_vector

    def scale_factor(self): return self.optimal_scale_factor()

    def step_forward(self):
      self.reparametrisation.apply_shifts(self.step())
      self.reparametrisation.linearise()
      self.reparametrisation.store()
      self.taken_step = self.step().deep_copy()

    def step_backward(self):
      self.reparametrisation.apply_shifts(-self.taken_step)
      self.reparametrisation.linearise()
      self.reparametrisation.store()
      self.taken_step = None

    def goof(self):
      return math.sqrt(self.chi_sq_data_only)

    def restrained_goof(self):
      if self.restraints_manager is None:
        return self.goof()
      return math.sqrt(self.chi_sq_data_and_restraints)

    def wR2(self, cutoff_factor=None):
      if cutoff_factor is None:
        return math.sqrt(2*self.objective_data_only)
      fo_sq = self.observations.fo_sq
      strong = fo_sq.data() >= cutoff_factor*fo_sq.sigmas()
      fo_sq = fo_sq.select(strong)
      fc_sq = self.fc_sq.select(strong)
      wght = self.weights.select(strong)
      fc_sq = fc_sq.data()
      fo_sq = fo_sq.data()
      fc_sq *= self.scale_factor()
      wR2 = flex.sum(wght*flex.pow2((fo_sq-fc_sq)))/flex.sum(wght*flex.pow2(fo_sq))
      return math.sqrt(wR2)

    def r1_factor(self, cutoff_factor=None):
      fo_sq = self.observations.fo_sq
      if cutoff_factor is not None:
        strong = fo_sq.data() >= cutoff_factor*fo_sq.sigmas()
        fo_sq = fo_sq.select(strong)
        fc_sq = self.fc_sq.select(strong)
      else:
        fc_sq = self.fc_sq
      f_obs = fo_sq.f_sq_as_f()
      f_calc = fc_sq.f_sq_as_f()
      R1 = f_obs.r1_factor(f_calc,
        scale_factor=math.sqrt(self.scale_factor()), assume_index_matching=True)
      return R1, f_obs.size()

    def covariance_matrix(self,
                          jacobian_transpose=None,
                          normalised_by_goof=True):
      """ The columns of the jacobian_transpose determine which crystallographic
          parameters appear in the covariance matrix.
          If jacobian_transpose is None, then the covariance matrix returned will
          be that for the independent L.S. parameters.
      """
      if not self.step_equations().solved:
        self.solve()
      cov = linalg.inverse_of_u_transpose_u(
        self.step_equations().cholesky_factor_packed_u())
      cov /= self.sum_w_yo_sq()
      if jacobian_transpose is not None:
        cov = jacobian_transpose.self_transpose_times_symmetric_times_self(cov)
      if normalised_by_goof: cov *= self.restrained_goof()**2
      return cov

    def covariance_matrix_and_annotations(self):
      jac_tr = self.reparametrisation.jacobian_transpose_matching_grad_fc()
      return covariance_matrix_and_annotations(
        self.covariance_matrix(jacobian_transpose=jac_tr),
        self.reparametrisation.component_annotations)

  return klass


def crystallographic_ls(
  observations, reparametrisation,
  non_linear_ls_with_separable_scale_factor=None,
  may_parallelise=True,
  **kwds):
  return crystallographic_ls_class(non_linear_ls_with_separable_scale_factor
                                   )(observations, reparametrisation,
                                     may_parallelise=may_parallelise, **kwds)


class covariance_matrix_and_annotations(object):

  def __init__(self, covariance_matrix, annotations):
    """ The covariance matrix is assumed to be a symmetric matrix stored as a
        packed upper diagonal matrix.
    """
    self.matrix = covariance_matrix
    self.annotations = annotations
    self._2_n_minus_1 = 2*len(self.annotations)-1 # precompute for efficiency

  def __call__(self, i, j):
    return self.matrix[i*(self._2_n_minus_1-i)//2 + j]

  def variance_of(self, annotation):
    i = self.annotations.index(annotation)
    return self(i, i)

  def covariance_of(self, annotation_1, annotation_2):
    i = self.annotations.index(annotation_1)
    j = self.annotations.index(annotation_2)
    if j > i:
      i, j = j, i
    return self(i, j)

  def diagonal(self):
    return self.matrix.matrix_packed_u_diagonal()


 *******************************************************************************


 *******************************************************************************
smtbx/refinement/restraints/__init__.py
from __future__ import absolute_import, division, print_function
import scitbx.sparse # import dependency

import boost_adaptbx.boost.python as bp
bp.import_ext("smtbx_refinement_restraints_ext")

from smtbx_refinement_restraints_ext import *

from cctbx.xray import parameter_map
from cctbx.adp_restraints import adp_restraint_params

from libtbx import adopt_optional_init_args

import sys

class manager(object):
  bond_proxies=None
  angle_proxies=None
  dihedral_proxies=None
  chirality_proxies=None
  planarity_proxies=None
  bond_similarity_proxies=None
  adp_similarity_proxies=None
  rigid_bond_proxies=None
  rigu_proxies=None
  isotropic_adp_proxies=None
  #new
  fixed_u_eq_adp_proxies=None
  adp_u_eq_similarity_proxies=None
  adp_volume_similarity_proxies=None

  def __init__(self, **kwds):
    adopt_optional_init_args(self, kwds)

  def show_sorted(self, xray_structure,
                  f=None,
                  prefix="",
                  max_items=None):
    unit_cell = xray_structure.unit_cell()
    sites_cart = xray_structure.sites_cart()
    u_cart = xray_structure.scatterers().extract_u_cart(unit_cell)
    u_iso = xray_structure.scatterers().extract_u_iso()
    use_u_aniso = xray_structure.use_u_aniso()
    site_labels = xray_structure.scatterers().extract_labels()
    if (f is None): f = sys.stdout
    if (self.bond_proxies is not None):
      self.bond_proxies.show_sorted(
        by_value="residual", unit_cell=unit_cell,
        sites_cart=sites_cart, site_labels=site_labels,
        f=f, prefix=prefix, max_items=max_items)
      print(file=f)
    if (self.angle_proxies is not None):
      self.angle_proxies.show_sorted(
        by_value="residual",
        unit_cell=unit_cell, sites_cart=sites_cart, site_labels=site_labels,
        f=f, prefix=prefix, max_items=max_items)
      print(file=f)
    if (self.dihedral_proxies is not None):
      self.dihedral_proxies.show_sorted(
        by_value="residual",
        sites_cart=sites_cart, site_labels=site_labels,
        unit_cell=unit_cell, f=f, prefix=prefix, max_items=max_items)
      print(file=f)
    if (self.chirality_proxies is not None):
      self.chirality_proxies.show_sorted(
        by_value="residual",
        sites_cart=sites_cart, site_labels=site_labels,
        unit_cell=unit_cell, f=f, prefix=prefix, max_items=max_items)
      print(file=f)
    if (self.planarity_proxies is not None):
      self.planarity_proxies.show_sorted(
        by_value="residual",
        unit_cell=unit_cell, sites_cart=sites_cart, site_labels=site_labels,
        f=f, prefix=prefix, max_items=max_items)
      print(file=f)
    if (self.bond_similarity_proxies is not None):
      self.bond_similarity_proxies.show_sorted(
        by_value="residual",
        sites_cart=sites_cart, site_labels=site_labels,
        unit_cell=unit_cell, f=f, prefix=prefix, max_items=max_items)
      print(file=f)
    if (self.adp_similarity_proxies is not None):
      self.adp_similarity_proxies.show_sorted(
        by_value="residual", site_labels=site_labels,
        u_cart=u_cart, u_iso=u_iso, use_u_aniso=use_u_aniso,
        f=f, prefix=prefix, max_items=max_items)
      print(file=f)
    if (self.adp_u_eq_similarity_proxies is not None):
      self.adp_u_eq_similarity_proxies.show_sorted(
        by_value="residual", site_labels=site_labels,
        u_cart=u_cart, u_iso=u_iso, use_u_aniso=use_u_aniso,
        f=f, prefix=prefix, max_items=max_items)
      print(file=f)
    if (self.adp_volume_similarity_proxies is not None):
      self.adp_volume_similarity_proxies.show_sorted(
        by_value="residual", site_labels=site_labels,
        u_cart=u_cart, u_iso=u_iso, use_u_aniso=use_u_aniso,
        f=f, prefix=prefix, max_items=max_items)
      print(file=f)
    if (self.rigid_bond_proxies is not None):
      self.rigid_bond_proxies.show_sorted(
        by_value="residual",
        sites_cart=sites_cart, site_labels=site_labels, u_cart=u_cart,
        f=f, prefix=prefix, max_items=max_items)
      print(file=f)
    if (self.rigu_proxies is not None):
      self.rigu_proxies.show_sorted(
        by_value="residual",
        sites_cart=sites_cart, site_labels=site_labels, u_cart=u_cart,
        f=f, prefix=prefix, max_items=max_items)
      print(file=f)
    if (self.isotropic_adp_proxies is not None):
      self.isotropic_adp_proxies.show_sorted(
        by_value="residual", site_labels=site_labels,
        u_cart=u_cart, u_iso=u_iso, use_u_aniso=use_u_aniso,
        f=f, prefix=prefix, max_items=max_items)
      print(file=f)
    if (self.fixed_u_eq_adp_proxies is not None):
      self.fixed_u_eq_adp_proxies.show_sorted(
        by_value="residual", site_labels=site_labels,
        u_cart=u_cart, u_iso=u_iso, use_u_aniso=use_u_aniso,
        f=f, prefix=prefix, max_items=max_items)
      print(file=f)

  def add_to_cif_block(self, cif_block, xray_structure):
    import iotbx.cif.restraints
    iotbx.cif.restraints.add_to_cif_block(
      cif_block, xray_structure,
      bond_proxies=self.bond_proxies,
      angle_proxies=self.angle_proxies,
      dihedral_proxies=self.dihedral_proxies,
      chirality_proxies=self.chirality_proxies,
      bond_similarity_proxies=self.bond_similarity_proxies,
      rigid_bond_proxies=self.rigid_bond_proxies,
      rigu_proxies=self.rigu_proxies,
      adp_similarity_proxies=self.adp_similarity_proxies,
      isotropic_adp_proxies=self.isotropic_adp_proxies,
      adp_u_eq_similarity_proxies=self.adp_u_eq_similarity_proxies,
      adp_volume_similarity_proxies=self.adp_volume_similarity_proxies,
      fixed_u_eq_adp_proxies=self.fixed_u_eq_adp_proxies
    )

  def build_linearised_eqns(self, xray_structure, parameter_map):
    n_restraints = 0
    n_params = parameter_map.n_parameters
    geometry_proxies = [proxies for proxies in (
      self.bond_proxies, self.angle_proxies, self.dihedral_proxies)
                        if proxies is not None]
    # count restraints, i.e. number of rows for restraint matrix
    n_restraints = sum([proxies.size() for proxies in geometry_proxies])
    if self.bond_similarity_proxies is not None:
      for proxy in self.bond_similarity_proxies:
        n_restraints += proxy.i_seqs.size()
      geometry_proxies.append(self.bond_similarity_proxies)
    if self.chirality_proxies is not None:
      for proxy in self.chirality_proxies:
        n_restraints += 1
      geometry_proxies.append(self.chirality_proxies)
    adp_proxies = []
    if self.adp_similarity_proxies is not None:
      adp_proxies.append(self.adp_similarity_proxies)
      n_restraints += 6 * self.adp_similarity_proxies.size()
    if self.adp_u_eq_similarity_proxies is not None:
      adp_proxies.append(self.adp_u_eq_similarity_proxies)
      for p in self.adp_u_eq_similarity_proxies:
        n_restraints += len(p.i_seqs)
    if self.adp_volume_similarity_proxies is not None:
      adp_proxies.append(self.adp_volume_similarity_proxies)
      for p in self.adp_volume_similarity_proxies:
        n_restraints += len(p.i_seqs)
    if self.isotropic_adp_proxies is not None:
      adp_proxies.append(self.isotropic_adp_proxies)
      n_restraints += 6 * self.isotropic_adp_proxies.size()
    if self.fixed_u_eq_adp_proxies is not None:
      adp_proxies.append(self.fixed_u_eq_adp_proxies)
      n_restraints += self.fixed_u_eq_adp_proxies.size()
    if self.rigid_bond_proxies is not None:
      adp_proxies.append(self.rigid_bond_proxies)
      n_restraints += self.rigid_bond_proxies.size()
    if self.rigu_proxies is not None:
      adp_proxies.append(self.rigu_proxies)
      n_restraints += 3 * self.rigu_proxies.size()
    # construct restraints matrix
    linearised_eqns = linearised_eqns_of_restraint(
      n_restraints, n_params)
    for proxies in geometry_proxies:
      linearise_restraints(
        xray_structure.unit_cell(), xray_structure.sites_cart(),
        parameter_map, proxies, linearised_eqns)
    u_cart = xray_structure.scatterers().extract_u_cart(
      xray_structure.unit_cell())
    params = adp_restraint_params(
      sites_cart=xray_structure.sites_cart(),
      u_cart=u_cart,
      u_iso=xray_structure.scatterers().extract_u_iso(),
      use_u_aniso=xray_structure.use_u_aniso())
    for proxies in adp_proxies:
      linearise_restraints(
        xray_structure.unit_cell(), params,
        parameter_map, proxies, linearised_eqns)
    return linearised_eqns


 *******************************************************************************


 *******************************************************************************
smtbx/refinement/restraints/adp_restraints.py
from __future__ import absolute_import, division, print_function
from cctbx.array_family import flex
from cctbx import crystal
from cctbx import adp_restraints

class adp_similarity_restraints(object):
  def __init__(self, xray_structure=None, pair_sym_table=None, proxies=None,
               i_seqs=None, sigma=0.04, sigma_terminal=None,
               buffer_thickness=3.5):
    assert [xray_structure, pair_sym_table].count(None) == 1
    if i_seqs is not None and len(i_seqs) == 0: i_seqs = None
    if sigma_terminal is None: sigma_terminal = 2 * sigma
    if proxies is None:
      proxies = adp_restraints.shared_adp_similarity_proxy()
    if pair_sym_table is None:
      asu_mappings = xray_structure.asu_mappings(buffer_thickness=buffer_thickness)
      pair_asu_table = crystal.pair_asu_table(asu_mappings=asu_mappings)
      scattering_types = xray_structure.scatterers().extract_scattering_types()
      pair_asu_table.add_covalent_pairs(
        scattering_types, exclude_scattering_types=flex.std_string(("H","D")))
      pair_sym_table = pair_asu_table.extract_pair_sym_table()
    connectivity = pair_sym_table.full_simple_connectivity()

    for i_seq, j_seq_dict in enumerate(pair_sym_table):
      if i_seqs is not None and i_seq not in i_seqs: continue
      for j_seq, sym_ops in j_seq_dict.items():
        if i_seqs is not None and j_seq not in i_seqs: continue
        for sym_op in sym_ops:
          if sym_op.is_unit_mx():
            i_is_terminal = (connectivity[i_seq].size() <= 1)
            j_is_terminal = (connectivity[j_seq].size() <= 1)
            if i_is_terminal or j_is_terminal:
              weight = 1/(sigma_terminal*sigma_terminal)
            else:
              weight = 1/(sigma*sigma)
            proxies.append(adp_restraints.adp_similarity_proxy(
              i_seqs=(i_seq,j_seq),weight=weight))
          break
    self.proxies = proxies

class rigid_bond_restraints(object):
  def __init__(self, xray_structure=None, pair_sym_table=None, proxies=None,
               i_seqs=None, sigma_12=0.01, sigma_13=None,
               buffer_thickness=3.5):
    """ sigma_12 and sigma_13 are the effective standard deviations used for
        1,2- and 1,3-distances respectively
    """
    assert [xray_structure, pair_sym_table].count(None) == 1
    if i_seqs is not None and len(i_seqs) == 0: i_seqs = None
    if sigma_13 is None: sigma_13 = sigma_12
    if proxies is None:
      proxies = adp_restraints.shared_rigid_bond_proxy()
    if pair_sym_table is None:
      asu_mappings = xray_structure.asu_mappings(buffer_thickness=buffer_thickness)
      pair_asu_table = crystal.pair_asu_table(asu_mappings=asu_mappings)
      scattering_types = xray_structure.scatterers().extract_scattering_types()
      pair_asu_table.add_covalent_pairs(
        scattering_types, exclude_scattering_types=flex.std_string(("H","D")))
      pair_sym_table = pair_asu_table.extract_pair_sym_table()
    connectivity = pair_sym_table.full_simple_connectivity()
    ij_seqs = set()

    for i_seq, j_seq_dict in enumerate(pair_sym_table):
      if i_seqs is not None and i_seq not in i_seqs: continue
      for j_seq in connectivity[i_seq]:
        if i_seqs is not None and j_seq not in i_seqs: continue
        if i_seq < j_seq:
          j_sym_ops = pair_sym_table[i_seq][j_seq]
        else:
          k_sym_ops = pair_sym_table[j_seq][i_seq]
        for sym_op in j_sym_ops:
          if (    sym_op.is_unit_mx()
              and i_seq < j_seq
              and (i_seq, j_seq) not in ij_seqs):
            ij_seqs.add((i_seq, j_seq))
            weight = 1/(sigma_12*sigma_12)
            proxies.append(adp_restraints.rigid_bond_proxy(
              i_seqs=(i_seq,j_seq),weight=weight))
            break
        if connectivity[j_seq].size() > 1:
          for k_seq in connectivity[j_seq]:
            if i_seqs is not None and k_seq not in i_seqs: continue
            if k_seq != i_seq:
              for sym_op in j_sym_ops:
                if sym_op.is_unit_mx():
                  if j_seq < k_seq:
                    k_sym_ops = pair_sym_table[j_seq][k_seq]
                  else:
                    k_sym_ops = pair_sym_table[k_seq][j_seq]
                  for sym_op in k_sym_ops:
                    if (    sym_op.is_unit_mx()
                        and i_seq < k_seq
                        and (i_seq, k_seq) not in ij_seqs):
                      ij_seqs.add((i_seq, k_seq))
                      weight = 1/(sigma_13*sigma_13)
                      proxies.append(adp_restraints.rigid_bond_proxy(
                        i_seqs=(i_seq,k_seq),weight=weight))
                      break
                  break
    self.proxies = proxies

class rigu_restraints(object):
  def __init__(self, xray_structure=None, pair_sym_table=None, proxies=None,
               i_seqs=None, sigma_12=0.004, sigma_13=None,
               buffer_thickness=3.5):
    """ sigma_12 and sigma_13 are the effective standard deviations used for
        1,2- and 1,3-distances respectively
    """
    assert [xray_structure, pair_sym_table].count(None) == 1
    if i_seqs is not None and len(i_seqs) == 0: i_seqs = None
    if sigma_13 is None: sigma_13 = sigma_12
    if proxies is None:
      proxies = adp_restraints.shared_rigu_proxy()
    if pair_sym_table is None:
      asu_mappings = xray_structure.asu_mappings(buffer_thickness=buffer_thickness)
      pair_asu_table = crystal.pair_asu_table(asu_mappings=asu_mappings)
      scattering_types = xray_structure.scatterers().extract_scattering_types()
      pair_asu_table.add_covalent_pairs(
        scattering_types, exclude_scattering_types=flex.std_string(("H","D")))
      pair_sym_table = pair_asu_table.extract_pair_sym_table()
    connectivity = pair_sym_table.full_simple_connectivity()
    ij_seqs = set()

    for i_seq, j_seq_dict in enumerate(pair_sym_table):
      if i_seqs is not None and i_seq not in i_seqs: continue
      for j_seq in connectivity[i_seq]:
        if i_seqs is not None and j_seq not in i_seqs: continue
        if i_seq < j_seq:
          j_sym_ops = pair_sym_table[i_seq][j_seq]
        else:
          k_sym_ops = pair_sym_table[j_seq][i_seq]
        for sym_op in j_sym_ops:
          if (    sym_op.is_unit_mx()
              and i_seq < j_seq
              and (i_seq, j_seq) not in ij_seqs):
            ij_seqs.add((i_seq, j_seq))
            weight = 1/(sigma_12*sigma_12)
            proxies.append(adp_restraints.rigu_proxy(
              i_seqs=(i_seq,j_seq),weight=weight))
            break
        if connectivity[j_seq].size() > 1:
          for k_seq in connectivity[j_seq]:
            if i_seqs is not None and k_seq not in i_seqs: continue
            if k_seq != i_seq:
              for sym_op in j_sym_ops:
                if sym_op.is_unit_mx():
                  if j_seq < k_seq:
                    k_sym_ops = pair_sym_table[j_seq][k_seq]
                  else:
                    k_sym_ops = pair_sym_table[k_seq][j_seq]
                  for sym_op in k_sym_ops:
                    if (    sym_op.is_unit_mx()
                        and i_seq < k_seq
                        and (i_seq, k_seq) not in ij_seqs):
                      ij_seqs.add((i_seq, k_seq))
                      weight = 1/(sigma_13*sigma_13)
                      proxies.append(adp_restraints.rigu_proxy(
                        i_seqs=(i_seq,k_seq),weight=weight))
                      break
                  break
    self.proxies = proxies

class isotropic_adp_restraints(object):
  def __init__(self, xray_structure, pair_sym_table=None, proxies=None,
               i_seqs=None, sigma=0.1, sigma_terminal=None, buffer_thickness=3.5):
    if sigma_terminal is None: sigma_terminal = 2 * sigma
    if i_seqs is not None and len(i_seqs) == 0: i_seqs = None
    if proxies is None:
      proxies = adp_restraints.shared_isotropic_adp_proxy()
    scattering_types = xray_structure.scatterers().extract_scattering_types()
    use_u_aniso = xray_structure.scatterers().extract_use_u_aniso()
    if pair_sym_table is None:
      asu_mappings = xray_structure.asu_mappings(buffer_thickness=buffer_thickness)
      pair_asu_table = crystal.pair_asu_table(asu_mappings=asu_mappings)
      pair_asu_table.add_covalent_pairs(
        scattering_types, exclude_scattering_types=flex.std_string(("H","D")))
      pair_sym_table = pair_asu_table.extract_pair_sym_table()
    connectivity = pair_sym_table.full_simple_connectivity()

    for i_seq, neighbours in enumerate(connectivity):
      if i_seqs is not None and i_seq not in i_seqs: continue
      elif scattering_types[i_seq] in ('H','D'): continue
      elif not use_u_aniso[i_seq]: continue
      if neighbours.size() <= 1:
        weight = 1/(sigma_terminal*sigma_terminal)
      else:
        weight = 1/(sigma*sigma)
      proxies.append(adp_restraints.isotropic_adp_proxy(
        i_seqs=(i_seq,),weight=weight))
    self.proxies = proxies

class fixed_u_eq_adp_restraints(object):
  def __init__(self, xray_structure, u_eq_ideal, proxies=None,
               i_seqs=None, sigma=0.1):
    if proxies is None:
      proxies = adp_restraints.shared_fixed_u_eq_adp_proxy()
    weight = 1/(sigma*sigma)
    if i_seqs is None:
      i_seqs = [i for i, s in enumerate(xray_structure.scatterers())
                if s.scattering_type not in ('H', 'D')]
    for i_seq in i_seqs:
      proxies.append(adp_restraints.fixed_u_eq_adp_proxy(
        i_seqs=(i_seq,),weight=weight, u_eq_ideal=u_eq_ideal))
    self.proxies = proxies

class adp_u_eq_similarity_restraints(object):
  def __init__(self, xray_structure, proxies=None,
               i_seqs=None, sigma=0.1):
    if proxies is None:
      proxies = adp_restraints.shared_adp_u_eq_similarity_proxy()
    weight = 1/(sigma*sigma)
    if i_seqs is None:
      i_seqs = [i for i, s in enumerate(xray_structure.scatterers())
                if s.scattering_type not in ('H', 'D')]
    assert len(i_seqs) > 1
    proxies.append(adp_restraints.adp_u_eq_similarity_proxy(
      i_seqs=i_seqs, weight=weight))
    self.proxies = proxies

class adp_volume_similarity_restraints(object):
  def __init__(self, xray_structure, proxies=None,
               i_seqs=None, sigma=0.1):
    if proxies is None:
      proxies = adp_restraints.shared_adp_volume_similarity_proxy()
    weight = 1/(sigma*sigma)
    if i_seqs is None:
      i_seqs = [i for i, s in enumerate(xray_structure.scatterers())
                if s.scattering_type not in ('H', 'D')]
    assert len(i_seqs) > 1
    proxies.append(adp_restraints.adp_volume_similarity_proxy(
      i_seqs=i_seqs, weight=weight))
    self.proxies = proxies


 *******************************************************************************


 *******************************************************************************
smtbx/refinement/restraints/origin_fixing_restraints.py
from __future__ import absolute_import, division, print_function
from scitbx.array_family import flex
from cctbx.eltbx import tiny_pse
from smtbx.refinement.restraints import origin_fixing as base


class homogeneous_weighting(base):

  def weights(self,
              normal_eqns,
              jacobian_transpose_matching_grad_fc,
              params):
    z_max = max([
      tiny_pse.table(p.scatterer.element_symbol()).atomic_number()
      for p in params ])
    return flex.double(params.size(), z_max**2)


class atomic_number_weighting(base):

  def weights(self,
              normal_eqns,
              jacobian_transpose_matching_grad_fc,
              params):
    w = flex.double([
      tiny_pse.table(p.scatterer.element_symbol()).atomic_number()
      for p in params ])**2
    return w


class flack_schwarzenbach_weighting(base):

  def weights(self,
            normal_eqns,
            jacobian_transpose_matching_grad_fc,
            params):
    raise NotImplementedError()


 *******************************************************************************


 *******************************************************************************
smtbx/refinement/restraints/tests/tst_adp_restraints.py
from __future__ import absolute_import, division, print_function

from libtbx.test_utils import approx_equal
from smtbx.refinement.restraints import adp_restraints
from smtbx import development
from cctbx.array_family import flex
from cctbx import crystal
from six.moves import range

def get_pair_sym_table(xray_structure):
  asu_mappings = xray_structure.asu_mappings(buffer_thickness=3.5)
  pair_asu_table = crystal.pair_asu_table(asu_mappings=asu_mappings)
  scattering_types = xray_structure.scatterers().extract_scattering_types()
  pair_asu_table.add_covalent_pairs(
    scattering_types, exclude_scattering_types=flex.std_string(("H","D")))
  return pair_asu_table.extract_pair_sym_table()

def exercise_adp_similarity():
  xray_structure = development.sucrose()
  pair_sym_table = get_pair_sym_table(xray_structure)
  for table in (None,pair_sym_table):
    if table is None: xs = xray_structure
    else: xs = None
    restraints = \
      adp_restraints.adp_similarity_restraints(
        xray_structure=xs,
        pair_sym_table=table)
    assert restraints.proxies.size() == 24
    i_seqs = (9,14,28,32,36,38)
    restraints = \
      adp_restraints.adp_similarity_restraints(
        xray_structure=xs,
        pair_sym_table=table,
        i_seqs=i_seqs)
    expected_i_seqs = ((9,32),(14,36),(32,36),(36,38))
    expected_weights = (625,156.25,625,625)
    proxies = restraints.proxies
    assert proxies.size() == len(expected_i_seqs)
    for i in range(proxies.size()):
      assert approx_equal(proxies[i].i_seqs, expected_i_seqs[i])
      assert approx_equal(proxies[i].weight, expected_weights[i])
    # add more restraints to same shared proxy
    i_seqs = (3,23,40,42)
    restraints = \
      adp_restraints.adp_similarity_restraints(
        xray_structure=xs,
        pair_sym_table=table,
        proxies=proxies,
        i_seqs=i_seqs)
    expected_i_seqs = (
      (9,32),(14,36),(32,36),(36,38),(3,23),(40,42))
    expected_weights = (625,156.25,625,625,156.25,625)
    proxies = restraints.proxies
    assert proxies.size() == len(expected_i_seqs)
    for i in range(proxies.size()):
      assert approx_equal(proxies[i].i_seqs, expected_i_seqs[i])
      assert approx_equal(proxies[i].weight, expected_weights[i])

def exercise_rigid_bond():
  xray_structure = development.sucrose()
  pair_sym_table = get_pair_sym_table(xray_structure)
  for table in (None,pair_sym_table):
    if table is None: xs = xray_structure
    else: xs = None
    restraints = \
      adp_restraints.rigid_bond_restraints(
        xray_structure=xs,
        pair_sym_table=table)
    assert restraints.proxies.size() == 60
    i_seqs = (9,14,28,32,36,38)
    restraints = \
      adp_restraints.rigid_bond_restraints(
        xray_structure=xs,
        pair_sym_table=table,
        i_seqs=i_seqs)
    expected_i_seqs = (
      (9,32),(9,36),(14,36),(14,32),(14,38),(32,36),(32,38),(36,38))
    expected_weights = [10000]*len(expected_i_seqs)
    proxies = restraints.proxies
    assert proxies.size() == len(expected_i_seqs)
    for i in range(proxies.size()):
      assert approx_equal(proxies[i].i_seqs, expected_i_seqs[i])
      assert approx_equal(proxies[i].weight, expected_weights[i])
    # add more restraints to same shared proxy
    i_seqs = (10,40,42)
    restraints = \
      adp_restraints.rigid_bond_restraints(
        xray_structure=xs,
        pair_sym_table=table,
        proxies=proxies,
        i_seqs=i_seqs)
    expected_i_seqs = (
      (9,32),(9,36),(14,36),(14,32),(14,38),(32,36),
      (32,38),(36,38),(10,42),(10,40),(40,42))
    expected_weights = [10000]*len(expected_i_seqs)
    proxies = restraints.proxies
    assert proxies.size() == len(expected_i_seqs)
    for i in range(proxies.size()):
      assert approx_equal(proxies[i].i_seqs, expected_i_seqs[i])
      assert approx_equal(proxies[i].weight, expected_weights[i])

def exercise_isotropic_adp():
  xray_structure = development.sucrose()
  xray_structure.scatterers()[10].set_use_u_iso_only()
  pair_sym_table = get_pair_sym_table(xray_structure)
  for table in (None,pair_sym_table):
    restraints = \
      adp_restraints.isotropic_adp_restraints(
        xray_structure=xray_structure,
        pair_sym_table=table)
    assert restraints.proxies.size() == 22
    i_seqs = (9,14,28,32,36,38)
    expected_weights = (100,25,100,100,100,100)
    restraints = \
      adp_restraints.isotropic_adp_restraints(
        xray_structure=xray_structure,
        pair_sym_table=table,
        i_seqs=i_seqs)
    proxies = restraints.proxies
    assert proxies.size() == len(i_seqs)
    for i in range(proxies.size()):
      assert approx_equal(proxies[i].i_seqs[0], i_seqs[i])
      assert approx_equal(proxies[i].weight, expected_weights[i])
    # add more restraints to same shared proxy
    i_seqs = (3,5,42)
    restraints = \
      adp_restraints.isotropic_adp_restraints(
        xray_structure=xray_structure,
        pair_sym_table=table,
        proxies=proxies,
        i_seqs=i_seqs)
    expected_i_seqs = (9,14,28,32,36,38,3,5,42)
    expected_weights = (100,25,100,100,100,100,25,25,100)
    proxies = restraints.proxies
    assert proxies.size() == len(expected_i_seqs)
    for i in range(proxies.size()):
      assert approx_equal(proxies[i].i_seqs[0], expected_i_seqs[i])
      assert approx_equal(proxies[i].weight, expected_weights[i])

def exercise_rigu():
  xray_structure = development.sucrose()
  pair_sym_table = get_pair_sym_table(xray_structure)
  for table in (None,pair_sym_table):
    if table is None: xs = xray_structure
    else: xs = None
    restraints = \
      adp_restraints.rigu_restraints(
        xray_structure=xs,
        pair_sym_table=table)
    assert restraints.proxies.size() == 60
    i_seqs = (9,14,28,32,36,38)
    restraints = \
      adp_restraints.rigu_restraints(
        xray_structure=xs,
        pair_sym_table=table,
        i_seqs=i_seqs)
    expected_i_seqs = (
      (9,32),(9,36),(14,36),(14,32),(14,38),(32,36),(32,38),(36,38))
    expected_weights = [62500]*len(expected_i_seqs)
    proxies = restraints.proxies
    assert proxies.size() == len(expected_i_seqs)
    for i in range(proxies.size()):
      assert approx_equal(proxies[i].i_seqs, expected_i_seqs[i])
      assert approx_equal(proxies[i].weight, expected_weights[i])
    # add more restraints to same shared proxy
    i_seqs = (10,40,42)
    restraints = \
      adp_restraints.rigu_restraints(
        xray_structure=xs,
        pair_sym_table=table,
        proxies=proxies,
        i_seqs=i_seqs)
    expected_i_seqs = (
      (9,32),(9,36),(14,36),(14,32),(14,38),(32,36),
      (32,38),(36,38),(10,42),(10,40),(40,42))
    expected_weights = [62500]*len(expected_i_seqs)
    proxies = restraints.proxies
    assert proxies.size() == len(expected_i_seqs)
    for i in range(proxies.size()):
      assert approx_equal(proxies[i].i_seqs, expected_i_seqs[i])
      assert approx_equal(proxies[i].weight, expected_weights[i])

if __name__ == '__main__':
  exercise_isotropic_adp()
  exercise_rigid_bond()
  exercise_adp_similarity()
  exercise_rigu()
  print('OK')


 *******************************************************************************


 *******************************************************************************
smtbx/refinement/restraints/tests/tst_manager.py
from __future__ import absolute_import, division, print_function

from smtbx.refinement import restraints
from smtbx.refinement.restraints import adp_restraints
import smtbx.development
from cctbx import crystal
from cctbx import sgtbx
from cctbx.array_family import flex
import cctbx.geometry_restraints
from six.moves import cStringIO as StringIO
import sys

def exercise_manager():
  xray_structure = smtbx.development.sucrose()
  xray_structure.scatterers()[10].set_use_u_iso_only()
  asu_mappings = xray_structure.asu_mappings(buffer_thickness=3.5)
  pair_asu_table = crystal.pair_asu_table(asu_mappings=asu_mappings)
  scattering_types = xray_structure.scatterers().extract_scattering_types()
  pair_asu_table.add_covalent_pairs(
    scattering_types, exclude_scattering_types=flex.std_string(("H","D")))
  pair_sym_table = pair_asu_table.extract_pair_sym_table()
  # setup adp restraint proxies
  adp_similarity_proxies = \
    adp_restraints.adp_similarity_restraints(
      pair_sym_table=pair_sym_table).proxies
  rigid_bond_proxies = \
    adp_restraints.rigid_bond_restraints(
      pair_sym_table=pair_sym_table).proxies
  rigu_proxies = \
    adp_restraints.rigu_restraints(
      pair_sym_table=pair_sym_table).proxies
  isotropic_adp_proxies = \
    adp_restraints.isotropic_adp_restraints(
      xray_structure=xray_structure,
      pair_sym_table=pair_sym_table).proxies
  bond_proxies = cctbx.geometry_restraints.shared_bond_simple_proxy()
  bond_proxies.append(
    cctbx.geometry_restraints.bond_simple_proxy(
      i_seqs=(3,23), distance_ideal=1.44, weight=2))
  bond_proxies.append(
    cctbx.geometry_restraints.bond_simple_proxy(
      i_seqs=(5,25), distance_ideal=1.44, weight=2))
  bond_proxies.append(
    cctbx.geometry_restraints.bond_simple_proxy(
      i_seqs=(1,21), distance_ideal=1.44, weight=2))
  angle_proxies = cctbx.geometry_restraints.shared_angle_proxy()
  angle_proxies.append(
    cctbx.geometry_restraints.angle_proxy(
      i_seqs=(25,28,30),angle_ideal=110,weight=2))
  angle_proxies.append(
    cctbx.geometry_restraints.angle_proxy(
      i_seqs=(23,25,28),angle_ideal=110,weight=2))
  angle_proxies.append(
    cctbx.geometry_restraints.angle_proxy(
      i_seqs=(19,23,25),angle_ideal=110,weight=2))
  bond_similarity_proxies=cctbx.geometry_restraints.shared_bond_similarity_proxy()
  bond_similarity_proxies.append(
    cctbx.geometry_restraints.bond_similarity_proxy(
      i_seqs=((14,36),(12,38)),
      weights=(10,10),
      sym_ops=(sgtbx.rt_mx(),sgtbx.rt_mx())))
  chirality_proxies=cctbx.geometry_restraints.shared_chirality_proxy()
  chirality_proxies.append(
    cctbx.geometry_restraints.chirality_proxy(
      i_seqs=(14,36,12,38),
      weight=10**4,
      volume_ideal=1.2,
      both_signs=False))
  # setup restraints manager
  manager = restraints.manager(
    bond_proxies=bond_proxies,
    angle_proxies=angle_proxies,
    bond_similarity_proxies=bond_similarity_proxies,
    adp_similarity_proxies=adp_similarity_proxies,
    rigid_bond_proxies=rigid_bond_proxies,
    rigu_proxies=rigu_proxies,
    isotropic_adp_proxies=isotropic_adp_proxies,
    chirality_proxies=chirality_proxies)
  sio = StringIO()
  manager.show_sorted(xray_structure, max_items=1, f=sio)
  if sys.platform.startswith("win") and sys.version_info[:2] < (2,6):
    # This appears to be a windows-specific bug with string formatting
    # for python versions prior to 2.6, where the exponent is printed
    # with 3 digits rather than 2.
    pass
  else:
    assert sio.getvalue() == """\
Bond restraints: 3
Sorted by residual:
bond O3
     C3
  ideal  model  delta    sigma   weight residual
  1.440  1.422  0.018 7.07e-01 2.00e+00 6.58e-04
... (remaining 2 not shown)

Bond angle restraints: 3
Sorted by residual:
angle C3
      C4
      C5
    ideal   model   delta    sigma   weight residual
   110.00  108.00    2.00 7.07e-01 2.00e+00 8.03e+00
... (remaining 2 not shown)

Chirality restraints: 1
Sorted by residual:
chirality O9
          C9
          O8
          C10
  both_signs  ideal   model   delta    sigma   weight residual
    False      1.20    2.52   -1.32 1.00e-02 1.00e+04 1.75e+04

Bond similarity restraints: 1
Sorted by residual:
               delta    sigma   weight rms_deltas residual sym.op.
bond O9-C9    -0.010 3.16e-01 1.00e+01   9.93e-03 9.87e-05
     O8-C10    0.010 3.16e-01 1.00e+01

ADP similarity restraints: 24
Sorted by residual:
scatterers O7
           C12
          delta    sigma   weight rms_deltas residual
 U11  -1.02e+00 8.00e-02 1.56e+02   5.93e-01 4.95e+02
 U22  -1.03e+00 8.00e-02 1.56e+02
 U33  -1.03e+00 8.00e-02 1.56e+02
 U12  -4.23e-03 8.00e-02 1.56e+02
 U13  -3.49e-03 8.00e-02 1.56e+02
 U23   5.66e-03 8.00e-02 1.56e+02
... (remaining 23 not shown)

Rigid bond restraints: 60
Sorted by residual:
scatterers O7
           C12
   delta_z    sigma   weight residual
 -6.42e-01 1.00e-02 1.00e+04 4.12e+03
... (remaining 59 not shown)

Rigu bond restraints: 60
Sorted by residual:
scatterers O2
           C2
   delta_z    sigma   weight residual
  1.27e-03 6.36e-03 2.47e+04 4.01e-02
 -9.08e-03 6.36e-03 2.47e+04 2.04e+00
 -9.08e-03 6.36e-03 2.47e+04 2.40e+00
... (remaining 59 not shown)

Isotropic ADP restraints: 22
Sorted by residual:
scatterer O3
         delta    sigma   weight rms_deltas residual
 U11  1.20e-03 2.00e-01 2.50e+01   1.34e-02 4.06e-02
 U22 -2.46e-02 2.00e-01 2.50e+01
 U33  2.34e-02 2.00e-01 2.50e+01
 U12 -8.14e-03 2.00e-01 2.50e+01
 U13  9.78e-03 2.00e-01 2.50e+01
 U23 -8.63e-03 2.00e-01 2.50e+01
... (remaining 21 not shown)

"""

if __name__ == '__main__':
  exercise_manager()
  print('OK')


 *******************************************************************************
