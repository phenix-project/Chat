

 *******************************************************************************
simtbx/diffBragg/tests/tst_diffBragg_lambda_coefficients.py

"""
This test checks the lambda coefficients property and derivatives
"""
from __future__ import division
##from simtbx.kokkos import gpu_instance
#kokkos_run = gpu_instance(deviceId = 0)

from argparse import ArgumentParser
parser = ArgumentParser()
parser.add_argument("--kokkos", action="store_true")
parser.add_argument("--plot", action='store_true')
parser.add_argument("--idx", type=int, help="coefficient index (0 or 1)", default=0, choices=[0,1])
args = parser.parse_args()
if args.kokkos:
    import os
    os.environ["DIFFBRAGG_USE_KOKKOS"]="1"
from simtbx.diffBragg.utils import find_diffBragg_instances
from simtbx.diffBragg.device import DeviceWrapper
with DeviceWrapper(0) as _:

    import numpy as np
    import pylab as plt
    from scipy.stats import linregress
    from scipy.spatial.transform import Rotation
    from simtbx.nanoBragg import sim_data
    from scitbx.matrix import sqr, rec
    from cctbx import uctbx
    from dxtbx.model import Crystal

    ucell = (70, 60, 50, 90.0, 110, 90.0)
    symbol = "C121"

    a_real, b_real, c_real = sqr(uctbx.unit_cell(ucell).orthogonalization_matrix()).transpose().as_list_of_lists()
    C = Crystal(a_real, b_real, c_real, symbol)

    # random raotation
    rotation = Rotation.random(num=1, random_state=101)[0]
    Q = rec(rotation.as_quat(), n=(4, 1))
    rot_ang, rot_axis = Q.unit_quaternion_as_axis_and_angle()
    C.rotate_around_origin(rot_axis, rot_ang)

    S = sim_data.SimData(use_default_crystal=True)
    S.crystal.dxtbx_crystal = C
    spectrum = S.beam.spectrum
    wave, flux = spectrum[0]
    Nwave = 5
    waves = np.linspace(wave-wave*0.002, wave+wave*0.002, Nwave)
    fluxes = np.ones(Nwave) * flux / Nwave

    lambda0_GT = 0
    lambda1_GT = 1

    S.beam.spectrum = list(zip(waves, fluxes))
    S.detector = sim_data.SimData.simple_detector(180, 0.1, (1024, 1024))
    S.instantiate_diffBragg(verbose=0, oversample=0, auto_set_spotscale=True)
    S.D.lambda_coefficients = lambda0_GT, lambda1_GT
    S.D.spot_scale = 100000
    S.D.Ncells_abc = 12

    if args.idx == 0:
        S.D.refine(12)
    else:
        S.D.refine(13)
    S.D.initialize_managers()
    S.D.region_of_interest = ((0, 1023), (0, 1023))

    S.D.add_diffBragg_spots()
    img = S.D.raw_pixels.as_numpy_array()
    derivs = S.D.get_lambda_derivative_pixels()
    deriv = derivs[0].as_numpy_array().reshape(img.shape)

    S.D.raw_pixels *= 0
    S.D.use_lambda_coefficients = False
    S.D.add_diffBragg_spots()
    test_img = S.D.raw_pixels.as_numpy_array()
    assert np.allclose(img, test_img)
    S.D.use_lambda_coefficients = True
    S.D.raw_pixels *= 0
    print("OK")

    bragg = img > 1e-1  # select bragg scattering regions

    all_error = []
    all_error2 = []
    shifts = []
    shifts2 = []

    from scipy import constants
    ENERGY_CONV = 1e10*constants.c*constants.h / constants.electron_volt

    energy_shifts = 0.1, .3, .5, 1, 3, 5, 10   # in electron volt
    b_percs = 0.001, 0.002, 0.004, 0.008,  0.016, 0.032, 0.064
    reference_energy = ENERGY_CONV / wave

    for i_shift, en_shift in enumerate(energy_shifts):

        wave_shifted = ENERGY_CONV / (reference_energy + en_shift)
        wave_shift = wave - wave_shifted
        delta_a = wave_shift
        delta_b = lambda1_GT*b_percs[i_shift]

        if args.idx == 0:
            shift = b_percs[i_shift]*0.01
            new_waves = waves*lambda1_GT + lambda0_GT+shift
        else:
            shift = b_percs[i_shift]*0.01
            new_waves = waves*(lambda1_GT+shift) + lambda0_GT

        en = np.mean(ENERGY_CONV/new_waves)

        if args.idx == 0:
            S.D.lambda_coefficients = lambda0_GT + shift, lambda1_GT
            shifts.append(shift)
        else:
            S.D.lambda_coefficients = lambda0_GT, lambda1_GT + shift
            shifts.append(shift)

        S.D.raw_pixels *= 0
        S.D.region_of_interest = ((0, 1023), (0, 1023))
        S.D.add_diffBragg_spots()
        img2 = S.D.raw_pixels.as_numpy_array()

        fdiff = (img2 - img) / shift

        if args.idx == 0:
            error = np.abs(fdiff[bragg] - deriv[bragg]).mean()
        else:
            error = np.abs(fdiff[bragg] - deriv[bragg]).mean()

        all_error.append(error)

        print ("error=%f, step=%f, energy=%f" % (error, delta_a, en))
        #if args.plot:
        #    plt.subplot(121)
        #    plt.imshow(fdiff)
        #    plt.title("finite diff")
        #    plt.subplot(122)
        #    plt.imshow(deriv)
        #    plt.title("analytical")
        #    plt.draw()
        #    plt.suptitle("Shift %d / %d"
        #                 % (i_shift + 1, len(perc)))
        #    plt.pause(0.8)

    if args.plot:
        #plt.close()
        plt.plot(shifts, all_error, 'o')
        plt.show()
        #if args.curvatures:
        #    plt.plot(shifts2, all_error2, 'o')
        #    plt.show()

    l = linregress(shifts, all_error)
    assert l.rvalue > .9999  # this is definitely a line!
    assert l.slope > 0
    assert l.pvalue < 1e-6
    assert l.intercept < 0.1*l.slope # line should go through origin

    print("OK!")
    for name in find_diffBragg_instances(globals()): del globals()[name]


 *******************************************************************************


 *******************************************************************************
simtbx/diffBragg/tests/tst_diffBragg_map_to_asu.py
from __future__ import division

from simtbx.nanoBragg import sim_data
from dxtbx.model.crystal import CrystalFactory
from simtbx.nanoBragg import nanoBragg_crystal
from simtbx.diffBragg import utils
from cctbx import miller, crystal


def test_S(S):
    print("instantiate")
    S.instantiate_diffBragg()
    print("get map")
    Amap = S.D.get_ASUid_map()

    print("verify")
    inds, _ = S.D.Fhkl_tuple
#   NOTE: are symm equivalent indices the same in different bases ?
    print("SYMBOL:", S.crystal.symbol, "UCELL:", S.crystal.dxtbx_crystal.get_unit_cell())
    sym = crystal.symmetry(S.crystal.dxtbx_crystal.get_unit_cell(), S.crystal.symbol)
    mset = miller.set(sym, inds, True)
    mset_asu = mset.map_to_asu()
    print("count")
    n1 = len(set(mset_asu.indices()))
    n2 = len(Amap)
    assert n1==n2, "%d, %d" % (n1, n2)

    print("compare indices")
    A = []
    for item in Amap.keys():
        h,k,l = map(int, item.split(","))
        A.append ((h,k,l))
    A = set(A)
    B = set(mset_asu.indices())
    assert A==B

    print("OK")


if __name__=="__main__":
    S = sim_data.SimData(True)
    test_S(S)

    S2 = sim_data.SimData()
    UCELL_A=40.3
    UCELL_B=180.3
    UCELL_C=142.6
    HALL=' C 2c 2'

    CRYSTAL_DICT={
        '__id__': 'crystal',
        'real_space_a': (UCELL_A, 0.0, 0.0),
        'real_space_b': (0.0, UCELL_B, 0.0),
        'real_space_c': (0.0, 0.0, UCELL_C),
        'space_group_hall_symbol': HALL}
    C = CrystalFactory.from_dict(CRYSTAL_DICT)
    nbC = nanoBragg_crystal.NBcrystal()
    nbC.dxtbx_crystal = C
    nbC.symbol = C.get_space_group().info().type().lookup_symbol()
    nbC.miller_array = utils.make_miller_array(nbC.symbol, C.get_unit_cell().parameters())
    S2.crystal = nbC
    test_S(S2)

    p65_cryst = {'__id__': 'crystal',
                 'real_space_a': (43.32309880004587, 25.5289818883498, 60.49634260901813),
                 'real_space_b': (34.201635357808115, -38.82573591182249, -59.255697149884924),
                 'real_space_c': (41.42476391176581, 229.70849483520402, -126.60059788183489),
                 'space_group_hall_symbol': ' P 65 2 (x,y,z+1/12)',
                 'ML_half_mosaicity_deg': 0.06671930026192037,
                 'ML_domain_size_ang': 6349.223840307989}
    p65_C = CrystalFactory.from_dict(p65_cryst)
    S3 = sim_data.SimData()

    nbC = nanoBragg_crystal.NBcrystal()
    nbC.dxtbx_crystal = p65_C
    nbC.symbol = p65_C.get_space_group().info().type().lookup_symbol()
    nbC.miller_array = utils.make_miller_array(nbC.symbol, p65_C.get_unit_cell().parameters())
    S3.crystal = nbC
    test_S(S3)


 *******************************************************************************


 *******************************************************************************
simtbx/diffBragg/tests/tst_diffBragg_nanoBragg_congruency.py
from __future__ import division
##from simtbx.kokkos import gpu_instance
#kokkos_run = gpu_instance(deviceId = 0)
from simtbx.diffBragg.utils import find_diffBragg_instances
import numpy as np


def main():
    from simtbx.nanoBragg.sim_data import SimData

    S = SimData(use_default_crystal=True)
    S.instantiate_diffBragg()
    S.D.nopolar = True
    S.D.oversample = 3

    S.D.add_diffBragg_spots()
    S._add_background()

    diff_img = S.D.raw_pixels.as_numpy_array()

    S.D.raw_pixels *= 0
    S.D.add_nanoBragg_spots()
    S._add_background()

    nano_img = S.D.raw_pixels.as_numpy_array()

    assert np.allclose(diff_img, nano_img, atol=1e-9)
    for name in find_diffBragg_instances(globals()): del globals()[name]


if __name__ == "__main__":
    import sys
    if "--kokkos" in sys.argv:
        import os
        os.environ["DIFFBRAGG_USE_KOKKOS"]="1"
    from simtbx.diffBragg.device import DeviceWrapper
    with DeviceWrapper(0) as _:
        main()
    print ("OK!")


 *******************************************************************************


 *******************************************************************************
simtbx/diffBragg/tests/tst_diffBragg_ncells_offdiag_property.py
"""
This test checks the setter and getter for Ncells parameter
"""
from __future__ import division
##from simtbx.kokkos import gpu_instance
#kokkos_run = gpu_instance(deviceId = 0)

from argparse import ArgumentParser
parser = ArgumentParser()
parser.add_argument("--kokkos", action="store_true")
parser.add_argument("--plot", action='store_true')
parser.add_argument("--curvatures", action='store_true')
parser.add_argument("--idx", default=0, help="0=Nd, 1=Ne, 2=Nf", type=int, choices=[0,1,2])
args = parser.parse_args()
if args.kokkos:
    import os
    os.environ["DIFFBRAGG_USE_KOKKOS"]="1"
from simtbx.diffBragg.utils import find_diffBragg_instances
from simtbx.diffBragg.device import DeviceWrapper
with DeviceWrapper(0) as _:

    import numpy as np
    import pylab as plt
    from scipy.stats import linregress
    from scipy.spatial.transform import Rotation
    from simtbx.nanoBragg import sim_data
    from scitbx.matrix import sqr, rec
    from cctbx import uctbx
    from dxtbx.model import Crystal

    ucell = (70, 60, 50, 90.0, 110, 90.0)
    symbol = "C121"

    a_real, b_real, c_real = sqr(uctbx.unit_cell(ucell).orthogonalization_matrix()).transpose().as_list_of_lists()
    C = Crystal(a_real, b_real, c_real, symbol)

    # random raotation
    rotation = Rotation.random(num=1, random_state=101)[0]
    Q = rec(rotation.as_quat(), n=(4, 1))
    rot_ang, rot_axis = Q.unit_quaternion_as_axis_and_angle()
    C.rotate_around_origin(rot_axis, rot_ang)

    S = sim_data.SimData(use_default_crystal=True)
    S.crystal.dxtbx_crystal = C
    S.detector = sim_data.SimData.simple_detector(180, 0.1, (1024, 1024))
    S.instantiate_diffBragg(verbose=0, oversample=0, auto_set_spotscale=True)
    S.D.spot_scale = 100000
    #S.D.oversample = 5

    Ncells_def_id = 21

    S.D.Ncells_abc_aniso = 12, 13, 14
    S.D.Ncells_def = 10,11,12
    Nd, Ne, Nf = S.D.Ncells_def

    assert (Nd,Ne,Nf) == (10,11,12)

    print("OK")
    S.D.isotropic_ncells = False
    S.D.refine(Ncells_def_id)
    S.D.initialize_managers()
    ncells_def_GT = 10,11,12

    S.D.Ncells_abc_aniso = (20, 15, 17)
    S.D.Ncells_def = ncells_def_GT
    S.D.add_diffBragg_spots()

    img = S.D.raw_pixels_roi.as_numpy_array()
    derivs_abc = S.D.get_ncells_def_derivative_pixels()
    derivs_abc = [d.as_numpy_array() for d in derivs_abc]
    if args.curvatures:
        derivs2_abc = S.D.get_ncells_def_second_derivative_pixels()
        derivs2_abc = [d.as_numpy_array() for d in derivs2_abc]

    perc = 0.001, 0.01, 0.1, 1, 10
    bragg = img > 1e-1  # select bragg scattering regions

    Nd, Ne, Nf = ncells_def_GT
    for i_nc in range(3):
        if i_nc != args.idx:
            continue

        N = ncells_def_GT[i_nc]
        print("Testing finite diff %d / 3, Ncells_def=%d" % (i_nc +1, N))

        all_error = []
        all_error2 = []
        shifts = []
        shifts2 = []
        for i_shift, p in enumerate(perc):
            delta_N = N*p*0.01

            Ncells_def_vals = [Nd, Ne, Nf]
            Ncells_def_vals[i_nc] = N+delta_N

            S.D.Ncells_def = tuple(Ncells_def_vals)
            shifts.append(delta_N)

            S.D.raw_pixels_roi *= 0
            #S.D.printout_pixel_fastslow = 10, 10
            S.D.add_diffBragg_spots()
            img2 = S.D.raw_pixels_roi.as_numpy_array()

            fdiff = (img2 - img) / delta_N
            deriv = derivs_abc[i_nc]
            error = np.abs(fdiff[bragg] - deriv[bragg]).mean()
            all_error.append(error)

            if args.curvatures:
                Ncells_vals = [Nd, Ne, Nf]
                Ncells_vals[i_nc] = N - delta_N
                S.D.Ncells_def = tuple(Ncells_vals)
                shifts2.append(delta_N**2)

                S.D.raw_pixels_roi *= 0
                S.D.add_diffBragg_spots()
                img_backward = S.D.raw_pixels_roi.as_numpy_array()

                fdiff2 = (img2 - 2*img + img_backward) / delta_N / delta_N

                second_deriv = derivs2_abc[i_nc]

                error2 = (np.abs(fdiff2[bragg] - second_deriv[bragg]) / 1).mean()
                all_error2.append(error2)

            print ("error=%f, step=%f" % (error, delta_N))

        if args.plot:
            plt.plot(shifts, all_error, 'o')
            plt.show()
            if args.curvatures:
                plt.plot(shifts2, all_error2, 'o')
                plt.show()

        l = linregress(shifts, all_error)
        assert l.rvalue > .999  # this is definitely a line!
        assert l.slope > 0
        assert l.pvalue < 1e-5
        assert l.intercept < 0.1*l.slope # line should go through origin
        if args.curvatures:
            l = linregress(shifts2, all_error2)
            assert l.rvalue > .999  # this is definitely a line!
            assert l.slope > 0
            assert l.pvalue < 1e-5
            assert l.intercept < 0.1*l.slope # line should go through origin

        print("OK!")
    for name in find_diffBragg_instances(globals()): del globals()[name]


 *******************************************************************************


 *******************************************************************************
simtbx/diffBragg/tests/tst_diffBragg_ncells_property.py
"""
This test checks the setter and getter for Ncells parameter
"""
from __future__ import division
##from simtbx.kokkos import gpu_instance
#kokkos_run = gpu_instance(deviceId = 0)

from argparse import ArgumentParser
parser = ArgumentParser()
parser.add_argument("--kokkos", action="store_true")
parser.add_argument("--plot", action='store_true')
parser.add_argument("--curvatures", action='store_true')
args = parser.parse_args()
if args.kokkos:
    import os
    os.environ["DIFFBRAGG_USE_KOKKOS"]="1"
from simtbx.diffBragg.utils import find_diffBragg_instances
from simtbx.diffBragg.device import DeviceWrapper
with DeviceWrapper(0) as _:

    import numpy as np
    import pylab as plt
    from scipy.stats import linregress
    from scipy.spatial.transform import Rotation
    from simtbx.nanoBragg import sim_data
    from scitbx.matrix import sqr, rec
    from cctbx import uctbx
    from dxtbx.model import Crystal

    ucell = (70, 60, 50, 90.0, 110, 90.0)
    symbol = "C121"

    a_real, b_real, c_real = sqr(uctbx.unit_cell(ucell).orthogonalization_matrix()).transpose().as_list_of_lists()
    C = Crystal(a_real, b_real, c_real, symbol)

    # random raotation
    rotation = Rotation.random(num=1, random_state=101)[0]
    Q = rec(rotation.as_quat(), n=(4, 1))
    rot_ang, rot_axis = Q.unit_quaternion_as_axis_and_angle()
    C.rotate_around_origin(rot_axis, rot_ang)

    S = sim_data.SimData(use_default_crystal=True)
    S.crystal.dxtbx_crystal = C
    S.crystal.isotropic_ncells = True
    S.detector = sim_data.SimData.simple_detector(180, 0.1, (1024, 1024))
    S.instantiate_diffBragg(verbose=0, oversample=0)
    assert S.D.isotropic_ncells
    S.D.spot_scale = 100000
    #S.D.oversample = 5

    Ncells_id = 9

    S.D.Ncells_abc = 12
    i = S.D.get_value(Ncells_id)
    S.D.set_value(Ncells_id, 14)
    i2 = S.D.get_value(Ncells_id)
    S.D.Ncells_abc = 80
    i3 = S.D.get_value(Ncells_id)
    S.D.set_value(Ncells_id, 10)

    assert i == 12
    assert i2 == 14
    assert i3 == 80

    print("OK")

    S.D.refine(Ncells_id)
    S.D.initialize_managers()
    S.D.Ncells_abc = 20
    #S.D.printout_pixel_fastslow = 10, 10
    S.D.verbose = 1
    assert S.D.isotropic_ncells
    #S.D.isotropic_ncells = True
    S.D.add_diffBragg_spots()
    S.D.verbose = 0
    img = S.D.raw_pixels_roi.as_numpy_array()
    deriv = S.D.get_ncells_derivative_pixels()[0].as_numpy_array()
    if args.curvatures:
        deriv2 = S.D.get_ncells_second_derivative_pixels()[0].as_numpy_array()

    N = S.D.get_value(Ncells_id)
    perc = 0.001, 0.01, 0.1, 1, 10

    bragg = img > 1e-1  # select bragg scattering regions

    all_error = []
    all_error2 = []
    shifts = []
    shifts2 = []
    for i_shift, p in enumerate(perc):
        delta_N = N*p*0.001
        #S.D.set_value(Ncells_id, N-delta_N)

        Nabc = [N+delta_N, N+delta_N, N+delta_N]
        shifts.append(delta_N)
        S.D.Ncells_abc_aniso = tuple(Nabc)
        S.D.raw_pixels_roi *= 0
        S.D.add_diffBragg_spots()
        img2 = S.D.raw_pixels_roi.as_numpy_array()

        fdiff = (img2-img) / delta_N
        error = np.abs(fdiff[bragg] - deriv[bragg]).mean()
        all_error.append(error)

        if args.curvatures:
            S.D.set_value(Ncells_id, N - delta_N)
            shifts2.append(delta_N**2)

            S.D.raw_pixels_roi *= 0
            S.D.add_diffBragg_spots()
            img_backward = S.D.raw_pixels.as_numpy_array()

            fdiff2 = (img2 - 2*img + img_backward) / delta_N / delta_N

            error2 = (np.abs(fdiff2[bragg] - deriv2[bragg]) / 1).mean()
            all_error2.append(error2)

        print ("error=%f, step=%f" % (error, delta_N))

    if args.plot:
        plt.plot(shifts, all_error, 'o')
        plt.show()
        if args.curvatures:
            plt.plot(shifts2, all_error2, 'o')
            plt.show()

    l = linregress(shifts, all_error)
    assert l.rvalue > .9999, l  # this is definitely a line!
    assert l.slope > 0
    assert l.pvalue < 1e-6
    assert l.intercept < 0.1*l.slope # line should go through origin
    if args.curvatures:
        l = linregress(shifts2, all_error2)
        assert l.rvalue > .9999  # this is definitely a line!
        assert l.slope > 0
        assert l.pvalue < 1e-6
        assert l.intercept < 0.1*l.slope # line should go through origin

    print("OK!")
    for name in find_diffBragg_instances(globals()): del globals()[name]


 *******************************************************************************


 *******************************************************************************
simtbx/diffBragg/tests/tst_diffBragg_ncells_property_anisotropic.py
"""
This test checks the setter and getter for Ncells parameter
"""
from __future__ import division
##from simtbx.kokkos import gpu_instance
#kokkos_run = gpu_instance(deviceId = 0)

from argparse import ArgumentParser
parser = ArgumentParser()
parser.add_argument("--kokkos", action="store_true")
parser.add_argument("--plot", action='store_true')
parser.add_argument("--curvatures", action='store_true')
parser.add_argument("--idx", default=0, help="0=Na, 1=Nb, 2=Nc", type=int, choices=[0,1,2])
args = parser.parse_args()
if args.kokkos:
    import os
    os.environ["DIFFBRAGG_USE_KOKKOS"]="1"
from simtbx.diffBragg.utils import find_diffBragg_instances
from simtbx.diffBragg.device import DeviceWrapper
with DeviceWrapper(0) as _:

    import numpy as np
    import pylab as plt
    from scipy.stats import linregress
    from scipy.spatial.transform import Rotation
    from simtbx.nanoBragg import sim_data
    from scitbx.matrix import sqr, rec
    from cctbx import uctbx
    from dxtbx.model import Crystal

    ucell = (70, 60, 50, 90.0, 110, 90.0)
    symbol = "C121"

    a_real, b_real, c_real = sqr(uctbx.unit_cell(ucell).orthogonalization_matrix()).transpose().as_list_of_lists()
    C = Crystal(a_real, b_real, c_real, symbol)

    # random raotation
    rotation = Rotation.random(num=1, random_state=101)[0]
    Q = rec(rotation.as_quat(), n=(4, 1))
    rot_ang, rot_axis = Q.unit_quaternion_as_axis_and_angle()
    C.rotate_around_origin(rot_axis, rot_ang)

    S = sim_data.SimData(use_default_crystal=True)
    S.crystal.dxtbx_crystal = C
    S.detector = sim_data.SimData.simple_detector(180, 0.1, (1024, 1024))
    S.instantiate_diffBragg(verbose=0, oversample=0, auto_set_spotscale=True)
    S.D.spot_scale = 100000
    #S.D.oversample = 5

    Ncells_id = 9

    S.D.Ncells_abc_aniso = 12, 13, 14
    Na, Nb, Nc = S.D.Ncells_abc_aniso

    assert (Na,Nb,Nc) == (12, 13, 14)

    print("OK")
    S.D.isotropic_ncells = False
    S.D.refine(Ncells_id)
    S.D.initialize_managers()
    ncells_GT = (20, 15, 17)

    S.D.Ncells_abc_aniso = ncells_GT
    S.D.Ncells_def = 0,0,0
    S.D.add_diffBragg_spots()

    img = S.D.raw_pixels_roi.as_numpy_array()
    derivs_abc = S.D.get_ncells_derivative_pixels()
    derivs_abc = [d.as_numpy_array() for d in derivs_abc]
    if args.curvatures:
        derivs2_abc = S.D.get_ncells_second_derivative_pixels()
        derivs2_abc = [d.as_numpy_array() for d in derivs2_abc]

    perc = 0.001, 0.01, 0.1, 1, 10
    bragg = img > 1e-1  # select bragg scattering regions

    Na, Nb, Nc = ncells_GT
    for i_nc in range(3):
        if i_nc != args.idx:
            continue

        N = ncells_GT[i_nc]
        print("Testing finite diff %d / 3, Ncells=%d" % (i_nc +1, N))

        all_error = []
        all_error2 = []
        shifts = []
        shifts2 = []
        for i_shift, p in enumerate(perc):
            delta_N = N*p*0.01

            Ncells_vals = [Na, Nb, Nc]
            Ncells_vals[i_nc] = N+delta_N

            S.D.Ncells_abc_aniso = tuple(Ncells_vals)
            shifts.append(delta_N)

            S.D.raw_pixels_roi *= 0
            #S.D.printout_pixel_fastslow = 10, 10
            S.D.add_diffBragg_spots()
            img2 = S.D.raw_pixels_roi.as_numpy_array()

            fdiff = (img2 - img) / delta_N
            deriv = derivs_abc[i_nc]
            error = np.abs(fdiff[bragg] - deriv[bragg]).mean()
            all_error.append(error)

            if args.curvatures:
                Ncells_vals = [Na, Nb, Nc]
                Ncells_vals[i_nc] = N - delta_N
                S.D.Ncells_abc_aniso = tuple(Ncells_vals)
                shifts2.append(delta_N**2)

                S.D.raw_pixels_roi *= 0
                S.D.add_diffBragg_spots()
                img_backward = S.D.raw_pixels_roi.as_numpy_array()

                fdiff2 = (img2 - 2*img + img_backward) / delta_N / delta_N

                second_deriv = derivs2_abc[i_nc]
                error2 = (np.abs(fdiff2[bragg] - second_deriv[bragg]) / 1).mean()
                all_error2.append(error2)

            print ("error=%f, step=%f" % (error, delta_N))
            if args.curvatures:
                print ("error2=%f, step=%f" % (error2, delta_N))
                print()

        if args.plot:
            plt.plot(shifts, all_error, 'o')
            plt.show()
            if args.curvatures:
                plt.plot(shifts2, all_error2, 'o')
                plt.show()

        l = linregress(shifts, all_error)
        assert l.rvalue > .9999  # this is definitely a line!
        assert l.slope > 0
        assert l.pvalue < 1e-6
        assert l.intercept < 0.1*l.slope # line should go through origin
        if args.curvatures:
            l = linregress(shifts2, all_error2)
            assert l.rvalue > .9999  # this is definitely a line!
            assert l.slope > 0
            assert l.pvalue < 1e-6
            assert l.intercept < 0.1*l.slope # line should go through origin

        print("OK!")
    for name in find_diffBragg_instances(globals()): del globals()[name]


 *******************************************************************************


 *******************************************************************************
simtbx/diffBragg/tests/tst_diffBragg_panelXY_derivs.py
from __future__ import division
##from simtbx.kokkos import gpu_instance
#kokkos_run = gpu_instance(deviceId = 0)
from simtbx.nanoBragg import sim_data

from argparse import ArgumentParser
parser = ArgumentParser()
parser.add_argument("--kokkos", action="store_true")
parser.add_argument("--plotimages", action='store_true')
parser.add_argument("--panel", choices=["x", "y", "z"], default="x", help="which origin coordinate to check")
parser.add_argument("--plotlines", action='store_true')
args = parser.parse_args()
if args.kokkos:
    import os
    os.environ["DIFFBRAGG_USE_KOKKOS"]="1"
from simtbx.diffBragg.utils import find_diffBragg_instances
from simtbx.diffBragg.device import DeviceWrapper
with DeviceWrapper(0) as _:
    SIM = sim_data.SimData(use_default_crystal=True)

    det = sim_data.SimData.simple_detector(detector_distance_mm=150, pixelsize_mm=0.1, image_shape=(512, 512))

    if args.panel == "x":
      refine_idx = 15  # id of origin coordinate in diffBragg
    elif args.panel == "y":
      refine_idx = 16  # id of origin coordinate in diffBragg
    else:  # args.panel==z
      refine_idx = 10

    B = SIM.beam.nanoBragg_constructor_beam

    # set the detector
    SIM.detector = det
    SIM.instantiate_diffBragg(auto_set_spotscale=True)
    D = SIM.D
    D.oversample_omega = True  #False
    D.nopolar = True

    D.refine(refine_idx)

    D.initialize_managers()
    D.add_diffBragg_spots()

    # get the simulated image and derivative
    img = D.raw_pixels_roi.as_numpy_array()
    deriv = D.get_derivative_pixels(refine_idx).as_numpy_array()
    D.raw_pixels_roi *= 0
    D.raw_pixels *= 0

    node = det[0]
    node_d = node.to_dict()
    O = node_d["origin"][0], node_d["origin"][1], node_d["origin"][2]
    OX,OY,OZ = O

    # update the detector distance
    import numpy as np
    all_shifts = []
    all_errors = []
    shifts_mm = [2*i*(1e-7) for i in range(1,30,2)]
    print(shifts_mm)
    import pylab as plt

    from dxtbx.model import Panel

    for i_shift, delta_shift in enumerate(shifts_mm):
      # update the detector model

      if args.panel=="x":
        shifted = OX+delta_shift, OY, OZ
      elif args.panel=="y":
        shifted = OX, OY+delta_shift, OZ
      else:
        delta_shift = delta_shift*10  # larger shift for Z
        shifted = OX, OY, OZ + delta_shift

      node_d["origin"] = shifted
      det[0] = Panel.from_dict(node_d)

      D.update_dxtbx_geoms(det, B, 0)
      D.add_diffBragg_spots()
      img_forward = D.raw_pixels_roi.as_numpy_array()
      D.raw_pixels_roi *= 0
      D.raw_pixels *= 0
      delta_shift_meters = delta_shift*1e-3
      fdiff = (img_forward-img)/delta_shift_meters

      bragg = img > 1e-2

      error = (np.abs(fdiff[bragg] - deriv[bragg])).mean()
      all_errors.append(error)

      all_shifts.append(delta_shift_meters)

      print("Error=%2.7g shift=%2.7g um" % (error, delta_shift*1000))
      if args.plotimages:
        plt.clf()
        y = slice(40, 65, 1)
        x = slice(415, 437, 1)
        plt.subplot(121)
        plt.imshow(fdiff[y, x])
        plt.title("finite diff")
        plt.subplot(122)
        plt.imshow(deriv[y, x])
        plt.title("analytical")
        plt.draw()
        plt.suptitle("delta=%f mm, Shift %d / %d"
                     % ( delta_shift, i_shift + 1, len(shifts_mm)))
        plt.pause(0.3)

    if args.plotlines:
      plt.close()

      plt.plot(all_shifts, all_errors, 'o')
      plt.suptitle("finite 1st difference error", fontsize=16)
      plt.xlabel("h", fontsize=16)
      plt.show()

    from scipy.stats import linregress
    l = linregress(all_shifts, all_errors)
    print("finite diff l.rvalue=%10.7g" % l.rvalue)
    assert l.rvalue > .99
    assert l.slope > 0
    assert l.pvalue < 1e-6
    assert l.intercept < 0.1*l.slope # line should go through origin

    print("OK!")
    for name in find_diffBragg_instances(globals()): del globals()[name]


 *******************************************************************************


 *******************************************************************************
simtbx/diffBragg/tests/tst_diffBragg_regions_of_interest.py
from __future__ import division
##from simtbx.kokkos import gpu_instance
#kokkos_run = gpu_instance(deviceId = 0)

def main():

    import numpy as np
    from simtbx.diffBragg.utils import get_diffBragg_instance
    from simtbx.diffBragg.utils import find_diffBragg_instances

    D = get_diffBragg_instance()
    D.nopolar = False
    D.interpolate = 0
    D.spot_scale = 1e5
    rois = (20, 100, 30, 100), (10, 90, 40, 80)
    #px = 39,52
    for x1, x2, y1, y2 in rois:
        D.raw_pixels *= 0
        D.region_of_interest = ((x1, x2), (y1, y2))
        #D.printout_pixel_fastslow = x1+px[0], y1+px[1]

        D.add_nanoBragg_spots()
        nano_pixels = D.raw_pixels.as_numpy_array()
        nano_roi_pixels = nano_pixels[y1:y2, x1:x2]

        D.raw_pixels *= 0
        D.vectorize_umats()
        D.add_diffBragg_spots()
        npix_sim = (x2-x1)*(y2-y1)
        diff_roi_pixels = D.raw_pixels_roi.as_numpy_array()[:npix_sim].reshape((y2-y1, x2-x1))

        assert np.allclose(diff_roi_pixels, nano_roi_pixels, atol=1e-9)
        for name in find_diffBragg_instances(globals()): del globals()[name]


if __name__ == "__main__":
    import sys
    if "--kokkos" in sys.argv:
        import os
        os.environ["DIFFBRAGG_USE_KOKKOS"]="1"
    from simtbx.diffBragg.device import DeviceWrapper

    with DeviceWrapper(0) as _:
        main()
    print ("OK!")


 *******************************************************************************


 *******************************************************************************
simtbx/diffBragg/tests/tst_diffBragg_rotXYZ.py
from __future__ import division
##from simtbx.kokkos import gpu_instance
#kokkos_run = gpu_instance(deviceId = 0)

from argparse import ArgumentParser
parser = ArgumentParser("diffBragg tests")
parser.add_argument("--plot", action='store_true')
parser.add_argument("--kokkos", action="store_true")
args = parser.parse_args()
if args.kokkos:
    import os
    os.environ["DIFFBRAGG_USE_KOKKOS"]="1"
from simtbx.diffBragg.utils import find_diffBragg_instances


def main():
    import numpy as np
    from simtbx.diffBragg.utils import get_diffBragg_instance
    from scitbx.matrix import col, sqr

    n_trials = 10
    np.random.seed(n_trials)
    angles_XYZ = np.random.random((n_trials, 3)) * 3 * np.pi / 180.
    print (angles_XYZ*180 / np.pi)

    D = get_diffBragg_instance()
    D.use_gpu = args.kokkos

    rotX, rotY, rotZ = 0, 1, 2
    D.refine(rotX)  # rotX
    D.refine(rotY)  # rotY
    D.refine(rotZ)  # rotZ

    D.initialize_managers()
    D.vectorize_umats()

    x = col((-1, 0, 0))
    y = col((0, -1, 0))
    z = col((0, 0, -1))
    Uorig = sqr(D.Umatrix)

    if args.plot:
        import pylab as plt
        plt.figure()
        axA = plt.subplot(121)
        axB = plt.subplot(122)
    for i_ang, (thetaX, thetaY, thetaZ) in enumerate(angles_XYZ):

        RX = x.axis_and_angle_as_r3_rotation_matrix(thetaX, deg=False)
        RY = y.axis_and_angle_as_r3_rotation_matrix(thetaY, deg=False)
        RZ = z.axis_and_angle_as_r3_rotation_matrix(thetaZ, deg=False)

        Misset = RX*RY*RZ
        U = Misset*Uorig
        D.raw_pixels *= 0
        D.set_value(rotX,0)
        D.set_value(rotY,0)
        D.set_value(rotZ,0)
        D.Umatrix = U.elems
        D.verbose = 1
        D.add_diffBragg_spots()
        if args.kokkos:
            D.gpu_free()
        imgA = D.raw_pixels.as_numpy_array()


        D.raw_pixels *= 0
        D.set_value(rotX, thetaX)
        D.set_value(rotY, thetaY)
        D.set_value(rotZ, thetaZ)
        D.Umatrix = Uorig
        D.add_diffBragg_spots()
        if args.kokkos:
            D.gpu_free()
        imgB = D.raw_pixels.as_numpy_array()
        if args.plot:
            m = imgA[ imgA > 0].mean()
            s = imgA[ imgA > 0].std()

            axA.clear()
            axB.clear()
            axA.imshow( imgA, vmin=0, vmax=m+2*s, cmap='gnuplot')
            axB.imshow( imgB, vmin=0, vmax=m+2*s, cmap='gnuplot')
            plt.draw()
            plt.pause(1.)

        assert(np.allclose(imgA, imgB, atol=1e-4))
        print("OK (%d / %d)" % (i_ang+1, len(angles_XYZ)))
        for name in find_diffBragg_instances(globals()): del globals()[name]


if __name__ == "__main__":
    from simtbx.diffBragg.device import DeviceWrapper
    with DeviceWrapper(0) as _:
        main()
    print("OK")


 *******************************************************************************


 *******************************************************************************
simtbx/diffBragg/tests/tst_diffBragg_rotXYZ_deriv.py
from __future__ import division
##from simtbx.kokkos import gpu_instance
#kokkos_run = gpu_instance(deviceId = 0)

from argparse import ArgumentParser
parser = ArgumentParser("diffBragg tests")
parser.add_argument("--plot", action='store_true')
parser.add_argument("--kokkos", action='store_true')
parser.add_argument("--curvatures", action='store_true')
parser.add_argument("--plotimages", action="store_true")
parser.add_argument("--rotidx", type=int, choices=[0,1,2], required=True)
parser.add_argument("--randomrotate", type=int, default=None, help="seed for random rotation of Umatrix")
args = parser.parse_args()
if args.kokkos:
    import os
    os.environ["DIFFBRAGG_USE_KOKKOS"]="1"
from simtbx.diffBragg.utils import find_diffBragg_instances
from simtbx.diffBragg.device import DeviceWrapper
with DeviceWrapper(0) as _:
    if args.plot:
        import pylab as plt
    from simtbx.nanoBragg.sim_data import SimData

    from simtbx.nanoBragg.nanoBragg_crystal import NBcrystal
    import numpy as np
    from scitbx.matrix import sqr
    from cctbx import uctbx
    from dxtbx.model import Crystal
    from scipy import stats

    rot_idx = args.rotidx

    ucell = (70, 60, 50, 90.0, 110, 90.0)
    symbol = "C121"

    a_real, b_real, c_real = sqr(uctbx.unit_cell(ucell).orthogonalization_matrix()).transpose().as_list_of_lists()
    C = Crystal(a_real, b_real, c_real, symbol)
    # make a nanoBragg crystal to pass to diffBragg
    nbcryst = NBcrystal()
    nbcryst.dxtbx_crystal = C
    nbcryst.n_mos_domains = 1
    nbcryst.thick_mm = 0.01
    nbcryst.Ncells_abc = (7, 7, 7)

    # make an instance of diffBRagg, use the simData wrapper
    SIM = SimData(use_default_crystal=True)
    # overwrite the default detector with a smaller pixels one
    SIM.detector = SimData.simple_detector(220, 0.1, (1000, 1000))
    SIM.crystal = nbcryst

    SIM.instantiate_diffBragg(oversample=0, verbose=0, interpolate=0, default_F=1e3,auto_set_spotscale=True)
    # D is an instance of diffBragg with reasonable parameters
    # and our dxtbx crystal created above
    D = SIM.D
    if args.curvatures:
        D.compute_curvatures = True

    # STEP 1: simulate the un-perturbed image:
    D.refine(rot_idx)
    D.initialize_managers()
    D.set_value(rot_idx, 0)
    D.use_gpu = args.kokkos
    #D.printout_pixel_fastslow = 786, 567
    D.add_diffBragg_spots()
    img0 = D.raw_pixels_roi.as_numpy_array()
    bragg = img0 > 1  #np.ones_like(img0).astype(bool)
    if args.plotimages:
        plt.title("Scattering from crystal")
        plt.imshow(img0)
        plt.show()

    deriv = D.get_derivative_pixels(rot_idx).as_numpy_array()
    if args.curvatures:
        second_deriv = D.get_second_derivative_pixels(rot_idx).as_numpy_array()

    error_vals = []
    error_vals2 = []
    delta_h = []
    delta_h2 = []
    theta_vals = [0.0005 + i*0.0005 for i in range(8)]   # 0.01, 0.02048, 0.04096, 0.08192, 0.16384, 0.32768, 0.65536, 1.31072, 2.62144

    for theta_degrees in theta_vals:
        theta = theta_degrees * np.pi / 180
        D.set_value(rot_idx, theta)

        # simulate the scattering in the rotated crystal:
        D.raw_pixels_roi *= 0
        D.add_diffBragg_spots()
        img_plus = D.raw_pixels_roi.as_numpy_array()
        if args.curvatures:
            D.set_value(rot_idx, -theta)
            D.raw_pixels_roi *= 0
            D.add_diffBragg_spots()
            img_minus = D.raw_pixels_roi.as_numpy_array()
            finite_second_diff = (img_plus-2*img0 + img_minus) / theta / theta
            delta_h2.append(theta**2)

        # STEP3 : compute finite differenceL
        finite_diff = (img_plus-img0)/theta
        delta_h.append(theta)

        if args.plotimages:
            plt.subplot(121)
            plt.imshow(finite_diff)
            plt.title("finite diff.")
            plt.subplot(122)
            plt.imshow(deriv)
            plt.title("analytical")
            plt.suptitle("Theta = %f deg. " % theta_degrees)
            plt.draw()
            plt.pause(1)
            if args.curvatures:
                plt.clf()
                plt.subplot(121)
                plt.imshow(finite_second_diff)
                plt.title("finite 2nd diff.")
                plt.subplot(122)
                plt.imshow(second_deriv)
                plt.title("analytical")
                plt.suptitle("Theta = %f deg. " % theta_degrees)
                plt.draw()
                plt.pause(0.2)

        error_image = abs(deriv[bragg]-finite_diff[bragg])
        error = error_image.mean()
        error_vals.append(error)

        if args.curvatures:
            error_image2 = abs(second_deriv[bragg]-finite_second_diff[bragg])
            error2 = error_image2.mean()
            print("Theta = %.4f deg, 1st error = %2.7g, 2nd %2.7g" %
                    (theta_degrees, error, error2))
            error_vals2.append(error2)
        else:
            print("Theta = %.4f deg, 1st error = %2.7g" %
                  (theta_degrees, error))

    if args.plot:
        plt.close()
        plt.plot(delta_h, error_vals, '.')
        ax = plt.gca()
        ax.set_xlabel("theta (rad.)")
        ax.set_ylabel(r"$\langle |\,$finite_diff - analytical$\,| \rangle$", fontsize=14)
        plt.ticklabel_format(style='sci', axis='y', scilimits=(0, 0))
        plt.subplots_adjust(left=0.12)
        plt.show()
        if args.curvatures:
            plt.plot(delta_h2, error_vals2, '.')
            ax = plt.gca()
            ax.set_xlabel("theta^2 (rad.^2)")
            ax.set_ylabel(r"$\langle |\,$finite_second_diff - analytical$\,| \rangle$", fontsize=14)
            plt.ticklabel_format(style='sci', axis='x', scilimits=(0, 0))
            plt.subplots_adjust(left=0.12)
            plt.show()

    l = stats.linregress(delta_h, error_vals)
    assert l.rvalue > .9999, "%2.7g" % l.rvalue
    assert l.slope > 0, "%2.7g" % l.slope
    assert l.pvalue < 1e-6, "%2.7g" % l.pvalue
    assert l.intercept < 0.1*l.slope, "%2.7g" % l.intercept
    if args.curvatures:
        l = stats.linregress(delta_h2, error_vals2)
        assert l.rvalue > .9999, "2nd deriv rvalue %2.7g" % l.rvalue
        assert l.slope > 0, "2nd deriv slope %2.7g" % l.slope
        assert l.pvalue < 1e-6, "2nd deriv pvalue %2.7g" % l.pvalue
        assert l.intercept < 0.1*l.slope, "2nd deriv pvalue %2.7g" % l.intercept
    if args.kokkos:
        D.gpu_free()
    print("OK!")
    for name in find_diffBragg_instances(globals()): del globals()[name]


 *******************************************************************************


 *******************************************************************************
simtbx/diffBragg/tests/tst_diffBragg_rotation.py
from __future__ import absolute_import, division, print_function
from simtbx.kokkos import gpu_instance
kokkos_run = gpu_instance(deviceId = 0)
from simtbx.diffBragg import utils, hopper_utils
from simtbx.nanoBragg.tst_nanoBragg_multipanel import beam as dxtbx_beam
from simtbx.nanoBragg.tst_nanoBragg_multipanel import whole_det as dxtbx_det
from simtbx.nanoBragg import nanoBragg_crystal, nanoBragg_beam, sim_data
from iotbx.crystal_symmetry_from_any import extract_from
from dxtbx_model_ext import Crystal
from scitbx import matrix
import numpy as np
# from simtbx.nanoBragg import shapetype
# from simtbx.nanoBragg import nanoBragg
import libtbx.load_env # possibly implicit

pdb_lines = """HEADER TEST
CRYST1   50.000   60.000   70.000  90.00  90.00  90.00 P 1
ATOM      1  O   HOH A   1      56.829   2.920  55.702  1.00 20.00           O
ATOM      2  O   HOH A   2      49.515  35.149  37.665  1.00 20.00           O
ATOM      3  O   HOH A   3      52.667  17.794  69.925  1.00 20.00           O
ATOM      4  O   HOH A   4      40.986  20.409  18.309  1.00 20.00           O
ATOM      5  O   HOH A   5      46.896  37.790  41.629  1.00 20.00           O
ATOM      6 SED  MSE A   6       1.000   2.000   3.000  1.00 20.00          SE
END
"""

FAST, SLOW=228,104  # center of one of the Bragg peaks

def write_test_pdb(fileout="test.pdb"):
  from iotbx import pdb
  pdb_inp = pdb.input(source_info=None,lines = pdb_lines)
  pdb_inp.write_pdb_file(fileout)
  return fileout

def run_sim(testpdb, version="nanoBragg", spindle_axis=(1,0,0), phi_start=0, phistep_deg=-1, phisteps=-1, osc_deg=-1):
  # crystal
  symmetry=extract_from(testpdb)
  sg = str(symmetry.space_group_info())
  fmat = matrix.sqr(symmetry.unit_cell().fractionalization_matrix())
  dxtbx_cryst = Crystal(fmat, sg)
  crystal = nanoBragg_crystal.NBcrystal(init_defaults=True)
  crystal.isotropic_ncells = False
  crystal.dxtbx_crystal = dxtbx_cryst
  crystal.Ncells_abc = 10,10,10
  crystal.n_mos_domains = 1 # TODO: setting this causes discrepancy
  crystal.mos_spread_deg = 0#1
  symbol = dxtbx_cryst.get_space_group().info().type().lookup_symbol()
  ucell_p = dxtbx_cryst.get_unit_cell().parameters()
  miller_data = utils.make_miller_array(symbol, ucell_p, defaultF=1000)
  crystal.symbol = miller_data.crystal_symmetry().space_group_info().type().lookup_symbol()
  crystal.miller_array = miller_data
  # beam
  beam = nanoBragg_beam.NBbeam()
  beam.size_mm = 0.001
  beam.unit_s0 = dxtbx_beam.get_unit_s0()
  spectrum = [(dxtbx_beam.get_wavelength(), 1e12)]
  beam.spectrum = spectrum
  # detector
  fsize, ssize = dxtbx_det[0].get_image_size()
  pfs = hopper_utils.full_img_pfs((1,ssize,fsize))
  # simulator
  SIM = sim_data.SimData()
  SIM.detector = utils.strip_thickness_from_detector(dxtbx_det)
  SIM.detector = dxtbx_det
  SIM.crystal = crystal
  SIM.beam = beam
  SIM.panel_id = 0
  def setup_rotation(SIM):
    SIM.D.spindle_axis=spindle_axis
    SIM.D.phi_deg = phi_start
    SIM.D.phistep_deg = phistep_deg
    SIM.D.phisteps = phisteps
  if version == "nanoBragg":
    SIM.instantiate_nanoBragg(oversample=1, device_Id=0, default_F=0)
    SIM.D.printout_pixel_fastslow = FAST,SLOW
    setup_rotation(SIM)
    SIM.D.show_params()

    SIM.D.add_nanoBragg_spots()
    pix = SIM.D.raw_pixels.as_numpy_array()
    SIM.D.free_all()
    return pix
  else:
    SIM.instantiate_diffBragg(oversample=1, device_Id=0, default_F=0)
    SIM.D.xray_beams = SIM.beam.xray_beams
    ucell_man = utils.manager_from_params(ucell_p)
    Bmatrix = ucell_man.B_recipspace
    SIM.D.Bmatrix = Bmatrix

    npix = int(len(pfs)/3)
    SIM.D.printout_pixel_fastslow = FAST,SLOW
    setup_rotation(SIM)
    SIM.D.show_params()

    SIM.D.add_diffBragg_spots_full()
    pix = SIM.D.raw_pixels_roi.as_numpy_array()
    SIM.D.free_all()
    return pix

def assert_identical_pixels(pix1, pix2):
  assert np.allclose(pix1,pix2)

def test_range_of_rotation_steps():
  # automatic param setting for phistep_deg, phisteps and osc_deg when passed values are <0
  # conflicting params are tolerated and should be handled with the same decision tree
  testpdb = write_test_pdb(fileout="test.pdb")
  for phi_start in (0, 30):
    for phistep_deg in (-1, 0.01, 0.1):
      for phisteps in (-1, 1, 10):
        for osc_deg in (-1, 0.1, 1):
          pix1 = run_sim(
                  testpdb,
                  version="nanoBragg",
                  spindle_axis=(1,0,0),
                  phi_start=phi_start,
                  phistep_deg=phistep_deg,
                  phisteps=phisteps,
                  osc_deg=osc_deg)#, fileout="rotimg_nano_%03d.h5")
          pix2 = run_sim(
                  testpdb,
                  version="diffBragg",
                  spindle_axis=(1,0,0),
                  phi_start=phi_start,
                  phistep_deg=phistep_deg,
                  phisteps=phisteps,
                  osc_deg=osc_deg)#, fileout="rotimg_diff_%03d.h5")
          pix2 = pix2.reshape(pix1.shape)
          assert_identical_pixels(pix1, pix2)

def test_sweep():
  testpdb = write_test_pdb(fileout="test.pdb")
  for phi_start in range(10):
    pix1 = run_sim(
            testpdb,
            version="nanoBragg",
            spindle_axis=(1,0,0),
            phi_start=phi_start,
            phistep_deg=0.05,
            phisteps=20,
            osc_deg=1)#, fileout="rotimg_nano_%03d.h5")
    pix2 = run_sim(
            testpdb,
            version="diffBragg",
            spindle_axis=(1,0,0),
            phi_start=phi_start,
            phistep_deg=0.05,
            phisteps=20,
            osc_deg=1)#, fileout="rotimg_diff_%03d.h5")
    pix2 = pix2.reshape(pix1.shape)
    assert_identical_pixels(pix1, pix2)

def tst_all():
  import os
  # currently only tests CPU implementation
  if "DIFFBRAGG_USE_CUDA" in os.environ:
    os.environ.unsetenv("DIFFBRAGG_USE_CUDA")
  #os.environ["DIFFBRAGG_USE_CUDA"]=1
  test_range_of_rotation_steps()
  test_sweep()

if __name__=="__main__":
  tst_all()
  print("OK")


 *******************************************************************************


 *******************************************************************************
simtbx/diffBragg/tests/tst_diffBragg_structure_factors.py
from __future__ import division

from simtbx.diffBragg import utils
from simtbx.nanoBragg.tst_nanoBragg_basic import pdb_lines
from simtbx.diffBragg.phil import hopper_phil, philz
from libtbx.phil import parse
from simtbx.nanoBragg import tst_nanoBragg_multipanel
from dxtbx.model import Experiment
import numpy as np

# make a dummie experiment
expt = Experiment()
expt.detector = tst_nanoBragg_multipanel.whole_det
expt.beam = tst_nanoBragg_multipanel.beam
expt.crystal = tst_nanoBragg_multipanel.cryst

# write a dummie PDB file
PDB = "1234.pdb"
o = open(PDB, "w")
o.write(pdb_lines)
o.close()

# Create a miller array from on-disk PDB file
F = utils.get_complex_fcalc_from_pdb(PDB,
    wavelength=expt.beam.get_wavelength(),
    dmin=2, dmax=20, k_sol=0.2, b_sol=20)
F = F.as_amplitude_array()
Fmap = {h: amp for h,amp in zip(F.indices(), F.data())}
res_map = {h: res for h,res in zip(F.d_spacings().indices(), F.d_spacings().data())}

# Create a sim_data class instance as would be done for hopper_utils.refine for example
phil_scope = parse(hopper_phil+philz)
params = phil_scope.extract()
params.simulator.structure_factors.from_pdb.name = PDB
params.simulator.structure_factors.from_pdb.add_anom = True
params.simulator.structure_factors.from_pdb.k_sol = 0.2
params.simulator.structure_factors.from_pdb.b_sol = 20
params.simulator.structure_factors.dmin = 2
params.simulator.structure_factors.dmax = 20


SIM = utils.simulator_from_expt_and_params(expt, params)

# verify the miller arrary
F_from_SIM = SIM.crystal.miller_array
F_from_SIM_map = {h:amp for h,amp in zip(F_from_SIM.indices(), F_from_SIM.data())}
for h in Fmap:
    assert Fmap[h] == F_from_SIM_map[h]

# verify the miller data within the diffBragg object
db_instance = SIM.D
db_inds, db_amps = db_instance.Fhkl_tuple
db_Fmap = {h: amp for h, amp in zip(db_inds, db_amps)}
# note diffBragg only models refls out to a certain resolution(see sim_data, update Fhkl tuple method)
# and values outside of this resolution shell will be 0 or not present
dmin = SIM.get_detector_corner_res()
for h in Fmap:
    if h not in db_Fmap:
        assert res_map[h] < dmin
        continue
    if db_Fmap[h] == 0:
        assert res_map[h] < dmin
        continue
    assert Fmap[h] == db_Fmap[h]


# create a default array, and verify it
params.simulator.structure_factors.from_pdb.name = None
params.simulator.structure_factors.default_F = 1234
SIM_def = utils.simulator_from_expt_and_params(expt, params)

inds,amps = SIM_def.D.Fhkl_tuple
for hkl,amp in zip(inds, amps):
    if hkl== (0,0,0):
        assert amp == 0
    else:
        assert amp==1234

# save as F as an MTZ file
MTZ="Ftester.mtz"
col="Famp"
F.as_mtz_dataset(column_root_label="Famp").mtz_object().write(MTZ)
# create a sim data object with structure factors loaded from MTZ file
params.simulator.structure_factors.default_F = 0
params.simulator.structure_factors.mtz_name = MTZ
params.simulator.structure_factors.mtz_column = "%s(+),%s(-)" % (col,col)
SIM_mtz = utils.simulator_from_expt_and_params(expt, params)
# verify
F_from_SIM2 = SIM_mtz.crystal.miller_array
F_from_SIM2_map = {h:amp for h,amp in zip(F_from_SIM2.indices(), F_from_SIM2.data())}

avals,avals2 = [],[]
for h in Fmap:
    if h not in F_from_SIM2_map:
        assert res_map[h] < dmin
        continue
    if F_from_SIM2_map[h] == 0:
        assert res_map[h] < dmin
        continue
    avals.append(Fmap[h])
    avals2.append(F_from_SIM2_map[h])
assert np.allclose(avals, avals2)
# with MTZ writing there is a loss in precision, hence equality only holds up to float32
assert np.all(np.float32(avals)==np.float32(avals2))

print("OK")
from simtbx.diffBragg.utils import find_diffBragg_instances
from simtbx.diffBragg.device import DeviceWrapper
with DeviceWrapper(0) as _:
    for name in find_diffBragg_instances(globals()): del globals()[name]


 *******************************************************************************


 *******************************************************************************
simtbx/diffBragg/tests/tst_diffBragg_unitcell_property.py
from __future__ import division

from argparse import ArgumentParser
parser = ArgumentParser()
parser.add_argument("--plot", action='store_true')
parser.add_argument("--crystalsystem", default='tetragonal',
                    choices=["monoclinic", "tetragonal", "hexagonal"])
parser.add_argument("--curvatures", action='store_true')
parser.add_argument("--kokkos", action="store_true")
args = parser.parse_args()

if args.kokkos:
    import os
    os.environ["DIFFBRAGG_USE_KOKKOS"]="1"
from simtbx.diffBragg.utils import find_diffBragg_instances
from simtbx.diffBragg.device import DeviceWrapper
with DeviceWrapper(0) as _:

    import numpy as np
    from scipy.spatial.transform import Rotation
    from scipy.stats import pearsonr
    import pylab as plt
    from scipy.stats import linregress
    from simtbx.diffBragg.hopper_utils import UCELL_ID_OFFSET
    from scitbx.matrix import sqr
    from scitbx.matrix import rec
    from simtbx.nanoBragg.nanoBragg_crystal import NBcrystal
    from cctbx import uctbx
    from simtbx.nanoBragg.sim_data import SimData
    from simtbx.diffBragg import utils
    from dxtbx.model.crystal import Crystal


    # STEP 1:
    # make a crystal and orient it randomly
    if args.crystalsystem=="tetragonal":
        ucell = (55, 55, 77, 90, 90, 90)
        symbol = "P43212"
    elif args.crystalsystem=="hexagonal":
        ucell = (55, 55, 77, 90, 90, 120)
        symbol = "P6522"
    else:  # args.crystalsystem == "monoclinic"
        ucell = (70, 60, 50, 90.0, 110, 90.0)
        symbol = "C121"

    a_real, b_real, c_real = sqr(uctbx.unit_cell(ucell).orthogonalization_matrix()).transpose().as_list_of_lists()
    C = Crystal(a_real, b_real, c_real, symbol)

    # random raotation
    rotation = Rotation.random(num=1, random_state=101)[0]
    Q = rec(rotation.as_quat(), n=(4, 1))
    rot_ang, rot_axis = Q.unit_quaternion_as_axis_and_angle()
    C.rotate_around_origin(rot_axis, rot_ang)

    # STEP3:
    # create the unit cell parameter manager
    UcellMan = utils.manager_from_params(ucell)
    n_ucell_params = len(UcellMan.variables)
    assert np.allclose(UcellMan.B_recipspace, C.get_B())

    # STEP4:
    # make a nanoBragg crystal to pass to diffBragg
    nbcryst = NBcrystal(init_defaults=True)
    nbcryst.dxtbx_crystal = C
    nbcryst.n_mos_domains = 1
    nbcryst.thick_mm = 0.01
    nbcryst.Ncells_abc = (7, 7, 7)

    # STEP5: make an instance of diffBRagg, use the simData wrapper
    SIM = SimData()
    # overwrite the default detector to use smaller pixels
    img_sh = 700,700
    SIM.detector = SimData.simple_detector(300, 0.1, img_sh)
    SIM.crystal = nbcryst
    SIM.instantiate_diffBragg(oversample=0, verbose=0, auto_set_spotscale=True)
    # D is an instance of diffBragg with sensible parameters
    # and our dxtbx crystal created above
    D = SIM.D
    D.progress_meter = True
    D.compute_curvatures = args.curvatures

    # STEP6:
    # initialize the derivative managers for the unit cell parameters
    for i_param in range(n_ucell_params):
        D.refine(UCELL_ID_OFFSET+i_param)
    for i in range(n_ucell_params):
        D.set_ucell_derivative_matrix(UCELL_ID_OFFSET+i, UcellMan.derivative_matrices[i])
        if args.curvatures:
            D.set_ucell_second_derivative_matrix(UCELL_ID_OFFSET + i, UcellMan.second_derivative_matrices[i])
    D.initialize_managers()


    # STEP7:
    # compute the scattering and its derivative
    print("Adding diffBragg spots")
    #D.printout_pixel_fastslow =150, 351
    D.add_diffBragg_spots()
    print("Done!")
    img = D.raw_pixels_roi.as_numpy_array()
    # reset all pixel values
    D.raw_pixels *= 0
    D.raw_pixels_roi *= 0

    derivs = []
    second_derivs = []
    for i_param in range(n_ucell_params):
        analy_deriv = D.get_derivative_pixels(UCELL_ID_OFFSET+i_param).as_numpy_array()
        derivs.append(analy_deriv)
        if args.curvatures:
            second_derivs.append(D.get_second_derivative_pixels(UCELL_ID_OFFSET+i_param).as_numpy_array())

    # STEP8
    # iterate over the parameters and do a finite difference test for each one
    # parameter shifts:
    shifts = [1e-4*(2*i) for i in range(1, 12, 2)]

    import copy
    starting_var = copy.copy(UcellMan.variables)
    for i_param in range(n_ucell_params):
        analy_deriv = derivs[i_param]
        cc_vals = []
        cc_vals2 = []
        error = []
        error2 = []
        h_vals = []
        for i_shift, percent_shift in enumerate(shifts):

            var = copy.copy(starting_var)

            param_shift = var[i_param] * percent_shift

            var[i_param] += param_shift
            UcellMan.variables = var

            D.Bmatrix = UcellMan.B_recipspace
            D.add_diffBragg_spots()

            img_forward = D.raw_pixels_roi.as_numpy_array()

            # reset for next computation
            D.raw_pixels_roi *= 0
            D.raw_pixels *= 0

            if args.curvatures:
                # estimate the second derivative
                var[i_param] = var[i_param] - 2*param_shift  # do the backwards finite deriv
                UcellMan.variables = var

                D.Bmatrix = UcellMan.B_recipspace
                D.add_diffBragg_spots()

                img_backward = D.raw_pixels_roi.as_numpy_array()

                # reset for next computation
                D.raw_pixels_roi *= 0
                D.raw_pixels *= 0

            finite_deriv = (img_forward-img) / param_shift

            if second_derivs:
                finite_second_deriv = (img_forward - 2*img + img_backward) / param_shift / param_shift

            bragg = img > 0.5

            ave_error = np.abs(finite_deriv[bragg] - analy_deriv[bragg]).mean()

            r = pearsonr(analy_deriv[bragg].ravel(), finite_deriv[bragg].ravel())[0]
            cc_vals.append(r)

            error.append(ave_error)
            h_vals.append( param_shift)
            print ("\tAverage error=%f; parameter shift h=%f" % (ave_error, abs(param_shift)))
            if args.curvatures:
                ave_error2 = np.abs(finite_second_deriv[bragg] - second_derivs[i_param][bragg]).mean()
                print("\tsecond derivative Average error=%f; parameter shift squared h^2=%f"
                      % (ave_error2, abs(param_shift)**2))
                r2 = pearsonr(second_derivs[i_param][bragg].ravel(), finite_second_deriv[bragg].ravel())[0]

                error2.append(ave_error2)
                cc_vals2.append(r2)
            if args.plot:
                plt.subplot(121)
                plt.imshow(finite_deriv.reshape((img_sh)))
                plt.title("finite diff")
                plt.subplot(122)
                plt.imshow(analy_deriv.reshape((img_sh)))
                plt.title("analytical")
                plt.draw()
                plt.suptitle("Shift %d / %d"
                             % (i_shift+1, len(shifts)))
                plt.pause(1.2)
                if args.curvatures:
                    plt.subplot(121)
                    plt.imshow(finite_second_deriv.reshape((img_sh)))
                    plt.title("finite second diff")
                    plt.subplot(122)
                    plt.imshow(second_derivs[i_param].reshape((img_sh)))
                    plt.title("analytical")
                    plt.draw()
                    plt.suptitle("Shift %d / %d"
                                 % (i_shift + 1, len(shifts)))
                    plt.pause(1.2)

        l = linregress(h_vals, error)

        print ("finite diff l.rvalue=%10.7g" % l.rvalue)
        assert l.rvalue > .99
        assert l.slope > 0
        assert l.pvalue < 1e-6
        assert l.intercept < 0.1*l.slope

        if args.curvatures:
            l2 = linregress(np.array(h_vals)**2, error2)
            print ("finite 2nd diff l.rvalue=%10.7g" % l2.rvalue)
            assert l2.rvalue > .99
            assert l2.slope > 0
            assert l2.pvalue < 1e-6
            assert l2.intercept < 0.1*l2.slope

        if args.plot:
            plt.close()
            plt.plot(shifts, cc_vals, 'o')
            title = "Unit cell parameter %d / %d" % (i_param+1, n_ucell_params)
            plt.title(title + "\nPearson corr between finite deriv and analytical")
            plt.xlabel("unit cell shifts")
            plt.ylabel("Pearson corr")
            plt.show()
            if args.curvatures:
                plt.close()
                plt.plot(np.array(shifts)**2, cc_vals2, 'o')
                title = "Unit cell parameter %d / %d" % (i_param + 1, n_ucell_params)
                plt.title(title + "\nPearson corr between finite second deriv and analytical")
                plt.xlabel("unit cell shifts")
                plt.ylabel("Pearson corr")
                plt.show()

        # verify a high correlation for the smallest parameter shift
        print("Check high pearson R between analytical and finite diff")
        print("Pearson correlection at smallest parameter shift=%f" % cc_vals[0])
        assert(cc_vals[0] > .98), "%f" % cc_vals[0]
        # check monotonic decrease
        print("Fit polynomial and check monotonic decrease")
        trend = np.polyval(np.polyfit(shifts, cc_vals, 2), shifts)
        assert np.all(np.diff(list(zip(trend[:-1], trend[1:])), axis=1) <= 0)
        if args.curvatures:
            assert (cc_vals2[0] > .99), "%f" % cc_vals2[0]
    print("OK!")
    for name in find_diffBragg_instances(globals()): del globals()[name]


 *******************************************************************************


 *******************************************************************************
simtbx/diffBragg/tests/tst_diffBragg_update_dxtbx_geoms.py
"""
We need a way to update geometric properties
via dxtbx objects, without re-instantiating the simulator
These unit tests check our functon update_dxtbx_geoms which allows
one to update those models for beam/detector post-instantiation
"""
from __future__ import division

import numpy as np
from simtbx.nanoBragg import sim_data
from dxtbx.model import Panel

import sys
if "--kokkos" in sys.argv:
    import os
    os.environ["DIFFBRAGG_USE_KOKKOS"]="1"
from simtbx.diffBragg.utils import find_diffBragg_instances
from simtbx.diffBragg.device import DeviceWrapper
with DeviceWrapper(0) as _:
    # make a simple detector
    det = sim_data.SimData.simple_detector(detector_distance_mm=150, pixelsize_mm=0.1, image_shape=(512, 512))

    SIM = sim_data.SimData(use_default_crystal=True)
    # snag the beam for later use
    B = SIM.beam.nanoBragg_constructor_beam
    # set the detector
    SIM.detector = det
    SIM.instantiate_diffBragg(auto_set_spotscale=True)
    D = SIM.D
    D.add_diffBragg_spots()
    # get the simulated image
    img = D.raw_pixels.as_numpy_array()
    D.raw_pixels *= 0  # reset

    # update the geom to the same thing as it already is (sanity check)
    D.update_dxtbx_geoms(det, B, 0)
    D.update_dxtbx_geoms(det, B, 0)  # do it a few times to ensure no beam center isnt walking
    D.update_dxtbx_geoms(det, B, 0)
    D.add_diffBragg_spots()
    img2 = D.raw_pixels.as_numpy_array()
    # verify the images are the same
    assert np.allclose(img, img2)
    D.raw_pixels *= 0  # reset the pixels

    # make a new detector with shifted detector distance
    det2 = sim_data.SimData.simple_detector(detector_distance_mm=151, pixelsize_mm=0.1, image_shape=(512, 512))
    D.update_dxtbx_geoms(det2, B, 0)
    # simulate the new pattern
    D.add_diffBragg_spots()
    img3 = D.raw_pixels.as_numpy_array()
    D.free_all()  # free c++ objects

    # make a new diffBragg instantiating directly using the shifted detector
    # e.g. use the nanoBragg dxtbx constructor
    SIM = sim_data.SimData(use_default_crystal=True)
    SIM.detector = det2
    SIM.instantiate_diffBragg(auto_set_spotscale=True)
    # make the new pattern and verify its the same as img3
    SIM.D.add_diffBragg_spots()
    img4 = SIM.D.raw_pixels.as_numpy_array()
    assert np.allclose(img3, img4)

    # modify the detector dxtbx object directly to produce the same pattern:
    # NOTE: this is how we can adjust the detector distance without re-instantiating
    node = det[0]
    node_d = node.to_dict()
    O = node_d["origin"]
    distance_shift = -1
    O2 = O[0], O[1], O[2] + distance_shift
    node_d["origin"] = O2
    det[0] = Panel.from_dict(node_d)
    assert det == det2
    # NOTE: too bad dxtbx doesnt seem to have a set_origin or set_fdet

    SIM.D.update_dxtbx_geoms(det, B, 0)
    SIM.D.raw_pixels *= 0
    SIM.D.add_diffBragg_spots()
    img5 = SIM.D.raw_pixels.as_numpy_array()
    assert np.allclose(img4, img5)

    # sanity check:
    assert np.allclose(det[0].get_beam_centre(B.get_s0()), SIM.D.beam_center_mm)

    print("OK!")
    for name in find_diffBragg_instances(globals()): del globals()[name]


 *******************************************************************************


 *******************************************************************************
simtbx/diffBragg/tests/tst_diffBragg_utils.py
from __future__ import division, print_function
import numpy as np
from simtbx.diffBragg import stage_two_utils
from simtbx.diffBragg.phil import phil_scope

PARAMS = phil_scope.extract()

import logging
import sys
logger = logging.getLogger()
handler = logging.StreamHandler(sys.stdout)
format = "%(filename)s:%(funcName)s >> %(message)s"
F = logging.Formatter(format)
handler.setFormatter(fmt=F)
logger.setLevel(logging.INFO)
handler.setLevel(logging.INFO)
logger.addHandler(handler)


def test_regions():
    """divides the detector into square regions for doing gain correction refinement"""
    PARAMS.refiner.region_size = 60, 60
    det_shape = 1, 514, 1030
    regions = stage_two_utils.regionize_detector(det_shape, PARAMS.refiner.region_size)
    nregions = len(np.unique(regions))
    assert nregions == 162

    det_shape = 2, 514, 1030
    regions = stage_two_utils.regionize_detector(det_shape, PARAMS.refiner.region_size)
    nregions = len(np.unique(regions))
    assert nregions == 324
    logger.info("OK")


if __name__ == "__main__":
    print("OK")


 *******************************************************************************


 *******************************************************************************
simtbx/diffBragg/tests/tst_hopper_usecase.py
from __future__ import division
from libtbx.mpi4py import MPI
COMM = MPI.COMM_WORLD
from dxtbx.model import DetectorFactory, BeamFactory
from simtbx.nanoBragg.tst_nanoBragg_multipanel import det_descr, beam_descr
from simtbx.diffBragg import diffBragg

from argparse import ArgumentParser
parser = ArgumentParser()
parser.add_argument("--ngpu", type=int, default=1)
parser.add_argument("--kokkos", action="store_true")
args = parser.parse_args()
NGPU_PER_NODE = args.ngpu
if args.kokkos:
    import os
    os.environ["DIFFBRAGG_USE_KOKKOS"] = "1"

GPU_ID = COMM.rank % NGPU_PER_NODE
beam = BeamFactory.from_dict(beam_descr)
det = DetectorFactory.from_dict(det_descr)

from simtbx.diffBragg.utils import find_diffBragg_instances
from simtbx.diffBragg.device import DeviceWrapper
with DeviceWrapper(GPU_ID) as wrapper:
    for i in range(COMM.size*3):
        if i % COMM.size != COMM.rank:
            continue
        D = diffBragg(det, beam)
        D.verbose = 1
        D.vectorize_umats()
        for _ in range(5):
            D.add_diffBragg_spots()

        D.free_all()
        D.free_Fhkl2()
        print("RANK %d, done with Iter %d" % (COMM.rank, i+1))

    # TODO: the following deletion of the diffBragg instance is necessary to prevent the deallocation error
    # is there someway around this ????
    for name in find_diffBragg_instances(globals()): del globals()[name]
    print("OK!")


 *******************************************************************************


 *******************************************************************************
simtbx/diffBragg/utils.py
from __future__ import absolute_import, division, print_function
import os
import socket
import sys
import re
from io import StringIO
import numpy as np
from scipy import fft
import pickle
from scipy.optimize import minimize
from scipy.ndimage import generate_binary_structure, maximum_filter, binary_erosion
from cctbx.array_family import flex
from cctbx import miller, sgtbx
from cctbx.crystal import symmetry
from dxtbx.model import Detector, Panel
from simtbx.nanoBragg.sim_data import SimData
from simtbx.nanoBragg.nanoBragg_beam import NBbeam
from simtbx.nanoBragg.nanoBragg_crystal import NBcrystal
from simtbx.diffBragg import phil
from simtbx.nanoBragg.utils import ENERGY_CONV
from simtbx.diffBragg.refiners.crystal_systems import OrthorhombicManager, TetragonalManager, MonoclinicManager, HexagonalManager
from dxtbx.imageset import MemReader
from dxtbx.imageset import ImageSet, ImageSetData
from dxtbx.model.experiment_list import ExperimentListFactory
import libtbx
from libtbx.phil import parse
from dials.array_family import flex as dials_flex
import mmtbx.programs.fmodel
import mmtbx.utils
from cctbx.eltbx import henke
from simtbx.diffBragg import psf
from dials.algorithms.shoebox import MaskCode
from xfel.merging.application.utils.memory_usage import get_memory_usage


import logging
MAIN_LOGGER = logging.getLogger("diffBragg.main")


def strong_spot_mask(refl_tbl, detector, as_composite=True):
    """
    Form an image of the strong spot masks (True indicates strong spot)
    :param refl_tbl: dials reflection table with shoeboxes
    :param detector: dxtbx detecto model
    :param as_composite: return a single mask same shape as detector, else return shoebox masks as a lst
    """
    Nrefl = len( refl_tbl)
    masks = [ refl_tbl[i]['shoebox'].mask.as_numpy_array()
              for i in range(Nrefl)]
    pids = refl_tbl['panel']
    nfast, nslow = detector[0].get_image_size()
    npan = len(detector)
    code = MaskCode.Foreground.real

    x1, x2, y1, y2, z1, z2 = zip(*[refl_tbl[i]['shoebox'].bbox
                                   for i in range(Nrefl)])
    if not as_composite:
        spot_masks = []
    spot_mask = np.zeros((npan, nslow, nfast), bool)
    for i_ref, (i1, i2, j1, j2, M) in enumerate(zip(x1, x2, y1, y2, masks)):

        slcX = slice(i1, i2, 1)
        slcY = slice(j1, j2, 1)
        spot_mask[pids[i_ref],slcY, slcX] = M & code == code
        if not as_composite:
            spot_masks.append(spot_mask.copy())
            spot_mask *= False
    if as_composite:
        return spot_mask
    else:
        return spot_masks


def label_background_pixels(roi_img, thresh=3.5, iterations=1, only_high=True):
    """
    roi_img, a two dimensional pixel image numpy array
    thresh, median deviation Z-score; pixels with Z-score below thresh are flagged as background
    iterations, lots of bright pixels can skew the stats, so iteratively label background pixels
              and recompute Z-scores
    """
    img_shape = roi_img.shape
    img1 = roi_img.copy().ravel()   # 1-D version
    background_pixels = None
    while iterations > 0:
        if background_pixels is None:
            outliers = is_outlier(img1, thresh)
            inlier_vals = img1[~outliers]
            if inlier_vals.size:
                m = np.median(inlier_vals)
            else:
                m = np.nan
            if only_high:
                outliers = np.logical_and(outliers, img1 > m)
            background_pixels = ~outliers
        else:
            where_bg = np.where(background_pixels)[0]
            outliers = is_outlier(img1[background_pixels], thresh)
            inlier_vals = img1[background_pixels][~outliers]
            if inlier_vals.size:
                m = np.median(inlier_vals)
            else:
                m = np.nan
            if only_high:
                outliers = np.logical_and(outliers, img1[background_pixels] > m)
            background_pixels[where_bg[outliers]] = False
        iterations = iterations - 1

    return background_pixels.reshape(img_shape)


def is_outlier(points, thresh=3.5):
    """http://stackoverflow.com/a/22357811/2077270"""
    if len(points.shape) == 1:
        points = points[:, None]
    if points.size:
        median = np.median(points, axis=0)
    else:
        median = np.nan
    diff = np.sum((points - median) ** 2, axis=-1)
    diff = np.sqrt(diff)
    if diff.size:
        med_abs_deviation = np.median(diff)
    else:
        med_abs_deviation = np.nan
    if med_abs_deviation == 0:
        return np.zeros(points.shape[0], bool)

    modified_z_score = 0.6745 * diff / med_abs_deviation

    return modified_z_score > thresh


def get_diffBragg_instance():
    """
    Simple method to get a diffBRagg instance
    USED IN TESTING
    Returns an instance of diffBragg
    """
    from dxtbx.model.crystal import CrystalFactory
    from dxtbx.model.detector import DetectorFactory
    from dxtbx.model.beam import BeamFactory
    from simtbx.nanoBragg.tst_nanoBragg_basic import fcalc_from_pdb
    from simtbx.nanoBragg import shapetype
    from simtbx.diffBragg import diffBragg

    wavelen = 1.24
    flux = 1e15
    SHAPE = shapetype.Gauss

    NCELLS_ABC = 15  # means (15, 15, 15)

    beam_descr = {'direction': (0.0, 0.0, 1.0),
                  'divergence': 0.0,
                  'flux': 5e11,
                  'polarization_fraction': 1.,
                  'polarization_normal': (0.0, 1.0, 0.0),
                  'sigma_divergence': 0.0,
                  'transmission': 1.0,
                  'wavelength': wavelen}

    cryst_descr = {'__id__': 'crystal',
                   'real_space_a': (50, 0, 0),
                   'real_space_b': (0, 60, 0),
                   'real_space_c': (0, 0, 70),
                   'space_group_hall_symbol': '-P 4 2'}

    det_descr = {'panels':
                     [{'fast_axis': (-1.0, 0.0, 0.0),
                       'gain': 1.0,
                       'identifier': '',
                       'image_size': (196, 196),
                       'mask': [],
                       'material': '',
                       'mu': 0.0,
                       'name': 'Panel',
                       'origin': (19.6, -19.6, -550),
                       'pedestal': 0.0,
                       'pixel_size': (0.1, 0.1),
                       'px_mm_strategy': {'type': 'SimplePxMmStrategy'},
                       'raw_image_offset': (0, 0),
                       'slow_axis': (0.0, 1.0, 0.0),
                       'thickness': 0.0,
                       'trusted_range': (0.0, 65536.0),
                       'type': ''}]}

    DET = DetectorFactory.from_dict(det_descr)
    BEAM = BeamFactory.from_dict(beam_descr)
    crystal = CrystalFactory.from_dict(cryst_descr)

    Fhkl = fcalc_from_pdb(resolution=4, algorithm="fft", wavelength=wavelen)

    D = diffBragg(DET, BEAM, verbose=0)
    D.xtal_shape = SHAPE
    D.Ncells_abc = NCELLS_ABC
    D.wavelength_A = wavelen
    D.flux = flux
    D.mosaic_spread_deg = 0.01
    D.mosaic_domains = 10
    from simtbx.nanoBragg.nanoBragg_crystal import NBcrystal
    braggC = NBcrystal()
    braggC.miller_array = Fhkl
    idx = braggC.miller_array.indices()
    amps = braggC.miller_array.data()
    D.Bmatrix = crystal.get_B()
    D.Umatrix = crystal.get_U()
    D.Fhkl_tuple = idx, amps, None
    D.Bmatrix = crystal.get_B()
    D.Umatrix = crystal.get_U()
    return D


def map_hkl_list(Hi_lst, anomalous_flag=True, symbol="P43212"):
    """
    :param Hi_lst: list of miller indices, presumably in P1
    :param anomalous_flag: whether to map to anomalous ASU
    :param symbol: space group symbol
    :return: list of miller indices, mapped to HKL
    """
    sg_type = sgtbx.space_group_info(symbol=symbol).type()
    # necessary for py3 to type cast the ints
    type_casted_Hi_lst = tuple([(int(x), int(y), int(z)) for x, y, z in Hi_lst])
    Hi_flex = dials_flex.miller_index(type_casted_Hi_lst)
    miller.map_to_asu(sg_type, anomalous_flag, Hi_flex)
    return list(Hi_flex)


def compare_with_ground_truth(a, b, c, dxcryst_models, symbol="C121", verbose=False):
    """
    ported from LS49
    :param a: ground truth a (real space)
    :param b: ground truth b (real space)
    :param c: gournd truth c (real space)
    :param dxcryst_models: P1 models or whatever
    :param symbol: target space group
    :return: list of angles, one for each model
    """
    from cctbx import sgtbx
    from dxtbx.model import MosaicCrystalSauter2014
    from cctbx import crystal_orientation
    from libtbx.test_utils import approx_equal
    from scitbx.array_family import flex
    from scitbx.matrix import sqr

    sgi = sgtbx.space_group_info(symbol=symbol)
    CB_OP_C_P = sgi.change_of_basis_op_to_primitive_setting()

    icount = 0
    angles = []
    icount += 1
    for crystal_model in dxcryst_models:
        if crystal_model.get_space_group().info().type().lookup_symbol() == "P 1":
            crystal_model = crystal_model.change_basis(CB_OP_C_P.inverse())
        mosaic_model = MosaicCrystalSauter2014(crystal_model)

        direct_A = mosaic_model.get_A_inverse_as_sqr()
        sim_compatible = direct_A
        integrated_Ori = crystal_orientation.crystal_orientation(
            sim_compatible,
            crystal_orientation.basis_type.direct)

        header_Ori = crystal_orientation.crystal_orientation(
            tuple(a)+tuple(b)+tuple(c),
            crystal_orientation.basis_type.direct)

        C2_ground_truth = header_Ori.change_basis(CB_OP_C_P.inverse())
        if verbose:
            C2_ground_truth.show(legend="C2_ground_truth")

        # align integrated model with ground truth
        cb_op_align = integrated_Ori.best_similarity_transformation(C2_ground_truth, 50, 1)
        aligned_Ori = integrated_Ori.change_basis(sqr(cb_op_align))
        if verbose:
            aligned_Ori.show(legend="integrated, aligned")
            MAIN_LOGGER.debug("alignment matrix", cb_op_align)

        U_integrated = aligned_Ori.get_U_as_sqr()
        U_ground_truth = C2_ground_truth.get_U_as_sqr()
        missetting_rot = U_integrated * U_ground_truth.inverse()
        assert approx_equal(missetting_rot.determinant(), 1.0)

        # now calculate the angle as mean a_to_a,b_to_b,c_to_c
        aoff = aligned_Ori.a.angle(C2_ground_truth.a, deg=True)
        boff = aligned_Ori.b.angle(C2_ground_truth.b, deg=True)
        coff = aligned_Ori.c.angle(C2_ground_truth.c, deg=True)

        hyp = flex.mean(flex.double((aoff, boff, coff)))
        angles.append(hyp)

    return angles


def fcalc_from_pdb(resolution, algorithm=None, wavelength=0.9, anom=True, ucell=None, symbol=None, as_amplitudes=True):
    # borrowed from tst_nanoBragg_basic
    pdb_lines = """HEADER TEST
CRYST1   50.000   60.000   70.000  90.00  90.00  90.00 P 1
ATOM      1  O   HOH A   1      56.829   2.920  55.702  1.00 20.00           O
ATOM      2  O   HOH A   2      49.515  35.149  37.665  1.00 20.00           O
ATOM      3  O   HOH A   3      52.667  17.794  69.925  1.00 20.00           O
ATOM      4  O   HOH A   4      40.986  20.409  18.309  1.00 20.00           O
ATOM      5  O   HOH A   5      46.896  37.790  41.629  1.00 20.00           O
ATOM      6 SED  MSE A   6       1.000   2.000   3.000  1.00 20.00          SE
END
"""
    import iotbx.pdb
    pdb_inp = iotbx.pdb.input(source_info=None, lines=pdb_lines)
    xray_structure = pdb_inp.xray_structure_simple()
    if ucell is not None:
        assert symbol is not None
        from cctbx.xray import structure
        from cctbx import crystal
        crystal_sym = crystal.symmetry(unit_cell=ucell, space_group_symbol=symbol)
        xray_structure = structure(scatterers=xray_structure.scatterers(), crystal_symmetry=crystal_sym)
    # take a detour to insist on calculating anomalous contribution of every atom
    scatterers = xray_structure.scatterers()
    if anom:
        from cctbx.eltbx import henke
        for sc in scatterers:
            expected_henke = henke.table(sc.element_symbol()).at_angstrom(wavelength)
            sc.fp = expected_henke.fp()
            sc.fdp = expected_henke.fdp()
    # how do we do bulk solvent?
    primitive_xray_structure = xray_structure.primitive_setting()
    P1_primitive_xray_structure = primitive_xray_structure.expand_to_p1()
    fcalc = P1_primitive_xray_structure.structure_factors(
        d_min=resolution, anomalous_flag=anom, algorithm=algorithm).f_calc()
    if as_amplitudes:
        fcalc = fcalc.amplitudes().set_observation_type_xray_amplitude()
    return fcalc


def get_roi_from_spot(refls, fdim, sdim, shoebox_sz=10, centroid='obs'):
    """

    :param refls: reflection table
    :param fdim: fast axis dimension
    :param sdim: slow axis dimension
    :param shoebox_sz: size of the shoeboxes
    :param centroid: either `obs` or  `cal`. correspinds to refl column `xyzobs.px.value` or `xyzxcal.px`, respectively
    :return:
    """
    if centroid=='obs':
        fs_spot, ss_spot, _ = zip(*refls['xyzobs.px.value'])
    elif centroid=='cal':
        fs_spot, ss_spot, _ = zip(*refls['xyzcal.px'])
    else:
        raise NotImplementedError("No instruction to get centroid position from %s" % centroid)
    rois = []
    is_on_edge = []
    for i_spot, (x_com, y_com) in enumerate(zip(fs_spot, ss_spot)):
        x_com = x_com - 0.5
        y_com = y_com - 0.5
        i1 = int(max(x_com - shoebox_sz / 2., 0))
        i2 = int(min(x_com + shoebox_sz / 2., fdim-1))
        j1 = int(max(y_com - shoebox_sz / 2., 0))
        j2 = int(min(y_com + shoebox_sz / 2., sdim-1))

        if i2-i1 < shoebox_sz-1 or j2-j1 < shoebox_sz-1:
            is_on_edge.append(True)
        else:
            is_on_edge.append(False)
        roi = i1, i2, j1, j2
        rois.append(roi)
    return rois, is_on_edge


def add_rlp_column(refls, experiment):
    """
    add Relps to refl tabl
    :param refls: reflection table
    :param experiment: dxtbx experiment
    :return:
    """
    keys = list(refls[0].keys())
    if "s1" in keys:
        s1 = refls['s1']
        s1_norm = np.array(s1) / np.linalg.norm(s1,axis=1)[:,None]
        wavelen = experiment.beam.get_wavelength()
        s0 = np.array([list(experiment.beam.get_unit_s0())]*len(refls))
        q_vecs = 1/wavelen*(s1_norm-s0)
        refls['rlp'] = flex.vec3_double(tuple(map(tuple, q_vecs)))
    else:
        raise KeyError("Need rlp or s1 column in refl table!")


def get_roi_deltaQ(refls, delta_Q, experiment, centroid='obs'):
    """
    :param refls: reflection table (needs rlp column)
    :param delta_Q:  width of the ROI in inverse Angstromg (e.g. 0.05)
    :param experiment:
    :param centroid: flag, obs, cal, or bbox
    :return:
    """
    nref = len(refls)
    assert nref >0

    keys = list(refls[0].keys())
    if "rlp" not in  keys:
        add_rlp_column(refls, experiment)

    beam = experiment.beam
    detector = experiment.detector
    assert beam is not None and experiment is not None

    rois = []
    is_on_edge = []
    for i_refl in range(nref):
        roi, on_edge = determine_shoebox_ROI(detector, delta_Q, beam.get_wavelength(), refls[i_refl], centroid=centroid)
        rois.append(roi)
        is_on_edge.append( on_edge)
    return rois, is_on_edge


# TODO: pass params object directly to this method
def get_roi_background_and_selection_flags(refls, imgs, shoebox_sz=10, reject_edge_reflections=False,
                                   reject_roi_with_hotpix=True, background_mask=None, hotpix_mask=None,
                                   bg_thresh=3.5, set_negative_bg_to_zero=False,
                                   pad_for_background_estimation=None, use_robust_estimation=True, sigma_rdout=3.,
                                   min_trusted_pix_per_roi=4, deltaQ=None, experiment=None, weighted_fit=True,
                                   ret_cov=False, allow_overlaps=False, skip_roi_with_negative_bg=True,
                                   only_high=True, centroid='obs'):
    """

    :param refls: reflection table
    :param imgs: ndimage array, same shape as detector
    :param shoebox_sz:  size of shoeboxes, deltaQ (see below) overrides this
    :param reject_edge_reflections: reject the refl if its centroid is close to the edge
    :param reject_roi_with_hotpix: reject the refl if ROI contains a hot pixel
    :param background_mask: mask specifying which pixels are most likely background (e.g. strong spot pixels should be False)
    :param hotpix_mask: mask labeling hot pixels as True
    :param bg_thresh: median absolute deviation threshold for background selection (e.g. ROI pixels with MAD above this value are treated as hot or strong)
    :param set_negative_bg_to_zero: after fitting background plane, force negative background signals to be 0
    :param pad_for_background_estimation: expand the ROI for the purposes of background fitting, once background is fit, remove expanded pixels
    :param use_robust_estimation: let ROI median value be the background
    :param sigma_rdout: readout noise of the pixel (in ADU)
    :param min_trusted_pix_per_roi: require at least this many trusted pixels in the ROI, otherwise flag refl as unselected
    :param deltaQ: specify the width of the ROI in inverse angstrom (overrides shoebox_sz), such that higher Q ROIS are larger
    :param experiment: dxtbx experiment
    :param weighted_fit: fit a tilt plane with basis error models as weights
    :param ret_cov: return the tilt plane covariance
    :param allow_overlaps: allow overlapping ROIS, otherwise shrink ROIS until the no longer overlap
    :param skip_roi_with_negative_bg: if an ROI has negative signal, dont include it in refinement
    :param only_high: only filter zingers that are above the mean (default is True)
    :param centroid: obs or cal (get centroids from refl column xyzobs.px.value or xyzcal.px)
    :return:
    """


    # TODO handle divide by 0 warning that happens in is_outlier, when labeling background pix?
    npan, sdim, fdim = imgs.shape

    if hotpix_mask is not None:
        assert hotpix_mask.shape == imgs.shape

    if background_mask is not None:
        assert background_mask.shape == imgs.shape

    if deltaQ is None:  # then use fixed size ROIS determined by shoebox_sz
        rois, is_on_edge = get_roi_from_spot(refls, fdim, sdim, shoebox_sz=shoebox_sz, centroid=centroid)
    else:
        assert experiment is not None
        if len(refls) == 0:
            return
        rois, is_on_edge = get_roi_deltaQ(refls, deltaQ, experiment, centroid=centroid)

    tilt_abc = []
    kept_rois = []
    panel_ids = []
    all_cov =[]
    selection_flags = []
    num_roi_negative_bg = 0
    num_roi_nan_bg = 0
    background = np.full_like(imgs, -1, dtype=float)
    i_roi = 0
    while i_roi < len(rois):
        roi = rois[i_roi]
        i1, i2, j1, j2 = roi
        is_selected = True
        refl_bbox_str = "Reflection %d bounded by x1=%d,x2=%d,y1=%d,y2=%d" % (i_roi, i1,i2,j1,j2)
        if is_on_edge[i_roi] and reject_edge_reflections:
            MAIN_LOGGER.debug("Reflection %d is on edge" % i_roi)
            is_selected = False
        pid = refls[i_roi]['panel']

        if hotpix_mask is not None:
            is_hotpix = hotpix_mask[pid, j1:j2, i1:i2]
            num_hotpix = is_hotpix.sum()
            if num_hotpix > 0 and reject_roi_with_hotpix:
                MAIN_LOGGER.debug("reflection %d has hot pixel" % i_roi)
                is_selected = False
            if num_hotpix > min_trusted_pix_per_roi:
                MAIN_LOGGER.debug("reflection %d has too many (%d) hot pixels (%d allowed)!" % (i_roi, num_hotpix, min_trusted_pix_per_roi))
                is_selected = False

        # Before padding and fitting, test for overlaps and shrink if needed
        is_overlapping = not np.all(background[pid, j1:j2, i1:i2] == -1)
        if not allow_overlaps and is_overlapping:
            MAIN_LOGGER.debug("region of interest already accounted for roi size= %d %d" % (i2-i1, j2-j1))
            rois[i_roi] = (i1 + 1, i2, j1 + 1, j2) if (i1 + i2) % 2 \
                else (i1, i2 - 1, j1, j2 - 1)  # shrink alternately from corners
            continue

        dimY, dimX = imgs[pid].shape
        j1_nopad = j1
        i1_nopad = i1
        j2_nopad = j2
        i2_nopad = i2
        if pad_for_background_estimation is not None:
            j1 = max(0, j1-pad_for_background_estimation)
            i1 = max(0, i1-pad_for_background_estimation)
            j2 = min(dimY, j2+pad_for_background_estimation)
            i2 = min(dimX, i2+pad_for_background_estimation)

        shoebox = imgs[pid, j1:j2, i1:i2]

        if shoebox.size < 4:
            MAIN_LOGGER.debug("reflection %d has negative background" % i_roi)
            is_selected = False

        if not isinstance(sigma_rdout, float) and not isinstance(sigma_rdout, int):
            shoebox_sigma_readout = sigma_rdout[pid, j1:j2, i1:i2]
        else:
            shoebox_sigma_readout = sigma_rdout

        if background_mask is not None:
            is_background = background_mask[pid, j1:j2, i1:i2]
        else:
            if shoebox.shape== (0,0):
                is_background = shoebox.copy().astype(bool)
            else:
                is_background = label_background_pixels(shoebox,thresh=bg_thresh, iterations=2, only_high=only_high)

        Ycoords, Xcoords = np.indices((j2-j1, i2-i1))

        if use_robust_estimation:
            bg_pixels = shoebox[is_background]
            if not bg_pixels.size:
                bg_signal = np.nan
            else:
                bg_signal = np.median(bg_pixels)
            if bg_signal < 0:
                num_roi_negative_bg += 1
                if set_negative_bg_to_zero:
                    bg_signal = 0
                elif skip_roi_with_negative_bg:
                    MAIN_LOGGER.debug("reflection %d has negative background" % i_roi)
                    is_selected = False
                elif np.isnan(bg_signal):
                    is_selected = False
            tilt_a, tilt_b, tilt_c = 0, 0, bg_signal
            covariance = None

            tilt_plane = tilt_a * Xcoords + tilt_b * Ycoords + tilt_c
        else:
            fit_results = fit_plane_equation_to_background_pixels(
                shoebox_img=shoebox, fit_sel=is_background, sigma_rdout=shoebox_sigma_readout,
                weighted=weighted_fit)
            if fit_results is None:
                tilt_a = tilt_b = tilt_c = covariance = 0
                MAIN_LOGGER.debug("Reflection %d has no fit!" % i_roi)
                is_selected = False
                MAIN_LOGGER.debug("tilt fit failed for reflection %d, probably too few pixels" % i_roi)
                tilt_plane = np.zeros_like(Xcoords)
            else:
                #MAIN_LOGGER.debug("successfully fit tilt plane")
                (tilt_a, tilt_b, tilt_c), covariance = fit_results
                tilt_plane = tilt_a * Xcoords + tilt_b * Ycoords + tilt_c
                if np.any(np.isnan(tilt_plane)) and is_selected:
                    MAIN_LOGGER.debug("reflection %d has nan in plane" % i_roi)
                    is_selected = False
                    num_roi_nan_bg += 1
                if skip_roi_with_negative_bg and np.min(tilt_plane) < 0:  # dips below
                    num_roi_negative_bg += 1
                    MAIN_LOGGER.debug("reflection %d has tilt plane that dips below 0" % i_roi)
                    is_selected = False

        # unpadded ROI dimension
        roi_dimY = j2_nopad-j1_nopad
        roi_dimX = i2_nopad-i1_nopad

        if roi_dimY < 2 or roi_dimX < 2:
            MAIN_LOGGER.debug("reflection %d is too small" % (i_roi))
            is_selected = False

        j1 = j1_nopad-j1
        i1 = i1_nopad-i1
        plane_in_unpadded_roi = tilt_plane[j1: j1 + roi_dimY, i1: i1 + roi_dimX]
        background[pid, j1_nopad:j2_nopad, i1_nopad:i2_nopad] = plane_in_unpadded_roi
        tilt_abc.append((tilt_a, tilt_b, tilt_c))
        all_cov.append(covariance)
        kept_rois.append(roi)
        panel_ids.append(pid)
        selection_flags.append(is_selected)
        if not is_selected:
            MAIN_LOGGER.debug("--> %s was not selected for above reasons" % refl_bbox_str)
        i_roi += 1

    MAIN_LOGGER.debug("Number of skipped ROI with negative BGs: %d / %d" % (num_roi_negative_bg, len(rois)))
    MAIN_LOGGER.debug("Number of skipped ROI with NAN in BGs: %d / %d" % (num_roi_nan_bg, len(rois)))
    MAIN_LOGGER.info("Number of ROIS that will proceed to refinement: %d/%d" % (np.sum(selection_flags), len(rois)))
    if ret_cov:
        return kept_rois, panel_ids, tilt_abc, selection_flags, background, all_cov
    else:
        return kept_rois, panel_ids, tilt_abc, selection_flags, background


def determine_shoebox_ROI(detector, delta_Q, wavelength_A, refl, centroid="obs"):
    panel = detector[refl["panel"]]
    width = get_width_of_integration_shoebox(panel, delta_Q, wavelength_A, refl['rlp'])
    wby2 = int(round(width/2.))
    fdim,sdim = panel.get_image_size()
    if centroid=='obs':  #TODO: give this more options
        i_com, j_com,_ = refl['xyzobs.px.value']
    elif centroid=='cal':
        i_com, j_com,_ = refl['xyzcal.px']
    else:
        i1,i2,j1,j2,_,_ = refl['bbox']  # super weird funky spots can skew bbox such that its a bad measure of centroid
        i_com = (i1+i2) * .5
        j_com = (j1+j2) * .5
    i1, i2, j1, j2 = i_com - wby2, i_com + wby2, j_com - wby2, j_com + wby2
    on_edge = False
    if i1 < 0 or j1 < 0:
        on_edge = True
    elif i2 >= fdim  or j2 >= sdim:
        on_edge = True
    i1 = max(int(i1), 0)
    i2 = min(int(i2), fdim)
    j1 = max(int(j1), 0)
    j2 = min(int(j2), sdim)
    return (i1, i2, j1, j2), on_edge


def get_width_of_integration_shoebox(detector_panel, delta_Q, ave_wavelength_A,  rlp):
    Qmag = 2 * np.pi * np.linalg.norm(rlp)  # magnitude momentum transfer of the RLP in physicist convention
    detdist_mm = detector_panel.get_distance()
    pixsize_mm = detector_panel.get_pixel_size()[0]
    rad1 = (detdist_mm / pixsize_mm) * np.tan(2 * np.arcsin((Qmag - delta_Q * .5) * ave_wavelength_A / 4 / np.pi))
    rad2 = (detdist_mm / pixsize_mm) * np.tan(2 * np.arcsin((Qmag + delta_Q * .5) * ave_wavelength_A / 4 / np.pi))
    bbox_extent = (rad2 - rad1) / np.sqrt(2)  # rad2 - rad1 is the diagonal across the bbox
    return bbox_extent


def fit_plane_equation_to_background_pixels(shoebox_img, fit_sel, sigma_rdout=3, weighted=True, relative_XY=None):
    """
    :param shoebox_img: 2D pixel image (usually less than 100x100 pixels)
    :param fit_sel: pixels to be fit to plane (usually background pixels)
    :param sigma_rdout: float or 2D image , readout noise term ( in shoebox_img pixel units)
    :return: coefficients of tilt plane (fast-scan, slow-scan, offset), as well as a covariance estimate matrix
    """
    # fast scan pixels, slow scan pixels, pixel values (corrected for gain)
    Y, X = np.indices(shoebox_img.shape)
    if relative_XY is not None:
        X += relative_XY[0]
        Y += relative_XY[1]
    fast, slow, rho_bg = X[fit_sel], Y[fit_sel], shoebox_img[fit_sel]


    try:
        sigma_rdout = sigma_rdout[fit_sel]
    except TypeError:
        pass

    # do the fit of the background plane
    A = np.array([fast, slow, np.ones_like(fast)]).T
    # weights matrix:
    if weighted:
        W = np.diag(1 / (sigma_rdout ** 2 + rho_bg))
        W[W <0] = 0
        W = np.sqrt(W)
    else:
        W = np.eye(len(rho_bg))
    AWA = np.dot(A.T, np.dot(W, A))
    try:
        AWA_inv = np.linalg.inv(AWA)
    except np.linalg.LinAlgError:
        MAIN_LOGGER.debug("WARNING: Fit did not work.. investigate reflection, number of pixels used in fit=%d" % len(fast))
        return None
    AtW = np.dot(A.T, W)
    t1, t2, t3 = np.dot(np.dot(AWA_inv, AtW), rho_bg)

    # get the covariance of the tilt coefficients:
    # vector of residuals
    r = rho_bg - np.dot(A, (t1, t2, t3))
    Nbg = len(rho_bg)
    with np.errstate(divide='ignore', invalid='ignore'):
        r_fact = np.dot(r.T, np.dot(W, r)) / (Nbg - 3)  # 3 parameters fit
    var_covar = AWA_inv * r_fact  # TODO: check for correlations in the off diagonal elems

    return (t1, t2, t3), var_covar


def strip_thickness_from_detector(detector):
    """return a new dxtbx detector with 0 thickness"""
    return set_detector_thickness(detector,0,0)


def set_detector_thickness(detector, thick=0, mu=0):
    """
    warning: this overrides detector hierarchy

    :param detector: dxtbx detector model
    :param thick: sensor thickness in mm
    :param mu: sensor absorption length in mm
    :return: new dxtbx detector model
    """
    px_type = "SimplePxMmStrategy"
    if thick > 0:
        px_type = "ParallaxCorrectedPxMmStrategy"

    new_detector = Detector()
    for i_pan in range(len(detector)):
        panel = detector[i_pan]
        panel_dict = panel.to_dict()
        # NOTE: necessary to set origin and fast/slow because panel.to_dict doesnt care about hierarchy
        panel_dict["origin"] = panel.get_origin()
        panel_dict["fast_axis"] = panel.get_fast_axis()
        panel_dict["slow_axis"] = panel.get_slow_axis()
        panel_dict["mu"] = mu
        panel_dict["thickness"] = thick
        panel_dict["px_mm_strategy"] = {'type': px_type}
        new_panel = Panel.from_dict(panel_dict)
        new_detector.add_panel(new_panel)
    return new_detector


def image_data_from_expt(expt, as_double=True):
    """

    :param expt: dxtbx experiment
    :param as_double: return data as doubles
    :return:
    """
    iset = expt.imageset
    if len(iset) == 0:
        raise ValueError("imageset should have 1 shot")
    if len(iset) > 1:
        raise ValueError("imageset should have only 1 shot. This expt has imageset with %d shots" % len(iset))
    try:
        flex_data = iset.get_raw_data(0)

    except Exception as err:
        assert str(type(err)) == "<class 'Boost.Python.ArgumentError'>", "something weird going on with imageset data"
        flex_data = iset.get_raw_data()
    if not isinstance(flex_data, tuple):
        flex_data = (flex_data, )
    img_data = np.array([data.as_numpy_array() for data in flex_data])
    if as_double:
        img_data = img_data.astype(np.float64)
    return img_data


def simulator_from_expt(expt, oversample=0, device_id=0, init_scale=1, total_flux=1e12,
                        ncells_abc=(10,10,10), has_isotropic_ncells=True, mosaicity=0,
                        num_mosaicity_samples=1, mtz_name=None,
                        mtz_column=None, default_F=0, dmin=1.5, dmax=30,
                        spectra_file=None, spectra_stride=1,
                        complex_F=None):
    raise NotImplementedError("This will be a convenience method")
    # params = get_params_object()
    # params.simulator.oversample = oversample
    # etc
    #return simulator_from_expt_and_params(expt, params)


def simulator_for_refinement(expt, params):
    # TODO: choose a phil param and remove support for the other: crystal.anositropic_mosaicity, or init.eta_abc
    MAIN_LOGGER.info(
        "Setting initial mosaicity from params.init.eta_abc: %f %f %f" % tuple(params.init.eta_abc))
    if params.simulator.crystal.has_isotropic_mosaicity:
        params.simulator.crystal.anisotropic_mosaicity = None
        params.simulator.crystal.mosaicity = params.init.eta_abc[0]
    else:
        params.simulator.crystal.anisotropic_mosaicity = params.init.eta_abc
    MAIN_LOGGER.info("Number of mosaic domains from params: %d" % params.simulator.crystal.num_mosaicity_samples)

    #  GET SIMULATOR #
    SIM = simulator_from_expt_and_params(expt, params)

    if SIM.D.mosaic_domains > 1:
        MAIN_LOGGER.info("Will use mosaic models: %d domains" % SIM.D.mosaic_domains)
    else:
        MAIN_LOGGER.info("Will not use mosaic models, as simulator.crystal.num_mosaicity_samples=1")

    if not params.fix.eta_abc:
        assert SIM.D.mosaic_domains > 1

    if not params.fix.diffuse_gamma or not params.fix.diffuse_sigma:
        assert params.use_diffuse_models
    SIM.D.use_diffuse = params.use_diffuse_models
    SIM.D.gamma_miller_units = params.gamma_miller_units
    SIM.isotropic_diffuse_gamma = params.isotropic.diffuse_gamma
    SIM.isotropic_diffuse_sigma = params.isotropic.diffuse_sigma

    SIM.D.no_Nabc_scale = params.no_Nabc_scale  # TODO check gradients for this setting
    SIM.D.update_oversample_during_refinement = False

    return SIM


def simulator_from_expt_and_params(expt, params=None):
    """
    :param expt:  dxtbx experiment
    :param params: diffBragg/phil.py phil params
    :return:
    """

    oversample = params.simulator.oversample
    device_id = params.simulator.device_id
    init_scale = params.simulator.init_scale
    total_flux = params.simulator.total_flux

    ncells_abc = params.simulator.crystal.ncells_abc
    ncells_def = params.simulator.crystal.ncells_def
    has_isotropic_ncells = params.simulator.crystal.has_isotropic_ncells
    mosaicity = params.simulator.crystal.mosaicity
    num_mosaicity_samples = params.simulator.crystal.num_mosaicity_samples

    default_F = params.simulator.structure_factors.default_F

    spectra_file = params.simulator.spectrum.filename
    spectra_stride = params.simulator.spectrum.stride
    aniso_mos_spread = params.simulator.crystal.anisotropic_mosaicity

    if has_isotropic_ncells:
        if len(set(ncells_abc)) != 1 :
            raise ValueError("`isotropic_ncells=True`, so `ncells_abc` should all be the same, not %d %d %d" % tuple(ncells_abc))

    # make a simulator instance
    SIM = SimData()
    if params.simulator.detector.force_zero_thickness:
        SIM.detector = strip_thickness_from_detector(expt.detector)
    else:
        atten = params.simulator.detector.atten
        thick = params.simulator.detector.thick
        if atten is not None and thick is not None:
            expt.detector = set_detector_thickness(expt.detector, thick, 1./atten)
        SIM.detector = expt.detector

    # create nanoBragg crystal
    crystal = NBcrystal(init_defaults=False)
    crystal.isotropic_ncells = has_isotropic_ncells
    if params.simulator.crystal.rotXYZ_ucell is not None:
        rotXYZ = params.simulator.crystal.rotXYZ_ucell[:3]
        ucell_p = params.simulator.crystal.rotXYZ_ucell[3:]
        crystal.dxtbx_crystal = modify_crystal(rotXYZ, ucell_p, expt.crystal)
    else:
        crystal.dxtbx_crystal = expt.crystal
    crystal.thick_mm = 0.1  # hard code a thickness, will be over-written by the scale
    # mosaic block size
    crystal.Ncells_abc = tuple(ncells_abc)
    if ncells_def is not None:
        crystal.Ncells_def = tuple(ncells_def)
    crystal.anisotropic_mos_spread_deg = aniso_mos_spread
    crystal.n_mos_domains = num_mosaicity_samples
    crystal.mos_spread_deg = mosaicity

    # load the structure factors
    miller_data = load_Fhkl_model_from_params_and_expt(params, expt)
    crystal.miller_array = miller_data
    if params.refiner.force_symbol is not None:
        crystal.symbol = params.refiner.force_symbol
    else:
        crystal.symbol = miller_data.crystal_symmetry().space_group_info().type().lookup_symbol()
    SIM.crystal = crystal

    # create a nanoBragg beam
    beam = NBbeam()
    beam.size_mm = params.simulator.beam.size_mm
    beam.unit_s0 = expt.beam.get_unit_s0()
    if spectra_file is not None:
        init_spectrum = load_spectra_file(spectra_file, total_flux, spectra_stride, as_spectrum=True)
    else:
        assert total_flux is not None
        init_spectrum = [(expt.beam.get_wavelength(), total_flux)]
    beam.spectrum = init_spectrum
    SIM.beam = beam

    # create the diffbragg object, which is the D attribute of SIM
    SIM.panel_id = 0
    SIM.instantiate_diffBragg(oversample=oversample, device_Id=device_id, default_F=default_F, verbose=params.refiner.verbose)
    if init_scale is not None:
        #TODO phase this parameter out since its redundant?
        SIM.update_nanoBragg_instance("spot_scale", init_scale)

    test_panel = SIM.detector[0]
    if test_panel.get_thickness() > 0:
        SIM.update_nanoBragg_instance(
            "detector_thicksteps", params.simulator.detector.thicksteps)
    MAIN_LOGGER.debug("Detector thicksteps = %d" % SIM.D.detector_thicksteps )
    MAIN_LOGGER.debug("Detector thick = %f mm" % SIM.D.detector_thick_mm )
    MAIN_LOGGER.debug("Detector atten len = %f mm" % SIM.D.detector_attenuation_length_mm )
    if params.simulator.psf.use:
        SIM.use_psf = True
        SIM.psf_args = {'pixel_size': SIM.detector[0].get_pixel_size()[0]*1e3,
                'fwhm': params.simulator.psf.fwhm,
                'psf_radius': params.simulator.psf.radius}
        fwhm_pix = SIM.psf_args["fwhm"] / SIM.psf_args["pixel_size"]
        kern_size = SIM.psf_args["psf_radius"]*2 + 1
        SIM.PSF = psf.makeMoffat_integPSF(fwhm_pix, kern_size, kern_size)

    update_SIM_with_gonio(SIM, params)

    return SIM


def update_SIM_with_gonio(SIM, params=None, delta_phi=None, num_phi_steps=5):
    """

    :param SIM: sim_data instance
    :param params: diffBragg phil parameters instance
    :param delta_phi: how much to rotate gonio during model
    :param num_phi_steps: number of phi steps
    :return:
    """
    if not hasattr(SIM, "D"):
        raise AttributeError("Need to instantiate diffBragg first")
    if params is not None:
        delta_phi = params.simulator.gonio.delta_phi
        num_phi_steps = params.simulator.gonio.phi_steps

    if delta_phi is not None:
        SIM.D.phi_deg = 0
        SIM.D.osc_deg = delta_phi
        SIM.D.phisteps = num_phi_steps


def get_complex_fcalc_from_pdb(
        pdb_file,
        wavelength=None,
        dmin=1,
        dmax=None,
        k_sol=0.435, b_sol=46, show_pdb_summary=False):
    """
    produce a structure factor from PDB coords, see mmtbx/programs/fmodel.py for formulation
    k_sol, b_sol form the solvent component of the Fcalc: Fprotein + k_sol*exp(-b_sol*s^2/4) (I think)
    """
    import iotbx.pdb
    pdb_in = iotbx.pdb.input(pdb_file)
    xray_structure = pdb_in.xray_structure_simple()
    if show_pdb_summary:
        xray_structure.show_summary()
    for sc in xray_structure.scatterers():
        if wavelength is not None:
            expected_henke = henke.table(sc.element_symbol()).at_angstrom(wavelength)
            sc.fp = expected_henke.fp()
            sc.fdp = expected_henke.fdp()
    phil2 = mmtbx.programs.fmodel.master_phil
    params2 = phil2.extract()
    params2.high_resolution = dmin
    params2.low_resolution = dmax
    params2.fmodel.k_sol = k_sol
    params2.fmodel.b_sol = b_sol
    params2.structure_factors_accuracy.algorithm = 'fft'
    f_model = mmtbx.utils.fmodel_from_xray_structure(
        xray_structure=xray_structure,
        f_obs=None,
        add_sigmas=False,
        params=params2).f_model
    f_model = f_model.generate_bijvoet_mates()

    return f_model


def open_mtz(mtzfname, mtzlabel=None, verbose=False):
    """

    :param mtzfname: path to mtz
    :param mtzlabel: column in mtz
    :param verbose:
    :return:
    """
    if mtzlabel is None:
        mtzlabel = "fobs(+)fobs(-)"
    if verbose:
        MAIN_LOGGER.info("Opening mtz file %s , label %s" % (mtzfname, mtzlabel))
    from iotbx.reflection_file_reader import any_reflection_file
    miller_arrays = any_reflection_file(mtzfname).as_miller_arrays()

    possible_labels = []
    foundlabel = False
    for ma in miller_arrays:
        label = ma.info().label_string()
        possible_labels.append(label)
        if label == mtzlabel:
            foundlabel = True
            break

    assert foundlabel, "MTZ Label not found... \npossible choices: %s" % (" ".join(possible_labels))
    if not ma.is_xray_amplitude_array():
        ma = ma.as_amplitude_array()
    return ma


def make_miller_array(symbol, unit_cell, defaultF=1000, d_min=1.5, d_max=999):
    """

    :param symbol: space group e.g. P43212
    :param unit_cell: unit cell tuple (6-tuple, a,b,c,alpha,beta,gamma)
    :param defaultF: structure factor amplitude (constant for all HKL)
    :param d_min: high res
    :param d_max: low res
    :return:  cctbx miller array
    """
    sgi = sgtbx.space_group_info(symbol)
    # TODO: allow override of ucell
    symm = symmetry(unit_cell=unit_cell, space_group_info=sgi)
    miller_set = symm.build_miller_set(anomalous_flag=True, d_min=d_min, d_max=d_max)
    # NOTE does build_miller_set automatically expand to p1 ? Does it obey systematic absences ?
    # Note how to handle sys absences here ?
    Famp = flex.double(np.ones(len(miller_set.indices())) * defaultF)
    mil_ar = miller.array(miller_set=miller_set, data=Famp).set_observation_type_xray_amplitude()
    return mil_ar


def make_miller_array_from_crystal(Crystal, dmin, dmax, defaultF=1000, symbol=None):
    if symbol is None:
        symbol = Crystal.get_space_group().info().type().lookup_symbol()
    Famp = make_miller_array(
        symbol=symbol,
        unit_cell=Crystal.get_unit_cell(), d_min=dmin, d_max=dmax, defaultF=defaultF)
    return Famp


def save_spectra_file(spec_file, wavelengths, weights):
    """
    Create a precognition .lam file
    :param spec_file: name
    :param wavelengths: list of wavelen
    :param weights: list of weights
    """
    data = np.array([wavelengths, weights])
    np.savetxt(spec_file, data.T, delimiter=',', header="wavelengths, weights")


def load_spectra_file(spec_file, total_flux=None, pinkstride=1, as_spectrum=False, delim=","):
    """
    load a precognition .lam file
    :param spec_file: path to file
    :param total_flux: total photons per shot
    :param pinkstride: wavelength stride (e.g. pinkstride=10 is every 10th wavelength)
    :param as_spectrum: as a nanoBragg_beam.NBbeam.spectrum object
    :param delim: column delimiter
    """
    wavelengths, weights = np.loadtxt(spec_file, float, delimiter=delim, skiprows=1).T
    if isinstance(wavelengths, float) and isinstance(weights, float):
        # the file had one entry:
        wavelengths = np.array([wavelengths])
        weights = np.array([weights])
    if pinkstride > len(wavelengths) or pinkstride == 0:
        raise ValueError("Incorrect value for pinkstride")
    wavelengths = wavelengths[::pinkstride]
    weights = weights[::pinkstride]
    energies = ENERGY_CONV/wavelengths
    if total_flux is not None:
        weights = weights / weights.sum() * total_flux
    if as_spectrum:
        return list(zip(list(wavelengths), list(weights)))
    else:
        return weights, energies


def save_numpy_mask_as_flex(numpymask, outfile):
    flexmask = tuple((dials_flex.bool(m) for m in numpymask))
    with open(outfile, "wb") as f:
        pickle.dump(flexmask, f)

def load_mask(maskfile):
    """

    :param maskfile: path to a dials mask file (tuple of flex)
    :return:
    """
    if maskfile is None:
        return None
    with open(maskfile, 'rb') as o:
        mask = pickle.load(o)
    if isinstance(mask, tuple):
        mask = np.array([m.as_numpy_array() for m in mask])
    else:
        mask = mask.as_numpy_array()
    return mask


def unitcell_sigmas(unitcell_manager, unitcell_sigmas):
    """

    :param unitcell_manager: unit cell manager (see diffBragg/refiners/crystal_systems
    :param unitcell_sigmas: refinement sensitivities
    :return:
    """
    name_mapping = {'a_Ang': 0, 'b_Ang': 1, 'c_Ang': 2, 'alpha_rad': 3, 'beta_rad': 4, 'gamma_rad': 5}
    variable_sigmas = []
    for name in unitcell_manager.variable_names:
        sig = unitcell_sigmas[name_mapping[name]]
        variable_sigmas.append(sig)
    return variable_sigmas


def manager_from_crystal(crystal):
    """
    :param crystal:  dxtbx crystal model
    :return:
    """
    params = crystal.get_unit_cell().parameters()
    return manager_from_params(params)


def manager_from_params(ucell_p):
    """
    :param ucell_p: unit cell 6-tuple
    :return: unit cell manager (crystal systems)
    """

    a, b, c, al, be, ga = ucell_p
    if np.isclose(a,b) and not np.isclose(a,c) and np.allclose([al, be, ga], [90]*3):
        manager = TetragonalManager(a=a, c=c)

    elif not np.isclose(a,b) and not np.isclose(b,c) and not np.isclose(a,c) and np.allclose([al, be, ga], [90]*3):
        manager = OrthorhombicManager(a=a, b=b, c=c)

    elif np.isclose(a,b) and not np.isclose(a,c) and np.allclose([al, be], [90]*2) and np.allclose([ga], [120]):
        manager = HexagonalManager(a=a, c=c)

    elif not np.isclose(a,b) and not np.isclose(b,c) and not np.isclose(a,c) and np.allclose([al, ga], [90]*2) and not np.allclose([be], [120]):
        manager = MonoclinicManager(a=a, b=b, c=c, beta=be*np.pi/180.)

    else:
        raise NotImplementedError("Not yet implemented for crystal model")

    return manager


def detect_peaks(image_, threshold=0):
    """
    Detector of peaks in a 2d array
    Borrowed recipe: https://stackoverflow.com/a/3689710/2077270
    :param image: 2d img
    :param threshold: float, cutoff, pixels below this are assumed to background (e.g. not peaks)
    :returns: a binary image thats 1 at the potision of the peaks
    """
    image = image_.copy()
    image[image < threshold] = 0
    neighborhood = generate_binary_structure(2,2)
    local_max = maximum_filter(image, footprint=neighborhood)==image
    background = (image == 0)

    eroded_background = binary_erosion(background, structure=neighborhood, border_value=1)

    detected_peaks = local_max ^ eroded_background

    return detected_peaks


def refls_from_sims(panel_imgs, detector, beam, thresh=0, filter=None, panel_ids=None,
                    max_spot_size=1000, use_detect_peaks=False, **kwargs):
    """
    This is for converting the centroids in the noiseless simtbx images
    to a multi panel reflection table

    :param panel_imgs: list or 3D array of detector panel simulations
    :param detector: dxtbx  detector model of a caspad
    :param beam:  dxtxb beam model
    :param thresh: threshol intensity for labeling centroids
    :param filter: optional filter to apply to images before
        labeling threshold, typically one of scipy.ndimage's filters
    :param pids: panel IDS , else assumes panel_imgs is same length as detector
    :param max_spot_size: maximum number of px in a spot
    :param use_detect_peaks: precisely compute the peak of each simulated spot
        and throw away the profile
    :param kwargs: kwargs to pass along to the optional filter
    :return: a reflection table of spot centroids
    """
    from dials.algorithms.spot_finding.factory import FilterRunner
    from dials.model.data import PixelListLabeller, PixelList
    from dials.algorithms.spot_finding.finder import pixel_list_to_reflection_table

    if panel_ids is None:
        panel_ids = np.arange(len(detector))
    pxlst_labs = []
    for i, pid in enumerate(panel_ids):
        plab = PixelListLabeller()
        img = panel_imgs[i]
        if use_detect_peaks:
            mask = detect_peaks(img, thresh)
        elif filter is not None:
            mask = filter(img, **kwargs) > thresh
        else:
            mask = img > thresh
        img_sz = detector[int(pid)].get_image_size()  # for some reason the int cast is necessary in Py3
        flex_img = flex.double(img)
        flex_img.reshape(flex.grid(img_sz))

        flex_mask = flex.bool(mask)
        flex_mask.resize(flex.grid(img_sz))
        pl = PixelList(0, flex.double(img), flex.bool(mask))
        plab.add(pl)

        pxlst_labs.append(plab)

    El = explist_from_numpyarrays(panel_imgs, detector, beam)
    iset = El.imagesets()[0]
    refls = pixel_list_to_reflection_table(
        iset, pxlst_labs,
        min_spot_size=1,
        max_spot_size=max_spot_size,  # TODO: change this ?
        filter_spots=FilterRunner(),  # must use a dummie filter runner!
        write_hot_pixel_mask=False)[0]

    return refls


class FormatInMemory:
    """
    this class is a special image type
    necessary to create dxtbx imagesets and
    datablocks from numpy array images
    and masks.
    """
    def __init__(self, image, mask=None):
        self.image = image
        if image.dtype != np.float64:
            self.image = self.image.astype(np.float64)
        if mask is None:
            self.mask = np.ones_like(self.image).astype(bool)
        else:
            assert (mask.shape == image.shape)
            assert(mask.dtype == bool)
            self.mask = mask

    def get_raw_data(self):
        if len(self.image.shape)==2:
            return flex.double(self.image)
        else:
            return tuple([flex.double(panel) for panel in self.image])

    def get_mask(self, goniometer=None):
        if len(self.image.shape)==2:
            return flex.bool(self.mask)
        else:
            return tuple([flex.bool(panelmask) for panelmask in self.mask])


def explist_from_numpyarrays(image, detector, beam, mask=None):
    """
    So that one can do e.g.
    >> dblock = datablock_from_numpyarrays( image, detector, beam)
    >> refl = flex.reflection_table.from_observations(dblock, spot_finder_params)
    without having to utilize the harddisk

    :param image:  numpy array image, or list of numpy arrays
    :param mask:  numpy mask, should be same shape format as numpy array
    :param detector: dxtbx detector model
    :param beam: dxtbx beam model
    :return: datablock for the image
    """
    if isinstance( image, list):
        image = np.array( image)
    if mask is not None:
        if isinstance( mask, list):
            mask = np.array(mask).astype(bool)
    I = FormatInMemory(image=image, mask=mask)
    reader = MemReader([I])
    iset_Data = ImageSetData(reader, None) # , masker)
    iset = ImageSet(iset_Data)
    iset.set_beam(beam)
    iset.set_detector(detector)
    explist = ExperimentListFactory.from_imageset_and_crystal(iset, None)
    return explist


def load_panel_group_file(panel_group_file):
    """

    :param panel_group_file: file specifying which group IDs for multi panel detectors
    :return:
    """
    lines = open(panel_group_file, 'r').readlines()
    groups = {}
    for l in lines:
        try:
            panel, group = map(int, l.strip().split())
        except ValueError:
            continue
        groups[panel] = group
    return groups


def load_spectra_from_dataframe(df):
    """
    :param df:pandas dataframe
    :return:
    """
    total_flux = df.total_flux.values[0]
    spectrum_file = df.spectrum_filename.values[0]
    pink_stride = df.spectrum_stride.values[0]
    spec = load_spectra_file(spectrum_file, total_flux=total_flux,
                            pinkstride=pink_stride, as_spectrum=True)
    return spec


def refls_to_q(refls, detector, beam, update_table=False):
    """
    gets the Q-vector at each refl
    :param refls: reflection table
    :param detector: detector
    :param beam: beam
    :param update_table: update the table with rlp col
    :return:
    """

    orig_vecs = {}
    fs_vecs = {}
    ss_vecs = {}
    u_pids = set(refls['panel'])
    for pid in u_pids:
        orig_vecs[pid] = np.array(detector[pid].get_origin())
        fs_vecs[pid] = np.array(detector[pid].get_fast_axis())
        ss_vecs[pid] = np.array(detector[pid].get_slow_axis())

    s1_vecs = []
    q_vecs = []
    panels = refls["panel"]
    n_refls = len(refls)
    for i_r in range(n_refls):
        r = refls[i_r]
        pid = r['panel']
        i_fs, i_ss, _ = r['xyzobs.px.value']
        panel = detector[pid]
        orig = orig_vecs[pid] #panel.get_origin()
        fs = fs_vecs[pid] #panel.get_fast_axis()
        ss = ss_vecs[pid] #panel.get_slow_axis()

        fs_pixsize, ss_pixsize = panel.get_pixel_size()
        s1 = orig + i_fs*fs*fs_pixsize + i_ss*ss*ss_pixsize  # scattering vector
        s1 = s1 / np.linalg.norm(s1) / beam.get_wavelength()
        s1_vecs.append(s1)
        q_vecs.append(s1-beam.get_s0())

    if update_table:
        refls['s1'] = flex.vec3_double(tuple(map(tuple, s1_vecs)))
        refls['rlp'] = flex.vec3_double(tuple(map(tuple, q_vecs)))

    return np.vstack(q_vecs)


def modify_crystal(anglesXYZ, ucell_params, starting_crystal):
    """
    applies a rotation and unit cell adjustment to crystal
    :param anglesXYZ: rotation angles
    :param ucell_params: unit cell param
    :param starting_crystal: dxtbx crystal
    :return:
    """
    from scitbx.matrix import col
    from copy import deepcopy
    x = col((-1, 0, 0))
    y = col((0, -1, 0))
    z = col((0, 0, -1))
    RX = x.axis_and_angle_as_r3_rotation_matrix(anglesXYZ[0], deg=False)
    RY = y.axis_and_angle_as_r3_rotation_matrix(anglesXYZ[1], deg=False)
    RZ = z.axis_and_angle_as_r3_rotation_matrix(anglesXYZ[2], deg=False)
    M = RX * RY * RZ
    q = M.r3_rotation_matrix_as_unit_quaternion()
    rot_ang, rot_ax = q.unit_quaternion_as_axis_and_angle(deg=True)

    UCELL_MAN = manager_from_params(ucell_params)
    B = UCELL_MAN.B_recipspace

    C = deepcopy(starting_crystal)
    C.set_B(B)
    if rot_ang > 0:
        C.rotate_around_origin(rot_ax, rot_ang)
    return C


def parse_reso_string(s):
    """
    :param s:  a strong formated as %f-%f,%f-%f,%f-%f etc.
    :return: two floats as a tuple
    """
    vals =[]
    try:
        for subs in s.strip().split(","):
            a, b = map(float, subs.strip().split("-"))
            assert a < b
            vals.append((a,b))
    except Exception as error:
        MAIN_LOGGER.error("Failed to parse string!", error)
        raise ValueError("Wrong string format, see error above")
    return vals


def refls_to_hkl(refls, detector, beam, crystal,
                 update_table=False, returnQ=False, wavelen=None):
    """
    convert pixel panel reflections to miller index data
    :param refls:  reflecton table for a panel or a tuple of (x,y)
    :param detector:  dxtbx detector model
    :param beam:  dxtbx beam model
    :param crystal: dxtbx crystal model
    :param update_table: whether to update the refltable
    :param returnQ: whether to return intermediately computed q vectors
    :return: if as_numpy two Nx3 numpy arrays are returned
        (one for fractional and one for whole HKL)
        else dictionary of hkl_i (nearest) and hkl (fractional)
    """
    from scitbx.matrix import sqr
    if 'rlp' not in list(refls.keys()):
        q_vecs = refls_to_q(refls, detector, beam, update_table=update_table)
    else:
        q_vecs = np.vstack([refls[i_r]['rlp'] for i_r in range(len(refls))])
    Ai = sqr(crystal.get_A()).inverse()
    Ai = Ai.as_numpy_array()
    HKL = np.dot( Ai, q_vecs.T)
    HKLi = np.ceil(HKL-0.5)
    if update_table:
        refls['miller_index'] = flex.miller_index(list(map(tuple, HKLi.T.astype(np.int32))))
    if returnQ:
        return np.vstack(HKL).T, np.vstack(HKLi).T, q_vecs
    else:
        return np.vstack(HKL).T, np.vstack(HKLi).T


def get_panels_fasts_slows(expt, pids, rois, img_sh=None):
    """
    :param expt: dxtbx experiment
    :param pids: panel ids
    :param rois: regions of interest
    :param img_sh: 3-tuple Npan, Nslow, Nfast
    :return:
    """
    if expt is not None:
        npan = len(expt.detector)
        nfast, nslow = expt.detector[0].get_image_size()
    else:
        assert img_sh is not None
        npan, nslow, nfast = img_sh
    MASK = np.zeros((npan, nslow, nfast), bool)
    ROI_ID = np.zeros((npan, nslow, nfast), 'uint16')
    #ROI_ID = NP_ONES((npan, nslow, nfast), 'uint16') * mx
    nspots = len(rois)
    for i_spot in range(nspots):
        x1, x2, y1, y2 = rois[i_spot]
        if x2-x1 == 0 or y2-y1 == 0:
            continue
        pid = pids[i_spot]
        MASK[pid, y1:y2, x1:x2] = True
        ROI_ID[pid, y1:y2, x1:x2] = i_spot
    p,s,f = np.where(MASK)
    roi_id = ROI_ID[p,s,f]
    pan_fast_slow = np.ascontiguousarray((np.vstack([p,f,s]).T).ravel())
    pan_fast_slow = flex.size_t(pan_fast_slow)
    return pan_fast_slow, roi_id


def f_double_prime(energies, a,b,c,d, deriv=None):
    """
    generate a 4 parameter f double prime curve based on the sigmoid function
    :param energies:
    :param a: offset
    :param b: amplitude
    :param c: center
    :param d: slope
    :param deriv: string flag, c,d or None,
        eg 'c' returns deriv of f_dbl_prime w.r.t. c, None returns function f_dbl_prime
    :return: f double prime as a function of energy
    """
    exp_arg = -d * (energies - c)
    e_term = np.exp(exp_arg)
    if deriv=="c":
        return -b*(1+e_term)**-2 * e_term * d
    elif deriv=="d":
        return -b*(1+e_term)**-2 * e_term * (c-energies)
    else:
        return a + b / (1+e_term)


def f_prime(f_double_prime, S=None, padn=5000):
    """
    generate an f_prime from an f_double_prime curve
    using the kramers kronig relationship
    :param f_double_prime: function or its derivative
    :param S:
    :param padn:
    :return:
    """
    if S is None:
        S = np.sin(np.linspace(-np.pi / 2, np.pi / 2, padn)) * 0.5 + 0.5
    else:
        padn = S.shape[0]
    F = f_double_prime
    Fin = np.hstack((F[0] * S,
                     F,
                     F[-1] * (1 - S)))  # sin padding as used in Sherrell thesis, TODO window function ?
    Ft = fft.fft(Fin)
    iFt = -1 * fft.ifft(1j * np.sign(fft.fftfreq(Ft.shape[0])) * Ft).real
    return iFt[padn:-padn]


def shift_panelZ(D, shift):
    """
    :param D:  dxtbx detector
    :param shift:  shift in mm for origin Z component
    :return: new detector with shift applied to each panel origin
    """
    newD = Detector()
    for pid in range(len(D)):
        panel = D[pid]
        pan_dict = panel.to_dict()
        x,y,z = panel.get_origin()
        pan_dict["origin"] = x,y,z+shift
        pan_dict["fast_axis"] = panel.get_fast_axis()
        pan_dict["slow_axis"] = panel.get_slow_axis()
        newP = Panel.from_dict(pan_dict)
        newD.add_panel(newP)
    return newD

def safe_makedirs(name):
    """
    :param name: dirname to create
    """
    if not os.path.exists(name):
        os.makedirs(name)


def _rfactor_minimizer_target(k, F1, F2):
    """
    :param k: scale factor
    :param F1: miller array
    :param F2: miller array
    :return:
    """
    return F1.r1_factor(F2, scale_factor=k[0])


def compute_scale_to_minmize_r_factor(F1, F2, anom=True):
    """
    F1, F2 : two miller arrays (should be of type amplitude)
    scale factor should be applied to F2 such that the R factor is minmized between the two arrays!"""
    if min(F1.data()) < 0:
        F1 = F1.as_amplitude_array()
    if min(F2.data()) < 0:
        F2 = F2.as_amplitude_array()

    indices_common = set(F1.indices()).intersection(F2.indices())
    indices_common = flex.miller_index(list(indices_common))
    F1 = F1.select_indices(indices_common)
    F2_mset = F1.miller_set(indices_common, anom)
    F2_map = {h:d for h,d in zip(F2.indices(), F2.data())}
    F2_data = flex.double([F2_map[h] for h in indices_common])
    F2 = miller.array(F2_mset, F2_data)
    F1=F1.sort(by_value='packed_indices')
    F2=F2.sort(by_value='packed_indices')

    res = minimize(_rfactor_minimizer_target,
                       x0=[1], args=(F1, F2),
                   method='Nelder-Mead')

    assert res.success
    r1_scale = res.x[0]
    MAIN_LOGGER.debug("Optimization successful!, using scale factor=%f" % r1_scale)
    return r1_scale


def show_diffBragg_state(D, debug_pixel_panelfastslow):
    """
    D, diffBragg instance
    debug_pixel_panelfastslow, 3-tuple of ints, panelId, fast coord, slow coord
    """
    # TODO be careful with zero-ing the pixels - is this really what we want to do ?
    # TODO, rather than print the state, pickle the state
    D.show_params()
    MAIN_LOGGER.info("internal spot scale=%f" % D.spot_scale)
    D.raw_pixels*=0
    p, f, s = debug_pixel_panelfastslow
    D.printout_pixel_fastslow = f, s
    D.add_diffBragg_spots((p, f, s))
    D.raw_pixels*=0


def get_phil(params):
    """
    recursively print the phil param string, given a phil scope extract obj
    :param params: libtbx.phil.scope_extract object
    """
    for p in dir(params):
        if p.startswith("_"):
            continue
        name, val = params.__phil_path_and_value__(p)
        if not isinstance(val, libtbx.phil.scope_extract):
            print("%s =" % name, val)
        else:
            get_phil(val)


class Capturing(list):
    # class for capturing function output in a list:
    # https://stackoverflow.com/a/16571630/2077270
    def __enter__(self):
        self._stdout = sys.stdout
        sys.stdout = self._stringio = StringIO()
        return self

    def __exit__(self, *args):
        self.extend(self._stringio.getvalue().splitlines())
        del self._stringio  # free up some memory
        sys.stdout = self._stdout


def recover_diff_phil_from_scope_extract(modeler_file):
    """
    Prints the diff phil used to run stage 1 (diffBragg portion only)
    :param modeler_file: npy file written by hopper_process during stage 1, stored in the
    output.output_dir/modelers folder
    """
    # get the phil scope extract
    params = np.load(modeler_file, allow_pickle=True)[()].params
    with Capturing() as output:
        get_phil(params)
    user_phil = parse("\n".join(output))
    master = parse("diffBragg {\n%s\n}" %  (phil.philz + phil.hopper_phil))
    master.fetch_diff(source=user_phil).show()


def get_extracted_params_from_phil_sources(phil_file=None, cmdline_phil_lst=None):
    """
    get a params obj derived from diffBragg/phil.py thats ready to passed to various methods
    :param phil_file: is the path to a phil configuration file for diffBragg/phil.py
    :param cmdline_phil_lst: list of strings, each a command line phil arg, e.g. ['rank0_level=high', 'outdir=something']

    Just like in normal operation, the cmdline str does not need to specify the absolute scope unless there are conflicting scopes
    """

    phil_scope = parse(phil.philz + phil.hopper_phil)
    arg_interp = phil_scope.command_line_argument_interpreter(home_scope="")

    phil_sources = []

    if phil_file is not None:
        phil_from_file = open(phil_file, "r").read()
        user_phil = parse(phil_from_file)
        phil_sources.append(user_phil)

    if cmdline_phil_lst is not None:
        command_line_phils = [arg_interp.process(phil.strip()) for phil in cmdline_phil_lst]
        phil_sources += command_line_phils

    working_phil, unused = phil_scope.fetch(sources=phil_sources, track_unused_definitions=True)
    for loc in unused:
        print("WARNING: unused phil:", loc)

    params = working_phil.extract()
    return params


def get_laue_group_number(sg_symbol=None):
    """ get laue group number from space group symbol """
    if sg_symbol is None:
        laue_sym = "P-1"
    else:
        g = sgtbx.space_group_info(sg_symbol).group()
        if g.laue_group_type() not in ["2/m", "-3m"]:
            laue_sym = "P{}".format(g.laue_group_type())
        else:
            pg = str(g.build_derived_patterson_group().info().symbol_and_number())
            lc = re.sub(r'\([^)]*\)', '', pg[2:]).replace(" ", "")
            if pg[0] == "R":
                lc = lc.replace(":H", "1")
            laue_sym = "P{}".format(lc)

    hm_symbols = ['P-1', 'P112/m', 'P12/m1', 'P2/m11', 'Pmmm', 'P4/m', 'P4/mmm', 'P-3', 'P-3m1', 'P-31m', 'P6/m',
                  'P6/mmm', 'Pm-3', 'Pm-3m']
    lgs = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]
    return lgs[hm_symbols.index(laue_sym)]


def track_fhkl(Modeler):
    try:
        from stream_redirect import Redirect
    except ImportError:
        print("Cannot use track_fhkl unless module stream_redirect is installed: pip install stream-redirect")
        return
    SIM = Modeler.SIM
    SIM.D.track_Fhkl = True
    npix = int( len(Modeler.pan_fast_slow)/ 3)
    PFS = np.reshape(Modeler.pan_fast_slow, (npix, 3))
    uroi = set(Modeler.roi_id)
    all_good_count_stats = []
    all_bad_count_stats = []
    all_count_stats = {}
    for ii, i_roi in enumerate(uroi):
        output = Redirect(stdout=True)
        i_roi_sel = Modeler.roi_id == i_roi
        with output:
            sel = np.logical_and(i_roi_sel, Modeler.all_trusted)
            pfs_roi = PFS[sel]
            pfs_roi = np.ascontiguousarray(pfs_roi.ravel())
            pfs_roi = flex.size_t(pfs_roi)
            SIM.D.add_diffBragg_spots(pfs_roi)
        #i_fcell = Modeler.all_fcell_global_idx[i_roi_sel][0]
        #shoebox_hkl = SIM.asu_from_i_fcell[i_fcell]
        lines = output.stdout.split("\n")
        count_stats = {}
        for l in lines:
            if l.startswith("Pixel"):
                hkl = l.split()[5]
                hkl = tuple(map(int, hkl.split(",")))
                hkl = map_hkl_list([hkl], True, SIM.crystal.space_group_info.type().lookup_symbol())[0]
                count = int(l.split()[8])
                if hkl in count_stats:
                    count_stats[hkl] += count
                else:
                    count_stats[hkl] = count
        ntot = sum(count_stats.values())
        #assert shoebox_hkl in count_stats
        #print("Shoebox hkl", shoebox_hkl)
        for hkl in count_stats:
            frac = 0 if ntot ==0 else count_stats[hkl] / float(ntot)
            h, k, l = hkl
            print("\tstep hkl %d,%d,%d : frac=%.1f%%" % (h, k, l, frac * 100))
            count_stats[hkl] = frac

        all_count_stats[i_roi] = count_stats
    return all_count_stats


def load_Fhkl_model_from_params_and_expt(params, expt):
    """

    :param params:  diffBragg params instance (diffBragg/phil.py)
    :param expt: dxtbx experiment with crystal
    :return:
    """
    sf = params.simulator.structure_factors
    if sf.mtz_name is None:
        if sf.from_pdb.name is not None:
            wavelength=None
            if sf.from_pdb.add_anom:
                wavelength = expt.beam.get_wavelength()
            miller_data = get_complex_fcalc_from_pdb(sf.from_pdb.name,
                dmin=params.simulator.structure_factors.dmin,
                dmax=params.simulator.structure_factors.dmax,
                wavelength=wavelength,
                k_sol=params.simulator.structure_factors.from_pdb.k_sol,
                b_sol=params.simulator.structure_factors.from_pdb.b_sol)
            miller_data = miller_data.as_amplitude_array()

        else:
            miller_data = make_miller_array(
                symbol=expt.crystal.get_space_group().info().type().lookup_symbol(),
                unit_cell=expt.crystal.get_unit_cell(), d_min=sf.dmin,
                d_max=sf.dmax,
                defaultF=sf.default_F)
    else:
        miller_data = open_mtz(sf.mtz_name, sf.mtz_column)

    return miller_data


def find_diffBragg_instances(globe_objs):
    """find any instances of diffbragg in globals
        globe_objs is a return value of globals() (dict)
    """
    inst_names = []
    for name,obj in globe_objs.items():
        if "simtbx.nanoBragg.sim_data.SimData" in str(obj):
            inst_names.append(name)
        if "simtbx_diffBragg_ext.diffBragg" in str(obj):
            inst_names.append(name)
    return inst_names


def memory_report(prefix='Memory usage'):
    """Return a string documenting memory usage; to be used with LOGGER.info"""
    memory_usage_in_gb = get_memory_usage() / 1024.
    host = socket.gethostname()
    return "%s: %f GB on node %s" % (prefix, memory_usage_in_gb, host)


def smooth(x, beta=10.0, window_size=11):
    """
    https://glowingpython.blogspot.com/2012/02/convolution-with-numpy.html

    Apply a Kaiser window smoothing convolution.

    Parameters
    ----------
    x : ndarray, float
        The array to smooth.

    Optional Parameters
    -------------------
    beta : float
        Parameter controlling the strength of the smoothing -- bigger beta
        results in a smoother function.
    window_size : int
        The size of the Kaiser window to apply, i.e. the number of neighboring
        points used in the smoothing.

    Returns
    -------
    smoothed : ndarray, float
        A smoothed version of `x`.
    """

    # make sure the window size is odd
    if window_size % 2 == 0:
        window_size += 1

    # apply the smoothing function
    s = np.r_[x[window_size - 1:0:-1], x, x[-1:-window_size:-1]]
    w = np.kaiser(window_size, beta)
    y = np.convolve(w / w.sum(), s, mode='valid')

    # remove the extra array length convolve adds
    b = int((window_size - 1) / 2)
    smoothed = y[b:len(y) - b]

    return smoothed


 *******************************************************************************


 *******************************************************************************
simtbx/gpu/__init__.py
from __future__ import absolute_import, division, print_function
import boost_adaptbx.boost.python as bp
import cctbx.uctbx # possibly implicit
ext = bp.import_ext("simtbx_gpu_ext")
from simtbx_gpu_ext import *



 *******************************************************************************


 *******************************************************************************
simtbx/gpu/tst_exafel_api.py
"""
Extend the tests in tst_gauss_argchk.
Both test cases excercise a simple monolithic detector
tst_exafel_api introduces polychromatic beam (3 wavelengths in this simplified example)
Supply command-line context=[kokkos_gpu | cuda] to switch between both implementations
Test 1) standard C++ result CPU
     2) CPU, but use the stable sort version of CPU background (FUTURE PLAN)
     3) exafel api interface to GPU, fast evaluation on many energy channels, CPU background
     4) exafel api interface to GPU, fast evaluation on many energy channels, GPU background
     5) exafel api interface to GPU, with GAUSS_ARGCHK
"""
from __future__ import absolute_import, division, print_function
import numpy as np
import dxtbx
from scitbx.array_family import flex
from scitbx.matrix import sqr
from simtbx.nanoBragg import nanoBragg, shapetype
from simtbx.nanoBragg.tst_gauss_argchk import water, basic_crystal, basic_beam, basic_detector, amplitudes
from simtbx import get_exascale

def parse_input():
  from iotbx.phil import parse
  master_phil="""
    context = kokkos_gpu *cuda
      .type = choice
      .optional = False
      .help = backend for parallel execution
  """
  phil_scope = parse(master_phil)
  # The script usage
  import libtbx.load_env # implicit import
  from dials.util.options import ArgumentParser
  # Create the parser
  parser = ArgumentParser(
        usage="\n libtbx.python tst_exafel_api context=[kokkos_gpu|cuda]",
        phil=phil_scope,
        epilog="test monolithic detector, three-energy beam, cuda vs. kokkos")
  # Parse the command line. quick_parse is required for MPI compatibility
  params, options = parser.parse_args(show_diff_phil=True,quick_parse=True)
  return params,options

class several_wavelength_case:
 def __init__(self, BEAM, DETECTOR, CRYSTAL, SF_model):
  SIM = nanoBragg(DETECTOR, BEAM, panel_id=0)
  print("\nassume three energy channels")
  self.wavlen = flex.double([BEAM.get_wavelength()-0.002, BEAM.get_wavelength(), BEAM.get_wavelength()+0.002])
  self.flux = flex.double([(1./6.)*SIM.flux, (3./6.)*SIM.flux, (2./6.)*SIM.flux])
  self.sfall_channels = {}
  for x in range(len(self.wavlen)):
    self.sfall_channels[x] = SF_model.get_amplitudes(at_angstrom = self.wavlen[x])
  self.DETECTOR = DETECTOR
  self.BEAM = BEAM
  self.CRYSTAL = CRYSTAL
  self.domains_per_crystal = 5.E10 # put Bragg spots on larger scale relative to background

 def several_wavelength_case_for_CPU(self):
  SIM = nanoBragg(self.DETECTOR, self.BEAM, panel_id=0)
  SIM.adc_offset_adu=0
  for x in range(len(self.wavlen)):
    SIM.flux = self.flux[x]
    SIM.wavelength_A = self.wavlen[x]
    print("CPUnanoBragg_API+++++++++++++ Wavelength %d=%.6f, Flux %.6e, Fluence %.6e"%(
            x, SIM.wavelength_A, SIM.flux, SIM.fluence))
    SIM.Fhkl = self.sfall_channels[x]
    SIM.Ncells_abc = (20,20,20)
    SIM.Amatrix = sqr(self.CRYSTAL.get_A()).transpose()
    SIM.oversample = 2
    SIM.xtal_shape = shapetype.Gauss
    SIM.interpolate = 0
    SIM.add_nanoBragg_spots()
  SIM.raw_pixels*=self.domains_per_crystal
  ref_max_bragg = flex.max(SIM.raw_pixels) # get the maximum pixel value for a Bragg spot

  SIM.wavelength_A = self.BEAM.get_wavelength()
  SIM.Fbg_vs_stol = water
  SIM.amorphous_sample_thick_mm = 0.02
  SIM.amorphous_density_gcm3 = 1
  SIM.amorphous_molecular_weight_Da = 18
  SIM.flux=1e12
  SIM.beamsize_mm=0.003 # square (not user specified)
  SIM.exposure_s=1.0 # multiplies flux x exposure
  SIM.progress_meter=False
  SIM.add_background()
  ref_mean_with_background = flex.mean(SIM.raw_pixels)
  print ("Ratio",ref_max_bragg/ref_mean_with_background)
  assert ref_max_bragg > 10. * ref_mean_with_background # data must be sensible, Bragg >> solvent
  return SIM

 def modularized_exafel_api_for_GPU(self, params, argchk=False, gpu_background=True):
  gpu_channels_type = get_exascale("gpu_energy_channels",params.context)
  gpu_channels_singleton = gpu_channels_type (deviceId = 0)

  SIM = nanoBragg(self.DETECTOR, self.BEAM, panel_id=0)
  SIM.adc_offset_adu=0
  SIM.device_Id = 0

  assert gpu_channels_singleton.get_deviceID()==SIM.device_Id
  assert gpu_channels_singleton.get_nchannels() == 0 # uninitialized
  for x in range(len(self.flux)):
          gpu_channels_singleton.structure_factors_to_GPU_direct(
           x, self.sfall_channels[x].indices(), self.sfall_channels[x].data())
  assert gpu_channels_singleton.get_nchannels() == len(self.flux)
  SIM.Ncells_abc = (20,20,20)
  SIM.Amatrix = sqr(self.CRYSTAL.get_A()).transpose()
  SIM.oversample = 2
  if argchk:
    print("\npolychromatic GPU argchk")
    SIM.xtal_shape = shapetype.Gauss_argchk
  else:
    print("\npolychromatic GPU no argchk")
    SIM.xtal_shape = shapetype.Gauss
  SIM.interpolate = 0
  # allocate GPU arrays
  gpu_simulation = get_exascale("exascale_api",params.context)(nanoBragg = SIM)
  gpu_simulation.allocate()

  gpu_detector = get_exascale("gpu_detector",params.context)(
                 deviceId=SIM.device_Id, detector=self.DETECTOR, beam=self.BEAM)
  gpu_detector.each_image_allocate()

  # loop over energies
  for x in range(len(self.flux)):
      SIM.flux = self.flux[x]
      SIM.wavelength_A = self.wavlen[x]
      print("USE_EXASCALE_API+++++++++++++ Wavelength %d=%.6f, Flux %.6e, Fluence %.6e"%(
            x, SIM.wavelength_A, SIM.flux, SIM.fluence))
      gpu_simulation.add_energy_channel_from_gpu_amplitudes(
        x, gpu_channels_singleton, gpu_detector)
  per_image_scale_factor = self.domains_per_crystal # 1.0
  gpu_detector.scale_in_place(per_image_scale_factor) # apply scale directly on GPU
  SIM.wavelength_A = self.BEAM.get_wavelength() # return to canonical energy for subsequent background

  if gpu_background:
      SIM.Fbg_vs_stol = water
      SIM.amorphous_sample_thick_mm = 0.02
      SIM.amorphous_density_gcm3 = 1
      SIM.amorphous_molecular_weight_Da = 18
      SIM.flux=1e12
      SIM.beamsize_mm=0.003 # square (not user specified)
      SIM.exposure_s=1.0 # multiplies flux x exposure
      gpu_simulation.add_background(gpu_detector)

      # deallocate GPU arrays afterward
      gpu_detector.write_raw_pixels(SIM)  # updates SIM.raw_pixels from GPU
      gpu_detector.each_image_free()
  else:
      # deallocate GPU arrays up front
      gpu_detector.write_raw_pixels(SIM)  # updates SIM.raw_pixels from GPU
      gpu_detector.each_image_free()

      SIM.Fbg_vs_stol = water
      SIM.amorphous_sample_thick_mm = 0.02
      SIM.amorphous_density_gcm3 = 1
      SIM.amorphous_molecular_weight_Da = 18
      SIM.flux=1e12
      SIM.beamsize_mm=0.003 # square (not user specified)
      SIM.exposure_s=1.0 # multiplies flux x exposure
      SIM.progress_meter=False
      SIM.add_background()
  return SIM

def diffs(labelA, A, labelB, B):
  diff = A-B
  min = flex.min(diff); mean = flex.mean(diff); max = flex.max(diff)
  print("Pixel differences between %s and %s, minimum=%.4f mean=%.4f maximum=%.4f"%(
       labelA, labelB, min, mean, max))
  assert min > -1.0
  assert max < 1.0

if __name__=="__main__":
  params,options = parse_input()
  # make the dxtbx objects
  BEAM = basic_beam()
  DETECTOR = basic_detector()
  CRYSTAL = basic_crystal()
  SF_model = amplitudes(CRYSTAL)
  # Famp = SF_model.Famp # simple uniform amplitudes
  SF_model.random_structure(CRYSTAL)
  SF_model.ersatz_correct_to_P1()

  print("\n# Use case 2.  Three-wavelength polychromatic source")
  SWC = several_wavelength_case(BEAM, DETECTOR, CRYSTAL, SF_model)
  SIM = SWC.several_wavelength_case_for_CPU()
  SIM.to_smv_format(fileout="test_full_cpu_002.img") # scales by default
  scale = SIM.get_intfile_scale()
  print ("Scale",scale)
  SIM.to_cbf("test_full_cpu_002.cbf", intfile_scale=scale)
  # verify cbf (double) and smv (int) produce the same image to within an ADU
  loader_smv = dxtbx.load("test_full_cpu_002.img")
  loader_cbf = dxtbx.load("test_full_cpu_002.cbf")
  assert np.allclose(loader_cbf.get_raw_data().as_numpy_array(), loader_smv.get_raw_data().as_numpy_array(), atol=1.1)

  # Switch the remaining tests based on GPU context
  gpu_instance_type = get_exascale("gpu_instance", params.context)
  gpu_instance = gpu_instance_type(deviceId = 0)

  print("\n# Use case 3 (%s): modularized api argchk=False, gpu_background=False"%params.context)
  SIM3 = SWC.modularized_exafel_api_for_GPU(params=params, argchk=False, gpu_background=False)
  SIM3.to_cbf("test_full_%s_003.cbf"%(params.context), intfile_scale=scale)
  diffs("CPU",SIM.raw_pixels, "GPU",SIM3.raw_pixels)

  print("\n# Use case 4 (%s): modularized api argchk=False, gpu_background=True"%(params.context))
  SIM4 = SWC.modularized_exafel_api_for_GPU(params=params, argchk=False, gpu_background=True)
  SIM4.to_cbf("test_full_%s_004.cbf"%(params.context), intfile_scale=scale)
  diffs("CPU",SIM.raw_pixels, "GPU",SIM4.raw_pixels)

  print("\n# Use case 5 (%s): modularized api argchk=True, gpu_background=True"%(params.context))
  SIM5 = SWC.modularized_exafel_api_for_GPU(params=params, argchk=True, gpu_background=True)
  SIM5.to_cbf("test_full_%s_005.cbf"%(params.context), intfile_scale=scale)
  diffs("CPU",SIM.raw_pixels, "GPU",SIM5.raw_pixels)

print("OK")


 *******************************************************************************


 *******************************************************************************
simtbx/gpu/tst_gpu_multisource_background.py
from __future__ import absolute_import, division, print_function
from simtbx.nanoBragg import nanoBragg
import numpy as np

from simtbx.nanoBragg.tst_multisource_background import run_background_simulation
from simtbx.tests.test_utils import parse_input
from simtbx import get_exascale

class gpu_run_background_simulation(run_background_simulation):

  def gpu_background(self, params, override_source=2):
    gpu_channels_type = get_exascale("gpu_energy_channels",params.context)
    gpu_channels_singleton = gpu_channels_type (deviceId = 0)
    self.SIM.device_Id = 0
    # allocate GPU arrays
    gpu_simulation = get_exascale("exascale_api",params.context)(nanoBragg = self.SIM)
    gpu_simulation.allocate()

    gpu_detector = get_exascale("gpu_detector",params.context)(
                   deviceId=self.SIM.device_Id, nanoBragg=self.SIM)
    gpu_detector.each_image_allocate()

    per_image_scale_factor = 0.0
    gpu_detector.scale_in_place(per_image_scale_factor) # apply scale directly on GPU
    gpu_simulation.add_background(gpu_detector)
    gpu_detector.write_raw_pixels(self.SIM)  # updates SIM.raw_pixels from GPU
    self.bg_multi = self.SIM.raw_pixels.as_numpy_array()

    gpu_detector.scale_in_place(per_image_scale_factor)
    gpu_simulation.add_background(gpu_detector, override_source)
    gpu_detector.write_raw_pixels(self.SIM)
    self.bg_single = self.SIM.raw_pixels.as_numpy_array()

    gpu_detector.each_image_free()

def c_g_validate(cpu,gpu):
  mean_c = cpu.mean()
  mean_g = gpu.mean()
  print("cpu mean: %1.5g" % mean_c)
  print("gpu mean: %1.5g" % mean_g)
  if np.allclose(mean_c, mean_g): return True
  else:
    frac = mean_c / mean_g
    print("Means are off by a factor of %.6f" % frac)
    return False

def test_cpu_gpu_equivalence(params,n_chan=5,wave_interval=(0.998, 1.002),spectrum='tophat',single=2):
  cpu_run = run_background_simulation()
  gpu_run = gpu_run_background_simulation()
  beam = cpu_run.make_multichannel_beam_simulation(n_chan,wave_interval,spectrum)
  cpu_run.set_beam(beam)
  gpu_run.set_beam(beam)
  cpu_run.cpu_background(override_source=single)
  gpu_run.gpu_background(params, override_source=single)
  assert c_g_validate(cpu_run.bg_single, gpu_run.bg_single)
  if "plot" in sys.argv: plot_one_and_multi(cpu_run.bg_single, gpu_run.bg_single)
  assert c_g_validate(cpu_run.bg_multi, gpu_run.bg_multi)
  if "plot" in sys.argv: plot_one_and_multi(cpu_run.bg_multi, gpu_run.bg_multi)

if __name__=="__main__":
  import sys
  params,options = parse_input()
  # Initialize based on GPU context
  gpu_instance_type = get_exascale("gpu_instance", params.context)
  gpu_instance = gpu_instance_type(deviceId = 0)

  print("test with thin bandpass and tophat spectrum")
  test_cpu_gpu_equivalence(params=params)

  print("test with thin bandpass and tophat spectrum, more channels")
  test_cpu_gpu_equivalence(params=params, n_chan = 10)

  print("test with wider bandpass and tophat spectrum")
  test_cpu_gpu_equivalence(params=params, wave_interval=(0.98, 1.02))

  print("test with thin bandpass and gaussian spectrum")
  test_cpu_gpu_equivalence(params=params, n_chan=5, spectrum='gaussian', single=2)

  print("Scale-up the GPU channels--prints timing")
  from libtbx.development.timers import Profiler
  for n_chan in [20,40,80,160,320,640,1280,2560,5120]:
    P = Profiler("%d channels"%n_chan)
    gpu_run = gpu_run_background_simulation()
    beam = gpu_run.make_multichannel_beam_simulation(n_chan,wave_interval=(0.90,1.1))
    gpu_run.set_beam(beam)
    gpu_run.gpu_background(params=params)
    del P

  print("OK")


 *******************************************************************************


 *******************************************************************************
simtbx/gpu/tst_shoeboxes.py
"""
Extend the previous tests
Implemented unit tests for the whitelist mechanism:
     7) implement shoebox masks and resulting mask
     8) 3-wavelength, use add_energy_channel_mask_allpanel, use all-pixel int mask (equate 3,8)
     9) 3-wavelength, use add_energy_channel_mask_allpanel, use all-pixel bool mask (equate 3,9)
Unit test strategy:
Do a reference simulation with monochromatic beam.  Use dials to find strong spots.
Then construct two masks:  the positive mask just on the strong spot shoeboxes,
                       and the negative mask on all other pixels, including weak tails, weak spots, and background.
Then do two Bragg spot whitelist calls: one on tne positve mask, one on the negative mask.
A test image consisting of the sum of background + positive mask values + negative mask values should equal the reference image.
Furthermore, the result should be the same for either type of whitelist: bool array or integer addresses.
The GPU classes required modification for this to work, specifically the deepest array had to
be reinitialized after each Bragg calculation.
"""
from __future__ import absolute_import, division, print_function
import numpy as np
from dials.array_family import flex
from scitbx.matrix import sqr
from simtbx.tests.tst_unified import several_wavelength_case
from simtbx.nanoBragg.tst_gauss_argchk import water, basic_crystal, basic_beam, basic_detector, amplitudes
from simtbx import get_exascale
from simtbx.nanoBragg import nanoBragg, shapetype

def _dials_phil_str():
    return """
  include scope dials.algorithms.spot_finding.factory.phil_scope
"""
def spots_params():
  from iotbx.phil import parse
  dials_phil_str = _dials_phil_str()
  master_phil="""
    context = kokkos_gpu *cuda
      .type = choice
      .optional = False
      .help = backend for parallel execution
  output {
    shoeboxes = True
      .type = bool
      .help = Save the raw pixel values inside the reflection shoeboxes during spotfinding.
  }
  """
  phil_scope = parse(master_phil + dials_phil_str, process_includes=True)
  # The script usage
  import libtbx.load_env # implicit import
  from dials.util.options import ArgumentParser
  # Create the parser
  parser = ArgumentParser(usage="",phil=phil_scope, epilog="")
  # Parse the command line. quick_parse is required for MPI compatibility
  params, options = parser.parse_args(show_diff_phil=True,quick_parse=True)
  return params, options

class whitelist_case(several_wavelength_case):
  def extensions_for_shoebox_usage(self, params, argchk=False, gpu_background=True, sources=False):
    gpu_channels_type = get_exascale("gpu_energy_channels",params.context)
    gpu_channels_singleton = gpu_channels_type (deviceId = 0)

    SIM = nanoBragg(self.DETECTOR, self.BEAM, panel_id=0)
    SIM.adc_offset_adu=0
    SIM.device_Id = 0

    assert gpu_channels_singleton.get_deviceID()==SIM.device_Id # API test
    assert gpu_channels_singleton.get_nchannels() == 0 # uninitialized
    for x in range(len(self.flux)):
          gpu_channels_singleton.structure_factors_to_GPU_direct(
           x, self.sfall_channels[x].indices(), self.sfall_channels[x].data())
    assert gpu_channels_singleton.get_nchannels() == len(self.flux) #API test
    SIM.Ncells_abc = (20,20,20)
    SIM.Amatrix = sqr(self.CRYSTAL.get_A()).transpose()
    SIM.oversample = 2
    SIM.xtal_shape = shapetype.Gauss
    SIM.interpolate = 0
    # allocate GPU arrays
    gpu_simulation = get_exascale("exascale_api",params.context)(nanoBragg = SIM)
    assert hasattr(gpu_simulation, "diffuse")==(params.context=="kokkos_gpu") # diffuse halo only implemented in kokkos
    gpu_simulation.allocate()
    gpu_detector = get_exascale("gpu_detector",params.context)(
                 deviceId=SIM.device_Id, detector=self.DETECTOR, beam=self.BEAM)
    gpu_detector.each_image_allocate()
    assert sources is False # original exascale API, explicit energy loop in Python

    for x in range(len(self.flux)):
        SIM.wavelength_A = self.wavlen[x]
        print("USE_WHITELIST(bool)_API+++++++++++++ Wavelength %d=%.6f, Flux %.6e, Fluence %.6e"%(
            x, SIM.wavelength_A, SIM.flux, SIM.fluence))
        gpu_simulation.add_energy_channel_mask_allpanel(
            x, gpu_channels_singleton, gpu_detector, positive_mask.as_1d())
            #weight = self.frac[x])
    per_image_scale_factor = self.domains_per_crystal # 1.0
    gpu_detector.scale_in_place(per_image_scale_factor) # apply scale directly on GPU
    positive_mask_bool_pixels = gpu_detector.get_raw_pixels()
    gpu_detector.scale_in_place(0) # reset
    """ explanation:  There are two arrays on device
    m_floatimage is the deepest one, that adds up bragg spots for each simulation call
    m_accumulate_floatimage is incremented by m_floatimage in the add_array(), only at the end of each simulation call
    the scale_in_place(0) only resets the shallow array (m_accumulate_floatimage)
    the deeper array (m_floatimage) could only be zeroed previously by the deallocate/allocate cycle
    instead, propose changing the add_array() kernel so that it does two jobs:
      1) add the deep array (m_floatimage) to the shallow (which is the current behavior)
      2) zero out the deep array (new behavior, should fix problem)
    """
    for x in range(len(self.flux)):
        SIM.wavelength_A = self.wavlen[x]
        print("USE_WHITELIST(bool)_API+++++++++++++ Wavelength %d=%.6f, Flux %.6e, Fluence %.6e"%(
            x, SIM.wavelength_A, SIM.flux, SIM.fluence))
        gpu_simulation.add_energy_channel_mask_allpanel(
            x, gpu_channels_singleton, gpu_detector, negative_mask.as_1d())
    gpu_detector.scale_in_place(per_image_scale_factor) # apply scale directly on GPU
    negative_mask_bool_pixels = gpu_detector.get_raw_pixels()
    gpu_detector.scale_in_place(0) # reset

    if True: # insert tests here, for the integer-address whitelist interface
      for x in range(len(self.flux)):
        SIM.wavelength_A = self.wavlen[x]
        print("USE_WHITELIST(pixel_address)_API+++++++++++++ Wavelength %d=%.6f, Flux %.6e, Fluence %.6e"%(
            x, SIM.wavelength_A, SIM.flux, SIM.fluence))
        gpu_simulation.add_energy_channel_mask_allpanel(
            x, gpu_channels_singleton, gpu_detector, positive_mask.iselection())
        per_image_scale_factor = self.domains_per_crystal # 1.0
        gpu_detector.scale_in_place(per_image_scale_factor) # apply scale directly on GPU
        positive_mask_int_pixels = gpu_detector.get_raw_pixels()
      gpu_detector.scale_in_place(0) # reset
      for x in range(len(self.flux)):
        SIM.wavelength_A = self.wavlen[x]
        print("USE_WHITELIST(pixel_address)_API+++++++++++++ Wavelength %d=%.6f, Flux %.6e, Fluence %.6e"%(
            x, SIM.wavelength_A, SIM.flux, SIM.fluence))
        gpu_simulation.add_energy_channel_mask_allpanel(
            x, gpu_channels_singleton, gpu_detector, negative_mask.iselection())
      gpu_detector.scale_in_place(per_image_scale_factor) # apply scale directly on GPU
      negative_mask_int_pixels = gpu_detector.get_raw_pixels()
      gpu_detector.scale_in_place(0) # reset
      assert np.allclose(positive_mask_int_pixels, positive_mask_bool_pixels) # either API gives same answer (int vs. bool)
      assert np.allclose(negative_mask_int_pixels, negative_mask_bool_pixels)

    SIM.wavelength_A = self.BEAM.get_wavelength() # return to canonical energy for subsequent background
    SIM.Fbg_vs_stol = water
    SIM.amorphous_sample_thick_mm = 0.02
    SIM.amorphous_density_gcm3 = 1
    SIM.amorphous_molecular_weight_Da = 18
    SIM.flux=1e12
    SIM.beamsize_mm=0.003 # square (not user specified)
    SIM.exposure_s=1.0 # multiplies flux x exposure
    gpu_simulation.add_background(gpu_detector)
    """Problem statement (before the GPU code was modified)
with pos first
pos -> back + pos
neg -> back + neg + pos
both-> back + neg + 2*pos

with neg first
pos -> back + neg + pos
neg -> back + neg
both-> back + 2*neg + pos

"""
    gpu_detector.write_raw_pixels(SIM)  # updates SIM.raw_pixels from GPU
    gpu_detector.each_image_free()
    SIM.raw_pixels += positive_mask_bool_pixels
    SIM.raw_pixels += negative_mask_bool_pixels
    return SIM

if __name__=="__main__":
  params,options = spots_params()
  # make the dxtbx objects
  BEAM = basic_beam()
  DETECTOR = basic_detector()
  CRYSTAL = basic_crystal()
  SF_model = amplitudes(CRYSTAL)
  # Famp = SF_model.Famp # simple uniform amplitudes
  SF_model.random_structure(CRYSTAL)
  SF_model.ersatz_correct_to_P1()

  # Initialize based on GPU context
  gpu_instance_type = get_exascale("gpu_instance", params.context)
  gpu_instance = gpu_instance_type(deviceId = 0)

  print("\n# Use case 1 (%s). Monochromatic source"%params.context)
  SWC = several_wavelength_case(BEAM, DETECTOR, CRYSTAL, SF_model, weights=flex.double([1.]))
  SIM1 = SWC.modularized_exafel_api_for_GPU(params=params, argchk=False, gpu_background=True)
  scale = SIM1.get_intfile_scale() # case 1 is the overall scale factor to write all result files
  SIM1.to_cbf("test_shoebox_%s_001.cbf"%(params.context), intfile_scale=scale)
  SIM1.raw_pixels *= scale # temporarily set to intfile_scale for spotfinder
  from dxtbx.model.experiment_list import (
    Experiment,
    ExperimentList,
    ExperimentListFactory,
  )
  experiments = ExperimentListFactory.from_imageset_and_crystal(SIM1.imageset, CRYSTAL)

  # Find the strong spots
  observed = flex.reflection_table.from_observations(experiments, params, is_stills=True)
  observed.as_file("test_shoebox_%s_001.refl"%(params.context))
  SIM1.raw_pixels /= scale # reset from intfile_scale after spotfinder
  # Find the positive mask
  image_grid = flex.grid(SIM1.raw_pixels.focus())
  positive_mask = flex.bool(image_grid, False)

  imask = SIM1.imageset.get_mask(0)
  for x in range(len(observed)):
    fast1, fast2, slow1, slow2, z1, z2 = observed["bbox"][x]
    for slow in range(slow1,slow2):
      for fast in range(fast1,fast2):
        positive_mask[(slow,fast)]=True
  negative_mask=~positive_mask
  import pickle
  with open("test_shoebox_%s_001.mask"%(params.context),"wb") as M:
    pickle.dump([positive_mask], M)
  with open("test_shoebox_%s_002.mask"%(params.context),"wb") as M:
    pickle.dump([negative_mask], M)

  print("\n# Use case 2 (%s). Pixel masks."%params.context)
  print(positive_mask.count(True), negative_mask.count(True), len(positive_mask))
  WC = whitelist_case(BEAM, DETECTOR, CRYSTAL, SF_model, weights=flex.double([1.]))
  SIM3 = WC.extensions_for_shoebox_usage(params=params, argchk=False, gpu_background=True)
  SIM3.to_cbf("test_shoebox_%s_003.cbf"%(params.context), intfile_scale=scale)

  assert np.allclose(SIM1.raw_pixels, SIM3.raw_pixels) # reassembly equates with original image

print("OK")


 *******************************************************************************


 *******************************************************************************
simtbx/kokkos/__init__.py
from __future__ import absolute_import, division, print_function
import boost_adaptbx.boost.python as bp
import cctbx.uctbx # possibly implicit
ext = bp.import_ext("simtbx_kokkos_ext")
from simtbx_kokkos_ext import *



 *******************************************************************************


 *******************************************************************************
simtbx/kokkos/tst_kokkos_lib.py
"""
Extend the tests in tst_exafel_api to test KOKKOS vs CUDA
Both test cases excercise a simple monolithic detector
Test 1) standard C++ result CPU
     2) CPU, but use the stable sort version of CPU background (FUTURE PLAN)
     3) exafel api interface to GPU, fast evaluation on many energy channels, CPU background
     4) exafel api interface to GPU, fast evaluation on many energy channels, GPU background
     5) exafel api interface to KOKKOS, fast evaluation on many energy channels, KOKKOS background
     6) exafel api interface to KOKKOS, with GAUSS_ARGCHK
"""
from __future__ import absolute_import, division, print_function
from scitbx.array_family import flex
from scitbx.matrix import sqr
from simtbx.nanoBragg import nanoBragg, shapetype

from simtbx.nanoBragg.tst_gauss_argchk import water, basic_crystal, basic_beam, basic_detector, amplitudes

class several_wavelength_case:
 def __init__(self, BEAM, DETECTOR, CRYSTAL, SF_model):
  SIM = nanoBragg(DETECTOR, BEAM, panel_id=0)
  print("\nassume three energy channels")
  self.wavlen = flex.double([BEAM.get_wavelength()-0.002, BEAM.get_wavelength(), BEAM.get_wavelength()+0.002])
  self.flux = flex.double([(1./6.)*SIM.flux, (3./6.)*SIM.flux, (2./6.)*SIM.flux])
  self.sfall_channels = {}
  for x in range(len(self.wavlen)):
    self.sfall_channels[x] = SF_model.get_amplitudes(at_angstrom = self.wavlen[x])
  self.DETECTOR = DETECTOR
  self.BEAM = BEAM
  self.CRYSTAL = CRYSTAL

 def several_wavelength_case_for_CPU(self):
  SIM = nanoBragg(self.DETECTOR, self.BEAM, panel_id=0)
  for x in range(len(self.wavlen)):
    SIM.flux = self.flux[x]
    SIM.wavelength_A = self.wavlen[x]
    print("CPUnanoBragg_API+++++++++++++ Wavelength %d=%.6f, Flux %.6e, Fluence %.6e"%(
            x, SIM.wavelength_A, SIM.flux, SIM.fluence))
    SIM.Fhkl = self.sfall_channels[x]
    SIM.Ncells_abc = (20,20,20)
    SIM.Amatrix = sqr(self.CRYSTAL.get_A()).transpose()
    SIM.oversample = 2
    SIM.xtal_shape = shapetype.Gauss
    SIM.interpolate = 0
    SIM.add_nanoBragg_spots()

  SIM.wavelength_A = self.BEAM.get_wavelength()
  SIM.Fbg_vs_stol = water
  SIM.amorphous_sample_thick_mm = 0.02
  SIM.amorphous_density_gcm3 = 1
  SIM.amorphous_molecular_weight_Da = 18
  SIM.flux=1e12
  SIM.beamsize_mm=0.003 # square (not user specified)
  SIM.exposure_s=1.0 # multiplies flux x exposure
  SIM.progress_meter=False
  SIM.add_background()
  return SIM

 def modularized_exafel_api_for_GPU(self, argchk=False, cuda_background=True):
  from simtbx.gpu import gpu_energy_channels
  gpu_channels_singleton = gpu_energy_channels(deviceId = 0)

  SIM = nanoBragg(self.DETECTOR, self.BEAM, panel_id=0)
  SIM.device_Id = 0

  assert gpu_channels_singleton.get_deviceID()==SIM.device_Id
  assert gpu_channels_singleton.get_nchannels() == 0 # uninitialized
  for x in range(len(self.flux)):
          gpu_channels_singleton.structure_factors_to_GPU_direct(
           x, self.sfall_channels[x].indices(), self.sfall_channels[x].data())
  assert gpu_channels_singleton.get_nchannels() == len(self.flux)
  SIM.Ncells_abc = (20,20,20)
  SIM.Amatrix = sqr(self.CRYSTAL.get_A()).transpose()
  SIM.oversample = 2
  if argchk:
    print("\npolychromatic GPU argchk")
    SIM.xtal_shape = shapetype.Gauss_argchk
  else:
    print("\npolychromatic GPU no argchk")
    SIM.xtal_shape = shapetype.Gauss
  SIM.interpolate = 0
  # allocate GPU arrays
  from simtbx.gpu import exascale_api
  gpu_simulation = exascale_api(nanoBragg = SIM)
  gpu_simulation.allocate()

  from simtbx.gpu import gpu_detector as gpud
  gpu_detector = gpud(deviceId=SIM.device_Id, detector=self.DETECTOR, beam=self.BEAM)
  gpu_detector.each_image_allocate()

  # loop over energies
  for x in range(len(self.flux)):
      SIM.flux = self.flux[x]
      SIM.wavelength_A = self.wavlen[x]
      print("USE_EXASCALE_API+++++++++++++ Wavelength %d=%.6f, Flux %.6e, Fluence %.6e"%(
            x, SIM.wavelength_A, SIM.flux, SIM.fluence))
      gpu_simulation.add_energy_channel_from_gpu_amplitudes(
        x, gpu_channels_singleton, gpu_detector)
  per_image_scale_factor = 1.0
  gpu_detector.scale_in_place(per_image_scale_factor) # apply scale directly on GPU
  SIM.wavelength_A = self.BEAM.get_wavelength() # return to canonical energy for subsequent background

  if cuda_background:
      SIM.Fbg_vs_stol = water
      SIM.amorphous_sample_thick_mm = 0.02
      SIM.amorphous_density_gcm3 = 1
      SIM.amorphous_molecular_weight_Da = 18
      SIM.flux=1e12
      SIM.beamsize_mm=0.003 # square (not user specified)
      SIM.exposure_s=1.0 # multiplies flux x exposure
      gpu_simulation.add_background(gpu_detector)

      # deallocate GPU arrays afterward
      gpu_detector.write_raw_pixels(SIM)  # updates SIM.raw_pixels from GPU
      gpu_detector.each_image_free()
  else:
      # deallocate GPU arrays up front
      gpu_detector.write_raw_pixels(SIM)  # updates SIM.raw_pixels from GPU
      gpu_detector.each_image_free()

      SIM.Fbg_vs_stol = water
      SIM.amorphous_sample_thick_mm = 0.02
      SIM.amorphous_density_gcm3 = 1
      SIM.amorphous_molecular_weight_Da = 18
      SIM.flux=1e12
      SIM.beamsize_mm=0.003 # square (not user specified)
      SIM.exposure_s=1.0 # multiplies flux x exposure
      SIM.progress_meter=False
      SIM.add_background()
  return SIM

 def modularized_exafel_api_for_KOKKOS(self, argchk=False, cuda_background=True):
  from simtbx.kokkos import gpu_energy_channels
  kokkos_channels_singleton = gpu_energy_channels()

  SIM = nanoBragg(self.DETECTOR, self.BEAM, panel_id=0)
  SIM.device_Id = 0

  assert kokkos_channels_singleton.get_nchannels() == 0 # uninitialized
  for x in range(len(self.flux)):
          kokkos_channels_singleton.structure_factors_to_GPU_direct(
          x, self.sfall_channels[x].indices(), self.sfall_channels[x].data())
  assert kokkos_channels_singleton.get_nchannels() == len(self.flux)
  SIM.Ncells_abc = (20,20,20)
  SIM.Amatrix = sqr(self.CRYSTAL.get_A()).transpose()
  SIM.oversample = 2
  if argchk:
    print("\npolychromatic KOKKOS argchk")
    SIM.xtal_shape = shapetype.Gauss_argchk
  else:
    print("\npolychromatic KOKKOS no argchk")
    SIM.xtal_shape = shapetype.Gauss
  SIM.interpolate = 0
  # allocate GPU arrays
  from simtbx.kokkos import exascale_api
  kokkos_simulation = exascale_api(nanoBragg = SIM)
  kokkos_simulation.allocate()

  from simtbx.kokkos import gpu_detector as kokkosd
  kokkos_detector = kokkosd(detector=self.DETECTOR, beam=self.BEAM)
  kokkos_detector.each_image_allocate()

  # loop over energies
  for x in range(len(self.flux)):
      SIM.flux = self.flux[x]
      SIM.wavelength_A = self.wavlen[x]
      print("USE_EXASCALE_API+++++++++++++ Wavelength %d=%.6f, Flux %.6e, Fluence %.6e"%(
            x, SIM.wavelength_A, SIM.flux, SIM.fluence))
      kokkos_simulation.add_energy_channel_from_gpu_amplitudes(
        x, kokkos_channels_singleton, kokkos_detector)
  per_image_scale_factor = 1.0
  kokkos_detector.scale_in_place(per_image_scale_factor) # apply scale directly in KOKKOS
  SIM.wavelength_A = self.BEAM.get_wavelength() # return to canonical energy for subsequent background

  if cuda_background:
      SIM.Fbg_vs_stol = water
      SIM.amorphous_sample_thick_mm = 0.02
      SIM.amorphous_density_gcm3 = 1
      SIM.amorphous_molecular_weight_Da = 18
      SIM.flux=1e12
      SIM.beamsize_mm=0.003 # square (not user specified)
      SIM.exposure_s=1.0 # multiplies flux x exposure
      kokkos_simulation.add_background(kokkos_detector)

      # updates SIM.raw_pixels from GPU
      kokkos_detector.write_raw_pixels(SIM)
  else:
      # updates SIM.raw_pixels from GPU
      kokkos_detector.write_raw_pixels(SIM)

      SIM.Fbg_vs_stol = water
      SIM.amorphous_sample_thick_mm = 0.02
      SIM.amorphous_density_gcm3 = 1
      SIM.amorphous_molecular_weight_Da = 18
      SIM.flux=1e12
      SIM.beamsize_mm=0.003 # square (not user specified)
      SIM.exposure_s=1.0 # multiplies flux x exposure
      SIM.progress_meter=False
      SIM.add_background()
  return SIM

def diffs(labelA, A, labelB, B):
  diff = A-B
  min = flex.min(diff); mean = flex.mean(diff); max = flex.max(diff)
  print("Pixel differences between %s and %s, minimum=%.4f mean=%.4f maximum=%.4f"%(
       labelA, labelB, min, mean, max))
  assert min > -1.0
  assert max < 1.0

if __name__=="__main__":
  # make the dxtbx objects
  BEAM = basic_beam()
  DETECTOR = basic_detector()
  CRYSTAL = basic_crystal()
  SF_model = amplitudes(CRYSTAL)
  # Famp = SF_model.Famp # simple uniform amplitudes
  SF_model.random_structure(CRYSTAL)
  SF_model.ersatz_correct_to_P1()

  print("\n# Use case 2.  Three-wavelength polychromatic source")
  SWC = several_wavelength_case(BEAM, DETECTOR, CRYSTAL, SF_model)
  SIM = SWC.several_wavelength_case_for_CPU()
  SIM.to_smv_format(fileout="test_full_e_002.img")
  SIM.to_cbf("test_full_e_002.cbf")

  print("\n# Use case: modularized api argchk=False, cuda_background=False")
  try:
    SIM3 = SWC.modularized_exafel_api_for_GPU(argchk=False, cuda_background=False)
  except ImportError:
    print(" - Skipped, no cuda module simtbx_gpu_ext found.")
  else:
    SIM3.to_smv_format(fileout="test_full_e_003.img")
    SIM3.to_cbf("test_full_e_003.cbf")
    diffs("CPU",SIM.raw_pixels, "GPU",SIM3.raw_pixels)

  print("\n# Use case: modularized api argchk=False, cuda_background=True")
  try:
    SIM4 = SWC.modularized_exafel_api_for_GPU(argchk=False, cuda_background=True)
  except ImportError:
    print(" - Skipped, no cuda module simtbx_gpu_ext found.")
  else:
    SIM4.to_smv_format(fileout="test_full_e_004.img")
    SIM4.to_cbf("test_full_e_004.cbf")
    diffs("CPU",SIM.raw_pixels, "GPU",SIM4.raw_pixels)

  from simtbx.kokkos import gpu_instance
  kokkos_run = gpu_instance(deviceId = 0)
  print("\n# Use case: modularized api argchk=False, cuda_background=True")
  SIM5 = SWC.modularized_exafel_api_for_KOKKOS(argchk=False, cuda_background=True)
  SIM5.to_smv_format(fileout="test_full_e_005.img")
  SIM5.to_cbf("test_full_e_005.cbf")
  diffs("CPU",SIM.raw_pixels, "KOKKOS",SIM5.raw_pixels)

  print("\n# Use case: modularized api argchk=True, cuda_background=True")
  SIM6 = SWC.modularized_exafel_api_for_KOKKOS(argchk=True, cuda_background=True)
  SIM6.to_smv_format(fileout="test_full_e_006.img")
  SIM6.to_cbf("test_full_e_006.cbf")
  diffs("CPU",SIM.raw_pixels, "KOKKOS",SIM6.raw_pixels)

print("OK")


 *******************************************************************************


 *******************************************************************************
simtbx/modeling/FormatHDF5AttributeGeometry.py
from __future__ import absolute_import, division

import numpy as np
import h5py
from copy import deepcopy
import ast

from dxtbx.format.FormatHDF5 import FormatHDF5
from dials.array_family import flex
from dxtbx.format.FormatStill import FormatStill
from dxtbx.model import Beam


class FormatHDF5AttributeGeometry(FormatHDF5, FormatStill):
    """
    Class for reading HDF5 files for arbitrary geometries
    focused on performance
    """
    @staticmethod
    def understand(image_file):
        try:
            img_handle = h5py.File(image_file, "r")
            keys = img_handle.keys()
        except (IOError, AttributeError) as err:
            return False
        if "images" not in keys:
            return False
        images = img_handle["images"]
        if "dxtbx_detector_string" not in images.attrs:
            return False
        if "dxtbx_beam_string" not in images.attrs:
            return False
        return True

    def _start(self):
        self._handle = h5py.File(self._image_file, "r")
        self.HAS_SPECTRUM_BEAM = False
        if hasattr(Beam, "set_spectrum"):
            self.HAS_SPECTRUM_BEAM = True
        self._image_dset = self._handle["images"]
        self._geometry_define()
        self._has_spectra = False
        self._has_central_wavelengths = False
        self._energies = None
        self._weights = None
        self._central_wavelengths = None
        self._check_per_shot_spectra()
        self._ENERGY_CONV = 12398.419739640716

    def _geometry_define(self):
        det_str = self._image_dset.attrs["dxtbx_detector_string"]
        beam_str = self._image_dset.attrs["dxtbx_beam_string"]
        try:
            det_str = det_str.decode()
            beam_str = beam_str.decode()
        except AttributeError:
            pass
        det_dict = ast.literal_eval(det_str)
        beam_dict = ast.literal_eval(beam_str)
        self._cctbx_detector = self._detector_factory.from_dict(det_dict)
        self._cctbx_beam = self._beam_factory.from_dict(beam_dict)

    def _check_per_shot_spectra(self):
        keys = list(self._handle.keys())
        has_energies = "spectrum_energies" in keys
        has_weights = "spectrum_weights" in keys
        has_central_wavelengths = "central_wavelengths" in keys
        if has_energies and has_weights:
            self._has_spectra = True
            self._energies = self._handle["spectrum_energies"]
            self._weights = self._handle["spectrum_weights"]
        elif has_central_wavelengths:
            self._has_central_wavelengths = True
            self._central_wavelengths = self._handle["central_wavelengths"]

    def get_num_images(self):
        return self._image_dset.shape[0]

    def get_raw_data(self, index=0):
        self.panels = self._image_dset[index]
        if self.panels.dtype == np.float64:
            flex_data = [flex.double(p) for p in self._image_dset[index]]
        else:
            flex_data = [flex.double(p.astype(np.float64)) for p in self._image_dset[index]]
        return tuple(flex_data)

    def get_detectorbase(self, index=None):
        raise NotImplementedError

    def get_detector(self, index=None):
        return self._cctbx_detector

    def _get_wavelength(self, index):
        if self._has_spectra:
            w = self._weights[index]
            E = self._energies[index]
            ave_E = (w*E).sum() / (w.sum())
            wavelength = self._ENERGY_CONV / ave_E
            if self.HAS_SPECTRUM_BEAM:
                self._w = w
                self._E = E
        elif self._has_central_wavelengths:
            wavelength = self._central_wavelengths[index]
        else:
            wavelength = None
        return wavelength

    def get_beam(self, index=0):
        beam = self._cctbx_beam
        wavelength = self._get_wavelength(index)
        if wavelength is not None:
            beam = deepcopy(self._cctbx_beam)
            beam.set_wavelength(wavelength)
        return beam


if __name__ == '__main__':
    import sys
    for arg in sys.argv[1:]:
        print(FormatHDF5AttributeGeometry.understand(arg))


 *******************************************************************************


 *******************************************************************************
simtbx/modeling/__init__.py


 *******************************************************************************


 *******************************************************************************
simtbx/modeling/forward_models.py
from __future__ import division
import os
import time
import logging
LOGGER = logging.getLogger("diffBragg.main")
import numpy as np
import pandas
from simtbx.nanoBragg.utils import flexBeam_sim_colors
from cctbx import miller
from cctbx.array_family import flex

try:
    from simtbx.gpu import gpu_energy_channels
except ImportError:
    gpu_energy_channels = None

from simtbx.diffBragg import utils
from dxtbx.model.experiment_list import ExperimentListFactory
multipanel_sim = None
try:
    from LS49.adse13_187.cyto_batch import multipanel_sim
except (ImportError, TypeError):
    pass
from simtbx.nanoBragg import utils as nanoBragg_utils
from simtbx.nanoBragg.nanoBragg_crystal import NBcrystal
from simtbx.nanoBragg.nanoBragg_beam import NBbeam
from simtbx.nanoBragg.sim_data import SimData


def panda_frame_from_exp(exp_name, detz_shift_mm=0, Ncells_abc=(30.,30.,30.), spot_scale=1., beamsize_mm=0.001,
                         total_flux=1e12, oversample=1,spectrum_fname=None, spectrum_stride=1, lam0=0, lam1=1):
    df = pandas.DataFrame({
        "opt_exp_name": [exp_name],
        "detz_shift_mm": [detz_shift_mm],
        "ncells": [Ncells_abc],
        "spot_scales": [spot_scale],
        "beamsize_mm": [beamsize_mm],
        "total_flux": [total_flux],
        "oversample": [oversample],
        "spectrum_filename": [spectrum_fname],
        "spectrum_stride": [spectrum_stride],
        "lam0": [lam0],
        "lam1": [lam1]})

    return df


def model_from_expt(exp_name,  model_spots_from_pandas_kwargs=None, panda_frame_from_exp_kwargs=None):
    if model_spots_from_pandas_kwargs is None:
        model_spots_from_pandas_kwargs = {}
    if panda_frame_from_exp_kwargs is None:
        panda_frame_from_exp_kwargs = {}
    df = panda_frame_from_exp(exp_name, **panda_frame_from_exp_kwargs)
    out = model_spots_from_pandas(df, **model_spots_from_pandas_kwargs)
    return out


# TODO name change
# TODO move all these arguments into the pandas dataFrame (mtz_col, from_pdb etc)
def model_spots_from_pandas(pandas_frame,  rois_per_panel=None,
                          mtz_file=None, mtz_col=None,
                          oversample_override=None,
                          Ncells_abc_override=None,
                          pink_stride_override=None,
                          spectrum_override=None,
                          cuda=False, device_Id=0, time_panels=False,
                          d_max=999, d_min=1.5, defaultF=1e3,
                          omp=False,
                          norm_by_spectrum=False,
                          symbol_override=None, quiet=False, reset_Bmatrix=False, nopolar=False,
                          force_no_detector_thickness=False, printout_pix=None, norm_by_nsource=False,
                          use_exascale_api=False, use_db=False, show_timings=False, perpixel_wavelen=False,
                          det_thicksteps=None, from_pdb=None):
    if perpixel_wavelen and not use_db:
        raise NotImplementedError("to get perpixel wavelengths set use_db=True to use the diffBragg backend")
    if use_exascale_api:
        assert gpu_energy_channels is not None, "cant use exascale api if not in a GPU build"
        assert multipanel_sim is not None, "cant use exascale api if LS49: https://github.com/nksauter/LS49.git  is not configured\n install in the modules folder"

    df = pandas_frame.reset_index(drop=True)

    if not quiet: LOGGER.info("Loading experiment models")
    expt_name = df.exp_name.values[0]
    El = ExperimentListFactory.from_json_file(expt_name, check_format=False)
    exp_idx = 0
    if "exp_idx" in list(df):
        exp_idx = int(df.exp_idx.values[0])  # cast to int because has to be 32-bit
    expt = El[exp_idx]
    crystal = expt.crystal
    crystal.set_A(df.Amats.values[0])
    expt.crystal = crystal
    columns = list(df)
    if "detz_shift_mm" in columns:  # NOTE, this could also be inside expt_name directly
        expt.detector = utils.shift_panelZ(expt.detector, df.detz_shift_mm.values[0])

    if force_no_detector_thickness:
        expt.detector = utils.strip_thickness_from_detector(expt.detector)
    if reset_Bmatrix:
        ucell_params = df[["a", "b", "c", "al", "be", "ga"]].values[0]
        ucell_man = utils.manager_from_params(ucell_params)
        expt.crystal.set_B(ucell_man.B_recipspace)
    assert len(df) == 1
    Ncells_abc = df.ncells.values[0]
    if Ncells_abc_override is not None:
        Ncells_abc = Ncells_abc_override
    Ncells_def = df.ncells_def.values[0]
    spot_scale = df.spot_scales.values[0]
    beamsize_mm = df.beamsize_mm.values[0]
    total_flux = df.total_flux.values[0]
    oversample = df.oversample.values[0]
    if oversample_override is not None:
        oversample = oversample_override

    # get the optimized spectra
    if spectrum_override is None:
        if "spectrum_filename" in list(df) and df.spectrum_filename.values[0] is not None:
            spectrum_file = df.spectrum_filename.values[0]
            pink_stride = df.spectrum_stride.values[0]
            if norm_by_spectrum:
                nspec = utils.load_spectra_file(spectrum_file)[0].shape[0]
                spot_scale = spot_scale / nspec
            if pink_stride_override is not None:
                pink_stride = pink_stride_override
            fluxes, energies = utils.load_spectra_file(spectrum_file, total_flux=total_flux,
                                                       pinkstride=pink_stride)
        else:
            fluxes = np.array([total_flux])
            energies = np.array([utils.ENERGY_CONV/expt.beam.get_wavelength()])
            if not quiet: LOGGER.info("Running MONO sim")

    else:
        wavelens, fluxes = map(np.array, zip(*spectrum_override))
        energies = utils.ENERGY_CONV / wavelens

    lam0 = df.lam0.values[0]
    lam1 = df.lam1.values[0]
    if lam0 == -1 or np.isnan(lam0):
        lam0 = 0
    if lam1 == -1 or np.isnan(lam1):
        lam1 = 1
    wavelens = utils.ENERGY_CONV / energies
    wavelens = lam0 + lam1*wavelens
    energies = utils.ENERGY_CONV / wavelens

    if mtz_file is not None:
        assert mtz_col is not None
        Famp = utils.open_mtz(mtz_file, mtz_col)
        Famp = miller.array(Famp.set(), data=flex.double(len(Famp.data()), np.mean(Famp.data())))
    elif from_pdb is not None and from_pdb.name is not None:
        wavelength=None
        if from_pdb.add_anom:
            wavelength = expt.beam.get_wavelength()
        miller_data = utils.get_complex_fcalc_from_pdb(from_pdb.name,
                                                 dmin=d_min,
                                                 dmax=d_max,
                                                 wavelength=wavelength,
                                                 k_sol=from_pdb.k_sol,
                                                 b_sol=from_pdb.b_sol)
        Famp = miller_data.as_amplitude_array()
    else:
        Famp = utils.make_miller_array_from_crystal(expt.crystal, dmin=d_min, dmax=d_max, defaultF=defaultF, symbol=symbol_override)

    diffuse_params = None
    if "use_diffuse_models" in columns and df.use_diffuse_models.values[0]:
        if not use_db:
            raise RuntimeError("Cant simulate diffuse models unless use_db=True (diffBragg modeler)")
        diffuse_params = {"gamma": tuple(df.diffuse_gamma.values[0]),
                          "sigma": tuple(df.diffuse_sigma.values[0]),
                          "gamma_miller_units": False}
        if "gamma_miller_units" in list(df):
            diffuse_params["gamma_miller_units"] = df.gamma_miller_units.values[0]


    if use_exascale_api:
        #===================
        gpu_channels_singleton = gpu_energy_channels(deviceId=0)
        print(gpu_channels_singleton.get_deviceID(), "device")
        from simtbx.nanoBragg import nanoBragg_crystal
        C = nanoBragg_crystal.NBcrystal(init_defaults=False)
        C.miller_array = Famp
        F_P1 = C.miller_array
        F_P1 = Famp.expand_to_p1()
        gpu_channels_singleton.structure_factors_to_GPU_direct(0, F_P1.indices(), F_P1.data())
        Famp = gpu_channels_singleton
        #===========
        results,_,_ = multipanel_sim(CRYSTAL=expt.crystal,
                                 DETECTOR=expt.detector,
                                 BEAM=expt.beam, Famp=Famp,
                                 energies=energies, fluxes=fluxes, Ncells_abc=Ncells_abc,
                                 beamsize_mm=beamsize_mm, oversample=oversample,
                                 spot_scale_override=spot_scale, default_F=0, interpolate=0,
                                 include_background=False,
                                 profile="gauss", cuda=True, show_params=False)
        return results, expt
    elif use_db:
        mos_dom = 1
        if "num_mosaicity_samples" in list(df):
            mos_dom = int(df.num_mosaicity_samples.values[0])
        eta_abc = df.eta_abc.values[0]
        LOGGER.debug("Num mos samples=%d, eta_abc=%f %f %f" % ((mos_dom,)+ eta_abc )  )
        LOGGER.debug("Num energy channels=%d" % len(energies))
        results = diffBragg_forward(CRYSTAL=expt.crystal, DETECTOR=expt.detector, BEAM=expt.beam, Famp=Famp,
                                    fluxes=fluxes, energies=energies, beamsize_mm=beamsize_mm,
                                    Ncells_abc=Ncells_abc, spot_scale_override=spot_scale,
                                    mos_dom=mos_dom, eta_abc=df.eta_abc.values[0],
                                    default_F=np.mean(Famp.data()),
                                    device_Id=device_Id, oversample=oversample,
                                    show_params=not quiet,
                                    nopolar=nopolar,
                                    printout_pix=printout_pix,
                                    diffuse_params=diffuse_params, cuda=cuda,
                                    show_timings=show_timings,
                                    perpixel_wavelen=perpixel_wavelen,
                                    det_thicksteps=det_thicksteps, Ncells_def=Ncells_def)
        return results, expt

    else:
        pids = None
        if rois_per_panel is not None:
            pids = list(rois_per_panel.keys()),
        results = flexBeam_sim_colors(CRYSTAL=expt.crystal, DETECTOR=expt.detector, BEAM=expt.beam, Famp=Famp,
                                      fluxes=fluxes, energies=energies, beamsize_mm=beamsize_mm,
                                      Ncells_abc=Ncells_abc, spot_scale_override=spot_scale,
                                      cuda=cuda, device_Id=device_Id, oversample=oversample,
                                      time_panels=time_panels and not quiet,
                                      pids=pids,
                                      rois_perpanel=rois_per_panel,
                                      omp=omp, show_params=not quiet,
                                      nopolar=nopolar,
                                      printout_pix=printout_pix)
        if norm_by_nsource:
            return np.array([image/len(energies) for _,image in results]), expt
        else:
            return np.array([image for _,image in results]), expt


def diffBragg_forward(CRYSTAL, DETECTOR, BEAM, Famp, energies, fluxes,
                      oversample=0, Ncells_abc=(50, 50, 50),
                      mos_dom=1, mos_spread=0, beamsize_mm=0.001, device_Id=0,
                      show_params=True, crystal_size_mm=None, printout_pix=None,
                      verbose=0, default_F=0, interpolate=0, profile="gauss",
                      spot_scale_override=None,
                      mosaicity_random_seeds=None,
                      nopolar=False, diffuse_params=None, cuda=False,
                      show_timings=False,perpixel_wavelen=False,
                      det_thicksteps=None, eta_abc=None, Ncells_def=None,
                      num_phi_steps=1, delta_phi=None, div_mrad=0, divsteps=0):

    if cuda:
        os.environ["DIFFBRAGG_USE_CUDA"] = "1"
    CRYSTAL, Famp = nanoBragg_utils.ensure_p1(CRYSTAL, Famp)

    nbBeam = NBbeam()
    nbBeam.divergence_mrad = div_mrad  # / 1e3 * 180 / np.pi
    nbBeam.divsteps = divsteps
    nbBeam.size_mm = beamsize_mm
    nbBeam.unit_s0 = BEAM.get_unit_s0()
    wavelengths = utils.ENERGY_CONV / np.array(energies)
    nbBeam.spectrum = list(zip(wavelengths, fluxes))

    nbCrystal = NBcrystal(init_defaults=False)
    nbCrystal.isotropic_ncells = False
    nbCrystal.dxtbx_crystal = CRYSTAL
    nbCrystal.miller_array = Famp
    nbCrystal.Ncells_abc = Ncells_abc
    nbCrystal.Ncells_def = Ncells_def
    nbCrystal.symbol = CRYSTAL.get_space_group().info().type().lookup_symbol()
    nbCrystal.thick_mm = crystal_size_mm
    nbCrystal.xtal_shape = profile
    nbCrystal.n_mos_domains = mos_dom
    nbCrystal.mos_spread_deg = mos_spread
    if eta_abc is not None:
        nbCrystal.anisotropic_mos_spread_deg = eta_abc

    S = SimData()
    S.detector = DETECTOR
    npan = len(DETECTOR)
    nfast, nslow = DETECTOR[0].get_image_size()
    img_shape = npan, nslow, nfast
    S.beam = nbBeam
    S.crystal = nbCrystal
    if mosaicity_random_seeds is not None:
        S.mosaic_seeds = mosaicity_random_seeds

    S.instantiate_diffBragg(verbose=verbose, oversample=oversample, interpolate=interpolate, device_Id=device_Id,
                            default_F=default_F,
                            auto_set_spotscale=crystal_size_mm is not None and spot_scale_override is None)

    if spot_scale_override is not None:
        S.update_nanoBragg_instance("spot_scale", spot_scale_override)
    S.update_nanoBragg_instance("nopolar", nopolar)
    if det_thicksteps is not None:
        S.update_nanoBragg_instance(
            "detector_thicksteps", det_thicksteps)

    if show_params:
        S.D.show_params()
        print("Spot scale=%f" % S.D.spot_scale)

    if show_timings and verbose < 2:
        S.D.verbose = 2
    S.D.store_ave_wavelength_image = perpixel_wavelen
    S.D.record_time = True
    if diffuse_params is not None:
        S.D.use_diffuse = True
        S.D.gamma_miller_units = diffuse_params["gamma_miller_units"]
        S.D.diffuse_gamma = diffuse_params["gamma"]
        S.D.diffuse_sigma = diffuse_params["sigma"]

    if delta_phi is not None:
        utils.update_SIM_with_gonio(S, delta_phi=delta_phi, num_phi_steps=num_phi_steps )
    S.D.add_diffBragg_spots_full()
    if show_timings or LOGGER.level <= 10:
        S.D.show_timings()
    t = time.time()
    data = S.D.raw_pixels_roi.as_numpy_array().reshape(img_shape)
    if perpixel_wavelen:
        wavelen_data = S.D.ave_wavelength_image().as_numpy_array().reshape(img_shape)
        hdata,kdata,ldata = map(lambda x:x.as_numpy_array().reshape(img_shape), S.D.ave_hkl_image())

    t = time.time() - t
    if show_timings:
        print("Took %f sec to recast and reshape" % t)
    if printout_pix is not None:
        S.D.raw_pixels_roi*=0
        p,f,s = printout_pix
        S.D.printout_pixel_fastslow = f,s
        S.D.show_params()
        S.D.add_diffBragg_spots(printout_pix)

    # free up memory
    S.D.free_all()
    S.D.free_Fhkl2()
    if S.D.gpu_free is not None:
        S.D.gpu_free()
    if perpixel_wavelen:
        return data, wavelen_data, hdata, kdata, ldata
    else:
        return data


if __name__ == "__main__":
    import sys
    from simtbx.diffBragg import hopper_utils
    df = pandas.read_pickle(sys.argv[1])
    max_prc = 1  #@int(sys.argv[2])
    exp_names = df.exp_name.unique()
    use_exa = True
    PFS = 40, 222, 192
    oo = 3 #None
    PFS = None
    CUDA= True

    if os.environ.get("DIFFBRAGG_USE_CUDA") is None:
        CUDA = False
    for exp_name in exp_names:
        df_exp = df.query("exp_name=='%s'" % exp_name)
        E = ExperimentListFactory.from_json_file(df_exp.exp_name.values[0])[0]
        spectrum = hopper_utils.spectrum_from_expt(E, 1e12)

        t = time.time()
        imgs,_ = model_spots_from_pandas(df_exp, force_no_detector_thickness=True, use_db=True, quiet=True,
                                     oversample_override=oo, nopolar=True, spectrum_override=spectrum)
        t = time.time() - t
        print("----------------------")

        t2 = time.time()
        imgs2,_ = model_spots_from_pandas(df_exp, force_no_detector_thickness=True, cuda=CUDA, quiet=True,
                                      oversample_override=oo, nopolar=True, spectrum_override=spectrum)#, oversample_override=1, nopolar=True, printout_pix=PFS)
        t2 = time.time()-t2
        print("----------------------")
        if np.allclose(imgs, imgs2):
            print("OK1")
        else:
            print("NOPE1")
        if not CUDA:
            exit()
        t3 = time.time()
        imgs3,_ = model_spots_from_pandas(df_exp, use_exascale_api=True, force_no_detector_thickness=True, quiet=True,
                                          oversample_override=oo, nopolar=True, spectrum_override=spectrum)
        t3 = time.time()-t3
        if np.allclose(imgs, imgs3):
            print("OK2")
        else:
            print("NOPE2")
        print("<><><><><><><><><><><><><><><><>")
        print("--------     RESULTS     -------")
        print("<><><><><><><><><><><><><><><><>")
        print("\t\tdiffBragg: %f" % t)
        print("\t\tlegacy: %f" % t2)
        print("\t\texascale: %f" % t3)

        exit()


 *******************************************************************************


 *******************************************************************************
simtbx/modeling/predictions.py
from __future__ import division

from simtbx.modeling.forward_models import model_spots_from_pandas
from simtbx.diffBragg.utils import refls_to_hkl, refls_from_sims
from dials.array_family import flex
from scipy.spatial import cKDTree, distance
from dials.algorithms.shoebox import MaskCode
SIGNAL_MASK = MaskCode.Valid + MaskCode.Foreground
import numpy as np
from numpy import logical_or as logi_or
from numpy import logical_and as logi_and
from dxtbx.model import ExperimentList
from numpy import logical_not as logi_not


def get_spot_wave(predictions, expt, wavelen_images):
    perSpotWave = flex.double()
    for i_sb, sb in enumerate(predictions['shoebox']):
        x1,x2,y1,y2,_,_ = sb.bbox
        pid = predictions[i_sb]['panel']
        assert x1 >= 0 and y1 >=0
        xdim, ydim = expt.detector[pid].get_image_size()
        assert x2 <= xdim and y2 <= ydim
        wavelen_subimg = wavelen_images[pid, y1:y2, x1:x2]
        where_signal  = sb.mask.as_numpy_array()[0] == SIGNAL_MASK
        wave_where_sig = wavelen_subimg[where_signal]
        assert not  np.any(np.isnan(wave_where_sig))
        ave_wave = wave_where_sig.mean()
        perSpotWave.append(ave_wave)
    return perSpotWave


def get_predicted_from_pandas(df, params, strong=None, eid='', device_Id=0, spectrum_override=None):
    """
    :param df: pandas dataframe, stage1_df attribute of simtbx.command_line.hopper_process.HopperProcess
    :param params: instance of diffBragg/phil.py phil params
    :param strong: strong (observed) reflections
    :param eid: experiment identifier, TODO: verify that the default is an empty string ''
    :param device_Id: GPU device Id for simulating forward model
    :param spectrum_override: the X-ray spectra to use during prediction
    :return: predicted reflections table, to be passed along to dials.integrate functions
    """
    mtz_file = mtz_col = None
    defaultF = params.predictions.default_Famplitude
    from_pdb = None

    if params.predictions.use_diffBragg_mtz:
        mtz_file = params.simulator.structure_factors.mtz_name
        mtz_col = params.simulator.structure_factors.mtz_column
        from_pdb = params.simulator.structure_factors.from_pdb
        defaultF = 0
    # returns the images and the experiment including any pre-modeling modifications (e.g. thinning out the detector)
    if "num_mosaicity_samples" not in list(df):
        df['num_mosaicity_samples'] = [params.simulator.crystal.num_mosaicity_samples]

    model_out = model_spots_from_pandas(
        df,
        oversample_override=params.predictions.oversample_override,
        Ncells_abc_override=params.predictions.Nabc_override,
        pink_stride_override=params.predictions.pink_stride_override,
        spectrum_override=spectrum_override,
        defaultF=defaultF,
        device_Id=device_Id,
        mtz_file=mtz_file, mtz_col=mtz_col,
        d_max=params.predictions.resolution_range[1],
        d_min=params.predictions.resolution_range[0],
        symbol_override=params.predictions.symbol_override,
        force_no_detector_thickness=params.simulator.detector.force_zero_thickness,
        use_exascale_api=params.predictions.method == "exascale",
        use_db=params.predictions.method == "diffbragg",
        show_timings=params.predictions.verbose,
        quiet=(not params.predictions.verbose),
        perpixel_wavelen=params.predictions.laue_mode,
        det_thicksteps=params.predictions.thicksteps_override,
        from_pdb=from_pdb)

    if not params.predictions.laue_mode:
        panel_images, expt = model_out
    else:
        (panel_images, wavelen_images), expt = model_out
    # NOTE:  panel-images contains per-pixel model, and wavelen_images contains per-pixel wavelength

    predictions = refls_from_sims(panel_images, expt.detector,
                                expt.beam, thresh=params.predictions.threshold,
                                max_spot_size=1000,
                                use_detect_peaks=params.predictions.use_peak_detection)
    print("Found %d Bragg peak predictions above the threshold" %len(predictions))

    # TODO: pulled these from comparing to a normal stills_process prediction table, not sure what they imply
    # TODO: multiple experiments per shot
    predictions['flags'] = flex.size_t(len(predictions), 1)
    predictions['id'] = flex.int(len(predictions), 0)
    predictions['entering'] = flex.bool(len(predictions), False)
    predictions['delpsical.rad'] = flex.double(len(predictions), 0)
    if eid:
        predictions.experiment_identifiers()[0] = eid

    El = ExperimentList()
    El.append(expt)
    predictions.centroid_px_to_mm(El)
    predictions.map_centroids_to_reciprocal_space(El)
    if params.predictions.laue_mode:
        # need to alter rlp according to wavelength ?
        predictions['rlp'] *= expt.beam.get_wavelength()
        predictions['ave_wavelen'] = get_spot_wave(predictions, expt, wavelen_images)
        predictions['rlp'] /= predictions['ave_wavelen']

    refls_to_hkl(predictions, expt.detector, expt.beam, expt.crystal, update_table=True)

    predictions['xyzcal.px'] = predictions['xyzobs.px.value']
    predictions['xyzcal.mm'] = predictions['xyzobs.mm.value']
    predictions["num_pixels"] = numpix = predictions["shoebox"].count_mask_values(SIGNAL_MASK)
    predictions['scatter'] = predictions["intensity.sum.value"] / flex.double(np.array(numpix, np.float64))

    if strong is None:
        return predictions

    strong.centroid_px_to_mm(El)
    strong.map_centroids_to_reciprocal_space(El)

    # separate out the weak from the strong
    label_weak_predictions(predictions, strong,params.predictions.qcut)
    n_weak = sum(predictions["is_weak"])
    predictions["is_strong"] = flex.bool(np.logical_not(predictions["is_weak"]))
    n_pred = len(predictions)
    n_strong = np.sum(predictions["is_strong"])
    print("%d / %d predicted refls are near strongs" % (n_strong, n_pred))

    label_weak_spots_for_integration(params.predictions.weak_fraction, predictions)
    print("Will use %d spots for integration" % sum(predictions["is_for_integration"]))
    predictions = predictions.select(predictions["is_for_integration"])

    return predictions, panel_images


def label_weak_predictions(predictions, strong, q_cutoff=0.005, col="rlp"):
    """
    :param predictions: model reflection table
    :param strong: strong observed spots (reflection table)
    :param q_cutoff: distance in RLP space or pixel space, depending on col - arbitrary, increasing will bring in more candidates, 0.005 seems reasonable
    :param col: column to read distances from, can be rlp or xyzobs.px.value
    """
    strong_tree = cKDTree(strong[col])
    predicted_tree = cKDTree(predictions[col])

    # for each strong refl, find all predictions within q_cutoff of the strong rlp
    pred_idx_candidates = strong_tree.query_ball_tree(predicted_tree, q_cutoff)

    is_weak = flex.bool(len(predictions), True)
    xyz_obs = [(-1,-1,-1)]*len(predictions)
    indexed_sel = flex.bool(np.zeros(len(strong), bool))
    miller_inds = flex.miller_index()
    xyz_cal_mm = flex.vec3_double()
    xyz_cal_px = flex.vec3_double()
    s1 =flex.vec3_double()
    for i_idx, cands in enumerate(pred_idx_candidates):
        if not cands:
            miller_inds.append([0,0,0])
            xyz_cal_mm.append((0,0,0))
            xyz_cal_px.append((0,0,0))
            s1.append((0,0,0))
            continue
        if len(cands) == 1:
            # if 1 spot is within q_cutoff , then its the closest
            pred_idx = cands[0]
        else:
            # in this case there are multiple predictions near the strong refl, we choose the closest one
            dists = []
            for c in cands:
                d = distance.euclidean(strong_tree.data[i_idx], predicted_tree.data[c])
                dists.append(d)
            pred_idx = cands[np.argmin(dists)]
        is_weak[pred_idx] = False
        xyz_obs[pred_idx] = strong["xyzobs.px.value"][i_idx]
        indexed_sel[i_idx] = True
        miller_inds.append(predictions["miller_index"][pred_idx])
        xyz_cal_mm.append(predictions["xyzcal.mm"][pred_idx])
        xyz_cal_px.append(predictions["xyzcal.px"][pred_idx])
        s1.append(predictions["s1"][pred_idx])
    predictions["is_weak"] = is_weak
    predictions["orig.xyzobs.px"] = flex.vec3_double(xyz_obs)
    strong['miller_index'] = miller_inds
    strong['xyzcal.mm'] = xyz_cal_mm
    strong['xyzcal.px'] = xyz_cal_px
    strong['entering'] = flex.bool(len(strong), False)
    strong['s1'] = s1
    strong.set_flags(indexed_sel, strong.flags.indexed)
    strong["indexed"] = indexed_sel


def label_weak_spots_for_integration(fraction, predictions, num_res_bins=10):
    """
    :param fraction: fraction of reflections to label as "integratable" within each resolution bin
    :param predictions: dials.flex.reflections_table
    :param num_res_bins: number of resolution bins
    """
    res = 1. / np.linalg.norm(predictions["rlp"], axis=1)
    res_sort = np.sort(res)
    res_bins = [rb[0]-1e-6 for rb in np.array_split( res_sort, num_res_bins)] + [res_sort[-1]+1e-6]
    res_bin_assigments = np.digitize(res, res_bins)
    is_weak_but_integratable = np.zeros(len(predictions)).astype(bool)
    for i_res in range(1, num_res_bins+1):
        # grab weak spots in this res bin
        is_weak_and_in_bin = logi_and(res_bin_assigments == i_res, predictions["is_weak"])
        refls_in_bin = predictions.select(flex.bool(is_weak_and_in_bin))
        if len(refls_in_bin)==0:
            continue

        # determine which weak spots are closer to the Ewald sphere, based on the scatter value
        signal_cutoff_in_bin = np.percentile(refls_in_bin['scatter'], (1.-fraction)*100)
        is_above_cutoff = predictions["scatter"] >= signal_cutoff_in_bin

        is_integratable = logi_and(is_weak_and_in_bin, is_above_cutoff)
        is_weak_but_integratable[is_integratable] = True
    predictions['is_for_integration'] = flex.bool(logi_or(logi_not(predictions["is_weak"]), is_weak_but_integratable))


def normalize_by_partiality(refls, model, default_F=1, gain=1):
    """
    :param refls: integrated refls output by the integrator.integrate() method in hopper_process / stills_process
    :param model: prediction intensities, output by the model_spots_from_pandas method
    :param default_F: value of the default structure factor used in the predictive model
    :param gain: detector ADU to photon factor
    :return: updated reflection table
    """
    nref = len(refls)
    F2 = default_F**2
    partials = flex.double()
    new_Isum = flex.double()
    new_Ivar = flex.double()
    for i_ref in range(nref):
        refl = refls[i_ref]
        sb = refl['shoebox']
        pid = refl['panel']
        mask = sb.mask.as_numpy_array()[0]
        data = sb.data.as_numpy_array()[0] / gain
        x1,x2,y1,y2,_,_ = sb.bbox
        was_integrated = mask == SIGNAL_MASK
        Y, X = np.where(was_integrated)
        Y += y1
        X += x1
        par = model[pid, Y, X] / F2
        good = par > 0
        corrected = (data[was_integrated] / par)[good]

        par_sum = par.sum()
        data_sum = corrected.sum()
        data_var = corrected.std()**2
        partials.append(par_sum)
        new_Isum.append(data_sum)
        new_Ivar.append(data_var)
    refls['dials.intensity.sum.value'] = refls['intensity.sum.value']
    refls['dials.intensity.sum.variance'] = refls['intensity.sum.variance']
    refls['diffBragg_partials'] = partials
    refls['intensity.sum.value'] = new_Isum
    refls['intensity.sum.variance'] = new_Ivar
    return refls


 *******************************************************************************


 *******************************************************************************
simtbx/nanoBragg/__init__.py
from __future__ import absolute_import, division, print_function
import boost_adaptbx.boost.python as bp
import cctbx.uctbx # possibly implicit
ext = bp.import_ext("simtbx_nanoBragg_ext")
from libtbx.phil import parse
from scitbx.array_family import flex
from simtbx_nanoBragg_ext import *
from scitbx.matrix import col, sqr
from cctbx import sgtbx
from cctbx.sgtbx.literal_description import literal_description

from dxtbx.imageset import MemReader
from dxtbx.imageset import ImageSet, ImageSetData
from dxtbx.model.experiment_list import Experiment, ExperimentList
from dxtbx.model import CrystalFactory
from dxtbx.model import BeamFactory
from dxtbx.model import DetectorFactory
from dxtbx.format.Format import Format
from dxtbx.format import cbf_writer, nxmx_writer
from cctbx import sgtbx
from cctbx.sgtbx.literal_description import literal_description
import numpy as np


@bp.inject_into(ext.nanoBragg)
class _():

  def __getattr__(self,name):
    """assemble miller array of structure factors used to compute spot intensities from the internal C cube array
       how do we specify docstrings for individual overriden members? """
    if name == "Fhkl":
      from cctbx.crystal import symmetry
      cs = symmetry(unit_cell = self.unit_cell_Adeg,space_group="P 1")
      from cctbx.miller import set, array
      indices,data = self.Fhkl_tuple
      mset = set(crystal_symmetry=cs, anomalous_flag=True, indices=indices)
      return array(mset, data=data).set_observation_type_xray_amplitude()

  def set_mosaic_blocks_sym(self, crystal, reference_symbol, orig_mos_domains, refining_eta=False):
    """
    hijack the mosaic blocks to symmetrize F_latt for P3/P6 space groups
    Will extend mosaic blocks by up to a factor of 3
    :param crystal:  dxtbx crystal model, preferably in the original setting (reference)
    :param symbol: space group loopk symbol e.g. P6522
    :param orig_mos_domains: int number of mosaic blocks before adding 3-fold mosaic blocks
    :param refining_eta: bool, if using diffBragg to refine eta, the umat derivative mats should also be updated
    """
    if refining_eta:
      # TODO, fix this case, see diffBragg.cpp, method get_mosaic_blocks_prime
      assert not self.has_anisotropic_spread

    sgi = sgtbx.space_group_info(reference_symbol)
    cb_op = sgi.change_of_basis_op_to_primitive_setting()
    # TODO? use internal nanoBragg parameters to get the p1 a,b,c vectors,
    # then use those to construct the crystal, then apply change of basis
    crystal_reference = crystal.change_basis(cb_op.inverse())

    # Get the real space Amatrix in the reference setting
    A = sqr(crystal_reference.get_A()).inverse().transpose()

    # this should be equivalent to column matrix of real space vectors
    a,b,c = crystal_reference.get_real_space_vectors()
    assert np.allclose(sqr(a+b+c).transpose().elems , A.elems)

    # get the originally set mosaic blocks
    mos_blocks = self.get_mosaic_blocks()[:orig_mos_domains]
    mos_blocks_prime = None
    if refining_eta:
      mos_blocks_prime = self.get_mosaic_blocks_prime()[:orig_mos_domains]

    # new list of mosaic blocks
    new_mos_blocks = flex.mat3_double()
    new_mos_blocks.extend(mos_blocks)

    # eta deriv matrices
    new_mos_blocks_prime = None
    if mos_blocks_prime is not None:
      new_mos_blocks_prime = flex.mat3_double()
      new_mos_blocks_prime.extend(mos_blocks_prime)

    # loop over all laue group 3-fold operations
    ops = sgi.group().build_derived_laue_group().all_ops()
    for op in ops:
      if op.r().determinant()==-1:
        continue
      descr = literal_description(op).long_form()
      if "3-fold" in descr:
        R = sqr(op.r().as_double())
        # we want to operate about the crystal basis hence we use A*R*A^-1
        Rcryst = A*R*A.inverse()
        # this will left-multiply the real space amatrix in nanoBragg / diffBragg
        new_mos_blocks.extend(flex.mat3_double([sqr(U)*Rcryst for U in mos_blocks]))
        if new_mos_blocks_prime is not None:
          #TODO does Umat_prime need to also be multiplied by Rcryst ?
          new_mos_blocks_prime.extend(flex.mat3_double([sqr(U) for U in mos_blocks_prime]))

    self.set_mosaic_blocks(new_mos_blocks)
    if new_mos_blocks_prime is not None:
      self.set_mosaic_blocks_prime(new_mos_blocks_prime)

    # if using diffBragg, we must also call:
    if self.vectorize_umats is not None:
      self.vectorize_umats()

    # need to update nanoBragg mos_spread_deg so it actually runs through the mosaic domains
    if self.mosaic_spread_deg == 0:
      self.mosaic_spread_deg = 1e-6

  def __setattr__(self,name,value):
    """use a P1 anomalous=True miller array to initialize the internal C cube array with structure factors for the spot intensities
       how do we specify docstrings for individual overriden members? """
    if name in ["Fhkl"]:
      value=value.expand_to_p1()
      value=value.generate_bijvoet_mates()
      assert value.space_group_info().type().lookup_symbol() == "P 1"
      # handle exception by expanding to P1
      assert value.anomalous_flag() == True
      # handle exception by copying all F(hkl) to F(-h-k-l)
      #assert values are amplitudes # not sure how to guarantee this
      self.unit_cell_Adeg = value.unit_cell()
      #self.mock_up_group = value.space_group()
      #self.mock_up_anomalous_flag = value.anomalous_flag()
      self.Fhkl_tuple = (value.indices(),value.data())
    else:
      super(ext.nanoBragg,self).__setattr__(name,value)

  def to_smv_format_py(self,fileout,intfile_scale=0.0,debug_x=-1,debug_y=-1,
    rotmat=False,extra=None,verbose=False,gz=False):

    byte_order = "little_endian";

    #recast the image file write to Python to afford extra options: rotmat, extra, gz
    if gz:
      from libtbx.smart_open import for_writing
      outfile = for_writing(file_name=fileout+".gz", gzip_mode="wb")
    else:
      outfile = open(fileout,"wb");

    outfile.write(("{\nHEADER_BYTES=1024;\nDIM=2;\nBYTE_ORDER=%s;\nTYPE=unsigned_short;\n"%byte_order).encode());
    outfile.write(b"SIZE1=%d;\nSIZE2=%d;\nPIXEL_SIZE=%g;\nDISTANCE=%g;\n"%(
      self.detpixels_fastslow[0],self.detpixels_fastslow[1],self.pixel_size_mm,self.distance_mm));
    outfile.write(b"WAVELENGTH=%g;\n"%self.wavelength_A);
    outfile.write(b"BEAM_CENTER_X=%g;\nBEAM_CENTER_Y=%g;\n"%self.beam_center_mm);
    outfile.write(b"ADXV_CENTER_X=%g;\nADXV_CENTER_Y=%g;\n"%self.adxv_beam_center_mm);
    outfile.write(b"MOSFLM_CENTER_X=%g;\nMOSFLM_CENTER_Y=%g;\n"%self.mosflm_beam_center_mm);
    outfile.write(b"DENZO_X_BEAM=%g;\nDENZO_Y_BEAM=%g;\n"%self.denzo_beam_center_mm);
    outfile.write(b"DIALS_ORIGIN=%g,%g,%g\n"%self.dials_origin_mm);
    outfile.write(b"XDS_ORGX=%g;\nXDS_ORGY=%g;\n"%self.XDS_ORGXY);
    outfile.write(b"CLOSE_DISTANCE=%g;\n"%self.close_distance_mm);
    outfile.write(b"PHI=%g;\nOSC_START=%g;\nOSC_RANGE=%g;\n"%(self.phi_deg,self.phi_deg,self.osc_deg));
    outfile.write(b"TIME=%g;\n"%self.exposure_s);
    outfile.write(b"TWOTHETA=%g;\n"%self.detector_twotheta_deg);
    outfile.write(b"DETECTOR_SN=000;\n");
    outfile.write(b"ADC_OFFSET=%g;\n"%self.adc_offset_adu);
    outfile.write(b"BEAMLINE=fake;\n");
    if rotmat:
      from scitbx.matrix import sqr
      RSABC = sqr(self.Amatrix).inverse().transpose()
      outfile.write( ("DIRECT_SPACE_ABC=%s;\n"%(",".join([repr(a) for a in RSABC.elems]))).encode() )
    if extra is not None:
      outfile.write(extra.encode())
    outfile.write(b"}\f");
    assert outfile.tell() < 1024, "SMV header too long, please edit this code and ask for more bytes."
    while ( outfile.tell() < 1024 ): outfile.write(b" ")
    from six import PY3
    if PY3:
      # Python3-compatible method for populating the output buffer.
      # Py2 implementation is more elegant in that the streambuf may be passed to C++,
      #   and the data are gzipped in chunks (default 1024). Py3 will not accept this method
      #   as it is PyString-based, with no converter mechanisms to bring data into PyBytes.
      # The Py3 method brings the full data in one chunk into PyBytes and then populates
      #   the output buffer in Python rather than C++.
      image_bytes = self.raw_pixels_unsigned_short_as_python_bytes(intfile_scale,debug_x,debug_y)
      ptr = 0; nbytes = len(image_bytes)
      while (ptr < nbytes): # chunked output necessary to prevent intermittent MemoryError
        outfile.write(image_bytes[ptr : min(ptr + 65536, nbytes)])
        ptr += 65536
      outfile.close();
      return
    from boost_adaptbx.boost.python import streambuf
    self.to_smv_format_streambuf(streambuf(outfile),intfile_scale,debug_x,debug_y)

    outfile.close();

  @property
  def beam(self):
    # Does this handle the conventions ? Im always confused about where the beam is pointing, whats s0 and whats beam_vector
    beam_dict = {'direction': self.beam_vector,
                  'divergence': 0.0,  # TODO
                  'flux': self.flux,
                  'polarization_fraction': self.polarization,  #TODO
                  'polarization_normal': col(self.polar_vector).cross(col(self.beam_vector)),
                  'sigma_divergence': 0.0,  # TODO
                  'transmission': 1.0,  #TODO ?
                  'wavelength': self.wavelength_A}
    beam = BeamFactory.from_dict(beam_dict)
    return beam

  @property
  def crystal(self):
    crystal = None
    # dxtbx crystal description
    if self.Amatrix is not None:
      A = sqr(self.Amatrix).inverse().elems
      # is this always P-1 ?
      real_a = A[0], A[3], A[6]
      real_b = A[1], A[4], A[7]
      real_c = A[2], A[5], A[8]
      cryst_dict = {'__id__': 'crystal',
                     'real_space_a': real_a,
                     'real_space_b': real_b,
                     'real_space_c': real_c,
                     'space_group_hall_symbol': ' P 1'}
      crystal = CrystalFactory.from_dict(cryst_dict)
    return crystal

  @property
  def detector(self):
    # monolithic camera description
    pixsize = self.pixel_size_mm
    im_shape = self.detpixels_fastslow
    fdet = self.fdet_vector
    sdet = self.sdet_vector
    origin = self.dials_origin_mm
    det_descr = {'panels':
                   [{'fast_axis': fdet,
                     'slow_axis': sdet,
                     'gain': 1, # this should always be 1 for simulations. If you ran add_noise then quantum gain was multiplied
                     'identifier': '',
                     'image_size': im_shape,
                     'mask': [],
                     'material': 'Si',
                     'mu': 0.0,  # TODO
                     'name': 'Panel',
                     'origin': origin,
                     'pedestal': 0.0,
                     'pixel_size': (pixsize, pixsize),
                     'px_mm_strategy': {'type': 'SimplePxMmStrategy'},
                     'raw_image_offset': (0, 0),
                     'thickness': 0.00001,  # TODO
                     'trusted_range': (-1e3, 1e10),  # TODO
                     'type': ''}]}
    detector = DetectorFactory.from_dict(det_descr)
    return detector

  @property
  def imageset(self):
    if self.cbf_int:
      raw_pix = self.raw_pixels.as_numpy_array()
      raw_pix = flex.int(raw_pix.astype(np.int32))
    else:
      raw_pix = self.raw_pixels

    format_class = FormatBraggInMemory(raw_pix)
    reader = MemReaderNamedPath("virtual_Bragg_path", [format_class])
    reader.format_class = FormatBraggInMemory
    imageset_data = ImageSetData(reader, None, vendor="", params={'raw_pixels': raw_pix},
                                 format=FormatBraggInMemory)
    imageset = ImageSet(imageset_data)
    imageset.set_beam(self.beam)
    imageset.set_detector(self.detector)

    return imageset

  def as_explist(self, fname=None, toggle_conventions=False):
    """
    return experiment list for simulated image
    """
    C = self.crystal
    if toggle_conventions:
      # switch to DIALS convention before writing CBF
      # also change basis of crystal
      CURRENT_CONV = self.beamcenter_convention
      FSO = sqr(self.fdet_vector + self.sdet_vector + self.pix0_vector_mm)
      self.beamcenter_convention=DIALS
      FSO2 = sqr(self.fdet_vector + self.sdet_vector + self.dials_origin_mm)
      xtal_transform = FSO.inverse()*FSO2

      # transform the crystal vectors
      a,b,c = map(lambda x: xtal_transform*col(x) , C.get_real_space_vectors())
      Cdict = C.to_dict()
      Cdict['real_space_a'] = a
      Cdict['real_space_b'] = b
      Cdict['real_space_b'] = c
      C = CrystalFactory.from_dict(Cdict)

    exp = Experiment()
    exp.crystal = C
    exp.beam = self.beam
    exp.detector = self.detector
    exp.imageset = self.imageset
    explist = ExperimentList()
    explist.append(exp)
    if fname is not None:
        explist.as_file(fname)
    if toggle_conventions:
      self.beamcenter_convention=CURRENT_CONV

    return explist

  def to_cbf(self, cbf_filename, toggle_conventions=False, intfile_scale=1.0, cbf_int=False):
    """write a CBF-format image file to disk from the raw pixel array
    intfile_scale: multiplicative factor applied to raw pixels before output
         intfile_scale > 0 : value of the multiplicative factor
         intfile_scale = 1 (default): do not apply a factor
         intfile_scale = 0 : compute a reasonable scale factor to set max pixel to 55000; given by get_intfile_scale()
    cbf_int: boolean flag, write the cbf using 32-bit int precision
    """
    temp = self.cbf_int
    self.cbf_int = cbf_int

    if intfile_scale != 1.0:
      cache_pixels = self.raw_pixels
      if intfile_scale > 0: self.raw_pixels = self.raw_pixels * intfile_scale
      else: self.raw_pixels = self.raw_pixels * self.get_intfile_scale()
      # print("switch to scaled")

    if toggle_conventions:
      # switch to DIALS convention before writing CBF
      CURRENT_CONV = self.beamcenter_convention
      self.beamcenter_convention=DIALS

    imgset = self.imageset
    writer = cbf_writer.FullCBFWriter(imageset=imgset)
    cbf = writer.get_cbf_handle(index=0, header_only=True)
    data = imgset.get_raw_data(0)
    writer.add_data_to_cbf(cbf, data=data)
    writer.write_cbf(cbf_filename, cbf=cbf)

    if toggle_conventions:
      self.beamcenter_convention=CURRENT_CONV

    if intfile_scale != 1.0:
      self.raw_pixels = cache_pixels
      # print("switch back to cached")

    self.cbf_int = temp

  def to_nexus_nxmx(self, nxmx_filename, toggle_conventions=False, intfile_scale=1.0):
    """write a NeXus NXmx-format image file to disk from the raw pixel array
    intfile_scale: multiplicative factor applied to raw pixels before output
         intfile_scale > 0 : value of the multiplicative factor
         intfile_scale = 1 (default): do not apply a factor
         intfile_scale = 0 : compute a reasonable scale factor to set max pixel to 55000; given by get_intfile_scale()"""

    if intfile_scale != 1.0:
      cache_pixels = self.raw_pixels
      if intfile_scale > 0: self.raw_pixels = self.raw_pixels * intfile_scale
      else: self.raw_pixels = self.raw_pixels * self.get_intfile_scale()
      # print("switch to scaled")

    if toggle_conventions:
      # switch to DIALS convention before writing CBF
      CURRENT_CONV = self.beamcenter_convention
      self.beamcenter_convention=DIALS

    params = nxmx_writer.phil_scope.fetch(parse("""
    output_file=%s
    nexus_details {
      instrument_name=nanoBragg
      source_name=nanoBragg
      start_time=NA
      end_time_estimated=NA
      sample_name=nanoBragg
    }
    """%nxmx_filename)).extract()
    writer = nxmx_writer.NXmxWriter(params)
    writer(imageset=self.imageset)

    if toggle_conventions:
      self.beamcenter_convention=CURRENT_CONV

    if intfile_scale != 1.0:
      self.raw_pixels = cache_pixels
      # print("switch back to cached")

def nexus_factory(nxmx_filename):
    params = nxmx_writer.phil_scope.fetch(parse("""
    output_file=%s
    nexus_details {
      instrument_name=nanoBragg
      source_name=nanoBragg
      start_time=NA
      end_time_estimated=NA
      sample_name=nanoBragg
    }
    dtype=int32
    """%nxmx_filename)).extract()
    writer = nxmx_writer.NXmxWriter(params)
    return writer


def make_imageset(data, beam, detector):
  format_class = FormatBraggInMemoryMultiPanel(data)
  reader = MemReaderNamedPath("virtual_Bragg_path", [format_class])
  reader.format_class = FormatBraggInMemory
  imageset_data = ImageSetData(reader, None)
  imageset = ImageSet(imageset_data)
  imageset.set_beam(beam)
  imageset.set_detector(detector)
  return imageset

class FormatBraggInMemoryMultiPanel:

  def __init__(self, raw_pixels_lst):
    if not isinstance(raw_pixels_lst[0], flex.double):
      raw_pixels_lst = [flex.double(data) for data in raw_pixels_lst]
    self.raw_pixels_panels = tuple(raw_pixels_lst)
    panel_shape = self.raw_pixels_panels[0].focus()
    self.mask = tuple([flex.bool(flex.grid(panel_shape), True)]*len(self.raw_pixels_panels) )  # TODO: use nanoBragg internal mask

  def get_path(self, index):
    if index == 0:
      return "Virtual"
    else:
      raise ValueError("index must be 0 for format %s" % self.__name__)

  def get_raw_data(self):
    """
    return as a tuple, multi panel with 1 panel
    currently nanoBragg doesnt support simulating directly to a multi panel detector
    so this is the best we can do..
    """
    return self.raw_pixels_panels

  def get_mask(self, goniometer=None):
    """dummie place holder for mask, consider using internal nanoBragg mask"""
    return self.mask

class FormatBraggInMemory(Format):

  def __init__(self, raw_pixels):
    self.raw_pixels = raw_pixels
    panel_shape = self.raw_pixels.focus()
    #self._filenames = ["InMemoryBraggPath"]  # TODO: CBFLib complains if no datablock path provided which comes from path
    self.mask = flex.bool(flex.grid(panel_shape), True)  # TODO: use nanoBragg internal mask

  def get_path(self, index):
    if index == 0:
      return "Virtual"
    else:
      raise ValueError("index must be 0 for format %s" % self.__name__)

  def get_raw_data(self):
    """
    return as a tuple, multi panel with 1 panel
    currently nanoBragg doesnt support simulating directly to a multi panel detector
    so this is the best we can do..
    """
    return self.raw_pixels,

  def get_mask(self, goniometer=None):
    """dummie place holder for mask, consider using internal nanoBragg mask"""
    return self.mask,

  @classmethod
  def get_instance(Class, filename, **kwargs):
    return Class(raw_pixels = kwargs.pop('raw_pixels'), **kwargs)

  #def paths(self):
  #  return ["InMemoryBraggPath"]  # TODO: CBFLib complains if no datablock path provided which comes from path

class MemReaderNamedPath(MemReader):

  def __init__(self, path,  *args, **kwargs):
    self.dummie_path_name = path
    super(MemReaderNamedPath, self).__init__(*args, **kwargs)

  def paths(self):
    """Necessary to have non zero string for CBFLib writer for some reason..."""
    return ["%s_%d" % (self.dummie_path_name, i) for i, _ in enumerate(self._images)]


 *******************************************************************************


 *******************************************************************************
simtbx/nanoBragg/anisotropic_mosaicity.py
from __future__ import division
import random
from scipy import special

try:
    from collections.abc import Iterable
except ModuleNotFoundError:
    from collections import Iterable

import numpy as np
from simtbx.nanoBragg.tst_gaussian_mosaicity2 import check_distributions
from scitbx.matrix import sqr, col

def search_directions(N=1000):
    """
    See Journal of Magnetic Resonance 138, 288–297 (1999)
    equation A6
    :param N: number of points on hemisphere
    :return: Nx3 numpy array of unit vectors
    """
    ti = (np.arange(1, N+1) - 0.5) / N
    THETA = np.arccos(ti)
    PHI = np.sqrt(np.pi*N) * np.arcsin(ti)

    u_vecs = np.zeros((N, 3))
    x = np.sin(THETA) * np.cos(PHI)
    y = np.sin(THETA) * np.sin(PHI)
    z = np.cos(THETA)
    u_vecs[:N, 0] = x
    u_vecs[:N, 1] = y
    u_vecs[:N, 2] = z

    return u_vecs


def _compute(rot_ax, ang_idx, eta_eff, Cvec, derivs=None, second_derivs=None):
    """

    :param rot_ax: scitbx.matrix.col rotation axis
    :param ang_idx: list of indices corresponding to uniform samplings of the cummulative distribution function
    :param eta_eff: float, effective mosaicity in degrees
    :param Cvec: scitbx.matrix.col the vector of rotation axis along the projects
    :param derivs: list of d_etaEffective_d_eta derivative tensors , should be len 1 for isotropic models, else len 3
    :param second_derivs: same as derivs, yet dsquared_detaEffecitve_d_eta_squared
    :return: Umatrices, and there first and second derivatives w.r.t. eta
    """
    # store positive and negative rotation matrices in a list
    Us, Uprimes, Udblprimes = [],[],[]

    # rotation amount
    factor = np.sqrt(2) * special.erfinv(ang_idx) * np.pi / 180.
    rot_ang = eta_eff * factor

    # first derivatives
    if derivs is not None:
        d_theta_d_eta = []
        dsquared_theta_d_eta_squared = []
        common_term = -(0.5 *eta_eff**3) * factor
        for d, d2 in zip(derivs, second_derivs):
            G = np.dot(Cvec, np.dot(d, Cvec))
            d_theta_d_eta.append(common_term*G)

            G2 = np.dot(Cvec, np.dot(d2, Cvec))
            dsquared_theta_d_eta_squared.append(common_term*(-1.5* eta_eff**2 * G**2 + G2))

    # do for both postivie and negative rotations for even distribution of Umats
    for rot_sign in [1, -1]:
        U = rot_ax.axis_and_angle_as_r3_rotation_matrix(rot_sign*rot_ang, deg=False)
        Us.append(U)

        if derivs is not None:
            dU_d_theta = rot_ax.axis_and_angle_as_r3_derivative_wrt_angle(rot_sign*rot_ang, deg=False) # 1st deriv
            d2U_d_theta2 = rot_ax.axis_and_angle_as_r3_derivative_wrt_angle(rot_sign*rot_ang, deg=False, second_order=True)  # second deriv
            for d, d2 in zip(d_theta_d_eta, dsquared_theta_d_eta_squared):
                dU_d_eta = dU_d_theta*(rot_sign*d)
                d2U_d_eta2 = d2U_d_theta2*(d**2) + dU_d_theta*(rot_sign*d2)
                Uprimes.append(dU_d_eta)
                Udblprimes.append(d2U_d_eta2)

    return Us, Uprimes, Udblprimes


class AnisoUmats:

    def __init__(self, num_random_samples=500, seed=8675309):
        """
        num_random_samples, number of mosaic domain umatrices to generate with generate_Umats method (should be even)
        seed, random seed used for permuting the 1-to-1 rotation axis / rotation angle mapping
        """
        if num_random_samples %2 == 1:
            raise ValueError("Num random samples should be an even number")
        Nrand = int(num_random_samples/2)
        self.hemisph_samples = search_directions(Nrand)
        R = random.Random()
        R.seed(seed)
        self.angle_indices = [float(i) / Nrand for i in range(Nrand)]
        R.shuffle(self.angle_indices)

    def generate_Umats(self, eta, crystal=None, transform_eta=False,
                       how=1, compute_derivs=True, verbose=False ):
        """
        :param eta: float or 3-tuple specfying the mosaicity in degrees
        :param crystal: dxtbx crystal model
        :param transform_eta: bool, if True, then form an eta tensor that uses the
        crystal axes as its basis (experimental, not sure if its correct)
        references:
        https://en.wikipedia.org/wiki/Ellipsoid#As_a_quadric
        https://math.stackexchange.com/a/1119690/721977

        :param num_axes: how many points to sample the unit hemisphere with
        :param num_angles_per_axis:  produces 2x this number of angles per axes to sample the angle distribution
        :param how: if 0, then do the full treatment (6 Umat derivatives)
                    if 1, then do the diagonal only (3 Umat derivatives)
                    if 2, then there is no anisotropy (1 Umat derivative)
        :param num_random_samples, if an integer, ignore num_axes and num_angles_per_axis and
            use this number to generate random samples
        :param compute_derivs, boolean, if False, only compute the Umats
        :return:
        """
        if how==0:
            raise NotImplementedError("Still working out details and use cases for 6-parameter mosaicity model.")

        if isinstance(eta, Iterable):
            assert len(eta) == 3
            eta_a, eta_b, eta_c = eta
        else:
            if not how==2:
                raise ValueError("passing in a float for eta assumes how=2 (isotropic model)")
            eta_a = eta_b = eta_c = eta

        eta_tensor = np.diag(1./np.array([eta_a, eta_b, eta_c])**2)

        if how==1 and transform_eta:
            a,b,c = map(lambda x: col(x).normalize(), crystal.get_real_space_vectors())
            # S is a matrix whose columns are a,b,c
            S = np.reshape( sqr(a.elems+b.elems+c.elems).transpose(), (3,3))
            Sinv = np.linalg.inv(S)
            # re-write eta_tensor in crystal basis ?
            eta_tensor = np.dot(S, np.dot(eta_tensor, Sinv))

        if how==1:
            d_eta_tensor_a = np.diag([-2*eta_a**-3,0,0])
            d_eta_tensor_b = np.diag([0,-2*eta_b**-3,0])
            d_eta_tensor_c = np.diag([0,0, -2*eta_c**-3])
            if transform_eta:
                d_eta_tensor_a = np.dot(S, np.dot(d_eta_tensor_a, Sinv))
                d_eta_tensor_b = np.dot(S, np.dot(d_eta_tensor_b, Sinv))
                d_eta_tensor_c = np.dot(S, np.dot(d_eta_tensor_c, Sinv))
            derivs = d_eta_tensor_a, d_eta_tensor_b, d_eta_tensor_c

            d2_eta_tensor_a = np.diag([6*eta_a**-4,0,0])
            d2_eta_tensor_b = np.diag([0,6*eta_b**-4,0])
            d2_eta_tensor_c = np.diag([0,0,6*eta_c**-4])
            if transform_eta:
                d2_eta_tensor_a = np.dot(S, np.dot(d2_eta_tensor_a, Sinv))
                d2_eta_tensor_b = np.dot(S, np.dot(d2_eta_tensor_b, Sinv))
                d2_eta_tensor_c = np.dot(S, np.dot(d2_eta_tensor_c, Sinv))
            second_derivs = d2_eta_tensor_a, d2_eta_tensor_b, d2_eta_tensor_c
        elif how==2:
            # eta_a = eta_b = eta_c
            derivs = [np.diag([-2*eta_a**-3]*3)]
            second_derivs = [np.diag([6*eta_a**-4]*3)]

        all_U = []
        all_Uprime = []
        all_Udblprime = []
        for i, pt in enumerate(self.hemisph_samples):
            rot_ax = col(pt)
            C = rot_ax

            # effective mosaic rotation dependent on eta tensor
            C_eta_C = np.dot(C, np.dot(eta_tensor, C))
            # NOTE: added in the abs to protect sqrt, prob doesnt matter since we sample +- rotation for every axis...
            eta_eff = 1/np.sqrt(np.abs(C_eta_C))

            ang_idx = self.angle_indices[i]
            U, Up, Udp = _compute(rot_ax, ang_idx, eta_eff, C,
                                  derivs=derivs if compute_derivs else None,
                                  second_derivs=second_derivs if compute_derivs else None)
            all_U += U
            if compute_derivs:
                all_Uprime += Up
                all_Udblprime += Udp

        if compute_derivs and how == 1:
            assert 3 * len(all_U) == len(all_Uprime) == len(all_Udblprime)
        elif compute_derivs and how == 2:
            assert len(all_U) == len(all_Uprime) == len(all_Udblprime)

        if verbose:
            nm_angles = check_distributions.get_angular_rotation(all_U)
            nm_rms_angle = np.sqrt(np.mean(nm_angles * nm_angles))
            print("Normal rms angle is ", nm_rms_angle)

        return all_U, all_Uprime, all_Udblprime


 *******************************************************************************


 *******************************************************************************
simtbx/nanoBragg/brunger_example/run_example.py
from __future__ import absolute_import, division, print_function
from scitbx.array_family import flex # import dependency
from simtbx.nanoBragg import shapetype
from simtbx.nanoBragg import convention
from simtbx.nanoBragg import nanoBragg
import libtbx.load_env # possibly implicit
from cctbx import crystal

import os

# allow command-line options
GOFAST = False
import sys
if len(sys.argv)>1:
  if sys.argv[1] == "fast":
    print("SPEEDING UP! ")
    GOFAST = True


# get the structure factor of spots
mtzfile = "model_nophase.mtz"
stolfile = "./bg.stol"
imgfile = "./F4_0_00008.mccd.gz"

# get stuff from the web if we have to
if not os.path.isfile(mtzfile):
  from six.moves import urllib
  url = "http://bl831.als.lbl.gov/~jamesh/simtbx/"+mtzfile
  urllib.request.urlretrieve(url, mtzfile)

if not os.path.isfile(stolfile):
  from six.moves import urllib
  url = "http://bl831.als.lbl.gov/~jamesh/simtbx/bg.stol"
  urllib.request.urlretrieve(url, stolfile)

if not os.path.isfile(imgfile):
  from six.moves import urllib
  url = "http://bl831.als.lbl.gov/~jamesh/simtbx/"+imgfile
  urllib.request.urlretrieve(url, imgfile)

# make sure we got everything we need
assert os.path.isfile(mtzfile)
assert os.path.isfile(stolfile)
assert os.path.isfile(imgfile)

# read in structure factor amplitudes
from iotbx.reflection_file_reader import any_reflection_file
mtz_file = any_reflection_file(mtzfile)
Fhkl = mtz_file.as_miller_arrays()[0]

# get the structure factors of the background
Fbg_vs_stol = []
with open(stolfile, "rb") as fp:
  for i in fp.readlines():
    tmp = i.split(" ")
    try:
      Fbg_vs_stol.append((float(tmp[0]), float(tmp[1])))
    except Exception:pass
# now Fbg_vs_stol is a list of stol,Fbg tuples

# open the existing diffraction image: we need it for the background profile
import dxtbx
img = dxtbx.load(imgfile)
panel = img.get_detector()[0]
pixel_size_mm = panel.get_pixel_size[0]
distance_mm = panel.get_distance()
#beam_center_mm =

# create the simulation
SIM = nanoBragg(img.get_detector(),img.get_beam(),verbose=6)

#SIM = nanoBragg(detpixels_slowfast=(4096,4096),pixel_size_mm=0.079346,verbose=9)
SIM.Fhkl = Fhkl
SIM.Fbg_vs_stol = Fbg_vs_stol

print(SIM.Fbg_vs_stol[1])
SIM.Fbg_vs_stol[1]=(0,0)
print(SIM.Fbg_vs_stol[1])
SIM.Fbg_vs_stol[1]=(0,0)
print(SIM.Fbg_vs_stol[1])

#from IPython import embed
#embed()


blarg = SIM.Fbg_vs_stol
blarg[1] = (0,0)

SIM.Fbg_vs_stol = blarg
print(SIM.Fbg_vs_stol[1])

# sigh, just keep going...
#exit()

print("beam_center_mm=",SIM.beam_center_mm)
print("XDS_ORGXY=",SIM.XDS_ORGXY)
print("detector_pivot=",SIM.detector_pivot)
print("beamcenter_convention=",SIM.beamcenter_convention)
print("fdet_vector=",SIM.fdet_vector)
print("sdet_vector=",SIM.sdet_vector)
print("odet_vector=",SIM.odet_vector)
print("beam_vector=",SIM.beam_vector)
print("polar_vector=",SIM.polar_vector)
print("spindle_axis=",SIM.spindle_axis)
print("twotheta_axis=",SIM.twotheta_axis)
print("distance_meters=",SIM.distance_meters)
print("distance_mm=",SIM.distance_mm)
print("close_distance_mm=",SIM.close_distance_mm)
print("detector_twotheta_deg=",SIM.detector_twotheta_deg)
print("detsize_fastslow_mm=",SIM.detsize_fastslow_mm)
print("detpixels_fastslow=",SIM.detpixels_fastslow)
print("detector_rot_deg=",SIM.detector_rot_deg)
print("curved_detector=",SIM.curved_detector)
print("pixel_size_mm=",SIM.pixel_size_mm)
print("point_pixel=",SIM.point_pixel)
print("polarization=",SIM.polarization)
print("nopolar=",SIM.nopolar)
print("oversample=",SIM.oversample)
print("region_of_interest=",SIM.region_of_interest)
print("wavelength_A=",SIM.wavelength_A)
print("energy_eV=",SIM.energy_eV)
print("fluence=",SIM.fluence)
print("flux=",SIM.flux)
print("exposure_s=",SIM.exposure_s)
print("beamsize_mm=",SIM.beamsize_mm)
print("dispersion_pct=",SIM.dispersion_pct)
print("dispsteps=",SIM.dispsteps)
print("divergence_hv_mrad=",SIM.divergence_hv_mrad)
print("divsteps_hv=",SIM.divsteps_hv)
print("divstep_hv_mrad=",SIM.divstep_hv_mrad)
print("round_div=",SIM.round_div)
print("phi_deg=",SIM.phi_deg)
print("osc_deg=",SIM.osc_deg)
print("phisteps=",SIM.phisteps)
print("phistep_deg=",SIM.phistep_deg)
print("detector_thick_mm=",SIM.detector_thick_mm)
print("detector_thicksteps=",SIM.detector_thicksteps)
print("detector_thickstep_mm=",SIM.detector_thickstep_mm)
print("mosaic_spread_deg=",SIM.mosaic_spread_deg)
print("mosaic_domains=",SIM.mosaic_domains)
print("indices=",SIM.indices)
print("amplitudes=",SIM.amplitudes)
print("Fhkl_tuple=",SIM.Fhkl_tuple)
print("default_F=",SIM.default_F)
print("interpolate=",SIM.interpolate)
print("integral_form=",SIM.integral_form)

# modify things that are missing, or not quite right in the header
SIM.close_distance_mm=299.83
SIM.wavelength_A=1.304735
SIM.polarization=0.99
SIM.beamsize_mm=0.03
#SIM.fluence=4.28889e+18
# fluence scaled to make crystal look bigger
SIM.fluence=1.03e+27
SIM.beamcenter_convention=convention.Custom
SIM.beam_center_mm=( 160.53, 182.31 )
SIM.dispersion_pct = 0.5
SIM.dispsteps=6
print("dispsteps=",SIM.dispsteps)
SIM.divergence_hv_mrad = ( 0.02, 0.02 )
SIM.divsteps_hv = ( 2 , 2 )
print(SIM.divsteps_hv)
SIM.round_div=True
print(SIM.divsteps_hv)
#SIM.detector_thick_mm = 0.037
SIM.detector_thick_mm = 0.
SIM.detector_thicksteps = 1
# override mtz unit cell
SIM.unit_cell_tuple = ( 68.78, 169.26, 287.42, 90, 90, 90 )
#SIM.Ncells_abc = ( 1, 1, 1 )
SIM.Ncells_abc = ( 14, 6, 4 )
#SIM.Ncells_abc = ( 35, 15, 10 )
print("Ncells_abc=",SIM.Ncells_abc)
SIM.xtal_shape=shapetype.Tophat
print("xtal_size_mm=",SIM.xtal_size_mm)
SIM.interpolate=0
SIM.progress_meter=True
SIM.mosaic_spread_deg = 0.2
SIM.mosaic_domains = 30
SIM.oversample = 1
SIM.detector_psf_type=shapetype.Fiber
SIM.adc_offset_adu = 10
SIM.readout_noise_adu = 1.5

SIM.show_sources()

# speedups, comment out for realism
if GOFAST:
  SIM.divergence_hv_mrad = ( 0,0 )
  SIM.dispersion_pct = 0
  SIM.mosaic_spread_deg = 0
    # set this to 0 or -1 to trigger automatic radius.  could be very slow with bright images
  SIM.detector_psf_kernel_radius_pixels=5;

# use one pixel for diagnostics?
SIM.printout_pixel_fastslow=(1782,1832)
# debug only a little patch
#SIM.region_of_interest=((1450,1850),(1550,1950))

SIM.amorphous_sample_thick_mm = 0.1
SIM.amorphous_density_gcm3 = 7e-7
SIM.amorphous_sample_molecular_weight_Da = 18 # default


# load in the real image so we can extract the background
SIM.raw_pixels = img.get_raw_data().as_double()
#print SIM.Fbg_vs_stol[100]
SIM.extract_background()
#print SIM.Fbg_vs_stol[100]

# maybe edit background trace here?
# or, forget it, reset to old one:
SIM.Fbg_vs_stol = Fbg_vs_stol

# now clear the pixels
SIM.raw_pixels*=0;

print("dispsteps=",SIM.dispsteps)
print("divsteps=",SIM.divsteps_hv)
print("oversample=",SIM.oversample)
SIM.add_background(oversample=1,source=0)
print("mid_sample=",SIM.raw_pixels[1782,1832])
print("dispsteps=",SIM.dispsteps)
print("divsteps=",SIM.divsteps_hv)
print("oversample=",SIM.oversample)
SIM.to_smv_format(fileout="intimage_001.img",intfile_scale=1)

# three clusters of mosaic domains
if GOFAST == False:
  SIM.fluence /= 3
  SIM.missets_deg = ( 96.9473, -52.0932, -32.518 )
  #SIM.missets_deg = ( 96.544, -51.9673, -32.4243 )
  SIM.add_nanoBragg_spots()
  SIM.to_smv_format(fileout="intimage_002.img",intfile_scale=1)
  SIM.missets_deg = ( 97.5182, -52.3404, -32.7289 )
  SIM.add_nanoBragg_spots()
  SIM.to_smv_format(fileout="intimage_003.img",intfile_scale=1)

SIM.missets_deg = ( 97.1251, -52.2242, -32.751 )
SIM.add_nanoBragg_spots()
SIM.to_smv_format(fileout="intimage_004.img",intfile_scale=1)


SIM.detector_psf_fwhm_mm=0.08;
SIM.detector_psf_type=shapetype.Fiber

# get same noise each time this test is run
SIM.seed = 1
print("seed=",SIM.seed)
print("calib_seed=",SIM.calib_seed)
print("quantum_gain=",SIM.quantum_gain)
print("adc_offset_adu=",SIM.adc_offset_adu)
print("detector_calibration_noise_pct=",SIM.detector_calibration_noise_pct)
print("flicker_noise_pct=",SIM.flicker_noise_pct)
print("readout_noise_adu=",SIM.readout_noise_adu)
print("detector_psf_type=",SIM.detector_psf_type)
print("detector_psf_fwhm_mm=",SIM.detector_psf_fwhm_mm)
print("detector_psf_kernel_radius_pixels=",SIM.detector_psf_kernel_radius_pixels)
SIM.show_params()
SIM.add_noise()

print("raw_pixels=",SIM.raw_pixels)
SIM.to_smv_format(fileout="noiseimage_001.img",intfile_scale=1)

print("mosaic_domains=",SIM.mosaic_domains)
print("mosaic_spread_deg=",SIM.mosaic_spread_deg)
print("dispersion_pct=",SIM.dispersion_pct)
print("dispsteps=",SIM.dispsteps)
print("divergence_hv_mrad=",SIM.divergence_hv_mrad)
print("divergence_hv=",SIM.divsteps_hv)

print("GOT HERE 1")

SIM.verbose=999
SIM.free_all()

print("GOT HERE 2")



 *******************************************************************************


 *******************************************************************************
simtbx/nanoBragg/nanoBragg_beam.py
"""
Organizer for nanoBragg beam properties
"""
from __future__ import print_function, division
from dxtbx.model.beam import BeamFactory
from dxtbx_model_ext import flex_Beam
import numpy as np
from copy import deepcopy
from mmtbx_reduce_ext import RotatePointDegreesAroundAxisDir


def rotate_axis(v, axis, phi):
    """
    :param v: vector to rotate
    :param axis: axis of rotation
    :param phi: angle in radians
    """
    new_v = RotatePointDegreesAroundAxisDir((0,0,0), axis, v, phi*180/np.pi)
    return new_v


class NBbeam(object):

  def __init__(self):
    self.spectrum = [(1.8, 1e12)] # angstroms, photons per pulse
    self.unit_s0 = 1, 0, 0  # forward beam direction
    self.polarization_fraction = 1  # defines horizontal and vertical polarization fraction
    self.divergence_mrad = 0  # set the divergence cone angle
    self.divsteps = 0  # number of divergence steps, will be squared (one per horizontal, vertical directions)
    self.size_mm = 0.001 # beam spot size
    self._undo_nanoBragg_norm_by_nbeams = True # we undo it by default
    self.prev_xray_beams = None  # used to cache most recent xray_beams property for efficiency
    self.num_div_angles_within_cone = 0  # used to count how manydivergence angles we sample within the cone of divergence

  @property
  def divsteps(self):
    return self._divsteps

  @divsteps.setter
  def divsteps(self, val):
    if val > 0:
      assert val % 2 == 0, "divsteps must be even"
    self._divsteps = val

  @property
  def divergences(self):
    divrange = self.divergence_mrad/1000.
    if self.divsteps==0:
      return [(0,0)]
    else:
      all_divs = np.arange(0, divrange+1e-7, divrange / self.divsteps) - divrange / 2
      return [(hdiv, vdiv) for vdiv in all_divs for hdiv in all_divs]

  @property
  def size_mm(self):
    return self._size_mm

  @size_mm.setter
  def size_mm(self, val):
    self._size_mm = val

  @property
  def spectrum(self):
    """ list of (wavelength, flux) defining the energy spectrum"""
    return self._spectrum

  @spectrum.setter
  def spectrum(self, val):
    self._spectrum = val

  @property
  def unit_s0(self):
    return self._unit_s0

  @unit_s0.setter
  def unit_s0(self, val):
    self._unit_s0 = val

  @property
  def divergence(self):
    return self._divergence

  @divergence.setter
  def divergence(self, val):
    self._divergence = val

  @property
  def polarization_fraction(self):
    return self._polarization_fraction

  @polarization_fraction.setter
  def polarization_fraction(self, val):
    self._polarization_fraction = val

  @property
  def xray_beams(self):
    self._xray_beams = flex_Beam()

    divs = self.divergences

    wavelen = self.spectrum[0][0]
    nominal_beam = BeamFactory.simple(wavelen * 1e-10)
    nominal_beam.set_unit_s0(self.unit_s0)
    nominal_beam.set_polarization_fraction(self.polarization_fraction)
    beam_vector = nominal_beam.get_sample_to_source_direction()
    beam_vector /= np.linalg.norm(beam_vector)
    vert_vector = nominal_beam.get_polarization_normal()
    polar_vector = np.cross(beam_vector, vert_vector)
    polar_vector /= np.linalg.norm(polar_vector)

    self.num_div_angles_within_cone = 0
    beams = []
    for hdiv, vdiv in divs:
      vec_xyz = rotate_axis(-beam_vector, polar_vector, vdiv)
      unit_s0 = rotate_axis(vec_xyz, vert_vector, hdiv)
      div_ang = np.arccos(np.dot(unit_s0, -beam_vector))
      if hdiv == 0 and vdiv == 0:
        assert div_ang == 0
        assert np.allclose(unit_s0, nominal_beam.get_unit_s0())
      if div_ang > 1.1*(self.divergence_mrad / 1000. / 2.):
        continue
      self.num_div_angles_within_cone += 1
      for wavelen, flux in self.spectrum:
        beam = deepcopy(nominal_beam)
        beam.set_wavelength(wavelen*1e-10)
        beam.set_flux(flux)
        beam.set_polarization_fraction(self.polarization_fraction)
        beam.set_unit_s0(unit_s0)
        beam.set_divergence(div_ang)
        beams.append(beam)

    # set normalization
    norm = 1
    if self._undo_nanoBragg_norm_by_nbeams:
      norm = len(beams)
    for beam in beams:
      beam.set_flux(beam.get_flux()/norm)
      self._xray_beams.append(beam)

    self.prev_xray_beams = self._xray_beams
    return self._xray_beams

  @property
  def nanoBragg_constructor_beam(self):
    """dumb necessity for instantiating nanoBragg."""
    if self.prev_xray_beams is None:
      self.prev_xray_beams = self.xray_beams

    beam = BeamFactory.from_dict(self.prev_xray_beams[0].to_dict())

    # set the nominal beam to have the average wavelength and the total flux
    num = 0
    den = 0
    flux = 0
    u0 = []
    div = 0
    count = 0
    for b in self.prev_xray_beams:
      wave = b.get_wavelength()
      wt = b.get_flux()
      num += wave * wt
      den += wt
      flux += b.get_flux()
      div += b.get_divergence()
      u0.append( b.get_unit_s0())
      count += 1
    u0 = np.mean(u0, 0)
    ave_wave = num / den
    div = div / count

    beam.set_divergence(div)
    beam.set_wavelength(ave_wave * 1e10)
    beam.set_flux(flux)
    beam.set_unit_s0(u0)
    return beam

  @property
  def number_of_sources(self):
    return len(self.spectrum)


 *******************************************************************************


 *******************************************************************************
simtbx/nanoBragg/nanoBragg_crystal.py
"""
organizer for setting the nanoBragg crystal properties
"""
from __future__ import absolute_import, division, print_function
try:
    from collections.abc import Iterable
except ModuleNotFoundError:
    from collections import Iterable
from simtbx.nanoBragg import shapetype
from scitbx.matrix import sqr
from cctbx import sgtbx


class NBcrystal(object):

  def __init__(self, init_defaults=True):
    self.xtal_shape = None  # nanoBragg shapetypes, can be e.g. tophat, gauss, square, round
    self.Ncells_abc = None  # 3-tuple of  floats specifying mosaic domains size along a,b,c crystal axes
    self.isotropic_ncells = None  # whether Na=Nb=Nc is a restraint
    self.Ncells_def = None  # 3-tuple of the offiagonal mosaic domain size terms, e.g. NaNb, NaNc, NcNb
    self.thick_mm = None  # crystal thickness used to determine an approximate scale for the crystal (not used much in diffBragg)
    self.symbol = None  # space group symbol e.g. P6522
    self.miller_array = None  # cctbx miller array for setting structure factor amplitudes
    self.mos_spread_deg = None  # mosaic spread
    self.anisotropic_mos_spread_deg = None  # whether mosaic spread is defined using 1 or 3 parameters
    self.n_mos_domains = None  # how many mosaic domains are used to sample the mosaic rotational spread (spherical or ellipsoidal caps)
    self.umat_maker = None  # instance of nanoBragg.anisotropic_mosaicity.AnisoUmats
    self.dxtbx_crystal = None  # dxtbx crystal model for the crystal
    self.cb_op = None
    if init_defaults:
      self.init_defaults()

  def init_defaults(self):
    self.xtal_shape = "gauss"
    self.Ncells_abc = (10, 10, 10)
    self.isotropic_ncells = True
    self.Ncells_def = None
    self.thick_mm = 0.1
    self.symbol = "P43212"
    ucell = (79.1, 79.1, 38.4, 90, 90, 90)
    self.dxtbx_crystal = NBcrystal.dxtbx_crystal_from_ucell_and_symbol(
      ucell_tuple_Adeg=ucell, symbol=self.symbol)
    self.miller_array = NBcrystal.dummie_Fhkl(ucell, self.symbol)
    self.mos_spread_deg = 0
    self.anisotropic_mos_spread_deg = None
    self.n_mos_domains = 1
    self.umat_maker = None

  @property
  def has_anisotropic_mosaicity(self):
    return self.anisotropic_mos_spread_deg is not None

  @property
  def space_group_info(self):
    if self.symbol is not None:
      info = sgtbx.space_group_info(symbol=self.symbol)
      return info
    else:
      raise AttributeError("Set the space group symbol before calling for space_group_info!")

  @property
  def miller_array_high_symmetry(self):
    if self.symbol is not None and self.miller_array is not None:
      return self.miller_array.customized_copy(space_group_info=self.space_group_info)
    else:
      raise AttributeError("Set the symbol and miller_array properties first!")

  @property
  def symbol(self):
    return self._symbol

  @symbol.setter
  def symbol(self, val):
    self._symbol = val

  @property
  def Omatrix(self):
    """
    Change of basis operator
    """
    if self.dxtbx_crystal is None:
      raise AttributeError("Specify the dxtbx crystal object first!")
    sgi = self.dxtbx_crystal.get_space_group().info()
    to_p1 = sgi.change_of_basis_op_to_primitive_setting()
    return sqr(to_p1.c_inv().r().transpose().as_double())

  @property
  def dxtbx_crystal(self):
    return self._dxtbx_crystal

  @dxtbx_crystal.setter
  def dxtbx_crystal(self, val):
    self._dxtbx_crystal = val

  @property
  def miller_array(self):
    return self._miller_array

  @miller_array.setter
  def miller_array(self, val):
    if val is not None:
      if isinstance(val.data()[0], complex):
        self.miller_is_complex = True
      else:
        self.miller_is_complex = False
        if str(val.observation_type()) == "xray.intensity":
          val = val.as_amplitude_array()
      self.cb_op = val.space_group_info().change_of_basis_op_to_primitive_setting()
      val = val.expand_to_p1()
      val = val.generate_bijvoet_mates()
      dtrm = sqr(self.cb_op.c().r().as_double()).determinant()
      if not dtrm == 1:
        val = val.change_basis(self.cb_op)
    self._miller_array = val

  @property
  def Ncells_abc(self):
    return self._Ncells_abc

  @Ncells_abc.setter
  def Ncells_abc(self, val):
    self._Ncells_abc = val

  @property
  def Ncells_def(self):
    return self._Ncells_def

  @Ncells_def.setter
  def Ncells_def(self, val):
    self._Ncells_def = val

  @property
  def anisotropic_mos_spread_deg(self):
    return self._anisotropic_mos_spread_deg

  @anisotropic_mos_spread_deg.setter
  def anisotropic_mos_spread_deg(self, val):
    if val is not None:
      if not isinstance(val, Iterable):
        raise TypeError("anisotropic_mos_spread_deg needs to be a 3-tuple or 6-tuple")
      elif len(val) not in [3, 6]:
        raise ValueError("Anisotropic mosaicity should be either a 3-tuple or a 6-tuple")
    self._anisotropic_mos_spread_deg = val

  @property
  def mos_spread_deg(self):
    return self._mos_spread_deg

  @mos_spread_deg.setter
  def mos_spread_deg(self, val):
    self._mos_spread_deg = val

  @property
  def n_mos_domains(self):
    return self._n_mos_domains

  @n_mos_domains.setter
  def n_mos_domains(self, val):
    self._n_mos_domains = val

  @property
  def xtal_shape(self):
    if self._xtal_shape == "gauss":
      return shapetype.Gauss
    elif self._xtal_shape == "gauss_argchk":
      return shapetype.Gauss_argchk
    elif self._xtal_shape == "round":
      return shapetype.Round
    elif self._xtal_shape == "square":
      return shapetype.Square
    else:
      return shapetype.Tophat  # default after init

  @xtal_shape.setter
  def xtal_shape(self, val):
    self._xtal_shape = val

  @property
  def thick_mm(self):
    return self._thick_mm

  @thick_mm.setter
  def thick_mm(self, val):
    self._thick_mm = val

  @staticmethod
  def dxtbx_crystal_from_ucell_and_symbol(ucell_tuple_Adeg, symbol):
    """
    :param ucell_tuple_Adeg:  unit cell tuple a,b,c al, be, ga in Angstom and degrees
    :param symbol: lookup symbol for space group, e.g. 'P1'
    :return:a default crystal in conventional orientation, a along x-axis
    """
    from cctbx import crystal
    from dxtbx.model.crystal import CrystalFactory
    symm = crystal.symmetry("%f,%f,%f,%f,%f,%f" % ucell_tuple_Adeg, symbol)

    ucell = symm.unit_cell()
    O = ucell.orthogonalization_matrix()
    real_space_a = O[0], O[3], O[6]
    real_space_b = O[1], O[4], O[7]
    real_space_c = O[2], O[5], O[8]

    hall_symbol = symm.space_group_info().type().hall_symbol()

    return CrystalFactory.from_dict(
      {'__id__': 'crystal',
       'real_space_a': real_space_a,
       'real_space_b': real_space_b,
       'real_space_c': real_space_c,
       'space_group_hall_symbol': hall_symbol})

  @staticmethod
  def dummie_Fhkl(ucell, symbol):
    from simtbx.nanoBragg.utils import fcalc_from_pdb
    Fhkl = fcalc_from_pdb(resolution=2, algorithm="fft", wavelength=1, symbol=symbol, ucell=ucell)
    return Fhkl


 *******************************************************************************


 *******************************************************************************
simtbx/nanoBragg/nanoBragg_gui_dialogs.py
from __future__ import absolute_import, division, print_function

'''
Author      : Lyubimov, A.Y.
Created     : 12/12/2017
Last Changed: 12/12/2017
Description : IOTA GUI Dialogs
'''

import wx
from iota.components.iota_utils import UnicodeCharacters, WxFlags


# Platform-specific stuff
# TODO: Will need to test this on Windows at some point
if wx.Platform == '__WXGTK__':
  norm_font_size = 10
  button_font_size = 12
  LABEL_SIZE = 14
  CAPTION_SIZE = 12
elif wx.Platform == '__WXMAC__':
  norm_font_size = 12
  button_font_size = 14
  LABEL_SIZE = 14
  CAPTION_SIZE = 12
elif (wx.Platform == '__WXMSW__'):
  norm_font_size = 9
  button_font_size = 11
  LABEL_SIZE = 11
  CAPTION_SIZE = 9

# Initialize unicode font and wx flags
u = UnicodeCharacters()
f = WxFlags()


# ---------------------------------------------------------------------------- #

class BaseDialog(wx.Dialog):
  def __init__(self, parent, style=wx.DEFAULT_DIALOG_STYLE,
               label_style='bold',
               content_style='normal',
               *args, **kwargs):
    wx.Dialog.__init__(self, parent, style=style, *args, **kwargs)

    self.envelope = wx.BoxSizer(wx.VERTICAL)
    self.main_sizer = wx.BoxSizer(wx.VERTICAL)
    self.envelope.Add(self.main_sizer, 1, flag=wx.EXPAND | wx.ALL, border=5)
    self.SetSizer(self.envelope)

    if label_style == 'normal':
      self.font = wx.Font(norm_font_size, wx.DEFAULT, wx.NORMAL, wx.NORMAL)
    elif label_style == 'bold':
      self.font = wx.Font(norm_font_size, wx.DEFAULT, wx.NORMAL, wx.BOLD)
    elif label_style == 'italic':
      self.font = wx.Font(norm_font_size, wx.DEFAULT, wx.ITALIC, wx.NORMAL)
    elif label_style == 'italic_bold':
      self.font = wx.Font(norm_font_size, wx.DEFAULT, wx.ITALIC, wx.BOLD)

    if content_style == 'normal':
      self.cfont = wx.Font(norm_font_size, wx.DEFAULT, wx.NORMAL, wx.NORMAL)
    elif content_style == 'bold':
      self.cfont = wx.Font(norm_font_size, wx.DEFAULT, wx.NORMAL, wx.BOLD)
    elif content_style == 'italic':
      self.cfont = wx.Font(norm_font_size, wx.DEFAULT, wx.ITALIC, wx.NORMAL)
    elif content_style == 'italic_bold':
      self.cfont = wx.Font(norm_font_size, wx.DEFAULT, wx.ITALIC, wx.BOLD)

class BeamlineOptions(BaseDialog):
  def __init__(self, parent, phil=None,
               label_style='bold',
               content_style='normal',
               *args, **kwargs):
    dlg_style = wx.CAPTION | wx.CLOSE_BOX | wx.RESIZE_BORDER | wx.STAY_ON_TOP

    BaseDialog.__init__(self, parent, style=dlg_style,
                        label_style=label_style,
                        content_style=content_style,
                        size=(600, 500),
                        *args, **kwargs)


 *******************************************************************************


 *******************************************************************************
simtbx/nanoBragg/nanoBragg_gui_frames.py
'''
Author      : Lyubimov, A.Y.
Created     : 12/12/2017
Last Changed: 06/20/2019
Description : SIMTBX (nanoBragg) GUI Windows / frames
'''
from __future__ import absolute_import, division, print_function

import os
import wx
import numpy as np

from wxtbx import bitmaps

from matplotlib.backends.backend_wxagg import FigureCanvasWxAgg as FigureCanvas
from matplotlib.figure import Figure

from iotbx import phil as ip
from simtbx.nanoBragg import nanoBragg_gui_dialogs as dlg
from simtbx.nanoBragg import nanoBragg_threads as thr
from iota.components.gui import controls as ct
from iota.components.iota_utils import InputFinder, WxFlags, noneset
from six.moves import range

ginp = InputFinder()
import time

f = WxFlags()

# ------------------------------ Input Window -------------------------------- #

class BasePanel(wx.Panel):
  def __init__(self, parent):
    wx.Panel.__init__(self, parent=parent, id=wx.ID_ANY, size=(800, 800))

    self.main_sizer = wx.BoxSizer(wx.VERTICAL)
    self.SetSizer(self.main_sizer)


class TopPanel(BasePanel):
  def __init__(self, parent):
    BasePanel.__init__(self, parent=parent)

    self.parent = parent
    self.img_filename = None
    self.input_phil = None
    self.sparams = None
    self.coord_filename = None
    self.mtz_filename = None
    self.stol_filename = None
    self.ref_img_filename = None
    self.dblclick = False


    self.project_folder = ct.InputCtrl(self,
                                       label='Project Folder: ',
                                       label_size=(150, -1),
                                       label_style='bold',
                                       value=os.path.abspath(os.curdir),
                                       buttons=True)

    self.project_title = ct.InputCtrl(self,
                                      label='Description',
                                      label_size=(150, -1),
                                      label_style='normal')

    self.splitter = wx.SplitterWindow(self, style=wx.SP_LIVE_UPDATE |
                                                  wx.SP_3DSASH |
                                                  wx.SP_NOBORDER)
    self.file_panel = wx.Panel(self.splitter, size=(-1, 200))
    self.file_sizer = wx.BoxSizer(wx.VERTICAL)
    self.file_panel.SetSizer(self.file_sizer)
    self.preview_panel = wx.Panel(self.splitter, size=(-1, 500))
    self.preview_sizer = wx.BoxSizer(wx.VERTICAL)
    self.preview_panel.SetSizer(self.preview_sizer)
    self.splitter.SplitHorizontally(self.file_panel, self.preview_panel, 200)

    self.input = FileListCtrl(self.file_panel)
    self.file_sizer.Add(self.input, 1, flag=wx.ALL | wx.EXPAND, border=10)

    # Image preview box w/ options
    prev_box = wx.GridBagSizer(5, 15)

    # self.opt_knb_start = ct.KnobCtrl(self.preview_panel,
    #                                  label='start',
    #                                  label_size=(40, -1),
    #                                  spin_ctr_size=(50, -1),
    #                                  knob_size=(120, 120),
    #                                  values_start=0,
    #                                  values_end=360,
    #                                  values_step=1,
    #                                  value=0)
    #
    # self.opt_knb_end = ct.KnobCtrl(self.preview_panel,
    #                                label='end',
    #                                label_size=(40, -1),
    #                                spin_ctr_size=(50, -1),
    #                                knob_size=(120, 120),
    #                                values_start=0,
    #                                values_end=360,
    #                                values_step=1,
    #                                value=360)

    self.opt_spc_start = ct.SpinCtrl(self.preview_panel,
                                     label='start:',
                                     label_size=(50, -1),
                                     ctrl_size=(60, -1),
                                     ctrl_value='0',
                                     ctrl_max=360,
                                     ctrl_min=0,
                                   ctrl_step=0.1,
                                   ctrl_digits=1)

    self.opt_spc_end = ct.SpinCtrl(self.preview_panel,
                                   label='finish:',
                                   label_size=(50, -1),
                                   ctrl_size=(60, -1),
                                   ctrl_value='360',
                                   ctrl_max=360,
                                   ctrl_min=0,
                                   ctrl_step=0.1,
                                   ctrl_digits=1)

    self.opt_spc_osc = ct.SpinCtrl(self.preview_panel,
                                   label='step:',
                                   label_size=(50, -1),
                                   ctrl_size=(60, -1),
                                   ctrl_value='1.0',
                                   ctrl_max=360,
                                   ctrl_min=0,
                                   ctrl_step=0.1,
                                   ctrl_digits=2)

    self.opt_btn_prev = wx.Button(self.preview_panel,
                                  label='PREVIEW IMAGE')

    self.opt_chk_bkg = wx.CheckBox(self.preview_panel, label='Add Background')
    self.opt_chk_bkg.SetValue(True)
    self.opt_chk_noise = wx.CheckBox(self.preview_panel, label='Add Noise')
    self.opt_chk_noise.SetValue(True)
    self.opt_chk_rand = wx.CheckBox(self.preview_panel,
                                    label='Randomize Orientation')
    self.opt_chk_rand.SetValue(True)

    self.opt_spc_scale = ct.SpinCtrl(self.preview_panel,
                                     label='Crystal size (um): ',
                                     label_size=(120, -1),
                                     ctrl_size=(100, -1),
                                     ctrl_min = 1,
                                     ctrl_max = 1000,
                                     ctrl_step = 1,
                                     ctrl_value = 30)

    self.img_figure = Figure(figsize=(3, 3))
    self.img_axes = self.img_figure.add_subplot(111)

    self.img_axes.set_frame_on(False)
    self.img_axes.axis('off')
    self.img_axes.set_aspect('equal')

    self.img_figure.patch.set_visible(False)
    self.img_canvas = FigureCanvas(self.preview_panel, -1, self.img_figure)

    prev_box.Add(self.opt_spc_start, pos=(0, 0))
    prev_box.Add(self.opt_spc_end, pos=(0, 1))
    prev_box.Add(self.opt_spc_osc, pos=(1, 0))
    prev_box.Add(self.opt_chk_bkg, flag=wx.EXPAND, pos=(4, 0), span=(1, 2))
    prev_box.Add(self.opt_chk_noise, flag=wx.EXPAND, pos=(5, 0), span=(1, 2))
    prev_box.Add(self.opt_chk_rand, flag=wx.EXPAND, pos=(6, 0), span=(1, 2))
    prev_box.Add(self.opt_spc_scale, flag=wx.EXPAND, pos=(7, 0), span=(1, 2))
    prev_box.Add(self.opt_btn_prev, flag=wx.EXPAND, pos=(8,0), span=(1, 2))
    prev_box.Add(self.img_canvas, pos=(0, 2), span=(9, 1),
                 flag=wx.EXPAND)
    prev_box.AddGrowableCol(2)
    prev_box.AddGrowableRow(8)

    self.preview_sizer.Add(prev_box, 1, flag=wx.EXPAND | wx.ALL, border=10)

    self.main_sizer.Add(self.project_title, flag=wx.EXPAND | wx.ALL, border=10)
    self.main_sizer.Add(self.project_folder, flag=wx.EXPAND | wx.ALL, border=10)
    self.main_sizer.Add(self.splitter, 1, flag=wx.EXPAND)

    # Button bindings
    self.Bind(wx.EVT_BUTTON, self.onRunPreview, self.opt_btn_prev)

    # Thread bindings
    self.Bind(thr.EVT_NBDONE, self.onFinishedSimThread)

    # Image bindings
    xid = self.img_canvas.mpl_connect('button_press_event', self.on_button_press)
    xid = self.img_canvas.mpl_connect('button_release_event',
                                      self.on_button_release)

  def onRunPreview(self, e):
    e.Skip()

  def generate_phil(self):

    coord_path = None
    FCalc_path = None
    bkg_path = None
    img_path = None

    # Grab inputs (if any) from file list control
    idxs = self.input.ctr.GetItemCount()
    inputs = [self.input.ctr.GetItemData(i) for i in range(idxs)]

    for idx in range(idxs):
      item = self.input.ctr.GetItemData(idx)
      item_type_sel = item.type_selection
      item_type = item.type.type.GetString(item_type_sel)

      if item_type == 'coordinates':
        coord_path = item.path
      elif item_type == 'structure factors':
        FCalc_path = item.path
      elif item_type == 'background':
        bkg_path = item.path
      elif item_type == 'raw image file':
        img_path = item.path

    simtbx_phil_string = '\n'.join([
    'description = {}'.format(noneset(self.project_title.ctr.GetValue())),
    'output = {}'.format(noneset(self.project_folder.ctr.GetValue())),
    'reference_coordinates = {}'.format(coord_path),
    'reference_FCalc = {}'.format(FCalc_path),
    'reference_image = {}'.format(img_path),
    'radial_average_background = {}'.format(bkg_path),
    'dataset',
    '{',
    '  start_phi = {}'.format(str(self.opt_spc_start.ctr.GetValue())),
    '  finish_phi = {}'.format(str(self.opt_spc_end.ctr.GetValue())),
    '  oscillation = {}'.format(str(self.opt_spc_osc.ctr.GetValue())),
    '  }'
    ])

    self.input_phil = ip.parse(simtbx_phil_string)

  def run_simulator(self, init=None):
    pass

  def run_preview(self):
    img_filename = 'test_image.{}'.format(self.sparams.image_format)
    self.img_filename = os.path.join(self.sparams.output, img_filename)
    self.start_timer = time.time()
    self.sim = thr.nanoBraggThread(self,
                                   params=self.sparams,
                                   add_background=self.opt_chk_bkg.GetValue(),
                                   add_noise=self.opt_chk_noise.GetValue(),
                                   randomize=self.opt_chk_rand.GetValue(),
                                   pixel_scale=self.opt_spc_scale.ctr.GetValue(),
                                   preview=True)
    self.sim.start()

  def onFinishedSimThread(self, e):
    pixels = e.GetValue()
    self.display_image(pixels=pixels)
    print('TOTAL TIME = ', time.time() - self.start_timer)

  def display_image(self, pixels=None):
    if pixels is None:
      pixels = np.random.randint(low=0, high=1500000, size=(2576, 2576))
    else:
      pixels = pixels.as_numpy_array()

    clim = (pixels.min(), np.percentile(pixels, 99))

    self.img_axes.imshow(pixels,
                         #interpolation='nearest',
                         cmap='gray_r',
                         clim=clim)
    self.img_figure.subplots_adjust(left=0, bottom=0, right=1, top=1)

    self.preview_panel.Layout()
    print('DEBUG: AVERAGE PIXEL VALUE = ', np.mean(pixels))
    print('DONE!')

  def on_button_press(self, e):
    if e.button == 1 and e.dblclick:
      self.dblclick = True
    else:
      self.dblclick = False

  def on_button_release(self, e):
    if e.button == 1 and self.dblclick:
      self.view_image()

  def view_image(self):
    viewer = thr.ImageViewerThread(self,
                                   file_string=self.img_filename)
    viewer.start()

class FileListCtrl(ct.CustomListCtrl):
  ''' File list window for the input tab '''

  def __init__(self, parent, size=(-1, 250)):
    ct.CustomListCtrl.__init__(self, parent=parent, size=size)

    self.parent = parent
    self.main_window = parent.GetParent()

    # Generate columns
    self.ctr.InsertColumn(0, "Input Path")
    self.ctr.InsertColumn(1, "Input Type")
    self.ctr.InsertColumn(2, "Action")
    self.ctr.setResizeColumn(1)

    # Add file / folder buttons
    self.button_sizer = wx.BoxSizer(wx.HORIZONTAL)
    self.btn_add_file = wx.Button(self, label='Add File...')
    #self.btn_browse = wx.Button(self, label='Add Folder...')
    self.button_sizer.Add(self.btn_add_file)
    #self.proc_sizer.Add(self.btn_browse, flag=wx.LEFT, border=10)

    self.sizer.Add(self.button_sizer, flag=wx.TOP | wx.BOTTOM, border=10)

    # Event bindings
    self.Bind(wx.EVT_BUTTON, self.onAddFile, self.btn_add_file)

    self.Layout()

  def onAddFile(self, e):
    file_dlg = wx.FileDialog(self,
                             message="Load File",
                             defaultDir=os.curdir,
                             defaultFile="*",
                             wildcard="*",
                             style=wx.FD_OPEN | wx.FD_FILE_MUST_EXIST |
                                   wx.FD_MULTIPLE)
    if file_dlg.ShowModal() == wx.ID_OK:
      files = file_dlg.GetPaths()
      for item in files:
        self.add_item(item)
    file_dlg.Destroy()
    e.Skip()

  def set_type_choices(self, path):
    # Determine what type of input this is and present user with choices
    # (this so far works for images ONLY)
    type_choices = ['[  SELECT INPUT TYPE  ]',
                    'coordinates',
                    'structure factors',
                    'background',
                    'raw image file']
    preferred_selection = 0
    inputs, input_type = ginp.get_input(path, filter_results=False)

    if input_type == 'data (MTZ)':
      input_type = 'structure factors'
    elif input_type == 'text' and path.endswith('stol'):
      input_type = 'background'

    if input_type in type_choices:
      preferred_selection = type_choices.index(input_type)
    return inputs, type_choices, preferred_selection

  def add_item(self, path):
    # Generate item
    inputs, inp_choices, inp_sel = self.set_type_choices(path)
    type_choice = ct.DataTypeChoice(self.ctr,
                                    choices=inp_choices)
    item = ct.InputListItem(path=path,
                            type=type_choice,
                            buttons=ct.MiniButtonBoxInput(self.ctr))

    self.Bind(wx.EVT_CHOICE, self.onTypeChoice, item.type.type)
    # item.buttons.btn_mag.Bind(wx.EVT_BUTTON, self.onMagButton)
    # item.buttons.btn_delete.Bind(wx.EVT_BUTTON, self.onDelButton)
    # item.buttons.btn_info.Bind(wx.EVT_BUTTON, self.onInfoButton)
    self.Bind(wx.EVT_BUTTON, self.onMagButton, item.buttons.btn_mag)
    self.Bind(wx.EVT_BUTTON, self.onDelButton, item.buttons.btn_delete)
    self.Bind(wx.EVT_BUTTON, self.onInfoButton, item.buttons.btn_info)

    # Insert list item
    idx = self.ctr.InsertStringItem(self.ctr.GetItemCount() + 1, item.path)
    self.ctr.SetItemWindow(idx, 1, item.type, expand=True)
    self.ctr.SetItemWindow(idx, 2, item.buttons, expand=True)

    # Set drop-down selection, check it for data and open other tabs
    item.type.type.SetSelection(inp_sel)
    if item.type.type.GetString(inp_sel) in ('coordinates',
                                             'structure factors',
                                             'background',
                                             'raw image file'):
      if "image" in item.type.type.GetString(inp_sel):
        view_bmp = bitmaps.fetch_custom_icon_bitmap('image_viewer16')
        item.buttons.btn_mag.SetBitmapLabel(view_bmp)
    else:
      warn_bmp = bitmaps.fetch_icon_bitmap('actions', 'status_unknown',
                                           size=16)
      item.buttons.btn_info.SetBitmapLabel(warn_bmp)
      item.warning = True

    # Record index in all relevant places
    item.id = idx
    item.buttons.index = idx
    item.type.index = idx
    item.type_selection = inp_sel

    # Resize columns to fit content
    self.ctr.SetColumnWidth(1, width=-1)
    self.ctr.SetColumnWidth(2, width=-1)
    self.ctr.SetColumnWidth(0, width=-3)

    # Make sure all the choice lists are the same size
    if item.type.type.GetSize()[0] < self.ctr.GetColumnWidth(2) - 5:
       item.type.type.SetSize((self.ctr.GetColumnWidth(2) - 5, -1))

    # Attach data object to item
    self.ctr.SetItemData(item.id, item)

    self.Layout()

  def onTypeChoice(self, e):
    type = e.GetEventObject().GetParent()
    item_data = self.ctr.GetItemData(type.index)
    item_data.type.type.SetSelection(type.type.GetSelection())
    item_data.type_selection = type.type.GetSelection()

    # Evaluate whether data folders / files are present
    data_items = 0
    for idx in range(self.ctr.GetItemCount()):
      if self.ctr.GetItemData(idx).type_selection != 0:
        data_items += 1
    if data_items > 0:
      self.main_window.toolbar.EnableTool(self.main_window.tb_btn_run.GetId(),
                                          True)
    else:
      self.main_window.toolbar.EnableTool(self.main_window.tb_btn_run.GetId(),
                                          False)
    e.Skip()

  def onMagButton(self, e):
    idx = e.GetEventObject().GetParent().index
    item_obj = self.ctr.GetItemData(idx)
    path = item_obj.path
    type = item_obj.type.type.GetString(item_obj.type_selection)

    if os.path.isfile(path):
      if type in ('raw image file', 'image pickle file'):
        self.view_images([path], img_type=type)
      elif type == 'text':
        with open(path, 'r') as f:
          file_list = f.readlines()
          msg = ' '.join(file_list)
          textview = dlg.TextFileView(self, title=path, contents=msg)
          textview.ShowModal()
      else:
        wx.MessageBox('Unknown file format', 'Warning',
                      wx.OK | wx.ICON_EXCLAMATION)

  def view_images(self, img_list, img_type=None):
    ''' Launches image viewer (depending on backend) '''
    viewer = self.parent.gparams.advanced.image_viewer
    if viewer == 'cxi.view' and 'pickle' not in img_type:
        wx.MessageBox('cxi.view only accepts image pickles', 'Warning',
                      wx.OK | wx.ICON_EXCLAMATION)
    else:
      if len(img_list) > 10:
        view_warning = dlg.ViewerWarning(self, len(img_list))
        if view_warning.ShowModal() == wx.ID_OK:
          # parse 'other' entry
          img_no_string = str(view_warning.no_images).split(',')
          filenames = []
          for n in img_no_string:
            if '-' in n:
              img_limits = n.split('-')
              start = int(min(img_limits))
              end = int(max(img_limits))
              if start <= len(img_list) and end <= len(img_list):
                filenames.extend(img_list[start:end])
            else:
              if int(n) <= len(img_list):
                filenames.append(img_list[int(n)])
          file_string = ' '.join(filenames)
        else:
          return
        view_warning.Close()
      elif viewer == 'distl.image_viewer' and len(img_list) > 1:
        wx.MessageBox('distl.image_viewer can show only one image', 'Warning',
                      wx.OK | wx.ICON_EXCLAMATION)
        file_string = img_list[0]
      else:
        file_string = ' '.join(img_list)

      viewer = thr.ImageViewerThread(self,
                                     viewer=viewer,
                                     file_string=file_string,
                                     img_type=img_type)
      viewer.start()


  def onDelButton(self, e):
    item = e.GetEventObject().GetParent()
    self.delete_button(item.index)

  def delete_all(self):
    for idx in range(self.ctr.GetItemCount()):
      self.delete_button(index=0)

  def delete_button(self, index):
    self.ctr.DeleteItem(index)

    # Refresh widget and list item indices
    if self.ctr.GetItemCount() > 0:
      for i in range(self.ctr.GetItemCount()):
        item_data = self.ctr.GetItemData(i)
        item_data.id = i
        item_data.buttons.index = i
        item_data.type.index = i
        type_choice = self.ctr.GetItemWindow(i, col=1)
        type_selection = item_data.type.type.GetSelection()
        type_choice.type.SetSelection(type_selection)
        self.ctr.SetItemData(i, item_data)

  def onInfoButton(self, e):
    ''' Info / alert / error button (will change depending on circumstance) '''
    idx = e.GetEventObject().GetParent().index
    item_obj = self.ctr.GetItemData(idx)
    item_type = item_obj.type.type.GetString(item_obj.type_selection)

    if item_obj.warning:
      wx.MessageBox(item_obj.info['WARNING'], 'Warning', wx.OK |
                    wx.ICON_EXCLAMATION)
    else:
      wx.MessageBox(item_obj.info[item_type], 'Info', wx.OK |
                    wx.ICON_INFORMATION)


 *******************************************************************************


 *******************************************************************************
simtbx/nanoBragg/nanoBragg_gui_init.py
'''
Author      : Lyubimov, A.Y.
Created     : 12/12/2017
Last Changed: 10/30/2018
Description : SIMTBX (nanoBragg) GUI Initialization module
'''
from __future__ import absolute_import, division, print_function

import os
import wx
from wxtbx import bitmaps
import numpy as np

from simtbx.nanoBragg import nanoBragg_gui_frames as frm
from simtbx.nanoBragg import nanoBragg_input as inp


# ------------------------------- Main Window -------------------------------- #

class MainWindow(wx.Frame):
  ''' Frame housing the entire app; all windows open from this one '''

  def __init__(self, parent, id, title):
    wx.Frame.__init__(self, parent, id, title)
    self.parent = parent
    self.simtbx_phil = inp.generate_simtbx_phil()
    self.sparams = self.simtbx_phil.extract()

    #self.simtbx_phil.show()

    # Setup main sizer
    self.main_sizer = wx.BoxSizer(wx.VERTICAL)

    # Setup toolbar
    self.toolbar = self.CreateToolBar(style=wx.TB_TEXT)
    quit_bmp = bitmaps.fetch_icon_bitmap('actions', 'exit')
    self.tb_btn_quit = self.toolbar.AddLabelTool(wx.ID_EXIT, label='Quit',
                                                 bitmap=quit_bmp,
                                                 shortHelp='Quit',
                                                 longHelp='Quit image tracker')
    self.toolbar.AddSeparator()
    run_bmp = bitmaps.fetch_icon_bitmap('actions', 'run')
    self.tb_btn_run = self.toolbar.AddLabelTool(wx.ID_ANY, label='Run',
                                                bitmap=run_bmp,
                                                shortHelp='Run',
                                                longHelp='Run Spotfinding')
    self.toolbar.Realize()

    #Processing status bar
    self.sb = self.CreateStatusBar()
    self.sb.SetFieldsCount(2)
    self.sb.SetStatusWidths([-1, -2])

    # Output gauge in status bar
    self.gauge_process = wx.Gauge(self.sb, -1, style=wx.GA_HORIZONTAL | wx.GA_SMOOTH)
    rect = self.sb.GetFieldRect(0)
    self.gauge_process.SetPosition((rect.x + 2, rect.y + 2))
    self.gauge_process.SetSize((rect.width - 4, rect.height - 4))
    self.gauge_process.Hide()

    # Instantiate windows
    self.top_window = frm.TopPanel(self)

    # Single input window
    self.main_sizer.Add(self.top_window, 1,
                        flag=wx.ALL | wx.EXPAND,
                        border=10)
    self.main_sizer.Add((-1, 20))

    # Bindings
    self.Bind(wx.EVT_TOOL, self.onQuit, self.tb_btn_quit)
    self.Bind(wx.EVT_TOOL, self.onRun, self.tb_btn_run)
    self.Bind(wx.EVT_BUTTON, self.onRunPreview,
              self.top_window.opt_btn_prev)

  def onQuit(self, e):
    self.Close()

  def onRun(self, e):
    self.init_settings()
    self.top_window.sparams = self.sparams

    init = InitAll(self, self.sparams)
    good_to_go = init.run()

    if good_to_go:
      self.top_window.run_simulator(init=init)

  def onRunPreview(self, e):
    self.init_settings()
    self.top_window.sparams = self.sparams
    self.top_window.run_preview()


  def init_settings(self):

    # Pull settings from input window
    # TODO: once tabs are made, pull user-phil files from each tab
    self.top_window.generate_phil()
    self.simtbx_phil = self.simtbx_phil.fetch(self.top_window.input_phil)

    # Generate params python object
    self.sparams = self.simtbx_phil.extract()


# ------------------------------- Initialize --------------------------------- #

class InitAll(object):
  """ Class to initialize current nanoBragg run

  """

  def __init__(self, parent, params):
    self.parent = parent
    self.params = params
    self.img_base = None

  def make_input_list(self):
    if self.img_base is not None:
      start = self.params.dataset.start_phi
      finish = self.params.dataset.finish_phi
      step = self.params.dataset.oscillation
      angles = list(np.arange(start, finish, step))

      # generate list of image filenames
      img_prefix = self.params.image_prefix
      img_format = self.params.image_format
      inputs = []
      for phi in angles:
        idx = angles.index(phi) + 1
        input = {'index':idx,
                 'path':'{}_{:05d}.{}'.format(img_prefix, idx, img_format),
                 'phi':phi, 'osc':step}
        inputs.append(input)
      return inputs
    else:
      return None



  def run(self):
    ''' Initialize simtbx UI'''

    # Create folder for synthetic images
    self.img_base = os.path.join(os.path.abspath(self.params.output), 'images')

    # Generate list of inputs
    self.input_list = self.make_input_list()

    if self.input_list is not None:
      for i in self.input_list: print(i)
      return True
    else:
      return False


 *******************************************************************************


 *******************************************************************************
simtbx/nanoBragg/nanoBragg_input.py
'''
Author      : Lyubimov, A.Y.
Created     : 10/10/2014
Last Changed: 11/03/2017
Description : SIMTBX (nanoBragg) I/O module. Reads PHIL input.
'''
from __future__ import absolute_import, division, print_function

import iotbx.phil as ip
import inspect

from simtbx.nanoBragg import nanoBragg

def isprop(v):
  ''' Test if attribute is a property '''
  return isinstance(v, property)

def flatten(L):
  for item in L:
    try:
      for i in flatten(item):
        yield i
    except TypeError:
      yield item

def generate_simtbx_phil():
  ''' Generates a PHIL object from simTBX params

  @return: sim_phil: a PHIL object
  '''

  ui_phil_string = """
description = None
  .type = str
  .help = Run description (optional).
  .optional = True
output = None
  .type = path
  .help = Base output directory, current directory in command-line, can be set in GUI
  .optional = False
image_prefix = synthetic_image
  .type = str
  .help = Prefix for synthetic image filenames (numbers will be added)
image_format = *img cbf mccd pickle
  .type = choice
  .help = Will be format in the future, just extension for now
reference_coordinates = None
  .type = path
  .help = Coordinates (PDB) to generate FCalc
reference_FCalc = None
  .type = path
  .help = FCalc (MTZ) that can be used to generate the diffraction pattern
reference_image = None
  .type = path
  .help = Diffraction image that can be used to match orientation
radial_average_background = None
  .type = path
  .help = Radial average background (sin(theta) / lambda, STOL)
dataset
  .help = Synthetic dataset options
{
  start_phi = 0
    .type = float
    .help = phi angle for the first image in the dataset
  finish_phi = 90
    .type = float
    .help = phi angle for the last image in the dataset
  oscillation = 1
    .type = float
    .help = phi oscillation per dataset image
}
"""

  sim = nanoBragg()
  params = [name for (name, value) in inspect.getmembers(nanoBragg, isprop)]

  param_lines = ['simtbx',
                 '{']
  for i in params:
    # The below properties result in boost errors (Fbg_vs_stol), TypeError
    # exceptions (xray_beams), or yield objects rather than values (the rest)
    if i in ('Fbg_vs_stol', 'Fhkl_tuple', 'amplitudes', 'indices', 'raw_pixels',
             'xray_source_XYZ', 'xray_source_intensity_fraction', 'xray_beams',
             'xray_source_wavelengths_A', 'unit_cell_tuple', 'progress_pixel'):
      continue

    try:
      param_value = getattr(sim, i)
      if type(param_value).__name__ == 'tuple':
        element_type = type(list(flatten(param_value))[0]).__name__
        param_type = "{}s".format(element_type)
        param_value = ' '.join(str(i) for i in list(flatten(param_value)))
        param_doc = getattr(nanoBragg, i).__doc__
      else:
        param_type = type(param_value).__name__
        param_doc = getattr(nanoBragg, i).__doc__
        if param_type == 'unit_cell':
          param_value = ' '.join(str(i) for i in param_value.parameters())

      # Correct a number of weird vartypes
      if param_type in ('convention', 'pivot', 'shapetype'):
        param_type = 'str'


      # PHIL interprets ';' as a line break
      param_doc = param_doc.replace(';', '.')

      param_line = '  {} = {} \n    .type = {}\n    .help = {}' \
                   ''.format(i, param_value, param_type, param_doc)
      param_lines.append(param_line)

    except TypeError as e:
      print(i, e)
      pass

  param_lines.append('}')
  sim_phil_string = '\n'.join(param_lines)
  combo_string = ui_phil_string + sim_phil_string

  sim_phil = ip.parse(combo_string)
  return sim_phil


 *******************************************************************************


 *******************************************************************************
simtbx/nanoBragg/nanoBragg_threads.py
'''
Author      : Lyubimov, A.Y.
Created     : 12/21/2017
Last Changed: 12/21/2017
Description : SIMTBX (nanoBragg) GUI Threads and PostEvents
'''
from __future__ import absolute_import, division, print_function

import os
import wx
from threading import Thread

from libtbx import easy_run
from scitbx.array_family import flex

from simtbx.nanoBragg import nanoBragg
from simtbx.nanoBragg import shapetype

from iotbx import pdb
from cctbx.eltbx import henke


# ------------------------------ IMAGE SYNTHESIS ----------------------------- #

tp_EVT_NBDONE = wx.NewEventType()
EVT_NBDONE = wx.PyEventBinder(tp_EVT_NBDONE, 1)

class nanoBraggAllDone(wx.PyCommandEvent):
  ''' Send event when finished all cycles  '''

  def __init__(self, etype, eid, pixels=None):
    wx.PyCommandEvent.__init__(self, etype, eid)
    self.pixels = pixels

  def GetValue(self):
    return self.pixels

class nanoBraggThread(Thread):
  ''' Basic spotfinder (with defaults) that could be used to rapidly analyze
  images as they are collected '''

  def __init__(self, parent, params,
               add_background=True,
               add_noise=True,
               randomize=True,
               pixel_scale=None,
               preview=True):
    Thread.__init__(self)
    self.SIM = nanoBragg(detpixels_slowfast=(1231, 1263),
                         pixel_size_mm=0.344,
                         Ncells_abc=(5, 5, 5))
    self.parent = parent
    self.params = params
    self.add_background = add_background
    self.add_noise = add_noise
    self.randomize = randomize
    self.crystal_size = pixel_scale
    self.preview = preview

  def run(self):
    if self.preview:
      self.generate_image()
    else:
      self.generate_image_set()


  def generate_image_set(self):
    pass

  def generate_image(self):
    img_filename = 'test_image.{}'.format(self.params.image_format)
    self.img_file = os.path.join(self.params.output, img_filename)

    if self.params.reference_coordinates is None:
      self.SIM.default_F = 1000
      print('DEBUG: GENERATING FCALC OF {}'.format(self.SIM.default_F))
    else:
      print('DEBUG: GENERATING FCALC FROM COORDINATES')
      self.SIM.default_F = 0
      sfall = self.fcalc_from_pdb(resolution=1.6, algorithm="fft",
                                  wavelength=self.SIM.wavelength_A)
      self.SIM.Fhkl = sfall

    # fastest option, least realistic
    self.SIM.xtal_shape = shapetype.Tophat

    # oversample = 1 is the fastest setting (speed inversely proportional to
    # square of oversample)
    self.SIM.oversample = 1
    self.SIM.wavelength_A = 1.3
    self.SIM.polarization = 1

    self.SIM.distance_mm = 300

    # default orientation is with a axis down the beam, lets pick a random one
    print('DEBUG: RANDOMIZE ORIENTATION - ', self.randomize)
    if self.randomize:
      self.SIM.randomize_orientation()
    # display randomly-picked missetting angles
    print('SIMTBX: MISSETTING ANGLES: ', self.SIM.missets_deg)
    # or an Arndt-Wonacott A matrix (U*B), same as used by mosflm
    print('SIMTBX: ARNDT-WONACOTT A MATRIX', self.SIM.Amatrix)

    # show all parameters
    print('SIMTBX: SHOWING PARAMETERS:')
    self.SIM.show_params()
    print('\n *** \n')

    # print 'SIMTBX: SETTING BEAM PARAMETERS'
    self.SIM.flux = 1e12
    # assumes round beam
    self.SIM.beamsize_mm = 0.1
    self.SIM.exposure_s = 1
    print('SIMTBX: FLUX = ', self.SIM.flux)
    print('SIMTBX: BEAM SIZE = {} mm'.format(self.SIM.beamsize_mm))
    print('SIMTBX: EXPOSURE = {} SEC'.format(self.SIM.exposure_s))

    # now actually run the simulation
    print('SIMTBX: ADDING SPOTS...')
    self.SIM.add_nanoBragg_spots()

    if self.crystal_size is not None:
      scale = (self.crystal_size/1000)**3 / (self.SIM.xtal_size_mm[0] *
                                              self.SIM.xtal_size_mm[1] *
                                              self.SIM.xtal_size_mm[2])
      print('SIMTBX: SCALING BY {} '.format(scale))

      self.SIM.raw_pixels *= scale

    if self.add_background:
      print('SIMTBX: ADDING WATER BACKGROUND')
      # rough approximation to water: interpolation points for sin(theta/lambda) vs structure factor
      bg = flex.vec2_double(
        [(0, 2.57), (0.0365, 2.58), (0.07, 2.8), (0.12, 5), (0.162, 8),
         (0.2, 6.75), (0.18, 7.32), (0.216, 6.75), (0.236, 6.5), (0.28, 4.5),
         (0.3, 4.3), (0.345, 4.36), (0.436, 3.77), (0.5, 3.17)])
      self.SIM.Fbg_vs_stol = bg
      self.SIM.amorphous_sample_thick_mm = 0.1
      self.SIM.amorphous_density_gcm3 = 1
      self.SIM.amorphous_molecular_weight_Da = 18
      self.SIM.add_background()

      print('SIMTBX: ADDING AIR BACKGROUND')
      bg = flex.vec2_double(
        [(0, 14.1), (0.045, 13.5), (0.174, 8.35), (0.35, 4.78), (0.5, 4.22)])
      self.SIM.Fbg_vs_stol = bg
      self.SIM.amorphous_sample_thick_mm = 35  # between beamstop and collimator
      self.SIM.amorphous_density_gcm3 = 1.2e-3
      self.SIM.amorphous_sample_molecular_weight_Da = 28  # nitrogen = N2
      self.SIM.add_background()

    # set this to 0 or -1 to trigger automatic radius.  could be very slow with bright images
    self.SIM.detector_psf_kernel_radius_pixels = 5
    self.SIM.detector_psf_fwhm_mm = 0.08
    self.SIM.detector_psf_type = shapetype.Fiber

    if self.add_noise:
      print('SIMTBX: ADDING NOISE...')
      self.SIM.add_noise()

    # write out a file on arbitrary scale, header contains beam center in various conventions
    print('DEBUG: FILENAME = ', self.img_file)
    print('SIMTBX: CONVERTING TO SMV FORMAT...')
    self.SIM.to_smv_format(fileout="intimage_001.img")

    # output image file
    if self.img_file is not None:
      self.SIM.to_smv_format(fileout=self.img_file)
      print('IMAGE WRITTEN TO ', self.img_file)

    # send pixels back to GUI when done
    try:
      evt = nanoBraggAllDone(tp_EVT_NBDONE, -1, pixels=self.SIM.raw_pixels)
      wx.PostEvent(self.parent, evt)
    except Exception as e:
      print(e)

  def fcalc_from_pdb(self, resolution=None, algorithm=None, wavelength=0.9):
    ''' Generate FCalc from PDB-formatted coordinates '''

    with open(self.params.reference_coordinates, 'r') as pdb_file:
      pdb_lines = pdb_file.readlines()

    # Read in coordinates
    pdb_inp = pdb.input(source_info=None, lines=pdb_lines)
    xray_structure = pdb_inp.xray_structure_simple()

    # take a detour to insist on calculating anomalous contribution of every atom
    scatterers = xray_structure.scatterers()
    for sc in scatterers:
      expected_henke = henke.table(sc.element_symbol()).at_angstrom(wavelength)
      sc.fp = expected_henke.fp()
      sc.fdp = expected_henke.fdp()

    # how do we do bulk solvent?
    primitive_xray_structure = xray_structure.primitive_setting()
    P1_primitive_xray_structure = primitive_xray_structure.expand_to_p1()
    fcalc = P1_primitive_xray_structure.structure_factors(
      d_min=resolution, anomalous_flag=True, algorithm=algorithm).f_calc()
    return fcalc.amplitudes()

# ------------------------------- MISCELLANEOUS ------------------------------ #

class ImageViewerThread(Thread):
  ''' Worker thread that will move the image viewer launch away from the GUI
  and hopefully will prevent the image selection dialog freezing on MacOS'''
  def __init__(self,
               parent,
               file_string,
               viewer='dials.image_viewer',
               img_type=None):
    Thread.__init__(self)
    self.parent = parent
    self.file_string = file_string
    self.viewer = viewer
    self.img_type = img_type

  def run(self):
    command = '{} {}'.format(self.viewer, self.file_string)
    easy_run.fully_buffered(command)


 *******************************************************************************
