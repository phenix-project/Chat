

 *******************************************************************************
mmtbx/maps/__init__.py
from __future__ import absolute_import, division, print_function
import iotbx.phil
from scitbx.array_family import flex
from libtbx.utils import Sorry, date_and_time
from libtbx import adopt_init_args
from libtbx.str_utils import show_string
from libtbx.math_utils import ifloor, iceil
import libtbx.callbacks # import dependency
import os
import sys
from mmtbx import map_tools
from cctbx import miller
from cctbx import maptbx
from six.moves import zip
from six.moves import range
from iotbx import extract_xtal_data

map_coeff_params_base_str = """\
  map_coefficients
    .multiple = True
    .short_caption = Map coefficients
    .style = auto_align
  {
    map_type = None
      .type = str
      .style = bold renderer:draw_map_type_widget
    format = *mtz phs
      .type = choice(multi=True)
    mtz_label_amplitudes = None
      .type = str
      .short_caption = MTZ label for amplitudes
      .style = bold
    mtz_label_phases = None
      .type = str
      .short_caption = MTZ label for phases
      .style = bold
    fill_missing_f_obs = False
      .type = bool
      .short_caption = Fill missing F(obs) with F(calc)
    acentrics_scale = 2.0
      .type = float
      .help = Scale terms corresponding to acentric reflections (residual maps only: k==n)
      .expert_level = 2
    centrics_pre_scale = 1.0
      .type = float
      .help = Centric reflections, k!=n and k*n != 0: \
              max(k-centrics_pre_scale,0)*Fo-max(n-centrics_pre_scale,0)*Fc
      .expert_level = 2
    sharpening = False
      .type = bool
      .help = Apply B-factor sharpening
      .short_caption = Apply B-factor sharpening
      .style = bold
    sharpening_b_factor = None
      .type = float
      .help = Optional sharpening B-factor value
      .short_caption = Sharpening B-factor value (optional)
    exclude_free_r_reflections = False
      .type = bool
      .help = Exclude free-R selected reflections from output map coefficients
      .short_caption = Exclude R-free set from map coefficients
    isotropize = True
      .type = bool
    dev
      .expert_level=3
    {
      complete_set_up_to_d_min = False
        .type = bool
      aply_same_incompleteness_to_complete_set_at = randomly low high
        .type = choice(multi=False)
    }
    %s
  }
"""

# for phenix.maps and phenix.refine
map_coeff_params_str = map_coeff_params_base_str % ""

map_params_base_str ="""\
  map
    .short_caption = XPLOR or CCP4 map
    .multiple = True
    .style = auto_align
  {
    map_type = None
      .type = str
      .expert_level=0
      .style = bold renderer:draw_map_type_widget
    format = xplor *ccp4
      .type = choice
      .short_caption = File format
      .caption = XPLOR CCP4
      .style = bold
    file_name = None
      .type = path
      .style = bold new_file
    fill_missing_f_obs = False
      .type = bool
      .expert_level=0
    grid_resolution_factor = 1/4.
      .type = float
      .expert_level=0
    scale = *sigma volume
      .type = choice(multi=False)
      .expert_level=2
    region = *selection cell
      .type = choice
      .caption = Atom_selection Unit_cell
      .short_caption=Map region
    atom_selection = None
      .type = atom_selection
      .short_caption = Atom selection
    atom_selection_buffer = 3
      .type = float
    acentrics_scale = 2.0
      .type = float
      .help = Scale terms corresponding to acentric reflections (residual maps only: k==n)
      .expert_level=2
    centrics_pre_scale = 1.0
      .type = float
      .help = Centric reflections, k!=n and k*n != 0: \
              max(k-centrics_pre_scale,0)*Fo-max(n-centrics_pre_scale,0)*Fc
      .expert_level=2
    sharpening = False
      .type = bool
      .help = Apply B-factor sharpening
      .short_caption = Apply B-factor sharpening
      .style = bold
    sharpening_b_factor = None
      .type = float
      .help = Optional sharpening B-factor value
      .short_caption = Sharpening B-factor value (optional)
    exclude_free_r_reflections = False
      .type = bool
      .help = Exclude free-R selected reflections from map calculation
    isotropize = True
      .type = bool
    %s
  }
"""

map_params_str = map_params_base_str % ""

# XXX for phenix.maps and phenix.refine
map_and_map_coeff_params_str = """\
%s
%s
"""%(map_coeff_params_str, map_params_str)

def map_and_map_coeff_master_params():
  return iotbx.phil.parse(map_and_map_coeff_params_str, process_includes=False)

maps_including_IO_params_str = """\
maps {
  input {
    pdb_file_name = None
      .type = path
      .optional = False
      .short_caption = Model file
      .style = bold file_type:pdb input_file
    reflection_data {
      %s
      r_free_flags {
        %s
      }
    }
  }
  output {
    directory = None
      .type = path
      .short_caption = Output directory
      .help = For GUI only.
      .style = bold output_dir noauto
    prefix = None
      .type = str
      .input_size = 100
      .short_caption = Output prefix
      .style = bold noauto
    include scope libtbx.phil.interface.tracking_params
    fmodel_data_file_format = mtz
      .optional=True
      .type=choice
      .help=Write Fobs, Fmodel, various scales and more to MTZ file
    include_r_free_flags = False
      .type = bool
      .short_caption = Include R-free flags in output MTZ file
  }
  scattering_table = wk1995  it1992  *n_gaussian  neutron electron
    .type = choice
    .help = Choices of scattering table for structure factors calculations
  wavelength = None
    .type = float(value_min=0.2, value_max=10.)
    .input_size = 80
    .help = Optional X-ray wavelength (in Angstroms), which will be used to \
      set the appropriate anomalous scattering factors for the model.  This \
      will only affect the LLG map from Phaser.
  bulk_solvent_correction = True
    .type = bool
  anisotropic_scaling = True
    .type = bool
  skip_twin_detection = False
    .type = bool
    .short_caption = Skip automatic twinning detection
    .help = Skip automatic twinning detection
  omit {
    method = *simple
      .type = choice(multi=False)
    selection = None
      .type = str
      .short_caption = Omit selection
      .input_size = 400
  }
  %s
  %s
}
"""%(extract_xtal_data.data_and_flags_str_part1,
     extract_xtal_data.data_and_flags_str_part2,
     map_coeff_params_str,
     map_params_str)

# XXX for documentation
master_params = maps_including_IO_params_str

def maps_including_IO_master_params():
  return iotbx.phil.parse(maps_including_IO_params_str, process_includes=True)

def cast_map_coeff_params(map_type_obj):
  map_coeff_params_str = """\
    map_coefficients
    {
      format = *mtz phs
      mtz_label_amplitudes = %s
      mtz_label_phases = P%s
      map_type = %s
      fill_missing_f_obs = %s
    }
"""%(map_type_obj.format(), map_type_obj.format(), map_type_obj.format(),
     map_type_obj.f_obs_filled)
  return iotbx.phil.parse(map_coeff_params_str, process_includes=False)

class map_coeffs_mtz_label_manager:

  def __init__(self, map_params):
    self._amplitudes = map_params.mtz_label_amplitudes
    self._phases = map_params.mtz_label_phases
    if(self._amplitudes is None): self._amplitudes = str(map_params.map_type)
    if(self._phases is None): self._phases = "PH"+str(map_params.map_type)

  def amplitudes(self):
    return self._amplitudes

  def phases(self, root_label, anomalous_sign=None):
    assert anomalous_sign is None or not anomalous_sign
    return self._phases

class write_xplor_map_file(object):

  def __init__(self, params, coeffs, atom_selection_manager=None,
               xray_structure=None):
    adopt_init_args(self, locals())
    fft_map = coeffs.fft_map(resolution_factor =
      self.params.grid_resolution_factor)
    if(self.params.scale == "volume"): fft_map.apply_volume_scaling()
    elif(self.params.scale == "sigma"): fft_map.apply_sigma_scaling()
    else: raise RuntimeError
    title_lines=["REMARK file: %s" %
      show_string(os.path.basename(self.params.file_name))]
    title_lines.append("REMARK directory: %s" %
      show_string(os.path.dirname(self.params.file_name)))
    title_lines.append("REMARK %s" % date_and_time())
    assert self.params.region in ["selection", "cell"]
    if(self.params.region == "selection" and xray_structure is not None):
      map_iselection = None
      if atom_selection_manager is not None :
        map_iselection = self.atom_iselection()
      frac_min, frac_max = self.box_around_selection(
        iselection = map_iselection,
        buffer     = self.params.atom_selection_buffer)
      n_real = fft_map.n_real()
      gridding_first=[ifloor(f*n) for f,n in zip(frac_min,n_real)]
      gridding_last=[iceil(f*n) for f,n in zip(frac_max,n_real)]
      title_lines.append('REMARK map around selection')
      title_lines.append('REMARK   atom_selection=%s' %
        show_string(self.params.atom_selection))
      title_lines.append('REMARK   atom_selection_buffer=%.6g' %
        self.params.atom_selection_buffer)
      if(map_iselection is None):
        sel_size = self.xray_structure.scatterers().size()
      else:
        sel_size = map_iselection.size()
      title_lines.append('REMARK   number of atoms selected: %d' % sel_size)
    else:
      gridding_first = None
      gridding_last = None
      title_lines.append("REMARK map covering the unit cell")
    if params.format == "xplor" :
      fft_map.as_xplor_map(
        file_name      = self.params.file_name,
        title_lines    = title_lines,
        gridding_first = gridding_first,
        gridding_last  = gridding_last)
    else :
      fft_map.as_ccp4_map(
        file_name      = self.params.file_name,
        gridding_first = gridding_first,
        gridding_last  = gridding_last,
        labels=title_lines)

  def box_around_selection(self, iselection, buffer):
    sites_cart = self.xray_structure.sites_cart()
    if(iselection is not None):
      sites_cart = sites_cart.select(iselection)
    return self.xray_structure.unit_cell().box_frac_around_sites(
      sites_cart = sites_cart, buffer = buffer)

  def atom_iselection(self):
    if(self.params.region != "selection" or self.params.atom_selection is None):
      return None
    try:
      result = self.atom_selection_manager.selection(string =
        self.params.atom_selection).iselection()
    except KeyboardInterrupt: raise
    except Exception:
      raise Sorry('Invalid atom selection: %s' % self.params.atom_selection)
    if(result.size() == 0):
      raise Sorry('Empty atom selection: %s' % self.params.atom_selection)
    return result

def compute_f_calc(fmodel, params):
  from cctbx import miller
  coeffs_partial_set = fmodel.f_obs().structure_factors_from_scatterers(
    xray_structure = fmodel.xray_structure).f_calc()
  if(hasattr(params,"dev") and params.dev.complete_set_up_to_d_min):
    coeffs = fmodel.xray_structure.structure_factors(
      d_min = fmodel.f_obs().d_min()).f_calc()
    frac_inc = 1.*coeffs_partial_set.data().size()/coeffs.data().size()
    n_miss = coeffs.data().size() - coeffs_partial_set.data().size()
    if(params.dev.aply_same_incompleteness_to_complete_set_at == "randomly"):
      sel = flex.random_bool(coeffs.data().size(), frac_inc)
      coeffs = coeffs.select(sel)
    elif(params.dev.aply_same_incompleteness_to_complete_set_at == "low"):
      coeffs = coeffs.sort()
      coeffs = miller.set(
        crystal_symmetry = coeffs,
        indices = coeffs.indices()[n_miss+1:],
        anomalous_flag = coeffs.anomalous_flag()).array(
        data = coeffs.data()[n_miss+1:])
    elif(params.dev.aply_same_incompleteness_to_complete_set_at == "high"):
      coeffs = coeffs.sort(reverse=True)
      coeffs = miller.set(
        crystal_symmetry = coeffs,
        indices = coeffs.indices()[n_miss+1:],
        anomalous_flag = coeffs.anomalous_flag()).array(
        data = coeffs.data()[n_miss+1:])
  else:
    coeffs = coeffs_partial_set
  return coeffs

def map_coefficients_from_fmodel(
      params,
      fmodel = None,
      map_calculation_server = None,
      post_processing_callback=None,
      pdb_hierarchy=None):
  assert [fmodel, map_calculation_server].count(None) == 1
  from mmtbx import map_tools
  import mmtbx
  from cctbx import miller
  mnm = mmtbx.map_names(map_name_string = params.map_type)
  if(mnm.k==0 and abs(mnm.n)==1):
    # FIXME Fcalc maps require that fmodel is not None!
    if (fmodel is None):
      fmodel = map_calculation_server.fmodel
    return compute_f_calc(fmodel, params)
  if(fmodel is not None and
     fmodel.is_twin_fmodel_manager() and
     mnm.phaser_sad_llg):
    return None
  if(fmodel is not None):
    e_map_obj = fmodel.electron_density_map()
    xrs = fmodel.xray_structure
  else:
    e_map_obj = map_calculation_server
    xrs = map_calculation_server.fmodel.xray_structure
  coeffs = None
  coeffs = e_map_obj.map_coefficients(
    map_type           = params.map_type,
    acentrics_scale    = params.acentrics_scale,
    centrics_pre_scale = params.centrics_pre_scale,
    fill_missing       = params.fill_missing_f_obs,
    isotropize         = params.isotropize,
    exclude_free_r_reflections=params.exclude_free_r_reflections,
    pdb_hierarchy=pdb_hierarchy,
    merge_anomalous=True)
  if (coeffs is None) : return None
  if(params.sharpening):
    from mmtbx import map_tools
    coeffs, b_sharp = map_tools.sharp_map(
      sites_frac = xrs.sites_frac(),
      map_coeffs = coeffs,
      b_sharp    = params.sharpening_b_factor)
  # XXX need to figure out why this happens
  if (coeffs is None):
    raise RuntimeError(("Map coefficient generation failed (map_type=%s, "
      "sharpening=%s, isotropize=%s, anomalous=%s.") %
        (params.map_type, params.sharpening, params.isotropize,
         fmodel.f_obs().anomalous_flag()))
  if(coeffs.anomalous_flag()):
    coeffs = coeffs.average_bijvoet_mates()
  return coeffs

def compute_xplor_maps(
    fmodel,
    params,
    atom_selection_manager=None,
    file_name_prefix=None,
    file_name_base=None,
    post_processing_callback=None,
    pdb_hierarchy=None):
  assert ((post_processing_callback is None) or
          (hasattr(post_processing_callback, "__call__")))
  output_files = []
  for mp in params:
    if(mp.map_type is not None):
      coeffs = map_coefficients_from_fmodel(fmodel = fmodel,
        params = mp,
        post_processing_callback=post_processing_callback,
        pdb_hierarchy=pdb_hierarchy)
      if (coeffs is None):
        raise Sorry("Couldn't generate map type '%s'." % mp.map_type)
      if(mp.file_name is None):
        output_file_name = ""
        if(file_name_prefix is not None): output_file_name = file_name_prefix
        if(file_name_base is not None):
          if(len(output_file_name)>0):
            output_file_name = output_file_name + "_"+file_name_base
          else: output_file_name = output_file_name + file_name_base
        if mp.format == "xplor" :
          ext = ".xplor"
        else :
          ext = ".ccp4"
        output_file_name = output_file_name + "_" + mp.map_type + "_map" + ext
        mp.file_name = output_file_name
      write_xplor_map_file(params = mp, coeffs = coeffs,
        atom_selection_manager = atom_selection_manager,
        xray_structure = fmodel.xray_structure)
      output_files.append(mp.file_name)
  return output_files

class compute_map_coefficients(object):

  def __init__(self,
               fmodel,
               params,
               mtz_dataset = None,
               post_processing_callback=None,
               pdb_hierarchy=None,
               log=sys.stdout):
    assert ((post_processing_callback is None) or
            (hasattr(post_processing_callback, "__call__")))
    self.mtz_dataset = mtz_dataset
    coeffs = None
    # Avoid doing slow calculation several times!
    map_calculation_server = fmodel.electron_density_map()
    self.map_coeffs = []
    for mcp in params:
      if(mcp.map_type is not None):
        if(fmodel.is_twin_fmodel_manager()) and (mcp.isotropize):
          mcp.isotropize = False
        coeffs = map_coefficients_from_fmodel(
          map_calculation_server   = map_calculation_server,
          params                   = mcp,
          post_processing_callback = post_processing_callback,
          pdb_hierarchy            = pdb_hierarchy)
        if("mtz" in mcp.format and coeffs is not None):
          if coeffs.anomalous_flag():
            coeffs = coeffs.average_bijvoet_mates()
          lbl_mgr = map_coeffs_mtz_label_manager(map_params = mcp)
          if(self.mtz_dataset is None):
            self.mtz_dataset = coeffs.as_mtz_dataset(
              column_root_label = lbl_mgr.amplitudes(),
              label_decorator   = lbl_mgr)
          else:
            self.mtz_dataset.add_miller_array(
              miller_array      = coeffs,
              column_root_label = lbl_mgr.amplitudes(),
              label_decorator   = lbl_mgr)
          self.map_coeffs.append(coeffs)
        elif (coeffs is None):
          if ((mcp.map_type == "anomalous") and
              (not fmodel.f_obs().anomalous_flag())):
            # since anomalous map is included in the defaults, even if the
            # data are merged, no warning is issued here
            pass
          else :
            libtbx.warn(("Map coefficients not available for map type '%s'; "+
              "usually means you have requested an anomalous map but supplied "+
              "merged data, or indicates a twinning-related incompatibility.")%
              mcp.map_type)

  def write_mtz_file(self, file_name, mtz_history_buffer = None,
      r_free_flags=None):
    from cctbx.array_family import flex
    if(self.mtz_dataset is not None):
      if (r_free_flags is not None):
        self.mtz_dataset.add_miller_array(r_free_flags,
          column_root_label="FreeR_flag")
      if(mtz_history_buffer is None):
        mtz_history_buffer = flex.std_string()
      mtz_history_buffer.append(date_and_time())
      mtz_history_buffer.append("> file name: %s" % os.path.basename(file_name))
      mtz_object = self.mtz_dataset.mtz_object()
      mtz_object.add_history(mtz_history_buffer)
      mtz_object.write(file_name = file_name)
      return True
    return False

def b_factor_sharpening_by_map_kurtosis_maximization(map_coeffs, show=True,
      b_sharp_best=None, b_only=False, b_min=-100, b_max=100, b_step=5):
  ss = 1./flex.pow2(map_coeffs.d_spacings().data()) / 4.
  if(b_sharp_best is None):
    b_sharp_best = None
    kurt = -999
    for b_sharp in range(b_min,b_max,b_step):
      k_sharp = 1./flex.exp(-ss * b_sharp)
      map_coeffs_ = map_coeffs.deep_copy().customized_copy(
        data = map_coeffs.data()*k_sharp)
      fft_map = map_coeffs_.fft_map(resolution_factor = 0.25)
      fft_map.apply_sigma_scaling()
      map_data = fft_map.real_map_unpadded()
      o = maptbx.more_statistics(map_data)
      kurt_ = o.kurtosis()
      if(kurt_ > kurt):
        kurt = kurt_
        b_sharp_best = b_sharp
      if(show):
        print("b_sharp: %6.1f skewness: %6.4f kurtosis: %6.4f"%(b_sharp,
          o.skewness(), o.kurtosis()))
  if(show): print("Best sharpening B-factor:", b_sharp_best)
  k_sharp = 1./flex.exp(-ss * b_sharp_best)
  if(b_only): return b_sharp_best
  else:
    return map_coeffs.customized_copy(data = map_coeffs.data()*k_sharp)


 *******************************************************************************


 *******************************************************************************
mmtbx/maps/composite_omit_map.py

"""
Methods and utilities for generating composite omit maps.  The actual
end-user application, phenix.composite_omit_map, is part of the phenix
sources.
"""

from __future__ import absolute_import, division, print_function
import mmtbx.f_model
from cctbx import miller
from cctbx import maptbx
import cctbx.miller
from scitbx.array_family import flex
import boost_adaptbx.boost.python as bp
from six.moves import zip
from six.moves import range
asu_map_ext = bp.import_ext("cctbx_asymmetric_map_ext")
from libtbx import slots_getstate_setstate, \
  slots_getstate_setstate_default_initializer
from libtbx.utils import null_out
import libtbx.phil
import operator
import sys
from libtbx import adopt_init_args
import mmtbx.real_space

omit_map_phil = libtbx.phil.parse("""
n_debias_cycles = 2
  .type = int
neutral_volume_box_cushion_width = 1
  .type = float
full_resolution_map = True
  .type = bool
""")

class run(object):
  """
  Composite residual OMIT map. Details:
    Afonine et al. (2014). FEM: Feature Enhanced Map
  """
  def __init__(
        self,
        fmodel,
        crystal_gridding,
        box_size_as_fraction=0.1,
        max_boxes=2000,
        neutral_volume_box_cushion_width=2,
        full_resolution_map=True,
        log=sys.stdout):
    adopt_init_args(self, locals())
    self.map_type="mFo-DFc" # using other map types is much worse
    self.sd = self.get_p1_map_unscaled(fmodel = self.fmodel,
      map_type=self.map_type).sample_standard_deviation()
    xrs_p1 = fmodel.xray_structure.expand_to_p1(sites_mod_positive=True)
    self.sgt = fmodel.f_obs().space_group().type()
    self.r = flex.double() # for tests only
    self.acc_asu = None
    # bulk-solvent
    mp = mmtbx.masks.mask_master_params.extract()
    mp.n_real = crystal_gridding.n_real()
    mp.step=None
    mmtbx_masks_asu_mask_obj = mmtbx.masks.asu_mask(
      xray_structure = xrs_p1,
      mask_params = mp)
    self.bulk_solvent_mask = mmtbx_masks_asu_mask_obj.mask_data_whole_uc()
    self.bulk_solvent_mask_asu=self.to_asu_map(map_data=self.bulk_solvent_mask)
    # atom map
    self.atom_map = mmtbx.real_space.sampled_model_density(
      xray_structure = xrs_p1,
      n_real         = crystal_gridding.n_real()).data()
    self.n_real = self.atom_map.focus()
    self.atom_map_asu=self.to_asu_map(map_data=self.atom_map)
    # extras
    self.zero_cmpl_ma = fmodel.f_calc().customized_copy(
      data = flex.complex_double(fmodel.f_calc().size(), 0))
    self.r_factor_omit = flex.double() # for regression test only
    # result map
    self.map_result_asu = flex.double(flex.grid(self.atom_map_asu.focus()))
    # iterate over boxes
    self.box_iterator()

  def map_coefficients(self, filter_noise=True):
    map_coefficients = self.result_as_sf()
    if(filter_noise):
      return self.noise_filtered_map_coefficients(
        map_coefficients=map_coefficients)
    else:
      return map_coefficients

  def noise_filtered_map_coefficients(self, map_coefficients):
    from mmtbx.maps import fem
    f_map = self.fmodel.electron_density_map().map_coefficients(
      map_type                   = "2mFo-DFc",
      isotropize                 = True,
      exclude_free_r_reflections = False,
      fill_missing               = True)
    selection = fem.good_atoms_selection(
      crystal_gridding = self.crystal_gridding,
      map_coeffs       = f_map,#map_coefficients,
      xray_structure   = self.fmodel.xray_structure)
    fft_map = cctbx.miller.fft_map(
      crystal_gridding     = self.crystal_gridding,
      fourier_coefficients = map_coefficients)
    fft_map.apply_sigma_scaling()
    m = fft_map.real_map_unpadded()
    m = fem.low_volume_density_elimination(m=m, fmodel=self.fmodel,
      selection=selection, end=11)
    ### Filter by 2mFo-DFc filled map
    fft_map = cctbx.miller.fft_map(
      crystal_gridding     = self.crystal_gridding,
      fourier_coefficients = f_map)
    fft_map.apply_sigma_scaling()
    filter_mask = fft_map.real_map_unpadded()
    filter_mask = fem.low_volume_density_elimination(m=filter_mask,
      fmodel=self.fmodel, selection=selection, end=6)#11)
    sel = filter_mask<0.25
    filter_mask = filter_mask.set_selected(sel, 0)
    sel = filter_mask>=0.25
    filter_mask = filter_mask.set_selected(sel, 1)
    ###
    return map_coefficients.structure_factors_from_map(
      map            = m*filter_mask,
      use_scale      = True,
      anomalous_flag = False,
      use_sg         = False)

  def box_iterator(self):
    b = maptbx.boxes(
      n_real   = self.atom_map_asu.focus(),
      fraction = self.box_size_as_fraction,
      max_boxes= self.max_boxes,
      log      = self.log)
    def get_wide_box(s,e): # define wide box: neutral + phased volumes
      if(self.neutral_volume_box_cushion_width>0):
        sh = self.neutral_volume_box_cushion_width
        ss = [max(s[i]-sh,0) for i in [0,1,2]]
        ee = [min(e[i]+sh,n_real_asu[i]) for i in [0,1,2]]
      else: ss,ee = s,e
      return ss,ee
    n_real_asu = b.n_real
    n_boxes = len(b.starts)
    i_box = 0
    for s,e in zip(b.starts, b.ends):
      i_box+=1
      sw,ew = get_wide_box(s=s,e=e)
      fmodel_omit = self.omit_box(start=sw, end=ew)
      r = fmodel_omit.r_work()
      self.r.append(r) # for tests only
      if(self.log):
        print("r(curr,min,max,mean)=%6.4f %6.4f %6.4f %6.4f"%(r,
          flex.min(self.r), flex.max(self.r), flex.mean(self.r)), i_box, n_boxes, file=self.log)
      omit_map_data = self.asu_map_from_fmodel(
        fmodel=fmodel_omit, map_type=self.map_type)
      maptbx.copy_box(
        map_data_from = omit_map_data,
        map_data_to   = self.map_result_asu,
        start         = s,
        end           = e)
    self.map_result_asu.reshape(self.acc_asu)

  def result_as_sf(self):
    asu_map_omit = asu_map_ext.asymmetric_map(
      self.sgt, self.map_result_asu, self.n_real)
    map_coefficients = self.zero_cmpl_ma.customized_copy(
      indices = self.zero_cmpl_ma.indices(),
      data    = asu_map_omit.structure_factors(self.zero_cmpl_ma.indices()))
    # full resolution map (reflections in sphere, not in box!)
    if(self.full_resolution_map):
      full_set = self.zero_cmpl_ma.complete_set(d_min=self.zero_cmpl_ma.d_min())
      fill = self.zero_cmpl_ma.customized_copy(
        indices = full_set.indices(),
        data    = asu_map_omit.structure_factors(full_set.indices()))
      map_coefficients = map_coefficients.complete_with(
        other=fill, scale=True)
    return map_coefficients

  def to_asu_map(self, map_data):
    r = asu_map_ext.asymmetric_map(self.sgt, map_data).data()
    if(self.acc_asu is None): self.acc_asu = r.accessor()
    # Why I'm doing this? This may be a bug for some SG!
    # See: exercise_structure_factors_from_map_and_asu_map in miller tests.
    return r.shift_origin()

  def omit_box(self, start, end):
    def asu_omit_map_as_sf(m_asu, s, e):
      m_asu_omit = maptbx.set_box_copy(value = 0, map_data_to = m_asu,
        start = s, end = e)
      m_asu_omit.reshape(self.acc_asu)
      asu_m_omit = asu_map_ext.asymmetric_map(self.sgt, m_asu_omit, self.n_real)
      return self.zero_cmpl_ma.customized_copy(
        indices = self.zero_cmpl_ma.indices(),
        data    = asu_m_omit.structure_factors(self.zero_cmpl_ma.indices()))
    f_calc_omit = asu_omit_map_as_sf(m_asu=self.atom_map_asu, s=start, e=end)
    f_mask_omit = asu_omit_map_as_sf(m_asu=self.bulk_solvent_mask_asu,
      s=start, e=end)
    fmodel_omit = mmtbx.f_model.manager(
      f_obs        = self.fmodel.f_obs(),
      r_free_flags = self.fmodel.r_free_flags(),
      k_isotropic  = self.fmodel.k_isotropic(),
      k_anisotropic= self.fmodel.k_anisotropic(),
      k_mask       = self.fmodel.k_masks(),
      f_calc       = f_calc_omit,
      f_mask       = f_mask_omit)
    return fmodel_omit

  def as_p1_map(self, map_asu=None):
    if(map_asu is None): map_asu = self.map_result_asu
    asu_map_omit = asu_map_ext.asymmetric_map(self.sgt, map_asu, self.n_real)
    p1_map = asu_map_omit.symmetry_expanded_map()
    maptbx.unpad_in_place(map=p1_map)
    sd = p1_map.sample_standard_deviation()
    if(sd != 0):
      p1_map = p1_map/sd
    return p1_map

  def get_p1_map_unscaled(self, fmodel, map_type):
    f_map = fmodel.electron_density_map().map_coefficients(
      map_type                   = map_type,
      isotropize                 = True,
      exclude_free_r_reflections = True,
      fill_missing               = False)
    fft_map = cctbx.miller.fft_map(
      crystal_gridding     = self.crystal_gridding,
      fourier_coefficients = f_map)
    return fft_map.real_map_unpadded()

  def asu_map_from_fmodel(self, fmodel, map_type):
    map_data = self.get_p1_map_unscaled(fmodel=fmodel, map_type=map_type)
    return asu_map_ext.asymmetric_map(self.sgt, map_data).data().shift_origin()

################################################################################

########################################################################
# XXX LEGACY IMPLEMENTATION
#
# The code below is similar to the method used by CNS, which operates on
# xray scatterers rather than the map itself.  As a result it requires
# refinement (w/ annealing) of the partial model to thoroughly de-bias
# the phases, and is therefore much slower than the protocol above.  It
# is preserved for maximum flexibility and because the same underlying
# method is also useful for analyzing static disorder at high resolution.
#
# Note that most of the program logic lives in the phenix tree due to
# its use of phenix.refine.

class omit_box(slots_getstate_setstate_default_initializer):
  """
  Defines a region in fractional coordinates containing a selection of atoms
  to be omitted.
  """
  __slots__ = [ "frac_min", "frac_max", "selection", "serial" ]

  @property
  def n_atoms(self):
    return len(self.selection)

  def show(self, out=sys.stdout, prefix=""):
    print(prefix + \
      "box %d: atoms: %6d  extents: (%.4f, %.4f, %.4f) to (%.4f, %.4f, %.4f)" \
      % tuple([ self.serial, len(self.selection) ] +
        list(self.frac_min) + list(self.frac_max)), file=out)

class omit_regions(slots_getstate_setstate):
  """
  Groups together multiple omit_box objects (without any implicit spatial
  relationship); this is used to reduce the total number of bins of omitted
  atoms and to make the fraction omitted per bin approximately similar.
  """
  __slots__ = [ "boxes", "selection", "serial" ]
  def __init__(self, serial, selection=None):
    self.serial = serial
    self.boxes = []
    self.selection = selection
    if (selection is None):
      self.selection = flex.size_t()

  @property
  def n_boxes(self):
    return len(self.boxes)

  @property
  def n_atoms(self):
    return len(self.selection)

  def add_box(self, box):
    self.boxes.append(box)
    self.selection = join_selections(box.selection, self.selection)
    return self

  def combine_with(self, other):
    for box in other.boxes :
      self.add_box(box)
    return self

  def show(self, out=sys.stdout, prefix=""):
    if (len(self.boxes) == 0):
      print(prefix + "Region %d: empty" % self.serial, file=out)
    else :
      print(prefix + "Region %d:" % self.serial, file=out)
      for box in self.boxes :
        box.show(out=out, prefix=prefix+"  ")

class omit_region_results(slots_getstate_setstate_default_initializer):
  __slots__ = [ "serial", "map_coeffs_list", "r_work", "r_free" ]

def create_omit_regions(xray_structure,
    selection=None,
    fraction_omit=0.05,
    optimize_binning=True,
    box_cushion_radius=2.5,
    even_boxing=False,
    asu_buffer_thickness=1.e-5,
    log=None):
  """
  Divide the asymmetric unit into boxes of atoms to omit.  This will include
  a cushion around the actual omit region.  Although the step size is uniform,
  by default boxes will be grouped as needed to make the distribution roughly
  even and keep the total number of omit regions to a minimum.
  If a region does not contain any atoms, it will be skipped and filled in
  with the background map.

  Returns a list of omit_regions objects, which specify the selection of atoms
  to omit along with the boxes of interest (in fractional coordinates).
  """
  if (log is None) : log = null_out()
  if (selection is None):
    selection = flex.bool(xray_structure.scatterers().size(), True)
  iselection = selection.iselection()
  boxes = []
  xrs = xray_structure.sites_mod_positive()
  unit_cell = xrs.unit_cell()
  asu_mappings = xrs.asu_mappings(buffer_thickness=asu_buffer_thickness)
  asu = asu_mappings.asu()
  #print asu.box_min(), asu.box_max()
  sites_asu = flex.vec3_double()
  for i_seq, mappings in enumerate(asu_mappings.mappings()):
    if (not selection[i_seq]) : continue
    for mapping in mappings :
      site_cart = mapping.mapped_site()
      site_frac = unit_cell.fractionalize(site_cart=site_cart)
      sites_asu.append(site_frac)
      break
  x_cushion, y_cushion, z_cushion = unit_cell.fractionalize(
    site_cart=[ box_cushion_radius ] * 3)
  x_min, y_min, z_min = sites_asu.min()
  x_max, y_max, z_max = sites_asu.max()
  #print "min", x_min, y_min, z_min
  #print "max", x_max, y_max, z_max
  non_hd_sel = ~(xray_structure.hd_selection())
  n_omit_heavy_atoms = non_hd_sel.select(iselection).count(True)
  n_omit_per_box = n_omit_heavy_atoms * fraction_omit
  assert (n_omit_heavy_atoms > 0)
  if (even_boxing) : # XXX remove?
    x_step = asu_buffer_thickness + (x_max - x_min) / 4
    y_step = asu_buffer_thickness + (y_max - y_min) / 4
    z_step = asu_buffer_thickness + (z_max - z_min) / 2
  else :
    volume = n_omit_heavy_atoms * 9.0
    cube_length = (volume * fraction_omit) ** (1/3.)
    x_step, y_step, z_step = unit_cell.fractionalize(site_cart=[cube_length]*3)
  # to facilitate using the C++ loops to determine which sites fall inside the
  # box, we first split the fractional coordinates into separate x, y, z 1D
  # arrays.  not sure if there's a better way.
  sites_1d = sites_asu.as_double()
  sel_base = flex.size_t(range(len(sites_asu)))
  sites_x = sites_1d.select(sel_base*3)
  sites_y = sites_1d.select(sel_base*3+1)
  sites_z = sites_1d.select(sel_base*3+2)
  x_start = x_min
  serial = 1
  while (x_start < x_max):
    y_start = y_min
    while (y_start < y_max):
      z_start = z_min
      while (z_start < z_max):
        x_end = x_start + x_step
        y_end = y_start + y_step
        z_end = z_start + z_step
        x_min_box = x_start - x_cushion
        x_max_box = x_end + x_cushion
        y_min_box = y_start - y_cushion
        y_max_box = y_end + y_cushion
        z_min_box = z_start - z_cushion
        z_max_box = z_end + z_cushion
        box_selection = ((sites_x >= x_min_box) & (sites_x < x_max_box) &
                         (sites_y >= y_min_box) & (sites_y < y_max_box) &
                         (sites_z >= z_min_box) & (sites_z < z_max_box))
        box_iselection = box_selection.iselection()
        n_atoms_current_box = len(box_iselection)
        if (n_atoms_current_box > 0):
          frac_max = [min(x_end, 1.0), min(y_end, 1.0), min(z_end, 1.0)]
          new_box = omit_box(
            frac_min=[x_start, y_start, z_start],
            frac_max=frac_max,
            selection=iselection.select(box_iselection),
            serial=serial)
          boxes.append(new_box)
          serial += 1
        z_start += z_step
      y_start += y_step
    x_start += x_step
  groups = []
  for box in boxes :
    group = omit_regions(serial=box.serial).add_box(box)
    groups.append(group)
  if (optimize_binning):
    # http://en.wikipedia.org/wiki/Bin_packing_problem
    groups = sorted(groups, key=operator.attrgetter("n_atoms"), reverse=True)
    while True :
      n_combined = 0
      i_group = 0
      while i_group < len(groups):
        groups[i_group].serial = i_group + 1
        j_group = 0
        while j_group < i_group :
          n_atoms_combined = groups[i_group].n_atoms + groups[j_group].n_atoms
          if (n_atoms_combined <= n_omit_per_box):
            groups[j_group].combine_with(groups[i_group])
            del groups[i_group]
            n_combined += 1
            break
          j_group += 1
        i_group += 1
      if (n_combined == 0):
        break
  assert (len(set([ g.serial for g in groups ])) == len(groups))
  return groups

def join_selections(sel1, sel2):
  intersections = sel1.intersection_i_seqs(sel2)
  unique_sel = flex.bool(len(sel1), True)
  unique_sel.set_selected(intersections[0], False)
  sel1 = sel1.select(unique_sel)
  sel1.extend(sel2)
  return flex.sorted(sel1)

def combine_maps(
    map_arrays,
    omit_groups,
    background_map_coeffs,
    resolution_factor,
    flatten_background=False,
    sigma_scaling=False,
    control_map=False):
  """
  For each box, FFT the corresponding omit map coefficients, extract the
  omit regions, and copy them to the combined map, using Marat's asymmetric
  map class to handle symmetry expansion internally.
  """
  assert len(map_arrays) == len(omit_groups)
  space_group = background_map_coeffs.space_group()
  fft_map = background_map_coeffs.fft_map(
    symmetry_flags=maptbx.use_space_group_symmetry,
    resolution_factor=resolution_factor).apply_volume_scaling()
  if (sigma_scaling):
    fft_map.apply_sigma_scaling()
  background_map = fft_map.real_map_unpadded()
  #print "full map:", background_map.focus()
  if (flatten_background):
    sel_all = flex.bool(background_map.as_1d().size(), True)
    background_map.as_1d().set_selected(sel_all, 0)
  asym_map = asu_map_ext.asymmetric_map(space_group.type(), background_map)
  origin = asym_map.data().origin()
  n_real_all = background_map.focus()
  n_real_asu = asym_map.data().focus()
  m_real_asu = asym_map.data().all()
  #print "ORIGIN:", origin
  #print "N_REAL:", n_real_asu
  #print "M_REAL:", m_real_asu
  if (not control_map):
    f2g = maptbx.frac2grid(n_real_all)
    n = 0
    for group, map_coeffs in zip(omit_groups, map_arrays):
      space_group = map_coeffs.space_group()
      omit_fft_map = map_coeffs.fft_map(
        resolution_factor=resolution_factor,
        symmetry_flags=maptbx.use_space_group_symmetry).apply_volume_scaling()
      if (sigma_scaling):
        omit_fft_map.apply_sigma_scaling()
      omit_map = omit_fft_map.real_map_unpadded()
      omit_asym_map = asu_map_ext.asymmetric_map(space_group.type(), omit_map)
      assert omit_asym_map.data().focus() == n_real_asu
      for box in group.boxes :
        if (control_map) : continue
        grid_start = tuple(f2g(box.frac_min))
        grid_end = grid_max(f2g(box.frac_max), n_real_asu)
        #print grid_start, grid_end
        for u in range(grid_start[0], grid_end[0]+1):
          for v in range(grid_start[1], grid_end[1]+1):
            for w in range(grid_start[2], grid_end[2]+1):
              try :
                asym_map.data()[(u,v,w)] = omit_asym_map.data()[(u,v,w)]
              except IndexError :
                raise IndexError("n_real: %s  origin: %s  index: %s" %
                  (str(n_real_asu), str(origin), str((u,v,w))))
  return asym_map.map_for_fft()

def grid_max(grid_coords, n_real):
  return (min(grid_coords[0], n_real[0]-1), min(grid_coords[1], n_real[1]-1),
          min(grid_coords[2], n_real[2]-1))


 *******************************************************************************


 *******************************************************************************
mmtbx/maps/correlation.py
from __future__ import absolute_import, division, print_function
from libtbx import adopt_init_args
from scitbx.array_family import flex
from cctbx import maptbx
from cctbx import miller
from cctbx import adptbx
from mmtbx import masks
import sys
import boost_adaptbx.boost.python as bp
from six.moves import range
cctbx_maptbx_ext = bp.import_ext("cctbx_maptbx_ext")
from libtbx import group_args
from mmtbx.maps import map_tools

def get_selection_above_cutoff(m, n):
  return m>=m.as_1d().select(flex.sort_permutation(m.as_1d(), reverse=True))[n]

class five_cc(object):
  def __init__(self,
               map,
               xray_structure,
               d_min,
               box=None,
               keep_map_calc=False,
               compute_cc_box=False,
               compute_cc_image=False,
               compute_cc_mask=True,
               compute_cc_volume=True,
               compute_cc_peaks=True):
    adopt_init_args(self, locals())
    if(box is None and
       xray_structure.crystal_symmetry().space_group().type().number()==1):
      box=True
    else:
      box=False
    #
    cc_box    = None
    cc_image  = None
    cc_mask   = None
    cc_volume = None
    cc_peaks  = None
    #
    self.crystal_gridding = maptbx.crystal_gridding(
      unit_cell             = xray_structure.unit_cell(),
      space_group_info      = xray_structure.space_group_info(),
      pre_determined_n_real = map.accessor().all(),
      symmetry_flags        = maptbx.use_space_group_symmetry)
    self.atom_radius = None
    bs_mask = masks.mask_from_xray_structure(
      xray_structure        = self.xray_structure,
      p1                    = True,
      for_structure_factors = False,
      n_real                = self.map.accessor().all()).mask_data
    maptbx.unpad_in_place(map=bs_mask)
    self.sel_inside = (bs_mask==0.).iselection()
    self.n_nodes_inside = self.sel_inside.size()
    del bs_mask
    #
    map_calc = self._get_map_calc()
    #
    if(compute_cc_mask):
      cc_mask = from_map_map_selection(map_1=self.map, map_2=map_calc,
        selection = self.sel_inside)
    del self.sel_inside
    if(compute_cc_box):
      cc_box = from_map_map(map_1=self.map, map_2=map_calc)
    if(compute_cc_image):
      self.atom_radius = self._atom_radius()
      cc_image = self._cc_image(map_calc = map_calc)
    if(compute_cc_volume):
      cc_volume = self._cc_volume(map_calc=map_calc)
    if(compute_cc_peaks):
      cc_peaks = self._cc_peaks(map_calc=map_calc)
    #
    if(not keep_map_calc): map_calc=None
    self.result = group_args(
      cc_box      = cc_box,
      cc_image    = cc_image,
      cc_mask     = cc_mask,
      cc_volume   = cc_volume,
      cc_peaks    = cc_peaks,
      map_calc    = map_calc,
      atom_radius = self.atom_radius)

  def _get_map_calc(self):
    if(self.box is True):
      f_calc = miller.structure_factor_box_from_map(
        crystal_symmetry = self.xray_structure.crystal_symmetry(),
        n_real           = self.map.focus()).structure_factors_from_scatterers(
          xray_structure = self.xray_structure).f_calc()
      d_spacings = f_calc.d_spacings().data()
      sel = d_spacings > d_min
      f_calc = f_calc.select(sel)
    else:
      f_calc = self.xray_structure.structure_factors(d_min=self.d_min).f_calc()
    fft_map = miller.fft_map(
      crystal_gridding     = self.crystal_gridding,
      fourier_coefficients = f_calc)
    return fft_map.real_map_unpadded()

  def _atom_radius(self):
    b_iso = adptbx.u_as_b(
      flex.mean(self.xray_structure.extract_u_iso_or_u_equiv()))
    o = maptbx.atom_curves(scattering_type="C", scattering_table="electron")
    return o.image(d_min=self.d_min, b_iso=b_iso,
      radius_max=max(15.,self.d_min), radius_step=0.01).radius

  def _cc_image(self, map_calc):
    return from_map_map_atoms(
      map_1      = self.map,
      map_2      = map_calc,
      sites_cart = self.xray_structure.sites_cart(),
      unit_cell  = self.xray_structure.unit_cell(),
      radius     = self.atom_radius)

  def _cc_peaks(self, map_calc):
    s1 = get_selection_above_cutoff(m=self.map, n=self.n_nodes_inside)
    s2 = get_selection_above_cutoff(m=map_calc, n=self.n_nodes_inside)
    s = (s1 | s2).iselection()
    del s1
    del s2
    #G = flex.double(flex.grid(self.map.all()), 0)
    #G = G.set_selected(s, 1)
    #ccp4_map(cg=self.crystal_gridding, file_name="m1.ccp4", map_data=self.map)
    #ccp4_map(cg=self.crystal_gridding, file_name="m2.ccp4", map_data=map_calc)
    #ccp4_map(cg=self.crystal_gridding, file_name="m3.ccp4", map_data=G)
    return flex.linear_correlation(
      x=self.map.select(s).as_1d(),
      y=map_calc.select(s).as_1d()).coefficient()

  def _cc_volume(self, map_calc):
    s = get_selection_above_cutoff(m=map_calc, n=self.n_nodes_inside).iselection()
    #G = flex.double(flex.grid(self.map.all()), 0)
    #G = G.set_selected(s, 1)
    #ccp4_map(cg=self.crystal_gridding, file_name="m1.ccp4", map_data=self.map)
    #ccp4_map(cg=self.crystal_gridding, file_name="m2.ccp4", map_data=map_calc)
    #ccp4_map(cg=self.crystal_gridding, file_name="m3.ccp4", map_data=G)
    return flex.linear_correlation(
      x=self.map.select(s).as_1d(),
      y=map_calc.select(s).as_1d()).coefficient()

class fsc_model_vs_map(object):
  def __init__(self,
               xray_structure,
               map,
               atom_radius,
               d_min):
    assert atom_radius is not None # otherwise C++ traceback from flex.double(sites_frac.size(), atom_radius)
    self.atom_radius = atom_radius
    sgn = xray_structure.crystal_symmetry().space_group().type().number()
    assert sgn == 1 # P1 only
    def compute_mc(map_coeffs, map_data):
      return map_coeffs.structure_factors_from_map(
        map            = map_data,
        use_scale      = True,
        anomalous_flag = False,
        use_sg         = False)
    # Crystal gridding
    crystal_gridding = maptbx.crystal_gridding(
      unit_cell             = xray_structure.unit_cell(),
      space_group_info      = xray_structure.space_group_info(),
      pre_determined_n_real = map.accessor().all())
    # Compute mask
    sites_frac = xray_structure.sites_frac()
    mask = cctbx_maptbx_ext.mask(
      sites_frac                  = sites_frac,
      unit_cell                   = xray_structure.unit_cell(),
      n_real                      = map.all(),
      mask_value_inside_molecule  = 1,
      mask_value_outside_molecule = 0,
      radii                       = flex.double(sites_frac.size(), atom_radius))
    # Compute Fcalc
    f_calc = xray_structure.structure_factors(
      d_min=min(d_min, 3.0)).f_calc().resolution_filter(d_min=d_min)
    # Compute Fcalc masked inplace
    fft_map = miller.fft_map(
      crystal_gridding     = crystal_gridding,
      fourier_coefficients = f_calc)
    map_calc = fft_map.real_map_unpadded()
    del fft_map
    map_calc = map_calc * mask
    map = map*mask
    del mask
    f_calc = compute_mc(map_coeffs = f_calc, map_data = map_calc)
    del map_calc
    # Compute Fobs masked
    f_obs = compute_mc(map_coeffs = f_calc, map_data = map)
    # Binning
    n_bins=min(30, f_obs.data().size()//500)
    dsd = f_obs.d_spacings().data()
    if(dsd.size()>1500):
      f_obs.setup_binner(n_bins = n_bins)
    else:
      f_obs.setup_binner(reflections_per_bin = dsd.size())
    # Compute FSC
    self.result = []
    for i_bin in f_obs.binner().range_used():
      sel       = f_obs.binner().selection(i_bin)
      d         = dsd.select(sel)
      d_min     = flex.min(d)
      d_max     = flex.max(d)
      n         = d.size()
      fc        = f_calc.select(sel)
      fo        = f_obs.select(sel)
      cc        = fc.map_correlation(other = fo)
      bin = group_args(
        d_min = d_min, d_max = d_max, n = d.size(), cc = cc)
      self.result.append(bin)

  def show_lines(self, prefix=""):
    lines = []
    msg = prefix+"Atom radius used for masking: %s A"%(
      str("%5.2f"%self.atom_radius).strip())
    lines.append(msg)
    lines.append(prefix+"Bin  Resolution      CC(FSC)  N_coeffs")
    fmt="%2d: %7.3f-%-7.3f %7.4f %5d"
    for i, bin in enumerate(self.result):
      lines.append(prefix+fmt%(i, bin.d_max, bin.d_min, bin.cc, bin.n))
    return lines

  def show(self, log=None, prefix="", allcaps=False):
    if(log is None): log = sys.stdout
    lines = self.show_lines(prefix=prefix)
    for l in lines:
      if(allcaps): l = l.upper()
      print(l, file=log)

def assert_same_gridding(map_1, map_2):
  # XXX remove it!
  maptbx.assert_same_gridding(map_1, map_2)

def from_map_map(map_1, map_2):
  assert_same_gridding(map_1, map_2)
  return flex.linear_correlation(
    x=map_1.as_1d(),
    y=map_2.as_1d()).coefficient()

def from_map_map_atom(map_1, map_2, site_cart, unit_cell, radius):
  assert_same_gridding(map_1, map_2)
  sel = maptbx.grid_indices_around_sites(
    unit_cell  = unit_cell,
    fft_n_real = map_1.focus(),
    fft_m_real = map_1.all(),
    sites_cart = flex.vec3_double([site_cart]),
    site_radii = flex.double(1, radius))
  return flex.linear_correlation(
    x=map_1.select(sel).as_1d(),
    y=map_2.select(sel).as_1d()).coefficient()

def from_map_map_atoms_optimal_radius(map_1, map_2, sites_cart, unit_cell, d_min):
  radii_coarse = [r/100. for r in range(150,550,50)]+[d_min,]
  cc_best = -999
  r_best = None
  for r in radii_coarse:
    cc = from_map_map_atoms(map_1=map_1, map_2=map_2, sites_cart=sites_cart,
      unit_cell=unit_cell, radius=r)
    if(cc>cc_best):
      r_best = r
      cc_best = cc
  r_fine = [r/100. for r in range(max(150,int(r_best*100)-50), int(r_best*100)+50,10)]
  for r in r_fine:
    cc = from_map_map_atoms(map_1=map_1, map_2=map_2, sites_cart=sites_cart,
      unit_cell=unit_cell, radius=r)
    if(cc>cc_best):
      r_best = r
      cc_best = cc
  return cc_best, r_best

def from_map_map_atoms(map_1, map_2, sites_cart, unit_cell, radius):
  assert_same_gridding(map_1, map_2)
  sel = maptbx.grid_indices_around_sites(
    unit_cell  = unit_cell,
    fft_n_real = map_1.focus(),
    fft_m_real = map_1.all(),
    sites_cart = sites_cart,
    site_radii = flex.double(sites_cart.size(), radius))
  return flex.linear_correlation(
    x=map_1.select(sel).as_1d(),
    y=map_2.select(sel).as_1d()).coefficient()

def from_map_map_selection(map_1, map_2, selection):
  assert_same_gridding(map_1, map_2)
  return flex.linear_correlation(
    x=map_1.select(selection).as_1d(),
    y=map_2.select(selection).as_1d()).coefficient()

def from_map_map_atoms_per_atom(map_1, map_2, sites_cart, unit_cell, radius):
  assert_same_gridding(map_1, map_2)
  result = flex.double()
  for site_cart in sites_cart:
    cc = from_map_map_atom(map_1=map_1, map_2=map_2, site_cart=site_cart,
      unit_cell=unit_cell, radius=radius)
    result.append(cc)
  return result

class histogram_per_atom(object):
  def __init__(self, map_1, map_2, sites_cart, unit_cell, radius, n_slots):
    assert_same_gridding(map_1, map_2)
    self.ccs = from_map_map_atoms_per_atom(
      map_1      = map_1,
      map_2      = map_2,
      sites_cart = sites_cart,
      unit_cell  = unit_cell,
      radius     = radius)
    self.hist = flex.histogram(data = self.ccs, n_slots = n_slots)

  def format(self, prefix=""):
    h = self.hist
    lc_1 = h.data_min()
    s_1 = enumerate(h.slots())
    lines = []
    for (i_1,n_1) in s_1:
      hc_1 = h.data_min() + h.slot_width() * (i_1+1)
      line = "%s %7.4f - %-7.4f: %6.2f %s" % (prefix, lc_1, hc_1,
        n_1/self.ccs.size()*100, "%")
      lines.append(line)
      lc_1 = hc_1
    return "\n".join(lines)

class from_map_and_xray_structure_or_fmodel(object):

  def __init__(self,
        xray_structure    = None,
        fmodel            = None,
        map_data          = None,
        d_min             = None,
        resolution_factor = 0.25,
        map_type          = "2mFo-DFc"):
    """
    Utility to calculate correlation between two maps:
      CC(xray_structure, map_data), xray_structure are map_data inputs
    or
      CC(2mFo-DFc, Fc), 2mFo-DFc and Fc are from input fmodel .
    """
    assert [fmodel, map_data].count(None) == 1
    assert [xray_structure, map_data].count(None) in [0, 2]
    assert [fmodel, xray_structure].count(None) == 1
    assert [d_min, fmodel].count(None) == 1
    adopt_init_args(self, locals())
    if(fmodel is not None): self.xray_structure = fmodel.xray_structure
    # get map_data defined
    if(self.fmodel is not None):
      e_map_obj = fmodel.electron_density_map()
      isotropize = True
      if(fmodel.is_twin_fmodel_manager()): isotropize = False
      mc = e_map_obj.map_coefficients(
        map_type           = map_type,
        fill_missing       = False,
        isotropize         = isotropize)
      crystal_gridding = self.fmodel.f_obs().crystal_gridding(
        d_min              = self.fmodel.f_obs().d_min(),
        resolution_factor  = resolution_factor)
      fft_map = miller.fft_map(
        crystal_gridding     = crystal_gridding,
        fourier_coefficients = mc)
      self.map_data = fft_map.real_map_unpadded()
    # get model map
    if(self.fmodel is not None):
      if(fmodel.is_twin_fmodel_manager()):
        f_model = self.fmodel.f_model()
      else:
        f_model = self.fmodel.f_model_scaled_with_k1()
      fft_map = miller.fft_map(
        crystal_gridding     = crystal_gridding,
        fourier_coefficients = f_model)
      fft_map.apply_sigma_scaling()
      self.map_model = fft_map.real_map_unpadded()
    else:
      crystal_gridding = maptbx.crystal_gridding(
        unit_cell             = self.xray_structure.unit_cell(),
        space_group_info      = self.xray_structure.space_group_info(),
        pre_determined_n_real = self.map_data.accessor().all())
      f_model = self.xray_structure.structure_factors(d_min=self.d_min).f_calc()
      fft_map = miller.fft_map(
        crystal_gridding     = crystal_gridding,
        fourier_coefficients = f_model)
      del f_model
      fft_map.apply_sigma_scaling()
      self.map_model = fft_map.real_map_unpadded()
      del fft_map
    if(self.fmodel is not None):
      self.sites_cart = self.fmodel.xray_structure.sites_cart()
      self.sites_frac = self.fmodel.xray_structure.sites_frac()
    else:
      self.sites_cart = self.xray_structure.sites_cart()
      self.sites_frac = self.xray_structure.sites_frac()

  def cc(self, selections=None, selection=None, atom_radius=2.0, per_atom=None):
    def compute(sites_cart):
      return from_map_map_atoms(
        map_1      = self.map_data,
        map_2      = self.map_model,
        sites_cart = sites_cart,
        unit_cell  = self.xray_structure.unit_cell(),
        radius     = atom_radius)
    if(selections is not None):
      result = []
      for s in selections:
        result.append(compute(sites_cart=self.sites_cart.select(s)))
      return result
    elif(selection is not None):
      return compute(sites_cart=self.sites_cart.select(selection))
    elif(per_atom):
      return from_map_map_atoms_per_atom(
        map_1      = self.map_data,
        map_2      = self.map_model,
        sites_cart = self.sites_cart,
        unit_cell  = self.fmodel.xray_structure.unit_cell(),
        radius     = atom_radius)
    elif([selection, selections].count(None)==2):
      return from_map_map(
        map_1 = self.map_data,
        map_2 = self.map_model)
    else:
      raise RuntimeError

def map_model_cc_and_vals_per_atom_xtal(
      fmodel,
      map_obs_type  = "2mFo-DFc",
      map_calc_type = "Fmodel",
      grid_step     = 0.6, # From mosaic work
      atom_radius   = 2.0):
  """
  Calculate CC(map_obs_type, map_calc_type) and map values at atom center of
  map_obs_type. Crystallography specific since it uses fmodel.
  fmodel is expected to have all scales set and up to date.
  """
  def get_map(map_type):
    map_coeffs = map_tools.electron_density_map(
       fmodel = fmodel).map_coefficients(
         map_type     = map_type,
         isotropize   = True,
         fill_missing = False)
    fft_map = miller.fft_map(
      crystal_gridding     = crystal_gridding,
      fourier_coefficients = map_coeffs)
    fft_map.apply_sigma_scaling()
    return fft_map.real_map_unpadded()
  xrs = fmodel.xray_structure
  uc  = xrs.unit_cell()
  crystal_gridding = maptbx.crystal_gridding(
    unit_cell        = uc,
    space_group_info = xrs.space_group_info(),
    symmetry_flags   = maptbx.use_space_group_symmetry,
    step             = grid_step)
  map_obs  = get_map(map_type = map_obs_type)
  map_calc = get_map(map_type = map_calc_type)
  ccs  = flex.double()
  vals = flex.double()
  for site_cart, site_frac in zip(xrs.sites_cart(), xrs.sites_frac()):
    cc = from_map_map_atom(
      map_1     = map_obs,
      map_2     = map_calc,
      site_cart = site_cart,
      unit_cell = uc,
      radius    = atom_radius)
    mv = map_obs.tricubic_interpolation(site_frac)
    ccs .append(cc)
    vals.append(mv)
  return group_args(ccs = ccs, vals = vals)


 *******************************************************************************


 *******************************************************************************
mmtbx/maps/fem.py
from __future__ import absolute_import, division, print_function
from cctbx import maptbx
import mmtbx.maps
import mmtbx.map_tools
import random
from scitbx.array_family import flex
from cctbx import adptbx
from libtbx.test_utils import approx_equal
from mmtbx.maps import kick
import sys
from libtbx import adopt_init_args
from cctbx import adptbx
from mmtbx import map_tools
from cctbx import miller
from libtbx import Auto
import mmtbx.maps.composite_omit_map
from six.moves import range

class run(object):

  def __init__(
        self,
        f_obs,
        r_free_flags,
        xray_structure,
        use_resolve,
        use_omit,
        use_max_map,
        sharp,
        use_unsharp_masking,
        resolution_factor,
        n_inner_loop = 10,
        n_outer_loop = 10,
        log          = None):
    adopt_init_args(self, locals())
    if(self.log is None): self.log = sys.stdout
    print("Start FEM...", file=self.log)
    self.prepare_f_obs_and_flags()
    self.mc_orig = self.compute_original_map()
    self.b_overall = None
    print("Create un-sharpened fmodel...", file=self.log)
    self.fmodel_nosharp = self.create_fmodel(show=True).deep_copy()
    if(self.sharp): self.remove_common_isotropic_adp()
    print("Create fmodel...", file=self.log)
    self.fmodel = self.create_fmodel(show=True)
    self.crystal_gridding = self.f_obs.crystal_gridding(
      d_min             = self.fmodel.f_obs().d_min(),
      symmetry_flags    = maptbx.use_space_group_symmetry,
      resolution_factor = self.resolution_factor)
    # initial maps
    print("Compute initial maps...", file=self.log)
    self.mc = map_tools.electron_density_map(
      fmodel=self.fmodel).map_coefficients(
        map_type     = "2mFo-DFc",
        isotropize   = True,
        fill_missing = False)
    self.mc_fill = map_tools.electron_density_map(
      fmodel=self.fmodel).map_coefficients(
        map_type     = "2mFo-DFc",
        isotropize   = True,
        fill_missing = True)
    print("Finding typical atom volumes...", file=self.log)
    self.selection = good_atoms_selection(
      crystal_gridding = self.crystal_gridding,
      map_coeffs       = self.mc_fill,
      xray_structure   = self.fmodel.xray_structure)
    # main FEM loop
    m = self.outer_loop()
    m = low_volume_density_elimination(m=m, fmodel=self.fmodel,
      selection=self.selection)
    self.zero_below_threshold(m = m)
    # HE
    m = maptbx.volume_scale(map = m,  n_bins = 10000).map_data()
    # create Fourier ripples filter
    sel = m<0.5
    msk = m.set_selected(sel, 0)
    sel = msk>=0.5
    msk = msk.set_selected(sel, 1)

#XXX    maptbx.sharpen(map_data=m, index_span=2, n_averages=1,
#XXX          allow_negatives=False)


    # Use Resolve filter
    m_resolve = self.resolve_filter_map()
    if(m_resolve is not None): m = m * m_resolve
    # Use OMIT
    if(self.use_omit):
      comit = mmtbx.maps.composite_omit_map.run(
        fmodel                           = self.fmodel_nosharp,
        crystal_gridding                 = self.crystal_gridding,
        box_size_as_fraction             = 0.2,
        max_boxes                        = 2000,
        neutral_volume_box_cushion_width = 2,
        full_resolution_map              = True,
        log                              = self.log)
      omit_map = comit.as_p1_map()
      #ccp4_map(cg=self.crystal_gridding, file_name="omit1.ccp4", map_data=omit_map)
      omit_map = low_volume_density_elimination(m=omit_map, fmodel=self.fmodel,
        selection=self.selection,end=16)
      #ccp4_map(cg=self.crystal_gridding, file_name="omit2.ccp4", map_data=omit_map)
      sel      = omit_map<1.5
      omit_map = omit_map.set_selected(sel, 0)
      sel      = omit_map>=1.5
      omit_map = omit_map.set_selected(sel, 1)
      m = m * omit_map
      #
      # Extra filter: seems to ne redundant, TBD.
      #
      #omit_mc = comit.result_as_sf()
      #omit_map = get_map(mc=omit_mc, cg=self.crystal_gridding)
      #omit_map = low_volume_density_elimination(m=omit_map, fmodel=self.fmodel, selection=self.selection)
      #ccp4_map(cg=self.crystal_gridding, file_name="omit2.ccp4", map_data=omit_map)
      #sel      = omit_map<0.5
      #omit_map = omit_map.set_selected(sel, 0)
      #sel      = omit_map>=0.5
      #omit_map = omit_map.set_selected(sel, 1)
      #m = m * omit_map

    #
    self.mc_result = self.mc_fill.structure_factors_from_map(
      map            = m,
      use_scale      = True,
      anomalous_flag = False,
      use_sg         = False)
    if(self.sharp):
      self.mc_result=mmtbx.maps.b_factor_sharpening_by_map_kurtosis_maximization(
        map_coeffs=self.mc_result, show=True, b_only=False)
    self.map_result = get_map(mc=self.mc_result, cg=self.crystal_gridding)*msk

  def resolve_filter_map(self):
    m_resolve = None
    cmpl = self.fmodel.f_obs().resolution_filter(d_min=6).completeness()
    if((self.use_resolve is Auto and
       (self.fmodel.r_work()>0.2 or self.b_overall>30.) or cmpl<0.7) or
       self.use_resolve is True):
      print("Running Resolve density modificaiton", file=self.log)
      mc_resolve = self.fmodel.resolve_dm_map_coefficients()
      m_resolve = get_map(mc=mc_resolve, cg=self.crystal_gridding)
      m_resolve = low_volume_density_elimination(m=m_resolve, fmodel=self.fmodel,
        selection=self.selection)
      m_resolve = m_resolve.set_selected(m_resolve < 0.25, 0)
      m_resolve = m_resolve.set_selected(m_resolve >=0.25, 1)
      print("Obtained Resolve filter", file=self.log)
    return m_resolve

  def write_output_files(self, mtz_file_name, ccp4_map_file_name, fem_label,
                         orig_label):
    mtz_dataset = self.mc_result.as_mtz_dataset(column_root_label=fem_label)
    mtz_dataset.add_miller_array(
      miller_array      = self.mc_orig,
      column_root_label = orig_label)
    mtz_object = mtz_dataset.mtz_object()
    mtz_object.write(file_name = mtz_file_name)
    ccp4_map(cg=self.crystal_gridding, file_name=ccp4_map_file_name,
      map_data=self.map_result)

  def compute_original_map(self):
    return map_tools.electron_density_map(
      fmodel = self.create_fmodel(update_f_part1=False)).map_coefficients(
        map_type     = "2mFo-DFc",
        isotropize   = False,
        fill_missing = False)

  def outer_loop(self):
    missing_reflections_manager = mmtbx.map_tools.model_missing_reflections(
      coeffs=self.mc, fmodel=self.fmodel)
    missing = missing_reflections_manager.get_missing(deterministic=True)
    wam = kick.weighted_average(fmodel=self.fmodel, map_coefficients=self.mc)
    progress_counter = counter(
      n1=self.n_inner_loop, n2=self.n_outer_loop, log=self.log)
    map_accumulator = maptbx.map_accumulator(
      n_real = self.crystal_gridding.n_real(), smearing_b=1, max_peak_scale=100,
      smearing_span=5, use_max_map=self.use_max_map)
    for i in range(self.n_outer_loop):
      m = inner_loop(
        fmodel           = self.fmodel,
        wam              = wam,
        missing          = missing,
        crystal_gridding = self.crystal_gridding,
        n                = self.n_inner_loop,
        progress_counter = progress_counter,
        use_max_map      = self.use_max_map)
      m = low_volume_density_elimination(m=m, fmodel=self.fmodel,
        selection=self.selection)
      if(self.sharp and self.use_unsharp_masking):
        maptbx.sharpen(map_data=m, index_span=1, n_averages=2,
          allow_negatives=False)
        maptbx.gamma_compression(map_data=m, gamma=0.1)
      self.zero_below_threshold(m = m)
      m = m/flex.max(m)
      map_accumulator.add(map_data=m)
    m = map_accumulator.as_median_map()
    sd = m.sample_standard_deviation()
    print(file=self.log)
    return m/sd

  def remove_common_isotropic_adp(self):
    xrs = self.xray_structure
    b_iso_min = flex.min(xrs.extract_u_iso_or_u_equiv()*adptbx.u_as_b(1))
    self.b_overall = b_iso_min
    print("Max B subtracted from atoms and used to sharpen map:", b_iso_min, file=self.log)
    xrs.shift_us(b_shift=-b_iso_min)
    b_iso_min = flex.min(xrs.extract_u_iso_or_u_equiv()*adptbx.u_as_b(1))
    assert approx_equal(b_iso_min, 0, 1.e-3)

  def prepare_f_obs_and_flags(self):
    if not self.f_obs:
      from libtbx.utils import Sorry
      raise Sorry("No FOBS available?")
    if not self.r_free_flags:
      from libtbx.utils import Sorry
      raise Sorry("No r_free_flags (test set) available?")
    sel = self.f_obs.data()>0
    self.f_obs = self.f_obs.select(sel)
    self.r_free_flags = self.r_free_flags.select(sel)
    #
    merged = self.f_obs.as_non_anomalous_array().merge_equivalents()
    self.f_obs = merged.array().set_observation_type(self.f_obs)
    #
    merged = self.r_free_flags.as_non_anomalous_array().merge_equivalents()
    self.r_free_flags = merged.array().set_observation_type(self.r_free_flags)
    #
    self.f_obs, self.r_free_flags = self.f_obs.common_sets(self.r_free_flags)

  def create_fmodel(self, update_f_part1=True, show=False):
    fmodel = mmtbx.f_model.manager(
      f_obs          = self.f_obs,
      r_free_flags   = self.r_free_flags,
      xray_structure = self.xray_structure)
    fmodel.update_all_scales(update_f_part1 = update_f_part1)
    if(show):
      fmodel.show(show_header=False, show_approx=False)
      print("r_work=%6.4f r_free=%6.4f" % (fmodel.r_work(),
        fmodel.r_free()), file=self.log)
    return fmodel

  def zero_below_threshold(self, m):
    maptbx.reset(
      data                   = m,
      substitute_value       = 0.0,
      less_than_threshold    = 0.24,
      greater_than_threshold = -9999,
      use_and                = True)

def low_volume_density_elimination(m, fmodel, selection, end=11):
  rr = [i/10. for i in range(5,end)]#+[1.5, 1.75, 2.]
  rr.reverse()
  for c in rr:
    sh=0.25
    zero_all_interblob_region = False
    if(c<=0.5): zero_all_interblob_region=True
    msk = truncate_with_roots(
      m=m, fmodel=fmodel, c1=c, c2=c-sh, cutoff=c, scale=1, as_int=False,
      zero_all_interblob_region=zero_all_interblob_region,
      selection = selection)
    if(msk is not None):
      m = m * msk
  return m

def truncate_with_roots(
      m, fmodel, c1, c2, cutoff, scale, zero_all_interblob_region=True,
      as_int=False, average_peak_volume=None, selection=None):
  assert c1>=c2
  if(average_peak_volume is None):
    sites_cart = fmodel.xray_structure.sites_cart()
    if(selection is not None):
      sites_cart = sites_cart.select(selection)
    average_peak_volume = maptbx.peak_volume_estimate(
      map_data         = m,
      sites_cart       = sites_cart,
      crystal_symmetry = fmodel.xray_structure.crystal_symmetry(),
      cutoff           = cutoff)
  if(average_peak_volume is None or int(average_peak_volume*scale)-1==0):
    return None
  average_peak_volume = int(average_peak_volume*scale/2)-1 # XXX "/2" is ad hoc and I don't know why!
  co1 = maptbx.connectivity(map_data=m, threshold=c1)
  co2 = maptbx.connectivity(map_data=m, threshold=c2)
  result = co2.noise_elimination_two_cutoffs(
    connectivity_object_at_t1=co1,
    elimination_volume_threshold_at_t1=average_peak_volume,
    zero_all_interblob_region=zero_all_interblob_region)
  if(as_int): return result
  else:       return result.as_double()

def good_atoms_selection(
      crystal_gridding,
      map_coeffs,
      xray_structure):
  #XXX copy from model_missing_reflections map_tools.py, consolidate later
  #XXX Also look for similar crap in f_model.py
  fft_map = miller.fft_map(
    crystal_gridding     = crystal_gridding,
    fourier_coefficients = map_coeffs)
  fft_map.apply_sigma_scaling()
  map_data = fft_map.real_map_unpadded()
  rho_atoms = flex.double()
  for site_frac in xray_structure.sites_frac():
    rho_atoms.append(map_data.eight_point_interpolation(site_frac))
  #rho_mean = flex.mean_default(rho_atoms.select(rho_atoms>1.0), 1.0)
  sel_exclude = rho_atoms < 1.0 # XXX ??? TRY 0.5!
  sites_cart = xray_structure.sites_cart()
  #
  f_calc = map_coeffs.structure_factors_from_scatterers(
    xray_structure = xray_structure).f_calc()
  fft_map = miller.fft_map(
    crystal_gridding     = crystal_gridding,
    fourier_coefficients = f_calc)
  fft_map.apply_sigma_scaling()
  map_data2 = fft_map.real_map_unpadded()
  #
  hd_sel = xray_structure.hd_selection()
  for i_seq, site_cart in enumerate(sites_cart):
    selection = maptbx.grid_indices_around_sites(
      unit_cell  = map_coeffs.unit_cell(),
      fft_n_real = map_data.focus(),
      fft_m_real = map_data.all(),
      sites_cart = flex.vec3_double([site_cart]),
      site_radii = flex.double([1.5]))
    cc = flex.linear_correlation(x=map_data.select(selection),
      y=map_data2.select(selection)).coefficient()
    if(cc<0.7 or hd_sel[i_seq]): sel_exclude[i_seq] = True
  return ~sel_exclude

def inner_loop(fmodel, wam, missing, crystal_gridding, n, progress_counter,
               use_max_map):
  mac = maptbx.map_accumulator(n_real = crystal_gridding.n_real(),
    smearing_b=1, max_peak_scale=100, smearing_span=5, use_max_map=use_max_map)
  for j in range(n):
    mc_w = wam.random_weight_averaged_map_coefficients(
      missing       = missing,
      random_scale  = random.choice([0,1,2,3,4,5]),
      random_seed   = random.choice(range(1, 9754365, 10000)),
      n_cycles      = 100,
      fraction_keep = random.choice([0.9, 0.95, 1.0]))
    if(random.choice([True,False])):
      mc_w = kick.randomize_struture_factors(map_coeffs=mc_w,
        number_of_kicks=100)
    m = get_map(mc=mc_w, cg=crystal_gridding)
    m = m/flex.max(m)
    sel = m<0
    m = m.set_selected(sel, 0)
    mac.add(map_data=m)
    progress_counter.show()
  mm = mac.as_median_map()
  sd = mm.sample_standard_deviation()
  r = mm/sd
  return r

def get_map(mc, cg):
  fft_map = miller.fft_map(
      crystal_gridding     = cg,
      fourier_coefficients = mc)
  fft_map.apply_sigma_scaling()
  return fft_map.real_map_unpadded()

class counter(object):
  def __init__(self, n1, n2, log):
    adopt_init_args(self, locals())
    self.n=0
    assert self.n1*self.n2>0
    self.progress_scale = 100./(self.n1*self.n2)
  def show(self):
    self.n += 1
    self.log.write(
      "\r%s %d%%" %("FEM loop: done so far:",
      int(self.n*self.progress_scale)))
    self.log.flush()

def ccp4_map(cg, file_name, mc=None, map_data=None):
  assert [mc, map_data].count(None)==1
  if(map_data is None):
    map_data = get_map(mc=mc, cg=cg)
  from iotbx import mrcfile
  mrcfile.write_ccp4_map(
      file_name=file_name,
      unit_cell=cg.unit_cell(),
      space_group=cg.space_group(),
      #gridding_first=(0,0,0),# This causes a bug (map gets shifted)
      #gridding_last=n_real,  # This causes a bug (map gets shifted)
      map_data=map_data,
      labels=flex.std_string([""]))


 *******************************************************************************


 *******************************************************************************
mmtbx/maps/fobs_minus_fobs_map.py

from __future__ import absolute_import, division, print_function
from mmtbx import utils
import mmtbx.f_model
from iotbx.option_parser import iotbx_option_parser
from iotbx.pdb import combine_unique_pdb_files
from iotbx import reflection_file_reader
from iotbx import reflection_file_utils
import iotbx.file_reader
import iotbx.symmetry
import iotbx.phil
from cctbx.array_family import flex
import iotbx.pdb
from cctbx import miller
from libtbx.str_utils import format_value
from libtbx.utils import Sorry, null_out
from libtbx import adopt_init_args
from libtbx import runtime_utils
import libtbx.callbacks # import dependency
from six.moves import cStringIO as StringIO
import os
import sys
import mmtbx.model
from six.moves import zip
from iotbx import extract_xtal_data

fo_minus_fo_master_params_str = """\
f_obs_1_file_name = None
  .type = path
  .help = File with Fobs data
  .short_caption = Reflections file 1
  .style = bold file_type:hkl process_hkl child:fobs:f_obs_1_label force_data
f_obs_1_label = None
  .type = str
  .short_caption = Labels 1
  .input_size = 160
  .style = bold renderer:draw_fobs_label_widget
f_obs_2_file_name = None
  .type = path
  .help = File with Fobs data
  .short_caption = Reflections file 2
  .style = bold file_type:hkl process_hkl child:fobs:f_obs_2_label force_data
f_obs_2_label = None
  .type = str
  .short_caption = Labels 2
  .input_size = 160
  .style = bold renderer:draw_fobs_label_widget
high_resolution = None
  .type = float
  .help = High resolution data cutoff
  .style = bold resolution
low_resolution = None
  .type = float
  .help = Low resolution data cutoff
  .style = bold resolution
sigma_cutoff = None
  .type = float
  .help = Fobs sigma cutoff
  .short_caption = F(obs) sigma cutoff
phase_source = None
  .type = path
  .help = PDB file with a model or reflection file with the phases
  .short_caption = PDB file for phasing
  .style = bold OnChange:validate_phase_source file_type:pdb
scattering_table = wk1995 it1992 *n_gaussian electron neutron
  .type = choice(multi=False)
  .help = Choices of scattering table for structure factors calculations
output_file = None
  .type = path
  .style = hidden
output_dir = None
  .type = path
  .short_caption = Output folder
  .style = output_dir
  .expert_level = 4
file_name_prefix = None
  .type = str
  .input_size = 400
  .help = Base file name for output (GUI parameter only)
  .expert_level = 4
job_id = None
  .type = int
  .style = hidden
  .help = GUI parameter only
  .expert_level = 4
ignore_non_isomorphous_unit_cells = False
  .type = bool
  .short_caption = Ignore non-isomorphous unit cells
include scope libtbx.phil.interface.tracking_params
advanced
  .expert_level = 3
  .short_caption = Advanced options
  .style = auto_align menu_item
{
  multiscale = False
    .type = bool
    .expert_level = 2
    .short_caption = Use multiscaling method
  omit_selection = None
    .type = atom_selection
    .short_caption = Omit atom selection
    .help = The selected atoms will be left out of the phasing model.
    .expert_level = 1
  anomalous = False
    .type = bool
    .short_caption = Use anomalous differences instead of amplitudes
    .help = Experimental feature: generate a difference map using the \
      anomalous differences of each dataset instead of the amplitudes, \
      similar to the log-likelihood gradient difference map in Phaser \
      SAD phasing (or simple anomaloues residual map), only using two \
      experimental datasets instead of F-obs and F-calc.
    .expert_level = 3
}
find_peaks_holes = False
  .type = bool
  .short_caption = Find peaks and holes in map
map_cutoff = 3.0
  .type = float
  .short_caption = Sigma-level cutoff for peak search
peak_search
  .short_caption = Peak search parameters
  .style = auto_align box menu_item
{
include scope mmtbx.find_peaks.master_params
}
structure_factors_accuracy
  .short_caption = Structure factors accuracy
  .style = auto_align box
{
  include scope mmtbx.f_model.sf_and_grads_accuracy_master_params
}
"""
def fo_minus_fo_master_params():
  return iotbx.phil.parse(fo_minus_fo_master_params_str, process_includes=True)

class compute_fo_minus_fo_map(object):
  def __init__(self,
      data_arrays,
      xray_structure,
      sf_accuracy_params=None,
      log=None,
      silent=False,
      output_file=None,
      peak_search=False,
      map_cutoff=None,
      peak_search_params=None,
      r_free_arrays=None,
      write_map=True,
      multiscale=False,
      anomalous=False):
    if (log is None) : log = sys.stdout
    adopt_init_args(self, locals())
    fmodels = []
    for i_seq, d in enumerate(data_arrays):
      if(not silent):
        print("Data set: %d"%i_seq, file=log)
      if(d.anomalous_flag()) and (not anomalous):
        d = d.average_bijvoet_mates()
      elif (anomalous):
        assert d.anomalous_flag()
      if (r_free_arrays is not None) and (i_seq < len(r_free_arrays)):
        r_free_flags = r_free_arrays[i_seq]
      else :
        r_free_flags = d.array(data = flex.bool(d.data().size(), False))
      fmodel = mmtbx.f_model.manager(
        xray_structure = xray_structure.deep_copy_scatterers(),
        r_free_flags   = r_free_flags,
        target_name    = "ls_wunit_k1",
        sf_and_grads_accuracy_params = sf_accuracy_params,
        f_obs          = d)
      fmodel.update_all_scales(log=None)

      #fmodel.export( out=open("taam_%d.mtz"%i_seq,"w") )

      if(not silent):
        fmodel.info().show_rfactors_targets_scales_overall(out=log)
        print(file=log)
        fmodel.show(show_header=False, show_approx=False, log=log)

      fmodels.append(fmodel)
    self.fmodel = fmodels[0]
    # prepare Fobs for map calculation (apply scaling):
    f_obss = []
    for fmodel in fmodels:
      f_obss.append(fmodel.f_obs_scaled(include_fom=True))
    # given two Fobs sets, make them one-to-one matching, get phases and map coefficients
    # Note: f_calc below is just f_calc from atoms (no bulk solvent etc applied)
    fobs_1, f_model = f_obss[0].common_sets(other = fmodels[1].f_model())
    fobs_1, fobs_2 = fobs_1.common_sets(other = f_obss[1])
    fobs_1, f_model = fobs_1.common_sets(other = f_model)
    self.f_model = f_model
    assert fobs_2.indices().all_eq(fobs_1.indices())
    assert f_model.indices().all_eq(fobs_1.indices())

    # scale again
    scale_k1 = 1
    den = flex.sum(flex.abs(fobs_2.data())*flex.abs(fobs_2.data()))
    if(den != 0):
      scale_k1 = flex.sum(flex.abs(fobs_1.data())*flex.abs(fobs_2.data())) / den
    #
    fobs_2 = fobs_2.array(data = fobs_2.data()*scale_k1)

    if multiscale:
      #fobs_1 = fobs_2.multiscale(other = fobs_1, reflections_per_bin=50)
      fobs_1 = fobs_2.multiscale(
        other = fobs_1, reflections_per_bin=250, use_exp_scale=True)
    if(not silent):
      print("", file=log)
      print("Fobs1_vs_Fobs2 statistics:", file=log)
      print("Bin# Resolution range  Compl.  No.of refl. CC   R-factor", file=log)
      fobs_1.setup_binner(reflections_per_bin = min(50, fobs_1.data().size()))
      fobs_2.use_binning_of(fobs_1)
      for i_bin in fobs_1.binner().range_used():
        sel = fobs_1.binner().selection(i_bin)
        f1  = fobs_1.select(sel)
        f2  = fobs_2.select(sel)
        d_max, d_min = fobs_1.d_max_min()
        compl = fobs_1.completeness(d_max = d_max)
        n_ref = sel.count(True)
        num = flex.sum(flex.abs(f1.data()-f2.data()))
        den = flex.sum(flex.abs(f1.data()+f2.data())/2)
        r = None
        if(den!=0):
          r = num/den
        cc = flex.linear_correlation(x=f1.data(), y=f2.data()).coefficient()
        d_range = fobs_1.binner().bin_legend(
                       i_bin = i_bin, show_bin_number = False, show_counts = False)
        fmt = "%3d: %-17s   %4.2f %6d         %5.3f  %6s"
        print(fmt % (i_bin, d_range, compl, n_ref, cc,
          format_value("%6.4f", r)), file=log)
    # overall statistics
    self.cc = flex.linear_correlation(
      x=fobs_1.data(),
      y=fobs_2.data()).coefficient()
    num = flex.sum(flex.abs(fobs_1.data()-fobs_2.data()))
    den = flex.sum(flex.abs(fobs_2.data()+fobs_2.data())/2)
    self.r_factor = None
    if (den != 0):
      self.r_factor = num / den
    # map coefficients
    def phase_transfer(miller_array, phase_source):
      tmp = miller.array(miller_set = miller_array,
        data = flex.double(miller_array.indices().size(), 1)
        ).phase_transfer(phase_source = phase_source)
      return miller.array(miller_set = miller_array,
        data = miller_array.data() * tmp.data() )
    if (not anomalous):
      diff = miller.array(
        miller_set = f_model,
        data       = fobs_1.data()-fobs_2.data())
      self.map_coeff = phase_transfer(
        miller_array = diff,
        phase_source = f_model)
    else :
      dano_1 = fobs_1.anomalous_differences()
      dano_2 = fobs_2.anomalous_differences()
      assert dano_1.indices().all_eq(dano_2.indices())
      diff = miller.array(
        miller_set = dano_1,
        data = dano_1.data() - dano_2.data())
      f_model_phases = f_model.average_bijvoet_mates().common_set(diff)
      map_coeffs = phase_transfer(
        miller_array = diff,
        phase_source = f_model_phases)
      self.map_coeff = map_coeffs.customized_copy(data=map_coeffs.data()/(2j))
    if(self.map_coeff.anomalous_flag()):
      self.map_coeff = map_coeff.average_bijvoet_mates()
    self.file_names = []
    if (write_map):
      self.file_names = self.write_map_file()

  def write_map_file(self):
  # output MTZ file with map coefficients
    class map_coeffs_mtz_label_manager:
      def __init__(self, amplitudes, phases):
        self._amplitudes = amplitudes
        self._phases = phases
      def amplitudes(self):
        return self._amplitudes
      def phases(self, root_label, anomalous_sign=None):
        assert anomalous_sign is None or not anomalous_sign
        return self._phases
    mtz_history_buffer = flex.std_string()
    lbl_mgr = map_coeffs_mtz_label_manager(amplitudes = "FoFo", phases = "PHFc")
    mtz_dataset = self.map_coeff.as_mtz_dataset(
      column_root_label=lbl_mgr.amplitudes(),
      label_decorator=lbl_mgr)
    mtz_history_buffer.append("> column label %s = phenix %s" % (
        lbl_mgr.amplitudes(), "FoFoPHFc"))
    if self.output_file is not None :
      file_name = self.output_file
    else :
      file_name = "FoFoPHFc.mtz"
    mtz_history_buffer.append("file name %s"%file_name)
    mtz_object = mtz_dataset.mtz_object()
    mtz_object.add_history(mtz_history_buffer)
    mtz_object.write(file_name=file_name)
    self.file_names = [ file_name ]
    if (self.peak_search):
      from mmtbx.command_line import find_peaks_holes
      from mmtbx import find_peaks
      peak_search_log = self.log
      if (self.silent) : peak_search_log = null_out()
      fmodel = self.fmodel
      peaks = find_peaks.manager(
        map_cutoff     = self.map_cutoff,
        xray_structure = fmodel.xray_structure,
        params         = self.peak_search_params,
        log            = peak_search_log,
        map_coeffs     = self.map_coeff).peaks_mapped()
      peaks.sites = fmodel.xray_structure.unit_cell().orthogonalize(peaks.sites)
      holes = find_peaks.manager(
        map_cutoff     = -self.map_cutoff,
        xray_structure = fmodel.xray_structure,
        params         = self.peak_search_params,
        log            = peak_search_log,
        map_coeffs     = self.map_coeff).peaks_mapped()
      holes.sites = fmodel.xray_structure.unit_cell().orthogonalize(holes.sites)
      result = find_peaks_holes.peaks_holes_container(
        peaks=peaks,
        holes=holes,
        map_cutoff=self.map_cutoff)
      pdb_out = os.path.splitext(file_name)[0] + "_peaks.pdb"
      result.save_pdb_file(
        file_name=pdb_out,
        include_anom=False,
        include_water=False,
        log=peak_search_log)
      self.file_names.append(pdb_out)
    return self.file_names

def run(args, command_name = "phenix.fobs_minus_fobs_map", log=None):
  if(len(args) == 0): args = ["--help"]
  examples = """Examples:

phenix.fobs_minus_fobs_map f_obs_1_file=data1.mtz f_obs_2_file=data2.sca \
f_obs_1_label=FOBS1 f_obs_2_label=FOBS2 model.pdb

phenix.fobs_minus_fobs_map f_obs_1_file=data.mtz f_obs_2_file=data.mtz \
f_obs_1_label=FOBS1 f_obs_2_label=FOBS2 phase_source=model.pdb \
high_res=2.0 sigma_cutoff=2 scattering_table=neutron"""

  command_line = (iotbx_option_parser(
    usage="%s [options]" % command_name,
    description=examples)
    .option("--silent",
      action="store_true",
      help="Suppress output to the screen.")
    .enable_symmetry_comprehensive()
    ).process(args=args)
  #
  if (log is None):
    log = sys.stdout
  if(not command_line.options.silent):
    utils.print_header("phenix.fobs_minus_fobs_map", out = log)
    print("Command line arguments: ", file=log)
    print(args, file=log)
    print(file=log)
  #
  processed_args = utils.process_command_line_args(
    args=command_line.args,
    cmd_cs=command_line.symmetry,
    master_params=fo_minus_fo_master_params(),
    absolute_angle_tolerance=5,
    absolute_length_tolerance=1,
    log=log,
    suppress_symmetry_related_errors=True)
  working_phil = processed_args.params
  if(not command_line.options.silent):
    print("*** Parameters:", file=log)
    working_phil.show(out = log)
    print(file=log)
  params = working_phil.extract()
  consensus_symmetry = None
  if (params.ignore_non_isomorphous_unit_cells):
    if (None in [params.f_obs_1_file_name, params.f_obs_2_file_name,
        params.phase_source]):
      raise Sorry("The file parameters (f_obs_1_file_name, f_obs_2_file_name, "+
        "phase_source) must be specified explicitly when "+
        "ignore_non_isomorphous_unit_cells=True.")
    symm_manager = iotbx.symmetry.manager()
    pdb_in = iotbx.file_reader.any_file(params.phase_source, force_type="pdb")
    symm_manager.process_pdb_file(pdb_in)
    hkl_in_1 = iotbx.file_reader.any_file(params.f_obs_1_file_name,
      force_type="hkl")
    sg_err_1, uc_err_1 = symm_manager.process_reflections_file(hkl_in_1)
    hkl_in_2 = iotbx.file_reader.any_file(params.f_obs_2_file_name,
      force_type="hkl")
    sg_err_2, uc_err_2 = symm_manager.process_reflections_file(hkl_in_2)
    out = StringIO()
    symm_manager.show(out=out)
    if (sg_err_1) or (sg_err_2):
      raise Sorry(("Incompatible space groups in input files:\n%s\nAll files "+
        "must have the same point group (and ideally the same space group). "+
        "Please note that any symmetry information in the PDB file will be "+
        "used first.") % out.getvalue())
    elif (uc_err_1) or (uc_err_2):
      libtbx.call_back(message="warn",
        data=("Crystal symmetry mismatch:\n%s\nCalculations will continue "+
          "using the symmetry in the PDB file (or if not available, the "+
          "first reflection file), but the maps should be treated with "+
          "extreme suspicion.") % out.getvalue())
    crystal_symmetry = symm_manager.as_symmetry_object()
  else :
    processed_args = utils.process_command_line_args(
      args=command_line.args,
      cmd_cs=command_line.symmetry,
      master_params=fo_minus_fo_master_params(),
      suppress_symmetry_related_errors = False,
      absolute_angle_tolerance=5,
      absolute_length_tolerance=1,
      log=StringIO())
    crystal_symmetry = processed_args.crystal_symmetry
  #
  pdb_file_names = processed_args.pdb_file_names
  if(len(processed_args.pdb_file_names) == 0):
    if(params.phase_source is not None):
      pdb_file_names = [params.phase_source]
    else:
      raise Sorry("No PDB file found.")
  # Extaract Fobs1, Fobs2
  f_obss = []
  if(len(processed_args.reflection_files)==2):
    for reflection_file in processed_args.reflection_files:
      reflection_file_server = reflection_file_utils.reflection_file_server(
        crystal_symmetry = crystal_symmetry,
        force_symmetry   = True,
        reflection_files = [reflection_file],
        err              = null_out())
      # XXX UGLY !!!
      try:
        parameters = extract_xtal_data.data_and_flags_master_params().extract()
        if(params.f_obs_1_label is not None):
          parameters.labels = [params.f_obs_1_label]
        determine_data_and_flags_result = extract_xtal_data.run(
          reflection_file_server = reflection_file_server,
          keep_going             = True,
          parameters             = parameters)
      except: # intentional
        parameters = extract_xtal_data.data_and_flags_master_params().extract()
        if(params.f_obs_2_label is not None):
          parameters.labels = [params.f_obs_2_label]
        determine_data_and_flags_result = extract_xtal_data.run(
          reflection_file_server = reflection_file_server,
          keep_going             = True,
          parameters             = parameters)
      f_obss.append(determine_data_and_flags_result.f_obs)
  else:
    if([params.f_obs_1_file_name,params.f_obs_2_file_name].count(None)==2):
      raise Sorry("No reflection data file found.")
    for file_name, label in zip([params.f_obs_1_file_name,params.f_obs_2_file_name],
                                [params.f_obs_1_label,params.f_obs_2_label]):
      reflection_file = reflection_file_reader.any_reflection_file(
        file_name = file_name, ensure_read_access = False)
      reflection_file_server = reflection_file_utils.reflection_file_server(
        crystal_symmetry = crystal_symmetry,
        force_symmetry   = True,
        reflection_files = [reflection_file],
        err              = null_out())
      parameters = extract_xtal_data.data_and_flags_master_params().extract()
      if(label is not None):
        parameters.labels = [label]
      determine_data_and_flags_result = extract_xtal_data.run(
          reflection_file_server = reflection_file_server,
          parameters             = parameters,
          keep_going             = True)
      f_obss.append(determine_data_and_flags_result.f_obs)
  if(len(f_obss)!=2):
    raise Sorry(" ".join(errors))
  if(not command_line.options.silent):
    for ifobs, fobs in enumerate(f_obss):
      print("*** Summary for data set %d:"%ifobs, file=log)
      fobs.show_comprehensive_summary(f = log)
      print(file=log)
  pdb_combined = combine_unique_pdb_files(file_names = pdb_file_names)
  pdb_combined.report_non_unique(out = log)
  if(len(pdb_combined.unique_file_names) == 0):
    raise Sorry("No coordinate file given.")
  #
  raw_recs = flex.std_string()
  for rec in pdb_combined.raw_records:
    if(rec.upper().count("CRYST1")==0):
      raw_recs.append(rec)
  raw_recs.append(iotbx.pdb.format_cryst1_record(
    crystal_symmetry = crystal_symmetry))
  #
  pdb_in = iotbx.pdb.input(source_info = None, lines = raw_recs)
  model = mmtbx.model.manager(model_input = pdb_in)
  d_min = min(f_obss[0].d_min(), f_obss[1].d_min())
  model.setup_scattering_dictionaries(
    scattering_table = params.scattering_table,
    d_min            = d_min)
  xray_structure = model.get_xray_structure()
  hierarchy = model.get_hierarchy()
  #
  omit_sel = flex.bool(hierarchy.atoms_size(), False)
  if (params.advanced.omit_selection is not None):
    print("Will omit selection from phasing model:", file=log)
    print("  " + params.advanced.omit_selection, file=log)
    omit_sel = hierarchy.atom_selection_cache().selection(
      params.advanced.omit_selection)
    print("%d atoms selected for removal" % omit_sel.count(True), file=log)
  del hierarchy
  xray_structure = xray_structure.select(~omit_sel)
  if(not command_line.options.silent):
    print("*** Model summary:", file=log)
    xray_structure.show_summary(f = log)
    print(file=log)
  info0 = f_obss[0].info()
  info1 = f_obss[1].info()
  f_obss[0] = f_obss[0].resolution_filter(d_min = params.high_resolution,
    d_max = params.low_resolution).set_info(info0)
  f_obss[1] = f_obss[1].resolution_filter(d_min = params.high_resolution,
    d_max = params.low_resolution).set_info(info1)
  if(params.sigma_cutoff is not None):
    for i in [0,1]:
      if(f_obss[i].sigmas() is not None):
        sel = f_obss[i].data() > f_obss[i].sigmas()*params.sigma_cutoff
        f_obss[i] = f_obss[i].select(sel).set_info(info0)
  for k, f_obs in enumerate(f_obss):
    if (f_obs.indices().size() == 0):
      raise Sorry("No data left in array %d (labels=%s) after filtering!" % (k+1,
        f_obs.info().label_string()))
  output_file_name = params.output_file
  if (output_file_name is None) and (params.file_name_prefix is not None):
    output_file_name = "%s_%s.mtz" % (params.file_name_prefix, params.job_id)
  output_files = compute_fo_minus_fo_map(
    data_arrays = f_obss,
    xray_structure = xray_structure,
    sf_accuracy_params = params.structure_factors_accuracy,
    log = log,
    silent = command_line.options.silent,
    output_file = output_file_name,
    peak_search=params.find_peaks_holes,
    map_cutoff=params.map_cutoff,
    peak_search_params=params.peak_search,
    multiscale=params.advanced.multiscale,
    anomalous=params.advanced.anomalous).file_names
  return output_files

class launcher(runtime_utils.target_with_save_result):
  def run(self):
    os.makedirs(self.output_dir)
    os.chdir(self.output_dir)
    return run(args=list(self.args))

def validate_params(params, callback=None):
  if (None in [params.f_obs_1_file_name, params.f_obs_2_file_name]):
    raise Sorry("You must supply two files containing F(obs).")
  if (None in [params.f_obs_1_label, params.f_obs_2_label]):
    raise Sorry("You must define the labels for both reflection files.")
  if (params.phase_source is None):
    raise Sorry("You must specify a PDB file for phasing.")
  if not os.path.isdir(params.output_dir):
    raise Sorry("Output directory does not exist.")

def finish_job(result):
  output_files = []
  if (result is not None):
    assert (isinstance(result, list)) and (len(result) > 0)
    output_files.append((result[0], "Map coefficients"))
    if (len(result) > 1):
      output_files.append((result[1], "Map peaks and holes"))
  return (output_files, [])


 *******************************************************************************


 *******************************************************************************
mmtbx/maps/kick.py
from __future__ import absolute_import, division, print_function
from scitbx.array_family import flex
import random
from cctbx import miller
from cctbx import maptbx
from libtbx.test_utils import approx_equal
import mmtbx.f_model
from cctbx import maptbx
import mmtbx.maps.composite_omit_map
from six.moves import range

def get_map(map_coeffs, crystal_gridding):
  fft_map = miller.fft_map(
    crystal_gridding     = crystal_gridding,
    fourier_coefficients = map_coeffs)
  fft_map.apply_sigma_scaling()
  return fft_map.real_map_unpadded()

def compute_map_and_combine(
      map_coeffs,
      crystal_gridding,
      map_data,
      thresholds = [0,0.1,0.2,0.3,0.4,0.5]):
  m = get_map(map_coeffs=map_coeffs, crystal_gridding=crystal_gridding)
  if(map_data is None): map_data = m
  else:
    maptbx.intersection(
      map_data_1 = m,
      map_data_2 = map_data,
      thresholds = flex.double(thresholds),
      average    = True)
  return map_data

class weighted_average(object):
  def __init__(self, fmodel, map_coefficients):
    self.map_coefficients_data = map_coefficients.data()
    self.map_coefficients = map_coefficients
    f_o = fmodel.f_obs().data()
    i_o = f_o * f_o
    i_c = abs(fmodel.f_model_scaled_with_k1()).data() * \
          abs(fmodel.f_model_scaled_with_k1()).data()
    sig = fmodel.f_obs().sigmas()
    self.r = abs(i_o-i_c)/abs(i_o+i_c)
    if(sig is None):
      sig = flex.double(f_o.size(), 1)
    self.so = sig/f_o

  def random_weight_averaged_map_coefficients(self,
        random_scale, random_seed, n_cycles, fraction_keep, missing=None):
    assert self.map_coefficients_data.size() == \
           self.r.size() == \
           self.so.size()
    mc_data = maptbx.fem_averaging_loop(
      map_coefficients = self.map_coefficients_data,
      r_factors        = self.r,
      sigma_over_f_obs = self.so,
      random_scale     = random_scale,
      random_seed      = random_seed,
      n_cycles         = n_cycles)
    mc_wa = self.map_coefficients.customized_copy(data = mc_data)
    if(missing is not None):
      mc_wa = mc_wa.complete_with(other=missing, scale=True)
    return mc_wa.select(flex.random_bool(mc_wa.size(), fraction_keep))

def randomize_completeness2(map_coeffs, crystal_gridding, n_cycles=10):
  map_filter = None
  from mmtbx.maps import fem
  for cycle in range(n_cycles):
    if(cycle>0):
      mc = map_coeffs.select(flex.random_bool(map_coeffs.size(), 0.99))
    else:
      mc = map_coeffs.deep_copy()
    m = get_map(map_coeffs=mc, crystal_gridding=crystal_gridding)
    maptbx.reset(
      data=m,
      substitute_value=0.0,
      less_than_threshold=0.5,
      greater_than_threshold=-9999,
      use_and=True)
    m  = maptbx.volume_scale(map = m,  n_bins = 10000).map_data()
    if(map_filter is not None):
      map_filter  = maptbx.volume_scale(map = map_filter,  n_bins = 10000).map_data()
    map_filter = fem.intersection(m1=map_filter, m2=m,
      thresholds=flex.double([i/100. for i in range(0,55,5)]),
      average=True)
  #map_filter = map_filter.set_selected(map_filter< 0.5, 0)
  #map_filter = map_filter.set_selected(map_filter>=0.5, 1)
  return map_filter

def randomize_completeness(map_coeffs, crystal_gridding, n_cycles=10,
      thresholds=[0,0.1,0.2,0.3,0.4,0.5]):
  map_data = None
  for cycle in range(n_cycles):
    if(cycle>0):
      mc = map_coeffs.select(flex.random_bool(map_coeffs.size(), 0.95))
    else:
      mc = map_coeffs.deep_copy()
    map_data = compute_map_and_combine(
      map_coeffs        = mc,
      crystal_gridding  = crystal_gridding,
      map_data          = map_data,
      thresholds        = thresholds)
  return map_data

def randomize_struture_factors(map_coeffs, number_of_kicks, phases_only=False):
  map_coeff_data = None
  for kick in range(number_of_kicks):
    rc, ar, pr = random.choice([(0.1, 0.10, 40),
                                (0.2, 0.09, 40),
                                (0.3, 0.08, 30),
                                (0.4, 0.07, 30),
                                (0.5, 0.06, 20),
                                (0.6, 0.05, 20),
                                (0.7, 0.04, 20),
                                (0.8, 0.03, 10),
                                (0.9, 0.02, 10),
                                (1.0, 0.01, 10)
                               ])
    if(phases_only): ar = 0
    sel = flex.random_bool(map_coeffs.size(), rc)
    mc = map_coeffs.randomize_amplitude_and_phase(
      amplitude_error=ar, phase_error_deg=pr, selection=sel)
    if(map_coeff_data is None): map_coeff_data = mc.data()
    else:                       map_coeff_data = map_coeff_data + mc.data()
  map_coeff_data = map_coeff_data/number_of_kicks
  return miller.set(
    crystal_symmetry = map_coeffs.crystal_symmetry(),
    indices          = map_coeffs.indices(),
    anomalous_flag   = False).array(data = map_coeff_data)

def kick_map_coeffs(
      map_coeffs,
      crystal_gridding,
      number_of_kicks,
      macro_cycles,
      missing           = None,
      kick_completeness = 0.95,
      phases_only       = False):
  map_data = None
  if(macro_cycles==0):
    map_data = compute_map_and_combine(
      map_coeffs       = map_coeffs,
      crystal_gridding = crystal_gridding,
      map_data         = map_data)
  for it in range(macro_cycles):
    print("  %d"%it)
    if(number_of_kicks>0):
      mc = randomize_struture_factors(map_coeffs=map_coeffs,
        number_of_kicks=number_of_kicks, phases_only=phases_only)
    else:
      mc = map_coeffs.deep_copy()
    if(missing is not None):
      mc = mc.complete_with(other=missing, scale=True)
    if(kick_completeness):
      mc = mc.select(flex.random_bool(mc.size(), kick_completeness))
    map_data = compute_map_and_combine(
      map_coeffs       = mc,
      crystal_gridding = crystal_gridding,
      map_data         = map_data)
  return map_data

def kick_fmodel(
      fmodel,
      map_type,
      crystal_gridding,
      number_of_kicks,
      macro_cycles,
      missing           = None,
      kick_completeness = 0.95):
  f_model = fmodel.f_model_no_scales()
  zero = fmodel.f_calc().customized_copy(data =
    flex.complex_double(fmodel.f_calc().data().size(), 0))
  fmodel_dc  = mmtbx.f_model.manager(
    f_obs         = fmodel.f_obs(),
    r_free_flags  = fmodel.r_free_flags(),
    k_isotropic   = fmodel.k_isotropic(),
    k_anisotropic = fmodel.k_anisotropic(),
    f_calc        = fmodel.f_model_no_scales(),
    f_part1       = fmodel.f_part1(),
    f_part2       = fmodel.f_part2(),
    f_mask        = zero)
  r1 = fmodel.r_work()
  r2 = fmodel_dc.r_work()
  assert approx_equal(r1, r2, 1.e-4), [r1, r2]
  def get_mc(fm):
   return fm.electron_density_map().map_coefficients(
       map_type     = map_type,
       isotropize   = True,
       fill_missing = False)
  def recreate_r_free_flags(fmodel):
    rc = random.choice([0.05, 0.9])
    r_free_flags = flex.random_bool(fmodel.f_obs().indices().size(), rc)
    fmodel._r_free_flags._data = r_free_flags
    return fmodel
  map_data = None
  for it in range(macro_cycles):
    print("  %d"%it)
    f_model_kick = randomize_struture_factors(map_coeffs=f_model,
      number_of_kicks=number_of_kicks)
    fmodel_dc = recreate_r_free_flags(fmodel = fmodel_dc)
    fmodel_dc.update(f_calc = f_model_kick)
    mc = get_mc(fm=fmodel_dc)
    if(missing is not None):
      mc = mc.complete_with(missing, scale=True)
    if(kick_completeness):
      mc = mc.select(flex.random_bool(mc.size(), kick_completeness))
    map_data = compute_map_and_combine(
      map_coeffs       = mc,
      crystal_gridding = crystal_gridding,
      map_data         = map_data)
  return map_data

class run(object):
  """
  Note 1: Assume Fmodel has correct scaling already (all f_parts etc).
  Note 2: More macro_cycles can substantially clean map in extremely bad cases.
  """

  def __init__(
      self,
      fmodel,
      map_type           = "2mFo-DFc",
      mask_data          = None,
      crystal_gridding   = None,
      number_of_kicks    = 100,
      macro_cycles       = 10,
      kick_completeness  = 0.95,
      omit               = True):
    fmodel = self.convert_to_non_anomalous(fmodel=fmodel)
    from mmtbx import map_tools
    self.mc_orig = map_tools.electron_density_map(
      fmodel=fmodel).map_coefficients(
        map_type     = "2mFo-DFc",
        isotropize   = True,
        fill_missing = False)
    md_orig = get_map(map_coeffs=self.mc_orig, crystal_gridding=crystal_gridding)
    # model missing
    self.complete_set = map_tools.resolve_dm_map(
      fmodel       = fmodel,
      map_coeffs   = self.mc_orig,
      pdb_inp      = None,
      use_model_hl = True,
      fill         = True)
    md_complete_set = get_map(map_coeffs=self.complete_set, crystal_gridding=crystal_gridding)
    self.missing = self.complete_set.lone_set(self.mc_orig)
    # Kick map coefficients
    md_kick = kick_map_coeffs(
      map_coeffs        = self.mc_orig,
      crystal_gridding  = crystal_gridding,
      number_of_kicks   = number_of_kicks,
      macro_cycles      = macro_cycles,
      missing           = self.missing,
      kick_completeness = kick_completeness)
    self.mc_kick = self.map_coeffs_from_map(map_data=md_kick)
    # Kick fmodel
    md_fm = kick_fmodel(
      fmodel            = fmodel,
      map_type          = map_type,
      crystal_gridding  = crystal_gridding,
      number_of_kicks   = number_of_kicks,
      macro_cycles      = macro_cycles,
      missing           = self.missing,
      kick_completeness = kick_completeness)
    self.mc_fm = self.map_coeffs_from_map(map_data=md_fm)
    if(omit):
    # Kick OMIT map
      com1 = mmtbx.maps.composite_omit_map.run(
        crystal_gridding     = crystal_gridding,
        fmodel               = fmodel.deep_copy(), # XXX
        full_resolution_map  = True,
        box_size_as_fraction = 0.03)
      md_com1 = kick_map_coeffs(
        map_coeffs        = com1.map_coefficients(),
        crystal_gridding  = crystal_gridding,
        number_of_kicks   = number_of_kicks,
        macro_cycles      = macro_cycles,
        phases_only       = True,
        missing           = self.missing,
        kick_completeness = kick_completeness)
      self.mc_com1 = self.map_coeffs_from_map(map_data=md_com1)
      # Kick OMIT map 2
      com2 = mmtbx.maps.composite_omit_map.run(
        crystal_gridding     = crystal_gridding,
        fmodel               = fmodel.deep_copy(), # XXX
        full_resolution_map  = True,
        box_size_as_fraction = 0.03)
      md_com2 = kick_map_coeffs(
        map_coeffs        = com2.map_coefficients(),
        crystal_gridding  = crystal_gridding,
        number_of_kicks   = number_of_kicks,
        macro_cycles      = macro_cycles,
        phases_only       = True,
        missing           = self.missing,
        kick_completeness = kick_completeness)
      self.mc_com2 = self.map_coeffs_from_map(map_data=md_com2)
    # combine maps
    def intersect(m1,m2, use_average):
      maptbx.intersection(
        map_data_1 = m1,
        map_data_2 = m2,
        thresholds = flex.double([0,0.1,0.2,0.3,0.4,0.5]),
        average    = False)
      if(use_average): return (m1+m2)/2
      else:            return m1
    m = (md_kick + md_fm)/2
    m = intersect(m, md_kick,         use_average=True)
    m = intersect(m, md_fm,           use_average=True)
    if(omit):
      m = intersect(m, md_com1,         use_average=False)
      m = intersect(m, md_com2,         use_average=False)
    m = intersect(m, md_orig,         use_average=False)
    m = intersect(m, md_complete_set, use_average=False)
    self.map_data_result = m
    self.mc_result  = self.map_coeffs_from_map(map_data=self.map_data_result)

  def write_mc(self, file_name="mc.mtz"):
    mtz_dataset = self.mc_orig.as_mtz_dataset(column_root_label="mc_orig")
    mtz_dataset.add_miller_array(
      miller_array=self.mc_kick,
      column_root_label="mc_kick")
    mtz_dataset.add_miller_array(
      miller_array=self.mc_fm,
      column_root_label="mc_fm")
    if(omit):
      mtz_dataset.add_miller_array(
        miller_array=self.mc_com1,
        column_root_label="mc_com1")
      mtz_dataset.add_miller_array(
        miller_array=self.mc_com2,
        column_root_label="mc_com2")
    mtz_dataset.add_miller_array(
      miller_array=self.mc_result,
      column_root_label="mc_result")
    mtz_dataset.add_miller_array(
      miller_array=self.complete_set,
      column_root_label="complete_set")
    mtz_object = mtz_dataset.mtz_object()
    mtz_object.write(file_name = file_name)

  def map_coeffs_from_map(self, map_data):
    return self.mc_orig.structure_factors_from_map(
      map            = map_data,
      use_scale      = True,
      anomalous_flag = False,
      use_sg         = False)

  def convert_to_non_anomalous(self, fmodel):
    if(fmodel.f_obs().anomalous_flag()):
      f_obs        = fmodel.f_obs().average_bijvoet_mates()
      r_free_flags = fmodel.r_free_flags().average_bijvoet_mates()
      fmodel = mmtbx.f_model.manager(
        f_obs = f_obs,
        r_free_flags = r_free_flags,
        xray_structure = fmodel.xray_structure)
      fmodel.update_all_scales()
    return fmodel


 *******************************************************************************


 *******************************************************************************
mmtbx/maps/map_model_cc.py
from __future__ import absolute_import, division, print_function
from scitbx.array_family import flex
import sys
from libtbx import group_args
from libtbx.utils import Sorry
import mmtbx.maps.correlation
from cctbx import maptbx
import iotbx.phil
from libtbx import adopt_init_args
from mmtbx.maps import mtriage


master_params_str = """
map_model_cc {
  resolution = None
    .type = float
    .help = Data (map) resolution
    .short_caption = Resolution (optional in GUI)
    .expert_level=1
  scattering_table = wk1995  it1992 n_gaussian  neutron *electron
    .type = choice
    .help = Scattering table (X-ray, neutron or electron)
    .expert_level=0
  atom_radius = None
    .type = float
    .help = Atom radius for masking. If undefined then calculated automatically
    .short_caption = Atom radius (optional)
    .expert_level=0
  keep_map_calc = False
    .type = bool
    .help = Keep model-calculated map
    .expert_level=3
  wrapping = None
    .type = bool
    .help = You can specify whether your maps wrap around outside boundaries
    .short_caption = Wrapping (optional)
    .expert_level=3
  ignore_symmetry_conflicts = False
    .type = bool
    .help = You can ignore the symmetry information (CRYST1) from \
            coordinate files. This may be necessary if your model has been\
            placed in a box with box_map for example.
    .expert_level=2

  compute {
    cc_per_chain = True
      .type = bool
      .help = Compute local model-map CC for each chain
      .short_caption = CC by chain
    cc_per_residue = True
      .type = bool
      .help = Compute local model-map CC for each residue
      .short_caption = CC by residue
    cc_per_residue_group = False
      .type = bool
      .help = Compute local model-map CC for each residue group
      .short_caption = CC by residue group
    fsc = True
      .type = bool
      .help = Compute FSC
      .short_caption = FSC
    cc_mask = True
      .type = bool
    cc_volume = True
      .type = bool
    cc_peaks = True
      .type = bool
    cc_box = True
      .type = bool
    cc_image = False
      .type = bool
  }
}
"""

def master_params():
  return iotbx.phil.parse(master_params_str, process_includes=False)

class map_model_cc(object):
  def __init__(self, map_data, pdb_hierarchy, crystal_symmetry, params):
    adopt_init_args(self, locals())
    self.five_cc_result = None
    self.cc_per_chain = []
    self.cc_per_residue = []
    self.cc_main_chain = None
    self.cc_side_chain = None
    self.cc_per_residue_group = flex.double()

  def validate(self):
    assert not None in [self.map_data, self.pdb_hierarchy,
      self.crystal_symmetry, self.params]
    if(self.params.resolution is None):
      raise Sorry("Resolution is required.")

  def run(self):
    xrs = self.pdb_hierarchy.extract_xray_structure(
      crystal_symmetry=self.crystal_symmetry)
    xrs.scattering_type_registry(table = self.params.scattering_table)
    soin = maptbx.shift_origin_if_needed(
      map_data         = self.map_data,
      sites_cart       = xrs.sites_cart(),
      crystal_symmetry = self.crystal_symmetry)
    map_data = soin.map_data
    xrs.set_sites_cart(soin.sites_cart)
    self.five_cc = mmtbx.maps.correlation.five_cc(
      map               = map_data,
      xray_structure    = xrs,
      keep_map_calc     = self.params.keep_map_calc,
      d_min             = self.params.resolution,
      compute_cc_mask   = self.params.compute.cc_mask,
      compute_cc_volume = self.params.compute.cc_volume,
      compute_cc_peaks  = self.params.compute.cc_peaks,
      compute_cc_box    = self.params.compute.cc_box,
      compute_cc_image  = self.params.compute.cc_image)
    # Atom radius
    self.atom_radius = mtriage.get_atom_radius(
      xray_structure = xrs,
      resolution     = self.params.resolution,
      radius         = self.params.atom_radius)
    #
    cc_calculator = mmtbx.maps.correlation.from_map_and_xray_structure_or_fmodel(
      xray_structure = xrs,
      map_data       = map_data,
      d_min          = self.params.resolution)
    #
    def get_common_data(atoms, atom_radius):
      sel = atoms.extract_i_seq()
      cc = cc_calculator.cc(selection = sel, atom_radius = atom_radius)
      return group_args(
        b_iso_mean = flex.mean(atoms.extract_b()),
        occ_mean   = flex.mean(atoms.extract_occ()),
        n_atoms    = atoms.size(),
        cc         = cc,
        xyz_mean   = atoms.extract_xyz().mean())
    # CC per chain
    if(self.params.compute.cc_per_chain):
      for chain in self.pdb_hierarchy.chains():
        cd = get_common_data(atoms=chain.atoms(), atom_radius=self.atom_radius)
        self.cc_per_chain.append(group_args(
          chain_id   = chain.id,
          b_iso_mean = cd.b_iso_mean,
          occ_mean   = cd.occ_mean,
          n_atoms    = cd.n_atoms,
          cc         = cd.cc))
    # CC per residue
    if(self.params.compute.cc_per_residue):
      for rg in self.pdb_hierarchy.residue_groups():
        for conformer in rg.conformers():
          for residue in conformer.residues():
            cd = get_common_data(
              atoms       = residue.atoms(),
              atom_radius = self.atom_radius)
            self.cc_per_residue.append(group_args(
              model_id   = rg.parent().parent().id,
              chain_id   = rg.parent().id,
              resname    = residue.resname,
              resseq     = residue.resseq,
              icode      = residue.icode,
              b_iso_mean = cd.b_iso_mean,
              occ_mean   = cd.occ_mean,
              n_atoms    = cd.n_atoms,
              cc         = cd.cc,
              xyz_mean   = cd.xyz_mean))
    # CC per residue group
    if(self.params.compute.cc_per_residue_group):
      for rg in self.pdb_hierarchy.residue_groups():
        rg_cc = cc_calculator.cc(
          selection   = rg.atoms().extract_i_seq(),
          atom_radius = self.atom_radius)
        self.cc_per_residue_group.append(rg_cc)
    # Side chain
    sel_mc_str = "protein and (name C or name N or name CA or name O or name CB)"
    asc = self.pdb_hierarchy.atom_selection_cache()
    sel_mc = asc.selection(sel_mc_str)
    sel_sc = ~sel_mc
    if(sel_mc.count(True)>0):
      self.cc_main_chain = get_common_data(
        atoms       = self.pdb_hierarchy.select(sel_mc).atoms(),
        atom_radius = self.atom_radius)
    if(sel_sc.count(True)>0):
      self.cc_side_chain = get_common_data(
        atoms       = self.pdb_hierarchy.select(sel_sc).atoms(),
        atom_radius = self.atom_radius)

  def get_results(self):
    return group_args(
      cc_mask        = self.five_cc.result.cc_mask,
      cc_volume      = self.five_cc.result.cc_volume,
      cc_peaks       = self.five_cc.result.cc_peaks,
      cc_box         = self.five_cc.result.cc_box,
      map_calc       = self.five_cc.result.map_calc,
      cc_per_chain   = self.cc_per_chain,
      cc_per_residue = self.cc_per_residue,
      cc_per_residue_group = self.cc_per_residue_group,
      cc_main_chain  = self.cc_main_chain,
      cc_side_chain  = self.cc_side_chain,
      atom_radius    = self.atom_radius)

if (__name__ == "__main__"):
  run(args=sys.argv[1:])


 *******************************************************************************


 *******************************************************************************
mmtbx/maps/mtriage.py
from __future__ import absolute_import, division, print_function
import sys
from libtbx import group_args
from cctbx import maptbx
import iotbx.phil
from libtbx import adopt_init_args
from cctbx.maptbx import resolution_from_map_and_model
from libtbx import group_args
from cctbx import miller, adptbx
from mmtbx import masks
from scitbx.array_family import flex
import time
from libtbx import introspection
from libtbx.str_utils import size_as_string_with_commas
from libtbx.utils import null_out,Sorry

def show_process_info(out):
  print("\\/"*39, file=out)
  introspection.virtual_memory_info().show_if_available(out=out, show_max=True)
  print("/\\"*39, file=out)
  out.flush()

master_params_str = """
  scattering_table = wk1995  it1992  n_gaussian  neutron *electron
    .type = choice
    .help = Scattering table (X-ray, neutron or electron)
  compute {
    map_counts = True
      .type = bool
      .help = Compute map counts
    fsc_curve_model = True
      .type = bool
      .help = Compute model-map CC in reciprocal space: FSC(model map, data map)
    d_fsc_half_map_05 = False
      .type = bool
      .help = Compute d_half_map (FSC=0.5)
    d_fsc_model_05 = True
      .type = bool
      .help = Compute d_fsc_model (FSC=0.5)
    d_fsc_model_0 = True
      .type = bool
      .help = Compute d_fsc_model (FSC=0)
    d_fsc_model_0143 = True
      .type = bool
      .help = Compute d_fsc_model (FSC=0.143)
    d_model = True
      .type = bool
      .help = Resolution estimate using model and map
    d_model_b0 = True
      .type = bool
      .help = Resolution estimate using model and map, assumin all atoms B=0
    d99 = True
      .type = bool
      .help = Resolution estimate d99
  }
  resolution = None
    .type = float
    .help = Map resolution (d_FSC)
  mask_maps = None
    .type = bool
    .help = Mask out region outside molecule
    .style = tribool
  auto_mask_if_no_model = True
    .type = bool
    .help = If mask_maps is set and no model is present, mask based on density
    .style = tribool
  auto_mask_if_model = False
    .type = bool
    .help = If mask_maps is set and model is present, mask based on density
    .style = tribool
  radius_smooth = None
    .type = float
    .help = Mask smoothing radius
    .short_caption = Mask smoothing radius
  radius_smooth_ratio = 2
    .type = float
    .help = If mask smoothing radius is not specified it will be \
               radius_smooth_ratio times the resolution
    .short_caption = Mask smoothing radius ratio
  n_bins = None
    .type = int
    .help = Number of bins for FSC curves. Suggested number is 5000. \
           Alternative is default (None) which gives bins of width 100.
    .short_caption = Bins for FSC
  nproc = 1
    .type = int
    .help = Number of processors to use
  show_time = False
    .type = bool
    .help = Show individual run times for each step
  include_curves = True
    .type = bool
    .help = "Keep FSC curves"
  include_mask = True
    .type = bool
    .help = "Keep mask"
  wrapping = None
    .type = bool
    .help = You can ignore the wrapping information from map files and set it
    .expert_level = 2
"""

def show_histogram(map_histograms, log):
  if(map_histograms.h_half_map_1 is None):
    hm = map_histograms.h_map
    print("                   Values                 Map", file=log)
    lc_1 = hm.data_min()
    s_1 = enumerate(hm.slots())
    for (i_1,n_1) in s_1:
      hc_1 = hm.data_min() + hm.slot_width() * (i_1+1)
      print("%8.4f - %-8.4f : %d" % (lc_1, hc_1, n_1), file=log)
      lc_1 = hc_1
  else:
    print("                Full map                   Half-map1 Half-map2", file=log)
    h0 = map_histograms.h_map
    h1 = map_histograms.h_half_map_1
    h2 = map_histograms.h_half_map_2
    data_min = map_histograms._data_min
    lc_2 = data_min
    lc_1 = h0.data_min()
    s_0 = enumerate(h0.slots())
    s_1 = h1.slots()
    s_2 = h2.slots()
    for (i_1,n_1) in s_0:
      hc_1 = h0.data_min() + h0.slot_width() * (i_1+1)
      hc_2 = data_min + h2.slot_width() * (i_1+1)
      print("%8.4f - %-8.4f : %9d %8.4f - %-8.4f : %9d %9d" % (
        lc_1, hc_1, n_1, lc_2, hc_2, s_1[i_1], s_2[i_1]), file=log)
      lc_1 = hc_1
      lc_2 = hc_2
    print("  Half-maps, correlation of histograms: ", \
      map_histograms.half_map_histogram_cc, file=log)

def get_fsc(map_data, model, params):
  result = None
  if(params.compute.fsc):
    mtriage_params = master_params().extract()
    mtriage_params.scattering_table = params.scattering_table
    mtriage_params.compute.map_counts = False
    mtriage_params.compute.fsc_curve_model = True
    mtriage_params.compute.d_fsc_model_05 = False
    mtriage_params.compute.d_fsc_model_0 = False
    mtriage_params.compute.d_fsc_model_0143 = False
    mtriage_params.compute.d_model = False
    mtriage_params.compute.d_model_b0 = False
    mtriage_params.compute.d99 = False
    mtriage_params.mask_maps = True
    mtriage_params.resolution = params.resolution
    result = mtriage(
      map_data       = map_data,
      xray_structure = model.get_xray_structure(),
      params         = mtriage_params).get_results().masked.fsc_curve_model
  return result

def get_atom_radius(xray_structure=None, resolution=None, radius=None):
  if(radius is not None): return radius
  radii = []
  if(resolution is not None):
    radii.append(resolution)
  if(xray_structure is not None and resolution is not None):
    b_iso = adptbx.u_as_b(
      flex.mean(xray_structure.extract_u_iso_or_u_equiv()))
    o = maptbx.atom_curves(scattering_type="C", scattering_table="electron")
    rad_image = o.image(d_min=resolution, b_iso=b_iso,
      radius_max=max(15.,resolution), radius_step=0.1).radius
    radii.append(rad_image)
  return max(3, min(10, max(radii)))

def master_params():
  return iotbx.phil.parse(master_params_str, process_includes=False)

class caller(object):
  def __init__(self, show=False):
    self.time_cumulative = 0
    self.show=show

  def call(self, f, msg):
    t0 = time.time()
    f()
    sa=size_as_string_with_commas(
      introspection.virtual_memory_info().current_max_sizes().virtual_memory)
    if(self.show):
      delta = time.time()-t0
      self.time_cumulative += delta
      print("%6.2f %8.2f %15s:"%(delta, self.time_cumulative, sa), msg)
      sys.stdout.flush()

class mtriage(object):
  def __init__(self,
               map_data,
               map_data_1       = None,
               map_data_2       = None,
               xray_structure   = None,
               crystal_symmetry = None,
               params           = None):
    self.map_data   = map_data.deep_copy()
    self.map_data_1 = None
    self.map_data_2 = None
    if(map_data_1 is not None): self.map_data_1 = map_data_1.deep_copy()
    if(map_data_2 is not None): self.map_data_2 = map_data_2.deep_copy()
    self.xray_structure   = xray_structure
    self.crystal_symmetry = crystal_symmetry
    self.params           = params
    self.results_masked   = None
    self.results_unmasked = None
    self.time_cumulative  = 0
    if(self.params is None):
      self.params = master_params().extract()
    self.caller = caller(show=self.params.show_time)

  def call(self, func, prefix):
    t0 = time.time()
    result = func()
    sa=size_as_string_with_commas(
      introspection.virtual_memory_info().current_max_sizes().virtual_memory)
    if(self.params.show_time):
      delta = time.time()-t0
      self.time_cumulative += delta
      print("%6.2f %8.2f %15s:"%(delta, self.time_cumulative, sa), prefix)
      sys.stdout.flush()
    return result

  def _run(self):
    if(self.params.mask_maps is None):
      # No masking
      self.params.mask_maps = False
      self.results_unmasked = _mtriage(
        map_data         = self.map_data,
        map_data_1       = self.map_data_1,
        map_data_2       = self.map_data_2,
        xray_structure   = self.xray_structure,
        crystal_symmetry = self.crystal_symmetry,
        params           = self.params,
        caller           = self.caller
      ).run().get_results(
        include_curves = self.params.include_curves,
        include_mask   = self.params.include_mask)
      # Masking
      self.params.mask_maps = True
      self.results_masked = _mtriage(
        map_data         = self.map_data,
        map_data_1       = self.map_data_1,
        map_data_2       = self.map_data_2,
        xray_structure   = self.xray_structure,
        crystal_symmetry = self.crystal_symmetry,
        params           = self.params,
        caller           = self.caller
      ).run().get_results(
        include_curves = self.params.include_curves,
        include_mask   = self.params.include_mask)
    else:
      result = _mtriage(
        map_data         = self.map_data,
        map_data_1       = self.map_data_1,
        map_data_2       = self.map_data_2,
        xray_structure   = self.xray_structure,
        crystal_symmetry = self.crystal_symmetry,
        params           = self.params,
        caller           = self.caller
      ).run().get_results(
        include_curves = self.params.include_curves,
        include_mask   = self.params.include_mask)
      if(self.params.mask_maps): self.results_masked = result
      else:                      self.results_unmasked = result

  def get_results(self):
    self._run()
    cs = self.crystal_symmetry
    if(cs is None): cs = self.xray_structure.crystal_symmetry()
    return group_args(
      crystal_symmetry = cs,
      masked   = self.results_masked,
      unmasked = self.results_unmasked)

class _mtriage(object):
  def __init__(self,
        map_data,
        map_data_1,
        map_data_2,
        xray_structure,
        crystal_symmetry,
        caller,
        params):
    adopt_init_args(self, locals())
    if(self.crystal_symmetry is None):
      self.crystal_symmetry = self.xray_structure.crystal_symmetry()
    self.call = self.caller.call
    self.resolution = self.params.resolution
    # Results
    self.d99              = None
    self.d99_1            = None
    self.d99_2            = None
    self.d_model          = None
    self.d_model_b0       = None
    self.b_iso_overall    = None
    self.d_fsc            = None
    self.d_fsc_05         = None
    self.d_fsc_model_05   = None
    self.d_fsc_model_0    = None
    self.d_fsc_model_0143 = None
    self.fsc_curve        = None
    self.fsc_curve_model  = None
    self.mask_smooth      = None
    self.radius_smooth    = self.params.radius_smooth
    self.auto_masked      = None
    self.n_bins           = self.params.n_bins
    self.d_corner         = None
    # Info (results)
    self.map_counts        = None
    self.half_map_1_counts = None
    self.half_map_2_counts = None
    self.map_histograms    = None
    # Internal work objects
    self.f_map    = None
    self.f_map_1  = None
    self.f_map_2  = None
    self.f_calc   = None

  def run(self):
    # Compute radius
    self.call(f=self._compute_radius, msg="Compute radius")
    # Compute and apply mask
    self.call(f=self._compute_and_apply_mask, msg="Masking")
    # Compute F_maps
    self.call(f=self._compute_f_maps, msg="Compute F_maps")
    # Compute d99
    self.call(f=self._compute_d99, msg="Compute d99")
    # Strategy adjustments based on d99
    self.call(f=self._adjust, msg="Adjustments based on d99")
    # Compute half-map FSC
    self.call(f=self._compute_half_map_fsc, msg="Compute half-map FSC")
    # Compute half-map FSC at 0.5
    self.call(f=self._compute_half_map_fsc_05, msg="Compute half-map FSC_05")
    # Compute Fcalc
    self.call(f=self._compute_f_calc, msg="Compute Fcalc")
    # Map-model FSC curve
    self.call(f=self._compute_fsc_curve_model, msg="Compute fsc_curve_model")
    # d_fsc_model_0
    self.call(f=self._compute_f_fsc_model_0, msg="Compute d_fsc_model_0")
    # d_fsc_model_0143
    self.call(f=self._compute_f_fsc_model_0143, msg="Compute d_fsc_model_0143")
    # d_fsc_model_05
    self.call(f=self._compute_f_fsc_model_05, msg="Compute d_fsc_model_05")
    # Compute d_model
    self.call(f=self._compute_d_model, msg="Compute d_model")
    return self

  def _adjust(self):
    return None # XXX It is not clear why this is needed.
    if(self.d99 and self.d99>10.): # Atomic model isn't suitable?
      self.params.compute.fsc_curve_model = False
      self.params.compute.d_fsc_model_05  = False
      self.params.compute.d_fsc_model_0   = False
      self.params.compute.d_fsc_model_0143= False
      self.params.compute.d_model         = False
      self.params.compute.d_model_b0      = False

  def _compute_radius(self):
    if(not self.params.mask_maps): return
    if(self.radius_smooth is not None): return
    if self.resolution and self.params.radius_smooth_ratio:
      self.radius_smooth = \
          self.params.resolution*self.params.radius_smooth_ratio
      return
    if(self.xray_structure is None):
      if(self.resolution):  # resolution but no smooth ratio
        self.radius_smooth = self.resolution
      return
    if(self.xray_structure is not None and
       [self.radius_smooth, self.resolution].count(None)==2):
      f_map = miller.structure_factor_box_from_map(
        map              = self.map_data,
        crystal_symmetry = self.crystal_symmetry)
      self.radius_smooth = maptbx.d99(f_map = f_map).result.d99
      if self.params.radius_smooth_ratio:
        self.radius_smooth = self.radius_smooth *self.params.radius_smooth_ratio
    self.radius_smooth = get_atom_radius(
      xray_structure   = self.xray_structure,
      radius           = self.radius_smooth,
      resolution       = self.resolution)

  def _compute_soft_mask_from_density(self):

    from cctbx.maptbx.segment_and_split_map import get_iterated_solvent_fraction
    mask_data,solvent_fraction=get_iterated_solvent_fraction(
        crystal_symmetry=self.crystal_symmetry,
        fraction_of_max_mask_threshold=0.05, #
        cell_cutoff_for_solvent_from_mask=1, # Use low-res method always
        mask_resolution=self.resolution,
        return_mask_and_solvent_fraction=True,
        verbose=False,
        map=self.map_data,
        out=null_out())

    if solvent_fraction:
      from cctbx.maptbx.segment_and_split_map import apply_soft_mask
      map_data,smoothed_mask_data=apply_soft_mask(map_data=self.map_data,
        mask_data=mask_data.as_double(),
        rad_smooth=self.radius_smooth,
        crystal_symmetry=self.crystal_symmetry,
        out=null_out())

      return smoothed_mask_data
    else:
      return None

  def _compute_and_apply_mask(self):
    if(not self.params.mask_maps): return
    # Decide about auto_masking
    auto_mask = False
    if (self.xray_structure is None) and (self.params.auto_mask_if_no_model):
      auto_mask = True
    elif (self.xray_structure is not None) and (self.params.auto_mask_if_model):
      auto_mask = True

    if auto_mask:
      self.mask_smooth=None
      if not self.params.resolution:
          raise Sorry("Need approximate resolution for auto_mask_if_no_model")
      # generate mask from the density
      self.mask_smooth=self._compute_soft_mask_from_density()
      if self.mask_smooth: # it worked
        self.auto_masked = True  # we used auto_mask
      else:
        raise Sorry("Failed to auto-mask...try using a model ")
    else:
      self.mask_smooth = masks.smooth_mask(
        xray_structure = self.xray_structure,
        n_real         = self.map_data.all(),
        rad_smooth     = self.radius_smooth).mask_smooth
    self.map_data = self.map_data*self.mask_smooth
    if(self.map_data_1 is not None):
      self.map_data_1 = self.map_data_1*self.mask_smooth
      self.map_data_2 = self.map_data_2*self.mask_smooth

  def _compute_f_maps(self):
    assert self.map_data.origin()==(0,0,0)
    assert self.map_data.as_1d().count(0) != self.map_data.size() # need data
    if self.map_data_1 is not None:
      assert self.map_data_1.origin()==(0,0,0)
      assert self.map_data.all()==self.map_data_1.all()
    if self.map_data_2 is not None:
      assert self.map_data_2.origin()==(0,0,0)
      assert self.map_data.all()==self.map_data_2.all()

    self.f_map = miller.structure_factor_box_from_map(
      map              = self.map_data,
      crystal_symmetry = self.crystal_symmetry)
    if(self.map_data_1 is not None):
      self.f_map_1 = miller.structure_factor_box_from_map(
        map              = self.map_data_1,
        crystal_symmetry = self.crystal_symmetry)
      self.f_map_2 = miller.structure_factor_box_from_map(
        map              = self.map_data_2,
        crystal_symmetry = self.crystal_symmetry)

  def _compute_d99(self):
    if(not self.params.compute.d99): return
    d99 = maptbx.d99(f_map = self.f_map)
    self.d99    = d99.result.d99
    d99_obj_1, d99_obj_2 = None,None
    if(self.map_data_1 is not None):
      d99_1 = maptbx.d99(
        map              = self.map_data_1,
        crystal_symmetry = self.crystal_symmetry)
      d99_2 = maptbx.d99(
        map              = self.map_data_2,
        crystal_symmetry = self.crystal_symmetry)
      self.d99_1 = d99_1.result.d99
      self.d99_2 = d99_2.result.d99
      self.f_map_1 = d99_1.f_map
      self.f_map_2 = d99_2.f_map

  def _compute_f_calc(self):
    if(self.xray_structure is None): return
    self.f_calc = self.f_map.structure_factors_from_scatterers(
      xray_structure = self.xray_structure).f_calc()

  def _compute_d_model(self):
    if(not self.params.compute.d_model): return
    if(self.xray_structure is not None):
      o = resolution_from_map_and_model.run(
        f_map            = self.f_map,
        d_fsc_model      = self.d_fsc_model_0,
        xray_structure   = self.xray_structure)
      self.d_model       = o.d_min
      self.b_iso_overall = o.b_iso
      self.d_model_b0    = o.d_model_b0

  def _compute_half_map_fsc(self):
    if(self.map_data_1 is not None):
      self.fsc_curve = self.f_map_1.d_min_from_fsc(
        other = self.f_map_2, fsc_cutoff=0.143)
      self.d_fsc = self.fsc_curve.d_min

  def _compute_half_map_fsc_05(self):
    if(not self.params.compute.d_fsc_half_map_05): return
    if(self.map_data_1 is not None):
      self.fsc_curve_05 = self.f_map_1.d_min_from_fsc(
        other = self.f_map_2, fsc_cutoff=0.5)
      self.d_fsc_05 = self.fsc_curve_05.d_min

  def _compute_fsc_curve_model(self):
    if(not self.params.compute.fsc_curve_model): return
    if(self.xray_structure is not None):
      self.fsc_curve_model = self.f_calc.fsc(other=self.f_map)

  def _compute_f_fsc_model_0(self):
    if(not self.params.compute.d_fsc_model_0): return
    if(self.xray_structure is None): return
    assert self.fsc_curve_model is not None
    self.d_fsc_model_0 = self.f_calc.d_min_from_fsc(
      fsc_curve=self.fsc_curve_model, fsc_cutoff=0.).d_min

  def _compute_f_fsc_model_0143(self):
    if(not self.params.compute.d_fsc_model_0143): return
    if(self.xray_structure is None): return
    assert self.fsc_curve_model is not None
    self.d_fsc_model_0143 = self.f_calc.d_min_from_fsc(
      fsc_curve=self.fsc_curve_model, fsc_cutoff=0.143).d_min

  def _compute_f_fsc_model_05(self):
    if(not self.params.compute.d_fsc_model_05): return
    if(self.xray_structure is None): return
    assert self.fsc_curve_model is not None
    self.d_fsc_model_05 = self.f_calc.d_min_from_fsc(
      fsc_curve=self.fsc_curve_model, fsc_cutoff=0.5).d_min

  def get_results(self, include_curves, include_mask):
    mask = None
    if(self.mask_smooth is not None and include_mask):
      mask = self.mask_smooth
    map_histograms  = None
    fsc_curve       = None
    fsc_curve_model = None
    if(include_curves):
      map_histograms  = self.map_histograms
      fsc_curve       = self.fsc_curve
      fsc_curve_model = self.fsc_curve_model
    return group_args(
      d99               = self.d99,
      d99_1             = self.d99_1,
      d99_2             = self.d99_2,
      d_model           = self.d_model,
      d_model_b0        = self.d_model_b0,
      b_iso_overall     = self.b_iso_overall,
      d_fsc             = self.d_fsc,
      d_fsc_05          = self.d_fsc_05,
      d_fsc_model_05    = self.d_fsc_model_05,
      d_fsc_model_0     = self.d_fsc_model_0,
      d_fsc_model_0143  = self.d_fsc_model_0143,
      fsc_curve         = fsc_curve,
      fsc_curve_model   = fsc_curve_model,
      mask              = mask,
      radius_smooth     = self.radius_smooth,
      auto_masked       = self.auto_masked)

if (__name__ == "__main__"):
  run(args=sys.argv[1:])


 *******************************************************************************


 *******************************************************************************
mmtbx/maps/polder.py
from __future__ import absolute_import, division, print_function
import mmtbx.f_model
import mmtbx.masks
from mmtbx import map_tools
from iotbx import phil
from cctbx import maptbx
from cctbx import miller
from cctbx.array_family import flex
from libtbx import group_args
from libtbx.utils import Sorry
from libtbx.math_utils import ifloor, iceil
from six.moves import zip
from six.moves import range


master_params_str = """
polder {
  resolution_factor = 0.25
    .type = float
    .short_caption = Resolution factor
    .help = Used to determine the grid step = resolution_factor * high resolution
  sphere_radius = 5
    .type = float
    .short_caption = Solvent exclusion radius
    .help = Radius of sphere around atoms where solvent mask is reset to zero
  box_buffer = None
    .type = float
    .short_caption = Selection box buffer
    .help = Buffer around selection box: Increase the box for resetting the mask \
     by a buffer.
  compute_box = False
    .type = bool
    .short_caption = Use box
    .help = Reset mask within a box (parallel to unit cell axes) defined by an \
     atom selection
  altloc_scale = False
    .type = bool
    .short_caption = apply scale for altlocs
    .help = Apply special scaling procedure for alternate conformations \
     (only one residue, no mix)
}
"""

def master_params():
  return phil.parse(master_params_str, process_includes = False)

# =============================================================================

class compute_polder_map():
  def __init__(self,
               f_obs,
               r_free_flags,
               model,
               params,
               selection_string):
    self.f_obs = f_obs
    self.r_free_flags = r_free_flags
    self.xray_structure = model.get_xray_structure()
    self.pdb_hierarchy = model.get_hierarchy()
    self.model = model
    self.params = params
    self.selection_string = selection_string
    self.cs = self.xray_structure.crystal_symmetry()
    #
    self.resolution_factor = self.params.resolution_factor
    self.sphere_radius = self.params.sphere_radius
    # New scaling method for alternative conformations
    self.apply_scale_for_altloc = False

  # ---------------------------------------------------------------------------

  def validate(self):
    assert not None in [self.f_obs, self.xray_structure, self.pdb_hierarchy,
      self.params, self.selection_string]

  # ---------------------------------------------------------------------------

  def run(self):
    selection_bool = self.pdb_hierarchy.atom_selection_cache().selection(
      string = self.selection_string)
    ph_selected = self.pdb_hierarchy.select(selection_bool)
    altloc_indices = ph_selected.altloc_indices()
    if (len(altloc_indices) == 2 and '' not in list(altloc_indices) and
      not self.params.compute_box and self.params.altloc_scale):
      self.apply_scale_for_altloc = True
    else:
      self.apply_scale_for_altloc = False

    computed_results = self.compute(selection_bool = selection_bool)
    if not self.apply_scale_for_altloc:
      self.computed_results = computed_results
    else:
      # to be changed with modified code but use this to make it run
      self.computed_results = self.compute_if_altloc(
                                altloc_indices      = altloc_indices,
                                computed_results_AB = computed_results)

  # ---------------------------------------------------------------------------

  def compute_if_altloc(self, altloc_indices, computed_results_AB):
    #
    def combine(mA, mB, sc):
      #m = (mA+mB*sc)/2
      m = maptbx.combine_and_maximize_maps(map_data_1=mA, map_data_2=mB*sc, n_real=mB.all())
      return m/m.sample_standard_deviation()
    def scale(x, y):
      x = flex.abs(x)
      y = flex.abs(y)
      d = flex.sum(y*y)
      return flex.sum(x*y)/d
    def get_map(mc):
      fft_map = mc.fft_map(resolution_factor=0.25)
      #fft_map.apply_volume_scaling()
      fft_map.apply_sigma_scaling()
      m = fft_map.real_map_unpadded()
      return m
    # Not sure if this definition of sel strings can be prone to errors...
    sel_A_string = self.selection_string + ' altloc %s' % list(altloc_indices)[0]
    sel_B_string = self.selection_string + ' altloc %s' % list(altloc_indices)[1]
    sel_AB_string = self.selection_string
    sel_A = self.model.selection(string=sel_A_string)
    sel_B = self.model.selection(string=sel_B_string)
    sel_AB = self.model.selection(string=sel_AB_string)
    sf_A = self.model.get_sites_frac().select(sel_A)
    sf_B = self.model.get_sites_frac().select(sel_B)
    sf_AB = self.model.get_sites_frac().select(sel_AB)
    #
    computed_results_A = self.compute(selection_bool = sel_A)
    computed_results_B = self.compute(selection_bool = sel_B)
    mc_A_polder = computed_results_A.mc_polder
    mc_B_polder = computed_results_B.mc_polder
    mc_AB_polder = computed_results_AB.mc_polder
    m_A  = get_map(mc_A_polder)
    m_B  = get_map(mc_B_polder)
    m_AB = get_map(mc_AB_polder)
    mv_A = flex.double()
    mv_B = flex.double()
    for sf_A_, sf_B_ in zip(sf_A, sf_B):
      mv_A.append(m_A.tricubic_interpolation(sf_A_))
      mv_B.append(m_B.tricubic_interpolation(sf_B_))
    sc = scale(mv_A, mv_B)
    m = combine(m_A, m_B, sc)
    ###
    mv_A = flex.double()
    mv_B = flex.double()
    for sf_ in sf_AB:
      mv_A.append(m.tricubic_interpolation(sf_))
      mv_B.append(m_AB.tricubic_interpolation(sf_))
    sc = scale(mv_A, mv_B)
    m = combine(m, m_AB, sc)
    #
    mc = maptbx.map_to_map_coefficients(m=m, cs=self.cs, d_min=mc_A_polder.d_min())
#    mtz_dataset = mc.as_mtz_dataset(column_root_label='polder')
#    mtz_object = mtz_dataset.mtz_object()
#    mtz_object.write(file_name = "%s.mtz"%'polder_cl')
    #
    computed_results = computed_results_AB
    computed_results.mc_polder = mc

    return computed_results

  # ---------------------------------------------------------------------------

  def compute(self, selection_bool):
    # When extracting cartesian coordinates, xray_structure needs to be in P1:
    sites_cart_ligand_expanded = self.xray_structure.select(
      selection_bool).expand_to_p1(sites_mod_positive = True).sites_cart()
    sites_frac_ligand_expanded = self.xray_structure.select(
      selection_bool).expand_to_p1(sites_mod_positive = False).sites_frac()
    # xray_structure object without ligand/selection
    if (self.params.compute_box):
      xray_structure_noligand = self.xray_structure
    else:
      xray_structure_noligand = self.xray_structure.select(~selection_bool)
    self.crystal_gridding = self.f_obs.crystal_gridding(
      d_min             = self.f_obs.d_min(),
      symmetry_flags    = maptbx.use_space_group_symmetry,
      resolution_factor = self.resolution_factor)
    n_real = self.crystal_gridding.n_real()
    # Mask using all atoms
    mask_data_all = self.mask_from_xrs_unpadded(
      xray_structure = self.xray_structure,
      n_real         = n_real)
    # Mask if ligand is not in model
    mask_data_omit = self.mask_from_xrs_unpadded(
      xray_structure = xray_structure_noligand,
      n_real         = n_real)
    # Polder mask
    if (self.params.compute_box):
      # TODO: check if mask_omit = mask_all
      mask_data_polder = self.modify_mask_box(
        mask_data  = mask_data_all.deep_copy(),
        sites_frac =  sites_frac_ligand_expanded,
        selection_bool = selection_bool)
    else:
      mask_data_polder = self.modify_mask(
        mask_data     = mask_data_all.deep_copy(),
        sites_cart    = sites_cart_ligand_expanded)
    # Compute fmodel and map coeffs for input, biased, polder, omit case
    # Input model
    fmodel_input = mmtbx.f_model.manager(
     f_obs          = self.f_obs,
     r_free_flags   = self.r_free_flags,
     xray_structure = self.xray_structure)
    fmodel_input.update_all_scales()
    # Biased map
    if self.params.compute_box:
      fmodel_biased, mc_biased = None, None
    else:
      fmodel_biased, mc_biased = self.get_fmodel_and_map_coefficients(
          xray_structure = xray_structure_noligand,
          mask_data      = mask_data_all)
    # Polder map
    fmodel_polder, mc_polder = self.get_fmodel_and_map_coefficients(
      xray_structure = xray_structure_noligand,
      mask_data      = mask_data_polder)
    # OMIT map
    fmodel_omit, mc_omit = self.get_fmodel_and_map_coefficients(
      xray_structure = xray_structure_noligand,
      mask_data      = mask_data_omit)
    # Validation only applies if selection present in model:
    if (self.params.compute_box or self.apply_scale_for_altloc):
      validation_results = None
    else:
      validation_results = self.validate_polder_map(
        selection_bool = selection_bool,
        xray_structure_noligand = xray_structure_noligand,
        mask_data_polder = mask_data_polder)

    computed_results = group_args(
      fmodel_input     = fmodel_input,
      fmodel_biased    = fmodel_biased,
      fmodel_omit      = fmodel_omit,
      fmodel_polder    = fmodel_polder,
      mask_data_all    = mask_data_all,
      mask_data_omit   = mask_data_omit,
      mask_data_polder = mask_data_polder,
      mc_biased        = mc_biased,
      mc_polder        = mc_polder,
      mc_omit          = mc_omit,
      validation_results = validation_results)

    return computed_results

  # ---------------------------------------------------------------------------

  def get_results(self):
    return self.computed_results

  # ---------------------------------------------------------------------------

  def modify_mask(self, mask_data, sites_cart):
    sel = maptbx.grid_indices_around_sites(
      unit_cell  = self.cs.unit_cell(),
      fft_n_real = mask_data.focus(),
      fft_m_real = mask_data.all(),
      sites_cart = sites_cart,
      site_radii = flex.double(sites_cart.size(), self.sphere_radius))
    mask = mask_data.as_1d()
    mask.set_selected(sel, 0)
    mask.reshape(mask_data.accessor())
    return mask

  # ---------------------------------------------------------------------------

  def modify_mask_box(self, mask_data, sites_frac, selection_bool):
    box_buffer = self.params.box_buffer
    # Number of selected atoms
    n_selected = selection_bool.count(True)
    na = mask_data.all()
    n_selected_p1 = sites_frac.size()
    n_boxes = int(n_selected_p1/n_selected)
    box_list = [[] for i in range(n_boxes)]
    for n_box in range(n_boxes):
      for i in range(n_selected):
        box_list[n_box].append(sites_frac[n_box + n_boxes*i])
    #na = self.mask_data_all.all()
    k = 0
    for box in box_list:
      k+=1
      x_min = min(frac[0] for frac in box)
      y_min = min(frac[1] for frac in box)
      z_min = min(frac[2] for frac in box)
      x_max = max(frac[0] for frac in box)
      y_max = max(frac[1] for frac in box)
      z_max = max(frac[2] for frac in box)
      frac_min = [x_min, y_min, z_min]
      frac_max = [x_max, y_max, z_max]

      #cs = self.xray_structure.crystal_symmetry()

      # Add buffer to box if indicated.
      if (box_buffer is not None):
        cushion = flex.double(self.cs.unit_cell().fractionalize((box_buffer,)*3))
        frac_min = list(flex.double(frac_min) - cushion)
        frac_max = list(flex.double(frac_max) + cushion)

      gridding_first = [ifloor(f * n) for f,n in zip(frac_min, na)]
      gridding_last  = [iceil(f * n) for f,n in zip(frac_max, na)]

      for j in range(3):
        if (gridding_last[j] - gridding_first[j] >= na[j]):
          raise Sorry("The box is too big. Decrease box_buffer or use a " +
                      "different selection")

      maptbx.set_box(
        value         = 0,
        map_data_to   = mask_data,
        start         = gridding_first,
        end           = gridding_last)
    return mask_data

  # ---------------------------------------------------------------------------

  def mask_from_xrs_unpadded(self, xray_structure, n_real):
    mask_params = mmtbx.masks.mask_master_params.extract()
    mask = mmtbx.masks.mask_from_xray_structure(
      xray_structure           = xray_structure,
      p1                       = True,
      shrink_truncation_radius = mask_params.shrink_truncation_radius,
      solvent_radius           = mask_params.solvent_radius,
      for_structure_factors    = True,
      n_real                   = n_real).mask_data
    maptbx.unpad_in_place(map = mask)
    return mask

  # ---------------------------------------------------------------------------

  def get_fmodel_and_map_coefficients(self, xray_structure, mask_data):
    f_calc = self.f_obs.structure_factors_from_scatterers(
      xray_structure = xray_structure).f_calc()
    mask = self.f_obs.structure_factors_from_map(
      map            = mask_data,
      use_scale      = True,
      anomalous_flag = False,
      use_sg         = False)
    # To check: is it really use_sg = false?
    fmodel = mmtbx.f_model.manager(
      f_obs        = self.f_obs,
      r_free_flags = self.r_free_flags,
      f_calc       = f_calc,
      f_mask       = mask)
    fmodel.update_all_scales()
    mc_fofc = map_tools.electron_density_map(fmodel = fmodel).map_coefficients(
      map_type     = "mFo-DFc",
      isotropize   = True,
      fill_missing = False)
    return fmodel, mc_fofc

  # ---------------------------------------------------------------------------

  def get_polder_diff_map(self,
                          f_obs,
                          r_free_flags,
                          f_calc,
                          f_mask,
                          model_selected,
                          box_cushion):
    fmodel = mmtbx.f_model.manager(
      f_obs        = f_obs,
      r_free_flags = r_free_flags,
      f_calc       = f_calc,
      f_mask       = f_mask)
    fmodel.update_all_scales(remove_outliers=False)
    mc_diff = map_tools.electron_density_map(
      fmodel = fmodel).map_coefficients(
        map_type         = "mFo-DFc",
        isotropize       = True,
        fill_missing     = False)
    fft_map = miller.fft_map(
      crystal_gridding     = self.crystal_gridding,
      fourier_coefficients = mc_diff)
    fft_map.apply_sigma_scaling()
    mm= fft_map.as_map_manager()

    from iotbx.map_model_manager import map_model_manager
    inputs=map_model_manager(
      model=model_selected.deep_copy(),
      map_manager=mm,) # no need to allow ignore_symmetry_conflicts
    return inputs

  # ---------------------------------------------------------------------------

  def validate_polder_map(self,
                          selection_bool,
                          xray_structure_noligand,
                          mask_data_polder,
                          box_cushion = 2.1):
    '''
    The parameter box_cushion is hardcoded to be 2.1
    The value is related to the site_radii used for CC calculation (box_cushion - 0.1)
    Ideally the site_radii are calculated according to resolution, atom type and B factor for each atom
    However, for the purpose of polder map validation, it is a reasonable approximation
    to use 2.0.
    If this value is changed, it will affect the values of the CCs and therefore also the
    output messages (see mmtbx/programs/polder.py --> result_message)
    So modify this value with caution.
    '''
  # Significance check
    fmodel = mmtbx.f_model.manager(
     f_obs          = self.f_obs,
     r_free_flags   = self.r_free_flags,
     xray_structure = self.xray_structure)
    fmodel.update_all_scales(
      remove_outliers = False,
      fast            = True)
    f_obs_1 = abs(fmodel.f_model())
    fmodel.update_xray_structure(
      xray_structure      = xray_structure_noligand,
      update_f_calc       = True,
      update_f_mask       = True,
      force_update_f_mask = True)
  ## PVA: do we need it? fmodel.update_all_scales(remove_outliers=False)
    f_obs_2 = abs(fmodel.f_model())
    model_selected = self.model.select(selection_bool)
    pdb_hierarchy_selected = self.pdb_hierarchy.select(selection_bool)
    xrs_selected = pdb_hierarchy_selected.extract_xray_structure(
      crystal_symmetry = self.cs)
    f_calc = fmodel.f_obs().structure_factors_from_scatterers(
      xray_structure = xray_structure_noligand).f_calc()
    f_mask = fmodel.f_obs().structure_factors_from_map(
      map            = mask_data_polder,
      use_scale      = True,
      anomalous_flag = False,
      use_sg         = False)
    box_1 = self.get_polder_diff_map(
      f_obs = f_obs_1,
      r_free_flags = fmodel.r_free_flags(),
      f_calc = f_calc,
      f_mask = f_mask,
      model_selected = model_selected,
      box_cushion = box_cushion)
    box_2 = self.get_polder_diff_map(
      f_obs = f_obs_2,
      r_free_flags = fmodel.r_free_flags(),
      f_calc = f_calc,
      f_mask = f_mask,
      model_selected = model_selected,
      box_cushion = box_cushion)
    box_3 = self.get_polder_diff_map(
      f_obs = fmodel.f_obs(),
      r_free_flags = fmodel.r_free_flags(),
      f_calc = f_calc,
      f_mask = f_mask,
      model_selected = model_selected,
      box_cushion = box_cushion)

    sites_cart_box = box_1.model().get_xray_structure().sites_cart()
    sel = maptbx.grid_indices_around_sites(
      unit_cell  = box_1.model().get_xray_structure().unit_cell(),
      fft_n_real = box_1.map_manager().map_data().focus(),
      fft_m_real = box_1.map_manager().map_data().all(),
      sites_cart = sites_cart_box,
      site_radii = flex.double(sites_cart_box.size(), box_cushion-0.1))
    b1 = box_1.map_manager().map_data().select(sel).as_1d()
    b2 = box_2.map_manager().map_data().select(sel).as_1d()
    b3 = box_3.map_manager().map_data().select(sel).as_1d()
    # Map 1: calculated Fobs with ligand
    # Map 2: calculated Fobs without ligand
    # Map 3: real Fobs data
    cc12 = flex.linear_correlation(x=b1,y=b2).coefficient()
    cc13 = flex.linear_correlation(x=b1,y=b3).coefficient()
    cc23 = flex.linear_correlation(x=b2,y=b3).coefficient()
    #### D-function
    b1 = maptbx.volume_scale_1d(map=b1, n_bins=10000).map_data()
    b2 = maptbx.volume_scale_1d(map=b2, n_bins=10000).map_data()
    b3 = maptbx.volume_scale_1d(map=b3, n_bins=10000).map_data()
    cc12_peak = flex.linear_correlation(x=b1,y=b2).coefficient()
    cc13_peak = flex.linear_correlation(x=b1,y=b3).coefficient()
    cc23_peak = flex.linear_correlation(x=b2,y=b3).coefficient()
    #### Peak CC:
    cutoffs = flex.double(
      [i/10. for i in range(1,10)]+[i/100 for i in range(91,100)])
    d12 = maptbx.discrepancy_function(map_1=b1, map_2=b2, cutoffs=cutoffs)
    d13 = maptbx.discrepancy_function(map_1=b1, map_2=b3, cutoffs=cutoffs)
    d23 = maptbx.discrepancy_function(map_1=b2, map_2=b3, cutoffs=cutoffs)
    pdb_hierarchy_selected.adopt_xray_structure(box_1.model().get_xray_structure())
    return group_args(
      box_1 = box_1,
      box_2 = box_2,
      box_3 = box_3,
      cc12  = cc12,
      cc13  = cc13,
      cc23  = cc23,
      cc12_peak = cc12_peak,
      cc13_peak = cc13_peak,
      cc23_peak = cc23_peak,
      d12 = d12,
      d13 = d13,
      d23 = d23,
      cutoffs = cutoffs,
      ph_selected = pdb_hierarchy_selected
      )

# =============================================================================

#if (__name__ == "__main__"):
#  run(args=sys.argv[1:])


 *******************************************************************************


 *******************************************************************************
mmtbx/maps/superpose.py

from __future__ import absolute_import, division, print_function
import mmtbx.maps.utils
import iotbx.pdb
from iotbx import crystal_symmetry_from_any
from cctbx import maptbx
from cctbx.array_family import flex
from scitbx.math import superpose
from libtbx.math_utils import ifloor, iceil
from libtbx.utils import null_out
import libtbx.load_env
from libtbx import easy_run
from libtbx import adopt_init_args
import sys, os
from six.moves import zip
from six.moves import range

def mask_grid(xrs, buffer, map_data, n_real):
  # XXX move to C++
  frac_min, frac_max = xrs.unit_cell().box_frac_around_sites(
    sites_cart = xrs.sites_cart(), buffer = buffer-1.5)
  gridding_first=[ifloor(f*n) for f,n in zip(frac_min,n_real)]
  gridding_last=[iceil(f*n) for f,n in zip(frac_max,n_real)]
  new_map = flex.double(flex.grid(n_real),0)
  for i in range(gridding_first[0], gridding_last[0]):
    for j in range(gridding_first[1], gridding_last[1]):
      for k in range(gridding_first[2], gridding_last[2]):
        if(i> 0 and i<n_real[0] and
           j> 0 and j<n_real[1] and
           k> 0 and k<n_real[2]):
          new_map[(i,j,k)] = map_data[(i,j,k)]
  return new_map

# this assumes that coordinates have already been shifted to all-positive
def generate_p1_box(pdb_hierarchy, buffer=10.0):
  sites_cart = pdb_hierarchy.atoms().extract_xyz()
  xyz_max = sites_cart.max()
  a = xyz_max[0] + buffer
  b = xyz_max[1] + buffer
  c = xyz_max[2] + buffer
  combined = "%.3f,%.3f,%.3f,90,90,90,P1" % (a, b, c)
  symm = crystal_symmetry_from_any.from_string(combined)
  return symm

class common_frame_of_reference(object):
  def __init__(self,
               all_sites_cart,
               lsq_fits,
               buffer=10.0,
               move_to_frame_of_reference=True,
               log=sys.stdout):
    fitted_sites = []
    original_sites = []
    minima = flex.vec3_double()
    for sites_cart, lsq_fit in zip(all_sites_cart, lsq_fits):
      fitted_sites.append(sites_cart.deep_copy())
      minima.append(sites_cart.min())
      if lsq_fit is None :
        original_sites.append(sites_cart.deep_copy())
      else :
        old_sites = lsq_fit.r.inverse().elems * (sites_cart - lsq_fit.t.elems)
        original_sites.append(old_sites)
    xyz_min = minima.min()
    if move_to_frame_of_reference:
      dxyz = (buffer - xyz_min[0], buffer - xyz_min[1], buffer - xyz_min[2])
    else:
      dxyz = (0,0,0)
    self.shifted_sites = []
    self.transformation_matrices = []
    for i, sites_cart in enumerate(fitted_sites):
      new_sites_cart = sites_cart + dxyz
      #print new_sites_cart.min()
      self.shifted_sites.append(new_sites_cart)
      lsq_fit = superpose.least_squares_fit(
        reference_sites=new_sites_cart,
        other_sites=original_sites[i])
      self.transformation_matrices.append(lsq_fit.rt())

  def apply_new_sites_to_hierarchies(self, pdb_hierarchies):
    assert len(pdb_hierarchies) == len(self.shifted_sites)
    for i, pdb_hierarchy in enumerate(pdb_hierarchies):
      atoms = pdb_hierarchy.atoms()
      atoms.set_xyz(self.shifted_sites[i])

  def apply_new_sites_to_xray_structure(self, xray_structures):
    pass

  def get_inverse_matrix(self, i):
    assert i < len(self.transformation_matrices)
    rt = self.transformation_matrices[i]
    return rt.inverse()

  def inverse_transform_hierarchy(self, i, pdb_hierarchy):
    rt = self.get_inverse_matrix(i)
    atoms = pdb_hierarchy.atoms()
    sites_cart = atoms.extract_xyz()
    atoms.set_xyz(rt.r.elems * sites_cart + rt.t.elems)
    uij = flex.sym_mat3_double(sites_cart.size(),[-1,-1,-1,-1,-1,-1])
    atoms.set_uij(uij)

def transform_map_by_lsq_fit(fft_map,
                              unit_cell,
                              lsq_fit_obj,
                              pdb_hierarchy,
                              d_min,
                              buffer=10.0,
                              resolution_factor=0.25,
                              file_name=None,
                              log=sys.stdout,
                              mask_map_grid=False,
                              format="xplor"):
  assert (format in ["xplor", "ccp4"])
  fake_symm = generate_p1_box(pdb_hierarchy, buffer=10.0)
  xray_structure = pdb_hierarchy.extract_xray_structure(
    crystal_symmetry=fake_symm)
  f_calc = xray_structure.structure_factors(d_min=d_min).f_calc()
  fake_map = f_calc.fft_map(resolution_factor=resolution_factor)
  map_data_superposed = maptbx.superpose_maps(
    unit_cell_1        = unit_cell,
    unit_cell_2        = fake_symm.unit_cell(),
    map_data_1         = fft_map.real_map_unpadded(),
    n_real_2           = fake_map.n_real(),
    rotation_matrix    = lsq_fit_obj.r.elems,
    translation_vector = lsq_fit_obj.t.elems)
  if mask_map_grid :
    map_data_superposed = mask_grid(
      xrs      = xray_structure,
      buffer   = buffer,
      map_data = map_data_superposed,
      n_real   = fake_map.n_real())
  if file_name is not None :
    if format == "xplor" :
      print("    saving XPLOR map to %s" % file_name, file=log)
      mmtbx.maps.utils.write_xplor_map(
        sites_cart=xray_structure.sites_cart(),
        unit_cell=fake_symm.unit_cell(),
        map_data=map_data_superposed,
        n_real=fake_map.n_real(),
        file_name=file_name,
        buffer=buffer)
    else :
      import iotbx.map_tools
      print("    saving CCP4 map to %s" % file_name, file=log)
      iotbx.map_tools.write_ccp4_map(
        sites_cart=xray_structure.sites_cart(),
        unit_cell=fake_symm.unit_cell(),
        map_data=map_data_superposed,
        n_real=fake_map.n_real(),
        file_name=file_name,
        buffer=buffer)
  return xray_structure, map_data_superposed

# XXX: wrapper for multiprocessing
class transform_maps(object):
  def __init__(self,
                map_coeffs,
                map_types,
                pdb_hierarchy,
                unit_cell,
                lsq_fit_obj,
                output_files,
                resolution_factor=0.25,
                buffer=10.0,
                auto_run=True,
                format="ccp4"):
    adopt_init_args(self, locals())
    if auto_run :
      self.run()

  def run(self):
    for (array, map_type, file_name) in zip(self.map_coeffs, self.map_types,
        self.output_files):
      if array is None :
        continue
      (d_max, d_min) = array.d_max_min()
      fft_map = array.fft_map(resolution_factor=self.resolution_factor)
      fft_map.apply_sigma_scaling()
      transform_map_by_lsq_fit(
        fft_map=fft_map,
        unit_cell=self.unit_cell,
        lsq_fit_obj=self.lsq_fit_obj,
        pdb_hierarchy=self.pdb_hierarchy,
        resolution_factor=self.resolution_factor,
        buffer=self.buffer,
        d_min=d_min,
        file_name=file_name,
        log=null_out(),
        format=self.format)
      del fft_map

def exercise():
  pdb_file_name_1 = libtbx.env.find_in_repositories(
    relative_path="phenix_regression/misc/1l3r_no_ligand.pdb",
    test=os.path.isfile)
  pdb_in_1 = iotbx.pdb.input(file_name = pdb_file_name_1)
  xrs1 = pdb_in_1.xray_structure_simple()
  ofn = "1l3r_rt.pdb"
  cmd = " ".join([
    "phenix.pdbtools",
    "%s"%pdb_file_name_1,
    "rotate='90 10 20' translate='10 10 10'",
    "output.file_name=%s"%ofn,
    "--quiet"])
  easy_run.call(cmd)
  pdb_in_rt = iotbx.pdb.input(file_name = ofn)
  xrs_rt = pdb_in_rt.xray_structure_simple()
  fft_map_1 = xrs1.structure_factors(d_min=1.5).f_calc().fft_map(
    resolution_factor = 1./3)
  fft_map_1.apply_sigma_scaling()
  map_data_1 = fft_map_1.real_map_unpadded()
  mmtbx.maps.utils.write_xplor_map(sites_cart = xrs1.sites_cart(),
    unit_cell  = xrs1.unit_cell(),
    map_data   = map_data_1,
    n_real     = fft_map_1.n_real(),
    file_name  = "1l3r.xplor")
  lsq_fit_obj = superpose.least_squares_fit(
    reference_sites=xrs_rt.sites_cart(),
    other_sites=xrs1.sites_cart().deep_copy())
  f_o_r = common_frame_of_reference(
    all_sites_cart=[xrs1.sites_cart(),xrs_rt.sites_cart()],
    lsq_fits=[None, lsq_fit_obj])
  hierarchy_rt = pdb_in_rt.construct_hierarchy()
  lsq_fit_obj = f_o_r.transformation_matrices[1]
  hierarchy_rt.atoms().set_xyz(f_o_r.shifted_sites[1])
  open("1l3r_rt.pdb", "w").write(hierarchy_rt.as_pdb_string())
  xrs_rt, map_data_rt = transform_map_by_lsq_fit(
    fft_map=fft_map_1,
    unit_cell=xrs1.unit_cell(),
    lsq_fit_obj=lsq_fit_obj.inverse(),
    pdb_hierarchy=hierarchy_rt,
    d_min=1.5,
    file_name="1l3r_rt.xplor",
    log=null_out())
  f_o_r.inverse_transform_hierarchy(1, hierarchy_rt)
  open("1l3r.pdb", "w").write(hierarchy_rt.as_pdb_string())
  #for sf1, sf2 in zip(xrs1.sites_frac(), xrs_rt.sites_frac()):
  #  e1 = map_data_1.eight_point_interpolation(sf1)
  #  e2 = map_data_rt.eight_point_interpolation(sf2)
  #  print abs(e1-e2)
  #  assert abs(e1-e2) < 1.
  print("OK")

if __name__ == "__main__" :
  exercise()


 *******************************************************************************


 *******************************************************************************
mmtbx/maps/tst_composite_omit_map.py
from __future__ import absolute_import, division, print_function
from scitbx.array_family import flex
from cctbx import miller
from cctbx.development import random_structure
from cctbx.sgtbx import space_group_info
import boost_adaptbx.boost.python as bp
from six.moves import zip
from six.moves import range
asu_map_ext = bp.import_ext("cctbx_asymmetric_map_ext")
from mmtbx.maps import composite_omit_map as cfom
from cctbx import maptbx
import mmtbx.maps
from libtbx.test_utils import approx_equal
import mmtbx.f_model
import time
import sys
import cctbx

class omit_p1_specific(object):
  """
  Composite full-omit map: omit entire box in real-space corresponding to Fmodel,
  which includs atomic model and non-atomic model (bulk-solvent and scales).
  ASU maps are not use, so this is limited to P1 only. Use for this test only.
  """
  def __init__(
        self,
        crystal_gridding,
        fmodel,
        map_type,
        max_boxes,
        box_size_as_fraction=None):
    sgt = fmodel.f_obs().space_group().type()
    assert sgt.number() == 1
    def get_map(fmodel, map_type, external_complete_set=None):
      f_map = fmodel.electron_density_map().map_coefficients(
          map_type     = map_type,
          isotropize   = True,
          fill_missing = False)
      fft_map = miller.fft_map(
        crystal_gridding     = crystal_gridding,
        fourier_coefficients = f_map)
      return fft_map.real_map_unpadded()
    f_model = fmodel.f_model_scaled_with_k1()
    fft_map = miller.fft_map(
      crystal_gridding     = crystal_gridding,
      fourier_coefficients = f_model)
    f_model_map_data = fft_map.real_map_unpadded()
    zero_complex_ma = f_model.customized_copy(
      data = flex.complex_double(f_model.data().size(), 0))
    b = maptbx.boxes(
      fraction = 0.3,
      n_real   = f_model_map_data.focus(),
      max_boxes=max_boxes,
      log=sys.stdout)
    self.map_result = flex.double(flex.grid(b.n_real))
    self.r = flex.double()
    for s,e in zip(b.starts, b.ends):
      f_model_map_data_omit = maptbx.set_box_copy(
        value         = 0,
        map_data_to   = f_model_map_data,
        start         = s,
        end           = e)
      f_model_omit = f_model.structure_factors_from_map(
        map            = f_model_map_data_omit,
        use_scale      = True,
        anomalous_flag = False,
        use_sg         = False)
      fmodel_ = mmtbx.f_model.manager(
        f_obs        = fmodel.f_obs(),
        r_free_flags = fmodel.r_free_flags(),
        f_calc       = f_model_omit,
        f_mask       = zero_complex_ma)
      self.r.append(fmodel_.r_work())
      f_map_data = get_map(fmodel=fmodel_, map_type=map_type)
      etmp = [e[0]-1, e[1]-1, e[2]-1] # because .copy() includes right edge
      box = maptbx.copy(f_map_data, s, etmp)
      box.reshape(flex.grid(box.all()))
      maptbx.set_box(
        map_data_from = box,
        map_data_to   = self.map_result,
        start         = s,
        end           = e)
    sd = self.map_result.sample_standard_deviation()
    self.map_result = self.map_result/sd
    self.map_coefficients = fmodel.f_obs().structure_factors_from_map(
      map            = self.map_result,
      use_scale      = True,
      anomalous_flag = False,
      use_sg         = False)

class omit_general_obsolete(object):
  """
  Composite full-omit map: omit entire box in real-space corresponding to
  Fmodel, which includs atomic model and non-atomic model (bulk-solvent and
  scales).  This is much faster than the refinement-based method, and is used
  by default in phenix.composite_omit_map.
  """
  def __init__(
        self,
        crystal_gridding,
        fmodel,
        map_type,
        box_size_as_fraction=0.03,
        max_boxes=100,
        n_debias_cycles=2,
        neutral_volume_box_cushion_width=1,
        full_resolution_map=True,
        log=sys.stdout):
    self.crystal_gridding = crystal_gridding
    # assert compatibility of symops with griding
    assert self.crystal_gridding._symmetry_flags is not None
    self.sgt = fmodel.f_obs().space_group().type()
    self.zero_cmpl_ma = fmodel.f_calc().customized_copy(
      data = flex.complex_double(fmodel.f_calc().size(), 0))
    # embedded utility functions
    def get_map(fmodel, map_type, crystal_gridding, asu=True):
      f_map = fmodel.electron_density_map().map_coefficients(
        map_type                   = map_type,
        isotropize                 = True,
        exclude_free_r_reflections = True,
        fill_missing               = False)
      fft_map = cctbx.miller.fft_map(
        crystal_gridding     = crystal_gridding,
        fourier_coefficients = f_map)
      if(asu): return asu_map_ext.asymmetric_map(self.sgt,
        fft_map.real_map_unpadded()).data()
      else:
        return fft_map.real_map_unpadded()
    # f_model map
    f_model_map_data = fmodel.f_model_scaled_with_k1().fft_map(
      symmetry_flags   = maptbx.use_space_group_symmetry,
      crystal_gridding = self.crystal_gridding).real_map_unpadded()
    self.n_real = f_model_map_data.focus()
    # extract asu map from full P1
    f_model_map_data_asu=asu_map_ext.asymmetric_map(
      self.sgt, f_model_map_data).data()
    self.acc = f_model_map_data_asu.accessor()
    f_model_map_data_asu = f_model_map_data_asu.shift_origin()
    # set up boxes
    b = maptbx.boxes(
      n_real   = f_model_map_data_asu.focus(),
      fraction = box_size_as_fraction,
      max_boxes= max_boxes,
      log      = log)
    self.map_result_asu = flex.double(flex.grid(b.n_real))
    assert f_model_map_data_asu.focus()==b.n_real
    assert b.n_real==self.map_result_asu.focus()
    n_real_asu = b.n_real
    self.r = flex.double() # for regression test only
    n_boxes = len(b.starts)
    i_box = 0
    for s,e in zip(b.starts, b.ends):
      i_box+=1
      # define wide box: neutral + phased volumes
      if(neutral_volume_box_cushion_width>0):
        sh = neutral_volume_box_cushion_width
        ss = [max(s[i]-sh,0) for i in [0,1,2]]
        ee = [min(e[i]+sh,n_real_asu[i]) for i in [0,1,2]]
      else: ss,ee = s,e
      # omit wide box from f_model map, repeat n_debias_cycles times
      f_model_map_data_asu_ = f_model_map_data_asu.deep_copy()
      for i in range(n_debias_cycles):
        f_model_omit, f_model_map_data_asu_ = self.omit_box(s=ss, e=ee,
          md_asu=f_model_map_data_asu_)
      # get fmodel for omit map calculation
      fmodel_ = mmtbx.f_model.manager(
        f_obs        = fmodel.f_obs(),
        r_free_flags = fmodel.r_free_flags(),
        f_calc       = f_model_omit,
        f_mask       = self.zero_cmpl_ma)
      rw = fmodel_.r_work()
      self.r.append(rw) # for regression test only
      f_map_data_asu = get_map(fmodel=fmodel_, map_type=map_type,
        crystal_gridding=self.crystal_gridding)
      f_map_data_asu = f_map_data_asu.shift_origin()
      if(log):
        print("box %2d of %2d:"%(i_box, n_boxes), s, e, "%6.4f"%rw, file=log)
      assert f_map_data_asu.focus() == self.map_result_asu.focus()
      maptbx.copy_box(
        map_data_from = f_map_data_asu,
        map_data_to   = self.map_result_asu,
        start         = s,
        end           = e)
    # result
    self.map_result_asu.reshape(self.acc)
    self.asu_map_omit = asu_map_ext.asymmetric_map(
      self.sgt, self.map_result_asu, self.n_real)
    self.map_coefficients = self.zero_cmpl_ma.customized_copy(
      indices = self.zero_cmpl_ma.indices(),
      data    = self.asu_map_omit.structure_factors(self.zero_cmpl_ma.indices()))
    # full resolution map (reflections in sphere, not in box!)
    if(full_resolution_map):
      cs = self.zero_cmpl_ma.complete_set(d_min=self.zero_cmpl_ma.d_min())
      asu_map_omit = asu_map_ext.asymmetric_map(
        self.sgt,self.map_result_asu,self.n_real)
      fill = self.zero_cmpl_ma.customized_copy(
        indices = cs.indices(),
        data    = asu_map_omit.structure_factors(cs.indices()))
      self.map_coefficients = self.map_coefficients.complete_with(
        other=fill, scale=True)

  def omit_box(self, s, e, md_asu):
    md_asu_omit = maptbx.set_box_copy(value = 0, map_data_to = md_asu,
      start = s, end = e)
    md_asu_omit.reshape(self.acc)
    asu_map_omit = asu_map_ext.asymmetric_map(self.sgt, md_asu_omit, self.n_real)
    ma_omit = self.zero_cmpl_ma.customized_copy(
      indices = self.zero_cmpl_ma.indices(),
      data    = asu_map_omit.structure_factors(self.zero_cmpl_ma.indices()))
    fft_map = cctbx.miller.fft_map(
      crystal_gridding = self.crystal_gridding, fourier_coefficients = ma_omit)
    md = fft_map.real_map_unpadded()
    asu_map = asu_map_ext.asymmetric_map(self.sgt, md)
    md_asu_omit = asu_map.data()
    md_asu_omit = md_asu_omit.shift_origin()
    return ma_omit, md_asu_omit

def run():
  """
  This test makes sure that composite full omit maps calculated using Marat's
  ASU map code and not using ASU maps exactly match.
  """
  # make up data
  xrs = random_structure.xray_structure(
    space_group_info       = space_group_info("P 1"),
    volume_per_atom        = 250,
    general_positions_only = False,
    elements               = ('C', 'N', 'O', "S")*50,
    u_iso                  = 0.1,
    min_distance           = 1.0)
  xrs.scattering_type_registry(table="wk1995")
  f_obs = abs(xrs.structure_factors(d_min=2).f_calc())
  # create fmodel object
  xrs.shake_sites_in_place(mean_distance=0.3)
  sel = xrs.random_remove_sites_selection(fraction=0.1)
  xrs = xrs.select(sel)
  fmodel = mmtbx.f_model.manager(
    xray_structure = xrs,
    f_obs          = f_obs)
  fmodel.update_all_scales(update_f_part1=False)
  crystal_gridding = fmodel.f_obs().crystal_gridding(
    d_min             = fmodel.f_obs().d_min(),
    symmetry_flags    = maptbx.use_space_group_symmetry,
    resolution_factor = 0.25)
  # compute OMIT maps
  r1 = omit_p1_specific(
    crystal_gridding = crystal_gridding,
    fmodel           = fmodel.deep_copy(),
    max_boxes=70,
    map_type         = "Fo")
  r2 = omit_general_obsolete(
    crystal_gridding = crystal_gridding,
    fmodel           = fmodel.deep_copy(),
    full_resolution_map = False,
    map_type         = "Fo",
    n_debias_cycles  = 1,
    neutral_volume_box_cushion_width = 0,
    box_size_as_fraction=0.3,
    max_boxes=70,
    log=sys.stdout)
  r3 = cfom.run(
    crystal_gridding = crystal_gridding,
    fmodel           = fmodel.deep_copy(),
    full_resolution_map = False,
    neutral_volume_box_cushion_width = 0,
    box_size_as_fraction=0.3,
    max_boxes=70,
    log=sys.stdout)
  assert approx_equal(r1.r, r2.r)
  def r_factor(x,y):
    x = flex.abs(abs(x).data())
    y = flex.abs(abs(y).data())
    sc = flex.sum(x*y)/flex.sum(y*y)
    return flex.sum(flex.abs(x-sc*y))/flex.sum(x+sc*y)*2
  print(abs(r1.map_coefficients).data().min_max_mean().as_tuple())
  print(abs(r2.map_coefficients).data().min_max_mean().as_tuple())
  cc1=flex.linear_correlation(
      x=abs(r1.map_coefficients).data(),
      y=abs(r2.map_coefficients).data()).coefficient()
  assert approx_equal(cc1, 1.0)
  cc2=flex.linear_correlation(
      x=abs(r1.map_coefficients).data(),
      y=abs(r3.map_coefficients(filter_noise=False)).data()).coefficient()
  assert cc2 > 0.8, cc2
  assert approx_equal(r_factor(
    x=r1.map_coefficients, y=r2.map_coefficients), 0.0)
  cc3=flex.linear_correlation(x=r1.r, y=r3.r).coefficient()
  assert cc3>0.95
  for cutoff in [0.5,0.6,0.7,0.8,0.9,0.95,0.99]:
    print(maptbx.cc_peak(
      cutoff       = cutoff,
      map_coeffs_1 = r1.map_coefficients,
      map_coeffs_2 = r3.map_coefficients(filter_noise=False)), "CCpeak", cutoff)

if (__name__ == "__main__"):
  t0 = time.time()
  run()
  print("Time: %6.4f"%(time.time()-t0))


 *******************************************************************************


 *******************************************************************************
mmtbx/maps/tst_composite_omit_map_2.py

from __future__ import absolute_import, division, print_function
from cctbx.array_family import flex
import iotbx.pdb
import mmtbx.f_model
from cctbx import miller
import mmtbx.maps
from cctbx import maptbx
import mmtbx.maps.composite_omit_map
import sys

pdb_str="""\n
REMARK iotbx.pdb.box_around_molecule --buffer-layer=2 "m.pdb"
REMARK Date 2013-12-16 Time 13:47:17 PST -0800 (1387230437.01 s)
CRYST1   12.380   14.615   11.502  90.00  90.00  90.00 P 1
ATOM      1  CB  PHE A   1       4.641   4.458   4.502  1.00 10.00           C
ATOM      2  CG  PHE A   1       3.809   3.637   5.453  1.00 10.00           C
ATOM      3  CD1 PHE A   1       2.792   2.781   4.971  1.00 10.00           C
ATOM      4  CD2 PHE A   1       4.035   3.712   6.843  1.00 10.00           C
ATOM      5  CE1 PHE A   1       2.000   2.000   5.869  1.00 10.00           C
ATOM      6  CE2 PHE A   1       3.256   2.941   7.761  1.00 10.00           C
ATOM      7  CZ  PHE A   1       2.234   2.081   7.270  1.00 10.00           C
ATOM      8  C   PHE A   1       4.830   6.416   2.964  1.00 10.00           C
ATOM      9  O   PHE A   1       5.380   5.842   2.000  1.00 10.00           O
ATOM     10  OXT PHE A   1       5.017   7.615   3.259  1.00 10.00           O
ATOM     11  N   PHE A   1       2.749   5.066   3.014  1.00 10.00           N
ATOM     12  CA  PHE A   1       3.874   5.605   3.831  1.00 10.00           C
ATOM     13  CB  PHE A   2       9.641   9.458   9.502  1.00 10.00           C
ATOM     14  C   PHE A   2       9.830  11.416   7.964  1.00 10.00           C
ATOM     15  O   PHE A   2      10.380  10.842   7.000  1.00 10.00           O
ATOM     16  OXT PHE A   2      10.017  12.615   8.259  1.00 10.00           O
ATOM     17  N   PHE A   2       7.749  10.066   8.014  1.00 10.00           N
ATOM     18  CA  PHE A   2       8.874  10.605   8.831  1.00 10.00           C
TER
END
"""

def get_cc(mc1, mc2, xrs):
  crystal_gridding = mc1.crystal_gridding(
    d_min             = mc1.d_min(),
    symmetry_flags    = maptbx.use_space_group_symmetry,
    resolution_factor = 0.25)
  fft_map = miller.fft_map(
    crystal_gridding     = crystal_gridding,
    fourier_coefficients = mc1)
  fft_map.apply_sigma_scaling()
  m1 = fft_map.real_map_unpadded()
  fft_map = miller.fft_map(
    crystal_gridding     = crystal_gridding,
    fourier_coefficients = mc2)
  fft_map.apply_sigma_scaling()
  m2 = fft_map.real_map_unpadded()
  assert m1.focus()==m2.focus()
  assert m1.all()==m2.all()
  sel = maptbx.grid_indices_around_sites(
    unit_cell  = mc1.unit_cell(),
    fft_n_real = m1.focus(),
    fft_m_real = m1.all(),
    sites_cart = flex.vec3_double(xrs.sites_cart()),
    site_radii = flex.double([1.5]*xrs.scatterers().size()))
  cc = flex.linear_correlation(x=m1.select(sel), y=m2.select(sel)).coefficient()
  def md(m, xrs):
    r = flex.double()
    for sf in xrs.sites_frac():
      r.append(m.eight_point_interpolation(sf))
    return flex.mean(r)
  return cc, md(m=m1, xrs=xrs), md(m=m2, xrs=xrs)

def run(args):
  pdb_inp = iotbx.pdb.input(source_info=None, lines=pdb_str)
  ph = pdb_inp.construct_hierarchy()
  ph.write_pdb_file(file_name="m.pdb")
  xrs = pdb_inp.xray_structure_simple()
  sel = ph.atom_selection_cache().selection("resseq 1")
  xrs1 = xrs.select( sel)
  xrs2 = xrs.select(~sel)
  #
  F  =  xrs.structure_factors(d_min=1.5).f_calc()
  FB = xrs1.structure_factors(d_min=1.5).f_calc()
  FC =   FB.phase_transfer(phase_source=F)
  #
  mtz_dataset = abs(FB).as_mtz_dataset(column_root_label="F-obs")
  mtz_dataset.add_miller_array(miller_array=FB.generate_r_free_flags(),
    column_root_label="R-free-flags")
  mtz_object = mtz_dataset.mtz_object()
  mtz_object.write(file_name = "data.mtz")
  #
  mtz_dataset = F.as_mtz_dataset(column_root_label="f")
  mtz_dataset.add_miller_array(miller_array=FB, column_root_label="FB")
  mtz_dataset.add_miller_array(miller_array=FC, column_root_label="FC")
  mtz_dataset.add_miller_array(miller_array=abs(FB), column_root_label="FOBS")
  #
  fmodel = mmtbx.f_model.manager(f_obs = abs(FB), xray_structure = xrs)
  # mc is model biased: one should not see any density for resseq 2
  mc = fmodel.electron_density_map().map_coefficients(
    map_type     = "Fo",
    isotropize   = False,
    fill_missing = False)
  #
  print(get_cc(mc1=mc, mc2=F,  xrs=xrs1), get_cc(mc1=mc, mc2=F,  xrs=xrs2))
  print(get_cc(mc1=mc, mc2=FB, xrs=xrs1), get_cc(mc1=mc, mc2=FB, xrs=xrs2))
  print(get_cc(mc1=mc, mc2=FC, xrs=xrs1), get_cc(mc1=mc, mc2=FC, xrs=xrs2))
  print()
  #
  crystal_gridding = fmodel.f_obs().crystal_gridding(
    d_min             = fmodel.f_obs().d_min(),
    symmetry_flags    = maptbx.use_space_group_symmetry,
    resolution_factor = 0.25)
  #
  oo = mmtbx.maps.composite_omit_map.run(
    crystal_gridding     = crystal_gridding,
    full_resolution_map  = False,
    fmodel               = fmodel.deep_copy(),
    box_size_as_fraction = 0.2)
  mco = oo.map_coefficients(filter_noise=False)
  print(get_cc(mc1=mco, mc2=F, xrs=xrs1), get_cc(mc1=mco, mc2=F, xrs=xrs2))
  #
  mtz_dataset.add_miller_array(miller_array=mco, column_root_label="O")
  mtz_dataset.add_miller_array(miller_array=mc, column_root_label="mc")
  #
  mtz_object = mtz_dataset.mtz_object()
  mtz_object.write(file_name = "m.mtz")

if (__name__ == "__main__"):
  run(sys.argv[1:])


 *******************************************************************************


 *******************************************************************************
mmtbx/maps/tst_composite_omit_map_3.py
from __future__ import absolute_import, division, print_function
from scitbx.array_family import flex
from cctbx import miller
from cctbx.development import random_structure
from cctbx.sgtbx import space_group_info
import boost_adaptbx.boost.python as bp
asu_map_ext = bp.import_ext("cctbx_asymmetric_map_ext")
from mmtbx.maps import composite_omit_map as cfom
from cctbx import maptbx
import mmtbx.f_model
import time, sys
from cctbx.development import debug_utils
from cctbx import sgtbx

def get_cc(mc1, mc2, xrs):
  crystal_gridding = mc1.crystal_gridding(
    d_min = mc1.d_min(), resolution_factor = 0.25)
  fft_map = miller.fft_map(
    crystal_gridding     = crystal_gridding,
    fourier_coefficients = mc1)
  fft_map.apply_sigma_scaling()
  m1 = fft_map.real_map_unpadded()
  fft_map = miller.fft_map(
    crystal_gridding     = crystal_gridding,
    fourier_coefficients = mc2)
  fft_map.apply_sigma_scaling()
  m2 = fft_map.real_map_unpadded()
  assert m1.focus()==m2.focus()
  assert m1.all()==m2.all()
  ccs = flex.double()
  for site_cart in xrs.sites_cart():
    sel = maptbx.grid_indices_around_sites(
      unit_cell  = mc1.unit_cell(),
      fft_n_real = m1.focus(),
      fft_m_real = m1.all(),
      sites_cart = flex.vec3_double([site_cart]),
      site_radii = flex.double([1.5]))
    cc = flex.linear_correlation(x=m1.select(sel), y=m2.select(sel)).coefficient()
    ccs.append(cc)
  return ccs

def run(space_group_info):
  """
  Make sure it work for all space groups and boxes with non-zero origin.
  """
  # make up data
  xrs = random_structure.xray_structure(
    space_group_info       = space_group_info,
    volume_per_atom        = 50,
    general_positions_only = False,
    u_iso                  = 0.3,
    elements               = ('C', 'N', 'O', "S")*10,
    min_distance           = 1.5)
  xrs.scattering_type_registry(table="wk1995")
  f_calc = xrs.structure_factors(d_min=2).f_calc()
  f_obs = abs(f_calc)
  # create fmodel object
  fmodel = mmtbx.f_model.manager(
    xray_structure = xrs,
    f_obs          = f_obs)
  fmodel.update_all_scales()
  mc1 = fmodel.electron_density_map().map_coefficients(
      map_type     = "2mFo-DFc",
      isotropize   = False,
      exclude_free_r_reflections=False,
      fill_missing = False)
  crystal_gridding = fmodel.f_obs().crystal_gridding(
    d_min             = fmodel.f_obs().d_min(),
    symmetry_flags    = maptbx.use_space_group_symmetry,
    resolution_factor = 1./3)
  # compute OMIT map
  r = cfom.run(
    crystal_gridding    = crystal_gridding,
    fmodel              = fmodel.deep_copy(),
    full_resolution_map = False,
    max_boxes           = 70,
    neutral_volume_box_cushion_width = 0,
    box_size_as_fraction=0.3,
    log=False)
  ccs = get_cc(mc1=mc1, mc2=r.map_coefficients(filter_noise=False), xrs=xrs)
  assert flex.mean(ccs) > 0.8
  print("  CC(min/max,mean)",ccs.min_max_mean().as_tuple())

def run_call_back(flags, space_group_info):
  run(space_group_info)

if (__name__ == "__main__"):
  t0 = time.time()
  debug_utils.parse_options_loop_space_groups(sys.argv[1:], run_call_back,
    symbols_to_stdout=True, symbols_to_stderr=False)
  run(sgtbx.space_group_info("R3:R"))
  print("Time: %6.4f"%(time.time()-t0))


 *******************************************************************************


 *******************************************************************************
mmtbx/maps/tst_correlation.py
from __future__ import absolute_import, division, print_function
from scitbx.array_family import flex
import boost_adaptbx.boost.python as bp
asu_map_ext = bp.import_ext("cctbx_asymmetric_map_ext")
import iotbx.pdb
from mmtbx.maps import correlation
from libtbx.test_utils import approx_equal
from cctbx import maptbx

pdb_str="""
CRYST1   60.410   44.706   51.507  90.00  90.00  90.00 P 1
SCALE1      0.016554  0.000000  0.000000        0.00000
SCALE2      0.000000  0.022368  0.000000        0.00000
SCALE3      0.000000  0.000000  0.019415        0.00000
ATOM      1  N   GLY A   1      20.043  24.706  27.193  1.00 20.00           N
ATOM      2  CA  GLY A   1      20.000  24.301  25.742  1.00 20.00           C
ATOM      3  C   GLY A   1      21.037  23.234  25.510  1.00 20.00           C
ATOM      4  O   GLY A   1      21.529  22.615  26.472  1.00 20.00           O
ATOM      5  N   ASN A   2      21.396  23.017  24.246  1.00 20.00           N
ATOM      6  CA  ASN A   2      22.530  22.132  23.922  1.00 20.00           C
ATOM      7  C   ASN A   2      23.811  22.631  24.518  1.00 20.00           C
ATOM      8  O   ASN A   2      24.074  23.836  24.517  1.00 20.00           O
ATOM      9  CB  ASN A   2      22.706  21.975  22.432  1.00 20.00           C
ATOM     10  CG  ASN A   2      21.468  21.436  21.783  1.00 20.00           C
ATOM     11  OD1 ASN A   2      21.027  20.321  22.107  1.00 20.00           O
ATOM     12  ND2 ASN A   2      20.848  22.249  20.922  1.00 20.00           N
ATOM     13  N   ASN A   3      24.614  21.684  24.996  1.00 20.00           N
ATOM     14  CA  ASN A   3      25.859  21.998  25.680  1.00 20.00           C
ATOM     15  C   ASN A   3      27.097  21.426  24.986  1.00 20.00           C
ATOM     16  O   ASN A   3      27.180  20.213  24.739  1.00 20.00           O
ATOM     17  CB  ASN A   3      25.793  21.472  27.133  1.00 20.00           C
ATOM     18  CG  ASN A   3      27.046  21.833  27.952  1.00 20.00           C
ATOM     19  OD1 ASN A   3      27.350  23.019  28.163  1.00 20.00           O
ATOM     20  ND2 ASN A   3      27.781  20.809  28.397  1.00 20.00           N
ATOM     21  N   GLN A   4      28.047  22.322  24.689  1.00 20.00           N
ATOM     22  CA  GLN A   4      29.436  21.982  24.290  1.00 20.00           C
ATOM     23  C   GLN A   4      30.487  22.700  25.179  1.00 20.00           C
ATOM     24  O   GLN A   4      30.599  23.937  25.206  1.00 20.00           O
ATOM     25  CB  GLN A   4      29.708  22.242  22.802  1.00 20.00           C
ATOM     26  CG  GLN A   4      30.996  21.552  22.304  1.00 20.00           C
ATOM     27  CD  GLN A   4      31.556  22.138  21.002  1.00 20.00           C
ATOM     28  OE1 GLN A   4      31.796  23.362  20.901  1.00 20.00           O
ATOM     29  NE2 GLN A   4      31.802  21.255  20.000  1.00 20.00           N
ATOM     30  N   GLN A   5      31.206  21.915  25.962  1.00 20.00           N
ATOM     31  CA  GLN A   5      32.322  22.455  26.731  1.00 20.00           C
ATOM     32  C   GLN A   5      33.646  21.862  26.263  1.00 20.00           C
ATOM     33  O   GLN A   5      33.820  20.640  26.145  1.00 20.00           O
ATOM     34  CB  GLN A   5      32.108  22.277  28.238  1.00 20.00           C
ATOM     35  CG  GLN A   5      30.881  23.044  28.738  1.00 20.00           C
ATOM     36  CD  GLN A   5      30.396  22.508  30.045  1.00 20.00           C
ATOM     37  OE1 GLN A   5      29.826  21.419  30.093  1.00 20.00           O
ATOM     38  NE2 GLN A   5      30.601  23.281  31.130  1.00 20.00           N
ATOM     39  N   ASN A   6      34.566  22.758  25.947  1.00 20.00           N
ATOM     40  CA  ASN A   6      35.883  22.404  25.409  1.00 20.00           C
ATOM     41  C   ASN A   6      36.906  22.855  26.415  1.00 20.00           C
ATOM     42  O   ASN A   6      37.271  24.037  26.465  1.00 20.00           O
ATOM     43  CB  ASN A   6      36.117  23.110  24.084  1.00 20.00           C
ATOM     44  CG  ASN A   6      35.013  22.829  23.094  1.00 20.00           C
ATOM     45  OD1 ASN A   6      34.850  21.698  22.642  1.00 20.00           O
ATOM     46  ND2 ASN A   6      34.247  23.841  22.770  1.00 20.00           N
ATOM     47  N   TYR A   7      37.344  21.911  27.238  1.00 20.00           N
ATOM     48  CA  TYR A   7      38.211  22.238  28.390  1.00 20.00           C
ATOM     49  C   TYR A   7      39.655  22.425  27.976  1.00 20.00           C
ATOM     50  O   TYR A   7      40.093  21.905  26.946  1.00 20.00           O
ATOM     51  CB  TYR A   7      38.113  21.159  29.460  1.00 20.00           C
ATOM     52  CG  TYR A   7      36.717  21.023  29.993  1.00 20.00           C
ATOM     53  CD1 TYR A   7      35.823  20.115  29.418  1.00 20.00           C
ATOM     54  CD2 TYR A   7      36.262  21.850  31.011  1.00 20.00           C
ATOM     55  CE1 TYR A   7      34.532  20.000  29.887  1.00 20.00           C
ATOM     56  CE2 TYR A   7      34.956  21.743  31.507  1.00 20.00           C
ATOM     57  CZ  TYR A   7      34.099  20.823  30.922  1.00 20.00           C
ATOM     58  OH  TYR A   7      32.818  20.683  31.382  1.00 20.00           O
ATOM     59  OXT TYR A   7      40.410  23.093  28.703  1.00 20.00           O
END
"""

def exercise_d99():
  pdb_inp = iotbx.pdb.input(source_info=None, lines = pdb_str)
  ph = pdb_inp.construct_hierarchy()
  xrs = ph.extract_xray_structure(crystal_symmetry = pdb_inp.crystal_symmetry())
  crystal_gridding = maptbx.crystal_gridding(
    unit_cell         = xrs.unit_cell(),
    space_group_info  = xrs.space_group_info(),
    resolution_factor = 0.25,
    d_min             = 2.,
    symmetry_flags    = maptbx.use_space_group_symmetry)
  fc = xrs.structure_factors(d_min=2.).f_calc()
  fft_map = fc.fft_map(crystal_gridding=crystal_gridding)
  map = fft_map.real_map_unpadded()
  #
  o = maptbx.d99(map=map, crystal_symmetry=xrs.crystal_symmetry())
  assert approx_equal(o.result.d99, 2.13, 0.03)

def exercise_five_cc():
  pdb_inp = iotbx.pdb.input(source_info=None, lines = pdb_str)
  ph = pdb_inp.construct_hierarchy()
  #ph.write_pdb_file(file_name="m1.pdb")
  xrs = ph.extract_xray_structure(crystal_symmetry = pdb_inp.crystal_symmetry())
  f_calc = xrs.structure_factors(d_min=2.0).f_calc()#.resolution_filter(d_max=6)
  fft_map = f_calc.fft_map(resolution_factor=0.25)
  m1 = fft_map.real_map_unpadded()
  #
  #xrs = xrs.set_b_iso(value=50)
  sc = xrs.sites_cart()
  #sc = sc + flex.vec3_double(sc.size(), [.5,.5,.5])
  xrs = xrs.replace_sites_cart(new_sites=sc)
  ph.adopt_xray_structure(xrs)
  #ph.write_pdb_file(file_name="m2.pdb")
  o = correlation.five_cc(map=m1, xray_structure=xrs, d_min=2.0,
    compute_cc_box=True, compute_cc_image=True, box=False).result
  assert approx_equal(o.cc_box, 1.0)
  assert approx_equal(o.cc_image  , 1.0)
  assert approx_equal(o.cc_mask   , 1.0)
  assert approx_equal(o.cc_peaks  , 1.0)
  assert approx_equal(o.cc_volume , 1.0)

if (__name__ == "__main__"):
  exercise_d99()
  exercise_five_cc()


 *******************************************************************************


 *******************************************************************************
mmtbx/maps/tst_map_model_cc_and_vals_per_atom_xtal.py
from __future__ import division
import iotbx.pdb
import mmtbx.model
import mmtbx.f_model
from scitbx.array_family import flex
from libtbx.test_utils import approx_equal
from mmtbx.maps import correlation

pdb_str = """
CRYST1  120.670  120.670  136.370  90.00  90.00  90.00 I 4 2 2
ATOM      1  O   HOH A1001       0.385 140.717  50.480  0.50 10.00           O
ATOM      9  O   HOH A1002       6.262 141.644  51.299  0.20 10.00           O
ATOM     24  O   HOH A1004       9.580 133.515  50.443  1.00 10.00           O
TER
ATOM    400  O   HOH A1055      26.182 123.726  20.298  1.00 10.00           O
ATOM    401  O   HOH A1055      25.854 122.538  21.075  1.00 10.00           O
ATOM    402  O   HOH A1055      26.638 121.342  20.536  1.00 10.00           O
ATOM    403  O   HOH A1055      26.375 120.862  19.435  1.00 10.00           O
ATOM    404  O   HOH A1055      24.353 122.353  21.000  1.00 10.00           O
ATOM    405  O   HOH A1055      23.698 121.398  21.929  1.00 10.00           O
ATOM    406  O   HOH A1055      23.055 121.735  23.085  1.00 10.00           O
ATOM    407  O   HOH A1055      23.560 119.980  21.783  1.00 10.00           O
ATOM    408  O   HOH A1055      22.543 120.613  23.678  1.00 10.00           O
ATOM    409  O   HOH A1055      22.835 119.525  22.907  1.00 10.00           O
ATOM    410  O   HOH A1055      23.969 119.044  20.827  1.00 10.00           O
ATOM    411  O   HOH A1055      22.515 118.180  23.107  1.00 10.00           O
ATOM    412  O   HOH A1055      23.658 117.716  21.026  1.00 10.00           O
ATOM    413  O   HOH A1055      22.940 117.293  22.156  1.00 10.00           O
ATOM    414  O   HOH A1056      27.660 120.961  21.291  1.00 10.00           O
ATOM    415  O   HOH A1056      28.617 119.926  20.939  1.00 10.00           O
ATOM    416  O   HOH A1056      28.936 119.084  22.170  1.00 10.00           O
ATOM    417  O   HOH A1056      29.791 119.479  22.957  1.00 10.00           O
ATOM    418  O   HOH A1056      29.969 120.503  20.457  1.00 10.00           O
ATOM    419  O   HOH A1056      29.789 121.456  19.403  1.00 10.00           O
ATOM    420  O   HOH A1056      30.835 119.383  19.884  1.00 10.00           O
ATOM    421  O   HOH A1057      28.254 117.978  22.432  1.00 10.00           O
ATOM    422  O   HOH A1057      28.579 117.228  23.654  1.00 10.00           O
ATOM    423  O   HOH A1057      30.035 116.807  23.734  1.00 10.00           O
ATOM    424  O   HOH A1057      30.644 116.451  22.736  1.00 10.00           O
ATOM    425  O   HOH A1057      27.655 116.014  23.546  1.00 10.00           O
ATOM    426  O   HOH A1057      26.471 116.555  22.790  1.00 10.00           O
ATOM    427  O   HOH A1057      27.090 117.423  21.727  1.00 10.00           O
ATOM    428  O   HOH A1058      30.589 116.855  24.946  1.00 10.00           O
ATOM    429  O   HOH A1058      31.990 116.512  25.116  1.00 10.00           O
ATOM    430  O   HOH A1058      32.223 115.225  25.897  1.00 10.00           O
ATOM    431  O   HOH A1058      33.376 114.801  26.021  1.00 10.00           O
ATOM    432  O   HOH A1058      32.729 117.660  25.819  1.00 10.00           O
ATOM    433  O   HOH A1058      32.742 118.931  24.991  1.00 10.00           O
ATOM    434  O   HOH A1058      32.085 120.062  25.441  1.00 10.00           O
ATOM    435  O   HOH A1058      33.403 118.955  23.779  1.00 10.00           O
ATOM    436  O   HOH A1058      32.118 121.215  24.691  1.00 10.00           O
ATOM    437  O   HOH A1058      33.444 120.109  23.019  1.00 10.00           O
ATOM    438  O   HOH A1058      32.789 121.228  23.486  1.00 10.00           O
ATOM    439  O   HOH A1059      31.173 114.619  26.441  1.00 10.00           O
ATOM    440  O   HOH A1059      31.363 113.477  27.312  1.00 10.00           O
ATOM    441  O   HOH A1059      30.460 112.314  26.941  1.00 10.00           O
ATOM    442  O   HOH A1059      29.379 112.486  26.390  1.00 10.00           O
ATOM    443  O   HOH A1059      31.084 113.855  28.770  1.00 10.00           O
ATOM    444  O   HOH A1059      32.012 114.945  29.291  1.00 10.00           O
ATOM    445  O   HOH A1059      31.573 115.430  30.966  1.00 10.00           O
ATOM    446  O   HOH A1059      32.850 114.619  31.914  1.00 10.00           O
ATOM    447  O   HOH A1060      30.890 111.112  27.331  1.00 10.00           O
ATOM    448  O   HOH A1060      29.940 110.001  27.198  1.00 10.00           O
ATOM    449  O   HOH A1060      28.873 110.111  28.287  1.00 10.00           O
ATOM    450  O   HOH A1060      28.983 110.902  29.213  1.00 10.00           O
ATOM    451  O   HOH A1060      30.638 108.642  27.328  1.00 10.00           O
ATOM    452  O   HOH A1060      31.329 108.669  28.563  1.00 10.00           O
ATOM    453  O   HOH A1060      31.768 108.465  26.324  1.00 10.00           O
END
"""

def run():
  pdb_inp = iotbx.pdb.input(source_info = None, lines = pdb_str)
  model = mmtbx.model.manager(model_input = pdb_inp)
  xrs_good = model.get_xray_structure()
  f_obs = abs(xrs_good.structure_factors(d_min=1.5).f_calc())
  #
  xrs_poor = xrs_good.deep_copy_scatterers()
  sites_cart = xrs_poor.sites_cart()
  sites_cart[2] = (sites_cart[2][0]+5,
                   sites_cart[2][1]+2,
                   sites_cart[2][2]+3)
  xrs_poor = xrs_poor.replace_sites_cart(new_sites = sites_cart)
  #
  fmodel = mmtbx.f_model.manager(
    f_obs          = f_obs,
    xray_structure = xrs_poor)
  fmodel.update_all_scales()
  print ("r_work=%6.4f r_free=%6.4f"%(fmodel.r_work(), fmodel.r_free()))
  #
  r = correlation.map_model_cc_and_vals_per_atom_xtal(fmodel = fmodel)
  for i, a in enumerate(model.get_hierarchy().atoms()):
    cc = r.ccs[i]
    mv = r.vals[i]
    #print(a.format_atom_record(), cc, mv)
  mean = flex.mean(r.vals[3:])
  a0 = round(mean/r.vals[0],0)
  a1 = round(mean/r.vals[1],0)
  assert approx_equal(a0, 2)
  assert approx_equal(a1, 5)

if(__name__ == "__main__"):
  run()


 *******************************************************************************


 *******************************************************************************
mmtbx/maps/utils.py

# XXX most of the functions in this module are deprectated and should be
# removed as soon as someone has time.

from __future__ import absolute_import, division, print_function
from libtbx.math_utils import ifloor, iceil
from libtbx.utils import Sorry, null_out
from libtbx import adopt_init_args
import libtbx.phil
import os
import sys
from six.moves import zip

#-----------------------------------------------------------------------
# MAP COEFFICIENT MANIPULATION

def create_map_from_pdb_and_mtz(
    pdb_file,
    mtz_file,
    output_file,
    fill=False,
    out=None,
    llg_map=False,
    remove_unknown_scatterering_type=False,
    assume_pdb_data=False):
  """
  Convenience function, used by phenix.fetch_pdb.

  :param remove_unknown_scatterering_type: if True, atoms with unknown
    scattering type will be removed before extracting the X-ray structure
    (which would crash otherwise).
  """
  if (out is None) : out = sys.stdout
  import iotbx.pdb
  from scitbx.array_family import flex
  pdb_in = iotbx.pdb.input(pdb_file)
  xrs = pdb_in.xray_structure_simple(enable_scattering_type_unknown=True)
  selection = xrs.scatterers().extract_scattering_types()!="unknown"
  if(selection.size()!=selection.count(True)):
    print("WARNING: removing %d atoms with unknown scattering type." %\
      selection.count(False), file=out)
  xrs = xrs.select(selection)
  fast_maps_from_hkl_file(
    file_name=mtz_file,
    xray_structure=xrs,
    map_out=output_file,
    log=out,
    auto_run=True,
    quiet=True,
    anomalous_map=True,
    llg_map=llg_map,
    fill_maps=fill,
    assume_pdb_data=assume_pdb_data)

class fast_maps_from_hkl_file(object):
  """
  Automation wrapper for calculating standard 2mFo-DFc, mFo-DFc, and optional
  anomalous difference map coefficients, starting from an X-ray structure and
  an MTZ file name.  This will attempt to guess the correct data array
  automatically (giving preference to anomalous amplitudes).

  The organization of this class is somewhat messy, as it is designed to be
  run in parallel for multiple structures.
  """
  def __init__(self,
                file_name,
                xray_structure,
                scattering_table="wk1995",
                f_label=None,
                r_free_label=None,
                map_out=None,
                log=sys.stdout,
                auto_run=True,
                quiet=False,
                anomalous_map=False,
                fill_maps=True,
                save_fmodel=False,
                llg_map=False,
                assume_pdb_data=False, # FIXME should be default, needs testing
                ):
    adopt_init_args(self, locals())
    from iotbx import file_reader
    from scitbx.array_family import flex
    if f_label is None and not quiet:
      print("      no label for %s, will try default labels" % \
        os.path.basename(file_name), file=log)
    f_obs = r_free_flags = None
    # FIXME this whole block needs to disappear
    if (not assume_pdb_data):
      fallback_f_obs = []
      default_labels = ["F(+),SIGF(+),F(-),SIGF(-)",
        "I(+),SIGI(+),I(-),SIGI(-)",
        "F,SIGF","FOBS,SIGFOBS", "FOBS_X", "IOBS,SIGIOBS"]
      default_rfree_labels = ["FreeR_flag", "FREE", "R-free-flags"]
      all_labels = []
      best_label = sys.maxsize
      data_file = file_reader.any_file(file_name, force_type="hkl")
      for miller_array in data_file.file_server.miller_arrays :
        labels = miller_array.info().label_string()
        all_labels.append(labels)
        if (labels == f_label):
          f_obs = miller_array
          break
        elif (f_label is None) and (labels in default_labels):
          label_score = default_labels.index(labels)
          if (label_score < best_label):
            f_obs = miller_array
            best_label = label_score
        elif miller_array.is_xray_amplitude_array():
          fallback_f_obs.append(miller_array)
      if f_obs is None :
        if (len(fallback_f_obs) == 1) and (f_label is None):
          for array in fallback_f_obs :
            if (array.anomalous_flag()) and (self.anomalous_map):
              f_obs = array
              break
          else :
            f_obs = fallback_f_obs[0]
        else :
          raise Sorry(("Couldn't find %s in %s.  Please specify valid "+
            "column labels (possible choices: %s)") % (f_label, file_name,
              " ".join(all_labels)))
      if (f_obs.is_xray_intensity_array()):
        f_obs = f_obs.f_sq_as_f()
      sys_abs_flags = f_obs.sys_absent_flags().data()
      f_obs = f_obs.map_to_asu().select(selection=~sys_abs_flags)
      r_free = data_file.file_server.get_r_free_flags(
        file_name=None,
        label=r_free_label,
        test_flag_value=None,
        parameter_scope=None,
        disable_suitability_test=False,
        return_all_valid_arrays=True)
      if (len(r_free) == 0):
        self.f_obs = f_obs
        self.r_free_flags = f_obs.array(
          data=flex.bool(f_obs.data().size(),False))
      else :
        array, test_flag_value = r_free[0]
        new_flags = array.customized_copy(
          data=array.data() == test_flag_value).map_to_asu()
        if (f_obs.anomalous_flag()) and (not new_flags.anomalous_flag()):
          new_flags = new_flags.generate_bijvoet_mates()
        self.r_free_flags = new_flags.common_set(f_obs)
        self.f_obs = f_obs.common_set(self.r_free_flags)
    else :
      import mmtbx.wwpdb.utils
      data_info = mmtbx.wwpdb.utils.find_data_arrays(
        mtz_file=file_name, log=null_out())
      self.f_obs, self.r_free_flags = data_info.data_and_flags()
    self.log = None
    self.fmodel = None
    if auto_run :
      self.run()

  def get_maps_from_fmodel(self):
    import mmtbx.utils
    from scitbx.array_family import flex
    mmtbx.utils.setup_scattering_dictionaries(
      scattering_table = "n_gaussian",
      xray_structure   = self.xray_structure,
      d_min            = self.f_obs.d_min(),
      log              = null_out())
    fmodel = mmtbx.utils.fmodel_simple(
      xray_structures=[self.xray_structure],
      scattering_table = self.scattering_table,
      f_obs=self.f_obs,
      r_free_flags=self.r_free_flags,
      outliers_rejection=True,
      skip_twin_detection=False,
      bulk_solvent_correction=True,
      anisotropic_scaling=True)
    if (self.save_fmodel):
      self.fmodel = fmodel
    (f_map, df_map) = get_maps_from_fmodel(fmodel)
    anom_map = None
    if (self.anomalous_map) and (self.f_obs.anomalous_flag()):
      anom_map = get_anomalous_map(fmodel)
    return f_map, df_map, anom_map

  def run(self):
    import iotbx.map_tools
    (f_map, df_map, anom_map) = self.get_maps_from_fmodel()
    if self.map_out is None :
      self.map_out = os.path.splitext(self.file_name)[0] + "_map_coeffs.mtz"
    iotbx.map_tools.write_map_coeffs(f_map, df_map, self.map_out, anom_map)

def get_maps_from_fmodel(fmodel, fill_missing_f_obs=True,
    exclude_free_r_reflections=False):
  map_manager = fmodel.electron_density_map()
  two_fofc_coeffs = map_manager.map_coefficients(map_type = "2mFo-DFc",
    exclude_free_r_reflections=exclude_free_r_reflections,
    fill_missing=fill_missing_f_obs)
  if two_fofc_coeffs.anomalous_flag():
    two_fofc_coeffs = two_fofc_coeffs.average_bijvoet_mates()
  fofc_coeffs = map_manager.map_coefficients(map_type = "mFo-DFc",
    exclude_free_r_reflections=exclude_free_r_reflections,
    fill_missing=fill_missing_f_obs)
  if fofc_coeffs.anomalous_flag():
    fofc_coeffs = fofc_coeffs.average_bijvoet_mates()
  return (two_fofc_coeffs, fofc_coeffs)

def get_anomalous_map(fmodel):
  map_manager = fmodel.electron_density_map()
  anom_coeffs = map_manager.map_coefficients(map_type="anom")
  if (anom_coeffs.anomalous_flag()):
    anom_coeffs = anom_coeffs.average_bijvoet_mates()
  return anom_coeffs

class generate_water_omit_map(object):
  """
  Calculate standard map coefficients (with R-free flags omitted, and missing
  reflections filled) with water occupancies set to zero.  Used for ligand
  fitting after refinement.
  """
  def __init__(self,
      fmodel,
      pdb_hierarchy,
      skip_if_no_waters=False,
      exclude_free_r_reflections=False,
      fill_missing_f_obs=False,
      write_f_model=False,
      log=None):
    if (log is None):
      log = null_out()
    sel_cache = pdb_hierarchy.atom_selection_cache()
    water_sel = sel_cache.selection("resname HOH")
    xrs = fmodel.xray_structure
    self.crystal_symmetry = xrs.crystal_symmetry()
    assert (water_sel.size() == xrs.scatterers().size())
    self.n_waters = water_sel.count(True)
    self.two_fofc_map = self.fofc_map = self.anom_map = self.fmodel_map = None
    if (self.n_waters == 0) and (skip_if_no_waters):
      print("  No waters in model, skipping omit map calculation", file=log)
      self.pdb_hierarchy_omit = pdb_hierarchy
    else :
      print("  Calculating new 2mFo-DFc and mFo-DFc maps...", file=log)
      print("    %d waters temporarily set to zero occupancy" % \
        self.n_waters, file=log)
      print("", file=log)
      self.pdb_hierarchy_omit = pdb_hierarchy.select(~water_sel)
      occ = xrs.scatterers().extract_occupancies()
      if (self.n_waters > 0):
        xrs.set_occupancies(value=0, selection=water_sel)
      fmodel.update_xray_structure(xrs,
        update_f_calc=True)
    #    update_f_mask=False)
      fmodel.update_all_scales(log=log)
      self.two_fofc_map = fmodel.electron_density_map(
        ).map_coefficients(
          map_type="2mFo-DFc",
          exclude_free_r_reflections=exclude_free_r_reflections,
          fill_missing=fill_missing_f_obs)
      self.fofc_map = fmodel.electron_density_map(
        ).map_coefficients(
          map_type="mFo-DFc",
          exclude_free_r_reflections=exclude_free_r_reflections,
          fill_missing=False,
          merge_anomalous=True)
      if (fmodel.f_obs().anomalous_flag()):
        self.anom_map = fmodel.electron_density_map(
          ).map_coefficients(
            map_type="anom",
            exclude_free_r_reflections=exclude_free_r_reflections,
            fill_missing=fill_missing_f_obs)
      if (write_f_model):
        self.fmodel_map = fmodel.f_model().average_bijvoet_mates()

  def write_map_coeffs(self, file_name):
    assert (self.two_fofc_map is not None)
    write_map_coeffs(
      fwt_coeffs=self.two_fofc_map,
      delfwt_coeffs=self.fofc_map,
      anom_coeffs=self.anom_map,
      fmodel_coeffs=self.fmodel_map,
      file_name=file_name)

  def write_pdb_file(self, file_name):
    self.pdb_hierarchy_omit.write_pdb_file(
      file_name=file_name,
      crystal_symmetry=self.crystal_symmetry)

def get_default_map_coefficients_phil(
    show_filled=True,
    disable_filled=False,
    exclude_free_r_reflections=False,
    enclosing_scope=None,
    as_phil_object=True):
  """
  Generate the map coefficients PHIL string for phenix.maps, phenix.refine,
  and related applications, based on several toggles which control the
  handling of missing reflections and R-free flags.  Used by the Phenix GUI.
  """
  secondary_two_fofc_params = ""
  if (not disable_filled):
    if (show_filled):
      secondary_two_fofc_params = """
      map_coefficients {
        mtz_label_amplitudes = 2FOFCWT_no_fill
        mtz_label_phases = PH2FOFCWT_no_fill
        map_type = 2mFo-DFc
        fill_missing_f_obs = False
        exclude_free_r_reflections = %s
      }""" % exclude_free_r_reflections
    else :
      secondary_two_fofc_params = """
      map_coefficients {
        mtz_label_amplitudes = 2FOFCWT_filled
        mtz_label_phases = PH2FOFCWT_filled
        map_type = 2mFo-DFc
        fill_missing_f_obs = True
        exclude_free_r_reflections = %s
      }""" % exclude_free_r_reflections
  maps_phil = """
    map_coefficients {
      mtz_label_amplitudes = 2FOFCWT
      mtz_label_phases = PH2FOFCWT
      map_type = 2mFo-DFc
      fill_missing_f_obs = %(show_filled)s
      exclude_free_r_reflections = %(exclude_rfree)s
    }
    %(other_two_fofc)s
    map_coefficients {
      mtz_label_amplitudes = FOFCWT
      mtz_label_phases = PHFOFCWT
      map_type = mFo-DFc
      exclude_free_r_reflections = %(exclude_rfree)s
    }
    map_coefficients {
      map_type = anomalous
      format = *mtz phs
      mtz_label_amplitudes = ANOM
      mtz_label_phases = PHANOM
      exclude_free_r_reflections = %(exclude_rfree)s
    }
""" % { "exclude_rfree" : exclude_free_r_reflections,
        "other_two_fofc" : secondary_two_fofc_params,
        "show_filled" : show_filled and not disable_filled, }
  if (enclosing_scope is not None):
    maps_phil = """%s {\n%s\n}""" % (enclosing_scope, maps_phil)
  if (as_phil_object):
    return libtbx.phil.parse(maps_phil)
  return maps_phil

# XXX redundant, needs to be eliminated
def write_map_coeffs(*args, **kwds):
  import iotbx.map_tools
  return iotbx.map_tools.write_map_coeffs(*args, **kwds)

#-----------------------------------------------------------------------
# XPLOR MAP OUTPUT

# TODO: make more modular!
def write_xplor_map_file(coeffs, frac_min, frac_max, file_base):
  fft_map = coeffs.fft_map(resolution_factor=1/3.0)
  fft_map.apply_sigma_scaling()
  n_real = fft_map.n_real()
  gridding_first=[ifloor(f*n) for f,n in zip(frac_min,n_real)]
  gridding_last=[iceil(f*n) for f,n in zip(frac_max,n_real)]
  title_lines=["REMARK map covering model + 3.0A buffer"]
  file_name = "%s.map" % file_base
  fft_map.as_xplor_map(
    file_name=file_name,
    title_lines=title_lines,
    gridding_first=gridding_first,
    gridding_last=gridding_last)
  return file_name

def write_xplor_map(sites_cart, unit_cell, map_data, n_real, file_name,
    buffer=10):
  import iotbx.xplor.map
  if sites_cart is not None :
    frac_min, frac_max = unit_cell.box_frac_around_sites(
      sites_cart=sites_cart,
      buffer=buffer)
  else :
    frac_min, frac_max = (0.0, 0.0, 0.0), (1.0, 1.0, 1.0)
  gridding_first=[ifloor(f*n) for f,n in zip(frac_min,n_real)]
  gridding_last=[iceil(f*n) for f,n in zip(frac_max,n_real)]
  gridding = iotbx.xplor.map.gridding(n     = map_data.focus(),
                                      first = gridding_first,
                                      last  = gridding_last)
  iotbx.xplor.map.writer(
    file_name          = file_name,
    is_p1_cell         = True,
    title_lines        = [' None',],
    unit_cell          = unit_cell,
    gridding           = gridding,
    data               = map_data,
    average            = -1,
    standard_deviation = -1)

# XXX backwards compatibility
# TODO remove these ASAP once GUI is thoroughly tested
def extract_map_coeffs(*args, **kwds):
  import iotbx.gui_tools.reflections
  return iotbx.gui_tools.reflections.extract_map_coeffs(*args, **kwds)

def map_coeffs_from_mtz_file(*args, **kwds):
  import iotbx.gui_tools.reflections
  return iotbx.gui_tools.reflections.map_coeffs_from_mtz_file(*args, **kwds)

def extract_phenix_refine_map_coeffs(*args, **kwds):
  import iotbx.gui_tools.reflections
  return iotbx.gui_tools.reflections.extract_phenix_refine_map_coeffs(*args,
    **kwds)

def get_map_coeff_labels(*args, **kwds):
  import iotbx.gui_tools.reflections
  return iotbx.gui_tools.reflections.get_map_coeff_labels(*args, **kwds)

def get_map_coeffs_for_build(server):
  return get_map_coeff_labels(server, build_only=True)

def format_map_coeffs_for_resolve(*args, **kwds):
  import iotbx.gui_tools.reflections
  return iotbx.gui_tools.reflections.format_map_coeffs_for_resolve(*args,
    **kwds)

def decode_resolve_map_coeffs(*args, **kwds):
  import iotbx.gui_tools.reflections
  return iotbx.gui_tools.reflections.decode_resolve_map_coeffs(*args, **kwds)


 *******************************************************************************


 *******************************************************************************
mmtbx/maps/xtrapol8.py
from __future__ import absolute_import, division, print_function
import inspect
from libtbx import adopt_init_args
from libtbx.utils import user_plus_sys_time

def broadcast(m, log):
  if log is None: return
  print("-"*79, file=log)
  print(m, file=log)
  print("*"*len(m), file=log)

class manager(object):
  '''
  Clsss to execute Xtrapol8 calculations.
  f_obs_reference and f_obs_triggered are experimental amplitudes and expecetd
  to have consistent indexing.
  '''

  def __init__(self,
               model_reference,
               f_obs_reference,
               f_obs_triggered,
               log=None):
    adopt_init_args(self, locals())
    self.total_time = 0
    #
    self._caller(self._initialize)

  def run(self):
    self._caller(self._scale)
    self._caller(self._compute_weights)
    self._caller(self._compute_fo_minus_fo_map)

  def _caller(self, func):
    timer = user_plus_sys_time()
    doc = inspect.getdoc(func)
    broadcast(m=doc, log=self.log)
    func()
    t = timer.elapsed()
    self.total_time += t

  def _initialize(self):
    '''
    Start: initializing and validating inputs
    '''
    self.f_obs_reference, self.f_obs_triggered = \
      self.f_obs_reference.common_sets(self.f_obs_triggered)
    # Compute Riso and CCiso

  def _scale(self):
    '''
    Scale f_obs_reference and f_obs_triggered
    '''
    pass

  def _compute_weights(self):
    '''
    Compute k- and q-weights
    '''
    pass

  def _compute_fo_minus_fo_map(self):
    '''
    Compute F_diff = {weight * (F_obs1 - F_obs2), Phase_reference} map
    '''
    pass

  def _compute_f_extrapolated(self, alpha):
    '''
    Compute F_extrapolated
    '''
    pass


 *******************************************************************************
