

 *******************************************************************************
cctbx/regression/tst_grm_modifications_rm.py
from __future__ import absolute_import, division, print_function
from mmtbx import monomer_library
import mmtbx.model
from six.moves import cStringIO as StringIO
#import libtbx.load_env
from libtbx.test_utils import show_diff, assert_lines_in_text
from libtbx.utils import null_out
import libtbx.load_env
import iotbx
import os

# from tst_grm_modifications import raw_records4, raw_records9
from tst_grm_modifications import make_initial_grm, show_sorted_geometry

def make_initial_grm(mon_lib_srv, ener_lib, records):
  processed_pdb_file = monomer_library.pdb_interpretation.process(
    mon_lib_srv    = mon_lib_srv,
    ener_lib       = ener_lib,
    raw_records    = records,
    force_symmetry = True)

  geometry = processed_pdb_file.geometry_restraints_manager(
    show_energies      = True,
    plain_pairs_radius = 5.0)
  xrs = processed_pdb_file.xray_structure()
  return geometry, xrs

def make_grm_via_model(mon_lib_srv, ener_lib, records, params):
  pdb_inp = iotbx.pdb.input(source_info=None, lines=records)
  model = mmtbx.model.manager(
      model_input = pdb_inp,
      log=null_out())
  model.process(pdb_interpretation_params=params, make_restraints=True)
  grm = model.get_restraints_manager().geometry
  xrs = model.get_xray_structure()
  return grm, xrs


def show_sorted_geometry_str(geometry, xrs):
  sio = StringIO()
  geometry.show_sorted(
      sites_cart=xrs.sites_cart(),
      site_labels=xrs.scatterers().extract_labels(),
      f=sio)
  return sio.getvalue()

# SS-bridge with self!
raw_records1 = """\
CRYST1  108.910  108.910  108.910  90.00  90.00  90.00 I 4 3 2
SCALE1      0.009182  0.000000  0.000000        0.00000
SCALE2      0.000000  0.009182  0.000000        0.00000
SCALE3      0.000000  0.000000  0.009182        0.00000
ATOM      1  N   PRO A   1     -50.110 -12.340  -8.990  1.00 87.52           N
ATOM      2  CA  PRO A   1     -49.518 -12.918 -10.200  1.00 88.41           C
ATOM      3  C   PRO A   1     -50.549 -13.676 -11.025  1.00 97.43           C
ATOM      4  O   PRO A   1     -51.129 -14.656 -10.556  1.00 93.89           O
ATOM      5  CB  PRO A   1     -48.446 -13.865  -9.649  1.00 78.46           C
ATOM      6  CG  PRO A   1     -48.110 -13.314  -8.317  1.00 80.77           C
ATOM      7  CD  PRO A   1     -49.402 -12.783  -7.777  1.00 92.02           C
ATOM      8  N   CYS A   2     -50.777 -13.205 -12.246  1.00 95.50           N
ATOM      9  CA  CYS A   2     -51.774 -13.797 -13.124  1.00103.68           C
ATOM     10  C   CYS A   2     -51.135 -14.327 -14.399  1.00101.77           C
ATOM     11  O   CYS A   2     -50.987 -13.597 -15.382  1.00106.09           O
ATOM     12  CB  CYS A   2     -52.861 -12.775 -13.466  1.00103.91           C
ATOM     13  SG  CYS A   2     -54.064 -13.357 -14.680  1.00106.39           S
ATOM     14  N   LYS A   3     -50.756 -15.600 -14.375  1.00105.98           N
ATOM     15  CA  LYS A   3     -50.135 -16.230 -15.528  1.00115.21           C
ATOM     16  C   LYS A   3     -50.110 -17.740 -15.357  1.00105.26           C
ATOM     17  O   LYS A   3     -50.331 -18.255 -14.264  1.00118.65           O
ATOM     18  CB  LYS A   3     -48.714 -15.704 -15.737  1.00110.03           C
ATOM     19  CG  LYS A   3     -47.784 -15.954 -14.563  1.00100.14           C
ATOM     20  CD  LYS A   3     -46.379 -15.452 -14.853  1.00101.77           C
ATOM     21  CE  LYS A   3     -45.456 -15.678 -13.663  1.00112.21           C
ATOM     22  NZ  LYS A   3     -44.063 -15.229 -13.941  1.00110.68           N
ATOM     23  OXT LYS A   3     -49.867 -18.479 -16.312  1.00 30.00           O
TER
END
"""

# CO is on special position, 3 copies around. Links to NE2 and HOH
raw_records2 = """\
CRYST1   81.430   81.430   33.750  90.00  90.00 120.00 H 3          18
ORIGX1      1.000000  0.000000  0.000000        0.00000
ORIGX2      0.000000  1.000000  0.000000        0.00000
ORIGX3      0.000000  0.000000  1.000000        0.00000
SCALE1      0.012280  0.007090  0.000000        0.00000
SCALE2      0.000000  0.014180  0.000000        0.00000
SCALE3      0.000000  0.000000  0.029630        0.00000
ATOM      1  N   HIS D  10      -0.063   5.481  -5.607  1.00 10.05           N
ATOM      2  CA  HIS D  10       1.347   5.653  -5.385  1.00  9.54           C
ATOM      3  C   HIS D  10       1.835   7.103  -5.261  1.00  8.81           C
ATOM      4  O   HIS D  10       2.731   7.418  -4.480  1.00  8.89           O
ATOM      5  CB  HIS D  10       2.061   4.958  -6.530  1.00 10.08           C
ATOM      6  CG  HIS D  10       1.686   3.518  -6.637  1.00 10.90           C
ATOM      7  ND1 HIS D  10       1.964   2.609  -5.629  1.00 11.69           N
ATOM      8  CD2 HIS D  10       0.995   2.864  -7.574  1.00 11.16           C
ATOM      9  CE1 HIS D  10       1.490   1.429  -5.986  1.00 12.82           C
ATOM     10  NE2 HIS D  10       0.918   1.565  -7.171  1.00 10.61           N
HETATM   11 CO    CO D 101      -0.002   0.003  -8.336  0.33 12.86          CO
HETATM   12  O   HOH D 208      -0.901   1.609  -9.921  1.00 16.66           O
END
"""

raw_records4 = """\
CRYST1   15.775   12.565   13.187  90.00  90.00  90.00 P 1
ATOM      1  N   MET A   1       9.821   6.568   5.000  1.00 66.07           N
ATOM      2  CA  MET A   1       9.946   7.171   6.357  1.00 66.55           C
ATOM      3  C   MET A   1      10.571   6.157   7.305  1.00 64.57           C
ATOM      4  O   MET A   1      10.775   5.000   6.933  1.00 66.25           O
ATOM      5  CB  MET A   1       8.570   7.565   6.897  1.00 69.08           C
ATOM      6  CG  MET A   1       7.723   6.373   7.299  1.00 71.37           C
ATOM      7  SD  MET A   1       6.247   6.862   8.187  1.00 76.22           S
ATOM      8  CE  MET A   1       5.000   6.694   6.892  1.00 74.93           C
END
""".splitlines()

raw_records9 = """\
CRYST1   41.028   41.028  183.010  90.00  90.00  90.00 P 43 21 2
SCALE1      0.024374  0.000000  0.000000        0.00000
SCALE2      0.000000  0.024374  0.000000        0.00000
SCALE3      0.000000  0.000000  0.005464        0.00000
ATOM      1  CG  HIS A 319       2.304  23.849  77.123  1.00 23.70           C
ATOM      2  ND1 HIS A 319       1.668  23.871  75.903  1.00 25.36           N
ATOM      3  CD2 HIS A 319       2.302  25.128  77.578  1.00 21.49           C
ATOM      4  CE1 HIS A 319       1.265  25.110  75.643  1.00 25.28           C
ATOM      5  NE2 HIS A 319       1.643  25.884  76.636  1.00 23.98           N
ATOM      6  HD1 HIS A 319       1.550  23.191  75.390  1.00 30.43           H
ATOM      7  HD2 HIS A 319       2.675  25.435  78.373  1.00 25.78           H
ATOM      8  HE1 HIS A 319       0.795  25.383  74.888  1.00 30.33           H
ATOM      9  HG3 MET A 338      -1.284  24.273  77.766  1.00 36.33           H
ATOM     10  CG  GLU A 362       1.743  29.061  80.665  1.00 32.98           C
ATOM     11  CD  GLU A 362       1.505  28.476  79.273  1.00 26.00           C
ATOM     12  OE1 GLU A 362       0.357  28.085  78.927  1.00 33.20           O
ATOM     13  OE2 GLU A 362       2.511  28.378  78.586  1.00 24.88           O
ATOM     14  HG2 GLU A 362       2.252  29.880  80.555  1.00 39.58           H
ATOM     15  HG3 GLU A 362       2.259  28.414  81.171  1.00 39.58           H
TER
ATOM     16  N   HIS B 304     -20.949  11.990  59.962  1.00 23.21           N
ATOM     17  CA  HIS B 304     -22.165  11.249  60.299  1.00 25.44           C
ATOM     18  C   HIS B 304     -23.349  12.161  60.500  1.00 29.20           C
ATOM     19  O   HIS B 304     -24.477  11.760  60.211  1.00 32.52           O
ATOM     20  CB  HIS B 304     -21.963  10.373  61.537  1.00 28.40           C
ATOM     21  CG  HIS B 304     -20.809   9.431  61.430  1.00 27.87           C
ATOM     22  ND1 HIS B 304     -19.517   9.806  61.733  1.00 36.76           N
ATOM     23  CD2 HIS B 304     -20.737   8.128  61.054  1.00 26.50           C
ATOM     24  CE1 HIS B 304     -18.706   8.776  61.549  1.00 36.85           C
ATOM     25  NE2 HIS B 304     -19.428   7.737  61.176  1.00 27.21           N
ATOM     26  HA  HIS B 304     -22.359  10.653  59.559  1.00 30.53           H
ATOM     27  HB2 HIS B 304     -21.805  10.948  62.303  1.00 34.08           H
ATOM     28  HB3 HIS B 304     -22.764   9.845  61.678  1.00 34.08           H
ATOM     29  HD2 HIS B 304     -21.445   7.599  60.766  1.00 31.79           H
ATOM     30  HE1 HIS B 304     -17.783   8.783  61.663  1.00 44.22           H
ATOM     31  HE2 HIS B 304     -19.128   6.944  61.034  1.00 32.64           H
ATOM     32 HG21 VAL B 315     -20.236   8.723  64.319  1.00 36.99           H
TER
HETATM   33 ZN    ZN A   8       1.797  27.888  76.692  1.00 34.36          Zn
HETATM   34  O   HOH A  57       3.694  28.411  75.816  1.00 39.92           O
HETATM   35  O   HOH A  69       5.784  26.244  75.932  1.00 38.11           O
"""

raw_records91 = """\
CRYST1   41.028   41.028  183.010  90.00  90.00  90.00 P 43 21 2
SCALE1      0.024374  0.000000  0.000000        0.00000
SCALE2      0.000000  0.024374  0.000000        0.00000
SCALE3      0.000000  0.000000  0.005464        0.00000
ATOM     16  N   HIS B 304     -20.949  11.990  59.962  1.00 23.21           N
ATOM     17  CA  HIS B 304     -22.165  11.249  60.299  1.00 25.44           C
ATOM     18  C   HIS B 304     -23.349  12.161  60.500  1.00 29.20           C
ATOM     19  O   HIS B 304     -24.477  11.760  60.211  1.00 32.52           O
ATOM     20  CB  HIS B 304     -21.963  10.373  61.537  1.00 28.40           C
ATOM     21  CG  HIS B 304     -20.809   9.431  61.430  1.00 27.87           C
ATOM     22  ND1 HIS B 304     -19.517   9.806  61.733  1.00 36.76           N
ATOM     23  CD2 HIS B 304     -20.737   8.128  61.054  1.00 26.50           C
ATOM     24  CE1 HIS B 304     -18.706   8.776  61.549  1.00 36.85           C
ATOM     25  NE2 HIS B 304     -19.428   7.737  61.176  1.00 27.21           N
ATOM     26  HA  HIS B 304     -22.359  10.653  59.559  1.00 30.53           H
ATOM     27  HB2 HIS B 304     -21.805  10.948  62.303  1.00 34.08           H
ATOM     28  HB3 HIS B 304     -22.764   9.845  61.678  1.00 34.08           H
ATOM     29  HD2 HIS B 304     -21.445   7.599  60.766  1.00 31.79           H
ATOM     30  HE1 HIS B 304     -17.783   8.783  61.663  1.00 44.22           H
ATOM     31  HE2 HIS B 304     -19.128   6.944  61.034  1.00 32.64           H
ATOM     32 HG21 VAL B 315     -20.236   8.723  64.319  1.00 36.99           H
TER
HETATM   33 ZN    ZN A   8       1.797  27.888  76.692  1.00 34.36          Zn
HETATM   34  O   HOH A  57       3.694  28.411  75.816  1.00 39.92           O
HETATM   35  O   HOH A  69       5.784  26.244  75.932  1.00 38.11           O
"""

raw_records91_noh = """\
CRYST1   41.028   41.028  183.010  90.00  90.00  90.00 P 43 21 2
SCALE1      0.024374  0.000000  0.000000        0.00000
SCALE2      0.000000  0.024374  0.000000        0.00000
SCALE3      0.000000  0.000000  0.005464        0.00000
ATOM     16  N   HIS B 304     -20.949  11.990  59.962  1.00 23.21           N
ATOM     17  CA  HIS B 304     -22.165  11.249  60.299  1.00 25.44           C
ATOM     18  C   HIS B 304     -23.349  12.161  60.500  1.00 29.20           C
ATOM     19  O   HIS B 304     -24.477  11.760  60.211  1.00 32.52           O
ATOM     20  CB  HIS B 304     -21.963  10.373  61.537  1.00 28.40           C
ATOM     21  CG  HIS B 304     -20.809   9.431  61.430  1.00 27.87           C
ATOM     22  ND1 HIS B 304     -19.517   9.806  61.733  1.00 36.76           N
ATOM     23  CD2 HIS B 304     -20.737   8.128  61.054  1.00 26.50           C
ATOM     24  CE1 HIS B 304     -18.706   8.776  61.549  1.00 36.85           C
ATOM     25  NE2 HIS B 304     -19.428   7.737  61.176  1.00 27.21           N
TER
HETATM   33 ZN    ZN A   8       1.797  27.888  76.692  1.00 34.36          Zn
HETATM   34  O   HOH A  57       3.694  28.411  75.816  1.00 39.92           O
HETATM   35  O   HOH A  69       5.784  26.244  75.932  1.00 38.11           O
"""


def exercise_remove_bond_restraint_in_place(mon_lib_srv, ener_lib):
  # removing the bond between N and CA, iseqs being (0,1)
  # making sure nothing else changes
  geometry, xrs = make_initial_grm(mon_lib_srv, ener_lib, raw_records4)

  assert geometry.is_bonded_atoms(0,1)
  assert geometry.pair_proxies().bond_proxies.simple.size() == 7
  assert geometry.pair_proxies().bond_proxies.asu.size() == 0
  assert geometry.pair_proxies().nonbonded_proxies.simple.size() == 9
  assert geometry.pair_proxies().nonbonded_proxies.asu.size() == 0
  show_sorted_geometry(geometry, xrs, 'exercise_remove_bond_restraint_in_place_start.geo')

  # Removing
  geometry.remove_bond_restraints_in_place(bonded_pairs=[(0,1)], sites_cart=xrs.sites_cart())

  show_sorted_geometry(geometry, xrs, 'exercise_remove_bond_restraint_in_place_end.geo')
  final_geo = show_sorted_geometry_str(geometry, xrs)

  # Checking
  assert not geometry.is_bonded_atoms(0,1)
  # 1 less bond:
  assert geometry.pair_proxies().bond_proxies.simple.size() == 6, geometry.pair_proxies().bond_proxies.simple.size()
  assert geometry.pair_proxies().bond_proxies.asu.size() == 0, geometry.pair_proxies().bond_proxies.asu.size()
  assert geometry.pair_proxies().nonbonded_proxies.simple.size() == 12, geometry.pair_proxies().nonbonded_proxies.simple.size()
  assert geometry.pair_proxies().nonbonded_proxies.asu.size() == 0, geometry.pair_proxies().nonbonded_proxies.asu.size()
  # Nonbonded - we expect not only additional N-CA, but also
  # N-C as former 1-3 interaction, N-O and N-CB as former 1-4 interactions now.
  # print(final_geo)
  n_pos = final_geo.find("Nonbonded | unspecified")
  assert n_pos>0
  assert not show_diff(final_geo[n_pos:-2], """\
Nonbonded | unspecified | interactions: 12
Sorted by model distance:
nonbonded pdb=" N   MET A   1 "
          pdb=" CA  MET A   1 "
   model   vdw
   1.490 3.550
nonbonded pdb=" N   MET A   1 "
          pdb=" C   MET A   1 "
   model   vdw
   2.459 3.350
nonbonded pdb=" N   MET A   1 "
          pdb=" CB  MET A   1 "
   model   vdw
   2.481 3.520
nonbonded pdb=" N   MET A   1 "
          pdb=" O   MET A   1 "
   model   vdw
   2.666 3.120
nonbonded pdb=" C   MET A   1 "
          pdb=" CG  MET A   1 "
   model   vdw
   2.856 2.936
nonbonded pdb=" N   MET A   1 "
          pdb=" CG  MET A   1 "
   model   vdw
   3.118 3.520
nonbonded pdb=" O   MET A   1 "
          pdb=" CG  MET A   1 "
   model   vdw
   3.367 3.440
nonbonded pdb=" O   MET A   1 "
          pdb=" CB  MET A   1 "
   model   vdw
   3.383 2.752
nonbonded pdb=" CB  MET A   1 "
          pdb=" CE  MET A   1 "
   model   vdw
   3.675 3.088
nonbonded pdb=" CA  MET A   1 "
          pdb=" SD  MET A   1 "
   model   vdw
   4.138 3.064
nonbonded pdb=" C   MET A   1 "
          pdb=" SD  MET A   1 "
   model   vdw
   4.469 3.630
nonbonded pdb=" N   MET A   1 "
          pdb=" SD  MET A   1 "
   model   vdw
   4.798 3.480""")

def exercise_remove_two_bond_restraints_in_place(mon_lib_srv, ener_lib):
  # removing the bond between N and CA, iseqs being (0,1)
  # making sure nothing else changes
  geometry, xrs = make_initial_grm(mon_lib_srv, ener_lib, raw_records4)

  assert geometry.is_bonded_atoms(0,1)
  assert geometry.pair_proxies().bond_proxies.simple.size() == 7
  assert geometry.pair_proxies().bond_proxies.asu.size() == 0
  assert geometry.pair_proxies().nonbonded_proxies.simple.size() == 9
  assert geometry.pair_proxies().nonbonded_proxies.asu.size() == 0
  show_sorted_geometry(geometry, xrs, 'exercise_remove_two_bond_restraints_in_place_start.geo')

  # Removing
  geometry.remove_bond_restraints_in_place(bonded_pairs=[(0,1), (3,2)], sites_cart=xrs.sites_cart())

  show_sorted_geometry(geometry, xrs, 'exercise_remove_two_bond_restraints_in_place_end.geo')
  final_geo = show_sorted_geometry_str(geometry, xrs)
  # print(final_geo)

  # Checking
  assert not geometry.is_bonded_atoms(0,1)
  # 1 less bond:
  assert geometry.pair_proxies().bond_proxies.simple.size() == 5, geometry.pair_proxies().bond_proxies.simple.size()
  assert geometry.pair_proxies().bond_proxies.asu.size() == 0, geometry.pair_proxies().bond_proxies.asu.size()
  assert geometry.pair_proxies().nonbonded_proxies.simple.size() == 14, geometry.pair_proxies().nonbonded_proxies.simple.size()
  assert geometry.pair_proxies().nonbonded_proxies.asu.size() == 0, geometry.pair_proxies().nonbonded_proxies.asu.size()
  # print(final_geo)
  n_pos = final_geo.find("Nonbonded | unspecified")
  assert n_pos>0
  assert not show_diff(final_geo[n_pos:-2], """\
Nonbonded | unspecified | interactions: 14
Sorted by model distance:
nonbonded pdb=" C   MET A   1 "
          pdb=" O   MET A   1 "
   model   vdw
   1.232 3.270
nonbonded pdb=" N   MET A   1 "
          pdb=" CA  MET A   1 "
   model   vdw
   1.490 3.550
nonbonded pdb=" CA  MET A   1 "
          pdb=" O   MET A   1 "
   model   vdw
   2.394 3.470
nonbonded pdb=" N   MET A   1 "
          pdb=" C   MET A   1 "
   model   vdw
   2.459 3.350
nonbonded pdb=" N   MET A   1 "
          pdb=" CB  MET A   1 "
   model   vdw
   2.481 3.520
nonbonded pdb=" N   MET A   1 "
          pdb=" O   MET A   1 "
   model   vdw
   2.666 3.120
nonbonded pdb=" C   MET A   1 "
          pdb=" CG  MET A   1 "
   model   vdw
   2.856 2.936
nonbonded pdb=" N   MET A   1 "
          pdb=" CG  MET A   1 "
   model   vdw
   3.118 3.520
nonbonded pdb=" O   MET A   1 "
          pdb=" CG  MET A   1 "
   model   vdw
   3.367 3.440
nonbonded pdb=" O   MET A   1 "
          pdb=" CB  MET A   1 "
   model   vdw
   3.383 3.440
nonbonded pdb=" CB  MET A   1 "
          pdb=" CE  MET A   1 "
   model   vdw
   3.675 3.088
nonbonded pdb=" CA  MET A   1 "
          pdb=" SD  MET A   1 "
   model   vdw
   4.138 3.064
nonbonded pdb=" C   MET A   1 "
          pdb=" SD  MET A   1 "
   model   vdw
   4.469 3.630
nonbonded pdb=" N   MET A   1 "
          pdb=" SD  MET A   1 "
   model   vdw
   4.798 3.480""")

def exercise_consistency_between_getting_grm(mon_lib_srv, ener_lib):
  simple_grm, simple_xrs = make_initial_grm(mon_lib_srv, ener_lib, raw_records91_noh)
  simple_geo_str = show_sorted_geometry_str(simple_grm, simple_xrs)

  params = mmtbx.model.manager.get_default_pdb_interpretation_params()
  # params.pdb_interpretation.restraints_library.mcl=False
  # params.pdb_interpretation.use_neutron_distances=False
  model_grm, model_xrs = make_grm_via_model(mon_lib_srv, ener_lib, raw_records91_noh, params)
  model_geo_str = show_sorted_geometry_str(model_grm, model_xrs)
  # print(model_geo_str)
  assert not show_diff(simple_geo_str, model_geo_str)

def exercise_bond_in_symmetry_grm(mon_lib_srv, ener_lib):
  """ There is symmetry bond in GRM, but we removing non-symmetry one.

  Args:
      mon_lib_srv (_type_): _description_
      ener_lib (_type_): _description_
  """
  params = mmtbx.model.manager.get_default_pdb_interpretation_params()
  grm, xrs = make_grm_via_model(mon_lib_srv, ener_lib, raw_records91_noh, params)
  simple, asu = grm.get_all_bond_proxies()
  assert (simple.size(), asu.size()) == (10, 2), (simple.size(), asu.size())
  sites_cart = xrs.sites_cart()
  initial_geo = show_sorted_geometry_str(grm, xrs)

  # Now we are removing the bonds one by one
  assert grm.is_bonded_atoms(0,1)
  grm.remove_bond_restraints_in_place(bonded_pairs=[(0,1)], sites_cart=sites_cart)
  assert not grm.is_bonded_atoms(0,1)
  simple, asu = grm.get_all_bond_proxies()
  assert (simple.size(), asu.size()) == (9, 2), (simple.size(), asu.size())

  final_geo = show_sorted_geometry_str(grm, xrs)
  # print(final_geo)
  # STOP()
  n_pos = final_geo.find("Nonbonded | unspecified | interactions: 38")
  assert n_pos>0

  diff_out = StringIO()
  show_diff(final_geo, initial_geo, out=diff_out)
  diff_gv = diff_out.getvalue()
  # print("*"*80)
  # print(diff_gv)
  # STOP()
  assert not show_diff(diff_gv,"""\
---
+++
@@ -1,4 +1,4 @@
-Bond | covalent geometry | restraints: 10
+Bond | covalent geometry | restraints: 9
 Sorted by residual:
 bond pdb=" CA  HIS B 304 "
      pdb=" C   HIS B 304 "
@@ -12,10 +12,6 @@
      pdb=" CE1 HIS B 304 "
   ideal  model  delta    sigma   weight residual
   1.321  1.324 -0.003 1.00e-02 1.00e+04 7.90e-02
-bond pdb=" N   HIS B 304 "
-     pdb=" CA  HIS B 304 "
-  ideal  model  delta    sigma   weight residual
-  1.458  1.463 -0.005 1.90e-02 2.77e+03 7.84e-02
 bond pdb=" CB  HIS B 304 "
      pdb=" CG  HIS B 304 "
   ideal  model  delta    sigma   weight residual
@@ -166,12 +162,24 @@
       pdb=" CE1 HIS B 304 "   -0.009 2.00e-02 2.50e+03
       pdb=" NE2 HIS B 304 "    0.020 2.00e-02 2.50e+03

-Nonbonded | unspecified | interactions: 35
+Nonbonded | unspecified | interactions: 38
 Sorted by model distance:
+nonbonded pdb=" N   HIS B 304 "
+          pdb=" CA  HIS B 304 "
+   model   vdw
+   1.463 3.550
 nonbonded pdb="ZN    ZN A   8 "
           pdb=" O   HOH A  57 "
    model   vdw
    2.154 2.230
+nonbonded pdb=" N   HIS B 304 "
+          pdb=" C   HIS B 304 "
+   model   vdw
+   2.465 3.350
+nonbonded pdb=" N   HIS B 304 "
+          pdb=" CB  HIS B 304 "
+   model   vdw
+   2.475 3.520
 nonbonded pdb=" CG  HIS B 304 "
           pdb="ZN    ZN A   8 "
    model   vdw sym.op.
@@ -179,7 +187,7 @@
 nonbonded pdb=" N   HIS B 304 "
           pdb=" CG  HIS B 304 "
    model   vdw
-   2.953 2.672
+   2.953 3.340
 nonbonded pdb=" O   HOH A  57 "
           pdb=" O   HOH A  69 "
    model   vdw
@@ -215,7 +223,7 @@
 nonbonded pdb=" N   HIS B 304 "
           pdb=" O   HIS B 304 "
    model   vdw
-   3.544 2.496
+   3.544 3.120
 nonbonded pdb=" CB  HIS B 304 "
           pdb=" CE1 HIS B 304 "
    model   vdw

""", strip_trailing_whitespace=True)


def exercise_bond_over_symmetry_2(mon_lib_srv, ener_lib):
  """ There is symmetry bond in GRM, but we remove it.
  Making sure that GRM build without it is identical to the one with it.
  Bond does not include angles.

  Args:
      mon_lib_srv (_type_): _description_
      ener_lib (_type_): _description_
  """
  params = mmtbx.model.manager.get_default_pdb_interpretation_params()
  grm, xrs = make_grm_via_model(mon_lib_srv, ener_lib, raw_records91_noh, params)
  initial_geo_str = show_sorted_geometry_str(grm, xrs)
  simple, asu = grm.get_all_bond_proxies()
  assert (simple.size(), asu.size()) == (10, 2), (simple.size(), asu.size())
  # print('before', simple.size(), asu.size())
  sites_cart = xrs.sites_cart()

  # Now we are removing the bonds one by one
  assert grm.is_bonded_atoms(9,10)
  grm.remove_bond_restraints_in_place(bonded_pairs=[(9,10)], sites_cart=sites_cart)
  assert not grm.is_bonded_atoms(9,10)
  simple, asu = grm.get_all_bond_proxies()
  assert (simple.size(), asu.size()) == (10, 0), (simple.size(), asu.size())

  # print('after', simple.size(), asu.size())
  after_geo_str = show_sorted_geometry_str(grm, xrs)
  # print(after_geo_str)

  # Here we creating GRM without the Zn -- NE2 bond
  params = mmtbx.model.manager.get_default_pdb_interpretation_params()
  params.pdb_interpretation.restraints_library.mcl=False
  nobond_grm, xrs = make_grm_via_model(mon_lib_srv, ener_lib, raw_records91_noh, params)
  simple, asu = nobond_grm.get_all_bond_proxies()
  assert (simple.size(), asu.size()) == (10, 0), (simple.size(), asu.size())
  nobond_geo_str = show_sorted_geometry_str(nobond_grm, xrs)
  assert not show_diff(after_geo_str, nobond_geo_str)

def exercise_bond_with_self(mon_lib_srv, ener_lib):
  """Shell_sym_table has the following in this case:
i_seq: 12
  j_seq: 12
    -x-1,z,y
  """
  params = mmtbx.model.manager.get_default_pdb_interpretation_params()
  grm, xrs = make_grm_via_model(mon_lib_srv, ener_lib, raw_records1, params)
  sites_cart = xrs.sites_cart()
  initial_geo_str = show_sorted_geometry_str(grm, xrs)
  # with open("exercise_bond_with_self_initial.geo", 'w') as f:
  #   f.write(initial_geo_str)
  # print(initial_geo_str)
  assert_lines_in_text(initial_geo_str,"""\
Bond | Disulphide bridge | restraints: 1
Sorted by residual:
bond pdb=" SG  CYS A   2 "
     pdb=" SG  CYS A   2 "
  ideal  model  delta    sigma   weight residual sym.op.
  2.031  2.028  0.003 2.00e-02 2.50e+03 2.48e-02 -x-1,z,y
""")
  simple, asu = grm.get_all_bond_proxies()
  assert (simple.size(), asu.size()) == (23, 1), (simple.size(), asu.size())
  assert grm.is_bonded_atoms(12,12)
  grm.remove_bond_restraints_in_place(bonded_pairs=[(12,12)], sites_cart=sites_cart)
  assert not grm.is_bonded_atoms(12,12)
  simple, asu = grm.get_all_bond_proxies()
  assert (simple.size(), asu.size()) == (23, 0), (simple.size(), asu.size())
  after_geo_str = show_sorted_geometry_str(grm, xrs)
  # with open("exercise_bond_with_self_after.geo", 'w') as f:
  #   f.write(after_geo_str)
  diff_out = StringIO()
  show_diff(after_geo_str, initial_geo_str, out=diff_out)
  diff_gv = diff_out.getvalue()
  # print("*"*80)
  # print(diff_gv)
  # STOP()
  assert_lines_in_text (diff_gv,"""\
-
-Bond | Disulphide bridge | restraints: 1
-Sorted by residual:
-bond pdb=" SG  CYS A   2 "
-     pdb=" SG  CYS A   2 "
-  ideal  model  delta    sigma   weight residual sym.op.
-  2.031  2.028  0.003 2.00e-02 2.50e+03 2.48e-02 -x-1,z,y
""")
  assert_lines_in_text(diff_gv, """\
-Nonbonded | unspecified | interactions: 80
+Nonbonded | unspecified | interactions: 83
 Sorted by model distance:
+nonbonded pdb=" SG  CYS A   2 "
+          pdb=" SG  CYS A   2 "
+   model   vdw sym.op.
+   2.028 3.760 -x-1,z,y
""")

  assert_lines_in_text(diff_gv, """\
+nonbonded pdb=" CB  CYS A   2 "
+          pdb=" SG  CYS A   2 "
+   model   vdw sym.op.
+   2.753 3.800 -x-1,z,y
""")
  assert_lines_in_text(diff_gv, """\
+nonbonded pdb=" SG  CYS A   2 "
+          pdb=" CB  CYS A   2 "
+   model   vdw sym.op.
+   2.753 3.800 -x-1,z,y
""")

def exercise_on_special_position(mon_lib_srv, ener_lib):
  """
  Looks like special position is not different from no symmetry case.
  """
  params = mmtbx.model.manager.get_default_pdb_interpretation_params()
  params.pdb_interpretation.automatic_linking.link_all=True
  grm, xrs = make_grm_via_model(mon_lib_srv, ener_lib, raw_records2, params)
  sites_cart = xrs.sites_cart()
  initial_geo_str = show_sorted_geometry_str(grm, xrs)
  # with open("exercise_bond_with_self_initial.geo", 'w') as f:
  #   f.write(initial_geo_str)
  # print(initial_geo_str)
  simple, asu = grm.get_all_bond_proxies()
  assert (simple.size(), asu.size()) == (12, 0), (simple.size(), asu.size())
  assert grm.is_bonded_atoms(9,10)
  assert grm.is_bonded_atoms(10,11)
  grm.remove_bond_restraints_in_place(bonded_pairs=[(9,10), (10,11)], sites_cart=sites_cart)
  assert not grm.is_bonded_atoms(9,10)
  assert not grm.is_bonded_atoms(10,11)
  after_geo_str = show_sorted_geometry_str(grm, xrs)
  # print(final_geo_str)
  diff_out = StringIO()
  show_diff(after_geo_str, initial_geo_str, out=diff_out)
  diff_gv = diff_out.getvalue()
  # print("*"*80)
  # print(diff_gv)
  # STOP()
  assert_lines_in_text(diff_gv,"""\
---
+++
@@ -40,17 +40,6 @@
      pdb=" CE1 HIS D  10 "
   ideal  model  delta    sigma   weight residual
   1.321  1.321  0.000 1.00e-02 1.00e+04 3.82e-04
-
-Bond | Metal coordination | restraints: 2
-Sorted by residual:
-bond pdb="CO    CO D 101 "
-     pdb=" O   HOH D 208 "
-  ideal  model  delta    sigma   weight residual
-  2.090  2.429 -0.339 1.00e-01 1.00e+02 1.15e+01
-bond pdb=" NE2 HIS D  10 "
-     pdb="CO    CO D 101 "
-  ideal  model  delta    sigma   weight residual
-  2.140  2.155 -0.015 1.00e-01 1.00e+02 2.21e-02

 Bond angle | covalent geometry | restraints: 12
 Sorted by residual:
@@ -166,7 +155,7 @@
       pdb=" CE1 HIS D  10 "   -0.005 2.00e-02 2.50e+03
       pdb=" NE2 HIS D  10 "    0.009 2.00e-02 2.50e+03

-Nonbonded | unspecified | interactions: 81
+Nonbonded | unspecified | interactions: 86
""")

def exercise_remove_ss(mon_lib_srv, ener_lib):
  file_path = libtbx.env.find_in_repositories(
    relative_path="phenix_regression/pdb/10mh_helix_sheet_na.pdb",
    test=os.path.isfile)
  if (file_path is None):
    print("Skipping exercise_remove_ss: input file not available")
    return
  with open(file_path, 'r') as f:
    raw_records=f.readlines()

  params = mmtbx.model.manager.get_default_pdb_interpretation_params()
  params.pdb_interpretation.secondary_structure.enabled=True
  params.pdb_interpretation.secondary_structure.nucleic_acid.base_pair[0].restrain_planarity=True
  grm, xrs = make_grm_via_model(mon_lib_srv, ener_lib, raw_records, params)
  sites_cart = xrs.sites_cart()
  initial_geo_str = show_sorted_geometry_str(grm, xrs)
  # with open('start_exercise_remove_ss.geo', 'w') as f:
  #   f.write(initial_geo_str)
  assert_lines_in_text(initial_geo_str, "Bond | Bond-like | restraints: 90")
  assert_lines_in_text(initial_geo_str, "Bond angle | Secondary Structure restraints around h-bond | restraints: 190")
  assert_lines_in_text(initial_geo_str, "Parallelity | Stacking parallelity | restraints: 16")
  assert_lines_in_text(initial_geo_str, "Planarity | Basepair planarity | restraints: 10")

  grm.remove_secondary_structure_restraints(sites_cart=sites_cart)
  end_geo_str = show_sorted_geometry_str(grm, xrs)
  # with open('end_exercise_remove_ss.geo', 'w') as f:
  #   f.write(end_geo_str)
  diff_out = StringIO()
  show_diff(end_geo_str, initial_geo_str, out=diff_out)
  diff_gv = diff_out.getvalue()
  assert_lines_in_text(diff_gv, "-Bond | Bond-like | restraints: 90")
  assert_lines_in_text(diff_gv, "-Bond angle | Secondary Structure restraints around h-bond | restraints: 190")
  assert_lines_in_text(diff_gv, "-Parallelity | Stacking parallelity | restraints: 16")
  assert_lines_in_text(diff_gv, "-Planarity | Basepair planarity | restraints: 10")


def exercise():
  mon_lib_srv = None
  ener_lib = None
  try:
    mon_lib_srv = monomer_library.server.server()
    ener_lib = monomer_library.server.ener_lib()
  except: # intentional
    print("Can not initialize monomer_library, skipping test.")
  if mon_lib_srv is not None and ener_lib is not None:
    exercise_consistency_between_getting_grm(mon_lib_srv, ener_lib)
    exercise_remove_bond_restraint_in_place(mon_lib_srv, ener_lib)
    exercise_remove_two_bond_restraints_in_place(mon_lib_srv, ener_lib)
    exercise_bond_in_symmetry_grm(mon_lib_srv, ener_lib)
    exercise_bond_over_symmetry_2(mon_lib_srv, ener_lib)
    exercise_bond_with_self(mon_lib_srv, ener_lib)
    exercise_on_special_position(mon_lib_srv, ener_lib)
    exercise_remove_ss(mon_lib_srv, ener_lib)

if (__name__ == "__main__"):
  exercise()
  print("OK")


 *******************************************************************************


 *******************************************************************************
cctbx/regression/tst_grm_pickling.py
from __future__ import absolute_import, division, print_function

from mmtbx import monomer_library
import mmtbx.monomer_library.server
import mmtbx.monomer_library.pdb_interpretation
import sys
try:
  from six.moves import cPickle as pickle
except ImportError:
  import pickle
from six.moves import cStringIO as StringIO
from libtbx.test_utils import show_diff
import iotbx.pdb
from libtbx.utils import null_out # import dependency
from time import time
from libtbx.test_utils import approx_equal


raw_records1 = """\
CRYST1   60.800   60.800   97.000  90.00  90.00 120.00 P 32 2 1      6
ORIGX1      1.000000  0.000000  0.000000        0.00000
ORIGX2      0.000000  1.000000  0.000000        0.00000
ORIGX3      0.000000  0.000000  1.000000        0.00000
SCALE1      0.016447  0.009496  0.000000        0.00000
SCALE2      0.000000  0.018992  0.000000        0.00000
SCALE3      0.000000  0.000000  0.010309        0.00000
ATOM   1050  N   LYS A 135      31.992  14.930  -7.233  1.00  9.47           N
ATOM   1051  CA  LYS A 135      31.388  16.216  -7.637  1.00 12.89           C
ATOM   1052  C   LYS A 135      30.807  16.840  -6.406  1.00  6.47           C
ATOM   1053  O   LYS A 135      29.583  16.869  -6.191  1.00 15.74           O
ATOM   1054  CB  LYS A 135      30.263  16.059  -8.655  1.00 13.51           C
ATOM   1055  CG  LYS A 135      30.742  15.277  -9.843  1.00 16.23           C
ATOM   1056  CD  LYS A 135      29.612  15.131 -10.835  1.00 28.55           C
ATOM   1057  CE  LYS A 135      30.173  14.812 -12.216  1.00 34.52           C
ATOM   1058  NZ  LYS A 135      29.396  13.756 -12.899  1.00 46.18           N
TER    1294      LYS A 162
END
"""

raw_records2 = """\
CRYST1   24.627   42.717   46.906  90.00  90.00  90.00 P 21 21 21    8
ATOM    184  P    DG A   9       9.587  13.026  19.037  1.00  6.28           P
ATOM    185  OP1  DG A   9       9.944  14.347  19.602  1.00  8.07           O
ATOM    186  OP2  DG A   9      10.654  12.085  18.639  1.00  8.27           O
ATOM    187  O5'  DG A   9       8.717  12.191  20.048  1.00  5.88           O
ATOM    188  C5'  DG A   9       7.723  12.833  20.854  1.00  5.45           C
ATOM    189  C4'  DG A   9       7.145  11.818  21.807  1.00  5.40           C
ATOM    190  O4'  DG A   9       6.435  10.777  21.087  1.00  5.77           O
ATOM    191  C3'  DG A   9       8.142  11.036  22.648  1.00  5.10           C
ATOM    192  O3'  DG A   9       8.612  11.838  23.723  1.00  5.90           O
ATOM    193  C2'  DG A   9       7.300   9.857  23.068  1.00  5.97           C
ATOM    194  C1'  DG A   9       6.619   9.536  21.805  1.00  5.97           C
ATOM    195  N9   DG A   9       7.390   8.643  20.931  1.00  5.97           N
ATOM    196  C8   DG A   9       8.074   8.881  19.775  1.00  6.62           C
ATOM    197  N7   DG A   9       8.647   7.820  19.249  1.00  6.57           N
ATOM    198  C5   DG A   9       8.308   6.806  20.141  1.00  6.22           C
ATOM    199  C6   DG A   9       8.620   5.431  20.136  1.00  6.03           C
ATOM    200  O6   DG A   9       9.297   4.803  19.296  1.00  7.21           O
ATOM    201  N1   DG A   9       8.101   4.773  21.247  1.00  6.10           N
ATOM    202  C2   DG A   9       7.365   5.351  22.260  1.00  6.24           C
ATOM    203  N2   DG A   9       6.948   4.569  23.241  1.00  7.88           N
ATOM    204  N3   DG A   9       7.051   6.652  22.257  1.00  6.53           N
ATOM    205  C4   DG A   9       7.539   7.295  21.184  1.00  5.69           C
ATOM    206  P    DC A  10      10.081  11.538  24.300  1.00  5.91           P
ATOM    207  OP1  DC A  10      10.273  12.645  25.291  1.00  7.27           O
ATOM    208  OP2  DC A  10      11.063  11.363  23.228  1.00  6.84           O
ATOM    209  O5'  DC A  10       9.953  10.128  25.026  1.00  5.75           O
ATOM    210  C5'  DC A  10       9.077   9.959  26.149  1.00  5.87           C
ATOM    211  C4'  DC A  10       9.188   8.549  26.672  1.00  5.56           C
ATOM    212  O4'  DC A  10       8.708   7.612  25.667  1.00  5.70           O
ATOM    213  C3'  DC A  10      10.580   8.059  27.007  1.00  5.27           C
ATOM    214  O3'  DC A  10      11.010   8.447  28.315  1.00  5.83           O
ATOM    215  C2'  DC A  10      10.422   6.549  26.893  1.00  5.34           C
ATOM    216  C1'  DC A  10       9.436   6.405  25.754  1.00  5.23           C
ATOM    217  N1   DC A  10      10.113   6.168  24.448  1.00  5.30           N
ATOM    218  C2   DC A  10      10.514   4.871  24.152  1.00  5.28           C
ATOM    219  O2   DC A  10      10.283   3.972  25.000  1.00  5.75           O
ATOM    220  N3   DC A  10      11.131   4.627  22.965  1.00  5.65           N
ATOM    221  C4   DC A  10      11.395   5.628  22.138  1.00  5.80           C
ATOM    222  N4   DC A  10      12.034   5.327  21.005  1.00  6.75           N
ATOM    223  C5   DC A  10      11.029   6.970  22.449  1.00  5.99           C
ATOM    224  C6   DC A  10      10.394   7.203  23.612  1.00  5.56           C
ATOM    226  O5'  DG B  11      12.424  -4.393  18.427  1.00 22.70           O
ATOM    227  C5'  DG B  11      12.380  -5.516  19.282  1.00 14.75           C
ATOM    228  C4'  DG B  11      11.969  -5.112  20.676  1.00 10.42           C
ATOM    229  O4'  DG B  11      12.972  -4.192  21.210  1.00 10.51           O
ATOM    230  C3'  DG B  11      10.649  -4.394  20.782  1.00  8.57           C
ATOM    231  O3'  DG B  11       9.618  -5.363  20.846  1.00  8.69           O
ATOM    232  C2'  DG B  11      10.822  -3.597  22.051  1.00  8.63           C
ATOM    233  C1'  DG B  11      12.236  -3.233  21.980  1.00  9.81           C
ATOM    234  N9   DG B  11      12.509  -1.902  21.305  1.00  8.66           N
ATOM    235  C8   DG B  11      13.175  -1.667  20.135  1.00  9.57           C
ATOM    236  N7   DG B  11      13.255  -0.407  19.824  1.00  9.04           N
ATOM    237  C5   DG B  11      12.613   0.235  20.869  1.00  7.63           C
ATOM    238  C6   DG B  11      12.388   1.612  21.119  1.00  7.05           C
ATOM    239  O6   DG B  11      12.723   2.590  20.419  1.00  7.81           O
ATOM    240  N1   DG B  11      11.715   1.819  22.317  1.00  6.27           N
ATOM    241  C2   DG B  11      11.264   0.828  23.159  1.00  6.05           C
ATOM    242  N2   DG B  11      10.611   1.219  24.248  1.00  5.85           N
ATOM    243  N3   DG B  11      11.483  -0.457  22.942  1.00  6.55           N
ATOM    244  C4   DG B  11      12.150  -0.687  21.797  1.00  6.84           C
ATOM    245  P    DC B  12       8.134  -5.009  20.350  1.00  8.13           P
ATOM    246  OP1  DC B  12       7.367  -6.252  20.459  1.00 10.02           O
ATOM    247  OP2  DC B  12       8.172  -4.307  19.052  1.00  9.79           O
ATOM    248  O5'  DC B  12       7.564  -3.912  21.389  1.00  8.18           O
ATOM    249  C5'  DC B  12       7.275  -4.296  22.719  1.00  8.00           C
ATOM    250  C4'  DC B  12       6.856  -3.057  23.487  1.00  8.01           C
ATOM    251  O4'  DC B  12       8.006  -2.146  23.615  1.00  7.35           O
ATOM    252  C3'  DC B  12       5.763  -2.208  22.890  1.00  7.04           C
ATOM    253  O3'  DC B  12       4.456  -2.800  23.100  1.00  9.82           O
ATOM    254  C2'  DC B  12       6.019  -0.916  23.630  1.00  6.50           C
ATOM    255  C1'  DC B  12       7.467  -0.808  23.608  1.00  7.35           C
ATOM    256  N1   DC B  12       8.040  -0.143  22.396  1.00  6.64           N
ATOM    257  C2   DC B  12       8.017   1.257  22.382  1.00  5.68           C
ATOM    258  O2   DC B  12       7.524   1.832  23.357  1.00  6.32           O
ATOM    259  N3   DC B  12       8.543   1.930  21.312  1.00  6.18           N
ATOM    260  C4   DC B  12       9.009   1.236  20.266  1.00  6.48           C
ATOM    261  N4   DC B  12       9.518   1.926  19.243  1.00  7.43           N
ATOM    262  C5   DC B  12       9.012  -0.198  20.248  1.00  6.83           C
ATOM    263  C6   DC B  12       8.502  -0.825  21.311  1.00  6.80           C
"""

raw_records3 = """\
CRYST1   10.000   10.000   10.000  90.00  90.00  90.00 P 1           1
ATOM      1  N   ALA A   2      -7.656   2.923   3.155  1.00 15.02           N
ATOM      2  CA  ALA A   2      -6.522   2.038   2.831  1.00 14.10           C
ATOM      3  C   ALA A   2      -5.241   2.537   3.427  1.00 13.13           C
ATOM      4  O   ALA A   2      -4.978   3.742   3.426  1.00 11.91           O
ATOM      5  CB  ALA A   2      -6.346   1.881   1.341  1.00 15.38           C
ATOM      7  N   ALA A   3      -4.438   1.590   3.905  1.00 12.26           N
ATOM      8  CA  ALA A   3      -3.193   1.904   4.589  1.00 11.74           C
ATOM      9  C   ALA A   3      -1.955   1.332   3.895  1.00 11.10           C
ATOM     10  O   ALA A   3      -1.872   0.119   3.648  1.00 10.42           O
ATOM     11  CB  ALA A   3      -3.259   1.378   6.042  1.00 12.15           C
ATOM     13  N   ALA A   4      -1.005   2.228   3.598  1.00 10.29           N
ATOM     14  CA  ALA A   4       0.384   1.888   3.199  1.00 10.53           C
ATOM     15  C   ALA A   4       1.435   2.606   4.088  1.00 10.24           C
ATOM     16  O   ALA A   4       1.547   3.843   4.115  1.00  8.86           O
ATOM     17  CB  ALA A   4       0.656   2.148   1.711  1.00  9.80           C
END
"""

def make_initial_grm(mon_lib_srv, ener_lib, records):
  processed_pdb_file = monomer_library.pdb_interpretation.process(
    mon_lib_srv    = mon_lib_srv,
    ener_lib       = ener_lib,
    raw_records    = records,
    force_symmetry = True)

  geometry = processed_pdb_file.geometry_restraints_manager(
    show_energies      = True,
    plain_pairs_radius = 5.0)
  xrs = processed_pdb_file.xray_structure()
  return geometry, xrs

def make_geo_pickle_unpickle(geometry, xrs, prefix):
  init_out = StringIO()
  from_file_out = StringIO()
  geometry.show_sorted(
      sites_cart=xrs.sites_cart(),
      site_labels=xrs.scatterers().extract_labels(),
      f=init_out)
  energy_original = geometry.energies_sites(sites_cart=xrs.sites_cart())
  t0 = time()
  #import code, traceback; code.interact(local=locals(), banner="".join( traceback.format_stack(limit=10) ) )
  pklstr = pickle.dumps(geometry)
  t1 = time()
  grm_from_file = pickle.loads(pklstr)
  t2 = time()
  # Fails here:
  energy_from_pickle = grm_from_file.energies_sites(sites_cart=xrs.sites_cart())
  assert approx_equal(energy_original.target, energy_from_pickle.target)
  print("Time pickling/unpickling: %.4f, %.4f" % (t1-t0, t2-t1))
  grm_from_file.show_sorted(
      sites_cart=xrs.sites_cart(),
      site_labels=xrs.scatterers().extract_labels(),
      f=from_file_out)
  # print "INITIAL"
  init_v = init_out.getvalue()
  # print init_v
  # print "="*50
  # print "From disc"
  from_file_v = from_file_out.getvalue()
  # print from_file_v
  # STOP()
  assert not show_diff(init_v, from_file_v)
  return grm_from_file

def test_simple_protein(
    mon_lib_srv, ener_lib, prefix="tst_grm_pickling_simple_protein"):
  geometry, xrs = make_initial_grm(mon_lib_srv, ener_lib, raw_records1)
  make_geo_pickle_unpickle(geometry, xrs, prefix)

def test_nucleic_acid(mon_lib_srv, ener_lib, prefix="tst_grm_pickling_na"):
  with open("%s.pdb" % prefix, "w") as f:
    f.write(raw_records2)
  from mmtbx import monomer_library
  params = monomer_library.pdb_interpretation.master_params.extract()
  params.secondary_structure.enabled=True
  processed_pdb_file = monomer_library.pdb_interpretation.run(
    args=["%s.pdb" % prefix],
    params=params,
    strict_conflict_handling=False,
    log=sys.stdout)
  geo = processed_pdb_file.geometry_restraints_manager()
  assert geo.get_n_hbond_proxies() == 6
  assert geo.get_n_hangle_proxies() == 12
  assert geo.get_n_stacking_proxies() == 2
  assert geo.get_n_parallelity_bp_proxies() == 2
  make_geo_pickle_unpickle(geo, processed_pdb_file.xray_structure(), prefix)

def test_ramachandran(mon_lib_srv, ener_lib, prefix="tst_grm_pickling_rama"):
  with open("%s.pdb" % prefix, "w") as f:
    f.write(raw_records3)
  from mmtbx import monomer_library
  params = monomer_library.pdb_interpretation.master_params.extract()
  params.peptide_link.ramachandran_restraints=True
  processed_pdb_file = monomer_library.pdb_interpretation.run(
    args=["%s.pdb" % prefix],
    params=params,
    strict_conflict_handling=False,
    log=sys.stdout)
  geo = processed_pdb_file.geometry_restraints_manager()
  assert geo.get_n_ramachandran_proxies() == 1
  make_geo_pickle_unpickle(geo, processed_pdb_file.xray_structure(), prefix)

def test_cbeta(mon_lib_srv, ener_lib, prefix="tst_grm_pickling_cbeta"):
  with open("%s.pdb" % prefix, "w") as f:
    f.write(raw_records3)
  from mmtbx import monomer_library
  params = monomer_library.pdb_interpretation.master_params.extract()
  params.c_beta_restraints=True
  processed_pdb_file = monomer_library.pdb_interpretation.run(
    args=["%s.pdb" % prefix],
    params=params,
    strict_conflict_handling=False,
    log=sys.stdout)
  geo = processed_pdb_file.geometry_restraints_manager()
  assert geo.get_n_c_beta_torsion_proxies() == 6
  make_geo_pickle_unpickle(geo, processed_pdb_file.xray_structure(), prefix)

def test_reference_coordinate(mon_lib_srv, ener_lib, prefix="tst_grm_pickling_ref_coor"):
  from mmtbx.geometry_restraints import reference
  # for some strange reason without importing this the code doesn't work...
  from cctbx import adp_restraints # import dependency

  pdb_inp = iotbx.pdb.input(source_info=None, lines=raw_records3)
  params = monomer_library.pdb_interpretation.master_params.extract()
  params.reference_coordinate_restraints.enabled=False
  processed_pdb_file = monomer_library.pdb_interpretation.process(
    mon_lib_srv=mon_lib_srv,
    ener_lib=ener_lib,
    params=params,
    strict_conflict_handling=False,
    pdb_inp=pdb_inp,
    log=sys.stdout)
  geo = processed_pdb_file.geometry_restraints_manager()
  pdb_hierarchy = processed_pdb_file.all_chain_proxies.pdb_hierarchy
  sites_cart = pdb_hierarchy.atoms().extract_xyz()
  rcp = reference.add_coordinate_restraints(sites_cart=sites_cart)
  geo.adopt_reference_coordinate_restraints_in_place(rcp)
  # print "number of rcr proxies:", geo.get_n_reference_coordinate_proxies()
  make_geo_pickle_unpickle(geo, processed_pdb_file.xray_structure(), prefix)

def test_secondary_structure(mon_lib_srv, ener_lib, prefix="tst_grm_pickling_ss"):
  pdb_str = """
HELIX    2   2 ASP A   37  GLY A   48  1                                  12
CRYST1  113.068  113.068   53.292  90.00  90.00  90.00 I 41          8
ATOM    266  N   ASP A  37       6.265  61.752  14.145  1.00 35.17           N
ATOM    267  CA  ASP A  37       5.251  62.335  15.056  1.00 37.08           C
ATOM    268  C   ASP A  37       5.433  61.900  16.511  1.00 37.79           C
ATOM    269  O   ASP A  37       6.443  61.316  16.858  1.00 37.54           O
ATOM    270  CB  ASP A  37       3.827  62.120  14.521  1.00 37.53           C
ATOM    271  CG  ASP A  37       3.427  60.683  14.400  1.00 38.76           C
ATOM    272  OD1 ASP A  37       4.001  59.819  15.070  1.00 38.84           O
ATOM    273  OD2 ASP A  37       2.506  60.327  13.624  1.00 41.78           O
ATOM    274  N   ASP A  38       4.467  62.205  17.382  1.00 38.31           N
ATOM    275  CA  ASP A  38       4.609  61.829  18.786  1.00 38.69           C
ATOM    276  C   ASP A  38       4.781  60.335  18.955  1.00 37.78           C
ATOM    277  O   ASP A  38       5.598  59.886  19.760  1.00 38.31           O
ATOM    278  CB  ASP A  38       3.376  62.258  19.608  1.00 39.51           C
ATOM    279  CG  ASP A  38       3.378  63.724  19.972  1.00 42.76           C
ATOM    280  OD1 ASP A  38       4.462  64.343  20.161  1.00 48.07           O
ATOM    281  OD2 ASP A  38       2.295  64.337  20.144  1.00 47.65           O
ATOM    282  N   ALA A  39       4.003  59.561  18.209  1.00 36.68           N
ATOM    283  CA  ALA A  39       4.065  58.107  18.287  1.00 36.58           C
ATOM    284  C   ALA A  39       5.433  57.607  17.773  1.00 35.91           C
ATOM    285  O   ALA A  39       6.014  56.661  18.319  1.00 35.28           O
ATOM    286  CB  ALA A  39       2.947  57.491  17.483  1.00 36.33           C
ATOM    287  N   GLY A  40       5.948  58.257  16.745  1.00 35.33           N
ATOM    288  CA  GLY A  40       7.296  57.938  16.267  1.00 35.20           C
ATOM    289  C   GLY A  40       8.386  58.218  17.295  1.00 34.81           C
ATOM    290  O   GLY A  40       9.320  57.432  17.456  1.00 34.92           O
ATOM    291  N   ARG A  41       8.297  59.351  17.981  1.00 35.65           N
ATOM    292  CA  ARG A  41       9.300  59.698  18.970  1.00 35.75           C
ATOM    293  C   ARG A  41       9.257  58.681  20.093  1.00 37.10           C
ATOM    294  O   ARG A  41      10.295  58.291  20.642  1.00 37.65           O
ATOM    295  CB  ARG A  41       9.090  61.118  19.494  1.00 36.15           C
ATOM    296  CG  ARG A  41       9.575  62.196  18.563  1.00 35.51           C
ATOM    297  CD  ARG A  41       9.383  63.592  19.134  1.00 38.98           C
ATOM    298  NE  ARG A  41       7.999  64.012  18.913  1.00 40.46           N
ATOM    299  CZ  ARG A  41       7.537  64.446  17.753  1.00 41.44           C
ATOM    300  NH1 ARG A  41       8.326  64.534  16.682  1.00 42.62           N
ATOM    301  NH2 ARG A  41       6.261  64.776  17.649  1.00 43.05           N
ATOM    302  N   ALA A  42       8.053  58.238  20.441  1.00 38.18           N
ATOM    303  CA  ALA A  42       7.878  57.270  21.524  1.00 38.42           C
ATOM    304  C   ALA A  42       8.398  55.909  21.116  1.00 38.32           C
ATOM    305  O   ALA A  42       8.952  55.181  21.927  1.00 37.15           O
ATOM    306  CB  ALA A  42       6.387  57.158  21.948  1.00 38.91           C
ATOM    307  N   THR A  43       8.209  55.567  19.842  1.00 37.57           N
ATOM    308  CA  THR A  43       8.756  54.324  19.328  1.00 37.21           C
ATOM    309  C   THR A  43      10.284  54.321  19.472  1.00 36.33           C
ATOM    310  O   THR A  43      10.842  53.315  19.824  1.00 36.44           O
ATOM    311  CB  THR A  43       8.316  54.130  17.873  1.00 37.54           C
ATOM    312  OG1 THR A  43       6.890  53.948  17.829  1.00 38.41           O
ATOM    313  CG2 THR A  43       8.897  52.837  17.280  1.00 36.05           C
ATOM    314  N   LEU A  44      10.948  55.436  19.192  1.00 36.74           N
ATOM    315  CA  LEU A  44      12.410  55.504  19.283  1.00 36.66           C
ATOM    316  C   LEU A  44      12.877  55.316  20.729  1.00 37.24           C
ATOM    317  O   LEU A  44      13.840  54.613  20.978  1.00 36.26           O
ATOM    318  CB  LEU A  44      12.957  56.819  18.725  1.00 36.22           C
ATOM    319  CG  LEU A  44      12.786  57.061  17.209  1.00 34.97           C
ATOM    320  CD1 LEU A  44      13.386  58.400  16.795  1.00 33.89           C
ATOM    321  CD2 LEU A  44      13.399  55.928  16.404  1.00 33.15           C
ATOM    322  N   ARG A  45      12.147  55.914  21.675  1.00 38.31           N
ATOM    323  CA  ARG A  45      12.485  55.801  23.095  1.00 39.49           C
ATOM    324  C   ARG A  45      12.296  54.381  23.589  1.00 39.97           C
ATOM    325  O   ARG A  45      13.113  53.864  24.338  1.00 40.63           O
ATOM    326  CB  ARG A  45      11.614  56.757  23.935  1.00 39.94           C
ATOM    327  N   ARG A  46      11.186  53.775  23.179  1.00 41.00           N
ATOM    328  CA  ARG A  46      10.849  52.397  23.503  1.00 41.33           C
ATOM    329  C   ARG A  46      11.912  51.412  23.025  1.00 40.34           C
ATOM    330  O   ARG A  46      12.278  50.485  23.731  1.00 39.81           O
ATOM    331  CB  ARG A  46       9.524  52.063  22.835  1.00 41.72           C
ATOM    332  CG  ARG A  46       8.773  50.911  23.395  1.00 46.36           C
ATOM    333  CD  ARG A  46       7.352  50.836  22.851  1.00 51.59           C
ATOM    334  NE  ARG A  46       7.345  50.162  21.548  1.00 57.79           N
ATOM    335  CZ  ARG A  46       6.851  50.659  20.399  1.00 61.01           C
ATOM    336  NH1 ARG A  46       6.282  51.872  20.344  1.00 62.67           N
ATOM    337  NH2 ARG A  46       6.918  49.916  19.290  1.00 61.73           N
ATOM    338  N   LEU A  47      12.402  51.620  21.809  1.00 39.47           N
ATOM    339  CA  LEU A  47      13.439  50.765  21.223  1.00 38.25           C
ATOM    340  C   LEU A  47      14.826  51.006  21.800  1.00 37.39           C
ATOM    341  O   LEU A  47      15.742  50.247  21.530  1.00 38.19           O
ATOM    342  CB  LEU A  47      13.502  51.010  19.712  1.00 38.57           C
ATOM    343  CG  LEU A  47      12.264  50.556  18.951  1.00 38.58           C
ATOM    344  CD1 LEU A  47      12.346  51.046  17.517  1.00 38.92           C
ATOM    345  CD2 LEU A  47      12.101  49.038  19.050  1.00 38.51           C
ATOM    346  N   GLY A  48      14.997  52.083  22.557  1.00 36.96           N
ATOM    347  CA  GLY A  48      16.262  52.383  23.191  1.00 35.72           C
ATOM    348  C   GLY A  48      17.323  52.969  22.286  1.00 34.43           C
ATOM    349  O   GLY A  48      18.512  52.912  22.607  1.00 34.93           O
  """

  pdb_inp = iotbx.pdb.input(source_info=None, lines=pdb_str)
  params = monomer_library.pdb_interpretation.master_params.extract()
  params.secondary_structure.enabled=True
  processed_pdb_file = monomer_library.pdb_interpretation.process(
    mon_lib_srv=mon_lib_srv,
    ener_lib=ener_lib,
    params=params,
    strict_conflict_handling=False,
    pdb_inp=pdb_inp,
    log=sys.stdout)
  geo = processed_pdb_file.geometry_restraints_manager()
  assert geo.get_n_hbond_proxies() == 8
  make_geo_pickle_unpickle(geo, processed_pdb_file.xray_structure(), prefix)

def test_secondary_structure_2(mon_lib_srv, ener_lib, prefix="tst_grm_pickling_ss2"):
  from iotbx.pdb.tst_secondary_structure import pdb_1ywf_sample_strings
  pdb_inp = iotbx.pdb.input(source_info=None, lines=pdb_1ywf_sample_strings)
  params = monomer_library.pdb_interpretation.master_params.extract()
  params.secondary_structure.enabled=True
  processed_pdb_file = monomer_library.pdb_interpretation.process(
    mon_lib_srv=mon_lib_srv,
    ener_lib=ener_lib,
    params=params,
    strict_conflict_handling=False,
    pdb_inp=pdb_inp,
    log=sys.stdout)
  geo = processed_pdb_file.geometry_restraints_manager()
  assert geo.get_n_hbond_proxies() == 103, geo.get_n_hbond_proxies()
  make_geo_pickle_unpickle(geo, processed_pdb_file.xray_structure(), prefix)

def test_across_symmetry(mon_lib_srv, ener_lib, prefix="tst_across_symmetry"):
  raw_records1 = """\
CRYST1   60.800   60.800   97.000  90.00  90.00 120.00 P 32 2 1      6
ORIGX1      1.000000  0.000000  0.000000        0.00000
ORIGX2      0.000000  1.000000  0.000000        0.00000
ORIGX3      0.000000  0.000000  1.000000        0.00000
SCALE1      0.016447  0.009496  0.000000        0.00000
SCALE2      0.000000  0.018992  0.000000        0.00000
SCALE3      0.000000  0.000000  0.010309        0.00000
ATOM   1050  N   LYS A 135      31.992  14.930  -7.233  1.00  9.47           N
ATOM   1051  CA  LYS A 135      31.388  16.216  -7.637  1.00 12.89           C
ATOM   1052  C   LYS A 135      30.807  16.840  -6.406  1.00  6.47           C
ATOM   1053  O   LYS A 135      29.583  16.869  -6.191  1.00 15.74           O
ATOM   1054  CB  LYS A 135      30.263  16.059  -8.655  1.00 13.51           C
ATOM   1055  CG  LYS A 135      30.742  15.277  -9.843  1.00 16.23           C
ATOM   1056  CD  LYS A 135      29.612  15.131 -10.835  1.00 28.55           C
ATOM   1057  CE  LYS A 135      30.173  14.812 -12.216  1.00 34.52           C
ATOM   1058  NZ  LYS A 135      29.396  13.756 -12.899  1.00 46.18           N
HETATM 1406  O   HOH A 282      32.366  19.942  24.727  1.00 38.09           O
END
"""
  geometry, xrs = make_initial_grm(mon_lib_srv, ener_lib, raw_records1)
  make_geo_pickle_unpickle(geometry, xrs, prefix)

def test_reference_model(mon_lib_srv, ener_lib, prefix="tst_reference_model"):
  from mmtbx.geometry_restraints.torsion_restraints.tst_reference_model import \
      model_raw_records, reference_raw_records
  from mmtbx.geometry_restraints.torsion_restraints.reference_model import \
    reference_model
  import mmtbx.model
  # mstream = StringIO()
  from libtbx.utils import multi_out
  mstream = multi_out()
  mstream.register("stdout", sys.stdout)
  mstream_file_name = "polder.log"
  mstreamfile = open(mstream_file_name, "w")
  mstream.register("logfile", mstreamfile)

  work_params = mmtbx.model.manager.get_default_pdb_interpretation_params()
  work_params.reference_model.enabled = True
  work_params.reference_model.use_starting_model_as_reference = True
  work_params.reference_model.fix_outliers = False
  pdb_inp = iotbx.pdb.input(lines=model_raw_records.split('\n'), source_info=None)
  model = mmtbx.model.manager(model_input = pdb_inp)
  model.process(pdb_interpretation_params=work_params,
    make_restraints=True)
  reference_hierarchy_list = []
  tmp_hierarchy = iotbx.pdb.input(
    source_info=None,
    lines=reference_raw_records.split('\n')).construct_hierarchy()
  reference_hierarchy_list.append(tmp_hierarchy)
  rm = reference_model(
         model = model,
         reference_hierarchy_list=reference_hierarchy_list,
         params=work_params.reference_model,
         log=null_out())  # XXX changed from mstream which cannot be pickled
  assert rm.get_n_proxies() == 5, "Got %d, expected 5" % rm.get_n_proxies()
  geometry, xrs = make_initial_grm(mon_lib_srv, ener_lib, model_raw_records)
  geometry.adopt_reference_dihedral_manager(rm)
  make_geo_pickle_unpickle(geometry, xrs, prefix)
  mstream.close()

def exercise_all(args):
  mon_lib_srv = None
  ener_lib = None
  try:
    mon_lib_srv = monomer_library.server.server()
    ener_lib = monomer_library.server.ener_lib()
  except Exception:
    print("Can not initialize monomer_library, skipping test.")
    return 0
  import libtbx.load_env
  if libtbx.env.find_in_repositories(relative_path="chem_data") is None:
    print("Skipping exercise(): chem_data directory not available")
    return

  test_simple_protein(mon_lib_srv, ener_lib)
  test_nucleic_acid(mon_lib_srv, ener_lib)
  # test_ramachandran(mon_lib_srv, ener_lib)
  # test_cbeta(mon_lib_srv, ener_lib)
  # test_reference_coordinate(mon_lib_srv, ener_lib)
  # test_secondary_structure(mon_lib_srv, ener_lib)
  # test_secondary_structure_2(mon_lib_srv, ener_lib)
  # test_across_symmetry(mon_lib_srv, ener_lib)
  test_reference_model(mon_lib_srv, ener_lib)

if (__name__ == "__main__"):
  exercise_all(sys.argv[1:])


 *******************************************************************************


 *******************************************************************************
cctbx/regression/tst_grouped_data.py
from __future__ import absolute_import, division, print_function
from cctbx import miller
from cctbx import xray
from cctbx.development import random_structure
from cctbx.development import debug_utils
from cctbx.array_family import flex
import sys

def exercise(space_group_info, anomalous_flag,
             n_scatterers=8, d_min=2, verbose=0):
  structure = random_structure.xray_structure(
    space_group_info,
    elements=["const"]*n_scatterers)
  f_calc = structure.structure_factors(
    d_min=d_min, anomalous_flag=anomalous_flag).f_calc()
  f = abs(f_calc)
  f = miller.array(miller_set=f, data=f.data(), sigmas=flex.sqrt(f.data()))
  f = f.f_as_f_sq()
  g = f.expand_to_p1()
  merger_p1 = xray.merger( g.indices(),
                              g.data(),
                              g.sigmas(),
                              g.space_group(),
                              g.anomalous_flag(),
                              g.unit_cell() )
  p1_bic = merger_p1.bic()
  p1_r = merger_p1.r_abs()

  merger_nat = xray.merger( g.indices(),
                              g.data(),
                              g.sigmas(),
                              f.space_group(),
                              g.anomalous_flag(),
                              g.unit_cell() )
  nat_bic = merger_nat.bic()
  nat_r = merger_nat.r_abs()
  assert nat_bic >= p1_bic
  assert p1_r <= 1e-8


def run_call_back(flags, space_group_info):
  for anomalous_flag in (False, True):
    exercise(space_group_info, anomalous_flag)

def run():
  debug_utils.parse_options_loop_space_groups(sys.argv[1:], run_call_back)
  print("OK")

if (__name__ == "__main__"):
  run()


 *******************************************************************************


 *******************************************************************************
cctbx/regression/tst_itvb_2001_table_a1427_hall_symbols.py
"""Check if sgtbx Hermann-Mauguin vs. Hall symbol table is fully
   consistent with ITVB 2001.
"""
from __future__ import absolute_import, division, print_function
from cctbx import sgtbx
import os

html_file = "itvb_2001_table_a1427_hall_symbols.html"
html_file = os.path.join(os.path.dirname(os.path.realpath(__file__)), html_file)

def get_and_check_file():
  not_found = False
  if os.path.isfile(html_file):
    with open(html_file) as f:
      not_found = f.read().lower().find("not found") >= 0
  if not os.path.isfile(html_file) or not_found:
    print("Skipping exercise(): input file not available")
    return
  with open(html_file) as f:
    table_lines = f.read().splitlines()[11:-4]
  assert len(table_lines) == 530, "%d != 530" % len(table_lines)
  space_group_symbol_iterator = sgtbx.space_group_symbol_iterator()
  for line in table_lines:
    flds = line.split()
    assert len(flds) == 3
    nc, hm, hall = flds
    assert hall.lower() == hall
    symbols = sgtbx.space_group_symbols(symbol=hm)
    hm_sgtbx = symbols.universal_hermann_mauguin().replace(" ", "_") \
      .replace("_:",":") \
      .replace(":H",":h") \
      .replace(":R",":r")
    hall_sgtbx = symbols.hall().lower().replace(" ", "_")
    if (hall_sgtbx[0] == "_"): hall_sgtbx = hall_sgtbx[1:]
    assert hm_sgtbx == hm
    assert hall_sgtbx == hall
    symbols_i = next(space_group_symbol_iterator)
    assert symbols_i.universal_hermann_mauguin() \
        == symbols.universal_hermann_mauguin()

def exercise():
  get_and_check_file()
  print("OK")

if (__name__ == "__main__"):
  exercise()


 *******************************************************************************


 *******************************************************************************
cctbx/regression/tst_krivy_gruber.py
from __future__ import absolute_import, division, print_function
from cctbx.uctbx import reduction_base
from cctbx.uctbx import krivy_gruber_1976
from cctbx.uctbx import gruber_1973
from cctbx.uctbx import gruber_1973_table_1
from cctbx import uctbx
from cctbx import sgtbx
from scitbx import matrix
from scitbx.python_utils.misc import get_caller_name
from libtbx.utils import time_log
from libtbx.test_utils import Exception_expected, approx_equal
import math
import random
import sys
from six.moves import range

class check_is_niggli_cell(reduction_base.gruber_parameterization):

  def itva_is_niggli_cell(self):
    eq = self.eps_eq
    gt = self.eps_gt
    a,b,c,d,e,f = (self.a,self.b,self.c,self.d,self.e,self.f)
    if (not self.meets_main_conditions()): return False
    type = self.type()
    assert type in (1,2)
    if (type == 1):
      if (eq(a, b)):
        if (gt(d, e)): return False
      if (eq(b, c)):
        if (gt(e, f)): return False
      if (eq(d, b)):
        if (gt(f, e+e)): return False
      if (eq(e, a)):
        if (gt(f, d+d)): return False
      if (eq(f, a)):
        if (gt(e, d+d)): return False
    else:
      if (eq(a, b)):
        if (gt(abs(d), abs(e))): return False
      if (eq(b, c)):
        if (gt(abs(e), abs(f))): return False
      if (eq(abs(d), b)):
        if (not eq(f, 0)): return False
      if (eq(abs(e), a)):
        if (not eq(f, 0)): return False
      if (eq(abs(f), a)):
        if (not eq(e, 0)): return False
      if (eq(abs(d)+abs(e)+abs(f), a+b)):
        if (gt(a, abs(e) + abs(f)/2)): return False
    return True

class reduction_with_tracking(krivy_gruber_1976.reduction):

  def __init__(self, unit_cell, relative_epsilon=0, iteration_limit=100):
    self.action_log = []
    self.cell_log = []
    self.type_log = []
    self.meets_primary_conditions_log = []
    self.meets_main_conditions_log = []
    self.is_niggli_cell_log = []
    try:
      krivy_gruber_1976.reduction.__init__(self,
        unit_cell=unit_cell,
        relative_epsilon=relative_epsilon,
        iteration_limit=iteration_limit)
      self.iteration_limit_exceeded = False
    except StopIteration:
      self.iteration_limit_exceeded = True

  def cb_update(self, m_elems):
    caller = get_caller_name()
    if (caller == "n3_true_action"):
      id = 3
    elif (caller == "n3_false_action"):
      id = 4
    else:
      id = int(caller[1])
    self.action_log.append(id)
    self.cell_log.append(self.as_unit_cell())
    self.type_log.append(self.type())
    self.meets_primary_conditions_log.append(self.meets_primary_conditions())
    self.meets_main_conditions_log.append(self.meets_main_conditions())
    self.is_niggli_cell_log.append(self.is_niggli_cell())
    if (self._n_iterations == self._iteration_limit):
      raise StopIteration
    self._r_inv *= matrix.sqr(m_elems)
    self._n_iterations += 1

class reduction_with_tracking_and_eq_always_false(reduction_with_tracking):

  def __init__(self, unit_cell):
    reduction_with_tracking.__init__(self, unit_cell)

  def eps_eq(self, x, y):
    return False

relative_epsilon = None
track_infinite = False
eq_always_false = False
time_krivy_gruber_1976 = time_log("krivy_gruber_1976.reduction")
time_gruber_1973 = time_log("gruber_1973.reduction")
time_krivy_gruber_1976_minimum=time_log("krivy_gruber_1976.minimum_reduction")
time_gruber_1973_minimum = time_log("gruber_1973.minimum_reduction")
time_gruber_1973_fast_minimum = time_log("gruber_1973.fast_minimum_reduction")
time_uctbx_fast_minimum = time_log("uctbx.fast_minimum_reduction")
fast_minimum_reduction_max_n_iterations = 0

def do_reduce(inp):
  assert not inp.is_degenerate()
  time_krivy_gruber_1976.start()
  red = krivy_gruber_1976.reduction(
    inp, relative_epsilon=relative_epsilon)
  time_krivy_gruber_1976.stop()
  assert red.is_niggli_cell()
  red_cell = red.as_unit_cell()
  assert inp.change_basis(red.r_inv().elems).is_similar_to(red_cell)
  if (relative_epsilon is None):
    assert check_is_niggli_cell(red_cell).itva_is_niggli_cell()
  time_gruber_1973.start()
  gruber_reduction = gruber_1973.reduction(
    inp, relative_epsilon=relative_epsilon)
  time_gruber_1973.stop()
  assert gruber_reduction.is_buerger_cell()
  buerger_cell = gruber_reduction.as_unit_cell()
  assert inp.change_basis(gruber_reduction.r_inv().elems).is_similar_to(
    buerger_cell)
  time_krivy_gruber_1976_minimum.start()
  min_reduction = krivy_gruber_1976.minimum_reduction(inp)
  time_krivy_gruber_1976_minimum.stop()
  assert min_reduction.type() in (1,2)
  min_cell = min_reduction.as_unit_cell()
  assert approx_equal(min_cell.parameters()[:3], red_cell.parameters()[:3])
  assert inp.change_basis(min_reduction.r_inv().elems).is_similar_to(min_cell)
  time_gruber_1973_minimum.start()
  min_reduction = gruber_1973.minimum_reduction(inp)
  time_gruber_1973_minimum.stop()
  assert min_reduction.type() in (1,2)
  min_cell = min_reduction.as_unit_cell()
  assert approx_equal(min_cell.parameters()[:3], red_cell.parameters()[:3])
  assert inp.change_basis(min_reduction.r_inv().elems).is_similar_to(min_cell)
  time_gruber_1973_fast_minimum.start()
  min_reduction = gruber_1973.fast_minimum_reduction(inp)
  time_gruber_1973_fast_minimum.stop()
  assert min_reduction.type() in (1,2)
  min_cell = min_reduction.as_unit_cell()
  assert approx_equal(min_cell.parameters()[:3], red_cell.parameters()[:3])
  assert inp.change_basis(min_reduction.r_inv().elems).is_similar_to(min_cell)
  time_uctbx_fast_minimum.start()
  min_reduction = uctbx.fast_minimum_reduction(inp)
  time_uctbx_fast_minimum.stop()
  assert min_reduction.type() in (1,2)
  min_cell = min_reduction.as_unit_cell()
  assert approx_equal(min_cell.parameters()[:3], red_cell.parameters()[:3])
  assert inp.change_basis(min_reduction.r_inv()).is_similar_to(min_cell)
  global fast_minimum_reduction_max_n_iterations
  fast_minimum_reduction_max_n_iterations = max(
    fast_minimum_reduction_max_n_iterations, min_reduction.n_iterations())
  if (track_infinite):
    if (eq_always_false):
      red0 = reduction_with_tracking_and_eq_always_false(inp)
    else:
      red0 = reduction_with_tracking(inp)
    if (red0.iteration_limit_exceeded):
      n = 20
      print(inp)
      print("red0.action_log:", red0.action_log[-n:])
      print("red0.type_log:", red0.type_log[-n:])
      print("red0.meets_primary_conditions_log:", \
             red0.meets_primary_conditions_log[-n:])
      print("red0.meets_main_conditions_log:", \
             red0.meets_main_conditions_log[-n:])
      print("red0.is_niggli_cell_log:", red0.is_niggli_cell_log[-n:])
      if (1):
        for cell in red0.cell_log[-n:]:
          print(cell)
        print()
      sys.stdout.flush()
  return red

def reduce(inp):
  try:
    return do_reduce(inp)
  except Exception:
    print("Problem parameters:", inp.parameters())
    raise

def ucgmx(gruber_matrix): # unit cell given Gruber matrix
  (a,b,c,d,e,f) = gruber_matrix
  return uctbx.unit_cell(metrical_matrix=(a,b,c,f/2.,e/2.,d/2.))

def exercise_gruber_1973_example():
  start = ucgmx((4,136,76,-155,-31,44))
  assert start.is_similar_to(uctbx.unit_cell(
    (2, 11.66, 8.718, 139+40/60., 152+45/60., 19+24/60.)))
  buerger = ucgmx((4,16,16,-16,-1,-3))
  assert buerger.is_similar_to(uctbx.unit_cell(
    (2, 4, 4, 120, 93.5833, 100.807)))
  niggli = ucgmx((4,16,16,16,3,4))
  assert niggli.is_similar_to(uctbx.unit_cell(
    (2, 4, 4, 60, 79.1931, 75.5225)))
  red = reduction_base.gruber_parameterization(start)
  assert not red.is_buerger_cell()
  assert approx_equal(red.as_gruber_matrix(), (4,136,76,-155,-31,44))
  assert approx_equal(red.as_niggli_matrix(), (4,136,76,-155/2.,-31/2.,44/2.))
  assert approx_equal(red.as_sym_mat3(), (4,136,76,44/2.,-31/2.,-155/2.))
  assert red.as_unit_cell().is_similar_to(start)
  red = reduction_base.gruber_parameterization(buerger)
  assert red.is_buerger_cell()
  assert not red.is_niggli_cell()
  red = reduction_base.gruber_parameterization(niggli)
  assert red.is_niggli_cell()
  red = reduce(start)
  assert red.as_unit_cell().is_similar_to(niggli)
  assert red.r_inv().elems == (-1, 5, 9, 0, -1, -1, 0, 0, 1)
  assert red.n_iterations() == 29
  red = reduce(buerger)
  assert red.as_unit_cell().is_similar_to(niggli)
  assert red.r_inv().elems == (-1, 0, 0, 0, 1, 1, 0, 1, 0)
  assert red.n_iterations() == 4
  red = reduce(niggli)
  assert red.as_unit_cell().is_similar_to(niggli)
  assert red.r_inv().elems == (1, 0, 0, 0, 1, 0, 0, 0, 1)
  assert red.n_iterations() == 1
  try:
    red = krivy_gruber_1976.reduction(buerger, iteration_limit=1)
  except krivy_gruber_1976.iteration_limit_exceeded:
    pass
  else:
    raise Exception_expected
  assert not start.is_buerger_cell()
  assert not start.is_niggli_cell()
  assert buerger.is_buerger_cell()
  assert not buerger.is_niggli_cell()
  assert niggli.is_buerger_cell()
  assert niggli.is_niggli_cell()
  red = start.niggli_reduction()
  assert red.n_iterations() == 29
  assert start.niggli_cell().is_similar_to(niggli)

def exercise_krivy_gruber_1976_example():
  start = ucgmx((9,27,4,-5,-4,-22))
  assert start.is_similar_to(uctbx.unit_cell(
    (3, 5.196, 2, 103+55/60., 109+28/60., 134+53/60.)))
  for gmx in ((4,9,9,-8,-1,-4),
              (4,9,9,9,1,4)):
    red = reduction_base.gruber_parameterization(ucgmx(gmx))
    assert red.is_buerger_cell()
    assert not red.is_niggli_cell()
  niggli = ucgmx((4,9,9,9,3,4))
  assert niggli.is_similar_to(uctbx.unit_cell(
    (2, 3, 3, 60, 75+31/60., 70+32/60.)))
  red = reduction_base.gruber_parameterization(niggli)
  assert red.is_niggli_cell()
  red = reduce(start)
  assert red.as_unit_cell().is_similar_to(niggli)
  assert red.r_inv().elems == (0, 1, 2, 0, 0, 1, 1, 1, 2)
  assert red.n_iterations() == 11

def exercise_bravais_plus():
  for pg in ("1", "2", "2 2", "4", "3*", "6", "2 2 3"):
    for z in "PABCIRF":
      sgi = sgtbx.space_group_info("Hall: %s %s" % (z, pg))
      r_inv = sgi.group().z2p_op().c_inv().r()
      reduce(sgi.any_compatible_unit_cell(volume=100).change_basis(
        r_inv.num(),r_inv.den()))

def cos_deg(x):
  return math.cos(x*math.pi/180)

def exercise_grid(quick=False, verbose=0):
  if (quick):
    sample_lengths = (10,)
    sample_angles = (60,)
  else:
    sample_lengths = (10,20,30)
    sample_angles = (10,30,45,60,90,120,150,170)
  n_trials = 0
  for a in sample_lengths:
    for b in sample_lengths:
      for c in sample_lengths:
        for alpha in sample_angles:
          for beta in sample_angles:
            for gamma in sample_angles:
              a_b = a*b*cos_deg(gamma)
              a_c = a*c*cos_deg(beta)
              b_c = b*c*cos_deg(alpha)
              g = matrix.sqr((a*a,a_b,a_c,
                              a_b,b*b,b_c,
                              a_c,b_c,c*c))
              det_g = g.determinant()
              try: unit_cell = uctbx.unit_cell((a,b,c,alpha,beta,gamma))
              except Exception:
                assert det_g <= 1.e-5
                continue
              assert abs(det_g-unit_cell.volume()**2) < 1.e-5
              if (unit_cell.volume() < a*b*c/1000.): continue
              n_trials += 1
              reduce(unit_cell)
  if (0 or verbose):
    print("exercise_grid n_trials:", n_trials)

class random_unimodular_integer_matrix_generator(object):

  def __init__(self, reset_threshold=10):
    self.reset_threshold = reset_threshold
    self._m1 = matrix.sqr((0,0,1,1,0,0,0,1,0))
    self._m2 = matrix.sqr((1,-1,0,1,0,0,0,0,1))
    self._mi = self._m1 * self._m2

  def has_elements_which_are_to_large(self):
    e = self._mi.elems
    return max(abs(min(e)), abs(max(e))) >= self.reset_threshold

  def next(self):
    while 1:
      if (random.randrange(0,2)):
        self._mi = self._m2 * self._mi
      else:
        self._mi = self._m1 * self._mi
      if (not self.has_elements_which_are_to_large()):
        break
      self._mi = random.choice((self._m1, self._m2))
    return self._mi

class random_abcpq(object):

  def __init__(self, ck_type):
    rr = random.randrange
    self.a = rr(100,201)
    self.b = self.a
    self.p = rr(10,41)
    self.q = self.a
    if (ck_type[0] == "q"):
      if (ck_type[1] != "=" and rr(0,2)):
        self.q = rr(50,91)
      ck_type = ck_type[2:]
    if   (ck_type == "a=b<=c"):
      self.c = self.b
      if (rr(0,2)): self.c += rr(10,101)
    elif (ck_type == "a<b=c"):
      self.b += rr(10,101)
      self.c = self.b
    elif (ck_type == "a<=b<c"):
      if (rr(0,2)): self.b += rr(10,101)
      self.c = self.b + rr(10,101)
    elif (ck_type == "a<b<c"):
      self.b += rr(10,101)
      self.c = self.b + rr(10,101)
    elif (ck_type == "a=b<c"):
      self.c = self.b + rr(10,101)
    elif (ck_type == "a<b<=c"):
      self.b += rr(10,101)
      self.c = self.b
      if (rr(0,2)): self.c += rr(10,101)
    else:
      raise RuntimeError("Unknown ck_type.")

  def eval_defks(self, defks):
    a,b,c,p,q = tuple([float(x) for x in (self.a,self.b,self.c,self.p,self.q)])
    m = b/a
    n = (b-a)/a
    d,e,f = eval(defks)
    return a,b,c,d,e,f

def random_gruber_matrix(type_conditions):
  return random_abcpq(random.choice(
    type_conditions.ck_types)).eval_defks(type_conditions.defks)

def exercise_gruber_types(n_trials_per_type, dump=0, verbose=0):
  mk2_sets = gruber_1973_table_1.get_mk2_sets()
  type_conditions = gruber_1973_table_1.get_type_conditions()
  random_unimodular = random_unimodular_integer_matrix_generator()
  have_errors = False
  for k in range(1,29):
    set = mk2_sets[k]
    tc = type_conditions[k]
    if (0 or verbose):
      print(" ", tc.ck_types, tc.defks)
    n_errors = 0
    for i_trial in range(n_trials_per_type):
      gruber_matrix = random_gruber_matrix(tc)
      type_cell = ucgmx(gruber_matrix)
      if (0 or verbose):
        print(" ", gruber_matrix)
        print(" ", type_cell)
      red = reduction_base.gruber_parameterization(type_cell)
      assert red.is_niggli_cell()
      n_different_cells = 0
      for m in set:
        other_cell = type_cell.change_basis(m.inverse().transpose().elems, 1)
        if (0 or verbose):
          print(" ", m.elems, m.determinant())
          print(" ", other_cell)
        red = reduction_base.gruber_parameterization(other_cell)
        if (not red.is_buerger_cell()):
          print("  Error: Transformed cell is not a Buerger cell.")
          print("  gruber_matrix:", gruber_matrix)
          n_errors += 1
        else:
          n_different_cells += 1
          if (red.is_niggli_cell()):
            if (not other_cell.is_similar_to(type_cell)):
              print("  Error: Transformed cell is a Niggli cell.")
              print("  gruber_matrix:", gruber_matrix)
              n_errors += 1
          else:
            krivy_cell = reduce(type_cell).as_unit_cell()
            assert krivy_cell.is_similar_to(type_cell)
            krivy_cell = reduce(other_cell).as_unit_cell()
            assert krivy_cell.is_similar_to(type_cell)
            r_inv = random_unimodular.next().elems
            random_cell = type_cell.change_basis(r_inv, 1)
            if (0 or verbose):
              print("  Random:", random_cell, r_inv)
            red = reduce(random_cell)
            krivy_cell = red.as_unit_cell()
            if (dump):
              print("type_cell:", type_cell)
              print("random_cell:", random_cell)
              print("krivy_cell:", krivy_cell)
              print()
            if (not krivy_cell.is_similar_to(type_cell)):
              print("  Error: Random cell recovery.")
              print("  gruber_matrix:", gruber_matrix)
              print("  r_inv:", r_inv)
              print("  red.as_gruber_matrix():", red.as_gruber_matrix())
              n_errors += 1
      if (n_different_cells == 0):
        print("  Error: Transformation does not yield different cells.")
        n_errors += 1
        raise RuntimeError
    if ((0 or verbose) and n_errors != 0):
      print("Errors for type %d:" % k, n_errors)
    if (n_errors != 0):
      have_errors = True
  assert not have_errors

def exercise_extreme():
  uc = uctbx.unit_cell((
    69.059014477286041, 48.674386086971339, 0.0048194797114296736,
    89.995145576185806, 89.999840576946085, 99.484656090034875))
  red = uc.niggli_reduction()
  assert red.as_unit_cell().is_similar_to(uctbx.unit_cell((
    0.00481948, 48.6744, 69.059,
    80.5153, 89.9962, 89.9951)))
  uc = uctbx.unit_cell((
    80.816186392181365, 81.021289502648813, 140.6784408482614,
    29.932540128999769, 89.92047105556459, 119.85301114570319))
  uc.niggli_reduction(iteration_limit=10000)

def exercise_real_world_examples():
  # SSZ-59, cell by Michael Treacy, infinite loop in GSAS rducll (Linux)
  uc = uctbx.unit_cell((
    12.7366, 29.2300, 5.0242,
    94.6570, 100.8630, 99.7561))
  nc = uc.niggli_cell()
  assert nc.is_similar_to(uctbx.unit_cell(
    (5.0242, 12.7366, 29.23, 99.7561, 94.657, 100.863)))
  # SSZ-59, Burton et al., Table 4
  uc = uctbx.unit_cell((
    12.7806, 12.7366, 29.457,
    103.42, 103.57, 22.71))
  red = uc.niggli_reduction()
  assert red.as_unit_cell().is_similar_to(nc)
  assert red.r_inv().elems == (-1, 0, 1, 1, -1, 0, 0, 0, 1)

def exercise_problem_parameters():
  problem_parameters = (
    (13.892443989449804, 13.892443989449804, 14.7648230602334,
     61.936000954634402, 61.936000954634402, 88.515487291567879),
    (10.0, 10.0, 20.0,
     90.0, 45.0, 120.0),
    (10.0, 20.0, 30.0,
     120.0, 60.0, 120.0),
    (10.816653826391969, 13.820274961085254, 13.820274961085254,
     60.0, 66.962544368849834, 66.962544368849834),
    (10.148891565092219, 13.379088160259652, 13.379088160259652,
     107.33461190548745, 107.94415159713115, 109.72759194290299),
    (19.798989873223331, 231.21851136965654, 14.352700094407323,
     133.37207519042573, 92.016673840743408, 134.55815348093702),
    (10.392304845413264, 13.19090595827292, 13.19090595827292,
     112.64730819498385, 104.36056979415913, 106.96527532101391),
    (16.046806535881213, 13.341664064126334, 197.64614845728718,
     153.28759931491018, 114.05435960569044, 92.543256980798247),
    (10.488088481701515, 13.820274961085254, 13.820274961085254,
     109.9226012907464, 104.00699650533103, 110.31922490992999),
    (10.04987562112089, 13.19090595827292, 13.19090595827292,
     118.05419482122835, 97.404049814230376, 106.92070123011929),
    (10.04987562112089, 13.45362404707371, 13.45362404707371,
     109.02416163919622, 105.88181549565937, 109.44017310001107),
    (11.357816691600547, 13.638181696985853, 13.638181696985855,
     115.81608733396159, 104.29612977641231, 104.29612977641233),
    (11.832159566199232, 13.784048752090222, 13.784048752090222,
     110.67521616123457, 104.95317005195066, 110.01926787579129))
  for parameters in problem_parameters:
    reduce(uctbx.unit_cell(parameters))

def exercise_one_pass(show_times=False):
  quick = "--Quick" in sys.argv[1:]
  verbose = "--Verbose" in sys.argv[1:]
  global relative_epsilon
  global track_infinite
  global eq_always_false
  if ("--zero_epsilon" in sys.argv[1:]):
    relative_epsilon = 0
  if ("--track_infinite" in sys.argv[1:]):
    track_infinite = True
  if ("--eq_always_false" in sys.argv[1:]):
    track_infinite = True
    eq_always_false = True
  exercise_problem_parameters()
  exercise_extreme()
  exercise_gruber_1973_example()
  exercise_krivy_gruber_1976_example()
  exercise_bravais_plus()
  exercise_grid(quick=quick, verbose=verbose)
  if (quick): n_trials_per_type=10
  else:       n_trials_per_type=100
  if ("--dump" in sys.argv[1:]):
    random.seed(0)
    exercise_gruber_types(n_trials_per_type, dump=True, verbose=verbose)
    return
  exercise_gruber_types(n_trials_per_type, verbose=verbose)
  exercise_real_world_examples()
  if (0 or verbose or show_times):
    print(time_krivy_gruber_1976.report())
    print(time_gruber_1973.report())
    print(time_krivy_gruber_1976_minimum.report())
    print(time_gruber_1973_minimum.report())
    print(time_gruber_1973_fast_minimum.report())
    print(time_uctbx_fast_minimum.report())
    if (time_uctbx_fast_minimum.accumulation != 0):
      print("fast_minimum Python/C++: %.3g" % (
          time_gruber_1973_fast_minimum.accumulation
        / time_uctbx_fast_minimum.accumulation))
    print("fast_minimum_reduction_max_n_iterations:", \
           fast_minimum_reduction_max_n_iterations)
  print("OK")

def exercise():
  forever = "--Forever" in sys.argv[1:]
  while 1:
    exercise_one_pass(show_times=forever)
    sys.stdout.flush()
    if (not forever):
      break

if (__name__ == "__main__"):
  exercise()


 *******************************************************************************


 *******************************************************************************
cctbx/regression/tst_loc_res.py
from __future__ import absolute_import, division, print_function

from libtbx.test_utils import approx_equal
import iotbx.pdb
from cctbx import maptbx
from  cctbx import maptbx
from six.moves import zip
from iotbx import map_model_manager
from iotbx import map_manager

raw_records = """\
CRYST1   26.880   33.600   31.920  90.00  90.00  90.00 P 1
ATOM      1  N   META1   1       6.457   5.962   7.411  1.00945.14           N
ATOM      2  CA  META1   1       6.950   5.877   5.993  1.00928.61           C
ATOM      3  C   META1   1       8.223   6.699   5.793  1.00910.08           C
ATOM      4  O   META1   1       9.243   6.182   5.328  1.00910.73           O
ATOM      5  CB  META1   1       5.876   6.358   5.004  1.00932.69           C
ATOM      6  CG  META1   1       4.568   5.569   5.015  1.00937.71           C
ATOM      7  SD  META1   1       4.706   3.879   4.402  1.00945.00           S
ATOM      8  CE  META1   1       3.085   3.239   4.820  1.00941.13           C
ATOM      9  N   GLNA1   2       8.145   7.976   6.159  1.00985.67           N
ATOM     10  CA  GLNA1   2       9.224   8.943   5.958  1.00979.66           C
ATOM     11  C   GLNA1   2      10.241   9.025   7.112  1.00974.69           C
ATOM     12  O   GLNA1   2      11.358   9.495   6.896  1.00979.07           O
ATOM     13  CB  GLNA1   2       8.595  10.314   5.711  1.00980.23           C
ATOM     14  CG  GLNA1   2       9.537  11.423   5.259  1.00989.23           C
ATOM     15  CD  GLNA1   2      10.274  11.097   3.976  1.00902.03           C
ATOM     16  OE1 GLNA1   2       9.763  10.385   3.110  1.00904.39           O
ATOM     17  NE2 GLNA1   2      11.484  11.624   3.845  1.00937.18           N
ATOM     18  N   ARGA1   3       9.853   8.577   8.312  1.00964.30           N
ATOM     19  CA  ARGA1   3      10.716   8.560   9.520  1.00966.26           C
ATOM     20  C   ARGA1   3      10.999   9.975  10.053  1.00966.52           C
ATOM     21  O   ARGA1   3      11.841  10.691   9.509  1.00968.91           O
ATOM     22  CB  ARGA1   3      12.026   7.778   9.276  1.00972.03           C
ATOM     23  CG  ARGA1   3      13.003   7.724  10.446  1.00980.32           C
ATOM     24  CD  ARGA1   3      12.400   7.099  11.694  1.00993.10           C
ATOM     25  NE  ARGA1   3      13.347   7.098  12.809  1.00910.27           N
ATOM     26  CZ  ARGA1   3      13.072   6.692  14.050  1.00920.50           C
ATOM     27  NH1 ARGA1   3      14.021   6.744  14.983  1.00930.56           N
ATOM     28  NH2 ARGA1   3      11.860   6.234  14.373  1.00927.11           N
ATOM     29  N   SERA1   4      10.310  10.351  11.133  1.00970.10           N
ATOM     30  CA  SERA1   4      10.354  11.730  11.665  1.00969.72           C
ATOM     31  C   SERA1   4      11.636  12.037  12.458  1.00972.14           C
ATOM     32  O   SERA1   4      12.139  11.164  13.169  1.00972.46           O
ATOM     33  CB  SERA1   4       9.136  12.007  12.554  1.00967.95           C
ATOM     34  OG  SERA1   4       9.282  11.419  13.837  1.00966.18           O
ATOM     35  N   PROA1   5      12.143  13.288  12.370  1.00976.06           N
ATOM     36  CA  PROA1   5      13.432  13.642  12.995  1.00970.63           C
ATOM     37  C   PROA1   5      13.413  13.900  14.515  1.00962.60           C
ATOM     38  O   PROA1   5      14.460  13.795  15.158  1.00953.71           O
ATOM     39  CB  PROA1   5      13.835  14.912  12.244  1.00971.75           C
ATOM     40  CG  PROA1   5      12.538  15.556  11.904  1.00970.02           C
ATOM     41  CD  PROA1   5      11.546  14.450  11.681  1.00969.15           C
ATOM     42  N   VALA1   6      12.247  14.236  15.074  1.00957.91           N
ATOM     43  CA  VALA1   6      12.086  14.442  16.521  1.00956.66           C
ATOM     44  C   VALA1   6      12.466  13.191  17.316  1.00964.35           C
ATOM     45  O   VALA1   6      12.902  13.293  18.463  1.00963.11           O
ATOM     46  CB  VALA1   6      10.646  14.895  16.873  1.00953.86           C
ATOM     47  CG1 VALA1   6       9.629  13.783  16.632  1.00955.04           C
ATOM     48  CG2 VALA1   6      10.564  15.418  18.305  1.00951.21           C
ATOM     49  N   GLUA1   7      12.275  12.023  16.699  1.00981.64           N
ATOM     50  CA  GLUA1   7      12.746  10.740  17.244  1.00986.88           C
ATOM     51  C   GLUA1   7      14.251  10.751  17.542  1.00984.08           C
ATOM     52  O   GLUA1   7      14.682  10.288  18.602  1.00981.69           O
ATOM     53  CB  GLUA1   7      12.428   9.594  16.274  1.00992.25           C
ATOM     54  CG  GLUA1   7      10.942   9.304  16.075  1.00998.55           C
ATOM     55  CD  GLUA1   7      10.255   8.692  17.292  1.00908.01           C
ATOM     56  OE1 GLUA1   7      10.945   8.223  18.225  1.00917.52           O
ATOM     57  OE2 GLUA1   7       9.006   8.674  17.310  1.00911.20           O
ATOM     58  N   ASPA1   8      15.029  11.281  16.597  1.00981.90           N
ATOM     59  CA  ASPA1   8      16.486  11.412  16.728  1.00973.55           C
ATOM     60  C   ASPA1   8      16.859  12.874  16.984  1.00968.82           C
ATOM     61  O   ASPA1   8      17.526  13.518  16.167  1.00967.38           O
ATOM     62  CB  ASPA1   8      17.181  10.885  15.466  1.00972.03           C
ATOM     63  CG  ASPA1   8      16.797   9.452  15.138  1.00970.76           C
ATOM     64  OD1 ASPA1   8      16.670   8.634  16.072  1.00971.90           O
ATOM     65  OD2 ASPA1   8      16.624   9.145  13.939  1.00969.04           O
ATOM     66  N   ALAA1   9      16.415  13.379  18.132  1.00961.64           N
ATOM     67  CA  ALAA1   9      16.603  14.784  18.516  1.00966.44           C
ATOM     68  C   ALAA1   9      17.351  14.937  19.844  1.00967.19           C
ATOM     69  O   ALAA1   9      17.283  14.063  20.712  1.00961.82           O
ATOM     70  CB  ALAA1   9      15.256  15.486  18.591  1.00968.54           C
ATOM     71  N   ASNA1  10      18.056  16.065  19.975  1.00973.18           N
ATOM     72  CA  ASNA1  10      18.795  16.429  21.183  1.00964.26           C
ATOM     73  C   ASNA1  10      18.003  17.403  22.070  1.00968.71           C
ATOM     74  O   ASNA1  10      17.219  18.228  21.577  1.00959.02           O
ATOM     75  CB  ASNA1  10      20.144  17.045  20.791  1.00956.30           C
ATOM     76  CG  ASNA1  10      21.141  17.087  21.939  1.00955.13           C
ATOM     77  OD1 ASNA1  10      20.945  16.476  22.991  1.00949.89           O
ATOM     78  ND2 ASNA1  10      22.228  17.814  21.732  1.00958.95           N
ATOM     79  N   CYSA1  11      18.240  17.302  23.378  1.00 20.00           N
ATOM     80  CA  CYSA1  11      17.509  18.064  24.406  1.00 20.00           C
ATOM     81  C   CYSA1  11      17.457  19.576  24.165  1.00 20.00           C
ATOM     82  O   CYSA1  11      16.456  20.218  24.484  1.00 20.00           O
ATOM     83  CB  CYSA1  11      18.093  17.773  25.796  1.00 20.00           C
ATOM     84  SG  CYSA1  11      19.900  17.783  25.877  1.00 20.00           S
ATOM     85  N   LEUA1  12      18.530  20.132  23.607  1.00 20.00           N
ATOM     86  CA  LEUA1  12      18.578  21.549  23.243  1.00 20.00           C
ATOM     87  C   LEUA1  12      17.781  21.794  21.968  1.00 20.00           C
ATOM     88  O   LEUA1  12      16.997  22.747  21.888  1.00 20.00           O
ATOM     89  CB  LEUA1  12      20.023  22.024  23.056  1.00 20.00           C
ATOM     90  CG  LEUA1  12      20.775  22.412  24.332  1.00 20.00           C
ATOM     91  CD1 LEUA1  12      21.100  21.195  25.188  1.00 20.00           C
ATOM     92  CD2 LEUA1  12      22.051  23.166  23.986  1.00 20.00           C
ATOM     93  N   SERA1  13      17.979  20.922  20.982  1.00 20.00           N
ATOM     94  CA  SERA1  13      17.342  21.072  19.672  1.00 20.00           C
ATOM     95  C   SERA1  13      15.823  20.970  19.753  1.00 20.00           C
ATOM     96  O   SERA1  13      15.111  21.701  19.049  1.00 20.00           O
ATOM     97  CB  SERA1  13      17.897  20.057  18.667  1.00 20.00           C
ATOM     98  OG  SERA1  13      17.826  18.736  19.165  1.00 20.00           O
ATOM     99  N   ARGA1  14      15.340  20.073  20.614  1.00 20.00           N
ATOM    100  CA  ARGA1  14      13.895  19.927  20.840  1.00 20.00           C
ATOM    101  C   ARGA1  14      13.283  21.099  21.632  1.00 20.00           C
ATOM    102  O   ARGA1  14      12.119  21.445  21.419  1.00 20.00           O
ATOM    103  CB  ARGA1  14      13.570  18.579  21.500  1.00 20.00           C
ATOM    104  CG  ARGA1  14      14.072  18.405  22.922  1.00 20.00           C
ATOM    105  CD  ARGA1  14      13.841  16.988  23.418  1.00 20.00           C
ATOM    106  NE  ARGA1  14      12.423  16.714  23.658  1.00 20.00           N
ATOM    107  CZ  ARGA1  14      11.935  15.592  24.195  1.00 20.00           C
ATOM    108  NH1 ARGA1  14      10.619  15.463  24.369  1.00 20.00           N
ATOM    109  NH2 ARGA1  14      12.742  14.594  24.564  1.00 20.00           N
ATOM    110  N   TYRA1  15      14.065  21.700  22.532  1.00 20.00           N
ATOM    111  CA  TYRA1  15      13.624  22.854  23.325  1.00 20.00           C
ATOM    112  C   TYRA1  15      13.416  24.094  22.457  1.00 20.00           C
ATOM    113  O   TYRA1  15      12.343  24.698  22.482  1.00 20.00           O
ATOM    114  CB  TYRA1  15      14.648  23.155  24.422  1.00 20.00           C
ATOM    115  CG  TYRA1  15      14.241  24.242  25.389  1.00 20.00           C
ATOM    116  CD1 TYRA1  15      13.524  23.941  26.547  1.00 20.00           C
ATOM    117  CD2 TYRA1  15      14.590  25.574  25.161  1.00 20.00           C
ATOM    118  CE1 TYRA1  15      13.156  24.935  27.445  1.00 20.00           C
ATOM    119  CE2 TYRA1  15      14.226  26.577  26.050  1.00 20.00           C
ATOM    120  CZ  TYRA1  15      13.510  26.254  27.191  1.00 20.00           C
ATOM    121  OH  TYRA1  15      13.147  27.244  28.077  1.00 20.00           O
ATOM    122  N   PHEA1  16      14.448  24.460  21.697  1.00 20.00           N
ATOM    123  CA  PHEA1  16      14.402  25.621  20.779  1.00 20.00           C
ATOM    124  C   PHEA1  16      13.776  25.358  19.393  1.00 20.00           C
ATOM    125  O   PHEA1  16      13.545  26.313  18.643  1.00 20.00           O
ATOM    126  CB  PHEA1  16      15.814  26.192  20.575  1.00 20.00           C
ATOM    127  CG  PHEA1  16      16.319  26.997  21.734  1.00 20.00           C
ATOM    128  CD1 PHEA1  16      16.018  28.349  21.840  1.00 20.00           C
ATOM    129  CD2 PHEA1  16      17.110  26.410  22.712  1.00 20.00           C
ATOM    130  CE1 PHEA1  16      16.490  29.099  22.909  1.00 20.00           C
ATOM    131  CE2 PHEA1  16      17.581  27.153  23.785  1.00 20.00           C
ATOM    132  CZ  PHEA1  16      17.272  28.501  23.883  1.00 20.00           C
ATOM    133  N   PHEA1  17      13.499  24.089  19.068  1.00 20.00           N
ATOM    134  CA  PHEA1  17      13.061  23.671  17.724  1.00 20.00           C
ATOM    135  C   PHEA1  17      14.112  23.971  16.634  1.00 20.00           C
ATOM    136  O   PHEA1  17      13.961  24.927  15.864  1.00 20.00           O
ATOM    137  CB  PHEA1  17      11.696  24.288  17.357  1.00 20.00           C
ATOM    138  CG  PHEA1  17      10.643  24.113  18.413  1.00 20.00           C
ATOM    139  CD1 PHEA1  17       9.834  22.986  18.423  1.00 20.00           C
ATOM    140  CD2 PHEA1  17      10.451  25.082  19.394  1.00 20.00           C
ATOM    141  CE1 PHEA1  17       8.855  22.825  19.394  1.00 20.00           C
ATOM    142  CE2 PHEA1  17       9.476  24.925  20.369  1.00 20.00           C
ATOM    143  CZ  PHEA1  17       8.675  23.795  20.370  1.00 20.00           C
ATOM    144  N   TRPA1  18      15.177  23.164  16.593  1.00 20.00           N
ATOM    145  CA  TRPA1  18      16.173  23.217  15.500  1.00 20.00           C
ATOM    146  C   TRPA1  18      15.755  22.365  14.287  1.00 20.00           C
ATOM    147  O   TRPA1  18      16.241  22.588  13.175  1.00 20.00           O
ATOM    148  CB  TRPA1  18      17.555  22.750  15.985  1.00 20.00           C
ATOM    149  CG  TRPA1  18      18.326  23.748  16.815  1.00 20.00           C
ATOM    150  CD1 TRPA1  18      17.963  24.262  18.026  1.00 20.00           C
ATOM    151  CD2 TRPA1  18      19.609  24.321  16.505  1.00 20.00           C
ATOM    152  NE1 TRPA1  18      18.931  25.126  18.488  1.00 20.00           N
ATOM    153  CE2 TRPA1  18      19.949  25.185  17.575  1.00 20.00           C
ATOM    154  CE3 TRPA1  18      20.499  24.197  15.427  1.00 20.00           C
ATOM    155  CZ2 TRPA1  18      21.145  25.922  17.598  1.00 20.00           C
ATOM    156  CZ3 TRPA1  18      21.692  24.933  15.451  1.00 20.00           C
ATOM    157  CH2 TRPA1  18      22.000  25.783  16.532  1.00 20.00           C
ATOM    158  N   TRPA1  19      14.858  21.401  14.508  1.00 20.00           N
ATOM    159  CA  TRPA1  19      14.551  20.352  13.512  1.00 20.00           C
ATOM    160  C   TRPA1  19      13.654  20.762  12.341  1.00 20.00           C
ATOM    161  O   TRPA1  19      13.665  20.095  11.303  1.00 20.00           O
ATOM    162  CB  TRPA1  19      13.982  19.092  14.183  1.00 20.00           C
ATOM    163  CG  TRPA1  19      12.647  19.247  14.852  1.00 20.00           C
ATOM    164  CD1 TRPA1  19      12.423  19.644  16.133  1.00 20.00           C
ATOM    165  CD2 TRPA1  19      11.359  18.966  14.289  1.00 20.00           C
ATOM    166  NE1 TRPA1  19      11.079  19.648  16.401  1.00 20.00           N
ATOM    167  CE2 TRPA1  19      10.400  19.233  15.289  1.00 20.00           C
ATOM    168  CE3 TRPA1  19      10.921  18.522  13.036  1.00 20.00           C
ATOM    169  CZ2 TRPA1  19       9.025  19.072  15.080  1.00 20.00           C
ATOM    170  CZ3 TRPA1  19       9.548  18.359  12.825  1.00 20.00           C
ATOM    171  CH2 TRPA1  19       8.619  18.635  13.845  1.00 20.00           C
ATOM    172  N   THRA1  20      12.893  21.842  12.494  1.00 20.00           N
ATOM    173  CA  THRA1  20      12.024  22.334  11.408  1.00 20.00           C
ATOM    174  C   THRA1  20      12.757  22.960  10.196  1.00 20.00           C
ATOM    175  O   THRA1  20      12.143  23.126   9.131  1.00 20.00           O
ATOM    176  CB  THRA1  20      10.981  23.340  11.942  1.00 20.00           C
ATOM    177  OG1 THRA1  20      11.638  24.387  12.665  1.00 20.00           O
ATOM    178  CG2 THRA1  20       9.986  22.643  12.860  1.00 20.00           C
""".splitlines()

raw_records_2 = """\
CRYST1   26.880   33.600   31.920  90.00  90.00  90.00 P 1
ATOM      1  N   META1   1       6.457   5.962   7.411  1.00200.00           N
ATOM      2  CA  META1   1       6.950   5.877   5.993  1.00200.00           C
ATOM      3  C   META1   1       8.223   6.699   5.793  1.00200.00           C
ATOM      4  O   META1   1       9.243   6.182   5.328  1.00200.00           O
ATOM      5  CB  META1   1       5.876   6.358   5.004  1.00200.00           C
ATOM      6  CG  META1   1       4.568   5.569   5.015  1.00200.00           C
ATOM      7  SD  META1   1       4.706   3.879   4.402  1.00200.00           S
ATOM      8  CE  META1   1       3.085   3.239   4.820  1.00200.00           C
ATOM      9  N   GLNA1   2       8.145   7.976   6.159  1.00200.00           N
ATOM     10  CA  GLNA1   2       9.224   8.943   5.958  1.00200.00           C
ATOM     11  C   GLNA1   2      10.241   9.025   7.112  1.00200.00           C
ATOM     12  O   GLNA1   2      11.358   9.495   6.896  1.00200.00           O
ATOM     13  CB  GLNA1   2       8.595  10.314   5.711  1.00200.00           C
ATOM     14  CG  GLNA1   2       9.537  11.423   5.259  1.00200.00           C
ATOM     15  CD  GLNA1   2      10.274  11.097   3.976  1.00200.00           C
ATOM     16  OE1 GLNA1   2       9.763  10.385   3.110  1.00200.00           O
ATOM     17  NE2 GLNA1   2      11.484  11.624   3.845  1.00200.00           N
ATOM     18  N   ARGA1   3       9.853   8.577   8.312  1.00200.00           N
ATOM     19  CA  ARGA1   3      10.716   8.560   9.520  1.00200.00           C
ATOM     20  C   ARGA1   3      10.999   9.975  10.053  1.00200.00           C
ATOM     21  O   ARGA1   3      11.841  10.691   9.509  1.00200.00           O
ATOM     22  CB  ARGA1   3      12.026   7.778   9.276  1.00200.00           C
ATOM     23  CG  ARGA1   3      13.003   7.724  10.446  1.00200.00           C
ATOM     24  CD  ARGA1   3      12.400   7.099  11.694  1.00200.00           C
ATOM     25  NE  ARGA1   3      13.347   7.098  12.809  1.00200.00           N
ATOM     26  CZ  ARGA1   3      13.072   6.692  14.050  1.00200.00           C
ATOM     27  NH1 ARGA1   3      14.021   6.744  14.983  1.00200.00           N
ATOM     28  NH2 ARGA1   3      11.860   6.234  14.373  1.00200.00           N
ATOM     29  N   SERA1   4      10.310  10.351  11.133  1.00200.00           N
ATOM     30  CA  SERA1   4      10.354  11.730  11.665  1.00200.00           C
ATOM     31  C   SERA1   4      11.636  12.037  12.458  1.00200.00           C
ATOM     32  O   SERA1   4      12.139  11.164  13.169  1.00200.00           O
ATOM     33  CB  SERA1   4       9.136  12.007  12.554  1.00200.00           C
ATOM     34  OG  SERA1   4       9.282  11.419  13.837  1.00200.00           O
ATOM     35  N   PROA1   5      12.143  13.288  12.370  1.00200.00           N
ATOM     36  CA  PROA1   5      13.432  13.642  12.995  1.00200.00           C
ATOM     37  C   PROA1   5      13.413  13.900  14.515  1.00200.00           C
ATOM     38  O   PROA1   5      14.460  13.795  15.158  1.00200.00           O
ATOM     39  CB  PROA1   5      13.835  14.912  12.244  1.00200.00           C
ATOM     40  CG  PROA1   5      12.538  15.556  11.904  1.00200.00           C
ATOM     41  CD  PROA1   5      11.546  14.450  11.681  1.00200.00           C
ATOM     42  N   VALA1   6      12.247  14.236  15.074  1.00200.00           N
ATOM     43  CA  VALA1   6      12.086  14.442  16.521  1.00200.00           C
ATOM     44  C   VALA1   6      12.466  13.191  17.316  1.00200.00           C
ATOM     45  O   VALA1   6      12.902  13.293  18.463  1.00200.00           O
ATOM     46  CB  VALA1   6      10.646  14.895  16.873  1.00200.00           C
ATOM     47  CG1 VALA1   6       9.629  13.783  16.632  1.00200.00           C
ATOM     48  CG2 VALA1   6      10.564  15.418  18.305  1.00200.00           C
ATOM     49  N   GLUA1   7      12.275  12.023  16.699  1.00200.00           N
ATOM     50  CA  GLUA1   7      12.746  10.740  17.244  1.00200.00           C
ATOM     51  C   GLUA1   7      14.251  10.751  17.542  1.00200.00           C
ATOM     52  O   GLUA1   7      14.682  10.288  18.602  1.00200.00           O
ATOM     53  CB  GLUA1   7      12.428   9.594  16.274  1.00200.00           C
ATOM     54  CG  GLUA1   7      10.942   9.304  16.075  1.00200.00           C
ATOM     55  CD  GLUA1   7      10.255   8.692  17.292  1.00200.00           C
ATOM     56  OE1 GLUA1   7      10.945   8.223  18.225  1.00200.00           O
ATOM     57  OE2 GLUA1   7       9.006   8.674  17.310  1.00200.00           O
ATOM     58  N   ASPA1   8      15.029  11.281  16.597  1.00200.00           N
ATOM     59  CA  ASPA1   8      16.486  11.412  16.728  1.00200.00           C
ATOM     60  C   ASPA1   8      16.859  12.874  16.984  1.00200.00           C
ATOM     61  O   ASPA1   8      17.526  13.518  16.167  1.00200.00           O
ATOM     62  CB  ASPA1   8      17.181  10.885  15.466  1.00200.00           C
ATOM     63  CG  ASPA1   8      16.797   9.452  15.138  1.00200.00           C
ATOM     64  OD1 ASPA1   8      16.670   8.634  16.072  1.00200.00           O
ATOM     65  OD2 ASPA1   8      16.624   9.145  13.939  1.00200.00           O
ATOM     66  N   ALAA1   9      16.415  13.379  18.132  1.00200.00           N
ATOM     67  CA  ALAA1   9      16.603  14.784  18.516  1.00200.00           C
ATOM     68  C   ALAA1   9      17.351  14.937  19.844  1.00200.00           C
ATOM     69  O   ALAA1   9      17.283  14.063  20.712  1.00200.00           O
ATOM     70  CB  ALAA1   9      15.256  15.486  18.591  1.00200.00           C
ATOM     71  N   ASNA1  10      18.056  16.065  19.975  1.00200.00           N
ATOM     72  CA  ASNA1  10      18.795  16.429  21.183  1.00200.00           C
ATOM     73  C   ASNA1  10      18.003  17.403  22.070  1.00200.00           C
ATOM     74  O   ASNA1  10      17.219  18.228  21.577  1.00200.00           O
ATOM     75  CB  ASNA1  10      20.144  17.045  20.791  1.00200.00           C
ATOM     76  CG  ASNA1  10      21.141  17.087  21.939  1.00200.00           C
ATOM     77  OD1 ASNA1  10      20.945  16.476  22.991  1.00200.00           O
ATOM     78  ND2 ASNA1  10      22.228  17.814  21.732  1.00200.00           N
ATOM     79  N   CYSA1  11      18.240  17.302  23.378  1.00 20.00           N
ATOM     80  CA  CYSA1  11      17.509  18.064  24.406  1.00 20.00           C
ATOM     81  C   CYSA1  11      17.457  19.576  24.165  1.00 20.00           C
ATOM     82  O   CYSA1  11      16.456  20.218  24.484  1.00 20.00           O
ATOM     83  CB  CYSA1  11      18.093  17.773  25.796  1.00 20.00           C
ATOM     84  SG  CYSA1  11      19.900  17.783  25.877  1.00 20.00           S
ATOM     85  N   LEUA1  12      18.530  20.132  23.607  1.00 20.00           N
ATOM     86  CA  LEUA1  12      18.578  21.549  23.243  1.00 20.00           C
ATOM     87  C   LEUA1  12      17.781  21.794  21.968  1.00 20.00           C
ATOM     88  O   LEUA1  12      16.997  22.747  21.888  1.00 20.00           O
ATOM     89  CB  LEUA1  12      20.023  22.024  23.056  1.00 20.00           C
ATOM     90  CG  LEUA1  12      20.775  22.412  24.332  1.00 20.00           C
ATOM     91  CD1 LEUA1  12      21.100  21.195  25.188  1.00 20.00           C
ATOM     92  CD2 LEUA1  12      22.051  23.166  23.986  1.00 20.00           C
ATOM     93  N   SERA1  13      17.979  20.922  20.982  1.00 20.00           N
ATOM     94  CA  SERA1  13      17.342  21.072  19.672  1.00 20.00           C
ATOM     95  C   SERA1  13      15.823  20.970  19.753  1.00 20.00           C
ATOM     96  O   SERA1  13      15.111  21.701  19.049  1.00 20.00           O
ATOM     97  CB  SERA1  13      17.897  20.057  18.667  1.00 20.00           C
ATOM     98  OG  SERA1  13      17.826  18.736  19.165  1.00 20.00           O
ATOM     99  N   ARGA1  14      15.340  20.073  20.614  1.00 20.00           N
ATOM    100  CA  ARGA1  14      13.895  19.927  20.840  1.00 20.00           C
ATOM    101  C   ARGA1  14      13.283  21.099  21.632  1.00 20.00           C
ATOM    102  O   ARGA1  14      12.119  21.445  21.419  1.00 20.00           O
ATOM    103  CB  ARGA1  14      13.570  18.579  21.500  1.00 20.00           C
ATOM    104  CG  ARGA1  14      14.072  18.405  22.922  1.00 20.00           C
ATOM    105  CD  ARGA1  14      13.841  16.988  23.418  1.00 20.00           C
ATOM    106  NE  ARGA1  14      12.423  16.714  23.658  1.00 20.00           N
ATOM    107  CZ  ARGA1  14      11.935  15.592  24.195  1.00 20.00           C
ATOM    108  NH1 ARGA1  14      10.619  15.463  24.369  1.00 20.00           N
ATOM    109  NH2 ARGA1  14      12.742  14.594  24.564  1.00 20.00           N
ATOM    110  N   TYRA1  15      14.065  21.700  22.532  1.00 20.00           N
ATOM    111  CA  TYRA1  15      13.624  22.854  23.325  1.00 20.00           C
ATOM    112  C   TYRA1  15      13.416  24.094  22.457  1.00 20.00           C
ATOM    113  O   TYRA1  15      12.343  24.698  22.482  1.00 20.00           O
ATOM    114  CB  TYRA1  15      14.648  23.155  24.422  1.00 20.00           C
ATOM    115  CG  TYRA1  15      14.241  24.242  25.389  1.00 20.00           C
ATOM    116  CD1 TYRA1  15      13.524  23.941  26.547  1.00 20.00           C
ATOM    117  CD2 TYRA1  15      14.590  25.574  25.161  1.00 20.00           C
ATOM    118  CE1 TYRA1  15      13.156  24.935  27.445  1.00 20.00           C
ATOM    119  CE2 TYRA1  15      14.226  26.577  26.050  1.00 20.00           C
ATOM    120  CZ  TYRA1  15      13.510  26.254  27.191  1.00 20.00           C
ATOM    121  OH  TYRA1  15      13.147  27.244  28.077  1.00 20.00           O
ATOM    122  N   PHEA1  16      14.448  24.460  21.697  1.00 20.00           N
ATOM    123  CA  PHEA1  16      14.402  25.621  20.779  1.00 20.00           C
ATOM    124  C   PHEA1  16      13.776  25.358  19.393  1.00 20.00           C
ATOM    125  O   PHEA1  16      13.545  26.313  18.643  1.00 20.00           O
ATOM    126  CB  PHEA1  16      15.814  26.192  20.575  1.00 20.00           C
ATOM    127  CG  PHEA1  16      16.319  26.997  21.734  1.00 20.00           C
ATOM    128  CD1 PHEA1  16      16.018  28.349  21.840  1.00 20.00           C
ATOM    129  CD2 PHEA1  16      17.110  26.410  22.712  1.00 20.00           C
ATOM    130  CE1 PHEA1  16      16.490  29.099  22.909  1.00 20.00           C
ATOM    131  CE2 PHEA1  16      17.581  27.153  23.785  1.00 20.00           C
ATOM    132  CZ  PHEA1  16      17.272  28.501  23.883  1.00 20.00           C
ATOM    133  N   PHEA1  17      13.499  24.089  19.068  1.00 20.00           N
ATOM    134  CA  PHEA1  17      13.061  23.671  17.724  1.00 20.00           C
ATOM    135  C   PHEA1  17      14.112  23.971  16.634  1.00 20.00           C
ATOM    136  O   PHEA1  17      13.961  24.927  15.864  1.00 20.00           O
ATOM    137  CB  PHEA1  17      11.696  24.288  17.357  1.00 20.00           C
ATOM    138  CG  PHEA1  17      10.643  24.113  18.413  1.00 20.00           C
ATOM    139  CD1 PHEA1  17       9.834  22.986  18.423  1.00 20.00           C
ATOM    140  CD2 PHEA1  17      10.451  25.082  19.394  1.00 20.00           C
ATOM    141  CE1 PHEA1  17       8.855  22.825  19.394  1.00 20.00           C
ATOM    142  CE2 PHEA1  17       9.476  24.925  20.369  1.00 20.00           C
ATOM    143  CZ  PHEA1  17       8.675  23.795  20.370  1.00 20.00           C
ATOM    144  N   TRPA1  18      15.177  23.164  16.593  1.00 20.00           N
ATOM    145  CA  TRPA1  18      16.173  23.217  15.500  1.00 20.00           C
ATOM    146  C   TRPA1  18      15.755  22.365  14.287  1.00 20.00           C
ATOM    147  O   TRPA1  18      16.241  22.588  13.175  1.00 20.00           O
ATOM    148  CB  TRPA1  18      17.555  22.750  15.985  1.00 20.00           C
ATOM    149  CG  TRPA1  18      18.326  23.748  16.815  1.00 20.00           C
ATOM    150  CD1 TRPA1  18      17.963  24.262  18.026  1.00 20.00           C
ATOM    151  CD2 TRPA1  18      19.609  24.321  16.505  1.00 20.00           C
ATOM    152  NE1 TRPA1  18      18.931  25.126  18.488  1.00 20.00           N
ATOM    153  CE2 TRPA1  18      19.949  25.185  17.575  1.00 20.00           C
ATOM    154  CE3 TRPA1  18      20.499  24.197  15.427  1.00 20.00           C
ATOM    155  CZ2 TRPA1  18      21.145  25.922  17.598  1.00 20.00           C
ATOM    156  CZ3 TRPA1  18      21.692  24.933  15.451  1.00 20.00           C
ATOM    157  CH2 TRPA1  18      22.000  25.783  16.532  1.00 20.00           C
ATOM    158  N   TRPA1  19      14.858  21.401  14.508  1.00 20.00           N
ATOM    159  CA  TRPA1  19      14.551  20.352  13.512  1.00 20.00           C
ATOM    160  C   TRPA1  19      13.654  20.762  12.341  1.00 20.00           C
ATOM    161  O   TRPA1  19      13.665  20.095  11.303  1.00 20.00           O
ATOM    162  CB  TRPA1  19      13.982  19.092  14.183  1.00 20.00           C
ATOM    163  CG  TRPA1  19      12.647  19.247  14.852  1.00 20.00           C
ATOM    164  CD1 TRPA1  19      12.423  19.644  16.133  1.00 20.00           C
ATOM    165  CD2 TRPA1  19      11.359  18.966  14.289  1.00 20.00           C
ATOM    166  NE1 TRPA1  19      11.079  19.648  16.401  1.00 20.00           N
ATOM    167  CE2 TRPA1  19      10.400  19.233  15.289  1.00 20.00           C
ATOM    168  CE3 TRPA1  19      10.921  18.522  13.036  1.00 20.00           C
ATOM    169  CZ2 TRPA1  19       9.025  19.072  15.080  1.00 20.00           C
ATOM    170  CZ3 TRPA1  19       9.548  18.359  12.825  1.00 20.00           C
ATOM    171  CH2 TRPA1  19       8.619  18.635  13.845  1.00 20.00           C
ATOM    172  N   THRA1  20      12.893  21.842  12.494  1.00 20.00           N
ATOM    173  CA  THRA1  20      12.024  22.334  11.408  1.00 20.00           C
ATOM    174  C   THRA1  20      12.757  22.960  10.196  1.00 20.00           C
ATOM    175  O   THRA1  20      12.143  23.126   9.131  1.00 20.00           O
ATOM    176  CB  THRA1  20      10.981  23.340  11.942  1.00 20.00           C
ATOM    177  OG1 THRA1  20      11.638  24.387  12.665  1.00 20.00           O
ATOM    178  CG2 THRA1  20       9.986  22.643  12.860  1.00 20.00           C
""".splitlines()


def get_b_and_occ(hierarchy=None,atom_selection=None):
  atom_selection="name CA and (resid 5 or resid 15)"
  asc1=hierarchy.atom_selection_cache()
  sel1 = asc1.selection(string = atom_selection)
  b_values=list(hierarchy.select(sel1).atoms().extract_b())
  resolutions=list(hierarchy.select(sel1).atoms().extract_occ())
  return b_values,resolutions

def make_map_from_pdb(raw_records=None,set_b_iso=None):
    pdb_inp = iotbx.pdb.input(source_info=None, lines=raw_records)
    ph = pdb_inp.construct_hierarchy()
    xrs = pdb_inp.xray_structure_simple()
    if set_b_iso:
      xrs.set_b_iso(value=set_b_iso)
    crystal_symmetry=xrs.crystal_symmetry()
    fc = xrs.structure_factors(d_min = 3, algorithm = "direct").f_calc()
    fft_map = fc.fft_map(resolution_factor = 0.25)
    fft_map.apply_sigma_scaling()
    map_data = fft_map.real_map_unpadded()
    # Create model instead of pdb_hierarchy
    ph.adopt_xray_structure(xrs)
    import mmtbx.model
    model=mmtbx.model.manager(
          model_input=None,
          pdb_hierarchy = ph,
          crystal_symmetry = crystal_symmetry)
    return model,map_data,crystal_symmetry

def tst_0():
  model,map_data,crystal_symmetry=make_map_from_pdb(raw_records=raw_records)
  mm = map_manager.map_manager(
    map_data                   = map_data,
    unit_cell_crystal_symmetry = crystal_symmetry,
    unit_cell_grid             = map_data.all(),
    wrapping                   = False)
  mmm = map_model_manager.map_model_manager(model = model, map_manager = mm)

  method="rscc"
  r  = maptbx.loc_res(
    map_model_manager = mmm,
    method            = method)
  assert  approx_equal([r.result[0], r.result[-1]], [9.7, 3.1], eps=.05)

  method = "fsc"
  r  = maptbx.loc_res(
    map_model_manager = mmm,
    method            = method)
  assert  approx_equal(sorted([round(r,1) for r in set(r.result)]), [1.9, 5.2], eps=.05)

def tst_1():
  for set_b_iso,expected_b_values,expected_occs in zip(
     [-200,0,200],
     [[200.0, 200.0],[-20.0, -20.0],[-160.0, -180.0]],
     [[3.0, 3.0],[3.4, 3.0],[3.2, 3.1]]   ):

    model,map_data,crystal_symmetry=make_map_from_pdb(raw_records=raw_records_2,
     set_b_iso=set_b_iso)

    mm = map_manager.map_manager(
      map_data                   = map_data,
      unit_cell_crystal_symmetry = crystal_symmetry,
      unit_cell_grid             = map_data.all(),
      wrapping                   = False)
    mmm = map_model_manager.map_model_manager(model = model, map_manager = mm)

    method = "rscc_d_min_b"
    r  = maptbx.loc_res(
      map_model_manager = mmm,
      method            = method,
      b_min             = -1000,
      b_max             = 1000,
      b_step            = 1)
    print("result:", list(set(r.result)), "expected:", expected_occs)

if (__name__ == "__main__"):
  tst_0()
  tst_1()
  print("OK")


 *******************************************************************************


 *******************************************************************************
cctbx/regression/tst_map_is_periodic.py
from __future__ import absolute_import, division, print_function

from cctbx.development import random_structure
from cctbx.sgtbx import space_group_info
from six.moves import range
from cctbx_asymmetric_map_ext import *
from cctbx.array_family import flex
from cctbx import maptbx
import random
from cctbx.maptbx import is_periodic

if (1):
  kk=0
  random.seed(kk)
  flex.set_random_seed(kk)

def run(single_side=False, quick=True):
  result = flex.bool()
  periodic_list=[]
  aperiodic_list=[]
  if quick:
    rf_list=[0.33]
  else:
    rf_list=[0.33, 0.48, ]
  for resolution_factor in rf_list:
   for sgn in range(1,231):
    kk=random.randint(1,99999)
    random.seed(kk)
    flex.set_random_seed(kk)
    group = space_group_info(sgn)
    xrs = random_structure.xray_structure(
      space_group_info       = group,
      volume_per_atom        = 25.,
      general_positions_only = False,
      elements               = ('C', 'N', 'O', 'H')*30,
      min_distance           = 1.0)
    sgt = xrs.space_group().type()
    fc = xrs.structure_factors(d_min=2).f_calc()
    fft_map = fc.fft_map(symmetry_flags = maptbx.use_space_group_symmetry,
      resolution_factor=resolution_factor)
    map_data = fft_map.real_map_unpadded()
    xx=is_periodic(map_data)
    periodic_list.append(xx)
    assert xx in [True,None]

    # Now cut off edges and should not work:
    min_size=int(flex.double(map_data.all()).min_max_mean().min)
    assert min_size >= 12
    if quick:
      range_to_use=[1]
      k_list=[1]
    else:
      range_to_use=list(range(1,max(2,min(10,1+min_size//12))))
      k_list=[0,1]
    for i in range_to_use:
     for k in k_list:
      if single_side:
        lower_bounds=(k,k,k)
        upper_bounds=tuple([x - i - 1 for x in map_data.all()])
      else:
        lower_bounds=(k,k,k)
        upper_bounds=(map_data.all()[0]-i-1,map_data.all()[1],map_data.all()[2])

      map_box = maptbx.copy(map_data,
       lower_bounds,upper_bounds)
      new_map_box=map_box.shift_origin()
      xx=is_periodic(new_map_box)
      aperiodic_list.append(xx)
      assert xx in [False,None]


  print ("For periodic.. True:",periodic_list.count(True),
     "None:",periodic_list.count(None)," False:",periodic_list.count(False))
  print ("For aperiodic.. True:",aperiodic_list.count(True),
     "None:",aperiodic_list.count(None)," False:",aperiodic_list.count(False))
  assert periodic_list.count(False) == 0
  assert periodic_list.count(None) <= 0.05 * len(periodic_list)
  assert aperiodic_list.count(True) == 0
  assert aperiodic_list.count(None) <= 0.05 * len(aperiodic_list)

if (__name__ == "__main__"):
  run()
  print ("OK")


 *******************************************************************************


 *******************************************************************************
cctbx/regression/tst_map_weights_for_symmetry_summation.py
"""\
Essence of bulk-solvent mask calculation, testing interaction of
symmetry summation in maptbx.structure_factors.from_map with handling
of grid points. This script demonstrates that grid points redundant
under symmetry must be kept at zero and that all grid points inside
the asu have to be weighted by site-multiplicity/order_z.
As an aside, this script also exercises space_group.multiplicity(site).
"""

from __future__ import absolute_import, division, print_function
from cctbx import maptbx
from cctbx import miller
from cctbx import sgtbx
from cctbx.development import debug_utils
from scitbx import fftpack
from scitbx.array_family import flex
from libtbx.math_utils import iround
from libtbx.test_utils import approx_equal
from libtbx.utils import n_dim_index_from_one_dim
import boost_adaptbx.boost.rational
import random
from six.moves import zip

def exercise(space_group_info, redundancy_counter=0):
  n_real = (12,12,12)
  miller_max = (2,2,2)
  gt = maptbx.grid_tags(n_real)
  uc = space_group_info.any_compatible_unit_cell(volume=1000)
  fl = sgtbx.search_symmetry_flags(use_space_group_symmetry=True)
  gt.build(space_group_info.type(), fl)
  fft = fftpack.real_to_complex_3d(n_real)
  map0 = flex.double(flex.grid(fft.m_real()).set_focus(fft.n_real()), 0)
  weight_map = map0.deep_copy()
  map = map0.deep_copy()
  ta = gt.tag_array()
  order_z = space_group_info.group().order_z()
  problems_expected = (redundancy_counter != 0)
  for ijk in flex.nested_loop(n_real):
    t = ta[ijk]
    if (t < 0):
      xyz = [i/n for i,n in zip(ijk, n_real)]
      ss = sgtbx.site_symmetry(
        unit_cell=uc,
        space_group=space_group_info.group(),
        original_site=xyz,
        min_distance_sym_equiv=1e-5)
      m = space_group_info.group().multiplicity(
        site=boost_adaptbx.boost.rational.vector(ijk, n_real))
      assert m == ss.multiplicity()
      w = m / order_z
      weight_map[ijk] = w
      map[ijk] = w
    elif (redundancy_counter != 0):
      redundancy_counter -= 1
      ijk_asu = n_dim_index_from_one_dim(i1d=t, sizes=n_real)
      assert ta.accessor()(ijk_asu) == t
      map[ijk] = map[ijk_asu]
  sf_map = fft.forward(map)
  del map
  mi = miller.index_generator(
    space_group_info.type(), False, miller_max).to_array()
  assert mi.size() != 0
  from_map = maptbx.structure_factors.from_map(
    space_group=space_group_info.group(),
    anomalous_flag=False,
    miller_indices=mi,
    complex_map=sf_map,
    conjugate_flag=True)
  sf = [iround(abs(f)) for f in from_map.data()]
  if (sf != [0]*len(sf)):
    assert problems_expected
    return
  else:
    not problems_expected
  #
  map_p1 = map0.deep_copy()
  map_sw = map0.deep_copy()
  for ijk in flex.nested_loop(n_real):
    t = ta[ijk]
    if (t < 0):
      v = random.random()*2-1
      map_p1[ijk] = v
      map_sw[ijk] = v * weight_map[ijk]
    else:
      ijk_asu = n_dim_index_from_one_dim(i1d=t, sizes=n_real)
      assert ta.accessor()(ijk_asu) == t
      assert map_p1[ijk_asu] != 0
      map_p1[ijk] = map_p1[ijk_asu]
  #
  # fft followed by symmetry summation in reciprocal space
  sf_map_sw = fft.forward(map_sw)
  del map_sw
  sf_sw = maptbx.structure_factors.from_map(
    space_group=space_group_info.group(),
    anomalous_flag=False,
    miller_indices=mi,
    complex_map=sf_map_sw,
    conjugate_flag=True).data()
  del sf_map_sw
  #
  # symmetry expansion in real space (done above already) followed fft
  sf_map_p1 = fft.forward(map_p1)
  del map_p1
  sf_p1 = maptbx.structure_factors.from_map(
    space_group=sgtbx.space_group(),
    anomalous_flag=False,
    miller_indices=mi,
    complex_map=sf_map_p1,
    conjugate_flag=True).data()
  del sf_map_p1
  #
  corr = flex.linear_correlation(x=flex.abs(sf_sw), y=flex.abs(sf_p1))
  assert corr.is_well_defined
  assert approx_equal(corr.coefficient(), 1)

def run_call_back(flags, space_group_info):
  exercise(space_group_info=space_group_info)

def run(args):
  exercise(
    space_group_info=sgtbx.space_group_info(symbol="P222"),
    redundancy_counter=1)
  debug_utils.parse_options_loop_space_groups(args, run_call_back)

if (__name__ == "__main__"):
  import sys
  run(args=sys.argv[1:])


 *******************************************************************************


 *******************************************************************************
cctbx/regression/tst_maptbx_box.py
from __future__ import absolute_import, division, print_function
import os
import iotbx.pdb
from libtbx.test_utils import approx_equal
from cctbx.sgtbx import space_group_info
from cctbx.development import random_structure
import cctbx.maptbx.box
from libtbx import group_args
import iotbx.pdb
from iotbx.map_manager import map_manager
from iotbx.map_model_manager import map_model_manager
from iotbx.data_manager import DataManager
import mmtbx.model
from scitbx.array_family import flex
import libtbx.load_env

def get_random_structure_and_map(
   use_static_structure = False,
   random_seed = 171413,
  ):

  if use_static_structure:
    mmm = map_model_manager()
    mmm.generate_map()
    return group_args(model = mmm.model(), mm = mmm.map_manager())
  import random
  random.seed(random_seed)
  i = random.randint(1, 714717)
  flex.set_random_seed(i)

  xrs = random_structure.xray_structure(
    space_group_info = space_group_info(19),
    volume_per_atom  = 25.,
    elements         = ('C', 'N', 'O', 'H')*10,
    min_distance     = 1.5)
  fc = xrs.structure_factors(d_min = 2).f_calc()
  fft_map = fc.fft_map(resolution_factor = 0.25)
  fft_map.apply_volume_scaling()
  ph = iotbx.pdb.input(
    source_info = None, lines = xrs.as_pdb_file()).construct_hierarchy()
  ph.atoms().set_xyz(xrs.sites_cart())
  map_data = fft_map.real_map_unpadded()
  mm = map_manager(
    unit_cell_grid             = map_data.accessor().all(),
    unit_cell_crystal_symmetry = fc.crystal_symmetry(),
    origin_shift_grid_units    = (0, 0, 0),
    map_data                   = map_data)
  model = mmtbx.model.manager(
    model_input = None, pdb_hierarchy = ph, crystal_symmetry = fc.crystal_symmetry())
  return group_args(model = model, mm = mm)

def exercise_around_model():

  from cctbx.maptbx.box import make_list_symmetric
  a=[3,4,5,3,9,1,6,3,2,5,6,6]
  new_a=make_list_symmetric(a)
  from scitbx.array_family import flex
  aa=flex.double(a)
  new_aa=flex.double(new_a)
  assert (aa.size(),new_aa.size())== (12, 12)
  assert aa.min_max_mean().mean == new_aa.min_max_mean().mean
  print (a,new_a)

  a=[3,4,5,3,8,1,6,7,3,2,5,6,6]
  new_a=make_list_symmetric(a)
  from scitbx.array_family import flex
  aa=flex.double(a)
  new_aa=flex.double(new_a)
  print (a,new_a)
  assert (aa.size(),new_aa.size())== (13, 13)
  assert aa.min_max_mean().mean == new_aa.min_max_mean().mean

  mam = get_random_structure_and_map(use_static_structure = True)

  map_data_orig   = mam.mm.map_data().deep_copy()
  sites_frac_orig = mam.model.get_sites_frac().deep_copy()
  sites_cart_orig = mam.model.get_sites_cart().deep_copy()
  cs_orig         = mam.model.crystal_symmetry()

  box = cctbx.maptbx.box.around_model(
    map_manager = mam.mm,
    model       = mam.model.deep_copy(),
    box_cushion     = 10,
    wrapping    = True)
  new_mm1 = box.map_manager()
  new_mm2 = box.apply_to_map(map_manager = mam.mm.deep_copy())
  assert approx_equal(new_mm1.map_data(), new_mm2.map_data())

  new_model1 = box.model()
  new_model2 = box.apply_to_model(model = mam.model.deep_copy())
  assert new_model1.crystal_symmetry().is_similar_symmetry(
         new_model2.crystal_symmetry())
  assert new_model1.crystal_symmetry().is_similar_symmetry(
         box.crystal_symmetry)

  assert approx_equal(new_model1.get_sites_cart()[0], (19.705233333333336, 15.631525, 13.5040625))
  # make sure things did change
  assert new_mm2.map_data().size() !=  map_data_orig.size()

  # make sure things are changed in-place and are therefore different from start
  assert box.map_manager().map_data().size() !=  map_data_orig.size()
  assert box.model().get_sites_frac() !=  sites_frac_orig
  assert box.model().get_sites_cart() !=   sites_cart_orig
  assert (not cs_orig.is_similar_symmetry(box.model().crystal_symmetry()))

  # make sure box, model and map_manager remember original crystal symmetry
  assert cs_orig.is_similar_symmetry(box.map_manager().unit_cell_crystal_symmetry())
  assert cs_orig.is_similar_symmetry(
    box.map_manager().unit_cell_crystal_symmetry())

  assert approx_equal (box.model().shift_cart(),
     [5.229233333333334, 5.061524999999999, 5.162062499999999])

  assert box.model().unit_cell_crystal_symmetry().is_similar_symmetry(cs_orig)
  assert (not box.model().crystal_symmetry().is_similar_symmetry(cs_orig))

  assert approx_equal(
     box.model()._figure_out_hierarchy_to_output(do_not_shift_back = False
       ).atoms().extract_xyz()[0],
        (14.476, 10.57, 8.342))

  # make sure we can stack shifts
  sel = box.model().selection("resseq 219:219")
  m_small = box.model().select(selection = sel)

  assert approx_equal(box.model().shift_cart(),
     m_small.shift_cart())

  # Now box again:
  small_box = cctbx.maptbx.box.around_model(
    map_manager = mam.mm,
    model       = mam.model.deep_copy(),
    box_cushion     = 5,
    wrapping    = True)

  # Make sure nothing was zeroed out in this map (wrapping = True)
  assert new_mm1.map_data().as_1d().count(0) == 0

  # Now without wrapping...
  box = cctbx.maptbx.box.around_model(
    map_manager = mam.mm,
    model       = mam.model.deep_copy(),
    box_cushion     = 10,
    wrapping    = False)

  # make sure things are changed in-place and are therefore different from start
  assert box.map_manager().map_data().size() !=  map_data_orig.size()
  assert box.model().get_sites_frac() !=  sites_frac_orig
  assert box.model().get_sites_cart() !=   sites_cart_orig
  assert (not cs_orig.is_similar_symmetry(box.model().crystal_symmetry()))

  # make sure box, model and map_manager remember original crystal symmetry
  assert cs_orig.is_similar_symmetry(box.model().unit_cell_crystal_symmetry())
  assert cs_orig.is_similar_symmetry(
    box.map_manager().unit_cell_crystal_symmetry())

  assert box.map_manager().map_data().as_1d().count(0) == 81264

  # Now specify bounds directly
  new_box = cctbx.maptbx.box.with_bounds(
    map_manager = mam.mm.deep_copy(),
    lower_bounds =  (-7, -7, -7),
    upper_bounds =  (37, 47, 39),
    wrapping    = False)

  new_model = new_box.apply_to_model(mam.model.deep_copy())
  # make sure things are changed in-place and are therefore different from start
  assert new_box.map_manager().map_data().size() !=  map_data_orig.size()
  assert new_model.get_sites_frac() !=  sites_frac_orig
  assert new_model.get_sites_cart() !=   sites_cart_orig
  assert (not cs_orig.is_similar_symmetry(new_model.crystal_symmetry()))

  # make sure box, model and map_manager remember original crystal symmetry
  assert cs_orig.is_similar_symmetry(box.model().unit_cell_crystal_symmetry())
  assert cs_orig.is_similar_symmetry(
    box.map_manager().unit_cell_crystal_symmetry())

  assert box.map_manager().map_data().as_1d().count(0) == 81264

  # Now specify bounds directly and init with model
  box = cctbx.maptbx.box.with_bounds(
    map_manager = mam.mm.deep_copy(),
    lower_bounds =  (-7, -7, -7),
    upper_bounds =  (37, 47, 39),
    wrapping    = False,
    model = mam.model.deep_copy())

  new_model = box.model()
  # make sure things are changed in-place and are therefore different from start
  assert box.map_manager().map_data().size() !=  map_data_orig.size()
  assert new_model.get_sites_frac() !=  sites_frac_orig
  assert new_model.get_sites_cart() !=   sites_cart_orig
  assert (not cs_orig.is_similar_symmetry(new_model.crystal_symmetry()))

  # make sure box, model and map_manager remember original crystal symmetry
  assert cs_orig.is_similar_symmetry(box.model().unit_cell_crystal_symmetry())
  assert cs_orig.is_similar_symmetry(
    box.map_manager().unit_cell_crystal_symmetry())

  assert box.map_manager().map_data().as_1d().count(0) == 81264

  # Extract using around_unique

  data_dir = os.path.dirname(os.path.abspath(__file__))
  data_ccp4 = os.path.join(data_dir, 'data', 'D7.ccp4')
  data_ncs =  os.path.join(data_dir, 'data', 'D7.ncs_spec')
  data_seq =  os.path.join(data_dir, 'data', 'D7.seq')

  dm = DataManager(['real_map', 'phil', 'ncs_spec', 'sequence'])
  dm.process_real_map_file(data_ccp4)
  mm = dm.get_real_map(data_ccp4)

  dm.process_ncs_spec_file(data_ncs)
  ncs_obj = dm.get_ncs_spec(data_ncs)

  dm.process_sequence_file(data_seq)
  sequence = dm.get_sequence(data_seq)
  sequence_as_text = sequence[0].sequence

  map_model_mgr=map_model_manager(map_manager=mm,ncs_object=ncs_obj)
  mm=map_model_mgr.map_manager()
  mm.show_summary()

  box = cctbx.maptbx.box.around_unique(
    map_manager = mm.deep_copy(),
    resolution = 3,
    box_cushion = 1,
    sequence = sequence_as_text,
    soft_mask = True,
    wrapping    = False,
   )

  box.map_manager().write_map('new_box.ccp4')

  # run again from map_manager

  map_model_mgr.box_all_maps_around_unique_and_shift_origin(
    resolution = 3,
    box_cushion= 1,
    sequence = sequence_as_text,
    soft_mask = True,
   )

  # Get bounds around density
  box = cctbx.maptbx.box.around_density(
    map_manager = mam.mm.deep_copy(),
    wrapping = False)

  # Create a mask

  mm = mam.mm.deep_copy()

  mm.create_mask_around_density(
        resolution = 3,
        molecular_mass = 2100,
        sequence = "GAVAGA",
        solvent_content = 0.5,
        )
  mask_mm = mm.get_mask_as_map_manager()
  assert approx_equal(
     (mask_mm.map_data().count(0), mask_mm.map_data().count(1),
      mask_mm.map_data().size()),
     (19184, 19216, 38400))

  # Box around the mask
  box = cctbx.maptbx.box.around_mask(
    map_manager = mam.mm.deep_copy(),
    mask_as_map_manager = mask_mm,
    wrapping = False,
    )

  assert (box.gridding_first, box.gridding_last) == ([0, 0, 0] , [29, 39, 31])

  # Box around the mask with cubic box
  box = cctbx.maptbx.box.around_mask(
    map_manager = mam.mm.deep_copy(),
    mask_as_map_manager = mask_mm,
    use_cubic_boxing = True,
    wrapping = False,
    )

  assert (box.gridding_first, box.gridding_last) == ([1, 6, 2], [30, 35, 31])

  #
  # IF you are about to change this - THINK TWICE!
  #
  from libtbx.introspection import getfullargspec
  r = getfullargspec(cctbx.maptbx.box.around_model.__init__)
  assert sorted(r.args)  == sorted(
        ['self', 'map_manager', 'model', 'box_cushion',
        'wrapping', 'model_can_be_outside_bounds', 'stay_inside_current_map',
        'use_cubic_boxing', 'require_match_unit_cell_crystal_symmetry',
        'log']), r.args
  r = getfullargspec(cctbx.maptbx.box.with_bounds.__init__)
  assert sorted(r.args)  ==  sorted(
       ['self', 'map_manager', 'lower_bounds', 'upper_bounds',
        'model', 'wrapping', 'model_can_be_outside_bounds',
        'stay_inside_current_map', 'use_cubic_boxing',
        'require_match_unit_cell_crystal_symmetry', 'log']), r.args

  print ("OK")

if (__name__  ==  "__main__"):
  if libtbx.env.has_module('phenix'):
    exercise_around_model()
  else:
    print('phenix is not available, skipping test')


 *******************************************************************************


 *******************************************************************************
cctbx/regression/tst_maptbx_mask.py
from __future__ import absolute_import, division, print_function
from libtbx.test_utils import approx_equal
from scitbx.array_family import flex
from iotbx.map_model_manager import map_model_manager
from libtbx import group_args

def get_random_structure_and_map(
   use_static_structure = False,
   random_seed = 171413,
  ):

  if use_static_structure:
    mmm = map_model_manager()
    mmm.generate_map()
    return group_args(model = mmm.model(), mm = mmm.map_manager())
  import random
  random.seed(random_seed)
  i = random.randint(1, 714717)
  flex.set_random_seed(i)

  xrs = random_structure.xray_structure(
    space_group_info = space_group_info(19),
    volume_per_atom  = 25.,
    elements         = ('C', 'N', 'O', 'H')*10,
    min_distance     = 1.5)
  fc = xrs.structure_factors(d_min = 2).f_calc()
  fft_map = fc.fft_map(resolution_factor = 0.25)
  fft_map.apply_volume_scaling()
  ph = iotbx.pdb.input(
    source_info = None, lines = xrs.as_pdb_file()).construct_hierarchy()
  ph.atoms().set_xyz(xrs.sites_cart())
  map_data = fft_map.real_map_unpadded()
  mm = map_manager(
    unit_cell_grid             = map_data.accessor().all(),
    unit_cell_crystal_symmetry = fc.crystal_symmetry(),
    origin_shift_grid_units    = (0, 0, 0),
    map_data                   = map_data)
  model = mmtbx.model.manager(
    model_input = None, pdb_hierarchy = ph, crystal_symmetry = fc.crystal_symmetry())
  return group_args(model = model, mm = mm)

def exercise_mask():
  mam = get_random_structure_and_map(use_static_structure = True)
  mm_orig = mam.mm.deep_copy()
  map_data_orig   = mam.mm.map_data().deep_copy()
  assert map_data_orig.origin() == (0, 0, 0)
  sites_frac_orig = mam.model.get_sites_frac().deep_copy()
  sites_cart_orig = mam.model.get_sites_cart().deep_copy()
  cs_orig         = mam.model.crystal_symmetry()

  # Create mask with gridding supplied
  from cctbx.maptbx.mask import create_mask_around_atoms
  cm = create_mask_around_atoms(model = mam.model,
     mask_atoms_atom_radius = 3,
     n_real = mam.mm.map_data().all(),
     wrapping = mam.mm.wrapping())

  new_mask = cm.mask()
  assert (new_mask.count(0), new_mask.count(1), new_mask.size()) == (31852, 6548, 38400)

  cm.soft_mask(soft_mask_radius = 5)
  new_mask = cm.mask()
  assert (new_mask.count(0), new_mask.count(1), new_mask.size()) == (0, 0, 38400)
  assert approx_equal( (new_mask[0], new_mask[100]), (0.0232240949563, 0.0216530808725))

  # Create mask starting with a map_manager object
  cm = create_mask_around_atoms(model = mam.model,
     mask_atoms_atom_radius = 3,
     map_manager = mam.mm)
  assert mm_orig.map_data().origin() == (0, 0, 0)

  new_mm = cm.apply_mask_to_other_map_manager(mm_orig)
  new_map_data = new_mm.map_data()
  assert approx_equal( (new_map_data[5215], new_map_data[8432]), (0.0, -0.0514926330954))

  new_mm = cm.apply_mask_to_other_map_manager(mm_orig,
     set_outside_to_mean_inside = True)
  new_map_data = new_mm.map_data()
  assert approx_equal( (new_map_data[5215], new_map_data[8432]), (0.0646441178021, -0.0514926330954))

  # Create mask using n_real and check applying mask
  cm = create_mask_around_atoms(model = mam.model,
     mask_atoms_atom_radius = 3,
     n_real = mam.mm.map_data().all(),
     wrapping = mam.mm.wrapping())
  assert mm_orig.map_data().origin() == (0, 0, 0)

  new_mm = cm.apply_mask_to_other_map_manager(mm_orig,
     set_outside_to_mean_inside = True)
  new_map_data = new_mm.map_data()
  assert approx_equal( (new_map_data[5215], new_map_data[8432]), (0.0646441178021, -0.0514926330954))

  # Create mask using map_manager object
  mm = mm_orig.deep_copy()
  orig_map = mm.map_data().deep_copy()
  mm.create_mask_around_atoms(
    model = mam.model,
    mask_atoms_atom_radius = 3)
  mm.soft_mask(soft_mask_radius = 5)
  mm.apply_mask()
  new_map = mm.map_data()
  assert approx_equal(
    ( orig_map[5215], orig_map[8432], new_map[5215], orig_map[8432]),
    (-0.012385224860014447, -0.05149263309541403, -0.0004143453062615644,
        -0.05149263309541403)
    )

  # create mask around edges
  mm = mm_orig.deep_copy()
  orig_map = mm.map_data().deep_copy()
  mm.create_mask_around_edges(
    soft_mask_radius = 5)
  mm.soft_mask(soft_mask_radius = 5)
  mm.apply_mask()
  new_map = mm.map_data()
  assert approx_equal( (orig_map[0], new_map[0]),
     (-0.0071372973593,-0.00204624804668))
  assert approx_equal(
   ( orig_map[5215], orig_map[8432], new_map[5215], orig_map[8432]),
  (-0.01238522486, -0.0514926330954, -0.00401527420775, -0.0514926330954))


  # auto-generate mask
  mm = mm_orig.deep_copy()
  orig_map = mm.map_data().deep_copy()
  mm.create_mask_around_density(
    resolution = 3,
    molecular_mass = 2000,
    sequence = 'AVAGS',
    solvent_content = None)
  mask_mm = mm.get_mask_as_map_manager()
  mask_data = mask_mm.map_data()
  print ("Mask zero/one: ",
     mask_data.count(0), mask_data.count(1), mask_data.size())
  assert approx_equal ((mask_data.count(0), mask_data.count(1), mask_data.size()),
    (36705, 1695, 38400))

  mm.apply_mask()
  new_map = mm.map_data()
  print( "Map values before/after mask:",
       orig_map[4322], orig_map[9680], new_map[4322], new_map[9680]),
  assert approx_equal(
     (orig_map[4322], orig_map[9680], new_map[4322], new_map[9680]),
    (-0.0214128152846, -0.0249896972752, 0.0, -0.0249896972752))


  # create zero_boundary_mask

  map_data=mm.map_data()
  mean=map_data.as_1d().min_max_mean().mean
  sd=map_data.as_1d().standard_deviation_of_the_sample()

  from cctbx.maptbx import binary_filter
  bf=binary_filter(map_data,mean+sd).result()
  direct_mask_mm=mm.customized_copy(map_data=bf)

  map_data=mm.map_data()
  mean=map_data.as_1d().min_max_mean().mean
  sd=map_data.as_1d().standard_deviation_of_the_sample()

  manager_mask_mm=mm.binary_filter(mean+sd)
  mam=map_model_manager(map_manager_1=direct_mask_mm,map_manager_2=manager_mask_mm)
  assert approx_equal(mam.map_map_cc(map_id='map_manager_1',other_map_id='map_manager_2'),1)


if (__name__  ==  "__main__"):
  exercise_mask()


 *******************************************************************************


 *******************************************************************************
cctbx/regression/tst_maptbx_structure_factors.py
from __future__ import absolute_import, division, print_function
from cctbx import maptbx
from cctbx import crystal
from cctbx import sgtbx
from cctbx.development import random_structure
from cctbx.development import debug_utils
from cctbx.array_family import flex
from scitbx import fftpack
from libtbx.test_utils import approx_equal
import sys
from six.moves import range

def exercise_crystal_gridding():
  crystal_symmetry = crystal.symmetry(
    unit_cell=(95.2939, 95.2939, 98.4232, 94.3158, 115.226, 118.822),
    space_group_symbol="Hall: C 2y (x+y,-x+y+z,z)")
  for mandatory_factors,n_real in ((None,(90,90,90)),
                                   ((20,20,20),(100,100,100))):
    crystal_gridding = maptbx.crystal_gridding(
      unit_cell=crystal_symmetry.unit_cell(),
      d_min=3.5,
      resolution_factor=1/3.,
      symmetry_flags=maptbx.use_space_group_symmetry,
      space_group_info=crystal_symmetry.space_group_info(),
      mandatory_factors=mandatory_factors,
      max_prime=5,
      assert_shannon_sampling=True)
    assert crystal_gridding.n_real() == n_real

def exercise_f000():
  miller_indices = flex.miller_index([(0,0,0)])
  data = flex.complex_double([1-2j])
  n_real = [1,2,3]
  conjugate_flag = True
  for hall_symbol in ["P 1", "P 3", "R 3*"]:
    for is_centric in [False, True]:
      if (not is_centric):
        space_group = sgtbx.space_group(hall_symbol)
      else:
        space_group.expand_smx("-x,-y,-z")
      for anomalous_flag in [False, True]:
        if (not anomalous_flag):
          rfft = fftpack.real_to_complex_3d(n_real)
          n_complex = rfft.n_complex()
        else:
          cfft = fftpack.complex_to_complex_3d(n_real)
          n_complex = cfft.n()
        for treat_restricted in [False, True]:
          map = maptbx.structure_factors.to_map(
            space_group=space_group,
            anomalous_flag=anomalous_flag,
            miller_indices=miller_indices,
            structure_factors=data,
            n_real=n_real,
            map_grid=flex.grid(n_complex),
            conjugate_flag=conjugate_flag,
            treat_restricted=treat_restricted)
          if (treat_restricted):
            assert approx_equal(
              map.complex_map()[0], data[0])
          else:
            assert approx_equal(
              map.complex_map()[0], data[0]*space_group.order_p())

def exercise_shannon_sampled(space_group_info, anomalous_flag, conjugate_flag,
                             d_min=3., resolution_factor=0.5, max_prime=5,
                             verbose=0):
  structure = random_structure.xray_structure(
    space_group_info,
    elements=("N", "C", "C", "O"),
    random_f_prime_d_min=1,
    random_f_double_prime=anomalous_flag,
    use_u_aniso=True,
    random_u_iso=True,
    random_occupancy=True)
  f_calc = structure.structure_factors(
    anomalous_flag=anomalous_flag,
    d_min=d_min,
    algorithm="direct").f_calc()
  n_real = f_calc.crystal_gridding(
    resolution_factor=resolution_factor,
    d_min=d_min,
    max_prime=max_prime).n_real()
  if (not anomalous_flag):
    rfft = fftpack.real_to_complex_3d(n_real)
    n_complex = rfft.n_complex()
  else:
    cfft = fftpack.complex_to_complex_3d(n_real)
    n_complex = cfft.n()
  map = maptbx.structure_factors.to_map(
    space_group=f_calc.space_group(),
    anomalous_flag=anomalous_flag,
    miller_indices=f_calc.indices(),
    structure_factors=f_calc.data(),
    n_real=n_real,
    map_grid=flex.grid(n_complex),
    conjugate_flag=conjugate_flag)
  f_calc_p1 = f_calc.expand_to_p1()
  map_p1 = maptbx.structure_factors.to_map(
    space_group=f_calc_p1.space_group(),
    anomalous_flag=anomalous_flag,
    miller_indices=f_calc_p1.indices(),
    structure_factors=f_calc_p1.data(),
    n_real=n_real,
    map_grid=flex.grid(n_complex),
    conjugate_flag=conjugate_flag)
  assert flex.max(flex.abs(map_p1.complex_map() - map.complex_map())) < 1.e-10
  if (not anomalous_flag):
    real_map = rfft.backward(map.complex_map())
    assert real_map.all() == rfft.m_real()
    complex_map = rfft.forward(real_map)
  else:
    real_map = cfft.backward(map.complex_map())
    assert not real_map.is_padded()
    complex_map = cfft.forward(real_map)
  complex_map /= n_real[0] * n_real[1] * n_real[2]
  assert real_map.focus() == n_real
  assert complex_map.focus() == n_complex
  from_map = maptbx.structure_factors.from_map(
    unit_cell=f_calc.unit_cell(),
    space_group_type=f_calc.space_group_info().type(),
    anomalous_flag=anomalous_flag,
    d_min=d_min,
    complex_map=complex_map,
    conjugate_flag=conjugate_flag)
  from_map = f_calc.customized_copy(
    indices=from_map.miller_indices(),
    data=from_map.data())
  lone_sets = f_calc.lone_sets(from_map)
  for lone_set in lone_sets:
    if (lone_set.indices().size() > 0):
      flex.max(lone_set.d_spacings().data()-d_min) < 1.e-5
  common_sets = f_calc.common_sets(from_map)
  assert flex.max(flex.abs(common_sets[0].data()
                         - common_sets[1].data())) < 1.e-10
  from_map = maptbx.structure_factors.from_map(
    anomalous_flag=anomalous_flag,
    miller_indices=f_calc.indices(),
    complex_map=complex_map,
    conjugate_flag=conjugate_flag)
  assert from_map.miller_indices().size() == 0
  assert flex.max(flex.abs(f_calc.data()-from_map.data())) < 1.e-10
  structure_p1 = structure.asymmetric_unit_in_p1()
  f_calc_p1 = f_calc_p1.structure_factors_from_scatterers(
    xray_structure=structure_p1,
    algorithm="direct").f_calc()
  map = maptbx.structure_factors.to_map(
    space_group=f_calc_p1.space_group(),
    anomalous_flag=anomalous_flag,
    miller_indices=f_calc_p1.indices(),
    structure_factors=f_calc_p1.data(),
    n_real=n_real,
    map_grid=flex.grid(n_complex),
    conjugate_flag=conjugate_flag)
  from_map = maptbx.structure_factors.from_map(
    space_group=f_calc.space_group(),
    anomalous_flag=anomalous_flag,
    miller_indices=f_calc.indices(),
    complex_map=map.complex_map(),
    conjugate_flag=conjugate_flag)
  assert from_map.miller_indices().size() == 0
  assert flex.max(flex.abs(f_calc.data()-from_map.data())) < 1.e-10

def exercise_under_sampled(space_group_info, anomalous_flag, conjugate_flag,
                           under_sampling,
                           d_min=2., resolution_factor=0.5, max_prime=5,
                           verbose=0):
  structure_factors = random_structure.xray_structure(
    space_group_info,
    elements=("N", "C", "C", "O"),
    random_f_prime_d_min=1,
    random_f_double_prime=anomalous_flag,
    use_u_aniso=True,
    random_u_iso=True,
    random_occupancy=True
    ).structure_factors(
        anomalous_flag=anomalous_flag, d_min=d_min, algorithm="direct")
  f_calc = structure_factors.f_calc()
  n_real = maptbx.crystal_gridding(
    unit_cell=f_calc.unit_cell(),
    d_min=d_min,
    resolution_factor=resolution_factor,
    max_prime=max_prime,
    mandatory_factors=(under_sampling,)*3).n_real()
  if (not anomalous_flag):
    rfft = fftpack.real_to_complex_3d(n_real)
    n_complex = rfft.n_complex()
  else:
    cfft = fftpack.complex_to_complex_3d(n_real)
    n_complex = cfft.n()
  map = maptbx.structure_factors.to_map(
    space_group=f_calc.space_group(),
    anomalous_flag=anomalous_flag,
    miller_indices=f_calc.indices(),
    structure_factors=f_calc.data(),
    n_real=n_real,
    map_grid=flex.grid(n_complex),
    conjugate_flag=conjugate_flag)
  f_calc_p1 = f_calc.expand_to_p1()
  map_p1 = maptbx.structure_factors.to_map(
    space_group=f_calc_p1.space_group(),
    anomalous_flag=anomalous_flag,
    miller_indices=f_calc_p1.indices(),
    structure_factors=f_calc_p1.data(),
    n_real=n_real,
    map_grid=flex.grid(n_complex),
    conjugate_flag=conjugate_flag)
  assert flex.max(flex.abs(map_p1.complex_map() - map.complex_map())) < 1.e-10
  if (not anomalous_flag):
    real_map = rfft.backward(map.complex_map())
    assert real_map.all() == rfft.m_real()
  else:
    real_map = cfft.backward(map.complex_map())
    assert not real_map.is_padded()
  if (0 or verbose):
    if (not anomalous_flag):
      maptbx.statistics(real_map).show_summary()
      maptbx.statistics(real_map).show_summary()
    else:
      maptbx.statistics(flex.real(real_map)).show_summary()
      maptbx.statistics(flex.imag(real_map)).show_summary()
  n_real_under_sampled = [n//under_sampling for n in n_real]
  if (not anomalous_flag):
    rfft = fftpack.real_to_complex_3d(n_real_under_sampled)
    n_complex_under_sampled = rfft.n_complex()
  else:
    cfft = fftpack.complex_to_complex_3d(n_real_under_sampled)
    n_complex_under_sampled = cfft.n()
  under_sampled_map = maptbx.structure_factors.to_map(
    space_group=f_calc.space_group(),
    anomalous_flag=anomalous_flag,
    miller_indices=f_calc.indices(),
    structure_factors=f_calc.data(),
    n_real=n_real_under_sampled,
    map_grid=flex.grid(n_complex_under_sampled),
    conjugate_flag=conjugate_flag)
  under_sampled_map_p1 = maptbx.structure_factors.to_map(
    space_group=f_calc_p1.space_group(),
    anomalous_flag=anomalous_flag,
    miller_indices=f_calc_p1.indices(),
    structure_factors=f_calc_p1.data(),
    n_real=n_real_under_sampled,
    map_grid=flex.grid(n_complex_under_sampled),
    conjugate_flag=conjugate_flag)
  assert flex.max(flex.abs(under_sampled_map_p1.complex_map()
                         - under_sampled_map.complex_map())) < 1.e-10
  if (not anomalous_flag):
    under_sampled_map_before_fft = under_sampled_map.complex_map().deep_copy()
    under_sampled_real_map = rfft.backward(under_sampled_map.complex_map())
    assert under_sampled_real_map.all() == rfft.m_real()
  else:
    under_sampled_real_map = cfft.backward(under_sampled_map.complex_map())
    assert not under_sampled_real_map.is_padded()
  if (0 or verbose):
    if (not anomalous_flag):
      maptbx.statistics(under_sampled_real_map).show_summary()
      maptbx.statistics(under_sampled_real_map).show_summary()
    else:
      maptbx.statistics(flex.real(under_sampled_real_map)).show_summary()
      maptbx.statistics(flex.imag(under_sampled_real_map)).show_summary()
  if (0 or verbose):
    print(real_map.all(), n_complex)
    print(under_sampled_real_map.all(), n_complex_under_sampled)
  if (not anomalous_flag):
    x_source = real_map
    y_source = under_sampled_real_map
  else:
    x_source = flex.real(real_map)
    y_source = flex.real(under_sampled_real_map)
  x = flex.double()
  n = x_source.focus()
  for i in range(0, n[0], under_sampling):
    for j in range(0, n[1], under_sampling):
      for k in range(0, n[2], under_sampling):
        x.append(x_source[(i,j,k)])
  y = maptbx.copy(y_source, flex.grid(y_source.focus())).as_1d()
  if (0 or verbose):
    print("x:", tuple(x))
    print("y:", tuple(y))
  assert flex.max(flex.abs(x-y)) \
      < (flex.max(flex.abs(x))+flex.max(flex.abs(y)))/2*1.e-6
  if (under_sampling == 1):
    x = maptbx.copy(x_source, flex.grid(x_source.focus())).as_1d()
    c = flex.linear_correlation(x, y)
    assert c.coefficient() >= 0.9999

def exercise_average_densities(space_group_info, d_min=1.5):
  structure = random_structure.xray_structure(
    space_group_info,
    elements=("C", "H", "O", "Cl"),
    volume_per_atom=500,
    min_distance=5)
  f_calc = structure.structure_factors(
    anomalous_flag=False,
    d_min=d_min,
    algorithm="direct").f_calc()
  map = f_calc.fft_map().real_map_unpadded()
  for radius in [1,2]:
    densities = maptbx.average_densities(
      unit_cell=structure.unit_cell(),
      data=map,
      sites_frac=structure.sites_frac(),
      radius=radius)
    perm = flex.sort_permutation(data=densities, reverse=True)
    assert list(perm) == [3,2,0,1]

def run_call_back(flags, space_group_info):
  for anomalous_flag in (False, True)[:]: #SWITCH
    for conjugate_flag in (False, True)[:]: #SWITCH
      for with_shift in (False, True)[:]: #SWITCH
        if (with_shift):
          sgi = debug_utils.random_origin_shift(space_group_info)
        else:
          sgi = space_group_info
      exercise_shannon_sampled(
        space_group_info=sgi,
        anomalous_flag=anomalous_flag,
        conjugate_flag=conjugate_flag,
        verbose=flags.Verbose)
  for anomalous_flag in (False, True)[:]: #SWITCH
    for conjugate_flag in (False, True)[:]: #SWITCH
      for under_sampling in (1,2,3,4,5):
        exercise_under_sampled(space_group_info,
                               anomalous_flag,
                               conjugate_flag,
                               under_sampling,
                               verbose=flags.Verbose)
  exercise_average_densities(space_group_info=space_group_info)

def run():
  exercise_crystal_gridding()
  exercise_f000()
  debug_utils.parse_options_loop_space_groups(sys.argv[1:], run_call_back)

if (__name__ == "__main__"):
  run()


 *******************************************************************************


 *******************************************************************************
cctbx/regression/tst_math_module.py
from __future__ import absolute_import, division, print_function
from libtbx.test_utils import Exception_expected
import scitbx.matrix as mat

def exercise_basis_of_mirror_plane_with_normal():
  from cctbx.math_module import basis_of_mirror_plane_with_normal
  for u in [(1,0,0), (0,1,0), (0,0,1), (1,1,0), (1,1,1), (0,-1,1), (-1,1,1)]:
    u = mat.col(u)
    v,w = [ mat.col(x) for x in basis_of_mirror_plane_with_normal(u.elems) ]
    assert u.dot(v) == 0
    assert u.dot(w) == 0
    assert abs(v.cross(w)) != 0
  try:
    basis_of_mirror_plane_with_normal((0,0,0))
  except AssertionError:
    pass
  else:
    raise Exception_expected


def run():
  exercise_basis_of_mirror_plane_with_normal()
  print('OK')

if __name__ == '__main__':
  run()


 *******************************************************************************


 *******************************************************************************
cctbx/regression/tst_mem.py
from __future__ import absolute_import, division, print_function
from scitbx.array_family import flex
import iotbx.pdb
import cctbx.maptbx.mem as mem
from cctbx import miller
from six.moves import zip

def map_1d(xrs, map_data, n_steps=300, step_size=0.01):
  atom_center = xrs.scatterers()[0].site
  a_cell = xrs.unit_cell().parameters()[0]
  dist = flex.double()
  rho = flex.double()
  x=-10
  while x<=10:
    x += step_size
    point = x/a_cell, 0, 0
    density_value_at_point_e = map_data.eight_point_interpolation(point)
    dist.append(x)
    rho.append(density_value_at_point_e)
  return dist, rho

def scale(x, y):
  assert x.size() == y.size()
  x = flex.abs(x)
  y = flex.abs(y)
  return flex.sum(x*y)/flex.sum(y*y)

def r_factor(x, r1, r2, eps=1.e-6):
  sel  = x > 0-eps
  sel &= x < 0+eps
  assert sel.count(True) == 1
  r1_ = r1.select(sel)
  r2_ = r2.select(sel)
  return flex.abs( r1_-r2_ )[0]

def run():
  pdb_str="""
CRYST1    5.000    5.000    5.000  90.00  90.00  90.00 P 1
HETATM    1  C    C      1       0.000   0.000   0.000  1.00  5.00           C
END
"""
  xrs = iotbx.pdb.input(source_info=None, lines=pdb_str).xray_structure_simple()
  ###
  fc = xrs.structure_factors(d_min = 0.26, algorithm = "direct").f_calc()
  fft_map_ref = fc.fft_map(resolution_factor = 0.1)
  fft_map_ref.apply_sigma_scaling()
  map_data_ref = fft_map_ref.real_map_unpadded()
  r_r, rho_r = map_1d(xrs=xrs,
    map_data=map_data_ref.deep_copy()/flex.max(map_data_ref))
  F_0 = xrs.structure_factors(d_min=1.4999999, algorithm="direct").f_calc()
  #
  fft_map_0 = miller.fft_map(
    crystal_gridding     = fft_map_ref,
    fourier_coefficients = F_0)
  fft_map_0.apply_sigma_scaling()
  map_data_0 = fft_map_0.real_map_unpadded()
  r_s, rho_s = map_1d(xrs=xrs, map_data=map_data_0)
  sc = scale(rho_r, rho_s)
  rho_s = rho_s*sc
  #
  R = r_factor(x=r_s, r1=rho_r, r2=rho_s)
  cc = flex.linear_correlation(x = rho_r, y = rho_s).coefficient()
  print("Initial dist: %6.3f"%R, cc)
  ### Exercise fixed lam
  lam = 0.74
  for start_map in ["flat", "lde", "min_shifted"]:
    m = mem.run(f=F_0, f_000=xrs.f_000(), lam=lam, resolution_factor=0.1,
      verbose=False, start_map=start_map, max_iterations=1300,
      detect_convergence=False)
    r_m, rho_m = map_1d(xrs=xrs, map_data=m.rho)
    sc = scale(rho_r, rho_m)
    rho_m = rho_m*sc
    R = r_factor(x=r_s, r1=rho_r, r2=rho_m)
    cc = flex.linear_correlation(x = rho_r, y = rho_m).coefficient()
    print(m.show(verbose=False), "*", "dist: %6.3f"%R, cc)
    assert R < 0.0004, R
    assert cc > 0.999, R
  ### Exercise auto-incremented lam, 1
  m = mem.run(f=F_0, f_000=xrs.f_000(), lam=0.01, resolution_factor=0.1,
    lambda_increment_factor = 1.01, beta=0.5, verbose=True,
    start_map="min_shifted", max_iterations=800, detect_convergence=True)
  r_m, rho_m = map_1d(xrs=xrs, map_data=m.rho)
  sc = scale(rho_r, rho_m)
  rho_m = rho_m*sc
  R = r_factor(x=r_s, r1=rho_r, r2=rho_m)
  cc = flex.linear_correlation(x = rho_r, y = rho_m).coefficient()
  print(m.show(verbose=False), "*", "dist: %6.3f"%R, cc)
  assert R < 0.004, R
  assert cc > 0.999, R
  ### Exercise auto-incremented lam, 2
  m = mem.run(f=F_0, f_000=xrs.f_000(), lam=0.01, resolution_factor=0.1,
    lambda_increment_factor = 1.01, beta=0.5, xray_structure=xrs, verbose=True,
    start_map="min_shifted", max_iterations=800, detect_convergence=True)
  r_m, rho_m = map_1d(xrs=xrs, map_data=m.rho)
  sc = scale(rho_r, rho_m)
  rho_m = rho_m*sc
  R = r_factor(x=r_s, r1=rho_r, r2=rho_m)
  cc = flex.linear_correlation(x = rho_r, y = rho_m).coefficient()
  print(m.show(verbose=False), "*", "dist: %6.3f"%R, cc)
  assert R < 0.05, R
  assert cc > 0.998, R
  #
  of = open("gp","w")
  assert rho_r.size() == rho_s.size() == rho_m.size()
  for r, r1, r2, r3 in zip(r_r, rho_r, rho_s, rho_m):
    print("%15.12f %15.12f %15.12f %15.12f"%(r, r1, r2, r3), file=of)
  of.close()
  #
  m.write_mtz_file()
  #
  print("gnuplot command to show results:")
  print("""
plot [-3:3] [-0.1:1.1] "gp" using 1:2 with lines title "exact" lw 3, "gp" using 1:3 with lines title "synthesis" lw 3 lc rgb "black", "gp" using 1:4 with lines title "MEM" lw 3
""")

if __name__ == "__main__" :
  run()


 *******************************************************************************


 *******************************************************************************
cctbx/regression/tst_mem_2.py
from __future__ import absolute_import, division, print_function
import iotbx.pdb
import libtbx.load_env
from libtbx import easy_run
from iotbx import mtz

def run():
  pdb_str="""
CRYST1    5.000    5.000    5.000  90.00  90.00  90.00 P 1
HETATM    1  C    C      1       0.000   0.000   0.000  1.00  5.00           C
END
"""
  xrs = iotbx.pdb.input(source_info=None, lines=pdb_str).xray_structure_simple()
  fc = xrs.structure_factors(d_min = 1, algorithm = "direct",
    anomalous_flag=True).f_calc()
  mtz_dataset = fc.as_mtz_dataset(column_root_label="F")
  mtz_object = mtz_dataset.mtz_object()
  mtz_object.write(file_name = "tst_mem_2.mtz")
  assert fc.anomalous_flag()
  cmd = "phenix.maximum_entropy_map tst_mem_2.mtz > tst_mem_2.log"
  assert not easy_run.call(cmd)
  o = mtz.object(file_name="tst_mem_2_mem.mtz")
  mas = o.as_miller_arrays()
  assert len(mas) == 2
  for ma in mas:
    assert ma.anomalous_flag() is False

if __name__ == "__main__" :
  if libtbx.env.has_module("phenix"):
    run()
    print("OK")
  else:
    print("Skipping test: phenix not available")


 *******************************************************************************


 *******************************************************************************
cctbx/regression/tst_miller.py
from __future__ import absolute_import, division, print_function
from cctbx import crystal
from cctbx import miller
from cctbx import xray
from cctbx import maptbx
from cctbx import sgtbx
from cctbx import uctbx
from cctbx.development import random_structure
from cctbx.development import debug_utils
from cctbx.array_family import flex
import cctbx
import scitbx.math
from libtbx import complex_math
from libtbx.test_utils import \
  approx_equal, not_approx_equal, show_diff, Exception_expected
from libtbx.utils import Sorry, Keep, null_out
from libtbx import Auto
from six.moves import cStringIO as StringIO
import warnings
from six.moves import range
from six.moves import zip
from six.moves import cPickle as pickle
import random
import math
import sys

def exercise_set():
  xs = crystal.symmetry((3,4,5), "P 2 2 2")
  mi = flex.miller_index(((1,2,3), (0,0,4)))
  ms = miller.set(xs, mi)
  ms = miller.set(xs, mi, False)
  ms = miller.set(xs, mi, True)
  assert ms.indices() == mi
  assert ms.anomalous_flag() == True
  ms2 = ms.as_non_anomalous_set()
  assert ms2.anomalous_flag() == False
  ms3 = ms2.as_anomalous_set()
  assert ms3.anomalous_flag() == True
  mc = ms.copy()
  assert not mc is ms
  assert mc.unit_cell() is ms.unit_cell()
  assert mc.space_group_info() is ms.space_group_info()
  assert mc.indices() is ms.indices()
  assert mc.anomalous_flag() is ms.anomalous_flag()
  mc = ms.deep_copy()
  assert mc.unit_cell().is_similar_to(ms.unit_cell())
  assert mc.space_group() == ms.space_group()
  assert flex.order(mc.indices(), ms.indices()) == 0
  assert mc.anomalous_flag() == ms.anomalous_flag()
  assert tuple(ms.multiplicities().data()) == (4, 2)
  assert tuple(ms.epsilons().data()) == (1, 2)
  assert approx_equal(ms.d_star_sq().data(), [0.7211111, 0.64])
  assert approx_equal(ms.d_star_cubed().data(), [0.612355017974, 0.512])
  assert approx_equal(tuple(ms.d_spacings().data()), (1.177603, 1.25))
  assert approx_equal(tuple(ms.sin_theta_over_lambda_sq().data()),
                      (0.1802778, 0.16))
  assert approx_equal(ms.d_min(), 1.177603)
  assert approx_equal(ms.d_max_min(), [1.25,1.177603])
  assert approx_equal(ms.resolution_range(), (1.25, 1.177603))
  assert approx_equal(ms.minimum_wavelength_based_on_d_min(), 2.33165395578)
  assert approx_equal(ms.minimum_wavelength_based_on_d_min(tolerance=0.1),
    2.11968541434)
  p1 = ms.expand_to_p1()
  assert p1.indices().size() == p1.size() == 6
  p1b, iselection = ms.expand_to_p1(return_iselection=True)
  assert p1b.indices().all_eq(p1.indices())
  assert list(iselection) == [0, 0, 0, 0, 1, 1]
  b = p1.setup_binner(auto_binning=True)
  b = p1.setup_binner(reflections_per_bin=1)
  b = p1.setup_binner(n_bins=8)
  assert id(p1.binner()) == id(b)
  assert b.limits().size() == 9
  assert tuple(ms.sort().indices()) == ((0,0,4), (1,2,3))
  assert tuple(ms.sort(reverse=True).indices()) == ((1,2,3), (0,0,4))
  assert tuple(ms.sort(reverse=True)
                .sort(by_value="packed_indices").indices()) \
      == ((0, 0, 4), (1, 2, 3))
  assert tuple(ms.sort(reverse=True)
                .sort(by_value="packed_indices", reverse=True).indices()) \
      == ((1, 2, 3), (0, 0, 4))
  ms = miller.set(xs, mi, False)
  mp = ms.patterson_symmetry()
  assert str(mp.space_group_info()) == "P m m m"
  assert mp.indices() == ms.indices()
  assert mp.min_max_indices() == ((0, 0, 3), (1, 2, 4))
  mc = ms.complete_set()
  c = mc.completeness()
  assert c >= 1-1.e5
  assert c <= 1
  c = mc.completeness(multiplier=100)
  assert (c > 1) and (c <= 100)
  c = mc.select(~mc.all_selection()).completeness()
  assert c == 0
  ma = ms.map_to_asu()
  assert flex.order(ms.indices(), ma.indices()) == 0
  ma = ms.remove_systematic_absences()
  assert flex.order(ms.indices(), ma.indices()) == 0
  assert miller.set(xs, mi).auto_anomalous().anomalous_flag() == False
  mi.extend(flex.miller_index(((-1,-2,-3), (3,4,5), (-3,-4,-5))))
  ma = miller.set(xs, mi)
  assert ma.n_bijvoet_pairs() == 2
  assert ma.auto_anomalous().anomalous_flag() == True
  assert ma.auto_anomalous(
    min_n_bijvoet_pairs=2).anomalous_flag() == True
  assert ma.auto_anomalous(
    min_n_bijvoet_pairs=3).anomalous_flag() == False
  assert ma.auto_anomalous(
    min_fraction_bijvoet_pairs=4/5.-1.e-4).anomalous_flag() == True
  assert ma.auto_anomalous(
    min_fraction_bijvoet_pairs=4/5.+1.e-4).anomalous_flag() == False
  s = StringIO()
  mc.show_comprehensive_summary(f=s)
  assert not show_diff(s.getvalue(), """\
Number of Miller indices: 36
Anomalous flag: %s
Unit cell: (3, 4, 5, 90, 90, 90)
Space group: P 2 2 2 (No. 16)
Systematic absences: 0
Centric reflections: 27
Resolution range: 5 1.1776
Completeness in resolution range: 1
Completeness with d_max=infinity: 1
""" % str(False))
  s = StringIO()
  mc.select(flex.size_t([0])).show_comprehensive_summary(f=s)
  assert not show_diff(s.getvalue(), """\
Number of Miller indices: 1
Anomalous flag: %s
Unit cell: (3, 4, 5, 90, 90, 90)
Space group: P 2 2 2 (No. 16)
Systematic absences: 0
Centric reflections: 1
Resolution range: 5 5
Completeness with d_max=infinity: 1
""" % str(False))
  #
  c = mc.change_basis(cb_op="k,h,-l")
  assert c.unit_cell().is_similar_to(uctbx.unit_cell((4,3,5,90,90,90)))
  #
  s = mc.customized_copy(space_group_info=sgtbx.space_group_info(number=19))
  assert s.sys_absent_flags().data().all_eq(flex.bool([
    True, False, True, False, True, False, False, False, False,
    False, False, False, False, True, False, True, False, False,
    False, False, False, False, False, False, False, False, False,
    False, False, False, False, False, False, False, False, False]))
  assert s.sys_absent_flags(integral_only=True).data().all_eq(False)
  r = s.reflection_intensity_symmetry()
  assert str(r.space_group_info()) == "P m m m"
  assert r.sys_absent_flags().data().all_eq(False)
  #
  s = s.customized_copy(indices=flex.miller_index([(1,2,3),(0,0,1)]))
  for deg in [False, True]:
    p = s.random_phases_compatible_with_phase_restrictions(deg=deg).data()
    assert s.space_group().is_valid_phase((0,0,1), p[1], deg)
  #
  s = miller.set(
    crystal_symmetry=xs,
    indices=flex.miller_index(((1,2,3), (0,0,0))),
    anomalous_flag=False)
  r = s.resolution_filter_selection
  assert list(r()) == [True, True]
  assert list(r(d_max=0, d_min=0)) == [True, True]
  assert list(r(d_max=1.1)) == [False, False]
  assert list(r(d_max=1.2)) == [True, False]
  assert list(r(d_min=1.1)) == [True, True]
  assert list(r(d_min=1.2)) == [False, True]
  assert list(r(d_max=1.2, d_min=1.1)) == [True, False]
  assert list(r(d_max=1.1, d_min=1.2)) == [False, False]
  #
  s = xs.miller_set(indices=flex.miller_index([(1,2,3)]), anomalous_flag=True)
  assert s.indices().size() == 1
  assert s.anomalous_flag()


def exercise_generate_bijvoet_mates_set():
  sg_info = sgtbx.space_group_info("P422")
  cs = sg_info.any_compatible_crystal_symmetry(volume=1000)
  for anom in [True, False]:
    miller_set = miller.build_set(
      crystal_symmetry=cs,
      anomalous_flag=anom,
      d_min=2.0,
    )
    bm = miller_set.generate_bivoet_mates()
    assert bm.anomalous_flag()
    assert bm.completeness() == 1


def exercise_union_of_sets():
  xs = crystal.symmetry(unit_cell=(10,10,10,90,90,90), space_group_symbol="P1")
  ms = miller.set(xs, flex.miller_index())
  u = miller.union_of_sets(miller_sets=[ms])
  assert u.is_similar_symmetry(ms)
  assert len(u.indices()) == 0
  ms = miller.set(xs, flex.miller_index(((1,-2,3), (0,0,-4))))
  u = miller.union_of_sets(miller_sets=[ms])
  assert sorted(u.indices()) == [(0,0,-4), (1,-2,3)]
  u = miller.union_of_sets(miller_sets=[ms, ms])
  assert sorted(u.indices()) == [(0,0,-4), (1,-2,3)]
  ms2 = miller.set(xs, flex.miller_index(((1,-2,3), (0,0,-5))))
  u = miller.union_of_sets(miller_sets=[ms, ms2])
  assert sorted(u.indices()) == [(0,0,-5), (0,0,-4), (1,-2,3)]

def exercise_enforce_positive_amplitudes():
  from cctbx.xray import observation_types
  xs = crystal.symmetry((3,4,5), "P 2 2 2")
  mi = flex.miller_index(((1,-2,3), (0,0,-4)))
  data = flex.double((-1,-2))
  sigmas = flex.double((1,2))
  ms = miller.set(xs, mi)
  ma = miller.array(ms)
  ma = miller.array(ms, data=data, sigmas=sigmas).set_observation_type(
    observation_types.intensity() )
  new_ma = ma.enforce_positive_amplitudes()
  assert new_ma.data()[0]>0
  assert new_ma.data()[1]>0

def exercise_generate_r_free_flag_on_lat_sym(sg_info):
  for an_flag in [True,False]:
    full_xs = sg_info.any_compatible_crystal_symmetry(volume=50*80*100)
    low_xs = crystal.symmetry( unit_cell = full_xs.unit_cell(),
                               space_group = sgtbx.space_group("P1") )
    miller_set = miller.build_set(
      crystal_symmetry=low_xs,
      anomalous_flag=an_flag,
      d_min=3.0 )

    free_flags = miller_set.generate_r_free_flags(use_lattice_symmetry=True)
    free_flags = free_flags.select( free_flags.data() )
    fake_data_in_lat_sym = free_flags.customized_copy(
      crystal_symmetry=full_xs,
      indices = free_flags.indices(),
      data = flex.double(free_flags.indices().size(),2.0 ),
      sigmas = flex.double(free_flags.indices().size(),1.0 )
                                                     )
    fake_data_in_lat_sym = fake_data_in_lat_sym.merge_equivalents().array()
    fake_data_in_p1 = fake_data_in_lat_sym.expand_to_p1()
    assert fake_data_in_p1.indices().size()==free_flags.indices().size()
    # note that this assert will fail (unless you are lucky)
    # if max_delta is set to None

    # also check that the full symmetry doesn't do anything weird
    miller_set = miller.build_set(
      crystal_symmetry=full_xs,
      anomalous_flag=an_flag,
      d_min=3.0 )
    free_flags = miller_set.generate_r_free_flags(use_lattice_symmetry=True)

    # check the generatiuon of integer flags please
    integer_flags = miller_set.generate_r_free_flags_on_lattice_symmetry(
      fraction=None,
      max_free=None,
      return_integer_array=True,
      n_partitions=3
    )
    assert approx_equal(
      float(integer_flags.data().size())/integer_flags.data().count( 0 ),3,eps=0.1 )
    assert approx_equal(
      float(integer_flags.data().size())/integer_flags.data().count( 1 ),3,eps=0.1 )
    assert approx_equal(
      float(integer_flags.data().size())/integer_flags.data().count( 2 ),3,eps=0.1 )
    assert ( integer_flags.data().count( 3 ) == 0 )

def exercise_generate_r_free_flags(verbose=0, use_lattice_symmetry=False):
  for anomalous_flag in [False, True]:
    miller_set = miller.build_set(
      crystal_symmetry=crystal.symmetry(
        unit_cell=(28.174, 52.857, 68.929, 90, 90, 90),
        space_group_symbol="P 21 21 21"),
      anomalous_flag=anomalous_flag,
      d_min=8)
    for i_trial in range(10):
      if (i_trial == 0):
        trial_set = miller_set
      else:
        trial_set = miller_set.select(
          flex.random_permutation(size=miller_set.indices().size()))
        if (i_trial >= 5):
          trial_set = trial_set.select(
            flex.random_double(size=miller_set.indices().size()) < 0.8)
      flags = trial_set.generate_r_free_flags(use_lattice_symmetry=use_lattice_symmetry)
      if (i_trial == 0):
        out = StringIO()
        flags.show_r_free_flags_info(out=out, prefix="$#")
        if (verbose): sys.stdout.write(out.getvalue())
        lines = out.getvalue().splitlines()
        assert len(lines) == 13
        for line in lines:
          assert line.startswith("$#")
        accu = flags.r_free_flags_accumulation()
        assert accu.reflection_counts.size() == accu.free_fractions.size()
        if (verbose):
          print("r_free_flags_accumulation:", \
            list(zip(accu.reflection_counts, accu.free_fractions)))
      if (not anomalous_flag):
        if (i_trial < 5):
          assert flags.indices().size() == 145
          assert flags.data().count(True) == 15
      else:
        if (i_trial < 5):
          assert flags.indices().size() == 212
        fp,fm = flags.hemispheres_acentrics()
        assert fp.data().all_eq(fm.data())
        if (i_trial < 5):
          assert fp.data().count(True) \
               + flags.select_centric().data().count(True) == 15
        flags_non_anomalous = flags.average_bijvoet_mates()
        if (i_trial < 5):
          assert flags_non_anomalous.indices().size() == 145
          assert flags_non_anomalous.data().count(True) == 15
          flags_gen = flags_non_anomalous.generate_bijvoet_mates() \
            .adopt_set(flags)
          assert flags_gen.data().all_eq(flags.data())
        flags = flags.select(~flex.bool(
          flags.indices().size(),
          flags.match_bijvoet_mates()[1].pairs_hemisphere_selection("-")))
      flags = flags.sort(by_value="resolution", reverse=True)
      isel = flags.data().iselection()
      flag_distances = isel[1:] - isel[:-1]
      assert flex.min(flag_distances) > 0
      assert flex.max(flag_distances) <= 20
      flags = trial_set.generate_r_free_flags(max_free=10, use_lattice_symmetry=use_lattice_symmetry)
      if (not anomalous_flag):
        assert flags.data().count(True) == 10
      else:
        assert 10 <= flags.data().count(True) <= 20
  for anomalous_flag in [False, True]:
    miller_set = miller.build_set(
      crystal_symmetry=crystal.symmetry(
        unit_cell=(28.174, 52.857, 68.929, 90, 90, 90),
        space_group_symbol="P 21 21 21"),
      anomalous_flag=anomalous_flag,
      d_min=1.)
    flags1 = miller_set.generate_r_free_flags(
      fraction=0.1,
      max_free=2000,
      use_lattice_symmetry=True,
      format="shelx")
    flags2 = miller_set.generate_r_free_flags(
      fraction=0.1,
      max_free=2000,
      use_lattice_symmetry=True,
      format="ccp4")
    assert (isinstance(flags1.data(), flex.int))
    assert (isinstance(flags2.data(), flex.int))
    if (anomalous_flag):
      flags1_ave = flags1.average_bijvoet_mates()
      flags2_ave = flags2.average_bijvoet_mates()
    try :
      flags2 = miller_set.generate_r_free_flags(
        fraction=0.1,
        max_free=2000,
        use_lattice_symmetry=True,
        use_dataman_shells=True,
        format="ccp4")
    except Sorry : pass
    else : raise Exception_expected

def exercise_binner():
  crystal_symmetry = crystal.symmetry(
    unit_cell="14.311  57.437  20.143",
    space_group_symbol="C m c m")
  for anomalous_flag in [False, True]:
    set1 = miller.build_set(
      crystal_symmetry=crystal_symmetry,
      anomalous_flag=anomalous_flag,
      d_min=10)
    set1.setup_binner(n_bins=3)
    s = StringIO()
    set1.binner().show_summary(f=s, prefix="..")
    assert s.getvalue() == """\
..unused:         - 28.7186 [0/0]
..bin  1: 28.7186 - 14.1305 [3/3]
..bin  2: 14.1305 - 11.4473 [3/3]
..bin  3: 11.4473 - 10.0715 [2/2]
..unused: 10.0715 -         [0/0]
"""
    s = StringIO()
    set1.binner().show_summary(f=s, prefix=" ", bin_range_as="stol")
    assert s.getvalue() == """\
 unused:         -  0.0174 [0/0]
 bin  1:  0.0174 -  0.0354 [3/3]
 bin  2:  0.0354 -  0.0437 [3/3]
 bin  3:  0.0437 -  0.0496 [2/2]
 unused:  0.0496 -         [0/0]
"""
    set2 = miller.build_set(
      crystal_symmetry=crystal_symmetry,
      anomalous_flag=anomalous_flag,
      d_min=8)
    set2.use_binning_of(set1)
    s = StringIO()
    set2.completeness(use_binning=True).show(f=s, prefix=". ")
    assert s.getvalue() == """\
. unused:         - 28.7186 [0/0]
. bin  1: 28.7186 - 14.1305 [3/3] 1.000
. bin  2: 14.1305 - 11.4473 [3/3] 1.000
. bin  3: 11.4473 - 10.0715 [2/2] 1.000
. unused: 10.0715 -         [8/8] 1.000
"""
    t = set2.completeness(use_binning=True).as_simple_table(
      data_label="Completeness")
    assert (t.export() == [
      ['Resolution range', 'N(obs)/N(possible)', 'Completeness'],
      ['28.7186 - 14.1305', '[3/3]', '1.000'],
      ['14.1305 - 11.4473', '[3/3]', '1.000'],
      ['11.4473 - 10.0715', '[2/2]', '1.000']])
    s = StringIO()
    set2.completeness(use_binning=True).show(show_bin_number=False, f=s)
    assert s.getvalue() == """\
        - 28.7186 [0/0]
28.7186 - 14.1305 [3/3] 1.000
14.1305 - 11.4473 [3/3] 1.000
11.4473 - 10.0715 [2/2] 1.000
10.0715 -         [8/8] 1.000
"""
    s = StringIO()
    set2.completeness(use_binning=True).show(
      show_bin_number=False, f=s, bin_range_as="two_theta", wavelength=0.71073)
    assert s.getvalue() == """\
        -  1.4180 [0/0]
 1.4180 -  2.8822 [3/3] 1.000
 2.8822 -  3.5579 [3/3] 1.000
 3.5579 -  4.0441 [2/2] 1.000
 4.0441 -         [8/8] 1.000
"""
    s = StringIO()
    set2.completeness(use_binning=True).show(show_d_range=False, f=s)
    assert s.getvalue() == """\
unused: [0/0]
bin  1: [3/3] 1.000
bin  2: [3/3] 1.000
bin  3: [2/2] 1.000
unused: [8/8] 1.000
"""
    s = StringIO()
    set2.completeness(use_binning=True).show(show_counts=False, f=s)
    assert s.getvalue() == """\
unused:         - 28.7186
bin  1: 28.7186 - 14.1305 1.000
bin  2: 14.1305 - 11.4473 1.000
bin  3: 11.4473 - 10.0715 1.000
unused: 10.0715 -         1.000
"""
    s = StringIO()
    set2.completeness(use_binning=True).show(
      show_bin_number=False, show_d_range=False, show_counts=False, f=s)
    assert s.getvalue() == """\

 1.000
 1.000
 1.000
 1.000
"""
    s = StringIO()
    set2.completeness(use_binning=True).show(
      show_bin_range=False, show_counts=False, f=s)
    assert s.getvalue() == """\
unused:
bin  1: 1.000
bin  2: 1.000
bin  3: 1.000
unused: 1.000
"""
    s = StringIO()
    set2.completeness(use_binning=True).show(
      show_bin_number=False, bin_range_as="d_star_sq", show_counts=False, f=s)
    assert s.getvalue() == """\
        -  0.0012
 0.0012 -  0.0050 1.000
 0.0050 -  0.0076 1.000
 0.0076 -  0.0099 1.000
 0.0099 -         1.000
"""
  set2 = set2.customized_copy(indices=flex.miller_index())
  set2.use_binning_of(set1)
  s = StringIO()
  set2.completeness(use_binning=True).show(f=s)
  assert s.getvalue() == """\
unused:         - 28.7186 [0/0]
bin  1: 28.7186 - 14.1305 [0/3] 0.000
bin  2: 14.1305 - 11.4473 [0/3] 0.000
bin  3: 11.4473 - 10.0715 [0/2] 0.000
unused: 10.0715 -         [0/0]
"""
  p = pickle.dumps(set1.binner())
  l = pickle.loads(p)
  s = StringIO()
  set1.binner().show_summary(f=s)
  sl = StringIO()
  l.show_summary(f=sl)
  assert not show_diff(sl.getvalue(), s.getvalue())
  #
  expected_counts = iter([
    [0,1,0], [0,1,0], [0,1,0],
    [0,1,1,0], [0,2,0], [0,2,0], [0,2,0],
    [0,1,1,1,0], [0,2,1,0], [0,3,0], [0,3,0], [0,3,0],
    [0,1,1,1,1,0], [0,2,2,0], [0,4,0], [0,4,0], [0,4,0], [0,4,0],
    [0,1,1,1,1,1,0], [0,2,1,2,0], [0,3,2,0], [0,5,0], [0,5,0], [0,5,0], [0,5,0]
  ])
  for n in range(1,6):
    set2 = set1.select(flex.size_t(range(n)))
    for reflections_per_bin in list(range(1,n+1)) + [n+1, n*10]:
      set2.setup_binner_counting_sorted(reflections_per_bin=reflections_per_bin)
      assert list(set2.binner().counts()) == next(expected_counts)
  set1.setup_binner_counting_sorted(
    d_max=16,
    d_min=11,
    reflections_per_bin=3)
  assert list(set1.binner().counts()) == [2,3,2,1]
  #
  expected_counts = iter([
    [0,1,0],
    [0,1,1,0], [0,2,0],
    [0,1,1,1,0], [0,2,1,0], [0,3,0],
    [0,1,1,1,1,0], [0,1,2,1,0], [0,2,2,0], [0,4,0],
    [0,1,1,1,1,1,0], [0,1,2,1,1,0], [0,2,1,2,0], [0,3,2,0], [0,5,0],
    [0,1,1,1,1,1,1,0], [0,1,1,2,1,1,0], [0,2,1,2,1,0], [0,2,2,2,0], [0,3,3,0], [0,6,0],
    [0,1,1,1,1,1,1,1,0], [0,1,1,2,1,1,1,0], [0,1,2,1,2,1,0], [0,2,2,1,2,0], [0,2,3,2,0], [0,4,3,0], [0,7,0]
  ])
  for n in range(1,8):
    set2 = set1.select(flex.size_t(range(n)))
    for n_bins in range(n, 0, -1):
      set2.setup_binner_counting_sorted(n_bins=n_bins)
      assert list(set2.binner().counts()) == next(expected_counts)
  set1.setup_binner_counting_sorted(
    d_max=16,
    d_min=11,
    n_bins=2)
  assert list(set1.binner().counts()) == [2,3,2,1]

def exercise_counting_sorted_no_empty_bins():
  sgi = sgtbx.space_group_info("I23")
  cs = sgi.any_compatible_crystal_symmetry(volume=999)
  ms = cs.build_miller_set(True, d_min=1)
  try:
    ms.setup_binner_counting_sorted(n_bins=50)
  except AssertionError:
    pass
  else:
     raise Exception_expected

def exercise_counting_sorted_n_bins_reflections_per_bin():
  sgi = sgtbx.space_group_info("I23")
  cs = sgi.any_compatible_crystal_symmetry(volume=999)
  ms = cs.build_miller_set(True, d_min=1)
  binner = ms.setup_binner_counting_sorted(n_bins=50, reflections_per_bin=10)
  assert binner.n_bins_used() == 5
  assert binner.counts_complete() == [0, 17, 30, 37, 44, 51, 0]
  assert approx_equal(
    binner.limits(),
    [
      0.020013344452328715,
      0.20013344452328713,
      0.4002668890465743,
      0.6204136780221902,
      0.8005337780931485,
      0.9806538783602378
    ]
  )

def exercise_crystal_gridding():
  crystal_symmetry = crystal.symmetry(
    unit_cell=(95.2939, 95.2939, 98.4232, 94.3158, 115.226, 118.822),
    space_group_symbol="Hall: C 2y (x+y,-x+y+z,z)")
  f_obs = miller.build_set(crystal_symmetry, anomalous_flag=False, d_min=3.5)
  symmetry_flags = sgtbx.search_symmetry_flags(
    use_space_group_symmetry=False,
    use_space_group_ltr=0,
    use_seminvariants=True,
    use_normalizer_k2l=False,
    use_normalizer_l2n=False)
  crystal_gridding_tags = f_obs.crystal_gridding(
    symmetry_flags=symmetry_flags,
    resolution_factor=1/3.,
    mandatory_factors=(20,20,20)).tags()
  assert crystal_gridding_tags.n_real() == (100,100,100)

def exercise_array():
  xs = crystal.symmetry((3,4,5), "P 2 2 2")
  mi = flex.miller_index(((1,-2,3), (0,0,-4)))
  data = flex.double((1,2))
  sigmas = flex.double((0.1,0.2))
  ms = miller.set(xs, mi)
  ma = miller.array(ms)
  ma = miller.array(ms, data)
  s = StringIO()
  ma.show_array(f=s, prefix=": ")
  assert approx_equal(xs.unit_cell().parameters(),
                      ma.crystal_symmetry().unit_cell().parameters())
  assert xs.space_group().type().lookup_symbol() == \
         ma.crystal_symmetry().space_group().type().lookup_symbol()
  assert s.getvalue() == """\
: (1, -2, 3) 1.0
: (0, 0, -4) 2.0
"""
  ma = miller.array(ms, data, sigmas)
  assert ma.first_index((0, 0, -4)) == 1
  assert ma.data_at_first_index((0, 0, -4)) == 2.0
  assert ma.sigma_at_first_index((0, 0, -4)) == 0.2
  s = StringIO()
  ma.show_array(f=s, prefix=" :")
  assert s.getvalue() == """\
 :(1, -2, 3) 1.0 0.1
 :(0, 0, -4) 2.0 0.2
"""
  ma = miller.array(ms, data, sigmas).set_info("test")
  assert ma.indices() == mi
  assert ma.data() == data
  assert ma.sigmas() == sigmas
  assert ma.info() == "test"
  assert ma.observation_type() is None
  assert ma.size() == 2
  ma.set_info(miller.array_info(
    source="file", labels=["a", "b", "c"]))
  assert str(ma.info()) == "file:a,b,c"
  assert ma.info().label_string() == "a,b,c"
  ma.set_info(miller.array_info(
    source="file", labels=["a", "b", "c"], merged=True))
  assert str(ma.info()) == "file:a,b,c,merged"
  assert ma.info().label_string() == "a,b,c,merged"
  ma.set_info(ma.info().customized_copy(systematic_absences_eliminated=True))
  assert ma.info().label_string() \
      == "a,b,c,merged,systematic_absences_eliminated"
  ma.set_info("Test")
  assert ma.info() == "Test"
  ma2 = ma.customized_copy()
  assert (ma2.info() is None)
  ma2 = ma.customized_copy(info=Keep)
  assert (ma2.info() == "Test")
  ma.set_observation_type_xray_amplitude()
  assert ma.is_xray_amplitude_array()
  ma.set_observation_type_xray_intensity()
  assert ma.is_xray_intensity_array()
  ac = ma.deep_copy()
  assert flex.order(ac.data(), ma.data()) == 0
  assert flex.order(ac.sigmas(), ma.sigmas()) == 0
  assert ac.info() == "Test"
  assert ac.is_xray_intensity_array()
  aa = ac.as_amplitude_array()
  assert aa.is_xray_amplitude_array()
  assert aa.as_amplitude_array() is aa
  ai = aa.as_intensity_array()
  assert ai.is_xray_intensity_array()
  assert approx_equal(ai.data(), ac.data())
  assert ai.as_intensity_array() is ai
  assert aa.eliminate_sys_absent() is aa
  assert ma.sigmas_are_sensible()
  assert ma.sigmas_are_sensible(epsilon=0.15)
  assert ma.sigmas_are_sensible(epsilon=0.15, critical_ratio=0.51)
  assert not ma.sigmas_are_sensible(epsilon=0.15, critical_ratio=0.49)
  assert not ma.sigmas_are_sensible(epsilon=0.25)
  ma_copy = ma.deep_copy()
  ma_filt = ma.delete_index((0,0,-4))
  assert (ma_filt.indices().size() == ma_filt.data().size() == 1)
  ma_filt2 = ma.delete_indices(other=ma_filt)
  assert (ma_filt2.indices().size() == 1)
  aa = miller.array(
    miller_set=miller.set(
      crystal_symmetry=crystal.symmetry(
        unit_cell=aa.unit_cell(),
        space_group_symbol="F222"),
      indices=aa.indices()),
    data=aa.data())
  ae = aa.eliminate_sys_absent()
  assert ae is not aa
  assert tuple(ae.indices()) == ((0,0,-4),)
  a_s = aa.select_sys_absent()
  assert a_s is not aa
  assert tuple(a_s.indices()) == ((1,-2,3),)
  s = StringIO()
  aa.eliminate_sys_absent(log=s, prefix="%^")
  assert not show_diff(s.getvalue(), """\
%^Removing 1 systematic absence:
%^  Average absolute value of:
%^    Absences: 1
%^      Others: 1.41421
%^       Ratio: 0.707107

""")
  s = StringIO()
  aa.eliminate_sys_absent(integral_only=True, log=s, prefix="%^")
  assert not show_diff(s.getvalue(), """\
%^Removing 1 integral systematic absence:
%^  Average absolute value of:
%^    Absences: 1
%^      Others: 1.41421
%^       Ratio: 0.707107

""")
  aa = aa.customized_copy(data=flex.complex_double([1+1j,2-2j]))
  s = StringIO()
  aa.eliminate_sys_absent(log=s, prefix="%^")
  assert not show_diff(s.getvalue(), """\
%^Removing 1 systematic absence:
%^  Average absolute value of:
%^    Absences: 1.41421
%^      Others: 2.82843
%^       Ratio: 0.5

""")
  aa = aa.customized_copy(data=flex.int([3,7]), anomalous_flag=True) \
    .expand_to_p1().customized_copy(crystal_symmetry=aa)
  s = StringIO()
  aa.eliminate_sys_absent(log=s, prefix="%^")
  assert not show_diff(s.getvalue(), """\
%^Removing 4 systematic absences.

""")
  #
  for deg in [None, False, True]:
    asu = ma.map_to_asu(deg=deg)
    assert tuple(asu.indices()) == ((1,2,3), (0,0,4))
    if (deg is None):
      assert asu.data().all_eq(ma.data())
    else:
      assert approx_equal(asu.data(), [-1, 2])
  #
  mi = flex.miller_index(((1,2,3), (-1,-2,-3), (2,3,4), (-2,-3,-4), (3,4,5)))
  data = flex.double((1,2,5,3,6))
  sigmas = flex.double((0.1,0.2,0.3,0.4,0.5))
  ms = miller.set(xs, mi, anomalous_flag=True)
  ma = miller.array(ms, data, sigmas)
  assert ma.set().__class__.__name__ == "set"
  assert ma.set().space_group_info() is ma.space_group_info()
  assert ma.set().indices() is ma.indices()
  assert ma.discard_sigmas().sigmas() is None
  ad = ma.anomalous_differences()
  assert tuple(ad.indices()) == ((1,2,3), (2,3,4))
  assert approx_equal(tuple(ad.data()), (-1.0, 2.0))
  assert approx_equal(tuple(ad.sigmas()), (math.sqrt(0.05), 0.5))
  for hp,hm in ((ma.hemisphere_acentrics("+"), ma.hemisphere_acentrics("-")),
                ma.hemispheres_acentrics()):
    assert tuple(hp.indices()) == ((1,2,3), (2,3,4))
    assert approx_equal(tuple(hp.data()), (1,5))
    assert approx_equal(tuple(hp.sigmas()), (0.1,0.3))
    assert tuple(hm.indices()) == ((-1,-2,-3), (-2,-3,-4))
    assert approx_equal(tuple(hm.data()), (2,3))
    assert approx_equal(tuple(hm.sigmas()), (0.2,0.4))
  assert approx_equal(ma.anomalous_signal(), 0.5063697)
  app = ma.anomalous_probability_plot()
  for app in (app, pickle.loads(pickle.dumps(app))):
    assert approx_equal(app.slope, 6.280403781181725)
    assert approx_equal(app.intercept, -0.23606797749978936)
    assert app.n_pairs ==  2
  assert ma.measurability() == 1.0
  assert approx_equal(ma.anomalous_completeness(), 0.018018)
  assert approx_equal(ma.anomalous_completeness(
    relative_to_complete_set=False), 0.66666667)
  ma.setup_binner(n_bins=3)
  acb = ma.anomalous_completeness(use_binning=True)
  sigma_test_meas = flex.double(5,0.3)
  m_test_meas = miller.array(ms, data, sigma_test_meas )
  assert m_test_meas.measurability() == 0.5
  ms = miller.set(crystal.symmetry(), mi, anomalous_flag=True)
  ma = miller.array(ms, data, sigmas)
  ad = ma.anomalous_differences()
  assert tuple(ad.indices()) == ((1,2,3), (2,3,4))
  for hp,hm in ((ma.hemisphere_acentrics("+"), ma.hemisphere_acentrics("-")),
                ma.hemispheres_acentrics()):
    assert tuple(hp.indices()) == ((1,2,3), (2,3,4))
    assert approx_equal(tuple(hp.data()), (1,5))
    assert approx_equal(tuple(hp.sigmas()), (0.1,0.3))
    assert tuple(hm.indices()) == ((-1,-2,-3), (-2,-3,-4))
    assert approx_equal(tuple(hm.data()), (2,3))
    assert approx_equal(tuple(hm.sigmas()), (0.2,0.4))
  assert approx_equal(ma.anomalous_signal(), 0.5063697)
  assert tuple(ma.all_selection()) == (True,True,True,True,True)
  for sa in (ma.select(flex.bool((True,False,False,True,False))),
             ma.select(flex.size_t((0,3)))):
    assert tuple(sa.indices()) == ((1,2,3), (-2,-3,-4))
    assert approx_equal(tuple(sa.data()), (1,3))
    assert approx_equal(tuple(sa.sigmas()), (0.1,0.4))
  # test corrupt sigmas and anomalous differences
  mi2 = flex.miller_index([(-9,-2,0), (9,2,0), (-2,-9,0), (2,-11,0),
    (9,-11,0), (2,9,0)])
  data2 = flex.double([1229,1427,1687,1614,1802,1661])
  sigmas2 = flex.double([-4.897,-5.665,-6.973,6.764,7.375,6.853])
  cs2 = crystal.symmetry(
    space_group_symbol="P 3 2 1",
    unit_cell=(167.578, 167.578, 93.934, 90.000, 90.000,120.000))
  ma2 = miller.set(crystal_symmetry=cs2,
    anomalous_flag=True,
    indices=mi2).array(data=data2,
      sigmas=sigmas2).merge_equivalents().array()
  ma3 = ma2.enforce_positive_sigmas()
  assert ma3.size() == 1
  dano = ma2.anomalous_differences()
  assert dano.size() == 1
  dano2 = ma2.anomalous_differences(enforce_positive_sigmas=True)
  assert dano2.size() == 0
  #
  ms = miller.build_set(xs, anomalous_flag=False, d_min=1)
  assert ms.is_unique_set_under_symmetry()
  assert ms.unique_under_symmetry() is ms
  ma = miller.array(ms)
  sa = ma.resolution_filter()
  assert ma.indices().size() == sa.indices().size()
  sa = ma.resolution_filter(0.5)
  assert sa.indices().size() == 0
  sa = ma.resolution_filter(d_min=2)
  assert sa.indices().size() == 10
  sa = ma.resolution_filter(d_min=2, negate=True)
  assert sa.indices().size() == 38
  ma = ma.d_spacings()
  ma = miller.array(ma, ma.data(), ma.data().deep_copy())
  assert ma.indices().size() == 48
  #
  indices=flex.miller_index(((-3,0,0),(2,2,1),(0,3,3)))
  sa = ma.select_indices(indices=indices).sort(
    by_value="packed_indices")
  assert sa.indices().size() == 2
  assert approx_equal(sa.indices(), ((0, 3, 3),(2, 2, 1)))
  sa = ma.select_indices(indices=indices, map_indices_to_asu=True).sort(
    by_value="packed_indices")
  assert sa.indices().size() == 3
  assert approx_equal(sa.indices(), ((0, 3, 3),(2, 2, 1),(3,0,0)))
  sa = ma.select_indices(indices=indices, negate=True)
  assert sa.indices().size() == 46
  sa = ma.select_indices(indices=indices, map_indices_to_asu=True,
                         negate=True)
  assert sa.indices().size() == 45
  for index in indices:
    assert index not in sa.indices()
  ms2 = miller.set(xs, flex.miller_index(((0,0,1),(0,0,1),(0,0,2))))
  ma2 = miller.array(ms2, flex.double((4,2,3)), sigmas=flex.double((0.4,0.1,0.6)))
  indices=flex.miller_index(((0,0,1),))
  try:
    sa = ma2.select_indices(indices=indices)
  except RuntimeError as e:
    assert not show_diff(
      str(e),
      ("cctbx.miller.array.select_indices(): "
       "This method can only be used reliably on a merged array"))
  else: raise Exception_expected
  #
  sa = ma.sigma_filter(0.5)
  assert sa.indices().size() == 48
  sa = ma.sigma_filter(2)
  assert sa.indices().size() == 0
  for i in (1,13,25,27,39):
    ma.sigmas()[i] /= 3
  sa = ma.sigma_filter(2)
  assert sa.indices().size() == 5
  assert approx_equal(ma.mean(False,False), 1.6460739)
  assert approx_equal(ma.mean(False,True), 1.5146784)
  ma.setup_binner(n_bins=3)
  assert approx_equal(ma.mean(True,False).data[1:-1],
    (2.228192, 1.2579831, 1.0639812))
  assert approx_equal(ma.mean(True,True).data[1:-1],
    (2.069884, 1.2587977, 1.0779636))
  assert approx_equal(ma.mean_sq(False,False), 3.3287521)
  assert approx_equal(ma.mean_sq(False,True), 2.6666536)
  assert approx_equal(ma.mean_sq(True,False).data[1:-1],
    (5.760794, 1.5889009, 1.1336907))
  assert approx_equal(ma.mean_sq(True,True).data[1:-1],
    (4.805354, 1.5916849, 1.1629777))
  assert approx_equal(ma.sum(False,False), 79.01154935280627)
  assert approx_equal(ma.sum(False,True), 72.704563158141255)
  assert approx_equal(ma.sum(True,False).data[1:-1],
    (46.792023266563191, 22.643695504219149, 9.5758305820238991))
  assert approx_equal(ma.sum(True,True).data[1:-1],
    (43.467564215172203, 22.658357766449797, 9.7016727390599851))
  assert approx_equal(ma.sum_sq(False,False), 159.7800992093843)
  assert approx_equal(ma.sum_sq(False,True), 127.9993737702583)
  assert approx_equal(ma.sum_sq(True,False).data[1:-1],
    (120.9766669251709, 28.600215901274829, 10.203216382938619))
  assert approx_equal(ma.sum_sq(True,True).data[1:-1],
    (100.91243638831548, 28.650328284843834, 10.466799373124193))
  assert approx_equal(ma.rms(False,False)**2, 3.3287521)
  assert approx_equal(ma.rms(False,True)**2, 2.6666536)
  assert approx_equal([x**2 for x in ma.rms(True,False).data[1:-1]],
    ma.mean_sq(True,False).data[1:-1])
  assert approx_equal([x**2 for x in ma.rms(True,True).data[1:-1]],
    ma.mean_sq(True,True).data[1:-1])
  for use_binning in (False,True):
    for use_multiplicities in (False,True):
      sa = ma.rms_filter(-1, use_binning, use_multiplicities)
      assert sa.indices().size() == 0
      sa = ma.rms_filter(100, use_binning, use_multiplicities, False)
      assert sa.indices().size() == ma.indices().size()
      sa = ma.rms_filter(-1, use_binning, use_multiplicities, negate=True)
      assert sa.indices().size() == ma.indices().size()
      sa = ma.rms_filter(100, use_binning, use_multiplicities, negate=True)
      assert sa.indices().size() == 0
      sa = ma.rms_filter(1.0, use_binning, use_multiplicities)
      assert sa.indices().size() \
          == ((36, 33), (29, 29))[use_binning][use_multiplicities]
  assert approx_equal(ma.statistical_mean(), 1.380312)
  s = StringIO()
  ma.count_and_fraction_in_bins(
    data_value_to_count=2).show(f=s)
  assert not show_diff(s.getvalue(), """\
unused:        - 5.0001 [ 0/0 ] 0 0.0000
bin  1: 5.0001 - 1.4346 [21/21] 1 0.0476
bin  2: 1.4346 - 1.1432 [18/18] 0 0.0000
bin  3: 1.1432 - 1.0000 [ 9/10] 0 0.0000
unused: 1.0000 -        [ 0/0 ] 0 0.0000
""")
  s = StringIO()
  ma.count_and_fraction_in_bins(
    data_value_to_count=2, count_not_equal=True).show(f=s)
  assert not show_diff(s.getvalue(), """\
unused:        - 5.0001 [ 0/0 ]  0 0.0000
bin  1: 5.0001 - 1.4346 [21/21] 20 0.9524
bin  2: 1.4346 - 1.1432 [18/18] 18 1.0000
bin  3: 1.1432 - 1.0000 [ 9/10]  9 1.0000
unused: 1.0000 -        [ 0/0 ]  0 0.0000
""")
  assert approx_equal(tuple(ma.statistical_mean(True)),
                      (1.768026, 1.208446, 0.9950434))
  no = ma.remove_patterson_origin_peak()
  assert approx_equal(no.data()[0], 3.231974)
  assert approx_equal(no.data()[47], 0.004956642)
  no = ma.quasi_normalize_structure_factors(d_star_power=0)
  assert approx_equal(no.data()[0], 2.4378468)
  assert approx_equal(no.data()[47], 0.9888979)
  no = ma.quasi_normalize_structure_factors()
  assert approx_equal(no.data()[0], 2.00753806261)
  assert approx_equal(no.data()[47], 1.09976342511)
  su = ma + 3
  assert approx_equal(tuple(su.data()), tuple(ma.data() + 3))
  su = ma + ma
  assert approx_equal(tuple(su.data()), tuple(ma.data() * 2))
  assert approx_equal(tuple(su.sigmas()), tuple(ma.sigmas() * math.sqrt(2)))
  for f_sq_as_f_algorithm in ["xtal_3_7", "crystals"]:
    for f_as_f_sq_algorithm in ["simple", "shelxl"]:
      s = ma.f_as_f_sq(algorithm=f_as_f_sq_algorithm)
      v = s.f_sq_as_f(algorithm=f_sq_as_f_algorithm)
      assert approx_equal(ma.data(), v.data())
      assert not_approx_equal(ma.sigmas(), v.sigmas())
      s = miller.array(ma, ma.data()).f_as_f_sq(algorithm=f_as_f_sq_algorithm)
      v = s.f_sq_as_f(algorithm=f_sq_as_f_algorithm)
      assert approx_equal(ma.data(), v.data())
      assert s.sigmas() is None
      assert v.sigmas() is None
  ma = miller.array(ms)
  s = ma[:]
  assert s.data() is None
  assert s.sigmas() is None
  ma = miller.array(ms, flex.double((1,2)))
  s = ma[:]
  assert s.data().all_eq(ma.data())
  assert s.sigmas() is None
  ma = miller.array(ms, flex.double((1,2)), flex.double((3,4)))
  s = ma[:]
  assert s.data().all_eq(ma.data())
  assert s.sigmas().all_eq(ma.sigmas())
  xs = crystal.symmetry((3,4,5), "P 1 1 21")
  mi = flex.miller_index(((0,0,1), (0,0,2), (0,0,-3), (0,0,-4)))
  ms = miller.set(xs, mi)
  ma = miller.array(ms).remove_systematic_absences()
  assert tuple(ma.indices()) == ((0,0,2), (0,0,-4))
  ma = miller.array(ms).remove_systematic_absences(negate=True)
  assert tuple(ma.indices()) == ((0,0,1), (0,0,-3))
  ma = miller.array(ms, flex.double((3,4,1,-2)), flex.double((.3,.4,.1,.2)))
  sa = ma.sort(by_value="resolution")
  assert tuple(sa.indices()) == ((0,0,1), (0,0,2), (0,0,-3), (0,0,-4))
  assert approx_equal(sa.data(), (3,4,1,-2))
  assert approx_equal(sa.sigmas(), (.3,.4,.1,.2))
  sa = ma.sort(by_value="resolution", reverse=True)
  assert tuple(sa.indices()) == ((0,0,-4), (0,0,-3), (0,0,2), (0,0,1))
  assert approx_equal(sa.data(), (-2,1,4,3))
  assert approx_equal(sa.sigmas(), (.2,.1,.4,.3))
  sa = ma.sort(by_value="packed_indices", reverse=True)
  assert tuple(sa.indices()) == ((0,0,2), (0,0,1), (0,0,-3), (0,0,-4))
  sa = ma.sort(by_value="data")
  assert approx_equal(sa.data(), (4,3,1,-2))
  sa = ma.sort(by_value="data", reverse=True)
  assert approx_equal(sa.data(), (-2,1,3,4))
  sa = ma.sort(by_value="abs")
  assert approx_equal(sa.data(), (4,3,-2,1))
  sa = ma.sort(by_value="abs", reverse=True)
  assert approx_equal(sa.data(), (1,-2,3,4))
  sa = ma.sort(by_value=flex.double((3,1,4,2)))
  assert tuple(sa.indices()) == ((0,0,-3), (0,0,1), (0,0,-4), (0,0,2))
  sa = ma.sort(by_value=flex.double((3,1,4,2)), reverse=True)
  assert tuple(sa.indices()) == ((0,0,2), (0,0,-4), (0,0,1), (0,0,-3))
  aa = sa.adopt_set(ma)
  assert tuple(aa.indices()) == tuple(ma.indices())
  assert approx_equal(aa.data(), ma.data())
  assert approx_equal(aa.sigmas(), ma.sigmas())
  sa = ma.apply_scaling(target_max=10)
  assert approx_equal(flex.max(sa.data()), 10)
  assert approx_equal(flex.max(sa.sigmas()), 1)
  sa = sa.apply_scaling(factor=3)
  assert approx_equal(flex.max(sa.data()), 30)
  assert approx_equal(flex.max(sa.sigmas()), 3)
  ma = miller.array(miller.set(xs, mi, False),data,sigmas).patterson_symmetry()
  assert str(ma.space_group_info()) == "P 1 1 2/m"
  assert ma.indices() == mi
  assert ma.data() == data
  assert ma.sigmas() == sigmas
  a1 = miller.array(
    miller.set(xs, flex.miller_index(((1,-2,3), (0,0,-4)))),
    flex.double((1,2)))
  a2 = miller.array(
    miller.set(xs, flex.miller_index(((0,0,-5), (1,-2,3)))),
    flex.double((3,4)),
    flex.double((5,6)))
  a3 = miller.array(
    miller.set(xs, flex.miller_index(((1,0,1), (0,0,-4), (0,0,-5), (1,-2,3)))),
    flex.double((5,6,7,8)),
    flex.double((1,2,3,4)))
  m1 = a1.matching_set(other=a2, data_substitute=13)
  assert m1.indices() is a2.indices()
  assert approx_equal(m1.data(), (13, 1))
  m2 = a2.matching_set(other=a1, data_substitute=15, sigmas_substitute=17)
  assert m2.indices() is a1.indices()
  assert approx_equal(m2.data(), (4, 15))
  assert approx_equal(m2.sigmas(), (6, 17))
  m3 = a2.matching_set(other=a3, data_substitute=a3.data(),
                       sigmas_substitute=a3.sigmas())
  assert m3.indices() is a3.indices()
  assert approx_equal(m3.data(), (5,6,3,4))
  assert approx_equal(m3.sigmas(), (1,2,5,6))
  c1 = a1.common_set(a2)
  assert tuple(c1.indices()) == ((1,-2,3),)
  assert tuple(c1.data()) == (1,)
  c2 = a2.common_set(a1)
  assert tuple(c2.indices()) == ((1,-2,3),)
  assert tuple(c2.data()) == (4,)
  assert tuple(c2.sigmas()) == (6,)
  l1 = a1.lone_set(a2)
  assert list(l1.indices()) == [(0,0,-4)]
  assert list(l1.data()) == [2]
  l2 = a2.lone_set(a1)
  assert list(l2.indices()) == [(0,0,-5)]
  assert list(l2.data()) == [3]
  l1, l2 = a1.lone_sets(a2)
  assert list(l1.indices()) == [(0,0,-4)]
  assert list(l2.indices()) == [(0,0,-5)]
  assert tuple(c1.adopt_set(c2).indices()) == ((1,-2,3),)
  sg = miller.array(
    miller.set(xs, flex.miller_index(((0,0,-5), (1,-2,3))), False),
    flex.double((3,4)))
  p1, isel = sg.expand_to_p1(return_iselection=True)
  assert list(isel) == [0,1,1]
  assert p1.indices().size() == 3
  assert approx_equal(tuple(p1.data()), (3,4,4))
  assert p1.sigmas() is None
  sg = miller.array(
    miller.set(xs, flex.miller_index(((0,0,-5), (1,-2,3))), False),
    flex.double((3,4)),
    flex.double((5,6)))
  p1 = sg.expand_to_p1()
  assert p1.indices().size() == 3
  assert approx_equal(tuple(p1.data()), (3,4,4))
  assert approx_equal(tuple(p1.sigmas()), (5,6,6))
  sg = sg.customized_copy(data=flex.bool([False, True]), sigmas=None)
  p1 = sg.expand_to_p1()
  assert p1.indices().size() == 3
  assert p1.data().all_eq(flex.bool([False, True, True]))
  sg = sg.customized_copy(data=flex.int([3, 5]))
  p1 = sg.expand_to_p1()
  assert p1.indices().size() == 3
  assert p1.data().all_eq(flex.int([3, 5, 5]))
  #
  xs = crystal.symmetry((3,4,5), "P 2 2 2")
  mi = flex.miller_index(((1,-2,3), (0,0,-4)))
  data = flex.double((1,2))
  a = miller.array(miller.set(xs, mi), data)
  ph = flex.double((10,20))
  b = a.phase_transfer(ph, deg=True)
  assert approx_equal(b.amplitudes().data(), a.data())
  assert approx_equal(b.intensities().data(), flex.pow2(a.data()))
  assert approx_equal(b.phases(deg=True).data(), (10,0))
  ph = ph * math.pi/180
  b = a.phase_transfer(ph, deg=False)
  assert approx_equal(tuple(b.amplitudes().data()), a.data())
  assert approx_equal(tuple(b.phases(deg=True).data()), (10,0))
  c = a.phase_transfer(b.data())
  assert approx_equal(tuple(c.amplitudes().data()), a.data())
  assert approx_equal(tuple(c.phases(deg=True).data()), (10,0))
  a = miller.array(miller_set=a, data=flex.complex_double([1+2j,2-3j]))
  c = a.conjugate()
  assert approx_equal(a.data(), flex.conj(c.data()))
  ms = miller_set=miller.build_set(
    crystal_symmetry=crystal.symmetry(
      unit_cell=(11,11,13,90,90,120),
      space_group_symbol="P31m"),
    anomalous_flag=True,
    d_min=3)
  ma = miller.array(
    miller_set=ms,
    data=flex.double(range(ms.indices().size())))
  assert ma.remove_cone(fraction_percent=10).data().size() == 43
  ma.set_observation_type_xray_amplitude()
  assert ma.select_acentric().data().size() == 48
  assert ma.select_centric().data().size() == 3
  ma.setup_binner(auto_binning=True).counts_complete(
    include_acentric=False,
    include_centric=False)
  assert ma.binner().counts_complete() == [0]*10
  for i_trial in [0,1]:
    if (i_trial == 1): ma = ma.f_as_f_sq()
    assert approx_equal(ma.second_moment_of_intensities(), 1.81758415842)
    assert approx_equal(ma.wilson_ratio(), 0.742574257426)
    ma.setup_binner(auto_binning=True).counts_complete(include_centric=False)
    s = StringIO()
    ma.second_moment_of_intensities(use_binning=True).show(f=s)
    assert s.getvalue() == """\
unused:         - 13.0001 [ 0/0 ]
bin  1: 13.0001 -  5.9727 [ 7/6 ]  2.1658
bin  2:  5.9727 -  4.8197 [ 8/8 ]  1.1899
bin  3:  4.8197 -  4.2345 [ 5/4 ]  1.6278
bin  4:  4.2345 -  3.8585 [ 6/6 ]  1.2952
bin  5:  3.8585 -  3.5881 [ 4/4 ]  1.0429
bin  6:  3.5881 -  3.3805 [ 8/8 ]  1.2980
bin  7:  3.3805 -  3.2139 [ 2/2 ]  1.0234
bin  8:  3.2139 -  3.0759 [11/10]  1.2283
unused:  3.0759 -         [ 0/0 ]
"""
    s = StringIO()
    ma.wilson_ratio(use_binning=True).show(f=s)
    d_max, d_min = ma.d_max_min()
    cl = ma.resolution_filter(d_min = 6.0,  d_max = d_max).completeness()
    ch = ma.resolution_filter(d_min = d_min,d_max = 6.0).completeness(d_max =
                                                                           6.0)
    ca = ma.resolution_filter().completeness()
    assert approx_equal(cl+ch+ca, 3.0)
    assert s.getvalue() == """\
unused:         - 13.0001 [ 0/0 ]
bin  1: 13.0001 -  5.9727 [ 7/6 ]  0.6007
bin  2:  5.9727 -  4.8197 [ 8/8 ]  0.9349
bin  3:  4.8197 -  4.2345 [ 5/4 ]  0.7079
bin  4:  4.2345 -  3.8585 [ 6/6 ]  0.9247
bin  5:  3.8585 -  3.5881 [ 4/4 ]  0.9892
bin  6:  3.5881 -  3.3805 [ 8/8 ]  0.9079
bin  7:  3.3805 -  3.2139 [ 2/2 ]  0.9941
bin  8:  3.2139 -  3.0759 [11/10]  0.9134
unused:  3.0759 -         [ 0/0 ]
"""
  assert ma.binner() is not None
  ml = pickle.loads(pickle.dumps(ma))
  sa = StringIO()
  sl = StringIO()
  ma.binner().show_summary(f=sa)
  ml.binner().show_summary(f=sl)
  assert not show_diff(sl.getvalue(), sa.getvalue())
  ma.clear_binner()
  assert ma.binner() is None
  ml = pickle.loads(pickle.dumps(ma))
  assert ml.binner() is None
  sa = StringIO()
  sl = StringIO()
  ma.show_summary(f=sa).show_array(f=sa)
  ml.show_summary(f=sl).show_array(f=sl)
  assert sa.getvalue() == sl.getvalue()
  #
  for i_trial in [0,1,2]:
    if (i_trial == 0):
      d = flex.random_double(size=ma.indices().size())
    elif (i_trial == 1):
      d = d < 0.5
    else:
      d = flex.int(list(flex.random_size_t(size=ma.indices().size()) % 100))
    b = ma.customized_copy(
      indices=ma.indices().concatenate(ma.indices()),
      data=d.concatenate(d))
    m = b.merge_equivalents()
    s = StringIO()
    m.show_summary(n_bins=3, out=s, prefix="@#")
    if (i_trial == 0):
      assert not show_diff(s.getvalue().replace("-0.0000", " 0.0000"), """\
@#R-linear = sum(abs(data - mean(data))) / sum(abs(data))
@#R-square = sum((data - mean(data))**2) / sum(data**2)
@#In these sums single measurements are excluded.
@#                             Redundancy       Mean      Mean
@#                           Min  Max   Mean  R-linear  R-square
@#unused:         - 13.0001
@#bin  1: 13.0001 -  4.3977    2    2  2.000    0.0000    0.0000
@#bin  2:  4.3977 -  3.5133    2    2  2.000    0.0000    0.0000
@#bin  3:  3.5133 -  3.0759    2    2  2.000    0.0000    0.0000
@#unused:  3.0759 -
""")
    else:
      assert not show_diff(s.getvalue(), """\
@#                             Redundancy
@#                           Min  Max   Mean
@#unused:         - 13.0001
@#bin  1: 13.0001 -  4.3977    2    2  2.000
@#bin  2:  4.3977 -  3.5133    2    2  2.000
@#bin  3:  3.5133 -  3.0759    2    2  2.000
@#unused:  3.0759 -
""")
  #
  ma.set_info(miller.array_info(
    source="fake",
    crystal_symmetry_from_file=crystal.symmetry(
      unit_cell=(10,10,12,90,90,120),
      space_group="P6")))
  assert ma.is_in_asu()
  s = ma.crystal_symmetry_is_compatible_with_symmetry_from_file()
  assert not s.unit_cell_is_compatible
  assert not s.space_group_is_compatible
  assert not show_diff(s.format_error_message(data_description="made up"), """\
Working crystal symmetry is not compatible with crystal symmetry from reflection file:
  made up: fake
  Unit cell from file: (10, 10, 12, 90, 90, 120)
    Working unit cell: (11, 11, 13, 90, 90, 120)
  Space group from file: P 6
    Working space group: P 3 1 m""")
  #
  xs = crystal.symmetry((3,4,5), "P 2 2 2")
  mi = flex.miller_index(((1,-2,3), (0,0,-4)))
  data = flex.double((1,2,3,4))
  sigmas = flex.double((0.1,0.2,0.3,0.4)).reversed()
  ms = miller.set(xs, mi)
  ma = miller.array(ms, data)
  assert ma.min_f_over_sigma() is None
  ma = miller.array(ms, data, sigmas)
  assert approx_equal(ma.min_f_over_sigma(), 2.5)
  sigmas[1] = 0
  assert approx_equal(ma.min_f_over_sigma(), 0)
  sigmas[2] = -1
  ma = miller.array(ms, data, sigmas)
  try: ma.min_f_over_sigma()
  except AssertionError: pass
  else: raise Exception_expected
  ma = miller.set(xs, indices=flex.miller_index()).array(
    data=flex.double(), sigmas=flex.double())
  assert ma.min_f_over_sigma() is None
  #
  ma = miller.array(ms, data[:2])
  maa = ma.combine(other=ma)
  assert not maa.anomalous_flag()
  ms = miller.set(xs, mi, anomalous_flag=True)
  ma = miller.array(ms, data[:2])
  maa = ma.combine(other=ma)
  assert maa.anomalous_flag()
  #
  maa = ma * ma
  assert approx_equal(maa.data(), [1,4])
  maa = ma * ma.data()
  assert approx_equal(maa.data(), [1,4])
  #
  ma = ms.array(
    data=flex.complex_double([1+2j, 2-3j]), sigmas=flex.double((2,3)))
  maa = ma.as_amplitude_array()
  assert maa.is_xray_amplitude_array()
  assert approx_equal(maa.data(), [5**0.5, 13**0.5])
  assert approx_equal(maa.sigmas(), (2,3))
  mai = ma.as_intensity_array()
  assert mai.is_xray_intensity_array()
  assert approx_equal(mai.data(), [5, 13])
  assert approx_equal(maa.as_intensity_array().data(), [5, 13])
  assert approx_equal(maa.as_intensity_array().sigmas(), mai.sigmas())
  assert approx_equal(mai.as_amplitude_array().data(), [5**0.5, 13**0.5])
  mai.set_sigmas(None)
  assert mai.sigmas() is None
  mai.set_sigmas(maa.as_intensity_array().sigmas())
  assert approx_equal(maa.as_intensity_array().sigmas(), mai.sigmas())
  #
  ms = miller.build_set(
    crystal_symmetry=xs,
    anomalous_flag=False,
    d_min=2)
  sz = ms.indices().size()
  assert sz >= 10
  mt = flex.mersenne_twister(seed=1)
  mc = ms.array(
    data=flex.complex_double(
      mt.random_double(sz)*2-1,
      mt.random_double(sz)*2-1))
  mb = ms.array(data=mt.random_double(sz))
  ma = mc.as_amplitude_array()
  for fc in [mc, ma]:
    sel = ma.f_obs_f_calc_fan_outlier_selection(f_calc=fc)
    assert sel.count(True) == 0
    sel = mb.f_obs_f_calc_fan_outlier_selection(f_calc=fc)
    assert sel.count(True) == 8 # depends on mt seed above
  xs = crystal.symmetry((3,4,5,85,95,105), "P 1")
  mi = flex.miller_index(((1,2,3), (3,0,3), (2,4,1),(0,1,2)))
  ms = miller.set(xs, mi, False)
  ma = miller.array(ms, data=flex.double([1,2,3,4]))
  maa = ma.slice(axis="l", slice_index=3)
  assert approx_equal(maa.data(), [1.0,2.0])
  maa = ma.slice(axis="h", slice_start=1, slice_end=2)
  assert approx_equal(maa.data(), [1.0,3.0])
  #
  ms = miller.set(crystal_symmetry=crystal.symmetry(
    unit_cell=(7.783,8.7364,10.9002,90,102.984,90),
    space_group_symbol='P 1 21 1'),
                  indices=flex.miller_index((
                    (1,0,7),
                    (1,0,8),
                    (1,0,9),
                    (1,0,10),
                    (1,0,11),
                    (1,0,12),
                    (1,1,0),
                    (1,1,1),
                    (1,1,2),
                    (1,1,3),
                    (1,1,4),
                    (1,1,5))))
  fo2 = ms.array(data=flex.double((45.53,-3.10,168.10,-1.51,18.92,-6.10,856.51,2795.86,
                                   6685.00,959.27,1125.99,765.78)),
                 sigmas=flex.double((3.06,3.10,4.50,3.42,4.12,6.72,22.33,662.76,
                                     177.27,16.72,16.36,17.00)))\
      .set_observation_type_xray_intensity()
  fc2 = ms.array(data=flex.double((45.88,0.98,159.37,2.39,22.74,0.03,907.43,
                                   4412.96,7872.73,886.38,1144.82,783.14)))\
      .set_observation_type_xray_intensity()
  s = StringIO()
  r = fo2.show_disagreeable_reflections(fc2, out=s)
  assert r.delta_f_sq_over_sigma.size() == 12
  assert not show_diff(s.getvalue(), """\
  h   k   l       Fo^2      Fc^2   |Fo^2-Fc^2|/sig(F^2)   Fc/max(Fc)  d spacing(A)
  1   1   2    6685.00   7872.73             6.70              1.00          3.60
  1   1   3     959.27    886.38             4.36              0.34          2.81
  1   1   1    2795.86   4412.96             2.44              0.75          4.72
  1   1   0     856.51    907.43             2.28              0.34          5.73
  1   0   9     168.10    159.37             1.94              0.14          1.13
  1   0   8      -3.10      0.98             1.32              0.01          1.26
  1   1   4    1125.99   1144.82             1.15              0.38          2.27
  1   0  10      -1.51      2.39             1.14              0.02          1.02
  1   1   5     765.78    783.14             1.02              0.32          1.89
  1   0  11      18.92     22.74             0.93              0.05          0.93
  1   0  12      -6.10      0.03             0.91              0.00          0.86
  1   0   7      45.53     45.88             0.11              0.08          1.43
""")
  f = fo2.value_at_index((1,1,2))
  assert (f == 6685.0)

def exercise_debye_waller():
  xs = crystal.symmetry((3,4,5,85,95,105), "P 1")
  mi = flex.miller_index(((1,2,3), (-2,1,-3)))
  ms = miller.set(xs, mi, False)
  dw = ms.debye_waller_factors
  assert approx_equal(
    dw(u_iso=0.01).data(),
    [0.8488782, 0.8378216])
  assert approx_equal(
    dw(b_iso=1.01).data(),
    [0.8109245, 0.7974382])
  assert approx_equal(
    dw(u_cart=[0.06,0.04,0.05,0.01,0.02,0.03]).data(),
    [0.2393822, 0.2899416])
  assert approx_equal(
    dw(b_cart=[1.06,1.04,1.05,1.01,1.02,1.03]).data(),
    [0.5460102, 0.6644463])
  assert approx_equal(
    dw(u_cif=[0.04,0.06,0.05,0.01,0.02,0.03]).data(),
    [0.2517064, 0.4104245])
  assert approx_equal(
    dw(u_star=[0.0004,0.0006,0.0005,0.0001,0.0002,0.0003]).data(),
    [0.7813437, 0.8726676])
  #
  ma = ms.array(data=flex.double([2,3]), sigmas=flex.double([4,5]))
  ap = ma.apply_debye_waller_factors
  maa = ap(u_iso=0.01)
  assert approx_equal(maa.data(), [1.697756, 2.513465])
  assert approx_equal(maa.sigmas(), [3.395513, 4.189108])
  maa = ap(u_cart=[0.06,0.04,0.05,0.01,0.02,0.03], apply_to_sigmas=False)
  assert approx_equal(maa.data(), [0.4787644, 0.8698248])
  assert approx_equal(maa.sigmas(), [4, 5])
  #
  ap(b_iso=-250, exp_arg_limit=60)
  ap(b_iso=-250, truncate_exp_arg=True)

def exercise_r1_factor():
  cs = crystal.symmetry((1,2,3), "P21/a")
  mi = flex.miller_index([(1,-1,1), (2,0,-3), (4,1,-2)])
  f_o = miller.array(miller.set(cs, mi),
                     data=flex.double([10, 3, -1]))
  f_c = miller.array(miller.set(cs, mi),
                     data=flex.complex_double([5+3j, 2-1j, 1+2j]))
  assert approx_equal(f_o.r1_factor(f_c, assume_index_matching=True),
                      0.440646)
  assert approx_equal(f_o.r1_factor(f_c, assume_index_matching=True,
                                    emulate_sftools=True), 0.507676)
  f1_o = f_o.select(flex.random_permutation(f_o.size()))
  f1_c = f_c.select(flex.random_permutation(f_c.size()))
  assert approx_equal(f1_o.r1_factor(f1_c), 0.440646)
  assert approx_equal(f1_o.r1_factor(f1_c, scale_factor=Auto), 0.2802183)
  f1_o *= 2
  assert approx_equal(f1_o.r1_factor(f1_c, scale_factor=2), 0.440646)
  assert approx_equal(f1_o.r1_factor(f1_c, scale_factor=Auto), 0.2802183)
  f_o *= 2
  assert approx_equal(
    f_o.r1_factor(f_c, scale_factor=2, assume_index_matching=True), 0.440646)
  f1_c.indices().append((4,5,6))
  f1_c.data().append(0.5)
  try:
    f1_o.r1_factor(f1_c)
    raised = False
  except AssertionError:
    raised = True
  assert raised

def exercise_scale_factor():
  flex.set_random_seed(0)
  crystal_symmetry = crystal.symmetry(
    unit_cell=(10,11,12,85,95,100),
    space_group_symbol="P 1")
  miller_set = miller.build_set(
    crystal_symmetry=crystal_symmetry,
    anomalous_flag=False,
    d_min=2)
  f_c = miller_set.array(
    data=flex.polar(
      flex.random_double(miller_set.size(), 100),
      flex.random_double(miller_set.size(), 2*math.pi)))
  f_o = f_c.as_amplitude_array()
  f_sq_o = f_c.as_intensity_array()
  # first with no scale factor
  assert approx_equal(f_o.scale_factor(f_c), 1.)
  assert approx_equal(f_sq_o.scale_factor(f_c), 1.)
  assert approx_equal(
    f_o.scale_factor(f_c, cutoff_factor=0), 1.)
  # now try with scale factor
  scale_factor = flex.random_double()
  f_o = f_c.customized_copy(data=flex.abs(f_c.data())*scale_factor)
  f_o.set_observation_type_xray_amplitude()
  f_sq_o = f_o.as_intensity_array()
  assert approx_equal(f_o.scale_factor(f_c), scale_factor)
  assert approx_equal(f_sq_o.scale_factor(
    f_c, cutoff_factor=0.9), scale_factor*scale_factor)
  # let's make things more random and using weights
  f_o = miller_set.array(data=scale_factor * flex.abs(f_c.data())
                         + (flex.random_double(miller_set.size())*2-1),
                         sigmas=flex.random_double(miller_set.size()))
  f_o.set_observation_type_xray_amplitude()
  f_sq_o = f_o.f_as_f_sq()
  weights = 1./flex.pow2(f_o.sigmas())
  assert approx_equal(f_o.scale_factor(f_c, weights=weights),
                      scale_factor, eps=0.1)
  # using all of the data should give better estimate of true scale factor
  assert abs(f_o.scale_factor(f_c, weights=weights, cutoff_factor=0.5)
             - scale_factor) \
         > abs(f_o.scale_factor(f_c, weights=weights) - scale_factor)
  weights = 1./flex.pow2(f_sq_o.sigmas())
  assert approx_equal(f_sq_o.scale_factor(f_c, weights=weights),
                      scale_factor*scale_factor, eps=0.1)
  assert abs(f_sq_o.scale_factor(f_c, weights=weights, cutoff_factor=0.5)
             - scale_factor*scale_factor) \
         > abs(f_sq_o.scale_factor(f_c, weights=weights)
               - scale_factor*scale_factor)
  f_sq_o.setup_binner(n_bins=10)
  for w in [weights, None]:
    binned_data = f_sq_o.scale_factor(f_c, weights=w, use_binning=True)
    assert isinstance(binned_data, miller.binned_data)
    assert len(binned_data.data) == binned_data.binner.n_bins_all()

def exercise_array_2(space_group_info):
  xs = space_group_info.any_compatible_crystal_symmetry(volume=60)
  for anomalous_flag in (False, True):
    st = miller.build_set(xs, anomalous_flag, d_min=1)
    for sigmas in (None, flex.double(range(1,st.indices().size()+1))):
      sg = miller.array(
        st,
        data=flex.double(range(st.indices().size())),
        sigmas=sigmas)
      p1 = sg.expand_to_p1()
      ps = miller.array(
        miller.set(xs, p1.indices(), p1.anomalous_flag()),
        p1.data(),
        p1.sigmas())
      m = ps.merge_equivalents()
      p = m.array().sort_permutation(by_value="data", reverse=True)
      assert flex.order(sg.indices(), m.array().indices().select(p)) == 0
      assert approx_equal(sg.data(), m.array().data().select(p))
      if (sigmas is not None):
        s = m.array().sigmas().select(p)
        r = m.redundancies().data().select(p)
        sr = s * flex.sqrt(r.as_double())
        assert approx_equal(sr, sigmas)
      #
      us = ps.select(flex.random_permutation(size=ps.indices().size())) \
        .unique_under_symmetry()
      assert us.indices().size() == m.array().indices().size()
      assert us.map_to_asu().common_set(m.array()).indices().size() \
          == m.array().indices().size()
      #
      orig = m.array()
      if (not orig.anomalous_flag()):
        ave = orig.average_bijvoet_mates()
        assert ave.correlation(orig).coefficient() > 1-1.e-6
        if (sigmas is not None):
          assert flex.linear_correlation(
            ave.sigmas(), orig.sigmas()).coefficient() > 1-1.e-6
      else:
        if (sigmas is not None):
          # merge_equivalents uses the sigmas as weights
          orig = orig.customized_copy(
            sigmas=flex.double(orig.sigmas().size(),1))
        ave = orig.average_bijvoet_mates()
        asu, matches = orig.match_bijvoet_mates()
        vfy_indices = asu.indices().select(matches.pairs().column(0))
        vfy_data = (  asu.data().select(matches.pairs().column(0))
                    + asu.data().select(matches.pairs().column(1))) / 2
        for sign in ("+", "-"):
          sel = matches.singles(sign)
          vfy_indices.extend(asu.indices().select(sel))
          vfy_data.extend(asu.data().select(sel))
        vfy = miller.array(
          miller_set=miller.set(
            crystal_symmetry=orig,
            indices=vfy_indices,
            anomalous_flag=False),
          data=vfy_data).adopt_set(ave)
        assert vfy.correlation(ave).coefficient() > 1-1.e-6
  #
  mi = flex.miller_index([(0,0,0)])
  matches = miller.match_bijvoet_mates(sgtbx.space_group_type(), mi)
  assert matches.pairs().size() == 0
  assert list(matches.singles('+')) == [0]
  assert matches.singles('-').size() == 0

def exercise_map_to_asu(space_group_info):
  crystal_symmetry = space_group_info.any_compatible_crystal_symmetry(
    asu_volume=200)
  for anomalous_flag in [False, True]:
    miller_set = miller.build_set(
      crystal_symmetry=crystal_symmetry,
      anomalous_flag=anomalous_flag,
      d_min=2)
    assert miller_set.indices().size() > 30
    ampl = miller_set.array(
      data=flex.random_double(size=miller_set.indices().size()))
    phases_rad = flex.random_double(
      size=miller_set.indices().size(), factor=2*math.pi)
    cmplx = ampl.phase_transfer(phase_source=phases_rad, deg=False)
    acentric = ~cmplx.centric_flags().data()
    for trig in [flex.cos, flex.sin]:
      assert approx_equal(
        trig(cmplx.phases(deg=False).data().select(acentric)),
        trig(phases_rad.select(acentric)))
    cmplx_exp = cmplx.expand_to_p1().customized_copy(
      crystal_symmetry=cmplx)
    for deg,f in [(False,1), (True,math.pi/180)]:
      phases_exp = cmplx_exp.phases(deg=deg)
      cmplx_exp_asu_phases = cmplx_exp.map_to_asu().phases(deg=deg)
      phases_exp_asu = phases_exp.map_to_asu(deg=deg)
      for trig in [flex.cos, flex.sin]:
        assert approx_equal(
          trig(cmplx_exp_asu_phases.data()*f),
          trig(phases_exp_asu.data()*f))
      phases = cmplx.phases(deg=deg)
      phases_exp = phases.expand_to_p1(phase_deg=deg).customized_copy(
        crystal_symmetry=phases)
      phases_exp_asu = phases_exp.map_to_asu(deg=deg)
      for trig in [flex.cos, flex.sin]:
        assert approx_equal(
          trig(cmplx_exp_asu_phases.data()*f),
          trig(phases_exp_asu.data()*f))

def exercise_complete_array():
  crystal_symmetry = crystal.symmetry((2.1,3,4), "P 2 2 2")
  set = miller.build_set(
    crystal_symmetry=crystal_symmetry,
    anomalous_flag=False,
    d_min=1)
  ni = set.indices().size()
  for sigmas in [None, flex.random_double(ni)]:
    array = set.array(
      data=flex.random_double(size=set.indices().size()),
      sigmas=sigmas)
    compl = array.complete_array()
    assert compl.indices().all_eq(array.indices())
    sel = flex.random_permutation(size=ni)[:(ni*2)//3]
    selected = array.select(sel)
    compl = selected.complete_array(d_min=1)
    assert compl.indices().size() == array.size()
    new_data_sel = compl.data() >= 0
    assert new_data_sel.count(True) == sel.size()
    if (sigmas is None):
      assert compl.sigmas() is None
    else:
      new_sigmas_sel = compl.sigmas() >= 0
      assert new_sigmas_sel.count(True) == sel.size()
      assert new_sigmas_sel.all_eq(new_data_sel)
    sel = flex.random_permutation(size=ni)[:(ni*2)//3]
    selected = array.select(sel)
    compl_to_4_angstrom = selected.complete_array(d_min=4)
    assert compl_to_4_angstrom.completeness() < 1
    assert approx_equal(
      compl_to_4_angstrom.resolution_filter(d_min=4).completeness(), 1)

def exercise_fft_map():
  xs = crystal.symmetry((3,4,5), "P 2 2 2")
  mi = flex.miller_index(((1,-2,3), (0,0,-4)))
  for anomalous_flag in (False, True):
    ms = miller.set(xs, mi, anomalous_flag=anomalous_flag)
    ma = miller.array(ms, flex.complex_double((1,2)))
    fft_map = ma.fft_map()
    assert approx_equal(fft_map.resolution_factor(), 1./3)
    assert fft_map.symmetry_flags() is None
    assert approx_equal(fft_map.max_prime(), 5)
    assert fft_map.anomalous_flag() == anomalous_flag
    assert fft_map.real_map().size() > 0
    assert not fft_map.real_map_unpadded(in_place=False).is_padded()
    if (anomalous_flag):
      assert fft_map.complex_map().size() > 0

def exercise_squaring_and_patterson_map(space_group_info,
                                        n_scatterers=8,
                                        d_min=2,
                                        verbose=0):
  structure = random_structure.xray_structure(
    space_group_info,
    elements=["const"]*n_scatterers,
    volume_per_atom=500,
    min_distance=5.,
    general_positions_only=True,
    u_iso=0.0)
  if (0 or verbose):
    structure.show_summary().show_scatterers()
  e_000 = math.sqrt(n_scatterers * structure.space_group().order_z())
  f_calc = structure.structure_factors(
    d_min=d_min, anomalous_flag=False).f_calc()
  f_calc = f_calc.sort(by_value="abs")
  f = abs(f_calc)
  assert approx_equal(f.data(), f_calc.amplitudes().data())
  assert approx_equal(f_calc.phases(deg=True).data()*math.pi/180,
                      f_calc.phases().data())
  f.setup_binner(auto_binning=True)
  e = f.quasi_normalize_structure_factors()
  grid_resolution_factor = 1/3.
  u_base = xray.calc_u_base(d_min, grid_resolution_factor)
  if (0 or verbose):
    print("u_base:", u_base)
  d_star_sq = e.unit_cell().d_star_sq(e.indices())
  dw = flex.exp(d_star_sq*2*(math.pi**2)*u_base)
  eb = miller.array(miller_set=e, data=e.data()/dw)
  eb_map = eb.phase_transfer(f_calc).fft_map(
    resolution_factor=grid_resolution_factor,
    d_min=d_min,
    f_000=e_000).real_map()
  eb_map_sq = flex.pow2(eb_map)
  eb_sq = eb.structure_factors_from_map(eb_map_sq)
  mwpe = f_calc.mean_weighted_phase_error(eb_sq)
  mpe = f_calc.mean_phase_error(f_calc.phases())
  assert approx_equal(mpe, 0.0)
  if (0 or verbose):
    print("mean_weighted_phase_error: %.2f" % mwpe)
  assert mwpe < 2
  for sharpening in (False, True):
    for origin_peak_removal in (False, True):
      patterson_map = eb.patterson_map(
        symmetry_flags=maptbx.use_space_group_symmetry,
        resolution_factor=grid_resolution_factor,
        f_000=e_000,
        sharpening=sharpening,
        origin_peak_removal=origin_peak_removal)
      grid_tags = maptbx.grid_tags(patterson_map.n_real())
      grid_tags.build(
        patterson_map.space_group_info().type(),
        maptbx.use_space_group_symmetry)
      assert grid_tags.n_grid_misses() == 0
      assert grid_tags.verify(patterson_map.real_map())

def exercise_neighbor_average():
  # Setup
  symmetry = crystal.symmetry(
    unit_cell=(10, 10, 10, 90, 90, 90),
    space_group_symbol="P1")
  d_min = 2
  structure = xray.structure(crystal_symmetry=symmetry)
  # now let's add some atoms
  atmrad = flex.double()
  xyzf = flex.vec3_double()
  from cctbx.eltbx import van_der_waals_radii
  a,b,c,_,_,_ = symmetry.unit_cell().parameters()
  for k in range(10):
    scatterer = xray.scatterer(
      site=(0, 0.1*math.sin(math.pi*4*k/b), k/b),
      scattering_type="S",
      u=0.02)
    structure.add_scatterer(scatterer)
    atmrad.append(van_der_waals_radii.vdw.table[scatterer.element_symbol()])
    xyzf.append(scatterer.site)
  f_calc = structure.structure_factors(
    d_min=d_min, anomalous_flag=False).f_calc()

  # Ready to get local average

  local_average=f_calc.average_neighbors(layers=0,include_origin=True)
  local_average_2=f_calc.average_neighbors(layers=1,include_origin=False,
      average_with_cc=True)

  a=None
  ind_list=[ (2,2,2),(1,2,2),(3,2,2),(2,1,2),(2,3,2),(2,2,1),(2,2,3)]
  for ind in ind_list:
    s=(f_calc.indices()==ind)
    ind=f_calc.indices().select(s)
    values=f_calc.data().select(s)
    for x,y in zip(ind,values):
      if a is None: a=y
      else: a+=y
  s=f_calc.indices()==ind_list[0]
  avg=local_average.data().select(s)[0]
  avg2=local_average_2.data().select(s)[0]
  assert approx_equal(a/len(ind_list),avg)

def exercise_local_overlap_map():
  symmetry = crystal.symmetry(
    unit_cell=(10, 10, 10, 90, 90, 90),
    space_group_symbol="P1")
  d_min = 2
  structure = xray.structure(crystal_symmetry=symmetry)
  # now let's add some atoms
  atmrad = flex.double()
  xyzf = flex.vec3_double()
  from cctbx.eltbx import van_der_waals_radii
  a,b,c,_,_,_ = symmetry.unit_cell().parameters()
  for k in range(10):
    scatterer = xray.scatterer(
      site=(0, 0.1*math.sin(math.pi*4*k/b), k/b),
      scattering_type="S",
      u=0.02)
    structure.add_scatterer(scatterer)
    atmrad.append(van_der_waals_radii.vdw.table[scatterer.element_symbol()])
    xyzf.append(scatterer.site)
  f_calc = structure.structure_factors(
    d_min=d_min, anomalous_flag=False).f_calc()
  sites_cart=structure.sites_cart()
  from scitbx.matrix import col
  sites_cart+=col((0.2,0.2,0.2))
  structure.set_sites_cart(sites_cart)
  f_calc_1 = structure.structure_factors(
    d_min=d_min, anomalous_flag=False).f_calc()
  lom = f_calc.local_overlap_map(other=f_calc_1,radius=3.5)
  lom_map=lom.real_map_unpadded()
  mmm=lom_map.as_1d().min_max_mean()
  hist = flex.histogram(data=lom_map.as_1d(), n_slots=lom_map.size())
  cutoff = hist.get_cutoff(int(lom_map.size()*(1-0.85)))
  mask = flex.size_t()
  mask.resize(lom_map.accessor(), 1)
  mask.set_selected(lom_map > cutoff, 0)
  # compare to vdw radii-based mask
  from cctbx.masks import around_atoms
  m1 = around_atoms(
    structure.unit_cell(),
    structure.space_group().order_z(),
    structure.sites_frac(),
    atmrad,
    lom.n_real(),
    solvent_radius=1,
    shrink_truncation_radius=1)
  corr = flex.linear_correlation(
    mask.as_double().as_1d(), m1.data.as_double().as_1d())
  assert corr.coefficient() > 0.70


def exercise_lsd_map():
  symmetry = crystal.symmetry(
    unit_cell=(10, 10, 10, 90, 90, 90),
    space_group_symbol="P1")
  d_min = 2
  structure = xray.structure(crystal_symmetry=symmetry)
  # first check with no atoms
  f_calc = structure.structure_factors(
    d_min=d_min, anomalous_flag=False).f_calc()
  lsd = f_calc.local_standard_deviation_map(radius=3.5)
  assert flex.max(lsd.real_map_unpadded()) == 0
  assert flex.min(lsd.real_map_unpadded()) == 0
  # now let's add some atoms
  atmrad = flex.double()
  xyzf = flex.vec3_double()
  from cctbx.eltbx import van_der_waals_radii
  a,b,c,_,_,_ = symmetry.unit_cell().parameters()
  for k in range(10):
    scatterer = xray.scatterer(
      site=(0, 0.1*math.sin(math.pi*4*k/b), k/b),
      scattering_type="S",
      u=0.02)
    structure.add_scatterer(scatterer)
    atmrad.append(van_der_waals_radii.vdw.table[scatterer.element_symbol()])
    xyzf.append(scatterer.site)
  f_calc = structure.structure_factors(
    d_min=d_min, anomalous_flag=False).f_calc()
  lsd = f_calc.local_standard_deviation_map(radius=1.5)
  lsd_map = lsd.real_map_unpadded()
  hist = flex.histogram(data=lsd_map.as_1d(), n_slots=lsd_map.size())
  cutoff = hist.get_cutoff(int(lsd_map.size()*(1-0.85)))
  mask = flex.size_t()
  mask.resize(lsd_map.accessor(), 1)
  mask.set_selected(lsd_map > cutoff, 0)
  # compare to vdw radii-based mask
  from cctbx.masks import around_atoms
  m1 = around_atoms(
    structure.unit_cell(),
    structure.space_group().order_z(),
    structure.sites_frac(),
    atmrad,
    lsd.n_real(),
    solvent_radius=1,
    shrink_truncation_radius=1)
  corr = flex.linear_correlation(
    mask.as_double().as_1d(), m1.data.as_double().as_1d())
  assert corr.coefficient() > 0.90, corr.coefficient()

def exercise_phased_translation_coeff(d_min = 1.0,
                                      algorithm = "direct",
                                      shift = [0.7, 1.2, 1.4],
                                      resolution_factor = 1./3):
  cs = crystal.symmetry((5, 5, 5, 90, 90, 90), "P 1")
  sp = crystal.special_position_settings(cs)
  scatterers = flex.xray_scatterer(
    [xray.scatterer("c", (0.2, 0.3, 0.4), u=0.2, occupancy=1)])
  xrs = xray.structure(sp, scatterers)
  f_calc = xrs.structure_factors(d_min = d_min, algorithm = algorithm).f_calc()
  f_obs = abs(f_calc)
  xrs_t = xrs.translate(x = shift[0], y = shift[1], z = shift[2])
  f_calc_t = xrs_t.structure_factors(d_min = d_min,
    algorithm = algorithm).f_calc()
  for fom in [None, f_obs.array(data=flex.double(f_obs.data().size(),1))]:
    result = f_obs.phased_translation_function_coeff(
      phase_source = f_calc,
      f_calc = f_calc_t,
      fom = fom)
    from cctbx import maptbx
    fft_map = result.fft_map(resolution_factor = resolution_factor,
                             symmetry_flags = maptbx.use_space_group_symmetry)
    fft_map.apply_fourier_scaling() # just to exercise this method
    fft_map.apply_sigma_scaling()
    fft_map_data = fft_map.real_map_unpadded()
    crystal_gridding_tags = fft_map.tags()
    cluster_analysis = crystal_gridding_tags.peak_search(
      parameters = maptbx.peak_search_parameters(),
      map = fft_map_data)
    assert cluster_analysis.sites().size() == 1
    expected_shift = [1.-(0.7/5), 1.-(1.2/5), 1.-(1.4/5)]
    assert approx_equal(expected_shift, cluster_analysis.sites()[0], eps=1e-2)

def exercise_common_set(arrays, permutation_only):
  (a, b) = arrays
  ab = a.common_set(b)
  ba = b.common_set(a)
  if (permutation_only):
    assert ab.indices().all_eq(b.indices())
    assert ba.indices().all_eq(a.indices())
  aab,bab = a.common_sets(b)
  assert aab.indices().all_eq(bab.indices())
  assert aab.indices().all_eq(ab.indices())
  aba,bba = b.common_sets(a)
  assert aba.indices().all_eq(bba.indices())
  assert aba.indices().all_eq(ba.indices())

def exercise_array_correlation(space_group_info,
                               n_scatterers=8,
                               d_min=2,
                               verbose=0):
  arrays = []
  for i in range(2):
    structure = random_structure.xray_structure(
      space_group_info,
      elements=["const"]*n_scatterers)
    arrays.append(abs(structure.structure_factors(d_min=d_min-i*0.5).f_calc()))
  arrays[1] = arrays[1].select(
    flex.random_permutation(size=arrays[1].indices().size()))
  exercise_common_set((arrays[0], arrays[0].select(
      flex.random_permutation(size=arrays[0].indices().size()))),
    permutation_only=True)
  exercise_common_set(arrays, permutation_only=False)
  for anomalous_flag in [False, True]:
    if (anomalous_flag):
      arrays[0] = arrays[0].generate_bijvoet_mates()
    assert approx_equal(arrays[0].correlation(arrays[0]).coefficient(), 1)
    assert approx_equal(arrays[0].correlation(arrays[1]).coefficient(),
                        arrays[1].correlation(arrays[0]).coefficient())
    arrays[0].setup_binner(auto_binning=True)
    arrays[1].use_binning_of(arrays[0])
    for corr in arrays[0].correlation(arrays[0], use_binning=True).data:
      if (corr is not None):
        assert approx_equal(corr, 1)
    corr0 = arrays[0].correlation(arrays[1], use_binning=True).data
    corr1 = arrays[1].correlation(arrays[0], use_binning=True).data
    for c0,c1 in zip(corr0,corr1):
      assert (c0 is None) == (c1 is None)
      if (c0 is None): continue
      assert approx_equal(c0, c1)

def exercise_as_hendrickson_lattman(space_group_info, n_scatterers=5, d_min=3,
                                    verbose=0):
  phase_integrator = miller.phase_integrator()
  phase_restriction = space_group_info.group().phase_restriction
  for anomalous_flag in [False, True]:
    structure = random_structure.xray_structure(
      space_group_info,
      elements=["const"]*n_scatterers,
      volume_per_atom=200,
      random_f_double_prime=False)
    f_calc = structure.structure_factors(
      d_min=d_min,
      anomalous_flag=anomalous_flag,
      algorithm="direct").f_calc()
    max_f_calc = flex.max(flex.abs(f_calc.data()))
    phase_integrals = f_calc.data() / (max_f_calc/.95)
    for h,pi_calc in zip(f_calc.indices(), phase_integrals):
      phase_info = phase_restriction(h)
      assert abs(pi_calc - phase_info.valid_structure_factor(pi_calc)) < 1.e-6
      hl = miller.as_hendrickson_lattman(
        centric_flag=phase_info.is_centric(),
        phase_integral=pi_calc,
        max_figure_of_merit=1-1.e-6)
      pi_int = phase_integrator(phase_info, hl)
      assert abs(pi_calc - pi_int) < 1.e-1

def one_random_hl(f, min_coeff=1.e-3):
  result = f * (random.random() - 0.5)
  if (result < 0):
    if (result > -min_coeff): return min_coeff
  else:
    if (result < min_coeff): return min_coeff
  return result

def generate_random_hl(miller_set, coeff_range=5, max_centric_multiplier=None, set_a=None):
  # added options to skew the phase distribution in one or the other way
  phase_restriction = miller_set.space_group().phase_restriction
  hl = flex.hendrickson_lattman()
  for h in miller_set.indices():
    phase_info = phase_restriction(h)
    if (phase_info.is_centric()):
      min_fom = 0.01
      if set_a is not None:
        min_fom = 1.0-1E-12
      fom = max(min_fom, random.random()*0.95)
      if  max_centric_multiplier is not None:
        fom = fom*max_centric_multiplier
      if (random.random() < 0.5): fom *= -1
      angle = phase_info.ht_angle()
      f = fom * complex(math.cos(angle), math.sin(angle))
      assert abs(f - phase_info.valid_structure_factor(f)) < 1.e-6
      hl.append(cctbx.hendrickson_lattman(
        centric_flag=True,
        phase_integral=f,
        max_figure_of_merit=1-1.e-6))
    else:
      f = 2 * coeff_range * random.random()
      coefs = [one_random_hl(f) for i in range(4)]
      if set_a is not None:
        coefs[0] = set_a
      hl.append(coefs)
  return miller.array(miller_set=miller_set, data=hl)

def exercise_average_and_generate_bijvoet_mates_hl(hl):
  hl_ave1 = hl.average_bijvoet_mates()
  hl_gen1 = hl_ave1.generate_bijvoet_mates().adopt_set(hl)
  hl_ave2 = hl_gen1.average_bijvoet_mates().adopt_set(hl_ave1)
  hl_gen2 = hl_ave2.generate_bijvoet_mates().adopt_set(hl_gen1)
  assert approx_equal(hl_ave2.data(), hl_ave1.data())
  assert approx_equal(hl_gen2.data(), hl_gen1.data())

def exercise_phase_integrals(space_group_info):
  crystal_symmetry = space_group_info.any_compatible_crystal_symmetry(
    asu_volume=200)
  is_centric = space_group_info.group().is_centric
  for anomalous_flag in [False, True]:
    miller_set = miller.build_set(
      crystal_symmetry=crystal_symmetry,
      anomalous_flag=anomalous_flag,
      d_min=2)
    assert miller_set.indices().size() > 30
    sg_hl = generate_random_hl(miller_set=miller_set)
    if (anomalous_flag):
      exercise_average_and_generate_bijvoet_mates_hl(sg_hl)
    p1_hl = sg_hl.expand_to_p1()
    sg_phase_integrals = sg_hl.phase_integrals(n_steps=360//5)
    p1_phase_integrals = p1_hl.phase_integrals()
    p1_sg_phase_integrals = sg_phase_integrals.expand_to_p1()
    assert p1_sg_phase_integrals.indices().all_eq(p1_phase_integrals.indices())
    for h,pi_p1,pi_p1_sg in zip(p1_phase_integrals.indices(),
                                p1_phase_integrals.data(),
                                p1_sg_phase_integrals.data()):
      if (is_centric(h)):
        if (scitbx.math.phase_error(complex_math.arg(pi_p1),
                                    complex_math.arg(pi_p1_sg)) > 1.e-6):
          print("Error:", h, pi_p1, pi_p1_sg)
          print("arg(pi_p1):", complex_math.arg(pi_p1))
          print("arg(pi_p1_sg):", complex_math.arg(pi_p1_sg))
          raise AssertionError
        if (not (0.5 < abs(pi_p1)/abs(pi_p1_sg) < 0.75)):
          print("Error:", h, pi_p1, pi_p1_sg)
          print("abs(pi_p1):", abs(pi_p1))
          print("abs(pi_p1_sg):", abs(pi_p1_sg))
          raise AssertionError
      elif (abs(pi_p1 - pi_p1_sg) > 1.e-6):
        print("Error:", h, pi_p1, pi_p1_sg)
        raise AssertionError
    #
    amplitude_array = miller.array(
      miller_set=miller_set,
      data=flex.random_double(size=miller_set.indices().size()))
    for phase_integrator_n_steps in [None, 360//5]:
      with_phases = amplitude_array.phase_transfer(
        phase_source=sg_hl,
        phase_integrator_n_steps=phase_integrator_n_steps)
      assert flex.max(  flex.abs(amplitude_array.data()
                      - abs(with_phases).data())) < 1.e-6
      assert with_phases.mean_weighted_phase_error(
        phase_source=sg_phase_integrals) < 1.e-6


    # test the entropy calculations: maximum uncertainty
    sg_hl = generate_random_hl(miller_set=miller_set, coeff_range=1E-12,max_centric_multiplier=1E-12)
    mean_entropy = sg_hl.phase_entropy(False,False,True)
    assert mean_entropy < 1e-3


    # test the entropy calculations: no uncertainty
    sg_hl = generate_random_hl(miller_set=miller_set, coeff_range=1E-12,set_a=90000.0)
    mean_entropy = sg_hl.phase_entropy(False,False,True)
    if miller_set.space_group() == sgtbx.space_group_info( "P1" ).group():
      assert mean_entropy > 8.2
    if miller_set.space_group() == sgtbx.space_group_info( "P-1" ).group():
      assert mean_entropy > 0.99

def exercise_map_correlation():
  xrs1 = random_structure.xray_structure(
    space_group_info=sgtbx.space_group_info(number=1),
    elements=["C"]*2)
  xrs2 = xrs1.deep_copy_scatterers()
  xrs2.shift_sites_in_place(shift_length=0.3)
  cg = maptbx.crystal_gridding(
    unit_cell         = xrs1.unit_cell(),
    space_group_info  = xrs1.space_group_info(),
    d_min             = 0.5,
    resolution_factor = 0.1)
  fc1 = xrs1.structure_factors(d_min=1, algorithm="direct").f_calc()
  fc2 = fc1.structure_factors_from_scatterers(xray_structure=xrs2,
    algorithm="direct").f_calc()
  cc1 = fc1.map_correlation(other=fc2)
  fft_map = miller.fft_map(
    crystal_gridding     = cg,
    fourier_coefficients = fc1)
  m1 = fft_map.real_map_unpadded()
  fft_map = miller.fft_map(
    crystal_gridding     = cg,
    fourier_coefficients = fc2)
  m2 = fft_map.real_map_unpadded()
  cc2 = flex.linear_correlation(m1.as_1d(), m2.as_1d()).coefficient()
  assert approx_equal(cc1, cc2)

def exercise_concatenate():
  xs = crystal.symmetry((3,4,5), "P 2 2 2")
  mi = flex.miller_index(((1,-2,3), (0,0,-4)))
  data = flex.double((1,2))
  sigmas = flex.double((0.1,0.2))
  ms = miller.set(xs, mi)
  ma1 = miller.array(ms, data, sigmas)
  #
  mi = flex.miller_index(((2,-4,6), (0,0,-8)))
  data = flex.double((2,4))
  sigmas = flex.double((0.2,0.4))
  ms = miller.set(xs, mi)
  ma2 = miller.array(ms, data, sigmas)
  result = ma1.concatenate(other = ma2)
  assert approx_equal(result.indices(), [(1,-2,3),(0,0,-4),(2,-4,6),(0,0,-8)])
  assert approx_equal(result.data(), [1.0, 2.0, 2.0, 4.0])
  assert approx_equal(result.sigmas(), [0.1, 0.2, 0.2, 0.4])
  mi = flex.miller_index(((2,-4,6), (0,0,-8)))
  data = flex.double((2,4))
  ms = miller.set(xs, mi)
  ma3 = miller.array(ms, data)
  result = ma1.concatenate(other = ma3)
  assert approx_equal(result.indices(), [(1,-2,3),(0,0,-4),(2,-4,6),(0,0,-8)])
  assert approx_equal(result.data(), [1.0, 2.0, 2.0, 4.0])
  assert result.sigmas() is None

def run_call_back(flags, space_group_info):
  exercise_randomize_amplitude_and_phase(space_group_info)
  exercise_array_2(space_group_info)
  exercise_map_to_asu(space_group_info)
  exercise_squaring_and_patterson_map(space_group_info, verbose=flags.Verbose)
  exercise_array_correlation(space_group_info)
  exercise_as_hendrickson_lattman(space_group_info)
  exercise_phase_integrals(space_group_info)
  exercise_generate_r_free_flag_on_lat_sym(space_group_info)

def exercise_difference_map():
  cs = crystal.symmetry((2,2,2), "P1")
  mi = miller.set(cs, flex.miller_index(((1,-2,3), (0,0,-4))))
  f_o = miller.array(mi, data=flex.double((1,2)))
  f_c = miller.array(mi, data=flex.complex_double((2j, 3j)))
  diff = f_o.f_obs_minus_f_calc(f_obs_factor=1, f_calc=f_c)
  assert approx_equal(tuple(diff.data()), (-1j, -1j))
  cs = crystal.symmetry((2,2,2), "P23")
  mi = miller.set(cs, flex.miller_index(((1,-2,3), (0,0,-4))))
  f_o = miller.array(mi, data=flex.double((1,2)))
  f_c = miller.array(mi, data=flex.complex_double((2j, 3j)))
  diff = f_o.f_obs_minus_f_calc(f_obs_factor=1, f_calc=f_c)
  assert approx_equal(diff.amplitudes().data(), (1,1))
  assert not cs.space_group().phase_restriction(mi.indices()[0]).is_centric()
  assert approx_equal(diff.data()[0], -1j)
  ph_restrict = cs.space_group().phase_restriction(mi.indices()[1])
  assert ph_restrict.is_centric()
  assert ph_restrict.nearest_valid_phase(90, deg=True) == 0
  assert approx_equal(diff.data()[1], -1)
  f_o = miller.array(mi, data=(flex.complex_double((3j, 4j))))
  diff = f_o.f_obs_minus_f_calc(f_obs_factor=1, f_calc=f_c)
  assert approx_equal(diff.data(), ((1j, 1j)))

def exercise_multiscale():
  xrs = random_structure.xray_structure(
    space_group_info=sgtbx.space_group_info(number=19),
    elements=["C"]*10)
  # Scalar scale
  f1 = abs(xrs.structure_factors(d_min=3).f_calc())
  f2 = abs(f1.deep_copy())
  assert approx_equal(
    flex.sum(f1.data()*f2.data())/flex.sum(f2.data()*f2.data()), 1)
  f2 = f2.array(data = f2.data()*10)
  assert approx_equal(
    flex.sum(f1.data()*f2.data())/flex.sum(f2.data()*f2.data()), 0.1)
  f1 = f2.multiscale(other = f1)
  assert approx_equal(
    flex.sum(f1.data()*f2.data())/flex.sum(f2.data()*f2.data()), 1)
  # Exp scale
  f1 = abs(xrs.structure_factors(d_min=1).f_calc())
  ss = 1./flex.pow2(f1.d_spacings().data()) / 4.
  f2 = f1.deep_copy()
  f2 = f2.array(data = f2.data()*10*flex.exp(-50*ss))
  f2 = f1.multiscale(other=f2, use_exp_scale=True)
  assert approx_equal(f1.data(), f2.data())
  # Now complex arrays!
  f1 = xrs.structure_factors(d_min=1).f_calc()
  ss = 1./flex.pow2(f1.d_spacings().data()) / 4.
  f2 = f1.deep_copy()
  f2 = f2.array(data = f2.data()*10*flex.exp(-50*ss))
  f2 = f1.multiscale(other=f2, use_exp_scale=True)
  assert approx_equal(f1.data(), f2.data())

def exercise_symmetry_agreement_factor():
  from cmath import phase as arg
  uc = uctbx.unit_cell((1, 2, 3, 90, 101, 90))
  cs = crystal.symmetry(uc, 'P 1')
  mi = miller.set(
    cs,
    flex.miller_index(((1,1,1), (-1,1,-1), (-1,1,1), (1,1,-1))),
    anomalous_flag=True)
  cb_op = sgtbx.change_of_basis_op(sgtbx.rt_mx('-x,y,-z+1/2'))
  ma = miller.array(
    mi, flex.complex_double((1+1j, -1+1j, 1-1j, -1-1j)))
  cc = [ (1+1j)*(1+1j), (-1+1j)*(-1+1j), (1-1j)*(1-1j), (-1-1j)*(-1-1j) ]
  expected = (3/math.pi**2 * sum([ abs(z)*arg(z)**2 for z in cc ])
                           / sum([ abs(z) for z in cc ]))
  assert approx_equal(ma.symmetry_agreement_factor(cb_op),
                      expected,
                      eps=1e-3)

def exercise_shelxl_extinction_correction():
  cs = crystal.symmetry((3,4,5), "P 2 2 2")
  mi = flex.miller_index(((1,-2,3), (0,0,-4)))
  ms = miller.set(cs, mi, anomalous_flag=True)
  data = flex.complex_double((1+2j, 2+3j))
  fc = miller.array(miller_set=ms, data=data)
  exti_val = 0.44
  wavelength = 0.71073
  corr = fc.shelxl_extinction_correction(x=exti_val, wavelength=wavelength)
  assert approx_equal(corr, [0.99965712792728978, 0.99906041805376866])
  ec = xray.shelx_extinction_correction(cs.unit_cell(), value=exti_val,
                                        wavelength=wavelength)
  fc_sq = fc.as_intensity_array().data()
  coef = [math.sqrt(ec.compute(mi[0],fc_sq[0],False)[0]),
          math.sqrt(ec.compute(mi[1],fc_sq[1],False)[0])]
  assert approx_equal(corr, coef)

def exercise_complete_with1():
  xs = crystal.symmetry((3,15,20), "P1")
  mi = flex.miller_index(((0,0,1), ))
  ms = miller.set(xs, mi, anomalous_flag=False)
  cms = ms.complete_set(d_min=2, d_max=20)
  cms_size = cms.indices().size()
  #
  data1 = flex.double(cms_size, 1)
  ma1 = miller.array(cms, data1)
  data2 = flex.double(cms_size, -1)
  ma2 = miller.array(cms, data2)
  #
  sel = flex.random_bool(cms_size, 0.5)
  ma1i = ma1.select(sel)
  ma1del = ma1.select(~sel)
  #
  ma1c = ma1i.complete_with(ma2)
  assert ma1c.data().size() == ma1.data().size()
  x = ma1.sort(by_value="packed_indices")
  y = ma1c.sort(by_value="packed_indices")
  assert x.indices().all_eq(y.indices())
  assert ma1c.common_set(ma1del).data().all_eq(-1)
  assert ma1c.lone_set(ma1del).data().all_eq(1)
  sel = ma1c.data() == -1
  assert ma1c.select(sel).sort(by_value="packed_indices").indices().all_eq(
    ma1del.sort(by_value="packed_indices").indices()  )

def exercise_complete_with2():
  xs = crystal.symmetry((3,15,20), "P1")
  mi1 = flex.miller_index(((0,0,1), (0,0,2)))
  ms1 = miller.set(xs, mi1, anomalous_flag=False)
  d1 = flex.double([1,2])
  ma1 = miller.array(ms1, d1)
  #
  mi2 = flex.miller_index(((0,0,0),(0,0,1), (0,0,3)))
  ms2 = miller.set(xs, mi2, anomalous_flag=False)
  d2 = flex.double([0,-1,-2])
  ma2 = miller.array(ms2, d2)
  #
  ma1c = ma1.complete_with(other=ma2)
  assert list(ma1c.indices()) == [(0, 0, 1), (0, 0, 2), (0, 0, 0), (0, 0, 3)]
  assert list(ma1c.data()) == [1.0, 2.0, 0.0, -2.0]
  #
  ma2c = ma2.complete_with(other=ma1)
  assert list(ma2c.indices()) == [(0, 0, 0), (0, 0, 1), (0, 0, 3), (0, 0, 2)]
  assert list(ma2c.data()) == [0.0, -1.0, -2.0, 2.0]

def exercise_complete_with3():
  xs = crystal.symmetry((3,15,20), "P1")
  mi1 = flex.miller_index(((0,0,1),(0,0,2),(0,0,3), (0,0,4), (0,0,5), (0,0,6),
   (0,0,7),(0,0,8),(0,0,9),(0,0,10),(0,0,11),(0,0,12),(0,0,13),(0,0,14)))
  ms1 = miller.set(xs, mi1, anomalous_flag=False)
  d1 = flex.double(14,1)
  ma1 = miller.array(ms1, d1)
  mi2 = flex.miller_index(((0,0,3), (0,0,4), (0,0,5), (0,0,8), (0,0,9),
    (0,0,10),(0,0,11),(0,0,12)))
  ms2 = miller.set(xs, mi2, anomalous_flag=False)
  d2 = flex.double(8,2)
  ma2 = miller.array(ms2, d2)
  # Complete all
  mi2a = ma2.complete_with(ma1)
  mi2a = mi2a.sort()
  assert mi2a.indices().all_eq(ma1.indices())
  assert list(mi2a.data()) == [1,1,2,2,2,1,1,2,2,2,2,2,1,1]
  # Low resolution only
  mi2a = ma2.complete_with(ma1.resolution_filter(d_min=6))
  mi2a = mi2a.sort()
  assert approx_equal(list(mi2a.indices()), ((0,0,1), (0,0,2), (0,0,3), (0,0,4),
    (0,0,5), (0,0,8), (0,0,9), (0,0,10),(0,0,11),(0,0,12)))
  assert list(mi2a.data()) == [1.0, 1.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0]
  # High resolution only
  mi2a = ma2.complete_with(ma1.resolution_filter(d_max=2))
  mi2a = mi2a.sort()
  assert approx_equal(list(mi2a.indices()), ((0,0,3), (0,0,4), (0,0,5),
   (0,0,8), (0,0,9), (0,0,10),(0,0,11),(0,0,12),(0,0,13),(0,0,14)))
  assert list(mi2a.data()) == [2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 1.0, 1.0]
  # Medium resolution only
  mi2a = ma2.complete_with(ma1.resolution_filter(d_max=4, d_min=2.5))
  mi2a = mi2a.sort()
  assert approx_equal(list(mi2a.indices()), ((0,0,3), (0,0,4), (0,0,5), (0,0,6),
   (0,0,7), (0,0,8), (0,0,9), (0,0,10),(0,0,11),(0,0,12)))
  assert list(mi2a.data()) == [2.0, 2.0, 2.0, 1.0, 1.0, 2.0, 2.0, 2.0, 2.0, 2.0]
  # Complete all - reverse
  ma1a = ma1.complete_with(ma2)
  ma1a = ma1a.sort()
  assert ma1a.indices().all_eq(ma1.indices())
  assert approx_equal(ma1a.data(), ma1.data())

def exercise_complete_with_complete_with_bin_average():
  xs = crystal.symmetry((30,15,20), "P1")
  mi = flex.miller_index(((0,0,1),(0,0,2),(0,0,3), (0,0,4), (0,0,5), (0,0,6),
   (0,0,7),(0,0,8),(0,0,9),(0,0,10),(0,0,11),(0,0,12),(0,0,13),(0,0,14)))
  ms = miller.set(xs, mi, anomalous_flag=False)
  ms = ms.complete_set()
  ms = ms.select(selection=flex.random_bool(ms.indices().size(), 0.3))
  d = flex.double(ms.indices().size(),1)
  ma = miller.array(ms, d)
  ma.complete_with_bin_average()

def exercise_merge_equivalents_special_cases():
  xs = crystal.symmetry((10,10,10), "P1")
  mi = flex.miller_index([(1,2,3), (1,2,3)])
  ms = miller.set(xs, mi, anomalous_flag=False)
  d = flex.double([0.0, 165.827774048])
  s = flex.double([8.89633977597e-10, 144.83241272])
  ma = miller.array(ms, data=d, sigmas=s)
  me = ma.merge_equivalents().array()
  assert approx_equal(me.data(), [165.827774048])
  assert approx_equal(me.sigmas(), [144.83241272])

def exercise_structure_factors_from_map():
  xrs = random_structure.xray_structure(
    space_group_info=sgtbx.space_group_info(number=19),
    elements=["C"]*10)
  fc1 = xrs.structure_factors(d_min=1.5, algorithm="direct").f_calc()
  for cntr in range(10):
    fft_map = fc1.fft_map(resolution_factor=0.1)
    fft_map.apply_volume_scaling()
    map_data = fft_map.real_map_unpadded()
    fc2 = fc1.structure_factors_from_map(
      map            = map_data,
      use_scale      = True,
      anomalous_flag = False,
      use_sg         = False)
    assert approx_equal(fc1.mean_phase_error(phase_source=fc2), 0)
    diff = abs(fc1).data()-abs(fc2).data()
    assert approx_equal([flex.min(diff), flex.max(diff), flex.mean(diff)], [0,0,0])
    fc1 = fc2.deep_copy()

def exercise_build_set_using_max_index():
  xrs = random_structure.xray_structure(
    space_group_info=sgtbx.space_group_info(number=19),
    elements=["C"]*10)
  sphere = xrs.structure_factors(d_min=2.0, algorithm="direct").f_calc()
  crystal_gridding = sphere.crystal_gridding(
    d_min                   = 2.0,
    resolution_factor       = 0.2,
    grid_step               = None,
    symmetry_flags          = None,
    mandatory_factors       = None,
    max_prime               = 5,
    assert_shannon_sampling = True)
  n_real = crystal_gridding.n_real()
  max_index = [int(i/2.) for i in n_real]
  box = sphere.complete_set(max_index=max_index)
  bi = box.min_max_indices()[1]
  for i in [0,1,2]: assert bi[i] == max_index[i]

def exercise_log_binning():
  xrs = random_structure.xray_structure(
    space_group_info=sgtbx.space_group_info(number=1),
    elements=["C"]*300)
  fc = xrs.structure_factors(d_min=1.0).f_calc()
  lb = fc.log_binning()
  r = flex.double()
  for i in range(len(lb)):
    if(i!=0 and i+1<len(lb)-1):
      r.append(lb[i+1].count(True)/lb[i].count(True))
  assert r.size() == 7
  assert approx_equal(flex.mean(r), 2.0, 0.01)
  #
  for i in range(2,10):
    lb = fc.log_binning(max_number_of_bins=i)
    assert i == len(lb)
  #
  for t in range(100,3000, 500):
    lb = fc.log_binning(min_reflections_in_bin=t)
    for i, s in enumerate(lb):
      if(i!=0): assert s.count(True)>=t

def exercise_scale():
  cs = crystal.symmetry((10,10,10), "P1")
  mi = flex.miller_index([(1,2,1), (1,2,2), (1,2,3), (1,2,4), (1,2,5)])
  ms = miller.set(cs, mi, anomalous_flag=False)
  d = flex.double([1,2,3,4,5])
  ma1 = miller.array(ms, data=d)
  #
  mi = flex.miller_index([(1,2,1), (1,2,3), (1,2,4), (1,2,5), (1,2,6)])
  ms = miller.set(cs, mi, anomalous_flag=False)
  d = flex.double([2, 6,8,10, 1])
  ma2 = miller.array(ms, data=d)
  assert approx_equal(list(ma1.scale(other=ma2).data()), [1., 3., 4., 5., 0.5])
  assert approx_equal(list(ma2.scale(other=ma1).data()), [2., 4., 6., 8., 10.])

def exercise_complete_with4():
  cs = crystal.symmetry((10,10,10), "P1")
  mi = flex.miller_index([(0,0,1), (0,0,2), (0,0,3), (0,0,4), (0,0,5)])
  ms = miller.set(cs, mi, anomalous_flag=False)
  d = flex.double([1,2,3,4,5])
  p = flex.double([1,2,3,4,5])
  ma1 = miller.array(ms, data=d)
  ma1 = ma1.phase_transfer(phase_source=p, deg=True)
  #
  mi = flex.miller_index([(0,0,1), (0,0,3), (0,0,4), (0,0,5), (0,0,6)])
  ms = miller.set(cs, mi, anomalous_flag=False)
  d = flex.double([1,  3, 4, 5, 6])
  p = flex.double([10,30,40,50,60])
  ma2 = miller.array(ms, data=d)
  ma2 = ma2.phase_transfer(phase_source=p, deg=True)
  #
  r = ma1.complete_with(other=ma2, replace_phases=True)
  r = r.sort()
  assert approx_equal(list(r.phases(deg=True).data()), [10,2,30,40,50,60])
  #
  r = ma2.complete_with(other=ma1, replace_phases=True)
  r = r.sort()
  assert approx_equal(list(r.phases(deg=True).data()), [1,2,3,4,5,60])

def exercise_hoppe_gassmann_modification():
  xrs = random_structure.xray_structure(
    space_group_info=sgtbx.space_group_info(number=1),
    elements=["C"]*300)
  fc = xrs.structure_factors(d_min=2.0).f_calc()
  fc.hoppe_gassmann_modification(mean_scale=2, n_iterations=2)
  fc.hoppe_gassmann_modification(mean_scale=2, n_iterations=2, d_min=1)

def exercise_randomize_amplitude_and_phase(space_group_info,
      random_seed=1312425):
  xrs = random_structure.xray_structure(
    space_group_info=space_group_info,
    elements=["C"]*300)
  fc = xrs.structure_factors(d_min=1).f_calc()
  def run(a,p):
    fc_ = fc.randomize_amplitude_and_phase(amplitude_error=a,
      phase_error_deg=p, random_seed=random_seed)
    d1, d2 = flex.abs(fc.data()), flex.abs(fc_.data())
    r = flex.sum(flex.abs(d1-d2))/flex.sum(flex.abs(d1+d2))*2
    return (r, fc.mean_phase_error(phase_source=fc_))
  #
  assert approx_equal(run(0,0), (0,0))
  for v in range(0,91, 10):
    r = run(v/100.,v)
    assert approx_equal(r[0], v/100., 0.05)
    assert approx_equal(r[1], v, 5)

def exercise_permute():
  xrs = random_structure.xray_structure(
    space_group_info=sgtbx.space_group_info(number=1),
    elements=["C"]*300)
  fc = xrs.structure_factors(d_min=1.0).f_calc()
  fc_perm = fc.permute_d_range(d_max=1.1, d_min=0)
  fc_other = fc.resolution_filter(d_min=1.1)
  fc_high = fc.resolution_filter(d_max=1.1)
  fc_perm_high = fc_perm.resolution_filter(d_max=1.1)
  fc_perm_other = fc_perm.resolution_filter(d_min=1.1)#00001)
  assert fc.data().size() == fc_perm.data().size()
  assert fc.indices().all_eq(fc_perm.indices())
  assert fc_other.data().all_eq(fc_perm_other.data())
  assert not fc_high.data().all_eq(fc_perm_high.data())
  #
  # Ad hoc test for G-function
  #
  fc_high._data.append(123)
  fc_high._indices.append([0,0,0])
  s = 1./fc_high.d_spacings().data()
  sel = flex.sort_permutation(s, reverse=False)
  s = s.select(sel)
  assert approx_equal(s[0], -1)
  fc_high=fc_high.select(sel)
  vals = fc_high.g_function(R=3, volume_scale=False)
  assert approx_equal(vals[:3], [1.0, 0.000863211, 0.0008627407])

def exercise_diagnostics():
  xs = crystal.symmetry((30,40,50), "P 2 2 2")
  ms = miller.build_set(crystal_symmetry=xs, anomalous_flag=True, d_min=2.9)
  da, db, dc = ms.d_min_along_a_b_c_star()
  assert approx_equal([da, db, dc], [3.0, 3.076923, 2.941176])
  xs2 = crystal.symmetry((30,40,60), "P 2 2 2")
  ms = ms.customized_copy(crystal_symmetry=xs2)
  da, db, dc = ms.d_min_along_a_b_c_star()
  assert approx_equal([da, db, dc], [3.0, 3.076923, 3.529412])

def exercise_convert_to_non_anomalous_if_ratio_pairs_lone_less_than():
  xs = crystal.symmetry((30,40,50), "P1")
  ms = miller.build_set(crystal_symmetry=xs, anomalous_flag=True, d_min=2.0)
  d = flex.double(ms.indices().size(), 0)
  ma = miller.array(ms, data=d)
  asu, matches = ma.match_bijvoet_mates()
  sel = matches.pairs().column(0)
  sel_ = flex.random_bool(sel.size(), 0.7)
  sel = sel.select(sel_)
  sel = ~flex.bool(d.size(), sel)
  ma = ma.select(sel)
  assert ma.completeness() < 0.66
  assert ma.anomalous_flag()
  ma=ma.convert_to_non_anomalous_if_ratio_pairs_lone_less_than(threshold=0.1)
  assert ma.completeness() < 0.66
  assert ma.anomalous_flag()
  ma=ma.convert_to_non_anomalous_if_ratio_pairs_lone_less_than(threshold=0.5)
  assert ma.completeness()>0.99
  assert ma.anomalous_flag() is False

def exercise_change_symmetry():
  # these should run without warnings
  with warnings.catch_warnings(record=True) as w:
    test_inputs = [
      ( (10, 20, 30, 89.9, 75, 90.1), "P1", "P2"),
      ( (10, 20, 30, 90, 89.95, 90), "P21", "P21212"),
      ( (125.91, 126.066, 165.64, 89.9324, 89.732, 60.0588), "P1", "P63"),
      ( (125.91, 126.066, 165.64, 89.9324, 89.732, 60.0588), "P1",
        "P63 (-a,b,-c)"),
      ( (40.1, 40.2, 65, 89.98, 90.02, 120.05), "P1", "P63" ),
      ( (40.1, 40.2, 65, 90, 90, 90), "P222", "P4"),
      ( (40.1, 40.2, 65, 90, 90, 90), "P222", "P1"),
    ]
    expected_unit_cells = [
      (10, 20, 29.0639, 90, 85.5888, 90),
      (10, 20, 30, 90, 90, 90),
      (126.025, 126.025, 165.64, 90, 90, 120),
      (126.025, 126.025, 165.64, 90, 90, 120),
      (40.1399, 40.1399, 65, 90, 90, 120),
      (40.15, 40.15, 65, 90, 90, 90),
      (40.1, 40.2, 65, 90, 90, 90),
    ]
    for i_inp, (uc_old, sg_old, sg_new) in enumerate(test_inputs):
      cs = crystal.symmetry(
        unit_cell=uc_old,
        space_group_symbol=sg_old)
      ms = miller.build_set(
        crystal_symmetry=cs,
        anomalous_flag=False,
        d_min=1.5)
      ma = ms.array(data=flex.double(ms.size(), 1.0))
      ma_new = ma.change_symmetry(sg_new, log=null_out())
      assert approx_equal(ma_new.unit_cell().parameters(),
        expected_unit_cells[i_inp], eps=0.001)
      assert (ma_new.completeness() >= 0.99), ma_new.completeness()
    assert len(w) == 0
  # test warnings
  with warnings.catch_warnings(record=True) as w:
    test_inputs = [
      ( (39.0, 40.7, 65, 89.98, 90.02, 121.05), "P1", "P63" ),
      ( (40.1, 40.2, 65, 90, 90, 90), "P222", "P1"),
    ]
    for i_inp, (uc_old, sg_old, sg_new) in enumerate(test_inputs):
      cs = crystal.symmetry(
        unit_cell=uc_old,
        space_group_symbol=sg_old)
      ms = miller.build_set(
        crystal_symmetry=cs,
        anomalous_flag=False,
        d_min=3.0)
      ma = ms.array(data=flex.double(ms.size(), 1.0))
      ma_new = ma.change_symmetry(sg_new, log=null_out(),
        expand_to_p1_if_necessary=False)
    assert len(w) == 2

def exercise_systematic_absences_info():
  xrs = random_structure.xray_structure(
    sgtbx.space_group_info("P21212"),
    elements=["const"]*100)
  f_calc = xrs.structure_factors(d_min=2.5).f_calc()
  i_calc = abs(f_calc).f_as_f_sq().set_observation_type_xray_intensity()
  i_calc = i_calc.customized_copy(
    space_group_info=sgtbx.space_group_info("P222"),
    sigmas=flex.double(i_calc.size(), 1.0))
  complete_set = i_calc.complete_set()
  lone_set = complete_set.lone_set(other=i_calc)
  i_abs = lone_set.array(data=flex.double(lone_set.size(), 0.05),
    sigmas=flex.double(lone_set.size(), 0.1))
  i_calc = i_calc.concatenate(other=i_abs).set_observation_type_xray_intensity()
  out = StringIO()
  absences = i_calc.show_all_possible_systematic_absences(out=out)
  assert (out.getvalue().count("  (   0,    3,    0): i/sigi =    0.5") == 4)
  fc = i_calc.f_sq_as_f()
  absences = fc.show_all_possible_systematic_absences(out=out)
  assert (absences.input_amplitudes)
  i_calc = i_calc.customized_copy(sigmas=None)
  try :
    absences = i_calc.show_all_possible_systematic_absences(out=out)
  except AssertionError :
    pass
  else :
    raise Exception_expected

def exercise_karle_normalization():
  xrs = random_structure.xray_structure(
    space_group_info = sgtbx.space_group_info(number=19),
    elements=["C"]*500,
    volume_per_atom=50,
    min_distance=1.0,
    general_positions_only=True,
    u_iso=0.0)
  fc = abs(xrs.structure_factors(
    d_min=1).f_calc()).set_observation_type_xray_amplitude()
  cntr = 0
  for m in fc.second_moments_centric_acentric():
    if(m[0]=="centric"):
      # result of 430 test runs:
      # min 2.757, q1 2.899, mean 2.947, q3 2.990, max 3.118, sd 0.06530
      assert approx_equal(m[1], 3.0, 0.3)
      cntr += 1
    if(m[0]=="acentric"):
      # result of 430 test runs:
      # min 1.964, q1 1.982, mean 1.987, q3 1.993, max 2.012, sd 0.00844
      assert approx_equal(m[1], 2.0, 0.1)
      cntr += 1
  assert cntr == 2

def exercise_structure_factors_from_map_and_asu_map(d_min=2.):
  import boost_adaptbx.boost.python as bp
  asu_map_ext = bp.import_ext("cctbx_asymmetric_map_ext")
  def rfactor(x,y):
    x = flex.abs(x.data())
    y = flex.abs(y.data())
    num = flex.sum(flex.abs(x-y))
    den = flex.sum(flex.abs(x+y))
    return num/den*2*100.
  for sg_number in range(1,231):
    xrs = random_structure.xray_structure(
      space_group_info = sgtbx.space_group_info(number=sg_number),
      elements=["C"]*50,
      volume_per_atom=50,
      min_distance=1.0,
      general_positions_only=False)
    fc = xrs.structure_factors(
      d_min=d_min).f_calc().set_observation_type_xray_amplitude()
    crystal_gridding = fc.crystal_gridding(
      d_min              = fc.d_min(),
      symmetry_flags     = maptbx.use_space_group_symmetry,
      resolution_factor  = 1./4)
    n_real = crystal_gridding.n_real()
    fft_map = fc.fft_map(
      symmetry_flags   = maptbx.use_space_group_symmetry,
      crystal_gridding = crystal_gridding)
    fft_map.apply_volume_scaling()
    map_data = fft_map.real_map_unpadded()
    fc_from_map = fc.structure_factors_from_map(
      map       = map_data,
      use_scale = True,
      use_sg    = False)
    assert approx_equal(rfactor(x=fc,y=fc_from_map), 0.0)
    # ASU map
    asu_map = asu_map_ext.asymmetric_map(
      xrs.space_group().type(), map_data).data()
    #asu_map = asu_map.shift_origin() # This brakes assertion in rare SG
    fc_from_asu_map = fc.structure_factors_from_asu_map(
      asu_map_data = asu_map,
      n_real       = n_real)
    assert approx_equal(rfactor(x=fc,y=fc_from_asu_map), 0.0)

def exercise_as_map_manager():
  xrs = random_structure.xray_structure(
    space_group_info = sgtbx.space_group_info(number=19),
    elements=["C"]*50,
    volume_per_atom=50,
    min_distance=1.0,
    general_positions_only=False)
  fc = xrs.structure_factors(d_min=2.0).f_calc()
  mm = fc.as_map_manager()
  mm = fc.as_map_manager(d_min=1, d_max=3)
  mm = fc.as_map_manager(wrapping=False, apply_volume_scaling=False)

def exercise_make_up_hl_coeffs():
  xrs = random_structure.xray_structure(
    space_group_info = sgtbx.space_group_info(number=19),
    elements=["C"]*50,
    volume_per_atom=50,
    min_distance=1.0,
    general_positions_only=False)
  fc = xrs.structure_factors(d_min=2.0).f_calc()
  hl = fc.make_up_hl_coeffs(k_blur=1, b_blur=20)

def run(args):
  exercise_make_up_hl_coeffs()
  exercise_as_map_manager()
  exercise_generate_bijvoet_mates_set()
  exercise_counting_sorted_n_bins_reflections_per_bin()
  exercise_counting_sorted_no_empty_bins()
  exercise_neighbor_average()
  exercise_local_overlap_map()
  exercise_structure_factors_from_map_and_asu_map()
  exercise_karle_normalization()
  exercise_systematic_absences_info()
  exercise_change_symmetry()
  exercise_convert_to_non_anomalous_if_ratio_pairs_lone_less_than()
  exercise_diagnostics()
  exercise_hoppe_gassmann_modification()
  exercise_complete_with4()
  exercise_scale()
  exercise_log_binning()
  exercise_build_set_using_max_index()
  exercise_structure_factors_from_map()
  exercise_complete_with_complete_with_bin_average()
  exercise_complete_with1()
  exercise_complete_with2()
  exercise_complete_with3()
  exercise_lsd_map()
  exercise_shelxl_extinction_correction()
  exercise_symmetry_agreement_factor()
  exercise_multiscale()
  exercise_difference_map()
  exercise_concatenate()
  exercise_phased_translation_coeff()
  exercise_set()
  exercise_union_of_sets()
  exercise_generate_r_free_flags(
    use_lattice_symmetry=False, verbose="--verbose" in args)
  exercise_generate_r_free_flags(
    use_lattice_symmetry=True, verbose="--verbose" in args)
  exercise_enforce_positive_amplitudes()
  exercise_binner()
  exercise_array()
  exercise_debye_waller()
  exercise_r1_factor()
  exercise_scale_factor()
  exercise_complete_array()
  exercise_crystal_gridding()
  exercise_fft_map()
  exercise_map_correlation()
  exercise_merge_equivalents_special_cases()
  exercise_permute()
  debug_utils.parse_options_loop_space_groups(args, run_call_back)
  print("OK")

if (__name__ == "__main__"):
  flex.set_random_seed(1)
  run(args=sys.argv[1:])


 *******************************************************************************


 *******************************************************************************
cctbx/regression/tst_miller_data_manipulation.py

from __future__ import absolute_import, division, print_function
from cctbx.development import random_structure
from cctbx.development import debug_utils
from cctbx.sgtbx import space_group_info
from scitbx.array_family import flex
from libtbx.test_utils import approx_equal, Exception_expected
from libtbx.utils import Sorry
import random
import math
import sys
from six.moves import zip

if (1): # fixed random seed to avoid rare failures
  random.seed(0)
  flex.set_random_seed(0)

def exercise_ellipsoidal_truncation(space_group_info, n_sites=100, d_min=1.5):
  xrs = random_structure.xray_structure(
    space_group_info=space_group_info,
    elements=(("O","N","C")*(n_sites//3+1))[:n_sites],
    volume_per_atom=50,
    min_distance=1.5)
  f_obs = abs(xrs.structure_factors(d_min = d_min).f_calc())
  # exercise reciprocal_space_vector()
  for mi, d in zip(f_obs.indices(), f_obs.d_spacings().data()):
    rsv = flex.double(f_obs.unit_cell().reciprocal_space_vector(mi))
    assert approx_equal(d, 1./math.sqrt(rsv.dot(rsv)))
  ##
  print(f_obs.unit_cell())
  f = flex.random_double(f_obs.data().size())*flex.mean(f_obs.data())/10
  #
  f_obs1 = f_obs.customized_copy(data = f_obs.data(), sigmas = f_obs.data()*f)
  print("datat in:",f_obs1.data().size())
  r = f_obs1.ellipsoidal_truncation_by_sigma(sigma_cutoff=1)
  print("data left:",r.data().size())
  r.miller_indices_as_pdb_file(file_name="indices1.pdb", expand_to_p1=False)
  r.miller_indices_as_pdb_file(file_name="indices2.pdb", expand_to_p1=True)
  #
  f_obs.miller_indices_as_pdb_file(file_name="indices3.pdb", expand_to_p1=False)
  f_obs.miller_indices_as_pdb_file(file_name="indices4.pdb", expand_to_p1=True)
  print("*"*25)

def exercise_translational_phase_shift(n_sites=100,d_min=1.5,
     resolution_factor = 0.3):
  sgi= space_group_info("P1")
  xrs = random_structure.xray_structure(
    space_group_info=sgi,
    elements=(("O","N","C")*(n_sites//3+1))[:n_sites],
    volume_per_atom=50,
    min_distance=1.5)
  f_calc= xrs.structure_factors(d_min = d_min).f_calc()
  print(f_calc.unit_cell())
  from scitbx.matrix import col
  shift_frac=col((.23984120,.902341127,.51219021))

  # Shift phases directly
  phase_shifted=f_calc.translational_shift(shift_frac=shift_frac)

  # Check that map from phase_shifted FC matches map calculated from
  #   translated xrs

  # Map from phase-shifted FC
  shifted_fft_map = phase_shifted.fft_map(resolution_factor=resolution_factor)
  shifted_fft_map.apply_sigma_scaling()
  shifted_map_data = shifted_fft_map.real_map_unpadded()
  cs = xrs.crystal_symmetry()
  from cctbx.maptbx import crystal_gridding
  cg = crystal_gridding(
      unit_cell             = cs.unit_cell(),
      space_group_info      = cs.space_group_info(),
      pre_determined_n_real = shifted_map_data.all())

  # Map from translated xrs
  sites_shifted=xrs.sites_frac()+shift_frac
  xrs.set_sites_frac(sites_shifted)
  f_calc_from_shifted_xrs = xrs.structure_factors(d_min = d_min).f_calc()
  fft_map_from_shifted_xrs = f_calc_from_shifted_xrs.fft_map(
      resolution_factor=resolution_factor,
      crystal_gridding     = cg)
  map_data_from_shifted_xrs=fft_map_from_shifted_xrs.real_map_unpadded()

  # shifted_map_data (map from phase shifted f_calc),
  # map_data_from_shifted_xrs (recalculated with shifted xrs)

  assert shifted_map_data.all() == map_data_from_shifted_xrs.all()
  from cctbx import maptbx
  sel = maptbx.grid_indices_around_sites(
      unit_cell  = xrs.unit_cell(),
      fft_n_real = shifted_map_data.focus(),
      fft_m_real = shifted_map_data.all(),
      sites_cart = xrs.sites_cart(),
      site_radii = flex.double(xrs.scatterers().size(), 1.5))
  shifted_map_data = shifted_map_data.select(sel)
  map_data_from_shifted_xrs = map_data_from_shifted_xrs.select(sel)

  cc_map_data_from_shifted_xrs_shifted_map_data= flex.linear_correlation(x=map_data_from_shifted_xrs.as_1d(),  y=shifted_map_data.as_1d()).coefficient()
  print("cc_map_data_from_shifted_xrs_shifted_map_data",\
     cc_map_data_from_shifted_xrs_shifted_map_data)
  assert  cc_map_data_from_shifted_xrs_shifted_map_data > 0.99
  print("*"*25)

def run_call_back(flags, space_group_info):
  exercise_ellipsoidal_truncation(space_group_info)

# TODO ideally this should loop over all possible space groups and all
# possible twin laws
def exercise_twinning():
  xrs = random_structure.xray_structure(
    unit_cell=(12,5,12,90,90,90),
    space_group_symbol="P1",
    n_scatterers=12,
    elements="random")
  fc = abs(xrs.structure_factors(d_min=1.5).f_calc())
  fc = fc.set_observation_type_xray_amplitude()
  fc_twin = fc.twin_data("l,-k,h", 0.3)
  ic = fc.f_as_f_sq()
  fc_twin_2 = ic.twin_data("l,-k,h", 0.3).f_sq_as_f()
  assert (fc_twin.data().all_eq(fc_twin_2.data()))
  fc_tmp, fc_twin_tmp = fc.common_sets(other=fc_twin)
  # XXX in this particular crystal symmetry, a subset of reflections where h==l
  # will have the same value in the twinned and untwinned data - need to check
  # whether this is correct
  assert not fc_twin_tmp.data().all_approx_equal(fc_tmp.data())
  try :
    fc_twin = fc.twin_data("k,h,l", 0.5)
  except Sorry as s:
    pass
  else :
    raise Exception_expected
  fc_detwin = fc_twin.detwin_data("l,-k,h", 0.3)
  fc_detwin, fc = fc_detwin.common_sets(other=fc)
  assert fc_detwin.data().all_approx_equal(fc.data())
  # derived from PDB 3hfg; this confirms that the change in unit cell
  # parameters does not crash the routines
  xrs = random_structure.xray_structure(
    unit_cell=(56.438, 152.670, 74.203, 90.00, 92.41, 90.00),
    space_group_symbol="P21",
    n_scatterers=100,
    elements="random")
  fc = abs(xrs.structure_factors(d_min=1.5).f_calc())
  fc = fc.set_observation_type_xray_amplitude()
  fc_twin = fc.twin_data("h,-k,-l", 0.3)
  ic = fc.f_as_f_sq()
  fc_twin_2 = ic.twin_data("h,-k,-l", 0.3).f_sq_as_f()
  assert (fc_twin.data().all_eq(fc_twin_2.data()))
  fc_detwin = fc_twin.detwin_data("h,-k,-l", 0.3)
  fc_detwin, fc = fc_detwin.common_sets(other=fc)
  assert fc_detwin.data().all_approx_equal(fc.data())

if (__name__ == "__main__"):
  exercise_twinning()
  exercise_translational_phase_shift()
  debug_utils.parse_options_loop_space_groups(sys.argv[1:], run_call_back)


 *******************************************************************************


 *******************************************************************************
cctbx/regression/tst_miller_double_step_filtration.py
from __future__ import absolute_import, division, print_function
from scitbx.array_family import flex
from cctbx import miller
import iotbx.pdb

def map_cc(map_coeffs_1, map_coeffs_2):
  fft_map_1 = map_coeffs_1.fft_map(resolution_factor=0.25)
  map_1 = fft_map_1.real_map_unpadded()
  fft_map_2 = miller.fft_map(
    crystal_gridding = fft_map_1,
    fourier_coefficients = map_coeffs_2)
  map_2 = fft_map_2.real_map_unpadded()
  assert map_1.size() == map_2.size()
  m1 = map_1.as_1d()
  m2 = map_2.as_1d()
  return flex.linear_correlation(x = m1, y = m2).coefficient()

def run():
  import iotbx.pdb
  xrs_str = """
CRYST1    8.000    8.000    8.000  90.00  90.00  90.00 P 1
HETATM  115  O   HOH A  18       4.000   4.000   4.000  1.00 10.00           O
TER
END
  """
  pdb_inp = iotbx.pdb.input(source_info=None, lines=xrs_str)
  xrs = pdb_inp.xray_structure_simple()
  xrs.scattering_type_registry(table = "wk1995")
  cntr = 0
  for remove_fraction in [0.2, 0.5]:
    print()
    print("remove_fraction:", remove_fraction)
    for option in ["random", "smallest", "highest"]:
      print()
      print("data incompleteness:",option,"-"*30)
      #
      f_exact = xrs.structure_factors(d_min = 1.0).f_calc()
      #
      if(option=="highest"):
        s = flex.sort_permutation(abs(f_exact).data(), reverse=True)
        f_exact = f_exact.select(s)
        n_remove = int(s.size()*remove_fraction)
        f_poor = f_exact.customized_copy(
          data    = f_exact.data()[n_remove:],
          indices = f_exact.indices()[n_remove:])
      elif(option == "smallest"):
        s = flex.sort_permutation(abs(f_exact).data(), reverse=True)
        f_exact = f_exact.select(s)
        n_remove = int(s.size()*remove_fraction)
        sz = f_exact.data().size()
        f_poor = f_exact.customized_copy(
          data    = f_exact.data()[:sz-n_remove],
          indices = f_exact.indices()[:sz-n_remove])
      elif(option == "random"):
        s = flex.random_bool(f_exact.data().size(), 1.-remove_fraction)
        f_poor = f_exact.select(s)
      else: assert 0
      #
      print("number of all data:", f_exact.data().size())
      print("number of incomplete data:", f_poor.data().size())
      cc1 = map_cc(map_coeffs_1=f_exact, map_coeffs_2=f_poor)
      print("start CC(exact_map, poor_map): ", cc1)
      #
      f_dsf = f_poor.double_step_filtration(
        vol_cutoff_plus_percent =0.1,
        vol_cutoff_minus_percent=0.1,
        complete_set=f_exact)
      f_new = f_poor.complete_with(other = f_dsf)
      cc2 = map_cc(map_coeffs_1=f_exact, map_coeffs_2=f_new)
      print("start CC(exact_map, filled_map)1: ", cc2)
      #
      f_dsf = f_poor.double_step_filtration(
        vol_cutoff_plus_percent =0.1,
        vol_cutoff_minus_percent=0.1,
        complete_set=f_exact,
        scale_to=f_exact)
      f_new = f_poor.complete_with(other = f_dsf)
      cc3 = map_cc(map_coeffs_1=f_exact, map_coeffs_2=f_new)
      print("start CC(exact_map, filled_map)2: ", cc3)
      #
      if(option=="highest"):
        if(remove_fraction==0.2):
          assert cc1<0.92
          assert cc2>0.99 and cc3>0.99
          cntr += 1
        elif(remove_fraction==0.5):
          assert cc1<0.16
          assert cc2>0.76
          assert cc3>0.99
          cntr += 1
  #
  assert cntr == 2 # make sure it's gone through all if statements

if (__name__ == "__main__"):
  run()


 *******************************************************************************
