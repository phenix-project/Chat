

 *******************************************************************************
iotbx/regression/secondary_structure/tst_annotation_long.py
from __future__ import absolute_import, division, print_function
import time
from iotbx.pdb.secondary_structure import annotation
import iotbx
import iotbx.cif
from libtbx.test_utils import show_diff

cif_one_helix = """\
#
_struct_conf.conf_type_id            HELX_P
_struct_conf.id                      HELX_P1
_struct_conf.pdbx_PDB_helix_id       AA1
_struct_conf.beg_label_comp_id       longGLN
_struct_conf.beg_label_asym_id       longA
_struct_conf.beg_label_seq_id        149
_struct_conf.pdbx_beg_PDB_ins_code   ?
_struct_conf.end_label_comp_id       longGLY
_struct_conf.end_label_asym_id       longA
_struct_conf.end_label_seq_id        160
_struct_conf.pdbx_end_PDB_ins_code   ?
_struct_conf.beg_auth_comp_id        alongGLN
_struct_conf.beg_auth_asym_id        alongA
_struct_conf.beg_auth_seq_id         212
_struct_conf.end_auth_comp_id        alongGLY
_struct_conf.end_auth_asym_id        alongA
_struct_conf.end_auth_seq_id         223
_struct_conf.pdbx_PDB_helix_class    1
_struct_conf.details                 ?
_struct_conf.pdbx_PDB_helix_length   12
#
_struct_conf_type.id          HELX_P
_struct_conf_type.criteria    ?
_struct_conf_type.reference   ?
"""

cif_one_sheet = """\
#
_struct_sheet.id               A
_struct_sheet.type             ?
_struct_sheet.number_strands   2
_struct_sheet.details          ?
#
_struct_sheet_order.sheet_id     A
_struct_sheet_order.range_id_1   1
_struct_sheet_order.range_id_2   2
_struct_sheet_order.offset       ?
_struct_sheet_order.sense        anti-parallel
#
loop_
_struct_sheet_range.sheet_id
_struct_sheet_range.id
_struct_sheet_range.beg_label_comp_id
_struct_sheet_range.beg_label_asym_id
_struct_sheet_range.beg_label_seq_id
_struct_sheet_range.pdbx_beg_PDB_ins_code
_struct_sheet_range.end_label_comp_id
_struct_sheet_range.end_label_asym_id
_struct_sheet_range.end_label_seq_id
_struct_sheet_range.pdbx_end_PDB_ins_code
_struct_sheet_range.symmetry
_struct_sheet_range.beg_auth_comp_id
_struct_sheet_range.beg_auth_asym_id
_struct_sheet_range.beg_auth_seq_id
_struct_sheet_range.end_auth_comp_id
_struct_sheet_range.end_auth_asym_id
_struct_sheet_range.end_auth_seq_id
A 1 longSER longA 4  ? longALA longA 7  ? ? alongSER alongA 4  alongALA alongA 7
A 2 longMET longA 22 ? longGLU longA 25 ? ? alongMET alongA 22 alongGLU alongA 25
#
_pdbx_struct_sheet_hbond.sheet_id                A
_pdbx_struct_sheet_hbond.range_id_1              1
_pdbx_struct_sheet_hbond.range_id_2              2
_pdbx_struct_sheet_hbond.range_1_label_atom_id   N
_pdbx_struct_sheet_hbond.range_1_label_comp_id   longSER
_pdbx_struct_sheet_hbond.range_1_label_asym_id   longA
_pdbx_struct_sheet_hbond.range_1_label_seq_id    4
_pdbx_struct_sheet_hbond.range_1_PDB_ins_code    ?
_pdbx_struct_sheet_hbond.range_1_auth_atom_id    N
_pdbx_struct_sheet_hbond.range_1_auth_comp_id    alongSER
_pdbx_struct_sheet_hbond.range_1_auth_asym_id    alongA
_pdbx_struct_sheet_hbond.range_1_auth_seq_id     4
_pdbx_struct_sheet_hbond.range_2_label_atom_id   O
_pdbx_struct_sheet_hbond.range_2_label_comp_id   longGLU
_pdbx_struct_sheet_hbond.range_2_label_asym_id   longA
_pdbx_struct_sheet_hbond.range_2_label_seq_id    25
_pdbx_struct_sheet_hbond.range_2_PDB_ins_code    ?
_pdbx_struct_sheet_hbond.range_2_auth_atom_id    O
_pdbx_struct_sheet_hbond.range_2_auth_comp_id    alongGLU
_pdbx_struct_sheet_hbond.range_2_auth_asym_id    alongA
_pdbx_struct_sheet_hbond.range_2_auth_seq_id     25
#
"""

def tst_helix_interface():
  cif_str = "data_1UCS" + cif_one_helix
  cif_model = iotbx.cif.reader(input_string=cif_str).model()
  cif_block = list(cif_model.values())[0]
  ann = annotation.from_cif_block(cif_block)
  h = ann.helices[0]
  #
  # !!! Note, here we got info from *auth* fields.
  #
  assert h.serial == 1
  assert h.helix_id == 'AA1', h.helix_id
  assert h.start_resname == 'alongGLN', h.start_resname
  assert h.start_chain_id == 'alongA'
  assert h.start_resseq == ' 212', h.start_resseq
  assert h.start_icode == ' '
  assert h.end_resname == 'alongGLY'
  assert h.end_chain_id == 'alongA'
  assert h.end_resseq == ' 223'
  assert h.end_icode == ' '
  assert h.helix_class == 'alpha'
  assert h.comment == '', "'%s'" % h.comment
  assert h.length == 12, h.length
  assert h.hbond_list == []
  assert h.helix_selection == None
  assert h.enabled == True
  assert h.sigma ==0.05
  assert h.slack ==0
  assert h.top_out == False

  assert h.get_start_resseq_as_int() == 212
  assert h.get_end_resseq_as_int() == 223
  assert not h.fits_in_pdb_format()
  assert not ann.fits_in_pdb_format()
  # print (h.as_pdb_or_mmcif_str())
  assert not show_diff(h.as_mmcif_str(),
"""data_phenix
loop_
  _struct_conf.conf_type_id
  _struct_conf.id
  _struct_conf.pdbx_PDB_helix_id
  _struct_conf.beg_label_comp_id
  _struct_conf.beg_label_asym_id
  _struct_conf.beg_label_seq_id
  _struct_conf.pdbx_beg_PDB_ins_code
  _struct_conf.end_label_comp_id
  _struct_conf.end_label_asym_id
  _struct_conf.end_label_seq_id
  _struct_conf.pdbx_end_PDB_ins_code
  _struct_conf.pdbx_PDB_helix_class
  _struct_conf.details
  _struct_conf.pdbx_PDB_helix_length
  HELX_P  1  AA1  alongGLN  alongA  212  ?  alongGLY  alongA  223  ?  1  ?  12

loop_
  _struct_conf_type.id
  _struct_conf_type.criteria
  _struct_conf_type.reference
  HELX_P  ?  ?

""")

def tst_sheet_interface():
  cif_str = "data_1UCS" + cif_one_sheet
  cif_model = iotbx.cif.reader(input_string=cif_str).model()
  cif_block = list(cif_model.values())[0]
  ann = annotation.from_cif_block(cif_block)

  sh = ann.sheets[0]
  st = sh.strands[1]
  reg = sh.registrations[1]

  #
  # !!! Note, here we got info from *auth* fields.
  #

  assert reg.cur_atom == ' O  '
  assert reg.cur_resname == 'alongGLU', reg.cur_resname
  assert reg.cur_chain_id == 'alongA'
  assert reg.cur_resseq == '  25'
  assert reg.cur_icode == ' '
  assert reg.prev_atom == ' N  '
  assert reg.prev_resname == 'alongSER'
  assert reg.prev_chain_id == 'alongA'
  assert reg.prev_resseq == '   4'
  assert reg.prev_icode  == ' '

  assert st.sheet_id == 'A', st.sheet_id
  assert st.strand_id == 2, st.strand_id
  assert st.start_resname == 'alongMET',st.start_resname
  assert st.start_chain_id == 'alongA'
  assert st.start_resseq == '  22', st.start_resseq
  assert st.start_icode == ' '
  assert st.end_resname == 'alongGLU'
  assert st.end_chain_id == 'alongA'
  assert st.end_resseq == '  25'
  assert st.end_icode == ' '
  assert st.sense == -1

  assert not sh.fits_in_pdb_format()
  assert not ann.fits_in_pdb_format()
  # print (sh.as_pdb_or_mmcif_str())
  assert not show_diff(sh.as_mmcif_str(),
"""data_phenix
loop_
  _struct_sheet.id
  _struct_sheet.type
  _struct_sheet.number_strands
  _struct_sheet.details
  A  ?  2  ?

loop_
  _struct_sheet_order.sheet_id
  _struct_sheet_order.range_id_1
  _struct_sheet_order.range_id_2
  _struct_sheet_order.offset
  _struct_sheet_order.sense
  A  1  2  ?  anti-parallel

loop_
  _struct_sheet_range.sheet_id
  _struct_sheet_range.id
  _struct_sheet_range.beg_label_comp_id
  _struct_sheet_range.beg_label_asym_id
  _struct_sheet_range.beg_label_seq_id
  _struct_sheet_range.pdbx_beg_PDB_ins_code
  _struct_sheet_range.end_label_comp_id
  _struct_sheet_range.end_label_asym_id
  _struct_sheet_range.end_label_seq_id
  _struct_sheet_range.pdbx_end_PDB_ins_code
  A  1  alongSER  alongA   4  ?  alongALA  alongA   7  ?
  A  2  alongMET  alongA  22  ?  alongGLU  alongA  25  ?

loop_
  _pdbx_struct_sheet_hbond.sheet_id
  _pdbx_struct_sheet_hbond.range_id_1
  _pdbx_struct_sheet_hbond.range_id_2
  _pdbx_struct_sheet_hbond.range_1_label_atom_id
  _pdbx_struct_sheet_hbond.range_1_label_comp_id
  _pdbx_struct_sheet_hbond.range_1_label_asym_id
  _pdbx_struct_sheet_hbond.range_1_label_seq_id
  _pdbx_struct_sheet_hbond.range_1_PDB_ins_code
  _pdbx_struct_sheet_hbond.range_2_label_atom_id
  _pdbx_struct_sheet_hbond.range_2_label_comp_id
  _pdbx_struct_sheet_hbond.range_2_label_asym_id
  _pdbx_struct_sheet_hbond.range_2_label_seq_id
  _pdbx_struct_sheet_hbond.range_2_PDB_ins_code
  A  1  2  N  alongSER  alongA  4  ?  O  alongGLU  alongA  25  ?

""")

if (__name__ == "__main__"):
  t0 = time.time()
  tst_helix_interface()
  tst_sheet_interface()
  print("OK time =%8.3f"%(time.time() - t0))


 *******************************************************************************


 *******************************************************************************
iotbx/regression/secondary_structure/tst_sheet.py
from __future__ import absolute_import, division, print_function
import sys
from iotbx.pdb import secondary_structure as ss
from libtbx.utils import Sorry, format_cpu_times
from libtbx import test_utils

ann_1 = """\
SHEET    1   B 4 ARG A  90  PHE A  95  0
SHEET    2   B 4 GLY A 179  ARG A 184 -1  N  GLY A 179   O  PHE A 95
SHEET    3   B 4 ARG A 128  THR A 132 -1  N  ALA A 130   O  ARG A 184
SHEET    4   B 4 VAL A 148  PRO A 152  0  O  ILE A 151   N  VAL A 129
"""

ann_2 = """\
SHEET    1   B 4 ARG A  90  PHE A  95  0
SHEET    2   B 4 GLY A 179  ARG A 184 -1  N  GLY A 179   O  PHE A 95
SHEET    3   B 4 ARG A 128  THR A 132 -1  N  ALA A 130   O  ARG A 184
SHEET    4   B 4 VAL A 148  PRO A 152 -1  O  ILE A 151   N  VAL A 129
"""

ann_3 = """\
SHEET    1   3 3 MET A 157  VAL A 161  0
SHEET    2   3 3 ILE A 114  ALA A 122 -1
SHEET    3   3 3 THR A 193  LEU A 201  1
"""

def exercise_01():
  try:
    annot = ss.annotation.from_records(records=ann_1.split('\n'))
  except Sorry as e:
    m = str(e)
    assert m.find("should be 1 or -1 for non-first strand") > 0

def exercise_02():
  annot = ss.annotation.from_records(records=ann_2.split('\n'))
  assert len(annot.helices) == 0
  assert len(annot.sheets) == 1
  sheet = annot.sheets[0]
  assert sheet.n_strands == 4
  assert len(sheet.strands) == 4
  assert len(sheet.registrations) == 4
  assert sheet.registrations[0] is None

def exercise_03():
  answer_phil_str = """\

protein.sheet {
  sheet_id = "  3"
  first_strand = chain 'A' and resid  157  through  161
  strand {
    selection = chain 'A' and resid  114  through  122
    sense = antiparallel
    bond_start_current = None
    bond_start_previous = None
  }
  strand {
    selection = chain 'A' and resid  193  through  201
    sense = parallel
    bond_start_current = None
    bond_start_previous = None
  }
}"""
  annot = ss.annotation.from_records(records=ann_3.split('\n'))
  assert len(annot.helices) == 0
  assert len(annot.sheets) == 1
  ann_sheet = annot.sheets[0]
  assert ann_sheet.n_strands == 3
  assert ann_sheet.registrations == [None]*3
  only_sheet = annot.sheets[0]
  phil_string = annot.as_restraint_groups()
  assert not test_utils.show_diff(phil_string, answer_phil_str,
      strip_trailing_whitespace=True)

def exercise(args):
  exercise_01()
  exercise_02()
  exercise_03()
  print("OK")
  print(format_cpu_times())

if (__name__ == "__main__"):
  exercise(sys.argv[1:])


 *******************************************************************************


 *******************************************************************************
iotbx/regression/tst_add_conformations.py
from __future__ import absolute_import, division, print_function

from libtbx.test_utils import contains_lines, Exception_expected
from libtbx.utils import Sorry
import libtbx.load_env
import iotbx.pdb
from six.moves import cStringIO as StringIO
import os

def exercise():
  pdb_file = libtbx.env.find_in_repositories(
    relative_path="phenix_regression/pdb/1ywf.pdb",
    test=os.path.isfile)
  if (pdb_file is None):
    print("phenix_regression not available, skipping test.")
    return
  from iotbx.command_line.pdb_add_conformations import run
  out = StringIO()
  run([pdb_file], out=out)
  assert contains_lines(out.getvalue(), "Modified model: 4254 atoms")
  out = StringIO()
  run([pdb_file, "atom_selection=\"chain A and not resname HOH\""], out=out)
  assert contains_lines(out.getvalue(), "Modified model: 3990 atoms")
  run([pdb_file, "new_occ=0.4", "atom_selection=\"resseq 1:275\""], out=out)
  pdb_in = iotbx.pdb.input("1ywf_split.pdb")
  atoms = pdb_in.atoms()
  occ = atoms.extract_occ()
  assert (occ.count(0.6) == occ.count(0.4) == 1858)
  out = StringIO()
  run([pdb_file, "n_confs=3", "new_occ=0.25"], out=out)
  pdb_in = iotbx.pdb.input("1ywf_split.pdb")
  assert contains_lines(out.getvalue(), """\
WARNING: zero-occupancy atom:
HETATM 1940  O  AHOH A 354      -0.009  56.525  -3.872  0.25 29.17           O\
""")
  atoms = pdb_in.atoms()
  assert (atoms.size() == 6381)
  occ = atoms.extract_occ()
  assert (occ.count(0.5) == 2126) and (occ.count(0.25) == 4254)
  try :
    run([pdb_file, "atom_selection=\"chain G\""], out=out)
  except Sorry as e :
    assert (str(e) == "Empty selection.")
  else :
    raise Exception_expected
  try :
    run([pdb_file, "new_occ=2"], out=out)
  except Sorry as e :
    assert (str(e) == "new_occ must be between 0 and 1.0")
  else :
    raise Exception_expected
  pdb_file = libtbx.env.find_in_repositories(
    relative_path="phenix_regression/pdb/1akg.pdb",
    test=os.path.isfile)
  try :
    run([pdb_file], out=out)
  except Sorry as e :
    assert (str(e) == """\
Atom group included in selection already has one or more alternate conformers:
ATOM     22  OG ASER     4      -1.752   0.849   3.272  0.50 11.67           O\
""")
  else :
    raise Exception_expected
  run([pdb_file, "atom_selection=\"not name OG\""], out=out)
  print("OK")

if (__name__ == "__main__"):
  exercise()


 *******************************************************************************


 *******************************************************************************
iotbx/regression/tst_all_chain_ids.py
from __future__ import absolute_import, division, print_function
from iotbx.regression.ncs.tst_mtrix_biomt_cmdl import pdb_str_0
import mmtbx.model
import iotbx.pdb

def test_1():
  """
  Chains A,B,C are present in the model. The rest of them are being generated
  by expansion. The problem is that iotbx/pdb/utils.py:all_chain_ids()
  generate chain ids with leading white space for single character ids.
  This results in inconsistent selection behavior demonstrated in this test.

  Many instruments quote chain ID when generate selection strings such as:
  iotbx/pdb/secondary_structure.py
  nqh_flip in mmtbx/validation/clashscore.py

  maybe others

  Therefore they don't work properly when the model is expanded using MTRIX
  and/or BIOMT matrices internally.

  To reproduce nqh_flip problem:
  phenix.fetch_pdb 1qgt
  phenix.molprobity 1qgt.pdb
  """
  # Loading and expanding the model
  inp = iotbx.pdb.input(lines=pdb_str_0, source_info=None)
  model = mmtbx.model.manager(model_input=inp)
  model.expand_with_BIOMT_records()
  h = model.get_hierarchy()
  asc = model.get_atom_selection_cache()
  chain_ids = [chain.id for chain in h.only_model().chains()]
  print (chain_ids)
  # Note leading whitespaces starting with chain D:
  # assert chain_ids == ['A', 'B', 'C', ' D', ' E', ' F', ' G', ' H', ' I', ' J', ' K', ' L', ' M', ' N', ' O', ' P', ' Q', ' R', ' S', ' T', ' U', ' V', ' W', ' X', ' Y', ' Z', ' 0']
  assert chain_ids == ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '0']

  # Set of test cases
  A_selections = ["chain A", "chain 'A'", "chain ' A'"]
  D_selections = ["chain D", "chain 'D'", "chain ' D'"]

  n_atoms_A = []
  for a_sel in A_selections:
    chA = asc.selection(a_sel)
    n_atoms = h.select(chA).atoms_size()
    print("chA:", n_atoms)
    n_atoms_A.append(n_atoms)
  assert n_atoms_A == [44, 44, 0]

  n_atoms_D = []
  for d_sel in D_selections:
    chD = asc.selection(d_sel)
    n_atoms = h.select(chD).atoms_size()
    print("chD:", n_atoms)
    n_atoms_D.append(n_atoms)
  assert n_atoms_D == [44, 44, 0]
  print ("Is intenal expansion consistent?", n_atoms_A == n_atoms_D)
  assert n_atoms_A == n_atoms_D

  # BUT!!!! if we dump the expanded model and re-load it, everyting is consistent.
  expanded_lines = model.model_as_pdb()
  exp_h = iotbx.pdb.input(lines=expanded_lines, source_info=None).construct_hierarchy()

  exp_asc = exp_h.atom_selection_cache()
  # literally copy-paste from above
  n_atoms_A = []
  for a_sel in A_selections:
    chA = exp_asc.selection(a_sel)
    n_atoms = exp_h.select(chA).atoms_size()
    print("exp chA:", n_atoms)
    n_atoms_A.append(n_atoms)
  assert n_atoms_A == [44, 44, 0]

  n_atoms_D = []
  for d_sel in D_selections:
    chD = exp_asc.selection(d_sel)
    n_atoms = exp_h.select(chD).atoms_size()
    print("exp chD:", n_atoms)
    n_atoms_D.append(n_atoms)
  assert n_atoms_D == [44, 44, 0]
  print ("Is reading from pdb consistent?", n_atoms_A == n_atoms_D)
  assert n_atoms_A == n_atoms_D

if (__name__ == "__main__"):
  test_1()


 *******************************************************************************


 *******************************************************************************
iotbx/regression/tst_atom_selections_10k.py
from __future__ import absolute_import, division, print_function

import iotbx.pdb

def tst_1():
  h = iotbx.pdb.input(source_info=None, lines="""\
data_1YJP
#
_cell.entry_id           1YJP
_cell.length_a           21.937
_cell.length_b           4.866
_cell.length_c           23.477
_cell.angle_alpha        90.00
_cell.angle_beta         107.08
_cell.angle_gamma        90.00
_cell.Z_PDB              2
_cell.pdbx_unique_axis   ?
#
_symmetry.entry_id                         1YJP
_symmetry.space_group_name_H-M             'P 1 21 1'
_symmetry.pdbx_full_space_group_name_H-M   ?
_symmetry.cell_setting                     ?
_symmetry.Int_Tables_number                4
_symmetry.space_group_name_Hall            ?
#
_atom_sites.entry_id                    1YJP
_atom_sites.fract_transf_matrix[1][1]   0.045585
_atom_sites.fract_transf_matrix[1][2]   0.000000
_atom_sites.fract_transf_matrix[1][3]   0.014006
_atom_sites.fract_transf_matrix[2][1]   0.000000
_atom_sites.fract_transf_matrix[2][2]   0.205508
_atom_sites.fract_transf_matrix[2][3]   0.000000
_atom_sites.fract_transf_matrix[3][1]   0.000000
_atom_sites.fract_transf_matrix[3][2]   0.000000
_atom_sites.fract_transf_matrix[3][3]   0.044560
_atom_sites.fract_transf_vector[1]      0.00000
_atom_sites.fract_transf_vector[2]      0.00000
_atom_sites.fract_transf_vector[3]      0.00000
#
loop_
_atom_site.group_PDB
_atom_site.id
_atom_site.type_symbol
_atom_site.label_atom_id
_atom_site.label_alt_id
_atom_site.label_comp_id
_atom_site.label_asym_id
_atom_site.label_entity_id
_atom_site.label_seq_id
_atom_site.pdbx_PDB_ins_code
_atom_site.Cartn_x
_atom_site.Cartn_y
_atom_site.Cartn_z
_atom_site.occupancy
_atom_site.B_iso_or_equiv
_atom_site.pdbx_formal_charge
_atom_site.auth_seq_id
_atom_site.auth_comp_id
_atom_site.auth_asym_id
_atom_site.auth_atom_id
_atom_site.pdbx_PDB_model_num
ATOM   1  N N   . GLY A 1 1 ? -9.009  4.612  6.102  1.00 16.77 ? 1  GLY A N   1
ATOM   2  C CA  . GLY A 1 1 ? -9.052  4.207  4.651  1.00 16.57 ? 1  GLY A CA  1
ATOM   3  C C   . GLY A 1 1 ? -8.015  3.140  4.419  1.00 16.16 ? 1  GLY A C   1
ATOM   4  O O   . GLY A 1 1 ? -7.523  2.521  5.381  1.00 16.78 ? 1  GLY A O   1
HETATM 60 O O   . HOH B 2 . ? -6.471  5.227  7.124  1.00 22.62 ? 8  HOH A O   1
HETATM 61 O O   . HOH B 2 . ? 10.431  1.858  3.216  1.00 19.71 ? 9  HOH A O   1
HETATM 62 O O   . HOH B 2 . ? -11.286 1.756  -1.468 1.00 17.08 ? 10 HOH A O   1
HETATM 63 O O   . HOH B 2 . ? 11.808  4.179  9.970  1.00 23.99 ? 10011 HOH A O   1
HETATM 64 O O   . HOH B 2 . ? 13.605  1.327  9.198  1.00 26.17 ? 10012 HOH A O   1
HETATM 65 O O   . HOH B 2 . ? -2.749  3.429  10.024 1.00 39.15 ? 10013 HOH A O   1
HETATM 66 O O   . HOH B 2 . ? -1.500  0.682  10.967 1.00 43.49 ? 10014 HOH A O   1
#    """).construct_hierarchy()

  # for a in h.atoms():
  #   print (a.id_str(), a.parent().parent().resseq,  a.parent().parent().resseq_as_int())

  asc = h.atom_selection_cache()
  # single residues:
  #
  assert list(asc.selection("resseq 10014").iselection()) == [10]
  assert list(asc.selection("resseq A00E").iselection()) == [10]
  # note resid is different:
  assert list(asc.selection("resid 10014").iselection()) == []
  assert list(asc.selection("resid A00E").iselection()) == [10]

  # Range of residues:
  #
  assert list(asc.selection("resseq 10011:10014").iselection()) == [7,8,9,10]
  assert list(asc.selection("resseq 10:10014").iselection()) == [6,7,8,9,10]
  assert list(asc.selection("resseq 10:10012").iselection()) == [6,7,8]
  # With hy36
  assert list(asc.selection("resseq 10011:A00E").iselection()) == [7,8,9,10]
  assert list(asc.selection("resseq 10:A00E").iselection()) == [6,7,8,9,10]

if (__name__ == "__main__"):
  tst_1()


 *******************************************************************************


 *******************************************************************************
iotbx/regression/tst_bioinformatics.py
from __future__ import absolute_import, division, print_function
from iotbx import bioinformatics

import unittest
import sys
from six.moves import zip

residue_basket="ACCDDDEEEE"
sequence1 = "VVKMDGRKHRLILPEAKVQDSGEFECRTEGVSAFFGVTVQDPSGPS"
sequence2 = "LVKFYGRKFVLLFMDQKTFDKYESKLETSGYEKFFIFCMASPISPA"
name1 = "gi|159164330|pdb|2E6P|A"
name2 = "Q8E5Q5_STRA3"
description_tmplt = "Chain %s, Solution Structure Of The Ig-Like Domain"
a3m_text = \
""">101
GSKLKSANDKGLSAAMVVKSFTDQIQLSMEYGDNDSECAAGEFEDAAARDKEFSSQFGSKLKSANDKGLSAAMVVKSFTDQIQLSMEYGDNDSECAAGEFEDAAARDKEFSSQFGSKLKSANDKGLSAAMVVKSFTDQIQLSMEYGDNDSECAAGEFEDAAARDKEFSSQFGSKLKSANDKGLSAAMVVKSFTDQIQLSMEYGDNDSECAAGEFEDAAARDKEFSSQFGSKLKSANDKGLSAAMVVKSFTDQIQLSMEYGDNDSECAAGEFEDAAARDKEFSSQFGSKLKSANDKGLSAAMVVKSFTDQIQLSMEYGDNDSECAAGEFEDAAARDKEFSSQFGSKLKSANDKGLSAAMVVKSFTDQIQLSMEYGDNDSECAAGEFEDAAARDKEFSSQFGSKLKSANDKGLSAAMVVKSFTDQIQLSMEYGDNDSECAAGEFEDAAARDKEFSSQFGSKLKSANDKGLSAAMVVKSFTDQIQLSMEYGDNDSECAAGEFEDAAARDKEFSSQFGSKLKSANDKGLSAAMVVKSFTDQIQLSMEYGDNDSECAAGEFEDAAARDKEFSSQFGSKLKSANDKGLSAAMVVKSFTDQIQLSME
>101
GSKLKSANDKGLSAAMVVKSFTDQIQLSMEYGDNDSECAAGEFEDAAARDKEFSSQFGSKLKSANDKGLSAAMVVKSFTDQIQLSMEYGDNDSECAAGEFEDAAARDKEFSSQFGSKLKSANDKGLSAAMVVKSFTDQIQLSMEYGDNDSECAAGEFEDAAARDKEFSSQFGSKLKSANDKGLSAAMVVKSFTDQIQLSMEYGDNDSECAAGEFEDAAARDKEFSSQFGSKLKSANDKGLSAAMVVKSFTDQIQLSMEYGDNDSECAAGEFEDAAARDKEFSSQFGSKLKSANDKGLSAAMVVKSFTDQIQLSMEYGDNDSECAAGEFEDAAARDKEFSSQFGSKLKSANDKGLSAAMVVKSFTDQIQLSMEYGDNDSECAAGEFEDAAARDKEFSSQFGSKLKSANDKGLSAAMVVKSFTDQIQLSMEYGDNDSECAAGEFEDAAARDKEFSSQFGSKLKSANDKGLSAAMVVKSFTDQIQLSMEYGDNDSECAAGEFEDAAARDKEFSSQFGSKLKSANDKGLSAAMVVKSFTDQIQLSMEYGDNDSECAAGEFEDAAARDKEFSSQFGSKLKSANDKGLSAAMVVKSFTDQIQLSME
>547|Ga0247610_10220222_2|-972|01 87 0.781 2.428E-13 15 68 600 55 105 328
---------------MGVK-FTDsQIQHLMEYGDND--WSDAEFEDAAARDKEFSSQF-SKLKSANDKGL---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

"""

class test_sequence(unittest.TestCase):

  def testEquality(self):

    seq1 = bioinformatics.sequence(
      sequence = sequence1,
      name = name1
      )

    seq2 = bioinformatics.sequence(
      sequence = sequence1,
      name = name2
      )

    fasta1 = bioinformatics.fasta_sequence(
      sequence = sequence1,
      name = name2,
      description = description_tmplt % "A"
      )

    fasta2 = bioinformatics.fasta_sequence(
      sequence = sequence1,
      name = name2,
      description = description_tmplt % "B"
      )

    pir1 = bioinformatics.pir_sequence(
      sequence = sequence1,
      name = name2,
      type = "P1",
      description = description_tmplt % "C"
      )

    self.assertEqual( seq1, seq2 )
    self.assertEqual( seq1, fasta1 )
    self.assertEqual( seq1, fasta2 )
    self.assertEqual( seq1, pir1 )

    self.assertEqual( seq2, fasta1 )
    self.assertEqual( seq2, fasta2 )
    self.assertEqual( seq2, pir1 )

    self.assertEqual( fasta1, fasta2 )
    self.assertEqual( fasta1, pir1 )

    self.assertEqual( fasta2, pir1 )


  def testNonEquality(self):

    seq1 = bioinformatics.sequence(
      sequence = sequence1,
      name = name1
      )

    seq2 = bioinformatics.sequence(
      sequence = sequence2,
      name = name1
      )

    seq3 = bioinformatics.sequence(
      sequence = sequence1 + "A",
      name = name1
      )

    fasta1 = bioinformatics.fasta_sequence(
      sequence = sequence2,
      name = name1,
      description = description_tmplt % "A"
      )

    pir1 = bioinformatics.pir_sequence(
      sequence = sequence2,
      name = name1,
      type = "P1",
      description = description_tmplt % "A"
      )

    self.assertTrue( seq1 != seq2 )
    self.assertTrue( seq1 != seq3 )
    self.assertTrue( seq1 != fasta1 )
    self.assertTrue( seq1 != pir1 )


class test_fasta_sequence(unittest.TestCase):

  def setUp(self):

    self.short = bioinformatics.fasta_sequence(
      sequence = sequence1,
      name = name1,
      description = description_tmplt % "A"
      )
    self.long = bioinformatics.fasta_sequence(
      sequence = sequence1 * 4,
      name = name1,
      description = description_tmplt % "A"
      )


  def testFormat(self):

    self.assertEqual(
      self.short.format( 70 ),
      ">gi|159164330|pdb|2E6P|A Chain A, Solution Structure Of The Ig-Like Do\n"
      + "VVKMDGRKHRLILPEAKVQDSGEFECRTEGVSAFFGVTVQDPSGPS"
      )

    self.assertEqual(
      self.short.format( 20 ),
      ">gi|159164330|pdb|2E\n"
      + "VVKMDGRKHRLILPEAKVQD\n"
      + "SGEFECRTEGVSAFFGVTVQ\n"
      + "DPSGPS"
      )


  def testStr(self):

    self.assertEqual(
      str( self.short ),
      ">gi|159164330|pdb|2E6P|A Chain A, Solution Structure Of The Ig-Like Do\n"
      + "VVKMDGRKHRLILPEAKVQDSGEFECRTEGVSAFFGVTVQDPSGPS"
      )

    self.assertEqual(
      str( self.long ),
      ">gi|159164330|pdb|2E6P|A Chain A, Solution Structure Of The Ig-Like Do\n"
      + "VVKMDGRKHRLILPEAKVQDSGEFECRTEGVSAFFGVTVQDPSGPSVVKMDGRKHRLILPEAKVQDSGEF\n"
      + "ECRTEGVSAFFGVTVQDPSGPSVVKMDGRKHRLILPEAKVQDSGEFECRTEGVSAFFGVTVQDPSGPSVV\n"
      + "KMDGRKHRLILPEAKVQDSGEFECRTEGVSAFFGVTVQDPSGPS"
      )


class test_pir_sequence(unittest.TestCase):

  def setUp(self):

    self.short = bioinformatics.pir_sequence(
      sequence = sequence1,
      name = name1,
      type = "P1",
      description = description_tmplt % "A"
      )
    self.long = bioinformatics.pir_sequence(
      sequence = sequence1 * 4,
      name = name1,
      type = "P1",
      description = description_tmplt % "A"
      )


  def testFormat(self):

    self.assertEqual(
      self.short.format( 70 ),
      ">P1;gi|159164330|pdb|2E6P|A\n"
      + "Chain A, Solution Structure Of The Ig-Like Domain\n"
      + "  VVKMDGRKHRLILPEAKVQDSGEFECRTEGVSAFFGVTVQDPSGPS*"
      )

    self.assertEqual(
      self.short.format( 20 ),
      ">P1;gi|159164330|pdb\n"
      + "Chain A, Solution St\n"
      + "  VVKMDGRKHRLILPEAKV\n"
      + "  QDSGEFECRTEGVSAFFG\n"
                + "  VTVQDPSGPS*"
      )


  def testStr(self):

    self.assertEqual(
      str( self.short ),
      ">P1;gi|159164330|pdb|2E6P|A\n"
      + "Chain A, Solution Structure Of The Ig-Like Domain\n"
      + "  VVKMDGRKHRLILPEAKVQDSGEFECRTEGVSAFFGVTVQDPSGPS*"
      )

    self.assertEqual(
      str( self.long ),
      ">P1;gi|159164330|pdb|2E6P|A\n"
      + "Chain A, Solution Structure Of The Ig-Like Domain\n"
      + "  VVKMDGRKHRLILPEAKVQDSGEFECRTEGVSAFFGVTVQDPSGPSVVKMDGRKHRLILPEAKVQDSG\n"
      + "  EFECRTEGVSAFFGVTVQDPSGPSVVKMDGRKHRLILPEAKVQDSGEFECRTEGVSAFFGVTVQDPSG\n"
      + "  PSVVKMDGRKHRLILPEAKVQDSGEFECRTEGVSAFFGVTVQDPSGPS*"
      )


class test_midline(unittest.TestCase):

  def setUp(self):

    self.midline = bioinformatics.midline( identical = "#" )


  def testConservationCode(self):

    self.assertEqual(
      self.midline.conservation_code( [ "A", "A", "A", "A" ] ),
      self.midline.identical
      )
    self.assertEqual(
      self.midline.conservation_code( [ "A", "A", "A", "B" ] ),
      self.midline.differ
      )


  def testMidline(self):

    self.assertEqual(
      self.midline.compare( [ "ABCD-EFGH", "ABD--EKGH" ] ),
      "##   # ##"
      )
    self.assertEqual(
      self.midline.compare( [] ),
      ""
      )

ali_1hml = "-KQFTKCELSQLLK--DIDGYGGIALPELICTMFHTSGYDTQAIVENN--ESTEYGLFQISNKLWCKSSQVPQSR"
ali_1hfy = "-EQLTKCEVFQKLK--DLKDYGGVSLPEWVCTAFHTSGYDTQAIVQNN--DSTEYGLFQINNKIWCKDDQNPHSR"
ali_1ghl = "GKVYGRCELAAAMKRMGLDNYRGYSLGNWVCAAKFESNFNTGATNRNT-DGSTDYGILQINSRWWCNDGRTPGSK"
ali_1lz3 = "-KVYGRCELAAAMKRLGLDNYRGYSLGNWVCAAKFESNFDTHATNRNT-DGSTDYGILQINSRWWCNDGRTPGSK"
ali_empt = "---------------------------------------------------------------------------"


class test_alignment(unittest.TestCase):

  def setUp(self):

    self.alignment1 = bioinformatics.alignment(
      alignments = [ ali_1hml, ali_1hfy ],
      names = [ "1hml", "1hfy" ]
      )
    self.alignment2 = bioinformatics.alignment(
      alignments = [ ali_1hml, ali_1hfy, ali_1ghl, ali_1lz3 ],
      names = [ "1hml", "1hfya", "1ghla", "1lz3" ]
      )
    self.alignment3 = bioinformatics.alignment(
      alignments = [],
      names = []
      )
    self.alignment4 = bioinformatics.alignment(
      alignments = [ ali_1hfy, ali_1ghl, ali_empt ],
      names = [ "1hfya", "1ghla", "empty" ]
      )


  def test_error(self):

    self.assertRaises(
      ValueError,
      bioinformatics.alignment,
      [ ali_1hml, ali_1hml + "A" ],
      [ "1hml", "1hfy" ]
      )
    self.assertRaises(
      ValueError,
      bioinformatics.alignment,
      [ ali_1hml, ali_1hml ],
      [ "1hml", "1hfy", "1ghla" ]
      )


  def test_identity_count(self):

    self.assertEqual( self.alignment1.identity_count(), 49 )
    self.assertEqual( self.alignment2.identity_count(), 21 )
    self.assertEqual( self.alignment3.identity_count(), 0 )
    self.assertEqual( self.alignment4.identity_count(), 0 )


  def test_identity_fraction(self):

    self.assertAlmostEqual( self.alignment1.identity_fraction(), 0.700, 3 )
    self.assertAlmostEqual( self.alignment2.identity_fraction(), 0.300, 3 )
    self.assertAlmostEqual( self.alignment3.identity_fraction(), 1.000, 3 )
    self.assertAlmostEqual( self.alignment4.identity_fraction(), 1.000, 3 )


  def test_multiplicity(self):

    self.assertEqual( self.alignment1.multiplicity(), 2 )
    self.assertEqual( self.alignment2.multiplicity(), 4 )
    self.assertEqual( self.alignment3.multiplicity(), 0 )
    self.assertEqual( self.alignment4.multiplicity(), 3 )


  def test_length(self):

    self.assertEqual( self.alignment1.length(), 75 )
    self.assertEqual( self.alignment2.length(), 75 )
    self.assertEqual( self.alignment3.length(), 0 )
    self.assertEqual( self.alignment4.length(), 75 )


  def test_copy(self):

    c = self.alignment1.copy(
      alignments = [ "AB", "BA" ],
      names = [ "XY", "YX" ],
      gap = "#"
      )

    self.assertTrue( c is not self.alignment1 )
    self.assertEqual( c.alignments, [ "AB", "BA" ] )
    self.assertEqual( c.names, [ "XY", "YX" ] )
    self.assertEqual( c.gap, "#" )


  def test__str__(self):
    self.assertEqual(
      str( self.alignment1 ),
      ">1hml\n"
      + "-KQFTKCELSQLLK--DIDGYGGIALPELICTMFHTSGYDTQAIVENN--ESTEYGLFQISNKLWCKSSQ\n"
      + "VPQSR\n\n"
      + ">1hfy\n"
      + "-EQLTKCEVFQKLK--DLKDYGGVSLPEWVCTAFHTSGYDTQAIVQNN--DSTEYGLFQINNKIWCKDDQ\n"
      + "NPHSR"
      )

  def test_extend(self):

    sequences = [
      "ABKQFTKCELSQLLKDIDGYGGIALPELICTMFHTSGYDTQAIVENNESTEYGLFQISNKLWCKSSQVPQSRNOPQR",
      "CDEEQLTKCEVFQKLKDLKDYGGVSLPEWVCTAFHTSGYDTQAIVQNNDSTEYGLFQINNKIWCKDDQNPHSRSTUV",
      "FGHIGKVYGRCELAAAMKRMGLDNYRGYSLGNWVCAAKFESNFNTGATNRNTDGSTDYGILQINSRWWCNDGRTPGSKXYZ",
      "JKILMKVYGRCELAAAMKRLGLDNYRGYSLGNWVCAAKFESNFDTHATNRNTDGSTDYGILQINSRWWCNDGRTPGSKAB",
      ]
    ali = self.alignment2.copy()
    ali.extend( sequences = sequences )
    self.assertEqual( ali.names, self.alignment2.names )
    self.assertEqual( ali.gap, self.alignment2.gap )
    self.assertEqual(
      ali.alignments,
      [
        "AB------------" + self.alignment2.alignments[0] + "NOPQR---------",
        "--CDE---------" + self.alignment2.alignments[1] + "-----STUV-----",
        "-----FGHI-----" + self.alignment2.alignments[2] + "---------XYZ--",
        "---------JKILM" + self.alignment2.alignments[3] + "------------AB",
        ]
      )


class test_fasta_alignment(unittest.TestCase):

  def setUp(self):

    self.alignment = bioinformatics.fasta_alignment(
      alignments = [ ali_1hml, ali_1hfy, ali_1ghl, ali_1lz3 ],
      names = [ "1hml", "1hfya", "1ghla", "1lz3" ],
      descriptions = [
        "alpha lactalbumin:Homo sapiens",
        "alpha-lactalbumin:Capra hircus",
        "lysozyme:Phasianus colchicus",
        "lysozyme:Meleagris gallopavo",
        ]
      )

  def test_error(self):

    self.assertRaises(
      ValueError,
      bioinformatics.fasta_alignment,
      [ ali_1hml, ali_1hml ],
      [ "1hml", "1hfy" ],
      [
        "alpha lactalbumin:Homo sapiens",
        "alpha-lactalbumin:Capra hircus",
        "lysozyme:Phasianus colchicus",
        ]
      )


  def test_format(self):

    self.assertEqual(
      self.alignment.format( 40 ),
      ">1hml alpha lactalbumin:Homo sapiens\n"
      + "-KQFTKCELSQLLK--DIDGYGGIALPELICTMFHTSGYD\n"
      + "TQAIVENN--ESTEYGLFQISNKLWCKSSQVPQSR\n\n"
      + ">1hfya alpha-lactalbumin:Capra hircus\n"
      + "-EQLTKCEVFQKLK--DLKDYGGVSLPEWVCTAFHTSGYD\n"
      + "TQAIVQNN--DSTEYGLFQINNKIWCKDDQNPHSR\n\n"
      + ">1ghla lysozyme:Phasianus colchicus\n"
      + "GKVYGRCELAAAMKRMGLDNYRGYSLGNWVCAAKFESNFN\n"
      + "TGATNRNT-DGSTDYGILQINSRWWCNDGRTPGSK\n\n"
      + ">1lz3 lysozyme:Meleagris gallopavo\n"
      + "-KVYGRCELAAAMKRLGLDNYRGYSLGNWVCAAKFESNFD\n"
      + "THATNRNT-DGSTDYGILQINSRWWCNDGRTPGSK"
      )


  def test__str__(self):
    self.assertEqual(
      str( self.alignment ),
      ">1hml alpha lactalbumin:Homo sapiens\n"
      + "-KQFTKCELSQLLK--DIDGYGGIALPELICTMFHTSGYDTQAIVENN--ESTEYGLFQISNKLWCKSSQ\n"
      + "VPQSR\n\n"
      + ">1hfya alpha-lactalbumin:Capra hircus\n"
      + "-EQLTKCEVFQKLK--DLKDYGGVSLPEWVCTAFHTSGYDTQAIVQNN--DSTEYGLFQINNKIWCKDDQ\n"
      + "NPHSR\n\n"
      + ">1ghla lysozyme:Phasianus colchicus\n"
      + "GKVYGRCELAAAMKRMGLDNYRGYSLGNWVCAAKFESNFNTGATNRNT-DGSTDYGILQINSRWWCNDGR\n"
      + "TPGSK\n\n"
      + ">1lz3 lysozyme:Meleagris gallopavo\n"
      + "-KVYGRCELAAAMKRLGLDNYRGYSLGNWVCAAKFESNFDTHATNRNT-DGSTDYGILQINSRWWCNDGR\n"
      + "TPGSK"
      )


  def test_copy(self):

    c = self.alignment.copy( descriptions = [ "A", "B", "C", "D" ] )
    self.assertEqual( c.descriptions, [ "A", "B", "C", "D" ] )
    self.assertEqual( c.alignments, self.alignment.alignments )
    self.assertEqual( c.names, self.alignment.names )
    self.assertEqual( c.gap, self.alignment.gap )


class test_pir_alignment(unittest.TestCase):

  def setUp(self):

    self.alignment = bioinformatics.pir_alignment(
      alignments = [ ali_1hml, ali_1hfy, ali_1ghl, ali_1lz3 ],
      names = [ "1hml", "1hfya", "1ghla", "1lz3" ],
      types = [ "P1" ] * 4,
      descriptions = [
        "alpha lactalbumin:Homo sapiens",
        "alpha-lactalbumin:Capra hircus",
        "lysozyme:Phasianus colchicus",
        "lysozyme:Meleagris gallopavo",
        ]
      )

  def test_error(self):

    self.assertRaises(
      ValueError,
      bioinformatics.pir_alignment,
      [ ali_1hml, ali_1hml ],
      [ "1hml", "1hfy" ],
      [ "P1", "P1", "P1" ],
      [
        "alpha lactalbumin:Homo sapiens",
        "alpha-lactalbumin:Capra hircus",
        ]
      )
    self.assertRaises(
      ValueError,
      bioinformatics.pir_alignment,
      [ ali_1hml, ali_1hml ],
      [ "1hml", "1hfy" ],
      [ "P1", "P1" ],
      [
        "alpha lactalbumin:Homo sapiens",
        "alpha-lactalbumin:Capra hircus",
        "lysozyme:Phasianus colchicus",
        ]
      )


  def test_format(self):

    self.assertEqual(
      self.alignment.format( 40 ),
      ">P1;1hml\nalpha lactalbumin:Homo sapiens\n"
      + "  -KQFTKCELSQLLK--DIDGYGGIALPELICTMFHTSG\n"
      + "  YDTQAIVENN--ESTEYGLFQISNKLWCKSSQVPQSR*\n\n"
      + ">P1;1hfya\nalpha-lactalbumin:Capra hircus\n"
      + "  -EQLTKCEVFQKLK--DLKDYGGVSLPEWVCTAFHTSG\n"
      + "  YDTQAIVQNN--DSTEYGLFQINNKIWCKDDQNPHSR*\n\n"
      + ">P1;1ghla\nlysozyme:Phasianus colchicus\n"
      + "  GKVYGRCELAAAMKRMGLDNYRGYSLGNWVCAAKFESN\n"
      + "  FNTGATNRNT-DGSTDYGILQINSRWWCNDGRTPGSK*\n\n"
      + ">P1;1lz3\nlysozyme:Meleagris gallopavo\n"
      + "  -KVYGRCELAAAMKRLGLDNYRGYSLGNWVCAAKFESN\n"
      + "  FDTHATNRNT-DGSTDYGILQINSRWWCNDGRTPGSK*"
      )


  def test__str__(self):
    self.assertEqual(
      str( self.alignment ),
      ">P1;1hml\nalpha lactalbumin:Homo sapiens\n"
      + "  -KQFTKCELSQLLK--DIDGYGGIALPELICTMFHTSGYDTQAIVENN--ESTEYGLFQISNKLWCKS\n"
      + "  SQVPQSR*\n\n"
      + ">P1;1hfya\nalpha-lactalbumin:Capra hircus\n"
      + "  -EQLTKCEVFQKLK--DLKDYGGVSLPEWVCTAFHTSGYDTQAIVQNN--DSTEYGLFQINNKIWCKD\n"
      + "  DQNPHSR*\n\n"
      + ">P1;1ghla\nlysozyme:Phasianus colchicus\n"
      + "  GKVYGRCELAAAMKRMGLDNYRGYSLGNWVCAAKFESNFNTGATNRNT-DGSTDYGILQINSRWWCND\n"
      + "  GRTPGSK*\n\n"
      + ">P1;1lz3\nlysozyme:Meleagris gallopavo\n"
      + "  -KVYGRCELAAAMKRLGLDNYRGYSLGNWVCAAKFESNFDTHATNRNT-DGSTDYGILQINSRWWCND\n"
      + "  GRTPGSK*"
      )

  def test_copy(self):

    c = self.alignment.copy(
      descriptions = [ "A", "B", "C", "D" ],
      types = [ "P1", "P2", "P3", "P4" ]
      )
    self.assertEqual( c.descriptions, [ "A", "B", "C", "D" ] )
    self.assertEqual( c.types, [ "P1", "P2", "P3", "P4" ] )
    self.assertEqual( c.alignments, self.alignment.alignments )
    self.assertEqual( c.names, self.alignment.names )
    self.assertEqual( c.gap, self.alignment.gap )


class test_clustal_alignment(unittest.TestCase):

  def setUp(self):

    self.alignment = bioinformatics.clustal_alignment(
      alignments = [ ali_1hml, ali_1hfy, ali_1ghl, ali_1lz3 ],
      names = [ "1hml", "1hfya", "1ghla", "1lz3" ],
      program = "CLUSTAL X 1.35"
      )

  def test_format(self):

    self.assertEqual(
      self.alignment.format( 40, 10 ),
      "CLUSTAL X 1.35 multiple sequence alignment\n\n"
      + "1hml       -KQFTKCELSQLLK--DIDGYGGIALPELICTMFHTSGYD 37\n"
      + "1hfya      -EQLTKCEVFQKLK--DLKDYGGVSLPEWVCTAFHTSGYD 37\n"
      + "1ghla      GKVYGRCELAAAMKRMGLDNYRGYSLGNWVCAAKFESNFN 40\n"
      + "1lz3       -KVYGRCELAAAMKRLGLDNYRGYSLGNWVCAAKFESNFD 39\n"
      + "                 **     *      * *  *    *     *   \n\n"
      + "1hml       TQAIVENN--ESTEYGLFQISNKLWCKSSQVPQSR 70\n"
      + "1hfya      TQAIVQNN--DSTEYGLFQINNKIWCKDDQNPHSR 70\n"
      + "1ghla      TGATNRNT-DGSTDYGILQINSRWWCNDGRTPGSK 74\n"
      + "1lz3       THATNRNT-DGSTDYGILQINSRWWCNDGRTPGSK 73\n"
      + "           * *   *    ** **  **    **     * * "
      )


  def test__str__(self):

    self.assertEqual(
      str( self.alignment ),
      "CLUSTAL X 1.35 multiple sequence alignment\n\n"
      + "1hml            -KQFTKCELSQLLK--DIDGYGGIALPELICTMFHTSGYDTQAIVENN--ESTEYGLFQI 55\n"
      + "1hfya           -EQLTKCEVFQKLK--DLKDYGGVSLPEWVCTAFHTSGYDTQAIVQNN--DSTEYGLFQI 55\n"
      + "1ghla           GKVYGRCELAAAMKRMGLDNYRGYSLGNWVCAAKFESNFNTGATNRNT-DGSTDYGILQI 59\n"
      + "1lz3            -KVYGRCELAAAMKRLGLDNYRGYSLGNWVCAAKFESNFDTHATNRNT-DGSTDYGILQI 58\n"
      + "                      **     *      * *  *    *     *   * *   *    ** **  **\n\n"
      + "1hml            SNKLWCKSSQVPQSR 70\n"
      + "1hfya           NNKIWCKDDQNPHSR 70\n"
      + "1ghla           NSRWWCNDGRTPGSK 74\n"
      + "1lz3            NSRWWCNDGRTPGSK 73\n"
      + "                    **     * * "
      )

  def test_copy(self):

    c = self.alignment.copy( program = "Foo" )
    self.assertEqual( c.program, "Foo" )
    self.assertEqual( c.alignments, self.alignment.alignments )
    self.assertEqual( c.names, self.alignment.names )
    self.assertEqual( c.gap, self.alignment.gap )


seq = """
Error
>chain_A
 TPDCVTGKVE YTKYNDDDTF TVKVGDKELF TNRWNLQSLL LSAQITGMTV TIKTNACHNG
 GGFSEVIFR
> chain A
 TPDCVTGKVE YTKYNDDDTF TVKVGDKELF TNRWNLQSLL LSAQITGMTV TIKTNACHNG
 GGFSEVIFR

> chain_A
 TPDCVTGKVE YTKYNDDDTF TVKVGDKELF TNRWNLQSLL LSAQITGMTV TIKTNACHNG
 GGFSEVIFR*

>
 TPDCVTGKVE YTKYNDDDTF TVKVGDKELF TNRWNLQSLL LSAQITGMTV TIKTNACHNG
 GGFSEVIFR
>chain_A"""

seq_sequence = "TPDCVTGKVEYTKYNDDDTFTVKVGDKELFTNRWNLQSLLLSAQITGMTVTIKTNACHNGGGFSEVIFR"

fasta = """
Error
>FOSB_MOUSE Protein fosB. 338 bp
     MFQAFPGDYDSGSRCSSSPSAESQYLSSVDSFGSPPTAAASQECAGLGEMPGSFVPTVTA
     ITTSQDLQWLVQPTLISSMAQSQGQPLASQPPAVDPYDMPGTSYSTPGLSAYSTGGASGS
     GGPSTSTTTSGPVSARPARARPRRPREETLTPEEEEKRRVRRERNKLAAAKCRNRRRELT
     DRLQAETDQLEEEKAELESEIAELQKEKERLEFVLVAHKPGCKIPYEEGPGPGPLAEVRD
     LPGSTSAKEDGFGWLLPPPPPPPLPFQSSRDAPPNLTASLFTHSEVQVLGDPFPVVSPSY
     TSSFVLTCPEVSAFAGAQRTSGSEQPSDPLNSPSLLAL

> FOSB_MOUSE Protein fosB. 338 bp
     MFQAFPGDYDSGSRCSSSPSAESQYLSSVDSFGSPPTAAASQECAGLGEMPGSFVPTVTA
     ITTSQDLQWLVQPTLISSMAQSQGQPLASQPPAVDPYDMPGTSYSTPGLSAYSTGGASGS
     GGPSTSTTTSGPVSARPARARPRRPREETLTPEEEEKRRVRRERNKLAAAKCRNRRRELT
     DRLQAETDQLEEEKAELESEIAELQKEKERLEFVLVAHKPGCKIPYEEGPGPGPLAEVRD
     LPGSTSAKEDGFGWLLPPPPPPPLPFQSSRDAPPNLTASLFTHSEVQVLGDPFPVVSPSY
     TSSFVLTCPEVSAFAGAQRTSGSEQPSDPLNSPSLLAL
> 1YJP:A|PDBID|CHAIN|SEQUENCE

     MFQAFPGDYDSGSRCSSSPSAESQYLSSVDSFGSPPTAAASQECAGLGEMPGSFVPTVTA
     ITTSQDLQWLVQPTLISSMAQSQGQPLASQPPAVDPYDMPGTSYSTPGLSAYSTGGASGS
     GGPSTSTTTSGPVSARPARARPRRPREETLTPEEEEKRRVRRERNKLAAAKCRNRRRELT
     DRLQAETDQLEEEKAELESEIAELQKEKERLEFVLVAHKPGCKIPYEEGPGPGPLAEVRD
     LPGSTSAKEDGFGWLLPPPPPPPLPFQSSRDAPPNLTASLFTHSEVQVLGDPFPVVSPSY
     TSSFVLTCPEVSAFAGAQRTSGSEQPSDPLNSPSLLAL


"""

fasta_sequence = (
    "MFQAFPGDYDSGSRCSSSPSAESQYLSSVDSFGSPPTAAASQECAGLGEMPGSFVPTVTA"
    + "ITTSQDLQWLVQPTLISSMAQSQGQPLASQPPAVDPYDMPGTSYSTPGLSAYSTGGASGS"
    + "GGPSTSTTTSGPVSARPARARPRRPREETLTPEEEEKRRVRRERNKLAAAKCRNRRRELT"
    + "DRLQAETDQLEEEKAELESEIAELQKEKERLEFVLVAHKPGCKIPYEEGPGPGPLAEVRD"
    + "LPGSTSAKEDGFGWLLPPPPPPPLPFQSSRDAPPNLTASLFTHSEVQVLGDPFPVVSPSY"
    + "TSSFVLTCPEVSAFAGAQRTSGSEQPSDPLNSPSLLAL"
    )

pir = """
Error
>P1;CRAB_ANAPL
ALPHA CRYSTALLIN B CHAIN (ALPHA(B)-CRYSTALLIN).
  MDITIHNPLI RRPLFSWLAP SRIFDQIFGE HLQESELLPA SPSLSPFLMR
  SPIFRMPSWL ETGLSEMRLE KDKFSVNLDV KHFSPEELKV KVLGDMVEIH
  GKHEERQDEH GFIAREFNRK YRIPADVDPL TITSSLSLDG VLTVSAPRKQ
  SDVPERSIPI TREEKPAIAG AQRK*

>P1;CRAB_ANAPL

  MDITIHNPLI RRPLFSWLAP SRIFDQIFGE HLQESELLPA SPSLSPFLMR
  SPIFRMPSWL ETGLSEMRLE KDKFSVNLDV KHFSPEELKV KVLGDMVEIH
  GKHEERQDEH GFIAREFNRK YRIPADVDPL TITSSLSLDG VLTVSAPRKQ
  SDVPERSIPI TREEKPAIAG AQRK*

>P1;CRAB_ANAPL
ALPHA CRYSTALLIN B CHAIN (ALPHA(B)-CRYSTALLIN).
  MDITIHNPLI RRPLFSWLAP SRIFDQIFGE HLQESELLPA SPSLSPFLMR
  SPIFRMPSWL ETGLSEMRLE KDKFSVNLDV KHFSPEELKV KVLGDMVEIH
  GKHEERQDEH GFIAREFNRK YRIPADVDPL TITSSLSLDG VLTVSAPRKQ
  SDVPERSIPI TREEKPAIAG AQRK

> P1;CRAB_ANAPL
ALPHA CRYSTALLIN B CHAIN (ALPHA(B)-CRYSTALLIN).
  MDITIHNPLI RRPLFSWLAP SRIFDQIFGE HLQESELLPA SPSLSPFLMR
  SPIFRMPSWL ETGLSEMRLE KDKFSVNLDV KHFSPEELKV KVLGDMVEIH
  GKHEERQDEH GFIAREFNRK YRIPADVDPL TITSSLSLDG VLTVSAPRKQ
  SDVPERSIPI TREEKPAIAG AQRK*

>P11;CRAB_ANAPL
ALPHA CRYSTALLIN B CHAIN (ALPHA(B)-CRYSTALLIN).
  MDITIHNPLI RRPLFSWLAP SRIFDQIFGE HLQESELLPA SPSLSPFLMR
  SPIFRMPSWL ETGLSEMRLE KDKFSVNLDV KHFSPEELKV KVLGDMVEIH
  GKHEERQDEH GFIAREFNRK YRIPADVDPL TITSSLSLDG VLTVSAPRKQ
  SDVPERSIPI TREEKPAIAG AQRK*

>P1;CRAB_ ANAPL
ALPHA CRYSTALLIN B CHAIN (ALPHA(B)-CRYSTALLIN).
  MDITIHNPLI RRPLFSWLAP SRIFDQIFGE HLQESELLPA SPSLSPFLMR
  SPIFRMPSWL ETGLSEMRLE KDKFSVNLDV KHFSPEELKV KVLGDMVEIH
  GKHEERQDEH GFIAREFNRK YRIPADVDPL TITSSLSLDG VLTVSAPRKQ
  SDVPERSIPI TREEKPAIAG AQRK*

"""

tolerant_pir = """
Error
>P1;CRAB_ANAPL
ALPHA CRYSTALLIN B CHAIN (ALPHA(B)-CRYSTALLIN).
  MDITIHNPLI RRPLFSWLAP SRIFDQIFGE HLQESELLPA SPSLSPFLMR
  SPIFRMPSWL ETGLSEMRLE KDKFSVNLDV KHFSPEELKV KVLGDMVEIH
  GKHEERQDEH GFIAREFNRK YRIPADVDPL TITSSLSLDG VLTVSAPRKQ
  SDVPERSIPI TREEKPAIAG AQRK*

Error2

>CRAB_ANAPL
ALPHA CRYSTALLIN B CHAIN (ALPHA(B)-CRYSTALLIN).
  MDITIHNPLI RRPLFSWLAP SRIFDQIFGE HLQESELLPA SPSLSPFLMR
  SPIFRMPSWL ETGLSEMRLE KDKFSVNLDV KHFSPEELKV KVLGDMVEIH
  GKHEERQDEH GFIAREFNRK YRIPADVDPL TITSSLSLDG VLTVSAPRKQ
  SDVPERSIPI TREEKPAIAG AQRK*

>CRAB_ANAPL

  MDITIHNPLI RRPLFSWLAP SRIFDQIFGE HLQESELLPA SPSLSPFLMR
  SPIFRMPSWL ETGLSEMRLE KDKFSVNLDV KHFSPEELKV KVLGDMVEIH
  GKHEERQDEH GFIAREFNRK YRIPADVDPL TITSSLSLDG VLTVSAPRKQ
  SDVPERSIPI TREEKPAIAG AQRK
"""

tf = """
> anb.pdb
AAKDVKFGVNVLADAVKVTLGPKGRNVVLDKSFGAPTITKDGVSVAREIELEDKFENMGAQMVKEVASKANDAAGDGTT
TATVLAQAIITEGLKAVAAGMNPMDLKRGIDKAVTAAVEELKALSVPCSDSKAIAQVGTISANSDETVGKLIAEAMDKV
GKEGVITVEDGTGLQDELDVVEGMQFDRGYLSPYFINKPETGAVELESPFILLADKKISNIREMLPVLEAVAKAGKPLL
IIAEDVEGEALATLVVNTMRGIVKVAAVKAPGFGDRRKAMLQDIATLTGGTVISEEIGMELEKATLEDLGQAKRVVINK
DTTTIIDGVGEEAAIQGRVAQIRQQIEEATSDYDREKLQERVAKLAGGVAVIKVGAATEVEMKEKKARVEDALHATRAA
VEEGVVAGGGVALIRVASKLADLRGQNEDQNVGIKVALRAMEAPLRQIVLNCGEEPSVVANTVKGGDGNYGYNAATEEY
GNMIDMGILDPTKVTRSALQYAASVAGLMITTECMVTDLP

AAKDVKFGNDARVKMLRGVNVLADAVKVTLGPKGRNVVLDKSFGAPTITKDGVSVAREIELEDKFENMGAQMVKEVASK
ANDAAGDGTTTATVLAQAIITEGLKAVAAGMNPMDLKRGIDKAVTAAVEELKALSVPCSDSKAIAQVGTISANSDETVG
KLIAEAMDKVGKEGVITVEDGTGLQDELDVVEGMQFDRGYLSPYFINKPETGAVELESPFILLADKKISNIREMLPVLE
AVAKAGKPLLIIAEDVEGEALQDIATLTGGTVISEEIGMELEKATLEDLGQAKRVVINKDTTTIIDGVGEEAAIQGRVA
QIRQQIEEATSDYDREKLQERVAKLAGGVAVIKVGAATEVEMKEKKARVEDALHATRAAVEEGVVAGGGVALIRVASKL
ADLRGQNEDQNVGIKVALRAMEAPLRQIVLNCGEEPSVVANTVKGGDGNYGYNAATEEYGNMIDMGILDPTKVTRSALQ
YAASVAGLMITTECMVTDLP

AAKDVKFGNDARVKMLRGVNVLADAVKVTLGPKGRNVVLDKSFGAPTITKDGVSVAREIELEDKFENMGAQMVKEVAST
ATVLAQAIITEGLKAVAAGMNPMDLKRGIDKAVTAAVEELKALSVPCSDSKAIAQVGTISANSDETVGKLIAEAMDKVG
KEGVITVEDGTGLQDELDVVEGMQFDRGYLSPYFINKPETGAVELESPFILLADKKISNIREMLPVLEAVAKAGKPLLI
IAEDVEGEALATLVVNTMRGIVKVAAVKAPGFGDRRKAMLQDIATLTGGTVISEEIGMELEKATLEDLGQAKRVVINKD
TTTIIDGVGEEAAIQGRVAQIRQQIEEATSDYDREKLQERVAKLAGGVAVIKVGAATEVEMKEKKARVEDALHATRAAV
EEGVVAGGGVALIRVASKLADLRGQNEDQNVGIKVALRAMEAPLRQIVLNCGKGGDGNYGYNAATEEYGNMIDMGILDP
TKVTRSALQYAASVAGLMITTECMVTDLP

"""

lineseparated = """
AAKDVKFGVNVLADAVKVTLGPKGRNVVLDKSFGAPTITKDGVSVAREIELEDKFENMGAQMVKEVASKANDAAGDGTT
TATVLAQAIITEGLKAVAAGMNPMDLKRGIDKAVTAAVEELKALSVPCSDSKAIAQVGTISANSDETVGKLIAEAMDKV
GKEGVITVEDGTGLQDELDVVEGMQFDRGYLSPYFINKPETGAVELESPFILLADKKISNIREMLPVLEAVAKAGKPLL
IIAEDVEGEALATLVVNTMRGIVKVAAVKAPGFGDRRKAMLQDIATLTGGTVISEEIGMELEKATLEDLGQAKRVVINK
DTTTIIDGVGEEAAIQGRVAQIRQQIEEATSDYDREKLQERVAKLAGGVAVIKVGAATEVEMKEKKARVEDALHATRAA
VEEGVVAGGGVALIRVASKLADLRGQNEDQNVGIKVALRAMEAPLRQIVLNCGEEPSVVANTVKGGDGNYGYNAATEEY
GNMIDMGILDPTKVTRSALQYAASVAGLMITTECMVTDLP

AAKDVKFGNDARVKMLRGVNVLADAVKVTLGPKGRNVVLDKSFGAPTITKDGVSVAREIELEDKFENMGAQMVKEVASK
ANDAAGDGTTTATVLAQAIITEGLKAVAAGMNPMDLKRGIDKAVTAAVEELKALSVPCSDSKAIAQVGTISANSDETVG
KLIAEAMDKVGKEGVITVEDGTGLQDELDVVEGMQFDRGYLSPYFINKPETGAVELESPFILLADKKISNIREMLPVLE
AVAKAGKPLLIIAEDVEGEALQDIATLTGGTVISEEIGMELEKATLEDLGQAKRVVINKDTTTIIDGVGEEAAIQGRVA
QIRQQIEEATSDYDREKLQERVAKLAGGVAVIKVGAATEVEMKEKKARVEDALHATRAAVEEGVVAGGGVALIRVASKL
ADLRGQNEDQNVGIKVALRAMEAPLRQIVLNCGEEPSVVANTVKGGDGNYGYNAATEEYGNMIDMGILDPTKVTRSALQ
YAASVAGLMITTECMVTDLP

"""

dbfetch = """
>PDB:1GAG_A
VFPSSVFVPDEWEVSREKITLLRELGQGSFGMVYEGNARDIIKGEAETRVAVKTVNESAS
LRERIEFLNEASVMKGFTCHHVVRLLGVVSKGQPTLVVMELMAHGDLKSYLRSLRPEAEN
NPGRPPPTLQEMIQMAAEIADGMAYLNAKKFVHRDLAARNCMVAHDFTVKIGDFGMTRDI
XETDXXRKGGKGLLPVRWMAPESLKDGVFTTSSDMWSFGVVLWEITSLAEQPYQGLSNEQ
VLKFVMDGGYLDQPDNCPERVTDLMRMCWQFNPKMRPTFLEIVNLLKDDLHPSFPEVSFF
HSEENK

>PDB:1GAG_B
PATGDFMNMSPVG
"""

pir_sequence = (
    "MDITIHNPLIRRPLFSWLAPSRIFDQIFGEHLQESELLPASPSLSPFLMR"
    + "SPIFRMPSWLETGLSEMRLEKDKFSVNLDVKHFSPEELKVKVLGDMVEIH"
    + "GKHEERQDEHGFIAREFNRKYRIPADVDPLTITSSLSLDGVLTVSAPRKQ"
    + "SDVPERSIPITREEKPAIAGAQRK"
    )

# Break string to preserve syntactic whitespace
clustal1 = ( """CLUSTAL 2.0.10 multiple sequence alignment


Horse           VLSAADKTNVKAAWSKVGGHAGEYGAEALERMFLGFPTTKTYFPHFDLSHGSAQVKA--- 57
chain_A         VLSEGEWQLVLHVWAKVEADVAGHGQDILIRLFKSHPETLEKFDRFKHLKTEAEMKASED 60
                *** .:   *  .*:** .... :* : * *:* ..* *   * :*.  : .*::**   \n"""
+ """
Horse           ---HGKKVGDALTLAVGHLDDLPGALSDLSNLHAHKLRVDPVNFKLLSHCLLSTLAVHLP 114
chain_A         LKKHGVTVLTALGAILKKKGHHEAELKPLAQSHATKHKIPIKYLEFISEAIIHVLHSRHP 120
                   ** .*  **   : : ..  . *. *:: ** * ::    ::::*..:: .*  : *

Horse           NDFTPAVHASLDKFLSSVSTVLTSKYR------ 141
chain_A         GDFGADAQGAMNKALELFRKDIAAKYKELGYQG 153
                .** . .:.:::* *. . . :::**:      """ )

clustal2 = """CLUSTAL X (1.81) multiple sequence alignment

1vkk VVCEVDPELKETLRKFRFR---KETNNAAIIMKVD--KDRQMVVLEDELQ-NISPEELKL
1ahq -GIAVSDDCVQKFNELKLGHQH-----RYVTFKMNASN--TEVVVEHVGGPNATYEDFKS

1vkk ELPERQPRFVVYSYKYVH--DDGRVSYPLCFIFSSPVGCKPEQQMMYAGSKNRLVQTAE-
1ahq QLPERDCRYAIFDYEFQVDG---GQRNKITFILWAPDSAPIKSKMMYTSTKDSIKKKLVG

1vkk L-TKVFEIRTTDD-LTETWLKEKLAFFR
1ahq IQ-VEVQATD-AAEISEDAVSERAKK--
"""

clustal3 = """MUSCLE (3.8) multiple sequence alignment


1mru_A          -----------------GSHMTTPSHLSD-----RYELGEILGFGGMSEVHLARDLRLHR
2h34_A          MGSSHHHHHHSSGLVPRGSHMDGTAESREGTQFGPYRLRRLVGRGGMGDVYEAEDTVRER
                                 ****  .:   :      * *  ::* ***.:*: * *    *

1mru_A          DVAVKVLRADLARDPSFYLRFRREAQNAAALNHPAIVAVYDTGEAETPAGPLPYIVMEYV
2h34_A          IVALKLMSETLSSDPVFRTRMQREARTAGRLQEPHVVPIHDFGEID---GQL-YVDMRLI
                 **:*::   *: ** *  *:.***..*. *: * :*.::* ** :   * * *: *  :
"""

bad_clustal1 = """MUSCLE (3.8) multiple sequence alignment
Blah

1mru_A          -----------------GSHMTTPSHLSD-----RYELGEILGFGGMSEVHLARDLRLHR
2h34_A          MGSSHHHHHHSSGLVPRGSHMDGTAESREGTQFGPYRLRRLVGRGGMGDVYEAEDTVRER
                                 ****  .:   :      * *  ::* ***.:*: * *    *

1mru_A          DVAVKVLRADLARDPSFYLRFRREAQNAAALNHPAIVAVYDTGEAETPAGPLPYIVMEYV
2h34_A          IVALKLMSETLSSDPVFRTRMQREARTAGRLQEPHVVPIHDFGEID---GQL-YVDMRLI
                 **:*::   *: ** *  *:.***..*. *: * :*.::* ** :   * * *: *  :
"""

bad_clustal2 = """MUSCLE (3.8) multiple sequence alignment


1mru_A          -----------------GSHMTTPSHLSD-----RYELGEILGFGGMSEVHLARDLRLHR
2h34_A          MGSSHHHHHHSSGLVPRGSHMDGTAESREGTQFGPYRLRRLVGRGGMGDVYEAEDTVRER
                                 ****  .:   :      * *  ::* ***.:*: * *    *

1mru_A          DVAVKVLRADLARDPSFYLRFRREAQNAAALNHPAIVAVYDTGEAETPAGPLPYIVMEYV
2h34_A          IVALKLMSETLSSDPVFRTRMQREARTAGRLQEPHVVPIHDFGEID---GQL-YVDMRLI
2ghj_A          IVALKLMSETLSSDPVFRTRMQREARTAGRLQEPHVVPIHDFGEID---GQL-YVDMRLI
                 **:*::   *: ** *  *:.***..*. *: * :*.::* ** :   * * *: *  :
"""

pir_ali1 = """
>P1;Horse

VLSAADKTNVKAAWSKVGGHAGEYGAEALERMFLGFPTTKTYFPHFDLSHGSAQVKA---
---HGKKVGDALTLAVGHLDDLPGALSDLSNLHAHKLRVDPVNFKLLSHCLLSTLAVHLP
NDFTPAVHASLDKFLSSVSTVLTSKYR------*

>P3;chain_A

VLSEGEWQLVLHVWAKVEADVAGHGQDILIRLFKSHPETLEKFDRFKHLKTEAEMKASED
LKKHGVTVLTALGAILKKKGHHEAELKPLAQSHATKHKIPIKYLEFISEAIIHVLHSRHP
GDFGADAQGAMNKALELFRKDIAAKYKELGYQG*
"""

fasta_ali1 = """
>2QZU:A Putative sulfatase from B. fragilis
QPTPNLVFIXADQYRGDAIGCIGKEPVKTPHLDKLASEGINFTNAISSYP
VSSPARGXLXTGXYPIGSKVT-GNCNSETAPYGVELSQNARCWSDVLKDQ
GYNXGYIGKWHLDAPYKPYVDTYNNRGKVAWNEWCP---PERRHGFDHWI
AYGTYDY-----------------------------H-LKPXYWNTTAPR
DSFYYVNQ-----------WGPEYEASKAIEYINGQKDQKQPFALVVSXN
PPHTGYE--------------LVPDRYKEIYKDLDVEALCKGRPDIP---
-------------------AKG----------------------TEXGDY
FRNNIRNYYACITGVDENVGRIIEALKQNNLFDNTIVVFTSDHGICXG--
---------------AHENAGKD-IFYEESXRIPXILSWPDQIKPRKSDP
--LXIAFA-DLYPTLLSXXGFSKEIPETVQTFDLSNEVLTGKNKKD-LVQ
PYYFVKF--------DNHA------------------TGYRGLRTDRYTY
AVHAT-DGK------------------------IDNVILFDRTNDPHEXN
NIASQ--QLKLTHTFNRQLKTWLEKTNDPF
>3B5Q:B Putative sulfatase from B. thetaiotaomicron
-EKPNFLIIQCDHLTQRVVGAYGQTQGCTLPIDEVASRGVIFSNAYVGCP
LSQPSRAALWSGXXPHQTNVR-SNSS---EPVNTRLPENVPTLGSLFSES
GYEAVHFGKTHDX---------------------------GSLRGFKHKE
P-------------------------------------------------
---VAKPFTDPEFPVNNDSFLDVGTCEDAVAYLSNP--PKEPFICIADFQ
NPHNICGFIGENAGVHTDRPI----------SGPLPEL----PDNFDVED
WSNIPTPVQYICCSHRRXT---QAA-------------------HWNEEN
YRHYIAAFQHYTKXVSKQVDSVLKALYSTPAGRNTIVVIXADHGDGXA--
---------------SHRXVTKHISFYDEXTNVPFIFAG-PGIKQQKKPV
DHLLTQPTLDLLPTLCDLAGIA--VPAEKAGISLAPTLRGEKQKKSHPYV
VSEWHSEYEYVT-------------------------TPGRXVRGPRYKY
THYLE----------------------------GNGEELYDXKKDPGERK
NLAKDPKYSKILAEHRALLDDYITRSKDDY
"""

ali_ali1 = """
>2QZU:A
QPTPNLVFIXADQYRGDAIGCIGKEPVKTPHLDKLASEGINFTNAISSYP
VSSPARGXLXTGXYPIGSKVT-GNCNSETAPYGVELSQNARCWSDVLKDQ
GYNXGYIGKWHLDAPYKPYVDTYNNRGKVAWNEWCP---PERRHGFDHWI
AYGTYDY-----------------------------H-LKPXYWNTTAPR
DSFYYVNQ-----------WGPEYEASKAIEYINGQKDQKQPFALVVSXN
PPHTGYE--------------LVPDRYKEIYKDLDVEALCKGRPDIP---
-------------------AKG----------------------TEXGDY
FRNNIRNYYACITGVDENVGRIIEALKQNNLFDNTIVVFTSDHGICXG--
---------------AHENAGKD-IFYEESXRIPXILSWPDQIKPRKSDP
--LXIAFA-DLYPTLLSXXGFSKEIPETVQTFDLSNEVLTGKNKKD-LVQ
PYYFVKF--------DNHA------------------TGYRGLRTDRYTY
AVHAT-DGK------------------------IDNVILFDRTNDPHEXN
NIASQ--QLKLTHTFNRQLKTWLEKTNDPF
>3B5Q:B
-EKPNFLIIQCDHLTQRVVGAYGQTQGCTLPIDEVASRGVIFSNAYVGCP
LSQPSRAALWSGXXPHQTNVR-SNSS---EPVNTRLPENVPTLGSLFSES
GYEAVHFGKTHDX---------------------------GSLRGFKHKE
P-------------------------------------------------
---VAKPFTDPEFPVNNDSFLDVGTCEDAVAYLSNP--PKEPFICIADFQ
NPHNICGFIGENAGVHTDRPI----------SGPLPEL----PDNFDVED
WSNIPTPVQYICCSHRRXT---QAA-------------------HWNEEN
YRHYIAAFQHYTKXVSKQVDSVLKALYSTPAGRNTIVVIXADHGDGXA--
---------------SHRXVTKHISFYDEXTNVPFIFAG-PGIKQQKKPV
DHLLTQPTLDLLPTLCDLAGIA--VPAEKAGISLAPTLRGEKQKKSHPYV
VSEWHSEYEYVT-------------------------TPGRXVRGPRYKY
THYLE----------------------------GNGEELYDXKKDPGERK
NLAKDPKYSKILAEHRALLDDYITRSKDDY
"""

class test_sequence_parse(unittest.TestCase):

  def testSequence(self):

    ( sequences, unknowns ) = bioinformatics.seq_sequence_parse( seq )

    self.assertEqual( len( sequences ), 4 )
    self.assertEqual( unknowns, [ "\nError\n", ">chain_A" ] )

    self.assertEqual(
      sequences[0].name,
      "chain_A"
      )
    self.assertEqual(
      sequences[0].sequence,
      seq_sequence
      )

    self.assertEqual(
      sequences[1].name,
      "chain A"
      )
    self.assertEqual(
      sequences[1].sequence,
       seq_sequence
       )

    self.assertEqual(
      sequences[2].name,
      "chain_A"
      )
    self.assertEqual(
      sequences[2].sequence,
      seq_sequence
      )

    self.assertEqual(
      sequences[3].name,
      ''
    )
    self.assertEqual(
      sequences[3].sequence,
      seq_sequence
    )

    ( fastas, unknowns ) = bioinformatics.seq_sequence_parse( fasta )

    self.assertEqual( len( fastas ), 3 )
    self.assertEqual( unknowns, [ "\nError\n" ] )

    self.assertEqual(
      fastas[0].name,
      "FOSB_MOUSE Protein fosB. 338 bp"
      )
    self.assertEqual(
      fastas[0].sequence,
      fasta_sequence
      )

    self.assertEqual(
      fastas[1].name,
      "FOSB_MOUSE Protein fosB. 338 bp"
      )
    self.assertEqual(
      fastas[1].sequence,
      fasta_sequence
      )

    self.assertEqual(
      fastas[2].name,
      "1YJP:A|PDBID|CHAIN|SEQUENCE"
      )
    self.assertEqual(
      fastas[2].sequence,
      fasta_sequence
      )

  def testFasta(self):

    ( fastas, unknowns ) = bioinformatics.fasta_sequence_parse( fasta )

    self.assertEqual( len( fastas ), 3 )
    self.assertEqual(
      unknowns,
      [
        "\nError\n",
        ] )

    self.assertEqual(
      fastas[0].name,
      "FOSB_MOUSE"
      )
    self.assertEqual(
      fastas[0].sequence,
      fasta_sequence
      )
    self.assertEqual(
      fastas[0].description,
      "Protein fosB. 338 bp"
      )

    self.assertEqual(
      fastas[1].name,
      "FOSB_MOUSE"
      )
    self.assertEqual(
      fastas[1].sequence,
      fasta_sequence
      )
    self.assertEqual(
      fastas[1].description,
      "Protein fosB. 338 bp"
      )

    self.assertEqual(
      fastas[2].name,
      "1YJP"
      )
    self.assertEqual(
      fastas[2].description,
      "A|PDBID|CHAIN|SEQUENCE"
      )
    self.assertEqual(
      fastas[2].sequence,
      fasta_sequence
      )


  def testPir(self):

    ( pirs, unknowns ) = bioinformatics.pir_sequence_parse( pir )

    self.assertEqual( len( pirs ), 2 )
    self.assertEqual( unknowns, [ "\nError\n", pir[490:] ] )

    self.assertEqual(
      pirs[0].name,
      "CRAB_ANAPL"
      )
    self.assertEqual(
      pirs[0].type,
      "P1"
      )
    self.assertEqual(
      pirs[0].description,
      "ALPHA CRYSTALLIN B CHAIN (ALPHA(B)-CRYSTALLIN)."
      )
    self.assertEqual(
      pirs[0].sequence,
      pir_sequence
      )

    self.assertEqual(
      pirs[1].name,
      "CRAB_ANAPL"
      )
    self.assertEqual(
      pirs[1].type,
      "P1"
      )
    self.assertEqual(
      pirs[1].description,
      ""
      )
    self.assertEqual(
      pirs[1].sequence,
      pir_sequence
      )


  def testTolerantPir(self):

    ( pirs, unknowns ) = bioinformatics.tolerant_pir_sequence_parse( tolerant_pir )

    self.assertEqual( len( pirs ), 3 )
    self.assertEqual( unknowns, [ "\nError\n", "Error2\n\n" ] )

    self.assertEqual(
      pirs[0].name,
      "P1;CRAB_ANAPL"
      )
    self.assertEqual(
      pirs[0].type,
      "P1"
      )
    self.assertEqual(
      pirs[0].description,
      "ALPHA CRYSTALLIN B CHAIN (ALPHA(B)-CRYSTALLIN)."
      )
    self.assertEqual(
      pirs[0].sequence,
      pir_sequence
      )

    self.assertEqual(
      pirs[1].name,
      "CRAB_ANAPL"
      )
    self.assertEqual(
      pirs[1].type,
      "P1"
      )
    self.assertEqual(
      pirs[1].description,
      "ALPHA CRYSTALLIN B CHAIN (ALPHA(B)-CRYSTALLIN)."
      )
    self.assertEqual(
      pirs[1].sequence,
      pir_sequence
      )
    self.assertEqual(
      pirs[2].name,
      "CRAB_ANAPL"
      )
    self.assertEqual(
      pirs[2].type,
      "P1"
      )
    self.assertEqual(
      pirs[2].description,
      ""
      )
    self.assertEqual(
      pirs[2].sequence,
      pir_sequence
      )


  def test_tf_parse(self):

    ( seqs, unknowns ) = bioinformatics.tf_sequence_parse( text = tf )
    self.assertEqual( unknowns, [] )
    self.assertEqual( len( seqs ), 3 )
    self.assertEqual( seqs[0].name, "anb.pdb" )
    self.assertEqual(
      seqs[0].sequence,
      "AAKDVKFGVNVLADAVKVTLGPKGRNVVLDKSFGAPTITKDGVSVAREIELEDKFENMGAQMVKEVASKANDAAGDGTT"
      + "TATVLAQAIITEGLKAVAAGMNPMDLKRGIDKAVTAAVEELKALSVPCSDSKAIAQVGTISANSDETVGKLIAEAMDKV"
      + "GKEGVITVEDGTGLQDELDVVEGMQFDRGYLSPYFINKPETGAVELESPFILLADKKISNIREMLPVLEAVAKAGKPLL"
      + "IIAEDVEGEALATLVVNTMRGIVKVAAVKAPGFGDRRKAMLQDIATLTGGTVISEEIGMELEKATLEDLGQAKRVVINK"
      + "DTTTIIDGVGEEAAIQGRVAQIRQQIEEATSDYDREKLQERVAKLAGGVAVIKVGAATEVEMKEKKARVEDALHATRAA"
      + "VEEGVVAGGGVALIRVASKLADLRGQNEDQNVGIKVALRAMEAPLRQIVLNCGEEPSVVANTVKGGDGNYGYNAATEEY"
      + "GNMIDMGILDPTKVTRSALQYAASVAGLMITTECMVTDLP"
      )
    self.assertEqual( seqs[1].name, "anb.pdb" )
    self.assertEqual(
      seqs[1].sequence,
      "AAKDVKFGNDARVKMLRGVNVLADAVKVTLGPKGRNVVLDKSFGAPTITKDGVSVAREIELEDKFENMGAQMVKEVASK"
      + "ANDAAGDGTTTATVLAQAIITEGLKAVAAGMNPMDLKRGIDKAVTAAVEELKALSVPCSDSKAIAQVGTISANSDETVG"
      + "KLIAEAMDKVGKEGVITVEDGTGLQDELDVVEGMQFDRGYLSPYFINKPETGAVELESPFILLADKKISNIREMLPVLE"
      + "AVAKAGKPLLIIAEDVEGEALQDIATLTGGTVISEEIGMELEKATLEDLGQAKRVVINKDTTTIIDGVGEEAAIQGRVA"
      + "QIRQQIEEATSDYDREKLQERVAKLAGGVAVIKVGAATEVEMKEKKARVEDALHATRAAVEEGVVAGGGVALIRVASKL"
      + "ADLRGQNEDQNVGIKVALRAMEAPLRQIVLNCGEEPSVVANTVKGGDGNYGYNAATEEYGNMIDMGILDPTKVTRSALQ"
      + "YAASVAGLMITTECMVTDLP"
      )
    self.assertEqual( seqs[2].name, "anb.pdb" )
    self.assertEqual(
      seqs[2].sequence,
      "AAKDVKFGNDARVKMLRGVNVLADAVKVTLGPKGRNVVLDKSFGAPTITKDGVSVAREIELEDKFENMGAQMVKEVAST"
      + "ATVLAQAIITEGLKAVAAGMNPMDLKRGIDKAVTAAVEELKALSVPCSDSKAIAQVGTISANSDETVGKLIAEAMDKVG"
      + "KEGVITVEDGTGLQDELDVVEGMQFDRGYLSPYFINKPETGAVELESPFILLADKKISNIREMLPVLEAVAKAGKPLLI"
      + "IAEDVEGEALATLVVNTMRGIVKVAAVKAPGFGDRRKAMLQDIATLTGGTVISEEIGMELEKATLEDLGQAKRVVINKD"
      + "TTTIIDGVGEEAAIQGRVAQIRQQIEEATSDYDREKLQERVAKLAGGVAVIKVGAATEVEMKEKKARVEDALHATRAAV"
      + "EEGVVAGGGVALIRVASKLADLRGQNEDQNVGIKVALRAMEAPLRQIVLNCGKGGDGNYGYNAATEEYGNMIDMGILDP"
      + "TKVTRSALQYAASVAGLMITTECMVTDLP"
      )


  def test_ls_parse(self):

    ( seqs, unknowns ) = bioinformatics.lineseparated_sequence_parse.parse(
      text = lineseparated,
      name = "foo"
      )
    self.assertEqual( unknowns, [] )
    self.assertEqual( len( seqs ), 2 )
    self.assertEqual( seqs[0].name, "foo" )
    self.assertEqual(
      seqs[0].sequence,
      "AAKDVKFGVNVLADAVKVTLGPKGRNVVLDKSFGAPTITKDGVSVAREIELEDKFENMGAQMVKEVASKANDAAGDGTT"
      + "TATVLAQAIITEGLKAVAAGMNPMDLKRGIDKAVTAAVEELKALSVPCSDSKAIAQVGTISANSDETVGKLIAEAMDKV"
      + "GKEGVITVEDGTGLQDELDVVEGMQFDRGYLSPYFINKPETGAVELESPFILLADKKISNIREMLPVLEAVAKAGKPLL"
      + "IIAEDVEGEALATLVVNTMRGIVKVAAVKAPGFGDRRKAMLQDIATLTGGTVISEEIGMELEKATLEDLGQAKRVVINK"
      + "DTTTIIDGVGEEAAIQGRVAQIRQQIEEATSDYDREKLQERVAKLAGGVAVIKVGAATEVEMKEKKARVEDALHATRAA"
      + "VEEGVVAGGGVALIRVASKLADLRGQNEDQNVGIKVALRAMEAPLRQIVLNCGEEPSVVANTVKGGDGNYGYNAATEEY"
      + "GNMIDMGILDPTKVTRSALQYAASVAGLMITTECMVTDLP"
      )
    self.assertEqual( seqs[1].name, "foo" )
    self.assertEqual(
      seqs[1].sequence,
      "AAKDVKFGNDARVKMLRGVNVLADAVKVTLGPKGRNVVLDKSFGAPTITKDGVSVAREIELEDKFENMGAQMVKEVASK"
      + "ANDAAGDGTTTATVLAQAIITEGLKAVAAGMNPMDLKRGIDKAVTAAVEELKALSVPCSDSKAIAQVGTISANSDETVG"
      + "KLIAEAMDKVGKEGVITVEDGTGLQDELDVVEGMQFDRGYLSPYFINKPETGAVELESPFILLADKKISNIREMLPVLE"
      + "AVAKAGKPLLIIAEDVEGEALQDIATLTGGTVISEEIGMELEKATLEDLGQAKRVVINKDTTTIIDGVGEEAAIQGRVA"
      + "QIRQQIEEATSDYDREKLQERVAKLAGGVAVIKVGAATEVEMKEKKARVEDALHATRAAVEEGVVAGGGVALIRVASKL"
      + "ADLRGQNEDQNVGIKVALRAMEAPLRQIVLNCGEEPSVVANTVKGGDGNYGYNAATEEYGNMIDMGILDPTKVTRSALQ"
      + "YAASVAGLMITTECMVTDLP"
      )


  def test_dbfetch_parse(self):

      ( seqs, unknowns ) = bioinformatics.dbfetch_sequence_parse(
        text = dbfetch
        )
      self.assertEqual( unknowns, [] )
      self.assertEqual( len( seqs ), 2 )
      self.assertEqual( seqs[0].name, "1GAG" )
      self.assertEqual( seqs[0].chain, "A" )
      self.assertEqual(
        seqs[0].sequence,
        "VFPSSVFVPDEWEVSREKITLLRELGQGSFGMVYEGNARDIIKGEAETRVAVKTVNESAS"
        + "LRERIEFLNEASVMKGFTCHHVVRLLGVVSKGQPTLVVMELMAHGDLKSYLRSLRPEAEN"
        + "NPGRPPPTLQEMIQMAAEIADGMAYLNAKKFVHRDLAARNCMVAHDFTVKIGDFGMTRDI"
        + "XETDXXRKGGKGLLPVRWMAPESLKDGVFTTSSDMWSFGVVLWEITSLAEQPYQGLSNEQ"
        + "VLKFVMDGGYLDQPDNCPERVTDLMRMCWQFNPKMRPTFLEIVNLLKDDLHPSFPEVSFF"
        + "HSEENK"
        )
      self.assertEqual( seqs[1].name, "1GAG" )
      self.assertEqual( seqs[1].chain, "B" )
      self.assertEqual( seqs[1].sequence, "PATGDFMNMSPVG" )


  def test_filename_selection(self):

    self.assertEqual(
      bioinformatics.sequence_parser_for( "dummy.pir" ),
      bioinformatics.pir_sequence_parse
      )
    self.assertEqual( bioinformatics.sequence_parser_for( "seq" ), None )


  def test_known_formats(self):
    self.assertEqual(
      sorted( bioinformatics.known_sequence_formats() ),
      ['.dat', '.fa', '.faa', '.fasta', '.pir', '.seq']
      )


class test_alignment_parse(unittest.TestCase):

  def testClustal(self):

    ( ali, unknowns ) = bioinformatics.clustal_alignment_parse( clustal1 )

    self.assertEqual( unknowns, "" )

    self.assertEqual( ali.program, "CLUSTAL 2.0.10" )
    self.assertEqual( ali.names, [ "Horse", "chain_A" ] )
    self.assertEqual(
      ali.alignments,
      [
        "VLSAADKTNVKAAWSKVGGHAGEYGAEALERMFLGFPTTKTYFPHFDLSHGSAQVKA---"
        + "---HGKKVGDALTLAVGHLDDLPGALSDLSNLHAHKLRVDPVNFKLLSHCLLSTLAVHLP"
        + "NDFTPAVHASLDKFLSSVSTVLTSKYR------",
        "VLSEGEWQLVLHVWAKVEADVAGHGQDILIRLFKSHPETLEKFDRFKHLKTEAEMKASED"
        + "LKKHGVTVLTALGAILKKKGHHEAELKPLAQSHATKHKIPIKYLEFISEAIIHVLHSRHP"
        + "GDFGADAQGAMNKALELFRKDIAAKYKELGYQG"
        ]
      )

    ( ali, unknowns ) = bioinformatics.clustal_alignment_parse( clustal2 )

    self.assertEqual( unknowns, "" )

    self.assertEqual( ali.program, "CLUSTAL X (1.81)" )
    self.assertEqual( ali.names, [ "1vkk", "1ahq" ] )
    self.assertEqual(
      ali.alignments,
      [
        "VVCEVDPELKETLRKFRFR---KETNNAAIIMKVD--KDRQMVVLEDELQ-NISPEELKL"
        + "ELPERQPRFVVYSYKYVH--DDGRVSYPLCFIFSSPVGCKPEQQMMYAGSKNRLVQTAE-"
        + "L-TKVFEIRTTDD-LTETWLKEKLAFFR",
        "-GIAVSDDCVQKFNELKLGHQH-----RYVTFKMNASN--TEVVVEHVGGPNATYEDFKS"
        + "QLPERDCRYAIFDYEFQVDG---GQRNKITFILWAPDSAPIKSKMMYTSTKDSIKKKLVG"
        + "IQ-VEVQATD-AAEISEDAVSERAKK--"
        ]
      )

    ( ali, unknowns ) = bioinformatics.clustal_alignment_parse( clustal3 )

    self.assertEqual( unknowns, "" )

    self.assertEqual( ali.program, "MUSCLE (3.8)" )
    self.assertEqual( ali.names, [ "1mru_A", "2h34_A" ] )
    self.assertEqual(
      ali.alignments,
      [
        "-----------------GSHMTTPSHLSD-----RYELGEILGFGGMSEVHLARDLRLHR"
        + "DVAVKVLRADLARDPSFYLRFRREAQNAAALNHPAIVAVYDTGEAETPAGPLPYIVMEYV",
        "MGSSHHHHHHSSGLVPRGSHMDGTAESREGTQFGPYRLRRLVGRGGMGDVYEAEDTVRER"
        + "IVALKLMSETLSSDPVFRTRMQREARTAGRLQEPHVVPIHDFGEID---GQL-YVDMRLI",
        ]
      )

    # Bad format
    badaln = "Blah\nBlah\n" + clustal2
    ( ali, unknowns ) = bioinformatics.clustal_alignment_parse( badaln )

    self.assertEqual( unknowns, badaln )
    self.assertEqual( ali, None )

    ( ali, unknowns ) = bioinformatics.clustal_alignment_parse( bad_clustal1 )

    self.assertEqual( unknowns, bad_clustal1 )
    self.assertEqual( ali, None )

    ( ali, unknowns ) = bioinformatics.clustal_alignment_parse( bad_clustal2 )

    self.assertEqual( unknowns, bad_clustal2 )
    self.assertEqual( ali, None )

    # Empty alignment
    ( ali, unknowns ) = bioinformatics.clustal_alignment_parse(
      "CLUSTAL 2.0.10 multiple sequence alignment\n\n"
      )

    self.assertEqual( unknowns, "" )
    self.assertEqual( ali.program, "CLUSTAL 2.0.10" )
    self.assertEqual( ali.names, [] )
    self.assertEqual( ali.alignments, [] )


  def testPir(self):

    ( ali, unknowns ) = bioinformatics.pir_alignment_parse( pir_ali1 )

    self.assertEqual( unknowns, "" )

    self.assertEqual( ali.names, [ "Horse", "chain_A" ] )
    self.assertEqual( ali.types, [ "P1", "P3" ] )
    self.assertEqual( ali.descriptions, [ "", "" ] )
    self.assertEqual(
      ali.alignments,
      [
        "VLSAADKTNVKAAWSKVGGHAGEYGAEALERMFLGFPTTKTYFPHFDLSHGSAQVKA---"
        + "---HGKKVGDALTLAVGHLDDLPGALSDLSNLHAHKLRVDPVNFKLLSHCLLSTLAVHLP"
        + "NDFTPAVHASLDKFLSSVSTVLTSKYR------",
        "VLSEGEWQLVLHVWAKVEADVAGHGQDILIRLFKSHPETLEKFDRFKHLKTEAEMKASED"
        + "LKKHGVTVLTALGAILKKKGHHEAELKPLAQSHATKHKIPIKYLEFISEAIIHVLHSRHP"
        + "GDFGADAQGAMNKALELFRKDIAAKYKELGYQG"
        ]
      )

    # Bad format
    ( ali, unknowns ) = bioinformatics.pir_alignment_parse( "\n" + clustal2 )

    self.assertEqual( unknowns, "\n" + clustal2 )
    self.assertEqual( ali, None )

    # Empty alignment
    ( ali, unknowns ) = bioinformatics.pir_alignment_parse( "" )

    self.assertEqual( unknowns, "" )

    self.assertEqual( ali.names, [] )
    self.assertEqual( ali.types, [] )
    self.assertEqual( ali.descriptions, [] )
    self.assertEqual( ali.alignments, [] )


  def testFasta(self):

    ( ali, unknowns ) = bioinformatics.fasta_alignment_parse( fasta_ali1 )

    self.assertEqual( unknowns, "" )

    self.assertEqual( ali.names, [ "2QZU:A", "3B5Q:B" ] )
    self.assertEqual(
      ali.descriptions,
      [
        "Putative sulfatase from B. fragilis",
        "Putative sulfatase from B. thetaiotaomicron",
        ]
      )
    self.assertEqual(
      ali.alignments,
      [
        "QPTPNLVFIXADQYRGDAIGCIGKEPVKTPHLDKLASEGINFTNAISSYP"
        + "VSSPARGXLXTGXYPIGSKVT-GNCNSETAPYGVELSQNARCWSDVLKDQ"
        + "GYNXGYIGKWHLDAPYKPYVDTYNNRGKVAWNEWCP---PERRHGFDHWI"
        + "AYGTYDY-----------------------------H-LKPXYWNTTAPR"
        + "DSFYYVNQ-----------WGPEYEASKAIEYINGQKDQKQPFALVVSXN"
        + "PPHTGYE--------------LVPDRYKEIYKDLDVEALCKGRPDIP---"
        + "-------------------AKG----------------------TEXGDY"
        + "FRNNIRNYYACITGVDENVGRIIEALKQNNLFDNTIVVFTSDHGICXG--"
        + "---------------AHENAGKD-IFYEESXRIPXILSWPDQIKPRKSDP"
        + "--LXIAFA-DLYPTLLSXXGFSKEIPETVQTFDLSNEVLTGKNKKD-LVQ"
        + "PYYFVKF--------DNHA------------------TGYRGLRTDRYTY"
        + "AVHAT-DGK------------------------IDNVILFDRTNDPHEXN"
        + "NIASQ--QLKLTHTFNRQLKTWLEKTNDPF",
        "-EKPNFLIIQCDHLTQRVVGAYGQTQGCTLPIDEVASRGVIFSNAYVGCP"
        + "LSQPSRAALWSGXXPHQTNVR-SNSS---EPVNTRLPENVPTLGSLFSES"
        + "GYEAVHFGKTHDX---------------------------GSLRGFKHKE"
        + "P-------------------------------------------------"
        + "---VAKPFTDPEFPVNNDSFLDVGTCEDAVAYLSNP--PKEPFICIADFQ"
        + "NPHNICGFIGENAGVHTDRPI----------SGPLPEL----PDNFDVED"
        + "WSNIPTPVQYICCSHRRXT---QAA-------------------HWNEEN"
        + "YRHYIAAFQHYTKXVSKQVDSVLKALYSTPAGRNTIVVIXADHGDGXA--"
        + "---------------SHRXVTKHISFYDEXTNVPFIFAG-PGIKQQKKPV"
        + "DHLLTQPTLDLLPTLCDLAGIA--VPAEKAGISLAPTLRGEKQKKSHPYV"
        + "VSEWHSEYEYVT-------------------------TPGRXVRGPRYKY"
        + "THYLE----------------------------GNGEELYDXKKDPGERK"
        + "NLAKDPKYSKILAEHRALLDDYITRSKDDY",
        ]
      )


  def testAli(self):

    ( ali, unknowns ) = bioinformatics.ali_alignment_parse( ali_ali1 )

    self.assertEqual( unknowns, "" )

    self.assertEqual( ali.names, [ "2QZU:A", "3B5Q:B" ] )
    self.assertEqual(
      ali.alignments,
      [
        "QPTPNLVFIXADQYRGDAIGCIGKEPVKTPHLDKLASEGINFTNAISSYP"
        + "VSSPARGXLXTGXYPIGSKVT-GNCNSETAPYGVELSQNARCWSDVLKDQ"
        + "GYNXGYIGKWHLDAPYKPYVDTYNNRGKVAWNEWCP---PERRHGFDHWI"
        + "AYGTYDY-----------------------------H-LKPXYWNTTAPR"
        + "DSFYYVNQ-----------WGPEYEASKAIEYINGQKDQKQPFALVVSXN"
        + "PPHTGYE--------------LVPDRYKEIYKDLDVEALCKGRPDIP---"
        + "-------------------AKG----------------------TEXGDY"
        + "FRNNIRNYYACITGVDENVGRIIEALKQNNLFDNTIVVFTSDHGICXG--"
        + "---------------AHENAGKD-IFYEESXRIPXILSWPDQIKPRKSDP"
        + "--LXIAFA-DLYPTLLSXXGFSKEIPETVQTFDLSNEVLTGKNKKD-LVQ"
        + "PYYFVKF--------DNHA------------------TGYRGLRTDRYTY"
        + "AVHAT-DGK------------------------IDNVILFDRTNDPHEXN"
        + "NIASQ--QLKLTHTFNRQLKTWLEKTNDPF",
        "-EKPNFLIIQCDHLTQRVVGAYGQTQGCTLPIDEVASRGVIFSNAYVGCP"
        + "LSQPSRAALWSGXXPHQTNVR-SNSS---EPVNTRLPENVPTLGSLFSES"
        + "GYEAVHFGKTHDX---------------------------GSLRGFKHKE"
        + "P-------------------------------------------------"
        + "---VAKPFTDPEFPVNNDSFLDVGTCEDAVAYLSNP--PKEPFICIADFQ"
        + "NPHNICGFIGENAGVHTDRPI----------SGPLPEL----PDNFDVED"
        + "WSNIPTPVQYICCSHRRXT---QAA-------------------HWNEEN"
        + "YRHYIAAFQHYTKXVSKQVDSVLKALYSTPAGRNTIVVIXADHGDGXA--"
        + "---------------SHRXVTKHISFYDEXTNVPFIFAG-PGIKQQKKPV"
        + "DHLLTQPTLDLLPTLCDLAGIA--VPAEKAGISLAPTLRGEKQKKSHPYV"
        + "VSEWHSEYEYVT-------------------------TPGRXVRGPRYKY"
        + "THYLE----------------------------GNGEELYDXKKDPGERK"
        + "NLAKDPKYSKILAEHRALLDDYITRSKDDY",
        ]
      )

  def test_filename_selection(self):

    self.assertEqual(
      bioinformatics.alignment_parser_for( "dummy.pir" ),
      bioinformatics.pir_alignment_parse
      )
    self.assertEqual( bioinformatics.alignment_parser_for( "clustal" ), None )


  def test_known_formats(self):

    self.assertEqual(
      sorted( bioinformatics.known_alignment_formats() ),
      [ ".ali", ".aln", ".clustal", ".fa", ".fasta", ".hhr", ".pir" ]
      )


hhsearchout = \
"""
Query         Thu_Sep_09_20:47:04_+0200_2010
Match_columns 205
No_of_seqs    280 out of 1436
Neff          7.1
Searched_HMMs 22773
Date          Thu Sep  9 20:51:32 2010
Command       /cluster/toolkit/production/bioprogs/hhpred/hhsearch -cpu 4 -v 1 -i /cluster/toolkit/production/tmp/production/426773/3338418.hhm -d /cluster/toolkit/production/databases/hhpred/new_dbs/pdb70_9Sep10/db/pdb.hhm -o /cluster/toolkit/production/tmp/production/426773/3338418.hhr -p 20 -P 20 -Z 100 -B 100 -seq 1 -aliw 80 -local -ssm 2 -norealign -sc 1 -dbstrlen 10000 -cs /cluster/toolkit/production/bioprogs/csblast/data/clusters.prf

 No Hit                             Prob E-value P-value  Score    SS Cols Query HMM  Template HMM
  1 3cng_A Nudix hydrolase; struct 100.0 4.5E-28   2E-32  196.5  15.7  139   59-204    27-172 (189)
  2 3i7u_A AP4A hydrolase; nudix p  99.9 1.4E-27 6.2E-32  182.2  13.1  127   69-196     4-130 (134)

No 1
>3cng_A Nudix hydrolase; structural genomics, APC7497, PSI-2, protein structure initiative, midwest center for structural genomics; 2.00A {Nitrosomonas europaea atcc 19718}
Probab=99.96  E-value=4.5e-28  Score=196.52  Aligned_cols=139  Identities=21%  Similarity=0.317  Sum_probs=0.0

Q ss_pred             hccCCC---CCceEEEEEEEEEECCEEEEEEcCC----CEEECCceeeCCCCCHHHHHHHHHHHHhCCccccceEEEEEe
Q Thu_Sep_09_20:   59 FCNETG---YQTPKLDTRAAIFQEDKILLVQEND----GLWSLPGGWCDVDQSVKDNVVKEVKEEAGLDVEAQRVVAILD  131 (205)
Q Consensus        59 ~~~~~g---y~Tpkv~v~a~v~~d~kiLLv~~~~----g~W~lPGG~ve~gEs~~eaa~REv~EETGl~v~~~~ll~v~~  131 (205)
                       |+.||   |+.|++.|.++|.++++|||++|+.    |.|+||||++|.|||+++||+||++||||+++....+++++.
T Consensus        27 ~C~~C~~~~y~~P~v~v~~ii~~~~~vLLv~r~~~~~~g~W~lPGG~ve~GEs~e~aa~REv~EEtGl~v~~~~l~~~~~  106 (189)
T 3cng_A           27 ICPKCHTIHYQNPKVIVGCIPEWENKVLLCKRAIAPYRGKWTLPAGFMENNETLVQGAARETLEEANARVEIRELYAVYS  106 (189)
T ss_dssp             EETTTTEEECCCCEEEEEEEEEETTEEEEEEESSSSSTTCEECSEEECCTTCCHHHHHHHHHHHHHCCCEEEEEEEEEEE
T ss_pred             eCCCCCCcccCCCceEEEEEeecCceEEEEeccCCCCCCCEeCCcccCcCCCCHHHHHHHHHHhhhceeeeeeEEEEEee


Q ss_pred             eccccCCCCceEEEEEEEEEEecCCccCCCCCeEeEEEEcHHHCccccccCCCHHHHHHHHHHHhCCCCCCCc
Q Thu_Sep_09_20:  132 KHKNNPAKSAHRVTKVFILCRLLGGEFQPNSETVASGFFSLDDLPPLYLGKNTAEQLALCLEASRSEHWETRF  204 (205)
Q Consensus       132 ~~~~~~~~~~~~~~~~~f~~~~~~~~~~~~~E~~e~~Wf~~deLp~Ls~~r~~~~~i~~~f~~~r~~~~~t~f  204 (205)
                      ....       +...++|.|...++.+.++.|+.+++||++++||...+.-....+.-+.|...+..+....+
T Consensus       107 ~~~~-------~~~~~~f~~~~~~~~~~~~~E~~e~~wf~~~elp~~~la~~~~~~~l~~~~~~~~~g~~~~~  172 (189)
T 3cng_A          107 LPHI-------SQVYMLFRAKLLDLDFFPGIESLEVRLFGEQEIPWNDIAFRVIHDPLKRYMEERHHGQPAFH  172 (189)
T ss_dssp             EGGG-------TEEEEEEEEEECCSCCCCCTTEEEEEEECTTTCCGGGBSCHHHHHHHHHHHHHHHHSSCCCE
T ss_pred             cccc-------ceeEEEEEEEeccCcccCcccceeEEEEcHHHCCchhcCcHHHHHHHHHHHHHhhcCCCccc


No 2
>3i7u_A AP4A hydrolase; nudix protein, diadenosine polyphosphate, structural genomics, NPPSFA; HET: PGE; 1.80A {Aquifex aeolicus} PDB: 2pq1_A* 3i7u_A* 3i7v_A*
Probab=99.95  E-value=1.4e-27  Score=182.17  Aligned_cols=127  Identities=20%  Similarity=0.336  Sum_probs=0.0

Q ss_pred             EEEEEEEEEECCEEEEEEcCCCEEECCceeeCCCCCHHHHHHHHHHHHhCCccccceEEEEEeeccccCCCCceEEEEEE
Q Thu_Sep_09_20:   69 KLDTRAAIFQEDKILLVQENDGLWSLPGGWCDVDQSVKDNVVKEVKEEAGLDVEAQRVVAILDKHKNNPAKSAHRVTKVF  148 (205)
Q Consensus        69 kv~v~a~v~~d~kiLLv~~~~g~W~lPGG~ve~gEs~~eaa~REv~EETGl~v~~~~ll~v~~~~~~~~~~~~~~~~~~~  148 (205)
                      ++.++|+|+++|+|||+++.+|.|++|||++|.|||+.+||+||++||||+++....+++..+.. +.......+...++
T Consensus         4 ~~aAg~vv~~~~~vLlv~r~~~~w~~PgG~ve~gEt~~~aa~RE~~EEtGl~~~~~~~~~~~~~~-~~~~~~~~~~~~~~   82 (134)
T 3i7u_A            4 EFSAGGVLFKDGEVLLIKTPSNVWSFPKGNIEPGEKPEETAVREVWEETGVKGEILDYIGEIHYW-YTLKGERIFKTVKY   82 (134)
T ss_dssp             EEEEEEEEEETTEEEEEECTTSCEECCEEECCTTCCHHHHHHHHHHHHHSEEEEEEEEEEEEEEE-EEETTEEEEEEEEE
T ss_pred             EEEEEEEEEECCEEEEEEeCCCcEECceeEeCCCCCHHHHHHhhhhheeceeEEEeeeeeeeeee-ccCCCceEEEEEEE


Q ss_pred             EEEEecCCccCCCCCeEeEEEEcHHHCccccccCCCHHHHHHHHHHHh
Q Thu_Sep_09_20:  149 ILCRLLGGEFQPNSETVASGFFSLDDLPPLYLGKNTAEQLALCLEASR  196 (205)
Q Consensus       149 f~~~~~~~~~~~~~E~~e~~Wf~~deLp~Ls~~r~~~~~i~~~f~~~r  196 (205)
                      |.+...++++.++.|+.+++|+++++++++....+....|..+++..+
T Consensus        83 f~~~~~~~~~~~~~E~~~~~W~~~~e~~~~l~~~~~r~il~~~~~l~~  130 (134)
T 3i7u_A           83 YLMKYKEGEPRPSWEVKDAKFFPIKEAKKLLKYKGDKEIFEKALKLKE  130 (134)
T ss_dssp             EEEEEEEECCCCCTTSSEEEEEEHHHHHHHCCSHHHHHHHHHHHHHHH
T ss_pred             EEEeccCCcccCChhheEEEEEeHHHHHhhcCChHHHHHHHHHHHHHh


Done!
"""

hhalignout = """
Query         1XVQ.pdb
Match_columns 155
No_of_seqs    111 out of 3723
Neff          9.0
Searched_HMMs 0
Date          Tue Jul 13 19:50:02 2010
Command       /work/dimaio/sequence/hhsearch/hhalign -i 1XVQ.hhm -t 1FOH.hhm -glob -o 1FOH_1XVQ.hhr

 No Hit                             Prob E-value P-value  Score    SS Cols Query HMM  Template HMM
  1 1FOH_aln.pdb                     1.0       1       1   56.1  11.5  141    1-155   460-631 (649)

No 1
>1FOH_aln.pdb
Probab=1.00    E-value=1  Score=56.09  Aligned_columns=141  Identities=11%

Q ss_pred             CCCCCCCCCCCCCCEEEEC-CCCCEEEHHH-HC--CCEEEEEEECCCCCCCHHHHHHHHHHHHHHC--------------
Q ss_conf             9988554688178517897-9997764889-69--9848999832437711126669999998420--------------
Q 1XVQ.pdb          1 TVGELPAVGSPAPAFTLTG-GDLGVISSDQ-FR--GKSVLLNIFPSVDTPVCATSVRTFDERAAAS--------------   62 (155)
Q Consensus         1 ~~~~~p~vG~~aPdF~l~~-~~G~~v~ls~-~~--Gk~vvl~f~~~~~~p~c~~~~~~l~~~~~~~--------------   62 (155)
                      -...-+.+|..+|+.-+.. .+|....+.+ +.  |++.++.|......+.-...+..+.+...................
T Consensus       460 ~~~~~~~~G~r~p~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  539 (649)
T 1FOH_aln.pdb    460 ELAKNCVVGTRFKSQPVVRHSEGLWMHFGDRLVTDGRFRIIVFAGKATDATQMSRIKKFSAYLDSENSVISLYTPKVSDR  539 (649)
T ss_pred             CCCCCCCCCCCCCCCCEEECCCCCCCCHHHHHCCCCCEEEEEECCCCCCCHHHHHHHHHHHHHCCCCCEEEECCCCCCCC
T ss_conf             33688888864688503532788831125541278837999943888761135678888875204563011022466766


Q ss_pred             --CEEECCCCCCCHH-----HHHHHHHHHCCCC------EEECCCCCHHHHHHCCCCCCCCCCCCCEEEEEEEECCCCEE
Q ss_conf             --1000023467889-----9999999828975------11014433488997077344565557101279998699839
Q 1XVQ.pdb         63 --GATVLCVSKDLPF-----AQKRFCGAEGTEN------VMPASAFRDSFGEDYGVTIADGPMAGLLARAIVVIGADGNV  129 (155)
Q Consensus        63 --g~~v~~i~~~~~~-----~~~~~~~~~~~~~------~~~~~d~~~~~~~~~g~~~~~~~~~~~~~p~~fiID~~G~I  129 (155)
                        .+.++.|......     .............      .....|........||+..+        ..+.+||=|||-|
T Consensus       540 ~~~~~~~~v~~~~~~~~~~~~~~~~~~~~~~~~~~v~~~~~~~~~~~~~~~~~~g~~~~--------~~~~vlVRPD~~V  611 (649)
T 1FOH_aln.pdb    540 NSRIDVITIHSCHRDDIEMHDFPAPALHPKWQYDFIYADCDSWHHPHPKSYQAWGVDET--------KGAVVVVRPDGYT  611 (649)
T ss_pred             CCCEEEEEEECCCCCCCCHHHCHHHHCCCCCCCEEEEECCCCCCCCCHHHHHHHCCCHH--------CCEEEEECCCCEE
T ss_conf             56168999854776544233320200246742016650444444667789998098711--------4379998699558


Q ss_pred             EEEEECCCCCCCCCHHHHHHHHHHHC
Q ss_conf             99998178888889999999998519
Q 1XVQ.pdb        130 AYTELVPEIAQEPNYEAALAALGATS  155 (155)
Q Consensus       130 ~~~~~~~~~~~~~~~~~il~~lkal~  155 (155)
                      .++.  +    .-+.+++.+.+...=
T Consensus       612 a~~~--~----~~~~~~l~~~~~~~l  631 (649)
T 1FOH_aln.pdb    612 SLVT--D----LEGTAEIDRYFSGIL  631 (649)
T ss_pred             EEEE--C----HHHHHHHHHHHHHHC
T ss_conf             9997--3----013589999999742


Done!
"""


class test_hhsearch_parser(unittest.TestCase):

  def setUp(self):

    self.hss = bioinformatics.hhsearch_parser( output = hhsearchout )


  def test_process_header(self):

    self.assertEqual( self.hss.query, "Thu_Sep_09_20:47:04_+0200_2010" )
    self.assertEqual( self.hss.match_columns, 205 )
    self.assertEqual( self.hss.no_of_sequences, ( 280, 1436 ) )
    self.assertEqual( self.hss.neff, "7.1" )
    self.assertEqual( self.hss.searched_hmms, 22773 )
    self.assertEqual( self.hss.date, "Thu Sep  9 20:51:32 2010" )
    self.assertEqual(
      self.hss.command,
      "/cluster/toolkit/production/bioprogs/hhpred/hhsearch -cpu 4 -v 1 -i /cluster/toolkit/production/tmp/production/426773/3338418.hhm -d /cluster/toolkit/production/databases/hhpred/new_dbs/pdb70_9Sep10/db/pdb.hhm -o /cluster/toolkit/production/tmp/production/426773/3338418.hhr -p 20 -P 20 -Z 100 -B 100 -seq 1 -aliw 80 -local -ssm 2 -norealign -sc 1 -dbstrlen 10000 -cs /cluster/toolkit/production/bioprogs/csblast/data/clusters.prf"
      )


  def test_process_hits(self):

    self.assertEqual( self.hss.indices, [ 1, 2 ] )
    self.assertEqual( self.hss.pdbs, [ "3CNG", "3I7U" ] )
    self.assertEqual( self.hss.chains, [ "A", "A" ] )
    self.assertEqual(
      self.hss.annotations,
      [
        "Nudix hydrolase; structural genomics, APC7497, PSI-2, protein structure initiative, midwest center for structural genomics; 2.00A {Nitrosomonas europaea atcc 19718}",
        "AP4A hydrolase; nudix protein, diadenosine polyphosphate, structural genomics, NPPSFA; HET: PGE; 1.80A {Aquifex aeolicus} PDB: 2pq1_A* 3i7u_A* 3i7v_A*",
        ]
        )

    self.assertIterablesAlmostEqual( self.hss.probabs, [ 99.96, 99.95 ], 2 )
    self.assertIterablesAlmostEqual( self.hss.e_values, [ 4.5e-28, 1.4e-27 ], 28 )
    self.assertIterablesAlmostEqual( self.hss.scores, [ 196.52, 182.17 ], 2 )
    self.assertEqual( self.hss.aligned_cols, [ 139, 127 ] )
    self.assertIterablesAlmostEqual( self.hss.identities, [ 21, 20 ], 1 )
    self.assertEqual( self.hss.query_starts, [ 59, 69 ] )
    self.assertEqual( self.hss.query_ends, [ 204, 196 ] )
    self.assertEqual( self.hss.query_others, [ 205, 205 ] )
    self.assertEqual(
      self.hss.query_alignments,
      [
        "FCNETG---YQTPKLDTRAAIFQEDKILLVQEND----GLWSLPGGWCDVDQSVKDNVVKEVKEEAGLDVEAQRVVAILD"
          + "KHKNNPAKSAHRVTKVFILCRLLGGEFQPNSETVASGFFSLDDLPPLYLGKNTAEQLALCLEASRSEHWETRF",
        "KLDTRAAIFQEDKILLVQENDGLWSLPGGWCDVDQSVKDNVVKEVKEEAGLDVEAQRVVAILDKHKNNPAKSAHRVTKVF"
          + "ILCRLLGGEFQPNSETVASGFFSLDDLPPLYLGKNTAEQLALCLEASR",
        ]
      )

    self.assertEqual( self.hss.hit_starts, [ 27, 4 ] )
    self.assertEqual( self.hss.hit_ends, [ 172, 130 ] )
    self.assertEqual( self.hss.hit_others, [ 189, 134 ] )
    self.assertEqual(
      self.hss.hit_alignments,
      [
        "ICPKCHTIHYQNPKVIVGCIPEWENKVLLCKRAIAPYRGKWTLPAGFMENNETLVQGAARETLEEANARVEIRELYAVYS"
          + "LPHI-------SQVYMLFRAKLLDLDFFPGIESLEVRLFGEQEIPWNDIAFRVIHDPLKRYMEERHHGQPAFH",
        "EFSAGGVLFKDGEVLLIKTPSNVWSFPKGNIEPGEKPEETAVREVWEETGVKGEILDYIGEIHYW-YTLKGERIFKTVKY"
          + "YLMKYKEGEPRPSWEVKDAKFFPIKEAKKLLKYKGDKEIFEKALKLKE",
        ]
      )


  def assertIterablesAlmostEqual(self, i1, i2, digits):

    self.assertEqual( len( i1 ), len( i2 ) )

    for ( o, e ) in zip( i1, i2 ):
      self.assertAlmostEqual( o, e, digits )


class test_hhalign_parser(unittest.TestCase):

  def setUp(self):

    self.hss = bioinformatics.hhalign_parser( output = hhalignout )


  def test_process_header(self):

    self.assertEqual( self.hss.query, "1XVQ.pdb" )
    self.assertEqual( self.hss.match_columns, 155 )
    self.assertEqual( self.hss.no_of_sequences, ( 111, 3723 ) )
    self.assertEqual( self.hss.neff, "9.0" )
    self.assertEqual( self.hss.searched_hmms, 0 )
    self.assertEqual( self.hss.date, "Tue Jul 13 19:50:02 2010" )
    self.assertEqual(
      self.hss.command,
      "/work/dimaio/sequence/hhsearch/hhalign -i 1XVQ.hhm -t 1FOH.hhm -glob -o 1FOH_1XVQ.hhr"
      )


  def test_process_hits(self):

    self.assertEqual( self.hss.indices, [ 1 ] )
    self.assertEqual( self.hss.annotations, [ "1FOH_aln.pdb" ] )

    self.assertIterablesAlmostEqual( self.hss.probabs, [ 1.0 ], 2 )
    self.assertIterablesAlmostEqual( self.hss.e_values, [ 1.0 ], 2 )
    self.assertIterablesAlmostEqual( self.hss.scores, [ 56.09 ], 2 )
    self.assertEqual( self.hss.aligned_cols, [ 141 ] )
    self.assertIterablesAlmostEqual( self.hss.identities, [ 11 ], 1 )
    self.assertEqual( self.hss.query_starts, [ 1 ] )
    self.assertEqual( self.hss.query_ends, [ 155 ] )
    self.assertEqual( self.hss.query_others, [ 155 ] )
    self.assertEqual(
      self.hss.query_alignments,
      [
        "TVGELPAVGSPAPAFTLTG-GDLGVISSDQ-FR--GKSVLLNIFPSVDTPVCATSVRTFDERAAAS--------------"
          + "--GATVLCVSKDLPF-----AQKRFCGAEGTEN------VMPASAFRDSFGEDYGVTIADGPMAGLLARAIVVIGADGNV"
          + "AYTELVPEIAQEPNYEAALAALGATS",
        ]
      )
    self.assertEqual(
      self.hss.query_consensi,
      [
        "~~~~~p~vG~~aPdF~l~~-~~G~~v~ls~-~~--Gk~vvl~f~~~~~~p~c~~~~~~l~~~~~~~--------------"
          + "--g~~v~~i~~~~~~-----~~~~~~~~~~~~~------~~~~~d~~~~~~~~~g~~~~~~~~~~~~~p~~fiID~~G~I"
          + "~~~~~~~~~~~~~~~~~il~~lkal~",
        ]
      )
    self.assertEqual(
      self.hss.query_ss_preds,
      [
        "CCCCCCCCCCCCCCEEEEC-CCCCEEEHHH-HC--CCEEEEEEECCCCCCCHHHHHHHHHHHHHHC--------------"
          + "--CEEECCCCCCCHH-----HHHHHHHHHCCCC------EEECCCCCHHHHHHCCCCCCCCCCCCCEEEEEEEECCCCEE"
          + "EEEEECCCCCCCCCHHHHHHHHHHHC",
        ]
      )
    self.assertEqual(
      self.hss.query_ss_confs,
      [
        "9988554688178517897-9997764889-69--9848999832437711126669999998420--------------"
          + "--1000023467889-----9999999828975------11014433488997077344565557101279998699839"
          + "99998178888889999999998519",
        ]
      )

    self.assertEqual(
      self.hss.midlines,
      [
        "-...-+.+|..+|+.-+.. .+|....+.+ +.  |++.++.|......+.-...+..+.+..................."
          + "  .+.++.|......     .............      .....|........||+..+        ..+.+||=|||-|"
          + ".++.  +    .-+.+++.+.+...=",
        ]
      )

    self.assertEqual( self.hss.hit_starts, [ 460 ] )
    self.assertEqual( self.hss.hit_ends, [ 631 ] )
    self.assertEqual( self.hss.hit_others, [ 649 ] )
    self.assertEqual(
      self.hss.hit_ss_preds,
      [
        "CCCCCCCCCCCCCCCCEEECCCCCCCCHHHHHCCCCCEEEEEECCCCCCCHHHHHHHHHHHHHCCCCCEEEECCCCCCCC"
          + "CCCEEEEEEECCCCCCCCHHHCHHHHCCCCCCCEEEEECCCCCCCCCHHHHHHHCCCHH--------CCEEEEECCCCEE"
          + "EEEE--C----HHHHHHHHHHHHHHC",
        ]
      )
    self.assertEqual(
      self.hss.hit_ss_confs,
      [
        "33688888864688503532788831125541278837999943888761135678888875204563011022466766"
          + "56168999854776544233320200246742016650444444667789998098711--------4379998699558"
          + "9997--3----013589999999742",
        ]
      )
    self.assertEqual(
      self.hss.hit_consensi,
      [
        "~~~~~~~~G~r~p~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
          + "~~~~~~~~v~~~~~~~~~~~~~~~~~~~~~~~~~~v~~~~~~~~~~~~~~~~~~g~~~~--------~~~~vlVRPD~~V"
          + "a~~~--~----~~~~~~l~~~~~~~l",
        ]
      )
    self.assertEqual(
      self.hss.hit_alignments,
      [
        "ELAKNCVVGTRFKSQPVVRHSEGLWMHFGDRLVTDGRFRIIVFAGKATDATQMSRIKKFSAYLDSENSVISLYTPKVSDR"
          + "NSRIDVITIHSCHRDDIEMHDFPAPALHPKWQYDFIYADCDSWHHPHPKSYQAWGVDET--------KGAVVVVRPDGYT"
          + "SLVT--D----LEGTAEIDRYFSGIL",
        ]
      )


  def assertIterablesAlmostEqual(self, i1, i2, digits):

    self.assertEqual( len( i1 ), len( i2 ) )

    for ( o, e ) in zip( i1, i2 ):
      self.assertAlmostEqual( o, e, digits )

def exercise_read_a3m():
  from iotbx.bioinformatics import read_a3m
  a3m_info = read_a3m(a3m_text)
  assert a3m_info is not None
  assert a3m_info.sequence_length == 600, a3m_info.sequence_length

def exercise_guess_chain_types():
  from iotbx.bioinformatics import \
     guess_chain_types_from_sequences,text_from_chains_matching_chain_type
  print("Testing guess_chain_types ...", end=' ')
  text_rna="""
>4a17.pdb|Chain=2
AGAAAAUUUUCAACGGUGGAUAUCUAGGUUCCCGUGACGAUGAAGAACGCAGCGAAAUGCGAUACGCAAUGCGAAUUGCA
GAACCGCGAGUCAUCAGAUCUUUGAACGCAAGUGGUGGAGGUGUAAAAACCUUCAUGUUUGUUUCAGUGUGGAA
  """
  text_ambiguous="""
>4a17.pdb|Chain=A
TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT
  """
  text_ambiguous_a="""
>4a17.pdb|Chain=A
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
  """
  text_ambiguous_ag="""
AAAAAAAG
  """

  text_protein="""
>4a17.pdb|Chain=A
GRVIRAQRKGRANGVYKSHKSGRIAPAQYRVYDFAERQGYIRGCIRDIVHEPGRGAPLAEVAFRDPYRYKTNKEHFIAAE
GQYSGQYVYCGLKAQIAVGNVLPINRIPEGTVVCNVEEKVGDRGTFSRASGCYATIIGHSEDGDKTRIRLPSGARKTIPG
SCRATVGIVAGGGRTDKPILKAGNQFHKYARKRKSWPRVRGVAMNPVDHPHGGGNHQHIGHPATVSKWASAGQKVGLRAA
RRTGLVRGGQKEKMAMK
  """
  text_dna="""
>4a17.pdb|Chain=B
GATCCCTTTCCC
  """
  text_misc="""
UGGAGAGUUUGAUCCU

asdfaafasdfafsdea
"""
  text_misc_2="""
>> chain 1
UGGAGAGUUUGAUCCU

>> chain 2
asdfaafasdfafsdea
"""
  text_misc_3="""
>> chain 1
UGGAGAGUUUGAUCCU

>> chain 2

"""

  text_protein_pdb = \
"""
ATOM      2  CA  GLY A 511      12.652  44.232  24.646  1.00 31.14      A    C
ATOM      6  CA  ASP A 512       9.025  45.287  24.299  1.00 36.73      A    C
ATOM     14  CA  PRO A 513       7.666  41.856  25.348  1.00 32.96      A    C
ATOM     21  CA  VAL A 514       9.071  42.422  28.848  1.00 29.77      A    C
ATOM     28  CA  THR A 515       6.954  45.559  29.147  1.00 33.07      A    C
ATOM     35  CA  ARG A 516       3.960  43.821  27.518  1.00 36.02      A    C
ATOM     46  CA  VAL A 517       4.094  40.967  30.053  1.00 29.54      A    C
ATOM     53  CA  LEU A 518       4.292  43.291  33.052  1.00 27.54      A    C
ATOM     61  CA  ASP A 519       1.537  45.543  31.676  1.00 29.63      A    C
ATOM     69  CA  ASP A 520      -0.827  42.633  30.996  1.00 31.79      A    C
"""
  text_rna_pdb = \
"""
ATOM     23  P     G U   1      13.063  22.026  11.420  1.00  0.00
ATOM     43  P     U U   2      18.716  21.164  10.071  1.00  0.00
ATOM     66  P     G U   3      22.765  18.088   7.789  1.00  0.00
ATOM     89  P     G U   4      23.803  13.287   4.325  1.00  0.00
ATOM    109  P     U U   5      21.549   8.522   0.878  1.00  0.00
ATOM    132  P     G U   6      18.176   5.108  -2.281  1.00  0.00
ATOM    160  P     A V   2       5.037  12.654   6.095  1.00  0.00
ATOM    180  P     C V   3       6.536   7.470   8.349  1.00  0.00
ATOM    200  P     C V   4      10.409   4.550  10.972  1.00  0.00
ATOM    222  P     A V   5      15.160   3.698  14.124  1.00  0.00
ATOM    242  P     C V   6      19.171   5.322  17.832  1.00  0.00
"""
  text_rna_pdb_o_two = \
"""
ATOM     23  P     G U   1      13.063  22.026  11.420  1.00  0.00
ATOM     24  O2'   G U   1      14.063  23.026  12.420  1.00  0.00
ATOM     43  P     U U   2      18.716  21.164  10.071  1.00  0.00
ATOM     66  P     G U   3      22.765  18.088   7.789  1.00  0.00
ATOM     89  P     G U   4      23.803  13.287   4.325  1.00  0.00
ATOM    109  P     U U   5      21.549   8.522   0.878  1.00  0.00
ATOM    132  P     G U   6      18.176   5.108  -2.281  1.00  0.00
ATOM    160  P     A V   2       5.037  12.654   6.095  1.00  0.00
ATOM    180  P     C V   3       6.536   7.470   8.349  1.00  0.00
ATOM    200  P     C V   4      10.409   4.550  10.972  1.00  0.00
ATOM    222  P     A V   5      15.160   3.698  14.124  1.00  0.00
ATOM    242  P     C V   6      19.171   5.322  17.832  1.00  0.00
"""
  text_dna_pdb = \
"""
ATOM     23  P     G U   1      13.063  22.026  11.420  1.00  0.00
ATOM     43  P     T U   2      18.716  21.164  10.071  1.00  0.00
ATOM     66  P     G U   3      22.765  18.088   7.789  1.00  0.00
ATOM     89  P     G U   4      23.803  13.287   4.325  1.00  0.00
ATOM    109  P     T U   5      21.549   8.522   0.878  1.00  0.00
ATOM    132  P     G U   6      18.176   5.108  -2.281  1.00  0.00
ATOM    160  P     A V   2       5.037  12.654   6.095  1.00  0.00
ATOM    180  P     C V   3       6.536   7.470   8.349  1.00  0.00
ATOM    200  P     C V   4      10.409   4.550  10.972  1.00  0.00
ATOM    222  P     A V   5      15.160   3.698  14.124  1.00  0.00
ATOM    242  P     C V   6      19.171   5.322  17.832  1.00  0.00
"""
  text_dna_pdb_lc = \
"""
ATOM     23  P     g U   1      13.063  22.026  11.420  1.00  0.00
ATOM     43  P     t U   2      18.716  21.164  10.071  1.00  0.00
ATOM     66  P     g U   3      22.765  18.088   7.789  1.00  0.00
ATOM     89  P     g U   4      23.803  13.287   4.325  1.00  0.00
ATOM    109  P     t U   5      21.549   8.522   0.878  1.00  0.00
ATOM    132  P     g U   6      18.176   5.108  -2.281  1.00  0.00
ATOM    160  P     a V   2       5.037  12.654   6.095  1.00  0.00
ATOM    180  P     c V   3       6.536   7.470   8.349  1.00  0.00
ATOM    200  P     c V   4      10.409   4.550  10.972  1.00  0.00
ATOM    222  P     a V   5      15.160   3.698  14.124  1.00  0.00
ATOM    242  P     c V   6      19.171   5.322  17.832  1.00  0.00
"""

  assert guess_chain_types_from_sequences(text=text_protein)==["PROTEIN"]
  assert guess_chain_types_from_sequences(text=text_dna)==["DNA"]
  assert guess_chain_types_from_sequences(text=text_rna)==["RNA"]
  assert guess_chain_types_from_sequences(
    text=text_protein+text_rna)==["PROTEIN","RNA"]
  assert guess_chain_types_from_sequences(
    text=text_protein+text_dna)==["DNA","PROTEIN"]
  assert guess_chain_types_from_sequences(
    text=text_rna+text_protein+text_dna)==["DNA","PROTEIN","RNA"]
  assert guess_chain_types_from_sequences(
    text=text_rna+text_dna)==["DNA","RNA"]
  assert guess_chain_types_from_sequences(text="XX")==[]
  assert guess_chain_types_from_sequences(text=text_misc)==["PROTEIN","RNA"]
  assert guess_chain_types_from_sequences(text=text_misc_2)==["PROTEIN","RNA"]
  assert guess_chain_types_from_sequences(text=text_misc_3)==["RNA"]

  assert guess_chain_types_from_sequences(text=
    text_from_chains_matching_chain_type(text=text_misc_2))==["PROTEIN","RNA"]
  assert guess_chain_types_from_sequences(text=
    text_from_chains_matching_chain_type(text=text_misc_3))==["RNA"]
  assert guess_chain_types_from_sequences(text=
    text_from_chains_matching_chain_type(text=text_protein))==["PROTEIN"]
  assert guess_chain_types_from_sequences(text=
    text_from_chains_matching_chain_type(text=text_ambiguous))==['DNA']
  assert guess_chain_types_from_sequences(text=
    text_from_chains_matching_chain_type(text=text_ambiguous_a))==['PROTEIN']
  assert guess_chain_types_from_sequences(text=
    text_from_chains_matching_chain_type(text=text_ambiguous_ag))==['PROTEIN']

  assert guess_chain_types_from_sequences(text=
    text_from_chains_matching_chain_type(text=text_ambiguous_a),
       likely_chain_types=['RNA'])==['RNA']
  assert guess_chain_types_from_sequences(text=text_ambiguous,
       likely_chain_types=['PROTEIN','RNA']) == ['PROTEIN']
  assert text_from_chains_matching_chain_type(
      text=text_ambiguous,chain_type='PROTEIN')=="""
>
TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT
 """

  print("OK")
def exercise_random_sequences():
  import random
  random.seed(71231)
  seq=bioinformatics.random_sequence(n_residues=100,
     residue_basket=residue_basket)
  # random number generator is not consistent between Python 2 and 3
  assert len(seq) == 100
  assert seq.count('E') > seq.count('D')
  assert seq.count('D') > seq.count('C')
  assert seq.count('C') > seq.count('A')
  seq=bioinformatics.random_sequence(n_residues=100, chain_type = 'PROTEIN')
  assert len(seq) == 100
  seq=bioinformatics.random_sequence(n_residues=100, chain_type = 'RNA')
  assert len(seq) == 100
  seq=bioinformatics.random_sequence(n_residues=100, chain_type = 'DNA')
  assert len(seq) == 100
  seq=bioinformatics.random_sequence(n_residues=100)
  assert len(seq) == 100

def exercise_merge_sequences():
  print("Testing merge_sequences ...", end=' ')
  with open("tmp_iotbx_bioinfo.fa", "w") as f:
    f.write("""\
> 9zzz
ARGLYS
> 8xxx
PHETYR""")
  output_file = "tmp_iotbx_bioinfo_merged.fa"
  bioinformatics.merge_sequence_files(
    file_names=["tmp_iotbx_bioinfo.fa"],
    output_file=output_file,
    sequences=["SERTHR"])
  seq_in, nc = bioinformatics.any_sequence_format(output_file)
  assert (len(seq_in) == 3) and (len(nc) == 0)
  print("OK")

suite_sequence = unittest.TestLoader().loadTestsFromTestCase(
  test_sequence
  )
suite_fasta_sequence = unittest.TestLoader().loadTestsFromTestCase(
  test_fasta_sequence
  )
suite_pir_sequence = unittest.TestLoader().loadTestsFromTestCase(
  test_pir_sequence
  )
suite_midline = unittest.TestLoader().loadTestsFromTestCase(
  test_midline
  )
suite_alignment = unittest.TestLoader().loadTestsFromTestCase(
  test_alignment
  )
suite_fasta_alignment = unittest.TestLoader().loadTestsFromTestCase(
  test_fasta_alignment
  )
suite_pir_alignment = unittest.TestLoader().loadTestsFromTestCase(
  test_pir_alignment
  )
suite_clustal_alignment = unittest.TestLoader().loadTestsFromTestCase(
  test_clustal_alignment
  )
suite_sequence_parse = unittest.TestLoader().loadTestsFromTestCase(
    test_sequence_parse
    )
suite_alignment_parse = unittest.TestLoader().loadTestsFromTestCase(
    test_alignment_parse
    )
suite_hhsearch_parser = unittest.TestLoader().loadTestsFromTestCase(
    test_hhsearch_parser
    )
suite_hhalign_parser = unittest.TestLoader().loadTestsFromTestCase(
    test_hhalign_parser
    )

alltests = unittest.TestSuite(
  [
    suite_sequence,
    suite_fasta_sequence,
    suite_pir_sequence,
    suite_midline,
    suite_alignment,
    suite_fasta_alignment,
    suite_pir_alignment,
    suite_clustal_alignment,
    suite_sequence_parse,
    suite_alignment_parse,
    suite_hhsearch_parser,
    suite_hhalign_parser,
    ]
  )

if __name__ == "__main__":
  exercise_read_a3m()
  exercise_guess_chain_types()
  exercise_merge_sequences()
  exercise_random_sequences()
  unittest.TextTestRunner( stream=sys.stdout, verbosity = 2 ).run( alltests )


 *******************************************************************************


 *******************************************************************************
iotbx/regression/tst_box_around_molecule.py
from __future__ import absolute_import, division, print_function
import libtbx.load_env
from libtbx import easy_run
from libtbx.test_utils import assert_lines_in_file

pdb_str = """\
ATOM      1  N   SER 1  71      10.595  29.158 114.534  1.00300.00           N
ATOM      2  CA  SER 1  71      10.156  30.582 114.477  1.00300.00           C
ATOM      3  C   SER 1  71      11.003  31.474 115.392  1.00300.00           C
ATOM      4  O   SER 1  71      10.892  31.400 116.622  1.00300.00           O
"""

# ------------------------------------------------------------------------------

cif_str = """\
data_default
loop_
  _atom_site.group_PDB
  _atom_site.id
  _atom_site.label_atom_id
  _atom_site.label_alt_id
  _atom_site.label_comp_id
  _atom_site.auth_asym_id
  _atom_site.auth_seq_id
  _atom_site.pdbx_PDB_ins_code
  _atom_site.Cartn_x
  _atom_site.Cartn_y
  _atom_site.Cartn_z
  _atom_site.occupancy
  _atom_site.B_iso_or_equiv
  _atom_site.type_symbol
  _atom_site.pdbx_formal_charge
  _atom_site.label_asym_id
  _atom_site.label_entity_id
  _atom_site.label_seq_id
  _atom_site.pdbx_PDB_model_num
   ATOM 1 N . PRO H 14 ? 5.39400 6.71500 9.04100 1.000 20.43000 N ? A ? 1 1
   ATOM 2 CA . PRO H 14 ? 6.20600 7.23200 10.14700 1.000 20.01000 C ? A ? 1 1
   ATOM 3 C . PRO H 14 ? 7.24800 8.27800 9.73800 1.000 20.76000 C ? A ? 1 1
   ATOM 4 O . PRO H 14 ? 7.79100 8.23500 8.63500 1.000 16.34000 O ? A ? 1 1
"""
# ------------------------------------------------------------------------------

def exercise(prefix="tst_pdb_box_around_mol"):
  # test pdb format
  with open("%s.pdb" % prefix, 'w') as f:
    f.write(pdb_str)
  assert not easy_run.call("iotbx.pdb.box_around_molecule %s.pdb" % (
      prefix))
  assert_lines_in_file(file_name="%s_box_000.pdb" % prefix,
    lines="""\
CRYST1   10.847   12.316   12.145  90.00  90.00  90.00 P 1
SCALE1      0.092191  0.000000  0.000000        0.00000
SCALE2      0.000000  0.081195  0.000000        0.00000
SCALE3      0.000000  0.000000  0.082338        0.00000
ATOM      1  N   SER 1  71       5.439   5.000   5.057  1.00300.00           N
ATOM      2  CA  SER 1  71       5.000   6.424   5.000  1.00300.00           C
ATOM      3  C   SER 1  71       5.847   7.316   5.915  1.00300.00           C
ATOM      4  O   SER 1  71       5.736   7.242   7.145  1.00300.00           O
TER""")
  # test mmcif format
  if libtbx.env.find_in_repositories(relative_path='chem_data') is not None:
    with open("%s.cif" % prefix, 'w') as f:
      f.write(cif_str)
    assert not easy_run.call("iotbx.pdb.box_around_molecule %s.cif" % (
        prefix))
    # XXX temp fix for python3 failure
    # XXX changes in python 3 because _cell.length_a and other order differs

    # Python 3 behavior looks better.
    # Reason for this discrepancy is that starting from Python 3.7
    # "the insertion-order preservation nature of dict objects has been
    # declared to be an official part of the Python language spec."
    # https://docs.python.org/3/whatsnew/3.7.html
    # Basically, dict.keys() in Py3 preserves the order in which keys were added
    # to the dict.
    #
    # Sorting of mmCIF keys here
    # cctbx_project/iotbx/cif/__init__.py, def category_sort_function()
    # should be improved to address such issues universally (sorting within
    # category), note the diference in _space_group and _symmetry categories
    # as well.

    import sys
    if sys.version_info.major == 3:
      assert_lines_in_file(file_name="%s_box_000.cif" % prefix,
      lines="""\
data_default
_cell.length_a                    12.397
_cell.length_b                    11.563
_cell.length_c                    11.512
_cell.angle_alpha                 90.000
_cell.angle_beta                  90.000
_cell.angle_gamma                 90.000
_cell.volume                      1650.205
_space_group.crystal_system       triclinic
_space_group.IT_number            1
_space_group.name_H-M_alt         'P 1'
_space_group.name_Hall            ' P 1'
_symmetry.space_group_name_H-M    'P 1'
_symmetry.space_group_name_Hall   ' P 1'
_symmetry.Int_Tables_number       1
loop_
  _space_group_symop.id
  _space_group_symop.operation_xyz
   1 x,y,z""")
    else: # version 2.7
      assert_lines_in_file(file_name="%s_box_000.cif" % prefix,
      lines="""\
data_default
_cell.angle_beta                  90.000
_cell.angle_gamma                 90.000
_cell.length_b                    11.563
_cell.length_c                    11.512
_cell.angle_alpha                 90.000
_cell.volume                      1650.205
_cell.length_a                    12.397
_space_group.crystal_system       triclinic
_space_group.name_H-M_alt         'P 1'
_space_group.IT_number            1
_space_group.name_Hall            ' P 1'
_symmetry.space_group_name_H-M    'P 1'
_symmetry.Int_Tables_number       1
_symmetry.space_group_name_Hall   ' P 1'
loop_
  _space_group_symop.id
  _space_group_symop.operation_xyz
   1 x,y,z""")

  else:
    print('chem_data is not available, skipping')

  print("OK")

# ------------------------------------------------------------------------------

if __name__=="__main__":
  exercise()


 *******************************************************************************


 *******************************************************************************
iotbx/regression/tst_cif_1.py
from __future__ import absolute_import, division, print_function
import time
import mmtbx.model
import iotbx.pdb
from libtbx.utils import null_out

# ------------------------------------------------------------------------------

def run():
  """
  Test that MTRIX matrix is not applied if it is referred to as
  "given" and it is not under loop_.
  """
  inp = iotbx.pdb.input(lines=mmcif_str.split("\n"), source_info=None)
  #inp = iotbx.pdb.input('5aj2_test.cif')
  m = mmtbx.model.manager(model_input = inp,log = null_out())
  p = m.get_hierarchy()
  #p.overall_counts().show()
  chains = list(p.overall_counts().chain_ids.keys())
  chains.sort()
  answer = ['A', 'B', 'C']
  assert (chains == answer), '%s %s' % (chains, answer)

mmcif_str = '''
data_5AJ2
#
_cell.entry_id           5AJ2
_cell.length_a           1.000
_cell.length_b           1.000
_cell.length_c           1.000
_cell.angle_alpha        90.00
_cell.angle_beta         90.00
_cell.angle_gamma        90.00
_cell.Z_PDB              1
_cell.pdbx_unique_axis   ?
#
_symmetry.entry_id                         5AJ2
_symmetry.space_group_name_H-M             'P 1'
_symmetry.pdbx_full_space_group_name_H-M   ?
_symmetry.cell_setting                     ?
_symmetry.Int_Tables_number                1
#
_struct_ncs_oper.id             1
_struct_ncs_oper.code           given
_struct_ncs_oper.details        ?
_struct_ncs_oper.matrix[1][1]   0.858065
_struct_ncs_oper.matrix[1][2]   0.000000
_struct_ncs_oper.matrix[1][3]   0.513541
_struct_ncs_oper.matrix[2][1]   0.000000
_struct_ncs_oper.matrix[2][2]   1.000000
_struct_ncs_oper.matrix[2][3]   0.000000
_struct_ncs_oper.matrix[3][1]   -0.513541
_struct_ncs_oper.matrix[3][2]   0.000000
_struct_ncs_oper.matrix[3][3]   0.858065
_struct_ncs_oper.vector[1]      -131.70160
_struct_ncs_oper.vector[2]      5.57000
_struct_ncs_oper.vector[3]      173.48700
#
loop_
_atom_site.group_PDB
_atom_site.id
_atom_site.type_symbol
_atom_site.label_atom_id
_atom_site.label_alt_id
_atom_site.label_comp_id
_atom_site.label_asym_id
_atom_site.label_entity_id
_atom_site.label_seq_id
_atom_site.pdbx_PDB_ins_code
_atom_site.Cartn_x
_atom_site.Cartn_y
_atom_site.Cartn_z
_atom_site.occupancy
_atom_site.B_iso_or_equiv
_atom_site.pdbx_formal_charge
_atom_site.auth_seq_id
_atom_site.auth_comp_id
_atom_site.auth_asym_id
_atom_site.auth_atom_id
_atom_site.pdbx_PDB_model_num
ATOM 1   C CA . VAL A 1 93  ? 265.910 287.538 371.741 1.00 65.63  ? 93   VAL A CA 1
ATOM 2   C CA . THR A 1 94  ? 263.468 290.283 372.749 1.00 75.26  ? 94   THR A CA 1
ATOM 3   C CA . GLU A 1 95  ? 263.384 291.733 376.277 1.00 36.70  ? 95   GLU A CA 1
ATOM 4   C CA . GLU A 1 96  ? 259.609 291.836 376.486 1.00 59.29  ? 96   GLU A CA 1
ATOM 5   C CA . ASP A 1 97  ? 259.526 288.058 375.892 1.00 55.35  ? 97   ASP A CA 1
ATOM 6   C CA . LEU A 1 98  ? 261.809 287.789 378.893 1.00 19.26  ? 98   LEU A CA 1
ATOM 7   C CA . ASN A 1 99  ? 259.447 289.832 381.026 1.00 24.16  ? 99   ASN A CA 1
ATOM 8   C CA . VAL A 1 100 ? 256.439 287.714 380.038 1.00 10.60  ? 100  VAL A CA 1
ATOM 264 C CA . ALA B 2 1   ? 253.610 250.832 414.360 1.00 26.29  ? 356  ALA B CA 1
ATOM 265 C CA . HIS B 2 2   ? 257.043 250.568 415.989 1.00 21.06  ? 357  HIS B CA 1
ATOM 266 C CA . THR B 2 3   ? 259.058 250.909 412.773 1.00 5.95   ? 358  THR B CA 1
ATOM 267 C CA . GLN B 2 4   ? 258.465 252.946 409.610 1.00 4.25   ? 359  GLN B CA 1
ATOM 268 C CA . THR B 2 5   ? 258.221 249.640 407.755 1.00 5.45   ? 360  THR B CA 1
ATOM 269 C CA . MET B 2 6   ? 255.270 248.643 409.910 1.00 34.55  ? 361  MET B CA 1
ATOM 270 C CA . LEU B 2 7   ? 253.772 252.095 409.294 1.00 5.13   ? 362  LEU B CA 1
ATOM 271 C CA . PHE B 2 8   ? 254.068 251.554 405.553 1.00 6.06   ? 363  PHE B CA 1
ATOM 272 C CA . GLN B 2 9   ? 252.690 248.038 406.042 1.00 19.38  ? 364  GLN B CA 1
ATOM 273 C CA . THR B 2 10  ? 249.682 249.259 408.001 1.00 6.76   ? 365  THR B CA 1
ATOM 489 C CA . GLN C 3 1   ? 291.310 230.862 413.727 1.00 13.26  ? 580  GLN C CA 1
ATOM 490 C CA . GLY C 3 2   ? 294.400 231.823 415.719 1.00 4.03   ? 581  GLY C CA 1
ATOM 491 C CA . LYS C 3 3   ? 294.558 235.261 414.129 1.00 4.01   ? 582  LYS C CA 1
ATOM 492 C CA . SER C 3 4   ? 294.108 238.876 415.238 1.00 10.15  ? 583  SER C CA 1
ATOM 493 C CA . LEU C 3 5   ? 291.813 241.792 414.393 1.00 6.63   ? 584  LEU C CA 1
ATOM 494 C CA . TYR C 3 6   ? 292.428 245.561 414.505 1.00 4.96   ? 585  TYR C CA 1
ATOM 495 C CA . ILE C 3 7   ? 289.616 248.010 415.243 1.00 4.50   ? 586  ILE C CA 1
ATOM 496 C CA . ASN C 3 8   ? 289.741 251.810 415.279 1.00 6.27   ? 587  ASN C CA 1
ATOM 497 C CA . SER C 3 9   ? 286.657 253.085 417.096 1.00 26.29  ? 588  SER C CA 1
ATOM 498 C CA . GLU C 3 10  ? 286.522 256.305 415.074 1.00 19.32  ? 589  GLU C CA 1
#
'''

# ------------------------------------------------------------------------------

if (__name__ == "__main__"):
  t0 = time.time()
  run()
  print("OK. Time: %8.3f"%(time.time()-t0))


 *******************************************************************************


 *******************************************************************************
iotbx/regression/tst_cif_as_pdb_1atom.py
from __future__ import absolute_import, division, print_function
import iotbx.pdb
import mmtbx.model
from libtbx.test_utils import show_diff


test_cif_str = """\
data_default
_cell.angle_beta                  107.080
_cell.angle_gamma                 90.000
_cell.length_b                    4.866
_cell.length_c                    23.477
_cell.angle_alpha                 90.000
_cell.volume                      2395.534
_cell.length_a                    21.937
_space_group.crystal_system       monoclinic
_space_group.name_H-M_alt         'P 1 21 1'
_space_group.IT_number            4
_space_group.name_Hall            ' P 2yb'
_symmetry.space_group_name_H-M    'P 1 21 1'
_symmetry.Int_Tables_number       4
_symmetry.space_group_name_Hall   ' P 2yb'

_atom_site.group_PDB ATOM
_atom_site.id 1
_atom_site.label_atom_id N
_atom_site.label_alt_id A
_atom_site.label_comp_id GLY
_atom_site.auth_asym_id A
_atom_site.auth_seq_id 1
_atom_site.pdbx_PDB_ins_code I
_atom_site.Cartn_x   -9.13600
_atom_site.Cartn_y  4.55200
_atom_site.Cartn_z  5.82700
_atom_site.occupancy  1.000
_atom_site.B_iso_or_equiv  18.49000
_atom_site.type_symbol  N
_atom_site.pdbx_formal_charge  ?
_atom_site.label_asym_id  A
_atom_site.label_entity_id  ?
_atom_site.label_seq_id  1
_atom_site.pdbx_PDB_model_num  1

_atom_site_anisotrop.id  1
_atom_site_anisotrop.pdbx_auth_atom_id  N
_atom_site_anisotrop.pdbx_label_alt_id  A
_atom_site_anisotrop.pdbx_auth_comp_id  GLY
_atom_site_anisotrop.pdbx_auth_asym_id  A
_atom_site_anisotrop.pdbx_auth_seq_id  1
_atom_site_anisotrop.pdbx_PDB_ins_code  I
_atom_site_anisotrop.U[1][1]  0.29030
_atom_site_anisotrop.U[2][2]  0.13360
_atom_site_anisotrop.U[3][3]  0.27880
_atom_site_anisotrop.U[1][2]  0.06870
_atom_site_anisotrop.U[1][3]  0.10560
_atom_site_anisotrop.U[2][3]  0.05900
"""

pdb_answer = """\
CRYST1   21.937    4.866   23.477  90.00 107.08  90.00 P 1 21 1
SCALE1      0.045585  0.000000  0.014006        0.00000
SCALE2      0.000000  0.205508  0.000000        0.00000
SCALE3      0.000000  0.000000  0.044560        0.00000
ATOM      1  N  AGLY A   1I     -9.136   4.552   5.827  1.00 18.49           N
ANISOU    1  N  AGLY A   1I    2903   1336   2788    687   1056    590       N
TER
END
"""

def exercise(prefix="tst_cif_as_pdb_1atom"):
  """ Note that cif contains only 1 atom and information is not wrapped into
  loops (loop_) as usual
  """
  cif_inp = iotbx.pdb.input(lines=test_cif_str, source_info=None)
  model = mmtbx.model.manager(model_input=cif_inp)
  pdb_txt = model.model_as_pdb()
  assert not show_diff(pdb_txt, pdb_answer)

if __name__ == '__main__':
  exercise()


 *******************************************************************************


 *******************************************************************************
iotbx/regression/tst_cli_parser.py
from __future__ import absolute_import, division, print_function

import os
import json

from multiprocessing import Process
from six.moves import cStringIO as StringIO

from iotbx.cli_parser import run_program
from iotbx.data_manager import DataManager
from libtbx.program_template import ProgramTemplate
from libtbx.utils import multi_out, Sorry
from libtbx.test_utils import Exception_expected, Exception_not_expected

# =============================================================================
def test_dry_run():
  class testProgram(ProgramTemplate):
    def validate(self):
      raise Sorry('This is a test')

  try:
    run_program(program_class=testProgram, args=['--dry-run', '--quiet'])
  except Sorry:
    pass
  else:
    raise Exception_expected

  class testProgram(ProgramTemplate):
    def validate(self):
      pass

  try:
    run_program(program_class=testProgram, args=['--dry-run', '--quiet'])
  except Exception:
    raise Exception_not_expected

# -----------------------------------------------------------------------------
def test_label_parsing():
  class testProgram(ProgramTemplate):
    program_name = 'tst_cli_parser'
    datatypes = ['miller_array', 'model', 'phil', 'restraint']
    def validate(self):
      pass
    def run(self):
      pass

  data_dir = os.path.dirname(os.path.abspath(__file__))
  data_mtz = os.path.join(data_dir, 'data',
                          'insulin_unmerged_cutted_from_ccp4.mtz')
  labels = ['M_ISYM', 'BATCH', 'I,SIGI,merged', 'IPR,SIGIPR,merged',
            'FRACTIONCALC', 'XDET', 'YDET', 'ROT', 'WIDTH', 'LP', 'MPART',
            'FLAG', 'BGPKRATIOS']
  phil_filename = testProgram.program_name + '_all.eff'

  # check label matching and parsing
  for phil_args, label_args in [
    (['labels.name'], ['xd']),
    (['labels.name', 'labels.name', 'labels.name'], ['XD', 'SIGI', 'WIDTH']),
    (['user_selected_labels', 'user_selected_labels', 'user_selected_labels'], ['YD', 'M_ISYM', 'IPR']),
    (['labels.name', 'user_selected_labels', 'user_selected_labels'], ['BATCH', 'FRACTION', 'BGP']),
    (['user_selected_labels', 'labels.name', 'user_selected_labels', 'labels.name'], ['LP', 'ROT', 'FLAG', 'SIGI'])
  ]:

    combined_args = ['{}={}'.format(phil_arg, label_arg) for phil_arg, label_arg in zip(phil_args, label_args)]

    parser_log = StringIO()
    logger = multi_out()
    logger.register('parser_log', parser_log)

    run_program(
      program_class=testProgram,
      args=['--overwrite', '--write-all', data_mtz] + combined_args,
      logger=logger)

    parser_log.flush()
    text = parser_log.getvalue()
    assert 'Combined labels PHIL' in text

    logger.close()

    dm = DataManager()
    dm.process_phil_file(phil_filename)
    working_phil = dm.master_phil.fetch(dm.get_phil())
    extract = working_phil.extract()
    for label in extract.data_manager.miller_array[0].labels:
      assert label.name in labels
    for label in label_args:
      assert label in extract.data_manager.miller_array[0].user_selected_labels

  os.remove(phil_filename)

  # check ambiguous label
  try:
    run_program(program_class=testProgram, args=['--quiet', data_mtz, 'labels.name=SIG'])
  except Sorry as s:
    assert 'The label, SIG' in str(s)
  try:
    run_program(program_class=testProgram, args=['--quiet', data_mtz, 'user_selected_label=SIG'])
  except Sorry as s:
    assert 'The label, SIG' in str(s)

# -----------------------------------------------------------------------------
def test_model_type_parsing():
  data_dir = os.path.dirname(os.path.abspath(__file__))
  model_1yjp = os.path.join(data_dir, 'data', '1yjp.pdb')
  model_2erl = os.path.join(data_dir, 'data', '2ERL.pdb')

  class testProgram(ProgramTemplate):

    datatypes = ['map_coefficients', 'miller_array', 'model', 'phil', 'real_map']

    def validate(self):
      pass

    def run(self):
      if self.data_manager.get_model_type(filename=model_1yjp) != ['neutron']:
        raise Sorry('1jyp should be neutron')
      if self.data_manager.get_model_type(filename=model_2erl) != ['electron']:
        raise Sorry('2erl should be electron')

  # model.type order matches input model order
  run_program(program_class=testProgram, args=[model_1yjp, model_2erl,
    'model.type=neutron', 'model.type=electron', '--quiet'])

  # other order will fail
  try:
    run_program(program_class=testProgram, args=[model_1yjp, model_2erl,
      'model.type=electron', 'model.type=neutron', '--quiet'])
  except Sorry as e:
    assert '1jyp' in str(e)
    assert 'neutron' in str(e)

  # and there needs to be a model.type for each model
  try:
    run_program(program_class=testProgram, args=[model_1yjp, model_2erl,
      'model.type=neutron', '--quiet'])
  except Sorry as e:
    assert 'Please specify exactly one "model.type" for each model' in str(e)

# -----------------------------------------------------------------------------
def test_user_selected_labels():
  data_dir = os.path.dirname(os.path.abspath(__file__))
  data_mtz = os.path.join(data_dir, 'data',
                          'insulin_unmerged_cutted_from_ccp4.mtz')

  class testProgram(ProgramTemplate):
    program_name = 'tst_cli_parser'
    datatypes = ['map_coefficients', 'miller_array', 'phil', 'real_map']
    master_phil_str = '''
other_file = None
  .type = path
'''
    def validate(self):
      pass
    def run(self):
      self.result = self.data_manager.get_miller_array_user_selected_labels(data_mtz)
      params = self.data_manager.export_phil_scope(as_extract=True)
      assert params.data_manager.miller_array[0].user_selected_labels == self.result
    def get_results(self):
      return self.result

  phil_name = 'user_selected.eff'

  # phil file with just the DataManager scope
  phil_one = '''
data_manager {
  miller_array {
    file = %s
    user_selected_labels = IPR,SIGIPR,merged
    user_selected_labels = FRACTIONCALC
  }
}
''' % data_mtz

  # phil file with the same file as a separate parameter
  phil_two = '''
data_manager {
  miller_array {
    file = %s
    user_selected_labels = IPR,SIGIPR,merged
    user_selected_labels = FRACTIONCALC
  }
}
other_file = %s
''' % (data_mtz, data_mtz)

  for phil in [phil_one, phil_two]:
    with open(phil_name, 'w') as f:
      f.write(phil)

    result = run_program(
      program_class=testProgram,
      args=['--quiet', '--overwrite', phil_name])

    assert len(result) == 2
    for label in result:
      assert label in ['FRACTIONCALC' ,'IPR,SIGIPR,merged']

  os.remove(phil_name)

  # duplicate user labels
  try:
    result = run_program(
      program_class=testProgram,
      args=['--quiet', '--overwrite', data_mtz,
            'miller_array.user_selected=WID',
            'miller_array.user_selected=WIDT'])
  except Sorry as s:
    assert 'duplicate user_selected_labels' in str(s)

  # map_coefficients.user_selected will not work on files without map coefficients
  try:
    result = run_program(
      program_class=testProgram,
      args=['--quiet', '--overwrite', data_mtz,
            'miller_array.user_selected=WID',
            'map_coefficients.user_selected=WIDT'])
  except Sorry as s:
    assert 'does not seem to have map_coefficients data' in str(s)

  # map_coefficients.user_selected_labels should be mirrored in
  # miller_array.user_selected_labels
  data_mtz = os.path.join(data_dir, 'data',
                          'phaser_1.mtz')
  class testProgram(ProgramTemplate):

    datatypes = ['map_coefficients', 'miller_array', 'phil', 'real_map']

    def validate(self):
      pass

    def run(self):
      ma_labels = self.data_manager.get_miller_array_user_selected_labels()
      mc_labels = self.data_manager.get_map_coefficients_user_selected_labels()
      print(ma_labels, file=self.logger)
      print(mc_labels, file=self.logger)
      assert ma_labels == mc_labels

  run_program(
    program_class=testProgram,
    args=['--quiet', '--overwrite', data_mtz,
          'map_coefficients.user_selected=FW']
  )

  run_program(
    program_class=testProgram,
    args=['--quiet', '--overwrite', data_mtz,
          'miller_array.user_selected=FW']
  )

  run_program(
    program_class=testProgram,
    args=['--quiet', '--overwrite', data_mtz,
          'map_coefficients.labels.name=FW']
  )

  run_program(
    program_class=testProgram,
    args=['--quiet', '--overwrite', data_mtz,
          'miller_array.labels.name=FW']
  )

  run_program(
    program_class=testProgram,
    args=['--quiet', '--overwrite', data_mtz,
          'map_coefficients.user_selected=FWT,PHIFWT']
  )

  run_program(
    program_class=testProgram,
    args=['--quiet', '--overwrite', data_mtz,
          'miller_array.user_selected=FWT,PHIFWT']
  )

  # non map_coefficients should not be copied
  try:
    run_program(
      program_class=testProgram,
      args=['--quiet', '--overwrite', data_mtz,
            'miller_array.user_selected=FP']
    )
  except AssertionError:
    pass

  # or used to select non map_coefficients data
  try:
    run_program(
      program_class=testProgram,
      args=['--quiet', '--overwrite', data_mtz,
            'map_coefficients.user_selected=FP']
    )
  except Sorry as s:
    assert 'is not recognized to be map_coefficients data' in str(s)

  try:
    run_program(
      program_class=testProgram,
      args=['--quiet', '--overwrite', data_mtz,
            'map_coefficients.user_selected=WT',
            'miller_array.user_selected=PHIF']
    )
  except Sorry as s:
    assert 'duplicate user_selected_labels' in str(s)

  try:
    run_program(
      program_class=testProgram,
      args=['--quiet', '--overwrite', data_mtz,
            'miller_array.user_selected=WT',
            'miller_array.user_selected=PHIF']
    )
  except Sorry as s:
    assert 'duplicate user_selected_labels' in str(s)

  try:
    run_program(
      program_class=testProgram,
      args=['--quiet', '--overwrite', data_mtz,
            'map_coefficients.user_selected=WT',
            'map_coefficients.user_selected=PHIF']
    )
  except Sorry as s:
    assert 'duplicate user_selected_labels' in str(s)

  try:
    run_program(
      program_class=testProgram,
      args=['--quiet', '--overwrite', data_mtz,
            'map_coefficients.labels.name=FWT,PHIFWT',
            'map_coefficients.user_selected=PHIF']
    )
  except Sorry as s:
    assert 'duplicate user_selected_labels' in str(s)

  try:
    run_program(
      program_class=testProgram,
      args=['--quiet', '--overwrite', data_mtz,
            'miller_array.labels.name=FWT,PHIFWT',
            'map_coefficients.user_selected=PHIF']
    )
  except Sorry as s:
    assert 'duplicate user_selected_labels' in str(s)

# -----------------------------------------------------------------------------
def test_update_all_defaults():

  data_dir = os.path.dirname(os.path.abspath(__file__))
  model_1yjp = os.path.join(data_dir, 'data', '1yjp.pdb')
  data_mtz = os.path.join(data_dir, 'data', 'phaser_1.mtz')

  class testProgram(ProgramTemplate):

    datatypes = ['model', 'miller_array', 'phil']

    def validate(self):
      pass

    def run(self):
      pass

    def get_results(self):
      return self.data_manager

  dm = run_program(
    program_class=testProgram,
    args=['--quiet', '--overwrite', model_1yjp, data_mtz]
  )
  dm.update_all_defaults('neutron')
  model_type = dm.get_model_type(model_1yjp)
  assert 'neutron' in model_type
  assert 'x_ray' not in model_type
  assert 'electron' not in model_type
  assert 'reference' not in model_type
  for label in dm.get_miller_array_all_labels(data_mtz):
    array_type = dm.get_miller_array_type(data_mtz, label)
    assert 'neutron' in array_type
    assert 'x_ray' not in array_type
    assert 'electron' not in array_type

  # check that all default types are updated even with label selection
  dm = run_program(
    program_class=testProgram,
    args=['--quiet', '--overwrite', model_1yjp, data_mtz,
          'user_selected=FWT,PHIFWT']
  )
  dm.update_all_defaults('electron')
  model_type = dm.get_model_type(model_1yjp)
  assert 'electron' in model_type
  assert 'x_ray' not in model_type
  assert 'neutron' not in model_type
  assert 'reference' not in model_type
  for label in dm.get_miller_array_all_labels(data_mtz):
    array_type = dm.get_miller_array_type(data_mtz, label)
    assert 'electron' in array_type
    assert 'x_ray' not in array_type
    assert 'neutron' not in array_type

  # check that reference type is kept
  dm = run_program(
    program_class=testProgram,
    args=['--quiet', '--overwrite', model_1yjp, data_mtz,
          'user_selected=FWT,PHIFWT']
  )
  dm.set_model_type(model_1yjp, ['reference'])
  dm.update_all_defaults('neutron')
  model_type = dm.get_model_type(model_1yjp)
  assert 'neutron' in model_type
  assert 'x_ray' not in model_type
  assert 'electron' not in model_type
  assert 'reference' in model_type

# -----------------------------------------------------------------------------
def test_json():
  class testProgram(ProgramTemplate):
    program_name = 'tst_cli_parser'
    datatypes = ['model', 'phil']
    def validate(self):
      pass
    def run(self):
      pass

  data_dir = os.path.dirname(os.path.abspath(__file__))
  model_1yjp = os.path.join(data_dir, 'data', '1yjp.pdb')

  # check for get_results_as_JSON function
  parser_log = StringIO()
  logger = multi_out()
  logger.register('parser_log', parser_log)

  run_program(
    program_class=testProgram,
    args=['--overwrite', '--json', model_1yjp],
    logger=parser_log
  )

  parser_log.flush()
  text = parser_log.getvalue()
  assert 'WARNING: The get_results_as_JSON function has not been defined for this program' in text

  logger.close()

  # check that json file is output
  expected_result = {'key': 'value'}
  class testProgram(ProgramTemplate):
    program_name = 'tst_cli_parser'
    datatypes = ['model', 'phil']
    def validate(self):
      pass
    def run(self):
      pass
    def get_results_as_JSON(self):
      dummy_results = expected_result
      return json.dumps(dummy_results, indent=2)

  run_program(
    program_class=testProgram,
    args=['--quiet', '--overwrite', '--json', model_1yjp]
  )

  expected_filename = 'tst_cli_parser_result.json'
  assert os.path.exists(expected_filename)
  with open(expected_filename, 'r') as f:
    result = json.loads(f.read())
  assert result == expected_result
  os.remove(expected_filename)

  # check non-default filename
  expected_filename = 'non-default.json'
  run_program(
    program_class=testProgram,
    args=['--quiet', '--overwrite', '--json',
          '--json-filename', expected_filename, model_1yjp]
  )
  assert os.path.exists(expected_filename)
  with open(expected_filename, 'r') as f:
    result = json.loads(f.read())
  assert result == expected_result
  os.remove(expected_filename)

  # try only with --json_filename and without .json extension
  filename = 'non-default'
  run_program(
    program_class=testProgram,
    args=['--quiet', '--overwrite',
          '--json_filename', filename, model_1yjp]
  )
  assert os.path.exists(expected_filename)
  with open(expected_filename, 'r') as f:
    result = json.loads(f.read())
  assert result == expected_result
  os.remove(expected_filename)

# -----------------------------------------------------------------------------
# since --diff-params calls sys.exit, run in a separate process
class testProgram(ProgramTemplate):
  program_name = 'test_diff_params'
  master_phil_str = '''
diff_test_parameter = None
.type = str
another_parameter = None
.type = str
'''
  def run():
    pass
  def validate(self):
    pass

def run_diff_program(args):
  return run_program(program_class=testProgram, args=args)

def run_function_in_process(args):
  p = Process(target=run_diff_program, args=[args])
  p.start()
  p.join()

def test_diff_params():

  expected_filename = 'test_diff_params_modified.eff'
  if os.path.exists(expected_filename):
    os.remove(expected_filename)

  # no diff
  args = ['--quiet', '--diff-params']
  run_function_in_process(args)
  assert not os.path.exists(expected_filename)

  # program diff
  args = ['--quiet', '--diff-params', 'diff_test=abc']
  run_function_in_process(args)
  with open(expected_filename, 'r') as f:
    text = f.read()
    assert 'diff_test_parameter = abc' in text.strip(), text

  # DataManager diff
  data_dir = os.path.dirname(os.path.abspath(__file__))
  model_1yjp = os.path.join(data_dir, 'data', '1yjp.pdb')
  args = [model_1yjp, '--quiet', '--diff-params']
  run_function_in_process(args)
  with open(expected_filename, 'r') as f:
    text = f.read()
    assert text.count('1yjp.pdb') == 2, text
    assert 'diff_test_parameter' not in text.strip(), text

  # both diff
  args = ['--quiet', '--diff-params', model_1yjp, 'diff_test=abc']
  run_function_in_process(args)
  with open(expected_filename, 'r') as f:
    text = f.read()
    assert text.count('1yjp.pdb') == 2, text
    assert 'diff_test_parameter' in text.strip(), text

  # phil file
  test_phil = '''\
data_manager {
  model {
    file = not_a_real_filename.pdb
  }
}
diff_test_parameter = abc
another_parameter = def
'''
  with open('phil_file.eff', 'w') as f:
    f.write(test_phil)
  args = ['--quiet', '--diff-params', 'phil_file.eff']
  run_function_in_process(args)
  with open(expected_filename, 'r') as f:
    text = f.read()
    assert text.count('not_a_real_filename.pdb') == 1, text
    assert 'diff_test_parameter = abc' in text
    assert 'another_parameter = def' in text

  # multiple phil files with different orders
  test_phil_a = '''\
another_parameter = ghi
'''
  test_phil_b = '''\
diff_test_parameter = jkl
'''
  test_phil_c = '''\
data_manager {
  model {
    file = possibly_a_real_filename.pdb
  }
}
'''
  with open('a.eff', 'w') as f:
    f.write(test_phil_a)
  with open('b.eff', 'w') as f:
    f.write(test_phil_b)
  with open('c.eff', 'w') as f:
    f.write(test_phil_c)
  args = ['--quiet', '--diff-params', 'phil_file.eff', 'a.eff']
  run_function_in_process(args)
  with open(expected_filename, 'r') as f:
    text = f.read()
    assert text.count('not_a_real_filename.pdb') == 1, text
    assert 'diff_test_parameter = abc' in text
    assert 'another_parameter = ghi' in text

  args = ['--quiet', '--diff-params', 'phil_file.eff', 'b.eff']
  run_function_in_process(args)
  with open(expected_filename, 'r') as f:
    text = f.read()
    assert text.count('not_a_real_filename.pdb') == 1, text
    assert 'diff_test_parameter = jkl' in text
    assert 'another_parameter = def' in text

  args = ['--quiet', '--diff-params', 'phil_file.eff', 'a.eff', 'b.eff']
  run_function_in_process(args)
  with open(expected_filename, 'r') as f:
    text = f.read()
    assert text.count('not_a_real_filename.pdb') == 1, text
    assert 'diff_test_parameter = jkl' in text
    assert 'another_parameter = ghi' in text

  args = ['--quiet', '--diff-params', 'a.eff', 'b.eff', 'phil_file.eff']
  run_function_in_process(args)
  with open(expected_filename, 'r') as f:
    text = f.read()
    assert text.count('not_a_real_filename.pdb') == 1, text
    assert 'diff_test_parameter = abc' in text
    assert 'another_parameter = def' in text

  args = ['--quiet', '--diff-params', 'phil_file.eff', 'a.eff', 'b.eff', 'c.eff']
  run_function_in_process(args)
  with open(expected_filename, 'r') as f:
    text = f.read()
    assert text.count('not_a_real_filename.pdb') == 1, text
    assert text.count('possibly_a_real_filename.pdb') == 1, text
    assert 'diff_test_parameter = jkl' in text
    assert 'another_parameter = ghi' in text

  # modify settings in file with command-line argument
  args = ['--quiet', '--diff-params', 'phil_file.eff', 'a.eff', 'b.eff', 'c.eff', 'another_parameter=mno']
  run_function_in_process(args)
  with open(expected_filename, 'r') as f:
    text = f.read()
    assert text.count('not_a_real_filename.pdb') == 1, text
    assert text.count('possibly_a_real_filename.pdb') == 1, text
    assert 'diff_test_parameter = jkl' in text
    assert 'another_parameter = mno' in text

  for filename in [expected_filename, 'phil_file.eff', 'a.eff', 'b.eff',
                  'c.eff']:
    if os.path.isfile(filename):
      os.remove(filename)

# -----------------------------------------------------------------------------
def test_check_current_dir():
  data_dir = os.path.dirname(os.path.abspath(__file__))
  model_1yjp = os.path.join(data_dir, 'data', '1yjp.pdb')

  test_filename = 'check_current_dir_model.pdb'
  with open(model_1yjp, 'r') as fread:
    model_text = fread.read()
    with open(test_filename, 'w') as fwrite:
      fwrite.write(model_text)

  original_phil = '''\
data_manager {
  model {
    file = %s
  }
}
''' % os.path.join(data_dir, test_filename)
  phil_filename = 'check_current_dir.eff'
  with open(phil_filename, 'w') as f:
    f.write(original_phil)

  class testProgram(ProgramTemplate):
    program_name = 'tst_cli_parser'

    def validate(self):
      pass

    def run(self):
      pass

    def get_results(self):
      return self.data_manager.get_model_names()

  # check for missing file
  try:
    run_program(program_class=testProgram, args=[phil_filename, '--quiet'])
  except Sorry as s:
    assert "Couldn't find the file" in str(s)

  # check --check-current-dir
  result = run_program(program_class=testProgram,
                       args=[phil_filename, '--check-current-dir', '--quiet'])
  expected_filename = os.path.join(os.getcwd(), test_filename)
  assert expected_filename in result, result

  for filename in [test_filename, phil_filename]:
    if os.path.isfile(filename):
      os.remove(filename)

# -----------------------------------------------------------------------------
def test_scattering_table():

  class TestScatteringTableProgram(ProgramTemplate):

    datatypes = ['model', 'phil']

    use_scattering_table_for_default_type = 'a.b.c.d.efgh'

    master_phil_str = """\
a {
  b {
    c {
      d {
        efgh = electron
          .type = str
      }
    }
  }
}
"""

    def validate(self):
      pass

    def run(self):
      pass

    def get_results(self):
      return self.data_manager

  data_dir = os.path.dirname(os.path.abspath(__file__))
  model_1yjp = os.path.join(data_dir, 'data', '1yjp.pdb')
  data_mtz = os.path.join(data_dir, 'data', 'phaser_1.mtz')

  # check that both model and miller_array are required
  try:
    dm = run_program(TestScatteringTableProgram,
                    args=['--quiet', model_1yjp, data_mtz])
  except Sorry as s:
    assert 'use_scattering_table_for_default_type' in str(s)

  TestScatteringTableProgram.datatypes = ['miller_array', 'model', 'phil']

  # check default PHIL
  dm = run_program(TestScatteringTableProgram,
                   args=['--quiet', model_1yjp, data_mtz])
  model_type = dm.get_model_type(model_1yjp)
  assert 'x_ray' not in model_type
  assert 'electron' in model_type
  assert 'neutron' not in model_type
  assert 'reference' not in model_type

  # check modified PHIL
  dm = run_program(TestScatteringTableProgram,
                   args=['--quiet', 'efgh=neutron', model_1yjp, data_mtz])
  model_type = dm.get_model_type(model_1yjp)
  assert 'x_ray' not in model_type
  assert 'electron' not in model_type
  assert 'neutron' in model_type
  assert 'reference' not in model_type

  # check wrong input
  try:
    dm = run_program(TestScatteringTableProgram,
                    args=['--quiet', 'efgh=not_a_type', model_1yjp, data_mtz])
  except Sorry as s:
    assert 'not_a_type' in str(s)

# =============================================================================
if __name__ == '__main__':
  test_dry_run()
  test_label_parsing()
  test_model_type_parsing()
  test_user_selected_labels()
  test_update_all_defaults()
  test_json()
  test_diff_params()
  test_check_current_dir()
  test_scattering_table()

  print("OK")


 *******************************************************************************


 *******************************************************************************
iotbx/regression/tst_crystal_symmetry_from_any.py
from __future__ import absolute_import, division, print_function
from iotbx import crystal_symmetry_from_any

def exercise():
  space_group = "P1"
  unit_cell = "100,100,100,90,90,90"
  symmetry = unit_cell+","+space_group
  sp_space_group = " P 1 "
  sp_symmetry = unit_cell+","+sp_space_group
  killer="100,P1"
  killer2=space_group+","+unit_cell
  killer3="100 100 100 90 90 90"
  killer4=killer3+" "+sp_space_group

  cs = crystal_symmetry_from_any.from_string(space_group)
  assert(cs is not None)
  assert(cs.unit_cell() is None)
  assert(str(cs.space_group_info())=='P 1')

  cs = crystal_symmetry_from_any.from_string(unit_cell)
  assert(cs is not None)
  assert(cs.unit_cell().parameters()==(100.0,100.0,100.0,90.0,90.0,90.0))
  assert(cs.space_group_info() is None)

  cs = crystal_symmetry_from_any.from_string(symmetry)
  assert(cs is not None)
  assert(cs.unit_cell().parameters()==(100.0,100.0,100.0,90.0,90.0,90.0))
  assert(str(cs.space_group_info())=='P 1')

  cs = crystal_symmetry_from_any.from_string(sp_space_group)
  assert(cs is not None)
  assert(cs.unit_cell() is None)
  assert(str(cs.space_group_info())=='P 1')

  cs = crystal_symmetry_from_any.from_string(sp_symmetry)
  assert(cs is not None)
  assert(cs.unit_cell().parameters()==(100.0,100.0,100.0,90.0,90.0,90.0))
  assert(str(cs.space_group_info())=='P 1')

  cs = crystal_symmetry_from_any.from_string(killer)
  assert(cs is None)

  cs = crystal_symmetry_from_any.from_string(killer2)
  assert(cs is None)

  cs = crystal_symmetry_from_any.from_string(killer3)
  assert(cs is None)

  cs = crystal_symmetry_from_any.from_string(killer4)
  assert(cs is None)

  print("OK")

if __name__=="__main__":
  exercise()


 *******************************************************************************


 *******************************************************************************
iotbx/regression/tst_csv_utils.py
from __future__ import absolute_import, division, print_function
from scitbx.array_family import flex
from libtbx.test_utils import open_tmp_file, Exception_expected
from six.moves import zip

def exercise():
  exercise_writer()
  exercise_reader()

def exercise_writer():
  from iotbx import csv_utils

  x = (1,2,3,4,5)
  y = (6,7,8,9,10)
  f = open_tmp_file()
  field_names = ('x','y')
  csv_utils.writer(f, (x,y), field_names=field_names)
  f.close()
  f = open(f.name, 'r')
  content = [l.strip() for l in f.readlines()]

  text = ['x,y']
  text += ['%s,%s' %(row[0],row[1]) for row in zip(x,y)]
  assert content == text
  f.close()

  x = (1,2,3,4,5)
  y = (6,7,8,9,10)
  f = open_tmp_file()
  csv_utils.writer(f, (x,y), delimiter=';')
  f.close()
  f = open(f.name, 'r')
  content = [l.strip() for l in f.readlines()]
  text = ['%s;%s' %(row[0],row[1]) for row in zip(x,y)]
  assert content == text
  f.close()

  x = flex.int(x)
  y = flex.int(y)
  f = open_tmp_file()
  csv_utils.writer(f, (x,y), field_names=field_names)
  f.close()
  f = open(f.name, 'r')
  content = [l.strip() for l in f.readlines()]
  text = ['x,y']
  text += ['%s,%s' %(row[0],row[1]) for row in zip(x,y)]
  assert content == text
  f.close()

  y.append(11)
  f = open_tmp_file()
  try:
    csv_utils.writer(f, (x,y), field_names=field_names)
  except AssertionError:
    pass
  else:
    raise Exception_expected
  f.close()


def exercise_reader():
  from iotbx import csv_utils

  x = (1,2,3,4,5)
  y = (6,7,8,9,10)
  f = open_tmp_file()
  field_names = ('x','y')
  csv_utils.writer(f, (x,y), field_names=field_names,delimiter=';')
  f.close()
  f = open(f.name, 'r')
  a = csv_utils.reader(f, data_type=int, field_names=True,delimiter=';')
  f.close()
  assert tuple(a.data[0]) == x
  assert tuple(a.data[1]) == y

  x = (1,2,3,4,5)
  y = (1.1,2.2,3.3,4.4,5.5)
  f = open_tmp_file()
  csv_utils.writer(f, (x,y))
  f.close()
  f = open(f.name, 'r')
  data_type_list = (int, float)
  a = csv_utils.reader(f, data_type_list=data_type_list)
  f.close()
  assert tuple(a.data[0]) == x
  assert tuple(a.data[1]) == y

  f = open(f.name, 'r')
  data_type_list = (int, float)
  try:
    a = csv_utils.reader(f, data_type=int,
                         data_type_list=data_type_list)
    # Can't pass data_type AND data_type_list
  except AssertionError:
    pass
  else:
    raise Exception_expected
  f.close()

  f = open(f.name, 'r')
  a = csv_utils.reader(f)
  f.close()
  assert list(a.data[0]) == [str(i) for i in x]
  assert list(a.data[1]) == [str(i) for i in y]

def run():
  exercise()
  print("OK")

if __name__ == '__main__':
  run()


 *******************************************************************************


 *******************************************************************************
iotbx/regression/tst_data_manager.py
from __future__ import absolute_import, division, print_function

import os

import iotbx.phil
import libtbx.load_env
import libtbx.phil

from cctbx import crystal
from libtbx.program_template import ProgramTemplate
from libtbx.utils import Sorry
from iotbx.data_manager import DataManager
from six.moves import zip

# -----------------------------------------------------------------------------
def test_data_manager():
  a = DataManager(['model'])

  a.add_model('a', 'b')
  a.add_model('c', 'd')
  assert a.get_model() == 'b'
  assert a.get_model('a') == 'b'
  assert a.get_model('c') == 'd'
  assert a.get_model_names() == ['a', 'c']

  assert a.has_models()
  assert a.has_models(exact_count=True, expected_n=2)
  assert not a.has_models(expected_n=3, raise_sorry=False)

  # exporting phil
  working_phil = a.export_phil_scope()
  assert len(working_phil.extract().data_manager.model) == 2

  # data tracking
  try:
    a.has_models(expected_n=3, raise_sorry=True)
  except Sorry:
    pass

  try:
    a.has_models(exact_count=True, raise_sorry=True)
  except Sorry:
    pass

  a.set_default_model('c')
  assert a.get_model() == 'd'

  assert a.get_model_names() == ['a', 'c'] or a.get_model_names() == ['c', 'a']

  a.remove_model('c')
  try:
    a.get_model()
  except Sorry:
    pass
  try:
    a.get_model('missing')
  except Sorry:
    pass
  try:
    a.set_default_model('missing')
  except Sorry:
    pass

  a = DataManager(datatypes=['sequence', 'phil'])
  assert a.get_sequence_names() == []
  assert not hasattr(a, 'get_model')

  # phil functions
  test_phil_str = '''
data_manager {
  phil_files = data_manager_test.eff
}
'''
  with open('data_manager_test.eff', 'w') as f:
    f.write(test_phil_str)

  # loading file with get function
  assert len(a.get_phil_names()) == 0
  p = a.get_phil('data_manager_test.eff')
  assert isinstance(p, libtbx.phil.scope)
  assert 'data_manager_test.eff' in a.get_phil_names()

  # loading file with phil
  a = DataManager(datatypes=['phil'])
  test_phil = iotbx.phil.parse(test_phil_str)
  a.load_phil_scope(test_phil)

  assert 'data_manager_test.eff' in a.get_phil_names()
  assert a.get_default_phil_name() == 'data_manager_test.eff'

  os.remove('data_manager_test.eff')

  # writing
  a = DataManager(datatypes=['model', 'phil', 'sequence'])
  a.add_model('a','b')
  a.add_phil('c','d')
  a.add_sequence('e','f')

  a.write_model_file(a.get_model(), filename='a.dat', overwrite=True)
  a.write_phil_file(a.get_phil(), filename='c.dat', overwrite=True)
  a.write_sequence_file(a.get_sequence(), filename='e.dat', overwrite=True)

  with open('a.dat', 'r') as f:
    lines = f.readlines()
  assert lines[0] == 'b'

  os.remove('a.dat')
  os.remove('c.dat')
  os.remove('e.dat')

  # check datatypes with parent
  datatypes = ['miller_array', 'map_coefficients']
  dm = DataManager(datatypes=datatypes)
  assert len(dm.datatypes) == len(datatypes)

  datatypes = ['miller_array', 'map_coefficients', 'phil', 'model']
  dm = DataManager(datatypes=datatypes)
  assert len(dm.datatypes) == len(datatypes)

  datatypes = ['phil', 'model', 'miller_array', 'map_coefficients',]
  dm = DataManager(datatypes=datatypes)
  assert len(dm.datatypes) == len(datatypes)

# -----------------------------------------------------------------------------
def test_model_datatype():
  import mmtbx.monomer_library.server
  try:
    mon_lib_srv = mmtbx.monomer_library.server.server()
  except mmtbx.monomer_library.server.MonomerLibraryServerError:
    print("Can not initialize monomer_library, skipping test_model_datatype.")
    return

  # 1yjp
  model_str = '''
CRYST1   21.937    4.866   23.477  90.00 107.08  90.00 P 1 21 1      2
ORIGX1      1.000000  0.000000  0.000000        0.00000
ORIGX2      0.000000  1.000000  0.000000        0.00000
ORIGX3      0.000000  0.000000  1.000000        0.00000
SCALE1      0.045585  0.000000  0.014006        0.00000
SCALE2      0.000000  0.205508  0.000000        0.00000
SCALE3      0.000000  0.000000  0.044560        0.00000
ATOM      1  N   GLY A   1      -9.009   4.612   6.102  1.00 16.77           N
ATOM      2  CA  GLY A   1      -9.052   4.207   4.651  1.00 16.57           C
ATOM      3  C   GLY A   1      -8.015   3.140   4.419  1.00 16.16           C
ATOM      4  O   GLY A   1      -7.523   2.521   5.381  1.00 16.78           O
ATOM      5  N   ASN A   2      -7.656   2.923   3.155  1.00 15.02           N
ATOM      6  CA  ASN A   2      -6.522   2.038   2.831  1.00 14.10           C
ATOM      7  C   ASN A   2      -5.241   2.537   3.427  1.00 13.13           C
ATOM      8  O   ASN A   2      -4.978   3.742   3.426  1.00 11.91           O
ATOM      9  CB  ASN A   2      -6.346   1.881   1.341  1.00 15.38           C
ATOM     10  CG  ASN A   2      -7.584   1.342   0.692  1.00 14.08           C
ATOM     11  OD1 ASN A   2      -8.025   0.227   1.016  1.00 17.46           O
ATOM     12  ND2 ASN A   2      -8.204   2.155  -0.169  1.00 11.72           N
ATOM     13  N   ASN A   3      -4.438   1.590   3.905  1.00 12.26           N
ATOM     14  CA  ASN A   3      -3.193   1.904   4.589  1.00 11.74           C
ATOM     15  C   ASN A   3      -1.955   1.332   3.895  1.00 11.10           C
ATOM     16  O   ASN A   3      -1.872   0.119   3.648  1.00 10.42           O
ATOM     17  CB  ASN A   3      -3.259   1.378   6.042  1.00 12.15           C
ATOM     18  CG  ASN A   3      -2.006   1.739   6.861  1.00 12.82           C
ATOM     19  OD1 ASN A   3      -1.702   2.925   7.072  1.00 15.05           O
ATOM     20  ND2 ASN A   3      -1.271   0.715   7.306  1.00 13.48           N
ATOM     21  N   GLN A   4      -1.005   2.228   3.598  1.00 10.29           N
ATOM     22  CA  GLN A   4       0.384   1.888   3.199  1.00 10.53           C
ATOM     23  C   GLN A   4       1.435   2.606   4.088  1.00 10.24           C
ATOM     24  O   GLN A   4       1.547   3.843   4.115  1.00  8.86           O
ATOM     25  CB  GLN A   4       0.656   2.148   1.711  1.00  9.80           C
ATOM     26  CG  GLN A   4       1.944   1.458   1.213  1.00 10.25           C
ATOM     27  CD  GLN A   4       2.504   2.044  -0.089  1.00 12.43           C
ATOM     28  OE1 GLN A   4       2.744   3.268  -0.190  1.00 14.62           O
ATOM     29  NE2 GLN A   4       2.750   1.161  -1.091  1.00  9.05           N
ATOM     30  N   GLN A   5       2.154   1.821   4.871  1.00 10.38           N
ATOM     31  CA  GLN A   5       3.270   2.361   5.640  1.00 11.39           C
ATOM     32  C   GLN A   5       4.594   1.768   5.172  1.00 11.52           C
ATOM     33  O   GLN A   5       4.768   0.546   5.054  1.00 12.05           O
ATOM     34  CB  GLN A   5       3.056   2.183   7.147  1.00 11.96           C
ATOM     35  CG  GLN A   5       1.829   2.950   7.647  1.00 10.81           C
ATOM     36  CD  GLN A   5       1.344   2.414   8.954  1.00 13.10           C
ATOM     37  OE1 GLN A   5       0.774   1.325   9.002  1.00 10.65           O
ATOM     38  NE2 GLN A   5       1.549   3.187  10.039  1.00 12.30           N
ATOM     39  N   ASN A   6       5.514   2.664   4.856  1.00 11.99           N
ATOM     40  CA  ASN A   6       6.831   2.310   4.318  1.00 12.30           C
ATOM     41  C   ASN A   6       7.854   2.761   5.324  1.00 13.40           C
ATOM     42  O   ASN A   6       8.219   3.943   5.374  1.00 13.92           O
ATOM     43  CB  ASN A   6       7.065   3.016   2.993  1.00 12.13           C
ATOM     44  CG  ASN A   6       5.961   2.735   2.003  1.00 12.77           C
ATOM     45  OD1 ASN A   6       5.798   1.604   1.551  1.00 14.27           O
ATOM     46  ND2 ASN A   6       5.195   3.747   1.679  1.00 10.07           N
ATOM     47  N   TYR A   7       8.292   1.817   6.147  1.00 14.70           N
ATOM     48  CA  TYR A   7       9.159   2.144   7.299  1.00 15.18           C
ATOM     49  C   TYR A   7      10.603   2.331   6.885  1.00 15.91           C
ATOM     50  O   TYR A   7      11.041   1.811   5.855  1.00 15.76           O
ATOM     51  CB  TYR A   7       9.061   1.065   8.369  1.00 15.35           C
ATOM     52  CG  TYR A   7       7.665   0.929   8.902  1.00 14.45           C
ATOM     53  CD1 TYR A   7       6.771   0.021   8.327  1.00 15.68           C
ATOM     54  CD2 TYR A   7       7.210   1.756   9.920  1.00 14.80           C
ATOM     55  CE1 TYR A   7       5.480  -0.094   8.796  1.00 13.46           C
ATOM     56  CE2 TYR A   7       5.904   1.649  10.416  1.00 14.33           C
ATOM     57  CZ  TYR A   7       5.047   0.729   9.831  1.00 15.09           C
ATOM     58  OH  TYR A   7       3.766   0.589  10.291  1.00 14.39           O
ATOM     59  OXT TYR A   7      11.358   2.999   7.612  1.00 17.49           O
TER      60      TYR A   7
HETATM   61  O   HOH A   8      -6.471   5.227   7.124  1.00 22.62           O
HETATM   62  O   HOH A   9      10.431   1.858   3.216  1.00 19.71           O
HETATM   63  O   HOH A  10     -11.286   1.756  -1.468  1.00 17.08           O
HETATM   64  O   HOH A  11      11.808   4.179   9.970  1.00 23.99           O
HETATM   65  O   HOH A  12      13.605   1.327   9.198  1.00 26.17           O
HETATM   66  O   HOH A  13      -2.749   3.429  10.024  1.00 39.15           O
HETATM   67  O   HOH A  14      -1.500   0.682  10.967  1.00 43.49           O
MASTER      238    0    0    0    0    0    0    6   66    1    0    1
END
'''

  # test reading/writing PDB
  test_filename = 'test_model.pdb'
  test_output_filename = 'test_model_output.pdb'
  test_eff = 'model.eff'
  dm = DataManager(['model'])
  dm.process_model_str(test_filename, model_str)
  dm.write_model_file(model_str, filename=test_output_filename, overwrite=True)
  m = dm.get_model(test_output_filename)
  assert test_output_filename in dm.get_model_names()
  dm.write_model_file(m, overwrite=True)
  pdb_filename = 'cctbx_program.pdb'
  assert os.path.exists(pdb_filename)
  dm.process_model_file(pdb_filename)
  assert not dm.get_model(pdb_filename).input_model_format_cif()
  dm.write_model_file(m, test_filename, overwrite=True)
  os.remove(test_output_filename)

  # test reading PDB writing CIF
  test_filename = 'test_model.pdb'
  test_output_filename = 'test_model.cif'
  dm = DataManager(['model'])
  dm.process_model_str(test_filename, model_str)
  m = dm.get_model(test_filename)
  dm.write_model_file(m, filename=test_output_filename, format='cif',
      overwrite=True)
  m = dm.get_model(test_output_filename)
  assert test_output_filename in dm.get_model_names()
  dm.write_model_file(m, overwrite=True)
  cif_filename = 'cctbx_program.cif'
  assert os.path.exists(cif_filename)
  dm.process_model_file(cif_filename)
  assert dm.get_model(cif_filename).input_model_format_cif()

  # test type
  assert dm.get_model_type() == ['x_ray']
  dm.set_model_type(test_filename, ['neutron'])
  assert dm.get_model_type() == ['neutron']
  phil_scope = dm.export_phil_scope()
  extract = phil_scope.extract()
  assert extract.data_manager.model[0].type == ['neutron']
  with open(test_eff, 'w') as f:
    f.write(phil_scope.as_str())
  new_phil_scope = iotbx.phil.parse(file_name=test_eff)
  new_dm = DataManager(['model'])
  new_dm.load_phil_scope(new_phil_scope)
  assert new_dm.get_model_type(test_filename) == ['neutron']
  new_dm = DataManager(['model'])
  try:
    new_dm.set_default_model_type(['nonsense'])
  except Sorry as s:
    assert 'Unrecognized' in str(s)
  # single model_type
  new_dm.set_default_model_type(['electron'])
  new_dm.process_model_file(test_filename)
  assert new_dm.get_model_type() == ['electron']
  assert len(new_dm.get_model_names()) == 1
  assert len(new_dm.get_model_names(model_type='x_ray')) == 0
  assert len(new_dm.get_model_names(model_type='electron')) == 1
  assert len(new_dm.get_model_names(model_type='neutron')) == 0
  assert len(new_dm.get_model_names(model_type='reference')) == 0
  # multiple model_type
  new_dm.set_model_type(filename=test_filename, model_type=['x_ray', 'reference'])
  assert len(new_dm.get_model_names(model_type='x_ray')) == 1
  assert len(new_dm.get_model_names(model_type='electron')) == 0
  assert len(new_dm.get_model_names(model_type='neutron')) == 0
  assert len(new_dm.get_model_names(model_type='reference')) == 1
  new_dm.set_model_type(filename=test_filename, model_type=['x_ray', 'neutron'])
  try:
    new_dm.get_model(filename=test_filename)
  except Sorry as s:
    assert 'There is more than one model type' in str(s)
  try:
    new_dm.get_model(filename=test_filename, model_type='electron')
  except Sorry as s:
    assert 'electron, is not one of the types' in str(s)
  try:
    new_dm.get_model(filename=test_filename, model_type='not_a_valid_type')
  except Sorry as s:
    assert 'type, "not_a_valid_type' in str(s)
  # check for copy
  new_dm.set_model_type(filename=test_filename, model_type=['electron'])
  model = new_dm.get_model(filename=test_filename)
  test_model = new_dm.get_model(filename=test_filename, model_type='electron')
  assert test_model is model
  new_dm.set_model_type(filename=test_filename, model_type=['electron', 'neutron'])
  test_model = new_dm.get_model(filename=test_filename, model_type='electron')
  assert test_model is model
  test_model = new_dm.get_model(filename=test_filename, model_type='neutron')
  assert test_model is not model

  # check PHIL
  new_dm.set_model_type(filename=test_filename, model_type=['x_ray', 'reference'])
  multiple_type_phil_str = new_dm.export_phil_scope().as_str()
  multiple_type_phil = iotbx.phil.parse(multiple_type_phil_str)
  new_dm = DataManager(phil=multiple_type_phil)
  assert new_dm.get_model_names()[0] == test_filename
  assert len(new_dm.get_model_names(model_type='x_ray')) == 1
  assert len(new_dm.get_model_names(model_type='electron')) == 0
  assert len(new_dm.get_model_names(model_type='neutron')) == 0
  assert len(new_dm.get_model_names(model_type='reference')) == 1
  try:
    new_dm.set_model_type(filename=test_filename, model_type=['electron', 'nonsense'])
  except Sorry as s:
    assert 'Unrecognized' in str(s)

  # check processing file by getting the object
  dm = DataManager(['model', 'phil'])
  assert test_output_filename not in dm.get_model_names()
  dm.get_model(test_output_filename)
  assert test_output_filename in dm.get_model_names()
  try:
    dm.get_model('model.eff')
  except Sorry as s:
    assert 'not a recognized model file' in str(s)
  assert test_filename not in dm.get_phil_names()
  try:
    dm.get_phil(test_filename)
  except Sorry as s:
    assert 'not a recognized phil file' in str(s)

  # check processing file by setting a default
  dm = DataManager(['model', 'phil'])
  assert test_output_filename not in dm.get_model_names()
  dm.set_default_model(test_output_filename)
  assert 'does_not_exist.pdb' not in dm.get_model_names()
  try:
    dm.set_default_model('does_not_exist.pdb')
  except Sorry as s:
    assert 'find the file does_not_exist.pdb' in str(s)
  assert 'model.eff' not in dm.get_model_names()
  try:
    dm.set_default_model('model.eff')
  except Sorry as s:
    assert 'not a recognized model file' in str(s)
  assert test_filename not in dm.get_phil_names()
  try:
    dm.set_default_phil(test_filename)
  except Sorry as s:
    assert 'not a recognized phil file' in str(s)

  os.remove(test_eff)
  os.remove(test_filename)
  os.remove(test_output_filename)

  # test reading/writing CIF
  test_filename = 'test_model_datatype.cif'
  dm.write_model_file(dm.get_model().model_as_mmcif(),
                      filename=test_filename, overwrite=True)
  dm.process_model_file(test_filename)
  os.remove(test_filename)
  assert test_filename in dm.get_model_names()
  m = dm.get_model(test_filename)
  dm.write_model_file(m, overwrite=True)
  cif_filename = 'cctbx_program.cif'
  assert os.path.exists(cif_filename)
  dm.process_model_file(cif_filename)
  assert dm.get_model(cif_filename).input_model_format_cif()
  os.remove(pdb_filename)
  os.remove(cif_filename)

# -----------------------------------------------------------------------------
def test_model_and_restraint():

  # from 3tpj
  model_str = '''
CRYST1  104.428  128.690   76.662  90.00  90.00  90.00 C 2 2 21
ATOM   5877  O   URE A 403     -37.796 -38.296   5.693  1.00 15.43           O
ATOM   5878  C   URE A 403     -36.624 -38.509   5.800  1.00 20.53           C
ATOM   5879  N2  URE A 403     -36.191 -39.836   6.120  1.00 27.82           N
ATOM   5880  N1  URE A 403     -35.679 -37.450   5.644  1.00 21.36           N
ATOM   5881 HN11 URE A 403     -34.792 -37.617   5.732  1.00 25.63           H
ATOM   5882 HN12 URE A 403     -35.965 -36.613   5.445  1.00 25.63           H
ATOM   5883 HN21 URE A 403     -35.307 -40.015   6.211  1.00 33.38           H
ATOM   5884 HN22 URE A 403     -36.801 -40.499   6.221  1.00 33.38           H
'''

  restraint_str = '''
#
data_comp_list
loop_
_chem_comp.id
_chem_comp.three_letter_code
_chem_comp.name
_chem_comp.group
_chem_comp.number_atoms_all
_chem_comp.number_atoms_nh
_chem_comp.desc_level
URE URE Unknown                   ligand 8 4 .
#
data_comp_URE
#
loop_
_chem_comp_atom.comp_id
_chem_comp_atom.atom_id
_chem_comp_atom.type_symbol
_chem_comp_atom.type_energy
_chem_comp_atom.partial_charge
_chem_comp_atom.x
_chem_comp_atom.y
_chem_comp_atom.z
URE        C       C   C     .          0.4968   -0.0000   -0.0000
URE        O       O   O     .          1.7184   -0.0000   -0.0000
URE        N1      N   NH2   .         -0.2180   -0.0000    1.2381
URE        N2      N   NH2   .         -0.2180    0.0000   -1.2381
URE        HN11    H   HNH2  .          0.2355   -0.0000    2.0237
URE        HN12    H   HNH2  .         -1.1251    0.0000    1.2382
URE        HN21    H   HNH2  .          0.2355    0.0000   -2.0237
URE        HN22    H   HNH2  .         -1.1251   -0.0000   -1.2382
#
loop_
_chem_comp_bond.comp_id
_chem_comp_bond.atom_id_1
_chem_comp_bond.atom_id_2
_chem_comp_bond.type
_chem_comp_bond.value_dist
_chem_comp_bond.value_dist_esd
URE  C       O      double        1.222 0.020
URE  C       N1     single        1.430 0.020
URE  C       N2     single        1.430 0.020
URE  N1      HN11   single        0.907 0.020
URE  N1      HN12   single        0.907 0.020
URE  N2      HN21   single        0.907 0.020
URE  N2      HN22   single        0.907 0.020
#
loop_
_chem_comp_angle.comp_id
_chem_comp_angle.atom_id_1
_chem_comp_angle.atom_id_2
_chem_comp_angle.atom_id_3
_chem_comp_angle.value_angle
_chem_comp_angle.value_angle_esd
URE  N2      C       N1           120.00 3.000
URE  N2      C       O            120.00 3.000
URE  N1      C       O            120.00 3.000
URE  HN12    N1      HN11         120.00 3.000
URE  HN12    N1      C            120.00 3.000
URE  HN11    N1      C            120.00 3.000
URE  HN22    N2      HN21         120.00 3.000
URE  HN22    N2      C            120.00 3.000
URE  HN21    N2      C            120.00 3.000
#
loop_
_chem_comp_tor.comp_id
_chem_comp_tor.id
_chem_comp_tor.atom_id_1
_chem_comp_tor.atom_id_2
_chem_comp_tor.atom_id_3
_chem_comp_tor.atom_id_4
_chem_comp_tor.value_angle
_chem_comp_tor.value_angle_esd
_chem_comp_tor.period
URE CONST_01      HN11    N1      C       O              0.00   0.0 0
URE CONST_02      HN12    N1      C       O            180.00   0.0 0
URE CONST_03      HN21    N2      C       O             -0.00   0.0 0
URE CONST_04      HN22    N2      C       O            180.00   0.0 0
URE CONST_05      HN21    N2      C       N1           180.00   0.0 0
URE CONST_06      HN22    N2      C       N1            -0.00   0.0 0
URE CONST_07      HN11    N1      C       N2          -180.00   0.0 0
URE CONST_08      HN12    N1      C       N2            -0.00   0.0 0
#
loop_
_chem_comp_plane_atom.comp_id
_chem_comp_plane_atom.plane_id
_chem_comp_plane_atom.atom_id
_chem_comp_plane_atom.dist_esd
URE plan-1  C      0.020
URE plan-1  O      0.020
URE plan-1  N1     0.020
URE plan-1  N2     0.020
URE plan-1  HN11   0.020
URE plan-1  HN12   0.020
URE plan-1  HN21   0.020
URE plan-1  HN22   0.020
'''

  model_filename = 'ure.pdb'
  restraint_filename = 'ure.cif'

  dm = DataManager(['model', 'restraint'])
  dm.write_model_file(model_str, filename=model_filename, overwrite=True)
  dm.write_restraint_file(restraint_str, filename=restraint_filename,
                          overwrite=True)

  # fails because no restraints are loaded
  dm.process_model_file(model_filename)
  model = dm.get_model()
  try:
    model.get_restraints_manager()
  except Sorry:
    pass

  # automatically add restraints
  dm.process_restraint_file(restraint_filename)
  model = dm.get_model()
  model.get_restraints_manager()

  os.remove(model_filename)
  os.remove(restraint_filename)

# -----------------------------------------------------------------------------
def test_sequence_datatype():

  # 1sar.fa
  seq_filename = 'test_seq.fa'
  seq_str = '''>1SAR A
DVSGTVCLSALPPEATDTLNLIASDGPFPYSQDGVVFQNRESVLPTQSYGYYHEYTVITPGARTRGTRRIICGEATQEDY
YTGDHYATFSLIDQTC
'''

  with open(seq_filename, 'w') as f:
    f.write(seq_str)

  dm = DataManager(['sequence'])
  dm.process_sequence_file(seq_filename)
  assert seq_filename in dm.get_sequence_names()

  seq = dm.get_sequence()
  new_str = dm.get_sequence_as_string(seq_filename)
  for a, b in zip(new_str, seq_str):
    assert a == b

  os.remove(seq_filename)

# -----------------------------------------------------------------------------
def test_miller_array_datatype():

  data_dir = os.path.dirname(os.path.abspath(__file__))
  data_mtz = os.path.join(data_dir, 'data',
                          'insulin_unmerged_cutted_from_ccp4.mtz')

  dm = DataManager(['miller_array', 'phil'])
  dm.process_miller_array_file(data_mtz)

  # test labels
  labels = ['M_ISYM', 'BATCH', 'I,SIGI,merged', 'IPR,SIGIPR,merged',
            'FRACTIONCALC', 'XDET', 'YDET', 'ROT', 'WIDTH', 'LP', 'MPART',
            'FLAG', 'BGPKRATIOS']
  for label in dm.get_miller_array_all_labels():
    assert label in labels

  assert len(dm.get_miller_arrays()) == len(dm.get_miller_array_all_labels())

  # test access by label
  label = dm.get_miller_array_all_labels()[3]
  new_label = dm.get_miller_arrays(labels=[label])[0].info().label_string()
  assert label == new_label

  # test custom PHIL
  dm.write_phil_file(dm.export_phil_scope().as_str(),
                     filename='test.phil', overwrite=True)
  loaded_phil = iotbx.phil.parse(file_name='test.phil')
  new_dm = DataManager(['miller_array', 'phil'])
  new_dm.load_phil_scope(loaded_phil)
  assert data_mtz == new_dm.get_default_miller_array_name()
  for label in new_dm.get_miller_array_all_labels():
    assert label in labels

  os.remove('test.phil')

  # test type
  assert dm.get_miller_array_type() == ['x_ray']
  dm.set_miller_array_user_selected_labels()
  label = labels[3]
  dm.set_miller_array_type(data_mtz, label, ['electron'])
  assert dm.get_miller_array_type(label=label) == ['electron']
  dm.write_phil_file(dm.export_phil_scope().as_str(),
                     filename='test_phil', overwrite=True)
  loaded_phil = iotbx.phil.parse(file_name='test_phil')
  new_dm.load_phil_scope(loaded_phil)
  assert new_dm.get_miller_array_type(label=label) == ['electron']
  new_dm = DataManager(['miller_array'])
  try:
    new_dm.set_default_miller_array_type(['q'])
  except Sorry as s:
    assert 'Unrecognized miller_array type, "q,"' in str(s)
  new_dm.set_default_miller_array_type(['neutron'])
  new_dm.process_miller_array_file(data_mtz)
  assert new_dm.get_miller_array_type(label=label) == ['neutron']
  os.remove('test_phil')

  # test array_type
  assert dm.get_miller_array_array_type() == 'integer'
  label = labels[6]
  dm.set_miller_array_array_type(data_mtz, label, 'nonsense')
  assert dm.get_miller_array_array_type(label=label) == 'nonsense'
  dm.write_phil_file(dm.export_phil_scope().as_str(),
                     filename='test_phil', overwrite=True)
  loaded_phil = iotbx.phil.parse(file_name='test_phil')
  new_dm.load_phil_scope(loaded_phil)
  assert new_dm.get_miller_array_array_type(label=label) == 'nonsense'
  new_dm = DataManager(['miller_array'])
  try:
    new_dm.set_default_miller_array_array_type('q')
  except Sorry as s:
    assert 'Unrecognized miller_array type, "q,"' in str(s)
  new_dm.set_default_miller_array_array_type('intensity')
  new_dm.process_miller_array_file(data_mtz)
  assert new_dm.get_miller_array_array_type(label=label) == 'intensity'

  os.remove('test_phil')

  # test writing file
  arrays = dm.get_miller_arrays()
  dataset = arrays[2].as_mtz_dataset(column_root_label='label1')
  dataset.add_miller_array(miller_array=arrays[3], column_root_label='label2')
  mtz_object = dataset.mtz_object()
  dm.write_miller_array_file(mtz_object, filename='test.mtz', overwrite=True)
  dm.process_miller_array_file('test.mtz')
  new_labels = dm.get_miller_array_all_labels('test.mtz')
  assert 'label1,SIGlabel1' in new_labels
  assert 'label2,SIGlabel2' in new_labels

  os.remove('test.mtz')

  # test file server
  dm.set_miller_array_user_selected_labels(labels=[])
  fs1 = dm.get_reflection_file_server()
  fs2 = dm.get_reflection_file_server([data_mtz, 'test.mtz'])
  assert len(fs1.miller_arrays) == len(fs2.miller_arrays)
  cs = crystal.symmetry(
    unit_cell=dm.get_miller_arrays()[0].crystal_symmetry().unit_cell(),
    space_group_symbol='P1')
  fs = dm.get_reflection_file_server(crystal_symmetry=cs)
  assert fs.crystal_symmetry.is_similar_symmetry(cs)
  assert not fs.crystal_symmetry.is_similar_symmetry(
    dm.get_miller_arrays()[0].crystal_symmetry())
  fs = dm.get_reflection_file_server(labels=[None, ['I,SIGI,merged']])
  assert len(fs.get_miller_arrays(None)) == len(labels)
  fs = dm.get_reflection_file_server(labels=[['I,SIGI,merged']])
  assert len(fs.get_miller_arrays(None)) == 3
  fs = dm.get_reflection_file_server(labels=[['I,SIGI,merged'], ['label1,SIGlabel1']])
  assert len(fs.get_miller_arrays(None)) == 2
  fs = dm.get_reflection_file_server(labels=[['I,SIGI,merged'], ['label2,SIGlabel2']])
  assert len(fs.get_miller_arrays(None)) == 2
  fs = dm.get_reflection_file_server(labels=[['I,SIGI,merged'],
                                             ['label1,SIGlabel1', 'label2,SIGlabel2']])
  assert len(fs.get_miller_arrays(None)) == 3
  fs = dm.get_reflection_file_server(labels=[['I,SIGI,merged'], ['I,SIGI,merged']])
  assert len(fs.get_miller_arrays(None)) == 1
  miller_array = fs.get_amplitudes(None, None, True, None, None)
  assert miller_array.info().label_string() == 'I,as_amplitude_array,merged'

  for label in dm.get_miller_array_all_labels():
    dm.set_miller_array_type(label=label, array_type=['electron'])
  fs = dm.get_reflection_file_server(array_type='x_ray')
  assert len(fs.get_miller_arrays(None)) == 2
  fs = dm.get_reflection_file_server(array_type='electron')
  assert len(fs.get_miller_arrays(None)) == 13
  fs = dm.get_reflection_file_server(filenames=[data_mtz],
    labels=[['I,SIGI,merged', 'IPR,SIGIPR,merged']], array_type='neutron')
  assert fs is None
  for label in ['I,SIGI,merged', 'IPR,SIGIPR,merged']:
    dm.set_miller_array_type(label=label, array_type=['x_ray'])
  fs = dm.get_reflection_file_server(filenames=[data_mtz],
    labels=[['I,SIGI,merged', 'IPR,SIGIPR,merged']], array_type='x_ray')
  assert len(fs.get_miller_arrays(data_mtz)) == 2
  fs = dm.get_reflection_file_server(filenames=[data_mtz], array_type='x_ray')
  assert len(fs.get_miller_arrays(data_mtz)) == 2
  fs = dm.get_reflection_file_server(filenames=[data_mtz], array_type='electron')
  assert len(fs.get_miller_arrays(data_mtz)) == 11

  # test subset of labels
  label_subset = labels[3:8]
  dm = DataManager(['miller_array', 'phil'])
  dm.process_miller_array_file(data_mtz)
  dm.set_miller_array_user_selected_labels(labels=label_subset)
  dm.set_miller_array_type(label=label_subset[2], array_type=['electron'])
  assert dm.get_miller_array_type(label=label_subset[2]) == ['electron']
  dm.write_phil_file(dm.export_phil_scope().as_str(), filename='test.phil',
                     overwrite=True)
  loaded_phil = iotbx.phil.parse(file_name='test.phil')
  new_dm = DataManager(['miller_array', 'phil'])
  new_dm.load_phil_scope(loaded_phil)
  assert new_dm.get_miller_array_type(label=label_subset[2]) == ['electron']
  fs = new_dm.get_reflection_file_server(array_type='x_ray', labels=[label_subset])
  assert len(fs.get_miller_arrays(None)) == 4
  fs = new_dm.get_reflection_file_server(array_type='electron', labels=[label_subset])
  assert len(fs.get_miller_arrays(None)) == 1
  os.remove('test.phil')

  label_subset = list()
  dm = DataManager(['miller_array', 'phil'])
  dm.process_miller_array_file(data_mtz)
  dm.write_phil_file(dm.export_phil_scope().as_str(), filename='test.phil',
                     overwrite=True)
  loaded_phil = iotbx.phil.parse(file_name='test.phil')
  new_dm = DataManager(['miller_array', 'phil'])
  new_dm.load_phil_scope(loaded_phil)
  fs = new_dm.get_reflection_file_server(array_type='x_ray')
  assert len(fs.get_miller_arrays(None)) == 13
  fs = new_dm.get_reflection_file_server(array_type='electron')
  assert fs is None
  os.remove('test.phil')

# -----------------------------------------------------------------------------
def test_real_map_datatype():

  data_dir = os.path.dirname(os.path.abspath(__file__))
  data_ccp4 = os.path.join(data_dir, 'data',
                          'non_zero_origin_map.ccp4')

  dm = DataManager(['real_map', 'phil'])
  dm.process_real_map_file(data_ccp4)
  assert dm.has_real_maps()

  # test custom PHIL
  dm.write_phil_file(dm.export_phil_scope().as_str(),
                     filename='test.phil', overwrite=True)
  loaded_phil = iotbx.phil.parse(file_name='test.phil')
  new_dm = DataManager(['real_map', 'phil'])
  new_dm.load_phil_scope(loaded_phil)
  assert data_ccp4 == new_dm.get_default_real_map_name()
  os.remove('test.phil')

  # test writing and reading file
  mm = dm.get_real_map()
  mm.shift_origin()
  dm.write_real_map_file(mm, filename='test.ccp4', overwrite=True)
  dm.process_real_map_file('test.ccp4')
  new_mm = dm.get_real_map('test.ccp4')
  assert not new_mm.is_similar(mm)
  new_mm.shift_origin()
  assert new_mm.is_similar(mm)

  os.remove('test.ccp4')

# -----------------------------------------------------------------------------
def test_map_mixins():
  dm = DataManager(['real_map'])
  assert not hasattr(dm, 'has_real_maps_or_map_coefficients')
  assert hasattr(dm, 'has_real_maps')
  assert not hasattr(dm, 'has_map_coefficients')

  dm = DataManager(['map_coefficients'])
  assert not hasattr(dm, 'has_real_maps_or_map_coefficients')
  assert not hasattr(dm, 'has_real_maps')
  assert hasattr(dm, 'has_map_coefficients')

  dm = DataManager()
  assert hasattr(dm, 'has_real_maps_or_map_coefficients')
  assert hasattr(dm, 'has_real_maps')
  assert hasattr(dm, 'has_map_coefficients')

  real_map_file = libtbx.env.under_dist('iotbx', 'regression/data/D7.ccp4')
  map_coefficients_file = 'D7.mtz'
  m = dm.get_real_map(real_map_file)
  mc = m.map_as_fourier_coefficients(d_min=3)
  mtz_dataset = mc.as_mtz_dataset(column_root_label='F')
  mtz_object=mtz_dataset.mtz_object()
  dm.write_miller_array_file(mtz_object, filename=map_coefficients_file)

  dm = DataManager()
  assert not dm.has_real_maps_or_map_coefficients(expected_n=1, exact_count=True)
  dm.process_real_map_file(real_map_file)
  assert dm.has_real_maps(expected_n=1, exact_count=True)
  assert dm.has_real_maps_or_map_coefficients(expected_n=1, exact_count=True)
  dm.process_map_coefficients_file(map_coefficients_file)
  assert dm.has_map_coefficients(expected_n=1, exact_count=True)
  assert not dm.has_real_maps_or_map_coefficients(expected_n=1, exact_count=True)
  assert dm.has_real_maps_or_map_coefficients(expected_n=1, exact_count=False)
  assert dm.has_real_maps_or_map_coefficients(expected_n=2, exact_count=True)

  os.remove(map_coefficients_file)

# -----------------------------------------------------------------------------
def test_default_filenames():
  datatypes = ['model', 'ncs_spec', 'phil', 'real_map', 'restraint', 'sequence']
  extensions = ['cif', 'ncs_spec', 'eff', 'ccp4', 'cif', 'seq']
  dm = DataManager(datatypes)
  for datatype, extension in zip(datatypes, extensions):
    filename = getattr(dm, 'get_default_output_{datatype}_filename'.
                       format(datatype=datatype))()
    assert filename == 'cctbx_program.' + extension

  filename = dm.get_default_output_model_filename(extension='.abc')
  assert filename == 'cctbx_program.abc'

  class TestProgram(ProgramTemplate):
    master_phil_str = """
output {
  serial = 0
    .type = int
}
"""
  master_phil = iotbx.phil.parse(TestProgram.master_phil_str)
  required_output_phil = iotbx.phil.parse(ProgramTemplate.output_phil_str)
  master_phil.adopt_scope(required_output_phil)
  working_phil = iotbx.phil.parse(ProgramTemplate.master_phil_str)
  params = master_phil.fetch(working_phil).extract()
  p = ProgramTemplate(dm, params, master_phil)
  assert dm.get_default_output_filename() == 'cctbx_program_000'
  dm.set_overwrite(False)
  name = dm.write_model_file('abc')    # cctbx_program_000.cif
  assert name == 'cctbx_program_000.cif'
  name = dm.write_phil_file('123')     # cctbx_program_000.eff
  assert name == 'cctbx_program_000.eff'
  name = dm.write_phil_file('456')     # cctbx_program_001.eff
  assert name == 'cctbx_program_001.eff'
  name = dm.write_model_file('def')    # cctbx_program_001.cif
  assert name == 'cctbx_program_001.cif'
  assert dm.get_default_output_filename() == 'cctbx_program_001'
  name = dm.write_sequence_file('ghi') # cctbx_program_001.seq
  assert name == 'cctbx_program_001.seq'
  name = dm.write_sequence_file('hkl') # cctbx_program_002.seq
  assert name == 'cctbx_program_002.seq'
  assert dm.get_default_output_filename() == 'cctbx_program_002'
  assert os.path.isfile('cctbx_program_000.cif')
  assert os.path.isfile('cctbx_program_001.cif')
  assert os.path.isfile('cctbx_program_000.eff')
  assert os.path.isfile('cctbx_program_001.eff')
  assert os.path.isfile('cctbx_program_001.seq')
  assert os.path.isfile('cctbx_program_002.seq')
  os.remove('cctbx_program_000.cif')
  os.remove('cctbx_program_001.cif')
  os.remove('cctbx_program_000.eff')
  os.remove('cctbx_program_001.eff')
  os.remove('cctbx_program_001.seq')
  os.remove('cctbx_program_002.seq')

  # test output.filename, output.file_name
  assert p.get_default_output_filename() == 'cctbx_program_002'
  assert p.get_default_output_filename(filename='abc') == 'abc'
  working_phil_str = 'output.filename=def'
  working_phil = iotbx.phil.parse(working_phil_str)
  params = master_phil.fetch(working_phil).extract()
  p = ProgramTemplate(dm, params, master_phil)
  assert params.output.filename == params.output.file_name == 'def'
  assert p.get_default_output_filename() == 'def'
  assert dm.get_default_output_filename() == 'def'
  working_phil_str = 'output.file_name=ghi'
  working_phil = iotbx.phil.parse(working_phil_str)
  params = master_phil.fetch(working_phil).extract()
  p = ProgramTemplate(dm, params, master_phil)
  assert params.output.filename == params.output.file_name == 'ghi'
  assert p.get_default_output_filename() == 'ghi'
  assert dm.get_default_output_filename() == 'ghi'

# -----------------------------------------------------------------------------
def test_model_skip_ss_annotations():
  good_h_str = 'HELIX    1   1 THR A   18  ILE A   20  5                                   3'
  bad_h_str = 'HELIX    1   1 THR A   18  ILE A   20 11                                   3'
  pdb_str = """
CRYST1   32.501   39.502   44.640  90.00  90.00  90.00 P 21 21 21    4
ATOM    265  N   THR A  18      13.114   7.968   6.956  1.00  4.57           N
ATOM    266  CA  THR A  18      13.581   6.907   6.105  1.00  4.76           C
ATOM    267  C   THR A  18      14.273   5.867   7.003  1.00  4.60           C
ATOM    268  O   THR A  18      14.631   6.110   8.149  1.00  4.40           O
ATOM    269  CB  THR A  18      14.556   7.447   5.032  1.00  5.62           C
ATOM    270  OG1 THR A  18      15.710   7.880   5.759  1.00  6.08           O
ATOM    271  CG2 THR A  18      13.937   8.551   4.219  1.00  7.48           C
ATOM    279  N   LEU A  19      14.528   4.681   6.410  1.00  5.15           N
ATOM    280  CA  LEU A  19      15.074   3.599   7.202  1.00  4.83           C
ATOM    281  C   LEU A  19      16.437   3.919   7.781  1.00  4.82           C
ATOM    282  O   LEU A  19      16.736   3.482   8.909  1.00  5.18           O
ATOM    283  CB  LEU A  19      15.111   2.303   6.373  1.00  5.60           C
ATOM    284  CG  LEU A  19      13.748   1.663   6.109  1.00  6.04           C
ATOM    285  CD1 LEU A  19      13.891   0.508   5.116  1.00  7.36           C
ATOM    286  CD2 LEU A  19      13.107   1.170   7.418  1.00  7.22           C
ATOM    298  N   ILE A  20      17.306   4.658   7.066  1.00  5.11           N
ATOM    299  CA  ILE A  20      18.645   4.933   7.588  1.00  5.24           C
ATOM    300  C   ILE A  20      18.601   5.767   8.844  1.00  4.94           C
ATOM    301  O   ILE A  20      19.565   5.822   9.609  1.00  5.92           O
ATOM    302  CB  ILE A  20      19.529   5.617   6.519  1.00  6.40           C
ATOM    303  CG1 ILE A  20      21.031   5.545   6.877  1.00  9.33           C
ATOM    304  CG2 ILE A  20      19.057   7.034   6.234  1.00  7.06           C
ATOM    305  CD1 ILE A  20      21.947   6.045   5.765  1.00 12.70           C
"""
  dm = DataManager(['model'])
  dm.write_model_file(good_h_str + pdb_str, filename='good', format='pdb', overwrite=True)
  dm.write_model_file(bad_h_str + pdb_str, filename='bad', format='pdb', overwrite=True)
  dm.process_model_file('good.pdb')
  try:
    dm.process_model_file('bad.pdb')
  except IndexError as e:
    assert str(e) == 'list index out of range'
  dm = DataManager(['model'], custom_options=['model_skip_ss_annotations'])
  dm.process_model_file('good.pdb')
  dm.process_model_file('bad.pdb')

  os.remove('good.pdb')
  os.remove('bad.pdb')

# -----------------------------------------------------------------------------
def test_fmodel_params():
  dm = DataManager(['model'])
  assert not hasattr(dm, 'get_fmodel_params')

  dm = DataManager(['miller_array'])
  params = dm.export_phil_scope(as_extract=True)
  assert not hasattr(params.data_manager, 'fmodel')

  dm = DataManager(['model', 'miller_array'])
  params = dm.get_fmodel_params()
  assert isinstance(params, libtbx.phil.scope_extract)

  phil = iotbx.phil.parse('data_manager.fmodel.xray_data.french_wilson.max_bins=1')
  dm.load_phil_scope(phil)
  params = dm.get_fmodel_params()
  assert params.xray_data.french_wilson.max_bins == 1

  new_params = dm.get_fmodel_params()
  new_params.xray_data.r_free_flags.test_flag_value = 2
  dm.set_fmodel_params(new_params)
  params = dm.get_fmodel_params()
  assert params.xray_data.r_free_flags.test_flag_value == 2

  new_params = dm.export_phil_scope(as_extract=True)
  new_params.data_manager.fmodel.xray_data.twin_law = 'h, k, l'
  dm.set_fmodel_params(new_params)
  params = dm.get_fmodel_params()
  assert params.xray_data.twin_law == 'h, k, l'
  assert params.xray_data.r_free_flags.test_flag_value == 2
  assert params.xray_data.french_wilson.max_bins == 1
  full_params = dm.export_phil_scope(as_extract=True)
  assert full_params.data_manager.fmodel.xray_data.twin_law == 'h, k, l'
  assert full_params.data_manager.fmodel.xray_data.r_free_flags.test_flag_value == 2
  assert full_params.data_manager.fmodel.xray_data.french_wilson.max_bins == 1

  # test updated defaults
  dm = DataManager(['model', 'miller_array'])
  data_dir = os.path.dirname(os.path.abspath(__file__))
  data_pdb = os.path.join(data_dir, 'data', '1yjp.pdb')
  data_pdb2 = os.path.join(data_dir, 'data', '2ERL.pdb')
  data_mtz = os.path.join(data_dir, 'data',
                          'insulin_unmerged_cutted_from_ccp4.mtz')
  data_mtz2 = os.path.join(data_dir, 'data',
                           'phaser_1.mtz')
  dm.process_model_file(data_pdb)
  dm.process_model_file(data_pdb2)
  dm.process_miller_array_file(data_mtz)
  dm.process_miller_array_file(data_mtz2)

  assert dm.get_default_model_type() == ['x_ray']
  for filename in dm.get_model_names():
    assert dm.get_model_type(filename) == ['x_ray']
  assert dm.get_default_miller_array_type() == ['x_ray']
  for filename in dm.get_miller_array_names():
    for label in dm.get_miller_array_labels(filename):
      assert dm.get_miller_array_type(filename, label) == ['x_ray']

  dm.update_all_defaults('electron')
  assert dm.get_default_model_type() == ['electron']
  for filename in dm.get_model_names():
    assert dm.get_model_type(filename) == ['electron']
  assert dm.get_default_miller_array_type() == ['electron']
  for filename in dm.get_miller_array_names():
    for label in dm.get_miller_array_labels(filename):
      assert dm.get_miller_array_type(filename, label) == ['electron']

  for x_ray_type in ['wk1995', 'it1992', 'n_gaussian']:
    dm.update_all_defaults(x_ray_type)
    for filename in dm.get_model_names():
      assert dm.get_model_type(filename) == ['x_ray']
    assert dm.get_default_miller_array_type() == ['x_ray']
    for filename in dm.get_miller_array_names():
      for label in dm.get_miller_array_labels(filename):
        assert dm.get_miller_array_type(filename, label) == ['x_ray']

# -----------------------------------------------------------------------------
def test_user_selected_labels():
  dm = DataManager(['miller_array', 'phil'])
  data_dir = os.path.dirname(os.path.abspath(__file__))
  data_mtz = os.path.join(data_dir, 'data',
                          'insulin_unmerged_cutted_from_ccp4.mtz')
  dm.process_miller_array_file(data_mtz)
  params = dm.export_phil_scope(as_extract=True)
  assert len(params.data_manager.miller_array[0].user_selected_labels) == 0

  # user_selected_labels
  dm = DataManager(['miller_array', 'phil'])
  phil = iotbx.phil.parse('''
data_manager {
  miller_array {
    file = %s
    user_selected_labels = FRACTION
    user_selected_labels = BGP
  }
}
''' % data_mtz)
  working_phil = dm.master_phil.fetch(phil)
  dm.load_miller_array_phil_extract(working_phil.extract())
  params = dm.export_phil_scope(as_extract=True)
  assert params.data_manager.miller_array[0].user_selected_labels == ['FRACTION', 'BGP']

  # wrong label
  dm = DataManager(['miller_array', 'phil'])
  phil = iotbx.phil.parse('''
data_manager {
  miller_array {
    file = %s
    user_selected_labels = abc
  }
}
''' % data_mtz)
  working_phil = dm.master_phil.fetch(phil)
  try:
    dm.load_miller_array_phil_extract(working_phil.extract())
  except Sorry as s:
    assert 'abc, could not be found in' in str(s)

  # labels
  dm = DataManager(['miller_array', 'phil'])
  phil = iotbx.phil.parse('''
data_manager {
  miller_array {
    file = %s
    labels.name = fraction
  }
}
''' % data_mtz)
  working_phil = dm.master_phil.fetch(phil)
  dm.load_miller_array_phil_extract(working_phil.extract())
  params = dm.export_phil_scope(as_extract=True)
  assert params.data_manager.miller_array[0].user_selected_labels == ['fraction']
  for label in params.data_manager.miller_array[0].labels:
    assert label.name != 'fraction'  # fraction is only stored in user_selected_labels

  # wrong label
  dm = DataManager(['miller_array', 'phil'])
  phil = iotbx.phil.parse('''
data_manager {
  miller_array {
    file = %s
    labels.name = DEF
  }
}
''' % data_mtz)
  working_phil = dm.master_phil.fetch(phil)
  try:
    dm.load_miller_array_phil_extract(working_phil.extract())
  except Sorry as s:
    assert 'DEF, could not be found in' in str(s)

  # test file server
  dm = DataManager(['miller_array', 'phil'])
  phil = iotbx.phil.parse('''
data_manager {
  miller_array {
    file = %s
    user_selected_labels = IPR
  }
}
''' % data_mtz)
  working_phil = dm.master_phil.fetch(phil)
  dm.load_miller_array_phil_extract(working_phil.extract())
  fs = dm.get_reflection_file_server()
  ma = fs.get_miller_arrays(None)
  fs_labels = [m.info().label_string() for m in ma]
  # only I,SIGI should be ignored in reflection file server
  all_labels = dm.get_miller_array_all_labels()
  assert 'I,SIGI,merged' in all_labels
  assert 'I,SIGI,merged' not in fs_labels
  for label in all_labels:
    if label != 'I,SIGI,merged':
      assert label in fs_labels

  # select array by incomplete label
  dm = DataManager(['miller_array', 'phil'])
  phil = iotbx.phil.parse('''
data_manager {
  miller_array {
    file = %s
    user_selected_labels = XD
  }
}
''' % data_mtz)
  working_phil = dm.master_phil.fetch(phil)
  dm.load_miller_array_phil_extract(working_phil.extract())
  answer = dm.get_miller_arrays(labels=['XDET'])
  user_labels = dm.get_miller_array_user_selected_labels()
  test = dm.get_miller_arrays(labels=user_labels)
  assert user_labels == ['XD']
  assert answer == test

# -----------------------------------------------------------------------------
def test_scattering_table_mixins():
  for datatype in ['model', 'miller_array']:
    dm = DataManager([datatype])
    assert hasattr(dm, 'check_scattering_table_type')
    assert hasattr(dm, 'map_scattering_table_type')

  dm = DataManager(['phil'])
  assert not hasattr(dm, 'check_scattering_table_type')
  assert not hasattr(dm, 'map_scattering_table_type')

  dm = DataManager()
  for scattering_table in ['wk1995', 'it1992', 'n_gaussian', 'neutron',  'electron']:
    assert dm.check_scattering_table_type(scattering_table) == scattering_table
  assert dm.check_scattering_table_type('x_ray') == 'n_gaussian'
  try:
    dm.check_scattering_table_type('abc')
  except Sorry as s:
    assert 'Unrecognized scattering table type, "abc,"' in str(s)

  for scattering_table in ['neutron',  'electron']:
    assert dm.map_scattering_table_type(scattering_table) == scattering_table
  for scattering_table in ['wk1995', 'it1992', 'n_gaussian']:
    assert dm.map_scattering_table_type(scattering_table) == 'x_ray'

# -----------------------------------------------------------------------------
if __name__ == '__main__':

  test_data_manager()
  test_model_datatype()
  test_sequence_datatype()
  test_miller_array_datatype()
  test_real_map_datatype()
  test_map_mixins()
  test_default_filenames()
  test_model_skip_ss_annotations()
  test_fmodel_params()
  test_user_selected_labels()
  test_scattering_table_mixins()

  if libtbx.env.find_in_repositories(relative_path='chem_data') is not None:
    test_model_and_restraint()
  else:
    print('Skip test_model_and_restraint, chem_data not available')
  print("OK")


 *******************************************************************************


 *******************************************************************************
iotbx/regression/tst_data_plots.py

from __future__ import absolute_import, division, print_function
from iotbx import data_plots
import libtbx.load_env
import json
import os

def exercise_inline():
  loggraph1 = """\
$TABLE: Resolution shell statistics
$GRAPHS
:R-free vs. resolution:A:1,3:
:FOM vs. resolution:A:1,4:
$$
1/resol^2  Nrefl      R-free     FOM       $$
$$
0.02       2004       0.25       0.89
0.04       2084       0.23       0.88
0.06       *          0.27       nan
0.08       1949       0.28       0.75
0.1        1783       0.38       *
$$
"""
  # Different newline arrangement, otherwise identical
  loggraph_input = """\
$TABLE: Resolution shell statistics: $GRAPHS :R-free vs. resolution:A:1,3: :FOM vs. resolution:A:1,4:
$$
1/resol^2  Nrefl      """+"""
R-free     FOM       $$ $$
0.02       2004       """+"""
0.25       0.89
0.04       2084       0.23
       0.88
0.06       nan        0.27       nan
0.08       1949       0.28       0.75 0.1        1783       0.38       * $$
"""
  t = data_plots.table_data(None)
  t.import_loggraph(loggraph_input)
#  print t.format_loggraph()
#  print "---"
#  print loggraph1
  assert (len(t.data) == 4)
  assert (t.data[0] == [0.02, 0.04, 0.06, 0.08, 0.10])
  assert (t.data[3][4] is None)
  assert (t.format_loggraph() == loggraph1), t.format_loggraph()
  assert (t.export_rows()[-1] == ['0.1', '1783', '0.38', '*'])
  json_t = t.export_json_table()
  json_d = json.loads(json_t)
  assert (json_d['rows'] == [
    ["1/resol^2", "Nrefl", "R-free", "FOM"],
    ["0.02", "2004", "0.25", "0.89"],
    ["0.04", "2084", "0.23", "0.88"],
    ["0.06", "*", "0.27", "nan"],
    ["0.08", "1949", "0.28", "0.75"],
    ["0.1", "1783", "0.38", "*"]]), json_d['rows']
  assert (json_d['title'] == "Resolution shell statistics"), json_d['title']

  f = open("_tst_data_plots.log", "w")
  f.write("\nRandom non-loggraph text\n\n")
  f.write(loggraph1)
  f.write("\n\n")
  f.write(loggraph1)
  f.close()
  tables = data_plots.import_ccp4i_logfile("_tst_data_plots.log")
  assert len(tables) == 2
  assert tables[0].format_loggraph() == loggraph1
  assert tables[0].format_loggraph() == tables[1].format_loggraph()
  t2 = data_plots.table_data(
    title = "Resolution shell statistics",
    column_labels = ["1/resol^2", "Nrefl", "R-free", "FOM"],
    graph_names = ["R-free vs. resolution", "FOM vs. resolution"],
    graph_columns = [[0,2], [0,3]],
    data = [[0.02, 0.04, 0.06, 0.08, 0.10],
            [2004, 2084, None, 1949, 1783],
            [0.25, 0.23, 0.27, 0.28, 0.38],
            [0.89, 0.88, float('NaN'), 0.75, None]]
  )
  #print loggraph1
  #print "---"
  #print t2.format_loggraph()
  assert t2.format_loggraph() == loggraph1
  g1 = t2.get_graph("R-free vs. resolution")
  g2 = t2.get_graph("FOM vs. resolution")
  assert len(g1.data) == 2 and len(g2.data) == 2
  p1 = g1.get_plots(fill_in_missing_y=None)
  p2 = g2.get_plots(fill_in_missing_y=None)
  assert len(p1) == 1 and len(p2) == 1
  (plot_x, plot_y) = p1.pop()
  assert len(plot_x) == 5
  (plot_x, plot_y) = p2.pop()
  assert len(plot_x) == 4
  formatted_table = """\
  -------------------------------------------------
  | Resolution shell statistics                   |
  |-----------------------------------------------|
  | 1/resol^2 | Nrefl     | R-free    | FOM       |
  |-----------------------------------------------|
  | 0.02      | 2004      | 0.25      | 0.89      |
  | 0.04      | 2084      | 0.23      | 0.88      |
  | 0.06      | *         | 0.27      | nan       |
  | 0.08      | 1949      | 0.28      | 0.75      |
  | 0.1       | 1783      | 0.38      | *         |
  -------------------------------------------------
"""
  #print t2.format()
  assert t2.format(indent=2) == formatted_table
  simple_table = """\
  Resolution shell statistics
  1/resol^2 Nrefl     R-free    FOM
  0.02      2004      0.25      0.89
  0.04      2084      0.23      0.88
  0.06      *         0.27      nan
  0.08      1949      0.28      0.75
  0.1       1783      0.38      *
"""
  # as above, but without indentation
  simpler_table = """\
Resolution shell statistics
1/resol^2 Nrefl     R-free    FOM
0.02      2004      0.25      0.89
0.04      2084      0.23      0.88
0.06      *         0.27      nan
0.08      1949      0.28      0.75
0.1       1783      0.38      *
"""
  formatted = t2.format_simple(indent=2)
  assert (formatted == simple_table), formatted
  assert str(t2) == simpler_table
  json_str = t2.export_json()
  json_dict = json.loads(json_str)
  expected_dict = {"graph_types": ["A", "A"], "graph_columns": [[0, 2], [0, 3]], "title": "Resolution shell statistics", "column_labels": ["1/resol^2", "Nrefl", "R-free", "FOM"], "data": [[0.02, 0.04, 0.06, 0.08, 0.1], [2004, 2084, None, 1949, 1783], [0.25, 0.23, 0.27, 0.28, 0.38], [0.89, 0.88, float('nan'), 0.75, None]], "graph_names": ["R-free vs. resolution", "FOM vs. resolution"], "x_is_inverse_d_min": False}
  for key in expected_dict:
    if key != 'data':
      assert (key in json_dict), key
      assert (json_dict[key] == expected_dict[key]), \
              (key, json_dict[key], expected_dict[key])
  assert ('"data": [[0.02, 0.04, 0.06, 0.08, 0.1], [2004, 2084, null, 1949, 1783], [0.25, 0.23, 0.27, 0.28, 0.38], [0.89, 0.88, NaN, 0.75, null]]' in
          json_str), json_str


def exercise_column_formats():
  t = data_plots.table_data(
    title = "Resolution shell statistics",
    column_labels = ["1/resol^2", "Nrefl", "R-free", "FOM"],
    column_formats = ["%.2g", "%i", "%.2f", "%.2f"],
    data = [[0.02, 0.04, 0.06, 0.08, 0.10],
            [2004, 2084, None, 1949, 1783],
            [0.25, 0.23, 0.27, 0.28, 0.38],
            [0.89, 0.88, float('NaN'), 0.75, None]]
  )
  assert t.format() == """\
-------------------------------------------------
| Resolution shell statistics                   |
|-----------------------------------------------|
| 1/resol^2 | Nrefl     | R-free    | FOM       |
|-----------------------------------------------|
| 0.02      | 2004      | 0.25      | 0.89      |
| 0.04      | 2084      | 0.23      | 0.88      |
| 0.06      | *         | 0.27      | nan       |
| 0.08      | 1949      | 0.28      | 0.75      |
| 0.1       | 1783      | 0.38      | *         |
-------------------------------------------------
"""


def exercise_logfile():
  log_file = libtbx.env.find_in_repositories(
    relative_path="phenix_regression/tracking/scala.log",
    test=os.path.isfile)
  if log_file is not None :
    tables = data_plots.import_ccp4i_logfile(log_file)
    assert ([ t.title for t in tables ] ==
      ['>>> Scales v rotation range, Unspecified ',
       'Analysis against Batch, Unspecified ',
       'Analysis against resolution , Unspecified ',
       'Analysis against intensity, Unspecified ',
       'Completeness, multiplicity, Rmeas v. resolution, Unspecified ',
       'Correlations within dataset, Unspecified ',
       'Axial reflections, axis h, Unspecified ',
       'Axial reflections, axis k, Unspecified ',
       'Axial reflections, axis l, Unspecified ',
       'Run     1, standard deviation v. Intensity, Unspecified '])
  loggraph3 = """\
$TABLE: Matthews coefficients:
$GRAPHS: Protein crystal computed at resolution of 2.450 :A:1,2,3,4
$$ Nmol/asym Matthews_Coeff sovlent_frac P(2.450) $$
$$
    1         3.13            0.61         0.99
    2         1.56            0.21         0.01
$$
"""
  t3 = data_plots.table_data(None)
  t3.import_loggraph(loggraph3)
  g3 = t3.get_graph("Protein crystal computed at resolution of 2.450")
  p3 = g3.get_plots()

if __name__ == "__main__" :
  exercise_column_formats()
  exercise_inline()
  exercise_logfile()
  print("OK")


 *******************************************************************************


 *******************************************************************************
iotbx/regression/tst_examples.py
from __future__ import absolute_import, division, print_function
from libtbx.test_utils import assert_lines_in_text
import libtbx.load_env
from six.moves import cStringIO as StringIO
import os, sys

def run_function_and_grab_stdout(func, params):
  saved_stdout = sys.stdout
  inp = StringIO()
  sys.stdout = inp
  func(params)
  stdout_text = inp.getvalue()
  sys.stdout = saved_stdout
  return stdout_text

def exercise_pdb_shake():
  from iotbx.examples.pdb_shake import run
  pdb_file = libtbx.env.find_in_repositories(
    relative_path="iotbx/regression/data/2ERL.pdb",
    test=os.path.isfile)
  stdout_text = run_function_and_grab_stdout(run, [pdb_file])
  assert_lines_in_text(stdout_text, 'END')


def exercise_pdb_to_map_simple():
  from iotbx.examples.pdb_to_map_simple import run
  pdb_file = libtbx.env.find_in_repositories(
    relative_path="iotbx/regression/data/pdb1zff.ent",
    test=os.path.isfile)
  stdout_text = run_function_and_grab_stdout(run, [pdb_file])
  # print(stdout_text)
  assert_lines_in_text(stdout_text, 'block last:  (26, 17, 26)')

def exercise_shelx_latt_sym_to_space_group_symbol():
  from iotbx.examples.shelx_latt_sym_to_space_group_symbol import run
  fname = libtbx.env.find_in_repositories(
    relative_path="iotbx/regression/data/shelx.ins",
    test=os.path.isfile)
  stdout_text = run_function_and_grab_stdout(run, [fname])
  # print(stdout_text)
  assert_lines_in_text(stdout_text, "P 1 21 1")

def exercise_direct_methods_light():
  from iotbx.examples.direct_methods_light import run
  data_fname = libtbx.env.find_in_repositories(
    relative_path="iotbx/regression/data/cu3182Isup2.hkl",
    test=os.path.isfile)
  model_fname = libtbx.env.find_in_repositories(
    relative_path="iotbx/regression/data/cu3182sup1.cif",
    test=os.path.isfile)
  run_function_and_grab_stdout(run, [data_fname, model_fname])

def exercise_pdb_symmetry_copies():
  from iotbx.examples.pdb_symmetry_copies import run
  fname = libtbx.env.find_in_repositories(
    relative_path="iotbx/regression/data/1yjp.pdb",
    test=os.path.isfile)
  stdout_text = run_function_and_grab_stdout(run, [fname])
  # print(stdout_text)
  assert_lines_in_text(stdout_text, "Writing file: symmetry_copies.pdb")
  assert os.path.isfile("symmetry_copies.pdb")

if (__name__ == "__main__"):
  exercise_pdb_shake()
  exercise_pdb_to_map_simple()
  exercise_shelx_latt_sym_to_space_group_symbol()
  exercise_direct_methods_light()
  exercise_pdb_symmetry_copies()
  print("OK")


 *******************************************************************************


 *******************************************************************************
iotbx/regression/tst_export_scalepack_unmerged.py

from __future__ import absolute_import, division, print_function
from iotbx.reflection_file_reader import any_reflection_file
from iotbx.command_line import export_scalepack_unmerged
from libtbx.utils import null_out

prefix = "tst_export_scalepack_unmerged"

def exercise_xds() : pass # TODO
def exercise_mtz() : pass # TODO

def exercise_scalepack():
  sca_in = """\
    4 i41
  1  0  0  0  1  0  0  0  1
  0  0  0
 -1  0  0  0 -1  0  0  0  1
  0  0  0
  0 -1  0  1  0  0  0  0  1
  0  6  3
  0  1  0 -1  0  0  0  0  1
  0  6  3
   0   0   4   0   0   4   188 1 1  1 80331.8  8648.0
   0   0  -4   0   0   4     8 2 1  1104526.7 11623.3
   0   0   8   0   0   8    19 1 0  1 44883.6  4527.6
   0   0   8   0   0   8   184 1 1  1 41134.1  4431.9
   0   0  -8   0   0   8     4 2 1  1 53386.0  5564.1
   0   0  -8   0   0   8   198 2 0  1 50401.8  5464.6
   0   0  12   0   0  12    22 1 0  1119801.4 12231.2
   0   0  12   0   0  12   180 1 1  1105312.9 12602.2
   0   0  16   0   0  16    26 1 0  1 14877.6  2161.5
   1   0   3   1   0   3    10 1 0  1 19407.0  2301.4
   1   0   3   1   0   3   184 1 1  1 19337.0  2204.0
  -1   0   3   1   0   3    19 1 0  2 19513.6  2220.3
  -1   0   3   1   0   3   193 1 1  2 20702.3  2227.8
   0  -1   3   1   0   3    11 1 0  3 20041.6  2360.2
   0  -1   3   1   0   3   185 1 1  3 20043.9  2296.8
   0   1   3   1   0   3    18 1 0  4 19677.4  2125.2
  -1   0  -3   1   0   3     4 2 1  1 17056.4  1829.7
  -1   0  -3   1   0   3   189 2 0  1 16545.2  2065.9
   1   0  -3   1   0   3    13 2 1  2 17169.5  1768.9
   1   0  -3   1   0   3   198 2 0  2 16195.8  1927.5
"""
  sca_file = prefix + "_in.sca"
  with open(sca_file, "w") as f:
    f.write(sca_in)
  ofn = export_scalepack_unmerged.run(args=[sca_file], out=null_out())[0]
  assert (ofn == "tst_export_scalepack_unmerged_in_unmerged.sca")
  hkl_in = any_reflection_file(ofn).file_content()
  i_obs = hkl_in.as_miller_arrays(merge_equivalents=False)[0]
  assert (not i_obs.is_unique_set_under_symmetry())
  assert (list(hkl_in.batch_numbers) == [188, 8, 19, 184, 4, 198, 22, 180, 26,
          10, 184, 19, 193, 11, 185, 18, 4, 189, 13, 198])

def exercise_cif():
  # .cif input
  cif_in = """\
data_r2etdsf
#
_cell.entry_id      2etd
_cell.length_a      80.4540
_cell.length_b      85.2590
_cell.length_c      53.3970
_cell.angle_alpha   90.0000
_cell.angle_beta    90.0000
_cell.angle_gamma   90.0000
#
_symmetry.entry_id               2etd
_symmetry.space_group_name_H-M   'C 2 2 2'
#
loop_
_refln.crystal_id
_refln.wavelength_id
_refln.scale_group_code
_refln.index_h
_refln.index_k
_refln.index_l
_refln.status
_refln.intensity_meas
_refln.intensity_sigma
1 1 1    0    2   -8  o    1544.6    130.4
1 1 1    0    2    9  o    3450.1    264.9
1 1 1    0   -2    9  o    3243.5    268.5
1 1 1    0   -2   -9  o    3475.4    265.0
1 1 1    0    2   -9  o    3420.1    260.3
1 1 1    0    2   10  o      58.8     31.8
1 1 1    0   -2  -10  o     131.7     50.7
1 1 1    0    2  -10  o      97.9     48.7
1 1 1    0   -2   11  o    9808.3    953.5
1 1 1    0   -2  -11  o   11486.1    970.3
1 1 1    0    2  -11  o   11278.1    967.8
1 1 1    0    2   12  o    1368.9    150.7
1 1 1    0   -2   12  o    1620.9    148.7
1 1 1    0   -2  -12  o    1293.5    147.6
1 1 1    0    2  -12  o    1619.5    155.7
1 1 1    0   -2   13  o   47438.3   4104.1
1 1 1    0    2   14  o    8577.5   1188.0
1 1 1    0   -2   14  o    7996.7   1179.9
1 1 1    0   -2  -14  o    9333.7   1178.1
1 1 1    0    2  -14  o    9642.3   1197.6
1 1 1    0    2   15  o   13577.7   1852.4
1 1 1    0   -2   15  o   14100.9   1852.8
1 1 1    0   -2  -15  o   14184.2   1871.6
1 1 1    0    2   16  o     135.6     76.3
1 1 1    0   -2   16  o     117.0     60.4
"""
  cif_file = prefix + ".cif"
  with open(cif_file, "w") as f:
    f.write(cif_in)
  hkl_orig = any_reflection_file(cif_file).file_content()
  i_obs_orig = hkl_orig.as_miller_arrays(merge_equivalents=False)[0]
  ofn = export_scalepack_unmerged.run(args=[cif_file], out=null_out())[0]
  assert (ofn == prefix + "_unmerged.sca")
  hkl_new = any_reflection_file(ofn).file_content()
  i_obs_new = hkl_new.as_miller_arrays(merge_equivalents=False)[0]
  assert (not i_obs_new.is_unique_set_under_symmetry())
  assert i_obs_new.indices().all_eq(i_obs_orig.indices())

if (__name__ == "__main__"):
  exercise_scalepack()
  exercise_cif()
  print("OK")


 *******************************************************************************


 *******************************************************************************
iotbx/regression/tst_extract_xtal_data.py
from __future__ import absolute_import, division, print_function
from iotbx.reflection_file_reader import any_reflection_file
import iotbx.reflection_file_reader
from iotbx import extract_xtal_data as ed
import sys, os
import cctbx.miller

def run():
  data_dir = os.path.dirname(os.path.abspath(__file__))
  data_mtz = os.path.join(data_dir, 'data', 'phaser_1.mtz')

  params = ed.data_and_flags_master_params().extract()
  params.file_name = data_mtz
  params.labels=['FP,SIGFP']

  phases_params = ed.experimental_phases_master_params().extract()
  phases_params.labels="HLA,HLB,HLC,HLD"

  reflection_files = [
    iotbx.reflection_file_reader.any_reflection_file(data_mtz)]

  server = iotbx.reflection_file_utils.reflection_file_server(
    crystal_symmetry = None,
    reflection_files = reflection_files,
    err              = sys.stdout)

  fo = ed.run(
    reflection_file_server     = server,
    parameters                 = params,
    experimental_phases_params = phases_params,
    extract_r_free_flags       = False).f_obs
  assert cctbx.miller.array(fo, cctbx.miller.array)

if(__name__ == "__main__"):
  run()


 *******************************************************************************


 *******************************************************************************
iotbx/regression/tst_fetch.py
from __future__ import absolute_import, division, print_function

from libtbx.utils import format_cpu_times
import requests
from iotbx.cli_parser import run_program
from iotbx.pdb.fetch import fetch, get_link
from libtbx.test_utils import assert_lines_in_text
from mmtbx.command_line.fetch_pdb import custom_args_proc
from mmtbx.programs.fetch import Program
import sys, os

def exercise_1():
  string_1yjp = fetch(id = "1yjp").read().decode()
  # print("%s" % string_1yjp)
  assert_lines_in_text(string_1yjp, """\
ATOM      1  N   GLY A   1      -9.009   4.612   6.102  1.00 16.77           N
ATOM      2  CA  GLY A   1      -9.052   4.207   4.651  1.00 16.57           C
ATOM      3  C   GLY A   1      -8.015   3.140   4.419  1.00 16.16           C
""")

def exercise_2():
  string_1yjp_sf = fetch(id = "1yjp", entity='sf').read().decode()
  print("%s" % string_1yjp_sf)
  assert_lines_in_text(string_1yjp_sf, """\
loop_
_refln.crystal_id
_refln.wavelength_id
_refln.scale_group_code
_refln.index_h
_refln.index_k
_refln.index_l
_refln.status
_refln.F_meas_au
_refln.F_meas_sigma_au
1 1 1  -12    0    2 o     3.49   2.34
1 1 1  -12    0    3 o     3.31   2.43
1 1 1  -12    0    4 o     7.32   4.25 """)

def exercise_3():
  """
  pdb: 6yvd
  EMD-10944
  maps are only 2.8 Mb and has half-maps
  """
  result = run_program(program_class=Program,
                       custom_process_arguments=custom_args_proc,
                       args=["6yvd", "action=all"])
  for i in range(len(result[0])):
    result[0][i] = os.path.basename(result[0][i])
  for fn in [ "6yvd.pdb",
              "6yvd.cif",
              "emd_10944.map.gz",
              "emd_10944_half_map_1.map.gz",
              "emd_10944_half_map_2.map.gz",
              "6yvd.fa",
              ]:
    assert os.path.isfile(fn), "File %s not found" % fn
    assert fn in result[0]

def exercise_4():
    """
    pdb: 6yvd
    EMD-10944
    Testing with action=model
    """
    # Remove relevant files before running the command
    files_to_remove = [
        "6yvd.pdb",
        "6yvd.cif",
        "emd_10944.map.gz",
        "emd_10944_half_map_1.map.gz",
        "emd_10944_half_map_2.map.gz",
        "6yvd.fa",
    ]
    for file in files_to_remove:
        if os.path.exists(file):
            os.remove(file)
    result = run_program(program_class=Program,
                         custom_process_arguments=custom_args_proc,
                         args=["6yvd", "action=model"])
    for i in range(len(result[0])):
      result[0][i] = os.path.basename(result[0][i])
    # Files that should be present with action=model
    expected_files = [
        "6yvd.pdb",
        "6yvd.cif",
    ]
    # Files that should not be present with action=model
    unexpected_files = [
        "emd_10944.map.gz",
        "emd_10944_half_map_1.map.gz",
        "emd_10944_half_map_2.map.gz",
        "6yvd.fa",
    ]
    for fn in expected_files:
      assert os.path.isfile(fn), "File {0} not found, but it should be present with action=model".format(fn)
      assert fn in result[0], "File {0} not found, but it should be present with action=model".format(fn)
    for fn in unexpected_files:
      assert not os.path.isfile(fn), "File {0} found, but it should not be present with action=model".format(fn)
      assert fn not in result[0], "File {0} found, but it should not be present with action=model".format(fn)

def exercise_5():
    """
    Testing all possible actions in fetch_pdb
    """
    actions = ['model', 'data', 'half_maps', 'sequence', 'all']
    pdb_id = '6yvd'
    files_to_remove = [
        "%s.pdb" % pdb_id,
        "%s.cif" % pdb_id,
        "emd_10944.map.gz",
        "emd_10944_half_map_1.map.gz",
        "emd_10944_half_map_2.map.gz",
        "%s.fa" % pdb_id,
    ]
    for action in actions:
      # Remove relevant files before running the command
      for file in files_to_remove:
        if os.path.exists(file):
          os.remove(file)
      result = run_program(program_class=Program,
                           custom_process_arguments=custom_args_proc,
                           args=[pdb_id, "action=%s" % action])
      for i in range(len(result[0])):
        result[0][i] = os.path.basename(result[0][i])
      if action == 'model':
        assert os.path.isfile("%s.pdb" % pdb_id)
        assert "%s.pdb" % pdb_id in result[0]
        assert os.path.isfile("%s.cif" % pdb_id)
        assert "%s.cif" % pdb_id in result[0]
        assert not os.path.isfile("emd_10944.map.gz")
        assert "emd_10944.map.gz" not in result[0]
        assert not os.path.isfile("%s.fa" % pdb_id)
        assert "%s.fa" % pdb_id not in result[0]
        assert not os.path.isfile("emd_10944_half_map_1.map.gz")
        assert "emd_10944_half_map_1.map.gz" not in result[0]
        assert not os.path.isfile("emd_10944_half_map_2.map.gz")
        assert "emd_10944_half_map_2.map.gz" not in result[0]
      elif action == 'data':
        assert os.path.isfile("emd_10944.map.gz")
        assert "emd_10944.map.gz" in result[0]
        assert not os.path.isfile("%s.pdb" % pdb_id)
        assert "%s.pdb" % pdb_id not in result[0]
        assert not os.path.isfile("%s.cif" % pdb_id)
        assert "%s.cif" % pdb_id not in result[0]
        assert not os.path.isfile("emd_10944_half_map_1.map.gz")
        assert "emd_10944_half_map_1.map.gz" not in result[0]
        assert not os.path.isfile("emd_10944_half_map_2.map.gz")
        assert "emd_10944_half_map_2.map.gz" not in result[0]
      elif action == 'sequence':
        assert os.path.isfile("%s.fa" % pdb_id)
        assert "%s.fa" % pdb_id in result[0]
        assert not os.path.isfile("%s.pdb" % pdb_id)
        assert "%s.pdb" % pdb_id not in result[0]
        assert not os.path.isfile("%s.cif" % pdb_id)
        assert "%s.cif" % pdb_id not in result[0]
        assert not os.path.isfile("emd_10944.map.gz")
        assert "emd_10944.map.gz" not in result[0]
        assert not os.path.isfile("emd_10944_half_map_1.map.gz")
        assert "emd_10944_half_map_1.map.gz" not in result[0]
        assert not os.path.isfile("emd_10944_half_map_2.map.gz")
        assert "emd_10944_half_map_2.map.gz" not in result[0]
      elif action == 'all':
        assert os.path.isfile("%s.pdb" % pdb_id)
        assert "%s.pdb" % pdb_id in result[0]
        assert os.path.isfile("%s.cif" % pdb_id)
        assert "%s.cif" % pdb_id in result[0]
        assert os.path.isfile("emd_10944.map.gz")
        assert "emd_10944.map.gz" in result[0]
        assert os.path.isfile("emd_10944_half_map_1.map.gz")
        assert "emd_10944_half_map_1.map.gz" in result [0]
        assert os.path.isfile("emd_10944_half_map_2.map.gz")
        assert "emd_10944_half_map_2.map.gz" in result[0]
        assert os.path.isfile("%s.fa" % pdb_id)
        assert "%s.fa" % pdb_id in result[0]

def exercise_get_link():
  r = []
  for ft in ['model_pdb', 'model_cif', 'sequence', 'sf', 'em_map']:
    r.append(get_link('rcsb', ft, '1ab2', emdb_number="1111"))
  # print (r)
  assert r == ['https://files.rcsb.org/pub/pdb/data/structures/divided/pdb/ab/pdb1ab2.ent.gz',
               'https://files.rcsb.org/pub/pdb/data/structures/divided/mmCIF/ab/1ab2.cif.gz',
               'https://www.rcsb.org/fasta/entry/1ab2',
               'https://files.rcsb.org/download/1ab2-sf.cif.gz',
               'https://files.rcsb.org/pub/emdb/structures/EMD-1111/map/emd_1111.map.gz'], r

if (__name__ == "__main__"):
  exercise_get_link()
  if sys.version_info.major >= 3:
    exception_occured = False
    try:
      r = requests.get('https://search.rcsb.org/')
    except Exception:
      print("OK but exception.")
      exception_occured = True
    if not exception_occured and r.ok and len(r.text) > 100:
      exercise_1()
      exercise_2()
      exercise_3()
      exercise_4()
      exercise_5()
      print("OK")
    else:
      print("OK but skipped.")
  print(format_cpu_times())


 *******************************************************************************


 *******************************************************************************
iotbx/regression/tst_file_reader.py
from __future__ import absolute_import, division, print_function
import os
import sys
import libtbx.load_env
from libtbx.utils import Sorry
from libtbx import easy_run
from libtbx.test_utils import Exception_expected, open_tmp_file
from iotbx import file_reader
from iotbx.file_reader import any_file, sort_by_file_type, group_files
from cctbx import miller
from cctbx import crystal
from cctbx.array_family import flex
from six.moves import cPickle as pickle
from six.moves import zip

if (libtbx.env.has_module("ccp4io")):
  from iotbx import mtz
else:
  mtz = None

def exercise_cif():
  #--- CIF
  cif_data = """
data_comp_list
loop_
_chem_comp.id
_chem_comp.three_letter_code
_chem_comp.name
_chem_comp.group
_chem_comp.number_atoms_all
_chem_comp.number_atoms_nh
_chem_comp.desc_level
HOH      .   'water                               ' solvent             3   1 .
#
data_comp_HOH
#
loop_
_chem_comp_atom.comp_id
_chem_comp_atom.atom_id
_chem_comp_atom.type_symbol
_chem_comp_atom.type_energy
_chem_comp_atom.partial_charge
 HOH           O      O    OH2      -0.408
 HOH           H1     H    HOH2      0.204
 HOH           H2     H    HOH2      0.204
loop_
_chem_comp_tree.comp_id
_chem_comp_tree.atom_id
_chem_comp_tree.atom_back
_chem_comp_tree.atom_forward
_chem_comp_tree.connect_type
 HOH      O      n/a    .      END
 HOH      H1     O      .      .
 HOH      H2     O      .      .
loop_
_chem_comp_bond.comp_id
_chem_comp_bond.atom_id_1
_chem_comp_bond.atom_id_2
_chem_comp_bond.type
_chem_comp_bond.value_dist
_chem_comp_bond.value_dist_esd
 HOH      O      H1        coval       0.980    0.020
 HOH      O      H2        coval       0.980    0.020
loop_
_chem_comp_angle.comp_id
_chem_comp_angle.atom_id_1
_chem_comp_angle.atom_id_2
_chem_comp_angle.atom_id_3
_chem_comp_angle.value_angle
_chem_comp_angle.value_angle_esd
 HOH      H1     O      H2      106.800    3.000
"""

  f = open("tmp1.cif", "w")
  f.write(cif_data)
  f.close()
  cif = any_file("tmp1.cif")
  cif.assert_file_type("cif")
  # test command-line tool
  lines = easy_run.fully_buffered("iotbx.file_reader tmp1.cif").stdout_lines
  assert ("cif" in lines[0])
  os.remove("tmp1.cif")

def exercise_mmcif():
  input_4edr = """\
data_4EDR
_cell.length_a           150.582
_cell.length_b           150.582
_cell.length_c           38.633
_cell.angle_alpha        90.000
_cell.angle_beta         90.000
_cell.angle_gamma        120.000
#
_symmetry.space_group_name_H-M             'P 61'
#
loop_
_atom_site.group_PDB
_atom_site.id
_atom_site.type_symbol
_atom_site.label_atom_id
_atom_site.label_alt_id
_atom_site.label_comp_id
_atom_site.label_asym_id
_atom_site.label_entity_id
_atom_site.label_seq_id
_atom_site.Cartn_x
_atom_site.Cartn_y
_atom_site.Cartn_z
_atom_site.occupancy
_atom_site.B_iso_or_equiv
_atom_site.auth_seq_id
_atom_site.auth_comp_id
_atom_site.auth_asym_id
_atom_site.auth_atom_id
_atom_site.pdbx_PDB_model_num
ATOM   1    N  N     . SER A 1 1 21.138  -69.073 17.360  1.00 23.68 108 SER A N     1
ATOM   2    C  CA    . SER A 1 1 22.164  -68.793 18.358  1.00 22.98 108 SER A CA    1
ATOM   3    C  C     . SER A 1 1 23.173  -67.799 17.805  1.00 21.13 108 SER A C     1
ATOM   4    O  O     . SER A 1 1 23.251  -67.594 16.595  1.00 19.34 108 SER A O     1
ATOM   5    C  CB    . SER A 1 1 22.882  -70.080 18.766  1.00 22.68 108 SER A CB    1
ATOM   6    O  OG    . SER A 1 1 23.683  -70.569 17.703  1.00 24.00 108 SER A OG    1
HETATM 2650 MN MN    . MN  F 4 . 9.296   -44.783 -6.320  1.00 44.18 505 MN  A MN    1
"""
  f = open_tmp_file(suffix="cif", mode="w")
  print(input_4edr, file=f)
  f.close()
  mmcif = any_file(f.name)
  mmcif.assert_file_type("pdb")
  mmcif.check_file_type("pdb")
  symm = mmcif.crystal_symmetry()
  assert (str(symm.space_group_info()) == "P 61")
  assert (str(symm.unit_cell()) == "(150.582, 150.582, 38.633, 90, 90, 120)")
  assert mmcif.file_description == 'Model'
  hierarchy = mmcif.file_object.hierarchy
  assert len(hierarchy.atoms()) == 7
  remarks = mmcif.file_object.input.remark_section()
  assert (len(remarks) == 0)

def exercise_pdb():
  pdb_data = """
HEADER    HYDROLASE(METALLOPROTEINASE)            17-NOV-93   1THL
ATOM      1  N   ILE     1       9.581  51.813  -0.720  1.00 31.90      1THL 158
ATOM      2  CA  ILE     1       8.335  52.235  -0.041  1.00 52.95      1THL 159
ATOM      3  C   ILE     1       7.959  53.741   0.036  1.00 26.88      1THL 160
END
"""
  f = open("tmp1.pdb", "w")
  f.write(pdb_data)
  f.close()
  pdb = any_file("tmp1.pdb")
  try :
    pdb.assert_file_type("txt")
  except Sorry :
    pass
  else :
    raise Exception_expected
  pdb.assert_file_type("pdb")
  pdb.check_file_type("pdb")
  try :
    pdb.check_file_type("hkl")
  except Sorry :
    pass
  else :
    raise Exception_expected
  try :
    pdb.check_file_type(multiple_formats=["hkl","seq"])
  except Sorry :
    pass
  else :
    raise Exception_expected
  pdb.check_file_type(multiple_formats=["hkl","pdb"])
  symm = pdb.crystal_symmetry()
  assert (symm is None)
  os.remove("tmp1.pdb")
  f = open("tmp1.ent.txt", "w")
  f.write(pdb_data)
  f.close()
  pdb = any_file("tmp1.ent.txt")
  pdb.assert_file_type("pdb")
  pdb_data_symm = """\
CRYST1   21.937    4.866   23.477  90.00 107.08  90.00 P 1 21 1      2
""" + pdb_data
  with open("tmp_file_reader2.pdb", "w") as f:
    f.write(pdb_data_symm)
  pdb = any_file("tmp_file_reader2.pdb").assert_file_type("pdb")
  symm = pdb.crystal_symmetry()
  assert (str(symm.space_group_info()) == "P 1 21 1")
  assert (str(symm.unit_cell()) == "(21.937, 4.866, 23.477, 90, 107.08, 90)")
  # bad formatting
  pdb_data_bad = """
HEADER    HYDROLASE(METALLOPROTEINASE)            17-NOV-93   1THL
ATOM      1  N   ILE     1       9.581  51.813  -0.720  1.00 31.90      1THL 158
ATOM      2  CA  ILE     1       8.335  52.235  -0.041  1.00 52.95      1THL 159
ATOM      3  C   ILE     1       7.959  53.741   0.036  1,00 26.88      1THL 160
END"""
  f = open("tmp1_bad.pdb", "w")
  f.write(pdb_data_bad)
  f.close()
  try :
    pdb = any_file("tmp1_bad.pdb", raise_sorry_if_not_expected_format=True)
  except Sorry as e :
    pass
  else :
    raise Exception_expected
  try :
    pdb = any_file("tmp1_bad.pdb", force_type="phil")
  except RuntimeError as e :
    pass
  else :
    raise Exception_expected
  try :
    pdb = any_file("tmp1_bad.pdb",
      force_type="pdb",
      raise_sorry_if_errors=True)
  except Sorry as e :
    assert ("Couldn't read 'tmp1_bad.pdb' as file type 'pdb'" in str(e))
  else :
    raise Exception_expected

def exercise_phil():
  phil_data = """\
refinement {
  input {
    include scope iotbx.extract_xtal_data.neutron_data_str
    include scope iotbx.extract_xtal_data.xray_data_str
  }
  refine {
    strategy = *individual_adp *individual_sites *tls occupancies group_adp
      .type = choice(multi=True)
    adp {
      tls = None
        .type = str
        .multiple = True
    }
  }
  main {
    number_of_macro_cycles = 3
      .type = int
    simulated_annealing = True
      .type = bool
  }
}"""

  f = open("tmp1.phil", "w")
  f.write(phil_data)
  f.close()
  phil = any_file("tmp1.phil")
  # phil_data refers to mmtbx.utils. If mmtbx is not present reading the phil
  # file as phil fails and any_file() opens it as the txt format.
  assert phil.file_type == "phil", "Possibly due to missing mmtbx"
  params = phil.file_object.extract()
  assert params.refinement.main.number_of_macro_cycles == 3
  assert params.refinement.input.xray_data.r_free_flags.test_flag_value == None
  os.remove("tmp1.phil")
  try :
    symm = phil.crystal_symmetry()
  except NotImplementedError :
    pass
  else :
    raise Exception_expected

def exercise_pickle():
  f = open("tmp1.pkl", "wb")
  e = OSError(2001, "Hello, world!", "tmp1.phil")
  pickle.dump(e, f)
  f.close()
  pkl = any_file("tmp1.pkl")
  assert pkl.file_type == "pkl"
  exception = pkl.file_object
  assert (exception.errno == 2001)
  os.remove("tmp1.pkl")

def exercise_sequence2():
  answer = """>BtSA
MDTVFVHQTQIPILIERQDNVLFYFRLDAKESRMMDEIVLDFGKSVNLSDVQAVKLYYGGTEALQDKGKKRFAPVDYISS
HRPGNTLAAIPSYSIKCAEALQPSAKVVLKSHYKLFPGINFFWISLQMKPETSLFTKISSELQSVKIDGKEAICEERSPK
DIIHRMAVGVRHAGDDGSASFRIPGLVTSNKGTLLGVYDVRYNSSVDLQEYVDVGLSRSTDGGKTWEKMRLPLSFGEYDG
LPAAQNGVGDPSILVDTQTNTIWVVAAWTHGMGNQRAWWSSHPGMDLYQTAQLVMAKSTDDGKTWSKPINITEQVKDPSW
YFLLQGPGRGITMSDGTLVFPTQFIDSTRVPNAGIMYSKDRGKTWKMHNMARTNTTEAQVVETEPGVLMLNMRDNRGGSR
AVAITKDLGKTWTEHPSSRKALQEPVCMASLIHVEAEDNVLDKDILLFSNPNTTRGRNHITIKASLDDGLTWLPEHQLML
DEGEGWGYSCLTMIDRETIGILYESSAAHMTFQAVKLKDLIRGNSSSVDKLAAALEHHHHHH"""
  txt="""
%s
>>>
"""%answer
  file_name = "tst_file_reader_exercise_sequence2"
  with open(file_name,"w") as fo:
    fo.write(txt)
  seq_file = file_reader.any_file(
    file_name,
    force_type = "seq",
    raise_sorry_if_errors=True)
  sequence = seq_file.file_object
  assert len(sequence) == 1
  s1 = "".join([s.strip() for s in str(sequence[0])])
  s2 = "".join([s.strip() for s in answer])
  assert s1 == s2

def exercise_sequence():
  seqs = ["AAKDVKFGVNVLADAV",
          "AAKDVKFGNDARVKML",
          "AVKDVRYGNEARVKIL"]
  headers = ["anb.pdb chain A",
             "anb.pdb chain B",
             "anb.pdb chain C"]
  f = open("sequence.pir", "w")
  f.write("""\
> %s

%s
*""" % (headers[0], seqs[0]))
  f.close()
  f = any_file("sequence.pir")
  assert (f.file_type == "seq")
  assert (f.file_object[0].sequence == (seqs[0] + "*"))
  os.remove("sequence.pir")
  f = open("sequence.dat", "w")
  f.write(seqs[0])
  f.close()
  f = any_file("sequence.dat")
  assert (f.file_type == "seq")
  assert (f.file_object[0].sequence == seqs[0])
  os.remove("sequence.dat")
  f = open("sequence.fa", "w")
  f.write("""\
> %s
%s""" % (headers[0], seqs[0]))
  f.close()
  f = any_file("sequence.fa", "w")
  assert (f.file_type == "seq")
  os.remove("sequence.fa")
  f = open("sequences.fa", "w")
  for header, seq in zip(headers, seqs):
    f.write("""\
> %s
%s
""" % (header, seq))
  f.close()
  f = any_file("sequences.fa")
  assert (f.file_type == "seq")
  for i, seq_object in enumerate(f.file_object):
    assert (seq_object.sequence == seqs[i])
  os.remove("sequences.fa")

def exercise_alignment():
  aln1 = """\
>1mru_A
-----------------GSHMTTPSHLSD-----RYELGEILGFGGMSEVHLARDLRLHR
DVAVKVLRADLARDPSFYLRFRREAQNAAALNHPAIVAVYDTGEAETPAGPLPYIVMEYV
DGVTLRDIVHTEGPMTPKRAIEVIADACQALNFSHQNGIIHRDVKPANIMISATNAVKVM
DFGIARAIADSGNSVTQTAAVIGTAQYLSPEQARGDSVDARSDVYSLGCVLYEVLTGEPP
FTGDSPVSVAYQHVREDPIPPSARHEGLSADLDAVVLKALAKNPENRYQTAAEMRADLVR
VHNGEPPEAPKVLTDAERTSLLSSAAGNLSGPR
>2h34_A
MGSSHHHHHHSSGLVPRGSHMDGTAESREGTQFGPYRLRRLVGRGGMGDVYEAEDTVRER
IVALKLMSETLSSDPVFRTRMQREARTAGRLQEPHVVPIHDFGEID---GQL-YVDMRLI
NGVDLAAMLRRQGPLAPPRAVAIVRQIGSALDAAHAAGATHRDVKPENILVSADDFAYLV
DFGIASATTD--EKLTQLGNTVGTLYYMAPERFSESHATYRADIYALTCVLYECLTGSPP
YQGDQ-LSVMGAHINQAIPRPSTVRPGIPVAFDAVIARGMAKNPEDRYVTCGDLSA----
-----AAHAALATADQDRATDILR--------R"""
  with open("seqs.aln", "w") as f:
    f.write(aln1)
  f = any_file("seqs.aln")
  f.assert_file_type("aln")
  assert (f.file_object.names == ["1mru_A", "2h34_A"])
  aln2 = """\
MUSCLE (3.8) multiple sequence alignment


1mru_A          -----------------GSHMTTPSHLSD-----RYELGEILGFGGMSEVHLARDLRLHR
2h34_A          MGSSHHHHHHSSGLVPRGSHMDGTAESREGTQFGPYRLRRLVGRGGMGDVYEAEDTVRER
                                 ****  .:   :      * *  ::* ***.:*: * *    *

1mru_A          DVAVKVLRADLARDPSFYLRFRREAQNAAALNHPAIVAVYDTGEAETPAGPLPYIVMEYV
2h34_A          IVALKLMSETLSSDPVFRTRMQREARTAGRLQEPHVVPIHDFGEID---GQL-YVDMRLI
                 **:*::   *: ** *  *:.***..*. *: * :*.::* ** :   * * *: *  :"""
  with open("seqs.aln", "w") as f:
    f.write(aln2)
  f = any_file("seqs.aln")
  f.assert_file_type("aln")
  assert (f.file_object.names == ["1mru_A", "2h34_A"])

def exercise_hhr():
  hhr_file = libtbx.env.find_in_repositories(
    relative_path="phenix_regression/misc/hewl.hhr",
    test=os.path.isfile)
  if (hhr_file is not None):
    f = any_file(hhr_file, valid_types=["seq","aln","hhr","txt"])
    assert (f.file_type == "hhr")
    assert (type(f.file_object).__name__ == "hhsearch_parser")

def exercise_xml():
  xml_file = libtbx.env.find_in_repositories(
    relative_path="phenix_regression/misc/hewl.xml",
    test=os.path.isfile)
  if (xml_file is not None):
    f = any_file(xml_file, valid_types=["seq","aln","hhr","xml","txt"])
    assert (f.file_type == "xml")
    assert (f.file_object.nodeName == "#document")
    assert (len(f.file_object.childNodes) == 2)
    assert (f.file_object.childNodes[1].nodeName == "BlastOutput")

def exercise_maps():
  xplor_map = libtbx.env.find_in_repositories(
    relative_path="phenix_regression/misc/cns.map",
    test=os.path.isfile)
  if xplor_map is not None :
    f = any_file(xplor_map)
    assert f.file_type == "xplor_map"
  ccp4_map = libtbx.env.under_dist(
    module_name="iotbx",
    path="ccp4_map/tst_input.map")
  f = any_file(ccp4_map)
  assert f.file_type == "ccp4_map"

def exercise_hkl():
  #--- HKL
  crystal_symmetry = crystal.symmetry(
    unit_cell=(10,11,12,85,95,100),
    space_group_symbol="P 1")
  miller_set = miller.build_set(
    crystal_symmetry=crystal_symmetry,
    anomalous_flag=False,
    d_min=3)
  input_arrays = [miller_set.array(
    data=flex.random_double(size=miller_set.indices().size()))
      .set_observation_type_xray_amplitude()
        for i in [0,1]]
  mtz_dataset = input_arrays[0].as_mtz_dataset(column_root_label="F0")
  mtz_dataset.mtz_object().write("tmp1.mtz")
  hkl = any_file("tmp1.mtz")
  assert hkl.file_type == "hkl"
  #assert hkl.file_server
  assert hkl.file_server.miller_arrays[0].info().labels == ["F0"]
  os.remove("tmp1.mtz")

def exercise_misc():
  file_names = ["foo.pdb", "foo.mtz", "bar.pdb", "bar.mtz", "seq.dat"]
  file_types = ["pdb", "hkl", "pdb", "hkl", "seq"]
  for i, file_name in enumerate(file_names):
    f = open(file_name, "w")
    f.write("1")
    f.close()
    input_file = file_reader.any_file_fast(file_name)
    assert (input_file.file_type == file_types[i])
    if (input_file.file_type == "hkl"):
      assert (input_file.file_object.file_type() == "CCP4 MTZ")
  file_names = sort_by_file_type(file_names, sort_order=["pdb","hkl","seq"])
  assert (file_names == ['foo.pdb','bar.pdb','foo.mtz','bar.mtz','seq.dat'])
  wc = file_reader.get_wildcard_strings(["hkl","pdb","seq"])
  if (sys.platform == "darwin"):
    assert (wc == """Reflections file (*.mtz, *.hkl, *.sca, *.cns, *.xplor, *.cv, *.ref, *.fobs)|*.mtz;*.hkl;*.sca;*.cns;*.xplor;*.cv;*.ref;*.fobs|Model file (*.pdb, *.ent, *.cif)|*.pdb;*.ent;*.cif|Sequence file (*.fa, *.faa, *.seq, *.pir, *.dat, *.fasta)|*.fa;*.faa;*.seq;*.pir;*.dat;*.fasta|All files (*.*)|*.*""")
  wc = file_reader.get_wildcard_strings([])
  assert (wc == """All files (*.*)|*.*""")

def exercise_groups():
  files = [
    "/data/user/project1/p1.sca",
    "/data/user/project2/p2.pdb",
    "/data/user/project1/p1.pdb",
    "/data/user/project1/process/mosflm.log",
    "/data/user/project4/refine/current.pdb",
    "/data/user/project3/data.sca",
    "/data/user/project3/model.pdb",
    "/data/user/project2/native.mtz",
    "/data/user/project3/ligands.cif",
    "/data/user/project4/data.mtz",
    "/data/user/project4/refine/ligands.cif",
    #"/data/user/project2/p2_reindex.pdb",
    #"/data/user/project2/p2_reindex.mtz",
    "/data/user/new_data.hkl",
    "/data/user/project5/model.pdb",
    "/data/user/project5/model2.pdb",
    "/data/user/project5/anom.mtz",
  ]
  g = group_files(files)
  assert (g.ambiguous_files == ['/data/user/new_data.hkl',
                                '/data/user/project5/anom.mtz'])
  assert (g.ungrouped_files == [])
  assert (g.grouped_files == [
    ['/data/user/project2/p2.pdb',
      '/data/user/project2/native.mtz'],
    ['/data/user/project1/p1.pdb',
      '/data/user/project1/p1.sca',
      '/data/user/project1/process/mosflm.log'],
    ['/data/user/project4/refine/current.pdb',
      '/data/user/project4/data.mtz',
      '/data/user/project4/refine/ligands.cif'],
    ['/data/user/project3/model.pdb',
      '/data/user/project3/data.sca',
      '/data/user/project3/ligands.cif'],
    ['/data/user/project5/model.pdb'],
    ['/data/user/project5/model2.pdb'],
  ])
  g = group_files(files, template_format="hkl")
  assert (g.ambiguous_files == [])
  assert (g.ungrouped_files == [])
  assert (g.grouped_files == [
    ['/data/user/project1/p1.sca',
      '/data/user/project1/p1.pdb',
      '/data/user/project1/process/mosflm.log'],
    ['/data/user/project3/data.sca',
      '/data/user/project3/model.pdb',
      '/data/user/project3/ligands.cif'],
    ['/data/user/project2/native.mtz',
      '/data/user/project2/p2.pdb'],
    ['/data/user/project4/data.mtz',
      '/data/user/project4/refine/current.pdb',
      '/data/user/project4/refine/ligands.cif'],
    ['/data/user/new_data.hkl'],
    ['/data/user/project5/anom.mtz',
      '/data/user/project5/model.pdb',
      '/data/user/project5/model2.pdb']
  ])

def exercise():
  exercise_sequence2()
  exercise_mmcif()
  exercise_groups()
  exercise_misc()
  exercise_cif()
  exercise_pdb()
  exercise_phil()
  exercise_pickle()
  exercise_sequence()
  exercise_alignment()
  exercise_hhr()
  exercise_xml()
  exercise_maps()
  if mtz is None :
    print("Skipping mtz file tests")
  else :
    exercise_hkl()
  print("OK")

if __name__ == "__main__" :
  exercise()
#---end


 *******************************************************************************


 *******************************************************************************
iotbx/regression/tst_generate_n_char_string.py
from __future__ import absolute_import, division, print_function

def test_1():
  """
  Test generate_n_char_string method, iterator that generates strings of
  length n_char
  """

  from iotbx.pdb.utils import generate_n_char_string
  string_list = []
  g = generate_n_char_string(n_chars=2)
  for i in range(1000):
    string_list.append(g.next())
  assert [string_list[55], string_list[900], string_list[87]] == "A3 Og BZ".split(), "%s %s %s" %(string_list[55], string_list[900], string_list[87])

  string_list = []
  g = generate_n_char_string(n_chars=2, include_upper=False)
  for i in range(1000):
    string_list.append(g.next())
  assert [string_list[55], string_list[900], string_list[87]] == "bt za cp".split(), "%s %s %s" %(string_list[55], string_list[900], string_list[87])

  string_list = []
  g = generate_n_char_string(n_chars=2, include_numbers=False)
  for i in range(1000):
    string_list.append(g.next())
  assert [string_list[55], string_list[900], string_list[87]] == "BD RQ Bj".split(), "%s %s %s" %(string_list[55], string_list[900], string_list[87])

  string_list = []
  g = generate_n_char_string(n_chars=1, include_special_chars=True)
  for i in range(120):
    string_list.append(g.next())
    if string_list[-1] is None:
      string_list = string_list[:-1]
      break
  assert [string_list[55], string_list[89], string_list[86]] == " 3 + %".split(), "%s %s %s" %(string_list[55], string_list[89], string_list[86])

  string_list = []
  g = generate_n_char_string(n_chars=3, include_upper=False,
    include_lower=False,
   include_numbers=True,
   include_special_chars=False,
   end_with_tilde=True)
  for i in range(1000):
    string_list.append(g.next())
    if string_list[-1] is None: break
  assert [string_list[55], string_list[57], string_list[23]] == "55~ 57~ 23~".split(), "%s %s %s" %(string_list[55], string_list[57], string_list[23])

  print("OK")

if (__name__ == "__main__"):
  test_1()


 *******************************************************************************


 *******************************************************************************
iotbx/regression/tst_group_rounding.py
from __future__ import absolute_import, division, print_function
from iotbx.pdb.hierarchy import group_rounding


def tst_1():
  """ Test cases where nothing should happen"""
  assert group_rounding([0.222222], 2) == [0.222222]
  assert group_rounding([5.222], 2) == [5.222]
  # sum less than 1
  assert group_rounding([0.222222, 0.22222], 2) == [0.222222, 0.22222]
  assert group_rounding([0.222222, 0.22222, 0.2, 0.2], 2) == [0.222222, 0.22222, 0.2, 0.2]

  # sum greater than 1
  assert group_rounding([0.5222222, 0.522222], 2) == [0.5222222, 0.522222]
  assert group_rounding([0.5222222, 0.522222, 0.2, 0.2], 2) == [0.5222222, 0.522222, 0.2, 0.2]

def tst_2():
  """ Test cases where rounding should occur"""
  # straightforward cases, no special procedure would have needed
  assert group_rounding([0.4555555, 0.5444445],3) == [0.456, 0.544]
  assert group_rounding([0.4555555, 0.5444445],2) == [0.46, 0.54]
  assert group_rounding([0.250001, 0.249999, 0.5],3) == [0.25, 0.25, 0.5]
  assert group_rounding([0.250001, 0.249999, 0.5],2) == [0.25, 0.25, 0.5]
  assert group_rounding([0.250001, 0.249999, 0.1, 0.1, 0.1, 0.1, 0.1],2) == [0.25, 0.25, 0.1, 0.1, 0.1, 0.1, 0.1]

def tst_3():
  # interesting cases, where standard rounding would exceed sum of 1
  assert group_rounding([0.545, 0.455],2) == [0.55, 0.45]
  assert group_rounding([0.125, 0.125, 0.75], 2) == [0.13, 0.12, 0.75]
  assert group_rounding([0.75, 0.125, 0.125], 2) == [0.75, 0.13, 0.12]
  assert group_rounding([0.125, 0.125, 0.5, 0.25], 2) == [0.13, 0.12, 0.5, 0.25]

  assert group_rounding([0.5005, 0.4995],3) == [0.5, 0.5]
  assert group_rounding([0.7555, 0.2445],3) == [0.756, 0.244]
  assert group_rounding([0.5555, 0.2445, 0.2],3) == [0.556, 0.244, 0.2]

if (__name__ == "__main__"):
  tst_1()
  tst_2()
  tst_3()


 *******************************************************************************


 *******************************************************************************
iotbx/regression/tst_hierarchy_altlocs.py
from __future__ import absolute_import, division, print_function
import iotbx.pdb
from six.moves import cStringIO as StringIO
from libtbx.test_utils import show_diff

pdb_str1 = """
ATOM      1  N  AVAL A   1      -4.898   0.072  13.387  0.49  7.34           N
ATOM      2  CA AVAL A   1      -4.626   0.703  12.080  0.49  7.71           C
ATOM      3  C  AVAL A   1      -3.475   1.680  12.227  0.49  7.52           C
ATOM      4  O  AVAL A   1      -3.125   2.100  13.335  0.49  7.59           O
ATOM      5  CB AVAL A   1      -5.882   1.390  11.495  0.49  7.79           C
ATOM      6  CG1AVAL A   1      -6.979   0.367  11.258  0.49  7.20           C
ATOM      7  CG2AVAL A   1      -6.359   2.496  12.408  0.49  7.81           C
ATOM      8  H1 AVAL A   1      -4.794  -0.809  13.318  0.49  8.81           H
ATOM      9  H2 AVAL A   1      -4.331   0.391  13.995  0.49  8.81           H
ATOM     10  H3 AVAL A   1      -5.733   0.254  13.636  0.49  8.81           H
ATOM     11  HA AVAL A   1      -4.371   0.017  11.444  0.49  9.26           H
ATOM     12  HB AVAL A   1      -5.655   1.790  10.641  0.49  9.35           H
HETATM 2211  O   HOH S 216       9.105  -6.647  -4.343  0.25 56.37           O
HETATM 2219  O  BHOH S 224       6.977   3.045   9.044  0.31 55.60           O
"""

pdb_str2 = """
HETATM 2174  O   HOH S 179      -5.781   7.569   9.276  0.24 14.70           O
HETATM 2174  O  AHOH S 179      -5.781   7.569   9.276  0.24 14.70           O
HETATM 2174  O   HOH S 179      -4.781   7.569   9.276  0.24 14.70           H
HETATM 2174  O  CHOH S 179      -6.781   7.569   9.276  0.24 14.70           H
END
"""

pdb_str3 = """
HETATM 2174  O   HOH S 179      -5.781   7.569   9.276  0.24 14.70           O
HETATM 2174  O   HOH S 179      -5.781   7.569   9.276  0.24 14.70           O
HETATM 2174  O   HOH S 179      -4.781   7.569   9.276  0.24 14.70           H
HETATM 2174  O   HOH S 179      -6.781   7.569   9.276  0.24 14.70           H
END
"""

pdb_str4 = """
ATOM      1  N   ALA A   1      -4.898   0.072  13.387  0.49  7.34           N
ATOM      2  CA  ALA A   1      -4.626   0.703  12.080  0.49  7.71           C
ATOM      3  C   ALA A   1      -3.475   1.680  12.227  0.49  7.52           C
ATOM      4  O   ALA A   1      -3.125   2.100  13.335  0.49  7.59           O
ATOM      5  CB  ALA A   1      -5.882   1.390  11.495  0.49  7.79           C
ATOM      5  CB AALA A   1      -5.882   1.390  11.495  0.49  7.79           C
"""

pdb_str5 = """
ATOM      1  N   ALA A   1      -4.898   0.072  13.387  0.49  7.34           N
ATOM      2  CA  ALA A   1      -4.626   0.703  12.080  0.49  7.71           C
ATOM      3  C   ALA A   1      -3.475   1.680  12.227  0.49  7.52           C
ATOM      4  O   ALA A   1      -3.125   2.100  13.335  0.49  7.59           O
ATOM      5  CB AALA A   1      -5.882   1.390  11.495  0.49  7.79           C
ATOM      5  CB BALA A   1      -5.882   1.390  11.495  0.49  7.79           C
"""

pdb_str6 = """
HETATM 2174  O   HOH S 179      -5.781   7.569   9.276  0.24 14.70           O
"""
def get_h_oc(s):
  h = iotbx.pdb.input(source_info=None, lines=s).construct_hierarchy()
  oc = h.overall_counts()
  return h, oc

#
# This is current state of affairs. This was also the case in
# Phenix 1.20 and 1.18.
#

def tst1():
  """Everything is good here, empty altloc as expected.
  """
  h, oc = get_h_oc(pdb_str1)
  altlocs = [ag.altloc for ag in h.only_model().atom_groups()]
  assert altlocs == ['A', '', 'B'], altlocs
  assert oc.n_alt_conf_improper == 0, oc.n_alt_conf_improper
  assert oc.duplicate_atom_labels == [], list(oc.duplicate_atom_labels)
  #

def tst2():
  """There's duplicated atom - HOH without altloc. It gets whitespace: ' ',
  but overall_counts has several warnings.
  """
  h, oc = get_h_oc(pdb_str2)
  altlocs = [ag.altloc for ag in h.only_model().atom_groups()]
  assert altlocs == [' ', 'A', 'C'], altlocs
  # for a in h.atoms():
  #   print("%s '%s'" % (a.id_str(), a.parent().altloc))

  # Things that let one know about improper alt conf:
  assert oc.n_alt_conf_improper == 1, oc.n_alt_conf_improper
  assert len(oc.duplicate_atom_labels) == 1, list(oc.duplicate_atom_labels)

  duplicate_output = StringIO()
  oc.show_duplicate_atom_labels(out=duplicate_output)
  do_value = duplicate_output.getvalue()
  assert not show_diff(do_value, """\
number of groups of duplicate atom labels: 1
  total number of affected atoms:          2
  group "HETA    .*.  O   HOH S 179 .*.     O  "
        "HETA    .*.  O   HOH S 179 .*.     H  "
""")

def tst3():
  """ This is a simple case of duplicated atom labels:
  no n_alt_conf_improper
  """
  h, oc = get_h_oc(pdb_str3)
  altlocs = [ag.altloc for ag in h.only_model().atom_groups()]
  assert altlocs == [''], altlocs
  assert oc.n_alt_conf_improper == 0, oc.n_alt_conf_improper
  assert len(oc.duplicate_atom_labels) == 1, list(oc.duplicate_atom_labels)

  duplicate_output = StringIO()
  oc.show_duplicate_atom_labels(out=duplicate_output)
  do_value = duplicate_output.getvalue()
  assert not show_diff(do_value, """\
number of groups of duplicate atom labels: 1
  total number of affected atoms:          4
  group "HETA    .*.  O   HOH S 179 .*.     O  "
        "HETA    .*.  O   HOH S 179 .*.     O  "
        "HETA    .*.  O   HOH S 179 .*.     H  "
        "HETA    .*.  O   HOH S 179 .*.     H  "
""")

def tst4():
  """This is pure case where only n_alt_conf_improper shows problem,
  but no duplicated atom labels.
  """
  # Here we have a residue with one atom duplicated out of several.
  # CB atoms get ' ' and 'A' altlocs, while the rest get ''.
  h, oc = get_h_oc(pdb_str4)
  altlocs = [ag.altloc for ag in h.only_model().atom_groups()]
  # for a in h.atoms():
  #   print("%s '%s'" % (a.id_str(), a.parent().altloc))
  assert altlocs == ['', ' ', 'A'], altlocs
  assert oc.n_alt_conf_improper == 1, oc.n_alt_conf_improper
  assert len(oc.duplicate_atom_labels) == 0, list(oc.duplicate_atom_labels)

  duplicate_output = StringIO()
  oc.show_duplicate_atom_labels(out=duplicate_output)
  do_value = duplicate_output.getvalue()
  assert not show_diff(do_value, "")

def tst5():
  """putting whitespace into already created hierarchy results
  in exactly same behavior as having incorrect one:
  here we transform good hierarchy into one from tst4 by changing
  altloc A to ' ' and get the same n_alt_conf_improper == 1."""
  h, oc = get_h_oc(pdb_str5)
  altlocs = [ag.altloc for ag in h.only_model().atom_groups()]
  assert altlocs == ['', 'A', 'B'], altlocs
  assert oc.n_alt_conf_improper == 0, oc.n_alt_conf_improper
  assert len(oc.duplicate_atom_labels) == 0, list(oc.duplicate_atom_labels)

  # Now we change altloc A to ' '
  h.atoms()[-2].parent().altloc = ' '
  # h.atoms()[-1].parent().altloc = ' '

  altlocs = [ag.altloc for ag in h.only_model().atom_groups()]
  assert altlocs == ['', ' ', 'B'], altlocs
  # print(h.as_pdb_string())
  oc2 = h.overall_counts()
  assert oc2.n_alt_conf_improper == 1, oc2.n_alt_conf_improper
  assert len(oc2.duplicate_atom_labels) == 0, list(oc2.duplicate_atom_labels)

def tst6():
  """Putting whitespace into altloc seem to always result
  in n_alt_conf_improper.
  """
  h, oc = get_h_oc(pdb_str6)
  altlocs = [ag.altloc for ag in h.only_model().atom_groups()]
  assert altlocs == [''], altlocs
  assert oc.n_alt_conf_improper == 0, oc.n_alt_conf_improper
  assert len(oc.duplicate_atom_labels) == 0, list(oc.duplicate_atom_labels)

  # Now we change altloc A to ' '
  h.atoms()[0].parent().altloc = ' '
  altlocs = [ag.altloc for ag in h.only_model().atom_groups()]
  assert altlocs == [' '], altlocs
  oc2 = h.overall_counts()
  assert oc2.n_alt_conf_improper == 1, oc2.n_alt_conf_improper
  assert len(oc2.duplicate_atom_labels) == 0, list(oc2.duplicate_atom_labels)


if (__name__ == "__main__"):
  tst1()
  tst2()
  tst3()
  tst4()
  tst5()
  tst6()
  print("OK")


 *******************************************************************************


 *******************************************************************************
iotbx/regression/tst_hierarchy_copy_select.py
from __future__ import absolute_import, division, print_function
import time
import iotbx.pdb

pdb_str = """
ATOM      1  N   GLY A   1      -9.009   4.612   6.102  1.00 16.77           N
ATOM      2  CA  GLY A   1      -9.052   4.207   4.651  1.00 16.57           C
ATOM      3  C   GLY A   1      -8.015   3.140   4.419  1.00 16.16           C
ATOM      4  O   GLY A   1      -7.523   2.521   5.381  1.00 16.78           O
ATOM      5  N   ASN A   2      -7.656   2.923   3.155  1.00 15.02           N
ATOM      6  CA  ASN A   2      -6.522   2.038   2.831  1.00 14.10           C
ATOM      7  C   ASN A   2      -5.241   2.537   3.427  1.00 13.13           C
ATOM      8  O   ASN A   2      -4.978   3.742   3.426  1.00 11.91           O
ATOM      9  CB  ASN A   2      -6.346   1.881   1.341  1.00 15.38           C
ATOM     10  CG  ASN A   2      -7.584   1.342   0.692  1.00 14.08           C
ATOM     11  OD1 ASN A   2      -8.025   0.227   1.016  1.00 17.46           O
ATOM     12  ND2 ASN A   2      -8.204   2.155  -0.169  1.00 11.72           N
ATOM     13  N   ASN A   3      -4.438   1.590   3.905  1.00 12.26           N
ATOM     14  CA  ASN A   3      -3.193   1.904   4.589  1.00 11.74           C
ATOM     15  C   ASN A   3      -1.955   1.332   3.895  1.00 11.10           C
ATOM     16  O   ASN A   3      -1.872   0.119   3.648  1.00 10.42           O
ATOM     17  CB  ASN A   3      -3.259   1.378   6.042  1.00 12.15           C
ATOM     18  CG  ASN A   3      -2.006   1.739   6.861  1.00 12.82           C
ATOM     19  OD1 ASN A   3      -1.702   2.925   7.072  1.00 15.05           O
"""

def get_h_and_sel():
  inp = iotbx.pdb.input(lines=pdb_str, source_info=None)
  h = inp.construct_hierarchy()
  asc=h.atom_selection_cache()
  sel = asc.selection(string = "all")
  return h, sel


# In these tests we will use id_str() to show if the information is available in the hierarchy
# These tests show how .select() can corrupt resulting hierarchy if not done carefully.

def test1():
  """Normal operations  """
  h, sel = get_h_and_sel()
  assert h.atoms()[0].id_str() == 'pdb=" N   GLY A   1 "', "'%s'" % h.atoms()[0].id_str()
  sel_h = h.select(sel)
  assert sel_h.atoms()[0].id_str() == 'pdb=" N   GLY A   1 "', "'%s'" % sel_h.atoms()[0].id_str()

def test2():
  """ Still works"""
  h, sel = get_h_and_sel()
  assert h.atoms()[0].id_str() == 'pdb=" N   GLY A   1 "', "'%s'" % h.atoms()[0].id_str()
  copy_h = h.deep_copy()
  sel_h = copy_h.select(sel)
  assert sel_h.atoms()[0].id_str() == 'pdb=" N   GLY A   1 "', "'%s'" % sel_h.atoms()[0].id_str()

def test3():
  """ Does not work"""
  h, sel = get_h_and_sel()
  assert h.atoms()[0].id_str() == 'pdb=" N   GLY A   1 "', "'%s'" % h.atoms()[0].id_str()
  sel_h = h.deep_copy().select(sel)
  print("There is no info:", sel_h.atoms()[0].id_str())
  print("And no parent:", sel_h.atoms()[0].parent())
  # assert sel_h.atoms()[0].id_str() == 'pdb=" N   GLY A   1 "', "'%s'" % sel_h.atoms()[0].id_str()

def test4():
  """ What happened in test3(): """
  h, sel = get_h_and_sel()
  assert h.atoms()[0].id_str() == 'pdb=" N   GLY A   1 "', "'%s'" % h.atoms()[0].id_str()
  copy_h = h.deep_copy()
  sel_h = copy_h.select(sel)
  # Everything is good for now
  assert sel_h.atoms()[0].id_str() == 'pdb=" N   GLY A   1 "', "'%s'" % sel_h.atoms()[0].id_str()
  del copy_h
  # but when the copy_h is deleted (or garbage collector removes it) the info is gone:
  # That's exactly what happens when one does sel_h = h.deep_copy().select(), the result of
  # h.deep_copy() is dropped immediately.
  print("Info is gone:", sel_h.atoms()[0].id_str())
  # assert sel_h.atoms()[0].id_str() == 'pdb=" N   GLY A   1 "', "'%s'" % sel_h.atoms()[0].id_str()

def test5():
  """ That's how test3 should be written, note copy_atoms=True """
  h, sel = get_h_and_sel()
  assert h.atoms()[0].id_str() == 'pdb=" N   GLY A   1 "', "'%s'" % h.atoms()[0].id_str()
  sel_h = h.deep_copy().select(sel, copy_atoms=True)
  print("Info is still here:", sel_h.atoms()[0].id_str())
  assert sel_h.atoms()[0].id_str() == 'pdb=" N   GLY A   1 "', "'%s'" % sel_h.atoms()[0].id_str()

if (__name__ == "__main__"):
  t0 = time.time()
  test1()
  test2()
  test3()
  test4()
  test5()
  print("OK. Time: %8.3f"%(time.time()-t0))


 *******************************************************************************


 *******************************************************************************
iotbx/regression/tst_hierarchy_forward_compatible_pdb.py
from __future__ import absolute_import, division, print_function
import time
import iotbx.pdb

# ------------------------------------------------------------------------------

# from https://github.com/wwPDB/extended-wwPDB-identifier-examples
# https://github.com/wwPDB/extended-wwPDB-identifier-examples/blob/main/Models/7fgz-extended_CCD_code-model.cif
mmcif_str = '''
data_XXXX
#
loop_
_atom_site.group_PDB
_atom_site.id
_atom_site.type_symbol
_atom_site.label_atom_id
_atom_site.label_alt_id
_atom_site.label_comp_id
_atom_site.label_asym_id
_atom_site.label_entity_id
_atom_site.label_seq_id
_atom_site.pdbx_PDB_ins_code
_atom_site.Cartn_x
_atom_site.Cartn_y
_atom_site.Cartn_z
_atom_site.occupancy
_atom_site.B_iso_or_equiv
_atom_site.pdbx_formal_charge
_atom_site.auth_seq_id
_atom_site.auth_comp_id
_atom_site.auth_asym_id
_atom_site.auth_atom_id
_atom_site.pdbx_PDB_model_num
ATOM   2140 N  N   . LYS A 1 261 ? 0.399   -10.171 39.802 1.00 40.11 ? 279 LYS A N   1
ATOM   2141 C  CA  . LYS A 1 261 ? -0.169  -9.988  41.173 1.00 43.86 ? 279 LYS A CA  1
ATOM   2142 C  C   . LYS A 1 261 ? 0.687   -9.011  41.991 1.00 41.94 ? 279 LYS A C   1
ATOM   2143 O  O   . LYS A 1 261 ? 1.044   -7.920  41.556 1.00 39.32 ? 279 LYS A O   1
ATOM   2144 C  CB  . LYS A 1 261 ? -0.260  -11.336 41.902 1.00 46.47 ? 279 LYS A CB  1
ATOM   2145 C  CG  . LYS A 1 261 ? -1.583  -12.074 41.713 1.00 49.13 ? 279 LYS A CG  1
ATOM   2146 C  CD  . LYS A 1 261 ? -1.611  -13.468 42.315 1.00 51.03 ? 279 LYS A CD  1
ATOM   2147 C  CE  . LYS A 1 261 ? -2.923  -13.799 42.993 1.00 52.86 ? 279 LYS A CE  1
ATOM   2148 N  NZ  . LYS A 1 261 ? -3.209  -12.856 44.100 1.00 54.19 ? 279 LYS A NZ  1
HETATM 2149 CA CA  . CA  B 2 .   ? -17.362 -22.385 28.047 1.00 15.20 ? 301 CA  A CA  1
HETATM 2150 N  N1  . 7ZTVU C 3 .   ? -7.743  -6.355  8.243  1.00 18.72 ? 302 7ZTVU A N1  1
HETATM 2151 C  C2  . 7ZTVU C 3 .   ? -8.462  -5.534  9.265  1.00 16.68 ? 302 7ZTVU A C2  1
HETATM 2152 C  C3  . 7ZTVU C 3 .   ? -8.092  -5.865  10.711 1.00 17.35 ? 302 7ZTVU A C3  1
HETATM 2153 N  N4  . 7ZTVU C 3 .   ? -7.975  -7.334  10.767 1.00 17.04 ? 302 7ZTVU A N4  1
HETATM 2154 C  C5  . 7ZTVU C 3 .   ? -6.781  -7.689  10.027 1.00 17.11 ? 302 7ZTVU A C5  1
HETATM 2155 C  C6  . 7ZTVU C 3 .   ? -7.363  -7.730  8.633  1.00 16.97 ? 302 7ZTVU A C6  1
HETATM 2156 C  C7  . 7ZTVU C 3 .   ? -8.071  -7.951  12.064 1.00 16.77 ? 302 7ZTVU A C7  1
HETATM 2157 C  C8  . 7ZTVU C 3 .   ? -8.490  -9.440  12.025 1.00 16.60 ? 302 7ZTVU A C8  1
HETATM 2158 O  O8  . 7ZTVU C 3 .   ? -8.391  -10.140 10.781 1.00 14.14 ? 302 7ZTVU A O8  1
HETATM 2159 C  C9  . 7ZTVU C 3 .   ? -8.438  -6.311  6.935  1.00 20.13 ? 302 7ZTVU A C9  1
HETATM 2160 C  C10 . 7ZTVU C 3 .   ? -7.646  -6.965  5.796  1.00 22.62 ? 302 7ZTVU A C10 1
HETATM 2161 S  S   . 7ZTVU C 3 .   ? -8.372  -6.708  4.279  1.00 24.90 ? 302 7ZTVU A S   1
HETATM 2162 O  O1S . 7ZTVU C 3 .   ? -7.579  -7.371  3.224  1.00 25.47 ? 302 7ZTVU A O1S 1
HETATM 2163 O  O2S . 7ZTVU C 3 .   ? -8.533  -5.211  4.078  1.00 25.01 ? 302 7ZTVU A O2S 1
HETATM 2164 O  O3S . 7ZTVU C 3 .   ? -9.691  -7.326  4.282  1.00 26.42 ? 302 7ZTVU A O3S 1
HETATM 2165 N  N1  . 7ZTVU D 3 .   ? -11.233 1.732   10.446 1.00 74.61 ? 303 7ZTVU A N1  1
HETATM 2166 C  C2  . 7ZTVU D 3 .   ? -11.682 2.495   9.264  1.00 77.03 ? 303 7ZTVU A C2  1
HETATM 2167 C  C3  . 7ZTVU D 3 .   ? -11.907 3.979   9.617  1.00 76.82 ? 303 7ZTVU A C3  1
HETATM 2168 N  N4  . 7ZTVU D 3 .   ? -12.335 4.282   11.022 1.00 73.77 ? 303 7ZTVU A N4  1
HETATM 2169 C  C5  . 7ZTVU D 3 .   ? -12.654 3.123   11.908 1.00 69.90 ? 303 7ZTVU A C5  1
HETATM 2170 C  C6  . 7ZTVU D 3 .   ? -12.333 1.719   11.409 1.00 69.07 ? 303 7ZTVU A C6  1
HETATM 2171 C  C7  . 7ZTVU D 3 .   ? -11.415 5.232   11.725 1.00 71.46 ? 303 7ZTVU A C7  1
HETATM 2172 C  C8  . 7ZTVU D 3 .   ? -12.126 5.976   12.871 1.00 70.74 ? 303 7ZTVU A C8  1
HETATM 2173 O  O8  . 7ZTVU D 3 .   ? -11.360 5.921   14.096 1.00 61.89 ? 303 7ZTVU A O8  1
HETATM 2174 C  C9  . 7ZTVU D 3 .   ? -10.756 0.357   10.142 1.00 74.40 ? 303 7ZTVU A C9  1
HETATM 2175 C  C10 . 7ZTVU D 3 .   ? -10.121 -0.289  11.396 1.00 75.92 ? 303 7ZTVU A C10 1
HETATM 2176 S  S   . 7ZTVU D 3 .   ? -8.757  -1.214  11.091 1.00 77.53 ? 303 7ZTVU A S   1
HETATM 2177 O  O1S . 7ZTVU D 3 .   ? -7.735  -0.305  10.525 1.00 74.01 ? 303 7ZTVU A O1S 1
HETATM 2178 O  O2S . 7ZTVU D 3 .   ? -9.042  -2.313  10.141 1.00 83.78 ? 303 7ZTVU A O2S 1
HETATM 2179 O  O3S . 7ZTVU D 3 .   ? -8.264  -1.864  12.321 1.00 70.44 ? 303 7ZTVU A O3S 1
HETATM 2180 O  O   . HOH E 4 .   ? 10.567  -6.539  28.064 1.00 30.11 ? 401 HOH A O   1
HETATM 2181 O  O   . HOH E 4 .   ? 2.856   -8.848  40.692 1.00 32.14 ? 402 HOH A O   1
HETATM 2182 O  O   . HOH E 4 .   ? -10.577 -29.762 22.833 1.00 22.07 ? 403 HOH A O   1
HETATM 2183 O  O   . HOH E 4 .   ? 14.705  -5.437  13.988 1.00 28.06 ? 404 HOH A O   1
'''
mmcif_str_1 = '''data_default
loop_
  _struct_asym.id
   A
   B

loop_
  _chem_comp.id
   GLYD
   GLYHABC

loop_
  _atom_site.group_PDB
  _atom_site.id
  _atom_site.label_atom_id
  _atom_site.label_alt_id
  _atom_site.label_comp_id
  _atom_site.auth_asym_id
  _atom_site.auth_seq_id
  _atom_site.pdbx_PDB_ins_code
  _atom_site.Cartn_x
  _atom_site.Cartn_y
  _atom_site.Cartn_z
  _atom_site.occupancy
  _atom_site.B_iso_or_equiv
  _atom_site.type_symbol
  _atom_site.pdbx_formal_charge
  _atom_site.label_asym_id
  _atom_site.label_entity_id
  _atom_site.label_seq_id
  _atom_site.pdbx_PDB_model_num
   ATOM 1 CA . GLYG ABCDEFG 1 ? 12.47000 12.95700 8.06900 1.000 30.00000 C ? A ? 1 1
   ATOM 2 CA . GLYHABCD DEFGHIL 1 ? 12.47000 12.95700 8.06900 1.000 30.00000 C ? B ? 1 1
'''
mmcif_str_3 = '''
data_XXXX
#
loop_
_atom_site.group_PDB
_atom_site.id
_atom_site.type_symbol
_atom_site.label_atom_id
_atom_site.label_alt_id
_atom_site.label_comp_id
_atom_site.label_asym_id
_atom_site.label_entity_id
_atom_site.label_seq_id
_atom_site.pdbx_PDB_ins_code
_atom_site.Cartn_x
_atom_site.Cartn_y
_atom_site.Cartn_z
_atom_site.occupancy
_atom_site.B_iso_or_equiv
_atom_site.pdbx_formal_charge
_atom_site.auth_seq_id
_atom_site.auth_comp_id
_atom_site.auth_asym_id
_atom_site.auth_atom_id
_atom_site.pdbx_PDB_model_num
ATOM   2141 C  CA  . LYS A 1 261 ? -0.169  -9.988  41.173 1.00 43.86 ? 261 LYS A C  1
ATOM   2142 C  CA  . LYS A 1 262 ? 0.687   -9.011  41.991 1.00 41.94 ? 262 LYS A C   1
ATOM   2143 C  CA  . LYS A 1 263 ? 1.044   -7.920  41.556 1.00 39.32 ? 263 LYS A C   1
ATOM   2144 C  CA  . LYS A 1 264 ? -0.260  -11.336 41.902 1.00 46.47 ? 264 LYS A C  1
'''
mmcif_str_4 = '''data_default
loop_
  _struct_asym.id
   A

loop_
  _chem_comp.id
   GLY

loop_
  _atom_site.group_PDB
  _atom_site.id
  _atom_site.label_atom_id
  _atom_site.label_alt_id
  _atom_site.label_comp_id
  _atom_site.auth_asym_id
  _atom_site.auth_seq_id
  _atom_site.pdbx_PDB_ins_code
  _atom_site.Cartn_x
  _atom_site.Cartn_y
  _atom_site.Cartn_z
  _atom_site.occupancy
  _atom_site.B_iso_or_equiv
  _atom_site.type_symbol
  _atom_site.pdbx_formal_charge
  _atom_site.label_asym_id
  _atom_site.label_entity_id
  _atom_site.label_seq_id
  _atom_site.pdbx_PDB_model_num
   ATOM 1 CA . GLY A 1 ? 12.47000 12.95700 8.06900 1.000 30.00000 C ? A ? 1 1
   ATOM 2 CA . GLY A 2 ? 12.47000 12.95700 8.06900 1.000 30.00000 C ? A ? 1 1
'''

def test1():
  """
  Test methods in conversion_tables with mmcif_str
  """
  inp = iotbx.pdb.input(lines=mmcif_str.split("\n"), source_info=None)
  ph = inp.construct_hierarchy()

  from iotbx.pdb.forward_compatible_pdb_cif_conversion import forward_compatible_pdb_cif_conversion
  conversion_info = forward_compatible_pdb_cif_conversion(hierarchy = ph)
  print(conversion_info.conversion_as_remark_hetnam_string())

def test2():
  """
  Test methods in conversion_tables with mmcif_str_1
  """
  inp = iotbx.pdb.input(lines=mmcif_str_1.split("\n"), source_info=None)
  ph = inp.construct_hierarchy()

  from iotbx.pdb.forward_compatible_pdb_cif_conversion import forward_compatible_pdb_cif_conversion
  conversion_info = forward_compatible_pdb_cif_conversion(hierarchy = ph)
  print(conversion_info.conversion_as_remark_hetnam_string())

def test3():
  """
  Test methods in conversion_tables with mmcif_str_1 and
    set_conversion_tables_from_remark_hetnam_records
  """
  inp = iotbx.pdb.input(lines=mmcif_str_1.split("\n"), source_info=None)
  ph = inp.construct_hierarchy()

  from iotbx.pdb.forward_compatible_pdb_cif_conversion import forward_compatible_pdb_cif_conversion
  conversion_info = forward_compatible_pdb_cif_conversion(hierarchy = ph,
    residue_conversion_as_remark = True)
  remark_hetnam_string = conversion_info.conversion_as_remark_hetnam_string()

  new_conversion_info = forward_compatible_pdb_cif_conversion()
  new_conversion_info.set_conversion_tables_from_remark_hetnam_records(
    remark_hetnam_records = remark_hetnam_string.splitlines())
  new_remark_hetnam_string = new_conversion_info.conversion_as_remark_hetnam_string()
  print(new_remark_hetnam_string)
  assert remark_hetnam_string == new_remark_hetnam_string

def test3a():
  """
  Test methods in conversion_tables with mmcif_str_1 and
    set_conversion_tables_from_remark_hetnam_records
  """
  inp = iotbx.pdb.input(lines=mmcif_str_1.split("\n"), source_info=None)
  ph = inp.construct_hierarchy()

  from iotbx.pdb.forward_compatible_pdb_cif_conversion import forward_compatible_pdb_cif_conversion
  conversion_info = forward_compatible_pdb_cif_conversion(hierarchy = ph,
    residue_conversion_as_remark = False,
    residue_conversion_as_hetnam = True,
     )
  remark_hetnam_string = conversion_info.conversion_as_remark_hetnam_string()
  print("OLD\n",remark_hetnam_string)

  new_conversion_info = forward_compatible_pdb_cif_conversion(
     residue_conversion_as_remark = False,
     residue_conversion_as_hetnam = True,
     )
  new_conversion_info.set_conversion_tables_from_remark_hetnam_records(
    remark_hetnam_records = remark_hetnam_string.splitlines())
  new_remark_hetnam_string = new_conversion_info.conversion_as_remark_hetnam_string()
  print("NEW\n",new_remark_hetnam_string)
  assert remark_hetnam_string == new_remark_hetnam_string

def test4():
  """
  Test methods in conversion_tables with mmcif_str_1 and
    set_conversion_tables_from_remark_hetnam_records and read remarks as part
    of input string
  """
  inp = iotbx.pdb.input(lines=mmcif_str_1.split("\n"), source_info=None)
  ph = inp.construct_hierarchy()

  from iotbx.pdb.forward_compatible_pdb_cif_conversion import forward_compatible_pdb_cif_conversion
  conversion_info = forward_compatible_pdb_cif_conversion(hierarchy = ph)
  remark_hetnam_string = conversion_info.conversion_as_remark_hetnam_string()

  # convert to forward_compatible_pdb
  conversion_info.convert_hierarchy_to_forward_compatible_pdb_representation(ph)
  new_string = ph.as_pdb_string()
  print("NEW STRING (forward_compatible_pdb)\n%s" %(new_string))
  new_inp = iotbx.pdb.input(lines=(remark_hetnam_string + new_string).split("\n"),
      source_info=None,
      )
  new_remark_hetnam_string = "\n".join(new_inp.remark_section())
  new_ph = new_inp.construct_hierarchy()
  print("New ph as string:\n",new_ph.as_pdb_string())

  from iotbx.pdb.forward_compatible_pdb_cif_conversion import forward_compatible_pdb_cif_conversion
  new_conversion_info = forward_compatible_pdb_cif_conversion()
  new_conversion_info.set_conversion_tables_from_remark_hetnam_records(
    remark_hetnam_records = new_remark_hetnam_string.splitlines())
  updated_remark_hetnam_string = new_conversion_info.conversion_as_remark_hetnam_string()
  print("\nNew remark string:\n",new_remark_hetnam_string)
  print("\nUpdated remark string:\n",updated_remark_hetnam_string)
  assert remark_hetnam_string == updated_remark_hetnam_string

def test5():
  """
  Test standard uses of forward_compatible_pdb to hierarchy conversions
  """

  print("\nTest 5, standard uses of forward_compatible_pdb to hierarchy conversions")

  # Get a hierarchy that is not forward_compatible_pdb compatible
  from iotbx.pdb.forward_compatible_pdb_cif_conversion import pdb_or_mmcif_string_as_hierarchy
  ph = pdb_or_mmcif_string_as_hierarchy(mmcif_str_1).hierarchy

  # Write a forward_compatible_pdb compatible string with conversion information in REMARKs
  from iotbx.pdb.forward_compatible_pdb_cif_conversion import hierarchy_as_forward_compatible_pdb_string
  forward_compatible_pdb_string =  hierarchy_as_forward_compatible_pdb_string(ph)
  print("Hierarchy as forward_compatible_pdb string with REMARKS:\n%s" %(forward_compatible_pdb_string))

  # convert forward_compatible_pdb_string to a hierarchy
  from iotbx.pdb.forward_compatible_pdb_cif_conversion import pdb_or_mmcif_string_as_hierarchy
  new_ph = pdb_or_mmcif_string_as_hierarchy(forward_compatible_pdb_string).hierarchy
  new_forward_compatible_pdb_string =  hierarchy_as_forward_compatible_pdb_string(new_ph)
  print("Hierarchy after writing/reading as forward_compatible_pdb string with REMARKS:\n%s" %(new_forward_compatible_pdb_string))
  assert forward_compatible_pdb_string == new_forward_compatible_pdb_string

  # strip off REMARKS from forward_compatible_pdb_string, read in and apply conversions
  from iotbx.pdb.forward_compatible_pdb_cif_conversion import forward_compatible_pdb_cif_conversion
  conversion_info = forward_compatible_pdb_cif_conversion(ph)
  forward_compatible_pdb_string_no_remarks = remove_remarks_hetnam(forward_compatible_pdb_string)
  print("forward_compatible_pdb_string with no remarks:\n%s\n" %(forward_compatible_pdb_string_no_remarks))

  updated_ph = pdb_or_mmcif_string_as_hierarchy(forward_compatible_pdb_string_no_remarks).hierarchy
  # Apply the conversions to obtain a full representation in updated_ph
  conversion_info.convert_hierarchy_to_full_representation(updated_ph)

  # Get updated forward_compatible_pdb string
  updated_forward_compatible_pdb_string =  hierarchy_as_forward_compatible_pdb_string(updated_ph)
  print("Hierarchy after writing/reading as forward_compatible_pdb string without REMARKS and restoring conversion:\n%s" %(updated_forward_compatible_pdb_string))
  assert updated_forward_compatible_pdb_string == forward_compatible_pdb_string

  # Initialize conversion_info with unique_values_dict
  conversion_info = forward_compatible_pdb_cif_conversion(ph)
  unique_values_dict = {}
  unique_values_dict['chain_id'] = \
     conversion_info._unique_chain_ids_from_hierarchy(ph)
  unique_values_dict['resname'] = \
      conversion_info._unique_resnames_from_hierarchy(ph)
  new_conversion_info = forward_compatible_pdb_cif_conversion(
    unique_values_dict = unique_values_dict)
  print("\nConversion info using unique_values_dict:")
  print(conversion_info.conversion_as_remark_hetnam_string())
  assert conversion_info.conversion_as_remark_hetnam_string() == new_conversion_info.conversion_as_remark_hetnam_string()

def test6():
  print("Testing use of ph.as_mmcif_string(segid_as_auth_segid=True)")

  # Get a hierarchy
  from iotbx.pdb.forward_compatible_pdb_cif_conversion \
     import pdb_or_mmcif_string_as_hierarchy
  ph = pdb_or_mmcif_string_as_hierarchy(mmcif_str_4).hierarchy
  # Add segid to the hierarchy and set chain ID and resnames
  i = 0
  for model in ph.models():
    for chain in model.chains():
        for residue_group in chain.residue_groups():
          for atom_group in residue_group.atom_groups():
            for atom in atom_group.atoms():
              atom.set_segid('UNK')
  ph_as_string = ph.as_pdb_string()
  ph_as_mmcif_string_auth_segid = ph.as_mmcif_string(segid_as_auth_segid=True)
  ph_as_mmcif_string_no_auth_segid = ph.as_mmcif_string(
      segid_as_auth_segid=False)
  new_ph_auth_segid = pdb_or_mmcif_string_as_hierarchy(
     ph_as_mmcif_string_auth_segid).hierarchy
  new_ph_no_auth_segid = pdb_or_mmcif_string_as_hierarchy(
     ph_as_mmcif_string_no_auth_segid).hierarchy
  new_ph_auth_segid_as_string = new_ph_auth_segid.as_pdb_string(
     force_write=True)
  new_ph_no_auth_segid_as_string = new_ph_no_auth_segid.as_pdb_string(
     force_write=True)

  #print("ph_as_string\n",ph_as_string)
  #print("ph_as_mmcif_string_auth_segid\n",ph_as_mmcif_string_auth_segid)
  #print("ph_as_mmcif_string_no_auth_segid\n",ph_as_mmcif_string_no_auth_segid)
  #print("new_ph_auth_segid_as_string\n",new_ph_auth_segid_as_string)
  #print("new_ph_no_auth_segid_as_string\n",new_ph_no_auth_segid_as_string)
  assert ph_as_string.find(" UNK  C")>-1
  assert ph_as_mmcif_string_auth_segid.find("1  1  UNK") > -1
  assert ph_as_mmcif_string_no_auth_segid.find("0  1  UNK") < 0
  assert ph_as_mmcif_string_no_auth_segid.find(" UNK ") > -1
  assert ph_as_string == new_ph_auth_segid_as_string

def test7():
  """
  Test get_unique_values_dict
  """
  print("Testing get_unique_values_dict")
  inp = iotbx.pdb.input(lines=mmcif_str_1.split("\n"), source_info=None)
  ph = inp.construct_hierarchy()
  from iotbx.pdb.forward_compatible_pdb_cif_conversion import \
    get_unique_values_dict
  unique_values_dict = get_unique_values_dict([ph])
  assert unique_values_dict == {
    'chain_id': ['ABCDEFG', 'DEFGHIL'], 'resname': ['GLYG', 'GLYHABCD']}

def test8():
  print("Testing use of ph.as_mmcif_string(output_break_string=True)")

  # Get a hierarchy
  from iotbx.pdb.forward_compatible_pdb_cif_conversion import pdb_or_mmcif_string_as_hierarchy
  ph = pdb_or_mmcif_string_as_hierarchy(mmcif_str_3).hierarchy
  # Add segid to the hierarchy
  i = 0
  for model in ph.models():
    for chain in model.chains():
      for residue_group in chain.residue_groups():
        i+= 1
        if i == 2:
           residue_group.link_to_previous = False
  ph1 = pdb_or_mmcif_string_as_hierarchy(ph.as_mmcif_string()).hierarchy
  assert ph1.as_pdb_string().find("BREAK") == -1
  ph2 = pdb_or_mmcif_string_as_hierarchy(
      ph.as_mmcif_string(output_break_records=True)).hierarchy
  assert ph2.as_pdb_string().find("BREAK") > -1

def remove_remarks_hetnam(text):
  new_text_list = []
  for line in text.splitlines():
    if line.startswith("REMARK"):continue
    if line.startswith("HETNAM"):continue
    new_text_list.append(line)
  return "\n".join(new_text_list)
if (__name__ == "__main__"):
  t0 = time.time()
  test1()
  test2()
  test3()
  test3a()
  test4()
  test5()
  test6()
  test7()
  test8()
  print("OK. Time: %8.3f"%(time.time()-t0))


 *******************************************************************************


 *******************************************************************************
iotbx/regression/tst_hierarchy_id_str.py
from __future__ import absolute_import, division, print_function

from libtbx.utils import format_cpu_times
from libtbx.test_utils import show_diff
from iotbx import pdb

def awl(a):
  return a.fetch_labels()

def exercise_awl_id_str():
  # The same as atom id_str test, but converting to atom_with_labels for all checks.
  a = pdb.hierarchy.atom()
  a.set_name(new_name="NaMe")
  a.set_serial(new_serial="B1234")
  assert awl(a).id_str() == 'pdb="NaMe           "'
  assert awl(a).id_str(pdbres=True) == 'pdbres="          "'
  ag = pdb.hierarchy.atom_group(altloc="A", resname="longGLY")
  ag.append_atom(a)
  assert awl(a).id_str() == 'pdb="NaMeAlongGLY       "', "'%s'" % awl(a).id_str()
  assert awl(a).id_str(True) == 'pdbres="longGLY       "'
  rg = pdb.hierarchy.residue_group(resseq="1234", icode="J")
  rg.append_atom_group(ag)
  assert awl(a).id_str() == 'pdb="NaMeAlongGLY  1234J"'
  assert awl(a).id_str(pdbres=True) == 'pdbres="longGLY  1234J"'
  ch = pdb.hierarchy.chain(id="dlinCh")
  ch.append_residue_group(rg)
  assert awl(a).id_str() == 'pdb="NaMeAlongGLYdlinCh1234J"'
  assert awl(a).id_str(pdbres=True) == 'pdbres="longGLYdlinCh1234J"'
  md = pdb.hierarchy.model()
  md.append_chain(ch)
  assert awl(a).id_str() == 'pdb="NaMeAlongGLYdlinCh1234J"'
  assert awl(a).id_str(pdbres=True) == 'pdbres="longGLYdlinCh1234J"'
  md.id = ""
  assert awl(a).id_str() == 'pdb="NaMeAlongGLYdlinCh1234J"'
  assert awl(a).id_str(pdbres=True) == 'pdbres="longGLYdlinCh1234J"'
  md.id = "1"
  assert awl(a).id_str() == 'model="   1" pdb="NaMeAlongGLYdlinCh1234J"'
  assert awl(a).id_str(pdbres=True) == 'model="   1" pdbres="longGLYdlinCh1234J"'
  md.id = "12345678"
  assert awl(a).id_str() == 'model="12345678" pdb="NaMeAlongGLYdlinCh1234J"'
  assert awl(a).id_str(pdbres=True) == 'model="12345678" pdbres="longGLYdlinCh1234J"'

  md.id = "12345678"
  a.segid = "1234"

  assert awl(a).id_str(suppress_segid=False) \
      == 'model="12345678" pdb="NaMeAlongGLYdlinCh1234J" segid="1234"', a.id_str(suppress_segid=False)
  assert awl(a).id_str(suppress_segid=True) \
      == 'model="12345678" pdb="NaMeAlongGLYdlinCh1234J"'
  assert awl(a).id_str(pdbres=True) \
      == 'model="12345678" pdbres="longGLYdlinCh1234J" segid="1234"'
  assert awl(a).id_str(pdbres=True, suppress_segid=True) \
      == 'model="12345678" pdbres="longGLYdlinCh1234J"'
  md.id = ""
  assert awl(a).id_str() == 'pdb="NaMeAlongGLYdlinCh1234J" segid="1234"'
  assert awl(a).id_str(pdbres=True) \
      == 'pdbres="longGLYdlinCh1234J" segid="1234"'
  assert awl(a).id_str(pdbres=True, suppress_segid=True) \
      == 'pdbres="longGLYdlinCh1234J"'
  rt = pdb.hierarchy.root()
  rt.append_model(md)
  assert awl(a).id_str() == 'pdb="NaMeAlongGLYdlinCh1234J" segid="1234"'
  assert awl(a).id_str(pdbres=True) == 'pdbres="longGLYdlinCh1234J" segid="1234"'
  md.id = "    "
  assert awl(a).id_str() == 'model="    " pdb="NaMeAlongGLYdlinCh1234J" segid="1234"'
  assert awl(a).id_str(pdbres=True) \
      == 'model="    " pdbres="longGLYdlinCh1234J" segid="1234"'


def exercise_atom_residue_id_str():
  a = pdb.hierarchy.atom()
  a.set_name(new_name="NaMe")
  a.set_serial(new_serial="B1234")
  assert a.id_str() == 'pdb="NaMe           "'
  assert a.id_str(pdbres=True) == 'pdbres="          "'
  ag = pdb.hierarchy.atom_group(altloc="A", resname="longGLY")
  ag.append_atom(a)
  assert a.id_str() == 'pdb="NaMeAlongGLY       "'
  assert a.id_str(True) == 'pdbres="longGLY       "'

  rg = pdb.hierarchy.residue_group(resseq="1234", icode="J")
  rg.append_atom_group(ag)
  assert a.id_str() == 'pdb="NaMeAlongGLY  1234J"'
  assert a.id_str(pdbres=True) == 'pdbres="longGLY  1234J"'
  ch = pdb.hierarchy.chain(id="dlinCh")
  ch.append_residue_group(rg)
  assert a.id_str() == 'pdb="NaMeAlongGLYdlinCh1234J"'
  assert a.id_str(pdbres=True) == 'pdbres="longGLYdlinCh1234J"'
  md = pdb.hierarchy.model()
  md.append_chain(ch)
  assert a.id_str() == 'pdb="NaMeAlongGLYdlinCh1234J"'
  assert a.id_str(pdbres=True) == 'pdbres="longGLYdlinCh1234J"'
  md.id = ""
  assert a.id_str() == 'pdb="NaMeAlongGLYdlinCh1234J"'
  assert a.id_str(pdbres=True) == 'pdbres="longGLYdlinCh1234J"'
  md.id = "1"
  assert a.id_str() == 'model="   1" pdb="NaMeAlongGLYdlinCh1234J"'
  assert a.id_str(pdbres=True) == 'model="   1" pdbres="longGLYdlinCh1234J"'
  md.id = "12345678"
  assert a.id_str() == 'model="12345678" pdb="NaMeAlongGLYdlinCh1234J"'
  assert a.id_str(pdbres=True) == 'model="12345678" pdbres="longGLYdlinCh1234J"'

  md.id = "12345678"
  a.segid = "1234"

  assert a.id_str(suppress_segid=False) \
      == 'model="12345678" pdb="NaMeAlongGLYdlinCh1234J" segid="1234"', a.id_str(suppress_segid=False)
  assert a.id_str(suppress_segid=True) \
      == 'model="12345678" pdb="NaMeAlongGLYdlinCh1234J"'
  assert a.id_str(pdbres=True) \
      == 'model="12345678" pdbres="longGLYdlinCh1234J" segid="1234"'
  assert a.id_str(pdbres=True, suppress_segid=True) \
      == 'model="12345678" pdbres="longGLYdlinCh1234J"'
  md.id = ""
  assert a.id_str() == 'pdb="NaMeAlongGLYdlinCh1234J" segid="1234"'
  assert a.id_str(pdbres=True) \
      == 'pdbres="longGLYdlinCh1234J" segid="1234"'
  assert a.id_str(pdbres=True, suppress_segid=True) \
      == 'pdbres="longGLYdlinCh1234J"'
  rt = pdb.hierarchy.root()
  rt.append_model(md)
  assert a.id_str() == 'pdb="NaMeAlongGLYdlinCh1234J" segid="1234"'
  assert a.id_str(pdbres=True) == 'pdbres="longGLYdlinCh1234J" segid="1234"'
  md.id = "    "
  assert a.id_str() == 'model="    " pdb="NaMeAlongGLYdlinCh1234J" segid="1234"'
  assert a.id_str(pdbres=True) \
      == 'model="    " pdbres="longGLYdlinCh1234J" segid="1234"'
  #
  cf = ch.only_conformer()
  rd = cf.only_residue()


  # residue
  assert rd.id_str() == 'model="    " pdbres="longGLYdlinCh1234J" segid="1234"', rd.id_str()
  assert rd.id_str(suppress_segid=1) == 'model="    " pdbres="longGLYdlinCh1234J"'
  md.id = "12345678"
  assert rd.id_str() == 'model="12345678" pdbres="longGLYdlinCh1234J" segid="1234"'
  assert rd.id_str(suppress_segid=1) == 'model="12345678" pdbres="longGLYdlinCh1234J"'
  del cf
  assert rd.id_str(suppress_segid=-1) == 'pdbres="longGLY  1234J" segid="1234"', rd.id_str(suppress_segid=-1)
  assert rd.id_str(suppress_segid=1) == 'pdbres="longGLY  1234J"'
  #
  a2 = pdb.hierarchy.atom().set_segid(new_segid="abcd")
  ag.append_atom(atom=a2)
  cf = ch.only_conformer()
  rd = cf.only_residue()
  assert rd.id_str(suppress_segid=1) == 'model="12345678" pdbres="longGLYdlinCh1234J"'
  assert rd.id_str(suppress_segid=-1) == 'model="12345678" pdbres="longGLYdlinCh1234J"'
  try: rd.id_str()
  except ValueError as e:
    assert not show_diff(str(e), '''\
residue.id_str(suppress_segid=false): segid is not unique:
  model="12345678" pdbres="longGLYdlinCh1234J" segid="1234"''')
  else: raise Exception_expected

def exercise_ag_id_str():
  # The function defined in python
  ag = pdb.hierarchy.atom_group()
  ag.altloc='A'
  ag.resname = "ALA"
  assert ag.id_str() == 'AALA       ', "'%s'" % ag.id_str()
  ag.altloc="longAlt"
  ag.resname = "ALAnine"
  assert ag.id_str() == 'longAltALAnine       ', "'%s'" % ag.id_str()

  h = pdb.input(source_info=None, lines="""\
ATOM      6  CA  ASN B   2      -6.522   2.038   2.831  1.00 14.10           C""").construct_hierarchy()
  ag = h.only_model().only_chain().residue_groups()[0].atom_groups()[0]
  assert ag.id_str() == ' ASN B   2 ', "'%s'" % ag.id_str()
  ag.resname='longASN'
  assert ag.id_str() == ' longASN B   2 '
  h.only_model().only_chain().id='dlinB'
  assert ag.id_str() == ' longASNdlinB   2 '
  ag.altloc='A'
  assert ag.id_str() == 'AlongASNdlinB   2 '

def exercise_rg_id_str():
  # The function defined in python
  h = pdb.input(source_info=None, lines="""\
ATOM      6  CA  ASN B   2      -6.522   2.038   2.831  1.00 14.10           C""").construct_hierarchy()
  rg = h.only_model().only_chain().residue_groups()[0]
  assert rg.id_str() == ' B   2 ', "'%s'" % rg.id_str()
  rg.icode='F'
  rg.resseq="A001"
  h.only_model().only_chain().id="dlinB"
  assert rg.id_str() == 'dlinBA001F', "'%s'" % rg.id_str()



if (__name__ == "__main__"):
  exercise_atom_residue_id_str()
  exercise_awl_id_str()
  exercise_ag_id_str()
  exercise_rg_id_str()

  print(format_cpu_times())


 *******************************************************************************


 *******************************************************************************
iotbx/regression/tst_hierarchy_long_chain_ids_1.py
from __future__ import absolute_import, division, print_function
import time
import iotbx.pdb
from libtbx.test_utils import assert_lines_in_text
import mmtbx.model
from mmtbx import monomer_library

# ------------------------------------------------------------------------------

# from https://files.rcsb.org/download/4ZOR-assembly1.cif.gz
mmcif_str = '''
data_XXXX
#
loop_
_audit_author.name
_audit_author.pdbx_ordinal
"Asensio, M.A."     1
"Sankaran, B."      2
"Zwart, P.H."       3
"Tullman-Ercek, D." 4

loop_
_atom_site.group_PDB
_atom_site.id
_atom_site.type_symbol
_atom_site.label_atom_id
_atom_site.label_alt_id
_atom_site.label_comp_id
_atom_site.label_asym_id
_atom_site.label_entity_id
_atom_site.label_seq_id
_atom_site.pdbx_PDB_ins_code
_atom_site.Cartn_x
_atom_site.Cartn_y
_atom_site.Cartn_z
_atom_site.occupancy
_atom_site.B_iso_or_equiv
_atom_site.Cartn_x_esd
_atom_site.Cartn_y_esd
_atom_site.Cartn_z_esd
_atom_site.occupancy_esd
_atom_site.B_iso_or_equiv_esd
_atom_site.pdbx_formal_charge
_atom_site.auth_seq_id
_atom_site.auth_comp_id
_atom_site.auth_asym_id
_atom_site.auth_atom_id
_atom_site.pdbx_PDB_model_num
ATOM   1      N N    . SER A    1 2   ? 157.548 157.308 62.978  1.00 68.85  ? ? ? ? ? ? 2   SER A    N    1
ATOM   2      C CA   . SER A    1 2   ? 156.320 156.678 63.447  1.00 78.79  ? ? ? ? ? ? 2   SER A    CA   1
ATOM   3      C C    . SER A    1 2   ? 155.227 156.764 62.393  1.00 67.20  ? ? ? ? ? ? 2   SER A    C    1
ATOM   4      O O    . SER A    1 2   ? 155.070 157.792 61.737  1.00 65.10  ? ? ? ? ? ? 2   SER A    O    1
ATOM   5      C CB   . SER A    1 2   ? 155.840 157.336 64.744  1.00 85.23  ? ? ? ? ? ? 2   SER A    CB   1
ATOM   6      O OG   . SER A    1 2   ? 154.643 156.734 65.207  1.00 91.40  ? ? ? ? ? ? 2   SER A    OG   1
ATOM   7      H HA   . SER A    1 2   ? 156.493 155.741 63.628  1.00 94.55  ? ? ? ? ? ? 2   SER A    HA   1
ATOM   8      H HB2  . SER A    1 2   ? 156.527 157.235 65.422  1.00 102.28 ? ? ? ? ? ? 2   SER A    HB2  1
ATOM   9      H HB3  . SER A    1 2   ? 155.675 158.277 64.578  1.00 102.28 ? ? ? ? ? ? 2   SER A    HB3  1
ATOM   10     H HG   . SER A    1 2   ? 154.392 157.104 65.918  1.00 109.68 ? ? ? ? ? ? 2   SER A    HG   1
ATOM   11     N N    . ASN A    1 3   ? 154.459 155.689 62.251  1.00 63.77  ? ? ? ? ? ? 3   ASN A    N    1
ATOM   12     C CA   . ASN A    1 3   ? 153.352 155.668 61.304  1.00 65.83  ? ? ? ? ? ? 3   ASN A    CA   1
ATOM   13     C C    . ASN A    1 3   ? 152.088 156.238 61.943  1.00 55.45  ? ? ? ? ? ? 3   ASN A    C    1
ATOM   14     O O    . ASN A    1 3   ? 151.014 156.237 61.341  1.00 50.39  ? ? ? ? ? ? 3   ASN A    O    1
ATOM   15     C CB   . ASN A    1 3   ? 153.102 154.243 60.804  1.00 82.56  ? ? ? ? ? ? 3   ASN A    CB   1
ATOM   16     C CG   . ASN A    1 3   ? 152.881 153.251 61.938  1.00 97.37  ? ? ? ? ? ? 3   ASN A    CG   1
ATOM   17     O OD1  . ASN A    1 3   ? 152.730 153.636 63.100  1.00 93.43  ? ? ? ? ? ? 3   ASN A    OD1  1
ATOM   18     N ND2  . ASN A    1 3   ? 152.861 151.967 61.602  1.00 102.91 ? ? ? ? ? ? 3   ASN A    ND2  1
ATOM   19     H H    . ASN A    1 3   ? 154.559 154.958 62.693  1.00 76.52  ? ? ? ? ? ? 3   ASN A    H    1
ATOM   20     H HA   . ASN A    1 3   ? 153.578 156.220 60.540  1.00 78.99  ? ? ? ? ? ? 3   ASN A    HA   1
ATOM   21     H HB2  . ASN A    1 3   ? 152.310 154.239 60.243  1.00 99.07  ? ? ? ? ? ? 3   ASN A    HB2  1
ATOM   22     H HB3  . ASN A    1 3   ? 153.872 153.947 60.293  1.00 99.07  ? ? ? ? ? ? 3   ASN A    HB3  1
ATOM   23     H HD21 . ASN A    1 3   ? 152.739 151.366 62.205  1.00 123.50 ? ? ? ? ? ? 3   ASN A    HD21 1
ATOM   24     H HD22 . ASN A    1 3   ? 152.969 151.735 60.781  1.00 123.50 ? ? ? ? ? ? 3   ASN A    HD22 1
ATOM   25     N N    . PHE A    1 4   ? 152.244 156.739 63.165  1.00 40.42  ? ? ? ? ? ? 4   PHE A    N    1
ATOM   26     C CA   . PHE A    1 4   ? 151.163 157.355 63.923  1.00 39.55  ? ? ? ? ? ? 4   PHE A    CA   1
ATOM   27     C C    . PHE A    1 4   ? 151.025 158.825 63.522  1.00 39.94  ? ? ? ? ? ? 4   PHE A    C    1
ATOM   28     O O    . PHE A    1 4   ? 151.514 159.719 64.217  1.00 40.63  ? ? ? ? ? ? 4   PHE A    O    1
ATOM   29     C CB   . PHE A    1 4   ? 151.452 157.193 65.421  1.00 39.64  ? ? ? ? ? ? 4   PHE A    CB   1
ATOM   30     C CG   . PHE A    1 4   ? 150.306 157.558 66.329  1.00 38.70  ? ? ? ? ? ? 4   PHE A    CG   1
ATOM   31     C CD1  . PHE A    1 4   ? 149.020 157.744 65.846  1.00 37.96  ? ? ? ? ? ? 4   PHE A    CD1  1
ATOM   32     C CD2  . PHE A    1 4   ? 150.526 157.687 67.689  1.00 38.91  ? ? ? ? ? ? 4   PHE A    CD2  1
ATOM   33     C CE1  . PHE A    1 4   ? 147.985 158.072 66.705  1.00 37.01  ? ? ? ? ? ? 4   PHE A    CE1  1
ATOM   34     C CE2  . PHE A    1 4   ? 149.499 158.013 68.549  1.00 38.16  ? ? ? ? ? ? 4   PHE A    CE2  1
ATOM   35     C CZ   . PHE A    1 4   ? 148.226 158.201 68.059  1.00 48.00  ? ? ? ? ? ? 4   PHE A    CZ   1
ATOM   36     H H    . PHE A    1 4   ? 152.992 156.733 63.589  1.00 48.51  ? ? ? ? ? ? 4   PHE A    H    1
ATOM   37     H HA   . PHE A    1 4   ? 150.329 156.902 63.721  1.00 47.46  ? ? ? ? ? ? 4   PHE A    HA   1
ATOM   38     H HB2  . PHE A    1 4   ? 151.679 156.266 65.594  1.00 47.57  ? ? ? ? ? ? 4   PHE A    HB2  1
ATOM   39     H HB3  . PHE A    1 4   ? 152.203 157.761 65.654  1.00 47.57  ? ? ? ? ? ? 4   PHE A    HB3  1
ATOM   40     H HD1  . PHE A    1 4   ? 148.853 157.658 64.935  1.00 45.56  ? ? ? ? ? ? 4   PHE A    HD1  1
ATOM   41     H HD2  . PHE A    1 4   ? 151.383 157.561 68.028  1.00 46.69  ? ? ? ? ? ? 4   PHE A    HD2  1
ATOM   42     H HE1  . PHE A    1 4   ? 147.126 158.199 66.372  1.00 44.41  ? ? ? ? ? ? 4   PHE A    HE1  1
ATOM   43     H HE2  . PHE A    1 4   ? 149.664 158.100 69.460  1.00 45.79  ? ? ? ? ? ? 4   PHE A    HE2  1
ATOM   44     H HZ   . PHE A    1 4   ? 147.532 158.422 68.637  1.00 57.59  ? ? ? ? ? ? 4   PHE A    HZ   1
ATOM   45     N N    . THR A    1 5   ? 150.358 159.064 62.394  1.00 39.85  ? ? ? ? ? ? 5   THR A    N    1
ATOM   46     C CA   . THR A    1 5   ? 150.317 160.394 61.787  1.00 40.09  ? ? ? ? ? ? 5   THR A    CA   1
ATOM   47     C C    . THR A    1 5   ? 148.902 160.860 61.432  1.00 39.18  ? ? ? ? ? ? 5   THR A    C    1
ATOM   48     O O    . THR A    1 5   ? 147.972 160.058 61.325  1.00 38.69  ? ? ? ? ? ? 5   THR A    O    1
ATOM   49     C CB   . THR A    1 5   ? 151.196 160.436 60.514  1.00 64.25  ? ? ? ? ? ? 5   THR A    CB   1
ATOM   50     O OG1  . THR A    1 5   ? 151.389 161.794 60.102  1.00 64.23  ? ? ? ? ? ? 5   THR A    OG1  1
ATOM   51     C CG2  . THR A    1 5   ? 150.563 159.643 59.376  1.00 40.46  ? ? ? ? ? ? 5   THR A    CG2  1
ATOM   52     H H    . THR A    1 5   ? 149.917 158.468 61.958  1.00 47.81  ? ? ? ? ? ? 5   THR A    H    1
ATOM   53     H HA   . THR A    1 5   ? 150.685 161.031 62.418  1.00 48.11  ? ? ? ? ? ? 5   THR A    HA   1
ATOM   54     H HB   . THR A    1 5   ? 152.059 160.040 60.712  1.00 77.10  ? ? ? ? ? ? 5   THR A    HB   1
ATOM   55     H HG1  . THR A    1 5   ? 151.866 161.820 59.411  1.00 77.08  ? ? ? ? ? ? 5   THR A    HG1  1
ATOM   56     H HG21 . THR A    1 5   ? 151.129 159.683 58.590  1.00 48.55  ? ? ? ? ? ? 5   THR A    HG21 1
ATOM   57     H HG22 . THR A    1 5   ? 150.453 158.716 59.639  1.00 48.55  ? ? ? ? ? ? 5   THR A    HG22 1
ATOM   58     H HG23 . THR A    1 5   ? 149.694 160.014 59.158  1.00 48.55  ? ? ? ? ? ? 5   THR A    HG23 1
ATOM   9413   N N    . SER A-2  1 2   ? 70.577  70.817  62.978  1.00 68.85  ? ? ? ? ? ? 2   SER A-2  N    1
ATOM   9414   C CA   . SER A-2  1 2   ? 71.805  71.447  63.447  1.00 78.79  ? ? ? ? ? ? 2   SER A-2  CA   1
ATOM   9415   C C    . SER A-2  1 2   ? 72.898  71.361  62.393  1.00 67.20  ? ? ? ? ? ? 2   SER A-2  C    1
ATOM   9416   O O    . SER A-2  1 2   ? 73.055  70.333  61.737  1.00 65.10  ? ? ? ? ? ? 2   SER A-2  O    1
ATOM   9417   C CB   . SER A-2  1 2   ? 72.285  70.789  64.744  1.00 85.23  ? ? ? ? ? ? 2   SER A-2  CB   1
ATOM   9418   O OG   . SER A-2  1 2   ? 73.482  71.391  65.207  1.00 91.40  ? ? ? ? ? ? 2   SER A-2  OG   1
ATOM   9419   H HA   . SER A-2  1 2   ? 71.632  72.384  63.628  1.00 94.55  ? ? ? ? ? ? 2   SER A-2  HA   1
ATOM   9420   H HB2  . SER A-2  1 2   ? 71.598  70.890  65.422  1.00 102.28 ? ? ? ? ? ? 2   SER A-2  HB2  1
ATOM   9421   H HB3  . SER A-2  1 2   ? 72.450  69.848  64.578  1.00 102.28 ? ? ? ? ? ? 2   SER A-2  HB3  1
ATOM   9422   H HG   . SER A-2  1 2   ? 73.733  71.021  65.918  1.00 109.68 ? ? ? ? ? ? 2   SER A-2  HG   1
ATOM   9423   N N    . ASN A-2  1 3   ? 73.666  72.436  62.251  1.00 63.77  ? ? ? ? ? ? 3   ASN A-2  N    1
ATOM   9424   C CA   . ASN A-2  1 3   ? 74.773  72.457  61.304  1.00 65.83  ? ? ? ? ? ? 3   ASN A-2  CA   1
ATOM   9425   C C    . ASN A-2  1 3   ? 76.037  71.887  61.943  1.00 55.45  ? ? ? ? ? ? 3   ASN A-2  C    1
ATOM   9426   O O    . ASN A-2  1 3   ? 77.111  71.888  61.341  1.00 50.39  ? ? ? ? ? ? 3   ASN A-2  O    1
ATOM   9427   C CB   . ASN A-2  1 3   ? 75.023  73.882  60.804  1.00 82.56  ? ? ? ? ? ? 3   ASN A-2  CB   1
ATOM   9428   C CG   . ASN A-2  1 3   ? 75.244  74.874  61.938  1.00 97.37  ? ? ? ? ? ? 3   ASN A-2  CG   1
ATOM   9429   O OD1  . ASN A-2  1 3   ? 75.395  74.489  63.100  1.00 93.43  ? ? ? ? ? ? 3   ASN A-2  OD1  1
ATOM   9430   N ND2  . ASN A-2  1 3   ? 75.264  76.158  61.602  1.00 102.91 ? ? ? ? ? ? 3   ASN A-2  ND2  1
ATOM   9431   H H    . ASN A-2  1 3   ? 73.566  73.167  62.693  1.00 76.52  ? ? ? ? ? ? 3   ASN A-2  H    1
ATOM   9432   H HA   . ASN A-2  1 3   ? 74.547  71.905  60.540  1.00 78.99  ? ? ? ? ? ? 3   ASN A-2  HA   1
ATOM   9433   H HB2  . ASN A-2  1 3   ? 75.815  73.886  60.243  1.00 99.07  ? ? ? ? ? ? 3   ASN A-2  HB2  1
ATOM   9434   H HB3  . ASN A-2  1 3   ? 74.253  74.178  60.293  1.00 99.07  ? ? ? ? ? ? 3   ASN A-2  HB3  1
ATOM   9435   H HD21 . ASN A-2  1 3   ? 75.386  76.759  62.205  1.00 123.50 ? ? ? ? ? ? 3   ASN A-2  HD21 1
ATOM   9436   H HD22 . ASN A-2  1 3   ? 75.156  76.390  60.781  1.00 123.50 ? ? ? ? ? ? 3   ASN A-2  HD22 1
ATOM   9437   N N    . PHE A-2  1 4   ? 75.881  71.386  63.165  1.00 40.42  ? ? ? ? ? ? 4   PHE A-2  N    1
ATOM   9438   C CA   . PHE A-2  1 4   ? 76.962  70.770  63.923  1.00 39.55  ? ? ? ? ? ? 4   PHE A-2  CA   1
ATOM   9439   C C    . PHE A-2  1 4   ? 77.100  69.300  63.522  1.00 39.94  ? ? ? ? ? ? 4   PHE A-2  C    1
ATOM   9440   O O    . PHE A-2  1 4   ? 76.611  68.406  64.217  1.00 40.63  ? ? ? ? ? ? 4   PHE A-2  O    1
ATOM   9441   C CB   . PHE A-2  1 4   ? 76.673  70.932  65.421  1.00 39.64  ? ? ? ? ? ? 4   PHE A-2  CB   1
ATOM   9442   C CG   . PHE A-2  1 4   ? 77.819  70.567  66.329  1.00 38.70  ? ? ? ? ? ? 4   PHE A-2  CG   1
ATOM   9443   C CD1  . PHE A-2  1 4   ? 79.105  70.381  65.846  1.00 37.96  ? ? ? ? ? ? 4   PHE A-2  CD1  1
ATOM   9444   C CD2  . PHE A-2  1 4   ? 77.599  70.438  67.689  1.00 38.91  ? ? ? ? ? ? 4   PHE A-2  CD2  1
ATOM   9445   C CE1  . PHE A-2  1 4   ? 80.140  70.053  66.705  1.00 37.01  ? ? ? ? ? ? 4   PHE A-2  CE1  1
ATOM   9446   C CE2  . PHE A-2  1 4   ? 78.626  70.112  68.549  1.00 38.16  ? ? ? ? ? ? 4   PHE A-2  CE2  1
ATOM   9447   C CZ   . PHE A-2  1 4   ? 79.899  69.924  68.059  1.00 48.00  ? ? ? ? ? ? 4   PHE A-2  CZ   1
ATOM   9448   H H    . PHE A-2  1 4   ? 75.133  71.392  63.589  1.00 48.51  ? ? ? ? ? ? 4   PHE A-2  H    1
ATOM   9449   H HA   . PHE A-2  1 4   ? 77.796  71.223  63.721  1.00 47.46  ? ? ? ? ? ? 4   PHE A-2  HA   1
ATOM   9450   H HB2  . PHE A-2  1 4   ? 76.446  71.859  65.594  1.00 47.57  ? ? ? ? ? ? 4   PHE A-2  HB2  1
ATOM   9451   H HB3  . PHE A-2  1 4   ? 75.922  70.364  65.654  1.00 47.57  ? ? ? ? ? ? 4   PHE A-2  HB3  1
ATOM   9452   H HD1  . PHE A-2  1 4   ? 79.272  70.467  64.935  1.00 45.56  ? ? ? ? ? ? 4   PHE A-2  HD1  1
ATOM   9453   H HD2  . PHE A-2  1 4   ? 76.742  70.564  68.028  1.00 46.69  ? ? ? ? ? ? 4   PHE A-2  HD2  1
ATOM   9454   H HE1  . PHE A-2  1 4   ? 80.999  69.926  66.372  1.00 44.41  ? ? ? ? ? ? 4   PHE A-2  HE1  1
ATOM   9455   H HE2  . PHE A-2  1 4   ? 78.461  70.025  69.460  1.00 45.79  ? ? ? ? ? ? 4   PHE A-2  HE2  1
ATOM   9456   H HZ   . PHE A-2  1 4   ? 80.593  69.703  68.637  1.00 57.59  ? ? ? ? ? ? 4   PHE A-2  HZ   1
ATOM   9457   N N    . THR A-2  1 5   ? 77.767  69.061  62.394  1.00 39.85  ? ? ? ? ? ? 5   THR A-2  N    1
ATOM   9458   C CA   . THR A-2  1 5   ? 77.808  67.731  61.787  1.00 40.09  ? ? ? ? ? ? 5   THR A-2  CA   1
ATOM   9459   C C    . THR A-2  1 5   ? 79.223  67.265  61.432  1.00 39.18  ? ? ? ? ? ? 5   THR A-2  C    1
ATOM   9460   O O    . THR A-2  1 5   ? 80.153  68.067  61.325  1.00 38.69  ? ? ? ? ? ? 5   THR A-2  O    1
ATOM   9461   C CB   . THR A-2  1 5   ? 76.929  67.689  60.514  1.00 64.25  ? ? ? ? ? ? 5   THR A-2  CB   1
ATOM   9462   O OG1  . THR A-2  1 5   ? 76.736  66.331  60.102  1.00 64.23  ? ? ? ? ? ? 5   THR A-2  OG1  1
ATOM   9463   C CG2  . THR A-2  1 5   ? 77.562  68.482  59.376  1.00 40.46  ? ? ? ? ? ? 5   THR A-2  CG2  1
ATOM   9464   H H    . THR A-2  1 5   ? 78.208  69.657  61.958  1.00 47.81  ? ? ? ? ? ? 5   THR A-2  H    1
ATOM   9465   H HA   . THR A-2  1 5   ? 77.440  67.094  62.418  1.00 48.11  ? ? ? ? ? ? 5   THR A-2  HA   1
ATOM   9466   H HB   . THR A-2  1 5   ? 76.066  68.085  60.712  1.00 77.10  ? ? ? ? ? ? 5   THR A-2  HB   1
ATOM   9467   H HG1  . THR A-2  1 5   ? 76.259  66.305  59.411  1.00 77.08  ? ? ? ? ? ? 5   THR A-2  HG1  1
ATOM   9468   H HG21 . THR A-2  1 5   ? 76.996  68.442  58.590  1.00 48.55  ? ? ? ? ? ? 5   THR A-2  HG21 1
ATOM   9469   H HG22 . THR A-2  1 5   ? 77.672  69.409  59.639  1.00 48.55  ? ? ? ? ? ? 5   THR A-2  HG22 1
ATOM   9470   H HG23 . THR A-2  1 5   ? 78.431  68.111  59.158  1.00 48.55  ? ? ? ? ? ? 5   THR A-2  HG23 1
ATOM   37649  N N    . SER A-5  1 2   ? 62.978  157.548 157.308 1.00 68.85  ? ? ? ? ? ? 2   SER A-5  N    1
ATOM   37650  C CA   . SER A-5  1 2   ? 63.447  156.320 156.678 1.00 78.79  ? ? ? ? ? ? 2   SER A-5  CA   1
ATOM   37651  C C    . SER A-5  1 2   ? 62.393  155.227 156.764 1.00 67.20  ? ? ? ? ? ? 2   SER A-5  C    1
ATOM   37652  O O    . SER A-5  1 2   ? 61.737  155.070 157.792 1.00 65.10  ? ? ? ? ? ? 2   SER A-5  O    1
ATOM   37653  C CB   . SER A-5  1 2   ? 64.744  155.840 157.336 1.00 85.23  ? ? ? ? ? ? 2   SER A-5  CB   1
ATOM   37654  O OG   . SER A-5  1 2   ? 65.207  154.643 156.734 1.00 91.40  ? ? ? ? ? ? 2   SER A-5  OG   1
ATOM   37655  H HA   . SER A-5  1 2   ? 63.628  156.493 155.741 1.00 94.55  ? ? ? ? ? ? 2   SER A-5  HA   1
ATOM   37656  H HB2  . SER A-5  1 2   ? 65.422  156.527 157.235 1.00 102.28 ? ? ? ? ? ? 2   SER A-5  HB2  1
ATOM   37657  H HB3  . SER A-5  1 2   ? 64.578  155.675 158.277 1.00 102.28 ? ? ? ? ? ? 2   SER A-5  HB3  1
ATOM   37658  H HG   . SER A-5  1 2   ? 65.918  154.392 157.104 1.00 109.68 ? ? ? ? ? ? 2   SER A-5  HG   1
ATOM   37659  N N    . ASN A-5  1 3   ? 62.251  154.459 155.689 1.00 63.77  ? ? ? ? ? ? 3   ASN A-5  N    1
ATOM   37660  C CA   . ASN A-5  1 3   ? 61.304  153.352 155.668 1.00 65.83  ? ? ? ? ? ? 3   ASN A-5  CA   1
ATOM   37661  C C    . ASN A-5  1 3   ? 61.943  152.088 156.238 1.00 55.45  ? ? ? ? ? ? 3   ASN A-5  C    1
ATOM   37662  O O    . ASN A-5  1 3   ? 61.341  151.014 156.237 1.00 50.39  ? ? ? ? ? ? 3   ASN A-5  O    1
ATOM   37663  C CB   . ASN A-5  1 3   ? 60.804  153.102 154.243 1.00 82.56  ? ? ? ? ? ? 3   ASN A-5  CB   1
ATOM   37664  C CG   . ASN A-5  1 3   ? 61.938  152.881 153.251 1.00 97.37  ? ? ? ? ? ? 3   ASN A-5  CG   1
ATOM   37665  O OD1  . ASN A-5  1 3   ? 63.100  152.730 153.636 1.00 93.43  ? ? ? ? ? ? 3   ASN A-5  OD1  1
ATOM   37666  N ND2  . ASN A-5  1 3   ? 61.602  152.861 151.967 1.00 102.91 ? ? ? ? ? ? 3   ASN A-5  ND2  1
ATOM   37667  H H    . ASN A-5  1 3   ? 62.693  154.559 154.958 1.00 76.52  ? ? ? ? ? ? 3   ASN A-5  H    1
ATOM   37668  H HA   . ASN A-5  1 3   ? 60.540  153.578 156.220 1.00 78.99  ? ? ? ? ? ? 3   ASN A-5  HA   1
ATOM   37669  H HB2  . ASN A-5  1 3   ? 60.243  152.310 154.239 1.00 99.07  ? ? ? ? ? ? 3   ASN A-5  HB2  1
ATOM   37670  H HB3  . ASN A-5  1 3   ? 60.293  153.872 153.947 1.00 99.07  ? ? ? ? ? ? 3   ASN A-5  HB3  1
ATOM   37671  H HD21 . ASN A-5  1 3   ? 62.205  152.739 151.366 1.00 123.50 ? ? ? ? ? ? 3   ASN A-5  HD21 1
ATOM   37672  H HD22 . ASN A-5  1 3   ? 60.781  152.969 151.735 1.00 123.50 ? ? ? ? ? ? 3   ASN A-5  HD22 1
ATOM   37673  N N    . PHE A-5  1 4   ? 63.165  152.244 156.739 1.00 40.42  ? ? ? ? ? ? 4   PHE A-5  N    1
ATOM   37674  C CA   . PHE A-5  1 4   ? 63.923  151.163 157.355 1.00 39.55  ? ? ? ? ? ? 4   PHE A-5  CA   1
ATOM   37675  C C    . PHE A-5  1 4   ? 63.522  151.025 158.825 1.00 39.94  ? ? ? ? ? ? 4   PHE A-5  C    1
ATOM   37676  O O    . PHE A-5  1 4   ? 64.217  151.514 159.719 1.00 40.63  ? ? ? ? ? ? 4   PHE A-5  O    1
ATOM   37677  C CB   . PHE A-5  1 4   ? 65.421  151.452 157.193 1.00 39.64  ? ? ? ? ? ? 4   PHE A-5  CB   1
ATOM   37678  C CG   . PHE A-5  1 4   ? 66.329  150.306 157.558 1.00 38.70  ? ? ? ? ? ? 4   PHE A-5  CG   1
ATOM   37679  C CD1  . PHE A-5  1 4   ? 65.846  149.020 157.744 1.00 37.96  ? ? ? ? ? ? 4   PHE A-5  CD1  1
ATOM   37680  C CD2  . PHE A-5  1 4   ? 67.689  150.526 157.687 1.00 38.91  ? ? ? ? ? ? 4   PHE A-5  CD2  1
ATOM   37681  C CE1  . PHE A-5  1 4   ? 66.705  147.985 158.072 1.00 37.01  ? ? ? ? ? ? 4   PHE A-5  CE1  1
ATOM   37682  C CE2  . PHE A-5  1 4   ? 68.549  149.499 158.013 1.00 38.16  ? ? ? ? ? ? 4   PHE A-5  CE2  1
ATOM   37683  C CZ   . PHE A-5  1 4   ? 68.059  148.226 158.201 1.00 48.00  ? ? ? ? ? ? 4   PHE A-5  CZ   1
ATOM   37684  H H    . PHE A-5  1 4   ? 63.589  152.992 156.733 1.00 48.51  ? ? ? ? ? ? 4   PHE A-5  H    1
ATOM   37685  H HA   . PHE A-5  1 4   ? 63.721  150.329 156.902 1.00 47.46  ? ? ? ? ? ? 4   PHE A-5  HA   1
ATOM   37686  H HB2  . PHE A-5  1 4   ? 65.594  151.679 156.266 1.00 47.57  ? ? ? ? ? ? 4   PHE A-5  HB2  1
ATOM   37687  H HB3  . PHE A-5  1 4   ? 65.654  152.203 157.761 1.00 47.57  ? ? ? ? ? ? 4   PHE A-5  HB3  1
ATOM   37688  H HD1  . PHE A-5  1 4   ? 64.935  148.853 157.658 1.00 45.56  ? ? ? ? ? ? 4   PHE A-5  HD1  1
ATOM   37689  H HD2  . PHE A-5  1 4   ? 68.028  151.383 157.561 1.00 46.69  ? ? ? ? ? ? 4   PHE A-5  HD2  1
ATOM   37690  H HE1  . PHE A-5  1 4   ? 66.372  147.126 158.199 1.00 44.41  ? ? ? ? ? ? 4   PHE A-5  HE1  1
ATOM   37691  H HE2  . PHE A-5  1 4   ? 69.460  149.664 158.100 1.00 45.79  ? ? ? ? ? ? 4   PHE A-5  HE2  1
ATOM   37692  H HZ   . PHE A-5  1 4   ? 68.637  147.532 158.422 1.00 57.59  ? ? ? ? ? ? 4   PHE A-5  HZ   1
ATOM   37693  N N    . THR A-5  1 5   ? 62.394  150.358 159.064 1.00 39.85  ? ? ? ? ? ? 5   THR A-5  N    1
ATOM   37694  C CA   . THR A-5  1 5   ? 61.787  150.317 160.394 1.00 40.09  ? ? ? ? ? ? 5   THR A-5  CA   1
ATOM   37695  C C    . THR A-5  1 5   ? 61.432  148.902 160.860 1.00 39.18  ? ? ? ? ? ? 5   THR A-5  C    1
ATOM   37696  O O    . THR A-5  1 5   ? 61.325  147.972 160.058 1.00 38.69  ? ? ? ? ? ? 5   THR A-5  O    1
ATOM   37697  C CB   . THR A-5  1 5   ? 60.514  151.196 160.436 1.00 64.25  ? ? ? ? ? ? 5   THR A-5  CB   1
ATOM   37698  O OG1  . THR A-5  1 5   ? 60.102  151.389 161.794 1.00 64.23  ? ? ? ? ? ? 5   THR A-5  OG1  1
ATOM   37699  C CG2  . THR A-5  1 5   ? 59.376  150.563 159.643 1.00 40.46  ? ? ? ? ? ? 5   THR A-5  CG2  1
ATOM   37700  H H    . THR A-5  1 5   ? 61.958  149.917 158.468 1.00 47.81  ? ? ? ? ? ? 5   THR A-5  H    1
ATOM   37701  H HA   . THR A-5  1 5   ? 62.418  150.685 161.031 1.00 48.11  ? ? ? ? ? ? 5   THR A-5  HA   1
ATOM   37702  H HB   . THR A-5  1 5   ? 60.712  152.059 160.040 1.00 77.10  ? ? ? ? ? ? 5   THR A-5  HB   1
ATOM   37703  H HG1  . THR A-5  1 5   ? 59.411  151.866 161.820 1.00 77.08  ? ? ? ? ? ? 5   THR A-5  HG1  1
ATOM   37704  H HG21 . THR A-5  1 5   ? 58.590  151.129 159.683 1.00 48.55  ? ? ? ? ? ? 5   THR A-5  HG21 1
ATOM   37705  H HG22 . THR A-5  1 5   ? 59.639  150.453 158.716 1.00 48.55  ? ? ? ? ? ? 5   THR A-5  HG22 1
ATOM   37706  H HG23 . THR A-5  1 5   ? 59.158  149.694 160.014 1.00 48.55  ? ? ? ? ? ? 5   THR A-5  HG23 1
'''

norm_str = """
ATOM      1  N   GLY A   1      -9.009   4.612   6.102  1.00 16.77           N
ATOM      2  CA  GLY A   1      -9.052   4.207   4.651  1.00 16.57           C
ATOM      3  C   GLY A   1      -8.015   3.140   4.419  1.00 16.16           C
ATOM      4  O   GLY A   1      -7.523   2.521   5.381  1.00 16.78           O
ATOM      5  N   ASN A   2      -7.656   2.923   3.155  1.00 15.02           N
ATOM      6  CA  ASN A   2      -6.522   2.038   2.831  1.00 14.10           C
ATOM      7  C   ASN A   2      -5.241   2.537   3.427  1.00 13.13           C
ATOM      8  O   ASN A   2      -4.978   3.742   3.426  1.00 11.91           O
ATOM      9  CB  ASN A   2      -6.346   1.881   1.341  1.00 15.38           C
ATOM     10  CG  ASN A   2      -7.584   1.342   0.692  1.00 14.08           C
ATOM     11  OD1 ASN A   2      -8.025   0.227   1.016  1.00 17.46           O
ATOM     12  ND2 ASN A   2      -8.204   2.155  -0.169  1.00 11.72           N
ATOM     13  N   ASN A   3      -4.438   1.590   3.905  1.00 12.26           N
ATOM     14  CA  ASN A   3      -3.193   1.904   4.589  1.00 11.74           C
ATOM     15  C   ASN A   3      -1.955   1.332   3.895  1.00 11.10           C
ATOM     16  O   ASN A   3      -1.872   0.119   3.648  1.00 10.42           O
ATOM     17  CB  ASN A   3      -3.259   1.378   6.042  1.00 12.15           C
ATOM     18  CG  ASN A   3      -2.006   1.739   6.861  1.00 12.82           C
ATOM     19  OD1 ASN A   3      -1.702   2.925   7.072  1.00 15.05           O
"""

def test1():
  """
  Test correct reading of long chain ids from mmCIF file into hierarchy.
  Testing output to pdb and cif.
  """
  inp = iotbx.pdb.input(lines=mmcif_str.split("\n"), source_info=None)
  h = inp.construct_hierarchy()
  chains = list(h.overall_counts().chain_ids.keys())
  chains.sort()
  # print(chains)
  answer = ['A', 'A-2', 'A-5']
  assert (chains == answer), '%s %s' % (chains, answer)

  o_pdb_str = h.as_pdb_string()
  # Note here incorrect/trimmed chain id
  # There's no way to correctly output chain ids longer than 2 char in PDB format
  print(o_pdb_str)
  assert o_pdb_str==""
#   assert_lines_in_text(o_pdb_str, """\
# ATOM     61  C   SERA-2   2      72.898  71.361  62.393  1.00 67.20           C
# ATOM     62  O   SERA-2   2      73.055  70.333  61.737  1.00 65.10           O
#     """)

  o_cif_str = "%s" % h.as_cif_block()
  assert_lines_in_text(o_cif_str, """\
  ATOM  116  HG23  .  THR  A-2  5  ?   78.43100   68.11100   59.15800  1.000   48.55000  H  ?  B  ?  4  1
  ATOM  117  N     .  SER  A-5  2  ?   62.97800  157.54800  157.30800  1.000   68.85000  N  ?  C  ?  1  1
    """)

def test2():
  """ Overall counts duplicate atom labels should be 0 if long chain ids
  are processing correctly
  """
  inp = iotbx.pdb.input(lines=mmcif_str.split("\n"), source_info=None)
  h = inp.construct_hierarchy()
  oc = h.overall_counts()
  oc.show()
  assert oc.errors() == []

def test3():
  """ Construct restraints and output .geo file.
  Make sure long chain ids are properly outputted.
  """
  inp = iotbx.pdb.input(lines=mmcif_str.split("\n"), source_info=None)
  m = mmtbx.model.manager(model_input = inp)
  m.process(make_restraints=True)
  geo = m.restraints_as_geo()
  # print (geo)
  for l in [
    'bond pdb=" CA  PHEA-5   4 "',
    'pdb=" CB  PHEA-5   4 "',
    'angle pdb=" C   THRA-5   5 "',
    'dihedral pdb=" N   SERA-5   2 "',
    'chirality pdb=" CA  ASNA-5   3 "',
    'nonbonded pdb=" O   PHEA-5   4 "',]:
    assert_lines_in_text(geo, l)

def test4():
  """
  Test selections
  """
  inp = iotbx.pdb.input(lines=mmcif_str.split("\n"), source_info=None)
  h = inp.construct_hierarchy()
  asc = h.atom_selection_cache()
  s = asc.iselection("chain A")
  assert list(s) == list(range(0,58)), list(s)
  s = asc.iselection("chain A-2")
  assert list(s) == list(range(58,116)), list(s)
  s = asc.iselection("chain A-5")
  assert list(s) == list(range(116,174)), list(s)


if (__name__ == "__main__"):
  t0 = time.time()
  test1()
  test2()
  mon_lib_srv = None
  try:
    mon_lib_srv = monomer_library.server.server()
  except: # intentional
    print("Can not initialize monomer_library, skipping test.")
  if mon_lib_srv is not None:
    test3()
  test4()
  print("OK. Time: %8.3f"%(time.time()-t0))


 *******************************************************************************
