

 *******************************************************************************
cctbx/geometry_restraints/__init__.py
from __future__ import absolute_import, division, print_function
import cctbx.crystal.direct_space_asu # import dependency
from cctbx.array_family import flex
import scitbx.array_family.shared # import dependency
import cctbx.geometry # import dependency
from libtbx.test_utils import approx_equal
from libtbx.str_utils import show_string
from libtbx import group_args

import boost_adaptbx.boost.python as bp
from six.moves import range
from six.moves import zip
ext = bp.import_ext("cctbx_geometry_restraints_ext")
from cctbx_geometry_restraints_ext import *

import scitbx.stl.map
import math
import sys
import six

nonbonded_radius_table = scitbx.stl.map.stl_string_double

nonbonded_distance_table = scitbx.stl.map.stl_string_stl_map_stl_string_double
nonbonded_distance_dict = scitbx.stl.map.stl_string_double

def weight_as_sigma(weight):
  if (weight <= 0): return 0
  return 1/weight**0.5

def sigma_as_weight(sigma):
  if (sigma <= 0): return 0
  return 1/sigma**2

def angle_delta_deg(angle_1, angle_2, periodicity=1):
  half_period = 180./max(1,periodicity)
  d = math.fmod(angle_2-angle_1, 2*half_period)
  if   (d < -half_period): d += 2*half_period
  elif (d >  half_period): d -= 2*half_period
  return d

@bp.inject_into(bond_params_table)
class _():

  def lookup(self, i_seq, j_seq):
    if (i_seq > j_seq): i_seq, j_seq = j_seq, i_seq
    bond_params_by_j_seq = self[i_seq]
    if (j_seq not in bond_params_by_j_seq): return None
    return bond_params_by_j_seq[j_seq]

class proxy_registry_process_result(object):

  def __init__(self,
        tabulated_proxy=None,
        is_new=False,
        is_conflicting=False,
        conflict_source_labels=None):
    self.tabulated_proxy = tabulated_proxy
    self.is_new = is_new
    self.is_conflicting = is_conflicting
    self.conflict_source_labels = conflict_source_labels

class proxy_registry_base(object):

  def __init__(self, proxies, strict_conflict_handling):
    self.proxies = proxies
    self.strict_conflict_handling = strict_conflict_handling
    self.n_resolved_conflicts = 0
    self.discard_table()

  def initialize_table(self):
    self.table = {}
    self.source_labels = flex.std_string()
    self.source_n_expected_atoms = flex.int()

  def discard_table(self):
    self.table = None
    self.source_labels = None
    self.source_n_expected_atoms = None

  def append_custom_proxy(self, proxy):
    assert self.table is None
    self.proxies.append(proxy)

  def _append_proxy(self, source_info, proxy, process_result):
    self.proxies.append(proxy)
    self.source_labels.append(source_info.labels())
    self.source_n_expected_atoms.append(source_info.n_expected_atoms())
    process_result.tabulated_proxy = proxy
    process_result.is_new = True

  def _handle_conflict(self,
        source_info,
        proxy,
        i_list,
        process_result):
    # Almost never called.
    source_n_expected_atoms = source_info.n_expected_atoms()
    if (self.strict_conflict_handling
        or self.source_n_expected_atoms[i_list]
           == source_n_expected_atoms):
      process_result.is_conflicting = True
      process_result.conflict_source_labels = (self.source_labels[i_list],
                                               source_info.labels())
    else:
      self.n_resolved_conflicts += 1
      if (self.source_n_expected_atoms[i_list] < source_n_expected_atoms):
        self.proxies[i_list] = proxy
        self.source_labels[i_list] += ", " + source_info.labels()
        self.source_n_expected_atoms[i_list] = source_n_expected_atoms
        process_result.tabulated_proxy = proxy

class bond_simple_proxy_registry(proxy_registry_base):
  """
  self.table:
  [ {iseq1: Nproxy} ] , index in this array is iseq0
  """

  def __init__(self, n_seq, strict_conflict_handling):
    proxy_registry_base.__init__(self,
      proxies=shared_bond_simple_proxy(),
      strict_conflict_handling=strict_conflict_handling)
    self.n_seq = n_seq

  def expand_with_ncs(self, nrgl, masters_and_rest_iselection):
    # print("original proxies:", [p.i_seqs for p in self.proxies])
    # nrgl._show(brief=False)
    additional_proxies = []
    for i in range(len(self.proxies)):
      p = self.proxies[i]
      new_current_proxy_iseqs = (masters_and_rest_iselection[p.i_seqs[0]],
                                 masters_and_rest_iselection[p.i_seqs[1]])
      new_master_p = bond_simple_proxy(
          i_seqs = new_current_proxy_iseqs,
          distance_ideal=p.distance_ideal,
          weight=p.weight,
          slack=p.slack,
          limit=p.limit,
          top_out=p.top_out,
          origin_id=p.origin_id).sort_i_seqs()
      self.proxies[i] = new_master_p
      all_new_iseqs = nrgl.get_copy_iseqs(new_current_proxy_iseqs)
      # print('  i, p.i_seqs', i, p.i_seqs)
      # print('  all_new_iseqs', all_new_iseqs)
      if all_new_iseqs is not None:
        for new_iseqs in all_new_iseqs:
          new_proxy = bond_simple_proxy(
              i_seqs=new_iseqs,
              distance_ideal=p.distance_ideal,
              weight=p.weight,
              slack=p.slack,
              limit=p.limit,
              top_out=p.top_out,
              origin_id=p.origin_id).sort_i_seqs()
          # marking table
          self.table[new_iseqs[0]][new_iseqs[1]] = self.proxies.size()
          # ~ self._append_proxy
          additional_proxies.append(new_proxy)
          self.source_labels.append(self.source_labels[i])
          self.source_n_expected_atoms.append(self.source_n_expected_atoms[i])
    self.proxies.extend(additional_proxies)


  def initialize_table(self):
    proxy_registry_base.initialize_table(self)
    self.table = [{} for i in range(self.n_seq)]

  def is_proxy_set(self, i_seqs):
    return (i_seqs[1] in self.table[i_seqs[0]])

  def is_any_proxy_set(self, i_seqs, j_seqs):
    for i in i_seqs:
      for j in j_seqs:
        tmp = [i,j]
        tmp.sort()
        ps = self.is_proxy_set(tmp)
        if ps: return ps
    return False

  def process(self, source_info, proxy, tolerance=1.e-6):
    result = proxy_registry_process_result()
    proxy = proxy.sort_i_seqs()
    if (proxy.i_seqs[1] not in self.table[proxy.i_seqs[0]]):
      self.table[proxy.i_seqs[0]][proxy.i_seqs[1]] = self.proxies.size()
      self._append_proxy(
        source_info=source_info,
        proxy=proxy,
        process_result=result)
    else:
      i_list = self.table[proxy.i_seqs[0]][proxy.i_seqs[1]]
      result.tabulated_proxy = self.proxies[i_list]
      if (   abs(result.tabulated_proxy.distance_ideal
                                - proxy.distance_ideal) > tolerance
          or abs(result.tabulated_proxy.weight - proxy.weight)
               > tolerance):
        self._handle_conflict(
          source_info=source_info,
          proxy=proxy,
          i_list=i_list,
          process_result=result)
    return result

class angle_proxy_registry(proxy_registry_base):
  #
  """
  self.table: nested dicts
    { iseq1:
      {
        (iseq0, iseq2) : Nproxy
      }
    }
  """

  def __init__(self, strict_conflict_handling):
    proxy_registry_base.__init__(self,
      proxies=shared_angle_proxy(),
      strict_conflict_handling=strict_conflict_handling)

  def expand_with_ncs(self, nrgl, masters_and_rest_iselection):
    additional_proxies = []
    # n_proxies = len(self.proxies)
    for i in range(len(self.proxies)):
      p = self.proxies[i]
      new_current_proxy_iseqs = [ masters_and_rest_iselection[iseq] for iseq in p.i_seqs]
      new_master_p = angle_proxy(
            i_seqs=new_current_proxy_iseqs,
            proxy=p).sort_i_seqs()
      self.proxies[i] = new_master_p
      all_new_iseqs = nrgl.get_copy_iseqs(new_current_proxy_iseqs)
      if all_new_iseqs is not None:
        for new_iseqs in all_new_iseqs:
          new_proxy = angle_proxy(
              i_seqs=new_iseqs,
              proxy=p).sort_i_seqs()
          # marking table
          tab_i_seq_1 = self.table.setdefault(new_proxy.i_seqs[1], {})
          tab_i_seq_1[(new_proxy.i_seqs[0], new_proxy.i_seqs[2])] = self.proxies.size()
          # ~ self._append_proxy
          additional_proxies.append(new_proxy)
          # self.proxies.append(new_proxy)
          self.source_labels.append(self.source_labels[i])
          self.source_n_expected_atoms.append(self.source_n_expected_atoms[i])
    self.proxies.extend(additional_proxies)

  def add_if_not_duplicated(self, proxy, tolerance=1.e-6):
    assert len(proxy.i_seqs) == 3
    proxy = proxy.sort_i_seqs()
    tab_i_seq_1 = self.table.setdefault(proxy.i_seqs[1], {})
    i_seqs_0_2 = (proxy.i_seqs[0], proxy.i_seqs[2])
    if (i_seqs_0_2 not in tab_i_seq_1):
      tab_i_seq_1[i_seqs_0_2] = self.proxies.size()
      self.proxies.append(proxy)
      return True
    return False

  def process(self, source_info, proxy, tolerance=1.e-6):
    result = proxy_registry_process_result()
    proxy = proxy.sort_i_seqs()
    tab_i_seq_1 = self.table.setdefault(proxy.i_seqs[1], {})
    i_seqs_0_2 = (proxy.i_seqs[0], proxy.i_seqs[2])
    if (i_seqs_0_2 not in tab_i_seq_1):
      tab_i_seq_1[i_seqs_0_2] = self.proxies.size()
      self._append_proxy(
        source_info=source_info,
        proxy=proxy,
        process_result=result)
    else:
      i_list = tab_i_seq_1[i_seqs_0_2]
      result.tabulated_proxy = self.proxies[i_list]
      if (   abs(angle_delta_deg(result.tabulated_proxy.angle_ideal,
                                 proxy.angle_ideal)) > tolerance
          or abs(result.tabulated_proxy.weight - proxy.weight)
               > tolerance):
        self._handle_conflict(
          source_info=source_info,
          proxy=proxy,
          i_list=i_list,
          process_result=result)
    return result

  def lookup_i_proxy(self, i_seqs):
    "See also: cctbx::geometry_restraints::angle_proxy::sort_i_seqs()"
    (i0, i1, i2) = i_seqs
    tab_i_seq_1 = self.table.get(i1)
    if (tab_i_seq_1 is None):
      return None
    if (i0 > i2):
      return tab_i_seq_1.get((i2, i0))
    return tab_i_seq_1.get((i0, i2))

class dihedral_proxy_registry(proxy_registry_base):
  """
  self.table - similar to angle:
    { iseq0:
      {
        (iseq1, iseq2, iseq3) : Nproxy
      }
    }
  """

  def __init__(self, strict_conflict_handling):
    proxy_registry_base.__init__(self,
      proxies=shared_dihedral_proxy(),
      strict_conflict_handling=strict_conflict_handling)

  def expand_with_ncs(self, nrgl, masters_and_rest_iselection):
    additional_proxies = []
    for i in range(len(self.proxies)):
      p = self.proxies[i]
      new_current_proxy_iseqs = [ masters_and_rest_iselection[iseq] for iseq in p.i_seqs]
      new_master_p = dihedral_proxy(
            i_seqs=new_current_proxy_iseqs,
            proxy=p).sort_i_seqs()
      self.proxies[i] = new_master_p
      all_new_iseqs = nrgl.get_copy_iseqs(new_current_proxy_iseqs)
      if all_new_iseqs is not None:
        for new_iseqs in all_new_iseqs:
          new_proxy = dihedral_proxy(
              i_seqs=new_iseqs,
              proxy=p).sort_i_seqs()
          # marking table
          tab_i_seq_0 = self.table.setdefault(new_proxy.i_seqs[0], {})
          tab_i_seq_0[(new_proxy.i_seqs[1], new_proxy.i_seqs[2], new_proxy.i_seqs[3])] = self.proxies.size()
          # ~ self._append_proxy
          additional_proxies.append(new_proxy)
          # self.proxies.append(new_proxy)
          self.source_labels.append(self.source_labels[i])
          self.source_n_expected_atoms.append(self.source_n_expected_atoms[i])
    self.proxies.extend(additional_proxies)

  def add_if_not_duplicated(self, proxy, tolerance=1.e-6):
    assert len(proxy.i_seqs) == 4
    proxy = proxy.sort_i_seqs()
    tab_i_seq_0 = self.table.setdefault(proxy.i_seqs[0], {})
    i_seqs_1_2_3 = (proxy.i_seqs[1], proxy.i_seqs[2], proxy.i_seqs[3])
    if (i_seqs_1_2_3 not in tab_i_seq_0):
      tab_i_seq_0[i_seqs_1_2_3] = self.proxies.size()
      self.proxies.append(proxy)
      return True
    return False

  def process(self, source_info, proxy, tolerance=1.e-6):
    result = proxy_registry_process_result()
    proxy = proxy.sort_i_seqs()
    tab_i_seq_0 = self.table.setdefault(proxy.i_seqs[0], {})
    i_seqs_1_2_3 = (proxy.i_seqs[1], proxy.i_seqs[2], proxy.i_seqs[3])
    if (i_seqs_1_2_3 not in tab_i_seq_0):
      tab_i_seq_0[i_seqs_1_2_3] = self.proxies.size()
      self._append_proxy(
        source_info=source_info,
        proxy=proxy,
        process_result=result)
    else:
      i_list = tab_i_seq_0[i_seqs_1_2_3]
      result.tabulated_proxy = self.proxies[i_list]
      if (   abs(angle_delta_deg(result.tabulated_proxy.angle_ideal,
                                 proxy.angle_ideal,
                                 proxy.periodicity)) > tolerance
          or abs(result.tabulated_proxy.weight - proxy.weight)
               > tolerance
          or result.tabulated_proxy.periodicity != proxy.periodicity):
        self._handle_conflict(
          source_info=source_info,
          proxy=proxy,
          i_list=i_list,
          process_result=result)
    return result

  def lookup_i_proxy(self, i_seqs):
    "See also: cctbx::geometry_restraints::dihedral_proxy::sort_i_seqs()"
    (i0, i1, i2, i3) = i_seqs
    angle_sign = 1
    if (i0 > i3):
      i0, i3 = i3, i0
      angle_sign *= -1
    if (i1 > i2):
      i1, i2 = i2, i1
      angle_sign *= -1
    tab_i_seq_0 = self.table.get(i0)
    if (tab_i_seq_0 is None):
      return (None, None)
    return (tab_i_seq_0.get((i1, i2, i3)), angle_sign)

class chirality_proxy_registry(proxy_registry_base):
  """
  self.table - same as dihedral:
    { iseq0:
      {
        (iseq1, iseq2, iseq3) : Nproxy
      }
    }
  """

  def __init__(self, strict_conflict_handling):
    proxy_registry_base.__init__(self,
      proxies=shared_chirality_proxy(),
      strict_conflict_handling=strict_conflict_handling)

  def expand_with_ncs(self, nrgl, masters_and_rest_iselection):
    additional_proxies = []
    for i in range(len(self.proxies)):
      p = self.proxies[i]
      new_current_proxy_iseqs = [ masters_and_rest_iselection[iseq] for iseq in p.i_seqs]
      new_master_p = chirality_proxy(
            i_seqs=new_current_proxy_iseqs,
            proxy=p).sort_i_seqs()
      self.proxies[i] = new_master_p
      all_new_iseqs = nrgl.get_copy_iseqs(new_current_proxy_iseqs)
      if all_new_iseqs is not None:
        for new_iseqs in all_new_iseqs:
          new_proxy = chirality_proxy(
              i_seqs=new_iseqs,
              proxy=p).sort_i_seqs()
          # marking table
          tab_i_seq_0 = self.table.setdefault(new_proxy.i_seqs[0], {})
          tab_i_seq_0[(new_proxy.i_seqs[1], new_proxy.i_seqs[2], new_proxy.i_seqs[3])] = self.proxies.size()
          # ~ self._append_proxy
          additional_proxies.append(new_proxy)
          # self.proxies.append(new_proxy)
          self.source_labels.append(self.source_labels[i])
          self.source_n_expected_atoms.append(self.source_n_expected_atoms[i])
    self.proxies.extend(additional_proxies)

  def add_if_not_duplicated(self, proxy, tolerance=1.e-6):
    proxy = proxy.sort_i_seqs()
    tab_i_seq_0 = self.table.setdefault(proxy.i_seqs[0], {})
    i_seqs_1_2_3 = (proxy.i_seqs[1], proxy.i_seqs[2], proxy.i_seqs[3])
    if (i_seqs_1_2_3 not in tab_i_seq_0):
      tab_i_seq_0[i_seqs_1_2_3] = self.proxies.size()
      self.proxies.append(proxy)
      return True
    return False


  def process(self, source_info, proxy, tolerance=1.e-6):
    result = proxy_registry_process_result()
    proxy = proxy.sort_i_seqs()
    tab_i_seq_0 = self.table.setdefault(proxy.i_seqs[0], {})
    i_seqs_1_2_3 = (proxy.i_seqs[1], proxy.i_seqs[2], proxy.i_seqs[3])
    if (i_seqs_1_2_3 not in tab_i_seq_0):
      tab_i_seq_0[i_seqs_1_2_3] = self.proxies.size()
      self._append_proxy(
        source_info=source_info,
        proxy=proxy,
        process_result=result)
    else:
      i_list = tab_i_seq_0[i_seqs_1_2_3]
      result.tabulated_proxy = self.proxies[i_list]
      if (   abs(result.tabulated_proxy.volume_ideal - proxy.volume_ideal)
               > tolerance
          or abs(result.tabulated_proxy.weight - proxy.weight)
               > tolerance):
        self._handle_conflict(
          source_info=source_info,
          proxy=proxy,
          i_list=i_list,
          process_result=result)
    return result

class planarity_proxy_registry(proxy_registry_base):
  """
  self.table:

    self.table - similar to dihedral, chiralities, but undefined
      number of iseqs in the nested dictionary keys:
    { iseq0:
      {
        (iseq1, iseq2, iseq3, ... ) : Nproxy
      }
    }

  """

  def __init__(self, strict_conflict_handling):
    proxy_registry_base.__init__(self,
      proxies=shared_planarity_proxy(),
      strict_conflict_handling=strict_conflict_handling)

  def expand_with_ncs(self, nrgl, masters_and_rest_iselection):
    additional_proxies = []
    for i in range(len(self.proxies)):
      p = self.proxies[i]
      new_current_proxy_iseqs = [ masters_and_rest_iselection[iseq] for iseq in p.i_seqs]
      new_master_p = planarity_proxy(
            i_seqs=new_current_proxy_iseqs,
            proxy=p).sort_i_seqs()
      self.proxies[i] = new_master_p
      all_new_iseqs = nrgl.get_copy_iseqs(new_current_proxy_iseqs)
      if all_new_iseqs is not None:
        for new_iseqs in all_new_iseqs:
          new_proxy = planarity_proxy(
              i_seqs=new_iseqs,
              proxy=p).sort_i_seqs()
          # marking table
          tab_i_seq_0 = self.table.setdefault(new_proxy.i_seqs[0], {})
          tab_i_seq_0[(new_proxy.i_seqs[1:])] = self.proxies.size()
          # ~ self._append_proxy
          additional_proxies.append(new_proxy)
          # self.proxies.append(new_proxy)
          self.source_labels.append(self.source_labels[i])
          self.source_n_expected_atoms.append(self.source_n_expected_atoms[i])
    self.proxies.extend(additional_proxies)

  def add_if_not_duplicated(self, proxy, tolerance=1.e-6):
    assert proxy.i_seqs.size() > 2
    proxy = proxy.sort_i_seqs()
    tab_i_seq_0 = self.table.setdefault(proxy.i_seqs[0], {})
    i_seqs_1_up = tuple(proxy.i_seqs[1:])
    if (i_seqs_1_up not in tab_i_seq_0):
      tab_i_seq_0[i_seqs_1_up] = self.proxies.size()
      # saving proxy number in list
      self.proxies.append(proxy)
      return True
    return False

  def process(self, source_info, proxy, tolerance=1.e-6):
    assert proxy.i_seqs.size() > 0
    result = proxy_registry_process_result()
    proxy = proxy.sort_i_seqs()
    tab_i_seq_0 = self.table.setdefault(proxy.i_seqs[0], {})
    i_seqs_1_up = tuple(proxy.i_seqs[1:])
    if (i_seqs_1_up not in tab_i_seq_0):
      tab_i_seq_0[i_seqs_1_up] = self.proxies.size()
      self._append_proxy(
        source_info=source_info,
        proxy=proxy,
        process_result=result)
    else:
      i_list = tab_i_seq_0[i_seqs_1_up]
      result.tabulated_proxy = self.proxies[i_list]
      if (not approx_equal(result.tabulated_proxy.weights, proxy.weights,
                           eps=tolerance)):
        self._handle_conflict(
          source_info=source_info,
          proxy=proxy,
          i_list=i_list,
          process_result=result)
    return result

class parallelity_proxy_registry(proxy_registry_base):
  """
  self.table:
  { ( (iseqs), (jseqs) ) : Nproxy }
  """

  def __init__(self, strict_conflict_handling):
    proxy_registry_base.__init__(self,
        proxies=shared_parallelity_proxy(),
        strict_conflict_handling=strict_conflict_handling)

  def expand_with_ncs(self, nrgl, masters_and_rest_iselection):
    additional_proxies = []
    for i in range(len(self.proxies)):
      p = self.proxies[i]
      new_current_proxy_iseqs = [ masters_and_rest_iselection[iseq] for iseq in p.i_seqs]
      new_current_proxy_jseqs = [ masters_and_rest_iselection[jseq] for jseq in p.j_seqs]
      new_master_p = parallelity_proxy(
            i_seqs=new_current_proxy_iseqs,
            j_seqs=new_current_proxy_jseqs,
            proxy=p).sort_i_seqs()
      self.proxies[i] = new_master_p
      # all_new_iseqs = nrgl.get_copy_iseqs(new_current_proxy_iseqs)
      all_new_iseqs = nrgl.get_copy_iseqs(new_current_proxy_iseqs)
      all_new_jseqs = nrgl.get_copy_iseqs(new_current_proxy_jseqs)
      if all_new_iseqs is not None and all_new_jseqs is not None:
        for new_iseqs, new_jseqs in zip(all_new_iseqs, all_new_jseqs):
          new_proxy = parallelity_proxy(
              i_seqs=new_iseqs,
              j_seqs=new_jseqs,
              proxy=p).sort_i_seqs()
          # marking table
          self.table[(tuple(new_proxy.i_seqs), tuple(new_proxy.j_seqs))] = self.proxies.size()
          # ~ self._append_proxy
          additional_proxies.append(new_proxy)
          # self.proxies.append(new_proxy)
          self.source_labels.append(self.source_labels[i])
          self.source_n_expected_atoms.append(self.source_n_expected_atoms[i])
    self.proxies.extend(additional_proxies)

  def add_if_not_duplicated(self, proxy, tolerance=1.e-6):
    assert proxy.i_seqs.size() > 2
    assert proxy.j_seqs.size() > 2
    proxy = proxy.sort_ij_seqs()
    tab_i_seqs = tuple(proxy.i_seqs)
    tab_j_seqs = tuple(proxy.j_seqs)
    if (self.table.get((tab_i_seqs, tab_j_seqs), -1) <0 and
        self.table.get((tab_j_seqs, tab_i_seqs), -1) <0):
      # saving proxy number in list
      self.table[(tab_i_seqs, tab_j_seqs)]= self.proxies.size()
      self.proxies.append(proxy)
      return True
    return False

  def process(self, source_info, proxy, tolerance=1.e-6):
    assert proxy.i_seqs.size() > 2
    assert proxy.j_seqs.size() > 2
    result = proxy_registry_process_result()
    proxy = proxy.sort_ij_seqs()
    # here we want to make sure that we don't have this proxy yet
    tab_i_seqs = tuple(proxy.i_seqs)
    tab_j_seqs = tuple(proxy.j_seqs)
    if (self.table.get((tab_i_seqs, tab_j_seqs), -1) <0 and
        self.table.get((tab_j_seqs, tab_i_seqs), -1) <0):
      # saving proxy number in list
      self.table[(tab_i_seqs, tab_j_seqs)]= self.proxies.size()
      self._append_proxy(
        source_info=source_info,
        proxy=proxy,
        process_result=result)
    else:
      # conflict, we have precisely the same proxy!!!
      i_list = max(self.table.get((tab_i_seqs, tab_j_seqs), -1),
                   self.table.get((tab_j_seqs, tab_i_seqs), -1))
      # number of duplicated proxy
      result.tabulated_proxy = self.proxies[i_list]
      if (not approx_equal(result.tabulated_proxy.weight, proxy.weight,
                           eps=tolerance)):
        self._handle_conflict(
          source_info=source_info,
          proxy=proxy,
          i_list=i_list,
          process_result=result)
    return result

@bp.inject_into(prolsq_repulsion_function)
class _():

  def customized_copy(O, c_rep=None, k_rep=None, irexp=None, rexp=None):
    if (c_rep is None): c_rep = O.c_rep
    if (k_rep is None): k_rep = O.k_rep
    if (irexp is None): irexp = O.irexp
    if (rexp is None): rexp = O.rexp
    return prolsq_repulsion_function(
      c_rep=c_rep, k_rep=k_rep, irexp=irexp, rexp=rexp)

def _bond_show_sorted_impl(self,
                           by_value,
                           sites_cart,
                           site_labels=None,
                           unit_cell=None,
                           f=None,
                           prefix="",
                           max_items=None,
                           origin_id=None,
                           return_result = False):
  if return_result:
      result = group_args(group_args_type = 'Bond restraints',
        by_value = by_value,
        max_items = max_items,
        value_list = [],
      )

  if unit_cell is None:
    sorted_table, n_not_shown = self.get_sorted(
      by_value=by_value,
      sites_cart=sites_cart,
      site_labels=site_labels,
      max_items=max_items,
      origin_id=origin_id)
  else:
    sorted_table, n_not_shown = self.get_sorted(
      by_value=by_value,
      sites_cart=sites_cart,
      unit_cell=unit_cell,
      site_labels=site_labels,
      max_items=max_items,
      origin_id=origin_id)
  len_sorted_table = 0 if sorted_table is None else len(sorted_table)
  if n_not_shown is None: n_not_shown = 0
  print("%sBond restraints: %d" % (prefix, len_sorted_table+n_not_shown), file=f)
  if (f is None): f = sys.stdout
  if len_sorted_table+n_not_shown==0: return
  print("%sSorted by %s:" % (prefix, by_value), file=f)
  if sorted_table is not None:
    for restraint_info in sorted_table :
      (i_seq,j_seq,  # Always
        labels, distance_ideal, distance_model, slack, delta, sigma, weight,
        residual, sym_op_j, rt_mx) = restraint_info
      s = "bond"
      for label in labels :
        print("%s%4s %s" % (prefix, s, label), file=f)
        s = ""
      if (slack == 0):
        l = ""
        v = ""
      else:
        l = "  slack"
        v = " %6.3f" % slack
      print("%s  ideal  model%s  delta    sigma   weight residual%s" % (
        prefix, l, sym_op_j), file=f)
      print("%s  %5.3f %6.3f%s %6.3f %6.2e %6.2e %6.2e" % (
        prefix, distance_ideal, distance_model, v, delta,
        sigma, weight, residual), end='', file=f)
      if (rt_mx is not None):
        print(" " + str(rt_mx), end='', file=f)
      print(file=f)
      if return_result:
          value = group_args(
            group_args_type =
             'Bond distance:  ',
            labels = labels,
            delta = delta,
            sigma = sigma,
            residual = residual,
            ideal = distance_ideal,
            model = distance_model,)
          result.value_list.append(value)


  if (n_not_shown != 0):
    print(prefix + "... (remaining %d not shown)" % n_not_shown, file=f)

  if return_result:
    return result

@bp.inject_into(shared_bond_asu_proxy)
class _():

  def get_proxies_without_origin_id(self, origin_id):
    result = shared_bond_asu_proxy()
    for p in self:
      if p.origin_id != origin_id:
        result.append(p)
    return result

def resid_to_pymol(resid):
  resid = resid.strip()
  if resid.startswith('-'):
    resid = '\\' + resid
  return resid

@bp.inject_into(shared_bond_simple_proxy)
class _():

  def _generate_proxy_and_atom_labels(self, pdb_hierarchy):
    pdb_atoms = pdb_hierarchy.atoms()
    for proxy in self:
      i_seq, j_seq = proxy.i_seqs
      atom1 = pdb_atoms[i_seq].fetch_labels()
      atom2 = pdb_atoms[j_seq].fetch_labels()
      yield proxy, atom1, atom2

  def as_csv(self, pdb_hierarchy):
    # chain1,resname1,resid1,altloc1,name1,chain2,resname2,resid2,altloc2,name2
    # A,ALA,1," ",O,A,GLY,5," ",N
    result='chain1,resname1,resid1,name1,chain2,resname2,resid2,name2\n'
    for proxy, atom1, atom2 in self._generate_proxy_and_atom_labels(pdb_hierarchy):
      line = [ atom1.chain_id, atom1.resseq, atom1.altloc, atom1.name,
               atom2.chain_id, atom2.resseq, atom2.altloc, atom2.name,
               ]
      result += '%s\n' % ",".join(line)
    return result

  def as_pymol_dashes(self, pdb_hierarchy):
    # copied from mmtbx/geometry_restraints/hbond.py due to deprecation of
    # hbond.py
    result = ""
    for proxy, atom1, atom2 in self._generate_proxy_and_atom_labels(pdb_hierarchy):
      base_sele = """chain "%s" and resi %s and name %s and alt '%s'"""
      sele1 = base_sele % (atom1.chain_id.strip(), resid_to_pymol(atom1.resid()), atom1.name, atom1.altloc)
      sele2 = base_sele % (atom2.chain_id.strip(), resid_to_pymol(atom2.resid()), atom2.name, atom2.altloc)
      result += "dist %s, %s\n" % (sele1, sele2)
    return result

  def as_refmac_restraints(self, pdb_hierarchy):
    # copied from mmtbx/geometry_restraints/hbond.py due to deprecation of
    # hbond.py
    result = ""
    for proxy, atom1, atom2 in self._generate_proxy_and_atom_labels(pdb_hierarchy):
      sigma = 0.05
      if proxy.weight > 1e-5:
        sigma = 1.0/(proxy.weight**0.5)
      cmd = (("exte dist first chain %s residue %s atom %s " +
              "second chain %s residue %s atom %s value %.3f sigma %.2f") %
        (atom1.chain_id, atom1.resseq, atom1.name, atom2.chain_id,
         atom2.resseq, atom2.name, proxy.distance_ideal, sigma))
      result += "%s\n" % cmd
    return result

  def as_kinemage(self, pdb_hierarchy):
    # copied from mmtbx/geometry_restraints/hbond.py due to deprecation of
    # hbond.py. Outputs something, not tested.
    pdb_atoms = pdb_hierarchy.atoms()
    result = ""
    result += """\
@group {PHENIX H-bonds}
@subgroup {H-bond dots} dominant"""
    for proxy in self:
      i_seq, j_seq = proxy.i_seqs
      a = pdb_atoms[i_seq].xyz
      b = pdb_atoms[j_seq].xyz
      ab = (b[0] - a[0], b[1] - a[1], b[2] - a[2])
      result += """@dotlist {Drawn dots} color= green"""
      for x in range(1, 12):
        fac = float(x) / 12
        vec = (a[0] + (ab[0]*fac), a[1] + (ab[1]*fac), a[2] + (ab[2]*fac))
        if (x == 1):
          result += "{drawn} %.4f %.4f %.4f" % vec
        else :
          result += "{''} %.4f %.4f %.4f" % vec
    return result

  # shared_bond_simple_proxy
  def get_sorted(self,
        by_value,
        sites_cart,
        site_labels=None,
        unit_cell=None,
        max_items=None,
        origin_id=None):
    assert origin_id is None # not implemented
    assert by_value in ["residual", "delta"]
    assert site_labels is None or len(site_labels) == sites_cart.size()
    if (self.size() == 0): return None, None
    if (max_items is not None and max_items <= 0): return None, None
    if (by_value == "residual"):
      data_to_sort = self.residuals(sites_cart=sites_cart, unit_cell=unit_cell)
    elif (by_value == "delta"):
      data_to_sort = flex.abs(
        self.deltas(sites_cart=sites_cart, unit_cell=unit_cell))
    else:
      raise AssertionError
    i_proxies_sorted = flex.sort_permutation(data=data_to_sort, reverse=True)
    if (max_items is not None):
      i_proxies_sorted = i_proxies_sorted[:max_items]
    sorted_table = []
    for i_proxy in i_proxies_sorted:
      proxy = self[i_proxy]
      i_seq,j_seq = proxy.i_seqs
      rt_mx = proxy.rt_mx_ji
      if rt_mx is None: sym_op_j = ""
      else: sym_op_j = " sym.op."
      if unit_cell is None:
        restraint = bond(
          sites_cart=sites_cart,
          proxy=proxy)
      else:
        restraint = bond(
          unit_cell,
          sites_cart=sites_cart,
          proxy=proxy)
      labels = []
      for i in [i_seq, j_seq]:
        if (site_labels is None): l = str(i)
        else:                     l = site_labels[i]
        labels.append(l)
      info = (i_seq, j_seq, labels, restraint.distance_ideal, restraint.distance_model,
         restraint.slack, restraint.delta,
         weight_as_sigma(weight=restraint.weight), restraint.weight,
         restraint.residual(), sym_op_j, rt_mx)
      sorted_table.append(info)
    n_not_shown = data_to_sort.size() - i_proxies_sorted.size()
    return sorted_table, n_not_shown

  # shared_bond_simple_proxy
  def show_sorted(self,
                  by_value,
                  sites_cart,
                  site_labels=None,
                  unit_cell=None,
                  f=None,
                  prefix="",
                  max_items=None,
                  origin_id=None,
                  return_result = False):
    if f is None: f = sys.stdout
    # print >> f, "%sBond restraints: %d" % (prefix, self.size())
    return _bond_show_sorted_impl(self, by_value,
                           sites_cart=sites_cart,
                           site_labels=site_labels,
                           unit_cell=unit_cell,
                           f=f,
                           prefix=prefix,
                           max_items=max_items,
                           origin_id=origin_id,
                           return_result = return_result)

  def deltas(self, sites_cart, unit_cell=None):
    if unit_cell is None:
      return bond_deltas(sites_cart=sites_cart, proxies=self)
    else:
      return bond_deltas(
        unit_cell=unit_cell, sites_cart=sites_cart, proxies=self)

  def residuals(self, sites_cart, unit_cell=None):
    if unit_cell is None:
      return bond_residuals(sites_cart=sites_cart, proxies=self)
    else:
      return bond_residuals(
        unit_cell=unit_cell, sites_cart=sites_cart, proxies=self)

  def get_proxies_with_origin_id(self, origin_id=0): # this is the default
    result = []
    for p in self:
      if p.origin_id == origin_id:
        result.append(p)
    return result

  def get_proxies_without_origin_id(self, origin_id):
    result = shared_bond_simple_proxy()
    for p in self:
      if p.origin_id != origin_id:
        result.append(p)
    return result

@bp.inject_into(bond_sorted_asu_proxies)
class _():

  def show_histogram_of_model_distances(self,
        sites_cart,
        n_slots=5,
        cutoff_warn_small=0.5,
        cutoff_warn_large=5,
        cutoff_warn_extreme=20,
        f=None,
        prefix="",
        origin_id=None):
    if (self.n_total() == 0): return None
    if (f is None): f = sys.stdout
    print("%sHistogram of bond lengths:" % prefix, file=f)
    hdata = None
    if origin_id is None:
      hdata = bond_distances_model(
        sites_cart=sites_cart,
        sorted_asu_proxies=self)
    else:
      selected_simple = self.simple.proxy_select(origin_id = origin_id)
      selected_asu = self.asu.proxy_select(origin_id = origin_id)
      hdata_simple = bond_distances_model(
        sites_cart=sites_cart,
        proxies=selected_simple)
      sap = bond_sorted_asu_proxies(asu_mappings=self.asu_mappings())
      sap.process(selected_asu)
      hdata_asu = bond_distances_model(
        sites_cart=sites_cart,
        sorted_asu_proxies=sap)
      hdata_simple.extend(hdata_asu)
      hdata = hdata_simple
    histogram = flex.histogram(
      data=flex.double(hdata),
      n_slots=n_slots)
    low_cutoff = histogram.data_min()
    for i,n in enumerate(histogram.slots()):
      high_cutoff = histogram.data_min() + histogram.slot_width() * (i+1)
      print("%s  %8.2f - %8.2f: %d" % (
        prefix, low_cutoff, high_cutoff, n), file=f)
      low_cutoff = high_cutoff
    if (cutoff_warn_small is not None
        and histogram.data_min() < cutoff_warn_small):
      print("%sWarning: very small bond lengths." % prefix, file=f)
    if (cutoff_warn_extreme is not None
        and histogram.data_max() > cutoff_warn_extreme):
      print("%sWarning: extremely large bond lengths." % prefix, file=f)
    elif (cutoff_warn_large is not None
          and histogram.data_max() > cutoff_warn_large):
      print("%sWarning: very large bond lengths." % prefix, file=f)
    return histogram

  def deltas(self, sites_cart, origin_id=None):
    if origin_id is None:
      return bond_deltas(sites_cart=sites_cart, sorted_asu_proxies=self)
    return bond_deltas(sites_cart=sites_cart, sorted_asu_proxies=self,
        origin_id=origin_id)

  def residuals(self, sites_cart, origin_id=None):
    if origin_id is None:
      return bond_residuals(sites_cart=sites_cart, sorted_asu_proxies=self)
    return bond_residuals(sites_cart=sites_cart, sorted_asu_proxies=self,
        origin_id=origin_id)

  def get_proxies_with_origin_id(self, origin_id=0): # this is the default
    result = []
    for p in self.simple:
      if p.origin_id == origin_id:
        result.append(p)
    for p in self.asu:
      if p.origin_id == origin_id:
        result.append(p)
    return result

  def show_histogram_of_deltas(self,
        sites_cart,
        n_slots=5,
        f=None,
        prefix="",
        origin_id=None):
    if (self.n_total() == 0): return
    if (f is None): f = sys.stdout
    print("%sHistogram of bond deltas:" % prefix, file=f)
    hdata = None
    if origin_id is None:
      hdata = bond_deltas(
        sites_cart=sites_cart,
        sorted_asu_proxies=self)
    else:
      sorted_table, n_not_shown = self.get_sorted(
                        by_value="delta",
                        sites_cart=sites_cart,
                        origin_id=origin_id)
      hd = [x[6] for x in sorted_table]
      hdata = flex.double(hd)
    histogram = flex.histogram(
      data=flex.abs(hdata),
      n_slots=n_slots)
    low_cutoff = histogram.data_min()
    for i,n in enumerate(histogram.slots()):
      high_cutoff = histogram.data_min() + histogram.slot_width() * (i+1)
      print("%s  %8.3f - %8.3f: %d" % (
        prefix, low_cutoff, high_cutoff, n), file=f)
      low_cutoff = high_cutoff
    return histogram

  # bond_sorted_asu_proxies
  def get_sorted(self,
        by_value,
        sites_cart,
        site_labels=None,
        max_items=None,
        origin_id=None):
    assert by_value in ["residual", "delta"]
    assert site_labels is None or len(site_labels) == sites_cart.size()
    if (self.n_total() == 0): return None, None
    if (max_items is not None and max_items <0): return None, None
    if (by_value == "residual"):
      data_to_sort = self.residuals(sites_cart=sites_cart)
    elif (by_value == "delta"):
      data_to_sort = flex.abs(self.deltas(sites_cart=sites_cart))
    else:
      raise AssertionError
    i_proxies_sorted = flex.sort_permutation(data=data_to_sort, reverse=True)
    total_proxies = len(i_proxies_sorted)
    correct_id_proxies = total_proxies
    if origin_id is not None:
      correct_id_proxies = [i.origin_id for i in self.simple].count(origin_id)
      correct_id_proxies += [i.origin_id for i in self.asu].count(origin_id)
    if max_items is None:
      max_items = correct_id_proxies
    if (self.asu.size() == 0):
      asu_mappings = None
    else:
      asu_mappings = self.asu_mappings()
    n_simple = self.simple.size()
    sorted_table = []
    n = 0
    n_outputted = 0
    n_excluded = 0
    while n < total_proxies and n_outputted < max_items:
      i_proxy = i_proxies_sorted[n]
      if (i_proxy < n_simple):
        proxy = self.simple[i_proxy]
        i_seq,j_seq = proxy.i_seqs
        rt_mx = None
        sym_op_j = ""
        restraint = bond(
          sites_cart=sites_cart,
          proxy=proxy)
      else:
        proxy = self.asu[i_proxy-n_simple]
        i_seq,j_seq = proxy.i_seq, proxy.j_seq
        rt_mx = asu_mappings.get_rt_mx_ji(pair=proxy)
        sym_op_j = " sym.op."
        restraint = bond(
          sites_cart=sites_cart,
          asu_mappings=asu_mappings,
          proxy=proxy)
      if origin_id is None or origin_id == proxy.origin_id:
        labels = []
        for i in [i_seq, j_seq]:
          if (site_labels is None): l = str(i)
          else:                     l = site_labels[i]
          labels.append(l)
        info=(i_seq, j_seq, labels, restraint.distance_ideal, restraint.distance_model,
           restraint.slack, restraint.delta,
           weight_as_sigma(weight=restraint.weight), restraint.weight,
           restraint.residual(), sym_op_j, rt_mx)
        sorted_table.append(info)
        n_outputted += 1
      else:
        n_excluded += 1
      n += 1
    n_not_shown = correct_id_proxies - n_outputted
    return sorted_table, n_not_shown

  def get_outliers(self, sites_cart, sigma_threshold, origin_id=None):
    result = []
    from cctbx.geometry_restraints.linking_class import linking_class
    origin_ids = linking_class()
    if origin_id is None: origin_id=origin_ids.get_origin_id('covalent geometry')
    vals = self.get_sorted(
        by_value="delta",
        sites_cart=sites_cart,
        origin_id=origin_id)[0]
    if(vals is None): return result
    for it in vals:
      i,j = it[0],it[1]
      delta = abs(it[6])
      sigma = it[7]
      if(delta > sigma*sigma_threshold):
        result.append([i,j])
    return result

  def get_filtered_deltas(self,
      sites_cart,
      origin_id=None):
    n_proxies = self.n_total()
    if (n_proxies == 0): return None
    if (self.asu.size() == 0):
      asu_mappings = None
    else:
      asu_mappings = self.asu_mappings()
    if origin_id is None:
      return self.deltas(sites_cart=sites_cart)
    else:
      result = flex.double()
      n_simple = self.simple.size()
      for i in range(n_simple):
        proxy = self.simple[i]
        if proxy.origin_id == origin_id:
          rt_mx = None
          sym_op_j = ""
          restraint = bond(
            sites_cart=sites_cart,
            proxy=proxy)
          result.append(restraint.delta)
      for i in range(n_simple, n_proxies):
        proxy = self.asu[i-n_simple]
        if proxy.origin_id == origin_id:
          rt_mx = asu_mappings.get_rt_mx_ji(pair=proxy)
          sym_op_j = " sym.op."
          restraint = bond(
            sites_cart=sites_cart,
            asu_mappings=asu_mappings,
            proxy=proxy)
          result.append(restraint.delta)
      return result if len(result) > 0 else None

  # bond_sorted_asu_proxies
  def show_sorted(self,
        by_value,
        sites_cart,
        site_labels=None,
        f=None,
        prefix="",
        max_items=None,
        origin_id=None,
        return_result = False,):
    if f is None: f = sys.stdout
    # print >> f, "%sBond restraints: %d" % (prefix, self.n_total())
    return _bond_show_sorted_impl(self, by_value,
                          sites_cart=sites_cart,
                          site_labels=site_labels,
                          f=f,
                          prefix=prefix,
                          max_items=max_items,
                          origin_id=origin_id,
                          return_result = return_result)

@bp.inject_into(nonbonded_sorted_asu_proxies)
class _():

  def deltas(self, sites_cart):
    return nonbonded_deltas(sites_cart=sites_cart, sorted_asu_proxies=self)

  def show_histogram_of_model_distances(self,
        sites_cart,
        n_slots=5,
        cutoff_warn_small=1.0,
        f=None,
        prefix=""):
    if (self.n_total() == 0): return None
    if (f is None): f = sys.stdout
    print("%sHistogram of nonbonded interaction distances:" % prefix, file=f)
    histogram = flex.histogram(
      data=self.deltas(sites_cart=sites_cart),
      n_slots=n_slots)
    low_cutoff = histogram.data_min()
    for i,n in enumerate(histogram.slots()):
      high_cutoff = histogram.data_min() + histogram.slot_width() * (i+1)
      print("%s  %8.2f - %8.2f: %d" % (
        prefix, low_cutoff, high_cutoff, n), file=f)
      low_cutoff = high_cutoff
    if (cutoff_warn_small is not None
        and histogram.data_min() < cutoff_warn_small):
      print("%sWarning: very small nonbonded interaction distances." % (
        prefix), file=f)
    return histogram

  def get_sorted_i_proxies(self,
                           by_value,
                           sites_cart,
                           site_labels=None,
                           max_items=None,
                           ):
    assert by_value in ["delta"]
    deltas = nonbonded_deltas(sites_cart=sites_cart, sorted_asu_proxies=self)
    if (deltas.size() == 0): return
    if (max_items is not None and max_items <= 0): return
    i_proxies_sorted = flex.sort_permutation(data=deltas)
    if (max_items is not None):
      i_proxies_sorted = i_proxies_sorted[:max_items]
    return i_proxies_sorted

  def sorted_value_proxies_generator(self,
                           by_value,
                           sites_cart,
                           cutoff = 100):
    assert by_value in ["delta"]
    deltas = nonbonded_deltas(sites_cart=sites_cart, sorted_asu_proxies=self)
    if (deltas.size() == 0): return
    i_proxies_sorted = flex.sort_permutation(data=deltas)
    n_proxies = deltas.size()
    n_simple = self.simple.size()
    asu_mappings = self.asu_mappings()
    i = 0
    while i < n_proxies and deltas[i_proxies_sorted[i]] < cutoff:
      i_proxy = i_proxies_sorted[i]
      if (i_proxy < n_simple):
        i_seq, j_seq = self.simple[i_proxy].i_seqs
        yield (
            i_seq,
            j_seq,
            deltas[i_proxy],
            None,
            "",
            self.simple[i_proxy],
            )
      else:
        i_seq, j_seq = self.asu[i_proxy-n_simple].i_seq, self.asu[i_proxy-n_simple].j_seq
        yield (
            i_seq,
            j_seq,
            deltas[i_proxy],
            asu_mappings.get_rt_mx_ji(pair=self.asu[i_proxy-n_simple]),
            " sym.op.",
            self.asu[i_proxy-n_simple])
      i += 1

  def get_sorted_proxies(self,
                         by_value,
                         sites_cart,
                         site_labels=None,
                         max_items=None,
                         ):
    assert by_value in ["delta"]
    i_proxies_sorted = self.get_sorted_i_proxies(by_value=by_value,
                                                 sites_cart=sites_cart,
                                                 site_labels=site_labels,
                                                 max_items=max_items,
      )
    if (self.asu.size() == 0):
      asu_mappings = None
    else:
      asu_mappings = self.asu_mappings()
    n_simple = self.simple.size()
    sorted_proxies=[]
    for i_proxy in i_proxies_sorted:
      if (i_proxy < n_simple):
        proxy = self.simple[i_proxy]
      else:
        proxy = self.asu[i_proxy-n_simple]
      sorted_proxies.append(proxy)
    return sorted_proxies

  def get_sorted(self,
                 by_value,
                 sites_cart,
                 site_labels=None,
                 max_items=None,
                 include_proxy=False,
                 ):
    assert by_value in ["delta"]
    deltas = nonbonded_deltas(sites_cart=sites_cart, sorted_asu_proxies=self)
    if (deltas.size() == 0): return [], 0
    if (max_items is not None and max_items <= 0): return [], deltas.size()
    i_proxies_sorted = flex.sort_permutation(data=deltas)
    if (max_items is not None):
      i_proxies_sorted = i_proxies_sorted[:max_items]
    if (self.asu.size() == 0):
      asu_mappings = None
    else:
      asu_mappings = self.asu_mappings()
    n_simple = self.simple.size()
    sorted_table=[]
    for i_proxy in i_proxies_sorted:
      if (i_proxy < n_simple):
        proxy = self.simple[i_proxy]
        i_seq,j_seq = proxy.i_seqs
        rt_mx = None
        sym_op_j = ""
      else:
        proxy = self.asu[i_proxy-n_simple]
        i_seq,j_seq = proxy.i_seq,proxy.j_seq
        rt_mx = asu_mappings.get_rt_mx_ji(pair=proxy)
        sym_op_j = " sym.op."
      labels = []
      for i in [i_seq, j_seq]:
        if (site_labels is None): l = str(i)
        else:                     l = site_labels[i]
        labels.append(l)
      m, v = deltas[i_proxy], proxy.vdw_distance
      if include_proxy:
        sorted_table.append(
          (labels,
           i_seq,
           j_seq,
           deltas[i_proxy],
           proxy.vdw_distance,
           sym_op_j,
           rt_mx,
           proxy)
          )
      else:
        sorted_table.append(
          (labels,
           i_seq,
           j_seq,
           deltas[i_proxy],
           proxy.vdw_distance,
           sym_op_j,
           rt_mx)
          )
    n_not_shown = deltas.size() - i_proxies_sorted.size()
    return sorted_table, n_not_shown

  def get_symmetry_interacting_indices_unique(self, sites_cart):
    """
    See output of show_sorted below to understand what this function does.
    Find atom indices in the main copy that bump with the main copy via symmetry
    or periodicity. There may be several symmetry/periodicity related copies
    corresponding to given atom in main copy. The function returns a dictionary
    with keys being atom indices in main copy and values being the list of
    symmetry operations to generate interacting mates.
    """
    result = {}
    deltas = nonbonded_deltas(sites_cart=sites_cart, sorted_asu_proxies=self)
    if (deltas.size() == 0): return
    i_proxies_sorted = flex.sort_permutation(data=deltas)
    if (self.asu.size() == 0):
      asu_mappings = None
    else:
      asu_mappings = self.asu_mappings()
    n_simple = self.simple.size()
    for i_proxy in i_proxies_sorted:
      if (i_proxy >= n_simple):
        proxy = self.asu[i_proxy-n_simple]
        i_seq,j_seq = proxy.i_seq,proxy.j_seq
        rt_mx = asu_mappings.get_rt_mx_ji(pair=proxy)
        #if str(rt_mx)=="x,y,z": continue # why do I need this?
        result.setdefault(j_seq, []).append(rt_mx)
    for k,v in six.iteritems(result):
      result[k] = list(set(v))
    return result

  def show_sorted(self,
        by_value,
        sites_cart,
        site_labels=None,
        f=None,
        prefix="",
        max_items=None,
        suppress_model_minus_vdw_greater_than=0.2,
        but_show_all_model_up_to=3.5,
        return_result = False):

    if return_result:
      result = group_args(group_args_type = 'Non-bonded restraints',
        by_value = by_value,
        max_items = max_items,
        value_list = [],
      )

    assert by_value in ["delta"]
    sorted_table, n_not_shown = self.get_sorted(
        by_value=by_value,
        sites_cart=sites_cart,
        site_labels=site_labels,
        max_items=max_items,
        include_proxy=False)
    if (f is None): f = sys.stdout
    print("%sNonbonded interactions: %d" % (prefix, len(sorted_table)+n_not_shown), file=f)
    if len(sorted_table) == 0: return
    print("%sSorted by model distance:" % prefix, file=f)

    for info in sorted_table:
      labels, i_seq, j_seq, delta, vdw_distance, sym_op_j, rt_mx = info
      def suppress():
        m, v = delta, vdw_distance
        if (suppress_model_minus_vdw_greater_than is None): return False
        if (m-v <= suppress_model_minus_vdw_greater_than): return False
        if (but_show_all_model_up_to is None): return True
        if (m <= but_show_all_model_up_to): return False
        return True
      if (suppress()): continue
      s = "nonbonded"
      for l in labels:
        print("%s%9s %s" % (prefix, s, l), file=f)
        s = ""
      print("%s   model   vdw%s" % (prefix, sym_op_j), file=f)
      print("%s  %6.3f %5.3f" % (prefix, delta, vdw_distance), end='', file=f)
      if (rt_mx is not None):
        print(" " + str(rt_mx), end='', file=f)
      print(file=f)
      if return_result:
          value = group_args(
            group_args_type =
             'Non-bonded distance:  ideal is vdw_distance, '+
                 'model is delta (actual)',
            labels = labels,
            delta = None,
            sigma = None,
            residual = None,
            ideal = vdw_distance,
            model = delta,)
          result.value_list.append(value)

    if (n_not_shown != 0):
      print(prefix + "... (remaining %d not shown)" % n_not_shown, file=f)

    if return_result:
      return result

@bp.inject_into(angle)
class _():

  def _show_sorted_item(O, f, prefix):
    print("%s    ideal   model   delta" \
      "    sigma   weight residual" % prefix, file=f)
    print("%s  %7.2f %7.2f %7.2f %6.2e %6.2e %6.2e" % (
      prefix,
      O.angle_ideal, O.angle_model, O.delta,
      weight_as_sigma(weight=O.weight), O.weight, O.residual()), file=f)

  def _get_sorted_item(O):
    return [O.angle_ideal, O.angle_model, O.delta,
            weight_as_sigma(weight=O.weight), O.weight, O.residual()]

@bp.inject_into(shared_angle_proxy)
class _():

  def as_pymol_dashes(self, pdb_hierarchy):
    # copied from mmtbx/geometry_restraints/hbond.py due to deprecation of
    # hbond.py
    result = ""
    pdb_atoms = pdb_hierarchy.atoms()
    i = 0
    for proxy in self:
      i_seq, j_seq, k_seq = proxy.i_seqs
      atom1 = pdb_atoms[i_seq].fetch_labels()
      atom2 = pdb_atoms[j_seq].fetch_labels()
      atom3 = pdb_atoms[k_seq].fetch_labels()
      base_sele = """chain "%s" and resi %s and name %s and alt '%s'"""
      sele1 = base_sele % (atom1.chain_id.strip(), resid_to_pymol(atom1.resid()), atom1.name, atom1.altloc)
      sele2 = base_sele % (atom2.chain_id.strip(), resid_to_pymol(atom2.resid()), atom2.name, atom2.altloc)
      sele3 = base_sele % (atom3.chain_id.strip(), resid_to_pymol(atom3.resid()), atom3.name, atom3.altloc)
      result += "angle a%d, %s, %s, %s\n" % (i, sele1, sele2, sele3)
      i += 1
    return result

  def deltas(self, sites_cart, unit_cell=None, origin_id=None):
    if unit_cell is None:
      if origin_id is None:
        return angle_deltas(sites_cart=sites_cart, proxies=self)
      return angle_deltas(sites_cart=sites_cart, proxies=self, origin_id=origin_id)
    else:
      if origin_id is None:
        return angle_deltas(
          unit_cell=unit_cell, sites_cart=sites_cart, proxies=self)
      return angle_deltas(
        unit_cell=unit_cell, sites_cart=sites_cart, proxies=self, origin_id=origin_id)

  def residuals(self, sites_cart, unit_cell=None):
    if unit_cell is None:
      return angle_residuals(sites_cart=sites_cart, proxies=self)
    else:
      return angle_residuals(
        unit_cell=unit_cell, sites_cart=sites_cart, proxies=self)

  def get_filtered_deltas(self,
      sites_cart,
      origin_id=None):
    # ANGLE
    n_proxies = self.size()
    if (n_proxies == 0): return None
    if origin_id is None:
      if unit_cell is None:
        result = flex.abs(O.deltas(sites_cart=sites_cart))
      else:
        result = flex.abs(
          O.deltas(unit_cell=unit_cell, sites_cart=sites_cart))
    else:
      result = flex.double()
      for i in range(n_proxies):
        proxy = self[i]
        if proxy.origin_id == origin_id:
          restraint = angle(
            sites_cart=sites_cart,
            proxy=proxy)
          result.append(restraint.delta)
    return result if len(result) > 0 else None

  def show_histogram_of_deltas(self,
        sites_cart,
        unit_cell=None,
        n_slots=5,
        proxy_label="bond angle",
        f=None,
        prefix="",
        origin_id=None):
    return _show_histogram_of_deltas_impl(O=self,
      proxy_label=proxy_label,
      format_cutoffs="%8.2f",
      unit_cell=unit_cell,
      sites_cart=sites_cart, n_slots=n_slots, f=f, prefix=prefix,
      origin_id=origin_id)

  def show_sorted(self,
        by_value,
        sites_cart,
        site_labels=None,
        proxy_label="Bond angle",
        unit_cell=None,
        f=None,
        prefix="",
        max_items=None,
        origin_id=None,
        return_result = False):
    return _show_sorted_impl(O=self,
        proxy_type=angle,
        proxy_label=proxy_label,
        item_label="angle",
        by_value=by_value, unit_cell=unit_cell, sites_cart=sites_cart,
        site_labels=site_labels, f=f, prefix=prefix, max_items=max_items,
        origin_id=origin_id,
        return_result = return_result)

  def get_sorted(self,
        by_value,
        sites_cart,
        site_labels=None,
        unit_cell=None,
        max_items=None,
        origin_id=None):
    return _get_sorted_impl(O=self,
        proxy_type=angle,
        by_value=by_value, unit_cell=unit_cell, sites_cart=sites_cart,
        site_labels=site_labels, max_items=max_items,
        get_restraints_only=False, origin_id=origin_id)

  def get_outliers(self, sites_cart, sigma_threshold, origin_id=0):
    result = []
    vals = self.get_sorted(by_value="delta",
                           origin_id=origin_id,
                           sites_cart=sites_cart)[0]
    if(vals is None): return result
    for it in vals:
      i,j,k = [int(i) for i in it[0]]
      delta = abs(it[3])
      sigma = it[4]
      if(delta > sigma*sigma_threshold):
        result.append([i,j,k])
    return result

@bp.inject_into(dihedral)
class _():

  def _show_sorted_item(O, f, prefix):
    print("%s    ideal   model   delta" \
      " %        s    sigma   weight residual" % (
        prefix, {False: "sinusoidal", True: " harmonic "}[O.periodicity <= 0]), file=f)
    angle_ideal = O.angle_model+O.delta
    if angle_ideal<-180: angle_ideal+=360
    print("%s  %7.2f %7.2f %7.2f %5d      %6.2e %6.2e %6.2e" % (
      prefix,
      angle_ideal, O.angle_model, O.delta, O.periodicity,
      weight_as_sigma(weight=O.weight), O.weight, O.residual()), file=f)

  def _get_sorted_item(O):
    return [O.angle_ideal, O.angle_model, O.delta, O.periodicity,
            weight_as_sigma(weight=O.weight), O.weight, O.residual()]

@bp.inject_into(shared_dihedral_proxy)
class _():

  def deltas(self, sites_cart, unit_cell=None):
    if unit_cell is None:
      return dihedral_deltas(sites_cart=sites_cart, proxies=self)
    else:
      return dihedral_deltas(
        unit_cell=unit_cell, sites_cart=sites_cart, proxies=self)

  def residuals(self, sites_cart, unit_cell=None):
    if unit_cell is None:
      return dihedral_residuals(sites_cart=sites_cart, proxies=self)
    else:
      return dihedral_residuals(
        unit_cell=unit_cell, sites_cart=sites_cart, proxies=self)

  def show_histogram_of_deltas(self,
        sites_cart,
        unit_cell=None,
        n_slots=5,
        proxy_label="dihedral angle",
        f=None,
        prefix=""):
    return _show_histogram_of_deltas_impl(O=self,
      proxy_label=proxy_label,
      format_cutoffs="%8.2f",
      unit_cell=unit_cell,
      sites_cart=sites_cart, n_slots=n_slots, f=f, prefix=prefix)

  def show_sorted(self,
        by_value,
        sites_cart,
        site_labels=None,
        proxy_label="Dihedral angle",
        unit_cell=None,
        f=None,
        prefix="",
        max_items=None,
        origin_id=None,
        return_result = False):
    return _show_sorted_impl(O=self,
        proxy_type=dihedral,
        proxy_label=proxy_label,
        item_label="dihedral",
        by_value=by_value, unit_cell=unit_cell, sites_cart=sites_cart,
        site_labels=site_labels, f=f, prefix=prefix, max_items=max_items,
        origin_id=origin_id,
        return_result = return_result)

  def get_sorted(self,
        by_value,
        sites_cart,
        site_labels=None,
        unit_cell=None,
        max_items=None):
    return _get_sorted_impl(O=self,
        proxy_type=dihedral,
        by_value=by_value, unit_cell=unit_cell, sites_cart=sites_cart,
        site_labels=site_labels, max_items=max_items,
        get_restraints_only=False)

  def get_outliers(self, sites_cart, sigma_threshold):
    result = []
    vals = self.get_sorted(by_value="delta", sites_cart=sites_cart)[0]
    if(vals is None): return result
    for it in vals:
      ind = [int(i) for i in it[0]]
      delta = abs(it[3])
      sigma = it[5]
      if(delta > sigma*sigma_threshold):
        result.append(ind)
    return result

@bp.inject_into(chirality)
class _():

  def _show_sorted_item(O, f, prefix):
    print("%s  both_signs  ideal   model" \
      "   delta    sigma   weight residual" % prefix, file=f)
    print("%s    %-5s   %7.2f %7.2f %7.2f %6.2e %6.2e %6.2e" % (
      prefix,
      str(O.both_signs), O.volume_ideal, O.volume_model, O.delta,
      weight_as_sigma(weight=O.weight), O.weight, O.residual()), file=f)

  def _get_sorted_item(O):
    return [str(O.both_signs), O.volume_ideal, O.volume_model, O.delta,
      weight_as_sigma(weight=O.weight), O.weight, O.residual()]

@bp.inject_into(shared_chirality_proxy)
class _():

  def deltas(self, sites_cart, unit_cell=None):
    if unit_cell is None:
      return chirality_deltas(sites_cart=sites_cart, proxies=self)
    else:
      return chirality_deltas(unit_cell=unit_cell, sites_cart=sites_cart, proxies=self)

  def residuals(self, sites_cart, unit_cell=None):
    if unit_cell is None:
      return chirality_residuals(sites_cart=sites_cart, proxies=self)
    else:
      return chirality_residuals(unit_cell=unit_cell, sites_cart=sites_cart, proxies=self)

  def show_histogram_of_deltas(self,
        sites_cart,
        n_slots=5,
        proxy_label="chiral volume",
        f=None,
        prefix=""):
    return _show_histogram_of_deltas_impl(O=self,
      proxy_label=proxy_label,
      format_cutoffs="%8.3f",
      unit_cell=None,
      sites_cart=sites_cart, n_slots=n_slots, f=f, prefix=prefix)

  def show_sorted(self,
        by_value,
        sites_cart,
        site_labels=None,
        unit_cell=None,
        proxy_label="Chirality",
        f=None,
        prefix="",
        max_items=None,
        origin_id=None,
        return_result = False,
    ):

    return _show_sorted_impl(O=self,
        proxy_type=chirality,
        proxy_label=proxy_label,
        item_label="chirality",
        by_value=by_value, unit_cell=unit_cell, sites_cart=sites_cart,
        site_labels=site_labels, f=f, prefix=prefix, max_items=max_items,
        origin_id=origin_id,
        return_result = return_result)

  def get_sorted(self,
        by_value,
        sites_cart,
        site_labels=None,
        max_items=None):
    return _get_sorted_impl(O=self,
        proxy_type=chirality,
        by_value=by_value, unit_cell=None, sites_cart=sites_cart,
        site_labels=site_labels, max_items=max_items,
        get_restraints_only=False)

  def get_outliers(self, sites_cart, sigma_threshold):
    result = []
    vals = self.get_sorted(by_value="delta", sites_cart=sites_cart)[0]
    if(vals is None): return result
    for it in vals:
      # it: [[iseqs], both_signs(bool), ideal, model, delta, sigma, weight, residual]
      ind = [int(i) for i in it[0]]
      delta = abs(it[4])
      sigma = it[5]
      if(delta > sigma*sigma_threshold):
        result.append(ind)
    return result

@bp.inject_into(shared_planarity_proxy)
class _():

  def deltas_rms(O, sites_cart, unit_cell=None):
    if unit_cell is None:
      return planarity_deltas_rms(sites_cart=sites_cart, proxies=O)
    else:
      return planarity_deltas_rms(
        unit_cell=unit_cell, sites_cart=sites_cart, proxies=O)

  def residuals(O, sites_cart, unit_cell=None):
    if unit_cell is None:
      return planarity_residuals(sites_cart=sites_cart, proxies=O)
    else:
      return planarity_residuals(
        unit_cell=unit_cell, sites_cart=sites_cart, proxies=O)

  def get_sorted(O,
        by_value,
        sites_cart,
        site_labels=None,
        unit_cell=None,
        max_items=None):
    assert by_value in ["residual", "rms_deltas"]
    assert site_labels is None or len(site_labels) == sites_cart.size()
    if (O.size() == 0): return None, None
    if (max_items is not None and max_items <= 0): return None, None
    if (by_value == "residual"):
      if unit_cell is None:
        data_to_sort = O.residuals(sites_cart=sites_cart)
      else:
        data_to_sort = O.residuals(unit_cell=unit_cell,sites_cart=sites_cart)
    elif (by_value == "rms_deltas"):
      if unit_cell is None:
        data_to_sort = O.deltas_rms(sites_cart=sites_cart)
      else:
        data_to_sort = O.deltas_rms(unit_cell=unit_cell, sites_cart=sites_cart)
    else:
      raise AssertionError
    i_proxies_sorted = flex.sort_permutation(data=data_to_sort, reverse=True)
    if (max_items is not None):
      i_proxies_sorted = i_proxies_sorted[:max_items]
    sorted_table = []
    for i_proxy in i_proxies_sorted:
      proxy = O[i_proxy]
      labels = []
      for i_seq in proxy.i_seqs:
        if (site_labels is None): l = str(i_seq)
        else:                     l = site_labels[i_seq]
        labels.append(l)
      if unit_cell is None:
        restraint = planarity(sites_cart=sites_cart, proxy=proxy)
      else:
        restraint = planarity(unit_cell=unit_cell, sites_cart=sites_cart,
                              proxy=proxy)
      restraint_atoms = []
      for i,(i_seq,weight,delta,l) in enumerate(zip(proxy.i_seqs, proxy.weights,
                                      restraint.deltas(), labels)):
        sym_op = ""
        if proxy.sym_ops:
          rt_mx = proxy.sym_ops[i]
          if not rt_mx.is_unit_mx():
            sym_op = "%s %s" %(rdr_spacer, rt_mx.as_xyz())
        restraint_atoms.append((l, delta, weight_as_sigma(weight=weight),
          weight, sym_op))
      sorted_table.append((restraint_atoms, restraint.rms_deltas(),
        restraint.residual()))
    n_not_shown = O.size() - i_proxies_sorted.size()
    return sorted_table, n_not_shown

  # TODO: convert this to use get_sorted
  def show_sorted(O,
        by_value,
        sites_cart,
        site_labels=None,
        proxy_label=None, # not used yet
        unit_cell=None,
        f=None,
        prefix="",
        max_items=None,
        origin_id=None,
        return_result = False,
    ):
    if return_result:
      result = group_args(group_args_type = 'Planarity restraints',
        by_value = by_value,
        max_items = max_items,
        value_list = [],
      )



    assert by_value in ["residual", "rms_deltas"]
    assert site_labels is None or len(site_labels) == sites_cart.size()
    if (f is None): f = sys.stdout
    outl = ''
    if (O.size() == 0):
      print("%sPlanarity restraints: %d" % (prefix, O.size()), file=f)
      return
    if (max_items is not None and max_items <= 0): return
    if (by_value == "residual"):
      if unit_cell is None:
        data_to_sort = O.residuals(sites_cart=sites_cart)
      else:
        data_to_sort = O.residuals(unit_cell=unit_cell,sites_cart=sites_cart)
    elif (by_value == "rms_deltas"):
      if unit_cell is None:
        data_to_sort = O.deltas_rms(sites_cart=sites_cart)
      else:
        data_to_sort = O.deltas_rms(unit_cell=unit_cell, sites_cart=sites_cart)
    else:
      raise AssertionError
    i_proxies_sorted = flex.sort_permutation(data=data_to_sort, reverse=True)
    if (max_items is not None):
      i_proxies_sorted = i_proxies_sorted[:max_items]
    n_planes=0
    for i_proxy in i_proxies_sorted:
      proxy = O[i_proxy]
      if origin_id is not None and proxy.origin_id!=origin_id: continue
      n_planes+=1
      len_max = 0
      ls = []
      for i_seq in proxy.i_seqs:
        if (site_labels is None): l = str(i_seq)
        else:                     l = site_labels[i_seq]
        len_max = max(len_max, len(l))
        ls.append(l)
      if unit_cell is None:
        restraint = planarity(sites_cart=sites_cart, proxy=proxy)
        sym_op_label = ""
      else:
        restraint = planarity(unit_cell=unit_cell, sites_cart=sites_cart,
                              proxy=proxy)
        sym_op_label = " sym.op."
      outl +=  "%s      %s    delta    sigma   weight rms_deltas residual%s\n" % (
          prefix, " "*len_max, sym_op_label)
      s = "plane"
      rdr = None
      for i, (i_seq,weight,delta,l) in enumerate(zip(proxy.i_seqs, proxy.weights,
                                      restraint.deltas(), ls)):
        if (rdr is None):
          rdr = "   %6.2e %6.2e" % (
            restraint.rms_deltas(), restraint.residual())
          rdr_spacer = ""
        sym_op = ""
        if proxy.sym_ops:
          rt_mx = proxy.sym_ops[i]
          if not rt_mx.is_unit_mx():
            sym_op = "%s %s" %(rdr_spacer, rt_mx.as_xyz())
        outl += "%s%5s %s  %7.3f %6.2e %6.2e%s%s\n" % (
          prefix, s, l+" "*(len_max-len(l)),
          delta, weight_as_sigma(weight=weight), weight, rdr, sym_op)
        rdr = ""
        rdr_spacer = " "*20
        s = ""
        if return_result:
          sigma = weight_as_sigma(weight=weight)
          value = group_args(
            group_args_type =
             'Planarity restraint (energy for one atom, all atoms: %s)' %(
              str(ls)),
            labels = [l],
            delta = delta,
            sigma = sigma,
            residual = (delta/max(1.e-10,sigma))**2,
            ideal = None,
            model = None,)
          result.value_list.append(value)

    n_not_shown = O.size() - i_proxies_sorted.size()
    if (n_not_shown != 0):
      outl += prefix + "... (remaining %d not shown)\n" % n_not_shown
    if origin_id is None:
      n_planes = O.size()
    print("%sPlanarity restraints: %d" % (prefix, n_planes), file=f)
    if outl:
      print("%sSorted by %s:" % (prefix, by_value), file=f)
      print(outl[:-1], file=f)

    if return_result:
      return result

@bp.inject_into(parallelity)
class _():

  def _show_sorted_item(O, f, prefix):
    assert 0
    print("%s    ideal   model   delta" \
      "    sigma   weight residual" % prefix, file=f)

  def _get_sorted_item(self):
    return [self.residual(), self.weight, self.delta]

@bp.inject_into(shared_parallelity_proxy)
class _():

  def deltas(O, sites_cart, unit_cell=None):
    if unit_cell is None:
      return parallelity_deltas(sites_cart=sites_cart, proxies=O)
    else:
      return parallelity_deltas(
        unit_cell=unit_cell, sites_cart=sites_cart, proxies=O)

  def residuals(O, sites_cart, unit_cell=None):
    if unit_cell is None:
      return parallelity_residuals(sites_cart=sites_cart, proxies=O)
    else:
      return parallelity_residuals(
        unit_cell=unit_cell, sites_cart=sites_cart, proxies=O)

  def show_sorted(self,
        by_value,
        sites_cart,
        site_labels=None,
        proxy_label=None, # not used yet
        f=None,
        prefix="",
        max_items=None,
        origin_id=None):
    if (f is None): f = sys.stdout
    sorted_table, n_not_shown = self.get_sorted(
          by_value=by_value,
          sites_cart=sites_cart,
          site_labels=site_labels,
          max_items=max_items,
          origin_id=origin_id)
    if sorted_table is None: return
    print("Parallelity restraints: %d" % (len(sorted_table)), file=f)
    if (self.size() == 0): return
    if len(sorted_table)==0: return
    if (max_items is not None and max_items <= 0): return
    print("%sSorted by %s:" % (prefix, by_value), file=f)
    for info in sorted_table:
      residual = info[1]
      delta_deg = delta = info[3]
      # delta_deg = math.degrees(math.acos(1-delta))
      weight = info[2]
      sigma = math.sqrt(1./weight)
      print("    plane 1                plane 2  "+\
          "              residual  delta(deg) sigma", file=f)
      r_info = "  %.2e %8.4f  %8.4f" % (residual, delta_deg, sigma)
      i_labels = info[0][0]
      j_labels = info[0][1]
      i = 0
      long_len = max(len(i_labels), len(j_labels))
      while i < long_len:
        print("    %s  %s%s" % \
            (i_labels[i] if i < len(i_labels) else " "*21,
             j_labels[i] if i < len(j_labels) else "",
             r_info), file=f)
        r_info = ""
        i += 1
      print(file=f)
    if (n_not_shown != 0):
      print(prefix + "... (remaining %d not shown)" % n_not_shown, file=f)

  def get_sorted(self,
        by_value,
        sites_cart,
        site_labels=None,
        max_items=None,
        origin_id=None):
    return _get_sorted_impl(O=self,
        proxy_type=parallelity,
        by_value=by_value, unit_cell=None, sites_cart=sites_cart,
        site_labels=site_labels, max_items=max_items,
        get_restraints_only=False,
        origin_id=origin_id)

@bp.inject_into(shared_bond_similarity_proxy)
class _():

  def deltas_rms(self, sites_cart, unit_cell=None):
    if unit_cell is None:
      return bond_similarity_deltas_rms(sites_cart=sites_cart, proxies=self)
    else:
      return bond_similarity_deltas_rms(
        unit_cell=unit_cell, sites_cart=sites_cart, proxies=self)

  def residuals(self, sites_cart, unit_cell=None):
    if unit_cell is None:
      return bond_similarity_residuals(sites_cart=sites_cart, proxies=self)
    else:
      return bond_similarity_residuals(
        unit_cell=unit_cell, sites_cart=sites_cart, proxies=self)

  def show_sorted(O,
      by_value,
      sites_cart,
      site_labels=None,
      unit_cell=None,
      f=None,
      prefix="",
      max_items=None,
      origin_id=None):
    assert by_value in ["residual", "rms_deltas"]
    assert site_labels is None or len(site_labels) == sites_cart.size()
    if (f is None): f = sys.stdout
    print("%sBond similarity restraints: %d" % (prefix, O.size()), file=f)
    if (O.size() == 0): return
    if (max_items is not None and max_items <= 0): return
    if (by_value == "residual"):
      if unit_cell is None:
        data_to_sort = O.residuals(sites_cart=sites_cart)
      else:
        data_to_sort = O.residuals(unit_cell=unit_cell,sites_cart=sites_cart)
    elif (by_value == "rms_deltas"):
      if unit_cell is None:
        data_to_sort = O.deltas_rms(sites_cart=sites_cart)
      else:
        data_to_sort = O.deltas_rms(unit_cell=unit_cell, sites_cart=sites_cart)
    else:
      raise AssertionError
    i_proxies_sorted = flex.sort_permutation(data=data_to_sort, reverse=True)
    if (max_items is not None):
      i_proxies_sorted = i_proxies_sorted[:max_items]
    print("%sSorted by %s:" % (prefix, by_value), file=f)
    for i_proxy in i_proxies_sorted:
      proxy = O[i_proxy]
      if origin_id is not None and proxy.origin_id!=origin_id: continue
      len_max = 0
      ls = []
      for pair in proxy.i_seqs:
        if (site_labels is None):
          l = "%s-%s" %(str(pair[0]), str(pair[1]))
        else:
          l = "%s-%s" %(site_labels[pair[0]], site_labels[pair[1]])
        len_max = max(len_max, len(l))
        ls.append(l)
      if unit_cell is None:
        restraint = bond_similarity(sites_cart=sites_cart, proxy=proxy)
        sym_op_label = ""
      else:
        restraint = bond_similarity(unit_cell=unit_cell, sites_cart=sites_cart,
                              proxy=proxy)
        sym_op_label = " sym.op."
      print("%s     %s    delta    sigma   weight rms_deltas residual%s" % (
          prefix, " "*len_max, sym_op_label), file=f)
      s = "bond"
      rdr = None
      for i, (i_seq,weight,delta,l) in enumerate(zip(proxy.i_seqs, proxy.weights,
                                      restraint.deltas(), ls)):
        if (rdr is None):
          rdr = "   %6.2e %6.2e" % (
            restraint.rms_deltas(), restraint.residual())
          rdr_spacer = ""
        sym_op = ""
        if proxy.sym_ops:
          rt_mx = proxy.sym_ops[i]
          if not rt_mx.is_unit_mx():
            sym_op = "%s %s" %(rdr_spacer, rt_mx.as_xyz())
        print("%s%4s %s  %7.3f %6.2e %6.2e%s%s" % (
          prefix, s, l+" "*(len_max-len(l)),
          delta, weight_as_sigma(weight=weight), weight, rdr, sym_op), file=f)
        rdr = ""
        rdr_spacer = " "*20
        s = ""
    n_not_shown = O.size() - i_proxies_sorted.size()
    if (n_not_shown != 0):
      print(prefix + "... (remaining %d not shown)" % n_not_shown, file=f)

def _show_histogram_of_deltas_impl(O,
        proxy_label,
        format_cutoffs,
        unit_cell,
        sites_cart,
        n_slots,
        f,
        prefix,
        origin_id=None):
    if (O.size() == 0): return
    if (f is None): f = sys.stdout
    print("%sHistogram of %s deviations from ideal:" % (
      prefix, proxy_label), file=f)
    selected_proxies = O
    if origin_id is not None:
      selected_proxies = O.proxy_select(origin_id=origin_id)
    if unit_cell is None:
      data = flex.abs(selected_proxies.deltas(sites_cart=sites_cart))
    else:
      data = flex.abs(
        selected_proxies.deltas(unit_cell=unit_cell, sites_cart=sites_cart))
    histogram = flex.histogram(
      data=data,
      n_slots=n_slots)
    fmt = "%%s  %s - %s: %%d" % (format_cutoffs, format_cutoffs)
    low_cutoff = histogram.data_min()
    for i,n in enumerate(histogram.slots()):
      high_cutoff = histogram.data_min() + histogram.slot_width() * (i+1)
      print(fmt % (prefix, low_cutoff, high_cutoff, n), file=f)
      low_cutoff = high_cutoff
    return histogram

def _get_sorted_impl(O,
        proxy_type,
        by_value,
        unit_cell,
        sites_cart,
        site_labels,
        max_items,
        get_restraints_only=True,
        origin_id=None):
  assert by_value in ["residual", "delta"]
  assert site_labels is None or len(site_labels) == sites_cart.size()
  if (O.size() == 0): return None, None
  if (max_items is not None and max_items < 0): return None, None
  if (by_value == "residual"):
    if unit_cell is None:
      data_to_sort = O.residuals(sites_cart=sites_cart)
    else:
      data_to_sort = O.residuals(unit_cell=unit_cell, sites_cart=sites_cart)
  elif (by_value == "delta"):
    if unit_cell is None:
      data_to_sort = flex.abs(O.deltas(sites_cart=sites_cart))
    else:
      data_to_sort = flex.abs(
        O.deltas(unit_cell=unit_cell, sites_cart=sites_cart))
  else:
    raise AssertionError
  i_proxies_sorted = flex.sort_permutation(data=data_to_sort, reverse=True)
  n_total_proxies = len(i_proxies_sorted)
  if max_items is None:
    max_items = n_total_proxies
  sorted_table = []
  n_added_proxies = 0
  correct_id_proxies = n_total_proxies
  if origin_id is not None:
    correct_id_proxies = [i.origin_id for i in O].count(origin_id)

  i = 0
  while i < n_total_proxies and n_added_proxies < max_items:
    proxy = O[i_proxies_sorted[i]]
    if (origin_id is None or
       (origin_id is not None and hasattr(proxy, "origin_id")
        and proxy.origin_id==origin_id)):
      labels = []
      labels_j = []
      for n, i_seq in enumerate(proxy.i_seqs):
        if (site_labels is None): l = str(i_seq)
        else:                     l = site_labels[i_seq]
        if unit_cell and proxy.sym_ops:
          sym_op = proxy.sym_ops[n]
          if not sym_op.is_unit_mx():
            l += "  %s" %sym_op.as_xyz()
        labels.append(l)
      if proxy_type==parallelity:
        for n, i_seq in enumerate(proxy.j_seqs):
          if (site_labels is None): l = str(i_seq)
          else:                     l = site_labels[i_seq]
          if unit_cell and proxy.sym_ops:
            sym_op = proxy.sym_ops[n]
            if not sym_op.is_unit_mx():
              l += "  %s" %sym_op.as_xyz()
          labels_j.append(l)
        labels = [labels,labels_j]
      if unit_cell is None:
        restraint = proxy_type(
          sites_cart=sites_cart,
          proxy=proxy)
      else:
        restraint = proxy_type(
          unit_cell=unit_cell,
          sites_cart=sites_cart,
          proxy=proxy)
      if get_restraints_only :
        sorted_table.append((labels, restraint))
      else :
        restraint_info = restraint._get_sorted_item()
        sorted_table.append([labels] + restraint_info)
      n_added_proxies += 1
    i += 1
  n_not_shown = correct_id_proxies - n_added_proxies
  return sorted_table, n_not_shown

def _show_sorted_impl(O,
        proxy_type,
        proxy_label,
        item_label,
        by_value,
        unit_cell,
        sites_cart,
        site_labels,
        f,
        prefix,
        max_items,
        origin_id=None,
        return_result = False,
      ):
  if return_result:
    result = group_args(group_args_type = '%s restraints' %(proxy_label),
        by_value = by_value,
        max_items = max_items,
        value_list = [],)

  if (f is None): f = sys.stdout
  sorted_table, n_not_shown = _get_sorted_impl(O,
        proxy_type=proxy_type,
        by_value=by_value,
        unit_cell=unit_cell,
        sites_cart=sites_cart,
        site_labels=site_labels,
        max_items=max_items,
        get_restraints_only=True,
        origin_id=origin_id)
  len_sorted_table = 0 if sorted_table is None else len(sorted_table)
  if n_not_shown is None: n_not_shown = 0
  print("%s%s restraints: %d" % (prefix, proxy_label, len_sorted_table+n_not_shown), file=f)
  if (O.size() == 0): return
  if len_sorted_table+n_not_shown==0: return
  n_harmonic = 0
  n_sinusoidal = 0
  if (max_items is not None and max_items <= 0): return
  item_label_blank = " " * len(item_label)
  outl = six.StringIO()
  for (labels, restraint) in sorted_table :
    if (proxy_type is dihedral) and (origin_id==0 or origin_id is None):
      if restraint.periodicity<=0: n_harmonic+=1
      else: n_sinusoidal+=1
    s = item_label
    for l in labels :
      print("%s%s %s" % (prefix, s, l), file=outl)
      s = item_label_blank
    restraint._show_sorted_item(f=outl, prefix=prefix)

    if return_result:
          def value_from_restraint(restraint, key_ending = None):
            for x in dir(restraint):
              if not x.startswith("__") and x.endswith(key_ending):
                return getattr(restraint,x)

          #angle_ideal, angle_model, delta, variance**0.5, weight, residual
          delta = restraint.delta
          sigma = weight_as_sigma(weight = restraint.weight)
          ideal = value_from_restraint(restraint,'_ideal')
          model = value_from_restraint(restraint,'_model')
          residual = restraint.residual()
          if proxy_label == 'Dihedral angle':
            ideal = model + delta
            if ideal<-180: ideal+=360

          value = group_args(group_args_type = '%s result' %proxy_label,
            labels = labels,
            delta = delta,
            sigma = sigma,
            ideal = ideal,
            model = model,
            residual = residual)
          result.value_list.append(value)

  if (n_not_shown != 0):
    if (proxy_type is dihedral):
      n_harmonic = O.count_harmonic()
      n_sinusoidal = O.size() - n_harmonic
    print(prefix + "... (remaining %d not shown)" % n_not_shown, file=outl)
  #
  if (proxy_type is dihedral) and (origin_id==0 or origin_id is None):
    print(prefix+"  sinusoidal: %d" % n_sinusoidal, file=f)
    print(prefix+"    harmonic: %d" % n_harmonic, file=f)
  print("%sSorted by %s:" % (prefix, by_value), file=f)
  print(outl.getvalue()[:-1], file=f)

  if return_result:
    return result

class pair_proxies(object):

  def __init__(self,
        flags=None,
        bond_params_table=None,
        shell_asu_tables=None,
        model_indices=None,
        conformer_indices=None,
        sym_excl_indices=None,
        donor_acceptor_excl_groups=None,
        nonbonded_params=None,
        nonbonded_types=None,
        nonbonded_charges=None,
        nonbonded_distance_cutoff_plus_buffer=None,
        min_cubicle_edge=5):
    self.bond_proxies = None
    self.nonbonded_proxies = None
    if (bond_params_table is not None
        and (flags is None or flags.bond)):
      if (shell_asu_tables is None):
        self.bond_proxies = bond_sorted_asu_proxies(
          bond_params_table=bond_params_table)
      else:
        assert len(shell_asu_tables) > 0
        self.bond_proxies = bond_sorted_asu_proxies(
          bond_params_table=bond_params_table,
          bond_asu_table=shell_asu_tables[0])
    if (nonbonded_types is not None
        and (flags is None or flags.nonbonded)):
      assert nonbonded_params is not None
      assert nonbonded_distance_cutoff_plus_buffer is not None
      assert shell_asu_tables is not None
      assert len(shell_asu_tables) > 0
      if (nonbonded_charges is None):
        nonbonded_charges = flex.int(nonbonded_types.size(), 0)
      assert (nonbonded_types.size() == nonbonded_charges.size())
      self.nonbonded_proxies = nonbonded_sorted_asu_proxies(
        model_indices=model_indices,
        conformer_indices=conformer_indices,
        sym_excl_indices=sym_excl_indices,
        donor_acceptor_excl_groups=donor_acceptor_excl_groups,
        nonbonded_params=nonbonded_params,
        nonbonded_types=nonbonded_types,
        nonbonded_charges=nonbonded_charges,
        nonbonded_distance_cutoff_plus_buffer=\
          nonbonded_distance_cutoff_plus_buffer,
        min_cubicle_edge=min_cubicle_edge,
        shell_asu_tables=shell_asu_tables)

@bp.inject_into(ext.motif)
class _():

  def show(self, out=None, prefix=""):
    if (out is None): out = sys.stdout
    print(prefix+"geometry_restraints.motif {", file=out)
    print(prefix+"  id = %s" % show_string(self.id), file=out)
    print(prefix+"  description = %s" % show_string(self.description), file=out)
    for info in self.info:
      print(prefix+"  info = %s" % show_string(info), file=out)
    for manipulation_id in self.manipulation_ids:
      print(prefix+"  manipulation_id = %s" % (
        show_string(manipulation_id)), file=out)
    self.show_atoms(out=out, prefix=prefix+"  ")
    self.show_bonds(out=out, prefix=prefix+"  ")
    self.show_angles(out=out, prefix=prefix+"  ")
    self.show_dihedrals(out=out, prefix=prefix+"  ")
    self.show_chiralities(out=out, prefix=prefix+"  ")
    self.show_planarities(out=out, prefix=prefix+"  ")
    print(prefix+"}", file=out)

  def show_atoms(self, out=None, prefix=""):
    atoms = self.atoms_as_list()
    if (len(atoms) > 0):
      print(prefix+"atom = " \
        "[name scattering_type nonbonded_type partial_charge]", file=out)
      for atom in atoms:
        print(prefix+"atom = %s %s %s %.6g" % (
          show_string(atom.name),
          show_string(atom.scattering_type),
          show_string(atom.nonbonded_type),
          atom.partial_charge), file=out)

  def show_bonds(self, out=None, prefix=""):
    bonds = self.bonds_as_list()
    if (len(bonds) > 0):
      print(prefix+"bond = " \
        "[atom_name*2 type distance_ideal weight id]", file=out)
      for bond in bonds:
        atom_names = bond.atom_names
        print(prefix+"bond = %s %s %s %.6g %.6g %s" % (
          show_string(atom_names[0]),
          show_string(atom_names[1]),
          show_string(bond.type),
          bond.distance_ideal,
          bond.weight,
          show_string(bond.id)), file=out)

  def show_angles(self, out=None, prefix=""):
    angles = self.angles_as_list()
    if (len(angles) > 0):
      print(prefix+"angle = " \
        "[atom_name*3 angle_ideal weight id]", file=out)
      for angle in angles:
        atom_names = angle.atom_names
        print(prefix+"angle = %s %s %s %.6g %.6g %s" % (
          show_string(atom_names[0]),
          show_string(atom_names[1]),
          show_string(atom_names[2]),
          angle.angle_ideal,
          angle.weight,
          show_string(angle.id)), file=out)

  def show_dihedrals(self, out=None, prefix=""):
    dihedrals = self.dihedrals_as_list()
    if (len(dihedrals) > 0):
      print(prefix+"dihedral = " \
        "[atom_name*4 angle_ideal weight periodicity id]", file=out)
      for dihedral in dihedrals:
        atom_names = dihedral.atom_names
        print(prefix+"dihedral = %s %s %s %s %.6g %.6g %d %s" % (
          show_string(atom_names[0]),
          show_string(atom_names[1]),
          show_string(atom_names[2]),
          show_string(atom_names[3]),
          dihedral.angle_ideal,
          dihedral.weight,
          dihedral.periodicity,
          show_string(dihedral.id)), file=out)

  def show_chiralities(self, out=None, prefix=""):
    chiralities = self.chiralities_as_list()
    if (len(chiralities) > 0):
      print(prefix+"chirality = " \
        "[atom_name*4 volume_sign both_signs volume_ideal weight id]", file=out)
      for chirality in chiralities:
        atom_names = chirality.atom_names
        if (chirality.both_signs): both_signs = "True"
        else:                      both_signs = "False"
        print(prefix+"chirality = %s %s %s %s %s %s %.6g %.6g %s" % (
          show_string(atom_names[0]),
          show_string(atom_names[1]),
          show_string(atom_names[2]),
          show_string(atom_names[3]),
          show_string(chirality.volume_sign),
          both_signs,
          chirality.volume_ideal,
          chirality.weight,
          show_string(chirality.id)), file=out)

  def show_planarities(self, out=None, prefix=""):
    planarities = self.planarities_as_list()
    if (len(planarities) > 0):
      for planarity in planarities:
        print(prefix+"planarity {", file=out)
        print(prefix+"  id = %s" % show_string(planarity.id), file=out)
        assert planarity.weights.size() == planarity.atom_names.size()
        print(prefix+"  atom = [name weight]", file=out)
        for an,w in zip(planarity.atom_names, planarity.weights):
          print(prefix+"  atom = %s %.6g" % (show_string(an), w), file=out)
        print(prefix+"}", file=out)

@bp.inject_into(ext.motif_alteration)
class _():

  def show(self, out=None, prefix="", previous_help=None):
    if (out is None): out = sys.stdout
    action = self.action
    operand = self.operand
    if (operand == "atom"):
      assert len(self.motif_ids) == 1
      atom = self.atom
      attr = "name scattering_type nonbonded_type partial_charge"
      if (action == "add"):
        help = prefix+"atom = add [motif_id %s]" % attr
        if (help != previous_help): print(help, file=out)
        print(prefix+"atom = add %s %s %s %s %s" % (
          show_string(self.motif_ids[0]),
          show_string(atom.name),
          show_string(atom.scattering_type),
          show_string(atom.nonbonded_type),
          atom.partial_charge), file=out)
      elif (action == "change"):
        help = prefix+"atom = change [motif_id motif_atom_name \\\n" \
                    + prefix+"               %s]" % attr
        if (help != previous_help): print(help, file=out)
        print(prefix+"atom = change %s %s \\" % (
          show_string(self.motif_ids[0]),
          show_string(self.motif_atom_name)), file=out)
        if (not self.change_partial_charge()):
          partial_charge = "None"
        else:
          partial_charge = "%.6g" % atom.partial_charge
        print(prefix+"              %s %s %s %s" % (
          show_string(atom.name),
          show_string(atom.scattering_type),
          show_string(atom.nonbonded_type),
          partial_charge), file=out)
      else:
        assert action == "delete"
        help = prefix+"atom = delete [motif_id motif_atom_name]"
        if (help != previous_help): print(help, file=out)
        print(prefix+"atom = delete %s %s" % (
          show_string(self.motif_ids[0]),
          show_string(self.motif_atom_name)), file=out)
    elif (operand == "bond"):
      assert len(self.motif_ids) == 2
      bond = self.bond
      help_lead = "bond = %s [(motif_id atom_name)*2" % action
      data_lead = "bond = %s %s %s %s %s" % (
        action,
        show_string(self.motif_ids[0]),
        show_string(bond.atom_names[0]),
        show_string(self.motif_ids[1]),
        show_string(bond.atom_names[1]))
      if (action == "delete"):
        help = prefix+"%s]" % help_lead
        if (help != previous_help): print(help, file=out)
        print(prefix+"%s" % data_lead, file=out)
      else:
        if (action == "change" and not self.change_distance_ideal()):
          distance_ideal = "None"
        else:
          distance_ideal = "%.6g" % bond.distance_ideal
        if (action == "change" and not self.change_weight()):
          weight = "None"
        else:
          weight = "%.6g" % bond.weight
        help = prefix+"%s type distance_ideal weight id]" % help_lead
        if (help != previous_help): print(help, file=out)
        print(prefix+"%s %s %s %s" % (
          data_lead, distance_ideal, weight, show_string(bond.id)), file=out)
    elif (operand == "angle"):
      assert len(self.motif_ids) == 3
      angle = self.angle
      help_lead = "angle = %s [(motif_id atom_name)*3" % action
      data_lead = "angle = %s %s %s %s %s %s %s" % (
        action,
        show_string(self.motif_ids[0]),
        show_string(angle.atom_names[0]),
        show_string(self.motif_ids[1]),
        show_string(angle.atom_names[1]),
        show_string(self.motif_ids[2]),
        show_string(angle.atom_names[2]))
      if (action == "delete"):
        help = prefix+"%s]" % help_lead
        if (help != previous_help): print(help, file=out)
        print(prefix+"%s" % data_lead, file=out)
      else:
        if (action == "change" and not self.change_angle_ideal()):
          angle_ideal = "None"
        else:
          angle_ideal = "%.6g" % angle.angle_ideal
        if (action == "change" and not self.change_weight()):
          weight = "None"
        else:
          weight = "%.6g" % angle.weight
        help = prefix+"%s type angle_ideal weight id]" % help_lead
        if (help != previous_help): print(help, file=out)
        print(prefix+"%s %s %s %s" % (
          data_lead, angle_ideal, weight, show_string(angle.id)), file=out)
    elif (operand == "dihedral"):
      assert len(self.motif_ids) == 4
      dihedral = self.dihedral
      help_lead = "dihedral = %s [(motif_id atom_name)*4" % action
      data_lead = "dihedral = %s %s %s %s %s %s %s %s %s" % (
        action,
        show_string(self.motif_ids[0]),
        show_string(dihedral.atom_names[0]),
        show_string(self.motif_ids[1]),
        show_string(dihedral.atom_names[1]),
        show_string(self.motif_ids[2]),
        show_string(dihedral.atom_names[2]),
        show_string(self.motif_ids[3]),
        show_string(dihedral.atom_names[3]))
      if (action == "delete"):
        help = prefix+"%s]" % help_lead
        if (help != previous_help): print(help, file=out)
        print(prefix+"%s" % data_lead, file=out)
      else:
        if (action == "change" and not self.change_angle_ideal()):
          angle_ideal = "None"
        else:
          angle_ideal = "%.6g" % dihedral.angle_ideal
        if (action == "change" and not self.change_weight()):
          weight = "None"
        else:
          weight = "%.6g" % dihedral.weight
        if (action == "change" and not self.change_periodicity()):
          periodicity = "None"
        else:
          periodicity = "%d" % dihedral.periodicity
        help = prefix+"%s angle_ideal weight periodicity id]" % help_lead
        if (help != previous_help): print(help, file=out)
        print(prefix+"%s %s %s %s %s" % (
          data_lead, angle_ideal, weight, periodicity,
          show_string(dihedral.id)), file=out)
    elif (operand == "chirality"):
      assert len(self.motif_ids) == 4
      chirality = self.chirality
      help_lead = "chirality = %s [(motif_id atom_name)*4" % action
      data_lead = "chirality = %s %s %s %s %s %s %s %s %s" % (
        action,
        show_string(self.motif_ids[0]),
        show_string(chirality.atom_names[0]),
        show_string(self.motif_ids[1]),
        show_string(chirality.atom_names[1]),
        show_string(self.motif_ids[2]),
        show_string(chirality.atom_names[2]),
        show_string(self.motif_ids[3]),
        show_string(chirality.atom_names[3]))
      if (action == "delete"):
        help = prefix+"%s]" % help_lead
        if (help != previous_help): print(help, file=out)
        print(prefix+"%s" % data_lead, file=out)
      else:
        if (action == "change" and not self.change_volume_ideal()):
          volume_ideal = "None"
        else:
          volume_ideal = "%.6g" % chirality.volume_ideal
        if (action == "change" and not self.change_weight()):
          weight = "None"
        else:
          weight = "%.6g" % chirality.weight
        help = prefix+"%s \\\n" % help_lead \
             + prefix+" "*(14+len(action)) \
             + "volume_sign volume_ideal weight id]"
        if (help != previous_help): print(help, file=out)
        print(prefix+"%s \\\n%s%s%s %s %s %s" % (
          data_lead, prefix, " "*(13+len(action)),
          show_string(chirality.volume_sign),
          volume_ideal, weight, show_string(chirality.id)), file=out)
    elif (operand == "planarity"):
      planarity = self.planarity
      print(prefix+"planarity {", file=out)
      print(prefix+"  action = %s" % action, file=out)
      print(prefix+"  motif_id = %s" % show_string(
        self.planarity_motif_id), file=out)
      print(prefix+"  id = %s" % show_string(planarity.id), file=out)
      if (action == "add"):
        print(prefix+"  atom = [motif_id name weight]", file=out)
        assert planarity.weights.size() == planarity.atom_names.size()
        assert self.motif_ids.size() == planarity.atom_names.size()
        for mi,an,w in zip(self.motif_ids,
                           planarity.atom_names,
                           planarity.weights):
          print(prefix+"  atom = %s %s %.6g" % (
            show_string(mi), show_string(an), w), file=out)
      elif (action == "change"):
        assert planarity.weights.size() == planarity.atom_names.size()
        assert self.motif_ids.size() == planarity.atom_names.size()
        actions = self.planarity_atom_actions_as_list()
        assert len(actions) == planarity.atom_names.size()
        previous_help = None
        for ac,mi,an,w in zip(actions,
                              self.motif_ids,
                              planarity.atom_names,
                              planarity.weights):
          if (ac != "delete"):
            help = prefix+"  atom = %s [motif_id name weight]" % ac
            if (help != previous_help): print(help, file=out)
            print(prefix+"  atom = %s %s %s %.6g" % (
              ac, show_string(mi), show_string(an), w), file=out)
          else:
            help = prefix+"  atom = delete [motif_id name]"
            if (help != previous_help): print(help, file=out)
            print(prefix+"  atom = %s %s %s" % (
              ac, show_string(mi), show_string(an)), file=out)
          previous_help = help
      print(prefix+"}", file=out)
      help = None
    else:
      raise RuntimeError("Internal Error: unknown operand: %s" % operand)
    return help

@bp.inject_into(ext.motif_manipulation)
class _():

  def show(self, out=None, prefix=""):
    if (out is None): out = sys.stdout
    print(prefix+"geometry_restraints.motif_manipulation {", file=out)
    print(prefix+"  id = %s" % show_string(self.id), file=out)
    print(prefix+"  description = %s" % show_string(self.description), file=out)
    for info in self.info:
      print(prefix+"  info = %s" % show_string(info), file=out)
    previous_help = None
    for alteration in self.alterations_as_list():
      previous_help = alteration.show(
        out=out, prefix=prefix+"  ", previous_help=previous_help)
    print(prefix+"}", file=out)


 *******************************************************************************


 *******************************************************************************
cctbx/geometry_restraints/auto_linking_types.py
from __future__ import absolute_import, division, print_function

bond_origin_ids = {}
angle_origin_ids = {}
torsion_origin_ids = {}
chiral_origin_ids = {}
plane_origin_ids = {}
parallelity_origin_ids = {}
origin_ids = [bond_origin_ids,
              angle_origin_ids,
              torsion_origin_ids,
              plane_origin_ids,
              chiral_origin_ids,
              parallelity_origin_ids,
              ]

class origins(list):
  def __init__(self, item, internals=None):
    self.internals = internals
    for i, l in enumerate(item):
      self.append(l)
      if i==3:
        self.header = l

  def __repr__(self):
    return list.__repr__(self) + ' is %s' % self.internals

covalent_headers = ['Bond',
                    "Bond angle",
                    "Dihedral angle",
                    "Chirality",
                    "Planarity",
                    "Parallelity",
                    ]

internal_labels = ['bonds',
                   'angles',
                   'dihedrals',
                   'chirals',
                   'planes',
                   'parallelities',
                   ]

starting_id = 0
for link_info in [
    ['covalent geometry', 'covalent geometry', [0,1,2,3,4,5]], # 0
    ['SS BOND', # short desc.
     # complete desc.
     'Disulphide bond for CYS-like sulphur atoms within 3A (default) using '
     'values determined from hi-res structures and published in CCN. '
     'Some bonds are automatically excluded based on distance from metals.',
     # citation
     'Comput. Cryst. Newsl. (2015), 6, 13-13.',
     # geo file header - bond, angle, dihedral (None will suppress output)
     ['Disulphide bridge']*3,
     # internals
     [0,1,2], # does not seem to be used much...
    ],
    ['hydrogen bonds',
     'hydrogen bonds added both for protein SS and NA basepairs',
     '',
     ['Bond-like', 'Secondary Structure restraints around h-bond'],
     [0,1],
    ],
    ['metal coordination',
     '',
     '',
     ['Metal coordination']*2,
     [0,1],
    ],
    ['edits',
     '',
     'www.phenix-online.org/documentation/reference/refinement.html#definition-of-custom-bonds-and-angles',
     ['User supplied']*6,
     [0,1,2,3,4,5],
    ],
    # ['glycosidic',
    #  'Standard glycosidic CIF link blocks such as link_??? and ???',
    #  '',
    #  ['Standard Glycosidic']*5, # includes chirals!!!
    #  [0,1,2,3,4],
    # ],
    ['glycosidic custom',
     'Custom glycosidic links need to be generated when the atom names of '
     '''the carbohydrates don't conform to the standard.''',
     '',
     ['Custom Glycosidic']*5,
     [0,1,2,3,4],
    ],
    ['basepair stacking',
     'Enforces parallel between two bases in the sequence',
     'J. Appl. Cryst. 48, 1130-1141 (2015).',
     [None, None, None, None, None, 'Stacking parallelity'],
     [5],
    ],
    ['basepair parallelity',
     'Enforces parallel between two base pairs in paired bases',
     'J. Appl. Cryst. 48, 1130-1141 (2015).',
     [None, None, None, None, None, 'Basepair parallelity'],
     [5],
    ],
    ['side-chain parallelity',
     'Enforces parallel between two alt conf side-chains',
     'JH',
     [None, None, None, None, None, 'Side-chain parallelity'],
     [5],
    ],
    ['basepair planarity',
     'Enforces planarity of two base pairs in paired bases',
     'J. Appl. Cryst. 48, 1130-1141 (2015).',
     [None, None, None, 'xxx', 'Basepair planarity'],
     [3],
    ],
    # ['trans peptide link',
    # 'Applying the standard TRANS peptide link to a non-standard peptide',
    # '',
    # ['Trans Peptide']*3+[None],
    # [0,1,2,4]
    # ]
    ['Misc. bond', # 9
     'Bond created based on atom type and distance.',
     '',
     ['Misc.']*5,
     [0,1,2,3,4]
    ],
    ['User supplied cif_link', # 10
     'Internal coordinates supplied by the user in cif_link format',
     '',
     ['User cif_link']*5,
     [0,1,2,3,4]
    ],
    ]:
  for oi in origin_ids:
    assert starting_id not in oi
    oi[starting_id] = origins(link_info[:-1], internals=link_info[-1])
  starting_id+=1

# only angles
for link_info in []:
  angle_origin_ids[starting_id] = origins(link_info, internals=[1])
  starting_id+=1

# only dihedrals
for link_info in [
    ['C-beta',
     'C-beta restraints are (only) dihedrals used by default',
     '',
     [None, None, 'C-Beta improper'],
     ],
    ['chi angles',
     'Torsion restraints on chi angles (side-chain rotamers)',
     '',
     [None, None, 'Side chain'],
     ],
  ]:
  torsion_origin_ids[starting_id] = origins(link_info, internals=[2])
  starting_id+=1

from cctbx.geometry_restraints.standard_cif_links import standard_cif_links
for scl in standard_cif_links:
  assert starting_id not in origin_ids[0]
  origin_ids[0][starting_id] = origins(scl, internals=[0,1,2,3,4,5])
  starting_id+=1

not_covalent = [
  # not really necessary as there are no bonds, angles but added for completeness
  'basepair stacking',
  'basepair parallelity',
  'side-chain parallelity',
  'basepair planarity',
  'link_gap',
  # necessary
  'hydrogen bonds',
  ]

def iterate_covalent():
  for key, item in origin_ids[0].items():
    if item[0] in not_covalent: continue
    # print('YIELD "%s" "%s"' % (key, item))
    yield key

if __name__=="__main__":
  print('-'*80)
  print(bond_origin_ids)
  print('-'*80)
  print(angle_origin_ids)
  print('-'*80)
  print(torsion_origin_ids)
  print('-'*80)
  print(parallelity_origin_ids)


 *******************************************************************************


 *******************************************************************************
cctbx/geometry_restraints/base_geometry.py
from __future__ import absolute_import, division, print_function

class Base_geometry(object):
  """
  Base class for geometry restraints manager. This will go inside
  restraints manager defined in mmtbx/restraints.py
  The reason for it is for external packages, like AMBER to be able
  to inherit from it and be placed instead of classical geometry.
  Therefore all functions defined for classical geometry are defined
  here with hopefully reasonable default actions.
  """
  def __init__(self):
    self._source = None

  def set_source(self, source):
    assert self._source is None or self._source == source
    self._source = source

  def get_source(self):
    return self._source

  def reset_internals(self):
    pass
  def replace_site_symmetry(self, new_site_symmetry_table):
    pass
  def simple_edge_list(self, omit_slack_greater_than=0):
    return None
  def rigid_clusters_due_to_dihedrals_and_planes(self,
      constrain_dihedrals_with_sigma_less_than):
    return None
  def construct_tardy_tree(self,
      sites=None,
      sites_cart=None,
      selection=None,
      omit_bonds_with_slack_greater_than=0,
      constrain_dihedrals_with_sigma_less_than=10,
      near_singular_hinges_angular_tolerance_deg=5):
    return None
  def reduce_for_tardy(self,
        tardy_tree,
        omit_bonds_with_slack_greater_than=0,
        include_den_restraints=False):
    return self
  def sites_cart_used_for_pair_proxies(self):
    return None
  def new_including_isolated_sites(self,
        n_additional_sites,
        model_indices=None,
        conformer_indices=None,
        sym_excl_indices=None,
        donor_acceptor_excl_groups=None,
        site_symmetry_table=None,
        nonbonded_types=None,
        nonbonded_charges=None):
    return self

  def select(self, selection=None, iselection=None):
    """
    This is cruicial function and should be defined in child.
    Given selection return manager only with selected atoms and restraints
    """
    raise NotImplementedError
  def shift_sites_cart(self, shift):
    """
    Sometimes coordinates of the model are shifted (e.g. in boxing with map).
    In case any element of restraints cares, do what is appropriate here.
    """
    raise NotImplementedError

  def discard_symmetry(self, new_unit_cell):
    return self
  def add_angles_in_place(self, additional_angle_proxies):
    pass
  def remove_angles_in_place(self, selection):
    pass
  def get_user_supplied_restraints(self):
    return None, None, None, None, None
  def remove_user_supplied_restraints_in_place(self):
    raise NotImplementedError
  def get_bond_proxies_without_user_supplied(self, sites_cart=None):
    return None, None
  def get_angle_proxies_without_user_supplied(self):
    return None
  def get_planarity_proxies_without_user_supplied(self):
    return None
  def get_parallelity_proxies_without_user_supplied(self):
    return None

  #=================================================================
  # Reference coordinate proxies methods
  #=================================================================
  def get_reference_coordinate_proxies(self):
    return None
  def adopt_reference_coordinate_restraints_in_place(self,
      reference_coordinate_proxies):
    pass
  def remove_reference_coordinate_restraints_in_place(self,
      selection=None):
    pass
  def get_n_reference_coordinate_proxies(self):
    return 0

  def append_reference_coordinate_restraints_in_place(self,
      reference_coordinate_proxies):
    pass
  def add_reference_coordinate_restraints_in_place(self,
      all_chain_proxies=None,
      pdb_hierarchy=None,
      selection=None,
      exclude_outliers=True,
      sigma=0.2,
      limit=1.0,
      top_out=False):
    pass

  #=================================================================
  # Torsion (dihedral) restraints on chi angles (side-chain rotamers)
  # proxies methods
  #=================================================================
  def add_chi_torsion_restraints_in_place(self,
      pdb_hierarchy,
      sites_cart,
      selection=None,
      sigma=2.5,
      limit=15.0,
      chi_angles_only=False,
      top_out_potential=False):
    pass
  def remove_chi_torsion_restraints_in_place(self, selection=None):
    pass
  def get_chi_torsion_proxies(self):
    return None

  def get_n_chi_torsion_proixes(self):
    return None
  #=================================================================
  # Dihedral proxies methods
  #=================================================================
  def add_dihedrals_in_place(self,
      additional_dihedral_proxies,
      check_for_duplicates=True):
    pass
  def remove_dihedrals_in_place(self, selection):
    pass
  def get_dihedral_proxies(self):
    return None

  #=================================================================
  # C-beta dihedral proxies methods
  #=================================================================
  def get_c_beta_torsion_proxies(self):
    return None
  def get_n_c_beta_torsion_proxies(self):
    return 0

  def remove_c_beta_torsion_restraints_in_place(self, selection=None):
    pass
  #=================================================================
  # Reference dihedral proxies methods
  #=================================================================
  def adopt_reference_dihedral_manager(self, manager):
    pass
  def remove_reference_dihedrals_in_place(self, selection):
    pass
  def remove_ncs_dihedrals_in_place(self):
    pass
  def update_dihedral_ncs_restraints(self, model, log):
    pass
  def get_n_reference_dihedral_proxies(self):
    return None

  def sync_reference_dihedral_with_ncs(self, log):
    pass
  #=================================================================
  # DEN manager/proxies methods
  #=================================================================
  def create_den_manager(self, den_params, pdb_hierarchy, log):
    pass
  def adopt_den_manager(self, den_manager):
    pass
  def get_n_den_proxies(self):
    return 0
  def remove_chiralities_in_place(self, selection):
    pass
  def add_planarities_in_place(self, additional_planarity_proxies):
    pass
  def remove_planarities_in_place(self, selection):
    pass
  def add_parallelities_in_place(self, additional_parallelity_proxies):
    pass
  def remove_parallelities_in_place(self, selection):
    pass
  #=================================================================
  # Ramachandran manager/proxies methods
  #=================================================================
  def set_ramachandran_restraints(self, manager):
    pass
  def update_ramachandran_restraints_phi_psi_targets(self, sites_cart):
    pass
  def remove_ramachandran_in_place(self):
    pass
  def get_n_ramachandran_proxies(self):
    return 0
  #=================================================================
  # Secondary structure manager/proxies methods
  #=================================================================
  def set_secondary_structure_restraints(self, ss_manager, hierarchy, log):
    pass
  def remove_secondary_structure_restraints(self):
    # Not implemented. The problem here is to remove hbond restraints, which
    # requires modification of pair_proxies and as complicated as addition
    # of bond restraint.
    raise NotImplementedError
  def set_external_energy_function(self, energy_function):
    pass
  def _get_n_bond_proxies_origin(self, origin_id):
    return 0
  def get_n_bond_proxies(self):
    return 0
  def get_covalent_bond_proxies(self, sites_cart=None):
    return None
  def get_all_bond_proxies(self, sites_cart=None):
    return None
  def get_covalent_angle_proxies(self):
    return None
  def get_all_angle_proxies(self):
    return None
  def get_n_hbond_proxies(self):
    return None
  def get_n_angle_proxies(self):
    return 0
  def get_n_hangle_proxies(self):
    return 0
  def get_n_stacking_proxies(self):
    return 0
  def get_n_parallelity_bp_proxies(self):
    return 0
  def get_n_planarity_proxies(self):
    return 0
  def get_n_planarity_bp_proxies(self):
    return 0
  def get_hbond_proxies_iseqs(self):
    return None

  def new_included_bonded_atoms(self, proxies, sites_cart,
      site_symmetry_table, nonbonded_types, nonbonded_charges,
      max_distance_between_connecting_atoms=5,
      skip_max_proxy_distance_calculation=False):
    """ Produce new geometry_restraints_manager object that will
    include new atoms each with exactly one bond to the existing atom.
    proxies - list of bond_proxy objects. Symmetry operation will be determined
    automatically, so proxy.rt_mx_ji is ignored.
    Essentially this function wraps self.new_including_isolated_sites() and
    self.add_new_bond_restraints_in_place().
    sites_cart should contain all coordinates, for old and new atoms. new
      coordinates should follow old ones and the order should be consistent
      with i_seqs mentioned in proxy objects.
    site_symmetry_table - table only for new atoms
    nonbonded_types - only for new atoms
    nonbonded_charges - only for new atoms."""
    return self

  def add_new_hbond_restraints_in_place(self, proxies, sites_cart,
      max_distance_between_connecting_atoms=5,
      skip_max_proxy_distance_calculation=False):
    pass

  def add_new_bond_restraints_in_place(self, proxies, sites_cart,
      max_distance_between_connecting_atoms=5,
      skip_max_proxy_distance_calculation=False):
    """ Add new bond restraints for list of proxies to this
    geometry restraints manager, _in_place_! Returns nothing.
    proxies - list of bond_proxy objects. The symmetry operation for the
    paired atoms is determined here, therefore the proxy.rt_mx_ji may be
    anything."""
    pass

  def is_bonded_atoms(self, i_seq, j_seq):
    return True

  def pair_proxies(self,
        sites_cart=None,
        flags=None,
        asu_is_inside_epsilon=None,
        bonded_distance_cutoff_epsilon=None,
        site_labels=None):
    return None

  def nonbonded_model_distances(self, sites_cart=None):
    return None
  def update_plain_pair_sym_table(self, sites_frac):
    pass

  def energies_sites(self,
        sites_cart,
        flags=None,
        custom_nonbonded_function=None,
        compute_gradients=False,
        gradients=None,
        disable_asu_cache=False,
        normalization=False,
        external_energy_function=None,
        extension_objects=[],
        site_labels=None):
    """
    Crucial function to override in child. Maybe we should put some info
    here later.
    """
    raise NotImplementedError

  def harmonic_restraints(self, variables, type_indices, type_weights):
    """
    Not clear what it is
    """
    raise NotImplementedError

  def ta_harmonic_restraints(self, sites_cart, ta_harmonic_restraint_info, weight = 0.001, slack = 0.5):
    """
    Not clear what it is
    """
    raise NotImplementedError

  def update_atom_nonbonded_type(self,
        i_seq,
        nonbonded_type,
        charge=0):
    pass

  def write_geo_file(self,
      sites_cart=None,
      site_labels=None,
      file_name=None,
      file_descriptor=None,
      header="# Geometry restraints\n"):
    """
    Define this if you want the .geo file
    """
    pass

  def show_sorted(self,
        flags=None,
        sites_cart=None,
        site_labels=None,
        f=None):
    """
    Similar to geo file
    """
    pass

  def nb_overlaps_info(
    self,
    sites_cart,
    hd_sel,
    macro_mol_sel=None,
    site_labels=None):
    """ non-bonded overlaps information """
    return None


 *******************************************************************************


 *******************************************************************************
cctbx/geometry_restraints/distance_least_squares.py
from __future__ import absolute_import, division, print_function
from cctbx import geometry_restraints
import cctbx.geometry_restraints.flags
import cctbx.geometry_restraints.manager
import cctbx.geometry_restraints.lbfgs
from cctbx import xray
from cctbx import crystal
import cctbx.crystal.coordination_sequences
from cctbx import sgtbx
from cctbx.array_family import flex
from scitbx import matrix as mx
import scitbx.lbfgs
from libtbx.str_utils import format_value
from itertools import count
import sys
from six.moves import range

if (1):
  flex.set_random_seed(0)

class restraint_parameters(object):

  def __init__(self, distance_ideal, weight):
    self.distance_ideal = distance_ideal
    self.weight = weight

restraint_parameters_si_o = restraint_parameters(1.61, 2.0)
restraint_parameters_o_si_o = restraint_parameters(2.629099, 0.41)
restraint_parameters_si_o_si = restraint_parameters(3.070969, 0.2308)

def setup_bond_params_table(structure, bond_sym_table):
  scatterers = structure.scatterers()
  t = geometry_restraints.bond_params_table(scatterers.size())
  for i_seq,bond_sym_dict in enumerate(bond_sym_table):
    for j_seq in bond_sym_dict.keys():
      i_seqs = [i_seq, j_seq]
      i_seqs.sort()
      scattering_types = [scatterers[i].scattering_type for i in i_seqs]
      scattering_types.sort()
      if (scattering_types == ["Si", "Si"]):
        params = restraint_parameters_si_o_si
      elif (scattering_types == ["O", "Si"]):
        params = restraint_parameters_si_o
      elif (scattering_types == ["O", "O"]):
        params = restraint_parameters_o_si_o
      else:
        raise AssertionError("Unknown scattering type pair.")
      if (j_seq not in t[i_seq]):
        t[i_seq][j_seq] = geometry_restraints.bond_params(
          distance_ideal=params.distance_ideal,
          weight=params.weight)
      else:
        prev_params = t[i_seq][j_seq]
        assert abs(prev_params.distance_ideal - params.distance_ideal) < 1.e-8
        assert abs(prev_params.weight - params.weight) < 1.e-8
  return t

def setup_nonbonded_params():
  p = geometry_restraints.nonbonded_params()
  d = p.distance_table
  d.setdefault("Si")["Si"] = 3.1
  d.setdefault("Si")["O"] = 1.5
  d.setdefault("O")["O"] = 2.0
  return p

class add_oxygen(object):

  def __init__(self, si_structure, si_si_sym_table):
    self.structure = si_structure.deep_copy_scatterers()
    bond_sym_table = crystal.pair_sym_table(si_si_sym_table.size())
    sites_frac = si_structure.sites_frac()
    i_oxygen = count(1)
    for i_seq,pair_sym_dict in enumerate(si_si_sym_table):
      site_frac_i = mx.col(sites_frac[i_seq])
      for j_seq,sym_ops in pair_sym_dict.items():
        assert j_seq >= i_seq
        for rt_mx_ji in sym_ops:
          site_frac_ji = mx.col(rt_mx_ji * sites_frac[j_seq])
          bond_center = (site_frac_i + site_frac_ji) / 2
          i_seq_o = self.structure.scatterers().size()
          self.structure.add_scatterer(xray.scatterer(
            label="O%d"%next(i_oxygen),
            site=bond_center))
          bond_sym_table[i_seq].setdefault(i_seq_o).append(
            sgtbx.rt_mx(1,1))
          bond_sym_table[j_seq].setdefault(i_seq_o).append(
            rt_mx_ji.inverse_cancel())
          bond_sym_table.append(crystal.pair_sym_dict())
    self.bond_sym_table = bond_sym_table.tidy(
      site_symmetry_table=self.structure.site_symmetry_table())

def make_o_si_o_sym_table(si_o_structure, si_o_bond_sym_table):
  scatterers = si_o_structure.scatterers()
  si_o_full_sym_table = si_o_bond_sym_table.full_connectivity(
    site_symmetry_table=si_o_structure.site_symmetry_table())
  o_si_o_sym_table = crystal.pair_sym_table(si_o_full_sym_table.size())
  for i_seq,pair_sym_dict in enumerate(si_o_full_sym_table):
    if (scatterers[i_seq].scattering_type != "Si"): continue
    jr_list = []
    for j_seq,sym_ops in pair_sym_dict.items():
      if (scatterers[j_seq].scattering_type != "O"): continue
      for rt_mx_ji in sym_ops:
        jr_list.append((j_seq,rt_mx_ji))
    for i_jj1 in range(0,len(jr_list)-1):
      jr1 = jr_list[i_jj1]
      i_seq = jr1[0]
      rt_mx_jr1_inv = jr1[1].inverse()
      for i_jj2 in range(i_jj1+1,len(jr_list)):
        jr2 = jr_list[i_jj2]
        j_seq = jr2[0]
        rt_mx_jr21 = rt_mx_jr1_inv.multiply(jr2[1])
        if (i_seq <= j_seq):
          o_si_o_sym_table[i_seq].setdefault(j_seq).append(rt_mx_jr21)
        else:
          o_si_o_sym_table[j_seq].setdefault(i_seq).append(rt_mx_jr21.inverse())
  return o_si_o_sym_table.tidy(
    site_symmetry_table=si_o_structure.site_symmetry_table())

class distance_and_repulsion_least_squares:

  def __init__(self,
        si_structure,
        distance_cutoff,
        nonbonded_distance_cutoff=None,
        nonbonded_buffer=1,
        nonbonded_repulsion_function_type="gaussian",
        nonbonded_max_residual_bond_stretch_factor=1.0,
        n_trials=1,
        n_macro_cycles=2,
        max_exceptions_handled=10,
        connectivities=None,
        out=None,
        dev=False):
    assert nonbonded_repulsion_function_type in ["gaussian", "cos", "prolsq"]
    assert n_trials > 0
    assert n_macro_cycles > 0
    assert max_exceptions_handled >= 0
    if (out is None): out = sys.stdout
    si_structure.show_summary(f=out).show_scatterers(f=out)
    print(file=out)
    out.flush()
    def get_si_si_sym_table():
      si_asu_mappings = si_structure.asu_mappings(
        buffer_thickness=distance_cutoff)
      asu_table = crystal.pair_asu_table(asu_mappings=si_asu_mappings)
      asu_table.add_all_pairs(distance_cutoff=distance_cutoff)
      si_si_sym_table = asu_table.extract_pair_sym_table()
      si_pair_counts = si_structure.pair_sym_table_show_distances(
        pair_sym_table=si_si_sym_table,
        out=out)
      if (connectivities is not None):
        assert list(si_pair_counts) == connectivities
      print(file=out)
      return si_si_sym_table, si_pair_counts
    si_si_sym_table, si_pair_counts = get_si_si_sym_table()
    out.flush()
    si_o = add_oxygen(
      si_structure=si_structure,
      si_si_sym_table=si_si_sym_table)
    si_o.structure.show_summary(f=out).show_scatterers(f=out)
    si_o_sst = si_o.structure.site_symmetry_table()
    print(file=out)
    out.flush()
    si_o_pair_counts = si_o.structure.pair_sym_table_show_distances(
      pair_sym_table=si_o.bond_sym_table,
      out=out)
    n_si = si_pair_counts.size()
    n_si_o = si_o_pair_counts.size()
    assert si_o_pair_counts[:n_si].all_eq(si_pair_counts)
    assert si_o_pair_counts[n_si:].count(2) == n_si_o-n_si
    print(file=out)
    out.flush()
    o_si_o_sym_table = make_o_si_o_sym_table(
      si_o_structure=si_o.structure,
      si_o_bond_sym_table=si_o.bond_sym_table)
    o_si_o_pair_counts = si_o.structure.pair_sym_table_show_distances(
      pair_sym_table=o_si_o_sym_table,
      out=out)
    assert o_si_o_pair_counts[:n_si].all_eq(0)
    if (si_pair_counts.count(4) == n_si):
      assert o_si_o_pair_counts[n_si:].all_eq(6)
    print(file=out)
    out.flush()
    shell_sym_tables = crystal.coordination_sequences.shell_sym_tables(
      full_pair_sym_table=si_o.bond_sym_table.full_connectivity(
        site_symmetry_table=si_o_sst),
      site_symmetry_table=si_o_sst,
      max_shell=3)
    if (1):
      shell_sym_tables[0].add_pair_sym_table_in_place(other=si_si_sym_table)
    if (1):
      shell_sym_tables[0].add_pair_sym_table_in_place(other=o_si_o_sym_table)
    shell_sym_tables = [_.tidy(site_symmetry_table=si_o_sst)
      for _ in shell_sym_tables]
    bond_params_table = setup_bond_params_table(
      structure=si_o.structure,
      bond_sym_table=shell_sym_tables[0])
    nonbonded_params = setup_nonbonded_params()
    nonbonded_types = flex.std_string()
    for scatterer in si_o.structure.scatterers():
      nonbonded_types.append(scatterer.scattering_type)
    if (nonbonded_repulsion_function_type == "gaussian"):
      nonbonded_function = geometry_restraints.gaussian_repulsion_function(
        max_residual=bond_params_table.mean_residual(
          bond_stretch_factor=nonbonded_max_residual_bond_stretch_factor))
      if (nonbonded_distance_cutoff is None):
        nonbonded_distance_cutoff = 7
    elif (nonbonded_repulsion_function_type == "cos"):
      nonbonded_function = geometry_restraints.cos_repulsion_function(
        max_residual=bond_params_table.mean_residual(
          bond_stretch_factor=nonbonded_max_residual_bond_stretch_factor))
    else:
      nonbonded_function = geometry_restraints.prolsq_repulsion_function()
    geometry_restraints_manager = geometry_restraints.manager.manager(
      crystal_symmetry=si_o.structure,
      site_symmetry_table=si_o_sst,
      bond_params_table=bond_params_table,
      shell_sym_tables=shell_sym_tables,
      nonbonded_params=nonbonded_params,
      nonbonded_types=nonbonded_types,
      nonbonded_function=nonbonded_function,
      nonbonded_distance_cutoff=nonbonded_distance_cutoff,
      nonbonded_buffer=nonbonded_buffer,
      max_reasonable_bond_distance=100)
    minimized = None
    for i_trial in range(n_trials):
      for i_exceptions_handled in range(max_exceptions_handled+1):
        trial_structure = si_o.structure.deep_copy_scatterers()
        if (i_trial > 0):
          n_scatterers = trial_structure.scatterers().size()
          trial_structure.set_sites_cart(flex.vec3_double(flex.random_double(
            size=n_scatterers*3)*10-5))
          trial_structure.apply_symmetry_sites()
        trial_minimized = []
        trial_sites_cart = None
        for i_macro_cycle in range(n_macro_cycles):
          if (trial_sites_cart is not None):
            trial_structure.set_sites_cart(sites_cart=trial_sites_cart)
            trial_structure = trial_structure.random_shift_sites(
              max_shift_cart=0.2)
            trial_structure.apply_symmetry_sites()
          trial_sites_cart = trial_structure.sites_cart()
          geometry_restraints_flags = geometry_restraints.flags.flags(
            bond=True,
            nonbonded=((i_macro_cycle % 2) != (n_macro_cycles % 2)))
          if (not dev):
            try:
              m = geometry_restraints.lbfgs.lbfgs(
                sites_cart=trial_sites_cart,
                correct_special_position_tolerance=1.0,
                geometry_restraints_manager=geometry_restraints_manager,
                geometry_restraints_flags=geometry_restraints_flags,
                lbfgs_termination_params=scitbx.lbfgs.termination_parameters(
                  max_iterations=100),
                lbfgs_exception_handling_params=
                  scitbx.lbfgs.exception_handling_parameters(
                    ignore_line_search_failed_step_at_lower_bound=True))
            except RuntimeError as lbfgs_error:
              if (i_trial == 0): raise
              if (not str(lbfgs_error).startswith(
                    "Bond distance > max_reasonable_bond_distance: ")): raise
              m = None
              break
            else:
              trial_minimized.append(m)
              trial_structure.set_sites_cart(sites_cart=trial_sites_cart)
          else:
            m = dev_lbfgs(
              sites_cart=trial_sites_cart,
              geometry_restraints_manager=geometry_restraints_manager,
              geometry_restraints_flags=geometry_restraints_flags,
              lbfgs_termination_params=scitbx.lbfgs.termination_parameters(
                max_iterations=100),
              lbfgs_exception_handling_params=
                scitbx.lbfgs.exception_handling_parameters(
                  ignore_line_search_failed_step_at_lower_bound=True))
            trial_minimized.append(m)
            trial_structure.set_sites_cart(sites_cart=trial_sites_cart)
        if (m is not None):
          break
      else:
        raise RuntimeError(
          "max_exceptions_handled=%d exceeded: %s" % (
            max_exceptions_handled, str(lbfgs_error)))
      ftr = trial_minimized[-1].final_target_result
      pair_proxies = geometry_restraints_manager.pair_proxies(
        sites_cart=trial_sites_cart)
      min_nonbonded_distance = flex.min_default(
        pair_proxies.nonbonded_proxies.deltas(sites_cart=trial_sites_cart),
        None)
      print("i_trial, bond, nonbonded, min distance: %d, %.6g, %.6g, %s" % (
          i_trial,
          ftr.bond_residual_sum,
          ftr.nonbonded_residual_sum,
          format_value(format="%.4g", value=min_nonbonded_distance)), file=out)
      out.flush()
      if (minimized is None or       minimized[-1].final_target_result.target
                             > trial_minimized[-1].final_target_result.target):
        minimized = trial_minimized
        minimized_structure = trial_structure
        best_i_trial = i_trial
    assert minimized is not None
    for im,m in enumerate(minimized):
      print(file=out)
      print("Energies at start of %d. minimization:" % (im+1), file=out)
      m.first_target_result.show(f=out)
      print(file=out)
      print("Energies at end of %d. minimization:" % (im+1), file=out)
      m.final_target_result.show(f=out)
    print(file=out)
    print("Final target value (i_trial=%d): %.6g" % (
      best_i_trial, minimized[-1].final_target_result.target), file=out)
    if (minimized[-1].final_target_result.target > 0.1):
      print("WARNING: LARGE final target value: %.6g" % (
        minimized[-1].final_target_result.target), file=out)
    print(file=out)
    minimized_structure.pair_sym_table_show_distances(
      pair_sym_table=shell_sym_tables[0],
      out=out)
    print(file=out)
    sites_cart = minimized_structure.sites_cart()
    pair_proxies = geometry_restraints_manager.pair_proxies(
      sites_cart=sites_cart)
    pair_proxies.bond_proxies.show_sorted(
      by_value="residual",
      sites_cart=sites_cart,
      site_labels=[scatterer.label
        for scatterer in minimized_structure.scatterers()],
      f=out)
    print(file=out)
    pair_proxies.nonbonded_proxies.show_histogram_of_model_distances(
      sites_cart=sites_cart,
      f=out)
    print(file=out)
    out.flush()
    self.geometry_restraints_manager = geometry_restraints_manager
    self.start_structure = si_o.structure
    self.minimized_structure = minimized_structure

class dev_target_result(object):

  def __init__(O, target, n_bond_proxies, bond_residual_sum):
    O.target = target
    O.n_bond_proxies = n_bond_proxies
    O.bond_residual_sum = bond_residual_sum
    O.n_nonbonded_proxies = None
    O.nonbonded_residual_sum = 0

  def show(O, f=None, prefix=""):
    if (f is None): f = sys.stdout
    print(prefix+"target: %.6g" % O.target, file=f)
    if (O.n_bond_proxies is not None):
      print(prefix+"  bond_residual_sum (n=%d): %.6g" % (
        O.n_bond_proxies, O.bond_residual_sum), file=f)
    if (O.n_nonbonded_proxies is not None):
      print(prefix+"  nonbonded_residual_sum (n=%d): %.6g" % (
        O.n_nonbonded_proxies, O.nonbonded_residual_sum), file=f)

class dev_lbfgs(object):

  __slots__ = [
    "grm", "x", "proxies", "minimizer",
    "first_target_result",
    "final_target_result"]

  def __init__(O,
        sites_cart,
        geometry_restraints_manager,
        geometry_restraints_flags,
        lbfgs_termination_params,
        lbfgs_exception_handling_params):
    O.grm = geometry_restraints_manager
    cs = O.grm.crystal_symmetry
    sst = O.grm.site_symmetry_table
    sites_frac = cs.unit_cell().fractionalize(sites_cart)
    O.x = sst.pack_coordinates(sites_frac=sites_frac)
    O.proxies = geometry_restraints.shared_bond_simple_proxy()
    for i_seq,pair_sym_dict in enumerate(O.grm.shell_sym_tables[0]):
      for j_seq,sym_ops in pair_sym_dict.items():
        assert i_seq <= j_seq
        bond_params = O.grm.bond_params_table[i_seq][j_seq]
        for rt_mx_ji in sym_ops:
          O.proxies.append(geometry_restraints.bond_simple_proxy(
            i_seqs=[i_seq, j_seq],
            rt_mx_ji=rt_mx_ji,
            params=bond_params))
    def get_target_result():
      f, _ = O.compute_functional_and_gradients()
      return dev_target_result(
        target=f,
        n_bond_proxies=O.proxies.size(),
        bond_residual_sum=f)
    O.first_target_result = get_target_result()
    import scitbx.lbfgs
    O.minimizer = scitbx.lbfgs.run(
      target_evaluator=O,
      termination_params=lbfgs_termination_params,
      exception_handling_params=lbfgs_exception_handling_params)
    f, _ = O.compute_functional_and_gradients()
    O.final_target_result = get_target_result()

  def compute_functional_and_gradients(O):
    cs = O.grm.crystal_symmetry
    sst = O.grm.site_symmetry_table
    sites_frac = sst.unpack_coordinates(packed_coordinates=O.x)
    sites_cart = cs.unit_cell().orthogonalize(sites_frac)
    g_cart = flex.vec3_double(sites_cart.size(), (0,0,0))
    f = geometry_restraints.bond_residual_sum(
      unit_cell=cs.unit_cell(),
      sites_cart=sites_cart,
      proxies=O.proxies,
      gradient_array=g_cart)
    g_frac = g_cart * cs.unit_cell().orthogonalization_matrix()
    g = sst.pack_gradients(g_frac=g_frac)
    return f, g


 *******************************************************************************


 *******************************************************************************
cctbx/geometry_restraints/energies.py
from __future__ import absolute_import, division, print_function
from libtbx import adopt_init_args
from cctbx import geometry_restraints
from cctbx.array_family import flex
import scitbx.restraints
import math
import sys
from six.moves import zip
from libtbx import Auto

class energies(scitbx.restraints.energies):

  def __init__(self, sites_cart,
               unit_cell=None,
               bond_proxies=None,
               nonbonded_proxies=None,
               nonbonded_function=None,
               angle_proxies=None,
               dihedral_proxies=None,
               reference_coordinate_proxies=None,
               reference_dihedral_manager=None,
               ncs_dihedral_manager=None,
               den_manager=None,
               chirality_proxies=None,
               planarity_proxies=None,
               parallelity_proxies=None,
               bond_similarity_proxies=None,
               ramachandran_manager=None,
               external_energy_function=None,
               compute_gradients=True,
               gradients=None,
               disable_asu_cache=False,
               normalization=False,
               extension_objects=[]):
    # runsnaked away...
    #adopt_init_args(self, locals())
    #for local in sorted(locals()):
    #  print "    self.%(local)s=%(local)s" % locals()
    #assert 0
    #
    self.angle_proxies=angle_proxies
    self.bond_proxies=bond_proxies
    self.bond_similarity_proxies=bond_similarity_proxies
    self.chirality_proxies=chirality_proxies
    self.compute_gradients=compute_gradients
    self.den_manager=den_manager
    self.dihedral_proxies=dihedral_proxies
    self.disable_asu_cache=disable_asu_cache
    self.extension_objects=extension_objects
    self.external_energy_function=external_energy_function
    self.gradients=gradients
    # self.ncs_dihedral_manager=ncs_dihedral_manager
    self.nonbonded_function=nonbonded_function
    self.nonbonded_proxies=nonbonded_proxies
    self.normalization=normalization
    self.parallelity_proxies=parallelity_proxies
    self.planarity_proxies=planarity_proxies
    self.ramachandran_manager=ramachandran_manager
    self.reference_coordinate_proxies=reference_coordinate_proxies
    self.reference_dihedral_manager=reference_dihedral_manager
    self.sites_cart=sites_cart
    self.unit_cell=unit_cell
    #
    scitbx.restraints.energies.__init__(self,
                                        compute_gradients=compute_gradients,
                                        gradients=gradients,
                                        gradients_size=sites_cart.size(),
                                        gradients_factory=flex.vec3_double,
                                        normalization=normalization)
    self.n_dihedral_restraints = None
    self.dihedral_restraints_residual_sum = 0
    if (nonbonded_proxies is not None): assert nonbonded_function is not None
    if (compute_gradients):
      if (self.gradients is None):
        self.gradients = flex.vec3_double(sites_cart.size(), [0,0,0])
      else:
        assert self.gradients.size() == sites_cart.size()

    if (bond_proxies is None):
      self.n_bond_proxies = None
      self.bond_residual_sum = 0
    else:
      self.n_bond_proxies = bond_proxies.n_total()
      self.bond_residual_sum = geometry_restraints.bond_residual_sum(
        sites_cart=sites_cart,
        sorted_asu_proxies=bond_proxies,
        gradient_array=self.gradients,
        disable_cache=disable_asu_cache)
      self.number_of_restraints += self.n_bond_proxies
      self.residual_sum += self.bond_residual_sum
    if (nonbonded_proxies is None):
      self.n_nonbonded_proxies = None
      self.nonbonded_residual_sum = 0
    else:
      self.n_nonbonded_proxies = nonbonded_proxies.n_total()
      self.nonbonded_residual_sum = geometry_restraints.nonbonded_residual_sum(
        sites_cart=sites_cart,
        sorted_asu_proxies=nonbonded_proxies,
        gradient_array=self.gradients,
        function=nonbonded_function,
        disable_cache=False)
      self.number_of_restraints += self.n_nonbonded_proxies
      self.residual_sum += self.nonbonded_residual_sum

    # ====================================================================
    # Unit cell dependent
    # ====================================================================
    # name, parameter, function to call
    for name, proxies, residual_sum_function in [
        ("angle", angle_proxies, geometry_restraints.angle_residual_sum),
        ("dihedral",dihedral_proxies, geometry_restraints.dihedral_residual_sum),
        ("planarity", planarity_proxies, geometry_restraints.planarity_residual_sum),
        ("parallelity", parallelity_proxies, geometry_restraints.parallelity_residual_sum),
        ("bond_similarity", bond_similarity_proxies, geometry_restraints.bond_similarity_residual_sum)]:
      setattr(self, "n_%s_proxies" % name, None)
      setattr(self, "%s_residual_sum" % name, 0)
      if proxies is not None:
        n_proxies = proxies.size()
        # setattr(self, "n_%s_proxies" % name, proxies.size())
        if unit_cell is None:
          res_sum = residual_sum_function(
              sites_cart=sites_cart,
              proxies=proxies,
              gradient_array=self.gradients)
        else:
          res_sum = residual_sum_function(
              unit_cell=unit_cell,
              sites_cart=sites_cart,
              proxies=proxies,
              gradient_array=self.gradients)
        self.number_of_restraints += n_proxies
        self.residual_sum += res_sum
        setattr(self, "n_%s_proxies" % name, n_proxies)
        setattr(self, "%s_residual_sum" % name, res_sum)

    # ====================================================================
    # Managers
    # ====================================================================
    for name, manager in [
        ("reference_dihedral", reference_dihedral_manager),
        ("ncs_dihedral", ncs_dihedral_manager),
        ("den", den_manager),
        ("ramachandran", ramachandran_manager)]:
      setattr(self, "n_%s_proxies" % name, None)
      setattr(self, "%s_residual_sum" % name, 0)
      if manager is not None:
        n_proxies = manager.get_n_proxies()
        res_sum = manager.target_and_gradients(
            unit_cell=unit_cell,
            sites_cart=sites_cart,
            gradient_array=self.gradients)
        self.number_of_restraints += n_proxies
        self.residual_sum += res_sum
        setattr(self, "n_%s_proxies" % name, n_proxies)
        setattr(self, "%s_residual_sum" % name, res_sum)

    # ====================================================================
    # The rest (not yet unified)
    # ====================================================================
    if reference_coordinate_proxies is None:
      self.n_reference_coordinate_proxies = None
      self.reference_coordinate_residual_sum = 0
    else:
      import boost_adaptbx.boost.python as bp
      ext = bp.import_ext("mmtbx_reference_coordinate_ext")
      self.n_reference_coordinate_proxies = reference_coordinate_proxies.size()
      self.reference_coordinate_residual_sum = \
          ext.reference_coordinate_residual_sum(
              sites_cart=sites_cart,
              proxies=reference_coordinate_proxies,
              gradient_array=self.gradients)
      self.number_of_restraints += self.n_reference_coordinate_proxies
      self.residual_sum += self.reference_coordinate_residual_sum

    if (self.chirality_proxies is None):
      self.n_chirality_proxies = None
      self.chirality_residual_sum = 0
    else:
      self.n_chirality_proxies = len(self.chirality_proxies)
      self.chirality_residual_sum = geometry_restraints.chirality_residual_sum(
        sites_cart=sites_cart,
        proxies=self.chirality_proxies,
        gradient_array=self.gradients)
      self.number_of_restraints += self.n_chirality_proxies
      self.residual_sum += self.chirality_residual_sum

    if (external_energy_function is not None):
      self.external_energy = external_energy_function(
        sites_cart=sites_cart,
        gradient_array=self.gradients)
      self.residual_sum += self.external_energy
    else :
      self.external_energy = 0
    for extension_obj in self.extension_objects:
      extension_obj.energies_add(energies_obj=self)
    self.finalize_target_and_gradients()

  # Not used anymore? -- used in model_statistics.py
  def get_filtered_n_bond_proxies(self, origin_id=0):
    return self.bond_proxies.simple.proxy_select(origin_id=origin_id).size()

  def get_filtered_n_angle_proxies(self, origin_id=0):
    return self.angle_proxies.proxy_select(origin_id=origin_id).size()

  def get_filtered_n_dihedral_proxies(self):
    return self.dihedral_proxies.proxy_select(origin_id=0).size()

  def get_filtered_n_planarity_proxies(self):
    return self.planarity_proxies.proxy_select(origin_id=0).size()

  def get_angle_outliers(self, sites_cart, sigma_threshold=4, origin_id=0):
    return self.angle_proxies.get_outliers(sites_cart=sites_cart,
                                           sigma_threshold=sigma_threshold,
                                           origin_id=origin_id,
                                           )

  def get_bond_outliers(self, sites_cart, sigma_threshold=4, origin_id=0):
    return self.bond_proxies.get_outliers( sites_cart=sites_cart,
                                           sigma_threshold=sigma_threshold,
                                           origin_id=origin_id,
                                           )

  def get_dihedral_outliers(self, sites_cart, sigma_threshold=4):
    return self.dihedral_proxies.get_outliers(sites_cart=sites_cart,
                                              sigma_threshold=sigma_threshold)

  def get_chirality_outliers(self, sites_cart, sigma_threshold=4):
    return self.chirality_proxies.get_outliers(sites_cart=sites_cart,
                                              sigma_threshold=sigma_threshold)

  def _get_deltas(self, proxies, origin_id=Auto):
    if type(origin_id)==type(1) and origin_id<=0:
      origin_id=abs(origin_id)
    else:
      assert origin_id, 'origin_id is %s' % origin_id
    from cctbx.geometry_restraints.auto_linking_types import iterate_covalent
    if origin_id is Auto:
      deltas = flex.double()
      for oi in iterate_covalent():
        tmp = proxies.deltas(sites_cart=self.sites_cart, origin_id=oi)
        if tmp: deltas.extend(tmp)
    else:
      deltas = proxies.deltas(sites_cart=self.sites_cart, origin_id=origin_id)
    return deltas

  def _get_bond_deltas(self, origin_id=Auto):
    return self._get_deltas(self.bond_proxies, origin_id=origin_id)

  def _get_angle_deltas(self, origin_id=Auto):
    return self._get_deltas(self.angle_proxies, origin_id=origin_id)

  def _sigmas(self, self_proxies, origin_id=Auto):
    from cctbx.geometry_restraints.auto_linking_types import iterate_covalent
    proxies = self_proxies.proxy_select(origin_id=0)
    if origin_id is Auto:
      for oi in iterate_covalent():
        if not oi: continue
        tmp = self_proxies.proxy_select(origin_id=oi)
        if tmp: proxies.extend(tmp)
    sigmas = [geometry_restraints.weight_as_sigma(x.weight) for x in proxies]
    return sigmas

  def bond_sigmas(self, origin_id=Auto):
    return self._sigmas(self.bond_proxies.simple, origin_id=origin_id)

  def angle_sigmas(self, origin_id=Auto):
    return self._sigmas(self.angle_proxies, origin_id=origin_id)

  def bond_deviations_z(self, origin_id=0):
    '''
    Calculate rmsz of bond deviations

    Compute rmsz, the Root-Mean-Square of the z-scors for a set of data
    using z_i = {x_i - mu / sigma}  and rmsz = sqrt(mean(z*z))
    x_i: atcual bond length
    mu: geometry restraints mean
    sigma:  geometry restraints standard deviation
    z_i: z-score for bond i
    z: array of z_i

    The sigma and the (x_i - mu) are model constrains, geometry restraints.
    This function extracts from self, not calculated from data.

    :returns:
    b_rmsz: rmsz, root mean square of the z-scors of all bonds
    b_z_min/max: min/max abolute values of z-scors
    '''
    if(self.n_bond_proxies is not None):
      bond_deltas=self._get_bond_deltas(origin_id=origin_id)
      if len(bond_deltas) >0:
        sigmas = self.bond_sigmas(origin_id=origin_id)
        #assert len(bond_deltas)==len(sigmas), 'bond_deltas!=sigmas %s %s' % (len(bond_deltas), len(sigmas))
        z_scores = flex.double([(bond_delta/sigma) for bond_delta,sigma in zip(bond_deltas,sigmas)])
        b_rmsz = math.sqrt(flex.mean_default(z_scores*z_scores,0))
        b_z_max = flex.max_default(flex.abs(z_scores), 0)
        b_z_min = flex.min_default(flex.abs(z_scores), 0)
        return b_z_min, b_z_max, b_rmsz, len(sigmas)
      else:
        return 0,0,0,0

  def bond_deviations_weighted(self, origin_id=Auto):
    assert 0
    if(self.n_bond_proxies is not None):
      bond_deltas = self.bond_proxies.deltas(
          sites_cart=self.sites_cart, origin_id=origin_id)
      if len(bond_deltas) >0:
        sigmas = flex.double([geometry_restraints.weight_as_sigma(x.weight) for x in self.bond_proxies.simple])
        sigma_mean = flex.mean_default(sigmas, 0)
        z_scores = flex.double([(bond_delta/sigma*sigma_mean) for bond_delta,sigma in zip(bond_deltas,sigmas)])
        b_rmsz = math.sqrt(flex.mean_default(z_scores*z_scores,0))
        b_z_max = flex.max_default(flex.abs(z_scores), 0)
        b_z_min = flex.min_default(flex.abs(z_scores), 0)
        return b_z_min, b_z_max, b_rmsz
      else:
        return 0,0,0

  def bond_deviations(self, origin_id=Auto):
    if(self.n_bond_proxies is not None):
      bond_deltas=self._get_bond_deltas(origin_id=origin_id)
      if len(bond_deltas) >0:
        b_sq  = bond_deltas * bond_deltas
        b_ave = math.sqrt(flex.mean_default(b_sq, 0))
        b_max = math.sqrt(flex.max_default(b_sq, 0))
        b_min = math.sqrt(flex.min_default(b_sq, 0))
        return b_min, b_max, b_ave, len(bond_deltas)
      else:
        return 0,0,0,0

  def angle_deviations_z(self, origin_id=0):
    '''
    Calculate rmsz of angles deviations

    Compute rmsz, the Root-Mean-Square of the z-scors for a set of data
    using z_i = {x_i - mu / sigma}  and rmsz = sqrt(mean(z*z))

    Compute rmsz, the Root-Mean-Square of the z-scors for a set of data
    using z_i = {x_i - mu / sigma}  and rmsz = sqrt(mean(z*z))
    x_i: atcual bond angle
    mu: geometry restraints mean
    sigma:  geometry restraints standard deviation
    z_i: z-score for bond i
    z: array of z_i

    The sigma and the (x_i - mu) are model constrains, geometry restraints. They function extracts
    from self, not calculated from data.

    :returns:
    a_rmsz: rmsz, root mean square of the z-scors of all angles
    a_z_min/max: min/max values of z-scors
    '''
    if(self.n_angle_proxies is not None):
      angle_deltas = self._get_angle_deltas(origin_id=origin_id)
      if len(angle_deltas) > 0:
        sigmas = self.angle_sigmas(origin_id=origin_id)
        assert len(sigmas)==len(angle_deltas)
        z_scores = flex.double([(angle_delta/sigma) for angle_delta,sigma in zip(angle_deltas,sigmas)])
        a_rmsz = math.sqrt(flex.mean_default(z_scores*z_scores,0))
        a_z_max = flex.max_default(flex.abs(z_scores), 0)
        a_z_min = flex.min_default(flex.abs(z_scores), 0)
        return a_z_min, a_z_max, a_rmsz, len(sigmas)
      else:
        return 0,0,0,0

  def angle_deviations_weighted(self):
    assert 0
    if(self.n_angle_proxies is not None):
      angle_deltas = self.angle_proxies.proxy_select(origin_id=0).deltas(
          sites_cart=self.sites_cart)
      if len(angle_deltas) > 0:
        sigmas = self.angle_proxies(origin_id=origin_id)
        sigma_mean = flex.mean_default(sigmas, 0)
        z_scores = flex.double([(angle_delta/sigma*sigma_mean) for angle_delta,sigma in zip(angle_deltas,sigmas)])
        a_rmsz = math.sqrt(flex.mean_default(z_scores*z_scores,0))
        a_z_max = flex.max_default(flex.abs(z_scores), 0)
        a_z_min = flex.min_default(flex.abs(z_scores), 0)
        return a_z_min, a_z_max, a_rmsz
      else:
        return 0,0,0

  def angle_deviations(self, origin_id=Auto):
    if(self.n_angle_proxies is not None):
      angle_deltas = self._get_angle_deltas(origin_id=origin_id)
      # print('angle',origin_id,len(angle_deltas),list(angle_deltas[:10]))
      if len(angle_deltas) > 0:
        a_sq  = angle_deltas * angle_deltas
        a_ave = math.sqrt(flex.mean_default(a_sq, 0))
        a_max = math.sqrt(flex.max_default(a_sq, 0))
        a_min = math.sqrt(flex.min_default(a_sq, 0))
        return a_min, a_max, a_ave, len(angle_deltas)
      else:
        return 0,0,0,0

  def nonbonded_distances(self):
    return geometry_restraints.nonbonded_deltas(
      sites_cart         = self.sites_cart,
      sorted_asu_proxies = self.nonbonded_proxies)

  def nonbonded_deviations(self):
    if(self.n_nonbonded_proxies is not None):
      nonbonded_deltas = self.nonbonded_distances()
      r_sq  = nonbonded_deltas * nonbonded_deltas
      r_ave = math.sqrt(flex.mean_default(r_sq, 0))
      r_max = math.sqrt(flex.max_default(r_sq, 0))
      r_min = math.sqrt(flex.min_default(r_sq, 0))
      return r_min, r_max, r_ave

  def dihedral_deviations(self):
    if(self.n_dihedral_proxies is not None):
      covalent_dihedrals = self.dihedral_proxies.proxy_select(origin_id=0)
      dihedral_deltas = geometry_restraints.dihedral_deltas(
        sites_cart = self.sites_cart,
        proxies    = covalent_dihedrals)
      d_sq  = dihedral_deltas * dihedral_deltas
      d_ave = math.sqrt(flex.mean_default(d_sq, 0))
      d_max = math.sqrt(flex.max_default(d_sq, 0))
      d_min = math.sqrt(flex.min_default(d_sq, 0))
      return d_min, d_max, d_ave

  def reference_dihedral_deviations(self):
    assert 0, "Not working"
    if(self.n_reference_dihedral_proxies is not None):
      reference_dihedral_deltas = geometry_restraints.reference_dihedral_deltas(
        sites_cart = self.sites_cart,
        proxies    = self.reference_dihedral_proxies)
      d_sq  = reference_dihedral_deltas * reference_dihedral_deltas
      d_ave = math.sqrt(flex.mean_default(d_sq, 0))
      d_max = math.sqrt(flex.max_default(d_sq, 0))
      d_min = math.sqrt(flex.min_default(d_sq, 0))
      return d_min, d_max, d_ave

  # def ncs_dihedral_deviations(self):
      # It is probably wrong anyway - origin_id!
  #   if(self.n_ncs_dihedral_proxies is not None):
  #     ncs_dihedral_deltas = geometry_restraints.ncs_dihedral_deltas(
  #       sites_cart = self.sites_cart,
  #       proxies    = self.ncs_dihedral_manager.ncs_dihedral_proxies)
  #     d_sq  = ncs_dihedral_deltas * ncs_dihedral_deltas
  #     d_ave = math.sqrt(flex.mean_default(d_sq, 0))
  #     d_max = math.sqrt(flex.max_default(d_sq, 0))
  #     d_min = math.sqrt(flex.min_default(d_sq, 0))
  #     return d_min, d_max, d_ave

  def chirality_deviations(self):
    if(self.n_chirality_proxies is not None):
      chirality_deltas = geometry_restraints.chirality_deltas(
        sites_cart = self.sites_cart,
        proxies    = self.chirality_proxies)
      c_sq  = chirality_deltas * chirality_deltas
      c_ave = math.sqrt(flex.mean_default(c_sq, 0))
      c_max = math.sqrt(flex.max_default(c_sq, 0))
      c_min = math.sqrt(flex.min_default(c_sq, 0))
      return c_min, c_max, c_ave

  def planarity_deviations(self):
    # XXX Need update, does not respect origin_id
    # assert 0, "Not counting for origin_id"
    if(self.n_planarity_proxies is not None):
      covalent_plan = self.planarity_proxies.proxy_select(origin_id=0)
      planarity_deltas = geometry_restraints.planarity_deltas_rms(
        sites_cart = self.sites_cart,
        proxies    = covalent_plan)
      p_sq  = planarity_deltas * planarity_deltas
      p_ave = math.sqrt(flex.mean_default(p_sq, 0))
      p_max = math.sqrt(flex.max_default(p_sq, 0))
      p_min = math.sqrt(flex.min_default(p_sq, 0))
      return p_min, p_max, p_ave

  def parallelity_deviations(self):
    if self.n_parallelity_proxies is not None:
      parallelity_deltas = geometry_restraints.parallelity_deltas(
        sites_cart = self.sites_cart,
        proxies    = self.parallelity_proxies)
      p_sq  = parallelity_deltas * parallelity_deltas
      p_ave = math.sqrt(flex.mean_default(p_sq, 0))
      p_max = math.sqrt(flex.max_default(p_sq, 0))
      p_min = math.sqrt(flex.min_default(p_sq, 0))
      return p_min, p_max, p_ave

  def show(self, f=None, prefix=""):
    if (f is None): f = sys.stdout
    print(prefix+"target: %.6g" % self.target, file=f)

    for p_name in ["bond", "nonbonded", "angle", "dihedral",
        "reference_dihedral", "reference_coordinate", "ncs_dihedral",
        "den", "chirality", "planarity", "parallelity", "ramachandran",
        "bond_similarity"]:
      if getattr(self, "n_%s_proxies" % p_name) is not None:
        print("%s  %s_residual_sum (n=%d): %.6g" % (
            prefix,
            p_name,
            getattr(self, "n_%s_proxies" % p_name),
            getattr(self, "%s_residual_sum" % p_name)), file=f)
    for extension_obj in self.extension_objects:
      extension_obj.energies_show(energies_obj=self, f=f, prefix=prefix)
    if (self.gradients is not None):
      print(prefix+"  norm of gradients: %.6g" % self.gradients.norm(), file=f)


 *******************************************************************************


 *******************************************************************************
cctbx/geometry_restraints/flags.py
from __future__ import absolute_import, division, print_function
from libtbx import adopt_init_args
import sys

class flags(object):

  def __init__(self,
        bond=None,
        nonbonded=None,
        angle=None,
        dihedral=None,
        reference_coordinate=None,
        reference_dihedral=None,
        ncs_dihedral=None,
        den_restraints=None,
        chirality=None,
        planarity=None,
        parallelity=None,
        bond_similarity=None,
        ramachandran_restraints=None,
        default=False):
    if (bond is None): bond = default
    if (nonbonded is None): nonbonded = default
    if (angle is None): angle = default
    if (dihedral is None): dihedral = default
    if (reference_coordinate is None): reference_coordinate = default
    if (reference_dihedral is None): reference_dihedral = default
    if (ncs_dihedral is None): ncs_dihedral = default
    if den_restraints is None: den_restraints = default
    if (chirality is None): chirality = default
    if (planarity is None): planarity = default
    if (parallelity is None): parallelity = default
    if (bond_similarity is None): bond_similarity = default
    if ramachandran_restraints is None: ramachandran_restraints = default
    adopt_init_args(self, locals())

  def show(self, f=None):
    if (f is None): f = sys.stdout
    print("geometry_restraints.manager.flags:", file=f)
    print("  bond:", self.bond, file=f)
    print("  nonbonded:", self.nonbonded, file=f)
    print("  angle:", self.angle, file=f)
    print("  dihedral:", self.dihedral, file=f)
    print("  reference coordinate:", self.reference_coordinate, file=f)
    print("  reference dihedral:", self.reference_dihedral, file=f)
    print("  chirality:", self.chirality, file=f)
    print("  planarity:", self.planarity, file=f)
    print("  parallelity:", self.parallelity, file=f)
    print("  bond similarity:", self.bond_similarity, file=f)
    print("  ramachandran:", self.ramachandran_restraints, file=f)
    print("  DEN:", self.den_restraints, file=f)


 *******************************************************************************


 *******************************************************************************
cctbx/geometry_restraints/lbfgs.py
from __future__ import absolute_import, division, print_function
from cctbx import crystal
from cctbx.array_family import flex
import scitbx.lbfgs

class empty: pass

class lbfgs(object):

  def __init__(self,
      sites_cart,
      geometry_restraints_manager,
      riding_h_manager=None,
      correct_special_position_tolerance=1.0,
      geometry_restraints_flags=None,
      lbfgs_termination_params=None,
      lbfgs_core_params=None,
      lbfgs_exception_handling_params=None,
      disable_asu_cache=False,
      sites_cart_selection=None,
      site_labels=None,
      states_collector=None):
    if (lbfgs_termination_params is None):
      lbfgs_termination_params = scitbx.lbfgs.termination_parameters(
        max_iterations=1000)
    self.riding_h_manager = riding_h_manager
    self.correct_special_position_tolerance=correct_special_position_tolerance
    self.site_labels = site_labels
    self.states_collector = states_collector
    self.tmp = empty()
    self.rmsd_bonds, self.rmsd_angles = None, None
    if sites_cart_selection:
      self.sites_cart_selection = flex.bool(sites_cart_selection)
      self.tmp.reduced_sites_cart=sites_cart.select(self.sites_cart_selection)
      self.x = flex.double(self.tmp.reduced_sites_cart.size()*3, 0)
    else:
      self.sites_cart_selection = None
      if(self.riding_h_manager is not None):
        self.x = self.riding_h_manager.refinable_parameters_init()
      else:
        self.x = flex.double(sites_cart.size()*3, 0)
    self.tmp.geometry_restraints_manager = geometry_restraints_manager
    self.tmp.geometry_restraints_flags = geometry_restraints_flags
    self.tmp.disable_asu_cache = disable_asu_cache
    self.tmp.sites_cart = sites_cart
    self.tmp.sites_shifted = sites_cart
    self.first_target_result = None
    self.minimizer = scitbx.lbfgs.run(
      target_evaluator=self,
      termination_params=lbfgs_termination_params,
      core_params=lbfgs_core_params,
      exception_handling_params=lbfgs_exception_handling_params)
    self.apply_shifts()
    self.compute_target(compute_gradients=True)
    self.final_target_result = self.tmp.target_result
    sites_cart.clear()
    sites_cart.extend(self.tmp.sites_shifted)
    del self.tmp
    del self.x
    self.first_target_value = self.first_target_result.target
    self.final_target_value = self.final_target_result.target

  def apply_shifts(self):
    if self.sites_cart_selection:
      shifted = self.tmp.reduced_sites_cart + flex.vec3_double(self.x)
      self.tmp.sites_shifted = self.tmp.sites_cart.deep_copy()
      self.tmp.sites_shifted.set_selected(self.sites_cart_selection, shifted)
    else:
      if(self.riding_h_manager is None):
        self.tmp.sites_shifted = self.tmp.sites_cart + flex.vec3_double(self.x)
      else:
        new_sites = self.tmp.sites_cart.select(
          self.riding_h_manager.not_hd_selection) + flex.vec3_double(self.x)
        self.tmp.sites_shifted.set_selected(
          self.riding_h_manager.not_hd_selection, new_sites)
        self.riding_h_manager.idealize_riding_h_positions(sites_cart = self.tmp.sites_shifted)
    if(self.states_collector is not None):
      self.states_collector.add(sites_cart = self.tmp.sites_shifted)
    if (self.tmp.geometry_restraints_manager.crystal_symmetry is not None):
      crystal_symmetry = self.tmp.geometry_restraints_manager.crystal_symmetry
      site_symmetry_table \
        = self.tmp.geometry_restraints_manager.site_symmetry_table
      assert site_symmetry_table is not None
      for i_seq in site_symmetry_table.special_position_indices():
        self.tmp.sites_shifted[i_seq] = crystal.correct_special_position(
          crystal_symmetry=crystal_symmetry,
          tolerance=self.correct_special_position_tolerance,
          special_op=site_symmetry_table.get(i_seq).special_op(),
          site_cart=self.tmp.sites_shifted[i_seq])

  def compute_target(self, compute_gradients):
    self.tmp.target_result = \
      self.tmp.geometry_restraints_manager.energies_sites(
        sites_cart=self.tmp.sites_shifted,
        flags=self.tmp.geometry_restraints_flags,
        compute_gradients=compute_gradients,
        disable_asu_cache=self.tmp.disable_asu_cache,
        site_labels=self.site_labels)

  def compute_functional_and_gradients(self):
    if (self.first_target_result is None):
      assert self.x.all_eq(0)
    else:
      self.apply_shifts()
    self.compute_target(compute_gradients=True)
    self.f = self.tmp.target_result.target
    if (self.first_target_result is None):
      self.first_target_result = self.tmp.target_result
    if self.sites_cart_selection:
      ptr = self.tmp.target_result.gradients
      self.g = ptr.select(self.sites_cart_selection).as_double()
    else:
      if(self.riding_h_manager is None):
        self.g = self.tmp.target_result.gradients.as_double()
      else:
        self.g = self.riding_h_manager.gradients_reduced_cpp(
          gradients    = self.tmp.target_result.gradients,
          sites_cart   = self.tmp.sites_shifted,
          hd_selection = self.riding_h_manager.hd_selection)
    return self.f, self.g


 *******************************************************************************


 *******************************************************************************
cctbx/geometry_restraints/linking_class.py
from __future__ import absolute_import, division, print_function
from cctbx.geometry_restraints.auto_linking_types import origin_ids
from cctbx.geometry_restraints.auto_linking_types import covalent_headers

class linking_class(dict):
  def __init__(self):
    self.data = {}
    origin_id = 0
    for oi in origin_ids:
      for i, item in oi.items():
        if item[0] in self: continue
        self[item[0]] = i #origin_id
        self.data[item[0]] = item
        origin_id+=1

  def __repr__(self):
    outl = 'links\n'
    for i, item in sorted(self.items()):
      if type(i)==type(0) and 0:
        outl += '  %3d\n' % (i)
        for j in item:
          outl += '      %s\n' % (j)
      else:
        outl += '  %-20s : %s\n' % (i, item)
    return outl

  def __getitem__(self, key):
    try:
      return dict.__getitem__(self, key)
    except KeyError as e:
      print('''
Look for a key in the list below

%s
      ''' % self)
      raise e

  def get_origin_id(self,
                    key,
                    add_if_absent=False,
                    return_none_if_absent=False,
                    ):
    rc = self.get(key, None)
    if not rc:
      if return_none_if_absent:
        pass
      elif add_if_absent:
        rc = max(self.values())+1 # = origins(key, internals=[0,1,2,3,4,5])
        self[key] = rc
        self.data[key] = ['key', 'user supplied link']
      else:
        assert rc is not None, 'linking origin id not found for "%s"' % key
    return rc

  def get_origin_key(self, origin_id):
    for key, item in self.items():
      if item==origin_id:
        return key
    return None

  def _get_origin_id_labels(self, internals=None):
    keys = list(self.keys())
    def _sort_on_values(k1, k2):
      if self[k1]<self[k2]: return -1
      return 1
    def _filter_on_internals(k1):
      ptr = {'bonds':0,
             'angles':1,
             'dihedrals':2,
             'planes':3,
             'chirals':4,
             'parallelity':5,
             }[internals]
      if internals is None: return True
      if ptr in self.data[k1].internals: return True
      return False
    from functools import cmp_to_key
    keys.sort(key = cmp_to_key(_sort_on_values))
    keys = filter(_filter_on_internals, keys)
    return keys

  def get_bond_origin_id_labels(self):
    return self._get_origin_id_labels(internals='bonds')

  def get_angle_origin_id_labels(self):
    return self._get_origin_id_labels(internals='angles')

  def get_dihedral_origin_id_labels(self):
    return self._get_origin_id_labels(internals='dihedrals')

  def get_chiral_origin_id_labels(self):
    return self._get_origin_id_labels(internals='chirals')

  def get_plane_origin_id_labels(self):
    return self._get_origin_id_labels(internals='planes')

  def get_parallelity_origin_id_labels(self):
    return self._get_origin_id_labels(internals='parallelity')

  def get_geo_file_header(self, origin_id_label, internals=None):
    info = self.data.get(origin_id_label, None)
    assert info
    if len(info)>=4:
      rc = info[3]
      assert type(rc)==type([])
      if internals in [None, 'bonds']: return rc[0]
      elif internals in ['angles']: return rc[1]
      elif internals in ['dihedrals']: return rc[2]
      elif internals in ['chirals']: return rc[3]
      elif internals in ['planes']: return rc[4]
      elif internals in ['parallelities']: return rc[5]
      else: assert 0
    else: return info[0]

  def parse_geo_file_header(self, origin_id_label, subheader=None, internals=None):
    if origin_id_label in ['Nonbonded']:
      # special case for Nonbonded
      return 0, origin_id_label
    elif not origin_id_label in covalent_headers:
      assert 0, 'origin_id_label "%s" not in %s' % (origin_id_label, covalent_headers)
    info = self.data.get(origin_id_label, None)
    if info:
      assert 0
    else:
      for i, (origin_label, info) in enumerate(self.data.items()):
        if len(info)==2:
          if subheader in info:
            return i, '%s %s' % (origin_id_label, subheader)
        elif len(info)>=4:
          header_info = info[3]
          if isinstance(header_info, list):
            if subheader in header_info:
              return i, '%s %s' % (origin_id_label, subheader)

    print(origin_id_label, subheader)
    assert 0

  def get_origin_label_and_internal(self, query_header, verbose=False):
    '''
    Input:
      Line from a .geo file
    Returns:
      None if not a header line
      If header:
      tuple of:
        Origin_id :
        Bond type : Bond, Bond angle, ...
        Subtype   : A string related mostly to the cif_link used but also
                    origin_id
        Number of restraints: int - number from the header.
    '''
    if verbose:
      for origin_label, info in self.data.items():
        print('origin_label, info',origin_label,info)
    if query_header.find('|')==-1: return None
    tmp = query_header.split('|')
    header=tmp[0].strip()
    subheader=tmp[1].strip()
    oi, rc = self.parse_geo_file_header(header, subheader=subheader)
    rc = rc.replace(header, '').strip()
    tmp = query_header.split(':')
    num = int(tmp[-1])
    return oi, header, rc, num

if __name__=='__main__':
  lc = linking_class()
  print(lc)
  for line in [ 'Bond | covalent geometry | restraints: -1',
                'Bond | Misc. | restraints: -1',
                'Bond | link_BETA1-4 | restraints: -1',
                'Bond | link_TRANS | restraints: -1',
                'Bond angle | covalent geometry | restraints: -1',
                'Bond angle | link_BETA1-4 | restraints: -1',
                'Bond angle | link_TRANS | restraints: -1',
                'Dihedral angle | covalent geometry | restraints: -1',
                'Dihedral angle | C-Beta improper | restraints: -1',
                'Dihedral angle | link_TRANS | restraints: -1',
                'Chirality | covalent geometry | restraints: -1',
                'Chirality | link_BETA1-4 | restraints: -1',
                'Planarity | covalent geometry | restraints: -1',
                'Planarity | link_TRANS | restraints: -1',

                "Bond | Bond-like | restraints: -1",
                "Bond angle | Secondary Structure restraints around h-bond | restraints: -1",
                "Parallelity | Stacking parallelity | restraints: -1",
                "Parallelity | Basepair parallelity | restraints: -1",
                'random line',

                #148L
                'Bond | covalent geometry | restraints: 1390',
                'Bond | Misc. | restraints: 4',
                'Bond | link_BETA1-4 | restraints: 1',
                'Bond | link_TRANS | restraints: 1',
                'Bond angle | covalent geometry | restraints: 1868',
                'Bond angle | link_BETA1-4 | restraints: 3',
                'Bond angle | link_TRANS | restraints: 3',
                'Dihedral angle | covalent geometry | restraints: 563',
                'Dihedral angle | C-Beta improper | restraints: 308',
                'Dihedral angle | link_TRANS | restraints: 3',
                'Chirality | covalent geometry | restraints: 210',
                'Chirality | link_BETA1-4 | restraints: 1',
                'Planarity | covalent geometry | restraints: 238',
                'Planarity | link_TRANS | restraints: 1',
                'Nonbonded | unspecified | interactions: 15086',
    ]:
    print('.........',line, lc.get_origin_label_and_internal(line))


 *******************************************************************************


 *******************************************************************************
cctbx/geometry_restraints/manager.py
from __future__ import absolute_import, division, print_function
from cctbx import geometry_restraints
import cctbx.geometry_restraints.flags
import cctbx.geometry_restraints.energies
from cctbx import crystal
from cctbx.array_family import flex
from scitbx.python_utils.misc import store
from libtbx import introspection
from libtbx import adopt_init_args
from libtbx import dict_with_default_0
from libtbx.utils import Sorry
import sys, math
from six import StringIO
import iotbx.pdb

import boost_adaptbx.boost.python as bp
from six.moves import range
from six.moves import zip
bp.import_ext("scitbx_array_family_flex_ext")
from scitbx_array_family_flex_ext import reindexing_array

from cctbx.geometry_restraints.linking_class import linking_class
origin_ids = linking_class()
from cctbx.geometry_restraints.base_geometry import Base_geometry

def create_side_chain_restraints(hierarchy, grm, log=None):
  proxies=[]
  for rg in hierarchy.residue_groups():
    ags=rg.atom_groups()
    names = []
    for atom in rg.atoms():
      if atom.element_is_hydrogen(): continue
      if atom.name not in names:
        names.append(atom.name)
    pairs=[[],[]]
    for name in names:
      if name in [' CA ', ' N  ', ' C  ', ' O  ']: continue
      for i, ag in enumerate(ags):
        if not ag.altloc: continue
        pairs[i].append(ag.get_atom(name.strip()).i_seq)
    sigma=.2
    if not pairs[0] or not pairs[1]: continue
    if len(pairs[0])<3 or len(pairs[1])<3: continue
    proxy=geometry_restraints.parallelity_proxy(
              i_seqs=flex.size_t(pairs[0]),
              j_seqs=flex.size_t(pairs[1]),
              weight=1/(sigma**2),
              target_angle_deg=0,
              slack=0,
              top_out=False,
              limit=1,
              origin_id=origin_ids.get_origin_id('side-chain parallelity'))
    proxies.append(proxy)
  return proxies

class manager(Base_geometry):
# This class is documented in
# http://www.phenix-online.org/papers/iucrcompcomm_aug2004.pdf
  def __init__(self,
        crystal_symmetry=None,
        model_indices=None,
        conformer_indices=None,
        sym_excl_indices=None,
        site_symmetry_table=None,
        donor_acceptor_excl_groups=None,
        bond_params_table=None,
        shell_sym_tables=None,
        nonbonded_params=None,
        nonbonded_types=None,
        nonbonded_charges=None,
        nonbonded_function=None,
        nonbonded_distance_cutoff=None,
        nonbonded_buffer=1,
        angle_proxies=None,
        dihedral_proxies=None,
        reference_coordinate_proxies=None,
        reference_dihedral_manager=None,
        ncs_dihedral_manager=None,
        den_manager=None,
        chirality_proxies=None,
        planarity_proxies=None,
        parallelity_proxies=None,
        ramachandran_manager=None,
        external_energy_function=None,
        plain_pairs_radius=None,
        max_reasonable_bond_distance=None,
        min_cubicle_edge=5,
        log=StringIO()):
    super(manager, self).__init__()
    if (site_symmetry_table is not None): assert crystal_symmetry is not None
    if (bond_params_table is not None and site_symmetry_table is not None):
      assert bond_params_table.size() == site_symmetry_table.indices().size()
    if (shell_sym_tables is not None and site_symmetry_table is not None):
      assert len(shell_sym_tables) > 0
      assert shell_sym_tables[0].size() == site_symmetry_table.indices().size()
    if (nonbonded_types is not None and site_symmetry_table is not None):
      assert nonbonded_types.size() == site_symmetry_table.indices().size(), "%d != %d" % (
          nonbonded_types.size(), site_symmetry_table.indices().size())
    if (nonbonded_types is not None) and (nonbonded_charges is not None):
      assert nonbonded_charges.size() == nonbonded_types.size(), "%d != %d" % (
          nonbonded_charges.size(), nonbonded_types.size())
    adopt_init_args(self, locals(), exclude=["log"])
    self.reset_internals()

# implement explicit pickling for the log object since StringIO doesn't support pickling
  # def __getstate__(self):
  #   state = self.__dict__.copy()
  #   if hasattr(self.log, "getvalue"):
  #     state[ "log" ] = self.log.getvalue()
  #   else:
  #     state[ "log" ] = ""
  #   return state

  # def __setstate__(self, state):
  #   state[ "log" ] = StringIO( state[ "log" ] )
  #   self.__dict__.update( state )

  def reset_internals(self):
    self._sites_cart_used_for_pair_proxies = None
    self._flags_bond_used_for_pair_proxies = False
    self._flags_nonbonded_used_for_pair_proxies = False
    self._pair_proxies = None
    self.plain_pair_sym_table = None
    self.nonbonded_distance_cutoff_was_determined_automatically = False
    self.adjusted_nonbonded_distance_cutoff = self.nonbonded_distance_cutoff
    self.effective_nonbonded_buffer = self.nonbonded_buffer
    self.n_updates_pair_proxies = 0

  def replace_site_symmetry(self, new_site_symmetry_table,
                                  special_position_settings,
                                  sites_cart):
    assert self.site_symmetry_table is not None
    self.site_symmetry_table = new_site_symmetry_table
    # Recompute shell_sym_tables
    asu_mappings = special_position_settings.asu_mappings(
      buffer_thickness = self.max_reasonable_bond_distance*3 if \
      self.max_reasonable_bond_distance is not None \
      else 150) # arbitrary big number if not defined
    asu_mappings.process_sites_cart(
      original_sites      = sites_cart,
      site_symmetry_table = self.site_symmetry_table)
    bond_asu_table = crystal.pair_asu_table(asu_mappings = asu_mappings)
    # Add all previously defined bonds
    bond_asu_table.add_pair_sym_table(self.shell_sym_tables[0])
    shell_asu_tables = crystal.coordination_sequences.shell_asu_tables(
      pair_asu_table = bond_asu_table,
      max_shell      = 3)
    self.shell_sym_tables = [shell_asu_table.extract_pair_sym_table()
      for shell_asu_table in shell_asu_tables]
    self.reset_internals()

  def simple_edge_list(self, omit_slack_greater_than=0):
    assert self.bond_params_table is not None
    assert self.shell_sym_tables is not None
    result = []
    bpt = self.bond_params_table
    for i,j in self.shell_sym_tables[0].simple_edge_list():
      assert i < j
      if (bpt[i][j].slack > omit_slack_greater_than): continue
      result.append((i,j))
    return result

  def rigid_clusters_due_to_dihedrals_and_planes(self,
        constrain_dihedrals_with_sigma_less_than):
    result = []
    if (self.dihedral_proxies is not None):
      assert constrain_dihedrals_with_sigma_less_than > 0
      weight_limit = 1.0 / constrain_dihedrals_with_sigma_less_than**2
      for proxy in self.get_dihedral_proxies():
        if (proxy.weight > weight_limit):
          result.append(proxy.i_seqs)
    if (self.planarity_proxies is not None):
      for proxy in self.planarity_proxies:
        result.append(proxy.i_seqs)
    return result

  def construct_tardy_tree(self,
        sites=None,
        sites_cart=None,
        selection=None,
        omit_bonds_with_slack_greater_than=0,
        constrain_dihedrals_with_sigma_less_than=10,
        near_singular_hinges_angular_tolerance_deg=5):
    assert [sites_cart, sites].count(None) == 1
    from scitbx.graph import tardy_tree
    from scitbx import matrix
    if (sites is None):
      sites = matrix.col_list(sites_cart)
    if (selection is not None):
      if (not isinstance(selection, flex.bool)):
        selection = flex.bool(len(sites), selection)
      fixed_vertices_bool = ~selection
    else:
      fixed_vertices_bool = flex.bool(len(sites), False)
    if (self.site_symmetry_table is not None):
      fixed_vertices_bool.set_selected(
        self.site_symmetry_table.special_position_indices(), True)
    return tardy_tree.construct(
      sites=sites,
      edge_list=self.simple_edge_list(
        omit_slack_greater_than
          =omit_bonds_with_slack_greater_than),
      external_clusters=self.rigid_clusters_due_to_dihedrals_and_planes(
        constrain_dihedrals_with_sigma_less_than
          =constrain_dihedrals_with_sigma_less_than),
      fixed_vertices=fixed_vertices_bool.iselection(),
      near_singular_hinges_angular_tolerance_deg
        =near_singular_hinges_angular_tolerance_deg)

  def reduce_for_tardy(self,
        tardy_tree,
        omit_bonds_with_slack_greater_than=0,
        include_den_restraints=False):
    from cctbx import sgtbx
    from scitbx.graph.utils import construct_edge_sets
    #
    assert tardy_tree.n_vertices == self.bond_params_table.size()
    loop_edge_sets = construct_edge_sets(
      n_vertices=tardy_tree.n_vertices,
      edge_list=tardy_tree.cluster_manager.loop_edges,
      assert_i_lt_j=False)
    #
    def get():
      result = crystal.pair_sym_table(tardy_tree.n_vertices)
      bond_params_table = self.bond_params_table
      for i,pair_sym_dict in enumerate(self.shell_sym_tables[0]):
        reduced_pair_sym_dict = result[i]
        for j,sym_ops in pair_sym_dict.items():
          reduced_sym_ops = sgtbx.stl_vector_rt_mx()
          for sym_op in sym_ops:
            if (sym_op.is_unit_mx()):
              if (  bond_params_table[i][j].slack
                  > omit_bonds_with_slack_greater_than):
                continue
              if (j not in loop_edge_sets[i]):
                continue
            reduced_sym_ops.append(sym_op)
          if (reduced_sym_ops.size() != 0):
            reduced_pair_sym_dict[j] = reduced_sym_ops
      return [result]
    reduced_shell_sym_tables = get()
    #
    def get():
      result = geometry_restraints.shared_angle_proxy()
      for proxy in self.angle_proxies:
        i,j,k = proxy.i_seqs
        if (   j in loop_edge_sets[i]
            or j in loop_edge_sets[k]):
          result.append(proxy)
      if (result.size() == 0):
        return None
      return result
    reduced_angle_proxies = get()
    #
    def get():
      result = geometry_restraints.shared_dihedral_proxy()
      ec = tardy_tree.cluster_manager.edge_classifier()
      for proxy in self.get_dihedral_proxies():
        if (ec(edge=proxy.i_seqs[1:3]) in ["hinge", "loop"]):
          result.append(proxy)
      if (result.size() == 0):
        return None
      return result
    reduced_dihedral_proxies = get()
    #
    if not include_den_restraints:
      result = manager(
        crystal_symmetry=self.crystal_symmetry,
        site_symmetry_table=self.site_symmetry_table,
        bond_params_table=self.bond_params_table,
        shell_sym_tables=reduced_shell_sym_tables,
        angle_proxies=reduced_angle_proxies,
        dihedral_proxies=reduced_dihedral_proxies,
        ncs_dihedral_manager=self.ncs_dihedral_manager)
    else:
      result = manager(
        crystal_symmetry=self.crystal_symmetry,
        site_symmetry_table=self.site_symmetry_table,
        bond_params_table=self.bond_params_table,
        shell_sym_tables=reduced_shell_sym_tables,
        angle_proxies=reduced_angle_proxies,
        dihedral_proxies=reduced_dihedral_proxies,
        ncs_dihedral_manager=self.ncs_dihedral_manager,
        den_manager=self.den_manager,
        ramachandran_manager=self.ramachandran_manager)
    result.set_source(source = self.get_source())
    return result

  def sites_cart_used_for_pair_proxies(self):
    return self._sites_cart_used_for_pair_proxies

  def new_including_isolated_sites(self,
        n_additional_sites,
        model_indices=None,
        conformer_indices=None,
        sym_excl_indices=None,
        donor_acceptor_excl_groups=None,
        site_symmetry_table=None,
        nonbonded_types=None,
        nonbonded_charges=None):
    assert n_additional_sites >= 0
    assert (model_indices is None) == (self.model_indices is None)
    assert (conformer_indices is None) == (self.conformer_indices is None)
    assert (donor_acceptor_excl_groups is None) == \
           (self.donor_acceptor_excl_groups is None)
    assert (sym_excl_indices is None) == (self.sym_excl_indices is None)
    assert (site_symmetry_table is None) == (self.site_symmetry_table is None)
    assert (nonbonded_types is None) == (self.nonbonded_types is None)
    if (self.model_indices is not None):
      assert model_indices.size() == n_additional_sites
      model_indices = self.model_indices.concatenate(
        model_indices)
    if (self.conformer_indices is not None):
      assert conformer_indices.size() == n_additional_sites
      conformer_indices = self.conformer_indices.concatenate(
        conformer_indices)
    if (self.donor_acceptor_excl_groups is not None):
      assert donor_acceptor_excl_groups.size() == n_additional_sites
      donor_acceptor_excl_groups = self.donor_acceptor_excl_groups.concatenate(
        donor_acceptor_excl_groups)
    if (self.sym_excl_indices is not None):
      assert sym_excl_indices.size() == n_additional_sites
      sym_excl_indices = self.sym_excl_indices.concatenate(
        sym_excl_indices)
    if (self.site_symmetry_table is not None):
      assert site_symmetry_table.indices().size() == n_additional_sites
      # XXX should become site_symmetry_table.concatenate()
      new_site_symmetry_table = self.site_symmetry_table.deep_copy()
      new_site_symmetry_table.reserve(new_site_symmetry_table.indices().size()
                                    + n_additional_sites)
      for i_seq in range(n_additional_sites):
        new_site_symmetry_table.process(site_symmetry_table.get(i_seq))
      site_symmetry_table = new_site_symmetry_table
    bond_params_table = None
    if (self.bond_params_table is not None):
      bond_params_table = self.bond_params_table.deep_copy()
      bond_params_table.extend(geometry_restraints.bond_params_table(
        n_additional_sites))
    shell_sym_tables = None
    if (self.shell_sym_tables is not None):
      shell_sym_tables = []
      for shell_sym_table in self.shell_sym_tables:
        shell_sym_table = shell_sym_table.deep_copy()
        shell_sym_table.extend(crystal.pair_sym_table(n_additional_sites))
        shell_sym_tables.append(shell_sym_table)
    if (self.nonbonded_types is not None):
      assert nonbonded_types.size() == n_additional_sites
      nonbonded_types = self.nonbonded_types.concatenate(
        nonbonded_types)
    if (self.nonbonded_charges is not None):
      if (nonbonded_charges is None):
        nonbonded_charges = flex.int(n_additional_sites, 0)
      assert (nonbonded_charges.size() == n_additional_sites)
      nonbonded_charges = self.nonbonded_charges.concatenate(
        nonbonded_charges)
    result = manager(
      crystal_symmetry=self.crystal_symmetry,
      model_indices=model_indices,
      conformer_indices=conformer_indices,
      sym_excl_indices=sym_excl_indices,
      donor_acceptor_excl_groups=donor_acceptor_excl_groups,
      site_symmetry_table=site_symmetry_table,
      bond_params_table=bond_params_table,
      shell_sym_tables=shell_sym_tables,
      nonbonded_params=self.nonbonded_params,
      nonbonded_types=nonbonded_types,
      nonbonded_charges=nonbonded_charges,
      nonbonded_function=self.nonbonded_function,
      nonbonded_distance_cutoff=self.nonbonded_distance_cutoff,
      nonbonded_buffer=self.nonbonded_buffer,
      angle_proxies=self.angle_proxies,
      dihedral_proxies=self.dihedral_proxies,
      reference_coordinate_proxies=self.reference_coordinate_proxies,
      reference_dihedral_manager=self.reference_dihedral_manager,
      ramachandran_manager=self.ramachandran_manager,
      ncs_dihedral_manager=self.ncs_dihedral_manager,
      den_manager=self.den_manager,
      chirality_proxies=self.chirality_proxies,
      planarity_proxies=self.planarity_proxies,
      parallelity_proxies=self.parallelity_proxies,
      plain_pairs_radius=self.plain_pairs_radius,
      max_reasonable_bond_distance=self.max_reasonable_bond_distance)
    result.set_source(source = self.get_source())
    return result

  def select(self, selection=None, iselection=None):
    assert [selection, iselection].count(None) == 1

    n_seqs = dict_with_default_0()
    if (iselection is None):
      iselection = selection.iselection()
      n_seqs[selection.size()] += 1

    selected_stuff = [None]*7
    for i, stuff in enumerate([self.model_indices, self.conformer_indices,
        self.sym_excl_indices, self.donor_acceptor_excl_groups,
        self.nonbonded_types,
        self.nonbonded_charges]):
      if stuff is not None:
        selected_stuff[i] = stuff.select(iselection)
        n_seqs[stuff.size()] += 1
    selected_site_symmetry_table = None
    if (self.site_symmetry_table is not None):
      selected_site_symmetry_table = self.site_symmetry_table.select(
        iselection)
      n_seqs[self.site_symmetry_table.indices().size()] += 1
    selected_bond_params_table = None
    if (self.bond_params_table is not None):
      selected_bond_params_table = self.bond_params_table.proxy_select(
        iselection)
      n_seqs[self.bond_params_table.size()] += 1
    selected_shell_sym_tables = None
    if (self.shell_sym_tables is not None):
      selected_shell_sym_tables = [shell_sym_table.proxy_select(
          iselection)
        for shell_sym_table in self.shell_sym_tables]
      if (len(self.shell_sym_tables) > 0):
        n_seqs[self.shell_sym_tables[0].size()] += 1
    selected_nonbonded_types = None

    def get_n_seq():
      if (len(n_seqs) == 0):
        raise RuntimeError("Cannot determine n_seq.")
      if (len(n_seqs) != 1):
        raise RuntimeError("Selection size mismatches: %s." % str(n_seqs))
      return list(n_seqs.keys())[0]  # FIXME this might break py2/3 compat unless there is only 1 key

    n_seq = get_n_seq()

    selected_proxies = [None]*11
    for i, proxies in enumerate([self.angle_proxies, self.dihedral_proxies,
        self.reference_coordinate_proxies, self.reference_dihedral_manager,
        self.ncs_dihedral_manager, self.den_manager, self.chirality_proxies,
        self.planarity_proxies, self.parallelity_proxies,
        self.ramachandran_manager]):
      if proxies is not None:
        selected_proxies[i] = proxies.proxy_select(n_seq, iselection)

    result = manager(
      crystal_symmetry=self.crystal_symmetry,
      site_symmetry_table=selected_site_symmetry_table,
      model_indices=selected_stuff[0],
      conformer_indices=selected_stuff[1],
      sym_excl_indices=selected_stuff[2],
      donor_acceptor_excl_groups=selected_stuff[3],
      bond_params_table=selected_bond_params_table,
      shell_sym_tables=selected_shell_sym_tables,
      nonbonded_params=self.nonbonded_params,
      nonbonded_types=selected_stuff[4],
      nonbonded_charges=selected_stuff[5],
      nonbonded_function=self.nonbonded_function,
      nonbonded_distance_cutoff=self.nonbonded_distance_cutoff,
      nonbonded_buffer=self.nonbonded_buffer,
      angle_proxies=selected_proxies[0],
      dihedral_proxies=selected_proxies[1],
      reference_coordinate_proxies=selected_proxies[2],
      reference_dihedral_manager=selected_proxies[3],
      ramachandran_manager=selected_proxies[9],
      ncs_dihedral_manager=selected_proxies[4],
      den_manager=selected_proxies[5],
      chirality_proxies=selected_proxies[6],
      planarity_proxies=selected_proxies[7],
      parallelity_proxies=selected_proxies[8],
      plain_pairs_radius=self.plain_pairs_radius,
      max_reasonable_bond_distance=self.max_reasonable_bond_distance)
    result.set_source(source = self.get_source())
    return result

  def shift_sites_cart(self, shift):
    # just a stub from RSR. Proper treatment can be implemented here.
    self.remove_reference_coordinate_restraints_in_place()

  def discard_symmetry(self, new_unit_cell):
    assert self.site_symmetry_table is not None #XXX lazy
    assert self.shell_sym_tables is not None #XXX lazy
    result = manager(
      crystal_symmetry=crystal.symmetry(
        unit_cell=new_unit_cell,
        space_group_symbol="P1"),
      model_indices=self.model_indices,
      conformer_indices=self.conformer_indices,
      sym_excl_indices=None,
      donor_acceptor_excl_groups=self.donor_acceptor_excl_groups,
      site_symmetry_table=self.site_symmetry_table.discard_symmetry(),
      bond_params_table=self.bond_params_table,
      shell_sym_tables=[t.discard_symmetry() for t in self.shell_sym_tables],
      nonbonded_params=self.nonbonded_params,
      nonbonded_types=self.nonbonded_types,
      nonbonded_charges=self.nonbonded_charges,
      nonbonded_function=self.nonbonded_function,
      nonbonded_distance_cutoff=self.nonbonded_distance_cutoff,
      nonbonded_buffer=self.nonbonded_buffer,
      angle_proxies=self.angle_proxies,
      dihedral_proxies=self.dihedral_proxies,
      reference_coordinate_proxies=self.reference_coordinate_proxies,
      reference_dihedral_manager=self.reference_dihedral_manager,
      ramachandran_manager=self.ramachandran_manager,
      ncs_dihedral_manager=self.ncs_dihedral_manager,
      den_manager=self.den_manager,
      chirality_proxies=self.chirality_proxies,
      planarity_proxies=self.planarity_proxies,
      parallelity_proxies=self.parallelity_proxies,
      plain_pairs_radius=self.plain_pairs_radius,
      max_reasonable_bond_distance=self.max_reasonable_bond_distance)
    result.set_source(source = self.get_source())
    return result

  def add_angles_in_place(self, additional_angle_proxies):
    self.angle_proxies.extend(additional_angle_proxies)

  def remove_angles_in_place(self, selection):
    self.angle_proxies = self.angle_proxies.proxy_remove(
      selection=selection)

  #=================================================================
  # User-supplied restraints (geometry_restraints.edits scope)
  #=================================================================
  def get_user_supplied_restraints(self):
    bonds_simpe = None
    bonds_asu = None
    angles = None
    planarity = None
    parallelity = None
    pair_proxies = self.pair_proxies()
    specific_origin_id = origin_ids.get_origin_id('edits')
    if pair_proxies is not None:
      if pair_proxies.bond_proxies is not None:
        bonds_simpe = pair_proxies.bond_proxies.simple.proxy_select(
          origin_id=specific_origin_id)
        bonds_asu = pair_proxies.bond_proxies.asu.proxy_select(
          origin_id=specific_origin_id)
    angles = self.angle_proxies.proxy_select(
      origin_id=specific_origin_id)
    dihedrals = self.dihedral_proxies.proxy_select(
      origin_id=specific_origin_id)
    planarity = self.planarity_proxies.proxy_select(
      origin_id=specific_origin_id)
    parallelity = self.parallelity_proxies.proxy_select(
      origin_id=specific_origin_id)
    return bonds_simpe, bonds_asu, angles, dihedrals, planarity, parallelity

  def remove_user_supplied_restraints_in_place(self):
    """
    Problem is in removing bond restraints, which is not yet implemented at all
    and rather complicated.
    """
    raise NotImplementedError

  def get_bond_proxies_without_user_supplied(self, sites_cart=None):
    pair_proxies = self.pair_proxies(sites_cart=sites_cart)
    simple = None
    asu = None
    specific_origin_id = origin_ids.get_origin_id('edits')
    if pair_proxies is not None:
      if pair_proxies.bond_proxies is not None:
        if pair_proxies.bond_proxies.simple is not None:
          simple = pair_proxies.bond_proxies.simple.get_proxies_without_origin_id(
            origin_id=specific_origin_id)
        if pair_proxies.bond_proxies.asu is not None:
          asu = pair_proxies.bond_proxies.asu.get_proxies_without_origin_id(
            origin_id=specific_origin_id)
    return simple, asu

  def get_angle_proxies_without_user_supplied(self):
    specific_origin_id = origin_ids.get_origin_id('edits')
    if self.angle_proxies is not None:
      return self.angle_proxies.proxy_remove(origin_id=specific_origin_id)
    return None

  def get_dihedral_proxies_without_user_supplied(self):
    specific_origin_id = origin_ids.get_origin_id('edits')
    if self.dihedral_proxies is not None:
      return self.dihedral_proxies.proxy_remove(origin_id=specific_origin_id)
    return None

  def get_planarity_proxies_without_user_supplied(self):
    specific_origin_id = origin_ids.get_origin_id('edits')
    if self.planarity_proxies is not None:
      return self.planarity_proxies.proxy_remove(origin_id=specific_origin_id)
    return None

  def get_parallelity_proxies_without_user_supplied(self):
    specific_origin_id = origin_ids.get_origin_id('edits')
    if self.parallelity_proxies is not None:
      return self.parallelity_proxies.proxy_remove(origin_id=specific_origin_id)
    return None

  #=================================================================
  # Reference coordinate proxies methods
  #=================================================================
  def get_reference_coordinate_proxies(self):
    return self.reference_coordinate_proxies

  def adopt_reference_coordinate_restraints_in_place(self,
      reference_coordinate_proxies):
    self.reference_coordinate_proxies = reference_coordinate_proxies

  def remove_reference_coordinate_restraints_in_place(self,
      selection=None):
    if (selection is not None):
      self.reference_coordinate_proxies = \
        self.reference_coordinate_proxies.proxy_remove(selection=selection)
    else :
      self.reference_coordinate_proxies = None

  def get_n_reference_coordinate_proxies(self):
    if self.reference_coordinate_proxies is not None:
      return self.reference_coordinate_proxies.size()
    else:
      return 0

  def append_reference_coordinate_restraints_in_place(self,
      reference_coordinate_proxies):
    if self.reference_coordinate_proxies is not None:
      self.reference_coordinate_proxies.extend(
          reference_coordinate_proxies)
    else:
      self.reference_coordinate_proxies = reference_coordinate_proxies

  def add_reference_coordinate_restraints_in_place(self,
      all_chain_proxies=None,
      pdb_hierarchy=None,
      selection=None,
      exclude_outliers=True,
      sigma=0.2,
      limit=1.0,
      top_out=False,
      n_atoms_in_target_model=None,
      reference_is_average_alt_confs=None,
      ):
    assert [all_chain_proxies, pdb_hierarchy].count(None) == 1
    assert [all_chain_proxies, n_atoms_in_target_model].count(None) == 1
    if all_chain_proxies is None:
      assert isinstance(selection, flex.size_t)
    from mmtbx.geometry_restraints.reference import add_coordinate_restraints, \
        exclude_outliers_from_reference_restraints_selection

    if isinstance(selection, flex.size_t):
      isel = selection
      bsel = flex.bool(n_atoms_in_target_model, isel)
      sites_cart=pdb_hierarchy.atoms().extract_xyz()
      assert not reference_is_average_alt_confs
    else:
      # should be deleted if all_chain_proxies won't be used
      if reference_is_average_alt_confs:
        hierarchy = all_chain_proxies.pdb_hierarchy.as_forward_compatible_hierarchy()
        asel = hierarchy.average_alt_confs(pinch_limit=limit)
        sites_cart = hierarchy.atoms().extract_xyz()
      else:
        sites_cart = all_chain_proxies.pdb_hierarchy.atoms().extract_xyz()
      new_selection = flex.bool(sites_cart.size(), True)
      if selection is not None:
        new_selection = all_chain_proxies.selection(selection)
        if (new_selection.size() == 0):
          raise Sorry(("No atoms selected for harmonic restraints (input "+
            "selection string: %s)") % selection)
      # print >> self.log, "*** Restraining %d atoms to initial coordinates ***" % \
      #     new_selection.size()
      isel = new_selection.iselection()
    if exclude_outliers:
      new_selection = exclude_outliers_from_reference_restraints_selection(
          pdb_hierarchy=pdb_hierarchy if pdb_hierarchy is not None else all_chain_proxies.pdb_hierarchy,
          restraints_selection=new_selection if all_chain_proxies is not None else bsel)
      isel = new_selection.iselection()
    if reference_is_average_alt_confs:
      isel = asel
    proxies = add_coordinate_restraints(
        sites_cart=sites_cart.select(isel) if n_atoms_in_target_model is None else sites_cart,
        selection=isel,
        sigma=sigma,
        limit=limit,
        top_out_potential=top_out)
    if proxies.size() > 0:
      self.reference_coordinate_proxies = proxies

  #=================================================================
  # Torsion (dihedral) restraints on chi angles (side-chain rotamers)
  # proxies methods
  #=================================================================
  def add_chi_torsion_restraints_in_place(self,
      pdb_hierarchy,
      sites_cart,
      selection=None,
      sigma=2.5,
      limit=15.0,
      chi_angles_only=False,
      top_out_potential=False):
    from mmtbx.geometry_restraints.reference import generate_torsion_restraints
    specific_origin_id = origin_ids.get_origin_id('chi angles')
    chi_torsions = generate_torsion_restraints(
        pdb_hierarchy=pdb_hierarchy,
        sites_cart=sites_cart,
        selection=selection,
        sigma=sigma,
        limit=limit,
        chi_angles_only=chi_angles_only,
        top_out_potential=top_out_potential,
        origin_id=specific_origin_id)
    self.add_dihedrals_in_place(chi_torsions)

  def remove_chi_torsion_restraints_in_place(self, selection=None):
    specific_origin_id = origin_ids.get_origin_id('chi angles')
    if self.dihedral_proxies is not None:
      if selection is None:
        self.dihedral_proxies = self.dihedral_proxies.proxy_remove(
          origin_id=specific_origin_id)
      else:
        chi_proxies = self.dihedral_proxies.proxy_select(
          origin_id=specific_origin_id)
        should_remain_proxies = chi_proxies.proxy_remove(selection=selection)
        self.dihedral_proxies = self.dihedral_proxies.proxy_remove(
          origin_id=specific_origin_id)
        self.add_dihedrals_in_place(should_remain_proxies)

  def get_chi_torsion_proxies(self):
    specific_origin_id = origin_ids.get_origin_id('chi angles')
    if self.dihedral_proxies is not None:
      return self.dihedral_proxies.proxy_select(origin_id=specific_origin_id)

  def get_n_chi_torsion_proixes(self):
    specific_origin_id = origin_ids.get_origin_id('chi angles')
    if self.dihedral_proxies is not None:
      return self.dihedral_proxies.proxy_select(origin_id=specific_origin_id).size()


  #=================================================================
  # Dihedral proxies methods
  #=================================================================
  def add_dihedrals_in_place(self,
      additional_dihedral_proxies,
      check_for_duplicates=True):
    if self.dihedral_proxies is not None:
      if check_for_duplicates:
        # first remove duplicates
        n_atoms = 0
        selection = None
        sel = []
        for p in additional_dihedral_proxies:
          for i_seq in p.i_seqs:
            sel.append(i_seq)
        selection = flex.size_t(sorted(list(set(sel))))
        self.remove_dihedrals_in_place(selection)
      self.dihedral_proxies.extend(additional_dihedral_proxies)
    else:
      self.dihedral_proxies = additional_dihedral_proxies

  def remove_dihedrals_in_place(self, selection):
    if self.dihedral_proxies is not None:
      self.dihedral_proxies = self.dihedral_proxies.proxy_remove(
        selection=selection)

  def get_dihedral_proxies(self):
    specific_origin_id = origin_ids.get_origin_id('covalent geometry')
    if self.dihedral_proxies is not None:
      return self.dihedral_proxies.proxy_select(origin_id=specific_origin_id)
    return None

  #=================================================================
  # C-beta dihedral proxies methods
  #=================================================================
  def get_c_beta_torsion_proxies(self):
    specific_origin_id = origin_ids.get_origin_id('C-beta')
    if self.dihedral_proxies is not None:
      return self.dihedral_proxies.proxy_select(origin_id=specific_origin_id)
    return None

  def get_n_c_beta_torsion_proxies(self):
    tp = self.get_c_beta_torsion_proxies()
    if tp is not None:
      return tp.size()
    return 0

  def remove_c_beta_torsion_restraints_in_place(self, selection=None):
    specific_origin_id = origin_ids.get_origin_id('C-beta')
    if selection is None:
      self.dihedral_proxies = self.dihedral_proxies.proxy_remove(
        origin_id=specific_origin_id)
    else:
      self.dihedral_proxies = self.dihedral_proxies.proxy_select(
        origin_id=specific_origin_id).proxy_remove(selection=selection)

  #=================================================================
  # Reference dihedral proxies methods
  #=================================================================
  def adopt_reference_dihedral_manager(self, manager):
    self.reference_dihedral_manager = manager

  def remove_reference_dihedral_manager(self):
    self.reference_dihedral_manager = None

  def remove_reference_dihedrals_in_place(self, selection):
    if self.reference_dihedral_manager is not None:
      self.reference_dihedral_manager.proxy_remove(selection=selection)

  def remove_ncs_dihedrals_in_place(self):
    if self.ncs_dihedral_manager is not None:
      self.ncs_dihedral_manager.remove_ncs_dihedrals_in_place()

  def update_dihedral_ncs_restraints(self, model, log):
    if self.ncs_dihedral_manager is not None:
      self.ncs_dihedral_manager.update_dihedral_ncs_restraints(
          model=model,
          log=log)

  def get_n_reference_dihedral_proxies(self):
    if self.reference_dihedral_manager is not None:
      return self.reference_dihedral_manager.get_n_proxies()

  def sync_reference_dihedral_with_ncs(self, log):
    if (self.reference_dihedral_manager is not None and
        self.ncs_dihedral_manager is not None):
      self.reference_dihedral_manager.remove_restraints_with_ncs_matches(
          ncs_dihedral_proxies = self.ncs_dihedral_manager.ncs_dihedral_proxies,
          ncs_match_hash       = self.ncs_dihedral_manager.ncs_match_hash,
          log=log)

  #=================================================================
  # DEN manager/proxies methods
  #=================================================================
  def create_den_manager(self, den_params, pdb_hierarchy, log):
    from mmtbx.den import den_restraints
    if den_params.reference_file is not None:
      pdb_io_ref = iotbx.pdb.input(den_params.reference_file)
      pdb_hierarchy_ref = pdb_io_ref.construct_hierarchy()
      pdb_hierarchy_ref.atoms().reset_i_seq()
    else: #restrain model to starting coordinates
      pdb_hierarchy_ref = None
    den_manager = den_restraints(
      pdb_hierarchy=pdb_hierarchy,
      pdb_hierarchy_ref=pdb_hierarchy_ref,
      params=den_params,
      log=log)
    self.adopt_den_manager(den_manager)

  def adopt_den_manager(self, den_manager):
    self.den_manager = den_manager

  def get_n_den_proxies(self):
    if self.den_manager is not None:
      return self.den_manager.get_n_proixes()
    return 0

  def remove_chiralities_in_place(self, selection):
    self.chirality_proxies = self.chirality_proxies.proxy_remove(
      selection=selection)

  def add_planarities_in_place(self, additional_planarity_proxies):
    self.planarity_proxies.extend(additional_planarity_proxies)

  def remove_planarities_in_place(self, selection):
    self.planarity_proxies = self.planarity_proxies.proxy_remove(
      selection=selection)

  def add_parallelities_in_place(self, additional_parallelity_proxies):
    self.parallelity_proxies.extend(additional_parallelity_proxies)

  def remove_parallelities_in_place(self, selection):
    self.parallelity_proxies = self.parallelity_proxies.proxy_remove(
      selection=selection)

  #=================================================================
  # Ramachandran manager/proxies methods
  #=================================================================
  def set_ramachandran_restraints(self, manager):
    self.ramachandran_manager=manager

  def update_ramachandran_restraints_phi_psi_targets(self, hierarchy):
    if(self.ramachandran_manager is not None):
      self.ramachandran_manager.update_phi_psi_targets(hierarchy = hierarchy)

  def remove_ramachandran_in_place(self):
    self.ramachandran_manager = None

  def get_n_ramachandran_proxies(self):
    if self.ramachandran_manager is not None:
      return self.ramachandran_manager.get_n_proxies()
    return 0

  #=================================================================
  # Secondary structure manager/proxies methods
  #=================================================================
  def set_secondary_structure_restraints(self, ss_manager, hierarchy, log):
    (hb_proxies, hb_angle_proxies, planarity_proxies,
    parallelity_proxies) = ss_manager.create_all_new_restraints(
        pdb_hierarchy=hierarchy,
        grm=self,
        log=log)
    # print ('Total proxies:', len(hb_proxies))
    # for p in hb_proxies:
    #   print (p.i_seqs[0], p.i_seqs[1], hierarchy.atoms()[p.i_seqs[0]].id_str(), '<-->', hierarchy.atoms()[p.i_seqs[1]].id_str())
    #   print ("  ", hierarchy.atoms()[p.i_seqs[0]].distance(hierarchy.atoms()[p.i_seqs[1]]))
    self.add_new_hbond_restraints_in_place(
        proxies=hb_proxies,
        sites_cart=hierarchy.atoms().extract_xyz(),
        max_distance_between_connecting_atoms=10)
    self.add_angles_in_place(hb_angle_proxies)
    self.add_planarities_in_place(planarity_proxies)
    self.add_parallelities_in_place(parallelity_proxies)

  def remove_secondary_structure_restraints(self, sites_cart):
    bp_origin_id = origin_ids.get_origin_id('hydrogen bonds')
    bonds_to_remove = []
    for proxy_type in self.get_all_bond_proxies():
      for proxy in proxy_type:
        if proxy.origin_id == bp_origin_id:
          bonds_to_remove.append(proxy.i_seqs)
    self.remove_bond_restraints_in_place(
        bonded_pairs=bonds_to_remove,
        sites_cart=sites_cart)
    if self.angle_proxies is not None:
      self.angle_proxies = self.angle_proxies.proxy_remove(
          origin_id=origin_ids.get_origin_id('hydrogen bonds'))
    if self.planarity_proxies is not None:
      self.planarity_proxies = self.planarity_proxies.proxy_remove(
          origin_id=origin_ids.get_origin_id('basepair planarity'))
    if self.parallelity_proxies is not None:
      self.parallelity_proxies = self.parallelity_proxies.proxy_remove(
          origin_id=origin_ids.get_origin_id('basepair parallelity'))
    if self.parallelity_proxies is not None:
      self.parallelity_proxies = self.parallelity_proxies.proxy_remove(
          origin_id=origin_ids.get_origin_id('basepair stacking'))
    return None

  def add_parallelity_proxies_for_side_chain(self, hierarchy, log):
    parallelity_proxies = create_side_chain_restraints( hierarchy=hierarchy,
                                                        grm=self,
                                                        log=log)
    self.add_parallelities_in_place(parallelity_proxies)

  def set_external_energy_function(self, energy_function):
    self.external_energy_function = energy_function

  def _get_n_bond_proxies_origin(self, origin_id):
    pair_proxies = self.pair_proxies()
    if pair_proxies is not None:
      if pair_proxies.bond_proxies is not None:
        return len(pair_proxies.bond_proxies.simple.proxy_select(origin_id=origin_id))+\
            len(pair_proxies.bond_proxies.asu.proxy_select(origin_id=origin_id))
    return 0

  def get_n_bond_proxies(self):
    specific_origin_id = origin_ids.get_origin_id('covalent geometry')
    return self._get_n_bond_proxies_origin(origin_id=specific_origin_id)

  def get_covalent_bond_proxies(self, sites_cart=None):
    specific_origin_id = origin_ids.get_origin_id('covalent geometry')
    pair_proxies = self.pair_proxies(sites_cart=sites_cart)
    if pair_proxies is not None:
      if pair_proxies.bond_proxies is not None:
        return (pair_proxies.bond_proxies.simple.proxy_select(
          origin_id=specific_origin_id),
        pair_proxies.bond_proxies.asu.proxy_select(
          origin_id=specific_origin_id))

  def get_all_bond_proxies(self, sites_cart=None):
    pair_proxies = self.pair_proxies(sites_cart=sites_cart)
    if pair_proxies is not None:
      if pair_proxies.bond_proxies is not None:
        return (pair_proxies.bond_proxies.simple,
                pair_proxies.bond_proxies.asu)

  def get_covalent_angle_proxies(self):
    specific_origin_id = origin_ids.get_origin_id('covalent geometry')
    return self.angle_proxies.proxy_select(origin_id=specific_origin_id)

  def get_all_angle_proxies(self):
    return self.angle_proxies

  def get_n_hbond_proxies(self):
    specific_origin_id = origin_ids.get_origin_id('hydrogen bonds')
    return self._get_n_bond_proxies_origin(origin_id=specific_origin_id)

  def get_n_angle_proxies(self):
    specific_origin_id = origin_ids.get_origin_id('covalent geometry')
    return len(self.angle_proxies.proxy_select(origin_id=specific_origin_id))

  def get_n_hangle_proxies(self):
    specific_origin_id = origin_ids.get_origin_id('hydrogen bonds')
    return len(self.angle_proxies.proxy_select(origin_id=specific_origin_id))

  def get_n_stacking_proxies(self):
    specific_origin_id = origin_ids.get_origin_id('basepair stacking')
    return len(self.parallelity_proxies.proxy_select(
      origin_id=specific_origin_id))

  def get_n_parallelity_bp_proxies(self):
    specific_origin_id = origin_ids.get_origin_id('basepair parallelity')
    return len(self.parallelity_proxies.proxy_select(
      origin_id=specific_origin_id))

  def get_n_planarity_proxies(self):
    specific_origin_id = origin_ids.get_origin_id('covalent geometry')
    return len(self.planarity_proxies.proxy_select(
      origin_id=specific_origin_id))

  def get_n_planarity_bp_proxies(self):
    specific_origin_id = origin_ids.get_origin_id('basepair planarity')
    return len(self.planarity_proxies.proxy_select(
      origin_id=specific_origin_id))

  def get_hbond_proxies_iseqs(self):
    specific_origin_id = origin_ids.get_origin_id('hydrogen bonds')
    result = []
    try:
      pair_proxies = self.pair_proxies()
    except AssertionError as e:
      # This is in case when somebody tries to access hbonds when
      # grm is not ready. See e.g. phenix/refinement/runtime.py
      # class refinement_status, grm.get_hbond_proxies_iseqs()
      if "pair_proxies not defined already." in e.args:
        return result
      else:
        raise
    if pair_proxies is not None:
      if pair_proxies.bond_proxies is not None:
        simple_p = pair_proxies.bond_proxies.simple.proxy_select(
          origin_id=specific_origin_id)
        asu_p = pair_proxies.bond_proxies.asu.proxy_select(
          origin_id=specific_origin_id)
        for p in simple_p:
          result.append((p.i_seqs[0], p.i_seqs[1]))
        for p in asu_p:
          result.append((p.i_seq, p.j_seq))
    return result

  def new_included_bonded_atoms(self, proxies, sites_cart,
      site_symmetry_table, nonbonded_types, nonbonded_charges,
      max_distance_between_connecting_atoms=5,
      skip_max_proxy_distance_calculation=False):

    """ Produce new geometry_restraints_manager object that will
    include new atoms each with exactly one bond to the existing atom.
    proxies - list of bond_proxy objects. Symmetry operation will be determined
    automatically, so proxy.rt_mx_ji is ignored.
    Essentially this function wraps self.new_including_isolated_sites() and
    self.add_new_bond_restraints_in_place().
    sites_cart should contain all coordinates, for old and new atoms. new
      coordinates should follow old ones and the order should be consistent
      with i_seqs mentioned in proxy objects.
    site_symmetry_table - table only for new atoms
    nonbonded_types - only for new atoms
    nonbonded_charges - only for new atoms."""

    number_of_new_atoms = len(proxies)

    assert site_symmetry_table.indices().size() == number_of_new_atoms
    assert len(nonbonded_types) == number_of_new_atoms
    assert len(nonbonded_charges) == number_of_new_atoms

    if (self.model_indices is None):
      model_indices = None
    else:
      model_indices = flex.size_t(number_of_new_atoms, 0)
    if (self.conformer_indices is None):
      conformer_indices = None
    else:
      conformer_indices = flex.size_t(number_of_new_atoms, 0)
    if (self.sym_excl_indices is None):
      sym_excl_indices = None
    else:
      sym_excl_indices = flex.size_t(number_of_new_atoms, 0)
    if (self.donor_acceptor_excl_groups is None):
      donor_acceptor_excl_groups = None
    else:
      donor_acceptor_excl_groups = flex.size_t(number_of_new_atoms, 0)
    new_grm = self.new_including_isolated_sites(
        n_additional_sites =number_of_new_atoms,
        model_indices=model_indices,
        conformer_indices=conformer_indices,
        sym_excl_indices=sym_excl_indices,
        donor_acceptor_excl_groups=donor_acceptor_excl_groups,
        site_symmetry_table=site_symmetry_table,
        nonbonded_types=nonbonded_types,
        nonbonded_charges=nonbonded_charges)
    sites_frac = self.crystal_symmetry.unit_cell().\
        fractionalize(sites_cart=sites_cart)
    new_grm.update_plain_pair_sym_table(sites_frac)
    new_grm.add_new_bond_restraints_in_place(proxies, sites_cart,
      max_distance_between_connecting_atoms=max_distance_between_connecting_atoms,
      skip_max_proxy_distance_calculation=skip_max_proxy_distance_calculation)
    new_grm.set_source(source = self.get_source())
    return new_grm

  def add_new_hbond_restraints_in_place(self, proxies, sites_cart,
      max_distance_between_connecting_atoms=5,
      skip_max_proxy_distance_calculation=False):
    self.add_new_bond_restraints_in_place(proxies, sites_cart,
        max_distance_between_connecting_atoms,
        skip_max_proxy_distance_calculation)

  def add_new_bond_restraints_in_place(self, proxies, sites_cart,
      max_distance_between_connecting_atoms=5,
      skip_max_proxy_distance_calculation=False):
    """ Add new bond restraints for list of proxies to this
    geometry restraints manager, _in_place_! Returns nothing.
    proxies - list of bond_proxy objects. The symmetry operation for the
    paired atoms is determined here, therefore the proxy.rt_mx_ji may be
    anything."""
    import time
    if len(proxies) == 0:
      return
    rt_mx_ji_options = [[] for x in proxies]
    # Get current max bond distance, copied from pair_proxies()
    t0 = time.time()
    bonded_distance_cutoff = max_distance_between_connecting_atoms
    sites_frac = self.crystal_symmetry.unit_cell().\
        fractionalize(sites_cart=sites_cart)
    existing_max_bonded_distance = 0
    for shell_sym_table in self.shell_sym_tables:
      existing_max_bonded_distance = flex.max_default(
              values=crystal.get_distances(
                  pair_sym_table=shell_sym_table,
                  orthogonalization_matrix=self.crystal_symmetry.unit_cell() \
                      .orthogonalization_matrix(),
                  sites_frac=sites_frac),
              default=0)
    t1 = time.time()
    max_p_distance=0
    if not skip_max_proxy_distance_calculation:
      for p in proxies:
        distance_model = geometry_restraints.bond(
            [sites_cart[p.i_seqs[0]],sites_cart[p.i_seqs[1]]],
            distance_ideal=0,
            weight=1).distance_model
        if distance_model > max_p_distance:
          max_p_distance = distance_model
      bonded_distance_cutoff = max(bonded_distance_cutoff,
          max_p_distance)
    bonded_distance_cutoff = min(bonded_distance_cutoff,
        max_distance_between_connecting_atoms)+0.1
    bonded_distance_cutoff = max(bonded_distance_cutoff,
        existing_max_bonded_distance)
    t2 = time.time()
    # print("bonded_distance_cutoff", bonded_distance_cutoff)
    # make asu mappings
    all_asu_mappings = self.crystal_symmetry.special_position_settings().\
        asu_mappings(buffer_thickness=bonded_distance_cutoff)
    all_asu_mappings.process_sites_cart(
      original_sites=sites_cart,
      site_symmetry_table=self.site_symmetry_table)
    # Add all previously defined bonds
    all_bonds_asu_table = crystal.pair_asu_table(asu_mappings=all_asu_mappings)
    all_bonds_asu_table.add_pair_sym_table(self.shell_sym_tables[0])

    t3 = time.time()
    proxies_i_seqs = {}
    proxies_iselection = []
    for np, p in enumerate(proxies):
      # print('p iseqs', p.i_seqs)
      proxies_i_seqs[p.i_seqs] = np
      proxies_i_seqs[(p.i_seqs[1], p.i_seqs[0])] = np
      for i in list(p.i_seqs):
        if i not in proxies_iselection:
          proxies_iselection.append(i)
    # Not sure whether we want to sort it...
    # proxies_iselection = flex.size_t(sorted(proxies_iselection))
    # print('proxies_i_seqs', proxies_i_seqs)
    proxies_iselection = flex.size_t(proxies_iselection)
    t4 = time.time()

    # Generate pairs for connecting atoms only - should be much faster then
    # doing the same for all atoms in geometry_restraints_manager.
    # Note, that this will generate not only useful pairs but all pairs
    # within bonded_distance_cutoff cutoff. Therefore
    # later we will filter them.
    conn_asu_mappings = self.crystal_symmetry.special_position_settings().\
      asu_mappings(buffer_thickness=bonded_distance_cutoff)
    connecting_sites_cart = sites_cart.select(proxies_iselection)
    conn_site_symmetry_table = self.site_symmetry_table.select(
        proxies_iselection)
    conn_asu_mappings.process_sites_cart(
        original_sites=connecting_sites_cart,
        site_symmetry_table=conn_site_symmetry_table)
    conn_pair_asu_table = crystal.pair_asu_table(
        asu_mappings=conn_asu_mappings)
    conn_pair_asu_table.add_all_pairs(
        distance_cutoff=bonded_distance_cutoff)
    pair_generator = crystal.neighbors_fast_pair_generator(
        conn_asu_mappings,
        distance_cutoff=bonded_distance_cutoff)

    t5 = time.time()
    # r_a connects i_seqs in pair_generator with original i_seqs
    r_a = list(reindexing_array(len(sites_cart), proxies_iselection.as_int()))
    r_a_index = [0]*(len(sites_cart)+1)
    for index, value in enumerate(r_a):
      r_a_index[value] = index
    n_added_proxies = 0
    for pair in pair_generator:
      # !!! Warning !!! pairs here may come reverted: (32,24) and (24,32) and
      # they may result in different rt_mx_ji. Therefore in the next for cycle
      # we need to make sure we are picking correct rt_mx_ji
      pair_in_origninal_indeces = (r_a_index[pair.i_seq], r_a_index[pair.j_seq])
      n_proxy = None
      # Is this pair should be restrained?
      try:
        n_proxy = proxies_i_seqs.get(pair_in_origninal_indeces, None)
      except ValueError:
        # there is no proxy for this pair, so we will not make a bond for it
        continue
      if n_proxy is None:
        continue
      # Sanity check (not necessary because of 'continue' in previous line)
      # print "  n_proxy", n_proxy
      if n_proxy is not None:
        # print("Adding to options,", n_proxy, rt_mx_ji_options)
        #Trying to find rt_mx_ji for connecting atoms
        rt_mx_i = conn_asu_mappings.get_rt_mx_i(pair)
        rt_mx_j = conn_asu_mappings.get_rt_mx_j(pair)
        rt_mx_ji = rt_mx_i.inverse().multiply(rt_mx_j)
        rt_mx_ji_options[n_proxy].append(rt_mx_ji)
        # print("  pair:",  pair.i_seq, pair.j_seq, "n_proxy ", n_proxy,rt_mx_ji)
    # print ("rt_mx_ji_options:", rt_mx_ji_options)
    # for i, opts in enumerate(rt_mx_ji_options):
    #   print("  ",i,' ', end='')
    #   for o in opts:
    #     print(o,",", end='')
    #   print()
    # print()
    # print("STARTING TO PICK rt_mx_ji for proxies")
    for proxy, rt_mx_ji_option in zip(proxies, rt_mx_ji_options):
      # print("rt_mx_ji_options:",end='')
      # for op in rt_mx_ji_option:
      #   print (op,' | ' , end='')
      # print()
      # print("  choose rt_mx_ji")
      rt_mx_ji = None
      if len(rt_mx_ji_option) == 1:
        rt_mx_ji = rt_mx_ji_option[0]
      if len(rt_mx_ji_option) > 1:
        # search for unit mx or pick the first one
        for rmj in rt_mx_ji_option:
          if rmj.is_unit_mx():
            rt_mx_ji = rmj
        if rt_mx_ji is None:
          # no unit mx found and we have >1 options, need to pick correct one
          for rmj in rt_mx_ji_option:
            t_rt_mx_i = all_asu_mappings.get_rt_mx(proxy.i_seqs[0], 0)
            t_rt_mx_j = t_rt_mx_i.multiply(rmj)
            j_sym = all_asu_mappings.find_i_sym(proxy.i_seqs[1], t_rt_mx_j)
            # print('checking j_sym', j_sym, proxy.i_seqs[0], proxy.i_seqs[1])
            if j_sym >= 0:
              rt_mx_ji = rmj
      # Add new defined bond
      # print ("  chosen rt_mx_ji", rt_mx_ji)
      if rt_mx_ji is not None:
        # print("  Adding new bond:", proxy.i_seqs[0], proxy.i_seqs[1], rt_mx_ji)
        all_bonds_asu_table.add_pair(
          i_seq=proxy.i_seqs[0],
          j_seq=proxy.i_seqs[1],
          rt_mx_ji=rt_mx_ji)
        # Update with new bond
        self.bond_params_table.update(
            i_seq=proxy.i_seqs[0],
            j_seq=proxy.i_seqs[1],
            params=geometry_restraints.bond_params(
                distance_ideal = proxy.distance_ideal,
                weight         = proxy.weight,
                slack          = proxy.slack,
                limit          = proxy.limit,
                top_out        = proxy.top_out,
                origin_id      = proxy.origin_id)
            )
        n_added_proxies += 1
    t6 = time.time()
    # print('n_added_proxies', n_added_proxies)
    # update self.shell_sym_tables with new bonds
    shell_asu_tables = crystal.coordination_sequences.shell_asu_tables(
      pair_asu_table=all_bonds_asu_table,
      max_shell=3)
    self.shell_sym_tables = [shell_asu_table.extract_pair_sym_table()
      for shell_asu_table in shell_asu_tables]
    self.reset_internals()
    # Run this function so that new pair_proxies are ready to go
    t61 = time.time()
    self.pair_proxies(sites_cart=sites_cart)
    t7 = time.time()
    # print "times in add_new_bond_restraints_in_place:"
    # print "t1: %f" % (t1-t0)
    # print "t2: %f" % (t2-t1)
    # print "t3: %f" % (t3-t2)
    # print "t4: %f" % (t4-t3)
    # print "t5: %f" % (t5-t4)
    # print "t6: %f" % (t6-t5)
    # print "t61: %f" % (t61-t6)
    # print "t7: %f" % (t7-t61)
    # STOP()

  def remove_bond_restraints_in_place(self, bonded_pairs, sites_cart):
    """ Removing bond restraints in place.
    Current limitations:
      * symmetry related cases (1' means symmetry mate of 1):
        -: 2' --- 1 --- 2
        -: 1' --- 1

    Args:
        bonded_pairs (list): list of bonded i_seqs to remove bonds, e.g.
        [(0,1), (5,15)] for bonds between atoms 0--1 and 5--15 to be removed.
    """
    def _show_bpt(bpt):
      print('bpt size:', bpt.size())
      for i_seq in range(bpt.size()):
        print('i_seq', i_seq)
        d = bpt[i_seq]
        for k in d.keys():
          print('  j_seq: %d, %f' % (k, d[k].distance_ideal))

    # print("1-2,"*30)
    # print('BEGIN shell_sym_tables[0]')
    # self.shell_sym_tables[0].show()
    filtered_bonded_pairs = [sorted(x) for x in bonded_pairs if self.is_bonded_atoms(x[0], x[1])]
    # print("Original BPT")
    # _show_bpt(self.bond_params_table)

    # Removing bonds from self.shell_sym_tables
    asu_mappings = self.crystal_symmetry.special_position_settings().\
        asu_mappings(buffer_thickness=5)
    asu_mappings.process_sites_cart(
        original_sites=sites_cart,
        site_symmetry_table=self.site_symmetry_table)

    pair_asu_table = crystal.pair_asu_table(asu_mappings=asu_mappings)
    for i, j in filtered_bonded_pairs:
      del self.shell_sym_tables[0][i][j]
    pair_asu_table.add_pair_sym_table(self.shell_sym_tables[0])
    shell_asu_tables = crystal.coordination_sequences.shell_asu_tables(
      pair_asu_table=pair_asu_table,
      max_shell=3)
    self.shell_sym_tables = [shell_asu_table.extract_pair_sym_table()
      for shell_asu_table in shell_asu_tables]

    self.reset_internals()
    self.pair_proxies(sites_cart=sites_cart)

  def is_bonded_atoms(self, i_seq, j_seq):
    i_s = i_seq
    j_s = j_seq
    if i_seq > j_seq:
      i_s = j_seq
      j_s = i_seq
    return j_s in self.shell_sym_tables[0][i_s].keys()

  def pair_proxies(self,
        sites_cart=None,
        flags=None,
        asu_is_inside_epsilon=None,
        bonded_distance_cutoff_epsilon=None,
        site_labels=None):
    if (bonded_distance_cutoff_epsilon is None):
      bonded_distance_cutoff_epsilon = 1.e-6
    if (self.crystal_symmetry is None):
      orthogonalization_matrix = None
    else:
      orthogonalization_matrix = self.crystal_symmetry.unit_cell() \
        .orthogonalization_matrix()
    bonded_distance_cutoff = -1
    def check_bonded_distance_cutoff(sites_frac=None, sites_cart=None):
      if (    self.max_reasonable_bond_distance is not None
          and bonded_distance_cutoff > self.max_reasonable_bond_distance):
        lines = format_distances_for_error_message(
          pair_sym_table=self.shell_sym_tables[0],
          larger_than=3,
          orthogonalization_matrix=orthogonalization_matrix,
          sites_frac=sites_frac,
          sites_cart=sites_cart,
          site_labels=site_labels)
        msg = "Bond distance > max_reasonable_bond_distance: %.6g > %.6g" % (
          bonded_distance_cutoff, self.max_reasonable_bond_distance)
        if (len(lines) != 0):
          msg += ":\n  "
          msg += "\n  ".join(lines)
        raise RuntimeError(msg)
    def flags_are_different():
      if (flags is None):
        if (not self._flags_bond_used_for_pair_proxies):
          return True
        if (not self._flags_nonbonded_used_for_pair_proxies):
          return True
      else:
        if (self._flags_bond_used_for_pair_proxies != flags.bond):
          return True
        if (self._flags_nonbonded_used_for_pair_proxies != flags.nonbonded):
          return True
      return False
    if (self.nonbonded_types is None):
      if (    self._pair_proxies is None
          and self.shell_sym_tables is not None
          and self.crystal_symmetry is not None
          and self.site_symmetry_table is not None):
        unit_cell = self.crystal_symmetry.unit_cell()
        sites_frac = unit_cell.fractionalize(sites_cart=sites_cart)
        for shell_sym_table in self.shell_sym_tables:
          bonded_distance_cutoff = max(bonded_distance_cutoff,
            flex.max_default(
              values=crystal.get_distances(
                pair_sym_table=shell_sym_table,
                orthogonalization_matrix=orthogonalization_matrix,
                sites_frac=sites_frac),
              default=0))
        check_bonded_distance_cutoff(sites_frac=sites_frac)
        bonded_distance_cutoff *= (1 + bonded_distance_cutoff_epsilon)
        asu_mappings = crystal.symmetry.asu_mappings(self.crystal_symmetry,
          buffer_thickness=bonded_distance_cutoff,
          asu_is_inside_epsilon=asu_is_inside_epsilon)
        asu_mappings.process_sites_frac(
          original_sites=sites_frac,
          site_symmetry_table=self.site_symmetry_table)
        shell_asu_tables = None
        shell_asu_tables = [
          crystal.pair_asu_table(asu_mappings=asu_mappings)
          .add_pair_sym_table(sym_table=shell_sym_table)
          for shell_sym_table in self.shell_sym_tables]
        self.n_updates_pair_proxies += 1
        self._pair_proxies = geometry_restraints.pair_proxies(
          flags=flags,
          bond_params_table=self.bond_params_table,
          min_cubicle_edge=self.min_cubicle_edge,
          shell_asu_tables=shell_asu_tables)
      elif (self._pair_proxies is None):
        self.n_updates_pair_proxies += 1
        self._pair_proxies = geometry_restraints.pair_proxies(
          flags=flags,
          bond_params_table=self.bond_params_table,
          min_cubicle_edge=self.min_cubicle_edge)
    elif (sites_cart is not None
            and (self._sites_cart_used_for_pair_proxies is None
              or flags_are_different()
              or self._sites_cart_used_for_pair_proxies.max_distance(
                sites_cart) > self.effective_nonbonded_buffer)):
      self.n_updates_pair_proxies += 1
      self._sites_cart_used_for_pair_proxies = sites_cart.deep_copy()
      if (flags is None):
        self._flags_bond_used_for_pair_proxies = True
        self._flags_nonbonded_used_for_pair_proxies = True
      else:
        self._flags_bond_used_for_pair_proxies = flags.bond
        self._flags_nonbonded_used_for_pair_proxies = flags.nonbonded
      bonded_distance_cutoff = -1
      if (self.nonbonded_distance_cutoff is None):
        max_vdw_dist = self.nonbonded_params.find_max_vdw_distance(
          nonbonded_types=self.nonbonded_types)
        assert max_vdw_dist > 0
        r = self.nonbonded_function.residual(
          vdw_distance=max_vdw_dist, delta=max_vdw_dist*(1+1.e-6))
        if (r != 0):
          raise RuntimeError(
            "Cannot automatically determine nonbonded_distance_cutoff:"
            " nonbonded_function.residual() not zero beyond maximum VDW"
            " distance.")
        self.nonbonded_distance_cutoff_was_determined_automatically = True
        self.nonbonded_distance_cutoff = max_vdw_dist
        self.adjusted_nonbonded_distance_cutoff = max_vdw_dist
      asu_mappings = None
      shell_asu_tables = None
      while True:
        current_nonbonded_distance_cutoff_plus_buffer \
          = self.adjusted_nonbonded_distance_cutoff \
          + self.nonbonded_buffer
        if (self.crystal_symmetry is None):
          if (bonded_distance_cutoff < 0):
            for shell_sym_table in self.shell_sym_tables:
              bonded_distance_cutoff = max(bonded_distance_cutoff,
                flex.max_default(
                  values=crystal.get_distances(
                    pair_sym_table=shell_sym_table,
                    sites_cart=sites_cart),
                  default=0))
            check_bonded_distance_cutoff(sites_cart=sites_cart)
            bonded_distance_cutoff *= (1 + bonded_distance_cutoff_epsilon)
            asu_mappings = \
              crystal.direct_space_asu.non_crystallographic_asu_mappings(
                sites_cart=sites_cart,
                min_unit_cell_length=
                  2*current_nonbonded_distance_cutoff_plus_buffer)
        else:
          if (   bonded_distance_cutoff < 0
              or self.plain_pairs_radius is not None):
            unit_cell = self.crystal_symmetry.unit_cell()
            sites_frac = unit_cell.fractionalize(sites_cart=sites_cart)
          if (self.plain_pairs_radius is not None):
            self.update_plain_pair_sym_table(sites_frac=sites_frac)
          if (bonded_distance_cutoff < 0):
            for shell_sym_table in self.shell_sym_tables:
              bonded_distance_cutoff = max(bonded_distance_cutoff,
                flex.max_default(
                  values=crystal.get_distances(
                    pair_sym_table=shell_sym_table,
                    orthogonalization_matrix=orthogonalization_matrix,
                    sites_frac=sites_frac),
                  default=0))
            check_bonded_distance_cutoff(sites_frac=sites_frac)
            bonded_distance_cutoff *= (1 + bonded_distance_cutoff_epsilon)
          if (asu_mappings is None
              or asu_mappings.buffer_thickness()
                 < current_nonbonded_distance_cutoff_plus_buffer):
            asu_mappings = crystal.symmetry.asu_mappings(self.crystal_symmetry,
              buffer_thickness=max(
                bonded_distance_cutoff,
                current_nonbonded_distance_cutoff_plus_buffer),
              asu_is_inside_epsilon=asu_is_inside_epsilon)
            asu_mappings.process_sites_frac(
              original_sites=sites_frac,
              site_symmetry_table=self.site_symmetry_table)
            shell_asu_tables = None
        if (shell_asu_tables is None):
          shell_asu_tables = [
            crystal.pair_asu_table(asu_mappings=asu_mappings)
              .add_pair_sym_table(sym_table=shell_sym_table)
                for shell_sym_table in self.shell_sym_tables]
        self._pair_proxies = geometry_restraints.pair_proxies(
          flags=flags,
          bond_params_table=self.bond_params_table,
          shell_asu_tables=shell_asu_tables,
          model_indices=self.model_indices,
          conformer_indices=self.conformer_indices,
          sym_excl_indices=self.sym_excl_indices,
          donor_acceptor_excl_groups=self.donor_acceptor_excl_groups,
          nonbonded_params=self.nonbonded_params,
          nonbonded_types=self.nonbonded_types,
          nonbonded_charges=self.nonbonded_charges,
          nonbonded_distance_cutoff_plus_buffer
            =current_nonbonded_distance_cutoff_plus_buffer,
          min_cubicle_edge=self.min_cubicle_edge)
        introspection.virtual_memory_info().update_max()
        if (self._pair_proxies.nonbonded_proxies is None):
          break
        max_vdw_dist = self._pair_proxies.nonbonded_proxies.max_vdw_distance
        if (max_vdw_dist <= 0):
          break
        r = self.nonbonded_function.residual(
          vdw_distance=max_vdw_dist, delta=max_vdw_dist*(1+1.e-6))
        if (r != 0):
          break
        if (self.nonbonded_distance_cutoff < max_vdw_dist):
          if (self.nonbonded_distance_cutoff_was_determined_automatically):
            raise AssertionError("Internal error.")
          raise Sorry(
            "nonbonded_distance_cutoff=%.6g is too small:"
            " max_vdw_distance=%.6g" % (
              self.nonbonded_distance_cutoff,
              max_vdw_dist))
        self.adjusted_nonbonded_distance_cutoff = max_vdw_dist
        self.effective_nonbonded_buffer \
          = current_nonbonded_distance_cutoff_plus_buffer \
          - self.adjusted_nonbonded_distance_cutoff
        if (self.effective_nonbonded_buffer > bonded_distance_cutoff_epsilon):
          break
        self.adjusted_nonbonded_distance_cutoff \
          = self.nonbonded_distance_cutoff
    elif (self._pair_proxies is None):
      raise AssertionError("pair_proxies not defined already.")
    return self._pair_proxies

  def nonbonded_model_distances(self, sites_cart=None):
    pair_proxies = self.pair_proxies(sites_cart=sites_cart)
    if (sites_cart is None):
      sites_cart = self._sites_cart_used_for_pair_proxies
    return pair_proxies.nonbonded_proxies.deltas(sites_cart=sites_cart)

  def update_plain_pair_sym_table(self, sites_frac):
    asu_mappings = crystal.symmetry.asu_mappings(self.crystal_symmetry,
      buffer_thickness=self.plain_pairs_radius)
    asu_mappings.process_sites_frac(
      original_sites=sites_frac,
      site_symmetry_table=self.site_symmetry_table)
    pair_asu_table = crystal.pair_asu_table(asu_mappings=asu_mappings)
    pair_asu_table.add_all_pairs(distance_cutoff=self.plain_pairs_radius)
    self.plain_pair_sym_table=pair_asu_table.extract_pair_sym_table()
    introspection.virtual_memory_info().update_max()

  def energies_sites(self,
        sites_cart,
        flags=None,
        custom_nonbonded_function=None,
        compute_gradients=False,
        gradients=None,
        disable_asu_cache=False,
        normalization=False,
        external_energy_function=None,
        extension_objects=[],
        site_labels=None):
    if(external_energy_function is not None):
      assert self.external_energy_function is None
    else:
      external_energy_function = self.external_energy_function
    if (flags is None):
      flags = geometry_restraints.flags.flags(default=True)
    pair_proxies = self.pair_proxies(
      flags=flags, sites_cart=sites_cart, site_labels=site_labels)
    (bond_proxies,
     nonbonded_proxies,
     nonbonded_function,
     angle_proxies,
     dihedral_proxies,
     reference_coordinate_proxies,
     reference_dihedral_manager,
     ncs_dihedral_manager,
     den_manager,
     chirality_proxies,
     planarity_proxies,
     parallelity_proxies,
     ramachandran_manager) = [None]*13
    if (flags.bond):
      assert pair_proxies.bond_proxies is not None
      bond_proxies = pair_proxies.bond_proxies
    if (flags.nonbonded and self.nonbonded_types is not None):
      assert pair_proxies.nonbonded_proxies is not None
      nonbonded_proxies = pair_proxies.nonbonded_proxies
      if (custom_nonbonded_function is None):
        nonbonded_function = self.nonbonded_function
      else:
        nonbonded_function = custom_nonbonded_function
    if (flags.angle):     angle_proxies = self.angle_proxies
    if (flags.dihedral):  dihedral_proxies = self.dihedral_proxies
    if flags.reference_coordinate:
      reference_coordinate_proxies = self.reference_coordinate_proxies
    if (flags.reference_dihedral):
      reference_dihedral_manager = self.reference_dihedral_manager
    if (flags.ncs_dihedral): ncs_dihedral_manager = self.ncs_dihedral_manager
    if flags.den_restraints: den_manager = self.den_manager
    if (flags.chirality): chirality_proxies = self.chirality_proxies
    if (flags.planarity): planarity_proxies = self.planarity_proxies
    if (flags.parallelity): parallelity_proxies = self.parallelity_proxies
    if flags.ramachandran_restraints:
      ramachandran_manager = self.ramachandran_manager
    return geometry_restraints.energies.energies(
      sites_cart=sites_cart,
      bond_proxies=bond_proxies,
      nonbonded_proxies=nonbonded_proxies,
      nonbonded_function=nonbonded_function,
      angle_proxies=angle_proxies,
      dihedral_proxies=dihedral_proxies,
      reference_coordinate_proxies=reference_coordinate_proxies,
      reference_dihedral_manager=reference_dihedral_manager,
      ncs_dihedral_manager=ncs_dihedral_manager,
      den_manager=den_manager,
      chirality_proxies=chirality_proxies,
      planarity_proxies=planarity_proxies,
      parallelity_proxies=parallelity_proxies,
      ramachandran_manager = ramachandran_manager,
      external_energy_function=external_energy_function,
      compute_gradients=compute_gradients,
      gradients=gradients,
      disable_asu_cache=disable_asu_cache,
      normalization=normalization,
      extension_objects=extension_objects)

  def harmonic_restraints(self, variables, type_indices, type_weights):
    assert self.shell_sym_tables is not None
    assert len(self.shell_sym_tables) > 0
    assert variables.size() == self.shell_sym_tables[0].size()
    residual_sum = 0
    gradients = flex.double(variables.size(), 0)
    for pair in self.shell_sym_tables[0].iterator():
      i,j = pair.i_seqs()
      if (type_indices is None):
        weight = type_weights
      else:
        weight = (  type_weights[type_indices[i]]
                  + type_weights[type_indices[j]]) * 0.5
      delta = variables[i] - variables[j]
      term = weight * delta
      residual_sum += term * delta
      gradients[i] += term * 2
      gradients[j] -= term * 2
    return store(residual_sum=residual_sum, gradients=gradients)

  def ta_harmonic_restraints(self, sites_cart, ta_harmonic_restraint_info, weight = 0.001, slack = 0.5):

    def delta(site1,
              site2):
      delta = math.sqrt(((site1[0]-site2[0])**2) + ((site1[1]-site2[1])**2) + ((site1[2]-site2[2])**2))
      if slack > 0:
        if (delta > self.ta_slack):
          delta_slack = delta - slack
        else:
          delta_slack = 0.0
      else: delta_slack = delta
      return delta, delta_slack

    def residual(distance):
      residual = self.ta_harmonic_weight * distance**2
      return residual

    def gradient(site,
                 ref_site,
                 distance_slack,
                 distance):
      site_delta = ((site[0]-ref_site[0]),(site[1]-ref_site[1]),(site[2]-ref_site[2]))
      if self.ta_slack > 0.0:
        if distance < self.ta_slack:
          return (0.0,0.0,0.0)
      gradient = (self.ta_harmonic_weight * 2.0 * distance_slack * site_delta[0],
                  self.ta_harmonic_weight * 2.0 * distance_slack * site_delta[1],
                  self.ta_harmonic_weight * 2.0 * distance_slack * site_delta[2])
      return gradient

    self.ta_harmonic_weight = weight
    self.ta_slack = slack
    gradients = flex.vec3_double(sites_cart.size(), (0,0,0))
    residuals = flex.double(sites_cart.size(), 0)
    for x in ta_harmonic_restraint_info:
      distance, distance_slack = delta(x[1],sites_cart[x[0]])
      residuals[x[0]] = residual(distance = distance)
      gradients[x[0]] = gradient(distance       = distance,
                                 distance_slack = distance_slack,
                                 site           = sites_cart[x[0]],
                                 ref_site       = x[1])
    return gradients

  def update_atom_nonbonded_type(self,
        i_seq,
        nonbonded_type,
        charge=0):
    if (self.nonbonded_types is not None):
      self.nonbonded_types[i_seq] = nonbonded_type
    if (self.nonbonded_charges is not None):
      self.nonbonded_charges[i_seq] = charge

  def write_geo_file(self,
      sites_cart=None,
      site_labels=None,
      file_name=None,
      file_descriptor=sys.stdout,
      header="# Geometry restraints\n"):
    outf_descriptor = None
    if file_name is None:
      outf_descriptor = file_descriptor
    else:
      outf_descriptor = open(file_name, "w")
    print(header, file=outf_descriptor)
    self.show_sorted(
      sites_cart=sites_cart,
      site_labels=site_labels,
      f=outf_descriptor)
    if file_name is not None:
      outf_descriptor.close()

  def show_sorted(self,
        flags=None,
        sites_cart=None,
        site_labels=None,
        f=None):
    from cctbx.geometry_restraints.auto_linking_types import covalent_headers
    from cctbx.geometry_restraints.auto_linking_types import internal_labels
    covalent_key = 'covalent geometry'
    default_origin_id = origin_ids.get_origin_id(covalent_key)
    if (f is None): f = sys.stdout
    pair_proxies = self.pair_proxies(flags=flags, sites_cart=sites_cart)
    if (sites_cart is None):
      sites_cart = self._sites_cart_used_for_pair_proxies

    if pair_proxies.bond_proxies is not None:
      #
      # write covalent bonds
      #
      label='%s | %s |' % (covalent_headers[0], covalent_key)
      tempbuffer = StringIO()
      pair_proxies.bond_proxies.show_sorted(
          by_value="residual",
          sites_cart=sites_cart,
          site_labels=site_labels,
          f=tempbuffer,
          origin_id=default_origin_id)
      if tempbuffer.getvalue().find(': 0')==-1:
        print(label, tempbuffer.getvalue()[5:], file=f)
      #
      # write bonds with other origin_id
      #
      label=covalent_headers[0]
      for key in origin_ids.get_bond_origin_id_labels():
        origin_id=origin_ids.get_origin_id(key)
        if origin_id==default_origin_id: continue
        t_label=origin_ids.get_geo_file_header(key)
        tempbuffer = StringIO()
        pair_proxies.bond_proxies.show_sorted(
            by_value="residual",
            sites_cart=sites_cart,
            site_labels=site_labels,
            f=tempbuffer,
            prefix="",
            origin_id=origin_id)
        if tempbuffer.getvalue().find(': 0')==-1:
          print('%s | %s |' % (label, t_label), tempbuffer.getvalue()[5:], file=f)
    #
    # write of the other internals for each origin_id
    #
    for i, (proxies, keys, start) in enumerate([
      (
       self.angle_proxies, # self.get_all_angle_proxies(),
       origin_ids.get_angle_origin_id_labels(),
       11),
      (
       self.dihedral_proxies, # self.get_dihedral_proxies(),
       origin_ids.get_dihedral_origin_id_labels(),
       15),
      (
       self.chirality_proxies,
       origin_ids.get_chiral_origin_id_labels(),
       10),
      (
       self.planarity_proxies,
       origin_ids.get_plane_origin_id_labels(),
       10),
      (
       self.parallelity_proxies,
       origin_ids.get_parallelity_origin_id_labels(),
       12),
      ]):
      p_label=covalent_headers[i+1]
      internals=internal_labels[i+1]
      if (proxies is not None):
        #
        # "covalent" original ids
        #
        if p_label not in ['Parallelity']: # not default origin for parallelity
          tempbuffer = StringIO()
          proxies.show_sorted(
            by_value="residual",
            sites_cart=sites_cart,
            site_labels=site_labels,
            f=tempbuffer,
            origin_id=default_origin_id)
          print('%s | %s | %s' % (tempbuffer.getvalue()[:start-1],
                                  covalent_key,
                                  tempbuffer.getvalue()[start:]),
                file=f)
        #
        # other origin ids
        #
        for key in keys:
          origin_id=origin_ids.get_origin_id(key)
          if origin_id==default_origin_id: continue
          label=origin_ids.get_geo_file_header(key, internals=internals)
          if label is None: continue
          tempbuffer = StringIO()
          proxies.show_sorted(
              by_value="residual",
              sites_cart=sites_cart,
              site_labels=site_labels,
              f=tempbuffer,
              prefix="",
              origin_id=origin_id)
          if len(tempbuffer.getvalue()) and tempbuffer.getvalue().find(': 0')==-1:
            print('%s | %s | %s' % (p_label, label, tempbuffer.getvalue()[start:]),
                  file=f)
    #
    # not parsed for geo viewer
    #
    for p_label, proxies in [
        ("Reference torsion angle", self.reference_dihedral_manager),
        ("NCS torsion angle",       self.ncs_dihedral_manager),
        ("",                        self.ramachandran_manager),
        ('Reference coordinate',    self.reference_coordinate_proxies),
        ]:
      if proxies is not None:
        if hasattr(proxies, 'show_sorted'):
          proxies.show_sorted(
              by_value="residual",
              sites_cart=sites_cart,
              site_labels=site_labels,
              proxy_label=p_label,
              f=f)
        else:
          def dist2(xyz1, xyz2):
            d2=0
            for i in range(3):
              d2+=(xyz1[i]-xyz2[i])**2
            return d2
          print('Harmonic | Reference coordinate | restraints :%d' % (len(proxies)),
                file=f)
          for proxy in proxies:
            i_seq=proxy.i_seqs[0]
            d2=dist2(proxy.ref_sites, sites_cart[i_seq])
            print('bond %s, d2=%6.3fA, sigma=%7.3f, weight=%7.3f' % (
              site_labels[i_seq],
              d2,
              # '(%9.5f, %9.5f, %9.5f)' % tuple(proxy.ref_sites),
              1/proxy.weight**0.5,
              proxy.weight,
              ),
              file=f,
              )
        print(file=f)
    #
    # Here should be showing DEN manager...
    #
    if (pair_proxies.nonbonded_proxies is not None):
      tempbuffer = StringIO()
      pair_proxies.nonbonded_proxies.show_sorted(
        by_value="delta",
        sites_cart=sites_cart, site_labels=site_labels,
        f=tempbuffer,
        suppress_model_minus_vdw_greater_than=None)
      start=10
      print('%s| unspecified | %s' % (tempbuffer.getvalue()[:start],
                                      tempbuffer.getvalue()[start:]
                                     ),
            file=f)

# This should be in model class?
#  def nb_overlaps_info(
#    self,
#    sites_cart,
#    hd_sel,
#    macro_mol_sel=None,
#    site_labels=None):
#    """ non-bonded overlaps information """
#    from cctbx.geometry_restraints.nonbonded_overlaps import info
#    if not macro_mol_sel:
#      from cctbx.geometry_restraints.nonbonded_overlaps import get_macro_mol_sel
#      macro_mol_sel = get_macro_mol_sel(pdb_processed_file=self)
#
#    return info(
#      geometry_restraints_manager=self,
#      macro_molecule_selection=macro_mol_sel,
#      sites_cart=sites_cart,
#      hd_sel=hd_sel,
#      site_labels=site_labels).result

  def _bond_generator(self):
    simple, asu = self.get_all_bond_proxies()
    simple = simple.get_proxies_without_origin_id(0)
    asu = asu.get_proxies_without_origin_id(0)
    for bond in list(simple)+list(asu):
      yield bond

  def get_struct_conn_mmcif(self, hierarchy):
    atoms = hierarchy.atoms()
    def _atom_info(atom):
      return [  # auth
                atom.parent().resname.strip(),
                atom.parent().parent().parent().id,
                atom.parent().parent().resseq.strip(),
                atom.name.strip(),
                # label
                atom.parent().resname.strip(),
                hierarchy.get_label_asym_id(atom.parent().parent()),
                hierarchy.get_label_seq_id(atom.parent()),
                atom.name.strip(),
                '.', # role
               ]
      return res
    def _atom_info_grouped(bond):
      row = []
      if hasattr(bond, 'i_seqs'):
        i1 = bond.i_seqs[0]
        i2 = bond.i_seqs[1]
      else:
        i1 = bond.i_seq
        i2 = bond.j_seq
      row += _atom_info(atoms[i1])
      row += _atom_info(atoms[i2])
      #row.append('1_555') # symmetry!
      return row
    from cctbx.geometry_restraints.auto_linking_types import origin_ids
    struct_conn_loop = iotbx.cif.model.loop(header=(
      '_struct_conn.id',
      '_struct_conn.conn_type_id',
      '_struct_conn.ptnr1_auth_comp_id',
      '_struct_conn.ptnr1_auth_asym_id',
      '_struct_conn.ptnr1_auth_seq_id',
      '_struct_conn.ptnr1_auth_atom_id',
      '_struct_conn.ptnr1_label_comp_id',
      '_struct_conn.ptnr1_label_asym_id',
      '_struct_conn.ptnr1_label_seq_id',
      '_struct_conn.ptnr1_label_atom_id',
      '_struct_conn.ptnr1_role',
      #'_struct_conn.ptnr1_symmetry',
      '_struct_conn.ptnr2_auth_comp_id',
      '_struct_conn.ptnr2_auth_asym_id',
      '_struct_conn.ptnr2_auth_seq_id',
      '_struct_conn.ptnr2_auth_atom_id',
      '_struct_conn.ptnr2_label_comp_id',
      '_struct_conn.ptnr2_label_asym_id',
      '_struct_conn.ptnr2_label_seq_id',
      '_struct_conn.ptnr2_label_atom_id',
      '_struct_conn.ptnr2_role',
      #'_struct_conn.ptnr2_symmetry',
      '_struct_conn.details',
      ))
    for i, bond in enumerate(self._bond_generator()):
      row = ['C%05d' % (i+1)]
      origin_id_info = origin_ids[0].get(bond.origin_id, None)
      assert origin_id_info
      if origin_id_info[0]=='SS BOND': row.append('disulf')
      elif origin_id_info[0]=='metal coordination': row.append('metalc')
      elif origin_id_info[0]=='hydrogen bonds': row.append('hydrog')
      else: row.append('covale')
      row += _atom_info_grouped(bond)
      if len(origin_id_info)>2 and origin_id_info[2]:
        row.append(origin_id_info[2])
      elif origin_id_info[1]: row.append(origin_id_info[1])
      else: row.append('.') # details
      struct_conn_loop.add_row(row)
    return struct_conn_loop

  def get_cif_link_entries(self, mon_lib_srv):
    from cctbx.geometry_restraints.auto_linking_types import origin_ids
    links = iotbx.cif.model.cif()
    # not sure why this is the case but these are missing from origin_ids
    done = ['POST-BETA-TRANS',
            'PRE-BETA-TRANS',
            'SSRAD',
            'rna2p',
            'rna3p',
            ]
    for i, bond in enumerate(self._bond_generator()):
      row = ['C%05d' % (i+1)]
      origin_id_info = origin_ids[0].get(bond.origin_id, None)
      assert origin_id_info
      key = origin_id_info[0].replace('link_', '')
      link_key = 'link_%s' % origin_id_info[0]
      if origin_id_info[0]=='SS BOND':
        links['link_SS'] = mon_lib_srv.link_link_id_dict['SS'].as_cif_block()
      elif origin_id_info[0]=='User supplied cif_link':
        tlinks = []
        for origin_id in origin_ids:
          for oi, item in origin_id.items():
            tlinks.append(item[0])
          break
        for tkey, item in sorted(mon_lib_srv.link_link_id_dict.items()):
          if tkey in done: continue
          done.append(tkey)
          if tkey not in tlinks and 'link_%s' % tkey not in tlinks:
            links['link_%s' % tkey] = item.as_cif_block()
      elif key in mon_lib_srv.link_link_id_dict:
        links['link_%s' % key] = mon_lib_srv.link_link_id_dict[key].as_cif_block()
      elif origin_id_info[0] in ['hydrogen bonds',
                                 'edits',
                                 'metal coordination',
                                 'glycosidic custom',
                                 'Misc. bond',
                                 ]:
        # not writing cif_link for various reasons like programatic links
        pass
      else:
        print(origin_id_info[0])
        assert 0
    return links

def construct_non_crystallographic_conserving_bonds_and_angles(
      sites_cart,
      edge_list_bonds,
      edge_list_angles,
      bond_weight=100,
      angle_weight=50,
      vdw_distance=1.2,
      non_crystallographic_unit_cell_buffer_layer=5,
      asu_mappings_buffer_thickness=5,
      max_reasonable_bond_distance=10):
  import cctbx.crystal.coordination_sequences
  from cctbx import uctbx
  from scitbx import matrix
  bond_proxies = geometry_restraints.bond_sorted_asu_proxies(
    asu_mappings=None)
  for edge_list,weight in [(edge_list_bonds, bond_weight),
                           (edge_list_angles, angle_weight)]:
    for i,j in edge_list:
      distance = abs(matrix.col(sites_cart[i]) - matrix.col(sites_cart[j]))
      bond_proxies.process(geometry_restraints.bond_simple_proxy(
        i_seqs=(i,j), distance_ideal=distance, weight=weight))
  bond_params_table = geometry_restraints.extract_bond_params(
    n_seq=sites_cart.size(),
    bond_simple_proxies=bond_proxies.simple)
  box = uctbx.non_crystallographic_unit_cell_with_the_sites_in_its_center(
    sites_cart=sites_cart,
    buffer_layer=non_crystallographic_unit_cell_buffer_layer)
  asu_mappings = box.crystal_symmetry().special_position_settings() \
    .asu_mappings(
      buffer_thickness=asu_mappings_buffer_thickness,
      sites_cart=box.sites_cart)
  bond_asu_table = crystal.pair_asu_table(asu_mappings=asu_mappings)
  geometry_restraints.add_pairs(bond_asu_table, bond_proxies.simple)
  shell_asu_tables = crystal.coordination_sequences.shell_asu_tables(
    pair_asu_table=bond_asu_table,
    max_shell=3)
  shell_sym_tables = [shell_asu_table.extract_pair_sym_table()
    for shell_asu_table in shell_asu_tables]
  nonbonded_types = flex.std_string(bond_params_table.size(), "Default")
  nonbonded_params = geometry_restraints.nonbonded_params()
  nonbonded_params.distance_table.setdefault(
    "Default")["Default"] = vdw_distance
  new_grm = manager(
    crystal_symmetry=box.crystal_symmetry(),
    site_symmetry_table=asu_mappings.site_symmetry_table(),
    bond_params_table=bond_params_table,
    shell_sym_tables=shell_sym_tables,
    nonbonded_params=nonbonded_params,
    nonbonded_types=nonbonded_types,
    nonbonded_function=geometry_restraints.prolsq_repulsion_function(),
    max_reasonable_bond_distance=max_reasonable_bond_distance)
  return box.sites_cart, new_grm

def format_distances_for_error_message(
      pair_sym_table,
      larger_than,
      orthogonalization_matrix,
      sites_frac,
      sites_cart,
      site_labels):
  assert [sites_frac, sites_cart].count(None) == 1
  if (site_labels is not None):
    if (sites_frac is not None):
      assert len(site_labels) == len(sites_frac)
    else:
      assert len(site_labels) == len(sites_cart)
  result = []
  from scitbx.matrix import col, sqr
  if (orthogonalization_matrix is not None):
    orthogonalization_matrix = sqr(orthogonalization_matrix)
  for i_seq,pair_sym_dict in enumerate(pair_sym_table):
    for j_seq,sym_ops in pair_sym_dict.items():
      for rt_mx_ji in sym_ops:
        if (sites_cart is not None):
          assert rt_mx_ji.is_unit_mx()
          d_cart = col(sites_cart[i_seq]) - col(sites_cart[j_seq])
        else:
          d_frac = col(sites_frac[i_seq]) - col(rt_mx_ji * sites_frac[j_seq])
          d_cart = orthogonalization_matrix * d_frac
        dist = d_cart.length()
        if (dist > larger_than):
          if (rt_mx_ji.is_unit_mx()):
            ss = ""
          else:
            ss = " " + str(rt_mx_ji)
          if (site_labels is None):
            si, sj = str(i_seq), str(j_seq)
          else:
            si, sj = site_labels[i_seq], site_labels[j_seq]
          if (dist < 1000):
            sd = "%7.3f" % dist
          else:
            sd = "%.6g" % dist
          result.append("distance: %s - %s: %s%s" % (si, sj, sd, ss))
  return result


 *******************************************************************************


 *******************************************************************************
cctbx/geometry_restraints/nonbonded_overlaps.py
from __future__ import absolute_import, division, print_function
from libtbx.utils import Sorry
from scitbx.array_family import flex
from libtbx import easy_run
import iotbx.pdb
import math
import sys
import six
from six.moves import range, zip

class nonbonded_overlaps_results(object):
  """ Container for non-bonded overlaps results """

  def __init__(self):
    """
    - nonbonded_overlaps is number of overlaps based on the non-bonded
      proxies pairs
    - Overlapping proxies is a list containing the information on the
      overlapping atoms
      in the format:([pdb labels],i_seq,j_seq,model,vdw_distance,sym_op_j,rt_mx)

    The following non-bonded overlaps are calculated:
      nb_overlaps_due_to_sym_op: (calculated with the complete model)
      nb_overlaps_macro_molecule: (protein, DNA and RNA)
        excluding symmetry related overlaps
      nb_overlaps_all: (calculated with the complete model)

    For each of the overlaps a list of overlapping proxies (atoms) is provided:
      nb_overlaps_proxies_due_to_sym_op
      nb_overlaps_proxies_macro_molecule
      nb_overlaps_proxies_all

    The following non-bonded overlaps are calculated:
      normalized_nbo_sym: (calculated with the complete model)
      normalized_nbo_macro_molecule: (protein, DNA and RNA)
        excluding symmetry related overlaps
      normalized_nbo_all: (calculated with the complete model)

    """
    self.nb_overlaps_due_to_sym_op = 0
    self.nb_overlaps_macro_molecule = 0
    self.nb_overlaps_all = 0
    #
    self.nb_overlaps_proxies_due_to_sym_op = []
    self.nb_overlaps_proxies_macro_molecule = []
    self.nb_overlaps_proxies_all = []
    #
    self.normalized_nbo_sym = 0
    self.normalized_nbo_macro_molecule = 0
    self.normalized_nbo_all = 0

class compute(object):
  """
  Compute non-bonded overlap using geometry restraints manager.

  @author: Youval Dar (LBL 2013)
  """

  def __init__(
    self,
    nonbonded_list,
    hd_sel,
    full_connectivity_table,
    connectivity_table_2,
    sites_cart):
    """
    Arguments:
    nonbonded_list: a list with items in the following format
                    ([pdb labels],i_seq,j_seq,model,vdw_distance,sym_op_j,rt_mx)
                    i_seq,j_seq: position of residues in the pdb file
                    model: The pdb or other model distance
                    vdw_distance: Van Der Waals distance
                    sym_op_j: is this a product of a symmetry operation
                    rt_mx: Rotation matrix for symmetry operation
    hd_sel: hd_sel[i] returns True of False, indicating whether an atom i
            is a Hydrogen or not
    full_connectivity_table: full_connectivity_table[i] is a dictionary
                            containing a list of all atoms connected to atom i
    connectivity_table_2: connectivity_table[i] is a dictionary containing a
                         list of all atoms separated by three bonds from atom i
                         (1 - 4 interaction)
    sites_cart: sites_cart[i] tuple containing the x,y,z coordinates of atom i
    """
    self.nonbonded_list = nonbonded_list
    self.hd_sel = hd_sel
    self.full_connectivity_table = full_connectivity_table
    self.connectivity_table_2 = connectivity_table_2
    self.sites_cart = sites_cart
    if nonbonded_list != []:
      try:
        nbo_list = self.nb_overlaps_list()
      except TypeError as e:
        # When proxies_info_nonbonded are not available
        if e == "vec3_double' object is not callable":
          raise Sorry(e)
        else:
          nbo_list = [[],[]]
          print(e)
      except Sorry as e:
        raise Sorry(e)
      except Exception as e:
        m='Failed processing proxies_info_nonbonded in nb_overlaps_list()'
        raise Sorry(m)
      # Collect overlaps information
      self.nb_overlaps_proxies_due_to_sym_op = nbo_list[0]
      self.nb_overlaps_non_sym_overlaps = nbo_list[1]
      self.nb_overlaps_proxies_all = nbo_list[0] + nbo_list[1]
      # overlap is the of steric overlaps (>0.4A)
      self.n_atoms = len(self.sites_cart)
      nbo_sym = len(nbo_list[0])
      nbo_non_sym = len(nbo_list[1])
      nbo_all_overlaps = nbo_sym + nbo_non_sym
      #
      self.nb_overlaps_due_to_sym_op = nbo_sym
      self.nb_overlaps_non_sym = nbo_non_sym
      self.nb_overlaps_all = nbo_all_overlaps
      # compute clashscores for testing
      # number of steric overlaps (>0.4A) per 1000 atoms
      clashscore_sym = nbo_sym*1000/self.n_atoms
      clashscore_non_sym = nbo_non_sym*1000/self.n_atoms
      clashscore_all_clashes = clashscore_sym + clashscore_non_sym
      self.normalized_nbo_sym = clashscore_sym
      self.cctbx_clashscore_non_sym = clashscore_non_sym
      self.normalized_nbo_all = clashscore_all_clashes
    else:
      self.nb_overlaps_due_to_sym_op = 0
      self.nb_overlaps_non_sym = 0
      self.nb_overlaps_all = 0
      self.normalized_nbo_sym = 0
      self.cctbx_clashscore_non_sym = 0
      self.normalized_nbo_all = 0
      #
      self.nb_overlaps_proxies_due_to_sym_op = []
      self.nb_overlaps_non_sym_overlaps = []
      self.nb_overlaps_proxies_all = []

  @staticmethod
  def is_1_5_interaction(i_seq,j_seq,hd_sel,full_connectivity_table):
    """(int,int,bool array,list of lists of int) -> bool
    Check if we have 1-5 interaction between two hydrogen and heavy atom

    Args:
      i_seq,j_seq:  are the number of the atoms we are checking in the pdb table
      hd_sel: hd_sel[i] returns True of False, indicating whether an atom i is
        a Hydrogen or not
      full_connectivity_table: full_connectivity_table[i] is a dictionary
        constraining a list of all atoms connected to atom

    Returns:
      True if we have 1-5 hydrogen and heavy atom interaction
    """
    # check if we have hydrogen - heavy atom interaction
    xor = lambda a,b: (a or b) and not (a and b)
    if xor(hd_sel[i_seq],hd_sel[j_seq]):
      # starting with hydrogen will make process shorter
      if not hd_sel[i_seq]:
        i_seq,j_seq = j_seq,i_seq
      # build connection table of i_seq, 4 steps deep
      atoms_numbers = dict([(i_seq, 0)]) # i_seq is in zero distance
      used_connections = {i_seq}
      new_connections = {i_seq}
      for i in range(2,6):
        connections = set()
        for key in new_connections:
          # add all new connections for the current step
          connections = connections.union(set(full_connectivity_table[key]))
        # Remove the connection that were already used
        new_connections = connections - used_connections
        # Add the new connection to the used once
        used_connections = used_connections.union(connections)
        # Add the new atoms with their distance from key
        for new_atom in new_connections:
          atoms_numbers[new_atom] = i
      # return true if j_seq in the is 1-5 connection
      return (j_seq in atoms_numbers) and (atoms_numbers[j_seq] == 5)
    else:
      return False

  def get_nbo_keys(self,record):
    """(str) -> str,str,str

    Collect atoms keys and coordinates

    Args:
      record : an overlap record, for example:
    (['pdb=" HA  LEU A  38 "','pdb="HD23 LEU A  38 "'],523,532,1.81,2.44,'',None)

    Returns:
      nbo_vec: a unique key for an overlap. for example:
        '0.144,0.323,1.776,0.154,0.327,1.786'
      key1,key2: are the atoms keys. for example
        ' HA  LEU A  38 ::120::' or ' CB ASN A  55 ::52::sym.op.'
        "atom1 label::atom1 number::sym.op""
    """
    # get atoms keys
    record = list(record)
    key = '{0}::{1}::{2}'
    key1 = key.format(record[0][0][5:-1],record[1],record[5])
    key2 = key.format(record[0][1][5:-1],record[2],record[5])
    # get coordinates
    atomi_xyz = self.sites_cart[record[1]]
    atomj_xyz = self.sites_cart[record[2]]
    # make tupe containing both atom coordinates
    vec = atomi_xyz + atomj_xyz
    # creat a string from vec
    nbo_vec = '{0:.3f},{1:.3f},{2:.3f},{3:.3f},{4:.3f},{5:.3f}'.format(*vec)
    # make key1 always smaller than key2
    if key1 > key2:
      key1,key2 = key2,key1
    return nbo_vec,key1,key2

  @staticmethod
  def cos_vec(u,v):
    """(tuple,tuple) -> float

    Calculate the cosine used to evaluate whether the atoms
    colliding are inline or not

    Args:
      u,v: lists containing x1,y1,z1,x2,y2,z2 coordinates
    Returns:
      cos_angle: the cosine of the angle between center of the common atom
        and the mid point between the other two atoms.
    """
    # Calculate dot product
    u_dot_v = lambda u,v: (u[0]*v[0]+u[1]*v[1]+u[2]*v[2])
    # Calculate mid point between to atoms
    u_mid_v = lambda u,v: [(x+y)/2 for (x,y) in zip(u,v)]
    # find the length of a vector
    u_len = lambda u: math.sqrt(u[0]**2 + u[1]**2 + u[2]**2)
    # Move vector to the origin
    make_vec = lambda u1,u2: [(x-y) for (x,y) in zip(u1,u2)]
    v1 = v[0:3]
    v2 = v[3:6]
    u1 = u[0:3]
    u2 = u[3:6]
    # find the common atoms
    if v1 == u1:
      mid_uv = u_mid_v(u2,v2)
      vec1 = make_vec(v1,mid_uv)
      vec2 = make_vec(u2,v2)
    elif v1 == u2:
      mid_uv = u_mid_v(u1,v2)
      vec1 = make_vec(v1,mid_uv)
      vec2 = make_vec(u1,v2)
    elif v2 == u1:
      mid_uv = u_mid_v(u2,v1)
      vec1 = make_vec(v2,mid_uv)
      vec2 = make_vec(u2,v1)
    else: #v2 == u2
      mid_uv = u_mid_v(u1,v1)
      vec1 = make_vec(v2,mid_uv)
      vec2 = make_vec(u1,v1)
    # return the cosine of the angle between the two vectors
    try:
      cos_angle = abs(u_dot_v(vec1,vec2)/u_len(vec1)/u_len(vec2))
    except ZeroDivisionError:
      cos_angle = 1
    return cos_angle

  def nb_overlaps_list(self):
    """(self) -> [list,list]
    Collect information of overlapping nonbonded proxies (neighboring atoms)
    for overlap count calculation.
    - proxies (atoms) considered to overlap when:
        model_distance - van_der_waals_distance < -0.40
    - For every atom consider only worst overlap
    - Do not double count in-line overlaps.
       for example, C-H1  H2-...
       if both C and H1 are overlapping with H2 count only the worst of them
    - Exclude 1-5 interaction of Hydrogen and heavy atom

    Returns:
      Overlapping_atoms_list: [[list of overlaps due to sym operation],
                            [list of all other overlaps]]
    """
    Overlapping_atoms_list = [[],[]]
    overlap_atoms_dict = {}
    # overlap_atoms_dict[atom_key] = [all overlaps information for this atom]
    # overlap_atoms_dict[' HA  ASP A  44 '] =
    #   [ [atom1,vec1,i_seq,j_seq1,model)],[atom2, vec2,i_seq, j_seq2,model]...]
    # vec = [delta_x,delta_y,delta_z] , difference between the atoms coordinates
    overlaps_dict = {}
    # overlaps_dict[vec] = [atom1, atom2, nonbonded_list nbo_record]
    # vec uniquely define a overlap, regardless of atoms order
    for rec in self.nonbonded_list:
      i_seq = rec[1]
      j_seq = rec[2]
      model = rec[3]
      vdw = rec[4]
      symop = rec[5]
      delta = model - vdw
      # check for overlap
      if (delta < -0.40):
        # Check of 1-5 interaction
        if not self.is_1_5_interaction(
                i_seq, j_seq,self.hd_sel,self.full_connectivity_table):
          nbo_vec,key1,key2 = self.get_nbo_keys(rec)
          # nbo_key is a string a string that uniquely identify each overlap
          if key1>key2:
            nbo_key = '::'.join([key2,key1])
          else:
            nbo_key = '::'.join([key1,key2])
          if nbo_key not in overlaps_dict:
            # record new overlap
            overlaps_dict[nbo_key] = [key1,key2,rec]
            if key1 not in overlap_atoms_dict: overlap_atoms_dict[key1] = []
            if key2 not in overlap_atoms_dict: overlap_atoms_dict[key2] = []
            overlap_atoms_dict[key1].append([key2,nbo_vec,nbo_key,symop,model])
            overlap_atoms_dict[key2].append([key1,nbo_vec,nbo_key,symop,model])
    for key in overlap_atoms_dict:
      # for atoms that overlap more than once, check for inline overlaps
      if len(overlap_atoms_dict[key]) > 1:
        temp_nbo_list = []
        n_overlaps = len(overlap_atoms_dict[key])
        # iterate over all overlap combination
        for i in range(n_overlaps-1):
          for j in range(i+1,n_overlaps):
            vec_i = overlap_atoms_dict[key][i][1]
            vec_j = overlap_atoms_dict[key][j][1]
            u = [float(_v) for _v in vec_i.split(',')]
            v = [float(_v) for _v in vec_j.split(',')]
            cos_angle = 0
            # test inline only if the two atoms, overlapping with the
            # common atom, are connected
            overlapping_atom_1 = int(overlap_atoms_dict[key][i][0].split('::')[1])
            overlapping_atom_2 = int(overlap_atoms_dict[key][j][0].split('::')[1])
            if overlapping_atom_1 in self.full_connectivity_table[overlapping_atom_2]:
              if not [0.0,0.0,0.0] in [u,v]:
                # Do not calculate cos_angle when atoms are overlapping
                if overlap_atoms_dict[key][i][3] == '':
                  # ignore overlaps that are cause by symmetry operation
                  cos_angle = self.cos_vec(u,v)
            # atoms consider to be inline if cosine of
            # the angle between vectors > 0.707
            if abs(cos_angle) > 0.707 and (vec_i != vec_j):
              # for inline overlaps keep the closer two(compare models)
              if overlap_atoms_dict[key][i][4] < overlap_atoms_dict[key][j][4]:
                temp_nbo_list.append(overlap_atoms_dict[key][i])
                # remove overlap from overlaps_dict
                remove_key = overlap_atoms_dict[key][j][2]
                if remove_key in overlaps_dict: del overlaps_dict[remove_key]
              else:
                temp_nbo_list.append(overlap_atoms_dict[key][j])
                # remove overlap from overlaps_dict
                remove_key = overlap_atoms_dict[key][i][2]
                if remove_key in overlaps_dict: del overlaps_dict[remove_key]
            else:
              # overlaps are not inline, keep both
              temp_nbo_list.append(overlap_atoms_dict[key][j])
              temp_nbo_list.append(overlap_atoms_dict[key][i])
        overlap_atoms_dict[key] = temp_nbo_list
    for (key,val) in six.iteritems(overlaps_dict):
      if key.split('::')[2] != '':
        # not to symmetry operation
        Overlapping_atoms_list[0].append(val[2])
      else:
        # not due to symmetry operation
        Overlapping_atoms_list[1].append(val[2])
    return Overlapping_atoms_list

class info(object):

  def __init__(self,
    model,
#    geometry_restraints_manager,
    macro_molecule_selection,
#    sites_cart,
#    hd_sel,
#    site_labels=None,
    do_only_macro_molecule=False,
    check_for_unknown_pairs=True):

    geometry_restraints_manager = model.get_restraints_manager().geometry
    xrs = model.get_xray_structure()
    sites_cart = model.get_sites_cart()
    site_labels = xrs.scatterers().extract_labels()
    hd_sel = model.get_hd_selection()
    '''
    Construct nonbonded_overlaps_info, the non-bonded overlaps number and list

    Args:
      geometry_restraints_manager:
      macro_molecule_selection : selection array typically of corresponding to a
        selection string of "protein of dna or rna"
      sites_cart: sites_cart[i] tuple containing the x,y,z coordinates of atom i
      site_labels: a list of lables such as " HA  LEU A  38 ", for each atom
      hd_sel: hd_sel[i] retruns True of False, indicating whether an atom i is
            a Hydrogen or not

    NOTE:
    As of Dec. 2013 manipulation of scatterers can produce scatteres which
    have no lables. In that case, water interaction score will not be accurate

    NOTE:
    Be aware to the parameters:
       assume_hydrogens_all_missing=False,
       hard_minimum_nonbonded_distance=0.0

    The default values of these are True and 0.001, which will alter
    the size of the vdw bonds and the overlaps that being counted

    As of Dec. 2013 manipulation of scatterers can produce scatterers which
    have no labels. In that case, water interaction score will not be accurate

    @author: Youval Dar, LBL 12-2013
    '''
    selection_list = [flex.bool([True]*sites_cart.size())]
    results = []
    # second_grm_selection = macro_molecule_selection.count(False) > 0
    # This is 10 times faster and produces the same result
    second_grm_selection = not macro_molecule_selection.all_eq(True)
    if second_grm_selection:
      selection_list.append(macro_molecule_selection)

    for i, sel in enumerate(selection_list):
      if do_only_macro_molecule and i == 0:
        results.append(compute(
            nonbonded_list=[],
            hd_sel=None,
            full_connectivity_table=None,
            connectivity_table_2=None,
            sites_cart=None))
        continue
      grm = geometry_restraints_manager.select(sel)
      cart = sites_cart.select(sel)
      if site_labels:
        site_label = site_labels.select(sel)
      else:
        site_label = site_labels
      if (check_for_unknown_pairs and
          unknown_pairs_present(grm=grm,sites_cart=cart,site_labels=site_label)):
        msg = "nonbonded overlaps can't be calculated."
        msg += " PDB file contains unknown type pairs. Please provide cif file."
        raise Sorry(msg)
      pair_proxies = grm.pair_proxies(sites_cart=cart,site_labels=site_label)
      proxies_info_nonbonded = pair_proxies.nonbonded_proxies.get_sorted(
        by_value="delta",
        sites_cart=cart,
        site_labels=site_label)

      if proxies_info_nonbonded != None:
        nonbonded_list = proxies_info_nonbonded[0]
      else:
        nonbonded_list = []

      fsc0=grm.shell_sym_tables[0].full_simple_connectivity()
      fsc2=grm.shell_sym_tables[2].full_simple_connectivity()

      results.append(compute(
        nonbonded_list=nonbonded_list,
        hd_sel=hd_sel.select(sel),
        full_connectivity_table=fsc0,
        connectivity_table_2=fsc2,
        sites_cart=cart))

    self.result = nonbonded_overlaps_results()
    r_complete = results[0]
    # all
    self.result.nb_overlaps_all = r_complete.nb_overlaps_all
    self.result.nb_overlaps_proxies_all = r_complete.nb_overlaps_proxies_all
    # Symmetry
    self.result.nb_overlaps_due_to_sym_op = r_complete.nb_overlaps_due_to_sym_op
    self.result.nb_overlaps_proxies_due_to_sym_op = \
      r_complete.nb_overlaps_proxies_due_to_sym_op
    # CCTBX clashscore
    self.result.normalized_nbo_all = r_complete.normalized_nbo_all
    self.result.normalized_nbo_sym = \
      r_complete.normalized_nbo_sym
    # macro molecule
    if second_grm_selection:
      r_macro_mol = results[1]
      nb_overlaps = r_macro_mol.nb_overlaps_non_sym
      self.result.nb_overlaps_macro_molecule = nb_overlaps
      self.result.nb_overlaps_proxies_macro_molecule = \
        r_macro_mol.nb_overlaps_non_sym_overlaps
      clashscore = r_macro_mol.cctbx_clashscore_non_sym
      self.result.normalized_nbo_macro_molecule = clashscore
    else:
      self.result.nb_overlaps_macro_molecule = \
        r_complete.nb_overlaps_non_sym
      self.result.nb_overlaps_proxies_macro_molecule = \
        r_complete.nb_overlaps_non_sym_overlaps
      self.result.normalized_nbo_macro_molecule = \
        r_complete.cctbx_clashscore_non_sym

  def show(self, log=None, nbo_type='all',normalized_nbo=False):
    """
    Show (prints to log) nonbonded_overlaps_info on overlapping atoms

    Args:
      show_normalized_nbo=False Show non-bonded overlaps per 1000 atoms
      log : when no log is given function will print to sys.stdout
      nbo_type (str): The type of overlaps to show
        'all': Show all overlapping atoms
        'sym': Show symmetry related overlaps
        'macro': Show macro molecule overlaps (not including sym related overlaps)

    Returns:
      out_string (str): the output string that is printed to log
    """
    nb_overlaps = self.result
    if not log: log = sys.stdout
    out_list = []
    result_str = '{:<54} :{:5.2f}'
    if normalized_nbo:
      names = ['Total normalized NBO',
             'normalized NBO macro molecule (Protein, RNA, DNA)',
             'normalized NBO due to symmetry']
      scores = [nb_overlaps.normalized_nbo_all,
              nb_overlaps.normalized_nbo_macro_molecule,
              nb_overlaps.normalized_nbo_sym]
      for name,score in zip(names,scores):
        out_list.append(result_str.format(name,round(score,2)))
    names = ['Total non-bonded overlaps',
             'non-bonded overlaps macro molecule (Protein, RNA, DNA)',
             'non-bonded overlaps due to symmetry']
    scores = [nb_overlaps.nb_overlaps_all,
              nb_overlaps.nb_overlaps_macro_molecule,
              nb_overlaps.nb_overlaps_due_to_sym_op]
    for name,score in zip(names,scores):
      out_list.append(result_str.format(name,round(score,2)))
    if nbo_type == 'sym':
      nbo_proxies = nb_overlaps.nb_overlaps_proxies_due_to_sym_op
      title = 'Overlaps due to symmetry operation,'
    elif nbo_type == 'macro':
      nbo_proxies = nb_overlaps.nb_overlaps_proxies_macro_molecule
      title = 'Overlaps in macro molecule (not including sym. related overlaps),'
    else:
      nbo_proxies = nb_overlaps.nb_overlaps_proxies_all
      title = 'Overlapping atoms, complete model,'
    title += ' based on pair_proxies.nonbonded_proxies'
    out_list.append(title)
    out_list.append('='*len(title))
    labels =  ["Overlapping residues info","i_seq","j_seq","model-vdw",
               "sym overlap"]
    lbl_str = '{:^33}|{:^7}|{:^7}|{:^11}|{:<10}'
    out_str = '{:>16}|{:>16}|{:^7}|{:^7}|  {:>6.3f}   |{:^10}|'
    out_list.append(lbl_str.format(*labels))
    out_list.append('-'*73)
    argmented_counts = [0,0]
    def _adjust_count(d):
      d=(abs(d)-0.4)*10
      return d+1
    for data in nbo_proxies:
      # clean and order info for output string
      d = list(data)
      rec_list = [x.replace('pdb=','') for x in d[0]]
      rec_list = [x.replace('"','') for x in rec_list]
      rec_list.extend(d[1:3])
      rec_list.append(d[3]-d[4])
      rec_list.append('1'*bool(d[5]) + ' '*(not bool(d[5])))
      #print(rec_list)
      ptr = 0
      if rec_list[5].strip(): ptr=1
      argmented_counts[ptr] += _adjust_count(rec_list[4])
      out_list.append(out_str.format(*rec_list))
    out_string = '\n'.join(out_list)
    print(out_string, file=log)
    #print(argmented_counts)
    return out_string

def get_macro_mol_sel(pdb_processed_file,selection='protein or dna or rna'):
  """
  Get macro molecule selection from a PBD interpretation object, for non bonded
  overlaps calculation

  Args:
    pdb_processed_file : Object result from pdb_interpretation of a file
    selection (str): By default a string to select the macro molecule.

  Return:
    macro_mol_sel (flex.bool): selection array
  """
  proxies = pdb_processed_file.all_chain_proxies
  cache = proxies.pdb_hierarchy.atom_selection_cache()
  macro_mol_sel = proxies.selection(
    cache=cache,
    string=selection )
  return macro_mol_sel

def create_cif_file_using_ready_set(
        pdb_hierarchy=None,
        crystal_symmetry=None,
        file_name=None,
        log=None):
  """
  When model contains unknown pairs, create a cif file for nonbonded_overlaps
  calculation using READY_SET.

  Args:
    pdb_hierarchy : pdb hierarchy
    file_name (str): pdb file name
    log : output location
    crystal_symmetry : must provide crystal symmetry when using pdb_hierarchy

  Returns:
    (str): the cif file name that was created
  """
  import libtbx.load_env
  has_ready_set = libtbx.env.has_module(name="phenix")
  if file_name:
    pdb_inp = iotbx.pdb.input(file_name=file_name)
    pdb_hierarchy = pdb_inp.construct_hierarchy()
    cryst_sym = pdb_inp.crystal_symmetry()
  else:
    assert crystal_symmetry
    cryst_sym = crystal_symmetry
  assert pdb_hierarchy
  if not log: log = sys.stdout
  models = pdb_hierarchy.models()
  assert len(models) == 1
  if not has_ready_set:
    msg = 'phenix.ready_set could not be detected on your system.\n'
    msg += 'Cannot process PDB file'
    print(msg, file=log)
    return [False,False]
  if not file_name:
    file_name = pdb_hierarchy.write_pdb_or_mmcif_file(
        target_format = 'pdb',
        crystal_symmetry=cryst_sym,
        target_filename = 'input_pdb_file_for_ready_set.pdb')
  cmd = "phenix.ready_set {} --silent".format(file_name)
  out = easy_run.fully_buffered(cmd)
  if (out.return_code != 0):
    msg_str = "ready_set crashed - dumping stderr:\n%s"
    raise RuntimeError(msg_str % ( "\n".join(out.stderr_lines)))
  fn_pdb = file_name.replace('.pdb','.updated.pdb')
  fn_cif = file_name.replace('.pdb','.ligands.cif')
  return [fn_cif,fn_pdb]

def unknown_pairs_present(grm,sites_cart,site_labels):
  """
  Test if PDB file contains unknown type pairs

  Args:
    grm (obj): geometry restraints manager
    sites_cart (flex.vec3): atoms sites cart (coordinates)
    site_labels: a list of lables such as " HA  LEU A  38 ", for each atom

  Return:
    (bool): True if PDB file contains unknown type pairs
  """
  pp= grm.pair_proxies(sites_cart=sites_cart,site_labels=site_labels)
  return (pp.nonbonded_proxies.n_unknown_nonbonded_type_pairs != 0)


 *******************************************************************************


 *******************************************************************************
cctbx/geometry_restraints/process_nonbonded_proxies.py
from __future__ import division, print_function
#import math
from libtbx import group_args
from scitbx import matrix
from libtbx.str_utils import make_sub_header
from libtbx.utils import null_out
import scitbx.matrix
from cctbx import sgtbx
from mmtbx.nci import hbond
from libtbx.test_utils import approx_equal
from collections import OrderedDict
import six


def check_if_1_5_interaction(
      i_seq,
      j_seq,
      hd_sel,
      full_connectivity_table):
  """
  Checks if there is 1-5 interaction between a hydrogen (H) and heavy atom
  (X): H-A-A-A-X

  Parameters
  ----------
  i_seq: int
    Atom i_seq number
  j_seq: int
    Atom i_seq
  hd_sel: bool array
    hd_sel[i] returns True of False if atom i is H or not
  full_connectivity_table: dict of lists of int
    dictionary with a list of all atoms connected to atom i

  Returns
  -------
  is_1_5_interaction: bool
    True/False if there is 1-5 interaction between a hydrogen and a heavy atom
  """
  is_1_5_interaction = False
  # check if there is hydrogen - heavy atom interaction
  xor = lambda a,b: (a or b) and not (a and b)
  if xor(hd_sel[i_seq],hd_sel[j_seq]):
    # starting with hydrogen will make process shorter
    if not hd_sel[i_seq]:
      i_seq,j_seq = j_seq,i_seq
    # build connection table of i_seq, 4 steps deep
    atoms_numbers = dict([(i_seq, 0)]) # i_seq is in zero distance
    used_connections = {i_seq}
    new_connections = {i_seq}
    for i in range(2,6):
      connections = set()
      for key in new_connections:
        # add all new connections for the current step
        connections = connections.union(set(full_connectivity_table[key]))
      # Remove the connection that were already used
      new_connections = connections - used_connections
      # Add the new connection to the used ones
      used_connections = used_connections.union(connections)
      # Add the new atoms with their distance from key
      for new_atom in new_connections:
        atoms_numbers[new_atom] = i
    # return true if j_seq in the is 1-5 connection
    is_1_5_interaction = (j_seq in atoms_numbers) and (atoms_numbers[j_seq]==5)
    #return (j_seq in atoms_numbers) and (atoms_numbers[j_seq] == 5)
  return is_1_5_interaction
  #else:
  #  return False

#-------------------------------------------------------------------------------

def cos_vec(u, v, w):
  """
  Calculate the cosine to evaluate whether clashing atoms are inline
  A1 clashes with A2 and A3. Find out if A2 and A3 are inline.
  A1 ~~~ A2
  A1 ~~~ A3

  Parameters
  ----------
  u: vector
    vector of clashing atom (A2 or A3, order does not matter)
  v: vector
    vector of clashing atom (A2 or A3, order does not matter)
  w: vector
    vector of common clashing atom (A1)

  Returns
  -------
    cos_angle: float
    The cosine of the angle between the center of the common atom
      and the mid point between the other two atoms.
  """
  u = matrix.col(u)
  v = matrix.col(v)
  w = matrix.col(w)

  vec1 = w - (u/2 + v/2)
  vec2 = u - v

  try:
    cos_angle = abs(vec1.normalize().dot(vec2.normalize()))
  except ZeroDivisionError:
    cos_angle = 1
  return cos_angle

#-------------------------------------------------------------------------------

def unknown_pairs_present(model):
  """
  Test if PDB file contains unknown type pairs

  Parameters:
    model (obj): model object

  Returns:
    (bool): True if PDB file contains unknown type pairs
  """
  grm = model.get_restraints_manager()
  sites_cart = model.get_sites_cart()
  site_labels = model.get_xray_structure.scatterers().extract_labels()
  pp= grm.pair_proxies(sites_cart=sites_cart,site_labels=site_labels)
  return (pp.nonbonded_proxies.n_unknown_nonbonded_type_pairs != 0)

#-------------------------------------------------------------------------------

class clashes(object):
  """
  Class for clashes
  """
  def __init__(self, clashes_dict, model):
    '''
    clashes_dict  {(iseq, jseq):(distance, sum_vdw_radii, overlap, symop_str, symop)}
    iseq          atom i
    jseq          atom j
    distance      distance between atom i and atom j
    sum_vdw_radii sum of vdW radii
    '''
    self._clashes_dict = clashes_dict
    self.model = model
    #
    self.sort_clashes()


  def show(self, log=null_out(), show_clashscore=True):
    """
    Print all clashes in a table.
    """
    make_sub_header(' Nonbonded overlaps', out=log)
    if self._clashes_dict:
      # General information
      results = self.get_results()
      result_str = '{:<18} : {:5d}'
      print(result_str.format(' Number of clashes', results.n_clashes),file=log)
      print(result_str.format(' Number of clashes due to symmetry',
        results.n_clashes_sym), file=log)
      result_str = '{:<18} : {:5.2f}'
      if show_clashscore:
        print(result_str.format(' Clashscore', results.clashscore), file=log)
      # print table with all overlaps
      labels =  ["Overlapping residues info","model distance","overlap",
                 "symmetry"]
      lbl_str = '{:^33}|{:^16}|{:^11}|{:^15}'
      table_str = '{:>16}|{:>16}|{:^16.2f}|{:^11.2}|{:^15}|'
      print('\n' + lbl_str.format(*labels), file=log)
      print('-'*78, file=log)
      atoms = self.model.get_atoms()
      for iseq_tuple, record in six.iteritems(self._clashes_dict):
        i_seq, j_seq = iseq_tuple
        overlap = record[2]
        if record[4] is not None:
          symop = record[4].as_xyz()
        else: symop = ''
        i_id_str = atoms[i_seq].id_str().replace('pdb=','').replace('"','')
        j_id_str = atoms[j_seq].id_str().replace('pdb=','').replace('"','')
        line = [i_id_str, j_id_str,round(record[0], 2),round(overlap, 2), symop]
        #print(table_str % line, file=log)
        print(table_str.format(*line), file=log)
      print('-'*78, file=log)
    else:
      print('No clashes found', file=log)


  def add_clash(self, clash_tuple, clash_info):
    """
    Add a clash to the dictionary

    Parameters:
      clash_tuple (tuple): tuple of 2 i_seqs
      clash_info (list): list of: [model_distance, vdw_sum, abs(delta), symop_str, symop]
    """
    self._clashes_dict[clash_tuple] = clash_info


  def remove_clash(self, clash_tuple):
    """
    Remove a clash from the dictionary

    Parameters:
      clash_tuple(tuple): tuple of 2 i_seqs
    """
    if clash_tuple in self._clashes_dict:
      del self._clashes_dict[clash_tuple]


  def iseq_tuple_is_sym_clash(self, clash_tuple):
    """
    Test if clash tuple is involved in symmetry clash
    """
    return self._clashes_dict[clash_tuple][4]


  def iseq_tuple_is_clashing(self, clash_tuple):
    """
    Test if two iseqs are involved in a clash
    """
    are_clashing = False
    if clash_tuple in self._clashes_dict:
      are_clashing = True
    return are_clashing


  def iseq_is_clashing(self, iseq):
    """
    Test if a particular atom is involved in a clash.

    Parameters:
      iseq (int): atom i_seq number

    Returns:
      (bool): True if the atom is involved in a clash
    """
    is_clashing = False
    if self._clashes_dict:
      i_seqs, j_seqs = zip(*self._clashes_dict)
      if iseq in i_seqs or iseq in j_seqs:
        is_clashing = True
    return is_clashing


  def get_model_distance(self, clash_tuple):
    """
    Return the model distance of a clash
    """
    return self._clashes_dict[clash_tuple][0]


  def get_n_clashes(self):
    """
    Number of clashes
    """
    return len(self._clashes_dict)


  def sort_clashes(self, by_value='overlap'):
    """
    Sort clashes according to vdW distance, model distance, overlap or symmetry

    Parameters:
      by_value (str): vdw_distance, model_distance, overlap or symmetry
    """
    options = ['vdw_distance', 'model_distance', 'overlap', 'symmetry']
    if (by_value not in options):
      raise Sorry('Can not sort by this value. Possible options: \n\
                  vdw_distance, model_distance, overlap, symmetry')
    if by_value == 'model_distance': key = 0
    if by_value == 'vdw_distance': key = 1
    if by_value == 'overlap': key = 2
    if by_value == 'symmetry': key = 4
    none_items = [x for x in self._clashes_dict.items() if x[1][key] is None]
    other_items = [x for x in self._clashes_dict.items() if x[1][key] is not None]
    self._clashes_dict = OrderedDict(
      none_items + sorted(other_items, key=lambda x: x[1][key]))


  def _obtain_symmetry_clashes(self):
    """
    Get clashes due to symmetry
    """
    self._symmetry_clashes_dict = dict()
    n_clashes_sym = 0
    clashscore_sym = 0
    for iseq_tuple, record in six.iteritems(self._clashes_dict):
      if record[4] is not None:
        self._symmetry_clashes_dict[iseq_tuple] = record
    if self._symmetry_clashes_dict:
      n_clashes_sym = len(self._symmetry_clashes_dict)
      # Does clashscore_sym actually make sense?
      n_atoms = self.model.size()
      clashscore_sym = n_clashes_sym * 1000 / n_atoms
    return n_clashes_sym, clashscore_sym


  def _obtain_macro_mol_clashes(self):
    """
    Get clashes involving macro-mol atoms only
    """
    self._macro_mol_clashes_dict = dict()
    n_clashes_macro_mol = 0
    clashscore_macro_mol = 0
    macro_mol_sel = self.model.selection(string = 'protein')
    for iseq_tuple, record in six.iteritems(self._clashes_dict):
      if (macro_mol_sel[iseq_tuple[0]] and macro_mol_sel[iseq_tuple[1]]
          and record[4] is None):
        self._macro_mol_clashes_dict[iseq_tuple] = record
    if self._macro_mol_clashes_dict:
      n_clashes_macro_mol = len(self._macro_mol_clashes_dict)
      clashscore_macro_mol = n_clashes_macro_mol * 1000 / \
        self.model.select(macro_mol_sel).size()
    return n_clashes_macro_mol, clashscore_macro_mol


  def get_results(self):
    """
    Accessor for results
    """
    # overall clashscore
    n_clashes = self.get_n_clashes()
    n_atoms = self.model.size()
    clashscore = n_clashes * 1000 / n_atoms
    # clashes due to symmetry
    n_clashes_sym, clashscore_sym = self._obtain_symmetry_clashes()
    # macromolecule ('protein')
    n_clashes_macro_mol, clashscore_macro_mol = self._obtain_macro_mol_clashes()

    return group_args(
             n_clashes            = n_clashes,
             clashscore           = clashscore,
             n_clashes_sym        = n_clashes_sym,
             clashscore_sym       = clashscore_sym,
             n_clashes_macro_mol  = n_clashes_macro_mol,
             clashscore_macro_mol = clashscore_macro_mol)

#-------------------------------------------------------------------------------

class hbonds(object):
  """
  Class for hbonds

  Hydrogen bond is defined here as: D-H...A-Y

     Y
      \
       A
        .
         .
         H
         |
         D
        / \
  """
  def __init__(self, hbonds_dict, model):
    """
    Parameters:
      model         model object (mmtbx/model)
      hbonds_dict (dict)  {(iseq, jseq, kseq):[d_HA, d_DA, a_DHA, symop_str, symop, vdw_sum]}

      iseq          atom D (donor heavy atom)
      jseq          atom H (donor H atom)
      kseq          atom A (acceptor atom)
      d_HA          distance H...A
      d_DA          distance D...A
      a_DHA         angle D-H...A
      symop_str     string of symmetry operator
      symop         symetry operatior
      vdw_sum       sum of vdW radii (atom H and atom D)

    Hydrogen bond is defined here as: D-H...A-Y
    """
    self._hbonds_dict = hbonds_dict
    self.model = model

  def show(self, log=null_out()):
    """
    Print hbonds in a table.

    Parameters:
      log: logfile (or null_out() or sys.stdout)
    """
    make_sub_header(' Hydrogen bonds', out=log)
    if self._hbonds_dict:
      # General information
      results = self.get_results()
      result_str = '{:<18} : {:5d}'
      print(result_str.format(' Number of H bonds', results.n_hbonds), file=log)
      # print table with all H-bonds
      title1 = ['donor', 'acceptor', 'distance', 'angle']
      title1_str = '{:^33}|{:^16}|{:^21}|{:^14}|'
      print('\n' + title1_str.format(*title1), file=log)
      title2 =  ['X', 'H', 'A','H...A','X...A',
                 'X-H...A', 'symop']
      title2_str = '{:^16}|{:^16}|{:^16}|{:^10}|{:^10}|{:^14}|{:^15}|'
      print(title2_str.format(*title2), file=log)
      table_str = '{:>16}|{:>16}|{:^16}|{:^10.2f}|{:^10.2f}|{:^14.2f}|{:^15}|'
      print('-'*99, file=log)
      atoms = self.model.get_atoms()
      for iseq_tuple, record in self._hbonds_dict.items():
        iseq_x, iseq_h, iseq_a = iseq_tuple
        if record[4] is not None:
          symop = record[4].as_xyz()
        else: symop = ''
        x_id_str = atoms[iseq_x].id_str().replace('pdb=','').replace('"','')
        h_id_str = atoms[iseq_h].id_str().replace('pdb=','').replace('"','')
        a_id_str = atoms[iseq_a].id_str().replace('pdb=','').replace('"','')
        line = [x_id_str, h_id_str, a_id_str, round(record[0], 2),
          round(record[1], 2), round(record[2], 2), symop]
        print(table_str.format(*line), file=log)
      print('-'*99, file=log)
    else:
      print('No hbonds found', file=log)


  def add_hbond(self, hbond_tuple, hbond_info):
    """
    Add a hbond to the dictionary

    Parameters:
      hbond_tuple (tuple): tuple of 3 i_seqs
      hbond_info (list):   list of: [d_HA, d_DA, a_DHA, symop_str, symop, vdw_sum]
    """
    self._hbonds_dict[hbond_tuple] = hbond_info

  def get_n_hbonds(self):
    """
    Number of hbonds
    """
    return len(self._hbonds_dict)

  def forms_hbond(self, iseq):
    pass

  def sort_hbonds(self, by_value='HA_distance'):
    pass

  def get_results(self):
    """
    Accessor for results
    """
    # overall
    n_hbonds = self.get_n_hbonds()
    # due to symmetry TODO
#    n_hbonds_sym = self._obtain_symmetry_clashes()

    return group_args(
             n_hbonds = n_hbonds)

#-------------------------------------------------------------------------------

class h_bond(object):
  """
  Hydrogen bond is defined here as: D-H...A-Y

     Y
      \
       A
        .
         .
         H
         |
         D
        / \

    A = O, N, S
    D = O, N, S
    90 <= a_YAH <= 180
    a_DHA >= 120
    1.4 <= d_HA <= 3.0
    2.5 <= d_DA <= 3.5
  """
  def __init__(self):
    self.Hs = ["H", "D"]
    self.As = ["O","N","S","F","CL"]
    self.Ds = ["O","N","S"]
    self.d_HA_cutoff  = [1.4, 3.0]
    self.d_DA_cutoff  = [2.4, 4.1]
    self.a_DHA_cutoff = 120
    self.a_YAH_cutoff = [90, 180]

class manager():

  def __init__(self, model, h_bond_params=None):
    if(h_bond_params is None): h_bond_params = h_bond()
    self.model        = model
    self.Hs           = h_bond_params.Hs
    self.As           = h_bond_params.As
    self.Ds           = h_bond_params.Ds
    self.d_HA_cutoff  = h_bond_params.d_HA_cutoff
    self.d_DA_cutoff  = h_bond_params.d_DA_cutoff
    self.a_DHA_cutoff = h_bond_params.a_DHA_cutoff
    self.a_YAH_cutoff = h_bond_params.a_YAH_cutoff
    #
    self._clashes = None
    self._hbonds  = None


    # TODO: add H in manager or do we enfore that input model has H?
    # self._add_H_atoms() ????


  def get_clashes(self):
    """
    Accessor for clashes object
    """
    if self._clashes is None:
      self._process_nonbonded_proxies(find_clashes = True)
    return self._clashes


  def get_hbonds(self):
    """
    Accessor for hbonds object
    """
    if not self._hbonds:
      self._process_nonbonded_proxies(find_hbonds = True)
    return self._hbonds


  def has_hbonds(self):
    """
    True/False if any hbonds were found.
    """
    hbonds = self.get_hbonds()
    return hbonds.get_n_hbonds() > 0


  def has_clashes(self):
    """
    True/False if any clashes were found.
    """
    clashes = self.get_clashes()
    return clashes.get_n_clashes() > 0


  def show(self):
    """
    Print information
    """
    if self.has_clashes():
      self._clashes.show()
    if self.has_hbonds():
      self._hbonds.show()

#-------------------------------------------------------------------------------

  def _process_nonbonded_proxies(self,
                                 find_clashes = True,
                                 find_hbonds  = True):
    """
    Process nonbonded_proxies to find bonds, interactions and clashes.
    Clashes code refactored from Youval Dar's code for nonbonded_overlaps (LBNL 2013)
    """
    if(self.model.get_restraints_manager() is None):
      self.model.process(make_restraints=True)
    grm = self.model.get_restraints_manager().geometry
    xrs = self.model.get_xray_structure()
    sites_cart  = self.model.get_sites_cart()
    site_labels = xrs.scatterers().extract_labels()
    self.hd_sel      = self.model.get_hd_selection()
    self.water_sel   = self.model.selection('water')
    crystal_symmetry = self.model.crystal_symmetry()
    if crystal_symmetry is not None:
      unit_cell   = crystal_symmetry.unit_cell()
    else:
      unit_cell = None
    self.atoms  = self.model.get_atoms()

    pair_proxies = grm.pair_proxies(
                        sites_cart  = sites_cart,
                        site_labels = site_labels)

    proxies_info_nonbonded = pair_proxies.nonbonded_proxies.get_sorted(
      by_value    = "delta",
      sites_cart  = sites_cart,
      site_labels = site_labels)

    if proxies_info_nonbonded is not None:
      nonbonded_list = proxies_info_nonbonded[0]
    else:
      nonbonded_list = []
      # create 'empty' instance of results class
      self._clashes = clashes(clashes_dict = dict())
      self._hbonds  = hbonds(hbonds_dict = dict())
      return

    fsc0 = grm.shell_sym_tables[0].full_simple_connectivity()
    fsc2 = grm.shell_sym_tables[2].full_simple_connectivity()

    # Create clashes and hbonds class
    self._clashes = clashes(
      clashes_dict = dict(),
      model        = self.model)
    self._hbonds = hbonds(
      hbonds_dict = dict(),
      model       = self.model)
    self._mult_clash_dict = dict()

    # loop over nonbonded proxies, analyze and fill in the dicts:
    for item in nonbonded_list:
      i_seq          = item[1]
      j_seq          = item[2]
      model_distance = item[3]
      vdw_sum        = item[4]
      symop_str      = item[5] # TODO probably not necessary
      symop          = item[6]

      is_hbond, is_clash = False, False

      # Find hbonds
      if find_hbonds:
        if (model_distance <= self.d_HA_cutoff[1] # currently: 3.0
          and [self.hd_sel[i_seq],self.hd_sel[j_seq]].count(True) == 1):
          is_hbond = self._is_hbond(item  = item, fsc0  = fsc0)
          # proxy cannot be clash and hbond at the same time
          if is_hbond: continue

      # Find clashes
      if find_clashes:
        delta = model_distance - vdw_sum
        if (delta < -0.40):
          is_clash = self._is_clash(
            i_seq = i_seq,
            j_seq = j_seq,
            fsc0 = fsc0,
            model_distance = model_distance)
          if is_clash:
            clash_tuple = [i_seq, j_seq]
            clash_tuple.sort()
            clash_tuple = tuple(clash_tuple)
            clash_info = [model_distance, vdw_sum, abs(delta), symop_str, symop]
            self._clashes.add_clash(clash_tuple = clash_tuple,
                                    clash_info  = clash_info)

    # Remove clashes involving common atoms (cannot be done in first loop)
    self._process_clashes(
      sites_cart = sites_cart,
      fsc0       = fsc0)
    self._clashes.sort_clashes(by_value='overlap')

#-------------------------------------------------------------------------------

  def _is_hbond(self, item, fsc0):
    """
    Check if a nonbonded proxy is a H bond

    Parameters:
      item: list item of nonbonded_list
      fsc0: shell_sym_table
    """
    is_hbond = False

    i_seq          = item[1]
    j_seq          = item[2]
    model_distance = item[3]
    vdw_sum        = item[4]
    symop_str      = item[5]
    symop          = item[6]

    is_candidate = hbond.precheck(
      atoms = self.atoms,
      i = i_seq,
      j = j_seq,
      Hs = self.Hs,
      As = self.As,
      Ds = self.Ds,
      fsc0 = fsc0)

    if (not is_candidate):
      return is_hbond

    crystal_symmetry = self.model.crystal_symmetry()
    if crystal_symmetry is not None:
      fm = crystal_symmetry.unit_cell().fractionalization_matrix()
      om = crystal_symmetry.unit_cell().orthogonalization_matrix()
    else:
      fm, om = None, None
    rt_mx_ji = None
    if symop is not None:
      rt_mx_ji = sgtbx.rt_mx(str(symop))
    #
    D, H, A, Y, atom_A, atom_H, atom_D = hbond.get_D_H_A_Y(
      i        = i_seq,
      j        = j_seq,
      Hs       = self.Hs,
      fsc0     = fsc0,
      rt_mx_ji = rt_mx_ji,
      fm       = fm,
      om       = om,
      atoms    = self.atoms)

    d_HA = A.distance(H)
    # if the distances are not equal, something went wrong
    assert approx_equal(d_HA, model_distance, eps=0.1)
    d_DA = D.distance(A)
    a_DHA = H.angle(A, D, deg=True)

    # Values from Steiner, Angew. Chem. Int. Ed. 2002, 41, 48-76, Table 2
    # Modification: minimum angle is 110, not 90
    # TODO: do we want to adapt to acceptor element?
    # TODO: h_a_y angle could be interesting, too
#    if ((d_HA >= 1.2 and d_HA <= 2.2) and
#        (d_DA  >= 2.2 and d_DA <= 3.2) and
#        (a_DHA >= 110)):
    if ((d_HA >= self.d_HA_cutoff[0] and d_HA <= self.d_HA_cutoff[1]) and
        (d_DA  >= self.d_DA_cutoff[0] and d_DA <= self.d_DA_cutoff[1]) and
        (a_DHA >= self.a_DHA_cutoff)):
      is_hbond = True

      self._hbonds.add_hbond(
        hbond_tuple = (D.i_seq, H.i_seq, A.i_seq),
        hbond_info  = [d_HA, d_DA, a_DHA, symop_str, symop, vdw_sum])
      # TODO: if several atom_x, use the first one found
      #  (show shortest or both)

    return is_hbond

#-------------------------------------------------------------------------------

  def _is_clash(self,
                i_seq,
                j_seq,
                fsc0,
                model_distance):
    """
    Determine if a nonbonded proxy is a clash.

    Parameters:
      i_seq (int): atom i_seq
      j_seq (int): atom i_seq
      fsc0 (dict of lists of int): dictionary with a list of all atoms connected to an atom
      model_distance (float): distance between atom i and atom j

    Returns:
      bool (is_clash): if a nonbonded proxy is a clash
    """
    is_clash = False

# Not recommended doing this:
# ignore overlaps of atoms with occupancy sum<1 and in different chains
# a couple of models has asym unit content with superposed chains
#    atom_i = self.atoms[i_seq]
#    atom_j = self.atoms[j_seq]
#    if atom_i.occ + atom_j.occ <= 1.0:
#      if atom_i.chain != atom_j.chain:
#        return False

    # Exclude 1-5 interaction of H atom and heavy atom
    is_1_5_interaction = check_if_1_5_interaction(
             i_seq = i_seq,
             j_seq = j_seq,
             hd_sel = self.hd_sel,
             full_connectivity_table = fsc0)
    if not is_1_5_interaction:
      #if i_seq > j_seq:
      #  i_seq, j_seq = j_seq, i_seq
      # Check to prevent that symmetry clashes are counted twice
      #if (i_seq, j_seq) not in self._clashes_dict.keys():
      is_clash = True
      if (i_seq not in self._mult_clash_dict):
        self._mult_clash_dict[i_seq] = list()
      if (j_seq not in self._mult_clash_dict):
        self._mult_clash_dict[j_seq] = list()
      self._mult_clash_dict[i_seq].append(j_seq)
      self._mult_clash_dict[j_seq].append(i_seq)

    return is_clash

#-------------------------------------------------------------------------------

  def _process_clashes(self, sites_cart, fsc0):
    """
    Process clashes from previous loop through nonbonded_proxies.

    This step is necessary to filter out clashes with common atoms.
    X-H ~~~ Y might produce two clashes, one between X and Y, the other
    between H and Y. This step filters the raw results and keeps the shorter
    of the two clashes (if an angular cutoff is above a limit)
    """
    clashes_to_be_removed = list()
    for i_seq, j_seq_list in six.iteritems(self._mult_clash_dict):
      n_multiples = len(j_seq_list)
      if n_multiples <= 1: continue
      for i in range(n_multiples-1):
        for j in range(i+1, n_multiples):
          multiple_1 = j_seq_list[i]
          multiple_2 = j_seq_list[j]
          cos_angle = 0
        # test inline only if the two atoms that overlap with the common atom are connected
          if multiple_1 in fsc0[multiple_2]:
            atom_1_xyz = sites_cart[multiple_1]
            atom_2_xyz = sites_cart[multiple_2]
            atom_i_xyz = sites_cart[i_seq]
            tuple1 = [i_seq, multiple_1]
            tuple2 = [i_seq, multiple_2]
            tuple1.sort()
            tuple2.sort()
            tuple1 = tuple(tuple1)
            tuple2 = tuple(tuple2)
            # Don't check for inline if symmetry overlap (needs correcty xyz!)
            if not self._clashes.iseq_tuple_is_sym_clash(tuple1):
              cos_angle = cos_vec(atom_1_xyz, atom_2_xyz, atom_i_xyz)
            # check if atoms are inline
            if abs(cos_angle) > 0.707 and (atom_1_xyz != atom_2_xyz):
              if (self._clashes.iseq_tuple_is_clashing(tuple1) and
                  self._clashes.iseq_tuple_is_clashing(tuple2)):
              #if tuple1 in self._clashes_dict and tuple2 in self._clashes_dict:
                if (self._clashes.get_model_distance(tuple1) <
                   self._clashes.get_model_distance(tuple2)):
                  clashes_to_be_removed.append(tuple2)
                else:
                  clashes_to_be_removed.append(tuple1)
    for clash_tuple in clashes_to_be_removed:
      if self._clashes.iseq_tuple_is_clashing(clash_tuple):
        self._clashes.remove_clash(clash_tuple)
#    double_tuples = list()
#    tuples = self._clashes_dict.keys()
#    # Now filter out doubly counted clashes (due to symmetry)
#    for clash_tuple in tuples:
#      i_seq, j_seq = clash_tuple[0], clash_tuple[1]
#      if (j_seq, i_seq) in tuples:
#        if i_seq > j_seq:
#          double_tuples.append(clash_tuple)
#    for clash_tuple in double_tuples:
#      del self._clashes_dict[clash_tuple]
#


 *******************************************************************************


 *******************************************************************************
cctbx/geometry_restraints/standard_cif_links.py
from __future__ import absolute_import, division, print_function
#
# regenerate using python <PHENIX>/modules/cctbx_project/mmtbx/monomer_library/populate_auto_linking_origin_ids.py
#
standard_cif_links = [
  ['link_ACE_C-N', 'ACE_C-N from Monomer Library or GeoStd'],
  ['link_AHT-ALA', 'AHT-ALA from Monomer Library or GeoStd'],
  ['link_ALPHA1-2', 'ALPHA1-2 from Monomer Library or GeoStd'],
  ['link_ALPHA1-3', 'ALPHA1-3 from Monomer Library or GeoStd'],
  ['link_ALPHA1-4', 'ALPHA1-4 from Monomer Library or GeoStd'],
  ['link_ALPHA1-6', 'ALPHA1-6 from Monomer Library or GeoStd'],
  ['link_ALPHA2-3', 'ALPHA2-3 from Monomer Library or GeoStd'],
  ['link_ALPHA2-6', 'ALPHA2-6 from Monomer Library or GeoStd'],
  ['link_ASP_CG-ANY_N', 'ASP_CG-ANY_N from Monomer Library or GeoStd'],
  ['link_BETA1-2', 'BETA1-2 from Monomer Library or GeoStd'],
  ['link_BETA1-3', 'BETA1-3 from Monomer Library or GeoStd'],
  ['link_BETA1-4', 'BETA1-4 from Monomer Library or GeoStd'],
  ['link_BETA1-6', 'BETA1-6 from Monomer Library or GeoStd'],
  ['link_BETA2-3', 'BETA2-3 from Monomer Library or GeoStd'],
  ['link_BOC_C-N', 'BOC_C-N from Monomer Library or GeoStd'],
  ['link_BR-C5', 'BR-C5 from Monomer Library or GeoStd'],
  ['link_CH2-N2', 'CH2-N2 from Monomer Library or GeoStd'],
  ['link_CH3-N1', 'CH3-N1 from Monomer Library or GeoStd'],
  ['link_CH3-O2*', 'CH3-O2* from Monomer Library or GeoStd'],
  ['link_CIS', 'CIS from Monomer Library or GeoStd'],
  ['link_CYS-MPR', 'CYS-MPR from Monomer Library or GeoStd'],
  ['link_DFO-NME', 'DFO-NME from Monomer Library or GeoStd'],
  ['link_DFO_C-N', 'DFO_C-N from Monomer Library or GeoStd'],
  ['link_DFO_DFO', 'DFO_DFO from Monomer Library or GeoStd'],
  ['link_DFO_N-C', 'DFO_N-C from Monomer Library or GeoStd'],
  ['link_DFO_STA', 'DFO_STA from Monomer Library or GeoStd'],
  ['link_DM1-CH2', 'DM1-CH2 from Monomer Library or GeoStd'],
  ['link_FE-CYS', 'FE-CYS from Monomer Library or GeoStd'],
  ['link_FOR-LYZ', 'FOR-LYZ from Monomer Library or GeoStd'],
  ['link_FOR_C-C', 'FOR_C-C from Monomer Library or GeoStd'],
  ['link_FOR_C-N', 'FOR_C-N from Monomer Library or GeoStd'],
  ['link_ILG_CD-N', 'ILG_CD-N from Monomer Library or GeoStd'],
  ['link_ILG_CD-p', 'ILG_CD-p from Monomer Library or GeoStd'],
  ['link_IVA_C-N', 'IVA_C-N from Monomer Library or GeoStd'],
  ['link_LINK_C-N', 'LINK_C-N from Monomer Library or GeoStd'],
  ['link_LINK_CNp', 'LINK_CNp from Monomer Library or GeoStd'],
  ['link_LINK_CpN', 'LINK_CpN from Monomer Library or GeoStd'],
  ['link_MAN-ASN', 'MAN-ASN from Monomer Library or GeoStd'],
  ['link_MAN-SER', 'MAN-SER from Monomer Library or GeoStd'],
  ['link_MAN-THR', 'MAN-THR from Monomer Library or GeoStd'],
  ['link_MG-O1P', 'MG-O1P from Monomer Library or GeoStd'],
  ['link_MG-O2P', 'MG-O2P from Monomer Library or GeoStd'],
  ['link_MPR-CYS', 'MPR-CYS from Monomer Library or GeoStd'],
  ['link_NAG-ASN', 'NAG-ASN from Monomer Library or GeoStd'],
  ['link_NAG-SER', 'NAG-SER from Monomer Library or GeoStd'],
  ['link_NAG-THR', 'NAG-THR from Monomer Library or GeoStd'],
  ['link_NH2_CTERM', 'NH2_CTERM from Monomer Library or GeoStd'],
  ['link_NMCIS', 'NMCIS from Monomer Library or GeoStd'],
  ['link_NME_N-C', 'NME_N-C from Monomer Library or GeoStd'],
  ['link_NMTRANS', 'NMTRANS from Monomer Library or GeoStd'],
  ['link_PCIS', 'PCIS from Monomer Library or GeoStd'],
  ['link_PEPTIDE-PLANE', 'PEPTIDE-PLANE from Monomer Library or GeoStd'],
  ['link_POST-BETA-TRANS', 'POST-BETA-TRANS from Monomer Library or GeoStd'],
  ['link_PRE-BETA-TRANS', 'PRE-BETA-TRANS from Monomer Library or GeoStd'],
  ['link_PTRANS', 'PTRANS from Monomer Library or GeoStd'],
  ['link_SFN-TYR', 'SFN-TYR from Monomer Library or GeoStd'],
  ['link_SS', 'SS from Monomer Library or GeoStd'],
  ['link_SSRAD', 'SSRAD from Monomer Library or GeoStd'],
  ['link_STA-NME', 'STA-NME from Monomer Library or GeoStd'],
  ['link_STA_C-N', 'STA_C-N from Monomer Library or GeoStd'],
  ['link_STA_DFO', 'STA_DFO from Monomer Library or GeoStd'],
  ['link_STA_N-C', 'STA_N-C from Monomer Library or GeoStd'],
  ['link_STA_STA', 'STA_STA from Monomer Library or GeoStd'],
  ['link_TRANS', 'TRANS from Monomer Library or GeoStd'],
  ['link_XYS-ASN', 'XYS-ASN from Monomer Library or GeoStd'],
  ['link_XYS-SER', 'XYS-SER from Monomer Library or GeoStd'],
  ['link_XYS-THR', 'XYS-THR from Monomer Library or GeoStd'],
  ['link_ZN-CYS', 'ZN-CYS from Monomer Library or GeoStd'],
  ['link_gap', 'gap from Monomer Library or GeoStd'],
  ['link_p', 'p from Monomer Library or GeoStd'],
  ['link_symmetry', 'symmetry from Monomer Library or GeoStd'],
]


 *******************************************************************************


 *******************************************************************************
cctbx/geometry_restraints/tst_angle_derivs.py
from __future__ import absolute_import, division, print_function
from cctbx.geometry_restraints import angle, angle_delta_deg
from cctbx.array_family import flex
from scitbx import matrix
from libtbx.test_utils import approx_equal
from libtbx.utils import null_out
import sys
from six.moves import range

def derivs_fd(a, order, eps=1.e-6):
  result = flex.vec3_double()
  sites0 = a.sites
  sites = [list(site) for site in sites0]
  for i_site in range(3):
    ds = []
    for i_dim in range(3):
      samples = []
      for signed_eps in [eps, -eps]:
        sites[i_site][i_dim] = sites0[i_site][i_dim] + signed_eps
        a_eps = angle(sites=sites, angle_ideal=a.angle_ideal, weight=a.weight)
        if (order == 1):
          samples.append(a_eps.residual())
        elif (order == 2):
          samples.append(a_eps.gradients()[i_site][i_dim])
        else:
          raise RuntimeError
      sites[i_site][i_dim] = sites0[i_site][i_dim]
      ds.append((samples[0]-samples[1])/(2*eps))
    result.append(tuple(ds))
  return result

def compare_derivs(out, ana, fin, expect_failure, eps=1.e-6):
  s = 1 / max(1, flex.max(flex.abs(ana.as_double())))
  print("  ana:", list(ana*s), file=out)
  print("  fin:", list(fin*s), file=out)
  if (not expect_failure):
    assert approx_equal(ana*s, fin*s, eps=eps)
  else:
    # This is to suppress output because it confuses testing functionality.
    # Apparently, it was never working and development was stopped long time ago.
    # To continue development/debugging - uncomment approx_equal
    pass
    # approx_equal(ana*s, fin*s, eps=eps)
  print(file=out)

def check_derivs(out, a, expect_failure=False):
  print("sites:", a.sites, file=out)
  print(file=out)
  gc = a.grads_and_curvs()
  print("grads:", a.sites, file=out)
  g_fd = derivs_fd(a=a, order=1)
  compare_derivs(out=out, ana=gc[:3], fin=g_fd, expect_failure=expect_failure)
  print("curvs:", a.sites, file=out)
  c_fd = derivs_fd(a=a, order=2)
  compare_derivs(out=out, ana=gc[3:], fin=c_fd, expect_failure=expect_failure)
  print(file=out)

def write_plots(method, rot_scale=2, rot_step=1, c_truncate_at=-2e4):
  assert method in ["ana", "fin"]
  plot_file_names = []
  site0 = (-1,0,0)
  site1 = (0,0,0)
  axis = matrix.col((0,0,1))
  for angle_ideal in [180, 120]:
    def init_plots():
      result = []
      for j in range(3):
        result.append([])
      return result
    g_plots = init_plots()
    c_plots = init_plots()
    for rot_deg_sc in range(90*rot_scale, 270*rot_scale+rot_step, rot_step):
      rot_deg = rot_deg_sc / rot_scale
      r = axis.axis_and_angle_as_r3_rotation_matrix(angle=rot_deg, deg=True)
      a = angle(
        sites=[site0, site1, r*site0],
        angle_ideal=angle_ideal,
        weight=1)
      if (method == "ana"):
        gc = a.grads_and_curvs()
      else:
        gc = derivs_fd(a=a, order=1)
        gc.extend(derivs_fd(a=a, order=2))
      for j in range(3):
        g_plots[j].append((rot_deg, gc[2][j]))
      for j in range(3):
        c_plots[j].append((rot_deg, gc[5][j]))
    def write(deriv, plots):
      file_name = "angle_%d_%s_%s.xy" % (angle_ideal, deriv, method)
      plot_file_names.append(file_name)
      with open(file_name, "w") as f:
        print("@with g0", file=f)
        print('@ title "%s ideal=%d method=%s"' % (
          deriv, angle_ideal, method), file=f)
        for j in range(3):
          print('@ s%d legend "%s"' % (j, "xyz"[j]), file=f)
        for plot in plots:
          for x,y in plot:
            if (deriv == "curv" and y < c_truncate_at): y = c_truncate_at
            print(x,y, file=f)
          print("&", file=f)
    write(deriv="grad", plots=g_plots)
    write(deriv="curv", plots=c_plots)
  return plot_file_names

def run(args):
  assert args in [[], ["--verbose"]]
  if (len(args) == 0):
    out = null_out()
  else:
    out = sys.stdout
  #
  mt = flex.mersenne_twister(seed=0)
  #
  for i_trial in range(10):
    l0 = mt.random_double() + 0.5
    l1 = mt.random_double() + 0.5
    l2 = mt.random_double() + 0.5
    angle_model = mt.random_double() * 178 + 1 \
                + 180 * (mt.random_size_t() % 3 - 1)
    v = matrix.col(mt.random_double_point_on_sphere())
    axis = v.ortho()
    site1 = v * l1
    site0 = site1 + v * l0
    r = axis.axis_and_angle_as_r3_rotation_matrix(angle=angle_model, deg=True)
    site2 = site1 + (r * v) * l2
    a = angle(
      sites=[site0, site1, site2],
      angle_ideal=mt.random_double() * 720 - 360,
      weight=mt.random_double() * 10 + 0.1)
    assert approx_equal(min(
      abs(angle_delta_deg(angle_1=a.angle_model, angle_2= angle_model)),
      abs(angle_delta_deg(angle_1=a.angle_model, angle_2=-angle_model))), 0)
    check_derivs(out=out, a=a)
  #
  for site2 in [(0,2.3,0), (0,0,2.5)]:
    perm = flex.size_t([0,1,2])
    while True:
      a = angle(
        sites=tuple(flex.vec3_double(
          [(1.2,0,0), (0,0,0), site2]).select(perm)),
        angle_ideal=mt.random_double() * 720 - 360,
        weight=mt.random_double() * 10 + 0.1)
      check_derivs(out=out, a=a)
      if (not perm.next_permutation()):
        break
  #
  for site0 in [(1,0,0),(0,1,0),(0,0,1),(1,1,1)]:
    perm = flex.size_t([0,1,2])
    while True:
      a = angle(
        sites=tuple(flex.vec3_double(
          [site0, (0,0,0), -matrix.col(site0)]).select(perm)),
        angle_ideal=180,
        weight=1.3)
      check_derivs(out=out, a=a, expect_failure=True)
      if (not perm.next_permutation()):
        break
  #
  plot_file_names = []
  for method in ["ana", "fin"]:
    plot_file_names.extend(write_plots(method=method))
  f = open("angle_xy_as_pdf_commands", "w")
  for file_name in plot_file_names:
    print("ppdf %s > %s" % (file_name, file_name.replace(".xy", ".pdf")), file=f)
  f.close()
  #
  print("OK")

if (__name__ == "__main__"):
  run(args=sys.argv[1:])


 *******************************************************************************


 *******************************************************************************
cctbx/geometry_restraints/tst_ext.py
from __future__ import absolute_import, division, print_function
from cctbx.array_family import flex
from cctbx import geometry_restraints
from cctbx import crystal
from cctbx import sgtbx
from cctbx import uctbx
from cctbx.crystal import direct_space_asu
from scitbx import matrix
from libtbx.test_utils import approx_equal, not_approx_equal, eps_eq, show_diff
from libtbx.utils import null_out
from six.moves import cStringIO as StringIO
import math
import sys
from six.moves import range
from six.moves import zip

def finite_difference_gradients(restraint_type, sites_cart, proxy, unit_cell=None, eps=1.e-8):
  def residual(restraint_type, sites_cart, proxy, unit_cell):
    if unit_cell is None:
      return restraint_type(
        sites_cart=sites_cart,
        proxy=proxy).residual()
    else:
      return restraint_type(
        unit_cell=unit_cell,
        sites_cart=sites_cart,
        proxy=proxy).residual()
  result = []
  for i in range(len(sites_cart)):
    result_i = []
    for j in range(3):
      h = [0,0,0]
      h[j] = eps
      h = matrix.col(h)
      sites_cart[i]=matrix.col(sites_cart[i]) + h
      qp = residual(restraint_type,sites_cart,proxy,unit_cell)
      sites_cart[i]=matrix.col(sites_cart[i]) - 2*h
      qm = residual(restraint_type,sites_cart,proxy,unit_cell)
      dq = (qp-qm)/2.0
      result_i.append(dq/(eps))
    result.append(result_i)
  return result

def exercise_bond_similarity():
  # test without symmetry operations
  i_seqs=((0,2),
          (1,3),
          (4,5))
  weights=(1,2,3)
  p = geometry_restraints.bond_similarity_proxy(
    i_seqs=i_seqs,
    weights=weights)
  assert tuple(p.i_seqs) == i_seqs
  assert approx_equal(p.weights, weights)
  assert p.sym_ops == None
  #
  expected_deltas = \
    (-0.033333333333333, 0.066666666666666, -0.033333333333333)
  expected_rms_deltas = math.sqrt(
    sum([delta * delta for delta in expected_deltas])
    /len(expected_deltas))
  expected_residual = sum([weights[i] * expected_deltas[i]
                          * expected_deltas[i]
                          for i in range(3)])\
                    / sum([w for w in weights])
  expected_gradients = (
    ((0,0,0.011111111111), (0,0,-0.011111111111)),
    ((0,-0.044444444444,0), (0,0.044444444444,0)),
    ((0.033333333333,0,0), (-0.033333333333,0,0)))
  sites_array=[
    ((1,2,3),(1,2,4.5)),((2,4,6),(2,5.6,6)),((4,14,19),(5.5,14,19))]
  b = geometry_restraints.bond_similarity(
    sites_array=sites_array,
    weights=weights)
  assert approx_equal(b.sites_array, sites_array)
  assert approx_equal(b.weights, weights)
  assert approx_equal(b.mean_distance(), 1.533333333333333)
  assert approx_equal(b.deltas(), expected_deltas)
  assert approx_equal(b.rms_deltas(), expected_rms_deltas)
  assert approx_equal(b.residual(), expected_residual)
  assert approx_equal(b.gradients(), expected_gradients)
  #
  sites_cart = flex.vec3_double(
    [(1,2,3),(2,4,6),(1,2,4.5),(2,5.6,6),(4,14,19),(5.5,14,19)])
  b = geometry_restraints.bond_similarity(
    sites_cart=sites_cart,
    proxy=p)
  assert approx_equal(b.sites_array, sites_array)
  assert approx_equal(b.weights, weights)
  assert approx_equal(b.mean_distance(), 1.533333333333333)
  assert approx_equal(b.deltas(), expected_deltas)
  assert approx_equal(b.rms_deltas(), expected_rms_deltas)
  assert approx_equal(b.residual(), expected_residual)
  assert approx_equal(b.gradients(), expected_gradients)
  # test with symmetry operations
  unit_mx = sgtbx.rt_mx()
  i_seqs=((0,2),
          (1,3),
          (4,5))
  sym_ops=(unit_mx,
           unit_mx,
           sgtbx.rt_mx('1+x,y,z'),)
  weights=(1,2,3)
  p = geometry_restraints.bond_similarity_proxy(
    i_seqs=i_seqs,
    sym_ops=sym_ops,
    weights=weights)
  assert tuple(p.i_seqs) == i_seqs
  assert tuple(p.sym_ops) == sym_ops
  assert approx_equal(p.weights, weights)
  #
  expected_deltas = \
    (-0.033333333333333, 0.066666666666666, -0.033333333333333)
  expected_rms_deltas = math.sqrt(
    sum([delta * delta for delta in expected_deltas])
    /len(expected_deltas))
  expected_residual = sum([weights[i] * expected_deltas[i]
                          * expected_deltas[i]
                          for i in range(3)])\
                    / sum([w for w in weights])
  expected_gradients = (
    ((0,0,0.011111111111), (0,0,-0.011111111111)),
    ((0,-0.044444444444,0), (0,0.044444444444,0)),
    ((0.033333333333,0,0), (-0.033333333333,0,0)))
  sites_array=[
    ((1,2,3),(1,2,4.5)),((2,4,6),(2,5.6,6)),((14,24,29),(15.5,24,29))]
  b = geometry_restraints.bond_similarity(
    sites_array=sites_array,
    weights=weights)
  assert approx_equal(b.sites_array, sites_array)
  assert approx_equal(b.weights, weights)
  assert approx_equal(b.mean_distance(), 1.533333333333333)
  assert approx_equal(b.deltas(), expected_deltas)
  assert approx_equal(b.rms_deltas(), expected_rms_deltas)
  assert approx_equal(b.residual(), expected_residual)
  assert approx_equal(b.gradients(), expected_gradients)
  #
  unit_cell = uctbx.unit_cell([15,25,30,90,90,90])
  sites_cart = flex.vec3_double(
    [(1,2,3),(2,4,6),(1,2,4.5),(2,5.6,6),(14,24,29),(0.5,24,29)])
  b = geometry_restraints.bond_similarity(
    unit_cell=unit_cell,
    sites_cart=sites_cart,
    proxy=p)
  assert approx_equal(b.sites_array, sites_array)
  assert approx_equal(b.weights, weights)
  assert approx_equal(b.mean_distance(), 1.533333333333333)
  assert approx_equal(b.deltas(), expected_deltas)
  assert approx_equal(b.rms_deltas(), expected_rms_deltas)
  assert approx_equal(b.residual(), expected_residual)
  assert approx_equal(b.gradients(), expected_gradients)
  #
  proxies = geometry_restraints.shared_bond_similarity_proxy([p,p])
  assert eps_eq(geometry_restraints.bond_similarity_residuals(
    unit_cell=unit_cell,
    sites_cart=sites_cart,
    proxies=proxies), [expected_residual]*2)
  assert eps_eq(geometry_restraints.bond_similarity_deltas_rms(
    unit_cell=unit_cell,
    sites_cart=sites_cart,
    proxies=proxies), [expected_rms_deltas]*2)
  residual_sum = geometry_restraints.bond_similarity_residual_sum(
    unit_cell=unit_cell,
    sites_cart=sites_cart,
    proxies=proxies,
    gradient_array=None)
  assert eps_eq(residual_sum, 2*expected_residual)
  gradient_array = flex.vec3_double(sites_cart.size(), (0,0,0))
  residual_sum = geometry_restraints.bond_similarity_residual_sum(
    unit_cell=unit_cell,
    sites_cart=sites_cart,
    proxies=proxies,
    gradient_array=gradient_array)
  assert eps_eq(residual_sum, 2*expected_residual)
  fd_grads = finite_difference_gradients(
    restraint_type=geometry_restraints.bond_similarity,
    unit_cell=unit_cell,
    sites_cart=sites_cart,
    proxy=p)
  for g,e in zip(gradient_array, fd_grads):
    assert approx_equal(g, matrix.col(e)*2)
  # check proxies with and without sym_ops are happy side-by-side
  p_sym = geometry_restraints.bond_similarity_proxy(
    i_seqs=i_seqs,
    sym_ops=sym_ops,
    weights=weights)
  assert p_sym.sym_ops == sym_ops
  restraint_sym = geometry_restraints.bond_similarity(
    unit_cell=unit_cell,
    sites_cart=sites_cart,
    proxy=p_sym)
  p_no_sym = geometry_restraints.bond_similarity_proxy(
    i_seqs=i_seqs,
    weights=weights)
  assert p_no_sym.sym_ops == None
  restraint_no_sym = geometry_restraints.bond_similarity(
    sites_cart=sites_cart,
    proxy=p_no_sym)
  proxies = geometry_restraints.shared_bond_similarity_proxy([p_sym,p_no_sym])
  assert approx_equal(geometry_restraints.bond_similarity_deltas_rms(
    unit_cell=unit_cell,
    sites_cart=sites_cart,
    proxies=proxies), [restraint_sym.rms_deltas(),restraint_no_sym.rms_deltas()])
  assert approx_equal(geometry_restraints.bond_similarity_residuals(
    unit_cell=unit_cell,
    sites_cart=sites_cart,
    proxies=proxies), [restraint_sym.residual(),restraint_no_sym.residual()])
  residual_sum = geometry_restraints.bond_similarity_residual_sum(
    unit_cell=unit_cell,
    sites_cart=sites_cart,
    proxies=proxies,
    gradient_array=None)
  assert approx_equal(residual_sum, restraint_sym.residual() + restraint_no_sym.residual())

def exercise_bond():
  def check_bpar(p, distance_ideal=3.5, weight=1, slack=0, limit=-1,
      top_out=False, origin_id=0):
    assert approx_equal(p.distance_ideal, distance_ideal)
    assert approx_equal(p.weight, weight)
    assert approx_equal(p.slack, slack)
    assert approx_equal(p.limit, limit)
    assert p.top_out == top_out
    assert p.origin_id == origin_id

  def check_bproxy(p, i_seqs=(0,1), sym_op=None, distance_ideal=3.5,
      weight=1, slack=0, limit=-1, top_out=False, origin_id=0):
    assert p.i_seqs == i_seqs
    if p.rt_mx_ji is not None:
      assert approx_equal(p.rt_mx_ji.as_double_array(), sym_op.as_double_array())
    else:
      assert sym_op is None
    assert approx_equal(p.distance_ideal, distance_ideal)
    assert approx_equal(p.weight, weight)
    assert approx_equal(p.slack, slack)
    assert approx_equal(p.limit, limit)
    assert p.top_out == top_out
    assert p.origin_id == origin_id

  p = geometry_restraints.bond_params(
    distance_ideal=3.5,
    weight=2,
    slack=2,
    limit=1,
    top_out=True,
    origin_id=2)
  check_bpar(p, weight=2, slack=2, limit=1, top_out=True, origin_id=2)
  p = geometry_restraints.bond_params(
    distance_ideal=3.5,
    weight=1)
  check_bpar(p)
  p.distance_ideal = 35
  p.weight = 10
  p.slack = 3
  p.limit = 3
  p.top_out = True
  p.origin_id = 3
  check_bpar(p, distance_ideal=35, weight=10, slack=3, limit=3,
      top_out=True, origin_id=3)
  p.distance_ideal = 3.5
  p.weight = 1
  p.slack = 0
  p.limit = -1.0
  p.top_out = False
  p.origin_id = 0
  check_bpar(p)
  #
  c = p.scale_weight(factor=2)
  check_bpar(p)
  check_bpar(c, weight=2)
  #
  t = geometry_restraints.bond_params_table()
  assert t.size() == 0
  d = geometry_restraints.bond_params_dict()
  assert len(d) == 0
  p = geometry_restraints.bond_params(distance_ideal=3, weight=2)
  d[10] = p
  check_bpar(d[10], distance_ideal=3, weight=2)
  t.append(d)
  t.append(d)
  check_bpar(t[1][10], distance_ideal=3, weight=2)
  t[0][13] = p
  check_bpar(t[0][13], distance_ideal=3, weight=2)
  t[0][13].distance_ideal = 5
  check_bpar(t[0][13], distance_ideal=5, weight=2)
  check_bpar(t[1][10], distance_ideal=3, weight=2)
  t[1][1] = geometry_restraints.bond_params(distance_ideal=4, weight=5,
      slack=2, limit=1, top_out=True, origin_id=2)
  while (t.size() < 14):
    t.append(geometry_restraints.bond_params_dict())
  s = t.proxy_select(iselection=flex.size_t([1]))
  check_bpar(s[0][0], distance_ideal=4, weight=5, slack=2, limit=1,
      top_out=True, origin_id=2)
  #
  check_bpar(t.lookup(13, 0), distance_ideal=5, weight=2)
  t.lookup(0, 13).weight = 48
  check_bpar(t.lookup(0, 13), distance_ideal=5, weight=48)
  t.lookup(13, 0).weight = 2
  #
  rest = t.proxy_remove(selection=flex.bool([True]*14))
  assert [p.size() for p in rest] == [0]*14
  rest = t.proxy_remove(selection=flex.bool([False]*14))
  assert [p.size() for p in rest] == [2,2]+[0]*12
  rest = t.proxy_remove(selection=flex.bool([False,True]+[False]*12))
  assert [p.size() for p in rest] == [2,1]+[0]*12
  rest = t.proxy_remove(
    selection=flex.bool([True,False]+[False]*8+[True]+[False]*3))
  assert [p.size() for p in rest] == [1,2]+[0]*12
  rest = t.proxy_remove(
    selection=flex.bool([True,True]+[False]*8+[True]+[False]*3))
  assert [p.size() for p in rest] == [1]+[0]*13
  #
  p = geometry_restraints.bond_params(distance_ideal=2.8, weight=2,
      slack=2, limit=1, top_out=True, origin_id=2)
  assert t[3].size() == 0
  t.update(i_seq=4, j_seq=3, params=p)
  assert t[3].size() == 1
  check_bpar(t[3][4], distance_ideal=2.8, weight=2, slack=2, limit=1,
      top_out=True, origin_id=2)
  p = geometry_restraints.bond_params(distance_ideal=3.8, weight=3)
  t.update(i_seq=3, j_seq=5, params=p)
  assert t[3].size() == 2
  assert approx_equal(t[3][5].distance_ideal, 3.8)
  p = geometry_restraints.bond_params(distance_ideal=1.8, weight=4)
  t.update(i_seq=3, j_seq=4, params=p)
  assert t[3].size() == 2
  check_bpar(t[3][4], distance_ideal=1.8, weight=4)
  #
  assert geometry_restraints.bond_params_table().mean_residual(1) == 0
  assert t.mean_residual(bond_stretch_factor=0) == 0
  assert approx_equal(t.mean_residual(0.5), 9.26166666667)
  assert approx_equal(t.mean_residual(1.0), 37.0466666667)
  assert approx_equal(t.mean_residual(2.0), 148.186666667)
  #
  p = geometry_restraints.bond_simple_proxy(
      i_seqs=[1,0], distance_ideal=3.5, weight=1)
  check_bproxy(p, i_seqs=(1,0))
  p = geometry_restraints.bond_simple_proxy(
      i_seqs=[1,0],
      distance_ideal=3.5,
      weight=1,
      slack=2,
      limit=1,
      top_out=True,
      origin_id=2)
  check_bproxy(p, i_seqs=(1,0), distance_ideal=3.5, weight=1, slack=2, limit=1,
      top_out=True, origin_id=2)
  p = p.sort_i_seqs()
  check_bproxy(p, i_seqs=(0,1), distance_ideal=3.5, weight=1, slack=2, limit=1,
      top_out=True, origin_id=2)
  p.distance_ideal = 35
  p.weight = 10
  p.slack = 3
  p.limit = 3
  p.top_out = True
  p.origin_id = 3
  check_bproxy(p, i_seqs=(0,1), distance_ideal=35, weight=10, slack=3, limit=3,
      top_out=True, origin_id=3)
  p.distance_ideal = 3.5
  p.weight = 1
  p.slack = 0
  p.limit = -1.0
  p.top_out = False
  p.origin_id = 0
  check_bproxy(p, i_seqs=(0,1))
  b = geometry_restraints.bond(
    sites=[(1,2,3),(2,4,6)],
    distance_ideal=3.5,
    weight=1)
  assert approx_equal(b.sites, [(1,2,3),(2,4,6)])
  assert approx_equal(b.distance_ideal, 3.5)
  assert approx_equal(b.weight, 1)
  assert approx_equal(b.slack, 0)
  assert approx_equal(b.limit, -1)
  assert not b.top_out
  assert approx_equal(b.origin_id, 0)
  assert approx_equal(b.distance_model**2, 14)
  assert approx_equal(b.delta, -0.241657386774)
  assert approx_equal(b.residual(), 0.0583982925824)
  assert approx_equal(b.gradients(),
    ((-0.12917130661302928, -0.25834261322605856, -0.38751391983908784),
     ( 0.12917130661302928,  0.25834261322605856,  0.38751391983908784)))
  b = geometry_restraints.bond(
      sites=[(1,2,3),(1,2,3)],
      distance_ideal=3.5,
      weight=1,
      slack=2,
      limit=1,
      top_out=True,
      origin_id=2)
  assert approx_equal(b.distance_model, 0)
  assert approx_equal(b.weight, 1)
  assert approx_equal(b.slack, 2)
  assert approx_equal(b.limit, 1)
  assert b.top_out
  assert approx_equal(b.origin_id, 2)
  assert approx_equal(b.gradients(), [(0,0,0), (0,0,0)])
  sites_cart = flex.vec3_double([(1,2,3),(2,4,6)])
  b = geometry_restraints.bond(
    sites_cart=sites_cart,
    proxy=p)
  assert approx_equal(b.sites, [(1,2,3),(2,4,6)])
  assert approx_equal(b.distance_ideal, 3.5)
  assert approx_equal(b.weight, 1)
  assert approx_equal(p.slack, 0)
  assert approx_equal(p.limit, -1)
  assert not p.top_out
  assert approx_equal(p.origin_id, 0)
  assert approx_equal(b.distance_model**2, 14)
  proxies = geometry_restraints.shared_bond_simple_proxy([p,p])
  for proxy in proxies:
    assert approx_equal(proxy.weight, 1)
    proxy.weight = 12
    assert approx_equal(proxy.slack, 0)
    proxy.slack = 3
    assert approx_equal(proxy.limit, -1)
    proxy.limit = 3
    assert not proxy.top_out
    proxy.top_out = True
    assert approx_equal(proxy.origin_id, 0)
    proxy.origin_id = 3
  for proxy in proxies:
    assert approx_equal(proxy.weight, 12)
    proxy.weight = 1
    assert approx_equal(proxy.slack, 3)
    proxy.slack = 0
    assert approx_equal(proxy.limit, 3)
    proxy.limit = -1.0
    assert proxy.top_out
    proxy.top_out = False
    assert approx_equal(proxy.origin_id, 3)
    proxy.origin_id = 0

  tab = geometry_restraints.extract_bond_params(
    n_seq=2, bond_simple_proxies=proxies)
  assert list(tab[0].keys()) == [1]
  # FIXME: if tab[0] is a dictionary, this might break py2/3 compat, order of values and keys changes depending on py 2/3
  assert approx_equal(list(tab[0].values())[0].distance_ideal, 3.5)
  assert approx_equal(list(tab[0].values())[0].weight, 1)
  assert list(tab[1].keys()) == []
  assert approx_equal(geometry_restraints.bond_distances_model(
    sites_cart=sites_cart,
    proxies=proxies), [14**0.5]*2)
  assert approx_equal(geometry_restraints.bond_deltas(
    sites_cart=sites_cart,
    proxies=proxies), [-0.241657386774]*2)
  assert approx_equal(geometry_restraints.bond_residuals(
    sites_cart=sites_cart,
    proxies=proxies), [0.0583982925824]*2)
  residual_sum = geometry_restraints.bond_residual_sum(
    sites_cart=sites_cart,
    proxies=proxies,
    gradient_array=None)
  assert approx_equal(residual_sum, 2*0.0583982925824)
  #
  for sym_op in (None, sgtbx.rt_mx("-y,z,x")):
    if sym_op is None:
      p = geometry_restraints.bond_simple_proxy(
        i_seqs=[1,0],
        distance_ideal=3.5,
        weight=1)
      check_bproxy(p, i_seqs=(1,0), sym_op=sym_op)
    else:
      for proxy_t in (geometry_restraints.bond_simple_proxy,
                      geometry_restraints.bond_sym_proxy):
        p = proxy_t(
          i_seqs=[1,0],
          rt_mx_ji=sgtbx.rt_mx("-y,z,x"),
          distance_ideal=3.5,
          weight=1, slack=2, limit=1, top_out=True, origin_id=2)
        check_bproxy(p, i_seqs=(1,0), sym_op=sym_op, slack=2, limit=1,
            top_out=True, origin_id=2)
  unit_cell = uctbx.unit_cell([15,25,30,90,90,90])
  sites_cart = flex.vec3_double([[1,2,3],[2,3,4]])
  b = geometry_restraints.bond(
    unit_cell=unit_cell,
    sites_cart=sites_cart,
    proxy=p)
  assert approx_equal(b.sites, [(2,3,4),(-1.2,2.5,2)])
  assert approx_equal(b.distance_ideal, 3.5)
  assert approx_equal(b.weight, 1)
  assert approx_equal(b.distance_model**2, 14.49)
  assert approx_equal(p.slack, 2)
  assert approx_equal(p.limit, 1)
  assert p.top_out
  assert approx_equal(p.origin_id, 2)
  #
  sites_cart = flex.vec3_double([[1,2,3],[2,3,4]])
  asu_mappings = direct_space_asu.non_crystallographic_asu_mappings(
    sites_cart=sites_cart)
  pair_generator = crystal.neighbors_fast_pair_generator(
    asu_mappings=asu_mappings,
    distance_cutoff=5)
  p = geometry_restraints.bond_asu_proxy(
      pair=next(pair_generator),
      distance_ideal=2,
      weight=10, slack=2, limit=1, top_out=True, origin_id=2)
  p = geometry_restraints.bond_asu_proxy(pair=p, params=p)
  assert pair_generator.at_end()
  assert p.i_seq == 0
  assert p.j_seq == 1
  assert p.j_sym == 0
  assert approx_equal(p.distance_ideal, 2)
  assert approx_equal(p.weight, 10)
  assert approx_equal(p.slack, 2)
  assert approx_equal(p.limit, 1)
  assert p.top_out
  assert approx_equal(p.origin_id, 2)
  p.distance_ideal = 35
  assert approx_equal(p.distance_ideal, 35)
  p.distance_ideal = 2
  assert approx_equal(p.distance_ideal, 2)
  p.weight = 1
  assert approx_equal(p.weight, 1)
  p.weight = 10
  assert approx_equal(p.weight, 10)
  p.slack = 3
  assert approx_equal(p.slack, 3)
  p.slack = 0
  assert approx_equal(p.slack, 0)
  p.limit = 3
  assert approx_equal(p.limit, 3)
  p.limit = -1.0
  assert approx_equal(p.limit, -1)
  p.top_out = True
  assert p.top_out
  p.top_out = False
  assert not p.top_out
  p.origin_id = 3
  assert approx_equal(p.origin_id, 3)
  p.origin_id = 0
  assert approx_equal(p.origin_id, 0)
  assert p.as_simple_proxy().i_seqs == (0,1)
  assert approx_equal(p.as_simple_proxy().distance_ideal, 2)
  assert approx_equal(p.as_simple_proxy().weight, 10)
  sym_proxies = geometry_restraints.shared_bond_asu_proxy([p,p])
  for proxy in sym_proxies:
    assert approx_equal(proxy.distance_ideal, 2)
    proxy.distance_ideal = -4
  for proxy in sym_proxies:
    assert approx_equal(proxy.distance_ideal, -4)
    proxy.distance_ideal = 2
  sorted_asu_proxies = geometry_restraints.bond_sorted_asu_proxies(
    asu_mappings=asu_mappings)
  sorted_asu_proxies.process(proxies=sym_proxies)
  assert approx_equal(
    geometry_restraints.bond_distances_model(
      sites_cart=sites_cart,
      sorted_asu_proxies=sorted_asu_proxies),
    [3**.5]*2)
  assert approx_equal(
    geometry_restraints.bond_deltas(
      sites_cart=sites_cart,
      sorted_asu_proxies=sorted_asu_proxies),
    [2-3**.5]*2)
  assert approx_equal(
    geometry_restraints.bond_residuals(
      sites_cart=sites_cart,
      sorted_asu_proxies=sorted_asu_proxies),
    [10*(2-3**.5)**2]*2)
  assert approx_equal(
    geometry_restraints.bond_residual_sum(
      sites_cart=sites_cart,
      sorted_asu_proxies=sorted_asu_proxies,
      gradient_array=None),
    (10*(2-3**.5)**2)*2)
  gradient_array = flex.vec3_double(2, [0,0,0])
  assert approx_equal(
    geometry_restraints.bond_residual_sum(
      sites_cart=sites_cart,
      sorted_asu_proxies=sorted_asu_proxies,
      gradient_array=gradient_array),
    (10*(2-3**.5)**2)*2)
  assert approx_equal(gradient_array,
    [[ 6.1880215351700611]*3,
     [-6.1880215351700611]*3])
  for disable_cache in [False, True]:
    gradient_array = flex.vec3_double(2, [0,0,0])
    assert approx_equal(
      geometry_restraints.bond_residual_sum(
        sites_cart=sites_cart,
        sorted_asu_proxies=sorted_asu_proxies,
        gradient_array=gradient_array,
        disable_cache=disable_cache),
      (10*(2-3**.5)**2)*2)
    assert approx_equal(gradient_array,
      [[ 6.1880215351700611]*3,
       [-6.1880215351700611]*3])
  #
  for p in geometry_restraints.shared_bond_simple_proxy(size=2):
    assert p.distance_ideal == 0
    assert p.weight == 0
    assert p.slack == 0
    assert p.i_seqs == (0,0)
  #
  sorted_asu_proxies = geometry_restraints.bond_sorted_asu_proxies(
    asu_mappings=asu_mappings)
  sorted_asu_proxies.push_back(proxy=sym_proxies[0])
  assert sorted_asu_proxies.simple.size() == 0
  assert sorted_asu_proxies.asu.size() == 1
  sorted_asu_proxies = geometry_restraints.bond_sorted_asu_proxies(
    asu_mappings=asu_mappings)
  sorted_asu_proxies.process(proxy=proxies[0])
  sorted_asu_proxies.process(proxy=sym_proxies[0])
  assert sorted_asu_proxies.simple.size() == 2
  assert sorted_asu_proxies.asu.size() == 0
  assert sorted_asu_proxies.n_total() == 2
  residual_0 = geometry_restraints.bond(
    sites_cart=sites_cart,
    proxy=proxies[0]).residual()
  residual_1 = geometry_restraints.bond(
    sites_cart=sites_cart,
    asu_mappings=asu_mappings,
    proxy=sym_proxies[0]).residual()
  assert approx_equal(residual_1, 10*(2-3**.5)**2)
  gradient_array = flex.vec3_double(2, [0,0,0])
  assert approx_equal(geometry_restraints.bond_residual_sum(
    sites_cart=sites_cart,
    sorted_asu_proxies=sorted_asu_proxies,
    gradient_array=gradient_array), residual_0+residual_1)
  assert approx_equal(gradient_array,
    [(5.1354626519124107, 5.1354626519124107, 5.1354626519124107),
     (-5.1354626519124107, -5.1354626519124107, -5.1354626519124107)])
  sorted_asu_proxies.process(sorted_asu_proxies.simple.deep_copy())
  assert sorted_asu_proxies.simple.size() == 4
  sorted_asu_proxies.process(sorted_asu_proxies.asu.deep_copy())
  assert sorted_asu_proxies.asu.size() == 0
  sorted_asu_proxies.push_back(sorted_asu_proxies.asu.deep_copy())
  assert sorted_asu_proxies.asu.size() == 0
  #
  pair_asu_table = crystal.pair_asu_table(asu_mappings=asu_mappings)
  assert list(pair_asu_table.table()[0].keys()) == []
  geometry_restraints.add_pairs(
    pair_asu_table=pair_asu_table,
    bond_simple_proxies=proxies)
  assert list(pair_asu_table.table()[0].keys()) == [1]
  #
  pair_asu_table = crystal.pair_asu_table(asu_mappings=asu_mappings)
  sorted_asu_proxies = geometry_restraints.bond_sorted_asu_proxies(
    pair_asu_table=pair_asu_table)
  assert sorted_asu_proxies.simple.size() == 0
  assert sorted_asu_proxies.asu.size() == 0
  pair_asu_table.add_all_pairs(distance_cutoff=2)
  sorted_asu_proxies = geometry_restraints.bond_sorted_asu_proxies(
    pair_asu_table=pair_asu_table)
  assert sorted_asu_proxies.simple.size() == 1
  assert sorted_asu_proxies.asu.size() == 0
  #
  def sign(x):
    if (x < 0): return -1
    return 1
  mt = flex.mersenne_twister(seed=0)
  for slack in [0, 1/3., 2/3., 1]:
    for ish in range(9):
      sh = ish / 2.
      site1 = matrix.col((1,2,3)) \
            + sh * matrix.col(mt.random_double_point_on_sphere())
      b = geometry_restraints.bond(
        sites=[(1,2,3),site1],
        distance_ideal=2,
        weight=1,
        slack=slack)
      assert approx_equal(b.distance_model, sh)
      assert approx_equal(
        b.delta_slack,
        sign(b.delta) * max(0, (abs(b.delta) - b.slack)))
      #
      for i in range(3):
        rs = []
        eps = 1.e-6
        for signed_eps in [eps, -eps]:
          site0 = [1,2,3]
          site0[i] += signed_eps
          be = geometry_restraints.bond(
            sites=[site0,site1],
            distance_ideal=2,
            weight=1,
            slack=slack)
          rs.append(be.residual())
        g_fin = (rs[0]-rs[1])/(2*eps)
        g_ana = b.gradients()[0][i]
        assert approx_equal(g_ana, g_fin)

  #
  sites_cart = flex.vec3_double([(1,2,3),(2,3,4)])
  gradients_inp = flex.vec3_double([(10,20,30),(20,30,40)])
  site_symmetry_table_indices = flex.size_t([0,1])
  home_sites_cart = flex.vec3_double([(1.1,1.9,3.05),(2.1,3.2,4.3)])
  iselection = flex.size_t([0,1])
  def get(weight, slack, no_grads=False, no_site_sym=False):
    gradients = None
    if (not no_grads):
      gradients = gradients_inp.deep_copy()
    site_sym = None
    if (not no_site_sym):
      site_sym = site_symmetry_table_indices
    residual_sum = geometry_restraints \
      .home_restraints_summation_skip_special_positions(
        sites_cart=sites_cart,
        gradients=gradients,
        site_symmetry_table_indices=site_sym,
        home_sites_cart=home_sites_cart,
        iselection=iselection,
        weight=weight,
        slack=slack)
    if (not no_grads):
      return [residual_sum, gradients]
    return residual_sum
  assert approx_equal(get(1, 0),
    [0.0225, [(9.8,20.2,29.9), (20,30,40)]])
  assert approx_equal(get(1, 0, True), 0.0225)
  assert approx_equal(get(1, 0, True, True), 0.1625)
  assert approx_equal(get(1, 0, False, True),
    [0.1625, [(9.8,20.2,29.9), (19.8,29.6,39.4)]])
  assert approx_equal(get(3, 0),
    [0.0675, [(9.4,20.6,29.7), (20,30,40)]])
  assert approx_equal(get(1, 3),
    [0.0, [(10,20,30), (20,30,40)]])
  site_symmetry_table_indices = flex.size_t([1,0])
  assert approx_equal(get(1, 0),
    [0.14, [(10,20,30), (19.8,29.6,39.4)]])
  site_symmetry_table_indices = flex.size_t([0,0])
  iselection = flex.size_t([1])
  assert approx_equal(get(1, 0),
    [0.14, [(10,20,30), (19.8,29.6,39.4)]])
  iselection = flex.size_t([])
  assert approx_equal(get(1, 0),
    [0.0, [(10,20,30), (20,30,40)]])
  iselection = flex.size_t([0,1])
  # top_out potential
  sites = [[0,0,0],[1.5,0,0]]
  proxy1 = geometry_restraints.bond_simple_proxy(
    i_seqs=[0,1],
    distance_ideal=1.5,
    weight=400)
  proxy2 = geometry_restraints.bond_simple_proxy(
    i_seqs=[0,1],
    distance_ideal=1.5,
    weight=400,
    limit=0.6,
    top_out=True)
  for i in range(200):
    sites[1][0] = 1.5 + 0.01 * (i - 100)
    sites_cart = flex.vec3_double(sites) # XXX why isn't this automatic?
    bond1 = geometry_restraints.bond(sites_cart, proxy1)
    bond2 = geometry_restraints.bond(sites_cart, proxy2)
    res1 = bond1.residual()
    res2 = bond2.residual()
    if (i <= 100):
      assert (res1 == res2)
    else :
      assert (res2 < res1)
    grads_fd = finite_difference_gradients(geometry_restraints.bond,
      sites_cart, proxy2)
    grads_an = bond2.gradients()
    assert approx_equal(grads_fd, grads_an, eps=0.0001)

class py_nonbonded_cos(object): # prototype

  def __init__(self, max_residual, exponent=1):
    self.max_residual = max_residual
    self.exponent = exponent

  def residual_and_gradients(self, proxy, sites_cart, gradient_array=None):
    vdw_distance = proxy.vdw_distance
    i, j = proxy.i_seqs
    diff_vec = matrix.col(sites_cart[i]) - matrix.col(sites_cart[j])
    d = abs(diff_vec)
    if (d >= vdw_distance): return 0
    x = d / vdw_distance
    m = self.max_residual
    e = self.exponent
    pi = math.pi
    pix = pi * x
    cpixpo = math.cos(pix) + 1
    result = m * (cpixpo/2)**e
    if (gradient_array is not None and d != 0):
      """
      r=m ((Cos[Pi x]+1)/2)^e
      g=D[r,x]
      """
      drdx = -(e*m*pi*cpixpo**(e-1)*math.sin(pix)) / 2**e
      drdd = drdx / vdw_distance
      gradient_0 = diff_vec * drdd / d
      gradient_array[i] = matrix.col(gradient_array[i]) + gradient_0
      gradient_array[j] = matrix.col(gradient_array[j]) - gradient_0
    return result

def nb_cos_finite_difference_gradients(nbf, proxy, sites_cart, eps=1.e-6):
  result = []
  for i in proxy.i_seqs:
    sc = list(sites_cart[i])
    for c in range(3):
      scc0 = sc[c]
      rs = []
      for signed_eps in [eps, -eps]:
        sc[c] = scc0 + signed_eps
        sites_cart[i] = sc
        rs.append(nbf.residual_and_gradients(
          proxy=proxy,
          sites_cart=sites_cart))
      sc[c] = scc0
      result.append((rs[0]-rs[1])/(2*eps))
    sites_cart[i] = sc
  return flex.vec3_double(flex.double(result))

def exercise_nonbonded_cos(verbose=0):
  if (verbose): log = sys.stdout
  else: log = null_out()
  for exponent in [1, 2, 1.5]:
    nbf = py_nonbonded_cos(max_residual=13, exponent=exponent)
    sites_cart = flex.vec3_double([(1,2,3), (0.3,2.4,3.5)])
    proxy = geometry_restraints.nonbonded_simple_proxy(
      i_seqs=(0,1), vdw_distance=2)
    gradient_array = flex.vec3_double(2, (0,0,0))
    r = nbf.residual_and_gradients(
      proxy=proxy,
      sites_cart=sites_cart,
      gradient_array=gradient_array)
    fd_grads = nb_cos_finite_difference_gradients(
      nbf=nbf, proxy=proxy, sites_cart=sites_cart)
    print(list(gradient_array), file=log)
    print(list(fd_grads), file=log)
    assert approx_equal(gradient_array, fd_grads)
    nc = geometry_restraints.nonbonded_cos(
      sites=list(sites_cart),
      vdw_distance=proxy.vdw_distance,
      function=geometry_restraints.cos_repulsion_function(
        max_residual=nbf.max_residual, exponent=nbf.exponent))
    assert approx_equal(nc.residual(), r)
    print(nc.gradients(), file=log)
    assert approx_equal(nc.gradients(), gradient_array)
    print(file=log)
    sc0 = matrix.col(sites_cart[0])
    v01 = matrix.col(sites_cart[1]) - sc0
    v01 *= 1/abs(v01)
    for i in range(21,-1,-1):
      for eps in [0, 1.e-3, -1.e-3]:
        d = i/10 + eps
        sites_cart[1] = sc0 + d * v01
        gradient_array = flex.vec3_double(2, (0,0,0))
        r = nbf.residual_and_gradients(
          proxy=proxy,
          sites_cart=sites_cart,
          gradient_array=gradient_array)
        print("d, r:", d, r, file=log)
        if (d == 2):
          assert abs(r) <= 1.e-8
        else:
          fd_grads = nb_cos_finite_difference_gradients(
            nbf=nbf, proxy=proxy, sites_cart=sites_cart)
          print(list(gradient_array), file=log)
          print(list(fd_grads), file=log)
          assert approx_equal(gradient_array, fd_grads)
          nc = geometry_restraints.nonbonded_cos(
            sites=list(sites_cart),
            vdw_distance=proxy.vdw_distance,
            function=geometry_restraints.cos_repulsion_function(
              max_residual=nbf.max_residual, exponent=nbf.exponent))
          assert approx_equal(nc.residual(), r)
          print(nc.gradients(), file=log)
          assert approx_equal(nc.gradients(), gradient_array)
          print(file=log)

def exercise_nonbonded():
  params = geometry_restraints.nonbonded_params()
  assert params.distance_table.size() == 0
  assert params.radius_table.size() == 0
  assert approx_equal(params.factor_1_4_interactions, 2/3.)
  assert approx_equal(params.const_shrink_1_4_interactions, 0)
  assert approx_equal(params.default_distance, 0)
  assert approx_equal(params.minimum_distance, 0)
  params = geometry_restraints.nonbonded_params(
    factor_1_4_interactions=.5,
    const_shrink_1_4_interactions=.1,
    default_distance=1,
    minimum_distance=2)
  assert approx_equal(params.factor_1_4_interactions, .5)
  assert approx_equal(params.const_shrink_1_4_interactions, .1)
  assert approx_equal(params.default_distance, 1)
  assert approx_equal(params.minimum_distance, 2)
  params.factor_1_4_interactions = .4
  assert approx_equal(params.factor_1_4_interactions, .4)
  params.const_shrink_1_4_interactions = .2
  assert approx_equal(params.const_shrink_1_4_interactions, .2)
  params.default_distance = .3
  assert approx_equal(params.default_distance, .3)
  params.minimum_distance = .6
  assert approx_equal(params.minimum_distance, .6)
  #
  p = geometry_restraints.nonbonded_simple_proxy(
    i_seqs=[0,1],
    vdw_distance=5)
  assert p.i_seqs == (0,1)
  assert p.rt_mx_ji is None
  assert approx_equal(p.vdw_distance, 5)
  ps = geometry_restraints.nonbonded_simple_proxy(
    i_seqs=[2,3],
    rt_mx_ji=sgtbx.rt_mx("y,y-x,0.5+Z"),
    vdw_distance=4)
  assert ps.i_seqs == (2,3)
  assert str(ps.rt_mx_ji) == "y,-x+y,z+1/2"
  assert approx_equal(ps.vdw_distance, 4)
  r = geometry_restraints.nonbonded_prolsq(
    sites=[(1,2,3),(2,4,6)],
    vdw_distance=5,
    function=geometry_restraints.prolsq_repulsion_function())
  assert approx_equal(r.sites, [(1,2,3),(2,4,6)])
  assert approx_equal(r.vdw_distance, 5)
  assert approx_equal(r.function.c_rep, 16)
  assert approx_equal(r.delta, 3.74165738677)
  assert approx_equal(r.residual(), 40.1158130612)
  assert approx_equal(r.gradients(),
    [(34.081026602378813, 68.162053204757626, 102.24307980713644),
     (-34.081026602378813, -68.162053204757626, -102.24307980713644)])
  sites_cart = flex.vec3_double([(1,2,3),(2,4,6)])
  r = geometry_restraints.nonbonded_prolsq(
    sites_cart=sites_cart,
    proxy=p,
    function=geometry_restraints.prolsq_repulsion_function())
  assert approx_equal(r.sites, [(1,2,3),(2,4,6)])
  assert approx_equal(r.vdw_distance, 5)
  assert approx_equal(r.function.c_rep, 16)
  assert approx_equal(r.delta, 3.74165738677)
  proxies = geometry_restraints.shared_nonbonded_simple_proxy([p,p])
  for proxy in proxies:
    assert approx_equal(proxy.vdw_distance, 5)
  assert approx_equal(geometry_restraints.nonbonded_deltas(
      sites_cart=sites_cart,
      proxies=proxies),
    [3.74165738677]*2)
  assert approx_equal(geometry_restraints.nonbonded_residuals(
      sites_cart=sites_cart,
      proxies=proxies,
      function=geometry_restraints.prolsq_repulsion_function()),
    [40.1158130612]*2)
  assert approx_equal(geometry_restraints.nonbonded_residuals(
      sites_cart=sites_cart,
      proxies=proxies,
      function=geometry_restraints.inverse_power_repulsion_function(10)),
    [1.3363062095621219]*2)
  assert approx_equal(geometry_restraints.nonbonded_residuals(
      sites_cart=sites_cart,
      proxies=proxies,
      function=geometry_restraints.cos_repulsion_function(max_residual=13)),
    [1.9279613709216095]*2)
  assert approx_equal(geometry_restraints.nonbonded_residuals(
      sites_cart=sites_cart,
      proxies=proxies,
      function=geometry_restraints.gaussian_repulsion_function(
        max_residual=12, norm_height_at_vdw_distance=0.2)),
    [4.8725695136639997]*2)
  residual_sum = geometry_restraints.nonbonded_residual_sum(
    sites_cart=sites_cart,
    proxies=proxies,
    gradient_array=None,
    function=geometry_restraints.prolsq_repulsion_function())
  assert approx_equal(residual_sum, 2*40.1158130612)
  residual_sum = geometry_restraints.nonbonded_residual_sum(
    sites_cart=sites_cart,
    proxies=proxies,
    gradient_array=None,
    function=geometry_restraints.inverse_power_repulsion_function(10))
  assert approx_equal(residual_sum, 2*1.3363062095621219)
  residual_sum = geometry_restraints.nonbonded_residual_sum(
    sites_cart=sites_cart,
    proxies=proxies,
    gradient_array=None,
    function=geometry_restraints.cos_repulsion_function(max_residual=13))
  assert approx_equal(residual_sum, 2*1.9279613709216095)
  residual_sum = geometry_restraints.nonbonded_residual_sum(
    sites_cart=sites_cart,
    proxies=proxies,
    gradient_array=None,
    function=geometry_restraints.gaussian_repulsion_function(
      max_residual=12, norm_height_at_vdw_distance=0.2))
  assert approx_equal(residual_sum, 2*4.8725695136639997)
  #
  sites_cart = flex.vec3_double([[1,2,3],[2,3,4]])
  asu_mappings = direct_space_asu.non_crystallographic_asu_mappings(
    sites_cart=sites_cart)
  pair_generator = crystal.neighbors_fast_pair_generator(
    asu_mappings=asu_mappings,
    distance_cutoff=5)
  p = geometry_restraints.nonbonded_asu_proxy(
    pair=next(pair_generator),
    vdw_distance=2)
  assert pair_generator.at_end()
  assert p.i_seq == 0
  assert p.j_seq == 1
  assert p.j_sym == 0
  assert approx_equal(p.vdw_distance, 2)
  p.vdw_distance = 3
  assert approx_equal(p.vdw_distance, 3)
  p.vdw_distance = 2
  sym_proxies = geometry_restraints.shared_nonbonded_asu_proxy([p,p])
  for proxy in sym_proxies:
    assert approx_equal(proxy.vdw_distance, 2)
    proxy.vdw_distance = 3
  for proxy in sym_proxies:
    assert approx_equal(proxy.vdw_distance, 3)
    proxy.vdw_distance = 2
  f = geometry_restraints.prolsq_repulsion_function(
    c_rep=1, k_rep=4, irexp=2, rexp=3)
  assert approx_equal(f.c_rep, 1)
  assert approx_equal(f.k_rep, 4)
  assert approx_equal(f.irexp, 2)
  assert approx_equal(f.rexp, 3)
  assert approx_equal(f.residual(vdw_distance=3, delta=2.9), 2492774.43588)
  assert approx_equal(f.residual(vdw_distance=3, delta=3), 2460375.0)
  r = geometry_restraints.nonbonded_prolsq(
    sites=list(sites_cart),
    vdw_distance=p.vdw_distance,
    function=f)
  assert approx_equal(r.function.c_rep, 1)
  assert approx_equal(r.diff_vec, [-1,-1,-1])
  assert approx_equal(r.delta**2, 3)
  assert approx_equal(r.residual(), 226981)
  assert approx_equal(r.gradients(),
    [(22326.0, 22326.0, 22326.0), (-22326.0, -22326.0, -22326.0)])
  f = geometry_restraints.prolsq_repulsion_function()
  assert approx_equal(f.residual(vdw_distance=3, delta=2.9), 0.0016)
  assert approx_equal(f.residual(vdw_distance=3, delta=3), 0)
  r = geometry_restraints.nonbonded_prolsq(
    sites=list(sites_cart),
    vdw_distance=p.vdw_distance,
    function=f)
  assert approx_equal(r.function.c_rep, 16)
  assert approx_equal(r.function.k_rep, 1)
  assert approx_equal(r.function.irexp, 1)
  assert approx_equal(r.function.rexp, 4)
  assert approx_equal(r.diff_vec, [-1,-1,-1])
  assert approx_equal(r.delta**2, 3)
  assert approx_equal(r.residual(), 0.0824764182859)
  assert approx_equal(r.gradients(),
    [(0.71084793153727288, 0.71084793153727288, 0.71084793153727288),
     (-0.71084793153727288, -0.71084793153727288, -0.71084793153727288)])
  #
  assert approx_equal(f.residual(vdw_distance=3, delta=2.9), 0.0016)
  assert approx_equal(f.residual(vdw_distance=3, delta=3), 0)
  for irexp in [1,2,3,4,5]:
    f = geometry_restraints.inverse_power_repulsion_function(
      nonbonded_distance_cutoff=100,
      k_rep=4,
      irexp=irexp)
    assert approx_equal(f.k_rep, 4)
    assert approx_equal(f.irexp, irexp)
    if (irexp == 1):
      assert approx_equal(f.residual(vdw_distance=3, delta=2.9), 4.13793103448)
      assert approx_equal(f.residual(vdw_distance=3, delta=3), 4)
    r = geometry_restraints.nonbonded_inverse_power(
      sites=list(sites_cart),
      vdw_distance=p.vdw_distance,
      function=f)
    assert approx_equal(r.diff_vec, [-1,-1,-1])
    assert approx_equal(r.delta**2, 3)
    assert approx_equal(r.residual(), f.k_rep*p.vdw_distance/r.delta**f.irexp)
    g = -f.irexp*f.k_rep*p.vdw_distance/(r.delta**(f.irexp+1))/r.delta
    assert approx_equal(r.gradients(), [(-g,-g,-g),(g,g,g)])
  for nonbonded_distance_cutoff in [1,2]:
    f = geometry_restraints.inverse_power_repulsion_function(
      nonbonded_distance_cutoff=nonbonded_distance_cutoff,
      k_rep=4,
      irexp=2)
    r = geometry_restraints.nonbonded_inverse_power(
      sites=list(sites_cart),
      vdw_distance=p.vdw_distance,
      function=f)
    if (nonbonded_distance_cutoff == 1):
      assert approx_equal(r.residual(), 0)
      assert approx_equal(r.gradients(), [(0,0,0),(0,0,0)])
    else:
      assert not_approx_equal(r.residual(), 0)
      assert not_approx_equal(r.gradients(), [(0,0,0),(0,0,0)])
  #
  for exponent in [1,2,3]:
    f = geometry_restraints.cos_repulsion_function(
      max_residual=13,
      exponent=exponent)
    assert approx_equal(f.max_residual, 13)
    assert approx_equal(f.exponent, exponent)
    if (exponent == 1):
      assert approx_equal(
        f.residual(vdw_distance=3, delta=2.9), 0.0356076801062)
      assert approx_equal(f.residual(vdw_distance=3, delta=3), 0)
    r = geometry_restraints.nonbonded_cos(
      sites=list(sites_cart),
      vdw_distance=p.vdw_distance,
      function=f)
    assert approx_equal(r.diff_vec, [-1,-1,-1])
    assert approx_equal(r.delta**2, 3)
    pynbc = py_nonbonded_cos(max_residual=f.max_residual, exponent=f.exponent)
    gradient_array = flex.vec3_double(sites_cart.size(), (0,0,0))
    pr = pynbc.residual_and_gradients(
      proxy=geometry_restraints.nonbonded_simple_proxy(
        i_seqs=(0,1), vdw_distance=r.vdw_distance),
      sites_cart=sites_cart,
      gradient_array=gradient_array)
    assert approx_equal(r.residual(), pr)
    assert approx_equal(r.gradients(), gradient_array)
  #
  expected_residuals = iter([
    1.39552236695,
    2.66705891104,
    3.89565157972])
  expected_gradients = iter([
    2.45678379644,
    2.88800522497,
    2.92825483126])
  for norm_height_at_vdw_distance in [0.1, 0.2, 0.3]:
    f = geometry_restraints.gaussian_repulsion_function(
      max_residual=12,
      norm_height_at_vdw_distance=norm_height_at_vdw_distance)
    assert approx_equal(f.max_residual, 12)
    assert approx_equal(
      f.norm_height_at_vdw_distance(), norm_height_at_vdw_distance)
    assert approx_equal(
      f.residual(vdw_distance=3, delta=3), 12*norm_height_at_vdw_distance)
    assert approx_equal(
      f.residual(vdw_distance=3, delta=2.9), next(expected_residuals))
    r = geometry_restraints.nonbonded_gaussian(
      sites=list(sites_cart),
      vdw_distance=p.vdw_distance,
      function=f)
    assert approx_equal(r.diff_vec, [-1,-1,-1])
    assert approx_equal(r.delta**2, 3)
    e = next(expected_gradients)
    assert approx_equal(r.gradients(), [[e]*3,[-e]*3])
  #
  sorted_asu_proxies = geometry_restraints.nonbonded_sorted_asu_proxies(
    asu_mappings=asu_mappings)
  sorted_asu_proxies.process(proxies=sym_proxies)
  assert approx_equal(
    flex.pow2(geometry_restraints.nonbonded_deltas(
      sites_cart=sites_cart,
      sorted_asu_proxies=sorted_asu_proxies)),
    [3]*2)
  assert approx_equal(
    geometry_restraints.nonbonded_residuals(
      sites_cart=sites_cart,
      sorted_asu_proxies=sorted_asu_proxies,
      function=geometry_restraints.prolsq_repulsion_function()),
    [0.0824764182859]*2)
  assert approx_equal(
    geometry_restraints.nonbonded_residual_sum(
      sites_cart=sites_cart,
      sorted_asu_proxies=sorted_asu_proxies,
      gradient_array=None,
      function=geometry_restraints.prolsq_repulsion_function()),
    0.0824764182859*2)
  for disable_cache in [False, True]:
    gradient_array = flex.vec3_double(2, [0,0,0])
    assert approx_equal(
      geometry_restraints.nonbonded_residual_sum(
        sites_cart=sites_cart,
        sorted_asu_proxies=sorted_asu_proxies,
        gradient_array=gradient_array,
        function=geometry_restraints.prolsq_repulsion_function(),
        disable_cache=disable_cache),
      0.0824764182859*2)
    assert approx_equal(gradient_array,
      [(1.4216958630745458, 1.4216958630745458, 1.4216958630745458),
       (-1.4216958630745458, -1.4216958630745458, -1.4216958630745458)])
  #
  sorted_asu_proxies = geometry_restraints.nonbonded_sorted_asu_proxies(
    asu_mappings=asu_mappings)
  sorted_asu_proxies.process(proxy=proxies[0])
  sorted_asu_proxies.process(proxy=sym_proxies[0], sym_excl_flag=False)
  assert sorted_asu_proxies.simple.size() == 2
  assert sorted_asu_proxies.asu.size() == 0
  assert sorted_asu_proxies.n_total() == 2
  residual_0 = geometry_restraints.nonbonded_prolsq(
    sites_cart=sites_cart,
    proxy=proxies[0],
    function=geometry_restraints.prolsq_repulsion_function()).residual()
  residual_1 = geometry_restraints.nonbonded_prolsq(
    sites_cart=sites_cart,
    asu_mappings=asu_mappings,
    proxy=sym_proxies[0],
    function=geometry_restraints.prolsq_repulsion_function()).residual()
  gradient_array = flex.vec3_double(2, [0,0,0])
  assert approx_equal(geometry_restraints.nonbonded_residual_sum(
      sites_cart=sites_cart,
      sorted_asu_proxies=sorted_asu_proxies,
      gradient_array=gradient_array,
      function=geometry_restraints.prolsq_repulsion_function()),
    residual_0+residual_1)
  assert approx_equal(gradient_array,
    [(1290.2817767146657, 1290.2817767146657, 1290.2817767146657),
     (-1290.2817767146657, -1290.2817767146657, -1290.2817767146657)])
  sorted_asu_proxies.process(sorted_asu_proxies.simple.deep_copy())
  assert sorted_asu_proxies.simple.size() == 4
  sorted_asu_proxies.process(sorted_asu_proxies.asu.deep_copy())
  assert sorted_asu_proxies.asu.size() == 0
  #
  f = geometry_restraints.prolsq_repulsion_function()
  assert approx_equal((f.c_rep, f.k_rep, f.irexp, f.rexp), (16,1,1,4))
  c = f.customized_copy()
  assert approx_equal((c.c_rep, c.k_rep, c.irexp, c.rexp), (16,1,1,4))
  c = f.customized_copy(c_rep=8, k_rep=2, irexp=3, rexp=5)
  assert approx_equal((c.c_rep, c.k_rep, c.irexp, c.rexp), (8,2,3,5))

def exercise_angle():
  # test without symmetry operations
  def check(p, i_seqs=(2,1,0), sym_ops=None, angle_ideal=95,
      weight=1, slack=0.0, origin_id=0):
    assert p.i_seqs == i_seqs
    if p.sym_ops is not None:
      for i in range(len(sym_ops)):
        assert approx_equal(p.sym_ops[i].as_double_array(), sym_ops[i].as_double_array())
    else:
      assert sym_ops is None # while p.sym_ops IS None
    assert approx_equal(p.angle_ideal, angle_ideal)
    assert approx_equal(p.weight, weight)
    assert p.slack == slack
    assert p.origin_id == origin_id

  p = geometry_restraints.angle_proxy(
    i_seqs=[2,1,0],
    angle_ideal=95,
    weight=1)
  check(p)
  p.angle_ideal = 86
  p.weight = 78
  p.slack = 12
  p.origin_id = 3
  check(p, angle_ideal=86, weight=78, slack=12, origin_id=3)
  p.angle_ideal = 95
  p.weight = 1
  p.slack = 0
  p.origin_id = 0
  check(p)
  p = geometry_restraints.angle_proxy(
    i_seqs=[2,1,0],
    sym_ops=None,
    angle_ideal=95,
    weight=1)
  check(p)
  p = p.sort_i_seqs()
  check(p, i_seqs=(0,1,2))
  c = geometry_restraints.angle_proxy(
    i_seqs=[3,4,5],
    proxy=p)
  check(c, i_seqs=(3,4,5))
  c = p.scale_weight(factor=3.14)
  check(c, i_seqs=(0,1,2), weight=3.14)

  a = geometry_restraints.angle(
    sites=[(1,0,0),(0,0,0),(0,1,0)],
    angle_ideal=95,
    weight=1)
  assert approx_equal(a.sites, [(1,0,0),(0,0,0),(0,1,0)])
  assert approx_equal(a.angle_ideal, 95)
  assert approx_equal(a.weight, 1)
  assert a.origin_id == 0
  assert a.have_angle_model
  assert approx_equal(a.angle_model, 90)
  assert approx_equal(a.delta, 5)
  assert approx_equal(a.residual(), 25)
  assert approx_equal(a.gradients(epsilon=1.e-100),
    ((0.0, 572.95779513082323, 0.0),
     (-572.95779513082323, -572.95779513082323, 0.0),
     (572.95779513082323, 0.0, 0.0)))
  assert a.slack == 0.0
  sites_cart = flex.vec3_double([(1,0,0),(0,0,0),(0,1,0)])
  p.origin_id = 3
  a = geometry_restraints.angle(
    sites_cart=sites_cart,
    proxy=p)
  assert approx_equal(a.sites, [(1,0,0),(0,0,0),(0,1,0)])
  assert approx_equal(a.angle_ideal, 95)
  assert approx_equal(a.weight, 1)
  assert a.origin_id == 3
  assert a.have_angle_model
  assert approx_equal(a.angle_model, 90)
  proxies = geometry_restraints.shared_angle_proxy([p,p])
  for proxy in proxies:
    assert approx_equal(proxy.weight, 1)
  assert approx_equal(geometry_restraints.angle_deltas(
    sites_cart=sites_cart,
    proxies=proxies), [5]*2)
  assert approx_equal(geometry_restraints.angle_residuals(
    sites_cart=sites_cart,
    proxies=proxies), [25]*2)
  residual_sum = geometry_restraints.angle_residual_sum(
    sites_cart=sites_cart,
    proxies=proxies,
    gradient_array=None)
  assert approx_equal(residual_sum, 2*25)
  p1 = geometry_restraints.angle_proxy(i_seqs=[0,1,2], proxy=p)
  p1.origin_id = 1
  # here their origin ids are 3,1
  proxies = geometry_restraints.shared_angle_proxy([p,p1])
  # and we expect only 1 delta in the result
  assert approx_equal(geometry_restraints.angle_deltas(
    sites_cart=sites_cart,
    proxies=proxies,
    origin_id=1), [5])
  assert approx_equal(geometry_restraints.angle_deltas(
    sites_cart=sites_cart,
    proxies=proxies,
    origin_id=3), [5])

  # test with symmetry operations
  sym_ops = (sgtbx.rt_mx('-1+x,+y,+z'),sgtbx.rt_mx(),sgtbx.rt_mx())
  p = geometry_restraints.angle_proxy(
    i_seqs=[2,1,0],
    sym_ops=sym_ops,
    angle_ideal=95,
    weight=1)
  check(p, sym_ops=sym_ops)
  c = geometry_restraints.angle_proxy(
    i_seqs=[3,4,5],
    proxy=p)
  check(c, i_seqs=(3,4,5), sym_ops=sym_ops)
  c = p.scale_weight(factor=5.82)
  check(c, sym_ops=sym_ops, weight=5.82)
  p = p.sort_i_seqs()
  check(p,
      i_seqs=(0,1,2),
      sym_ops=(sgtbx.rt_mx(),sgtbx.rt_mx(),sgtbx.rt_mx('-1+x,+y,+z')))
  unit_cell = uctbx.unit_cell([15,25,30,90,90,90])
  sites_cart = flex.vec3_double([(1,0,0),(0,1,0),(14,0,0)])
  p.origin_id = 3
  a = geometry_restraints.angle(
    unit_cell=unit_cell,
    sites_cart=sites_cart,
    proxy=p)
  assert approx_equal(a.sites, [(1,0,0),(0,1,0),(-1,0,0)])
  assert approx_equal(a.angle_ideal, 95)
  assert approx_equal(a.weight, 1)
  assert a.origin_id == 3
  assert a.have_angle_model
  assert approx_equal(a.angle_model, 90)
  assert approx_equal(a.delta, 5)
  assert approx_equal(a.residual(), a.weight*a.delta**2)
  p.origin_id = 0
  p1 = geometry_restraints.angle_proxy(
    i_seqs=[0,1,2],
    proxy=p)
  p1.origin_id = 2
  proxies = geometry_restraints.shared_angle_proxy()
  for i in range(10):
    if i<7:
      proxies.append(p)
    else:
      proxies.append(p1)
  assert approx_equal(geometry_restraints.angle_deltas(
    unit_cell=unit_cell,
    sites_cart=sites_cart,
    proxies=proxies), [5]*10)
  assert approx_equal(geometry_restraints.angle_deltas(
    unit_cell=unit_cell,
    sites_cart=sites_cart,
    proxies=proxies,
    origin_id=0), [5]*7)
  assert approx_equal(geometry_restraints.angle_deltas(
    unit_cell=unit_cell,
    sites_cart=sites_cart,
    proxies=proxies,
    origin_id=2), [5]*3)
  assert approx_equal(geometry_restraints.angle_deltas(
    unit_cell=unit_cell,
    sites_cart=sites_cart,
    proxies=proxies,
    origin_id=1), [])
  assert approx_equal(geometry_restraints.angle_residuals(
    unit_cell=unit_cell,
    sites_cart=sites_cart,
    proxies=proxies), [25]*10)
  gradient_array = flex.double([0]*10)
  residual_sum = geometry_restraints.angle_residual_sum(
    unit_cell=unit_cell,
    sites_cart=sites_cart,
    proxies=proxies,
    gradient_array=None)
  assert approx_equal(residual_sum, 10*25)
  # check proxies with and without sym_ops are happy side-by-side
  p_sym = geometry_restraints.angle_proxy(
    i_seqs=[2,1,0],
    sym_ops=sym_ops,
    angle_ideal=95,
    weight=1)
  check(p_sym, sym_ops=sym_ops)
  angle_sym = geometry_restraints.angle(
    unit_cell=unit_cell,
    sites_cart=sites_cart,
    proxy=p_sym)
  p_no_sym = geometry_restraints.angle_proxy(
    i_seqs=[2,1,0],
    angle_ideal=95,
    weight=1,
    origin_id=3)
  check(p_no_sym, origin_id=3)
  angle_no_sym = geometry_restraints.angle(
    sites_cart=sites_cart,
    proxy=p_no_sym)
  proxies = geometry_restraints.shared_angle_proxy([p_sym,p_no_sym])
  assert approx_equal(geometry_restraints.angle_deltas(
    unit_cell=unit_cell,
    sites_cart=sites_cart,
    proxies=proxies), [angle_sym.delta,angle_no_sym.delta])
  assert approx_equal(geometry_restraints.angle_residuals(
    unit_cell=unit_cell,
    sites_cart=sites_cart,
    proxies=proxies), [angle_sym.residual(),angle_no_sym.residual()])
  residual_sum = geometry_restraints.angle_residual_sum(
    unit_cell=unit_cell,
    sites_cart=sites_cart,
    proxies=proxies,
    gradient_array=None)
  assert approx_equal(residual_sum, angle_sym.residual() + angle_no_sym.residual())
  #
  proxies = geometry_restraints.shared_angle_proxy([
    geometry_restraints.angle_proxy([0,1,2], 1, 2, 0, 0),
    geometry_restraints.angle_proxy([1,2,3], 2, 3, 0, 1),
    geometry_restraints.angle_proxy([2,3,0], 3, 4, 0, 1),
    geometry_restraints.angle_proxy([3,1,2], 4, 5, 0, 3)])
  selected = proxies.proxy_select(n_seq=4, iselection=flex.size_t([0,2]))
  assert selected.size() == 0
  selected = proxies.proxy_select(n_seq=4, iselection=flex.size_t([0,1,2]))
  assert selected.size() == 1
  check(selected[0], i_seqs=(0,1,2), angle_ideal=1, weight=2)
  selected = proxies.proxy_select(n_seq=4, iselection=flex.size_t([0,2,3]))
  assert selected.size() == 1
  check(selected[0], i_seqs=(1,2,0), angle_ideal=3, weight=4, origin_id=1)
  selected = proxies.proxy_select(n_seq=4, iselection=flex.size_t([1,2,3]))
  assert selected.size() == 2
  check(selected[0], i_seqs=(0,1,2), angle_ideal=2, weight=3, origin_id=1)
  check(selected[1], i_seqs=(2,0,1), angle_ideal=4, weight=5, origin_id=3)
  selected = proxies.proxy_select(n_seq=4, iselection=flex.size_t([0,1,2,3]))
  assert selected.size() == 4
  #
  rest = proxies.proxy_remove(selection=flex.bool([True,True,True,True]))
  assert rest.size() == 0
  rest = proxies.proxy_remove(selection=flex.bool([False,True,True,True]))
  assert rest.size() == 2
  check(rest[0], i_seqs=(0,1,2), angle_ideal=1, weight=2, origin_id=0)
  check(rest[1], i_seqs=(2,3,0), angle_ideal=3, weight=4, origin_id=1)
  rest = proxies.proxy_remove(selection=flex.bool([True,True,True,False]))
  assert rest.size() == 3
  rest = proxies.proxy_remove(origin_id=1)
  assert rest.size() == 2
  check(rest[0], i_seqs=(0,1,2), angle_ideal=1, weight=2, origin_id=0)
  check(rest[1], i_seqs=(3,1,2), angle_ideal=4, weight=5, origin_id=3)
  #
  selected = proxies.proxy_select(origin_id=5)
  assert selected.size() == 0
  selected = proxies.proxy_select(origin_id=0)
  assert selected.size() == 1
  check(selected[0], i_seqs=(0,1,2), angle_ideal=1, weight=2)
  selected = proxies.proxy_select(origin_id=1)
  assert selected.size() == 2
  check(selected[0], i_seqs=(1,2,3), angle_ideal=2, weight=3, origin_id=1)
  check(selected[1], i_seqs=(2,3,0), angle_ideal=3, weight=4, origin_id=1)
  #
  unit_cell = uctbx.unit_cell([15,11.5,16.25,90,99.5,90])
  sites_cart = flex.vec3_double(
    [(12.87,0.10,9.04),(12.54,0.44,7.73),(13.47,0.34,6.71)])
  rt_mx = sgtbx.rt_mx('2-X,-Y,1-Z')
  u_mx = sgtbx.rt_mx()
  i_seqs = [2,0,1]
  a_sym_ops = [u_mx,rt_mx,rt_mx]
  b_sym_ops = [rt_mx,u_mx,u_mx]
  a_proxy = geometry_restraints.angle_proxy(
    i_seqs=i_seqs,
    sym_ops=a_sym_ops,
    angle_ideal=120,
    weight=1)
  b_proxy = geometry_restraints.angle_proxy(
    i_seqs=i_seqs,
    sym_ops=b_sym_ops,
    angle_ideal=120,
    weight=1)
  a_angle = geometry_restraints.angle(
    unit_cell=unit_cell,
    sites_cart=sites_cart,
    proxy=a_proxy)
  b_angle = geometry_restraints.angle(
    unit_cell=unit_cell,
    sites_cart=sites_cart,
    proxy=b_proxy)
  assert approx_equal(a_angle.delta, b_angle.delta)
  assert approx_equal(a_angle.residual(), b_angle.residual())
  assert not_approx_equal(a_angle.gradients(), b_angle.gradients())
  assert approx_equal(a_angle.grads_and_curvs(), [
    (82.47780595428577, 9.9176398449691465, -275.30239023150972),
    (-287.7152475786869, 62.177141285587624, 345.71504772803047),
    (205.23744162440113, -72.094781130556768, -70.412657496520751),
    (548.64354849364315, -141.3499058192476, 4777.1475618734567),
    (5313.4607140709404, -424.64322327702632, 7689.6945986452274),
    (2641.6450110035271, 222.22748382126554, 413.72502597622014)])
  a_gradient_array = flex.vec3_double(sites_cart.size())
  a_residual_sum = geometry_restraints.angle_residual_sum(
    unit_cell=unit_cell,
    sites_cart=sites_cart,
    proxies=geometry_restraints.shared_angle_proxy([a_proxy]),
    gradient_array=a_gradient_array)
  b_gradient_array = flex.vec3_double(sites_cart.size())
  b_residual_sum = geometry_restraints.angle_residual_sum(
    unit_cell=unit_cell,
    sites_cart=sites_cart,
    proxies=geometry_restraints.shared_angle_proxy([b_proxy]),
    gradient_array=b_gradient_array)
  for a,b in zip(a_gradient_array, b_gradient_array):
    assert approx_equal(a, b)
  fd_grads = finite_difference_gradients(
    restraint_type=geometry_restraints.angle,
    unit_cell=unit_cell,
    sites_cart=sites_cart,
    proxy=a_proxy)
  for g,e in zip(a_gradient_array, fd_grads):
    assert approx_equal(g, e)

  #exercise slack parameter
  # ans: delta, delta_slack, residual
  ans = [(5,5,25),(5,2,4), (5,0,0), (5,0,0), (-5,-2,4), (-5,-5,25)]
  for i, vals in enumerate(
      [(95,0),(95,3),(95,5),(95,7),(85,3),(85,0)]):
    a = geometry_restraints.angle(
      sites=[(1,0,0),(0,0,0),(0,1,0)],
      angle_ideal=vals[0],
      weight=1,
      slack=vals[1])
    # print i, vals, a.residual()
    assert approx_equal(a.angle_model, 90)
    assert approx_equal(a.delta, ans[i][0])
    assert approx_equal(a.delta_slack, ans[i][1])
    assert approx_equal(a.residual(), ans[i][2])

def exercise_dihedral():

  def check(p, i_seqs=None, sites=None, sym_ops=None, angle_ideal=-40,
      alt_angle_ideals=None, weight=1, periodicity=0, limit=-1, top_out=False,
      slack=0.0, origin_id=0, angle_model=0, angle_delta=0):
    assert [i_seqs, sites].count(None) == 1 # check for correct usage of procedure
    assert approx_equal(p.angle_ideal, angle_ideal)
    assert p.alt_angle_ideals == alt_angle_ideals
    assert approx_equal(p.weight, weight)
    assert approx_equal(p.periodicity, periodicity)
    assert approx_equal(p.limit, limit)
    assert p.top_out == top_out
    assert approx_equal(p.slack, slack)
    if i_seqs is not None:
      assert p.origin_id == origin_id
      assert p.i_seqs == i_seqs
      if p.sym_ops is not None:
        for i in range(len(p.sym_ops)):
          assert approx_equal(p.sym_ops[i].as_double_array(), sym_ops[i].as_double_array())
      else:
        assert sym_ops is None # while p.sym_ops IS None
    else:
      assert approx_equal(p.sites, sites)
      assert p.have_angle_model
      assert approx_equal(p.angle_model, angle_model)
      assert approx_equal(p.delta, angle_delta)

  # defaults:
  p = geometry_restraints.dihedral_proxy(
      i_seqs=[3,2,1,0],
      angle_ideal=10,
      weight=1)
  check(p, i_seqs=(3,2,1,0), angle_ideal=10)

  u_mx = sgtbx.rt_mx() # unit matrix
  sym_ops = (u_mx, sgtbx.rt_mx('1+X,+Y,+Z'), u_mx, sgtbx.rt_mx('+X,-1+Y,2+Z'))
  p = geometry_restraints.dihedral_proxy(
      i_seqs=[3,2,1,0],
      sym_ops=sym_ops,
      angle_ideal=-40,
      weight=1,
      periodicity=2,
      alt_angle_ideals=[180])
  check(p, i_seqs=(3,2,1,0), sym_ops=sym_ops, alt_angle_ideals=(180,), periodicity=2)
  c = geometry_restraints.dihedral_proxy(
      i_seqs=[6,8,5,3],
      proxy=p)
  check(c, i_seqs=(6,8,5,3), sym_ops=sym_ops, alt_angle_ideals=(180,),
      periodicity=2)
  c = p.scale_weight(factor=0.37)
  check(c, i_seqs=(3,2,1,0), sym_ops=sym_ops, weight=0.37,
      alt_angle_ideals=(180,), periodicity=2)
  p = p.sort_i_seqs()
  check(p, i_seqs=(0,1,2,3),
      sym_ops=(
          sgtbx.rt_mx('+X,-1+Y,2+Z'), u_mx, sgtbx.rt_mx('1+X,+Y,+Z'), u_mx),
      alt_angle_ideals=(180,), periodicity=2)
  p.angle_ideal = 50
  p.weight = 2
  p.periodicity = 3
  p.alt_angle_ideals = None
  p.origin_id = 2
  check(p, i_seqs=(0,1,2,3), angle_ideal=50,
      sym_ops=(
          sgtbx.rt_mx('+X,-1+Y,2+Z'), u_mx, sgtbx.rt_mx('1+X,+Y,+Z'), u_mx),
      weight=2, periodicity=3, origin_id=2)
  p.angle_ideal = -40
  p.weight = 1
  p.periodicity = 2
  p.alt_angle_ideals = (25,-25)
  p.origin_id=0
  check(p, i_seqs=(0,1,2,3), angle_ideal=-40,
      sym_ops=(
          sgtbx.rt_mx('+X,-1+Y,2+Z'), u_mx, sgtbx.rt_mx('1+X,+Y,+Z'), u_mx),
      weight=1, periodicity=2, alt_angle_ideals=(25,-25,), origin_id=0)
  #
  u_mx = sgtbx.rt_mx() # unit matrix
  sym_ops = (u_mx, u_mx, sgtbx.rt_mx('+X,1+Y,+Z'), sgtbx.rt_mx('+X,1+Y,+Z'))
  unit_cell = uctbx.unit_cell([15,25,30,90,90,90])
  sites_cart = flex.vec3_double([(2,24,0),(1,24,0),(1,1,0),(0,1,0)])
  for periodicity in [0, 1, -1]:
    p = geometry_restraints.dihedral_proxy(
      i_seqs=[0,1,2,3],
      sym_ops=sym_ops,
      angle_ideal=175,
      weight=1,
      periodicity=periodicity)
    d = geometry_restraints.dihedral(
      unit_cell=unit_cell,
      sites_cart=sites_cart,
      proxy=p)
    check(d, sites=[(2,24,0),(1,24,0),(1,26,0),(0,26,0)], angle_ideal=175,
        angle_model=180, angle_delta=-5, periodicity=periodicity)
    if (periodicity <= 0):
      assert approx_equal(d.residual(), 25)
      assert approx_equal(d.gradients(epsilon=1.e-100),
        ((0, 0, 572.95779513082323),
         (0, 0, -572.95779513082323),
         (0, 0, -572.95779513082323),
         (0, 0, 572.95779513082323)))
    else:
      assert approx_equal(d.residual(), 36.5308983192)
      assert approx_equal(d.gradients(epsilon=1.e-100),
        ((0.0, 0.0, 836.69513037751835),
         (0.0, 0.0, -836.69513037751835),
         (0.0, 0.0, -836.69513037751835),
         (0.0, 0.0, 836.69513037751835)))
  #
  p = geometry_restraints.dihedral_proxy(
    i_seqs=[0,1,2,3],
    sym_ops=sym_ops,
    angle_ideal=175,
    weight=1,
    periodicity=0)
  proxies = geometry_restraints.shared_dihedral_proxy([p,p])
  assert proxies.count_harmonic() == 2
  assert approx_equal(geometry_restraints.dihedral_deltas(
    unit_cell=unit_cell,
    sites_cart=sites_cart,
    proxies=proxies), [-5]*2)
  assert approx_equal(geometry_restraints.dihedral_residuals(
    unit_cell=unit_cell,
    sites_cart=sites_cart,
    proxies=proxies), [25]*2)
  residual_sum = geometry_restraints.dihedral_residual_sum(
    unit_cell=unit_cell,
    sites_cart=sites_cart,
    proxies=proxies,
    gradient_array=None)
  assert approx_equal(residual_sum, 2*25)
  # check proxies with and without sym_ops are happy side-by-side
  p_sym = geometry_restraints.dihedral_proxy(
    i_seqs=[0,1,2,3],
    sym_ops=sym_ops,
    angle_ideal=175,
    weight=1)
  check(p_sym, i_seqs=(0,1,2,3), sym_ops=sym_ops, angle_ideal=175)
  dihedral_sym = geometry_restraints.dihedral(
    unit_cell=unit_cell,
    sites_cart=sites_cart,
    proxy=p_sym)
  check(dihedral_sym, sites=[(2,24,0),(1,24,0),(1,26,0),(0,26,0)],
      sym_ops=sym_ops, angle_ideal=175,
      weight=1, angle_model=180, angle_delta=-5)
  p_no_sym = geometry_restraints.dihedral_proxy(
    i_seqs=[0,1,2,3],
    angle_ideal=175,
    weight=1)
  check(p_no_sym, i_seqs=(0,1,2,3), sym_ops=None, angle_ideal=175)
  dihedral_no_sym = geometry_restraints.dihedral(
    sites_cart=sites_cart,
    proxy=p_no_sym)
  check(dihedral_no_sym, sites=[(2,24,0),(1,24,0),(1,1,0),(0,1,0)],
      sym_ops=sym_ops, angle_ideal=175,
      weight=1, angle_model=180, angle_delta=-5)
  proxies = geometry_restraints.shared_dihedral_proxy([p_sym,p_no_sym])
  assert approx_equal(geometry_restraints.dihedral_deltas(
    unit_cell=unit_cell,
    sites_cart=sites_cart,
    proxies=proxies), [dihedral_sym.delta,dihedral_no_sym.delta])
  assert approx_equal(geometry_restraints.dihedral_residuals(
    unit_cell=unit_cell,
    sites_cart=sites_cart,
    proxies=proxies), [dihedral_sym.residual(),dihedral_no_sym.residual()])
  residual_sum = geometry_restraints.dihedral_residual_sum(
    unit_cell=unit_cell,
    sites_cart=sites_cart,
    proxies=proxies,
    gradient_array=None)
  assert approx_equal(
    residual_sum,
    dihedral_sym.residual() + dihedral_no_sym.residual())
  #
  unit_cell = uctbx.unit_cell([15,11.5,16.25,90,99.5,90])
  sites_cart = flex.vec3_double(
    [(12.87,0.10,9.04),(12.54,0.44,7.73),(13.47,0.34,6.71)])
  rt_mx = sgtbx.rt_mx('2-X,-Y,1-Z')
  u_mx = sgtbx.rt_mx()
  i_seqs = [2,0,1,2]
  a_sym_ops = [u_mx,u_mx,u_mx,rt_mx]
  b_sym_ops = [u_mx,rt_mx,rt_mx,rt_mx]
  a_proxy = geometry_restraints.dihedral_proxy(
    i_seqs=i_seqs,
    sym_ops=a_sym_ops,
    angle_ideal=0,
    weight=1)
  b_proxy = geometry_restraints.dihedral_proxy(
    i_seqs=i_seqs,
    sym_ops=b_sym_ops,
    angle_ideal=0,
    weight=1)
  a_dihedral = geometry_restraints.dihedral(
    unit_cell=unit_cell,
    sites_cart=sites_cart,
    proxy=a_proxy)
  b_dihedral = geometry_restraints.dihedral(
    unit_cell=unit_cell,
    sites_cart=sites_cart,
    proxy=b_proxy)
  assert approx_equal(a_dihedral.delta, b_dihedral.delta)
  assert approx_equal(a_dihedral.residual(), b_dihedral.residual())
  assert not_approx_equal(a_dihedral.gradients(), b_dihedral.gradients())
  a_gradient_array = flex.vec3_double(sites_cart.size())
  a_residual_sum = geometry_restraints.dihedral_residual_sum(
    unit_cell=unit_cell,
    sites_cart=sites_cart,
    proxies=geometry_restraints.shared_dihedral_proxy([a_proxy]),
    gradient_array=a_gradient_array)
  b_gradient_array = flex.vec3_double(sites_cart.size())
  b_residual_sum = geometry_restraints.dihedral_residual_sum(
    unit_cell=unit_cell,
    sites_cart=sites_cart,
    proxies=geometry_restraints.shared_dihedral_proxy([b_proxy]),
    gradient_array=b_gradient_array)
  for a,b in zip(a_gradient_array, b_gradient_array):
    assert approx_equal(a, b)
  fd_grads = finite_difference_gradients(
    restraint_type=geometry_restraints.dihedral,
    unit_cell=unit_cell,
    sites_cart=sites_cart,
    proxy=a_proxy)
  for g,e in zip(a_gradient_array, fd_grads):
    assert approx_equal(g, e)
  #
  p = geometry_restraints.dihedral_proxy(
    i_seqs=[3,2,1,0],
    angle_ideal=-40,
    weight=1,
    periodicity=-2,
    alt_angle_ideals=None)
  check(p, i_seqs=(3,2,1,0), periodicity=-2)
  p = p.sort_i_seqs()
  check(p, i_seqs=(0,1,2,3), periodicity=-2)
  p.angle_ideal = 50
  p.weight = 2
  p.periodicity = 3
  p.origin_id = 2
  check(p, i_seqs=(0,1,2,3), angle_ideal=50, weight=2,
      periodicity=3, origin_id=2)
  p.angle_ideal = -40
  p.weight = 1
  p.periodicity = -2
  p.origin_id = 0
  check(p, i_seqs=(0,1,2,3), angle_ideal=-40, weight=1, periodicity=-2)
  d = geometry_restraints.dihedral(
    sites=[(1,0,0),(0,0,0),(0,1,0),(1,0,1)],
    angle_ideal=-40,
    weight=1)
  check(d, sites=[(1,0,0),(0,0,0),(0,1,0),(1,0,1)],
      angle_ideal=-40, angle_model=-45, angle_delta=5)
  assert approx_equal(d.residual(), 25)
  assert approx_equal(d.gradients(epsilon=1.e-100),
    ((0, 0, -572.95779513082323),
     (286.47889756541161, 0, 286.47889756541161),
     (0, 0, 0),
     (-286.47889756541161, 0, 286.47889756541161)))
  sites_cart = flex.vec3_double([(1,0,0),(0,0,0),(0,1,0),(-1,0,-1)])
  d = geometry_restraints.dihedral(
    sites_cart=sites_cart,
    proxy=p)
  check(d, sites=[(1,0,0),(0,0,0),(0,1,0),(-1,0,-1)],
      angle_ideal=-40, periodicity=-2, angle_model=135, angle_delta=5)
  proxies = geometry_restraints.shared_dihedral_proxy([p,p])
  for proxy in proxies:
    assert proxy.periodicity == -2
  proxies[1].periodicity = 3
  assert proxies[1].periodicity == 3
  assert proxies[0].periodicity == -2
  proxies[1].periodicity = -2
  assert proxies[1].periodicity == -2
  assert approx_equal(geometry_restraints.dihedral_deltas(
    sites_cart=sites_cart,
    proxies=proxies), [5]*2)
  assert approx_equal(geometry_restraints.dihedral_residuals(
    sites_cart=sites_cart,
    proxies=proxies), [25]*2)
  residual_sum = geometry_restraints.dihedral_residual_sum(
    sites_cart=sites_cart,
    proxies=proxies,
    gradient_array=None)
  assert approx_equal(residual_sum, 2*25)
  #
  sites_cart = flex.vec3_double((
    (44.14, -3.376, 8.756),
    (43.598, -2.045, 8.726),
    (42.178, -2.036, 9.302),
    (41.818, -0.984, 10.006)))
  r_orig = geometry_restraints.dihedral(
    sites=list(sites_cart), angle_ideal=0, weight=1)
  perm = flex.size_t(range(4))
  n_perms = 0
  n_equiv = 0
  n_equiv_direct = 0
  while 1:
    sites_perm = sites_cart.select(perm)
    r = geometry_restraints.dihedral(
      sites=list(sites_perm), angle_ideal=0, weight=1)
    if (   abs(r.angle_model - r_orig.angle_model) < 1.e-6
        or abs(r.angle_model + r_orig.angle_model) < 1.e-6):
      n_equiv += 1
      p = geometry_restraints.dihedral_proxy(
        i_seqs=list(perm),
        angle_ideal=r.angle_model,
        weight=1)
      rp = geometry_restraints.dihedral(
        sites_cart=sites_cart,
        proxy=p)
      assert approx_equal(rp.angle_model, r.angle_model)
      if (abs(p.angle_ideal - r_orig.angle_model) < 1.e-6):
        n_equiv_direct += 1
      p_sorted = p.sort_i_seqs()
      assert p_sorted.i_seqs == (0,1,2,3)
      assert approx_equal(p_sorted.angle_ideal, r_orig.angle_model)
    #
    p = geometry_restraints.dihedral_proxy(
      i_seqs=list(perm),
      angle_ideal=12,
      weight=1,
      alt_angle_ideals=[30,-40])
    p_sorted = p.sort_i_seqs()
    if (p_sorted.angle_ideal > 0):
      assert approx_equal(p_sorted.alt_angle_ideals, [30,-40])
    else:
      assert approx_equal(p_sorted.alt_angle_ideals, [-30,40])
    #
    n_perms += 1
    if (not perm.next_permutation()):
      break
  assert n_perms == 24
  assert n_equiv == 4
  assert n_equiv_direct == 2
  #
  proxies = geometry_restraints.shared_dihedral_proxy([
    geometry_restraints.dihedral_proxy([0,1,2,3], 1, 2, 3),
    geometry_restraints.dihedral_proxy([1,2,3,4], 2, 3, 4, origin_id=1),
    geometry_restraints.dihedral_proxy([2,3,0,4], 3, 4, 5, origin_id=1),
    geometry_restraints.dihedral_proxy([3,1,2,4], 4, 5, 6, origin_id=3)])
  selected = proxies.proxy_select(n_seq=5, iselection=flex.size_t([0,2,4]))
  assert selected.size() == 0
  selected = proxies.proxy_select(n_seq=5, iselection=flex.size_t([1,2,3,4]))
  assert selected.size() == 2 # 2nd and 4th
  check(selected[0],
      i_seqs=(0,1,2,3), angle_ideal=2, weight=3, periodicity=4, origin_id=1)
  check(selected[1],
      i_seqs=(2,0,1,3), angle_ideal=4, weight=5, periodicity=6, origin_id=3)
  #
  rest = proxies.proxy_remove(selection=flex.bool([True,True,True,True,True]))
  assert rest.size() == 0
  rest = proxies.proxy_remove(selection=flex.bool([False,True,True,True,True]))
  assert rest.size() == 2 # 1st and 3rd
  check(rest[0],
      i_seqs=(0,1,2,3), angle_ideal=1, weight=2, periodicity=3, origin_id=0)
  check(rest[1],
      i_seqs=(2,3,0,4), angle_ideal=3, weight=4, periodicity=5, origin_id=1)
  rest = proxies.proxy_remove(selection=flex.bool([True,True,True,True,False]))
  assert rest.size() == 3 # all but 1st
  check(rest[0],
      i_seqs=(1,2,3,4), angle_ideal=2, weight=3, periodicity=4, origin_id=1)
  check(rest[1],
      i_seqs=(2,3,0,4), angle_ideal=3, weight=4, periodicity=5, origin_id=1)
  check(rest[2],
      i_seqs=(3,1,2,4), angle_ideal=4, weight=5, periodicity=6, origin_id=3)
  rest = proxies.proxy_remove(origin_id=1)
  assert rest.size() == 2 # 1st and 4th
  check(rest[0],
      i_seqs=(0,1,2,3), angle_ideal=1, weight=2, periodicity=3, origin_id=0)
  check(rest[1],
      i_seqs=(3,1,2,4), angle_ideal=4, weight=5, periodicity=6, origin_id=3)
  #
  selected = proxies.proxy_select(origin_id=5)
  assert selected.size() == 0
  selected = proxies.proxy_select(origin_id=0)
  assert selected.size() == 1
  check(selected[0],
      i_seqs=(0,1,2,3), angle_ideal=1, weight=2, periodicity=3, origin_id=0)
  selected = proxies.proxy_select(origin_id=1)
  assert selected.size() == 2
  check(selected[0],
      i_seqs=(1,2,3,4), angle_ideal=2, weight=3, periodicity=4, origin_id=1)
  check(selected[1],
      i_seqs=(2,3,0,4), angle_ideal=3, weight=4, periodicity=5, origin_id=1)
  #
  def get_d(angle_ideal, angle_model, periodicity, alt_angle_ideals=None):
    a = angle_model * math.pi / 180
    c, s = math.cos(a), math.sin(a)
    d = geometry_restraints.dihedral(
      sites=[(1,0,-1),(0,0,-1),(0,0,0),(c,s,0)],
      angle_ideal=angle_ideal,
      weight=1/15**2,
      periodicity=periodicity,
      alt_angle_ideals=alt_angle_ideals)
    v = math.fmod(d.angle_model-angle_model, 360)
    if (v < 0): v += 360
    if (v > 360-1e-8): v -= 360
    assert approx_equal(v, 0)
    return d
  #
  for periodicity in range(1,6):
    f = open("plot_geo_restr_dihedral_periodicity_%d.xy" % periodicity, "w")
    for signed_periodicity in [periodicity, -periodicity]:
      for angle_model in range(0, 720+1, 1):
        d = get_d(
          angle_ideal=70,
          angle_model=angle_model,
          periodicity=signed_periodicity)
        print(angle_model, d.residual(), file=f)
      print("&", file=f)
    f.close()
  #
  intersection_angle = 120
  for angle_ideal in range(0, 720+5, 5):
    for periodicity in range(1,6):
      for signed_periodicity in [periodicity, -periodicity]:
        residuals = []
        for offset in [0, intersection_angle, -intersection_angle]:
          d = get_d(
            angle_ideal=angle_ideal,
            angle_model=angle_ideal + offset / periodicity,
            periodicity=signed_periodicity)
          residuals.append(d.residual())
        assert approx_equal(residuals[0], 0)
        assert approx_equal(residuals[1], residuals[2])
        assert approx_equal(residuals[1], d.weight * d.delta**2)
      #
      for offset in [intersection_angle, -intersection_angle]:
        for offset2 in [30, -30]:
          residuals = []
          for signed_periodicity in [periodicity, -periodicity]:
            d = get_d(
              angle_ideal=angle_ideal,
              angle_model=angle_ideal + (offset + offset2) / periodicity,
              periodicity=signed_periodicity)
            residuals.append(d.residual())
          if ((offset > 0) == (offset2 < 0)):
            assert residuals[0] > residuals[1]
          else:
            assert residuals[0] < residuals[1]

  #test alt_angle_ideals
  d = get_d(angle_ideal=180, angle_model=170, periodicity=2)
  assert approx_equal(d.delta, 10.)
  assert d.alt_angle_ideals is None
  d = get_d(angle_ideal=180, angle_model=170, periodicity=2,
    alt_angle_ideals=(25,))
  assert approx_equal(d.delta, 10.)
  d = get_d(angle_ideal=180, angle_model=10, periodicity=2,
    alt_angle_ideals=(25,))
  assert approx_equal(d.delta, -10.)
  d = get_d(angle_ideal=180, angle_model=10, periodicity=2,
    alt_angle_ideals=(15,))
  assert approx_equal(d.delta, 5.)
  d = get_d(angle_ideal=180, angle_model=10, periodicity=2,
    alt_angle_ideals=(15,345))
  assert approx_equal(d.delta, 5.)
  d = get_d(angle_ideal=180, angle_model=-10, periodicity=2,
    alt_angle_ideals=(15,345))
  assert approx_equal(d.delta, -5.)
  d = get_d(angle_ideal=30, angle_model=28, periodicity=1)
  assert approx_equal(d.delta, 2.)
  d = get_d(angle_ideal=30, angle_model=-30, periodicity=1)
  assert approx_equal(d.delta, 60.)
  d = get_d(angle_ideal=30, angle_model=28, periodicity=1,
    alt_angle_ideals=(-30,))
  assert approx_equal(d.delta, 2.)
  d = get_d(angle_ideal=30, angle_model=-28, periodicity=1,
    alt_angle_ideals=(-30,))
  assert approx_equal(d.delta, -2.)

def exercise_chirality():
  def check(p, i_seqs=None, sites=None, volume_ideal=0, both_signs=False,
      weight=0, origin_id=0, volume_model=0, delta_sign=0, delta=0):
    assert [i_seqs, sites].count(None) == 1 # check for correct usage of procedure
    assert approx_equal(p.volume_ideal, volume_ideal)
    assert p.both_signs == both_signs
    assert approx_equal(p.weight, weight)
    if i_seqs is not None:
      assert p.origin_id == origin_id
      assert p.i_seqs == i_seqs
    else:
      assert approx_equal(p.sites, sites)
      assert approx_equal(p.volume_model, volume_model)
      assert approx_equal(p.delta, delta)
      assert approx_equal(p.delta_sign, delta_sign)

  p = geometry_restraints.chirality_proxy(
    i_seqs=[0,2,3,1],
    volume_ideal=4,
    both_signs=False,
    weight=1,
    origin_id=1)
  check(p, i_seqs=(0,2,3,1), volume_ideal=4, both_signs=False, weight=1,
      origin_id=1)
  c = geometry_restraints.chirality_proxy(
    i_seqs=[9,0,4,6],
    proxy=p)
  check(c, i_seqs=(9,0,4,6), volume_ideal=4, both_signs=False, weight=1,
      origin_id=1)
  c = p.scale_weight(factor=9.32)
  check(c, i_seqs=(0,2,3,1), volume_ideal=4, both_signs=False, weight=9.32,
      origin_id=1)
  p = p.sort_i_seqs()
  check(p, i_seqs=(0,1,2,3), volume_ideal=4, both_signs=False, weight=1,
      origin_id=1)
  p = geometry_restraints.chirality_proxy(
    i_seqs=[0,2,1,3],
    volume_ideal=-4,
    both_signs=False,
    weight=1)
  check(p, i_seqs=(0,2,1,3), volume_ideal=-4, both_signs=False, weight=1)
  p = p.sort_i_seqs()
  check(p, i_seqs=(0,1,2,3), volume_ideal=4, both_signs=False, weight=1)
  c = geometry_restraints.chirality(
    sites=[(1,0,0),(0,0,0),(0,1,0),(1,0,1)],
    volume_ideal=4,
    both_signs=False,
    weight=1)
  check(c, sites=[(1,0,0),(0,0,0),(0,1,0),(1,0,1)], volume_ideal=4,
      both_signs=False, weight=1, volume_model=-1, delta_sign=-1,
      delta=5)
  assert approx_equal(c.residual(), 25)
  assert approx_equal(c.gradients(),
    ((10, 0, -10),
     (-10, -10, 0),
     (-0, 10, -0),
     (-0, -0, 10)))
  sites_cart = flex.vec3_double([(1,0,0),(0,0,0),(0,1,0),(-1,0,-1)])
  c = geometry_restraints.chirality(
    sites_cart=sites_cart,
    proxy=p)
  check(c, sites=[(1,0,0),(0,0,0),(0,1,0),(-1,0,-1)], volume_ideal=4,
      both_signs=False, weight=1, volume_model=1, delta_sign=-1,
      delta=3)
  proxies = geometry_restraints.shared_chirality_proxy([p,p])
  for proxy in proxies:
    check(p, i_seqs=(0,1,2,3), volume_ideal=4, both_signs=False, weight=1)
  assert approx_equal(geometry_restraints.chirality_deltas(
    sites_cart=sites_cart,
    proxies=proxies), [3]*2)
  assert approx_equal(geometry_restraints.chirality_residuals(
    sites_cart=sites_cart,
    proxies=proxies), [9]*2)
  residual_sum = geometry_restraints.chirality_residual_sum(
    sites_cart=sites_cart,
    proxies=proxies,
    gradient_array=None)
  assert approx_equal(residual_sum, 2*9)
  #
  proxies = geometry_restraints.shared_chirality_proxy([
    geometry_restraints.chirality_proxy([0,1,2,3], 1, False, 2, 0),
    geometry_restraints.chirality_proxy([1,2,3,4], 2, True, 3, 1),
    geometry_restraints.chirality_proxy([2,3,0,4], 3, True, 4, 1),
    geometry_restraints.chirality_proxy([3,1,2,4], 4, False, 5, 3)])
  selected = proxies.proxy_select(n_seq=5, iselection=flex.size_t([0,2,4]))
  assert selected.size() == 0
  selected = proxies.proxy_select(n_seq=5, iselection=flex.size_t([1,2,3,4]))
  assert selected.size() == 2 # 2nd and 4th
  check(selected[0], i_seqs=(0,1,2,3),
      volume_ideal=2, both_signs=True, weight=3, origin_id=1)
  check(selected[1], i_seqs=(2,0,1,3),
      volume_ideal=4, both_signs=False, weight=5, origin_id=3)
  #
  selected = proxies.proxy_select(origin_id=5)
  assert selected.size() == 0
  selected = proxies.proxy_select(origin_id=0)
  assert selected.size() == 1
  check(selected[0], i_seqs=(0,1,2,3),
      volume_ideal=1, both_signs=False, weight=2, origin_id=0)
  selected = proxies.proxy_select(origin_id=1)
  assert selected.size() == 2
  check(selected[0], i_seqs=(1,2,3,4),
      volume_ideal=2, both_signs=True, weight=3, origin_id=1)
  check(selected[1], i_seqs=(2,3,0,4),
      volume_ideal=3, both_signs=True, weight=4, origin_id=1)
  #
  rest = proxies.proxy_remove(selection=flex.bool([True,True,True,True,True]))
  assert rest.size() == 0
  rest = proxies.proxy_remove(selection=flex.bool([False,True,True,True,True]))
  assert rest.size() == 2 # 1st and 3rd
  check(rest[0], i_seqs=(0,1,2,3),
      volume_ideal=1, both_signs=False, weight=2, origin_id=0)
  check(rest[1], i_seqs=(2,3,0,4),
      volume_ideal=3, both_signs=True, weight=4, origin_id=1)
  rest = proxies.proxy_remove(selection=flex.bool([True,True,True,True,False]))
  assert rest.size() == 3 # all but 1st
  check(rest[0], i_seqs=(1,2,3,4),
      volume_ideal=2, both_signs=True, weight=3, origin_id=1)
  check(rest[1], i_seqs=(2,3,0,4),
      volume_ideal=3, both_signs=True, weight=4, origin_id=1)
  check(rest[2], i_seqs=(3,1,2,4),
      volume_ideal=4, both_signs=False, weight=5, origin_id=3)
  rest = proxies.proxy_remove(origin_id=1)
  assert rest.size() == 2 # 1st and 4th
  check(rest[0], i_seqs=(0,1,2,3),
      volume_ideal=1, both_signs=False, weight=2, origin_id=0)
  check(rest[1], i_seqs=(3,1,2,4),
      volume_ideal=4, both_signs=False, weight=5, origin_id=3)

def exercise_planarity():
  def check(p, i_seqs=None, sites=None, sym_ops=None, weights=[1,2,3,4],
      origin_id=0):
    assert [i_seqs, sites].count(None) == 1 # check for correct usage of procedure
    assert approx_equal(p.weights, weights)
    if i_seqs is not None:
      assert p.origin_id == origin_id
      approx_equal(p.i_seqs, i_seqs)
      if p.sym_ops is not None:
        for i in range(len(p.sym_ops)):
          assert approx_equal(p.sym_ops[i].as_double_array(), sym_ops[i].as_double_array())
      else:
        assert sym_ops is None # while p.sym_ops IS None

  weights = flex.double([1, 2, 3, 4])
  u_mx = sgtbx.rt_mx()
  sym_ops = (u_mx, sgtbx.rt_mx('1+x,y,z'), u_mx, sgtbx.rt_mx('1+x,1+y,z'))
  p = geometry_restraints.planarity_proxy(
    i_seqs=flex.size_t([3,1,0,2]),
    sym_ops=sym_ops,
    weights=weights)
  check(p, i_seqs=(3,1,0,2), sym_ops=sym_ops, weights=[1, 2, 3, 4])
  c = geometry_restraints.planarity_proxy(
    i_seqs=flex.size_t([8,6,3,1]),
    proxy=p)
  check(c, i_seqs=[8,6,3,1], sym_ops=sym_ops, weights=[1, 2, 3, 4])
  p.origin_id=1
  c = p.scale_weights(factor=4.94)
  check(c, i_seqs=[3,1,0,2], sym_ops=sym_ops,
      weights=[1*4.94, 2*4.94, 3*4.94, 4*4.94], origin_id=1)
  p.origin_id=0
  assert c.i_seqs.id() == p.i_seqs.id()
  assert c.weights.id() != p.weights.id()
  p = p.sort_i_seqs()
  check(p, i_seqs=(0,1,2,3),
      sym_ops=(u_mx, sgtbx.rt_mx('1+x,y,z'), sgtbx.rt_mx('1+x,1+y,z'), u_mx),
      weights=(3,2,4,1))
  #
  unit_cell = uctbx.unit_cell([15,25,30,90,90,90])
  sites_cart = flex.vec3_double([(1,24,1.1),(1,1,1),(14,1,1),(14,24,0.9)])
  expected_residual = 0.04
  expected_gradients = [(0,0,0.4), (0,0,0), (0,0,0), (0,0,-0.4)]
  p = geometry_restraints.planarity_proxy(
    i_seqs=(0,1,2,3),
    sym_ops=[u_mx, sgtbx.rt_mx('x,y,z'), sgtbx.rt_mx('x,1+y,z'), sgtbx.rt_mx('1-x,y,z')],
    weights=(2,2,2,2))
  planarity = geometry_restraints.planarity(
    unit_cell=unit_cell,
    sites_cart=sites_cart,
    proxy=p)
  check(p, i_seqs=(0,1,2,3),
      sym_ops=[u_mx, sgtbx.rt_mx('x,y,z'), sgtbx.rt_mx('x,1+y,z'), sgtbx.rt_mx('1-x,y,z')],
      weights=(2,2,2,2))
  check(planarity, sites=[(1.0, 24.0, 1.1), (1.0, 1.0, 1.0), (14., 26.0, 1.0), (1., 24.0, 0.9)],
      sym_ops=[u_mx, sgtbx.rt_mx('x,y,z'), sgtbx.rt_mx('x,1+y,z'), sgtbx.rt_mx('1-x,y,z')],
      weights=(2,2,2,2))
  assert approx_equal(planarity.deltas(), (0.1, 0, 0, -0.1))
  assert approx_equal(planarity.residual(), 0.04)
  assert approx_equal(planarity.gradients(), expected_gradients)
  #
  proxies = geometry_restraints.shared_planarity_proxy([p,p])
  for proxy in proxies:
    check(p, i_seqs=(0,1,2,3),
        sym_ops=[u_mx, sgtbx.rt_mx('x,y,z'), sgtbx.rt_mx('x,1+y,z'), sgtbx.rt_mx('1-x,y,z')],
        weights=(2,2,2,2))
  assert eps_eq(geometry_restraints.planarity_deltas_rms(
    unit_cell=unit_cell,
    sites_cart=sites_cart,
    proxies=proxies), [0.070710678118654821]*2)
  assert eps_eq(geometry_restraints.planarity_residuals(
    unit_cell=unit_cell,
    sites_cart=sites_cart,
    proxies=proxies), [expected_residual]*2)
  residual_sum = geometry_restraints.planarity_residual_sum(
    unit_cell=unit_cell,
    sites_cart=sites_cart,
    proxies=proxies,
    gradient_array=None)
  assert eps_eq(residual_sum, 2*expected_residual)
  gradient_array = flex.vec3_double(proxy.i_seqs.size(), (0,0,0))
  residual_sum = geometry_restraints.planarity_residual_sum(
    unit_cell=unit_cell,
    sites_cart=sites_cart,
    proxies=proxies,
    gradient_array=gradient_array)
  assert eps_eq(residual_sum, 2*0.04)
  for g,e in zip(gradient_array, expected_gradients):
    assert eps_eq(g, matrix.col(e)*2)
  #
  sites_cart = flex.vec3_double([
    (-6.9010753374697966, 1.3017288659588333, -1.4469233441387523),
    (-4.947324488687852, -1.0193474269570115, 0.16296067326855093),
    (-6.9598378855214706, -0.66835111494675281, -1.7153810358296142),
    (-4.846552160625774, 0.96315156534510438, 0.51500258491293438)])
  weights = flex.double([1, 2, 3, 4])
  expected_residual = 0.000428526964094
  expected_gradients = [
    (0.019669677238598002, 0.0024733761183690019, -0.020428665017957027),
    (0.020015197633649708, 0.0025168238009701843, -0.020787517902107686),
    (-0.020270795833584803, -0.002548964159754365, 0.0210529787910856),
    (-0.019414079038662237, -0.0024412357595847371, 0.020163204128978415)]
  p = geometry_restraints.planarity_proxy(
    i_seqs=flex.size_t([0,1,2,3]),
    weights=weights)
  assert tuple(p.i_seqs) == (0,1,2,3)
  assert approx_equal(p.weights, weights)
  perm = flex.size_t([3,1,0,2])
  p = geometry_restraints.planarity_proxy(
    i_seqs=flex.size_t([0,1,2,3]).select(perm),
    weights=weights.select(perm))
  assert tuple(p.i_seqs) == (3,1,0,2)
  assert not_approx_equal(p.weights, weights)
  p = p.sort_i_seqs()
  assert tuple(p.i_seqs) == (0,1,2,3)
  assert approx_equal(p.weights, weights)
  for i_constructor in range(2):
    if (i_constructor == 0):
      l = geometry_restraints.planarity(
        sites=sites_cart,
        weights=weights)
    else:
      l = geometry_restraints.planarity(
        sites_cart=sites_cart,
        proxy=p)
    assert approx_equal(l.sites, sites_cart)
    assert approx_equal(l.weights, weights)
    assert eps_eq(l.deltas(), (0.014233272168667327, 0.007241647943016986,
                               -0.0048894168534149443, -0.0035120793736139956))
    assert eps_eq(l.rms_deltas(), 0.00853329655308)
    assert eps_eq(l.residual(), expected_residual)
    assert eps_eq(l.gradients(), expected_gradients)
    assert eps_eq(l.normal(),
      (0.69097523765119184, 0.086887122267422581, -0.71763768639680903))
    assert eps_eq(l.residual(), l.lambda_min())
    assert eps_eq(l.center_of_mass(),
      (-5.7061446613913009, 0.11105869285849694, -0.42071347654387559))
    assert eps_eq(l.center_of_mass(), l.sites.mean_weighted(weights=l.weights))
    assert eps_eq(l.residual_tensor(),
      (10.250312599815825, 8.7000194514224525, 10.265208176541265,
       2.7229147081229312, 10.19874296603952, 3.6750425846794936))
    assert eps_eq(l.eigensystem().values(),
      [21.998140770294835, 7.2169709305206142, 0.00042852696409348911])
  proxies = geometry_restraints.shared_planarity_proxy([p,p])
  for proxy in proxies:
    assert tuple(proxy.i_seqs) == (0,1,2,3)
  assert eps_eq(geometry_restraints.planarity_deltas_rms(
    sites_cart=sites_cart,
    proxies=proxies), [0.0085332965530764398]*2)
  assert eps_eq(geometry_restraints.planarity_residuals(
    sites_cart=sites_cart,
    proxies=proxies), [expected_residual]*2)
  residual_sum = geometry_restraints.planarity_residual_sum(
    sites_cart=sites_cart,
    proxies=proxies,
    gradient_array=None)
  assert eps_eq(residual_sum, 2*expected_residual)
  gradient_array = flex.vec3_double(proxy.i_seqs.size(), (0,0,0))
  residual_sum = geometry_restraints.planarity_residual_sum(
    sites_cart=sites_cart,
    proxies=proxies,
    gradient_array=gradient_array)
  assert eps_eq(residual_sum, 2*expected_residual)
  for g,e in zip(gradient_array, expected_gradients):
    assert eps_eq(g, matrix.col(e)*2)
  #
  def make_proxy(i_seqs, weights, origin_id):
    return geometry_restraints.planarity_proxy(
      flex.size_t(i_seqs),
      flex.double(weights),
      origin_id)
  proxies = geometry_restraints.shared_planarity_proxy([
    make_proxy([0,1,2,3], [2,3,4,5], 0),
    make_proxy([1,2,3,4], [3,4,5,6], 1),
    make_proxy([2,3,0,4], [4,5,6,7], 1),
    make_proxy([3,1,2,4], [5,6,7,8], 3)])
  selected = proxies.proxy_select(n_seq=5, iselection=flex.size_t([0,2,4]))
  assert selected.size() == 0
  selected = proxies.proxy_select(n_seq=5, iselection=flex.size_t([1,2,3,4]))
  assert selected.size() == 2 # 2nd, 4th
  check(selected[0], i_seqs=[0,1,2,3], weights=[3,4,5,6], origin_id=1)
  check(selected[1], i_seqs=[2,0,1,3], weights=[5,6,7,8], origin_id=3)
  #
  selected = proxies.proxy_select(origin_id=5)
  assert selected.size() == 0
  selected = proxies.proxy_select(origin_id=0)
  assert selected.size() == 1
  check(selected[0], i_seqs=[0,1,2,3], weights=[2,3,4,5], origin_id=0)
  selected = proxies.proxy_select(origin_id=1)
  assert selected.size() == 2
  check(selected[0], i_seqs=[1,2,3,4], weights=[3,4,5,6], origin_id=1)
  check(selected[1], i_seqs=[2,3,0,4], weights=[4,5,6,7], origin_id=1)
  #
  for i_remove in range(10,15):
    sel = flex.size_t(list(range(10,i_remove))+list(range(i_remove+1,15)))
    pp = geometry_restraints.planarity_proxy(
      i_seqs=flex.size_t([10, 11, 12, 13, 14]),
      weights=flex.double(range(5))+13)
    pps = geometry_restraints.shared_planarity_proxy()
    pps.append(pp)
    selected = pps.proxy_select(20, sel)
    assert list(selected[0].i_seqs) == [0,1,2,3]
    assert approx_equal(selected[0].weights,
      pp.weights[:i_remove-10].concatenate(pp.weights[i_remove+1-10:]))
  #
  rest = proxies.proxy_remove(selection=flex.bool([True,True,True,True,True]))
  assert rest.size() == 0
  rest = proxies.proxy_remove(selection=flex.bool([False,True,True,True,True]))
  assert rest.size() == 2 # 1st and 3rd
  check(rest[0], i_seqs=[0,1,2,3], weights=[2,3,4,5], origin_id=0)
  check(rest[1], i_seqs=[2,3,0,4], weights=[4,5,6,7], origin_id=1)
  rest = proxies.proxy_remove(selection=flex.bool([True,True,True,True,False]))
  assert rest.size() == 3
  rest = proxies.proxy_remove(origin_id=1)
  assert rest.size() == 2 # 1st and 4th
  check(rest[0], i_seqs=[0,1,2,3], weights=[2,3,4,5], origin_id=0)
  check(rest[1], i_seqs=[3,1,2,4], weights=[5,6,7,8], origin_id=3)
  #
  unit_cell = uctbx.unit_cell([15,11.5,16.25,90,99.5,90])
  sites_cart = flex.vec3_double(
    [(12.87,0.10,9.04),(12.54,0.44,7.73),(13.47,0.34,6.71)])
  rt_mx = sgtbx.rt_mx('2-X,-Y,1-Z')
  u_mx = sgtbx.rt_mx()
  i_seqs = flex.size_t([0,1,2,0,1,2])
  sym_ops = (u_mx,u_mx,u_mx,rt_mx,rt_mx,rt_mx)
  weights = flex.double([1]*6)
  p = geometry_restraints.planarity_proxy(
    i_seqs=i_seqs,
    sym_ops=sym_ops,
    weights=weights)
  planarity = geometry_restraints.planarity(
    unit_cell=unit_cell,
    sites_cart=sites_cart,
    proxy=p)
  gradient_array = flex.vec3_double(sites_cart.size())
  residual_sum = geometry_restraints.planarity_residual_sum(
    unit_cell=unit_cell,
    sites_cart=sites_cart,
    proxies=geometry_restraints.shared_planarity_proxy([p]),
    gradient_array=gradient_array)
  fd_grads = finite_difference_gradients(
    restraint_type=geometry_restraints.planarity,
    unit_cell=unit_cell,
    sites_cart=sites_cart,
    proxy=p)
  for g,e in zip(gradient_array, fd_grads):
    assert approx_equal(g, e)
  # check proxies with and without sym_ops are happy side-by-side
  p_sym = geometry_restraints.planarity_proxy(
    i_seqs=i_seqs,
    sym_ops=sym_ops,
    weights=weights)
  assert p_sym.sym_ops == sym_ops
  restraint_sym = geometry_restraints.planarity(
    unit_cell=unit_cell,
    sites_cart=sites_cart,
    proxy=p_sym)
  p_no_sym = geometry_restraints.planarity_proxy(
    i_seqs=i_seqs,
    weights=weights)
  assert p_no_sym.sym_ops == None
  restraint_no_sym = geometry_restraints.planarity(
    sites_cart=sites_cart,
    proxy=p_no_sym)
  proxies = geometry_restraints.shared_planarity_proxy([p_sym,p_no_sym])
  assert approx_equal(geometry_restraints.planarity_deltas_rms(
    unit_cell=unit_cell,
    sites_cart=sites_cart,
    proxies=proxies), [restraint_sym.rms_deltas(),restraint_no_sym.rms_deltas()])
  assert approx_equal(geometry_restraints.planarity_residuals(
    unit_cell=unit_cell,
    sites_cart=sites_cart,
    proxies=proxies), [restraint_sym.residual(),restraint_no_sym.residual()])
  residual_sum = geometry_restraints.planarity_residual_sum(
    unit_cell=unit_cell,
    sites_cart=sites_cart,
    proxies=proxies,
    gradient_array=None)
  assert approx_equal(residual_sum, restraint_sym.residual() + restraint_no_sym.residual())

def exercise_planarity_top_out():
  # exercise finite-difference for top-out potential
  i_seqs = [0,1,2,3]
  sites_cart = flex.vec3_double(
    [(1,1,0),(1,2,0),(2,1,0),(1,1,2)])
    # [(12,54,23),(234,235,345),(234,433,287),(1541,3452,7677)])
  weights = flex.double([1]*4)
  p = geometry_restraints.planarity_proxy(
    i_seqs=i_seqs,
    weights=weights,
    limit=1,
    top_out=True)
  planarity = geometry_restraints.planarity(
    sites_cart=sites_cart,
    proxy=p)
  # manual_gradient(planarity)
  print("Normal:", planarity.normal())
  # print dir(planarity)
  print("deltas:", list(planarity.deltas()))
  # res = planarity.residual()
  # print "residual:",res
  sc1 = sites_cart.deep_copy()
  sc2 = sites_cart.deep_copy()
  h=1.e-5
  sc1[0] = (1+h,1,0)
  sc2[0] = (1-h,1,0)
  pl1 = geometry_restraints.planarity(
    sites_cart=sc1,
    proxy=p)
  pl2 = geometry_restraints.planarity(
    sites_cart=sc2,
    proxy=p)
  pl1_residual = pl1.residual()
  pl2_residual = pl2.residual()
  gr = (pl1_residual - pl2_residual) / (2*h)
  # print list(sc1)
  # print list(sc2)
  # print pl1_residual, pl2_residual
  # print "GRADIENT:",gr
  # STOP()
  gradient_array = flex.vec3_double(sites_cart.size())
  residual_sum = geometry_restraints.planarity_residual_sum(
    sites_cart=sites_cart,
    proxies=geometry_restraints.shared_planarity_proxy([p]),
    gradient_array=gradient_array)
  fd_grads = finite_difference_gradients(
    restraint_type=geometry_restraints.planarity,
    sites_cart=sites_cart,
    proxy=p, eps=1.e-5)
  for g,e in zip(gradient_array, fd_grads):
    print("grads from proxy:", g)
    print("grads from finit:", e)
    # assert approx_equal(g, e)

def exercise_proxy_show():
  # zeolite AHT
  crystal_symmetry = crystal.symmetry(
    unit_cell=(15.794, 9.206, 8.589, 90, 90, 90),
    space_group_symbol="C m c m")
  sites_cart_cry = crystal_symmetry.unit_cell().orthogonalization_matrix() \
    * flex.vec3_double([(0.1681, 0.6646, 0.4372), (0.0000, 0.6644, 0.5629)])
  asu_mappings = crystal_symmetry.asu_mappings(buffer_thickness=3.0)
  asu_mappings.process_sites_cart(original_sites=sites_cart_cry)
  pair_asu_table = crystal.pair_asu_table(asu_mappings=asu_mappings)
  pair_asu_table.add_all_pairs(distance_cutoff=2.9)
  sorted_asu_proxies = geometry_restraints.bond_sorted_asu_proxies(
    asu_mappings=asu_mappings)
  sio = StringIO()
  sorted_asu_proxies.show_sorted(
    by_value="residual",
    sites_cart=sites_cart_cry,
    f=sio)
  assert not show_diff(sio.getvalue(), """\
Bond restraints: 0
""")
  sorted_asu_proxies = geometry_restraints.bond_sorted_asu_proxies(
    pair_asu_table=pair_asu_table)
  mt = flex.mersenne_twister(seed=5)
  for proxy in sorted_asu_proxies.asu:
    proxy.distance_ideal = 2.9 + (mt.random_double()-0.5)*0.2
    proxy.weight = 1+mt.random_double()*100
    if (mt.random_double() > 0.5):
      proxy.slack = mt.random_double()*0.1
  sio = StringIO()
  sorted_asu_proxies.show_sorted(
    by_value="residual",
    sites_cart=sites_cart_cry,
    site_labels=["Si1", "Si2"],
    f=sio)
  assert not show_diff(sio.getvalue(), """\
Bond restraints: 3
Sorted by residual:
bond Si1
     Si2
  ideal  model  slack  delta    sigma   weight residual sym.op.
  2.979  2.866  0.004  0.112 1.71e-01 3.42e+01 4.01e-01 x,y,z
bond Si2
     Si1
  ideal  model  slack  delta    sigma   weight residual sym.op.
  2.822  2.866  0.042 -0.045 1.29e-01 6.05e+01 4.35e-04 x,y,z
bond Si2
     Si1
  ideal  model  delta    sigma   weight residual sym.op.
  2.867  2.866  0.001 1.26e-01 6.33e+01 6.17e-05 -x,y,z
""")
  sio = StringIO()
  sorted_asu_proxies.show_sorted(
    by_value="residual",
    sites_cart=sites_cart_cry,
    f=sio,
    prefix="&",
    max_items=2)
  assert not show_diff(sio.getvalue(), """\
&Bond restraints: 3
&Sorted by residual:
&bond 0
&     1
&  ideal  model  slack  delta    sigma   weight residual sym.op.
&  2.979  2.866  0.004  0.112 1.71e-01 3.42e+01 4.01e-01 x,y,z
&bond 1
&     0
&  ideal  model  slack  delta    sigma   weight residual sym.op.
&  2.822  2.866  0.042 -0.045 1.29e-01 6.05e+01 4.35e-04 x,y,z
&... (remaining 1 not shown)
""")
  sio = StringIO()
  sorted_asu_proxies.show_sorted(
    by_value="residual",
    sites_cart=sites_cart_cry,
    f=sio,
    prefix="*",
    max_items=0)
  gv = sio.getvalue()
  assert not show_diff(sio.getvalue(), """\
*Bond restraints: 3
*Sorted by residual:
*... (remaining 3 not shown)
""")
  #
  for unit_cell in [None, uctbx.unit_cell([15,11.5,16.25,90,99.5,90])]:
    simple_proxies = geometry_restraints.shared_bond_simple_proxy([
      geometry_restraints.bond_simple_proxy((0,1), 2.979, 10),
      geometry_restraints.bond_simple_proxy(
        (1,0), sgtbx.rt_mx("x,y,z"), 2.822, 250)
    ])
    sio = StringIO()
    simple_proxies.show_sorted(
      "residual", sites_cart_cry, unit_cell=unit_cell, f=sio)
    assert not show_diff(sio.getvalue(), """\
Bond restraints: 2
Sorted by residual:
bond 1
     0
  ideal  model  delta    sigma   weight residual sym.op.
  2.822  2.866 -0.044 6.32e-02 2.50e+02 4.86e-01 x,y,z
bond 0
     1
  ideal  model  delta    sigma   weight residual
  2.979  2.866  0.113 3.16e-01 1.00e+01 1.27e-01
""")
  mt = flex.mersenne_twister(seed=73)
  sites_cart = flex.vec3_double(mt.random_double(size=18))
  site_labels = ["a", "ba", "c", "dada", "e", "f"]
  #
  proxies = geometry_restraints.shared_angle_proxy()
  sio = StringIO()
  proxies.show_sorted(
    by_value="residual",
    sites_cart=flex.vec3_double(),
    f=sio)
  assert not show_diff(sio.getvalue(), """\
Bond angle restraints: 0
""")
  proxies = geometry_restraints.shared_angle_proxy([
    geometry_restraints.angle_proxy(
      i_seqs=[2,1,0],
      angle_ideal=59,
      weight=2),
    geometry_restraints.angle_proxy(
      i_seqs=[3,0,1],
      angle_ideal=99,
      weight=8)])
  sio = StringIO()
  proxies.show_sorted(
    by_value="residual",
    sites_cart=sites_cart,
    f=sio,
    prefix="+")
  assert not show_diff(sio.getvalue(), """\
+Bond angle restraints: 2
+Sorted by residual:
+angle 3
+      0
+      1
+    ideal   model   delta    sigma   weight residual
+    99.00   99.72   -0.72 3.54e-01 8.00e+00 4.19e+00
+angle 2
+      1
+      0
+    ideal   model   delta    sigma   weight residual
+    59.00   58.06    0.94 7.07e-01 2.00e+00 1.76e+00
""")
  sio = StringIO()
  proxies.show_sorted(
    by_value="delta",
    sites_cart=sites_cart,
    site_labels=site_labels,
    f=sio,
    prefix="@",
    max_items=1)
  assert not show_diff(sio.getvalue(), """\
@Bond angle restraints: 2
@Sorted by delta:
@angle c
@      ba
@      a
@    ideal   model   delta    sigma   weight residual
@    59.00   58.06    0.94 7.07e-01 2.00e+00 1.76e+00
@... (remaining 1 not shown)
""")
  sio = StringIO()
  proxies.show_sorted(
    by_value="residual",
    sites_cart=sites_cart,
    f=sio,
    max_items=0)
  assert not show_diff(sio.getvalue(), """\
Bond angle restraints: 2
""")
  #
  proxies = geometry_restraints.shared_dihedral_proxy()
  sio = StringIO()
  proxies.show_sorted(
    by_value="residual",
    sites_cart=flex.vec3_double(),
    f=sio)
  assert not show_diff(sio.getvalue(), """\
Dihedral angle restraints: 0
""")
  proxies = geometry_restraints.shared_dihedral_proxy([
    geometry_restraints.dihedral_proxy(
      i_seqs=[0,1,3,4],
      angle_ideal=59,
      weight=2,
      periodicity=-1),
    geometry_restraints.dihedral_proxy(
      i_seqs=[3,2,0,5],
      angle_ideal=99,
      weight=8,
      periodicity=-1)])
  sio = StringIO()
  proxies.show_sorted(
    by_value="residual",
    sites_cart=sites_cart,
    f=sio,
    prefix="-")
  assert not show_diff(sio.getvalue(), """\
-Dihedral angle restraints: 2
-  sinusoidal: 0
-    harmonic: 2
-Sorted by residual:
-dihedral 3
-         2
-         0
-         5
-    ideal   model   delta  harmonic     sigma   weight residual
-    99.00   16.67   82.33    -1      3.54e-01 8.00e+00 5.42e+04
-dihedral 0
-         1
-         3
-         4
-    ideal   model   delta  harmonic     sigma   weight residual
-    59.00 -159.79 -141.21    -1      7.07e-01 2.00e+00 3.99e+04
""")
  sio = StringIO()
  proxies.show_sorted(
    by_value="delta",
    sites_cart=sites_cart,
    site_labels=site_labels,
    f=sio,
    prefix="^",
    max_items=1)
  assert not show_diff(sio.getvalue(), """\
^Dihedral angle restraints: 2
^  sinusoidal: 0
^    harmonic: 2
^Sorted by delta:
^dihedral a
^         ba
^         dada
^         e
^    ideal   model   delta  harmonic     sigma   weight residual
^    59.00 -159.79 -141.21    -1      7.07e-01 2.00e+00 3.99e+04
^... (remaining 1 not shown)
""")
  sio = StringIO()
  proxies.show_sorted(
    by_value="residual",
    sites_cart=sites_cart,
    f=sio,
    max_items=1)
  assert not show_diff(sio.getvalue(), """\
Dihedral angle restraints: 2
  sinusoidal: 0
    harmonic: 2
Sorted by residual:
dihedral 3
         2
         0
         5
    ideal   model   delta  harmonic     sigma   weight residual
    99.00   16.67   82.33    -1      3.54e-01 8.00e+00 5.42e+04
... (remaining 1 not shown)
""")
  #
  proxies = geometry_restraints.shared_chirality_proxy()
  sio = StringIO()
  proxies.show_sorted(
    by_value="residual",
    sites_cart=flex.vec3_double(),
    f=sio)
  assert not show_diff(sio.getvalue(), """\
Chirality restraints: 0
""")
  proxies = geometry_restraints.shared_chirality_proxy([
    geometry_restraints.chirality_proxy(
      i_seqs=[0,1,3,4],
      volume_ideal=0.09,
      both_signs=False,
      weight=2),
    geometry_restraints.chirality_proxy(
      i_seqs=[3,2,0,5],
      volume_ideal=0.16,
      both_signs=True,
      weight=8)])
  sio = StringIO()
  proxies.show_sorted(
    by_value="residual",
    sites_cart=sites_cart,
    f=sio,
    prefix="$")
  assert not show_diff(sio.getvalue(), """\
$Chirality restraints: 2
$Sorted by residual:
$chirality 3
$          2
$          0
$          5
$  both_signs  ideal   model   delta    sigma   weight residual
$    True       0.16    0.05    0.11 3.54e-01 8.00e+00 9.34e-02
$chirality 0
$          1
$          3
$          4
$  both_signs  ideal   model   delta    sigma   weight residual
$    False      0.09   -0.04    0.13 7.07e-01 2.00e+00 3.33e-02
""")
  sio = StringIO()
  proxies.show_sorted(
    by_value="delta",
    sites_cart=sites_cart,
    site_labels=site_labels,
    f=sio,
    prefix="*",
    max_items=1)
  assert not show_diff(sio.getvalue(), """\
*Chirality restraints: 2
*Sorted by delta:
*chirality a
*          ba
*          dada
*          e
*  both_signs  ideal   model   delta    sigma   weight residual
*    False      0.09   -0.04    0.13 7.07e-01 2.00e+00 3.33e-02
*... (remaining 1 not shown)
""")
  sio = StringIO()
  proxies.show_sorted(
    by_value="residual",
    sites_cart=sites_cart,
    f=sio,
    max_items=0)
  assert not show_diff(sio.getvalue(), """\
Chirality restraints: 2
""")
  #
  proxies = geometry_restraints.shared_planarity_proxy()
  sio = StringIO()
  proxies.show_sorted(
    by_value="residual",
    sites_cart=flex.vec3_double(),
    f=sio)
  if 0: # n=0 restraints removed
    assert not show_diff(sio.getvalue(), """\
Planarity restraints: 0
""")
  proxies = geometry_restraints.shared_planarity_proxy([
    geometry_restraints.planarity_proxy(
      i_seqs=[0,2,4,1],
      weights=[0.31,0.2,0.31,0.4]),
    geometry_restraints.planarity_proxy(
      i_seqs=[0,2,3,4,5],
      weights=[0.01,0.11,0.21,0.31,0.41])])
  sio = StringIO()
  proxies.show_sorted(
    by_value="residual",
    sites_cart=sites_cart,
    f=sio,
    prefix=":")
  assert not show_diff(sio.getvalue(), """\
:Planarity restraints: 2
:Sorted by residual:
:           delta    sigma   weight rms_deltas residual
:plane 0    0.004 1.80e+00 3.10e-01   1.46e-01 2.52e-02
:      2   -0.196 2.24e+00 2.00e-01
:      4   -0.115 1.80e+00 3.10e-01
:      1    0.184 1.58e+00 4.00e-01
:           delta    sigma   weight rms_deltas residual
:plane 0   -0.332 1.00e+01 1.00e-02   1.78e-01 9.86e-03
:      2    0.152 3.02e+00 1.10e-01
:      3   -0.143 2.18e+00 2.10e-01
:      4   -0.030 1.80e+00 3.10e-01
:      5    0.063 1.56e+00 4.10e-01
""")
  sio = StringIO()
  proxies.show_sorted(
    by_value="rms_deltas",
    sites_cart=sites_cart,
    site_labels=site_labels,
    f=sio,
    prefix="<",
    max_items=1)
  assert not show_diff(sio.getvalue(), """\
<Planarity restraints: 2
<Sorted by rms_deltas:
<              delta    sigma   weight rms_deltas residual
<plane a      -0.332 1.00e+01 1.00e-02   1.78e-01 9.86e-03
<      c       0.152 3.02e+00 1.10e-01
<      dada   -0.143 2.18e+00 2.10e-01
<      e      -0.030 1.80e+00 3.10e-01
<      f       0.063 1.56e+00 4.10e-01
<... (remaining 1 not shown)
""")
  sio = StringIO()
  proxies.show_sorted(
    by_value="residual",
    sites_cart=sites_cart,
    f=sio,
    max_items=1)
  assert not show_diff(sio.getvalue(), """\
Planarity restraints: 2
Sorted by residual:
           delta    sigma   weight rms_deltas residual
plane 0    0.004 1.80e+00 3.10e-01   1.46e-01 2.52e-02
      2   -0.196 2.24e+00 2.00e-01
      4   -0.115 1.80e+00 3.10e-01
      1    0.184 1.58e+00 4.00e-01
... (remaining 1 not shown)
""")
  #
  unit_cell = uctbx.unit_cell([15,11.5,16.25,90,99.5,90])
  sites_cart = flex.vec3_double(
    [(12.87,0.10,9.04),(12.54,0.44,7.73),(13.47,0.34,6.71),(1,2,3)])
  rt_mx = sgtbx.rt_mx('2-X,-Y,1-Z')
  u_mx = sgtbx.rt_mx()
  p = geometry_restraints.angle_proxy(
    i_seqs=[2,0,1],
    sym_ops=[u_mx,rt_mx,rt_mx],
    angle_ideal=120,
    weight=1)
  proxies = geometry_restraints.shared_angle_proxy([p,p])
  sio = StringIO()
  proxies.show_sorted(
    by_value="residual",
    unit_cell=unit_cell,
    sites_cart=sites_cart,
    f=sio,
    prefix='!')
  assert not show_diff(sio.getvalue(), """\
!Bond angle restraints: 2
!Sorted by residual:
!angle 2
!      0  -x+2,-y,-z+1
!      1  -x+2,-y,-z+1
!    ideal   model   delta    sigma   weight residual
!   120.00  122.78   -2.78 1.00e+00 1.00e+00 7.73e+00
!angle 2
!      0  -x+2,-y,-z+1
!      1  -x+2,-y,-z+1
!    ideal   model   delta    sigma   weight residual
!   120.00  122.78   -2.78 1.00e+00 1.00e+00 7.73e+00
""")
  # test proxies with and without proxy.sym_ops side by side
  p2 = geometry_restraints.angle_proxy(
    i_seqs=[2,1,0],
    angle_ideal=59,
    weight=2)
  proxies = geometry_restraints.shared_angle_proxy([p,p2])
  sio = StringIO()
  proxies.show_sorted(
    by_value="delta",
    unit_cell=unit_cell,
    sites_cart=sites_cart,
    f=sio,
    prefix='~')
  assert not show_diff(sio.getvalue(), """\
~Bond angle restraints: 2
~Sorted by delta:
~angle 2
~      1
~      0
~    ideal   model   delta    sigma   weight residual
~    59.00  121.08  -62.08 7.07e-01 2.00e+00 7.71e+03
~angle 2
~      0  -x+2,-y,-z+1
~      1  -x+2,-y,-z+1
~    ideal   model   delta    sigma   weight residual
~   120.00  122.78   -2.78 1.00e+00 1.00e+00 7.73e+00
""")
  #
  p = geometry_restraints.dihedral_proxy(
    i_seqs=[2,0,1,2],
    sym_ops=[u_mx,u_mx,u_mx,rt_mx],
    angle_ideal=0,
    weight=1)
  proxies = geometry_restraints.shared_dihedral_proxy([p,p])
  sio = StringIO()
  proxies.show_sorted(
    by_value="delta",
    unit_cell=unit_cell,
    sites_cart=sites_cart,
    f=sio,
    prefix='%')
  assert not show_diff(sio.getvalue(), """\
%Dihedral angle restraints: 2
%  sinusoidal: 0
%    harmonic: 2
%Sorted by delta:
%dihedral 2
%         0
%         1
%         2  -x+2,-y,-z+1
%    ideal   model   delta  harmonic     sigma   weight residual
%     0.00    5.16   -5.16     0      1.00e+00 1.00e+00 2.67e+01
%dihedral 2
%         0
%         1
%         2  -x+2,-y,-z+1
%    ideal   model   delta  harmonic     sigma   weight residual
%     0.00    5.16   -5.16     0      1.00e+00 1.00e+00 2.67e+01
""")
  #
  p = geometry_restraints.planarity_proxy(
    i_seqs=flex.size_t([0,1,2,0,1,2]),
    sym_ops=[u_mx,u_mx,u_mx,rt_mx,rt_mx,rt_mx],
    weights=flex.double([1]*6))
  proxies = geometry_restraints.shared_planarity_proxy([p,p])
  sio = StringIO()
  proxies.show_sorted(
    by_value="residual",
    unit_cell=unit_cell,
    sites_cart=sites_cart,
    f=sio,
    prefix=">")
  assert not show_diff(sio.getvalue(), """\
>Planarity restraints: 2
>Sorted by residual:
>           delta    sigma   weight rms_deltas residual sym.op.
>plane 0    0.017 1.00e+00 1.00e+00   1.60e-02 1.53e-03
>      1   -0.015 1.00e+00 1.00e+00
>      2    0.016 1.00e+00 1.00e+00
>      0   -0.017 1.00e+00 1.00e+00                     -x+2,-y,-z+1
>      1    0.015 1.00e+00 1.00e+00                     -x+2,-y,-z+1
>      2   -0.016 1.00e+00 1.00e+00                     -x+2,-y,-z+1
>           delta    sigma   weight rms_deltas residual sym.op.
>plane 0    0.017 1.00e+00 1.00e+00   1.60e-02 1.53e-03
>      1   -0.015 1.00e+00 1.00e+00
>      2    0.016 1.00e+00 1.00e+00
>      0   -0.017 1.00e+00 1.00e+00                     -x+2,-y,-z+1
>      1    0.015 1.00e+00 1.00e+00                     -x+2,-y,-z+1
>      2   -0.016 1.00e+00 1.00e+00                     -x+2,-y,-z+1
""")
  # test proxies with and without proxy.sym_ops side by side
  p2 = geometry_restraints.planarity_proxy(
    i_seqs=[0,2,3,1],
    weights=[0.31,0.2,0.31,0.4])
  proxies = geometry_restraints.shared_planarity_proxy([p,p2])
  sio = StringIO()
  proxies.show_sorted(
    by_value="rms_deltas",
    unit_cell=unit_cell,
    sites_cart=sites_cart,
    f=sio,
    prefix="#")
  assert not show_diff(sio.getvalue(), """\
#Planarity restraints: 2
#Sorted by rms_deltas:
#           delta    sigma   weight rms_deltas residual sym.op.
#plane 0   -0.053 1.80e+00 3.10e-01   6.02e-02 4.53e-03
#      2   -0.071 2.24e+00 2.00e-01
#      3   -0.005 1.80e+00 3.10e-01
#      1    0.081 1.58e+00 4.00e-01
#           delta    sigma   weight rms_deltas residual sym.op.
#plane 0    0.017 1.00e+00 1.00e+00   1.60e-02 1.53e-03
#      1   -0.015 1.00e+00 1.00e+00
#      2    0.016 1.00e+00 1.00e+00
#      0   -0.017 1.00e+00 1.00e+00                     -x+2,-y,-z+1
#      1    0.015 1.00e+00 1.00e+00                     -x+2,-y,-z+1
#      2   -0.016 1.00e+00 1.00e+00                     -x+2,-y,-z+1
""")
  #
  unit_cell = uctbx.unit_cell([15,25,30,90,90,90])
  sites_cart = flex.vec3_double(
    [(1,2,3),(2,4,6),(1,2,4.5),(2,5.6,6),(14,24,29),(0.5,24,29)])
  p = geometry_restraints.bond_similarity_proxy(
    i_seqs=[(0,2),(1,3),(4,5)],
    sym_ops=[u_mx,u_mx,sgtbx.rt_mx('1+x,y,z')],
    weights=(1,2,3))
  proxies = geometry_restraints.shared_bond_similarity_proxy([p,p])
  sio = StringIO()
  proxies.show_sorted(
    by_value="residual",
    unit_cell=unit_cell,
    sites_cart=sites_cart,
    f=sio,
    prefix=">")
  assert not show_diff(sio.getvalue(), """\
>Bond similarity restraints: 2
>Sorted by residual:
>            delta    sigma   weight rms_deltas residual sym.op.
>bond 0-2   -0.033 1.00e+00 1.00e+00   4.71e-02 2.22e-03
>     1-3    0.067 7.07e-01 2.00e+00
>     4-5   -0.033 5.77e-01 3.00e+00                     x+1,y,z
>            delta    sigma   weight rms_deltas residual sym.op.
>bond 0-2   -0.033 1.00e+00 1.00e+00   4.71e-02 2.22e-03
>     1-3    0.067 7.07e-01 2.00e+00
>     4-5   -0.033 5.77e-01 3.00e+00                     x+1,y,z
""")
  sio = StringIO()
  p = geometry_restraints.bond_similarity_proxy(
    i_seqs=[(0,2),(1,3),(4,5)],
    weights=(1,2,3))
  proxies = geometry_restraints.shared_bond_similarity_proxy([p,p])
  proxies.show_sorted(
    by_value="rms_deltas",
    sites_cart=sites_cart,
    site_labels=site_labels,
    f=sio,
    prefix=">")
  assert not show_diff(sio.getvalue(), """\
>Bond similarity restraints: 2
>Sorted by rms_deltas:
>                delta    sigma   weight rms_deltas residual
>bond a-c       -6.033 1.00e+00 1.00e+00   5.98e+00 3.56e+01
>     ba-dada   -5.933 7.07e-01 2.00e+00
>     e-f        5.967 5.77e-01 3.00e+00
>                delta    sigma   weight rms_deltas residual
>bond a-c       -6.033 1.00e+00 1.00e+00   5.98e+00 3.56e+01
>     ba-dada   -5.933 7.07e-01 2.00e+00
>     e-f        5.967 5.77e-01 3.00e+00
""")

def exercise_bonds_with_symops():
  from cctbx.crystal.tst_ext import trial_structure
  xs = trial_structure(choice_of_coordinates=1)
  pst = xs.pair_asu_table(distance_cutoff=3.2).extract_pair_sym_table()
  bp = geometry_restraints.bond_params(
    distance_ideal=3.1,
    weight=1/0.01**2)
  proxies = geometry_restraints.shared_bond_simple_proxy([
    geometry_restraints.bond_simple_proxy(
      i_seqs=[_.i_seq, _.j_seq],
      rt_mx_ji=_.rt_mx_ji,
      params=bp)
        for _ in pst.iterator()])
  assert not show_diff(
    "\n".join([p.rt_mx_ji.as_xyz() for p in proxies]),
    """\
-y+1,-x+1,-z+1/2
x,x-y+2,-z+1/2
x,y,z
x-y+1,x+1,-z+1
x,y,z
-y+1,-x+1,z
-x+y,y,z""")
  deltas = geometry_restraints.bond_deltas(
    unit_cell=xs.unit_cell(),
    sites_cart=xs.sites_cart(),
    proxies=proxies)
  assert approx_equal(deltas, [
    0.0495812, -0.0821728, -0.07030907, -0.0093944,
    -0.09861225, 0.082206, -0.0658604])
  residuals = geometry_restraints.bond_residuals(
    unit_cell=xs.unit_cell(),
    sites_cart=xs.sites_cart(),
    proxies=proxies)
  assert approx_equal(residuals, [
    24.58295, 67.52369, 49.43365, 0.8825475, 97.24376, 67.57826, 43.37592])
  grads_ana = flex.vec3_double(xs.scatterers().size(), (0,0,0))
  sites_cart = xs.sites_cart()
  residual_sum = geometry_restraints.bond_residual_sum(
    unit_cell=xs.unit_cell(),
    sites_cart=sites_cart,
    proxies=proxies,
    gradient_array=grads_ana)
  eps = 1e-6
  grads_fin = flex.vec3_double()
  for i_site in range(sites_cart.size()):
    sori = sites_cart[i_site]
    gs = []
    for ix in range(3):
      fs = []
      for signed_eps in [eps, -eps]:
        seps = list(sori)
        seps[ix] += signed_eps
        sites_cart[i_site] = seps
        residual_sum = geometry_restraints.bond_residual_sum(
          unit_cell=xs.unit_cell(),
          sites_cart=sites_cart,
          proxies=proxies,
          gradient_array=None)
        fs.append(residual_sum)
      gs.append((fs[0]-fs[1])/(2*eps))
    grads_fin.append(gs)
    sites_cart[i_site] = sori
  assert approx_equal(grads_ana, grads_fin)

def exercise_parallelity():
  def check(p, i_seqs=(1,2,3,4,5), j_seqs=(6,7,8,9,10), weight=1,
      target_angle_deg=0, slack=0, top_out=False, limit=1, origin_id=0):
    assert approx_equal(p.i_seqs, i_seqs)
    assert approx_equal(p.j_seqs, j_seqs)
    assert approx_equal(p.weight, weight)
    assert approx_equal(p.target_angle_deg, target_angle_deg)
    assert approx_equal(p.slack, slack)
    assert p.top_out == top_out
    assert approx_equal(p.limit, limit)
    assert p.origin_id == origin_id

  def test_exact_values(test_sites, weight, top_out, limit, residual,
                        delta, origin_id=0, eps=1e-6):
    p = geometry_restraints.parallelity(i_sites=test_sites[0],
                    j_sites=test_sites[1],
                    weight=weight,
                    top_out=top_out,
                    limit=limit)
    assert approx_equal(p.residual(), residual, eps)
    assert approx_equal(p.delta, delta, eps)

  p = geometry_restraints.parallelity_proxy(
      i_seqs=(1,2,3,4,5),
      j_seqs=(6,7,8,9,10),
      weight=1)
  check(p)
  p.origin_id = 1
  check(p, origin_id=1)
  c = geometry_restraints.parallelity_proxy(
      i_seqs=(5,4,3,2,1),
      j_seqs=(10,9,8,7,6),
      proxy=p)
  check(c, i_seqs=(5,4,3,2,1), j_seqs=(10,9,8,7,6), weight=1, origin_id=1)
  c = c.sort_ij_seqs()
  check(p, origin_id=1)
  # values
  test_sites_1 = ([(1,1,0), (2,3,0), (1,2,0)],
                  [(1,1,1), (2,2,1), (1,2,1)])
  test_sites_2 = ([(1,0,0), (2,0,0), (1,1,0)],
                  [(1,0,0), (2,0,0), (1,0,1)])
  # 60 degrees
  test_sites_21 = ([(1,0,0), (2,0,0), (1,1.732050807568877,-1)],
                   [(1,0,0), (2,0,0), (1,0,1)])
  test_sites_3 = ([(1,0,0), (2,0,0), (1,1,0),(3,0,0), (3,3,0), (1,1,0)],
                  [(1,0,0), (2,0,0), (1,0,1)])
  test_sites_4 = ([(1,0,0), (2,0,0) ],
                  [(1,0,0), (2,0,0), (1,0,1)])
  # test_data=[(test_sites, weight, top_out, limit, residual, delta)]
  test_data = [(test_sites_1,    1, False,1,    0,              0 , 0),
               (test_sites_1,    1, True, 1,    0,              0 , 0),
               (test_sites_1,    1, True, 1000, 0,              0 , 0),
               (test_sites_2,    1, False,1,    1,              90, 0),
               (test_sites_2,    1, True, 1,    0.632120558829, 90, 0),
               (test_sites_2,    1, True, 1000, 0.999999499984, 90, 1),
               (test_sites_2, 1300, False,1,    1300,           90, 1),
               (test_sites_2, 1300, True, 1,    821.756726477,  90, 1),
               (test_sites_2, 1300, True, 1000, 1299.99934998,  90, 1),
               (test_sites_21,1000, False,1,    500,            60, 1),
               (test_sites_21,1000, True, 1,    393.469340287,  60, 2),
               (test_sites_21,1000, True, 1000, 499.999874948,  60, 2),
               (test_sites_3,    1, False,1,    1,              90, 2),
               (test_sites_3,    1, True, 1,    0.632120558829, 90, 2),
               (test_sites_3,    1, True, 1000, 0.999999499984, 90, 2)]
  for (test_sites, weight, top_out, limit, residual,
      delta, origin_id) in test_data:
    test_exact_values(test_sites, weight, top_out, limit, residual,
        delta, origin_id)

  # gradients
  def make_points(one_d):
    result = []
    for i in range(int(len(one_d)/3)):
      result.append(tuple(one_d[i*3:i*3+3]))
    return result
  h=1.e-7
  test_sites= [(1,0,0), (2,0,0), (1,1.732050807568877,-1),
               (1,0,0), (2,0,0), (1,0,1)]
  test_sites_1d = [1,0,0, 2,0,0, 1,1.732050807568877,-1,
                   1,0,0, 2,0,0, 1,0,1]
  # for target_angle_deg in [0,10]:
  for target_angle_deg in range(0,360,4):
    for slack in range(0,90,4):
      for top_out in [False, True]:
        limit = 10
        weight = 10
        # print target_angle_deg, slack
        p_original = geometry_restraints.parallelity(i_sites=test_sites[:3],
                                 j_sites=test_sites[3:],
                                 weight=1,
                                 target_angle_deg=target_angle_deg,
                                 slack=slack,
                                 limit=limit,
                                 top_out=top_out)
        grad = list(p_original.gradients())
        fin_dif_grad = []
        for i in range(len(test_sites_1d)):
          test_sites_1d[i]+=h
          points = make_points(test_sites_1d)
          p1 = geometry_restraints.parallelity(i_sites=points[:3],
                           j_sites=points[3:],
                           weight=1,
                           target_angle_deg=target_angle_deg,
                           slack=slack,
                           limit=limit,
                           top_out=top_out)
          test_sites_1d[i]-=2*h
          points = make_points(test_sites_1d)
          p2 = geometry_restraints.parallelity(i_sites=points[:3],
                           j_sites=points[3:],
                           weight=1,
                           target_angle_deg=target_angle_deg,
                           slack=slack,
                           limit=limit,
                           top_out=top_out)
          test_sites_1d[i]+=h
          # print p1.residual(), p2.residual()
          fin_dif_grad.append((p1.residual()-p2.residual())/(2.0*h))
      sites_fdg = make_points(fin_dif_grad)
      assert approx_equal(grad, sites_fdg, 1.e-6)
  # Proxy selections
  def make_proxy(i_seqs, j_seqs, weight, target_angle_deg=0, slack=0,
                 limit=-1, top_out=False, origin_id=0):
    return geometry_restraints.parallelity_proxy(
        flex.size_t(i_seqs),
        flex.size_t(j_seqs),
        weight, target_angle_deg, slack, limit, top_out, origin_id)
  proxies = geometry_restraints.shared_parallelity_proxy([
    make_proxy([0,1,2,3],   [2,3,4,5],   1, 11, 1, 1, True, 0),
    make_proxy([1,2,3,4],   [3,4,5,6],   2, 12, 2, 2, True, 1),
    make_proxy([2,3,10,11], [4,5,12,13], 3, 13, 3, 3, True, 1),
    make_proxy([3,1,12,14], [5,6,14,15], 4, 14, 4, 4, True, 3)])
  selected = proxies.proxy_select(n_seq=16, iselection=flex.size_t([0,2,4]))
  assert selected.size() == 0
  selected = proxies.proxy_select(n_seq=16,
                                  iselection=flex.size_t([1,2,3,4,6]))
  assert selected.size() == 2
  check(selected[0], i_seqs=(0,1,2), j_seqs=(1,2,3), weight=1,
      target_angle_deg=11, slack=1, top_out=True, limit=1, origin_id=0)
  check(selected[1], i_seqs=(0, 1, 2, 3), j_seqs=(2, 3, 4), weight=2,
      target_angle_deg=12, slack=2, top_out=True, limit=2, origin_id=1)
  #
  selected = proxies.proxy_select(origin_id=5)
  assert selected.size() == 0
  selected = proxies.proxy_select(origin_id=0)
  assert selected.size() == 1
  check(selected[0], i_seqs=(0,1,2,3), j_seqs=(2,3,4,5), weight=1,
      target_angle_deg=11, slack=1, top_out=True, limit=1, origin_id=0)
  selected = proxies.proxy_select(origin_id=1)
  assert selected.size() == 2
  check(selected[0], i_seqs=(1,2,3,4), j_seqs=(3,4,5,6), weight=2,
      target_angle_deg=12, slack=2, top_out=True, limit=2, origin_id=1)
  check(selected[1], i_seqs=(2,3,10,11), j_seqs=(4,5,12,13), weight=3,
      target_angle_deg=13, slack=3, top_out=True, limit=3, origin_id=1)

  # - geometry_restraints.remove.parallelities
  rest = proxies.proxy_remove(selection=flex.bool([True]*16))
  assert len(rest) == 0
  rest = proxies.proxy_remove(selection=flex.bool([True]*6+[False]*10))
  assert len(rest) == 2 # 3rd and 4th
  check(rest[0], i_seqs=(2, 3, 10, 11), j_seqs=(4, 5, 12, 13), weight=3,
      target_angle_deg=13, slack=3, top_out=True, limit=3, origin_id=1)
  check(rest[1], i_seqs=(3, 1, 12, 14), j_seqs=(5, 6, 14, 15), weight=4,
      target_angle_deg=14, slack=4, top_out=True, limit=4, origin_id=3)
  rest = proxies.proxy_remove(origin_id=1)
  assert len(rest) == 2 # 1st and 4th
  check(rest[0], i_seqs=(0,1,2,3), j_seqs=(2,3,4,5), weight=1,
      target_angle_deg=11, slack=1, top_out=True, limit=1, origin_id=0)
  check(rest[1], i_seqs=(3, 1, 12, 14), j_seqs=(5, 6, 14, 15), weight=4,
      target_angle_deg=14, slack=4, top_out=True, limit=4, origin_id=3)

def exercise_origin_id_selections_for_bonds():
  p_array = []
  for i in range(10):
    p = geometry_restraints.bond_simple_proxy(
        i_seqs=[i,i+1],
        distance_ideal=3.5,
        weight=1,
        slack=1,
        limit=1,
        top_out=False,
        origin_id=0)
    p_array.append(p)
  for i in range(10,20):
    p = geometry_restraints.bond_simple_proxy(
        i_seqs=[i,i+1],
        distance_ideal=3.5,
        weight=1,
        slack=1,
        limit=1,
        top_out=False,
        origin_id=1)
    p_array.append(p)
  for i in range(20,30):
    p = geometry_restraints.bond_simple_proxy(
        i_seqs=[i,i+1],
        distance_ideal=3.5,
        weight=1,
        slack=1,
        limit=1,
        top_out=False,
        origin_id=2)
    p_array.append(p)
  proxies = geometry_restraints.shared_bond_simple_proxy(p_array)
  new_p2 = proxies.proxy_select(origin_id=1)
  new_p3 = proxies.proxy_select(origin_id=2)
  new_p4 = proxies.proxy_select(origin_id=3)
  assert len(new_p2) == 10
  assert len(new_p3) == 10
  assert len(new_p4) == 0

  sites_cart = flex.vec3_double([[1,2,3],[2,3,4]])
  asu_mappings = direct_space_asu.non_crystallographic_asu_mappings(
    sites_cart=sites_cart)
  pair_generator = crystal.neighbors_fast_pair_generator(
    asu_mappings=asu_mappings,
    distance_cutoff=5)
  pgn = next(pair_generator)
  p_array = []
  for i in range(10):
    p = geometry_restraints.bond_asu_proxy(
      pair=pgn,
      distance_ideal=2,
      weight=10, slack=2, limit=1, top_out=True, origin_id=0)
    p_array.append(p)
  for i in range(10,20):
    p = geometry_restraints.bond_asu_proxy(
      pair=pgn,
      distance_ideal=2,
      weight=10, slack=2, limit=1, top_out=True, origin_id=1)
    p_array.append(p)
  for i in range(20,30):
    p = geometry_restraints.bond_asu_proxy(
      pair=pgn,
      distance_ideal=2,
      weight=10, slack=2, limit=1, top_out=True, origin_id=2)
    p_array.append(p)
  proxies = geometry_restraints.shared_bond_asu_proxy(p_array)
  new_p2 = proxies.proxy_select(origin_id=1)
  new_p3 = proxies.proxy_select(origin_id=2)
  new_p4 = proxies.proxy_select(origin_id=3)
  assert len(new_p2) == 10
  assert len(new_p3) == 10
  assert len(new_p4) == 0

def exercise():
  exercise_bond_similarity()
  exercise_bond()
  exercise_bonds_with_symops()
  exercise_nonbonded()
  exercise_nonbonded_cos()
  exercise_angle()
  exercise_dihedral()
  exercise_chirality()
  exercise_planarity()
  # exercise_planarity_top_out()
  exercise_proxy_show()
  exercise_parallelity()
  exercise_origin_id_selections_for_bonds()
  print("OK")

if (__name__ == "__main__"):
  exercise()


 *******************************************************************************
