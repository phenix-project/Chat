

 *******************************************************************************
xfel/ui/__init__.py
from __future__ import absolute_import, division, print_function
import os
from iotbx.phil import parse
from libtbx.utils import Sorry

master_phil_str = """
dispatcher = cctbx.xfel.process
  .type = str
  .help = Which program to run. cctbx.xfel.process should be used in most cases.
dry_run = False
  .type = bool
  .help = If True, the program will create the trial directory but not submit the job, \
          and will show the command that would have been executed.
monitoring_mode = False
  .type = bool
  .help = If True, will hide the submit jobs buttons and remove tabs for configuring \
          Trials and Datasets.
facility {
  name = lcls *standalone
    .type = choice
    .help = Facility for the XFEL gui. LCLS configures the GUI to use LCLS services \
            for data monitoring, job submission, and so forth. Standlone runs the \
            GUI for all other data sources.
  lcls {
    experiment = ""
      .type = str
      .help = Experiment name, eg cxid9114
    web {
      location = "SLAC"
        .type = str
        .help = Where to look for XTC streams. Can be SLAC, SLACFFB (active experiment \
                only, retired), SRCF_FFB (active experiment only), SDF or NERSC \
                (contact LCLS staff to arrange file mover for SDF or NERSC).
      user = ""
        .type = str
        .help = Username for LCLS run database web service
      password = ""
        .type = str
        .help = Web password. Will be cached in plain text!
      enforce80 = False
        .type = bool
        .help = report only on stream 81, FEE spectrometer
      enforce81 = False
        .type = bool
        .help = report only on stream 81, FEE spectrometer
    }
    use_ffb = False
      .type = bool
      .help = Run on the ffb if possible. Only for active users!
    dump_shots = False
      .type = bool
      .help = Write images to disk whether they index or not. \
              Helpful for tuning spotfinding and indexing parameters, and necessary \
              for the "Should have indexed" feature of the Run Stats tab.
  }
  standalone {
    data_dir = None
      .type = path
      .help = Folder to monitor for new data
    monitor_for = *files folders
      .type = choice
      .help = Whether to monitor for new files or new folders with files in them
    folders {
      method = *status_file n_files
        .type = choice
        .help = How to determine if a run is complete. status_file: look for a \
                status.txt file. n_files: run is complete when at least \
                n_files_needed files are found
      n_files_needed = 0
        .type = int
        .help = If criteria is n_files, this is how many files are needed \
                before a run is complete
    }
    files {
      last_modified = 0
        .type = float
        .help = This is the miniumum number of seconds since a file was last \
                modified before the run is complete
      minimum_file_size = 0
        .type = int
        .help = Minimum file size (in bytes) before the run is complete
    }
    template = None
      .type = str
      .help = File matching pattern for new data. Example: *.h5
    composite_files = True
      .type = bool
      .help = If True, files are submitted as individual runs. Otherwise, groups \
              of files are submitted as single runs
  }
}
output_folder = ""
  .type = path
  .help = Processing results will go in this folder

include scope xfel.command_line.cxi_mpi_submit.mp_phil_scope
"""
db_phil_str = """
experiment_tag = None
  .type = str
  .help = User defined tag to describe the set of trials being performed. All database tables will \
          be pre-pended with this string
db {
  host = psdb-user.slac.stanford.edu
    .type = str
    .help = Host name for mysql databse server
  name = ""
    .type = str
    .help = Database name
  user = ""
    .type=str
    .help = Database user name
  password = ""
    .type = str
    .help = Database password. Will be cached as plain text!
  verbose = False
    .type = bool
    .expert_level = 2
    .help = Print to the terminal all database queries
  port = 3306
    .type = int
    .help = Port number to be used for connection
  logging_batch_size = 3
    .type = int
    .help = Number of images to log at once. Increase if using many (thousands) of processors.
  server {
    basedir = None
      .type = path
      .help = Root folder for mysql database

    prompt_for_root_password = False
      .type = bool
      .help = Whether to always ask for the root password. Note, root password is always \
              needed when the database is initialized.

    root_user = 'root'
      .type = str
      .help = username for root
      .expert_level = 2

    root_password = None
      .type = str
      .help = Password for root user
      .expert_level = 2
  }
}
"""
master_phil_scope = parse(master_phil_str + db_phil_str, process_includes=True)

settings_dir = os.path.join(os.path.expanduser('~'), '.cctbx.xfel')
settings_file = os.path.join(settings_dir, 'settings.phil')

known_dials_dispatchers = {
  'cctbx.xfel.xtc_process': 'xfel.command_line.xtc_process',
  'cctbx.xfel.process': 'xfel.command_line.xfel_process',
  'dials.stills_process': 'dials.command_line.stills_process',
  'cctbx.xfel.small_cell_process': 'xfel.small_cell.command_line.xfel_small_cell_process',
  'cctbx.xfel.stripe_experiment': 'xfel.command_line.striping',
  'cctbx.xfel.merge': 'xfel.merging.application.phil.phil'
}

def load_phil_scope_from_dispatcher(dispatcher):
  import importlib
  module = importlib.import_module(known_dials_dispatchers[dispatcher])
  importlib.reload(module)
  phil_scope = module.phil_scope
  return phil_scope

def load_cached_settings(scope=None, extract=True):
  if scope is None:
    scope = master_phil_scope
  if os.path.exists(settings_file):
    user_phil = parse(file_name = settings_file)
    scope, unused = scope.fetch(source = user_phil, track_unused_definitions=True)
    if not extract:
      return scope
    params = scope.extract()
    if len(unused) > 0:
      from .phil_patch import sync_phil
      sync_phil(params, unused)
    return params
  else:
    if extract:
      return scope.extract()
    else:
      return scope

def save_cached_settings(params):
  if not os.path.exists(settings_dir):
    os.makedirs(settings_dir)

  working_phil = master_phil_scope.format(python_object = params)
  diff_phil = master_phil_scope.fetch_diff(source = working_phil)

  try:
    f = open(settings_file.encode('utf8'), 'wb')
    f.write(diff_phil.as_str().encode('utf8'))
    f.close()
  except IOError:
    raise Sorry('Unable to write %s.' % settings_file)


 *******************************************************************************


 *******************************************************************************
xfel/ui/command_line/__init__.py


 *******************************************************************************


 *******************************************************************************
xfel/ui/command_line/get_hit_timestamps.py
from __future__ import absolute_import, division, print_function

from libtbx.phil import parse
from libtbx.utils import Sorry
from xfel.ui import db_phil_str
from xfel.ui.db.xfel_db import xfel_db_application
import sys, os

"""
Jiffy script to print out all the hits from the database. If the user was dumping all shots, they can
use this script to print all the file paths of all the hits.
"""

phil_str = """
  trial = None
    .type = int
  hit_cutoff = 16
    .type = int
    .help = Number of reflections to consider an image a hit. Estimate by looking at plot of strong reflections/image.
  output_folder = None
    .type = str
    .help = Folder with results from cctbx.xfel processing
"""
phil_scope = parse(phil_str + db_phil_str)

def run(args):
  user_phil = []
  for arg in args:
    try:
      user_phil.append(parse(arg))
    except Exception as e:
      raise Sorry("Unrecognized argument %s"%arg)
  params = phil_scope.fetch(sources=user_phil).extract()

  app = xfel_db_application(params)
  trial = app.get_trial(trial_number = params.trial)
  jobs = app.get_all_jobs()
  for rungroup in trial.rungroups:
    for run in rungroup.runs:
      if params.output_folder is None:
        job = None
        all_path = None
      else:
        job_found = None
        for job in jobs:
          if job.trial.id == trial.id and job.rungroup.id == rungroup.id and job.run.id == run.id:
            all_path = os.path.join(os.path.sep.join(job.get_log_path().split(os.path.sep)[:-2]), "all")
            assert job_found is None
            job_found = job
        assert job_found is not None
        job = job_found

      where = "WHERE event.n_strong >= %d" % params.hit_cutoff
      events = app.get_all_events(trial = trial, runs = [run], only_indexed = False, where = where)
      for e in events:
        t = e.timestamp
        ts = t[0:4] + t[5:7] + t[8:10] + t[11:13] + t[14:16] + t[17:19] + t[20:23]
        if all_path is None:
          print("%04d"%run.run, ts)
        else:
          print(os.path.join(all_path, "shot-" + ts + ".pickle"))

if __name__ == "__main__":
  run(sys.argv[1:])


 *******************************************************************************


 *******************************************************************************
xfel/ui/command_line/plot_isoform_cloud.py
from __future__ import absolute_import, division, print_function

from libtbx.phil import parse
from libtbx.utils import Sorry
from xfel.ui.db.xfel_db import xfel_db_application
import sys
from xfel.ui import db_phil_str

"""
Script to compare whether a given trial is sorting results into the proper isoforms. Requires two trials, one with an isoforms and one without
"""

phil_str = """
  trial_noisoforms = None
    .type = int
  trial_isoforms = None
    .type = int
  tag = None
    .type = str
"""
phil_scope = parse(phil_str + db_phil_str)

def run(args):
  user_phil = []
  for arg in args:
    try:
      user_phil.append(parse(arg))
    except Exception as e:
      raise Sorry("Unrecognized argument %s"%arg)
  params = phil_scope.fetch(sources=user_phil).extract()

  app = xfel_db_application(params)

  trial_ni = app.get_trial(trial_number=params.trial_noisoforms)
  trial_i = app.get_trial(trial_number=params.trial_isoforms)

  tags = []
  if params.tag is not None and len(params.tag) > 0:
    for tag in app.get_all_tags():
      if params.tag == tag.name:
        tags.append(tag)
    extra_title = ",".join([t.name for t in tags])
    tag_ids = [t.id for t in tags]
    runs_ni = [r for r in trial_ni.runs if any([t.id in tag_ids for t in r.tags])]
    runs_i = [r for r in trial_i.runs if any([t.id in tag_ids for t in r.tags])]
  else:
    extra_title = None
    runs_ni = trial_ni.runs
    runs_i = trial_i.runs

  runs_ni_str = "(%s)"%(", ".join([str(r.id) for r in runs_ni]))
  exp_tag = params.experiment_tag

  isoforms = app.get_trial_isoforms(trial_i.id)

  print("Reading data...")
  info_list = []
  legend_list = []
  for isoform in isoforms:
    events_i = app.get_all_events(trial = trial_i, runs = runs_i, isoform=isoform)
    if len(events_i) == 0:
      print("No events of isoform %s found"%isoform.name)
      continue
    legend_list.append(isoform.name)
    events_i_str = "(%s)"%(", ".join(["'%s'"%e.timestamp for e in events_i]))

    query = """SELECT crystal.cell_id FROM `%s_crystal` crystal
               JOIN `%s_experiment` exp ON exp.crystal_id = crystal.id
               JOIN `%s_imageset` imgset ON imgset.id = exp.imageset_id
               JOIN `%s_imageset_event` ie ON ie.imageset_id = imgset.id
               JOIN `%s_event` evt ON evt.id = ie.event_id
               JOIN `%s_trial` trial ON trial.id = evt.trial_id
               JOIN `%s_run` run ON run.id = evt.run_id
               WHERE run.id in %s AND trial.id = %d AND evt.timestamp IN %s""" % (
      exp_tag, exp_tag, exp_tag, exp_tag, exp_tag, exp_tag, exp_tag, runs_ni_str, trial_ni.id, events_i_str)
    cell_ids = [str(i[0]) for i in app.execute_query(query).fetchall()]
    if len(cell_ids) == 0:
      cells = []
    else:
      from xfel.ui.db.experiment import Cell
      cells = app.get_all_x(Cell, 'cell', where = "WHERE id IN (%s)"%", ".join(cell_ids))

    print(len(cells))
    info = []
    for cell in cells:
      info.append({'a':cell.cell_a,
                   'b':cell.cell_b,
                   'c':cell.cell_c,
                   'alpha':cell.cell_alpha,
                   'beta':cell.cell_beta,
                   'gamma':cell.cell_gamma,
                   'n_img':0})
    info_list.append(info)

  import xfel.ui.components.xfel_gui_plotter as pltr
  plotter = pltr.PopUpCharts()
  plotter.plot_uc_histogram(info_list=info_list, legend_list=legend_list, extra_title=extra_title)
  plotter.plt.show()

if __name__ == "__main__":
  run(sys.argv[1:])


 *******************************************************************************


 *******************************************************************************
xfel/ui/command_line/plot_reflection_stats.py
from __future__ import absolute_import, division, print_function
from six.moves import range
# LIBTBX_SET_DISPATCHER_NAME cctbx.xfel.plot_reflection_stats
# LIBTBX_PRE_DISPATCHER_INCLUDE_SH export PHENIX_GUI_ENVIRONMENT=1
# LIBTBX_PRE_DISPATCHER_INCLUDE_SH export BOOST_ADAPTBX_FPE_DEFAULT=1
from matplotlib import pyplot as plt
from xfel.command_line.detector_residuals import setup_stats
from dials.array_family import flex
from dials.util import show_mail_on_error
import math
from libtbx.phil import parse
from scitbx.math import five_number_summary

help_message = """
Two plots:
deltaXY: plot of the difference between observed and predicted reflections in microns vs. two theta. Only reflections with I/sigI >= 5 are included.
I/sigI: plot of I/sigI for all reflections vs. two theta.

Two theta bins with fewer than 10 reflections are ommited.

For each plot, the median value per two theta bin is plotted.  The shaded area comprised the upper and lower quartiles.
N reflections per two theta bin is also plotted.

Example:
cctbx.xfel.plot_reflection_stats integrated1.expt integrated1.refl integrated2.expt integrated2.refl
"""

phil_str = """
save_pdf = False
  .type = bool
  .help = If true, save results as pdf
tag = None
  .type = str
  .help = Title for the plots
"""
phil_scope = parse(phil_str)

class Script(object):
  '''A class for running the script.'''

  def __init__(self):
    '''Initialise the script.'''
    from dials.util.options import ArgumentParser
    import libtbx.load_env

    # The script usage
    usage = "usage: %s [options] [param.phil] filenames" % libtbx.env.dispatcher_name

    # Create the parser
    self.parser = ArgumentParser(
      usage=usage,
      phil=phil_scope,
      check_format=False,
      read_experiments=True,
      read_reflections=True,
      epilog=help_message
      )

  def run(self):
    '''Execute the script.'''
    # Parse the command line
    params, options = self.parser.parse_args(show_diff_phil=True)

    n_bins = 10
    arbitrary_padding = 1
    legend = []

    # local container for axes
    figures = {}

    for plot in ['deltaXY','isigi']:
      fig, ax1 = plt.subplots()
      fig.suptitle(plot)
      ax2 = ax1.twinx()
      figures[plot] = {'fig':fig, 'ax1': ax1, 'ax2': ax2}

    def plotit(reflections, experiments):
      """
      Make the plots for a set of reflections and experiments.
      """
      beam = experiments.beams()[0] # only used to compute resolution of 2theta
      reflections = reflections.select(reflections['intensity.sum.variance'] > 0)

      # Setup up deltaXY and two theta bins
      reflections['difference_vector_norms'] = (reflections['xyzcal.mm']-reflections['xyzobs.mm.value']).norms()
      reflections = setup_stats(experiments, reflections, two_theta_only=True) # add two theta to reflection table
      sorted_two_theta = flex.sorted(reflections['two_theta_obs'])
      bin_low = [sorted_two_theta[int((len(sorted_two_theta)/n_bins) * i)] for i in range(n_bins)]
      bin_high = [bin_low[i+1] for i in range(n_bins-1)]
      bin_high.append(sorted_two_theta[-1]+arbitrary_padding)

      x_centers = flex.double()
      n_refls = flex.int()
      rmsds = flex.double()
      p25r = flex.double()
      p50r = flex.double()
      p75r = flex.double()
      p25i = flex.double()
      p50i = flex.double()
      p75i = flex.double()
      print("# 2theta Res N dXY IsigI")

      # Compute stats for each bin
      for i in range(n_bins):
        refls = reflections.select((reflections['two_theta_obs'] >= bin_low[i]) & (reflections['two_theta_obs'] < bin_high[i]))
        # Only compute deltaXY stats on reflections with I/sigI at least 5
        i_sigi = refls['intensity.sum.value']/flex.sqrt(refls['intensity.sum.variance'])
        refls = refls.select(i_sigi >= 5)
        n = len(refls)
        if n < 10: continue
        min_r, q1_r, med_r, q3_r, max_r = five_number_summary(1000*refls['difference_vector_norms'])

        n_refls.append(n)

        rmsds_ = 1000*math.sqrt(flex.sum_sq(refls['difference_vector_norms'])/n)

        min_i, q1_i, med_i, q3_i, max_i = five_number_summary(i_sigi)
        p25i.append(q1_i)
        p50i.append(med_i)
        p75i.append(q3_i)
        # x_center
        c = ((bin_high[i]-bin_low[i])/2) + bin_low[i]
        # resolution
        d = beam.get_wavelength()/(2*math.sin(math.pi*c/(2*180)))
        x_centers.append(c)
        rmsds.append(rmsds_)
        print("%d % 5.1f % 5.1f % 8d %.1f %.1f"%(i, c, d, n, med_r, med_i))
        p25r.append(q1_r)
        p50r.append(med_r)
        p75r.append(q3_r)

      # After binning, plot the results
      for plot in figures:
        ax1 = figures[plot]['ax1']
        ax2 = figures[plot]['ax2']
        if plot == 'isigi':
          line, = ax1.plot(x_centers.as_numpy_array(), p50i.as_numpy_array(), '-')
          line.set_label('Median')
          ax1.fill_between(x_centers.as_numpy_array(), p25i.as_numpy_array(), p75i.as_numpy_array(),
            interpolate = True, alpha = 0.50, color = line.get_color())
          line, = ax2.plot(x_centers.as_numpy_array(), n_refls.as_numpy_array(), '-', color = line.get_color())
          line.set_label('Median')
        elif plot == 'deltaXY':
          line, = ax1.plot(x_centers.as_numpy_array(), p50r.as_numpy_array(), '-')
          line.set_label('Median')
          ax1.fill_between(x_centers.as_numpy_array(), p25r.as_numpy_array(), p75r.as_numpy_array(),
            interpolate = True, alpha = 0.50, color = line.get_color())
          line, = ax2.plot(x_centers.as_numpy_array(), n_refls.as_numpy_array(), '-', color = line.get_color())
          line.set_label('Median')
        ax1.legend()
        ax2.legend()

    assert len(params.input.experiments) == len(params.input.reflections)

    # Plotit!
    for i in range(len(params.input.experiments)):
      plotit(params.input.reflections[i].data, params.input.experiments[i].data)

    # Set up labels
    for plot in figures:
      fig = figures[plot]['fig']
      ax1 = figures[plot]['ax1']
      ax2 = figures[plot]['ax2']
      if plot == 'isigi':
        ax1.set_ylabel("I/sigI")
        ax2.set_ylabel("N reflections")
        ax1.set_xlabel("Two theta (degrees)")
      elif plot == 'deltaXY':
        ax1.set_ylabel(r"$\Delta$XY")
        ax2.set_ylabel("N reflections")
        ax1.set_xlabel("Two theta (degrees)")
      if params.tag is not None:
        pass

    if params.save_pdf:
      from matplotlib.backends.backend_pdf import PdfPages
      pp = PdfPages('reflection_stats.pdf')
      for i in plt.get_fignums():
        pp.savefig(plt.figure(i), dpi=300)
      pp.close()
    else:
      plt.show()

if __name__ == '__main__':
  with show_mail_on_error():
    script = Script()
    script.run()


 *******************************************************************************


 *******************************************************************************
xfel/ui/command_line/plot_run_stats.py
from __future__ import absolute_import, division, print_function

'''
Author      : Young, I.D.
Created     : 07/14/2016
Last Changed: 07/14/2016
Description : XFEL UI plot real-time run stats
'''

from libtbx.phil import parse
from libtbx.utils import Sorry
from xfel.ui import master_phil_str, db_phil_str
from xfel.ui.db.xfel_db import xfel_db_application
from xfel.ui.db.stats import HitrateStats
from xfel.ui.components.run_stats_plotter import plot_multirun_stats
import sys

phil_str = """
  run = None
    .type = str
    .multiple = True
  trial = None
    .type = int
  rungroup = None
    .type = int
  d_min = 2.0
    .type = float
    .help = High resolution bin for the I/sig(I) plot and per-run statistics.
  n_strong_cutoff = 16
    .type = int
    .help = Number of strong spots to consider an image a hit.
  i_sigi_cutoff = 1
    .type = float
    .help = Avg. I/sig(I) in a bin to reach the cutoff for producing a spot (low or high res) in the third plot.
  run_tags = None
    .type = str
    .multiple = True
    .help = Tags to be applied as labels to the runs.
  minimalist = False
    .type = bool
    .help = Generate final plot without run tags, per-run text summaries or vertical lines between runs.
  compress_runs = True
    .type = bool
    .help = When plotting multiple runs, adjust timestamps so there is no blank space between them.
    .help = This mode is not compatible with fetching events from timestamps.
  title = None
    .type = str
    .help = Plot title.
"""
phil_scope = parse(phil_str + master_phil_str + db_phil_str)

def run(args):
  user_phil = []
  for arg in args:
    try:
      user_phil.append(parse(arg))
    except Exception as e:
      raise Sorry("Unrecognized argument %s"%arg)
  params = phil_scope.fetch(sources=user_phil).extract()

  app = xfel_db_application(params)
  runs = []
  all_results = []
  if params.rungroup is None:
    assert len(params.run) == 0
    trial = app.get_trial(trial_number = params.trial)
    for rungroup in trial.rungroups:
      for run in rungroup.runs:
        stats = HitrateStats(app, run.run, trial.trial, rungroup.id, params.d_min)()
        if len(stats[0]) > 0:
          runs.append(run.run)
          all_results.append(stats)
  else:
    for run_no in params.run:
      runs.append(run_no)
      all_results.append(HitrateStats(app, run_no, params.trial, params.rungroup, params.d_min)())
  plot_multirun_stats(all_results, runs, params.d_min, n_strong_cutoff=params.n_strong_cutoff, \
    i_sigi_cutoff=params.i_sigi_cutoff, run_tags=params.run_tags, title=params.title, \
    minimalist=params.minimalist, interactive=True, compress_runs=params.compress_runs)

if __name__ == "__main__":
  run(sys.argv[1:])


 *******************************************************************************


 *******************************************************************************
xfel/ui/command_line/plot_run_stats_from_experiments.py
from __future__ import absolute_import, division, print_function
# LIBTBX_SET_DISPATCHER_NAME cctbx.xfel.plot_run_stats_from_experiments
# LIBTBX_PRE_DISPATCHER_INCLUDE_SH export PHENIX_GUI_ENVIRONMENT=1
# LIBTBX_PRE_DISPATCHER_INCLUDE_SH export BOOST_ADAPTBX_FPE_DEFAULT=1

from libtbx.phil import parse
from libtbx.utils import Sorry
from xfel.ui.components.run_stats_plotter import plot_multirun_stats
import sys, os
from dials.array_family import flex
from dxtbx.model.experiment_list import ExperimentListFactory
from dials.algorithms.integration.stills_significance_filter import SignificanceFilter, phil_scope as sf_scope

"""
Script to analyze the results of dials.stills_process and plot statisitics over time using the xfel gui.

Example command:
cctbx.xfel.plot_run_stats_from_experiments . d_min=2.0
"""

phil_str = """
  d_min = 2.0
    .type = float
    .help = High resolution bin for the I/sig(I) plot and per-run statistics.
  n_strong_cutoff = 16
    .type = int
    .help = Number of strong spots to consider an image a hit.
  i_sigi_cutoff = 1
    .type = float
    .help = Avg. I/sig(I) in a bin to reach the cutoff for producing a spot (low or high res) in the third plot.
  run_tags = None
    .type = str
    .multiple = True
    .help = Tags to be applied as labels to the runs.
  run_tags_from_filenames = True
    .type = bool
    .help = Attempt to find the run number in the filenames supplied.
  minimalist = False
    .type = bool
    .help = Generate final plot without run tags, per-run text summaries or vertical lines between runs.
  title = None
    .type = str
    .help = Plot title.
"""
phil_scope = parse(phil_str)

def run(args):
  user_phil = []
  input_dirs = []
  input_paths = []
  for arg in args:
    if os.path.isdir(arg):
      input_dirs.append(arg)
      continue
    elif os.path.exists(arg):
      input_paths.append(arg)
      continue
    try:
      user_phil.append(parse(arg))
    except Exception as e:
      raise Sorry("Unrecognized argument %s"%arg)
  params = phil_scope.fetch(sources=user_phil).extract()
  sf_params = sf_scope.extract()
  sf_params.significance_filter.isigi_cutoff = params.i_sigi_cutoff
  sf_params.significance_filter.d_min = params.d_min

  def get_paths(dirname):
    absolute = lambda name: os.path.join(dirname, name)
    names = os.listdir(dirname)
    return [absolute(n) for n in names]

  files_dict = {dirname:get_paths(dirname) for dirname in input_dirs}
  if params.run_tags_from_filenames:
    for path in input_paths:
      filename = os.path.basename(path)
      try:
        run = int(filename.split("idx-")[1].split("-")[0].split("run")[1])
      except Exception:
        run = int(filename.split("idx-")[1].split("-")[0].split("r")[1])
      except Exception:
        run = None
      try:
        files_dict[run].append(path)
      except KeyError:
        files_dict[run] = [path]
  else:
    files_dict[None] = input_paths
  all_results = []
  runs = []

  # iterate through grouped file paths and look for processing results
  for run in sorted(files_dict):
    files = files_dict[run]
    if len(files) == 0: continue
    runs.append(run)
    timestamps = flex.double()
    two_theta_low = flex.double()
    two_theta_high = flex.double()
    n_strong = flex.int()
    resolutions = flex.double()
    n_lattices = flex.int()

    for i, path in enumerate(sorted(files)):
      root = os.path.dirname(path)
      filename = os.path.basename(path)
      extension = os.path.splitext(filename)[1]
      split_fn = filename.split('_')
      if extension not in ['.refl', '.pickle', '.mpack'] or len(split_fn) <= 0 or not split_fn[-1].startswith('strong'):
        continue
      base = os.path.join(root, "_".join(split_fn[:-1]))
      print(filename)
      strong_name = base + "_strong%s"%extension
      if not os.path.exists(strong_name):
        print("Couldn't log %s, strong%s not found"%(filename, exension))
        continue

      # Read the spotfinding results
      strong = flex.reflection_table.from_file(strong_name)
      print("N strong reflections: %d"%len(strong))

      timestamps.append(i)
      n_strong.append(len(strong))
      two_theta_low.append(0)
      two_theta_high.append(0)

      # Read indexing results if possible
      experiments_name = base + "_integrated"
      if extension == ".refl":
        experiments_name += ".expt"
      else:
        experiments_name += "_experiments.json"
      indexed_name = base + "_integrated%s"%extension
      if not os.path.exists(experiments_name) or not os.path.exists(indexed_name):
        print("Frame didn't index")
        resolutions.append(0)
        n_lattices.append(0)
        continue

      experiments = ExperimentListFactory.from_json_file(experiments_name, check_format=False)
      n_lattices.append(len(experiments))
      reflections = flex.reflection_table.from_file(indexed_name)
      reflections = reflections.select(reflections['intensity.sum.value'] > 0) # positive reflections only
      best_d_min = None
      for expt_id, experiment in enumerate(experiments):
        refls = reflections.select(reflections['id'] == expt_id)
        refls['id'] = flex.int(len(refls), 0)
        sig_filter = SignificanceFilter(sf_params)
        sig_filter(experiments[expt_id:expt_id+1], refls)
        if best_d_min is None or sig_filter.best_d_min < best_d_min:
          best_d_min = sig_filter.best_d_min
      resolutions.append(best_d_min or 0)

    all_results.append((timestamps, two_theta_low, two_theta_high, n_strong, resolutions, n_lattices))

  plot_multirun_stats(all_results, runs, params.d_min, n_strong_cutoff=params.n_strong_cutoff, \
    i_sigi_cutoff=params.i_sigi_cutoff, run_tags=params.run_tags, \
    minimalist=params.minimalist, interactive=True, compress_runs=True, \
    title=params.title)


if __name__ == "__main__":
  run(sys.argv[1:])


 *******************************************************************************


 *******************************************************************************
xfel/ui/command_line/plot_run_stats_in_gui.py
from __future__ import absolute_import, division, print_function
# LIBTBX_SET_DISPATCHER_NAME cctbx.xfel.plot_run_stats_from_stats_pickle
# LIBTBX_PRE_DISPATCHER_INCLUDE_SH export PHENIX_GUI_ENVIRONMENT=1
# LIBTBX_PRE_DISPATCHER_INCLUDE_SH export BOOST_ADAPTBX_FPE_DEFAULT=1

from xfel.ui.components.run_stats_plotter import plot_run_stats

def easy_run_plot_multirun_stats(pickle):
  from libtbx import easy_pickle
  contents = easy_pickle.load(pickle)
  stats_tuple, d_min, n_multiples, run_tags, run_statuses, minimalist, interactive, xsize, ysize, high_vis, title = contents
  print(plot_run_stats(stats_tuple, d_min, n_multiples, run_tags=run_tags, run_statuses=run_statuses, minimalist=minimalist,
    interactive=interactive, xsize=xsize, ysize=ysize, high_vis=high_vis, title=title))
  #plot_run_stats(stats_tuple, d_min, run_tags=run_tags, run_statuses=run_statuses, minimalist=minimalist,
  #  interactive=True, xsize=xsize, ysize=ysize, high_vis=high_vis, title=title)

if __name__ == "__main__":
  import sys
  easy_run_plot_multirun_stats(sys.argv[1])



 *******************************************************************************


 *******************************************************************************
xfel/ui/command_line/plot_spotfinder_stats_in_gui.py
from __future__ import absolute_import, division, print_function
# LIBTBX_SET_DISPATCHER_NAME cctbx.xfel.plot_spotfinder_stats_from_stats_pickle
# LIBTBX_PRE_DISPATCHER_INCLUDE_SH export PHENIX_GUI_ENVIRONMENT=1
# LIBTBX_PRE_DISPATCHER_INCLUDE_SH export BOOST_ADAPTBX_FPE_DEFAULT=1

from xfel.ui.components.spotfinder_plotter import plot_spotfinder_stats

def easy_run_plot_spotfinder_stats(pickle):
  from libtbx import easy_pickle
  contents = easy_pickle.load(pickle)
  stats_tuple, spot_length_stats_tuple, run_tags, run_statuses, minimalist, interactive, xsize, ysize, high_vis, title = contents
  print(plot_spotfinder_stats(stats_tuple, spot_length_stats_tuple, run_tags=run_tags, run_statuses=run_statuses, minimalist=minimalist,
    interactive=interactive, xsize=xsize, ysize=ysize, high_vis=high_vis, title=title))

if __name__ == "__main__":
  import sys
  easy_run_plot_spotfinder_stats(sys.argv[1])


 *******************************************************************************


 *******************************************************************************
xfel/ui/command_line/plot_uc_cloud.py
from __future__ import absolute_import, division, print_function

from libtbx.phil import parse
from libtbx.utils import Sorry
from xfel.ui import load_cached_settings
import xfel.ui.components.xfel_gui_plotter as pltr
from xfel.ui.db.xfel_db import xfel_db_application
import sys
from xfel.ui import db_phil_str

phil_str = """
  trial = None
    .type = int
  tag = None
    .type = str
    .multiple = True
  tag_selection_mode = *union intersection
    .type = choice
  run = None
    .type = str
    .multiple = True
  rungroup = None
    .type = int
  iqr_ratio = 1.5
    .type = float
    .help = Interquartile range multiplier for outlier rejection. Use None to disable outlier rejection.
  ranges = None
    .type = floats(6)
    .help = Lower and upper bounds for the ranges to display for each of the a, b and c axes
  angle_ranges = None
    .type = floats(6)
    .help = Lower and upper bounds for the ranges to display for each of the cell angles
 """
phil_scope = parse(phil_str + db_phil_str)

def run(args):
  user_phil = []
  for arg in args:
    try:
      user_phil.append(parse(arg))
    except Exception as e:
      raise Sorry("Unrecognized argument %s"%arg)
  scope = load_cached_settings(scope=phil_scope, extract=False)
  params = scope.fetch(sources=user_phil).extract()

  app = xfel_db_application(params)

  if params.tag is not None and len(params.tag) > 0:
    tags = []
    for tag in app.get_all_tags():
      for t in params.tag:
        if t == tag.name:
          tags.append(tag)
    extra_title = ",".join([t.name for t in tags])
  else:
    tags = None
    extra_title = None

  if params.run is not None and len(params.run) > 0:
    assert params.rungroup is not None
    runs = [app.get_run(run_number = r) for r in params.run]
    rungroup = app.get_rungroup(rungroup_id = params.rungroup)
  else:
    runs = None
    rungroup = None

  if extra_title is None and runs is not None:
    extra_title = "%s"%(",".join(["%s"%r.run for r in runs]))

  trial = app.get_trial(trial_number=params.trial)
  info_list = []
  plotter = pltr.PopUpCharts()
  print("Reading data...")
  if tags:
    for tag in tags:
      info = []
      cells = app.get_stats(trial=trial, tags=[tag], isigi_cutoff = 1.0, tag_selection_mode = params.tag_selection_mode, selected_runs = runs, selected_rungroup = rungroup)()
      for cell in cells:
        info.append({'a':cell.cell_a,
                     'b':cell.cell_b,
                     'c':cell.cell_c,
                     'alpha':cell.cell_alpha,
                     'beta':cell.cell_beta,
                     'gamma':cell.cell_gamma,
                     'n_img':0})
      info_list.append(info)
    plotter.plot_uc_histogram(info_list=info_list, extra_title=extra_title, legend_list=[t.name for t in tags], iqr_ratio = params.iqr_ratio, ranges=params.ranges, angle_ranges=params.angle_ranges)
  else:
    info = []
    cells = app.get_stats(trial=trial, isigi_cutoff = 1.0, selected_runs = runs, selected_rungroup = rungroup)()
    for cell in cells:
      info.append({'a':cell.cell_a,
                   'b':cell.cell_b,
                   'c':cell.cell_c,
                   'alpha':cell.cell_alpha,
                   'beta':cell.cell_beta,
                   'gamma':cell.cell_gamma,
                   'n_img':0})
    info_list.append(info)
    plotter.plot_uc_histogram(info_list=info_list, extra_title=extra_title, legend_list=[""], iqr_ratio = params.iqr_ratio, ranges=params.ranges, angle_ranges=params.angle_ranges)
  plotter.plot_uc_3Dplot(info=info, iqr_ratio = params.iqr_ratio)
  plotter.plt.show()

if __name__ == "__main__":
  run(sys.argv[1:])


 *******************************************************************************


 *******************************************************************************
xfel/ui/command_line/plot_uc_cloud_from_experiments.py
from __future__ import absolute_import, division, print_function
from six.moves import range
# LIBTBX_SET_DISPATCHER_NAME cctbx.xfel.plot_uc_cloud_from_experiments
# LIBTBX_PRE_DISPATCHER_INCLUDE_SH export PHENIX_GUI_ENVIRONMENT=1
# LIBTBX_PRE_DISPATCHER_INCLUDE_SH export BOOST_ADAPTBX_FPE_DEFAULT=1

from dials.util import show_mail_on_error
from libtbx.phil import parse

help_message = """
Plot a cloud of unit cell dimensions from stills. Provide either a combined.expt
file or a specify individual .expt files on the command line. To generate an overlay of
multiple plots (similar to grouping by run tag in the XFEL GUI), provide multiple
combined.expt files named as ${tag}_combined_*.expt and set extract_tags to True in
the phil scope.
"""

phil_str = """
  iqr_ratio = None
    .type = float
    .help = Interquartile range multiplier for outlier rejection. Use None to disable outlier rejection.
  ranges = None
    .type = floats(6)
    .help = Lower and upper bounds for the ranges to display for each of the a, b and c axes
  angle_ranges = None
    .type = floats(6)
    .help = Lower and upper bounds for the ranges to display for each of the cell angles
  extract_tags = False
    .type = bool
    .help = Extract tags from the names of multiple combined.expt filenames and use
    .help = these tags to label multiple groups of experiments.
  combine_all_input = False
    .type = bool
    .help = Combine all experiment lists to generate a single unit cell histogram. Useful for plotting
    .help = data from multiple runs outside the cctbx.xfel GUI.
  title = None
    .type = str
    .help = Title for the plot
  write_gnuplot_cloud = False
    .type = bool
    .help = If True, write a list of cells such that gnuplot can read them. Start gnuplot then use \
            splot "uccloud.dat".
  output.image_file = None
    .type = str
  scale = *linear log
    .type = choice
    .help = Z-axis scale for 2d histograms
"""
phil_scope = parse(phil_str)

class Script(object):
  '''A class for running the script.'''

  def __init__(self):
    '''Initialise the script.'''
    from dials.util.options import ArgumentParser
    import libtbx.load_env

    # The script usage
    usage = "usage: %s [options] [param.phil] filenames" % libtbx.env.dispatcher_name

    self.tag = None
    self.reference_detector = None

    # Create the parser
    self.parser = ArgumentParser(
      usage=usage,
      phil=phil_scope,
      read_experiments=True,
      check_format=False,
      epilog=help_message
      )

  def run(self):
    '''Execute the script.'''
    # Parse the command line
    params, options = self.parser.parse_args(show_diff_phil=True)

    if params.write_gnuplot_cloud:
      gnuplot = open("uccloud.dat", 'w')

    def get_info(experiment):
      a, b, c, alpha, beta, gamma = experiment.crystal.get_unit_cell().parameters()
      return {'a':a,
              'b':b,
              'c':c,
              'alpha':alpha,
              'beta':beta,
              'gamma':gamma,
              'n_img':0}
    experiments_list = [e.data for e in params.input.experiments]
    if params.extract_tags:
      import os
      experiments_tags = [os.path.splitext(os.path.basename(f.filename))[0] for f in params.input.experiments]
      info_list = []
      for experiments in experiments_list:
        infos = []
        for experiment in experiments:
          info = get_info(experiment)
          infos.append(info)
          if params.write_gnuplot_cloud:
            gnuplot.write("% 3.10f % 3.10f % 3.10f\n"%(info['a'], info['b'], info['c']))
        info_list.append(infos)
    else:
      experiments_tags = [str(i) for i in range(len(experiments_list))]
      info_list = []
      for experiments in experiments_list:
        infos = []
        for experiment in experiments:
          info = get_info(experiment)
          infos.append(info)
          if params.write_gnuplot_cloud:
            gnuplot.write("% 3.10f % 3.10f % 3.10f\n"%(info['a'], info['b'], info['c']))
        info_list.append(infos)
    if params.combine_all_input:
      info_list = [[info for infos in info_list for info in infos]]
      experiments_tags = ["combined"]

    if params.write_gnuplot_cloud:
      gnuplot.close()

    import xfel.ui.components.xfel_gui_plotter as pltr
    interactive = params.output.image_file is None
    plotter = pltr.PopUpCharts(interactive=interactive)
    plotter.plot_uc_histogram(
      info_list=info_list,
      legend_list=experiments_tags,
      iqr_ratio = params.iqr_ratio,
      ranges = params.ranges,
      angle_ranges = params.angle_ranges,
      title = params.title,
      image_fname = params.output.image_file,
      hist_scale = params.scale)
    plotter.plt.show()

if __name__ == '__main__':
  with show_mail_on_error():
    script = Script()
    script.run()


 *******************************************************************************


 *******************************************************************************
xfel/ui/command_line/print_run_stats.py
'''
Author      : Young, I.D.
Created     : 07/14/2016
Last Changed: 07/14/2016
Description : XFEL UI plot real-time run stats
'''
from __future__ import absolute_import, division, print_function

from libtbx.phil import parse
from libtbx.utils import Sorry
from xfel.ui import load_cached_settings
from xfel.ui.db.xfel_db import xfel_db_application
from xfel.ui.db.stats import HitrateStats
import sys
from xfel.ui.command_line.plot_run_stats import phil_scope
from scitbx.array_family import flex
from six.moves import zip

def run(args):
  user_phil = []
  for arg in args:
    try:
      user_phil.append(parse(arg))
    except Exception as e:
      raise Sorry("Unrecognized argument %s"%arg)

  scope = load_cached_settings(scope=phil_scope, extract=False)
  params = scope.fetch(sources=user_phil).extract()
  print("Printing results for trial", params.trial, "using a hit cutoff of", params.n_strong_cutoff, "reflections")
  print()
  print("                 Run  N Drop Hits   (%)   N Hits   (%) N Indexed   (%) N Lattices N High qual   (%)  %HQR   N Frames")

  drop_hits_total = 0
  hit_total = 0
  indexed_total = 0
  lattices_total = 0
  high_quality_total = 0
  overall_total = 0

  ratio_cutoff = 1

  app = xfel_db_application(params)

  if params.run is None or len(params.run) == 0:
    trial = app.get_trial(trial_number=params.trial)
    runs = []
    run_ids = []
    rungroups = []
    for rg in trial.rungroups:
      for run in rg.runs:
        if run.id in run_ids: continue
        if params.run_tags:
          s1 = set(params.run_tags)
          s2 = set(tag.name for tag in run.tags)
          # union?
          #if not s1.intersection(s2): continue
          # intersection
          if not all([t in s1.intersection(s2) for t in s1]): continue

        runs.append(run.run)
        run_ids.append(run.id)
        rungroups.append(rg.id)
  else:
    runs = params.run
    assert params.rungroup is not None
    rungroups = [params.rungroup] * len(runs)

  for run_no, rungroup_id in sorted(zip(runs, rungroups), key=lambda x: x[0]):
    if params.rungroup and params.rungroup != rungroup_id: continue
    try:
      timestamps, two_theta_low, two_theta_high, n_strong, average_i_sigi, n_lattices, wavelengths = HitrateStats(app, run_no, params.trial, rungroup_id, params.d_min, params.i_sigi_cutoff)()
    except Exception as e:
      print("Couldn't get run", run_no)
      continue

    n_hit = (n_strong >= params.n_strong_cutoff).count(True)
    n_indexed = (n_lattices > 0).count(True)
    n_lattices = flex.sum(n_lattices)
    n_total = len(timestamps)
    n_high_quality = ((average_i_sigi > 0) & (n_strong >= params.n_strong_cutoff)).count(True)

    invalid = (two_theta_low <= 0) or (two_theta_high < 0) # <= to prevent /0
    numerator = two_theta_high.set_selected(invalid, 0)
    denominator = two_theta_low.set_selected(two_theta_low == 0, 1) # prevent /0
    drop_ratios = numerator/denominator
    drop_hits = drop_ratios >= ratio_cutoff
    n_drop_hits = drop_hits.count(True)

    try:
      print("% 20s      % 7d % 5.1f  % 7d % 5.1f   % 7d % 5.1f    % 7d     % 7d % 5.1f % 5.1f    % 7d " % (run_no, n_drop_hits, 100*n_drop_hits/n_total, n_hit, 100*n_hit/n_total, n_indexed, 100*n_indexed/n_total, n_lattices, n_high_quality, 100*n_high_quality/n_total, 100*n_high_quality/n_indexed, n_total))
    except ZeroDivisionError:
      print("% 20s      % 7d % 5.1f  % 7d % 5.1f   % 7d % 5.1f    % 7d     % 7d % 5.1f % 5.1f    % 7d " % (run_no, n_drop_hits, 0, n_hit, 0, n_indexed, 0, n_lattices, n_high_quality, 0, 0, n_total))

    drop_hits_total += n_drop_hits
    hit_total += n_hit
    indexed_total += n_indexed
    lattices_total += n_lattices
    high_quality_total += n_high_quality
    overall_total += n_total

  if len(runs) > 1:
    print("-" * 80)
    try:
        print("Total                     % 7d % 5.1f  % 7d % 5.1f   % 7d % 5.1f    % 7d     % 7d % 5.1f % 5.1f    % 7d " % (drop_hits_total, 100*drop_hits_total/overall_total, hit_total, 100*hit_total/overall_total, indexed_total, 100*indexed_total/overall_total, lattices_total, high_quality_total, 100*high_quality_total/overall_total, 100*high_quality_total/indexed_total, overall_total))
    except ZeroDivisionError:
      if overall_total == 0:
        print("Total                     % 7d % 5.1f  % 7d % 5.1f   % 7d % 5.1f    % 7d     % 7d % 5.1f % 5.1f    % 7d " % (drop_hits_total, 0, hit_total, 0, indexed_total, 0, lattices_total, 0, 0, 0, overall_total))
      else:
        print("Total                     % 7d % 5.1f  % 7d % 5.1f   % 7d % 5.1f    % 7d     % 7d % 5.1f % 5.1f    % 7d " % (drop_hits_total, 100*drop_hits_total/overall_total, hit_total, 100*hit_total/overall_total, indexed_total, 100*indexed_total/overall_total, lattices_total, high_quality_total, 100*high_quality_total/overall_total, 0, overall_total))

if __name__ == "__main__":
  run(sys.argv[1:])


 *******************************************************************************


 *******************************************************************************
xfel/ui/command_line/ui_server.py
from __future__ import absolute_import, division, print_function
# LIBTBX_SET_DISPATCHER_NAME cctbx.xfel.ui_server

from libtbx.phil import parse
from libtbx.utils import Sorry
import sys, os, time
from xfel.ui import db_phil_str
from libtbx import easy_run
from xfel.ui.db.xfel_db import db_application

help_message = """

XFEL UI MySQL database server wrapper. Program to initialize and start a mysql database from user space inside the requested folder.

Example:
cctbx.xfel.ui_server db.port=3307 db.server.basedir=`pwd`/MySql db.user=aaron db.name=experiment42

This will look for `pwd`/MSql/my.cnf. If not found, the program will initialize the database, prompt for the entry of a root password, then create the requested database and user account on that database in the folder specified with basedir.

The server will run until a KeyboardInterrupt or other termination signal is sent, then the program will shut down the mysql server before exiting.

While the server is running, the user can connect to with with the xfel gui by providing the hostname the server is running on and appropiate credentials.

"""

phil_scope = parse(db_phil_str)

default_cnf = \
"""
[mysqld]
basedir={basedir}
datadir={basedir}{sep}data
socket={basedir}{sep}mysql.sock
port={port}
# Disabling symbolic-links is recommended to prevent assorted security risks
symbolic-links=0
max_connections=10000
default_authentication_plugin=mysql_native_password

[mysqld_safe]
log-error={basedir}{sep}mysqld.log
pid-file={basedir}{sep}mysqld.pid

[client]
protocol=tcp
"""

def run(args):
  user_phil = []
  if '--help' in args or '-h' in args:
    print(help_message)
    phil_scope.show()
    return

  for arg in args:
    try:
      user_phil.append(parse(arg))
    except Exception as e:
      raise Sorry("Unrecognized argument %s"%arg)
  params = phil_scope.fetch(sources=user_phil).extract()

  cnf_path = os.path.join(params.db.server.basedir, 'my.cnf')

  initialize = not os.path.exists(params.db.server.basedir)
  if initialize:
    assert params.db.user is not None and len(params.db.user) > 0 and \
           params.db.name is not None and len(params.db.name) > 0
    import getpass
    if params.db.server.root_password:
            rootw = params.db.server.root_password
    else:
      print("Initializing")
      print("You must specify a root password")
      rootpw1 = getpass.getpass()
      print("Re-enter password")
      rootpw2 = getpass.getpass()
      if rootpw1 != rootpw2:
        raise Sorry("Passwords don't match")
      rootpw = rootpw1

    print("Initializing database")
    os.makedirs(params.db.server.basedir)
    with open(cnf_path, 'w') as f:
      f.write(default_cnf.format(basedir=params.db.server.basedir, sep=os.path.sep, port=params.db.port))

    assert easy_run.call("mysqld --defaults-file=%s --initialize-insecure"%(cnf_path)) == 0

  elif params.db.server.prompt_for_root_password:
    if params.db.server.root_password:
      rootpw3 = params.db.server.root_password
    else:
      import getpass
      print("please enter root password to raise the connection")
      rootpw3 = getpass.getpass()

  print("Starting server")
  assert os.path.exists(cnf_path)
  server_process = easy_run.subprocess.Popen(["mysqld", "--defaults-file=%s"%(cnf_path)])

  print("Sleeping a few seconds to let server start up...")
  time.sleep(5) # let server start up

  params.db.host = '127.0.0.1'
  if initialize:
    new_user = params.db.user
    new_password = params.db.password
    new_db = params.db.name
    params.db.user = 'root'
    params.db.password = ''
    params.db.name = ''
    print("Changing password")
    app = db_application(params)
    rootpw = params.db.server.root_password
    app.execute_query("ALTER USER 'root'@'localhost' IDENTIFIED BY '%s'"%(rootpw))
    params.db.password = rootpw
    print("Creating empty database %s"%new_db)
    app.execute_query("CREATE DATABASE %s"%new_db)
    print("Creating new user %s"%new_user)
    app.execute_query("CREATE USER '%s'@'%%' IDENTIFIED BY '%s'"%(new_user, new_password))
    print("Setting permissions")
    app.execute_query("GRANT ALL PRIVILEGES ON %s . * TO '%s'@'%%'"%(new_db, new_user))
    app.execute_query("FLUSH PRIVILEGES")
    app.execute_query("UPDATE mysql.user SET Super_Priv='Y' WHERE user='%s' AND host='%%'"%new_user)
    app.execute_query("FLUSH PRIVILEGES")
    print("Initialized")
  else:
    print("Instantiating db query execution driver")
    app = db_application(params)

  if params.db.server.prompt_for_root_password:
    params.db.user = 'root'
    params.db.password = rootpw3

  print("Raising max connections")
  app.execute_query("SET GLOBAL max_connections=50000")

  try:
    while True:
      if server_process.poll() is not None:
        print("Server exited")
        return
      time.sleep(1)
  except KeyboardInterrupt:
    print("Shutting down")
  except Exception as e:
    print("Unhandled exception, shutting down")
    print(str(e))

  server_process.terminate()


if __name__ == '__main__':
  print(sys.argv)
  run(sys.argv[1:])



 *******************************************************************************


 *******************************************************************************
xfel/ui/command_line/xfel_gui_launch.py
from __future__ import absolute_import, division, print_function
# LIBTBX_SET_DISPATCHER_NAME cctbx.xfel
# LIBTBX_PRE_DISPATCHER_INCLUDE_SH export PHENIX_GUI_ENVIRONMENT=1
# LIBTBX_PRE_DISPATCHER_INCLUDE_SH export BOOST_ADAPTBX_FPE_DEFAULT=1

'''
Author      : Lyubimov, A.Y.
Created     : 06/02/2016
Last Changed: 06/02/2016
Description : XFEL UI startup module.
'''

import wx, sys
import matplotlib as mp
mp.use('PS')


from xfel.ui.components.xfel_gui_init import MainWindow
from xfel.ui.components.xfel_gui_dialogs import SettingsDialog
from xfel.ui import load_cached_settings, save_cached_settings

class MainApp(wx.App):
  ''' App for the main GUI window  '''

  def OnInit(self):
    params = load_cached_settings()
    self.frame = MainWindow(None, -1, title='CCTBX.XFEL', params=params)

    # select primary display and center on that
    self.frame.SetSize((800, -1))
    minx, miny = self.frame.GetEffectiveMinSize()
    dispx, dispy =  wx.GetDisplaySize()
    self.frame.SetMinSize((min(minx, dispx), min(miny, dispy)))
    self.frame.Center()

    # Start with login dialog before opening main window
    self.login = SettingsDialog(self.frame, params=params)
    self.login.SetTitle('CCTBX.XFEL Login')
    self.login.Center()
    if (self.login.ShowModal() == wx.ID_OK):
      save_cached_settings(params)
      if self.frame.connect_to_db(drop_tables=self.login.drop_tables):
        self.exp_tag = '| {}'.format(self.login.db_cred.ctr.GetValue())
        self.exp = '| {}'.format(self.login.experiment.ctr.GetValue())
        self.frame.SetTitle('CCTBX.XFEL {} {}'.format(self.exp, self.exp_tag))
        self.frame.Show(True)
        self.SetTopWindow(self.frame)
        self.frame.onTabChange(None)
        #self.frame.start_run_sentinel()
        #self.frame.start_job_monitor()
        #self.frame.start_prg_sentinel()
        self.frame.run_window.show_hide_tabs()
        return True
      else:
        return False
    else:
      return False

def run(args):
  import libtbx
  libtbx.mpi_import_guard.disable_mpi = True

  if '-h' in args or '--help' in args or '-c' in args:
    from xfel.ui import master_phil_str
    from libtbx.phil import parse
    print("""
Runs the cctbx.xfel GUI. For more information see:
http://cci.lbl.gov/publications/download/CCN_2019_p22_Brewster.pdf

Configuration options:

""")
    parse(master_phil_str, process_includes = True).show(attributes_level=2)
    return
  app = MainApp(0)
  app.MainLoop()

if __name__ == '__main__':
  run(sys.argv[1:])


 *******************************************************************************


 *******************************************************************************
xfel/ui/components/__init__.py


 *******************************************************************************


 *******************************************************************************
xfel/ui/components/ebeam_plotter.py
from __future__ import division

import dxtbx
from xfel.cxi.cspad_ana import cspad_tbx
from matplotlib import pyplot as plt
import numpy as np
from simtbx.nanoBragg.utils import ENERGY_CONV

def compare_ebeams_with_fees(locfiles, runs=None, plot=True, use_figure=None, max_events=None):
  if plot:
    fig = use_figure or plt.figure()
    ax = fig.subplots()

  ebeam_eV_offsets = []
  ebeam_wav_offsets = []

  for i in range(len(locfiles)):
    if locfiles[i] is None:
      if plot:
        ax.plot([],[], label='No data for run {runs[i]}')
      continue

    img = dxtbx.load(locfiles[i])
    n_img = img.get_num_images()
    if max_events is not None:
      n_img = min(n_img, max_events)

    ebeams_eV = []
    ebeams_wav = []
    fee_coms_eV = []
    fee_coms_wav = []

    for j in range(n_img):
      if not img.get_spectrum(j):
        continue # no FEE
      ewav = cspad_tbx.evt_wavelength(img._get_event(j))
      if not ewav:
        continue # no ebeam
      fee_coms_wav.append(fwav:=img.get_beam(j).get_wavelength())
      fee_coms_eV.append(feV:=ENERGY_CONV/fwav)
      ebeams_wav.append(ewav)
      ebeams_eV.append(eeV:=ENERGY_CONV/ewav)
      print(f'{i}: {int(feV)} eV FEE / {int(eeV)} eV Ebeam')

    if len(ebeams_eV) == 0:
      print("No events found with both FEE and eBeam")
      return None, None
    fee_coms_eV = np.array(fee_coms_eV)
    ebeam_eV = np.array(ebeams_eV)
    fee_coms_wav = np.array(fee_coms_wav)
    ebeams_wav = np.array(ebeams_wav)

    diffs_eV = fee_coms_eV - ebeam_eV
    ebeam_eV_offsets.append(np.median(diffs_eV))
    diffs_wav = fee_coms_wav - ebeams_wav
    ebeam_wav_offsets.append(np.median(diffs_wav))

    median_fee_eV = np.median(fee_coms_eV)
    median_ebeam_eV = np.median(ebeam_eV)

    if plot:
      ax.hist(ebeams_eV, alpha=0.5, bins=40, label=f'run {runs[i]} ebeams ({round(median_ebeam_eV)} eV)')
      ax.hist(fee_coms_eV, alpha=0.5, bins=40, label=f'run {runs[i]} FEE COMs ({round(median_fee_eV)} eV)')

  if plot:
    ax.legend()
    ax.set_xlabel('Energy (eV)')
    ax.set_ylabel('Counts')
    ax.set_title('Ebeam vs Calibrated FEE')
    if not use_figure:
      plt.show()

  return (sum(ebeam_eV_offsets)/len(ebeam_eV_offsets),
          sum(ebeam_wav_offsets)/len(ebeam_wav_offsets))



 *******************************************************************************


 *******************************************************************************
xfel/ui/components/run_stats_plotter.py
from __future__ import absolute_import, division, print_function
from six.moves import range

from dials.array_family import flex
from matplotlib import pyplot as plt
from matplotlib.ticker import FuncFormatter
from xfel.ui.components.timeit import duration
import time, math
from six.moves import map

# get_hitrate_stats takes a tuple (run, trial, rungroup, d_min)
# and returns a tuple of flex arrays as follows:
# time (s) -- flex.double, timestamp of the shot,
# ratio -- flex.double, ratio of intensities at two angles in the radial average
# n_strong -- flex.int, number of strong spots identified by hitfinder,
# I_sig_I_low -- flex.double, the average I/sig(I) in the low res bin of each shot, if it indexed
# I_sig_I_high -- flex.double, the average I/sig(I) in the high res bin of each shot, if it indexed

def get_should_have_indexed_timestamps(timestamps,
                                       n_strong,
                                       isigi_low,
                                       n_strong_cutoff,
                                       indexed=False):
  if indexed:
    should_have_indexed_sel = (isigi_low > 0) & (n_strong >= n_strong_cutoff)
  else:
    should_have_indexed_sel = (isigi_low == 0) & (n_strong >= n_strong_cutoff) # isigi = 0 if not indexed
  should_have_indexed = timestamps.select(should_have_indexed_sel)
  return should_have_indexed

def get_multirun_should_have_indexed_timestamps(stats_by_run,
                                                run_numbers,
                                                d_min,
                                                n_strong_cutoff=16,
                                                indexed=False):
  timestamps = []
  for idx in range(len(stats_by_run)):
    r = stats_by_run[idx]
    if len(r[0]) > 0:
      timestamps.append(
        get_should_have_indexed_timestamps(r[0], r[3], r[4], n_strong_cutoff, indexed=indexed))
    else:
      timestamps.append(flex.double())
  return (run_numbers, timestamps)

def get_string_from_timestamp(ts, long_form=False):
  import time
  time_seconds = int(math.floor(ts))
  time_milliseconds = int(round((ts - time_seconds)*1000))
  time_obj = time.gmtime(time_seconds)
  if long_form:
    string = "%04d-%02d-%02dT%02d:%02dZ%02d.%03d" % (
      time_obj.tm_year,
      time_obj.tm_mon,
      time_obj.tm_mday,
      time_obj.tm_hour,
      time_obj.tm_min,
      time_obj.tm_sec,
      time_milliseconds)
  else:
    string = "%04d%02d%02d%02d%02d%02d%03d" % (
      time_obj.tm_year,
      time_obj.tm_mon,
      time_obj.tm_mday,
      time_obj.tm_hour,
      time_obj.tm_min,
      time_obj.tm_sec,
      time_milliseconds)
  return string

def get_strings_from_timestamps(timestamps, long_form=False):
  import os
  get_strings = lambda ts: get_string_from_timestamp(ts, long_form=long_form)
  names = [get_strings(ts) for ts in  timestamps]
  return names

def get_paths_from_timestamps(timestamps,
                              prepend="",
                              tag="idx",
                              ext="cbf",
                              long_form=False):
  import os
  def convert(s):
    timestamp_string = get_string_from_timestamp(s, long_form=long_form)
    name = "%s-%s.%s" % (
      tag,
      timestamp_string,
      ext)
    return name
  names = map(convert, timestamps)
  paths = [os.path.join(prepend, name) for name in names]
  return paths

def get_run_stats(timestamps,
                   two_theta_low,
                   two_theta_high,
                   n_strong,
                   resolutions,
                   n_lattices,
                   wavelengths,
                   tuple_of_timestamp_boundaries,
                   lengths,
                   run_numbers,
                   n_multiples=2,
                   ratio_cutoff=1,
                   n_strong_cutoff=16,
                   i_sigi_cutoff=1,
                   d_min=2,
                   ):
  print("")
  print("%d shots" % len(timestamps))
  print("%d first lattices" % (n_lattices >= 1).count(True))
  print("%d multiple lattices" % (n_lattices >= 2).count(True))
  print("%d total lattices" % (flex.sum(n_lattices)))
  iterator = range(len(resolutions))
  # hit rate of drops (observe solvent) or crystals (observe strong spots)
  # since -1 is used as a flag for "did not store this value", and we want a quotient,
  # set the numerator value to 0 whenever either the numerator or denominator is -1
  invalid = (two_theta_low <= 0) or (two_theta_high < 0) # <= to prevent /0
  numerator = two_theta_high.set_selected(invalid, 0)
  denominator = two_theta_low.set_selected(two_theta_low == 0, 1) # prevent /0
  drop_ratios = numerator/denominator
  drop_hits = drop_ratios >= ratio_cutoff
  xtal_hits = n_strong >= n_strong_cutoff
  half_idx_rate_window = min(50, max(int(len(timestamps)//20), 1))
  half_hq_rate_window = 500
  indexed_sel = n_lattices > 0
  hq_sel = (resolutions > 0) & (resolutions <= d_min)
  # indexing and droplet hit rate in a sliding window
  idx_rate = flex.double()
  multiples_rate = flex.double()
  hq_rate = flex.double()
  drop_hit_rate = flex.double()
  for i in iterator:
    idx_min = max(0, i - half_idx_rate_window)
    idx_max = min(i + half_idx_rate_window, len(resolutions))
    n_lattices_local = n_lattices[idx_min:idx_max]
    shots_this_span = len(n_lattices_local)
    first_lattices_local = n_lattices_local >= 1
    idx_local_rate = first_lattices_local.count(True)/shots_this_span
    idx_rate.append(idx_local_rate)
    multiples_sel = n_lattices_local >= n_multiples
    multiples_local_rate = multiples_sel.count(True)/shots_this_span
    multiples_rate.append(multiples_local_rate)
    drop_sel = drop_hits[idx_min:idx_max]
    drop_local_rate = drop_sel.count(True)/shots_this_span
    drop_hit_rate.append(drop_local_rate)
    # different sliding window for "high quality" xtals
    hq_min = max(0, i - half_hq_rate_window)
    hq_max = min(i + half_hq_rate_window, len(resolutions))
    n_lattices_local_hq = n_lattices[hq_min:hq_max]
    first_lattices_local_hq = n_lattices_local_hq >= 1
    hq_high_sel = hq_sel[hq_min:hq_max].select(first_lattices_local_hq)
    n_first_lattices_local_hq = first_lattices_local_hq.count(True)
    if n_first_lattices_local_hq > 0:
      hq_rate.append(hq_high_sel.count(True)/n_first_lattices_local_hq)
    else:
      hq_rate.append(0)
  return (timestamps,
          drop_ratios,
          drop_hits,
          drop_hit_rate,
          n_strong,
          xtal_hits,
          idx_rate,
          multiples_rate,
          hq_rate,
          indexed_sel,
          hq_sel,
          resolutions,
          half_idx_rate_window*2,
          wavelengths,
          lengths,
          tuple_of_timestamp_boundaries,
          run_numbers)

def plot_run_stats(stats,
                   d_min,
                   n_multiples=2,
                   run_tags=[],
                   run_statuses=[],
                   minimalist=False,
                   interactive=True,
                   xsize=30,
                   ysize=10,
                   high_vis=False,
                   title=None,
                   ext='cbf',
                   figure=None,
                   ):
  t1 = time.time()
  if figure:
    f = figure
  else:
    f = plt.figure()
  plot_ratio = max(min(xsize, ysize)/2.5, 3)
  if high_vis:
    spot_ratio = plot_ratio*4
    text_ratio = plot_ratio*4.5
  else:
    spot_ratio = plot_ratio*2
    text_ratio = plot_ratio*3
  t, drop_ratios, drop_hits, drop_hit_rate, n_strong, xtal_hits, \
  idx_rate, multiples_rate, hq_rate, indexed_sel, hq_sel, resolutions, \
  window, wavelengths, lengths, boundaries, run_numbers = stats
  if len(t) == 0:
    return None
  n_runs = len(boundaries)//2
  if len(run_tags) != n_runs:
    run_tags = [[] for i in range(n_runs)]
  if len(run_statuses) != n_runs:
    run_statuses = [None for i in range(n_runs)]
  if minimalist:
    print("Minimalist mode activated.")
    ax1, ax2, ax3 = f.subplots(3, sharex=True, sharey=False)
    axset = (ax1, ax2, ax3)
  else:
    ax1, ax2, ax3, ax4 = f.subplots(4, sharex=True, sharey=False)
    axset = (ax1, ax2, ax3, ax4)
  for a in axset:
    a.tick_params(axis='x', which='both', bottom='off', top='off')
  ax1.scatter(t.select(~indexed_sel), n_strong.select(~indexed_sel), edgecolors="none", color ='#d9d9d9', s=spot_ratio)
  ax1.scatter(t.select(indexed_sel), n_strong.select(indexed_sel), edgecolors="none", color='blue', s=spot_ratio)
  ax1.set_ylim(ymin=0)
  ax1.axis('tight')
  ax1.set_ylabel("strong spots\nblue: idx\ngray: did not idx", fontsize=text_ratio)
  ax1.set_ylim(0, min(flex.max(n_strong), 5000))
  ax2.plot(t, idx_rate*100)
  ax2.plot(t, multiples_rate*100, color='magenta')
  ax2_twin = ax2.twinx()
  ax2_twin.plot(t, drop_hit_rate*100, color='green')
  ax2_twin.set_ylim(ymin=0)
  ax2.axis('tight')
  ax2.set_ylabel("blue:%% idx\npink:%% %d lattices" % n_multiples, fontsize=text_ratio)
  ax2_twin.set_ylabel("green:\n% solvent", fontsize=text_ratio)
  gtz = resolutions > 0 # no indexing solution stored as resolution of 0
  ax3.scatter(t.select(gtz), 1/(resolutions.select(gtz)**2), edgecolors="none", color='orange', s=spot_ratio)
  def resolution(x,pos):
    if x <= 0:
      return '-'
    return "%.1f"%(1/math.sqrt(x))
  formatter = FuncFormatter(resolution)
  ax3.yaxis.set_major_formatter(formatter)
  ax3_twin = ax3.twinx()
  ax3.set_zorder(0.1)
  ax3_twin.plot(t, hq_rate*100, color='orange')
  ax3_twin.set_ylim(ymin=0)
  ax3.axis('tight')
  ax3.set_ylabel("high res\nbin (Ang)", fontsize=text_ratio)
  ax3_twin.set_ylabel("line:%% <=\n%.2f Ang" % d_min, fontsize=text_ratio)
  axset_with_twins = list(axset) + [ax2_twin, ax3_twin]
  for a in axset_with_twins:
    xlab = a.get_xticklabels()
    ylab = a.get_yticklabels()
    for l in xlab + ylab:
      l.set_fontsize(text_ratio)
  f.subplots_adjust(hspace=0)
  # add lines and text summaries at the timestamp boundaries
  if not minimalist:
    for boundary in boundaries:
      if boundary is not None:
        for a in (ax1, ax2, ax3):
          a.axvline(x=boundary, ymin=0, ymax=3, linewidth=1, color='k')
  run_starts = boundaries[0::2]
  run_ends = boundaries[1::2]
  start = 0
  end = -1
  for idx in range(len(run_numbers)):
    start_t = run_starts[idx]
    end_t = run_ends[idx]
    if start_t is None or end_t is None: continue
    end += lengths[idx]
    slice_t = t[start:end+1]
    slice_hits = xtal_hits[start:end+1]
    n_hits = slice_hits.count(True)
    slice_drops = drop_hits[start:end+1]
    n_drops = slice_drops.count(True)
    slice_indexed_sel = indexed_sel[start:end+1]
    slice_hq_sel = hq_sel[start:end+1]
    n_idx_low = slice_indexed_sel.count(True)
    n_idx_high = slice_hq_sel.count(True)
    tags = run_tags[idx]
    status = run_statuses[idx]
    if status == "DONE":
      status_color = 'blue'
    elif status in ["RUN", "PEND", "SUBMITTED"]:
      status_color = 'green'
    elif status is None:
      status_color = 'black'
    else:
      status_color = 'red'
    if minimalist:
      ax3.set_xlabel("timestamp (s)\n# images shown as all (%3.1f Angstroms)" % d_min, fontsize=text_ratio)
      ax3.set_yticks([])
    else:
      sel = wavelengths > 0
      energies = 12398.4/wavelengths.select(sel)
      ax4.scatter(t.select(sel), energies, c='lightgray', s=spot_ratio, alpha=0.5)
      min_energy = flex.min(energies); max_energy = flex.max(energies); energy_range = max_energy-min_energy
      def normit(v):
        return min_energy + (v * energy_range)
      ax4.text(start_t, normit(4.05), " " + ", ".join(tags) + " [%s]" % status, fontsize=text_ratio, color=status_color, rotation=10)
      ax4.text(start_t, normit(.85), "run %s" % str(run_numbers[idx]), fontsize=text_ratio)
      ax4.text(start_t, normit(.65), "%d img/%d hit" % (lengths[idx], n_hits), fontsize=text_ratio)
      ax4.text(start_t, normit(.45), "%d (%d) idx" % (n_idx_low, n_idx_high), fontsize=text_ratio)
      ax4.text(start_t, normit(.25), "%-3.1f%% solv/%-3.1f%% xtal" % ((100*n_drops/lengths[idx]),(100*n_hits/lengths[idx])), fontsize=text_ratio)
      ax4.text(start_t, normit(.05), "%-3.1f (%-3.1f)%% idx" % \
        (100*n_idx_low/lengths[idx], 100*n_idx_high/lengths[idx]), fontsize=text_ratio)
      ax4.set_xlabel("timestamp (s)\n# images shown as all (%3.1f Angstroms)" % d_min, fontsize=text_ratio)
      ax4.set_ylabel("energy (eV)", fontsize=text_ratio)
    for item in axset:
      item.tick_params(labelsize=text_ratio)
    start += lengths[idx]
  if title is not None:
    plt.title(title)
  if interactive:
    if not figure:
      plt.show()
  else:
    f.set_size_inches(xsize, ysize)
    f.savefig("runstats_tmp.png", bbox_inches='tight', dpi=100)
    plt.close(f)
    t2 = time.time()
    # print "plot_run_stats took %s" % duration(t1, t2)
    return "runstats_tmp.png"

def plot_multirun_stats(runs,
                        run_numbers,
                        d_min,
                        n_multiples=2,
                        ratio_cutoff=1,
                        n_strong_cutoff=40,
                        i_sigi_cutoff=1,
                        run_tags=[],
                        run_statuses=[],
                        minimalist=False,
                        interactive=False,
                        easy_run=False,
                        compress_runs=True,
                        xsize=30,
                        ysize=10,
                        high_vis=False,
                        title=None,
                        figure=None):
  tset = flex.double()
  two_theta_low_set = flex.double()
  two_theta_high_set = flex.double()
  nset = flex.int()
  resolutions_set = flex.double()
  n_lattices = flex.int()
  wavelengths = flex.double()
  boundaries = []
  lengths = []
  runs_with_data = []
  run_tags_with_data = []
  run_statuses_with_data =[]
  offset = 0
  for idx in range(len(runs)):
    r = runs[idx]
    if len(r[0]) > 0:
      if compress_runs:
        tslice = r[0] - r[0][0] + offset
        offset += (r[0][-1] - r[0][0] + 1)
      else:
        tslice = r[0]
      last_end = r[0][-1]
      tset.extend(tslice)
      two_theta_low_set.extend(r[1])
      two_theta_high_set.extend(r[2])
      nset.extend(r[3])
      resolutions_set.extend(r[4])
      n_lattices.extend(r[5])
      wavelengths.extend(r[6])
      boundaries.append(tslice[0])
      boundaries.append(tslice[-1])
      lengths.append(len(tslice))
      runs_with_data.append(run_numbers[idx])
      if run_tags:
        run_tags_with_data.append(run_tags[idx])
      if run_statuses:
        run_statuses_with_data.append(run_statuses[idx])
  stats_tuple = get_run_stats(tset,
                              two_theta_low_set,
                              two_theta_high_set,
                              nset,
                              resolutions_set,
                              n_lattices,
                              wavelengths,
                              tuple(boundaries),
                              tuple(lengths),
                              runs_with_data,
                              n_multiples=n_multiples,
                              ratio_cutoff=ratio_cutoff,
                              n_strong_cutoff=n_strong_cutoff,
                              i_sigi_cutoff=i_sigi_cutoff,
                              d_min=d_min)
  if easy_run:
    from libtbx import easy_run, easy_pickle
    easy_pickle.dump("plot_run_stats_tmp.pickle", (stats_tuple, d_min, n_multiples, run_tags_with_data, run_statuses_with_data, minimalist, interactive, xsize, ysize, high_vis, title))
    result = easy_run.fully_buffered(command="cctbx.xfel.plot_run_stats_from_stats_pickle plot_run_stats_tmp.pickle")
    try:
      png = result.stdout_lines[-1]
      if png == "None":
        return None
    except Exception:
      return None
  else:
    png = plot_run_stats(stats_tuple, d_min, n_multiples=n_multiples, run_tags=run_tags_with_data, run_statuses=run_statuses_with_data, minimalist=minimalist,
      interactive=interactive, xsize=xsize, ysize=ysize, high_vis=high_vis, title=title, figure=figure)
  return png


 *******************************************************************************


 *******************************************************************************
xfel/ui/components/spotfinder_plotter.py
from __future__ import absolute_import, division, print_function
from six.moves import range

from dials.array_family import flex
from matplotlib import pyplot as plt

def get_spotfinder_stats(timestamps, n_strong, n_min,
  tuple_of_timestamp_boundaries, lengths, run_numbers):
  # n_strong is a flex.double and n_min is an integer
  iterator = range(len(timestamps))
  half_window = min(50, max(int(len(timestamps)//20), 1))
  # spotfinding more than n_min spots rate in a sliding window
  enough_spots = n_strong >= n_min
  enough_rate = flex.double()
  for i in iterator:
    window_min = max(0, i - half_window)
    window_max = min(i + half_window, len(timestamps))
    enough_local = enough_spots[window_min:window_max]
    enough_rate_local = enough_local.count(True)/len(enough_local)
    enough_rate.append(enough_rate_local)
  return (timestamps,
          n_strong,
          enough_rate,
          n_min,
          half_window*2,
          lengths,
          tuple_of_timestamp_boundaries,
          run_numbers)

def plot_spotfinder_stats(stats,
                          spot_length_stats,
                          run_tags=[],
                          run_statuses=[],
                          minimalist=False,
                          interactive=True,
                          xsize=30,
                          ysize=10,
                          high_vis=False,
                          title=None,
                          ext='cbf',
                          ):
  plot_ratio = max(min(xsize, ysize)/2.5, 3)
  if high_vis:
    spot_ratio = plot_ratio*4
    text_ratio = plot_ratio*4.5
  else:
    spot_ratio = plot_ratio*2
    text_ratio = plot_ratio*3
  t, n_strong, enough_rate, n_min, window, lengths, boundaries, run_numbers = stats
  t_lengths, spot_lengths, spot_intensities = spot_length_stats
  # set up coloring of spot lengths by intensities
  from matplotlib.cm import ScalarMappable
  mappable = ScalarMappable(cmap="plasma")
  cmap = mappable.to_rgba(-flex.log(spot_intensities))
  if len(t) == 0:
    return None
  n_runs = len(boundaries)//2
  if len(run_tags) != n_runs:
    run_tags = [[] for i in range(n_runs)]
  if len(run_statuses) != n_runs:
    run_statuses = [None for i in range(n_runs)]
  if minimalist:
    print("Minimalist mode activated.")
    f, (ax1, ax2) = plt.subplots(2, sharex=True, sharey=False)
    axset = (ax1, ax2)
  else:
    f, (ax1, ax2, ax3) = plt.subplots(3, sharex=True, sharey=False)
    axset = (ax1, ax2, ax3)
  for a in axset:
    a.tick_params(axis='x', which='both', bottom='off', top='off')
  ax1.scatter(t, n_strong, edgecolors="none", color='deeppink', s=spot_ratio)
  ax1.set_ylim(ymin=0)
  ax1.axis('tight')
  ax1.set_ylabel("# strong spots", fontsize=text_ratio)
  ax1_twin = ax1.twinx()
  ax1_twin.plot(t, enough_rate*100, color='orange')
  ax1_twin.set_ylim(ymin=0)
  ax1_twin.set_ylabel("%% images with\n>=%d spots" % n_min, fontsize=text_ratio)
  if spot_length_stats:
    ax2.scatter(t_lengths, spot_lengths, edgecolors="none", color=cmap, s=spot_ratio)
  ax2.set_ylim(ymin=0)
  ax2.axis('tight')
  ax2.set_ylabel("spot lengths\n(pixels)", fontsize=text_ratio)
  f.subplots_adjust(hspace=0)
  # add lines and text summaries at the timestamp boundaries
  if not minimalist:
    for boundary in boundaries:
      if boundary is not None:
        for a in (ax1, ax2):
          a.axvline(x=boundary, ymin=0, ymax=2, linewidth=1, color='k')
  run_starts = boundaries[0::2]
  run_ends = boundaries[1::2]
  start = 0
  end = -1
  for idx in range(len(run_numbers)):
    start_t = run_starts[idx]
    end_t = run_ends[idx]
    if start_t is None or end_t is None: continue
    end += lengths[idx]
    slice_t = t[start:end+1]
    slice_enough = n_strong[start:end+1] > n_min
    tags = run_tags[idx]
    status = run_statuses[idx]
    if status == "DONE":
      status_color = 'blue'
    elif status in ["RUN", "PEND", "SUBMITTED"]:
      status_color = 'green'
    elif status is None:
      status_color = 'black'
    else:
      status_color = 'red'
    if minimalist:
      ax2.set_xlabel("timestamp (s)\n# images shown as all (%3.1f Angstroms)" % d_min, fontsize=text_ratio)
      ax2.set_yticks([])
    else:
      ax3.text(start_t, 2.85, " " + ", ".join(tags) + " [%s]" % status, fontsize=text_ratio, color=status_color)
      ax3.text(start_t, .85, "run %d" % run_numbers[idx], fontsize=text_ratio)
      ax3.text(start_t, .65, "%d images" % lengths[idx], fontsize=text_ratio)
      ax3.text(start_t, .45, "%d n>=%d" % (slice_enough.count(True), n_min), fontsize=text_ratio)
      if spot_length_stats and len(spot_lengths) > 0:
        ax3.text(start_t, .25, "avg %d px" % int(flex.sum(spot_lengths)/len(spot_lengths)), fontsize=text_ratio)
      ax3.set_xlabel("timestamp (s)", fontsize=text_ratio)
      ax3.set_yticks([])
    for item in axset:
      item.tick_params(labelsize=text_ratio)
    start += lengths[idx]
  if title is not None:
    plt.title(title)
  f.set_size_inches(xsize, ysize)
  f.savefig("spotfinder_tmp.png", bbox_inches='tight', dpi=100)
  plt.close(f)
  return "spotfinder_tmp.png"

def plot_multirun_spotfinder_stats(runs,
                                   run_numbers,
                                   spot_length_stats=[],
                                   run_tags=[],
                                   run_statuses=[],
                                   n_min=4,
                                   minimalist=False,
                                   interactive=False,
                                   spotfinder_only=False,
                                   easy_run=False,
                                   compress_runs=True,
                                   xsize=30,
                                   ysize=10,
                                   high_vis=False,
                                   title=None):
  tset = flex.double()
  nset = flex.int()
  l_tset = flex.double() # lengths timestamp
  lset = flex.double() # lengths
  iset = flex.double() # intensities
  boundaries = []
  lengths = []
  runs_with_data = []
  offset = 0
  for idx in range(len(runs)):
    r = runs[idx]
    if len(r[0]) > 0:
      if compress_runs:
        tslice = r[0] - r[0][0] + offset
        l_tset.extend(spot_length_stats[idx][0] - r[0][0] + offset)
        offset += (r[0][-1] - r[0][0] + 1/120.)
      else:
        tslice = r[0]
        l_tset.extend(spot_length_stats[idx][0])
      last_end = r[0][-1]
      tset.extend(tslice)
      nset.extend(r[1])
      boundaries.append(tslice[0])
      boundaries.append(tslice[-1])
      lengths.append(len(tslice))
      runs_with_data.append(run_numbers[idx])
      lset.extend(spot_length_stats[idx][1])
      iset.extend(spot_length_stats[idx][2])
    else:
      boundaries.extend([None]*2)
  stats_tuple = get_spotfinder_stats(tset,
                                     nset,
                                     n_min,
                                     tuple(boundaries),
                                     tuple(lengths),
                                     runs_with_data)
  spot_length_stats_tuple = (l_tset, lset, iset)
  if easy_run:
    from libtbx import easy_run, easy_pickle
    easy_pickle.dump("plot_spotfinder_stats_tmp.pickle", (stats_tuple, spot_length_stats_tuple, run_tags, run_statuses, minimalist, interactive, xsize, ysize, high_vis, title))
    result = easy_run.fully_buffered(command="cctbx.xfel.plot_spotfinder_stats_from_stats_pickle plot_spotfinder_stats_tmp.pickle")
    try:
      png = result.stdout_lines[-1]
      if png == "None":
        return None
    except Exception:
      return None
  else:
    png = plot_spotfinder_stats(stats_tuple, spot_length_stats_tuple, run_tags=run_tags, run_statuses=run_statuses, minimalist=minimalist,
      interactive=interactive, xsize=xsize, ysize=ysize, high_vis=high_vis, title=title)
  return png


 *******************************************************************************


 *******************************************************************************
xfel/ui/components/spotfinder_scraper.py
from __future__ import absolute_import, division, print_function
from six.moves import range

from xfel.util.reflection_length import ReflectionsRadialLengthsFromFiles
from dials.array_family import flex
import os
from six.moves import zip
from six.moves import map

def get_spot_length_stats(outdir, ref_stats=None):
  def join(filename):
    return os.path.join(outdir, str(filename))

  files = map(join, os.listdir(outdir))
  datablocks = sorted([f for f in files if 'datablock' in f])
  strong = sorted([f for f in files if 'strong' in f])
  strong_spot_timestamps = flex.double()
  strong_spot_lengths = flex.double()
  strong_spot_intensities = flex.double()

  def process_pair(refl, block, ts=None):
    measurer = ReflectionsRadialLengthsFromFiles([refl, block])
    lengths = measurer.get_spot_lengths_px()
    intensities = measurer.get_intensities()
    assert len(lengths) == len(intensities)
    for i, length in enumerate(lengths):
      strong_spot_lengths.append(length)
      strong_spot_intensities.append(intensities[i])
      if ts:
        strong_spot_timestamps.append(ts)

  if ref_stats:
    timestamps, n_strong = ref_stats
    # Can't use reference timestamps at all if there are fewer datablocks than timestamps.
    assert len(datablocks) == len(timestamps), \
      "Mismatch between n_strong: %d, n_timestamps: %d" % (len(strong), len(timestamps))
    # In case of unanticipated errors during spotfinding, strong.pickle may not be written.
    # Get a list strong of the same length as datablocks with placeholder None values.
    if len(strong) != len(datablocks):
      strong = [db.split("datablock.json")[0] + "strong.pickle"
        if db.split("datablock.json")[0] + "strong.pickle" in strong
        else None
        for db in datablocks]
    for i in range(len(timestamps)):
      ts, s, db = timestamps[i], strong[i], datablocks[i]
      if s is not None:
        process_pair(s, db, ts=ts)
  else:
    if len(strong) != len(datablocks):
      for pickle in strong:
        matching_json = pickle.split("_strong.pickle")[0] + "_datablock.json"
        if matching_json in datablocks:
          process_pair(pickle, matching_json)
    else: # Looks redundant but doesn't depend on file naming conventions
      for s, db in zip(strong, datablocks):
        process_pair(s, db)
  return strong_spot_timestamps, strong_spot_lengths, strong_spot_intensities


 *******************************************************************************


 *******************************************************************************
xfel/ui/components/submission_tracker.py
from __future__ import absolute_import, division, print_function

from libtbx import easy_run

class JobStopper(object):
  def __init__(self, queueing_system):
    self.queueing_system = queueing_system
    if self.queueing_system in ["mpi", "lsf"]:
      self.command = "bkill %s"
    elif self.queueing_system in ["pbs", "sge"]:
      self.command = "qdel %s"
    elif self.queueing_system == 'local':
      pass
    elif self.queueing_system == 'slurm' or self.queueing_system == 'shifter':
      # The current implementation of the shifter mp method assumes that we're
      # running on NERSC's systems => jobs should be tracked using the _slurm_
      # submission tracker.
      self.command = "scancel %s"
    elif self.queueing_system == 'htcondor':
      self.command = "condor_rm %s"
    else:
      raise NotImplementedError("job stopper not implemented for %s queueing system" \
      % self.queueing_system)

  def stop_job(self, submission_id):
    if not submission_id: return
    for sid in submission_id.split(','):
      if self.queueing_system == 'local':
        import psutil
        try:
          process = psutil.Process(int(sid))
        except psutil.NoSuchProcess:
          return
        for child in process.children(recursive=True): child.kill()
        process.kill()
      else:
        result = easy_run.fully_buffered(command=self.command%sid)
        status = "\n".join(result.stdout_lines)
        error = "\n".join(result.stderr_lines)
        print(status)
        print(error)

class QueueInterrogator(object):
  """A queue monitor that returns the status of a given queued job, or ERR if the job cannot
  be found in the queue."""
  def __init__(self, queueing_system):
    self.queueing_system = queueing_system
    if self.queueing_system in ["mpi", "lsf"]:
      self.command = "bjobs %s | grep %s | awk '{ print $3 }'"
    elif self.queueing_system == 'pbs':
      self.command = "qstat -H %s | tail -n 1 | awk '{ print $10 }'"
    elif self.queueing_system == 'sge':
      self.command = "qstat |grep %s | awk '{print $5}'" # previous one "qstat -j %s | awk '/job_state/ {print $3}'"
    elif self.queueing_system == 'local':
      pass
    elif self.queueing_system == 'slurm' or  self.queueing_system == 'shifter':
      # The current implementation of the shifter mp method assumes that we're
      # running on NERSC's systems => jobs should be tracked using the _slurm_
      # submission tracker.
      self.command = "sacct --job %s --format state --noheader"
    elif self.queueing_system == 'htcondor':
      self.command1 = "condor_q %s -nobatch | grep -A 1 OWNER | tail -n 1"
      self.command2 = "condor_history %s | grep -A 1 OWNER | tail -n 1"
    else:
      raise NotImplementedError(
      "queue interrogator not implemented for %s queueing system"%self.queueing_system)

  def query(self, submission_id):
    if self.queueing_system in ["mpi", "lsf"]:
      result = easy_run.fully_buffered(command=self.command % \
        (submission_id, submission_id))
    elif self.queueing_system == 'pbs':
      result = easy_run.fully_buffered(command=self.command%submission_id)
    elif self.queueing_system == 'sge':
      result = easy_run.fully_buffered(command=self.command%submission_id)
    elif self.queueing_system == 'local':
      import psutil
      try:
        process = psutil.Process(int(submission_id))
      except psutil.NoSuchProcess:
        return "DONE"
      statuses = [p.status() for p in [process] + process.children(recursive=True)]
      if 'running' in statuses: return "RUN"
      if 'sleeping' in statuses: return "RUN"
      # zombie jobs can be left because the GUI process that forked them is still running
      if len(statuses) == 1 and statuses[0] == 'zombie': return "DONE"
      return ", ".join(statuses)
    elif self.queueing_system == 'slurm' or self.queueing_system == "shifter":
      # The current implementation of the shifter mp method assumes that we're
      # running on NERSC's systems => jobs should be tracked using the _slurm_
      # submission tracker.
      result = easy_run.fully_buffered(command=self.command%submission_id)
      if len(result.stdout_lines) == 0: return 'UNKWN'
      status = result.stdout_lines[0].strip().rstrip('+')
      statuses = {'COMPLETED': 'DONE',
                  'COMPLETING': 'RUN',
                  'FAILED': 'EXIT',
                  'PENDING': 'PEND',
                  'PREEMPTED': 'SUSP',
                  'RUNNING': 'RUN',
                  'SUSPENDED': 'SUSP',
                  'STOPPED': 'SUSP',
                  'CANCELLED': 'EXIT',
                  'TIMEOUT': 'TIMEOUT',
                 }
      return statuses[status] if status in statuses else 'UNKWN'
    elif self.queueing_system == 'htcondor':
      # (copied from the man page)
      # H = on hold, R = running, I = idle (waiting for a machine to execute on), C = completed,
      # X = removed, S = suspended (execution of a running job temporarily suspended on execute node),
      # < = transferring input (or queued to do so), and > = transferring output (or queued to do so).
      statuses = {'H': 'HOLD',
                  'R': 'RUN',
                  'I': 'PEND',
                  'C': 'DONE',
                  'X': 'DONE',
                  'S': 'SUSP',
                  '<': 'RUN',
                  '>': 'RUN'}
      for c in [self.command1, self.command2]:
        result = easy_run.fully_buffered(command=c%submission_id)
        if len(result.stdout_lines) != 1 or len(result.stdout_lines[0]) == 0: continue
        status = result.stdout_lines[0].split()[5]
        return statuses[status] if status in statuses else 'UNKWN'
      return 'ERR'
    status = "\n".join(result.stdout_lines)
    error = "\n".join(result.stderr_lines)
    if error != "" and not "Warning: job being submitted without an AFS token." in error:
      if "not found" in error:
        return "ERR"
      else:
        return error
    else:
      return status

  def get_mysql_server_hostname(self, submission_id):
    if self.queueing_system in ["mpi", "lsf"]:
      print("method to obtain hostname running MySQL server not implemented for ", self.queueing_system)
      pass
    elif self.queueing_system == 'pbs':
      print("method to obtain hostname running MySQL server not implemented for ", self.queueing_system)
      pass
    elif self.queueing_system == 'sge':
      print("method to obtain hostname running MySQL server not implemented for ", self.queueing_system)
      pass
    elif self.queueing_system == 'slurm' or self.queueing_system == "shifter":
      hostname_command = "sacct --job %s -o NODELIST --noheader | tail -n 1"
      result = easy_run.fully_buffered(command=hostname_command%submission_id).raise_if_errors()
      if result.stdout_lines:
        return result.stdout_lines[0].strip()
      else:
        return ""
    elif self.queueing_system == 'htcondor':
      print("method to obtain hostname running MySQL server not implemented for ", self.queueing_system)
      pass

class LogReader(object):
  """A log reader that distinguishes between expected results of successful and unsuccessful
  log file termination, and returns an error message if the log file cannot be found or read."""
  def __init__(self, queueing_system):
    self.queueing_system = queueing_system
    if self.queueing_system in ["mpi", "lsf", "pbs", "local", "sge"]:
      self.command = "tail -23 %s | head -1"
    elif self.queueing_system in ["slurm", "shifter", "htcondor"]:
      pass # no log reader used
    else:
      raise NotImplementedError(
      "queue interrogator not implemented for %s queueing system"%self.queueing_system)

  def read_result(self, log_path):
    result = easy_run.fully_buffered(command=self.command % log_path)
    status = "\n".join(result.stdout_lines)
    error = "\n".join(result.stderr_lines)
    if error != "" and not "Warning: job being submitted without an AFS token." in error:
      return "Error reading log file."
    else:
      return status

class SubmissionTracker(object):
  """An object that uses the QueueInterrogator and LogReader to query a queueing system and log
  file to determine the status of a queued job."""
  def __init__(self, params):
    self.queueing_system = params.mp.method
    self.interrogator = QueueInterrogator(self.queueing_system)
    self.reader = LogReader(self.queueing_system)
  def track(self, submission_id, log_path):
    if submission_id is None:
      return "UNKWN"
    all_statuses = [self._track(sid, log_path) for sid in submission_id.split(',')]
    if all_statuses and all([all_statuses[0] == s for s in all_statuses[1:]]):
      return all_statuses[0]
    else:
      return "UNKWN"

  def _track(self, submission_id, log_path):
    raise NotImplementedError("Override me!")

class LSFSubmissionTracker(SubmissionTracker):
  def _track(self, submission_id, log_path):
    from xfel.ui.db.job import known_job_statuses
    status = self.interrogator.query(submission_id)
    if status == "ERR":
      log_status = self.reader.read_result(log_path)
      if log_status == "Successfully completed.":
        return "DONE"
      elif "exit" in log_status.lower():
        return "EXIT"
      else:
        return "ERR" # error querying the queueing system
    elif status in known_job_statuses:
      return status
    else:
      print("Found an unknown status", status)

class PBSSubmissionTracker(SubmissionTracker):
  def _track(self, submission_id, log_path):
    status = self.interrogator.query(submission_id)
    if status == "F":
      return "DONE"
    elif status in ["Q", "H", "S"]:
      return "PEND"
    elif status in ["R", "T", "W", "E"]:
      return "RUN"
    else:
      print("Found an unknown status", status)

class SGESubmissionTracker(SubmissionTracker):
  def _track(self, submission_id, log_path):
    status = self.interrogator.query(submission_id)
    if status == "":
      return "DONE"
    elif status in ["s", "t", "S"]:
      return "PEND"
    elif status == "r":
      return "RUN"
    elif status == "qw":
      return "WAITING"
    else:
      print("Found an unknown status", status)

class SlurmSubmissionTracker(SubmissionTracker):
  def _track(self, submission_id, log_path):
    return self.interrogator.query(submission_id)

class HTCondorSubmissionTracker(SubmissionTracker):
  def _track(self, submission_id, log_path):
    return self.interrogator.query(submission_id)

class LocalSubmissionTracker(SubmissionTracker):
  def _track(self, submission_id, log_path):
    return self.interrogator.query(submission_id)

class TrackerFactory(object):
  @staticmethod
  def from_params(params):
    if params.mp.method in ['mpi', 'lsf']:
      return LSFSubmissionTracker(params)
    elif params.mp.method == 'pbs':
      return PBSSubmissionTracker(params)
    elif params.mp.method == 'sge' :
      return SGESubmissionTracker(params)
    elif params.mp.method == 'local':
      return LocalSubmissionTracker(params)
    elif params.mp.method == 'slurm':
      return SlurmSubmissionTracker(params)
    elif params.mp.method == 'shifter':
      # The current implementation of the shifter mp method assumes that we're
      # running on NERSC's systems => jobs should be tracked using the _slurm_
      # submission tracker.
      return SlurmSubmissionTracker(params)
    elif params.mp.method == 'htcondor':
      return HTCondorSubmissionTracker(params)


 *******************************************************************************


 *******************************************************************************
xfel/ui/components/timeit.py
from __future__ import absolute_import, division, print_function

import time, math

def now():
  return "%02d:%02d:%02d" % (time.localtime().tm_hour, time.localtime().tm_min, time.localtime().tm_sec)

def duration(t1, t2):
  diff = t2 - t1
  seconds = int(math.floor(diff))
  frac = diff - seconds
  hh = seconds // 3600
  mm = seconds // 60
  if hh > 0:
    mm = mm % 60
  ss = seconds % 60
  return "%02dh %02dm %fs" % (hh, mm, ss + frac)



 *******************************************************************************


 *******************************************************************************
xfel/ui/components/tooltips.py
from __future__ import absolute_import, division, print_function

from xfel.ui import master_phil_scope
try:
  from dxtbx.format.FormatXTC import locator_scope
except (ImportError, TypeError):
  locator_scope = None
from xfel.ui.command_line.plot_run_stats import phil_scope as rs_scope

def get_help(path, scope = master_phil_scope):
  return scope.get(path).objects[0].help

tooltips = {
  # Settings dialog
  'db_cred_ctr': get_help('experiment_tag'),
  'db_cred_btn_big': 'Set up database credentials the GUI will use to connect with',
  'facility_ctr': get_help('facility.name'),
  'btn_facility_options': 'Facility specific options',
  'experiment_ctr': get_help('facility.lcls.experiment'),
  'output_ctr': get_help('output_folder'),
  'advanced': 'Multiprocessing, queueing, and other options',
  # Advanced settings dialog
  'mp_option_ctr': get_help('mp.method'),
  'queue_ctr': get_help('mp.queue'),
  'nproc_ctr': get_help('mp.nproc'),
  'nnodes_ctr': get_help('mp.nnodes'),
  'nproc_per_node': get_help('mp.nproc_per_node'),
  'wall_time_ctr': get_help('mp.wall_time'),
  'mpi_command_ctr': get_help('mp.mpi_command'),
  'env_script_ctr': get_help('mp.env_script'),
  'phenix_script_ctr': get_help('mp.phenix_script'),
  'htcondor_executable_path_ctr': get_help('mp.htcondor.executable_path'),
  'htcondor_filesystemdomain_ctr': get_help('mp.htcondor.filesystemdomain'),
  'nnodes_index_ctr': get_help('mp.nnodes_index'),
  'nnodes_tder_ctr': get_help('mp.nnodes_tder'),
  'nnodes_scale_ctr': get_help('mp.nnodes_scale'),
  'nnodes_merge_ctr': get_help('mp.nnodes_merge'),
  'extra_options': get_help('mp.extra_options'),
  'shifter_image_ctr': get_help('mp.shifter.shifter_image'),
  'shifter_srun_template_ctr': get_help('mp.shifter.srun_script_template'),
  'shifter_sbatch_template_ctr': get_help('mp.shifter.sbatch_script_template'),
  'shifter_jobname_ctr': get_help('mp.shifter.jobname'),
  'shifter_project_ctr': get_help('mp.shifter.project'),
  'shifter_reservation_ctr': get_help('mp.shifter.reservation'),
  'shifter_constraint_ctr': get_help('mp.shifter.constraint'),
  'staging_ctr': get_help('mp.shifter.staging'),
  'back_end_ctr': get_help('dispatcher'),
  # DBCredentialsDialog
  'db_host_ctr': get_help('db.host'),
  'db_port_ctr': get_help('db.port'),
  'db_name_ctr': get_help('db.name'),
  'db_user_ctr': get_help('db.user'),
  'db_password_ctr': get_help('db.password'),
  'web_location_ctr': get_help('facility.lcls.web.location'),
  # StandaloneOptions
  'data_dir_ctr': get_help('facility.standalone.data_dir'),
  'monitor_for': get_help('facility.standalone.monitor_for'),
  'folders_options': get_help('facility.standalone.folders.method'),
  'n_files_needed_ctr': get_help('facility.standalone.folders.n_files_needed'),
  'last_modified_ctr': get_help('facility.standalone.files.last_modified'),
  'minimum_file_size_ctr': get_help('facility.standalone.files.minimum_file_size'),
  'template_ctr': get_help('facility.standalone.template'),
  # Main GUI
  'btn_persistent_tags': 'Auto-tag new runs as they arrive',
  'btn_manage_tags': 'Add/rename/delete tags',
  'btn_view_phil': 'View trial parameters',
  'rs_d_min': get_help('d_min', rs_scope),
  'rs_multiples': 'Number of multiple lattices before a hit is counted as a multiple hit',
  'rs_ratio': 'Ratio of 2θ high to 2θ low needed for an image to be a solvent hit',
  'rs_n_strong': get_help('n_strong_cutoff', rs_scope),
  'rs_isigi': get_help('i_sigi_cutoff', rs_scope),
  'rs_n_dump': 'Number of images to convert to cbf and then display',
  'uc_selection_type': 'Union: include runs matching any of these tags\n' + \
                       'Intersection: include runs matching all of these tags',
  # Trial dialog
  'trial_throttle_ctr': 'Percent of images (events) to process',
  'trial_num_bins_ctr': 'Used for logging only',
  'trial_d_min_ctr': 'Used for logging only', # XXX doesn't appear
  # Run group dialog
  'rg_end_type': 'Auto add runs: new data will be added to this block as it arrives\nSpecify end run: set the last run for this block explicitly.',
  'rg_address_ctr': 'Detector address in XTC stream (use detnames to list available detectors)',
  'rg_beam_xyz': 'Beam center in pixels, and detector distance in mm (overridden by the phil parameter input.reference_geometry)',
  'rg_bin_nrg_gain_binning': 'Rayonix binning (2, 3, 4, etc.)',
  'rg_bin_nrg_gain_energy': 'Energy override for all images (eV)',
  'rg_wavelength_offset': 'Offset applied to wavelength of each image (Å)',
  'rg_spectrum_calibration': get_help('spectrum_eV_per_pixel', locator_scope) if locator_scope else '',
  'rg_energy_ctr': 'Energy override for all images (eV)',
  'rg_two_thetas': 'Two 2θ values (deg). The ratio of high/low is used to check for presence of solvent on each image. ' + \
                   'Defaults are the water ring and a low resolution ring',
}

def setup_tooltip(obj):
  obj.SetToolTip(tooltips.get(obj.Name))



 *******************************************************************************


 *******************************************************************************
xfel/ui/components/xfel_gui_controls.py
from __future__ import absolute_import, division, print_function
import six

'''
Author      : Lyubimov, A.Y.
Created     : 06/03/2016
Last Changed: 06/03/2016
Description : XFEL UI Custom Widgets and Controls
'''

import os
import wx
import wx.lib.agw.floatspin as fs
import wx.richtext as rt
from wxtbx import metallicbutton as mb
from xfel.ui.components.tooltips import setup_tooltip

# Platform-specific stuff
# TODO: Will need to test this on Windows at some point
if wx.Platform == '__WXGTK__':
  norm_font_size = 10
  button_font_size = 12
  LABEL_SIZE = 14
  CAPTION_SIZE = 12
elif wx.Platform == '__WXMAC__':
  norm_font_size = 12
  button_font_size = 14
  LABEL_SIZE = 14
  CAPTION_SIZE = 12
elif (wx.Platform == '__WXMSW__'):
  norm_font_size = 9
  button_font_size = 11
  LABEL_SIZE = 11
  CAPTION_SIZE = 9

icons = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'icons/')

# --------------------------------- Tool tip overrides ----------------------- #

class TextCtrl(wx.TextCtrl):
  def __init__(self, *args, **kwargs):
    super(TextCtrl, self).__init__(*args, **kwargs)
    setup_tooltip(self)

class Button(wx.Button):
  def __init__(self, *args, **kwargs):
    super(Button, self).__init__(*args, **kwargs)
    setup_tooltip(self)

class BitmapButton(wx.BitmapButton):
  def __init__(self, *args, **kwargs):
    super(BitmapButton, self).__init__(*args, **kwargs)
    setup_tooltip(self)

class Choice(wx.Choice):
  def __init__(self, *args, **kwargs):
    super(Choice, self).__init__(*args, **kwargs)
    setup_tooltip(self)

class RichTextCtrl(rt.RichTextCtrl):
  def __init__(self, *args, **kwargs):
    super(RichTextCtrl, self).__init__(*args, **kwargs)
    setup_tooltip(self)

# --------------------------------- Buttons ---------------------------------- #

class GradButton(mb.MetallicButton):
  def __init__(self, parent, label='', bmp=None, size=wx.DefaultSize,
               style=mb.MB_STYLE_BOLD_LABEL, handler_function=None,
               user_data=None, start_color=(218, 218, 218),
               gradient_percent=0, highlight_color=(230, 230, 230),
               label_size=LABEL_SIZE, caption_size=CAPTION_SIZE,
               button_margin=4, disable_after_click=0) :
    if isinstance(bmp, str) :
      bmp = self.StandardBitmap(bmp)
      bmp_size = bmp.GetSize()
      if bmp_size > size[1]:
        size = (size[0], 1.5 * bmp_size[1])
    mb.MetallicButton.__init__(self,
                               parent=parent,
                               label=label,
                               bmp=bmp,
                               size=size,
                               style=style,
                               name=str(user_data),
                               start_color=start_color,
                               gradient_percent=gradient_percent,
                               highlight_color=highlight_color,
                               label_size=label_size,
                               caption_size=caption_size,
                               button_margin=button_margin,
                               disable_after_click=disable_after_click
                               )
    if handler_function is not None:
     self.bind_event(wx.EVT_BUTTON, handler_function)

  def StandardBitmap(img_name, size=None):
    img_path = img_name
    img = wx.Image(img_path, type=wx.BITMAP_TYPE_ANY, index=-1)
    if size is not None:
     (w, h) = size
     img.Rescale(w, h)
    bmp = img.ConvertToBitmap()
    return bmp

class RunBlockButton(GradButton):
  def __init__(self, parent, block, size=wx.DefaultSize):
    self.block = block
    db = block.app
    self.rnum = block.rungroup_id
    self.first_run, self.last_run = block.get_first_and_last_runs()
    self.use_ids = db.params.facility.name not in ['lcls']

    GradButton.__init__(self, parent=parent, label='',
                        size=size)
    self.update_label()

  def update_label(self):
    if self.first_run is None:
      first = ' ...'
    else:
      if self.use_ids:
        first = self.first_run.id
      else:
        first = self.first_run.run

    if self.last_run is None:
      last = ' ...'
    else:
      last = ' - {}'.format(self.last_run.id if self.use_ids else self.last_run.run)

    self.block_label = '[{}] runs {}{}'.format(self.rnum, first, last)
    self.SetLabel(self.block_label)
    self.Refresh()

class TaskButton(GradButton):
  def __init__(self, parent, task, size=wx.DefaultSize):
    self.task = task
    self.db = task.app

    GradButton.__init__(self, parent=parent, label='',
                        size=size)
    self.update_label()

  def update_label(self):
    if self.task.trial is None:
      self.task_label = '[{}] {}'.format(self.task.task_id, self.task.type)
    else:
      self.task_label = '[{}] {} trial {}'.format(self.task.task_id, self.task.type, self.task.trial.trial)
    self.SetLabel(self.task_label)
    self.Refresh()

class TagButton(GradButton):
  def __init__(self, parent, run, size=wx.DefaultSize):
    self.run = run
    self.tags = self.run.tags
    self.parent = parent

    GradButton.__init__(self, parent=parent, size=size)

    self.update_label()

  def update_label(self):

    label = ', '.join([i.name for i in self.tags])
    self.SetLabel(label)
    self.SetFont(wx.Font(button_font_size, wx.DEFAULT, wx.NORMAL, wx.NORMAL))
    self.Refresh()

  def change_tags(self):
    ''' Calls dialog with tag options for all runs; user will select tags
        for this specific run
    '''
    all_tags = self.run.app.get_all_tags()
    all_tag_names = [t.name for t in all_tags]
    tag_dlg = wx.MultiChoiceDialog(self,
                                   message='Available sample tags',
                                   caption='Sample Tags',
                                   choices=all_tag_names)
    # Get indices of selected items (if any) and set them to checked
    local_tag_names = [i.name for i in self.tags]
    indices = [all_tag_names.index(i) for i in all_tag_names if i in local_tag_names]
    tag_dlg.SetSelections(indices)
    tag_dlg.Fit()

    if (tag_dlg.ShowModal() == wx.ID_OK):
      tag_indices = tag_dlg.GetSelections()

      self.tags = [i for i in all_tags if all_tags.index(i) in
                   tag_indices]
      old_tags = self.run.tags
      old_tag_names = [t.name for t in old_tags]
      new_tag_names = [t.name for t in self.tags]

      for new_tag in self.tags:
        if new_tag.name not in old_tag_names:
          self.run.add_tag(new_tag)

      for old_tag in old_tags:
        if old_tag.name not in new_tag_names:
          self.run.remove_tag(old_tag)

      # re-synchronize, just in case
      self.tags = self.run.tags

      self.update_label()


# --------------------------------- Controls --------------------------------- #

class CtrlBase(wx.Panel):
  ''' Control panel base class '''
  def __init__(self,
               parent,
               label_style='normal',
               content_style='normal',
               size=wx.DefaultSize, **kwargs):

    wx.Panel.__init__(self, parent=parent, id=wx.ID_ANY, size=size, **kwargs)
    if label_style == 'normal':
      self.font = wx.Font(norm_font_size, wx.DEFAULT, wx.NORMAL, wx.NORMAL)
    elif label_style == 'bold':
      self.font = wx.Font(norm_font_size, wx.DEFAULT, wx.NORMAL, wx.BOLD)
    elif label_style == 'italic':
      self.font = wx.Font(norm_font_size, wx.DEFAULT, wx.ITALIC, wx.NORMAL)
    elif label_style == 'italic_bold':
      self.font = wx.Font(norm_font_size, wx.DEFAULT, wx.ITALIC, wx.BOLD)

    if content_style == 'normal':
      self.cfont = wx.Font(norm_font_size, wx.DEFAULT, wx.NORMAL, wx.NORMAL)
    elif content_style == 'bold':
      self.cfont = wx.Font(norm_font_size, wx.DEFAULT, wx.NORMAL, wx.BOLD)
    elif content_style == 'italic':
      self.cfont = wx.Font(norm_font_size, wx.DEFAULT, wx.ITALIC, wx.NORMAL)
    elif content_style == 'italic_bold':
      self.cfont = wx.Font(norm_font_size, wx.DEFAULT, wx.ITALIC, wx.BOLD)

class InputCtrl(CtrlBase):
  ''' Generic panel that will place a text control, with a label and an
      optional Browse / magnifying-glass buttons into a window'''

  def __init__(self, parent,
               label='', label_size=(100, -1),
               label_style='normal',
               button=False, value=''):

    CtrlBase.__init__(self, parent=parent, label_style=label_style)

    output_box = wx.FlexGridSizer(1, 4, 0, 10)
    self.txt = wx.StaticText(self, label=label, size=label_size)
    self.txt.SetFont(self.font)
    output_box.Add(self.txt)

    self.ctr = TextCtrl(self) #, size=ctr_size)
    self.ctr.SetValue(value)
    output_box.Add(self.ctr, flag=wx.EXPAND)

    self.btn_browse = Button(self, label='Browse...')
    self.btn_mag = wx.BitmapButton(self,
                                   bitmap=wx.Bitmap('{}/16x16/viewmag.png'
                                                    ''.format(icons)))
    output_box.Add(self.btn_browse, flag=wx.RESERVE_SPACE_EVEN_IF_HIDDEN)
    output_box.Add(self.btn_mag, flag=wx.RESERVE_SPACE_EVEN_IF_HIDDEN)

    if not button:
      self.btn_browse.Hide()
      self.btn_mag.Hide()

    output_box.AddGrowableCol(1, 1)
    self.SetSizer(output_box)

class PanelTextCtrl(CtrlBase):
  ''' Generic panel placing only a text box'''

  def __init__(self, parent,
               ctrl_size=(200, -1),
               value=''):
    CtrlBase.__init__(self, parent=parent)

    output_box = wx.FlexGridSizer(1, 4, 0, 10)
    self.txt = wx.StaticText(self)
    self.txt.SetFont(self.font)
    output_box.Add(self.txt)

    self.ctr = TextCtrl(self, size=ctrl_size)
    self.ctr.SetValue(value)
    output_box.Add(self.ctr, flag=wx.EXPAND)

    self.SetSizer(output_box)

class TextButtonCtrl(CtrlBase):
  ''' Generic panel that will place a text control, with a label and an
      optional large button, and an optional bitmap button'''

  def __init__(self, parent,
               label='', label_size=(100, -1),
               label_style='normal',
               text_style=wx.TE_LEFT,
               ctrl_size=(200, -1),
               big_button=False,
               big_button_label='Browse...',
               big_button_size=wx.DefaultSize,
               ghost_button=True,
               value='', **kwargs):

    CtrlBase.__init__(self, parent=parent, label_style=label_style, **kwargs)

    output_box = wx.FlexGridSizer(1, 4, 0, 10)
    self.txt = wx.StaticText(self, label=label, size=label_size)
    self.txt.SetFont(self.font)
    output_box.Add(self.txt)

    self.ctr = TextCtrl(self, name=self.Name + "_ctr", style=text_style, size=ctrl_size)
    self.ctr.SetValue(value)
    output_box.Add(self.ctr, flag=wx.EXPAND)

    self.btn_big = Button(self, name=self.Name + "_btn_big", label=big_button_label, size=big_button_size)
    if ghost_button:
      output_box.Add(self.btn_big, flag=wx.RESERVE_SPACE_EVEN_IF_HIDDEN)
    else:
      output_box.Add(self.btn_big)

    if not big_button:
      self.btn_big.Hide()

    output_box.AddGrowableCol(1, 1)
    self.SetSizer(output_box)

class TwoButtonCtrl(CtrlBase):
  ''' Generic panel that will place a text control, with a label and an
      optional large button, and an optional bitmap button'''

  def __init__(self, parent,
               label='', label_size=(100, -1),
               label_style='normal',
               text_style=wx.TE_LEFT,
               button1=False,
               button1_label='Browse...',
               button1_size=wx.DefaultSize,
               button2=False,
               button2_label='Default',
               button2_size=wx.DefaultSize,
               value='', **kwargs):

    CtrlBase.__init__(self, parent=parent, label_style=label_style, **kwargs)

    output_box = wx.FlexGridSizer(1, 5, 0, 10)
    self.txt = wx.StaticText(self, label=label, size=label_size)
    self.txt.SetFont(self.font)
    output_box.Add(self.txt)

    self.ctr = TextCtrl(self, style=text_style)
    self.ctr.SetValue(value)
    output_box.Add(self.ctr, flag=wx.EXPAND)

    if button1:
      self.button1 = Button(self, label=button1_label, size=button1_size)
      output_box.Add(self.button1)

    if button2:
      self.button2 = Button(self, label=button2_label, size=button2_size)
      output_box.Add(self.button2)

    output_box.AddGrowableCol(1, 1)
    self.SetSizer(output_box)

class OptionCtrl(CtrlBase):
  ''' Generic panel will place a text control w/ label '''
  def __init__(self, parent, items,
               label='',
               label_size=(100, -1),
               label_style='normal',
               sub_labels=(),
               ctrl_size=(300, -1),
               **kwargs):

    CtrlBase.__init__(self, parent=parent, label_style=label_style, **kwargs)

    if label != '':
      opt_box = wx.FlexGridSizer(1, len(items) * 2 + 1, 0, 10)
      self.txt = wx.StaticText(self, label=label, size=label_size)
      self.txt.SetFont(self.font)
      opt_box.Add(self.txt, flag=wx.ALIGN_CENTER_VERTICAL)
    else:
      opt_box = wx.FlexGridSizer(1, len(items) * 2, 0, 10)

    for key, value in items:
      if sub_labels:
        sub_label = sub_labels[items.index((key, value))]
      else:
        sub_label = key

      opt_label = wx.StaticText(self, id=wx.ID_ANY, label=sub_label)
      opt_box.Add(opt_label, flag=wx.ALIGN_CENTER_VERTICAL)

      item = TextCtrl(self, name = self.Name+"_"+key, id=wx.ID_ANY, size=ctrl_size,
                      style=wx.TE_PROCESS_ENTER)
      item.SetValue(str(value))
      opt_box.Add(item, flag=wx.ALIGN_CENTER_VERTICAL)
      self.__setattr__(key, item)

    self.SetSizer(opt_box)
    setup_tooltip(self)

class VerticalOptionCtrl(CtrlBase):
  ''' Generic panel will place a text control w/ label in column'''
  def __init__(self, parent, items,
               label='',
               label_size=(100, -1),
               label_style='normal',
               sub_labels=(),
               ctrl_size=(300, -1)):

    CtrlBase.__init__(self, parent=parent, label_style=label_style)

    if label != '':
      opt_box = wx.FlexGridSizer(len(items) * 2 + 1, 2, 10, 10)
      self.txt = wx.StaticText(self, label=label, size=label_size)
      self.txt.SetFont(self.font)
      opt_box.Add(self.txt, flag=wx.ALIGN_CENTER_VERTICAL)
      opt_box.Add((0, 0))
    else:
      opt_box = wx.FlexGridSizer(len(items) * 2, 2, 10, 10)

    for key, value in items:
      if sub_labels:
        sub_label = sub_labels[items.index((key, value))]
      else:
        sub_label = key

      if len(items) > 1:
        opt_label = wx.StaticText(self, id=wx.ID_ANY, label=sub_label)
        opt_box.Add(opt_label, flag=wx.ALIGN_CENTER_VERTICAL)

      item = TextCtrl(self, id=wx.ID_ANY, size=ctrl_size,
                      style=wx.TE_PROCESS_ENTER)
      item.SetValue(str(value))
      opt_box.Add(item, flag=wx.ALIGN_CENTER_VERTICAL)
      self.__setattr__(key, item)

    self.SetSizer(opt_box)

class IntFloatSpin(fs.FloatSpin):
  def __init__(self, *args, **kwargs):
    super(IntFloatSpin, self).__init__(*args, **kwargs)
    setup_tooltip(self)

  def GetValue(self):
    float_value = super(IntFloatSpin, self).GetValue()
    int_value = int(round(float_value))
    return int_value

class SpinCtrl(CtrlBase):
  ''' Generic panel will place a spin control w/ label '''
  def __init__(self, parent,
               label='',
               label_size=(200, -1),
               label_style='normal',
               ctrl_size=(60, -1),
               ctrl_value='3',
               ctrl_max=10,
               ctrl_min=0,
               ctrl_step=1,
               ctrl_digits=0,
               **kwargs):

    CtrlBase.__init__(self, parent=parent, label_style=label_style, **kwargs)

    ctr_box = wx.FlexGridSizer(1, 3, 0, 10)
    self.txt = wx.StaticText(self, label=label,
                             size=label_size)
    self.txt.SetFont(self.font)

    floatspin_class = IntFloatSpin if ctrl_digits == 0 else fs.FloatSpin
    self.ctr = floatspin_class(self, name=self.Name + "_ctr",
                               value=ctrl_value, max_val=(ctrl_max),
                               min_val=(ctrl_min), increment=ctrl_step,
                               digits=ctrl_digits, size=ctrl_size)
    ctr_box.Add(self.txt, flag=wx.ALIGN_CENTER_VERTICAL)
    ctr_box.Add(self.ctr, flag=wx.ALIGN_CENTER_VERTICAL)

    self.SetSizer(ctr_box)

class ChoiceCtrl(CtrlBase):
  ''' Generic panel will place a choice control w/ label '''

  def __init__(self, parent,
               choices,
               label='',
               label_size=(200, -1),
               label_style='normal',
               ctrl_size=(100, -1), **kwargs):

    CtrlBase.__init__(self, parent=parent, label_style=label_style, **kwargs)
    ctr_box = wx.FlexGridSizer(1, 3, 0, 10)
    self.txt = wx.StaticText(self, label=label, size=label_size)
    self.txt.SetFont(self.font)

    # Check if choices are tuples, extract data and assign to items if so
    if all(isinstance(i, tuple) for i in choices):
      items = [i[0] for i in choices]
      self.ctr = Choice(self, name=self.Name + "_ctr", size=ctrl_size, choices=items)
      for choice in choices:
        item_idx = self.ctr.FindString(choice[0])
        self.ctr.SetClientData(item_idx, choice[1])
    else:
      self.ctr = Choice(self, name=self.Name + "_ctr", size=ctrl_size, choices=choices)

    ctr_box.Add(self.txt, flag=wx.ALIGN_CENTER_VERTICAL)
    ctr_box.Add(self.ctr, flag=wx.ALIGN_CENTER_VERTICAL)

    self.SetSizer(ctr_box)

class CheckListCtrl(CtrlBase):
  def __init__(self, parent,
               choices,
               label='',
               label_size=(200, -1),
               label_style='normal',
               ctrl_size=(150, -1),
               direction='horizontal'):

    CtrlBase.__init__(self, parent=parent, label_style=label_style)

    self.txt = wx.StaticText(self, label=label, size=label_size)
    self.txt.SetFont(self.font)
    self.ctr = wx.CheckListBox(self, size=ctrl_size, choices=choices)

    if label == '':
      ctr_box = wx.BoxSizer(wx.VERTICAL)
    else:
      if direction == 'horizontal':
        ctr_box = wx.FlexGridSizer(1, 2, 0, 10)
      elif direction == 'vertical':
        ctr_box = wx.FlexGridSizer(2, 1, 10, 0)
      ctr_box.Add(self.txt, flag=wx.ALIGN_CENTER_VERTICAL)

    ctr_box.Add(self.ctr, proportion=1,
                flag=wx.ALIGN_CENTER_VERTICAL | wx.EXPAND)

    self.SetSizer(ctr_box)

class MultiChoiceCtrl(CtrlBase):
  ''' Generic panel with multiple choice controls / labels '''

  def __init__(self, parent, items,
               label='',
               label_size=(200, -1),
               label_style='normal',
               ctrl_size=(100, -1)):
    CtrlBase.__init__(self, parent=parent, label_style=label_style)


    choice_box = wx.FlexGridSizer(1, len(items) * 2 + 1, 0, 10)
    self.txt = wx.StaticText(self, label=label, size=label_size)
    self.txt.SetFont(self.font)
    choice_box.Add(self.txt, flag=wx.ALIGN_CENTER_VERTICAL)

    for key, choices in six.iteritems(items):
      if len(items) > 1:
        ch_label =wx.StaticText(self, id=wx.ID_ANY, label=key)
        choice_box.Add(ch_label, flag=wx.ALIGN_CENTER_VERTICAL)

      item = Choice(self, id=wx.ID_ANY, size=ctrl_size, choices=choices)
      choice_box.Add(item, flag=wx.ALIGN_CENTER_VERTICAL)
      self.__setattr__(key, item)

    self.SetSizer(choice_box)

class TableCtrl(CtrlBase):
  ''' Generic panel will place a table w/ x and y labels
      Data must be a list of lists for multi-column tables '''

  def __init__(self, parent,
               clabels=(),
               clabel_size=(200, -1),
               rlabels=(),
               rlabel_size=(200, -1),
               contents=(),
               label_style='normal',
               content_style='normal'):

    CtrlBase.__init__(self, parent=parent, label_style=label_style,
                      content_style=content_style)
    nrows = len(rlabels) + 1

    if len(clabels) == 0:
      ncols = 2
    else:
      ncols = len(clabels) + 1
    self.sizer = wx.FlexGridSizer(nrows, ncols, 10, 10)

    # add column labels (xlabels)
    if len(clabels) > 0:
      self.sizer.Add(wx.StaticText(self, label=''))
      for i in clabels:
        clabel = wx.StaticText(self, label=i.decode('utf-8'), size=clabel_size)
        clabel.SetFont(self.font)
        self.sizer.Add(clabel)

    # add row labels and row contents
    for l in rlabels:
      row_label = wx.StaticText(self, label=l.decode('utf-8'), size=rlabel_size)
      row_label.SetFont(self.font)
      self.sizer.Add(row_label)

      # Add data to table
      c_index = rlabels.index(l)
      for item in contents[c_index]:
        cell = wx.StaticText(self, label=item.decode('utf-8'))
        cell.SetFont(self.cfont)
        self.sizer.Add(cell)

    self.SetSizer(self.sizer)

class RadioCtrl(CtrlBase):
  '''Generic panel with multiple radio buttons.'''

  def __init__(self, parent,
               label='',
               label_size=(200, -1),
               label_style='normal',
               ctrl_size=(100, -1),
               direction='horizontal',
               items=None, **kwargs):
    CtrlBase.__init__(self, parent=parent, label_style=label_style, **kwargs)
    items = {} if items is None else items

    if direction == 'horizontal':
      radio_group = wx.FlexGridSizer(1, len(items) + 1, 0, 10)
    else:
      radio_group = wx.FlexGridSizer(len(items) + 1, 1, 0, 10)
    if label != '':
      self.txt = wx.StaticText(self, label=label, size=label_size)
      self.txt.SetFont(self.font)
      radio_group.Add(self.txt, flag=wx.ALIGN_CENTER_VERTICAL)

    for key, value in six.iteritems(items):
      button = wx.RadioButton(self, id=wx.ID_ANY, label=value)
      radio_group.Add(button)
      self.__setattr__(key, button)

    self.SetSizer(radio_group)
    setup_tooltip(self)

# Use a mixin to support sorting by columns
import wx.lib.mixins.listctrl as listmix

class SortableListCtrl(wx.ListCtrl, listmix.ColumnSorterMixin):
  def __init__(self, parent, style=wx.LC_ICON):
    self.integer_columns = set()
    self.parent = parent
    self.sortable_mixin = listmix
    wx.ListCtrl.__init__(self, parent, style=style)

  def initialize_sortable_columns(self, n_col=0, itemDataMap=None):
    self.itemDataMap = {} if itemDataMap is None else itemDataMap
    self.sortable_mixin.ColumnSorterMixin.__init__(self, n_col)
    sortable_list = self.GetListCtrl()
    if sortable_list:
      sortable_list.Bind(wx.EVT_LIST_COL_CLICK, self.__OnColClick, sortable_list)

  def __OnColClick(self, e):
    self._col = e.GetColumn()
    self._colSortFlag[self._col] = int(not self._colSortFlag[self._col])
    self.GetListCtrl().SortItems(self.get_appropriate_sorter())
    self.OnSortOrderChanged()
    if hasattr(self.parent, 'onColClick'):
      self.parent.onColClick(e)

  def RestoreSortOrder(self, col, colSortFlag):
    self._col = col
    self._colSortFlag = colSortFlag
    self.GetListCtrl().SortItems(self.get_appropriate_sorter())
    self.OnSortOrderChanged()

  def GetListCtrl(self):
    return self

  def get_appropriate_sorter(self):
    return self.integer_column_sorter if self._col in self.integer_columns \
      else self.GetColumnSorter()

  def integer_column_sorter(self, key1, key2):
    col = self._col
    ascending = self._colSortFlag[col]
    try:
      item1 = int(self.itemDataMap[key1][col])
    except (ValueError, SystemError):
      item1 = -1073741820
    try:
      item2 = int(self.itemDataMap[key2][col])
    except (ValueError, SystemError):
      item2 = -1073741820
    difference = item1 - item2
    if difference == 0:
      difference = 1 if key1 > key2 else -1
    return difference if ascending else -difference


# ------------------------------- UI Elements -------------------------------- #

class RunBlock(CtrlBase):
  def __init__(self, parent, block,
               label_style='normal',
               content_style='normal'):

    self.block = block

    CtrlBase.__init__(self, parent=parent, label_style=label_style,
                      content_style=content_style)

    self.sizer = wx.FlexGridSizer(1, 2, 0, 5)
    self.new_runblock = RunBlockButton(self, size=(225, 30), block=block)

    self.sizer.Add(self.new_runblock)

    self.SetSizer(self.sizer)

class TaskCtrl(CtrlBase):
  def __init__(self, parent, task,
               label_style='normal',
               content_style='normal'):

    self.task = task

    CtrlBase.__init__(self, parent=parent, label_style=label_style,
                      content_style=content_style)

    self.sizer = wx.FlexGridSizer(1, 2, 0, 5)
    self.new_task = TaskButton(self, size=(250, 30), task=task)

    self.sizer.Add(self.new_task)

    self.SetSizer(self.sizer)

class PHILBox(CtrlBase):
  def __init__(self, parent,
               btn_import=True,
               btn_import_size=(120, -1),
               btn_import_label='Import PHIL',
               btn_export=False,
               btn_export_size=(120, -1),
               btn_export_label='Export PHIL',
               btn_default=True,
               btn_default_size=(120, -1),
               btn_default_label='Default PHIL',
               ctr_size=(-1, 125),
               ctr_value='',
               label_style='normal',
               content_style='normal'):

    CtrlBase.__init__(self, parent=parent, label_style=label_style,
                      content_style=content_style)

    self.sizer = wx.GridBagSizer(5, 5)
    self.SetSizer(self.sizer)

    self.ctr = RichTextCtrl(self,
                            size=ctr_size,
                            style=wx.VSCROLL,
                            value=ctr_value)
    span_counter = 0
    if btn_import:
      self.btn_import = Button(self,
                                  label=btn_import_label,
                                  size=btn_import_size)
      self.sizer.Add(self.btn_import, pos=(span_counter, 0))
      span_counter += 1
    if btn_export:
      self.btn_export = Button(self,
                                  label=btn_export_label,
                                  size=btn_export_size)
      self.sizer.Add(self.btn_export, pos=(span_counter, 0))
      span_counter += 1
    if btn_default:
      self.btn_default = Button(self,
                                   label=btn_default_label,
                                   size=btn_default_size)
      self.sizer.Add(self.btn_default, pos=(span_counter, 0))
      span_counter += 1

    if span_counter > 0:
      self.sizer.Add(self.ctr, pos=(0, 1), span=(span_counter + 1, 1),
                     flag=wx.EXPAND)
      self.sizer.AddGrowableRow(span_counter)
    elif span_counter == 0:
      self.sizer = wx.BoxSizer(wx.VERTICAL)
      self.sizer.Add(self.ctr, 1, flag=wx.EXPAND)

    self.sizer.AddGrowableCol(1)

class GaugeBar(CtrlBase):
  def __init__(self, parent,
               label='',
               label_size=(80, -1),
               label_style='normal',
               content_style='normal',
               gauge_size=(250, 15),
               button=False,
               button_label='View Stats',
               button_size=wx.DefaultSize,
               choice_box=True,
               choice_label='',
               choice_label_size=(120, -1),
               choice_size=(100, -1),
               choice_style='normal',
               choices=(),
               gauge_max=100):
    CtrlBase.__init__(self, parent=parent, label_style=label_style,
                      content_style=content_style)

    self.sizer = wx.FlexGridSizer(1, 6, 0, 10)
    self.sizer.AddGrowableCol(3)
    self.bar = wx.Gauge(self, range=gauge_max, size=gauge_size)

    if choice_box:
      self.bins = ChoiceCtrl(self,
                             label=choice_label,
                             label_size=choice_label_size,
                             label_style=choice_style,
                             ctrl_size=choice_size,
                             choices=choices)

    self.txt_iso = wx.StaticText(self, label=label, size=label_size)
    self.txt_max = wx.StaticText(self, label=str(gauge_max))
    self.txt_min = wx.StaticText(self, label='0')
    self.sizer.Add(self.txt_iso)
    self.sizer.Add(self.txt_min)
    self.sizer.Add(self.bar)
    self.sizer.Add(self.txt_max)
    self.sizer.Add(self.bins)

    if button:
      self.btn = Button(self, label=button_label, size=button_size)
      self.sizer.Add(self.btn, 1, wx.ALIGN_RIGHT | wx.ALIGN_CENTER)

    self.SetSizer(self.sizer)


tp_EVT_STATUS_CHANGE = wx.NewEventType()
EVT_STATUS_CHANGE = wx.PyEventBinder(tp_EVT_STATUS_CHANGE, 1)

class StatusChange(wx.PyCommandEvent):
  ''' Send event when status light is updated '''
  def __init__(self, etype, eid, status=None):
    wx.PyCommandEvent.__init__(self, etype, eid)
    self.status = status
  def GetValue(self):
    return self.status

class SentinelStatus(CtrlBase):
  def __init__(self, parent,
               label='',
               label_size=(120, -1),
               label_style='normal',
               content_style='normal'):

    self.label = label
    self.label_size = label_size

    CtrlBase.__init__(self, parent=parent, label_style=label_style,
                      content_style=content_style, size=(-1, 24))

    bmp = wx.Bitmap('{}/16x16/led_off.png'.format(icons))
    self.light = wx.StaticBitmap(self, -1, bmp)

    self.sizer = wx.FlexGridSizer(1, 2, 0, 10)
    self.sizer.Add(self.light)
    self.sizer.Add(wx.StaticText(self, label=self.label, size=self.label_size))

    self.SetSizer(self.sizer)

    self.Bind(EVT_STATUS_CHANGE, self.onChangeStatus)

  def change_status(self, status):
    evt = StatusChange(tp_EVT_STATUS_CHANGE, -1, status)
    wx.PostEvent(self, evt)

  def onChangeStatus(self, evt):
    status = evt.GetValue()

    if status == 'on':
      bmp = wx.Bitmap('{}/16x16/led_on.png'.format(icons))
    elif status == 'off':
      bmp = wx.Bitmap('{}/16x16/led_off.png'.format(icons))
    elif status == 'idle':
      bmp = wx.Bitmap('{}/16x16/led_idle.png'.format(icons))
    elif status == 'alert':
      bmp = wx.Bitmap('{}/16x16/led_alert.png'.format(icons))

    self.light.SetBitmap(bmp)


class IsoformInfoCtrl(CtrlBase):
  def __init__(self, parent,
               label_style='normal',
               content_style='normal'):
    CtrlBase.__init__(self, parent=parent, label_style=label_style,
                      content_style=content_style)

    self.uc_values = None

    self.sizer = wx.FlexGridSizer(1, 9, 0, 10)
    self.sizer.AddGrowableCol(7)
    self.txt_iso = wx.StaticText(self, label='Isoform')
    self.txt_pg = wx.StaticText(self, label='Point Group')
    self.txt_num = wx.StaticText(self, label='No. Images')
    self.txt_uc = wx.StaticText(self, label='Unit Cell')

    self.ctr_iso = TextCtrl(self, size=(30, -1), style=wx.TE_READONLY)
    self.ctr_pg = TextCtrl(self, size=(50, -1), style=wx.TE_READONLY)
    self.ctr_num = TextCtrl(self, size=(50, -1), style=wx.TE_READONLY)
    self.ctr_uc = TextCtrl(self, size=(200, -1), style=wx.TE_READONLY)

    self.btn_hist = Button(self, label='Histogram')

    self.sizer.Add(self.txt_iso, flag=wx.ALIGN_CENTER_VERTICAL)
    self.sizer.Add(self.ctr_iso, flag=wx.ALIGN_CENTER_VERTICAL)
    self.sizer.Add(self.txt_pg, flag=wx.ALIGN_CENTER_VERTICAL)
    self.sizer.Add(self.ctr_pg, flag=wx.ALIGN_CENTER_VERTICAL)
    self.sizer.Add(self.txt_num, flag=wx.ALIGN_CENTER_VERTICAL)
    self.sizer.Add(self.ctr_num, flag=wx.ALIGN_CENTER_VERTICAL)
    self.sizer.Add(self.txt_uc, flag=wx.ALIGN_CENTER_VERTICAL)
    self.sizer.Add(self.ctr_uc, flag=wx.EXPAND | wx.ALIGN_CENTER_VERTICAL)
    self.sizer.Add(self.btn_hist, flag=wx.ALIGN_CENTER_VERTICAL)

    self.Bind(wx.EVT_BUTTON, self.onClusterHistogram, self.btn_hist)

    self.SetSizer(self.sizer)

  def onClusterHistogram(self, e):

    if self.uc_values is not None:
      import xfel.ui.components.xfel_gui_plotter as pltr
      plotter = pltr.PopUpCharts()
      plotter.plot_uc_histogram(info_list=[self.uc_values], legend_list=[])
      plotter.plt.show()


 *******************************************************************************


 *******************************************************************************
xfel/ui/components/xfel_gui_dialogs.py
from __future__ import absolute_import, division, print_function
from six.moves import range
import six

'''
Author      : Lyubimov, A.Y.
Created     : 06/04/2016
Last Changed: 06/04/2016
Description : XFEL UI Custom Dialogs
'''

import time
import os
import wx
from wx.lib.mixins.listctrl import TextEditMixin, getListCtrlSelection
from wx.lib.scrolledpanel import ScrolledPanel
from xfel.ui.db.task import task_types
import numpy as np

import xfel.ui.components.xfel_gui_controls as gctr
from xfel.ui.components.submission_tracker import QueueInterrogator

icons = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'icons/')

# Platform-specific stuff
# TODO: Will need to test this on Windows at some point
if wx.Platform == '__WXGTK__':
  norm_font_size = 10
  button_font_size = 12
  LABEL_SIZE = 14
  CAPTION_SIZE = 12
elif wx.Platform == '__WXMAC__':
  norm_font_size = 12
  button_font_size = 14
  LABEL_SIZE = 14
  CAPTION_SIZE = 12
elif (wx.Platform == '__WXMSW__'):
  norm_font_size = 9
  button_font_size = 11
  LABEL_SIZE = 11
  CAPTION_SIZE = 9


class EdListCtrl(wx.ListCtrl, TextEditMixin):
  ''' TextEditMixin allows any column to be edited. '''

  # ----------------------------------------------------------------------
  def __init__(self, parent, ID=wx.ID_ANY, pos=wx.DefaultPosition,
               size=wx.DefaultSize, style=0):
    """Constructor"""
    wx.ListCtrl.__init__(self, parent, ID, pos, size, style)
    TextEditMixin.__init__(self)
    self.curRow = -1

  def OnLeftDown(self, evt=None):
    try:
      return super(EdListCtrl, self).OnLeftDown(evt)
    except wx._core.wxAssertionError:
      pass

class BaseDialog(wx.Dialog):
  def __init__(self, parent,
               label_style='bold',
               content_style='normal',
               *args, **kwargs):
    wx.Dialog.__init__(self, parent, *args, **kwargs)

    self.envelope = wx.BoxSizer(wx.VERTICAL)
    self.main_sizer = wx.BoxSizer(wx.VERTICAL)
    self.envelope.Add(self.main_sizer, flag=wx.EXPAND | wx.ALL, border=5)
    self.SetSizer(self.envelope)

    if label_style == 'normal':
      self.font = wx.Font(norm_font_size, wx.DEFAULT, wx.NORMAL, wx.NORMAL)
    elif label_style == 'bold':
      self.font = wx.Font(norm_font_size, wx.DEFAULT, wx.NORMAL, wx.BOLD)
    elif label_style == 'italic':
      self.font = wx.Font(norm_font_size, wx.DEFAULT, wx.ITALIC, wx.NORMAL)
    elif label_style == 'italic_bold':
      self.font = wx.Font(norm_font_size, wx.DEFAULT, wx.ITALIC, wx.BOLD)

    if content_style == 'normal':
      self.cfont = wx.Font(norm_font_size, wx.DEFAULT, wx.NORMAL, wx.NORMAL)
    elif content_style == 'bold':
      self.cfont = wx.Font(norm_font_size, wx.DEFAULT, wx.NORMAL, wx.BOLD)
    elif content_style == 'italic':
      self.cfont = wx.Font(norm_font_size, wx.DEFAULT, wx.ITALIC, wx.NORMAL)
    elif content_style == 'italic_bold':
      self.cfont = wx.Font(norm_font_size, wx.DEFAULT, wx.ITALIC, wx.BOLD)


# --------------------------------- Dialogs ---------------------------------- #

class SettingsDialog(BaseDialog):
  ''' Initial settings for cctbx.xfel; accepts DB credentials (may be
  separate dialog), populates experiment name / tag, separate dialog for
  multiprocessing and other settings; starts sentinels on OK '''

  def __init__(self, parent, params,
               label_style='bold',
               content_style='normal',
               *args, **kwargs):

    BaseDialog.__init__(self, parent,
                        label_style=label_style,
                        content_style=content_style,
                        size=(600, -1),
                        *args, **kwargs)

    self.params = params
    self.drop_tables = False

    self.main_sizer = wx.BoxSizer(wx.VERTICAL)

    # Experiment tag and DB Credentials button
    self.db_cred = gctr.TextButtonCtrl(self,
                                       name='db_cred',
                                       label='Experiment Tag',
                                       label_style='bold',
                                       label_size=(150, -1),
                                       big_button=True,
                                       big_button_label='DB Credentials...',
                                       big_button_size=(130, -1),
                                       value=self.params.experiment_tag if self.params.experiment_tag is not None else "")
    self.main_sizer.Add(self.db_cred,
                        flag=wx.EXPAND | wx.ALL,
                        border=10)

    # Facility control
    self.facility_sizer = wx.BoxSizer(wx.HORIZONTAL)

    choices = ['LCLS', 'Standalone']
    lower_choices = [f.lower() for f in choices]
    self.facility = gctr.ChoiceCtrl(self,
                                    name = 'facility',
                                    label='Facility',
                                    label_size=(150, -1),
                                    ctrl_size=(180, -1),
                                    label_style='bold',
                                    choices=choices)
    self.facility_sizer.Add(self.facility, flag=wx.EXPAND | wx.ALL, border=10)
    try:
      self.facility.ctr.SetSelection(lower_choices.index(params.facility.name))
    except ValueError:
      pass

    self.btn_facility_options = gctr.Button(self, name = 'btn_facility_options', label='Options...')
    self.facility_sizer.Add(self.btn_facility_options, flag=wx.EXPAND | wx.ALL, border=10)

    self.main_sizer.Add(self.facility_sizer, flag=wx.EXPAND | wx.ALL)

    # Experiment name control
    experiment = None
    if self.params.facility.name == 'lcls': experiment = self.params.facility.lcls.experiment
    if experiment is None: experiment = ''
    self.experiment = gctr.TextButtonCtrl(self,
                                          name='experiment',
                                          label='Experiment',
                                          label_style='bold',
                                          label_size=(150, -1),
                                          big_button_size=(130, -1),
                                          value=experiment)
    self.main_sizer.Add(self.experiment,
                        flag=wx.EXPAND | wx.ALL,
                        border=10)

    # Output folder text control w/ Browse / magnifying glass button
    if self.params.output_folder == '':
      current_folder = os.path.abspath(os.curdir)
    else:
      current_folder = self.params.output_folder
    self.output = gctr.TextButtonCtrl(self,
                                      name='output',
                                      label='Output',
                                      label_style='bold',
                                      label_size=(150, -1),
                                      big_button=True,
                                      big_button_label='Browse...',
                                      big_button_size=(120, -1),
                                      value=current_folder)
    self.main_sizer.Add(self.output,
                        flag=wx.EXPAND | wx.ALL,
                        border=10)

    self.btn_op = gctr.Button(self, name='advanced', label='Advanced Settings...')
    self.btn_OK = wx.Button(self, label="OK", id=wx.ID_OK)
    self.btn_OK.SetDefault()
    self.btn_cancel = wx.Button(self, label="Cancel", id=wx.ID_CANCEL)

    button_sizer = wx.FlexGridSizer(1, 4, 0, 10)
    button_sizer.AddMany([#(self.btn_mp),
                          (self.btn_op),
                          (0,0),
                          (self.btn_OK),
                          (self.btn_cancel)])

    button_sizer.AddGrowableCol(1)
    self.main_sizer.Add(button_sizer,
                        flag=wx.EXPAND | wx.ALL,
                        border=10)
    self.SetSizerAndFit(self.main_sizer)

    self.Bind(wx.EVT_BUTTON, self.onDBCredentialsButton, id=self.db_cred.btn_big.GetId())
    self.Bind(wx.EVT_BUTTON, self.onAdvanced, id=self.btn_op.GetId())
    self.Bind(wx.EVT_BUTTON, self.onOK, id=self.btn_OK.GetId())
    self.Bind(wx.EVT_BUTTON, self.onBrowse, id=self.output.btn_big.GetId())
    self.Bind(wx.EVT_CHOICE, self.onFacilityChoice)
    self.Bind(wx.EVT_BUTTON, self.onFacilityOptions, id=self.btn_facility_options.GetId())

    self.setup_facility_options()

  def onBrowse(self, e):
    dlg = wx.DirDialog(self, "Choose the input directory:",
                       style=wx.DD_DEFAULT_STYLE)

    if dlg.ShowModal() == wx.ID_OK:
      self.output.ctr.SetValue(dlg.GetPath())
    dlg.Destroy()

  def onFacilityChoice(self, e):
    self.params.facility.name = self.facility.ctr.GetStringSelection().lower()
    self.setup_facility_options()

  def setup_facility_options(self):
    if self.params.facility.name in ['lcls']:
      self.experiment.Enable()
    else:
      self.experiment.Disable()

  def onFacilityOptions(self, e):
    if self.params.facility.name == 'lcls':
      opts = LCLSFacilityOptions(self, self.params)
      opts.Fit()
      opts.Center()
      opts.ShowModal()
    elif self.params.facility.name == 'standalone':
      opts = StandaloneOptions(self, self.params)
      opts.Fit()
      opts.Center()
      opts.ShowModal()

  def onAdvanced(self, e):
    adv = AdvancedSettingsDialog(self, self.params)
    adv.Fit()
    adv.Center()

    adv.ShowModal()

  def onDBCredentialsButton(self, e):
    self.update_settings()
    creds = DBCredentialsDialog(self, self.params)
    creds.Center()
    if (creds.ShowModal() == wx.ID_OK):
      self.params.db.host     = creds.db_host.ctr.GetValue()
      self.params.db.port     = int(creds.db_port.ctr.GetValue())
      self.params.db.name     = creds.db_name.ctr.GetValue()
      self.params.db.user     = creds.db_user.ctr.GetValue()
      self.params.db.password = creds.db_password.ctr.GetValue()
      if self.params.facility.name == 'lcls':
        self.params.facility.lcls.web.location = creds.web_location.ctr.GetValue()

      self.drop_tables = creds.chk_drop_tables.GetValue()

  def update_settings(self):
    self.params.facility.name = self.facility.ctr.GetStringSelection().lower()
    self.params.experiment_tag = self.db_cred.ctr.GetValue()
    self.params.output_folder = self.output.ctr.GetValue()
    if self.params.facility.name == 'lcls':
      self.params.facility.lcls.experiment = self.experiment.ctr.GetValue()

  def onOK(self, e):
    self.update_settings()
    e.Skip()


class DBCredentialsDialog(BaseDialog):
  ''' DB credentials entry '''

  def __init__(self, parent, params,
               label_style='bold',
               content_style='normal',
               *args, **kwargs):

    self.params = params
    BaseDialog.__init__(self, parent,
                        label_style=label_style,
                        content_style=content_style,
                        style=wx.NO_BORDER,
                        *args, **kwargs)

    # Host name
    self.db_host = gctr.TextButtonCtrl(self,
                                       name='db_host',
                                       label='DB Host name',
                                       label_style='bold',
                                       label_size=(150, -1),
                                       big_button_size=(130, -1),
                                       value=params.db.host)
    self.main_sizer.Add(self.db_host, flag=wx.EXPAND | wx.ALL, border=10)

    # Host name
    self.db_port = gctr.TextButtonCtrl(self,
                                       name='db_port',
                                       label='DB Port number',
                                       label_style='bold',
                                       label_size=(150, -1),
                                       big_button_size=(130, -1),
                                       value=str(params.db.port))
    self.main_sizer.Add(self.db_port, flag=wx.EXPAND | wx.ALL, border=10)

    # Database name
    self.db_name = gctr.TextButtonCtrl(self,
                                       name='db_name',
                                       label='DB name',
                                       label_style='bold',
                                       label_size=(150, -1),
                                       big_button_size=(130, -1),
                                       value=params.db.name)
    self.main_sizer.Add(self.db_name, flag=wx.EXPAND | wx.ALL, border=10)

    # User name
    self.db_user = gctr.TextButtonCtrl(self,
                                       name='db_user',
                                       label='DB user name',
                                       label_style='bold',
                                       label_size=(150, -1),
                                       big_button_size=(130, -1),
                                       value=params.db.user)
    self.main_sizer.Add(self.db_user, flag=wx.EXPAND | wx.ALL, border=10)

    # Password
    self.db_password = gctr.TextButtonCtrl(self,
                                           name='db_password',
                                           label='DB Password',
                                           label_style='bold',
                                           label_size=(150, -1),
                                           text_style=wx.TE_PASSWORD,
                                           big_button_size=(130, -1),
                                           value=params.db.password)
    self.main_sizer.Add(self.db_password, flag=wx.EXPAND | wx.ALL, border=10)



    # Drop tables button
    self.chk_drop_tables = wx.CheckBox(self,
                                       label='Delete and regenerate all tables')
    self.main_sizer.Add(self.chk_drop_tables, flag=wx.ALL, border=10)

    if params.facility.name == 'lcls':
      self.main_sizer.Add(wx.StaticLine(self), flag=wx.EXPAND | wx.ALL, border=10)
      # LCLS user name
      self.web_location = gctr.TextButtonCtrl(self,
                                              name='web_location',
                                              label='XTC stream location\n(SLAC or NERSC)',
                                              label_style='bold',
                                              label_size=(150, -1),
                                              big_button_size=(130, -1),
                                              value=params.facility.lcls.web.location)
      self.main_sizer.Add(self.web_location, flag=wx.EXPAND | wx.ALL, border=10)

    # Dialog control

    self.btn_db_start = gctr.Button(self, name='start_db', label='Start DB Server')
    self.db_btn_OK = wx.Button(self, name='db_OK', label="OK", id=wx.ID_OK)
    self.db_btn_OK.SetDefault()
    self.db_btn_cancel = wx.Button(self, label="Cancel", id=wx.ID_CANCEL)
    self.button_sizer = wx.BoxSizer(wx.HORIZONTAL)
    self.button_sizer.Add(self.btn_db_start)
    self.button_sizer.Add(-1,-1, proportion=1)
    self.button_sizer.Add(self.db_btn_OK)
    self.button_sizer.Add(self.db_btn_cancel)
    self.main_sizer.Add(self.button_sizer,flag=wx.EXPAND | wx.ALL, border=10)


    self.Bind(wx.EVT_CHECKBOX, self.onDropTables, self.chk_drop_tables)
    self.Bind(wx.EVT_BUTTON, self.onStartDB, self.btn_db_start)

    self.Fit()
    self.SetTitle('Database Credentials')

  def onDropTables(self, e):
    if self.chk_drop_tables.GetValue():
      msg = wx.MessageDialog(self,
                             message='Are you sure?',
                             caption='Warning',
                             style=wx.YES_NO |  wx.ICON_EXCLAMATION)

      if (msg.ShowModal() == wx.ID_NO):
        self.chk_drop_tables.SetValue(False)
    e.Skip()

  def onStartDB(self, e):
    self.start_db_dialog = StartDBDialog(self, self.params)
    if (self.start_db_dialog.ShowModal() == wx.ID_OK):
      self.params.db.server.root_password = self.start_db_dialog.get_db_root_psswd.ctr.GetValue()
      self.params.db.server.basedir = self.start_db_dialog.get_db_basedir.ctr.GetValue()

      def _submit_start_server_job(params):
        from xfel.command_line.cxi_mpi_submit import do_submit
        assert self.params.db.user is not None, "DB User not defined!"
        assert self.params.db.password is not None, "Password for DB User not defined!"
        assert self.params.db.server.root_password is not None, "Root password for DB not defined!"
        assert self.params.db.server.basedir is not None, "Base directory for DB not defined!"

        try:
          import copy
          new_params = copy.deepcopy(params)
          new_params.mp.use_mpi = False
          new_params.mp.extra_args = ["db.port=%d db.server.basedir=%s db.user=%s db.name=%s db.server.root_password=%s" %(params.db.port, params.db.server.basedir, params.db.user, params.db.name, params.db.server.root_password)]
          submit_path = os.path.join(params.output_folder, "launch_server_submit.sh")
          submission_id = do_submit('cctbx.xfel.ui_server',
                                    submit_path,
                                    new_params.output_folder,
                                    new_params.mp,
                                    log_name="my_SQL.log",
                                    err_name="my_SQL.err",
                                    job_name='cctbx_start_mysql'
                                   )
          #remove root password from params
          if submission_id:
            if (self.params.mp.method == 'slurm') or (self.params.mp.method == 'shifter'):
              attempts = 10
              q = QueueInterrogator(self.params.mp.method)
              for i in range(attempts):
                status = q.query(submission_id)
                if status == 'RUN':
                  hostname = q.get_mysql_server_hostname(submission_id)
                  if hostname:
                    self.params.db.host = hostname
                  else:
                    print("Unable to find hostname running MySQL server from SLURM. Submission ID: ", submission_id)
                else:
                  print("Waiting for job to start. Submission ID: %s, status: %s"%(submission_id, status))
                  time.sleep(1)
            elif self.params.mp.method == 'local':
              self.params.db.host = params.db.host
            else:
              print("Unable to find hostname running MySQL server on ", self.params.mp.method)
              print("Submission ID: ", submission_id)

            self.params.db.port = int(params.db.port)
            self.params.db.name = params.db.name
            self.params.db.user = params.db.user
            self.params.db.password = params.db.password
            self.params.db.server.root_password = ''
            self.params.db.server.basedir = params.db.server.basedir

            os.remove(os.path.join(self.params.output_folder, "launch_server_submit.sh"))
            os.remove(os.path.join(self.params.output_folder, "launch_server_submit_submit.sh"))
          else:
            print('couldn\'t submit job')
        except RuntimeError:
          print("Couldn\'t submit job to start MySql DB.")
          print("Check if all phil parameters required to launch jobs exists.")

      _submit_start_server_job(self.params)
      db_file_location = self.params.db.server.basedir
      self.launch_db_sizer = wx.BoxSizer(wx.HORIZONTAL)
      msg_text = "DB will be located in\n" + str(db_file_location)
      self.db_start_box = wx.MessageBox(msg_text,"DB Info", wx.OK | wx.ICON_INFORMATION)
      print("Started DB")
      self.Close()

class StartDBDialog(BaseDialog):
  ''' Dialog to start DB '''

  def __init__(self, parent, params,
               label_style='bold',
               content_style='normal',
               *args, **kwargs):

    self.params = params
    self.start_db_sizer = wx.BoxSizer(wx.HORIZONTAL)
    self.start_db_sizer2 = wx.BoxSizer(wx.HORIZONTAL)
    self.start_db_sizer3 = wx.BoxSizer(wx.HORIZONTAL)
    self.start_db_sizer4 = wx.BoxSizer(wx.HORIZONTAL)
    self.vsiz = wx.BoxSizer(wx.VERTICAL)
    BaseDialog.__init__(self, parent,
                        label_style=label_style,
                        content_style=content_style,
                        style=wx.DEFAULT_FRAME_STYLE,
                        *args, **kwargs)
    warn_icon = wx.ArtProvider.GetBitmap(wx.ART_WARNING, wx.ART_OTHER, (50, 50))
    self.staticbmp = wx.StaticBitmap(self, -1, warn_icon, pos=(1, 1))
    self.start_db_sizer.Add(self.staticbmp, flag=wx.ALL)
    self.vsiz.Add(self.start_db_sizer, 0)
    font = wx.Font(10, wx.FONTFAMILY_DEFAULT, wx.NORMAL, wx.FONTWEIGHT_NORMAL, False)
    warning_label1 = wx.StaticText(self, wx.ID_STATIC, 'This will start the server! Make sure the server is not already running!')
    warning_label1.SetFont(font)
    self.start_db_sizer.Add(warning_label1, 0, wx.ALL | wx.RIGHT)
    self.vsiz.Add(self.start_db_sizer, 0, wx.ALL, 20)
    self.get_db_basedir = gctr.TextButtonCtrl(self,
                                              name='basedir',
                                              label='DB Base Directory',
                                              label_style='bold',
                                              label_size=(150, -1),
                                              big_button_size=(130, -1),
                                              value=os.path.join(self.params.output_folder, 'MySql')
                                              )
    self.start_db_sizer2.Add(self.get_db_basedir)
    self.vsiz.Add(self.start_db_sizer2, 0, wx.ALL, 40)
    self.get_db_root_psswd = gctr.TextButtonCtrl(self,
                                                 name='db_root_password',
                                                 label='DB Root Password',
                                                 label_style='bold',
                                                 label_size=(150, -1),
                                                 text_style=wx.TE_PASSWORD,
                                                )

    self.start_db_sizer3.Add(self.get_db_root_psswd)
    self.start_db_sizer3.Add(-1, -1, proportion=1)
    self.start_db_cancel_btn = wx.Button(self, label="Cancel", id=wx.ID_CANCEL)
    self.start_db_OK_btn = wx.Button(self, label="OK", id=wx.ID_OK)
    self.start_db_sizer3.Add(self.start_db_cancel_btn)
    self.start_db_sizer3.Add(self.start_db_OK_btn)
    self.vsiz.Add(self.start_db_sizer3, 0, wx.ALL, 60)
    self.main_sizer.Add(self.start_db_sizer, flag=wx.EXPAND | wx.ALL, border=10)
    self.main_sizer.Add(self.start_db_sizer2, flag=wx.EXPAND | wx.ALL, border=10)
    self.main_sizer.Add(self.start_db_sizer3, flag=wx.EXPAND | wx.ALL, border=10)

    self.Fit()
    self.Center()
    self.SetTitle('Start Database')

class LCLSFacilityOptions(BaseDialog):
  ''' Options settings specific to LCLS'''
  def __init__(self, parent, params,
               label_style='bold',
               content_style='normal',
               *args, **kwargs):

    self.params = params
    BaseDialog.__init__(self, parent, label_style=label_style,
                        content_style=content_style, *args, **kwargs)

    self.main_sizer = wx.BoxSizer(wx.VERTICAL)

    self.chk_use_ffb = wx.CheckBox(self,
                                   label='Use ffb (fast feedback) file system. Active experiment only, on hiprio or prio queues')
    self.chk_use_ffb.SetValue(params.facility.lcls.use_ffb)

    self.chk_dump_shots = wx.CheckBox(self,
                                      label='Dump all images to disk. Useful for tuning spotfinding and indexing parameters')
    self.chk_dump_shots.SetValue(params.facility.lcls.dump_shots)

    self.chk_enforce80 = wx.CheckBox(self,
                                     label='Require stream 80 (FEE spectrometer) before processing')
    self.chk_enforce80.SetValue(params.facility.lcls.web.enforce80)


    self.chk_enforce81 = wx.CheckBox(self,
                                     label='Require stream 81 (FEE spectrometer) before processing')
    self.chk_enforce81.SetValue(params.facility.lcls.web.enforce81)

    self.main_sizer.Add(self.chk_use_ffb, flag=wx.ALL, border=10)
    self.main_sizer.Add(self.chk_dump_shots, flag=wx.ALL, border=10)
    self.main_sizer.Add(self.chk_enforce80, flag=wx.ALL, border=10)
    self.main_sizer.Add(self.chk_enforce81, flag=wx.ALL, border=10)
    self.SetSizer(self.main_sizer)

    # Dialog control
    dialog_box = self.CreateSeparatedButtonSizer(wx.OK | wx.CANCEL)
    self.main_sizer.Add(dialog_box,
                        flag=wx.EXPAND | wx.ALL,
                        border=10)

    self.SetTitle('LCLS Settings')

    self.Bind(wx.EVT_BUTTON, self.onOK, id=wx.ID_OK)

  def onOK(self, e):
    self.params.facility.lcls.use_ffb = bool(self.chk_use_ffb.GetValue())
    self.params.facility.lcls.dump_shots = bool(self.chk_dump_shots.GetValue())
    self.params.facility.lcls.web.enforce80 = bool(self.chk_enforce80.GetValue())
    self.params.facility.lcls.web.enforce81 = bool(self.chk_enforce81.GetValue())
    e.Skip()

class StandaloneOptions(BaseDialog):
  ''' Options settings specific to standalone GUI '''
  def __init__(self, parent, params,
               label_style='bold',
               content_style='normal',
               *args, **kwargs):

    self.params = params
    BaseDialog.__init__(self, parent, label_style=label_style,
                        content_style=content_style, *args, **kwargs)

    self.main_sizer = wx.BoxSizer(wx.VERTICAL)

    # Output folder text control w/ Browse / magnifying glass button
    if self.params.facility.standalone.data_dir is None:
      current_folder = os.path.abspath(os.curdir)
    else:
      current_folder = self.params.facility.standalone.data_dir
    self.data_dir = gctr.TextButtonCtrl(self,
                                        name='data_dir',
                                        label='Folder to monitor',
                                        label_style='bold',
                                        label_size=(300, -1),
                                        big_button=True,
                                        big_button_label='Browse...',
                                        big_button_size=(120, -1),
                                        value=current_folder)
    self.main_sizer.Add(self.data_dir,
                        flag=wx.EXPAND | wx.ALL,
                        border=10)

    self.SetSizer(self.main_sizer)

    # Raw image options
    self.monitor_for = gctr.RadioCtrl(self,
                                      name='monitor_for',
                                      label='Monitor for',
                                      label_style='bold',
                                      label_size=(-1, -1),
                                      direction='horizontal',
                                      items={'files':'files',
                                            'folders':'folders'})
    getattr(self.monitor_for, self.params.facility.standalone.monitor_for).SetValue(1)

    self.main_sizer.Add(self.monitor_for, flag=wx.EXPAND | wx.ALL, border=10)

    self.folders_options = gctr.RadioCtrl(self,
                                          name='folders_options',
                                          label='Run complete criteria',
                                          label_style='bold',
                                          label_size=(-1, -1),
                                          direction='horizontal',
                                          items={'status_file':'Status file',
                                            'n_files':'Number of files'})
    getattr(self.folders_options, self.params.facility.standalone.folders.method).SetValue(1)

    self.main_sizer.Add(self.folders_options, flag=wx.EXPAND | wx.ALL, border=10)

    self.n_files_needed = gctr.TextButtonCtrl(self,
                                              name='n_files_needed',
                                              label='Number of files per run',
                                              label_style='normal',
                                              label_size=(-1, -1),
                                              value=str(self.params.facility.standalone.folders.n_files_needed))
    self.main_sizer.Add(self.n_files_needed, flag=wx.EXPAND | wx.ALL, border=10)

    self.last_modified = gctr.TextButtonCtrl(self,
                                             name='last_modified',
                                             label='Minimum time since last modified\n(in seconds)',
                                             label_style='normal',
                                             label_size=(-1, -1),
                                             value=str(self.params.facility.standalone.files.last_modified))
    self.main_sizer.Add(self.last_modified, flag=wx.EXPAND | wx.ALL, border=10)

    self.minimum_file_size = gctr.TextButtonCtrl(self,
                                                 name='minimum_file_size',
                                                 label='Minimum file size\n(in bytes)',
                                                 label_style='normal',
                                                 label_size=(-1, -1),
                                                 value=str(self.params.facility.standalone.files.minimum_file_size))
    self.main_sizer.Add(self.minimum_file_size, flag=wx.EXPAND | wx.ALL, border=10)

    # File matching template control
    if self.params.facility.standalone.template is None:
      self.params.facility.standalone.template = ''
    self.template = gctr.TextButtonCtrl(self,
                                        name='template',
                                        label='File matching template\n(example *.h5)',
                                        label_style='bold',
                                        label_size=(300, -1),
                                        value=self.params.facility.standalone.template)
    self.main_sizer.Add(self.template,
                        flag=wx.EXPAND | wx.ALL,
                        border=10)

    # Composite check
    self.chk_composite = wx.CheckBox(self,
                                   label='Files are composite (like HDF5, files are submitted as individual runs.\nOtherwise, groups of files are submitted as single runs)')
    self.chk_composite.SetValue(params.facility.standalone.composite_files)
    self.main_sizer.Add(self.chk_composite,
                        flag=wx.EXPAND | wx.ALL,
                        border=10)

    self.SetTitle('Standalone settings')

    # Dialog control
    dialog_box = self.CreateSeparatedButtonSizer(wx.OK | wx.CANCEL)
    self.main_sizer.Add(dialog_box,
                        flag=wx.EXPAND | wx.ALL,
                        border=10)

    self.Bind(wx.EVT_BUTTON, self.onOK, id=wx.ID_OK)
    self.Bind(wx.EVT_BUTTON, self.onBrowse, id=self.data_dir.btn_big.GetId())
    self.Bind(wx.EVT_RADIOBUTTON, self.onOptionsChanged, self.monitor_for.files)
    self.Bind(wx.EVT_RADIOBUTTON, self.onOptionsChanged, self.monitor_for.folders)
    self.Bind(wx.EVT_RADIOBUTTON, self.onOptionsChanged, self.folders_options.status_file)
    self.Bind(wx.EVT_RADIOBUTTON, self.onOptionsChanged, self.folders_options.n_files)
    self.Bind(wx.EVT_CHECKBOX, self.onOptionsChanged, self.chk_composite)
    self.update_options()

  def onOK(self, e):
    self.params.facility.standalone.data_dir = self.data_dir.ctr.GetValue()
    if self.monitor_for.files.GetValue():
      self.params.facility.standalone.monitor_for = 'files'
      self.params.facility.standalone.files.last_modified = float(self.last_modified.ctr.GetValue())
      self.params.facility.standalone.files.minimum_file_size = int(self.minimum_file_size.ctr.GetValue())
    else:
      self.params.facility.standalone.monitor_for = 'folders'
    if self.folders_options.status_file.GetValue():
      self.params.facility.standalone.folders.method = 'status_file'
    elif self.folders_options.n_files.GetValue():
      self.params.facility.standalone.folders.method = 'n_files'
      self.params.facility.standalone.folders.n_files_needed = int(self.n_files_needed.ctr.GetValue())
    self.params.facility.standalone.template = self.template.ctr.GetValue()
    self.params.facility.standalone.composite_files = self.chk_composite.GetValue()
    e.Skip()

  def onBrowse(self, e):
    dlg = wx.DirDialog(self, "Choose the input directory:",
                       style=wx.DD_DEFAULT_STYLE)

    if dlg.ShowModal() == wx.ID_OK:
      self.data_dir.ctr.SetValue(dlg.GetPath())
    dlg.Destroy()

  def onOptionsChanged(self, e):
    self.update_options()

  def update_options(self):
    if self.monitor_for.files.GetValue():
      self.folders_options.Disable()
      self.n_files_needed.Disable()
      self.last_modified.Enable()
      self.minimum_file_size.Enable()
    else:
      self.folders_options.Enable()
      if self.folders_options.status_file.GetValue():
        self.n_files_needed.Disable()
      else:
        self.n_files_needed.Enable()
      self.last_modified.Disable()
      self.minimum_file_size.Disable()

class AdvancedSettingsDialog(BaseDialog):
  ''' Advanced settings for the cctbx.xfel front end '''
  def __init__(self, parent, params,
               label_style='bold',
               content_style='normal',
               *args, **kwargs):

    self.params = params
    BaseDialog.__init__(self, parent, label_style=label_style,
                        content_style=content_style, *args, **kwargs)

    # Multiprocessing settings
    mp_box = wx.StaticBox(self, label='Multiprocessing Options')
    self.mp_sizer = wx.StaticBoxSizer(mp_box, wx.VERTICAL)

    choices = ['local', 'lsf', 'slurm', 'shifter', 'sge', 'pbs', 'htcondor', 'custom']
    self.mp_option = gctr.ChoiceCtrl(self,
                                     name='mp_option',
                                     label='Multiprocessing:',
                                     label_size=(200, -1),
                                     label_style='bold',
                                     choices=choices)
    self.mp_sizer.Add(self.mp_option, flag=wx.EXPAND | wx.ALL, border=10)
    try:
      self.mp_option.ctr.SetSelection(choices.index(params.mp.method))
    except ValueError:
      pass
    self.Bind(wx.EVT_CHOICE, self.onMultiprocessingChoice, self.mp_option.ctr)

    # Queue
    queues = ['psanaq', 'psanaq', 'psdebugq','psanaidleq', 'psnehhiprioq',
              'psnehprioq', 'psnehq', 'psfehhiprioq', 'psfehprioq', 'psfehq']
    self.queue_choice = gctr.ChoiceCtrl(self,
                                        name='queue',
                                        label='Queue:',
                                        label_size=(200, -1),
                                        label_style='bold',
                                        choices=queues)
    self.Bind(wx.EVT_CHOICE, self.onQueueChoice, self.queue_choice.ctr)
    self.mp_sizer.Add(self.queue_choice, flag=wx.EXPAND | wx.ALL, border=10)
    try:
      self.queue_choice.ctr.SetSelection(queues.index(params.mp.queue))
    except ValueError:
      pass


    self.queue_text = gctr.TextButtonCtrl(self,
                                          name='queue',
                                          label='Queue:',
                                          label_style='bold',
                                          label_size=(200, -1),
                                          value=self.params.mp.queue \
                                                if params.mp.queue is not None else '')
    self.mp_sizer.Add(self.queue_text, flag=wx.EXPAND | wx.ALL, border=10)

    self.nproc = gctr.SpinCtrl(self,
                               name='nproc',
                               label='Total number of processors:',
                               label_size=(240, -1),
                               label_style='normal',
                               ctrl_size=(150, -1),
                               ctrl_value='%d'%params.mp.nproc,
                               ctrl_min=1,
                               ctrl_max=1000)
    self.mp_sizer.Add(self.nproc, flag=wx.EXPAND | wx.ALL, border=10)

    self.nnodes = gctr.SpinCtrl(self,
                                name='nnodes',
                                label='Total number of nodes:',
                                label_size=(150, -1),
                                label_style='normal',
                                ctrl_size=(100, -1),
                                ctrl_value='%d'%params.mp.nnodes,
                                ctrl_min=1,
                                ctrl_max=1000)
    self.mp_sizer.Add(self.nnodes, flag=wx.EXPAND | wx.ALL, border=10)

    self.nppn_box = gctr.CtrlBase(self)
    nppn_txt = wx.StaticText(self.nppn_box, label="Number of processors per node:")
    self.chk_auto_nproc_per_node = wx.CheckBox(self.nppn_box, label='Auto')
    self.chk_auto_nproc_per_node.SetValue(params.mp.nproc_per_node is None)
    self.nproc_per_node = gctr.SpinCtrl(self.nppn_box,
                                        name='nproc_per_node',
                                        ctrl_value='%d'%params.mp.nproc_per_node if params.mp.nproc_per_node else 1,
                                        ctrl_min = 1, ctrl_max = 1000, label_size=(-1,-1), ctrl_size=(150,-1))
    if not params.mp.nproc_per_node: self.nproc_per_node.Disable()

    nppn_sizer = wx.FlexGridSizer(1, 3, 0, 10)
    nppn_sizer.Add(nppn_txt, flag=wx.ALL, border=10)
    nppn_sizer.Add(self.chk_auto_nproc_per_node, flag=wx.ALL, border=10)
    nppn_sizer.Add(self.nproc_per_node, flag=wx.EXPAND | wx.ALL, border=10)
    self.nppn_box.SetSizer(nppn_sizer)
    self.mp_sizer.Add(self.nppn_box, flag=wx.EXPAND | wx.RIGHT | wx.TOP | wx.BOTTOM, border=10)

    self.wall_time = gctr.SpinCtrl(self,
                                   name='wall_time',
                                   label='Max Walltime (mins):',
                                   label_size=(240, -1),
                                   label_style='normal',
                                   ctrl_size=(150, -1),
                                   ctrl_value='%d'%params.mp.wall_time if params.mp.wall_time is not None else 1,
                                   ctrl_min=1,
                                   ctrl_max=2880)
    self.mp_sizer.Add(self.wall_time, flag=wx.EXPAND | wx.ALL, border=10)

    self.mpi_command = gctr.TextButtonCtrl(self,
                                           name='mpi_command',
                                           label='MPI command:',
                                           label_style='bold',
                                           label_size=(200, -1),
                                           value=self.params.mp.mpi_command)
    self.mp_sizer.Add(self.mpi_command, flag=wx.EXPAND | wx.ALL, border=10)

    self.env_script = gctr.TextButtonCtrl(self,
                                          name='env_script',
                                          label='Environment setup script:',
                                          label_style='bold',
                                          label_size=(200, -1),
                                          value=params.mp.env_script[0] \
                                                if len(params.mp.env_script) > 0 and \
                                                params.mp.env_script[0] is not None else '')
    self.mp_sizer.Add(self.env_script, flag=wx.EXPAND | wx.ALL, border=10)

    self.phenix_script = gctr.TextButtonCtrl(self,
                                             name='phenix_script',
                                             label='Phenix setup script:',
                                             label_style='bold',
                                             label_size=(200, -1),
                                             value=params.mp.phenix_script[0] \
                                                   if len(params.mp.phenix_script) > 0 and \
                                                   params.mp.phenix_script[0] is not None else '')
    self.mp_sizer.Add(self.phenix_script, flag=wx.EXPAND | wx.ALL, border=10)

    self.htcondor_executable_path = gctr.TextButtonCtrl(self,
                                                        name='htcondor_executable_path',
                                                        label='MPI executable path (mp2script or openmpiscript):',
                                                        label_style='bold',
                                                        label_size=(200, -1),
                                                        value=params.mp.htcondor.executable_path \
                                                        if params.mp.htcondor.executable_path is not None else '')
    self.mp_sizer.Add(self.htcondor_executable_path, flag=wx.EXPAND | wx.ALL, border=10)

    self.htcondor_filesystemdomain = gctr.TextButtonCtrl(self,
                                                        name='htcondor_filesystemdomain',
                                                        label='Shared filesystem domain:',
                                                        label_style='bold',
                                                        label_size=(200, -1),
                                                        value=params.mp.htcondor.filesystemdomain \
                                                        if params.mp.htcondor.filesystemdomain is not None else '')
    self.mp_sizer.Add(self.htcondor_filesystemdomain, flag=wx.EXPAND | wx.ALL, border=10)

    self.main_sizer.Add(self.mp_sizer, flag=wx.EXPAND | wx.ALL, border=10)

    # Different nnodes per job type. Implemented for shifter and slurm

    self.jobtype_nnodes_box = wx.StaticBox(self, label='Nodes per job')
    self.jobtype_nnodes_sizer = wx.StaticBoxSizer(self.jobtype_nnodes_box, wx.HORIZONTAL)

    self.nnodes_index = gctr.SpinCtrl(self,
                                      name='nnodes_index',
                                      label='Indexing:',
                                      label_size=(60, -1),
                                      label_style='normal',
                                      ctrl_size=(150, -1),
                                      ctrl_value='%d'%(params.mp.nnodes_index or 1),
                                      ctrl_min=1,
                                      ctrl_max=1000)
    self.jobtype_nnodes_sizer.Add(self.nnodes_index, flag=wx.EXPAND | wx.ALL, border=10)

    self.nnodes_tder = gctr.SpinCtrl(self,
                                      name='nnodes_tder',
                                      label='TDER:',
                                      label_size=(60, -1),
                                      label_style='normal',
                                      ctrl_size=(150, -1),
                                      ctrl_value='%d'%(params.mp.nnodes_tder or 1),
                                      ctrl_min=1,
                                      ctrl_max=1000)
    self.nnodes_tder.SetToolTip('Time Dependent Ensemble Refinement')
    self.jobtype_nnodes_sizer.Add(self.nnodes_tder, flag=wx.EXPAND | wx.ALL, border=10)

    self.nnodes_scale = gctr.SpinCtrl(self,
                                      name='nnodes_scale',
                                      label='Scaling:',
                                      label_size=(60, -1),
                                      label_style='normal',
                                      ctrl_size=(150, -1),
                                      ctrl_value='%d'%(params.mp.nnodes_scale or 1),
                                      ctrl_min=1,
                                      ctrl_max=1000)
    self.jobtype_nnodes_sizer.Add(self.nnodes_scale, flag=wx.EXPAND | wx.ALL, border=10)

    self.nnodes_merge = gctr.SpinCtrl(self,
                                      name='nnodes_merge',
                                      label='Merging:',
                                      label_size=(60, -1),
                                      label_style='normal',
                                      ctrl_size=(150, -1),
                                      ctrl_value='%d'%(params.mp.nnodes_merge or 1),
                                      ctrl_min=1,
                                      ctrl_max=1000)
    self.jobtype_nnodes_sizer.Add(self.nnodes_merge, flag=wx.EXPAND | wx.ALL, border=10)

    self.mp_sizer.Add(self.jobtype_nnodes_sizer, flag=wx.EXPAND | wx.ALL, border=10)

    self.extra_box = gctr.CtrlBase(self)
    extra_txt = wx.StaticText(self.extra_box, label="Extra submission arguments")
    self.extra_options = gctr.RichTextCtrl(self.extra_box,
                                           name='extra_options',
                                           size=(-1, 60),
                                           style=wx.VSCROLL,
                                           value="\n".join(self.params.mp.extra_options)
                                                 if any(self.params.mp.extra_options) else "")
    extra_sizer = wx.FlexGridSizer(1, 2, 0, 10)
    extra_sizer.Add(extra_txt, flag=wx.ALL, border=10)
    extra_sizer.Add(self.extra_options, flag=wx.EXPAND | wx.ALL, border=10)
    extra_sizer.AddGrowableCol(1)
    self.extra_box.SetSizer(extra_sizer)
    self.mp_sizer.Add(self.extra_box, flag=wx.EXPAND | wx.ALL, border=10)

    # Shifter-specific settings

    self.shifter_image = gctr.TextButtonCtrl(self,
                                             name='shifter_image',
                                             label='Shifter image:',
                                             label_style='bold',
                                             label_size=(200, -1),
                                             value=params.mp.shifter.shifter_image \
                                             if params.mp.shifter.shifter_image is not None else '')
    self.mp_sizer.Add(self.shifter_image, flag=wx.EXPAND | wx.ALL, border=10)

    self.shifter_srun_template = gctr.TextButtonCtrl(self,
                                                     name='shifter_srun_template',
                                                     label='Srun Script Template Path:',
                                                     label_style='bold',
                                                     label_size=(200, -1),
                                                     value=params.mp.shifter.srun_script_template \
                                                     if params.mp.shifter.srun_script_template is not None else '')
    self.mp_sizer.Add(self.shifter_srun_template, flag=wx.EXPAND | wx.ALL, border=10)

    self.shifter_sbatch_template = gctr.TextButtonCtrl(self,
                                                       name='shifter_sbatch_template',
                                                       label='Sbatch Script Template Path:',
                                                       label_style='bold',
                                                       label_size=(200, -1),
                                                       value=params.mp.shifter.sbatch_script_template \
                                                       if params.mp.shifter.sbatch_script_template is not None else '')
    self.mp_sizer.Add(self.shifter_sbatch_template, flag=wx.EXPAND | wx.ALL, border=10)

    self.shifter_jobname = gctr.TextButtonCtrl(self,
                                               name='shifter_jobname',
                                               label='Job Name:',
                                               label_style='bold',
                                               label_size=(200, -1),
                                               value=params.mp.shifter.jobname \
                                               if params.mp.shifter.jobname is not None else '')
    self.mp_sizer.Add(self.shifter_jobname, flag=wx.EXPAND | wx.ALL, border=10)

    self.shifter_project = gctr.TextButtonCtrl(self,
                                               name='shifter_project',
                                               label='NERSC Project (-A):',
                                               label_style='bold',
                                               label_size=(200, -1),
                                               value=params.mp.shifter.project \
                                               if params.mp.shifter.project is not None else '')
    self.mp_sizer.Add(self.shifter_project, flag=wx.EXPAND | wx.ALL, border=10)

    self.shifter_reservation = gctr.TextButtonCtrl(self,
                                                   name='shifter_reservation',
                                                   label='NERSC Reservation:',
                                                   label_style='bold',
                                                   label_size=(200, -1),
                                                   value=params.mp.shifter.reservation \
                                                   if params.mp.shifter.reservation is not None else '')
    self.mp_sizer.Add(self.shifter_reservation, flag=wx.EXPAND | wx.ALL, border=10)

    self.shifter_constraint = gctr.TextButtonCtrl(self,
                                                  name='shifter_constraint',
                                                  label='Job Constraint:',
                                                  label_style='bold',
                                                  label_size=(200, -1),
                                                  value=params.mp.shifter.constraint \
                                                  if params.mp.shifter.constraint is not None else '')
    self.mp_sizer.Add(self.shifter_constraint, flag=wx.EXPAND | wx.ALL, border=10)

    self.staging_methods = ["DataWarp", "None"]
    self.staging_descriptions = [
        'Stage logs to the DataWarp burst buffer. WARNING: Only when writing to Cori cscratch. Otherwise logs will be lost.',
        'Write logs directly to disk.']
    self.log_staging = gctr.ChoiceCtrl(self,
                                       name='staging',
                                       label="Log staging",
                                       label_size=(240, -1),
                                       label_style='bold',
                                       ctrl_size=(-1, -1),
                                       choices=self.staging_methods)
    self.log_staging.ctr.SetSelection(
        self.staging_methods.index(params.mp.shifter.staging))
    self.Bind(wx.EVT_CHOICE, self.onStagingChoice, self.log_staging.ctr)
    self.mp_sizer.Add(self.log_staging, flag=wx.EXPAND | wx.ALL, border=10)
    self.staging_help = wx.StaticText(self, label=self.staging_descriptions[self.log_staging.ctr.GetSelection()], size=(600,30))
    self.staging_help.Wrap(600)
    self.mp_sizer.Add(self.staging_help, flag=wx.EXPAND | wx.ALL, border=10)


    # Data analysis settings
    analysis_box = wx.StaticBox(self, label='Data Analysis Options')
    self.analysis_sizer = wx.StaticBoxSizer(analysis_box, wx.VERTICAL)

    # Processing back-ends
    self.dispatchers_sizer = wx.BoxSizer(wx.HORIZONTAL)
    self.back_ends = ['cctbx.xfel', 'Small cell', 'custom']
    self.dispatchers = ['cctbx.xfel.process', 'cctbx.xfel.small_cell_process', 'custom']
    # Legacy dispatchers disabled 12/14/22
    #self.back_ends = ['cctbx.xfel (LCLS mode)', 'cctbx.xfel (standalone mode)', 'Ha14', 'Small cell', 'custom']
    #self.dispatchers = ['cctbx.xfel.xtc_process', 'cctbx.xfel.process', 'cxi.xtc_process', 'cctbx.xfel.small_cell_process', 'custom']
    self.dispatcher_descriptions = [
      #'Process the data according to Brewster 2018, using DIALS for indexing, refinement and integration, with stills-specific defaults. Converts XTC into CBF in memory and optionally provides dumping of CBFs.',
      'Process the data according to Brewster 2018, using DIALS for indexing, refinement and integration, with stills-specific defaults. Reads image files directly.',
      #'Process the data according to Hattne 2014, using LABELIT for initial indexing and stills-specific refinement and integration code implemented in the package cctbx.rstbx.',
      'Process the data according to Brewster 2015, using small cell for initial indexing and using DIALS for refinement and integration, with stills-specific defaults.',
      'Provide a custom program. See authors for details.']

    self.back_end = gctr.ChoiceCtrl(self,
                                    name='back_end',
                                    label='Processing back end:',
                                    label_size=(240, -1),
                                    label_style='bold',
                                    ctrl_size=(-1, -1),
                                    choices=self.back_ends)
    self.Bind(wx.EVT_CHOICE, self.onBackendChoice, self.back_end.ctr)
    self.dispatchers_sizer.Add(self.back_end, flag=wx.ALIGN_LEFT)

    self.custom_dispatcher = gctr.PanelTextCtrl(self,
                                                ctrl_size=(300, -1),
                                                value="")
    self.dispatchers_sizer.Add(self.custom_dispatcher, flag=wx.EXPAND | wx.ALL)

    try:
      self.back_end.ctr.SetSelection(self.dispatchers.index(params.dispatcher))
      self.custom_dispatcher.Hide()
    except ValueError:
      self.back_end.ctr.SetSelection(len(self.dispatchers)-1)
      self.custom_dispatcher.ctr.SetValue(params.dispatcher)

    self.analysis_sizer.Add(self.dispatchers_sizer, flag=wx.EXPAND | wx.ALL, border=10)

    self.dispatcher_help = wx.StaticText(self, label=self.dispatcher_descriptions[self.back_end.ctr.GetSelection()], size=(600,80))
    self.dispatcher_help.Wrap(600)
    self.analysis_sizer.Add(self.dispatcher_help, flag=wx.EXPAND | wx.ALL, border=10)

    self.main_sizer.Add(self.analysis_sizer, flag=wx.EXPAND | wx.ALL, border=10)

    # Dialog control
    dialog_box = self.CreateSeparatedButtonSizer(wx.OK | wx.CANCEL)
    self.main_sizer.Add(dialog_box,
                        flag=wx.EXPAND | wx.ALL,
                        border=10)

    self.SetTitle('Advanced Settings')

    self.Bind(wx.EVT_CHECKBOX, self.onChkNppnAuto, self.chk_auto_nproc_per_node)
    self.Bind(wx.EVT_BUTTON, self.onOK, id=wx.ID_OK)

    self.updateMultiprocessing()

  def onChkNppnAuto(self, e):
    if self.chk_auto_nproc_per_node.GetValue():
      self.nproc_per_node.Disable()
    else:
      self.nproc_per_node.Enable()

  def onMultiprocessingChoice(self, e):
    self.updateMultiprocessing()

  def updateMultiprocessing(self):
    if self.mp_option.ctr.GetStringSelection() == 'local':
      self.queue_choice.Hide()
      self.queue_text.Show()
      self.nnodes.Hide()
      self.nproc.Show()
      self.nppn_box.Hide()
      self.wall_time.Hide()
      self.mpi_command.Hide()
      self.env_script.Hide()
      self.phenix_script.Hide()
      self.htcondor_executable_path.Hide()
      self.htcondor_filesystemdomain.Hide()
      self.jobtype_nnodes_box.Hide()
      self.nnodes_index.Hide()
      self.nnodes_tder.Hide()
      self.nnodes_scale.Hide()
      self.nnodes_merge.Hide()
      self.extra_box.Hide()
      self.shifter_image.Hide()
      self.shifter_srun_template.Hide()
      self.shifter_sbatch_template.Hide()
      self.shifter_jobname.Hide()
      self.shifter_project.Hide()
      self.shifter_reservation.Hide()
      self.shifter_constraint.Hide()
      self.log_staging.Hide()
      self.staging_help.Hide()
    elif self.mp_option.ctr.GetStringSelection() == 'shifter':
      self.queue_choice.Hide()
      self.queue_text.Show()
      self.nproc.Hide()
      self.nnodes.Show()
      self.nppn_box.Show()
      self.wall_time.Show()
      self.mpi_command.Hide()
      self.env_script.Hide()
      self.phenix_script.Hide()
      self.htcondor_executable_path.Hide()
      self.htcondor_filesystemdomain.Hide()
      self.nnodes_index.Show()
      self.nnodes_tder.Show()
      self.nnodes_scale.Show()
      self.nnodes_merge.Show()
      self.extra_box.Show()
      self.jobtype_nnodes_box.Show()
      self.shifter_image.Show()
      self.shifter_srun_template.Show()
      self.shifter_sbatch_template.Show()
      self.shifter_jobname.Show()
      self.shifter_project.Show()
      self.shifter_reservation.Show()
      self.shifter_constraint.Show()
      self.log_staging.Show()
      self.staging_help.Show()
    elif self.mp_option.ctr.GetStringSelection() == 'htcondor':
      self.queue_choice.Hide()
      self.queue_text.Show()
      self.nproc.Show()
      self.nnodes.Hide()
      self.nppn_box.Hide()
      self.wall_time.Hide()
      self.mpi_command.Hide()
      self.env_script.Show()
      self.phenix_script.Show()
      self.htcondor_executable_path.Show()
      self.htcondor_filesystemdomain.Show()
      self.nnodes_index.Hide()
      self.nnodes_tder.Hide()
      self.nnodes_scale.Hide()
      self.nnodes_merge.Hide()
      self.extra_box.Hide()
      self.jobtype_nnodes_box.Hide()
      self.shifter_image.Hide()
      self.shifter_srun_template.Hide()
      self.shifter_sbatch_template.Hide()
      self.shifter_jobname.Hide()
      self.shifter_project.Hide()
      self.shifter_reservation.Hide()
      self.shifter_constraint.Hide()
      self.log_staging.Hide()
      self.staging_help.Hide()
    elif self.mp_option.ctr.GetStringSelection() in ['slurm','pbs']:
      self.queue_choice.Hide()
      self.queue_text.Show()
      self.nproc.Hide()
      self.nnodes.Hide()
      self.nppn_box.Show()
      self.wall_time.Hide()
      self.mpi_command.Show()
      self.env_script.Show()
      self.phenix_script.Show()
      self.htcondor_executable_path.Hide()
      self.htcondor_filesystemdomain.Hide()
      self.nnodes_index.Show()
      self.nnodes_tder.Show()
      self.nnodes_scale.Show()
      self.nnodes_merge.Show()
      self.extra_box.Show()
      self.jobtype_nnodes_box.Show()
      self.shifter_image.Hide()
      self.shifter_srun_template.Hide()
      self.shifter_sbatch_template.Hide()
      self.shifter_jobname.Hide()
      self.shifter_project.Hide()
      self.shifter_reservation.Hide()
      self.shifter_constraint.Hide()
      self.log_staging.Hide()
      self.staging_help.Hide()
    else :
      if self.params.facility.name == 'lcls' and self.mp_option.ctr.GetStringSelection() == 'lsf':
        self.queue_choice.Show()
        self.queue_text.Hide()
      else:
        self.queue_choice.Hide()
        self.queue_text.Show()
      self.nproc.Show()
      self.nnodes.Hide()
      self.nppn_box.Hide()
      self.wall_time.Hide()
      self.mpi_command.Show()
      self.env_script.Show()
      self.phenix_script.Show()
      self.htcondor_executable_path.Hide()
      self.htcondor_filesystemdomain.Hide()
      self.nnodes_index.Hide()
      self.nnodes_tder.Hide()
      self.nnodes_scale.Hide()
      self.nnodes_merge.Hide()
      self.extra_box.Show()
      self.jobtype_nnodes_box.Hide()
      self.shifter_image.Hide()
      self.shifter_srun_template.Hide()
      self.shifter_sbatch_template.Hide()
      self.shifter_jobname.Hide()
      self.shifter_project.Hide()
      self.shifter_reservation.Hide()
      self.shifter_constraint.Hide()
      self.log_staging.Hide()
      self.staging_help.Hide()

    self.Fit()

  def onQueueChoice(self, e):
    queue = self.queue_choice.ctr.GetString(self.queue_choice.ctr.GetSelection())
    if 'neh' in queue or 'feh' in queue:
      self.nproc.ctr.SetValue(16)
      self.nproc.ctr.SetIncrement(16)
    elif 'psana' in queue or 'debug' in queue:
      self.nproc.ctr.SetValue(12)
      self.nproc.ctr.SetIncrement(12)
    else:
      self.nproc.ctr.SetValue(1)
      self.nproc.ctr.SetIncrement(1)

  def onStagingChoice(self, e):
    self.params.mp.shifter.staging = self.staging_methods[self.log_staging.ctr.GetSelection()]
    self.staging_help.SetLabel(self.staging_descriptions[self.log_staging.ctr.GetSelection()])
    self.staging_help.Wrap(600)


  def onBackendChoice(self, e):
    self.params.dispatcher = self.dispatchers[self.back_end.ctr.GetSelection()]
    self.dispatcher_help.SetLabel(self.dispatcher_descriptions[self.back_end.ctr.GetSelection()])
    self.dispatcher_help.Wrap(600)
    if self.params.dispatcher == 'custom':
      self.custom_dispatcher.Show()
      self.Layout()
    else:
      self.custom_dispatcher.Hide()
      self.Layout()


  def onOK(self, e):
    self.params.dispatcher = self.dispatchers[self.back_end.ctr.GetSelection()]

    if self.params.dispatcher == 'custom':
      self.params.dispatcher = self.custom_dispatcher.ctr.GetValue()

    self.params.mp.method = self.mp_option.ctr.GetStringSelection()
    self.params.mp.nproc = int(self.nproc.ctr.GetValue())

    if self.params.facility.name == 'lcls' and self.params.mp.method == "lsf":
      self.params.mp.queue = self.queue_choice.ctr.GetStringSelection()
    else:
      if self.chk_auto_nproc_per_node.GetValue():
        self.params.mp.nproc_per_node = None
      else:
        self.params.mp.nproc_per_node = int(self.nproc_per_node.ctr.GetValue())
      self.params.mp.queue = self.queue_text.ctr.GetValue()
      if self.mp_option.ctr.GetStringSelection() in ['shifter', 'slurm', 'pbs']:
        self.params.mp.nnodes_index = int(self.nnodes_index.ctr.GetValue())
        self.params.mp.nnodes_tder = int(self.nnodes_tder.ctr.GetValue())
        self.params.mp.nnodes_scale = int(self.nnodes_scale.ctr.GetValue())
        self.params.mp.nnodes_merge = int(self.nnodes_merge.ctr.GetValue())
      if self.mp_option.ctr.GetStringSelection() == 'shifter':
        self.params.mp.nnodes = int(self.nnodes.ctr.GetValue())
        self.params.mp.wall_time = int(self.wall_time.ctr.GetValue())
      else:
        self.params.mp.env_script = [self.env_script.ctr.GetValue()]
        self.params.mp.phenix_script = [self.phenix_script.ctr.GetValue()]
        self.params.mp.nproc = int(self.nproc.ctr.GetValue())

    self.params.mp.mpi_command = self.mpi_command.ctr.GetValue() \
      if len(self.mpi_command.ctr.GetValue()) > 0 else None
    if len(self.extra_options.GetValue()) > 0:
      self.params.mp.extra_options = self.extra_options.GetValue().split('\n')
    else:
      self.params.mp.extra_options = []

    # Copy htcondor settings into the htcondor phil
    self.params.mp.htcondor.executable_path = self.htcondor_executable_path.ctr.GetValue() \
      if len(self.htcondor_executable_path.ctr.GetValue()) > 0 else None
    self.params.mp.htcondor.filesystemdomain = self.htcondor_filesystemdomain.ctr.GetValue() \
      if len(self.htcondor_filesystemdomain.ctr.GetValue()) > 0 else None

    # Copy shfiter settings into the shifter phil
    self.params.mp.shifter.sbatch_script_template = self.shifter_sbatch_template.ctr.GetValue() \
      if len(self.shifter_sbatch_template.ctr.GetValue()) > 0 else None
    self.params.mp.shifter.shifter_image = self.shifter_image.ctr.GetValue() \
      if len(self.shifter_image.ctr.GetValue()) > 0 else None
    self.params.mp.shifter.srun_script_template = self.shifter_srun_template.ctr.GetValue() \
      if len(self.shifter_srun_template.ctr.GetValue()) > 0 else None
    self.params.mp.shifter.jobname=self.shifter_jobname.ctr.GetValue() \
      if len(self.shifter_jobname.ctr.GetValue()) > 0 else None
    self.params.mp.shifter.project=self.shifter_project.ctr.GetValue() \
      if len(self.shifter_project.ctr.GetValue()) > 0 else None
    self.params.mp.shifter.reservation=self.shifter_reservation.ctr.GetValue() \
      if len(self.shifter_reservation.ctr.GetValue()) > 0 else None
    self.params.mp.shifter.constraint =self.shifter_constraint.ctr.GetValue() \
      if len(self.shifter_constraint.ctr.GetValue()) > 0 else None

    e.Skip()


class CalibrationDialog(BaseDialog):
  def __init__(self, parent,
               label_style='bold',
               content_style='normal',
               db=None,
               *args, **kwargs):

    self.parent = parent
    BaseDialog.__init__(self, parent, label_style=label_style,
                        content_style=content_style, *args, **kwargs)

    self.db = db

    # Metrology version name
    self.version_name = gctr.TextButtonCtrl(self,
                                            label='Metrology Version Name:',
                                            label_size=(180, -1),
                                            label_style='bold',
                                            value='cspad')
    self.main_sizer.Add(self.version_name, flag=wx.EXPAND | wx.ALL, border=10)

    # Reflection type and number of images in subset
    self.top_sizer = wx.FlexGridSizer(1, 2, 0, 20)
    self.top_sizer.AddGrowableCol(1, 1)
    choices = ['indexed', 'reindexed strong', 'integrated']
    self.reflections = gctr.ChoiceCtrl(self,
                                       label='Reflections:',
                                       label_size=(100, -1),
                                       label_style='bold',
                                       choices=choices)
    self.n_subset = gctr.SpinCtrl(self,
                                  label='Images in subset:',
                                  label_size=(120, -1),
                                  label_style='normal',
                                  ctrl_value='1000',
                                  ctrl_max=10000,
                                  ctrl_min=10)
    self.top_sizer.Add(self.reflections)
    self.top_sizer.Add(self.n_subset, wx.ALIGN_RIGHT)

    #Trial & runs
    self.trial_sizer = wx.FlexGridSizer(1, 2, 0, 20)
    self.trial_sizer.AddGrowableCol(1, 1)
    trials = [str(i.trial) for i in self.db.get_all_trials()]
    self.trial_number = gctr.ChoiceCtrl(self,
                                        label='Trial:',
                                        label_size=(40, -1),
                                        label_style='normal',
                                        ctrl_size=(200, -1),
                                        choices=trials)
    self.trial_runs = gctr.CheckListCtrl(self,
                                         label='Runs:',
                                         label_size=(40, -1),
                                         label_style='normal',
                                         ctrl_size=(200, -1),
                                         choices=[])
    self.trial_sizer.Add(self.trial_number)
    self.trial_sizer.Add(self.trial_runs, wx.ALIGN_RIGHT)

    #Phil blob
    self.phil_text = gctr.RichTextCtrl(self, size=(550, 300), style=wx.VSCROLL)
    self.phil_path = gctr.TwoButtonCtrl(self,
                                        label='PHIL path:',
                                        label_size=(80, -1),
                                        label_style='normal',
                                        button1=True,
                                        button1_label='Browse...',
                                        button2=True,
                                        button2_label='Default PHIL')

    self.main_sizer.Add(self.top_sizer, flag=wx.EXPAND | wx.ALL, border=10)
    self.main_sizer.Add(self.trial_sizer, flag=wx.EXPAND | wx.ALL, border=10)
    self.main_sizer.Add(self.phil_text, flag=wx.EXPAND | wx.ALL, border=10)
    self.main_sizer.Add(self.phil_path, flag=wx.EXPAND | wx.ALL, border=10)

    self.chk_split_dataset = wx.CheckBox(self,
                                         label='Split dataset into 2 halves (outputs statistics, double runtime, uses 2x number of images')
    self.chk_split_dataset.SetValue(True)

    self.main_sizer.Add(self.chk_split_dataset, flag=wx.ALL, border=10)

    # Dialog control
    dialog_box = self.CreateSeparatedButtonSizer(wx.OK | wx.CANCEL)
    self.main_sizer.Add(dialog_box,
                        flag=wx.EXPAND | wx.ALL,
                        border=10)
    # Bindings
    self.Bind(wx.EVT_CHOICE, self.onTrialChoice,
              id=self.trial_number.ctr.GetId())
    self.Bind(wx.EVT_BUTTON, self.onBrowse, self.phil_path.button1)
    self.Bind(wx.EVT_BUTTON, self.onDefault, self.phil_path.button2)
    self.Bind(wx.EVT_BUTTON, self.onOK, id=wx.ID_OK)
    self.Bind(wx.EVT_BUTTON, self.onCancel, id=wx.ID_CANCEL)

    self.SetTitle('Calibration Settings')
    self.find_runs()

    self.frames_sentinel = None
    self.start_frames_sentinel()

  def start_frames_sentinel(self):
    if self.frames_sentinel is None:
      from xfel.ui.components.xfel_gui_init import FramesSentinel
      self.frames_sentinel = FramesSentinel(self)
    self.frames_sentinel.active = True
    self.frames_sentinel.start()

  def stop_frames_sentinel(self):
    if self.frames_sentinel is not None:
      self.frames_sentinel.active = False
      self.frames_sentinel.join()

  def onOK(self, e):
    from xfel.ui.db import get_run_path
    from xfel.util.mp import get_lsf_submit_command
    from xfel.ui import settings_dir
    from libtbx import easy_run
    import copy
    params = copy.deepcopy(self.parent.params)
    params.mp.nproc = 1

    version_str = self.version_name.ctr.GetValue()
    working_dir = os.path.join(params.output_folder, "metrology", version_str)
    if os.path.exists(working_dir):
      wx.MessageBox('Version name %s already used'%version_str, 'Warning!',
                    wx.ICON_EXCLAMATION)
      return

    self.stop_frames_sentinel()

    runs = [self.db.get_run(run_number=int(r)) for r in self.trial_runs.ctr.GetCheckedStrings()]
    run_ids = [r.id for r in runs]
    command = "cspad.cbf_metrology reflections=%s tag=%s split_dataset=%s n_subset=%d "% (
      self.reflections.ctr.GetStringSelection(), self.version_name.ctr.GetValue(),
      self.chk_split_dataset.GetValue(), self.n_subset.ctr.GetValue())

    phil_file = os.path.join(settings_dir, "cfgs", "%s.phil"%version_str)
    f = open(phil_file, 'w')
    f.write(self.phil_text.GetValue())
    f.close()
    command += phil_file + " "

    trial = self.db.get_trial(trial_number=int(self.trial_number.ctr.GetStringSelection()))
    runs_found = []
    run_paths = []
    for rungroup in trial.rungroups:
      for run in rungroup.runs:
        if run.id in runs_found:
          continue
        if run.id in run_ids:
          run_ids.pop(run_ids.index(run.id))
          runs_found.append(run.id)
          run_paths.append(os.path.join(get_run_path(params.output_folder, trial, rungroup, run), 'out'))
    assert len(run_ids) == 0

    command += " ".join(run_paths)

    submit_path = os.path.join(settings_dir, "%s.sh"%version_str)
    command = str(get_lsf_submit_command(command, submit_path, working_dir, params.mp)()) # comes back as unicode which throws off easy_run
    cwd = os.getcwd()
    os.makedirs(working_dir)
    os.chdir(working_dir)

    print("Submitting metrology refinement. Command:")
    print(command)
    try:
      results = easy_run.fully_buffered(command=command)
      results.show_stdout()
      results.show_stderr()
      results.raise_if_errors()
    except Exception as exc:
      if not "Warning: job being submitted without an AFS token." in str(exc):
        raise exc
    os.chdir(cwd)
    print("Output will be in", working_dir)

    e.Skip()

  def onTrialChoice(self, e):
    self.find_runs()

  def find_runs(self):
    self.trial_runs.ctr.Clear()
    trial = self.db.get_all_trials()[self.trial_number.ctr.GetSelection()]
    runs = [str(i.run) for i in trial.runs]
    if runs:
      self.trial_runs.ctr.InsertItems(items=runs, pos=0)

  def onBrowse(self, e):
    ''' Open dialog for selecting PHIL file '''
    load_dlg = wx.FileDialog(self,
                             message="Load PHIL file",
                             defaultDir=os.curdir,
                             defaultFile="*.phil",
                             wildcard="*.phil",
                             style=wx.FD_OPEN | wx.FD_FILE_MUST_EXIST,
                             )
    if load_dlg.ShowModal() == wx.ID_OK:
      target_file = load_dlg.GetPaths()[0]
      with open(target_file, 'r') as phil_file:
        phil_file_contents = phil_file.read()
      self.phil_text.SetValue(phil_file_contents)
      self.phil_path.ctr.SetValue(target_file)
    load_dlg.Destroy()

  def onDefault(self, e):
    # TODO: Generate default PHIL parameters
    pass

  def onCancel(self, e):
    self.stop_frames_sentinel()
    e.Skip()

class AveragingDialog(BaseDialog):
  def __init__(self, parent, run, params,
               label_style='bold',
               content_style='normal',
               *args, **kwargs):
    self.run = run
    self.params = params

    # Looks for a rungroup to use as a template
    # The averaging job is not assigned a rungroup
    run_rungroups = run.get_rungroups()
    if len(run_rungroups) == 0:
      # If this run has not been included in any rungroups try to use the rungroup
      # with the closest run
      all_rungroups = run.app.get_all_rungroups()
      if len(all_rungroups) == 0:
        self.template_rungroup = None
      else:
        distance = np.zeros(len(all_rungroups))
        for index, rungroup in enumerate(all_rungroups):
          first_run, last_run = rungroup.get_first_and_last_runs()
          distance[index] = min([
            abs(int(first_run.run) - int(run.run)),
            abs(int(last_run.run) - int(run.run))
          ])
        template_rungroup_id = all_rungroups[np.argmin(distance)].rungroup_id
        self.template_rungroup = run.app.get_rungroup(rungroup_id=template_rungroup_id)
    else:
      # If this run has been included in any rungroups - use that
      self.template_rungroup = run_rungroups[-1]

    BaseDialog.__init__(self, parent, label_style=label_style,
                        content_style=content_style, *args, **kwargs)

    # Image Average Options
    self.skip_images = gctr.SpinCtrl(self,
                                   label='Skip Images:',
                                   label_style='bold',
                                   label_size=(150, -1),
                                   ctrl_value=0,
                                   ctrl_min=0,
                                   ctrl_size=(150, -1),
                                   ctrl_max=None)
    self.num_images_type = gctr.RadioCtrl(self,
                                   name='Use All Images',
                                   label='',
                                   label_style='normal',
                                   label_size=(100, -1),
                                   direction='vertical',
                                   items={'all': 'Use all images',
                                          'specify': 'Specify total images'})
    self.num_images = gctr.SpinCtrl(self,
                                   label='Number Images:',
                                   label_style='bold',
                                   label_size=(150, -1),
                                   ctrl_value=0,
                                   ctrl_min=0,
                                   ctrl_size=(150, -1),
                                   ctrl_max=None)
    self.main_sizer.Add(self.skip_images, flag=wx.EXPAND | wx.ALL, border=10)
    self.main_sizer.Add(self.num_images_type, flag=wx.EXPAND | wx.ALL, border=10)
    self.main_sizer.Add(self.num_images, flag=wx.EXPAND | wx.ALL, border=10)
    self.skip_images.SetToolTip('Number of images to skip at the start of the dataset')
    self.num_images.SetToolTip('Maximum number of frames to average.')
    self.Bind(wx.EVT_RADIOBUTTON, self.onAllImages, self.num_images_type.all)
    self.Bind(wx.EVT_RADIOBUTTON, self.onSpecifyImages, self.num_images_type.specify)
    self.num_images.Disable()

    # Dialog control
    dialog_box = self.CreateSeparatedButtonSizer(wx.OK | wx.CANCEL)
    self.main_sizer.Add(dialog_box, flag=wx.EXPAND | wx.ALL, border=10)
    self.Bind(wx.EVT_BUTTON, self.onOK, id=wx.ID_OK)

  def onAllImages(self, e):
    self.num_images.Disable()

  def onSpecifyImages(self, e):
    self.num_images.Enable()

  def onOK(self, e):
    if self.template_rungroup is None:
      wx.MessageBox('Add this run to a rungroup in the Trials tab first!', 'Warning', wx.ICON_EXCLAMATION)
      return

    skip_images = self.skip_images.ctr.GetValue()
    if self.num_images_type.all.GetValue():
      num_images = 0
    else:
      num_images = self.num_images.ctr.GetValue()
    if num_images == 1:
      print("Average Aborted.\nNeed more than one image to average.")
      return
    else:
      from xfel.ui.db.job import AveragingJob
      job = AveragingJob(self.run.app)
      job.run = self.run
      job.rungroup = self.template_rungroup
      job.skip_images = skip_images
      job.num_images = num_images
      job.submit()
      self.Destroy()

class TrialTagSelectionDialog(BaseDialog):
  def __init__(self, parent,
               label_style='bold',
               content_style='normal',
               db=None,
               *args, **kwargs):
    BaseDialog.__init__(self, parent, label_style=label_style,
                        content_style=content_style, *args, **kwargs)
    self.db = db
    self.parent = parent
    self.run_paths = []
    self.tags = []
    self.tag_names = []

    self.trials = db.get_all_trials()
    trial_numbers = ["%d"%trial.trial for trial in self.trials]
    self.trials_ctrl = gctr.ChoiceCtrl(self,
                                       label='Trial number:',
                                       label_size=(120, -1),
                                       label_style='bold',
                                       choices=trial_numbers)
    self.main_sizer.Add(self.trials_ctrl, flag=wx.EXPAND | wx.ALL, border=10)


    self.trial_tags = gctr.CheckListCtrl(self,
                                         label='Tags (optional):',
                                         label_size=(40, -1),
                                         label_style='normal',
                                         ctrl_size=(200, -1),
                                         choices=[])
    self.main_sizer.Add(self.trial_tags, flag=wx.EXPAND | wx.ALL, border=10)

    # Dialog control
    dialog_box = self.CreateSeparatedButtonSizer(wx.OK | wx.CANCEL)
    self.main_sizer.Add(dialog_box,
                        flag=wx.EXPAND | wx.ALL,
                        border=10)

    self.SetTitle('Pick a trial and optionally some tags from that trial')

    self.Bind(wx.EVT_CHOICE, self.onTrialSelect, id=self.trials_ctrl.ctr.GetId())
    self.Bind(wx.EVT_BUTTON, self.onOK, id=wx.ID_OK)
    wx.CallAfter(self.refresh_tags)

  def onTrialSelect(self, e):
    self.refresh_tags()

  def refresh_tags(self):
    self.trial_tags.ctr.Clear()
    trial = self.trials[self.trials_ctrl.ctr.GetSelection()]
    self.tags = []
    self.tag_names = []
    tag_ids = []
    for run in trial.runs:
      for tag in run.tags:
        if tag.id not in tag_ids:
          self.tags.append(tag)
          tag_ids.append(tag.id)
          self.tag_names.append(tag.name)

    if self.tag_names:
      self.trial_tags.ctr.InsertItems(items=self.tag_names, pos=0)

  def onOK(self, e):
    from xfel.ui.db import get_run_path
    self.run_paths = []

    trial = self.trials[self.trials_ctrl.ctr.GetSelection()]
    tags = [self.tags[self.tag_names.index(t)] for t in self.trial_tags.ctr.GetCheckedStrings()]
    tag_ids = [t.id for t in tags]

    run_ids = []
    for rungroup in trial.rungroups:
      for run in rungroup.runs:
        if run.id not in run_ids:
          if len(tags) == 0:
            self.run_paths.append(os.path.join(
              get_run_path(self.parent.main.params.output_folder, trial, rungroup, run),
              'out'))
          else:
            run_tag_ids = [t.id for t in run.tags]
            for tag_id in tag_ids:
              if tag_id in run_tag_ids:
                run_ids.append(run.id)
                self.run_paths.append(os.path.join(
                  get_run_path(self.parent.main.params.output_folder, trial, rungroup, run),
                  'out'))
                break
    e.Skip()

class MultiRunTagDialog(BaseDialog):
  def __init__(self, parent,
               label_style='bold',
               content_style='normal',
               db=None,
               *args, **kwargs):
    BaseDialog.__init__(self, parent, label_style=label_style,
                        content_style=content_style, *args, **kwargs)
    self.parent = parent
    self.db = db
    self.db_tags = self.db.get_all_tags()
    self.db_tag_names = [t.name for t in self.db_tags]
    self.db_tags_selected_sort = self.db_tag_names
    self.db_runs = self.db.get_all_runs()
    self.db_run_numbers = [str(r.run) for r in self.db_runs]
    self.runs_selected = []
    self.buttons_for_runs_selected = []

    self.multiruntag_sizer = wx.BoxSizer(wx.VERTICAL)

    self.select_runs_panel = wx.Panel(self)
    self.select_runs_sizer = wx.BoxSizer(wx.HORIZONTAL)
    self.select_runs =  gctr.CheckListCtrl(self.select_runs_panel,
                                           label='Selected runs:',
                                           label_size=(200, -1),
                                           label_style='normal',
                                           ctrl_size=(240, 300),
                                           direction='vertical',
                                           choices=self.db_run_numbers)
    self.select_runs_sizer.Add(self.select_runs,
                               flag=wx.EXPAND | wx.LEFT | wx.RIGHT | wx.TOP,
                               border=10)
    self.select_runs_panel.SetSizer(self.select_runs_sizer)

    self.sort_type_panel = wx.Panel(self)
    self.sort_type_sizer = wx.BoxSizer(wx.VERTICAL)
    self.radio_sort = gctr.RadioCtrl(self.sort_type_panel,
                                     label='Sort tags by',
                                     label_style='normal',
                                     label_size=(80, -1),
                                     direction='horizontal',
                                     items={'id':'DB ID',
                                            'alpha':'name'})
    self.sort_type_sizer.Add(self.radio_sort,
                             flag=wx.EXPAND | wx.LEFT | wx.RIGHT | wx.TOP,
                             border=5)
    self.sort_type_panel.SetSizer(self.sort_type_sizer)

    self.button_panel = wx.Panel(self)
    self.button_sizer = wx.BoxSizer(wx.HORIZONTAL)
    self.btn_add_tags    = wx.Button(self.button_panel, size=(115, -1),
                                     label='Add tags')
    self.btn_remove_tags = wx.Button(self.button_panel, size=(115, -1),
                                     label='Remove tags')
    self.button_sizer.Add(self.btn_add_tags,
                          flag=wx.EXPAND | wx.LEFT | wx.RIGHT | wx.TOP,
                          border=5)
    self.button_sizer.Add(self.btn_remove_tags,
                          flag=wx.EXPAND | wx.LEFT | wx.RIGHT | wx.TOP,
                          border=5)
    self.button_panel.SetSizer(self.button_sizer)

    # Add panels to main sizer
    self.multiruntag_sizer.Add(self.select_runs_panel,
                               flag=wx.EXPAND | wx.LEFT | wx.RIGHT)
    self.multiruntag_sizer.Add(self.sort_type_panel,
                               flag=wx.EXPAND | wx.BOTTOM | wx.TOP)
    self.multiruntag_sizer.Add(self.button_panel,
                               flag=wx.EXPAND | wx.BOTTOM | wx.TOP)
    self.main_sizer.Add(self.multiruntag_sizer,
                        flag=wx.EXPAND | wx.RIGHT | wx.LEFT)

    # Dialog control
    dialog_box = self.CreateSeparatedButtonSizer(wx.OK | wx.CANCEL)
    self.main_sizer.Add(dialog_box,
                        flag=wx.EXPAND | wx.ALL,
                        border=10)

    self.Layout()
    self.SetTitle('Manage multiple runs')

    self.Bind(wx.EVT_CHECKLISTBOX, self.onRunChoice, self.select_runs.ctr)
    self.Bind(wx.EVT_RADIOBUTTON, self.onSortDefault, self.radio_sort.id)
    self.Bind(wx.EVT_RADIOBUTTON, self.onSortAlphanum, self.radio_sort.alpha)
    self.Bind(wx.EVT_BUTTON, self.onAddTags, self.btn_add_tags)
    self.Bind(wx.EVT_BUTTON, self.onRemoveTags, self.btn_remove_tags)
    self.Bind(wx.EVT_BUTTON, self.onOK, id=wx.ID_OK)

  def onRunChoice(self, e):
    run_numbers_selected = self.select_runs.ctr.GetCheckedStrings()
    self.selected = {}
    for r in self.db_runs:
      if r.run in run_numbers_selected:
        self.selected[r.run] = [r]
    for b in self.parent.all_tag_buttons:
      if b.run.run in self.selected:
        self.selected[b.run.run].append(b)

  def onSortDefault(self, e):
    self.db_tags_selected_sort = self.db_tag_names

  def onSortAlphanum(self, e):
    self.db_tags_selected_sort = sorted(self.db_tag_names)

  def onAddTags(self, e):
    tag_dlg = wx.MultiChoiceDialog(self,
                                   message='Add these tags to selected runs',
                                   caption='Add tags to multiple runs',
                                   choices=self.db_tags_selected_sort)
    tag_dlg.Fit()

    if (tag_dlg.ShowModal() == wx.ID_OK):
      tag_indices = tag_dlg.GetSelections()
      add_tags = [t for t in self.db_tags if self.db_tag_names.index(t.name) in tag_indices]

      runs_with_tags_buttons = self.parent.all_tag_buttons

      for tag in add_tags:
        for run_number in self.selected.keys():
          run, button = self.selected[run_number]
          run_tags = run.app.get_run_tags(run.run_id)
          run_tag_ids = [t.tag_id for t in run_tags]
          if tag.tag_id not in run_tag_ids:
            run.add_tag(tag)
            button.tags.append(tag)
            button.update_label()


  def onRemoveTags(self, e):
    tag_dlg = wx.MultiChoiceDialog(self,
                                   message='Remove these tags from selected runs',
                                   caption='Remove tags from multiple runs',
                                   choices=self.db_tags_selected_sort)
    tag_dlg.Fit()

    if (tag_dlg.ShowModal() == wx.ID_OK):
      tag_indices = tag_dlg.GetSelections()
      remove_tags = [t for t in self.db_tags if self.db_tag_names.index(t.name) in tag_indices]

      for tag in remove_tags:
        for run_number in self.selected.keys():
          run, button = self.selected[run_number]
          run_tags = run.app.get_run_tags(run.run_id)
          run_tag_ids = [t.tag_id for t in run_tags]
          if tag.tag_id in run_tag_ids:
            run.remove_tag(tag)
            tag_on_button = [t for t in button.tags if t.tag_id == tag.tag_id][0] # proxy tag =/= other proxy tag
            button.tags.remove(tag_on_button)
            button.update_label()

  def onOK(self, e):
    e.Skip()

class TagDialog(BaseDialog):
  def __init__(self, parent,
               label_style='bold',
               content_style='normal',
               db=None,
               *args, **kwargs):
    BaseDialog.__init__(self, parent, label_style=label_style,
                        content_style=content_style, *args, **kwargs)

    self.db = db
    self.db_tags = self.db.get_all_tags()
    self.deleted_tags = []
    self.new_tags = []
    self.edited_tags =[]
    self.index = 0

    self.top_sizer = wx.BoxSizer(wx.HORIZONTAL)

    self.button_panel = wx.Panel(self)
    self.button_sizer = wx.BoxSizer(wx.VERTICAL)
    self.btn_add = wx.Button(self.button_panel, size=(120, -1),
                             label='Add Tag')
    self.btn_rmv = wx.Button(self.button_panel, size=(120, -1),
                             label='Remove Tags')
    self.btn_clr = wx.Button(self.button_panel, size=(120, -1),
                             label='Clear All')
    self.button_sizer.Add(self.btn_add)
    self.button_sizer.Add(self.btn_rmv)
    self.button_sizer.Add(self.btn_clr)
    self.button_panel.SetSizer(self.button_sizer)

    self.tag_panel = ScrolledPanel(self, size=(500, 400))
    self.tag_list = EdListCtrl(self.tag_panel,
                               style=wx.LC_REPORT | wx.SUNKEN_BORDER)
    self.tag_sizer = wx.BoxSizer(wx.VERTICAL)
    self.tag_panel.SetSizer(self.tag_sizer)

    self.tag_list.InsertColumn(0, 'Sample Tag', width=200)
    self.tag_list.InsertColumn(1, 'Comments', width=300)

    # Populate tags with current values from db
    if len(self.db_tags) > 0:
      for tag in self.db_tags:
        self.tag_list.InsertItem(self.index, str(tag.name))
        self.tag_list.SetItem(self.index, 1, str(tag.comment))
        self.tag_list.SetItemData(self.index, tag.tag_id)
        self.index += 1

    self.tag_sizer.Add(self.tag_list, 1, flag=wx.EXPAND)

    # Add panels to main sizer
    self.top_sizer.Add(self.button_panel,
                       flag=wx.LEFT, border=10)
    self.top_sizer.Add(self.tag_panel,
                       flag=wx.EXPAND | wx.RIGHT | wx.LEFT, border=10)
    self.main_sizer.Add(self.top_sizer,
                        flag=wx.EXPAND| wx.TOP | wx.BOTTOM, border=10)
    # Dialog control
    dialog_box = self.CreateSeparatedButtonSizer(wx.OK | wx.CANCEL)
    self.main_sizer.Add(dialog_box,
                   flag=wx.EXPAND | wx.ALL,
                   border=10)

    self.Layout()
    self.SetTitle('Manage Tags')

    # Button bindings
    self.Bind(wx.EVT_BUTTON, self.onAdd, self.btn_add)
    self.Bind(wx.EVT_BUTTON, self.onRemove, self.btn_rmv)
    self.Bind(wx.EVT_BUTTON, self.onClear, self.btn_clr)
    self.Bind(wx.EVT_BUTTON, self.onOK, id=wx.ID_OK)

  def onAdd(self, e):
    ''' Add a string item to list; focus on item & provide default tag name'''
    new_tag = ('default tag {}'.format(self.index), '', self.index)
    self.new_tags.append(new_tag)
    self.tag_list.InsertItem(self.index, new_tag[0])
    self.tag_list.SetItem(self.index, 1, new_tag[1])
    self.tag_list.SetItemData(self.index, -1)
    #self.tag_list.Select(self.index)
    #self.tag_list.Focus(self.index)
    self.index += 1

  def onRemove(self, e):
    selected_indices = getListCtrlSelection(self.tag_list)
    tag_ids = [self.tag_list.GetItemData(i) for i in selected_indices]
    self.deleted_tags = [i for i in self.db_tags if i.tag_id in tag_ids]

    for i in range(len(selected_indices)):
      to_delete = getListCtrlSelection(self.tag_list)
      self.tag_list.DeleteItem(to_delete[0])

  def onClear(self, e):
    warning = wx.MessageDialog(self,
                               message='Are you sure you want to delete all '
                                       'tags? \n This cannot be reversed!',
                               caption='Warning',
                               style=wx.YES_NO | wx.ICON_EXCLAMATION)
    if (warning.ShowModal() == wx.ID_YES):
      self.deleted_tags = self.db_tags
      self.tag_list.DeleteAllItems()
      self.index = 0
      self.db_tags = []

  def onOK(self, e):
    try:
      # Delete tags from DB
      for tag in self.deleted_tags:
        self.db.delete_tag(tag=tag)

      # Update names for edited tags
      all_items = [(self.tag_list.GetItemData(i),
                    self.tag_list.GetItem(itemIdx=i, col=0),
                    self.tag_list.GetItem(itemIdx=i, col=1))
                    for i in range(self.tag_list.GetItemCount())]

      self.db_tags = self.db.get_all_tags()
      tag_ids = [i.tag_id for i in self.db_tags]
      new_tag_names = [i[1].GetText() for i in all_items]

      if len([i for i in new_tag_names if new_tag_names.count(i) > 1]) != 0:
        wx.MessageBox('Need a unique tag name!', 'Warning',
                       wx.ICON_EXCLAMATION)
      else:
        for item in all_items:
          if item[0] in tag_ids:
            tag = self.db.get_tag(tag_id=item[0])
            tag.name = item[1].GetText()
            tag.comment = item[2].GetText()
          elif item[0] == -1:
            self.db.create_tag(name=item[1].GetText(), comment=item[2].GetText())

    except Exception as exception:
      print(str(exception))

    e.Skip()


class RunBlockDialog(BaseDialog):
  ''' Comes up when individual run block button is clicked; allows for run
  block settings to be manipulated by user '''

  def __init__(self, parent, db,
               block=None, trial=None,
               label_style='bold',
               content_style='normal',
               *args, **kwargs):

    self.parent = parent
    self.block = block
    self.all_blocks = []
    self.db = db
    self.use_ids = db.params.facility.name not in ['lcls']
    self.is_lcls = db.params.facility.name == 'lcls'

    all_runs = db.get_all_runs()
    if self.use_ids:
      runs_available = sorted([i.id for i in all_runs])
    else:
      runs_available = sorted([int(i.run) for i in all_runs])
    self.first_avail = min(runs_available)
    self.last_avail = max(runs_available)

    if block is None:
      runs = self.db.get_all_runs()
      if self.use_ids:
        run_numbers = [r.id for r in runs]
      else:
        run_numbers = list(sorted([int(r.run) for r in runs]))
      assert len(set(run_numbers)) == len(run_numbers)

      if trial is not None:
        self.all_blocks = trial.rungroups

      if len(runs) == 0:
        wx.MessageBox("No runs found", "Error", wx.OK | wx.ICON_EXCLAMATION)
        assert False # Close and destroy dialog properly here

      self.first_run = min(run_numbers)
      self.last_run = None

      class defaults(object):
        def __getattr__(self, item):
          if item == "detector_address":
            return 'CxiDs2.0:Cspad.0'
          elif item == "detz_parameter":
            return 580
          elif item == "format":
            return "cbf"
          elif item == "two_theta_low":
            return 12.5 # Defaults are from kapton tape experiments (this is kapton ring)
          elif item == "two_theta_high":
            return 22.8 # Defaults are from kapton tape experiments (this is water ring)
          elif item in ["extra_phil_str", "calib_dir", "dark_avg_path", "dark_stddev_path",
            "gain_map_path", "beamx", "beamy", "gain_mask_level", "untrusted_pixel_mask_path",
            "binning", "energy", "wavelength_offset", "spectrum_eV_per_pixel", "spectrum_eV_offset",
            "comment", "config_str", "extra_format_str"]:
            return None
          else:
            raise AttributeError(item)
      block = defaults()

    else:
      db = block.app
      self.first_run, self.last_run = block.get_first_and_last_runs()
      if self.first_run is None:
        self.first_run = self.first_avail
      else:
        if self.use_ids:
          if self.first_run is not None: self.first_run = self.first_run.id
          if self.last_run is not None: self.last_run = self.last_run.id
        else:
          if self.first_run is not None: self.first_run = int(self.first_run.run)
          if self.last_run is not None: self.last_run = int(self.last_run.run)

    self.orig_first_run = self.first_run
    self.orig_last_run = self.last_run

    BaseDialog.__init__(self, parent,
                        label_style=label_style,
                        content_style=content_style,
                        size=(600, 600),
                        *args, **kwargs)

    # Run block start / end points (choice widgets)

    if self.is_lcls:
      self.config_panel = wx.Panel(self)
      config_box = wx.StaticBox(self.config_panel, label='Configuration')
      self.config_sizer = wx.StaticBoxSizer(config_box)
      self.config_panel.SetSizer(self.config_sizer)
      self.config_panel.Hide()

    self.phil_panel = wx.Panel(self)
    phil_box = wx.StaticBox(self.phil_panel, label='Extra phil parameters')
    self.phil_sizer = wx.StaticBoxSizer(phil_box)
    self.phil_panel.SetSizer(self.phil_sizer)

    if self.is_lcls:
      self.format_panel = wx.Panel(self)
      format_box = wx.StaticBox(self.format_panel, label='Extra XTC format parameters')
      self.format_sizer = wx.StaticBoxSizer(format_box)
      self.format_panel.SetSizer(self.format_sizer)

    runblock_box = wx.StaticBox(self, label='Options')
    self.runblock_box_sizer = wx.StaticBoxSizer(runblock_box, wx.VERTICAL)
    self.runblock_panel = ScrolledPanel(self, size=(550, 225))
    self.runblock_sizer = wx.BoxSizer(wx.VERTICAL)
    self.runblock_panel.SetSizer(self.runblock_sizer)

    if self.is_lcls:
      # Configuration text ctrl (user can put in anything they want)
      self.config = gctr.PHILBox(self.config_panel,
                                 btn_import=True,
                                 btn_import_label='Import Config',
                                 btn_export=False,
                                 btn_default=True,
                                 btn_default_label='Default Config',
                                 ctr_size=(-1, 100),
                                 ctr_value=str(block.config_str))
      self.config_sizer.Add(self.config, 1, flag=wx.EXPAND | wx.ALL, border=10)

    # Extra phil
    self.phil = gctr.PHILBox(self.phil_panel,
                             btn_import=True,
                             btn_import_label='Import PHIL',
                             btn_export=False,
                             btn_default=True,
                             btn_default_label='Default PHIL',
                             ctr_size=(-1, 100),
                             ctr_value=str(block.extra_phil_str))
    self.phil_sizer.Add(self.phil, 1, flag=wx.EXPAND | wx.ALL, border=10)

    if self.is_lcls:
      # Extra format options text ctrl (user can put in anything they want)
      self.format = gctr.PHILBox(self.format_panel,
                                 btn_import=True,
                                 btn_import_label='Import PHIL',
                                 btn_export=False,
                                 btn_default=False,
                                 ctr_size=(-1, 100),
                                 ctr_value=str(block.extra_format_str))
      self.format_sizer.Add(self.format, 1, flag=wx.EXPAND | wx.ALL, border=10)

    self.start_stop_sizer = wx.FlexGridSizer(2, 2, 20, 20)

    self.runblocks_start = gctr.SpinCtrl(self.runblock_panel,
                                   label='Start run:',
                                   label_style='bold',
                                   label_size=(100, -1),
                                   ctrl_value=(self.first_run or self.last_avail),
                                   ctrl_min=self.first_avail,
                                   ctrl_max=self.last_avail,
                                   ctrl_size=(150,-1))
    self.end_type = gctr.RadioCtrl(self.runblock_panel,
                                   name='rg_end_type',
                                   label='',
                                   label_style='normal',
                                   label_size=(100, -1),
                                   direction='vertical',
                                   items={'auto':'Auto add runs',
                                          'specify':'Specify end run'})
    self.runblocks_end = gctr.SpinCtrl(self.runblock_panel,
                                   label='End run:',
                                   label_style='bold',
                                   label_size=(100, -1),
                                   ctrl_value=(self.last_run or self.last_avail),
                                   ctrl_min=self.first_avail,
                                   ctrl_max=self.last_avail,
                                   ctrl_size=(150,-1))

    self.start_stop_sizer.AddMany([self.runblocks_start,
                                   wx.StaticText(self.runblock_panel, -1, ''),
                                   self.runblocks_end,
                                   self.end_type])
    self.runblock_sizer.Add(self.start_stop_sizer, flag=wx.EXPAND | wx.ALL, border=10)

    if self.is_lcls:
      # Detector address
      self.address = gctr.TextButtonCtrl(self.runblock_panel,
                                         name='rg_address',
                                         label='Detector Address:',
                                         label_style='bold',
                                         label_size=(100, -1),
                                         value=block.detector_address)
      self.runblock_sizer.Add(self.address, flag=wx.EXPAND | wx.ALL, border=10)


      # Beam XYZ (X, Y - pickle only)
      self.beam_xyz = gctr.OptionCtrl(self.runblock_panel,
                                      name='rg_beam_xyz',
                                      label='Beam:',
                                      label_style='bold',
                                      label_size=(100, -1),
                                      ctrl_size=(60, -1),
                                      items=[('X', block.beamx),
                                             ('Y', block.beamy),
                                             ('DetZ', block.detz_parameter)])
      self.runblock_sizer.Add(self.beam_xyz, flag=wx.EXPAND | wx.ALL, border=10)

    # Binning, energy, gain mask level
    if self.is_lcls:
      items = [('binning', block.binning),
               ('energy', block.energy)]
      self.bin_nrg_gain = gctr.OptionCtrl(self.runblock_panel,
                                          name='rg_bin_nrg_gain',
                                          ctrl_size=(80, -1),
                                          items=items)
      self.runblock_sizer.Add(self.bin_nrg_gain, flag=wx.EXPAND | wx.ALL, border=10)
      self.wavelength_offset = gctr.OptionCtrl(self.runblock_panel,
                                               name='rg_wavelength_offset',
                                               ctrl_size=(80, -1),
                                               items=[('wavelength_offset', block.wavelength_offset)])
      self.runblock_sizer.Add(self.wavelength_offset, flag=wx.EXPAND | wx.ALL, border=10)
      self.spectrum_calibration = gctr.OptionCtrl(self.runblock_panel,
                                                  name='rg_spectrum_calibration',
                                                  ctrl_size=(80, -1),
                                                  items=[('spectrum_eV_per_pixel', block.spectrum_eV_per_pixel),
                                                         ('spectrum_eV_offset', block.spectrum_eV_offset)])
      self.runblock_sizer.Add(self.spectrum_calibration, flag=wx.EXPAND | wx.ALL, border=10)
    else:
      self.energy = gctr.TextButtonCtrl(self.runblock_panel,
                                        name='rg_energy',
                                        label='Energy override',
                                        label_size=(150, -1))
      self.energy.ctr.SetValue(str(block.energy))
      self.runblock_sizer.Add(self.energy, flag=wx.EXPAND | wx.ALL, border=10)

    # Two theta values for droplet hit finding
    self.two_thetas = gctr.OptionCtrl(self.runblock_panel,
                                      name='rg_two_thetas',
                                      ctrl_size=(80, -1),
                                      items=[('two_theta_low', block.two_theta_low),
                                             ('two_theta_high', block.two_theta_high)])
    self.runblock_sizer.Add(self.two_thetas, flag=wx.EXPAND | wx.ALL, border=10)


    # Untrusted pixel mask path
    self.untrusted_path = gctr.TextButtonCtrl(self.runblock_panel,
                                              label='Untrusted Pixel Mask:',
                                              label_style='normal',
                                              label_size=(180, -1),
                                              big_button=True,
                                              value=str(block.untrusted_pixel_mask_path))
    self.runblock_sizer.Add(self.untrusted_path, flag=wx.EXPAND | wx.ALL,
                            border=10)

    # Comment
    self.comment = gctr.TextButtonCtrl(self.runblock_panel,
                                       label='Comment:',
                                       label_style='normal',
                                       label_size=(100, -1))
    self.comment.ctr.SetValue(str(block.comment))
    self.runblock_sizer.Add(self.comment, flag=wx.EXPAND | wx.ALL,
                            border=10)

    self.main_sizer.Add(self.phil_panel, flag=wx.EXPAND | wx.ALL, border=10)
    if self.is_lcls:
      self.main_sizer.Add(self.config_panel, flag=wx.EXPAND | wx.ALL, border=10)
      self.main_sizer.Add(self.format_panel, flag=wx.EXPAND | wx.ALL, border=10)
    self.runblock_box_sizer.Add(self.runblock_panel)
    self.main_sizer.Add(self.runblock_box_sizer, flag=wx.EXPAND | wx.ALL,
                        border=10)

    # Dialog control
    dialog_box = self.CreateSeparatedButtonSizer(wx.OK | wx.CANCEL)
    self.main_sizer.Add(dialog_box,
                        flag=wx.EXPAND | wx.ALL,
                        border=10)

    self.Bind(wx.EVT_RADIOBUTTON, self.onAutoEnd, self.end_type.auto)
    self.Bind(wx.EVT_RADIOBUTTON, self.onSpecifyEnd, self.end_type.specify)
    self.Bind(wx.EVT_BUTTON, self.onImportPhil, self.phil.btn_import)
    if self.is_lcls:
      self.Bind(wx.EVT_BUTTON, self.onImportFormat, self.format.btn_import)
    self.Bind(wx.EVT_BUTTON, self.onUntrustedBrowse,
              id=self.untrusted_path.btn_big.GetId())
    self.Bind(wx.EVT_BUTTON, self.onOK, id=wx.ID_OK)


    self.fill_in_fields()
    self.configure_controls()
    self.Layout()
    self.runblock_panel.SetupScrolling()
    self.SetTitle('Run Block Settings')

  def onAutoEnd(self, e):
    self.last_run = None
    self.runblocks_end.Disable()

  def onSpecifyEnd(self, e):
    self.runblocks_end.Enable()

  def onImportConfig(self, e):
    cfg_dlg = wx.FileDialog(self,
                            message="Load configuration file",
                            defaultDir=os.curdir,
                            defaultFile="*",
                            wildcard="*",
                            style=wx.FD_OPEN | wx.FD_FILE_MUST_EXIST,
                            )
    if cfg_dlg.ShowModal() == wx.ID_OK:
      config_file = cfg_dlg.GetPaths()[0]
      with open(config_file, 'r') as cfg:
        cfg_contents = cfg.read()
      self.config.ctr.SetValue(cfg_contents)
    cfg_dlg.Destroy()

  def onImportPhil(self, e):
    phil_dlg = wx.FileDialog(self,
                             message="Load phil file",
                             defaultDir=os.curdir,
                             defaultFile="*",
                             wildcard="*.phil",
                             style=wx.FD_OPEN | wx.FD_FILE_MUST_EXIST,
                             )
    if phil_dlg.ShowModal() == wx.ID_OK:
      phil_file = phil_dlg.GetPaths()[0]
      with open(phil_file, 'r') as phil:
        phil_contents = phil.read()
      self.phil.ctr.SetValue(phil_contents)
    phil_dlg.Destroy()

  def onImportFormat(self, e):
    phil_dlg = wx.FileDialog(self,
                             message="Load phil file",
                             defaultDir=os.curdir,
                             defaultFile="*",
                             wildcard="*.phil",
                             style=wx.FD_OPEN | wx.FD_FILE_MUST_EXIST,
                             )
    if phil_dlg.ShowModal() == wx.ID_OK:
      phil_file = phil_dlg.GetPaths()[0]
      with open(phil_file, 'r') as phil:
        phil_contents = phil.read()
      self.format.ctr.SetValue(phil_contents)
    phil_dlg.Destroy()

  def onDefaultConfig(self, e):
    # TODO: Generate default config parameters (re-do based on pickle / CBF)
    pass

  def onOK(self, e):
    try:
      first = int(self.runblocks_start.ctr.GetValue())
      assert first > 0 and first >= self.first_avail
      self.first_run = first
    except (ValueError, AssertionError) as e:
      wx.MessageBox("Please select a contiguous runs between %d and %d." % (self.first_avail, self.last_avail),
                    'Warning!', wx.ICON_EXCLAMATION)
      return
    if self.end_type.specify.GetValue() == 1:
      try:
        last = int(self.runblocks_end.ctr.GetValue())
        assert last > 0 and last <= self.last_avail and last >= first
        self.last_run = last
      except (ValueError, AssertionError) as e:
        wx.MessageBox("Please select contiguous runs between %d and %d." % (self.first_avail, self.last_avail),
                      'Warning!', wx.ICON_EXCLAMATION)
        return
    elif self.end_type.specify.GetValue() == 0:
      self.last_run = None
    else:
      assert False
    rg_open = self.last_run is None

    if self.is_lcls:
      # Validation
      if 'rayonix' in self.address.ctr.GetValue().lower():
        def is_none(string):
          return string is None or string in ['', 'None']
        if is_none(self.beam_xyz.X.GetValue()) or is_none(self.beam_xyz.Y.GetValue()) or \
             is_none(self.beam_xyz.DetZ.GetValue()):
          wx.MessageBox("For Rayonix, beam x, y, and DetZ are required, even if reference_geometry is specified. reference_geometry will take precedence.",
                        'Warning!', wx.ICON_EXCLAMATION)
          return

    rg_dict = dict(active=True,
                   open=rg_open,
                   extra_phil_str=self.phil.ctr.GetValue(),
                   untrusted_pixel_mask_path=self.untrusted_path.ctr.GetValue().strip(),
                   two_theta_low=self.two_thetas.two_theta_low.GetValue(),
                   two_theta_high=self.two_thetas.two_theta_high.GetValue(),
                   comment=self.comment.ctr.GetValue())

    if self.is_lcls:
      rg_dict['detz_parameter']=self.beam_xyz.DetZ.GetValue()
      rg_dict['beamx']=self.beam_xyz.X.GetValue()
      rg_dict['beamy']=self.beam_xyz.Y.GetValue()
      rg_dict['energy']=self.bin_nrg_gain.energy.GetValue()
      rg_dict['wavelength_offset']=self.wavelength_offset.wavelength_offset.GetValue()
      rg_dict['binning']=self.bin_nrg_gain.binning.GetValue()
      rg_dict['detector_address']=self.address.ctr.GetValue()
      rg_dict['config_str']=self.config.ctr.GetValue()
      rg_dict['extra_format_str']=self.format.ctr.GetValue()
      rg_dict['spectrum_eV_per_pixel']=self.spectrum_calibration.spectrum_eV_per_pixel.GetValue()
      rg_dict['spectrum_eV_offset']=self.spectrum_calibration.spectrum_eV_offset.GetValue()
    else:
      rg_dict['energy']=self.energy.ctr.GetValue()

    for key, value in six.iteritems(rg_dict):
      if str(value) == 'None' or str(value) == '':
        rg_dict[key] = None
      elif type(value) == bool:
        rg_dict[key] = int(value)

    if self.block is None:
      self.block = self.db.create_rungroup(**rg_dict)
      self.block.sync_runs(self.first_run, self.last_run, self.use_ids)
      self.parent.trial.add_rungroup(self.block)
    else:
      # if all the parameters are unchanged, do nothing
      all_the_same = [str(rg_dict[key]).strip() == str(getattr(self.block, key)).strip() for key in rg_dict].count(False) == 0
      all_the_same &= self.first_run == self.orig_first_run and self.last_run == self.orig_last_run
      if not all_the_same:
        # if all the parameters except open and comment are the same,
        # only update those fields
        keep_old_run_group = [str(rg_dict[key]).strip() == str(getattr(self.block, key)).strip() for key in rg_dict \
                              if key not in ['open', 'comment']].count(False) == 0
        if keep_old_run_group:
          main = self.parent.parent.GetParent().main
          running = main.job_sentinel is not None and main.job_sentinel.active
          if running:
            main.stop_job_sentinel()

          self.block.open = rg_open
          self.block.comment = rg_dict['comment']
          self.block.sync_runs(self.first_run, self.last_run, self.use_ids)

          if running:
            main.start_job_sentinel()

        else:
          # enough parameters have changed to warrant creating a new run group
          self.block.active = False
          self.block = self.db.create_rungroup(**rg_dict)
          self.block.sync_runs(self.first_run, self.last_run, self.use_ids)
          self.parent.trial.add_rungroup(self.block)

    e.Skip()

  def fill_in_fields(self):
    ''' If previous rungroups exist in trial, fill in fields in nascent block '''
    if len(self.all_blocks) > 0:
      last = self.all_blocks[-1]
      self.phil.ctr.SetValue(str(last.extra_phil_str))
      if self.is_lcls:
        self.address.ctr.SetValue(str(last.detector_address))
        self.config.ctr.SetValue(str(last.config_str))
        self.format.ctr.SetValue(str(last.extra_format_str))
        self.beam_xyz.DetZ.SetValue(str(last.detz_parameter))
        self.beam_xyz.X.SetValue(str(last.beamx))
        self.beam_xyz.Y.SetValue(str(last.beamy))
        self.bin_nrg_gain.binning.SetValue(str(last.binning))
        self.bin_nrg_gain.energy.SetValue(str(last.energy))
        self.wavelength_offset.wavelength_offset.SetValue(str(last.wavelength_offset))
        self.spectrum_calibration.spectrum_eV_per_pixel.SetValue(str(last.spectrum_eV_per_pixel))
        self.spectrum_calibration.spectrum_eV_offset.SetValue(str(last.spectrum_eV_offset))
      self.two_thetas.two_theta_low.SetValue(str(last.two_theta_low))
      self.two_thetas.two_theta_high.SetValue(str(last.two_theta_high))
      self.untrusted_path.ctr.SetValue(str(last.untrusted_pixel_mask_path))
      self.comment.ctr.SetValue(str(last.comment))

  def configure_controls(self):
    if self.last_run is None:
      self.runblocks_end.Disable()
      self.end_type.auto.SetValue(1)
    else:
      self.runblocks_end.Enable()
      self.end_type.specify.SetValue(1)

  def onDarkAvgBrowse(self, e):
    dark_dlg = wx.FileDialog(self,
                             message="Load dark average file",
                             defaultDir=os.curdir,
                             defaultFile="*.cbf",
                             wildcard="*.cbf",
                             style=wx.FD_OPEN | wx.FD_FILE_MUST_EXIST,
                             )

    if dark_dlg.ShowModal() == wx.ID_OK:
      self.dark_avg_path.ctr.SetValue(dark_dlg.GetPaths()[0])
    dark_dlg.Destroy()

  def onDarkMapBrowse(self, e):
    dark_dlg = wx.FileDialog(self,
                             message="Load dark map file",
                             defaultDir=os.curdir,
                             defaultFile="*.cbf",
                             wildcard="*.cbf",
                             style=wx.FD_OPEN | wx.FD_FILE_MUST_EXIST,
                             )

    if dark_dlg.ShowModal() == wx.ID_OK:
      self.gain_map_path.ctr.SetValue(dark_dlg.GetPaths()[0])
    dark_dlg.Destroy()

  def onDarkStdBrowse(self, e):
    dark_dlg = wx.FileDialog(self,
                             message="Load dark stddev file",
                             defaultDir=os.curdir,
                             defaultFile="*.cbf",
                             wildcard="*.cbf",
                             style=wx.FD_OPEN | wx.FD_FILE_MUST_EXIST,
                             )

    if dark_dlg.ShowModal() == wx.ID_OK:
      self.dark_stddev_path.ctr.SetValue(dark_dlg.GetPaths()[0])
    dark_dlg.Destroy()

  def onUntrustedBrowse(self, e):
    dlg = wx.FileDialog(self,
                             message="Load untrusted pixel mask",
                             defaultDir=os.curdir,
                             defaultFile="*.mask",
                             wildcard="*.mask",
                             style=wx.FD_OPEN | wx.FD_FILE_MUST_EXIST,
                             )

    if dlg.ShowModal() == wx.ID_OK:
      self.untrusted_path.ctr.SetValue(dlg.GetPaths()[0])
    dlg.Destroy()

  def onCalibDirBrowse(self, e):
    dlg = wx.DirDialog(self, "Choose calibration directory:",
                       style=wx.DD_DEFAULT_STYLE)

    if dlg.ShowModal() == wx.ID_OK:
      self.calib_dir.ctr.SetValue(dlg.GetPath())
    dlg.Destroy()
    e.Skip()

class SelectRunBlocksDialog(BaseDialog):
  def __init__(self, parent, trial,
               label_style='bold',
               content_style='normal',
               db=None,
               *args, **kwargs):
    BaseDialog.__init__(self, parent, label_style=label_style,
                        content_style=content_style, *args, **kwargs)

    self.db = db
    self.trial = trial

    self.top_sizer = wx.BoxSizer(wx.HORIZONTAL)

    self.button_panel = wx.Panel(self)
    self.button_sizer = wx.BoxSizer(wx.VERTICAL)
    self.button_panel.SetSizer(self.button_sizer)

    self.runblocks_panel = ScrolledPanel(self, size=(500, 400))

    # Populate rungroups with current values from db
    self.trial_rungroups = [t.id for t in trial.rungroups]
    self.all_rungroups = self.db.get_all_rungroups()
    choices = []
    selected = []
    use_ids = db.params.facility.name not in ['lcls']
    for rungroup in self.all_rungroups:
      selected.append(rungroup.id in self.trial_rungroups)
      first_run, last_run = rungroup.get_first_and_last_runs()
      if last_run is None:
        if first_run is None:
          desc = "[%d]"%(rungroup.id)
        else:
          desc = "[%d] %d+"%(rungroup.id, int(first_run.id) if use_ids else int(first_run.run))
      else:
        desc = "[%d] %d-%d"%(rungroup.id, int(first_run.id) if use_ids else int(first_run.run), \
                                          int(last_run.id) if use_ids else int(last_run.run))
      if rungroup.comment is not None:
        desc += " " + rungroup.comment

      choices.append(desc)

    self.runblocks_list = gctr.CheckListCtrl(self.runblocks_panel,
                                             label='Select runblocks',
                                             label_size=(40, -1),
                                             label_style='normal',
                                             ctrl_size=(450, 350),
                                             direction='vertical',
                                             choices=choices)
    for i in range(len(selected)):
      self.runblocks_list.ctr.Check(i, selected[i])

    self.runblocks_sizer = wx.BoxSizer(wx.VERTICAL)
    self.runblocks_panel.SetSizer(self.runblocks_sizer)

    self.runblocks_sizer.Add(self.runblocks_list, 1, flag=wx.EXPAND)

    # Add panels to main sizer
    self.top_sizer.Add(self.button_panel,
                       flag=wx.LEFT, border=10)
    self.top_sizer.Add(self.runblocks_panel,
                       flag=wx.EXPAND | wx.RIGHT | wx.LEFT, border=10)
    self.main_sizer.Add(self.top_sizer,
                        flag=wx.EXPAND| wx.TOP | wx.BOTTOM, border=10)
    # Dialog control
    dialog_box = self.CreateSeparatedButtonSizer(wx.OK | wx.CANCEL)
    self.main_sizer.Add(dialog_box,
                   flag=wx.EXPAND | wx.ALL,
                   border=10)

    self.Layout()
    self.SetTitle('Select run blocks')

    # Button bindings
    self.Bind(wx.EVT_BUTTON, self.onOK, id=wx.ID_OK)

  def onOK(self, e):
    trial_rungroups = [t.id for t in self.db.get_trial_rungroups(self.trial.id, only_active=False)]
    trials = self.db.get_all_trials()

    for i, rungroup in enumerate(self.all_rungroups):
      if self.runblocks_list.ctr.IsChecked(i):
        if not rungroup.id in trial_rungroups:
          self.trial.add_rungroup(rungroup)
        rungroup.active = True
      else:
        if rungroup.id in trial_rungroups:
          self.trial.remove_rungroup(rungroup)
        if not any([rungroup.id in [rg.id for rg in t.rungroups] for t in trials]):
          rungroup.active = False

    e.Skip()

class TrialDialog(BaseDialog):
  def __init__(self, parent, db,
               new=True,
               trial=None,
               label_style='bold',
               content_style='normal',
               *args, **kwargs):

    self.db = db
    self.new = new
    self.trial = trial
    self.all_trials = db.get_all_trials()

    BaseDialog.__init__(self, parent,
                        label_style=label_style,
                        content_style=content_style,
                        size=(600, 600),
                        *args, **kwargs)

    if trial is None:
      trials = [t.trial for t in self.all_trials]
      if len(trials) == 0:
        trial_number = 0
      else:
        trial_number = max(trials) + 1
      d_min = 1.5
    else:
      trial_number = trial.trial
      d_min = trial.d_min if trial.d_min is not None else 1.5

    self.trial_info = gctr.TwoButtonCtrl(self,
                                         label='Trial number:',
                                         label_size=(100, -1),
                                         label_style='bold',
                                         button1=True,
                                         button1_label='Import PHIL',
                                         button1_size=(120, -1),
                                         button2=True,
                                         button2_label='Default PHIL',
                                         button2_size=(120, -1),
                                         value="{}".format(trial_number))
    self.trial_comment = gctr.TextButtonCtrl(self,
                                             label='Comment:',
                                             label_size=(100, -1),
                                             label_style='bold',
                                             ghost_button=False)

    self.phil_box = gctr.RichTextCtrl(self, style=wx.VSCROLL, size=(-1, 400))

    choices = [('None', None)] + \
              [('Trial {}'.format(t.trial), t.trial) for t in self.all_trials]
    self.copy_runblocks = gctr.ChoiceCtrl(self,
                                          label='Copy runblocks from',
                                          label_style='normal',
                                          label_size=(180, -1),
                                          ctrl_size=(80, -1),
                                          choices=choices)
    self.copy_runblocks.ctr.SetSelection(0)
    self.throttle = gctr.SpinCtrl(self,
                                  name='trial_throttle',
                                  label='Percent events processed:',
                                  label_size=(180, -1),
                                  label_style='bold',
                                  ctrl_size=(150, -1),
                                  ctrl_value='100',
                                  ctrl_min=1,
                                  ctrl_max=100)
    self.num_bins = gctr.SpinCtrl(self,
                                  name='trial_num_bins',
                                  label='Number of bins:',
                                  label_size=(180, -1),
                                  label_style='bold',
                                  ctrl_size=(150, -1),
                                  ctrl_value='20',
                                  ctrl_min=1,
                                  ctrl_max=100,
                                  ctrl_step=1)
    self.d_min = gctr.SpinCtrl(self,
                               name='trial_d_min',
                               label='High res. limit ({}):'
                               ''.format(u'\N{ANGSTROM SIGN}'.encode('utf-8')),
                               label_size=(180, -1),
                               label_style='bold',
                               ctrl_size=(150, -1),
                               ctrl_value=str(d_min),
                               ctrl_min=0.1,
                               ctrl_max=100,
                               ctrl_step=0.1,
                               ctrl_digits=1)

    self.option_sizer = wx.FlexGridSizer(3, 2, 10, 20)
    self.option_sizer.AddMany([(self.copy_runblocks),
                               (0, 0),
                               (self.throttle),
                               (0, 0),
                               (self.num_bins),
                               (self.d_min)])

    self.main_sizer.Add(self.trial_info,
                        flag=wx.EXPAND | wx.TOP | wx.LEFT | wx.RIGHT,
                        border=10)
    self.main_sizer.Add(self.trial_comment,
                        flag=wx.EXPAND | wx.TOP | wx.LEFT | wx.RIGHT,
                        border=10)
    self.main_sizer.Add(self.phil_box, 1,
                        flag=wx.EXPAND | wx.TOP | wx.LEFT | wx.RIGHT,
                        border=10)
    self.main_sizer.Add(self.option_sizer, flag=wx.EXPAND | wx.ALL, border=10)


    # Dialog control
    if self.new:
      dialog_box = self.CreateSeparatedButtonSizer(wx.OK | wx.CANCEL)
    else:
      dialog_box = self.CreateSeparatedButtonSizer(wx.OK)
    self.main_sizer.Add(dialog_box,
                        flag=wx.EXPAND | wx.ALL,
                        border=10)

    self.Layout()

    if self.new:
      self.SetTitle('New Trial Settings')

      # If previous trials exist, propagate previous settings from them
      if len(self.all_trials) > 0:
        self.last_trial = self.all_trials[-1]
        target_phil_str = self.last_trial.target_phil_str
        self.trial_comment.ctr.SetValue(str(self.last_trial.comment))
        process_percent = self.last_trial.process_percent

      else:
        target_phil_str = ''
        process_percent = 100

    else:
      self.SetTitle('Trial {}'.format(self.trial.trial))
      target_phil_str = self.trial.target_phil_str
      self.trial_comment.ctr.SetValue(str(self.trial.comment))
      process_percent = self.trial.process_percent

      # Disable controls for viewing
      self.trial_info.button1.Disable()
      self.trial_info.button2.Disable()
      self.trial_info.ctr.SetEditable(False)
      self.copy_runblocks.Hide()
      self.phil_box.SetEditable(False)
      self.throttle.ctr.Disable()
      self.num_bins.ctr.Disable()
      self.d_min.ctr.Disable()

    if target_phil_str is None:
      target_phil_str = ""
    if process_percent is None:
      process_percent = 100
    self.phil_box.SetValue(target_phil_str)
    self.throttle.ctr.SetValue(process_percent)

    # Bindings
    self.Bind(wx.EVT_BUTTON, self.onBrowse, self.trial_info.button1)
    self.Bind(wx.EVT_BUTTON, self.onDefault, self.trial_info.button2)
    self.Bind(wx.EVT_BUTTON, self.onOK, id=wx.ID_OK)

  def onBrowse(self, e):
    ''' Open dialog for selecting PHIL file '''

    load_dlg = wx.FileDialog(self,
                             message="Load PHIL file",
                             defaultDir=os.curdir,
                             defaultFile="*.phil",
                             wildcard="*.phil",
                             style=wx.FD_OPEN | wx.FD_FILE_MUST_EXIST,
                             )
    if load_dlg.ShowModal() == wx.ID_OK:
      target_file = load_dlg.GetPaths()[0]
      with open(target_file, 'r') as phil_file:
        phil_file_contents = phil_file.read()
      self.phil_box.SetValue(phil_file_contents)
    load_dlg.Destroy()

  def onDefault(self, e):
    # TODO: Generate default PHIL parameters
    pass

  def onOK(self, e):
    if self.new:
      target_phil_str = self.phil_box.GetValue()

      # Parameter validation
      dispatcher = self.db.params.dispatcher
      from xfel.ui import load_phil_scope_from_dispatcher
      phil_scope = load_phil_scope_from_dispatcher(dispatcher)

      from iotbx.phil import parse
      msg = None
      try:
        trial_params, unused = phil_scope.fetch(parse(target_phil_str), track_unused_definitions = True)
      except Exception as e:
        msg = '\nParameters incompatible with %s dispatcher:\n%s\n' % (dispatcher, str(e))
      else:
        if len(unused) > 0:
          msg = [str(item) for item in unused]
          msg = '\n'.join(['  %s' % line for line in msg])
          msg = 'The following definitions were not recognized:\n%s\n' % msg

        try:
          params = trial_params.extract()
        except Exception as e:
          if msg is None: msg = ""
          msg += '\nOne or more values could not be parsed:\n%s\n' % str(e)

      if msg is not None:
        msg += '\nFix the parameters and press OK again'
        msgdlg = wx.MessageDialog(self,
                                  message=msg,
                                  caption='Warning',
                                  style=wx.OK |  wx.ICON_EXCLAMATION)
        msgdlg.ShowModal()
        return

      comment = self.trial_comment.ctr.GetValue()
      process_percent = int(self.throttle.ctr.GetValue())
      d_min = float(self.d_min.ctr.GetValue())
      n_bins = int(self.num_bins.ctr.GetValue())
      if process_percent == 100:
        process_percent = None

      if self.trial is None:
        self.db.create_trial(
          trial = int(self.trial_info.ctr.GetValue()),
          active = False,
          target_phil_str = target_phil_str,
          comment = comment,
          process_percent = process_percent,
          d_min = d_min,
          n_bins = n_bins)
        self.trial = self.db.get_trial(trial_number=int(self.trial_info.ctr.GetValue()))

        template_trial_number = self.copy_runblocks.ctr.GetClientData(
          self.copy_runblocks.ctr.GetSelection())

        if template_trial_number is not None:
          template_trial = self.db.get_trial(trial_number=template_trial_number)
          for block in template_trial.rungroups:
            self.trial.add_rungroup(block)

      else:
        self.trial.target_phil_str = target_phil_str
        self.trial.comment = comment
    else:
      if self.trial.comment != self.trial_comment.ctr.GetValue():
        self.trial.comment = self.trial_comment.ctr.GetValue()
    e.Skip()

class DatasetDialog(BaseDialog):
  def __init__(self, parent, db,
               new=True,
               dataset=None,
               label_style='bold',
               content_style='normal',
               *args, **kwargs):

    self.db = db
    self.new = new
    self.dataset = dataset

    BaseDialog.__init__(self, parent,
                        label_style=label_style,
                        content_style=content_style,
                        size=(600, 600),
                        *args, **kwargs)

    self.name = gctr.TextButtonCtrl(self,
                                    label='Name:',
                                    label_size=(100, -1),
                                    label_style='bold',
                                    ghost_button=False)

    self.comment = gctr.TextButtonCtrl(self,
                                       label='Comment:',
                                       label_size=(100, -1),
                                       label_style='bold',
                                       ghost_button=False)

    self.tag_checklist = gctr.CheckListCtrl(self,
                                        label='Tags:',
                                        label_size=(200, -1),
                                        label_style='normal',
                                        ctrl_size=(150, 100),
                                        direction='vertical',
                                        choices=[])

    self.selection_type_radio = gctr.RadioCtrl(self,
                                           label='',
                                           label_style='normal',
                                           label_size=(-1, -1),
                                           direction='horizontal',
                                           items={'inter':'intersection',
                                                  'union':'union'})

    self.main_sizer.Add(self.name,
                        flag=wx.EXPAND | wx.TOP | wx.LEFT | wx.RIGHT,
                        border=10)
    self.main_sizer.Add(self.comment,
                        flag=wx.EXPAND | wx.TOP | wx.LEFT | wx.RIGHT,
                        border=10)
    self.main_sizer.Add(self.tag_checklist,
                        flag=wx.EXPAND | wx.TOP | wx.LEFT | wx.RIGHT,
                        border=10)
    self.main_sizer.Add(self.selection_type_radio,
                        flag=wx.EXPAND | wx.TOP | wx.LEFT | wx.RIGHT,
                        border=10)

    # Dialog control
    dialog_box = self.CreateSeparatedButtonSizer(wx.OK | wx.CANCEL)
    self.main_sizer.Add(dialog_box,
                        flag=wx.EXPAND | wx.ALL,
                        border=10)

    self.Layout()

    if self.new:
      self.SetTitle('New Dataset Settings')
      self.selection_type_radio.inter.SetValue(1)
    else:
      self.SetTitle('Dataset Settings')
      self.name.ctr.SetValue(str(self.dataset.name))
      self.comment.ctr.SetValue(str(self.dataset.comment))
      if self.dataset.tag_operator == "union":
        self.selection_type_radio.union.SetValue(1)
      elif self.dataset.tag_operator == "intersection":
        self.selection_type_radio.inter.SetValue(1)
      else:
        assert False

    # Bindings
    self.Bind(wx.EVT_BUTTON, self.onOK, id=wx.ID_OK)

    # Initialize tag list
    self.all_tags = db.get_all_tags()
    tag_names = [t.name for t in self.all_tags]
    self.dataset_tagnames = [t.name for t in self.dataset.tags] if self.dataset is not None else []
    if tag_names:
      self.tag_checklist.ctr.InsertItems(items=tag_names, pos=0)
      checked = [tag_idx for tag_idx, tag_name in enumerate(tag_names) if tag_name in self.dataset_tagnames]
      self.tag_checklist.ctr.SetCheckedItems(checked)

  def onOK(self, e):
    name = self.name.ctr.GetValue()
    comment = self.comment.ctr.GetValue()
    if self.selection_type_radio.union.GetValue() == 1:
      mode = 'union'
    else:
      mode = 'intersection'

    if self.new:
      self.dataset = self.db.create_dataset(name = name,
                                            comment = comment,
                                            active = False,
                                            tag_operator = mode)
    else:
      self.dataset.name = name
      self.dataset.comment = comment
      self.dataset.tag_operator = mode

    checked = self.tag_checklist.ctr.GetCheckedItems()
    for tag_idx, tag in enumerate(self.all_tags):
      if tag_idx in checked:
        if tag.name not in self.dataset_tagnames:
          self.dataset.add_tag(tag)
      else:
        if tag.name in self.dataset_tagnames:
          self.dataset.remove_tag(tag)

    e.Skip()

class TaskDialog(BaseDialog):
  def __init__(self, parent, db,
               dataset=None,
               task=None,
               label_style='bold',
               content_style='normal',
               *args, **kwargs):

    self.db = db
    self.dataset = dataset
    self.task = task
    self.all_trials = db.get_all_trials()
    self.all_trial_numbers = [str(t.trial) for t in self.all_trials]

    BaseDialog.__init__(self, parent,
                        label_style=label_style,
                        content_style=content_style,
                        size=(600, 600),
                        *args, **kwargs)

    self.type = gctr.ChoiceCtrl(self,
                                label='Task type:',
                                label_size=(100, -1),
                                ctrl_size=(150, -1),
                                choices=task_types)

    self.trial = gctr.ChoiceCtrl(self,
                                 label='Trial:',
                                 label_size=(100, -1),
                                 ctrl_size=(150, -1),
                                 choices=self.all_trial_numbers)

    self.phil_box = gctr.RichTextCtrl(self, style=wx.VSCROLL, size=(550, 400))

    self.main_sizer.Add(self.type,
                        flag=wx.EXPAND | wx.TOP | wx.LEFT | wx.RIGHT,
                        border=10)
    self.main_sizer.Add(self.trial,
                        flag=wx.EXPAND | wx.TOP | wx.LEFT | wx.RIGHT,
                        border=10)
    self.main_sizer.Add(self.phil_box, 1,
                        flag=wx.EXPAND | wx.TOP | wx.LEFT | wx.RIGHT,
                        border=10)

    # Dialog control
    dialog_box = self.CreateSeparatedButtonSizer(wx.OK | wx.CANCEL)
    self.main_sizer.Add(dialog_box,
                        flag=wx.EXPAND | wx.ALL,
                        border=10)

    self.Layout()

    if task is None:
      self.SetTitle('New Task Settings')

      # If previous tasks exist, propagate previous settings from them
      # XXX
      self.type.ctr.SetSelection(0)
      self.trial.ctr.SetSelection(0)
    else:
      self.SetTitle('Task Settings')
      self.type.ctr.SetSelection(task_types.index(self.task.type))
      self.trial.ctr.SetSelection(self.all_trial_numbers.index(str(self.task.trial.trial)))
      if self.task.parameters is not None:
        self.phil_box.SetValue(self.task.parameters)

    # Bindings
    self.Bind(wx.EVT_BUTTON, self.onOK, id=wx.ID_OK)

  def onOK(self, e):
    task_type = self.type.ctr.GetStringSelection()
    # Remember, a trial number doesn't necessarily match its id and they are not guaranteed to be consecutive
    trial = self.all_trials[self.all_trial_numbers.index(self.trial.ctr.GetStringSelection())]
    parameters = self.phil_box.GetValue()

    # Parameter validation
    from xfel.ui.db.task import Task
    from iotbx.phil import parse
    dispatcher, phil_scope = Task.get_phil_scope(self.db, task_type)

    if phil_scope is not None:
      msg = None
      try:
        task_params, unused = phil_scope.fetch(parse(parameters), track_unused_definitions = True)
      except Exception as e:
        msg = '\nParameters incompatible with %s dispatcher:\n%s\n' % (dispatcher, str(e))
      else:
        if len(unused) > 0:
          msg = [str(item) for item in unused]
          msg = '\n'.join(['  %s' % line for line in msg])
          msg = 'The following definitions were not recognized:\n%s\n' % msg

        try:
          params = task_params.extract()
        except Exception as e:
          if msg is None: msg = ""
          msg += '\nOne or more values could not be parsed:\n%s\n' % str(e)

      if msg is not None:
        msg += '\nFix the parameters and press OK again'
        msgdlg = wx.MessageDialog(self,
                                  message=msg,
                                  caption='Warning',
                                  style=wx.OK |  wx.ICON_EXCLAMATION)
        msgdlg.ShowModal()
        return

    if self.task is None:
      task = self.db.create_task(type = task_type,
                                 trial_id = trial.id,
                                 parameters = parameters)
      self.dataset.add_task(task)
    else:
      self.task.type = task_type
      self.task.trial_id = trial.id
      self.task.parameters = parameters

    e.Skip()

class SelectTasksDialog(BaseDialog):
  def __init__(self, parent, dataset,
               label_style='bold',
               content_style='normal',
               db=None,
               *args, **kwargs):
    BaseDialog.__init__(self, parent, label_style=label_style,
                        content_style=content_style, *args, **kwargs)

    self.db = db
    self.dataset = dataset

    self.top_sizer = wx.BoxSizer(wx.HORIZONTAL)

    self.button_panel = wx.Panel(self)
    self.button_sizer = wx.BoxSizer(wx.VERTICAL)
    self.button_panel.SetSizer(self.button_sizer)

    self.tasks_panel = ScrolledPanel(self, size=(500, 400))

    # Populate tasks with current values from db
    self.dataset_tasks = [t for t in dataset.tasks]
    self.dataset_task_ids = [t.id for t in self.dataset_tasks]
    self.all_tasks = self.db.get_all_tasks()
    choices = []
    selected = []
    for task in self.all_tasks:
      selected.append(task.id in self.dataset_task_ids)
      desc = "[%d] %s"%(task.id, task.type)
      if task.trial is not None:
        desc += " (trial %d)"%task.trial.trial

      choices.append(desc)

    self.tasks_list = gctr.CheckListCtrl(self.tasks_panel,
                                         label='Select tasks',
                                         label_size=(40, -1),
                                         label_style='normal',
                                         ctrl_size=(450, 350),
                                         direction='vertical',
                                         choices=choices)
    for i in range(len(selected)):
      self.tasks_list.ctr.Check(i, selected[i])

    self.tasks_sizer = wx.BoxSizer(wx.VERTICAL)
    self.tasks_panel.SetSizer(self.tasks_sizer)

    self.tasks_sizer.Add(self.tasks_list, 1, flag=wx.EXPAND)

    # Add panels to main sizer
    self.top_sizer.Add(self.button_panel,
                       flag=wx.LEFT, border=10)
    self.top_sizer.Add(self.tasks_panel,
                       flag=wx.EXPAND | wx.RIGHT | wx.LEFT, border=10)
    self.main_sizer.Add(self.top_sizer,
                        flag=wx.EXPAND| wx.TOP | wx.BOTTOM, border=10)
    # Dialog control
    dialog_box = self.CreateSeparatedButtonSizer(wx.OK | wx.CANCEL)
    self.main_sizer.Add(dialog_box,
                   flag=wx.EXPAND | wx.ALL,
                   border=10)

    self.Layout()
    self.SetTitle('Select tasks')

    # Button bindings
    self.Bind(wx.EVT_BUTTON, self.onOK, id=wx.ID_OK)

  def onOK(self, e):
    for task in self.dataset_tasks:
      self.dataset.remove_task(task)

    for i, task in enumerate(self.all_tasks):
      if self.tasks_list.ctr.IsChecked(i):
        self.dataset.add_task(task)

    e.Skip()


 *******************************************************************************


 *******************************************************************************
xfel/ui/components/xfel_gui_init.py
from __future__ import absolute_import, division, print_function
from six.moves import range, zip, map

'''
Author      : Lyubimov, A.Y.
Created     : 06/02/2016
Last Changed: 02/09/2017
Description : XFEL UI Initialization module
'''

import os
import wx
import time
import numpy as np
from threading import Thread
from wx.lib.scrolledpanel import ScrolledPanel
from libtbx import easy_run

try:
  from MySQLdb import OperationalError # test import
except ImportError:
  from libtbx.utils import Sorry
  raise Sorry('Mysql not available')

from xfel.clustering.cluster import Cluster
import xfel.ui.components.xfel_gui_controls as gctr
import xfel.ui.components.xfel_gui_dialogs as dlg
import xfel.ui.components.xfel_gui_plotter as pltr

from xfel.ui import load_cached_settings, save_cached_settings
from xfel.ui.db import get_run_path
from xfel.ui.db.xfel_db import xfel_db_application

from prime.postrefine.mod_gui_frames import PRIMEInputWindow, PRIMERunWindow
from prime.postrefine.mod_input import master_phil
from iota.utils.utils import Capturing, set_base_dir

icons = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'icons/')

import getpass
user = getpass.getuser()

import libtbx.load_env
license = libtbx.env.under_root(os.path.join("modules","cctbx_project","LICENSE.txt"))
if not os.path.exists(license):
  license = libtbx.env.under_root(os.path.join("cctbx", "LICENSE.txt")) # conda installations

description = 'The cctbx.xfel UI is developed for use during data collection ' \
              'and initial processing of serial crystallographic data from' \
              'XFELs and synchrotrons.'

class TagSet(object):
  def __init__(self, tag_selection_mode, tags):
    assert tag_selection_mode in ['union', 'intersection']
    self.mode = tag_selection_mode
    self.tags = tags
  def __str__(self):
    if len(self.tags) > 1:
      return ", ".join([t.name for t in self.tags]) + (' (%s)' % self.mode[0])
    else:
      return ", ".join([t.name for t in self.tags])


# ------------------------------- Run Sentinel ------------------------------- #

# Set up events for and for finishing all cycles
tp_EVT_RUN_REFRESH = wx.NewEventType()
EVT_RUN_REFRESH = wx.PyEventBinder(tp_EVT_RUN_REFRESH, 1)

class RefreshRuns(wx.PyCommandEvent):
  ''' Send event when finished all cycles  '''
  def __init__(self, etype, eid):
    wx.PyCommandEvent.__init__(self, etype, eid)

class RunSentinel(Thread):
  ''' Worker thread for runs; generated so that the GUI does not lock up when
      processing is running '''

  def __init__(self,
               parent,
               active=True):
    Thread.__init__(self)
    self.parent = parent
    self.active = active

    if self.parent.params.facility.name == 'standalone':
      if self.parent.params.facility.standalone.monitor_for == 'folders' and \
         self.parent.params.facility.standalone.folders.method == 'status_file':
        from xfel.ui.db.xfel_db import cheetah_run_finder
        self.finder = cheetah_run_finder(self.parent.params)
      else:
        from xfel.ui.db.xfel_db import standalone_run_finder
        self.finder = standalone_run_finder(self.parent.params)

  def post_refresh(self):
    evt = RefreshRuns(tp_EVT_RUN_REFRESH, -1)
    wx.PostEvent(self.parent.run_window.runs_tab, evt)
    wx.PostEvent(self.parent.run_window.trials_tab, evt)

  def run(self):
    # one time post for an initial update
    self.post_refresh()
    db = xfel_db_application(self.parent.params)
    use_ids = self.parent.params.facility.name not in ['lcls']

    while self.active:
      try:
        # Find the delta
        known_runs = [r.run for r in db.get_all_runs()]
        if self.parent.params.facility.name == 'lcls':
          unknown_run_runs = [str(run['run']) for run in db.list_lcls_runs() if
                              str(run['run']) not in known_runs]
          unknown_run_paths = [''] * len(unknown_run_runs)
        elif self.parent.params.facility.name == 'standalone':
          standalone_runs = [run for run in self.finder.list_runs() if
                             run[0] not in known_runs]
          unknown_run_runs = [r[0] for r in standalone_runs]
          unknown_run_paths = [r[1] for r in standalone_runs]

        if len(unknown_run_runs) > 0:
          for run_run, run_path in zip(unknown_run_runs, unknown_run_paths):
            db.create_run(run = run_run, path = run_path)
          new_runs = [r for r in db.get_all_runs() if r.run in unknown_run_runs]
          if len(self.parent.run_window.runs_tab.persistent_tags) > 0:
            tags = [t for t in db.get_all_tags() if t.name in self.parent.run_window.runs_tab.persistent_tags]
            for r in new_runs:
              for t in tags:
                r.add_tag(t)
          # Sync new runs to rungroups
          for rungroup in db.get_all_rungroups(only_active=True):
            first_run, last_run = rungroup.get_first_and_last_runs()
            # HACK: to get working -- TODO: make nice
            if use_ids:
              first_run = first_run.id
              last_run = last_run.id if last_run is not None else None
            else:
              first_run = int(first_run.run)
              last_run = int(last_run.run) if last_run is not None else None
            rungroup.sync_runs(first_run, last_run, use_ids=use_ids)

          print("%d new runs" % len(unknown_run_runs))
          self.post_refresh()
        time.sleep(10)
      except Exception as e:
        print(e)
        self.parent.run_window.run_light.change_status('alert')
        break


# ------------------------------ Calib Worker ------------------------------ #

# Set up events for updating calibration results
tp_EVT_ENERGY_DONE = wx.NewEventType()
EVT_ENERGY_DONE = wx.PyEventBinder(tp_EVT_ENERGY_DONE, 1)

class CalibWorker(Thread):
  ''' Worker thread to execute calibrations in the background without locking
      up the GUI'''

  def __init__(self,
               parent,
               active=True):
    Thread.__init__(self)
    self.parent = parent
    self.active = active

  def post_refresh_energy(self):
    evt = RefreshRuns(tp_EVT_ENERGY_DONE, -1)
    wx.PostEvent(self.energy_tab, evt)

  def run(self):
    # one time setup
    self.energy_tab = self.parent.run_window.energy_tab
    self.db = xfel_db_application(self.parent.params)

    from serialtbx.util.energy_scan_notch_finder import notch_phil_string
    from xfel.command_line.fee_calibration import fee_phil_string
    from libtbx.phil import parse
    self.fee_params = parse(notch_phil_string + fee_phil_string).extract()
    self.energy_tab.refresh_runs()

    while self.active:
      self.parent.run_window.calib_light.change_status('idle') # yellow -- actually means working
      try:
        if self.energy_tab.fee_calib_stale:
          self.run_fee_calib()
          self.post_refresh_energy()
        if self.energy_tab.ebeam_calib_stale:
          self.run_ebeam_calib()
          self.post_refresh_energy()
        self.parent.run_window.calib_light.change_status('on') # green-- actually means idle
        time.sleep(1)
      except Exception as e:
        print(e)
        self.parent.run_window.calib_light.change_status('alert') # red -- means crashed
        break

  def run_fee_calib(self):
    from serialtbx.util.energy_scan_notch_finder import find_notch, plot_notches, calibrate_energy
    from xfel.command_line.fee_calibration import tally_fee_data

    runs = self.energy_tab.fee_runs
    energies = self.energy_tab.fee_energies
    rundata = tally_fee_data(self.energy_tab.experiment, runs, plot=False, verbose=True, max_events=self.energy_tab.max_events)
    notches = [find_notch(range(len(data)),
                          data,
                          self.fee_params.kernel_size,
                          self.fee_params.fit_half_range,
                          self.fee_params.baseline_cutoff)
              for data in rundata]

    plot_notches(runs,
                 rundata,
                 notches,
                 per_run_plots=False,
                 use_figure=self.energy_tab.spectra_figure)
    offset, per_px = calibrate_energy(notches,
                                      energies,
                                      use_figure=self.energy_tab.trendline_figure)
    self.energy_tab.spectra_figure.canvas.draw_idle()
    self.energy_tab.trendline_figure.canvas.draw_idle()

    self.energy_tab.fee_eV_offset = offset
    self.energy_tab.fee_eV_per_pixel = per_px
    self.energy_tab.eV_offset_text.SetLabel(f'{offset:.4f} eV')
    self.energy_tab.eV_per_px_text.SetLabel(f'{per_px:.4f} eV')
    self.energy_tab.fee_calib_stale = False

  def run_ebeam_calib(self, source='loc'):
    from xfel.ui.components.ebeam_plotter import compare_ebeams_with_fees

    run_strings = self.energy_tab.selected_runs

    if not hasattr(self, 'loc_dir'):
      results_dir = self.parent.params.output_folder
      energy_dir = os.path.join(results_dir, '..', 'energy')
      if os.path.exists(energy_dir):
        self.loc_dir = energy_dir
      else:
        try:
          os.mkdir(energy_dir)
          self.loc_dir = energy_dir
        except Exception:
          loc_dir = os.path.join(results_dir, 'locs')
          os.mkdir(loc_dir)
          self.loc_dir = loc_dir

    loc_parts = []
    if self.energy_tab.experiment is None:
      print("Experiment not set")
      return
    loc_parts.append(f'experiment={self.energy_tab.experiment}')
    if self.energy_tab.fee_eV_offset is None:
      print("Calibrate spectrometer first")
      return

    loc_parts.append(f'spectrum_eV_offset={self.energy_tab.fee_eV_offset:.2f}')
    loc_parts.append(f'spectrum_eV_per_pixel={self.energy_tab.fee_eV_per_pixel:.2f}')

    runs = [run for run in self.db.get_all_runs() if str(run.run) in run_strings]
    locfiles = []
    reordered_run_strings = []
    for run in runs:
      try:
        this_loc_parts = loc_parts[::]
        this_loc_parts.append(f'run={run.run}')
        try:
          rungroup = run.get_rungroups()[-1]
        except Exception:
          print(f'Run {run.run} does not appear to be in any rungroup. Skipping.')
          continue
        det_addr = rungroup.detector_address
        this_loc_parts.append(f'detector_address={det_addr}')
        if 'rayonix' in det_addr:
          this_loc_parts.append(f'rayonix.bin_size={rungroup.binning}')
        loc_path = os.path.join(self.loc_dir, f'{run.run}.loc')
        with open(loc_path, 'w') as locf:
          locf.write('\n'.join(this_loc_parts))
        locfiles.append(loc_path)
        reordered_run_strings.append(str(run.run))
      except Exception as e:
        print('Failed to load ebeam for run {run.run}')
        print(e)
        continue

    if len(locfiles) == 0:
      print('No runs to compare.')
      return

    self.energy_tab.ebeam_figure.clear()
    ebeam_eV_offset, ebeam_wavelength_offset = compare_ebeams_with_fees(
      locfiles,
      runs=reordered_run_strings,
      plot=True,
      use_figure=self.energy_tab.ebeam_figure,
      max_events=self.energy_tab.max_events)
    self.energy_tab.ebeam_figure.canvas.draw_idle()

    if ebeam_eV_offset is not None:
      self.energy_tab.ebeam_eV_offset = ebeam_eV_offset
      self.energy_tab.ebeam_wavelength_offset = ebeam_wavelength_offset
      ang = u'\u212b' # Angstrom
      self.energy_tab.ebeam_offset_text.SetLabel(f'{ebeam_eV_offset:.2f} eV ({ebeam_wavelength_offset:.6f} {ang})')
      self.energy_tab.ebeam_calib_stale = False

    #try:
    #  locfile = os.path.join(db.params.output_folder, f'r{run.run:04d}', f'{trial.trial:03d}_rg{rg.rungroup_id:03d', 'data.loc')
    #except ValueError: # in case of non-numeric run names
    #  locfile = os.path.join(db.params.output_folder, f'r{run.run}', f'{trial.trial:03d}_rg{rg.rungroup_id:03d', 'data.loc')

# ------------------------------- Job Monitor ------------------------------- #

# Set up events for and for finishing all cycles
tp_EVT_JOB_MONITOR = wx.NewEventType()
EVT_JOB_MONITOR = wx.PyEventBinder(tp_EVT_JOB_MONITOR, 1)

class MonitorJobs(wx.PyCommandEvent):
  ''' Send event when finished all cycles  '''

  def __init__(self, etype, eid, trials = None, jobs = None):
    wx.PyCommandEvent.__init__(self, etype, eid)
    self.trials = trials
    self.jobs = jobs

class JobMonitor(Thread):
  ''' Monitor thread for jobs; generated so that the GUI does not lock up when
      monitoring is running '''

  def __init__(self,
               parent,
               active=True):
    Thread.__init__(self)
    self.parent = parent
    self.active = active
    self.only_active_jobs = True

  def post_refresh(self, trials = None, jobs = None):
    evt = MonitorJobs(tp_EVT_JOB_MONITOR, -1, trials, jobs)
    wx.PostEvent(self.parent.run_window.jobs_tab, evt)

  def run(self):
    from xfel.ui.components.submission_tracker import TrackerFactory

    # one time post for an initial update
    self.post_refresh()

    db = xfel_db_application(self.parent.params)
    tracker = TrackerFactory.from_params(self.parent.params)

    while self.active:
      try:
        self.parent.run_window.jmn_light.change_status('idle')

        trials = db.get_all_trials()
        jobs = db.get_all_jobs(active = self.only_active_jobs)

        for job in jobs:
          if job.status in ['DONE', 'EXIT', 'SUBMIT_FAIL', 'DELETED']:
            continue
          new_status = tracker.track(job.submission_id, job.get_log_path())
          # Handle the case where the job was submitted but no status is available yet
          if job.status == "SUBMITTED" and new_status == "ERR":
            pass
          elif job.status != new_status:
            job.status = new_status

        self.post_refresh(trials, jobs)
        self.parent.run_window.jmn_light.change_status('on')
        time.sleep(5)
      except Exception as e:
        print(e)
        self.parent.run_window.jmn_light.change_status('alert')
        break


# ------------------------------- Job Sentinel ------------------------------- #

# Set up events for and for finishing all cycles
tp_EVT_JOB_REFRESH = wx.NewEventType()
EVT_JOB_REFRESH = wx.PyEventBinder(tp_EVT_JOB_REFRESH, 1)

class RefreshJobs(wx.PyCommandEvent):
  ''' Send event when finished all cycles  '''
  def __init__(self, etype, eid):
    wx.PyCommandEvent.__init__(self, etype, eid)

class JobSentinel(Thread):
  ''' Worker thread for jobs; generated so that the GUI does not lock up when
      processing is running '''

  def __init__(self,
               parent,
               active=True):
    Thread.__init__(self)
    self.parent = parent
    self.active = active

  def post_refresh(self):
    pass

  def run(self):
    # one time post for an initial update
    self.post_refresh()
    db = xfel_db_application(self.parent.params)

    from xfel.ui.db.job import submit_all_jobs

    while self.active:
      try:
        submit_all_jobs(db)
        self.post_refresh()
        time.sleep(2)
      except Exception as e:
        print(e)
        self.parent.run_window.job_light.change_status('alert')
        break

# ----------------------------- Progress Sentinel ---------------------------- #

# Set up events for and for finishing all cycles
tp_EVT_PRG_REFRESH = wx.NewEventType()
EVT_PRG_REFRESH = wx.PyEventBinder(tp_EVT_PRG_REFRESH, 1)

class RefreshStats(wx.PyCommandEvent):
  ''' Send event when finished all cycles  '''
  def __init__(self, etype, eid, result=None):
    wx.PyCommandEvent.__init__(self, etype, eid)
    self.result = result
  def GetValue(self):
    return self.result

class ProgressSentinel(Thread):
  ''' Worker thread for jobs; generated so that the GUI does not lock up when
      processing is running '''

  def __init__(self,
               parent,
               active=True):
    Thread.__init__(self)
    self.parent = parent
    self.active = active
    self.output = self.parent.params.output_folder
    self.number_of_pickles = 0
    self.info = {}
    self.noiso_cells = []

    # on initialization (and restart), make sure stats drawn from scratch
    self.parent.run_window.status_tab.redraw_windows = True

  def post_refresh(self):
    evt = RefreshStats(tp_EVT_PRG_REFRESH, -1, self.info)
    wx.PostEvent(self.parent.run_window.status_tab, evt)

  def run(self):
    # one time post for an initial update
    self.post_refresh()
    db = xfel_db_application(self.parent.params)

    while self.active:
      try:
        self.parent.run_window.prg_light.change_status('idle')

        if len(db.get_all_trials()) > 0:
          trial = db.get_trial(
            trial_number=self.parent.run_window.status_tab.trial_no)

          trial_has_isoforms = len(trial.isoforms) > 0

          tags = self.parent.run_window.status_tab.selected_tags
          tag_ids = [tag.id for tag in tags]
          cells = db.get_stats(trial=trial, tags=tags, isigi_cutoff = self.parent.run_window.status_tab.isigi_cutoff)()

          if self.parent.run_window.status_tab.tag_trial_changed:
            self.parent.run_window.status_tab.redraw_windows = True
            self.parent.run_window.status_tab.tag_trial_changed = False

          run_numbers = []
          runs = []
          for rb in trial.rungroups:
            for run in rb.runs:
              if run.run not in run_numbers:
                if len(tags) > 0:
                  for tag in run.tags:
                    if tag.id in tag_ids:
                      run_numbers.append(run.run)
                      runs.append(run)
                else:
                  run_numbers.append(run.run)
                  runs.append(run)
          if not trial_has_isoforms:
            n_img = len(db.get_all_events(trial, runs))

          for cell in cells:
            # Check for cell isoform
            if cell.isoform is None:
              self.noiso_cells.append({'a':cell.cell_a,
                                       'b':cell.cell_b,
                                       'c':cell.cell_c,
                                       'alpha':cell.cell_alpha,
                                       'beta':cell.cell_beta,
                                       'gamma':cell.cell_gamma,
                                       'n_img':n_img})
            else:
              current_rows = self.parent.run_window.status_tab.rows
              if current_rows != {}:
                if cell.isoform._db_dict['name'] in current_rows:
                  bins = cell.bins[
                         :int(current_rows[cell.isoform._db_dict['name']]['high_bin'])]
                  highest_bin = cell.bins[int(current_rows[cell.isoform._db_dict['name']]['high_bin'])]
                else:
                  assert False, "This isoform is not available yet"
              else:
                bins = cell.bins
                d_mins = [b.d_min for b in bins]
                highest_bin = bins[d_mins.index(min(d_mins))]

              counts_all = [int(i.count) for i in bins]
              totals_all = [int(i.total_hkl) for i in bins]
              counts_highest = int(highest_bin.count)
              totals_highest = int(highest_bin.total_hkl)

              # Apply throttle to multiplicity calculation
              if trial.process_percent is None:
                process_percent = 100
              else:
                process_percent = trial.process_percent

              n_img = len(db.get_all_events(trial, runs, isoform = cell.isoform))

              # Generate multiplicity graph for isoforms
              mult_all = sum(counts_all) / sum(totals_all) / (process_percent / 100)
              mult_highest = counts_highest / totals_highest / (process_percent / 100)
              self.info[cell.isoform._db_dict['name']] = {'multiplicity_all':mult_all,
                                              'multiplicity_highest':mult_highest,
                                              'bins':bins,
                                              'isoform':cell.isoform._db_dict['name'],
                                              'a':cell.cell_a,
                                              'b':cell.cell_b,
                                              'c':cell.cell_c,
                                              'alpha':cell.cell_alpha,
                                              'beta':cell.cell_beta,
                                              'gamma':cell.cell_gamma,
                                              'n_img':n_img}
          #if len(self.noiso_cells) > 0:
          if len(self.info) == 0 and len(self.noiso_cells) > 0:
            sum_n_img = sum([cell['n_img'] for cell in self.noiso_cells])
            mean_a = sum([cell['n_img']*cell['a'] for cell in self.noiso_cells])/sum_n_img
            mean_b = sum([cell['n_img']*cell['b'] for cell in self.noiso_cells])/sum_n_img
            mean_c = sum([cell['n_img']*cell['c'] for cell in self.noiso_cells])/sum_n_img
            mean_alpha = sum([cell['n_img']*cell['alpha'] for cell in self.noiso_cells])/sum_n_img
            mean_beta  = sum([cell['n_img']*cell['beta']  for cell in self.noiso_cells])/sum_n_img
            mean_gamma = sum([cell['n_img']*cell['gamma'] for cell in self.noiso_cells])/sum_n_img
            noiso_entry = {'multiplicity_all':0,
                           'multiplicity_highest':0,
                           'bins':None,
                           'isoform':None,
                           'a':mean_a,
                           'b':mean_b,
                           'c':mean_c,
                           'alpha':mean_alpha,
                           'beta':mean_beta,
                           'gamma':mean_gamma,
                           'n_img':sum_n_img}
            self.info['noiso'] = noiso_entry
        self.post_refresh()
        self.info = {}
        self.parent.run_window.prg_light.change_status('on')
        time.sleep(5)
      except Exception as e:
        print(e)
        self.parent.run_window.prg_light.change_status('alert')
        break

# ----------------------------- Run Stats Sentinel ---------------------------- #

# Set up events for monitoring hitrate, indexing rate and I/sig(I)
tp_EVT_RUNSTATS_REFRESH = wx.NewEventType()
EVT_RUNSTATS_REFRESH = wx.PyEventBinder(tp_EVT_RUNSTATS_REFRESH, 1)

class RefreshRunStats(wx.PyCommandEvent):
  ''' Send event when finished all cycles  '''
  def __init__(self, etype, eid, result=None):
    wx.PyCommandEvent.__init__(self, etype, eid)
    self.result = result
  def GetValue(self):
    return self.result

class RunStatsSentinel(Thread):
  ''' Worker thread for run stats; generated so that the GUI does not lock up when
      processing is running '''

  def __init__(self,
               parent,
               active=True):
    Thread.__init__(self)
    self.parent = parent
    self.active = active
    self.output = self.parent.params.output_folder
    self.number_of_pickles = 0
    self.info = {}
    self.run_numbers = []
    self.stats = []
    self.run_tags = []
    self.run_statuses = []

  def post_refresh(self):
    evt = RefreshRunStats(tp_EVT_RUNSTATS_REFRESH, -1, self.info)
    wx.PostEvent(self.parent.run_window.runstats_tab, evt)

  def run(self):
    # one time post for an initial update
    self.post_refresh()
    self.db = xfel_db_application(self.parent.params)

    while self.active:
      try:
        self.parent.run_window.runstats_light.change_status('idle')
        self.plot_stats()
        self.fetch_timestamps(indexed=True)
        self.fetch_timestamps(indexed=False)
        self.post_refresh()
        self.info = {}
        self.parent.run_window.runstats_light.change_status('on')
        time.sleep(5)
      except Exception as e:
        print(e)
        self.parent.run_window.runstats_light.change_status('alert')
        break

  def refresh_stats(self):
    #from xfel.ui.components.timeit import duration
    from xfel.ui.db.stats import HitrateStats
    import copy, time
    t1 = time.time()
    if self.parent.run_window.runstats_tab.trial_no is not None:
      trial = self.db.get_trial(
        trial_number=self.parent.run_window.runstats_tab.trial_no)
      selected_runs = copy.deepcopy(self.parent.run_window.runstats_tab.selected_runs)
      self.run_numbers = []
      trial_ids = []
      rungroup_ids = []
      self.stats = []
      self.trgr = {}
      self.run_tags = []
      self.run_statuses = []
      for rg in trial.rungroups:
        for run in rg.runs:
          if run.run not in self.run_numbers and run.run in selected_runs:
            self.run_numbers.append(run.run)
            trial_ids.append(trial.id)
            rungroup_ids.append(rg.id)
            self.trgr[run.run] = (trial, rg, run)
            self.stats.append(HitrateStats(self.db, run.run, trial.trial, rg.id,
                                           i_sigi_cutoff=self.parent.run_window.runstats_tab.i_sigi,
                                           d_min=self.parent.run_window.runstats_tab.d_min)())
            self.run_tags.append([tag.name for tag in run.tags])

      jobs = self.db.get_all_jobs()
      for idx in range(len(self.run_numbers)):
        run_no = self.run_numbers[idx]
        rg_id = rungroup_ids[idx]
        t_id = trial_ids[idx]
        found_it = False
        for job in jobs:
          try:
            ok = job.run.run == run_no and job.rungroup.id == rg_id and job.trial.id == t_id
          except AttributeError:
            pass
          else:
            if ok:
              self.run_statuses.append(job.status)
              found_it = True; break
        if not found_it: self.run_statuses.append('UNKWN')
    t2 = time.time()

  def get_xtc_process_params_for_run(self, trial, rg, run):
    params = {}
    params['experiment'] = str(self.parent.db.params.facility.lcls.experiment)
    try:
      params['output_dir'] = os.path.join(str(self.parent.db.params.output_folder),
        "r%04d"%(int(run.run)), "%03d_rg%03d"%(trial.trial, rg.rungroup_id), "all")
    except ValueError:
      params['output_dir'] = os.path.join(str(self.parent.db.params.output_folder),
        "r%s"%(run.run), "%03d_rg%03d"%(trial.trial, rg.rungroup_id), "all")
    params['run'] = run.run
    params['address'] = rg.detector_address
    params['format'] = rg.format
    params['config'] = rg.config_str if hasattr(rg, 'config_str') else None
    params['beamx'] = rg.beamx if hasattr(rg, 'beamx') else None
    params['beamy'] = rg.beamy if hasattr(rg, 'beamy') else None
    params['distance'] = rg.detz_parameter if hasattr(rg, 'detz_parameter') else None
    params['bin_size'] = rg.binning if hasattr(rg, 'binning') else None
    params['energy'] = rg.energy if hasattr(rg, 'energy') else None
    params['gain_mask_level'] = rg.gain_mask_level if hasattr(rg, 'gain_mask_level') else None
    return params

  def fetch_timestamps(self, indexed=False):
    from xfel.ui.components.run_stats_plotter import \
      get_multirun_should_have_indexed_timestamps, get_paths_from_timestamps, get_strings_from_timestamps
    runs, timestamps = \
      get_multirun_should_have_indexed_timestamps(self.stats,
                                                  self.run_numbers,
                                                  self.parent.run_window.runstats_tab.d_min,
                                                  self.parent.run_window.runstats_tab.n_strong,
                                                  indexed=indexed)

    image_paths_by_run = []
    timestamps_and_params_by_run = []
    for i in range(len(runs)):
      run = runs[i]
      ts = timestamps[i]
      outdir = "out" if indexed else "all"
      prepend = os.path.join(get_run_path(self.output, *self.trgr[run]), outdir)
      tag = "idx" if indexed else "shot"
      image_paths = get_paths_from_timestamps(ts, prepend=prepend, tag=tag, ext=self.trgr[run][1].format)
      image_paths_by_run.append(image_paths)
      timestamp_strings = get_strings_from_timestamps(ts, long_form=True)
      timestamps_and_params_by_run.append((self.get_xtc_process_params_for_run(*self.trgr[run]), timestamp_strings))
    if indexed:
      self.parent.run_window.runstats_tab.strong_indexed_image_timestamps = \
        timestamps_and_params_by_run
      self.parent.run_window.runstats_tab.strong_indexed_image_paths = \
        image_paths_by_run
    else:
      self.parent.run_window.runstats_tab.should_have_indexed_timestamps = \
        timestamps_and_params_by_run
      self.parent.run_window.runstats_tab.should_have_indexed_image_paths = \
        image_paths_by_run

  def plot_stats(self):
    from xfel.ui.components.run_stats_plotter import plot_multirun_stats
    self.refresh_stats()
    sizex, sizey = self.parent.run_window.runstats_tab.runstats_panelsize
    figure = self.parent.run_window.runstats_tab.figure
    figure.clear()
    plot_multirun_stats(
      self.stats, self.run_numbers,
      d_min=self.parent.run_window.runstats_tab.d_min,
      n_multiples=self.parent.run_window.runstats_tab.n_multiples,
      interactive=True,
      ratio_cutoff=self.parent.run_window.runstats_tab.ratio,
      n_strong_cutoff=self.parent.run_window.runstats_tab.n_strong,
      i_sigi_cutoff=self.parent.run_window.runstats_tab.i_sigi,
      run_tags=self.run_tags,
      run_statuses=self.run_statuses,
      minimalist=self.parent.run_window.runstats_tab.entire_expt,
      xsize=(sizex-25)/85, ysize=(sizey-25)/95,
      high_vis=self.parent.high_vis,
      figure=figure)
      # convert px to inches with fudge factor for scaling inside borders
    figure.canvas.draw_idle()

# ----------------------------- Spotfinder Sentinel ---------------------------- #

# Set up events for monitoring spotfinder results against a set threshold
tp_EVT_SPOTFINDER_REFRESH = wx.NewEventType()
EVT_SPOTFINDER_REFRESH = wx.PyEventBinder(tp_EVT_SPOTFINDER_REFRESH, 1)

class RefreshSpotfinder(wx.PyCommandEvent):
  ''' Send event when finished all cycles  '''
  def __init__(self, etype, eid, result=None):
    wx.PyCommandEvent.__init__(self, etype, eid)
    self.result = result
  def GetValue(self):
    return self.result

class SpotfinderSentinel(Thread):
  ''' Worker thread for spotfinder stats; generated so that the GUI does not lock up when
      processing is running '''

  def __init__(self,
               parent,
               active=True):
    Thread.__init__(self)
    self.parent = parent
    self.active = active
    self.output = self.parent.params.output_folder
    self.number_of_pickles = 0
    self.info = {}
    self.run_numbers = []
    self.stats = []
    self.spot_length_stats = []
    self.run_tags = []
    self.run_statuses = []

    # on initialization (and restart), make sure spotfinder stats drawn from scratch
    self.parent.run_window.spotfinder_tab.redraw_windows = True

  def post_refresh(self):
    evt = RefreshSpotfinder(tp_EVT_SPOTFINDER_REFRESH, -1, self.info)
    wx.PostEvent(self.parent.run_window.spotfinder_tab, evt)

  def run(self):
    # one time post for an initial update
    self.post_refresh()
    self.db = xfel_db_application(self.parent.params)

    while self.active:
      try:
        self.parent.run_window.spotfinder_light.change_status('idle')
        self.plot_stats_static()
        self.post_refresh()
        self.info = {}
        self.parent.run_window.spotfinder_light.change_status('on')
        time.sleep(5)
      except Exception as e:
        print(e)
        self.parent.run_window.spotfinder_light.change_status('alert')
        break

  def refresh_stats(self):
    from xfel.ui.db.stats import SpotfinderStats
    from xfel.ui.components.spotfinder_scraper import get_spot_length_stats
    import copy
    if self.parent.run_window.spotfinder_tab.trial_no is not None:
      trial = self.db.get_trial(
        trial_number=self.parent.run_window.spotfinder_tab.trial_no)
      selected_runs = copy.deepcopy(self.parent.run_window.spotfinder_tab.selected_runs)
      self.run_numbers = []
      trial_ids = []
      rungroup_ids = []
      self.stats = []
      self.spot_length_stats = []
      self.trgr = {}
      self.run_tags = []
      self.run_statuses = []
      self.output = self.parent.params.output_folder
      for rg in trial.rungroups:
        for run in rg.runs:
          if run.run not in self.run_numbers and run.run in selected_runs:
            self.run_numbers.append(run.run)
            trial_ids.append(trial.id)
            rungroup_ids.append(rg.id)
            self.trgr[run.run] = (trial, rg, run)
            # spot count
            sf_stats = SpotfinderStats(self.db, run.run, trial.trial, rg.id)()
            self.stats.append(sf_stats)
            self.run_tags.append([tag.name for tag in run.tags])
            # spot lengths
            if self.parent.params.dispatcher == "cxi.xtc_process": #LABELIT backend
              outdir = "integration"
            else:
              outdir = "out"
            run_outdir = os.path.join(get_run_path(self.output, trial, rg, run), outdir)
            try:
              self.spot_length_stats.append(get_spot_length_stats(run_outdir, ref_stats=sf_stats))
            except OSError:
              print("Outdir %s no longer accessible." % run_outdir)
            except Exception as e:
              print(e)
              from dials.array_family import flex
              self.spot_length_stats.append((flex.double(), flex.double(), flex.double()))

      jobs = self.db.get_all_jobs()
      for idx in range(len(self.run_numbers)):
        run_no = self.run_numbers[idx]
        rg_id = rungroup_ids[idx]
        t_id = trial_ids[idx]
        for job in jobs:
          if job.run.run == run_no and job.rungroup.id == rg_id and job.trial.id == t_id:
            self.run_statuses.append(job.status)

  def plot_stats_static(self):
    from xfel.ui.components.spotfinder_plotter import plot_multirun_spotfinder_stats
    self.refresh_stats()
    sizex, sizey = self.parent.run_window.spotfinder_tab.spotfinder_panelsize
    self.parent.run_window.spotfinder_tab.png = plot_multirun_spotfinder_stats(
      self.stats, self.run_numbers,
      spot_length_stats=self.spot_length_stats,
      interactive=False,
      run_tags=self.run_tags,
      run_statuses=self.run_statuses,
      n_min=self.parent.run_window.spotfinder_tab.n_min,
      minimalist=self.parent.run_window.spotfinder_tab.entire_expt,
      easy_run=True,
      xsize=(sizex-25)/85, ysize=sizey/95,
      high_vis=self.parent.high_vis)
      # convert px to inches with fudge factor for scaling inside borders
    self.parent.run_window.spotfinder_tab.redraw_windows = True

# ---------------------------- Image Dumping Thread ---------------------------- #

class ImageDumpThread(Thread):
  def __init__(self,
               command):
    Thread.__init__(self)
    self.active = True
    self.command = command

  def run(self):
    print(self.command)
    easy_run.fully_buffered(command=self.command).show_stderr()

# ----------------------------- Unit Cell Sentinel ----------------------------- #

# Set up events for monitoring unit cell statistics
tp_EVT_UNITCELL_REFRESH = wx.NewEventType()
EVT_UNITCELL_REFRESH = wx.PyEventBinder(tp_EVT_UNITCELL_REFRESH, 1)

class RefreshUnitCell(wx.PyCommandEvent):
  ''' Send event when finished all cycles  '''
  def __init__(self, etype, eid):
    wx.PyCommandEvent.__init__(self, etype, eid)

class UnitCellSentinel(Thread):
  ''' Worker thread for unit cell analysis; generated so that the GUI does not lock up when
      processing is running '''

  def __init__(self,
               parent,
               active=True):
    Thread.__init__(self)
    self.parent = parent
    self.active = active

  def post_refresh(self):
    evt = RefreshUnitCell(tp_EVT_UNITCELL_REFRESH, -1)
    wx.PostEvent(self.parent.run_window.unitcell_tab, evt)

  def run(self):
    import xfel.ui.components.xfel_gui_plotter as pltr

    feature_vectors = {
      "Triclinic": None,
      "Monoclinic": "a,b,c",
      "Orthorhombic": "a,b,c",
      "Tetragonal": "a,c",
      "Hexagonal": "a,c",
      "Cubic": None,
    }

    # one time post for an initial update
    self.post_refresh()
    self.db = xfel_db_application(self.parent.params)

    while self.active:
      try:
        self.parent.run_window.unitcell_light.change_status('idle')
        trial = self.parent.run_window.unitcell_tab.trial
        tag_sets = self.parent.run_window.unitcell_tab.tag_sets
        sizex, sizey = self.parent.run_window.unitcell_tab.unit_cell_panelsize

        info_list = []
        legend_list = []
        for tag_set in tag_sets:
          legend_list.append(str(tag_set))
          cells = self.db.get_stats(trial=trial,
                                    tags=tag_set.tags,
                                    isigi_cutoff=1.0,
                                    tag_selection_mode=tag_set.mode)()
          info = []
          for cell in cells:
            info.append({'a':cell.cell_a,
                         'b':cell.cell_b,
                         'c':cell.cell_c,
                         'alpha':cell.cell_alpha,
                         'beta':cell.cell_beta,
                         'gamma':cell.cell_gamma,
                         'n_img':0})
          info_list.append(info)

        iqr_ratio = 1.5 if self.parent.run_window.unitcell_tab.reject_outliers else None

        figure = self.parent.run_window.unitcell_tab.figure
        plotter = pltr.PopUpCharts(interactive=True, figure=figure)

        if not self.parent.run_window.unitcell_tab.plot_clusters:
          figure.clear()
          plotter.plot_uc_histogram(
            info_list=info_list,
            legend_list=legend_list,
            xsize=(sizex-115)/82, ysize=(sizey-115)/82,
            high_vis=self.parent.high_vis,
            iqr_ratio=iqr_ratio)
          figure.canvas.draw_idle()
        elif len(info_list) > 0:
          from uc_metrics.clustering.step1 import phil_scope
          from uc_metrics.clustering.step_dbscan3d import dbscan_plot_manager
          from cctbx.sgtbx import space_group_info

          if len(info_list) > 1:
            print("Warning, only first tag set will be plotted")

          params = phil_scope.extract()
          try:
            sg = self.parent.run_window.unitcell_tab.trial.cell.lookup_symbol
          except AttributeError:
            sg = "P1"
          sg = "".join(sg.split()) # remove spaces
          params.input.space_group = sg

          iterable = ["{a} {b} {c} {alpha} {beta} {gamma} ".format(**c) + sg for c in info_list[0]]
          params.input.__inject__('iterable', iterable)
          params.file_name = None
          params.cluster.dbscan.eps = float(self.parent.run_window.unitcell_tab.plot_eps.eps.GetValue())
          params.show_plot = True
          params.plot.legend = legend_list[0]
          reject_outliers = self.parent.run_window.unitcell_tab.chk_reject_outliers.GetValue()
          params.plot.outliers = not reject_outliers

          sginfo = space_group_info(params.input.space_group)
          cs = sginfo.group().crystal_system()
          params.input.feature_vector = feature_vectors.get(cs)

          if params.input.feature_vector:
            figure = self.parent.run_window.unitcell_tab.figure
            figure.clear()
            plots = dbscan_plot_manager(params)
            plots.wrap_3D_features(fig = figure, embedded = True)
            figure.canvas.draw_idle()
            cluster_dir = os.path.join(self.parent.params.output_folder, "cluster")
            if not os.path.isdir(cluster_dir):
              os.makedirs(cluster_dir)
            cluster_file = os.path.join(cluster_dir,"cluster_%s.pickle"%(plots.FV.sample_name.strip().replace(" ", "_")))
            print("Writing cluster to", cluster_file)
            import pickle
            with open(cluster_file,"wb") as FF:
              pickle.dump(
                dict(populations=plots.pop,
                     features=plots.FV.features_,
                     info=plots.FV.output_info,
                     sample=plots.FV.sample_name),FF
                )
          else:
            print("Unsupported crystal system", cs)

        self.post_refresh()
        self.parent.run_window.unitcell_light.change_status('on')
        time.sleep(15)
      except Exception as e:
        print(e)
        self.parent.run_window.unitcell_light.change_status('alert')
        break

# ------------------------------- Frames Sentinel ------------------------------- #

# Set up events for FramesSeninel
tp_EVT_FRAMES_REFRESH = wx.NewEventType()
EVT_FRAMES_REFRESH = wx.PyEventBinder(tp_EVT_FRAMES_REFRESH, 1)

class RefreshFrames(wx.PyCommandEvent):
  ''' Send event when finished all cycles  '''

  def __init__(self, etype, eid):
    wx.PyCommandEvent.__init__(self, etype, eid)

class FramesSentinel(Thread):
  ''' Worker thread for frames; generated so that the GUI does not lock up when
      processing is running '''

  def __init__(self,
               parent,
               active=True):
    Thread.__init__(self)
    self.parent = parent
    self.active = active

  def post_refresh(self):
    pass

  def run(self):
    # one time post for an initial update
    self.post_refresh()
    db = xfel_db_application(self.parent.parent.params)

    while self.active:
      try:
        trial = db.get_trial(trial_number=int(self.parent.trial_number.ctr.GetStringSelection()))
        runs = [db.get_run(run_number=int(r)) for r in self.parent.trial_runs.ctr.GetCheckedStrings()]
        print("Total events in trial", trial.trial, end=' ')
        if len(runs) == 0:
          runs = None
        else:
          print("runs", ", ".join(sorted([str(r.run) for r in runs])), end=' ')
        print(":", len(db.get_all_events(trial, runs)))
        self.post_refresh()
        time.sleep(2)
      except Exception as e:
        print(e)
        #self.parent.run_window.frames_light.change_status('alert')
        break

# ------------------------------- Clustering --------------------------------- #

# Set up events for and for finishing all cycles
tp_EVT_CLUSTERING = wx.NewEventType()
EVT_CLUSTERING = wx.PyEventBinder(tp_EVT_CLUSTERING, 1)

class ClusteringResult(wx.PyCommandEvent):
  ''' Send event when finished all cycles  '''

  def __init__(self, etype, eid, result=None):
    wx.PyCommandEvent.__init__(self, etype, eid)
    self.result = result
  def GetValue(self):
    return self.result

class Clusterer():
  def __init__(self, trial, runblocks, tags, output, sample_size, threshold):
    self.trial = trial
    self.runblocks = runblocks
    self.tags = tags
    self.output = output
    self.sample_size = sample_size
    self.threshold = threshold

  def unit_cell_clustering(self):

    # 1. Get all pickle files, check if new ones arrived
    run_numbers = []
    rb_paths = []
    tag_ids = set([t.id for t in self.tags])
    for rb in self.runblocks:
      for run in rb.runs:
        if run.run not in run_numbers:
          if len(tag_ids) > 0:
            run_tag_ids = set([t.id for t in run.tags])
            if len(tag_ids.intersection(run_tag_ids)) == 0:
              continue
          run_numbers.append(run.run)
          # test for integration folder
          path = os.path.join(get_run_path(self.output, self.trial, rb, run), "integration")
          if not os.path.exists(path):
            path = os.path.join(get_run_path(self.output, self.trial, rb, run), "out")
          rb_paths.append(path)

    all_pickles = []

    for path in rb_paths:
      try:
        pickles = [os.path.join(path, i) for i in os.listdir(path) if
                   i.endswith('pickle') and 'int-' in i]
        all_pickles = all_pickles + pickles
      except OSError as error:
        print('Folder not found!')
        print(error)

    if len(all_pickles) == 0:
      print('No images integrated (yet)')
      return

    # If clustering button was pressed, do clustering
    # 2. Pick subset
    subset = list(np.random.choice(all_pickles, size=int(self.sample_size)))

    # 3. Do clustering
    ucs = Cluster.from_files(subset, use_b=True)
    clusters, _ = ucs.ab_cluster(self.threshold,
                                 log=False, write_file_lists=False,
                                 schnell=False, doplot=False)
    return clusters

class ClusteringWorker(Thread):
  ''' Worker thread for jobs; generated so that the GUI does not lock up when
      processing is running '''

  def __init__(self,
               parent,
               trial,
               runblocks,
               tags,
               output,
               sample_size=1000,
               threshold=250,):
    Thread.__init__(self)
    self.parent = parent
    self.trial = trial
    self.runblocks = runblocks
    self.tags = tags
    self.output = output
    self.sample_size = sample_size
    self.threshold = threshold

  def run(self):
    clusterer = Clusterer(self.trial, self.runblocks, self.tags, self.output,
                          self.sample_size, self.threshold)
    self.clusters = clusterer.unit_cell_clustering()

    evt = ClusteringResult(tp_EVT_CLUSTERING, -1, self.clusters)
    wx.PostEvent(self.parent, evt)

# ----------------------------- Merging Stats Sentinel ---------------------------- #

# Set up events for monitoring merging stats
tp_EVT_MERGINGSTATS_REFRESH = wx.NewEventType()
EVT_MERGINGSTATS_REFRESH = wx.PyEventBinder(tp_EVT_MERGINGSTATS_REFRESH, 1)

class RefreshMergingStats(wx.PyCommandEvent):
  ''' Send event when finished all cycles  '''
  def __init__(self, etype, eid, result=None):
    wx.PyCommandEvent.__init__(self, etype, eid)
    self.result = result
  def GetValue(self):
    return self.result

class MergingStatsSentinel(Thread):
  ''' Worker thread for merging stats; generated so that the GUI does not lock up when
      processing is running '''

  def __init__(self,
               parent,
               active=True):
    Thread.__init__(self)
    self.parent = parent
    self.active = active
    self.output = self.parent.params.output_folder

    # on initialization (and restart), make sure run stats drawn from scratch
    self.parent.run_window.mergingstats_tab.redraw_windows = True

  def post_refresh(self):
    evt = RefreshMergingStats(tp_EVT_MERGINGSTATS_REFRESH, -1)
    wx.PostEvent(self.parent.run_window.mergingstats_tab, evt)

  def run(self):
    # one time post for an initial update
    self.post_refresh()
    self.db = xfel_db_application(self.parent.params)

    while self.active:
      try:
        self.parent.run_window.mergingstats_light.change_status('idle')
        self.plot_stats_static()
        self.post_refresh()
        self.parent.run_window.mergingstats_light.change_status('on')
        time.sleep(5)
      except Exception as e:
        print(e)
        self.parent.run_window.mergingstats_light.change_status('alert')
        break

  def plot_stats_static(self):
    from xfel.ui.db.merging_log_scraper import Scraper

    if not self.parent.run_window.mergingstats_tab.dataset_versions: return

    sizex, sizey = self.parent.run_window.mergingstats_tab.mergingstats_panelsize
    sizex = (sizex-25)/85
    sizey = (sizey-25)/95

    if len(self.parent.run_window.mergingstats_tab.dataset_versions) > 1:
      all_results = []
      for folder in self.parent.run_window.mergingstats_tab.dataset_versions:
        scraper = Scraper(folder, '#')
        all_results.append(scraper.scrape())
      self.parent.run_window.mergingstats_tab.png = scraper.plot_many_results(all_results,
                                                                              self.parent.run_window.mergingstats_tab.dataset_name,
                                                                              sizex, sizey, interactive=False)
    else:
      scraper = Scraper(self.parent.run_window.mergingstats_tab.dataset_versions[0], '%')
      results = scraper.scrape()
      self.parent.run_window.mergingstats_tab.png = scraper.plot_single_results(results,
                                                                                self.parent.run_window.mergingstats_tab.dataset_name,
                                                                                sizex, sizey, interactive=False)
    self.parent.run_window.mergingstats_tab.redraw_windows = True

# ------------------------------- Main Window -------------------------------- #

class MainWindow(wx.Frame):

  def __init__(self, parent, id, title, params=None):
    wx.Frame.__init__(self, parent, id, title, size=(200, 200))

    self.run_sentinel = None
    self.calib_worker = None
    self.job_sentinel = None
    self.job_monitor = None
    self.spotfinder_sentinel = None
    self.runstats_sentinel = None
    self.unitcell_sentinel = None
    self.mergingstats_sentinel = None

    if not params:
      params = load_cached_settings()
    self.params = params
    self.db = None

    self.high_vis = False

    # Toolbar
    self.toolbar = self.CreateToolBar(wx.TB_TEXT)
    self.tb_btn_quit = self.toolbar.AddTool(wx.ID_EXIT,
                       label='Quit',
                       bitmap=wx.Bitmap('{}/32x32/exit.png'.format(icons)),
                       bmpDisabled=wx.NullBitmap,
                       shortHelp='Quit',
                       longHelp='Exit CCTBX.XFEL')
    self.toolbar.AddSeparator()
    if not self.params.monitoring_mode:
      self.tb_btn_watch_new_runs = self.toolbar.AddTool(wx.ID_ANY,
                                   label='Watch for new runs',
                                   bitmap=wx.Bitmap('{}/32x32/quick_restart.png'.format(icons)),
                                   bmpDisabled=wx.NullBitmap,
                                   shortHelp='Watch for new runs',
                                   longHelp='Watch for new runs')
      self.tb_btn_auto_submit = self.toolbar.AddTool(wx.ID_ANY,
                                label='Auto-submit jobs',
                                bitmap=wx.Bitmap('{}/32x32/play.png'.format(icons)),
                                bmpDisabled=wx.NullBitmap,
                                shortHelp='Auto-submit jobs',
                                longHelp='Auto-submit all pending jobs')
      self.toolbar.AddSeparator()
      #self.tb_btn_calibrate = self.toolbar.AddTool(wx.ID_ANY,
      #                    label='Calibration',
      #                    bitmap=wx.Bitmap('{}/32x32/calib.png'.format(icons)),
      #                    bmpDisabled=wx.NullBitmap,
      #                    shortHelp='Calibration',
      #                    longHelp='Detector geometry calibration')
      #self.toolbar.AddSeparator()
      self.tb_btn_settings = self.toolbar.AddTool(wx.ID_ANY,
                          label='Settings',
                          bitmap=wx.Bitmap('{}/32x32/settings.png'.format(icons)),
                          bmpDisabled=wx.NullBitmap,
                          shortHelp='Settings',
                          longHelp='Database, user and experiment settings')
    self.tb_btn_zoom = self.toolbar.AddCheckTool(wx.ID_ANY,
                                                 label='Large text',
                                                 bitmap1=wx.Bitmap('{}/32x32/search.png'.format(icons)),
                                                 bmpDisabled=wx.NullBitmap,
                                                 shortHelp='Change text size',
                                                 longHelp='Change text size for plots')
    self.toolbar.Realize()

    # Status bar
    self.sb = self.CreateStatusBar()

    # Menu bar
    menubar = wx.MenuBar()
    m_help = wx.Menu()
    self.mb_about = m_help.Append(wx.ID_ANY, '&About')
    self.mb_docs = m_help.Append(wx.ID_ANY, '&Online help')
    menubar.Append(m_help, '&Help')
    self.SetMenuBar(menubar)

    # Place elements in main PRIME window
    main_box = wx.BoxSizer(wx.VERTICAL)

    # Instantiate windows
    self.run_window = RunWindow(self)

    # Single input window
    main_box.Add(self.run_window, 1, flag=wx.ALL | wx.EXPAND, border=10)
    main_box.Add((-1, 20))


    # Menubar button bindings
    self.Bind(wx.EVT_MENU, self.OnAboutBox, self.mb_about)
    self.Bind(wx.EVT_MENU, self.OnDocs, self.mb_docs)

    # Bindings
    self.Bind(wx.EVT_TOOL, self.onQuit, self.tb_btn_quit)
    if not self.params.monitoring_mode:
      self.Bind(wx.EVT_TOOL, self.onWatchRuns, self.tb_btn_watch_new_runs)
      self.Bind(wx.EVT_TOOL, self.onAutoSubmit, self.tb_btn_auto_submit)
      #self.Bind(wx.EVT_TOOL, self.onCalibration, self.tb_btn_calibrate)
      self.Bind(wx.EVT_TOOL, self.onSettings, self.tb_btn_settings)
    self.Bind(wx.EVT_TOOL, self.onZoom, self.tb_btn_zoom)
    self.Bind(wx.EVT_NOTEBOOK_PAGE_CHANGED, self.onTabChange,
              self.run_window.main_nbook)
    self.Bind(wx.EVT_NOTEBOOK_PAGE_CHANGING, self.onLeavingTab,
              self.run_window.main_nbook)

    # Draw the main window sizer
    self.SetSizer(main_box)

  def connect_to_db(self, drop_tables = False):
    self.db = xfel_db_application(self.params, drop_tables = drop_tables, verify_tables = True)

    return True

  def stop_sentinels(self):
    if not self.params.monitoring_mode:
      self.stop_run_sentinel()
      self.stop_calib_worker()
      self.stop_job_sentinel()
      self.stop_job_monitor()
    #self.stop_spotfinder_sentinel()
    self.stop_runstats_sentinel()
    self.stop_unitcell_sentinel()
    self.stop_mergingstats_sentinel()

  def start_run_sentinel(self):
    self.run_sentinel = RunSentinel(self, active=True)
    self.run_sentinel.start()
    self.run_window.run_light.change_status('on')

    self.toolbar.SetToolNormalBitmap(self.tb_btn_watch_new_runs.Id, wx.Bitmap('{}/32x32/pause.png'.format(icons)))

  def stop_run_sentinel(self, block = True):
    if self.run_sentinel is not None and self.run_sentinel.active:
      self.run_sentinel.active = False
      if block:
        self.run_sentinel.join()
    self.run_window.run_light.change_status('off')
    self.toolbar.SetToolNormalBitmap(self.tb_btn_watch_new_runs.Id, wx.Bitmap('{}/32x32/quick_restart.png'.format(icons)))

  def start_calib_worker(self):
    self.calib_worker = CalibWorker(self, active=True)
    self.calib_worker.start()
    self.run_window.calib_light.change_status('on')

  def stop_calib_worker(self, block = True):
    if self.calib_worker is not None and self.calib_worker.active:
      self.calib_worker.active = False
      if block:
        self.calib_worker.join()
    self.run_window.calib_light.change_status('off')

  def start_job_monitor(self):
    self.job_monitor = JobMonitor(self, active=True)
    self.job_monitor.start()

  def stop_job_monitor(self, block = True):
    if self.job_monitor is not None and self.job_monitor.active:
      self.job_monitor.active = False
      if block:
        self.job_monitor.join()

  def start_job_sentinel(self):
    self.job_sentinel = JobSentinel(self, active=True)
    self.job_sentinel.start()
    self.run_window.job_light.change_status('on')

    self.toolbar.SetToolNormalBitmap(self.tb_btn_auto_submit.Id, wx.Bitmap('{}/32x32/pause.png'.format(icons)))

  def stop_job_sentinel(self, block = True):
    if self.job_sentinel is not None and self.job_sentinel.active:
      self.job_sentinel.active = False
      if block:
        self.job_sentinel.join()
    self.run_window.job_light.change_status('off')
    self.toolbar.SetToolNormalBitmap(self.tb_btn_auto_submit.Id, wx.Bitmap('{}/32x32/play.png'.format(icons)))

  def start_prg_sentinel(self):
    self.prg_sentinel = ProgressSentinel(self, active=True)
    self.prg_sentinel.start()
    self.run_window.prg_light.change_status('on')

  def stop_prg_sentinel(self, block = True):
    if self.prg_sentinel is not None and self.prg_sentinel.active:
      self.prg_sentinel.active = False
      if block:
        self.prg_sentinel.join()
    self.run_window.prg_light.change_status('off')

  def start_spotfinder_sentinel(self):
    self.spotfinder_sentinel = SpotfinderSentinel(self, active=True)
    self.spotfinder_sentinel.start()
    self.run_window.spotfinder_light.change_status('on')

  def stop_spotfinder_sentinel(self, block = True):
    if self.spotfinder_sentinel is not None and self.spotfinder_sentinel.active:
      self.spotfinder_sentinel.active = False
      if block:
        self.spotfinder_sentinel.join()
    self.run_window.spotfinder_light.change_status('off')

  def start_runstats_sentinel(self):
    self.runstats_sentinel = RunStatsSentinel(self, active=True)
    self.runstats_sentinel.start()
    self.run_window.runstats_light.change_status('on')

  def stop_runstats_sentinel(self, block = True):
    if self.runstats_sentinel is not None and self.runstats_sentinel.active:
      self.runstats_sentinel.active = False
      if block:
        self.runstats_sentinel.join()
    self.run_window.runstats_light.change_status('off')

  def start_unitcell_sentinel(self):
    self.unitcell_sentinel = UnitCellSentinel(self, active=True)
    self.unitcell_sentinel.start()
    self.run_window.unitcell_light.change_status('on')

  def stop_unitcell_sentinel(self, block = True):
    if self.unitcell_sentinel is not None and self.unitcell_sentinel.active:
      self.unitcell_sentinel.active = False
      if block:
        self.unitcell_sentinel.join()
    self.run_window.unitcell_light.change_status('off')

  def start_mergingstats_sentinel(self):
    self.mergingstats_sentinel = MergingStatsSentinel(self, active=True)
    self.mergingstats_sentinel.start()
    self.run_window.mergingstats_light.change_status('on')

  def stop_mergingstats_sentinel(self, block = True):
    if self.mergingstats_sentinel is not None and self.mergingstats_sentinel.active:
      self.mergingstats_sentinel.active = False
      if block:
        self.mergingstats_sentinel.join()
    self.run_window.mergingstats_light.change_status('off')

  def OnAboutBox(self, e):
    ''' About dialog '''
    import wx.adv
    info = wx.adv.AboutDialogInfo()
    info.SetName('cctbx.xfel')
    info.SetLicense(open(license).read())
    info.SetDescription(description)
    info.AddDeveloper('Artem Lyubimov')
    info.AddDeveloper('Aaron Brewster')
    info.AddDeveloper('Iris Young')
    info.AddDeveloper('Asmit Bhowmick')
    info.AddDeveloper('Daniel Paley')
    info.AddDeveloper('Derek A. Mendez')
    info.AddDeveloper('Johannes Blaschke')
    info.AddDeveloper('Robert Bolotovsky')
    info.AddDeveloper('Vanessa Oklejas')
    info.AddDeveloper('Axel Brunger')
    info.AddDeveloper('Nicholas Sauter')
    wx.adv.AboutBox(info)

  def OnDocs(self, e):
    import webbrowser
    url = 'http://cci.lbl.gov/publications/download/CCN_2019_p22_Brewster.pdf'
    print('Opening', url)
    webbrowser.open(url)

  def onSettings(self, e):
    settings_dlg = dlg.SettingsDialog(self,
                                      params=self.params)
    settings_dlg.db_cred.btn_big.Disable()
    settings_dlg.SetTitle('Settings')

    if (settings_dlg.ShowModal() == wx.ID_OK):
      self.params = settings_dlg.params
      save_cached_settings(self.params)
      if self.params.facility.name == 'lcls':
        self.title = 'CCTBX.XFEL | {} | {}'.format(self.params.experiment_tag,
                                                   self.params.facility.lcls.experiment)
      else:
        self.title = 'CCTBX.XFEL | {}'.format(self.params.experiment_tag)

  def onZoom(self, e):
    self.high_vis = not self.high_vis

  # def onCalibration(self, e):
  #   calib_dlg = dlg.CalibrationDialog(self, db=self.db)
  #   calib_dlg.Fit()

  #   calib_dlg.ShowModal()

  def onWatchRuns(self, e):
    ''' Toggle autosubmit '''
    if self.run_sentinel is not None and self.run_sentinel.active:
      self.stop_run_sentinel(block = True)
    else:
      self.start_run_sentinel()

  def onAutoSubmit(self, e):
    ''' Toggle autosubmit '''
    if self.job_sentinel is not None and self.job_sentinel.active:
      self.stop_job_sentinel(block = True)
    else:
      self.start_job_sentinel()

  def onTabChange(self, e):
    name = self.run_window.main_nbook.GetPageText((self.run_window.main_nbook.GetSelection()))
    if name == self.run_window.jobs_tab.name:
      if self.job_monitor is None or not self.job_monitor.active:
        self.start_job_monitor()
        self.run_window.jmn_light.change_status('on')
    elif name == self.run_window.energy_tab.name:
      if self.calib_worker is None or not self.calib_worker.active:
        self.start_calib_worker()
        self.run_window.calib_light.change_status('on')
    # Disabled
    #elif name == self.run_window.spotfinder_tab.name:
    #  if self.job_monitor is None or not self.job_monitor.active:
    #    self.start_job_monitor()
    #    self.run_window.jmn_light.change_status('on')
    #  if self.spotfinder_sentinel is None or not self.spotfinder_sentinel.active:
    #    self.start_spotfinder_sentinel()
    #    self.run_window.spotfinder_light.change_status('on')
    elif name == self.run_window.trials_tab.name:
      self.run_window.trials_tab.refresh_trials()
    elif name == self.run_window.runstats_tab.name:
      if not self.params.monitoring_mode and (self.job_monitor is None or not self.job_monitor.active):
        self.start_job_monitor()
        self.run_window.jmn_light.change_status('on')
      if self.run_window.runstats_tab.auto_update and (self.runstats_sentinel is None or not self.runstats_sentinel.active):
        self.start_runstats_sentinel()
        self.run_window.runstats_light.change_status('on')
    elif name == self.run_window.unitcell_tab.name:
      if self.run_window.unitcell_tab.auto_update and (self.unitcell_sentinel is None or not self.unitcell_sentinel.active):
        self.start_unitcell_sentinel()
        self.run_window.unitcell_light.change_status('on')
    elif name == self.run_window.datasets_tab.name:
      self.run_window.datasets_tab.refresh_datasets()
    elif name == self.run_window.mergingstats_tab.name:
      self.run_window.mergingstats_tab.refresh_datasets()
      if self.mergingstats_sentinel is None or not self.mergingstats_sentinel.active:
        self.start_mergingstats_sentinel()
        self.run_window.mergingstats_light.change_status('on')
    #elif name == self.run_window.merge_tab.name:
    #  self.run_window.merge_tab.find_trials()

  def onLeavingTab(self, e):
    name = self.run_window.main_nbook.GetPageText((self.run_window.main_nbook.GetSelection()))
    if name == self.run_window.jobs_tab.name:
      if self.job_monitor.active:
        self.stop_job_monitor(block = False)
        self.run_window.jmn_light.change_status('off')
    elif name == self.run_window.energy_tab.name:
      if self.calib_worker.active:
        self.stop_calib_worker(block = False)
        self.run_window.calib_light.change_status('off')
    # Disabled
    #elif name == self.run_window.spotfinder_tab.name:
    #  if self.job_monitor.active:
    #    self.stop_job_monitor(block = False)
    #    self.run_window.jmn_light.change_status('off')
    #  if self.spotfinder_sentinel.active:
    #    self.stop_spotfinder_sentinel(block = False)
    #    self.run_window.spotfinder_light.change_status('off')
    elif name == self.run_window.runstats_tab.name:
      if not self.params.monitoring_mode and self.job_monitor.active:
        self.stop_job_monitor(block = False)
        self.run_window.jmn_light.change_status('off')
      if self.runstats_sentinel.active:
        self.stop_runstats_sentinel(block = False)
        self.run_window.runstats_light.change_status('off')
    elif name == self.run_window.unitcell_tab.name:
      if self.unitcell_sentinel.active:
        self.stop_unitcell_sentinel(block = False)
        self.run_window.unitcell_light.change_status('off')
    elif name == self.run_window.mergingstats_tab.name:
      if self.mergingstats_sentinel.active:
        self.stop_mergingstats_sentinel(block = False)
        self.run_window.mergingstats_light.change_status('off')


  def onQuit(self, e):
    self.stop_sentinels()
    save_cached_settings(self.params)
    # wx windows resolve to False if closed
    if self.run_window.runstats_tab.sf_frame:
      self.run_window.runstats_tab.sf_frame.Close()
    self.Destroy()


class RunWindow(wx.Panel):
  ''' Window panel that will house all the run tabs '''

  def __init__(self, parent):
    self.parent = parent
    super(RunWindow, self).__init__(self.parent)

    self.main_panel = wx.Panel(self)
    self.main_nbook = wx.Notebook(self.main_panel, style=0)
    self.runs_tab = RunTab(self.main_nbook, main=self.parent)
    self.energy_tab = EnergyTab(self.main_nbook, main=self.parent)
    self.trials_tab = TrialsTab(self.main_nbook, main=self.parent)
    self.jobs_tab = JobsTab(self.main_nbook, main=self.parent)
    #self.spotfinder_tab = SpotfinderTab(self.main_nbook, main=self.parent) # Disabled
    self.runstats_tab = RunStatsTab(self.main_nbook, main=self.parent)
    self.unitcell_tab = UnitCellTab(self.main_nbook, main=self.parent)
    self.datasets_tab = DatasetTab(self.main_nbook, main=self.parent)
    #self.merge_tab = MergeTab(self.main_nbook, main=self.parent)
    self.mergingstats_tab = MergingStatsTab(self.main_nbook, main=self.parent)
    self.main_nbook.AddPage(self.runs_tab, self.runs_tab.name)
    self.main_nbook.AddPage(self.energy_tab, self.energy_tab.name)
    self.main_nbook.AddPage(self.trials_tab, self.trials_tab.name)
    self.main_nbook.AddPage(self.jobs_tab, self.jobs_tab.name)
    #self.main_nbook.AddPage(self.spotfinder_tab, self.spotfinder_tab.name) # Disabled
    self.main_nbook.AddPage(self.runstats_tab, self.runstats_tab.name)
    self.main_nbook.AddPage(self.unitcell_tab, self.unitcell_tab.name)
    self.main_nbook.AddPage(self.datasets_tab, self.datasets_tab.name)
    #self.main_nbook.AddPage(self.merge_tab, self.merge_tab.name)
    self.main_nbook.AddPage(self.mergingstats_tab, self.mergingstats_tab.name)

    self.sentinel_box = wx.FlexGridSizer(1, 7, 0, 20)
    self.run_light = gctr.SentinelStatus(self.main_panel, label='Run Sentinel')
    self.calib_light = gctr.SentinelStatus(self.main_panel, label='Calib Worker')
    self.job_light = gctr.SentinelStatus(self.main_panel, label='Job Sentinel')
    self.jmn_light = gctr.SentinelStatus(self.main_panel, label='Job Monitor')
    #self.spotfinder_light = gctr.SentinelStatus(self.main_panel, label='Spotfinder Sentinel')
    self.runstats_light = gctr.SentinelStatus(self.main_panel, label='Run Stats Sentinel')
    self.unitcell_light = gctr.SentinelStatus(self.main_panel, label='Unit Cell Sentinel')
    self.mergingstats_light = gctr.SentinelStatus(self.main_panel, label='Merging Stats Sentinel')
    self.sentinel_box.Add(self.run_light)
    self.sentinel_box.Add(self.calib_light)
    self.sentinel_box.Add(self.job_light)
    self.sentinel_box.Add(self.jmn_light)
    #self.sentinel_box.Add(self.spotfinder_light)
    self.sentinel_box.Add(self.runstats_light)
    self.sentinel_box.Add(self.unitcell_light)
    self.sentinel_box.Add(self.mergingstats_light)

    nb_sizer = wx.BoxSizer(wx.VERTICAL)
    nb_sizer.Add(self.main_nbook, 1, flag=wx.EXPAND | wx.ALL, border=3)
    nb_sizer.Add((-1, 20))
    nb_sizer.Add(self.sentinel_box, flag=wx.ALIGN_CENTER_HORIZONTAL)
    self.main_panel.SetSizer(nb_sizer)

    main_sizer = wx.BoxSizer(wx.VERTICAL)
    main_sizer.Add(self.main_panel, 1, flag=wx.EXPAND | wx.ALL, border=3)
    self.SetSizer(main_sizer)

    self.show_hide_tabs()

  def show_hide_tabs(self):
    if self.parent.params.monitoring_mode:
      self.runs_tab.Hide()
      self.trials_tab.Hide()
      self.jobs_tab.Hide()
      self.datasets_tab.Hide()
      self.run_light.Hide()
      self.job_light.Hide()
      self.jmn_light.Hide()
    else:
      self.runs_tab.Show()
      self.trials_tab.Show()
      self.jobs_tab.Show()
      self.datasets_tab.Show()
      self.run_light.Show()
      self.job_light.Show()
      self.jmn_light.Show()

    if self.parent.params.facility.name == "lcls" and not self.parent.params.monitoring_mode:
      self.energy_tab.Show()
    else:
      self.energy_tab.Hide()

# --------------------------------- UI Tabs ---------------------------------- #

class BaseTab(wx.Panel):
  ''' Base class for runtime tab '''

  def __init__(self, parent):
    wx.Panel.__init__(self, parent=parent, id=wx.ID_ANY, size=(200, 200))

    self.main_sizer = wx.BoxSizer(wx.VERTICAL)
    self.SetSizer(self.main_sizer)


class RunTab(BaseTab):
  def __init__(self, parent, main):
    BaseTab.__init__(self, parent=parent)
    self.name = 'Runs'
    self.main = main
    self.last_run = 0
    self.all_runs = []
    self.all_tags = []
    self.all_tag_buttons = []
    self.persistent_tags = []

    self.run_panel = ScrolledPanel(self)
    self.run_sizer = wx.BoxSizer(wx.VERTICAL)
    self.run_panel.SetSizer(self.run_sizer)

    self.colname_sizer = wx.FlexGridSizer(1, 2, 0, 10)
    run_label = wx.StaticText(self, label='Run', size=(60, -1))
    tag_label = wx.StaticText(self, label='Sample Tags', size=(620, -1))
    self.colname_sizer.Add(run_label, flag=wx.ALIGN_RIGHT)
    self.colname_sizer.Add(tag_label, flag=wx.ALIGN_RIGHT | wx.EXPAND)
    self.colname_sizer.AddGrowableCol(1, 1)
    self.main_sizer.Add(self.colname_sizer, flag=wx.ALL | wx.EXPAND, border=10)

    self.btn_multirun_tags = wx.Button(self, label='Change Tags on Multiple Runs', size=(240, -1))
    self.btn_persistent_tags = gctr.Button(self, name='btn_persistent_tags', label='Manage Persistent Tags', size=(240, -1))
    self.btn_manage_tags = gctr.Button(self, name='btn_manage_tags', label='Manage Tags', size=(120, -1))
    self.main_sizer.Add(self.run_panel, 1, flag=wx.EXPAND | wx.ALL, border=10)
    self.main_sizer.Add(wx.StaticLine(self), flag=wx.EXPAND | wx.ALL, border=10)

    self.button_sizer = wx.BoxSizer(wx.HORIZONTAL)
    self.button_sizer.Add(self.btn_multirun_tags,
                          flag=wx.RIGHT | wx.LEFT | wx.BOTTOM,
                          border=10)
    self.button_sizer.Add(self.btn_persistent_tags,
                          flag=wx.RIGHT | wx.LEFT | wx.BOTTOM,
                          border=10)
    self.button_sizer.Add(self.btn_manage_tags,
                          flag=wx.RIGHT | wx.LEFT | wx.BOTTOM,
                          border=10)
    self.main_sizer.Add(self.button_sizer, flag=wx.EXPAND | wx.ALL, border=10)

    # Bindings
    self.Bind(EVT_RUN_REFRESH, self.onRefresh)
    self.Bind(wx.EVT_BUTTON, self.onMultiRunTags, self.btn_multirun_tags)
    self.Bind(wx.EVT_BUTTON, self.onManagePersistentTags, self.btn_persistent_tags)
    self.Bind(wx.EVT_BUTTON, self.onManageTags, self.btn_manage_tags)

  def onRefresh(self, e):
      self.refresh_rows()

  def onMultiRunTags(self, e):
    """Add or remove tags applied to multiple runs at a time."""
    multirun_tag_dialog = dlg.MultiRunTagDialog(self, db=self.main.db)
    multirun_tag_dialog.Fit()
    multirun_tag_dialog.ShowModal()
    multirun_tag_dialog.Destroy()

  def onManageTags(self, e):
    ''' User can add / remove / edit sample tags '''
    mtag_dlg = dlg.TagDialog(self, db=self.main.db)
    mtag_dlg.Fit()
    mtag_dlg.ShowModal()
    mtag_dlg.Destroy()

    # Update tags on all tag buttons
    for btn in self.all_tag_buttons:
      btn.tags = btn.run.tags
      btn.update_label()

  def onManagePersistentTags(self, e):
    '''Update which tags are applied automatically to new runs'''
    tags = self.main.db.get_all_tags()
    tag_names = [i.name for i in tags]
    mptag_dlg = wx.MultiChoiceDialog(self,
                                     message='Available tags',
                                     caption='Persistent Tags',
                                     choices=tag_names)
    # Get indices of selected items (if any) and set them to checked
    persistent_tags = self.persistent_tags
    indices = [tag_names.index(i) for i in tag_names if i in persistent_tags]
    mptag_dlg.SetSelections(indices)
    mptag_dlg.Fit()
    if (mptag_dlg.ShowModal() == wx.ID_OK):
      indices = mptag_dlg.GetSelections()
      tag_names = [t.name for t in tags if tag_names.index(t.name) in indices]
      self.persistent_tags = tag_names
    mptag_dlg.Destroy()

  def refresh_rows(self, all=False):
    # Get new runs
    old_run_numbers = [run.run for run in self.all_runs]
    all_runs = self.main.db.get_all_runs()
    new_runs = [run for run in all_runs if run.run not in old_run_numbers]

    font = self.GetFont()
    dc = wx.ScreenDC()
    dc.SetFont(font)
    if len(all_runs) > 0:
      max_width = max([dc.GetTextExtent(str(run))[0] for run in all_runs])
    else:
      max_width = None

    # Update either all or only new runs
    if all:
      runs = self.all_runs
    else:
      runs = new_runs
    for run in runs:
      run_row = RunEntry(self.run_panel, run=run, params=self.main.params, label_width = max_width)
      self.all_tag_buttons.append(run_row.tag_button)
      self.run_sizer.Add(run_row, flag=wx.ALL | wx.EXPAND, border=0)

    self.all_runs = all_runs

    # Update labels on all new tag buttons
    self.all_tags = self.main.db.get_all_tags()
    for button in self.all_tag_buttons:
      button.all_tags = self.all_tags
      button.update_label()

    self.run_panel.SetupScrolling(scrollToTop=False)
    self.run_panel.Refresh()

class EnergyTab(BaseTab):
  def __init__(self, parent, main):
    BaseTab.__init__(self, parent=parent)
    self.name = 'Energy'
    self.main = main

    self.all_runs = []
    self.fee_runs = []
    self.fee_energies = []
    self.ebeam_runs = []
    self.fee_eV_per_pixel = None
    self.fee_eV_offset = None
    self.ebeam_eV_offset = None
    self.ebeam_wavelength_offset = None

    self.fee_calib_stale = False
    self.ebeam_calib_stale = False
    self.size_stale = False
    self.experiment = main.params.facility.lcls.experiment

    self.calib_panel = ScrolledPanel(self)
    self.calib_sizer = wx.BoxSizer(wx.VERTICAL)
    self.calib_panel.SetSizer(self.calib_sizer)
    self.calib_grid_sizer = wx.GridBagSizer(vgap=10, hgap=10)

    import matplotlib as mpl
    from matplotlib.backends.backend_wxagg import (
      FigureCanvasWxAgg as FigureCanvas,
      NavigationToolbar2WxAgg as NavigationToolbar)

    # FEE scan section
    self.scan_runs_panel = ScrolledPanel(self.calib_panel, size=(220, 325))
    self.scan_runs_sizer = wx.BoxSizer(wx.VERTICAL)
    self.scan_runs_panel.SetSizer(self.scan_runs_sizer)

    self.scan_runs_panel_label = wx.StaticText(self.scan_runs_panel, label='FEE Energy Scan Description', size=(420, 20))
    self.scan_runs_sizer.Add(self.scan_runs_panel_label, border=10, flag=wx.BOTTOM)

    self.expt_id_panel = wx.Panel(self.scan_runs_panel)
    self.expt_id_sizer = wx.BoxSizer(wx.HORIZONTAL)
    self.scan_runs_experiment_label = wx.StaticText(self.expt_id_panel, label='Experiment:', size=(80, -1))
    self.scan_runs_experiment = wx.TextCtrl(self.expt_id_panel, size=(118, -1))
    self.expt_id_sizer.Add(self.scan_runs_experiment_label)
    self.expt_id_sizer.Add(self.scan_runs_experiment)
    self.scan_runs_experiment.SetValue(self.experiment)
    self.expt_id_panel.SetSizer(self.expt_id_sizer)
    self.scan_runs_sizer.Add(self.expt_id_panel)

    self.max_evts_panel = wx.Panel(self.scan_runs_panel)
    self.max_evts_sizer = wx.BoxSizer(wx.HORIZONTAL)
    self.max_evts_label = wx.StaticText(self.max_evts_panel, label='Max events:', size=(80, -1))
    self.max_evts = wx.TextCtrl(self.max_evts_panel, size=(118, -1))
    self.max_evts_sizer.Add(self.max_evts_label)
    self.max_evts_sizer.Add(self.max_evts)
    self.max_evts.SetValue("200")
    self.max_evts_panel.SetSizer(self.max_evts_sizer)
    self.scan_runs_sizer.Add(self.max_evts_panel)

    self.scan_runs_list = dlg.EdListCtrl(self.scan_runs_panel,
                                         style=wx.LC_EDIT_LABELS | wx.LC_REPORT,
                                         size=(200,165))

    self.scan_runs_list.InsertColumn(0, 'Run', width=60)
    self.scan_runs_list.InsertColumn(1, 'Notch Energy (eV)', width=140)
    self.scan_runs_list.integer_columns = {0}
    self.scan_runs_list.InsertItem(0, 0)
    self.scan_runs_list.Select(0)

    self.scan_runs_sizer.Add(self.scan_runs_list, 1)

    self.scan_runs_button_panel = wx.Panel(self.scan_runs_panel)
    self.scan_runs_button_sizer = wx.GridBagSizer(0,0)
    self.scan_runs_button_add   = wx.Button(self.scan_runs_button_panel,
                                            size=(94, -1),
                                            label='Add Row')
    self.scan_runs_button_clear = wx.Button(self.scan_runs_button_panel,
                                            size=(94, -1),
                                            label='Clear All')
    self.scan_runs_button_run   = wx.Button(self.scan_runs_button_panel,
                                            size=(194, -1),
                                            label='Run Calibration')
    self.scan_runs_button_sizer.Add(self.scan_runs_button_add,
                                    pos=(0,0), border=3, flag=wx.ALL)
    self.scan_runs_button_sizer.Add(self.scan_runs_button_clear,
                                    pos=(0,1), border=3, flag=wx.ALL)
    self.scan_runs_button_sizer.Add(self.scan_runs_button_run,
                                    pos=(1,0), span=(1,2), border=3, flag=wx.ALL | wx.EXPAND)
    self.scan_runs_button_panel.SetSizer(self.scan_runs_button_sizer)

    self.scan_runs_sizer.Add(self.scan_runs_button_panel, 1)
    self.calib_grid_sizer.Add(self.scan_runs_panel, pos=(0, 0))

    # FEE scan trendline
    self.trendline_panel = wx.Panel(self.calib_panel)
    self.trendline_sizer = wx.BoxSizer(wx.HORIZONTAL)
    self.trendline_panel.SetSizer(self.trendline_sizer)

    self.trendline_figure = mpl.figure.Figure(figsize=(4,2.3))
    self.trendline_canvas = FigureCanvas(self.trendline_panel, -1, self.trendline_figure)
    self.trendline_toolbar = NavigationToolbar(self.trendline_canvas)
    self.trendline_toolbar.SetWindowStyle(wx.TB_VERTICAL)
    self.trendline_toolbar.Realize()

    self.trendline_sizer.Add(self.trendline_canvas, 1, flag=wx.EXPAND | wx.ALL)
    self.trendline_sizer.Add(self.trendline_toolbar, 0)

    self.calib_grid_sizer.Add(self.trendline_panel, pos=(0, 1), flag=wx.EXPAND | wx.ALL)

    # FEE scan spectra
    self.spectra_panel = wx.Panel(self.calib_panel)
    self.spectra_sizer = wx.BoxSizer(wx.HORIZONTAL)
    self.spectra_panel.SetSizer(self.spectra_sizer)

    self.spectra_figure = mpl.figure.Figure(figsize=(4,2.3))
    self.spectra_canvas = FigureCanvas(self.spectra_panel, -1, self.spectra_figure)
    self.spectra_toolbar = NavigationToolbar(self.spectra_canvas)
    self.spectra_toolbar.SetWindowStyle(wx.TB_VERTICAL)
    self.spectra_toolbar.Realize()

    self.spectra_sizer.Add(self.spectra_canvas, 1, flag=wx.EXPAND | wx.ALL)
    self.spectra_sizer.Add(self.spectra_toolbar, 0)

    self.calib_grid_sizer.Add(self.spectra_panel, pos=(0, 2), flag=wx.EXPAND | wx.ALL)

    # Ebeam calibration section
    self.ebeam_runs_panel = ScrolledPanel(self.calib_panel, size=(220, 270))
    self.ebeam_runs_sizer = wx.BoxSizer(wx.VERTICAL)
    self.ebeam_runs_panel.SetSizer(self.ebeam_runs_sizer)

    self.ebeam_runs_selection = gctr.CheckListCtrl(self.ebeam_runs_panel,
                                                   label='Runs for Ebeam Calibration',
                                                   label_size=(200, -1),
                                                   label_style='normal',
                                                   ctrl_size=(200, 160),
                                                   direction='vertical',
                                                   choices=[])

    self.ebeam_runs_sizer.Add(self.ebeam_runs_selection, 1, flag=wx.EXPAND)

    self.ebeam_runs_button_panel = wx.Panel(self.ebeam_runs_panel)
    self.ebeam_runs_button_sizer = wx.GridBagSizer(0,0)
    self.ebeam_runs_refresh_button = wx.Button(self.ebeam_runs_button_panel,
                                               label='Refresh',
                                               size=(94, -1))
    self.ebeam_runs_clear_button = wx.Button(self.ebeam_runs_button_panel,
                                             label='Clear',
                                             size=(94, -1))
    self.ebeam_runs_launch_button = wx.Button(self.ebeam_runs_button_panel,
                                              label='Run Calibration',
                                              size=(194, -1))
    self.ebeam_runs_button_sizer.Add(self.ebeam_runs_refresh_button,
                                     pos=(0,0), border=3, flag=wx.ALL)
    self.ebeam_runs_button_sizer.Add(self.ebeam_runs_clear_button,
                                     pos=(0,1), border=3, flag=wx.ALL)
    self.ebeam_runs_button_sizer.Add(self.ebeam_runs_launch_button,
                                     pos=(1,0), span=(1,2), border=3, flag=wx.ALL)
    self.ebeam_runs_button_panel.SetSizer(self.ebeam_runs_button_sizer)

    self.ebeam_runs_sizer.Add(self.ebeam_runs_button_panel, 0)

    self.calib_grid_sizer.Add(self.ebeam_runs_panel, pos=(1, 0))

    # Ebeam vs calibrated FEE spectra overlay
    self.ebeam_panel = wx.Panel(self.calib_panel)
    self.ebeam_sizer = wx.BoxSizer(wx.HORIZONTAL)
    self.ebeam_panel.SetSizer(self.ebeam_sizer)

    self.ebeam_figure = mpl.figure.Figure(figsize=(4,2.3))
    self.ebeam_canvas = FigureCanvas(self.ebeam_panel, -1, self.ebeam_figure)
    self.ebeam_toolbar = NavigationToolbar(self.ebeam_canvas)
    self.ebeam_toolbar.SetWindowStyle(wx.TB_VERTICAL)
    self.ebeam_toolbar.Realize()

    self.ebeam_sizer.Add(self.ebeam_canvas, 1, flag=wx.EXPAND | wx.ALL)
    self.ebeam_sizer.Add(self.ebeam_toolbar, 0)

    self.calib_grid_sizer.Add(self.ebeam_panel, pos=(1, 1), flag=wx.EXPAND | wx.ALL)

    # Display and export calibrated values
    self.results_panel = wx.Panel(self.calib_panel)
    self.results_box = wx.StaticBox(self.results_panel, label='Calibration Results', size=(300, 200))
    self.results_sizer = wx.StaticBoxSizer(self.results_box, wx.VERTICAL)
    self.results_panel.SetSizer(self.results_sizer)
    self.results_text_sizer = wx.GridBagSizer(3, 3)

    self.results_text_sizer.Add(
        wx.StaticText(self.results_box, label='FEE eV per pixel:', size=(120, -1)),
                                                     pos=(0,0), border=5, flag=wx.TOP)
    self.eV_per_px_text = wx.StaticText(self.results_box, label='', size=(180, -1))
    self.results_text_sizer.Add(self.eV_per_px_text, pos=(0,1), border=5, flag=wx.TOP)

    self.results_text_sizer.Add(
        wx.StaticText(self.results_box, label='FEE eV offset:', size=(120, -1)),
                                                     pos=(1,0), border=5, flag=wx.TOP)
    self.eV_offset_text = wx.StaticText(self.results_box, label='', size=(180, -1))
    self.results_text_sizer.Add(self.eV_offset_text, pos=(1,1), border=5, flag=wx.TOP)

    self.results_text_sizer.Add(
        wx.StaticText(self.results_box, label='Ebeam offset:', size=(120, -1)),
                                                        pos=(2,0), border=5, flag=wx.TOP)
    self.ebeam_offset_text = wx.StaticText(self.results_box, label='', size=(180, -1))
    self.results_text_sizer.Add(self.ebeam_offset_text, pos=(2,1), border=5, flag=wx.TOP)

    self.results_sizer.Add(self.results_text_sizer)

    self.export_button = wx.Button(self.results_box, label='Save calibration', size=(300, -1))
    self.results_sizer.Add(self.export_button)

    self.save_notif_text = wx.StaticText(self.results_box, label='')
    self.results_text_sizer.Add(self.save_notif_text, pos=(3,0))

    self.calib_grid_sizer.Add(self.results_panel, pos=(1,2), flag=wx.ALIGN_CENTER)

    self.calib_sizer.Add(self.calib_grid_sizer, flag=wx.EXPAND | wx.ALL, border=10)
    self.main_sizer.Add(self.calib_panel, 1, flag=wx.EXPAND | wx.ALL, border=10)

    # Bindings
    self.Bind(wx.EVT_BUTTON, self.onAddScanRuns, self.scan_runs_button_add)
    self.Bind(wx.EVT_BUTTON, self.onClearScanRuns, self.scan_runs_button_clear)
    self.Bind(wx.EVT_BUTTON, self.onRunFEECalib, self.scan_runs_button_run)
    self.Bind(wx.EVT_BUTTON, self.onRunsRefresh, self.ebeam_runs_refresh_button)
    self.Bind(wx.EVT_BUTTON, self.onRunsClear, self.ebeam_runs_clear_button)
    self.Bind(wx.EVT_BUTTON, self.onRunEbeamCalib, self.ebeam_runs_launch_button)
    self.Bind(wx.EVT_BUTTON, self.onSaveCalib, self.export_button)

    self.Layout()
    self.Fit()

  def onAddScanRuns(self, e):
    n_rows = self.scan_runs_list.GetItemCount()
    self.scan_runs_list.InsertItem(n_rows, 0)
    self.scan_runs_list.Select(n_rows)

  def onClearScanRuns(self, e):
    n_rows = self.scan_runs_list.GetItemCount()
    self.scan_runs_list.DeleteAllItems()
    self.scan_runs_list.InsertItem(0, 0)
    self.scan_runs_list.Select(0)
    e.Skip()

  def onRunFEECalib(self, e):
    self.clear_FEE_calib()
    self.refresh_runs()
    fee_runs = []
    fee_energies = []

    self.experiment = self.scan_runs_experiment.GetValue()
    if self.experiment.strip() == '':
      if self.main.params.facility.name == 'lcls':
        self.experiment = self.main.params.facility.lcls.experiment
      else:
        self.experiment = None
    self.max_events = int(self.max_evts.GetValue())

    #TODO: validation during input instead?
    self.fee_runs = []
    self.fee_energies = []
    for row in range(self.scan_runs_list.GetItemCount()):
      run = self.scan_runs_list.GetItem(itemIdx=row, col=0).GetText()
      if not run in self.all_runs:
        dlg = wx.MessageDialog(self,
                               message=f'Run {run} not recognized.',
                               caption='Error',
                               style=wx.OK | wx.ICON_ERROR)
        dlg.ShowModal()
        return
      self.fee_runs.append(run)

      try:
        energy = float(self.scan_runs_list.GetItem(itemIdx=row, col=1).GetText())
      except ValueError:
        dlg = wx.MessageDialog(self,
                               message=f'Energy {energy} for run {run} not a float.',
                               caption='Error',
                               style=wx.OK | wx.ICON_ERROR)
        dlg.ShowModal()
        return
      self.fee_energies.append(energy)
    self.fee_calib_stale = True
    e.Skip()

  def onRunEbeamCalib(self, e):
    #self.ebeam_offset_text.SetLabel('')
    self.selected_runs = self.ebeam_runs_selection.ctr.GetCheckedStrings()
    self.max_events = int(self.max_evts.GetValue())
    self.ebeam_calib_stale = True
    e.Skip()

  def onRunsRefresh(self, e):
    self.refresh_runs()
    e.Skip()

  def onRunsClear(self, e):
    self.ebeam_runs_selection.ctr.SetCheckedItems([])
    self.ebeam_figure.clear()
    self.ebeam_offset_text.SetLabel('')
    self.save_notif_text.SetLabel('')
    e.Skip()

  def onSaveCalib(self, e):
    save_dlg = wx.FileDialog(self,
                             message='Save FEE Calibration',
                             defaultDir=os.path.join(str(self.main.db.params.output_folder), '..', 'fee'),
                             defaultFile='fee_calib.phil',
                             wildcard='*.phil',
                             style=wx.FD_SAVE | wx.FD_OVERWRITE_PROMPT)
    if save_dlg.ShowModal() == wx.ID_OK:
      self.write_calib_phil(save_dlg.GetPath())
    e.Skip()

  def refresh_runs(self):
    try:
      all_runs = self.main.db.get_all_runs()
      for run in all_runs:
        if run.run not in self.all_runs:
          self.ebeam_runs_selection.ctr.Append(str(run.run))
          self.all_runs.append(run.run)
    except AttributeError:
      print('Unable to find runs')

  def clear_FEE_calib(self):
    for figure in (self.trendline_figure, self.spectra_figure, self.ebeam_figure):
      figure.clear()
    for text in (self.eV_per_px_text, self.eV_offset_text, self.ebeam_offset_text, self.save_notif_text):
      text.SetLabel('')

  def write_calib_phil(self, path):
    lines = []
    if self.fee_eV_per_pixel is not None:
      lines.append(f'spectrum_eV_per_pixel={self.fee_eV_per_pixel}\n')
    if self.fee_eV_offset is not None:
      lines.append(f'spectrum_eV_offset={self.fee_eV_offset}\n')
    if self.ebeam_eV_offset is not None:
      lines.append(f'ebeam_eV_offset={self.ebeam_eV_offset}\n')
    if self.ebeam_wavelength_offset is not None:
      lines.append(f'wavelength_offset={self.ebeam_wavelength_offset}\n')
    with open(path, 'w') as outfile:
      for line in lines:
        outfile.write(line)
    print(f'Wrote calibrated values to {path}')

class TrialsTab(BaseTab):
  def __init__(self, parent, main):
    BaseTab.__init__(self, parent=parent)
    self.name = 'Trials'

    self.main = main
    self.show_active_only = False

    self.trial_panel = ScrolledPanel(self, size=(200, 200))
    self.trial_sizer = wx.BoxSizer(wx.HORIZONTAL)
    self.trial_panel.SetSizer(self.trial_sizer)

    self.btn_sizer = wx.FlexGridSizer(1, 2, 0, 10)
    self.btn_sizer.AddGrowableCol(0)
    self.btn_add_trial = wx.Button(self, label='New Trial', size=(120, -1))
    self.btn_active_only = wx.ToggleButton(self,
                                           label='Show Only Active Trials',
                                    size=(180, self.btn_add_trial.GetSize()[1]))
    self.btn_sizer.Add(self.btn_active_only, flag=wx.ALIGN_RIGHT)
    self.btn_sizer.Add(self.btn_add_trial)

    self.main_sizer.Add(self.trial_panel, 1, flag=wx.EXPAND | wx.ALL, border=10)
    self.main_sizer.Add(self.btn_sizer, flag=wx.EXPAND | wx.ALL, border=10)

    # Bindings
    self.Bind(EVT_RUN_REFRESH, self.onRefresh)
    self.Bind(wx.EVT_BUTTON, self.onAddTrial, self.btn_add_trial)
    self.Bind(wx.EVT_TOGGLEBUTTON, self.onActiveOnly, self.btn_active_only)

  def onRefresh(self, e):
    self.refresh_trials()

  def refresh_trials(self):
    self.trial_sizer.Clear(delete_windows=True)
    self.all_trials = self.main.db.get_all_trials()
    for trial in self.all_trials:
      if self.show_active_only:
        if trial.active:
          self.add_trial(trial=trial)
      else:
        self.add_trial(trial=trial)

    self.trial_panel.SetSizer(self.trial_sizer)
    #self.trial_panel.Layout()
    self.trial_sizer.Layout()
    self.trial_panel.SetupScrolling(scrollToTop=False)

  def add_trial(self, trial):
    new_trial = TrialPanel(self.trial_panel,
                           db=self.main.db,
                           trial=trial,
                           box_label='Trial {} {}'.format(trial.trial,
                             trial.comment[:min(len(trial.comment), 20)] if trial.comment is not None else ""))
    new_trial.chk_active.SetValue(trial.active)
    new_trial.refresh_trial()
    self.trial_sizer.Add(new_trial, flag=wx.EXPAND | wx.ALL, border=10)

  def onAddTrial(self, e):
    new_trial_dlg = dlg.TrialDialog(self, db=self.main.db)
    new_trial_dlg.Fit()

    if new_trial_dlg.ShowModal() == wx.ID_OK:
      self.refresh_trials()

  def onActiveOnly(self, e):
    self.show_active_only = self.btn_active_only.GetValue()
    self.refresh_trials()


class JobsTab(BaseTab):
  def __init__(self, parent, main):
    BaseTab.__init__(self, parent=parent)
    self.name = 'Jobs'

    self.main = main
    self.all_trials = []
    self.all_jobs = None
    self.filter = 'All jobs'
    self.data = {}

    self.job_list = gctr.SortableListCtrl(self, style=wx.LC_REPORT|wx.BORDER_SUNKEN)
    self.job_list.InsertColumn(0, "Job")
    self.job_list.InsertColumn(1, "Type")
    self.job_list.InsertColumn(2, "Dataset")
    self.job_list.InsertColumn(3, "Trial")
    self.job_list.InsertColumn(4, "Run")
    self.job_list.InsertColumn(5, "Block")
    self.job_list.InsertColumn(6, "Task")
    self.job_list.InsertColumn(7, "Subm ID")
    self.job_list.InsertColumn(8, "Status")

    self.job_list.integer_columns = {0, 6}
    self.job_list_sort_flag = [0, 0, 0, 0, 0, 0, 0, 0, 0]
    self.job_list_col = 0

    self.trial_choice = gctr.ChoiceCtrl(self,
                                        label='Filter by:',
                                        label_size=(60, -1),
                                        label_style='normal',
                                        ctrl_size=(100, -1),
                                        choices=[])
    self.btn_stop_job = wx.Button(self, label='Stop job', size=(120, -1))
    self.btn_delete_job = wx.Button(self, label='Delete job', size=(120, -1))
    self.btn_restart_job = wx.Button(self, label='Restart job', size=(120, -1))
    self.chk_active = wx.CheckBox(self, label='Only display jobs from active trials/blocks')
    self.chk_active.SetValue(True)
    self.option_sizer = wx.FlexGridSizer(1, 5, 0, 20)
    self.option_sizer.AddMany([(self.trial_choice), (self.chk_active), (self.btn_stop_job), (self.btn_delete_job), (self.btn_restart_job)])

    self.main_sizer.Add(self.job_list, 1, flag=wx.EXPAND | wx.ALL, border=10)
    self.main_sizer.Add(self.option_sizer, flag=wx.EXPAND | wx.ALL, border=10)


    self.Bind(wx.EVT_BUTTON, self.onStopJob, self.btn_stop_job)
    self.Bind(wx.EVT_BUTTON, self.onDeleteJob, self.btn_delete_job)
    self.Bind(wx.EVT_BUTTON, self.onRestartJob, self.btn_restart_job)
    self.Bind(wx.EVT_CHOICE, self.onTrialChoice, self.trial_choice.ctr)
    self.chk_active.Bind(wx.EVT_CHECKBOX, self.onToggleActive)
    self.Bind(EVT_JOB_MONITOR, self.onMonitorJobs)
    self.Bind(wx.EVT_LIST_COL_CLICK, self.onColClick, self.job_list)

  def onToggleActive(self, e):
    self.main.job_monitor.only_active_jobs = self.chk_active.GetValue()

  def onTrialChoice(self, e):
    self.filter = self.trial_choice.ctr.GetString(
                  self.trial_choice.ctr.GetSelection())

  def GetSelectedJobIds(self):
    return [self.job_list.GetItemData(i) for i in range(self.job_list.GetItemCount()) if self.job_list.IsSelected(i)]

  def onStopJob(self, e):
    if self.all_jobs is None:
      return

    jobs_to_stop = self.GetSelectedJobIds()
    if len(jobs_to_stop) == 0:
      return

    if len(jobs_to_stop) == 1:
      message='Are you sure to stop job %d?'%jobs_to_stop[0]
    else:
      message='Are you sure to stop %d jobs?'%len(jobs_to_stop)

    msg = wx.MessageDialog(self,
                           message=message,
                           caption='Warning',
                           style=wx.YES_NO | wx.ICON_EXCLAMATION)

    if (msg.ShowModal() == wx.ID_NO):
      return

    from xfel.ui.components.submission_tracker import JobStopper
    stopper = JobStopper(self.main.params.mp.method)
    for job in self.all_jobs:
      if job.id in jobs_to_stop:
        stopper.stop_job(job.submission_id)

  def onDeleteJob(self, e):
    if self.all_jobs is None:
      return

    jobs_to_delete = self.GetSelectedJobIds()
    if len(jobs_to_delete) == 0:
      return

    if len(jobs_to_delete) == 1:
      message='Are you sure to delete all processing results from job %d?'%jobs_to_delete[0]
    else:
      message='Are you sure to delete all processing results from %d jobs?'%len(jobs_to_delete)

    msg = wx.MessageDialog(self,
                           message=message,
                           caption='Warning',
                           style=wx.YES_NO | wx.ICON_EXCLAMATION)

    if (msg.ShowModal() == wx.ID_NO):
      return

    for job in self.all_jobs:
      if job.id in jobs_to_delete:
        job.delete()

  def onRestartJob(self, e):
    if self.all_jobs is None:
      return

    jobs_to_restart = self.GetSelectedJobIds()
    if len(jobs_to_restart) == 0:
      return

    if len(jobs_to_restart) == 1:
      message='Are you sure to restart job %d? This will delete all processing results from from this job and re-submit it. Be sure the job has been stopped first.'%jobs_to_restart[0]
    else:
      message='Are you sure to restart %d jobs? This will delete all processing results from these jobs and re-submit them. Be sure the jobs have been stopped first.'%len(jobs_to_restart)

    msg = wx.MessageDialog(self,
                           message=message,
                           caption='Warning',
                           style=wx.YES_NO | wx.ICON_EXCLAMATION)

    if (msg.ShowModal() == wx.ID_NO):
      return

    for job in self.all_jobs:
      if job.id in jobs_to_restart:
        job.delete()
        if job.status != "DELETED":
          print("Couldn't restart job", job.id, "job is not deleted")
          continue
        job.remove_from_db()

  def onMonitorJobs(self, e):
    # Find new trials
    if e.trials is not None:
      all_db_trials = [str(i.trial) for i in e.trials]
      new_trials = [i for i in all_db_trials if i not in self.all_trials]
      if len(new_trials) > 0:
        self.find_trials()
        self.all_trials = all_db_trials

    if e.jobs is not None:
      self.all_jobs = e.jobs
      if str(self.filter).lower() == 'all jobs':
        selected_trials = [int(t) for t in self.all_trials]
      else:
        selected_trials = [int(self.filter.split()[-1])]

      selected_jobs = self.GetSelectedJobIds()
      if self.job_list.GetFocusedItem() > 0:
        focused_job_id = self.job_list.GetItemData(self.job_list.GetFocusedItem())
      else:
        focused_job_id = None

      self.data = {} # reset contents of the table, with unique row ids

      # assemble updated list of job ids
      job_list_ids = [self.job_list.GetItemData(i) for i in range(self.job_list.GetItemCount())]

      for job in e.jobs:
        if job.trial is not None:
          if job.trial.trial not in selected_trials: continue

        # Order: job, type, dataset, trial, run, rungroup, submission id, status
        j = str(job.id)
        jt = job.task.type if job.task is not None else "-"
        ds = job.dataset.name if job.dataset is not None else "-"
        t = "t%03d" % job.trial.trial if job.trial is not None else "-"
        try:
          r = "r%04d" % int(job.run.run) if job.run is not None else "-"
        except ValueError:
          r = "r%s" % job.run.run
        rg = "rg%03d" % job.rungroup.id if job.rungroup is not None else "-"
        tsk = "%d" % job.task.id if job.task is not None else "-"
        sid = str(job.submission_id)

        short_status = str(job.status).strip("'")
        if short_status == "SUBMIT_FAIL":
          short_status = "S_FAIL"
        elif short_status == "SUBMITTED":
          short_status = "SUBMIT"
        s = short_status

        self.data[job.id] = [j, jt, ds, t, r, rg, tsk, sid, s]
        found_it = False
        # Look to see if item already in list
        for i, jid in enumerate(job_list_ids):
          if jid == job.id:
            for k, item in enumerate(self.data[job.id]):
              self.job_list.SetItem(i, k, item)
            found_it = True
            break
        if found_it: continue

        # Item not present, so deposit the row in the table
        local_job_id = self.job_list.Append(self.data[job.id])
        self.job_list.SetItemData(local_job_id, job.id)

      # Remove items not sent in the event or otherwise filtered out
      # Need to do it in reverse order to avoid list re-ordering when deleting items
      for i in reversed(range(self.job_list.GetItemCount())):
        if self.job_list.GetItemData(i) not in self.data:
          self.job_list.DeleteItem(i)

      # Initialize sortable column mixin
      self.job_list.initialize_sortable_columns(n_col=5, itemDataMap=self.data)
      self.job_list.RestoreSortOrder(self.job_list_col, self.job_list_sort_flag)

      # Restore selected items
      for i in range(self.job_list.GetItemCount()):
        job_id = self.job_list.GetItemData(i)
        if job_id in selected_jobs:
          self.job_list.Select(i)
        if job_id == focused_job_id:
          self.job_list.Focus(i)

  def onColClick(self, e):
    # Note: the sortable list binds the event first and activates this method after.
    # print "Click recorded in column %s" % str(self.job_list._col) ## DEBUG
    # print self.job_list.GetSortState() ## DEBUG
    self.job_list_col = self.job_list._col
    self.job_list_sort_flag = self.job_list._colSortFlag

  def find_trials(self):
    print("Found trials")
    if self.main.db is not None:
      choices = ['All jobs'] + \
                ['trial {}'.format(i.trial) for i in self.main.db.get_all_trials()]
      self.trial_choice.ctr.Clear()
      for choice in choices:
        self.trial_choice.ctr.Append(choice)

      if self.filter == 'All jobs':
        self.trial_choice.ctr.SetSelection(0)
      else:
        self.trial_choice.ctr.SetSelection(int(self.filter[-1]))

class SpotfinderTab(BaseTab):
  def __init__(self, parent, main):
    BaseTab.__init__(self, parent=parent)
    self.name = 'Spotfinder'

    self.main = main
    self.all_trials = []
    self.trial_no = None
    self.trial = None
    self.all_runs = []
    self.selected_runs = []
    self.tag_trial_changed = True
    self.tag_runs_changed = True
    self.tag_last_five = False
    self.entire_expt = False
    self.png = None
    self.static_bitmap = None
    self.redraw_windows = True
    self.n_min = 4

    self.spotfinder_panel = wx.Panel(self, size=(100, 100))
    self.spotfinder_panelsize = self.spotfinder_panel.GetSize()
    self.spotfinder_box = wx.StaticBox(self.spotfinder_panel, label='Run Statistics')
    self.spotfinder_sizer = wx.StaticBoxSizer(self.spotfinder_box, wx.HORIZONTAL)
    self.spotfinder_panel.SetSizer(self.spotfinder_sizer)

    self.trial_number = gctr.ChoiceCtrl(self,
                                        label='Trial:',
                                        label_size=(90, -1),
                                        label_style='normal',
                                        ctrl_size=(100, -1),
                                        choices=[])
    self.last_five_runs =  wx.Button(self,
                                     label='Auto plot last five runs',
                                     size=(200, -1))
    self.plot_entire_expt = wx.Button(self,
                                     label='Auto plot entire experiment',
                                     size=(200,-1))
    self.n_min_selector = gctr.OptionCtrl(self,
                                          label='minimum # spots:',
                                          label_size=(160, -1),
                                          ctrl_size=(30, -1),
                                          items=[('n_min', 4)])
    self.run_numbers =  gctr.CheckListCtrl(self,
                                           label='Selected runs:',
                                           label_size=(200, -1),
                                           label_style='normal',
                                           ctrl_size=(150, 224),
                                           direction='vertical',
                                           choices=[])

    self.bottom_sizer = wx.FlexGridSizer(1, 2, 0, 4)

    options_box = wx.StaticBox(self, label='Display Options')
    self.options_box_sizer = wx.StaticBoxSizer(options_box, wx.VERTICAL)
    self.options_opt_sizer = wx.GridBagSizer(1, 1)

    self.options_opt_sizer.Add(self.trial_number, pos=(0, 0),
                               flag=wx.ALL, border=2)
    self.options_opt_sizer.Add(self.last_five_runs, pos=(1, 0),
                               flag=wx.ALL, border=2)
    self.options_opt_sizer.Add(self.plot_entire_expt, pos=(2, 0),
                               flag=wx.ALL, border=2)
    self.options_opt_sizer.Add(self.n_min_selector, pos=(3, 0),
                               flag=wx.ALL, border=2)
    self.options_opt_sizer.Add(self.run_numbers, pos=(0, 1), span=(8, 1),
                               flag=wx.BOTTOM | wx.TOP | wx.RIGHT | wx.EXPAND,
                               border=10)
    self.options_box_sizer.Add(self.options_opt_sizer)
    self.bottom_sizer.Add(self.options_box_sizer)

    self.main_sizer.Add(self.spotfinder_panel, 1,
                        flag=wx.EXPAND | wx.ALL, border=10)
    self.main_sizer.Add(self.bottom_sizer, 0,
                        flag=wx.EXPAND | wx.ALL, border=10)

    # Bindings
    self.Bind(wx.EVT_CHOICE, self.onTrialChoice, self.trial_number.ctr)
    self.Bind(wx.EVT_BUTTON, self.onLastFiveRuns, self.last_five_runs)
    self.Bind(wx.EVT_BUTTON, self.onEntireExpt, self.plot_entire_expt)
    self.Bind(wx.EVT_TEXT_ENTER, self.onNMin, self.n_min_selector.n_min)
    self.Bind(wx.EVT_CHECKLISTBOX, self.onRunChoice, self.run_numbers.ctr)
    self.Bind(EVT_SPOTFINDER_REFRESH, self.onRefresh)
    self.Bind(wx.EVT_SIZE, self.OnSize)

  def OnSize(self, e):
    self.spotfinder_panelsize = self.spotfinder_panel.GetSize()
    e.Skip()

  def onTrialChoice(self, e):
    trial_idx = self.trial_number.ctr.GetSelection()
    if trial_idx == 0:
      self.trial_no = None
      self.trial = None
      self.run_numbers.ctr.Clear()
      self.all_runs = []
      self.selected_runs = []
    else:
      trial_no = self.trial_number.ctr.GetClientData(trial_idx)
      if trial_no is not None:
        self.trial_no = int(trial_no)
        self.trial = self.main.db.get_trial(trial_number=int(self.trial_no))
        self.spotfinder_box.SetLabel('Spotfinder Results - Trial {}'.format(self.trial_no))
        self.find_runs()

  def onRunChoice(self, e):
    self.tag_last_five = False
    self.entire_expt = False
    run_numbers_selected = self.run_numbers.ctr.GetCheckedStrings()
    if self.trial is not None:
      self.selected_runs = [r.run for r in self.trial.runs if r.run in run_numbers_selected]
      self.main.run_window.spotfinder_light.change_status('idle')

  def find_trials(self):
    all_db_trials = [str(i.trial) for i in self.main.db.get_all_trials()]
    new_trials = [i for i in all_db_trials if i not in self.all_trials]
    if len(new_trials) > 0:
      self.trial_number.ctr.Clear()
      self.all_trials = [None] + all_db_trials
      for trial in self.all_trials:
        if trial is None:
          entry = 'None'
          self.trial_number.ctr.Append(entry)
          self.trial_number.ctr.SetClientData(0, None)
        else:
          entry = trial
          self.trial_number.ctr.Append(entry)
          item_idx = self.trial_number.ctr.FindString(entry)
          self.trial_number.ctr.SetClientData(item_idx, trial)

      if self.trial_no is not None:
        self.trial_number.ctr.SetSelection(self.trial_no)
      else:
        self.trial_number.ctr.SetSelection(0)

  def find_runs(self):
    self.run_numbers.ctr.Clear()
    if self.trial is not None:
      self.runs_available = [str(r.run) for r in self.trial.runs]
      if len(self.all_runs) > 0:
        self.run_numbers.ctr.InsertItems(items=self.all_runs, pos=0)

  def onRefresh(self, e):
    self.refresh_trials()
    self.refresh_runs()
    if self.tag_last_five:
      self.select_last_n_runs(5)
    elif self.entire_expt:
      self.select_all()
    if self.redraw_windows:
      self.plot_static_spotfinder_stats()
      self.redraw_windows = False
    if self.trial is not None:
      self.spotfinder_box.SetLabel('Spotfinder Results - Trial {}'.format(self.trial_no))
    else:
      self.spotfinder_box.SetLabel('Spotfinder Results - No trial selected')

  def refresh_trials(self):
    if self.all_trials == []:
      self.find_trials()
    avail_trials = [str(i.trial) for i in self.main.db.get_all_trials()]
    for t in avail_trials:
      if t not in self.all_trials:
        self.trial_number.ctr.Append(t)
        self.all_trials.append(t)
        item_idx = self.trial_number.ctr.FindString(t)
        self.trial_number.ctr.SetClientData(item_idx, t)

  def refresh_runs(self):
    if self.all_runs == []:
      self.find_runs()
    if self.trial is not None:
      avail_runs = [str(r.run) for r in self.trial.runs]
      for r in avail_runs:
        if r not in self.all_runs:
          self.run_numbers.ctr.Append(r)
          self.all_runs.append(r)

  def plot_static_spotfinder_stats(self):
    if self.png is not None:
      if self.static_bitmap is not None:
        self.static_bitmap.Destroy()
      img = wx.Image(self.png, wx.BITMAP_TYPE_ANY)
      self.static_bitmap = wx.StaticBitmap(
        self.spotfinder_panel, wx.ID_ANY, wx.Bitmap(img))
      self.spotfinder_sizer.Add(self.static_bitmap, 0, wx.EXPAND | wx.ALL, 3)
      self.spotfinder_panel.SetSizer(self.spotfinder_sizer)
      self.spotfinder_panel.Layout()

  def select_last_n_runs(self, n):
    if self.trial is not None:
      self.selected_runs = [r.run for r in self.trial.runs][-n:]

  def select_all(self):
    if self.trial is not None:
      self.selected_runs = [r.run for r in self.trial.runs]

  def onLastFiveRuns(self, e):
    self.entire_expt = False
    self.tag_last_five = True
    self.select_last_n_runs(5)
    self.main.run_window.spotfinder_light.change_status('idle')

  def onEntireExpt(self, e):
    self.entire_expt = True
    self.tag_last_five = False
    self.select_all()
    self.main.run_window.spotfinder_light.change_status('idle')

  def onNMin(self, e):
    n_min = self.n_min_selector.n_min.GetValue()
    if n_min.isdigit():
      self.n_min = int(n_min)

class RunStatsTab(SpotfinderTab):
  def __init__(self, parent, main):
    BaseTab.__init__(self, parent=parent)
    self.name = 'Run Stats'

    self.main = main
    self.all_trials = []
    self.trial_no = None
    self.trial = None
    self.all_runs = []
    self.selected_runs = []
    self.tag_trial_changed = True
    self.tag_runs_changed = True
    self.tag_last_five = False
    self.entire_expt = False
    self.d_min = 2
    self.n_multiples = 2
    self.ratio = 1
    self.n_strong = 16
    self.i_sigi = 1
    self.n_dump = 10
    self.should_have_indexed_image_paths = None
    self.should_have_indexed_timestamps = None
    self.strong_indexed_image_paths = None
    self.strong_indexed_image_timestamps = None
    self.auto_update = True
    self.sf_frame = None
    self.cached_run = None

    self.runstats_panel = wx.Panel(self, size=(100, 100))
    self.runstats_box = wx.StaticBox(self.runstats_panel, label='Run Statistics')
    self.runstats_sizer = wx.StaticBoxSizer(self.runstats_box, wx.HORIZONTAL)
    self.runstats_panel.SetSizer(self.runstats_sizer)

    import matplotlib as mpl
    from matplotlib.backends.backend_wxagg import (
      FigureCanvasWxAgg as FigureCanvas,
      NavigationToolbar2WxAgg as NavigationToolbar)

    self.figure = mpl.figure.Figure()
    self.canvas = FigureCanvas(self.runstats_box, -1, self.figure)
    self.toolbar = NavigationToolbar(self.canvas)
    self.toolbar.SetWindowStyle(wx.TB_VERTICAL)
    self.toolbar.Realize()

    self.runstats_sizer.Add(self.canvas, 1, wx.EXPAND)
    self.runstats_sizer.Add(self.toolbar, 0, wx.LEFT | wx.EXPAND)

    self.options_box = wx.StaticBox(self, label='Statistics Options')

    self.trial_number = gctr.ChoiceCtrl(self.options_box,
                                        label='Trial:',
                                        label_size=(90, -1),
                                        label_style='normal',
                                        ctrl_size=(100, -1),
                                        choices=[])
    self.last_five_runs =  wx.Button(self.options_box,
                                     label='Auto plot last five runs',
                                     size=(200, -1))
    self.plot_entire_expt = wx.Button(self.options_box,
                                     label='Auto plot entire experiment',
                                     size=(200,-1))
    self.d_min_select = gctr.OptionCtrl(self.options_box,
                                        name='rs_d_min',
                                        label='High resolution limit:',
                                        sub_labels=[''],
                                        label_size=(160, -1),
                                        ctrl_size=(60, -1),
                                        items=[('d_min', 2.0)])
    self.n_multiples_selector = gctr.OptionCtrl(self.options_box,
                                               name='rs_multiples',
                                               label='# multiples threshold:',
                                               sub_labels=[''],
                                               label_size=(160, -1),
                                               ctrl_size=(60, -1),
                                               items=[('multiples', 2)])
    self.ratio_cutoff = gctr.OptionCtrl(self.options_box,
                                        name='rs_ratio',
                                        label='two theta ratio cutoff:',
                                        sub_labels=[''],
                                        label_size=(160, -1),
                                        ctrl_size=(60, -1),
                                        items=[('ratio', 1)])
    self.n_strong_cutoff = gctr.OptionCtrl(self.options_box,
                                           name='rs_n_strong',
                                           label='# strong spots cutoff:',
                                           sub_labels=[''],
                                           label_size=(160, -1),
                                           ctrl_size=(60, -1),
                                           items=[('n_strong', 16)])
    self.i_sigi_cutoff = gctr.OptionCtrl(self.options_box,
                                         name='rs_isigi',
                                         label='I/sig(I) cutoff:',
                                         sub_labels=[''],
                                         label_size=(160, -1),
                                         ctrl_size=(60, -1),
                                         items=[('isigi', 1)])
    self.n_dump_cutoff = gctr.OptionCtrl(self.options_box,
                                         name='rs_n_dump',
                                         label='# images to dump:',
                                         sub_labels=[''],
                                         label_size=(160, -1),
                                         ctrl_size=(60, -1),
                                         items=[('n_dump', 10)])
    self.run_numbers =  gctr.CheckListCtrl(self.options_box,
                                           label='Selected runs:',
                                           label_size=(200, -1),
                                           label_style='normal',
                                           ctrl_size=(150, 250),
                                           direction='vertical',
                                           choices=[])

    self.strong_indexed_box = wx.StaticBox(self, label='Strongest Indexed Images')
    self.strong_indexed_list = wx.TextCtrl(self.strong_indexed_box,
                                           style=wx.TE_MULTILINE | wx.TE_READONLY)
    self.idx_show_images_button = wx.Button(self.strong_indexed_box,
                                            label='Open images',
                                            size=(200, -1))
    self.should_have_indexed_box = wx.StaticBox(self, label='Strong Images that Didn\'t Index')
    self.should_have_indexed_list = wx.TextCtrl(self.should_have_indexed_box,
                                                style=wx.TE_MULTILINE | wx.TE_READONLY)
    self.shi_dump_images_button = wx.Button(self.should_have_indexed_box,
                                            label='Dump images',
                                            size=(200, -1))

    self.bottom_sizer = wx.FlexGridSizer(1, 2, 0, 10)

    self.options_box_sizer = wx.StaticBoxSizer(self.options_box, wx.VERTICAL)
    self.options_opt_sizer = wx.GridBagSizer(1, 1)

    self.options_opt_sizer.Add(self.trial_number, pos=(0, 0),
                               flag=wx.ALL, border=2)
    self.options_opt_sizer.Add(self.last_five_runs, pos=(1, 0),
                               flag=wx.ALL, border=2)
    self.options_opt_sizer.Add(self.plot_entire_expt, pos=(2, 0),
                                   flag=wx.ALL, border=2)
    self.options_opt_sizer.Add(self.d_min_select, pos=(3, 0),
                               flag=wx.ALL, border=2)
    self.options_opt_sizer.Add(self.n_multiples_selector, pos=(4, 0),
                               flag=wx.ALL, border=2)
    self.options_opt_sizer.Add(self.ratio_cutoff, pos=(5, 0),
                               flag=wx.ALL, border=2)
    self.options_opt_sizer.Add(self.n_strong_cutoff, pos=(7, 0),
                               flag=wx.ALL, border=2)
    self.options_opt_sizer.Add(self.i_sigi_cutoff, pos=(6, 0),
                               flag=wx.ALL, border=2)
    self.options_opt_sizer.Add(self.n_dump_cutoff, pos=(8, 0),
                               flag=wx.ALL, border=2)
    self.options_opt_sizer.Add(self.run_numbers, pos=(0, 1), span=(8, 1),
                               flag=wx.BOTTOM | wx.TOP | wx.RIGHT | wx.EXPAND,
                               border=10)
    self.options_box_sizer.Add(self.options_opt_sizer)
    self.bottom_sizer.Add(self.options_box_sizer)

    self.dump_images_sizer = wx.GridBagSizer(3, 1)

    self.strong_indexed_box_sizer = wx.StaticBoxSizer(self.strong_indexed_box, wx.VERTICAL)

    self.strong_indexed_results_sizer = wx.GridBagSizer(1, 1)
    self.strong_indexed_results_sizer.Add(self.strong_indexed_list, pos=(0, 0),
                                          span=(5, 45),
                                          flag=wx.LEFT | wx.RIGHT | wx.EXPAND,
                                          border=10)
    self.strong_indexed_box_sizer.Add(self.strong_indexed_results_sizer)

    self.strong_indexed_box_sizer.Add(self.idx_show_images_button,
                                      flag=wx.LEFT | wx.RIGHT | wx.ALL | wx.EXPAND,
                                      border=5)

    self.should_have_indexed_box_sizer = wx.StaticBoxSizer(self.should_have_indexed_box, wx.VERTICAL)

    self.should_have_indexed_results_sizer = wx.GridBagSizer(1, 1)
    self.should_have_indexed_results_sizer.Add(self.should_have_indexed_list, pos=(0, 0),
                                               span=(5, 45),
                                               flag=wx.LEFT | wx.RIGHT | wx.EXPAND,
                                               border=10)
    self.should_have_indexed_box_sizer.Add(self.should_have_indexed_results_sizer)

    self.should_have_indexed_box_sizer.Add(self.shi_dump_images_button,
                                           flag=wx.LEFT | wx.RIGHT | wx.ALL | wx.EXPAND,
                                           border=5)

    self.manage_panel = wx.Panel(self)
    self.manage_sizer = wx.BoxSizer(wx.HORIZONTAL)

    self.btn_toggle_options = wx.ToggleButton(self.manage_panel,
                                              label='Hide options')
    self.chk_auto_update = wx.CheckBox(self.manage_panel, label='Auto update')
    self.chk_auto_update.SetValue(True)
    self.manage_sizer.Add(self.btn_toggle_options)
    self.manage_sizer.Add(self.chk_auto_update)
    self.manage_panel.SetSizer(self.manage_sizer)

    self.dump_images_sizer.Add(self.manage_panel, pos=(0, 0))
    self.dump_images_sizer.Add(self.strong_indexed_box_sizer, pos=(1, 0))
    self.dump_images_sizer.Add(self.should_have_indexed_box_sizer, pos=(2, 0))

    if self.main.params.dispatcher != "cctbx.xfel.xtc_process":
      self.n_dump_cutoff.Hide()
      self.strong_indexed_box.Hide()
      self.strong_indexed_list.Hide()
      self.idx_show_images_button.Hide()
      self.should_have_indexed_box.Hide()
      self.should_have_indexed_list.Hide()
      self.shi_dump_images_button.Hide()

    # self.bottom_sizer.Add(self.should_have_indexed_box_sizer, flag=wx.EXPAND | wx.ALL)
    # self.bottom_sizer.Add(self.strong_indexed_box_sizer, flag=wx.EXPAND | wx.ALL)
    self.bottom_sizer.Add(self.dump_images_sizer, flag=wx.EXPAND | wx.ALL)

    self.main_sizer.Add(self.runstats_panel, 1,
                        flag=wx.EXPAND | wx.ALL, border=10)
    self.main_sizer.Add(self.bottom_sizer, 0,
                        flag=wx.EXPAND | wx.ALL, border=10)

    self.static_bitmap = wx.StaticBitmap(
      self.runstats_panel, wx.ID_ANY)#, wx.Bitmap(img))
    self.runstats_sizer.Add(self.static_bitmap, 0, wx.EXPAND | wx.ALL, 3)
    self.runstats_panel.SetSizer(self.runstats_sizer)

    # Bindings
    self.Bind(wx.EVT_CHOICE, self.onTrialChoice, self.trial_number.ctr)
    self.Bind(wx.EVT_BUTTON, self.onLastFiveRuns, self.last_five_runs)
    self.Bind(wx.EVT_BUTTON, self.onEntireExpt, self.plot_entire_expt)
    self.Bind(wx.EVT_TEXT_ENTER, self.onDMin, self.d_min_select.d_min)
    self.Bind(wx.EVT_TEXT_ENTER, self.onMultiples, self.n_multiples_selector.multiples)
    self.Bind(wx.EVT_TEXT_ENTER, self.onRatioCutoff, self.ratio_cutoff.ratio)
    self.Bind(wx.EVT_TEXT_ENTER, self.onHitCutoff, self.n_strong_cutoff.n_strong)
    self.Bind(wx.EVT_TEXT_ENTER, self.onIsigICutoff, self.i_sigi_cutoff.isigi)
    self.Bind(wx.EVT_TEXT_ENTER, self.onNDump, self.n_dump_cutoff.n_dump)
    self.Bind(wx.EVT_CHECKLISTBOX, self.onRunChoice, self.run_numbers.ctr)
    self.Bind(wx.EVT_BUTTON, self.onOpenImages, self.idx_show_images_button)
    self.Bind(wx.EVT_BUTTON, self.onDumpImages, self.shi_dump_images_button)
    self.Bind(wx.EVT_TOGGLEBUTTON, self.onToggleOptions, self.btn_toggle_options)
    self.Bind(wx.EVT_CHECKBOX, self.onChkAutoUpdate, self.chk_auto_update)
    self.Bind(EVT_RUNSTATS_REFRESH, self.onRefresh)
    self.Bind(wx.EVT_SIZE, self.OnSize)

    if hasattr(self.figure, '_cid'):
      self.figure.canvas.mpl_disconnect(self.figure._cid)
    self.figure._cid = self.figure.canvas.mpl_connect('button_press_event', self.onCanvasClick)

    self.Layout()
    self.Fit()
    self.runstats_panelsize = self.runstats_box.GetSize()

  def OnSize(self, e):
    self.runstats_panelsize = self.runstats_box.GetSize()
    e.Skip()

  def onTrialChoice(self, e):
    trial_idx = self.trial_number.ctr.GetSelection()
    self.trial_no = None
    self.trial = None
    self.run_numbers.ctr.Clear()
    self.all_runs = []
    self.selected_runs = []
    if trial_idx > 0:
      trial_no = self.trial_number.ctr.GetClientData(trial_idx)
      if trial_no is not None:
        self.trial_no = int(trial_no)
        self.trial = self.main.db.get_trial(trial_number=int(self.trial_no))
        self.runstats_box.SetLabel('Run Statistics - Trial {}'.format(self.trial_no))
        self.find_runs()

  def onRunChoice(self, e):
    self.tag_last_five = False
    self.entire_expt = False
    run_numbers_selected = self.run_numbers.ctr.GetCheckedStrings()
    if self.trial is not None:
      self.selected_runs = [r.run for r in self.trial.runs if r.run in run_numbers_selected]
      self.main.run_window.runstats_light.change_status('idle')

  def onRefresh(self, e):
    self.refresh_trials()
    self.refresh_runs()
    if self.tag_last_five:
      self.select_last_n_runs(5)
    elif self.entire_expt:
      self.select_all()
    self.print_strong_indexed_paths()
    self.print_should_have_indexed_paths()
    if self.trial is not None:
      self.runstats_box.SetLabel('Run Statistics - Trial {}'.format(self.trial_no))
    else:
      self.runstats_box.SetLabel('Run Statistics - No trial selected')

  def onToggleOptions(self, e):
    if self.btn_toggle_options.GetValue():
      self.options_box.Hide()
      self.strong_indexed_box.Hide()
      self.should_have_indexed_box.Hide()
    else:
      self.options_box.Show()
      if self.main.params.dispatcher == "cctbx.xfel.xtc_process":
        self.strong_indexed_box.Show()
        self.should_have_indexed_box.Show()
    self.Layout()
    self.Fit()

  @staticmethod
  def onCanvasClick(event):
    if event.canvas.toolbar.mode: return
    if event.xdata is None: return
    tab = event.canvas.GetParent().GetParent().GetParent()
    params = tab.main.params
    if params.facility.name != 'lcls': return
    all_stats = tab.main.runstats_sentinel.stats
    if not all_stats:
      return

    if 'strong' in event.inaxes.get_ylabel():
      twod_data = np.concatenate([event.inaxes.collections[0].get_offsets().data, event.inaxes.collections[1].get_offsets().data])
    elif 'high res' in event.inaxes.get_ylabel():
      twod_data = event.inaxes.collections[0].get_offsets().data
    else:
      return
    twod_picture = event.inaxes.transData.transform(twod_data)
    evt_xy_picture = event.inaxes.transData.transform((event.xdata, event.ydata))
    diffs = twod_picture - (evt_xy_picture)
    diffs = np.linalg.norm(diffs, axis=1)
    mindiff = np.argmin(diffs)
    x = round(twod_data[mindiff][0])

    run_numbers = tab.main.runstats_sentinel.run_numbers
    found_it = False
    for run_number, stats in zip(run_numbers, all_stats):
      timestamps, two_theta_low, two_theta_high, n_strong, resolutions, n_lattices, wavelengths = stats
      if x < len(timestamps):
        found_it = True
        break
      else:
        x -= len(timestamps)
    assert found_it, x

    trial = tab.trial
    found_it = False
    for rg in trial.rungroups:
      for run in rg.runs:
        if run.run == run_number:
          found_it = True
          break
      if found_it:
        break
    assert found_it, run_number

    locator_path = os.path.join(params.output_folder, "r%04d"%int(run_number), \
                                "%03d_rg%03d"%(trial.trial, rg.id), 'data.loc')
    print("Loading run %s, image %d"%(run.run, x+1))

    from dials.command_line.image_viewer import phil_scope
    from dials.util.image_viewer.spotfinder_frame import SpotFrame, chooser_wrapper
    from dxtbx.model.experiment_list import ExperimentListFactory
    if not tab.sf_frame: # if closed, wx windows resolve to False
      expts = ExperimentListFactory.from_filenames([locator_path], load_models=False)
      tab.sf_frame = SpotFrame(tab.main, params=phil_scope.extract(), experiments=[expts], reflections=[])
      tab.sf_frame.SetSize((1024, 780))
    elif tab.cached_run.run != run.run:
      expts = ExperimentListFactory.from_filenames([locator_path], load_models=False)
      tab.sf_frame.imagesets = expts.imagesets()
    tab.sf_frame.add_file_name_or_data(chooser_wrapper(tab.sf_frame.imagesets[x], 0))
    tab.sf_frame.load_image(chooser_wrapper(tab.sf_frame.imagesets[x], 0))
    tab.sf_frame.Show()
    tab.cached_run = run

  def onChkAutoUpdate(self, e):
    self.auto_update = self.chk_auto_update.GetValue()

    if self.auto_update and (self.main.runstats_sentinel is None or not self.main.runstats_sentinel.active):
      self.main.start_runstats_sentinel()
    else:
      self.main.stop_runstats_sentinel()

  def print_strong_indexed_paths(self):
    try:
      paths = []
      for p in self.strong_indexed_image_paths:
        paths.extend(p)
      image_paths = '\n'.join(paths)
      self.strong_indexed_list.SetValue(image_paths)
    except TypeError:
      print("Error getting list of best indexed images")
      pass

  def print_should_have_indexed_paths(self):
    if self.trial is not None:
      try:
        paths = []
        for p in self.should_have_indexed_image_paths:
          paths.extend(p)
        image_paths = '\n'.join(paths)
        self.should_have_indexed_list.SetValue(image_paths)
      except TypeError:
        print("Error getting list of images that should have indexed")
        pass

  def onLastFiveRuns(self, e):
    self.entire_expt = False
    self.tag_last_five = True
    self.select_last_n_runs(5)
    self.main.run_window.runstats_light.change_status('idle')

  def onEntireExpt(self, e):
    self.entire_expt = True
    self.tag_last_five = False
    self.select_all()
    self.main.run_window.runstats_light.change_status('idle')

  def onDMin(self, e):
    try:
      d_min = float(self.d_min_select.d_min.GetValue())
      self.d_min = d_min
    except ValueError:
      pass

  def onMultiples(self, e):
    try:
      mult = int(self.n_multiples_selector.multiples.GetValue())
      self.n_multiples = mult
    except ValueError:
      pass

  def onRatioCutoff(self, e):
    try:
      ratio = float(self.ratio_cutoff.ratio.GetValue())
      self.ratio = ratio
    except ValueError:
      pass

  def onHitCutoff(self, e):
    n_strong = self.n_strong_cutoff.n_strong.GetValue()
    if n_strong.isdigit():
      self.n_strong = int(n_strong)

  def onIsigICutoff(self, e):
    try:
      isigi = float(self.i_sigi_cutoff.isigi.GetValue())
      self.i_sigi = isigi
    except ValueError:
      pass

  def onNDump(self, e):
    n_dump = self.n_dump_cutoff.n_dump.GetValue()
    if n_dump.isdigit():
      self.n_dump = int(n_dump)

  def dump_timestamps(self, params, ts_list, img_list):
    if not os.path.isdir(params['output_dir']):
      os.makedirs(params['output_dir'])
    command = ('cctbx.xfel.xtc_dump input.experiment=%s '%params['experiment'])+\
    ('input.run_num=%s input.address=%s '%(str(params['run']), params['address']))+\
    ('format.file_format=%s '%params['format'])+\
    ('output.output_dir=%s '%params['output_dir'])
    if params['format'] == 'cbf':
      command += 'format.cbf.detz_offset=%f '%params['distance']
      if params['energy'] is not None:
        command += 'format.cbf.override_energy=%f '%params['energy']
      if 'Rayonix' in params['address']:
        command += 'format.cbf.mode=rayonix '
        if params['beamx'] is not None:
          command += 'format.cbf.rayonix.override_beam_x=%d '%params['beamx']
        if params['beamy'] is not None:
          command += 'format.cbf.rayonix.override_beam_y=%d '%params['beamy']
        if params['bin_size'] is not None:
          command += 'format.cbf.rayonix.bin_size=%d '%params['bin_size']
      elif 'cspad' in params['address'].lower():
        if params['gain_mask_level'] is not None:
          command += 'format.cbf.cspad.gain_mask_value=%f '% params['gain_mask_level']
    elif params['format'] == 'pickle':
      if params['config'] is not None:
        command += 'input.cfg=%s '%params['config']
    command += 'dispatch.selected_events=True '
    for timestamp_string in ts_list[:self.n_dump]:
      command += 'input.timestamp=%s '%timestamp_string
    command += '&& dials.image_viewer %s'%\
      ' '.join(map(str, img_list[:self.n_dump]))
    thread = ImageDumpThread(command)
    thread.start()

  def onDumpImages(self, e):
    for idx in range(len(self.should_have_indexed_timestamps)):
      params, ts_list = self.should_have_indexed_timestamps[idx]
      imgs = self.should_have_indexed_image_paths[idx]
      self.dump_timestamps(params, ts_list, imgs)

  def onOpenImages(self, e):
    for idx in range(len(self.strong_indexed_image_timestamps)):
      params, ts_list = self.strong_indexed_image_timestamps[idx]
      ext = '.' + params['format']
      image_paths = self.strong_indexed_image_paths[idx][:self.n_dump]
      indexed_paths = [path.split(ext)[0]+'_indexed.refl' for path in image_paths]
      if all([os.path.exists(p) for p in (image_paths + indexed_paths)]):
        command = str('dials.image_viewer ' + ' '.join(image_paths) + \
          ' ' + ' '.join(indexed_paths))
        thread = ImageDumpThread(command)
        thread.start()
      else:
        shot_paths = [p.split('out')[0] + 'all' + p.split('out')[1].replace('idx', 'shot') \
          for p in image_paths]
        self.dump_timestamps(params, ts_list, shot_paths)

class UnitCellTab(BaseTab):
  def __init__(self, parent, main):
    BaseTab.__init__(self, parent=parent)
    self.name = 'Unit Cell'

    self.main = main
    self.all_trials = []
    self.trial_no = None
    self.trial = None
    self.tags = []
    self.tag_sets = []
    self.reject_outliers = True
    self.plot_clusters = False
    self.auto_update = True

    # self.tab_panel = wx.Panel(self, size=(300, 300))
    self.tab_sizer = wx.BoxSizer(wx.HORIZONTAL)
    # self.tab_panel.SetSizer(self.tab_sizer)

    self.selection_columns_panel = wx.Panel(self, size=(230, 120))
    self.selection_columns_box = wx.StaticBox(self.selection_columns_panel, label='Select tag sets')
    self.selection_columns_sizer = wx.StaticBoxSizer(self.selection_columns_box, wx.VERTICAL)
    self.selection_columns_panel.SetSizer(self.selection_columns_sizer)

    # self.selection_columns_panel = wx.Panel(self, size=(100, 120))
    # self.selection_columns_sizer = wx.BoxSizer(wx.HORIZONTAL)
    # self.selection_columns_panel.SetSizer(self.selection_columns_sizer)

    self.trial_number = gctr.ChoiceCtrl(self.selection_columns_panel,
                                        label='Trial:',
                                        label_size=(90, -1),
                                        label_style='normal',
                                        ctrl_size=(100, -1),
                                        choices=[])

    self.tag_checklist = gctr.CheckListCtrl(self.selection_columns_panel,
                                            label='Available tags:',
                                            label_size=(200, -1),
                                            label_style='normal',
                                            ctrl_size=(150, 100),
                                            direction='vertical',
                                            choices=[])

    self.selection_type_radio = gctr.RadioCtrl(self.selection_columns_panel,
                                               name='uc_selection_type',
                                               label='',
                                               label_style='normal',
                                               label_size=(-1, -1),
                                               direction='horizontal',
                                               items={'union':'union',
                                                      'inter':'intersection'})

    self.add_sele_button = wx.Button(self.selection_columns_panel,
                                     label='Add selection',
                                     size=(200, -1))

    self.tag_set_checklist = gctr.CheckListCtrl(self.selection_columns_panel,
                                                label='Tag sets to display:',
                                                label_size=(200, -1),
                                                label_style='normal',
                                                ctrl_size=(150, 100),
                                                direction='vertical',
                                                choices=[])

    self.remove_sele_button = wx.Button(self.selection_columns_panel,
                                        label='Remove selection',
                                        size=(200, -1))

    self.reset_sele_button = wx.Button(self.selection_columns_panel,
                                       label='Reset selections',
                                       size=(200, -1))

    self.chk_reject_outliers = wx.CheckBox(self.selection_columns_panel, label='Reject outliers')
    self.chk_reject_outliers.SetValue(True)

    self.chk_plot_clusters = wx.CheckBox(self.selection_columns_panel, label='Plot clusters')

    self.chk_auto_update = wx.CheckBox(self.selection_columns_panel, label='Auto update')
    self.chk_auto_update.SetValue(True)

    self.plot_eps = gctr.OptionCtrl(self.selection_columns_panel,
                                    name='uc_plot_eps',
                                    label='Cluster epsilon',
                                    sub_labels=[''],
                                    label_size=(160, -1),
                                    ctrl_size=(50, -1),
                                    items=[('eps', 0.8)])
    self.plot_eps.eps.Disable()

    try:
      import uc_metrics # import dependency
    except ImportError:
      self.chk_plot_clusters.Hide()
      self.plot_eps.Hide()

    self.add_sele_sizer = wx.GridBagSizer(4, 1)
    self.add_sele_sizer.Add(self.trial_number, pos=(0, 0),
                            flag=wx.ALL, border=0)
    self.add_sele_sizer.Add(self.tag_checklist, pos=(1, 0),
                            flag=wx.ALL | wx.EXPAND, border=0)
    self.add_sele_sizer.Add(self.selection_type_radio, pos=(2, 0),
                            flag=wx.ALL | wx.ALIGN_CENTER, border=0)
    self.add_sele_sizer.Add(self.add_sele_button, pos=(3, 0),
                            flag=wx.ALL)
    self.selection_columns_sizer.Add(self.add_sele_sizer, flag=wx.ALL | wx.EXPAND, border=10)

    self.remove_sele_sizer = wx.GridBagSizer(3, 1)
    self.remove_sele_sizer.Add(self.tag_set_checklist, pos=(0, 0),
                               flag=wx.ALL | wx.EXPAND, border=0)
    self.remove_sele_sizer.Add(self.remove_sele_button, pos=(1, 0),
                               flag=wx.ALL)
    self.remove_sele_sizer.Add(self.reset_sele_button, pos=(2, 0),
                               flag=wx.ALL)
    self.selection_columns_sizer.Add(self.remove_sele_sizer, flag=wx.ALL | wx.EXPAND, border=10)
    self.selection_columns_sizer.Add(self.chk_reject_outliers, flag=wx.ALL | wx.EXPAND, border=10)
    self.selection_columns_sizer.Add(self.chk_plot_clusters, flag=wx.ALL | wx.EXPAND, border=10)
    self.selection_columns_sizer.Add(self.plot_eps, flag=wx.ALL | wx.EXPAND, border=10)
    self.selection_columns_sizer.Add(self.chk_auto_update, flag=wx.ALL | wx.EXPAND, border=10)

    self.unit_cell_panel = wx.Panel(self, size=(200, 120))
    self.unit_cell_box = wx.StaticBox(self.unit_cell_panel, label='Unit cell analysis')
    self.unit_cell_panelsize = self.unit_cell_box.GetSize()
    self.unit_cell_sizer = wx.StaticBoxSizer(self.unit_cell_box, wx.VERTICAL)
    self.unit_cell_panel.SetSizer(self.unit_cell_sizer)

    import matplotlib as mpl
    from matplotlib.backends.backend_wxagg import (
      FigureCanvasWxAgg as FigureCanvas,
      NavigationToolbar2WxAgg as NavigationToolbar)

    self.figure = mpl.figure.Figure()
    self.canvas = FigureCanvas(self.unit_cell_box, -1, self.figure)
    self.toolbar = NavigationToolbar(self.canvas)
    self.toolbar.Realize()

    self.unit_cell_sizer.Add(self.canvas, 1, wx.EXPAND)
    self.unit_cell_sizer.Add(self.toolbar, 0, wx.LEFT | wx.EXPAND)

    # self.main_sizer.Add(self.selection_columns_panel, 1,
    #                     flag=wx.EXPAND | wx.ALL, border=10)
    # self.main_sizer.Add(self.unit_cell_panel, 1,
    #                     flag=wx.EXPAND | wx.ALL, border=10)

    self.tab_sizer.Add(self.selection_columns_panel, 0,
                       flag=wx.ALIGN_LEFT | wx.EXPAND, border=10)
    self.tab_sizer.Add(self.unit_cell_panel, 1,
                       flag=wx.EXPAND | wx.ALL, border=0)
    self.main_sizer.Add(self.tab_sizer, 1,
                        flag=wx.EXPAND | wx.ALL, border=10)
    self.selection_columns_sizer.Layout()

    self.Bind(wx.EVT_CHOICE, self.onTrialChoice, self.trial_number.ctr)
    self.Bind(wx.EVT_BUTTON, self.onAddTagSet, self.add_sele_button)
    self.Bind(wx.EVT_BUTTON, self.onRemoveTagSet, self.remove_sele_button)
    self.Bind(wx.EVT_BUTTON, self.onResetTagSets, self.reset_sele_button)
    self.Bind(wx.EVT_CHECKBOX, self.onChkRejectOutliers, self.chk_reject_outliers)
    self.Bind(wx.EVT_CHECKBOX, self.onChkPlotClusters, self.chk_plot_clusters)
    self.Bind(wx.EVT_CHECKBOX, self.onChkAutoUpdate, self.chk_auto_update)
    self.Bind(EVT_UNITCELL_REFRESH, self.onRefresh)
    self.Bind(wx.EVT_SIZE, self.OnSize)

  def OnSize(self, e):
    self.unit_cell_panelsize = self.unit_cell_box.GetSize()
    e.Skip()

  def find_trials(self):
    all_db_trials = [str(i.trial) for i in self.main.db.get_all_trials()]
    new_trials = [i for i in all_db_trials if i not in self.all_trials]
    if len(new_trials) > 0:
      self.trial_number.ctr.Clear()
      self.all_trials = [None] + all_db_trials
      for trial in self.all_trials:
        if trial is not None:
          entry = trial
          self.trial_number.ctr.Append(entry)
          item_idx = self.trial_number.ctr.FindString(entry)
          self.trial_number.ctr.SetClientData(item_idx, trial)
        else:
          entry = 'None'
          self.trial_number.ctr.Append(entry)
          self.trial_number.ctr.SetClientData(0, None)
      if self.trial_no is not None:
        self.trial_number.ctr.SetSelection(self.trial_no)
      else:
        self.trial_number.ctr.SetSelection(0)

  def onTrialChoice(self, e):
    trial_idx = self.trial_number.ctr.GetSelection()
    if trial_idx == 0:
      self.trial_no = None
      self.trial = None
    elif self.trial_number.ctr.GetClientData(trial_idx) != self.trial_no:
      self.trial_no = int(self.trial_number.ctr.GetClientData(trial_idx))
      self.trial = self.main.db.get_trial(trial_number=self.trial_no)
    self.find_tags()

  def find_tags(self):
    self.tag_checklist.ctr.Clear()
    if self.trial is not None:
      self.tags = self.trial.tags
      tag_names = [t.name for t in self.tags]
      if tag_names:
        self.tag_checklist.ctr.InsertItems(items=tag_names, pos=0)
    self.refresh_tag_sets()

  def onAddTagSet(self, e):
    checked_items = self.tag_checklist.ctr.GetCheckedStrings()
    selected_tags = [i for i in self.main.db.get_all_tags()
                     if i.name in checked_items]
    selected_tags = selected_tags
    if self.selection_type_radio.union.GetValue() == 1:
      mode = 'union'
    else:
      mode = 'intersection'
    tag_set = TagSet(mode, selected_tags)
    self.tag_sets.append(tag_set)
    self.refresh_tag_sets()

  def refresh_tag_sets(self):
    self.tag_set_checklist.ctr.Clear()
    tag_set_strings = [str(ts) for ts in self.tag_sets]
    if tag_set_strings:
      self.tag_set_checklist.ctr.InsertItems(items = tag_set_strings, pos=0)

  def onRemoveTagSet(self, e):
    all_items = self.tag_set_checklist.ctr.GetStrings()
    checked_items = self.tag_set_checklist.ctr.GetCheckedStrings()
    selected_tag_sets = [ts for ts in self.tag_sets if str(ts) in checked_items]
    for ts in selected_tag_sets:
      idx = all_items.index(str(ts))
      self.tag_set_checklist.ctr.Delete(idx)
      self.tag_sets.remove(ts)

  def onResetTagSets(self, e):
    self.tag_set_checklist.ctr.Clear()
    self.tag_sets = []
    self.selected_tag_sets = []

  def onChkRejectOutliers(self, e):
    self.reject_outliers = self.chk_reject_outliers.GetValue()

  def onChkPlotClusters(self, e):
    self.plot_clusters = self.chk_plot_clusters.GetValue()
    if self.plot_clusters:
      self.plot_eps.eps.Enable()
    else:
      self.plot_eps.eps.Disable()

  def onChkAutoUpdate(self, e):
    self.auto_update = self.chk_auto_update.GetValue()

    if self.auto_update and (self.main.unitcell_sentinel is None or not self.main.unitcell_sentinel.active):
      self.main.start_unitcell_sentinel()
    else:
      self.main.stop_unitcell_sentinel()

  def onRefresh(self, e):
    self.find_trials()

class DatasetTab(BaseTab):
  def __init__(self, parent, main):
    BaseTab.__init__(self, parent=parent)
    self.name = 'Datasets'

    self.main = main

    self.show_active_only = False

    self.dataset_panel = ScrolledPanel(self, size=(200, 200))
    self.dataset_sizer = wx.BoxSizer(wx.HORIZONTAL)
    self.dataset_panel.SetSizer(self.dataset_sizer)

    self.btn_sizer = wx.FlexGridSizer(1, 3, 0, 10)
    self.btn_sizer.AddGrowableCol(0)

    self.filter = gctr.TextButtonCtrl(self,
                                      name='filter',
                                      label='Filter',
                                      label_style='bold',
                                      label_size=(100, -1),
                                      value="")
    self.btn_sizer.Add(self.filter, flag=wx.ALIGN_RIGHT)

    self.btn_add_dataset = wx.Button(self, label='New Dataset', size=(120, -1))
    self.btn_active_only = wx.ToggleButton(self,
                                           label='Show Only Active Datasets',
                                    size=(180, self.btn_add_dataset.GetSize()[1]))
    self.btn_sizer.Add(self.btn_active_only, flag=wx.ALIGN_RIGHT)
    self.btn_sizer.Add(self.btn_add_dataset)

    self.main_sizer.Add(self.dataset_panel, 1, flag=wx.EXPAND | wx.ALL, border=10)
    self.main_sizer.Add(self.btn_sizer, flag=wx.EXPAND | wx.ALL, border=10)

    # Bindings
    self.Bind(wx.EVT_TEXT, self.onFilter, self.filter.ctr)
    self.Bind(wx.EVT_BUTTON, self.onAddDataset, self.btn_add_dataset)
    self.Bind(wx.EVT_TOGGLEBUTTON, self.onActiveOnly, self.btn_active_only)

    #self.refresh_datasets()

  def refresh_datasets(self):
    self.dataset_sizer.Clear(delete_windows=True)
    self.all_datasets = self.main.db.get_all_datasets()

    filter_str = self.filter.ctr.GetValue()

    for dataset in self.all_datasets:
      if filter_str and filter_str not in dataset.name:
        continue
      if self.show_active_only:
        if dataset.active:
          self.add_dataset(dataset=dataset)
      else:
        self.add_dataset(dataset=dataset)

    self.dataset_panel.SetSizer(self.dataset_sizer)
    self.dataset_sizer.Layout()
    self.dataset_panel.SetupScrolling(scrollToTop=False)

  def add_dataset(self, dataset):
    new_dataset = DatasetPanel(self.dataset_panel,
                           db=self.main.db,
                           dataset=dataset)
    new_dataset.chk_active.SetValue(dataset.active)
    new_dataset.refresh_dataset()
    self.dataset_sizer.Add(new_dataset, flag=wx.EXPAND | wx.ALL, border=10)

  def onAddDataset(self, e):
    new_dataset_dlg = dlg.DatasetDialog(self, db=self.main.db)
    new_dataset_dlg.Fit()

    if new_dataset_dlg.ShowModal() == wx.ID_OK:
      self.refresh_datasets()

  def onFilter(self, e):
    self.refresh_datasets()

  def onActiveOnly(self, e):
    self.show_active_only = self.btn_active_only.GetValue()
    self.refresh_datasets()

class MergingStatsTab(BaseTab):
  def __init__(self, parent, main):
    BaseTab.__init__(self, parent=parent)
    self.name = 'Merging stats'

    self.main = main
    self.all_datasets = []
    self.dataset_versions = []
    self.png = None
    self.static_bitmap = None
    self.redraw_windows = True

    self.tab_sizer = wx.BoxSizer(wx.HORIZONTAL)

    self.datasets_panel = wx.Panel(self, size=(240, 120))
    self.datasets_box = wx.StaticBox(self.datasets_panel, label='Select dataset')
    self.datasets_sizer = wx.StaticBoxSizer(self.datasets_box, wx.VERTICAL)
    self.datasets_panel.SetSizer(self.datasets_sizer)

    self.datasets = wx.ListBox(self.datasets_panel,
                               size=(220, 100))
    self.datasets_sizer.Add(self.datasets, flag=wx.EXPAND | wx.ALL, border = 5)

    self.chk_active = wx.CheckBox(self.datasets_panel, label='Active only')
    self.chk_active.SetValue(True)
    self.datasets_sizer.Add(self.chk_active, flag=wx.EXPAND | wx.ALL, border = 5)

    self.dataset_version = gctr.ChoiceCtrl(self.datasets_panel,
                                           label='Dataset version:',
                                           label_size=(120, -1),
                                           label_style='normal',
                                           ctrl_size=(100, -1),
                                           choices=[])
    self.datasets_sizer.Add(self.dataset_version, flag=wx.EXPAND | wx.ALL, border = 5)

    self.plots_panel = wx.Panel(self, size=(200, 120))
    self.mergingstats_panelsize = self.plots_panel.GetSize()
    self.plots_box = wx.StaticBox(self.plots_panel, label='Statistics')
    self.plots_sizer = wx.StaticBoxSizer(self.plots_box, wx.VERTICAL)
    self.plots_panel.SetSizer(self.plots_sizer)

    self.tab_sizer.Add(self.datasets_panel, 0,
                       flag=wx.ALIGN_LEFT | wx.EXPAND, border=10)
    self.tab_sizer.Add(self.plots_panel, 1,
                       flag=wx.EXPAND | wx.ALL, border=0)
    self.main_sizer.Add(self.tab_sizer, 1,
                        flag=wx.EXPAND | wx.ALL, border=10)

    self.Bind(wx.EVT_LISTBOX, self.onSelectDataset, self.datasets)
    self.Bind(wx.EVT_CHOICE, self.onVersionChoice, self.dataset_version.ctr)
    self.Bind(EVT_MERGINGSTATS_REFRESH, self.onRefresh)
    self.chk_active.Bind(wx.EVT_CHECKBOX, self.onToggleActivity)
    self.Bind(wx.EVT_SIZE, self.OnSize)

  def OnSize(self, e):
    self.mergingstats_panelsize = self.plots_panel.GetSize()
    e.Skip()

  def onToggleActivity(self, e):
    self.refresh_datasets()

  def refresh_datasets(self):
    self.datasets.Clear()
    self.all_datasets = self.main.db.get_all_datasets()
    if self.chk_active.GetValue():
      self.all_datasets = [d for d in self.all_datasets if d.active]
    for dataset in self.all_datasets:
      self.datasets.Append(dataset.name)
    self.refresh_dataset()

  def onVersionChoice(self, e):
    self.refresh_stats()

  def onSelectDataset(self, e):
    self.refresh_dataset()

  def refresh_dataset(self):
    self.dataset_version.ctr.Clear()
    sel = self.datasets.GetSelection()
    if sel < 0: return
    try:
      dataset = self.all_datasets[sel]
    except IndexError:
      pass
    else:
      self.dataset_version.ctr.Append('All')
      for version in dataset.active_versions:
        self.dataset_version.ctr.Append(str(version.version))
      self.dataset_version.ctr.SetSelection(0)
      self.refresh_stats()

  def refresh_stats(self):
    sel = self.datasets.GetSelection()
    dataset = self.all_datasets[sel]
    self.dataset_name = dataset.name
    if self.dataset_version.ctr.GetSelection() == 0:
      self.dataset_versions = [version.output_path() for version in dataset.active_versions]
    else:
      version = dataset.active_versions[self.dataset_version.ctr.GetSelection()-1]
      self.dataset_name += " v%03d"%version.version
      self.dataset_versions = [version.output_path()]

  def onRefresh(self, e):
    self.plot_merging_stats()

  def plot_merging_stats(self):
    if self.png is not None:
      if self.static_bitmap is not None:
        try:
          self.static_bitmap.Destroy()
        except RuntimeError as e:
          if "StaticBitmap has been deleted" not in str(e):
            raise
      img = wx.Image(self.png, wx.BITMAP_TYPE_ANY)
      self.static_bitmap = wx.StaticBitmap(
        self.plots_panel, wx.ID_ANY, wx.Bitmap(img))
      self.plots_sizer.Add(self.static_bitmap, 0, wx.EXPAND | wx.ALL, 3)
      self.plots_panel.SetSizer(self.plots_sizer)
      self.plots_panel.Layout()

class MergeTab(BaseTab):

  def __init__(self, parent, main, prefix='prime'):
    BaseTab.__init__(self, parent=parent)
    self.name = 'Merge'

    self.main = main
    self.prefix = prefix
    self.prime_filename = '{}.phil'.format(self.prefix)
    self.output = self.main.params.output_folder
    self.run_paths = []
    self.trial_no = None
    self.all_trials = []
    self.all_tags = []
    self.selected_tags = []
    self.run_paths = []

    self.prime_panel = PRIMEInputWindow(self)
    self.toolbar = wx.ToolBar(self, style=wx.TB_HORZ_TEXT | wx.TB_FLAT)
    self.tb_btn_def = self.toolbar.AddTool(wx.ID_ANY, label=' Defaults',
                          bitmap=wx.Bitmap('{}/24x24/def.png'.format(icons)),
                          bmpDisabled=wx.NullBitmap,
                          shortHelp='Default Settings',
                          longHelp='Generate default PRIME settings')
    self.tb_btn_load = self.toolbar.AddTool(wx.ID_OPEN, label=' Load PHIL',
                          bitmap=wx.Bitmap('{}/24x24/open.png'.format(icons)),
                          bmpDisabled=wx.NullBitmap,
                          shortHelp='Load PHIL file',
                          longHelp='Load PHIL file with PRIME settings')
    self.tb_btn_save = self.toolbar.AddTool(wx.ID_SAVE, label=' Save PHIL',
                          bitmap=wx.Bitmap('{}/24x24/save.png'.format(icons)),
                          bmpDisabled=wx.NullBitmap,
                          shortHelp='Save PHIL file',
                          longHelp='Save PHIL file with PRIME settings')
    self.tb_btn_cmd = self.toolbar.AddTool(wx.ID_ANY, label=' Command',
                          bitmap=wx.Bitmap('{}/24x24/term.png'.format(icons)),
                          bmpDisabled=wx.NullBitmap,
                          shortHelp='PRIME Command',
                          longHelp='Output PRIME command to stdout')
    self.toolbar.EnableTool(self.tb_btn_cmd.GetId(), False)
    self.toolbar.AddSeparator()
    self.tb_btn_run = self.toolbar.AddTool(wx.ID_ANY, label=' Run PRIME',
                          bitmap=wx.Bitmap('{}/24x24/run.png'.format(icons)),
                          bmpDisabled=wx.NullBitmap,
                          shortHelp='Run PRIME',
                          longHelp='Scale, merge and post-refine with PRIME')
    self.toolbar.EnableTool(self.tb_btn_run.GetId(), False)
    self.toolbar.Realize()

    # Modify PRIME input window to hide input control
    self.prime_panel.inp_box.Hide()
    self.prime_panel.out_box.ctr.SetValue(self.output)

    # Input box
    self.input_panel = wx.Panel(self)
    input_box = wx.StaticBox(self.input_panel, label='PRIME Input')
    self.input_box_sizer = wx.StaticBoxSizer(input_box, wx.HORIZONTAL)
    self.input_panel.SetSizer(self.input_box_sizer)

    self.trial_number = gctr.ChoiceCtrl(self.input_panel,
                                        label='Trial:',
                                        label_size=(80, -1),
                                        label_style='normal',
                                        ctrl_size=(140, -1),
                                        choices=[])
    self.tag_title = wx.StaticText(self.input_panel, label='Tags:')
    self.tag_list = gctr.CheckListCtrl(self.input_panel,
                                       ctrl_size=(200, 100),
                                       choices=[],
                                       direction='vertical')
    self.opt_prefix = gctr.OptionCtrl(self.input_panel,
                                      label='List prefix:',
                                      label_size=(80, -1),
                                      ctrl_size=(140, -1),
                                      items=[('prefix', 'prime')])
    self.input_number = wx.StaticText(self.input_panel,
                                      label='0 images in 0 folders:')
    self.input_list = wx.TextCtrl(self.input_panel,
                                  style=wx.TE_MULTILINE | wx.TE_READONLY)

    self.trial_tag_sizer = wx.GridBagSizer(2, 3)
    self.trial_tag_sizer.Add(self.opt_prefix, pos=(0, 0))
    self.trial_tag_sizer.Add(self.trial_number, pos=(1, 0),
                             flag=wx.TOP, border=10)
    self.trial_tag_sizer.Add(self.tag_title, pos=(0, 1),
                             flag=wx.LEFT | wx.EXPAND,
                             border=15)
    self.trial_tag_sizer.Add(self.tag_list, pos=(1, 1),
                             flag=wx.LEFT | wx.EXPAND,
                             border=15)
    self.trial_tag_sizer.Add(self.input_number, pos=(0, 2),
                             flag=wx.LEFT | wx.EXPAND | wx.ALIGN_RIGHT,
                             border=15)
    self.trial_tag_sizer.Add(self.input_list, pos=(1, 2),
                             flag=wx.LEFT | wx.EXPAND | wx.ALIGN_RIGHT,
                             border=15)
    self.input_box_sizer.Add(self.trial_tag_sizer, 1, flag=wx.ALL | wx.EXPAND,
                             border=10)
    self.trial_tag_sizer.AddGrowableCol(2)
    self.trial_tag_sizer.AddGrowableRow(1)
    self.main_sizer.Add(self.toolbar, border=10,
                        flag=wx.EXPAND | wx.LEFT | wx.RIGHT)
    self.main_sizer.Add(self.input_panel, proportion=1,
                        flag=wx.ALL | wx.EXPAND, border=10)
    self.main_sizer.Add(self.prime_panel, border=10,
                        flag=wx.RIGHT | wx.LEFT | wx.BOTTOM | wx.EXPAND)


    self.Bind(wx.EVT_TEXT, self.onInput, self.input_list)
    #self.Bind(wx.EVT_BUTTON, self.onIsoRef, self.prime_panel.ref_box.btn_browse)
    #self.Bind(wx.EVT_TEXT, self.onIsoRef, self.prime_panel.ref_box.ctr)
    self.Bind(wx.EVT_CHOICE, self.onTrialChoice, self.trial_number.ctr)
    self.Bind(wx.EVT_CHECKLISTBOX, self.onTagCheck, self.tag_list.ctr)
    self.Bind(wx.EVT_TOOL, self.onRun, self.tb_btn_run)
    self.Bind(wx.EVT_TOOL, self.onRun, self.tb_btn_cmd)
    self.Bind(wx.EVT_TOOL, self.onLoad, self.tb_btn_load)
    self.Bind(wx.EVT_TOOL, self.onSave, self.tb_btn_save)

  def onTagCheck(self, e):
    checked_items = self.tag_list.ctr.GetCheckedStrings()
    self.selected_tags = [i for i in self.main.db.get_all_tags() if i.name
                          in checked_items]
    self.find_integrated_pickles()

  def onTrialChoice(self, e):
    trial_idx = self.trial_number.ctr.GetSelection()
    if self.trial_number.ctr.GetClientData(trial_idx) == 0:
      self.toolbar.EnableTool(self.tb_btn_run.GetId(), False)
      self.toolbar.EnableTool(self.tb_btn_cmd.GetId(), False)
      self.tag_list.ctr.Clear()
      self.input_list.SetValue('')
    elif self.trial_number.ctr.GetClientData(trial_idx) != self.trial_no:
      self.trial_no = self.trial_number.ctr.GetClientData(trial_idx)
      self.trial = self.main.db.get_trial(trial_number=int(self.trial_no))
      self.find_tags()
      self.find_integrated_pickles()

  def find_tags(self):
    self.tag_list.ctr.Clear()
    self.tags = []
    self.tag_names = []
    tag_ids = []
    for run in self.trial.runs:
      for tag in run.tags:
        if tag.id not in tag_ids:
          self.tags.append(tag)
          tag_ids.append(tag.id)
          self.tag_names.append(tag.name)
    self.tag_title.SetLabel('Tags for trial {}:'.format(self.trial.trial))
    if self.tag_names:
      self.tag_list.ctr.InsertItems(items=self.tag_names, pos=0)

  def find_trials(self):
    all_db_trials = [str(i.trial) for i in self.main.db.get_all_trials()]
    new_trials = [i for i in all_db_trials if i not in self.all_trials]
    if len(new_trials) > 0:
      self.trial_number.ctr.Clear()
      self.all_trials = [None] + \
                        [str(i.trial) for i in self.main.db.get_all_trials()]
      for trial in self.all_trials:
        if trial is not None:
          entry = 'Trial {}'.format(trial)
          self.trial_number.ctr.Append(entry)
          item_idx = self.trial_number.ctr.FindString(entry)
          self.trial_number.ctr.SetClientData(item_idx, trial)
        else:
          entry = '-- select a trial --'
          self.trial_number.ctr.Append(entry)
          self.trial_number.ctr.SetClientData(0, None)

      if self.trial_no is not None:
        self.trial_number.ctr.SetSelection(self.trial_no)
      else:
        self.trial_number.ctr.SetSelection(0)

  def find_integrated_pickles(self):

    # Find runblock paths associated with the trial
    run_numbers = []
    run_ids = []
    self.run_paths = []
    if self.main.params.dispatcher == "cxi.xtc_process": #LABELIT backend
      integration_dir = "integration"
    else:
      integration_dir = "out"
    for rb in self.trial.rungroups:
      for run in rb.runs:
        if run.run not in run_numbers:
          if len(self.selected_tags) == 0:
            self.run_paths.append(os.path.join(
              get_run_path(self.output, self.trial, rb, run), integration_dir))
            run_numbers.append(run.run)
          else:
            for tag_id in [int(t.id) for t in self.selected_tags]:
              if tag_id in [int(t.id) for t in run.tags]:
                run_ids.append(int(run.id))
                self.run_paths.append(os.path.join(
                  get_run_path(self.output, self.trial, rb, run), integration_dir))
                break

    # Display paths in input list text control
    input_paths = '\n'.join(self.run_paths)
    self.input_list.SetValue(input_paths)

    # Find appropriate integration pickles in runblock paths
    self.all_pickles = []
    for path in self.run_paths:
      try:
        pickles = [os.path.join(path, i) for i in os.listdir(path) if
                   i.endswith('pickle') and 'int-' in i]
        self.all_pickles = self.all_pickles + pickles
      except OSError as error:
        print('Folder not found: {}'.format(path))
        continue

    self.input_number.SetLabel('{} images in {} folders:'
                               ''.format(len(self.all_pickles),
                                         len(self.run_paths)))

  def onInput(self, e):
    self.toolbar.EnableTool(self.tb_btn_run.GetId(), True)
    self.toolbar.EnableTool(self.tb_btn_cmd.GetId(), True)

  def onLoad(self, e):
    # Extract params from file
    load_dlg = wx.FileDialog(self,
                             message="Load script file",
                             defaultDir=os.curdir,
                             defaultFile="*.phil",
                             wildcard="*.phil",
                             style=wx.FD_OPEN | wx.FD_FILE_MUST_EXIST,
                             )
    if load_dlg.ShowModal() == wx.ID_OK:
      script = load_dlg.GetPaths()[0]
      out_dir = os.path.dirname(script)
      self.prime_filename = os.path.basename(script)
      self.load_script(out_dir=out_dir)
    load_dlg.Destroy()

  def load_script(self, out_dir):
    ''' Loads PRIME script '''
    import iotbx.phil as ip

    script = os.path.join(out_dir, self.prime_filename)
    user_phil = ip.parse(open(script).read())
    self.pparams = master_phil.fetch(sources=[user_phil]).extract()
    self.prime_panel.pparams = self.pparams

    if len(self.pparams.data) > 0:
      self.prime_panel.inp_box.ctr.SetValue(str(self.pparams.data[0]))
    current_dir = os.path.dirname(self.pparams.run_no)
    self.prime_panel.out_box.ctr.SetValue(str(current_dir))
    if str(self.prime_panel.out_box.ctr.GetValue).lower() == '':
      self.prime_panel.out_box.ctr.SetValue(self.out_dir)
    if str(self.pparams.title).lower() != 'none':
      self.prime_panel.title_box.ctr.SetValue(str(self.pparams.title))
    if str(self.pparams.hklisoin).lower() != 'none':
      self.prime_panel.ref_box.ctr.SetValue(str(self.pparams.hklisoin))
    elif str(self.pparams.hklrefin).lower() != 'none':
      self.prime_panel.ref_box.ctr.SetValue(str(self.pparams.hklrefin))
      self.prime_panel.opt_chk_useref.SetValue(True)
    if str(self.pparams.n_residues).lower() == 'none':
      self.prime_panel.opt_spc_nres.SetValue(500)
    else:
      self.prime_panel.opt_spc_nres.SetValue(int(self.pparams.n_residues))
    self.prime_panel.opt_spc_nproc.SetValue(int(self.pparams.n_processors))

  def onSave(self, e):
    self.init_settings()

    # Generate text of params
    final_phil = master_phil.format(python_object=self.pparams)
    with Capturing() as txt_output:
      final_phil.show()
    txt_out = ''
    for one_output in txt_output:
      txt_out += one_output + '\n'

    # Save param file
    save_dlg = wx.FileDialog(self,
                             message="Save PRIME Script",
                             defaultDir=os.curdir,
                             defaultFile="*.phil",
                             wildcard="*.phil",
                             style=wx.FD_SAVE | wx.FD_OVERWRITE_PROMPT
                             )
    if save_dlg.ShowModal() == wx.ID_OK:
      with open(save_dlg.GetPath(), 'w') as savefile:
        savefile.write(txt_out)

  def onIsoRef(self, e):
    if self.prime_panel.ref_box.ctr.GetValue() != '':
      self.prime_panel.opt_chk_useref.Enable()
    else:
      self.prime_panel.opt_chk_useref.Disable()

  def init_settings(self):

    # Determine where/what PRIME folders are
    prime_dir = os.path.join(self.output, 'prime')
    self.working_dir = os.path.join(prime_dir, 'trial_{}'.format(self.trial_no))
    if not os.path.exists(prime_dir):
      os.mkdir(prime_dir)
    if not os.path.exists(self.working_dir):
      os.mkdir(self.working_dir)

    # Write list of pickles to file
    list_prefix = self.opt_prefix.prefix.GetValue()
    if list_prefix == None or list_prefix == '':
      list_prefix = 'prime'
    self.pickle_path_file = os.path.join(self.working_dir,
                           '{}_trial_{}.lst'.format(list_prefix, self.trial_no))
    print('Saving list of pickles to ', self.pickle_path_file)

    with open(self.pickle_path_file, 'w') as lfile:
      for pickle in self.all_pickles:
        lfile.write('{}\n'.format(pickle))

    self.pparams = self.prime_panel.pparams
    self.pparams.data = [self.pickle_path_file]
    self.pparams.run_no = set_base_dir(out_dir=self.working_dir)
    self.out_dir = self.prime_panel.out_box.ctr.GetValue()
    self.pparams.title = self.prime_panel.title_box.ctr.GetValue()
    if str(self.prime_panel.ref_box.ctr.GetValue()).lower() != '':
      self.pparams.hklisoin = self.prime_panel.ref_box.ctr.GetValue()
      if self.prime_panel.opt_chk_useref.GetValue():
        self.pparams.hklrefin = self.prime_panel.ref_box.ctr.GetValue()
    self.pparams.n_residues = self.prime_panel.opt_spc_nres.GetValue()
    self.pparams.n_processors = self.prime_panel.opt_spc_nproc.GetValue()

  def onRun(self, e):
    # Run full processing

    from xfel.util.mp import get_lsf_submit_command
    from xfel.ui import settings_dir
    import datetime
    import copy

    params = copy.deepcopy(self.main.params)
    params.mp.nproc = self.prime_panel.opt_spc_nproc.GetValue()

    # Generate script filename (w/ timestamp)
    ts = '{:%Y%m%d_%H%M%S}'.format(datetime.datetime.now())
    script_filename = 'trial_{:03d}_{}.sh'.format(int(self.trial_no), ts)

    self.init_settings()
    prime_phil = master_phil.format(python_object=self.pparams)

    with Capturing() as output:
      prime_phil.show()

    txt_out = ''
    for one_output in output:
      txt_out += one_output + '\n'

    prime_file = os.path.join(settings_dir, self.prime_filename)
    out_file = os.path.join(self.working_dir, 'stdout.log')
    with open(prime_file, 'w') as pf:
      pf.write(txt_out)

    if params.mp.method == 'local':
      command=None
    else:
      job_name = 'prime_t{}'.format(self.trial_no)
      cmd = '-J {} prime.postrefine {}'.format(job_name, prime_file)
      submit_path = os.path.join(settings_dir, script_filename)
      command = str(get_lsf_submit_command(cmd, submit_path, self.working_dir,
                                           params.mp)())

    if e.GetId() == self.tb_btn_run.GetId():
      self.prime_run_window = PRIMERunWindow(self, -1,
                                             title='PRIME Output',
                                             params=self.pparams,
                                             prime_file=prime_file,
                                             # out_file=out_file,
                                             mp_method=params.mp.method,
                                             command=command)
      self.prime_run_window.prev_pids = easy_run.fully_buffered('pgrep -u {} {}'
                                            ''.format(user, 'python')).stdout_lines

      self.prime_run_window.Show(True)

    elif e.GetId() == self.tb_btn_cmd.GetId():
      print('Submission command:')
      print(command)

    # Try and write files to created folder


# ------------------------------- UI Elements -------------------------------- #

class TrialPanel(wx.Panel):
  ''' A scrolled panel that contains run blocks and trial controls '''

  def __init__(self, parent, db, trial, box_label=None):
    wx.Panel.__init__(self, parent=parent, size=(270, 200))

    self.db = db
    self.trial = trial
    self.parent = parent

    trial_box = wx.StaticBox(self, label=box_label)
    self.main_sizer = wx.StaticBoxSizer(trial_box, wx.VERTICAL)

    self.block_panel = ScrolledPanel(self, size=(150, 180))
    self.block_sizer = wx.BoxSizer(wx.VERTICAL)
    self.block_panel.SetSizer(self.block_sizer)
    self.one_block_sizer = wx.BoxSizer(wx.HORIZONTAL)
    self.add_panel = wx.Panel(self)
    self.add_sizer = wx.BoxSizer(wx.VERTICAL)
    self.add_panel.SetSizer(self.add_sizer)

    # Add "New Block" button to a separate sizer (so it is always on bottom)
    self.btn_add_block = wx.Button(self.add_panel, label='New Block',
                                   size=(200, -1))
    self.btn_select_blocks = wx.Button(self.add_panel, label='Select Blocks',
                                       size=(200, -1))
    self.btn_view_phil = gctr.BitmapButton(self.add_panel, name='btn_view_phil',
                                           bitmap=wx.Bitmap('{}/16x16/viewmag.png'.format(icons)))
    self.chk_active = wx.CheckBox(self.add_panel, label='Active Trial')
    self.view_sizer = wx.FlexGridSizer(1, 2, 0, 10)
    self.view_sizer.Add(self.btn_view_phil)
    self.view_sizer.Add(self.chk_active, flag=wx.EXPAND)

    self.add_sizer.Add(self.btn_add_block,
                       flag=wx.TOP | wx.LEFT | wx.RIGHT | wx.ALIGN_CENTER,
                       border=10)
    self.add_sizer.Add(self.btn_select_blocks,
                       flag=wx.TOP | wx.LEFT | wx.RIGHT | wx.ALIGN_CENTER,
                       border=10)
    self.add_sizer.Add(self.view_sizer,
                       flag=wx.TOP | wx.LEFT | wx.RIGHT | wx.ALIGN_LEFT,
                       border=10)

    self.main_sizer.Add(self.block_panel, 1, flag=wx.EXPAND | wx.ALL, border=10)
    self.main_sizer.Add(self.add_panel, flag=wx.ALL, border=5)

    # Bindings
    self.Bind(wx.EVT_BUTTON, self.onAddBlock, self.btn_add_block)
    self.Bind(wx.EVT_BUTTON, self.onSelectBlocks, self.btn_select_blocks)
    self.Bind(wx.EVT_BUTTON, self.onViewPHIL, self.btn_view_phil)
    self.chk_active.Bind(wx.EVT_CHECKBOX, self.onToggleActivity)

    self.SetSizer(self.main_sizer)

  def onViewPHIL(self, e):
    view_dlg = dlg.TrialDialog(self, db=self.db, trial=self.trial, new=False)
    view_dlg.Fit()
    view_dlg.ShowModal()
    view_dlg.Destroy()

  def onToggleActivity(self, e):
    if self.chk_active.GetValue():
      self.trial.active = True
    else:
      self.trial.active = False

  def onAddBlock(self, e):
    rblock_dlg = dlg.RunBlockDialog(self, trial=self.trial,
                                    db=self.db)
    rblock_dlg.Fit()

    if (rblock_dlg.ShowModal() == wx.ID_OK):
      self.refresh_trial()
    rblock_dlg.Destroy()

  def onSelectBlocks(self, e):
    rblocksel_dlg = dlg.SelectRunBlocksDialog(self, trial=self.trial,
                                           db=self.db)
    rblocksel_dlg.Fit()

    if (rblocksel_dlg.ShowModal() == wx.ID_OK):
      self.refresh_trial()
    rblocksel_dlg.Destroy()

  def refresh_trial(self):
    self.block_sizer.Clear(delete_windows=True)
    self.active_blocks = self.trial.rungroups
    for block in self.active_blocks:
      self.draw_block_button(block)
    self.block_panel.Layout()
    self.block_panel.SetupScrolling(scrollToTop=False)

  def draw_block_button(self, block):
    ''' Add new run block button '''
    new_block = gctr.RunBlock(self.block_panel, block=block)
    self.Bind(wx.EVT_BUTTON, self.onRunBlockOptions, new_block.new_runblock)
    self.block_sizer.Add(new_block,
                         flag=wx.TOP | wx.LEFT | wx.RIGHT | wx.ALIGN_CENTER,
                         border=5)

  def onRunBlockOptions(self, e):
    ''' Open dialog and change run_block options '''
    run_block = e.GetEventObject().block
    rblock_dlg = dlg.RunBlockDialog(self, block=run_block,
                                    db=self.db)
    rblock_dlg.Fit()

    if (rblock_dlg.ShowModal() == wx.ID_OK):
      wx.CallAfter(self.refresh_trial)
    rblock_dlg.Destroy()

class DatasetPanel(wx.Panel):
  ''' A scrolled panel that contains dataset and task controls '''

  def __init__(self, parent, db, dataset, box_label=""):
    wx.Panel.__init__(self, parent=parent, size=(270, 200))

    self.db = db
    self.dataset = dataset
    self.parent = parent

    self.dataset_box = wx.StaticBox(self, label=box_label)
    self.main_sizer = wx.StaticBoxSizer(self.dataset_box, wx.VERTICAL)

    self.dataset_comment = wx.StaticText(self)
    self.task_panel = ScrolledPanel(self, size=(150, 180))
    self.task_sizer = wx.BoxSizer(wx.VERTICAL)
    self.task_panel.SetSizer(self.task_sizer)
    self.one_task_sizer = wx.BoxSizer(wx.HORIZONTAL)
    self.add_panel = wx.Panel(self)
    self.add_sizer = wx.BoxSizer(wx.VERTICAL)
    self.add_panel.SetSizer(self.add_sizer)

    # Add "New task" button to a separate sizer (so it is always on bottom)
    self.btn_add_task = wx.Button(self.add_panel, label='New Task',
                                   size=(200, -1))
    self.btn_select_tasks = wx.Button(self.add_panel, label='Select Tasks',
                                       size=(200, -1))
    self.btn_edit_dataset = wx.BitmapButton(self.add_panel,
                                            bitmap=wx.Bitmap('{}/16x16/viewmag.png'.format(icons)))
    self.chk_active = wx.CheckBox(self.add_panel, label='Active Dataset')
    self.chk_sizer = wx.FlexGridSizer(1, 2, 0, 10)
    self.chk_sizer.Add(self.btn_edit_dataset)
    self.chk_sizer.Add(self.chk_active, flag=wx.EXPAND)

    self.add_sizer.Add(self.btn_add_task,
                       flag=wx.TOP | wx.LEFT | wx.RIGHT | wx.ALIGN_CENTER,
                       border=10)
    self.add_sizer.Add(self.btn_select_tasks,
                       flag=wx.TOP | wx.LEFT | wx.RIGHT | wx.ALIGN_CENTER,
                       border=10)
    self.add_sizer.Add(self.chk_sizer,
                       flag=wx.TOP | wx.LEFT | wx.RIGHT | wx.ALIGN_LEFT,
                       border=10)

    self.main_sizer.Add(self.dataset_comment, 0, flag=wx.ALL, border=10)
    self.main_sizer.Add(self.task_panel, 1, flag=wx.EXPAND | wx.ALL, border=10)
    self.main_sizer.Add(self.add_panel, flag=wx.ALL, border=5)

    # Bindings
    self.Bind(wx.EVT_BUTTON, self.onAddTask, self.btn_add_task)
    self.Bind(wx.EVT_BUTTON, self.onSelectTasks, self.btn_select_tasks)
    self.Bind(wx.EVT_BUTTON, self.onEditDataset, self.btn_edit_dataset)
    self.chk_active.Bind(wx.EVT_CHECKBOX, self.onToggleActivity)

    self.SetSizer(self.main_sizer)

  def onToggleActivity(self, e):
    if self.chk_active.GetValue():
      self.dataset.active = True
    else:
      self.dataset.active = False

  def onAddTask(self, e):
    task_dlg = dlg.TaskDialog(self, dataset=self.dataset,
                                    db=self.db)
    task_dlg.Fit()

    if (task_dlg.ShowModal() == wx.ID_OK):
      self.refresh_dataset()
    task_dlg.Destroy()

  def onSelectTasks(self, e):
    tasksel_dlg = dlg.SelectTasksDialog(self, dataset=self.dataset,
                                           db=self.db)
    tasksel_dlg.Fit()

    if (tasksel_dlg.ShowModal() == wx.ID_OK):
      self.refresh_dataset()
    tasksel_dlg.Destroy()

  def refresh_dataset(self):
    self.dataset_comment.SetLabel(self.dataset.comment if self.dataset.comment is not None else "")
    self.dataset_box.SetLabel('Dataset {} {}'.format(self.dataset.dataset_id,
                               self.dataset.name[:min(len(self.dataset.name), 20)]
                               if self.dataset.name is not None else ""))
    self.task_sizer.Clear(delete_windows=True)
    tags = self.dataset.tags
    if tags:
      tags_text = "Tags: " + ",".join([t.name for t in tags])
    else:
      tags_text = "No tags selected"
    label = wx.StaticText(self.task_panel, label = tags_text)
    self.task_sizer.Add(label,
                        flag=wx.TOP | wx.LEFT | wx.RIGHT | wx.ALIGN_CENTER,
                        border=5)
    for task in self.dataset.tasks:
      self.draw_task_button(task)
    self.task_panel.Layout()
    self.task_panel.SetupScrolling(scrollToTop=False)

  def draw_task_button(self, task):
    ''' Add new run block button '''
    new_task = gctr.TaskCtrl(self.task_panel, task=task)
    self.Bind(wx.EVT_BUTTON, self.onTaskOptions, new_task.new_task)
    self.task_sizer.Add(new_task,
                        flag=wx.TOP | wx.LEFT | wx.RIGHT | wx.ALIGN_CENTER,
                        border=5)

  def onTaskOptions(self, e):
    ''' Open dialog and change task options '''
    task = e.GetEventObject().task
    task_dlg = dlg.TaskDialog(self, task=task,
                                    db=self.db)
    task_dlg.Fit()

    if (task_dlg.ShowModal() == wx.ID_OK):
      wx.CallAfter(self.refresh_dataset)
    task_dlg.Destroy()

  def onEditDataset(self, e):
    new_dataset_dlg = dlg.DatasetDialog(self, db=self.db, dataset=self.dataset, new=False)
    new_dataset_dlg.Fit()

    if new_dataset_dlg.ShowModal() == wx.ID_OK:
      self.refresh_dataset()

class RunEntry(wx.Panel):
  ''' Adds run row to table, with average and view buttons'''
  def __init__(self, parent, run, params, label_width = None):
    self.run = run
    self.params = params

    wx.Panel.__init__(self, parent=parent)
    if label_width is None: label_width = 60

    self.sizer = wx.FlexGridSizer(1, 4, 0, 10)
    run_no = wx.StaticText(self, label=str(run),
                           size=(label_width, -1))
    self.tag_button = gctr.TagButton(self, run=run)
    self.avg_button = wx.Button(self, label='Average')
    self.view_button = wx.Button(self, label='View')
    self.view_button.Hide()

    self.sizer.Add(run_no, flag=wx.EXPAND)
    self.sizer.Add(self.tag_button, flag=wx.EXPAND)
    self.sizer.AddGrowableCol(1)
    self.sizer.Add(self.avg_button)
    self.sizer.Add(self.view_button, flag=wx.RESERVE_SPACE_EVEN_IF_HIDDEN)

    # Button Bindings
    self.Bind(wx.EVT_BUTTON, self.onTagButton, self.tag_button)
    self.Bind(wx.EVT_BUTTON, self.onAvgButton, self.avg_button)
    self.Bind(wx.EVT_BUTTON, self.onViewButton, self.view_button)

    self.SetSizer(self.sizer)

  def onTagButton(self, e):
    self.tag_button.change_tags()

  def onAvgButton(self, e):
    avg = dlg.AveragingDialog(self, self.run, self.params)
    avg.Fit()
    avg.Center()

    if (avg.ShowModal() == wx.ID_OK):
      e.GetEventObject().SetLabel('Running')
      e.GetEventObject().Disable()
      self.view_button.Show()
      # TODO: hook up the calibration app

  def onViewButton(self, e):
    # TODO: hook up view function
    pass


 *******************************************************************************
