

 *******************************************************************************
crys3d/hklviewer/hklviewer_gui.py
# -*- coding: utf-8 -*-

################################################################################
## Form generated from reading UI file 'HKLviewer6.ui'
##
## Created by: Qt User Interface Compiler version 5.15.2
##
## WARNING! All changes made in this file will be lost when recompiling UI file!
################################################################################
from __future__ import absolute_import, division, print_function

from .qt import QWebEngineView
try: # if invoked by cctbx.python or some such
  from crys3d.hklviewer.helpers import HeaderDataTableWidget, MyQDoubleSpinBox, MyQPlainTextEdit # implicit import
except Exception as e: # if invoked by a generic python that doesn't know cctbx modules
  from .helpers import HeaderDataTableWidget, MyQDoubleSpinBox, MyQPlainTextEdit # implicit import

from .qt import ( QCoreApplication, QMetaObject, QRect, QSize, Qt,  # implicit import
 QFont, QAbstractItemView, QAction, QCheckBox, QComboBox, QLineEdit, QDockWidget,
 QDoubleSpinBox, QFrame, QGridLayout, QGroupBox, QLabel, QPlainTextEdit,
 QPushButton, QRadioButton, QScrollArea, QSlider, QSplitter, QSizePolicy, QSpinBox,
 QTableWidget, QTabWidget, QTextEdit, QWidget, QIcon, QAbstractScrollArea, )



class Ui_MainWindow(object):
    def setupUi(self, MainWindow):
        if not MainWindow.objectName():
            MainWindow.setObjectName(u"MainWindow")
        MainWindow.resize(824, 751)
        sizePolicy = QSizePolicy(QSizePolicy.Preferred, QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(MainWindow.sizePolicy().hasHeightForWidth())
        MainWindow.setSizePolicy(sizePolicy)
        self.actionOpen_reflection_file = QAction(MainWindow)
        self.actionOpen_reflection_file.setObjectName(u"actionOpen_reflection_file")
        self.actionSettings = QAction(MainWindow)
        self.actionSettings.setObjectName(u"actionSettings")
        self.actiondebug = QAction(MainWindow)
        self.actiondebug.setObjectName(u"actiondebug")
        self.actionExit = QAction(MainWindow)
        self.actionExit.setObjectName(u"actionExit")
        self.actionSave_reflection_file = QAction(MainWindow)
        self.actionSave_reflection_file.setObjectName(u"actionSave_reflection_file")
        self.actionReset_View = QAction(MainWindow)
        self.actionReset_View.setObjectName(u"actionReset_View")
        self.actionSave_Current_Image = QAction(MainWindow)
        self.actionSave_Current_Image.setObjectName(u"actionSave_Current_Image")
        self.actionCCTBXwebsite = QAction(MainWindow)
        self.actionCCTBXwebsite.setObjectName(u"actionCCTBXwebsite")
        self.actionLocal_Help = QAction(MainWindow)
        self.actionLocal_Help.setObjectName(u"actionLocal_Help")
        self.actionAbout = QAction(MainWindow)
        self.actionAbout.setObjectName(u"actionAbout")
        self.actionColour_Gradient = QAction(MainWindow)
        self.actionColour_Gradient.setObjectName(u"actionColour_Gradient")
        self.actionHKLviewer_Tutorial = QAction(MainWindow)
        self.actionHKLviewer_Tutorial.setObjectName(u"actionHKLviewer_Tutorial")
        self.actionBackground_Colour = QAction(MainWindow)
        self.actionBackground_Colour.setObjectName(u"actionBackground_Colour")
        self.actionNGLmousebindings = QAction(MainWindow)
        self.actionNGLmousebindings.setObjectName(u"actionNGLmousebindings")
        self.centralwidget = QWidget(MainWindow)
        self.centralwidget.setObjectName(u"centralwidget")
        sizePolicy.setHeightForWidth(self.centralwidget.sizePolicy().hasHeightForWidth())
        self.centralwidget.setSizePolicy(sizePolicy)
        self.gridLayout_2 = QGridLayout(self.centralwidget)
        self.gridLayout_2.setSpacing(0)
        self.gridLayout_2.setContentsMargins(3, 3, 3, 3)
        self.gridLayout_2.setObjectName(u"gridLayout_2")
        self.gridLayout_2.setContentsMargins(0, 0, 0, 0)
        self.widget = QWidget(self.centralwidget)
        self.widget.setObjectName(u"widget")
        sizePolicy.setHeightForWidth(self.widget.sizePolicy().hasHeightForWidth())
        self.widget.setSizePolicy(sizePolicy)
        self.gridLayout_32 = QGridLayout(self.widget)
        self.gridLayout_32.setSpacing(0)
        self.gridLayout_32.setContentsMargins(3, 3, 3, 3)
        self.gridLayout_32.setObjectName(u"gridLayout_32")
        self.gridLayout_32.setContentsMargins(0, 0, 0, 0)
        self.BrowserBox = QWebEngineView(self.widget)
        self.BrowserBox.setObjectName(u"BrowserBox")
        sizePolicy1 = QSizePolicy(QSizePolicy.Preferred, QSizePolicy.Preferred)
        sizePolicy1.setHorizontalStretch(2)
        sizePolicy1.setVerticalStretch(0)
        sizePolicy1.setHeightForWidth(self.BrowserBox.sizePolicy().hasHeightForWidth())
        self.BrowserBox.setSizePolicy(sizePolicy1)

        self.gridLayout_32.addWidget(self.BrowserBox, 0, 0, 1, 1)


        self.gridLayout_2.addWidget(self.widget, 0, 0, 1, 1)

        #MainWindow.setCentralWidget(self.centralwidget)
        self.ControlsWidget = QDockWidget(MainWindow)
        self.ControlsWidget.setObjectName(u"ControlsWidget")
        self.ControlsWidget.setMinimumSize(QSize(183, 241))
        self.ControlsWidget.setFeatures(QDockWidget.DockWidgetFloatable|QDockWidget.DockWidgetMovable)
        self.dockControls = QWidget()
        self.dockControls.setObjectName(u"dockControls")
        self.gridLayout_9 = QGridLayout(self.dockControls)
        self.gridLayout_9.setSpacing(0)
        self.gridLayout_9.setContentsMargins(3, 3, 3, 3)
        self.gridLayout_9.setObjectName(u"gridLayout_9")
        self.gridLayout_9.setContentsMargins(0, 0, 0, 0)
        self.widget_2 = QWidget(self.dockControls)
        self.widget_2.setObjectName(u"widget_2")
        sizePolicy.setHeightForWidth(self.widget_2.sizePolicy().hasHeightForWidth())
        self.widget_2.setSizePolicy(sizePolicy)
        self.gridLayout_31 = QGridLayout(self.widget_2)
        self.gridLayout_31.setSpacing(0)
        self.gridLayout_31.setContentsMargins(3, 3, 3, 3)
        self.gridLayout_31.setObjectName(u"gridLayout_31")
        self.gridLayout_31.setContentsMargins(0, 0, 0, 0)
        self.splitter_2 = QSplitter(self.widget_2)
        self.splitter_2.setObjectName(u"splitter_2")
        sizePolicy.setHeightForWidth(self.splitter_2.sizePolicy().hasHeightForWidth())
        self.splitter_2.setSizePolicy(sizePolicy)
        self.splitter_2.setOrientation(Qt.Vertical)
        self.splitter_2.setHandleWidth(5)
        self.tabWidget = QTabWidget(self.splitter_2)
        self.tabWidget.setObjectName(u"tabWidget")
        sizePolicy.setHeightForWidth(self.tabWidget.sizePolicy().hasHeightForWidth())
        self.tabWidget.setSizePolicy(sizePolicy)
        self.tabWidget.setMinimumSize(QSize(0, 0))
        self.tabWidget.setElideMode(Qt.ElideNone)
        self.tabWidget.setUsesScrollButtons(True)
        self.tabPresetbuttons = QWidget()
        self.tabPresetbuttons.setObjectName(u"tabPresetbuttons")
        self.gridLayout_25 = QGridLayout(self.tabPresetbuttons)
        self.gridLayout_25.setSpacing(3)
        self.gridLayout_25.setContentsMargins(3, 3, 3, 3)
        self.gridLayout_25.setObjectName(u"gridLayout_25")
        self.gridLayout_25.setContentsMargins(3, 3, 3, 3)
        self.XtricorderBtn = QPushButton(self.tabPresetbuttons)
        self.XtricorderBtn.setObjectName(u"XtricorderBtn")
        sizePolicy.setHeightForWidth(self.XtricorderBtn.sizePolicy().hasHeightForWidth())
        self.XtricorderBtn.setSizePolicy(sizePolicy)

        self.gridLayout_25.addWidget(self.XtricorderBtn, 0, 1, 1, 1)

        self.XtriageBtn = QPushButton(self.tabPresetbuttons)
        self.XtriageBtn.setObjectName(u"XtriageBtn")
        sizePolicy.setHeightForWidth(self.XtriageBtn.sizePolicy().hasHeightForWidth())
        self.XtriageBtn.setSizePolicy(sizePolicy)

        self.gridLayout_25.addWidget(self.XtriageBtn, 0, 0, 1, 1)

        self.scrollArea_2 = QScrollArea(self.tabPresetbuttons)
        self.scrollArea_2.setObjectName(u"scrollArea_2")
        sizePolicy2 = QSizePolicy(QSizePolicy.Preferred, QSizePolicy.Expanding)
        sizePolicy2.setHorizontalStretch(0)
        sizePolicy2.setVerticalStretch(0)
        sizePolicy2.setHeightForWidth(self.scrollArea_2.sizePolicy().hasHeightForWidth())
        self.scrollArea_2.setSizePolicy(sizePolicy2)
        self.scrollArea_2.setFrameShadow(QFrame.Plain)
        self.scrollArea_2.setHorizontalScrollBarPolicy(Qt.ScrollBarAsNeeded)
        self.scrollArea_2.setWidgetResizable(True)
        self.scrollAreaWidgetContents_2 = QWidget()
        self.scrollAreaWidgetContents_2.setObjectName(u"scrollAreaWidgetContents_2")
        self.scrollAreaWidgetContents_2.setGeometry(QRect(0, 0, 460, 547))
        self.gridLayout_29 = QGridLayout(self.scrollAreaWidgetContents_2)
        self.gridLayout_29.setSpacing(4)
        self.gridLayout_29.setContentsMargins(3, 3, 3, 3)
        self.gridLayout_29.setObjectName(u"gridLayout_29")
        self.gridLayout_29.setContentsMargins(0, 0, 0, 0)
        self.PresetButtonsFrame = QFrame(self.scrollAreaWidgetContents_2)
        self.PresetButtonsFrame.setObjectName(u"PresetButtonsFrame")
        sizePolicy3 = QSizePolicy(QSizePolicy.Preferred, QSizePolicy.Preferred)
        sizePolicy3.setHorizontalStretch(0)
        sizePolicy3.setVerticalStretch(1)
        sizePolicy3.setHeightForWidth(self.PresetButtonsFrame.sizePolicy().hasHeightForWidth())
        self.PresetButtonsFrame.setSizePolicy(sizePolicy3)
        self.PresetButtonsFrame.setFrameShape(QFrame.StyledPanel)
        self.PresetButtonsFrame.setFrameShadow(QFrame.Raised)
        self.gridLayout_24 = QGridLayout(self.PresetButtonsFrame)
        self.gridLayout_24.setSpacing(4)
        self.gridLayout_24.setContentsMargins(3, 3, 3, 3)
        self.gridLayout_24.setObjectName(u"gridLayout_24")
        self.gridLayout_24.setContentsMargins(0, 0, 0, 0)

        self.gridLayout_29.addWidget(self.PresetButtonsFrame, 0, 0, 1, 1)

        self.scrollArea_2.setWidget(self.scrollAreaWidgetContents_2)

        self.gridLayout_25.addWidget(self.scrollArea_2, 1, 0, 1, 2)

        self.tabWidget.addTab(self.tabPresetbuttons, "")
        self.tabDetails = QWidget()
        self.tabDetails.setObjectName(u"tabDetails")
        self.gridLayout_23 = QGridLayout(self.tabDetails)
        self.gridLayout_23.setSpacing(4)
        self.gridLayout_23.setContentsMargins(3, 3, 3, 3)
        self.gridLayout_23.setObjectName(u"gridLayout_23")
        self.gridLayout_23.setContentsMargins(0, 0, 0, 0)
        self.splitter = QSplitter(self.tabDetails)
        self.splitter.setObjectName(u"splitter")
        self.splitter.setOrientation(Qt.Vertical)
        self.widget_4 = QWidget(self.splitter)
        self.widget_4.setObjectName(u"widget_4")
        sizePolicy4 = QSizePolicy(QSizePolicy.Preferred, QSizePolicy.Preferred)
        sizePolicy4.setHorizontalStretch(0)
        sizePolicy4.setVerticalStretch(2)
        sizePolicy4.setHeightForWidth(self.widget_4.sizePolicy().hasHeightForWidth())
        self.widget_4.setSizePolicy(sizePolicy4)
        self.gridLayout_5 = QGridLayout(self.widget_4)
        self.gridLayout_5.setSpacing(4)
        self.gridLayout_5.setContentsMargins(3, 3, 3, 3)
        self.gridLayout_5.setObjectName(u"gridLayout_5")
        self.gridLayout_5.setContentsMargins(0, 0, 0, 0)
        self.millertable = HeaderDataTableWidget(self.widget_4)
        if (self.millertable.columnCount() < 2):
            self.millertable.setColumnCount(2)
        if (self.millertable.rowCount() < 1):
            self.millertable.setRowCount(1)
        self.millertable.setObjectName(u"millertable")
        sizePolicy4.setHeightForWidth(self.millertable.sizePolicy().hasHeightForWidth())
        self.millertable.setSizePolicy(sizePolicy4)
        self.millertable.setVerticalScrollMode(QAbstractItemView.ScrollPerPixel)
        self.millertable.setHorizontalScrollMode(QAbstractItemView.ScrollPerPixel)
        self.millertable.setRowCount(1)
        self.millertable.setColumnCount(2)
        self.millertable.horizontalHeader().setMinimumSectionSize(5)
        self.millertable.horizontalHeader().setStretchLastSection(False)
        self.millertable.verticalHeader().setDefaultSectionSize(24)

        self.gridLayout_5.addWidget(self.millertable, 1, 0, 1, 1)

        self.label = QLabel(self.widget_4)
        self.label.setObjectName(u"label")
        sizePolicy5 = QSizePolicy(QSizePolicy.Preferred, QSizePolicy.Fixed)
        sizePolicy5.setHorizontalStretch(0)
        sizePolicy5.setVerticalStretch(0)
        sizePolicy5.setHeightForWidth(self.label.sizePolicy().hasHeightForWidth())
        self.label.setSizePolicy(sizePolicy5)
        self.label.setMinimumSize(QSize(0, 0))
        self.label.setWordWrap(True)

        self.gridLayout_5.addWidget(self.label, 0, 0, 1, 1)

        self.splitter.addWidget(self.widget_4)
        self.SpaceGrpUCellText = QTextEdit(self.splitter)
        self.SpaceGrpUCellText.setObjectName(u"SpaceGrpUCellText")
        sizePolicy6 = QSizePolicy(QSizePolicy.Minimum, QSizePolicy.Fixed)
        sizePolicy6.setHorizontalStretch(0)
        sizePolicy6.setVerticalStretch(2)
        sizePolicy6.setHeightForWidth(self.SpaceGrpUCellText.sizePolicy().hasHeightForWidth())
        self.SpaceGrpUCellText.setSizePolicy(sizePolicy6)
        self.SpaceGrpUCellText.setMinimumSize(QSize(100, 30))
        self.SpaceGrpUCellText.setMaximumSize(QSize(16777215, 192))
        font = QFont()
        font.setFamily(u"Arial")
        self.SpaceGrpUCellText.setFont(font)
        self.SpaceGrpUCellText.setVerticalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
        self.SpaceGrpUCellText.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
        self.SpaceGrpUCellText.setSizeAdjustPolicy(QAbstractScrollArea.AdjustToContents)
        self.SpaceGrpUCellText.setReadOnly(True)
        self.SpaceGrpUCellText.setOverwriteMode(True)
        self.SpaceGrpUCellText.setAcceptRichText(False)
        self.splitter.addWidget(self.SpaceGrpUCellText)
        self.scrollArea = QScrollArea(self.splitter)
        self.scrollArea.setObjectName(u"scrollArea")
        sizePolicy7 = QSizePolicy(QSizePolicy.Maximum, QSizePolicy.Preferred)
        sizePolicy7.setHorizontalStretch(0)
        sizePolicy7.setVerticalStretch(2)
        sizePolicy7.setHeightForWidth(self.scrollArea.sizePolicy().hasHeightForWidth())
        self.scrollArea.setSizePolicy(sizePolicy7)
        self.scrollArea.setMinimumSize(QSize(150, 0))
        self.scrollArea.setWidgetResizable(True)
        self.scrollAreaWidgetContents = QWidget()
        self.scrollAreaWidgetContents.setObjectName(u"scrollAreaWidgetContents")
        self.scrollAreaWidgetContents.setGeometry(QRect(0, 0, 453, 395))
        sizePolicy4.setHeightForWidth(self.scrollAreaWidgetContents.sizePolicy().hasHeightForWidth())
        self.scrollAreaWidgetContents.setSizePolicy(sizePolicy4)
        self.scrollAreaWidgetContents.setMinimumSize(QSize(0, 0))
        self.gridLayout_4 = QGridLayout(self.scrollAreaWidgetContents)
        self.gridLayout_4.setSpacing(4)
        self.gridLayout_4.setContentsMargins(3, 3, 3, 3)
        self.gridLayout_4.setObjectName(u"gridLayout_4")
        self.gridLayout_4.setContentsMargins(0, 0, 0, 0)
        self.functionTabWidget = QTabWidget(self.scrollAreaWidgetContents)
        self.functionTabWidget.setObjectName(u"functionTabWidget")
        sizePolicy.setHeightForWidth(self.functionTabWidget.sizePolicy().hasHeightForWidth())
        self.functionTabWidget.setSizePolicy(sizePolicy)
        self.functionTabWidget.setMinimumSize(QSize(100, 0))
        self.expansion_tab = QWidget()
        self.expansion_tab.setObjectName(u"expansion_tab")
        self.expansion_tab.setToolTipDuration(5)
        self.gridLayout_28 = QGridLayout(self.expansion_tab)
        self.gridLayout_28.setSpacing(4)
        self.gridLayout_28.setContentsMargins(3, 3, 3, 3)
        self.gridLayout_28.setObjectName(u"gridLayout_28")
        self.ExpandReflsGroupBox = QGroupBox(self.expansion_tab)
        self.ExpandReflsGroupBox.setObjectName(u"ExpandReflsGroupBox")
        sizePolicy5.setHeightForWidth(self.ExpandReflsGroupBox.sizePolicy().hasHeightForWidth())
        self.ExpandReflsGroupBox.setSizePolicy(sizePolicy5)
        self.ExpandReflsGroupBox.setCheckable(True)
        self.ExpandReflsGroupBox.setChecked(False)
        self.gridLayout_3 = QGridLayout(self.ExpandReflsGroupBox)
        self.gridLayout_3.setSpacing(4)
        self.gridLayout_3.setContentsMargins(3, 3, 3, 3)
        self.gridLayout_3.setObjectName(u"gridLayout_3")
        self.gridLayout_3.setContentsMargins(6, 6, 6, 6)
        self.expandP1checkbox = QCheckBox(self.ExpandReflsGroupBox)
        self.expandP1checkbox.setObjectName(u"expandP1checkbox")

        self.gridLayout_3.addWidget(self.expandP1checkbox, 0, 0, 1, 1)

        self.expandAnomalouscheckbox = QCheckBox(self.ExpandReflsGroupBox)
        self.expandAnomalouscheckbox.setObjectName(u"expandAnomalouscheckbox")

        self.gridLayout_3.addWidget(self.expandAnomalouscheckbox, 0, 1, 1, 1)


        self.gridLayout_28.addWidget(self.ExpandReflsGroupBox, 0, 0, 1, 3, Qt.AlignTop)

        self.sysabsentcheckbox = QCheckBox(self.expansion_tab)
        self.sysabsentcheckbox.setObjectName(u"sysabsentcheckbox")

        self.gridLayout_28.addWidget(self.sysabsentcheckbox, 1, 0, 1, 1, Qt.AlignTop)

        self.SpaceGroupComboBox = QComboBox(self.expansion_tab)
        self.SpaceGroupComboBox.setObjectName(u"SpaceGroupComboBox")
        sizePolicy5.setHeightForWidth(self.SpaceGroupComboBox.sizePolicy().hasHeightForWidth())
        self.SpaceGroupComboBox.setSizePolicy(sizePolicy5)

        self.gridLayout_28.addWidget(self.SpaceGroupComboBox, 5, 1, 1, 2, Qt.AlignTop)

        self.SpacegroupLabel = QLabel(self.expansion_tab)
        self.SpacegroupLabel.setObjectName(u"SpacegroupLabel")
        sizePolicy5.setHeightForWidth(self.SpacegroupLabel.sizePolicy().hasHeightForWidth())
        self.SpacegroupLabel.setSizePolicy(sizePolicy5)
        self.SpacegroupLabel.setTextFormat(Qt.AutoText)

        self.gridLayout_28.addWidget(self.SpacegroupLabel, 5, 0, 1, 1, Qt.AlignTop)

        self.widget_3 = QWidget(self.expansion_tab)
        self.widget_3.setObjectName(u"widget_3")
        sizePolicy5.setHeightForWidth(self.widget_3.sizePolicy().hasHeightForWidth())
        self.widget_3.setSizePolicy(sizePolicy5)
        self.gridLayout_20 = QGridLayout(self.widget_3)
        self.gridLayout_20.setSpacing(4)
        self.gridLayout_20.setContentsMargins(3, 3, 3, 3)
        self.gridLayout_20.setObjectName(u"gridLayout_20")
        self.gridLayout_20.setContentsMargins(0, 0, 0, 0)
        self.onlymissingcheckbox = QCheckBox(self.widget_3)
        self.onlymissingcheckbox.setObjectName(u"onlymissingcheckbox")

        self.gridLayout_20.addWidget(self.onlymissingcheckbox, 2, 0, 1, 1)

        self.missingcheckbox = QCheckBox(self.widget_3)
        self.missingcheckbox.setObjectName(u"missingcheckbox")

        self.gridLayout_20.addWidget(self.missingcheckbox, 0, 0, 2, 2)


        self.gridLayout_28.addWidget(self.widget_3, 1, 1, 1, 2, Qt.AlignTop)

        self.dummyframe = QFrame(self.expansion_tab)
        self.dummyframe.setObjectName(u"dummyframe")
        sizePolicy4.setHeightForWidth(self.dummyframe.sizePolicy().hasHeightForWidth())
        self.dummyframe.setSizePolicy(sizePolicy4)
        self.dummyframe.setFrameShape(QFrame.NoFrame)
        self.dummyframe.setFrameShadow(QFrame.Raised)

        self.gridLayout_28.addWidget(self.dummyframe, 8, 0, 1, 3)

        self.commitSubgroupExpansionBtn = QPushButton(self.expansion_tab)
        self.commitSubgroupExpansionBtn.setObjectName(u"commitSubgroupExpansionBtn")
        sizePolicy2.setHeightForWidth(self.commitSubgroupExpansionBtn.sizePolicy().hasHeightForWidth())
        self.commitSubgroupExpansionBtn.setSizePolicy(sizePolicy2)

        self.gridLayout_28.addWidget(self.commitSubgroupExpansionBtn, 7, 1, 1, 2)

        self.functionTabWidget.addTab(self.expansion_tab, "")
        self.slicing_tab = QWidget()
        self.slicing_tab.setObjectName(u"slicing_tab")
        self.gridLayout_7 = QGridLayout(self.slicing_tab)
        self.gridLayout_7.setSpacing(4)
        self.gridLayout_7.setContentsMargins(3, 3, 3, 3)
        self.gridLayout_7.setObjectName(u"gridLayout_7")
        self.ClipPlaneChkGroupBox = QGroupBox(self.slicing_tab)
        self.ClipPlaneChkGroupBox.setObjectName(u"ClipPlaneChkGroupBox")
        sizePolicy3.setHeightForWidth(self.ClipPlaneChkGroupBox.sizePolicy().hasHeightForWidth())
        self.ClipPlaneChkGroupBox.setSizePolicy(sizePolicy3)
        self.ClipPlaneChkGroupBox.setAlignment(Qt.AlignLeading|Qt.AlignLeft|Qt.AlignVCenter)
        self.ClipPlaneChkGroupBox.setCheckable(True)
        self.ClipPlaneChkGroupBox.setChecked(False)
        self.gridLayout_6 = QGridLayout(self.ClipPlaneChkGroupBox)
        self.gridLayout_6.setSpacing(4)
        self.gridLayout_6.setContentsMargins(3, 3, 3, 3)
        self.gridLayout_6.setObjectName(u"gridLayout_6")
        self.parallel_current_orientation_btn = QRadioButton(self.ClipPlaneChkGroupBox)
        self.parallel_current_orientation_btn.setObjectName(u"parallel_current_orientation_btn")
        sizePolicy5.setHeightForWidth(self.parallel_current_orientation_btn.sizePolicy().hasHeightForWidth())
        self.parallel_current_orientation_btn.setSizePolicy(sizePolicy5)
        self.parallel_current_orientation_btn.setChecked(True)

        self.gridLayout_6.addWidget(self.parallel_current_orientation_btn, 0, 0, 1, 2)

        self.normal_vec_btn = QRadioButton(self.ClipPlaneChkGroupBox)
        self.normal_vec_btn.setObjectName(u"normal_vec_btn")
        sizePolicy5.setHeightForWidth(self.normal_vec_btn.sizePolicy().hasHeightForWidth())
        self.normal_vec_btn.setSizePolicy(sizePolicy5)

        self.gridLayout_6.addWidget(self.normal_vec_btn, 1, 0, 1, 2)

        self.clipplane_normal_vector_combo = QComboBox(self.ClipPlaneChkGroupBox)
        self.clipplane_normal_vector_combo.setObjectName(u"clipplane_normal_vector_combo")
        sizePolicy8 = QSizePolicy(QSizePolicy.Preferred, QSizePolicy.Fixed)
        sizePolicy8.setHorizontalStretch(2)
        sizePolicy8.setVerticalStretch(0)
        sizePolicy8.setHeightForWidth(self.clipplane_normal_vector_combo.sizePolicy().hasHeightForWidth())
        self.clipplane_normal_vector_combo.setSizePolicy(sizePolicy8)

        self.gridLayout_6.addWidget(self.clipplane_normal_vector_combo, 1, 2, 2, 1)

        self.normal_realspace_vec_btn = QRadioButton(self.ClipPlaneChkGroupBox)
        self.normal_realspace_vec_btn.setObjectName(u"normal_realspace_vec_btn")
        sizePolicy9 = QSizePolicy(QSizePolicy.Fixed, QSizePolicy.Preferred)
        sizePolicy9.setHorizontalStretch(1)
        sizePolicy9.setVerticalStretch(0)
        sizePolicy9.setHeightForWidth(self.normal_realspace_vec_btn.sizePolicy().hasHeightForWidth())
        self.normal_realspace_vec_btn.setSizePolicy(sizePolicy9)

        self.gridLayout_6.addWidget(self.normal_realspace_vec_btn, 2, 0, 1, 1)

        self.normal_realspace_vec_label = QLabel(self.ClipPlaneChkGroupBox)
        self.normal_realspace_vec_label.setObjectName(u"normal_realspace_vec_label")
        sizePolicy10 = QSizePolicy(QSizePolicy.Preferred, QSizePolicy.Preferred)
        sizePolicy10.setHorizontalStretch(1)
        sizePolicy10.setVerticalStretch(0)
        sizePolicy10.setHeightForWidth(self.normal_realspace_vec_label.sizePolicy().hasHeightForWidth())
        self.normal_realspace_vec_label.setSizePolicy(sizePolicy10)
        self.normal_realspace_vec_label.setWordWrap(True)

        self.gridLayout_6.addWidget(self.normal_realspace_vec_label, 2, 1, 2, 1)

        self.label_13 = QLabel(self.ClipPlaneChkGroupBox)
        self.label_13.setObjectName(u"label_13")
        sizePolicy5.setHeightForWidth(self.label_13.sizePolicy().hasHeightForWidth())
        self.label_13.setSizePolicy(sizePolicy5)
        self.label_13.setTextFormat(Qt.RichText)
        self.label_13.setAlignment(Qt.AlignRight|Qt.AlignTrailing|Qt.AlignVCenter)

        self.gridLayout_6.addWidget(self.label_13, 3, 2, 1, 1)

        self.clipplane_normal_vector_length = QLineEdit(self.ClipPlaneChkGroupBox)
        self.clipplane_normal_vector_length.setObjectName(u"clipplane_normal_vector_length")
        sizePolicy5.setHeightForWidth(self.clipplane_normal_vector_length.sizePolicy().hasHeightForWidth())
        self.clipplane_normal_vector_length.setSizePolicy(sizePolicy5)
        self.clipplane_normal_vector_length.setReadOnly(False)

        self.gridLayout_6.addWidget(self.clipplane_normal_vector_length, 3, 3, 1, 2)

        self.label_15 = QLabel(self.ClipPlaneChkGroupBox)
        self.label_15.setObjectName(u"label_15")
        sizePolicy.setHeightForWidth(self.label_15.sizePolicy().hasHeightForWidth())
        self.label_15.setSizePolicy(sizePolicy)
        self.label_15.setWordWrap(True)

        self.gridLayout_6.addWidget(self.label_15, 4, 0, 1, 2)

        self.AutoClipWidthCheckBox = QCheckBox(self.ClipPlaneChkGroupBox)
        self.AutoClipWidthCheckBox.setObjectName(u"AutoClipWidthCheckBox")
        sizePolicy.setHeightForWidth(self.AutoClipWidthCheckBox.sizePolicy().hasHeightForWidth())
        self.AutoClipWidthCheckBox.setSizePolicy(sizePolicy)

        self.gridLayout_6.addWidget(self.AutoClipWidthCheckBox, 4, 2, 1, 3)

        self.hkldist_spinBox = MyQDoubleSpinBox(self.ClipPlaneChkGroupBox)
        self.hkldist_spinBox.setObjectName(u"hkldist_spinBox")
        sizePolicy5.setHeightForWidth(self.hkldist_spinBox.sizePolicy().hasHeightForWidth())
        self.hkldist_spinBox.setSizePolicy(sizePolicy5)
        self.hkldist_spinBox.setDecimals(3)
        self.hkldist_spinBox.setMinimum(-1000.000000000000000)
        self.hkldist_spinBox.setMaximum(1000.000000000000000)

        self.gridLayout_6.addWidget(self.hkldist_spinBox, 5, 0, 1, 2)

        self.label_21 = QLabel(self.ClipPlaneChkGroupBox)
        self.label_21.setObjectName(u"label_21")
        sizePolicy.setHeightForWidth(self.label_21.sizePolicy().hasHeightForWidth())
        self.label_21.setSizePolicy(sizePolicy)
        self.label_21.setAlignment(Qt.AlignRight|Qt.AlignTrailing|Qt.AlignVCenter)
        self.label_21.setWordWrap(True)

        self.gridLayout_6.addWidget(self.label_21, 5, 2, 1, 2)

        self.clipwidth_spinBox = MyQDoubleSpinBox(self.ClipPlaneChkGroupBox)
        self.clipwidth_spinBox.setObjectName(u"clipwidth_spinBox")
        sizePolicy5.setHeightForWidth(self.clipwidth_spinBox.sizePolicy().hasHeightForWidth())
        self.clipwidth_spinBox.setSizePolicy(sizePolicy5)
        self.clipwidth_spinBox.setMinimum(0.500000000000000)
        self.clipwidth_spinBox.setMaximum(100.000000000000000)
        self.clipwidth_spinBox.setSingleStep(0.500000000000000)

        self.gridLayout_6.addWidget(self.clipwidth_spinBox, 5, 4, 1, 1)


        self.gridLayout_7.addWidget(self.ClipPlaneChkGroupBox, 0, 0, 1, 1)

        self.RotateGroupBox = QGroupBox(self.slicing_tab)
        self.RotateGroupBox.setObjectName(u"RotateGroupBox")
        sizePolicy3.setHeightForWidth(self.RotateGroupBox.sizePolicy().hasHeightForWidth())
        self.RotateGroupBox.setSizePolicy(sizePolicy3)
        self.gridLayout_22 = QGridLayout(self.RotateGroupBox)
        self.gridLayout_22.setSpacing(4)
        self.gridLayout_22.setContentsMargins(3, 3, 3, 3)
        self.gridLayout_22.setObjectName(u"gridLayout_22")
        self.gridLayout_22.setContentsMargins(0, 3, 0, 0)
        self.label_14 = QLabel(self.RotateGroupBox)
        self.label_14.setObjectName(u"label_14")
        self.label_14.setAlignment(Qt.AlignRight|Qt.AlignTrailing|Qt.AlignVCenter)

        self.gridLayout_22.addWidget(self.label_14, 0, 0, 1, 1)

        self.angleStepHKLrotSpinBox = QDoubleSpinBox(self.RotateGroupBox)
        self.angleStepHKLrotSpinBox.setObjectName(u"angleStepHKLrotSpinBox")
        sizePolicy11 = QSizePolicy(QSizePolicy.Minimum, QSizePolicy.Fixed)
        sizePolicy11.setHorizontalStretch(0)
        sizePolicy11.setVerticalStretch(0)
        sizePolicy11.setHeightForWidth(self.angleStepHKLrotSpinBox.sizePolicy().hasHeightForWidth())
        self.angleStepHKLrotSpinBox.setSizePolicy(sizePolicy11)
        self.angleStepHKLrotSpinBox.setWrapping(True)
        self.angleStepHKLrotSpinBox.setDecimals(1)
        self.angleStepHKLrotSpinBox.setMinimum(0.000000000000000)
        self.angleStepHKLrotSpinBox.setMaximum(60.000000000000000)
        self.angleStepHKLrotSpinBox.setSingleStep(0.500000000000000)
        self.angleStepHKLrotSpinBox.setValue(1.000000000000000)

        self.gridLayout_22.addWidget(self.angleStepHKLrotSpinBox, 0, 1, 1, 1)

        self.groupBox_2 = QGroupBox(self.RotateGroupBox)
        self.groupBox_2.setObjectName(u"groupBox_2")
        self.groupBox_2.setAlignment(Qt.AlignCenter)
        self.gridLayout_16 = QGridLayout(self.groupBox_2)
        self.gridLayout_16.setSpacing(4)
        self.gridLayout_16.setContentsMargins(3, 3, 3, 3)
        self.gridLayout_16.setObjectName(u"gridLayout_16")
        self.xHKLrotBtn = QPushButton(self.groupBox_2)
        self.xHKLrotBtn.setObjectName(u"xHKLrotBtn")
        sizePolicy5.setHeightForWidth(self.xHKLrotBtn.sizePolicy().hasHeightForWidth())
        self.xHKLrotBtn.setSizePolicy(sizePolicy5)
        icon = QIcon()
        icon.addFile(u"roundarrow2.png", QSize(), QIcon.Normal, QIcon.Off)
        self.xHKLrotBtn.setIcon(icon)
        self.xHKLrotBtn.setFlat(False)

        self.gridLayout_16.addWidget(self.xHKLrotBtn, 0, 0, 1, 1)

        self.xHKLbackrotBtn = QPushButton(self.groupBox_2)
        self.xHKLbackrotBtn.setObjectName(u"xHKLbackrotBtn")
        sizePolicy5.setHeightForWidth(self.xHKLbackrotBtn.sizePolicy().hasHeightForWidth())
        self.xHKLbackrotBtn.setSizePolicy(sizePolicy5)
        icon1 = QIcon()
        icon1.addFile(u"roundarrow.png", QSize(), QIcon.Normal, QIcon.Off)
        self.xHKLbackrotBtn.setIcon(icon1)
        self.xHKLbackrotBtn.setFlat(False)

        self.gridLayout_16.addWidget(self.xHKLbackrotBtn, 0, 1, 1, 1)


        self.gridLayout_22.addWidget(self.groupBox_2, 1, 0, 1, 1)

        self.groupBox_4 = QGroupBox(self.RotateGroupBox)
        self.groupBox_4.setObjectName(u"groupBox_4")
        self.groupBox_4.setAlignment(Qt.AlignCenter)
        self.gridLayout_19 = QGridLayout(self.groupBox_4)
        self.gridLayout_19.setSpacing(4)
        self.gridLayout_19.setContentsMargins(3, 3, 3, 3)
        self.gridLayout_19.setObjectName(u"gridLayout_19")
        self.yHKLrotBtn = QPushButton(self.groupBox_4)
        self.yHKLrotBtn.setObjectName(u"yHKLrotBtn")
        sizePolicy5.setHeightForWidth(self.yHKLrotBtn.sizePolicy().hasHeightForWidth())
        self.yHKLrotBtn.setSizePolicy(sizePolicy5)
        self.yHKLrotBtn.setIcon(icon)

        self.gridLayout_19.addWidget(self.yHKLrotBtn, 0, 0, 1, 1)

        self.yHKLbackrotBtn = QPushButton(self.groupBox_4)
        self.yHKLbackrotBtn.setObjectName(u"yHKLbackrotBtn")
        sizePolicy5.setHeightForWidth(self.yHKLbackrotBtn.sizePolicy().hasHeightForWidth())
        self.yHKLbackrotBtn.setSizePolicy(sizePolicy5)
        self.yHKLbackrotBtn.setIcon(icon1)

        self.gridLayout_19.addWidget(self.yHKLbackrotBtn, 0, 1, 1, 1)


        self.gridLayout_22.addWidget(self.groupBox_4, 1, 1, 1, 1)

        self.groupBox_6 = QGroupBox(self.RotateGroupBox)
        self.groupBox_6.setObjectName(u"groupBox_6")
        self.groupBox_6.setAlignment(Qt.AlignCenter)
        self.gridLayout_21 = QGridLayout(self.groupBox_6)
        self.gridLayout_21.setSpacing(4)
        self.gridLayout_21.setContentsMargins(3, 3, 3, 3)
        self.gridLayout_21.setObjectName(u"gridLayout_21")
        self.zHKLrotBtn = QPushButton(self.groupBox_6)
        self.zHKLrotBtn.setObjectName(u"zHKLrotBtn")
        sizePolicy5.setHeightForWidth(self.zHKLrotBtn.sizePolicy().hasHeightForWidth())
        self.zHKLrotBtn.setSizePolicy(sizePolicy5)
        self.zHKLrotBtn.setIcon(icon)

        self.gridLayout_21.addWidget(self.zHKLrotBtn, 0, 0, 1, 1)

        self.zHKLbackrotBtn = QPushButton(self.groupBox_6)
        self.zHKLbackrotBtn.setObjectName(u"zHKLbackrotBtn")
        sizePolicy5.setHeightForWidth(self.zHKLbackrotBtn.sizePolicy().hasHeightForWidth())
        self.zHKLbackrotBtn.setSizePolicy(sizePolicy5)
        self.zHKLbackrotBtn.setIcon(icon1)

        self.gridLayout_21.addWidget(self.zHKLbackrotBtn, 0, 1, 1, 1)


        self.gridLayout_22.addWidget(self.groupBox_6, 1, 2, 1, 1)


        self.gridLayout_7.addWidget(self.RotateGroupBox, 1, 0, 1, 1)

        self.functionTabWidget.addTab(self.slicing_tab, "")
        self.sizing_tab = QWidget()
        self.sizing_tab.setObjectName(u"sizing_tab")
        self.gridLayout_27 = QGridLayout(self.sizing_tab)
        self.gridLayout_27.setSpacing(4)
        self.gridLayout_27.setContentsMargins(3, 3, 3, 3)
        self.gridLayout_27.setObjectName(u"gridLayout_27")
        self.groupBox_3 = QGroupBox(self.sizing_tab)
        self.groupBox_3.setObjectName(u"groupBox_3")
        sizePolicy.setHeightForWidth(self.groupBox_3.sizePolicy().hasHeightForWidth())
        self.groupBox_3.setSizePolicy(sizePolicy)
        self.groupBox_3.setCheckable(False)
        self.gridLayout_10 = QGridLayout(self.groupBox_3)
        self.gridLayout_10.setSpacing(4)
        self.gridLayout_10.setContentsMargins(3, 3, 3, 3)
        self.gridLayout_10.setObjectName(u"gridLayout_10")
        self.power_scale_spinBox = MyQDoubleSpinBox(self.groupBox_3)
        self.power_scale_spinBox.setObjectName(u"power_scale_spinBox")
        sizePolicy12 = QSizePolicy(QSizePolicy.Preferred, QSizePolicy.Maximum)
        sizePolicy12.setHorizontalStretch(0)
        sizePolicy12.setVerticalStretch(0)
        sizePolicy12.setHeightForWidth(self.power_scale_spinBox.sizePolicy().hasHeightForWidth())
        self.power_scale_spinBox.setSizePolicy(sizePolicy12)
        self.power_scale_spinBox.setMinimum(-10.000000000000000)
        self.power_scale_spinBox.setMaximum(10.000000000000000)
        self.power_scale_spinBox.setSingleStep(0.050000000000000)
        self.power_scale_spinBox.setValue(0.500000000000000)

        self.gridLayout_10.addWidget(self.power_scale_spinBox, 1, 4, 1, 1)

        self.radii_scale_spinBox = MyQDoubleSpinBox(self.groupBox_3)
        self.radii_scale_spinBox.setObjectName(u"radii_scale_spinBox")
        sizePolicy12.setHeightForWidth(self.radii_scale_spinBox.sizePolicy().hasHeightForWidth())
        self.radii_scale_spinBox.setSizePolicy(sizePolicy12)
        self.radii_scale_spinBox.setDecimals(2)
        self.radii_scale_spinBox.setMinimum(0.000000000000000)
        self.radii_scale_spinBox.setMaximum(1000.000000000000000)
        self.radii_scale_spinBox.setSingleStep(0.200000000000000)
        self.radii_scale_spinBox.setValue(1.000000000000000)

        self.gridLayout_10.addWidget(self.radii_scale_spinBox, 2, 1, 1, 1)

        self.label_7 = QLabel(self.groupBox_3)
        self.label_7.setObjectName(u"label_7")
        sizePolicy.setHeightForWidth(self.label_7.sizePolicy().hasHeightForWidth())
        self.label_7.setSizePolicy(sizePolicy)
        self.label_7.setTextFormat(Qt.RichText)
        self.label_7.setScaledContents(False)
        self.label_7.setAlignment(Qt.AlignLeading|Qt.AlignLeft|Qt.AlignVCenter)
        self.label_7.setWordWrap(True)

        self.gridLayout_10.addWidget(self.label_7, 0, 0, 1, 5)

        self.label_11 = QLabel(self.groupBox_3)
        self.label_11.setObjectName(u"label_11")
        sizePolicy12.setHeightForWidth(self.label_11.sizePolicy().hasHeightForWidth())
        self.label_11.setSizePolicy(sizePolicy12)

        self.gridLayout_10.addWidget(self.label_11, 2, 0, 1, 1)

        self.ManualPowerScalecheckbox = QCheckBox(self.groupBox_3)
        self.ManualPowerScalecheckbox.setObjectName(u"ManualPowerScalecheckbox")
        sizePolicy13 = QSizePolicy(QSizePolicy.Maximum, QSizePolicy.Maximum)
        sizePolicy13.setHorizontalStretch(0)
        sizePolicy13.setVerticalStretch(0)
        sizePolicy13.setHeightForWidth(self.ManualPowerScalecheckbox.sizePolicy().hasHeightForWidth())
        self.ManualPowerScalecheckbox.setSizePolicy(sizePolicy13)

        self.gridLayout_10.addWidget(self.ManualPowerScalecheckbox, 1, 0, 1, 2)

        self.label_10 = QLabel(self.groupBox_3)
        self.label_10.setObjectName(u"label_10")
        sizePolicy13.setHeightForWidth(self.label_10.sizePolicy().hasHeightForWidth())
        self.label_10.setSizePolicy(sizePolicy13)
        self.label_10.setAlignment(Qt.AlignRight|Qt.AlignTrailing|Qt.AlignVCenter)
        self.label_10.setWordWrap(False)
        self.label_10.setIndent(1)

        self.gridLayout_10.addWidget(self.label_10, 1, 3, 1, 1)


        self.gridLayout_27.addWidget(self.groupBox_3, 0, 0, 1, 1, Qt.AlignTop)

        self.functionTabWidget.addTab(self.sizing_tab, "")
        self.bining_tab = QWidget()
        self.bining_tab.setObjectName(u"bining_tab")
        self.gridLayout_13 = QGridLayout(self.bining_tab)
        self.gridLayout_13.setSpacing(4)
        self.gridLayout_13.setContentsMargins(3, 3, 3, 3)
        self.gridLayout_13.setObjectName(u"gridLayout_13")
        self.widget_6 = QWidget(self.bining_tab)
        self.widget_6.setObjectName(u"widget_6")
        sizePolicy3.setHeightForWidth(self.widget_6.sizePolicy().hasHeightForWidth())
        self.widget_6.setSizePolicy(sizePolicy3)
        self.gridLayout_12 = QGridLayout(self.widget_6)
        self.gridLayout_12.setSpacing(4)
        self.gridLayout_12.setContentsMargins(3, 3, 3, 3)
        self.gridLayout_12.setObjectName(u"gridLayout_12")
        self.gridLayout_12.setContentsMargins(3, 3, 3, 3)
        self.addDatasetBtn = QPushButton(self.widget_6)
        self.addDatasetBtn.setObjectName(u"addDatasetBtn")
        sizePolicy11.setHeightForWidth(self.addDatasetBtn.sizePolicy().hasHeightForWidth())
        self.addDatasetBtn.setSizePolicy(sizePolicy11)
        self.addDatasetBtn.setMinimumSize(QSize(200, 0))

        self.gridLayout_12.addWidget(self.addDatasetBtn, 1, 1, 1, 1)

        self.OpaqueAllCheckbox = QCheckBox(self.widget_6)
        self.OpaqueAllCheckbox.setObjectName(u"OpaqueAllCheckbox")
        sizePolicy5.setHeightForWidth(self.OpaqueAllCheckbox.sizePolicy().hasHeightForWidth())
        self.OpaqueAllCheckbox.setSizePolicy(sizePolicy5)

        self.gridLayout_12.addWidget(self.OpaqueAllCheckbox, 1, 0, 1, 1)

        self.binstable = HeaderDataTableWidget(self.widget_6)
        if (self.binstable.columnCount() < 4):
            self.binstable.setColumnCount(4)
        if (self.binstable.rowCount() < 5):
            self.binstable.setRowCount(5)
        self.binstable.setObjectName(u"binstable")
        sizePolicy14 = QSizePolicy(QSizePolicy.Preferred, QSizePolicy.Expanding)
        sizePolicy14.setHorizontalStretch(0)
        sizePolicy14.setVerticalStretch(1)
        sizePolicy14.setHeightForWidth(self.binstable.sizePolicy().hasHeightForWidth())
        self.binstable.setSizePolicy(sizePolicy14)
        self.binstable.setMinimumSize(QSize(0, 0))
        self.binstable.setSizeAdjustPolicy(QAbstractScrollArea.AdjustIgnored)
        self.binstable.setVerticalScrollMode(QAbstractItemView.ScrollPerPixel)
        self.binstable.setHorizontalScrollMode(QAbstractItemView.ScrollPerPixel)
        self.binstable.setRowCount(5)
        self.binstable.setColumnCount(4)
        self.binstable.horizontalHeader().setCascadingSectionResizes(False)
        self.binstable.horizontalHeader().setDefaultSectionSize(80)
        self.binstable.horizontalHeader().setStretchLastSection(False)
        self.binstable.verticalHeader().setMinimumSectionSize(10)
        self.binstable.verticalHeader().setDefaultSectionSize(24)
        self.binstable.verticalHeader().setHighlightSections(True)

        self.gridLayout_12.addWidget(self.binstable, 2, 0, 1, 2)


        self.gridLayout_13.addWidget(self.widget_6, 1, 0, 1, 1)

        self.groupBox_5 = QGroupBox(self.bining_tab)
        self.groupBox_5.setObjectName(u"groupBox_5")
        sizePolicy5.setHeightForWidth(self.groupBox_5.sizePolicy().hasHeightForWidth())
        self.groupBox_5.setSizePolicy(sizePolicy5)
        self.gridLayout_11 = QGridLayout(self.groupBox_5)
        self.gridLayout_11.setSpacing(4)
        self.gridLayout_11.setContentsMargins(3, 3, 3, 3)
        self.gridLayout_11.setObjectName(u"gridLayout_11")
        self.label_12 = QLabel(self.groupBox_5)
        self.label_12.setObjectName(u"label_12")

        self.gridLayout_11.addWidget(self.label_12, 0, 1, 1, 1)

        self.Nbins_spinBox = QSpinBox(self.groupBox_5)
        self.Nbins_spinBox.setObjectName(u"Nbins_spinBox")
        sizePolicy.setHeightForWidth(self.Nbins_spinBox.sizePolicy().hasHeightForWidth())
        self.Nbins_spinBox.setSizePolicy(sizePolicy)
        self.Nbins_spinBox.setMinimum(1)
        self.Nbins_spinBox.setMaximum(20)

        self.gridLayout_11.addWidget(self.Nbins_spinBox, 0, 2, 1, 1)

        self.BinDataComboBox = QComboBox(self.groupBox_5)
        self.BinDataComboBox.setObjectName(u"BinDataComboBox")
        sizePolicy8.setHeightForWidth(self.BinDataComboBox.sizePolicy().hasHeightForWidth())
        self.BinDataComboBox.setSizePolicy(sizePolicy8)

        self.gridLayout_11.addWidget(self.BinDataComboBox, 0, 0, 1, 1)


        self.gridLayout_13.addWidget(self.groupBox_5, 0, 0, 1, 1)

        self.functionTabWidget.addTab(self.bining_tab, "")
        self.vectors_tab = QWidget()
        self.vectors_tab.setObjectName(u"vectors_tab")
        self.gridLayout_14 = QGridLayout(self.vectors_tab)
        self.gridLayout_14.setSpacing(4)
        self.gridLayout_14.setContentsMargins(3, 3, 3, 3)
        self.gridLayout_14.setObjectName(u"gridLayout_14")
        self.ReciprocUnitCellgrp = QGroupBox(self.vectors_tab)
        self.ReciprocUnitCellgrp.setObjectName(u"ReciprocUnitCellgrp")
        self.ReciprocUnitCellgrp.setCheckable(False)
        self.ReciprocUnitCellgrp.setChecked(False)
        self.gridLayout_15 = QGridLayout(self.ReciprocUnitCellgrp)
        self.gridLayout_15.setSpacing(4)
        self.gridLayout_15.setContentsMargins(3, 3, 3, 3)
        self.gridLayout_15.setObjectName(u"gridLayout_15")
        self.gridLayout_15.setContentsMargins(-1, 3, -1, 3)
        self.label_2 = QLabel(self.ReciprocUnitCellgrp)
        self.label_2.setObjectName(u"label_2")
        sizePolicy.setHeightForWidth(self.label_2.sizePolicy().hasHeightForWidth())
        self.label_2.setSizePolicy(sizePolicy)
        self.label_2.setAlignment(Qt.AlignRight|Qt.AlignTrailing|Qt.AlignVCenter)
        self.label_2.setWordWrap(True)

        self.gridLayout_15.addWidget(self.label_2, 1, 0, 1, 1)

        self.reciprocunitcellslider = QSlider(self.ReciprocUnitCellgrp)
        self.reciprocunitcellslider.setObjectName(u"reciprocunitcellslider")
        sizePolicy5.setHeightForWidth(self.reciprocunitcellslider.sizePolicy().hasHeightForWidth())
        self.reciprocunitcellslider.setSizePolicy(sizePolicy5)
        self.reciprocunitcellslider.setMinimum(0)
        self.reciprocunitcellslider.setMaximum(100)
        self.reciprocunitcellslider.setOrientation(Qt.Horizontal)

        self.gridLayout_15.addWidget(self.reciprocunitcellslider, 1, 1, 1, 1)

        self.label_4 = QLabel(self.ReciprocUnitCellgrp)
        self.label_4.setObjectName(u"label_4")
        self.label_4.setWordWrap(True)

        self.gridLayout_15.addWidget(self.label_4, 0, 2, 2, 1)

        self.DrawReciprocUnitCellBox = QCheckBox(self.ReciprocUnitCellgrp)
        self.DrawReciprocUnitCellBox.setObjectName(u"DrawReciprocUnitCellBox")
        sizePolicy5.setHeightForWidth(self.DrawReciprocUnitCellBox.sizePolicy().hasHeightForWidth())
        self.DrawReciprocUnitCellBox.setSizePolicy(sizePolicy5)

        self.gridLayout_15.addWidget(self.DrawReciprocUnitCellBox, 0, 0, 1, 1)


        self.gridLayout_14.addWidget(self.ReciprocUnitCellgrp, 1, 0, 1, 1)

        self.RotationVectorsBox = QGroupBox(self.vectors_tab)
        self.RotationVectorsBox.setObjectName(u"RotationVectorsBox")
        sizePolicy.setHeightForWidth(self.RotationVectorsBox.sizePolicy().hasHeightForWidth())
        self.RotationVectorsBox.setSizePolicy(sizePolicy)
        self.RotationVectorsBox.setMaximumSize(QSize(16777215, 16777215))
        self.RotationVectorsBox.setCheckable(False)
        self.gridLayout_8 = QGridLayout(self.RotationVectorsBox)
        self.gridLayout_8.setSpacing(4)
        self.gridLayout_8.setContentsMargins(3, 3, 3, 3)
        self.gridLayout_8.setObjectName(u"gridLayout_8")
        self.gridLayout_8.setContentsMargins(3, 3, 3, 3)
        self.ShowAllVectorsBtn = QCheckBox(self.RotationVectorsBox)
        self.ShowAllVectorsBtn.setObjectName(u"ShowAllVectorsBtn")
        sizePolicy5.setHeightForWidth(self.ShowAllVectorsBtn.sizePolicy().hasHeightForWidth())
        self.ShowAllVectorsBtn.setSizePolicy(sizePolicy5)
        self.ShowAllVectorsBtn.setTristate(True)

        self.gridLayout_8.addWidget(self.ShowAllVectorsBtn, 0, 0, 1, 1)

        self.RotateAroundframe = QFrame(self.RotationVectorsBox)
        self.RotateAroundframe.setObjectName(u"RotateAroundframe")
        sizePolicy15 = QSizePolicy(QSizePolicy.Preferred, QSizePolicy.Preferred)
        sizePolicy15.setHorizontalStretch(1)
        sizePolicy15.setVerticalStretch(1)
        sizePolicy15.setHeightForWidth(self.RotateAroundframe.sizePolicy().hasHeightForWidth())
        self.RotateAroundframe.setSizePolicy(sizePolicy15)
        self.RotateAroundframe.setFrameShape(QFrame.StyledPanel)
        self.RotateAroundframe.setFrameShadow(QFrame.Raised)
        self.gridLayout_18 = QGridLayout(self.RotateAroundframe)
        self.gridLayout_18.setSpacing(4)
        self.gridLayout_18.setContentsMargins(3, 3, 3, 3)
        self.gridLayout_18.setObjectName(u"gridLayout_18")
        self.rotavecangle_labeltxt = QLabel(self.RotateAroundframe)
        self.rotavecangle_labeltxt.setObjectName(u"rotavecangle_labeltxt")
        sizePolicy16 = QSizePolicy(QSizePolicy.Preferred, QSizePolicy.Minimum)
        sizePolicy16.setHorizontalStretch(0)
        sizePolicy16.setVerticalStretch(0)
        sizePolicy16.setHeightForWidth(self.rotavecangle_labeltxt.sizePolicy().hasHeightForWidth())
        self.rotavecangle_labeltxt.setSizePolicy(sizePolicy16)
        self.rotavecangle_labeltxt.setMinimumSize(QSize(120, 0))
        self.rotavecangle_labeltxt.setWordWrap(True)

        self.gridLayout_18.addWidget(self.rotavecangle_labeltxt, 0, 0, 1, 2)

        self.rotavecangle_slider = QSlider(self.RotateAroundframe)
        self.rotavecangle_slider.setObjectName(u"rotavecangle_slider")
        sizePolicy17 = QSizePolicy(QSizePolicy.Preferred, QSizePolicy.MinimumExpanding)
        sizePolicy17.setHorizontalStretch(0)
        sizePolicy17.setVerticalStretch(0)
        sizePolicy17.setHeightForWidth(self.rotavecangle_slider.sizePolicy().hasHeightForWidth())
        self.rotavecangle_slider.setSizePolicy(sizePolicy17)
        self.rotavecangle_slider.setMinimumSize(QSize(120, 0))
        self.rotavecangle_slider.setMaximum(720)
        self.rotavecangle_slider.setPageStep(20)
        self.rotavecangle_slider.setOrientation(Qt.Horizontal)
        self.rotavecangle_slider.setTickPosition(QSlider.TicksAbove)
        self.rotavecangle_slider.setTickInterval(30)

        self.gridLayout_18.addWidget(self.rotavecangle_slider, 1, 0, 1, 2)

        self.AlignVectorGroupBox = QGroupBox(self.RotateAroundframe)
        self.AlignVectorGroupBox.setObjectName(u"AlignVectorGroupBox")
        self.AlignVectorGroupBox.setEnabled(True)
        sizePolicy16.setHeightForWidth(self.AlignVectorGroupBox.sizePolicy().hasHeightForWidth())
        self.AlignVectorGroupBox.setSizePolicy(sizePolicy16)
        self.AlignVectorGroupBox.setCheckable(True)
        self.AlignVectorGroupBox.setChecked(False)
        self.gridLayout_17 = QGridLayout(self.AlignVectorGroupBox)
        self.gridLayout_17.setSpacing(4)
        self.gridLayout_17.setContentsMargins(3, 3, 3, 3)
        self.gridLayout_17.setObjectName(u"gridLayout_17")
        self.gridLayout_17.setContentsMargins(3, 3, 3, 3)
        self.AlignParallelBtn = QRadioButton(self.AlignVectorGroupBox)
        self.AlignParallelBtn.setObjectName(u"AlignParallelBtn")
        sizePolicy5.setHeightForWidth(self.AlignParallelBtn.sizePolicy().hasHeightForWidth())
        self.AlignParallelBtn.setSizePolicy(sizePolicy5)

        self.gridLayout_17.addWidget(self.AlignParallelBtn, 0, 0, 1, 1)

        self.AlignNormalBtn = QRadioButton(self.AlignVectorGroupBox)
        self.AlignNormalBtn.setObjectName(u"AlignNormalBtn")
        sizePolicy5.setHeightForWidth(self.AlignNormalBtn.sizePolicy().hasHeightForWidth())
        self.AlignNormalBtn.setSizePolicy(sizePolicy5)
        self.AlignNormalBtn.setChecked(True)

        self.gridLayout_17.addWidget(self.AlignNormalBtn, 1, 0, 1, 1)


        self.gridLayout_18.addWidget(self.AlignVectorGroupBox, 2, 0, 1, 2)

        self.AnimaRotCheckBox = QCheckBox(self.RotateAroundframe)
        self.AnimaRotCheckBox.setObjectName(u"AnimaRotCheckBox")
        sizePolicy17.setHeightForWidth(self.AnimaRotCheckBox.sizePolicy().hasHeightForWidth())
        self.AnimaRotCheckBox.setSizePolicy(sizePolicy17)

        self.gridLayout_18.addWidget(self.AnimaRotCheckBox, 3, 0, 1, 2)

        self.label_8 = QLabel(self.RotateAroundframe)
        self.label_8.setObjectName(u"label_8")

        self.gridLayout_18.addWidget(self.label_8, 4, 0, 1, 1)

        self.AnimateSpeedSlider = QSlider(self.RotateAroundframe)
        self.AnimateSpeedSlider.setObjectName(u"AnimateSpeedSlider")
        sizePolicy5.setHeightForWidth(self.AnimateSpeedSlider.sizePolicy().hasHeightForWidth())
        self.AnimateSpeedSlider.setSizePolicy(sizePolicy5)
        self.AnimateSpeedSlider.setMinimum(1)
        self.AnimateSpeedSlider.setMaximum(20)
        self.AnimateSpeedSlider.setPageStep(1)
        self.AnimateSpeedSlider.setValue(5)
        self.AnimateSpeedSlider.setSliderPosition(5)
        self.AnimateSpeedSlider.setOrientation(Qt.Horizontal)
        self.AnimateSpeedSlider.setTickPosition(QSlider.TicksAbove)
        self.AnimateSpeedSlider.setTickInterval(1)

        self.gridLayout_18.addWidget(self.AnimateSpeedSlider, 4, 1, 1, 1)


        self.gridLayout_8.addWidget(self.RotateAroundframe, 0, 1, 2, 1)

        self.vectortable2 = QTableWidget(self.RotationVectorsBox)
        if (self.vectortable2.columnCount() < 4):
            self.vectortable2.setColumnCount(4)
        if (self.vectortable2.rowCount() < 5):
            self.vectortable2.setRowCount(5)
        self.vectortable2.setObjectName(u"vectortable2")
        sizePolicy18 = QSizePolicy(QSizePolicy.Preferred, QSizePolicy.Expanding)
        sizePolicy18.setHorizontalStretch(3)
        sizePolicy18.setVerticalStretch(1)
        sizePolicy18.setHeightForWidth(self.vectortable2.sizePolicy().hasHeightForWidth())
        self.vectortable2.setSizePolicy(sizePolicy18)
        self.vectortable2.setVerticalScrollBarPolicy(Qt.ScrollBarAsNeeded)
        self.vectortable2.setSizeAdjustPolicy(QAbstractScrollArea.AdjustIgnored)
        self.vectortable2.setDragEnabled(False)
        self.vectortable2.setVerticalScrollMode(QAbstractItemView.ScrollPerPixel)
        self.vectortable2.setHorizontalScrollMode(QAbstractItemView.ScrollPerPixel)
        self.vectortable2.setWordWrap(True)
        self.vectortable2.setRowCount(5)
        self.vectortable2.setColumnCount(4)
        self.vectortable2.horizontalHeader().setCascadingSectionResizes(False)
        self.vectortable2.horizontalHeader().setDefaultSectionSize(50)
        self.vectortable2.verticalHeader().setVisible(False)
        self.vectortable2.verticalHeader().setMinimumSectionSize(10)
        self.vectortable2.verticalHeader().setDefaultSectionSize(24)

        self.gridLayout_8.addWidget(self.vectortable2, 1, 0, 1, 1)


        self.gridLayout_14.addWidget(self.RotationVectorsBox, 0, 0, 1, 1)

        self.RealUnitCellBoxgrp = QGroupBox(self.vectors_tab)
        self.RealUnitCellBoxgrp.setObjectName(u"RealUnitCellBoxgrp")
        sizePolicy.setHeightForWidth(self.RealUnitCellBoxgrp.sizePolicy().hasHeightForWidth())
        self.RealUnitCellBoxgrp.setSizePolicy(sizePolicy)
        self.RealUnitCellBoxgrp.setCheckable(False)
        self.RealUnitCellBoxgrp.setChecked(False)
        self.gridLayout_26 = QGridLayout(self.RealUnitCellBoxgrp)
        self.gridLayout_26.setSpacing(4)
        self.gridLayout_26.setContentsMargins(3, 3, 3, 3)
        self.gridLayout_26.setObjectName(u"gridLayout_26")
        self.gridLayout_26.setContentsMargins(-1, 3, -1, 3)
        self.label_6 = QLabel(self.RealUnitCellBoxgrp)
        self.label_6.setObjectName(u"label_6")
        sizePolicy.setHeightForWidth(self.label_6.sizePolicy().hasHeightForWidth())
        self.label_6.setSizePolicy(sizePolicy)
        self.label_6.setAlignment(Qt.AlignRight|Qt.AlignTrailing|Qt.AlignVCenter)
        self.label_6.setWordWrap(True)

        self.gridLayout_26.addWidget(self.label_6, 1, 0, 1, 1)

        self.unitcellslider = QSlider(self.RealUnitCellBoxgrp)
        self.unitcellslider.setObjectName(u"unitcellslider")
        sizePolicy5.setHeightForWidth(self.unitcellslider.sizePolicy().hasHeightForWidth())
        self.unitcellslider.setSizePolicy(sizePolicy5)
        self.unitcellslider.setMinimum(0)
        self.unitcellslider.setMaximum(100)
        self.unitcellslider.setOrientation(Qt.Horizontal)

        self.gridLayout_26.addWidget(self.unitcellslider, 1, 1, 1, 1)

        self.DrawRealUnitCellBox = QCheckBox(self.RealUnitCellBoxgrp)
        self.DrawRealUnitCellBox.setObjectName(u"DrawRealUnitCellBox")
        sizePolicy5.setHeightForWidth(self.DrawRealUnitCellBox.sizePolicy().hasHeightForWidth())
        self.DrawRealUnitCellBox.setSizePolicy(sizePolicy5)

        self.gridLayout_26.addWidget(self.DrawRealUnitCellBox, 0, 0, 1, 1)

        self.label_5 = QLabel(self.RealUnitCellBoxgrp)
        self.label_5.setObjectName(u"label_5")
        sizePolicy.setHeightForWidth(self.label_5.sizePolicy().hasHeightForWidth())
        self.label_5.setSizePolicy(sizePolicy)
        self.label_5.setWordWrap(True)

        self.gridLayout_26.addWidget(self.label_5, 0, 2, 2, 1)


        self.gridLayout_14.addWidget(self.RealUnitCellBoxgrp, 2, 0, 1, 1)

        self.functionTabWidget.addTab(self.vectors_tab, "")

        self.gridLayout_4.addWidget(self.functionTabWidget, 1, 0, 1, 1)

        self.scrollArea.setWidget(self.scrollAreaWidgetContents)
        self.splitter.addWidget(self.scrollArea)

        self.gridLayout_23.addWidget(self.splitter, 0, 0, 1, 1)

        self.tabWidget.addTab(self.tabDetails, "")
        self.splitter_2.addWidget(self.tabWidget)

        self.gridLayout_31.addWidget(self.splitter_2, 0, 0, 1, 1)


        self.gridLayout_9.addWidget(self.widget_2, 0, 0, 1, 1)

        self.ControlsWidget.setWidget(self.dockControls)
        MainWindow.addDockWidget(Qt.LeftDockWidgetArea, self.ControlsWidget)
        self.InfoWidget = QDockWidget(MainWindow)
        self.InfoWidget.setObjectName(u"InfoWidget")
        self.InfoWidget.setFeatures(QDockWidget.DockWidgetFloatable|QDockWidget.DockWidgetMovable)
        self.dockWidgetContents = QWidget()
        self.dockWidgetContents.setObjectName(u"dockWidgetContents")
        self.gridLayout_33 = QGridLayout(self.dockWidgetContents)
        self.gridLayout_33.setSpacing(0)
        self.gridLayout_33.setContentsMargins(3, 3, 3, 3)
        self.gridLayout_33.setObjectName(u"gridLayout_33")
        self.gridLayout_33.setContentsMargins(0, 0, 0, 0)
        self.tabText = QTabWidget(self.dockWidgetContents)
        self.tabText.setObjectName(u"tabText")
        sizePolicy.setHeightForWidth(self.tabText.sizePolicy().hasHeightForWidth())
        self.tabText.setSizePolicy(sizePolicy)
        self.tabInfo = QWidget()
        self.tabInfo.setObjectName(u"tabInfo")
        self.gridLayout_30 = QGridLayout(self.tabInfo)
        self.gridLayout_30.setSpacing(4)
        self.gridLayout_30.setContentsMargins(3, 3, 3, 3)
        self.gridLayout_30.setObjectName(u"gridLayout_30")
        self.gridLayout_30.setContentsMargins(0, 0, 0, 0)
        self.textInfo = MyQPlainTextEdit(self.tabInfo)
        self.textInfo.setObjectName(u"textInfo")
        sizePolicy3.setHeightForWidth(self.textInfo.sizePolicy().hasHeightForWidth())
        self.textInfo.setSizePolicy(sizePolicy3)
        font1 = QFont()
        font1.setFamily(u"Courier New")
        font1.setPointSize(9)
        self.textInfo.setFont(font1)
        self.textInfo.setVerticalScrollBarPolicy(Qt.ScrollBarAlwaysOn)
        self.textInfo.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOn)
        self.textInfo.setSizeAdjustPolicy(QAbstractScrollArea.AdjustToContents)
        self.textInfo.setLineWrapMode(QPlainTextEdit.NoWrap)
        self.textInfo.setReadOnly(True)

        self.gridLayout_30.addWidget(self.textInfo, 0, 0, 1, 1)

        self.tabText.addTab(self.tabInfo, "")
        self.tabWarnings = QWidget()
        self.tabWarnings.setObjectName(u"tabWarnings")
        self.gridLayout = QGridLayout(self.tabWarnings)
        self.gridLayout.setSpacing(4)
        self.gridLayout.setContentsMargins(3, 3, 3, 3)
        self.gridLayout.setObjectName(u"gridLayout")
        self.gridLayout.setContentsMargins(0, 0, 0, 0)
        self.textAlerts = MyQPlainTextEdit(self.tabWarnings)
        self.textAlerts.setObjectName(u"textAlerts")
        sizePolicy3.setHeightForWidth(self.textAlerts.sizePolicy().hasHeightForWidth())
        self.textAlerts.setSizePolicy(sizePolicy3)
        font2 = QFont()
        font2.setFamily(u"Courier New")
        font2.setPointSize(9)
        font2.setBold(True)
        font2.setWeight(75)
        self.textAlerts.setFont(font2)
        self.textAlerts.setVerticalScrollBarPolicy(Qt.ScrollBarAlwaysOn)
        self.textAlerts.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOn)
        self.textAlerts.setSizeAdjustPolicy(QAbstractScrollArea.AdjustToContents)
        self.textAlerts.setLineWrapMode(QPlainTextEdit.NoWrap)
        self.textAlerts.setReadOnly(True)
        self.textAlerts.setTextInteractionFlags(Qt.TextSelectableByMouse)

        self.gridLayout.addWidget(self.textAlerts, 0, 0, 1, 1)

        self.tabText.addTab(self.tabWarnings, "")

        self.gridLayout_33.addWidget(self.tabText, 0, 0, 1, 1)

        self.InfoWidget.setWidget(self.dockWidgetContents)
        MainWindow.addDockWidget(Qt.LeftDockWidgetArea, self.InfoWidget)

        self.retranslateUi(MainWindow)

        self.tabWidget.setCurrentIndex(0)
        self.functionTabWidget.setCurrentIndex(0)
        self.xHKLrotBtn.setDefault(False)
        self.xHKLbackrotBtn.setDefault(False)
        self.tabText.setCurrentIndex(0)


        QMetaObject.connectSlotsByName(MainWindow)
    # setupUi

    def retranslateUi(self, MainWindow):
        MainWindow.setWindowTitle(QCoreApplication.translate("MainWindow", u"MainWindow", None))
        self.actionOpen_reflection_file.setText(QCoreApplication.translate("MainWindow", u"Open reflection file...", None))
        self.actionSettings.setText(QCoreApplication.translate("MainWindow", u"Settings", None))
#if QT_CONFIG(tooltip)
        self.actionSettings.setToolTip(QCoreApplication.translate("MainWindow", u"change mouse speed, font size etc.", None))
#endif // QT_CONFIG(tooltip)
        self.actiondebug.setText(QCoreApplication.translate("MainWindow", u"Debug", None))
        self.actionExit.setText(QCoreApplication.translate("MainWindow", u"Exit", None))
        self.actionSave_reflection_file.setText(QCoreApplication.translate("MainWindow", u"Save highlighted datasets as a reflection file...", None))
        self.actionReset_View.setText(QCoreApplication.translate("MainWindow", u"Reset View", None))
        self.actionSave_Current_Image.setText(QCoreApplication.translate("MainWindow", u"Save Current Image...", None))
        self.actionCCTBXwebsite.setText(QCoreApplication.translate("MainWindow", u"CCTBX Documentation", None))
        self.actionLocal_Help.setText(QCoreApplication.translate("MainWindow", u"Documentation", None))
        self.actionAbout.setText(QCoreApplication.translate("MainWindow", u"About", None))
        self.actionColour_Gradient.setText(QCoreApplication.translate("MainWindow", u"Colour Gradient...", None))
        self.actionHKLviewer_Tutorial.setText(QCoreApplication.translate("MainWindow", u"Tutorial", None))
        self.actionBackground_Colour.setText(QCoreApplication.translate("MainWindow", u"Background Colour", None))
#if QT_CONFIG(tooltip)
        self.actionBackground_Colour.setToolTip(QCoreApplication.translate("MainWindow", u"change colour of the background", None))
#endif // QT_CONFIG(tooltip)
        self.actionNGLmousebindings.setText(QCoreApplication.translate("MainWindow", u"Mouse Bindings help", None))
        self.ControlsWidget.setWindowTitle(QCoreApplication.translate("MainWindow", u"HKLviewer Controls", None))
        self.XtricorderBtn.setText(QCoreApplication.translate("MainWindow", u"Run Xtricorder", None))
        self.XtriageBtn.setText(QCoreApplication.translate("MainWindow", u"Run Xtriage", None))
        self.tabWidget.setTabText(self.tabWidget.indexOf(self.tabPresetbuttons), QCoreApplication.translate("MainWindow", u"Quick View", None))
#if QT_CONFIG(tooltip)
        self.millertable.setToolTip(QCoreApplication.translate("MainWindow", u"Highlighted datasets can be saved into a single datafile", None))
#endif // QT_CONFIG(tooltip)
        self.label.setText(QCoreApplication.translate("MainWindow", u"Display a dataset with a double-click. Right-click table for more options.", None))
#if QT_CONFIG(tooltip)
        self.ExpandReflsGroupBox.setToolTip(QCoreApplication.translate("MainWindow", u"<html><head/><body><p>Quick expansion of reflections utilising GPU of the computer</p></body></html>", None))
#endif // QT_CONFIG(tooltip)
        self.ExpandReflsGroupBox.setTitle(QCoreApplication.translate("MainWindow", u"Expand reflections", None))
#if QT_CONFIG(tooltip)
        self.expandP1checkbox.setToolTip(QCoreApplication.translate("MainWindow", u"<html><head/><body><p>Expand reflections from their asymmetric wedge by replicating reflections from succesive rotations operations defined by the spacegroup. If the set of reflections is not symmetry unique some (h,k,l) indices may display more than one reflection.</p></body></html>", None))
#endif // QT_CONFIG(tooltip)
        self.expandP1checkbox.setText(QCoreApplication.translate("MainWindow", u"Expand to P1", None))
#if QT_CONFIG(tooltip)
        self.expandAnomalouscheckbox.setToolTip(QCoreApplication.translate("MainWindow", u"<html><head/><body><p>Expand reflections to include -h,-k,-l</p></body></html>", None))
#endif // QT_CONFIG(tooltip)
        self.expandAnomalouscheckbox.setText(QCoreApplication.translate("MainWindow", u"Show Friedel pairs", None))
        self.sysabsentcheckbox.setText(QCoreApplication.translate("MainWindow", u"Show Systematic Absences", None))
#if QT_CONFIG(tooltip)
        self.SpaceGroupComboBox.setToolTip(QCoreApplication.translate("MainWindow", u"<html><head/><body><p>Expand the currently displayed dataset to a lower symmetry. The expansion is not committed to the actual dataset.</p></body></html>", None))
#endif // QT_CONFIG(tooltip)
#if QT_CONFIG(tooltip)
        self.SpacegroupLabel.setToolTip(QCoreApplication.translate("MainWindow", u"<html><head/><body><p>Subgroups present in this space group</p></body></html>", None))
#endif // QT_CONFIG(tooltip)
        self.SpacegroupLabel.setText(QCoreApplication.translate("MainWindow", u"Space Subgroups", None))
        self.onlymissingcheckbox.setText(QCoreApplication.translate("MainWindow", u"Only", None))
#if QT_CONFIG(tooltip)
        self.missingcheckbox.setToolTip(QCoreApplication.translate("MainWindow", u"<html><head/><body><p>Show those reflections not recorded, assuming the set of reflections forms a sphere.</p></body></html>", None))
#endif // QT_CONFIG(tooltip)
        self.missingcheckbox.setText(QCoreApplication.translate("MainWindow", u"Show Missing Reflections", None))
#if QT_CONFIG(tooltip)
        self.commitSubgroupExpansionBtn.setToolTip(QCoreApplication.translate("MainWindow", u"<html><head/><body><p>Selected subgroup expansion is committed to all datasets in the reflection file. The file may then be saved as a new reflection file.</p></body></html>", None))
#endif // QT_CONFIG(tooltip)
        self.commitSubgroupExpansionBtn.setText(QCoreApplication.translate("MainWindow", u"Commit expansion...", None))
        self.functionTabWidget.setTabText(self.functionTabWidget.indexOf(self.expansion_tab), QCoreApplication.translate("MainWindow", u"Expansion", None))
#if QT_CONFIG(tooltip)
        self.ClipPlaneChkGroupBox.setToolTip(QCoreApplication.translate("MainWindow", u"<html><head/><body><p>Limit the view of reflections with a clip plane parallel to the screen</p></body></html>", None))
#endif // QT_CONFIG(tooltip)
        self.ClipPlaneChkGroupBox.setTitle(QCoreApplication.translate("MainWindow", u"Slice with a clip plane parallel to screen that:", None))
        self.parallel_current_orientation_btn.setText(QCoreApplication.translate("MainWindow", u"uses current orientation", None))
#if QT_CONFIG(tooltip)
        self.normal_vec_btn.setToolTip(QCoreApplication.translate("MainWindow", u"Useful for inspecting reflections perpendicular to a rotation axis or a tNCS vector", None))
#endif // QT_CONFIG(tooltip)
        self.normal_vec_btn.setText(QCoreApplication.translate("MainWindow", u"is normal to:", None))
#if QT_CONFIG(tooltip)
        self.normal_realspace_vec_btn.setToolTip(QCoreApplication.translate("MainWindow", u"Useful for inspecting reflections satisfying an equation for a plane through reciprocal space", None))
#endif // QT_CONFIG(tooltip)
        self.normal_realspace_vec_btn.setText("")
#if QT_CONFIG(tooltip)
        self.normal_realspace_vec_label.setToolTip(QCoreApplication.translate("MainWindow", u"Useful for inspecting reflections satisfying an equation for a plane through reciprocal space", None))
#endif // QT_CONFIG(tooltip)
        self.normal_realspace_vec_label.setText(QCoreApplication.translate("MainWindow", u"is normal to real space vector associated with:", None))
        self.label_13.setText(QCoreApplication.translate("MainWindow", u"Scale:", None))
#if QT_CONFIG(tooltip)
        self.clipplane_normal_vector_length.setToolTip(QCoreApplication.translate("MainWindow", u"use current scale or multiply with a number to form a new scale", None))
#endif // QT_CONFIG(tooltip)
#if QT_CONFIG(tooltip)
        self.label_15.setToolTip(QCoreApplication.translate("MainWindow", u"in units of the selected vector above", None))
#endif // QT_CONFIG(tooltip)
        self.label_15.setText(QCoreApplication.translate("MainWindow", u"Distance from origin", None))
        self.AutoClipWidthCheckBox.setText(QCoreApplication.translate("MainWindow", u"Automatic Clip plane width", None))
#if QT_CONFIG(tooltip)
        self.hkldist_spinBox.setToolTip(QCoreApplication.translate("MainWindow", u"in units of the selected vector above", None))
#endif // QT_CONFIG(tooltip)
        self.label_21.setText(QCoreApplication.translate("MainWindow", u"Clip Plane Width:", None))
#if QT_CONFIG(tooltip)
        self.clipwidth_spinBox.setToolTip(QCoreApplication.translate("MainWindow", u"Adjust width to exclude reflections that should not be visible or to make visible reflections that are not", None))
#endif // QT_CONFIG(tooltip)
        self.RotateGroupBox.setTitle(QCoreApplication.translate("MainWindow", u"Rotate reflections around X, Y, Z axes", None))
        self.label_14.setText(QCoreApplication.translate("MainWindow", u"Angular step of:", None))
        self.angleStepHKLrotSpinBox.setSuffix(QCoreApplication.translate("MainWindow", u"\u00ba", None))
        self.groupBox_2.setTitle(QCoreApplication.translate("MainWindow", u"Rotate around X", None))
        self.xHKLrotBtn.setText(QCoreApplication.translate("MainWindow", u"+", None))
        self.xHKLbackrotBtn.setText(QCoreApplication.translate("MainWindow", u"-", None))
        self.groupBox_4.setTitle(QCoreApplication.translate("MainWindow", u"Rotate around Y", None))
        self.yHKLrotBtn.setText(QCoreApplication.translate("MainWindow", u"+", None))
        self.yHKLbackrotBtn.setText(QCoreApplication.translate("MainWindow", u"-", None))
        self.groupBox_6.setTitle(QCoreApplication.translate("MainWindow", u"Rotate around Z", None))
        self.zHKLrotBtn.setText(QCoreApplication.translate("MainWindow", u"+", None))
        self.zHKLbackrotBtn.setText(QCoreApplication.translate("MainWindow", u"-", None))
        self.functionTabWidget.setTabText(self.functionTabWidget.indexOf(self.slicing_tab), QCoreApplication.translate("MainWindow", u"Slicing", None))
        self.groupBox_3.setTitle(QCoreApplication.translate("MainWindow", u"Radii size of HKL spheres", None))
#if QT_CONFIG(tooltip)
        self.power_scale_spinBox.setToolTip("")
#endif // QT_CONFIG(tooltip)
#if QT_CONFIG(tooltip)
        self.radii_scale_spinBox.setToolTip(QCoreApplication.translate("MainWindow", u"<html><head/><body><p>A linear scale factor of 1 means that if two reflectiions with the largest data values happen to be next to each other their spheres will touch but not overlap.</p></body></html>", None))
#endif // QT_CONFIG(tooltip)
        self.label_7.setText(QCoreApplication.translate("MainWindow", u"<html><head/><body><p>Tick the <span style=\" font-weight:600;\">User defined power scaling</span> box for chosing a <span style=\" font-weight:600;\">Power scale factor</span>. Untick this box to get an <span style=\" font-weight:600;\">automatic power scale factor.</span><br/>An <span style=\" font-weight:600;\">automatic power scale</span> factor will scale reflections to make them all visible and still convey their relative magnitude, with the smallest reflection never drawn smaller than one tenth of the size of the largest reflection.<br/>A <span style=\" font-weight:600;\">power scale factor = 1</span> will size the reflections proportional to their data value offset by the smallest data value.<br/>A <span style=\" font-weight:600;\">power scale factor = 0</span> causes all reflections to have the same size regardless of their data values. <br/>A <span style=\" font-weight:600;\">power scale factor &lt; 0</span> will correlate the sizes of reflections negatively to their data values. </p></body></html>", None))
#if QT_CONFIG(tooltip)
        self.label_11.setToolTip(QCoreApplication.translate("MainWindow", u"<html><head/><body><p>A linear scale factor of 1 means that if two reflectiions with the largest data values happen to be next to each other their spheres will touch but not overlap.</p></body></html>", None))
#endif // QT_CONFIG(tooltip)
        self.label_11.setText(QCoreApplication.translate("MainWindow", u"Linear scale factor", None))
#if QT_CONFIG(tooltip)
        self.ManualPowerScalecheckbox.setToolTip("")
#endif // QT_CONFIG(tooltip)
        self.ManualPowerScalecheckbox.setText(QCoreApplication.translate("MainWindow", u"User defined power scaling", None))
        self.label_10.setText(QCoreApplication.translate("MainWindow", u"Power scale factor:", None))
        self.functionTabWidget.setTabText(self.functionTabWidget.indexOf(self.sizing_tab), QCoreApplication.translate("MainWindow", u"Sizing", None))
#if QT_CONFIG(tooltip)
        self.addDatasetBtn.setToolTip(QCoreApplication.translate("MainWindow", u"<html><head/><body><p>Provide a unique label to create a new dataset with the reflections that have opacity = 1.0</p></body></html>", None))
#endif // QT_CONFIG(tooltip)
        self.addDatasetBtn.setText(QCoreApplication.translate("MainWindow", u"Add visible reflections as new dataset...", None))
        self.OpaqueAllCheckbox.setText(QCoreApplication.translate("MainWindow", u"Show/hide all data", None))
#if QT_CONFIG(tooltip)
        self.binstable.setToolTip(QCoreApplication.translate("MainWindow", u"<html><head/><body><p>Change a bin threshold by entering a preferred value in the in the &quot;lower bin value&quot; column for a particular bin.<br/>Change visibility of bins either by ticking or unticking the check boxes or by entering opacity values between 0 and 1. Reflections with values less than 0.3 will not respond to mouse clicks.<br/></p></body></html>", None))
#endif // QT_CONFIG(tooltip)
        self.groupBox_5.setTitle(QCoreApplication.translate("MainWindow", u"Bin according to", None))
        self.label_12.setText(QCoreApplication.translate("MainWindow", u"Number of bins:", None))
#if QT_CONFIG(tooltip)
        self.Nbins_spinBox.setToolTip(QCoreApplication.translate("MainWindow", u"<html><head/><body><p>Select the number of bins for ordering the currently displayed data set. More than about 10-15 bins will slow down the HKLviewer when working with large datasets.<br/>The requested number of bins may not be created if there are zero reflections in some bins.</p></body></html>", None))
#endif // QT_CONFIG(tooltip)
#if QT_CONFIG(tooltip)
        self.BinDataComboBox.setToolTip(QCoreApplication.translate("MainWindow", u"<html><head/><body><p>Rank the currently displayed dataset in bins according resolution or the values of a selected dataset or singletons. Reflections in the currently displayed dataset not matching any reflections in the selected dataset will be put in a bin labelled with &quot;nan&quot;.</p></body></html>", None))
#endif // QT_CONFIG(tooltip)
        self.functionTabWidget.setTabText(self.functionTabWidget.indexOf(self.bining_tab), QCoreApplication.translate("MainWindow", u"Binning", None))
#if QT_CONFIG(tooltip)
        self.ReciprocUnitCellgrp.setToolTip(QCoreApplication.translate("MainWindow", u"<html><head/><body><p>The reciprocal unit cell spanning a*,b*,c* from (0,0,0) to (1,1,1) is located in the centre of the displayed reflections. and is therefore quite small. Adjust the slider to scale its outline to become compatible with the sphere of displayed reflections.</p></body></html>", None))
#endif // QT_CONFIG(tooltip)
        self.ReciprocUnitCellgrp.setTitle(QCoreApplication.translate("MainWindow", u"Reciprocal Vectors", None))
        self.label_2.setText(QCoreApplication.translate("MainWindow", u"True to scale", None))
        self.label_4.setText(QCoreApplication.translate("MainWindow", u"Roughly radius of highest resolution shell", None))
        self.DrawReciprocUnitCellBox.setText(QCoreApplication.translate("MainWindow", u"Show Unit Cell", None))
        self.RotationVectorsBox.setTitle(QCoreApplication.translate("MainWindow", u"Rotation Operators or Vector(s)", None))
        self.ShowAllVectorsBtn.setText(QCoreApplication.translate("MainWindow", u"Show All", None))
        self.rotavecangle_labeltxt.setText(QCoreApplication.translate("MainWindow", u"Rotate Reflections around Vector with Angle", None))
#if QT_CONFIG(tooltip)
        self.rotavecangle_slider.setToolTip(QCoreApplication.translate("MainWindow", u"<html><head/><body><p>If just one vector is drawn the reflections can be rotated to a particular angle around that vector.</p></body></html>", None))
#endif // QT_CONFIG(tooltip)
#if QT_CONFIG(tooltip)
        self.AlignVectorGroupBox.setToolTip(QCoreApplication.translate("MainWindow", u"<html><head/><body><p>If just one vector is drawn it can be oriented together with the reflections by ticking this checkbox.</p></body></html>", None))
#endif // QT_CONFIG(tooltip)
        self.AlignVectorGroupBox.setTitle(QCoreApplication.translate("MainWindow", u"Orient Vector", None))
        self.AlignParallelBtn.setText(QCoreApplication.translate("MainWindow", u"Parallel to Screen", None))
        self.AlignNormalBtn.setText(QCoreApplication.translate("MainWindow", u"Normal to Screen", None))
#if QT_CONFIG(tooltip)
        self.AnimaRotCheckBox.setToolTip(QCoreApplication.translate("MainWindow", u"<html><head/><body><p>If just one vector is drawn the reflections can be rotated continuously around that vector.</p></body></html>", None))
#endif // QT_CONFIG(tooltip)
        self.AnimaRotCheckBox.setText(QCoreApplication.translate("MainWindow", u"Rotate continuously", None))
        self.label_8.setText(QCoreApplication.translate("MainWindow", u"Speed", None))
#if QT_CONFIG(tooltip)
        self.vectortable2.setToolTip(QCoreApplication.translate("MainWindow", u"<html><head/><body><p>Tick checkboxes to draw the rotation axes defined by the space group.<br/>Enter additional vectors from origin defined either as axes of rotation operators, plain reciprocal coordinates (as hkl) or plain real space fractional coordinates (as abc).<br/>To enter a new vector, first override the &quot;new vector&quot; name with a preferred name. Then enter the definition of the vector in either the &quot;rotation&quot;, the &quot;as hkl&quot; or the &quot;as abc&quot; column.</p></body></html>", None))
#endif // QT_CONFIG(tooltip)
#if QT_CONFIG(tooltip)
        self.RealUnitCellBoxgrp.setToolTip(QCoreApplication.translate("MainWindow", u"<html><head/><body><p>The real space unit cell is often much larger than the sphere of displayed reflections. Adjust the slider to scale its outline to become compatible with the sphere of displayed reflections.</p></body></html>", None))
#endif // QT_CONFIG(tooltip)
        self.RealUnitCellBoxgrp.setTitle(QCoreApplication.translate("MainWindow", u"Real Space Vectors", None))
        self.label_6.setText(QCoreApplication.translate("MainWindow", u"Bigger", None))
        self.DrawRealUnitCellBox.setText(QCoreApplication.translate("MainWindow", u"Show Unit Cell", None))
        self.label_5.setText(QCoreApplication.translate("MainWindow", u"Roughly radius of highest resolution shell", None))
        self.functionTabWidget.setTabText(self.functionTabWidget.indexOf(self.vectors_tab), QCoreApplication.translate("MainWindow", u"Vectors", None))
        self.tabWidget.setTabText(self.tabWidget.indexOf(self.tabDetails), QCoreApplication.translate("MainWindow", u"Details", None))
        self.InfoWidget.setWindowTitle(QCoreApplication.translate("MainWindow", u"HKLviewer Info", None))
        self.tabText.setTabText(self.tabText.indexOf(self.tabInfo), QCoreApplication.translate("MainWindow", u"Info", None))
        self.tabText.setTabText(self.tabText.indexOf(self.tabWarnings), QCoreApplication.translate("MainWindow", u"Verbose Info", None))
    # retranslateUi


 *******************************************************************************


 *******************************************************************************
crys3d/hklviewer/jsview_3d.py
# -*- coding: utf-8 -*-
from __future__ import absolute_import, division, print_function
from libtbx.math_utils import roundoff
import traceback
from crys3d.hklviewer import display2 as display
from cctbx.array_family import flex
from cctbx import miller, sgtbx
from scitbx import graphics_utils
from scitbx import matrix
import scitbx.math
from libtbx import group_args
from libtbx.test_utils import approx_equal
from libtbx.utils import Sorry, to_str
import threading, math, sys, cmath
from crys3d.hklviewer.webbrowser_messenger_py3 import WBmessenger

import os.path, time, copy, re, io, subprocess
import libtbx
import webbrowser, tempfile
from six.moves import range


class HKLviewerError(Exception):
  # Unrecoverable errors we detect such as failure to connect via websocket or no WebGL
  def __init__(self, value):
    self.value = value
  def __str__(self):
    return(repr(self.value))


def has_phil_path(philobj, *paths): # variable number of arguments
  for path in paths:
    if len([ e.path for e in philobj.all_definitions() if path in e.path.split(".") ]):
      return True
  return False


def MakeHKLscene( proc_array, foms_array, pidx, fidx, renderscale, hkls, mprint=sys.stdout.write):
  """
  Conpute the hklscene for proc_array. If it's a complex array and foms_array!=None
  then also compute an hklscene with colours of each hkl attenuated by the corresponding FOM value.
  """
  from iotbx.gui_tools.reflections import ArrayInfo
  scenemaxdata =[]
  scenemindata =[]
  scenemaxsigmas = []
  sceneminsigmas = []
  scenearrayinfos = []
  hklscenes = []
  if (hkls.expand_anomalous or hkls.expand_to_p1) \
      and not proc_array.is_unique_set_under_symmetry():
    mprint("The " + proc_array.info().label_string() + \
         " array is not symmetry unique. Expansion may lead to multiple reflections rendered on top of each other.", verbose=1)
  hkls.expand_anomalous = False # don't expand reflections in display2.py as this now is done in HKLJavaScripts.js
  hkls.expand_to_p1 = False    #  TODO: remove this functionality altogether from display2.py

  hklscene = display.scene(miller_array=proc_array, merge=None, renderscale=renderscale,
    settings=hkls, foms_array=foms_array, fullprocessarray=True, mprint=mprint)
  if not hklscene.SceneCreated:
    mprint("The " + proc_array.info().label_string() + " array was not processed")
  #import code, traceback; code.interact(local=locals(), banner="".join( traceback.format_stack(limit=10) ) )
  # cast any NAN values to 1 of the colours and radii to 0.2 before writing javascript
  else:
    hklscenes.append( hklscene)
    hklscene.colors = graphics_utils.NoNansvec3( hklscene.colors, 1.0, 1.0, 1.0)
    hklscene.radii = graphics_utils.NoNansArray( hklscene.radii, 0.2)
    fomslabel = None
    if foms_array:
      fomslabel = foms_array.info().label_string()
    arrayinfo = ArrayInfo(hklscene.work_array)
    scenemindata.append(arrayinfo.minmaxdata[0])
    scenemaxdata.append(arrayinfo.minmaxdata[1])
    sceneminsigmas.append(arrayinfo.minmaxsigs[0])
    scenemaxsigmas.append(arrayinfo.minmaxsigs[1])
    lbl = arrayinfo.labelstr
    hassigmas=True
    if math.isnan(arrayinfo.maxsigmas):
      hassigmas=False
    if fomslabel:
      lbl = arrayinfo.labelstr + " + " + fomslabel
    (dummy1, infolst, dummy2, dummy3), dummy4, dummy5 = arrayinfo.get_selected_info_columns_from_phil()
    scenearrayinfos.append([infolst, pidx, fidx, lbl, infolst[1], hassigmas])
  return (hklscenes, scenemaxdata, scenemindata, scenemaxsigmas, sceneminsigmas, scenearrayinfos)


def get_browser_ctrl(using=None):
  if using is None or using=="default":
    return "default", webbrowser.get()

  if using=="firefox":
    if sys.platform == "win32":
      browser = "C:/Program Files/Mozilla Firefox/firefox.exe"
      if not os.path.isfile(browser):
        browser = "C:/Program Files (x86)/Mozilla Firefox/firefox.exe"
    if sys.platform.startswith("darwin"):
      browser = "/Applications/Firefox.app/Contents/MacOS/firefox"
    if sys.platform == "linux":
      browser = "/usr/bin/firefox"

  if using=="chrome":
    if sys.platform == "win32":
      browser = "C:/Program Files (x86)/Google/Chrome/Application/chrome.exe"
      if not os.path.isfile(browser):
        browser = "C:/Program Files/Google/Chrome/Application/chrome.exe"
    if sys.platform.startswith("darwin"):
      browser = '"/Applications/Google Chrome.app/Contents/MacOS/Google Chrome"'
      if not os.path.isfile(browser):
        browser = '"/Applications/Google Chrome.app"'
    if sys.platform == "linux":
      #pass
      browser = "/usr/bin/firefox"

  webbrowser.register(using, None, webbrowser.BackgroundBrowser(browser))
  webctrl = webbrowser.get(using)
  assert os.path.isfile(browser)
  return browser, webctrl


lock_timeout=120 # for the sempahores. Rendering could take a while for very large file. Until that
# has been completed, geometries of the NGL stage such as clipnear, clipfar, cameraZ and bounding box
# are undefined. websocket connection could take a while on Azure pipelines


class HKLview_3d:
  def __init__ (self, *args, **kwds) :
    self.diff_phil = None
    self.params = None # first assigned in HKLViewFrame().ResetPhil()
    self.miller_array = None
    self.symops = []
    self.sg = None
    self.tooltipstrings = []
    self.tooltipstringsdict = {}
    self.d_min = None
    self.scene = None
    self.lastscene_id = None
    self.merge = False
    self.url = ""
    self.bin_labels_type_idxs = []
    self.colours = []
    self.positions = []
    self.radii2 = []
    self.spbufttips = []
    self.rot_recip_zvec = None
    self.rot_zvec = None
    self.meanradius = -1
    self.past = time.time()
    self.orientmessage = None
    self.clipNear = None
    self.clipFar = None
    self.cameraPosZ = None
    self.zoom = None
    self.cameratranslation = ( 0,0,0 )
    self.planescalarvalue =0
    self.planenormalhklvec =None
    self.renderscale = 100
    #self.angle_x_svec = 0.0
    #self.angle_y_svec = 0.0
    self.angle_z_svec = 0.0
    #self.angle_z_yzvec = 0.0
    #self.angle_y_yzvec = 0.0
    #self.angle_y_xyvec = 0.0
    self.angle_x_xyvec = 0.0
    self.vecrotmx = None
    self.currentrotvec = None
    self.unit_h_axis = None
    self.unit_k_axis = None
    self.unit_l_axis = None
    self.normal_hk = None
    self.normal_kl = None
    self.normal_lh = None
    self.normal_vecnr = -1
    self.isnewfile = False
    self.has_new_miller_array = False
    self.sleeptime = 0.01 # 0.025 # used in sleep() for ProcessBrowserMessage and elsewhere in WBmessenger
    self.binvals = []
    self.binvalsboundaries = []
    self.oldnbinvalsboundaries = None
    self.proc_arrays = []
    self.HKLscene = []
    self.HKLscenedict = {}
    self.HKLscenesdict = {}
    self.HKLscenesMaxdata = []
    self.HKLscenesMindata = []
    self.HKLscenesMaxsigmas = []
    self.HKLscenesMinsigmas = []
    self.bindata = None
    self.reciproc_scale = 1.0
    self.realspace_scale = 1.0
    self.visual_symHKLs = []
    self.visual_symmxs= []
    self.visible_hkls = [] # Populated when applying clip planes. To be examined in regression tests
    self.outsideplane_hkls = []
    self.sceneisdirty = True
    self.max_reflections_in_frustum = 0
    self.imagename = None
    self.imgdatastr = ""
    self.hkl_scenes_info = []
    self.hkl_scenes_infos = []
    self.match_valarrays = []
    self.array_info_format_tpl = []
    self.binstrs = []
    self.rotation_operators = []
    self.all_vectors = []
    self.realSpaceMag = 1
    self.recipSpaceMag = 1
    self.cosine = 1
    self.L = 1.0
    self.nuniqueval = 0
    self.bin_infotpls = []
    self.executing_preset_btn = False
    self.mapcoef_fom_dict = {}
    # colourmap=brg, colourpower=1, nth_power_scale_radii=nan, radiiscale=1
    self.datatypedefault = ["brg", 1.0, float('nan'), 1.0]
    self.datatypedict = { }
    self.sceneid_from_arrayid = []
    self.parent = None
    if 'parent' in kwds:
      self.parent = kwds['parent']
    self.debug = None
    if 'debug' in kwds:
      self.debug = eval( kwds['debug'])
    self.mprint = sys.stdout.write
    if 'mprint' in kwds:
      self.mprint = kwds['mprint']
    self.nbinvalsboundaries = 0
    self.websockport = 7894
    if 'websockport' in kwds:
      self.websockport = kwds['websockport']
    tempdir = tempfile.gettempdir()
    # ensure unique file name by including port number in filename
    self.hklfname = os.path.join(tempdir, "hkl_%d.htm" %self.websockport )
    if os.path.isfile(self.hklfname):
      os.remove(self.hklfname)
    if 'htmlfname' in kwds and kwds['htmlfname']:
      self.hklfname = kwds['htmlfname']
    self.hklfname = os.path.abspath( self.hklfname )
    self.isHKLviewer= "false"
    self.verbose = 1
    self.verbosebrowser = False
    if 'verbose' in kwds:
      try:
        self.verbose = eval(kwds['verbose'])
      except Exception as e:
        self.verbose = kwds['verbose']
        if "browser" in self.verbose:
          self.verbosebrowser = True
    self.send_info_to_gui = None
    if 'send_info_to_gui' in kwds:
      self.send_info_to_gui = kwds['send_info_to_gui']
      self.isHKLviewer= "true"
    if 'fileinfo' in kwds:
      return
    self.mprint('Rendering done via websocket in \"%s\"'  %self.hklfname)
    self.hklhtml = r"""
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta charset="utf-8" /></head>
<body>
<script>var isHKLviewer = %s; </script>
<script>var websocket_portnumber = %s; </script>
<script src="%s" type="text/javascript"></script>
<script src="%s" type="text/javascript"></script>
<script src="%s" type="text/javascript"></script>
<script src="%s" type="text/javascript"></script>
<div id="viewport" style="width:100%%; height:100%%;"></div>
</body></html>

    """
    WeblglChecklibpath = os.path.join(os.path.dirname(os.path.abspath(__file__)), "webgl_check.js")
    Html2Canvaslibpath = os.path.join(os.path.dirname(os.path.abspath(__file__)), "html2canvas.min.js")
    NGLlibpath = os.path.join(os.path.dirname(os.path.abspath(__file__)), "ngl.js")
    HKLjscriptpath = os.path.join(os.path.dirname(os.path.abspath(__file__)), "HKLJavaScripts.js")
    WeblglCheckliburl = "file:///" + WeblglChecklibpath.replace("\\","/")
    Html2Canvasliburl = "file:///" + Html2Canvaslibpath.replace("\\","/")
    NGLliburl = "file:///" + NGLlibpath.replace("\\","/")
    HKLjscripturl = "file:///" + HKLjscriptpath.replace("\\","/")
    self.htmlstr = self.hklhtml %(self.isHKLviewer,
                                  self.websockport,
                                  WeblglCheckliburl,
                                  Html2Canvasliburl,
                                  NGLliburl,
                                  HKLjscripturl)
    self.colourgradientvalues = []
    self.browserpath, self.webctrl = get_browser_ctrl()
    self.UseOSBrowser = ""
    if 'useGuiSocket' not in kwds:
      self.UseOSBrowser = "default"
    ldic=locals()
    if 'UseOSBrowser' in kwds:
      exec("UseOSBrowser = kwds['UseOSBrowser']", globals(), ldic)
      self.UseOSBrowser = ldic["UseOSBrowser"]
      self.UseOSBrowser = self.UseOSBrowser.replace("\\","/")
      #if self.UseOSBrowser != "default" and not os.path.isfile(self.UseOSBrowser):
      #  raise Sorry("Error: %s does not exist" %self.UseOSBrowser)
      self.browserpath, self.webctrl = get_browser_ctrl(self.UseOSBrowser)

    self.viewmtrx = None
    self.lastviewmtrx = None
    self.currentRotmx = matrix.identity(3)
    self.include_tooltip_lst = []
    self.mouse_moved = False
    self.webgl_OK = True
    self.HKLsceneKey = None
    self.handshakewait = 5
    if 'handshakewait' in kwds:
      self.handshakewait = eval(kwds['handshakewait'])
    self.lastmsg = "" # "Ready"
    self.use_semaphore = True
    self.clipplane_msg_sem = threading.Semaphore()
    self.mousespeed_msg_sem = threading.BoundedSemaphore()
    self.hkls_drawn_sem = threading.Semaphore()
    self.autoview_sem = threading.BoundedSemaphore()
    self.browser_connect_sem = threading.BoundedSemaphore()
    self.WBmessenger = WBmessenger(self)
    self.AddToBrowserMsgQueue = self.WBmessenger.AddToBrowserMsgQueue
    # Don't overwhelm ProcessBrowserMessage() with the flurry of tooltips that can get emitted by javascript
    # when tooltips are shown for a large dataset as this makes the HKLviewer unresponsive.
    # replace_msg_lst is a list of strings that matches the
    # particular messages we want to replace rather than append to the message queue.
    self.WBmessenger.replace_msg_lst = ["tooltip_id:"]
    self.WBmessenger.StartWebsocket()
    self.javascriptcleaned = False


  def __exit__(self, exc_type, exc_value, traceback):
    # not called unless instantiated with a "with HKLview_3d ... " statement
    self.JavaScriptCleanUp()
    self.SendInfoToGUI( { "datatype_dict": self.datatypedict } ) # so the GUI can persist these across sessions
    nwait = 0
    if self.params.viewer.scene_id is None:
      self.WBmessenger.StopWebsocket()
    while not self.WBmessenger.isterminating and nwait < 5:
      time.sleep(self.sleeptime)
      nwait += self.sleeptime
    if os.path.isfile(self.hklfname):
      os.remove(self.hklfname)
    self.mprint("Destroying HKLview_3d", 1)


  def SendInfoToGUI(self, mydict):
    if self.send_info_to_gui:
      self.send_info_to_gui( mydict )


  def GuardedAddToBrowserMsgQueue(self, semaphorename, msgtype, msg="", binary=False,
                                  funcname="", posteriorcheck=True):
    if self.use_semaphore:
      semaphore = self.__dict__.get(semaphorename, None)
      self.mprint("%s waiting for %s.acquire" %(funcname, semaphorename), verbose="threadingmsg")
      if not semaphore.acquire(blocking=True, timeout=lock_timeout):
        self.mprint("Error! Timed out waiting for %s semaphore within %s seconds" %(semaphorename,lock_timeout), verbose=1)
      self.mprint("%s got %s" %(funcname, semaphorename), verbose="threadingmsg")

    self.AddToBrowserMsgQueue( msgtype, msg, binary)
    time.sleep(0.1)
    if posteriorcheck and self.use_semaphore:
      self.mprint("%s waiting for %s.acquire again" %(funcname, semaphorename), verbose="threadingmsg")
      if not semaphore.acquire(blocking=True, timeout=lock_timeout):
        self.mprint("Error! Timed out waiting for %s semaphore within %s seconds" %(semaphorename,lock_timeout), verbose=1)
      self.mprint("%s got %s again" %(funcname, semaphorename), verbose="threadingmsg")
      semaphore.release()
      self.mprint("%s released %s" %(funcname, semaphorename), verbose="threadingmsg")


  def process_PHIL_parameters(self, diff_phil, curphilparam) :
    """
    Event handler for zmq messages from the GUI or simply for commandline interaction when
    scripting HKLviewer with python
    """
    self.params = curphilparam
    self.diff_phil = diff_phil

    if has_phil_path(diff_phil,
            "openfilename",
            "use_provided_miller_arrays",
            "spacegroup_choice",
            "using_space_subgroup",
            "camera_type",
            "miller_array_operation",
       ) or has_phil_path(diff_phil, "viewer") \
          and has_phil_path(diff_phil,
                  "show_missing",
                  "show_only_missing",
                  "show_systematic_absences",
                  "slice_axis",
                  "slice_index",
                  "sigma_color_radius",
                  "scene_id",
                  "data_array",
                  "color_scheme",
                  "color_powscale",
                  "scale",
                  "nth_power_scale_radii"
              ) :
                  self.sceneisdirty = True
                  if has_phil_path(diff_phil,
                          "spacegroup_choice",
                          "show_missing",
                          "show_only_missing",
                          "show_systematic_absences",
                          "slice_axis",
                          "slice_index",
                          "sigma_color_radius",
                          "scene_id",
                          "data_array",
                          "use_provided_miller_arrays",
                          "color_scheme",
                          "color_powscale",
                          "scale",
                          "nth_power_scale_radii"
                     ):
                        self.ConstructReciprocalSpace(scene_id=self.params.viewer.scene_id )
    msg = ""
    if self.params.viewer.scene_id is not None and \
       has_phil_path(diff_phil,
            #"scene_id",
            "show_missing",
            "show_only_missing",
            "show_systematic_absences",
            "binner_idx",
            "binlabel",
            "nbins",
        ) and not has_phil_path(diff_phil, "scene_bin_thresholds"):
      self.binvalsboundaries = []
      self.binvals, self.nuniqueval = self.calc_bin_thresholds(curphilparam.binning.binner_idx,
                                                               curphilparam.binning.nbins)
      self.sceneisdirty = True

    self.params.max_reflections_in_frustum

    if has_phil_path(diff_phil, "max_reflections_in_frustum"):
      self.max_reflections_in_frustum = self.params.max_reflections_in_frustum

    if has_phil_path(diff_phil, "sigma_color_radius"):
      self.sceneisdirty = True

    if has_phil_path(diff_phil, "scene_bin_thresholds"):
      self.sceneisdirty = True

    if has_phil_path(diff_phil, "color_scheme"):
      self.add_colour_scheme_to_dict()
      self.sceneisdirty = True

    if has_phil_path(diff_phil, "color_powscale"):
      self.add_colour_powscale_to_dict()
      self.sceneisdirty = True

    if has_phil_path(diff_phil, "nth_power_scale_radii"):
      self.add_nth_power_scale_radii_to_dict()
      self.sceneisdirty = True

    if has_phil_path(diff_phil, "scale"):
      self.add_radii_scale_to_dict()
      self.sceneisdirty = True

    if has_phil_path(diff_phil, "camera_type"):
      self.set_camera_type()

    if has_phil_path(diff_phil, "show_hkl"):
      self.show_hkl()

    if has_phil_path(diff_phil, "tooltip_data"):
      tablerow, binclude = eval(self.params.tooltip_data)
      self.include_tooltip_lst[tablerow] = binclude

    if has_phil_path(diff_phil, "background_colour"):
      self.set_background_colour()

    if has_phil_path(diff_phil, "show_tooltips"):
      self.set_show_tooltips()

    if has_phil_path(diff_phil, "tooltip_alpha"):
      self.set_tooltip_opacity()

    if has_phil_path(diff_phil, "angle_around_vector"):
      i,deg = self.rotate_around_numbered_vector()
      self.params.viewer.angle_around_vector = str([i, deg])

    if has_phil_path(diff_phil, "angle_around_XHKL_vector"):
      self.rotate_stage_around_cartesian_vector([1,0,0], self.params.viewer.angle_around_XHKL_vector)
      self.params.viewer.angle_around_XHKL_vector = None

    if has_phil_path(diff_phil, "angle_around_YHKL_vector"):
      self.rotate_stage_around_cartesian_vector([0,1,0], self.params.viewer.angle_around_YHKL_vector)
      self.params.viewer.angle_around_YHKL_vector = None

    if has_phil_path(diff_phil, "angle_around_ZHKL_vector"):
      self.rotate_stage_around_cartesian_vector([0,0,1], self.params.viewer.angle_around_ZHKL_vector)
      self.params.viewer.angle_around_ZHKL_vector = None

    if has_phil_path(diff_phil,
                      "spacegroup_choice",
                      "use_provided_miller_arrays",
                      "binning",
                      "fontsize",
                      "vector_width",
                      "data_array",
                      "miller_array_operation",
                      "mouse_sensitivity",
                      "real_space_unit_cell_scale_fraction",
                      "reciprocal_unit_cell_scale_fraction",
                      "draw_real_space_unit_cell",
                      "draw_reciprocal_unit_cell",
                      "clip_plane",
                      "show_vector",
                      "show_all_vectors",
                      "hkls",
                      "use_wireframe",
                      "viewer") and self.params.viewer.scene_id is not None:
       # any change to parameters in the master phil in display2.py
      self.scene = self.HKLscene_dict_val(self.params.viewer.scene_id).scene
      self.DrawNGLJavaScript()
      self.mprint( "Rendered %d reflections" % self.scene.points.size(), verbose=1)
      #time.sleep(25) # for debugging
      self.realSpaceMag = (self.realspace_scale - 1.0)*self.params.real_space_unit_cell_scale_fraction + 1.0
      self.recipSpaceMag = (self.reciproc_scale - 1.0)*self.params.reciprocal_unit_cell_scale_fraction + 1.0

      if has_phil_path(diff_phil, "vector_width"):
        self.SetVectorWidth(self.params.NGL.vector_width)

      if has_phil_path(diff_phil, "hkldist"):
        self.visual_symHKLs = []

      if has_phil_path(diff_phil, "show_vector",
                                  "real_space_unit_cell_scale_fraction",
                                  "reciprocal_unit_cell_scale_fraction"):
        self.show_vectors(self.params.viewer.show_vector, diff_phil)

      if has_phil_path(diff_phil, "show_all_vectors"):
        self.show_all_vectors()

      if has_phil_path(diff_phil, "normal_vector") and self.params.clip_plane.normal_vector != "":
        found = False
        for (opnr, label, order, cartvec, hklop, hkl, abc, length) in self.all_vectors:
          if self.params.clip_plane.normal_vector in label:
            found=True
        if not found:
          raise Sorry("No vector present with substring: %s" %self.params.clip_plane.normal_vector)

      self.set_volatile_params()

    if has_phil_path(diff_phil, "fontsize"):
      self.SetFontSize(self.params.NGL.fontsize)

    if has_phil_path(diff_phil, "animate_rotation_around_vector"):
      i,speed = self.animate_rotate_around_vector()
      self.params.viewer.animate_rotation_around_vector = str([i, speed])

    if self.params.viewer.scene_id is None:
      self.DrawNGLJavaScript(blankscene=True)
    return curphilparam


  def set_volatile_params(self, use_semaphore=True):
    """
    Change the view of the reflections according to whatever the values are of the volatile parameters.
    Volatile parameters are those that do not require heavy computing (like position of WebGL primitives)
    but can change the appearance of primitives instantly like opacity or clipplane position. Expansion
    in browser of coordinates to P1 are also considered volatile as this operation is very fast.
    """
    self.use_semaphore = use_semaphore
    if self.params.viewer.scene_id is not None:
      if self.isnewfile:
        self.SetDefaultOrientation()
        if not self.autoview_sem.acquire(blocking=True, timeout=lock_timeout):
          self.mprint("Error! Timed out waiting for autoview_sem semaphore within %s seconds" %lock_timeout, verbose=1)
        self.mprint("set_volatile_params got autoview_sem", verbose="threadingmsg")
        self.autoview_sem.release()
        self.mprint("set_volatile_params released clipplane_msg_sem", verbose="threadingmsg")

        while len(self.WBmessenger.clientmsgqueue):
          self.mprint("set_volatile_params sleep", verbose=1)
          time.sleep(0.2)

      if self.params.viewer.fixorientation == "vector":
        self.orient_vector_to_screen(self.currentrotvec)
      self.SetMouseSpeed(self.params.NGL.mouse_sensitivity)
      hkldist = -1
      clipwidth = None
      self.fix_orientation()
      uc = self.miller_array.unit_cell()
      if self.params.clip_plane.clip_width: # then we are clipping
        self.UseCameraZoom()
        if self.params.clip_plane.auto_clip_width: # set the default spacing between layers of reflections
          self.params.clip_plane.clip_width = 0.5*self.L # equal to half the hkl vector length
        clipwidth = self.params.clip_plane.clip_width
        hkldist = -self.params.clip_plane.hkldist * self.L *self.cosine
        self.mprint("clip plane distance from origin: %s" %hkldist)
      else:
        self.UseZoomDrag()
      infomsg = ""
      self.normal_vecnr = -1
      for (opnr, label, order, cartvec, hklop, hkl, abc, length) in self.all_vectors:
        if self.params.clip_plane.normal_vector in label and self.params.clip_plane.normal_vector != "":
          self.normal_vecnr = opnr

      if self.normal_vecnr != -1: # then we are orienting clip plane with a vector
        # cartvec can be hklvec vector in cartesian coordinates
        # or abcvec vector in cartesian coordinates
        cartvec = self.all_vectors[ self.normal_vecnr ][3]
        self.L = self.all_vectors[ self.normal_vecnr ][7]
        # Use half the length of the tncs vector to allow stepping through alternating weak and strong layers
        # of reflections in the GUI when orienting clip plane perpendicular to the tncs vector
        if "tNCS" in self.all_vectors[ self.normal_vecnr ][1]:
          self.L *= 0.5

        if self.params.clip_plane.auto_clip_width: # set the default spacing between layers of reflections
          self.params.clip_plane.clip_width = 0.5*self.L # equal to half the hkl vector length
        clipwidth = self.params.clip_plane.clip_width
        # hklvec is reciprocal vector in reciprocal coordinates.
        # First try and see if they are stored in self.all_vectors[..][5].
        # If not then convert the cartesian representation cartvec of hklvec
        # into the reciprocal coordinates
        try:
          hklvec = eval(self.all_vectors[ self.normal_vecnr ][5])
        except Exception as e:
          hklvec = list(self.reciprocal_from_real_space_vector(cartvec ))
        # Get corresponding real space vector to the hkl vector (as cartesian coordinates)
        real_space_vec = hklvec * matrix.sqr(uc.orthogonalization_matrix())
        # In the general case real_space_vec is not parallel to hklvec
        # Orient the clip plane perpendicular to real_space_vec while at the
        # same time slide clip plane along the cartvec (reciprocal vector) direction
        # in units of cartvec projected onto real_space_vec
        self.cosine, _, _ = self.project_vector1_vector2(cartvec, real_space_vec)
        hkldist = -self.params.clip_plane.hkldist * self.L *self.cosine
        self.mprint("clip plane distance from origin: %s" %hkldist)
        if self.params.clip_plane.is_assoc_real_space_vector:
          orientvector = real_space_vec
          self.mprint("clip plane perpendicular to realspace vector associated with hkl vector: %s" %str(hklvec), verbose=1)
        else:
          orientvector = cartvec
          abcvec = self.all_vectors[ self.normal_vecnr ][6]
          self.mprint("clip plane perpendicular to realspace vector: %s" %str(abcvec), verbose=1)
          infomsg = "Vector distance from origin: %d" %(self.params.clip_plane.hkldist)
          if "tNCS" in self.all_vectors[ self.normal_vecnr ][1]:
            """ Clip plane width for tncs should be around 1/4 of the tncs modulation length
            as to ensure we only get the strongest/weakest reflections between clipnear, clipfar.
            The tncs modulation length is the inverse length of the tncs vector as defined in
            HKLViewFrame.list_vectors() where the length is stored as half the length of the tncs vector
            for the sake of stepping through alternating weak and strong layers with the +/- buttons.
            So set clip plane width to 0.5*0.5/tncs-vector-length.
            """
            if self.params.clip_plane.auto_clip_width: # use the default spacing between tncs layers of reflections
              self.params.clip_plane.clip_width = 0.5*self.L
            clipwidth = self.params.clip_plane.clip_width
            # Want the radius of the sphere of reflections so get a reflection at highest resolution
            # Decrease resolution by 0.00001 to avoid machine precision errors yielding 0 reflections
            dminhkl = self.miller_array.resolution_filter(d_min=0,
                                                          d_max=(self.miller_array.d_min()+0.00001)).indices()[0]
            dmincartvec = list( dminhkl * matrix.sqr(uc.fractionalization_matrix()).transpose() )
            sphereradius = math.sqrt(dmincartvec[0]*dmincartvec[0] + dmincartvec[1]*dmincartvec[1]
                                      + dmincartvec[2]*dmincartvec[2] )
            n_tncs_layers = sphereradius*self.renderscale/self.L
            infomsg = "tNCS layer: %d out of +-%2.2f" %(self.params.clip_plane.hkldist, n_tncs_layers)

          if "-fold" in self.all_vectors[ self.normal_vecnr ][1]:
            clipwidth = self.params.clip_plane.clip_width
            infomsg = "Reflection layer %d related through %s" \
              %(self.params.clip_plane.hkldist, self.all_vectors[ self.normal_vecnr ][1])

        self.orient_vector_to_screen(orientvector)
        scalefactor = 1.0
        if self.params.clip_plane.normal_vector_length_scale > 0 and self.all_vectors[self.normal_vecnr][1] != "tNCS":
          scalefactor = self.L/self.params.clip_plane.normal_vector_length_scale
          self.L = self.params.clip_plane.normal_vector_length_scale
        # Make a string of the equation of the plane of reflections
        hklvecsqr = hklvec[0]*hklvec[0] + hklvec[1]*hklvec[1] + hklvec[2]*hklvec[2]
        if self.params.clip_plane.is_assoc_real_space_vector:
          self.planescalarvalue = self.params.clip_plane.hkldist * hklvecsqr*scalefactor
          self.planenormalhklvec = hklvec
          infomsg = "Reflections satisfying: %s*h + %s*k + %s*l = %s" \
            %(roundoff(hklvec[0],4), roundoff(hklvec[1],4), roundoff(hklvec[2],4), roundoff(self.planescalarvalue))
        self.cosine, _, _ = self.project_vector1_vector2(cartvec, real_space_vec)
      # show equation or info in the browser
      self.AddToBrowserMsgQueue("PrintInformation", infomsg)
      self.ExpandInBrowser()
      retstr = ""
      if self.miller_array and self.params.binning.bin_opacity:
        bin_opacitieslst = self.params.binning.bin_opacity
        for alpha,bin in bin_opacitieslst:
          retstr += self.set_opacity(bin, alpha)
        self.SendInfoToGUI( { "bin_opacity": self.params.binning.bin_opacity } )
      self.mprint( retstr, verbose=1)
      self.DrawUnitCell()
      self.DrawReciprocalUnitCell()
      self.set_tooltip_opacity()
      self.set_show_tooltips()
      self.visualise_sym_HKLs()
      self.isnewfile = False
      self.make_clip_plane(hkldist, clipwidth)


  def set_scene(self):
    self.binvals = []
    if self.params.viewer.scene_id is None:
      return False
    self.set_miller_array(self.params.viewer.scene_id)
    if (self.miller_array is None):
      raise Sorry("No data loaded!")
    self.mprint( "Miller array %s runs from hkls: %s to %s" \
     %(self.miller_array.info().label_string(), self.miller_array.index_span().min(),
        self.miller_array.index_span().max() ) )
    self.mprint("Spacegroup: %s" %self.miller_array.space_group().info().symbol_and_number())
    return True


  def set_miller_array(self, scene_id=None, merge=None, details=""):
    if scene_id is not None:
      self.params.viewer.scene_id = scene_id
    if self.params.hkls and self.params.viewer.scene_id is not None and self.params.viewer.scene_id >= 0:
      self.miller_array = self.HKLscene_dict_val().scene.miller_array
      self.scene = self.HKLscene_dict_val().scene
    self.merge = merge
    if (self.miller_array is None):
      return
    self.identify_suitable_fomsarrays()
    self.GetUnitcellScales()
    self.d_min = self.miller_array.d_min()
    array_info = self.miller_array.info()
    # capture the currently selected spacegroup if not the default
    self.sg = self.proc_arrays[self.scene_id_to_array_id(self.params.viewer.scene_id)].space_group()
    self.symops = list(self.sg.all_ops())
    uc = "a=%g b=%g c=%g angles=%g,%g,%g" % self.miller_array.unit_cell().parameters()
    self.mprint( "Data: %s %s, %d reflections in space group: %s, unit Cell: %s" \
      % (array_info.label_string(), details, self.miller_array.indices().size(), \
          self.miller_array.space_group_info(), uc), verbose=0 )


  def Complex2AmplitudesPhases(self, data):
    ampls = flex.abs(data)
    phases = flex.arg(data) * 180.0/math.pi
    # purge nan values from array to avoid crash in fmod_positive()
    #b = flex.bool([bool(math.isnan(e)) for e in phases])
    # replace the nan values with an arbitrary float value
    #phases = phases.set_selected(b, 42.4242)
    phases = graphics_utils.NoNansArray( phases, 42.4242)
    # Cast negative degrees to equivalent positive degrees
    phases = flex.fmod_positive(phases, 360.0)
    return ampls, phases


  def get_rothkl_from_IDs(self, id, sym_id):
    anomalous = False
    if id < 0:
      anomalous = True
      id = abs(id) # we set anomalous ids as the negative of the original ids
    hkl = self.scene.indices[id]
    hklvec = flex.vec3_double( [(hkl[0], hkl[1], hkl[2])])
    rotmx=None
    if sym_id >= 0 and sym_id < len(self.symops):
      # symid tells which symmetry operator was used in HKLJavaScripts.js onMessage() Expand()
      rotmx = self.symops[sym_id].r()
    Rhkl = hklvec[0]
    if rotmx:
      # if a symmetry mate was clicked then deduce its hkl coordinate by
      # applying the rotation to the original hkl coordinate
      Rhkl = hklvec[0] * rotmx
    rothkl = (int(Rhkl[0]), int(Rhkl[1]), int(Rhkl[2]))
    if anomalous:
      rothkl = (int(-Rhkl[0]), int(-Rhkl[1]), int(-Rhkl[2]))
    return rothkl, hkl


  def make_visual_symHKLs(self, id, sym_id):
    symid = sym_id
    rothkl, dummy = self.get_rothkl_from_IDs(id, symid) # and use it
    if self.visual_symmxs:
      # if a list of symmetry matrices have been deduced from a selected rotation operator
      # then also compute the other symmetry mates of the current hkl
      self.visual_symHKLs = []
      for symmx,hklstr in self.visual_symmxs:
        vissymrothkl = rothkl * symmx.transpose()
        self.visual_symHKLs.append( (vissymrothkl, hklstr) )


  def GetTooltipOnTheFly(self, id, sym_id, anomalous=False):
    rothkl, hkl = self.get_rothkl_from_IDs(id, sym_id)
    spbufttip = '\'HKL: [%d,%d,%d]' %(rothkl[0], rothkl[1], rothkl[2])
    if rothkl != hkl: # then show the original hkl before P1 or anomalous expansion
      spbufttip += ', (asu): [%d,%d,%d]' %(hkl[0], hkl[1], hkl[2])
    # resolution and Angstrom character for javascript
    spbufttip += '\\ndres: %s \'+ String.fromCharCode(197) +\'' \
      %str(roundoff(self.miller_array.unit_cell().d(hkl), 2) )
    for tablerow,proc_array in enumerate(self.proc_arrays):
      if not self.include_tooltip_lst[tablerow]:
        continue
      sigvals = []
      datvals = []
      if proc_array.sigmas() is not None:
        sigvals = list( proc_array.select(proc_array.indices() == hkl).sigmas() )
      datval = None
      if hkl in proc_array.indices():
        datvals = list( proc_array.select(proc_array.indices() == hkl).data() )
      else:
        if id >= proc_array.size():
          continue
      for i,datval in enumerate(datvals):
        if proc_array.is_hendrickson_lattman_array() and math.isnan(datval[0] + datval[1] + datval[2] + datval[3]):
          continue
        if not isinstance(datval, tuple) and (math.isnan( abs(datval) ) or datval == display.inanval):
          continue
        if proc_array.is_complex_array():
          ampl = abs(datval)
          phase = cmath.phase(datval) * 180.0/math.pi
          # purge nan values from array to avoid crash in fmod_positive()
          # and replace the nan values with an arbitrary float value
          if math.isnan(phase):
            phase = 42.4242
          # Cast negative degrees to equivalent positive degrees
          phase = phase % 360.0
        spbufttip +="\\n" + proc_array.info().label_string() + ': '
        if proc_array.is_complex_array():
          spbufttip += str(roundoff(ampl, 2)) + ", " + str(roundoff(phase, 2)) + \
            "\'+ String.fromCharCode(176) +\'" # degree character for javascript
        elif sigvals:
          sigma = sigvals[i]
          spbufttip += str(roundoff(datval, 2)) + ", " + str(roundoff(sigma, 2))
        else:
          spbufttip += str(roundoff(datval, 2))
    spbufttip += '\\n\\n%d,%d' %(id, sym_id) # compared by the javascript
    spbufttip += '\''
    return spbufttip


  def get_col_fomcol(self, idx):
    if len(self.HKLscene_dict_val().arrayinfo) == 0:
      return -1, -1
    return self.HKLscene_dict_val(idx).arrayinfo[6], self.HKLscene_dict_val(idx).arrayinfo[7]


  def ConstructReciprocalSpace(self, scene_id=None):
    if len(self.proc_arrays) == 0 or scene_id is None:
      return False
    sceneid = scene_id
    self.HKLsceneKey = self.Sceneid_to_SceneKey(sceneid)
    if self.HKLsceneKey in self.HKLscenedict and not self.has_new_miller_array:
      self.HKLscene = self.HKLscenedict.get(self.HKLsceneKey, False)
      if self.HKLscene:
        self.mprint("Using cached HKL scene", verbose=1)
        return True
    if self.has_new_miller_array:
      self.identify_suitable_fomsarrays()
    self.mprint("Constructing HKL scenes...", verbose=1)
    idx,fdx = self.scene_id_to_array_and_foms_id(scene_id)
    fomarray = None
    if fdx >= 0: # index is -1 if idx is not paired with a FOM array
      fomarray = self.proc_arrays[fdx].deep_copy()
    (hklscenes, scenemaxdata,
      scenemindata, scenemaxsigmas,
        sceneminsigmas, scenearrayinfos
    ) = MakeHKLscene( self.proc_arrays[idx].deep_copy(), fomarray, idx, fdx,
                     self.renderscale, copy.deepcopy(self.params.hkls), self.mprint )
    for i,inf in enumerate(scenearrayinfos):
      self.mprint("%d, %s" %(idx+i+1, inf[3]), verbose=1)
      self.HKLsceneKey = self.Sceneid_to_SceneKey(sceneid)
      self.HKLscenedict[self.HKLsceneKey] =  group_args(scene = hklscenes[i],
                                                        maxdata = scenemaxdata[i],
                                                        mindata = scenemindata[i],
                                                        maxsigma = scenemaxsigmas[i],
                                                        minsigma = sceneminsigmas[i],
                                                        arrayinfo = inf)
      sceneid += 1
    self.HKLscene = self.HKLscenedict[self.HKLsceneKey].scene
    self.HKLscenesMaxdata = self.HKLscenedict[self.HKLsceneKey].maxdata
    self.HKLscenesMindata = self.HKLscenedict[self.HKLsceneKey].mindata
    self.HKLscenesMaxsigmas = self.HKLscenedict[self.HKLsceneKey].maxsigma
    self.HKLscenesMinsigmas = self.HKLscenedict[self.HKLsceneKey].minsigma
    self.hkl_scenes_info = self.HKLscenedict[self.HKLsceneKey].arrayinfo
    self.sceneisdirty = True
    self.has_new_miller_array = False
    self.mprint("Done constructing HKL scenes", verbose=1)
    return True


  def Sceneid_to_SceneKey(self, sceneid):
    return (self.params.spacegroup_choice,
                      self.params.using_space_subgroup,
                      self.params.hkls.expand_anomalous,
                      self.params.hkls.expand_to_p1,
                      self.params.hkls.slice_axis,
                      self.params.hkls.slice_index,
                      self.params.hkls.show_missing,
                      self.params.hkls.show_only_missing,
                      self.params.hkls.show_systematic_absences,
                      self.params.hkls.sigma_color_radius,
                      self.params.hkls.color_scheme,
                      self.params.hkls.color_powscale,
                      sceneid,
                      self.params.hkls.scale,
                      self.params.hkls.nth_power_scale_radii
                      )


  def HKLscene_dict_val(self, sceneid=None):
    if sceneid is None:
      sceneid = self.params.viewer.scene_id
    HKLsceneKey = self.Sceneid_to_SceneKey(sceneid)
    if not self.HKLscenedict.get(HKLsceneKey, False):
      self.ConstructReciprocalSpace(scene_id=sceneid)
    return self.HKLscenedict[HKLsceneKey]


  def identify_suitable_fomsarrays(self):
    self.mprint("Matching complex arrays to suitable FOM arrays", verbose=1)
    self.mapcoef_fom_dict = {}
    self.sceneid_from_arrayid = []
    for k,proc_array in enumerate(self.proc_arrays):
      fom_arrays_idx = []
      array_scene_ids = [(k,-1)] # using -1 to indicate not paired with a fom array
      for i,foms_array in enumerate(self.proc_arrays):
        if not proc_array.is_complex_array() or not foms_array.is_real_array():
          continue
        if proc_array.size() != foms_array.size():
          continue
        if  min(foms_array.data()) < 0.0 or flex.max(foms_array.data()) > 1.0:
          continue
        fom_arrays_idx.append( (foms_array, i) )
        array_scene_ids.append((k,i))
      self.sceneid_from_arrayid.extend( array_scene_ids)
      self.mapcoef_fom_dict[proc_array.info().label_string()] = fom_arrays_idx


  def get_scene_id_from_label_or_type(self, datalabel, datatype=None):
    """ Try finding a matching sceneid to the datalabel provided. As a fallback
    try finding a sceneid for the first matching datatype regardless of its label
    """
    assert datalabel is not None
    for i,e in enumerate(self.hkl_scenes_infos):
      if e[3] == datalabel:
        return i
    if datatype is not None:
      for i,e in enumerate(self.hkl_scenes_infos):
        if e[4] == datatype:
          return i
    self.mprint("Currently no dataset with label %s or type %s" %(datalabel, datatype), verbose=1)
    return None


  def get_label_type_from_scene_id(self, sceneid):
    if sceneid is None:
      return None,None
    # Find data label and type for a particular sceneid
    assert sceneid < len(self.hkl_scenes_infos)
    datalabel = self.hkl_scenes_infos[sceneid][3]
    datatype = self.hkl_scenes_infos[sceneid][4]
    return datalabel, datatype


  def get_binner_idx_from_label(self, binlabel):
    for i,e in enumerate(self.bin_labels_type_idxs):
      if binlabel == e[0]:
        return i
    return -1


  def get_binlabel_from_binner_idx(self, idx):
    return self.bin_labels_type_idxs[idx][0]


  def scene_id_to_array_id(self, scene_id):
    for i,array_scene_id in enumerate(self.sceneid_from_arrayid):
      if scene_id == i:
        return array_scene_id[0]
    raise Sorry("scene_id, %d, is out of range" %scene_id)


  def scene_id_to_array_and_foms_id(self, scene_id):
    for i,array_scene_id in enumerate(self.sceneid_from_arrayid):
      if scene_id == i:
        return array_scene_id
    raise Sorry("scene_id, %s, is out of range" %scene_id)


  def calc_bin_thresholds(self, binner_idx, nbins):
    # make default bin thresholds if scene_bin_thresholds is not set
    binscenelabel = self.bin_labels_type_idxs[binner_idx][0]
    self.mprint("Using %s for binning" %binscenelabel)
    if binscenelabel=="Resolution":
      warray = self.HKLscene_dict_val().scene.work_array
      dres = self.HKLscene_dict_val().scene.dres
      uc = warray.unit_cell()
      indices = self.HKLscene_dict_val().scene.indices
      dmax,dmin = warray.d_max_min(d_max_is_highest_defined_if_infinite=True) # to avoid any F000 reflection
      if dmax == dmin: # say if only one reflection
        binvals = [dres[0]-0.1, dmin +0.1]
        nuniquevalues = 2
      else: # use generic binning function from cctbx
        binning = miller.binning( uc, nbins, indices, dmax, dmin )
        binvals = [ binning.bin_d_range(n)[0] for n in binning.range_all() ]
        binvals = [ e for e in binvals if e != -1.0] # delete dummy limit
        binvals = list( 1.0/flex.double(binvals) )
        nuniquevalues = len(set(list(dres)))
    elif "Singletons" in binscenelabel:
      binvals = [ -0.1, 0.1 ] # if this dataset hasn't got any singletons
      if len(set(list(self.scene.singletonsiness))) == 3: # symmetry unique anomalous data with some singletons
        binvals = [ -1.5, -0.5, 0.5, 1.5 ]
      nuniquevalues = len(binvals)
    else:
      bindata, dummy = self.get_matched_binarray(binner_idx)
      selection = flex.sort_permutation( bindata )
      bindata_sorted = bindata.select(selection)
      # First check for case where all unique values could be covered by
      # number of requested bins (e.g. multiplicity values)
      uniquevalues = list((set(list(bindata))))
      nuniquevalues = len(uniquevalues)
      if nuniquevalues <= nbins:
        uniquevalues.sort()
        binvals = [uniquevalues[0]-1]
        for ival in range(nuniquevalues):
          binvals.append(uniquevalues[ival])
        nuniquevalues = len(binvals)

      else:
        # Get binvals by dividing bindata_sorted with nbins
        # This yields approximately the same number of reflections in each bin
        binvals = [ bindata_sorted[0] ]
        nbins_used = 0
        float_data_used = 0.0
        num_per_bin = float(len(bindata_sorted))/nbins
        while nbins_used < nbins:
          index = round(float_data_used + num_per_bin) - 1
          threshold = bindata_sorted[index]
          # Handle case where there are a lot of repeated values
          float_data_used += num_per_bin
          if threshold > binvals[-1]:
            binvals.append(threshold)
            nbins_used += 1
          else:
            # Split remaining data over remaining requested bins
            num_per_bin = (float(len(bindata_sorted))-float_data_used)/(nbins-nbins_used)
        if bindata_sorted[-1] > binvals[-1]:
          binvals.append(bindata_sorted[-1])
        nuniquevalues = len(binvals)

    binvals.sort()
    self.mprint("Bin thresholds are:\n" + str(binvals), verbose=1)
    return binvals, nuniquevalues


  def UpdateBinValues(self, binner_idx, binvals = None, nuniquevalues = -1):
    if binvals:
      binvals.sort()
      self.binvals = binvals
    else: # ensure default resolution interval includes all data by avoiding rounding errors
      self.binvals = [ 1.0/(self.miller_array.d_max_min()[0]*1.001),
                       1.0/(self.miller_array.d_max_min()[1]*0.999) ]
    if nuniquevalues == -1:
      if binner_idx==0: # i.e. the resolution array of the hkls
        nuniquevalues = len(set(list( self.HKLscene_dict_val().scene.dres )))
      elif binner_idx==1:  # i.e. singletons
        binvals = [ -0.1, 0.1 ] # if this dataset hasn't got any singletons
        if len(set(list(self.scene.singletonsiness))) == 3: # symmetry unique anomalous data with some singletons
          binvals = [ -1.5, -0.5, 0.5, 1.5 ]
        nuniquevalues = len(binvals)
      else: # one of the normal datasets
        bindata, dummy = self.get_matched_binarray(binner_idx)
        nuniquevalues = len(set(list(bindata)))
    self.nuniqueval = nuniquevalues


  def get_matched_binarray(self, binner_idx):
    binscenelabel, datatype, sceneid = self.bin_labels_type_idxs[binner_idx]
    label = self.HKLscene_dict_val(sceneid).scene.work_array.info().label_string()
    if datatype == "hassigmas" and binscenelabel == "Sigmas of " + label:
      bindata = self.HKLscene_dict_val(sceneid).scene.sigmas.deep_copy()
      binvalsboundaries = [ self.HKLscene_dict_val(sceneid).minsigma - 0.1 , self.HKLscene_dict_val(sceneid).maxsigma + 0.1 ]
    elif datatype in "Map coeffs" and "Phases of " + label in binscenelabel:
      bindata = self.HKLscene_dict_val(sceneid).scene.phases.deep_copy()
      # preselect centric reflections, i.e. those with phi = 0 or 180
      binvalsboundaries = [-0.01, 0.01, 179.99, 180.01, 359.99, 360]
    elif datatype in "Map coeffs" and "Amplitudes of " + label in binscenelabel:
      bindata = self.HKLscene_dict_val(sceneid).scene.ampl.deep_copy()
      binvalsboundaries = [ self.HKLscene_dict_val(sceneid).mindata - 0.1 , self.HKLscene_dict_val(sceneid).maxdata + 0.1 ]
    else:
      bindata = self.HKLscene_dict_val(sceneid).scene.data.deep_copy()
      binvalsboundaries = [ self.HKLscene_dict_val(sceneid).mindata - 0.1 , self.HKLscene_dict_val(sceneid).maxdata + 0.1 ]
    return bindata, binvalsboundaries


  def MatchBinArrayToSceneArray(self):
    # match bindata with data or sigmas
    if self.bin_labels_type_idxs[self.params.binning.binner_idx][0] == "Resolution":
      return 1.0/self.scene.dres
    binarraydata, dummy = self.get_matched_binarray(self.params.binning.binner_idx)
    scenearraydata = self.HKLscene_dict_val().scene.data
    binlabel, _, ibinarray = self.bin_labels_type_idxs[self.params.binning.binner_idx]
    if len(set(self.HKLscene_dict_val(ibinarray).scene.indices)) < self.HKLscene_dict_val(ibinarray).scene.indices.size():
      raise Sorry("Error: The HKL indices in %s are not unique. Use a merged dataset instead!" %binlabel)
    matchindices = miller.match_multi_indices(self.HKLscene_dict_val(ibinarray).scene.indices,
                               self.HKLscene_dict_val().scene.indices )
    matched_binarray = binarraydata.select( matchindices.pairs().column(0) )
    # patch the bin array so its sequence matches the scene array
    patched_binarraydata = []
    c = 0
    for b in matchindices.pair_selection(1):
      if b:
        patched_binarraydata.append(matched_binarray[c])
        c +=1
      else:
        patched_binarraydata.append(float("nan"))
    return flex.double(patched_binarraydata)


  def OperateOn1MillerArray(self, millarr, operation):
    # lets user specify a python expression operating on millarr
    newarray = millarr.deep_copy()
    dres = newarray.unit_cell().d( newarray.indices() )
    try:
      ldic= {'dres': dres, 'array1': newarray, 'newarray': newarray }
      exec(operation, globals(), ldic)
      newarray = ldic.get("newarray", None)
      return newarray
    except Exception as e:
      raise Sorry(str(e))


  def OperateOn2MillerArrays(self, millarr1, millarr2, operation):
    # lets user specify a python expression operating on millarr1 and millarr2
    matchindices = miller.match_indices(millarr1.indices(), millarr2.indices() )
    matcharr1 = millarr1.select( matchindices.pairs().column(0) ).deep_copy()
    matcharr2 = millarr2.select( matchindices.pairs().column(1) ).deep_copy()
    dres = matcharr1.unit_cell().d( matcharr1.indices() )
    matcharr2._observation_type = millarr1._observation_type
    newarray = matcharr2.deep_copy()
    try:
      ldic= { 'dres': dres, 'array1': matcharr1, 'array2': matcharr2, 'newarray': newarray }
      exec(operation, globals(), ldic)
      newarray = ldic.get("newarray", None)
      return newarray
    except Exception as e:
      raise Sorry(str(e))


  def get_colour_map_radii_power(self):
    datatype = self.get_current_datatype_or_default_dict()
    colourscheme, colourpower, powerscale, radiiscale = \
        self.datatypedict.get( datatype, self.datatypedefault[:] )
    return colourscheme, colourpower, powerscale, radiiscale


  def add_colour_scheme_to_dict(self):
    datatype = self.get_current_datatype_or_default_dict()
    self.datatypedict[datatype][0] = self.params.hkls.color_scheme


  def add_colour_powscale_to_dict(self):
    datatype = self.get_current_datatype_or_default_dict()
    self.datatypedict[datatype][1] = self.params.hkls.color_powscale


  def add_nth_power_scale_radii_to_dict(self):
    datatype = self.get_current_datatype_or_default_dict()
    self.datatypedict[datatype][2] = self.params.hkls.nth_power_scale_radii


  def add_radii_scale_to_dict(self):
    datatype = self.get_current_datatype_or_default_dict()
    self.datatypedict[datatype][3] = self.params.hkls.scale


  def get_current_datatype_or_default_dict(self):
    datatype = self.get_current_datatype()
    if datatype is None:
      return
    if self.params.hkls.sigma_color_radius:
      datatype = datatype + "_sigmas"
    if datatype not in self.datatypedict.keys():
        # ensure individual copies of datatypedefault and not references to the same
      self.datatypedict[ datatype ] = self.datatypedefault[:]
    return datatype


  def DrawNGLJavaScript(self, blankscene=False):
    if not self.scene or not self.sceneisdirty:
      return
    if self.scene.points.size() == 0:
      blankscene = True
    if self.miller_array is None :
      self.mprint( "Select a dataset to display reflections" )
      blankscene = True
    else:
      self.mprint("Rendering reflections.", end="")

    if self.scene is not None and self.miller_array is not None: # expansion always done in the browser now
     assert (self.scene.settings.expand_to_p1==False and self.scene.settings.expand_anomalous==False)

    h_axis = flex.vec3_double([self.scene.axes[0]])
    k_axis = flex.vec3_double([self.scene.axes[1]])
    l_axis = flex.vec3_double([self.scene.axes[2]])
    self.unit_h_axis = 1.0/h_axis.norm() * h_axis
    self.unit_k_axis = 1.0/k_axis.norm() * k_axis
    self.unit_l_axis = 1.0/l_axis.norm() * l_axis
    self.unit_normal_hk = self.unit_h_axis.cross( self.unit_k_axis )
    self.unit_normal_kl = self.unit_k_axis.cross( self.unit_l_axis )
    self.unit_normal_lh = self.unit_l_axis.cross( self.unit_h_axis )
    self.normal_hk = h_axis.cross( k_axis )
    self.normal_kl = k_axis.cross( l_axis )
    self.normal_lh = l_axis.cross( h_axis )
    maxnorm = max(h_axis.norm(), max(k_axis.norm(), l_axis.norm()))
    l1 = self.renderscale * maxnorm * 1.1
    l2= self.renderscale * maxnorm * 1.15
    Hstararrowstart = roundoff( [-self.unit_h_axis[0][0]*l1, -self.unit_h_axis[0][1]*l1, -self.unit_h_axis[0][2]*l1] )
    Hstararrowend = roundoff( [self.unit_h_axis[0][0]*l1, self.unit_h_axis[0][1]*l1, self.unit_h_axis[0][2]*l1] )
    Hstararrowtxt  = roundoff( [self.unit_h_axis[0][0]*l2, self.unit_h_axis[0][1]*l2, self.unit_h_axis[0][2]*l2] )
    Kstararrowstart = roundoff( [-self.unit_k_axis[0][0]*l1, -self.unit_k_axis[0][1]*l1, -self.unit_k_axis[0][2]*l1] )
    Kstararrowend = roundoff( [self.unit_k_axis[0][0]*l1, self.unit_k_axis[0][1]*l1, self.unit_k_axis[0][2]*l1] )
    Kstararrowtxt  = roundoff( [self.unit_k_axis[0][0]*l2, self.unit_k_axis[0][1]*l2, self.unit_k_axis[0][2]*l2] )
    Lstararrowstart = roundoff( [-self.unit_l_axis[0][0]*l1, -self.unit_l_axis[0][1]*l1, -self.unit_l_axis[0][2]*l1] )
    Lstararrowend = roundoff( [self.unit_l_axis[0][0]*l1, self.unit_l_axis[0][1]*l1, self.unit_l_axis[0][2]*l1] )
    Lstararrowtxt  = roundoff( [self.unit_l_axis[0][0]*l2, self.unit_l_axis[0][1]*l2, self.unit_l_axis[0][2]*l2] )

    if not blankscene:
      self.params.hkls.color_scheme, self.params.hkls.color_powscale, self.params.hkls.nth_power_scale_radii, \
        self.params.hkls.scale = self.get_colour_map_radii_power()

      # Make colour gradient array used for drawing a bar of colours next to associated values on the rendered html
      mincolourscalar = self.HKLscene_dict_val().mindata
      maxcolourscalar = self.HKLscene_dict_val().maxdata
      if self.params.hkls.sigma_color_radius:
        mincolourscalar = self.HKLscene_dict_val().minsigma
        maxcolourscalar = self.HKLscene_dict_val().maxsigma
      span = maxcolourscalar - mincolourscalar
      ln = 120
      incr = span/ln
      colourgradarrays = []
      val = mincolourscalar
      colourscalararray = flex.double()
      colourscalararray.append( val )
      for j,sc in enumerate(range(ln)):
        val += incr
        colourscalararray.append( val )
      if self.HKLscene_dict_val().scene.miller_array.is_complex_array():
        # When displaying phases from map coefficients together with fom values
        # compute colour map chart as a function of fom and phase values (x,y axis)
        incr = 360.0/ln
        val = 0.0
        colourscalararray = flex.double()
        colourscalararray.append( val )
        for j in enumerate(range(ln)):
          val += incr
          colourscalararray.append( val )

        fomarrays = []
        COL = display.MplColorHelper(self.params.hkls.color_scheme, 0, 360)
        rgbcolarray = flex.vec3_double( [ COL.get_rgb(d)[0:3] for d in colourscalararray ] )

        if self.HKLscene_dict_val().scene.isUsingFOMs():
          fomln = 50
          fom = 1.0
          fomdecr = 1.0/(fomln-1.0)
          for j in range(fomln):
            fomarrays.append( flex.double(len(colourscalararray), fom) )
            fom -= fomdecr
          for j in range(fomln):
            arr = graphics_utils.map_to_rgb_colourmap(
                data_for_colors= colourscalararray,
                colormap= rgbcolarray,
                selection=flex.bool(colourscalararray.size(), True),
                attenuation = fomarrays[j]
              )
            colourgradarrays.append( arr*256 )
        else:
          fomln =1
          fomarrays = [1.0]
          arr = graphics_utils.map_to_rgb_colourmap(
              data_for_colors= colourscalararray,
              colormap = rgbcolarray,
              selection=flex.bool(colourscalararray.size(), True),
            )
          colourgradarrays.append(  arr*256 )
      else:
        fomln = 1
        fomarrays = [1.0]
        COL = display.MplColorHelper(self.params.hkls.color_scheme, mincolourscalar, maxcolourscalar)
        rgbcolarray = flex.vec3_double( [ COL.get_rgb(d)[0:3] for d in colourscalararray ])

        arr = graphics_utils.map_to_rgb_colourmap(
            data_for_colors= colourscalararray,
            colormap = rgbcolarray,
            selection=flex.bool(colourscalararray.size(), True),
            powscale = self.params.hkls.color_powscale
          )

        colourgradarrays.append(arr*256)
      colors = self.HKLscene_dict_val().scene.colors
      radii = self.HKLscene_dict_val().scene.radii
      self.meanradius = flex.mean(radii)

    bin_labels_type_idx = self.bin_labels_type_idxs[self.params.binning.binner_idx]
    self.mprint(".", end="")
    if blankscene:
      points = flex.vec3_double( [ ] )
      colors = flex.vec3_double( [ ] )
      radii = flex.double( [ ] )
      bin_labels_type_idx = self.bin_labels_type_idxs[0]
    else:
      points = self.scene.points

    nrefls = points.size()
    hkls = self.scene.indices
    dres = self.scene.dres
    if bin_labels_type_idx[0] =="Resolution":
      colstr = "dres"
    elif "Singletons" in bin_labels_type_idx[0]:
      colstr = "Singleton"
    else:
      if not blankscene:
        colstr = self.HKLscene_dict_val(bin_labels_type_idx[2]).scene.work_array.info().label_string()
    data = self.scene.data
    if not blankscene:
      colourlabel = self.HKLscene_dict_val().scene.colourlabel
      fomlabel = self.HKLscene_dict_val().scene.fomlabel
    #import code, traceback; code.interact(local=locals(), banner="".join( traceback.format_stack(limit=10) ) )
    assert (colors.size() == radii.size() == nrefls)
    self.colours = []
    self.positions = []
    self.radii2 = []
    self.spbufttips = []

    if not blankscene:
      if bin_labels_type_idx[0] =="Resolution":
        self.binvalsboundaries = self.binvals
        self.bindata = 1.0/self.scene.dres
      elif "Singletons" in bin_labels_type_idx[0]:
        self.binvalsboundaries = self.binvals
        self.bindata = self.scene.singletonsiness
      else:
        # get upper and lower bounds for the dataset used for binning
        self.bindata = self.MatchBinArrayToSceneArray()
        if ( len(self.binvalsboundaries)==0 or len(self.params.binning.scene_bin_thresholds) > 0):
          dummy, self.binvalsboundaries = self.get_matched_binarray(self.params.binning.binner_idx)
        # binvals derived from scene_bin_thresholds must be sorted
        # if minimum or maximum of binvals are smaller or bigger than lower or
        # upper bounds then use those values instead
        self.binvals.sort()
        vals = self.binvals[:]
        # ignoring nan values add binvalsboundaries if these are smaller or bigger than values in binvals
        nonanbinvals = [e for e in self.binvals if not math.isnan(e)]
        if nonanbinvals[0] > self.binvalsboundaries[0]:
          vals[0] = self.binvalsboundaries[0]
        if nonanbinvals[-1] < self.binvalsboundaries[1]:
          vals[-1] = self.binvalsboundaries[-1]
        # if nan values are present then sort with nan being the last value
        vals = list(set( vals)) # no duplicates
        self.binvalsboundaries = sorted(vals, key= lambda e: sys.maxsize if math.isnan(e) else e)

    self.nbinvalsboundaries = len(self.binvalsboundaries)
    # avoid resetting opacities of bins unless we change the number of bins
    if self.oldnbinvalsboundaries != self.nbinvalsboundaries and not self.executing_preset_btn:
      self.params.binning.bin_opacity = [ [1.0, e] for e in range(self.nbinvalsboundaries ) ]
    self.oldnbinvalsboundaries = self.nbinvalsboundaries
    # Un-binnable data are scene data values where there are no matching reflections in the bin data
    # Put these in a separate bin and be diligent with the book keeping!
    for ibin in range(self.nbinvalsboundaries+1): # adding the extra bin for un-binnable data
      self.colours.append([]) # colours and positions are 3 x size of data()
      self.positions.append([])
      self.radii2.append([])
      self.spbufttips.append([])

    def data2bin(d, binvalsboundaries, nbinvalsboundaries):
      for ibin, binval in enumerate(binvalsboundaries):
        if math.isnan(d): # NaN values are un-binnable. Tag them for an additional last bin
          return nbinvalsboundaries-1
        if (ibin+1) == nbinvalsboundaries:
          return ibin
        if d > binval and d <= binvalsboundaries[ibin+1]:
          return ibin
      raise Sorry("data2bin: Should never get here")

    def getprecision(v1,v2):
      diff = abs(v1-v2); precision = 1; e = 1
      while diff*e < 1.0 and diff > 0:
        e *= 10
        precision += 1
      return precision

    if nrefls > 0 and self.bindata.size() != points.size():
      raise Sorry("Not the same number of reflections in bin-data and displayed data")

    start_time = time.time()
    for i, hklstars in enumerate(points):
      # bin currently displayed data according to the values of another miller array
      ibin = data2bin( self.bindata[i], self.binvalsboundaries, self.nbinvalsboundaries )
      self.positions[ibin].extend( hklstars )
      self.colours[ibin].extend( colors[i] )
      self.radii2[ibin].append( radii[i] )
      self.spbufttips[ibin].append( i )

    elapsed_time = time.time() - start_time
    self.mprint("elapsed time: %s" %elapsed_time, verbose=1)

    if not blankscene:
      cntbin = 0
      self.binstrs = []
      self.bin_infotpls = []
      if self.nuniqueval < self.params.binning.nbins:
        self.mprint("%d bins was requested but %s data has only %d unique value(s)!" %(self.params.binning.nbins, colstr, self.nuniqueval), 0)
      for ibin in range(self.nbinvalsboundaries+1):
        mstr =""
        nreflsinbin = len(self.radii2[ibin])
        bin2 = float("nan"); bin1= float("nan") # indicates un-binned data
        if ibin == self.nbinvalsboundaries:
          mstr= "bin[%d] has %d reflections with no %s values (assigned to %2.3f)" %(cntbin, nreflsinbin, \
                  colstr, bin1)
        precision = 3
        if ibin < (self.nbinvalsboundaries-1):
          bin1 = self.binvalsboundaries[ibin]
          bin2 = self.binvalsboundaries[ibin+1]
          bin3 = bin2
          if ibin < (self.nbinvalsboundaries-2):
            bin3= self.binvalsboundaries[ibin+2]
          if colstr=="dres":
            bin1= 1.0/self.binvalsboundaries[ibin]
            bin2= 1.0/self.binvalsboundaries[ibin+1]
            if ibin < (self.nbinvalsboundaries-2):
              bin3= 1.0/self.binvalsboundaries[ibin+2]
          #calculate precision by comparing a bin value with bin value below and above it
          prec1 = getprecision(bin1, bin2)
          prec2 = prec1
          if bin2 != bin3:
            prec2 = getprecision(bin3, bin2)
          precision = max(prec1, prec2)
          # format bin values string with necessary decimal places (precision)
          binformatstr = "]%2." + str(precision) + "f; %2." + str(precision) + "f]"
          mstr= "bin[%d] has %d reflections with %s in " %(cntbin, nreflsinbin, colstr)
          mstr += binformatstr %(bin1, bin2)
        if len(self.bin_infotpls) > 0 \
         and math.isnan(self.bin_infotpls[-1][1]) \
         and math.isnan(self.bin_infotpls[-1][2])  \
         and nreflsinbin == 0:
          continue

        if nreflsinbin > 0 and not math.isnan(bin1) and not math.isnan(bin2):
          self.bin_infotpls.append( roundoff((nreflsinbin, bin1, bin2 ), precision) )
        self.binstrs.append(mstr)
        self.mprint(mstr, verbose=1)
        cntbin += 1

      if self.params.binning.bin_opacity != None:
        opqlist = self.params.binning.bin_opacity
        if len(opqlist) < self.params.binning.nbins-1:
          # an extra bin may be added when editing scene_bin_thresholds. If so, don't reset opacities to 1
          self.params.binning.bin_opacity = [ [1.0, e] for e in range(cntbin) ]

      self.params.binning.nbins = len(self.bin_infotpls)
      self.SendInfoToGUI( { "bin_opacity": self.params.binning.bin_opacity,
                            "bin_infotpls": self.bin_infotpls,
                            "binner_idx": self.params.binning.binner_idx,
                            "tooltip_opacity": self.params.NGL.tooltip_alpha
                           } )

      self.calc_rotation_axes()
      nvaluelabels = int(ln/self.params.viewer.ncolourlabels )
      colourgradstrs = []
      if self.params.hkls.sigma_color_radius:
        lst = list(colourscalararray)
        lst.reverse() # flip labels on chart when showing sigmas
        colourscalararray = flex.double(lst )

      # if displaying phases from map coefficients together with fom values then
      for g,colourgradarray in enumerate(colourgradarrays):
        self.colourgradientvalues = []
        for j,e in enumerate(colourgradarray):
          self.colourgradientvalues.append( [colourscalararray[j], e] )
        self.colourgradientvalues = roundoff( self.colourgradientvalues )
        fom = fomarrays[g]
        colourgradstr = []
        for j,val in enumerate(self.colourgradientvalues):
          vstr = "null"
          alpha = 1.0
          rgb = (int(val[1][0]), int(val[1][1]), int(val[1][2]) )
          if j % nvaluelabels == 0 or j==(len(self.colourgradientvalues)-1) :
            vstr = roundoff(val[0], 2)
          colourgradstr.append([vstr, rgb[0], rgb[1], rgb[2] ])
        colourgradstrs.append(colourgradstr)

    self.mprint(".", end="")
    if not self.WBmessenger.browserisopen:
      self.ReloadNGL()
      # if sempahore is not free then websocket failed to connect to a browser. Critical error!
      self.mprint("DrawNGLJavaScript waiting for browser_connect_sem semaphore", verbose="threadingmsg")
      if not self.browser_connect_sem.acquire(timeout= lock_timeout):
        raise HKLviewerError("Timed out connecting to a web browser after %s seconds. Ensure web browser security settings permit websocket protocol." %lock_timeout)
      self.mprint("DrawNGLJavaScript released browser_connect_sem", verbose="threadingmsg")
      self.browser_connect_sem.release()

    if self.verbosebrowser:
      self.SetBrowserDebug("true")

    if self.params.use_wireframe:
      self.UseWireFrame("true")
    else:
      self.UseWireFrame("false")

    if not blankscene: # and self.webgl_OK:
      self.RemoveStageObjects()
      self.SetFontSize(self.params.NGL.fontsize)
      self.SetVectorWidth(self.params.NGL.vector_width)
      for ibin in range(self.nbinvalsboundaries+1):
        nreflsinbin = len(self.radii2[ibin])
        self.DefineHKL_Axes(str(Hstararrowstart), str(Hstararrowend),
          str(Kstararrowstart), str(Kstararrowend),
          str(Lstararrowstart), str(Lstararrowend),
          Hstararrowtxt, Kstararrowtxt, Lstararrowtxt )
        self.SendCoordinates2Browser(self.positions[ibin], self.colours[ibin],
                                     self.radii2[ibin], self.spbufttips[ibin] )
      self.mprint(".", end="")
      self.RenderStageObjects()
      self.mprint(".", end="")
      self.MakeColourChart(colourlabel, fomlabel, colourgradstrs)
      self.GetClipPlaneDistances()
      self.SetMouseSpeed( self.params.NGL.mouse_sensitivity )
    self.sceneisdirty = False
    self.lastscene_id = self.params.viewer.scene_id
    self.SendInfoToGUI( { "CurrentDatatype": self.get_current_datatype(),
         "current_labels": self.get_current_labels() } )
    self.mprint("\nSubmitted reflections and other objects to browser for rendering.", verbose=1)


  def get_current_labels(self):
    return self.get_label_type_from_scene_id(self.params.viewer.scene_id)[0]


  def get_visible_current_miller_array(self):
    arrayidxs = []
    if self.miller_array and self.params.binning.bin_opacity:
      bin_opacitieslst = self.params.binning.bin_opacity
      for alpha,bin in bin_opacitieslst:
        ibin = int(bin)
        if ibin > self.nbinvalsboundaries:
          continue
        if alpha==1.0:
          arrayidxs.extend(self.spbufttips[ibin])
    visarray = self.miller_array.select_indices(flex.miller_index(
      # has to be a better way of doing this
                          [ self.miller_array.indices()[i] for i in arrayidxs ] ))
    return visarray.deep_copy()


  def release_all_semaphores(self):
    # avoid potential deadlock by releasing any pending sempahores
    self.clipplane_msg_sem.release()
    self.autoview_sem.release()
    self.mousespeed_msg_sem.release()
    self.hkls_drawn_sem.release()
    self.browser_connect_sem.release()
    self.mprint( "All sempahores released", verbose="threadingmsg")


  def ProcessBrowserMessage(self, message):
    # Runs in WebsocketClientMessageThread handling messages from the browser displaying our reflections
    # started in webbrowser_messenger_py3
    try:
      if sys.version_info[0] > 2:
        ustr = str
      else:
        ustr = unicode
      if isinstance(message, bytes) and isinstance(self.lastmsg, ustr) and "Imageblob" in self.lastmsg:
        self.mprint( "Saving image to %s" %self.imagename, verbose=0)
        with open( self.imagename, "wb") as imgfile:
          imgfile.write( message)
      philchanged = False
      if isinstance(message, ustr) and message != "":
        if 'Critical WebGL problem' in message:
          self.mprint(message + "\n\nCommencing initiation of protocols for invoking program termination procedures...\n", verbose=0)
          self.webgl_OK = False
          self.SendInfoToGUI( { "closing_time": True } )
        elif 'Browser.JavaScript' in message:
          self.mprint( message, verbose=1)
        elif "JavaScriptError" in message:
          self.mprint( message, verbose=0)
          self.release_all_semaphores()
        elif "Orientation" in message:
          self.ProcessOrientationMessage(message)
        elif 'WebGL' in message:
          self.mprint( message, verbose=1)
        elif "websocket" in message:
          self.mprint( message, verbose=1)
        elif "Refreshing" in message or "disconnecting" in message:
          self.mprint( message, verbose=1)
          time.sleep(self.sleeptime)
        elif "AutoViewSet" in message:
          self.set_volatile_params()
          self.mprint( message, verbose=3)
        elif "SetAutoView" in message:
          self.mprint( message, verbose=3)
        elif "AutoViewFinished_AfterRendering" in message:
          self.mprint("ProcessBrowserMessage, %s released autoview_sem" %message, verbose="threadingmsg")
          self.autoview_sem.release()
        elif "JavaScriptCleanUpDone:" in message:
          self.mprint( message, verbose=1)
          time.sleep(0.5) # time for browser to clean up
          if not self.isnewfile:
            self.WBmessenger.StopWebsocket()
        elif "Expanded rotation operator" in message:
          self.mprint( message, verbose="expansionmsg")
        elif "Expand" in message:
          self.mprint( message, verbose=2)
        elif "Connection lost" in message:
          self.mprint( message, verbose=1)
        elif "Warning!: Web browser closed unexpectedly" in message:
          self.mprint( message, verbose=1)
        elif "ToggleAnimation" in message:
          vecnr,speed = eval(self.params.viewer.animate_rotation_around_vector)
          speed = -speed # negative speed tells HKLjavascripts to pause animating
          self.params.viewer.animate_rotation_around_vector = "[%s, %s]" %(vecnr,speed)
          philchanged = True
          self.parent.SendCurrentPhilValues() # update GUI to correspond to current phil parameters
        elif "Imageblob" in message:
          self.mprint( "Image blob to be received", verbose=1)
        elif "ImageWritten" in message:
          self.mprint( "Image blob sent to CCTBX", verbose=1)
          self.mprint("ProcessBrowserMessage, ImageWritten released self.hkls_drawn_sem", verbose="threadingmsg")
          self.hkls_drawn_sem.release()
        elif "ClipPlaneDistancesSet" in message:
          if self.use_semaphore:
            self.mprint("ProcessBrowserMessage, ClipPlaneDistancesSet released clipplane_msg_sem", verbose="threadingmsg")
            self.clipplane_msg_sem.release() # as was set by make_clip_plane
        elif "ExpandedInBrowser_AfterRendering" in message:
          if self.use_semaphore:
            self.mprint("ProcessBrowserMessage, ExpandedInBrowser released clipplane_msg_sem", verbose="threadingmsg")
            self.clipplane_msg_sem.release() # as was set by make_clip_plane
        elif "ReturnClipPlaneDistances:" in message:
          datastr = message[ message.find("\n") + 1: ]
          lst = datastr.split(",")
          flst = [float(e) for e in lst[0:4]]
          self.clipNear = flst[0]
          self.clipFar = flst[1]
          self.cameraPosZ = flst[2]
          self.zoom = flst[3]
          calledby = lst[4]
          self.mprint("ReturnClipPlaneDistances(%s): cameraPosZ: %s, zoom: %s" %(calledby, self.cameraPosZ, self.zoom), verbose="orientmsg")
          if self.use_semaphore:
            if calledby == "GetClipPlaneDistances": # only unlock if requested by GetClipPlaneDistances()
              self.mprint("ProcessBrowserMessage, ReturnClipPlaneDistances released hkls_drawn_sem", verbose="threadingmsg")
              self.hkls_drawn_sem.release()
              self.mprint("ProcessBrowserMessage, ReturnClipPlaneDistances released clipplane_msg_sem", verbose="threadingmsg")
              self.clipplane_msg_sem.release()
              self.mprint("ProcessBrowserMessage, ReturnClipPlaneDistances released autoview_sem", verbose="threadingmsg")
              self.autoview_sem.release()
            if calledby == "RotateStage": # only unlock if requested by GetClipPlaneDistances()
              self.mprint("ProcessBrowserMessage, RotateStage released clipplane_msg_sem", verbose="threadingmsg")
              self.clipplane_msg_sem.release()
        elif "ReturnMouseSpeed" in message:
          datastr = message[ message.find("\n") + 1: ]
          lst = datastr.split(",")
          flst = [float(e) for e in lst]
          if flst[0] is not None and not cmath.isnan(flst[0]):
            self.params.NGL.mouse_sensitivity = flst[0]
          if self.use_semaphore:
            self.mprint("ProcessBrowserMessage, ReturnMouseSpeed released mousespeed_msg_sem", verbose="threadingmsg")
            self.mousespeed_msg_sem.release()
        elif "tooltip_id:" in message:
          ttipids = message.split("tooltip_id:")[1]
          hklid = eval(message.split("tooltip_id:")[1])[0]
          sym_id = eval(message.split("tooltip_id:")[1])[1]
          ttip = self.GetTooltipOnTheFly(hklid, sym_id)
          self.AddToBrowserMsgQueue("ShowThisTooltip", ttip)
        elif "match_hkl_id:" in message:
          hklid = eval(message.split("match_hkl_id:")[1])[0]
          sym_id = eval(message.split("match_hkl_id:")[1])[1]
          if self.sg.info().symbol_and_number() == self.miller_array.space_group().info().symbol_and_number():
            self.make_visual_symHKLs(hklid, sym_id)
            self.visualise_sym_HKLs()
            hkl = self.scene.indices[abs(hklid)]
            hklmatches = miller.match_indices(self.parent.origarrays["HKLs"], [hkl])
            orig_hkl_ids = list(hklmatches.pairs().column(0))
            self.SendInfoToGUI( { "clicked_HKL": hkl, "orig_hkl_ids": orig_hkl_ids })
        elif "onClick colour chart" in message:
          self.onClickColourChart()
        elif "SelectedBrowserDataColumnComboBox" in message:
          sceneid = int(message.split(":")[1])
          self.parent.SetScene(sceneid)
        elif "InFrustum:" in message:
          # if GetReflectionsInFrustum() finds no reflections
          # then message="InFrustum::" which crashes eval(). Avoid this
          if "InFrustum::" not in message:
            hklids = eval(message.split(":")[1])
            rotids = eval(message.split(":")[2])
            self.visible_hkls = []
            self.outsideplane_hkls = []
            for i,hklid in enumerate(hklids):
              hkl, _ = self.get_rothkl_from_IDs(hklid, rotids[i])
              self.visible_hkls.append(hkl)
              if self.normal_vecnr != -1 and self.params.clip_plane.is_assoc_real_space_vector and \
                self.planescalarvalue != (self.planenormalhklvec[0]*hkl[0] + self.planenormalhklvec[1]*hkl[1] + self.planenormalhklvec[2]*hkl[2]):
                self.outsideplane_hkls.append(hkl)
            self.visible_hkls = list(set(self.visible_hkls))
            self.outsideplane_hkls = list(set(self.outsideplane_hkls))
            self.mprint( "visible hkls: " + str(self.visible_hkls), verbose="frustum")
            if len(self.outsideplane_hkls):
              self.mprint("hkls not satisfying plane equation: " + str(self.outsideplane_hkls))
              self.mprint("Consider reducing the clip plane width on the \"Slicing\" tab")
          self.mprint( message, verbose=3)
        elif "notify_cctbx_AfterRendering" in message:
          if self.use_semaphore:
            self.mprint("ProcessBrowserMessage, notify_cctbx_AfterRendering released self.hkls_drawn_sem", verbose="threadingmsg")
            self.hkls_drawn_sem.release()
          self.GetReflectionsInFrustum()
        elif "MoveClipPlanesUp" in message:
          self.params.clip_plane.hkldist += 1
          self.visual_symHKLs = []
          self.set_volatile_params(use_semaphore=False)
          philchanged = True
        elif "MoveClipPlanesDown" in message:
          self.params.clip_plane.hkldist -= 1
          self.visual_symHKLs = []
          self.set_volatile_params(use_semaphore=False)
          philchanged = True
        elif "RenderStageObjects" in message: # reflections have been drawn
          if self.use_semaphore:
            self.mprint("RenderStageObjects() has drawn reflections in the browser", verbose=1)
            self.hkls_drawn_sem.release()
        elif "Ready " in message:
          self.mprint( message, verbose=5)
        if philchanged:
          self.parent.SendCurrentPhilValues() # update GUI to correspond to current phil parameters
    except Exception as e:
      self.mprint( to_str(e) + "\n" + traceback.format_exc(limit=10), verbose=0)
    self.lastmsg = message


  def GetCameraPosRotTrans(self, viewmtrx):
    lst = viewmtrx.split(",")
    flst = [float(e) for e in lst]
    ScaleRotMx = matrix.sqr( (flst[0], flst[4], flst[8],
                          flst[1], flst[5], flst[9],
                          flst[2], flst[6], flst[10]
                          )
    )
    cameratranslation = (flst[12], flst[13], flst[14])
    self.mprint("translation: %s" %str(roundoff(cameratranslation)), verbose="orientmsg")
    alllst = roundoff(flst)
    self.mprint("""Orientation matrix:
  %s,  %s,  %s,  %s
  %s,  %s,  %s,  %s
  %s,  %s,  %s,  %s
  %s,  %s,  %s,  %s
Distance: %s
    """ %tuple(alllst), verbose="orientmsg")
    rotdet = ScaleRotMx.determinant()
    if rotdet <= 0.0:
      self.mprint("Negative orientation matrix determinant!!", verbose=1)
      self.SetAutoView() # return old values as a fall back even if they're out of date
      return self.cameraPosZ, self.currentRotmx, self.cameratranslation
    else:
      cameradist = math.pow(rotdet, 1.0/3.0)
    self.mprint("Scale distance: %s" %roundoff(cameradist), verbose="orientmsg")
    currentRotmx = matrix.identity(3)
    if cameradist > 0.0:
      currentRotmx = ScaleRotMx/cameradist
      cameraPosZ = cameradist
    return cameraPosZ, currentRotmx, cameratranslation


  def ProcessOrientationMessage(self, message):
    if self.params.viewer.scene_id is None or self.miller_array is None:
      return
    if message.find("NaN")>=0 or message.find("undefined")>=0 or message.find("Browser.JavaScript")>=0:
      return
    msgname = message[ 0 : message.find("\n")-1]
    self.viewmtrx = message[ message.find("\n") + 1: ]
    if "OrientationBeforeReload:" in message:
      if not self.isnewfile:
        self.lastviewmtrx = self.viewmtrx
      self.isnewfile = False
    self.cameraPosZ, self.currentRotmx, self.cameratranslation = self.GetCameraPosRotTrans( self.viewmtrx)
    rotlst = roundoff(self.currentRotmx.elems, 4)
    self.mprint(msgname + """, Rotation matrix:
  %s,  %s,  %s
  %s,  %s,  %s
  %s,  %s,  %s
    """ %rotlst, verbose="orientmsg")
    uc = self.miller_array.unit_cell()
    OrtMx = matrix.sqr( uc.fractionalization_matrix() )
    InvMx = OrtMx.inverse()
    # Our local coordinate system has x-axis pointing right and z axis pointing out of the screen
    # unlike threeJS so rotate the coordinates emitted from there before presenting them
    Xvec = matrix.rec([1,0,0], n=(1,3))
    Yvec = matrix.rec([0,1,0], n=(1,3))
    Zvec = matrix.rec([0,0,1], n=(1,3))

    RotAroundYMx = matrix.sqr([-1.0,0.0,0.0, 0.0,1.0,0.0, 0.0,0.0,-1.0])
    Xhkl = list(InvMx.transpose()*self.currentRotmx.inverse()* RotAroundYMx.transpose()* Xvec.transpose())
    Yhkl = list(InvMx.transpose()*self.currentRotmx.inverse()* RotAroundYMx.transpose()* Yvec.transpose())
    Zhkl = list(InvMx.transpose()*self.currentRotmx.inverse()* RotAroundYMx.transpose()* Zvec.transpose())

    if self.debug:
      self.SendInfoToGUI( { "StatusBar": "RotMx: %s, X: %s, Y: %s, Z: %s" \
        %(str(roundoff(self.currentRotmx,4)), str(roundoff(Xhkl, 2)),
                                              str(roundoff(Yhkl, 2)),
                                              str(roundoff(Zhkl, 2))),
                           }
                         )
    else:
      self.SendInfoToGUI( { "StatusBar": "X: %s , Y: %s , Z: %s" %(str(roundoff(Xhkl, 2)),
                                                     str(roundoff(Yhkl, 2)),
                                                     str(roundoff(Zhkl, 2))),
                           } )
    if "MouseMoved_Orientation:" in message:
      self.mouse_moved = True
    if self.currentRotmx.is_r3_rotation_matrix():
      # Round off matrix elements to avoid machine imprecision errors that might cast
      # any matrix element into a number strictly larger than 1 which would
      # crash r3_rotation_matrix_as_x_y_z_angles()
      self.currentRotmx = matrix.sqr(roundoff(self.currentRotmx.elems, 8) )
      angles = self.currentRotmx.r3_rotation_matrix_as_x_y_z_angles(deg=True)
      self.mprint(msgname + ", angles: %s" %str(roundoff(angles)), verbose=3)
      z_vec = flex.vec3_double( [(0,0,1)])
      self.rot_zvec = z_vec * self.currentRotmx
      self.mprint(msgname + ", Rotated cartesian Z direction : %s" %str(roundoff(self.rot_zvec[0])), verbose=3)
      rfracmx = matrix.sqr( self.miller_array.unit_cell().reciprocal().fractionalization_matrix() )
      self.rot_recip_zvec = self.rot_zvec * rfracmx
      self.rot_recip_zvec = (1.0/self.rot_recip_zvec.norm()) * self.rot_recip_zvec
      self.mprint(msgname + ", Rotated reciprocal L direction : %s" %str(roundoff(self.rot_recip_zvec[0])), verbose=3)


  def OpenBrowser(self):
    if self.params.viewer.scene_id is not None and not self.WBmessenger.websockclient \
       and not self.WBmessenger.browserisopen or self.isnewfile:
      # don't block in case we're called again and first time failed conecting to a browser
      self.browser_connect_sem.acquire(blocking = False)
      with open(self.hklfname, "w") as f:
        f.write( self.htmlstr )
      self.url = "file:///" + os.path.abspath( self.hklfname )
      self.url = self.url.replace("\\", "/")
      self.mprint( "Writing %s and connecting to its websocket client..." %self.hklfname, verbose=1)
      # ensure websockets server starts before the webbrowser loads page with javascript websocket client
      self.mprint("OpenBrowser waiting for listening_sem.acquire", verbose="threadingmsg")
      if not self.WBmessenger.listening_sem.acquire(blocking=True, timeout=lock_timeout):
        self.mprint("Error! Timed out waiting for listening_sem semaphore within %s seconds" %lock_timeout, verbose=1)
      self.mprint("OpenBrowser got listening_sem", verbose="threadingmsg")
      self.WBmessenger.listening_sem.release()
      self.mprint("OpenBrowser released listening_sem", verbose="threadingmsg")
      time.sleep(0.5)

      if self.UseOSBrowser=="default":
        if not self.webctrl.open(self.url):
          self.mprint("Could not open the default web browser")
          return False
      if self.UseOSBrowser != "default" and self.UseOSBrowser != "":
        subprocess.run('"' + self.browserpath + '" ' + self.url + ' &',
                       shell=True,
        # the following flags ensures external browser process doesn't hang during regression tests
                       capture_output=False,  # regression test wants to capture stdout/stderr
                       stdout=subprocess.DEVNULL,
                       stderr=subprocess.DEVNULL)
      self.SendInfoToGUI({ "html_url": self.url } )
      return True
    return False


  def on_browser_connection(self):
    try:
      self.browser_connect_sem.release()
      self.mprint("on_browser_connection released browser_connect_sem", verbose="threadingmsg")
      self.WBmessenger.browserisopen = True
      self.mprint("Successfully connected to browser", verbose=1)
    except ValueError as e:
      self.mprint( "Trying to reload webpage in browser", verbose=0)
      self.ReloadNGL()
    except Exception as e:
      self.mprint( to_str(e) + "\n" + traceback.format_exc(limit=10), verbose=0)


  def GetReflectionsInFrustum(self):
    msg = str(self.max_reflections_in_frustum)
    self.AddToBrowserMsgQueue("GetReflectionsInFrustum", msg)


  def RedrawNGL(self):
    self.AddToBrowserMsgQueue("Redraw")


  def ReloadNGL(self): # expensive as javascript may be several Mbytes large
    self.mprint("Rendering JavaScript...", verbose=1)
    if not self.OpenBrowser():
      self.AddToBrowserMsgQueue("Reload")


  def set_show_tooltips(self):
    msg = "%s" %self.params.NGL.show_tooltips
    self.AddToBrowserMsgQueue("DisplayTooltips", msg)


  def set_tooltip_opacity(self):
    msg = "%f" %self.params.NGL.tooltip_alpha
    self.AddToBrowserMsgQueue("TooltipOpacity", msg)


  def set_background_colour(self, r,g,b):
    msg = "rgb(%d, %d, %d)" %(r,g,b)
    self.AddToBrowserMsgQueue("BackgroundColour", msg)


  def set_opacity(self, bin, alpha):
    if bin > self.nbinvalsboundaries-1:
      return "There are only %d bins present\n" %self.nbinvalsboundaries
    msg = "%d, %f" %(bin, alpha)
    self.AddToBrowserMsgQueue("alpha", msg)
    return "Opacity %s set on bin[%d]\n" %(alpha, bin)


  def JavaScriptCleanUp(self, ):
    self.AddToBrowserMsgQueue("JavaScriptCleanUp")


  def ExpandInBrowser(self):
    """
    Expansion of reflections stored in an assymetric unit wedge defined by the spacegroup is
    done by applying the rotation matrices defined by the spacegroup on the reflections.
    Applying these matrices on all reflections is done much faster in WebGL in the browser.
    Before sending the rotation matrices to the browser first convert them into cartesian
    coordinates.
    """
    if self.sceneisdirty:
      self.mprint( "Not expanding in browser", verbose=1)
      return
    uc = self.miller_array.unit_cell()
    OrtMx = matrix.sqr( uc.orthogonalization_matrix())
    InvMx = OrtMx.inverse()
    msgtype = "Expand"
    msg = ""
    unique_rot_ops = []
    if self.params.hkls.expand_to_p1:
      msgtype += "P1"
      unique_rot_ops = self.symops[ 0 : self.sg.order_p() ] # avoid duplicate rotation matrices
      retmsg = "Expanding to P1 in browser"
      if not self.miller_array.is_unique_set_under_symmetry():
        retmsg += "\nNot all reflections are in the same asymmetric unit in reciprocal space.\n"
        retmsg += "Some reflections might be displayed on top of one another.\n"
      self.mprint( retmsg, verbose=1)
    else:
      unique_rot_ops = [ self.symops[0] ] # No P1 expansion. So only submit the identity matrix
    if self.params.hkls.expand_anomalous and not self.miller_array.anomalous_flag():
      msgtype += "Friedel"
      self.mprint( "Expanding Friedel mates in browser", verbose=1)
    for i, symop in enumerate(unique_rot_ops):
      RotMx = matrix.sqr( symop.r().as_double())
      ortrot = (OrtMx * RotMx * InvMx).as_mat3()
      if RotMx.is_r3_identity_matrix():
        # avoid machine precision rounding errors converting 1.0 to 0.99999999..
        ortrot = (1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0)
      str_rot = str(ortrot)
      str_rot = str_rot.replace("(", "")
      str_rot = str_rot.replace(")", "")
      msg += str_rot + "\n" # add rotation matrix to end of message string
    self.GuardedAddToBrowserMsgQueue(semaphorename="clipplane_msg_sem", msgtype=msgtype, msg=msg,
                                     funcname="ExpandInBrowser",  posteriorcheck=False)
    if self.use_semaphore:
      self.clipplane_msg_sem.release()
      self.mprint("ExpandInBrowser released clipplane_msg_sem", verbose="threadingmsg")

  def draw_sphere(self, s1, s2, s3, isreciprocal=True,
                  r=0, g=0, b=0, name="", radius = 1.0, mesh=False):
    """
    Place sphere at [s1, s2, s3]  with colour r,g,b. If name=="", the creation
    is deferred until draw_sphere is eventually called with name != "". These
    spheres are then joined in the same NGL representation.
    """
    uc = self.miller_array.unit_cell()
    vec = (s1*self.renderscale, s2*self.renderscale, s3*self.renderscale)
    #svec = list(vec)
    if isreciprocal:
      # uc.reciprocal_space_vector() only takes integer miller indices so compute the cartesian coordinates
      # for floating valued miller indices with the transpose of the fractionalization matrix
      vec = list( vec * matrix.sqr(uc.fractionalization_matrix()).transpose() )
      svec = [ vec[0], vec[1], vec[2] ]
    else: # real space fractional values
      vec = list( vec * matrix.sqr(uc.orthogonalization_matrix()) )
      vscale =  1.0/self.renderscale
      # TODO: find suitable scale factor for displaying real space vector together with reciprocal vectors
      svec = [ vscale*vec[0], vscale*vec[1], vscale*vec[2] ]
    self.draw_cartesian_sphere(svec[0], svec[1], svec[2], r, g, b, name, radius, mesh)


  def draw_cartesian_sphere(self, s1, s2, s3, r=0, g=0, b=0, name="", radius = 1.0, mesh=False):
    self.mprint("cartesian sphere is at: %s" %(str(roundoff([s1, s2, s3]))), verbose=2)
    self.AddToBrowserMsgQueue("DrawSphere", "%s;; %s;; %s;; %s;; %s;; %s;; %s;; %s;; %s" \
         %(s1, s2, s3, r, g, b, radius, name, int(mesh)) )
    if name=="":
      self.mprint("deferred rendering sphere at (%s, %s, %s)" %(s1, s2, s3), verbose=2)


  def draw_vector(self, s1, s2, s3, t1, t2, t3, isreciprocal=True, label="",
                  r=0, g=0, b=0, name="", radius=1.0, labelpos=0.8, autozoom = True):
    """
    Place vector from [s1, s2, s3] to [t1, t2, t3] with colour r,g,b and label
    If name=="" creation is deferred until draw_vector is eventually called with name != ""
    These vectors are then joined in the same NGL representation
    """
    uc = self.miller_array.unit_cell()
    vec1 = (s1*self.renderscale, s2*self.renderscale, s3*self.renderscale)
    vec2 = (t1*self.renderscale, t2*self.renderscale, t3*self.renderscale)
    #svec = list(vec)
    if isreciprocal:
      # uc.reciprocal_space_vector() only takes integer miller indices so compute the cartesian coordinates
      # for floating valued miller indices with the transpose of the fractionalization matrix
      vec1 = list( vec1 * matrix.sqr(uc.fractionalization_matrix()).transpose() )
      vec2 = list( vec2 * matrix.sqr(uc.fractionalization_matrix()).transpose() )
      svec1 = [ vec1[0], vec1[1], vec1[2] ]
      svec2 = [ vec2[0], vec2[1], vec2[2] ]
    else: # real space fractional values
      vec1 = list( vec1 * matrix.sqr(uc.orthogonalization_matrix()) )
      vec2 = list( vec2 * matrix.sqr(uc.orthogonalization_matrix()) )
      vscale =  1.0/self.renderscale
      # TODO: find suitable scale factor for displaying real space vector together with reciprocal vectors
      svec1 = [ vscale*vec1[0], vscale*vec1[1], vscale*vec1[2] ]
      svec2 = [ vscale*vec2[0], vscale*vec2[1], vscale*vec2[2] ]
    self.draw_cartesian_vector(svec1[0], svec1[1], svec1[2], svec2[0], svec2[1], svec2[2],
                            label, r, g, b, name, radius, labelpos, autozoom)


  def draw_cartesian_vector(self, s1, s2, s3, t1, t2, t3, label="",
                            r=0, g=0, b=0, name="", radius = 1.0, labelpos=0.8, autozoom = True ):
    self.mprint("cartesian vector is: %s to %s" %(str(roundoff([s1, s2, s3])), str(roundoff([t1, t2, t3]))), verbose="vector")
    rad = radius #self.params.NGL.vector_width
    self.AddToBrowserMsgQueue("DrawVector", "%s;;%s;;%s;;%s;;%s;;%s;;%s;;%s;;%s;;%s;;%s;;%s;;%s;;%s" \
         %(s1, s2, s3, t1, t2, t3, r, g, b, label, name, rad, labelpos, autozoom) )
    if name=="":
      self.mprint("deferred rendering vector from (%s, %s, %s) to (%s, %s, %s)" %(s1, s2, s3, t1, t2, t3), verbose=2)


  def get_cartesian_vector_angles(self, s1, s2, s3, t1, t2, t3):
    self.mprint("in get cartesian angles", verbose="angles")
    svec = [t1-s1, t2-s2, t3-s3]
    svecnorm = math.sqrt( svec[0]*svec[0] + svec[1]*svec[1] + svec[2]*svec[2] )
    xyvec = svec[:] # deep copying
    xyvec[2] = 0.0 # projection vector of svec in the xy plane
    xyvecnorm = math.sqrt( xyvec[0]*xyvec[0] + xyvec[1]*xyvec[1] )
    output = io.StringIO()
    if xyvecnorm > 0.0 and not approx_equal(xyvecnorm/svecnorm, 0.0, out=output):
      angle_x_xyvec = math.acos( xyvec[0]/xyvecnorm )*180.0/math.pi
      angle_y_xyvec = math.acos( xyvec[1]/xyvecnorm )*180.0/math.pi
    else:
      angle_x_xyvec = 90.0
      angle_y_xyvec = 90.0
    self.mprint(output.getvalue(), verbose="angles")
    output.close()
    yzvec = svec[:]
    yzvec[0] = 0.0 # projection vector of svec in the yz plane
    yzvecnorm = math.sqrt( yzvec[1]*yzvec[1] + yzvec[2]*yzvec[2] )

    output = io.StringIO()
    if yzvecnorm > 0.0 and not approx_equal(yzvecnorm/svecnorm, 0.0, out=output):
      angle_y_yzvec = math.acos( yzvec[1]/yzvecnorm )*180.0/math.pi
      angle_z_yzvec = math.acos( yzvec[2]/yzvecnorm )*180.0/math.pi
    else:
      angle_y_yzvec = 90.0
      angle_z_yzvec = 90.0
    self.mprint(output.getvalue(), verbose="angles")
    output.close()
    angle_x_svec = math.acos( svec[0]/svecnorm )*180.0/math.pi
    angle_y_svec = math.acos( svec[1]/svecnorm )*180.0/math.pi
    angle_z_svec = math.acos( svec[2]/svecnorm )*180.0/math.pi
    if angle_y_svec > 90.0:
      angle_x_xyvec = -angle_x_xyvec
    self.mprint("angles in xy plane to x,y axis are: %s, %s" %(angle_x_xyvec, angle_y_xyvec), verbose="angles")
    self.mprint("angles in yz plane to y,z axis are: %s, %s" %(angle_y_yzvec, angle_z_yzvec), verbose="angles")
    self.mprint("angles to x,y,z axis are: %s, %s, %s" %(angle_x_svec, angle_y_svec, angle_z_svec ), verbose=2)
    return angle_x_xyvec, angle_z_svec


  def PointVectorPerpendicularToScreen(self, angle_x_xyvec, angle_z_svec):
    rotmx = self.Euler2RotMatrix(( angle_x_xyvec, angle_z_svec + 180.0, 0.0 ))
    if rotmx.determinant() < 0.99999:
      self.mprint("Rotation matrix determinant is less than 1")
      return rotmx
    self.currentRotmx = rotmx
    self.RotateMxStage(rotmx)
    return rotmx


  def PointVectorParallelToScreen(self, angle_x_xyvec, angle_z_svec):
    rotmx = self.Euler2RotMatrix(( angle_x_xyvec, angle_z_svec + 90.0, 90.0 ))
    if rotmx.determinant() < 0.99999:
      self.mprint("Rotation matrix determinant is less than 1")
      return rotmx
    self.currentRotmx = rotmx
    self.RotateMxStage(rotmx)
    return rotmx


  def GetVectorAndAngleFromRotationMx(self, rot, ma=None, rectify_improper_rotation=True):
    # rectify_improper_rotation should be False when used for Xtriage rotations as
    # they may mistakenly be seen as being improper rotations
    RotMx = matrix.sqr(rot.as_double())
    if ma==None:
      ma = self.miller_array
    uc = ma.unit_cell()
    spg = ma.space_group()
    OrtMx = matrix.sqr( uc.orthogonalization_matrix())
    InvMx = OrtMx.inverse()
    ortrotmx = (OrtMx * RotMx * InvMx)
    isProperRotation = True
    ortrot = ortrotmx.as_mat3()
    label=""
    order = 0
    if not ortrotmx.is_r3_rotation_matrix() and rectify_improper_rotation:
      isProperRotation = False
      self.mprint("""Warning! The operation '%s' is not a proper rotation
in the space group %s\nwith unit cell %s""" \
        %(rot.as_hkl(), spg.info().symbol_and_number(), str(uc) ), verbose=2)
      self.mprint("Inverse of implied rotation matrix,\n%s\nis not equal to its transpose,\n%s" \
        %(str(roundoff(ortrotmx.inverse(),4)), str(roundoff(ortrotmx.transpose(),4))), verbose=2)
      improper_vec_angle = scitbx.math.r3_rotation_axis_and_angle_from_matrix(ortrot)
      self.mprint("\nTrying to find nearest orthonormal matrix approximtion", verbose=2)
      Rmx = matrix.find_nearest_orthonormal_matrix(ortrotmx)
      self.mprint("New suggested rotation matrix is\n%s" %str(roundoff(Rmx,4)), verbose=2)
      if not Rmx.is_r3_rotation_matrix() or (Rmx - ortrotmx).norm_sq() > 0.5:
      # norm_sq of a rotation matrix should be 3. Deviating from that indicates improper rotation
        self.mprint("Failed finding an approximate rotation matrix for \"%s\" in %s" \
         %(rot.as_hkl(), spg.info().symbol_and_number()), verbose=1)
        return (0,0,0), 0.0, label, order
      ortrotmx = Rmx
    ortrot = ortrotmx.as_mat3()
    r11,r12,r13,r21,r22,r23,r31,r32,r33 = ortrot
    theta =  math.acos(roundoff((r11+r22+r33-1.0)*0.5, 10))
    rotaxis = flex.vec3_double([(0,0,0)])
    self.mprint(str(ortrot), verbose=2)
    vec_angle = scitbx.math.r3_rotation_axis_and_angle_from_matrix(ortrot)
    rotaxis = flex.vec3_double([ vec_angle.axis ])
    if not isProperRotation:
      # Divine revelation: The new proper rotation from above axis is halfway
      # of being correctly aligned so subtract it from twice the improper axis
      # to get the desired rotation axis vector
      improp_rotaxis = flex.vec3_double([ improper_vec_angle.axis ])
      rotaxis = 2*rotaxis - improp_rotaxis
      # for debugging deduce the corresponding rotation matrix from this new axis
      usedrotmx = scitbx.math.r3_rotation_axis_and_angle_as_matrix( rotaxis[0], theta )
      self.mprint("Final proper rotation matrix:\n%s" %str(roundoff(matrix.sqr(usedrotmx),4)), verbose=1)
    ## adjust the length of the rotation axes to be compatible with the sphere of reflections
    if abs(theta) > 0.0001 and rotaxis.norm() > 0.01: # avoid nullvector
      order = int(roundoff(2*math.pi/theta, 0)) # how many times to rotate before its the identity operator
      forder = roundoff(2*math.pi/theta, 2)
      label = "%s-fold" %str(order)
    return list((rotaxis)[0]), theta, label, order


  def calc_rotation_axes(self, ma=None):
    if ma is not None:
      self.sg = ma.space_group()
      self.symops = list(self.sg.all_ops())
    if self.sg:
      unique_rot_ops = self.symops[ 0 : self.sg.order_p() ] # avoid duplicate rotation matrices
      self.rotation_operators = []
      for i,op in enumerate(unique_rot_ops): # skip the last op for javascript drawing purposes
        (cartvec, a, label, order) = self.GetVectorAndAngleFromRotationMx( rot=op.r(), ma=ma )
        if label != "":
          vs = 1+len(self.rotation_operators)/20
          cartvec[0] *= vs
          cartvec[1] *= vs
          cartvec[2] *= vs
          self.mprint( str(i) + ": " + str(roundoff(cartvec)) + ", " + label, verbose=1)
          veclength = math.sqrt( cartvec[0]*cartvec[0] + cartvec[1]*cartvec[1] + cartvec[2]*cartvec[2] )
          self.rotation_operators.append( (label + "#%d"%i, order , cartvec, op.r().as_hkl(), "", "", veclength) )


  def show_all_vectors(self):
    for (opnr, label, order, cartvec, hklop, hkl, abc, length) in self.all_vectors:
      self.show_labelled_vector(self.params.viewer.show_all_vectors==1, label, order, cartvec, hklop, autozoom=False)


  def show_vector(self, val, isvisible, autozoom=True):
    # val can be either the number (zero offset) of the vector in the list of vectors
    # or the label name of the vector in the list of vectors
    mag=1
    if isinstance(val, int):
      if val >= len(self.all_vectors):
        return str([])
      (opnr, label, order, cartvec, hklop, hkl, abc, length) = self.all_vectors[val]
      scale = 1
      if len(abc) > 0:
        mag = self.realSpaceMag
      if len(hkl) > 0:
        mag = self.recipSpaceMag
      self.show_labelled_vector(isvisible, label, order, cartvec, hklop,
                                autozoom=autozoom, mag=mag)
      if not isvisible:
        self.params.viewer.show_all_vectors = 0
      return str([val, isvisible])
    if isinstance(val, str):
      for i,(opnr, label, order, cartvec, hklop, hkl, abc, length) in enumerate(self.all_vectors):
        #if val in label: # so that user_vector.label="twin" declared for a preset button will match "2-fold_mytwin"
        if val == label:
          if len(abc) > 0:
            mag = self.realSpaceMag
          if len(hkl) > 0:
            mag = self.recipSpaceMag
          self.show_labelled_vector(isvisible, label, order, cartvec, hklop,
                                    autozoom=autozoom, mag=mag)
          if not isvisible:
            self.params.viewer.show_all_vectors = 0
          return str([i, isvisible])
    raise Sorry("No vector present with label or index: %s" %val)


  def show_vectors(self, philvectors, diff_phil):
    # autozoom may cause deadlock with unreleased semaphore clipplane_msg_sem
    # if more than 1 vectors are to be drawn at once. Avoid that.
    m = re.findall("(True)", str(philvectors)) # are there more than 1 vectors to be drawn?
    doautozoom = True
    if len(m) > 1 or self.params.clip_plane.clip_width: # don't autozoom if we are clipping
      doautozoom = False

    self.visual_symmxs = []
    self.visual_symHKLs = []

    for i,ivec in enumerate(philvectors):
      try:
        [val, isvisible] = eval(ivec)
        # in case val is the label for one of the vectors let show_vector() find the
        #  corresponding number and reassign ivec to "[number, bool]"
        if has_phil_path(diff_phil, "animate_rotation_around_vector"):
          # don't zoom if also initiating animation from this set of phil parameters
          ivec = self.show_vector(val, isvisible, autozoom=False)
        else:
          val2 = isvisible and doautozoom
          #if val2:
            #if not self.autoview_sem.acquire(blocking=True, timeout=lock_timeout):
            #  self.mprint("Error! Timed out waiting for autoview_sem semaphore within %s seconds" %lock_timeout, verbose=1)
            #self.mprint("show_vectors got autoview_sem", verbose="threadingmsg")
          ivec = self.show_vector(val, isvisible, autozoom=val2)
        philvectors[i] = ivec
      except Exception as e:
        pass


  def show_labelled_vector(self, isvisible, label, order, cartvec, hklop, autozoom=True, mag=1):
    # avoid onMessage-DrawVector in HKLJavaScripts.js misinterpreting the commas in strings like "-x,z+y,-y"
    name = label + "_" + hklop.replace(",", "_")
    if isvisible:
      self.currentrotvec = cartvec # cartesian vector to display and used for aligning
      if order > 0 and hklop != "":
# if this is a rotation operator deduce the group of successive rotation matrices it belongs to
        rt = sgtbx.rt_mx(symbol= hklop, r_den=12, t_den=144)
        RotMx = matrix.sqr(rt.r().as_double() )
        self.visual_symmxs.append( (RotMx, rt.r().as_hkl()) )
        nfoldrotmx = RotMx
        nfoldrot = rt.r()
        self.visual_symmxs = []
        self.visual_symHKLs = []
        for n in range(order): # append successive rotations to self.visual_symmxs
          nfoldrotmx = RotMx * nfoldrotmx
          nfoldrot = nfoldrot.multiply( rt.r() )
          self.visual_symmxs.append( (nfoldrotmx, nfoldrot.as_hkl()) )
        # adjust the length of the rotation axes to be compatible with the sphere of reflections
        uc = self.miller_array.unit_cell()
        OrtMx = matrix.sqr( uc.orthogonalization_matrix())
        s = math.sqrt(OrtMx.transpose().norm_sq())*self.realspace_scale*mag
        self.currentrotvec = [s*cartvec[0], s*cartvec[1], s*cartvec[2]]
      self.currentrotvec = [mag*self.currentrotvec[0], mag*self.currentrotvec[1], mag*self.currentrotvec[2]]
      self.draw_cartesian_vector(0, 0, 0, self.currentrotvec[0], self.currentrotvec[1],
                                  self.currentrotvec[2], r=0.1, g=0.1,b=0.1,
                                  label=label, name=name, radius=0.8, labelpos=1.0, autozoom=autozoom)
    else:
      self.RemovePrimitives(name)
    self.RemovePrimitives("sym_HKLs") # delete other symmetry hkls from a previous rotation operator if any


  def visualise_sym_HKLs(self):
    self.RemovePrimitives("sym_HKLs")
    if len(self.visual_symHKLs):
      for i,(hkl,hklstr) in enumerate(self.visual_symHKLs):
        thkl = tuple(hkl)
        hklstr = "H,K,L: %d,%d,%d" %thkl
        if i < len(self.visual_symHKLs)-1:
          self.draw_vector(0,0,0, hkl[0],hkl[1],hkl[2], isreciprocal=True, label=hklstr, r=0.5, g=0.3, b=0.3,
                           radius=0.8, labelpos=1.0, autozoom = False)
        else: # supplying a name for the vector last graphics primitive draws them all
          self.draw_vector(0,0,0, hkl[0],hkl[1],hkl[2], isreciprocal=True, label=hklstr, name="sym_HKLs",
                           r=0.5, g=0.3, b=0.3, radius=0.8, labelpos=1.0, autozoom = False)


  def show_hkl(self, bigwireframe=True):
    """
    Draw a wireframe sphere around a reflection selected with a double click in
    the millerarraytable in the GUI
    """
    rad = self.HKLscene_dict_val().scene.max_radius*1.5
    if not bigwireframe:
      rad = self.HKLscene_dict_val().scene.min_radius*0.9
    self.RemovePrimitives("highlight_HKL")
    if self.params.viewer.show_hkl != "deselect":
      hkl = eval(self.params.viewer.show_hkl)
      if self.sg.info().symbol_and_number() == self.miller_array.space_group().info().symbol_and_number():
        self.draw_sphere(hkl[0],hkl[1],hkl[2], isreciprocal=True, name="highlight_HKL",
                          r=1, g=0.0, b=0.0, radius= rad, mesh=True)
      else:
        self.mprint("Cannot currently associate reflection in original space group with reflection in different space group.")
    self.params.viewer.show_hkl = "" # to allow clicking on the same entry in the millerarraytable


  def get_vectors_labels_from_ids(self, idvectorlst):
    labelveclst = []
    for idvecval in idvectorlst:
      try:
        id, some_val = eval(idvecval)
        if isinstance(id, int):
          for opnr, label, order, cartvec, hklop, hkl, abc, length in self.all_vectors:
            if opnr==id:
              labelveclst.append([label, some_val])
              break
        if isinstance(id, str):
          labelveclst.append([id, some_val])
      except Exception as e:
        pass
    return labelveclst


  def get_vecid_from_label(self, val ):
    vecnr = -1
    if isinstance(val, int):
      vecnr = val
    if isinstance(val, str):
      for i,(opnr, label, order, cartvec, hklop, hkl, abc, length) in enumerate(self.all_vectors):
        if val in label:
          vecnr = i
    if not (vecnr>=0 and vecnr < len(self.all_vectors)):
      raise Sorry("No vector present in file with label or index: %s" %val)
    return vecnr


  def rotate_around_numbered_vector(self):
    val, deg = eval(self.params.viewer.angle_around_vector)
    vecnr = self.get_vecid_from_label(val)
    self.rotate_components_around_cartesian_vector(self.all_vectors[vecnr][3], deg)
    return vecnr,deg


  def rotate_components_around_cartesian_vector(self, cartvec, deg):
    phi = cmath.pi*deg/180
    normR = math.sqrt(cartvec[0]*cartvec[0] + cartvec[1]*cartvec[1] + cartvec[2]*cartvec[2] )
    ux = cartvec[0]/normR
    uy = cartvec[1]/normR
    uz = cartvec[2]/normR
    self.RotateAxisComponents([ux,uy,uz], phi, True)


  def rotate_stage_around_cartesian_vector(self, cartvec, deg):
    phi = cmath.pi*deg/180
    normR = math.sqrt(cartvec[0]*cartvec[0] + cartvec[1]*cartvec[1] + cartvec[2]*cartvec[2] )
    ux = cartvec[0]/normR
    uy = cartvec[1]/normR
    uz = cartvec[2]/normR
    self.RotateAxisMx([ux,uy,uz], phi, True)


  def animate_rotate_around_vector(self):
    val, speed = eval(self.params.viewer.animate_rotation_around_vector)
    vecnr = -1
    vecnr = self.get_vecid_from_label(val)
    cartvec = self.all_vectors[vecnr][3]
    normR = math.sqrt(cartvec[0]*cartvec[0] + cartvec[1]*cartvec[1] + cartvec[2]*cartvec[2] )
    ux = cartvec[0]/normR
    uy = cartvec[1]/normR
    uz = cartvec[2]/normR
    self.AnimateRotateAxisComponents([ux,uy,uz], speed, True)
    return vecnr,speed


  def DrawUnitCell(self):
    if self.params.draw_real_space_unit_cell is False:
      self.RemovePrimitives("unitcell")
      self.mprint( "Removing real space unit cell", verbose=2)
      return
    rad = 0.8 # scale # * 0.05 #  1000/ uc.volume()
    self.draw_vector(0,0,0, self.realSpaceMag,0,0, False, label="a", r=0.5, g=0.8, b=0.8, radius=rad)
    self.draw_vector(0,0,0, 0,self.realSpaceMag,0, False, label="b", r=0.8, g=0.5, b=0.8, radius=rad)
    self.draw_vector(0,0,0, 0,0,self.realSpaceMag, False, label="c", r=0.8, g=0.8, b=0.5, radius=rad)
    self.draw_vector(self.realSpaceMag,0,0, self.realSpaceMag,self.realSpaceMag,0, False, r=0.8, g=0.5, b=0.8, radius=rad)
    self.draw_vector(0,self.realSpaceMag,0, self.realSpaceMag,self.realSpaceMag,0, False, r=0.5, g=0.8, b=0.8, radius=rad)
    self.draw_vector(0,0,self.realSpaceMag, self.realSpaceMag,0,self.realSpaceMag, False, r=0.5, g=0.8, b=0.8, radius=rad)
    self.draw_vector(0,0,self.realSpaceMag, 0,self.realSpaceMag,self.realSpaceMag, False, r=0.8, g=0.5, b=0.8, radius=rad)
    self.draw_vector(0,self.realSpaceMag,self.realSpaceMag, self.realSpaceMag,self.realSpaceMag,self.realSpaceMag, False, r=0.5, g=0.8, b=0.8, radius=rad)
    self.draw_vector(self.realSpaceMag,0,self.realSpaceMag, self.realSpaceMag,self.realSpaceMag,self.realSpaceMag, False, r=0.8, g=0.5, b=0.8, radius=rad)
    self.draw_vector(self.realSpaceMag,0,0, self.realSpaceMag,0,self.realSpaceMag, False, r=0.8, g=0.8, b=0.5, radius=rad)
    self.draw_vector(0,self.realSpaceMag,0, 0,self.realSpaceMag,self.realSpaceMag, False, r=0.8, g=0.8, b=0.5, radius=rad)
    self.draw_vector(self.realSpaceMag,self.realSpaceMag,0, self.realSpaceMag,self.realSpaceMag,self.realSpaceMag, False, r=0.8, g=0.8, b=0.5, radius=rad,
                     name="unitcell", autozoom=False)
    self.mprint( "Adding real space unit cell", verbose=1)


  def DrawReciprocalUnitCell(self):
    if self.params.draw_reciprocal_unit_cell is False:
      self.RemovePrimitives("reciprocal_unitcell")
      self.mprint( "Removing reciprocal unit cell", verbose=2)
      return
    rad = 0.8 # 0.05 * scale
    self.draw_vector(0,0,0, self.recipSpaceMag,0,0, label="a*", r=0.5, g=0.3, b=0.3, radius=rad)
    self.draw_vector(0,0,0, 0,self.recipSpaceMag,0, label="b*", r=0.3, g=0.5, b=0.3, radius=rad)
    self.draw_vector(0,0,0, 0,0,self.recipSpaceMag, label="c*", r=0.3, g=0.3, b=0.5, radius=rad)
    self.draw_vector(self.recipSpaceMag,0,0, self.recipSpaceMag,self.recipSpaceMag,0, r=0.3, g=0.5, b=0.3, radius=rad)
    self.draw_vector(0,self.recipSpaceMag,0, self.recipSpaceMag,self.recipSpaceMag,0, r=0.5, g=0.3, b=0.3, radius=rad)
    self.draw_vector(0,0,self.recipSpaceMag, self.recipSpaceMag,0,self.recipSpaceMag, r=0.5, g=0.3, b=0.3, radius=rad)
    self.draw_vector(0,0,self.recipSpaceMag, 0,self.recipSpaceMag,self.recipSpaceMag, r=0.3, g=0.5, b=0.3, radius=rad)
    self.draw_vector(0,self.recipSpaceMag,self.recipSpaceMag, self.recipSpaceMag,self.recipSpaceMag,self.recipSpaceMag, r=0.5, g=0.3, b=0.3, radius=rad)
    self.draw_vector(self.recipSpaceMag,0,self.recipSpaceMag, self.recipSpaceMag,self.recipSpaceMag,self.recipSpaceMag, r=0.3, g=0.5, b=0.3, radius=rad)
    self.draw_vector(self.recipSpaceMag,0,0, self.recipSpaceMag,0,self.recipSpaceMag, r=0.3, g=0.3, b=0.5, radius=rad)
    self.draw_vector(0,self.recipSpaceMag,0, 0,self.recipSpaceMag,self.recipSpaceMag, r=0.3, g=0.3, b=0.5, radius=rad)
    self.draw_vector(self.recipSpaceMag,self.recipSpaceMag,0, self.recipSpaceMag,self.recipSpaceMag,self.recipSpaceMag, r=0.3, g=0.3, b=0.5, radius=rad,
                     name="reciprocal_unitcell", autozoom=False)
    self.mprint( "Adding reciprocal unit cell", verbose=1)


  def GetUnitcellScales(self):
    spanmin, spanmax = ( self.miller_array.index_span().min(), self.miller_array.index_span().max())
    uc = self.miller_array.unit_cell()
    vec = (1.0, 1.0, 1.0)
    # uc.reciprocal_space_vector() only takes integer miller indices so compute
    # the cartesian coordinates for real valued miller indices with the transpose of the fractionalization matrix
    vec1 = vec * matrix.sqr(uc.fractionalization_matrix()).transpose()
    reciproc_bodydiagonal_length = vec1.length()
    reciprocspanmaxvec = spanmax * matrix.sqr(uc.fractionalization_matrix()).transpose()
    reciproc_spanmax_length = reciprocspanmaxvec.length()
    reciprocspanminvec = spanmax * matrix.sqr(uc.fractionalization_matrix()).transpose()
    reciproc_spanmin_length = reciprocspanminvec.length()
    reciprocspan_length = max(reciproc_spanmax_length, reciproc_spanmin_length)
    self.reciproc_scale = reciprocspan_length / reciproc_bodydiagonal_length
    # for real space vector
    vec2 = vec * matrix.sqr(uc.orthogonalization_matrix())
    bodydiagonal_length =  vec2.length()
    self.realspace_scale = self.renderscale * reciprocspan_length / bodydiagonal_length


  def real_space_associated_with_reciprocal_vector(self, hklvec):
    # Get corresponding real space vector (in real space units) to the hkl vector
    uc = self.miller_array.unit_cell()
    R= hklvec[0] * self.normal_kl + hklvec[1] * self.normal_lh - hklvec[2] * self.normal_hk
    return (R[0]*matrix.sqr(uc.orthogonalization_matrix()).inverse()) * self.renderscale
    #return hklvec * matrix.sqr(uc.orthogonalization_matrix())


  def reciprocal_from_real_space_vector(self, realspacevec):
    uc = self.miller_array.unit_cell()
    return matrix.sqr(uc.orthogonalization_matrix()).inverse() * realspacevec


  def reciprocal_associated_with_real_space_vector(self, hklvec):
    uc = self.miller_array.unit_cell()
    cartvec = hklvec * matrix.sqr(uc.fractionalization_matrix()).transpose()
    myhkl = matrix.sqr(uc.orthogonalization_matrix()).inverse() * cartvec * self.renderscale
    #hkl = myhkl[0] * self.normal_bc + myhkl[1] * self.normal_ca - myhkl[2] * self.normal_ab
    return myhkl



  def project_vector1_vector2(self, vec1, vec2):
    # cartesian projection of vec1 onto vec2
    L1 = math.sqrt( vec1[0]*vec1[0] + vec1[1]*vec1[1] + vec1[2]*vec1[2] )
    L2 = math.sqrt( vec2[0]*vec2[0] + vec2[1]*vec2[1] + vec2[2]*vec2[2] )
    dotproduct = vec1[0]*vec2[0] + vec1[1]*vec2[1] + vec1[2]*vec2[2]
    cosine = dotproduct/(L1*L2)
    projvec1 = (vec1[0]*cosine, vec1[1]*cosine, vec1[2]*cosine)
    projvec2 = (vec2[0]*cosine, vec2[1]*cosine, vec2[2]*cosine)
    return cosine, projvec1, projvec2


  def orient_vector_to_screen(self, cartvec):
    if cartvec is None:
      return
    angle_x_xyvec, angle_z_svec = self.get_cartesian_vector_angles(0, 0, 0,
                                                                    cartvec[0],
                                                                    cartvec[1],
                                                                    cartvec[2])
    cartveclength = math.sqrt(cartvec[0]*cartvec[0] + cartvec[1]*cartvec[1] + cartvec[2]*cartvec[2] )
    self.mprint( "cartveclength= %s" %roundoff(cartveclength), verbose=1)

    if self.params.viewer.is_parallel:
      self.PointVectorParallelToScreen(angle_x_xyvec, angle_z_svec)
    else:
      self.PointVectorPerpendicularToScreen(angle_x_xyvec, angle_z_svec)


  def fix_orientation(self):
    if self.params.viewer.fixorientation != "None":
      self.DisableMouseRotation()
    else:
      self.EnableMouseRotation()


  def make_clip_plane(self, hkldist=0.0, clipwidth=None):
    # create clip plane oriented parallel or perpendicular to abc vector
    if clipwidth is None:
      self.SetClipPlaneDistances(0, 0) # tells NGL not to do clipping
      return
    self.mprint("Applying clip plane to reflections", verbose=1)
    self.RemovePrimitives("clip_vector")
    if self.cameraPosZ is None or self.cameraPosZ == 1.0:
      self.GetClipPlaneDistances()
    if self.use_semaphore:
      if not self.clipplane_msg_sem.acquire(blocking=True, timeout=lock_timeout):
        self.mprint("Error! Timed out waiting for clipplane_msg_sem semaphore within %s seconds" %lock_timeout, verbose=1)
      self.mprint("make_clip_plane got clipplane_msg_sem", verbose="threadingmsg")
      if not self.autoview_sem.acquire(blocking=True, timeout=lock_timeout):
        self.mprint("Error! Timed out waiting for autoview_sem semaphore within %s seconds" %lock_timeout, verbose=1)
      self.mprint("make_clip_plane got autoview_sem", verbose="threadingmsg")
    halfdist = self.cameraPosZ + hkldist # self.viewer.boundingZ*0.5
    if clipwidth == 0.0:
      clipwidth = self.meanradius
    clipNear = halfdist - clipwidth # 50/self.viewer.boundingZ
    clipFar = halfdist + clipwidth  #50/self.viewer.boundingZ
    if self.use_semaphore:
      self.mprint("make_clip_plane released clipplane_msg_sem, autoview_sem", verbose="threadingmsg")
      self.clipplane_msg_sem.release()
      self.autoview_sem.release()
    self.SetClipPlaneDistances(clipNear, clipFar, -self.cameraPosZ, self.zoom)
    self.mprint("clipnear: %s, clipfar: %s, cameraZ: %s, zoom: %s" %(clipNear, clipFar, -self.cameraPosZ, self.zoom), verbose=1)


  def set_camera_type(self):
    self.AddToBrowserMsgQueue("SetCameraType", self.params.NGL.camera_type)


  def set_background_colour(self):
    self.AddToBrowserMsgQueue("BackgroundColour", self.params.NGL.background_colour)


  def get_labels_of_data_for_binning(self, arrayinfos):
    self.hkl_scenes_infos = []
    sceneid = 0
    for pidx,arrayinfo in enumerate(arrayinfos):
      hassigmas=True
      if math.isnan(arrayinfo.maxsigmas):
        hassigmas=False
      (dummy1, infolst, dummy2, dummy3), dummy4, dummy5 = arrayinfo.get_selected_info_columns_from_phil()

      fomsarrays_idx = [(None, None)]
      mextnd = self.mapcoef_fom_dict.get(infolst[0])
      if infolst[1] in ['Map coeffs'] and mextnd is not None:
        fomsarrays_idx.extend( mextnd )
      for (fomsarray, fidx) in fomsarrays_idx:
        lbl = arrayinfo.labelstr
        fomslabel = None
        if fomsarray:
          fomslabel = fomsarray.info().label_string()
          lbl = arrayinfo.labelstr + " + " + fomslabel
        self.hkl_scenes_infos.append([infolst, pidx, fidx, lbl, infolst[1], hassigmas, sceneid])
        sceneid += 1

    scenearraylabeltypes = [ (e[3], e[4], e[1], e[5], e[6]) for e in self.hkl_scenes_infos ]
    self.SendInfoToGUI({ "scene_array_label_types": scenearraylabeltypes, "NewHKLscenes" : True })

    self.bin_labels_type_idxs = []
    self.bin_labels_type_idxs.append(("Resolution",  "", -1 ))
    self.bin_labels_type_idxs.append(("Singletons (current data)", "", -1 ))
    for label,labeltype,idx,hassigmas,sceneid in scenearraylabeltypes:
      if labeltype not in  ["Map coeffs", "Map coeffs_fom", "HL coeffs"]:
        self.bin_labels_type_idxs.append((label, labeltype, sceneid))
      if hassigmas:
        self.bin_labels_type_idxs.append(("Sigmas of " + label, "hassigmas", sceneid))
      if labeltype == "Map coeffs":
        self.bin_labels_type_idxs.append(("Phases of " + label, labeltype, sceneid))
        self.bin_labels_type_idxs.append(("Amplitudes of " + label, labeltype, sceneid))

    self.SendInfoToGUI({ "bin_labels_type_idxs": self.bin_labels_type_idxs})

    self.mprint("Data can be binned according to:", verbose=1)
    for i,e in enumerate(self.bin_labels_type_idxs):
      self.mprint("%d, %s" %(i, e[0]), verbose=1)


  def get_binner_idx_from_label(self, binlabel):
    for i,e in enumerate(self.bin_labels_type_idxs):
      if binlabel == e[0]:
        return i
    return -1


  def SetFontSize(self, fontsize):
    msg = str(fontsize)
    self.AddToBrowserMsgQueue("SetFontSize", msg)


  def SetVectorWidth(self, vecwidth):
    msg = str(vecwidth)
    self.AddToBrowserMsgQueue("SetVectorWidth", msg)


  def UseWireFrame(self, iswireframe):
    msg = str(iswireframe)
    self.AddToBrowserMsgQueue("UseWireFrame", msg)


  def SetBrowserDebug(self, isdebug):
    msg = str(isdebug)
    self.AddToBrowserMsgQueue("SetBrowserDebug", msg)


  def SetMouseSpeed(self, trackspeed):
    msg = str(trackspeed)
    self.AddToBrowserMsgQueue("SetMouseSpeed", msg)
    #self.GetMouseSpeed() # TODO: fix wait time
    self.mprint("In SetMouseSpeed:\n" + "".join( traceback.format_stack(limit=4) ), verbose="stacktrace"  )


  def GetMouseSpeed(self):
    if self.use_semaphore:
      self.mprint("GetMouseSpeed waiting for mousespeed_msg_sem.acquire", verbose="threadingmsg")
      if not self.mousespeed_msg_sem.acquire(blocking=True, timeout=lock_timeout):
        self.mprint("Error! Timed out waiting for mousespeed_msg_sem semaphore within %s seconds" %lock_timeout, verbose=1)
      self.mprint("GetMouseSpeed got mousespeed_msg_sem", verbose="threadingmsg")
    self.params.NGL.mouse_sensitivity = None
    self.AddToBrowserMsgQueue("GetMouseSpeed", "")


  def SetClipPlaneDistances(self, near, far, cameraPosZ=None, zoom=None):
    if cameraPosZ is None:
      cameraPosZ = self.cameraPosZ
    if zoom is None:
      zoom= self.zoom
    msg = str(near) + ", " + str(far) + ", " + str(cameraPosZ) + ", " + str(zoom)
    self.GuardedAddToBrowserMsgQueue("clipplane_msg_sem", "SetClipPlaneDistances", msg,
                                     funcname="SetClipPlaneDistances", posteriorcheck=False)


  def GetClipPlaneDistances(self):
    if self.use_semaphore:
      self.mprint("GetClipPlaneDistances waiting for hkls_drawn_sem.acquire", verbose="threadingmsg")
      if not self.hkls_drawn_sem.acquire(timeout=lock_timeout):
        self.mprint("Error! Timed out waiting for hkls_drawn_sem semaphore within %s seconds" %lock_timeout, verbose=1)
      self.mprint("GetClipPlaneDistances got hkls_drawn_sem", verbose="threadingmsg")
      self.mprint("GetClipPlaneDistances waiting for autoview_sem.acquire", verbose="threadingmsg")
      if not self.autoview_sem.acquire(blocking=True, timeout=lock_timeout):
        self.mprint("Error! Timed out waiting for autoview_sem semaphore within %s seconds" %lock_timeout, verbose=1)
      self.mprint("GetClipPlaneDistances got autoview_sem", verbose="threadingmsg")

    self.clipNear = None
    self.clipFar = None
    self.cameraPosZ = None
    self.zoom = None # very first call will yield bogus zoom value
    self.GuardedAddToBrowserMsgQueue("clipplane_msg_sem", "GetClipPlaneDistances",
                                     funcname="GetClipPlaneDistances")



  def RemovePrimitives(self, reprname=""):
    self.AddToBrowserMsgQueue("RemovePrimitives", reprname )


  def SetAutoView(self):
    rotmx = self.Euler2RotMatrix( ( 0.0, 0.0, 0.0 ) )
    self.currentRotmx = rotmx
    self.RotateMxStage(rotmx)
    self.GuardedAddToBrowserMsgQueue("autoview_sem", "SetAutoView", funcname="SetAutoView")


  def SetDefaultOrientation(self):
    if self.params.clip_plane.clip_width and not self.isnewfile:
      # if self.params.clip_plane.clip_width
      # then we are clipping and using camerazoom instead of camera.position.z
      # Autoview used by SetDefaultOrientation will mess that up. So bail out.
      return
    self.GuardedAddToBrowserMsgQueue("autoview_sem", "SetDefaultOrientation",
                                     funcname="SetDefaultOrientation")


  def TestNewFunction(self):
    self.AddToBrowserMsgQueue("Testing")


  def MakeImage(self, filename):
    self.imagename = filename
    if self.use_semaphore:
      self.mprint("MakeImage waiting for hkls_drawn_sem semaphore", verbose="threadingmsg")
      if not self.hkls_drawn_sem.acquire(blocking=True, timeout=lock_timeout):
        self.mprint("MakeImage failed acquiring hkls_drawn_sem semaphore within %s seconds" %lock_timeout, verbose=1)
      self.mprint("MakeImage got hkls_drawn_sem semaphore", verbose="threadingmsg")
    self.AddToBrowserMsgQueue("MakeImage2", "HKLviewer.png,"+ str(sys.version_info[0]) )


  def DisableMouseRotation(self): # disable rotating with the mouse
    self.AddToBrowserMsgQueue("DisableMouseRotation")


  def EnableMouseRotation(self): # enable rotating with the mouse
    self.AddToBrowserMsgQueue("EnableMouseRotation")


  def UseCameraZoom(self): # disable zoom with the mouse use webgl camera zoom instead
    self.AddToBrowserMsgQueue("DisableZoomDrag")


  def UseZoomDrag(self): # enable zoom with the mouse
    self.AddToBrowserMsgQueue("EnableZoomDrag")


  def SimulateClick(self):
    self.AddToBrowserMsgQueue("SimulateClick")


  def ReOrientStage(self):
    if self.viewmtrx:
      self.AddToBrowserMsgQueue("SetAutoView", self.viewmtrx)


  def Euler2RotMatrix(self, eulerangles):
    eulerangles1 = eulerangles
    radangles = [e*math.pi/180.0 for e in eulerangles1]
    # scitbx is using ZYZ convention for euler angles
    # https://en.wikipedia.org/wiki/Euler_angles#Rotation_matrix
    RotMx = scitbx.math.euler_angles_as_matrix(radangles)
    return RotMx


  def RotateMxStage(self, rotmx, quietbrowser=True):
    if self.cameraPosZ is None:
      # in case HKLJavaScripts.onMessage() crashed and failed returning cameraPosZ
      self.GetClipPlaneDistances()
    if self.cameraPosZ is not None:
      if self.use_semaphore:
        self.mprint("RotateMxStage waiting for clipplane_msg_sem.acquire", verbose="threadingmsg")
        if not self.clipplane_msg_sem.acquire(blocking=True, timeout=lock_timeout):
          self.mprint("Error! Timed out waiting for clipplane_msg_sem semaphore within %s seconds" %lock_timeout, verbose=1)
        self.mprint("RotateMxStage got clipplane_msg_sem", verbose="threadingmsg")
      scaleRot = rotmx * self.cameraPosZ
      ortrot = scaleRot.as_mat3()
      str_rot = str(ortrot)
      str_rot = str_rot.replace("(", "")
      str_rot = str_rot.replace(")", "")
      str_rot = str_rot + ", " + str(self.zoom)
      msg = str_rot + ", quiet\n"
      if not quietbrowser:
        msg = msg + ", verbose\n"

      self.AddToBrowserMsgQueue("RotateStage", msg)


  def RotateAxisMx(self, vec, theta, quietbrowser=True):
    if self.cameraPosZ is None:
      return
    str_rot = str(list(vec)) + ", " + str(theta)
    str_rot = str_rot.replace("[", "")
    str_rot = str_rot.replace("]", "")
    msg = str_rot + ", quiet\n"
    if not quietbrowser:
      msg = str_rot + ", verbose\n"
    self.AddToBrowserMsgQueue("RotateAxisStage", msg)


  def RotateMxComponents(self, rotmx, quietbrowser=True):
    if self.cameraPosZ is None:
      return
    #scaleRot = rotmx * self.cameraPosZ
    ortrot = rotmx.as_mat3()
    str_rot = str(ortrot)
    str_rot = str_rot.replace("(", "")
    str_rot = str_rot.replace(")", "")
    msg = str_rot + ", quiet\n"
    if not quietbrowser:
      msg = str_rot + ", verbose\n"
    self.AddToBrowserMsgQueue("RotateComponents", msg)


  def RotateAxisComponents(self, vec, theta, quietbrowser=True):
    if self.cameraPosZ is None:
      return
    str_rot = str(list(vec)) + ", " + str(theta)
    str_rot = str_rot.replace("[", "")
    str_rot = str_rot.replace("]", "")
    msg = str_rot + ", quiet\n"
    if not quietbrowser:
      msg = str_rot + ", verbose\n"
    self.AddToBrowserMsgQueue("RotateAxisComponents", msg)


  def AnimateRotateAxisComponents(self, vec, speed, quietbrowser=True):
    if self.cameraPosZ is None:
      return
    str_rot = str(list(vec)) + ", " + str(speed)
    str_rot = str_rot.replace("[", "")
    str_rot = str_rot.replace("]", "")
    msg = str_rot + ", quiet\n"
    if not quietbrowser:
      msg = str_rot + ", verbose\n"
    self.AddToBrowserMsgQueue("AnimateRotateAxisComponents", msg)


  def RemoveStageObjects(self):
    self.AddToBrowserMsgQueue("RemoveStageObjects")


  def DefineHKL_Axes(self, Hstararrowstart, Hstararrowend, Kstararrowstart,
                     Kstararrowend, Lstararrowstart, Lstararrowend,
                     Hlabelpos, Klabelpos, Llabelpos):
    strdata = ""
    strdata += "%s\n\n" %str(Hstararrowstart)
    strdata += "%s\n\n" %str(Hstararrowend)
    strdata += "%s\n\n" %str(Kstararrowstart)
    strdata += "%s\n\n" %str(Kstararrowend)
    strdata += "%s\n\n" %str(Lstararrowstart)
    strdata += "%s\n\n" %str(Lstararrowend)
    strdata += "%s\n\n" %str(Hlabelpos)
    strdata += "%s\n\n" %str(Klabelpos)
    strdata += "%s\n\n" %str(Llabelpos)
    self.AddToBrowserMsgQueue("DefineHKL_Axes", strdata)


  def SendCoordinates2Browser(self, positions, colours, radii, ttipids ):
    # send data in binary format rather than string to browser for the sake of speed and
    # having to avoid rounding off numbers which is also slow
    self.AddToBrowserMsgQueue("AddHKLCoordinates", positions, binary=True)
    self.mprint(".", end="")
    self.AddToBrowserMsgQueue("AddHKLColours", colours, binary=True)
    self.mprint(".", end="")
    self.AddToBrowserMsgQueue("AddHKLRadii", radii, binary=True)
    self.mprint(".", end="")
    self.AddToBrowserMsgQueue("AddHKLTTipIds", ttipids, binary=True)


  def RenderStageObjects(self):
    self.GuardedAddToBrowserMsgQueue("hkls_drawn_sem", "RenderStageObjects", funcname="RenderStageObjects")


  def MakeColourChart(self, label, fomlabel, colourgradarray):
    msg = "%s\n\n%s\n\n%s" %(label, fomlabel, str(colourgradarray) )
    self.AddToBrowserMsgQueue("MakeColourChart", msg )


  def get_current_datatype(self):
    # Amplitudes, Map coeffs, weights, floating points, etc
    if self.params.viewer.scene_id is None:
      return None
    dtype = self.array_info_format_tpl[ self.scene_id_to_array_id(self.params.viewer.scene_id )][1][1]
    # if dtype is boring generic then use the name of the data column for dtype
    if dtype in ["Floating-point", "Integer"]:
      dtype = self.array_info_format_tpl[ self.scene_id_to_array_id(self.params.viewer.scene_id )][1][0]
    return dtype


  def onClickColourChart(self):
    # if running the GUI show the colour chart selection dialog
    self.SendInfoToGUI( { "ColourChart": self.params.hkls.color_scheme,
                          "ColourPowerScale": self.params.hkls.color_powscale,
                          "CurrentDatatype": self.get_current_datatype(),
                          "ShowColourMapDialog": 1
                         } )


  def MakeBrowserDataColumnComboBox(self):
    datcolstr = ""
    for i,lbl in enumerate(self.hkl_scenes_infos):
      datcolstr = datcolstr + ",".join(lbl[3]) + "\n" + str(i)
      if i < len(self.hkl_scenes_infos)-1:
        datcolstr = datcolstr + "\n\n"
    datcolstr = datcolstr + "\n\n" + str(self.params.viewer.scene_id)
    self.AddToBrowserMsgQueue("MakeBrowserDataColumnComboBox", datcolstr)




ngl_philstr = """
  mouse_sensitivity = 0.06
    .type = float
    .help = "Controls the speed of movement when adjusting view with the mouse"
  tooltip_alpha = 0.80
    .type = float
    .help = "Opacity of tooltips showing data values of reflections when clicking or hovering the mouse on reflections"
  vector_width = 5
    .type = int(value_min=1, value_max=30)
    .help = "Thickness of vectors and axes"
  fontsize = 9
    .type = int
    .help = "Font size for browser window displaying reflections"
  background_colour = 'rgb(127, 127, 127)'
    .type = str
    .help = "String of RGB colour values for the background of the browser"
  show_tooltips = none *click hover
    .type = choice
    .help = "Specifies whether tooltips for reflections should show by hovering or by clicking on a reflection" \
            "If the displayed data has a very large number of reflections it is best to select "click""
  camera_type = *orthographic perspective
    .type = choice
"""

NGLmaster_phil = libtbx.phil.parse( ngl_philstr )
NGLparams = NGLmaster_phil.fetch().extract()

def reset_NGLsettings():
  """
  Reset NGL settings to their default values as specified in the phil definition string
  """
  #global NGLmaster_phil
  #global ngl_philstr
  #global NGLparams
  NGLparams = NGLmaster_phil.fetch(source = libtbx.phil.parse( ngl_philstr) ).extract()


def NGLsettings():
  """
  Get a global phil parameters object containing some NGL settings
  """
  #global NGLparams
  return NGLparams









"""
# python2 code

from websocket_server import WebsocketServer
import threading, math
from time import sleep

nc = {}
def new_client(client, server):
  nc = client
  print "got a new client:", nc

def on_message(client, server, message):
    print message

#websocket.enableTrace(True)
server = WebsocketServer(7894, host='127.0.0.1')
server.set_fn_new_client(new_client)
server.set_fn_message_received(on_message)

wst = threading.Thread(target=server.run_forever)
wst.daemon = True
wst.start()

def LoopSendMessages():
  x = 0.0
  i=0
  while server.clients:
    nc = server.clients[0]
    x += 0.2
    alpha =  (math.cos(x) +1.0 )/2.0
    msg = u"alpha, 2, %f" %alpha
    server.send_message(server.clients[0], msg )
    r = (math.cos(x) +1.0 )/2.0
    g = (math.cos(x+1) +1.0 )/2.0
    b = (math.cos(x+2) +1.0 )/2.0
    msg = u"colour, 1, %d, %f, %f, %f" %(i,r,g,b)
    server.send_message(server.clients[0], msg )
    sleep(0.2)



"""


"""

# python3 code

# WS server example
import asyncio
import websockets

async def hello(websocket, path):
  while True:
    name = await websocket.recv()
    print(f"< {name}")
    greeting = f"Hello {name}!"
    await websocket.send(greeting)
    if name=="STOP":
      return
    await asyncio.sleep(0.2)

start_server = websockets.serve(hello, "localhost", 8765)
asyncio.get_event_loop().run_until_complete(start_server)
asyncio.get_event_loop().run_forever()



# WS client example
import asyncio
import websockets

async def hello():
  uri = "ws://localhost:8765"
  async with websockets.connect(uri) as websocket:
    while True:
      name = input("What's your name?\n" )
      await websocket.send(name)
      print(f"> {name}")
      greeting = await websocket.recv()
      print(f"< {greeting}")

asyncio.get_event_loop().run_until_complete(hello())

"""


 *******************************************************************************


 *******************************************************************************
crys3d/hklviewer/preset_buttons.py
from __future__ import absolute_import, division, print_function

buttonsdeflist = [
  ("Intensities", "Show Intensities", """
            viewer {
              data_array {
                label = "I,SIGI"
                datatype = "Intensity"
              }
            }
"""),

  ("amplitudes", "Show Amplitudes", """
            viewer {
              data_array {
                label = "FOBS,SIGFOBS"
                datatype = "Amplitude"
              }
            }
"""),
# ConstantAxesSliceIntens and ConstantAxesSliceAmpl rely on hard coded names "H-axis (1,0,0)", "K-axis (0,1,0)"
# and "L-axis (0,0,1)" being present in the list of vectors. The button PHIL parameter show_vector="['-axis', True]"
# will then entail comboboxes being created from where H, K or L axes can be selected. This is more compact
# than having threee separate buttons for each axes
  ("ConstantAxesSliceIntens", "Show plane of intensities with constant: ", """
          clip_plane {
            normal_vector = "-axis"
            is_assoc_real_space_vector = True
            clip_width = 1.184
          }
          viewer {
            data_array {
              label = 'I,SIGI'
              datatype = 'Intensity'
            }
            show_vector = "['-axis', True]"
            fixorientation = *vector None
          }
          hkls {
            expand_to_p1 = True
            expand_anomalous = True
          }
 """),

   ("ConstantAxesSliceAmpl", "Show plane of amplitudes with constant: ", """
          clip_plane {
            normal_vector = "-axis"
            is_assoc_real_space_vector = True
            clip_width = 1.184
          }
          viewer {
            data_array {
              label = 'FP,SIGFP'
              datatype = 'Amplitude'
            }
            show_vector = "['-axis', True]"
            fixorientation = *vector None
          }
          hkls {
            expand_to_p1 = True
            expand_anomalous = True
          }
"""),

("FoversigF", "F/SigF",
 """
          miller_array_operation = "('newarray._data= array1.data()/array1.sigmas()\\nnewarray._sigmas = None', 'FoverSigF', ['FOBS,SIGFOBS', 'Amplitude'], ['', ''])"
          viewer {
            data_array {
              label = "FoverSigF"
              datatype = "Amplitude"
            }
          }

 """),

("IoverSigI", "I/SigI",
 """
        miller_array_operation = "('newarray._data=array1.data()/array1.sigmas()\\nnewarray._sigmas = None', 'IoverSigI', ['I<<FSQ,SIGI<<FSQ', 'Intensity'], ['', ''])"
        binning {
          scene_bin_thresholds = -10000 1 2 3 4 5 460 793.55 2750
          binlabel = "IoverSigI"
          bin_opacity = 1 0
          bin_opacity = 1 1
          bin_opacity = 1 2
          bin_opacity = 1 3
          bin_opacity = 1 4
          bin_opacity = 1 5
          bin_opacity = 1 6
          bin_opacity = 1 7
          bin_opacity = 1 8
          bin_opacity = 1 9
          bin_opacity = 1 10
          nbins = 9
        }
        viewer {
          data_array {
            label = "IoverSigI"
            datatype = "Intensity"
          }
        }
 """),

("Evalues", "E-values",
 """
          miller_array_operation = "('newarray._data = array1.normalize().data()\\nnewarray._sigmas = None', 'E-values', ['FP', 'Amplitude'], ['', ''])"
          viewer {
            data_array {
              label = "E-values"
              datatype = "Amplitude"
            }
          }
 """),

("Merged", "Merged Intensities",
 """
      miller_array_operation = "('from crys3d.hklviewer import display2\\nnewarray = display2.MergeData( array1, show_anomalous_pairs=False)[0]\\nfrom cctbx.xray import observation_types\\nnewarray.set_observation_type( observation_types.intensity())', 'Imerge', ['I,SIGI','Intensity'], ['', ''])"
      viewer {
        data_array {
          label = "Imerge,SigImerge"
          datatype = "Intensity"
        }
      }

 """),

("Multiplicities", "Multiplicities",
 """
      miller_array_operation = "('from crys3d.hklviewer import display2\\nmultiplicities = display2.MergeData( array1, show_anomalous_pairs=False)[1]\\n# use double to avoid being interpreted as R-free\\nnewarray._data = multiplicities.data().as_double()\\nnewarray._indices = multiplicities.indices()\\nnewarray._sigmas = None\\nfrom cctbx.xray import observation_types\\nnewarray.set_observation_type(None)', 'multiplicity', ['I,SIGI','Intensity'], ['', ''])"
      viewer {
        data_array {
          label = "multiplicity"
          datatype = "Floating-point"
        }
      }

 """),

("INFO035", "INFO < 0.35 bits", """
        binning {
          scene_bin_thresholds = -1 0.35 0.7 1 1.25 1.85 17.59 100
          binlabel = 'INFO'
          bin_opacity = 1 0
          bin_opacity = 0 1
          bin_opacity = 0 2
          bin_opacity = 0 3
          bin_opacity = 0 4
          bin_opacity = 0 5
          bin_opacity = 0 6
          bin_opacity = 0 7
          nbins = 8
        }
        viewer {
          data_array {
            label = "INFO"
          }
        }
 """),

("InfoISigI05", "INFO > 0.2 bits and I/SigI < 0.5", """
        miller_array_operation = "('ISigIarray = array2.deep_copy()\\nISigIarray._data = array2.data()/array2.sigmas()\\nnewarray = array1.select(ISigIarray.data()<0.5)', 'INFO_ISigI_0.5', ['INFO', None], ['IOBS,SIGIOBS', 'Intensity'])"
        binning {
          scene_bin_thresholds = -0.1 0.2 nan nan
          binlabel = 'INFO_ISigI_0.5'
          bin_opacity = 0 0
          bin_opacity = 1 1
          bin_opacity = 1 2
          bin_opacity = 1 3
          nbins = 4
        }
        viewer {
          data_array {
            label = "INFO_ISigI_0.5"
            datatype = "Floating-point"
          }
        }
 """),
 # we omit datatype of INFO in miller_array_operation as to force validate_preset_buttons()
 # only to match an array that is labelled INFO
  ("aniso4", "Rotate around one anisotropy principal axis:", """
        real_space_unit_cell_scale_fraction = 0.9
        binning {
          binlabel = "ANISO"
          bin_opacity = 1 0
          bin_opacity = 1 1
          bin_opacity = 0 2
          bin_opacity = 0 3
          bin_opacity = 0 4
          bin_opacity = 0 5
          bin_opacity = 1 6
          bin_opacity = 1 7
          nbins = 8
        }
        viewer {
          animate_rotation_around_vector = "['Anisotropy', 5.0]"
          data_array {
            label = "ANISO"
            datatype = "Floating-point"
          }
          show_vector = "['Anisotropy', True]"
          is_parallel = True
          fixorientation = *vector None
        }
        hkls {
          expand_to_p1 = True
          expand_anomalous = True
        }
  """),

  ("aniso", "Show anisotropy principal axes", """
          draw_real_space_unit_cell = True
          real_space_unit_cell_scale_fraction = 0.9
          binning {
            binlabel = "ANISO"
            bin_opacity = 1 0
            bin_opacity = 1 1
            bin_opacity = 0 2
            bin_opacity = 0 3
            bin_opacity = 0 4
            bin_opacity = 0 5
            bin_opacity = 1 6
            bin_opacity = 1 7
            nbins = 8
          }
          viewer {
            data_array {
              label = "ANISO"
              datatype = "Floating-point"
            }
            show_vector = "['Anisotropy1', True]"
            show_vector = "['Anisotropy2', True]"
            show_vector = "['Anisotropy3', True]"
          }
          hkls {
            expand_to_p1 = True
            expand_anomalous = True
          }
  """),
  ("TNCSlayer_xtricorder", "Slice perpendicular to tNCS_xtricorder vector", """
          clip_plane {
            normal_vector = "tNCS_xtricorder"
            clip_width = 0.380397231
          }
          viewer {
            data_array {
              label = "TEPS"
              datatype = "Floating-point"
            }
            show_vector = "['tNCS_xtricorder', True]"
            fixorientation = *vector None
          }
          hkls {
            expand_to_p1 = True
            expand_anomalous = True
          }

"""),
  ("TNCSvecrotate_xtricorder", "Rotate around tNCS_xtricorder vector", """
            clip_plane {
              clip_width = 6
              auto_clip_width = False
            }
            viewer {
              data_array {
                label = "TEPS"
                datatype = "Floating-point"
              }
              show_vector = "['tNCS_xtricorder', True]"
              is_parallel = True
              fixorientation = *vector None
              animate_rotation_around_vector = "['tNCS_xtricorder', 5.0]"
            }
            hkls {
              expand_to_p1 = True
              expand_anomalous = True
            }
"""),
  ("TNCSlayer_xtriage", "Slice perpendicular to tNCS_xtriage vector", """
          clip_plane {
            normal_vector = "tNCS_xtriage"
            clip_width = 0.380397231
          }
          miller_array_operation = "('newarray._data = array1.normalize().data()\\nnewarray._sigmas = None', 'E-values', ['FP', 'Amplitude'], ['', ''])"
          viewer {
            data_array {
              label = "E-values"
              datatype = "Amplitude"
            }
            show_vector = "['tNCS_xtriage', True]"
            user_vector {
              label = "tNCS_xtriage"
            }
            fixorientation = *vector None
          }
          hkls {
            expand_to_p1 = True
            expand_anomalous = True
          }

"""),
  ("TNCSvecrotate_xtriage_F", "Rotate around tNCS_xtriage vector", """
            clip_plane {
              clip_width = 6
              auto_clip_width = False
            }
            miller_array_operation = "('newarray._data = array1.normalize().data()\\nnewarray._sigmas = None', 'E-values(F)', ['FP', 'Amplitude'], ['', ''])"
            viewer {
              data_array {
                label = "E-values(F)"
                datatype = "Amplitude"
              }
              show_vector = "['tNCS_xtriage', True]"
              user_vector {
                label = "tNCS_xtriage"
              }
              is_parallel = True
              fixorientation = *vector None
              animate_rotation_around_vector = "['tNCS_xtriage', 5.0]"
            }
            hkls {
              expand_to_p1 = True
              expand_anomalous = True
            }
"""),
  ("TNCSvecrotate_xtriage_I", "Rotate around tNCS_xtriage vector", """
            clip_plane {
              clip_width = 6
              auto_clip_width = False
            }
            miller_array_operation = "('newarray._data = array1.normalize().data()\\nnewarray._sigmas = None', 'E-values(I)', ['I', 'Intensity'], ['', ''])"
            viewer {
              data_array {
                label = "E-values(I)"
                datatype = "Amplitude"
              }
              show_vector = "['tNCS_xtriage', True]"
              user_vector {
                label = "tNCS_xtriage"
              }
              is_parallel = True
              fixorientation = *vector None
              animate_rotation_around_vector = "['tNCS_xtriage', 5.0]"
            }
            hkls {
              expand_to_p1 = True
              expand_anomalous = True
            }
"""),

  # If user defines a twin operator where the name of the operator contains the string "twin" this
  # button will become enabled.
  # Pressing this button will expand amplitude data to P1 and slice it with twin axis perpendicular
  # to the screen. One can then step through layers of reflections with the +/- buttons in the GUI
  ("TwinAxisampl", "Slice amplitudes perpendicular to twin axis", """

          clip_plane {
            hkldist = 0.0
            normal_vector = "twin"
            clip_width = 0.5
          }
          viewer {
            data_array {
              label = "F,SIGF"
              datatype = "Amplitude"
            }
            show_vector = "['twin', True]"
            user_vector {
              label = "twin"
            }
            fixorientation = *vector None
          }
          hkls {
            expand_to_p1 = True
            expand_anomalous = True
          }

  """),

  ("TwinAxisintens", "Slice intensities perpendicular to twin axis", """

          clip_plane {
            hkldist = 0.0
            normal_vector = "twin"
            clip_width = 0.5
          }
          viewer {
            data_array {
              label = "I,SIGI"
              datatype = "Intensity"
            }
            show_vector = "['twin', True]"
            user_vector {
              label = "twin"
            }
            fixorientation = *vector None
          }
          hkls {
            expand_to_p1 = True
            expand_anomalous = True
          }

  """),

]


 *******************************************************************************


 *******************************************************************************
crys3d/hklviewer/qt.py
from __future__ import absolute_import, division

try:
  import PyQt5
  # PyQt5
  from PyQt5 import ( QtCore, QtWidgets )   # special import
  from PyQt5.QtCore import  QAbstractTableModel, QCoreApplication, QMetaObject, QModelIndex, \
        QRect, Qt, QEvent, QItemSelectionModel, QUrl, QSize, QSettings, QTimer  # special import
  from PyQt5.QtWidgets import ( QAction, QAbstractItemView, QApplication, QCheckBox, QColorDialog, QComboBox,   # special import
        QDialog, QDockWidget, QDoubleSpinBox, QFileDialog, QFrame, QGridLayout, QGroupBox, QHeaderView,
        QHBoxLayout, QInputDialog, QLabel, QLineEdit, QMainWindow, QMenu, QMenuBar, QMessageBox,
        QPlainTextEdit, QAbstractScrollArea,
        QProgressBar, QPushButton, QRadioButton, QScrollArea, QScrollBar, QSizePolicy,
        QSlider, QSplitter, QSpinBox, QStatusBar, QStyleFactory, QTableView, QTableWidget,
        QTableWidgetItem, QTabWidget, QTextEdit, QTextBrowser, QWidget, QVBoxLayout )
  from PyQt5.QtGui import ( QBrush, QCloseEvent, QColor, QFont, QCursor, QDesktopServices, QIcon,    # special import
                           QKeySequence, QPalette, QTextDocument )
  from PyQt5.QtWebEngineWidgets import ( QWebEngineView, QWebEngineProfile, QWebEnginePage )   # special import

except Exception:
  # PySide2
  from PySide2 import ( QtCore, QtWidgets )   # special import
  from PySide2.QtCore import Qt, QEvent, QAbstractTableModel, QCoreApplication, QMetaObject, \
        QModelIndex, QUrl, QRect, QItemSelectionModel, QSize, QSettings, QTimer   # special import
  from PySide2.QtWidgets import ( QAction, QAbstractItemView, QApplication, QCheckBox, QColorDialog, QComboBox,   # special import
        QDialog, QDockWidget, QDoubleSpinBox, QFileDialog, QFrame, QGridLayout, QGroupBox, QHeaderView,
        QHBoxLayout, QInputDialog, QLabel, QLineEdit, QMainWindow, QMenu, QMenuBar,  QMessageBox,
        QPlainTextEdit, QAbstractScrollArea,
        QProgressBar, QPushButton, QRadioButton, QScrollArea, QScrollBar, QSizePolicy,
        QSlider, QSplitter, QSpinBox, QStatusBar, QStyleFactory, QTableView, QTableWidget,
        QTableWidgetItem, QTabWidget, QTextEdit, QTextBrowser, QWidget, QVBoxLayout )
  from PySide2.QtGui import ( QBrush, QCloseEvent, QColor, QFont, QCursor, QDesktopServices, QIcon,    # special import
                             QKeySequence, QPalette, QTextDocument )
  from PySide2.QtWebEngineWidgets import ( QWebEngineView, QWebEngineProfile, QWebEnginePage )   # special import


 *******************************************************************************


 *******************************************************************************
crys3d/hklviewer/qt_chromium_check.py
from __future__ import absolute_import, division, print_function

from PySide2.QtCore import QTimer
from PySide2.QtWebEngineWidgets import QWebEngineView, QWebEnginePage
import sys, os


WeblglChecklibpath = os.path.join(os.path.dirname(os.path.abspath(__file__)), "webgl_check.js")

htmlstr1 = """

<html lang="en">
<head>
  <title>Detect webgl</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
</head>
<body>This is a test for webgl <div id="viewport" style="width:100%; height:100%;"></div>
</body>
</html>
"""

# some documentation for chromium flags
# https://peter.sh/experiments/chromium-command-line-switches

flgs = os.environ.get("QTWEBENGINE_CHROMIUM_FLAGS", "")
os.environ["QTWEBENGINE_CHROMIUM_FLAGS"] = flgs + " --single-process" # necessary for detecting webgl abilities on Mac

class MyQWebEnginePage(QWebEnginePage):
  def __init__(self, *args, **kwargs):
    QWebEnginePage.__init__(self, *args, **kwargs)
  def javaScriptConsoleMessage(self,level, message, lineNumber, sourceID):
    print(message)
    self.webglsupport = True
    if message == 'WebGL error':
      self.webglsupport = False
    return super(MyQWebEnginePage,self).javaScriptConsoleMessage(level, message, lineNumber, sourceID)
  def javaScriptAlert(self,securityOrigin,msg):
    print(msg)
    return super(MyQWebEnginePage,self).javaScriptAlert(securityOrigin,msg)


if (__name__ == "__main__") :
  from PySide2.QtWidgets import QApplication
  app1 = QApplication(sys.argv)
  webglcheckscript = ""
  with open(WeblglChecklibpath, "r") as f:
    webglcheckscript = f.read()
    assert webglcheckscript != ""

  #app1.aboutToQuit.connect(lambda :print("about to quit"))
  print("QTWEBENGINE_CHROMIUM_FLAGS = %s" %os.environ["QTWEBENGINE_CHROMIUM_FLAGS"] )
  # give the browser time to instatiate and then close down gracefully
  QTimer.singleShot(10000, app1.quit ) # in case pageloadFinished() is never executed
  browser = QWebEngineView()
  webpage = MyQWebEnginePage(browser)
  browser.setPage(webpage)

  def pageloadFinished( ok):
    #import code, traceback; code.interact(local=locals(), banner="".join( traceback.format_stack(limit=10) ) )
    browser.page().runJavaScript(webglcheckscript)
    # give the script time to run and then close us down gracefully
    QTimer.singleShot(1000, app1.quit )

  webpage.loadFinished.connect(pageloadFinished)
  webpage.setHtml(htmlstr1)
  browser.hide() # show() or hide() is necessary for loading the html page
  app1.exec_()


 *******************************************************************************


 *******************************************************************************
crys3d/hklviewer/webbrowser_messenger_py2.py
from __future__ import absolute_import, division, print_function
import traceback
from libtbx.utils import Sorry, to_str
import threading
import time

from websocket_server import WebsocketServer

class WBmessenger(object):
  def __init__(self, viewerparent ):
    try:
      self.parent = viewerparent
      self.ProcessBrowserMessage = self.parent.ProcessBrowserMessage
      self.websockport = self.parent.websockport
      self.sleeptime = self.parent.sleeptime
      self.mprint = self.parent.mprint
      self.parent.lastviewmtrx
      self.browserisopen = False
      self.msgqueue = []
      self.msgdelim = ":\n"
      self.ishandling = False
      self.websockclient = None
      self.isterminating = False
      self.was_disconnected = None
      self.mywebsock = None
      self.websockeventloop = None
    except Exception as e:
      print( to_str(e) + "\n" + traceback.format_exc(limit=10))


  def Sleep(self, t):
    time.sleep(t)


  def OnWebsocketClientMessage(self, client, server, message):
    self.ProcessBrowserMessage(message)


  def StartWebsocket(self):
    self.server = WebsocketServer(self.websockport, host='127.0.0.1')
    if not self.server:
      raise Sorry("Could not connect to web browser")
    self.server.set_fn_new_client(self.OnConnectWebsocketClient)
    self.server.set_fn_client_left(self.OnDisconnectWebsocketClient)
    self.server.set_fn_message_received(self.OnWebsocketClientMessage)
    self.wst = threading.Thread(target=self.server.run_forever)
    self.wst.daemon = True
    self.wst.start()
    self.msgqueuethrd = threading.Thread(target = self.WebBrowserMsgQueue )
    self.msgqueuethrd.daemon = True
    self.msgqueuethrd.start()


  def StopWebsocket(self):
    try:
      if self.websockclient: # might not have been created if program is closed before a data set is shown
        self.websockclient['handler'].send_text(u"", opcode=0x8)
    except Exception as e:
      self.mprint( to_str(e) + "\n" + traceback.format_exc(limit=10), verbose=0)
    self.mprint("Shutting down Websocket listening thread", verbose=1)
    self.server.shutdown()
    self.parent.javascriptcleaned = True
    self.msgqueuethrd.join()
    self.mprint("Shutting down WebsocketServer", verbose=1)
    self.wst.join()
    self.isterminating = True


  def AddToBrowserMsgQueue(self, msgtype, msg=""):
    self.msgqueue.append( (msgtype, msg) )


  def WebBrowserMsgQueue(self):
    try:
      while True:
        nwait = 0.0
        time.sleep(self.sleeptime)
        if self.parent.javascriptcleaned:
          self.mprint("Shutting down WebBrowser message queue", verbose=1)
          return
        if len(self.msgqueue):
          pendingmessagetype, pendingmessage = self.msgqueue[0]
          gotsent = self.send_msg_to_browser(pendingmessagetype, pendingmessage)
          while not self.browserisopen:  #self.websockclient:
            time.sleep(self.sleeptime)
            nwait += self.sleeptime
            if nwait > self.parent.handshakewait or self.parent.javascriptcleaned or not self.viewerparams.scene_id is not None:
              return
          if gotsent:
            self.msgqueue.remove( self.msgqueue[0] )
          #if self.was_disconnected:
          #  nwait2 = 0.0
          #  while nwait2 < self.parent.handshakewait:
          #    nwait2 += self.sleeptime
          #  self.ReloadNGL()
# if the html content is huge the browser will be unresponsive until it has finished
# reading the html content. This may crash this thread. So try restarting this thread until
# browser is ready
    except Exception as e:
      self.mprint( str(e) + ", Restarting WebBrowserMsgQueue\n" \
                          + traceback.format_exc(limit=10), verbose=2)
      self.websockclient = None
      self.WebBrowserMsgQueue()


  def OnConnectWebsocketClient(self, client, server):
    self.websockclient = client
    self.mprint( "Browser connected:" + str( self.websockclient ), verbose=1 )
    if self.was_disconnected:
      self.was_disconnected = False
    if self.parent.lastviewmtrx and self.parent.viewerparams.scene_id is not None:
      self.parent.set_volatile_params()
      self.mprint( "Reorienting client after refresh:" + str( self.websockclient ), verbose=2 )
      self.AddToBrowserMsgQueue("ReOrient", self.parent.lastviewmtrx)
    else:
      self.parent.SetAutoView()


  def OnDisconnectWebsocketClient(self, client, server):
    self.mprint( "Browser disconnected:" + str( client ), verbose=1 )
    self.was_disconnected = True


  def send_msg_to_browser(self, msgtype, msg=""):
    message = u"" + msgtype + self.msgdelim + str(msg)
    if self.websockclient:
      nwait = 0.0
      while not ("Ready" in self.parent.lastmsg or "tooltip_id" in self.parent.lastmsg \
        or "CurrentViewOrientation" in self.parent.lastmsg or "AutoViewSet" in self.parent.lastmsg \
        or "ReOrient" in self.parent.lastmsg or "JavaScriptCleanUp" in self.parent.lastmsg or self.websockclient is None):
        time.sleep(self.sleeptime)
        nwait += self.sleeptime
        if nwait > 2.0 and self.browserisopen:
          self.mprint("ERROR: No handshake from browser!", verbose=0 )
          self.mprint("failed sending " + msgtype, verbose=1)
          self.mprint("Reopening webpage again", verbose=0)
          break
    if self.browserisopen and self.websockclient is not None:
      try:
        self.server.send_message(self.websockclient, message )
        return True
      except Exception as e:
        self.mprint( str(e) + "\n" + traceback.format_exc(limit=10), verbose=1)
        self.websockclient = None
        return False
    else:
      return self.parent.OpenBrowser()


 *******************************************************************************


 *******************************************************************************
crys3d/hklviewer/webbrowser_messenger_py3.py
from __future__ import absolute_import, division, print_function
import traceback
from libtbx.utils import Sorry, to_str
import threading, sys
import os.path, time

import struct
import asyncio
from websockets.legacy import server
from typing import Optional
from websockets.exceptions import (
  ConnectionClosed,
  ConnectionClosedError,
  ConnectionClosedOK,
)

class MyWebSocketServerProtocol(server.WebSocketServerProtocol):
  def __init__(self, *args, **kwargs):
    self.client_connected = None
    self.onconnect = None
    self.ondisconnect = None
    self.onlostconnect = None
    super().__init__(*args, max_size=100000000) # allow for saving 100Mb size images
  def connection_open(self) -> None:
    #print("In connection_open()")
    self.client_connected = self.local_address
    if self.onconnect:
      self.onconnect(self.client_connected)
    super().connection_open()
  def connection_lost(self, exc: Optional[Exception]) -> None:
    #print("In connection_lost()")
    self.client_connected = None
    if self.onlostconnect and hasattr(self, "close_code"):
      self.onlostconnect(self.client_connected, self.close_code, self.close_reason)
    super().connection_lost(exc)
  def connection_closed_exc(self) -> ConnectionClosed:
    #print("In connection_closed_exc()")
    self.client_connected = None
    if self.ondisconnect:
      self.ondisconnect(self.client_connected, self.close_code, self.close_reason)
    return super().connection_closed_exc()

lock_timeout = 2

class WBmessenger(object):
  def __init__(self, viewerparent ):
    try:
      self.parent = viewerparent
      self.ProcessBrowserMessage = self.parent.ProcessBrowserMessage
      self.on_browser_connection = self.parent.on_browser_connection
      self.websockport = self.parent.websockport
      self.sleeptime = self.parent.sleeptime
      self.mprint = self.parent.mprint
      self.parent.lastviewmtrx
      self.browserisopen = False
      self.msgqueue = []
      self.clientmsgqueue = []
      self.replace_msg_lst = []
      self.msgdelim = ":\n"
      self.ishandling = False
      self.websockclient = None
      self.isterminating = False
      self.was_disconnected = None
      self.mywebsock = None
      self.websockeventloop = None
      self.clientmsgqueue_sem = threading.Semaphore()
      self.listening_sem = threading.Semaphore()
      self.listening_sem.acquire(blocking=True, timeout=lock_timeout)
      self.mprint("WBmessenger got listening_sem", verbose="threadingmsg")
    except Exception as e:
      print( to_str(e) + "\n" + traceback.format_exc(limit=10))


  def start_server_loop(self):
    #time.sleep(10)
    self.mprint("HKLviewerWebSockServerThread started", verbose=1)
    self.websockeventloop.run_until_complete(self.server)
    self.mprint("websocket server is listening", verbose=1)
    self.listening_sem.release()
    self.mprint("WBmessenger released listening_sem", verbose="threadingmsg")
    self.websockeventloop.run_forever()
    self.mprint("websockeventloop has run forever", verbose=1)


  def StartWebsocket(self):
    try:
      if self.websockeventloop is not None:
        self.mprint("websockeventloop already running", verbose=1)
        return
      if self.websockeventloop is None:
        self.websockeventloop = asyncio.new_event_loop()
        asyncio.set_event_loop(self.websockeventloop)
        if self.parent.debug is not None:
          self.websockeventloop.set_debug(True)
          import logging
          logger = logging.getLogger("websockets.server")
          logger.setLevel(logging.DEBUG)
          logger.addHandler(logging.StreamHandler())

      self.server = server.serve(self.WebSockHandler, 'localhost',
                                      self.websockport, #ssl=ssl_context,
                                      create_protocol=MyWebSocketServerProtocol,
                                      )
      self.mprint("Starting websocket server on port %s" %str(self.websockport), verbose=1)
      # run_forever() blocks execution so put in a separate thread
      self.wst = threading.Thread(target=self.start_server_loop, name="HKLviewerWebSockServerThread" )
      self.wst.daemon = True # ensure thread dies whenever program terminates through sys.exit()
      self.wst.start()
      self.websocketclientmsgthrd = threading.Thread(target = self.ProcessClientMessageLoop,
                                                     name="WebsocketClientMessageThread")
      self.websocketclientmsgthrd.daemon = True # ensure thread dies whenever program terminates through sys.exit()
      self.websocketclientmsgthrd.start()
      if not self.server:
        raise Sorry("Could not connect to web browser")
    except Exception as e:
      self.mprint( to_str(e) + "\n" + traceback.format_exc(limit=10), verbose=0)


  def StopWebsocket(self):
    self.isterminating = True
    self.javascriptcleaned = True
    self.mprint("Shutting down websockeventloop", verbose=1)
    self.websockeventloop.stop()


  async def WebSockHandler(self, mywebsock, path):
    # invoked only when a new websocket client (the browser) is waiting to connect
    self.mprint("Pending websocket client wanting to connect", verbose=1)
    if hasattr(self.mywebsock, "state") and self.mywebsock.state == 2 \
                                        and self.websockclient is not None:
      await self.mywebsock.wait_closed()
    if self.websockclient is not None or self.ishandling:
      await asyncio.sleep(0.5)
      return
    self.ishandling = True
    mywebsock.onconnect = self.OnConnectWebsocketClient
    self.OnConnectWebsocketClient(mywebsock.client_connected)
    mywebsock.ondisconnect = self.OnDisconnectWebsocketClient
    mywebsock.onlostconnect = self.OnLostConnectWebsocketClient
    self.mywebsock = mywebsock
    getmsgtask = asyncio.ensure_future(self.ReceiveMsgQueue())
    sendmsgtask = asyncio.ensure_future(self.SendMsgQueue())
    done, pending = await asyncio.wait( [getmsgtask, sendmsgtask],
      return_when=asyncio.FIRST_COMPLETED,
    )
    for task in pending:
      task.cancel()
    self.mprint("Exiting WebSockHandler", verbose=1)
    self.ishandling = False


  async def ReceiveMsgQueue(self):
    while True:
      await asyncio.sleep(self.sleeptime)
      if self.was_disconnected in [4242, # reload
                                    4241, # javascriptcleanup
                                    1006, # WebSocketServerProtocol.close_code is absent
                                    1001, # normal exit
                                    1005,
                                    1000
                                    ]:
        await self.mywebsock.wait_closed()
        self.mprint("ReceiveMsgQueue shutdown", verbose=1)
        return # shutdown
      if self.websockclient is None or self.mywebsock.client_connected is None:
        await asyncio.sleep(self.sleeptime)
        continue
      message = ""
      try: # use EAFP rather than LBYL style with websockets
        message = await self.mywebsock.recv()
      except Exception as e:
        if self.was_disconnected != 4242:
          self.mprint( to_str(e) + "\n" + traceback.format_exc(limit=10), verbose=1)
      self.clientmsgqueue_sem.acquire(blocking=True, timeout=lock_timeout)
      # Avoid overwhelming ProcessBrowserMessage() with too many messages of the same kind (like tooltips)
      # as it will uncontrolably grow clientmsgqueue which will slow down or make HKLviewer unresponsive
      # when displaying tooltips of a big dataset.
      # Instead we check if the substring rmsg matches the current message. If so and if it is already
      # present in clientmsgqueue, then replace it with message rather than appending it to clientmsgqueue.
      notfound = True
      for rmsg in self.replace_msg_lst:
        if isinstance(message, str) and rmsg in message:
          for msg in self.clientmsgqueue:
            if rmsg in msg:
              msg = message
              notfound = False
              break
      if notfound:
        self.clientmsgqueue.append(message)
      self.clientmsgqueue_sem.release()


  async def SendMsgQueue(self):
    while True:
      try:
        nwait = 0.0
        await asyncio.sleep(self.sleeptime)
        if self.was_disconnected in [4242, # reload
                                      4241, # javascriptcleanup
                                      1006, # WebSocketServerProtocol.close_code is absent
                                      1001, # normal exit
                                      1005,
                                      1000
                                      ]:
          self.mprint("SendMsgQueue shutdown", verbose=1)
          return # shutdown
        if self.parent.javascriptcleaned or self.was_disconnected == 4241: # or self.was_disconnected == 1001:
          return
        if len(self.msgqueue):
          pendingmessagetype, pendingmessage, pendingbinary = self.msgqueue[0]
          gotsent = await self.send_msg_to_browser(pendingmessagetype, pendingmessage, pendingbinary)
          while not self.browserisopen:  #self.websockclient:
            await asyncio.sleep(self.sleeptime)
            nwait += self.sleeptime
            if nwait > self.parent.handshakewait or self.parent.javascriptcleaned \
                or not self.parent.params.viewer.scene_id is not None:
              continue
          if gotsent:
            self.msgqueue.remove( self.msgqueue[0] )
      except Exception as e:
        self.mprint( str(e) + traceback.format_exc(limit=10), verbose=0)


  def ProcessClientMessageLoop(self):
    while self.isterminating == False:
      if len(self.clientmsgqueue):
        self.clientmsgqueue_sem.acquire(blocking=True, timeout=lock_timeout)
        pendingmessage = self.clientmsgqueue[0]
        self.ProcessBrowserMessage(pendingmessage)
        self.clientmsgqueue.remove( self.clientmsgqueue[0] )
        self.clientmsgqueue_sem.release()
      time.sleep(self.sleeptime)
    self.mprint("Shutting down WebsocketClientMessageThread", verbose=1)


  def AddToBrowserMsgQueue(self, msgtype, msg="",binary=False):
    self.msgqueue.append( (msgtype, msg, binary) )


  def OnConnectWebsocketClient(self, client):
    self.websockclient = client
    self.mprint( "Browser connected " + str( self.websockclient ), verbose=1 )
    self.on_browser_connection()
    self.was_disconnected = None
    if self.parent.lastviewmtrx and self.parent.params.viewer.scene_id is not None:
      self.parent.set_volatile_params()
      self.mprint( "Reorienting client after refresh:" + str( self.websockclient ), verbose=2 )
      self.AddToBrowserMsgQueue("ReOrient", self.parent.lastviewmtrx)


  def OnLostConnectWebsocketClient(self, client, close_code, close_reason):
    msg =  "Browser lost connection %s, code %s, reason: %s" %(str(self.websockclient), close_code, close_reason)
    self.mprint(msg , verbose=1 )
    self.was_disconnected = close_code
    self.browserisopen = False
    self.websockclient = None
    self.ishandling = False


  def OnDisconnectWebsocketClient(self, client, close_code, close_reason):
    msg =  "Browser disconnected %s, code %s, reason: %s" %(str(self.websockclient), close_code, close_reason)
    self.mprint(msg , verbose=1 )
    self.was_disconnected = close_code
    self.websockclient = None
    self.ishandling = False


  async def send_msg_to_browser(self, msgtype, msg="", binary=False):
    message = u"" + msgtype + self.msgdelim + str(msg)
    nwait = 0.0
    while isinstance(self.parent.lastmsg, str) and \
      not ("Ready" in self.parent.lastmsg or "tooltip_id" in self.parent.lastmsg \
      or "CurrentViewOrientation" in self.parent.lastmsg or "AutoViewSet" in self.parent.lastmsg \
      or "ReOrient" in self.parent.lastmsg or "JavaScriptCleanUp" in self.parent.lastmsg ) \
      or self.websockclient is None:
      await asyncio.sleep(self.sleeptime)
      nwait += self.sleeptime
      if self.was_disconnected != None:
        return False
      if nwait > 200 and self.browserisopen:
        self.mprint("ERROR: No handshake from browser!", verbose=0 )
        self.mprint("failed sending " + msgtype, verbose=1)
        self.was_disconnected = 1005
        #break
        return False
    if self.browserisopen and self.websockclient is not None or self.mywebsock.client_connected is not None:
      try: # use EAFP rather than LBYL style with websockets
        if not binary:
          await self.mywebsock.send( message )
        else:
          # Binary data is sent as a pair of messages. First a plain string containing the message type
          # is sent. Then the actual data array is sent in binary format as a bytearray.
          # When HKLjavascripts notes the second message is in binary format it pairs it up with the
          # previous message which is the message type so it can be processed
          await self.mywebsock.send( msgtype )
          byteslst = struct.pack("%sf" % len(msg), *msg)
          await self.mywebsock.send( bytearray(byteslst) )
        return True
      except Exception as e:
        if self.was_disconnected != 4242:
          self.mprint( str(e) + "\n" + traceback.format_exc(limit=10), verbose=1)
        self.websockclient = None
        return False
    else:
      return False


 *******************************************************************************


 *******************************************************************************
crys3d/hklviewer/xtriage_runner.py
from __future__ import absolute_import, division, print_function
from libtbx import group_args, phil


def external_cmd(parent, master_phil, firstpart):
  from mmtbx.scaling import xtriage
  from io import StringIO
  tabname = "Xtriage"

  logstrbuf = StringIO()
  xtriageobj = xtriage.run([ parent.loaded_file_name, "scaling.input.xray_data.obs_labels=" +
                           parent.viewer.get_current_labels() ], out=logstrbuf)
  logfname = firstpart + "_xtriage.log"
  with open(logfname, "w") as f:
    f.write( logstrbuf.getvalue() )

  retval = 0
  errormsg = ""
  # Add any twin operators as user vectors.
  # user_vector is multiple scope so we can't assign viewer.user_vector directly
  philstr = ""
  for i,twinop in enumerate(xtriageobj.twin_results.twin_law_names):
    philstr += '''
    viewer.user_vector {
                label = "twin_"''' + str(i) + '''
                hkl_op = "''' + twinop + '''"
           }
    '''
  # Add TNCS vector as a real space vector if patterson peak > 0.1 of origin peak
  if len(xtriageobj.twin_results.translational_pseudo_symmetry.suspected_peaks) > 0:
    tncsvec = xtriageobj.twin_results.translational_pseudo_symmetry.suspected_peaks[0][0]
    patterson_height = xtriageobj.twin_results.translational_pseudo_symmetry.suspected_peaks[0][1]
    if patterson_height > 10:
      philstr += '''
      viewer.user_vector {
                  label = "tNCS_xtriage"
                  abc = ''' + f"({tncsvec[0]:.5}, {tncsvec[1]:.5}, {tncsvec[2]:.5})" + '''
              }
      '''
  vectorphil = phil.parse(philstr)
  working_params = master_phil.fetch(source= vectorphil).extract()
  parent.add_user_vector(working_params.viewer.user_vector, rectify_improper_rotation=False)

  # The name of logfile and tab should be present in ldic after running exec().
  # cctbx.python sends this back to HKLviewer from HKLViewFrame.run_external_cmd()
  return group_args(tabname=tabname, logfname=logfname, retval=retval, errormsg=errormsg)


 *******************************************************************************


 *******************************************************************************
crys3d/hklviewer/xtricorder_runner.py
from __future__ import absolute_import, division, print_function
from libtbx import group_args
from libtbx.utils import Sorry
import os, os.path, glob

def external_cmd(parent, master_phil, firstpart):
  from phasertng.scripts import xtricorder
  # Provide a temp directory for xtricorder in current working directory and replace any
  # backslashes on Windows with forwardslashes for the sake of phasertng. Append a random
  # number to tempdir to avoid race conditions if another instance of xtricorder is running
  import random
  from pathlib import PurePath
  tempdir = PurePath(os.path.join( os.getcwd(), "HKLviewerXtricorder")).as_posix() + str(random.randrange(100000))
  tabname = "Xtricorder"
  (retobj) = xtricorder.xtricorder(
  r'''phasertng {
              hklin.filename = "%s"
              reflections.wavelength = 1.0
              suite.store = logfile
              suite.level = logfile
              suite.database = "%s"
            }
  ''' %(parent.loaded_file_name, tempdir)
  )
  retval = retobj.exit_code()
  errormsg = retobj.error_type() + " error, " + retobj.error_message()
  import shutil, glob
  mtzs = retobj.get_filenames(["mtz"])
  if len(mtzs):
    xtricordermtz = mtzs[-1]
    parent.hklin =  firstpart + "_xtricorder.mtz"
    shutil.copyfile( xtricordermtz, parent.hklin ) # copy the last file only
    parent.update_from_philstr("openfilename=" + parent.hklin) # resets all PHIL parameters
    parent.params.external_cmd = "runXtricorder" # allow this PHIL parameter to be shown
    parent.currentphil = master_phil.format(python_object=parent.params)

  logs = glob.glob(tempdir + "/**/*.logfile.log", recursive=True)
  timesortedlogs = sorted( [ (p, os.path.getmtime(p) )   for p in logs ], key=lambda e: e[1] )
  mstr = ''
  for fname, t in timesortedlogs:
    with open(fname, 'r') as f:
      mstr += f.read() + '\\n'
  # The name of logfile and tab should be present in ldic after running exec().
  # cctbx.python sends this back to HKLviewer from HKLViewFrame.run_external_cmd()
  logfname = firstpart + "_xtricorder.log"
  with open(logfname, 'w') as f:
    f.write(mstr)
  if len(mtzs) == 0:
    raise Sorry("Could not find the mtz file from running Xtricorder")

  shutil.rmtree(tempdir)
  return group_args(tabname=tabname, logfname=logfname, retval=retval, errormsg=errormsg)


 *******************************************************************************


 *******************************************************************************
crys3d/images.py
from __future__ import absolute_import, division, print_function
from gltbx.images import img_data

inspector_img = img_data(width=32, height=32, mask=-1, encoded_data = """\
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\
ffffffffffffffffffffffffffffffffffffecececd4d4d4d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9\
d9d9d9d9d9d9d9d9d9dbdbd8deded8dbdbd8d2d2dac8c8dcc2c2ddc1c2ddc7c7dcd1d1dadadad8\
deded8dcdcd8d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d9d5d5d5e8e8e8e4e4e4\
dcdcdce6e6e6e5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e9e9e5e8e8e5d0d1e9a9abf1888bf77478fb\
6b6efd676bfe676bfe6a6efd7276fb8588f8a4a6f2cccdeae7e7e5e9e9e4e5e5e5e5e5e5e5e5e5\
e5e5e5e5e5e5e5e5e5dfdfdfdfdfdfe5e5e5dddddde7e7e7e6e6e6e6e6e6e6e6e6e7e7e6eaeae5\
cbcceb8f91f7696dfe6064ff6266ff6468ff6569ff656aff666aff6569ff6468ff6266ff6065ff\
676bff898cf8c5c6eceae9e5e8e8e6e6e6e6e6e6e6e6e6e6e6e6e6e0e0e0e0e0e0e5e5e5dddddd\
e7e7e7e6e6e6e6e6e6e9e9e5e3e3e7a1a3f3686cfe6165ff6569ff666aff666aff666aff666aff\
666aff666aff666aff666aff666aff666aff6569ff6266ff6569ff989af5dfdfe7e9e9e5e6e6e6\
e6e6e6e6e6e6e0e0e0e0e0e0e5e5e5dddddde7e7e7e6e6e6e9e9e5dbdbe88689f96064ff6569ff\
666aff666aff666aff666aff666aff666aff666aff666aff666aff666aff6569ff666aff666aff\
666aff6569ff6064ff7d81fad4d5e9eaeae5e6e6e6e6e6e6e0e0e0e0e0e0e5e5e5dddddde7e7e7\
e8e8e6dcdce87f82fa6165ff666aff666aff666aff666aff666aff666aff666aff666aff666aff\
666aff6468ff6468ff696cff6367ff666aff666aff666aff666aff6166ff767afbd4d5e9e9e9e5\
e6e6e6e0e0e0e0e0e0e5e5e5dddddde8e8e7e5e5e6898cf86065ff666aff666aff666aff666aff\
666aff666aff666aff666aff666aff666aff6569ff6f72ffcacbffe4e4ff9496ff6266ff666aff\
666aff666aff666aff6165ff7f82fae0e0e7e8e8e6e0e0e0e0e0e0e5e5e5ddddddecece6a9abf2\
6064ff666aff666aff666aff666aff666aff666aff666aff666aff666aff666aff666aff6064ff\
b5b6ffffffffffffffd3d4ff6165ff666aff666aff666aff666aff666aff6064ff9b9ef4ebeae5\
e0e0e0e0e0e0e5e5e5e0e0ddd5d6ea6d70fd6569ff666aff666aff666aff666aff666aff666aff\
666aff666aff666aff666aff666aff6165ffd3d4ffffffffffffffb4b6ff6065ff666aff666aff\
666aff666aff666aff6569ff676bffcbcbece4e4dfe0e0e0e5e5e5e3e2dc9fa2f56065ff666aff\
666aff666aff666aff666aff666aff666aff666aff666aff666aff666aff666aff6266ff979aff\
e8e8ffcfd0ff6f73ff6569ff666aff666aff666aff666aff666aff666aff6165ff9194f7e4e4df\
e0e0e0e6e6e5d6d6df7579fd6468ff666aff666aff666aff666aff666aff666aff666aff666aff\
666aff666aff666aff666aff666aff6266ff686cff6569ff6468ff666aff666aff666aff666aff\
666aff666aff666aff6569ff6d71fed0d1e3e2e2e0e9e9e4bbbce46468ff666aff666aff666aff\
666aff666aff666aff666aff666aff666aff666aff666aff666aff666aff6165ff696dff777bff\
676bff666aff666aff666aff666aff666aff666aff666aff666aff666aff6266ffb1b2e9e5e5df\
eaeae4a1a3e96165ff666aff666aff666aff666aff666aff666aff666aff666aff666aff666aff\
666aff6468ff6367ff979affe0e1fff7f7ff7f83ff6367ff666aff666aff666aff666aff666aff\
666aff666aff666aff6165ff9598efe5e5dfeaeae48f91ed6266ff666aff666aff666aff666aff\
666aff666aff666aff666aff666aff666aff6166ff7074ffc6c7fffffffffffffff2f2ff7276ff\
6468ff666aff666aff666aff666aff666aff666aff666aff666aff6266ff8487f2e3e3e0e9e8e4\
8789ee6266ff666aff666aff666aff666aff666aff666aff666aff666aff666aff6468ff8689ff\
e5e6ffffffffffffffffffffc9caff6165ff666aff666aff666aff666aff666aff666aff666aff\
666aff666aff6367ff7d80f3e1e1e0e9e9e4878aee6266ff666aff666aff666aff666aff666aff\
666aff666aff666aff666aff6266ffadb0ffa2a4ffd0d1ffffffffffffff9598ff6165ff666aff\
666aff666aff666aff666aff666aff666aff666aff666aff6367ff7e81f3e1e1e0eaeae49194ec\
6166ff666aff666aff666aff666aff666aff666aff666aff666aff666aff666aff6266ff696dff\
ebebffffffffedeeff6e72ff6569ff666aff666aff666aff666aff666aff666aff666aff666aff\
666aff6266ff8789f2e3e3e0eaeae4a5a7e86165ff666aff666aff666aff666aff666aff666aff\
666aff666aff666aff666aff6065ff9598ffffffffffffffc0c2ff6064ff666aff666aff666aff\
666aff666aff666aff666aff666aff666aff666aff6165ff9a9ceee6e5dfe8e8e4c1c2e3666aff\
666aff666aff666aff666aff666aff666aff666aff666aff666aff666aff6166ffccceffffffff\
fefeff8d90ff6165ff666aff666aff666aff666aff666aff666aff666aff666aff666aff666aff\
6266ffb7b8e8e5e5dfe6e6e5dadade7b7efc6367ff666aff666aff666aff666aff666aff666aff\
666aff666aff6468ff787bfff6f6ffffffffe7e7ff676bff6064ff666aff666aff666aff666aff\
666aff666aff666aff666aff666aff6468ff7175fdd6d6e2e2e2e0e5e5e5e3e3dcaaacf26065ff\
666aff666aff666aff666aff666aff666aff666aff666aff6064ffa7a9ffffffffffffffb6b7ff\
7e81ffaeb0ff666aff666aff666aff666aff666aff666aff666aff666aff666aff6065ff9c9ef5\
e5e5dfe0e0e0e5e5e5dfdfdddddde97478fc6368ff666aff666aff666aff666aff666aff666aff\
666aff6469ffd9daffffffffffffffe8e9ffebebffa0a3ff6468ff666aff666aff666aff666aff\
666aff666aff666aff6569ff6c70fed4d4eae3e3e0e0e0e0e5e5e5ddddddecebe6b7b8ef6266ff\
666aff666aff666aff666aff666aff666aff6367ff7d80fffafaffffffffffffffe2e3ff8689ff\
6064ff666aff666aff666aff666aff666aff666aff666aff666aff6065ffaaacf2ebebe5e0e0e0\
e0e0e0e5e5e5dddddde7e7e7e9e9e69a9cf56064ff666aff666aff666aff666aff666aff6266ff\
8d8ffffafaffe7e8ffaaacff6b6fff6266ff666aff666aff666aff666aff666aff666aff666aff\
666aff6065ff8d90f7e6e6e6e7e7e6e0e0e0e0e0e0e5e5e5dddddde7e7e7e7e7e6e4e4e69093f7\
6064ff666aff666aff666aff666aff666aff696dff7c7fff6d71ff6064ff6569ff666aff666aff\
666aff666aff666aff666aff666aff666aff6064ff8589f9dfdfe7e8e8e6e6e6e6e0e0e0e0e0e0\
e5e5e5dddddde7e7e7e6e6e6e8e8e6e4e4e69a9cf56266ff6468ff666aff666aff666aff666aff\
6367ff6569ff666aff666aff666aff666aff666aff666aff666aff666aff6468ff6165ff9092f7\
e0e0e7e9e9e5e6e6e6e6e6e6e0e0e0e0e0e0e5e5e5dddddde7e7e7e6e6e6e6e6e6e7e7e6e9e9e5\
b7b8ef7376fc6064ff6468ff666aff666aff666aff666aff666aff666aff666aff666aff666aff\
666aff6468ff6064ff6e72fdaeb0f1e7e7e6e8e8e6e6e6e6e6e6e6e6e6e6e0e0e0e0e0e0e5e5e5\
dddddde7e7e7e6e6e6e6e6e6e6e6e6e6e6e6ebebe5dbdce8a6a8f27679fc6367ff6165ff6266ff\
6468ff6468ff6468ff6468ff6267ff6165ff6266ff7376fc9fa1f4d7d7e9ebebe5e7e7e6e6e6e6\
e6e6e6e6e6e6e6e6e6e0e0e0e0e0e0e4e4e4d9d9d9e4e4e4e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3\
e4e4e2e8e8e2dcdce4bdbeea9c9ef08486f57679f87074f97074f97579f88285f6989bf1b9baeb\
d9dae4e8e8e2e5e5e2e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3dcdcdcdededef0f0f0dadada\
dddddddddddddddddddddddddddddddddddddddddddddddddededde1e1dce2e2dcdfdfddd9d9de\
d5d5ded5d5dfd9d9dedededde2e2dce2e1dcdededddddddddddddddddddddddddddddddddddddd\
dddddddddddddadadaecececffffffffffffffffffffffffffffffffffffffffffffffffffffff\
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\
""")


 *******************************************************************************


 *******************************************************************************
crys3d/libtbx_refresh.py
from __future__ import absolute_import, division, print_function
try:
  from PyQt4 import uic
except ImportError:
  pass
else:
  import libtbx.load_env
  ui_dir = libtbx.env.under_dist(module_name="crys3d", path="qttbx")
  print('  Processing *.ui files in "%s"' % ui_dir)
  try:
    # check in case PyQt4 looks for ucs2, our Python is built with ucs4
    uic.compileUiDir(ui_dir, recurse=True)
  except BaseException:
    pass


 *******************************************************************************


 *******************************************************************************
crys3d/model.py
from __future__ import absolute_import, division, print_function
from six.moves import range

# TODO: clean up handling of changes in atom count

# these are approximations based on my (probably faulty) memory.
# feel free to change to something more reasonable.
# note: carbon is assigned the base color.
element_shades = {'H'  : (0.95, 0.95, 0.95), # very light grey
                  #'C'  : (0.8, 0.8, 0.8),    # light grey
                  'N'  : (0.0, 0.0, 1.0),    # blue
                  'O'  : (1.0, 0.0, 0.0),    # red
                  'S'  : (1.0, 0.5, 0.0),    # orange
                  'P'  : (1.0, 1.0, 0.0),    # yellow
                  'Se' : (0.0, 1.0, 0.0),    # green
                  'Mg' : (0.7, 0.7, 0.9),    # very pale blue
                  'Fe' : (0.8, 0.2, 0.0),    # rust
                  'Cl' : (0.8, 1.0, 0.2),    # yellow-green
                  'Na' : (0.7, 0.7, 0.7),    # light grey
                  'Ca' : (1.0, 1.0, 1.0),    # white
                  'Mn' : (1.0, 0.6, 0.8),    # lavender
                  'Zn' : (0.8, 0.9, 1.0),    # very pale cyan
                  'Ni' : (0.0, 0.8, 0.4),    # teal
                  'Cu' : (0.0, 0.8, 0.7),    # blue-green
                  'Co' : (0.0, 0.5, 0.6) }   # marine

class model_data (object) :
  def __init__ (self, object_id, pdb_hierarchy, atomic_bonds,
      special_position_settings=None,
      base_color=(0.0,1.0,1.0)) :
    self.object_id = object_id
    self.base_color = base_color
    self.draw_mode = None
    self.current_bonds = None
    self.noncovalent_bonds = None
    self.ribbon = None
    self.color_mode = None #"rainbow"
    self.flag_object_visible = True
    self._color_cache = {}
    self.flag_show_hydrogens = False
    self.flag_show_lines = True
    self.flag_show_labels = True
    self.flag_show_points = True
    self.flag_show_spheres = False
    self.flag_show_ribbon = False
    self.flag_show_ellipsoids = False
    self.flag_show_noncovalent_bonds = False
    self.update_structure(pdb_hierarchy=pdb_hierarchy,
      atomic_bonds=atomic_bonds,
      special_position_settings=special_position_settings)
    from scitbx.array_family import flex
    self.use_u_aniso = flex.bool(self.atoms.size())
    #self.recalculate_visibility()

  def reset (self) :
    self.is_changed = False

  def get_scene_data (self) :
    if self.atoms.size() != self.visibility.atoms_visible.size() :
      self.recalculate_visibility()
    return model_scene(bonds=self.current_bonds,
      points=self.atoms.extract_xyz(),
      b_iso=self.atoms.extract_b(),
      b_aniso=self.atoms.extract_uij(),
      atom_colors=self.atom_colors,
      atom_labels=self.atom_labels,
      atom_radii=self.atom_radii,
      visibility=self.visibility,
      noncovalent_bonds=self.noncovalent_bonds,
      atomic_bonds=self.atomic_bonds,
      ribbon=self.ribbon)

  def set_noncovalent_bonds (self, bonded_atoms) :
    self.noncovalent_bonds = bonded_atoms
    self.is_changed = True

  def update_scene_data (self, scene) :
    scene.update_bonds(self.current_bonds)
    scene.update_colors(self.atom_colors)
    scene.update_visibility(self.visibility)
    scene.clear_lists()

  def update_xyz (self, xyz) :
    assert xyz.size() == self.atoms.size()
    for i_seq, atom in enumerate(self.atoms) :
      atom.xyz = xyz[i_seq]
    self.is_changed = True

  def update_u_iso (self, u_iso) :
    assert u_iso.size() == self.atoms.size()
    for i_seq, atom in enumerate(self.atoms) :
      atom.b = adptbx.u_as_b(u_iso[i_seq])
    self.is_changed = True

  def update_u_aniso (self, u_aniso, aniso_flag=None) :
    assert u_aniso.size() == self.atoms.size()
    for i_seq, atom in enumerate(self.atoms) :
      atom.uij = u_aniso[i_seq]
    self.is_changed = True

  def update_from_xray_structure (self, xray_structure) :
    sites_cart = xray_structure.sites_cart()
    u_iso = xray_structure.extract_u_iso_or_u_equiv()
    u_aniso = xray_structure.extract_u_cart_plus_u_iso()
    occ = xray_structure.scatterers().extract_occupancies()
    assert sites_cart.size() == self.atoms.size()
    for i_seq, atom in enumerate(self.atoms) :
      atom.xyz = sites_cart[i_seq]
      atom.occ = occ[i_seq]
      atom.b = adptbx.u_as_b(u_iso[i_seq])
      atom.uij = u_aniso[i_seq]
    self.use_u_aniso = xray_structure.use_u_aniso()
    self._color_cache["b"] = None
    self.is_changed = True

  def update_structure (self, pdb_hierarchy, atomic_bonds,
      special_position_settings=None) :
    from scitbx.array_family import flex
    self.pdb_hierarchy = pdb_hierarchy
    self.atoms = pdb_hierarchy.atoms()
    self.atom_count = self.atoms.size()
    assert (self.atom_count == len(atomic_bonds))
    if atomic_bonds is None :
      atomic_bonds = flex.stl_set_unsigned(self.atom_count)
    self.atomic_bonds = atomic_bonds
    self.selection_cache = pdb_hierarchy.atom_selection_cache(
      special_position_settings=special_position_settings)
    #self.index_atoms()
    atom_index = []
    atom_labels = flex.std_string()
    for atom in self.pdb_hierarchy.atoms_with_labels() :
      atom_index.append(atom)
      atom_labels.append(format_atom_label(atom))
    self.atom_index = atom_index
    self.atom_labels = atom_labels
    self.trace_bonds = extract_trace(pdb_hierarchy, self.selection_cache)
    if self.draw_mode is None or self.draw_mode.startswith("trace") :
      self.current_bonds = self.trace_bonds
    else :
      self.current_bonds = self.atomic_bonds
    atom_radii = flex.double(self.atoms.size(), 1.5)
    hydrogen_flag = flex.bool(self.atoms.size(), False)
    for i_seq, atom in enumerate(self.atom_index) :
      if atom.element.strip() in ["H", "D"] :
        atom_radii[i_seq] = 0.75
        hydrogen_flag[i_seq] = True
    self.atom_radii = atom_radii
    self.hydrogen_flag = hydrogen_flag
    self._color_cache = {}
    self.is_changed = True

  def recalculate_visibility (self) :
    from scitbx.array_family import flex
    from gltbx import viewer_utils
    c = 0
    if self.draw_mode == "spheres" :
      show_points = True
    else :
      show_points = self.flag_show_points
    if self.flag_show_hydrogens :
      atoms_drawable = flex.bool(self.atom_count, True)
    else :
      atoms_drawable = self.hydrogen_flag.__invert__()
      #atoms_drawable = flex.bool([ (atom.element != ' H') for atom in atoms ])
    self.visibility = viewer_utils.atom_visibility(
      bonds             = self.current_bonds,
      atoms_drawable    = atoms_drawable,
      flag_show_points  = show_points
    )
    self.visible_atom_count = self.visibility.visible_atoms_count

  def initialize_cartoon (self, sec_str=None) :
    if (sec_str is None) :
      from mmtbx import secondary_structure
      manager = secondary_structure.manager(
        pdb_hierarchy=self.pdb_hierarchy,
        xray_structure=None)
      sec_str = manager.selections_as_ints()
    from crys3d import ribbon
    self.ribbon = ribbon.cartoon(pdb_hierarchy=self.pdb_hierarchy,
      sec_str=sec_str)
    self.ribbon.construct_geometry()

  def refresh (self) :
    self.is_changed = True
    self._color_cache = {}
    self.set_draw_mode(self.draw_mode)
    self.is_changed = False

  def toggle_hydrogens (self, show_hydrogens) :
    self.flag_show_hydrogens = show_hydrogens
    self.refresh()

  def toggle_ellipsoids (self, show_ellipsoids) :
    self.flag_show_ellipsoids = show_ellipsoids

  def set_draw_mode (self, draw_mode, color_mode=None) :
    if draw_mode == self.draw_mode and not self.is_changed :
      pass
    else :
      self.draw_mode = draw_mode
      show_points = True
      if draw_mode == "spheres" :
        self.flag_show_spheres = True
      elif draw_mode == "ribbon" :
        self.flag_show_ribbon = True
        self.flag_show_lines = False
        self.flag_show_points = False
        if (self.ribbon is None) :
          self.initialize_cartoon()
      else :
        self.flag_show_ribbon = False
        self.flag_show_lines = True
        if draw_mode in ["trace", "trace_and_nb"] :
          self.current_bonds = self.trace_bonds
        else :
          self.current_bonds = self.atomic_bonds
        if draw_mode in ["trace", "bonded_only"] :
          self.flag_show_points = False
        else :
          self.flag_show_points = True
      self.recalculate_visibility()
      if color_mode is not None :
        self.color_mode = color_mode
      self.set_color_mode(self.color_mode) # force re-coloring

  #---------------------------------------------------------------------
  # XXX: COLORING
  #
  def set_base_color (self, color) :
    self.base_color = color

  def set_color_mode (self, color_mode) :
    if color_mode == self.color_mode and not self.is_changed :
      pass
    else :
      n_visible = self.visibility.atoms_visible.count(True)
      if (n_visible == 0) :
        return
      elif (n_visible == 1) :
        color_mode = "mono"
      self.color_mode = color_mode
      if color_mode == "mono" :
        self.color_mono()
      elif color_mode == "rainbow" :
        self.color_rainbow()
      elif color_mode == "b" :
        self.color_b()
      elif color_mode == "chain" :
        self.color_by_chain()
      elif color_mode == "element" :
        self.color_by_element()

  def color_mono (self) :
    cached = self._color_cache.get("mono")
    if cached is not None :
      self.atom_colors = cached
    else :
      from scitbx.array_family import flex
      self.atom_colors = flex.vec3_double(
        [ self.base_color for i in range(0, self.atoms.size()) ]
      )
      self._color_cache["mono"] = self.atom_colors

  def color_rainbow (self) :
    cached = self._color_cache.get("rainbow")
    if cached is not None :
      self.atom_colors = cached
    else :
      from scitbx import graphics_utils
      if (self.visibility.atoms_visible.count(True) == 1) :
        from scitbx.array_family import flex
        self.atom_colors = flex.vec3_double([(0,0,1)])
        return
      self.atom_colors = graphics_utils.color_rainbow(
        selection=self.visibility.atoms_visible)
      self._color_cache["rainbow"] = self.atom_colors

  def color_b (self) :
    cached = self._color_cache.get("b")
    if cached is not None :
      self.atom_colors = cached
    else :
      from scitbx import graphics_utils
      self.atom_colors = graphics_utils.color_by_property(
        properties=self.atoms.extract_b(),
        selection=self.visibility.atoms_visible,
        color_all=False,
        gradient_type="rainbow")
      self._color_cache["b"] = self.atom_colors

  def color_by_chain (self) :
    cached = self._color_cache.get("chain")
    if cached is not None :
      self.atom_colors = cached
    else :
      from scitbx.array_family import flex
      from scitbx import graphics_utils
      c = 0
      for chain in self.pdb_hierarchy.chains() :
        c += 1
      rainbow = graphics_utils.make_rainbow_gradient(c)
      j = 0
      chain_shades = {}
      for chain in self.pdb_hierarchy.chains() :
        chain_shades[chain.id] = rainbow[j]
      atom_colors = flex.vec3_double()
      for atom in self.pdb_hierarchy.atoms_with_labels() :
        atom_colors.append(chain_shades[atom.chain_id])
      self.atom_colors = atom_colors
      self._color_cache["chain"] = atom_colors

  def color_by_element (self) :
    cached = self._color_cache.get("element")
    if cached is not None :
      self.atom_colors = cached
    else :
      from scitbx.array_family import flex
      atom_colors = flex.vec3_double()
      for atom in self.pdb_hierarchy.atoms_with_labels() :
        element = atom.element.strip()
        color = element_shades.get(element, self.base_color)
        atom_colors.append(color)
      self.atom_colors = atom_colors
      self._color_cache["element"] = cached

#-----------------------------------------------------------------------
# Utility functions
def extract_trace (pdb_hierarchy, selection_cache=None) :
  from scitbx.array_family import shared
  if selection_cache is None :
    selection_cache = pdb_hierarchy.atom_selection_cache()
  last_atom     = None
  vertices = selection_cache.selection(
    "(name ' CA ' or name ' P  ') and (altloc 'A' or altloc ' ')")
  last_i_seq = None
  last_labels = None
  atoms = pdb_hierarchy.atoms()
  bonds = shared.stl_set_unsigned(atoms.size())
  for i_seq, atom in enumerate(atoms) :
    labels = atom.fetch_labels()
    if vertices[i_seq] :
      if last_i_seq is not None :
        if (labels.chain_id        == last_labels.chain_id and
            labels.model_id        == last_labels.model_id and
            labels.resseq_as_int() == (last_labels.resseq_as_int() + 1) and
            ((labels.altloc == last_labels.altloc) or
             (labels.altloc == "A" and last_labels.altloc == "") or
             (labels.altloc == ""  and last_labels.altloc == "A"))) :
          bonds[last_i_seq].append(i_seq)
          bonds[i_seq].append(last_i_seq)
      last_i_seq = i_seq
      last_labels = labels
  return bonds

def format_atom_label (atom_info) :
  return ("%s %s%s %s %s" % (atom_info.name, atom_info.altloc,
        atom_info.resname, atom_info.chain_id, atom_info.resid())).strip()


 *******************************************************************************


 *******************************************************************************
crys3d/probe_dots.py
from __future__ import absolute_import, division, print_function

import gltbx.gl_managed
from gltbx.gl import *
from libtbx import group_args

class probe_dots_mixin (object) :
  def __init__ (self) :
    self._dots = []
    self.probe_dots_dispaly_list = None
    self.flag_show_probe_dots = True
    self.flag_show_probe_hb = True
    self.flag_show_probe_wc = True
    self.flag_show_probe_cc = True
    self.flag_show_probe_so = True
    self.flag_show_probe_bo = True

  def read_probe_dots_unformatted (self, file_name) :
    lines = open(file_name).readlines()
    for line in lines :
      fields = line.split(":")
      gap = float(fields[6])
      if (fields[2] == "hb") : c = (0.2, 0.8, 0.4)
      elif (gap > 0.35) :  c = (0.2,0.2,1.0)
      elif (gap > 0.25) :  c = (0.2, 0.6, 1.0)
      elif (gap > 0.15) :  c = (0.2, 1.0, 1.0)
      elif (gap > 0.0) :   c = (0.2, 1.0, 0.2)
      elif (gap > -0.1) :  c = (0.8, 1.0, 0.2)
      elif (gap > -0.2) :  c = (1.0, 1.0, 0.0)
      elif (gap > -0.3) :  c = (1.0, 0.6, 0.0)
      elif (gap > -0.4) :  c = (1.0, 0.0, 0.0)
      else :               c = (1.0, 0.4, 0.4)
      dot = group_args(
        dot_type=fields[2],
        atom1=fields[3],
        atom2=fields[4],
        color=c,
        xyz1=(float(fields[7]), float(fields[8]), float(fields[9])),
        xyz2=(float(fields[14]), float(fields[15]), float(fields[16])))
      self._dots.append(dot)

  def draw_probe_dots (self) :
    glEnable(GL_LINE_SMOOTH)
    glEnable(GL_BLEND)
    glHint(GL_LINE_SMOOTH_HINT, GL_NICEST)
    glDisable(GL_LIGHTING)
    if (self.probe_dots_display_list is None) :
      self.probe_dots_display_list = gltbx.gl_managed.display_list()
      self.probe_dots_display_list.compile()
      glLineWidth(2.0)
      for dot in self._dots :
        glColor3f(*(dot.color))
        glBegin(GL_LINES)
        glVertex3f(*(dot.xyz1))
        glVertex3f(*(dot.xyz2))
        glEnd()
      self.probe_dots_display_list.end()
    self.probe_dots_display_list.call()


 *******************************************************************************


 *******************************************************************************
crys3d/programs/HKLinfo.py
from __future__ import absolute_import, division, print_function

try:
  from phenix.program_template import ProgramTemplate
except ImportError:
  from libtbx.program_template import ProgramTemplate
import os

from iotbx.gui_tools.reflections import ArrayInfo
from iotbx.reflection_file_reader import any_reflection_file


class Program(ProgramTemplate):
  prog = os.getenv('LIBTBX_DISPATCHER_NAME')
  description="""
  %(prog)s reflectionfile
or
  %(prog)s reflectionfile philinput.txt

where reflectionfile can be any of the conventional reflection file formats
such as .mtz, .cif, .sca or .hkl file. This will print a table to the screen
listing properties of the reflection data arrays present in the file. The
name of the properties to be listed can be shown by typing:
%(prog)s --show-defaults
and noting which PHIL parameters in the scope \"selected_info\" are set to True.
These can be changed either by specifying these on the command line or by
entering the assignments into a text file, say \"philinput.txt\" that is
submitted on the command line together with the name of the reflection file.
""" % locals()

  datatypes = ['miller_array', 'phil' ]
  master_phil_str ="""
merge_equivalents = False
  .type = bool
  .caption = "merging symmetry equivalent reflections into unique wedge in reciprocal space"
  .short_caption = "merging reflections into a symmetry unique wedge"
reconstruct_amplitudes = False
  .type = bool
  .caption = "Convert mean amplitudes, F,SIGF, and anomalous differences, DANO,SIGDANO, into anomalous arrays, F(+),SIGF(+),F(-),SIGF(-)"
  .short_caption = "Turn mean amplitudes and anomalous differences into anomalous arrays"
""" + ArrayInfo.arrayinfo_phil_str

  def validate(self):
    pass

  def run(self):
    """
    Print a table of properties of miller_array objects from a reflection file to stdout formatted like

  7 Miller arrays in this dataset:
   Labels        |       Type      |  #HKLs  |     min,max data       |Anomalous|Sym.uniq.|Data compl.|
    R-free-flags |     R-free flag |   30451 |        0.0,         1.0|   False |    True |    0.9999 |
    FOBS,SIGFOBS |       Amplitude |   30443 |     3.9975,      1557.4|   False |    True |   0.99964 |
    IOBS,SIGIOBS |       Intensity |   30451 |    -484.25,  2.1485e+05|   False |    True |    0.9999 |
   I(+),SIGI(+),
    I(-),SIGI(-) |       Intensity |   57347 |    -727.01,  2.1485e+05|    True |    True |    0.9984 |
   F(+),SIGF(+),
    F(-),SIGF(-) |       Amplitude |   57338 |     3.9975,      1557.4|    True |    True |   0.99824 |
            DANO |  Floating-point |   30451 |    -102.58,      194.38|   False |    True |    0.9999 |
           SIGDP |       Amplitude |   30450 |        0.0,      85.081|   False |    True |   0.99987 |

    """
    data_file = self.data_manager.get_miller_array_names()[0]
    hkl_file = any_reflection_file(data_file)
    arrays = hkl_file.as_miller_arrays(merge_equivalents=self.params.merge_equivalents,
                                       reconstruct_amplitudes=self.params.reconstruct_amplitudes)

    print("%d Miller arrays in this dataset:" %len(arrays))
    delimiter = self.params.delimiter
    array_info_format_tpl=[]
    for i,array in enumerate(arrays):
      arrayinfo = ArrayInfo(array,self.params.wrap_labels)
      info_fmt, headerstr, infostr = arrayinfo.get_selected_info_columns_from_phil(self.params)
      if i==0:
        print(headerstr)
      print(infostr)


 *******************************************************************************


 *******************************************************************************
crys3d/programs/__init__.py


 *******************************************************************************


 *******************************************************************************
crys3d/qttbx/__init__.py
from __future__ import absolute_import, division, print_function
from libtbx import adopt_optional_init_args
import gltbx
import gltbx.util
from gltbx.gl import *
from gltbx.glu import *
from PyQt4.QtOpenGL import *
from PyQt4.QtCore import *
from PyQt4.QtGui import *
from scitbx import matrix as mat
import math
from six.moves import zip

class widget_with_fp_exception_trapping_off_mixin(object):

  def show(self):
    from boost_adaptbx.boost.python import ext
    try:
      division_by_zero = ext.is_division_by_zero_trapped()
      invalid = ext.is_invalid_trapped()
      overflow = ext.is_overflow_trapped()
      ext.trap_exceptions(division_by_zero=False,
                          invalid=False,
                          overflow=False)
      super(widget_with_fp_exception_trapping_off_mixin, self).show()
    finally:
      ext.trap_exceptions(division_by_zero=division_by_zero,
                          invalid=invalid,
                          overflow=overflow)

class widget(widget_with_fp_exception_trapping_off_mixin,
             QGLWidget):

  from_here = (0,0,0)
  to_there =  (1,1,1)
  clear_colour = (0.9, 0.92, 0.94, 1)
  fovy = 30
  orthographic = False
  zoom = 1.
  mouse_rotation_scale = 0.6
  mouse_wheel_scale = 0.002
  mouse_translation_scale = 0.01
  unit_cell_axis_label_font = QFont("Helvetica", pointSize=16)
  is_unit_cell_shown = True
  is_bounding_box_shown = False

  def __init__(self, unit_cell, light_position, **kwds):
    super(widget, self).__init__(QGLFormat(QGL.SampleBuffers),)
    adopt_optional_init_args(self, kwds)
    self.unit_cell = unit_cell
    self.light_position = light_position
    self.set_extent(self.from_here, self.to_there)
    self.orthogonaliser = gltbx.util.matrix(
      unit_cell.orthogonalization_matrix())
    self.orbiting = None
    self.dolly = None
    self.mouse_position = None

  def set_extent(self, from_here, to_there):
    self.from_here = mat.col(from_here)
    self.to_there = mat.col(to_there)
    self.object_centre_wrt_frac = (self.from_here + self.to_there)/2
    self.object_centre_wrt_cart = mat.col(
      self.unit_cell.orthogonalize(self.object_centre_wrt_frac))
    dx, dy, dz = self.unit_cell.orthogonalize(self.to_there - self.from_here)
    diameter_sq = max(
      u**2 + v**2 + w**2
      for u,v,w in ((dx, dy, dz), (dx, dy, -dz), (dx, -dy, dz), (-dx, dy, dz)))
    self.object_radius = math.sqrt(diameter_sq)/2

  def show_unit_cell(self, flag):
    self.is_unit_cell_shown = flag
    self.updateGL()

  def eye_distance(self):
    return self.object_radius / math.tan(self.fovy/2*math.pi/180)
  eye_distance = property(eye_distance)

  def initializeGL(self):
    glEnable(GL_MULTISAMPLE) # does not seem needed with Qt 4.7
                             # on MacOS 10.6.1
    glEnable(GL_DEPTH_TEST)
    glEnable(GL_NORMALIZE)
    glClearColor(*self.clear_colour)
    glMatrixMode(GL_MODELVIEW)
    glPushMatrix()
    glLoadIdentity()
    self.orbiting = gltbx.util.matrix().get()
    self.dolly = gltbx.util.matrix().get()
    glPopMatrix()

    glEnable(GL_LIGHTING)
    glEnable(GL_LIGHT0)
    glLightModelfv(GL_LIGHT_MODEL_AMBIENT, (0.7,)*3 + (1,))
    glLightModeli(GL_LIGHT_MODEL_TWO_SIDE, GL_TRUE)
    glPushMatrix()
    glLoadIdentity()
    glLightfv(GL_LIGHT0, GL_POSITION, self.light_position)
    glPopMatrix()
    gltbx.util.handle_error()
    self.initialise_opengl()

  def resizeGL(self, w=None, h=None):
    if w is None: w = self.width()
    if h is None: h = self.height()
    w = max(w, 1)
    h = max(h, 1)
    aspect = w/h
    glViewport(0, 0, w, h)
    glMatrixMode(GL_PROJECTION)
    glLoadIdentity()
    zoomed_radius = self.object_radius / self.zoom
    far = self.eye_distance + zoomed_radius
    near = self.eye_distance - zoomed_radius
    if self.orthographic:
      left = bottom = -zoomed_radius
      right = top = zoomed_radius
      if aspect < 1:
        bottom /= aspect
        top /= aspect
      else:
        left *= aspect
        right *= aspect
      glOrtho(left, right, bottom, top, near, far)
    else:
      gluPerspective(aspect=w/h, fovy=self.fovy/self.zoom,
                     zNear=near, zFar=far)

  def paintGL(self):
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)
    glMatrixMode(GL_MODELVIEW)
    glLoadIdentity()
    glTranslatef(0, 0, -self.eye_distance)
    self.dolly.multiply()
    self.orbiting.multiply()
    glPushMatrix()
    glTranslatef(*-self.object_centre_wrt_cart)
    self.draw_object_in_cartesian_coordinates()
    glPopMatrix()
    glPushMatrix()
    self.orthogonaliser.multiply()
    glTranslatef(*-self.object_centre_wrt_frac)
    if self.is_unit_cell_shown: self.draw_unit_cell()
    if self.is_bounding_box_shown: self.draw_bounding_box()
    self.draw_object_in_fractional_coordinates()
    glPopMatrix()

  def draw_object_in_cartesian_coordinates(self):
    pass

  def draw_object_in_fractional_coordinates(self):
    pass

  def draw_unit_cell(self):
    glPushAttrib(GL_LIGHTING_BIT)
    glDisable(GL_LIGHTING)

    glColor3f(0.5, 0.5, 0.5)

    e = -0.02
    for pos, label in zip([(1/2, e, e), (e, 1/2, e), (e, e, 1/2)],
                          ['a','b','c']):
      self.renderText(pos[0], pos[1], pos[2], label,
                      self.unit_cell_axis_label_font)

    glPushAttrib(GL_LINE_BIT)
    glLineWidth(3)

    glBegin(GL_LINE_LOOP)
    glVertex3f(0,0,0)
    glVertex3f(1,0,0)
    glVertex3f(1,1,0)
    glVertex3f(0,1,0)
    glEnd()
    glBegin(GL_LINE_LOOP)
    glVertex3f(0,0,1)
    glVertex3f(1,0,1)
    glVertex3f(1,1,1)
    glVertex3f(0,1,1)
    glEnd()
    glBegin(GL_LINES)
    glVertex3f(0,0,0)
    glVertex3f(0,0,1)
    glVertex3f(1,0,0)
    glVertex3f(1,0,1)
    glVertex3f(1,1,0)
    glVertex3f(1,1,1)
    glVertex3f(0,1,0)
    glVertex3f(0,1,1)
    glEnd()

    glPopAttrib() # line

    glPopAttrib() # light

  def draw_bounding_box(self):
    glPushAttrib(GL_LIGHTING_BIT)
    glDisable(GL_LIGHTING)

    glColor3f(0.8, 0.5, 0.1)

    glPushAttrib(GL_LINE_BIT)
    glLineWidth(3)

    x0, y0, z0 = self.from_here
    x1, y1, z1 = self.to_there

    glBegin(GL_LINE_LOOP)
    glVertex3f(x0,y0,z0)
    glVertex3f(x1,y0,z0)
    glVertex3f(x1,y1,z0)
    glVertex3f(x0,y1,z0)
    glEnd()
    glBegin(GL_LINE_LOOP)
    glVertex3f(x0,y0,z1)
    glVertex3f(x1,y0,z1)
    glVertex3f(x1,y1,z1)
    glVertex3f(x0,y1,z1)
    glEnd()
    glBegin(GL_LINES)
    glVertex3f(x0,y0,z0)
    glVertex3f(x0,y0,z1)
    glVertex3f(x1,y0,z0)
    glVertex3f(x1,y0,z1)
    glVertex3f(x1,y1,z0)
    glVertex3f(x1,y1,z1)
    glVertex3f(x0,y1,z0)
    glVertex3f(x0,y1,z1)
    glEnd()

    glPopAttrib() # line

    glPopAttrib() # light

  show_inspector = pyqtSignal()

  def keyPressEvent(self, event):
    if event.key() == Qt.Key_F5:
      QApplication.instance().quit()
    elif event.key() == Qt.Key_I and event.modifiers() & Qt.ControlModifier:
      self.show_inspector.emit()

  def mousePressEvent(self, event):
    if event.button() == Qt.LeftButton:
      self.mouse_position = event.pos()

  def mouseReleaseEvent(self, event):
    if event.button() == Qt.LeftButton:
      self.mouse_position = None

  def mouseMoveEvent(self, event):
    if self.mouse_position is None: return
    p, p0 = event.pos(), self.mouse_position
    self.mouse_position = p
    delta_x, delta_y = p.x() - p0.x(), p.y() - p0.y()
    if event.modifiers() == Qt.NoModifier:
      if not self.orbiting: return
      s = self.mouse_rotation_scale
      glMatrixMode(GL_MODELVIEW)
      glPushMatrix()
      glLoadIdentity()
      glRotatef(s*delta_x, 0, 1, 0)
      glRotatef(s*delta_y, 1, 0, 0)
      self.orbiting.multiply()
      self.orbiting.get()
      glPopMatrix()
    elif event.modifiers() == Qt.AltModifier:
      if not self.dolly: return
      s = self.mouse_translation_scale
      glMatrixMode(GL_MODELVIEW)
      glPushMatrix()
      glLoadIdentity()
      glTranslatef(s*delta_x, -s*delta_y, 0)
      self.dolly.multiply()
      self.dolly.get()
      glPopMatrix()
    self.updateGL()

  def wheelEvent(self, event):
    if not self.dolly: return
    s = event.delta()*self.mouse_wheel_scale
    # s > 0 when wheel rotated forward away from the user
    # then we increase zoom, i.e. zoom in
    # i.e. we chose to make the wheel control the camera:
    # forward means get closer, or zoom in
    # unlike the rotation of the structure where we manipulate the object
    # instead, but like scrolling where we move the viewing point and not
    # the text
    self.zoom += s
    self.resizeGL()
    self.updateGL()

  def set_perspective(self, flag):
    if self.orthographic != (not flag):
      self.orthographic = not flag
      self.resizeGL(self.width(), self.height())
      self.updateGL()
    return self



class widget_control_mixin(widget_with_fp_exception_trapping_off_mixin,
                           QWidget):

  def __init__(self, view, *args, **kwds):
    QWidget.__init__(self, *args, **kwds)
    self.view = view
    self.setupUi(self)
    try:
      self.perspectiveBox.setChecked(not self.view.orthographic)
      self.perspectiveBox.stateChanged[int].connect(self.view.set_perspective)
    except AttributeError:
      pass
    try:
      self.unitCellBox.setChecked(self.view.is_unit_cell_shown)
      self.unitCellBox.stateChanged[int].connect(self.view.show_unit_cell)
    except AttributeError:
      pass
    self.view.show_inspector.connect(self.show)


 *******************************************************************************


 *******************************************************************************
crys3d/qttbx/map_viewer.py
from __future__ import absolute_import, division, print_function
from PyQt4 import QtGui
from PyQt4.QtCore import Qt
import gltbx.util
from crys3d import qttbx
import crys3d.qttbx.map_viewer_controls
from gltbx import gl_managed
from gltbx.gl import *
from gltbx.glu import *
from scitbx import iso_surface
from cctbx import maptbx, uctbx

def display(window_title="Map Viewer", **kwds):
  app = QtGui.QApplication([])
  view = map_viewer(**kwds)
  view.setWindowTitle(window_title)
  view.resize(800, 800)
  ctrls = map_viewer_controls(view)
  ctrls.show()
  view.show()
  app.exec_()


class map_viewer_controls(qttbx.widget_control_mixin,
                          qttbx.map_viewer_controls.Ui_Form):

  positive_iso_level_fmt = "%.3g"

  def __init__(self, map_viewer):
    qttbx.widget_control_mixin.__init__(self, map_viewer, None, Qt.Tool)
    self.move(0,50)
    self.wiresBox.setChecked(self.view.wires)
    self.posIsoLevelSlider.setRange(0, 100)
    iso_level_validator = QtGui.QDoubleValidator(self)
    iso_level_validator.setRange(0, self.view.max_density, decimals=3)
    iso_level_validator.setNotation(QtGui.QDoubleValidator.ScientificNotation)
    self.posIsoLevel.setValidator(iso_level_validator)
    self.posIsoLevel.setText(self.positive_iso_level_fmt
                             % self.view.positive_iso_level)

    self.wiresBox.stateChanged[int].connect(self.view.set_wires)
    self.posIsoLevelSlider.valueChanged[int].connect(
      self.posIsoLevelLCD.display)
    self.posIsoLevelSlider.setValue(
      int(self.view.positive_iso_level/self.view.max_density*100))
    self.posIsoLevelSlider.sliderMoved[int].connect(
      self.on_positive_iso_level_slider_moved)
    self.posIsoLevelSlider.valueChanged[int].connect(
      self.posIsoLevelLCD.display)
    self.posIsoLevel.editingFinished.connect(
      self.on_iso_level_field_edited)

  def on_positive_iso_level_slider_moved(self, x):
    iso_level = self.view.max_density*x/100
    self.view.set_positive_iso_level(iso_level)
    self.posIsoLevel.setText(self.positive_iso_level_fmt % iso_level)

  def on_iso_level_field_edited(self):
    iso_level = float(self.posIsoLevel.text())
    self.view.set_positive_iso_level(iso_level)
    self.posIsoLevelSlider.setValue(iso_level/self.view.max_density*100)



class map_viewer(qttbx.widget):

  def __init__(self,
               fft_map=None,
               unit_cell=None, raw_map=None,
               periodic=False,
               positive_iso_level=None,
               iso_level_positive_range_fraction=None,
               negative_iso_level=None,
               iso_level_negative_range_fraction=None,
               wires=True,
               **kwds):
    if fft_map is not None:
      unit_cell = fft_map.unit_cell()
    super(map_viewer, self).__init__(unit_cell=unit_cell,
                                     light_position=(-1, 1, 1, 0),
                                     **kwds)
    assert (fft_map is not None
            or (unit_cell is not None and raw_map is not None))
    assert (positive_iso_level is not None
            or iso_level_positive_range_fraction is not None)
    assert (bool(negative_iso_level is not None)
            ^ bool(iso_level_negative_range_fraction is None))
    if fft_map is not None:
      self.rho = fft_map.real_map()
    else:
      self.rho = raw_map
    density_stats = maptbx.statistics(self.rho)
    self.min_density = density_stats.min()
    self.max_density = density_stats.max()
    if positive_iso_level is not None:
      self.positive_iso_level = positive_iso_level
    else:
      self.positive_iso_level = (
        iso_level_positive_range_fraction*self.max_density)
    if (negative_iso_level is None
        and iso_level_negative_range_fraction is not None):
      negative_iso_level = (
        iso_level_negative_range_fraction*self.min_density)
    self.negative_iso_level = negative_iso_level

    self.periodic = periodic
    self.wires = wires
    self.compute_triangulation()

  def set_positive_iso_level(self, level):
    if self.positive_iso_level != level:
      self.positive_iso_level = level
      self.compute_triangulation()
      self.updateGL()
    return self

  def set_wires(self, flag):
    if self.wires != flag:
      self.wires = flag
      self.updateGL()
    return self

  def compute_triangulation(self):
    self.triangulation = iso_surface.triangulation(
      self.rho, self.positive_iso_level,
      map_extent=(1,1,1),
      from_here=self.from_here,
      to_there=self.to_there,
      periodic=self.periodic,
      ascending_normal_direction=False)

  def initialise_opengl(self):
    glEnableClientState(GL_VERTEX_ARRAY)
    glEnableClientState(GL_NORMAL_ARRAY)
    self.material = gl_managed.material_model(
      ambient_front_colour=(0, 0.25, 0, 1),
      ambient_back_colour=(0., 0.25, 0, 1),
      diffuse_front_colour=(0, 1, 0, 1),
      diffuse_back_colour=(0, 0.75, 0, 1),
      specular_front_colour=(0.5, 0, 0.5, 1),
      specular_focus=100)
    self.wire_colour = (0, 1, 0, 1)

  def draw_object_in_fractional_coordinates(self):
    self.draw_triangulation()

  def draw_triangulation(self):
    if self.wires:
      glPushAttrib(GL_LIGHTING_BIT)
      glDisable(GL_LIGHTING)
      glPolygonMode(GL_FRONT_AND_BACK, GL_LINE)
      glColor4fv(self.wire_colour)
    else:
      glPolygonMode(GL_FRONT_AND_BACK, GL_FILL)
      self.material.execute(specular=not self.wires)
    va = gltbx.util.vertex_array(self.triangulation.vertices,
                                 self.triangulation.normals)
    va.draw_triangles(self.triangulation.triangles)
    if self.wires:
      glPopAttrib()
    gltbx.util.handle_error()

if __name__ == '__main__':
  from scitbx.iso_surface import tst_iso_surface
  uc = uctbx.unit_cell((1,1,1,60,120,90))
  case = tst_iso_surface.triangulation_test_case(
    func=tst_iso_surface.elliptic(),
    grid_size=(5, 3, 2),
    periodic=False,
    lazy_normals=False,
    descending_normals=True)
  display(unit_cell=uc,
          raw_map=case.map,
          positive_iso_level=2.26,
          wires=True,
          is_unit_cell_shown=False,
          orthographic=True)


 *******************************************************************************


 *******************************************************************************
crys3d/qttbx/xray_structure_viewer.py
from __future__ import absolute_import, division, print_function
from PyQt4 import QtGui
from PyQt4.QtCore import Qt
from crys3d import qttbx
import crys3d.qttbx.xray_structure_viewer_controls
from gltbx.gl import *
from gltbx.glu import *
from gltbx import quadrics, gl_managed
from cctbx import crystal
from cctbx.array_family import flex
from cctbx.eltbx import covalent_radii
from scitbx import matrix as mat
from six.moves import zip
import six
from six.moves import range


def display(**kwds):
  app = QtGui.QApplication([])
  view = xray_structure_viewer(**kwds)
  view.resize(800, 800)
  ctrls = xray_structure_viewer_controls(view)
  ctrls.show()
  view.show()
  app.exec_()


class xray_structure_viewer_controls(
  qttbx.widget_control_mixin,
  qttbx.xray_structure_viewer_controls.Ui_Form):

  def __init__(self, xray_structure_viewer):
    qttbx.widget_control_mixin.__init__(self, xray_structure_viewer,
                                        None, Qt.Tool)
    self.move(0,50)
    self.view.set_labels_type(self.labels.currentText())
    self.labels.currentIndexChanged[str].connect(self.view.set_labels_type)
    self.labelFontSize.setValue(self.view.label_font.pointSize())
    self.labelFontSize.valueChanged[int].connect(
      self.view.set_font_size)


class xray_structure_viewer(qttbx.widget):

  material_for = ([
    ('Br', (0.97, 0.86, 0.03), (1   , 0.5 , 0   ) ),
    ( 'C', (0.32,)*3         , (0.75,)*3          ),
    ( 'N', (0   , 0   , 1   ), (0.37, 0.37, 0.63) ),
    ( 'O', (0.91, 0   , 0   ), (0.63, 0.37, 0.37) ),
    ( 'F', (0   , 1   , 0   ), (0.07, 0.35, 0.07) ),
    ('Al', (0   , 0.5 , 0.5 ), (0.37, 0.87, 0.87) ),
    ('Si', (0.98, 0.42, 0.01), (0.62, 0.62, 0.37) ),
    ( 'P', (0.5 , 0   , 0.5 ), (0.5,)*3           ),
    ( 'S', (0.97, 0.85, 0.03), (0.5,)*3           ),
    ('Cl', (0   , 0.25, 0   ), (0.13, 0.65, 0.13) ),
    ('Br', (0.51, 0   , 0   ), (0.72, 0.53, 0.53) ),
    ( 'I', (0.27, 0   , 0.27), (0.87, 0.37, 0.87) ),
    ]

    # Metals (1st row)
    + [
    ( elt, (0   , 0   , 0.49), (0.37, 0.37, 0.62) )
    for elt in ('Ti', 'V', 'Cr', 'Mn', 'Fe', 'Co', 'Ni', 'Cu', 'Zn')
    ]
    )

  default_material = gl_managed.material_model(
    ambient_front_colour=(0.2,)*3,
    diffuse_front_colour=(0.1,)*3)

  material_for = dict([
    (elt, gl_managed.material_model(ambient_front_colour=a,
                                    diffuse_front_colour=b))
    for (elt, a, b) in material_for
    ])

  covalent_bond_tolerance = 0.5 # Angstrom
  distance_cutoff = None
  bonding="covalent"

  def __init__(self, xray_structure, name='??',
               **kwds):
    super(xray_structure_viewer, self).__init__(
      unit_cell=xray_structure.unit_cell(),
      orthographic=True,
      light_position=(-1, 1, 1, 0),
      **kwds)
    assert self.bonding in ("covalent", "all")
    assert self.bonding != "all" or self.distance_cutoff is not None
    self.xray_structure = xs = xray_structure
    self.setWindowTitle("%s in %s" % (name,
                                      xs.space_group().type().hall_symbol()))
    sites_frac = xs.sites_frac()
    self.set_extent(sites_frac.min(), sites_frac.max())
    self.is_unit_cell_shown = False

    sites_cart = self.sites_cart = xs.sites_cart()
    thermal_tensors = xs.extract_u_cart_plus_u_iso()
    self.ellipsoid_to_sphere_transforms = {}
    self.scatterer_indices = flex.std_string()
    self.scatterer_labels = flex.std_string()
    for i, (sc, site, u_cart) in enumerate(zip(xs.scatterers(),
                                                          sites_cart,
                                                          thermal_tensors)):
      t = quadrics.ellipsoid_to_sphere_transform(site, u_cart)
      self.ellipsoid_to_sphere_transforms.setdefault(
        sc.element_symbol(),
        quadrics.shared_ellipsoid_to_sphere_transforms()).append(t)
      self.scatterer_indices.append("# %i" % i)
      self.scatterer_labels.append(sc.label)
    self.labels = None
    self.label_font = QtGui.QFont("Arial Black", pointSize=18)

    if self.bonding == "covalent":
      radii = [
        covalent_radii.table(elt).radius()
        for elt in xs.scattering_type_registry().type_index_pairs_as_dict() ]
      buffer_thickness = 2*max(radii) + self.covalent_bond_tolerance
      asu_mappings = xs.asu_mappings(buffer_thickness=buffer_thickness)
      bond_table = crystal.pair_asu_table(asu_mappings)
      bond_table.add_covalent_pairs(xs.scattering_types(),
                                    tolerance=self.covalent_bond_tolerance)
    elif self.bonding == "all":
      asu_mappings = xs.asu_mappings(buffer_thickness=self.distance_cutoff)
      bond_table = crystal.pair_asu_table(asu_mappings)
      bond_table.add_all_pairs(self.distance_cutoff)

    pair_sym_table = bond_table.extract_pair_sym_table(
      all_interactions_from_inside_asu=True)
    self.bonds = flex.vec3_double()
    self.bonds.reserve(len(xs.scatterers()))
    uc = self.xray_structure.unit_cell()
    frac = mat.rec(uc.fractionalization_matrix(), (3,3))
    inv_frac = frac.inverse()
    site_symms = xs.site_symmetry_table()
    scatt = self.xray_structure.scatterers()
    for i, neighbours in enumerate(pair_sym_table):
      x0 = sites_cart[i]
      sc0 = scatt[i]
      for j, ops in neighbours.items():
        sc1 = scatt[j]
        if sc0.scattering_type == 'H' and sc1.scattering_type == 'H':
          continue
        for op in ops:
          if op.is_unit_mx():
            x1 = sites_cart[j]
          else:
            x1 = uc.orthogonalize(op*sites_frac[j])
            op_cart = inv_frac*mat.rec(op.r().as_double(), (3,3))*frac
            u1 = (op_cart
                  *mat.sym(sym_mat3=thermal_tensors[j])
                  *op_cart.transpose())
            t = quadrics.ellipsoid_to_sphere_transform(x1, u1.as_sym_mat3())
            self.ellipsoid_to_sphere_transforms[sc1.element_symbol()].append(t)
            self.sites_cart.append(x1)
            op_lbl = (" [%s]" % op).lower()
            self.scatterer_indices.append("# %i%s" % (j, op_lbl))
            self.scatterer_labels.append("%s%s" % (sc1.label, op_lbl))
          self.bonds.append(x0)
          self.bonds.append(x1)

  def initialise_opengl(self):
    self.ellipsoid_proto = quadrics.proto_ellipsoid(
      slices=32, stacks=32)
    self.principal_ellipses_tex = \
        quadrics.ellipsoid_principal_sections_texture(darkening=0.75,
                                                      n_s=64, n_t=64)
    self.cylindre_proto = quadrics.proto_cylinder(slices=16)
    self.bond_material = gl_managed.material_model(
      ambient_front_colour=(0.2,)*3,
      diffuse_front_colour=(0.1,)*3)
    glEnable(GL_TEXTURE_2D)
    glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE)

  def draw_object_in_cartesian_coordinates(self):
    self.principal_ellipses_tex.bind()
    for element, transforms in six.iteritems(self.ellipsoid_to_sphere_transforms):
      material = self.material_for.get(element, self.default_material)
      material.execute()
      transforms.draw(self.ellipsoid_proto)
    self.principal_ellipses_tex.unbind()

    self.bond_material.execute()
    for i in range(0, len(self.bonds), 2):
      start, end = self.bonds[i], self.bonds[i+1]
      self.cylindre_proto.draw(start, end, base_radius=0.05)

    if self.labels is not None:
      glPushAttrib(GL_LIGHTING_BIT)
      glDisable(GL_LIGHTING)
      glPushAttrib(GL_DEPTH_BUFFER_BIT)
      glDisable(GL_DEPTH_TEST)
      glColor3f(1, 1, 1)
      e = 0.1
      for x, lbl in zip(self.sites_cart, self.labels):
        self.renderText(x[0]-e, x[1]+e, x[2]-e,
                        lbl,
                        self.label_font)
      glPopAttrib()
      glPopAttrib()

  def set_labels_type(self, kind):
    self.labels = getattr(self, str(kind).lower().replace(' ', '_'), None)
    self.updateGL()

  def set_font_size(self, s):
    self.label_font.setPointSize(s)
    self.updateGL()


 *******************************************************************************


 *******************************************************************************
crys3d/regression/__init__.py


 *******************************************************************************


 *******************************************************************************
crys3d/regression/tests_HKLviewer.py
# -*- coding: utf-8 -*-
from __future__ import absolute_import, division, print_function

import libtbx.load_env, os.path, re, sys, os, time, subprocess
from crys3d.hklviewer import cmdlineframes, jsview_3d
import traceback

os.environ['PYTHONIOENCODING'] = 'UTF-8'


# The tests below uses datasets in this file here
datafname = libtbx.env.find_in_repositories(
  relative_path="iotbx/regression/data/phaser_1.mtz",
  test=os.path.isfile)

closetime = 150 # about half the maximum time each test will run
# HKLviewer uses websockets which is slightly unstable on virtual machines used on Azure.
# This might yield a bogus failure of the test. If so, repeat the test at most maxruns times
# or until it passes whichever comes first.
maxruns = 4
browser = "firefox"

philstr1 = """
clip_plane {
  normal_vector = "K-axis (0,1,0)"
  is_assoc_real_space_vector = True
  clip_width = 2
  hkldist = -9
}
viewer {
  data_array {
    label = "FP,SIGFP"
    datatype = 'Amplitude'
  }
  show_vector = "['K-axis (0,1,0)', True]"
  fixorientation = *vector None
}
hkls.expand_to_p1 = True
hkls.expand_anomalous = True
max_reflections_in_frustum = 70

"""
# These are the indices of visible reflections of phaser_1.mtz when the sphere of reflections
# have been sliced with a clip plane at k= -9, expanded to P1 and Friedel mates
reflections2match1 = set(  [(-3, -9, -1), (-3, -9, -2), (-3, -9, 0), (1, -9, -1), (4, -9, -2),
  (4, -9, -1), (1, -9, -2), (-1, -9, -4), (1, -9, -3), (-1, -9, -3), (-2, -9, -3), (1, -9, -4),
  (-1, -9, -1), (-1, -9, -2), (-2, -9, -1), (-2, -9, -2), (0, -9, 4), (1, -9, 4), (2, -9, -4),
  (3, -9, 1), (2, -9, -3), (0, -9, 2), (3, -9, 0), (-4, -9, 2), (2, -9, -1), (2, -9, -2),
  (0, -9, 3), (3, -9, 2), (-4, -9, 0), (0, -9, 1), (-4, -9, -1), (-4, -9, 1), (0, -9, -1),
  (0, -9, -2), (-2, -9, 4), (-1, -9, 4), (3, -9, -3), (2, -9, 0), (0, -9, -4), (2, -9, 1),
  (0, -9, -3), (2, -9, 2), (-1, -9, 0), (3, -9, -1), (3, -9, -2), (-2, -9, 0), (2, -9, 3),
  (-2, -9, 1), (-1, -9, 1), (1, -9, 3), (-2, -9, 2), (-1, -9, 2), (-3, -9, 3), (4, -9, 0),
  (1, -9, 2), (-2, -9, 3), (-1, -9, 3), (-3, -9, 2), (4, -9, 1), (1, -9, 1), (-3, -9, 1), (1, -9, 0)]
 )


philstr2 = """
clip_plane {
  hkldist = -8
  normal_vector = "H-axis (1,0,0)"
  is_assoc_real_space_vector = True
  clip_width = 2.030853224
}
binning {
  nbins = 2
}
viewer {
  data_array {
    label = "FP,SIGFP"
    datatype = "Amplitude"
  }
  show_vector = "['K-axis (0,1,0)', True]"
  fixorientation = *vector None
}
max_reflections_in_frustum = 40

"""
# These are the indices of visible reflections of phaser_1.mtz when the sphere of reflections
# have been sliced with a clip plane at h= -8
reflections2match2 = set(  [(-8, 4, 3), (-8, 4, 2), (-8, 3, 4), (-8, 4, 1), (-8, 3, 5), (-8, 5, 4),
   (-8, 1, 1), (-8, 4, 5), (-8, 1, 2), (-8, 4, 4), (-8, 1, 3), (-8, 1, 4), (-8, 2, 1), (-8, 1, 5),
   (-8, 5, 1), (-8, 0, 7), (-8, 1, 6), (-8, 5, 2), (-8, 2, 3), (-8, 0, 6), (-8, 1, 7), (-8, 5, 3),
   (-8, 2, 2), (-8, 2, 5), (-8, 0, 4), (-8, 3, 2), (-8, 2, 4), (-8, 0, 3), (-8, 3, 3), (-8, 0, 2),
   (-8, 2, 6), (-8, 3, 1), (-8, 3, 6)]
 )


# Create an array of F/SigF values, make 6 bins of reflections of equal size sorted with values and
# select only reflections from the two bins with the lowest F/SigF values. Then save those to a new file
philstr3 = """
miller_array_operation = "('newarray._data= array1.data()/array1.sigmas()\\nnewarray._sigmas = None', 'FoverSigF2', ['FOBS,SIGFOBS', 'Amplitude'], ['', ''])"
clip_plane {
  hkldist = 9
  normal_vector = "L-axis (0,0,1)"
  is_assoc_real_space_vector = True
  clip_width = 2.030853224
}
binning {
  binlabel = 'FoverSigF2'
  bin_opacity = 1 0
  bin_opacity = 1 1
  bin_opacity = 0 2
  bin_opacity = 0 3
  bin_opacity = 0 4
  bin_opacity = 0 5
  nbins = 6
}
viewer {
  data_array {
    label = "FoverSigF2"
    datatype = "Amplitude"
  }
  fixorientation = *vector None
}
hkls {
  expand_to_p1 = True
  expand_anomalous = True
}
visible_dataset_label = "LowValuesFSigF"
savefilename = "%s"
datasets_to_save = 8
max_reflections_in_frustum = 40
"""
# These are the indices of visible reflections of phaser_1.mtz of the F/SigF dataset created on the fly
# where the sphere of reflections have been sliced with a clip plane at l=9 and only reflections
# with F/SigF<=1 are displayed
reflections2match3 = set([(-5, -2, 9), (2, 1, 9), (-3, -1, 9), (-3, -2, 9), (-2, 4, 9), (-3, 0, 9),
   (-5, 0, 9), (-5, 2, 9), (-4, 1, 9), (-1, 0, 9), (-3, 2, 9), (-1, -3, 9), (-2, -3, 9), (0, -4, 9),
   (-2, 1, 9), (1, -2, 9), (-2, 3, 9), (-1, 3, 9), (2, -1, 9), (2, -2, 9), (-4, -1, 9), (-3, 1, 9),
   (0, 4, 9), (-2, -4, 9), (-2, -1, 9), (2, 2, 9), (1, 2, 9), (-2, 0, 9)]
)

def check_log_file(fname, refls2match):
  with open(fname, "r") as f:
    mstr = f.read()
  # check output file that reflections are reported to have been drawn
  assert re.findall(r"RenderStageObjects\(\) has drawn reflections in the browser", mstr) != []
  # peruse output file for the list of displayed reflections
  match = re.findall(r"visible \s+ hkls\: \s* (\[ .+ \])", mstr, re.VERBOSE)
  refls = []
  if match:
    refls = eval(match[-1]) # use the last match of reflections in the log file
  # check that only the following 108 reflections in refls2match were visible
  setrefls = set(refls)
  if setrefls != refls2match:
    print("Indices of visible reflections:\n%s" %str(setrefls))
    print("Do not match the expected indices:\n%s" %str(refls2match))
  assert setrefls == refls2match
  print("Indices of visible reflections match the expected ones.")


def Append2LogFile(fname, souterr):
  # write terminal output to our log file
  str1 = souterr.decode().replace("\r\n", "\n") # omit \r\n line endings on Windows
  str2 = str(str1).encode(sys.stdout.encoding, errors='ignore').decode(sys.stdout.encoding)
  with open(fname, "a", encoding="utf-8") as f:
    f.write("\nstdout, stderr in terminal: \n" + "-" * 80 + "\n")
    f.write(str2 + "\n")


def exercise_OSbrowser(philstr, refl2match, prefix=""):
  assert os.path.isfile(datafname)
  outputfname = prefix + "HKLviewer.log"

  with open(prefix + "environ.txt","w") as mfile:
    # print environment variables to log file
    for k,v in os.environ.items():
      mfile.write( k + "=" + v + "\n")

  with open(prefix + "HKLviewer_philinput.txt","w") as f:
    f.write(philstr)

  # check we can actually open a browser
  browserpath, webctrl = jsview_3d.get_browser_ctrl(browser)
  #assert webctrl.open("https://get.webgl.org/")
  #subprocess.run('"' + browserpath + '"  https://get.webgl.org/ &', shell=True,
  #               capture_output=False, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
  #time.sleep(10)

  cmdargs = [datafname,
            "phil_file=%sHKLviewer_philinput.txt" %prefix,
            "verbose=2_frustum_threadingmsg_orientmsg_browser", # dump displayed hkls to stdout when clipplaning as well as verbose=2
            "image_file=%sHKLviewer.png" %prefix,
            "UseOSBrowser=%s" %browser,
            "output_filename=" + outputfname, # file with stdout, stderr from hklview_frame
            "closing_time=%d" %closetime,
          ]

  cmdlineframes.run(cmdargs)
  print("=" * 80)
  check_log_file(outputfname, refl2match)


def exerciseQtGUI(philstr, refl2match, prefix=""):
  # These flags enables QWebEngine, Qt5.15 to work on VMs used on Azure
  os.environ["QTWEBENGINE_CHROMIUM_FLAGS"] = " --disable-web-security" \
            + " --enable-webgl-software-rendering --disable-gpu-compositing" \
            + " --disable_chromium_framebuffer_multisample --use-gl=swiftshader" \
            + " --swiftshader --swiftshader-webgl --ignore-gpu-blocklist"
  with open(prefix + "environ.txt","w") as mfile:
    # print environment variables to log file
    for k,v in os.environ.items():
      mfile.write( k + "=" + v + "\n")

  assert os.path.isfile(datafname)
  # First delete any settings from previous HKLviewer runs that might be present on this platform
  print("Removing any previous Qsettings...")
  obj = subprocess.Popen("cctbx.HKLviewer remove_settings",
                         shell=True,
                         env = os.environ,
                         stdin = subprocess.PIPE,
                         stdout = subprocess.PIPE,
                         stderr = subprocess.STDOUT)
  remove_settings_result,err = obj.communicate()

  print("Starting the real HKLviewer test...")
  with open(prefix + "HKLviewer_philinput.txt","w") as f:
    f.write(philstr)

  outputfname = prefix + "HKLviewer.log"
  if os.path.isfile(outputfname):
    os.remove(outputfname)

  cmdargs = ["cctbx.HKLviewer",
             datafname,
             "phil_file=%sHKLviewer_philinput.txt" %prefix,
             "verbose=2_frustum_threadingmsg_orientmsg_browser", # dump displayed hkls to stdout when clipplaning as well as verbose=2
             "image_file=%sHKLviewer.png" %prefix,
             "output_filename=" + outputfname, # file with stdout, stderr from hklview_frame
             "closing_time=%d" %closetime, # close HKLviewer after 25 seconds
            ]

  obj = subprocess.Popen(" ".join(cmdargs),
                         shell=True,
                         env = os.environ,
                         stdin = subprocess.PIPE,
                         stdout = subprocess.PIPE,
                         stderr = subprocess.STDOUT)
  HKLviewer_result,err = obj.communicate()
  # append terminal output to log file
  Append2LogFile(outputfname, remove_settings_result)
  Append2LogFile(outputfname, HKLviewer_result)
  print("retval: " + str(obj.returncode))
  print("=" * 80)
  check_log_file(outputfname, refl2match)



def runagain(func, philstr, refl2match, name):
  try:
    func(philstr, refl2match, name)
    print("OK\n")
    return False
  except Exception as e:
    print( str(e) + traceback.format_exc(limit=10))
    return True


 *******************************************************************************


 *******************************************************************************
crys3d/regression/tst_HKLviewerOSbrowserBinFSigF.py
# -*- coding: utf-8 -*-
from __future__ import absolute_import, division, print_function
from crys3d.regression import tests_HKLviewer
from libtbx.test_utils import contains_substring
import os, sys, subprocess

os.environ['PYTHONIOENCODING'] = 'UTF-8'

# Using a webbrowser exercise_OSbrowser() runs HKLviewer to enact the settings in philstr3 and
# eventually asserts that the visible reflections in the browser match the indices in
# reflections2match3. Due to occasional instability of websockets on virtual machines the test
# is run in a loop until it passes but no longer than maxruns times.

# This test is creating the F/SigF dataset on the fly from iotbx/regression/data/phaser_1.mtz,
# expands data to P1 with Friedel pairs, slices with a clip plane at l=9 and only shows
# reflections with F/SigF<=1. Then saves those reflections to a new file OSbrowserLowValueBinFSigF.mtz.
# Then checks that this file matches the info in expectedstr

expectedstr = """
Starting job
===============================================================================
1 Miller arrays in this dataset:
 Labels          |       Type      |   /   |  #HKLs  |               Span              |     min,max data       |     min,max sigmas     |  d_min,d_max/   |Anomalous|Sym.uniq.|Data compl.|
  LowValuesFSigF |       Amplitude |       1 |     363 |           (-9, 0, 0), (9, 9, 9) |    0.78407,       11.26|        nan,         nan|     2.5,    8.771|   False |    True |   0.33925 |

===============================================================================
Job complete
"""

def run():
  if 'linux' in sys.platform and os.environ.get("DISPLAY", None) != "0:0":
    return # Only run test if on a local linux machine with a connected monitor
  count = 0
  while True:
    print("running %d" %count)
    # exercise_OSbrowser() is unstable and might yield a bogus failure. If so, repeat the test
    # at most maxruns times or until it passes
    if not tests_HKLviewer.runagain(tests_HKLviewer.exercise_OSbrowser,
                                    tests_HKLviewer.philstr3 %"OSbrowserLowValueBinFSigF.mtz",
                                    tests_HKLviewer.reflections2match3,
                                    "OSbrowserBinFSigF"):
      break
    count +=1
    assert(count < tests_HKLviewer.maxruns)

  # Now check that the produced mtz file matches the info in expectedstr
  obj = subprocess.Popen("cctbx.HKLinfo OSbrowserLowValueBinFSigF.mtz",
                          shell=True,
                          stdin = subprocess.PIPE,
                          stdout = subprocess.PIPE,
                          stderr = subprocess.STDOUT)
  souterr,err = obj.communicate()
  tests_HKLviewer.Append2LogFile("OSbrowserBinFSigFHKLviewer.log", souterr)
  souterr = souterr.decode().replace("\r\n", "\n") # omit \r\n line endings on Windows
  assert (contains_substring( souterr, expectedstr ) )


if __name__ == '__main__':
  run()


 *******************************************************************************


 *******************************************************************************
crys3d/regression/tst_HKLviewerOSbrowserSliceK-9.py
from __future__ import absolute_import, division, print_function
from crys3d.regression import tests_HKLviewer
import os, sys

# Using a webbrowser exercise_OSbrowser() runs HKLviewer to enact the settings in philstr1 and
# eventually asserts that the visible reflections in the browser match the indices in
# reflections2match1. Due to occasional instability of websockets on virtual machines the test
# is run in a loop until it passes but no longer than maxruns times.

# Using a webbrowser test expanding amplitude data from iotbx/regression/data/phaser_1.mtz
# to P1 with Friedel pairs, slice with a clip plane at k= -9

def run():
  if 'linux' in sys.platform and os.environ.get("DISPLAY", None) != "0:0":
    return # Only run test if on a local linux machine with a connected monitor
  count = 0
  while True:
    print("running %d" %count)
    # exercise_OSbrowser() is unstable and might yield a bogus failure. If so, repeat the test
    # at most maxruns times or until it passes
    if not tests_HKLviewer.runagain(tests_HKLviewer.exercise_OSbrowser,
                                    tests_HKLviewer.philstr1,
                                    tests_HKLviewer.reflections2match1,
                                    "OSbrowserSliceK-9" ):
      break
    count +=1
    assert(count < tests_HKLviewer.maxruns)

if __name__ == '__main__':
  run()


 *******************************************************************************


 *******************************************************************************
crys3d/regression/tst_HKLviewerQtGuiBinFSigF.py
# -*- coding: utf-8 -*-
from __future__ import absolute_import, division, print_function
from crys3d.regression import tests_HKLviewer
from libtbx.test_utils import contains_substring
import os, sys, subprocess

os.environ['PYTHONIOENCODING'] = 'UTF-8'

# Using the HKLviewer Qt GUI exerciseQtGUI() runs HKLviewer to enact the settings in philstr3 and
# eventually asserts that the visible reflections in the browser match the indices in
# reflections2match3. Due to occasional instability of websockets on virtual machines the test
# is run in a loop until it passes but no longer than maxruns times.

# This test is creating the F/SigF dataset on the fly from iotbx/regression/data/phaser_1.mtz,
# expands data to P1 with Friedel pairs, slices with a clip plane at l=9 and only shows
# reflections with F/SigF<=1. Then saves those reflections to a new file OSbrowserLowValueBinFSigF.mtz.
# Then checks that this file matches the info in expectedstr

expectedstr = """
Starting job
===============================================================================
1 Miller arrays in this dataset:
 Labels          |       Type      |   /   |  #HKLs  |               Span              |     min,max data       |     min,max sigmas     |  d_min,d_max/   |Anomalous|Sym.uniq.|Data compl.|
  LowValuesFSigF |       Amplitude |       1 |     363 |           (-9, 0, 0), (9, 9, 9) |    0.78407,       11.26|        nan,         nan|     2.5,    8.771|   False |    True |   0.33925 |

===============================================================================
Job complete
"""

def run():
  if 'linux' in sys.platform and os.environ.get("DISPLAY", None) != "0:0":
    return # Only run test if on a local linux machine with a connected monitor
  count = 0
  while True:
    print("running %d" %count)
    # exerciseQtGUI() is unstable and might yield a bogus failure. If so, repeat the test
    # at most maxruns times or until it passes
    if not tests_HKLviewer.runagain(tests_HKLviewer.exerciseQtGUI,
                                    tests_HKLviewer.philstr3 %"QtGuiLowValueBinFSigF.mtz",
                                    tests_HKLviewer.reflections2match3,
                                    "QtGuiBinFSigF"):
      break
    count +=1
    assert(count < tests_HKLviewer.maxruns)

  # Now check that the produced mtz file matches the info in expectedstr
  obj = subprocess.Popen("cctbx.HKLinfo QtGuiLowValueBinFSigF.mtz",
                          shell=True,
                          stdin = subprocess.PIPE,
                          stdout = subprocess.PIPE,
                          stderr = subprocess.STDOUT)
  souterr,err = obj.communicate()
  tests_HKLviewer.Append2LogFile("QtGuiBinFSigFHKLviewer.log", souterr)
  souterr = souterr.decode().replace("\r\n", "\n") # omit \r\n line endings on Windows
  assert (contains_substring( souterr, expectedstr ) )


if __name__ == '__main__':
  run()


 *******************************************************************************


 *******************************************************************************
crys3d/regression/tst_HKLviewerQtGuiSliceK-9.py
from __future__ import absolute_import, division, print_function
from crys3d.regression import tests_HKLviewer
import os, sys

# Using the HKLviewer Qt GUI exerciseQtGUI() runs HKLviewer to enact the settings in philstr1 and
# eventually asserts that the visible reflections in the browser match the indices in
# reflections2match1. Due to occasional instability of websockets on virtual machines the test
# is run in a loop until it passes but no longer than maxruns times.

# With the HKLviewer Qt GUI test expanding amplitude data from iotbx/regression/data/phaser_1.mtz
# to P1 with Friedel pairs, slice with a clip plane at k= -9

def run():
  if 'linux' in sys.platform and os.environ.get("DISPLAY", None) != "0:0":
    return # Only run test if on a local linux machine with a connected monitor
  count = 0
  while True:
    print("running %d" %count)
    # exerciseQtGUI() is unstable and might yield a bogus failure. If so, repeat the test
    # at most maxruns times or until it passes
    if not tests_HKLviewer.runagain(tests_HKLviewer.exerciseQtGUI,
                                    tests_HKLviewer.philstr1,
                                    tests_HKLviewer.reflections2match1,
                                    "QtGuiSliceK-9" ):
      break
    count +=1
    assert(count < tests_HKLviewer.maxruns)

if __name__ == '__main__':
  run()


 *******************************************************************************


 *******************************************************************************
crys3d/regression/tst_hklinfo.py
# -*- coding: utf-8 -*-
from __future__ import absolute_import, division, print_function

from libtbx.test_utils import contains_substring
import os, subprocess

os.environ['PYTHONIOENCODING'] = 'UTF-8'

test1_cifstr = """
data_r4jglsf
#
_audit.revision_id    1_0
_audit.creation_date  2013-04-03
_audit.update_record
;The data loops contain the following:
 structure factors used in refinement, from crystal 185601 that is a Met-Inhibition crystal.
 unmerged original index intensities of data set used for refinement and phasing, this data set comes from crystal 185601 that is a Met-Inhibition crystal, wavelength 1.
 unmerged original index intensities of data set used for phasing, this data set comes from crystal 185601 that is a Met-Inhibition crystal, wavelength 2.
 unmerged original index intensities of data set used for phasing, this data set comes from crystal 185601 that is a Met-Inhibition crystal, wavelength 3.
 experimental phases from crystal 185601 that is a Met-Inhibition crystal.
 density modified experimental phases from crystal 185601 that is a Met-Inhibition crystal.
;
#
_cell.entry_id      4jgl
_cell.length_a      79.322
_cell.length_b      79.322
_cell.length_c      50.113
_cell.angle_alpha   90.000
_cell.angle_beta    90.000
_cell.angle_gamma   120.000
#
loop_
_diffrn_radiation_wavelength.id
_diffrn_radiation_wavelength.wavelength
1 0.918401
2 0.979338
3 0.979108
#
_entry.id   4jgl
#
_exptl_crystal.id   1
#
_reflns_scale.group_code   1
#
_symmetry.entry_id               4jgl
_symmetry.space_group_name_H-M   'P 61'
#
#
loop_
_refln.crystal_id
_refln.wavelength_id
_refln.scale_group_code
_refln.index_h
_refln.index_k
_refln.index_l
_refln.status
_refln.F_meas_au
_refln.F_meas_sigma_au
_refln.F_calc
_refln.phase_calc
1 1 1    0    0    3 o   1055.8   38.2     1482.3     7.0
1 1 1    0    0   12 x        ?      ?     1790.1   149.3
1 1 1    3   32    3 o    204.3    3.6      199.8   328.7
1 1 1    3   32    4 o     37.8    5.6       30.8    26.8
1 1 1    3   32    5 o    216.6    3.9      184.1   304.7
1 1 1    3   32    6 o     54.2    3.7       65.5   335.2
1 1 1    3   32    7 f     85.2    3.0      103.4    80.7
1 1 1    3   32    8 o    138.0    3.5      118.6   305.6
1 1 1    3   32    9 o    139.2    3.3      122.3   302.1
1 1 1    3   32   10 o     33.0    5.5       21.9   357.2
1 1 1    3   32   11 o    102.9    3.5      105.7   129.7
1 1 1    3   32   12 o     57.9    5.2       52.7   182.7
1 1 1   54    1    0 f     20.6    9.6       28.9   180.0
1 1 1   54    1    4 o     15.6    5.4       19.4   331.4
1 1 1   54    1    5 o     25.2    6.6       16.9    69.0
#END
data_r4jglAsf
#
_cell.entry_id      4jgl
_cell.length_a      79.3216
_cell.length_b      79.3216
_cell.length_c      50.1126
_cell.angle_alpha   90.0000
_cell.angle_beta    90.0000
_cell.angle_gamma   120.0000
#
_diffrn.id                  1
_diffrn.crystal_id          1
_diffrn.ambient_temp        ?
_diffrn.crystal_treatment   ?
_diffrn.details
;   unmerged original index intensities of data set used for refinement  and phasing.
;
#
_entry.id   4jgl
#
_exptl_crystal.id   1
#
_reflns_scale.group_code   1
#
#
loop_
_refln.crystal_id
_refln.wavelength_id
_refln.scale_group_code
_refln.index_h
_refln.index_k
_refln.index_l
_refln.status
_refln.intensity_meas
_refln.intensity_sigma
1 1 1    0    0    2  o       5.3     11.4
1 1 1    0    0   -2  o      13.4     13.3
1 1 1    0    0    3  o      -5.9      9.6
1 1 1    0    0   -3  o      14.8     14.3
1 1 1    2   -2  -36  o    1056.4    235.7
1 1 1    2    0  -36  o    1176.5    218.3
1 1 1    0   -2   36  o     788.1    195.6
1 1 1    2   -2   36  o     984.7    196.5
1 1 1   -1   55    5  o     285.9    179.5
1 1 1    1  -55   -5  o    -105.2    188.9
1 1 1  -55   54    5  o     558.6    268.4
1 1 1   55  -54   -5  o     340.6    311.3
1 1 1  -54   -1    5  o     153.0    129.0
1 1 1  -54   -1    5  o      -8.7    101.3
1 1 1    1  -55    5  o      52.0    249.1
1 1 1   -1   55   -5  o     -80.1    130.8
1 1 1   55  -54    5  o     576.9    272.9
1 1 1  -55   54   -5  o     219.8    205.6
#END
data_r4jglBsf
#
_cell.entry_id      4jgl
_cell.length_a      79.3132
_cell.length_b      79.3132
_cell.length_c      50.1025
_cell.angle_alpha   90.0000
_cell.angle_beta    90.0000
_cell.angle_gamma   120.0000
#
_diffrn.id                  1
_diffrn.crystal_id          1
_diffrn.ambient_temp        ?
_diffrn.crystal_treatment   ?
_diffrn.details
'   unmerged original index intensities of data set used for phasing.'
#
_entry.id   4jgl
#
_exptl_crystal.id   1
#
_reflns_scale.group_code   1
#
#
loop_
_refln.crystal_id
_refln.wavelength_id
_refln.scale_group_code
_refln.index_h
_refln.index_k
_refln.index_l
_refln.status
_refln.intensity_meas
_refln.intensity_sigma
1 2 1    0    0    2  o       2.5      7.6
1 2 1    0    0   -2  o       0.5     11.0
1 2 1    0    0    3  o      20.5     17.2
1 2 1   -1    0  -12  o   22476.8   2327.6
1 2 1    0   -1  -12  o   22730.3   1962.0
1 2 1    1   -1  -12  o   23595.6   1782.0
1 2 1   -1    0   12  o   24913.4   1960.4
1 2 1    1    0  -12  o   23227.8   1777.6
1 2 1   -1    1  -12  o   22906.0   2033.0
1 2 1    0   -1  -14  o   10141.0    877.2
1 2 1   -1    1   14  o    8471.0    838.7
1 2 1    1   -1  -14  o   10248.7    748.4
1 2 1   -1    0   14  o    7835.0    786.6
1 2 1    1  -55    4  o     -43.1     74.1
1 2 1    1  -55    5  o     105.6     60.3
1 2 1   55  -54    5  o     303.0    276.2
1 2 1  -55   54   -5  o     -44.3    127.2
#END
data_r4jglCsf
#
_cell.entry_id      4jgl
_cell.length_a      79.4003
_cell.length_b      79.4003
_cell.length_c      50.1616
_cell.angle_alpha   90.0000
_cell.angle_beta    90.0000
_cell.angle_gamma   120.0000
#
_diffrn.id                  1
_diffrn.crystal_id          1
_diffrn.ambient_temp        ?
_diffrn.crystal_treatment   ?
_diffrn.details
'   unmerged original index intensities of data set used for phasing.'
#
_entry.id   4jgl
#
_exptl_crystal.id   1
#
_reflns_scale.group_code   1
#
#
loop_
_refln.crystal_id
_refln.wavelength_id
_refln.scale_group_code
_refln.index_h
_refln.index_k
_refln.index_l
_refln.status
_refln.intensity_meas
_refln.intensity_sigma
1 3 1    0    0    2  o       2.2     14.2
1 3 1    0    0   -2  o      12.7     14.3
1 3 1    0    0    3  o      -9.5      3.8
1 3 1    0    0   -3  o      -8.2      3.9
1 3 1    0    0    4  o      20.2     22.1
1 3 1   11  -11   20  o    7381.3    861.9
1 3 1  -11   11  -20  o    8143.7    797.9
1 3 1   11    0   20  o    7939.2    822.9
1 3 1   11    0   20  o    8401.4    889.9
1 3 1  -49   -2    5  o    -682.5    697.3
1 3 1   50    1    1  o     164.3    164.9
1 3 1  -50   -1   -1  o    1390.9    464.9
1 3 1   -1   51    1  o    -589.3    274.5
1 3 1    1  -51   -1  o     903.4    414.8
1 3 1  -51   50    1  o      63.5     67.2
1 3 1  -50   -1    1  o   -1052.0    570.9
1 3 1   50    1   -1  o     174.0    158.8
1 3 1    1  -51    1  o     198.8    479.5
1 3 1   -1   51   -1  o    -259.0    239.2
#END
data_r4jglDsf
#
_cell.entry_id      4jgl
_cell.length_a      79.3130
_cell.length_b      79.3130
_cell.length_c      50.1030
_cell.angle_alpha   90.0000
_cell.angle_beta    90.0000
_cell.angle_gamma   120.0000
#
_diffrn.id                  1
_diffrn.crystal_id          1
_diffrn.ambient_temp        ?
_diffrn.crystal_treatment   ?
_diffrn.details             '  experimental phases.'
#
_entry.id   4jgl
#
_exptl_crystal.id   1
#
_reflns_scale.group_code   1
#
#
loop_
_refln.crystal_id
_refln.wavelength_id
_refln.scale_group_code
_refln.index_h
_refln.index_k
_refln.index_l
_refln.status
_refln.pdbx_HL_A_iso
_refln.pdbx_HL_B_iso
_refln.pdbx_HL_C_iso
_refln.pdbx_HL_D_iso
1 1 1    0    0    3  o    0.28   -1.43    0.00    0.00
1 1 1    3    0   12  o    0.02    0.24    0.00    0.00
1 1 1    0    0   18  o    2.89    4.23    0.73   -1.26
1 1 1    0    0   24  o   -0.08   -4.39    0.86    1.74
1 1 1    0    0   30  o   23.29  -37.82   13.58    1.94
1 1 1    0    0   36  o    3.35    3.12    0.29   -0.96
1 1 1    0    1    0  o       ?       ?       ?       ?
1 1 1    0    1    1  o       ?       ?       ?       ?
1 1 1   12   11    7  o   -2.50    7.76    1.03    0.31
1 1 1   12   11    8  o  -50.91  153.61   31.01   32.58
1 1 1   12   11    9  o    5.73   -8.35    0.09    2.76
1 1 1   12   11   10  o  -27.65   30.85   -1.02    9.22
1 1 1   53    3    3  o   -0.31    0.46    0.00    0.00
1 1 1   53    3    4  o    0.32   -0.06    0.00    0.00
1 1 1   54    1    0  o   -0.27    0.00    0.00    0.00
1 1 1   54    1    1  o    0.47   -0.01    0.00    0.00
1 1 1   54    1    2  o   -0.18   -0.34   -0.01   -0.02
1 1 1   54    1    3  o   -0.02   -0.28    0.00    0.00
1 1 1   54    1    4  o    0.35    0.49   -0.01   -0.01
1 1 1   54    1    5  o    0.15   -0.48    0.00    0.00
#END
data_r4jglEsf
#
_cell.entry_id      4jgl
_cell.length_a      79.3130
_cell.length_b      79.3130
_cell.length_c      50.1030
_cell.angle_alpha   90.0000
_cell.angle_beta    90.0000
_cell.angle_gamma   120.0000
#
_diffrn.id                  1
_diffrn.crystal_id          1
_diffrn.ambient_temp        ?
_diffrn.crystal_treatment   ?
_diffrn.details             '  density modified experimental phases.'
#
_entry.id   4jgl
#
_exptl_crystal.id   1
#
_reflns_scale.group_code   1
#
#
loop_
_refln.crystal_id
_refln.wavelength_id
_refln.scale_group_code
_refln.index_h
_refln.index_k
_refln.index_l
_refln.status
_refln.phase_meas
_refln.pdbx_FWT
_refln.fom
1 1 1    0    0    3  o   41.29 1238.431  0.99
1 1 1    0    0   12  o  125.51 1995.770  1.00
1 1 1    0    0   18  o   99.07 807.187  0.98
1 1 1    0    0   24  o -122.68 491.014  0.97
1 1 1    0    0   30  o  -25.97 161.558  0.99
1 1 1    0    0   36  o   31.40  56.578  0.81
1 1 1   53    2    1  o -126.70  22.452  0.60
1 1 1   53    2    2  o   92.10  17.818  0.61
1 1 1   53    2    3  o  -93.89   7.406  0.27
1 1 1   53    2    4  o -168.56  10.492  0.43
1 1 1   53    3    3  o  127.04  10.290  0.35
1 1 1   53    3    4  o   -0.28   4.982  0.18
1 1 1   54    1    0  o  180.00   7.752  0.33
1 1 1   54    1    1  o   13.94   5.584  0.21
1 1 1   54    1    2  o -111.70   4.379  0.16
1 1 1   54    1    3  o  -79.85   4.164  0.15
1 1 1   54    1    4  o   56.34   8.051  0.32
1 1 1   54    1    5  o  -69.69   7.166  0.29
#END OF REFLECTIONS

"""


phil1str = """
selected_info {
  labels = False
  description = True
  wavelength = True
  n_reflections = True
  span = False
  minmax_data = True
  minmax_sigmas = False
  d_minmax = True
  data_sigdata_max=True
  unit_cell = True
  space_group = True
  n_centrics = False
  is_anomalous = False
  is_symmetry_unique = False
  n_sys_abs = False
  data_completeness = True
  data_compl_infty = False
  ano_completeness = False
  ano_mean_diff = False
  n_bijvoet = False
  n_singletons = False
}
wrap_labels = -20
"""


expected1str = """
Starting job
===============================================================================
33 Miller arrays in this dataset:
       Type      |   /   |  #HKLs  |     min,max data       |MaxDatSigDat|  d_min,d_max/   |     unit cell (a/, b/, c/, %s, %s, %s)      |   space group      |Data compl.|
         Integer |0.918401 |      15 |        1.0,         1.0|        nan |    1.25,   16.704| 79.322, 79.322, 50.113,     90,     90,    120 |     P 61 (No. 169) |0.00029017 |
         Integer |0.918401 |      15 |        1.0,         1.0|        nan |    1.25,   16.704| 79.322, 79.322, 50.113,     90,     90,    120 |     P 61 (No. 169) |0.00029017 |
         Integer |0.918401 |      15 |        1.0,         1.0|        nan |    1.25,   16.704| 79.322, 79.322, 50.113,     90,     90,    120 |     P 61 (No. 169) |0.00029017 |
          String |0.918401 |      15 |        nan,         nan|        nan |    1.25,   16.704| 79.322, 79.322, 50.113,     90,     90,    120 |     P 61 (No. 169) |0.00029017 |
       Amplitude |0.918401 |      14 |       15.6,      1055.8|      56.75 |    1.25,   16.704| 79.322, 79.322, 50.113,     90,     90,    120 |     P 61 (No. 169) |0.00034303 |
      Map coeffs |0.918401 |      15 |       16.9,      1790.1|        nan |    1.25,   16.704| 79.322, 79.322, 50.113,     90,     90,    120 |     P 61 (No. 169) |0.00029017 |
         Integer |0.918401 |      18 |        1.0,         1.0|        nan |    1.25,   25.056| 79.322, 79.322, 50.113,     90,     90,    120 |                  ? |       nan |
         Integer |0.918401 |      18 |        1.0,         1.0|        nan |    1.25,   25.056| 79.322, 79.322, 50.113,     90,     90,    120 |                  ? |       nan |
         Integer |0.918401 |      18 |        1.0,         1.0|        nan |    1.25,   25.056| 79.322, 79.322, 50.113,     90,     90,    120 |                  ? |       nan |
          String |0.918401 |      18 |        nan,         nan|        nan |    1.25,   25.056| 79.322, 79.322, 50.113,     90,     90,    120 |                  ? |       nan |
       Intensity |0.918401 |      18 |     -105.2,      1176.5|      5.389 |    1.25,   25.056| 79.322, 79.322, 50.113,     90,     90,    120 |                  ? |       nan |
         Integer |0.979338 |      17 |        1.0,         1.0|        nan |    1.25,   25.051| 79.313, 79.313, 50.102,     90,     90,    120 |                  ? |       nan |
         Integer |0.979338 |      17 |        2.0,         2.0|        nan |    1.25,   25.051| 79.313, 79.313, 50.102,     90,     90,    120 |                  ? |       nan |
         Integer |0.979338 |      17 |        1.0,         1.0|        nan |    1.25,   25.051| 79.313, 79.313, 50.102,     90,     90,    120 |                  ? |       nan |
          String |0.979338 |      17 |        nan,         nan|        nan |    1.25,   25.051| 79.313, 79.313, 50.102,     90,     90,    120 |                  ? |       nan |
       Intensity |0.979338 |      17 |      -44.3,  2.4913e+04|      13.69 |    1.25,   25.051| 79.313, 79.313, 50.102,     90,     90,    120 |                  ? |       nan |
         Integer |0.979108 |      19 |        1.0,         1.0|        nan |   1.361,   25.081|   79.4,   79.4, 50.162,     90,     90,    120 |                  ? |       nan |
         Integer |0.979108 |      19 |        3.0,         3.0|        nan |   1.361,   25.081|   79.4,   79.4, 50.162,     90,     90,    120 |                  ? |       nan |
         Integer |0.979108 |      19 |        1.0,         1.0|        nan |   1.361,   25.081|   79.4,   79.4, 50.162,     90,     90,    120 |                  ? |       nan |
          String |0.979108 |      19 |        nan,         nan|        nan |   1.361,   25.081|   79.4,   79.4, 50.162,     90,     90,    120 |                  ? |       nan |
       Intensity |0.979108 |      19 |    -1052.0,      8401.4|      10.21 |   1.361,   25.081|   79.4,   79.4, 50.162,     90,     90,    120 |                  ? |       nan |
         Integer |0.918401 |      20 |        1.0,         1.0|        nan |    1.25,   68.687| 79.313, 79.313, 50.103,     90,     90,    120 |                  ? |       nan |
         Integer |0.918401 |      20 |        1.0,         1.0|        nan |    1.25,   68.687| 79.313, 79.313, 50.103,     90,     90,    120 |                  ? |       nan |
         Integer |0.918401 |      20 |        1.0,         1.0|        nan |    1.25,   68.687| 79.313, 79.313, 50.103,     90,     90,    120 |                  ? |       nan |
          String |0.918401 |      20 |        nan,         nan|        nan |    1.25,   68.687| 79.313, 79.313, 50.103,     90,     90,    120 |                  ? |       nan |
       HL coeffs |0.918401 |      18 |      -1.87,      166.29|        nan |    1.25,   16.701| 79.313, 79.313, 50.103,     90,     90,    120 |                  ? |       nan |
         Integer |0.918401 |      18 |        1.0,         1.0|        nan |    1.25,   16.701| 79.313, 79.313, 50.103,     90,     90,    120 |                  ? |       nan |
         Integer |0.918401 |      18 |        1.0,         1.0|        nan |    1.25,   16.701| 79.313, 79.313, 50.103,     90,     90,    120 |                  ? |       nan |
         Integer |0.918401 |      18 |        1.0,         1.0|        nan |    1.25,   16.701| 79.313, 79.313, 50.103,     90,     90,    120 |                  ? |       nan |
          String |0.918401 |      18 |        nan,         nan|        nan |    1.25,   16.701| 79.313, 79.313, 50.103,     90,     90,    120 |                  ? |       nan |
  Floating-point |0.918401 |      18 |    -168.56,       180.0|        nan |    1.25,   16.701| 79.313, 79.313, 50.103,     90,     90,    120 |                  ? |       nan |
  Floating-point |0.918401 |      18 |      4.164,      1995.8|        nan |    1.25,   16.701| 79.313, 79.313, 50.103,     90,     90,    120 |                  ? |       nan |
  Floating-point |0.918401 |      18 |       0.15,         1.0|        nan |    1.25,   16.701| 79.313, 79.313, 50.103,     90,     90,    120 |                  ? |       nan |

===============================================================================
Job complete
""" %("\u00b0", "\u00b0", "\u00b0")



test2_cifstr = """
data_mytest
#
loop_
  _space_group_symop.id
  _space_group_symop.operation_xyz
  1  x,y,z
  2  -y,x-y,z+1/3
  3  -x+y,-x,z+2/3
#
_diffrn.id                  1
_diffrn.crystal_id          1
#
_diffrn_radiation_wavelength.id           1
_diffrn_radiation_wavelength.wavelength   0.997432
#
_reflns_scale.group_code   1
#
_space_group.crystal_system       trigonal
_space_group.IT_number            144
_space_group.name_H-M_alt         'P 31'
_space_group.name_Hall            ' P 31'
_symmetry.space_group_name_H-M    'P 31'
_symmetry.space_group_name_Hall   ' P 31'
_symmetry.Int_Tables_number       144
_cell.length_a                    50.000
_cell.length_b                    50.000
_cell.length_c                    40.000
_cell.angle_alpha                 90.000
_cell.angle_beta                  90.000
_cell.angle_gamma                 120.000
_cell.volume                      86602.540
loop_
  _refln.crystal_id
  _refln.wavelength_id
  _refln.scale_group_code
  _refln.index_h
  _refln.index_k
  _refln.index_l
  _refln.I
  _refln.SIGI
  _refln.MyMap
  _refln.PHIMyMap
  _refln.Oink
  _refln.bleep
  _refln.FOM
  _refln.A_calc
  _refln.B_calc
1 1 1   1  -2   3   11.205  13.695    1   180    24.9  12.429     0    2.3   -3.2
1 1 1   0   0  -4    6.353   6.353    3   120  14.521       ?   0.1   12.4    4.7
1 1 1   1   2   3   26.167  24.921  0.8    90       ?  -3.328  0.25   -1.5   -4.8
1 1 1   0   1   2    14.94   6.225    2    60   3.738   3.738  0.35    7.9   10.2
1 1 1   1   0   2     2.42  11.193    4     0  22.429     4.9   0.4    8.3   22.5
1 1 1  -1   1  -2   24.921  26.167    1   -60  28.635       ?   0.5      ?      ?
1 1 1   2  -2  -2   16.185   8.715    1   -90       ?  -5.521   0.6   -9.4    8.6
1 1 1  -2   1   0   11.798   4.538    5  -120   3.328  10.738  0.75   -1.4    6.3
1 1 1   1   0  -2   21.183  27.413    ?     ?   3.738       ?     ?    9.1    7.7
1 1 1   0   0   2     4.98  21.165    6   135   19.92   19.92     1    3.9   -2.1
1 1 1  -1  -2   3    456.5    36.3    ?     ?       ?       ?     ?   -3.1    5.9
1 1 1   0   0   4   654.36   9.123    ?     ?       ?       ?     ?    6.9   13.8
1 1 1   1   2  -3  -78.234   76.37    ?     ?       ?       ?     ?      ?      ?
1 1 1   0  -1   2   369.78   11.29    ?     ?       ?       ?     ?    0.7   -3.2
1 1 1  -1   0   2  672.899   56.14    ?     ?       ?       ?     ?    7.8    0.2
1 1 1  -1   1   2   90.316    78.9    ?     ?       ?       ?     ?    2.8   11.5
1 1 1   0   0  -3        ?       ?    ?     ?       ?  38.635     ?    7.1    3.8

"""

phil2str = """
selected_info {
  labels = True
  description = True
  wavelength = False
  n_reflections = True
  span = True
  minmax_data = True
  minmax_sigmas = False
  data_sigdata_max = False
  d_minmax = True
  unit_cell = False
  space_group = True
  n_centrics = False
  is_anomalous = True
  is_symmetry_unique = False
  n_sys_abs = False
  data_completeness = True
  data_compl_infty = False
  ano_completeness = False
  ano_mean_diff = False
  n_bijvoet = False
  n_singletons = False
}
wrap_labels = -20
"""

expected2str ="""
Starting job
===============================================================================
9 Miller arrays in this dataset:
 Labels          |       Type      |  #HKLs  |               Span              |     min,max data       |  d_min,d_max/   |   space group      |Anomalous|Data compl.|
mytest,_refln.crystal_id
                 |         Integer |      17 |         (-2, -2, -4), (2, 2, 4) |        1.0,         1.0|    10.0,     25.0|     P 31 (No. 144) |    True |       nan |
mytest,_refln.wavelength_id
                 |         Integer |      17 |         (-2, -2, -4), (2, 2, 4) |        1.0,         1.0|    10.0,     25.0|     P 31 (No. 144) |    True |       nan |
mytest,_refln.scale_group_code
                 |         Integer |      17 |         (-2, -2, -4), (2, 2, 4) |        1.0,         1.0|    10.0,     25.0|     P 31 (No. 144) |    True |       nan |
mytest,_refln.I,_refln.SIGI
                 |  Floating-point |      16 |         (-2, -2, -4), (2, 2, 4) |    -78.234,       672.9|    10.0,     25.0|     P 31 (No. 144) |    True |       nan |
mytest,_refln.MyMap,_refln.PHIMyMap
                 |      Map coeffs |       9 |         (-2, -2, -4), (2, 2, 3) |        0.8,         6.0|    10.0,     25.0|     P 31 (No. 144) |    True |  0.067308 |
mytest,_refln.Oink
                 |  Floating-point |       8 |         (-2, -2, -4), (1, 1, 3) |      3.328,      28.635|    10.0,     25.0|     P 31 (No. 144) |    True |       nan |
mytest,_refln.bleep
                 |  Floating-point |       8 |         (-2, -2, -3), (2, 2, 3) |     -5.521,      38.635|  10.337,     25.0|     P 31 (No. 144) |   False |   0.13462 |
mytest,_refln.FOM
                 |  Floating-point |       9 |         (-2, -2, -4), (2, 2, 3) |        0.0,         1.0|    10.0,     25.0|     P 31 (No. 144) |    True |  0.067308 |
mytest,_refln.A_calc,_refln.B_calc
                 |      Map coeffs |      15 |         (-2, -2, -4), (2, 2, 4) |     3.2757,      23.982|    10.0,     25.0|     P 31 (No. 144) |    True |       nan |

===============================================================================
Job complete
"""



testhklstr = """!FORMAT=XDS_ASCII    MERGE=FALSE    FRIEDEL'S_LAW=TRUE
!OUTPUT_FILE=XDS_ASCII.HKL        DATE=10-Aug-2012
!Generated by CORRECT   (VERSION  March 15, 2012)
!PROFILE_FITTING= TRUE
!NAME_TEMPLATE_OF_DATA_FRAMES=../../img/x4_1_?????.cbf CBF
!DATA_RANGE=       1     360
!ROTATION_AXIS=  0.999993 -0.000046 -0.003827
!OSCILLATION_RANGE=  1.000000
!STARTING_ANGLE=     0.000
!STARTING_FRAME=       1
!INCLUDE_RESOLUTION_RANGE=    50.000     0.798
!SPACE_GROUP_NUMBER=    1
!UNIT_CELL_CONSTANTS=     7.484    13.661    21.131  94.941  96.598  99.633
!UNIT_CELL_A-AXIS=     4.886    -4.416     3.556
!UNIT_CELL_B-AXIS=    -8.390    -9.505    -5.088
!UNIT_CELL_C-AXIS=    11.220     2.222   -17.768
!REFLECTING_RANGE_E.S.D.=     0.837
!BEAM_DIVERGENCE_E.S.D.=     0.136
!X-RAY_WAVELENGTH=  0.700010
!INCIDENT_BEAM_DIRECTION=  0.003855  0.003610  1.428541
!FRACTION_OF_POLARIZATION=   0.990
!POLARIZATION_PLANE_NORMAL=  0.000000  1.000000  0.000000
!AIR=  0.000107
!SILICON=  1.347949
!SENSOR_THICKNESS=  0.320000
!DETECTOR=PILATUS
!OVERLOAD=   1048500
!DIRECTION_OF_DETECTOR_X-AXIS=   1.00000   0.00000   0.00000
!DIRECTION_OF_DETECTOR_Y-AXIS=   0.00000   1.00000   0.00000
!DETECTOR_DISTANCE=   170.465
!ORGX=   1248.63  ORGY=   1252.18
!NX=  2463  NY=  2527    QX=  0.172000  QY=  0.172000
!VARIANCE_MODEL=  1.494E+00  1.180E-03
!NUMBER_OF_ITEMS_IN_EACH_DATA_RECORD=12
!ITEM_H=1
!ITEM_K=2
!ITEM_L=3
!ITEM_IOBS=4
!ITEM_SIGMA(IOBS)=5
!ITEM_XD=6
!ITEM_YD=7
!ITEM_ZD=8
!ITEM_RLP=9
!ITEM_PEAK=10
!ITEM_CORR=11
!ITEM_PSI=12
!END_OF_HEADER
     0     0    -1  4.691E+02  2.124E+01  1232.6  1282.1    271.8 0.02777 100  30   16.89
     0     0    -1  4.685E+02  2.084E+01  1232.7  1226.9     94.1 0.02777 100  27 -164.84
     0     0     1  4.884E+02  2.164E+01  1270.1  1281.9     91.8 0.02777  99  22  163.53
     0     0     1  5.193E+02  2.330E+01  1270.0  1227.1    274.1 0.02777 100  25  -15.58
     0     0    -2  4.858E+04  2.040E+03  1213.9  1199.3     95.3 0.05557 100  20 -165.49
     0     0    -2  4.852E+04  2.038E+03  1213.8  1309.6    270.6 0.05553 100  16   17.54
     0     0     2  4.915E+04  2.064E+03  1288.9  1309.5     90.7 0.05557 100  16  162.88
     0     0     2  4.800E+04  2.017E+03  1288.7  1199.6    275.3 0.05558 100  17  -14.92
     0     0    -3  2.103E+04  8.846E+02  1195.0  1171.6     96.5 0.08343 100  24 -166.14
     0     0    -3  2.041E+04  8.589E+02  1194.8  1337.3    269.4 0.08328 100  27   18.20
"""


phil3str = """
selected_info {
  labels = True
  description = True
  wavelength = False
  n_reflections = True
  span = False
  minmax_data = True
  minmax_sigmas = False
  d_minmax = True
  unit_cell = False
  space_group = True
  n_centrics = False
  is_anomalous = True
  is_symmetry_unique = False
  n_sys_abs = False
  data_completeness = True
  data_compl_infty = True
  ano_completeness = True
  ano_mean_diff = False
  n_bijvoet = True
  n_singletons = True
}
merge_equivalents = True
wrap_labels = -20
"""


expected3str = """
Starting job
===============================================================================
1 Miller arrays in this dataset:
 Labels          |       Type      |  #HKLs  |     min,max data       |  d_min,d_max/   |   space group      |Anomalous|Data compl.|Compl.inf.|Ano.complete|#Bijvoets|#Singletons|
 iobs,sigma_iobs |       Intensity |       5 |     468.79,  4.8562e+04|   6.956,   20.869|        P 1 (No. 1) |    True |   0.22727 |  0.22727 |    0.18182 |       2 |         1 |

===============================================================================
Job complete
"""


testscastr = """    1
 -987
    44.151    44.151    44.151    80.000    80.000    80.000 h3
   1   0   0    -0.2     0.4
   2  -1   0     0.2     0.6
   2  -1   2  2471.3   119.7
   2   0   1  3166.3   237.6  2602.5   113.7
   3   0   1 10052.2   496.7 10107.3   504.2
   3   0   2 15486.2   469.7 15548.0   590.2
   3   0   3  4730.2   167.5  4454.7   188.8
   3   0   4  9840.6   543.6  8136.2   375.4
   4  -3   1 23731.2   553.5 20271.4   584.9
   4  -3   2  1311.5    57.1  1342.2    49.4
   4  -3   3   556.5    22.2  1231.4    56.0
   4  -3   4 17415.2   642.7 21023.1  1031.7
   4  -3   5 27394.1  1103.3 29405.3  2926.8
   4  -3   6  1462.1    75.0  1507.1   170.9
   4  -2   0  3763.1   166.4
   4  -2   1 15626.8   900.8 15210.5   706.0
   4  -2   2  5633.4   164.3  6092.0   186.0
   4  -2   3   236.7    12.3   428.2    17.7
   4  -2   4   837.0    40.5   762.2    45.4
   5  -3   2  6569.5   193.7  7542.3   254.6
   5  -3   3  6283.6   190.9  7280.4   241.6
   5  -3   4   567.3    36.4   949.3    46.8
   5  -3   5    77.0    43.2    26.9    58.7
   5  -3   6  3170.0   185.7  3134.1   175.3
   5  -3   7  1859.2   124.2  1936.3   158.1
   5  -3   8  3124.1   253.3  3047.0   216.0
   5  -3   9  2296.7   138.1
   5  -3  18   -11.8    53.3
   5  -2   0 10279.5   312.4
   6  -5   1  7179.4   200.2  7433.3   194.9
   6  -5   2  8662.2   388.1 10568.4   365.1
   6  -5   3 15441.5   598.0 14331.0   551.3
"""

phil4str = """
selected_info {
  labels = True
  description = True
  wavelength = False
  n_reflections = True
  span = False
  minmax_data = True
  minmax_sigmas = True
  d_minmax = True
  unit_cell = False
  space_group = True
  data_sigdata=True
  n_centrics = False
  is_anomalous = True
  is_symmetry_unique = False
  n_sys_abs = False
  data_completeness = True
  data_compl_infty = False
  ano_completeness = True
  ano_mean_diff = False
  n_bijvoet = True
  n_singletons = True
}
wrap_labels = -10
"""

expected4str = """
Starting job
===============================================================================
1 Miller arrays in this dataset:
 Labels          |       Type      |  #HKLs  |     min,max data       |     min,max sigmas     | DatSigDat|  d_min,d_max/   |   space group      |Anomalous|Data compl.|Ano.complete|#Bijvoets|#Singletons|
I(+),SIGI(+),I(-),SIGI(-)
                 |       Intensity |      57 |      -11.8,  2.9405e+04|        0.4,      2926.8|    21.45 |   2.293,   43.002|   R 3 :R (No. 146) |    True | 0.0059511 |  0.0052203 |      25 |         7 |

===============================================================================
Job complete
"""


def test_hklinfo_run(cifstr, filename, philstr, expectedstr):
  with open(filename, "w") as fh:
    fh.write(cifstr)
  with open("philinput.txt", "w") as fh:
    fh.write(philstr)

  obj = subprocess.Popen("cctbx.HKLinfo %s philinput.txt" %filename,
                         shell=True,
                         stdin = subprocess.PIPE,
                         stdout = subprocess.PIPE,
                         stderr = subprocess.STDOUT)
  out,err = obj.communicate()
  fullstdout = out.decode().replace("\r\n", "\n") # omit \r\n line endings on Windows
  #import code, traceback; code.interact(local=locals(), banner="".join( traceback.format_stack(limit=10) ) )
  assert (contains_substring( fullstdout, expectedstr ) )


# =============================================================================
if (__name__ == '__main__'):
  test_hklinfo_run(test1_cifstr, "test-sf.cif", phil1str, expected1str)
  test_hklinfo_run(test2_cifstr, "test-sf.cif", phil2str, expected2str)
  test_hklinfo_run(testhklstr, "test.hkl", phil3str, expected3str)
  test_hklinfo_run(testscastr, "test.sca", phil4str, expected4str)


  print('OK')


 *******************************************************************************
